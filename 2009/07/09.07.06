00:00:08 <jeffwheeler> Twey: Not with unsafePerformIO! We're going to hide that.
00:00:13 <Dae> heh, actually -O means your random numbers will all be the same
00:00:25 <Dae> not even sure if you need -O....
00:02:53 <solidsnack> Dae: I've used Haskell for awhile and don't know histozygisms.
00:03:56 <Twey> Dae: Pardon?
00:04:59 <Dae> Twey: using unsafePerformIO to make random pure will make it return the same random number every time, no?
00:05:09 <Twey> Dae: Ah
00:05:20 <Twey> Possibly
00:05:23 <mmorrow> copumpkin: heh, wow this opendarwin vm image is pretty epic (some random prog is dumping error msgs to the console every 10 seconds, you can only be root, halt/shutdown are broken, no gcc, w/in 10 minutes some key will stick requiring a reboot, header files are nowheres to be found, ... :)
00:05:35 <copumpkin> lol
00:05:36 <Twey> Not necessarily â€” it depends what optimisations get applied
00:05:37 <mmorrow> haha
00:05:39 <copumpkin> wow, that's an awesome vm
00:05:52 <solidsnack> LOLz
00:05:53 <mmorrow> i'm literally laughing
00:05:59 <mmorrow> it's like a friggin assault
00:05:59 <Twey> Nice :-P
00:06:15 * mmorrow tries to install osx somehow
00:07:17 <Dae> Twey: really? I thought it would just evaluate the function once and then return that result every time, considering we told it it was a pure function
00:07:59 <copumpkin> mmorrow: search for osx86
00:09:11 <mmorrow> copumpkin: i've actually got an osx cd somewhere, just no cd-drive..
00:09:22 <copumpkin> mmorrow: it won't install on non-macs
00:09:26 <mmorrow> goo
00:09:35 * mmorrow searches for osx86
00:09:38 <copumpkin> :P
00:09:50 <copumpkin> or hackint0sh
00:11:11 <Dae> is there a haskell compiler for android?
00:12:28 <wmealing_> Dae, if you find something that works
00:12:28 <blackh> Dae: Unlikely
00:12:33 <wmealing_> let me know.. I am _very_ interested
00:13:49 <Dae> yeah, just noticed that the android api is basicly java, so it would be tricky
00:14:55 <wmealing_> I dont think that haskell can target the JVM.. so I'd imagine its a while off yet
00:15:13 <jeffwheeler> You might want to search -cafe; it's definitely been mentioned a few times, there, but possibly only to deny the existence, I don't know.
00:16:34 <hackagebot> hspresent 0.2.1 - A terminal presentation tool (EvanKlitzke)
00:18:56 <Twey> Dae: It might do
00:19:01 <Twey> There's no guarantee that's what will happen
00:19:06 <Twey> That's an optimisation
00:19:23 <Twey> Also, the result might get garbage-collected at some point and be evaluated again
00:21:10 <wmealing_> jeffwheeler, what is -cafe ?
00:21:21 <jeffwheeler> wmealing_: haskell-cafe@haskell.org, the mailing list
00:21:39 <mmorrow> copumpkin: um, i'm not sure if this is obvious, but howtf /are/ you supposed to get the .iso they're referring to on osx86?
00:21:45 <Dae> what exaclty does ghc need to be compiled? just any c++ compiler?
00:21:52 <copumpkin> mmorrow: probably pirate bay or some other shady means :/
00:21:56 <mmorrow> ahh, ok
00:21:57 <wmealing_> ah
00:22:00 <copumpkin> mmorrow: I haven't actually done it myself
00:22:03 <mauke> Dae: no, it needs ghc
00:22:52 <Dae> mauke: I sense a possible problem there
00:23:35 <mmorrow> (not to be beating a dead horse, but) these are the things i don't like about apple stuff :)
00:23:52 <Saizan> Dae: you can bootstrap via C
00:24:23 <mmorrow> Dae: there's a howto page on the ghc wiki
00:25:13 <Dae> ok, I'll go have a look. Android folks released a c++ SDK a couple of weeks ago, so maybe it's possible. Possibly easier if I had an android phone though
00:25:42 <wmealing_> you dont need an android phone
00:25:44 <wmealing_> to do either
00:26:02 <wmealing_> the sdk comes with an emulator that really is close enough
00:26:30 <wmealing_> I was able to compile a vpn client in C , i'm mid hooking it up in the java code now
00:26:43 <wmealing_> but its essentially vpnc with the glibc specifics hacked / removed
00:36:20 <Dae> "grasp the Universe as it reall is"....hmmm.... I think that might be a wee bit tougher than it sounds
00:40:21 <Twey> Dae: If not nonsensical
00:41:51 <Dae> Twey: It is in a scientific sense, might not be in a philisophical on....
00:42:12 <Twey> I think that's the other way around
00:42:25 <Twey> Empirically speaking, it's possible, if only just
00:42:46 <Dae> Empirically speaking it is not possible
00:43:06 <Twey> How do you figure that?
00:43:43 <Dae> well, so see the universe as it really is we need to know everything there is to know about it, no?
00:44:08 <Dae> which would require storage space outside the universe
00:44:09 <Twey> Certainly not
00:44:14 <Dae> no?
00:44:33 <Twey> He said only â€˜the universe as it really isâ€™, not â€˜*all* the universe as it really isâ€™
00:44:39 <Dae> point taken
00:44:59 <Dae> you're right then
00:46:02 * Dae shouldn't try arguing scientific theory when sleepy
00:50:21 <wmealing_> grasp the universe as it really is means "dont think about the maybes, deal with your problems now"
00:50:22 <wmealing_> yes ?
00:50:49 <Dae> seems like an interpretation?
00:50:59 <rocketman> I don't think it means anything, kinda like "He took a face from the ancient gallery.."
00:51:04 <wmealing_> ah
00:51:14 <rocketman> It's just words stuck together
00:51:19 <opqdonut> rocketman: that does mean something!
00:51:43 <opqdonut> it's a reference to the many kinslayers in classic literature
00:51:47 <Dae> words stuck together do not have meaning? This could change my view of life a bit
00:59:21 <Peaker> quicksilver: you here?
01:01:50 <ezeike> Having a hard time finding documentation on <+> and .|. anyone know of some?
01:02:02 <Twey> :t <+>
01:02:03 <lambdabot> parse error on input `<+>'
01:02:07 <Twey> :t (<+>)
01:02:08 <lambdabot>     Ambiguous occurrence `<+>'
01:02:08 <lambdabot>     It could refer to either `Control.Arrow.<+>', imported from Control.Arrow at /home/cale/.lambdabot/State/L.hs:4:0-19
01:02:08 <lambdabot>                           or `Text.PrettyPrint.HughesPJ.<+>', imported from Text.PrettyPrint.HughesPJ at /home/cale/.lambdabot/State/L.hs:54:0-46
01:02:11 <Cynner> http://www.lostworlds.lv/go.php?1139730844
01:02:12 <Twey> Gah
01:02:14 <Saizan> how'd you call a predicate that tells you if there are documentations to be generated for a given package?
01:02:21 <Twey> Which did you mean, ezeike?
01:02:34 <Twey> Saizan: areDocs
01:03:39 <ezeike> twey: some docs that helpme understand this: conf xmproc = xfceConfig { manageHook = manageDocks <+> myManageHook <+> scratchpadManageHookDefault
01:03:45 <Saizan> ezeike: you should try in hoogle or hayoo
01:03:50 <Peaker> Anyone knows accumE?
01:04:03 <ezeike> and ((mod1Mask .|. shiftMask, xK_period), (moveTo Next NonEmptyWS))
01:05:33 <doserj> (.|.) is bitwise-or (defined for Bits a => a), <+> is the mplus-equivalent for Arrows
01:05:37 <ezeike> saizan: thanks, didn't know about those
01:05:54 <Saizan> ezeike: ah, in xmonad, .|. gives you the or of the bitmasks, so it means that you've to press both keys, iirc
01:06:02 <Twey> :t Control.Arrow.(<+>)
01:06:04 <lambdabot> Couldn't find qualified module.
01:06:11 <Twey> :t (Control.Arrow.<+>)
01:06:12 <lambdabot> forall (a :: * -> * -> *) b c. (ArrowPlus a) => a b c -> a b c -> a b c
01:06:16 <Twey> I always do that
01:06:41 <ezeike> k can't quite grasp what that means yet
01:07:28 <Twey> ezeike: It takes two instances of ArrowPlus (which is an arrow with <+> defined on it) and adds them together to yield a new ArrowPlus
01:09:13 <mauke> except this is xmonad, so (<+>) :: ManageHook -> ManageHook -> ManageHook
01:12:12 <Peaker> Does anyone here know Reactive? I think I'm seeing a serious problem with accumE/scanlE
01:15:12 <desp> Anyone familiar with gtk2hs?
01:15:40 <mxc> ?seen conal
01:15:40 <lambdabot> I saw conal leaving #haskell, #ghc, #haskell-in-depth, #haskell-iphone and #haskell-blah 3h 12m 13s ago, and .
01:15:52 <mxc> 3 hrs to slow peaker
01:16:02 <desp> I'm trying to figure out Graphics.UI.Gtk.Gdk.EventM
01:16:09 <Peaker> mxc: conal?
01:16:09 <mxc> s/to/too
01:16:18 <mxc> didn't he write it?
01:16:29 <desp> Why isn't  window `on` destroyEvent $ tryEvent (liftIO mainQuit)  equivalent to   onDestroy window mainQuit  ?
01:19:01 <mxc> peaker, iirc, reactive is conal's project..  if you catch him, he's probably familiar wth it
01:19:11 <Peaker> it is
01:24:40 <kowey> trying to define an instance for Arbitrary - anybody have tips on how to say something like "choose an arbitrary sublist of xs"?
01:25:41 <mauke> for each element: include with probability 0.5
01:26:00 <opqdonut> yeah
01:26:09 <opqdonut> :t
01:26:15 <opqdonut> woops
01:26:19 <opqdonut> :t filterM
01:26:20 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
01:26:48 <opqdonut> you could use something like "filterM (const arbitrary) yourlist"
01:27:05 <opqdonut> as an analogous to:
01:27:17 <opqdonut> > filterM (const [True,False]) [1,2,3]
01:27:18 <lambdabot>   [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
01:27:54 <phenrique> Dae?
01:28:14 <phenrique> Dae ?
01:28:28 <harlekin> @src filterM
01:28:28 <lambdabot> Source not found. I feel much better now.
01:29:30 <kowey> I think that makes sense
01:30:10 <kowey> ... may never achieve needed monad fluency, but at least getting to a point where I can understand why stuff like that makes sense if not come up with it myself
01:30:53 <opqdonut> harlekin: it's basically "filterM p (x:xs) = do { b <- p x; if b then (x:filterM p xs) else filterM p xs }"
01:31:05 <harlekin> opqdonut, thanks (:
01:31:22 <opqdonut> kowey: you might just want to "inline" that definition i gave
01:31:29 <opqdonut> the code will be more clear and elementary
01:31:46 <opqdonut> for some twisted reason i prefer to write these things with filterM ;)
01:33:35 <fasta> opqdonut: that then branch is not going to work :)
01:33:56 <opqdonut> fasta: ah?
01:34:42 <fasta> opqdonut: oh, never mind.
01:34:45 <boml> what is the prefered way to convert a string like "2009-02-15 14:20:11" to seconds_since_epoch in haskell?
01:36:22 <fasta> opqdonut: I thought you wanted something that worked for all monads.
01:39:00 <opqdonut> fasta: what branch were you referring to? the if in my definition of filterM?
01:39:21 <Dae> phenrique: yes?
01:40:00 <fasta> opqdonut: yes, I thought you wanted to have the actual filterM type, not the opqdonut filterM type.
01:40:20 <opqdonut> ah :)
01:40:30 <phenrique> i am thinking about how get it one User from file
01:40:38 <Saizan> ?type let filterM p (x:xs) = do { b <- p x; if b then (x:filterM p xs) else filterM p xs } in filterM
01:40:39 <lambdabot> forall b. (b -> [Bool]) -> [b] -> [b]
01:40:58 <phenrique> Dae, i am thinking about how get it one User from file
01:41:08 <opqdonut> yeah, missing one return
01:41:22 <Dae> phenrique: get the records?
01:41:28 <phenrique> example
01:41:29 <phenrique> Usuario {matricula = "06n10234", nome = "Paulo Henrique", endereco = "r. SADA", telefone = "3211-3498", livrosEmprestados = []}
01:41:38 <phenrique> various user in file
01:41:41 <Saizan> ?type let filterM p (x:xs) = do { b <- p x; if b then (x:) <$> filterM p xs else filterM p xs } in filterM
01:41:42 <lambdabot> forall t (m :: * -> *). (Functor m, Monad m) => (t -> m Bool) -> [t] -> m [t]
01:42:06 <Dae> well, depends on how you store the users and how the file is set up
01:42:35 <opqdonut> harlekin: that should've been something like "{ b <- p x; fxs <- filterM p xs; return $ if p then x:fxs else fxs }"
01:43:12 <phenrique> Dae
01:43:13 <phenrique> data Usuario = Usuario {
01:43:13 <phenrique>  	 matricula :: String
01:43:13 <phenrique> 	,nome :: String
01:43:13 <phenrique> 	,endereco :: String
01:43:13 <phenrique> 	,telefone :: String
01:43:15 <phenrique> 	,livrosEmprestados :: [String]
01:43:17 <phenrique> } deriving (Show)
01:43:19 <phenrique> data Livro = Livro {
01:43:21 <phenrique> 	 codigo :: String
01:43:23 <phenrique> 	,titulo :: String
01:43:25 <phenrique> 	,quantidade:: Int
01:43:27 <Dae> phenrique: don't pase code in chat
01:43:29 <phenrique> } deriving (Show)
01:43:30 <Dae> *paste
01:43:31 <phenrique> :)
01:43:33 <Dae> not that much
01:43:40 <phenrique> ok
01:44:02 <Saizan> phenrique: if you also derive Read you can use read to deserialize from the representation you get from show
01:44:05 <Dae> phenrique:  use http://hpaste.org/ if you want
01:46:15 <phenrique> humm
01:48:34 <phenrique> Saizan, but how i can the Users (one in a line in a file)?
01:48:45 <phenrique> verify \n ?
01:49:19 <phenrique> Usuario {matricula = "06n10234", nome = "Paulo Henrique", endereco = "r. SADA", telefone = "3211-3498", livrosEmprestados = []}
01:49:42 <phenrique> Usuario {matricula = "06nxsaf4", nome = "Paulo sfaenrique", endereco = "r. SAdDA", tedlefone = "321d1-3498", livrosEmprestados = []}
01:51:03 <phenrique> i have to do one list with all users, for to can locate some user
01:55:49 <boml> is there a good strip or trim function for strings?
01:56:47 <kowey> I have a personal odd-and-ends.hs with trim = reverse . dropWhile isSpace . reverse . dropWhile isSpace in it... which may not be what you'd call good :-)
01:57:05 <blackh> boml: http://www.serpentine.com/blog/2009/07/06/first-steps-with-haskell-text-api-improvement/ <-- one is being worked on as we speak
01:57:30 <copumpkin> I wrote a fancy trim once
01:57:38 <Cale> If you don't mind compressing whitespace in the middle, there's  unwords . words
01:57:51 <boml> one shouldn't have to write this kind of stuff imho.
01:57:59 <Cale> > unwords . words $ "    here   is       some   \t\n  text    "
01:58:01 <lambdabot>   "here is some text"
01:58:05 <boml> kind of nuts and bolts
01:58:27 <copumpkin> > groupBy ((==) `on` isSpace) $ "    here   is       some   \t\n  text    "
01:58:29 <lambdabot>   ["    ","here","   ","is","       ","some","   \t\n  ","text","    "]
01:59:03 <copumpkin> > join . tail . init . groupBy ((==) `on` isSpace) . (" "++) . (++" ") $ "    here   is       some   \t\n  text    "
01:59:04 <lambdabot>   "here   is       some   \t\n  text"
01:59:10 <Cale> There's might be something in a library on Hackage... but there are so many minor variations you might want.
01:59:21 <Cale> copumpkin: haha
01:59:22 <Petrosian> boml: http://www.haskell.org/ghc/docs/latest/html/libraries/time/Data-Time-Format.html#2 Maybe that's what you're after?
01:59:32 <copumpkin> :P
01:59:49 <boml> Petrosian: yes i'm trying it out right now. thx
01:59:57 <copumpkin> boml: there you go!
02:00:27 <mauke> :t let rtrim s = case span isSpace s of (_, []) -> ""; (t, r) -> t ++ r ++ rtrim s in rtrim
02:00:28 <lambdabot> [Char] -> [Char]
02:00:46 <Cale> Oh, was boml also looking for time formatting?
02:02:46 <boml> just like to remove whitespace of the end of a string.
02:04:07 <mauke> > let rtrim s = case span isSpace s of (_, []) -> ""; (t, r) -> t ++ r ++ rtrim s in rtrim "  a  b  c  "
02:04:09 <lambdabot>   "  a  b  c    a  b  c    a  b  c    a  b  c    a  b  c    a  b  c    a  b  ...
02:04:13 <mauke> haha, what
02:04:16 <Saizan> phenrique: you can use "map read (lines filecontent)"
02:04:31 * mauke slaps his brain
02:04:31 <Cale> mauke: recursion ;)
02:05:02 <quicksilver> Peaker: nope :)
02:05:11 <Cale> boml: You can always reverse it and then dropWhile isSpace
02:05:33 <phenrique> I will test Saizan
02:05:46 <mauke> > let rtrim s = case span isSpace s of (_, []) -> ""; (t, r) -> t ++ (let (r, s') = break isSpace r in r ++ rtrim s') in rtrim "  a  b  c  "
02:05:51 <lambdabot>   mueval-core: Prelude.read: no parse
02:05:51 <lambdabot>  mueval: ExitFailure 1
02:05:51 <boml> Cale: yes, I just thought there was something in the standard.
02:07:03 <Cale> boml: There are very few text-specific operations in the standard... I think it's basically the Read and Show classes, words, unwords, lines, unlines, and then the various operations on Char
02:07:16 <copumpkin> boml: my code removes whitespace at beginning and end of string!
02:07:29 <boml> Cale: with standard I meant ghc.
02:10:15 <RayNbow> hmm, a monoid M corresponds to a category with a single object and arrows being elements from M... right?
02:10:40 <phenrique> Saizan
02:10:43 <phenrique> teste: Prelude.read: no parse
02:10:43 <phenrique> ?
02:10:47 <kowey> anybody care to comment on http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6570#a6570 ? mainly want to see if I've got the right idea
02:11:26 <kowey> for example, using sequence (repeat arbitrary) to get a random list of random stuff
02:11:41 <Saizan> phenrique: have you specified the result type?
02:12:04 <Saizan> phenrique: adding  :: [User]
02:12:33 <Saizan> phenrique: (map read (lines filecontent) :: [Usuario])
02:12:40 <phenrique> "(map read (lines conteudo))::[User]"?
02:12:45 <phenrique> ok
02:13:22 <Saizan> phenrique: if it still gives you an error there has to be some error in the string you're trying to parse
02:13:38 <quicksilver> RayNbow: yes.
02:14:20 <RayNbow> quicksilver: and composition corresponds to the monoid's binary operator, right?
02:15:01 <Cale> RayNbow: yeah
02:15:58 <Cale> RayNbow: A category with one object (but possibly many arrows) is a monoid. A category with at most one arrow between any two objects (but possibly many objects) is a preorder.
02:16:15 <RayNbow> the only thing I was wondering about...
02:16:26 <RayNbow> u . v =? u `mappend` v
02:16:27 <RayNbow> or
02:16:32 <RayNbow> u . v =? v `mappend` u
02:16:35 <Cale> either way
02:17:08 <Cale> Clearly the first is a bit more natural though.
02:17:23 <Cale> (but not in any formal sense)
02:18:04 <Cale> (You'll get a monoid no matter how you do it)
02:18:30 * RayNbow nods
02:18:55 <RayNbow> I was just wondering what was considered the "correct" or "natural" way
02:22:51 <phenrique> Saizan
02:22:56 <phenrique> http://pastebin.com/m37e548ff
02:23:20 <phenrique>     No instance for (Read Usuario)
02:23:20 <phenrique>       arising from a use of `read' at Main.hs:126:43-46
02:23:20 <phenrique>     Possible fix: add an instance declaration for (Read Usuario)
02:23:20 <phenrique>     In the first argument of `map', namely `read'
02:23:20 <phenrique>     In the expression: map read (lines conteudo) :: [Usuario]
02:23:21 <phenrique>     In the definition of `cadastros':
02:23:23 <phenrique>         cadastros = map read (lines conteudo) :: [Usuario]
02:23:33 <opqdonut> please, don't paste it here
02:29:33 <Saizan> phenrique: you need to add Read to the deriving clause for Usuario
02:29:56 <Saizan> phenrique: i.e. it should look like data Usuario = .....  deriving (Read,Show)
02:30:14 <phenrique> hum
02:30:24 <Saizan> otherwise Usuario won't have a Read instance
02:30:27 <Saizan> ?type read
02:30:28 <lambdabot> forall a. (Read a) => String -> a
02:30:57 <RayNbow> kowey: sequence (repeat arbitrary) should work okay
02:31:24 <Saizan> RayNbow: or not terminate?
02:31:54 <kowey> I'm actually using sequence (take sz $ repeat arbitrary)
02:31:59 <RayNbow> generate 1 (mkStdGen 1) $ do {xs <- sequence (repeat (arbitrary :: Gen Int)); s <- arbitrary; return $ sum (take 10 xs) + s }   -- this works
02:34:23 <RayNbow> kowey: btw, you might want to use replicateM
02:34:25 <RayNbow> :t replicateM
02:34:26 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
02:34:42 <RayNbow> so: replicateM sz arbitrary
02:35:05 <kowey> thanks, RayNbow
02:35:17 <RayNbow> np :)
02:37:08 <ian-> Has anyone read "Introduction to Functional Programming Using Haskell"?
02:37:23 <LeCamarade> Why is Arch Linux seemingly having an affair with Haskell?
02:37:46 <pozic> LeCamarade: dons uses it. Just like with OpenBSD.
02:38:08 <pozic> LeCamarade: OpenBSD had decent support when dons used it. Not anymore.
02:38:15 <LeCamarade> Hmm. So, which one does dons use. Last I checked, it was OpenBSD.
02:38:20 <LeCamarade> Oh, so he moved.
02:38:29 * LeCamarade wonders why ...
02:41:09 <desp> Is there a way to escape the Render monad (Graphics.Rendering.Cairo)?
02:44:52 <doserj> what do you mean with escape?
02:45:18 <phenrique> Saizan ?
02:45:42 <phenrique> and the inverse?
02:46:15 <phenrique> one list of [Aluno] for lines in one file?
02:47:05 <ski> mmorrow : does the code generated for the given example at <http://moonpatio.com/cgi-bin/gadtshow.cgi> work ?
02:47:36 <Saizan> phenrique: unlines (map show alunos)
02:47:41 <mmorrow> ski: i'm not sure actually. usually you have to remove a Show constraint or two from the code it generates
02:47:51 <mmorrow> (since it does no typechecking or anything)
02:48:08 <Saizan> phenrique: then you can use writeFile "filename" on that list
02:48:12 <mmorrow> also, higher kinded tyvars confuse it (they confuse Data.Derive too)
02:48:52 <ski> mmorrow : since it seems (e.g.) to rely on being able to map `Show (a,b)' into `Show a' and `Show b' (at runtime), for the `Pair' case
02:49:06 <mmorrow> ski: and the final caveat is that if it really is impossible for a given GADT to have a Show instance at all, gadtshow.cgi will happily generate code anyways :)
02:49:17 <ski> (yes, i already tried with `Mu' and `Showable')
02:49:20 <mmorrow> heh
02:49:35 <mmorrow> Mu?
02:49:39 <mmorrow> a gadt version?
02:49:43 <ski> yes
02:49:46 <Saizan> Showable?
02:49:47 <ski> just for fun
02:49:56 <mmorrow> ooh, what's the def you gave it?
02:50:08 <ski>   data Mu :: (* -> *) -> * where In :: f (Mu f) -> Mu f
02:50:15 <mmorrow> heh, nice
02:50:24 <ski>   data Showable :: * where Show :: Show a => a -> Showable
02:50:26 <mmorrow> i dunno though, the regular Mu has a Show instance that works
02:50:36 <ski>   data Hidden :: * where Hide :: a -> Hidden
02:51:18 <mmorrow> ski: here's Show,Read,Eq,Ord for the regular Mu that i've used http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2293
02:51:19 <Saizan> mmorrow: you get the context wrong
02:51:32 <Saizan> in the .cgi script, i mean
02:51:45 <ski> (.. and i don't know if the type-checker in GHC currently allows taking apart an `Show (a,b)' constraint into `Show a' and `Show b' ..)
02:52:23 <mmorrow> Saizan: yeah, since it always blindly generates the same context, it'll get it wrong whenever it doesn't need that context or that context is just plain wrong
02:52:27 <ski> (.. it presumably could, if it knew such dictionaries must come from `instance (Show a,Show b) => Show (a,b)')
02:52:48 <mmorrow> ski: hmm, i'm not sure
02:53:13 <mmorrow> Saizan: ah, ok so Show works fine for the GADT Mu when you fix the context then you mean
02:53:25 <Saizan> > let foo :: Show (a,b) => a -> b -> String; foo a _ = show a in foo 1 2
02:53:26 <lambdabot>   Could not deduce (GHC.Show.Show a)
02:53:26 <lambdabot>    from the context (GHC.Show.Show (a, b...
02:54:13 <Saizan> mmorrow: i expect it not to differ from the non-gadt Mu
02:54:23 <mmorrow> , muT [0..3]
02:54:23 <ski> mmorrow : yes, i've heard that `instance (Show (f (Mu f))) => Show (Mu f)' for some reason works in GHC now .. but i still think it might be nice to be able to say `instance (forall a. Show a => Show (f a)) => Show (Mu f)' ..
02:54:26 <lunabot>  Mu (T (Mu (T (Mu (Tip 0)) (Mu (Tip 1)))) (Mu (T (Mu (Tip 2)) (Mu (Tip 3)))))
02:54:38 <mmorrow> Saizan: yeah, that's what surprised me
02:54:44 <mmorrow> (i thought that's what ski meant)
02:55:12 <mmorrow> ski: you need UndecideableInstances for those kind of instances too
02:55:28 <ski> mmorrow : i suspected so :)
02:55:57 <mmorrow> (another example of this kind of instance where you need UndecidableInstances comes up in the new "Fun with type functions" paper)
02:56:22 <mmorrow> i think this case is one of the more benign uses of UndecidableInstances
02:57:06 <mmorrow> because all it's doing is tying the knot, i don't think an instance like this could loop the typechecker (?)
02:57:10 <ski> if we have incoherent instances, then a particular `Show (Foo,Bar)' dictionary doesn't necessarily come from the `(Show a,Show b) => Show (a,b)' instance .. so there might then not be corresponding `Show Foo' and `Show Bar' dictionaries
02:57:14 <phenrique> Saizan
02:57:15 <phenrique> http://pastebin.com/m51481900
02:58:08 * ski wants to play with higher-ranked instances ..
02:58:25 <inkman> hi people
02:58:38 <inkman> i want to ask about inventory system strategies
02:58:53 <inkman> how do you store current stocks
02:58:59 <bremner> inkman: in Haskell?
02:59:15 <inkman> in general
02:59:29 <inkman> databse
02:59:31 <bremner> inkman: that would be off-topic for this channel, I think
02:59:35 <doserj> phenrique: the error message basically says that the recursive calls to removeUsuario are missing an argument
02:59:36 <inkman> ahh ok
03:00:01 * ski raises eyebrow
03:00:05 <Saizan> phenrique: you forgot to pass 'm' to the recursive calls to removeUsuario
03:00:07 <phenrique> ok
03:00:08 <phenrique> :)
03:02:28 <ski>   removeUsuario m = loop
03:02:31 <ski>     where
03:02:38 <ski>     loop [   ] = []
03:02:45 <ski>     loop (a:x)
03:02:55 <ski>       | nome a /= m = a : loop x
03:03:02 <ski>       | otherwise   =     loop x
03:03:45 <Saizan> or, removeUsuario xs m = filter (\x -> nome x /= m) xs
03:03:46 <ski> phenrique : that's an alternative way that avoids naming `m' all the time .. though it probably doesn't matter in this simple case
03:04:32 <RayNbow> that removeUsario function resembles filter?
03:04:48 <ski> (obviously)
03:06:02 <RayNbow> phenrique: is there a reason why you aren't using the Prelude's filter function?
03:06:55 * ski assumes phenrique is learning the basics of writing loops with recursion
03:07:05 <phenrique> I am not know how use :)
03:07:23 <RayNbow> @src filter
03:07:23 <lambdabot> filter _ []     = []
03:07:23 <lambdabot> filter p (x:xs)
03:07:23 <lambdabot>     | p x       = x : filter p xs
03:07:23 <lambdabot>     | otherwise = filter p xs
03:11:41 <RayNbow> removeUsuario xs m = filter p xs where p a = ...  -- you'd use filter like this, phenrique
03:12:27 <yuuki> Are there type systems that support arbitrary predicates as types?
03:14:46 <Twey> @src guard
03:14:46 <lambdabot> guard True  =  return ()
03:14:46 <lambdabot> guard False =  mzero
03:15:41 <RayNbow> yuuki: could you give an example how you'd use it?
03:16:02 <kowey> what does this linker error mean, please? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6574
03:16:49 <yuuki> I would use it to represent arbitrary theorems of mathematics, proving them constructively by writing programs that fulfilled the types
03:17:30 <ski> yuuki : are you looking for dependent types ?
03:17:38 <EvilTerran> yuuki, i believe agda and coq do something similar
03:18:15 <portnov> theoretically, haskell's type system can do this :)
03:18:29 <kowey> (nevermind)
03:18:43 <EvilTerran> portnov, sure, with enough extensions, haskell's type system becomes turing complete
03:18:44 <RayNbow> kowey: what caused the linker error?
03:19:08 <portnov> google for smth like "Turing-complete haskell type system" or "types programming in haskell"
03:19:13 <kowey> well, the module I was trying to build (with a main) function was calling itself RunTests, so I just renamed it to Main
03:19:21 <RayNbow> ah
03:19:29 <kowey> (leaving the file as RunTests.hs, but moving it to the top level directory)
03:19:52 <yuuki> for example, "f(n > 0) = 1/n"
03:22:26 <yuuki> Is that possible in Haskell?
03:22:57 <Twey> :src when
03:23:03 <EvilTerran> yuuki, well, you can write "f n | n > 0 = 1/n", but i'm not sure if that's what you meant
03:23:04 <Twey> @src whne
03:23:04 <lambdabot> Source not found. :(
03:23:08 <Twey> >.<
03:23:09 <Twey> @src when
03:23:09 <lambdabot> when p s = if p then s else return ()
03:23:37 <yuuki> EvilTerran, will that give you a type error?
03:23:53 <EvilTerran> no
03:26:54 <portnov> data Nat = Zero | Succ Nat
03:26:54 <portnov> data Sign = Plus | Minus
03:26:54 <portnov> data Integer = I Sign Nat
03:26:54 <portnov> f (I Plus n) = ...
03:27:18 <portnov> smth like this )
03:27:48 <phenrique> Saizan http://pastebin.com/m62a4da51
03:29:03 <phenrique> removeUsuario, it was for remove only the line with the matricula especific
03:29:11 <phenrique> but return []
03:29:25 <phenrique> the file is only []
03:31:16 <PeakerWork> quicksilver: are you here now? :)
03:32:31 <doserj> phenrique: the problem is the hClose. either try to put the hClose further to the end, or use readFile instead of openFile+hGetContents+hClose
03:34:31 <boml> let a = readTime defaultTimeLocale "%Y-%d-%m %H:%M:%S" "2009-06-30 14:20:21" :: UTCTime
03:34:47 <boml> @let a = readTime defaultTimeLocale "%Y-%d-%m %H:%M:%S" "2009-06-30 14:20:21" :: UTCTime
03:34:47 <lambdabot>  <local>:19:4: Not in scope: `readTime'
03:34:47 <lambdabot>  
03:34:47 <lambdabot>  <local>:19:13: Not in scope: `defa...
03:36:03 <Heffalump> anyone familiar with making Haskell stuff work in cygwin?
03:36:15 * Heffalump doesn't really understand how cygwin does things
03:37:05 <boml> @import Data.Time.Format; import System.Locale; import Data.Time.Clock; let a = readTime defaultTimeLocale "%Y-%d-%m %H:%M:%S" "2009-06-30 14:20:21" :: UTCTime
03:37:05 <lambdabot> Unknown command, try @list
03:37:16 <boml> how does one past into this thing?
03:37:21 <boml> paste
03:37:39 <mjs22> anyone here familiar with System.Random and performance issues related to it?
03:38:25 <boml> @import Data.Time.Format
03:38:26 <lambdabot> Unknown command, try @list
03:38:41 <boml> @list
03:38:41 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
03:39:24 <boml> @help
03:39:24 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
03:39:30 <boml> @list
03:39:30 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
03:40:22 <lilac> > readTime defaultTimeLocale "%Y-%d-%m %H:%M:%S" "2009-06-30 14:20:21" :: UTCTime
03:40:23 <lambdabot>   Not in scope: type constructor or class `UTCTime'Not in scope: `readTime'No...
03:40:57 <mjs22> > 1+2
03:40:58 <lambdabot>   3
03:41:01 <lilac> @type Date.Time.Clock.UTCTime
03:41:02 <lambdabot> Couldn't find qualified module.
03:41:18 <boml> @let a = Data.Time.Format.readTime System.Locale.defaultTimeLocale "%Y-%d-%m %H:%M:%S" "2009-06-30 14:20:21" :: Data.Time.Clock.UTCTime
03:41:19 <lambdabot>  <local>:19:4: Not in scope: `Data.Time.Format.readTime'
03:41:19 <lambdabot>  
03:41:19 <lambdabot>  <local>:19:30: No...
03:41:21 * ski . o O ( `I Minus Zero' )
03:41:22 <lilac> boml: you can't do imports in lambdabot. if what you want isn't available, you're out of luck
03:41:42 <lilac> and what you want isn't available, so...
03:41:43 <boml> lilac: where can I see what's available?
03:42:10 <lilac> boml: i think the best you can do is to look at the lambdabot source code on hackage. i think the file is called L.hs
03:42:13 <quicksilver> PeakerWork: still nope.
03:42:21 <EvilTerran> boml, by asking lambdabot in private message or reading the source, i think
03:42:34 <boml> ok. thx
03:42:40 <EvilTerran> > unsafeLaunchMissiles -- is this in scope? i hope not
03:42:42 <lambdabot>   Not in scope: `unsafeLaunchMissiles'
03:43:42 <opqdonut> > unsafeLaunchMissiles -- oops
03:43:43 <lambdabot>   "BOOM!"
03:44:01 <lilac> boml: yeah, lambdabot-<ver>/State/L.hs in the source package seems to be the place to look
03:44:04 <phenrique> doserj, it is not work : /
03:44:51 <boml> anyone knows how to convert a NominalDiffTime to an Int?
03:45:06 <boml> fromEnum gives strange results
03:45:09 <RayNbow> opqdonut: why the quotes? :p
03:45:25 <mjs22> > unsafeLaunchMissiles
03:45:26 <lambdabot>   "BOOM!"
03:45:29 <mjs22> heh
03:45:36 <lilac> someone should upload a package to hackage with an 'unsafeLaunchMissiles' function
03:45:47 <lilac> implementation is left as an exercise to the reader
03:46:00 <RayNbow> > unsafeLaunchNuke
03:46:01 <lambdabot>   A-Bomb Launch Detected
03:46:17 <RayNbow> look, no quotes :p
03:46:42 <EvilTerran> > text "look ma, no quotes!"
03:46:43 <lambdabot>   look ma, no quotes!
03:46:48 <RayNbow> indeed :p
03:46:50 <opqdonut> ha
03:46:50 <Vanadium> Sounds like unsafePerformMAD
03:47:04 <phenrique> Saizan ?
03:48:00 <RayNbow> > SimpleReflect.var "look EvilTerran, no quotes either :P"
03:48:02 <lambdabot>   look EvilTerran, no quotes either :P
03:48:17 <phenrique> RayNBow
03:48:18 <phenrique> ?
03:48:57 <phenrique> RayNbow
03:49:41 <RayNbow> phenrique: hmm?
03:50:10 <lilac> > fun "hello" :: Expr
03:50:11 <lambdabot>   hello
03:50:40 <phenrique> RayNbow
03:50:42 <phenrique> http://pastebin.com/m5e4b3383
03:51:31 <phenrique> if i had 2 tow lines in a file
03:51:34 <doserj> phenrique: try putting the hclose after the writeFile
03:51:51 <phenrique> but...
03:51:55 <phenrique> wait
03:51:56 <doserj> phenrique: (or simply use readFile)
03:52:33 <doserj> phenrique: hGetContents and let-bindings are lazy, so nothing is actually read before the writeFile
03:53:07 <doserj> phenrique: if you close the handle before anything is read, you will read nothing
03:55:11 <lilac> is it possible to implement readFile in terms of openFile, hGetContents and closeFile?
03:55:42 <phenrique> but now
03:55:43 <phenrique> teste: usuarios.txt: openFile: resource busy (file is locked)
03:55:51 <etpace_> @src sequence
03:55:51 <lambdabot> sequence []     = return []
03:55:51 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
03:55:51 <lambdabot> --OR
03:55:51 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
03:56:06 <Heffalump> lilac: just openFile and hGetContents, AFAIK
03:56:11 <Heffalump> in the obvious way
03:56:18 <Heffalump> hGetContents takes care of closing the handle
03:56:33 <Heffalump> if you do an explicit hClose you'll truncate the stream
03:56:41 <phenrique> doserj writeFile open and close, but it still is opened
03:57:12 <phenrique> doserj teste: usuarios.txt: openFile: resource busy (file is locked)
03:57:18 <doserj> phenrique: ah, you try to write to the same file as you read from...
03:57:27 <phenrique> yeah
03:57:35 <doserj> phenrique: just use readFile...
03:59:37 <etpace_> doing v <- x; takes it "out of" the IO box right? so xs <- return [] would mean that xs is []?
04:00:22 <etpace_> @src forever
04:00:22 <lambdabot> Source not found. The more you drive -- the dumber you get.
04:01:19 <lilac> Heffalump: i thought hGetContents only semi-closes? maybe i misunderstood
04:01:43 <Heffalump> the handle will be closed once EOF is reached
04:03:56 <quicksilver> or when the handle is GCed
04:04:13 <PeakerWork> quicksilver: NOW you're here :)
04:04:24 * quicksilver continues to deny everything.
04:07:32 <phenrique> doserj
04:07:34 <phenrique> http://pastebin.com/m2014e00c
04:07:45 <phenrique> now teste: usuarios.txt: openFile: resource busy (file is locked)
04:09:37 <Beelsebob> phenrique: the reason you're getting that is because of lazy IO
04:09:46 <Beelsebob> the computation of the output happens as it streams the file in
04:10:00 <Beelsebob> and hence the writing of the output happens at the same time
04:10:08 <Beelsebob> so you're trying to read from and write to a file at the same time
04:11:10 <Beelsebob> also writeFile "./somethingElse.txt" . unlines . map show . (flip removeUsuario matriculaUsuario) map read . lines =<< readFile "./usuarios.txt"
04:11:15 <Beelsebob> oops, missed a .
04:11:24 <Beelsebob> writeFile "./somethingElse.txt" . unlines . map show . (flip removeUsuario matriculaUsuario) . map read . lines =<< readFile "./usuarios.txt"
04:11:52 <Beelsebob> also, removeUsuario is aka filter
04:12:30 <Beelsebob> writeFile "./somethingElse.txt" . unlines . map show . (filter ((/=matriculaUsuario) . matricula)) . map read . lines =<< readFile "./usuarios.txt"
04:12:45 <PeakerWork> quicksilver: I wondered if I had misunderstood something about the semantic model of Conal's FRP, maybe you can help until conal is here (given you implemented Deus)
04:12:54 <doserj> ah, yes, readFile also is lazy...
04:13:01 <PeakerWork> quicksilver: Because I think there's a problem with how (Event a) and accumE/scanlE are defined
04:13:45 <PeakerWork> quicksilver: accumE accumulates all the events of the given event since the beginning of time, right?  or is it since the time accumE was applied to the event?
04:17:35 <Heffalump> grrr
04:17:36 <quicksilver> PeakerWork: "the time accumeR was applied to the event" is not a meaningful phrase.
04:17:57 * Heffalump gives up on trying to make a small utility program for his mother-in-law in Haskell because he just can't figure out how to sort out the Windows library issues
04:18:10 <quicksilver> PeakerWork: accumE, that is. An Event exists over all time; accumE is applied to an event which exists over all time and gives a result which is an event which exists over all time.
04:18:23 <phenrique> Beelsebob
04:18:24 <quicksilver> doserj: s/lazy/broken/;
04:18:36 <phenrique> http://pastebin.com/ma5691fe
04:18:56 <doserj> quicksilver: :)
04:19:06 <phenrique> Is it? It is not work.. it is not effect
04:19:14 <phenrique> not remove
04:22:04 <PeakerWork> quicksilver: then what if you have a Behavior that after a long time, applies accumE
04:22:23 <PeakerWork> quicksilver: Doesn't that mean that (Event a) must forever and ever hold all events since the beginning of time in the implementation?
04:22:32 <quicksilver> PeakerWork: Yes, absolutely.
04:22:39 <PeakerWork> quicksilver: Isn't this a serious problem?
04:22:49 <quicksilver> It's an important issue you have to understand.
04:22:58 <PeakerWork> quicksilver: I would assume the "solution" is to lose your references to the (Event a) to get rid of old occurances, right?
04:23:00 <quicksilver> that's why 'cojoin' for Event is useful.
04:23:17 <quicksilver> cojoin :: Event a -> Event (Event a)
04:23:27 <quicksilver> at each occurrence, you instead get an Event
04:23:37 <quicksilver> but that Event contains only that occurrence, and later ones
04:23:42 <quicksilver> no earlier ones.
04:23:55 <quicksilver> rather like "tails :: [a] -> [[a]]"
04:23:59 <PeakerWork> quicksilver: wouldn't it be better to not expose  Event  at all, but instead expose something that is semantically like   Behavior (Event a)   or:    Event (Event a) (only with an initial value) ?
04:24:12 <quicksilver> I don't think so, no.
04:24:15 <quicksilver> But you might be right.
04:24:15 <PeakerWork> quicksilver: why not?
04:24:36 <quicksilver> When you use an event inside a behaviour you have to remember to use cojoin first.
04:24:46 <quicksilver> and also if you use a behaviour inside a behaviour
04:24:53 <quicksilver> (since behaviours are implemented as events)
04:25:04 <quicksilver> conal calls this "aging"
04:25:44 <PeakerWork> If you only had EEvent a   which is semantically like Behavior (Event a)  and not Event a, what problem would it pose?  accumE would apply only "since the time of application", and everything else would work the same?
04:26:13 <quicksilver> I don't think it solves the problem you think it solves.
04:26:25 <quicksilver> I don't have time right now to tease out the details I'm afraid ;)
04:26:36 <quicksilver> I'm pretty sure that sometimes you want to use Event and sometimes you want to use Event Event
04:27:19 <PeakerWork> quicksilver: ok, thanks, I'll think about it :)
04:27:45 <PeakerWork> the idea though is that once you cojoin the Event, you always dispose the outer event and reapply cojoin on it?
04:29:50 <quicksilver> you don't need to reapply at that point.
04:32:07 <lilac> it seems to me that it'd be valuable to have: Event a `eventsAfter` Event () -> Event (Event a). can you manufacture that from cojoin?
04:32:56 <lilac> (i'm guessing something like: filterE isRight . cojoin $ (Left <$> a) `mappend` (Right <$> b) might work)
04:38:02 <quicksilver> lilac: (Left <$> a) `mappend` (Right <$> b) is called sumE
04:38:31 <quicksilver> arguably it should exist more generally somewhere
04:38:40 <quicksilver> :t \a b -> (Left <$> a) `mappend` (Right <$> b)
04:38:41 <lambdabot> forall a b (f :: * -> *). (Functor f, Monoid (f (Either a b))) => f a -> f b -> f (Either a b)
04:39:36 <quicksilver> I wonder if there is a way to characterise functors-which-are-monoids.
04:39:45 <quicksilver> I bet edwardk has thought about that if anyone has.
04:40:10 <Saizan> FunctorPlus ?
04:41:06 <Saizan> i guess it won't work
04:42:35 <edwardk> i have a FunctorPlus in category-extras, but I have to run =)
04:43:21 <quicksilver> runFunctorPlus (edwardk)
04:44:10 <raji> how do we generate numbers of width n (<=25) so that we generate numbers in the order of total bits set, like for n=3, it will be 0,1,2,4,3,5,6,7, n=4 ,0,1,2,4,8,3,5,6,9,10,12,7,11,13,14,15. I have a O(n*2^n) exact but i want to know if it can be n/2 or n/4  * 2^n
04:45:12 <BONUS> > let f n = [0..(2^n)-1] in f 4
04:45:13 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]
04:45:39 <PeakerWork> quicksilver: Alternative for Applicative+Monoid, and MonadPlus, so makes sense to have FunctorPlus.  But it would be even better if we had higher-ranked class contexts, so we could have  (forall a. Monoid (f a), Functor f) =>   contexts
04:45:51 <raji> BONUS, that doesn't work , 3 is before 4
04:46:17 <BONUS> oh wait sorry i thought it was just 0 to 2^n-1
04:46:33 <PeakerWork> I wonder what laws FunctorPlus can add, though
04:47:28 <quicksilver> PeakerWork: yes, this liftM2 mappend (Left <$>) (Right <$>) is something like the "free completion to Alternative"
04:47:46 <quicksilver> although completion is not, technically, the right word.
04:48:16 <PeakerWork> > let countBits 0 = 0 ; countBits n = 1 + countBits ((n-1) .&. n) in map countBits [1..7]
04:48:17 <lambdabot>   Add a type signature
04:48:17 <quicksilver> mappend itself, on Event, is a candidate for <|>
04:48:36 <PeakerWork> > let countBits :: Integer -> Integer ; countBits 0 = 0 ; countBits n = 1 + countBits ((n-1) .&. n) in map countBits [1..7]
04:48:37 <lambdabot>   [1,1,2,1,2,2,3]
04:48:50 <PeakerWork> @let countBits :: Integer -> Integer ; countBits 0 = 0 ; countBits n = 1 + countBits ((n-1) .&. n)
04:48:51 <lambdabot>  Defined.
04:49:15 <PeakerWork> @let sortOn key = sortBy (compare `on` key)
04:49:16 <lambdabot>  Defined.
04:49:31 <PeakerWork> > let f n = sortOn countBits [0..n] in f 10
04:49:32 <lambdabot>   [0,1,2,4,8,3,5,6,9,10,7]
04:49:52 <PeakerWork> raji: this is N * log^2 N   I think
04:50:26 <PeakerWork> now if you want something with O(1) memory complexity...
04:51:20 <PeakerWork> you can do better than the above sort, but do you need to?
04:53:03 <lilac> you can do the bit counting faster
04:54:27 <raji> thanks
04:54:33 <raji> i was thinking of grey code
04:54:51 <lilac> take n' = (n .&. 0b01010101 + (n `shiftR` 1) .&. 0b01010101). then take n'' = (n' .&. 0b00110011 + (n' `shiftR` 2) .&. 0b00110011), etc
04:54:58 <lilac> which should be O(log log N)
04:55:30 <copumpkin> > 0b11
04:55:30 <lambdabot>   Not in scope: `b11'
04:56:45 <PeakerWork> lilac: That uses inherent parallelism of bit-wise operations..
04:57:37 <PeakerWork> i.e: its only really a better "O()" for Int, not for Integer/etc
04:57:38 <quicksilver> taken advantage of the data parallelism of modern CPU!
04:57:47 <quicksilver> perform up to 32 - or even 64 - operations at one time!
04:57:50 <PeakerWork> lilac: its O(logN) if N is the number of bits, and the "naive" one I gave above is O(N)
04:57:55 <quicksilver> be the envy of your friends!
04:58:05 <copumpkin> lol
04:58:19 <raji> thanks
04:58:21 <PeakerWork> its only 64 times faster, not different O() :-)
04:58:50 <RayNbow> @where hayoo
04:58:51 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
05:00:31 <PeakerWork> Hayoo needs a nicer url
05:00:42 <RayNbow> agreed
05:05:38 <copumpkin> hoogle.org and hayoo.org would both be nice
05:09:54 <maartenm> hello
05:10:12 <maartenm> has :: [Integer] -> Integer -> Bool
05:10:20 <maartenm> has (x:xs) a = ( x == a || has xs a )
05:10:25 <maartenm> has [] a = False
05:10:49 <maartenm> I don't understand why Haskell has problems when this function is fed an infinite array as first argument
05:11:00 <maartenm> I thought it would be lazy enough to recognize that further calculation is not needed
05:11:05 <maartenm> because of the ||
05:11:15 <quicksilver> yes, it will be
05:11:18 <twanvl> only if the item is found
05:11:21 <quicksilver> > True || undefined
05:11:22 <lambdabot>   True
05:11:37 <maartenm> ah, ok
05:11:46 <maartenm> so in this case, I would need to have an ordered list
05:11:57 <maartenm> my brain isn't working today I think
05:11:58 <maartenm> ok, thanks
05:12:02 <doserj> > let has = flip elem in [1..] `has` 5
05:12:03 <lambdabot>   True
05:12:18 <quicksilver> if you knew the list was ordered
05:12:31 <quicksilver> then you could short circuit to false if x > a
05:12:34 <maartenm> yeah it is.. so I'd just need to check that x > a
05:13:29 <maartenm> that lambdabot is awesome, btw (first time i come here)
05:15:41 <dschoepe> Is there a emacs mode to collapse function definitions in Haskell files?
05:18:21 <maartenm> how can I write these kind of "short circuits" in an elegant way?
05:18:24 <maartenm> without if statements
05:18:41 <maartenm> instead of:   has (x:xs) a = if x > a     	       	  then False     	       	  else ( x == a || has xs a )
05:19:00 <Saizan> you can use guards
05:19:11 <maartenm> supposed you'd want to make this a generic check that a lot of fucntions should apply
05:19:20 <maartenm> guards.. ok I'll read about that
05:19:33 <maartenm> can I use that in a generic manner?
05:19:47 <Saizan> has (x:xs) a | x > a = False | otherwise = x == a || has xs a
05:19:59 <mauke> has (x : xs) a = x <= a && (x == a || has xs a)
05:20:05 <Saizan> yeah
05:20:45 <dschoepe> what's the case for has [] a? If it's False, you could use a `elem` xs
05:20:48 <maartenm> so there's a way to "coat" all my [Array] -> Int -> Bool functions with this check?
05:20:57 <maartenm> dschoepe: learning myself haskell
05:21:22 <Saizan> dschoepe: elem doesn't exploit the fact that the list is ordered
05:21:28 <dschoepe> hmm, right
05:21:51 <dschoepe> elem a . takeWhile (<=a) $ xs
05:23:08 <Saizan> maartenm: you could make a newtype of [Array] and check at the time of construction
05:23:19 <maartenm> hmm
05:23:58 <maartenm> I don't know how I can fit the (> a) function in that if I don't have 'a'
05:24:20 <maartenm> anyway, I should figure this out by myself I think
05:27:56 <cristi_ceata> hello! how do I remove a cabal package ?
05:30:19 <Zao> cristi_ceata: Unregister it and delete the files manually, I believe.
05:30:39 <pozic> cristi_ceata: sometimes all you want is to hide it.
05:36:46 <lilac> what would happen if you manually installed a later version of a cabal package which provided no modules?
05:37:05 <lilac> (how close would that be to an uninstall?)
05:37:20 <dcoutts> lilac: then everything that used it would fail :-)
05:37:28 <dcoutts> when compiling that is
05:38:58 <etpace_> @src Control.Monad.forever
05:38:58 <lambdabot> Source not found. :(
05:40:15 <lilac> dcoutts: i was thinking 1) install this dodgy package, then 2) unregister
05:41:12 <dcoutts> lilac: it would not delete old files if that's what you're thinking
05:41:52 <lilac> yeah, i just noticed in my ~/.cabal it has old versions left installed :-/
05:42:09 <Gracenotes> oops. I just realized the glass I had drank the punch out of was the same one I discarded the artichoke hearts into earlier.
05:42:32 <Gracenotes> the punch didn't taste funny.. it was a shock seeing the artichoke at the bottom though :/
05:43:32 <Badger> Delicious.
05:43:49 <Botje> artichoke punch to the face!
05:44:50 <Gracenotes> also s/drank/drunk/
05:45:09 <lilac> or s/had//
05:46:02 <Gracenotes> moving the 'had' to left of 'discarded' might also help
05:48:59 * rocketman thows a bag of words down
05:49:48 * Philippa offers rocketman an r and a scrabble board
05:50:53 <lilac> playing sentence scrabble with prebuilt words could be interesting
05:51:41 <etpace_> How does getContents work? Does it read line by line (when needed)?
05:52:53 <dschoepe> I'd like to be able to collapse the function definitions in Haskell files in emacs and only see the types and the left-hand-side of the declaration. Is there already a module for that?
05:56:06 <doserj> dschoepe: (add-hook 'haskell-mode-hook '(lambda () (outline-minor-mode) (setq outline-regexp "\\(import \\|\[a-zA-Z0-9 _'\]*::\\)") (hide-sublevels 1))) is a first approximation
05:56:31 <dschoepe> doserj: Thanks
05:56:35 <PeakerWork> do I need to understand a lot of CT to understand which arrows CoMonad reverses in Monad?  I don't understand why Functor's arrows aren't reversed, and join/etc are
05:57:24 <doserj> dschoepe: doesn't work for operators, class or instance definitions, yet
05:57:55 <dschoepe> doserj: I'll see if I can extend it to do that, but normal functions were my main issue
05:58:49 <copumpkin> PeakerWork: maybe because of the "a monad IS a functor, and HAS two natural transformations associated with it such that ..."?
05:58:58 <copumpkin> PeakerWork: but I'm definitely no CT expert :)
05:59:27 <PeakerWork> copumpkin: does that mean that a comonad is also a functor?  What if I view a Monad as:  fmap,return,join?
06:00:25 <dibblego> Peaker, yes (comonads are functors)
06:01:18 <Saizan> PeakerWork: fmap is a part of being a functor, the arrows reversed are the ones for the natural transformations return and join
06:02:25 <PeakerWork> dibblego: Yeah, what I meant is why is the Functor part not reversed, but the Pointed and Monad parts are?
06:02:30 <Saizan> return :: I -> M, join :: M M -> M, coreturn :: M -> I, cojoin :: M -> M M
06:02:36 <PeakerWork> Saizan: yeah, why is the functor part not reversed?
06:02:57 <copumpkin> what would reversing that mean?
06:03:17 <PeakerWork> I can only answer that by reversing Haskell arrows, I don't know CT :-)
06:03:30 <quicksilver> it would be something else, that's all.
06:03:53 <fasta> I wish I could see the history of a value in some kind of real debugger. A pony would be nice too, obviously.
06:03:58 <PeakerWork> (f a -> f b) -> (a -> b) or maybe either/each of them would also be reversed?
06:04:02 <Saizan> PeakerWork: because a functor has to map morphims in the base category to morphisms into the target category
06:04:14 <PeakerWork> fasta: a history of an immutable value?
06:04:20 <fasta> PeakerWork: yes
06:04:28 <Philippa> Peaker: the functor may as well be reversed - you can't tell the difference, it's an endofunctor
06:04:29 <quicksilver> Saizan: well, you can perfectly well have a contravariant functor from C to itself.
06:04:41 <PeakerWork> fasta: what does that mean? Which parts of it were already evaluated in different parts of history?
06:04:49 <Saizan> quicksilver: that just changes the base category, no?
06:05:01 <fasta> PeakerWork: it would answer the question: how did the value [(1,2)] come into existence?
06:05:13 <PeakerWork> fasta: oh, the history of the reductions made?
06:05:22 <fasta> PeakerWork: yes
06:05:30 <PeakerWork> fasta: yeah, sort of like Subtext
06:05:42 <quicksilver> Saizan: in a sense. But there is nothing inherently absurd about asking if there is a notion of Monad for a contravariant functor
06:05:57 <quicksilver> Saizan: although I imagine in practice it turns out to be uninteresting.
06:06:21 <copumpkin> contramonad! :P
06:06:23 <Saizan> quicksilver: but (f a -> f b) -> (a -> b) doesn't look like a contravariant functor to me
06:06:37 <quicksilver> well, yes, that's just wrong.
06:06:43 <Saizan> well, not one that starts with Hask :)
06:06:43 <quicksilver> (a -> b) -> (f b -> f a)
06:06:50 <quicksilver> that's the arrow you would reverse.
06:07:04 <doserj> dschoepe: it is probably best to add an (setq outline-level '(lambda () 1)) into that hook
06:07:23 <dschoepe> doserj: Thanks
06:07:52 <doserj> otherwise functions with longer names get folded into preceeding function with shorter names...
06:09:01 <lilac> Saizan: (f a -> f b) -> (a -> b) looks like an Unctor to me ;-)
06:10:30 <opqdonut> :D
06:10:40 <Saizan> how do you represent fmap for a certain functor in CT? it doesn't look like a natural transformation, unless you go via exponential objects
06:11:06 <ski> `fmap' translates a morphism into a morphism
06:11:14 <Saizan> right
06:11:32 <Saizan> so you've to go into the category of arrows?
06:12:52 <quicksilver> why would you represent it?
06:12:56 <mmorrow> fmap /is/ the functor
06:12:59 <quicksilver> or what do you mean by 'represent'
06:13:10 <quicksilver> fmap is the mapping on morphisms which defines what the functor is.
06:13:51 <Saizan> quicksilver: i agree, but before thinking about reversing arrows for it i'd like to represent it as a natural transformation or a morphism
06:14:02 <quicksilver> of course functors between small categories are themselves arrows in a large category of categories.
06:14:15 <quicksilver> I don't know what you're trying to think about.
06:14:24 <quicksilver> what I said is the very essence of 'co'
06:14:30 <quicksilver> functors are the simplest thing you can 'co'
06:14:43 <quicksilver> although conventionally they are called contravariant instead of merely cofunctors.
06:15:19 <rprije> Anyone free to help me with a space leak?
06:15:36 <Saizan> i understood that contravariance didn't really had a connection with duals (which is what co- is used for)
06:16:25 <quicksilver> well, a functor maps things to things, a contravariant functor maps things to co-things
06:16:34 <quicksilver> I'd say that's a fairly strong connection :)
06:16:40 <lilac> i thought that contravariant functors were functors?
06:16:53 <mux> is there some other one that comaps things to things?
06:16:58 * mux implodes
06:17:16 <mmorrow> if you have a contravariant functor from a category to itself that's Id in every sense other than that it's contravariant, then it maps objects to their duals
06:17:21 <opqdonut> lilac: they're functors to the co-category
06:17:31 <mmorrow> well, that's actually just A -> A^op
06:17:32 <quicksilver> opqdonut: or, from the co-category :)
06:17:33 <saml> @twit comaps contravariant
06:17:33 <lambdabot> Not enough privileges
06:17:42 <quicksilver> opqdonut: I generally think of it as "from"
06:17:50 <opqdonut> mmh
06:17:53 <quicksilver> not sure why I prefer that way around.
06:18:49 <lilac> i would think a cofunctor would map (f a -> f b) -> (a -> b) (where the arrows are all taken from the relevant categories)
06:18:58 <lilac> intuitively
06:19:21 <mmorrow> `f' is the functor though
06:19:25 <opqdonut> nah, that's the antifunctor (?) of f
06:19:29 <mmorrow> symbolically applicaed
06:19:33 <mmorrow> *applied
06:19:37 <mmorrow> A -> F A
06:19:50 <mmorrow> (A -> B) -> (F A -> F B)
06:19:58 <mmorrow> (A -> B) -> (F B -> F A)
06:20:00 <lilac> mmorrow: 'is the functor' is vague; the same term is used for the mapping of objects and the mapping of arrows as far as i can tell
06:20:23 <opqdonut> lilac: is the functor in the sense that that functor is designated by f
06:20:28 <lilac> mmorrow: for instance, you could say [] is the functor or you could say map is the functor
06:20:30 <mmorrow> "is" := "f a" is representing the object in the target category which "a" gets mapped to
06:20:36 <Saizan> lilac: like if you've cofunctor F :: C -> D that maps arrows in D to arrows in C, then you can just have a functor G :: D -> C
06:20:50 <Saizan> lilac: with your proposed sense of cofunctor
06:21:11 <mmorrow> so (f a -> f b) -> (a -> b) doesn't make sense, since "f a" and "f b" are in the target cat, not the source
06:21:11 <Saizan> if i understood what you mean :)
06:21:27 <lilac> Saizan: yes, i think we're on the same page
06:22:05 <lilac> but with the notion of contravariant functor, if you've got cofunctor F :: C -> D then you can just have a functor G :: C -> dual(D)
06:22:20 <Saizan> right
06:22:25 <lilac> they both seem like interesting concepts
06:24:41 <Saizan> a functor F : C^op -> D^op is the same as a functor C -> D?
06:24:49 <anteaterNethack> what is the most idiomatic way to express a generalization of lines (let's name it linesBy) that splits not on newlines but on a caller-supplied predicate function?
06:25:16 <Saizan> anteaterNethack: you can use the split package on hackage
06:25:21 <anteaterNethack> saizan, sorry, what does ^ mean in your line?
06:25:22 <lilac> Saizan: sounds right to me
06:25:22 <Twey> Data.List.Split.splitWhere from the split package
06:25:24 <mmorrow> anteaterNethack: it'd be "split" if we had it in the stdlibs :/
06:25:27 <anteaterNethack> thanks.
06:29:14 <etpace_> in the example do contents <- getContents; putStr (map toUpper contents), how does the laziness work? contetns contains a promise of contents, toupper promises a capitlised contents, but why does the code only seem to "run" when I press enter
06:29:51 <Saizan> etpace_: that's because of buffering
06:30:13 <Twey> @index withBufferMode
06:30:13 <lambdabot> bzzt
06:30:20 <Twey> I could have sworn something like that existed
06:30:34 <Saizan> etpace_: use hSetBuffering NoBuffering if you want to disable it
06:30:45 <Twey> I ended up writing withBufferMode :: [(Handle, BufferMode)] -> IO a -> IO a
06:31:00 <etpace_> What happens when its sitting there withn othing in the buffer Saizan? Does it just eternally wait for getContents to return something?
06:31:15 <etpace_> and then the promise finally expires on an end-of-file?
06:31:30 <opqdonut> yep
06:32:06 <Saizan> map toUpper just waits for more of the string to become available, getContents is wainting for the lower I/O levels to give something ..
06:32:12 <Saizan> *waiting
06:32:20 <Saizan> lazy IO is a bit like concurrency
06:32:40 <Saizan> getContents continues to perform side-effects even after it returns
06:32:40 <etpace_> It's quite wierd to think of without it "looping"
06:33:01 <etpace_> ah I see, that makes sense
06:33:11 <maartenm> hello, I have a simple haskell question:
06:33:45 <etpace_> when something arrives, it gives it to putStr, but it doesnt actually stop waiting
06:33:49 <maartenm> selection = filter (f or g) [1..1000]
06:33:52 <maartenm> how do I do this?
06:33:54 <Saizan> etpace_: right
06:34:11 <opqdonut> maartenm: simple answer: filter (\x -> f x || g x)
06:34:19 <maartenm> of course, lambda
06:34:21 <maartenm> thanks
06:34:28 <opqdonut> maartenm: cool answer: "liftM2 (||) f g"
06:34:35 <Twey> filter ((l... darn it :-P
06:34:46 <maartenm> liftM2, is that in Prelude?
06:34:50 <Twey> Control.Monad
06:34:50 <opqdonut> yes
06:34:57 <Twey> liftM2 is in the Prelude?
06:35:05 <Saizan> you need Control.Monad.Instances for that to work
06:35:07 <Twey> No, it's not
06:35:08 <opqdonut> ah, no, Control.Monad
06:35:12 <opqdonut> yeah, and you need Instances
06:35:19 <opqdonut> just use the lambda for now :)
06:35:22 <maartenm> ok, I'll keep it in mind once I'm less of an idiot in this language
06:35:54 <Saizan> i'd probably use the lambda for the sake of not being esoteric, in real code
06:36:17 <Twey> I don't think liftM2 is that esoteric
06:36:48 <Twey> I did use the lambda earlier today for a demonstration to some newbies, though
06:36:51 <RayNbow> opqdonut: why not liftA2?
06:37:29 <opqdonut> because
06:37:40 <rocketman> It's no different
06:38:15 <Twey> One module instead of two, I guess
06:39:33 * edwardk_ waves hello.
06:40:12 <edwardk> i miss anything interesting on the FunctorPlus discussion earlier?
06:40:15 <lilac> does ~ have any meaning in expressions (outside of contexts and patterns)?
06:40:38 <lilac> edwardk: i think it ended pretty much as soon as it began
06:40:44 <edwardk> ah well
06:41:19 * lilac contemplates an automatic lifting syntax: filter (~f || ~g)
06:41:26 * ToRA works out the filter thing using arrows a bit late: filter (uncurry (||) . (f &&& g))
06:41:52 <lilac> @type f &&& g >>> uncurry (|))
06:41:53 <lambdabot> parse error on input `|'
06:42:06 <lilac> @type ?f &&& ?g >>> uncurry (||)
06:42:07 <lambdabot> forall a. (?f::a -> Bool, ?g::a -> Bool) => a -> Bool
06:42:36 <Twey> lambdabot: Nice
06:42:39 <Twey> Er, lilac
06:42:56 <lilac> Twey: just adding more arrow syntax to ToRA's one
06:43:07 <Twey> I meant about the autolifting
06:43:21 <lilac> ah right. it might be nice, but it might be confusing :)
06:43:23 <Shurique> is there something like a function of type ThreadId -> IO Bool to check whether the specified thread has terminated?
06:48:58 <rprije> Anyone free to help me with a space leak?
06:49:01 <edwardk> Shurique: i highly doubt it, that would add book keeping to every thread for a feature you can code up yourself by using a custom forkIO-like thing
06:50:28 <Shurique> alright, I'll do that :)
06:50:29 <Shurique> thanks
06:51:11 <ski> lilac : lifting to what ?
06:52:37 * ski would prefer there not being syntactic constructions allowed in both patterns and expressions, but with different meaning
06:53:24 <ski> lilac : so, lifting in the `(r ->)' applicative ?
06:54:47 * ski would also like banning the use of the word "cofunctor"
06:59:48 <quicksilver> edwardk: I suggested that liftM2 mappend (Left <$>) (Right <$>)  was something like a free completion into a FunctorPlus
06:59:55 <quicksilver> edwardk: but it's not quite right, because it's not quite free.
06:59:58 <quicksilver> erm
07:00:01 <quicksilver> or not quite complete.
07:11:59 <maartenm> lpf n = if (spf n == n)       	   then n 	   else lpf (n / spf n)
07:12:09 <maartenm> ERROR file:C:/home/haskell/test.hs:32 - Instance of Fractional Int required for definition of lpf
07:12:39 <maartenm> but there is no risk, since spf ('smallest prime factor') ensures that (n/spf n) is an integer
07:12:48 <Botje> maartenm: you want `div` instead of /
07:12:50 <maartenm> but anyway, how does one deal with this?
07:13:05 <maartenm> ok, div is an integer division?
07:13:12 <Botje> yep
07:13:16 <ski>   n `div` spf n
07:13:18 <maartenm> ok, thanks
07:14:28 <boml> how does fromEnum work? i am doing fromEnum on a POSIXTime and every now and then I get a negative number.
07:15:53 <Botje> :t fromEnum
07:15:54 <lambdabot> forall a. (Enum a) => a -> Int
07:16:06 <maartenm> is there a function 'minimum' in Prelude that abuses the fact that my (infinite) list is sorted?
07:16:16 <Botje> you probably need a Word instead of an Int, i guess?
07:16:20 <maartenm> *suddenly realizes asking this question take slonger than writing that function*
07:16:34 <Botje> maartenm: if it's sorted then surely the minimum element is "head" ? :)
07:16:52 <maartenm> yes, I am very confused apparently
07:16:54 <lispy> Cale: ping?
07:17:15 <boml> I would like to convert the POSIXTime (which is seconds since epoch) to an integer.
07:17:16 <lispy> ?version
07:17:16 <lambdabot> lambdabot 4.2.2
07:17:16 <lambdabot> darcs get http://code.haskell.org/lambdabot
07:17:32 <lispy> How do I find out what version of ghc lambdabot was compiled with?
07:18:17 <maartenm> spf 600851475143  Program error: arithmetic overflow
07:18:28 <maartenm> hmm, why does it do that?
07:18:31 <maartenm> only thing spf does is:
07:18:38 <maartenm> spf n = head (filter (\x -> mod n x == 0) primes)
07:18:47 <lispy> Cale: /usr/bin/ghc-6.10.3 is now on olive
07:19:33 <lispy> > 600851475143 `mod` 1 :: Int
07:19:34 <lambdabot>   0
07:19:50 <byorgey> maartenm: what is the type of spf ?
07:20:02 <lispy> > 600851475143 `mod` 5 :: Int
07:20:02 <maartenm> when I do that, I also get arithmetic overflow
07:20:03 <lambdabot>   3
07:20:08 <byorgey> > maxBound :: Int
07:20:09 <lambdabot>   9223372036854775807
07:20:15 <maartenm> byorgey: Int -> Int
07:20:18 <byorgey> hmm
07:20:25 <lispy> oh, well lambdabot is running on a 64bit machine
07:20:33 <lispy> maartenm: are you using a 32bit ghc?
07:20:35 <byorgey> > 2^29
07:20:35 <maartenm> maxBound :: Int 2147483647
07:20:35 <lambdabot>   536870912
07:20:38 <maartenm> yeah
07:20:47 <maartenm> what type shoudl I use then?
07:20:49 <byorgey> well, that's why, I guess =
07:20:53 <byorgey> maartenm: use Integer instead of Int
07:20:54 <lispy> maartenm: so I think it's telling you that you've exceeded the precision of the native integer type
07:20:58 <byorgey> Integer is unbounded in size
07:21:03 <maartenm> ok
07:21:10 <maartenm> but I ran into problems trying to specify Integer as type
07:21:11 <lispy> maartenm: you can also use things like Word64, I think
07:21:13 <doserj> boml: try toRational instead of fromEnum
07:21:36 <lispy> > 600851475143 `mod` 10 :: Word64
07:21:37 <lambdabot>   3
07:22:09 <byorgey> Integer ought to work, why bother with Word64 ?
07:22:18 <byorgey> maartenm: what problems?
07:22:51 <maartenm> well
07:22:59 <byorgey> maartenm: note that a few Prelude functions (like length, indexOf, etc.) require Ints (for who knows what reason) so when using Integers sometimes you have to use  genericLength, genericIndexOf, etc.
07:23:00 <lispy> byorgey: efficiency is the only reason I would bother with it
07:23:04 <maartenm> I now have to change Int to Integer in all the functions of my code
07:23:16 <edwardk> @type liftM2 mappend (Left <$>) (Right <$>
07:23:17 <lambdabot> parse error (possibly incorrect indentation)
07:23:19 <edwardk> liftM2 mappend (Left <$>) (Right <$>)
07:23:20 <byorgey> maartenm: just do search-and-replace. =)
07:23:24 <edwardk> @type liftM2 mappend (Left <$>) (Right <$>)
07:23:25 <lambdabot> forall b (f :: * -> *). (Monoid (f (Either b b)), Functor f) => f b -> f (Either b b)
07:23:26 <edwardk> gah
07:23:36 <maartenm> yeah, I thought haskell could cast them smartly
07:23:46 <edwardk> quicksilver ugly
07:23:49 <lispy> maartenm: there are no implicit conversions i n haskell
07:23:58 <edwardk> er quicksilver: ugly. not that i'm saying that you are =)
07:24:16 <boml> doserj: strangely enough, that seems to work
07:24:33 <maartenm> ok.. it runs now.. thanks
07:24:42 <lispy> maartenm: the only magic you get here is that numeric literals are treated as genericly as possible until you constrain them.  So 1 :: Num a => a, meaning it's anything that is an instance of the Num type class
07:24:48 <maartenm> although I don't think Problem 3 of the Euler project should take 2 mins to calculate :)
07:24:50 <edwardk> maartenm: use fromIntegral here and there a a shim
07:24:57 <edwardk> er as a
07:24:58 <doserj> boml: from/toEnum give the picoseconds, as an Int, which of course overflows
07:24:59 <maartenm> ah, ok
07:25:17 <byorgey> maartenm: no, it probably shouldn't, but I doubt that's Haskell's fault =)
07:25:23 <edwardk> fromIntegral and fromInteger are your friends
07:25:43 <boml> doserj: and what does toRational give?
07:26:13 <doserj> it should give the seconds, as a Rational (i.e., a Ratio Integer)
07:26:40 <maartenm> well at least the answer is correct
07:26:48 <boml> doserj: can this be seen in the ghc docs?
07:26:52 <maartenm> btw is there an easy benchmark lib in haskell?
07:27:00 <maartenm> I grew attached to Ruby's incredibly easy benchmarking
07:27:23 <doserj> boml: internally, it is a Data.Fixed.Fixed E12, i.e., a fixed-precision decimal number
07:27:47 <doserj> boml: only if you follow the code links, I guess :)
07:28:46 <lilac> ski: lifting into an applicative (deduced from context)
07:28:58 <doserj> boml: and yes, the Enum instances for Data.Fixed.Fixed are broken, in my view...
07:29:43 <ski> (lilac : i have part of a design for that ..)
07:30:11 <ski> (well, monads in the general case, functor and applicative in restricted cases)
07:30:54 <lispy> gah, I can't install cabal-install on debian because there is no libghc6-parsec-dev for ghc6.10
07:31:22 <lispy> there is a parsec3, but cabal-install doesn't seem to like that
07:31:33 <SamB_XP> lispy: why did you get rid of your old cabal-install ?
07:31:47 <lispy> SamB_XP: I never had it on this machine
07:31:50 <SamB_XP> oh
07:32:02 <SamB_XP> well, copy it over from somewhere, maybe ?
07:32:05 <lispy> There is also no cabal-install package on debian
07:32:07 <boml> doserj: thx for the hint
07:32:54 * SamB_XP supposes he should reinstall cabal install with GHC 6.10
07:34:09 <dsturnbull> anyone have cabal installation instructions for debian/ubuntu? /part
07:34:12 <dsturnbull> woops
07:35:16 <SamB_XP> @ask kaol why isn't there a libghc6-parsec-dev (containing parsec2)? lispy says it's needed to build cabal-install.
07:35:19 <dsturnbull> bootstrap.sh basically fails
07:35:59 <kuribas> dschoepe: I wrote some Emacs code to do that.
07:36:05 <SamB_XP> dsturnbull: you were going to ask and run?
07:36:13 <dsturnbull> haha
07:36:35 <dcoutts__> dsturnbull: what does the bootstrap say?
07:36:37 <SamB_XP> dsturnbull: anyway, does your failure relate in some way to parsec ?
07:37:01 <lispy> I think ghc just barfed trying to link this Setup.hs
07:37:27 <dcoutts> dsturnbull: oh if it's the debian parsec problem then try this pre-release :-) http://haskell.org/~duncan/cabal/cabal-install-0.6.3.tar.gz
07:37:33 <dsturnbull> wlel, i went and downloaded all the dependencies for cabal off hackage manually before realising bootstrap.sh existed
07:37:45 <dschoepe> kuribas: Could you post that code somewhere?
07:37:49 <dsturnbull> so i'm trying to clean up before trying again
07:37:53 <dcoutts> dsturnbull: the other common one is not having the debian zlib dev package installed
07:37:59 <kuribas> dschoepe: sure
07:38:06 <lambdabot> kuribas: You have 1 new message. '/msg lambdabot @messages' to read it.
07:38:10 <dcoutts> dsturnbull: shouldn't be any need to clean up, the bootstrap will not re-install things that are already ok
07:38:24 <lispy> dcoutts: yeah, I'm having issues with cabal-install on debian.  Why is there no cabal-install apt package?
07:38:26 <maartenm> is there a function in prelude that takes all permutations of zipWiths? like zipPerms (*) [a,b] [c,d] = [a*b, a*d, b*c, b*d]
07:38:32 <dsturnbull>     Could not find module `Distribution.Simple':
07:38:35 <dcoutts> lispy: no idea, it's crazy
07:38:38 <maartenm> sorry
07:38:39 <SamB_XP> lispy: that is ANOTHER question for kaol
07:38:44 <dcoutts> lispy: go complain :-)
07:38:46 <maartenm> zipPerms (*) [a,b] [c,d] = [a*c, a*d, b*c, b*d]
07:38:55 <lispy> dcoutts: But...I already came here to complain :)
07:39:14 <dcoutts> lispy: you need to complain to the right people
07:39:23 <lpsmith> lispy:  I'm a debian user, and I haven't used the debian GHC packages really, ever.
07:39:26 <SamB_XP> @ask kaol why is there no cabal-install apt package? lispy wants it. dcoutts says it's crazy that there is none.
07:39:26 <lambdabot> Consider it noted.
07:39:33 <dcoutts> lispy: try #debian-haskell in OFTC or the debian haskell mailing list
07:39:41 <quicksilver> I'm a debian user, and I always use the debian GHC packages.
07:39:52 <SamB_XP> I am too, and usually do
07:40:10 <quicksilver> > liftM2 (*) [a,b] [c,d]
07:40:14 <lambdabot>   [a * c,a * d,b * c,b * d]
07:40:15 <SamB_XP> sometimes I use a self-built GHC running out of the build dir, though
07:40:19 <quicksilver> maartenm: like that? :)
07:40:28 <maartenm> gods
07:40:35 <maartenm> ok, liftM2 it is then
07:40:40 <maartenm> but that's not in prelude
07:40:44 <quicksilver> Control.Monad
07:40:53 <maartenm> it is Wizard stuff, not for the likes of me
07:41:07 <SamB_XP> maartenm: nonsense
07:41:08 <quicksilver> it is for all haskell users, regardless of race, creed, or affiliation
07:41:16 <SamB_XP> it just does a cartesian product
07:41:30 <SamB_XP> (in the [] monad)
07:41:34 <maartenm> ok, I feel like cheating trying to solve project euler stuff with it though.. but I'll use it as a start
07:41:46 <ski> > [x * y | x <- [a,b] , y <- [c,d]]  -- same as
07:41:48 <lambdabot>   [a * c,a * d,b * c,b * d]
07:42:04 <lispy> gah, issues with libghc6-network-dev too
07:42:09 <hzap> wow, lambdabot can even eval with free variables?
07:42:15 <SamB_XP> ski: what, are you translating it into Python ?
07:42:22 <ski> not at all
07:42:22 <quicksilver> hzap: yes, by an interesting hack.
07:42:33 <SamB_XP> hzap: they are actually bound in the environment
07:42:36 <lpsmith> The debian packages seem to be almost always at least a year or two out of date
07:42:46 <SamB_XP> which is to say, there's a little file on lambdabot's disk that has the bindings in
07:42:51 * ski was just showing maartenm alternative equivalents
07:42:58 <kuribas> dschoepe: http://paste.lisp.org/display/83105
07:43:05 <pikhq> :t liftM2 (*) [a,b] [c,d]
07:43:08 <lambdabot> [Expr]
07:43:11 <SamB_XP> hzap: well, at least, that's how it used to work
07:43:12 <Vq^> lpsmith: you must be new to debian
07:43:16 <SamB_XP> dunno if gwern changed that or not
07:43:17 <pikhq> There's your answer.
07:43:34 <SamB_XP> lpsmith: you need to switch to testing/unstable
07:43:35 <hzap> crazy stuff :)
07:43:45 <kuribas> dschoepe: You should bind show-only-definitions to a key.
07:43:54 <pikhq> lpsmith: Debian Stable is, in fact, a stable distribution.
07:44:16 <kuribas> dschoepe: When you press enter again, it will show the whole file.
07:44:32 <gbacon> ?src guard
07:44:32 <lambdabot> guard True  =  return ()
07:44:33 <lambdabot> guard False =  mzero
07:44:38 <SamB_XP> lpsmith: I mean, unless you just want a system where everything stays working
07:44:56 <lispy> okay, new bootstrap will run
07:44:59 <lispy> er now
07:46:09 <hzap> ah so does using a b c d only work with arithmetic operators?
07:46:15 <dschoepe> kuribas: Sorry, I might have missed your response, I lost my connection.
07:47:06 <kuribas> dschoepe: http://paste.lisp.org/display/83105 You should bind show-only-definitions to a key.  When you press enter again, it will show the whole file.
07:47:13 <dschoepe> kuribas: thanks
07:47:18 <kuribas> And it works with any mode.
07:47:18 <pikhq> hzap: I'd imagine it'd work on anything that can take Expr. Mostly the arithmetic operators.
07:47:58 <etpace_> @src interact
07:47:58 <lambdabot> interact f = do s <- getContents; putStr (f s)
07:48:10 <lpsmith> No, actually I'm a longtime debian user;   but yes, I remember now... I want everything to stay working, but I want an up-to-date ghc install, so I find it easiest just to manage that myself :-P
07:48:28 <boml> how to print a list? one row for each item in the list.
07:48:30 <SamB_XP> lpsmith: ah, yes, that makes sense
07:48:51 <lpsmith> Sometimes I forget why I have certain habits :)
07:48:54 <mauke> forM_ list print
07:48:57 <etpace_> mapM print [1..] boml?
07:49:17 <etpace_> mauke: is forM just mapM with parameters switched
07:49:23 <mauke> yes
07:49:28 <boml> maukes solution wins on elegance...
07:50:01 <lispy> cool, installing gitit via cabal-install now
07:50:22 <lispy> > let progress = progress + 1
07:50:27 <lambdabot>   not an expression: `let progress = progress + 1'
07:51:10 <boml> but actually they are quite similar. I was fooled by the [1..] part
07:51:15 <pikhq> > let progress = progress + 1 in progress
07:51:20 <lambdabot>   mueval-core: Prelude.read: no parse
07:51:21 <lambdabot>  mueval: ExitFailure 1
07:51:58 * Vq^ prefer mapM_ when f is short
07:52:33 * SamB_XP too
07:53:04 * hzap three
07:53:14 <SamB_XP> forM seems more appropriate for when f is a lambda or large pointless construction
07:54:19 <Vq^> or when only applying the input-list and not the function
07:54:35 <hzap> if the list expression is short, forM is sweet
07:56:35 * pikhq notes that forM ought to just be flip . mapM ;p
07:56:58 <Vq^> pikhq: im very curious
07:57:11 <quicksilver> I use forM when f is a multi-line expression.
07:57:19 <pikhq> Vq^: Good. Curiosity is good for you.
07:57:24 <mauke> :t flip . mapM
07:57:28 <lambdabot> forall b a b1. (a -> b -> b1) -> b -> [a] -> [b1]
07:57:30 <quicksilver> forM_ ["apple","pear"] $ \s -> do .... .... ... ...
07:58:11 <pikhq> Well, that is... Quite interesting.
07:58:13 <pikhq> :t mapM
07:58:17 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
07:58:34 <pikhq> flip . mapM doesn't work. Yay.
07:58:39 <mauke> :t flip mapM
07:58:41 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
07:58:45 <quicksilver> simply flip mapM
07:58:46 <quicksilver> not flip.mapM
07:58:55 <pikhq> ... Yeah. That... Makes more sense.
07:59:02 <pikhq> And works.
07:59:32 * Vq^ gets less curious
08:02:37 <lilac> ski: sounds neat. what notation do you use (if any)?
08:03:41 <pikhq> Vq^: Shame, that; curiosity's good for you.
08:04:34 <ski> lilac : i've not really decided on concrete syntax .. i've used symbols `<',`>' as well as the "Quine" (?) quotes
08:04:58 <ski> .. i mean i've used those in pseudo-code .. on paper
08:05:54 <ski> if you want, i can show some examples to eludicate on the idea
08:16:00 <Vq^> pikhq: i got plenty ;)
08:29:14 <drhodes> > print '"'
08:29:18 <lambdabot>   <IO ()>
08:30:40 <anteaterNethack> normally zip stops as soon any argument list ends.  However I need a zip that pads:
08:30:40 <anteaterNethack> zipDefault :: a -> b -> [a] -> [b] -> [(a,b)]
08:30:49 <anteaterNethack> what would be the most idiomatic way to implement this?
08:31:31 <opqdonut> zipDefalt defx defy xs ys = zip (xs ++ repeat defx) (ys ++ repeat defy)
08:31:44 <ski> that never stops ..
08:31:47 <opqdonut> or then just write out the recursion by hand
08:32:06 <anteaterNethack> ski, oh, i should mention: my zip should stop whenever the last list stops.
08:33:03 <lilac> anteaterNethack: what do you want to pad with?
08:33:14 <lilac> anteaterNethack: never mind
08:33:15 <anteaterNethack> example:
08:33:21 * lilac misread
08:34:06 <anteaterNethack> zipDefault 0 "c" [1,2,3] "ab" == [(1,'a'),(2,'b'),(3,'c')]
08:34:24 <anteaterNethack> i already have such a function defined, but the definition looks rather ugly.
08:35:38 <Ferdirand> is there an easy way to split a list into many lists of fixed maximum length ? i'm sure there is, can't wrap my head around it..
08:35:39 <lilac> zipDefault a b as bs = (map fst $ zip (as ++ repeat a) bs) `zip` (map snd $ zip as (bs ++ repeat b))
08:35:40 <Alucard_Not_Orca> zipDefault defx defy xs ys = take (max (length xs) (length ys)) $ zip (xs ++ repeat defx) (ys ++ repeat defy)
08:35:52 <lilac> Alucard_Not_Orca: that's not lazy enough i think
08:35:58 <hackagebot> fmlist 0.6 - FoldMap lists (SjoerdVisscher)
08:36:08 <anteaterNethack> Ferdirard, look at http://www.haskell.org/haskellwiki/Data.List.Split
08:36:23 <ski> @type \def_x def_y xs ys -> map (maybe def_x id *** maybe def_y id) . takeWhile (uncurry (||) . (isJust *** isJust)) $ zip (map Just xs ++ repeat Nothing) (map Just ys ++ repeat Nothing)
08:36:24 <Ferdirand> anteaterNethack: thanks :)
08:36:25 <lambdabot> forall a a1. a -> a1 -> [a] -> [a1] -> [(a, a1)]
08:36:28 <lilac> Alucard_Not_Orca: (doesn't work if xs or ys is infinite). using genericLength and Natural it might be workable though
08:36:58 <anteaterNethack> my current solution is:
08:36:59 <anteaterNethack> > zipDefault :: a -> b -> [a] -> [b] -> [(a,b)]
08:36:59 <anteaterNethack> > zipDefault da db as bs = map deflt . takeWhile (not . noJust) $ zip (fill as) (fill bs)
08:36:59 <anteaterNethack> >     where fill xs = map Just xs ++ repeat Nothing
08:36:59 <anteaterNethack> >           deflt (a,b) = (maybe da id a, maybe db id b)
08:36:59 <anteaterNethack> >           noJust (Nothing, Nothing) =  True
08:37:00 <anteaterNethack> >           noJust _ = False
08:37:04 <lambdabot>   <no location info>: parse error on input `where'
08:37:04 <lambdabot>   <no location info>: parse error on input `='
08:37:04 <lambdabot>   <no location info>: parse error on input `='
08:37:04 <lambdabot>   Not in scope: `zipDefault'
08:37:04 <lambdabot>   <no location info>: parse error on input `='
08:37:06 <lambdabot>   <no location info>: parse error on input `='
08:37:12 <anteaterNethack> (sorry for the scroll.)
08:37:24 <ski> > (\def_x def_y xs ys -> map (maybe def_x id *** maybe def_y id) . takeWhile (uncurry (||) . (isJust *** isJust)) $ zip (map Just xs ++ repeat Nothing) (map Just ys ++ repeat Nothing)) 'x' 'y' "abc" "defghi"
08:37:25 <lambdabot>   [('a','d'),('b','e'),('c','f'),('x','g'),('x','h'),('x','i')]
08:38:05 <ski> .. oh
08:38:21 <ski> anteaterNethack : mine is basically the same as yours :)
08:38:29 <anteaterNethack> yeah, i see.
08:38:31 <lilac> mine doesn't work ;-)
08:38:45 <ski> it feels a bit clumsy, though ..
08:38:47 <doserj> I would write zipDefault da db as ab = zip as bs where ..., and just give the 4 lines for zip
08:39:50 <anteaterNethack> doserj, could you elaborate?
08:40:07 <ski> @src zip
08:40:08 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
08:40:08 <lambdabot> zip _      _      = []
08:40:16 <ski> modify that to use the defaults, instead
08:40:28 <doserj> yep, that's what I mean
08:40:40 <anteaterNethack> that would work.
08:41:22 <ski> lilac : did you want to see some examples ?
08:44:37 <jelly12gen> i am looking at the code of http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
08:44:48 <jelly12gen> and i can;t run some examples ..
08:48:21 <lilac> ski: yes, please :)
08:48:31 <ski> hm, ok
08:48:51 <ski> you wanted to express `liftA2 (||) f g', yes ?
08:49:06 <ski> (or maybe with `liftM2' ..)
08:49:31 <lilac> for instance, yes
08:49:41 <lilac> @botsnack
08:49:42 <lunabot>  :)
08:49:45 <ski> i'll write my "Quine" quotes as
08:49:55 <ski>   `<expression>
08:49:56 <ski> here
08:50:06 <ski> and "Quine" anti-quote as
08:50:13 <ski>   ,<expression>
08:50:24 <ski> then we have
08:50:40 <ski>   f :: m Bool
08:50:41 <lambdabot> :)
08:50:42 <ski>   g :: m Bool
08:51:06 <boml> anyone knows how to use the System.Win32 api. For example the getLogicalDrives method just returns a number when I try it. I would like to have a list of letter or something.
08:51:11 <ski>   ,f :: Bool  -- with `m'-side-effects
08:51:15 <ski>   ,g :: Bool  -- with `m'-side-effects
08:51:16 <boml> letters
08:51:21 <ski>   ,f || ,g :: Bool  -- with `m'-side-effects
08:51:29 <ski>   `(,f || ,g) :: m Bool
08:51:37 <ski> lilac, so
08:51:42 <ski>   `(,f || ,g)
08:51:48 <ski> would be my version of it
08:52:42 <ski> (here `m' can be any applicative functor .. not just any monad)
08:52:46 <lilac> > let zipDefault a b as bs = map (either id id *** either id id) . takeWhile anyLeft $ zip (map Left as ++ repeat (Right a)) (map Left bs ++ repeat (Right b)) where anyLeft (Right _, Right _) = False; anyLeft _ = True in zipDefault 0 'c' [1,2,3] "ab"
08:52:47 <lambdabot>   [(1,'a'),(2,'b'),(3,'c')]
08:53:05 <ski> lilac : nice
08:53:11 <ski> :)
08:53:18 <lilac> ski: i only did it for the 'anyLeft' pun
08:53:25 <ski> hehe
08:53:55 <ski> (otherwise i'd used `uncurry (||) . (isLeft *** isLeft)')
08:54:20 <lilac> ski: that's what i started with, but it seemed rather ugly
08:54:35 <ski> the abstract syntax, or the concrete syntax ?
08:54:49 <lilac> the uncurry (||) . ...
08:54:53 <ski> oh ..
08:55:10 * ski thought lilac was talking about  `(,f || ,g)  :)
08:55:21 <lilac> also, \b has no isLeft in scope ;-)
08:55:41 <ski> hm .. right
08:56:02 <lilac> the `, notation seems reasonable (looks like a variation of the banana brackets paper notation)
08:56:19 <lilac> or am i thinking of the applicative paper?
08:56:28 <lilac> i think the latter
08:56:28 <ski> i was also using an alternative (sort-of) syntax
08:56:44 <ski>   > <f> || <g> <
08:56:46 <ski> on paper
08:56:54 <ski> though i think that's ambiguous ..
08:56:57 <timonator> how can uncurry work? does it create a function that passes the first N arguments and just swallows the N+1th argument, discarding it?
08:57:00 <ski> one could try
08:57:11 <ski>   [> [<f>] || [<g>] <]
08:57:16 <lilac> i've been wondering whether it's possible to deduce the extent of the lifted expression
08:57:21 <lilac> @src uncurry
08:57:22 <lambdabot> uncurry f p = f (fst p) (snd p)
08:57:37 <lilac> uncurry f ~(a, b) = f a b
08:57:39 <ski> lilac : my answer to that is : don't deduce, denote !
08:57:46 <timonator> lilac: what's ~?
08:57:53 <lilac> timonator: it's a lazy pattern match
08:58:00 <quicksilver> @remember ski my answer to that is : don't deduce, denote!
08:58:00 <lambdabot> Done.
08:58:02 <timonator> uh, ok
08:58:09 <lilac> timonator: basically, it's: uncurry f (a, b) = f a b
08:58:14 * ski grins
08:58:17 <timonator> so it unpacks a two-tuple and uses each part as an argument, OK
08:58:24 <lilac> timonator: but the deconstruction of the tuple only happens if f uses the arguments
08:58:44 <lilac> ski: Mr Hindley and Mr Milner want a word with you :-)
08:58:51 <timonator> not really what i'd intuit "uncurrying" to mean, but it's definitly more usable
08:58:59 <ski> > let f ~(x,y) = (42,(y,x)) in fst (f undefined)
08:59:01 <lambdabot>   42
08:59:02 <lilac> @src curry
08:59:03 <lambdabot> curry f x y = f (x, y)
08:59:03 <ski> > let f (x,y) = (42,(y,x)) in fst (f undefined)
08:59:05 <lambdabot>   * Exception: Prelude.undefined
08:59:10 <lilac> timonator: it's the inverse of 'curry'
09:00:02 <lilac> i should say 'an' inverse, since the stricter one is an inverse too
09:00:10 <ski> lilac : my point is, i think it's bad to let the place where you go from "implicit" to "explicit" not have actual syntax
09:01:01 <ski> lilac : anyway, another example .. using `<',`>' for the sake of argument
09:01:07 <lilac> ski: would you have an exception for the top-level?
09:01:20 <ski> (preferably, no)
09:01:23 <ski>   data Person = P Name Age
09:01:48 <ski>   name :: Parser Name
09:01:54 <ski>   age  :: Parser Age
09:01:57 <lilac> ",h = ,f || ,g" might be nice as an alternative to "h = `(,f || ,g)"
09:02:04 <ski>   person :: Parser Person
09:02:12 <ski>   <person> = P <name> <age>
09:02:16 <ski> or, if you will
09:02:22 <ski>   person = > P <name> <age> <
09:02:33 <ski> lilac : yes, i've had exactly that idea
09:02:58 <ski> (but i don't think that's an "exception for the top-level", if that's what you meant)
09:04:22 <ski> anyway, i was going to show a monadic example, too
09:04:40 <ski> (but i can't think of any "sensible" one at the moment)
09:04:57 <ski>   foo : A -> Parser B
09:05:08 <ski>   bar :: A -> B -> Parser C
09:05:17 <ski>   baz :: A -> Parser C
09:05:38 <ski>   <baz a> = <bar a <foo a>>
09:05:57 <ski> this is monadic because the `<...>' is nested
09:06:21 <doserj> ski: order of evaluation is left-to-right?
09:06:36 <ski> you mean in the `person' example ?
09:06:51 <doserj> for example, yes
09:06:54 <ski>   <person> = P <name> <age>
09:06:59 <ski> should be equivalent to
09:07:10 <ski>   person = liftA2 P name age
09:07:23 <ski> so it depends on the applicative functor in question
09:07:36 <ski> does that answer your question ?
09:07:49 <lilac> ski: i quite like that using <>
09:07:51 <anty> Does anyone know how I can take a screenshot with Haskell on Windows?
09:07:54 <doserj> I guess.
09:08:14 <ski> (one might consider disallowing "parallel" `<...>', requiring "explicit ordering" with `let' or something ..)
09:08:31 <lilac> ski: i think it'd come up often enough that you should just specify an evaluation order
09:08:45 <ski> also, if you use `<...>' in a value-binding in a `let', or in the scrutinee in a `case' (or `if'), that's also monadic
09:09:26 <lilac> main = putStrLn $ <getLine> ++ <getLine>
09:09:33 <ski> no
09:09:34 <lilac> ^^ is that OK, or do i need <> around both sides?
09:09:39 <ski> either
09:10:14 <ski> (well, forget one variant .. it's hard enough to see in this bad concrete syntax)
09:10:41 <ski>   <main> = putStrLn <<getLine> ++ <getLine>>
09:11:09 <ski> (you can lift the `<...>' around `main' into a `>...<' around the body if you prefer, as above)
09:11:15 <ski> hm
09:11:19 <doserj> main = putStrLn $ > <getLine> ++ <getLine> < ?
09:11:19 <ski> no, wait
09:11:26 <ski> that was wronfg
09:11:35 * ski got confused
09:11:44 <ski>   <main> = <putStrLn (<getLine> ++ <getLine>)>
09:11:48 <ski> that's it
09:11:53 <ski> because
09:11:59 <ski>   getLine :: IO String
09:12:00 <lilac> ski: sure, that's what i had, but with extra <> around both sides
09:12:07 <lilac> ski: i was wondering, can you drop those?
09:12:10 <ski>   <getLine> :: String  -- with `IO'-side-effects
09:12:18 <ski>   <getLine> ++ <getLine> :: String  -- with `IO'-side-effects
09:12:29 <ski>   putStrLn <getLine> ++ <getLine> :: IO ()  -- with `IO'-side-effects
09:12:34 <SamB_XP> what strange tongue is this ?
09:12:36 <SamB_XP> Agda?
09:12:36 <ski>   <putStrLn <getLine> ++ <getLine>> :: ()  -- with `IO'-side-effects
09:12:45 <SamB_XP> well, no, Agda would need more spaces ...
09:12:46 <SamB_XP> hmm
09:12:48 <ski> (and final step, if you want it
09:12:57 <ski>   > <putStrLn <getLine> ++ <getLine>> < :: IO ()
09:12:57 <ski> )
09:13:07 <lilac> ski: don't the >< cancel?
09:13:18 <ski> SamB_XP : no, it's make-up syntax
09:13:21 <ski> lilac : yes
09:13:27 <ski> that last is the same as
09:13:31 <lilac> ski: so main = putStrLn $ <getLine> ++ <getLine>
09:13:32 <SamB_XP> ski: what, and you don't have an implementation?
09:13:37 <ski>   putStrLn (<getLine> ++ <getLine>) :: IO ()
09:13:43 <ski> (forgot brackets before)
09:13:49 <SamB_XP> how the heck am I gonna know what it does if you don't implement it?
09:13:51 <ski> SamB_XP : not at all :)
09:13:57 <lilac> ski: isn't that where we started?
09:14:07 <ski> sorry ?
09:14:35 * ski hasn't thought on this for quite a while, so he might be misremembering things here and there
09:14:54 <lilac> 16:09 < lilac> main = putStrLn $ <getLine> ++ <getLine>
09:15:09 <ski> (SamB_XP : i have a compilation-by-translation scheme .. on paper)
09:16:03 <quicksilver> ski: so, syntactically, <getLine> ++ <getLine> is a different kind of term?
09:16:16 <quicksilver> so it doesn't have a principle type in the normal sense
09:16:22 <quicksilver> it has a different notion of type?
09:16:24 <ski> different kind of term than what ?
09:16:34 <quicksilver> than "foo" ++ "bar"
09:16:54 * Beelsebob wonders why main = putStrLn =<< (getLine <^(++)^> getLine) doesn't do it
09:17:13 <quicksilver> Beelsebob: because that doesn't scale to nested applications.
09:17:25 <ski> (wait a moment .. i'm trying to check the example i ran with lilac, to see if i said something wrong ..)
09:17:26 <boml> anyone know how to handle a dword (pointer to c-array) in haskell?
09:17:27 * Beelsebob nods
09:17:38 <ski> (quicksilver : exactly)
09:17:41 <quicksilver> boml: peekPtr ?
09:18:15 <ski> ok
09:18:18 <ski> now i remember
09:18:35 <ski> lilac : no, `> < foo > <' is not the same as `foo', generally
09:18:43 <ski> that answers that question
09:18:59 <ski> (it is the same as `foo' iff `foo' is side-effect-free)
09:19:15 <ski> (however, `< > foo < >' is always the same as `foo')
09:19:27 <boml> quicksilver: do you mean peekArray?
09:19:45 <SamB_XP> @hoogle peek
09:19:46 <lambdabot> Foreign.Storable peek :: Storable a => Ptr a -> IO a
09:19:46 <lambdabot> Foreign.Marshal.Array peekArray :: Storable a => Int -> Ptr a -> IO [a]
09:19:46 <lambdabot> Foreign.Marshal.Array peekArray0 :: (Storable a, Eq a) => a -> Ptr a -> IO [a]
09:19:52 <ski> quicksilver : well, `<getLine> ++ <getLine>' is not the normal kind of term .. it is a generalization, in a sense
09:20:01 <SamB_XP> boml: maybe he just meant peek?
09:20:11 <SamB_XP> @hoogle peekO
09:20:12 <lambdabot> No results found
09:20:14 <ski> each side-effect-free expression can trivially be regarded as a side-effect-ful expression
09:20:18 <SamB_XP> @hoogle peekI
09:20:19 <lambdabot> No results found
09:20:22 <SamB_XP> @hoogle peekOffset
09:20:23 <lambdabot> No results found
09:20:48 <quicksilver> ski: yes, that's what I thought.
09:20:49 <ski> quicksilver : these terms still has types, but they also have an "implicit side-effect"
09:21:12 <quicksilver> and that implicit side-effect is subject to unification as normal
09:21:16 <ski> yes
09:21:24 <quicksilver> in particular, it can be "Applicative f =>"
09:21:33 <quicksilver> (unconstrained)
09:21:46 <quicksilver> or something like "MonadState Int m => "
09:21:47 <ski> it's basically just a type expression of kind `* -> *', on which certain constraints are placed in certain circumstances
09:21:51 <quicksilver> somewhat constrained.
09:21:55 <ski> consider
09:22:20 <boml> these functions take a ptr. But all i've got is a DWORD...
09:22:27 <ski>   foo :: f [a]
09:22:36 <SamB_XP> boml: oh DEAR
09:22:40 <SamB_XP> that won't do at all
09:22:43 <ski>   > reverse <foo> < :: f [a]
09:22:45 <SamB_XP> what about win64?
09:22:58 <ski> here only the `Functor' constraint is placed on `f'
09:22:58 <roconnor> @free filter
09:23:00 <lambdabot> $map f . filter (g . f) = filter g . $map f
09:23:10 <SamB_XP> boml: what sort of a DWORD is it?
09:23:12 <boml> SamB_XP: im trying to run the win32 function getLogicalDrives
09:23:18 <quicksilver> ski: hmm. right, yes.
09:23:31 <ski> as soon as you use "parallel" `<...>' subexpression, you get `Applicative'
09:23:38 <ski> and i mentioned above what gets you `Monad'
09:24:01 * quicksilver nods
09:24:20 <ski> which constraints you get is a simple static analysis of the code
09:24:24 <quicksilver> and the desugaring order is left to right innermost first?
09:24:37 <quicksilver> obviously innermost first is absolutely required.
09:24:41 <quicksilver> left to right is a choice, in principle
09:24:48 <quicksilver> but I'd be surprised if you chose something else :)
09:24:50 <ski> left-to-right or right-to-left doesn't matter
09:25:02 <quicksilver> well it matters quite a lot, to the programmer :)
09:25:07 <ski> you still get a fixed order (if the applicative functor is non-commutative)
09:25:22 <quicksilver> P <getLine> <getLine>
09:25:32 <quicksilver> has rather a different effect depending which one happens first.
09:25:32 <ski> i mean it doesn't matter if the elaboration works from left-to-right or vice versa
09:25:43 <ski> you still get effectively
09:25:49 <ski>   liftA2 P getLine getLine
09:25:50 <ski> there
09:26:00 <quicksilver> ok that's left to right
09:26:02 <quicksilver> in the sense I meant.
09:26:07 <ski> ok
09:26:08 <quicksilver> effects applied innermost first left to right.
09:26:13 <quicksilver> as a C programmer would expect
09:26:23 <quicksilver> (well, the small subset of C programmers who actually know how their language works)
09:26:27 <ski>   instance Applicative f => Applicative (OtherOrder f)
09:26:49 <mauke> quicksilver: what?
09:27:01 <mauke> you sound crazy
09:27:03 <roconnor> quicksilver: that order depends on the particular applicative functor
09:27:03 <doserj> quicksilver: function parameter evaluation order is undefined in C
09:27:06 <ski> (and i thought C didn't specify evaluation ordering for function arguments ..)
09:27:10 <SamB> ski: so why not switch to âŸ¨ and âŸ© or something and actually implement it ?
09:27:14 <quicksilver> oh really?
09:27:16 <pikhq> It explicitly doesn't.
09:27:28 <quicksilver> in k(f(),g(),h()) the order of sideeffects is undefined?
09:27:33 <pikhq> Yes.
09:27:36 <quicksilver> ah well.
09:27:37 <mauke> expression evaluation order in C is unspecified except for certain operators
09:27:38 <ski> afaik, yes
09:27:45 <roconnor> quicksilver: given an applicative functor there is a dual applicative functor that runs right to left.
09:27:48 <quicksilver> roconnor: yes.
09:28:01 <mauke> && || ?: ,  (that's the comma operator, not the function argument separator)
09:28:08 <SamB> quicksilver: we aren't sure, but it might even allow their computation to be interleaved
09:28:08 <quicksilver> roconnor: well, erm
09:28:17 <ski> (SamB : that's some unicode, yes ?)
09:28:24 <quicksilver> roconnor: but you can't do that for monads :)
09:28:29 <SamB> where "we" means ##c
09:28:32 <quicksilver> roconnor: and this sugar is supposed to work for monads.
09:28:33 <lilac> quicksilver: you're guaranteed that the arguments will be evaluated sequentially, and not in parallel, but the order is undefined
09:28:55 <ski> functors, applicative functors *and* monads
09:28:55 <lilac> at least in c++. don't know about c
09:29:22 <SamB> ironically, we are unsure of this only because the standard specifically says they are calculuted in unspecified or implementation-defined order ...
09:29:32 <SamB> forget exactly what term it used
09:29:46 <lilac> SamB: the c++ standard explicitly says the evaluation of arguments isn't interleaved
09:29:49 <SamB> lilac: the C spec isn't clear on it
09:30:01 <SamB> it doesn't explicitly say that, but it mentions an order
09:30:02 <lilac> interesting :)
09:30:07 <ski> SamB : well, i haven't thought much on this for some years .. (and istr there were some things to work out)
09:30:14 <SamB> so it's hard to tell what was meant
09:30:25 <lilac> SamB: implicit `par` ;-)
09:31:33 <ski> SamB : also, i'm more of a theory person than a practical person :) .. i think i'd need to either compile GHC, or extend some haskell-parsing package .. basically, i've been too lazy to try any of that, yet ;)
09:32:29 <ski> finally, i'm a bit unsure about which concrete syntax would be not too intrusive ..
09:32:31 <quicksilver> it would be nice if GHC supported front-end plugins
09:32:41 <ski> last i talked about this, people complained about
09:33:00 <doserj> quicksilver: typical parameter evaluation order in C actually is right-to-left. f(printf("a"),printf("b")) outputs "ba" here :)
09:33:11 <quicksilver> I think there is work underway to make that more practical
09:33:21 <ski>   [> [<putStrLn ([<getLine>] ++ [<getLine>])>] <]
09:33:22 <ski> :)
09:33:30 <lilac> doserj: istr that on msvc it depends on the calling convention of f
09:34:33 <ski> (ok, that was my excuses)
09:34:57 <doserj> well, a typical implementation is to just push the arguments onto the stack, such that the first argument is the top-most element. that gives right-to-left semantics.
09:35:54 * doserj stops being off-topic now
09:36:27 <ski> (SamB : btw, in Scheme, any interleaving is specifically allowed .. indeed any concurrent execution, as long as it is serializable)
09:37:56 <mauke> ski: can function calls be interleaved in scheme?
09:38:19 <ski>   (+ (foo) (bar))
09:38:21 <mauke> i.e. in (f (g) (h)), can parts of h run before g returns?
09:38:36 <ski> to my knowledge, the calls to `foo' and `bar' may be interleaved
09:38:59 <mauke> well, C specifically disallows that
09:39:06 <nominolo> mauke: scheme has undefined order for argument evaluation
09:39:20 <mauke> nominolo: that doesn't help me
09:39:33 <mauke> function calls are atomic in C, so to speak
09:39:33 <SamB> ski: serializable ?
09:39:39 <nominolo> it means anything is possible (and implementation-dependent)
09:39:58 <SamB> nominolo: it doesn't have undefined order
09:40:02 <nominolo> so they may be run in parallel
09:40:05 <SamB> it doesn't HAVE order
09:40:19 <nominolo> SamB: hm?
09:40:19 <SamB> which is clearly spelled out
09:40:39 <ski> SamB : if you slice up the calls into "atomic" pieces, then a concurrent execution is serializable if you could get the same effect by an interleaving of the slices
09:40:45 <nominolo> ok, right, no fixed order
09:41:01 <SamB> ski: what's their definition of atomic ?
09:41:09 <ski> i don't recall that
09:41:25 <SamB> do they define a semantics ?
09:41:41 <SamB> a precisely vague one?
09:42:01 <ski> you should probably check the R5RS if you want to know the details (vague or not) .. i'm just regurgitating what i seem to recall about the matter :)
09:42:15 <SamB> ski: why R5?
09:42:32 <SamB> or is that the new one?
09:42:46 <nominolo> R6RS is the latest
09:42:55 <SamB> that's what I thought
09:42:56 <ski> well, presumably R6 would do, too .. though that one is not (at least yet) "fully" accepted
09:43:04 <SamB> oh
09:43:16 <beutdeuce> how do i return to the Prelude scope after i imported a library in ghci?
09:43:20 <SamB> why don't they have some ratification process ?
09:43:22 <ski> (there are some Scheme implementations that have said they will definitely *not* implement (full) R6RS)
09:43:34 <nominolo> beutdeuce: :m - Module Name
09:43:35 <quicksilver> beutdeuce: :m Prelude
09:44:00 <beutdeuce> thnx
09:44:09 <ski> (of course, if you define Schemes to be those which implement R6RS ..)
09:44:36 <mauke> all C implementations conform to the C standard :-)
09:44:46 <PeakerWork> quicksilver: do you have a little time for another question about cojoin?
09:44:48 <SamB> mauke: no they don't
09:44:55 <SamB> also, which one ?
09:45:00 <dankna> I think that was a joke.  The joke being that they aren't C implementations unless they do.
09:45:01 <SamB> ski: that'd be a silly def
09:45:14 * ski thinks so too
09:45:15 <quicksilver> PeakerWork: questions don't take very long.
09:45:20 <PeakerWork> quicksilver: if you cojoin -- you get an   Event (Event a) -- the inner event is fine, but the outer event still accumulates infinite history?
09:45:26 <quicksilver> PeakerWork: as to whether I have time for an answer, we'll see.
09:45:35 <quicksilver> PeakerWork: The short answer is "yes, clearly" ;)
09:45:36 <SamB> for one thing, what about implementations of S through R5RS?
09:45:45 <quicksilver> PeakerWork: the long answer is "nothing is accumulating anything"
09:45:49 <SamB> well, RS through R5RS
09:45:56 <PeakerWork> quicksilver: what do you mean?
09:45:59 <quicksilver> PeakerWork: the outer event exists over all time. nothing gets accumulated, semantically.
09:46:09 <SamB> I guess succ RS == R1RS?
09:46:11 <quicksilver> PeakerWork: any thought about accumulation is just an implementation detail.
09:46:14 <boml> how can I extract the monad value in ghci?
09:46:17 <SamB> or perhaps it's spelled RRS?
09:46:17 <p_l> SamB: yup
09:46:32 <ski> SamB : `RRS', yes
09:46:38 <quicksilver> PeakerWork: the inner events (there are many, not just one) are each "truncated" and only look forward past a fixed point.
09:46:40 <p_l> Report on Scheme. R2S = Revised Report on Scheme, etc.
09:46:43 <boml> got it
09:46:47 <ski> RS,RRS,RRRS,RRRRS,RRRRRS
09:46:48 <nominolo> boml: x <- monad_action
09:46:53 <boml> nominolo: thx
09:46:57 <SamB> p_l: R2S?
09:46:59 <PeakerWork> quicksilver: but since you can scanl/accum on the outer-event, it has to keep all the older event occurances too?
09:47:01 <ski> Report on the algorithmic language Scheme
09:47:06 <ski> Revised^n Report on the algorithmic language Scheme
09:47:13 <PeakerWork> quicksilver: as long as it exists?
09:47:15 <p_l> SamB: just like ski said
09:47:16 <nominolo> boml: only works for IO, though.  otherwise, use the monad's run function
09:47:26 <ski> RnRS
09:47:37 <PeakerWork> quicksilver: are you saying that you're supposed to cojoin, do something with the result, and then discard the original event and the cojoin result?
09:47:47 <SamB> they really included (1) in the title of the first revision ?
09:47:54 <p_l> SamB: nope
09:47:54 <ski> no
09:47:59 <SamB> I was gonna say
09:48:31 <beutdeuce> robable fix: add a type signature that fixes these type variable(s)
09:48:31 <SamB> so, you have RS, RRS, R2RS, R3RS, ... ,R5RS
09:48:36 <beutdeuce> what does that mean?
09:48:48 <p_l> the old book I had somewhere referred to Revised Report on algorithmic language Scheme, RRS in short, and Revised Revised Report ... as R2RS
09:48:57 <dankna> I like how you used ellipses to omit a single item
09:48:57 <nominolo> beutdeuce: can you paste the full message?
09:49:04 <nominolo> beutdeuce: and the code
09:49:07 <beutdeuce> Ambiguous type variable `a' in the constraint:
09:49:07 <beutdeuce>       `Read a' arising from a use of `readLn' at <interactive>:1:5-10
09:49:07 <beutdeuce>     Probable fix: add a type signature that fixes these type variable(s)
09:49:09 <boml> SamB_XP: it wasn't a ptr after all. The DWORD represented a bitmask. sorry.
09:49:24 <PeakerWork> quicksilver: that could work, I think, but its so easy to accidentally leak Event references
09:49:29 <nominolo> beutdeuce: ah, GHC can't figure out what exactly you want to read
09:49:34 <beutdeuce> n <- readLn
09:49:35 <PeakerWork> quicksilver: I'm pretty sure Event is a bad primitive
09:49:50 <nominolo> beutdeuce: right, so what should n be?  a number, a string?
09:49:50 <PeakerWork> @type readLn
09:49:51 <lambdabot> forall a. (Read a) => IO a
09:50:06 <doserj> beutdeuce: you have to say somewhere what type n should have
09:50:33 <beutdeuce> let n :: Int ?
09:50:50 <nominolo> beutdeuce: no, n <- readLn :: IO Int
09:50:52 <ski>   n <- readLn :: IO Int
09:51:01 <PeakerWork> beutdeuce: there are many different readLn values in the world, one for each type in the Read type-class.  Each of them does a rather different thing. Which would you like to use?
09:51:08 <ski>   n :: Int <- readLn   -- with pattern signatures, iirc
09:51:25 <nominolo> ski probably requires (n :: Int) <- ...
09:51:30 <doserj> beutdeuce: either n <- readLn :: IO Int, or  ... (n::Int) ... later in the code, where you use n
09:51:39 <ski> nominolo : yes .. i was just wonding about that ..
09:51:46 <beutdeuce> it doesnt say i need to do that in the tutorial
09:52:06 * ski thought #haskell was part of the tutorial
09:52:11 <doserj> which tutorial?
09:52:18 <beutdeuce> learn haskell in 10 minutes
09:52:18 <nominolo> beutdeuce: it usually only happens in GHCi,  in a larger program it usually becomes clear from the use of 'n'
09:52:33 <boml> how to convert a bitmask to a string. The first bit is character 'a'. The second 'b' and so on. Example: foo 6 -> "bc".
09:52:54 <SamB> beutdeuce: the title exhaggerates greatly
09:53:18 <beutdeuce> SamB, i can see that ;) Anyway, it doesnt do any casting
09:53:29 <nominolo> beutdeuce: but GHCi has only the current line to work with, so you have to help out a bit by using type signatures
09:53:42 <ski> `n :: Int' is not casting .. it is constraining .. aka a type ascription
09:53:45 <beutdeuce> k
09:54:01 <quicksilver> PeakerWork: I think you're confusing the implementation of event with the semantics of event.
09:54:16 <ski> if `n' can't already have type `Int', then `n :: Int' is a type error
09:54:19 <quicksilver> PeakerWork: the implementation of event has drawbacks which make be severe enough to make them a bad primitive (I'm not convinced, but it may)
09:54:30 <quicksilver> PeakerWork: the semantics of Event are clearly a good primitive.
09:54:31 <quicksilver> IMO.
09:54:50 <beutdeuce> is there a difference between IO Int and Int? Because apparently, i cannot do n <- readLn :: Int
09:55:11 <quicksilver> yes. The difference is the two letters "IO"
09:55:16 <quicksilver> that's a pretty important two leters, though.
09:55:17 <ski> yes, `IO Int' is the type of `IO'-actions, that *when*run*, will yield a value of type `Int'
09:55:49 <ski> you run the action `readLn' there by putting it to the right of the `<-' sign, the `n' on the left gets the result of type `Int'
09:55:51 <nominolo> beutdeuce: the reason is that you give a type signature to 'readLn' not 'n'.
09:56:56 <lilac> PeakerWork: an Event's history only needs to be preserved if it's used in a context where the history is looked at
09:57:07 <PeakerWork> quicksilver: I think the semantics of Event + the semantics of Behaviors + the semantics of accumE expose too much power that is not efficiently implementable
09:57:10 <boml> is there a function in ghc to convert a decimal to a binary?
09:57:17 <beutdeuce> do putStrLn "What is 2+2?" ; x <- readLn :: IO Int ; if x == 4 then putStrLn "Correct!" else "Wrong!"
09:57:21 <beutdeuce> Couldn't match expected type `IO ()' against inferred type `[Char]'
09:57:27 <PeakerWork> lilac: The history may be looked at by applications of scanlE/accumE in any behavior at any time?
09:57:43 <PeakerWork> lilac: if you have a reference to an Event, you have a reference to all past history, because of scanlE, I think
09:57:44 <pikhq> beutdeuce: else putStrLn "Wrong!"
09:57:45 <ski> boml : what's a "decimal" ?
09:57:52 <mauke> :t showIntAtBase
09:57:54 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
09:58:03 <ski> boml : a number ? a string containing a numeral in base ten ?
09:58:15 <RayNbow> @hoogle showIntAtBase
09:58:16 <lambdabot> Numeric showIntAtBase :: Integral a => a -> (Int -> Char) -> a -> ShowS
09:58:19 <beutdeuce> lol, ya
09:58:22 <lilac> PeakerWork: you mean, if i put a reference to an event into a data structure somewhere?
09:58:28 <boml> ski: an integer
09:58:34 <lilac> PeakerWork: yes, that would be a space leak
09:58:47 <byorgey> beutdeuce: alternatively, you could write  putStrLn (if x == 4 then "Correct!" else "Wrong!")
09:58:51 <PeakerWork> lilac: well, something like keyPressed would likely be an event you'd want to keep around
09:59:09 <ski> > showIntAtBase 2 intToDigit 0x22 ""  -- boml ?
09:59:10 <lambdabot>   "100010"
09:59:19 <ski> > showIntAtBase 10 intToDigit 0x22 ""  -- boml ?
09:59:21 <lambdabot>   "34"
09:59:23 <PeakerWork> lilac: you can always re-get the "keyPressed" event and accumlE on it has the semantics of using all keys - so you must preserve all keys pressed in history
09:59:41 <PeakerWork> lilac: accumE/scanlE, I mean
10:00:13 <boml> ski, mauke, thx
10:00:21 <PeakerWork> quicksilver: keyPressed :: UI -> Event Key   -- Doesn't this + existence of scanlE/accumE already mean that you can never forget keys pressed in history?
10:00:34 <ski> beutdeuce : also `do putStrLn "What is 2+2?" ; x <- readLn :: IO Int; putStrLn (if x == 4 then "Correct!" else "Wrong!")'
10:01:08 <beutdeuce> ski, nice!
10:01:34 <boml> ski: how do you convert the number 6 to binary?
10:01:52 <ski> > showIntAtBase 2 intToDigit 0x6 ""
10:01:54 <lambdabot>   "110"
10:02:02 <PeakerWork> do putStrLn "What is 2+2?" ; x <- readLn; putStrLn $ if x == (4::Int) then "Correct!" else "Wrong!"
10:02:05 <ski> > showIntAtBase 2 intToDigit (12 `div` 2) ""
10:02:07 <lambdabot>   "110"
10:02:41 <boml> ski: what means 0x6?
10:02:58 <ski> the number denoted by the hexadecimal numeral `6'
10:03:18 <ski> (which happens to be the same number that is being denoted by the decimal numeral `6')
10:03:36 <boml> ski: how do you convert the number 256 to binary?
10:03:51 <mauke> > showIntAtBase 2 intToDigit 256 ""
10:03:53 <lambdabot>   "100000000"
10:03:54 <jmcarthur_work> PeakerWork, accumE doesn't mean events are always retained
10:03:57 <ski> i'm just trying to emphasize that `showIntAtBase' doesn't convert a *decimal* anything into something else
10:04:22 <ski> it converts a *number* to a numeral in a given base
10:04:52 <ski> (that number can come from anywhere .. a result of a function call, a decimal literal numeral, a hexadecimal literal numeral, et.c.)
10:05:13 <mauke> preflex: calc '2 12/2
10:05:13 <preflex>  110
10:05:18 <jmcarthur_work> PeakerWork, it just saves one event at a time to be combined with the next one, then it can toss the old one too
10:06:04 <jmcarthur_work> PeakerWork, of course, you could *use* it to retain all events...
10:06:04 <boml> @intToDigit 256
10:06:04 <lambdabot> Unknown command, try @list
10:06:44 * ski wonders why it isn't `showIntAtBase :: (Integral a,Integral b) => b -> (Int -> Char) -> a -> ShowS' ..
10:07:10 <ski> (or maybe `showIntAtBase :: Integral a => Integer -> (Int -> Char) -> a -> ShowS' ..)
10:07:27 <ski> > intToDigit 3
10:07:29 <lambdabot>   '3'
10:07:31 <ski> > intToDigit 10
10:07:32 <lambdabot>   'a'
10:07:35 <ski> > intToDigit 16
10:07:37 <lambdabot>   * Exception: Char.intToDigit: not a digit 16
10:08:05 <boml> i'm just trying to digest the intuition behind the showIntAtBase function.
10:08:34 <Woof> > showIntAtBase 3 9
10:08:35 <lambdabot>   No instance for (GHC.Num.Num (GHC.Types.Int -> GHC.Types.Char))
10:08:35 <lambdabot>    arising ...
10:08:43 <etpace_> Is there a 2d array type in haskell?
10:08:44 <jleedev> > showIntAtBase 2 intToDigit 42 []
10:08:46 <lambdabot>   "101010"
10:08:53 <ski> > map (showIntAtBase 2 intToDigit `flip` "") [0..]
10:08:54 <lambdabot>   ["0","1","10","11","100","101","110","111","1000","1001","1010","1011","110...
10:09:10 <Claudius1aximus> @instances Ix
10:09:11 <lambdabot> Couldn't find class `Ix'. Try @instances-importing
10:09:13 <pikhq> etpace_: [[a]]
10:09:19 <Claudius1aximus> @instances-importing Ix
10:09:20 <lambdabot> Couldn't find class `Ix'. Try @instances-importing
10:09:25 <etpace_> hm
10:09:29 <byorgey> etpace_: pairs are instances of Ix, so you can use array indices like (2,3)
10:09:34 <byorgey> which effectively gives you 2D arrays.
10:09:38 <pikhq> (strictly speaking a list)
10:09:39 <ski> etpace_ : `Array (i,j) a'
10:09:51 <pikhq> That too.
10:09:52 <byorgey> assuming you really do want *arrays* and not just a list of lists.
10:10:14 <etpace_> I guess a list of list could work, but how would I specify say, setting (2,3) to a certain value?
10:10:43 <pikhq> State!
10:10:56 <byorgey> etpace_: well, with a list of lists that is a bit icky, but it wouldn't be too hard in theory to write a function to do that for you.
10:10:57 <PeakerWork> jmcarthur_work: the fact that you *can* use accumE on keysPressed at any point in the future, means that it will be able to run the keys of the past through your accumulator -- meaning it must retain all history
10:10:59 * pikhq holds up a cross to hold back the demons
10:11:08 <lilac> PeakerWork: typically you *wouldn't* keep keyPressed around. you'd build something which acts on key presses and immediately use the keyPressed event there and nowhere else
10:11:09 <byorgey> etpace_: what are you trying to accomplish with these 2D arrays?
10:11:23 <ski> > array ((0,0),(2,2)) [((i,j),3*j+i) | j <- [0..2] , i <- [0..2]]
10:11:24 <lambdabot>   array ((0,0),(2,2)) [((0,0),0),((0,1),3),((0,2),6),((1,0),1),((1,1),4),((1,...
10:11:27 <ski> @type array ((0,0),(2,2)) [((i,j),3*j+i) | j <- [0..2] , i <- [0..2]]
10:11:29 <lambdabot> forall t. (Num t, Enum t, Ix t) => Array (t, t) t
10:11:39 <etpace_> I'm using them to represent an image, so say 1 at (2, 3) means a black pixel at (2, 3)
10:12:09 <lilac> PeakerWork: the 'reactive way' essentially is that you don't keep around anything which refers to the past (like keyPressed)
10:12:24 <portnov> ... humm. Zipper for Array (Int,Int) ?
10:12:41 <boml> ski: will showIntAtBase ever be called with anything else than intToDigit?
10:13:27 <dons> zippers for arrays?
10:13:31 <dons> interesting idea.
10:13:31 <byorgey> etpace_: well, a list of lists would be nice for doing various operations over the entire image -- you can use all the list processing functions in the standard libraries (map, zipWith, foldl/r, transpose....)
10:13:52 <ski> > showIntAtBase 17 intToDigit 3143 ""
10:13:53 <lambdabot>   "aef"
10:13:56 <ski> > showIntAtBase 17 intToDigit 3144 ""  -- boml
10:13:58 <lambdabot>   "* Exception: Char.intToDigit: not a digit 16
10:14:02 <byorgey> etpace_: but being able to set a particular element in a list of lists is a bit icky (but can be done easily enough, you just have to write your own function to do it).
10:14:17 <etpace_> I'll attempt to write the function, and see how icky it is
10:14:38 <edwardk> a not-quite-array-zipper is the Pointer comonad
10:14:46 <byorgey> etpace_: sounds good.  I suggest using 'splitAt' to take the lists apart
10:15:08 <ski> > showIntAtBase 2 (\x -> if x == 0 then '.' else '*') 157 ""  -- boml
10:15:10 <lambdabot>   "*..***.*"
10:15:25 <jmcarthur_work> PeakerWork, it should just mean that the accumulator is constantly running, shouldn't it?
10:15:30 <jmcarthur_work> well, ideally at least
10:15:36 <mauke> preflex: calc '2 11/2
10:15:36 <preflex>  101.1
10:15:52 <ski> preflex: calc '17 3144
10:15:52 <preflex>  aeg
10:15:55 <edwardk> you can define zipper focus changes for it (though they aren't comonadic)
10:15:56 <boml> ski: is there a practical application for this?
10:16:03 <byorgey> > let foo x l = l1 ++ (x:l2') where (l1,_:l2') = splitAt 4 l   in foo 2097 [1..10]
10:16:04 <portnov> > showIntAtBase 2 (\x -> if x == 0 then '.' else 'â€”') 157 ""
10:16:04 <lambdabot>   [1,2,3,4,2097,6,7,8,9,10]
10:16:05 <jmcarthur_work> and yeah, you wouldn't always have the accumulator around anyway
10:16:05 <lambdabot>   "\8212..\8212\8212\8212.\8212"
10:16:25 <jmcarthur_work> you would start it from some trigger event, not worrying about what came before
10:16:37 <byorgey> etpace_: ^^^ there
10:16:48 <byorgey> etpace_: ^^^ there's something to get you started in the 1D case
10:17:11 <edwardk> etpace: so you have an array for an image, what are you trying to do with it? (trying to parse through the backlog)
10:17:24 <byorgey> and you ought to be able to do the 2D case by doing the 1D case twice =)
10:17:48 <ski> (boml : i don't know if there's any more than the ones i've hinted at)
10:17:59 <boml> ski: ok. thx.
10:18:24 <etpace_> Firstly be able to plot a data set edwardk, and then perhaps attempt to draw lines between these dots
10:18:58 <PeakerWork> jmcarthur_work: look at lilac's answer...
10:19:30 <edwardk> etpace: ah. you might just want to look at using an Array (Int,Int) and using \\ to get started.
10:26:43 <paper_cc> can a function zipWithDef such as zipWithDef 0 (+) [1,2] [10, 20] == [11, 22] and zipWithDef 0 (+) [1,2] [10,20,30] == zipWithDef 0 (+) [10,20,30] [1,2] == [11,22,33] be formulated without explicit recursion?
10:27:34 <paper_cc> *oh. not [11,22,33] but [11,22,30]
10:28:09 <largos> dons: are you interested in bug reports for mkcabal?
10:28:23 <mauke> paper_cc: does 'fix' count as explicit recursion?
10:29:15 <conal> paper_cc: are you letting yourself use zipWith (or zip)?
10:29:54 <byorgey> paper_cc: sure.  Just make a new datatype  data Value a = Val a | Default a, and a way to lift binary operations on a's to operations on Value a's, and then do a takeWhile isVal after doing zipWith of the lited operation on the lists extended infinitely with Default values.
10:29:55 <dons> largos: yes, though mkcabal is kinda of in a bad state at the moment. It needs to be (easily) ported to the new cabal format
10:29:58 <paper_cc> mauke: well, I just want a clean formulation, so fix is less clean than using explicit recursion
10:29:58 <byorgey> if that made sense.
10:30:05 <dons> largos: so yep, report a bug, and I'll probably rewrite it soon
10:30:09 <dons> since a lot of newbies use it.
10:30:12 <byorgey> but I don't know if it's worth it.
10:30:15 <largos> dons: ah, ok
10:30:33 <paper_cc> conal: yes I do. but zipWith doesn't do what I want
10:30:40 <ski> (paper_cc : how about `foldr' instead of `fix' ?)
10:30:41 <largos> dons: yep, I'm one of those newbies ;).  I'll fire you an email or two with some minor issues.
10:30:41 <byorgey> dons: better yet, mkcabal ought to be folded into cabal-install, so you can just say  'cabal init' or somesuch
10:30:45 <conal> paper_cc: not by itself
10:31:05 <dcoutts> byorgey: yes, that's the plan, afaik
10:31:09 <PeakerWork> conal: hey
10:31:18 <dcoutts> byorgey: just waiting for dons or me or someone to have the time to do it
10:31:33 <conal> paper_cc: i'd zero pad both lists (++ repeat 0) then zipWith, then take the max of the original lengths.
10:31:34 <byorgey> dcoutts: yep, I see
10:31:39 <conal> PeakerWork: hi
10:31:56 <dons> byorgey: indeed
10:32:06 <paper_cc> byorgey: this seems an overkill :(
10:32:10 <byorgey> dcoutts, dons: well, I could probably do it if it isn't done by the end of August.
10:32:12 <conal> paper_cc: if you use genericLength and lazy naturals, zipWithDef can still be lazy
10:32:19 <PeakerWork> conal: trying to implement/thinking about FRP -- I only recently realized that a value of type  (Event a)  actually has to, in the implementation, refer to the entire history of the a's..  It makes me think that maybe instead of Event, something like a   (Time -> occurances of a since that time) is better to expose?
10:32:21 <dons> dcoutts: yeah, i've seen blogs and other things with people using mkcabal. I might get a chance to do the merge this week.
10:32:24 <dons> fingers crossed.
10:32:35 <byorgey> paper_cc: I agree.  what's so bad about explicit recursion here, anyway?
10:32:38 <dcoutts> dons: great, you know where to send the patches :-)
10:32:44 <dons> yep
10:32:52 <PeakerWork> conal: I mean   Event' a  whose semantic model is that (Time -> ..) function
10:32:58 <dons> and i'll merge in cabal2arch while I'm there :)
10:33:01 <dons> cabal arch mode
10:33:13 <dcoutts> dons: into cabal-install?
10:33:17 <dons> hehe
10:33:29 <dons> cabal install --as=arch
10:33:36 <dcoutts> dons: ok, good I'm glad you're joking
10:33:44 * dcoutts was slightly worried for just a second
10:33:51 <dons> heh
10:33:59 <beutdeuce> while in ghci, if i :m to a library, is there a way to list all that is in that namespace?
10:34:00 <dons> what other junk could we merge in??!
10:34:10 <dcoutts> dons: on the other hand, a lib that the cabal2native tools can share would be good
10:34:14 <dons> yes.
10:34:16 <beutdeuce> djahandarie: :m Network
10:34:22 <dons> but that's probably the Cabal lib
10:34:25 <conal> PeakerWork: yes, Event is like list.  the combinators drop elements as they go.
10:34:25 <mauke> beutdeuce: I hear there's a :browse
10:34:27 <dons> with docs on how to use it to write native packageds.
10:34:32 <dcoutts> dons: maybe, or something on top of it
10:34:40 <paper_cc> byorgey: I was trying to write it in terms of zip/zipWith/take/etc. without using length and was surprised that I couldn't
10:34:42 <ski> paper_cc : btw, we discussed almost exactly this problem earlier, today ..
10:34:48 <conal> PeakerWork: would Time -> ... help?  it's like Event/list but more so.
10:34:48 <beutdeuce> mauke, thnx
10:35:20 <ski> (`zipDefault' instead of `zipWithDefault' .. not a big difference)
10:35:44 <conal> paper_cc: were you avoiding length in order to preserve laziness/productivity?
10:36:45 <etpace_> http://codepad.org/rUKnveDm why does yBelow have type [Int], it should be a [[Int]] as it's just a split from a [[Int]]
10:37:08 <paper_cc> conal: yes. but I think I'll write an explicitly recursive version if there's no cleaner variant using Prelude functions
10:37:29 <conal> paper_cc: there is a cleaner way!  recursion is the goto of functional programming.
10:37:37 <ski> (yes)
10:38:07 <byorgey> etpace_: you probably want to use ++yBelow instead of  : yBelow.
10:38:16 * paper_cc goes to STFW
10:38:31 <ski> (see "The Anatomy of a loop" by Olin Shivers)
10:38:37 <beutdeuce> i'm getting an error while trying to use HTTP, http://pastie.org/535924
10:38:47 <byorgey> etpace_: (:) is for consing a list element onto the front of a list.
10:38:59 <conal> see "What About the Natural Numbers" by Colin Runciman
10:39:21 <byorgey> etpace_: that error message is saying that since yBelow has type [[Int]], it is expecting [xLeft ++ ...] to have type [Int], since you are trying to cons it onto the front of a list whose elements are of that type
10:39:30 <byorgey> but of course it doesn't.
10:39:38 <PeakerWork> conal: The problem as I see it - is that if you keep references to old Events, in order to later use them with "snapshot" or such, you're leaking the entire history.  You're supposed to use "cojoin"/"duplicate" explicitly to avoid memory leaks.. I'd rather the simple way to use Events did not leak
10:39:48 <byorgey> so you should use ++, which is for joining two lists of the same type into one list.
10:40:18 <etpace_> ah, it's because of the [] enclosing xLeft and xRight
10:40:18 <etpace_> thanks
10:40:35 <conal> PeakerWork: yeah. Event has the same "problem" as [] and recursive data types in general in functional programming.
10:40:46 <byorgey> etpace_: ah, you're right, the better solution would be to remove the [ ] .
10:41:15 <byorgey> etpace_: you might need to replace them with parens though, not sure about the relative precedence of : and ++
10:42:24 <PeakerWork> conal: in [] its kind of solvable by using the "beautiful Folds" data type, rather than explicitly writing code to work with the list.  I think with (Event a) it is solvable by using the alternative semantic model -- which discards old elements as a function of time by "default", and only keeps them if you accumulate them explicitly
10:43:42 <conal> PeakerWork: i want to encourage you to explore alternative models (because Event is problematic).  i want to point out also that the problem you're mentioning is pervasive in functional programming.
10:44:30 <PeakerWork> conal: I see, I was wondering if missing something so important like this Event problem meant that maybe I'm missing more fundamental stuff here, but it seems I'm just walking the usual trail :)
10:44:31 <Philonous> Is there a recommendable database with high-level haskell interface?
10:44:42 <PeakerWork> conal: thanks for clearing it up
10:45:25 <conal> PeakerWork: :).  Event *is* the weak link in the Reactive formulation of FRP.  it's the only type that does not follow the type class morphism discipline.
10:45:46 <conal> PeakerWork: so by all means, try out semantic alternatives!
10:46:37 <ski> conal : (i'm not sure if i know the required prerequisite knowledge, but) what is that "problem" with `[]' and recursive data types you were referring to ?
10:47:49 <conal> ski: if i hang onto the beginning of a list *and* traverse it, i'll get a space leak, and probably a time leak as well.
10:48:03 <ski> ok
10:48:28 <ski> basically the same as in naïve formulations of ambiguous parsers on lazy lists, then
10:48:42 <ski> (i was wondering if that was what you meant)
10:48:58 <conal> ski: yeah.
10:49:04 <lilac> paper_cc: is this a homework question? someone else was asking about a zipWithDefault earlier today
10:49:32 <paper_cc> lilac: not for me at least =) I'm implementing polynomials
10:49:45 <lilac> weird coincidence then
10:49:58 <lilac> > let zipDefault a b as bs = map (either id id *** either id id) . takeWhile anyLeft $ zip (map Left as ++ repeat (Right a)) (map Left bs ++ repeat (Right b)) where anyLeft (Right _, Right _) = False; anyLeft _ = True in zipDefault 0 'c' [1,2,3] "ab"
10:50:00 <lambdabot>   [(1,'a'),(2,'b'),(3,'c')]
10:50:02 <ski> (s/zipWithDefault/zipDefault/)
10:50:03 <Kashyap> Hi folks ... I am having some difficulty in following this code -> (map.map) (+1) [[1,2],[3,4]]
10:50:14 <lilac> paper_cc: ^^ there's one implementation ;-)
10:50:26 <paper_cc> lilac: thanks, I've already found this
10:50:26 <lilac> converting that from zip to zipWith left as an easy exercise
10:50:31 <portnov> :t showIntAtBase
10:50:33 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
10:50:39 <Saizan> Kashyap: do you know what (.) does?
10:50:42 <portnov> @index showIntAtBase
10:50:42 <lambdabot> Numeric
10:51:10 <Kashyap> yeah ,,, so the way I read it is that first the inner map would be applied ... meaning map (+1) [. .... ]
10:51:25 <Kashyap> but the problem is (+) cannot be applied to lists
10:51:34 <jeff_s_> I know this is off topic, but this channel is where I know where to find lots of smart people. Does anyone know (I assume a combinatorics) book that would help me learn techniques to solve puzzles like http://www.codechef.com/problems/INSOMB6/ ?
10:51:41 <Kashyap> but the whole thing works
10:51:49 <conal> what i like about the pad/zipWith/take/min solution to paper_cc's question is that the loss of laziness has such an localized, elegant and widely applicable fix.
10:51:53 <monochrom> (map . map) (+1) [[1,2],[3,4]] = map (map (+1)) [[1,2],[3,4]] = [map (+1) [1,2], map (+1) [3,4]]
10:52:03 <Philonous> Kashyap: This is equivalent to map (map (+1)) [[1,2],[3,4]]
10:52:06 <monochrom> > map (+1) [1,2] :: [Expr]
10:52:08 <lambdabot>   [1 + 1,2 + 1]
10:52:18 <Saizan> (map.map) (+1) list = (\f -> map (map f)) (+1) list = map (map (+1)) list
10:52:54 <Kashyap> oh. .. okay., .... I think I am beginning to see
10:53:34 <monochrom> map (map f) ... is idomatic in pushing f into two-levels of lists.
10:53:36 <Philonous> f .g = \x -> f (g x) so map . map = \x -> map (map x). ergo (map . map ) +1 = (\x -> map (map x)) (+1) = map (map (+1))
10:54:07 <beutdeuce> what is the simplest gui library for haskell that isnt os-dependent
10:54:10 <Philonous> (forgot the parens at ( +1 ))
10:54:20 <conal> and there are nice generalizations of the map.map trick involving pairs and more general containers
10:54:29 <Kashyap> cool...thank Saizan and Philonos
10:54:30 <conal> as well as to generalizations of functions
10:55:08 <jeff_s_> beut - probably a Tk binding (not that I've worked with tk from haskell)
10:55:43 * ski . o O ( `onLines',`perLine' )
10:56:28 <ikegami__> I guess that GHC 6.10.4 will be shipped recently, because the number of open tickets is only one. (viewing the trac)
10:56:54 <paper_cc> lilac: well, the solution with lazy Nat would be really cleaner if the genericFoo were simply foo
10:57:40 <PeakerWork> conal: something that looks cool about this alternate model, possibly, is that it might allow the implementation to treat Event as a mutable list of observers in IO, or such (and do no queuing at all).  This might be simple, hopefully..
10:57:46 <jmcarthur_work> PeakerWork, it sounds like you are exploring the same model i am, at the moment
10:57:55 <conal> paper_cc: yeah. the pretty names are reserverd for the specialized functions and the ugly names for the generalizations.  bummer!
10:58:00 <PeakerWork> jmcarthur_work: Event as   Time -> list of events from this time on?
10:58:05 <jmcarthur_work> yes
10:58:09 <jmcarthur_work> err
10:58:14 <jmcarthur_work> close
10:58:24 <conal> paper_cc: like some of the changes from haskell 1.4 to haskell 98.
10:58:42 <gbacon> spj commented on my blog! *fanboi*
10:58:51 <lilac> paper_cc: yep. it's still a bit imperative for my tastes though
10:59:06 <conal> gbacon: url?
10:59:20 <lilac> "first we work out the length, then we produce that many elements, like so: ..."
10:59:28 <conal> PeakerWork: if you can get the semantics (exactly) correct, i'll be impressed!
10:59:29 <gbacon> conal: http://gbacon.blogspot.com/2009/06/cleaning-up-your-haskell-imports.html
10:59:46 <jmcarthur_work> PeakerWork, my semantics are something like Behavior t [a], where the value is [] for no event... that isn't my implementation though, just the model
10:59:59 <conal> gbacon: thx.
11:00:01 <paper_cc> lilac: the uncurry (||) . (isJust *** isJust) version is a bit long and overcomplicated for imperative /me
11:00:18 <lilac> paper_cc: please, isJust *** isJust >>> uncurry (||)
11:00:46 <lilac> ;-)
11:00:59 <ikegami__> gbacon: Seeing spj's comment, your work is really great
11:01:12 <lilac> just a pity you can't write it as join (***) isJust >>> uncurry (||)
11:01:20 <beutdeuce> for some reason, ghc keeps telling me it cant find module 'Network' when i already installed it with cabal, why is that?
11:01:32 <lilac> darn monomorphism getting in the way
11:01:39 <paper_cc> :t join (***)
11:01:40 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
11:01:48 <paper_cc> :t join (***) isJust
11:01:50 <lambdabot> forall a. (Maybe a, Maybe a) -> (Bool, Bool)
11:01:55 <lilac> @type isJust *** isJust
11:01:56 <lambdabot> forall a a1. (Maybe a, Maybe a1) -> (Bool, Bool)
11:02:04 <lilac> a small but key difference
11:02:14 <paper_cc> aha
11:02:20 <PeakerWork> jmcarthur_work: yeah, exactly, behavior of list of events from that time.
11:02:24 <PeakerWork> anyway, gotta run
11:02:35 <jmcarthur_work> oh, "from" threw me off
11:02:42 <jmcarthur_work> you meant at exactly that time?
11:03:08 <ski>   isJust :: Maybe (exists a. a) -> Bool  -- hm
11:03:32 <paper_cc> lilac: I don't know how to write join to avoid it thoug
11:03:35 <paper_cc> +
11:03:36 <paper_cc> +h
11:04:13 <Saizan> beutdeuce: are you compiling via cabal again?
11:04:48 <Saizan> beutdeuce: if so you've to put network in the build-depends field
11:04:53 <Saizan> beutdeuce: in the .cabal file
11:05:54 <beutdeuce> Saizan, http://pastie.org/535957
11:06:23 <beutdeuce> anyone? http://pastie.org/535957
11:06:52 <jmcarthur_work> conal, my current attempt at an implementation looks similar to: type Event t a = Behavior t (Event t a, [(t, a)]), where the second component is a list of all accumulated events since the beginning of time, and the first component is a "reset" Event where all previous events have been dropped. the idea is that you can drop the current event in favor of the new one, which allows old events to be GCed. i'm not very in implementation yet, thou
11:06:53 <jmcarthur_work> gh
11:07:06 <jmcarthur_work> *very far in implementation yet
11:07:42 <jmcarthur_work> i haven't worked out how to manage the old Events and the reset Events yet
11:08:31 <etpace_> > unlines $ map (\x -> unwords $ map show x) $ [[1,2], [3,4]]
11:08:32 <lambdabot>   "1 2\n3 4\n"
11:08:53 <etpace_> How can I remove the lambda from there? I'm trying but I keep getting errors
11:09:03 <etpace_> > unlines $ map unwords $ map show $ [[1,2], [3,4]]
11:09:04 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
11:09:57 <dons> @pl unlines $ map (\x -> unwords $ map show x) $ y
11:09:57 <jmcarthur_work> > unlines . map (\x -> unwords . map show $ x) $ [[1,2], [3,4]]
11:09:58 <lambdabot> unlines (map (unwords . map show) y)
11:09:59 <lambdabot>   "1 2\n3 4\n"
11:10:03 <jmcarthur_work> > unlines . map (unwords . map show) $ [[1,2], [3,4]]
11:10:04 <lambdabot>   "1 2\n3 4\n"
11:10:10 <beutdeuce> why cant i use the network library -> http://pastie.org/535957
11:10:56 <etpace_> ah, thanks
11:11:24 <roconnor> @free sequence
11:11:26 <lambdabot> Expected variable or '.'
11:11:35 <roconnor> @type sequence
11:11:36 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
11:11:45 <roconnor> @free sequence :: [[a]] -> [a]
11:11:46 <lambdabot> $map f . sequence = sequence . $map ($map f)
11:11:59 <jmcarthur_work> etpace_, \d -> a $ b $ c $ d  ==  \d -> a . b . c $ d  ==  a . b . c
11:12:31 <lilac> paper_cc: i think you'd need a much more exciting type system to be able to define a join which works in that case
11:12:31 <jmcarthur_work> etpace_, and:  a $ b c  ==  a $ b $ c
11:12:47 <ski> @free sequence :: [Maybe a] -> Maybe [a]
11:12:48 <lambdabot> $map_Maybe ($map f) . sequence = sequence . $map ($map_Maybe f)
11:12:58 <lilac> paper_cc: or at least to deduce the right type ...
11:13:17 <etpace_> thanks
11:13:51 <paper_cc> lilac: at least I can't think of a solution in RankNTypes
11:13:58 <conal> jmcarthur_work: t -> [a] is my mental model also.  strangely, though, the TCMs don't work out!
11:14:04 <roconnor> @free sort
11:14:06 <lambdabot> Extra stuff at end of line in retrieved type "forall a. (Ord a) => [a] -> [a]\n"
11:14:13 <roconnor> @free sortBy
11:14:15 <lambdabot> (forall x. g x = h (f x) . f) => $map f . sortBy g = sortBy h . $map f
11:14:23 <ski> lilac : i think `exists' could do it ..
11:14:31 <conal> jmcarthur_work: even with type composition, i.e., Event = (T ->) . []
11:15:47 <conal> jmcarthur_work: and i've come to trust TCMs a lot.  the failure in this case suggests to me that i'm on the wrong track with events.
11:16:35 <portnov> loopIO m = do m
11:16:35 <portnov>               loopIO m
11:16:35 <portnov> It that `Control.Monad.forever` ?
11:16:45 <paper_cc> :t forever
11:16:47 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
11:16:58 <conal> yay!  forever's type got fixed.
11:17:17 <paper_cc> the type got ... well ... inobvious
11:18:09 <conal> paper_cc: the polymorphism is saying something very important about forever.
11:18:20 <lilac> conal: what was it formerly? m a -> m ()? m a -> m Void?
11:19:03 <conal> lilac: i forget now.  maybe the former.  anyone here remember?  i only remember what i wanted it to be and kept assuming it was.
11:19:10 <conal> which it now is.
11:19:12 <ski> portnov : yes
11:19:22 <roconnor> m a -> m (forall b. b)  would be better :)
11:19:30 <paper_cc> conal: that forever m is like const $ return _|_. which makes me think for a bit
11:19:38 <portnov> ok. So, I'm fixing a bicycle :)
11:19:47 <_nickel> can anyone tell me the reason for the $ operator here:  filter odd . map (^2) $ [1..]
11:20:12 <ski>   filter odd . map (^2) $ [1..]  =  (filter odd . map (^2)) [1..]  =  filter odd (map (^2) [1..])
11:20:18 <lilac> conal: we had a discussion on this last week; there are some pragmatic reasons why m a -> m Void would be better
11:20:19 <roconnor> f . g $ a = f (g a)  whereas  f . g a = f (g a x)
11:20:22 <Zao> (filter odd) . (map ^2 [1..]) otherwise
11:20:23 <roconnor> er
11:20:27 <roconnor> f . g $ a = f (g a)  whereas  f . g a = \x . f (g a x)
11:20:27 <Zao> Which likely isn't what you want.
11:20:36 <conal> lilac: do you remember the reasons?
11:20:36 <monochrom> paper_cc: You can conclude it's an infinite loop, but there are still two kinds of infinite loop, those that do nothing and those that do something infinitely often.
11:20:41 <roconnor> f . g $ a = f (g a)  whereas  f . g a = \x -> f (g a x)
11:20:43 <lilac> conal: essentially, you get a type error if you try to use the result
11:20:49 <_nickel> thanks all
11:20:58 <monochrom> forever (putStrLn "hello") will do something infinitely often.
11:21:03 <ski> (unless you use it as type `Void' .. or explicitly convert with `void :: Void -> a')
11:21:12 <_nickel> I think this stems from a misrepresentation of the $ in my head
11:21:26 <monochrom> @src forever
11:21:27 <lambdabot> Source not found. :(
11:21:52 <conal> lilac: nice
11:22:16 <lilac> also, i had a question. is 'forever act = act >> forever act' ever worse than 'forever act = let result = act >> result in result'?
11:22:33 <monochrom> Deducing things from a monadic type is problematic because it hides monadic actions (like side effects).
11:22:34 <lilac> i ask because the former is what Control.Monad uses as its definition, and i thought it should be the latter
11:22:37 <ski>   subst :: Monad m => (a -> m a) -> m a -> m b  -- cousin of `forever'
11:23:16 <conal> lilac: i'm with you.  the latter would be more efficient, unless the compiler is very clever.
11:23:26 <ski> (lilac : it's probably similar to `repeat a = a : repeat a' vs. `repeat a = as where as = a : as')
11:23:29 <lilac> conal: i thought so at first, but in which monad?
11:23:30 <monochrom> My hunch is I prefer â€œlet result = act >> result in resultâ€ too but I don't mind.
11:23:37 <HugoDaniel> hello
11:23:58 <lilac> it's easy to come up with cases where naive fix is worse than smart fix
11:24:12 <lilac> (naive fix is 'fix f = f (fix f)')
11:25:01 <monochrom> â™¡ haskell
11:25:04 <lilac> but at least in the more common monads the two definitions of forever seem operationally to be pretty much equivalent
11:25:21 <beutdeuce> how can i view a web page using haskell?
11:26:20 <Zao> beutdeuce: Fetch or view?
11:26:38 <beutdeuce> Zao, fetch
11:26:59 <paper_cc> beutdeuce: using Network.HTTP for example
11:27:13 <beutdeuce> paper_cc wont work
11:27:32 * roconnor still wants repeatM
11:27:34 <jmcarthur_work> conal, well, the tcms work for monoid, just not for applicative/monad. for now, i'm just using the tcms from my model instead of trying to use the ones from your paper
11:27:48 <Zao> beutdeuce: Beeecause?
11:28:06 <jmcarthur_work> i think i might be able to have some auxillary functions to do that functionality, or something
11:28:18 <paper_cc> beutdeuce: well, there's also a wget wrapper, but why is http wrong?
11:28:23 <beutdeuce> Zao, paper_cc, http://pastie.org/535957
11:28:31 <conal> jmcarthur_work: i saw the same.  tcms for monoid and functor (latter only if you use type composition), butnot applicative & monad.
11:28:33 <lilac> @type sequence.repeat
11:28:35 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m [a]
11:28:41 <lilac> roconnor: ^^ that one?
11:28:48 <conal> jmcarthur_work: what do you mean about using "tcms from my model"?
11:28:59 <roconnor> lilac: yep
11:29:23 <roconnor> people say it is useless, but I used it in the ICFPC this year
11:29:32 <lilac> roconnor: for what?
11:29:35 <roconnor> ... well until it got turned into a mapM
11:29:38 <lilac> hehe
11:29:40 <jmcarthur_work> conal, your model for event is [(t,a)], which is what drives the semantics for Applicative, right?
11:29:44 <jmcarthur_work> in Reactive, that is
11:30:06 <paper_cc> beutdeuce: that seems like a broken installation of http (without network)
11:30:08 <roconnor> lilac: simulate = repeatM (runSimulatorStep)
11:30:11 <jmcarthur_work> i meant the *semantics* from your model, not the tcms
11:30:11 <lilac> tcms for functor seem overkill since functor is unique anyway
11:30:13 <conal> jmcarthur_work: yes that's the model, but no it doesn't drive the semantics.
11:30:19 <beutdeuce> paper_cc, how can i fix it?
11:30:22 <jmcarthur_work> conal, not all of them, i know
11:30:36 <conal> jmcarthur_work: that's what i meant about TCM failure for Event.
11:30:37 <jmcarthur_work> not for Applicative, either?
11:30:45 <lilac> roconnor: which monad were you working in?
11:30:47 <paper_cc> beutdeuce: what does `ghc-pkg list' say?
11:30:55 <balor> QuickCheck seems to test my properties 100 times by default.  How can I test a property only 10 times?
11:31:01 <jmcarthur_work> right. i'm trying to just stick with what the tcms are telling me instead of forcing it to be what i *think* it should be, for now
11:31:11 <conal> jmcarthur_work: good!
11:31:24 <roconnor> lilac: ST
11:31:27 <roconnor> er
11:31:32 <beutdeuce> paper_cc, http://pastie.org/535995
11:31:33 <roconnor> lilac: Lazy.ST
11:31:41 <lilac> roconnor: ah, that makes sense :)
11:31:53 <roconnor> ST.Lazy
11:31:55 <roconnor> whatever it is called
11:31:58 <Zao> Oh dear, OSX. Great fun, that platform.
11:32:17 <beutdeuce> paper_cc, though when in ghci and i try that Network.HTTP thing, it says package HTTP-4000.0.6 not found, even though its installed
11:32:26 <lilac> roconnor: well, Control.Monad.ST.Lazy.ST, so i guess you were right both times ;-)
11:32:40 <roconnor> lilac: it was a bit more like: simulate = repeatM (StrictSTToLazyST runSimulatorStep)
11:32:46 <beutdeuce> paper_cc "ghc: unable to load package `HTTP-4000.0.6'
11:32:52 <edwardk> lilac: i can't come up with any monad off the top of my head that really wins from the forever a = f where f = a >> forever a -- optimization
11:33:03 <conal> jmcarthur_work: in the case of event, i haven't been able to see the TCM answer for Applicative & Monad as useful.  that's why i'm suspicious of the (t->).[] model
11:33:03 <roconnor> @src forever
11:33:04 <lambdabot> Source not found. Take a stress pill and think things over.
11:33:09 <edwardk> er forever a = f where f = a >> f
11:33:18 <beutdeuce> paper_cc, http://pastie.org/536000
11:33:21 <paper_cc> beutdeuce: seems like you have _three_ different versions of the network package
11:33:28 <roconnor> edwardk: oh I never thought of that
11:33:42 <jmcarthur_work> conal, i think it could be useful, and i could just implement the other semantics through aux functions or a newtype wrapper or something
11:34:13 <conal> jmcarthur_work: would you lose the guiding hand of TCM in the newtype?
11:34:20 <paper_cc> beutdeuce: so ghci says basically the same (a missing symbol in the "network" package)
11:34:20 <stulli> balor: http://www.haskell.org/haskellwiki/Introduction_to_QuickCheck#Coverage
11:34:31 <jmcarthur_work> conal, the newtype would be another model. probably not 100% exposed implementation
11:34:44 <edwardk> because in general you're going to recopy in your monadic bind operator in order to substitute
11:34:44 <jmcarthur_work> i'm just thinking maybe i could provide *both* models
11:34:46 <conal> jmcarthur_work: i'm not thinking of implementation at all.
11:34:55 <beutdeuce> paper_cc, can cabal remove the older 2 network packageS?
11:34:56 <conal> (in this conversation)
11:34:59 <edwardk> er s/recopy/copy/g
11:35:01 <lilac> edwardk: s/>> forever a/>> f/ presumably? i found the same, but i'm still not certain one doesn't exist.
11:35:09 <edwardk> yeah
11:35:30 <jmcarthur_work> conal, by "not exposed implementation" i mean maybe even "not allow developer to wrap Event with this newtype himself"
11:35:31 <lilac> edwardk: perhaps a monad where the contained type is a phantom? ;-)
11:35:32 <conal> jmcarthur_work: just to be clear, i'm looking for a complete semantics that follows the TCM principle without exception.
11:35:33 <jleedev> @pl f x = x >> f x
11:35:34 <lambdabot> f = fix (ap (>>))
11:35:39 <jmcarthur_work> maybe some sort of semantic function can map between the two or something
11:35:40 <roconnor> edwardk: Identity monad?
11:35:41 <paper_cc> beutdeuce: the first problem is that the latest network-2.2.1.3 is installed locally in your $HOME
11:36:08 <jmcarthur_work> not semantic function
11:36:12 <jmcarthur_work> i don't know the word i want
11:36:17 <paper_cc> beutdeuce: the second is that cabal can't remove packages. you have to `ghc-pkg unregister' them and then remove package files by hand
11:36:21 <edwardk> roconnor: hrmm
11:36:22 <etpace_> > [[x*y `mod` 2 | x <- [1..100]] | y <- [1..100]]
11:36:23 <lambdabot>   [[1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1...
11:36:38 <lilac> edwardk: i wonder whether the monad laws imply that you can't do any sharing in (>>)
11:36:42 <beutdeuce> paper_cc, is it bad that its in $HOME, because thats where cabal installed it
11:36:44 <roconnor> edwardk: oh maybe not
11:37:09 <lilac> roconnor: forever _ = _|_ in identity, right?
11:37:12 <dcoutts> beutdeuce: the default per-user prefix is $HOME/.cabal/
11:37:13 <edwardk> roconnor: that just gives you a bottom there
11:37:14 <roconnor> forever is quite different from fix
11:37:18 <edwardk> yeah
11:37:20 <jmcarthur_work> conal, list has two sets of semantics, one is nondeterminism, one is zipping. i suspect it might still be meaningful for have a similar setup for Event
11:37:27 <jmcarthur_work> *to have
11:37:34 <lilac> aha, perhaps Writer?
11:37:41 <paper_cc> beutdeuce: you should have used cabal install --global
11:37:56 <lilac> would the smart forever take the smart fixed point of the written state?
11:38:00 <edwardk> as i recall there is a very good reason for mfix and cofix being monad-specific, but i don't recall ever seeing one for forever
11:38:03 <paper_cc> beutdeuce: also if you want to unregister or hide it, use ghc-pkg --user
11:38:06 <conal> jmcarthur_work: i like that example, as the dual semantics of [] troubles me.
11:38:13 <beutdeuce> paper_cc, why global
11:38:19 <conal> jmcarthur_work: let's look at [] via the TCM lens.
11:38:38 <edwardk> lilac: writer isn't that smart. it has listen and pass that !@(#*) it up.
11:38:44 <jmcarthur_work> mmkay
11:38:52 <edwardk> If it wasn't cocked up by those two methods, perhaps.
11:38:54 <paper_cc> beutdeuce: --global is the opposite of --user. global installs into /usr/local (or something like this) and user installs into $HOME
11:39:24 <paper_cc> beutdeuce: you can also edit your ~/.cabal/config to make --global the default
11:39:27 <beutdeuce> paper_cc, ghci only sees whats in global?
11:39:33 <paper_cc> beutdeuce: no
11:39:35 <lilac> edwardk: yeah. we could do with a MonadGenerator which /only/ has tell (and a runGenerator :: MonadGenerator g a -> ([g], a) )
11:40:10 <paper_cc> beutdeuce: it sees your per-user version, but your http is linked against one of the global ones
11:40:12 <jmcarthur_work> conal, what is it about the dual nature of [] that troubles you?
11:40:25 <beutdeuce> paper_cc k
11:40:25 <beutdeuce> paper_cc thnx
11:40:26 <jmcarthur_work> conal, that the same structure doesn't converge to just one semantics?
11:40:30 <dcoutts> beutdeuce: generally it's fine to use the default of per-user installed packages. I recommend that default and only using --global if there are particularly good reasons (like wanting to share the same package between many users)
11:40:35 <lilac> > take 5 . snd . runWriter $ forever (tell [1])
11:40:37 <lambdabot>   [1,1,1,1,1]
11:40:48 <paper_cc> beutdeuce: you can use `ghci -hide-package network-2.2.1.3' as a quick fix
11:40:54 <jmcarthur_work> conal, or perhaps that we should have separate type classes for the different semantics?
11:41:02 <jmcarthur_work> Zip, for example?
11:41:16 <paper_cc> beutdeuce: or ghc-pkg --user hide network-2.2.1.3 to make this the default
11:41:33 <lilac> , vacuum . snd . runWriter $ forever (tell [1])
11:41:34 <lunabot>  luna: Not in scope: `tell'
11:41:49 <beutdeuce> paper_cc i unregistered it
11:42:07 <beutdeuce> and left only one, the one it said is linked to HTTP
11:42:08 <paper_cc> beutdeuce: then rm it
11:42:24 <beutdeuce> where is it located?
11:42:24 <jmcarthur_work> conal, aside: i find it odd that i have so much trouble quantifying the difference between Zip and Applicative, besides perhaps that zip and unzip should be inverses (which oddly excludes [])
11:42:51 <conal> jmcarthur_work: that there are two compelling Applicative instances and one gets a priviledged status
11:42:58 <conal> (what troubles me)
11:43:13 <lilac> is unsafeInterleaveIO = stToIO . strictToLazyST ?
11:43:21 <jmcarthur_work> conal, ah! as opposed to Monoid Int, which has no instance but has several newtypes instead?
11:43:34 <beutdeuce> paper_cc still error that it cant find HTTP
11:44:06 <conal> jmcarthur_work: i like that example.  yeah.  one style of decision was made for [] and a different one for Int.
11:44:07 <conal> thx
11:44:14 <beutdeuce> paper_cc, not find, *load
11:44:30 <paper_cc> beutdeuce: try to -hide-package network-2.2.1.1 or -hide-package network-2.2.1.1
11:44:36 <paper_cc> (whichever works)
11:45:03 <conal> jmcarthur_work: continue on #haskell-overflow?
11:45:15 <conal> jmcarthur_work: oh, oops.
11:45:34 <conal> jmcarthur_work: or #haskell-indepth .  i forget the difference.
11:45:53 <jmcarthur_work> conal, sure
11:45:58 <jmcarthur_work> i joined the latter
11:46:22 <beutdeuce> paper_cc, how do u unhide?
11:47:59 <paper_cc> beutdeuce: ghc-pkg unhide foo (for default settings) or -package foo (on the GHC command line for local modifications)
11:48:40 <edwardk> bah, if you're going to limit it to [g] you might as well permit an arbitrary g `Reducer` =)
11:49:03 <edwardk> or Monoid
11:50:17 <etpace_> Is there a difference between Int and Integer?
11:50:37 <edwardk> jmcarthur: unzip is a universal construction. zip should be a left inverse for that.
11:50:58 <edwardk> jmcarthur: sure, its applicative, but there are plenty of Applicatives that aren't left inverses for the unzip construction
11:51:21 <beutdeuce> paper_cc, thnx for your help :)
11:52:00 <jmcarthur_work> edwardk, ah, just a left inverse. that works better for me
11:52:20 <edwardk> @type fmap fst &&& fmap snd
11:52:21 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a, b) -> (f a, f b)
11:53:08 <natthew2> what's the fastest way to write and read an enormous list of doubles to the hard drive?
11:53:10 <edwardk> a left inverse may not always exist/be total
11:53:38 <edwardk> jmcarthur_work: http://comonad.com/reader/2008/zipping-and-unzipping-functors/
11:54:47 <_dr> hi, is there a given function to check whether an element is part of a list?
11:55:00 <edwardk> oh, and the categorical dual of that notion: cozipping: http://comonad.com/reader/2008/cozipping/
11:55:11 <edwardk> which has decidability issues =)
11:55:22 <edwardk> afk a bit
11:56:21 <natthew2> @_dr elem
11:56:22 <lambdabot> Maybe you meant: arr id
11:56:40 <_dr> natthew2: thanks
11:56:43 <natthew2> elem 1 [1,2,3,4] -> true
11:59:26 <natthew2> does readPrec_foo write anything to disk?
11:59:30 <monochrom> etpace_:
11:59:36 <monochrom> > 39284983294832759874397583945 :: Int
11:59:37 <lambdabot>   -5244014384180446647
11:59:44 <monochrom> > 39284983294832759874397583945 :: Int
11:59:46 <lambdabot>   -5244014384180446647
11:59:49 <monochrom> > 39284983294832759874397583945 :: Integer
11:59:50 <lambdabot>   39284983294832759874397583945
12:00:08 <etpace_> ok, thanks
12:00:40 <madhadron> Can anyone think of a reason why I should be getting garbage in I/O to a POSIX serial port?
12:00:41 <roconnor> > 5 `elem` [1..]
12:00:42 <lambdabot>   True
12:01:06 <etpace_> What's the best way to take a list like [a, b, c] and return [(1, a), (2, b), (3, c)]?
12:01:20 <monochrom> zip [1..] [a,b,c]
12:01:28 <monochrom> > zip [1..] [a,b,c] :: [Expr]
12:01:29 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
12:01:33 <etpace_> doh
12:01:34 <etpace_> thanks
12:01:38 <monochrom> > zip [1..] [a,b,c] :: [(Int,Expr)]
12:01:40 <lambdabot>   [(1,a),(2,b),(3,c)]
12:02:39 <roconnor> > zip [1..] [a,b,c]
12:02:40 <lambdabot>   [(1,a),(2,b),(3,c)]
12:03:06 <roconnor> etpace_: I think you really want zip [0..] [a,b,c]
12:03:17 <roconnor> unless you are doing something strange
12:03:26 <etpace_> I do
12:03:29 <roconnor> like making something human readable :)
12:03:43 <monochrom> Just change the human.
12:03:54 <madhadron> roconnor, As a human, I find that offensive.
12:04:06 <monochrom> This one is not a particularly unreasonable change.
12:04:11 * roconnor renumbers his thesis to start with page 0.
12:04:31 <monochrom> Dijkstra and my supervisor already start with page 0.
12:04:35 <roconnor> 0 is the zeroth natural number.
12:04:36 * madhadron once watched a half page long expression collapse down to something manageable when he numbered starting with 0.
12:04:53 <pikhq> Perhaps he means zipWith (\x y->(x,y)) [1..] [a,b,c]? :P
12:05:06 <monochrom> My supervisor jokes "they should be 0st, 1nd, 2rd..."
12:05:27 <etpace_> @src foldl
12:05:27 <lambdabot> foldl f z []     = z
12:05:28 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
12:05:38 <roconnor> @src zip
12:05:38 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
12:05:38 <lambdabot> zip _      _      = []
12:05:48 <monochrom> By definition zipWith (\x y -> (x,y)) = zip.
12:05:56 <roconnor> @pl zipWith (\x y->(x,y)) [1..] [a,b,c]
12:05:56 <lambdabot> zip [1..] [a, b, c]
12:05:58 <pikhq> monochrom: Well, duh.
12:06:00 <Zao> madhadron: Ensured that you've got the right baud rate, parity, stop bits, handshaking, pie quotient?
12:06:00 <pikhq> It was a joke.
12:06:14 <monochrom> Hrm!
12:06:15 <jleedev> @pl \x y -> (x,y)
12:06:16 <lambdabot> (,)
12:06:19 <pikhq> Not an exceptionally good one, mind, but...
12:06:20 <madhadron> Zao, Yup.
12:06:23 <roconnor> (,)
12:06:28 <madhadron> Zao, I can get commands back and forth.
12:06:41 <madhadron> It's just that the hardware on the other side is misbehaving under Haskell
12:06:46 <roconnor> computers have serial ports?
12:06:51 <madhadron> and behaving when I try it with the Python serial library
12:06:55 <madhadron> roconnor, Only to run microscopes
12:06:56 <p_l> roconnor: ...
12:07:04 <pikhq> roconnor: They have a Universal Serial Bus.
12:07:08 <Philonous> At the first glance the berkeleydb package seems to implement (pure) database updates via unsafePerformIO-ing an actual update of the database. This is basically suicide, is it not?
12:07:13 <roconnor> pikhq: does that count?
12:07:37 <roconnor> Philonous: what you describe sounds suicidal
12:07:38 <p_l> pikhq: I call that Universal Shitty Bus... though one of my prized machines got nice serial console xD
12:07:45 <madhadron> This is particularly irksome since I'm the one who posted the serial library to Hackage.
12:07:58 <nomeata> Hi. Does Malcolm.Wallace hang around here?
12:08:24 <nomeata> Or does anyone know if the test failure of cpphs-1.7 that Iâ€™m experienceing here is problematic?
12:09:12 <nomeata> (FAILED: (expect38)  ../cpphs mauke)
12:09:14 <monochrom> haha madhadron
12:09:31 <Philonous> Can someone confirm that this is actually the case? I may be missing some nifty tricks (maybe berkeleyDB can branch databases or something... )
12:09:57 <_dr> another Q: my university lecture printout i can use "where" for convenience
12:10:10 <_dr> http://pastebin.com/m2b1440b7 doesn't work in this case... can someone tell me why?
12:10:20 <madhadron> I thought maybe there was something funny about converting Fd's to Handle's, and tried stripping out the Haskell IO entirely
12:10:24 <madhadron> ...which made the situation worse.
12:10:30 <madhadron> How, I'm really not sure.
12:10:53 <monochrom> _dr bad indentation. move the "where..." a few spaces to the left.
12:11:08 <Philonous> _dr you seem to be missing an = after otherwise
12:11:12 <Raevel> _dr: one thing is that you're using elem infix, so it should be `elem`
12:11:13 <monochrom> And what Philonous says.
12:11:26 <_dr> thanks
12:11:36 <monochrom> I guess the indentation is fine then.
12:11:57 <mauke> 'where' itself doesn't care where you put it
12:12:08 <mauke> you could even move it to the previous line
12:12:17 <roconnor> this vokale code looks familiar :D
12:12:38 <nomeata> mauke: I guess that test is named after you. Do you know more about it?
12:12:59 <mauke> nomeata: hmm, what does the test look like?
12:13:10 <monochrom> Wow we had the mauke processor and now we have the mauke test?!
12:13:30 <Zao> I prefer the GNU variant gmauke.
12:13:34 <pikhq> Soon we'll have the mauke language.
12:13:50 <monochrom> Now I need to know how to pronounce mauke
12:14:17 <nomeata> mauke: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6585#a6585
12:14:28 <roconnor> @src sequence
12:14:29 <lambdabot> sequence []     = return []
12:14:29 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
12:14:29 <lambdabot> --OR
12:14:29 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
12:14:31 <Badger> maw-kuh
12:14:39 <Badger> gotta be
12:14:51 <roconnor> @free foldr
12:14:52 <lambdabot> (forall x. g . h x = k (f x) . g) => g . foldr h y = foldr k (g y) . $map f
12:15:34 <Badger> roconnor: when it says or, which is actually implemented?
12:15:52 <paper_cc> roconnor: this vokale code looks strange
12:17:55 <mauke> nomeata: hmm, that looks like code I'd write :-)
12:18:05 <mauke> preprocessor stress test
12:18:12 <mauke> but I know nothing about cpphs
12:18:58 <nomeata> ok. I guess itâ€™s not critical, even if itâ€™s a bug in cpphs
12:23:06 <mauke> monochrom: rhymes with Pauke, for which see http://forvo.com/word/pauke/ and http://www.leo.org/dict/audio_de/p/die_Pauke.mp3
12:23:25 <ikegami__> because the haskell-src-exts package is not experimental now, it's time to combine the CEDET Emacs library to a parser created by the package
12:24:04 <ikegami__> even though almost people here uses vim...
12:24:44 <shachaf> ikegami__: Wow, "almost people"? Isn't that taking the vi-emacs thing to a bit of an extreme?
12:24:45 <madhadron> ikegami, Does it count if you occasionally forget and try to run vi from a shell in Emacs?
12:25:48 <etpace_> Hey guys, I'm getting a: No instance for (Integral (Int, Int)) in the expression: map (round . f . (*stepX)) [0..100] -- although map (round . (\x -> 2x + 3) . (*5)) [0..100] works fine?
12:25:53 <_dr> http://pastebin.com/m67510e15 correct me if i'm wrong... it seems the [] is not valid since it doesn't match the type (Char, a) because it is of type [b]? or how do i read that error
12:26:01 <ikegami__> well, i mean, "does anyone have an interest for writing Haskell codes in CEDET and haskell-src-exts in Emacs?"
12:26:23 <mauke> _dr: exactly
12:26:52 <mauke> _dr: the reason you're getting that error is that the 'then' and 'else' parts of an 'if' have to return values of the same type
12:26:57 <madhadron> etpace, what's the type of (round . f . (*stepX))?
12:27:16 <mauke> _dr: hugs sees that the 'then' part returns a tuple (Char, a), but the 'else' tries to return a list
12:27:40 <etpace_> (Num a) => a -> Int?
12:27:41 <_dr> mauke: that's what i thought
12:27:51 <shachaf> _dr: This is because the whole expression ("(if ...)") has to have a particular type.
12:27:56 <natthew2> Ok, i really don't want to spam, but I really don't know where to look for info on this. Is there anything significantly faster for reading/writing a list of 10000 to 1000000 doubles to disk than read-ing and show-ing the list to a text file with readFile?
12:28:13 <madhadron> natthew2, Data.Binary
12:28:18 <_dr> how can i get them both to return a list of tuples?
12:28:20 <madhadron> Which will be way, way faster.
12:28:40 <_dr> i thought like if ... then (a,b) ++ [] else []
12:28:44 <natthew2> excellent, thanks!
12:28:48 <shachaf> _dr: Well, (letter, l) is a single tuple.
12:29:00 <shachaf> _dr: You want : instead of ++.
12:29:08 <_dr> okay thanks
12:29:16 <shachaf> A shorthand for "a : []" is "[a]".
12:29:33 <etpace_> am I wrong madhadron?
12:29:54 <madhadron> etpace, Should be fine.
12:30:03 <madhadron> Somewhere you're getting a screwy type inference
12:30:41 * madhadron goes to shoot himself as the machine connected to his microscope runs out of disk space...again.
12:30:59 <_dr> ok seems to be tougher than i thought
12:31:26 <shachaf> _dr: It doesn't work?
12:31:28 <etpace_> Is there a function like round, but rounds to the nearest number in a list?
12:32:42 <anon7319> Is it possible to have a Matrix typeclass which is both a Num and IArray ?
12:33:09 <madhadron> anon7319, Yes.  I wrote one for 2D matrices about a week ago for affine transforms.
12:33:48 <madhadron> Sorry, 2x2 matrices
12:34:16 <roconnor> madhadron: did you make your own IArray instance?
12:34:34 <anon7319> How do I 'fix' a instance of IArray to take two indices only then? I mean matrix have only two indices.
12:35:06 <madhadron> roconnor, Probably.
12:35:09 <anon7319> (IArray a, e) => ArrayMatrix a e = TypeConst (a (Int, Int) e)
12:35:12 <HugoDaniel> im having problems runing glut examples on a freshly installed haskell platform, it complains about an unkown symbol "glutGet"
12:35:13 <_dr> shachaf: nope http://pastebin.com/ma757241#
12:35:17 <HugoDaniel> any clues ?
12:35:20 <_dr> http://pastebin.com/ma757241
12:35:40 <roconnor> madhadron: don't remember last week so well? :D
12:35:46 <_dr> but i'm only using haskell as of today, and my university's lecture is not that good either
12:36:06 <madhadron> roconnor, Frankly, no.  Plus it's 21h30 here.
12:36:39 <roconnor> anon7319: a matrix has only 1 index, but an index of type (a,a)
12:37:58 <madhadron> anon7319, Try something like 'instance IArray (ArrayMatrix (Int,Int))...'
12:38:01 <madhadron> oh, that's not right
12:38:07 <madhadron> Ok, my brain's shot.
12:38:30 <mauke> _dr: (:) takes an element and a list. you're calling it with two lists
12:38:40 <Zao> @type (:)
12:38:42 <lambdabot> forall a. a -> [a] -> [a]
12:39:11 <_dr> i fixed it
12:39:18 <_dr> it is ++ in the otherwise statement
12:39:19 <_dr> now it works
12:39:35 <_dr> thanks mauke
12:39:42 <madhadron> That's it, my development machine is fubared, my microscope is sending crazy errors from one of the microcontrollers, and I'm going home.
12:39:42 <roconnor> anon7319: hmm, I'm not sure you can make 2x2 matrices an Iarray
12:40:12 <shachaf> _dr: What are you trying to do exactly?
12:41:05 <_dr> we're supposed to write map and reduce functions for some stupid problem in haskell
12:41:19 <_dr> so we see how cool functional languages are :)
12:41:27 <mauke> hah
12:42:13 <paper_cc> _dr: that's not the cool way to write it
12:42:32 <mauke> what is this function supposed to do?
12:42:33 <_dr> i know
12:42:57 <_dr> mauke: it's the map function... it counts vocals in strings
12:43:17 <mauke> the map function doesn't count anything, it applies a function to a list of arguments
12:43:38 <mauke> and your function doesn't seem to count either
12:44:08 <_dr> that's how we were told to do it
12:44:16 <_dr> the reducer does the counting, yes...
12:44:24 <Zao> If you've got C++ experience, map is like std::transform.
12:44:36 * shachaf suspects a misunderstanding.
12:44:55 <mauke> _dr: your function is a filter, not a map
12:45:07 <_dr> mauke: i'm not talking about haskell 'map'
12:45:07 <paper_cc> :t filter
12:45:09 <shachaf> mauke: Well, it's both. :-)
12:45:09 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
12:45:21 <_dr> i'm talking about google's mapreduce for parallel computing
12:45:27 <shachaf> _dr: Yes you are. :-)
12:45:36 <shachaf> Map is map.
12:46:04 <_dr> but i don't use the map function anywhere
12:46:20 <paper_cc> _dr: but map is an idiom
12:46:46 <_dr> ok maybe i'm wrong
12:46:48 <mauke> vokaleMap [] = []; vokaleMap (x : xs) = (if toLower x `elem` vokale then [(x, 1)] else []) ++ vokaleMap xs
12:46:57 <_dr> but my assignment says i'm supposed to do it that way :)
12:46:59 <shachaf> _dr: That's right -- nor are you mapping, really. What is the meaning of this function that you're writing exactly?
12:47:31 <hackagebot> vacuum-opengl 0.0 - Visualize live Haskell data structures using vacuum, graphviz and OpenGL. (BalazsKomuves)
12:47:47 <shachaf> Why do you turn letters into tuples whose second value is 1?
12:47:52 <pikhq> The "map-reduce" paradigm is dumb; "map" there is an argument to map. So. Dumb.
12:48:17 <paper_cc> vokaleMap = map ((,) 1 . toLower) . filter (`elem` vokale) -- or like this
12:48:32 <mauke> length . filter (`elem` vokale)
12:48:46 <shachaf> > length . filter ((`elem` "aeiou") . toLower) $ "abcdefghi"
12:48:47 <lambdabot>   3
12:49:18 <_dr> shachaf: yeah, that works, too
12:49:32 <_dr> but my assignment is different
12:49:36 <paper_cc> > zip [1..] . filter (`elem` vokale) $ "abcdefghi" -- if you want to number them
12:49:37 <lambdabot>   Not in scope: `vokale'
12:49:49 <paper_cc> @let vokale = "aeiou"
12:49:50 <lambdabot>  Defined.
12:49:56 <paper_cc> > zip [1..] . filter (`elem` vokale) $ "abcdefghi"
12:49:58 <lambdabot>   [(1,'a'),(2,'e'),(3,'i')]
12:50:12 <_dr> it's not supposed to be that way :)
12:50:12 <shachaf> _dr: Yes, but I do not understand your assignment (and I suspect that you do not fully understand it either.).
12:50:36 <_dr> shachaf: ok the idea is: vokaleMap produces this stupid output
12:50:41 <shachaf> What is the point of a list like [('a',1),('e',1),('i',1)] ?
12:51:01 <_dr> shachaf: you can use one reducer per vocal
12:51:06 <_dr> so have have parallelism again
12:51:18 <paper_cc> > map ((,) 1 . toLower) . filter (`elem` vokale) $ "AbCdEfGhIjK"
12:51:19 <lambdabot>   []
12:51:27 <paper_cc> oh
12:51:33 <jmelesky> so you end up with [('a', 5), ('e', 12), ('i', 3)] ?
12:51:40 <_dr> yes
12:51:53 <_dr> i know vocals are a stupid example :)
12:52:00 <paper_cc> > map ((,) 1) . filter (`elem` vokale) . map toLower $ "AbCdEfGhIjK"
12:52:01 <lambdabot>   [(1,'a'),(1,'e'),(1,'i')]
12:52:50 <paper_cc> oh
12:52:56 <pikhq> This really seems like a contrived example.
12:53:05 <_dr> http://en.wikipedia.org/wiki/MapReduce
12:53:13 <jmelesky> pikhq: it's an assignment. of course it's contrived. :)
12:53:28 <_dr> the code sample uses EmitIntermediate(w ,1), too
12:53:33 <pikhq> I mean, really, I think I could do it in shell rather easily.
12:53:35 <_dr> i do not claim to fully understand it
12:53:58 <_dr> but if google uses it to put parallelism into pagerank it must have its advantages
12:54:10 <_dr> pikhq: yes, but not faster
12:54:42 <burp> map reduce.. nothing special about it in my opinion
12:55:20 <paper_cc> except that in MapReduce, Map is not map and Reduce is not reduce
12:55:51 <_dr> paper_cc: what do you mean?
12:55:55 <burp> but the idea behind it is the same
12:56:24 <lilac> > map (head &&& length) . group . sort . filter (`elem` vokale) . map toLower $ "3poruqfpoqermvpoqjrgpojqdwvmcpoeqfvoiqjwerflkns;clanw;doihqwipg"
12:56:26 <lambdabot>   [('a',1),('e',3),('i',3),('o',7),('u',1)]
12:56:54 <mauke> _dr: (they're called "vowels")
12:57:35 <paper_cc> _dr: map is more like concatMap or unionMap and reduce is (some Map function which name I don't remember)
12:57:49 <roconnor> paper_cc: fold?
12:58:03 <pikhq> (echo a `<file grep -o 'a' | wc -l`)&&(echo e `<file grep -o 'e' | wc -l`)&&(echo i `<file grep -o 'i'| wc -l`)&&(echo o `<file grep -o 'o'| wc -l`)&&(echo u `<file grep -o 'u'| wc -l`)
12:58:09 <_dr> mauke: the declaration was given by a german teacher
12:58:16 <pikhq> There. The same thing in shell.k And what's more, it's parallel.
12:58:20 <paper_cc> roconnor: no, Google's reduce isn't a fold
12:58:43 <mauke> _dr: yeah, but you keep saying "vocals" and that means Gesang
12:59:03 <monochrom> vowel? vocal?
12:59:31 <monochrom> lazy and strict? non-strict and eager?
12:59:51 <_dr> sorry, i'm tired :)
12:59:59 <_dr> and an idiot, as it seems
13:00:21 <monochrom> (It would be funny to hear in a Java "the language is eager but you can use design patterns to do non-strict datatypes")
13:00:22 <pikhq> mapreduce () {echo $1 `<file grep -o $1|wc -l`};for i in {a,e,i,o,u};do mapreduce $i&&done
13:00:29 <monochrom> s/Java/Java channel/
13:00:32 <mapreduce> Ahem.
13:00:34 <pikhq> There; more idiomatic shell.
13:00:34 <pikhq> Whee.
13:00:39 <monochrom> haha
13:00:52 <monochrom> Hi mapreduce do you love haskell!
13:00:54 <mauke> {a,e,i,o,u} better written as a e i o u
13:00:57 <pikhq> So, in the end, this is a stupid example.
13:01:03 <pikhq> mauke: ... Right.
13:01:13 <mapreduce> monochrom: I like it, but mostly use it as a posh calculator.
13:01:34 <mauke> good enough
13:02:43 <lilac> paper_cc: isn't google's reduce a monoidal fold?
13:02:49 <jmelesky> paper_cc: i thought google's reduce was like a fold over a tree
13:03:04 <lilac> paper_cc: that is, i thought it was essentially mconcat
13:04:46 <HugoDaniel> just fixed my problem with glut, i had to install X dev. libs and reinstall glut
13:04:56 <paper_cc> lilac, jmelesky: what the wikipedia article calls reduce is Reduce :: k -> [v] -> [a]
13:05:16 <lilac> mapreduce: you use haskell as a posh calculator? i've never used a calculator which broke if you didn't press the 'fromIntegral' button at the right times and had three different exponentiation buttons ;-)
13:05:43 <pikhq> I use an HP calculator as a posh calculator.
13:05:46 <mapreduce> Really?
13:05:52 <pikhq> It's got Reverse Polish Lisp and everything.
13:05:52 <CalJohn> When I try to compile FFI code without --make on ghc, I get told "compilation is NOT required".  Why is that?  (with --make does work, I'm just curious)
13:05:57 <mapreduce> My calculator has a ^2, a ^3 and a x^y button.
13:06:08 <byorgey> paper_cc: that looks wrong, I think it should be  k -> [v] -> [v].
13:06:21 <byorgey> paper_cc: I see the wikipedia article, I think 'v3' should be 'v2'
13:06:28 <lilac> mapreduce: well the fromIntegral bit still stands ;-)
13:06:50 <mapreduce> pikhq: Reverse Polish Lisp?  Isn't that Forth?
13:07:09 <opqdonut> basically yeah
13:07:13 <CalJohn> mapreduce: i'm thinking that perhaps it was a joke?
13:07:14 <lilac> is it considered bad form to upload a package to hackage which doesn't have haddock documentation?
13:07:17 <byorgey> it's basically a fold, but you're allowed to leave some values "unfolded", i.e. you can return a list of values instead of a single value.
13:07:37 <pikhq> CalJohn: I'm not joking. The language that HP calculators use is called Reverse Polish Lisp.
13:07:40 <byorgey> lilac: yes.
13:07:47 <CalJohn> pikhq: not RPN?  why?
13:07:52 <jmelesky> wait, so google reduce is filter? or map . filter?
13:07:54 <lilac> byorgey: right then. documentation time!
13:07:55 <mapreduce> pikhq: What does it look like?
13:08:13 <pikhq> mapreduce: The love-child of Lisp and Forth.
13:08:20 <byorgey> jmelesky: no, the output values don't have to be chosen from the input list.
13:08:54 <byorgey> jmelesky: it really is a fold, but a special fold where the output type is a list
13:09:08 <jmelesky> byorgey: but they're derived from the input list, surely?
13:09:15 <byorgey> jmelesky: well, that's the idea.
13:09:24 <byorgey> they're computed by combining elements from the input list somehow.
13:09:55 <byorgey> the 'combining' is key, which is why  map . filter  wouldn't cut it
13:10:06 <jmelesky> gotcha
13:11:08 <lilac> @seen Cale
13:11:09 <lambdabot> Cale is in #haskell-in-depth, #ghc, #haskell-overflow and #haskell. I don't know when Cale last spoke.
13:12:57 <beutdeuce> question, why am i getting a parse error on '<-' ?: let f x y z = x <- getLine :: Int ; y = 1 ; z = x + y ; print z
13:13:20 <paper_cc> @botsnack
13:13:20 <paper_cc> , [$ty|foldr|]
13:13:20 <lambdabot> :)
13:13:20 <lunabot>  :)
13:13:22 <paper_cc> :(
13:13:23 <lunabot>  forall a b . (b -> a -> a) -> a -> [] b -> a
13:13:28 <jmelesky> so, back to _dr's problem, vokaleMap would be a filter returning a list of (char, 1::int) tuples
13:13:43 <CalJohn> beutdeuce: you are lacking a "do"
13:13:45 <pikhq> beutdeuce: Because that's not in a do block.
13:14:24 <jmelesky> and vokaleReduce would be a fold which, given a key and the output of vokalReduce, would return an int which is the sum of all ints in tuples where the char matched the key
13:14:43 <beutdeuce> thnx
13:15:32 <_dr> well there are more steps
13:15:51 <_dr> after reduce there's a sort, then a partition which gives a list like
13:16:15 <beutdeuce> The last statement in a 'do' construct must be an expression
13:16:43 <_dr> [('a', [1]), ('e', [1,1,1,1])]
13:16:46 <_dr> and reduce works on that
13:16:47 <CalJohn> beutdeuce: that is typically caused by wonky indentation.  Ming posting to hpaste.org so I can see your work?
13:17:05 <jmelesky> _dr: got it
13:17:14 <beutdeuce> CalJohn, do let f x y z = x <- getLine :: Int ; y = 1 ; z = x + y ; print z
13:17:39 <jmelesky> _dr: which part are you having problems with? (scrollback doesn't go that far)
13:17:49 <CalJohn> beutdeuce: you aren't indenting at all?
13:18:03 <beutdeuce> CalJohn, im using semicolons instead
13:18:21 <_dr> jmelesky: i fixed it, thanks
13:19:08 <byorgey> beutdeuce: what are you trying to do?
13:19:18 <byorgey> are you trying to define a function called f ?
13:19:20 <beutdeuce> byorgey, testing how input works
13:19:26 <beutdeuce> byorgey, yes
13:19:27 <jmelesky> _dr: cool. of course, now i'm going to try and figure it out anyway. more fun than the html parsing i'm supposed to be working on. :)
13:19:28 <CalJohn> beutdeuce: he is obviously trying to learn, but there are quite a few mistakes in that
13:19:43 <byorgey> beutdeuce: it doesn't make sense to have x be a parameter to f and then say   x <- getLine
13:20:09 <_dr> jmelesky: hang on
13:20:14 <beutdeuce> byorgey, o, right, lol. I hate it when i do stupid things like that
13:20:17 <byorgey> in fact, there's no reason to have any parameters to f.
13:20:41 <CalJohn> beutdeuce: what book are you reading?
13:20:52 <beutdeuce> YAHT
13:21:04 <_dr> the file is not on the password protected part of the website
13:21:12 <byorgey> beutdeuce: also, getLine only returns Strings, try using readLn instead (which does getLine followed by 'read')
13:21:27 <byorgey> read converts from String to other types
13:21:28 <_dr> you can have it if you like
13:21:28 <beutdeuce> byorgey, isnt that the equivalent of a getline to a cast?
13:21:47 <byorgey> beutdeuce: yes, but Haskell doesn't cast.
13:21:57 <byorgey> you must explicitly use functions to do whatever conversion you want.
13:22:23 <byorgey> > read "45" :: Int
13:22:25 <lambdabot>   45
13:22:25 <jmelesky> _dr: sure. it's been long enough since i've done school problems that they're fun rather than tedious
13:22:33 <byorgey> > "45" :: Int
13:22:35 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
13:22:42 <beutdeuce> byorgey, like x <- getLine ; read x :: int
13:22:43 <_dr> http://www.openlsd.org/tmp/mapreduce.hs
13:22:49 <_dr> comments in german i'm afraid
13:23:05 <byorgey> beutdeuce: well, you'd have to assign the result of 'read x' to some other name
13:23:14 <jmelesky> _dr: no problem. i know enough german to muddle through
13:23:18 <beutdeuce> byorgey, btw, why cant i overload?
13:23:32 <paper_cc> beutdeuce: because you really can't
13:23:40 <_dr> ok
13:23:41 <CalJohn> beutdeuce: what language are you coming from?
13:23:57 <_dr> this implementation seems to work now, you can test it with "mapreduce (vokaleMap, vokaleReduce, bsp)"
13:23:59 <byorgey> beutdeuce, what do you mean by 'overload'?
13:24:08 <beutdeuce> CalJohn, OOP
13:24:14 <paper_cc> beutdeuce: any function must have a distinct type (if your "overloading" is C++'s one)
13:24:18 <beutdeuce> byorgey, variable overloading?
13:24:30 <CalJohn> beutdeuce: what you probably want to write is http://xrl.in/2mxw
13:24:34 <byorgey> beutdeuce: oh, you mean reassigning a different value to a variable?
13:25:00 <byorgey> beutdeuce: in Haskell, variables are just names for values.  they aren't like 'boxes' that you can put things in (like in other imperative languages).
13:25:15 <byorgey> it's a totally different way of thinking about programming.
13:25:18 <beutdeuce> byorgey, yes, like x <- getLine ; x = read x :: Int
13:26:23 <byorgey> beutdeuce: well, you *can* actually say  do { x <- getLine; let x = read x }, because the second 'x' shadows the first.  But you shouldn't do that, because you are likely to get confused (because it isn't doing what you think).
13:26:40 <beutdeuce> byorgey, its not even letting me do that
13:26:45 <byorgey> well, good =)
13:26:47 <paper_cc> beutdeuce: x = read x doesn't do what you think it does. it defines x /in terms of itself/ and discards the previous meaning of x
13:27:20 <fergie> I don't have much experience of programming languages but I really like what I've seen so far with Haskell. I want to write simple program using SOAP; does anyone know a good starting point?
13:27:24 <paper_cc> beutdeuce: it will let you do that if you say let x = read x; but that will still be wrong (it will be an infinite loop)
13:27:34 <beutdeuce> paper_cc, doesnt read x :: Int return x as an int?
13:27:56 <byorgey> beutdeuce: anyway, I recommend that you spend some more time learning the basics of the language before trying to do I/O stuff.
13:28:11 <mauke> beutdeuce: no, it parses the string in x for a number
13:28:12 <beutdeuce> byorgey k
13:28:13 <paper_cc> beutdeuce: well, it evaluates to x as an Int when x is a string
13:28:23 <beutdeuce> o
13:28:28 <byorgey> beutdeuce: Haskell represents such a complete brain rewiring that you shouldn't try taking on too much at once =)
13:28:28 <Elly> w 2
13:28:29 <beutdeuce> k
13:28:32 <Elly> oops
13:28:38 <beutdeuce> :) thnx
13:28:44 <fergie> or would I be better off trying with another language?
13:28:49 <tommd> byorgey: So, you use hackage-server?
13:28:52 <beutdeuce> i like it though, Haskell is very powerful and fun
13:28:57 <tommd> I seem to recall you mentioned that.
13:29:05 <byorgey> tommd: no, what's hackage-server?
13:29:12 <tommd> Oh, my mistake
13:29:21 <tommd> hackage-server is hackage .h . o on happstack.
13:29:28 <tommd> @where hackage-server
13:29:29 <lambdabot> I know nothing about hackage-server.
13:29:38 <byorgey> oh, I see
13:29:40 <tommd> @where+ hackage-server http://code.haskell.org/hackage-server
13:29:41 <lambdabot> It is forever etched in my memory.
13:29:45 <tommd> @flush
13:29:45 <lambdabot> Not enough privileges
13:29:49 <tommd> @slap lambdabot
13:29:49 <lambdabot> why on earth would I slap lambdabot?
13:30:05 <byorgey> fergie: did you look on Hackage for libraries related to SOAP?
13:30:19 <CalJohn> beutdeuce: :)  Another good piece of advice is to use the indented do notation.  Almost everyone else does, so the "other" method ends up being quite rare
13:30:23 <jmelesky> fergie: i don't know if haskell has any SOAP libraries, though there are a few XML libraries that you could use
13:30:24 <byorgey> hmm, I don't see any
13:30:45 <beutdeuce> CalJohn, k
13:30:48 <fergie> byorgey: I've had a look but there doesn't seem to be anything simple
13:30:57 <CalJohn> Is it possible to call into C++ from the FFI?
13:31:24 <CalJohn> (I don't actually know C++, I just want to use a library)
13:31:27 <Zao> Maybe if you're calling free functions and pray.
13:31:38 <Zao> It'd likely be easiest to hack up a C-ish wrapper you FFI to.
13:31:48 <fergie> jmelesky: do you think that is going to be the easiest way?
13:31:59 <CalJohn> Zao: so, basically, the answer is no?
13:32:34 <jmelesky> fergie: having worked with SOAP at the XML level, i'd say "no, not easy at all" -- SOAP's a bit complex
13:33:15 <CalJohn> Zao: the problem is that I don't know C either
13:33:19 <fergie> jmelesky: I'm a real novice at this. Would I be better off trying a different language with better support?
13:33:43 <lilac> what's a good monad for emitting elements one at a time, and building a list of them? I've heard Writer [] has performance issues
13:34:07 <jmelesky> fergie: possibly, though it depends on what languages you're familiar with already, how familiar you are with SOAP, etc
13:34:35 <lilac> CalJohn: constructing a C wrapper for a C++ lib is usually a fairly mechanical process, unless it wants to be extended via inheritance
13:35:12 <Zao> CalJohn: Which library, out of curiousity?
13:35:20 <the_unamker> wow more lazy functionalists every day
13:35:21 <HugoDaniel> is there any data structure to represent a set of unique objects, like, for instance, a list of unique strings ?
13:35:21 <fergie> jmelsky: not familiar with SOAP at all. Can do "Hello World" in other languages but not much more. What I want isn't that complicated though
13:35:35 <byorgey> fergie: if you specifically need to do stuff with SOAP and there aren't any Haskell SOAP libraries, I'd say use a different language.
13:35:39 <CalJohn> Zao: http://id3lib.sourceforge.net/
13:35:44 <lilac> also, what sort of performance problems does Writer [] suffer from? is it the same old quadratic performance from (++) thing?
13:35:47 <CalJohn> lilac: do you know of a guide?
13:36:14 <Zao> CalJohn: There's a binding to taglib already, that's not good enough I guess?
13:36:32 <CalJohn> Zao: oh, is there, I must've missed that
13:36:34 <HugoDaniel> it shouldn't be too hard to do a SOAP implementation in haskell... its just xml, and the schemas are readily available in the spec
13:36:46 <byorgey> lilac: Writer [] only has performance issues if you try  using ++[x] to put emitted elements on the end.  just cons them on the front, and then reverse at the very end if you like.
13:36:50 <Zao> http://hackage.haskell.org/packages/archive/pkg-list.html#cat:sound
13:36:59 <lilac> byorgey: i want more laziness than that
13:37:05 <fergie> byorgey: put it like that and it seems obvious. Any ideas which languages have a nice and easy SOAP interface?
13:37:13 <byorgey> lilac: wait, never mind, that wouldn't even work.
13:37:14 <jmelesky> fergie: the best SOAP library i've used is SOAP::Lite for perl. it's on CPAN (http://search.cpan.org/~mkutter/SOAP-Lite-0.710.08/)
13:37:25 <byorgey> lilac: what about  Writer DList ?
13:37:31 <lilac> byorgey: in particular i want: runGenerator $ do yield x; yield y; _|_ to produce 1:2:_|_
13:37:41 <lilac> s/1:2/x:y/
13:37:48 <byorgey> lilac: ah, I see
13:37:57 <lilac> byorgey: hmm, possibly. *looks up DList*
13:38:04 <fergie> jmelsky: thanks. I've never done any Perl but it might be about time to learn
13:38:05 <jmelesky> fergie: i don't know of any languages that have SOAP in the standard library, though, so wherever you go you
13:38:16 <jmelesky> you're going to have to learn how to install external libs
13:38:25 <the_unamker> so anyone got happstack going with some real data liek a gig or more?
13:38:30 <the_unamker> hows it run?
13:38:32 <lilac> byorgey: i'd prefer my hackage package didn't have extra deps, but if there's nothing better i'll go for DList
13:38:42 <the_unamker> soap lol
13:38:49 <lilac> byorgey: although to be honest i may just write it out by hand since it's pretty simple
13:38:50 <the_unamker> isnt that like a consultant tehconology
13:38:52 <byorgey> lilac: well, DList is just a thin wrapper around the idea
13:38:54 <the_unamker> lots of buzz no subs
13:38:57 <byorgey> lilac: yeah
13:39:08 <lilac> byorgey: is it basically just Endo on [a] -> [a]?
13:39:26 <roconnor> lilac: I remember talking with McBride about implementing runWriterL and runWriterR to automatically right or left associate all mappends.
13:39:56 <byorgey> lilac: I think you mean  Endo on [a], but yes
13:39:59 <roconnor> lilac: i recall that it would be pretty easy.
13:40:03 <lilac> byorgey: right :)
13:40:21 <jmelesky> the_unamker: not myself, but i know there were some conversations on the happstack mailing list about the scalability of macid last month
13:40:22 <byorgey> roconnor: that would be nifty.
13:40:32 <lilac> roconnor: runWriterR can presumably be done by something akin to wrapping in a ContT?
13:40:54 <roconnor> lilac: alternatively you can just do a ContT to associate everything the nice way.
13:40:55 <lilac> roconnor: sounds pretty useful
13:41:10 <roconnor> lilac: or even better use edwardk's magic library of transformer optimization
13:41:33 <lilac> in any case, i think i'll write this one by hand for the fun and experience
13:41:36 <jmelesky> the_unamker: there should be archives here: http://groups.google.com/group/HAppS
13:47:19 <beutdeuce> why?
13:47:19 <beutdeuce> do { square :: Num a => a -> a ; let square x = x*x }
13:47:19 <beutdeuce> <interactive>:1:33:
13:47:19 <beutdeuce>     The last statement in a 'do' construct must be an expression
13:48:00 <paper_cc> beutdeuce: why do you want a 'do' block here?
13:48:06 <paper_cc> you're doing a declaration
13:48:39 <beutdeuce> if i dont put in do block, it tells me im not in scope of 'square', because it isnt defined yet
13:48:49 <copumpkin> uh
13:48:55 <copumpkin> just remove the do and the let
13:49:12 <beutdeuce> copumpkin, i need let, otherwise it gets pase error on '='
13:49:13 <paper_cc> beutdeuce: it tells you're not in scope of square because you put a let
13:49:33 <copumpkin> beutdeuce: no you don't, you only need let if you're inot at the top level
13:49:47 <paper_cc> beutdeuce: the order of top-level declarations doesn't matter (no "isn't defined yet" here)
13:50:15 <beutdeuce> Prelude> square :: Num a => a -> a
13:50:15 <beutdeuce> <interactive>:1:0: Not in scope: `square'
13:50:29 <copumpkin> you can't do it in ghci
13:50:42 <beutdeuce> why?
13:50:59 <copumpkin> because that's the way ghci works :P it behaves like a giant do block in IO. mostly
13:51:40 <copumpkin> you can do let square :: (Num a) => a -> a; square x = x * x
13:51:58 <paper_cc> (but you should do that only in ghci)
13:52:19 <beutdeuce> would that work in hugs?
13:52:37 * copumpkin is a post-hugs child
13:52:46 <HugoDaniel> anyone knows if the uuid package works fine on windows ?
13:53:08 <paper_cc> beutdeuce: don't know, but a declaration in the .hs file is always fine (obviously)
13:53:14 <HugoDaniel> unfortunately i only run linux on this box :(
13:53:29 <copumpkin> HugoDaniel: if it doesn't do any FFI I don't see why it wouldn't be
13:53:32 <beutdeuce> k
13:53:53 <HugoDaniel> hmm copumpkin, http://en.wikipedia.org/wiki/UUID#Haskell
13:53:58 <HugoDaniel> this is why i hasked
13:54:00 <HugoDaniel> oops
13:54:01 <HugoDaniel> asked
13:54:02 <HugoDaniel> :/
13:54:07 <copumpkin> oh
13:55:06 <zrk> you guys have suggestions on colleges that might be good in functional programming/prog langs in general in the North East region of the US?  Specifically around Illinois?
13:56:00 <HugoDaniel> zrk: im european, sorry
13:56:36 <jmelesky> zrk: not offhand, but i do know Andy Gill is now at KU
13:56:56 <copumpkin> zrk: US colleges seem to not care much in general... they have little pockets of people who do care, but their curricula seem not to
13:57:05 <copumpkin> zrk: at least from what I've gathered
13:58:13 <edwardk> zrk: there is toyota technical institute, which is a graduate school over that way with a lot of functional guys at it
13:58:17 <beutdeuce> why wouldnt this work:
13:58:17 <beutdeuce> Prelude> let f = \x y -> x:y
13:58:18 <beutdeuce> Prelude> f "Hello" "World"
13:58:20 <zrk> I'm trying to find options for doing a masters/phd in prog langs, would be nice if it was in func programming
13:58:35 <copumpkin> beutdeuce: the type doesn't work
13:58:44 <copumpkin> zrk: there are a couple of people here at upenn
13:59:01 <beutdeuce> copumpkin, how so? two list of chars?
13:59:05 <Botje> beutdeuce: (:) has type a -> [a] -> [a]
13:59:11 <the_unamker> sometime I think i should learn c, and some of its libs
13:59:12 <Botje> you're feeding it two [Char]
13:59:13 <jmelesky> zrk: find a professor you want to work with first, then the school will be obvious from that
13:59:13 <copumpkin> Botje: a -> [a] ?
13:59:14 <the_unamker> and plan9
13:59:22 <the_unamker> and maybe that stuff wil ive me the power to get rich
13:59:29 <the_unamker> then other times I think lisp or haskell
13:59:31 <the_unamker> hmmm
13:59:34 <the_unamker> gosh im confused
13:59:36 <edwardk> zrk: but top end programs like carnegie mellon, harvard, mit, northeastern, upenn, have good functional content. u mass boston, if i recall correctly. there is a bunch of stuff on the other coast, but i'm less well acquainted with them
13:59:37 <copumpkin> o.O
13:59:39 <the_unamker> then there is forth
13:59:45 <Botje> copumpkin: did I say something wrong?
13:59:49 <beutdeuce> k, it should of been ++ instead of :
14:00:07 <copumpkin> Botje: oh lol, I read the first a as english instead of haskell, sorry :P
14:00:08 <zrk> jmelesky: that seems to be the advice I'm getting from multiple people.  I guess the task is now finding said profesor
14:00:11 <copumpkin> and saw [a] -> [a] :P
14:00:18 <edwardk> the_unamker: just learn them all and them pick through the wreckage of your mind for the interesting bits. it works well for me =)
14:00:19 <Botje> :)
14:00:25 * Botje hands copumpkin some coglasses
14:00:30 <copumpkin> thank you!
14:00:36 * copumpkin cotakes them off
14:00:46 <tew88> filter ( `mod` 3 == 0 ) [1..10] throws an error. How do I attain that sort of functionality? I'm assuming it's just a syntax misunderstanding
14:00:51 <jmelesky> zrk: and you do *that* by reading research papers. get familiar with citeseer. :)
14:01:10 <Botje> tew88: one way is ((== 0) . (`mod` 3))
14:01:11 <copumpkin> > filter (\x -> x `mod` 3 == 0 ) [1..10]
14:01:13 <lambdabot>   [3,6,9]
14:01:19 <copumpkin> @pl filter (\x -> x `mod` 3 == 0 ) [1..10]
14:01:20 <lambdabot> filter ((0 ==) . (`mod` 3)) [1..10]
14:01:39 <copumpkin> I wonder why everyone (including me) writes (== k) in point-free style
14:01:54 <tew88> Both excellent solutions, ty :)
14:01:55 <copumpkin> instead of (k ==)
14:01:59 <Botje> (k==) looks stupid :)
14:02:03 <opqdonut> copumpkin: well predicates tend to come first
14:02:03 <zrk> jmelesky: any suggestions where to start?
14:02:07 <edwardk> copumpkin: we do?
14:02:12 <tomh-> anyone know the happy equilevant of   {       $$ = NULL;     }   ?
14:02:15 <copumpkin> edwardk: fine, most people I see :P
14:02:16 <shachaf> copumpkin: Because you're checking if it "equals k".
14:02:36 <edwardk> i'm in the (==) k -- camp myself =)
14:02:43 <copumpkin> lol
14:02:44 <jleedev> > any (> 10) [1..]
14:02:45 <lambdabot>   True
14:02:53 <jmelesky> zrk: if you're thinking about programming languages research, i'd check out the ICFP publications, or try to attend the conference
14:02:56 <mjs22> zrk: a good place to start is to look at current and recent proceedings for conferences like ICFP.  Check out recent journals too.
14:03:16 <edwardk> no sense needlessly swapping argument orders, it just creates one of those annoying swap my argument thunks if the compiler if feeling dumb, and complicates things otherwise =)
14:03:58 <copumpkin> the compiler needs more commutativity knowledge :P
14:03:59 <edwardk> zrk: going to icfp is a _really_ good idea if you want to learn who is who and where they are in the functional programming community
14:04:07 <copumpkin> or symmetry in this case
14:04:07 <mjs22> zrk: OOPSLA has interesting PL papers too
14:04:17 <edwardk> the only reason anyone knows who I am is that I showed up at ICFP06 ranting like a loon.
14:04:29 <zrk> heh
14:04:47 <edwardk> well, some of them may have been forwarned by my presence on here... also reportedly ranting like a loon.
14:04:47 <jmelesky> edwardk: i was at '06, too. only one i've attended
14:06:02 <copumpkin> edwardk: did you apply an inebromorphism to yourself before going?
14:06:20 <edwardk> i basically talked to all the folks who had graduated from Harvard lately, rambled on about my generalizations of all of their research, decided I should talk to someone at Harvard about doing a Ph.D. and then promptly dropped all of that when I was hired away by industry..... ironically a move that required me to move a few miles away from Harvard.
14:07:01 <lysgaard> Is the "Roll your own IRC bot" on haskellwiki good for learning some simple network programming?
14:07:08 <tromp> what industry is that, edwardk?
14:07:16 <zrk> thanks y'all for letting me pick your brains a bit
14:07:20 <augustss> edwardk: yu can always do your phd when you get wealthy
14:07:36 <copumpkin> wealth is good
14:07:50 <tew88> lysgaard: There's a Real World Haskell chapter on Network Programming :>
14:07:52 <augustss> edwardk: look at Brian May
14:07:52 <edwardk> augustss: thats what i said i'd do the first time i went and became wealthy. unfortunately I lost all of that money shortly thereafter in the dot-com crash. ;)
14:08:26 <lysgaard> tew88: Heh, why didn't i think of that, I'we got the book lying here on my desk =)
14:08:45 <augustss> edwardk: if you didn't have the money in your hands you weren't really wealthy :)
14:08:48 <edwardk> tromp: i'm a defense subcontractor these days. i write code that helps big government contractors operate billion dollar contracts more efficiently
14:09:08 <augustss> edwardk: you should get a percentage!
14:10:06 <edwardk> augustss: well, i had some in hand, a lot in paper, and then i had a whole bunch of debt come tumbling down on me and a whole bunch of money go up in smoke after others played corporate politics better than I did ;)
14:10:14 <edwardk> expensive lesson
14:10:17 <solidsnack> augustss: That would give him the wrong incentives.
14:10:26 <beutdeuce> what is the difference between "let f x y = [(map (+1) x ,map (+1) y)]" and "let f = \x y -> [(map (+1) x ,map (+1) y)]"
14:10:50 <augustss> beutdeuce: none (ideally)
14:11:58 <copumpkin> hrm
14:12:06 <edwardk> augustss: i keep trying to get these guys to let me operate on a percentage basis of what i save them. for some reason when they hear how I actually did that to Ford once back in the day, none of them wants to offer me those terms. =)
14:13:31 <edwardk> I'd have been a bit smarter to sink that into houses than into a dot-com =) But then looking at the recent housing crash, maybe not much smarter ;)
14:13:51 <copumpkin> depending on when you decided to get out of it :)
14:14:07 <edwardk> copumpkin: hah, then where would it be, the stock market? ;)
14:14:26 <Botje> google stock!
14:14:32 <solidsnack> edwardk: Why wouldn't they want to offer you those terms based on what you did at Ford?
14:17:20 <solidsnack> edwardk: Because you made out well or because Ford made out badly?
14:17:24 <edwardk> solidsnack: erm, lets just say that Ford (and later Visteon) didn't think about what the letter of a contract would entail in certain extreme circumstances and I came out quite a bit ahead of the game.
14:17:46 <solidsnack> Interesting.
14:18:04 <edwardk> Ford did OK, but they misspecified the problem
14:19:22 <edwardk> but seriously, there isn't any way i could get anyone to operate on percentages on that scale =)
14:19:35 <edwardk> shame though
14:20:12 * edwardk apologizes for the seriously -blah chatter.
14:20:29 <the_unamker> didn anyone comment on my forth c lisp haskell rant? I came back after too much scrolling
14:20:43 <the_unamker> happs logs are crappy to read on google groups
14:20:46 <the_unamker> chaotic
14:20:50 <edwardk> <edwardk> the_unamker: just learn them all and them pick through the wreckage of your mind for the interesting bits. it works well for me =)
14:20:57 <the_unamker> hmm
14:21:17 <edwardk> you'll need to learn them all eventually anyway
14:21:24 <edwardk> so pick one and start there
14:21:30 <the_unamker> scheme seems cool and it has this book from mit, but I never hear dof anything big done in scheme and paul graham asid that common lips has more powerful macroes
14:21:52 <the_unamker> forth seems cool, it can be its own os
14:21:54 <edwardk> thats coz paul graham suffers from the blub paradox pretty badly =)
14:22:00 <the_unamker> no way
14:22:07 <the_unamker> really?
14:23:42 <edwardk> maybe i'm biased, but I love scheme, and genuinely dislike the feel of common lisp... anyways i have to run
14:24:11 <the_unamker> hm
14:24:16 <the_unamker> has a book
14:24:17 <the_unamker> ...
14:24:23 <the_unamker> I liek haivng a book to sorta learn from
14:24:25 <the_unamker> :)
14:24:29 <mauke> hello, gavin
14:24:33 <the_unamker> hey mok
14:24:41 <the_unamker> or whatever your real name is
14:25:21 <beutdeuce> is it that one is not allowed to do "data" in ghci?
14:25:52 <mauke> beutdeuce: yeah, ghci only does expressions and bindings
14:26:03 <mauke> no type definitions
14:29:18 <lilac> beutdeuce: but you can put them into a file and import them
14:36:06 <McManiaC> hm scheme
14:36:24 <McManiaC> i like it because thats how i got into haskell ;D
14:41:35 <the_unamker> oh?
14:41:48 <the_unamker> why do you like haskell?
14:42:03 <the_unamker> schemes way of writing a list seems easier and shorter
14:42:10 <the_unamker> without commas
14:42:52 <Stephan202> @pl t l s = maybe (-1) id $ findIndex id $ map (isPrefixOf s) (tails l)
14:42:53 <lambdabot> t = ((maybe -1 id . findIndex id) .) . flip (map . isPrefixOf) . tails
14:42:58 <Stephan202> ^ the parens around -1 shouldn't have been omitted in the answer, right?
14:43:16 <lilac> Stephan202: right, @pl makes mistakes sometimes
14:43:54 --- mode: ChanServ set +o mauke
14:43:55 --- mode: mauke set +b *!*@w005.z209031033.sjc-ca.dsl.cnc.net
14:44:10 <Stephan202> lilac: ok, thanks :)
14:44:55 --- mode: mauke set -o mauke
14:45:06 <byorgey> mauke: was there a history there I'm not aware of?
14:45:13 <mauke> @protontorpedo
14:45:13 <lambdabot> why haskell over say smalltalk
14:45:15 <mauke> @protontorpedo
14:45:15 <lambdabot> so if I learn haskell i can make cool interactive websites and get rich right?
14:45:18 <mauke> @protontorpedo
14:45:18 <lambdabot> i have a win xp box
14:45:32 <mauke> same guy
14:45:33 <byorgey> the_unmaker = protontorpedo?
14:45:35 <byorgey> ok =)
14:45:45 <mauke> also known as azathoth99, battle_rodent, big-ego-guy, boogooo, darkpaladin, dreamgirl_pakin, evilgod99, ferret_commander, gavino, gavino1, gavino2, hardeharrharr, hopplite, if_it_isnt_scots, kitkat, magic_user, math_guy4, merlyns_undersdy, nyrd, ramserver, renevannt, shemale_aunty, shemale_magic, star-trekio, the_unamker, the_unmaker
14:45:58 <inimino> heh
14:46:09 <Stephan202> :o
14:46:13 <McManiaC> ^^
14:46:23 <monochrom> Wow you collect his nicks!
14:46:30 <mauke> those are all personal encounters. see lambdabot's source for more nicks
14:47:05 <monochrom> You what? hardcode his nicks into lambdabot's source code?
14:47:18 <hzap> @protontorpedo
14:47:18 <lambdabot> oleg?
14:47:27 <SamB> mauke: what does lambdabot do with all of those ?
14:47:31 <mauke> monochrom: http://www.cse.unsw.edu.au/~dons/code/lambdabot/Plugin/Quote/Text.hs
14:47:44 <mauke> scroll down a bit
14:48:52 <McManiaC> "Category theory is the Paris Hilton of mathematics"
14:48:53 <McManiaC> lol
14:49:08 <SamB> eh?
14:49:11 <SamB> how's that ?
14:50:00 <monochrom> Vatican is the Category Theory of Geography.
14:50:45 <monochrom> Analogies are the Paris Hilton of Exposition.
14:51:37 <monochrom> do { x<-nouns; y<-nouns; z<-nouns; return (x ++ " is the " ++ y ++ " of " ++ z) }
14:52:01 <lilac> @brain
14:52:02 <lambdabot> I think so, Brain, but there's still a bug stuck in here from last time.
14:52:13 <McManiaC> "so haskell is new and improved c?"
14:52:14 <McManiaC> :D
14:52:20 <SamB> @brain
14:52:20 <lambdabot> I think so, Brain! But do I have what it take to be the 'Lord of the Dance'?
14:52:38 <lilac> how can something be both new /and/ improved?
14:53:19 <conal> lilac: heh
14:53:26 * conal had to think about that one
14:53:32 <Botje> version 2.0 had bugs so you're looking at version 2.1 :p
14:54:19 <McManiaC> "lazy makes macro not needed?" haha
14:54:22 <McManiaC> :D
15:00:19 * pikhq discovers that Haskell is insanely fast...
15:00:30 <pikhq> I think I may be able to nearly swear off C entirely.
15:01:34 <monochrom> That's nice.
15:01:41 <pikhq> 'Tis.
15:02:02 <pikhq> Not some deep conversation starter or anything, unfortunately.
15:02:12 <conal> pikhq: woot!
15:02:22 <monochrom> deep conversations are overrated.
15:02:27 <pikhq> Indeed.
15:02:30 <conal> ghc has come a long way!
15:02:39 <mauke> just write C in Haskell
15:02:52 <Heffalump> pikhq: what's your application domain?
15:02:54 <mauke> malloc, castPtr, peek, poke, it's all there :-)
15:03:06 * Heffalump agrees that Haskell *can be* insanely fast, but it's also quite easy to write slow code.
15:03:17 <dons> not slow in the Ruby sense though :)
15:03:36 <leimy_> It's kind of difficult to write code and understand the memory utilization impacts without measuring, at least for me.
15:03:48 <dons> yeah, that takes training.
15:03:54 --- mode: ChanServ set +o mauke
15:03:54 --- mode: mauke set -b *!*@w005.z209031033.sjc-ca.dsl.cnc.net
15:03:55 <leithaus_> for me the performance issue is brittleness
15:03:56 <dons> I wonder how they do it in the scripting langs
15:04:07 <pikhq> Heffalump: Sophomore in CS that likes programming random things.
15:04:10 <leimy_> I don't think people worry about it in scripting langs
15:04:17 <mike-burns> We don't worry about it.
15:04:18 <leimy_> I honestly don't put Haskell or scripting languages in the same camp.
15:04:20 <dons> they're content not to have a memory model?
15:04:24 <leithaus_> small changes to lazy code can cause big perf deltas
15:04:39 <dons> yes, laziness can make complexity-changing differences
15:04:49 <mauke> you know, /prog/ has certain bynames for languages
15:04:52 <SamB> in scripting languages, you don't tend to have much call to worry about it ... but if you did want to it wouldn't usually be that hard to guess
15:04:55 --- mode: mauke set -o mauke
15:04:57 <sm> I think the scripting languages have a more predictable model, you can just get by with an acquired "feel"
15:05:15 <leimy_> If you were deeply worried about memory utilization in a scripting language, you usually don't use a scripting language :-)
15:05:28 <mauke> the algorithmic language Scheme; the purely fictional programming language Haskell; the memory-leak based language C++
15:05:36 <mauke> and the SLOW AS FUCK language Ruby
15:05:52 <dankna> purely fictional?  that's a good one
15:05:52 <monochrom> What is /prog/ ?
15:05:54 <leimy_> mauke: the java version of ruby is supposed to be fast :-)
15:05:58 <dankna> I missed it on first reading
15:06:02 <leithaus_> meh -- speed is the least of the problems with Ruby
15:06:02 <pikhq> monochrom: Reddit, I'd assume.
15:06:21 <Phillemann> I've written a "connect" function which calls Network.connectTo and then returns the handle back to another function, but after "connect" returns the handle seems to be closed.
15:06:24 <mauke> monochrom: 4chan
15:06:35 <monochrom> Haha everyone bet wrong! :)
15:06:41 <leithaus_> given a 10 line code context of Ruby code, you cannot reliably tell what it does
15:06:41 <SamB> I mean, you can tell more-or-less how many of a given sort of thing you have live
15:06:51 <pikhq> Ruby always struck me as "Let's be like those other scripting languages, only worse".
15:06:54 <SamB> well, in Python
15:07:18 <mike-burns> So, I'm a Ruby dev for 8 hours a day, and I disagree that it's worse than Perl.
15:07:34 <leithaus_> and then ... after someone does a check in in a completely different part of the codebase... it does something different
15:07:38 <monochrom> Because perl is not a scripting language anymore. <duck>
15:07:39 <mike-burns> Also, its speed has seldom, if ever, been the bottleneck on our apps.
15:07:54 <SamB> monochrom: so what is it NOW?
15:07:59 <leithaus_> mike-burns: JRuby?
15:08:00 <monochrom> (Perl is a natural language.)
15:08:09 <edwardk> leithaus: i can empathize with that 10 line context statement =)
15:08:11 <mike-burns> leithaus_: Nope. The bottleneck is the database.
15:08:35 <leithaus_> mike-burns: i meant, are you using J or C Ruby?
15:08:44 <mike-burns> leithaus_: C Ruby (MRI). 1.8.
15:09:35 <leithaus_> and in large codebases types have a strongly navigational purpose
15:09:59 <leithaus_> i continually use types to direct my thinking along codepaths
15:10:33 <leithaus_> monkey-patching completely undermines this
15:10:57 <mike-burns> Like everything else in life, you can fully adjust to the Ruby way of programming and be quite efficient.
15:11:35 <timonator> what is monkey-patching? :x
15:11:43 <d3z> I just end up getting so frustrated at things the compiler _should_ be able to catch.
15:11:45 <mike-burns> timonator: Adding methods to an existing class.
15:11:51 <timonator> OK
15:12:09 <mike-burns> d3z: That's what lead me to Haskell.
15:12:20 <d3z> It's what keeps bringing me back :-)
15:12:52 <d3z> Although I'm happy that many good ideas make it into languages like Scala.
15:13:37 <mike-burns> Scala's pretty fun, for sure.
15:13:55 <dschoepe> If I put -threaded in the GHC_OPTIONS pragma, ghc complains about an unknown flag in the pragma. Do I need a different pragma for that?
15:14:22 <monochrom> OPTIONS_GHC ?
15:14:51 <dschoepe> err, yes that's what I'm using, I mistyped above.
15:15:02 <dschoepe> flags like -O2 work, but -threaded doesn't
15:15:02 <monochrom> (Someone please don't troll with suggesting "SNOITPO_CHG ?". :) )
15:15:32 <monochrom> Perhaps because -threaded is link-time not compile-time.
15:15:34 <sm> dschoepe: I think threaded would apply to the whole program, no
15:15:39 <mauke> É”É¥Æƒâ€¾suoÄ±Ê‡do
15:15:43 <dons> dschoepe: there's a distinction between dynamic and static flags
15:15:52 <dons> static flags control the language used, typically
15:15:55 <dons> but -threaded is a linking flag.
15:16:09 <dons> as a rule, the only thing that should appear in pragmas are LANGUAGE ...
15:16:09 <monochrom> Use makefile or cabal to specify -threaded.
15:16:13 <dons> indeed.
15:16:50 <dcoutts> I doubt linker flags are honoured in OPTIONS_GHC pragmas
15:17:01 <dschoepe> The specific case is xmonad, where the recompilation is handled by xmonad itself, so I'd need to change it to pass that flag.
15:17:14 <dcoutts> in any case it cannot be honoured when you compile without linking
15:17:33 <monochrom> xmonad self-build script does not already do -threaded ?
15:17:40 <dschoepe> no
15:17:55 <monochrom> Is -threaded really necessary?
15:18:00 <dschoepe> Adding it in its source works fine though.
15:18:11 <dschoepe> Yes, using forkIO
15:18:49 <Heffalump> forkIO doesn't imply you need -threaded, making FFI calls that block is what actually makes it necessary (AIUI)
15:18:59 <monochrom> Perhaps #xmonad people have better suggestions.
15:19:40 <dschoepe> Yes, forkIO sortof works, but the ffi blocks are the problem.
15:20:29 <dschoepe> Hmm, I guess I'll go with my patched xmonad-version and ask whether that should be applied in the repo
15:20:35 <dschoepe> thanks
15:20:40 <Heffalump> or arrange for it to be an option
15:20:54 <dschoepe> Does -threaded have any downsides?
15:20:56 <monochrom> OPTIONS_XMONAD ...
15:21:08 <Heffalump> I've observed it being slower in some situations
15:21:32 <SamB> what X11 library does Xmonad even use ?
15:21:46 <lysgaard> I need asyncrnus communication over network. (send and recieve at the same time) is it hard?
15:21:46 <dschoepe> SamB: the normal x11-bindings, not xhb
15:21:57 <SamB> no Xcb?
15:22:06 <SamB> or however you spell that?
15:22:12 <Heffalump> lysgaard: shouldn't be, just fork Haskell threads to do it
15:22:42 <dschoepe> SamB: nope, the advantages for switching would be minimal and switching quite some work
15:22:47 <lysgaard> Heffalump: Okay. I'll have to learn how to do that then ;=
15:23:01 <lysgaard> s/=/)/
15:23:16 <SamB> ... are there Haskell bindings for it ?
15:23:29 <Phillemann> When is a socket opened with connectTo normally closed?
15:23:30 <monochrom> This is a rare instance where if you learned how to do it in Java you can use the same technique in Haskell. :)
15:23:36 <dschoepe> SamB: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/xhb
15:23:55 <SamB> oh.
15:24:08 <natthew2> what do errors like this mean? (.text+0x7c1d): undefined reference to `__stginit_binaryzm0zi5zi0zi1_DataziBinary_'
15:24:12 <Heffalump> lysgaard: and look into Chans for communicating with an orchestration thread.
15:24:15 <SamB> somehow I got the impression that Xcb stood for X Call Backs or something ;-)
15:24:29 <dschoepe> natthew2: Some needed library was not linked against
15:24:57 <natthew2> against what?
15:25:17 <monochrom> against the program you're building.
15:25:35 <McManiaC> woot
15:25:42 <monochrom> Last time I saw a similar thing in this channel, it was because he/she had multiple versions of the same package installed.
15:25:46 <SamB> monochrom: why would the library have been linked against a program that wasn't built yet when it was linked?
15:25:52 <natthew2> i do
15:25:54 <lysgaard> Heffalump: Didn't get that one
15:25:54 <natthew2> actually
15:25:58 <natthew2> hm
15:26:16 <Cale> natthew2: --make
15:26:16 <dschoepe> SamB: The program was not linked against a library it needs, hence the error.
15:26:37 <Cale> natthew2: You should pass the --make flag to ghc if you're not already.
15:26:47 <Cale> natthew2: It resolves most problems of that sort.
15:27:03 <Cale> Or, in this case, -package binary
15:27:25 <natthew2> yeah, that worked
15:29:32 <SamB> dschoepe: yeah, I'm just teasing him about his handling of natthew2's english ;-P
15:29:57 <dschoepe> ah, okay
15:30:27 <monochrom> I did nothing of the sort.
15:31:09 <SamB> monochrom: yeah, that's what I'm teasing you about
15:31:16 <SamB> you didn't handle his english
15:32:01 <Heffalump> lysgaard: Just one possible way to do things: fork off threads to handle the asynchronous stuff, and send messages about it down a single Control.Concurrent.Chan when appropriate. The orchestrating thread can process those messages in sequence.
15:32:09 <monochrom> I don't know what you mean.
15:32:45 <lysgaard> Heffalump: Hm, sounds like a good idea
15:32:46 <dschoepe> the was a `flip' missing in the usage of "linked against" :)
15:34:03 <monochrom> Should I have answered "against the library"?
15:34:10 <Heffalump> essentially the non-determinism from the asynchronous behaviour gets resolved into the ordering of the messages in the channel.
15:36:59 <dschoepe> monochrom: I guess SamB wanted you to answer "the program was not linked against the library", since the "against what?" didn't make sense wrt to my formulation
15:38:56 <jpcooper> hello
15:39:10 <jpcooper> could someone tell me how to get haskell-mode to indent if-statements properly?
15:39:26 <SamB> jpcooper: not I :-(
15:39:42 <jpcooper> it's a pain in the backside!
15:40:06 <Vulpyne> I usually end up putting the else on the end of the line. It's not very readable but it seems to work.
15:40:28 <dschoepe> jpcooper++
15:41:43 <monochrom> IIRC a recent version of haskell-mode indents "then" and "else" by a level inner, so it will not cause errors.
15:42:09 <jpcooper> by a level inner?
15:42:19 <SamB> monochrom: so where does one obtain this version?
15:42:34 <jpcooper> oh you mean that it does it correctly
15:42:47 <jpcooper> SamB: maybe it's the CVS version
15:42:58 <SamB> the WHAT?
15:43:14 <SamB> oh, you think it's maintained in Emacs' arch repository?
15:43:16 <jpcooper> SVN*
15:43:39 <jpcooper> actually, yes, it is CVS
15:43:51 <dschoepe> jpcooper: haskell-mode is not part of emacs
15:44:02 <jpcooper> I know
15:44:12 <jpcooper> but there is a CVS version of haskell-mode
15:44:14 <monochrom> I'm using version 2.1
15:44:23 <jpcooper> I have 2.4
15:44:24 <dschoepe> jpcooper: ah, I didn't know that
15:44:29 <SamB> thank GOD they're going to switch to Bzr after releasing 23
15:45:20 <jpcooper> when is 23 to be released?
15:45:46 <SamB> er, half past never, maybe?
15:46:01 <SamB> well, "real soon now" is the impression they've been giving on the Emacs list..
15:46:15 <monochrom> http://www.iro.umontreal.ca/~monnier/elisp/#haskell-mode
15:46:46 <kulakowski> wasn't it like 6 years between 21 and 22?
15:47:10 <SamB> yeah, but they keep saying stuff like "this late in the game"
15:47:15 <natthew2> is it possible to do profiling on programs using Data.Binary?
15:47:37 <SamB> but I put that in quotes for a reason
15:47:47 <SamB> that reason being that I'm not sure I believe them
15:48:27 <kulakowski> Fair enough. I don't follow the development that closely, because I don't care especially much.
15:50:23 <jpcooper> which testing packages are there for Haskell where one writes the tests oneself
15:50:29 <jpcooper> +?
15:50:52 <dons> hunit or quickcheck.
15:50:59 <SamB> jpcooper: what do you mean by "writes tests"?
15:51:01 <dons> natthew2: yes.
15:51:12 <jpcooper> SamB: I write some conditions and it checks them all
15:51:26 <jpcooper> dons: I thought that quickcheck was for random tests
15:51:31 <jpcooper> I'll have a look
15:51:36 <dschoepe> jpcooper: Did you try the cvs version, does if/else-indentation work there?
15:51:40 <SamB> you, you ask it what to check
15:51:40 <dons> quickcheck with zero arguments are unit tests.
15:51:46 <SamB> it picks values to check them at
15:51:55 <SamB> er. I mean, you tell it what you want it to check ;-P
15:52:00 <dons> if you quantify over one of the variables, you end up with property-based testing (drive, by, e.g. random data)
15:52:40 <jpcooper> dschoepe: I don't actually know how to use CVS
15:52:50 <jpcooper> I'm too lazy at this time to find out how I can get access to the repository
15:53:10 <monochrom> I guess no one reads me.
15:53:34 <monochrom> "monochrom isn't speaking to my nick, let's ignore him"
15:53:38 <jpcooper> okay dons
15:53:50 <natthew2> dons: do you know where the source of the binary profiling library is? i can only find ubuntu/debian packages
15:54:21 <SamB> monochrom: actually I got distracted by http://hackage.haskell.org/cgi-bin/hackage-scripts/package/xhb or something
15:54:59 <jpcooper> monochrom: I don't know how to log on to the repository with those details, if that is what you are getting at
15:55:15 <SamB> jpcooper: anonymous/anonymous ?
15:55:25 <SamB> er, no, not quite
15:55:25 <monochrom> <monochrom> I'm using version 2.1  <monochrom> http://www.iro.umontreal.ca/~monnier/elisp/#haskell-mode
15:55:39 <dons> natthew2: oh, probably the easiest way is to: cabal install -p binary
15:55:41 <SamB> the username is apparantly anoncvs
15:55:56 <dschoepe> monochrom: I'd like to avoid downgrading, so I'll first check whether the cvs version solves it
15:55:57 <dons> natthew2: essentially, you have to rebuild the package with profiling enabled. if your distro doesnt provide profiling versions
15:56:09 <dons> having cabal-install working is the easiest way to do this.
15:56:11 <SamB> wait, haskell.org still offers CVS?
15:56:13 <monochrom> FWIW I never know how to log on to the CVS repositories or SVN repositories or darcs repositories or git repositories either.
15:56:27 <kulakowski> jpcooper: There is another minor mode for haskell indentation,
15:56:30 <jpcooper> SamB: I don't know the CVS command
15:56:30 <kulakowski> http://github.com/jwiegley/haskell-mode/blob/b03744b93120bdc64a03c4714541215592c1886f/haskell-indentation.el
15:56:38 <jpcooper> thanks kulakowski
15:56:45 <kulakowski> I've never used it myself but you can try
15:56:54 <monochrom> Oh? 2.4 doesn't work?
15:57:32 <dschoepe> monochrom: No, there "then" and "else" are on the same level as "if" which causes errors
15:57:53 <monochrom> I see. Sorry.
15:58:11 <kulakowski> I just heard someone mentioning this mode but haven't gotten around to trying it myself
15:58:19 <SamB> monochrom: ... I thought you said it was a *recent* version?
15:58:35 <monochrom> Just 3 minor versions ago!
15:58:44 <SamB> 4 years ago
15:59:17 <mjs22> is anyone here familiar with GHC on OSX?  I'm using 6.10.3 from the binary installer on haskell.org, and it seems it doesn't include profiling libraries.  Is the best bet to build a new GHC from scratch to get profiling support?
15:59:35 <dons> to get profiling versions of the libraries, including base?
16:00:35 <dschoepe> hmm, I get access denied when I try to checkout the cvs repo though
16:01:22 <SamB> dschoepe: try the git repo, no need to futz around with passwords: http://github.com/jwiegley/haskell-mode/tree/master
16:01:30 <SamB> it's just a mirror anyway
16:01:36 <dschoepe> Ah, thanks
16:01:45 <dankna> mjs22: I use ghc 6.10.3 on OS X but I built it myself, and I've never used it with profiling.  Sorry.
16:01:54 <dankna> But it builds nice and easy.
16:02:00 <SamB> thank kulakowski ;-)
16:02:19 <jpcooper> kulakowski: that doesn't work either
16:02:31 <jpcooper> I mean, it doesn't indent if-statements properly
16:02:41 <kulakowski> jpcooper: Same problem with not indenting if statements, or doesn't do anything right?
16:02:53 <jpcooper> just the if-statements
16:03:53 <mjs22> dons: not sure -- all I know is that the binary installer on linux seems to include profiling support, and the installer on my mac does not.  I want to avoid having to ssh to my linux system for profiling. :)
16:04:05 <monochrom> probably means "then" is right under "if" rather than the more correct a-few-spaces-more
16:06:49 <dschoepe> Ah, changing the line "(defcustom haskell-indent-thenelse 2
16:06:57 <dschoepe> from 0 to 2 or something else works
16:07:04 <dschoepe> (in haskell-indent.el)
16:07:48 <dschoepe> (the original line was "(defcustom haskell-indent-thenelse 0", I failed at pasting above)
16:09:00 <dschoepe> so a call to setq in .emacs should solve it
16:12:10 <veryalias> What should I do so that a package installed with cabal as root can be imported with regular users. (When I try to import it says it could not be found.)
16:12:50 <dschoepe> jpcooper: (setq haskell-indent-thenelse 3) in .emacs solves the issue for me.
16:13:10 <jpcooper> thanks dschoepe
16:13:43 <largos> I'm having dependency resolution problems with cabal install: despite having the most recent versions of the req'd libraries, I keep getting errors such as this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6591#a6591
16:14:29 <dschoepe> veryalias: install it via cabal install --global foo
16:14:56 <jpcooper> good night
16:14:58 <dschoepe> largos: Try running cabal update before
16:15:30 <largos> dschoepe: same thing
16:15:58 <veryalias> dschoepe: thanks, can I make an already installed package global?
16:16:09 <largos> hm... I may have misunderstood which package was needed....
16:16:34 <dschoepe> veryalias: I don't think so. So removing it and reinstalling as global might be simpler
16:17:07 <largos> er, maybe not... the cabal install complaints *do* refer to operating system packages, right?
16:19:11 <dschoepe> largos: No, they refer to haskell libraries
16:19:32 <largos> dschoepe: ah... they don't seem to be showing up in cabal list
16:19:43 <dschoepe> largos: try running cabal install in that directory
16:19:50 <dschoepe> it should fetch all needed dependencies
16:19:51 <largos> which directory?
16:20:03 <veryalias> dschoepe: I just installed it again globally as root, will there be some kind of duplicate resovling problems (with the non-global installed) if I update in the future?
16:20:20 <dschoepe> largos: the one your source is in. Or are you installing via "cabal install foo"?
16:20:30 <largos> I'm installing via 'cabal install foo'
16:20:44 <largos> (I'm installing leksah)
16:21:09 <dschoepe> In that case, I'm puzzled
16:23:28 <lilac> @hoogle (MonadTrans t, Monad m) => (m a -> m a) -> (t m a -> t m a)
16:23:29 <lambdabot> Data.Map alter :: Ord k => (Maybe a -> Maybe a) -> k -> Map k a -> Map k a
16:25:10 <largos> dschoepe: I pulled down a lazy repo. of leksah, and running cabal install in that repo. does the same thing too.
16:28:50 <Heffalump> lilac: intuitively, that's not possible, because you can't get from t m a  to ma
16:29:23 <Heffalump> though it feels like it ought to be possible to implement it for any given useful monad transformer
16:31:02 <roconnor> Heffalump: I don't think that is the case.  I'm trying to think of an example I encountered
16:32:06 <roconnor> oh
16:32:07 <roconnor> hmm
16:32:48 <roconnor> Heffalump, lilac: tmap :: (MonadTrans t, Monad m, Monad n) => (forall a. m a -> n a) -> (forall b. n b -> m b) -> t m c -> t n c
16:32:49 <EvilTerran> what're we trying to implement?
16:32:53 <roconnor> is that useful?
16:33:02 <roconnor> EvilTerran: (MonadTrans t, Monad m) => (m a -> m a) -> (t m a -> t m a)
16:33:35 <rocketman> I spilled spot remover on my dog.. haven't seen him since!
16:33:38 <EvilTerran> ?type lift
16:33:39 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
16:33:54 <EvilTerran> hmm...
16:33:57 <Heffalump> roconnor: what does tmap actually do?
16:34:01 <EvilTerran> this feels like it should be possible
16:34:16 <roconnor> I don't know. ...
16:34:20 <lpsmith> I'm skeptical
16:34:22 <roconnor> it is one of the methods of MonadTrans
16:35:37 <Heffalump> it is?
16:36:58 <lpsmith> which monad library?
16:38:29 <jimmyjazz14> I'm trying to figure out how to parse a file in a functional language like haskell.  Basically its a file that should be read line by line, each line should be printed on the screen but only if the preceding line does not contain #EXCLUDE
16:38:48 <jimmyjazz14> the file will be very large
16:39:58 <jimmyjazz14> I was thinking of using something like 'zip' but its seems like that would create a lot of overhead (with a large file)
16:40:18 <pikhq> Try it and see.
16:41:30 * dilinger gets a sudden clash urge
16:42:41 <lpsmith> jimmyjazz14:   zip is a good producer and consumer (in one argument)...  so there is the opportunity to eliminate some of the intermediate results
16:43:57 <jimmyjazz14> lpsmith: what do you mean?
16:45:26 <FunctorSalad> jimmyjazz14: foldl with b = (Bool,[Line]) , where the bool says whether the last line contained #EXCLUDE?
16:45:32 <FunctorSalad> @ty foldl
16:45:33 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
16:45:45 <FunctorSalad> a = (Bool,[Line]), actually
16:45:51 <FunctorSalad> b = Bool
16:46:00 <FunctorSalad> er
16:46:02 <FunctorSalad> b = Line
16:46:36 <FunctorSalad> and probably better use foldr, not foldl?
16:46:48 <FunctorSalad> (to start producing items immediately)
16:46:59 <jimmyjazz14> FunctorSalad: that sounds right
17:08:21 <jimmyjazz14> this is what I came up with...
17:08:21 <dancor> @pl maybe []
17:08:22 <lambdabot> maybe []
17:08:23 <jimmyjazz14> foldl (\a b-> if (not $ fst b) then (snd b):a else a) [] $ foldl (\a b->( snd (head a) == "#EXCLUDE" || b == "#EXCLUDE" , b ):a ) [(True,"")] (lines a)
17:08:25 <dancor> is that anything cool
17:08:41 <dancor> like (mappend lol)
17:09:40 <idnar> @type maybe []
17:09:41 <lambdabot> forall a a1. (a1 -> [a]) -> Maybe a1 -> [a]
17:23:41 <Plouj> hi
17:24:12 <Plouj> if OGL is a fork of the , does OpenGL 2.2.1.1 package that mean that OpenGL won't be deloped anymore and I should learn to use OGL?
17:24:16 <Plouj> http://www.haskell.org/haskellwiki/OGL
17:27:53 <jimmyjazz14> I reduced it to...
17:27:54 <rocketman> > 55-18
17:27:54 <jimmyjazz14> putStr . unlines $ snd $ foldl (\a b->let ex = (b == "#EXCLUDE") in  if (fst a == True || b == "#EXCLUDE") then (ex,snd a) else (ex, b:snd a) )  (True,[]) (lines a)
17:27:56 <lambdabot>   37
17:28:04 <Zao> Plouj: Sounds rather experimental.
17:30:29 <dancor> isn't (maybe []) just <$>
17:34:11 <aavogt> @type maybe []
17:34:13 <lambdabot> forall a a1. (a1 -> [a]) -> Maybe a1 -> [a]
17:34:50 <aavogt> @type (<$> Nothing)
17:34:52 <lambdabot> forall a b. (a -> b) -> Maybe b
17:35:42 <aavogt> jimmyjazz14: x == True is the same as x
17:36:42 <monochrom> I think we went over that yesterday.
17:37:20 <aavogt> and there's another common subexpression to lift out:   ... if fst a || ex then ...
17:37:31 <monochrom> I think a more interesting activity is to have a flame war over whether "x == True" is more "readable".
17:38:27 <aavogt> @src Eq Bool
17:38:28 <lambdabot> Source not found. stty: unknown mode: doofus
17:38:42 <aavogt> anyways, I'm sure its strict
17:38:52 <monochrom> I have a hunch that some people's "readable" involves "more tokens for less semantics is more readable", "if it looks like English it's readable".
17:39:24 <aavogt> > fix ("True =="++)
17:39:25 <dancor> but even then who says "if i like you is true, will you is like me true too"
17:39:26 <lambdabot>   "True ==True ==True ==True ==True ==True ==True ==True ==True ==True ==True...
17:39:31 <aavogt> > fix ("True == "++)
17:39:32 <lambdabot>   "True == True == True == True == True == True == True == True == True == Tr...
17:39:49 <aavogt> > fix ("True == ("++)
17:39:51 <lambdabot>   "True == (True == (True == (True == (True == (True == (True == (True == (Tr...
17:39:51 <monochrom> Yes that is usually my counter-argument
17:40:07 <dancor> truly
17:40:35 <monochrom> "if it looks like English is true, it's readable is true" haha great.
17:40:42 <idnar> hahaha
17:40:43 <aavogt> I think its convincing
17:41:27 <aavogt> perhaps the only point of (==True) is that it is like a type annotation?
17:41:41 <dancor> we have achieved a new synthesis of preaching to the choir and straw man argument
17:41:50 <monochrom> The only point is that the writer has not internalized logic.
17:42:56 <rocketman> "The natural language interpretations of infinitary boolean logic"
17:43:25 <rocketman> Dr. here I come
17:44:10 <aavogt> @check const True "say"
17:44:11 <lambdabot>   "OK, passed 500 tests."
17:44:30 <monochrom> There was someone on the internet who thought verbose was readable, "one idea per line". I replied with this: http://groups.google.com/group/comp.lang.functional/msg/17520bdd236b3351
17:44:46 <dancor> oh the internet
17:45:08 <monochrom> Surely I can do one-idea-per-line too. One line doesn't have to have 3 tokens.
17:46:23 <monochrom> Anyway that was how I deduce that some people want "more tokens for less semantics". Not strawman. I have a real example.
17:47:40 <SamB> monochrom: you've been believing too much xkcd again, haven't you?
17:47:50 <SamB> "someone on the internet is wrong" indeed!
17:49:03 <monochrom> Does it have to be "me right, them wrong"?
17:50:04 <monochrom> I'm just showing concrete examples of other people's opinions so you know I'm not building a strawman.
17:50:48 <SamB> monochrom: oh, it just sounded so wrong to me
17:51:16 <SamB> it is actually me who has been reading too much, xkcd I think
17:51:49 <SamB> and the point of the comic, I think, was that "someone on the internet is wrong" is not an emergency ;-P
17:52:10 <SamB> no matter how much we sometimes act like it
17:53:00 <aavogt> the same kind of indirectness sometimes occurs elsewhere
17:53:30 <SamB> aavogt: which kind ?
17:54:14 <aavogt> @type M.update (Just . ?f)
17:54:16 <lambdabot> forall b k. (?f::b -> b, Ord k) => k -> M.Map k b -> M.Map k b
17:54:41 <aavogt> @type M.update (Just . const ?f)
17:54:42 <lambdabot> forall a k. (?f::a, Ord k) => k -> M.Map k a -> M.Map k a
17:55:01 <aavogt> I found out that I wrote something like that
17:55:08 <SamB> hmm. I don't understand this sentance: "(Some cheap shots are too got to resist, sorry.)"
17:55:13 <SamB> what's "got" mean here?
17:55:21 <monochrom> perhaps "great".
17:55:50 <aavogt> anyways, that's M.insert
17:55:56 <monochrom> perhaps "hot"
17:56:24 <aavogt> where was this written?
17:56:51 <SamB> http://groups.google.com/group/comp.lang.functional/browse_thread/thread/6179df438bd4138d/17520bdd236b3351?#17520bdd236b3351
17:57:56 <dibblego> sentence (no 'a')
17:58:31 <SamB> dibblego: oh, whatever
17:58:43 <SamB> at least I use punctuation ;-)
17:59:13 <SamB> i don't just talk 2 u like this usually
17:59:24 <idnar> maybe "good"
17:59:26 <dibblego> np
17:59:38 <monochrom> "good" is the closest
18:00:45 <dcoutts> quick poll: we're getting cabal-install to maintain an index of all haddock docs. How should the setting to turn it on/off work? Should we just always do it when you turn doc generation on? Should it have a separate toggle?
18:01:37 <dcoutts> eg if you've got "documentation: True" in your ~/.cabal/config (equivalently --enable-documentation on the command line) should that be enough to make it update the central doc index?
18:02:04 <dcoutts> or do we need a separate "doc-index: True" setting in the config file?
18:02:30 <dcoutts> remember, every extra option has a cost in terms of user comprehension (especially in the --help output)
18:02:45 <dcoutts> too many flags / settings == user confusion
18:03:15 <aavogt> updating the index is cheap?
18:03:25 <sm> dcoutts: a global flag seems fine to start
18:03:25 <sjanssen> dcoutts: are there any negatives to the index?
18:03:48 <monochrom> If I uninstall a package, is the doc index cleaned up?
18:04:11 <dcoutts> sjanssen: it takes time to generate
18:04:30 <dcoutts> monochrom: next time you install something that has docs yes.
18:04:36 <sjanssen> dcoutts: how much time?
18:04:40 <monochrom> eww
18:04:43 <dcoutts> monochrom: since cabal doesn't know when you remove something
18:05:00 <dcoutts> monochrom: since currently you do that via ghc-pkg unregister
18:05:12 <monochrom> I guess no one uninstalls.
18:05:18 <dcoutts> if/when we add cabal uninstall then we could update the index at the same time
18:05:46 <monochrom> I don't mind lacking a dedicated setting.
18:07:13 * dcoutts times it
18:07:33 <sjanssen> dcoutts: I think on by default, with an option in the config to turn it off if it is really that slow
18:08:15 <aavogt> I think that when speed matters, people wouldn't enable docs at all
18:08:49 <monochrom> My current practice is I run Setup build and Setup docs etc. Then I manually add a bookmark to my web browser to point to the file:///usr/local/share/doc/nice-package/index.html
18:09:33 <monochrom> If cabal takes less time to re-build index than my speed of typing in a file:///usr/local/share/blahblahblah url, then you win.
18:10:01 <dcoutts> sjanssen: about 25 packages (with docs) per second
18:11:05 <dcoutts> sjanssen: so I've got 180 packages but only 24 with docs installed and it takes about 1 second
18:11:51 <dcoutts> sjanssen: so for people who enable docs it'll probably take 1-5 seconds
18:12:05 <aavogt> dcoutts: is there some way to specify --hyperlink-source for all cabal builds?
18:12:48 <dcoutts> aavogt: when using 'install' you mean. No currently no. We have not yet agreed on the user interface so it's not yet implemented.
18:13:02 <monochrom> apt-get upgrade takes longer.
18:13:15 <dcoutts> sjanssen: an option to turn it off is the thing that has the extra cost in terms of longer more confusing config file and --help output
18:15:44 <dcoutts> aavogt: if you'd like to suggest something see this ticket http://hackage.haskell.org/trac/hackage/ticket/517
18:16:28 <dcoutts> Saizan suggested that we have some generic way of passing flags to sub-commands that are invoked by install
18:16:49 <dcoutts> I'm interested in the output of cabal install --help being sane and comprehensible
18:17:10 <dcoutts> and not ending up with ad-hoc versions of all the other flags that all the other commands take
18:17:20 <monochrom> Cabal::X::Y::Z::enabled? = yes
18:18:14 <ManateeLazyCat> Hi all, i want a data structure that like map store key and value  (Key, Value), but have something different: `Key` is order number (such as: 0, 1, 2, 3, 4....) and `Value` is unique id. I want INSERT any VALUE in some KEY, after value will be resorted. Example i have this data and it's [(0, Id0), (1, Id1), (2, Id2)], when i insert VALUE `Id4` at `1`, then it became [(0, Id0), (1, Id4), (2, Id1), (3, Id2)]. So have an exist data
18:18:14 <ManateeLazyCat> structure in Haskell? Thanks!
18:19:01 <monochrom> Perhaps Data.Sequence
18:19:01 <dcoutts> sjanssen: so what do you think, given the current performance?
18:19:22 <ManateeLazyCat> monochrom: Perhaps?
18:19:32 <monochrom> Perhaps.
18:19:34 <aavogt> yeah, you could go with --haddock-flags="--hoogle bleh", but there's probably better options
18:20:15 <aavogt> out there
18:20:28 <ManateeLazyCat> monochrom: Thanks, i see it.
18:20:48 <dcoutts> aavogt: the other question is if all these need to be accessible via the cli. There more room for syntax in the config file
18:21:42 <monochrom> Oops, Data.Sequence doesn't have insertion.
18:21:56 <dcoutts> it does via split and join
18:22:01 <monochrom> See? I have to add perhaps. I am never sure.
18:22:18 <ManateeLazyCat> monochrom: So better solution?
18:23:07 <aavogt> how does Map fail for that use case?
18:23:38 <monochrom> Not fail. Lots of extra work.
18:23:40 <dancor> aavogt: it overwrites values instead of pushing them forward
18:24:15 <ManateeLazyCat> aavogt: If i insert some value in key, if that key have exist, it just replace old value with  new value, but i just want this map will be resorted elements after i insert.
18:24:31 <dancor> i would use Data.Sequence or spend three months making something new and beautiful for it
18:24:32 <ManateeLazyCat> aavogt: Yep, i just want push new value, not instead.
18:24:36 <mle> Data.Map lets you add with a combining function.
18:24:39 <aavogt> say the elements of the Map are lists?
18:24:39 <dancor> i usually flip a coin to decide between those two
18:25:37 <dancor> aavogt: sure but then it can become all listy instead of mappy after many adds and removals
18:25:54 <aavogt> yep
18:25:56 <Cale> dancor: eh?
18:26:13 <dancor> Cale: like an unbalanced chaining hash function
18:26:25 <ManateeLazyCat> aavogt: And i need search, add, remove in those data structure.
18:26:37 <Cale> But isn't the idea just to have multiple elements associated with a given key? Does the order matter?
18:26:49 <dancor> the idea is to push elements forward
18:26:52 <dancor> so order matters
18:27:01 <Cale> er...
18:27:04 <Cale> ah
18:27:07 <Cale> Use Data.Sequence
18:27:29 <Cale> Pushing elements forward doesn't really mean anything in the context of a general Map
18:27:48 <ManateeLazyCat> So result is use Data.Sequence ?
18:27:52 <Cale> yes :)
18:28:06 <ManateeLazyCat> Oh, Thanks all for help! :)
18:28:12 <dancor> irc is like a function with a result
18:28:19 <Cale> It's just like a finite list, but has fast concatenation, splitting, and access to both ends
18:28:23 <dancor> Either Flame Answer
18:28:38 <monochrom> All of you are morons.
18:28:44 <brian6> NO U
18:28:46 <dancor> monorons
18:29:13 <Cale> Left f = monochrom
18:29:17 <ManateeLazyCat> Cale: So i can implement PUSH function even Data.Sequence haven't INSERT action.
18:29:47 <Cale> ManateeLazyCat: It essentially does have an insert. Split it at the place where you want to insert an element and then add the element and concatenate.
18:29:54 <Cale> That's log time and space.
18:30:42 <ManateeLazyCat> Cale: Thanks for explain! :)
18:31:19 <Cale> insertAt n x xs = let (ys,zs) = Seq.splitAt n xs in ys >< (x <| zs)
18:31:28 <ManateeLazyCat> Cale: And log time is i want.
18:31:32 <dilinger> how does one define a data type in ghci (aside from adding it to a file and loading it into ghci)?  'let data Foo = Bar' doesn't work..
18:31:35 <ManateeLazyCat> Cale: Thanks.
18:31:43 <Cale> dilinger: One does not.
18:31:55 <dilinger> darn
18:31:58 <dancor> the i stands for incomplete
18:32:02 <Cale> dilinger: You're really expected to put definitions into a file.
18:32:33 <Cale> dilinger: There is that 'let' syntax for making temporary definitions, but it's not really how you're expected to use it.
18:33:03 <Cale> Usually I'll keep a file open in my editor alongside ghci, and then when I save the file, it's just :r to reload it in ghci
18:33:21 <Cale> and that way you never lose work
18:33:35 <ManateeLazyCat> Cale: In emacs, you won't save file.
18:33:38 <brian6> if i'm in monad Either and translate False to Left, did i 'lift' the Bool?
18:33:40 <Woof> The Unlambda interpreter is broken in the same manner >.>
18:33:46 <Woof> @unlambda `
18:33:46 <lambdabot>   fd:7: hClose: resource vanished (Broken pipe)
18:33:47 <ManateeLazyCat> Cale: It save file when you stop finger. :)
18:33:51 <Cale> brian6: I suppose.
18:34:11 <monochrom> I will save the file.
18:34:18 <dilinger> Cale: yeah, that's what i'm doing now, but it would be quicker (for what i'm doing now, which is just trying out different types) to be able to bypass the separate file step.  ah well, thanks anyways
18:34:21 <ManateeLazyCat> Cale: I split two window in Emacs, one for file, one for terminal.
18:34:32 <dancor> @vixen I will save the file.
18:34:33 <lambdabot> Beer, it's so much more than just a breakfast drink!
18:34:50 <monochrom> ...
18:34:55 <Cale> ManateeLazyCat: Isn't it C-x s ?
18:35:14 <monochrom> I just press the save button, sometimes.
18:35:15 <Cale> It's been a while since I last used emacs.
18:35:16 <ManateeLazyCat> Cale: NO, emacs save file when you STOP hit key.
18:35:29 <ManateeLazyCat> Cale: http://www.emacswiki.org/emacs/MultiTermDedicatedShotPage
18:35:33 <augustss> autsave
18:35:56 <monochrom> autistic save
18:36:13 <augustss> indeed
18:36:22 <ManateeLazyCat> Cale: So i haven't type "C-x s" two years. :)
18:36:57 <monochrom> Why should it save only when you don't type. Why doesn't it save always.
18:37:43 <ManateeLazyCat> monochrom: In fact, it save file when idle 1 second.
18:37:53 <monochrom> My proposal: Save if the user seems to have stopped typing. Save if the user has typed 10 keys since last save.
18:37:54 <ManateeLazyCat> monochrom: So it ALWAYS save
18:38:20 <FunctorSalad> to avoid lag?
18:38:38 <FunctorSalad> (save only when user stopped typing)
18:38:40 <monochrom> No, I may have 2 minutes of typing 100 keys, no idle 1 second. Then power fails. I have lost 100 keys, maybe the most crucial 100 keys. This is dumb.
18:38:46 <ManateeLazyCat> Cale: In my screenshot, you will see terminal in bottom side.
18:38:50 <idnar> monochrom: saving every 10 keystrokes sounds really expensive
18:39:02 <idnar> monochrom: maybe if there were some way to save the file without replacing the entire contents...
18:39:12 <augustss> save a log
18:39:13 <ManateeLazyCat> monochrom: Yes, but you should be rest?
18:39:25 <monochrom> I rest every 3 minutes?
18:39:58 <monochrom> Maybe I'm typing up English prose, my thesis, and I rest only every 15 minutes?
18:40:09 <Cale> Hmm, I wonder if I would actually care for that... I suppose it wouldn't be too inconvenient, but occasionally I decide that I'd rather reload the file than keep my changes.
18:40:21 <ManateeLazyCat> monochrom: In fact, it just the feature of autosave. Emacs always save any file in background, emacs will recover file when power cut.
18:40:31 <monochrom> Do you know how it is like if you are writing your thesis and you are furiously typing for 15 minutes and it is all lost? Have you tried?
18:40:49 <augustss> I don't want my emacs to save without a command.  And it doesn't, just the auto-save file every N keystrokes.
18:40:55 <shapr> What's the best approach to using Data.Binary for audio file tagging? I want to check and tag my FLACs. I've played around with Data.Binary, but it's so very manual...
18:41:07 <ManateeLazyCat> monochrom: No, it won't lost.
18:41:21 <ManateeLazyCat> monochrom: I just talk 'autosave.el' in Emacs.
18:41:31 <ManateeLazyCat> monochrom: In fact, Emacs always backup your any file.
18:41:35 <camior> shapr: manual?
18:41:44 <ManateeLazyCat> monochrom: Even you never stop hit key.
18:41:47 <Cale> shapr: Data.Binary really seems like a better thing if you have control over the file format, though there are the Get and Put monads...
18:41:53 <shapr> edwardk was tellin me about some library that lets you build a datatype and then derive the Data.Binary code.. anyone know what that might be?
18:42:25 <ManateeLazyCat> monochrom: Okay, enough about Emacs, if you interested deep about Emacs, please ask me in #emacs.
18:42:48 <monochrom> augustss: You don't want saving-without-command because your file system is not a versioning system yet. You will welcome it when VMS dominates the world again.
18:43:10 <shapr> ravi_n: Hey, are you the BlueSpec guy?
18:43:13 <dancor> shapr: import Data.DeriveTH
18:43:26 <dancor> $(derive makeBinary ''MyThing)
18:43:34 <shapr> Ah spiffy!
18:43:57 <shapr> Are there other libraries that automate the de/serializing process?
18:44:35 <shapr> ravi_n: Ah, yes you are!
18:44:46 <camior> shapr: There's a couple that do things like JSON and others using SYB.
18:45:00 <beutdeuce> what does it mean when it asks for an instance declaration?
18:45:05 <shapr> dancor, camior: thanks!
18:45:42 <camior> shapr: Have you considered using something like parsec with Data.Binary to parse the flac files?
18:45:58 <shapr> Will that work?
18:46:10 <shapr> Is there any example code around that shows how to do that?
18:46:16 <camior> shapr: I don't know, but usually when I get a flat file format I use parsec.
18:46:22 <shapr> That would be my preferred solution :-)
18:46:34 <camior> I don't know what the integration is like with Data.Binary.
18:46:48 <dancor> what does flat mean there
18:47:24 <camior> s/flat/created with some specification that I cannot modify.
18:48:03 <shapr> camior: So, you'd just read it into memory and parse it there?
18:48:35 <camior> shapr: Yeah, if the use of ram isn't really a concern.
18:48:56 <camior> shapr: I'm not aware of a really nice parser library that doesn't load the file all into RAM.
18:49:09 <shapr> Lazy ByteStrings could do it, yeah?
18:50:14 <shapr> I mean, that's the way to load it incrementally...
18:50:24 <shapr> I dunno about incremental parsing...
18:50:30 * shapr boings cheerfully
18:50:37 <camior> I don't know, I can imagine parsec being implemented in a way that would in essence "bypass" the laziness of the ByteString.
18:50:47 <shapr> Well, might as well try it...
18:50:55 <shapr> Have you parsed binary data with Parsec?
18:51:11 <camior> Nope, not yet.
18:51:18 <brian6> oh. use attoparsec for parsing binary data.
18:51:34 <brian6> it's like parsec lite for lazy bytestrings, by bos.
18:51:42 <shapr> ah, spiffy
18:52:21 <brian6> it's pretty nice.
18:52:29 <dankna> also, attoparsec is an awesome name.
18:53:33 <jeffwheeler> Is Swish still the only significant semantic web utility for Haskell?
18:53:46 <jeffwheeler> I thought I remembered something else from a few months back, but I only see Swish now.
18:55:02 <beutdeuce> is there a way to append variable values in strings? like "hello $x" where x is a variable for the world string
18:55:34 <jeffwheeler> Append or interpolate?
18:55:44 <beutdeuce> like "hello $x" where x
18:55:44 <beutdeuce>             is a variable for the world string
18:55:56 <brian6> beutdeuce: maybe use 'template' by johan tibell.
18:56:19 <jeffwheeler> Eh, Swish doesn't appear to have been updated in the last five years. I'd call that dead.
18:57:16 <brian6> beutdeuce: or xformat.
18:57:43 <camior> beutdeuce: Are you looking for something like f = \x y -> "$x and $y"?
18:57:49 <monochrom> "hello " ++ x  at least as a first version.
18:58:07 <beutdeuce> the problem is, it is thinking that when i do ++, its an argument, ie: writeFile "/"++name "hello"
18:58:47 <camior> writeFile ("/" ++ name ++ "hello")
18:59:01 <camior> or -> writeFile $ "/" ++ name ++ "hello"
18:59:10 <Cale> beutdeuce: It's parsing that as  (writeFile "/") ++ (name "hello")
18:59:12 <brian6> what's the story on mtl vs. transformers?
19:00:28 <Cale> brian6: I'm not 100% sure, but I think transformers is part of a package which separates the Haskell98 part of mtl from the part requiring extensions
19:01:09 <Cale> mtl is the one which most people use, as far as I'm aware...
19:01:25 <brian6> well, i'm hiding more packages than santa claus. JUST SAYING.
19:01:31 <Cale> hehe
19:01:33 <brian6> i hope someone has a plan.
19:02:01 <Cale> My plan would be to kill the mtl libraries and do a better set of monad libraries.
19:02:26 <brian6> tell haskell cafe or something. dons will probably crank it out tonight.
19:02:34 <Cale> I suppose I could too.
19:02:57 <aavogt> > sqrt 3 :: CReal
19:02:58 <lambdabot>   1.7320508075688772935274463415058723669428
19:03:01 <Cale> monadLib is closer to ideal
19:03:15 <idnar> heh
19:03:41 <Cale> But it still makes the (admittedly very minor) mistake of using (a,s) rather than (s,a) pairs ;)
19:03:56 <brian6> please mail him.
19:04:18 <Cale> Also, I think the stuff in logict should be worked in.
19:04:50 <Cale> Well, what is there to inform dons about?
19:04:56 <sjanssen> brian6: I don't think a reworked monad library is something you just crank out in an evening
19:04:57 <Cale> That package exists, you can use it ;)
19:05:04 <brian6> sjanssen: bit of humour.
19:05:12 <brian6> cuz he does a lot.
19:06:14 <Cale> I've been thinking about it a while, so I probably could throw something together fairly quickly, but there are a number of approaches to monads with composable effects, and I'm sort of hoping to figure out a way to combine them.
19:06:28 <Cale> Well, I should think about that actively some more.
19:06:31 <sjanssen> Cale: I think it might be too late for (s, a)
19:06:43 <sjanssen> unless you're talking about a totally fresh start
19:06:46 <FunctorSalad> "<Cale> My plan would be to kill the mtl libraries and do a better set of monad libraries." <-- better have an automatic refactorer then ;)
19:07:13 <Cale> FunctorSalad: Nah, new programs can use different libraries. There's no need to migrate everything right away.
19:07:53 <Cale> MonadPrompt is really nice, but I'd like to work out a good way to combine prompt types and interpreters for those types.
19:09:36 <Cale> It's also annoying that type inference surrounding GADTs isn't just a little bit stronger...
19:10:16 <Cale> You have to give explicit types to the parts of your interpreter, and the types are often worse than the code.
19:11:53 <Cale> But a nice thing is that any Prompt monad is really a monad, you don't have to check the laws.
19:19:16 <dancor> when i used takusen the types were totally insane
19:19:35 <dancor> and i had to stop using this auto-add-type-sigs thing
19:19:57 <brian6> dancor: what did you use takusen for?
19:20:34 <monochrom> haha
19:20:42 <dancor> brian6: i was working on this chess opening explorer
19:21:03 <dancor> and i needed to do binary data with postgres and something wack was happening with hdbc-postgresql
19:21:17 <brian6> dancor: oh, neat. did takusen work ok with postgres?
19:21:23 <dancor> hilariously, takusen didn't support it either but it was cooler and i was able to add what i needed there
19:21:36 <dancor> and i'm still waiting on that patch to be accepted
19:21:46 <dancor> open-source: it works; except when it doesn't
19:21:49 <brian6> :/
19:22:14 <brian6> dancor: did you check if their mega test suite still passed after the patch?
19:22:54 <dancor> no there wasn't one actually the guy finally got back to me recently and added a test for my code and i think he'll commit it soon
19:23:03 <petekaz> quick question: I'm reading Richard Bird's sudoku solver (http://www.cs.tufts.edu/~nr/comp150fp/archive/richard-bird/sudoku.pdf) programming pearl and in the PDF he uses a symbol that looks like the '^' character.  What does that stand for?
19:23:48 <petekaz> (page 2 ... 'correct' and 'nodups' function definitions)
19:23:57 <brian6> maybe 'and'?
19:24:18 <petekaz> that's what I thought, but isn't and '&&'?
19:24:41 <brian6> yeah, you're right. some people like to use more mathy symbols in pdfs.
19:24:42 <Cale> petekaz: yeah, in text :)
19:24:44 <QPlaty[HireMe]> petekaz: Its the and from logic
19:25:05 <petekaz> math nerds!
19:25:16 <dancor> it's how you turn a program into a paper
19:25:28 <dancor> it turns out programs are usually too easy to understand
19:25:56 <brian6> just depends on perspective. i learned >>= first, but lots of people learned some math symbol first that >>= is trying to look like.
19:26:06 <Cale> Haskell programmers are all just applied logicians who spend most of their time proving trivial theorems in more and more interesting ways in an inconsistent intuitionist logic.
19:26:25 <petekaz> Is there a page that provides a legend for non-math folks?
19:26:58 <Cale> petekaz: well, the upside-down version of that ^ is 'or'
19:27:08 <dilinger> petekaz: something like that might turn you into a math folk.  dangerous!
19:27:21 <Cale> actually, the use of v for 'or' came first. It's from the Latin 'vel'
19:27:59 <brian6> petekaz: https://secure.wikimedia.org/wikipedia/en/wiki/Math_symbols  helpful, at least.
19:28:03 <dancor> math is even crazier and more inconsistent than programming; doesn't that seem backwards to anyone else
19:28:07 <petekaz> haskell: more than just a computer programming language.
19:28:09 <Cale> but it turns out to agree so beautifully with the use of a U shape for union
19:28:18 <dancor> perhaps in the future the two fields will just merge
19:28:32 <Cale> dancor: you mean notation-wise?
19:28:37 <dankna> I don't think that either discipline would profit from a merge
19:28:38 <monochrom> x âˆ§ y âˆ¨ z
19:28:55 <dancor> Cale: ya and things are always being called lots of different things
19:29:01 <dankna> mathematicians are not good at all the fiddly details that programmers set great store by, and I suspect they'd have the same criticism of us
19:29:09 <brian6> monochrom: does that stuff render correctly for you? i see boxes.
19:29:31 <Cale> dancor: It's not so much that they're not good at those details, it's that they find those details boring.
19:29:37 <monochrom> It renders correctly for me.
19:29:38 * dankna blinks
19:29:39 <dankna> dancor?
19:29:44 <dankna> well, yeah, I agree
19:29:50 <Cale> er, dankna
19:29:51 <monochrom> http://www.vex.net/~trebla/symbols/select.html may help
19:29:53 <dancor> dan.kna
19:29:54 <dankna> but you can't be good at them without practice at them, was my thinking
19:29:59 <dankna> yeah, it's my name - Dan
19:30:04 <natthew2> Is there any reliable way to get around file locks with openBinaryFile?
19:30:12 <dancor> it was a namespace joke
19:30:46 <brian6> natthew2: how do you mean?
19:30:51 <dankna> oh, haha
19:31:46 <natthew2> i need to open a file, decode it to a bunch of doubles, do some computation with it and recieve a new set of doubles, encode them, and write them as a binary file
19:32:16 <natthew2> but i am not sure how to get around laziness in all cases
19:32:25 <dankna> sounds much like the ICFP contest problem, haha
19:32:37 <Cale> natthew2: if you mean write them to the same file, then don't use lazy I/O
19:32:56 <monochrom> Most IO commands are not that lazy.
19:33:33 <Cale> Yeah, just avoid using lazy hGetContents
19:33:44 <natthew2> what is strict?
19:33:52 <Cale> Since you're reading binary floats, you'll probably want storablevector anyway
19:34:19 <Cale> and it defaults to strict (unless you import the lazy version of it)
19:34:51 <Cale> http://hackage.haskell.org/package/storablevector
19:36:45 <hackagebot> AspectAG 0.1.1 - Attribute Grammars in the form of an EDSL (MarcosViera)
19:37:54 <Cale> dankna: Most mathematicians are reasonably good at formalising things because it's sort of what you do when you're having trouble deciding if some argument really works.
19:38:19 <dankna> well yes,
19:38:26 <Cale> dankna: But usually you'll do it once, and then see how it works, and then next time it comes up, probably not bother. :)
19:38:36 <dankna> thanks, yes, that was what I was about to try and articulate :)
19:38:58 <dankna> I mean, it's actually interesting and probably profitable to compare them
19:39:08 <dankna> but they're definitely not the same thing, I don't have to think too hard to realize that
19:39:59 <Cale> My algebraic topology prof had a nice term for what most mathematicians are aiming for when writing: "rigourisable".
19:40:16 <dankna> hahaha, nice
19:40:33 <Cale> That is, a competent mathematician should be able to turn it into something a computer could check, but nobody communicates that way.
19:51:04 <zoheb> I have asked this question before, but I think I didn't phrase it correctly, the question is purely academic, Is it possible to define a function readIntFromCachedFile ::IO(Int) which reads an Int from a "hard coded" file from disk the first time it is called and returns the cached value in later calls without using unSafePerformIO
19:53:43 <sjanssen> zoheb: no
19:54:12 <zoheb> thx sjanssen
19:54:23 <Cale> zoheb: However, it is possible to do it as an IO (IO Int)
19:54:57 <Cale> Where the result is an action which reads the file the first time, and returns the cached version thereafter.
19:55:15 <zoheb> Interesting
19:55:26 <zoheb> I did not think of that
19:57:36 <roconnor> @bot
19:57:36 <lambdabot> :)
19:57:36 <lunabot>  :)
19:58:16 <zoheb> How would you define this fn?
20:00:14 <zoheb> We would need to record the value somewhere in a state monad, and then make the state monad disappear from the signature later?
20:01:35 <FunctorSalad> I think you'd make an IORef or something in the outer IO
20:02:03 <hzap> readFileCached = do { cache <- newIORef Nothing; return (readIORef cache >>= \x -> case x of Nothing -> read-the-file; Just x -> return x) }
20:02:23 <FunctorSalad> do { r <- newIORef Nothing; return (action r) }; action r = ... if r is Nothing, read from disk and cache in r ...
20:02:28 <FunctorSalad> :D
20:04:18 <zoheb> what wold the type of the fn be? looks like it can be IO(Int)
20:08:28 <monochrom> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2951#a2951
20:08:47 <monochrom> readIntAndCache :: IO Int
20:09:08 <shapr> Does anyone have examples of attoparsec usage? Google doesn't turn up much.
20:09:13 <_nickel> anyone know where I can buy "the algebra of programming"
20:09:24 <monochrom> Oh haha there is a syntax error. I forgot a parameter to setEnv.
20:09:26 <_nickel> it was recommended last night and I can't find it save for 300 dollars on amazon
20:09:46 <camior> shapr: have you tried taking a look at the parsec documentation and seeing where it overlaps?
20:10:12 <camior> _nickel: I wonder if they guy who recommended it is the one selling it for $300.
20:10:22 <_nickel> :D
20:10:28 <shapr> _nickel: Sadly, that sometimes happens with good books recommended on #haskell .. for example "The Art of Science and Engineering : Learning to Learn" by Richard Hamming is one of my all time favorite books... and I was soo lucky to get it for $120
20:10:50 <_nickel> dollar per page is to steep right now
20:10:54 <_nickel> :P
20:10:58 <_nickel> *too
20:11:09 <camior> _nickel: Have you tried a library?
20:11:21 <zoheb> Thanks everybody
20:11:25 <monochrom> Look for papers on Richard Bird's website for now.
20:11:28 <shapr> I just checked Amazon, "The Art of Doing Science and Engineering" is going for $1200 now.
20:11:45 <jeffwheeler> I'm trying to make a simple DSL for sparql, which is similar to SQL for querying RDF documents. I'm looking at some haskelldb stuff, but the first presentation listed on the site appears to be _very_ old . . .
20:11:57 <jeffwheeler> What modern examples are out there for SQL DSLs?
20:12:01 <_nickel> camior: haven't sadly, there isn't a library I can go to without a lot of trouble
20:12:06 <monochrom> Plus you don't actually know whether you are ready to read Bird's book. The papers will tell you.
20:12:06 <shapr> HaskellDB is still good stuff.
20:12:17 <_nickel> camior: but I will since I'm not willing to spend 300
20:12:31 <jeffwheeler> shapr: hmm, then I guess I'll look for some more modern documentation
20:12:31 <shapr> I'd like to try Oleg's iteratee stuff though.
20:12:41 <shapr> jeffwheeler: Have you tried HaskellDB?
20:12:48 <shapr> You can still get suppor from the mailing list.
20:12:55 <_nickel> monochrom: thanks
20:12:55 <jeffwheeler> shapr: I'm not trying to use anything, I just want to look at examples of the DSL :)
20:13:02 <shapr> HaskellDB is sort of like Linq To SQL, but way neater.
20:13:03 <shapr> Oh
20:13:08 <shapr> In that case, you can just grab the source.
20:13:19 <shapr> From what I remember, it's straight up set theory.
20:13:22 <shapr> projections and all that.
20:13:23 <camior> _nickel: I found that my university's collection was on inter-library loan and I'm currently reading a print of "Denotational Semantics" by David Schmidt. It's a real gem.
20:13:25 <jeffwheeler> shapr: I want to build something similar for sparql, which is close to SQL
20:13:44 <jeffwheeler> And I have a feeling I'm quickly going in over my head, haha
20:13:53 <shapr> What better way to learn lots of new stuff?
20:13:59 <jeffwheeler> Indeed
20:14:31 <_nickel> camior: I'm sadly way behind on the maths behind programming. I was starting to feel like I should take the time to learn some of it, which is how I ended up here last night asking about reading material
20:15:50 <monochrom> _nickel: http://www.comlab.ox.ac.uk/people/publications/date/Richard.Bird.html has lots of his paper doing similar stuff as the book.
20:16:05 <_nickel> awesome
20:16:36 <_nickel> any recommendation on where to start as most of it looks like greek
20:16:52 <shapr> start asking here
20:16:59 <shapr> Do you know what a fold is?
20:17:14 <monochrom> Solving Optimisation Problems with Catamorphisms  maybe
20:17:22 <FunctorSalad> :o
20:17:37 <monochrom> Or just go from oldest to newest.
20:18:23 <_nickel> yes shapr
20:19:00 <shapr> Do you know the crazy symbols like the plus inside a circle that people use to represent a fold?
20:19:04 <shapr> Not that I do, mind you...
20:19:13 <_nickel> no
20:19:40 <shapr> Based on that tiny questionarre, I suspect you have the knowledge, and you just need to learn the funny squiggols.
20:20:12 <shapr> I tend to start with an online paper, and then ask about a specific symbol on a specific page here on #haskell
20:20:24 <Gracenotes> oh no, linguistics has been picking up their own cothings! http://en.wikipedia.org/wiki/Coverb
20:20:30 <shapr> and then ask where I can learn the rest of the symbols in that paper, perhaps a specific branch of math mentioned on wikipedia?
20:20:35 <monochrom> The oldest paper that also provides a pdf is From Dynamic Programming to Greedy Algorithms. Probably good place to start.
20:20:38 <Gracenotes> next thing you know we'll have conouns, coadjectives, and cosentences!
20:20:46 <shapr> Gracenotes: I wear cothings
20:21:02 <idnar> cothinges?
20:21:30 <shapr> I think that's used to fasten together parts of a cot.
20:21:30 <_nickel> shapr, monochrom: many thanks
20:21:37 <shapr> _nickel: Got any specific questions?
20:22:47 <FunctorSalad> Gracenotes: I don't get that intro text :(
20:28:16 <_nickel> shapr: nothing yet, surprisingly I'm able to follow about 60% of that first paper
20:28:25 <_nickel> well
20:28:30 <_nickel> 40%
20:34:28 <sjanssen> @botsnack
20:34:28 <lunabot>  :)
20:34:41 <lambdabot> :)
20:35:39 <dankna> @botsnack
20:35:40 <lambdabot> :)
20:35:40 <lunabot>  :)
20:35:42 <dankna> haha
20:38:14 <jimmyjazz14> anyone know if it is possible to write python libraries in Haskell?
20:38:49 <jimmyjazz14> or is it possible to write python binding for Haskell code?
20:39:02 <eck> jimmyjazz14: there would probably be a lot of tough gc issues to work out
20:39:03 <QPlaty[HireMe]> Would depend on python's FFI.
20:40:37 <gwern> doesn't goerzen have an interop lib?
20:41:14 <camior> jimmyjazz14: Having seen the C++ python binding and the FFI, I don't see any reason why that wouldn't be possible. You may have some difficulty moving lazy data structures between them, but if you're mostly strict you'd be okay.
20:44:09 <monochrom> I missed the @botsnack moments.
20:44:44 <jimmyjazz14> I never written any binding for python so I'm not really sure where to start
20:46:02 <camior> jimmyjazz14: Try making a function C function get called from within python.
20:46:21 <camior> jimmyjazz14: And then try to make a C program that calls a haskell function.
20:46:26 <camior> That should get you started.
20:46:51 <camior> Or you could look for the interop lib mentioned above.
20:47:38 <camior> @seen Beelsebob
20:47:39 <lambdabot> Beelsebob is in #haskell-blah, #haskell, #macosxdev and #macosx. I last heard Beelsebob speak 11h 30m 11s ago.
20:53:48 * monochrom contemplates another "persistent hack" using fifo's.
20:54:48 <monochrom> No, don't do fifo yet. The current hack using environment variables need optimization.
20:56:24 <monochrom> Hmm, Ptr is Show but not Read.
21:00:41 <lispy> cabal problem here
21:00:53 <kniu> I don't know where else to ask this question, so here it is.
21:00:57 <monochrom> IORef cannot be easily encoded as a string.
21:01:02 <lispy> I'm noticing that cabal install fails, but it doesn't give an error, in a second I can paste my log
21:01:10 <kniu> Is an infinite tower of types, kinds, sorts, etc.
21:01:14 <kniu> useful at all?
21:01:20 <monochrom> I guess the environment will have to do.
21:01:33 <lispy> kniu: this sounds like something that would be an a sigfpe blog
21:02:06 <monochrom> As useful as infinite memory.
21:02:14 <monochrom> infinite time too.
21:02:33 <kniu> well then.
21:02:37 <kniu> what is it used for?
21:02:57 <kniu> I know that "pure type systems", whatever they are, actually implement these.
21:03:28 <monochrom> No one uses all infinitely many levels. But you will be glad you didn't hardcode an upper limit.
21:03:53 <WebWalker3D> Anyone here do Visual Basic 2008?
21:05:16 <kniu> Kind of a strange question to ask.
21:05:20 <aavogt> @quote basic
21:05:20 <lambdabot> Pseudonym says: For some reason, I'm having trouble reconciling basic with "good API design".
21:05:28 <aavogt> @quote visual
21:05:29 <lambdabot> syntaxfree says: Functional programming has finally arrived to the masses. Its name is not Lisp, ML or Haskell: it's Visual Basic
21:05:42 <monochrom> My old Casio calculator hardcodes limits of: 6 levels of parenthesizing, 7 state variables, 2 programs, total 28 bytes for those 2 programs.
21:05:44 <WebWalker3D> I'm just not sure if I'm in the right channel
21:06:11 <kniu> You don't seem to be,
21:06:17 <monochrom> You see that after a while of using it, you will find those limits limiting.
21:06:19 <kniu> but there doesn't seem to be a visualbasic channel either.
21:06:45 <_nickel> I do for a living WebWalker, well actually .NET with C# but you are in the wrong channel
21:06:48 <monochrom> The same can be said if you limit your type system to 6 levels of types. You will want the 7th level one day.
21:07:09 <kniu> oy.
21:07:19 <lispy> I need help with this cabal error: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6598#a6598
21:07:22 <monochrom> It is more like "it is useless to pose an arbitrary limit" than "it is useful to make it infinite".
21:07:55 <aavogt> stack size limits?
21:13:39 <troutwine> Hello, all. I'm serializing Data.Binary instances into a postgres database with HDBC, or at least trying to. Only "" is written in.
21:14:09 <kniu> From wikipedia:
21:14:16 <kniu> "Roorda has discussed the application of pure type systems to functional programming; and Roorda and Jeuring have proposed a programming language based on pure type systems.[3]"
21:14:23 <kniu> oh boy.
21:14:28 <troutwine> Is there an obvious edge case to doing this that I'm missing, or should I prepare a haskell-cafe message?
21:15:02 <lispy> troutwine: well, are you somehow encoding the binary stream?
21:15:10 <lispy> troutwine: like base64 encoding?
21:15:15 <lispy> or hex?
21:15:42 <FunctorSalad> kniu: in coq you have Type(i):Type(i+1)... seems kinda similar to what you're asking?
21:16:00 <troutwine> lispy: Yep. I'm using Data.Binary's encode to the instance into ByteString and storing it in a base64 text field.
21:16:04 <kniu> FunctorSalad, exactly what I'm referring to.
21:16:30 <lispy> troutwine: I have no idea if what you're doing is problematic, but suppose you write out the byte 0, then would sql treat that as null?
21:16:36 <FunctorSalad> also makes me think of infinity-categories, but I don't pretend to understand them properly at all ;)
21:17:03 <kniu> now excuse me while I try to digest this research paper to see exactly how PTSs are useful.
21:17:13 <kniu> http://www.cs.chalmers.se/~jwr/pure/pts4fp.ps
21:17:20 <lispy> troutwine: have you done a sanity check of printing the string to screen or file to see if it looks okay?
21:18:12 <troutwine> lispy: It shouldn't, postgres should be escaping it, though I'm not the best domain expert. Also, yes I have and it does.
21:18:14 <lispy> What does it mean when ghc returns a 9?
21:18:18 <monochrom> Coq can't pose a limit because it doesn't know what you use it for. It can't just say "3 ought to be enough for everybody". That would be silly.
21:18:23 <lispy>  /home/dagit/bin/ghc returned ExitFailure 9
21:19:03 <monochrom> Haskell98 Report uses just 2 because it's specific. It has only one purpose and the purpose needs just 2.
21:19:10 <lispy> troutwine: okay, what about the string '111111' can you write that to the same field as a test?
21:20:48 <kniu> monochrom, I understand that.
21:20:56 <kniu> According to TaPL,
21:21:41 <kniu> "For programming languages, however, three levels have proved sufficient."
21:22:16 <monochrom> That's cool.
21:22:49 <monochrom> note that "have proved" means statistically and historically observed.
21:23:05 <FunctorSalad> three including values?
21:23:11 <FunctorSalad> (as in haskell)
21:23:49 <kniu> values, types, kinds
21:24:28 <Twey> 05:16:11 < troutwine> lispy: Yep. I'm using Data.Binary's encode to the instance into ByteString and storing it in a base64 text  field.
21:24:35 <Twey> troutwine: Not the right way to go...
21:24:45 <Twey> Consider using your database's binary type
21:28:22 <monochrom> If it's accessible through a Haskell binding.
21:33:19 <troutwine> Twey: Unless I misread the documentation, text is a bytea is an infinite varchar.
21:33:40 <troutwine> bytea being Postgres' binary type.
21:34:15 <troutwine> lispy: Sorry for the delay. Yes, I can write "111111" into the same field, any string literal I've tested will do.
21:34:31 <Twey> Essentially, yes, but a binary field should give you a more binary-friendly interface (e.g. a Handle) and thereby avoid the substantial overhead of base64-encoding a large amount of data
21:35:28 <Twey> If it's not accessible through a Haskell binding, we have some serious issues to work through in terms of database support
21:35:43 <troutwine> Twey: I'm not base64-encoding on the client end. Postgres, via plpgsql, is doing that for me. Unless I'm terrifically mistaken.
21:35:44 <Twey> But from what I've heard of Takusen and the like, that's not the case
21:36:05 <Twey> troutwine: I was thinking more of storage overhead
21:36:35 <troutwine> I _thought_, reading HDBC's documentation, that pushing in a ByteString and toSql'ing it was the correct operation.
21:38:32 <troutwine> Twey: I don't quite follow, then.
21:42:22 <thoughtpolice> woot!
21:42:28 <thoughtpolice> vacuum-opengl == win
21:43:02 <lispy> thoughtpolice: vacuum?
21:43:20 <FunctorSalad> cool. the cairo version is crashy for me
21:44:34 <ManateeLazyCat> Can someone give me an example of `adjust` in Data.Sequence? Thanks!
21:45:38 <lispy> :t adjust
21:45:42 <lambdabot> Not in scope: `adjust'
21:45:46 <lispy> ?hoogle adjust
21:45:47 <lambdabot> Data.IntMap adjust :: (a -> a) -> Key -> IntMap a -> IntMap a
21:45:47 <lambdabot> Data.Map adjust :: Ord k => (a -> a) -> k -> Map k a -> Map k a
21:45:47 <lambdabot> Data.Sequence adjust :: (a -> a) -> Int -> Seq a -> Seq a
21:45:51 <FunctorSalad> apparently it changes the element at the given position
21:46:18 <lispy> ?hoogle mkSeq
21:46:18 <lambdabot> No results found
21:46:30 <lispy> if I had a sequence I would show you an example
21:46:34 <thoughtpolice> @hackage vacuum
21:46:34 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/vacuum
21:46:36 <ManateeLazyCat> FunctorSalad: I can't understand why use (a -> a), how to use it?
21:46:37 <thoughtpolice> lispy: ^^
21:46:44 <thoughtpolice> lispy: it's a real awesome package :)
21:47:01 <thoughtpolice> FunctorSalad: yeah vacuum-opengl works really well here
21:47:10 <thoughtpolice> i never managed to get vacuum-cairo working
21:47:13 <lispy> :t (+1) -- look at this type
21:47:14 <lambdabot> forall a. (Num a) => a -> a
21:47:33 <roconnor> @type adjust
21:47:35 <lambdabot> Not in scope: `adjust'
21:48:01 <lispy> ManateeLazyCat: so imagine if you had a Seq Integer, you could do adjust (+1) n mySeq, and it would add 1 to the value at n
21:48:27 <ManateeLazyCat> lispy: I see.
21:49:13 <ManateeLazyCat> lispy: `update` function for replace new value, `adjust` use other function modified value
21:49:48 <lispy> ?hoogle update
21:49:49 <lambdabot> Data.HashTable update :: HashTable key val -> key -> val -> IO Bool
21:49:49 <lambdabot> Data.IntMap update :: (a -> Maybe a) -> Key -> IntMap a -> IntMap a
21:49:49 <lambdabot> Data.Map update :: Ord k => (a -> Maybe a) -> k -> Map k a -> Map k a
21:49:59 <lispy> ?hoogle update Seq
21:49:59 <lambdabot> No results found
21:50:06 <ManateeLazyCat> lispy: In fact, `adjust` just apply (a -> a) with element then use replace old value
21:50:17 <ManateeLazyCat> then replace old value
21:52:30 <FunctorSalad> if it's like Data.Map.update, it's like adjust except that you may also delete the element
21:52:32 <FunctorSalad> by returning Nothing
21:52:40 <lispy> why does ghc need hundreds of megs of ram to compile stuff?
21:54:06 <thoughtpolice> lispy: ?
21:54:34 <lispy> thoughtpolice: ghc keeps getting killed by the oom killer on my system that has 600 megs of ram free
21:54:57 <lispy> I'm going to add some swap
21:55:00 <FunctorSalad> NEED MOAR
21:57:05 <lispy> GHC gets up to about 250megs itself and then ld was matching it
21:59:26 <lispy> finally
22:01:02 <FunctorSalad> thoughtpolice: eh? ;) vacuum-opengl-server: /tmpvacuum-opengl-temp.dot: openFile: permission denied (Permission denied)
22:01:22 <thoughtpolice> FunctorSalad: :(
22:01:34 <FunctorSalad> must run as root, lol
22:01:36 <thoughtpolice> at least the problem is obvious :>
22:01:49 <thoughtpolice> "/tmpvacuum-opengl-temp.dot" <-- ?
22:01:59 <thoughtpolice> needs a (</>) in there
22:02:05 <FunctorSalad> yes
22:02:28 <FunctorSalad> I agree, the error message is much better than "catastrophic failure" or some such
22:03:17 <thoughtpolice> "vacuum-opengl-server: error: EPIC FAIL LOL"
22:05:07 <FunctorSalad> ./System/Vacuum/OpenGL/Server.hs:  let dot = tmp ++ "vacuum-opengl-temp.dot"
22:05:15 <FunctorSalad> that should be it
22:05:45 <thoughtpolice> looks like it.
22:06:04 <thoughtpolice> things like this are the reason i love filepath :)
22:14:01 <FunctorSalad> what do all the numbers mean in vacuum?
22:14:34 <FunctorSalad> btw this should be 3d
22:14:57 <FunctorSalad> actually I could retrofit my unfinished commutative diagram viewer, maybe ;)
22:24:19 <mgsloan> doing cabal install memotrie, I'm getting:
22:24:19 <mgsloan> src/Data/MemoTrie.hs:
22:24:19 <mgsloan>     unknown flags in  {-# OPTIONS #-} pragma: -fenable-rewrite-rules
22:24:35 <mgsloan> I have ghci 6.8.2
22:28:46 <sjanssen> mgsloan: I don't think memotrie is supposed to work with 6.8
22:29:28 <mgsloan> hrmm
22:30:02 <mgsloan> I suppose I'll upgrade then
22:30:44 <monochrom> Bwhahahahahahaha I got a more clever "persistent hack" working!
22:33:42 <monochrom> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2951#a2952  No unsafeWhatever, no environment variable either!
22:36:10 <monochrom> readIntAndCache :: IO Int  does this: the first call it reads a number from a file and caches it in memory. Subsequent calls it doesn't read the file, just reuses cached value.
22:37:30 <dancor> what's the signal all about
22:37:39 <QPlaty[HireMe]> @dijin x -> x -> [x]
22:37:40 <lambdabot> Error: Undefined type []
22:38:07 <dancor> omg
22:38:15 <monochrom> The signal is all about backdoor!
22:38:20 <monochrom> hahahahahaha
22:38:20 <dancor> so you can use this technique for up to two vars
22:38:24 <dancor> ::vomit::
22:38:30 <dancor> ;)
22:38:45 <monochrom> All you need is one var that points to more vars.
22:39:00 <dancor> globals beget globals
22:39:23 <monochrom> hahahahahahahaha I'm really proud of this!  Much better than getting a date!
22:43:27 * sjanssen knew when he saw that question earlier some crazy bastard would actually do it
22:43:47 <monochrom> hahahahahaha
22:45:16 <__marius__> how can i pattern matching on a string in haskell without doing it element-wise char?  (i.e. instead of doing ``let y ('f':('o':x)) = x'', i'd love to be able to do something similar to ``let y "fo" ++ x = x'')
22:46:14 <monochrom> Unfortunately cannot.
22:46:15 <sjanssen> monochrom: that's not very modular, though
22:46:29 <monochrom> Right.
22:46:37 <dibblego> let y k | "fo" `isPrefixOf` k = x''
22:47:09 <monochrom> It doesn't work if I don't know which thread will use readIntAndCache. It doesn't work if other things too.
22:48:50 <sjanssen> monochrom: there's a way to do it modularly using two signals
22:49:03 <__marius__> dibblego: yeah, was hoping to be able to do it without guards, just since it's more succint.. but i guess that's going to have to be it.. thanks
22:49:29 <dibblego> __marius__, what is more succint exactly? how can something that is not possible be more succint?
22:49:40 <sjanssen> hmm, maybe not
22:50:06 <__marius__> dibblego: right, i'm saying i was hoping there was such a possibility ;-)
22:51:15 <sjanssen> monochrom: look at the docs for installHandler "The previously installed signal handler for int is returned"
22:51:41 <monochrom> Great minds think alike! I'm just thinking over that.
22:53:11 <Twey> __marius__: let y (splitAt 2 -> ("fo", x)) = x -- view patterns
22:54:44 <monochrom> Enough hacking for today. Later.
22:56:26 <__marius__> Twey: ooh, interesting.
23:02:41 <Twey> __marius__: They're powerful, but kind of verbose.  *shrug*
23:03:21 <Twey> Hmm... do where clauses scope to view patterns?
23:05:36 <Heffalump> I'd have assumed they do, but I've never checked
23:06:07 <Heffalump> oh, actually, probably not, because the things bound in the pattern itself are in scope in a where
23:11:22 <jeffwheeler> Alright, I've spent some time trying to design a DSL for a SQL-like language (SPARQL), and I would love some feedback on what I've come up with.
23:11:22 <jeffwheeler> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6603#a6603
23:11:59 <jeffwheeler> Essentially, the 'triple's are the meat of the language, because they form the WHERE restrictions.
23:12:23 <jeffwheeler> It needs to be somewhat recursive, though, and that's where it gets tricky. I'm not sure the design I have for 'optional' is even possible.
23:12:50 <jeffwheeler> (Here's the language specification, by the way: http://www.w3.org/TR/rdf-sparql-query/)
23:14:01 <coCocoa> Does anyone on have GLFW working on a Windows system?
23:14:21 <jeffwheeler> Sorry, I suspect that's a bit too much to ask. I guess a simpler question is whether a 'return' would be necessary in a recursive DSL like that?
23:14:34 <jeffwheeler> I fear that the o
23:14:35 <jeffwheeler> err
23:14:45 <jeffwheeler> I fear the 'optional' syntax isn't possible . . . :(
23:17:02 <quicksilver> PeakerWork: in a word, "No" ;)
23:21:26 <Twey> 07:06:18 < Heffalump> oh, actually, probably not, because the things bound in the pattern itself are in scope in a where
23:21:38 <Twey> Heffalump: And we suddenly have a problem with recursive definitions?  :-P
23:22:55 <Twey> o.@
23:23:00 <Beelsebob> camior: you pang?
23:23:35 <Twey> Prelude> let ((*2) -> x) = x
23:23:39 <Twey> â€” this is apparently valid
23:23:47 <Twey> Prelude> let f ((*2) -> x) = x
23:23:51 <Twey> â€” but this overlaps
23:24:12 <Beelsebob> Twey: what does it mean though?
23:24:19 <Twey> That's my question :-P
23:24:25 <Beelsebob> lol
23:24:36 <Twey> And it doesn't define ->
23:24:45 <Twey> I checked â€” still a syntax error
23:24:48 <Beelsebob> oh
23:24:50 <Beelsebob> it's a view pattern
23:24:54 <Twey> Yes
23:24:54 <Beelsebob> and you have them enabled
23:24:59 <Twey> But it's nameless
23:25:02 <Twey> Nameless!
23:25:06 <Beelsebob> yeh
23:25:21 <Beelsebob> but I couldn't even figure out what it was meant to be until ghci moaned at me
23:25:22 <Beelsebob> :P
23:25:25 <Twey> Oh :-P
23:26:47 <dons> http://projects.haskell.org/ghc-iphone/
23:28:39 <dankna> dons: !
23:28:42 <dankna> pleasing
23:29:34 <Twey> .i'e
23:36:46 <dsturnbull> dons: finally, a url :)
23:37:24 <sjanssen> dons: the license is really weird
23:37:30 <mmorrow> here's a fairly clear and direct implem of the cheney GC algo (in haskell), if anyone is into that kind of thing http://moonpatio.com/repos/Cheney.hs
23:38:07 <Twey> Named after Dick?
23:38:17 <mmorrow> Twey: precisely
23:38:30 <Twey> Nice
23:38:41 <mmorrow> totally :)
23:38:42 * Twey looks for explosions
23:39:15 <mmorrow> Twey: i added a gratuitous error "Segmenatation fault" as a nod to C..
23:39:19 <sjanssen> mmorrow: you keep talking about interesting projects like linkeres and GCs, what are you up to?
23:39:29 * Twey grins.
23:39:35 <mmorrow> sjanssen: i'm writing linkers and GCs :)
23:39:43 <Twey> segfault = error "Segmentation fault"
23:39:44 <Twey> -- segfault = peek nullPtr -- ;)
23:40:02 <mmorrow> sjanssen: i'm trying to finish up this interpreter that i've been working on for the past couple months
23:40:20 <mmorrow> sjanssen: getting verrry close
23:40:20 * bremner can't be bothered with weird licenses. Life is too short.
23:41:32 <mmorrow> sjanssen: here's the linker code that i've been messing with the last few days trying to grok the process http://moonpatio.com/repos/lem-ld/
23:42:20 <mmorrow> (it "works" for a few reloc type (on x86_64 atm), but it's not doing a lot of things it should)
23:43:04 <mmorrow> (for instance, it just mmaps the entire file PROT_EXEC|PROT_READ|PROT_WRITE, disregarding the flags they should have, and mapping in all the stuff that's not  even supposed  to be alloc)
23:44:23 <mmorrow> (the hard part if figuring out the spiderweb relations in the elf format, well for me at least since i'd had to real exposure to linker stuff until i started reading the elf spec..)
23:44:28 <mmorrow> s/if/is/
23:44:40 <mmorrow> *i'd had no real ...
23:44:46 * mmorrow crashes
23:44:49 <mmorrow> night!
23:45:54 * jeffwheeler just got a good scare out of finding my own comments in RWH
23:46:13 <jeffwheeler> . . . from last December; how was I supposed to remember!
23:46:19 <idnar> haha
23:47:07 <Twey> Haha
23:47:36 <coCocoa> > let farey o = [x%y | y<- [1..o],x <- [0..pred y], gcd x y == 1] in farey 0
23:47:40 <lambdabot>   []
23:47:47 <coCocoa> > let farey o = [x%y | y<- [1..o],x <- [0..pred y], gcd x y == 1] in farey 8
23:47:48 <lambdabot>   [0 % 1,1 % 2,1 % 3,2 % 3,1 % 4,3 % 4,1 % 5,2 % 5,3 % 5,4 % 5,1 % 6,5 % 6,1 ...
23:48:02 <coCocoa> That'll work. :)
23:48:04 <jeffwheeler> @more
23:49:16 <coCocoa> mmorrow: Does it GC with multiple "undisclosed locations"? ;)
