00:00:08 <mjrosenb> Preprocessing library hpc-0.5.0.2...
00:00:08 <mjrosenb> cabal-bin: The program hsc2hs is required but it could not be found
00:00:16 <mjrosenb> I DO NOT NEED HPC
00:00:30 <mjrosenb> STOP TRYING TO BUILD IT
00:00:41 <mmorrow> mjrosenb: what system are you bootstrapping on?
00:01:23 <mjrosenb> mmorrow: ppc64-linux
00:01:49 <mmorrow> err, i was thinking for a minute maybe there'd be a way to blah blah that lead nowhere
00:02:10 <mmorrow> mjrosenb: i guess root through the build system
00:02:54 <jdrake> Is there such a thing where mapM :: Monad m => (a -> m b) -> [a] -> m [b]   can be done with an m [a] type?
00:03:08 <soupdragon> ??
00:03:23 <mmorrow> @type \f -> (mapM f =<<)
00:03:25 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m [a] -> m [b]
00:03:25 <soupdragon> You meant  (a -> m b) -> m [a] -> m [b]  ??
00:03:26 <mjrosenb> jdrake: l >>= mapM f
00:03:30 <jdrake> I have an IO [Bool] that I want to convert to IO [Char] but I can't figure out how to do it
00:03:46 <mjrosenb> jdrake: you can always use do
00:04:02 <jdrake> I have tried do, but not sure the best way to make use of it here
00:04:04 <mjrosenb> do l <- readBools; mapM foobar l
00:04:23 <mjrosenb> so you have l :: [Bool]
00:04:38 <jdrake> What I have is this: binaryGene m = 	mapM (\x -> return (if (x == True) then '1' else '0')) m        where m is IO [Bool]
00:04:39 * mjrosenb tries ripping out the hpc directory
00:04:45 * mjrosenb waits for it to go boom
00:04:46 <Cale> jdrake: How exactly? Mapping False to '0' and True to '1'?
00:04:56 <jdrake> Cale: quite
00:05:08 <jdrake> soupdragon: yes
00:05:09 <Cale> jdrake: fmap (\x -> if x then '1' else '0')
00:05:14 <Cale> :t fmap (\x -> if x then '1' else '0')
00:05:15 <lambdabot> forall (f :: * -> *). (Functor f) => f Bool -> f Char
00:05:35 <Cale> :t fmap (map (\x -> if x then '1' else '0'))
00:05:36 <lambdabot> forall (f :: * -> *). (Functor f) => f [Bool] -> f [Char]
00:06:14 <jdrake> What precisely does fmap do?
00:06:41 <Cale> Depends on the given functor, but generally, applies a function to every value in a datastructure, or to the result of a computation.
00:06:51 <Cale> :t fmap
00:06:52 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
00:06:55 <Cale> :t map
00:06:56 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
00:07:04 <Cale> It's like map, but generalised :)
00:07:27 <Cale> In any monad, including IO, it's the same thing as  fmap f x = do v <- x; return (f v)
00:08:03 <kamysh> @pl map snd $ filter fst $ zip
00:08:04 <lambdabot> map snd (filter fst zip)
00:09:18 <jdrake> sweet
00:09:39 <Cale> :t ((map snd . filter fst) .) . zip
00:09:40 <kamysh> @pl map snd $ filter fst $ zip lst1 lst2
00:09:41 <lambdabot> forall b. [Bool] -> [b] -> [b]
00:09:41 <lambdabot> map snd (filter fst (zip lst1 lst2))
00:10:02 <Cale> @pl \lst1 lst2 -> map snd . filter fst $ zip lst1 lst2
00:10:02 <lambdabot> ((map snd . filter fst) .) . zip
00:10:31 <jdrake> I am not sure I understand the fmap magic yet, but it is late
00:10:44 <Cale> > fmap (*10) [1,2,3]
00:10:46 <lambdabot>   [10,20,30]
00:10:49 <Cale> > fmap (*10) (Just 5)
00:10:51 <lambdabot>   Just 50
00:10:57 <soupdragon> (a -> b) -> (m a -> m b)
00:11:02 <mmorrow> @type \f m -> join (fmap f m)
00:11:04 <lambdabot> forall a (m :: * -> *) a1. (Functor m, Monad m) => (a -> m a1) -> m a -> m a1
00:11:13 <jdrake> The IO still seems like magic stuff
00:11:21 <soupdragon> fmap (+1) (return 3) = return 4
00:11:30 <mmorrow> @type \f m -> join (fmap f m) :: (a -> IO b) -> IO a -> IO b
00:11:32 <lambdabot>     Inferred type is less polymorphic than expected
00:11:32 <lambdabot>       Quantified type variable `b' is mentioned in the environment:
00:11:32 <lambdabot>         m :: (a -> IO b) -> a1 (bound at <interactive>:1:3)
00:11:41 <soupdragon> fmap (+1) (print "hi" >> return 3) = print "hi" >> return 4
00:11:41 <mjrosenb> jdrake: it's just a monad
00:11:54 <mjrosenb> jdrake: get more comfortable with monads, and the IO stuff will come
00:11:56 <Cale> jdrake: I'm about to go to sleep, but if you're still confused tomorrow, ping me about it and I'll explain.
00:12:02 <jdrake> I am a monad.
00:12:08 <jdrake> Cale, merci
00:12:36 <jdrake> @src fmap
00:12:36 <lambdabot> Source not found. My mind is going. I can feel it.
00:13:32 <mjrosenb> fmap f = (>>=f)
00:13:37 <mjrosenb> i *think*
00:13:49 <jdrake> :t (>>=)
00:13:51 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
00:13:59 <mjrosenb> nope
00:14:24 <jdrake> You know I almost got the monad stuff last time I did haskell. I have to look again. But that is for tomorrow at best.
00:14:34 * mjrosenb thinks about that again
00:15:12 <mmorrow> fmap f = (return . f =<<)
00:15:50 <mjrosenb> :t (=<<)
00:15:51 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
00:16:11 <jdrake> @src return
00:16:12 <lambdabot> Source not found. Wrong!  You cheating scum!
00:16:13 <mjrosenb> mmorrow: that does not have functor in the signature
00:16:25 <mjrosenb> jdrake: return is defined on a per-monad basis
00:16:26 <mmorrow> s/fmap/liftM/
00:16:44 <mjrosenb> jdrake: it is different for each one
00:16:55 <mmorrow> @type [fmap,liftM,(<$>)]
00:16:55 <jdrake> mjrosenb: just trying for the hell of it
00:16:57 <lambdabot> forall a b (f :: * -> *). (Functor f, Monad f) => [(a -> b) -> f a -> f b]
00:18:17 <mmorrow> @type [(>>=),((join.).flip fmap),(flip((join.).fmap))]
00:18:18 <lambdabot> forall (m :: * -> *) a a1. (Monad m, Functor m) => [m a1 -> (a1 -> m a) -> m a]
00:18:47 <mmorrow> @type [(=<<),(join .) . fmap]
00:18:49 <lambdabot> forall (m :: * -> *) a a1. (Monad m, Functor m) => [(a1 -> m a) -> m a1 -> m a]
00:21:09 <mmorrow> f =<< m = join (liftM f m) = join (fmap f m) = join (f <$> m)
00:21:20 <ray> @src [] return
00:21:20 <lambdabot> return x    = [x]
00:21:24 <mmorrow> where the "fmap" assumes the monad has a Functor instance (which is trivial)
00:21:26 <ray> lambdabot can do stuff like that
00:21:32 <mmorrow> and the "<$>" assumes an Applicative instance
00:21:38 <ray> also trivial
00:21:43 <mmorrow> instance (Monad m) => Functor m where fmap = liftM
00:21:47 <dobblego> @type (<$>)
00:21:49 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
00:21:59 <mmorrow> instance (Monad m) => Applicative m where pure = return; (<*>) = ap
00:22:39 <mmorrow> @src (<$>)
00:22:39 <lambdabot> f <$> a = fmap f a
00:23:23 <ray> should be pointless
00:23:32 <mmorrow> @. pl src (<$>)
00:23:33 <lambdabot> (line 1, column 1):
00:23:33 <lambdabot> unexpected end of input
00:23:33 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
00:23:36 <mmorrow> aww
00:24:22 <ray> some of the other definitions in Control.Applicative are pointless
00:25:18 <mjrosenb> what exactly is applicitive used for?
00:25:46 <erikc> hrm, would a haskell debugger stop on thunk creation or thunk forcing, or both?
00:25:48 <ray> well, have you ever wished you could fmap functions with 2 or more arguments?
00:25:56 <ray> you can, with Applicative!
00:27:17 <ManateeLazyCat> Hi all, i'm developing editor, so i need every page in editor have an unique name, example have page named C, then i add new page, it's filename is also C, then i need change first C file to /A_Directory/C, change second C file to /B_Directory/C for unique page name. So my question, have an exist algorithm fix this problem?
00:32:57 <ManateeLazyCat> An element in list is a file-path, and every element is unique, now i need algorithm transform list, if found two element have same file name, add previous level directory to the front, until all elements are unique, example List ["/A/B/D", "A/C/D", "/E/F", "/G/H"] change to ["/B/D", "/C/D", "F", "H"]
00:35:32 <mjrosenb> HAHAHAHAH, it is BUILDING
00:37:32 <mjrosenb> mmorrow: so you want to find the sortest suffix such that each element is unique?
00:37:38 <mjrosenb> err
00:37:55 <mjrosenb> ManateeLazyCat: so you want to find the shortest suffix such that each element is unique?
00:39:08 <mjrosenb> where a suffix can only be broken at the magical '/' character
00:39:34 <ManateeLazyCat> mjrosenb: Yeah,
00:40:34 <mjrosenb> actually no
00:40:55 <ManateeLazyCat> mjrosenb: My editor will named page with file's filename, but it will add previous directory name to the front if it found two page's file have same filename (those two file are different files)
00:41:11 <ManateeLazyCat> until all page's name is unique
00:41:11 <mjrosenb> because in that example you would end up with ["D", "C/D", "F", "H"]
00:41:44 <ManateeLazyCat> mjrosenb: No, should be ["/B/D", "/C/D", "F", "H"]
00:41:50 <mjrosenb> right
00:42:02 <mjrosenb> but if you describe it as i did, then that is the answer that you get
00:42:10 <mjrosenb> but if the input is
00:43:47 <mjrosenb> ["A/B/D", "M/N/D", "Z/B/D"] what would the output be?
00:44:47 <ManateeLazyCat> ["A/B/D", "N/D", "Z/B/D"]
00:45:37 <mjrosenb> that seems to be inconsistent with your previous response
00:46:47 <ManateeLazyCat> mjrosenb: Not just add previous directory name ONCE, it will add previous directory recursive until FIRST different directory name.
00:47:45 <ManateeLazyCat> mjrosenb: In fact, this just uniquify.el.gz module in Emacs, i just want know have someone do same thing with Haskell before i implement this algorithm.
00:48:56 <mjrosenb> hrmm
00:48:57 <mjrosenb> ok
00:51:46 * ManateeLazyCat Looks haven't this algorithm exist, implement it self.....
00:52:07 <mjrosenb> huh?
00:54:00 <sinelaw> hey, 1. what's the status of Yampa?
00:54:12 <sinelaw> 2. anyone know of an E-FRP (or RT-FRP) implementation?
00:55:22 <mjrosenb> sinelaw: i don't know what either of those things are
00:55:31 <mjrosenb> i assume Ya is Yet another
00:55:54 <sinelaw> @google yampa
00:55:55 <lambdabot> http://www.haskell.org/yampa/
00:55:55 <lambdabot> Title: Yampa
01:05:24 <strathhelp> sorry to have to ask, is there a simple way to do replace, ie.         replace 0 2 [1,1,1,0,1]  would produce [1,1,1,2,1], without having to implement a length search and replace function
01:05:50 <strathhelp> lengthy*
01:06:01 <soupdragon> yes
01:06:31 <soupdragon> replaceOne 0 2 0 = 2
01:06:34 <soupdragon> replaceOne 0 2 1 = 1
01:06:36 <soupdragon> replaceOne 0 2 2 = 2
01:06:41 <soupdragon> then
01:06:43 <mjrosenb> map
01:06:51 <soupdragon> replace 0 2 = map (replaceOne 0 2)
01:07:04 <mjrosenb> or just map with a lambda and an if
01:07:14 <soupdragon> mjrosenb, nah
01:09:59 <strathhelp> soupdragon that data isn't set, that is, replace won't always deal with the same range of numbers, it could be called with any number and array data
01:10:11 <soupdragon> ok
01:10:34 <soupdragon> my suggestion isn't applicable then
01:10:34 <strathhelp> actually im working with strings but i thought id ask with ints for simplicity
01:10:50 <strathhelp> thanks anyway :]
01:10:50 <mjrosenb> *Main> unique ["a/b/c", "d/c/c", "a/c/c"]
01:10:50 <mjrosenb> ["/b/c","a/c/c","d/c/c"]
01:11:12 <mjrosenb> strathhelp: thankfully, equality is defined on both strings and ints
01:12:18 <mjrosenb> there is a sore lack of functions for splitting up lists in haskell
01:12:33 <strathhelp> i agree, coming from perl it's been a bit of an adjustment
01:12:34 <mjrosenb> a generic version of 'words' or 'lines' would be much appreciated
01:13:00 * mjrosenb does not enjoy resorting to groupBy then ignoring the first value
01:13:36 <osfameron> there's a module to do it
01:13:40 <osfameron> on hackage
01:13:57 <osfameron> or you can use the function in Text.Regex
01:14:24 <mjrosenb> osfameron: i don't want something that operates on strings
01:14:25 <osfameron> (it annoyed me too, coming from Perl... but now that there are standard ways-to-do-it, best to use those ;-)
01:14:32 <mjrosenb> osfameron: i want something that operates on lists
01:14:36 <osfameron> mjrosenb: then the hackage version should do you find
01:14:37 <hackagebot> mmap 0.4 - Memory mapped files for POSIX and Windows (GracjanPolak)
01:14:40 <osfameron> *fine
01:15:03 <osfameron> mjrosenb: google finds http://hackage.haskell.org/package/split-0.1.1
01:15:21 <osfameron> (but check hackage to see if that's the most recent one etc.)
01:16:09 <mjrosenb> so not Text.Regex.Base
01:16:18 <mjrosenb> and/or Text.Regex.Posix
01:19:17 * mjrosenb wants a function
01:19:35 <mjrosenb> splitBy :: (a->Bool) -> [a] -> [[a]]
01:19:43 <mjrosenb> @hoogle (a->Bool) -> [a] -> [[a]]
01:19:43 <lambdabot> Distribution.Simple.Utils breaks :: (a -> Bool) -> [a] -> [[a]]
01:19:44 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
01:19:44 <lambdabot> Prelude filter :: (a -> Bool) -> [a] -> [a]
01:20:24 <pozic> What is the MonadFix instance for RandT from Control.Monad.Random?
01:34:10 <mjrosenb>  /me watches ghc compiling ... again
01:35:15 * shachaf watches mjrosenb watching GHC compiling... Again.
01:43:14 <mjrosenb> /usr/bin/ld: TOC section size exceeds 64k
01:43:17 * mjrosenb cries
01:44:58 <pozic> Is it even possible to write a MonadFix instance for RandT?
01:48:36 <Saizan> pozic: isn't RandT a wrapper over StateT?
01:50:39 <pozic> Saizan: yes
01:52:14 <Saizan> StateT does have a MonadFix instance, so RandT should too
01:52:24 <Saizan> s/should/can/
01:52:46 <pozic> Saizan: You have a function taking the result of the RandT computation and returning a new RandT computation, but I don't see how to "run" the RandT computation without giving it a generator.
01:53:02 <Saizan> instance (MonadFix m) => MonadFix (StateT s m) where mfix f = StateT $ \s -> mfix $ \ ~(a, _) -> runStateT (f a) s
01:53:39 <Saizan> you've to give it the generator
01:53:48 <Saizan> just like it's giving it the state there
01:54:54 <pozic> Oh, I guess the "state", in this case the generator, is just stored somewhere else.
01:55:16 <Saizan> keep in mind that the side-effects are run only once, it's not like a loop
01:55:31 <hesselink> mjrosenb: I think the split package on hackage has the splitBy function you want.
01:56:17 <Saizan> pozic: RandT g m a = g -> m (a,g), so the generator is given to you as an argument
01:59:29 <pozic> Saizan: no, it's newtype (RandomGen g) => RandT g m a = RandT {StateT g m a}
02:00:12 <pozic> Saizan: I already wrote it by cheating a bit. I simply derived it:  mfix = derive_mfix (Iso RandT select_state)
02:00:35 <Saizan> pozic: well that = was more "is isomorphic to"
02:00:47 <Saizan> given the definition of StateT
02:02:20 <pozic> Saizan: yes, that's what I meant by "is just stored somewhere else".
02:12:47 * quicksilver wishes typeclass constrains were illegal in existentials.
02:13:37 <Saizan> quicksilver: why?
02:16:07 <mjrosenb> hey, how do i tell ghc to pass a given flag into gcc?
02:16:34 <Saizan> -optc or similar, iirc
02:17:18 <Saizan> http://www.haskell.org/ghc/docs/latest/html/users_guide/options-phases.html#forcing-options-through <- yup
02:17:51 <Saizan> (if i google flag reference google gives me ghc's one, i guess they know me well)
02:18:26 <quicksilver> Saizan: because they make people think that all existentials have to be like that, and I even see it suggested that existentials are useless without them.
02:24:15 <FunctorSalad> quicksilver: aren't they useless without unsafeCoerce... ?
02:24:22 <RayNbow> aww, redditors don't like the two links I submitted... (perhaps the focus was too much on .NET :p)
02:25:00 <FunctorSalad> you can "seq" them too I guess ;)
02:27:25 <FunctorSalad> (okay, I can see how you could put the dictionary of any typeclass into a contextless existential)
02:33:06 <quicksilver> FunctorSalad: HOFs are not "the dictionary of a typeclass"
02:33:17 <quicksilver> FunctorSalad: you can put all kinds of interesting HOFs into an existential, yes.
02:34:19 <FunctorSalad> quicksilver: hmm? I didn't mean that all HOFs are the dictionary of a typeclass (though you could make one), but that any dictionary is a bunch of HOFs
02:35:16 <quicksilver> FunctorSalad: yes. I was just objecting to "you could put the dictionary of any typeclass"
02:35:27 <quicksilver> again that makes it sound like typeclasses are somehow interesting or special.
02:35:30 <mmorrow> Saizan: ah, i just remembered something i was meaning to mention to you/dcoutts, so before i forget again.. just a random idea that i think could be interesting:
02:35:38 <quicksilver> existentials are a much more fundamental concept than typeclasses :)
02:35:57 <coco> hi, I'm trying to use equational reasoning to debug a program spread over several modules... is there a way to temporarily export all definitions of a module?
02:36:13 <quicksilver> exists a . ([a],a -> IO a,a -> IO [a])
02:36:17 <mmorrow> Saizan: so a prog that gets a filepath on stdin, which is the root of a directory tree containing a bunch of cabal pkgs
02:36:25 <FunctorSalad> quicksilver: don't typeclasses enforce that a particular set of functions is linked to a type (rather than a value)? that is special in a sense
02:36:30 <quicksilver> yes.
02:36:42 <quicksilver> I'm just trying to vociferously object to the meme that typeclasses are related to existentials
02:36:49 <quicksilver> or that existentials aren't interesting without them
02:36:52 <FunctorSalad> I see
02:37:36 <RayNbow> you know... watching this channel sometimes makes me hungry.... *blames FunctorSalad for his nick* :p
02:37:52 <FunctorSalad> :)
02:38:00 * wmealing_ chuckles
02:38:03 <RayNbow> (but then again, I haven't eaten yet)
02:38:11 <wmealing_> RayNbow, url ?
02:38:25 <RayNbow> wmealing_: hmm? you mean the two reddit submissions?
02:38:30 <wmealing_> yes.
02:39:04 <mmorrow> Saizan: then, the prog finds all the .cabals, makes sure all deps are there, toposorts/whatever, then generates a shell script that you can stick in a tarball of that script + those packages and that'll build them wherever
02:39:19 <RayNbow> wmealing_: http://www.reddit.com/r/programming/comments/917x3/2009_langnet_symposium_37_talks_video/ and http://www.reddit.com/r/programming/comments/916o4/brian_beckman_and_erik_meijer_inside_the_net_reactive_framework_rx/
02:39:25 <mmorrow> Saizan: err, actually i just tried to simplify the use-case there, but i don't like how that sounded
02:39:45 <mmorrow> Saizan: so the point being, generation of shell scripts to replicate package.confs
02:39:58 <mmorrow> *exactly* replicate
02:40:14 <Saizan> package.confs? or the whole build-system?
02:40:20 <wmealing_> RayNbow, thanks
02:40:37 <mmorrow> Saizan: i was thinking of package.confs, but sure
02:40:53 <wmealing_> RayNbow, found that submissions during different hours are accepted depending on the topic
02:41:21 <mmorrow> Saizan: ok, gotta disappear.. wanted to say that so i didn't forget again :)
02:41:33 <wmealing_> did a bit of analysis on this myself.. but the rule of thumb is.. end of day US for MS related stories.  After hours for linux / open source stories
02:41:34 <FunctorSalad> @botsnack
02:41:35 <lunabot>  :)
02:41:35 <lambdabot> :)
02:41:45 <Saizan> mmorrow: since Setup.hs scripts can contain arbitrary haskell code it's hard to compile them down to bash
02:41:49 <harlekin> @pl (\bar -> foo *> bar)
02:41:50 <lambdabot> (foo *>)
02:41:50 <RayNbow> wmealing_: I once saw a paper on that
02:41:53 <wmealing_> US redditors are grumpy in the morning and downmod everything
02:42:19 <wmealing_> RayNbow, i'd like to read it.. this was more for my personal knowledge.
02:42:35 <harlekin> @pl (\bar -> bar <* foo)
02:42:35 <lambdabot> (<* foo)
02:43:10 <RayNbow> http://www.hpl.hp.com/research/scl/papers/predictions/predictions.pdf <-- wmealing_
02:43:19 <RayNbow> it's about the popularity of stuff on YouTube and Digg
02:44:05 <hackagebot> hashed-storage 0.3.6 - Hashed file storage support code. (PetrRockai)
02:44:59 * wmealing_ often wonders how youtube stays in business
02:45:12 <RayNbow> wmealing_: by printing more dollars :p
02:45:16 <FunctorSalad> google bought them
02:45:17 <wmealing_> genius.
02:45:24 <wmealing_> even in the post google world
02:46:08 <wmealing_> on first glance, my findings look similar to theirs.
02:46:17 <wmealing_> I really wanted to do some statistics on world of warcraft
02:46:43 <wmealing_> but since there is no API or ability to program it/anyone large amount of people wanting to dump statistics
02:46:53 <wmealing_> it seems like a lost cause.
02:47:15 <wmealing_> it was going to be my first haskell project actually.
02:51:00 <wmealing_>  http://code.google.com/p/simulationcraft/ <-- something like this
02:51:01 <RayNbow> wmealing_: are you interested in a video that shows the geographic location of viewers in a P2P Webcam stream test?
02:51:20 <coco> hi, I'm trying to use equational reasoning to debug a program spread
02:51:20 <coco>        over several modules... is there a way to temporarily export all
02:51:20 <coco>        definitions of a module?
02:51:55 <mmorrow> Saizan: oh, i mean a shell script that would e.g.
02:53:23 <wmealing_> RayNbow, i think it might upset the network admin at work, but if i can check it at home... sure
02:53:27 <RayNbow> wmealing_: http://vid.shinnonoir.nl/peers_live.MP4
02:53:28 <mmorrow> Saizan: wget -i list_of_pkgs.txt && for i in $(ls *.tar.gz); do tar -xzf $i; done && <toposort and stuff> && loop over all pkgs and build + pretty docs + hoogle .txt + something else;
02:53:35 <Saizan> coco: no, except editing the export list
02:53:36 <RayNbow> it's 2.47 MB
02:53:57 <mmorrow> Saizan: or whatever, but all of that being hard-coded into an .sh that can be run at any point in the future
02:54:15 <mmorrow> to replicate that collection of packages exactly
02:54:32 <Saizan> mmorrow: could that .sh assume you've Cabal installed?
02:54:55 <Saizan> mmorrow: so that it can run runghc Setup.hs configure/build/install
02:55:10 <mmorrow> Saizan: but then you can't guarantee the exact packages (which was my use-case), but sure i think .sh generation could be useful in general as well
02:55:33 <Saizan> mmorrow: "then"?
02:55:47 <mmorrow> Saizan: oh yeah totally, what i'm doing now is going via Setup configure/build/install/haddock
02:56:07 <wmealing_> RayNbow, its not too big :) you wrote it ?
02:56:08 <mmorrow> Saizan: what did you mean by cabal install?
02:56:22 <mmorrow> Saizan: (auto-dep resolution?)
02:56:44 <mmorrow> Saizan: (i though you meant that, which is why i said "then", but you probably didn't..)
02:56:44 <Saizan> mmorrow: i said "Cabal installed" not cabal-install :)
02:56:45 <RayNbow> wmealing_: no, I didn't... researchers at TU Delft did the P2P live stream test
02:56:50 <mmorrow> Saizan: ahhh :)
02:56:52 <wmealing_> ah
02:57:21 <wmealing_> looks like some xearth screenshots and some clever geo to ip mapping.. thats kinda cool
02:57:34 <Saizan> mmorrow: so you want the result of dep. resolution among a fixed set of packages to be serialized as an executable bash script
02:59:10 <mmorrow> Saizan: well said :)
03:01:05 <Saizan> mmorrow: which could be generalized by serializing into a more declarative format that can be compiled and/or interpreted as you wish
03:01:52 <mmorrow> Saizan: sure. i think shell scripts though are very practically useful in that they can be executed as-is
03:02:09 <mmorrow> but yeah, in general too that would be interesting
03:04:01 <mmorrow> Saizan: (also, you could imagine a .sh script that gets only (curl,tar) and whose job it is to clone a complete ghc/etc setup on another machine)
03:04:20 <mmorrow> that would be soooo handy
03:04:44 <mmorrow> mkboot < package.conf > bootit.sh
03:04:59 <mmorrow> scp bootit.sh me@foo:
03:05:09 <mmorrow> ssh me@foo ...... $ ./bootit.sh
03:07:14 <Saizan> package.conf's don't have enough information though, they don't refer to the sources, and they are platform and installation specific
03:08:02 <mmorrow> Saizan: you can get [(PackageName, Version)] and derive [HackageURL] from there though
03:08:09 <mmorrow> (for all the hackage packages at least)
03:08:51 <mmorrow> also, you can extract info from the ghc on the machine you're generating the .sh, then on the target machine download the bindist or srcdist
03:09:45 <Saizan> ok, so package.conf is only a "convenient" way to pass a [(Package,Version)] ?
03:09:56 <mmorrow> essentially yes
03:10:31 <wmealing_> i saw mention of someone talking about haskell on the iphone, can it talk to the objective C classes.. or is it for console apps at the moment ?
03:11:24 <mmorrow> wmealing_: there a #haskell-iphone channel i think
03:11:43 * wmealing_ hits them up
03:12:52 <mmorrow> Saizan: and also there's this which may be useful (if anyone still uses windows anymore :)  http://darcs.haskell.org/yhc/misc/Batch.hs
03:13:28 <mmorrow> Saizan: ah, that reminds me, i think there's an sh parser/etc on hackage
03:14:48 <Saizan> mmorrow: i think you should file a feature request on Cabal's ticket, so we don't both forget :)
03:16:02 <mmorrow> Saizan: i definitely won't forget for good, since i've got some code that implements some of this already, but i don't have time to finish it atm so i keep forgetting/remembering etc, but i want to get to it when i have some time
03:16:34 <mmorrow> Saizan: i try to put it into a repo in a little bit as-is
03:16:46 <mmorrow> Saizan: i'll file a ticket too
03:17:17 <Peaker> What's the status of Epigram? How does it compare to Agda/Coq?
03:21:02 <Saizan> good question
03:21:54 <Peaker> I tried reading "Why Dependent Types Matter". Its awesome. However I had to reverse engineer a LOT of context from the text. Not sure what audience/background it expetcs
03:21:58 <Peaker> expects
03:22:35 <Peaker> I had no actual prior exposure to dependent types, but I assumed that this paper assumed that
03:23:34 <soupdragon> http://www.e-pig.org/epilogue/
03:34:16 <hackagebot> darcs-beta 2.2.98.4 - a distributed, interactive, smart revision control system (PetrRockai)
03:37:17 <Yoshibloke> Hi, I'm writing an IRC bot but I can't get the ACTION (/me) command to work, it either comes up as unrecognized or the bot just says "ACTION blah" instead
03:37:25 <soupdragon> lol
03:37:42 <soupdragon> you need \1 around it to be a CTCP
03:37:58 <Yoshibloke> ok
03:38:38 <Yoshibloke> so something like: write "PRIVMSG" ((channel) ++ " : \1ACTION\1 " ++ msg
03:38:39 <Peaker> running mueval always fails with "time limit exceeded", how come?
03:38:39 <Yoshibloke> ?
03:41:35 <Peaker> hmm.. the unsafePerformIO example in mueval DOES work here. Ouch
03:44:56 <kalven> Yoshibloke: the final \1 goes at the end of the message, iirc.
03:45:08 <Yoshibloke> Ah, thanks
03:49:10 <lilac> @oeis 1 3 8 6 20 24
03:49:11 <lambdabot>  Pisano periods (or Pisano numbers): period of Fibonacci numbers mod n.
03:49:11 <lambdabot>  [1,3,8,6,20,24,16,12,24,60,10,24,28,48,40,24,36,24,18,60,16,30,48,24,100,84,...
04:01:36 <Peaker> why do .cabal files specify the language extensions? Why not LANGUAGE pragmas which limit extensions to exactly where they're needed and better documenting the code?
04:02:05 <quicksilver> Peaker: so that you can decide if a given package will compile with your compiler
04:02:11 <quicksilver> Peaker: without downloading it and checking every file.
04:02:30 <Peaker> quicksilver: but it means you don't have to specify it for each file.. it could be nice if it was purely documentary or auto-generated?
04:02:47 <yairchu> +1 for auto-generated
04:03:00 <yairchu> or inferred
04:03:29 <quicksilver> it would be nice if it could be inferred, yes.
04:07:45 <pasc1> hi, i have some problems installing cabal-install. the install-script says that i have to install parsec, but i already installed parsec before
04:11:33 <Oejet> Hi, I cannot get the XML prettifier code at http://therning.org/magnus/archives/695 to work as advertised. The xml module seems to be a wrapper of libxml, which eats any other output from the program (e.g. add 'print "monkey"').
04:11:43 <Oejet> Is that how it is supposed to work?
04:22:02 <Beelsebob> Oejet: the xml parser should only eat the contents of the file
04:23:06 <Oejet> Beelsebob: Thanks, that is also what I expected.
04:23:50 <Beelsebob> personally I'd write that as this though:
04:23:51 <Beelsebob> main = do fn <- (!! 0) <$> getArgs
04:23:51 <Beelsebob>            writeFile ("pretty-" ++ fn) . ppTopElement . fromJust . parseXMLDoc =<< readFile fn
04:27:09 <Oejet> Beelsebob: Where is <$> defined?
04:27:28 <quicksilver> Control.Applicative
04:27:38 <quicksilver> although it really belongs to functor.
04:27:48 * quicksilver wonderes why Beelsebob chose (!!0) over head
04:27:55 <Beelsebob> quicksilver: true
04:28:04 <Beelsebob> fn <- head <$> getArgs -- this rather
04:28:26 <Beelsebob> and tbh, I'd use something other than fromJust
04:28:33 <Beelsebob> fromMaybe with a sensible default document
04:29:16 <Beelsebob> also bear in mind Oejet that that code will only work if the file is in the current working directory
04:29:26 <Oejet> I compiled your suggestion. It behaves as before.
04:29:33 <hackagebot> generator 0.5.1 - A list monad transformer and related functions. (YairChuchem)
04:30:34 <Oejet> Beelsebob: I have the XML file in the working directory. What is odd, is that no file is written at all ("pretty"++), and the file is written to stdout.
04:30:42 <Beelsebob> you probably wanted something like appendFileName :: FilePath -> FilePath; appendFileName a f = path </> (a ++ name) where (path,name) = splitFileName f
04:31:15 <Beelsebob> that is indeed odd
04:33:51 <Oejet> And with no arguments on the command line, what appears to be the "--help" text for libxml is printed.
04:34:19 <Beelsebob> sounds like you have a rather odd version of libxml
04:34:33 <Beelsebob> I wonder...
04:34:46 <Beelsebob> are you sure that you're not getting an error from libxml?
04:34:56 <Beelsebob> check the top of the output
04:35:10 <Beelsebob> it may be something along the lines of "parse error on input: ..... <insert all the xml here>"
04:38:32 <Oejet> The versions I have, are xml 1.3.4 from Hackage, and libxml2 2.7.3 from Fedora.
04:40:57 <Oejet> Argh, people should think twice before publicly posting code, because random strangers might try to run it!
04:53:50 <Oejet> Nooooo, it turns out I named the program xmllint.hs, and actually called /usr/bin/xmllint, which is why it always behaved the same. That was a stupid mistake. :(
04:54:38 <Beelsebob> lol
04:54:55 <Beelsebob> awesome
04:55:11 <Beelsebob> sounds like one of the nastier bugs to track that I've heard of
04:55:42 <LeoD> haha
04:56:06 <mornfall> Yeah, that's a booh.
04:58:30 <anq> Mh. This might be a bit off-topic, but does anyone know the book "Discrete Mathematics using a computer"? Is it good?
05:00:45 <soupdragon> no
05:01:43 <kulakowski> no, no one knows the book, or no, it's not good
05:10:10 <gwern> @seen shachaf
05:10:11 <lambdabot> shachaf is in #haskell-iphone, #concatenative, ##logic, #haskell, #xmonad, #haskell-blah, #perl6, #scala and #haskell-in-depth. I last heard shachaf speak 2h 44m 21s ago.
05:11:13 <Oejet> @hoogle Element -> Content
05:11:14 <lambdabot> Warning: Unknown type Element
05:11:14 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
05:11:14 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
05:11:53 <gwern> I guess those 5k users included a fair number of haskellers
05:12:11 <gwern> and to think, I was going to make a joke like 'I don't disconnect for anything less than 7000'
05:12:17 <kulakowski> heh
05:33:14 <Maddas> Do people around here (still) use Yi for writing Haskell?
05:35:15 <Beelsebob> not me
05:35:20 <Beelsebob> I use SubEthaEdit
05:35:35 <kulakowski> Maddas: A new version was uploaded to Hackage just yesterday, so I doubt it's totally dead :)
05:49:17 <quicksilver> Maddas: it is not the permanent editor of choice for many.
05:49:35 <quicksilver> Maddas: but people try it out occasionally and I gather it is imporving fast.
05:52:22 <Peaker> is it supposed to be an emacs based on Haskell rather than elisp?
05:52:40 <Peaker> in terms of customizability/etc
05:52:53 <Maddas> kulakowski: Yeah, I noticed that just now, which is why I'm asking -- I haven't seen a lot of discussion about it for quite a while, but I'm not very attentive.
05:52:54 <soupdragon> no
05:53:14 <kulakowski> It takes a lot from emacs, but I wouldn't call it an emacs clone.
05:53:30 <Maddas> Peaker: http://www.haskell.org/haskellwiki/Yi#Borrowing_from_other_editors :-)
05:53:49 <kulakowski> But I udnerstand you can set it up to act a lot like vim as well (why someone would do such a thing is beyond me).
05:54:28 <Maddas> kulakowski: I suspect because many people have decades of training in using vi(m).
05:54:31 <ehamberg> kulakowski: perhaps because they are long time vim users :)
05:54:40 <Maddas> (And have become very proficient and efficient at using it.)
05:55:12 * kulakowski was making a joke implying that vim is bad.
05:55:21 <Maddas> :-)
05:55:27 * ehamberg didn't get it. :|
05:55:31 * Maddas would love to see Yi or any similar effort take off (as long as it uses a sufficiently cool programming language) :-)
05:56:06 <Maddas> kulakowski: I suspect that joke was too subtle for IRC, where many people make the same statement seriously all too often :-)
05:56:15 * soupdragon doesn't
05:56:35 <kulakowski> Maddas: probably.
05:57:24 <kulakowski> I also would like to see something like Yi take off. I haven't (tried) using it in a while, is there support for anything beyond editing Haskell, a LaTeX mode in particular? Might be something I would be interested in working on.
05:57:33 <Philonous> I beginn to understand the appeal  of unsafePerformIO. It is a pita to implement caching of IO actions that a are buried under several layers of functions. Now I have to add an extra parameter to all of them and initiate the cache at the top level, which exposes implementation details where it shouldn't
06:02:29 <soupdragon> Philonous: I get why other people use it but it's usually disappointing
06:04:07 <aldebrn> Is the web application that displays Real World Haskell with the nice inline comments  a stand-alone thing, or is it a custom job?
06:54:39 <Kashyap> Greetings gentle/smart Haskell folks :)
06:54:50 <Axman6> o/
06:55:01 <Axman6> how's it going Kashyap?
06:55:14 <Kashyap> There's an email thread I am part of where we are discussing FP and Haskell
06:55:36 <Kashyap> one question that has come up is - "why is there no array data type"
06:55:45 <dino-> I'm having some cabal API confusion.
06:56:18 <dino-> What I need is to get a path out of the local build info in my Setup
06:56:18 <Philonous> kayess: But there is?
06:56:20 <Elly> Kashyap: because of the existence of http://hackage.haskell.org/packages/archive/array/0.2.0.0/doc/html/Data-Array-IArray.html?
06:56:29 <dino-> An absolute path, with the $ things substituted.
06:56:30 <Axman6> Kashyap: there are
06:56:39 <Axman6> @hoogle array
06:56:39 <lambdabot> package array
06:56:40 <lambdabot> Data.Array.Base array :: (IArray a e, Ix i) => (i, i) -> [(i, e)] -> a i e
06:56:40 <lambdabot> Data.Array.IArray array :: (IArray a e, Ix i) => (i, i) -> [(i, e)] -> a i e
06:57:23 <Kashyap> oh!!! ... cool, so, can you describe to me if it would be straightforward for me to define one myself?
06:57:33 <dino-> I see substPathTemplate :: [(PathTemplateVariable, PathTemplate)] -> PathTemplate -> PathTemplate
06:57:43 <dino-> But have no idea where I'm supposed to get a [(PathTemplateVariable, PathTemplate)]
06:57:52 <doserj> data Array i e = Array !i !i !Int (GHC.Prim.Array# e) -- but you cannot define GHC.Prim.Array# yourself...
06:58:02 <Axman6> Kashyap: not so much
06:58:30 <Elly> I do not think 'straightforward' would be an accurate description of trying to write an O(1) array type in Haskell
06:58:37 <Kashyap> so its just like the "array" of C for example? ....  single block of data being indexed
06:58:39 <Axman6> Kashyap: you can easily define array like structures, but to get efficient ones, you need to use primitives that aren't strictly 'haskell'
06:58:47 <Axman6> yeah
06:59:00 <Twey> ketil: Precisely
06:59:04 <Twey> Kashyap**
06:59:06 <pozic> Isn't it possible to define new primitives on a specific platform by smashing the stack techniques?
06:59:06 <Dae> Kashyap: http://www.haskell.org/tutorial/arrays.html
06:59:16 <Berengal> At some point though, every datatype is provided by the compiler...
06:59:23 <Twey> pozic: The point is that they don't fit Haskell's philosophy
06:59:34 <pozic> Twey: that doesn't have to be the case.
06:59:56 <pozic> You can define a model for x86 code and prove that it does what it should do.
07:00:07 <Elly> pozic: are you talking about "smashing the stack" in the buffer-overflow sense? Because that shouldn't happen in Haskell...
07:00:17 <Kashyap> okay ... let me look at the link and see if I can understand
07:00:21 <Elly> also, trying to write down execution semantics for x86 machine code is the path to madness
07:00:30 <Berengal> Arrays in haskell are nice. They're horrible memory consumers though, unless you use ST for mutation
07:00:31 <pozic> Elly: you can write code which does that by using the FFI.
07:00:47 <pozic> Berengal: horrible memory consumers?
07:00:56 <pozic> Berengal: I don't think so.
07:00:59 <Elly> pozic: can yes, should no :P
07:01:10 * Twey nods.
07:01:11 <Berengal> pozic: Immutable arrays need copying to change
07:01:11 <Axman6> Kashyap: using STArrays or IOArrays will be more efficient than using the Array type if you need mutation
07:01:26 <pozic> Berengal: yes, so don't change them :)
07:01:41 <Axman6> aren't diffarrays mutable and fairly space efficient?
07:01:53 <pozic> Axman6: space, yes. Time, no.
07:02:00 <Kashyap> a quick related question ... what part of Haskell philosophy does not allow Arrays - or did I read that comment wrong?
07:02:06 <Berengal> pozic: Yup. If you do, however, throw in a ST and use a mutable array for a short while
07:02:11 <pozic> Kashyap: you read the comment wrong.
07:02:27 <Twey> Kashyap: It was about efficient arrays, i.e. mutable ones
07:02:41 <Axman6> Kashyap: nothing disallows them, it's just that they're not terrible easy to define using haskell datatypes
07:02:43 <Twey> In practice, of course, we just stick them in IO/ST
07:02:44 <pozic> Kashyap: in fact there are only practical reasons why DiffArrays are inefficient.
07:02:56 <Dae> Kashyap: not haskell philosophy, it works fine there. Some people are bothered that pointers have no strict mathematical equivelant though, and look down on arrays because of it
07:03:25 <Kashyap> oh right ... I see that point
07:03:32 <pozic> Kashyap: if someone invest a few months in compiler optimizations and in optimizing the library, they should be within a very small constant factor of C arrays.
07:03:40 * Axman6 thinks that pointers could probably be looked at as a mapping from a number to a piece of data... >_>
07:04:05 <Peaker> Axman6: Only if that piece of data is immutable?
07:04:10 <Axman6> yes
07:04:13 <pozic> invests*
07:04:54 <Kashyap> yeah ... I read a comment about mutability and efficiency .... why would efficient have to be mutable -> isn't efficient for reading sufficient?
07:05:01 <Axman6> pozic: it's not too hard to get that close to C Arrays speed, if you use the 'unsafe' functions, that don't do bounds checking
07:05:21 <sm> morning all. How do I raise a test error (not failure) within a hunit test ?
07:05:22 <lambdabot> sm: You have 1 new message. '/msg lambdabot @messages' to read it.
07:05:38 <Axman6> Kashyap: not having mutability makes changing an array _really_ costly. the entire array needs to be copied to change one value
07:05:52 <Kashyap> oh okay ... got it
07:06:16 <Axman6> and often a lot of what you want to use arrays for is updating them
07:06:26 <Kashyap> yes .. I see
07:06:56 <lilac> Kashyap: it is probably possible to define an O(1) immutable array type yourself (without using Data.Array) with unsafePerformIO
07:07:06 <Kashyap> thanks Axman6 and others ... I think I have an idea now ... I'll read that link and get back
07:07:08 <lilac> but there'd be no point since Data.Array already exists :)
07:07:10 <Axman6> the ST monad provides a very nice way to have both mutability and purity
07:08:24 <lilac> one thing that ST (and indeed IO) don't make easy is having a mutable structure where individual fields can be changed in-place
07:08:35 <lilac> but other than that, you get most of the power of an imperative language
07:09:06 <lilac> if you're happy with the fields being pointers to mutable data, then you can do that
07:09:09 <Twey> :t distance
07:09:12 <lambdabot> Not in scope: `distance'
07:09:15 <Twey> Hmm
07:09:45 <Dae> Kashyap: in reality, the lack of mutabillity is less of a problem than you might think, but it sometimes means having to rethink your problem
07:09:53 <Twey> What's that function that calculates the distance between two values?
07:10:26 <mikm> Subtraction?
07:10:50 <Twey> No, there was a specific function
07:11:04 <Twey> Basically defined as abs (x - y), I guess
07:12:33 <Gracenotes> for reals, that is just abs (x - y)...
07:13:08 <Gracenotes> you could make your own easily. (maybe with an inline pragma, just to be safe)
07:13:22 <dino-> Hello
07:13:24 <jacobian_> Anyone seen a potentially infinite data structure that looks like:
07:13:41 <jacobian_> data T X = X | T X * T X
07:14:08 <doserj> that's typically called a binary tree
07:14:15 <pozic> Does GHC optimize x + 0 to x? Or is that not guaranteed to be the same for Double values?
07:14:37 <Twey> Gracenotes: Yeah, but I think there's an existing one.
07:15:35 <Axman6> @check \x -> x == x + 0
07:15:38 <lambdabot>   "OK, passed 500 tests."
07:15:46 <Axman6> @check \x -> x == x + 0 where x :: Double
07:15:46 <lambdabot>   Parse error at "where" (column 18)
07:16:04 <Axman6> @check \x -> (x :: Doubel) == x + 0
07:16:06 <lambdabot>   Not in scope: type constructor or class `Doubel'
07:16:09 <Axman6> @check \x -> (x :: Double) == x + 0
07:16:11 <lambdabot>   "OK, passed 500 tests."
07:16:34 <Kashyap> Hey Dae ... I am curious to know if there is some example you can give to give an idea about why mutability is not as big a problem wrt arrays
07:17:05 <pozic> It seems odd that we have all kinds of theorems for monads, but not for something "basic" as Doubles.
07:17:48 <pozic> OTOH, monads are probably order of magnitudes more simple than Doubles, formally.
07:19:58 <Axman6> how interesting, Unladen Swallow (the LLVM python project by google) can now compile all python to native code with LLVM
07:20:31 <jmcarthur> yeah. the speedups are not yet great, but they haven't been focusing on that yet afaik
07:21:20 <Axman6> yeah
07:21:29 <Axman6> i don't use python, but this makes it more interesting
07:22:19 <Cromulent> I wonder if anyone is planning on implementing haskell on LLVM
07:24:34 <Axman6> Cromulent: it's been discussed, and i think that UHC might do just that
07:25:43 <Cromulent> Axman6: sounds good - I'd like to see LLVM support more languages
07:25:51 <Axman6> me too
07:26:31 <Axman6> i'm just waiting for Clang to be more finished really. would be awesome to be able to get rid of GCC
07:26:44 <Zao> Indeed.
07:26:53 <Zao> "oh look, it says it supports Visual Studio"
07:26:58 <Zao> Too bad you can't do shit with it there :)
07:27:02 <Cromulent> clang is pretty much fine for C and Obj-C it is just C++ that it is lacking
07:27:53 <Cromulent> in fact clangs static analysis tools are grade A :)
07:27:54 <benmachine> what's wrong with GCC
07:29:16 <Zao> benmachine: Relying on GCC makes it completely unusable with other toolchains.
07:29:25 <Zao> Like say xlC, VC++, sunstudio, etc.
07:31:07 <Berengal> how would you best describe loop :: (Monad m) => m (Either a b) -> a -> b?
07:31:24 <Peaker> Axman6: what's CLang?
07:31:34 <Axman6> Apple's LLVM based compiler
07:31:53 <Axman6> http://clang.llvm.org/
07:32:49 <Axman6> it performs quite a bit better than gcc (in terms of compile time, disk space used, and error messages are far clearer)
07:33:19 <Vanadium> Does it implement C++ yes
07:33:34 <Axman6> some of it
07:33:39 <Axman6> well, a lot of it i think
07:34:47 <Axman6> Peaker: and it's licenced under a BSD like licence
07:35:07 <soupdragon> Berengal, impossible
07:35:21 <Berengal> soupdragon: I keep forgetting types :/
07:35:29 <Peaker> Axman6: How about the resulting code quality?
07:35:44 <Berengal> Obvious it should be (Monad m) => (a -> m (Either a b)) -> a -> m b
07:35:46 <Axman6> well, it'll be a good ad LLVM can do, which is pretty good
07:36:38 <Peaker> Axman6: Aren't there quite a bit of optimizations to apply between C and LLVM, before LLVM gets its chance?
07:36:55 <Axman6> probably, i don't know :)
07:37:11 * Axman6 thinks he's found one of the ways Apple will be making Snow Leopard faster: http://compiler-rt.llvm.org/
07:37:17 <Peaker> Berengal: how do you get the 'b' out of the Either? Do you use the monad's fail?
07:37:46 <Berengal> Peaker: You give the monad an a until it returns a b
07:39:10 <Peaker> Berengal: ah
07:39:22 <dino-> There's a "right way" to get the mandir from the Cabal API
07:39:39 <dino-> But I can't figure it out!
07:39:44 <Peaker> Berengal: you give it the same a each time?
07:39:59 <Berengal> Peaker: No, if it returns an a, you feed it back in
07:41:23 <Berengal> The simple implementation is loop m a = do {eab <- m a; case eab of Left ra -> loop m ra; Right rb -> return rb}
07:41:35 <Berengal> I just want to see if it's possible to golf...
07:41:56 <Berengal> @undo do {eab <- m a; case eab of Left ra -> loop m ra; Right rb -> return rb}
07:41:56 <lambdabot> m a >>= \ eab -> case eab of { Left ra -> loop m ra; Right rb -> return rb}
07:42:02 <Berengal> @pl m a >>= \ eab -> case eab of { Left ra -> loop m ra; Right rb -> return rb}
07:42:02 <lambdabot> (line 1, column 30):
07:42:03 <lambdabot> unexpected "{"
07:42:03 <lambdabot> expecting variable, "(", operator, ">>", ">>=", "=<<", ">>>", "^>>", "^<<" or end of input
07:42:39 <doserj> loop f x = f x >>= either (loop f) return ?
07:43:16 <Peaker> it would be nice if @pl moved pattern matches to "maybe" or "either"
07:45:04 <djahandarie> What's the best way to store small amounts of persistant data?
07:45:30 <Berengal> Read . Show
07:47:08 <Axman6> djahandarie: Data.Binary isn't hard to grok and is guite nice to work with indeed
07:48:03 <djahandarie> Axman6, cool, thanks.
07:48:20 <Sisu> Berengal: something like: loop f x = either (loop f) return =<< f x
07:48:23 <Axman6> i actually find Data.Binary quite fun to use :)
07:48:39 <Saizan> @pl loop f x = either (loop f) return =<< f x
07:48:39 <lambdabot> loop = fix (join . (((.) . (=<<)) .) . flip flip return . (either .))
07:48:53 <Saizan> @pl loop f x = f x >>= either (loop f) return
07:48:53 <lambdabot> loop = fix (liftM2 flip ((>>=) .) . flip flip return . (either .))
07:49:00 <Saizan> not bad.
07:50:23 <doserj> loop = (either (loop f) return <=<)?
07:50:51 <doserj> erm
07:50:54 <Saizan> not in scope: f
07:50:57 <doserj> yes
07:50:59 <doserj> :(
07:51:08 <Saizan> but not bad
07:51:31 <Saizan> @pl loop f = (either (loop f) return <=< f)
07:51:32 <lambdabot> loop = fix (join . ((<=<) .) . flip flip return . (either .))
07:51:56 <benmachine> flip flip :o
07:52:08 <Saizan> ?type flip flip
07:52:10 <lambdabot> forall a b c. b -> (a -> b -> c) -> a -> c
07:53:14 <benmachine> hmm
07:53:25 <benmachine> so flip flip x f == (`f` x)
07:53:48 <benmachine> is that right?
07:54:07 <soupdragon> lets find out
07:54:09 <Saizan> yes
07:54:16 <soupdragon> @let x = "x"
07:54:18 <lambdabot>  Defined.
07:54:23 <benmachine> @check flip flip x f == (`f` x)
07:54:25 <lambdabot>   No instance for (GHC.Classes.Eq (a -> c))
07:54:25 <lambdabot>    arising from a use of `GHC.Cla...
07:54:30 <benmachine> erm
07:54:31 <soupdragon> @let f x = "f " ++ x
07:54:32 <lambdabot>  Defined.
07:58:52 <hackagebot> shelltestrunner 0.6 - A tool for testing command-line programs. (SimonMichael)
08:01:04 <pikhq> @check flip flip x f == (`f` x)
08:01:05 <lambdabot>   No instance for (GHC.Classes.Eq (a -> c))
08:01:05 <lambdabot>    arising from a use of `GHC.Cla...
08:07:12 <Vanadium> @pl \a b -> abs $ a - b
08:07:12 <lambdabot> (abs .) . (-)
08:07:14 <Vanadium> welp
08:08:11 <pikhq> Vanadium: I do believe that that's a case where pointless is much clearer. ;)
08:08:42 <pikhq> Erm.
08:08:48 <pikhq> Much less clear.
08:08:52 <benmachine> heh I did wonder
08:09:22 <benmachine> I think the library should give a name to ((f .) .) though as it does come in handy
08:09:32 * doserj agrees
08:09:37 <Vanadium> pikhq: I am not so much worried about it being clear or not, but frustrated that I could not work it out on my own
08:09:58 <Vanadium> Basically, yeah, because (f .) . does not make any intuitive sense to me
08:10:05 <soupdragon> @undef
08:10:05 <benmachine> @pl \f -> ((f .) .)
08:10:06 <lambdabot> (.) . (.)
08:10:07 <soupdragon> @let x = "x"
08:10:08 <lambdabot>  Defined.
08:10:09 <soupdragon> @let y = "y"
08:10:10 <lambdabot>  Defined.
08:10:11 <soupdragon> @let f x y = "f " ++ x ++ " " ++ y
08:10:12 <lambdabot>  Defined.
08:10:15 <soupdragon> > ((flip flip x f) y , (`f` x) y)
08:10:16 <lambdabot>   Ambiguous occurrence `x'
08:10:16 <lambdabot>  It could refer to either `L.x', defined at <local...
08:10:33 <Vq^> benmachine: isn't that just "on"?
08:10:41 <doserj> no
08:10:41 <benmachine> Vq^: err, possibly
08:10:45 <benmachine> @type on
08:10:47 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
08:10:53 <pikhq> Vanadium: Yeah, (f .) . y makes no sense to me whatsoever.
08:10:58 <Vq^> :t (`on` id)
08:10:59 <lambdabot> forall c a. (a -> a -> c) -> a -> a -> c
08:11:02 <quicksilver> Vanadium: abs $ a - b === abs . (a -) $ b
08:11:03 <pikhq> @type (f .) . g
08:11:04 <lambdabot>     Ambiguous occurrence `f'
08:11:05 <lambdabot>     It could refer to either `L.f', defined at <local>:3:0
08:11:05 <lambdabot>                           or `SimpleReflect.f', imported from SimpleReflect at /home/cale/.lambdabot/State/L.hs:72:0-32
08:11:08 <quicksilver> Vanadium: is that much clear?
08:11:12 <Saizan> @undef
08:11:34 <Vanadium> quicksilver: yeah, it is
08:11:39 <pikhq> @type ((\x->x) .) . (\y->y)
08:11:40 <lambdabot> forall b a. (a -> b) -> a -> b
08:11:46 <quicksilver> Vanadium: and (a -) = ((-) a)
08:11:50 <pikhq> That was a useless example. XD
08:11:53 <Vanadium> Yeah
08:12:05 <soupdragon> @undef
08:12:06 <soupdragon> > ((flip flip x f) y , (`f` x) y)
08:12:08 <lambdabot>   Add a type signature
08:12:27 <Saizan> > [flip flip x f y, (`f` x) y] :: [Expr]
08:12:29 <lambdabot>   [f y x,f y x]
08:12:45 <quicksilver> Vanadium: so, we get \a b -> abs . ((-) a) $ b = \a -> abs . ((-) a)
08:12:53 <quicksilver> Vanadium: still with me ?
08:13:12 <Vanadium> I suppose so
08:13:21 <quicksilver> now rewrite that (.) as prefix
08:13:32 <quicksilver> \a -> (.) abs ((-) a)
08:13:36 <Vanadium> Okay
08:13:46 <Vanadium> I suppose (.) abs is (abs .)
08:13:47 <quicksilver> which is \a -> ((.) abs) . (-) $ a
08:13:57 <Vanadium> Guh
08:14:00 <quicksilver> which is ((.) abs) . (-)
08:14:03 <Vanadium> Right
08:14:04 <quicksilver> and as you correctly said
08:14:08 <quicksilver> ((.) abs) is (abs .)
08:14:14 <quicksilver> so that is (abs . ) . (-)
08:14:18 <Vanadium> I think it makes sense to me now
08:14:29 <benmachine> @type (-) on abs
08:14:31 <lambdabot>     Occurs check: cannot construct the infinite type: b = a -> b
08:14:31 <benmachine> er
08:14:31 <lambdabot>     Probable cause: `abs' is applied to too many arguments
08:14:31 <lambdabot>     In the second argument of `(-)', namely `abs'
08:14:34 <benmachine> @type (-) `on` abs
08:14:36 <lambdabot> forall a. (Num a) => a -> a -> a
08:14:43 <quicksilver> it's the back-and-forthing between prefix and infix that makes it unclear
08:14:43 <benmachine> @src on
08:14:43 <lambdabot> (*) `on` f = \x y -> f x * f y
08:15:00 <benmachine> that's the wrong way around for this, isn't it
08:15:01 <quicksilver> it's harder to see eta-abstraction without converting to prefix form
08:15:13 <doserj> benmachine: yes, that's |x|-|y|, not |x-y|
08:15:16 <quicksilver> but sections look nicer in infix for.
08:15:20 <quicksilver> form.
08:15:51 <pikhq> I do believe that `on` makes quite a bit more sense than (f .).g. ;)
08:16:02 <Twey> @hoogle Num a => a -> a -> a
08:16:02 <lambdabot> Prelude (*) :: Num a => a -> a -> a
08:16:03 <lambdabot> Prelude (+) :: Num a => a -> a -> a
08:16:03 <lambdabot> Prelude (-) :: Num a => a -> a -> a
08:16:13 <Twey> @more
08:16:14 <Saizan> \a -> abs . ((-) a) == \a -> (abs .) ((-) a) <- another path
08:16:19 <Twey> :(
08:16:37 <benmachine> @please?
08:16:37 <lambdabot> Unknown command, try @list
08:17:29 <Saizan> pikhq: they don't do the same thing though
08:17:57 <pikhq> Saizan: Damn, just when I thought I had figured that junk out.
08:18:13 <soupdragon> I'm so tired man, I could sleep a horse
08:18:48 <Petrosian> @hoogle Seq a -> [a]
08:18:49 <lambdabot> Data.Foldable toList :: Foldable t => t a -> [a]
08:18:50 <lambdabot> Prelude repeat :: a -> [a]
08:18:50 <lambdabot> Data.List repeat :: a -> [a]
08:19:25 <Saizan> (f `on` g) x y = g (f x) (f y)  while instead   ((f .) . g) x y = f (g x y)
08:19:42 <Saizan> oops
08:19:55 <Saizan> (f `on` g) x y = f (g x) (g y)
08:20:22 <Saizan> still different :)
08:20:34 <desp> I wrote a toy vector module, aiming to achieve pleasant syntax: http://pastie.textmate.org/546874
08:20:35 <pikhq> Saizan: Oh, so (f.).g takes a function of two arguments g and evaluates f on its result.
08:20:36 <soupdragon> > ((f .) . g) x y :: Expr
08:20:38 <lambdabot>   Add a type signature
08:20:46 <pikhq> *That's* quite a bit clearer..
08:20:56 <desp> I'm trying now to parametrize it to allow more types as Scalar, but I'm running into problems.
08:21:39 <quicksilver> IMO overlapping instances points to a broken design ;)
08:22:07 <desp> Problem: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7035#a7036
08:22:09 <Saizan> IncoherentInstances are strong evidence of it
08:22:40 <Petrosian> Does anyone know if hlint can identify unnecessary imports?
08:22:55 <quicksilver> I don't think the way you're doing, for example, separate instances for Vector v => Add (v Scalar v) and various different positions where Scalar can appear
08:22:59 <desp> quicksilver, Saizan: I could avoid using those by duplicating code.
08:23:05 <soupdragon> desp: Use Chamelion,  not Haskell
08:24:34 <desp> quicksilver: pardon, but I don't understand your sentence.
08:25:55 <desp> quicksilver, Saizan: here's the code without undecidable/overlapping/incoherent instances, but with more duplication: http://pastie.textmate.org/546910
08:26:47 <desp> (Oh, and with the Abs typeclass mistakenly left in)
08:27:22 <Saizan> i'd probably use a Vector type parametrized by size
08:27:32 <Saizan> to remove some duplication
08:27:54 <desp> Saizan: I don't want to do that now.
08:27:54 <Saizan> most of it, i guess
08:28:00 <desp> Saizan: I want to parametrize Vector by the value type.
08:28:22 <desp> Saizan: but I don't understand what's happening here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7035#a7036
08:29:20 <Saizan> that's the whole code?
08:29:27 <desp> Yes.
08:29:37 <desp> It's truncated up to the point that causes problems.
08:29:51 <doserj> desp: you have two instance declaration for the same types (i.e., instance ... => Add v v v)
08:29:59 <soupdragon> and nothing but the code
08:30:14 <desp> doserj: but these are declarations under separate assumptions.
08:30:20 <doserj> doesn't matter
08:30:25 <quicksilver> desp: the assumptions are not part of the instance declaration.
08:30:26 <desp> How can I make it matter? :)
08:30:32 <quicksilver> desp: by using a different language.
08:30:36 <desp> Aw...
08:30:39 <quicksilver> haskell typeclasses are not what you think they are.
08:30:49 <Saizan> or using some heavy encoding
08:32:04 <quicksilver> the typeclass selector is not a general constraint solver, it's just a unifier.
08:32:25 <desp> Ah.
08:32:36 <quicksilver> i would like a good short answer to "why?" on that point
08:32:48 <quicksilver> since it's one of the most common typeclass mistakes
08:32:57 <quicksilver> (to believe that contexts play a role in instance choice)
08:33:09 <desp> It seems natural.
08:33:10 <quicksilver> I think part of the why is about parametricity, though.
08:33:43 <quicksilver> Suppose there is an instance Foo for all Num's a, and another instance Foo for totally general a
08:34:04 <quicksilver> desp: (this is much simpler but follows the pattern of your problem I think)
08:34:18 <quicksilver> now suppose you have a fully polymorphic (parametric) function which works on all types a.
08:34:27 <quicksilver> It uses the Foo instance on a.
08:34:30 <quicksilver> (there definitely is one)
08:34:47 <quicksilver> but there is no way it could possibly pick the more specific - Num - instance if a turns out to be a Num.
08:35:03 <quicksilver> because parametric functions literally cannot know whether their arguments are members of a type class.
08:35:19 <quicksilver> and that fact is pretty hardwired into GHC's compilation model.
08:35:54 <quicksilver> ICBW ;)
08:36:04 <desp> :)
08:36:10 <desp> Thanks.
08:36:28 <Saizan> yeah, it's about consistency of instance resolution with separate compilation
08:36:30 <quicksilver> Saizan: do you think my analysis is correct?
08:36:33 <quicksilver> (or anyone else)
08:38:07 <Saizan> quicksilver: so yes, it's related to the open-world assumption too
08:39:21 <quicksilver> Saizan: and separate compilation is also related to the open world assumption ;)
08:40:16 <Saizan> you get into problems with monomorphic application of methods too, who says that particular type won't satisfy the required context for an instance later?
08:42:20 <quicksilver> yup.
08:44:10 * maltem wonders if Agda-style hidden arguments are a good way to handle the “instance declarations are floating around in the source code” issue
08:45:15 <soupdragon> what difference would it make?
08:46:16 <maltem> I think it's not related to the discussion, but it's missing the feature that you can't really control what instance declarations are in scope
08:47:25 <quicksilver> in a haskell system, though, it's a mistake to do that
08:47:31 <quicksilver> non-global instances break invariants.
08:47:44 <quicksilver> maybe a different TC-like system would have different design tradeoffs though.
08:52:18 <desp> Another question...
08:52:56 <desp> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7037#a7038
08:55:09 <Peaker> @type fromInteger
08:55:11 <lambdabot> forall a. (Num a) => Integer -> a
08:55:15 <Peaker> @type fromRational
08:55:16 <lambdabot> forall a. (Fractional a) => Rational -> a
08:55:35 <Peaker> @type pi
08:55:36 <lambdabot> forall a. (Floating a) => a
08:55:50 <Peaker> desp: why do you have the Scalar class? Why not use these classes?
08:56:21 <desp> Peaker: because I'm overloading the standard arithmetic operators.
08:56:25 <Peaker> @type fromRational 5 * pi + fromInteger 1
08:56:27 <lambdabot> forall a. (Floating a) => a
08:56:36 <Peaker> @src Floating
08:56:37 <lambdabot> class  (Fractional a) => Floating a  where
08:56:37 <lambdabot>     pi                                                      :: a
08:56:37 <lambdabot>     exp, log, sqrt, sin, cos, tan                           :: a -> a
08:56:37 <lambdabot>     asin, acos, atan, sinh, cosh, tanh, asinh, acosh, atanh :: a -> a
08:56:37 <lambdabot>     (**), logBase                                           :: a -> a -> a
08:57:01 <Peaker> desp: why?
08:57:04 <desp> quicksilver: do you have another moment?
08:57:09 <Badger> > exp 1
08:57:10 <lambdabot>   2.718281828459045
08:58:44 <desp> Peaker: I didn't expect the Spanish Inquisition! :)
08:59:30 * pragma_ casts a spotlight glare in desp's face.
08:59:34 <pragma_> Explain yourself!
09:00:14 <Badger> Explique usted mismo!
09:00:26 <Peaker> desp: you lack a Vector context in your Add instance for Vectors
09:00:58 <Peaker> oh sorry, wait
09:00:59 <doserj> desp: you need to specialize the (+) in vzip (+) to s -> s -> s (which needs scoped type variables)
09:01:30 <doserj> desp: and you still need overlapping and incoherent instances...
09:01:58 <desp> doserj: but the (+) passed to vzip is supposed to be the Add s s s instance.
09:02:22 <desp> The  (Scalar s) => Add s s s  instance, I mean.
09:02:22 <doserj> exactly, that's what you have to tell to the compiler
09:03:22 <desp> Um.
09:03:30 <desp> Could you add a revision to the hpaste?
09:03:33 <desp> I really don't see a fix.
09:04:16 <desp> I tried explicitly specifying the type of (+), adding overlapping/incoherent instances, but the problem is still there.
09:04:23 <doserj> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7037#a7039
09:04:41 <desp> Peaker: I see that the Vector context is missing, but my attempts at adding it fail.
09:05:02 <doserj> desp: that type-checks here in ghc-6.8.2
09:05:27 <desp> Oh, scoped type variables...
09:05:31 <desp> Well, thanks.
09:05:32 <doserj> yes
09:05:39 <desp> Another language extension I have no idea about. :)
09:06:53 * pikhq discovered c2hs...
09:07:04 <pikhq> I think that's the nicest way of doing C bindings I've seen.
09:07:06 <Peaker> ghc bug:  deriving clauses depend on (>>=) and fail, but importing them causes warnings about them being unused
09:07:30 <Peaker> desp: is this an educational exercise? Seems a bit weird..
09:08:15 <desp> Peaker: I wanted to write a vector module using the usual arithmetic operators.
09:08:28 <Peaker> desp: take a look at vector-space, maybe
09:08:59 <desp> Peaker: yeah, I know there's a ton of those modules on hackage.
09:09:11 <desp> Peaker: the most interesting one is in the Basic algebra proposal, which also reimplements Prelude.
09:09:25 <desp> Peaker: still, none fit what I'm trying to do.
09:10:13 <Peaker> desp: why do you define (+) so generically?  Why isn't (+) between vectors of the same vectorspace?
09:10:48 <desp> Peaker: because I define adding a scalar to a vector as extending the vector.
09:10:56 <Zao> That's silly.
09:11:15 <Peaker> desp: extending its asbolute value?
09:11:15 <Zao> Elementwise addition I could see, but adding a dimension?
09:11:24 <desp> Zao: no, not adding a dimension.
09:11:31 <desp> Lengthening the vector.
09:11:32 <Zao> So you add magnitude?
09:11:35 <desp> Yes.
09:11:38 <Zao> Now that's uninituitive.
09:11:55 <Zao> I hope I don't have to touch your code. Ever :)
09:11:56 <desp> The only intuitive interface is the nipple.
09:12:09 <desp> Hey come on, I'm on vacation. :)
09:13:13 <hackagebot> hack 2009.7.15 - a Haskell Webserver Interface (JinjingWang)
09:15:24 <etpace_> @src foldl
09:15:24 <lambdabot> foldl f z []     = z
09:15:25 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
09:15:27 <etpace_> @src foldr
09:15:28 <lambdabot> foldr f z []     = z
09:15:28 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
09:16:47 <Peaker> desp: but the type of (+) really should not be monsterous
09:17:24 <Peaker> desp: is there any genericity gain from using (+) for both vector and scalar addition? Why not name these 2 distinct operations by different names instead of coercing them into the same operator with type class hackery?
09:17:33 <desp> Yes, I'm slowly coming to the realization that I really shouldn't be doing this.
09:17:58 <etpace_> > foldr (\x acc -> if x < 5 then x:acc else []) [] [1..]
09:17:59 <lambdabot>   [1,2,3,4]
09:18:08 <etpace_> > foldr (\x acc -> if x < 5 then x:acc else []) id [1..]
09:18:09 <lambdabot>   Couldn't match expected type `[a]' against inferred type `a1 -> a1'
09:18:35 <etpace_> my z value isnt actually used in that foldr at all, right?
09:19:08 <Twey> etpace_: Yes, it is
09:19:31 <Twey> 17:18:08 < etpace_> > foldr (\x acc -> if x < 5 then x:acc else []) id [1..]
09:19:36 <Twey> This is unlikely to type-check
09:19:42 <Twey> Unless you've got some really weird instances defined
09:20:09 <etpace_> Sorry, ignoring the type checking -- the value of z isnt used, because It never reaches foldr f z []?
09:20:16 <pikhq> :t foldr
09:20:18 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
09:20:42 <etpace_> > foldr (\x acc -> if x < 5 then x:acc else []) [999] [1..]
09:20:44 <pikhq> etpace_: "Ignoring the type checking"? *facepalm*
09:20:44 <lambdabot>   [1,2,3,4]
09:20:56 <etpace_> What pikhq?
09:21:12 <Twey> Ah, you mean it will never be evaluated?
09:21:16 <etpace_> Yes
09:21:36 <pikhq> But anyways, yeah; the value of z isn't used because you never use that accumulator. z just needs to be the right type.
09:26:47 <etpace_> I'm struggling to realise why foldl can't act on infinite lists as well -- in foldr, acc is calculated in the "future" right? (the next recursive call), where as foldl has the values for both its accumalator and it's x, can foldl not work on infinite lists because even if f doesn't reference acc, the next step will still be evaluated?
09:27:54 <quicksilver> @src foldl
09:27:54 <lambdabot> foldl f z []     = z
09:27:54 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
09:28:10 <quicksilver> etpace_: the "outermost" application in a foldl
09:28:25 <quicksilver> etpace_: is that which relates to the final element of the list
09:28:28 <quicksilver> etpace_: (see the base case)
09:28:36 <quicksilver> so you have to find the end before you can get started.
09:29:30 <pikhq> And so you can only foldl on an infinite list using an infinity machine.
09:31:21 <gwern> @seen shag
09:31:21 <lambdabot> shag is in #gentoo-haskell and #haskell. I don't know when shag last spoke.
09:31:30 <gwern> @seen shachaf
09:31:30 <lambdabot> shachaf is in #haskell-iphone, #concatenative, ##logic, #haskell, #xmonad, #haskell-blah, #perl6, #scala and #haskell-in-depth. I last heard shachaf speak 7h 5m 36s ago.
09:32:01 <gwern> @tell shachaf the essay we spoke of will probably be done in 2 or 3 days; would you be interested in a copy?
09:32:01 <lambdabot> Consider it noted.
09:35:39 <etpace_> quicksilver: while the new value of f z x can be calculated at each step, it never actually returns until the base case? the foldl will keep on going regardless of the value of f z x until []?
09:36:23 <quicksilver> depends on your f
09:36:56 <Lemmih> quicksilver: It does?
09:37:01 <quicksilver> well, in a sense
09:37:20 <quicksilver> > foldl (flip (&&)) False [undefined,undefined,True]
09:37:21 <lambdabot>   * Exception: Prelude.undefined
09:37:30 <quicksilver> > foldl (flip (&&)) True [undefined,undefined,False]
09:37:31 <lambdabot>   False
09:37:39 <quicksilver> in a sense that clearly doesn't evaluate all the fs.
09:37:42 <quicksilver> in another sense, it does ;)
09:37:54 <Philonous> etpace_: What you describe is foldl', the strict sibling of foldl. But due to nonstrict evaluation foldl f will never actually start to compute anything.
09:38:01 <quicksilver> you can't escape building the huge thunk, but that thunk can reduce very quickly.
09:38:11 <etpace_> ok Philonous
09:39:05 <etpace_> I understand why it can't now -- while in foldr, if the second argument of f is never needed at one point, the call returns -- foldl keeps going regardless of what f needs until it hits the base case
09:39:12 <etpace_> (i hope thats right?)
09:40:00 <quicksilver> yes.
09:40:01 <Philonous> etpace_: caveat: foldr f works on infinite list only if f is lazy in it's second argument.
09:40:11 <quicksilver> foldl definitely proceeds to the end of the list, to find the []
09:40:20 <quicksilver> foldr allows the "f" to guide how far it proceeds
09:40:41 <quicksilver> if the "f" is at some point non-strict in the second argument that may suspend or terminate the traversal.
09:40:59 <etpace_> thanks
09:44:08 <erisco> is + a function? can you pass it as an argument to another function somehow?
09:44:26 <Zao> @type (+)
09:44:28 <lambdabot> forall a. (Num a) => a -> a -> a
09:44:32 <Zao> Sure is.
09:44:51 <Zao> @type (*3)
09:44:52 <erisco> Zao, must I wrap it in parenthesis to work then? I will try that
09:44:52 <lambdabot> forall a. (Num a) => a -> a
09:45:08 <Zao> erisco: An infix function can be made into a prefix one with wrapping in parens.
09:45:19 <Zao> erisco: An prefix function can be made infix by enclosing in ``
09:45:24 <Zao> @type `elem`
09:45:25 <lambdabot> parse error on input ``'
09:45:34 <Zao> Except that lambdabot dislikes me :)
09:45:47 <MyCatVerbs> @type (`elem1)
09:45:49 <lambdabot> parse error on input `)'
09:45:49 <MyCatVerbs> @type (`elem`)
09:45:51 <lambdabot> parse error on input `)'
09:45:57 <Zao> > 42 `elem` [42, 3, 5]
09:45:58 <lambdabot>   True
09:46:22 <Zao> MyCatVerbs: Thankfully such abominations do not work.
09:46:59 <MyCatVerbs> I'm not so sure about "thankfully". It seems like an odd wart in the parser.
09:47:06 <desp> Are there synonyms for type classes?
09:49:23 <themroc--> hmm wow 621 ppl in a haskell chan
09:49:26 <themroc--> unbelievable :p
09:51:21 <gwern> themroc--: actually, we're all lambdabots
09:51:31 <gwern> part of dons' scheme for world-domination
10:00:25 <djahandarie> gwern, reminds me of a dream I had where I was getting attack by a bunch of lambda symbols
10:02:25 <RayNbow> @users
10:02:25 <lambdabot> Maximum users seen in #haskell: 658, currently: 627 (95.3%), active: 20 (3.2%)
10:03:38 * pikhq has been reading "The History of Haskell", and saw the phrase "the imperative nature of Lisp".
10:03:43 <pikhq> That makes me giggle.
10:04:21 <gwern> compared to us, lisp *is* awfully imperative
10:04:30 <pikhq> Well, yes.
10:04:31 <pikhq> It still makes me giggle.
10:05:08 <Axman6> heh, i must remember to call lisp imperative if i ever give a talk on haskell
10:05:27 <michie1> gwern: I'm casually interested in what way, is it easy/quick to explain?
10:06:40 <maltem> michie1, most lisp code I've seen has some sort of “set” command
10:06:52 <olsner> > Infinity
10:06:54 <lambdabot>   Not in scope: data constructor `Infinity'
10:07:01 <MyCatVerbs> > 1.0 / 0.0
10:07:02 <lambdabot>   Infinity
10:07:13 <olsner> > read "Infinity" :: Float
10:07:15 <lambdabot>   Infinity
10:08:02 <aldebrn> I too have a question about this: is Haskell as "flexible" as Lisp flavors, such as giving you control over every aspect of the language and implementaiton? E.g., conditions and restarts and customizing how the REPL unwinds the stack in any foreseeable situation?
10:08:09 <olsner> so... how are you supposed to write infinity-floats? having to write (1/0) is just stupid
10:08:31 <Axman6> aldebrn: probably not
10:08:52 <Axman6> but a lot of haskell's power comes from putting some restrictions on what you can dp
10:08:55 <Axman6> do*
10:09:11 <maltem> olsner, doesn't all the world just write (1/0)?
10:09:36 <lilac> aldebrn: various things which lisp allows are available in monads in haskell
10:09:38 <maltem> It sure is a little stupid.
10:09:42 <aldebrn> Axman6, ah, so it'd have to be weighted.
10:09:52 <Axman6> ?
10:10:05 <aldebrn> The flexibility versus power tradeoff
10:10:12 <lilac> aldebrn: this is in fact a feature -- it allows you to more easily prove things about the code
10:10:18 <erisco> what does => mean in a type definition?
10:10:26 <Berengal> Monads are in a way interpreters
10:10:30 <Axman6> :t (+)
10:10:32 <lambdabot> forall a. (Num a) => a -> a -> a
10:10:38 <Berengal> Well, runFoo is the interpreter for the Foo monad..
10:10:53 <Axman6> erisco: it means the a's in that signature must be instances of the Num class, for example
10:10:59 <lilac> aldebrn: consider: f g = g 3 + g 4. translated into lisp, can you prove that this calls g twice with 3 and 4, and adds the results? what if g invokes a continuation, etc?
10:11:20 <erisco> Axman6, hmm, I see. Haskell is not inferring the type I want then :(
10:11:29 <maltem> erisco, left to the => comes a context. But the meaning is a little different depending on where it's used (types vs. data/class/instance declarations)
10:11:31 <Axman6> how so?
10:12:55 <aldebrn> lilac, indeed it cannot.
10:13:08 <aldebrn> cannot be proven
10:13:31 <erisco> Axman6, well it is saying my arguments have to be instances of Eq which does not make sense at all. I must have done something wrong
10:13:45 <lilac> right. that's the advantage of the haskell way. the disadvantage being that if you want g to invoke a continuation you need to thread a monad through f or similar
10:13:50 <Axman6> erisco: care to share the code?
10:14:03 <lilac> fortunately that's pretty easy
10:17:20 <erisco> Axman6, as soon as I get it working I will, otherwise I doubt it will make sense
10:17:42 <Axman6> well, we might be able to explain why the constraint is being placed there
10:18:08 <erisco> Axman6, I know why it is being placed there, its okay
10:18:13 <Axman6> righto
10:18:15 <erisco> the workaround just doesn't seem right
10:19:50 <kaol> @djinn (a,[([b],c)]) -> [([b],[(a,c)])] -> [([b],[(a,c)])]
10:19:50 <lambdabot> Error: Undefined type []
10:21:58 <Axman6> djinn doesn't know about lists (or recursive datatypes i believe
10:22:24 <Berengal> @type const :: (a,[([b],c)]) -> [([b],[(a,c)])] -> [([b],[(a,c)])]
10:22:26 <lambdabot>     Couldn't match expected type `[([b], [(a, c)])]'
10:22:26 <lambdabot>            against inferred type `(a, [([b], c)])'
10:22:26 <lambdabot>     In the expression:
10:22:34 <Berengal> @type flip const :: (a,[([b],c)]) -> [([b],[(a,c)])] -> [([b],[(a,c)])]
10:22:36 <lambdabot> forall a b c. (a, [([b], c)]) -> [([b], [(a, c)])] -> [([b], [(a, c)])]
10:25:34 <Javagod> is there any way to time or profile a haskell function?
10:26:15 <Berengal> Compile with profiling
10:26:17 <Axman6> sure, compile with profiling support
10:26:30 <Berengal> Then set the profile flag to the RTS
10:26:33 <Axman6> ghc -prof -auto-all Main.hs -o main
10:29:06 <erisco> Axman6, ah, I got it working :)
10:29:14 <Axman6> good good
10:29:29 <erisco> Axman6, anyways, about the type restriction, I need to assert in a pattern match such as (x:xs) that xs is not == []
10:29:46 <erisco> Axman6, so naturally I did that in a guard, but that caused xs to need to be an instance of Eq
10:29:57 <erisco> Axman6, whereas if I just do (x:x2:xs) it does not
10:30:06 <Javagod> "Failed to load interface for prelude"?
10:30:11 <Axman6> oh, you need the null function
10:30:13 <erisco> Axman6, but I never use x2, I just cons it back onto xs and keep going
10:30:15 <Axman6> :t null
10:30:17 <lambdabot> forall a. [a] -> Bool
10:30:18 <Berengal> @src null
10:30:19 <lambdabot> null []     = True
10:30:19 <lambdabot> null (_:_)  = False
10:31:13 <maltem> erisco, also: x:(xs @ (_:_))   -- looks a little heavy though
10:31:15 <Javagod> hmm ghc -prof -auto-all blah.hs doesn't work
10:31:52 <erisco> maltem, the guard takes more room than that
10:35:58 <Javagod> can't find this on google and it's really simple but.. how do you pause in haskell?
10:36:20 <maltem> Javagod, threadDely?
10:36:24 <maltem> *threadDelay
10:37:32 <maltem> beware, it counts in microseconds
10:37:35 <erisco> when you define a local function in a where block, is that function created and destroyed in memory as the parent function is called?
10:37:39 <noteventime> Is it possible to make parsec keep track of source names/line numbers without explicitly updating them?
10:37:43 <Axman6> Javagod: "doesn't work"? how so? did you use ./blah +RTS -whatever-is-needed-to-profile?
10:38:09 <Axman6> erisco: i highly doubt it
10:38:16 <Axman6> there's no need to
10:38:30 <erisco> Axman6, you think that all function definitions stay in memory for the entire execution of the program?
10:38:39 <Axman6> yes
10:38:46 <Axman6> well
10:38:49 <Axman6> sort of
10:38:57 <Javagod> ah no wonder.. microseconds
10:39:59 <noteventime> That is, it it possible to get the current SourcePos inside a parser
10:40:01 <Javagod> oh it said i haven't installed the profiling libraries
10:41:33 <Berengal> Javagod: If you're using a cabal-installed package, you need to install with -p
10:41:43 <Berengal> so cabal install foo -p --reinstall
10:41:51 <Axman6> cabal install --reinstall <package> -p
10:42:11 <erisco> Axman6, it is just that I have a local function that in turn has another local function
10:42:29 <Axman6> and what's the problem?
10:42:30 <erisco> Axman6, so it would be important that the innermost function is not being created and destroyed each time
10:42:40 <Axman6> those functions may be totally optimised out by the compiler
10:42:42 <Berengal> Unless I'm mistaken, all functions are lifted out in assembly
10:42:48 <Javagod> cabal: command not found
10:43:17 <erisco> Axman6, okay, I will leave it as-is then
10:43:18 <Axman6> no, there is no reason for them to be 'created'. how would they get created? the program carries around its own source code, and a compiler?
10:43:36 <Axman6> this is haskell, functional programming, functions are not wasteful ;)
10:43:39 <olsner> > compare (0/0) (0/0)
10:43:40 <lambdabot>   GT
10:43:41 <Berengal> @quote functions
10:43:41 <lambdabot> lennart says: Should Haskell also provide unrestricted side effects, setjmp/longjmp, missile launching functions, etc?  After all, people who don't want to use them can just avoid them. :)
10:44:03 <olsner> haha, so NaN > NaN?
10:44:51 <Vanadium> > (1/0) > (1/0)
10:44:52 <lambdabot>   False
10:44:54 <Vanadium> no~
10:44:58 <Vanadium> oh, wrong
10:45:04 <Vanadium> sorry :v
10:45:04 <maltem> Vanadium, NaN /= Inf
10:45:09 <Axman6> Infinity /= NaN
10:45:20 <Vanadium> maltem: How can that be when Inf is not a number either
10:45:29 <Axman6> sure it is
10:45:33 <Axman6> it;s infinity :P
10:45:37 <Berengal> let xs = replicate 5 (0/0) in zipWith compare xs (reverse xs)
10:45:44 <Berengal> > let xs = replicate 5 (0/0) in zipWith compare xs (reverse xs)
10:45:45 <pikhq> Because that's how IEEE floating points are defined.
10:45:46 <lambdabot>   [GT,GT,GT,GT,GT]
10:45:46 <pikhq> :)
10:45:48 <maltem> Vanadium, that's just how it's defined
10:45:58 <Javagod> > length [1..10000000]
10:46:00 <lambdabot>   10000000
10:46:11 <pikhq> It's an arbitrary but useful definition is all.
10:46:13 <Javagod> > length [1..]
10:46:19 <lambdabot>   mueval-core: Prelude.read: no parse
10:46:19 <lambdabot>  mueval: ExitFailure 1
10:46:23 <maltem> > (0/0) < (0/0)
10:46:25 <lambdabot>   False
10:46:35 <pikhq> Javagod: What, you expect that to work?
10:46:48 <erisco> > (0/0) == (0/0)
10:46:49 <Badger> > (1/0) > (0/0)
10:46:49 <lambdabot>   False
10:46:50 <lambdabot>   False
10:46:51 <Vanadium> Why did you reverse xs up there?
10:46:53 <maltem> But the NaN > NaN is an odd part of how it's just defined.
10:47:01 <Javagod> pikhq: just noticed that length runs in O(n) and not O(1)
10:47:07 <pikhq> length [] = 0;length (x:xs) = 1+length xs -- I see no reason for that to work. :P
10:47:26 <olsner> for compare to work on NaN you need an additional value in Ordering, for not-equal-but-not-ordered
10:47:48 <pikhq> Javagod: Indeed; it's running on a linked list, not a C-style array with known size.
10:47:51 <Axman6> JaffaCake: you had a hamster called parallelogram? I love haskell compiler developers
10:48:11 <Berengal> Javagod: You could write your own list datatype that knows it's length, but it couldn't be infinite
10:48:30 <Berengal> Well, it could, but that's playing dangerously close to bottoms...
10:49:02 <Javagod> > import Data.Array
10:49:05 <lambdabot>   <no location info>: parse error on input `import'
10:49:32 <Vanadium> > 1/0 == 1/0
10:49:34 <lambdabot>   True
10:49:35 <Vanadium> > 1/0 == -1/0
10:49:37 <lambdabot>   False
10:49:44 <Vanadium> I am not sure I entirely agree with that
10:49:54 <Berengal> > -1/0
10:49:56 <lambdabot>   -Infinity
10:50:10 <Berengal> Infinity has a sign-bit
10:50:15 <Javagod> :t Infinity
10:50:17 <lambdabot> Not in scope: data constructor `Infinity'
10:50:35 <pikhq> :t -1/0
10:50:36 <lambdabot> forall a. (Fractional a) => a
10:50:44 <Vanadium> Yeah, but why does 1/0 result in any specific sign?
10:50:57 <pikhq> :t -1/0 :: Float
10:50:59 <lambdabot> Float
10:51:02 <Berengal> Vanadium: IEEE spesifications would be my guess
10:51:04 <pikhq> Vanadium: Because that's how it's defined.
10:51:13 <Javagod> (1/0 :: Float) * 1
10:51:19 <Javagod> > (1/0 :: Float) * 1
10:51:21 <lambdabot>   Infinity
10:51:39 <Berengal> x/0 = signum x * Infinity
10:51:55 <kulakowski> Vanadium: 1 is positive of course. IEEE floats have two representations for 0, one with and one without the sign bit set.
10:52:11 <Vanadium> Oh
10:52:17 <Vanadium> > 1/-0 == -1/0
10:52:19 <lambdabot>   Not in scope: `/-'
10:52:30 <Vanadium> ... that would not have happened in C >:[
10:52:34 <Vanadium> > 1 / -0 == -1/0
10:52:36 <lambdabot>   Precedence parsing error
10:52:36 <lambdabot>      cannot mix `GHC.Real./' [infixl 7] and prefix...
10:52:45 <Berengal> > 1 / (-0)
10:52:47 <lambdabot>   -Infinity
10:52:50 <Vanadium> Haskell is hard!
10:53:13 <Javagod> yep
10:56:45 <Javagod> why is there zipWith, zipWith3, zipWith4, ...?
10:57:33 <pikhq> Functions of 2, 3, 4, ... arguments.
10:57:41 <Berengal> Because not everyone wants to use applicatives all the time
10:57:56 <Javagod> yea but why does it go up to 7?
10:58:01 <pikhq> > zipWith3 (\x y z -> x+y+z) [1..9]
10:58:02 <lambdabot>   Overlapping instances for GHC.Show.Show ([c] -> [c] -> [c])
10:58:02 <lambdabot>    arising from...
10:58:08 <pikhq> Huh.
10:58:24 <pikhq> > zipWith3 (\x y z -> x+y+z) [1..9] [1..9]
10:58:25 <lambdabot>   Overlapping instances for GHC.Show.Show ([c] -> [c])
10:58:26 <lambdabot>    arising from a use ...
10:58:28 <pikhq> > zipWith3 (\x y z -> x+y+z) [1..9] [1..9] [1..9]
10:58:29 <pikhq> XD
10:58:29 <lambdabot>   [3,6,9,12,15,18,21,24,27]
10:58:35 <Berengal> Javagod: Because 7 arguments is enough for everyone
10:58:44 <Javagod> :t zipWith7
10:58:46 <lambdabot> forall a b c d e f g h. (a -> b -> c -> d -> e -> f -> g -> h) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [h]
10:59:22 <Javagod> zipWith7 (\a b c d e f g->a+b+c+d+e+f+g) [1..9] [1..9] [1..9] [1..9] [1..9] [1..9] [1..9]
10:59:28 <Javagod> >zipWith7 (\a b c d e f g->a+b+c+d+e+f+g) [1..9] [1..9] [1..9] [1..9] [1..9] [1..9] [1..9]
10:59:38 <monochrom> need one more space
10:59:40 <Vanadium> How would you replace zipWithn with Applicative there?
10:59:40 <pikhq> > (zipWith (+))<$>(zipWith (+))<$>(zipWith (+)) $ [1..9] [1..9] [1..9] -- Please tell me I'm not being dumb.
10:59:41 <lambdabot>   Couldn't match expected type `[a]'
10:59:45 <Javagod> > zipWith7 (\a b c d e f g->a+b+c+d+e+f+g) [1..9] [1..9] [1..9] [1..9] [1..9] [1..9] [1..9]
10:59:46 <Berengal> > let x = ZipList [1..10] in (\a b c d e f g -> a + b + c + d + e + f + g) <$> x <*> x <*> x <*> x <*> x <*> x <*> x
10:59:47 <lambdabot>   [7,14,21,28,35,42,49,56,63]
10:59:48 <lambdabot>   No instance for (GHC.Show.Show (Control.Applicative.ZipList a))
10:59:48 <lambdabot>    arising ...
10:59:48 <pikhq> YAY.
10:59:50 <Vanadium> oh shit
10:59:54 <Vanadium> Nevermind I do not even want to know
11:00:17 <pikhq> Berengal: ZipList is not an instance of show, IIRC.
11:00:19 <Berengal> let xs = replicate 5 (0/0) in getZipList $ zipWith compare xs (reverse xs)
11:00:24 <Berengal> Gah!
11:00:43 <Berengal> > let x = ZipList [1..10] in getZipList $ (\a b c d e f g -> a + b + c + d + e + f + g) <$> x <*> x <*> x <*> x <*> x <*> x <*> x
11:00:44 <lambdabot>   [7,14,21,28,35,42,49,56,63,70]
11:00:56 <Axman6> :t join id
11:00:58 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m a)
11:00:58 <lambdabot>     Probable cause: `id' is applied to too few arguments
11:00:58 <lambdabot>     In the first argument of `join', namely `id'
11:01:00 * Berengal is annoyed when his clipboard lags behind
11:01:26 <Javagod> > unzip7 ([(1),(1),(1),(1),(1),(1),(1)])
11:01:27 <lambdabot>   No instance for (GHC.Num.Num (a, b, c, d, e, f, g))
11:01:28 <lambdabot>    arising from the lit...
11:01:40 <pikhq> > let x = ZipList [1..10] in getZipList $ (+)<$>(+)<$>(+)<*>x<*>x<*>x
11:01:41 <lambdabot>   Couldn't match expected type `Control.Applicative.ZipList
11:02:00 <pikhq> > let x = ZipList [1..10] in getZipList $ (+)<$>(+)<$>(+)<$>x<*>x<*>x
11:02:01 <lambdabot>   Occurs check: cannot construct the infinite type:
11:02:01 <lambdabot>    a = (a -> a) -> a -> a
11:02:09 <pikhq> Bah.
11:02:15 <Javagod> > unzip7 (1,2,3,4,5,6,7)
11:02:16 <lambdabot>   Couldn't match expected type `[(a, b, c, d, e, f, g)]'
11:02:20 * pikhq goes off to a ghci
11:02:29 <Javagod> > unzip7 [(1,2,3,4,5,6,7)]
11:02:30 <lambdabot>   ([1],[2],[3],[4],[5],[6],[7])
11:02:42 <shachaf> > let x = ZipList [1..10] in getZipList $ (\x y z -> x + y + z) <$> x <*> x <*> x
11:02:44 <lambdabot>   [3,6,9,12,15,18,21,24,27,30]
11:02:44 <lambdabot> shachaf: You have 1 new message. '/msg lambdabot @messages' to read it.
11:02:53 <Javagod> > unzip8 [(1,2,3,4,5,6,7,8)]
11:02:54 <lambdabot>   Not in scope: `unzip8'
11:05:29 <pikhq> @pl \x y z -> x + y + z
11:05:30 <lambdabot> ((+) .) . (+)
11:06:02 <pikhq> @hoogle on
11:06:03 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
11:06:03 <lambdabot> Text.PrettyPrint.HughesPJ OneLineMode :: Mode
11:06:03 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
11:08:13 <pikhq> > let x = ZipList [1..10] in getZipList$((+)<$>)<$>(+)<$>x<*>x<*>x
11:08:15 <lambdabot>   [3,6,9,12,15,18,21,24,27,30]
11:08:56 <shachaf> pikhq: Ew.
11:08:59 <shachaf> That doesn't count.
11:10:21 <pikhq> shachaf: I was just randomly wondering what it'd look like pointless.
11:10:30 <pikhq> And then randomly decided to use <$> instead of .
11:10:45 <pikhq> Ugly.
11:14:10 <etpace_> Can anybody help explain how http://dpaste.com/67551/ works? especially the splits function
11:14:33 <etpace_> I'm quite confused with the recursion inside a list comprehension
11:16:40 <Berengal> Splits seems to return all the possible ways to split a list
11:18:10 <Berengal> perms returns all permutations of a list, by inserting the first element inbetween all possible splits of all permutations of the tail of the list
11:20:32 <etpace_> Gah, I'm struggling to understand how splits works, it's the recursion inside the comprehension that is throwing me
11:20:57 <Berengal> etpace_: Are you familiar with the list monad?
11:21:14 <etpace_> Not at all
11:21:21 <monochrom> Is this someone else's code as a puzzle and you are asked to understand it?
11:22:04 <Berengal> etpace_: do you know prolog? Are you familiar with non-deterministic computation?
11:22:37 <etpace_> It's in Erlang Programming, It's just a "heres an example of a list comprehension", I didn't understand it in Erlang so I rewrote it in haskell to see if that helped at all -- it hasn't
11:22:48 <Chile> I have a situation that looks more or less like, "func a b c = f (f' a b c) somethingelse (f' a b c)" which is clearly less than ideal.. is there a nicer way to write this syntactically?
11:22:51 <etpace_> Nope Berengal, and onyl as much as NFA
11:23:28 <Berengal> Chile: let/where
11:23:48 <pikhq> func a b c = f g somethingelse g where g = f' a b c
11:24:34 <alexsuraci> Is this the recommended/only haskell-mode for Emacs? http://www.haskell.org/haskell-mode/
11:24:39 <alexsuraci> Its indent rules are kind of off
11:25:15 <Chile> ah, I was under the impression you couldn't use arguments to the outside function in 'where' blocks. that makes it much easier.
11:25:39 <pikhq> alexsuraci: Hit tab again; the indentation cycles, since what indentation you want is often ambiguous.
11:25:44 * SamB wonders which wiki would be the best place to host a page about how to get haskell-mode to indent nicely -- emacswiki or haskellwiki?
11:26:11 <alexsuraci> pikhq: ah, interesting
11:26:16 <kulakowski> alexsuraci: There is also another indentation function that wome people prefer
11:26:25 * SamB supposes emacswiki would probably have more of the links you might want ...
11:26:43 <alexsuraci> kulakowski: The "simple" one?
11:26:57 <kulakowski> alexsuraci: no, one sec lemme find the link
11:27:02 <alexsuraci> alright
11:27:18 <Berengal> etpace_: I think list-comprehensions like these are easiest understood when explained as non-deterministic computations, which are easier to explain in the list monad
11:27:26 <Berengal> etpace_: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7045#a7045
11:27:26 <kulakowski> http://kuribas.hcoop.net/haskell-indentation.el
11:27:27 <monochrom> Understand what splits does first. splits [1,3,5,7] gives [([],[1,3,5,7]),([1],[3,5,7]),([1,3],[5,7]),([1,3,5],[7]),([1,3,5,7],[])]. So in general it seems to be [splitAt 0 xs, splitAt 1 xs, ... ]
11:27:31 <Berengal> Rewritten in the list monad
11:27:42 <alexsuraci> kulakowski: Thanks, I'll check it out.
11:28:02 <monochrom> To see how, first convince yourself that splits [] = [([],[])] is right.
11:28:28 <monochrom> Then assume splits xs works correctly, now see if splits (x:xs) works too.
11:29:04 * pikhq notes that the list monad rewrite is really easy to understand, in comparison to that list comprehension junk
11:29:05 <benmachine> induction woo
11:29:24 <monochrom> The 0th item given by splits (x:xs) is ([],ys), where ys is our x:xs. That's the correct 0th item.
11:29:52 <monochrom> For the rest, the code says compute splits xs, which gives us [splitAt 0 xs, splitAt 1 xs, ... ]
11:30:27 <monochrom> Then the code says take each of those, let's say take splitAt k xs. It's a pair, so call it (as,bs).
11:30:32 * erisco rofls
11:30:50 <monochrom> as has the left-side k items of xs, bs has the rest of xs.
11:30:55 <erisco> this is a quote from Chapter 7 in Real World Haskell
11:30:56 <erisco> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7047#a7047
11:31:20 <erisco> sound like a motivational speech much? :P
11:31:47 <monochrom> Now the code says part of the final answer is formed by (x:as, bs). So that's (first k+1 items of (x:xs), the rest of xs). Which is also right.
11:31:54 <pikhq> Hmm. do y <- [0..length xs]; return $ splitAt y xs
11:31:55 <FauxFaux> Looks more like a haiku to me, erisco. :)
11:32:14 <erisco> FauxFaux, I formatted it as such to emphasize my point
11:32:37 <Berengal> The IO monad; changing the state of the world; not the program state
11:33:06 <Berengal> s/the/just/ in the last line
11:33:20 <FauxFaux> I actually read the Monads section of RWH for the first time about an hour ago, I'm not convinced. :/
11:33:59 <Cale> FauxFaux: What are you trying to be convinced of?
11:34:00 <Berengal> FauxFaux: Convinced about what?
11:34:15 <Cale> That monads are a useful abstraction for a certain type of library?
11:34:26 <monochrom> For example, we assume splits [3,5,7] gives [([],[3,5,7]),([3],[5,7]),([3,5],[7]),([3,5,7],[])].
11:34:41 <FauxFaux> The sanity of that level of abstarction and bloating of the syntax of the language.
11:34:52 <pikhq> What bloating?
11:34:55 <erisco> > splits [3,5,7]
11:34:57 <lambdabot>   Not in scope: `splits'
11:35:01 <erisco> *shrug*
11:35:04 <Berengal> The only bloating is do-notation
11:35:05 <pikhq> The only additional syntax is 'do' notation.
11:35:30 <Fairweather> excuse me, does "bind f.g" translate to "(bind f).g" or "bind (f.g)"
11:35:31 <Cale> A monad is just a sort of library which supports one particular API. The reason we want to recognise monads when they occur is that it lets us use a whole library of standard operations together with that library.
11:35:33 <monochrom> Now try to see that ([], [1,3,5,7]):[(1:as, bs) | (as, bs) <- [([],[3,5,7]),([3],[5,7]),([3,5],[7]),([3,5,7],[])] ]  gives the correct answer.
11:35:37 <FauxFaux> Would you not be able to omit the whole a -> m b bit too?
11:35:42 <Cale> So it saves us trouble writing them out over and over.
11:35:43 <pikhq> Otherwise, it's just >>= and return and such, and those are just functions in a library. :)
11:35:45 <Berengal> Fairweather: (bind f).g
11:35:54 <Fairweather> thanks
11:36:00 <Cale> (and yes, there's do-notation, but that's just syntax sugar)
11:36:00 <Berengal> Fairweather: Function application binds the tightest, always
11:36:01 <Petrosian> Fairweather: Function application always takes higher precendence
11:36:13 <FauxFaux> I'm a java developer, cut me some slack, dammit. :p
11:36:26 <pikhq> FauxFaux: That wasn't added for monads.
11:36:35 <Cale> FauxFaux: The fact that IO is monadic is not particularly important aside from the fact that it lets you use the stuff in Control.Monad
11:36:43 <pikhq> That's a core feature of the type system, and it happens to make monads easy to implement.
11:36:49 <Cale> FauxFaux: The more important fact is that IO actions are represented as values.
11:37:02 <Cale> Don't let anyone tell you that monads are really about state :)
11:37:04 <Petrosian> I think I good start is to take Monads "out of the classroom"
11:37:10 <Petrosian> Actually use them to implement something non-trivial
11:37:12 <Petrosian> That's useful
11:37:17 <monochrom> @quote haiku
11:37:17 <lambdabot> lilac says: class Monad m where / return and Kleisli compose / must form a monoid  <lilac> that's my new monad tutorial haiku  <jmcarthur> i think that is the best monad tutorial i have ever
11:37:17 <lambdabot> read
11:37:23 <Fairweather> Berengal, Petrosian : ok, I'll take care to remember that
11:37:24 <monochrom> That's what monad is about.
11:37:31 <Petrosian> And compare it to the conventional, non-monadic approach
11:38:09 <FauxFaux> RWH runs throug hthat with their parser and the Maybe one, maybe that really is the best way to do it.
11:38:13 * pikhq really wishes that monads were first taught using the Maybe monad.
11:38:16 <Berengal> Control.Monad is a library of combinator combinators
11:38:25 <Cale> > do x <- [1,2,3]; y <- [4,5]; return (x,y)
11:38:27 <lambdabot>   [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
11:38:30 <Petrosian> pikhq: Maybe is the first Monad I learnt
11:38:40 <Petrosian> Or.. discovered
11:38:44 <pikhq> Petrosian: First monad I truly grokked.
11:38:57 <pikhq> Actually, that's not true.  The Id monad, that was easier. :P
11:38:58 <Cale> FauxFaux: The list monad is basically like list comprehensions. Why do we care? We already have list comprehensions, right?
11:39:11 <Cale> FauxFaux: The reason is that all the stuff in Control.Monad comes alive for lists as well:
11:39:19 <FauxFaux> My brain will actually explode if you type any more.
11:39:19 <Cale> > sequence [[1,2,3],[4,5],[6,7,8]]
11:39:21 <lambdabot>   [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2...
11:39:28 <Berengal> Part of the power of monads lies in realizing their generality, not just the convenience in the various special cases
11:39:41 <Berengal> > filterM (const [True, False]) [1,2,3]
11:39:42 <Petrosian> I learned several monads before IO
11:39:42 <lambdabot>   [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
11:39:56 <Petrosian> Seems the opposite is true for most people learning them these days
11:40:19 <pikhq> Petrosian: I think I saw IO before I learned monads at all. But for the trivial case, you really don't need to get that IO is a monad for it to work.
11:40:21 <Cale> Petrosian: It's always been a sort of point of tension in deciding how to structure a tutorial.
11:40:23 <Petrosian> Or rather, I understood and `usefully used' several before IO
11:40:25 <monochrom> The 3rd monad you learn is the monad that clicks.
11:40:58 <Berengal> monochrom: It's also the one you implement yourself
11:41:08 <Petrosian> Part of the problem is these undergrad want to dive right in and *read and write files* from the get go, madness.
11:41:16 <Cale> Petrosian: I think the more traditional way is to introduce IO late, but it's also quite possible to introduce it early. The other day, I had a discussion with someone who didn't really know Haskell at all, and explained how IO worked. :)
11:41:34 <Petrosian> Cale: Probably right
11:41:48 <Petrosian> Cale: I don't know which method is `better', having only experienced it the way I learnt it
11:42:02 <Berengal> The thing about IO is that it's not hard to understand if you come from an imperative language, but there are some truths about it which hold for several other monads as well, such as sequence
11:42:21 <monochrom> It's like "Hi I'm doing my very first exposure to the Chinese language so how do I write a PhD thesis in Chinese?"
11:43:27 <Petrosian> Berengal: It's when people try and shift their "imperative expectations" over to other monads besides IO
11:43:30 <Cale> monochrom: Surely not that bad. It's possible to explain how IO works properly, and just introduce other concepts as they arise. I didn't really get to mentioning how return and >>= generalise, of course.
11:43:50 <monochrom> That kind of people toss around "different people learn differently, I learn by diving in and writing a PhD thesis from the get go"
11:44:07 <Cale> The important thing isn't really that it's a monad though, it's that we have values which represent stuff which can be done, and operations on those values to glue them together into larger ones.
11:44:20 <monochrom> My answer is: sure different people learn differently. Now natural selection implies that some of those people suck.
11:44:35 <Berengal> Petrosian: Probably because they're trying too hard. Monads aren't the end-all be-all. They should do some "vanilla" functional programming as well, at least to begin with. Also, the list monad works decently as a stepping stone imho
11:44:48 <Cale> You don't really need to understand monads to understand any one monad.
11:45:04 <Petrosian> Berengal: Ye, the List monad is decent. I found that to be pretty instructive
11:45:08 <Cale> If all you have is one monad, then the fact that it happens to be a monad is irrelevant.
11:45:16 <pikhq> Cale: Well, doing *that* is quite reasonable.
11:45:43 <pikhq> At least, much more so than getting to IO and then trying to explain how IO is a monad and what a monad is and etc.
11:45:48 <Berengal> Cale: If all you have is one monad, you'd better hope it's called Cont ;)
11:45:53 <pikhq> s/ and //
11:46:18 <JKF> what confused me most was that IO wasn't doing thigns in-order because it was a monad, but because of how that monad is implemented with a case which breaks the lazyness
11:46:32 <Cale> JKF: hmm...
11:46:46 <Cale> JKF: Is there another implementation which you'd expect?
11:46:48 <etpace_> monochrom: Berengal Can you explain the (x:as, bs) part? Im trying to reason it like so: splitting the list 1:2:3:[], I can split a list 3:[] like ([], 3:[]), then as 3 comes before, it can only attach to the LHS (if it attached to the RHS, it wouldnt be a split for all terms), so I get [([], 3:[]), (3:[], [])] -- now what I'm struggling with is how do I know that prepending the LHS of each tuple with 2, and adding the ([], 2:3:[]) term is ...
11:46:54 <etpace_> ... correct? I can see that it is, but I cant really see how it produces all the splits
11:47:04 <JKF> no, but as a new person I had no basic feel that the case was what was forcing the ordering
11:47:31 <Cale> Well, the ordering is forced because IO values represent the order in which things are to occur explicitly.
11:47:46 <Cale> (no matter what they look like internally)
11:47:53 <dankna> hmm...  are there any gotchas in FFI callbacks that can lead to deadlocks?
11:48:01 <maltem_> Cale, in re "if all you have is one monad": That's how linear algebra is so depressing. First they go like, let's prove things about arbitrary finite-dimensional vector spaces, since that's more general than just for matrices. Afterwards they tell you that all that can be reduced to matrices :)
11:48:09 <dankna> I'm seeing a deadlock the moment my (multi-threaded) program calls from C into Haskell.
11:48:17 <JKF> I think understanding how it works inside is helpful
11:48:25 <Berengal> Actually, I'd say monads are sequential. That some of them might not evaluate sequentially, or even at all, is inconsequential, because the only monad you can observe that in is IO
11:48:31 <JKF> otherwise you bring what you think are properties of monads to other monads and can get confused
11:48:39 <bgs100> Darn it. I finished Learn a Haskell for Great Good!, only to find out it's not finished :'(
11:48:55 <Cale> maltem_: That's one reason I feel uneasy assuming that the space is finite before it's technically required to do so.
11:49:12 <Cale> Berengal: ehh?
11:49:13 <JKF> so the apparent sequential nature is misleading
11:49:22 <monochrom> etpace_ you're asking me to execute a program. I don't execute a program. I let a computer do that. My way of understanding recursion is not to execute it. As I demonstrated, I assume its behaviour for a smaller case, then see that it behaves the same for a larger case. To answer another of your question, for example (1:[3,5], [7]) will be ([1,3,5],[7]).
11:49:37 <Cale> JKF: Here's my mental model for IO:
11:49:39 <Cale> data IO a where
11:49:46 <Cale>   ReturnIO :: a -> IO a
11:49:55 <Cale>   BindIO :: IO a -> (a -> IO b) -> IO b
11:50:02 <Cale>   GetChar :: IO Char
11:50:09 <etpace_> Hmm, so you reason inductively? If it's right for the base case, and correct for k+1 case, it's correct for all?
11:50:09 <Berengal> Cale: m >>= fm makes fm depend on m, so m has to be done "before" fm can be evaluated.
11:50:11 <Cale>   PutChar :: Char -> IO ()
11:50:24 <Cale>   ForkIO :: IO a -> IO ThreadId
11:50:34 <Cale>   ... and so on for other primitive IO actions ...
11:50:46 <Cale> Berengal: but what "before" means is up to >>=
11:51:08 <Cale> Berengal: and it depends on what you mean by 'done'
11:51:14 <bgs100> What should I read to have the equivalent of the other chapters while the actual other chapters are being worked on?
11:51:35 <Berengal> Cale: In the end it doesn't matter in which order things were evaluated, because you get the same answer anyway. The only difference is IO, which is the only place observable side-effects can be had
11:52:04 <monochrom> And to split [1,2,3], first split [2,3] and this gives [([],[2,3]),([2],[3]),([2,3],[])]. Then for each of those items, attach 1. So for example, take this item ([2],[3]). That's our (as,bs).  So (x:as,bs) is (1:[2], [3]) is ([1,2], 3).
11:52:19 <Cale> JKF: So IO actions are directly represented as conglomerations of inert data constructors like that -- basically (higher-order) syntax for what is to be done, in order.
11:52:24 <monochrom> err ([1,2], [3])
11:52:31 <Berengal> Cale: So in a sense, no monad can break the illusion that >>= is a sequencing operator
11:52:36 <Cale> JKF: This is not how GHC does it, but conceivably it could.
11:52:49 <Berengal> (Not that such a perspective is neccessarily useful for all monads)
11:52:51 <JKF> ic
11:53:03 <JKF> I'm just saying how I was confused as a beginner
11:53:08 <solrize> ./lucene-2.4.0/contrib/snowball
11:53:16 <solrize> oops wrong window sorry
11:53:21 <JKF> and that was a big aha for me, in realisng why some monads worked differently
11:53:27 <Cale> JKF: Then the runtime system takes one of those values (main) apart step by step and actually carries out the effects that it describes.
11:53:56 <Cale> Berengal: well... you can sort of trivially say that >>= *defines* what sequencing means
11:54:47 <Cale> (in that given context)
11:54:58 <Cale> But I don't think that means much to most people ;)
11:55:02 <JKF> heh
11:55:23 <Cale> Most people's preconception of what sequencing is doesn't necessarily agree with that either.
11:55:35 <monochrom> You can think of [(x:as, bs) | (as, bs) <- splits xs] as map (\(as,bs) -> (x:as , bs)) (splits xs)
11:56:31 <monochrom> > map (\(as,bs) -> (1:as , bs)) [([],[2,3]),([2],[3]),([2,3],[])]
11:56:33 <lambdabot>   [([1],[2,3]),([1,2],[3]),([1,2,3],[])]
11:57:00 <monochrom> [(1:as, bs) | (as, bs) <- [([],[2,3]),([2],[3]),([2,3],[])]]
11:57:06 <monochrom> > [(1:as, bs) | (as, bs) <- [([],[2,3]),([2],[3]),([2,3],[])]]
11:57:07 <lambdabot>   [([1],[2,3]),([1,2],[3]),([1,2,3],[])]
12:02:25 <deech> Hi all, I'm having trouble getting Text.JSON to work. Right from the test suite that comes with source, this should work, but doesn't. decode "{\"method\":\"feed.add\",\"params\":{\"uri\":\"http://rss.slashdot.org/Slashdot/slashdot\"},\"version\":\"1.1\" }" => *** Exception: Unable to read ().
12:04:21 * cizra ponders whether a tabula rasa would have easier time learning Haskell than someone tainted with lesser languages like /me.
12:06:05 <Cale> cizra: probably.
12:07:11 <Cale> deech: hmm
12:08:45 <Cale> deech: aha
12:09:15 <Cale> deech: It's GHCi's extended defaulting biting you. The type is ambiguous, and so it's being defaulted (stupidly) to Result ()
12:09:50 <Cale> deech: Try giving it an explicit signature  :: Result JSValue
12:11:48 <Berengal> Is there a way of turning off defaulting in ghci?
12:12:18 <SamB> why the heck would you want to do that?
12:13:06 <Berengal> When working with functions polymorphic in their return value
12:15:20 <SamB> maybe you just want to turn off the MR?
12:15:33 <Berengal> That one's off already
12:15:52 <Berengal> But it has nothing to do with defaulting
12:16:13 <MAcks_> Hello :)
12:16:23 <SamB> Berengal: the only defaulting left to turn off is the defaulting which prevents you from having to write type signatures to pin down ambiguous types in the midst of your expressions
12:16:30 <SamB> Berengal: the MR does cause defaulting!
12:16:56 <Berengal> SamB: Well, yes, but it doesn't default expressions
12:17:05 <SamB> it defaults the types of things you bind
12:17:15 <SamB> instead of giving them polymorphic types
12:17:48 <MAcks_> I'd like to create something of an appendable "table-like" structure
12:17:50 <Berengal> Anyway, sometimes I'd like things like read "foo" to not default
12:18:01 <Berengal> > read "foo"
12:18:03 <lambdabot>   * Exception: Prelude.read: no parse
12:18:04 <Berengal> > read "()"
12:18:06 <lambdabot>   ()
12:18:11 <Berengal> See how stupid that is?
12:18:18 <Peaker> I'd like a read :: Read a => Maybe a
12:19:01 <Berengal> Yesterday I spent 15 minutes tracking down a bug in a parser that just wasn't there because ghci defaulted by parse call
12:19:07 <Berengal> my*
12:19:30 <Dridus> MAcks_: Data.Map ?
12:19:52 <MAcks_> with fields like t_start, t_end, etc. and I want to compute number of "rows" that contain some t between t_start and t_end
12:20:04 <MAcks_> but also to mark some records as deleted
12:20:52 <Berengal> MAcks_: Like a database?
12:21:10 <MAcks_> Berengal, that was my first idea
12:21:19 <MAcks_> Berengal, I have a prototype done in Python
12:21:30 <MAcks_> Berengal, and am trying to translate it to Haskell
12:22:18 <Berengal> MAcks_: Probably something like an IntMap holding the data, and several Map key Int index maps would do
12:22:30 <Berengal> I've tried to generalize this idea, but got stuck on the types
12:22:47 <MAcks_> Dridus, with Data.Map is there a large performance penalty to "deleting" entries?
12:23:03 <Dridus> MAcks_: it's not large, check the docs for the complexity
12:23:18 <Berengal> Data.Map has log n for most operations
12:25:06 <MAcks_> ok
12:25:58 <Dridus> MAcks_: what Berengal suggests sounds pretty good if you need fast access by different fields
12:28:22 <MAcks_> Dridus, my scheme is like this: I have location number, t_start and t_end and most of the time I need the overall number of entities at some location in a moment of time
12:29:00 <MAcks_> maybe using a map of Location:[(t_start, t_end)] would be a good idea?
12:29:23 <hackagebot> hsc3-process 0.1.2 - Create and control scsynth processes (StefanKersten)
12:30:05 <MAcks_> then I could select / modify the list of occurence-times for specific location
12:31:00 <Cale> MAcks_: what is it that you're really representing?
12:32:14 <MAcks_> Cale, planned car routes, so that I could know for any moment t, how many cars are going to be in a specified location
12:32:47 <Dridus> MAcks_: if that's really all you have then yeah that could work... length . filter (\ (start, end) -> start <= t && t <= end) . Map.lookup location
12:36:54 <MAcks_> thans
12:36:57 <MAcks_> thanks
12:37:20 <Peaker> @type Data.Map.lookup
12:37:22 <lambdabot> forall k a. (Ord k) => k -> M.Map k a -> Maybe a
12:37:27 <Peaker> you might need to fmap on the result of lookup
12:37:30 <MAcks_> I also have car# stored in there and I would be able to select od delete all entries for some car#
12:37:40 <Peaker> to penetrate that Maybe
12:39:32 <MAcks_> Peaker, couldn't I just use pattern matching?
12:40:12 <Peaker> MAcks_: you could, but that would be more work :)
12:40:36 <Peaker> MAcks_: "maybe" and "fmap" do the pattern matching for you
12:40:43 <MAcks_> Peaker, so how would that use of fmap look like?
12:40:50 <MAcks_> @type fmap
12:40:52 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:40:56 <RayNbow> > fmap succ (Just 3)
12:40:58 <lambdabot>   Just 4
12:41:01 <RayNbow> > fmap succ Nothing
12:41:02 <Peaker> MAcks_: in this case its       (a -> b) -> Maybe a -> Maybe b
12:41:02 <lambdabot>   Nothing
12:41:31 <Peaker> So if you had:        filter (blah ...) . Map.lookup location
12:41:41 <Peaker> then instead you'd have:  fmap (filter (blah ...)) . Map.lookup location
12:42:16 <Dridus> Peaker: yeah, forgot about the Maybe. fmap (length . filter (\ (start, end) -> start <= t && t <= end)) . Map.lookup location
12:42:24 <Peaker> hackagebot: which would mean your entire result is in a Maybe. If that's not good, then maybe you want "maybe" or "fromMaybe" to translate Nothing into something which isn't Nothing
12:42:42 <Dridus> hmm I want between :: Ord a => a -> a -> a -> Bool so I can use uncurry between instead of the lambda :-)
12:42:55 <Peaker> Dridus: what's t?
12:43:04 <Dridus> Peaker: time to look for
12:43:23 <Peaker> Dridus: \(start, end) t -> start <= t && t <= end       is a nice general function to name aside
12:43:27 <Dridus> Peaker: I forget if MAcks_ wanted all instances that surrounded a particular time, or any instances that intersected a time range
12:44:02 <Gracenotes> @type on (&&) . (<=).. hm, not quite...
12:44:04 <lambdabot> parse error on input `..'
12:44:11 <Gracenotes> ow
12:44:40 <Gracenotes> that's more of a less-than-both
12:44:44 <Dridus> @pl \a b c -> a <= c && c <= b
12:44:45 <lambdabot> (. flip (<=)) . ap . ((&&) .) . (<=)
12:44:47 <Dridus> ;-)
12:44:57 <MAcks_> Dridus, this function is ok :)
12:45:02 <Gracenotes> what have you created!!1!!
12:45:11 <Dridus> mwahahah!
12:45:18 <dino-> Live life on the edge with fromJust!
12:45:27 <Dridus> dino-: bottom noooooo
12:45:37 <Peaker> \start end -> liftA2 (&&) (>=start) (<=end)
12:45:41 <MAcks_> It's a nice bot you have here :)
12:45:54 <Peaker> > "Why thank you"
12:45:55 <lambdabot>   "Why thank you"
12:46:02 <MAcks_> :)
12:46:03 <dino-> If you're partially reckless
12:46:13 <Dridus> dino-: that was terrible
12:46:22 <dino-> heh
12:47:04 <Gracenotes> @type (. (<=)) . liftM2 (&&) . (>=) -- manually pointless-ified
12:47:06 <lambdabot> forall a. (Ord a) => a -> a -> a -> Bool
12:47:07 <Peaker> I'd like it if everything that could fail was in Maybe, even head/tail. Then we could have a single-point-of-failure, fromJust for evil :)
12:47:29 <copumpkin> Gracenotes: you're so pointless!
12:47:44 <Gracenotes> you don't have to be so pointed about it
12:47:51 <Peaker> @type liftM2 (&&) . (. (<=)) . (>=)
12:47:53 <lambdabot> forall a. (Ord a, Ord (a -> Bool)) => (a -> Bool) -> (a -> Bool) -> a -> Bool
12:47:56 <Peaker> oops
12:48:03 <Peaker> @type liftM2 (&&) . ((<=) .) . (>=)
12:48:06 <lambdabot>     Couldn't match expected type `Bool'
12:48:07 <lambdabot>            against inferred type `Bool -> Bool'
12:48:07 <lambdabot>     Probable cause: `.' is applied to too few arguments
12:48:10 <Peaker> ok this is just trial and error :)
12:50:42 <mmorrow> @pl \a b ->  (&&) <$> (a <) <*> (> b)
12:50:43 <lambdabot> (((&&) <$>) .) . (. flip (>)) . (<*>) . (<)
12:50:59 <Peaker> already had: liftA2 (&&) (>=start) (<=end)
12:55:31 <MAcks_> Peaker, nice :)
12:55:58 <Dridus> I think this function is best written pointfully as much as I like to be pointless
12:56:46 <Dridus> at least, in my own opinion
12:58:00 <MAcks_> @type liftA2
12:58:02 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
12:58:24 <LeoD> @src liftA2
12:58:25 <lambdabot> liftA2 f a b = f <$> a <*> b
12:58:55 <MAcks_> seems I have to look up <$> and <*>
12:59:08 <pikhq> @src <$>
12:59:08 <lambdabot> f <$> a = fmap f a
12:59:10 <pikhq> @src <*>
12:59:11 <lambdabot> Source not found. My brain just exploded
12:59:23 <pikhq> Oh, right. <*> is per-instance.
12:59:23 <Dridus> that's Applicative on (e ->) right?
12:59:38 <Dridus> er ((->) e)
12:59:56 <pikhq> What, <$>?
13:00:13 <Dridus> Peaker's Peaker: \start end -> liftA2 (&&) (>=start) (<=end)
13:00:19 <Dridus> oop, copy and paste-o
13:00:29 <pikhq> Ah.
13:01:37 <MAcks_> thanks :)
13:01:49 <MAcks_> I also wanted to ask about some concurrent execution
13:02:15 <MAcks_> seems like it is done with seq in GHC
13:02:29 <pikhq> pseq, you mean?
13:03:02 <MAcks_> pikhq, I meant par (and pseq)
13:03:18 <pikhq> Right.
13:03:29 <MAcks_> is there a possibility for more automatic distribution of tasks without hand-coding the fork-points?
13:05:37 <Dridus> MAcks_: it's hard for the compiler to determine what's a good granularity for units of work, so right now you have to tell it when to fork
13:05:45 <Dridus> MAcks_: at least, that's what I recall
13:06:06 <MAcks_> ok
13:06:09 <MAcks_> I'm using GHC
13:06:31 <MAcks_> I'd like to run a few tasks in parallel and then synchronize
13:07:09 <MAcks_> is there a possibility to get the -N passed to GHC runtime from within my code and spawn exactly that-many tasks?
13:07:27 <Dridus> MAcks_: I use STM for threading related stuff usually, myself. GHC does have a bevy of concurrency tools. I recall also somebody (maybe many somebodies) committed some libraries to hackage for managing workers and stuff like that
13:08:08 <cizra> Can I create a type alias or something similar to [Int], so that the compiler would do type checking for me? Ordinary type aliases won't cause type checking, AFAIK.
13:08:12 <Dridus> MAcks_: yes, though its GHC specific -- GHC.Conf.numCapabilities
13:08:37 <Dridus> MAcks_: er, GHC.Conc
13:10:47 <MAcks_> Dridus, in this use, there wouldn't be any shared data
13:10:56 <MAcks_> (If I planned correctly)
13:11:29 <Dridus> MAcks_: then foldl1 (par . combineResults) (replicate numCapabilities work) would probably be pretty simple
13:13:15 <MAcks_> Thanks
13:13:22 <MAcks_> one more thing
13:13:57 <MAcks_> does GHC have some builtin tools for distributing computations in the network or just between multiple processors in one system?
13:15:05 <Dridus> MAcks_: I don't know of anything builtin though hackage has some packages for working along those lines I think. Stuff that implements message passing protocols and such.
13:15:35 <hackagebot> json2yaml 0.0.0 - Utility to convert a file from JSON to YAML format. (MichaelSnoyman)
13:18:04 <MAcks_> I'll settle for a few cores right now
13:20:00 <MAcks_> ok guys, thanks for some very helpful answers. Going to bed now - see you tomorrow.
13:23:42 <Associat0r> does anyone know where to get FRAN? the download link seems to be down
13:24:41 <saml> let me find it for you
13:25:18 <saml> don't you mean FRAG?
13:25:22 <saml> what is fran
13:25:48 <RayNbow> Functional Reactive Animations
13:25:51 <RayNbow> or something like that
13:25:54 <RayNbow> @where fran
13:25:55 <Petrosian> saml: http://conal.net/fran/
13:25:55 <lambdabot> I know nothing about fran.
13:26:14 <Associat0r> yes that one
13:27:06 <saml> i'm pretty sure it's deprecated. Reactive is newer one
13:28:51 <Associat0r> saml I know it's deprecated
13:29:09 <Associat0r> saml  but I need the simpler one just for learning
13:30:05 <saml> Associat0r, maybe http://hackage.haskell.org/package/elerea .. but it's not from conal
13:30:23 <saml> so probably it's doing many things differently
13:31:02 <Associat0r> saml thanks but that is eventless
13:31:21 <Associat0r> I really need fran so I can follow the papers
13:37:32 <jao> is shim (or something similar beyond haskell-mode) still maintained/developed?
13:55:53 <mmorrow> jao: i don't think shim is actively developed anymore (and since the ghc-api changes often, it's bitrotted last i checked)
13:57:07 <jao> mmorrow: i see. pity.
13:58:19 <mmorrow> jao: but if someone was motivated it seemed to me like it could be revived with too much pain
13:58:44 <mmorrow> jao: (i peeked at the code a few months ago i'd say)
13:58:57 <jao> mmorrow: if you meant *without* i could be motivated :)
13:59:05 <mmorrow> hah
13:59:10 <mmorrow> yeah, without :)
13:59:18 * hzap is feeling really dumb after spending a whole hour figuring out why some IORef-mutating code is not working
13:59:37 <Peaker> cizra: did you get your answer?
13:59:53 <jao> mmorrow: i have an old darcs checkout, but the original server seems gone
13:59:56 <Peaker> hzap: paste?
14:00:06 <Peaker> hzap: so #haskell can make you really feel dumb? :-)
14:01:27 <mmorrow> jao: oh? iirc it's on code.haskell.org
14:01:39 <mmorrow> jao: if not i've got a checkout from a few months ago..
14:02:11 <mmorrow> http://code.haskell.org/shim/
14:02:14 <hzap> Peaker: I had a function which created a structure which contained an IORef as well as a function which works on this IORef, and then I wrote another function which simply replaces this IORef with another one (for sharing), but forgot that the function is still operating on the old IORef...
14:02:29 <mmorrow> (although last modified 20-Oct-2007 ..)
14:03:02 <Peaker> hzap: mutability is a pain :)
14:03:14 <jao> mmorrow: ah, forgot to check the obvious, thanks. as you say, it's been long untouched.
14:03:33 <Peaker> hzap: maybe you can factor the IORef out to be a normal argument or a StateT?
14:04:35 <hzap> Peaker: yeah, now I had this figured out it's probably time to factor the IORef argument out
14:05:25 <hzap> Peaker: moral of the story - trying to do funny things with mutable variables is bad bad bad...
14:06:32 <Peaker> hzap: mutability brings a whole set of considerations you otherwise wouldn't have. But if you do use mutability, yeah you gotta be careful that everyone reads from the same place, and not bound to some old copy, as well as worrying about threads, and other stuff
14:06:55 <monochrom> hzap: I have some more mind-boggling IORefs at http://www.haskell.org/haskellwiki/MonadFix#Lazy_algorithm_interleaved_with_effects hehehe
14:07:18 <mmorrow> heh
14:08:41 <mmorrow> too bad new account creation is disabled..
14:08:51 <deadlock> ok guys....i'm new to haskell...please help....i wrote this file in the editor with some IO ...wenn i try to run it nothing happens...i use the command ghc filename.hs ...no compile errors...just nothing
14:08:56 <mmorrow> (i wonder if that's a permanent thing?)
14:09:12 <monochrom> At least indefinite.
14:10:05 <Cale> deadlock: it should have produced a binary program for you to run
14:10:29 <Dridus> deadlock: did you specify --make?
14:10:30 <Peaker> deadlock: Use ghc --make, or runhaskell if you want it to run immediately
14:10:46 <Cale> deadlock: if you run  ghc --make filename.hs  then you should get a binary called either filename or filename.exe depending on your platform.
14:11:05 <deadlock> how to run it in the same console window? is that possible?
14:11:15 <Cale> you run it like you would run any other program
14:11:26 <mmorrow> monochrom: i really like mdo, it'd be nice if it was the default "do"
14:11:26 <Cale> ./filename
14:11:39 <Cale> or if you're on windows, I suppose that would be  filename.exe
14:12:29 <mmorrow> monochrom: err, i guess not all monads have mfix though.. but even still, "do" could be recursive by default for those monads that do have an mfix
14:12:30 <monochrom> There is the problem of much existing code and much existing tutorials rely on shadowing and not wanting mdo.
14:13:26 <mmorrow> i make a point to shadow in case alt patterns, but never in `do' binds, is this really that common?
14:13:35 <monochrom> There is the fundamental problem of let bindings inside mdo --- how to treat them.
14:13:51 <mmorrow> hmm
14:14:02 <deadlock> @Dridius no...how to do that?...if its too complicated, i can life with the binary file
14:14:02 <lambdabot> Unknown command, try @list
14:14:27 <Peaker> we could have do, zdo (MonadZero), mdo (MonadFix), ..
14:14:28 <Dridus> deadlock: ghc --make filename.hs
14:14:39 <monochrom> The mdo papers describe several choices and they all suck. Currently one of them is adopted and has a monomorphism issue.
14:14:49 <deadlock> ah thanx guys...wont be the last question :)
14:14:58 <Dridus> deadlock: without --make, it acts more like gcc or whatever and just makes an object file for later linking
14:15:12 <monochrom> do { let f x =...; ... } Normally that f is polymorphic.
14:15:15 <dolio> How would zdo differ from do?
14:15:18 <mmorrow> , runST (mdo x <- newSTRef ref; let ref = newSTRef 42; join (readSTRef x))
14:15:20 <lunabot>  luna: parse error on input `)'
14:15:45 <mmorrow> hrm, is 'let' even allowed in mdo? (i could've sworn i've used it before?)
14:16:00 <monochrom> mdo { let f x = ...; ... }  is currently desugared to mfix (\ ~(f, ...) -> .... )  That makes f monomorphic.
14:16:09 <trigonometric-Jo> haskell people, I have a question
14:16:26 <monochrom> Actually I don't know what is currently.
14:16:27 <trigonometric-Jo> how much is the tangent of (pi/4) ?
14:16:31 <mmorrow> i thought it was
14:16:54 <monochrom> But there are several choices.  One is forbid let and it sucks. The other is allow let but make it monomorphic and it sucks.
14:16:55 <Peaker> > tan (pi/4)
14:16:57 <lambdabot>   0.9999999999999999
14:17:06 <Peaker> > tan 0
14:17:08 <lambdabot>   0.0
14:17:16 <trigonometric-Jo> why is it 0.9999?
14:17:18 <trigonometric-Jo> oh crap
14:17:26 <trigonometric-Jo> it's tha 0.99.. = 1 stuff
14:17:28 <Peaker> trigonometric-Jo: float/double inaccuracies
14:17:48 <Peaker> I wish they taught cos,sin to kids as coordinates on the unit circle
14:17:58 <Peaker> Rather than the convoluted triangle definition
14:18:03 <Chile> Peaker: they do
14:18:06 <monochrom> I am not sure why we're doing trig in #haskell.
14:18:08 <mmorrow> mdo a1 <- m1; ... ; an <- mn; f (a1,..,n) ===> do (a1,..,an) <- mfix (\ ~(a1,..,an) -> do m1; ...; mn; return (a1,..,an); f (a1,..,an)
14:18:13 <mmorrow> or something like that
14:18:33 <mmorrow> err, missed a closing paren before the "f"
14:18:42 <Peaker> Chile: not here ...
14:19:03 <mmorrow> monochrom: yeah, monomorphic let would definitely suck
14:19:06 <Chile> Peaker: unit circle stuff was part of precalc for us (public school)
14:19:27 <trigonometric-Jo> Peaker: I'm 23 years old and I don't remember trig anymore
14:19:31 <mmorrow> but is that really the case, since the let would just get embedded in a regular "do" block after desugaring?
14:19:49 <trigonometric-Jo> honestly, it should be banned :P
14:20:00 <hzap> I was taught the opposite/hypotenuse definition
14:20:55 <Dridus> I didn' go to no skool
14:21:01 <monochrom> Let me find the example in the mdo papers.
14:23:16 <monochrom> A malicious example is like mdo { this_action_uses f; let f x = blah; return whatever }
14:23:39 <mmorrow> ah, that's what i was trying to test with that ST attempt..
14:23:41 <monochrom> Oh perhaps let me be more malicious.
14:23:54 <mmorrow> so the let /is/ resursive wrt the whole mdo block then?
14:23:54 <monochrom> mdo { y <- this_action_uses f; let f x = blah y; return whatever }
14:24:15 <mmorrow> , runST (mdo x <- newSTRef ref; let ref = newSTRef 42; join (readSTRef x))
14:24:16 <lunabot>  luna: parse error on input `)'
14:24:36 <mmorrow> , runST (mdo x <- ref; let ref = newSTRef 42; readSTRef x)
14:24:37 <monochrom> Yes. My renewed example is so devious it tangles up y and f, they have to be both included in mfix.
14:24:38 <lunabot>  luna: parse error on input `)'
14:24:44 <mmorrow> gah, what is this ")"
14:25:16 <monochrom> , runST (mdo x <- ref; let {ref = newSTRef 42}; readSTRef x)
14:25:20 <lunabot>  luna: out of memory (requested 2097152 bytes)
14:25:35 <monochrom> hehe at least the syntax is accepted
14:25:53 <monochrom> Need a level of { } because there are two possible parses.
14:26:18 <monochrom> (computer doesn't know when does let ends)
14:26:19 <mmorrow> , runST (mdo x <- ref; let {ref = newSTRef 42}; readSTRef x)
14:26:21 <lunabot>  luna: out of memory (requested 2097152 bytes)
14:26:24 <mmorrow> aha
14:26:54 <mmorrow> wow, i didn't realized the let-bound var was recursive too
14:27:10 <mmorrow> (wrt the the whole mdo block)
14:27:27 <monochrom> One can cook up examples so let-bound vars have to be included in the recursive because of lots of mutual dependencies.
14:27:47 <monochrom> I mean of course otherwise you could just factor things out.
14:29:36 <mmorrow> , runST (mdo x <- return (1::Int); let {f :: forall a. Num a => a -> a; f = (+1)}; y <- return (pi::Double); return (f x, f y))
14:29:37 <lunabot>  (2,4.141592653589793)
14:29:41 <mmorrow> :o
14:30:51 <monochrom> , runST (mdo x <- return (1::Int); let {f k = k+1}; y <- return (pi::Double); return (f x, f y))
14:30:52 <mmorrow> iirc ghc's mdo desugaring differed from the paper in some way, but i only read that somewhere indirectly
14:30:53 <lunabot>  (2,4.141592653589793)
14:31:06 <monochrom> Oh?! It's solved? :)
14:31:10 <mmorrow> yay!
14:31:52 <monochrom> Not so sure. The desugaring has a "segmentation" phase that factors things out where there is no dependency, such as this one.
14:31:55 <mmorrow> i think only the vals returned from the mdo block get lambda-bound in the desugaring
14:32:06 <mmorrow> monochrom: ah hmm
14:32:27 <mmorrow> let me find where the comment is in ghc that describes what id does
14:32:32 <mmorrow> s/id/is/
14:35:26 <jdrake> Has anyone ever seen a tin for tea that has a lambda on it?
14:37:31 <monochrom> , runST (mdo xs <- return (f (1::Int)); let {f _ = False:xs}; y <- return (pi::Double); return (take 3 (f x), take 3 (f y)))
14:37:34 <lunabot>  ([False,False,False],[False,False,False])
14:37:46 <monochrom> This one is a stronger case for "solved".
14:38:32 <monochrom> xs depends on f, f depends on xs. They have to be both included in the same mfix segment.
14:38:58 <monochrom> (Gosh it's so difficult to be evil!)
14:39:20 <Cale> jdrake: It's the eleventh in my set of Greek-letter-themed tea tins. ;)
14:39:45 <jdrake> A tin with this on it would be awesome: http://shop.cafepress.com/design/2841425
14:39:57 <Cale> :)
14:40:08 <Cale> Good ol' Haskell logo :)
14:40:23 <mmorrow> monochrom: ah, finally found it. (there's no direct source link the the part of the file it's at), but just search for "Translation for RecStmt's: "
14:40:28 <mmorrow> http://moonpatio.com/docs/ghc/src/DsExpr.html#dsExpr
14:40:32 <jdrake> Of course the hat that with this on it would be nice: http://shop.cafepress.com/design/26087944
14:40:37 <Vanadium> Did the lambda/>>= thing replace that as haskell logo?
14:40:47 <Badger> Lambda Beans
14:40:56 <jdrake> I would generally run into one problem - nobody in my college would ever have likely heard of haskell
14:41:27 <mmorrow> so i guess it's:
14:41:49 <monochrom> Oh my God these days GHC gut uses Applicative pervasively!
14:42:19 <mmorrow> mdo v1 <- m1; ... ; vn <- mn; f v1 .. vn) ===> (v1,..,vn) <- mfix (\~(v1,..vn). do stmts; f v1 .. vn)
14:42:23 <jdrake> So anything special coming in 6.12?
14:42:39 <pumpkin> jdrake: moar awesomeness
14:43:28 <mmorrow> monochrom: heh, a good sign
14:43:48 <Dridus> <3 Applicative
14:44:26 <monochrom> I should learn me an Applicative. OK I learned it years ago but I just skimmed it.
14:44:36 <monochrom> I.e., I didn't practice enough.
14:44:46 <Dridus> learn you an Applicative for greater good
14:44:50 <mmorrow> i only use (<$>) and (<*>) really, but they're really handay
14:44:56 <Rotaerk> hmm my boss's programming philosophy seems to be opposite that of functional programming
14:44:58 <monochrom> Unlike when I learned monads. I practiced it over a million things.
14:45:02 <Dridus> it's really nice for tweaking do-notation code back into a functional visual style
14:45:13 <Rotaerk> he handles the majority of his data flow via side effects
14:45:13 <Dridus> Rotaerk: nonfunctional programming?
14:45:15 <pumpkin> Rotaerk: oh no!
14:45:22 <pumpkin> dysfunctional programming
14:45:38 <monochrom> mutatative programming
14:45:45 <Rotaerk> so I end up with a lot of code that does: { f(); if(this.x) blah(); }  instead of { if(f()) blah(); }
14:45:46 <Dridus> mutant programming
14:45:53 <Dridus> eewww
14:45:54 <monochrom> mutational programming
14:46:10 <Rotaerk> it's really a pain in the ass to maintain hehe
14:46:15 <mmorrow> static global mutating fungi
14:46:16 <pumpkin> Rotaerk: yay for having to look inside each function to make sure it affects its environment correctly and to see what it does :P
14:46:23 <Rotaerk> yea exactly
14:46:42 <jdrake> This is awesome: http://shop.cafepress.com/design/2841446
14:46:42 <monochrom> Your boss learned programming with very old BASIC and he has been stuck in that mindset since.
14:47:00 <jdrake> I learned programming with GW-BASIC
14:47:09 <Rotaerk> his testing philosophy seems to be that unit testing is useless
14:47:10 <mmorrow> in languages where you mutate things as a matter of course though, there's still a big difference from global vars and not
14:47:20 <Rotaerk> that the only test worth doing is on the complete final product
14:47:33 <jdrake> Rotaerk: I am not entirely sure unit testing is useful
14:47:45 <monochrom> I mean, I wrote that kind of code in very old BASIC too. The different is I was already seeing that it sucked. When I then ran into Pascal I was so happy. All my wishes came true.
14:47:55 <jdrake> I should make myself a small computer that boots into intercal
14:48:05 <Rotaerk> jdrake, it is useful
14:48:09 <mmorrow> hmm, i'm not sure if i've ever actually seen pascal code
14:48:16 <mmorrow> ah yeah, := for assignment
14:48:21 <Rotaerk> it can't *prove* the code works, but it filters out a lot of bugs
14:48:26 <jdrake> Rotaerk: caveat: I am not a professional programmer
14:48:26 <dolio> BEGIN
14:48:50 <monochrom> Rotaerk: You can see his testing method is correlated to his programming method. I dare say they're tied, equivalent, isomorphic...
14:48:54 <mmorrow> CAN HAS STDIO?
14:48:58 <Rotaerk> monochrom, yep
14:49:08 <monochrom> With his programming method, unit testing is clearly meaningless.
14:49:12 <tommd> Can does not have stdio - its a very simple OS.
14:49:18 <monochrom> But his method doesn't scale.
14:49:45 <monochrom> Unit testing and scaling flies when you use Haskell.
14:49:52 <mmorrow> dolio: IM IN UR LOOP UPPIN YER VARS TIL ALL THEM VARS AN 10; KTHX;
14:50:03 <Rotaerk> yea
14:50:14 <Rotaerk> mmorrow, <3 lolcode
14:50:22 <mmorrow> s/KTHX/IM OUTA UR LOOP/
14:50:33 <pikhq> </3 LOLCODE.
14:50:44 <pikhq> (I say this as an *actual* esolang programmer. ;))
14:50:58 <Rotaerk> I wouldn't say it's a good language to program in
14:51:05 <Rotaerk> but that doesn't make me <3 it any less
14:51:09 <jdrake> whitespace!
14:51:09 <pikhq> It's just a dumb language in general.
14:51:26 <pikhq> jdrake: Shame that doesn't have anything semantically interesting happening.
14:52:04 <jdrake> pikhq: You know how the inuit have like 50,000 words for snow? Well, whitespace has at least 500,000 different kinds of whitespace.
14:52:17 <Dridus> pikhq: count number of spaces per line, the number determines what semantic meaning the line has ;-)
14:52:39 <mmorrow> pikhq: http://arcanux.org/lambdacats/unit-testing.jpg
14:53:11 <jdrake> Also spaces starting in column 3 are comments, spaces starting in column 4 are if statements. Now you have to figure out how to get to 3 or 4 without putting preceding spaces.
14:54:06 <Dridus> jdrake: &nbsp; ;-)
14:54:53 <Dridus> inuits may have so many words for snow, but unicode actually does have many codepoints for space
14:55:19 <mauke> > filter isSpace [minBound .. maxBound]
14:55:21 <lambdabot>   "\t\n\v\f\r \160\5760\6158\8192\8193\8194\8195\8196\8197\8198\8199\8200\820...
14:55:31 <mauke> > length $ filter isSpace [minBound .. maxBound]
14:55:33 <lambdabot>   23
14:55:51 <pstickne> I wonder why so many :(
14:56:40 <pikhq> pstickne: So that one may losslessly encode from RANDOM_CODESET to Unicode to THE_SAME_RANDOM_CODESET.
14:58:18 <Zao> pstickne: The formatting characters tend to be classified as whitespace, I believe.
14:58:39 <Zao> pstickne: Also, "why is there a snowman in unicode?"
14:58:47 <Zao> U+2603
14:58:48 <pstickne> I guess I can just accept \t \v \f, etc better :)
14:58:55 <pstickne> Zao:  because it's cute! duh!
14:59:12 <pikhq> Zao: Better question: why is there a hammer and sickle in Unicode?
14:59:20 <mauke> ツ
14:59:24 <Vanadium> Zao: Because it is used as a metereological symbol on weather maps.
14:59:59 <Vanadium> pikhq: Now I really want to think of sensible semantics for a hammer-and-sickle operator in haskell
15:00:06 <shepheb> pikhq: Axis and Allies play-by-email
15:00:11 <pstickne> Vanadium:  State Change :)
15:00:12 <pikhq> Vanadium: :D
15:00:25 <monochrom> haha
15:01:02 * ski for a while thought Vanadium was saying that the hammer-and-sickle was used as a meterological symbol on weather maps, there ..
15:01:25 <Vanadium> ski: "cloudy, with some chance of socialist uprisings"
15:06:01 <monochrom> We should commit an application to the Unicode committee for including the Haskell logo.
15:06:08 <monochrom> s/commit/submit/
15:09:36 <Baughn> Why?
15:10:08 <Dridus> because they have a snowman
15:10:38 <Dridus> "I bought an ant farm, but they didn't grow s***. Also, if I pulled your legs off, you look like snowmen"
15:11:55 <Peaker> they also have communism
15:14:11 <monochrom> , Control.Monad.ST.Lazy.runST (return True)
15:14:12 <lunabot>  luna: Not in scope: `Control.Monad.ST.Lazy.runST'
15:14:19 <monochrom> > Control.Monad.ST.Lazy.runST (return True)
15:14:20 <lambdabot>   Not in scope: `Control.Monad.ST.Lazy.runST'
15:14:28 <monochrom> Too bad.
15:14:57 <Berengal> throwError = fail in Error?
15:15:03 <monochrom> mdo { x<-f; let {f=newSTRef True}; readSTRef x}  works using Control.Monad.ST.Lazy and Data.STRef.Lazy
15:15:52 <Berengal> Because I need to do a crapload of pattern matches...
15:17:14 <Berengal> Actually... I think this can be written in a better way
15:18:22 <Peaker> monochrom: f = newSTRef True  ?  Not a bind?
15:18:29 <Peaker> oh, sorry
15:18:34 <Peaker> x is bound
15:19:13 <monochrom> It is silly code. But I have no typo there.
15:19:57 <ray> unicode has a policy against including people's logos
15:19:59 <ray> unless it's iran
15:20:04 <ray> their logo is in there
15:24:06 <SamB> ray: what about the nazi logo?
15:25:46 <tommd> Does anyone know how far Jeremy Shaw and the other freespire guys got on using Haskell for Linux system utilities?
15:26:06 <ski> (SamB : .. or the Jainist logo)
15:26:30 <tommd> For example, did they go and rewrite things like dhclient?  Or did they stick with the tried and true for things that existed?
15:26:49 <jdrake> SamB: I don't see that logo in apple's characters popup
15:27:09 <Cale> tommd: I'm not sure. I think they were mostly using it for the things which might otherwise have been system shellscripts.
15:27:10 <Saizan> tommd: i think they used haskell for things like the packaging system etc..
15:27:22 <SamB> aww
15:27:25 <Cale> and yeah, maybe the package management stuff
15:29:17 <tommd> Ok, thanks.
15:29:42 <Berengal> In parsec, what is the generalization of char?
15:29:50 <Berengal> That is, what parses a single token?
15:30:02 <Berengal> Of any type...
15:30:55 <monochrom> perhaps anyToken
15:31:25 <Berengal> That's anyChar
15:32:20 <Berengal> I want something like (t -> Maybe a) -> Parser a
15:32:33 <Cale> http://hackage.haskell.org/packages/archive/parsec/3.0.0/doc/html/Text-Parsec-Prim.html#v%3Atoken
15:32:55 <monochrom> The closest is token, and it is still hard to use.
15:33:39 <Berengal> Ah, for some reason the documentation I was looking at didn't have comments for that :/
15:34:15 <Cale> To be fair, it is probably as easy to use as it can reasonably be, given that it has to produce good error messages when the parse fails.
15:34:31 <monochrom> The documentation happened after 3.0.0
15:35:01 <Berengal> monochrom: I do have 3.0.0, but it turns out I was looking at the old documentation...
15:35:17 <monochrom> Yes, the old version has empty haddock.
15:35:18 <Cale> There's also tokenPrim, if you're not storing SourcePos values in your tokens while lexing.
15:35:51 <monochrom> I guess tokenPrim is easier to use then.
15:36:04 <Cale> It's more general, anyway.
15:36:42 <Berengal> Yeah, I have no need for position. I'm just doing a bunch of pattern matching, and figured a parser would do it nicely
15:37:06 * Berengal now also wants first-class patterns
15:37:14 <monochrom> (t -> SourcePos) requires me to pull positions out of thin air. (SourcePos -> t -> s -> SourcePos) at least gives me more information to work with.
15:38:03 <benmachine> @src build
15:38:03 <lambdabot> build g = g (:) []
15:38:12 <benmachine> ^ I saw this poking through my lambdabot source file
15:38:14 <benmachine> what is it?
15:38:16 <benmachine> @type build
15:38:18 <lambdabot> Not in scope: `build'
15:38:27 <benmachine> @index build
15:38:28 <lambdabot> Data.Graph.Inductive.Internal.Heap, Distribution.Simple.Build, GHC.Exts
15:38:37 <benmachine> erm
15:38:46 <pumpkin> benmachine: zomg u found da sekrit, we must killz u nao
15:38:47 <Berengal> @type let build g = g (:) [] in build
15:38:49 <lambdabot> forall a a1 t. ((a -> [a] -> [a]) -> [a1] -> t) -> t
15:38:58 <benmachine> erm
15:39:01 <pumpkin> benmachine: it's half of foldr/build fusion
15:39:04 <Chile> how do you go about debugging where an error like this occurs? or what could have caused it? "[*** Exception: Data/Graph/Inductive/NodeMap.hs:130:8-30: Irrefutable pattern failed for pattern Data.Maybe.Just es"
15:39:04 <Cale> benmachine: It turns a fold into a list.
15:39:10 <Chile> I'm a little lost without a callstack
15:39:22 <benmachine> Cale: interesting
15:39:42 <Cale> > let build g = g (:) [] in build (\cons nil -> cons 1 (cons 2 (cons 3 nil)))
15:39:43 <lambdabot>   [1,2,3]
15:40:22 <Cale> So it maps the function-representation of the list back to a concrete list.
15:41:17 <Saizan> ?type GHC.Exts.build
15:41:19 <lambdabot> forall a. (forall b. (a -> b -> b) -> b -> b) -> [a]
15:41:27 <Saizan> it's used by foldr/build fusion
15:41:48 <Saizan> pumpkin: you're back to normal!
15:41:55 <pumpkin> ORY
15:41:56 <pumpkin> ORLY
15:41:59 <pumpkin> DAMN
15:42:11 * pumpkin summons contrapumpkin
15:43:37 <monochrom> antipumpkin, counterpumpkin, depumpkin, impumpkin, unpumpkin, pumpkinless, pumpkinfree, pumpkinproof
15:44:18 <monochrom> doubleplusunpumpkin
15:44:35 <Saizan> pumpkinmorphism
15:44:40 <pumpkin> lol
15:45:05 <pumpkin> zygohistomorphic pumpkinmorphism?
15:45:36 <olsner> zygohistomorphic prepropumpkin?
15:47:03 <pumpkin> pedobear approves
15:47:08 <Peaker> are there things indexed types can do that fundeps can't?
15:47:21 <Peaker> it seems that the opposite is probably true?
15:47:33 <pumpkin> why?
15:48:13 <Peaker> because fundeps allow for completely arbitrary relationships between multiple types, and indexed types seem to only allow for many-to-one or one-to-one relationships with each type, separately
15:49:37 <shapr> y0 Vulpyne, are you still in the desert?
15:49:55 <shapr> IT'S TOO QUIET!
15:49:59 <Saizan> Peaker: you can have two indexes
15:50:04 <Saizan> Peaker: or more
15:50:22 <Saizan> Peaker: i think fundeps gain expressivity only if you allow OverlappingInstances
15:50:24 <Peaker> Saizan: but can you specify the relationships between those indices as freely as fundeps can?
15:50:35 <shapr> frederik: Where are you living these days?
15:51:34 <Taejo> I've been thinking about this homomorphic encryption thing. If you can "fmap" arbitrary circuits over encrypted messages, you can encrypt arbitrary messages by using constant-valued circuits (assuming you have some [unknown] ciphertext)? or am I missing something?
15:51:52 <Peaker> it seems to me that indexed types are only superficially different to fundeps, and while a bit more readable at first, they make programs longer and add type-equality to achieve the same things fundeps do without it.  I am wondering if it is truly such an advancement?
15:52:39 <Saizan> Peaker: it mostly depends on the use case
15:53:27 <Saizan> Peaker: but that was roughly the point of an ICFP08 (iirc) talk by the supporters of fundeps
15:53:51 <Saizan> (i don't recall the name ..)
15:54:01 <Taejo> and once you've got that, you can find out what (encrypt 0) and (encrypt 1) are. And then you can "fmap" an "nth-bit projection" circuit, whose result will be (encrypt 0) if the nth bit of the original plaintext was 0 and (encrypt 1) if the original plaintext was 1. So you can decrypt messages too.
15:54:24 <Peaker> Saizan: do indexed types/datas reduce the need for undecidable instances or stuff like that?
15:55:11 <Saizan> Peaker: you can generally write equivalent instances without turning on UndecidableInstances
15:55:33 <Saizan> by using type families i mean
15:55:53 <pumpkin> Taejo: how do you encode "constantness" in addition and multiplication?
15:56:11 <Peaker> Saizan: I mean - do type families reduce the need to rely on such things?
15:56:57 <Saizan> Peaker: yes, they do
15:57:22 <Saizan> Peaker: though that's mostly because the heuristic used to check decidability of instances is quite coarse
15:57:30 <Saizan> s/coarse/conservative/
15:57:34 <Taejo> pumpkin: the wikipedia page says you can evaluate any circuit. I assumed this meant a boolean circuit (possibly the ring in question is not "numerical")
15:58:01 <Peaker> Saizan: is that inherent?  It seems to me that the difference is superficial enough that there shouldn't be a problem to map each indexed type to a just-as-terminating fundep
15:58:19 <Peaker> Saizan: and mapping backwards to establish decidability, too
15:58:24 <pumpkin> Taejo: ah, maybe... I've only read the pop-science (not the magazine) articles on it, never looked too closely
15:59:34 <Saizan> Peaker: i've never gone to the gory details of this, so that might be true
15:59:43 <Taejo> pumpkin: if it's just arithmetic circuits, then indeed you can't do constantness, and so maybe that's where I'm falling down
16:00:06 <Taejo> but then the pop-science of "arbitrary computation on encrypted data" really falls down
16:00:08 <pumpkin> Taejo: I know that in the case of RSA, when people say it's multiplicative, it's numerical
16:00:19 <Saizan> Peaker: though fundeps looks more flexible to me, and that might hurt the proof
16:00:51 <Taejo> pumpkin: yeah, I know that too. But this new system is a little more dense than RSA.
16:00:56 <pumpkin> yeah :P
16:00:57 <pumpkin> just sayin'
16:00:58 <Taejo> or rather, I'm too dense
16:02:08 <Peaker> Saizan: but the special cases which are equivalent to indexed types can easily be established as such, without seeing the instances, I think
16:02:43 <Peaker> I am wondering what prompted the development of type families, if fundeps already worked
16:02:51 <Cale> Peaker: GADTs
16:02:58 <pumpkin> Taejo: but I do remember something about gentry's scheme involving lifting the encryption function itself into the scheme, to avoid degrading the message too much, or something like that :)
16:03:04 <Saizan> Cale: really?
16:03:21 <Cale> Peaker: Figuring out how GADTs should interact with functional dependencies made SPJ's brain explode.
16:03:32 <pumpkin> lol
16:03:36 <Saizan> hah
16:03:41 <Cale> So they came up with something for which the interaction would be easier to specify.
16:04:13 <Peaker> Using let to pattern match existentials also made someone's brain explode
16:04:40 <Cale> Well, the problem there is that the let bound variables have proper first-class existential types
16:04:42 <Saizan> still SPJ, and you still can't :)
16:05:06 <Cale> (as do the case-matched ones, but with let, you can do funny things like mutual recursion)
16:05:27 <Saizan> though there's a paper he co-authored that proposes top-level opening of existentials
16:05:48 <Cale> It's really hard to add let-bound existentials without planning for it from the outset, I think.
16:06:58 <Saizan> that paper also adds first-class existentials, and requires more annotations to keep type-checking decidable
16:06:59 <Cale> I think morrow can handle it
16:07:09 <Saizan> yeah
16:07:28 <pumpkin> mmorrow?
16:07:37 <Saizan> no, the language :)
16:07:37 <Cale> no, Daan Leijen's language
16:07:43 <pumpkin> damn
16:07:44 <shapr> Parsec?
16:08:03 <Saizan> Cale: have you played with it?
16:08:17 <Cale> Saizan: not really, but it looks sort of cool :)
16:08:32 <Cale> It also implements Daan's record system
16:08:33 <Saizan> it has extensible records too
16:08:42 <Cale> heh
16:08:50 <Saizan> though not the first version with first-class labels, iirc
16:09:39 <ski> Saizan : which paper ?
16:10:30 <Saizan> ski: First Class Modules for Haskell
16:10:37 <ski> ty
16:11:07 * ski has been wanting to play with real existentials for some time
16:11:21 <ehird> @remember bitwize The oleg is to functional studliness as the farad is to capacitance: a hopelessly large base unit.
16:11:21 <lambdabot> Okay.
16:11:32 <shapr> haha
16:11:39 <themroc--> hmm im thinking of doing a list comprehension that returns a list of 3 lists
16:11:55 <themroc--> like as i would do a quicksort implementation with 2 pivot elements
16:12:05 <themroc--> and have to split a list into 3
16:12:25 <themroc--> doing a list comprehension three times is quite expensive :p
16:12:27 <jdrake> Harry Potter opens tonight
16:12:33 <soupdragon> ski
16:12:37 <dons> sjanssen: btw, i'm reviving the twittering account.
16:12:52 <ski> soupdragon : yes ?
16:12:53 <soupdragon> I think EHC has that
16:13:20 <ski> ok
16:13:27 <ski> themroc-- : what are you trying to do ?
16:13:29 <Saizan> ski: there are seven pages about "type checking" :) Higher-order modules in System F_{\omega} and Haskell adds an encoding of applicative functors to that, btw
16:13:35 <soupdragon> except they don't have GADT
16:13:38 <themroc--> im just preparing for an exam and playing around :p
16:14:01 <ski> what problem are you trying to solve ?
16:14:24 <themroc--> http://pastebin.com/m3b633909
16:14:30 <themroc--> that one in a more elegant way
16:14:45 <pumpkin> ack
16:14:53 <themroc--> with one list comprehension
16:15:00 <themroc--> is it possible at all?
16:15:01 <soupdragon> use (,,)
16:15:05 <pumpkin> you really want to be using [[], [], []]?
16:15:06 <soupdragon> not [,,]
16:15:06 <pumpkin> yeah
16:15:07 <ski> themroc-- : why don't you use tuples ?
16:15:25 <themroc--> hmm yeah could use tuples too
16:15:27 <soupdragon> LISP
16:15:44 <themroc--> im coming straight from prolog, strange to reorder my mind sometimes :p
16:15:50 * ski for some reason is reminded of foof-loop, here ..
16:16:09 <soupdragon> prolog has triples lol
16:16:25 <ski> themroc-- : you shouldn't normally use lists for fixed-size structures in Prolog, either ..
16:16:56 <themroc--> ok then i totally forgot about tuples/triples :p
16:17:18 <themroc--> but does it matter?
16:17:26 <themroc--> using a list or a triple in this example?
16:17:58 <ski> i'm not sure how you wanted to use a list comprehension, here
16:18:53 <ski> sure, a list comprehension can be used to collect a list of values .. but here you want to collect several lists
16:19:30 * ski . o O ( `[(a | b | c)] -> ([a],[b],[c])' )
16:19:40 <themroc--> http://pastebin.com/m51d27de6
16:19:42 <themroc--> et voila
16:19:51 <dons> ski: what's that syntax?
16:20:27 <Peaker> is #haskell still growing?
16:20:34 <dons> ?users
16:20:35 <lambdabot> Maximum users seen in #haskell: 658, currently: 609 (92.6%), active: 22 (3.6%)
16:20:43 <ray> seems that way
16:20:44 <ski> dons : `(a | b | c)' is just (the type of) positional variants
16:20:55 <ski> (well, of size 3, here)
16:20:57 <dons> ah
16:20:58 <ray> the second derivative might be shrinking
16:21:04 <dons> ray: yeah
16:21:15 <themroc--> so the way i did is would be the prefered?
16:21:19 <themroc--> in style etc?
16:21:20 <dons> the maximum was 699 5 months ago, we've not breached that.
16:21:20 <Peaker> its been ~600 users for 6 months now?
16:21:42 <ski> themroc-- : it is probably the most straight-forward way, yes
16:22:17 <ski> dons : does `flush' flush the max user seen state, too ?
16:22:23 <ray> @djinn [(a,b,c)] -> ([a],[b],[c])
16:22:23 <lambdabot> Error: Undefined type []
16:22:33 <ski> djinn doesn't understand lists
16:22:39 <ray> pity
16:22:43 <Peaker> or recursive types in general :(
16:23:25 <benmachine> @karma themroc
16:23:25 <lambdabot> themroc has a karma of -4
16:23:28 <ski> the above type would be similar to `[Either a b] -> ([a],[b])' or even `[Maybe a] -> [a]'
16:23:28 <benmachine> <_<
16:23:30 <Peaker> @type map fst &&& map (fst . snd) &&& map (snd . snd)
16:23:31 <lambdabot> forall a a1 b. [(a, (a1, b))] -> ([a], ([a1], [b]))
16:23:32 <themroc--> huh
16:23:44 <ski> (well, maybe not quite the last one ..)
16:23:47 <Peaker> shame on Haskell for having N-tuples
16:24:13 <themroc--> @karma benmachine
16:24:13 <lambdabot> benmachine has a karma of 0
16:24:20 <themroc--> whats that? :p
16:24:31 <benmachine> not important I'm sure
16:25:02 <themroc--> anyone tried to write a chess algo in haskell?
16:25:13 <benmachine> do you mean an AI or a rule-checker
16:25:21 <ski> it might be nice if there were a general way of going from `(f a,f b,f c)' to `(g a,g b,g c)' given `forall x. f x -> g x'
16:25:30 <ski> (for tuples of any size ..)
16:25:34 <themroc--> if you call a bruteforce algo an ai, yes an ai :p
16:26:14 <Peaker> ski: if tuples were all built from 2-tuples, that would ease things up
16:26:49 * ski doesn't really like the idea of making an arbitrary choice in how to associate tuples
16:28:09 <Peaker> ski: its not arbitrary if you have a nil element, and always have a "next tuple" in the right-side element
16:28:37 <idnar> Peaker: you could just as well do it the other direction
16:28:56 <ski> it is arbitrary if in `(a,b,c)' the `a' is "closer to the top", than `c'
16:29:07 <idnar> (a,(b,(c,())))
16:29:09 <Peaker> idnar: that's making the arbitrary choice once at language design time, and not each time.  Just like (:) is arbitrarily putting the item on the left
16:29:16 <Peaker> ski: oh, bottom-wise?
16:29:27 <idnar> Peaker: I'm pretty sure that's exactly what ski meant
16:29:40 <Peaker> Oh, don't lift type products :)
16:29:40 <ski> Peaker : you could probably avoid bottom-problems by using unboxed stuff ..
16:30:00 <jmcarthur_work> or by wiping properly
16:30:13 <ski> idnar : yes
16:30:27 <Peaker> jmcarthur_work: wiping?
16:30:40 <jmcarthur_work> bad joke
16:30:48 <Peaker> ah
16:30:54 <ski> (if arbitrary choices are needed, i want them done as late as possible .. not as early as possible)
16:30:54 <noteventime> Is it possible to get current line and source name inside a Parsec parser?
16:30:54 <soupdragon> worse than bad :p
16:31:06 <jmcarthur_work> :(
16:31:09 <soupdragon> noteventime. yes
16:31:22 <hackagebot> fingertree 0.0.1.0 - Generic finger-tree structure, with example instances (RossPaterson)
16:31:22 <hackagebot> uacpid 0.0.2 - Userspace Advanced Configuration and Power Interface (DinoMorelli)
16:31:27 * benmachine hugs jmcarthur_work 
16:31:43 <noteventime> soupdragon: And how would I go around doing such a thing? :)
16:31:48 <noteventime> about*
16:31:51 * ski thought jmcarthur_work means some applications of `!' or `seq' by "wiping properly"
16:31:57 <idnar> haha
16:33:28 <ski>   TNil :: (#)
16:33:31 <ski>   TCons :: * -> (#) -> (#)
16:33:32 <ski>   Tuple :: (#) -> *
16:34:06 <ski> then `(a,b,c) = Tuple (TCons a (TCons b (TCons c TNil)))', which would take care of the bottom, iiuc
16:34:28 <tromp> @pl \a b -> b `mod` a == 0
16:34:29 <lambdabot> flip flip 0 . ((==) .) . flip mod
16:34:58 <ski> but i want a way to merge e.g. `(a,b)' and `(c,d,e)' into `(a,b,c,d,e)'
16:35:08 <benmachine> @type flip flip 0
16:35:10 <lambdabot> forall a b c. (Num b) => (a -> b -> c) -> a -> c
16:35:25 <benmachine> how about that
16:39:58 <tromp> @pl \b a -> b `mod` a == 0
16:39:59 <lambdabot> flip flip 0 . ((==) .) . mod
16:40:41 <ski> > 5 `mod` 0
16:40:42 <lambdabot>   * Exception: divide by zero
16:40:53 * ski thinks that possibly should be `5'
16:48:20 <dino-> Does everything in Hackage get jammed on over to the Arch AUR automatically?
16:48:47 <jmcarthur_work> almost everything
16:49:46 <dino-> jmcarthur_work: awesome
16:59:43 <aavogt> @pl (\x y z w -> (((x,y),z),w))
16:59:44 <lambdabot> ((((,) .) . (,)) .) . (,)
16:59:51 <aavogt> @type (\x y z w -> (((x,y),z),w))
16:59:53 <lambdabot> forall t t1 t2 t3. t -> t1 -> t2 -> t3 -> (((t, t1), t2), t3)
17:00:27 <aavogt> @type uncurry . uncurry . uncurry
17:00:28 <lambdabot> forall b c b1 a b2. (a -> b2 -> b1 -> b -> c) -> (((a, b2), b1), b) -> c
17:01:32 <aavogt> @type uncurry (,)
17:01:34 <lambdabot> forall a b. (a, b) -> (a, b)
17:01:35 <soupdragon> @type uncurry . uncurry . uncurry . uncurry . uncurry
17:01:36 <lambdabot> forall b c b1 b2 b3 a b4. (a -> b4 -> b3 -> b2 -> b1 -> b -> c) -> (((((a, b4), b3), b2), b1), b) -> c
17:01:50 <aavogt> @type curry.curry
17:01:52 <lambdabot> forall a b b1 c. (((a, b), b1) -> c) -> a -> b -> b1 -> c
17:02:36 <ski> @type uncurry id
17:02:37 <lambdabot> forall b c. (b -> c, b) -> c
17:03:02 <copumpkin> @pl f -> f . f . f
17:03:03 <lambdabot> (line 1, column 3):
17:03:03 <lambdabot> unexpected ">" or "-"
17:03:03 <lambdabot> expecting variable, "(", operator or end of input
17:03:07 <copumpkin> @pl \f -> f . f . f
17:03:08 <lambdabot> ap (.) (join (.))
17:03:10 <aavogt> @type (,,,)
17:03:11 <lambdabot> forall a b c d. a -> b -> c -> d -> (a, b, c, d)
17:04:08 <aavogt> @pl (\x y z -> ((x,y),z))
17:04:09 <lambdabot> ((,) .) . (,)
17:04:52 <aavogt> I'm using applicative functors
17:04:57 <soupdragon> @type (($) .) .) (,)
17:04:59 <lambdabot> parse error on input `)'
17:05:10 <roconnor> anyone know how to tell if a polynomial over some field is irreducible or not?
17:05:19 <aavogt> and I want to apply a function  f a -> f a
17:05:30 <roconnor> in a finite field I can just try all low degree polynomials,
17:05:41 <themroc--> ski?
17:05:46 <roconnor> but if the field isn't finite, I don't know how.
17:06:03 <aavogt> while the intermediate values are chained together with <*>
17:06:10 <aavogt> I don't have the function to apply yet
17:06:12 <copumpkin> aavogt: hm?
17:06:43 <aavogt> so it doesn't typecheck
17:07:03 <copumpkin> aavogt: I'm not sure I understand
17:07:14 <aavogt> @paste I will
17:07:15 <lambdabot> Haskell pastebin: http://hpaste.org/new
17:07:23 <copumpkin> thanks :)
17:07:32 <aavogt> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7059#a7059
17:07:37 <aavogt> is some of the code
17:07:55 <copumpkin> ok
17:08:08 <copumpkin> what's the error?
17:08:17 <soupdragon> why (\x y z w -> (((x,y),z),w))?
17:08:30 <aavogt> I think that could be an answer
17:08:35 <soupdragon> not some constructor?
17:09:20 <aavogt> yeah, it could be a constructor
17:09:45 <aavogt> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7059#a7060
17:09:46 <ski> themroc-- ?
17:10:25 <aavogt> so I would like to, independently of grouping in the datastructure, group the elements of the formlet
17:10:47 <aavogt> fieldLegend just adds a fieldset around the values
17:11:09 <aavogt> copumpkin: there isn't really an error
17:11:16 <copumpkin> oh :)
17:11:25 <aavogt> its just really awkward to have to unpack the values
17:11:40 <copumpkin> I typically put a constructor where your lambda is
17:11:57 <aavogt> I guess I could just rearrange my data types
17:11:59 <copumpkin> you might also want to look at she's idiom brackets
17:12:24 <aavogt> copumpkin: she is not googleable
17:12:26 <aavogt> @where she
17:12:27 <lambdabot> I know nothing about she.
17:12:36 <copumpkin> http://www.e-pig.org/epilogue/
17:12:37 <copumpkin> :)
17:12:38 <aavogt> I recall seeing something about it
17:13:42 <aavogt> hmm, I think I'll just rearrange my data
17:18:08 <aavogt> at least there's an option of repeated uncurry if required
17:29:45 <themroc--> why in hell does foldr1 has a number in its name?
17:30:14 <themroc--> i dont see any logic :p
17:30:35 <soupdragon> @karma themroc
17:30:36 <lambdabot> themroc has a karma of -5
17:30:46 <themroc--> hell
17:30:49 <themroc--> @karma themroc
17:30:50 <lambdabot> themroc has a karma of -5
17:30:56 <themroc--> why in hell
17:30:57 <themroc--> @karma themroc
17:30:58 <lambdabot> themroc has a karma of -5
17:31:02 <themroc--> wtf
17:31:04 <themroc--> @karma themroc
17:31:04 <lambdabot> themroc has a karma of -5
17:31:07 <themroc--> hmm
17:31:18 <themroc--> bla?
17:31:19 <themroc--> @karma themroc
17:31:20 <lambdabot> themroc has a karma of -5
17:31:22 <dolio> themroc--
17:31:22 <aavogt> 1 for it takes 1 elemen of the list to begin with?
17:31:27 <ski> why are you repeating yourself ?
17:31:28 <dolio> @karma themroc
17:31:28 <lambdabot> themroc has a karma of -6
17:31:33 <dolio> themroc++
17:31:41 <aavogt> themroc--: now?
17:31:57 <aavogt> @karma themroc
17:31:58 <lambdabot> themroc has a karma of -5
17:32:03 <rovar> hey all.. I'm working on the 20 intermediate haskell exercises, I'm stuck on #5.
17:32:07 <Rotaerk> themroc--, it's because it only deals with 1 type?
17:32:09 <Rotaerk> maybe
17:32:09 <themroc--> conspiracy :p
17:32:20 <aavogt> @type foldr1
17:32:22 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
17:32:41 <Rotaerk> @type foldr
17:32:43 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
17:32:51 <rovar> I'm not entirely sure, but I think that the function should look like   (a -> b) -> (EitherLeft x) a -> (EittherLeft x) b
17:33:00 <rovar> but I'm not sure how to produce that.
17:33:36 * ski wonders how `EitherLeft' is defined
17:33:46 <rovar> ah.
17:33:58 <rovar> http://dibblego.wordpress.com/2008/09/18/20-intermediate-haskell-exercises/
17:34:56 <mauke> that looks like #4, not #5
17:34:58 <byorgey> rovar: well, start with the types.  what type should furry have?
17:35:18 <rovar> mauke, you're right
17:35:37 <rovar>  (a -> b) -> f a -> f b
17:35:38 <byorgey> oh, you already said.  yes, that's the right type.
17:35:50 <byorgey> and here, f = EitherLeft x
17:35:56 <rovar> yar
17:36:08 <Botje> rovar: furry f (EitherLeft e) = case e of Left x -> ; Right y -> ...
17:36:44 <rovar> that makes sense
17:37:14 <Botje> because EitherLeft t is an instance of Fluffy, furry on an EitherLeft t a should give you an EitherLeft t b
17:37:53 <rovar> oui
17:38:13 <rovar> the part I was missing was actually "deconstructing" the eitherleft type
17:38:16 <Botje> translate the newtypes, and you get EitherLeft t a = Either a t, furry (EitherLeft t a) = Either b t
17:38:27 <Botje> so now you know how the structure should change :)
17:38:36 <sgillespie> I'd like to do some simple regex splitting
17:38:45 <sgillespie> having trouble finding much info
17:38:47 <ski>   furry f (EitherLeft (Left  t)) = ...
17:38:48 <ski>   furry f (EitherLeft (Right a)) = ...
17:42:31 <dibblego> hello rovar :)
17:42:54 <rovar> dibblego: hello
17:46:32 <byorgey> sgillespie: have you looked at some of the regex packages on Hackage?  I think some of the usual choices include pcre-light and regex-base (and the various regex-* backend packages)
17:47:34 <byorgey> sgillespie: but I'd also ask... are you SURE you really need regexes? as opposed to (a) a parsing library like Parsec or (b) something simple like Data.List.Split?
17:49:05 * Berengal has generally found regexes to have a lesser place in haskell than other languages because of the standard parsers
17:55:15 <dons> we parse things into ADTs, then pattern match on that, with type safety :)
17:55:37 <lpsmith> Parsec does regexes :)
17:55:49 <mauke> parsers are hard
17:58:19 <Berengal> They're easier than regexes
17:58:36 <mauke> not really
17:58:58 <mauke> I've written a reasonable regex library, but not a parser
17:59:09 <Berengal> Ah, to implement
17:59:21 <mauke> yeah, that's the other issue
17:59:23 <Berengal> I've written a parser, though it's probably not reasonable
17:59:31 <mauke> all existing parser libraries suck
17:59:42 <Berengal> They're easier to use than regexes
17:59:52 <mauke> I disagree
18:00:21 <Berengal> regexes are typically write-only
18:00:35 <mauke> so is haskell
18:00:42 <mauke> until you actually learn the language
18:01:09 <Berengal> I'd rate myself fairly decent with regexes, but I've often found I can't read the one I just wrote
18:03:46 <Cale> I agree about regexes being write-only. I would almost always use parsec over them for anything real.
18:03:52 <Shurique> what would be the equivalent of a dynamic array in Haskell?
18:04:00 <Berengal> Shurique: List
18:04:03 <Cale> Shurique: What do you mean by 'dynamic'?
18:04:13 <Cale> Shurique: Haskell has many array types.
18:04:14 <copumpkin> Shurique: tibbe just made something like that
18:04:32 <Shurique> Cale: http://en.wikipedia.org/wiki/Dynamic_array
18:04:33 <Berengal> Okay, list isn't equivalent, but it's the usual analogy
18:04:44 <rovar> "Some people, when confronted with a problem, think 'I know, I'll use regular expressions. Now they have two problems' "
18:04:45 <Shurique> specifically, I'm looking for constant-time indexing and insertion at the end
18:05:00 <benmachine> lists don't have constant-time indexing
18:05:22 <Berengal> How about something like lazy bytestrings?
18:05:27 <Cale> Shurique: Probably you want Data.Sequence
18:05:55 <Berengal> I mean, what's the lazy bytestring structure typically called?
18:05:56 <Cale> Lazy bytestrings don't have O(1) insertion at the end, do they?
18:06:01 <Shurique> Cale: I looked at that, but indexing seems to be logarithmic
18:06:14 <byorgey> it is, which isn't usually that big of a deal in practice
18:06:17 <sjanssen> Cale: O(n)
18:06:20 <byorgey> unless you want REALLY long ones
18:06:21 <Cale> Shurique: yeah, but technically so is pointer indirection
18:06:23 <Berengal> > log 64
18:06:25 <lambdabot>   4.1588830833596715
18:06:35 <Cale> Shurique: consider it part of your constant :)
18:06:35 <Berengal> > log 128
18:06:37 <lambdabot>   4.852030263919617
18:06:53 <Berengal> > map log [2^n | n <- [1..]]
18:06:55 <lambdabot>   [0.6931471805599453,1.3862943611198906,2.0794415416798357,2.772588722239781...
18:07:05 <Berengal> Stupid floats...
18:07:24 <Shurique> hmm, okay
18:07:26 <aavogt> > map (log . exp) [1..]
18:07:27 <lambdabot>   [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0,11.0,12.0,13.0,14.0,15.0,16.0,17....
18:07:33 <mauke> Cale: how do I say \cC\d{2},\d{2}(?=\cC\d{2},\d) in parsec?
18:07:37 <Cale> Shurique: It's actually impossible to construct a datastructure which grows arbitrarily and has O(1) lookup. Every datastructure which claims to do this is lying in one way or another.
18:07:50 <Cale> mauke: I can't be bothered to read that.
18:08:24 <Cale> Shurique: You can't even read the entire index in less than O(log n) time.
18:08:46 <mauke> Cale: char '\3' >> exactly 2 digit >> char ',' >> exactly 2 digit >> followedBy (char '\3' >> exactly 2 digit >> char ',' >> digit)
18:09:08 <copumpkin> lol
18:09:19 <Shurique> I'll try Data.Sequence
18:09:48 <Shurique> and perhaps try to implement a growable array too for the heck of it :P
18:09:57 <Berengal> mauke: Easier to read than the regex
18:10:00 <copumpkin> Shurique: speak to tibbe
18:10:05 <mauke> Berengal: yeah, but it doesn't work
18:10:22 <Berengal> mauke: No?
18:10:44 <mauke> > char '\3' >> exactly 2 digit >> char ',' >> exactly 2 digit >> followedBy (char '\3' >> exactly 2 digit >> char ',' >> digit)
18:10:45 <lambdabot>   Not in scope: `exactly'Not in scope: `digit'Not in scope: `exactly'Not in s...
18:10:47 <mauke> no.
18:11:59 <Cale> exactly = replicateM
18:12:39 <copumpkin> :t (*>)
18:12:41 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
18:13:12 <aavogt> @type >>
18:13:14 <lambdabot> parse error on input `>>'
18:13:25 <aavogt> @type (>>)
18:13:27 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
18:14:00 * aavogt wishes that those were the same symbol
18:14:52 * Berengal has found himself using *> in do notation several times
18:15:33 <aavogt> interesting how there isn't a complementary (<<)
18:15:45 <Berengal> @type (<*)
18:15:47 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
18:15:58 <aavogt> @hoogle <<
18:15:59 <lambdabot> Text.XHtml.Frameset (<<) :: HTML a => Html -> b -> a -> b
18:15:59 <lambdabot> Text.XHtml.Strict (<<) :: HTML a => Html -> b -> a -> b
18:15:59 <lambdabot> Text.XHtml.Transitional (<<) :: HTML a => Html -> b -> a -> b
18:16:11 <Berengal> (<*) has different semantics than (<<) would have if it were to match =<<
18:16:32 <mauke> hah, turns out I'm wrong
18:16:34 <mauke> Berengal: it does work
18:16:36 <aavogt> @src (<*)
18:16:37 <lambdabot> (<*) = liftA2 const
18:16:48 <aavogt> @src (>>)
18:16:48 <lambdabot> m >> k      = m >>= \_ -> k
18:17:05 <Berengal> mauke: And it's more readable
18:17:20 <mauke> it's just syntax
18:17:38 <soupdragon> more readable??
18:17:43 <aavogt> Berengal: how would it be different?
18:18:03 <Berengal> mauke: anyway, I could've written a regex like that, but not much more complicated
18:18:04 <aavogt> (<*) executes the left side first
18:18:23 <aavogt> while (<<) would would execute the right first?
18:18:35 <Berengal> aavogt: For (<<) to match (=<<) it would have to execute the right side first, yeah
18:19:22 * Berengal sometimes thinks a (<*>>=) operator would've been useful as well
18:19:36 <roconnor> @type (>>=)
18:19:38 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
18:20:00 <Berengal> a <*>>= b = do r <- a; b r; return r
18:21:53 <copumpkin> how about =<<*>>=
18:21:58 <copumpkin> that would be a pretty epic operator
18:22:11 <copumpkin> and =<<**>>= would flip it
18:22:39 <Berengal> What type would that have?
18:22:48 <copumpkin> haven't decided yet, but it'd be epic
18:23:00 <copumpkin> an epic morphism, even ;)
18:23:01 <benmachine> @type
18:23:03 <lambdabot> on the commandline:
18:23:03 <lambdabot>     Warning: -fno-th is deprecated: use -XNoTemplateHaskell or pragma {-# LANGUAGE NoTemplateHaskell#-} instead
18:23:03 <lambdabot> <no location info>: not an expression: `'
18:23:17 * copumpkin chuckles at his stupidity
18:23:26 <Berengal> I've already decided that if I make an epic operator it's going to be *//-/^\-\\*
18:23:38 <copumpkin> oh my
18:24:45 <Berengal> belt operator -> ==<<**>>==
18:25:28 <copumpkin> pity we can't mix letters in
18:25:40 <copumpkin> ==<<G>>== would be the gucci belt operator
18:25:55 <Berengal> Makes it more fun, in a way though. Requires more skill...
18:26:25 <Berengal> We can still make ==<<\/\/>>== wrestling belt
18:27:08 <copumpkin> oh that is awesome
18:27:12 <copumpkin> but what would it do?
18:27:34 <Berengal> *snicker*: do website <- Http \/\/-\/\/-\/\/ "example.com"
18:27:42 <copumpkin> lol
18:28:21 <Berengal> wrestling belt would wrestle
18:28:39 <mauke> int main(void) {
18:28:40 <mauke>   http://example.com/
18:28:40 <mauke>   return 0;
18:28:40 <mauke> }
18:28:49 <mauke> (valid C code)
18:28:53 <copumpkin> > let (==<<\/\/>>==) x y = text (x ++ ' ':y) in "BRING ON" ==<<\/\/>>== "THE PAIN"
18:28:55 <lambdabot>   BRING ON THE PAIN
18:28:58 <copumpkin> mauke: ah, that's cute
18:29:04 <copumpkin> doesn't do much though :P
18:29:07 <Berengal> mauke: Neat, but does it connect to the internet?
18:29:16 <Botje> mauke: even in C89 ?
18:29:17 <copumpkin> it's just a label and a comment :P
18:29:19 <benmachine> yeah I noticed that when I pasted a URL in the wrong window and the syntax highlighting was ok with it
18:29:24 <mauke> Botje: no :-)
18:29:26 <copumpkin> but the // won't work on older cs
18:29:36 <Botje> oof :)
18:29:41 <benmachine> you can have a maximum of one URL in scope though :P
18:29:47 <benmachine> well
18:29:52 <benmachine> one URL per protocol
18:29:53 <copumpkin> it's unconditionally valid java or c++ though
18:29:55 <mauke> but // comments are an extremely common extension
18:29:59 <copumpkin> yeah
18:30:27 <Berengal> How is that valid java?
18:31:02 <copumpkin> Berengal: oh, I was taking the URL in isolation :)
18:31:05 <mauke> some compilers also accept #include <stdio.h>  </stdio.h>
18:31:36 <Berengal> mauke: That makes me want to both laugh and cry
18:32:52 <copumpkin> I gave up on the preprocessor idea, so now I'm messing around with a part of GHC that I've never messed around with
18:33:17 <soupdragon> what preprocessor??
18:33:34 <copumpkin> the context alias (and associated contexts) preprocessor I wanted to make
18:34:06 <soupdragon> did you try using she?
18:34:14 <copumpkin> for what?
18:34:20 <copumpkin> as a basis for my preprocessor?
18:34:44 <copumpkin> he basically wrote a simple parser combinator library and then a simple haskell parser on top of it
18:35:15 <copumpkin> which seemed like a lot of work, so I was going to edit haskell-src-exts, but then I decided to just modify the original alex parser in ghc and go with an integrated approach
18:36:26 <rovar> Hey all, still having trouble with #4, I can't figure out how to construct the aproprate resulting type:   http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2981#a2981
18:36:45 <copumpkin> :o
18:36:56 <copumpkin> you sure you copied that down right?
18:37:10 <rovar> the last 3 lines are mine, and are incorrect
18:37:22 <copumpkin> the method in that class looks very fishy :)
18:37:39 <rovar> fishy? or furry?
18:37:43 <Twey> Should be -> f b
18:37:58 <rovar> what is b?
18:38:07 <Twey> The result type of the function
18:38:08 <copumpkin> furry :: (a -> b) -> f a -> f b
18:38:13 <rovar> right
18:38:19 <copumpkin> not furry :: (a -> b) -> f a -> f
18:38:26 <Twey> *nod*
18:38:29 <rovar> how do I operate on b?
18:38:35 <Twey> f is a type constructor, so that doesn't make any sense
18:38:54 <rovar> f is a function...
18:38:55 <Twey> And you're missing a bracket on the end of the definition of EitherRight
18:39:05 <copumpkin> rovar: it's sort of a function, but it works on types
18:39:06 <Twey> No
18:39:09 <Twey> Yeah
18:39:11 <Twey> Er
18:39:13 <Twey> Kind of.
18:39:20 <copumpkin> it's called a type constructor :)
18:39:21 <Twey> The ‘f’ here doesn't stand for ‘function’
18:39:32 <Twey> It would be giving the game away a bit to tell what it does stand for
18:39:39 <rovar> the parameter f is (a -> b)  that is a function, yea?
18:39:48 <Berengal> It stands for (Furry f) => f
18:39:53 <benmachine> erm
18:40:03 <copumpkin> rovar: you're trying to put the (a -> b) function into the Furry!
18:40:06 <benmachine> the letter f is used in two different contexts in that paste
18:40:14 <rovar> yea.. i should clarify.
18:40:17 <copumpkin> (a -> b) -> (f a -> f b)
18:40:25 <benmachine> I believe people are talking about one and listening about the other :P
18:40:34 <Twey> Ah, aye :)
18:40:46 <Berengal> time to do some alpha reduction
18:41:03 * copumpkin alpha-reduces Berengal
18:41:15 <Berengal> Rename the f in the instance declaration fun(ction)
18:42:06 <rovar> okay.. fixed:  http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2984#a2984
18:42:09 <rovar> yes
18:42:22 <rovar> f in the class is a type constructor, sure
18:42:44 <rovar> the fault, dear brutus, is not in the class, but in the instance
18:42:59 <rovar> because I wrote that part
18:43:01 <wmealing_> I know i'll probably get to this in a future chapter of the books i'm reading.. but  how does making something "interact with the outside world" impure ?
18:43:08 <wmealing_> make code impure, more correctly
18:43:34 <benmachine> wmealing_: because you don't know what the outside world's going to do?
18:43:36 <Berengal> rovar: The thing to notice is that a type constructor EitherLeft t cannot change the type of t
18:43:40 <rovar> wmealing_: pure functions are always deterministic.. if you pass in a value, you'll always get the same value back.
18:43:53 <Berengal> rovar: Meaning the Right values always have to be of the same type
18:43:55 <rovar> wmealing_:  if you ask the outside world for a value, it won't always be the same value.
18:44:08 <wmealing_> rovar, i see.. so its the environment effects the execution.
18:44:18 <wmealing_> s/its/it is if/
18:44:21 <rovar> wmealing_: invariably :)
18:44:29 <wmealing_> ok, that clears things up.
18:44:30 <dibblego> wmealing, consider a basic example, readByteFromFile
18:44:32 <copumpkin> whoa, real world haskell iphone app!
18:44:56 <rovar> Berengal:  I gather that I should be constructing using different variables, but I don't know where from
18:45:16 <rovar> Berengal: actually.. i'm not sure how e relates to the parameters to EitherLeft
18:45:17 <wmealing_> is it just in the programmers "mind" that its impure, or is it something you have to manage differently (i come from c/python background)
18:45:54 <dibblego> wmealing, in some languages readFileFromByte would have the type Byte, but in Haskell, the fact that it is impure is managed by the type system thus IO Byte
18:46:09 <wmealing_> ok.
18:46:19 <wmealing_> I'm kinda getting it.
18:46:28 <rovar> wmealing_:  When dealing only with pure functions, everything is mathematically correct, this offers tremendous advantages when analyzing (and optimizing) programs, the order in which you execute things no longer matters.
18:46:52 <Berengal> rovar: What to realize is that the type variable 't' is bound inside the instance declaration. It can't change or be polymorphic. The types a and b, however, are, they're rebound for each function
18:47:04 <Berengal> Might be badly explained...
18:47:19 <rovar> Berengal: so the 1st param of Eitherleft is bound, but not the second?
18:47:25 <wmealing_> thanks guys, appreciate the clear answers.
18:47:33 <rovar> if so, then how do I swap the values?
18:47:46 <Berengal> rovar: Yes. In the EitherLeft case, furry has type (a -> b) -> (EitherLeft t) a -> (EitherLeft t) b
18:48:02 <rovar> right
18:48:44 <Berengal> Now, EitherLeft, being a simple Either newtype, has either a 't' value, or an 'a' value. You only know how to transform the 'a' value, because you only have an (a -> b) function
18:49:03 <Berengal> So what to do in the case where you've got a 't' value?
18:49:20 <rovar> no idea
18:49:51 <Berengal> Applying 'o' to it is wrong, because 'a' and 't' doesn't have to represent the same type
18:49:57 <byorgey> rovar: remember, you have to produce a value of type  (EitherLeft t b)
18:50:18 <soupdragon> http://www77.wolframalpha.com/input/?i=haskell
18:50:41 <soupdragon> < 200 people per year learn haskell?
18:51:13 <rovar> How do I construct that?
18:51:15 <Berengal> rovar: So you have a value of type 't' and need to produce one of type EitherLeft t b. What to do?
18:51:31 <soupdragon> most haskellers are: 74
18:51:35 <copumpkin> bbl
18:51:36 <kulakowski> soupdragon: Obviously, there's only like 600 of us in here and Haskell is more than 600/200 years old
18:53:24 <benmachine> @type fmap
18:53:26 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:56:24 <rovar> Berengal:  What exactly does (EitherLeft t) a  mean?  Does that mean we're applying the partially applied EitherLeft constructor to a?
18:56:33 <aavogt> @users
18:56:34 <lambdabot> Maximum users seen in #haskell: 658, currently: 583 (88.6%), active: 16 (2.7%)
18:56:59 <kaf_> @users
18:57:00 <lambdabot> Maximum users seen in #haskell: 658, currently: 583 (88.6%), active: 17 (2.9%)
18:57:10 <Berengal> rovar: Yeah. The parenthesis are simply for grouping. I was simply string-replacing f in the type of furry with (EitherLeft t)
18:57:49 <Berengal> (EitherLeft t) a = EitherLeft t a
18:59:18 <rovar> so in the Left case of t, I have a
18:59:32 <rovar> but not b
18:59:45 <Berengal> No, if you have a t, you don't have an a
18:59:58 <Berengal> If you have an a, getting a b is easy
19:00:09 <rovar> surce
19:00:11 <rovar> sure
19:01:51 <rovar> is t the 1st parameter of EitherLeft?
19:01:56 <Berengal> You have _either_ a 't' or an 'a'. You need _either_ a 't' or a 'b'. If you have an 'a', you can't make up a 't, but you can easily make a 'b'. If you have a 't' you can't make a 'b', but you can easily make a 't'
19:02:16 <Berengal> Yes, t is the first parameter, which confusingly enough is the second parameter to the underlying Either
19:02:48 <rovar> right.. which is why i thought that in the left case I'd have an a, and in the right case I'd have a t
19:03:04 <Berengal> Oh, that's still true
19:03:36 <rovar> in either case, I need to produce EitherLeft t   but in the left case, I don't have a t
19:03:47 <rovar> or do I..
19:03:48 <Berengal> No, youn eed to produce EitherLeft t a
19:03:54 <Berengal> s/a/b/
19:04:15 <Berengal> You can't produce an EitherLeft t, because that's not a type
19:04:30 <Berengal> It's a type constructor, and type constructors don't have values
19:04:32 <rovar> but I don't have a t in the left case, so how do I make EitherLeft t a ?
19:04:49 <rovar> or can I use an as value?
19:04:59 <Berengal> Do you need a 't' value?
19:05:37 <rovar> I guess I can return what was passed in in the left case, yea?
19:05:53 <mmmulani> how do you convert an integer to a char?
19:06:01 <Berengal> Well, it's of type 'a', but you need either a 't' or a 'b'...
19:06:06 <Berengal> Can you make either of those?
19:06:11 <dibblego> > digitToInt '5'
19:06:13 <lambdabot>   5
19:06:22 <mmmulani> > chr 97
19:06:23 <dibblego> > intToDigit 55
19:06:24 <lambdabot>   'a'
19:06:25 <lambdabot>   * Exception: Char.intToDigit: not a digit 55
19:06:25 <Berengal> > toEnum 65 :: Char
19:06:27 <lambdabot>   'A'
19:06:28 <dibblego> > intToDigit 5
19:06:29 <mmmulani> sweet
19:06:29 <lambdabot>   '5'
19:06:35 <rovar> Berengal, i don't see how I could make a t,
19:06:47 <Berengal> rovar: Okay then, can you make a b?
19:06:58 <rovar> sure
19:07:01 <rovar> given an a
19:07:13 <Berengal> And an a is what you've got in the left case
19:07:40 <Berengal> So you don't need a t then
19:07:52 <rovar> why not?
19:08:08 <Berengal> Because you only need one value, of either type t or type a
19:08:21 <Berengal> You don't need both. In fact, you've only got room for one of them
19:09:23 <rovar> so how do I construct a new EitherLeft type then? I have to use either Right or Left, correct?
19:10:17 <Berengal> Correct
19:10:38 <Berengal> @type Left
19:10:40 <lambdabot> forall a b. a -> Either a b
19:10:41 <Berengal> @type Right
19:10:43 <lambdabot> forall b a. b -> Either a b
19:11:11 <rovar> ah
19:11:18 <rovar> that makes sense.. here is my answer then:
19:11:38 <rovar> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2985#a2985
19:11:50 <Berengal> \o/
19:12:06 <Berengal> Nice :)
19:12:12 <rovar> i'm not sure what that symbol means
19:12:20 <Berengal> Arms in the air
19:13:23 <rovar> ah
19:13:26 <rovar> thanks for your help
19:13:31 <Berengal> No problem
19:33:27 * benmachine twigs on the exercises what Fluffy and Misty refer to
19:56:46 <hackagebot> uacpid 0.0.3 - Userspace Advanced Configuration and Power Interface (DinoMorelli)
20:10:28 <kulakowski> return (,,,,,,) `ap` tree `ap` tree `ap` tree `ap` tree `ap` tree `ap` tree `ap` tree -- is ugly and liftM7 does not exist, is there a better way to do this?
20:12:34 <Berengal> zip7 <$> tree <*> tree <*> tree <*> tree <*> tree <*> tree <*> tree
20:13:06 <roconnor> kulakowski: doesn't seem that ugly to me
20:13:36 <roconnor> or no more that the fact you are using (,,,,,,)
20:13:40 <Berengal> Wait, that wasn't zip at all...
20:13:56 * Berengal should be going to bed, except he has work in a couple of hours
20:14:28 <kulakowski> roconnor: Not so much ugly as, it seems there should be a way to not type exactly the same thing 7 times.
20:15:40 <roconnor> kulakowski: there are other waysish, but they are a lot of work
20:16:04 <roconnor> and use extensions
20:16:06 <aavogt> @type join $ join (,,)
20:16:07 <lambdabot> forall a. a -> (a, a, a)
20:16:14 <__marius__> does anybody have a favorize haskell embedded web server?
20:16:18 <__marius__> favorite, even
20:16:21 <aavogt> @type join $ join $ join $ join (,,,,)
20:16:22 <lambdabot> forall e. e -> (e, e, e, e, e)
20:16:25 <roconnor> favourite even
20:16:29 <__marius__> or that!
20:16:30 <Berengal> @pl \f v -> f <$> v <*> v <*> v <*> v <*> v <*> v <*> v
20:16:31 <lambdabot> (. ((<*>) =<< (<*>) =<< (<*>) =<< (<*>) =<< (<*>) =<< join (<*>))) . (<$>)
20:16:36 <Berengal> :/
20:16:36 <Axman6> good man roconnor
20:16:36 <__marius__> yes, favourite please :-)
20:16:44 <copumpkin> then you have to write join a bunch of times instead :P
20:17:05 <Berengal> copumpkin: join them :P
20:17:19 <copumpkin> :t join join
20:17:20 <lambdabot>     Occurs check: cannot construct the infinite type:
20:17:21 <lambdabot>       m = (->) (m (m a))
20:17:21 <lambdabot>     Probable cause: `join' is applied to too few arguments
20:17:21 <Axman6> > join . join . join $ (,,,,,,)
20:17:23 <lambdabot>   Overlapping instances for GHC.Show.Show
20:17:23 <lambdabot>                              (a -> ...
20:17:26 <Axman6> :t join . join . join $ (,,,,,,)
20:17:27 <lambdabot> forall a e f g. a -> e -> f -> g -> (a, a, a, a, e, f, g)
20:17:43 <Axman6> :t join .  join . join . join $ (,,,,,,)
20:17:44 <lambdabot> forall a f g. a -> f -> g -> (a, a, a, a, a, f, g)
20:17:44 <Berengal> @type join (join . join)
20:17:46 <lambdabot>     Occurs check: cannot construct the infinite type:
20:17:47 <lambdabot>       m = (->) (m (m (m a)))
20:17:47 <lambdabot>     Probable cause: `.' is applied to too few arguments
20:18:00 <Axman6> :t join .  join . join . join $ (,,,,,,,)
20:18:02 <lambdabot> forall a f g h. a -> f -> g -> h -> (a, a, a, a, a, f, g, h)
20:18:07 <Axman6> :t join .  join . join . join $ (,,,,,)
20:18:08 <lambdabot> forall a f. a -> f -> (a, a, a, a, a, f)
20:18:24 <Axman6> :t join .  join . join . join . (,,,,,)
20:18:26 <lambdabot> forall a f. a -> f -> (a, f, f, f, f, f)
20:18:30 <Axman6> :\
20:18:41 <Axman6> still works i guess
20:18:54 <aavogt> keep joining
20:19:42 <roconnor> kulakowski: in some sense you have to say something 7 times, if even the peano type number Succ Succ Succ Succ Succ Succ Succ Zero.
20:19:59 <roconnor> although I suppose there is something you could do with binary notation.
20:20:29 <Berengal> OR you could just write liftM7
20:20:43 <roconnor> but you can use a "binary" notation for your <*> trees too if you want to logarithmically reduce the number of things you type
20:20:50 <copumpkin> liftBMWM3
20:20:55 <roconnor> Berengal: that's crazy talk
20:21:07 <roconnor> @type liftM4
20:21:09 <lambdabot> forall a1 a2 a3 a4 r (m :: * -> *). (Monad m) => (a1 -> a2 -> a3 -> a4 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m r
20:21:19 <Berengal> roconnor: Yeah, I know. It uses monads, and those things are _hard_!
20:21:31 <kulakowski> monads! oh no
20:21:42 <roconnor> @type liftM4 (,,,,,,)
20:21:43 <lambdabot> forall a1 a2 a3 a4 e f g (m :: * -> *). (Monad m) => m a1 -> m a2 -> m a3 -> m a4 -> m (e -> f -> g -> (a1, a2, a3, a4, e, f, g))
20:21:50 <kulakowski> and thanks all
20:22:48 <Berengal> *snicker* categorical spidey-sense...
20:24:07 <roconnor> @type \a b c d -> liftM4 (,,,,,,) a b c d `ap` liftM3
20:24:08 <lambdabot> forall a1 a2 a3 a4 f g a11 a21 a31 r (m :: * -> *). (Monad m) => ((a11 -> a21 -> a31 -> r) -> a1) -> ((a11 -> a21 -> a31 -> r) -> a2) -> ((a11 -> a21 -> a31 -> r) -> a3) -> ((a11 -> a21 -> a31 -> r)
20:24:08 <lambdabot> -> a4) -> (a11 -> a21 -> a31 -> r) -> f -> g -> (a1, a2, a3, a4, m a11 -> m a21 -> m a31 -> m r, f, g)
20:24:21 <Berengal> :O
20:24:35 <roconnor> @type \a b c d -> liftM3 `ap` liftM4 (,,,,,,) a b c d
20:24:36 <lambdabot> forall a2 a3 r a1 a21 a31 a4 e f g. (((f -> g -> (a1, a21, a31, a4, e, f, g)) -> a2 -> a3 -> r) -> a1) -> (((f -> g -> (a1, a21, a31, a4, e, f, g)) -> a2 -> a3 -> r) -> a21) -> (((f -> g -> (a1, a21,
20:24:37 <lambdabot>  a31, a4, e, f, g)) -> a2 -> a3 -> r) -> a31) -> (((f -> g -> (a1, a21, a31, a4, e, f, g)) -> a2 -> a3 -> r) -> a4) -> ((f -> g -> (a1, a21, a31, a4, e, f, g)) -> a2 -> a3 -> r) -> (e -> a2) -> (e ->
20:24:37 <lambdabot>  a3) -> e -> r
20:24:42 <roconnor> bah
20:25:22 <Berengal> It's type signatures like these that make me happy I'm not programming in a manifestly typed language
20:26:19 <Rotaerk> heh, geez
20:30:59 <mmmulani> how does one resolve a Couldn't match expected type `Int' against inferred type `Integer'" error?
20:31:21 <aavogt> fromIntegral
20:32:30 <aavogt> or use genericLength or genericWhateverFunctionThatOtherwiseReturnsAListVersion from Data.List
20:32:38 <aavogt> mmmulani: ^^ does this help?
20:32:52 <mmmulani> ack no
20:33:01 <mmmulani> but I think I'm applying it in the wrong spot
20:33:27 <mmmulani> sweet
20:33:27 <aavogt> @paste the code that brings up the error?
20:33:27 <lambdabot> Haskell pastebin: http://hpaste.org/new
20:33:44 <mmmulani> think I solved it
20:42:44 <Berengal> Is there an instance for Alternative Either?
20:44:46 <Berengal> Perhaps I should just write my own...
20:45:23 <copumpkin> whoops: ../test.hs:1:18: Not in scope: data constructor `Show'
20:45:55 * Berengal is still looking for a good way to "parse" a recursive structure
20:49:39 <rfmge> so I have some information in two trees, and I need to be able to modify it in one tree and access that change in the other tree
20:49:46 <rfmge> what's the best way to go about this?
20:49:51 <rfmge> I was looking into IORef, but I don't want to put everything into IO unless I have to
20:51:07 <Berengal> You're doing mutation, so putting it in IO is very suggestive...
20:51:21 <Berengal> Otherwise, some other monad that provides mutable references
20:51:41 <Axman6> like ST
20:51:49 <Berengal> Indeed, like ST.
20:51:58 <Axman6> MVars might be rather safe too
20:52:55 <copumpkin> they're in IO again
20:53:14 <rfmge> okay
20:53:31 <Berengal> However, other than IO, such a monad can't allow putting the references of one computation sequence into another, because the underlying map doesn't exist there...
20:54:09 <rfmge> so using something like IORef, I can pass the tree to pure functions and modify the parts of it not in the IORef
20:54:34 <rfmge> so if I store a tuple of (Int, Int, IORef Int) for example, I can look at the first two in pure functions?
20:54:45 <Berengal> Yes
20:55:18 <rfmge> okay, that should work
20:57:17 <Axman6> rfmge: any reason you're us9ing IORefs instead of MVars?
20:57:32 <Axman6> they're a bit safer when you're using them concurrently
20:58:03 <rfmge> I haven't looked at MVars, just chose IORef arbitrarily
20:59:03 <Axman6> righto
20:59:05 <Berengal> MVars are IORefs, except only one thread can look at the data at a time
20:59:31 <Berengal> So a sort of IORef (Maybe a)
20:59:46 <Axman6> well, sort of. they can be empty or full, and will block if you try and read an empty one, until another thread fills it
21:00:09 <Berengal> There's also tryTakeMVar
21:00:10 <Axman6> they're fast because the RTS handles them, and activates threads when needed
21:00:45 <rfmge> fast is good :)
21:01:32 <rfmge> I haven't seriously tried to parallelize it yet but I'm planning on doing so later, so I guess MVars are a better choice
21:02:13 <Axman6> yeah, MVars++ for parallelism
21:02:18 <Berengal> You could also put both trees in an MVar, but that's similar to locking the entire tree structure
21:02:56 <rfmge> I do computations with each subtree separately, so locking the entire tree doesn't sound so good
21:03:01 <rfmge> how much overhead do MVars/IORefs have compared to changing a variable in other impure languages?
21:04:00 <Berengal> Also, There's STM. Don't know how much slower it is if you're only running on one thread, but it's somewhat slower than MVars in concurrent systems, but they're composable, and I like composability
21:04:22 <Axman6> STM isn't all that fast
21:04:42 <Berengal> Even on a single thread?
21:05:16 <Axman6> not sure
21:05:45 <Berengal> rfmge: IORefs are (managed) pointers. I don't think they're slower than pointers in c
21:05:45 <Axman6> but MVars are damn fast, compared to what's available in other languages
21:05:56 <rfmge> what I'm doing basically is setting a flag on each node (red or blue) so STM is overkill
21:06:39 <rovar> i like that mvars combine in what step what is usually done with 2+ , but still have the flexibility to be used as simple critical sections.
21:07:00 <Berengal> I like STM for being composable...
21:07:15 <rovar> yea.. i miss that so much in my daily c++ job
21:07:15 <copumpkin> composable shcomposable
21:07:39 <rovar> nothing is composable in c++, unless you want to muck with functors
21:08:19 <copumpkin> did c++ call their function objects functors just cause functor sounds cool?
21:08:22 <Berengal> At least you've got templates in c++. Java doesn't even have that, plus it reeks of "enterprise"
21:08:42 <rovar> i agree
21:08:52 <rovar> actually.. i think java is the worst thing to happen to computer science.
21:09:03 <rovar> it set the entire industry back a decade.
21:09:23 * Berengal is working on a system that /converts arguments to xml before calling various methods/
21:09:35 <rovar> ?
21:09:36 <Berengal> I mean, whoever came up with that idea?
21:09:40 <Berengal> JAX-WS
21:09:47 <Berengal> On an internal system...
21:09:49 <mike-burns> Java brought better OO, and OO thinking, to a very imperative industry.
21:09:49 <rovar> xml is the 2nd worst thing to happen to computer science
21:09:50 <Berengal> Mostly, anyway
21:09:54 <monochrom> Java brought garbage collection to the mainstream.
21:09:59 <copumpkin> oh my god, that is awesomely enterprisey, and I bet it's industrial-stength and award-winning too
21:10:01 <mike-burns> Also, CS is not the industry. They're very different.
21:10:18 <rovar> okay.. it did make GC acceptable..
21:10:36 <Berengal> copumpkin: Currently it sits on a P4 running glassfish and oracle...
21:10:40 <Berengal> Oh, and 2GB ram
21:10:47 <Berengal> And it's my development machine :(
21:10:49 <copumpkin> oh wow, so it's scalable too!
21:11:01 <copumpkin> scalable, enterprisey, industrial-stength, and award-winning!
21:11:20 <rovar> don't forget  xml integrated and mission critical
21:11:29 <copumpkin> nice!
21:11:44 <mike-burns> Java isn't as good as Haskell, or Ruby, or Python, or a ton of other things I'd rather use, but it has a niche and the world is indeed better off with it.
21:11:52 <rovar> mission critical is one of my favorite phrases.. s
21:11:52 <Berengal> If by scaleable you mean I've made a macro that starts redeploying the app and puts a 5 min smoking break + 30 mins debugging into my schedule automatically, then yes
21:12:02 <rovar> simply because it is the coolest way to say absolutely nothing at all
21:12:16 <monochrom> Java brought "no multiple inheritance of fields" to the mainstream too. It broke the C++ "yes to multiple inheritance" monopoly. You know, "teach the debate!"
21:12:46 <rovar> who needs multiple inheritance when you have mixins
21:13:08 <rovar> oh yea.. java doesn' have them.
21:13:34 <Axman6> i don't really have a problem with Java. though sometimes it's far too complicated to do simple things
21:14:04 <monochrom> If you keep finding things java doesn't have, you will find infinitely many and your point is still irrelevant.
21:14:05 <Berengal> Oh, and object oriented? XML knows nothing about methods! We like *Handler classes, and *HandlerFactory classes. Encapsulation means making everything private, then creating do-nothing getters and setters...
21:14:07 <mike-burns> It's mostly that the syntax is cumbersome, and it didn't (doesn't?) optimize tail calls.
21:14:17 <rovar> i forget who, but someone wrote an excellent essay called the land of nouns.
21:14:23 <rovar> it puts into words most of what I hate about Java.
21:14:56 <Berengal> At least all the bugs happen in one place, somewhere between line 150 and line 7500 in the EverythingHandler
21:15:05 <Berengal> Okay, I think I'm done ranting...
21:15:07 <soupdragon>  http://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html ?
21:15:09 <monochrom> I thought Java was a land of adjectives.  Comparable, Enumerable, ...
21:15:31 <rovar> soupdragon: that's the one
21:15:39 <rovar> monochrom: all describing nouns
21:15:45 <rovar> what we need are verbs, dammit
21:15:48 <rovar> like haskell.
21:15:58 <rovar> verbs operating on verbs.. that's how you get shit done..
21:16:13 <Berengal> main = do it; print it
21:16:14 <mike-burns> Shouldn't we have a mix? Or will that just give us Perl?
21:16:14 <copumpkin> getShitDone :: a - >b
21:16:19 <copumpkin> a -> b
21:16:36 <rovar> that's a great shirt.
21:16:44 <rovar> 1st line:              a  ->  b
21:16:52 <rovar> 2nd line:                Haskell. Get Shit Done.
21:17:21 <soupdragon> Because the Verb citizens in this Kingdom have it very, very bad.
21:17:21 <monochrom> 3rd line: Burma Shave
21:18:02 <soupdragon> he's just saying java doesn't have first class functions?
21:18:12 <rovar> haha
21:18:24 <Berengal> It has something better: first class objects
21:18:25 <rovar> soupdragon: that's a fundamental flaw in many languages.  :)
21:18:31 <soupdragon> no
21:18:50 <rovar> functions should be first class objects.. if you wish to speak in terms of objects.
21:18:51 <Berengal> java and c++ are the only mainstream languages without first class functions
21:18:53 <monochrom> I don't understand why those blogs are so verbose, more verbose than the programming languages they are criticizing.
21:18:55 <soupdragon> is that all he is saying?
21:19:13 <soupdragon> hahaha monochrom spot on
21:19:14 <mike-burns> Berengal: Java and C++ are the only mainstream languages.
21:19:15 <rovar> Berengal: Ruby and C and  maybe fortran?
21:19:19 <Berengal> monochrom: They've gotten used to a verbose style
21:20:02 <Berengal> rovar: Ruby has lambda (not to mention blocks in general), C has function pointers, fortran I don't know anything about, but if it doesn't I'll just claim it doesn't fit my definition of mainstream
21:20:02 <rovar> In ruby they're object inasmuch as everything is an object, but they still don't get much love
21:20:36 <mike-burns> In Ruby, methods are not first class. You can construct a Proc and pass it around, but a Proc is not a method.
21:20:37 <rovar> There is still a lot of fortran running wall st..  I've had to soil my hands a bit with it.
21:20:45 <rovar> mike-burns: right.
21:21:08 <rovar> ruby's blocks and procs are nifty.. but it just leaves me wanting more.. like a real, consistent functional language.
21:21:24 <soupdragon> who cares the argument is stupid
21:21:28 <mike-burns> Right.
21:21:29 <rovar> i think it's ruby's inconsistencies that rub me the wrong way..
21:21:31 <p_l> mike-burns: what about methods defined in modules, including global module?
21:21:34 <rovar> i didn't know we were arguing..
21:21:46 <mike-burns> p_l: Still can't pass them to #map .
21:21:58 <Berengal> mike-burns: There's even syntax for lambdas...
21:22:09 <kulakowski> Fortran not having first class functions isn't that bad, it's definately a very niche language
21:22:13 <rovar> c++ has a syntax for lambdas too
21:22:20 <rovar> that doesn't mean fns are 1st class
21:22:29 <soupdragon> rovar: argument/discussion/viewpoint
21:22:46 <rovar> let's talk more about haskell then.
21:22:51 <mike-burns> That'd be great.
21:22:56 <pikhq> kulakowski: Fortran at least has the excuse of being very old.
21:23:03 <pikhq> (and not all that bad for its age)
21:23:32 <rovar> has anyone read Type Theory and Functional Programming ?
21:23:52 <rovar> I'm hoping it will help me get my head around haskell types, because I still don't have a very clear understanding
21:24:08 <kulakowski> pikhq: Yeah. Older than everything but lisp. And if any language arguably doesn't need them it's fortran.
21:24:17 <rovar> I can use them to create rather complex haskell apps.. but I kind of sidestep manipulating them, which results in less elegant code.
21:24:20 <monochrom> It overqualifies for that. It is way more than haskell types.
21:24:21 <soupdragon> the view "in every language, if it doesn't have first class functions it is bad" is ridiculous
21:24:23 <kulakowski> err
21:24:33 <kulakowski> even lisp, rather
21:24:37 <pikhq> kulakowski: And COBOL.
21:25:10 <rovar> fortran has the ability to pass around function pointers much easier than c++ or c
21:25:18 <rovar> but at the sake of type safety
21:25:26 <rovar> as in, there is none at all
21:25:41 <rovar> but you can easily define coroutines and such, which is something c sorely lacks.
21:26:20 <monochrom> I wonder how I understood Haskell types. I understood ML types before that. And I understood a good extent of C++ types before that. OK I guess that was how I worked.
21:27:11 <Berengal> C has blocks. Well, clang has an implementation of blocks for c
21:27:42 <rovar> interesting
21:27:55 <rovar> i was pushing for a block (postfix delegate?) implementation for D
21:28:08 <Cale> Haskell types always made way more sense to me than types in almost any language.
21:28:29 <rovar> i don't think you'll find any argument here
21:28:30 <monochrom> C++ already taught me much parametric polymorphism. It just lacked seamless higher-order functions, but that was so easy to understand or even re-invent it yourself later.
21:28:39 <Berengal> For me, understanding the basics/reasoning behind haskell's type system was just a minute meditating on the phrase "what's the square root of hello?"
21:28:40 <Axman6> Cale: same here
21:28:54 <Axman6> (mainly because they;re not so long i can't remember the names)
21:28:55 <Cale> type variables are easy to understand when presented the way that Haskell presents them
21:29:20 <Berengal> @karma C
21:29:21 <lambdabot> C has a karma of 1
21:29:24 <rovar> c++ templates can offer much in the way of polymorphism.. and it does a considerable amount of type inference at compile time, to the point I wonder why i have to spend all my time spelling out all of them
21:29:27 <Axman6> @remember Berengal For me, understanding the basics/reasoning behind haskell's type system was just a minute meditating on the phrase "what's the square root of hello?"
21:29:27 <lambdabot> Nice!
21:29:30 <pikhq> I found the Haskell type system pretty easy.
21:29:33 <dino-> I feel like I have problems articulating it, but the function pointers, and being able to make lambdas with them, it's not the same thing. It's like a type mismatch that has to be dereferenced in a lot of languages.
21:29:37 <Cale> Though I remember being slightly confused about currying until I read the explanation of it.
21:29:57 <Cale> (I didn't know at first that -> was supposed to be read as right associative)
21:30:14 <Axman6> i still can't remember which is curry and which is uncurry
21:30:15 <pikhq> "Okay, so it's like the C++0x type system (concepts ~= type classes), but much more flexible and much stricter."
21:30:35 <Cale> curry is the ((a,b) -> c) -> (a -> b -> c) way
21:30:36 <pikhq> And then there were monads, and I spent 4 days moving past that word. :P
21:30:37 <Berengal> type variables always made perfect sense to me. I was using them in my mental type model in python for quite a while before learning haskell
21:32:13 <monochrom> It now seems the best way to learn Haskell is to have been presupposing bits of it when you were still stuck with previous inferior languages.
21:32:43 <Axman6> Cale: so currying is what allows partial application?
21:32:46 <abuiles> Hi, does someone know why, if in Data.Word says that there is an instance for Storable Word8, when I try to use it as such, it says that there is not an instance for it. ?
21:32:57 <pikhq> Axman6: Duh.
21:33:00 <Cale> Axman6: Well, it makes partial application simple
21:33:12 <Cale> abuiles: Did you import Data.Word?
21:33:16 <Axman6> ok, hopefully i can remember that :)
21:33:23 <Berengal> Axman6: There is no partial application, there is only apply or not apply
21:33:30 <monochrom> hahahahaha
21:33:31 <Cale> abuiles: hmm... Maybe the instance isn't in that module...
21:33:42 <Axman6> Berengal: heh :)
21:33:42 <pikhq> Well. Without currying, you get tricky partial application.
21:33:56 <pikhq> At which point you may as well do it right and get the three projections of Futamura.
21:33:59 <pikhq> :)
21:34:11 <Cale> abuiles: Yeah, it's in Foreign.Storable
21:34:42 <Axman6> i just realised i've been reading that word as furutama
21:34:57 * Berengal has been reading it consistently as futurama
21:35:01 <pikhq> ... Word?
21:35:06 <pikhq> It's a *name*, man!
21:35:19 <Pseudonym> Axman: I just read what you said as "futurama".
21:35:27 * pikhq feels sorry for Mr. Futamura
21:35:27 <monochrom> A name is a word too. Welcome to OOP 101.
21:35:44 <pikhq> monochrom: OOP can die in a fire.
21:35:44 <mike-burns> I definitely read "Futurama" too.
21:35:46 <Axman6> Pseudonym: good, work, that's how it was supposed to be read, my bad :P
21:35:47 <pikhq> Needs more lambda.
21:35:55 <monochrom> LOOP
21:36:13 <Pseudonym> Axman: You made a mistake in your mistake.  Sadly, these did not cancel out.
21:36:16 <Cale> 降る玉?
21:36:22 <Axman6> :(
21:36:35 <monochrom> http://www.futamura.co.jp/english/index.html ?
21:36:48 <Berengal> Heh, I kept wondering what furutama was...
21:37:39 <Cale> hmm, my IME gives 二村 for futamura. "Two village"
21:37:46 * Axman6 is actually dyslexic, and he apologises
21:40:00 <Cale> 不面魔
21:40:12 <Cale> fu tura ma ;)
21:40:41 <monochrom> devil with no face? :)
21:40:49 <pikhq> Cale: Yeah, that would be Futamura... Japanese last names are a bit screwy.
21:41:04 <pikhq> (mostly invented out of whole cloth in the late 1800s)
21:41:22 <Cale> pikhq: I like them, they're mostly stuff from nature
21:41:25 <Berengal> Cale: Isn't the second character there the symbol for "runtime" and "Writer monad"?
21:41:38 <monochrom> I find 二村 "Two village" more credible. It actually looks like other Japanese names.
21:41:39 <pikhq> Still screwy. :P
21:41:39 <copumpkin> 面白い
21:42:24 <Berengal> copumpkin: I still think "explode stuff into tiny bits" seems like a good translation of that sequence
21:42:25 <abuiles> Cale: It's weird , I'm importing Foreign and it's still complaining
21:42:37 <Cale> abuiles: Try importing Foreign.Storable
21:42:39 <copumpkin> Berengal: I was just showing another common use for that character :P
21:42:50 <Cale> abuiles: Though Foreign should really be re-exporting that.
21:42:58 <Cale> abuiles: Which version of GHC are you using?
21:43:01 * Berengal knows maybe two japanese words
21:43:10 <Axman6> abuiles: importing Foo does not also import Foo.*
21:43:15 * copumpkin teaches Berengal koumon
21:43:23 <Berengal> Is that a pokemon?
21:44:16 <abuiles> Axman6: I tried with Foreing.Storable as well
21:44:17 <Axman6> "hey, did you see the latest ubuntu?" "sorry, i don't play pokemon" one of my favourite (badly quoted) xkcd comics
21:44:37 <Berengal> Axman6: "I'm not interested in pokemon"
21:44:50 <Berengal> (Probably also badly quoted)
21:44:54 <abuiles> Cale: 6.10.3
21:45:13 <Berengal> "Nah, I'm not really into pokemon."
21:46:19 <rovar> I'm not really into accurate quotes
21:46:38 <Cale> abuiles: very strange.
21:46:53 <rovar> geh.. still 2.15 hours to put up with at work.
21:47:02 <rovar> I got here 15 hrs ago.
21:47:22 <Cale> abuiles: from ghci, import Foreign and Data.Word and then :info Word8
21:47:31 <Cale> abuiles: and see if the instance of Storable appears
21:48:50 <abuiles> Cale: yes
21:50:11 <abuiles> Cale: It's weird cause, it appears in ghci, like you said, but when trying to open te file it doesn't
21:51:36 <Cale> abuiles: and at the top of that file, you import both those modules?
21:51:49 <Cale> I don't really understand how that could happen :)
21:52:34 <monochrom> sunspot activity increased recently. maybe that's why.
21:53:40 <Cale> copumpkin: 「面白い」は「面」と「白い」で書かれたことが面白いね。
21:53:53 <rovar> I'm not sure whether to be repulsed, or intrigued. I guess both is sufficient:  http://www.beatniksoftware.com/erjs/
21:54:10 <abuiles> Cale:check out http://www.moonpatio.com/fastcgi/hpaste.fcgi/view?id=2986#a2986
21:54:28 <Cale> abuiles: yeah, that should do it
21:54:33 <abuiles> Cale: Maybe, Am I doing something wrong when importing ?
21:54:41 <Cale> abuiles: What's the exact error message you're getting?
21:55:12 <monochrom> Hmm what does {-# LANGUAGE ForeignFunctionInterface #-} do?
21:55:30 <Cale> monochrom: Enables syntax like import foreign
21:55:35 <Axman6> rovar: how... um... interesting... i guess? >_<
21:56:01 <rovar> i really like the 1st line: ... which fakes threading in JavaScript 1.7 using coroutines and nested generator continuations.
21:56:04 <abuiles> Cale: I just added the error in hpaste
21:56:16 <Cale> abuiles: ah!
21:56:22 <Cale> abuiles: No instance for (Storable [Word8])
21:56:28 <monochrom> list of Word8 is different...
21:56:30 <Cale> [Word8] is not the same type as Word8 :)
21:57:12 <Cale> It's true that there's no instance of Storable for arbitrary lists of Word8 values.
21:57:34 <abuiles> Cale: Thanks..
21:57:42 <Cale> You'll probably want to pack them into a StorableArray
21:58:05 <Axman6> (and make sure it's not an infinite list...)
21:59:42 <Cale> hmm, that's funny, there's really no instance of Storable for the Vector type from storablevector?
21:59:51 <monochrom> <3 continuation as a story for cooperative concurrency.
22:00:20 <monochrom> Hell, <3 continuation
22:03:35 * monochrom contemplates The Unreasonable Effectiveness of Continuation as a Mediator between High-Level Constructs and Low-Level Implementations.
22:04:28 <monochrom> It's all the more amazing that continuation was first invented in lambda calculi rather than in machines, concrete or abstract.
22:04:29 * ski unreasons and continues
22:05:29 * Berengal wonders if this means Ntinuations are reasonably effective
22:06:43 <rovar> what function has the signature: (a -> m b) -> m a -> m b  ?
22:06:51 <Berengal> flip (>>=)
22:06:51 <ski> @type (=<<)
22:06:53 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
22:07:03 <soupdragon> @hoogle (a -> m b) -> m a -> m b
22:07:04 <lambdabot> Prelude (=<<) :: Monad m => (a -> m b) -> m a -> m b
22:07:04 <lambdabot> Control.Monad (=<<) :: Monad m => (a -> m b) -> m a -> m b
22:07:04 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
22:07:24 <rovar> @type (flip . flip)
22:07:25 <lambdabot> forall a b c. (b -> a -> c) -> b -> a -> c
22:08:01 <Berengal> aka id
22:08:05 <rovar> ya
22:08:20 <Berengal> ... or ($)
22:08:24 <monochrom> flip.flip is not very id because you can't use it on True.
22:08:35 <rovar> id3 :)
22:08:35 <ski> > id True
22:08:37 <lambdabot>   True
22:08:46 <Berengal> They're id with a specialized type
22:09:09 <abuiles> Cale:Good night and thanks for the your help. I'm going to try to do what you suggested tomorrow... thanks
23:18:27 <TempestAdept> Hello everybody... After installing some packages via cabal-install I ended up having both transformers and mtl required by them. But when I try to load Control.Monad.Trans in ghci it complains about finding it in multiple packages.
23:22:57 <TempestAdept> is there a way to specify which version to load? Or just to load any of them
23:25:30 <cizra> Peaker: Somewhat. I discovered on my own that I can make a data Board = Board [Mark], but I'm a bit confused by the usage.
23:28:04 <shachaf> cizra: ?
23:29:08 <Berengal> TempestAdept: ghc-pkg hide mtl
23:30:50 <cizra> shachaf: I asked something about creating such a type that would be basically a list, but would have static type checking.
23:31:11 <cizra> data Board = Board [Mark] is basically a list of Marks, but with type checking. If I've understood it correctly.
23:31:43 <shachaf> cizra: That's what newtype is for.
23:31:53 <shachaf> newtype Board = Board [Mark]
23:32:05 <coCocoa|in> cizra: Use "newtype" vice "data"...oh, never mind. :)
23:32:15 <shachaf> There are a few differences between that and data -- see the wiki, I'd guess.
23:32:28 <shachaf> @wiki Newtype
23:32:28 <lambdabot> http://www.haskell.org/haskellwiki/Newtype
23:32:42 <shachaf> Er, that page is perhaps not the most helpful. :-)
23:32:45 <cizra> This is not the same as type alias, right?
23:32:59 <cizra> A type alias won't do static type checking, right?
23:33:04 <shachaf> Right.
23:33:06 <shachaf> But a newtype would.
23:33:08 <soupdragon> what?
23:33:25 <shachaf> But all it makes is a "new type" -- it's compiled away, unlike data.
23:33:44 <shachaf> cizra: (Is the 'c' in your nick pronounced like "sh"?)
23:33:51 <cizra> shachaf: yes (=
23:34:01 <cizra> OK, so newtype it is.
23:34:17 <shachaf> cizra: Yep.
23:34:44 <cizra> shachaf: Why do you ask?
23:34:46 <shachaf> There's also a difference relating to _|_ -- with data, you can have "Board undefined" /= "undefined", but not with newtype.
23:35:05 <cizra> What is _|_?
23:35:07 <shachaf> Curiosity. :-)
23:35:12 <shachaf> Bottom, undefined.
23:35:19 <Berengal> or infinite loops...
23:35:21 <shachaf> An infinite loop, fix id, let x = x in x.
23:35:24 <cizra> ohh. Like the "False" symbol in logic.
23:35:28 * coCocoa|in pats the nice (_|_)...
23:35:30 <shachaf> A value which never returns.
23:35:32 <rovar> i think the bottom operator is more descriptive
23:35:46 <Berengal> Sort of like a lack of "Yes." in prolog
23:35:50 <dobblego> I think The Nothing is more descriptive if you've ever seen The Neverending Story
23:35:57 <Berengal> (Either no, or it never returns)
23:36:10 <rovar> if we include the Nothing we have to include the luck dragon
23:36:23 <dobblego> Falcor!
23:36:40 * Berengal ponders the the structure of luck dragons
23:42:46 <rovar> 'nite all
