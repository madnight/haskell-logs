00:01:38 <mjs22> > unsafeLaunchMissiles
00:01:39 <lambdabot>   Not in scope: `unsafeLaunchMissiles'
00:01:46 <mjs22> darn
00:02:12 <ray> lambdabot doesn't do IO
00:02:14 <ivanm> @seen matthew-_
00:02:15 <lambdabot> matthew-_ is in #haskell-blah, #haskell and #ghc. I don't know when matthew-_ last spoke.
00:02:16 <mjs22> :)
00:02:26 <ivanm> mjs22: besides, that's not a real function
00:03:08 <ray> it's trivial to implement given unsafePerformIO
00:03:34 <ivanm> @ask matthew-_ when you wrote the Attributes for graphviz, do you recall why some of them are parsed with optionalQuoted whilst the others are not? (looks like just the floatingNumber ones are, not the rest :s)
00:03:35 <lambdabot> Consider it noted.
00:03:48 <shachaf> ray: Isn't the point of unsafeLaunchMissiles that it's not in IO?
00:04:04 <shachaf> Otherwise it would be safe. :-)
00:05:07 <ray> it does IO, though
00:05:12 <Axman6> @hoogle missile
00:05:13 <lambdabot> No results found
00:05:13 <ray> otherwise it would be safe and also not launch missiles
00:05:14 <Axman6> :(
00:05:26 <mjs22> > unsafeLaunchMissiles -- oops
00:05:27 <lambdabot>   Not in scope: `unsafeLaunchMissiles'
00:06:12 <mjs22> I'm still curious how that was making lambdabot say boom a few days ago.  (see http://tunes.org/~nef/logs/haskell/09.07.06)
00:06:44 <ray> @let unsafeLaunchMissiles = "BOOM!"
00:06:45 <lambdabot>  Defined.
00:06:48 <mjs22> ah
00:06:50 <ray> something like that
00:07:29 <ray> @let unsafeLaunchMissiles = text "BOOM!"
00:07:30 <lambdabot>  <local>:4:0:
00:07:30 <lambdabot>      Multiple declarations of `L.unsafeLaunchMissiles'
00:07:32 <lambdabot>      Dec...
00:07:34 <ray> oh, right
00:07:45 <ray> and i can't unlet it without unletting everything
00:08:01 <shachaf> > unsafeLaunchMissiles
00:08:03 <lambdabot>   WARNING: Nuclear missile -- launched.
00:08:12 <shachaf> @unlet
00:08:13 <lambdabot>  Defined.
00:08:16 <shachaf> @undef
00:08:29 * ray is too polite to unlet things
00:08:50 <shachaf> Were other things @let?
00:08:59 <ray> doubt it
00:09:06 <ray> it's the thought that counts
00:09:23 * shachaf never thinks of @let as holding anything important to anyone.
00:09:34 <shachaf> @let if' b x y = if b then x else y
00:09:36 <lambdabot>  Defined.
00:12:30 <ivanm> shachaf: ahhh, the good old function known only to @pl...
00:12:51 <shachaf> Shouldn't it be called "if"?
00:13:11 <ivanm> shachaf: if is a keyword...
00:13:15 <ray> it really should
00:13:19 <FunctorSal> here we go again
00:13:29 <shachaf> ivanm: Should it be?
00:13:34 <FunctorSal> too bad copumpkin isn't here
00:13:41 <ivanm> shachaf: I'm not getting into that debate ;-)
00:13:46 <coCocoa> @let p ?: (t, f) = if p then t else f
00:13:48 <lambdabot>  Defined.
00:13:51 * shachaf is also for (.) = fmap.
00:13:54 <shachaf> @let (.) = fmap
00:13:55 <lambdabot>  .L.hs:75:36:
00:13:55 <lambdabot>      Ambiguous occurrence `.'
00:13:55 <lambdabot>      It could refer to either `L....
00:14:10 <ivanm> shachaf: please no...
00:14:21 <ray> i'm for all of it and more
00:14:29 <ivanm> that makes it harder for new people to work out how haskell works
00:14:48 <ivanm> same goes for map = fmap, generalising (++), etc.
00:15:10 <aavogt> @type (+)
00:15:11 <lambdabot> forall a. (Num a) => a -> a -> a
00:15:33 <aavogt> ivanm: type classes are unavoidable when people are learning
00:15:47 <ray> if it really turned out to be a problem, which i don't think is likely, you could have a newbie prelude :P
00:16:03 <shachaf> ivanm: Whereas the current situation makes it uglier for everyone else (maybe).
00:16:19 <ivanm> aavogt: how many tutorials have things like "this is how map is defined" ?
00:17:21 <aavogt> and it will still work the same way
00:17:41 <ray> well, it would be inside an instance Functor
00:18:51 <aavogt> @hackage parsedate
00:18:52 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/parsedate
00:18:59 <aavogt> Axman6: ^^ ?
00:19:34 <Axman6> yeah i've had a look at that
00:19:42 <mjrosenb> Prologue junk?: 	.type	s210_ret, @function
00:19:42 <mjrosenb> s210_ret: # 136 "/var/tmp/portage/dev-lang/ghc-6.6.1/temp/ghc32493_0/ghc32493_0.hc" 1
00:20:05 * mjrosenb is beginning to think that some higher power does not want me to install ghc on my desktop
00:21:36 <jeffwheeler> Say I only need one random number in my program, ever. Is this the easiest way to get it: getStdRandom $ randomR (1,999) ?
00:22:23 <mjrosenb> jeffwheeler: 4
00:22:34 <jeffwheeler> mjrosenb: once per execution :)
00:22:50 <aavogt> chosen by fair die?
00:22:52 <jeffwheeler> Although I could have it send a request to this IRC room.
00:22:52 <mjrosenb> jeffwheeler: you'll get one per execution
00:23:06 <mjrosenb> aavogt: yep
00:23:33 <jeffwheeler> Well, it may have more than 6 sides, but a variably-sided die, yes.
00:24:04 <jeffwheeler> It runs once at startup, selects a random file, then quits.
00:25:25 <mjrosenb> jeffwheeler: you want two random numbers
00:25:35 <jeffwheeler> Err, why?
00:25:40 <jeffwheeler> Oh, the seed?
00:26:02 <Saizan_> "getStdRandom $ randomR (1,999)" is perfectly fine
00:26:08 <mjrosenb> yes
00:26:16 <Saizan_> but you could also use randomRIO (1,999)
00:26:19 <mjrosenb> if you know it's going to be in the range (1,999)
00:26:36 <jeffwheeler> mjrosenb: I intended to count the number of files, first
00:26:57 <jeffwheeler> mjrosenb: I'll actually have a list of the filenames, if one of the random functions will automagically return a random item
00:27:04 <jeffwheeler> Saizan_: oh, thanks
00:27:16 <mjrosenb> map (\x -> fst (randomR (mkStdGen x) (0,5))) [0..30]
00:27:20 <mjrosenb> > map (\x -> fst (randomR (mkStdGen x) (0,5))) [0..30]
00:27:22 <lambdabot>   Couldn't match expected type `(a, a)'
00:27:58 <mjrosenb> > map (\x -> fst (randomR (0,5) (mkStdGen x))) [0..30]
00:28:00 <lambdabot>   [5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5]
00:28:31 <jeffwheeler> > map (\x -> fst (randomR (0,5) (mkStdGen x))) [0] -- all I need ;)
00:28:32 <lambdabot>   [5]
00:28:36 <jeffwheeler> > map (\x -> fst (randomR (0,5) (mkStdGen x))) [0] -- all I need ;)
00:28:37 <lambdabot>   [5]
00:28:39 <jeffwheeler> Wait, what?
00:28:50 <Saizan_> mkStdGen is deterministic.
00:29:07 <mjrosenb> Saizan_: yes, but note i'm giving it different seeds each time
00:29:14 <Deewiant> No you're not
00:29:16 <Deewiant> You're giving it 0
00:29:26 <mjrosenb> Deewiant: [0..30]
00:29:26 <Saizan_> mjrosenb: yeah, seeds created by small integers are similar
00:29:27 <Deewiant> No, that was jeff
00:29:27 <Deewiant> Sorry
00:29:30 <Saizan_> > mkStdGen 0
00:29:32 <lambdabot>   1 1
00:29:33 <Saizan_> > mkStdGen 1
00:29:35 <lambdabot>   2 1
00:29:36 <davidL> > map (\x -> fst (randomR (0,5) (mkStdGen x))) [0,3949234,42,93182,10000]
00:29:38 <lambdabot>   [5,4,5,4,5]
00:29:42 <Saizan_> the second part is always 1
00:29:49 <Deewiant> > map (\x -> fst (randomR (0,50) (mkStdGen x))) [0..30]
00:29:51 <lambdabot>   [17,5,35,14,44,23,2,32,11,41,20,50,29,8,38,17,47,26,5,35,14,44,23,2,32,11,4...
00:29:54 <Saizan_> but the seed you get from newStdGen is different
00:29:59 <Deewiant> > map (\x -> fst (randomR (0,5) (mkStdGen x))) [0..30]
00:30:00 <lambdabot>   [5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5]
00:30:03 <Deewiant> Heh
00:30:13 <mjrosenb> Saizan_: yes, but he is only going to be using one number
00:30:16 <Deewiant> That's the trouble with randomness: you can never be sure ;-)
00:30:20 <mjrosenb> Saizan_: and even if he bases it on the time
00:30:38 <mjrosenb> it's still going to look very deterministic with certain numbers of files
00:30:47 <Saizan_> i don't think so
00:31:22 <mjrosenb> > take 10 $ length (group(map (\x -> fst (randomR (0,5) (mkStdGen x))) [0..]))
00:31:24 <lambdabot>   Couldn't match expected type `[a]'
00:31:37 <mjrosenb> > take 10 $ (map .length) (group (map (\x -> fst (randomR (0,5) (mkStdGen x))) [0..]))
00:31:38 <lambdabot>   Couldn't match expected type `a -> b'
00:31:42 <davidL> > map (\x -> fst (randomR (0,5) (mkStdGen x))) [100000..]
00:31:44 <lambdabot>   [4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,...
00:32:17 <ajcates> hello?
00:32:47 <mjrosenb> > take 10 . (map length) . group . (map (\x -> fst (randomR (0,5) (mkStdGen x)))) $ [0..]
00:32:50 <lambdabot>   [53668,53668,53668,53669,53668,53668,53669,53668,53668,53669]
00:33:11 <mjrosenb> so you get 5 for 53,000 consecutive inputs
00:33:19 <mjrosenb> then 4 for 53000 consecutive inputs
00:33:37 <mjrosenb> ajcates: 'ello
00:34:09 <mjrosenb> > take 10 . (map \x-> (length x, head x)) . group . (map (\x -> fst (randomR (0,5) (mkStdGen x)))) $ [0..]
00:34:10 <lambdabot>   <no location info>: parse error on input `\'
00:34:22 <mjrosenb> > take 10 . (map (\x-> (length x, head x))) . group . (map (\x -> fst (randomR (0,5) (mkStdGen x)))) $ [0..]
00:34:26 <lambdabot>   [(53668,5),(53668,4),(53668,3),(53669,2),(53668,1),(53668,0),(53669,5),(536...
00:34:50 <mjrosenb> jeffwheeler: so like i said, you should probably take two random numbers
00:34:54 <mjrosenb> jeffwheeler: and use the second one
00:35:04 <jeffwheeler> Wait, why?
00:35:35 <aavogt> mjrosenb: why not get 3, and take the last one?
00:35:35 <davidL> mjrosenb: that is why newStdGen is used
00:35:58 <ajcates> yea whats the point of having 2 random numbers when you only need one?
00:36:39 <mjrosenb> ajcates: because there can be an incredibly high correlation between the first random number that you get, and the initial seed
00:37:03 <ajcates> meh
00:37:47 <foooof> > unsafeLaunchMissiles
00:37:49 <lambdabot>   "Whee"
00:38:12 <mjrosenb> jeffwheeler: did the first number that i was getting from different seeds look random to you?
00:38:29 <davidL> mjrosenb: that doens't matter
00:38:31 <jeffwheeler> mjrosenb: No, but it seemed like the first 53,000 weren't either
00:40:07 <mjrosenb> jeffwheeler: i was just giving it one seed, and pulling one value, exactly what you are proposing to do
00:40:38 <davidL> > show (mkStdGen 42)
00:40:39 <lambdabot>   "43 1"
00:41:44 <ajcates> i still don't get how one number can be more random then the second or thrid
00:42:02 <ajcates> maybe after your done having it spit out 10k numbers will you be able to find a pattern
00:42:21 <davidL> :\
00:42:26 <Saizan_> ajcates: because the first seed is quite poor
00:42:42 <Saizan_> all the seeds you get from mkStdGen have 1 as second field
00:43:03 <Saizan_> though after the first split they get more evely distributed in the space of seeds
00:43:13 <ajcates> jeff says your always rightâ€¦
00:43:20 <jeffwheeler> . . .
00:43:24 <ajcates> so by the extenstion of jeff being always right you win!
00:43:31 <ajcates> i suck at spelling btw.
00:43:33 <mjrosenb> Saizan_: what exactly is splitting?
00:43:51 <Saizan_> > split (mkStdGen 4)
00:43:52 <lambdabot>   (6 40692,200070 2147483398)
00:43:54 <davidL> Saizan_: why does that even matter if you're using the global generator?
00:44:42 <Saizan_> davidL: the global generator starts with mkStdGen as well (well, similar), but it uses the time as parameter
00:44:55 <Saizan_> davidL: you'll se that getStdGen will give you a similar seed
00:45:19 <davidL> time is its only source of entropy?
00:45:43 <Saizan_> yes
00:46:00 <jeffwheeler> Isn't that the case for most pseudo-random number generators?
00:46:11 <jeffwheeler> Or, at least those found in other popular languages?
00:46:15 <Saizan_> http://haskell.org/ghc/docs/latest/html/libraries/random/src/System-Random.html
00:46:54 <Saizan_> jeffwheeler: on unix you could use /dev/random or /dev/urandom i guess
00:47:08 <jeffwheeler> Saizan_: I am, but what does that use?
00:47:16 * mjrosenb is off to beat ghc into submission
00:47:57 <copumpkin> you show it!
00:48:11 <Saizan_> it uses entropy generated by the hardware
00:48:53 <Saizan_> http://en.wikipedia.org/wiki//dev/random
00:48:55 <jeffwheeler> Saizan_: I didn't know there was any, unless you had one of those neato "truly" random number generator cards that did some weird photo cannon thingy
00:49:05 <davidL> hm, for some reason I was under the impression that System.Random used /dev/random
00:49:18 <mjrosenb> jeffwheeler: you can look at keystrokes or network traffic and get pretty random data
00:49:29 <Sativa> i lived in a town called haskell, NJ
00:49:31 <Sativa> i hated it.
00:49:52 <mjrosenb> there is a haskell road just outside of LA
00:50:20 <Saizan_> jeffwheeler: that's different
00:50:25 <Sativa> http://ihatejade.com/index.php?c=viral&m=index&id=c8d3b2637c33fbe7c3ade2c277a51278
00:57:17 --- mode: ChanServ set +o Saizan
00:57:33 <bremner> weird, spammers who make almost on-topic comments
00:57:49 --- mode: Saizan set +b *!n=Ic@cpe-71-66-232-204.columbus.res.rr.com
00:58:00 --- mode: Saizan set -o Saizan
01:09:48 <RayNbow> hmm, planet.haskell.org down?
01:11:18 <Saizan> > group . map (fst . randomR (0,5)) . map mkStdGen $ [1..]
01:11:20 <lambdabot>   [[5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5...
01:11:25 <Saizan> > group . map (fst . randomR (1,5)) . map mkStdGen $ [1..]
01:11:27 <lambdabot>   [[3],[2],[1],[5],[4],[3],[2],[1],[5],[4],[3],[2],[1],[5],[4],[3],[2],[1],[5...
01:11:42 <Saizan> mjrosenb, jeffwheeler: this is quite funny
01:11:45 <Saizan> ^^^
01:12:45 <jeffwheeler> Hmm . . . yes, yes it is.
01:12:46 <RayNbow> Saizan: I thought the number 4 was supposed to be chosen by a fair dice... not 5? :p
01:13:11 <jeffwheeler> That comes from some Debian mailing list, doesn't it? I know I've heard that before.
01:13:35 <Saizan> jeffwheeler: xkcd, if you refer to the fair dice joke
01:13:40 <RayNbow> http://xkcd.com/221/
01:13:43 <jeffwheeler> That's it!
01:13:47 <jeffwheeler> I knew I'd seen it somewhere.
01:14:24 * RayNbow blinks
01:14:31 <RayNbow> I google for "hylomorphism functor"
01:14:42 <RayNbow> and the first hit is Java related O_O
01:14:48 <mjrosenb> RayNbow: ow.
01:14:54 <RayNbow> http://www.google.com/search?source=ig&hl=en&rlz=1G1TSEA_NLNL315&q=hylomorphism+functor&aq=f&oq=
01:14:59 <kulakowski> oh, I thought it was gonna be rule 34
01:15:16 <jeffwheeler> Google's just broken, don't worry.
01:16:02 <jeffwheeler> Damn. Five random's in, and my code picks a random file that doesn't exist.
01:16:14 <jeffwheeler> I knew I should've printed out debug info. I wonder what it tried to set it to . . .
01:16:35 <jeffwheeler> Oh, a directory. :)
01:17:21 <jeffwheeler> Ah. I wrote the code to filter for filenames, but I forgot to include the filtering function before returning.
01:18:56 <jeffwheeler> Random numbers stink. Way too much testing a bunch of times . . .
01:21:47 <Saizan> it seems i was kind of wrong earlier, getting the second random number doesn't seem give you a much better distribution, but seeding from time shouldn't give you consecutive seeds either.. so i guess you should just test and see if it appears enough random to you :)
01:22:57 <jeffwheeler> Since I'll forget that the script even exists after three logins, and won't notice if the background stops randomly changing, it's probably random enough for me. :)
01:24:02 * RayNbow finally sees how hylo :: Functor f => (a -> f a) -> (f b -> b) -> (a -> b) is supposed to work
01:24:48 <copumpkin> build and take it apart
01:25:11 <copumpkin> hmm
01:25:39 <copumpkin> hylo :: Functor f => Algebra g b -> (f :~> g) -> Coalgebra f a -> a -> b
01:25:48 <RayNbow> I was co-confused about how to write the definition of hylo
01:26:00 <copumpkin> Algebra g b = g b -> b
01:26:09 <copumpkin> didn't you forget something there?
01:26:14 * mjrosenb should learn some category theory
01:27:47 <copumpkin> RayNbow: ?
01:27:49 <RayNbow> copumpkin: hmm?
01:27:50 <RayNbow> hylo f g = g . fmap (hylo f g) . f  -- ?
01:28:13 <RayNbow> :t let hylo f g = g . fmap (hylo f g) . f  in hylo
01:28:15 <lambdabot> forall a (f :: * -> *) c. (Functor f) => (a -> f a) -> (f c -> c) -> a -> c
01:28:33 <copumpkin> hrm
01:29:10 <ray> hylo there
01:29:17 <copumpkin> how is that getting from the f a to f c?
01:29:35 <Saizan> copumpkin: he doesn't need the (f :~> g) because his hylo works on a single functor
01:29:40 <RayNbow> copumpkin: a recursive call
01:29:45 <copumpkin> hrm
01:30:01 <copumpkin> oh I see
01:30:01 <RayNbow> I had stumbled upon the same problem when I was figuring out loeb :: Functor a => a (a x -> x) -> a x
01:30:07 <Saizan> hylo f g :: a -> c, fmap (hylo f g) :: f a -> f c
01:30:16 <copumpkin> yeah
01:30:23 <copumpkin> makes sense
01:30:47 <RayNbow> now if only djinn could use recursion :p
01:31:34 <RayNbow> (although I doubt whether it's possible to implement)
01:34:16 <copumpkin> > let hylo f g = g . fmap (hylo f g) . f  in hylo (flip replicate 2) sum 5
01:34:19 <lambdabot>   * Exception: stack overflow
01:34:24 <copumpkin> > let hylo f g = g . fmap (hylo f g) . f  in hylo (flip replicate 2) length 5
01:34:25 <lambdabot>   5
01:34:37 <copumpkin> > let hylo f g = g . fmap (hylo f g) . f  in hylo (flip replicate 2) head 5
01:34:43 <lambdabot>   mueval-core: Prelude.read: no parse
01:34:43 <lambdabot>  mueval: ExitFailure 1
01:35:02 <copumpkin> hrm
01:35:18 <copumpkin> > let hylo f g = g . fmap (hylo f g) . f  in hylo (flip replicate 2) sum 5
01:35:21 <lambdabot>   * Exception: stack overflow
01:35:42 <copumpkin> > let hylo f g = g . fmap (hylo f g) . f  in hylo (flip replicate 2) sum 1
01:35:44 <lambdabot>   * Exception: stack overflow
01:35:53 <mjrosenb> yeah, that looks like it would have a tendency to not terminate
01:35:58 <Saizan> copumpkin: the unfolding part should stop at some point :)
01:36:20 <copumpkin> true, but how do I stop it?
01:37:31 <copumpkin> @type listToMaybe :: forall c. f c -> g c
01:37:31 <Saizan> a could be a tuple of a counter and the current value.. or something
01:37:32 <lambdabot> Not in scope: type variable `f'
01:37:33 <lambdabot> Not in scope: type variable `g'
01:38:08 <michael_ja> http://rapidshare.com/files/254231300/home_made_crazy_blonde_lolita.rar
01:38:11 <Saizan> so when you reach a certain point you return []
01:38:16 <copumpkin> michael_ja: thanks
01:38:17 --- mode: ChanServ set +o Saizan
01:38:23 --- mode: Saizan set +b *!*=michael_@88.235.165.*
01:38:23 --- kick: michael_ja was kicked by Saizan (Saizan)
01:38:39 <copumpkin> hmm
01:38:51 <RayNbow> Saizan, you bastard... killing Michael Jackson while he's already dead! :p
01:38:58 <copumpkin> :P
01:39:17 <mjrosenb> Saizan: you didn't even get a chance for him to say 'whoops, wrong window' :-p
01:39:47 --- mode: Saizan set -o Saizan
01:39:49 <ivanm> copumpkin: were you looking for porn? :p
01:40:07 <RayNbow> hmm, that IP seems to come from Turkey?
01:40:26 <copumpkin> ivanm: yup!
01:40:39 <idnar> I hear bing is a good way to search for porn
01:40:42 <RayNbow> @faq Can Haskell provide us functional porn?
01:40:42 <lambdabot> The answer is: Yes! Haskell can do that.
01:42:48 <ivanm> gah, the haskell.org is down :@
01:44:22 <copumpkin> bedtime for me :P
01:45:05 <ivanm> copumpkin: hence wanting the porn? :p
01:45:13 <mjrosenb> ivanm: it's just taking a while
01:47:24 <Axman6> i've seen functional porn. a flash movie with people having sex in rather strange ways, and when you put your mouse over any of their clothing, it would tell you about the clothes and the price etc
01:47:40 <ivanm> ..... >_> .....
01:47:45 <antonio_> ciao
01:47:49 * ivanm doesn't want to know what kind of porno sites Axman6 frequents...
01:47:54 <Axman6> choices of lesbian, straight and gay movies too
01:47:55 <antonio_> !list
01:48:05 <ivanm> hi antonio_
01:48:15 <Axman6> ivanm: it's quite possible it was digg back in the day
01:48:20 <ivanm> :o
01:48:26 <Axman6> and by day i mean like two years ago
01:49:54 * maltem 's new plan for world domination: Making up a design of a distributed commenting system, sort of a hybrid of Reddit and Usenet. Does that make any sense, or should I stop thinking?
01:51:02 <RayNbow> maltem: do you have an idea how to moderate it in a distributed way?
01:51:59 <maltem> Except for filtering, I didn't think about moderation
01:52:11 <Nafai> Does anyone know if there is a module out there for interacting with Google's GData APIs?
01:52:23 <ivanm> maltem: filtering as in spam?
01:52:40 * ivanm finds the frequent spamming of self-posts on reddit annoying
01:53:21 <maltem> ivanm: Filtering as in spam, or as in "I want to show the new-clever-system comments directly on my blog, but only comments by those I know"
01:53:43 <RayNbow> the problem with moderation is... not everyone agrees with each other :p
01:54:21 <maltem> RayNbow, are you thinking of moderation as in IRC mods?
01:54:23 <ivanm> maltem: I meant getting rid of spam posts from the comment system
01:54:23 <RayNbow> there are people that use an up/down mod system to upmod posts that they agree with and downmod the posts they disagree with
01:54:59 <RayNbow> but there are also people that prefer to upmod posts with good arguments (regardless whether they agree with the post)
01:55:31 <ivanm> RayNbow: then there are posts that should automatically be removed when someone tries to use a commenting site to advertise their own, either by spamming random articles or product listings, or by having rather banal posts with no content
01:55:48 <maltem> oh, you meant like points, as in reddit
01:55:54 <RayNbow> sorta
01:55:58 <RayNbow> but I don't like reddit's system :p
01:56:03 <maltem> heh
01:56:12 * RayNbow prefers systems like Slashdot and Tweakers.net (Dutch)
01:56:41 <maltem> I don't know, I usually don't care much what other people voted
01:57:22 <RayNbow> but on Tweakers.net, some people abuse the moderation system to mod strategically or upmod posts they agree with
01:57:28 <maltem> ivanm, as for banal posts, the problem is that there are banal people, no? ;)
01:57:30 <Axman6> @check \x -> x == (x && True)
01:57:31 <lambdabot>   "OK, passed 500 tests."
01:57:49 <mmorrow> @let (|.|) = flip hylo
01:57:50 <lambdabot>   Parse error
01:57:54 <dibblego> why does lambdabot insert import Control.Arrow hiding (pure) into State/L.hs after some time (since Control.Arrow does not export pure)?
01:58:00 <RayNbow> (so there's a meta-moderation forum @ Tweakers.net where moderators discuss posts that have an incorrect score :P)
01:58:07 <mmorrow> @let g |.| f = hylo f g
01:58:08 <lambdabot>  <local>:4:10: Not in scope: `hylo'
01:58:11 <paolino> maltem, in a distributed system anyone wants to have control on what he is mirroring/distributing
01:58:21 <mmorrow> @let hylo f g = g . fmap (hylo f g) . f
01:58:23 <lambdabot>  Defined.
01:58:24 <mmorrow> @let g |.| f = hylo f g
01:58:26 <lambdabot>  Defined.
01:58:35 <maltem> ivanm, the spam thing gets into another dimension though since I was thinking about a mail interface :)
01:59:01 <ivanm> heh
01:59:22 <Axman6> :t hylo
01:59:22 <Saizan> dibblego: because that L.hs was written when Control.Arrow still exported pure
01:59:23 <lambdabot> forall a (f :: * -> *) c. (Functor f) => (a -> f a) -> (f c -> c) -> a -> c
01:59:42 <dibblego> Saizan, sure, so I edited it, then cam back later to find it's back!
01:59:47 <RayNbow> I wonder if it's possible to implement a system where the moderation score of a post the user sees depends on the moderation given by other users with a similar "moderation taste"
01:59:56 <Axman6> > hylo (\x -> [x,x]) (show.head) 1
01:59:58 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
02:00:02 <Axman6> :O
02:00:16 <Axman6> > hylo (\x -> [x,x]) (head) 1
02:00:19 <Saizan> dibblego: there's a saved L.hs in the datadir that gets reused after an @unlet
02:00:19 <paolino> RayNbow: correlation
02:00:22 <lambdabot>   mueval-core: Prelude.read: no parse
02:00:22 <lambdabot>  mueval: ExitFailure 1
02:00:25 <Axman6> >_<
02:00:29 <dibblego> Saizan, ah thanks
02:00:41 <Saizan> dibblego: look at Plugin.Eval for details
02:01:10 <dibblego> Saizan, I see no such file
02:02:06 <dibblego> ~/.cabal$ find . -name L.hs
02:02:06 <dibblego> ./share/lambdabot-4.2.2.1/State/L.hs
02:05:28 <PetRat> I have been away for a while and apparently mibbit.com doesn't work any more with freenode. I'm trying XChat. How can I use a paste bin?
02:08:34 <PetRat> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6878#a6879
02:10:06 <PetRat> Anyone here? Does this test paste work?
02:10:22 <mjrosenb> wow, ghc is using the stage1-inplace is compiling
02:10:58 <mjrosenb> PetRat: people are here
02:11:15 <EvilTerran> PetRat, it says "test". it's more conventional to put code or whatever on a test paste, but if it was meant to say "test", it's working.
02:11:34 <EvilTerran> *on a pastebin
02:13:15 <PetRat> Okay great. Here's my real question. I have been away from Haskell for two months and have become Haskell-stupid. I'm getting the error "overlapping pattern matches" in this code. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6878#a6880
02:14:30 <EvilTerran> PetRat, i suspect the problem is that that "(x,_) ->" pattern might not be doing what you think it's doing
02:15:02 <EvilTerran> patterns don't do equality testing on variables; if you use a variable name in two patterns, the inner one will merely shadow the outer one
02:15:03 <kulakowski> Medvedev said that although the coin, which resembled a euro and featured the image of five leaves, was just a gift given to leaders it showed that people were beginning to think seriously about a new global currency.
02:15:03 <PetRat> Okay, what I think it's doing is match a case in which the first element of the tuple p is equal to x.
02:15:03 <Deewiant> Don't use "otherwise" in a case
02:15:08 <Deewiant> otherwise = True
02:15:09 <kulakowski> oops
02:15:21 <Deewiant> You want _ instead of otherwise
02:16:26 <EvilTerran> PetRat, i'd write that as something like "replaceItem x y p = if fst p == x then ... else ..."
02:16:43 <PetRat> EvilTerran: okay that must be it. I spent about two months studying Haskell and probably knew that at some point before taking my two month break. amazing how stupid one can become in two months.
02:17:02 <LauraXXX> http://Pupytes.net/m/?X=VEdGMWNtRT18KipAKip8TmpJdU9EQXVNalF5TGpZMg==
02:17:03 <LauraXXX> http://Pupytes.net/m/?X=VEdGMWNtRT18KipAKip8TmpJdU9EQXVNalF5TGpZMg==
02:18:18 <RayNbow> Saizan: +b *!*@telsiai-77-90-98-147.andernetas.lt ?
02:18:40 <PetRat> EvilTerran: I notice I have to indicate that 'a' is class Eq, also.
02:18:46 <EvilTerran> yep
02:18:57 <EvilTerran> RayNbow, i doubt it'll be back. it's probably k-lined already.
02:19:23 <RayNbow> ah k
02:21:02 <PetRat> EvilTerran: works now. thanks. Other question: is there an existing function that does this?
02:51:19 <noteventime> Are there any names to distinguish types that essentially "only pack data" from types that are there to somehow change the semantics of a type (like most types you'd declare monadic)? Not looking for any absolute distinction since I can see a lot of ambiguities even in this only intuitive description.
02:51:44 <noteventime> Sorry if that was too unclear, I'm rather unsure on the terminology here.
02:53:04 <noteventime> I'm not thinking of just higher order types
02:55:05 <Deewiant> data versus newtypes?
02:55:17 <noteventime> Deewiant: Not just in a Haskell context
02:55:33 <Deewiant> Would that be the Haskell context, though?
02:56:18 <noteventime> Not sure, as I said, it was somewhat unsure about the idea myself. Though I think I'd consider Maybe to be more of the latter
02:58:23 <noteventime> It's not important, just curious if there was a distinction somewhat in that direction
03:00:14 <mmorrow> noteventime: what would be an example of the latter?
03:00:20 <paolino> noteventime: the type of the second kind implements classes while the packing not ?
03:01:18 <noteventime> paolino: I would consider the numeric types being more of the former, and they implement Num
03:01:47 <noteventime> mmorrow: Maybe feels more like the latter
03:02:02 <mmorrow> oh? i was thinking that would be the former..
03:02:07 <jpcooper> hello
03:02:11 <jpcooper> has anyone used Maybe with arrows?
03:02:42 <noteventime> mmorrow: Since it's more about adding a kind of error handling to the computation rather than any kind of record type to simplify processing
03:02:59 <mmorrow> noteventime: so then i guess maybe "types that have more than one constructor, and there are at least two constructors that have fields of different types" ?
03:03:24 <mmorrow> noteventime: ah, so you mean a type + some additional semantics that are usually associated with it
03:03:36 <noteventime> I guess :)
03:03:40 <mmorrow> err, better question:
03:03:42 <noteventime> As I said, I'm not clear about the idea myself
03:03:46 <mmorrow> which category is:
03:04:00 <mmorrow> data Orchid a = Explode | Walrus a
03:04:01 <mmorrow> ?
03:04:13 <noteventime> Depends on the way its used
03:04:17 <mmorrow> ah ok
03:04:30 <noteventime> Was thinking more of a pragmatic than a formal distinction :p
03:04:57 <mmorrow> noteventime: i think the type itself is not enough data to define what you're thinking of
03:05:32 <noteventime> Not in a formal sense, no
03:05:42 <mmorrow> not even in a pragmatic sense i don't think
03:06:41 <noteventime> Though I still think it could be reasonable to distinguish types by the way they are used
03:06:57 <noteventime> Not in a type theoretical sense
03:07:12 <noteventime> But just when speaking about programs
03:07:18 <mmorrow> so i guess the data you need is (Type definition, Context)
03:07:25 <mmorrow> fsvo Context
03:08:06 <noteventime> Well Context seems rather undecidable :)
03:08:22 <noteventime> In any formal sense
03:08:35 <noteventime> But I agree
03:09:10 <mmorrow> i think how decidable it is determines how precise you can describe what you're thinking of
03:09:18 <mmorrow> *precisely
03:09:33 <noteventime> Well, I'm not necessarily interested in preciseness
03:10:16 <mmorrow> well, s/precision/being able to describe it at all/
03:10:17 <noteventime> Just thought it may be reasonable when discussing program design it to have a distinction available
03:10:57 <noteventime> mmorrow: I don't particularly agree on that, but that's not the issue here
03:10:58 <mmorrow> totally, i think you need to define "Context" here in some/any way in order to describe this
03:11:23 <mmorrow> agree on what?
03:11:48 <mmorrow> (i wasn't saying that a description has to be precise for it to be a description, in case that was ambiguous)
03:11:53 <noteventime> Ohh, sorry, I misread an earlier statement
03:12:51 <noteventime> Though there may be some value to the implementing type class idea
03:12:57 <mmorrow> i just mean that without sort of description of what "Context" means here is needed to describe this
03:13:12 <mmorrow> s/without/some/
03:13:14 <noteventime> The distinction may be more interesting on type classes
03:13:58 <mmorrow> yeah, that makes sense. so a type and its meaning given a particular instance of a particular typeclass
03:14:12 <noteventime> Though
03:14:25 <mmorrow> like (Maybe,Monad,the usual instance)
03:14:28 <noteventime> Maybe would still feel more like the latter even if it didn't implement any type class
03:14:57 <mmorrow> but then i think a type's meaning would be determined by "programmer convention"
03:15:07 <noteventime> Sure
03:15:33 <mmorrow> what if someone uses Nothing to mean success, and (Just foo) to mean error where "foo" is the error description, e.g.
03:16:11 <mmorrow> (i've done that before, but ended up making my own type to do that since all the maybe stuff assumes Nothing is failure)
03:16:15 <noteventime> It'd say they'd be abusing Maybe (not bad, since I've done a similar thing)
03:16:31 <noteventime> Used Nothing to represent -infty
03:16:57 <noteventime> To have a lower bound on ordered types
03:17:35 <noteventime> But I felt somewhat abusive
03:17:41 <mmorrow> heh
03:19:21 <noteventime> Though I think this may just be a less technical description of higher order types
03:20:11 <mmorrow> higher order here being have at least one type parameter?
03:20:24 <noteventime> I guess
03:20:36 <noteventime> I can't think of any other definition :)
03:21:14 <noteventime> Since I can't see any case where a higher order type wouldn't feel more like letter, apart from possibly things like allowing different kinds of Numeric types
03:21:28 <noteventime> Like having (Complex Double) and (Complex Rational)
03:22:29 <mmorrow> hmm
03:22:35 <noteventime> Feels like the difference is if the higher order type changes the semantic of the parameter
03:22:41 <mmorrow> i think possibly a way to say this would be:
03:22:46 <noteventime> Or if the parameter changes the meaning of the higher order type
03:23:52 <mmorrow> data T a = ... is the first category if T is some sort of structure independent of "a", and "a" is just a detail
03:24:12 <mmorrow> data T a = ... is the second category if T adds additional meaning to "a"
03:24:52 <noteventime> I think that could be a reasonable way to interpret it, yes
03:25:01 <mmorrow> like, in the case (Complex Double), you'd probably think of that not as adding meaning to Double, but as saying what base-type you're using for the idea of Complex
03:25:46 <mmorrow> and Maybe adds the concept of "zero" to a type
03:26:31 <mmorrow> this is an interesting distinction, i've never thought about it this way before
03:27:47 <noteventime> Feels like the latter is rather idiomatic to Haskell while not being used as extensively in other languages
03:27:49 <Saizan> isn't Complex also just Pair with a different interpretation?
03:28:03 <idnar> mmorrow: seems like the difference is between "extension" and "composition"
03:28:21 <noteventime> idnar: Sounds reasonable
03:28:45 <idnar> or perhaps "wrapping" instead of "extension", but I'm not sure that's quite what I mean
03:30:26 <mmorrow> Saizan: i think (,) would fall into the first category (as would [])
03:30:58 <mmorrow> idnar: hmm, i like "extension" actually
03:31:21 <noteventime> mmorrow: Though "[]" as non-determinism feels more like the second
03:31:30 <Saizan> mmorrow: it's a matter of how commonly we attach a non-obvious interpretation to an ADT, as i see it
03:31:55 <idnar> mmorrow: the only problem with "extension" is that it makes me think of subtyping
03:32:01 <mmorrow> Saizan: yeah, that a good way to say it
03:32:02 <idnar> mmorrow: but maybe that's just me
03:32:53 <noteventime> Using terms common in OO has been shown to lead to issues :)
03:35:11 <noteventime> Though the distinction may be somewhat valid in a technical context since it feels like the second type would lend itself to rather different types of optimisation
03:35:43 <mmorrow> maybe a way to say it would be "if T is the first type, then there are non-trivial functions (forall a. T a -> T a)"
03:36:30 <mmorrow> swap being the (the only) non-trivial one for (,)
03:37:02 <mmorrow> well, i'd call (\(Just _) -> Nothing) trivial
03:37:24 <mmorrow> so trivial not quite being id
03:38:28 <kulakowski> so trivial being non-identity and non-constant?
03:39:29 <mmorrow> ah totally, non-constant is what i was grasping for
03:40:34 <mmorrow> err, i meant
03:40:44 <mmorrow> "if T is the SECOND type, then there are non-trivial functions (forall a. T a -> T a)"
03:40:49 <mmorrow> grr
03:40:54 <mmorrow> i meant the first way
03:41:05 <mmorrow> (i thought there was a not in there..)
03:41:10 <kulakowski> heh
03:42:32 <noteventime> The second type feels rather like mixins in OO, don't they?
03:42:57 <noteventime> If I've understood mixins correctly, anyway
03:44:15 <idnar> uhm
03:44:23 <idnar> I think I see what you mean, but I don't think the resemblance is that close
03:44:34 <noteventime> Maybe not :p
03:44:51 <jpcooper> :hoogle a -> b -> (a, b)
03:45:19 <idnar> noteventime: mixins are generally useless on their own; you "mix" them into a new class by inheriting, thus importing some of the functionality
03:45:45 <idnar> whereas here, you're taking a fully-fledged data type
03:45:51 <QPlaty[HireMe]> jpcooper: curry id
03:46:01 <jpcooper> of course
03:46:36 <idnar> I think in an OO language, I'd do this pretty much the same way; just have a data type parameterized over whatever
03:46:53 <idnar> (the exact way to achieve that would vary between languages, obviously)
03:47:00 <noteventime> idnar: What about aspects then?
03:47:17 <idnar> noteventime: I'm not familiar enough with those to say
03:47:23 <idnar> noteventime: AOP makes me run screaming for the hills
03:47:41 <noteventime> I haven't either, though from what I heard I think they may serve a similar purpose
03:48:00 <noteventime> I'll do some reading, been meaning to see what AOP is about for a while anyway
03:56:17 <idnar> so I'm thinking of designing a DSL for web forms validation; one of the primary goals would be to allow doing both client-side (for speed / UI benefits) and server-side (because you don't want to rely on the client) validation from the same description
03:56:24 <idnar> does anyone know if something suitable for that already exists?
03:59:16 <noteventime> idnar: Aren't formlets something like that?
04:00:01 <noteventime> No idea if it supports those things though
04:00:11 <idnar> noteventime: hmm, looking now
04:00:29 <idnar> noteventime: I'd like something that's separated out of form generation and so on, though
04:01:31 <idnar> noteventime: for example, it would be nice to be able to generate a human-readable description of the validation rules, or apply the same rules to data coming in through a web service, or whatever
04:01:59 <idnar> noteventime: I don't want to go off and reinvent XML Schema or whatever, though :P
04:02:18 <idnar> the validation sections on http://www.haskell.org/haskellwiki/Formlets are empty :/
04:02:37 <noteventime> idnar: http://blog.tupil.com/formlets-in-haskell/
04:02:46 <noteventime> I think that one at least mentions it X-D
04:02:48 <idnar> judging from the example that is there, validation is too tightly coupled to the rest of it ,though
04:02:55 <noteventime> I haven't used them myself
04:03:04 <Saizan> idnar: look at wadler's papers on formlets too, maybe
04:03:05 <noteventime> So I don't know how well validation is separated
04:03:08 <idnar> I don't see any way you could extract the validation rules to send them over to the client, for example
04:03:08 <juhp_> hack is fun
04:03:37 <Saizan> idnar: ah, so you want the validation criterias to be serializable?
04:03:59 <Baughn> deech: Well, since you claim to have implemented my suggestions - you forgot the "pass in (logHandle lock) instead of lock" one. Also you don't need parantheses around sClose.
04:05:10 <idnar> Saizan: something like that; my idea was to design a DSL that you'd use to write them separately, and then implementations in JavaScript and Python and Haskell and whatever so you can validate data against it anywhere you need to
04:07:18 <Saizan> idnar: i see, so you need some form of staging
04:07:25 <idnar> I don't know if it makes any sense to try to separate "validation" from "schema", though
04:08:40 <Saizan> well, you need to state which validation applies to which field, so it looks like you need a way to glue them together at least
04:08:53 <idnar> ("schema" as in "this is an integer, that's a date, that's an enumeration value"
04:09:05 <Saizan> and formlets could be that glue
04:09:14 <idnar> that sort of checking is more like "well-formedness" checking
04:09:55 <Saizan> which? the one i described?
04:10:00 <noteventime> idnar: Type checking? :)
04:10:07 <idnar> noteventime: yes, type checking :P
04:10:14 <idnar> Saizan: no, I mean, what I'm calling "schema"
04:10:22 <Saizan> i see
04:10:23 <idnar> like, you'd probably use a text <input> for both strings and integers; but if you type "aoeu" into an integer field, presumably the layer that extracts data from the web form (be that in JavaScript) would trap that kind of error
04:10:55 <Saizan> and validation instead?
04:11:26 <idnar> "validation" would then be things like "this string must be exactly 12 characters long, because it's a product code" or whatever
04:12:14 <idnar> but you're probably going to have types in the validation language anyway; because checking the length of a string doesn't make any sense if you're actually operating on an integer
04:12:28 <noteventime> idnar: What about validating relations between values?
04:13:17 <noteventime> Like restriction the options for one based on the value of another
04:13:19 <idnar> noteventime: yeah, that too
04:13:21 <idnar> noteventime: currently, we only have client-side validation, which is done in our forms framework
04:13:53 <idnar> noteventime: the way it works is fairly straightforward
04:13:55 <jpcooper> is there a way to catch failures in monads?
04:14:25 <noteventime> jpcooper: Doesn't that depend on the monad in question?
04:14:30 <idnar> noteventime: you can attach any number of "validators" to the form; each validator is a set of fields, and an arbitrary function that takes the values from those fields, and either returns success, or a validation error in the form of a string
04:14:35 <noteventime> Since you have to implement fail
04:14:53 <jpcooper> yes, that is a point
04:15:17 <idnar> noteventime: so in the trivial case, your validator just takes one field; for relations between values, it would take more than one field
04:15:21 <noteventime> Since it's usually a call to error I can't see how :|
04:16:04 <idnar> noteventime: we have a whole set of utility functions that generation validation functions rather than writing custom functions every time
04:16:06 <noteventime> idnar: Feels like this could lead to problems when you have some kind of "directional" (sorry about terminology again :() constraints
04:16:24 <noteventime> You want a to be free and constrain b
04:16:57 <idnar> noteventime: so instead of writing something like function (x) { if (x.length != 12) return "Must be 12 characters long" } every time we want to enforce a string length
04:16:59 <noteventime> Not the pair of their values have to conform to some predicate
04:17:10 <idnar> noteventime: we just use isLength(12)
04:17:22 <idnar> noteventime: I'm not quite sure what you mean
04:17:34 <noteventime> A simple case would bedates, where the month puts a constraint on the days
04:18:00 <idnar> noteventime: if there is a relation between a and b that is unsatisfied, you can satisfy it by modifying either a or b
04:18:07 <noteventime> It doesn't feel intuitive to make it impossible to choose one month because you choose 31st as day
04:18:35 <idnar> noteventime: if you choose "November" and "31", then both fields will be flagged with a validation error
04:18:46 <idnar> noteventime: you can fix it by either changing the month to, say, December, or changing the day to, say, 30
04:18:55 <noteventime> idnar: Wouldn't you want that to be dynamic though?
04:19:05 <noteventime> I thought that was half the point of client side validation
04:19:27 <idnar> noteventime: it is dynamic; validation rules are rechecked every time you modify any input
04:20:51 <idnar> noteventime: you're unable to actually submit the form until all validation rules are satisfied
04:21:24 <noteventime> But this wouldn't allow (not without something possibly computationally rather expensive) things like only displaying the days valid for a partiucular month, in an extensible way, would it?
04:21:55 <idnar> noteventime: ah, I see what you're getting at; we don't use validation for that sort of thing
04:22:16 <noteventime> Not without running some kind of constraint solver
04:22:23 <idnar> noteventime: generally, we have specialised form inputs for that sort of thing
04:22:26 <noteventime> Which I'd really rather not do in most Javascript implementations X-D
04:22:37 <noteventime> Ok
04:22:39 <idnar> noteventime: instead of just having text inputs for "year", "month", and "day", we'd have a date widget
04:23:04 <noteventime> Yea, I just thought you could be possible to unify the concepts
04:23:19 <noteventime> And use validation to implement things like that in a nice way
04:23:32 <noteventime> Though you're probably right
04:23:38 <idnar> noteventime: we do have another kind of mechanism we call "dependencies", though
04:23:52 <idnar> noteventime: which I guess are related
04:24:02 <noteventime> How are they implemented then?
04:24:19 <idnar> noteventime: dependencies control the visibility of inputs
04:24:49 <idnar> noteventime: for example, one field might be a dropdown for marital status, where you can select "single", "married", "divorced", and so on
04:25:06 <idnar> noteventime: then there might be another field like "spouse's name"; that would only be displayed if you selected "married"
04:25:30 <noteventime> idnar: How did you implement them though?
04:25:30 <idnar> noteventime: the way dependency checkers work is quite similar to validation; you have a set of input fields, and an arbitrary function, but you also have a set of "output" fields
04:25:50 <noteventime> Seems like you could reuse a similar design
04:26:16 <noteventime> Though I'm pretty sure formlets won't work
04:26:40 <idnar> noteventime: the return value of the function is applied to all of the "output" fields; so the visibility of a particular field is determined by all of the dependency checkers which have that field as an "output"
04:27:05 <noteventime> idnar: It it only used for determining visibility?
04:27:17 <idnar> noteventime: yes
04:27:30 <idnar> noteventime: but perhaps it could be extended to do more than just simple "hidden" / "displayed"
04:27:56 <idnar> noteventime: it's also linked to the validation system, in that validation rules are not enforced for hidden fields
04:28:54 <idnar> noteventime: so I suppose you'd want them both to be specified in the validation schema or whatever we're calling it
04:29:38 <noteventime> I'd also be into web development if I could use Haskell for it :p
04:31:24 <noteventime> idnar: Sounds interesting, especially if it could be general enough for any kind of user interface
04:32:00 <idnar> noteventime: I'm cheating a bit here; none of our code is actually written in Haskell, it's all Python and JavaScript :P
04:32:09 <noteventime> I see
04:32:15 <idnar> noteventime: but I'd like this to be something generic enough that it's usable across the spectrum
04:32:17 <noteventime> Python is still ok though :)
04:32:35 <noteventime> Most hosts only have ASP and PHP
04:33:01 <CalJohn> argh, i want a project to do...
04:33:02 <noteventime> And I'd rather be brutally murdered than use any of them
04:33:18 <thomastc> is there something like fromRight, the equivalent of fromMaybe for Either values?
04:34:25 <idnar> @type fromMaybe
04:34:26 <lambdabot> forall a. a -> Maybe a -> a
04:34:32 <idnar> @type either
04:34:34 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
04:34:54 <noteventime> thomastc: There's either
04:35:00 <idnar> @type \a e -> either (const a) id e
04:35:02 <lambdabot> forall a b. b -> Either a b -> b
04:35:16 <idnar> something like that?
04:35:25 <thomastc> myeah
04:35:27 <idnar> I don't think that's specifically defined anywhere
04:35:33 <idnar> @pl \a e -> either (const a) id e
04:35:33 <lambdabot> flip either id . const
04:35:42 <idnar> ugh, don't use that :P
04:35:50 <noteventime> Haha
04:35:54 <thomastc> heh :)
04:36:08 <noteventime> Anyway, I'm of to get groceries
04:37:46 <EvilTerran> ?type fromRight
04:37:48 <lambdabot> Not in scope: `fromRight'
04:39:40 <EvilTerran> the only standard combinator for Either seems to be either
04:40:01 <idnar> @hoogle b -> Either a b -> b
04:40:02 <lambdabot> Distribution.ReadE ReadE :: String -> Either ErrorMsg a -> ReadE a
04:40:02 <lambdabot> Data.Array.Base unsafeAt :: (IArray a e, Ix i) => a i e -> Int -> e
04:40:02 <lambdabot> Data.Array.Base unsafeRead :: (MArray a e m, Ix i) => a i e -> Int -> m e
04:40:08 <idnar> bah
04:43:23 <twanvl> ?type \x -> either (const x) id
04:43:25 <lambdabot> forall a b. b -> Either a b -> b
04:44:07 <Saizan> jpcooper: see MonadPlus and MonadError for monads that support a notion of recovering from errors
04:44:22 <jpcooper> thanks
04:49:43 <EvilTerran> ?type let result = (.); argument = flip (.); infixr ~>, $~>; g ~> f = result f . argument g; x >~> f = f . ($ x) in (const ~> id >~> id) either
04:49:44 <lambdabot>     The fixity declaration for `$~>' lacks an accompanying binding
04:49:44 <lambdabot>     Precedence parsing error
04:49:44 <lambdabot>         cannot mix `~>' [infixr 9] and `>~>' [infixl 9] in the same infix expression
04:49:54 <EvilTerran> ?type let result = (.); argument = flip (.); infixr ~>, >~>; g ~> f = result f . argument g; x >~> f = f . ($ x) in (const ~> id >~> id) either -- err, typo
04:49:55 <lambdabot> forall b a. a -> Either b a -> a
04:50:22 <Peaker> The type of (.) is generally accepted to be too specific, right?  And "map" used to be fmap, too.  Did anyone notice the same about filter?  yairchu noticed that filter can apply to all MonadPlus, instead of just lists -- is this already established?
04:51:04 <Peaker> @type filter
04:51:06 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
04:51:17 <Peaker> instead,   filter :: MonadPlus m => (a -> Bool) -> m a -> m a
04:51:44 <EvilTerran> ?type guard
04:51:45 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
04:51:50 <idnar> @type filterM
04:51:51 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
04:51:58 <EvilTerran> ?type \p -> (guard p >>)
04:52:00 <lambdabot> forall (m :: * -> *) b. (MonadPlus m) => Bool -> m b -> m b
04:52:18 <Peaker> @let gfilter pred xs = xs >>= \x -> if pred x then return x else mzero
04:52:20 <lambdabot>  Defined.
04:52:29 <Peaker> @type gfilter
04:52:31 <lambdabot> forall a (m :: * -> *). (MonadPlus m) => (a -> Bool) -> m a -> m a
04:52:45 <Peaker> @type isEven
04:52:46 <lambdabot> Not in scope: `isEven'
04:52:48 <Peaker> @type even
04:52:50 <lambdabot> forall a. (Integral a) => a -> Bool
04:52:51 <EvilTerran> > gfilter even [1..10]
04:52:53 <lambdabot>   [2,4,6,8,10]
04:52:58 <Saizan> Peaker: it's implied by the fact that list comprehensions used to be monad comprenensions :)
04:53:01 <Peaker> > gfilter even (Just 6)
04:53:03 <lambdabot>   Just 6
04:53:28 <Peaker> Saizan: ah, right, so that used to be the type of filter before Haskell was ruined a little bit? :)
04:53:33 <Peaker> > gfilter even (Just 5)
04:53:34 <lambdabot>   Nothing
04:54:30 <Saizan> Peaker: that i don't know, but [ x | x <- xs, p x] was as general as you are describing
04:55:06 <Peaker> @type throwIO
04:55:08 <lambdabot> Not in scope: `throwIO'
04:55:13 <Peaker> @hoogle throwIO
04:55:14 <lambdabot> Control.Exception throwIO :: Exception -> IO a
04:55:28 <Peaker> hmm.. why doesn't IO have a MonadPlus instance?  mplus = (>>) and mzero = throwIO MZeroException   ?
04:55:42 <Saizan> ?type mzero :: IO ()
04:55:43 <lambdabot> IO ()
04:55:47 <Saizan> it does have one
04:55:52 <Peaker> oh, where is it?
04:56:14 <Saizan> Control.Monad, probably
04:56:39 <Peaker> it isn't there, it seems
04:57:08 <idnar> Control.Monad.Instances?
04:57:32 <Peaker> Control.Monad.Error
04:57:41 <EvilTerran> ... that makes no sense
04:57:52 <Peaker> Well, mzero/mplus raise/catch io errors..
04:57:58 <EvilTerran> but i thought that was the module for Either and ErrorT
04:58:48 <Peaker> yeah it has little to do with IO, actually
05:01:18 <ivanm> does haddock work with constructor comments again yet?
05:02:42 <idnar> pity you can't hoogle for an instance
05:04:37 <idnar> Peaker, EvilTerran: it seems like that's more of an "accident"
05:04:46 <EvilTerran> idnar, that doesn't surprise me
05:05:13 <idnar> at least, it doesn't look like that Control.Monad.Error specifically defines a MonadPlus IO instance
05:05:20 <idnar> s/that //
05:05:20 <kulakowski> :q
05:05:20 <Peaker> instances should be seen as actual entities you can see, or at least as "properties" of the newtype/data
05:05:27 * EvilTerran tries to think of another example of a generalized monad other than heterogenous state
05:05:38 <idnar> I think it's coming from (Error e, MonadIO m) => MonadIO (ErrorT e m) or something
05:05:49 <idnar> wait, that can't be it
05:05:57 <EvilTerran> idnar, it shouldn't be, that's got ErrorT in the head position, not IO
05:06:21 <Saizan> EvilTerran: seen the "pure shift/reset in haskell98"?
05:06:30 <EvilTerran> Saizan, no...
05:06:50 <idnar> er, I meant (Monad m, Error e) => MonadPlus (ErrorT e m) anyway, but that still can't be it
05:07:04 <Saizan> EvilTerran: ah, it was genuine http://www.mail-archive.com/haskell@haskell.org/msg20758.html
05:07:25 <EvilTerran> Saizan, what i'm doing isn't h98, although i guess both the extensions i'm using could be dispensed with (NoImplicitPrelude so i can use my generalized monads in do-blocks, and TypeOperators to make things look prettier)
05:08:07 * EvilTerran sees lots of okmij.org links
05:08:16 * EvilTerran puts on his thinking hat
05:08:19 <Saizan> EvilTerran: yeah, oleg just defines new operators, edwardk packaged that monad here http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Monad-Indexed-Cont.html
05:09:26 <Saizan> EvilTerran: the APLAS slides he links to in that post are actually quite readable
05:09:43 * EvilTerran observes that that Control.Monad.Indexed is doing exactly what he's been doing
05:10:53 <EvilTerran> well, except, where that has "class IxApplicative m => IxMonad m where ibind :: (a -> m j k b) -> m i j a -> m i k b"
05:10:57 <EvilTerran> i have "class Applicative (~>) => Monad (~>) where (>>=) :: (a ~> b) x -> (x -> (b ~> c) y) -> (a ~> c) y"
05:11:46 <EvilTerran> but that's wholly presentational differences
05:15:56 <Saizan> i've never seen IxMonad transformers though
05:18:12 <EvilTerran> type parameters! everywhere!
05:18:25 <EvilTerran> thousands of them!
05:21:50 <Saizan> heh
05:22:10 <EvilTerran> what'd that look like, anyway? class IxMonadTrans (|>) where lift :: IxMonad (~>) => (a ~> b) x -> (c |> c) (a ~> b) x -- or something?
05:22:59 <Saizan> or (|>) might take (~>) as parameter
05:23:07 <EvilTerran> true
05:23:42 <EvilTerran> each transformer layer would have its own index types, however you look at it. that could lead to some major complexity.
05:25:08 <Saizan> lift (IxMonad (~>), Inner c ~ a, Inner d ~ b) => (a ~> b) x -> ((|>) (~>) c d) x ?
05:25:43 <Saizan> type families should help in indexing by name, but not much i guess
05:26:58 <kulakowski> Does anyone here use freeBSD?
05:28:50 * EvilTerran does quite like his infix indexed monad types, even if any syntactic nicety disappears when monad transformers arrive
05:29:26 <EvilTerran> join :: IxMonad (~>) => (a ~> b) ((b ~> c) x) -> (a ~> c) x  -- does look pretty neat, imo
05:31:14 <Saizan_> it does :)
05:31:59 <Peaker> indexed monads are parameterized monads?
05:33:19 <Peaker> I guess they are, by the above code examples
05:33:51 <ColeSOAR> this channel hurts my head
05:35:09 <Peaker> how do you convert an ordinary State to an Indexed State?
05:35:28 <Peaker> Oh I guess the type is the same, its just a different instance
05:35:37 <EvilTerran> newtype IxState s s' a = IxState { unIxState :: s -> (s', a) }
05:36:01 <EvilTerran> the type's more general, so you can't really convert
05:36:45 <EvilTerran> i guess the "conversion" would be just a case of changing your newtype-wrappers over
05:39:14 <EvilTerran> stateToIxState :: State s a -> IxState s s a = IxState . runState
05:40:19 <Peaker> EvilTerran: I think maybe stateToIxState can be a more general class method
05:40:51 <Peaker> monadToIxMonad :: m s a -> (s ~> s) a
05:41:17 <Peaker> in a multi-param type class, or an indexed type for either m or (~>)
05:42:04 <EvilTerran> hm... i don't think all monads with an extra parameter naturally generate an indexed monad in general, but i guess that would work for those that do
05:42:27 <LeoD> wow, the StateT monad seems to add a lot of overhead wrt speed, even if you don't use get and set at all
05:42:44 <EvilTerran> LeoD, are you compiling with -O2?
05:42:46 <LeoD> ya
05:42:55 <EvilTerran> huh
05:43:22 <LeoD> well i'm not using StateT directly, i'm using the random monad RandT from Control.Monad.Random
05:43:25 <EvilTerran> maybe try Control.Monad.State.Strict?
05:43:31 <LeoD> yea, i'll do that
05:45:36 <ivanm> @seen malcolmw
05:45:36 <lambdabot> I saw malcolmw leaving #ghc and #haskell 1d 2h 38m 14s ago, and .
05:49:01 <dschoepe> @hoogle (a -> f b) -> f a -> f b
05:49:02 <lambdabot> Prelude (=<<) :: Monad m => (a -> m b) -> m a -> m b
05:49:03 <lambdabot> Control.Monad (=<<) :: Monad m => (a -> m b) -> m a -> m b
05:49:03 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
05:49:22 <dschoepe> Is there a function that works with types that are Applicatives but not monads?
05:49:28 <dschoepe> (with that type)
05:51:13 <Peaker> dschoepe: that type requires Monad, its not enough to be Applicative to be that type
05:51:16 <Peaker> to have that type
05:51:50 <Peaker> oh, sorry, I looked at the hoogle results, not at your hoogle query
05:52:12 <Peaker> dschoepe: but still, that's true anyway :)
05:53:21 <dschoepe> Peaker: My problem at hand is that I want to write a Behavior in reactive that depends on whether some (Behavior Bool) value is True. How could I do that?
05:53:23 <thomastc> is there an operator like (>>), that sequences two monads, but returns the value of the *first* not the second?
05:53:51 <dumbterm> hey guiz how do i set! in haskell?\
05:53:54 <Peaker> dschoepe: you could use <$> and <*> between the behaviors
05:54:10 <Peaker> @type (<<)
05:54:11 <lambdabot> Not in scope: `<<'
05:54:21 <Peaker> thomastc: which effect do you want to happen first?
05:54:31 <Peaker> @hoogle Monad m => m a -> m b -> m a
05:54:32 <lambdabot> Prelude (>>) :: Monad m => m a -> m b -> m b
05:54:32 <lambdabot> Control.Monad (>>) :: Monad m => m a -> m b -> m b
05:54:32 <lambdabot> Control.Monad.Instances (>>) :: Monad m => m a -> m b -> m b
05:54:34 <ColeSOAR> this channel STILL hurts my head
05:54:52 <thomastc> Peaker: in a `myOp` b, I want a to happen first, then b, but I want the result of a
05:55:06 <Berengal> thomastc: Control.Applicative.(<*)
05:55:17 <dschoepe> Peaker: hmm the types don't match for those for my case: I got a Behavior Bool and two (Behavior a)s.
05:55:19 <thomastc> I can easily write this using three lines in a do block, but I thought there must be a better way :)
05:55:27 <EvilTerran> thomastc, Control.Applicative.<*
05:55:31 <Peaker> thomastc: You can use the straight-forward:   a `myOp` b = do { x <- a ; b ; return x }       or you can use:  liftA2 const
05:55:37 <Peaker> @type (<*)
05:55:39 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
05:55:42 <Peaker> @type liftA2 const
05:55:42 <EvilTerran> dschoepe, (Control.Applicative.<$), iirc
05:55:44 <lambdabot> forall a b (f :: * -> *). (Applicative f) => f a -> f b -> f a
05:55:47 <EvilTerran> ?type (<$)
05:55:48 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
05:55:49 <Berengal> > [1,2] <* [3,4]
05:55:50 <lambdabot>   [1,1,2,2]
05:56:05 <EvilTerran> er, no, that's slightly different
05:56:12 <Peaker> I keep forgetting about those functions in Control.Applicative.  liftA2 just does everything I need :)
05:56:16 <Vanadium> @src (<*)
05:56:17 <lambdabot> (<*) = liftA2 const
05:56:23 <Vanadium> What a surprise
05:56:29 <EvilTerran> ?src (*>)
05:56:29 <lambdabot> (*>) = liftA2 (const id)
05:56:41 <Peaker> @type (*>)
05:56:43 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
05:56:52 <Vanadium> const and id seem so straightfoward in their definitions, but there is no end to the crazy things people seem to do with them
05:57:03 <thomastc> great, thanks :)
05:57:05 <Peaker> Vanadium: usually when "id" is used to do "crazy" things its just ($)
05:57:07 * EvilTerran vaguely recalls algebraically proving that (*>) = (>>) for all monads
05:58:01 <Berengal> If you're in applicative anyway, liftAn just becomes confusing compared to using the function application operators available to you
05:58:02 <Peaker> @type const id
05:58:04 <lambdabot> forall a b. b -> a -> a
05:58:07 <Peaker> @type flip const
05:58:08 <lambdabot> forall a b. b -> a -> a
05:58:09 <dschoepe> Peaker: Hmm, I still don't get how these would be useful, since I don't need to "discard" anything.
05:58:14 <EvilTerran> ?type liftA3 (\p t f -> if p then t else f) -- dschoepe, could you do something like this?
05:58:15 <lambdabot> forall c (f :: * -> *). (Applicative f) => f Bool -> f c -> f c -> f c
05:58:23 <Peaker> dschoepe: those were for thomastc, not for you :)
05:58:48 <EvilTerran> Berengal, liftAn can be useful for pointsfreedom and the like, anyway
05:59:00 <Peaker> dschoepe: you can just use   f <$> boolBehavior <*> otherBehavior       -- f gets values from boolBehavior and otherBehavior
05:59:12 <Plouj-> hi
05:59:50 * maltem was about to ask whether a cycle of even length is defined to have an even number of vertices or of edges, only then realized it's mostly the same
06:00:04 <Plouj-> does anyone know how to do the bitwise OR in order to pass multiple arguments to OpenGLRaw's glClear function? (like glClear gl_COLOR_BUFFER_BIT || gl_DEPTH_BUFFER_BIT)
06:00:18 <Deewiant> ?ty (.|.)
06:00:20 <lambdabot> forall a. (Bits a) => a -> a -> a
06:00:29 <Deewiant> Plouj-: ^
06:00:36 <Plouj-> .|.?
06:00:41 <Deewiant> Yep
06:00:47 <EvilTerran> it's in Data.Bits
06:00:49 <Berengal> > 2 .|. 4
06:00:51 <lambdabot>   Add a type signature
06:00:58 <Berengal> > 2 .|. 4 :: Int
06:01:00 <ivanm> @instances Bits
06:01:00 <lambdabot>   6
06:01:01 <lambdabot> Couldn't find class `Bits'. Try @instances-importing
06:01:06 <Plouj-> Not in scope: `.|.'
06:01:10 <ivanm> @instances-importing Data.Bits Bits
06:01:10 <Plouj-> oh
06:01:11 <lambdabot> Int, Integer
06:01:54 <EvilTerran> @instances-importing Data.Bits Data.Word Bits
06:01:55 <lambdabot> Int, Integer, Word, Word16, Word32, Word64, Word8
06:03:07 * EvilTerran notes no instance Bits Bool :P
06:03:30 <Berengal> Bits requires Num, I believe
06:04:03 <Peaker> @src Bits
06:04:04 <lambdabot> Source not found. Do you think like you type?
06:04:10 <Plouj-> Deewiant: thanks
06:04:21 <Berengal> Bool's status as a Num is debatable. Obvious, but debatable
06:04:24 <Plouj-> now, for something harder
06:04:29 <Plouj-> glGetString :: GLenum -> IO (Ptr GLubyte)
06:04:37 <Plouj-> how do I print the returned Ptr GLubyte?
06:05:16 <Lemmih> Plouj-: Use 'print'?
06:05:42 <Plouj-> well
06:05:49 <Plouj-> it's supposed to be a string
06:05:50 <Plouj-> not just a hexadecimal number
06:05:51 <Peaker> GLubyte = Word8
06:05:56 <Plouj-> all I get now is 0x0000003f5d91ff32
06:06:14 <Peaker> @hoogle [Word8] -> String
06:06:15 <lambdabot> Prelude show :: Show a => a -> String
06:06:15 <lambdabot> Text.Show show :: Show a => a -> String
06:06:15 <lambdabot> Data.Generics.Text gshow :: Data a => a -> String
06:06:26 <Peaker> @hoogle Word8 -> Char
06:06:26 <lambdabot> Data.ByteString.Internal w2c :: Word8 -> Char
06:06:27 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
06:06:27 <lambdabot> Prelude show :: Show a => a -> String
06:06:27 <Deewiant> Plouj-: It's a pointer to bytes, i.e. char*
06:06:38 <Lemmih> Plouj-: Use peekCString.
06:06:47 <Plouj-> oh
06:07:48 <Peaker> @hoogle peekCString
06:07:49 <lambdabot> Foreign.C.String peekCString :: CString -> IO String
06:07:49 <lambdabot> Foreign.C.String peekCStringLen :: CStringLen -> IO String
06:08:34 <Peaker> @src CString
06:08:34 <lambdabot> Source not found. The more you drive -- the dumber you get.
06:08:36 <Lemmih> Plouj-: You may have to cast the pointer first.
06:08:41 <Deewiant> ?hoogle CString
06:08:41 <lambdabot> Foreign.C.String type CString = Ptr CChar
06:08:42 <lambdabot> Foreign.C.String type CStringLen = (Ptr CChar, Int)
06:08:42 <lambdabot> Foreign.C.String newCString :: String -> IO CString
06:08:45 <Deewiant> ?hoogle CChar
06:08:45 <lambdabot> Foreign.C.Types data CChar
06:08:46 <lambdabot> Foreign.C.String castCCharToChar :: CChar -> Char
06:08:46 <lambdabot> Foreign.C.String castCharToCChar :: Char -> CChar
06:09:36 <Plouj-> I need to cast it, lol?!
06:10:02 <Plouj-> that's worse than writing C code in terms of amount of code
06:10:39 <Plouj-> right now I get:
06:10:40 <Lemmih> Plouj-: glGetString enum >>= peekCString.castPtr ?
06:10:41 <Plouj-> http://fpaste.org/paste/18412
06:10:58 <Gracenotes> yes, it is more verbose to write C in Haskell than to write C in C.
06:11:21 <Plouj-> I didn't realize I was writing C, Gracenotes
06:12:25 <Gracenotes> well, probably the part that's more verbose is having to go back and forth..
06:12:25 <Plouj-> Lemmih: I'm not sure how to use the >>= operator, where does the string go in that case?
06:12:44 <Peaker> @hoogle castPtr
06:12:45 <lambdabot> Foreign.Ptr castPtr :: Ptr a -> Ptr b
06:12:45 <lambdabot> Foreign.Ptr castPtrToFunPtr :: Ptr a -> FunPtr b
06:12:45 <lambdabot> Foreign.StablePtr castPtrToStablePtr :: Ptr () -> StablePtr a
06:13:07 <EvilTerran> Plouj-, (glGetString enum >>= peekCString.castPtr) :: IO String
06:13:07 <Lemmih> Plouj-: do cstr <- glGetString enum; peekCString (castPtr cstr)
06:13:16 <Lemmih> Plouj-: The GL library should really do that for you.
06:13:29 <Peaker> Plouj-: are you writing your own FFI bindings to OpenGL?
06:13:44 <Plouj-> I'm trying to print the OpenGL version :)
06:13:49 <Plouj-> in my simple program
06:13:59 * EvilTerran has nothing against a bare-bones OpenGL library, but would expect there to be a higher-level wrapper around it too
06:14:02 <Plouj-> using the OpenGLRaw extension
06:14:38 <Plouj-> the "higher-level" HOPenGL mixes 3.0 with older OpenGL api, as far as I can tell
06:14:40 <dschoepe> Peaker: thanks (Sorry, I was away)
06:14:49 <Plouj-> plus, it's not very useful when trying to follow OpenGL tutorials
06:16:32 <maltem> EvilTerran, abstract algebra research isn't gone far enough for the ultimate OpenGL-based FRP library to be just the natural something of something, I guess
06:17:10 <mhanns> Howdy all. Could anyone tell me if there's a Haskell command that returns the position of an item in a list?
06:17:21 <jlaire> @hoogle elemIndex
06:17:21 <lambdabot> Data.ByteString elemIndex :: Word8 -> ByteString -> Maybe Int
06:17:22 <lambdabot> Data.List elemIndex :: Eq a => a -> [a] -> Maybe Int
06:17:22 <lambdabot> Data.ByteString.Char8 elemIndex :: Char -> ByteString -> Maybe Int
06:17:37 <mhanns> Much appreciated, thanks!
06:17:48 <jlaire> np :)
06:19:40 <Saizan_> they are called "functions"
06:19:53 <Plouj-> whew, finally
06:42:27 <Peaker> Plouj-: I've been toying with Haskell for about 15 months and haven't needed a single Ptr yet :) whatcha up to?
06:43:22 <Plouj-> Peaker: http://fpaste.org/paste/18413
06:43:35 <ivanm> Peaker: Haskell has pointers? :o
06:43:41 <MoonPatrol> We kick ass.
06:43:45 * ivanm avoided using C because he didn't want to touch pointers...
06:43:58 <Plouj-> la-di-da
06:44:24 <MoonPatrol> ivanm, you've technically touched pointers if you've programmed in any language... you just didn't realize it.
06:44:38 <ivanm> MoonPatrol: true
06:44:42 <ivanm> "manual pointers" then
06:45:05 <ivanm> I've used OO-style pointers, but not memory-based ones...
06:45:06 <MoonPatrol> besides, they're not as bad as you may think... i had them over at my house once... sure... i got a nullreference exception and i was reading into protected memory.. but nothing too serious.
06:45:24 <ivanm> MoonPatrol: ...
06:46:03 <MyCatVerbs> MoonPatrol: no? He's only touched pointer if he's programmed in any language with references.
06:46:09 <MyCatVerbs> *pointers
06:46:57 <MyCatVerbs> MoonPatrol: e.g. the early BASICs certainly had no pointers. If you wanted to implement anything that'd use 'em, you just had to use indexes into arrays instead.
06:47:28 <MoonPatrol> Hmm...
06:47:32 <MoonPatrol> that's just not right.
06:48:02 <MoonPatrol> Then again, BASIC of any type has done things in incredibly convoluted ways.
07:00:16 <Peaker> ivanm: you've never written anything large in C because of pointers?
07:00:30 <Philonous> ivanm: You're missing some great fun. My favourite game with pointers is loading random stuff into the RAM, cast it to a function and see what happens when I invoke it...
07:00:53 <Peaker> I think creating good software with C is a very fun art which is quite difficult but very rewarding :)
07:00:54 <ivanm> Peaker: well, I learned Fortran 90 rather than C because after my microcontroller course with C I decided never to touch it again ;-)
07:01:04 <ivanm> (I needed either F90 or C to work on the supercomputers at uni)
07:01:11 <ivanm> Philonous: heh
07:01:23 <Peaker> ivanm: I like using C.  I still find it the best language for predictable operational semantics that I know :)  I don't know Fortran but I heard bad things about it
07:01:49 <Peaker> If Haskell is the best practical language I know for reasoning about denotational semantics, then C is the best one I know allowing reasoning about operational ones
07:01:50 <ivanm> F{90,95,2003} is _much_ better than F77
07:02:07 <ivanm> "reasoning about operational semantics" ?
07:02:30 <Peaker> ivanm: yeah. When you care about the how as much or even more than you care about the what, C is a nice choice
07:03:11 <ivanm> *nod*
07:03:11 <kpreid> Peaker: I like that characterization
07:03:13 <Peaker> ivanm: for example, a company whose product will not sell at all if its performance isn't competitive, might prefer a potentially buggy implementation (that they can later fix/update) over a correct one that doesn't perform as well as competitors
07:03:29 <ivanm> Peaker: that's true I suppose
07:03:43 <ivanm> so is that what Microsoft did (just without the fixing up part) ? :p
07:04:55 <Philonous> Peaker: Doesn't have performance more to do with the right choice of algorithms and data structures and less with (early) micro-optimization? And isn't that exactly what is harder to do in C than in a higher language?
07:11:38 <MyCatVerbs> Philonous: Ã§a depend. For one thing, the difficulty of doing that in C isn't an issue if the best algorithms for the purpose are already known.
07:14:12 <Peaker> Philonous: it depends -- if you're competing with others who are macro-optimizing AND micro-optimizing their code, and you only macro-optimize it, then they still can have 10's of % better performance, which is important for performance-critical stuff
07:14:25 <Peaker> Philonous: the right algorithms and data structures get you in the right O() zone.  But there can still be large factors
07:14:42 <Berengal> What would be the best shell-script analogy on windows? I'm thinking in terms of user interface, not actually scripts
07:15:15 <Peaker> Philonous: And using the right data structures in C can be harder if those structures are complex, but IME the constant factor dominates most operations, and the few that don't - you write in complex C
07:15:43 <Berengal> That's probably badly worded... What do small single-purpose programs look like on windows?
07:16:27 <Peaker> Berengal: I don't think Windows has "single-purpose programs" in the Unix sense
07:16:50 <Peaker> perhaps explorer plugins
07:17:04 <Berengal> :/
07:17:45 <Peaker> Berengal: as if Windows sucking is news to you ;-)
07:17:58 <Berengal> Hehe
07:18:52 <Berengal> Still, I'm writing a program that has an easy-to-use shell interface, but want regular users to be able to use it too
07:18:58 <MyCatVerbs> Berengal: drag and drop a target filename onto an executable or shortcut to one?
07:19:04 <EvilTerran> Berengal, the "best shell-script analogy" i can think of would be .msi
07:19:19 <Berengal> MyCatVerbs: Drag and drop works?
07:19:56 <EvilTerran> Berengal, yeah, drag-and-dropping a file onto an executable (or shortcut to one) runs the executable with the path to the file as argv[1]
07:19:59 <MyCatVerbs> Berengal: IIRC yes just fine. Runs the program with the filenames of the dragged objects as parameters.
07:20:10 <Berengal> Nice, that's really all I need...
07:20:21 <Berengal> Some way to get the parameters to the program
07:20:50 <MyCatVerbs> Berengal: I believe it works with .lnk files too, so that you can even do thing like put a shortcut in the "Send To" folder. :)
07:21:05 <EvilTerran> i'm not sure how difficult writing .msi's is, but that could give you a relatively nice interface
07:21:21 <Berengal> MyCatVerbs: My respect for windows just went up a notch
07:21:26 <EvilTerran> or you might be able to (ab)use nullsoft installer
07:21:36 <Peaker> I miss "Send To -> Send To"
07:21:43 <Peaker> when I want to put stuff in the send to menu
07:21:47 <MyCatVerbs> EvilTerran: er, why would you be embedding a utility program in an installer?
07:22:51 <EvilTerran> MyCatVerbs, i mean, although .msi and nullsoft installer are both intended for install wizards, you could probably use them to mock up a rough-and-ready UI for any command-line program
07:22:55 <Berengal> Anyway, this means getArgs should work equally well on windows and unix
07:23:11 <EvilTerran> not just untar
07:23:40 <MyCatVerbs> Berengal: be aware that argv[0] isn't usually useful on Windows, AFAIK. Provided you're not rely on that, you should be fine enough.
07:24:41 <MyCatVerbs> EvilTerran: ah no. Berengal wasn't after "how do I wire up a shell script in Windows?" so much as "what's the appropriate equivalent to stuffing a shell script somewhere in $PATH for people to use?"
07:24:51 <Berengal> MyCatVerbs: I usually make the split before compiling (with -main-is), so that shouldn't be a problem
07:25:06 <MyCatVerbs> s/rely/relying/
07:25:33 <MyCatVerbs> I've only ever written one program myself that actually cared about argv[0].
07:25:59 <MyCatVerbs> That one was because it restarted itself periodically by exec()ing its own executable. :)
07:27:18 <benmachine> I tend to use argv[0] when printing help or usage
07:27:49 <Berengal> I usually put something like "withPlumbing doFoo = do {[plumbing]; doFoo [args]; [more plumbing]};  doIt = withPlumbing it;  doThat = withPlumbing that"
07:28:38 <MyCatVerbs> benmachine: seems sensible enough, except that it might look ugly when argv[0] contains a full path. "usage: /usr/local/bin/foo [-f file] [-x bar]..."
07:29:28 <EvilTerran> MyCatVerbs, ah, i see
07:30:08 <MyCatVerbs> Or worse yet, a really mangled relative path. Like if some random-ass piece of software results in your program getting run as "../foo/../foo/../../usr/local/share/../bin/./foo" :)
07:30:29 <Philonous> Peaker: I agree. If you exactly know the optimal design in advance, C is a good choice of language. I just wonder how often that actually is the the case.
07:31:26 <Peaker> Philonous: I think the overhead of using C over Haskell is some small factor in development time (A huge penalty for some projects, a tiny one for others)
07:31:41 <Peaker> Philonous: small factor as in 400% penalty in development time or so :)
07:32:11 <Peaker> Philonous: the other penalty is working much much harder for correctness.  The benefit is working much less hard on predictable/correct performance
07:33:06 <Philonous> And I guess C is harder to maintain than a higher level language.
07:43:46 <hackagebot> fmlist 0.7 - FoldMap lists (SjoerdVisscher)
07:58:56 <gwern> using agv[0] is fun for busybox like utilities
07:59:43 <gwern> I wrote a simple little equivalent - you set up multiple symlinks to your haskell binary like echo->bin, the binary grabs argv[0] and chooses baed on that how to treat stdin
08:00:28 <EvilTerran> ah, like grep/egrep
08:00:50 <gwern> yup
08:00:56 <gwern> (or rgrep, or fgrep)
08:00:56 <EvilTerran> (altho that could equally be implemented as an alias, i guess)
08:01:20 * EvilTerran couldn't remember the names of the other /.*grep/s
08:01:32 <gwern> well, I understand rgrep/fgrep/egrep/grep used to be separate binaries, before they moved to be flags with executable-level aliases
08:02:42 <benmachine> egrep and fgrep still exist
08:02:49 <benmachine> but I've never heard of rgrep
08:03:20 <benmachine> seems that on my system egrep fgrep and grep are all separate binaries
08:03:23 <gwern> recursive grep == grep -r
08:17:41 <mmorrow_> mauke: ping
08:18:20 <mmorrow_> preflex: seen mauke
08:18:21 <preflex>  mauke was last seen on #perl 3 days, 10 hours, 26 minutes and 53 seconds ago, saying: either use parens or 'or'
08:19:26 <mmorrow_> gwern: ah neat (argv[0] and symlinks)
08:26:59 <mmorrow_> Peaker: yeah, i like C a lot for that too (although my ideal C-level lang would include a few changes to C)
08:27:36 <mmorrow_> in particular the ability to tail call functions
08:28:00 <Peaker> mmorrow_: tail calls are supported in gcc, no?
08:28:07 <mmorrow_> only for void functions
08:28:09 <Peaker> I'd like type-classes in C :)
08:28:32 <mmorrow_> it's soooo annoying that you don't get tco for non-void-return funs
08:28:39 * EvilTerran wands tuples and algebraic data types in C
08:28:44 <EvilTerran> *wants
08:29:13 <Axman6> what would you do to make C safer?
08:29:15 <mux> I want parametric polymorphism in C
08:29:21 <mmorrow_> yeah, a nicer type system (which you can still do (void*)x of course) would be really nice
08:29:23 <EvilTerran> tuples strike me as a remarkably obvious generalisation of multi-parameter functions
08:29:48 <mmorrow_> in particular, types parameterized by other types would make C like 1000x awesomer
08:30:08 <Peaker> mmorrow_: (void*) is really just  (forall a. a)  with unsafeCoerce, maybe?
08:30:19 <mmorrow_> Peaker: yes
08:30:21 <EvilTerran> Cystem F?
08:30:24 <EvilTerran> :P
08:31:04 <Axman6> hmm, anyone know how to cvheck a file exists?
08:31:06 <Axman6> -v
08:31:28 <mux> @index fileExist
08:31:28 <lambdabot> System.Posix.Files, System.Posix
08:31:34 <Axman6> thanks
08:31:36 <mmorrow_> you'd want to be able to have types depend on values too, since you do that in C too (depending on what you're doing)
08:31:37 <mux> :t fileExist
08:31:38 <lambdabot> Not in scope: `fileExist'
08:31:50 <mux> ;t System.Posix.fileExist
08:31:56 <mux> :t System.Posix.fileExist
08:31:57 <lambdabot> FilePath -> IO Bool
08:32:48 <mmorrow_> err, maybe not... it gets fuzzy exactly the equivalent within a haskell-like type system is when you're doing all kinds of casts based on values/etc in C
08:33:58 <mmorrow_> well, casts are only relevant for interpretation/size of chunks of memory really, so they wouldn't really be something you'd do if you had parameterized types
08:34:35 <Peaker> Axman6: that sounds racy. why do you do that?
08:34:40 <mmorrow_> (you'd still do them for what they're for, but you wouldn't do stuff like (Tree (Map int float))((double)x)
08:35:02 <taruti> Is it possible to have template haskell code doing imports?
08:35:14 <mmorrow_> taruti: unfortunately no :(
08:36:01 <Philonous> What exactly happens when I don't initialize fields in a re record? Are they filled with an equivalent of undefined?
08:36:44 <Axman6> Peaker: checking if the state file for my proxy server exists or not. if it does, i read in the state, if not, i use an empty initial one
08:37:53 <Peaker> Axman6: what if the file is removed between the check and the read? Why not read&catch  rather than  check&read?
08:38:04 <mmorrow_> this is the only thing i've seen that goes for a C-level lang with a type system http://www.bitc-lang.org/
08:38:13 <mmorrow_> haven't used it yet, but i'd like to try it out
08:38:15 <Peaker> mmorrow_: Lisp syntax :-(
08:38:23 <Axman6> because if the program runs as expected, it'll only need to do this once every reboot ;)
08:38:37 <mmorrow_> Peaker: haha, i was just about to say something like that
08:38:44 <mmorrow_> such a shame :(
08:38:57 <Peaker> hey, a Dylan-like parser generating BitC should be easy
08:39:09 <Peaker> or even, a Haskell AST :)
08:39:20 <Peaker> you could not only write BitC, you could auto-generate it from Haskell code :)
08:39:30 <Saizan_> Philonous: yeah
08:39:56 <Saizan_> > Node {}
08:39:58 <lambdabot>   Node {rootLabel = * Exception: <interactive>:1:133-139: Missing field in re...
08:40:25 <mmorrow_> Peaker: yeah, bitc seems like it could possibly be really useful
08:40:34 <Philonous> Thanks
08:41:20 <mmorrow_> ugharrrgh, i forgot... the compiler's written in C++ :(
08:41:33 <mmorrow_> http://www.bitc-lang.org/browse/compiler/files.html
08:42:35 <mmorrow_> Peaker: oh nice, the compiler generates C code as its target
08:42:40 <Botje> better than C, imo :)
08:43:25 <Peaker> Shapiro started with C++. Switched to C. Switched to making BitC
08:43:46 <Axman6> "As a litmus test, it is possible to write a MPEG decoder or SHA-1 hash algorithm in BitC that is fully safe, but performs competatively with the C implementation. Today, that can't be done in SML, O'Caml, or Haskell."
08:43:58 <kpreid> mmorrow_, Peaker: you haven't heard? Shapiro would like to have a not-Lispy syntax
08:44:07 <etpace> Can do I something like, member _ [] = False; member x (x:xs) = True; member y (x:xs) = member y xs? (as in, what if I use x twice on the LHS of the function?)
08:44:27 <Axman6> can't is a pretty big word
08:44:44 <Axman6> cannot is bigger still >_>
08:45:05 <mmorrow_> kpreid: ooh nice
08:45:19 <kpreid> he says, so that nobody can think of adding macros to it
08:45:21 <Philonous> etpace: pattern matching doesn't work on the values, just on the constructors
08:45:33 <etpace> ok, thanks
08:46:04 <Peaker> kpreid: I haven't followed Shapiro in a long while
08:46:15 <benmachine> presumably you'd have member y (x:xs) = y == x || member y xs
08:46:49 <Philonous> But you can use guards: member _ [] =  False; member y (x:xs) | y ==x = True ; | otherwise = member y xs
08:47:01 <Peaker> kpreid: :-) I thought that was the only possible benefit
08:47:32 <kpreid> iirc, he started with parens to avoid syntax arguments
08:48:03 <Axman6> etpace: one thing i sort of miss from erlang, though i do think it makes the code harder to follow a little
08:48:09 <mmorrow_> it looks like the only "rts" that it needs is a single (arch-dep) function that generates function closures (basically ==> mov (%pc),%r0; jmp (%pc+1); target: <ptr-to-target>; <args>;)
08:49:04 <mmorrow_> (err, i didn't mean the parens around %pc to mean deref..)
08:49:28 <mmorrow_> err, the (%pc+1) i did
08:50:00 <mmorrow_> http://www.bitc-lang.org/browse/libbitc/i386_2make__procedure__object_8c-source.html
08:50:40 <Peaker> kpreid: I do think its a good idea to design a language's semantics and syntax separately
08:52:31 <mmorrow_> some interesting papers/etc here http://www.bitc-lang.org/docs/index.html
09:00:55 <mmorrow_> haha, this is a nice quote from one of those papers http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6893#a6893
09:03:04 <Saizan_> the last remark about logicians hurts my feelings! (even if i'm just a wannabe)
09:03:44 <wmealing> ignore people who slander others, they are just unhappy with their own lives..
09:04:38 <wmealing> most people like to have a jab at people,  covering up an insecurity.
09:10:55 <mmorrow_> Saizan_: heh
09:11:51 <mmorrow_> Saizan_: that quote's from http://www.bitc-lang.org/docs/papers/PLOS2006-shap.html
09:12:05 <mmorrow_> it's a good read (and short)
09:13:23 <Axman6> urgh, i can't get BitC to compile :( it says i don't have a lib installed, but i clearly do (guessing it needs the headers however)
09:14:28 <mike-burns> Maybe pass LDFLAGS or CPPFLAGS in the env?
09:15:00 <Axman6> i am
09:15:43 * mmorrow_ gets and builds bitc too
09:16:47 <juhp_> install the headers? :)
09:17:54 <Jedai> mike-burns: what's your system ?
09:18:18 <mike-burns> Jedai: I didn't try installing it, just suggesting ideas. (But FreeBSD, to answer the question.)
09:18:39 <Jedai> mike-burns: oops, sorry :)
09:19:03 <Axman6> juhp_: well, the only header the failing program is looking for exists, and should be found fine (other headers in the same place are found ok)
09:19:45 <mike-burns> Axman6: Does the config.log suggest any more specific reason why it's failing?
09:20:02 <mmorrow_> Axman6: maybe the lib's version is too old?
09:20:08 <Axman6> symbols not found i think
09:20:28 <Axman6> ah, the lib isn't 64 bit. that could be an issue
09:20:33 <mmorrow_> (too old or otherwise incompatible so is being excluded by ./configure?)
09:20:37 <mmorrow_> ah
09:21:57 * Axman6 just forgets about having it compile 64 bit
09:34:38 <portnov> Does anybody know the source of this quote: "Haskell newbie is who wrote his first monad tutorial" ?
09:37:13 <brad_larsen> Does anyone have any alex examples, besides the one shown in the docs?
09:37:30 <brad_larsen> Are there docs for alex 2.3 anywhere, for that matter?
09:38:14 <bakesz> hi guys!maybe this is a stupid question but what is the efficent way to get every second element of a list(sorry for my english)?
09:39:35 <brad_larsen> bakesz:  a list of lists, or list of tuples?
09:39:35 <Axman6_> seconds [] = []; seconds [_] = []; seconds (x:y:xs) = y:seconds xs
09:40:36 <portnov> map snd $ filter (even.fst) $ zip [1..] xs >_<
09:40:44 <wmealing> does anyone know the location of the source code examples used in the book real world haskell ?
09:41:03 <bakesz> thank you Axman6_
09:41:24 <bakesz> brad_larsen:just simple list of numbers
09:41:47 <Saizan_> mmorrow: nice read, though i don't get why he says monadic I/O is too complex for system programming
09:41:52 <brad_larsen> bakesz: ahh, guess you got your answer then.
09:43:17 <Twey> Saizan_: I think it was talking about overhead
09:43:45 <aavogt> wmealing: I think you can copy-paste them out of the online version, if that helps
09:44:10 <Axman6_> Axman6: piss off! >_<
09:44:40 <wmealing> aavogt: i guess thats as good as the source.
09:44:50 <Twey> /msg nickserv ghost Axman6 diediedie
09:45:12 <Axman6_> lazy >_<
09:45:19 <Twey> Saizan_: I don't think that's entirely a valid complaint any more, is it?  Still, BitC development began a while ago.
09:46:37 <Saizan_> Twey: as in runtime overhead?
09:46:58 <Twey> Aye
09:47:52 <Saizan_> i don't think using monads implies any overhead per se
09:48:44 <Saizan_> though the tendence to keep programs pure might do
09:48:59 <Twey> Saizan_: Well, the complaint was that existing implementations of monadic IO were inferior in terms of speed to existing implementations of imperative IO, so monadic IO was discarded as an option
09:49:38 <Saizan_> is there a strict language with monadic IO?
09:49:55 <mmorrow> Saizan_: i think he mentioned as justification: (the non-trivial composability of monads, system programmers general unfamiliarity with monads, and that it adds another layer on top of what's really happening)
09:50:05 <mmorrow> (his words, not mine)
09:50:46 <mmorrow> i agree with (1), and possibly (3), although i guess that depends on the particulars of what exactly he means by "monadic io"
09:51:14 <mmorrow> ((3) depends on that)
09:51:26 <mmorrow> i agree with (1) in general
09:53:55 <Saizan_> well, non-trivial sure, not so complex though, and if you need to reduce overhead you can basically use newtypes of IO
09:54:54 <Saizan_> i.e. i see those as quite solvable problems
09:56:55 <jbender> had a thought, why isn't there a ditto (sp?) notation for using head matching functions
09:57:26 <Saizan_> head matching functions?
09:57:51 <jbender> pattern matching in the function
09:58:01 <jbender> its called head matching in erlang not sure if thats the right term here
09:58:24 <jbender> erlang doesn't have it either but it would mean less alteration in the case where you want to change the function name
09:58:31 <Peaker> if fromJust had a shorter name or even syntactic shortcuts, maybe (/) and head and other partial operations could return maybe, and then all such unsafe places would be marked with fromJust?  Or maybe fromRight, so that a Left can contain more error information?
09:58:52 <Saizan_> jbender: can you give an example?
09:58:54 <jbender> someFunc (x,y,z) = somecode
09:59:08 <mux> Peaker: I think what you're looking for os the Safe library
09:59:12 <jbender> <ditto operator> (x,y) = somecode
09:59:19 <jbender> <ditto operator> (x) = somecode
09:59:30 <jbender> then when you want to change the function name you just change someFunc
09:59:37 <Saizan_> jbender: aah, i see
09:59:57 <jbender> it could be a double qoute or an underscore or somethign
09:59:59 <Peaker> mux: what's that?  I'd like to see the entire stdlib change to always be safe and in Either...
10:00:32 <benmachine> jbender: imo it'd make code harder to understand, especially in isolation
10:00:33 <SamB> jbender: how about an editor command?
10:00:44 <mux> Peaker: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/safe
10:00:46 <jbender> SamB: clearly thats the easy route
10:01:22 <SamB> ... actually, isn't that what TAB already does ?
10:02:09 <Saizan_> it doesn't sync the others if you change one line, i think
10:02:13 <jbender> the only reason I ask is that I saw an article online about good haskell code and it pointed out that its easier to use case statements because you don't need to change the function name in many places
10:02:18 <SamB> well, yeah, there is that
10:02:24 <jbender> and i prefer headmatching to case satements
10:02:39 <jbender> aesthetically
10:02:42 <jbender> as lame as that sounds
10:02:56 <Saizan_> i'm with you :)
10:02:56 <pikhq> case statements are ugly.
10:03:14 <jbender> I dunno I think something like:
10:03:48 <SamB> > '''
10:03:49 <lambdabot>   <no location info>:
10:03:50 <lambdabot>      lexical error in string/character literal at chara...
10:03:53 <SamB> > ''
10:03:54 <lambdabot>   <no location info>:
10:03:54 <lambdabot>      lexical error in string/character literal at chara...
10:04:11 <SamB> okay, so '' is not currently meaningful ...
10:04:23 <jbender> someFunc (x, y) = doSomethingHere . blah x
10:04:23 <jbender> __               x     = doSomethingElse x
10:04:39 <Axman6> > let ('') = (+) in 1 '' 2
10:04:40 <lambdabot>   <no location info>:
10:04:40 <lambdabot>      lexical error in string/character literal at chara...
10:04:44 <jbender> doesn't seem so bad
10:05:07 <SamB> > let __ = 1 in __
10:05:08 <lambdabot>   1
10:05:09 <Saizan_> i think it reads better if you repeat the function name though
10:05:12 <SamB> that's a variable name
10:05:46 <jbender> SamB Saizan_: well if I get "unlazy" I'll try hacking emacs plugin for that
10:17:00 <roconnor> @what IFIP
10:17:00 <lambdabot> I know nothing about ifip.
10:34:13 <indianteen17> hi
10:34:34 <indianteen17> http://www.olivershouse.camstreams.com
10:35:53 --- mode: ChanServ set +o Saizan
10:35:57 --- mode: Saizan set +b *!*=indiante@*.dsl.renocs.pacbell.net
10:35:57 --- kick: indianteen17 was kicked by Saizan (no spam thanks.)
10:36:13 --- mode: Saizan set -o Saizan
10:59:54 <Berengal> What's a decent lazy parser?
11:01:20 <CalJohn> Is there any way to go from a FileStatus -> FilePath?  Or, at least, any way to get the contents of a directory FileStatus?
11:01:24 <Deewiant> polyparse?
11:01:48 <Berengal> Actually, lazyness might not help. I've got to parse things with closing tags
11:02:04 <Baughn> @index FileStatus
11:02:05 <lambdabot> System.Posix.Files, System.Posix
11:02:54 <Baughn> CalJohn: That's a no. FileStatus is per-file, and filenames have a many-to-one mapping with files.
11:03:03 <Baughn> CalJohn: Also there's no reverse mapping stored.
11:05:47 <CalJohn> Baughn: that makes it a real pain to know a file is a directory and also get a list of it's contents...i suppose i will have to thread both through my function
11:06:23 <Baughn> CalJohn: You don't need the filename to read the contents of a directory
11:06:40 <Baughn> CalJohn: ..well, not in unix anyway
11:06:46 <CalJohn> Baughn: is there any other way?
11:06:50 <CalJohn> (I am on unix)
11:07:37 <Baughn> CalJohn: The fdopendir function. I can't seem to find its equivalent in the libraries, though, just opendir.
11:08:05 <Baughn> CalJohn: I suggest reporting that as a bug
11:08:16 <CalJohn> @index opendir
11:08:17 <lambdabot> bzzt
11:08:25 <Baughn> @index openDirStream
11:08:26 <lambdabot> System.Posix.Directory, System.Posix
11:09:26 <Baughn> CalJohn: Although, you still can't do anything with a *FileStatus*. You'd have to carry around the Fd.
11:09:26 <CalJohn> i find it hard to believe how no one has found this "bug" before
11:09:47 <CalJohn> can I use the Fd to get a file listing?
11:10:02 <sw17ch> hi all
11:10:09 <Baughn> CalJohn: Yes, using fdopendir
11:10:30 <CalJohn> @index fdopendir
11:10:30 <lambdabot> bzzt
11:10:35 <sw17ch> is there a way to force a top level declaration?
11:10:38 <CalJohn> @index fdOpenDir
11:10:39 <lambdabot> bzzt
11:10:43 <hackagebot> ZipFold 0.1.4 - Zipping folds (ConalElliott)
11:10:45 <CalJohn> argh
11:11:01 <sw17ch> basically, i have something like this: x = unsafePerformIO whatever :: IO Int
11:11:06 <sw17ch> and i'd like it to be forced at startup
11:11:36 <Baughn> CalJohn: ..well, I did mention it was missing
11:11:56 <Baughn> sw17ch: There is no such way. Furthermore, your father smells of elderberries.
11:12:11 <sw17ch> Baughn, none?
11:12:14 <Baughn> sw17ch: In practice, a top-level unsafePerformIO value is evaluated at first read
11:12:21 <sw17ch> but i want it now :(
11:12:34 <sw17ch> @faq Can haskell force an unsafePerformIO at the top level when the program starts?
11:12:35 <lambdabot> The answer is: Yes! Haskell can do that.
11:12:38 <sw17ch> >:(
11:13:02 <Baughn> sw17ch: The way to do that would be to throw an "evaluate topLeevelValue" in at the top of main
11:13:15 <Baughn> sw17ch: Also, may I emphasize the smell of elderberries? What are you trying to do, anyway?
11:13:17 <CalJohn> Baughn: yeah, I know, but I would've thought that sometime between 1991 and ghc been started and now, someone would notice that it's a pain to get a directory listing...
11:13:36 <Baughn> CalJohn: It isn't, really. You just need to keep the filepath around, which you usually want anyway.
11:13:45 <sw17ch> Baughn, it's a sanity check that needs to run on startup--since i can't type check it
11:14:30 <sw17ch> basically, a top level assert
11:15:44 <Baughn> sw17ch: Right. Well, I'm sorry, but while there has been some discussion on how to do this there is no consensus.
11:15:54 <Baughn> Much less code
11:15:58 <sw17ch> :)
11:16:11 <sw17ch> alright, i'll just trust the programmers then *snerk* :)
11:23:12 <copumpkin> RayNbow: still around?
11:25:47 <hackagebot> hlint 1.6.4 - Source code suggestions (NeilMitchell)
11:26:03 <RayNbow`> copumpkin: yeah
11:26:19 <copumpkin> RayNbow: trying to figure out how to actually use that hylo
11:26:25 <copumpkin> but have been failing so far :P
11:26:33 <copumpkin> I thought I understood it :(
11:26:35 <RayNbow`> I don't have a highlight on my nick, you're lucky I just switched to this channel to check for messages :p
11:26:40 <copumpkin> hah
11:27:03 <RayNbow`> I asked Apfelmus about that hylo definition on the haskell-cafe list
11:27:38 <copumpkin> oh
11:28:17 <RayNbow`> and I now see byorgey_ replied recently :p
11:28:24 <copumpkin> yeah
11:28:55 <copumpkin> I stopped using [] with it and started trying tuples
11:29:18 <RayNbow`> http://www.haskell.org/pipermail/haskell-cafe/2009-July/064125.html --> http://www.haskell.org/pipermail/haskell-cafe/2009-July/064130.html --> http://www.haskell.org/pipermail/haskell-cafe/2009-July/064132.html --> http://www.haskell.org/pipermail/haskell-cafe/2009-July/064134.html
11:29:23 <copumpkin> yeah
11:29:26 <copumpkin> found it, thanks :)
11:30:01 <RayNbow`> I wonder why the new replies are in a different thread
11:30:03 <copumpkin> that's interesting
11:31:08 <sw17ch> is there a "Streamable" type class?
11:31:24 <copumpkin> I think there's a Stream typeclass in parsec somewhere
11:31:50 <sw17ch> copumpkin, that's what i'm looking at
11:32:01 <sw17ch> along with the Stream-0.3.2 package on Hackage
11:32:13 <sw17ch> and i want Stream-0.3.2's functions as typeclass methods
11:32:27 <sw17ch> perhaps rename the class to "Linear" or something
11:34:03 * RayNbow` wonders what the F stands for in byorgey_'s ListF
11:34:09 <copumpkin> functor ?
11:34:31 <copumpkin> RayNbow`: there's more similar work on http://knol.google.com/k/edward-kmett/catamorphisms/3qi7x2qrdushx/2#
11:34:33 <byorgey_> yeah, functor
11:34:41 <copumpkin> zomg it's byorgey_
11:34:48 <byorgey_> zomg it's me!
11:34:54 <byorgey_> =)
11:35:00 <copumpkin> :)
11:35:19 <sw17ch> that's the scary thing about #haskell, you ask questions, and the author answers.... o_O
11:35:21 <RayNbow`> it's *the* most favourited lambda chef of the world :p
11:35:36 <RayNbow`> so, what's cooking, byorgey? :)
11:36:19 <copumpkin> okay, so I think I get it now
11:36:20 <RayNbow`> btw, why use F as a suffix for functors?
11:36:32 <byorgey> today, broiled lambdafish with a basil-mango-lambda glaze
11:37:14 <byorgey> RayNbow`: I dunno, I often use F as a suffix for functors which only exist so that you can take their fixed point
11:37:27 <byorgey> so ListF = blah,  List = Fix ListF
11:37:28 * RayNbow` wonders if in the near future www.haskell.org/Dish_of_the_Day will be put online :p
11:37:42 <RayNbow`> ah
11:38:00 <opqdonut> ?
11:38:06 <byorgey> copumpkin: the key point is that hylo, ana, cata, etc. are recursion schemes for data structures which can be viewed as the fixed point of a functor
11:38:16 <copumpkin> I see :)
11:39:36 <byorgey> so, e.g.  cata :: (f a -> a) -> Fix f -> a
11:39:42 <RayNbow`> hmm, ListF is isomorphic to Maybe (a,b)?
11:39:56 <opqdonut> indeed
11:40:00 <byorgey> summarizes a Fix f, given only an (f a -> a) (an f-algebra)
11:40:12 <byorgey> RayNbow`: yup
11:40:28 <byorgey> i.e. 1 + a * b
11:40:46 <RayNbow`> I just noticed :)
11:41:09 <byorgey> copumpkin: but the 'Fix' part is hidden away in the type sgnature of 'hylo' so it's not as obvious what's going on, that the intermediate structure is a Fix f, not an f.
11:41:09 * RayNbow` should prepare some lambda tea to stay awake
11:43:29 <copumpkin> cool
11:55:14 <defun> @undo do let plist = ["Plugin1.o", "Plugin2.o", "Plugin3.o"]; plugins <- mapM (\p -> load p ["."] [] "resource") plist; let functions = map (valueOf . fromLoadSuc) plugins; mapM_ (\f -> putStrLn $ f "haskell is for hackers") functions
11:55:15 <lambdabot>  Parse error at "<-" (column 65)
11:55:35 <defun> @undo {do let plist = ["Plugin1.o", "Plugin2.o", "Plugin3.o"]; plugins <- mapM (\p -> load p ["."] [] "resource") plist; let functions = map (valueOf . fromLoadSuc) plugins; mapM_ (\f -> putStrLn $ f "haskell is for hackers") functions}
11:55:35 <lambdabot>  Parse error at "{do" (column 1)
11:55:54 <defun> @undo do {let plist = ["Plugin1.o", "Plugin2.o", "Plugin3.o"]; plugins <- mapM (\p -> load p ["."] [] "resource") plist; let functions = map (valueOf . fromLoadSuc) plugins; mapM_ (\f -> putStrLn $ f "haskell is for hackers") functions}
11:55:55 <lambdabot>  Parse error at "<-" (column 66)
11:56:18 <RayNbow`> defun: there's a problem with let in combination with semicolon notation
11:56:34 * RayNbow` hasn't figured out why it gives a parse error yet
12:11:25 <sw17ch> what's the complement of Monoid?
12:11:47 <FunctorSalad_> maximal ideal
12:12:08 <FunctorSalad_> err prime ideal
12:12:33 <sw17ch> hmm...
12:13:49 <FunctorSalad_> sorry j/k, complement in which sense?
12:14:25 <idnar> comonoid!
12:15:37 <mauke> re
12:15:48 <timonator> coolmonoid?
12:16:25 <pikhq> Doinom.
12:17:04 <pikhq> Erm.
12:17:05 <copumpkin> Endo?
12:17:08 <pikhq> Dionom.
12:17:12 <copumpkin> or Dual, rather?
12:21:09 <Saizan> class Comonoid m where unit :: m; split :: m -> (m,m)
12:22:07 <sw17ch> is there a typeclass that says something about the number of elements? or a way of counting things?
12:22:14 <sw17ch> length of a list, or nodes in a tree?
12:23:51 <FunctorSalad_> sw17ch: Foldable?
12:24:07 <Saizan> ?type Data.Foldable.length
12:24:07 <FunctorSalad_> length = foldMap (const (Sum 1))
12:24:08 <lambdabot> Not in scope: `Data.Foldable.length'
12:24:25 <FunctorSalad_> @let len = foldMap (const (Sum 1))
12:24:26 <lambdabot>  <local>:7:6: Not in scope: `foldMap'
12:24:26 <hackagebot> hack-frontend-monadcgi 0.0.1 - Allows programs written against MonadCGI to run with any hack handler. (MichaelSnoyman)
12:24:32 <FunctorSalad_> @let len = Data.Foldable.foldMap (const (Sum 1))
12:24:34 <lambdabot>  Defined.
12:24:44 <FunctorSalad_> > len []
12:24:47 <lambdabot>   Sum {getSum = 0}
12:24:51 <sw17ch> bingo, thanks
12:24:54 <Saizan> ?type len
12:24:55 <lambdabot> forall (t1 :: * -> *) a t. (Num t, Data.Foldable.Foldable t1) => t1 a -> Sum t
12:24:58 <sw17ch> Foldable + Monoid = Win
12:26:08 <FunctorSalad_> sw17ch: I think this will just count the nodes containing a value though
12:26:15 <FunctorSalad_> @src Data.Tree.Tree
12:26:16 <lambdabot> Source not found. :(
12:26:19 <FunctorSalad_> :(
12:26:23 <FunctorSalad_> @src Tree
12:26:24 <lambdabot> Source not found. Take a stress pill and think things over.
12:26:48 <sw17ch> hmm... i'd really like it to be lazy, i need an "at least len"
12:27:00 <copumpkin> :k Natural
12:27:02 <lambdabot> *
12:27:09 <FunctorSalad_> you need lazy natural numbers then
12:27:18 <copumpkin> > genericLength [0..] > (5 :: Natural)
12:27:19 <lambdabot>   True
12:27:34 <sw17ch> oh, i'd be happy with
12:27:39 <sw17ch> atleastLen 5 [1..]
12:27:45 <FunctorSalad_> @src Natural
12:27:46 <lambdabot> Source not found. Sorry.
12:28:02 <copumpkin> > genericLength [0..] > (5000 :: Natural)
12:28:04 <lambdabot>   True
12:28:37 <FunctorSalad_> is it binary?
12:28:48 <copumpkin> doubt it
12:28:51 <sw17ch> hmm?
12:28:52 <copumpkin> not sure though
12:29:01 <sw17ch> ah, tree
12:29:15 <FunctorSalad_> I mean Natural
12:29:36 <copumpkin> I think it's just the usual Peano thing, but it's hard to tell without timing operations on it :P
12:30:01 <FunctorSalad_> >  (10^6::Natural) > (10^6 ::Natural)
12:30:04 <lambdabot>   False
12:30:19 <FunctorSalad_> >  (10^15::Natural) > (10^15 ::Natural)
12:30:25 <lambdabot>   mueval-core: Prelude.read: no parse
12:30:25 <lambdabot>  mueval: ExitFailure 1
12:30:50 <FunctorSalad_> wow it did the 10^6 in unary?
12:31:01 <idnar> unary isn't a real base :/
12:31:48 <jeffwheeler> Is it not? Or is it just really boring?
12:32:08 <FunctorSalad_> someone could copy the binary inductive naturals from coq..
12:32:10 <FunctorSalad_> ;)
12:32:15 <idnar> well, the real unary can't represent any number other than 0
12:32:21 <sw17ch> @type (== n) . length . take n . toList
12:32:24 <lambdabot> Not in scope: `toList'
12:32:34 <sw17ch> woo
12:32:35 <idnar> so it's kinda useless
12:32:40 <jeffwheeler> idnar: I figured that, but what other unary is there?
12:32:54 <copumpkin> FunctorSalad_: mmm ;)
12:33:15 <idnar> jeffwheeler: the peano numeral kind, I guess
12:33:40 <idnar> SSSSS0 = 5 decimal; or 11111 = 5 decimal; or other variations on that theme
12:38:43 <sw17ch> shoot, functor is kind (* -> *)
12:38:44 <sw17ch> forgot
12:38:52 <sw17ch> and by functor, i mean foldable
12:40:32 <copumpkin> what is the relation between Foldable, Traversable, and the Functor/Applicative/Monad classes?
12:40:48 <FunctorSalad_> Foldable => Traversable
12:41:02 <FunctorSalad_> @hoogle Traversable
12:41:03 <lambdabot> module Data.Traversable
12:41:03 <lambdabot> Data.Traversable class (Functor t, Foldable t) => Traversable t
12:41:11 <FunctorSalad_> @hoogle Foldable
12:41:12 <lambdabot> module Data.Foldable
12:41:12 <lambdabot> Data.Foldable class Foldable t
12:43:05 <Peaker> why is it called a "lambda abstraction" rather than a "lambda literal" ?
12:43:21 <BONUS> also Functor => Traversable
12:43:21 <Peaker> @src Foldable
12:43:22 <lambdabot> Source not found. Just try something else.
12:43:37 <BONUS> and Functor => Applicative => Monad
12:43:45 <Peaker> I think Foldable lets you "extract" it into a result with a fold, but Traversable lets you keep the structure in tact
12:43:58 <Peaker> @type sequenceA
12:44:00 <lambdabot> Not in scope: `sequenceA'
12:44:04 <Peaker> @hoogle sequenceA
12:44:05 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
12:44:06 <lambdabot> Data.Foldable sequenceA_ :: (Foldable t, Applicative f) => t (f a) -> f ()
12:44:26 <copumpkin> hm
12:45:04 <FunctorSalad_> uh, you "abstract the bound variable out"
12:45:19 <FunctorSalad_> maybe it's referring to abstracting the name of the free variable away?
12:45:38 <FunctorSalad_> ABSTRACTIONHAMMER
12:45:48 <Peaker> its nice to think of "sequence" as reversing the outer/inner thingies
12:46:17 <idnar> unfortunately Foldable isn't a generic catamorphism
12:46:21 <FunctorSalad_> I think it's called that way because it runs the side effects in sequence
12:46:37 <FunctorSalad_> why not?
12:48:05 <idnar> FunctorSalad_: the type of foldr forces it to be listish
12:49:15 <Peaker> idnar: how could Foldable be a generic catamorphism?
12:49:29 <FunctorSalad_> @stc Data.Foldable.Foldable
12:49:30 <lambdabot> Source not found. My pet ferret can type better than you!
12:49:35 <idnar> Peaker: no clue; I'll leave it up to someone smarter than me to figure that one out ;)
12:49:42 <FunctorSalad_> isn't foldMap the primitive
12:49:48 <FunctorSalad_> that's make it the intiial monoid
12:49:56 <Peaker> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Foldable.html
12:50:34 <FunctorSalad_> or rather, "Foldable a" is the free monoid over a apparently
12:50:34 <Peaker> idnar: I don't think you can have a single class for all catamorphisms
12:50:47 <idnar> FunctorSalad_: you still can't write foldMap for, say, Either
12:50:55 <FunctorSalad_> (assuming you don't abuse foldMap by supplying something that doesn't satisfy the monoid laws)
12:51:09 <copumpkin> biFoldMap? :o
12:51:09 <idnar> Peaker: I guess I need to look at category-extras sometime
12:51:24 <idnar> cata :: Functor f => Algebra f a -> FixF f -> a
12:51:35 <Peaker> I think (Foldable f) could have a   toList :: f a -> [a]          and be equivalent?
12:51:52 <Peaker> idnar: what's an Algebra?
12:52:13 <idnar> copumpkin: foldEither :: (a -> c) -> (b -> c) -> Either a b -> c
12:52:17 <FunctorSalad_> Algebra f a = f a -> a
12:52:20 <FunctorSalad_> I thinkkk
12:52:24 <FunctorSalad_> *think
12:52:31 <idnar> copumpkin: (presumably the type is familiar :P)
12:52:38 <copumpkin> yup :)
12:53:18 <idnar> FunctorSalad_: yeah
12:53:40 <FunctorSalad_> Peaker: can you go the other way too? [a] _> f a
12:53:43 <FunctorSalad_> [a] -> f a
12:53:47 <FunctorSalad_> for f Foldable
12:55:08 <FunctorSalad_> @type foldMap return
12:55:10 <lambdabot> Not in scope: `foldMap'
12:55:16 <FunctorSalad_> @type Data.Foldable.foldMap return
12:55:18 <lambdabot> forall a (m :: * -> *) (t :: * -> *). (Monad m, Data.Foldable.Foldable t, Monoid (m a)) => t a -> m a
12:55:29 <RayNbow> @let foldMap = Data.Foldable.foldMap
12:55:30 <lambdabot>  Defined.
12:55:33 <RayNbow> there we go :p
12:55:39 <FunctorSalad_> \o/
12:56:23 <Zeiris> What's the most correct way to serialize/deserialize binary packets in Haskell?
12:56:55 <FunctorSalad_> I guess Foldable is not a *free* monoid after all since it doesn't demand uniqueness of the foldMap..
12:57:01 <a_guest> gtk2hs question: Consider a main window. How should I exit the application, eg removing all window and return from mainGUI?
12:57:05 <Peaker> FunctorSalad_: none of the Foldable methods have an (f a) in their result type
12:57:17 <Peaker> (or in any positive position)
12:57:32 <a_guest> destroy all window and then call 'mainQuit'?
12:58:00 <FunctorSalad_> Peaker: foldMap has, potentially
12:59:08 <Peaker> @hoogle foldMap
12:59:09 <lambdabot> Data.Foldable foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
12:59:09 <lambdabot> Data.Traversable foldMapDefault :: (Traversable t, Monoid m) => (a -> m) -> t a -> m
12:59:40 <FunctorSalad_> @type foldMap id
12:59:40 <Peaker> FunctorSalad_: you can build a Monoid, not a Foldable. If you build a Monoid which happens to be a Foldable, you didn't really use its Foldable instance to do so
12:59:42 <lambdabot> forall a (t :: * -> *). (Data.Foldable.Foldable t, Monoid a) => t a -> a
12:59:44 <copumpkin> FunctorSalad_: that seems weird to me
12:59:52 <copumpkin> [a] -> f a, that is
13:00:15 <FunctorSalad_> Peaker: I was thinking of a self-referential Monoid instance
13:00:20 <FunctorSalad_> you can use an instance in its own definition
13:00:50 <FunctorSalad_> I was just thinking there should be [a] -> f a, because the free monoid is unique up to isomorphism
13:01:00 <FunctorSalad_> but as I said, apparently Foldables aren't free monoids
13:01:12 <BONUS> if you have a list [2,3] and want to make a binary tree out of it
13:01:43 <Peaker> FunctorSalad_: If you could do [a] -> f a   then f a could not always have more structure/information than a list
13:01:47 <BONUS> you can make either Tree Nil 3 (Tree Nil 3 Nil)
13:02:00 <BONUS> or Tree (Tree Nil 2 Nil) 3 Nil
13:02:03 <BONUS> or a few more
13:02:14 <BONUS> so yeah you can't make a reliable [a] -> f a imo
13:02:48 <sw17ch> using functional dependencies, can i write an instance for both (Num n) => Foo n [Char] and Foo [Char] [Char]
13:02:49 <sw17ch> ?
13:02:50 <FunctorSalad_> you could always make a degenerate left-chaining-tree
13:02:57 <sw17ch> or is overlapping instances always going to kill me
13:03:24 <FunctorSalad_> that would be just a left inverse for foldMap though, not a right inverse
13:03:39 <FunctorSalad_> but as I said, I believe you that [] isn't isomorphic to Tree ;)
13:04:01 <BONUS> yeah, but with what Foldable defines, you can't make a function with type Foldable f => [a] -> f a
13:04:33 <BONUS> you could do like class Foldable f => UnFoldable f where fromTree :: [a] -> f a i guess
13:04:37 <FunctorSalad_> sorry. swap "left" and "right" there ;)
13:04:47 <FunctorSalad_> id == foldMap . leftDegenerateTree
13:05:19 <FunctorSalad_> hehe... it's UNfoldable!
13:07:03 <idnar> haha
13:11:24 <RayNbow> hmm, .NET might be getting FRP stuff?
13:12:02 * RayNbow adds http://channel9.msdn.com/shows/Going+Deep/Expert-to-Expert-Brian-Beckman-and-Erik-Meijer-Inside-the-NET-Reactive-Framework-Rx/ to his ToWatch queue
13:12:17 <FunctorSalad_> so is microsoft slipping to neutral?
13:12:21 <idnar> awesome
13:13:16 <RayNbow> hmm
13:13:21 <RayNbow> WMV HQ is 1.3 GB
13:37:41 <coCocoa> Erik Meijer is a known FP "fellow traveller". :)
13:41:48 <tommd> Somewhat OT, but its all quite right now:
13:41:48 <tommd> Are there any singularity experts here?  Could anyone comment about how critical the linear type system is to the overall design?  It seems necessary for any SIP that needs to communicate (so, any SIP at all), but LTS could be somewhat frustrating for general programming.
13:44:42 <CalJohn> @index getargs
13:44:43 <lambdabot> bzzt
13:44:49 <CalJohn> @index getArg
13:44:49 <lambdabot> bzzt
13:44:51 <CalJohn> @index getArgs
13:44:51 <lambdabot> System.Environment
13:46:51 <sbahra> http://detexify.kirelabs.org/classify.html - useful :)
13:53:10 <roconnor> Derek Elkins doesn't like how my Monoid instances for Colour and AlphaColour are unreleated.
13:53:36 <roconnor> specifically that opaque :: Colour a -> AlphaColour a isn't a Monoid homomorphism
13:53:57 <roconnor> I'm not sure if this is really a problem or not.
13:54:17 <roconnor> I'm not really convinced at the moment.
13:55:55 <lispy> I suspect only Haskell programmers would be bothered by that :)
13:56:12 <roconnor> lispy: I suspect you are right. :)
13:56:31 <Saizan> what's mappend here?
13:56:36 <lispy> heh
13:56:49 <roconnor> Saizan: For Colour it is vector addition
13:57:03 <Saizan> unfortunately it's an haskell library, so you should be worried by that!
13:57:03 <roconnor> Saizan: : For AlphaColour it is compositing (aka `over`)
13:57:11 <roconnor> I am worried
13:57:17 <lispy> It's a little odd that in the OO communities they talk about design patterns and here we talk about category theory
13:57:50 <roconnor> It is certainly a well-taken complain.  I just can't tell if there is a real problem or not
13:58:30 <Saizan> so opaque should really be transparent to be an homomorphism?
13:58:53 <Berengal> lispy: In some ways they're the same
13:59:17 <roconnor> Saizan: Hmm
13:59:32 <Berengal> Also, python's threading is way more broken than I'd thought
13:59:40 <lispy> One pattern that suprised me in the OO community was the inversion of control / dependency injection.  I thought we called that map/fmap :)
14:00:03 <Saizan> HOFs?
14:00:06 <roconnor> Saizan: I believe there is an analogy to vector addition for AlphaColours
14:00:07 <Berengal> lispy: Is that what that is? I never really got it...
14:00:34 <lispy> Berengal: it's the OO translation.  Some bits are changed, but the application and concept are the same at the heart
14:00:36 <roconnor> Saizan: and if that were the monoid instance, then the injection "opaque" would be a monoid homomorphism
14:01:07 <roconnor> Saizan: but for AlphaColour, the `over` monoid is the more important monoid.
14:01:32 <roconnor> Saizan: for Colour, the vector addition is of slight importance.
14:02:16 <roconnor> I haven't implemented the "vector addition" for AlphaColour, but I think it could be implemented in terms of my interface.
14:02:35 <Saizan> roconnor: is the homomorphism between the current two monoids of any use?
14:02:58 <roconnor> Saizan: there is no homomorphism between the current two.
14:03:23 <JN_> noob haskell question.  I'm reading a yaht (yet another haskell tutorial).  they say that fmap is a generalization of map to arbitrary structures.  I guess "map" applies just to lists, and fmap can apply to any functor.  and since list is a functor, then for a list, fmap and map are equivalent?
14:03:32 <roconnor> Saizan: unless you mean the trivial (cont mempty) homomorhpism
14:03:45 <roconnor> which is about as usefull as you'd imagine.
14:03:45 <lispy> JN_: right
14:03:54 <lispy> > (+1) `fmap` [1..3]
14:03:56 <lambdabot>   [2,3,4]
14:03:57 <JN_> thanks. :)
14:04:08 <lispy> > (+1) `map` [1..3]
14:04:10 <lambdabot>   [2,3,4]
14:04:19 <pikhq> JN_: Also fun: (.) is a special case of fmap.
14:04:57 <pikhq> > (+1) . (+2) $ 3
14:04:59 <lambdabot>   6
14:05:02 <pikhq> > (+1) `fmap` (+2) $ 3
14:05:04 <lambdabot>   6
14:05:11 <lispy> My biggest objection to all the cat. theory that we are exposed to here in the Haskell community is that for a given set, type, functor, etc, there isn't necessarily *one true* homomorphism/fmap/mappend etc
14:05:45 <Berengal> lispy: Leading to heaps of newtypes, you mean?
14:05:47 <RayNbow> hmm... I can't find an example of a "bijective homomorphism" between two non-isomorphic posets...
14:05:50 <roconnor> lispy: that is a valid compain, but not about cat. theory.
14:05:51 <lispy> Berengal: basically
14:06:28 <lispy> A friend of mine asked a good question the other day about Data.Set.  How do you specify an equality test and an unrelated ordering?
14:06:47 <Berengal> lispy: I agree, but it can also help separate different modes of thinking. Lists and ZipLists are quite different applicatives, even though they're the same "type"
14:07:15 <coCocoa> lispy: Well, your *real* objection "should" be that the data on the computer has an inherent ordering that interfers with, making things that aren't inherently ordered, e.g., sets. :\
14:07:36 <lispy> Berengal: I think newtypes are often a good thing.  I just find it weird that we pick *one true* implementation of the instances the way we do
14:08:12 <Saizan> lispy: equality test and unrelated ordering?
14:08:15 <lispy> Berengal: sometimes it's quite reasonable (map) and other times it's a stretch
14:08:20 <coCocoa> roconnor: Before you mention it, yes, my issue is also not a complaint about CT. :)
14:08:48 <tommd> lispy: I don't understand the issue with comparing sets.  What is the problem with a traditional definition, such as: âˆ€ x âˆˆ S , x âˆˆ T  âˆ§ âˆ€ y âˆˆ T , y âˆˆ S
14:08:54 <roconnor> coCocoa: which complaint?
14:08:56 <lispy> Saizan: yeah, I didn't get it at first, but after his example I saw the value.  I forgot the example, something with people in a database and their phone numbers?
14:09:23 <lispy> tommd: that's a lot of question marks
14:09:28 <Saizan> lispy: you are talking about ordering of the contained values, right?
14:09:35 <Berengal> lispy: In a way, but it also makes things easier to work with. There's also the number of abstractions fitting a given type. List is a monad, but ZipList isn't, so that at least gives the List some precedence when it comes to being the "default"
14:09:49 <coCocoa> lispy: So, how do you feel about when that "one true" version isn't chosen (e.g., Monoid over Nums)? :)
14:10:12 <roconnor> coCocoa: It had better be +
14:10:22 <roconnor> er
14:10:23 <roconnor> sorry
14:10:30 <roconnor> ignore me
14:10:54 <coCocoa> roconnor: Sorry, did you "say" something? ;)
14:10:54 <tommd> lispy: Fix your unicode.  Basically it says forall x element of S,  x is an element of T and forall y element of T, y is an element of S.
14:10:54 <tommd> Alternatively:  isNull (S \\ T) && isNull (T \\ S)   -- I think that's the same.
14:11:10 <roconnor> coCocoa: nope
14:11:24 <lispy> "imagine a collection of data about people -- you want them sorted by age, but you don't want to kill people just because they were born in the same year"
14:11:27 <roconnor> coCocoa: and don't check the logs either, cause there is nothing there.
14:11:47 <Berengal> lispy: However, I've noticed that in some cases there is no "default" implementation, e.g. State s -> (a, s) and Parser s -> (a, s)
14:11:58 <Saizan> lispy: that doesn't fit in Set
14:12:11 <Saizan> lispy: that's more like Map Age (Set Person)
14:12:41 <coCocoa> Also, about the whole "ZipList is not a monad" - isn't that because it's a comonad? :)
14:12:51 <Saizan> lispy: happstack-ixset provides more than one index, though i wouldn't call it production ready
14:13:37 <roconnor> coCocoa: it's not a comonad.
14:13:50 <Saizan> coCocoa: it's not a comonad, however data Stream a = Cons a (Stream a) is both
14:14:39 <roconnor> ZipList a -> a doesn't exist
14:16:39 <lispy> Saizan: well, something that is hard to express in Haskell, is how to provide a custom equality test when Eq, is used
14:17:03 <lispy> :t nub
14:17:05 <lambdabot> forall a. (Eq a) => [a] -> [a]
14:17:19 <lispy> So, to use nub with a custom equality test I need a newtype
14:17:25 <Saizan> lispy: yeah, it can be done but it's quite hacky :)
14:17:45 <dschoepe> lispy: There's also nubBy
14:17:54 <coCocoa> lispy: That's what nubBy is for, BTW. :)
14:18:01 <Saizan> without a custom newtype.. but the alternative is not much more pleasant
14:18:17 <MyCatVerbs> lispy: nubBy and sortBy.
14:18:21 <Saizan> see edwardk's reflect
14:18:22 <Berengal> lispy: Dynamic scoping could help...
14:18:46 <lispy> nub was just an example
14:18:46 <Saizan> Berengal: not really dynamic, but local (or named) instances
14:18:58 <lispy> We don't always have a *By version
14:19:17 <Berengal> Saizan: Same difference... *waves hand*
14:20:02 <pikhq> lispy: Then you should rewrite * as a special case of *By, shouldn't you?
14:20:02 <coCocoa> lispy: However, I (...anticipate for argument?) do understand that the ___By stuff should technically be defined at the Ord level, and should not be "exposed" at the list-level, otherwise you're recreating effort when you use some other container-type besides lists.
14:20:39 <Saizan> i think we should be able reword the typeclass system as first order modules + optional typechecker resolved applications
14:21:36 <lispy> pikhq: well, see coCocoa comment.  In general, that would require providing a *By version whenever a type class function is used, right?
14:24:39 <lispy> I think this may be a place where C++ templates can go a bit futher
14:25:02 <lispy> But, if that's the case then it seems that HOFs should be all we need
14:25:27 <Peaker> HOF?
14:25:36 <lispy> Peaker: higher order functions
14:27:39 <roconnor> @seen jeffheard
14:27:39 <lambdabot> I haven't seen jeffheard.
14:29:30 <Saizan> lispy: that's the lowlevel primitive we need
14:30:10 <Saizan> lispy: typeclasses are moslty a convenience to exploit the typechecker in filling the arguments, and i think for a lot of things that convenience is crucial
14:31:17 <coCocoa> That's an interesting concept - A class that doesn't change the type, but changes how other functors interact with that type....
14:31:48 <lispy> coCocoa: that's like the proxy or facade patterns from OO design, right?
14:32:22 <coCocoa> The point being, you don't want a new comparator between types of 'a', but you want to change how '[a]' gets compared.
14:33:49 <Twey> @pl \f -> g (f x)
14:33:50 <lambdabot> g . ($ x)
14:35:13 <Dessous> When did Haskell get a new logo?
14:35:55 <coCocoa> Two (three?) months ago.
14:36:53 <coCocoa> Dessous: Two months ago, I think was the decision.
14:39:44 <coCocoa> @type ap (.) . flip id
14:39:46 <lambdabot> forall b a. b -> (b -> a -> b) -> a -> a -> b
14:40:05 <coCocoa> Hmm, now-so-impressive... :\
14:43:44 <Peaker> @pl needs to use shiny arrow stuff when @pling tuples, instead of ugly curry/uncurry/(,) stuff
14:43:45 <lambdabot> (line 1, column 50):
14:43:46 <lambdabot> unexpected ","
14:43:46 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
14:46:12 <benmachine> @pl it is interesting how much will parse here
14:46:13 <lambdabot> it is interesting how much will parse here
14:46:50 <Vanadium> @pl it is, isn't it
14:46:50 <lambdabot> (line 1, column 6):
14:46:51 <lambdabot> unexpected ","
14:46:51 <lambdabot> expecting variable, "(", operator or end of input
14:47:33 <Baughn>  @pl \a b (c,d) f e = f a b (d+c) e f (a,b,c)
14:47:37 <Berengal> @pl the output is probably more interesting if you put a = somewhere
14:47:37 <lambdabot> (line 1, column 41):
14:47:38 <lambdabot> unexpected reserved word "if" or "i"
14:47:38 <lambdabot> expecting variable, "(", operator or end of input
14:47:50 <Baughn> @pl \a b (c,d) f e = f a b (d+c) e f (a,b,c)
14:47:51 <lambdabot> (line 1, column 16):
14:47:51 <lambdabot> unexpected "="
14:47:51 <lambdabot> expecting pattern or "->"
14:47:58 <Gracenotes> > let it = (+1); is = 4; isn't = const 6 in [it is, isn't it]
14:48:00 <lispy> pl requires very little deep information
14:48:00 <lambdabot>   [5,6]
14:48:08 <Baughn> @pl \a b (c,d) f e -> f a b (d+c) e f (a,b,c)
14:48:12 <lambdabot> flip flip snd . (ap .) . flip flip fst . ((.) .) . ap (ap . ((ap . ((flip . ((flip . (flip .)) .)) .)) .) . flip flip id . ((flip . ((flip . ((ap . (flip .)) .)) .)) .) . flip flip (+) . (((.) . (.))
14:48:12 <lambdabot>  .) . (flip .) . flip . flip id) (,,)
14:48:12 <lambdabot> optimization suspended, use @pl-resume to continue.
14:48:36 <Gracenotes> you broke lambdabot1!1!
14:49:25 <shapr> Any stylistic improvements for http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6906#a6906 ?
14:49:41 <jackdaw> hi, trying to implement the ackerman fn in the style it's given in sicp: ex 1.10, doesnt compile and i don't understand the error. code is:http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2971#a2971
14:50:20 <mauke> what's the error?
14:50:25 <mauke> oh, I see
14:50:41 <mauke> jackdaw: you're trying to call a number. you can only call functions.
14:50:41 <jackdaw> mauke: cannot construct the infinite type... (if that was at me :) )
14:50:42 <shapr> I ported some recursive Python code I wrote long ago to Haskell, that hpaste is the result. It looks like it could be better though. Any thoughts?
14:51:11 <jackdaw> mauke: ooh i thought that fnname arg arg worked like (defun ...)
14:51:15 <Cale> jackdaw: You forgot the *
14:51:19 <mauke> jackdaw: it does
14:51:21 <Cale> In a couple of places.
14:51:37 <mauke> you wrote (x-1) ackerman (...)
14:51:48 <mauke> that calls (x-1) with two arguments, ackerman and ...
14:51:59 <Lemmih> shapr: digitToInt?
14:52:10 <shapr> Oh, I'll try that.
14:52:13 <Cale> > 5 "hello"
14:52:13 <jackdaw> mauke: oh how do i call ackerman with (x-1) and ackerman(x, y-1) as arguments?
14:52:15 <lambdabot>   No instance for (GHC.Num.Num ([GHC.Types.Char] -> a))
14:52:15 <lambdabot>    arising from the l...
14:52:16 <Beelsebob> jackdaw: mnemonic = mapM ((list !!) . read . pure) where list = ...
14:52:23 <mauke> jackdaw: ackerman (x-1) (ackerman x (y-1))
14:52:39 <Cale> jackdaw: Don't write parens around things which you don't want grouped :)
14:52:44 <inimino> jackdaw: it's "Ackermann" btw
14:52:58 <jackdaw> thanks mauke  that works now
14:53:05 <Beelsebob> shapr: even -- mnemonic = mapM ((list !!) . read . pure) where list = ...
14:53:20 <jackdaw> Beelsebob: i don't follow that...?
14:53:20 <shapr> ah, I'll try that too
14:53:28 <Beelsebob> jackdaw: sorry, was poking the wrong person
14:53:30 <jackdaw> thanks guys very helpful
14:53:31 <Cale> jackdaw: It might be helpful to know that every function in Haskell really has exactly one argument.
14:53:33 <jackdaw> Beelsebob: no worries
14:53:47 <vinicius_> TestParser: Internal Happy error
14:53:47 <jackdaw> Cale: right, this leads to currying right?
14:53:50 <vinicius_> oboy
14:53:51 <Cale> Right.
14:54:01 <Cale> those which appear to take more are really producing other functions
14:54:11 <Baughn> jackdaw: They all pretend to have exactly one argument, but nothing is actually ever evaluated until you provide all the arguments
14:54:13 <Cale> So when you write f x y it means (f x) y
14:54:27 <Peaker> shapr: you could run hlint on it, it'll probably suggest mapM :)
14:54:28 <Saizan> shapr: read . (:[]) == digitToInt
14:54:28 <Cale> Baughn: Well... depends :)
14:54:38 <Berengal> Lambda calculus is fun :)
14:54:38 <Baughn> Cale: Sure, lambda is helpful
14:54:42 <jackdaw> Baughn: oh so you can't an incomplete function as some kind of closure? to pass around some staet?
14:54:48 <Lemmih> shapr: mnemonic = sequence . map (list!!) . map digitToInt
14:54:49 <Beelsebob> Saizan: oh, neat -- didn't know that
14:55:02 <shapr> Lemmih: ooh
14:55:04 <Beelsebob> mnemonic = mapM ((list "") . digitToInt)
14:55:11 <Beelsebob> !! even
14:55:19 <Saizan> Beelsebob: well when the result type is Int, clearly :)
14:55:30 <Beelsebob> Saizan: *nod*
14:55:32 <jackdaw> thanks for help all
14:55:36 <shapr> Right, mapM folds in the sequence call...
14:55:42 <Cale> jackdaw: 'closure' is a bad word to use at the programmer's level. There might be a closure there, but that'd be an implementation detail. If you're asking if functions capture the values of variables which are in scope where they are defined, then yes, they do.
14:55:52 <Baughn> jackdaw: Sure you can. You just have to keep in mind that if "f x y" does some calculations on x that are independent of y, it'll redo those calculations every time. Unless they're done in the process of evaluating x, of course. Or you've got a lambda in there, having programmed f to /actually/ return a function.
14:56:02 <Saizan> he's gone
14:56:03 <Berengal> list = words "0 1 abc de ghi jkl mno pqrs tuv wxyz"
14:56:10 <Baughn> What a pity
14:56:15 <Cale> hmm
14:56:26 <Beelsebob> Berengal: oh, neat, I'd never thought about doing that â€“ but it's much cleaner than using a list there
14:56:31 <Cale> Strange people asking questions and then leaving :)
14:56:36 <Baughn> > words (cycle " ")
14:56:36 <Beelsebob> I guess a little less flexible though
14:56:41 <lambdabot>   mueval-core: Prelude.read: no parse
14:56:41 <lambdabot>  mueval: ExitFailure 1
14:56:42 <Berengal> Beelsebob: I like words :) (and lines)
14:56:42 <shapr> Thanks for the style improvements!
14:56:48 <Beelsebob> Berengal: so do I :)
14:57:07 <Beelsebob> Berengal: I *love* interact -- I use it for 99% of my programs
14:57:35 <Baughn> Beelsebob: So you love FRP then, I assume? ;)
14:57:44 <Berengal> It's not very flexible, but there's also Data.List.Split for when you need to be, which isn't really that often since only strings have nice literal syntax
14:57:58 <shapr> Can I explicitly use Data.Char.digitToInt without requiring an import?
14:58:02 <Beelsebob> Baughn: hell yeh!
14:58:04 <shapr> I wanted to put this code in a tweet :-)
14:58:17 <Beelsebob> Baughn: there's not insignificant amounts of my code in reactive
14:58:17 <Lemmih> shapr: No, that only works in GHCi.
14:58:29 <shapr> ah, too bad
14:58:29 <Baughn> shapr: Well, Data.Char.digitToInt is valid if you've already imported Data.Char ;)
14:58:37 <Berengal> ghci only importes Prelude...
14:58:40 <shapr> Berengal: Ah, good suggestion
14:58:47 <Berengal> And no, it doesn't include digitToInt
14:59:56 <shapr> Wow, Haskell golf is cool!
15:00:05 <Saizan> Berengal: in ghci a fully qualified symbol like that is resolved even if the module is not imported (if you were objecting to that)
15:00:26 <shapr> Complete result is: import Data.Char \n mnemonic = mapM ((list !!) . digitToInt) where list = words "0 1 abc de ghi jkl mno pqrs tuv wxyz"
15:00:37 <shapr> btw, I'm using it to try to find an especially good number for Google voice.
15:00:53 <Berengal> Saizan: Oh, fully qualified. Right
15:01:59 <RayNbow> Cale: could you help me finding an example where a "bijective homomorphism" exists between two posets which are not isomorphic (in Pos)?
15:02:26 <mmorrow> this paper is good (re: data representation) http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.12.3001 (and it's from 1992)
15:03:21 <shapr> yay, single tweet: Find google voice number import Data.Char;mnemonic = mapM ((list !!) . digitToInt) where list = words "0 1 abc de ghi jkl mno pqrs tuv wxyz"
15:04:11 <dmhouse> ?type (!!)
15:04:13 <lambdabot> forall a. [a] -> Int -> a
15:04:16 <shapr> Now to mix it up with a dictionary...
15:04:18 <dmhouse> mapM?
15:04:36 <mmorrow> hah, "A compilation involves two passes that communicate through an intermediate language nicknamed \"C--\"."
15:04:39 <shapr> dmhouse: I started with sequence $ map (\x -> list !! (read [x] :: Int)) "8572726227"
15:04:47 <Berengal> > mapM (([1,2,3,4] !!) . digitToInt) [1,2,3,4]
15:04:48 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
15:04:49 <lambdabot>    arising from the literal `1...
15:05:04 <Berengal> Doh
15:05:09 <shapr> dmhouse: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6906#a6906
15:05:12 <dmhouse> Oh, right, it's a list of lists.
15:05:15 <Berengal> > mapM ([1,2,3,4] !!) [1,2,3]
15:05:16 <lambdabot>   No instance for (GHC.Show.Show (m [b]))
15:05:16 <lambdabot>    arising from a use of `M57030385...
15:05:21 * dmhouse didn't spot the `words'
15:05:40 <Saizan> > mapM ([1,2,3,4] !!) [1,2,3] :: [[Int]]
15:05:41 <Berengal> I suck today :(
15:05:41 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Int])
15:05:42 <lambdabot>    arising from the literal `...
15:05:46 <dmhouse> > mapM ((list !!) . digitToInt) list where list = map (:[]) [1,2,3,4]
15:05:48 <lambdabot>   <no location info>: parse error on input `where'
15:06:04 <dmhouse> > let list = map (:[]) [1,2,3,4] in mapM ((list !!) . digitToInt) list
15:06:06 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
15:06:12 <Saizan> hah
15:06:14 <Berengal> > mapM ((words "abc def ghi")!!) [0,1,2]
15:06:16 <lambdabot>   ["adg","adh","adi","aeg","aeh","aei","afg","afh","afi","bdg","bdh","bdi","b...
15:06:16 <dmhouse> Yeah, etc. But it has to be a list of lists.
15:06:22 <Berengal> \o/
15:06:30 <Saizan> at last!
15:07:07 <dmhouse> shapr: could save more chars by inlining `list'.
15:07:41 <shapr> oh, good point
15:07:51 <shapr> import Data.Char;mnemonic = mapM ((words "0 1 abc de ghi jkl mno pqrs tuv wxyz" !!) . digitToInt)
15:09:08 <shapr> I think it'll be hard to shrink that much.
15:09:12 <dmhouse> :type digitToInt
15:09:16 <dmhouse> ?type digitToInt
15:09:18 <lambdabot> Char -> Int
15:09:27 <dmhouse> mnemonic = mapM ((words "0 1 abc de ghi jkl mno pqrs tuv wxyz" !!) . read . (:[])) -- shorter?
15:09:32 <Berengal> shapr: You could remove whitespace and rename the function to a single letter
15:09:42 <shapr> wel, yeah..
15:10:08 <shapr> But I also want people to be able to read it, and use it... nifty Haskell snippets are good advertising :-)
15:10:32 <Berengal> m=mapM((words"0 1 abc def ghi jkl mno pqrs tuv wxyz"!!).read.(:[]))
15:10:43 <dmhouse> > length "read . (:[])" `compare` (length "import Data.Char" + length "digitToInt")
15:10:45 <lambdabot>   LT
15:11:03 <shapr> heh
15:11:28 <shapr> Ok, I'm impressed.. it is actually much shorter now.
15:12:36 <dmhouse> shapr: if you're aiming for the readability-shortness balance, I'd probably use digitToInt instead of read . (:[]).
15:12:40 <Berengal> When someone invents unicode symbols for mapM, read and return it'll be shorter still
15:12:43 <dmhouse> The latter looks way arcane with that section.
15:13:19 <Saizan> ?quote monkey
15:13:19 <lambdabot> bakert says: haskell is so weird.  you just monkey around with types until the program writes itself.
15:13:26 <Saizan> ?quote monkey.operator
15:13:27 <lambdabot> psykotic says:  (:[]) is the happy monkey operator
15:13:31 <LambdaFred> @pl \x y -> compare (fun x) (fun y)
15:13:32 <lambdabot> (. fun) . compare . fun
15:13:43 <Saizan> ?quote eat.a.comment
15:13:43 <lambdabot> SamB_XP says: I once saw it eat a comment (:[{- Help! -}])
15:13:47 <Berengal> compare `on` fun
15:13:57 <LambdaFred> thanks
15:14:01 <Berengal> Or comparing fun
15:14:02 <LambdaFred> i knew there was something like that :)
15:14:06 <LambdaFred> is that "lifting"?
15:14:09 <Saizan> Data.Funtion.on
15:14:14 <Saizan> Data.Function.on
15:14:14 <Berengal> @type on
15:14:16 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
15:14:18 <Berengal> @type comparing
15:14:19 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
15:14:38 <dmhouse> LambdaFred: "lifting" is quite an overloaded term. It doesn't really apply here, though.
15:14:56 <dmhouse> Well, debatebly it does. It seems a little unnatural to me.
15:16:09 <JBarcelona> Germany http://www.chelariu.de/
15:16:39 <Vanadium> Hi
15:16:55 <Peaker> @let infixr ~> 2 ; (f ~> g) x = f >>> x >>> g
15:16:56 <lambdabot>   Parse error
15:17:03 <Peaker> @let infixr 2 ~> ; (f ~> g) x = f >>> x >>> g
15:17:05 <lambdabot>  Defined.
15:17:21 <Peaker> @type \f -> f ~> f ~> id
15:17:23 <lambdabot> forall a b b1. (a -> b) -> (b -> b -> b1) -> a -> a -> b1
15:17:33 <Peaker> @type flip $ \f -> f ~> f ~> id
15:17:34 <lambdabot> forall a b b1. (b -> b -> b1) -> (a -> b) -> a -> a -> b1
15:17:44 <shapr> I swear, I wish I could filter spam out of the channel logs.
15:18:02 <Peaker> shapr: ain't much spam here...?
15:18:26 <Saizan> 3 just today feels like a lot here
15:18:55 <RayNbow> am I having a dejavu? :p <Peaker> @let infixr 2 ~> ; (f ~> g) x = f >>> x >>> g
15:19:06 <Peaker> RayNbow: I need to re-@let it all the time, yeah
15:20:16 <vinicius> @type >>>
15:20:18 <lambdabot> parse error on input `>>>'
15:20:21 <RayNbow> :t (>>>)
15:20:22 <vinicius> @type (>>>)
15:20:23 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
15:20:24 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
15:20:27 <Berengal> Ooo, nifty combinator
15:21:40 <dmhouse> Huh, isn't that from Control.Arrow?
15:21:42 <dmhouse> ?hoogle (>>>)
15:21:43 <lambdabot> Control.Arrow (>>>) :: Arrow a => a b c -> a c d -> a b d
15:21:49 <RayNbow> that too
15:22:00 <Berengal> It's flip (.)
15:22:03 <RayNbow> but it is no longer in the Arrow class
15:22:14 <RayNbow> it has moved up to Category
15:22:23 <dmhouse> Is that a superclass?
15:22:32 <RayNbow> it should be now
15:22:50 <dmhouse> Yes, I guess it must be. Is that the only operation?
15:23:17 <RayNbow> Category consists of (.) and id
15:31:35 <gwern> dr. scheme is nice, but the inconsistent keybindings are driving me nuts
15:31:47 <gwern> is it emacs, is it CUA, is it schizophrenic
15:32:34 <olsner> @pl \a b c d -> [a,b,c,d]
15:32:34 <gwern> (in other news, these 'write addition or multiplication using iteration in a log number of steps' are really killing me. this part of the chapter can't be over soon enough)
15:32:35 <lambdabot> (. ((. ((. return) . (:))) . (.) . (:))) . (.) . (.) . (:)
15:39:14 <benmachine> so I installed my own lambdabot from cabal
15:39:27 <benmachine> but I just get this
15:39:31 <benmachine> lambdabot> > 1 Terminated
15:39:33 <benmachine> er
15:39:37 <benmachine> irssi chomped my newlines
15:39:40 * benmachine manual
15:39:44 <benmachine> lambdabot> > 1
15:39:47 <benmachine>  Terminated
15:39:58 <Saizan> benmachine: did you install mueval?
15:40:06 <benmachine> I probably didn't
15:40:17 <benmachine> was I supposed to
15:40:23 <benmachine> is there a list of things I shoudl have
15:40:36 <gwern> brainfuck, mueval, hoogle
15:40:43 <benmachine> oh
15:40:45 <benmachine> thanks!
15:40:52 <gwern> the big ones, and obviously each is optional if you don't use it
15:43:55 <Taejo> > sequenceM [["twist", "exist"], ["twine"]]
15:43:56 <lambdabot>   Not in scope: `sequenceM'
15:44:03 <Taejo> > sequence [["twist", "exist"], ["twine"]]
15:44:04 <lambdabot>   [["twist","twine"],["exist","twine"]]
15:44:07 <gwern> @hoogle sequenceM
15:44:07 <lambdabot> No results found
15:44:13 <gwern> :t sequence
15:44:14 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
15:44:39 <RayNbow> @src Cont
15:44:39 <Taejo> gwern: in the case of m = [], the signature doesn't tell you much :)
15:44:40 <lambdabot> newtype Cont r a = Cont { runCont :: (a -> r) -> r }
15:44:43 <FunctorSalad_> RayNbow: try a function that is the identity on the carrier sets ;)
15:45:02 <RayNbow> FunctorSalad_: carrier sets?
15:45:18 <benmachine> now it says Could not find module `Control.Arrow.Transformer.All':
15:45:37 <FunctorSalad_> you asked about a bijective monotonic map between posets that isn't invertible in the cat of posets, right?
15:45:44 <benmachine> I used my newly-operational @hoogle to find some packages but installing them didn't help
15:46:01 <benmachine> @hoogle Control.Arrow.Transformer.All
15:46:02 <lambdabot> package cabal-install
15:46:02 <lambdabot> keyword forall
15:46:02 <lambdabot> package hinstaller
15:46:11 <benmachine> what does keyword forall mean in that result?
15:46:13 <RayNbow> FunctorSalad_: yes, so I could understand something that's written in Awodey's book on CT :p
15:46:20 <RayNbow> FunctorSalad_: but what are carrier sets? :p
15:46:33 <FunctorSalad_> RayNbow: a poset is based on a set, right?
15:46:39 <RayNbow> yes
15:46:45 <FunctorSalad_> I simply mean that set
15:49:02 <Taejo> :t guard
15:49:04 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
15:49:57 <FunctorSalad_> this feels very simliar to the same problem in TOP rather than POSET
15:50:12 <FunctorSalad_> I guess it's related by the order topology or so
15:50:43 <roconnor> Saizan: I was a little wrong.  There are two reasonable Monoids on AlphaColour, but in neither case is `opaque' a Monoid homomorphism.
15:54:07 <RayNbow> FunctorSalad_: I'm still puzzled. Could you give me two example non-isomorphic (po)sets for which I could try to find a bijective homomorphism?
15:54:57 <jdrake> How might I run the testsuite on an already installed ghc? (macport installed)
15:55:22 <benmachine>   Could not find module `Control.Monad.Writer':
15:55:22 <benmachine>    it was found in multiple packages: monads-fd-0.0.0.1 mtl-1.1.0.2
15:55:41 <benmachine> I don't even remember what these packages are :/
15:56:41 <Taejo> @pl \soln -> mapM_ (guard . satisfies soln) ints
15:56:41 <lambdabot> flip mapM_ ints . (guard .) . satisfies
15:56:55 <roconnor> Saizan: although I guess (`over` black) is a monoid homomorphism when using the alternative monoid structure on AlphaColour
15:57:10 <Taejo> @src forM_
15:57:11 <lambdabot> forM_ = flip mapM_
15:57:13 <Taejo> cool
15:58:41 <coCocoa> benmachine: mtl is the standard package.
15:59:10 <benmachine> coCocoa: mm, cabal doesn't seem to have an uninstall, though
15:59:15 * benmachine goes on a rming spree
15:59:21 <FunctorSalad_> RayNbow: it works for any poset with more than one element ;)
15:59:37 <FunctorSalad_> as I said, the map is the identity in Set
15:59:48 <coCocoa> benmachine: That's because you uninstall it from ghc-pkg. :)
15:59:53 <benmachine> oh
15:59:57 <Taejo> benmachine: hide is your friend, in this case
16:00:08 <RayNbow> but identity is a function from a -> a then, FunctorSalad_?
16:00:36 <FunctorSalad_> in Set, but not in Poset RayNbow
16:00:54 <FunctorSalad_> the identity is always an iso in its own category
16:00:55 <coCocoa> benmachine: Are you installing/have you installed Yi, perhaps?
16:01:13 <benmachine> coCocoa: I think I have done so in the past
16:01:17 <FunctorSalad_> RayNbow: tell me if I should resolve it
16:01:58 <coCocoa> benmachine: It may be easier then to hide -fd, then if you aren't using it.
16:02:29 <Taejo> :t replicateM
16:02:30 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
16:03:44 <RayNbow> FunctorSalad_: well, could we walk through an example poset... like perhaps p = ({1,2,3}, (<=)) ?
16:03:52 <benmachine> got it, thanks guys
16:03:57 * benmachine moves on to the next package
16:04:21 <FunctorSalad_> RayNbow: you need two different orders on the same set
16:04:41 <FunctorSalad_> (remember that they're *partial* orders)
16:20:45 <RayNbow> FunctorSalad_, s = {1,2,3,4};     p = (s, d(x,y)<=1 && x<=y);    q = (s, d(x,y)<=2 && x<=y) ?
16:22:58 <FunctorSalad_> RayNbow: these are not transitive
16:23:11 <RayNbow> ah crap
16:24:06 <RayNbow> perhaps it might be better to continue this later, it's getting late here :p
16:25:33 <natthew> Hi. I've been trying to figure this out for weeks to no avail. How do I read/write data strictly and quickly?
16:25:47 <gwern> bytestring
16:25:58 * RayNbow should also get a bouncer in the near future so he doesn't have to pollute channels with multiple clients connected
16:26:13 <gwern> natthew: data.binary might also be strict enough for you; it should be quick enough
16:26:35 <natthew> gwern: How do I make a bytestring?
16:26:42 <natthew> Data.Binary is not strict enough
16:26:57 <natthew> I need to open a file, modify it, and rewrite it.
16:27:13 <natthew> Data.Binary tells me the file is locked
16:27:44 <natthew> I can't find how to convert a bytestring to a list of doubles and vice versa
16:27:48 <gwern> readFile, modify, writeFile I'd guess with strict bytestring
16:28:28 <natthew> That's what I want to do, but readFile gives me a ByteString, not the data type i want
16:32:28 <natthew> gwern: Do I need to make my data into Word8 first?
16:32:42 * gwern shrugs
17:23:20 <Squarism> #haskell = idle-station
17:24:00 <MyCatVerbs> Depends on the time of day.
17:24:07 <soupdragon> A = pi r Squarism
17:24:15 <MyCatVerbs> And, to a greater extent, the time of year.
17:24:25 <MyCatVerbs> Specifically, it's always much busier during term-time. :)
17:24:35 <Squarism> aha
17:24:39 <Squarism> that explains it
17:24:58 <Squarism> its heavily used in academics?
17:25:44 <MyCatVerbs> Yeah, it's one of a handful of languages that many universities use when they want to introduce undergrads to FP ideas.
17:25:56 <Squarism> oh okey
17:26:24 <MyCatVerbs> bris.ac.uk teaches it in the second year of the course, for example.
17:26:45 <Squarism> compared to other language channels with around 100 ppl - its dead quiet in here in comparrisson
17:26:52 <gwern> argh, stupid scheme
17:26:59 <Cale> Squarism: Just picked a bad time, I guess.
17:27:05 <gwern> why do you make it so hard to get [n..m] and filter out the primes
17:27:22 <Cale> Squarism: There are certain hours when it gets a bit quiet, but mostly there are people around 24/7
17:27:23 <soupdragon> gwern: In scheme?
17:27:38 * gwern hates you so much! compared to haskell, that is. and this no-compile-checks thing is worse than I expected
17:28:42 <MyCatVerbs> (define (enumFromTo n m) (cond ((= n m) nil) (#t (cons n (enumFromTo (+ 1 n) m))))))
17:29:01 <MyCatVerbs> Shit, too many )'s.
17:29:07 <gwern> more or less what I had
17:29:26 <gwern> I have the additional wrinkle that I want only odds, so I had to mess with the internal logic a little
17:29:27 <MyCatVerbs> Oh, but it's '() rather than nil.
17:29:45 <MyCatVerbs> So write (+ 2 n) ;P
17:30:01 <MyCatVerbs> (define (enumFromTo n m) (cond ((= n m) '()) (#t (cons n (enumFromTo (+ 1 n) m)))))
17:30:04 <gwern> MyCatVerbs: and (enumFromTo 2 10)?
17:30:28 <soupdragon> enum-from-to
17:30:29 <MyCatVerbs> gwern: hit somebody at random with a spanner.
17:30:36 <MyCatVerbs> soupdragon: oh yeah, my bad.
17:46:24 <gwern> I can never remember
17:46:33 <gwern> what kind of abstraction is filter?
17:46:43 <gwern> not a zygohistomorphisms, I'm sure
17:47:01 <soupdragon> you can define it as a cata
17:47:48 <dibblego> cata alone is not enough
17:48:33 <soupdragon> not sure what you mean by that
17:48:58 <dibblego> try to write (a -> Bool) -> f a -> f a using Data.Foldable.foldr -- you won't
17:49:33 <soupdragon> I was talking about f = []
17:50:09 <Twey> @pl \x y@Y{z = z'} -> y{z = f w t z'}
17:50:09 <lambdabot> (line 1, column 5):
17:50:09 <lambdabot> unexpected "@"
17:50:09 <lambdabot> expecting pattern or "->"
17:50:25 <Twey> Hm
17:52:56 <FunctorSalad_> filter p = foldr (\x r -> if p x then (x:r) else r) []
17:52:58 <FunctorSalad_> cata!
17:53:10 <FunctorSalad_> probably ana too
17:53:33 <copumpkin> and hylo!
17:53:37 <copumpkin> :P
17:53:47 <copumpkin> (a pretty boring one I guess)
17:53:48 <FunctorSalad_> :o oh no it's the hylomorphism
17:54:00 <FunctorSalad_> was that ana . cata or cata . ana?
17:54:20 <dolio> That only works as a cata because you're using (:), which you don't have for arbitrary f.
17:54:30 <dibblego> @type \ p -> foldr (\x r -> if p x then pure x `mappend` r else r) mempty
17:54:32 <lambdabot> forall a (f :: * -> *). (Applicative f, Monoid (f a)) => (a -> Bool) -> [a] -> f a
17:54:50 <coCocoa> paramorphic, maybe? :)
17:54:52 <dibblego> @type \ p -> Data.Foldable.foldr (\x r -> if p x then pure x `mappend` r else r) mempty
17:54:54 <lambdabot> forall a (f :: * -> *) (t :: * -> *). (Applicative f, Monoid (f a), Data.Foldable.Foldable t) => (a -> Bool) -> t a -> f a
17:55:09 <dolio> And you can't write filter as a productive anamorphism, either.
17:55:33 <FunctorSalad_> right, that's why stream-fusion has "Skip"
17:55:46 <dolio> Yes.
17:57:03 <dolio> And hylo f g = cata f . ana g
17:57:44 <FunctorSalad_> I'm not familiar with the hylos... what's the point if you have to specify a whole algebra and coalgebra anyway?
17:57:54 <FunctorSalad_> performance?
17:58:52 <dolio> There was some hope for hylo-based fusion frameworks a while back.
17:59:00 <dolio> Nobody ever took them anywhere, though.
17:59:09 <copumpkin> :o
17:59:26 <copumpkin> dolio: any urls on that?
18:00:01 <dolio> No. You'll probably be able to find haskell mailing list posts that mention hylo-fusion.
18:00:55 <dolio> I don't know whether it didn't go anywhere because it wasn't viable, or because people just didn't pursue it enough, though.
18:01:46 <Warrigal> Is there a function to split a list into chunks wherever an element satisfies a certain function?
18:02:21 <Warrigal> E.g. "fneisGesmoWmsiDf" to ["fneis","esmo","msi","f"], where the function is isUpper.
18:02:44 <EvilTerran> ?hackage split
18:02:45 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/split
18:02:53 <EvilTerran> may have something appropriate
18:02:53 <olsner> @ty splitBy
18:02:56 <lambdabot> Not in scope: `splitBy'
18:03:27 <EvilTerran> Warrigal, or, if you want to stick to standard lib stuff, recursive use of break isUpper would suit
18:03:27 <EvilTerran> ?type break isUpper
18:03:29 <lambdabot> [Char] -> ([Char], [Char])
18:03:38 <Warrigal> > splitWhen isUpper "fneisGesmoWmsiDf"
18:03:39 <lambdabot>   Not in scope: `splitWhen'
18:03:47 <Warrigal> > Data.List.Split.splitWhen isUpper "fneisGesmoWmsiDf"
18:03:48 <lambdabot>   Not in scope: `Data.List.Split.splitWhen'
18:03:56 * Warrigal frowns.
18:04:42 <EvilTerran> > let uncamelcase "" = ""; uncamelcase s = w : uncamelcase s' where (w,s') = break isUpper s in uncamelcase "fneisGesmoWmsiDf"
18:04:44 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
18:04:46 * Cale adds both cayenne and curry to his ramen, in an apparent effort to involve as many names of functional languages as possible in his food.
18:04:57 <coCocoa> @src words
18:04:57 <lambdabot> words s = case dropWhile isSpace s of
18:04:58 <lambdabot>     "" -> []
18:04:58 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
18:05:28 <olsner> Cale: as long as there's no Haskell Curry in it, because that would be downright creepy
18:05:29 <dolio> No camel?
18:05:31 <EvilTerran> Warrigal, the split module isn't loaded into lambdabot, as far as i know
18:05:37 <EvilTerran> > let uncamelcase "" = []; uncamelcase s = w : uncamelcase s' where (w,s') = break isUpper s in uncamelcase "fneisGesmoWmsiDf" -- ahem
18:05:39 <lambdabot>   ["fneis","","","","","","","","","","","","","","","","","","","","","","",...
18:06:02 <EvilTerran> ... no? never mind
18:06:03 <coCocoa> Cale: What is the "ramen" language like? ;p
18:06:05 <pikhq> o.o
18:06:12 <Warrigal> @hoogle on
18:06:13 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
18:06:13 <lambdabot> Text.PrettyPrint.HughesPJ OneLineMode :: Mode
18:06:13 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
18:07:08 <Cale> coCocoa: Probably full of tangled continuations.
18:07:39 <MyCatVerbs> coCocoa: reminiscent of spaghetti code, but really not the same thing at all.
18:08:06 <EvilTerran> spaghetti code is code with too many gotos, is ramen code code with too many callccs?
18:08:17 <Warrigal> > let food s = case dropWhile (\x -> not (isAlpha x || isSpace x)) s of "" -> []; s' -> w : food s'' where (w, s'') = break (\x -> not (isAlpha x || isSpace x)) s' in food "What do you do, my eponymous friend?"
18:08:19 <lambdabot>   ["What do you do"," my eponymous friend"]
18:08:24 <Warrigal> Great!
18:08:31 <coCocoa> Cale, MyCatVerbs: Oh, so you mean compiled Ruby? <ducks>
18:08:41 <olsner> EvilTerran: that actually sounds really awesome
18:09:30 <EvilTerran> olsner, arithmetic with CPS-transformed peano numerals!
18:09:37 <olsner> mmm, yummy
18:09:41 <EvilTerran> er, s/peano/church/, that should be, shouldn't it
18:10:06 <olsner> aren't church numerals an implementation of peano numerals?
18:10:10 <olsner> or something like that?
18:10:41 <EvilTerran> well, peano numerals are an inductive definition
18:10:53 <EvilTerran> in haskell terms, a recursive ADT
18:11:28 <EvilTerran> i guess church numerals are pretty much the church encoding of peano numerals, yeah
18:12:05 <EvilTerran> or you could look at the church numeral for n as the catamorphism of the peano numeral for n
18:14:10 <olsner> hmm, I gotta learn those morphisms
18:55:48 <gwern> @quote stupid_theta
18:55:48 <lambdabot> No quotes match. Sorry.
18:56:01 <gwern> @remember SimonPJ [re: class constraints on data declarations] In GHC's source code these contexts are consistently called stupid_theta.
18:56:02 <lambdabot> Okay.
18:56:08 <gwern> @quote an.ass
18:56:08 <lambdabot> JN says: this tutorial just introduced _|_ and called it bottom.  I assume that's because it looks like an ass?
18:56:17 <gwern> @quote JavaScript
18:56:17 <lambdabot> uman says: so you can pass functions around as objects... this sounds like JavaScript
18:56:30 <Badger> heh
18:56:31 <gwern> @quote semolina
18:56:31 <lambdabot> Twey says: <Twey> Mr. Wing, sir, if you are listening: you have the I.Q. of a semolina pudding <Twey> And your homepage is full of <font> tags <Twey> I'm not sure which is the greater insult, but at
18:56:31 <lambdabot> least one is objectively true
18:56:49 <gwern> @quote overwhelming
18:56:50 <lambdabot> jmcarthur says: #haskell: Overwhelmingly helpful.
18:57:05 <gwern> @quote haiku
18:57:05 <lambdabot> lilac says: class Monad m where / return and Kleisli compose / must form a monoid  <lilac> that's my new monad tutorial haiku  <jmcarthur> i think that is the best monad tutorial i have ever
18:57:05 <lambdabot> read
18:57:14 <gwern> @quote happy
18:57:14 <lambdabot> psykotic says:  (:[]) is the happy monkey operator
18:57:16 <gwern> @quote happy
18:57:17 <lambdabot> paczesiowa says: my friends (evil, imperative and objectionable) from university laugh at me that I love haskell and I wont find any job as haskell programmer. I get sad when I start to believe them.
18:57:17 <lambdabot>  but then I look at some java code and I'm all happy again
18:57:20 <gwern> @quote happy
18:57:20 <lambdabot> psykotic says: the reader monad is your friend. trust the reader monad. be happy!
18:57:25 <gwern> @quote happy.is
18:57:26 <lambdabot> dcoutts says: make sure happy is on your path and it'll all be ok
18:57:34 <gwern> @quote know.programming
18:57:34 <lambdabot> roco says: guys i have problem, does anybody know programming ?
18:57:42 <gwern> @quote denote
18:57:43 <lambdabot> No quotes match. Listen, broccoli brains, I don't have time to listen to this trash.
18:57:52 <gwern> @remember ski my answer to that is : don't deduce, denote!
18:57:52 <lambdabot> It is stored.
18:58:01 <gwern> @quote C++
18:58:01 <lambdabot> Pseudonym says: A "newbie", in Haskell, is someone who hasn't yet implemented a compiler. They've only written a monad tutorial.
18:58:07 <gwern> @quote C\+\+
18:58:07 <lambdabot> dons says: C++: creating blub programmers since 1985
18:58:10 <gwern> @quote C\+\+
18:58:11 <lambdabot> cypherx says: Oh god, C++ is like a lamprey in my urethra.
18:58:19 <gwern> ok, that one's funny
18:58:25 <gwern> @quote C\+\+
18:58:25 <lambdabot> dons says: C++: creating blub programmers since 1985
18:58:31 <gwern> @quote C\+\+.are
18:58:31 <lambdabot> dhjdhj says: All new features added to C++ are intended to fix previously new features added to C++
18:58:36 <gwern> @flush
19:00:55 <tommd> @quote lambdabot
19:00:56 <lambdabot> lambdabot says: Done.
19:01:02 <tommd> @quote lambdabot
19:01:02 <lambdabot> lambdabot says: I know nothing about comprehending.
19:02:48 <wmealing__> My wife saw me type (_+_) and asked me "is that the ass operator ?"
19:06:13 <tommd> wmealing__: I assume you told her about "bottom" - your statement is very similar to a recent quote about _|_
19:06:55 <coCocoa> wmealing__: Right, I was going to ask is you showed her "bottom"...what, that's not how I meant it, you perv! ;)
19:07:26 * SamB_XP_ likes that (_|_) pun too
19:07:37 <FunctorSalad_> is your wife doing CS-related stuff too?
19:08:19 <FunctorSalad_> just wondering because at least she recognized it as an operator :)
19:08:22 <aavogt> @quote gwern
19:08:23 <lambdabot> gwern says: the best way to optimize a program is to make it lazier or stricter.
19:08:35 <FunctorSalad_> @quote bottom
19:08:36 <lambdabot> JN says: this tutorial just introduced _|_ and called it bottom.  I assume that's because it looks like an ass?
19:08:43 <FunctorSalad_> ...
19:09:00 <Badger> @quote FunctorSalad
19:09:00 <lambdabot> FunctorSalad says: lol I solved my typechecking problem... forgot that I overrode (.)
19:09:03 <FunctorSalad_> could also be interpreted as a different body part actually
19:09:16 <mike-burns> The armpit?
19:09:56 <FunctorSalad_> @quote cat
19:09:56 <lambdabot> sjanssen says: I suspect that planet.haskell.org has more content on catamorphisms than cats
19:10:04 <FunctorSalad_> @quote cat
19:10:05 <lambdabot> newsham says: taxonomies are prob more a reflection on the person categorizing than on whats being categorized :)
19:10:16 <FunctorSalad_> nice
19:10:45 <SamB_XP_> @quote pussy
19:10:46 <lambdabot> No quotes match. Are you on drugs?
19:10:49 <SamB_XP_> @quote cat
19:10:50 <lambdabot> FliPPeh says: @faq Can Conficker be rewritten in Haskell? <lambdabot> <no location info>: parse error on input `:'
19:11:08 <FunctorSalad_> there is no cat there
19:11:21 <SamB_XP_> I was about to mention that
19:11:24 <SamB_XP_> @quote cat
19:11:25 <lambdabot> ghc says: Malformed predicate
19:11:31 <SamB_XP_> okay, there's a cat there...
19:11:36 <SamB_XP_> oh ... found it!
19:11:38 <FunctorSalad_> hehe
19:11:38 <Badger> location
19:11:40 <SamB_XP_> "no location info"
19:11:43 <FunctorSalad_> !
19:11:55 <FunctorSalad_> that's pretty well-hidden
19:11:57 <SamB_XP_> @quote cat
19:11:58 <lambdabot> newsham says: taxonomies are prob more a reflection on the person categorizing than on whats being categorized :)
19:11:58 <Badger> No lo cat ion info.
19:12:15 <SamB_XP_> @quote lol
19:12:16 <lambdabot> glguy says: lol, making lambdabot fight your battles
19:12:16 <FunctorSalad_> @quote haskle
19:12:17 <lambdabot> No quotes match.
19:12:21 <SamB_XP_> @quote lol
19:12:21 <lambdabot> qwe1234 says: lol, thanks for the pointless offtopic post
19:12:24 <SamB_XP_> @quote lol
19:12:25 <lambdabot> qwe1234 says: lol, 'free university of amsterdam'.
19:12:29 <SamB_XP_> @quote lol
19:12:30 <lambdabot> Gracenotes says: > let o_o = 0.0 ;o' =(, ); ;o (*)=(*) ;( lol, xD :p )= o' o' $o.o$ (:[]) $o.o$ (:[]) o_o in (:[]) o_o :p
19:12:32 <FunctorSalad_> @quote rofl
19:12:33 <lambdabot> No quotes match. Where did you learn to type?
19:12:48 * SamB_XP_ wonders why qwe1234 isn't relegated to his own command, like keal
19:13:00 <FunctorSalad_> @keal
19:13:00 <lambdabot> nsa has all the profiling info you need to come up with the correct survey answers
19:13:18 <Badger> > let o_o = 0.0 ;o' =(, ); ;o (*)=(*) ;( lol, xD :p )= o' o' $o.o$ (:[]) $o.o$ (:[]) o_o in (:[]) o_o :p
19:13:20 <lambdabot>   [[0.0]]
19:13:30 <Badger> impressive
19:13:41 <aavogt> @quote quine
19:13:42 <lambdabot> No quotes match. Sorry about this, I know it's a bit silly.
19:16:12 <Vanadium> monads really need an unreturn method
19:17:04 <aavogt> Vanadium: many do
19:17:24 <Vanadium> Yeah. Those are pretty cool.
19:17:36 <wmealing__> hah
19:17:37 <aavogt> but if it was required, it would mess up things like IO
19:17:51 <coCocoa> Vanadium: Likewise, there are many, for which that is utturly impossible.
19:17:57 <wmealing__> I tried to explain folding to her, but she's an imperative girl...
19:18:05 <coCocoa> Er, *utterly
19:18:09 <Vanadium> coCocoa: I figured there might be a class for monads that have one
19:18:21 <aavogt> @quote comonad
19:18:22 <lambdabot> norpan says: the comonad of the No monad is the Yes monad?
19:19:07 <Vanadium> :O
19:19:12 <wmealing__> and she's living in an imperative world and she is an imperative girl.. oohhooh oh
19:19:42 <FunctorSalad_> sounds opposite from cse band's "theory girl" :)
19:19:57 <gwern> don't know what she wants with a functional guy \ her mom and dad can't eval why
19:19:58 <FunctorSalad_> theory girl... she doesn't wanna code in C or perl
19:20:37 <aavogt> so we can use the same name for: fromJust, head, unsafePerformIO, fst . runWriter
19:20:51 <aavogt> @hoogle Writer w a -> a
19:20:51 <lambdabot> Control.Monad.Writer.Lazy execWriter :: Writer w a -> w
19:20:52 <lambdabot> Control.Monad.Writer.Strict execWriter :: Writer w a -> w
19:20:52 <lambdabot> Data.Typeable typeOf2 :: Typeable2 t => t a b -> TypeRep
19:21:05 <Vanadium> aavogt: That is what comonads do?
19:21:10 <Vanadium> Or, huh
19:21:25 <FunctorSalad_> uh hardly any monad has a reasonable unreturn
19:21:35 <FunctorSalad_> unreturn [] = ?
19:21:44 <FunctorSalad_> unreturn (State ...) = ?
19:21:56 <pikhq> FunctorSalad_: unreturn [] = unsafePerformIO exit
19:21:58 <pikhq> :P
19:22:40 <aavogt> @type exit
19:22:42 <lambdabot> Not in scope: `exit'
19:22:50 <aavogt> @type System.Exit.exit
19:22:51 <lambdabot> Not in scope: `System.Exit.exit'
19:22:57 <aavogt> @hoogle exit
19:22:57 <lambdabot> module System.Exit
19:22:58 <lambdabot> System.Exit data ExitCode
19:22:58 <lambdabot> Control.Exception ExitException :: ExitCode -> Exception
19:22:58 * pikhq can does thinko.
19:25:08 <FunctorSalad_> unreturn (Left "errorz") ...
19:29:07 <strathhelp> anychance someone could give a bit of advice, is it possible to use the length test within an until ?
19:29:50 <strathhelp> until (length == x ) (helpSize) [1,1]                -- like such, obviously doesn't work
19:29:56 <Axman6> what do you mean?
19:30:10 <Axman6> :t until
19:30:11 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
19:30:33 <Axman6> where's the x coming from?
19:30:50 <strathhelp> x is an argument containing the expected length
19:30:51 <Axman6> (i think i see where you're going, and i don;t think it's possible)
19:31:02 <strathhelp> ouch.
19:31:10 <strathhelp> thanks
19:31:25 <Axman6> well, i shouldn't say not possible, of course it's possible, but probably not with until
19:31:40 <Axman6> roll your own, shouldn't be too hard
19:32:15 <Teja> hi
19:32:24 <Teja> trying to work on realworld haskell exercises from chap 4
19:32:24 <canvon> strathhelp: until (\a -> length a == x)  -- perhaps?
19:32:36 <Teja> had a doubt? can somebody help me out?
19:32:50 <Axman6> Teja: sure, but we'll need to know the problem first ;)
19:33:13 <strathhelp> canvon, that works
19:33:14 <Teja> Axman6: trying to implement the safeHead
19:33:21 <strathhelp> you just saved me from hours more of frustration
19:33:23 <strathhelp> thanks :D
19:33:27 <canvon> strathhelp: :]
19:33:37 <Teja> Axman6: safeHead [] = Nothing
19:33:37 <Teja> safeHead x:_ = x
19:33:42 <strathhelp> god i was thinking of maybe implementing a postfix length operator just to get it to work
19:33:54 <Axman6> ah. ok, so what is the type of x here?
19:33:56 <Teja> when loading in ghc it is saying parse error
19:34:20 <Axman6> oh yeah, you need parens
19:34:29 <Axman6> safeHead (x:_) = x
19:34:37 <Teja> oh let me try
19:34:41 <Axman6> but that's still broken slightly
19:35:08 <aavogt> safeHead :: [Maybe a] -> Maybe a
19:35:25 <Teja> Axman6: Not working
19:35:31 <Teja> it compiled good
19:35:33 <pikhq> aavogt: Why [Maybe a] -> Maybe a?
19:35:47 <Axman6> :t let sh [] = Nothing; sh (x:_) = x in sh
19:35:49 <lambdabot> forall a. [Maybe a] -> Maybe a
19:35:51 <Teja> but safeHead [2] is giving error
19:35:59 <strathhelp> canvon, i'd like to understand how that works, any links to relevant tutorials, i'm not familiar with this \a notation
19:36:06 <aavogt> pikhq: there's no Just on the right hand side
19:36:19 <aavogt> of the nonempty case
19:36:21 <Axman6> Teja: well, 'not working' isn't very helpful, how is it not working? what;s the error say?
19:36:24 <pikhq> aavogt: Ah.
19:36:25 <Teja> let me explain my problem, I want a fail safe head
19:36:44 <Teja> Axman6: No instance for (Num [Maybe a])
19:36:44 <Teja>       arising from the literal `2' at <interactive>:1:10
19:36:44 <Teja>     Possible fix: add an instance declaration for (Num [Maybe a])
19:36:44 <Teja>     In the expression: 2
19:36:44 <Teja>     In the first argument of `safeHead', namely `[2]'
19:36:44 <Teja>     In the expression: safeHead [2]
19:36:46 <benmachine> @pl \a -> length a == x
19:36:47 <lambdabot> (x ==) . length
19:36:57 <Axman6> uh
19:37:17 <Axman6> Teja: well the code you've shown should not give that error at all, it must be somewhere else
19:37:21 <aavogt> > let safeHead x = case x of [] -> Nothing; (x:_) -> x in safeHead [Just 1]
19:37:23 <lambdabot>   Just 1
19:37:49 <pikhq> Axman6: safeHead [2] when the function is of type [Maybe a] -> Maybe a.
19:37:50 <benmachine> no it gives that error because it thinks the list should have Maybes in it
19:37:53 <aavogt> > 2 :: Maybe Int
19:37:54 <Axman6> ah yrs
19:37:55 <pikhq> That's what we call a type failure.
19:37:55 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe GHC.Types.Int))
19:37:55 <lambdabot>    arising f...
19:37:56 <Axman6> yes*
19:37:57 <pikhq> ;)
19:38:07 <benmachine> because that's the only way to make the RHS of the second pattern match
19:38:17 <benmachine> but really that's because that RHS is wrong and should have a Just
19:38:30 <benmachine> if you had a type signature this would probably be clearer
19:38:35 <Teja> hmmm
19:38:37 <coCocoa> I.e., "safeHead [Just 2]"
19:38:40 <Teja> i don't get it
19:38:46 <Axman6> Teja: that;s because 2 is not the right type. what is the type of what safeHead is supposed to return?
19:38:53 <Axman6> @src Maybe
19:38:53 <lambdabot> data Maybe a = Nothing | Just a
19:38:54 <Teja> ploymorphic
19:39:00 <coCocoa> @type [2]
19:39:01 <lambdabot> forall t. (Num t) => [t]
19:39:03 <Teja> we know th head function right?
19:39:06 <coCocoa> @type [Just 2]
19:39:08 <lambdabot> forall t. (Num t) => [Maybe t]
19:39:14 <Teja> it returns exception with null list
19:39:15 <benmachine> Teja: I think if you add an explicit type signature it should help illustrate the problem
19:39:18 <aavogt> @src head
19:39:19 <lambdabot> head (x:_) = x
19:39:19 <lambdabot> head []    = undefined
19:39:20 <Teja> want to return nothing
19:39:23 <benmachine> or help the compiler give better errors, anyway
19:39:32 <Axman6> Teja: we know, and i'm sure 90% of people could implement this function just fine :)
19:40:07 <Axman6> Teja: ok, what is the type of: safeHead [2] supposed to be?
19:40:08 <Teja> yes, but I am a beginner
19:40:12 <canvon> strathhelp: that's just a lambda abstraction. see http://www.haskell.org/tutorial/functions.html#sect3.1 -- or start the tutorial from the beginning, i always found it very helpful and inspiring
19:40:16 <Teja> help me plx
19:40:22 <aavogt> @djin ([] a) -> Maybe a
19:40:23 <lambdabot> Maybe you meant: djinn djinn-add djinn-clr djinn-del djinn-env djinn-names djinn-ver
19:40:23 <Axman6> i know, we're trying to
19:40:28 <Teja> it should return 2
19:40:32 <aavogt> @djinn ([] a) -> Maybe a
19:40:32 <lambdabot> Cannot parse command
19:40:40 <aavogt> @djinn f :: ([] a) -> Maybe a
19:40:40 <benmachine> Teja: it can't return 2 in some cases and Nothing in others
19:40:41 <lambdabot> Cannot parse command
19:40:42 <Axman6> Teja: is 2 a Maybe a?
19:40:45 <benmachine> because those are different types
19:40:46 <Teja> yes
19:40:50 <Teja> oh ok
19:40:56 <Axman6> @src Maybe
19:40:57 <lambdabot> data Maybe a = Nothing | Just a
19:41:09 <Axman6> a Maybe a is either a Nothing, or a Just a
19:41:17 <Teja> benmachine: whats the solution then
19:41:29 <benmachine> Teja: return Just 2
19:41:31 <benmachine> instead of 2
19:41:32 <Axman6> well, you haven;t used Just anywhere have you?
19:41:35 <coCocoa> Teja: Try "safeHead [Just 2]"
19:41:45 <benmachine> coCocoa: no don't :P
19:41:45 <Teja> yes, never used before
19:41:54 <Axman6> well, you need to
19:41:58 <Teja> ok
19:42:06 <Teja> so what should be my code
19:42:12 <aavogt> ... use return and fail instead?
19:42:18 <Axman6> aavogt: shh
19:42:20 <Axman6> :P
19:42:25 <benmachine> aavogt: overcomplicating things
19:42:33 <coCocoa> Teja: Your code is fine. Your understanding needs improvement. ;)
19:42:35 <pikhq> aavogt: Shh. Don't confuse him with Monad.
19:42:37 <Axman6> Teja: safeHead [] = Nothing; safeHead (x:_) = Just x
19:42:38 <strathhelp> canvon: Thanks
19:42:41 <pikhq> (yet)
19:42:48 <Teja> cococoa: help me plz
19:43:01 * Axman6 can see that more will be learned by giving the answer here then explaining it
19:43:28 <benmachine> Teja: you shoudl use type annotations, like:
19:43:30 <Axman6> Teja: does that code i showed you make sense?
19:43:34 <aavogt> and given the way that Data.Map is going, polymorphism regarding empty values isn't that popular?
19:43:34 <benmachine> safeHead :: [a] -> Maybe a
19:43:44 <Teja> Axman6: your sample worked good
19:43:48 <benmachine> before you define safeHead
19:43:55 <Axman6> Teja: do you understand why?
19:44:02 <benmachine> if you work out what types you need where then it makes your life easier
19:44:13 <benmachine> and the compiler has to guess less
19:44:23 <Teja> but I think i lost the type of the element.. isn't it?
19:44:24 <pikhq> Teja: BTW, you may find this a helpful read: http://catb.org/esr/faqs/smart-questions.html
19:44:46 <Axman6> Teja: you're supposed to take a list of a's, and return a Maybe a right?
19:44:49 <pikhq> (has little to do with Haskell, and is a bit tangential, but that's beside the point)
19:45:15 <Teja> Axman6: May be I am not able to explain my problem properly
19:45:23 <Teja> Here is what I want
19:45:30 <Teja> if the list is empty return Nothing
19:45:42 <Teja> or return the first element of the list
19:45:43 <Axman6> Teja: i think what you want is not possible
19:45:45 <dobblego> safeHead = listToMaybe
19:45:48 <Teja> oh ok
19:46:01 <dobblego> @type listToMaybe
19:46:02 <lambdabot> forall a. [a] -> Maybe a
19:46:14 <benmachine> Teja: haskell's type system is strict, so what you return has to always be the same type
19:46:16 <Axman6> you _need_ to return a Maybe a. you can't have it return a Maybe a and an a
19:46:18 <mike-burns> Teja: To see why, try to express the type of the function you want.
19:46:26 <pikhq> @src listToMaybe
19:46:26 <lambdabot> listToMaybe []        =  Nothing
19:46:26 <lambdabot> listToMaybe (a:_)     =  Just a
19:46:40 <Teja> Nothing can be any type... thats what I thought
19:46:45 <benmachine> no
19:46:51 <benmachine> Nothing is type Maybe a
19:46:52 <benmachine> :t Nothing
19:46:53 <dobblego> @type Nothing
19:46:54 <lambdabot> forall a. Maybe a
19:46:55 <lambdabot> forall a. Maybe a
19:46:56 <kniu> Quick question
19:46:58 <pikhq> Teja: No, Nothing is exactly one type. Maybe a.
19:47:08 <kniu> Can GHC compile haskell core from an external file?
19:47:09 <Teja> ok... now I got it
19:47:15 <Axman6> Teja: so the type of safeHead [] = Nothing is safeHead :: [a] -> Maybe b, and the type of safeHead (x:_) = x is safeHead :: [a] -> a
19:47:41 <Teja> excellent
19:47:41 <aavogt> unify!
19:47:53 <Teja> thanks guys for your help and time
19:48:10 <Teja> Axman6: Thank you verymuch
19:48:14 <Axman6> Teja: soon you'll see that this strict typing is very powerful
19:48:25 <Axman6> no worries. stick around and keep asking questions :)
19:48:39 <Teja> I am actually from javaworld and new to haskell
19:48:53 <Teja> so still struggling with basics
19:49:03 <Axman6> well, haskell will take some getting use to :)
19:49:43 <Axman6> but a lot of haskell ideas can be used quite effectively in java (generics was introduced to java by some haskell people i believe)
19:50:11 <mike-burns> Teja: One thing that may help as you learn Haskell is that there is no magic going on anywhere.
19:50:24 <mjrosenb> but a whole lot of syntatic sugar
19:50:33 <mjrosenb> that you won't need to know about for a while
19:51:27 <Axman6> Teja: may i suggest you try another tutorial? i'm not so sure that RWH is the best beginner tutorial. you should check out learny ou a haskell for great good:
19:51:30 <Axman6> @where lyah
19:51:31 <lambdabot> www.learnyouahaskell.com
19:51:35 <Axman6>      ^^^^
19:51:38 <pikhq> There's two sorts of things in Haskell: things you understand and magic. For the experienced Haskeller, there is no magic.
19:51:42 <pikhq> :P
19:52:20 <benmachine> the trouble I had with lyah is it took a very long time to get a program out of it
19:52:20 <dbpatterson> I'm getting an error that a module is found in multiple packages, and for this reason it can't be loaded
19:52:21 <Axman6> learn*, not leanry :S
19:52:23 <dbpatterson> any way around that?
19:52:37 <benmachine> dbpatterson: I had this earlier today
19:52:41 <SamB_XP_> pikhq: eh.
19:52:45 <benmachine> apparently you use ghc-pkg to hide one of them
19:52:48 <mike-burns> pikhq: I had that attitude when I tried learning it the first time, and that slowed me down. When I realized that >>= is just a function, and that do notion is just syntax around >>=, and other such things, everything clicked into place.
19:52:49 <Axman6> dbpatterson: you can use ghc-pkg unregister on one of the packages
19:52:49 <SamB_XP_> the magic is the stuff you don't understand yet
19:52:52 <kniu> Currently (as of version 6.8.2), GHC does not have the ability to read in External Core files as source. If you would like GHC to have this ability, please make your wishes known to the GHC Team.
19:52:56 <SamB_XP_> or the stuff you claim you are going to write
19:53:02 <kniu> does GHC 6.10 have this ability?
19:53:11 <SamB_XP_> ... or just the stuff you don't want to explain at the time
19:53:17 <benmachine> Axman6: I used ghc-pkg hide
19:53:22 <Axman6> or that
19:53:23 <benmachine> is there any relevant difference
19:53:29 <Axman6> no idea
19:53:35 <benmachine> neat
19:53:38 <dbpatterson> is there any way of doing that on a per file basis?
19:53:39 <Axman6> i just know haskell, ot ghc ;)
19:53:46 <Axman6> n*
19:53:57 <SamB_XP_> kniu: I dunno ... you might have to try it
19:53:57 <aavogt> unregister means that the library can't be used if explicitly asked for with -package foo
19:54:09 <SamB_XP_> I think the way it would work should be in the manual
19:54:19 <SamB_XP_> the question is whether or not it will
19:54:23 <kniu> No manual entry for ghc
19:54:31 <benmachine> @pl flip f x y = f y x
19:54:32 <lambdabot> flip = flip
19:54:36 <benmachine> heh
19:54:46 <pikhq> mike-burns: What I was trying to say is "It only seems like magic until you grok it."
19:54:51 <kniu> there really should be a ghc man-page.
19:55:07 <Axman6> there is one...
19:55:11 <Axman6> i've got it
19:55:16 <SamB_XP_> pikhq: the experienced haskeller might not grok nearly as much as you think
19:55:19 <Axman6> maybe your manpath isn't set correctly
19:55:21 <SamB_XP_> at least, not all at the same time
19:55:36 <mike-burns> pikhq: Ah, you mean "Any sufficiently advanced technology is indistinguishable from magic"?
19:55:38 <benmachine> when I asked my lambdabot the same question I got
19:55:41 <benmachine> flip = id (fix (const flip))
19:55:46 <pikhq> mike-burns: In a way.
19:55:46 <benmachine> which I guess works
19:56:08 <mike-burns> pikhq: I still maintain that it's an attitude that makes it hard to learn.
19:56:16 <Axman6> @free flip
19:56:18 <lambdabot> (forall x. h . k x = p (f x) . g) => h . flip k y = flip p (g y) . f
19:56:20 <dilinger> heh
19:56:20 <dilinger> Prelude>  :q
19:56:20 <dilinger> Leaving GHCi.
19:56:29 <dilinger> that was.. unintentional and quite unexpected
19:56:34 <benmachine> Axman6: what on earth is that
19:56:41 <Axman6> @free map
19:56:43 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
19:56:55 <dilinger> let's hear it for the vi haskellers
19:56:56 <Axman6> um, gives you free theorums
19:57:01 <benmachine> oh right
19:57:11 <Axman6> dilinger: :help for more
19:57:12 <pikhq> Abuh?
19:57:25 <SamB_XP_> magic is just that which you can't be bothered to understand at the moment ;-)
19:57:35 <Axman6> @free head
19:57:36 <lambdabot> f . head = head . $map f
19:57:39 <SamB_XP_> which might be because it's really messy ...
19:57:40 <mike-burns> Ha
19:57:48 <dilinger> Axman6: no, see, it was a.. ah, nevermind.
19:57:49 <SamB_XP_> or because it involves math that's over your head ...
19:57:54 <strathhelp> what's the syntax for hiding functions in the prelude, I have this             import Prelude hiding (Left)              but isn't working
19:58:07 <benmachine> Axman6: is there a list of these or does it work them out somehow?
19:58:12 <SamB_XP_> but it might just be because you're busy figuring something else out
19:58:14 <Axman6> no idea :)
19:58:45 <SamB_XP_> benmachine: it works things out
19:58:52 * benmachine impressed
19:58:56 <SamB_XP_> there is basically a list of rewrite rules
19:59:15 <SamB_XP_> and I don't really know how it can tell whether it's making progress or not ...
19:59:45 <pikhq> SamB_XP_: Exemption: Perl's usage of the word 'magic'. Perl is, in fact, 100% magic to all involved (except maybe Larry Wall). :P
20:00:15 <benmachine> I wouldn't describe perl as sufficiently advanced technology
20:00:47 <SamB_XP_> benmachine: that's why they've come up with an even more complicated system for Perl 6 ;-)
20:01:06 <benmachine> hah
20:01:18 <mike-burns> If I remember correctly from my Perl days, there was a call to rand() in Perl's parser.
20:01:30 <SamB_XP_> mike-burns: wow
20:01:32 <SamB_XP_> that's FREAKY
20:01:40 <coCocoa> strathhelp: Just curious, but what does it say is the problem? :)
20:01:40 <jdrake> Without having a ghc source tree, is it possible to get the testsuite? The relevant page seems to say ./darcs-all --testsuite get  but I definitely wouldn't have darcs-all
20:01:44 <pikhq> Not surprising.
20:01:55 <SamB_XP_> jdrake: it's possible
20:01:56 <mike-burns> Luckily it never became a problem. Somehow.
20:02:04 <QPlaty[HireMe]> mike-burns: Not in the parser, but there is one in the hash code.
20:02:04 <pikhq> SamB_XP_: Another fun bit: Perl cannot be statically parsed. ;)
20:02:30 <SamB_XP_> jdrake: just poke around for it on darcs.haskell.org, I guess
20:02:38 <jdrake> shall do
20:02:39 <strathhelp> coCocoa: Sorry, I'm an idiot it's working now, a problem elsewhere was the problem
20:02:40 <SamB_XP_> like, you could read darcs-all
20:02:51 <inimino> pikhq: I've never been sure that's such a bad idea
20:02:55 <mike-burns> QPlaty[HireMe]: Ah, that must be what I was thinking of.
20:03:03 <coCocoa> strathhelp: Okay. If you need more help, just call. :)
20:03:15 <SamB_XP_> jdrake: not sure how much use it will be in isolation
20:03:23 <jdrake> SamB_XP_: We shall see
20:03:44 <QPlaty[HireMe]> mike-burns: Its there to prevent a class of securaty exploit.
20:03:48 <SamB_XP_> you may have to write your own harness, or at least add a lot of duct tape and possibly chewing gum to what's there
20:04:09 <aavogt> what, Identity doesn't have an Applicative instance?
20:04:18 <pikhq> QPlaty[HireMe]: o.O
20:04:56 <SamB_XP_> QPlaty[HireMe]: what class?
20:05:11 <FunctorSalad_> aavogt: Gen neither :/
20:05:12 <SamB_XP_> also, in what situation does the hash code call rand()?
20:05:27 <FunctorSalad_> it sucks because your code will break once it does have an instance in teh library
20:05:32 <copumpkin> seems like a hash call that involves rand wouldn't be a hash :P
20:05:50 <SamB_XP_> well, guys, I'm afraid not having an Applicative instance isn't the bug that not having a Functor instance is
20:06:08 <FunctorSalad_> ?
20:06:17 <QPlaty[HireMe]> copumpkin: We are talking about perl's assosative arrays/maps which in perl parlence are called hashes.
20:06:21 <gwern> man, 570M is not enough free space to compile highlighting-kate
20:06:23 <gwern> yeesj
20:06:25 <copumpkin> oh
20:06:53 <Axman6> gwern: i had the same problem with ghc :(
20:06:54 <SamB_XP_> well, if you find a missing Functor instance (for something that has a Monad instance), you are 100% justified in reporting a bug about it
20:07:09 <QPlaty[HireMe]> It is to undermine timing attacks which work out the contents currently in the hash by timeing how long inserts take.
20:07:22 <gwern> Axman6: one would hope some syntax highilighting would be less intensive than an advanced optimizing FP compiler!
20:07:26 <SamB_XP_> I mean, I found one or two in Q
20:07:29 <FunctorSalad_> SamB_XP_: reporting a bug seems like excessive red tape for such a trivial thing
20:07:50 <Axman6> well, ghc didn't seem to need much more space than 600MB ;)
20:07:52 <SamB_XP_> FunctorSalad_: excessive red tape ... how else do you get it fixed ?
20:08:01 <FunctorSalad_> SamB_XP_: send in a patch?
20:08:01 <gwern> yellow caution tape
20:08:19 <SamB_XP_> okay, maybe a little excessive
20:08:21 <copumpkin> FunctorSalad_: bug reports are still handy to keep track of what was fixed
20:08:32 <pikhq> QPlaty[HireMe]: Ah. Makes sense.
20:08:43 <pikhq> Bit silly, but eh.
20:08:51 <copumpkin> seems like it'd still leak information
20:08:57 <FunctorSalad_> I never tried actually sending in a patch to something like base, would it be accepted?
20:08:58 <copumpkin> you want inserts taking a constant amount of time :P
20:09:02 <SamB_XP_> but then again, what if the library in question was bundled with GHC and you are too lazy to check out GHC just to fix one little thing like that?
20:09:09 <copumpkin> not some uniformly distributed amount of time around the real time
20:09:24 <gwern> FunctorSalad_: no way, people will bikeshed you to death
20:09:30 <gwern> witness my recent attempt with 'ignore'
20:09:32 <SamB_XP_> plus, libraries@ does mandate a small amount of tape
20:09:34 <FunctorSalad_> nooo :(
20:09:45 <SamB_XP_> not sure what color of tape libraries@ mandates, though
20:10:02 <copumpkin> l think it's yellow
20:10:02 <gwern> SamB_XP_: invisible pink
20:10:10 <FunctorSalad_> monadic steel blue
20:10:22 <SamB_XP_> gwern: if itÅ› to add a missing Functor instance for something that has a Monad instance, I'm sure they'd *take* it
20:10:37 <SamB_XP_> er ... that was supposed to be it's
20:10:41 <FunctorSalad_> yes, the good thing about these instances is that there's no bikeshedding
20:10:48 <FunctorSalad_> fmap = liftM
20:10:51 <pikhq> SamB_XP_: Turing-colored.
20:10:56 <pikhq> Also, your deadkeys are showing.
20:10:59 <FunctorSalad_> pure = return; (<*>) = ap
20:11:12 <SamB_XP_> yeah, missing should-be-a-superclass instances are thankfully bikeshed-proof
20:11:20 <SamB_XP_> pikhq: wasn't a dead key
20:11:28 <SamB_XP_> well, sort of was, I guess
20:11:44 <SamB_XP_> I just accidentally switched keyboard layouts to "US International"
20:11:59 <pikhq> So your dead key was showing.
20:12:01 <pikhq> ;)
20:13:19 <mmmulani> what do I import to use unsafePerformIO?
20:13:37 <copumpkin> @index unsafePerformIO
20:13:37 <aavogt> why do you need it?
20:13:37 <lambdabot> System.IO.Unsafe, Foreign
20:13:53 <mmmulani> aavogt: I want to print out the progress of a recursive function
20:14:01 <copumpkin> use Debug.Trace
20:14:07 <mmmulani> ouu
20:14:13 <copumpkin> which just does that behind the scenes :P
20:14:19 <copumpkin> but reminds you it's for debugging only :P
20:14:27 <SamB_XP_> yeah, it calls unsafePerformIO so you won't have to
20:14:34 <aavogt> @index trace
20:14:34 <lambdabot> Debug.Trace
20:14:44 <SamB_XP_> but it might do other things too, like making sure to flush the handle or something
20:14:48 <aavogt> hmm, wasn't it in Test.Trace though?
20:14:55 <FunctorSalad_> @src trace
20:14:55 <lambdabot> trace string expr = unsafePerformIO $ do
20:14:56 <lambdabot>     hPutStrLn stderr string
20:14:56 <lambdabot>     return expr
20:15:01 <copumpkin> never heard of Test.Trace
20:15:12 <pikhq> mmmulani: unsafePerformIO is rarely the answer. ;)
20:15:13 <SamB_XP_> aavogt: hmm, I think it did get moved from somewhere else
20:15:16 <SamB_XP_> but I forget where
20:15:27 <SamB_XP_> pikhq: well, it was in this case
20:15:44 <copumpkin> mmmulani: if you want something more permanent, you might use Writer for logging
20:15:51 <SamB_XP_> but thankfully we have cheating down to a skill, so you can just steal the answer from someone else
20:16:07 <mmmulani> aavogt, copumpkin: thanks, this is working just as I hoped :P
20:16:14 <copumpkin> :)
20:16:17 <copumpkin> but do consider writer!
20:16:17 <copumpkin> ;)
20:16:19 <aavogt>  :)
20:16:41 <SamB_XP_> yeah, writer is great for writing a lint-y sort of program
20:17:17 <SamB_XP_> it can even output the problems it finds as it finds them
20:17:29 <SamB_XP_> without actualy entangling the computation in IO
20:17:45 <mmmulani> ouuuu
20:18:06 <mmmulani> how can I access functions from a file in ghci when I have a main function?
20:18:31 <SamB_XP_> mmmulani: sure ... one thing you might want to do is
20:18:48 <SamB_XP_> module Main (module Main) where
20:19:10 <aavogt> SamB_XP_: what do you mean by as it finds them?
20:19:50 <SamB_XP_> aavogt: I mean, you can pull the writer's output out lazily, if you use the right Monoid
20:20:00 <aavogt> I see
20:21:15 <SamB_XP_> I did one for the adventure game within the lovely puzzle game found on boundvariable ... dot org?
20:21:36 <SamB_XP_> @go boundvariable
20:21:37 <lambdabot> http://en.wikipedia.org/wiki/Free_variables_and_bound_variables
20:21:37 <lambdabot> Title: Free variables and bound variables - Wikipedia, the free encyclopedia
20:21:42 <SamB_XP_> @go boundvariable icfp
20:21:44 <lambdabot> http://boundvariable.org/press/tr-06-163.pdf
20:21:44 <lambdabot> Title: The Cult of the Bound Variable: The 9 Annual ICFP Programming Contest
20:21:53 <SamB_XP_> yeah, .org it is
20:23:45 <gwern> what the heck
20:23:52 <gwern> why is my twitter account being followed by 11 people
20:23:56 <gwern> apparently all haskellers
20:24:33 <SamB_XP_> gwern: oh, good, I was gonna say "spammers"
20:24:46 <SamB_XP_> that's who usually follows mine
20:25:05 <SamB_XP_> though maybe that's because I tweet so rarely and share the URL with so few
20:26:49 <aavogt> isn't that the point of twitter?
20:27:16 <SamB_XP_> what, spamming, or forgetting to tweet?
20:27:27 <mmorrow> copumpkin: finally got the logistics sorted wrt generating the "asm", so the only part left (to have a minimally working system) is to do some obvious copy propogation, redundancy elim, reorder instructions so register alloc is possible, then touch up the gc and interp function to account for the few mods i made/am making to the bytecodes
20:28:00 <mmorrow> copumpkin: here's some random generated code (part of which includes some stuff with those huge "Vec" datatype from that fft thing http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2972#a2973
20:30:49 <troutwine> There's an Arbitrary instance for String, but is there one for ByteString?
20:32:58 <FunctorSalad_> troutwine: pack <$> arbitrary -- ?
20:33:52 <troutwine> FunctorSalad_: That's what I've got now; just wondering, mostly.
20:33:55 <troutwine> Thanks though.
20:39:23 <FunctorSalad_> shrink = map pack . shrink . unpack
20:39:26 <FunctorSalad_> :)
20:39:48 <FunctorSalad_> base change ftw
20:45:18 <copumpkin> mmorrow: cool! so that's a large autogenerated FFT outputting your bytecode?
20:47:39 <copumpkin> or rather, a large fft in your bytecode :)
20:47:42 <aavogt> @quote visual.basic
20:47:42 <lambdabot> syntaxfree says: Functional programming has finally arrived to the masses. Its name is not Lisp, ML or Haskell: it's Visual Basic
20:48:04 <Adamant> I though the Excel VBA language was technically functional
20:48:36 <copumpkin> I still don't know what a formal definition of functional is... I have a "feeling" for it
20:48:37 <SamB_XP_> I think he was quoting a JFP paper about Haskell history and VB.NET
20:48:57 <aavogt> so if I cannot convince somebody to write something in Haskell, VB is the next best thing?
20:49:11 <Adamant> I know Eric Meijer is adding lots of FP-type stuff for VB.net
21:12:54 <copumpkin> seems like if things go well, STM will be a misnome
21:12:54 <copumpkin> r
21:15:46 <Cale> copumpkin: misnomer?
21:16:17 <ray> incorrect nomer
21:16:39 <copumpkin> well, ideally we'd get hardware support, and then we'd just have TM, possibly with an S back-end or, if you're lucky (and rich) an H back-end
21:18:11 <Cale> Well, yeah, the S part isn't really important. :)
21:18:29 <copumpkin> I know!
21:18:37 <copumpkin> but what if we get left behind
21:18:45 <copumpkin> and we get stuck with an S that no longer belongs in 10 years!
21:18:55 <Cale> Actually, it would have been nicer to have named it TM
21:19:37 <coCocoa> Mmm...Transactional Meditation! ;)
21:19:56 <ray> i don't think we should name things, in case any part of the name becomes obsolete
21:20:04 <copumpkin> ray: good idea!
21:20:49 <aavogt> STM (TM)
21:20:59 <ray> â„¢
21:21:03 <zebrafinch> ray: time to make a pointfree conlang?
21:21:13 <ray> it's probably well past time
21:21:34 <aavogt> tm is taken with trademark
21:24:15 <copumpkin> > (\_ -> 1) ([undefined])
21:24:16 <lambdabot>   1
21:24:32 <copumpkin> > (\_ -> 1) undefined
21:24:34 <lambdabot>   1
21:25:10 <copumpkin> I'm having doubts about how putStrLn "moo" >> putStrLn "baa" ever happens
21:25:29 * copumpkin feels like a n00b all over again :D
21:25:56 <aavogt> copumpkin: #RealWorld ?
21:26:07 <copumpkin> oh yeah :)
21:26:18 <copumpkin> it has no hash though, iirc
21:26:26 <aavogt> the fact that main gets executed is magic
21:26:31 <copumpkin> alright, drop my doubts
21:26:37 <aavogt> maybe its RealWorld#
21:26:45 <copumpkin> it's the state monadishness
21:26:50 <copumpkin> I still don't think it has a hash
21:27:12 <copumpkin> although there is the realWorld# thingy that's undocumented
21:37:48 <thoughtpolice> copumpkin: more like the hack that is IO
21:37:49 <thoughtpolice> :)
21:38:03 <ray> IO isn't real anyway
21:38:37 <ray> every haskeller should be issued an intern to write the IO for them
21:38:40 <roconnor> @quote spoon
21:38:40 <lambdabot> simonpj says: If you put a spoonful of sewage into a vat of wine, what do you have? A vat of sewage.
21:39:36 <roconnor> not the quote I was expecting
21:39:44 <roconnor> is he talking about side effects?
21:39:47 <ray> that's disgusting, true, and relevant
21:40:03 <ray> well, i assume
21:40:46 <jdrake> no no, a spoonful of sewage into a vat of fresh pelee island wine, you get high quality french.
21:41:32 <pikhq> thoughtpolice: IO doesn't feel like a hack.
21:41:57 <pikhq> It feels like discussing the invisible pink unicorn.
21:42:15 <SamB_XP> pikhq: there's a bit of each
21:42:19 <ray> when all our interns see how great haskell is and become haskellers themselves, we might have a problem
21:42:37 <aavogt> Haskell interns?
21:42:39 <roconnor> ray how so?
21:42:46 <pikhq> ray: I'm an intern and a (noob) Haskeller; what's that make me?
21:43:08 <roconnor> everyone is a noob Haskeller
21:43:12 <roconnor> ... except for Oleg
21:43:25 <shachaf> A sewage-handling wine enthusiast?
21:43:25 <roconnor> and maybe one of the Simons
21:43:28 <SamB_XP> I think SPJ may be underestimating the powers of wine, yeah
21:43:46 <SamB_XP> roconnor: is it always the same one?
21:44:08 <ray> roconnor: we'll run out of interns
21:44:41 <roconnor> SamB_XP: only a super position of sqrt(2) of each simon isn't
21:44:44 <SamB_XP> ray: you could hire bussiness interns?
21:45:09 <ray> once the haskell chain reaction starts, it won't stop
21:45:19 <thoughtpolice> roconnor: it's funny how whenever I see people post links to crazy type system stuff, I almost always know who it is by :)
21:45:24 <ray> everyone on the planet will end up a haskeller, and we'll have to write our own IO
21:46:07 <pikhq> ray: Except that with everyone a Haskeller, there will cease to be IO.
21:46:23 <pikhq> Instead there will only be function return values.
21:46:25 <SamB_XP> ray: I think the hope is that we'll have split up IOs duties more sensibly
21:46:31 <ray> i don't want to be passed as a parameter
21:46:33 <SamB_XP> we may even have abandoned monads almost entirely
21:46:41 <soupdragon> nah
21:46:44 <pikhq> SamB_XP: Doubtful.
21:46:52 <SamB_XP> it's hard to say
21:46:59 <soupdragon> you're writing science fiction
21:47:01 <pikhq> Given that functions are monads and we like our pure functions.
21:47:17 <ray> functions are a monad*
21:47:18 <SamB_XP> I meant, we might not use that as our abstraction for IO anymore
21:47:26 <pikhq> Oh.
21:47:31 <SamB_XP> not that the there won't be a ton of things we use that form Monads
21:47:32 <ray> yeah, that's more likely
21:47:36 <pikhq> That's something quite different.
21:47:36 <aavogt> FRP?
21:48:10 <copumpkin> I don't really use the monad ((->) a) instance except when I'm golfing, but I use the applicative a lot
21:48:32 <aavogt> @quote golf
21:48:33 <lambdabot> No quotes match. Take a stress pill and think things over.
21:48:42 <SamB_XP> funny
21:49:02 <aavogt> yep, even the quotes were golfed
21:49:10 <ray> liftAn for functions is useful
21:54:51 <lamdk> geez why is there so many people in here
21:55:05 <jeffwheeler> @users
21:55:06 <lambdabot> Maximum users seen in #haskell: 658, currently: 575 (87.4%), active: 15 (2.6%)
21:55:09 <lamdk> people use haskell outside of their programming languages class at school?
21:55:16 <jeffwheeler> Yes, and love it.
21:55:23 <lamdk> for wut
21:55:24 <Elly> I use software written in haskell daily
21:55:27 <Elly> namely darcs :)
21:55:34 <mike-burns> lamdk: I use Haskell for writing programs.
21:55:36 <jeffwheeler> (I wish I was taught Haskell at school . . .)
21:55:45 <ray> i use haskell for fun and profit
21:55:56 <jeffwheeler> I just use it for fun.
21:56:18 <ray> i don't actually profit either, but i could
21:57:12 <pikhq> lamdk: My school's classes uses C++.
21:57:41 <pikhq> Which is only faintly tolerable because they don't make me do idiomatic C++. :P
21:57:43 <lamdk> this channel is like rank 7 in terms of users right now out of like 5000 O_O
21:58:02 <jeffwheeler> Great!
21:58:08 <lamdk> i had a lab for like 2 weeks, and we had to sort lists of numbers with haskell
21:58:13 <jeffwheeler> If we were just the seventh most popular language, that'd be great, too.
21:58:15 <lamdk> and i thought it was weird -_-
21:58:24 <pikhq> ... 2 weeks for sorting?
21:58:35 <mike-burns> Sorting lists in Haskell is weird?
21:58:35 <pikhq> Even merge sort's only like 5 lines.
21:58:42 <pikhq> And that's if you count the merge function.
21:58:58 <lamdk> http://www.ics.uci.edu/~thornton/cs141/LabManual/Assignment3/
21:58:59 <lamdk> :D
21:59:36 <jeffwheeler> Hugs? This must be _really_ old.
21:59:42 <pikhq> And of course, the venerable quicksort is two lines.
22:00:17 <Elly> IIRC, the two-line quicksort is not actually very quick
22:00:30 <pikhq> Elly: Yeah.
22:00:59 <ray> it's just a pivoting sort really
22:01:01 <jeffwheeler> But show me a two-line sort in C, even if it's ridiculously slow.
22:01:16 <mike-burns> LOC is an irrelevant metric.
22:01:30 <jeffwheeler> Sure, and that's why you wouldn't really use that for sorting.
22:01:36 <jeffwheeler> But as an example for showing off Haskell?
22:01:42 <jeffwheeler> (. . . and how beautiful it is.)
22:01:43 <Elly> jeffwheeler: C has the excellent semicolon operator for this purpose :)
22:01:52 <ray> HASKELL DOES TOO
22:01:59 * ray preemptive
22:04:32 <pikhq> Elly: C also has the , operator.
22:04:59 <pikhq> And for really screwy (GNU-only)code, ({ }).
22:05:07 <Elly> yep
22:05:32 <pikhq> Shame I don't have my one line of obfuscated bubble sort around.
22:06:16 <Berengal> Every time I've tried to write bubble-sort in haskell it's turned into insertion sort...
22:06:43 <copumpkin> need moar bubblz
22:07:03 * copumpkin loves contributing to intellectual conversations
22:07:45 <QPlaty[HireMe]> Berengal: You would need mutable arrarys
22:07:49 <aavogt> yeah, it ends up being an insertion sort, if you end up putting the multiple passes into a fold
22:08:18 <aavogt> QPlaty[HireMe]: I don't think so
22:08:33 <QPlaty[HireMe]> aavogt: For a classic bubble sort?
22:08:36 <Berengal> QPlaty[HireMe]: I think you just need a bit of state
22:08:48 <aavogt> @type until
22:08:50 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
22:09:07 * sjanssen thinks the fact that bubble sort isn't obvious in Haskell is a feature, not a bug
22:09:25 <Berengal> sjanssen: Ditto
22:10:29 <Botje> @faq is it possible to write FORTRAN in Haskell?
22:10:30 <lambdabot> The answer is: Yes! Haskell can do that.
22:10:41 <Botje> that should've been Haskell programmers. boo :)
22:11:19 <aavogt> > let bubble (x:y:ys) | x > y = y:bubble (x:ys) | otherwise = x:bubble (y:ys); bubble x = x; sorted = and . ap (zipWith (>)) tail in until sorted bubble $ reverse [1..10]
22:11:21 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
22:11:35 <aavogt> > let bubble (x:y:ys) | x > y = y:bubble (x:ys) | otherwise = x:bubble (y:ys); bubble x = x; sorted = and . ap (zipWith (<=) tail in until sorted bubble $ reverse [1..10]
22:11:37 <lambdabot>   <no location info>: parse error on input `in'
22:11:46 <aavogt> > let bubble (x:y:ys) | x > y = y:bubble (x:ys) | otherwise = x:bubble (y:ys); bubble x = x; sorted = and . ap (zipWith (<=)) tail in until sorted bubble $ reverse [1..10]
22:11:47 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
22:12:02 <aavogt> > let bubble (x:y:ys) | x > y = y:bubble (x:ys) | otherwise = x:bubble (y:ys); bubble x = x; sorted = and . ap (zipWith (<=)) tail in until sorted bubble "hello?"
22:12:04 <lambdabot>   "?ehllo"
22:13:24 <aavogt> I think that's a pretty clear formulation of the bubble sort, no?
22:14:09 <Berengal> Appart from some minor fuzziness in the sorted function, yeah
22:14:33 <aavogt> yeah, that one would be done explicitly
22:17:04 <Berengal> > let insert x [] = x; insert x (y:ys) | x < y = x:y:ys | otherwise = y:insert x ys in foldr insert [] [5,4,7,8,2,34,5,6]
22:17:06 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
22:17:31 <coCocoa> > let bubble (x:y:ys) | x > y = y:bubble (x:ys) | otherwise = x:bubble (y:ys); bubble x = x;sorted = ap (==) sort in until sorted bubble "hello?"
22:17:33 <lambdabot>   "?ehllo"
22:17:41 <coCocoa> Cool. :)
22:18:25 <coCocoa> > let insert x [] = [x]; insert x (y:ys) | x < y = x:y:ys | otherwise = y:insert x ys in foldrinsert [] [5,4,7,8,2,34,5,6]
22:18:27 <lambdabot>   Not in scope: `foldrinsert'
22:18:32 <Berengal> > let insert x [] = [x]; insert x (y:ys) | x < y = x:y:ys | otherwise = y:insert x ys in foldr insert [] [5,4,7,8,2,34,5,6]
22:18:33 <lambdabot>   [2,4,5,5,6,7,8,34]
22:18:33 <sjanssen> aavogt: you do some redundant comparisons
22:19:07 * Berengal thinks the insert sort is somewhat clearer than the bubble sort
22:19:17 <sjanssen> aavogt: most bubble sorts will work with n, n-1 ... elements of the input at a time
22:19:39 <Berengal> Well, unless you don't know foldr...
22:19:48 <aavogt> so there's no need to use 'until sorted'?
22:20:06 <aavogt> I guess it depends on how frequently the input is mostly sorted to begin with...
22:20:39 <aavogt> though checking sortedness after each bubbling can't be efficient
22:20:49 <sjanssen> aavogt: I think most bubble sorts will combine the bubbling pass with the 'is sorted' pass
22:20:56 <Berengal> aavogt: You could check sortedness during the bubbling
22:21:39 <Berengal> just '| x > y = (y:bubble x:ys, False)'
22:21:46 <Berengal> Or something like that
22:25:26 <nornagon> http://mythryl.org/ interesting.
22:26:22 <copumpkin> > fmap (+1) (1, 4)
22:26:23 <lambdabot>   (1,5)
22:27:40 <copumpkin> it'd be nice if it were easier to make a fixpoint of a type like that without going through a newtype
22:27:50 <copumpkin> if I just wanted an infinitely nested tuple
22:28:10 <soupdragon> nornagon, why
22:28:35 <Cale> copumpkin: But if you just allow infinite types, there are a lot of easy bugs which can't be caught
22:28:39 <elliottt> anyone know why Foldable is a requirement on Traversable?
22:29:36 <copumpkin> Cale: hrm, I guess... but maybe something in between that would allow for easy infinite types if you explicitly ask for them, without the added noise of InF and outF and things like that you get with Mu
22:29:38 <nornagon> soupdragon: why not?
22:29:46 <soupdragon> nornagon, k
22:29:57 <copumpkin> epicly profound discussion
22:31:36 <elliottt> i mean, there's nothing in the default definitions of Traversable that uses Foldable
22:32:36 <soupdragon> 'something in between' -- I don't think anything between exists
22:34:17 <copumpkin> soupdragon: why not allow a cycle in type synonym declarations, for example
22:34:33 <copumpkin> possibly with an additional flag
22:34:51 <copumpkin> that'd be me saying "yeah, I know I want this to be infinite"
22:35:18 <copumpkin> (but I don't want to have to slap newtype constructors and accessors whenever I play with my infinite type)
22:35:29 <soupdragon> I woner how to implement that
22:35:36 <soupdragon> like having,
22:35:55 <copumpkin> currently it has a specific error message for it, so it clearly recognizes the situation
22:36:05 <soupdragon> x :: Loop; x = (1,x) -- that type check
22:36:14 <soupdragon> x = (1,x) -- type error
22:36:33 <soupdragon> so what about,
22:36:34 <copumpkin> yeah, I guess that would be a little ugly, but there are already situations in which that occurs
22:36:43 <copumpkin> not quite the same kind of type error, granted
22:36:49 <soupdragon> x = (1,x :: Loop) -- type error or not?
22:36:54 <copumpkin> ack :P
22:37:05 <soupdragon> interesting idea
22:38:19 <copumpkin> I've just been playing with recursion schemes and am getting frustrated with the extra noise of the various newtypes that must be added to appease the typechecker
22:38:57 <soupdragon> what about turing off types completely?
22:39:02 <copumpkin> :o
22:39:35 <copumpkin> how so?
22:39:42 <copumpkin> the gradual typing kind of thing?
22:39:46 <copumpkin> or unsafeCoerce everywhere? :P
22:39:48 <soupdragon> no
22:39:55 <ray> a notype declaration
22:40:01 <soupdragon> just not typechecking ainything
22:40:24 <copumpkin> :o
22:40:36 <copumpkin> but a lot depends on type knowledge
22:41:23 <ray> x :: TrustMe
22:41:27 <ray> and then it doesn't typecheck it
22:41:56 <copumpkin> anything involving it?
22:42:04 <ray> no typechecking
22:42:29 <ray> it becomes an innocent, trusting compiler
22:43:02 <copumpkin> lol
22:44:09 * soupdragon wonders why there isn't a LANGUAGE option for this in GHC
22:45:01 <copumpkin> > mapAccumR (\x y -> (x + y, x)) 0 [1..10]
22:45:03 <lambdabot>   (55,[54,52,49,45,40,34,27,19,10,0])
22:45:44 <copumpkin> soupdragon: haskell2010 proposal ;)
22:45:58 <copumpkin> {-# LANGUAGE Ruby #-}
22:46:48 <portnov> import Prelude hiding ((.))
22:46:48 <portnov> object . method = method object
22:46:51 <portnov> and so on )
22:49:52 <copumpkin> :P
22:50:22 <copumpkin> you'd presumably want that to be an implicit message send
22:50:29 <copumpkin> for ultimate dynamic behavior
22:51:14 <ray> ultimate dynamism
22:51:31 <copumpkin> real ultimate power
22:51:58 <ray> duck typing is just a feeble approximation to typeclasses anyway
22:52:50 <zebrafinch> Does GHC warn about non-exhaustive GADT matches even when the other GADT constructors are impossible based on the type?
22:53:00 <copumpkin> I think the recent boom of dynamic languages is because so many people's only experience of static typing is c(++) or java, and I don't blame them for feeling refreshed without all those explicit annotations
22:53:15 <copumpkin> zebrafinch: yeah, it can't decide which of them are possible
22:53:33 <ray> those languages don't even have static typing
22:53:56 <copumpkin> yeah
22:54:00 <ray> it all just makes you want to say "ha ha, mainstream language users, what a bunch of losers"
22:54:03 <ray> :P
22:54:08 <copumpkin> but when most people think of types
22:54:18 <copumpkin> the thought is "omg now I have to write all my types down"
22:54:48 <ray> if c was more static about typing, you could probably get some inference in there
22:55:17 <pikhq> If C were more static about typing, people would stop trying to cast pointers to ints and back.
22:55:46 <copumpkin> it has a type system but unsafeCoerce is a syntax element
22:55:53 <copumpkin> and is used everywhere
22:55:56 <zebrafinch> pikhq: C++0x includes some unholy attempt at type inference IIRC
22:56:04 <ray> "but pointers are ints because you can add to them, right?"
22:56:10 <pikhq> zebrafinch: "auto".
22:56:29 <pikhq> ray: HATE SO MUCH.
22:56:45 <pikhq> (I use AMD64; ints are half the size of pointers here. ;))
22:57:11 <dolio> They obviously aren't ints. There are no negative pointers.
22:57:40 <ray> so, entertainingly, it's the dynamic parts of C's type system that make what people think of as "static typing" (declarations everywhere) necessary
22:57:58 * pikhq giggles
22:59:17 * copumpkin goggles
23:11:38 <hackagebot> digest 0.0.0.6 - Various cryptographic hashes for bytestrings; CRC32 and Adler32 for now. (EugeneKirpichov)
23:19:07 <sully> How does foldl' work? Does it require serious hacks to implement?
23:19:44 * wmealing__ blinks
23:19:54 * pikhq blinks
23:20:03 <Berengal> Is seq considered a hack?
23:20:14 <copumpkin> @src foldl'
23:20:14 <lambdabot> foldl' f a []     = a
23:20:14 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
23:20:32 <copumpkin> I think seq is a bit of a hack
23:20:41 <sully> @src seq
23:20:41 <lambdabot> Source not found. Wrong!  You cheating scum!
23:20:43 <copumpkin> but I like it
23:20:56 * sully was not aware of seq
23:21:00 * sully is not aware of a lot of things
23:21:03 <aavogt> seq steals your free theorems
23:21:18 <aavogt> or is that bottom?
23:21:25 <Berengal> It's a small-ish hack. Not quite unsafePerformIO, but not completely pure either
23:21:43 <aavogt> @faq can I pretend that Haskell is bottomless?
23:21:44 <lambdabot> The answer is: Yes! Haskell can do that.
23:21:47 <copumpkin> as in, it could _mostly_ be implemented with a typeclass
23:21:52 <copumpkin> like NFData and rnf
23:21:55 <copumpkin> but not quite
23:22:05 <pikhq> And unlike unsafePerformIO.
23:22:26 <pikhq> (which takes everything pure about Haskell and smashes it to pieces)
23:22:55 <Berengal> copumpkin: you mean like 'instance Seq Int where seq 1 x = x; seq 2  x = x; [...]'?
23:23:46 <copumpkin> Berengal: basically :P but you wouldn't be able to Seq things which have no obvious constructors which could be a bit of a pain too
23:24:04 <mjrosenb> sully: how goes mozilla?
23:25:56 <Berengal> copumpkin: There are only a few magic contructor-less types. I think it's okay for those to have their own compiler-magic versions of seq, since they require compiler-magic to exist in the first place
23:26:20 <kayess> is there a channel for asking questions about functional programming in general?
23:26:34 <copumpkin> Berengal: maybe, yeah
23:26:46 <copumpkin> kayess: this one might work, depending on how general it is
23:26:57 <mjrosenb> kayess: you should be able to ask it here, or #sml or #scheme or #lisp
23:27:04 <mjrosenb> i assume that the last two exist
23:27:26 <dons> copumpkin: seq is unsatisfyingly magically polymorphic
23:27:46 <dons> we need a richer type system
23:27:50 <copumpkin> ah :)
23:27:52 <kayess> I was just wondering what the building block for a y combinator is -- I'm wondering if I have enough in a new FP I'm playing with
23:27:58 <copumpkin> yeah, I was proposing a Seq a => a -> b
23:28:09 <dons> sounds like Eval a => a -> b
23:28:17 <dons> from the Haskell 1.2 era
23:28:18 <copumpkin> but with the current type signature, it definitely couldn't be done in pure haskell
23:28:22 <copumpkin> ooh
23:28:24 <copumpkin> haven't seen that
23:28:44 <mjrosenb> dons: that type looks wrong
23:28:45 <sully> mjrosenb: it goes well! I'm making javascript 3% faster
23:29:02 <dons> check the pre-polymorphic seq reports. it was introduced as magically polymorphic because of the cost of refactoring to squash space leaks -- which introduced class constraints
23:29:03 <mjrosenb> sully: that's pretty impressive
23:29:05 <dblhelix> dons, copumpkin: Eval was banned from the language for good reasons
23:29:12 <dons> yep
23:29:15 <copumpkin> :o
23:29:23 <dons> bang patterns dun gone changed my types!
23:29:29 <copumpkin> lol
23:29:38 <Berengal> Hehehe
23:30:15 <ray> you make it sound like Eval was sealed away from the world like some kind of final boss
23:30:27 <copumpkin> cast into the flames of mount doom!
23:30:56 <kayess> @src fix
23:30:56 <dblhelix> it's a trade off: fully polymorphic seq is kind of weird
23:30:57 <lambdabot> fix f = let x = f x in x
23:30:57 <Berengal> ray: Sealed away, but not dead. It'll resurface again when Java 13 comes out
23:31:03 <dblhelix> for one thing, it breaks parametricity
23:31:05 <dons> well, maybe Eval was the good guy. polymorphic seq is the  ring of power.
23:31:08 <mjrosenb> ray: it will return when the hoards of perl coders are knocking at our gates
23:31:18 <dblhelix> fold/build fusion in ghc isn't safe because of seq
23:31:36 <dons> quite so. well, at least, it has more complicated side conditions
23:31:40 <copumpkin> speaking of fusion
23:31:46 <dons> ones that the current impl. doesn't check.
23:31:46 <copumpkin> I've completely neglected uvector recently :P
23:31:57 <dons> me too!
23:32:00 <dons> we should form a club
23:32:05 <mjrosenb> a `seq` b just forces a into whnf before b gets evaluated?
23:32:05 <Berengal> Lol
23:32:21 <copumpkin> hah :) I'll take a few days and clean up my tree and send you a patch so we can finally get a 0.2 out or something :P
23:32:47 <dblhelix> mjrosenb: well, that's the idea... but "before" is also a bit of an issue, given the way seq is defined in the Haskell 98 report
23:33:07 <mjrosenb> how is it defined?
23:33:09 <dblhelix> I guess that's what's set straight by pseq?
23:33:15 <dons> pseq guarantees before.
23:33:15 <Berengal> a `seq` b = b `seq` a `seq` b
23:33:32 <Berengal> Or at least, the compiler could rearrange things so that it is
23:33:42 <dblhelix> seq a b = _|_ if a = _|_, seq a b = b otherwise
23:33:54 <dons> 'seq' is strict in both its arguments
23:34:07 <dons> which means the compiler can rearrange them.
23:34:30 <dons> good for strictness, bad for enforcing sequentiality
23:34:40 <dblhelix> that is, if b diverges, seq a b may diverge without forcing a
23:34:51 <dons> so 'seq' is a bug in the H98 report wrt. multicore, in a way
23:34:53 <copumpkin> odd name for something bad for sequential
23:34:54 <mjrosenb> and _|_:_|_ != _|_
23:35:10 <dblhelix> mjrosenb: indeed
23:35:44 <dblhelix> (:) is lazy as are all data constructors modulo strictness flags in data types
23:35:47 <dons> pseq :: a -> b -> b
23:35:47 <dons> pseq  x y = x `seq` lazy y
23:36:02 <copumpkin> ah the infamous lazy function
23:36:06 <dons> par :: a -> b -> b
23:36:06 <dons> par  x y = case (par# x) of { _ -> lazy y }
23:36:23 <dblhelix> dons, how's lazy defined?
23:36:25 <dons> -- | The call '(lazy e)' means the same as 'e', but 'lazy' has a
23:36:25 <dons> -- magical strictness property: it is lazy in its first argument,
23:36:25 <dons> -- even though its semantics is strict.
23:36:25 <dons> lazy :: a -> a
23:36:25 <dons> lazy x = x
23:36:31 <dons> magic!!
23:36:43 <mjrosenb> ......
23:36:48 <dons> so now we have two kinds of magics.
23:36:48 <dblhelix> :-)
23:36:56 <copumpkin> there's also a magic inline function
23:37:10 <dblhelix> gotta love it
23:37:19 <dons> if we fire enough magic bullets, we'll hit the devil, right?
23:37:37 <dons> one of them has to be the silver bullet. keep looking!
23:37:46 <Beelsebob> dons: that's mean
23:37:48 * Beelsebob storms off
23:37:54 <copumpkin> to jdh?
23:38:09 <dons> he's a minor imp at best.
23:38:09 <copumpkin> poor Beelsebob
23:38:30 * copumpkin coaxes Beelsebob with some fresh souls
23:38:38 <dons> more souls for Beelsebob !!
23:38:58 <dblhelix> dons: btw, read your tweets; do you have live coverage of the  TdF in the States? I guess not..
23:39:09 <dons> dblhelix: yes, we do ,but it is at 4am
23:39:16 <dons> so i DVR it and watch it when I get home
23:39:34 <dons> yay for time travel
23:39:43 <dblhelix> :-)
23:42:50 <kayess> I'm trying to understand this y combinator thing. In Haskell the lambda you give to fix is something like (a -> b) -> a -> b
23:43:06 <dons> ?src fix
23:43:07 <lambdabot> fix f = let x = f x in x
23:43:09 <kayess> But the python example I've seen uses this: fact = lambda f: lambda x: 1 if x == 0 else x * f(x-1)
23:43:24 <copumpkin> how does that count as fix? that's factorial
23:43:37 <kayess> This is the function you pass to fix
23:43:43 <copumpkin> oh :)
23:43:46 <shachaf> kayess: f :: (a -> b), x :: a
23:43:54 <copumpkin> :t fix
23:43:55 <lambdabot> forall a. (a -> a) -> a
23:44:03 <shachaf> Er.
23:44:14 <shachaf> a = (Int -> Int)
23:44:19 <dblhelix> kadoban: you give it something of type a -> a in order to produce something of type a
23:44:25 <kayess> So, is the python using nested lambdas to try to do some sort of partial application, or is there some deeper reason behind the difference?
23:44:53 <dblhelix> :t fix (\fac -> \n -> if n == 0 then 1 else n * fac (n - 1))
23:44:54 <Berengal> > fix (\f x -> if x == 0 then 1 else x * f (x-1)) 5
23:44:55 <lambdabot> forall a. (Num a) => a -> a
23:44:56 <lambdabot>   120
23:45:25 <dblhelix> Berengal: heh, great minds ...
23:45:29 <shachaf> kayess: Well, it makes sense to separate the arguments.
23:45:39 <Berengal> kayess: In haskell, there's no difference between nested lambdas and multiple arguments
23:45:42 <Berengal> In python, there is
23:45:52 <kayess> so it could have been lambda f x in the python version too?
23:46:00 <Berengal> You can think of functions taking multiple parameters as taking a tuple instead
23:46:12 <kayess> But then you couldn't partially apply it in Python without using another higher order function to do that?
23:46:23 <shachaf> kayess: Yes -- but the separation is sensible.
23:46:39 <sm> anyone using hskeleton's parseArgs ? I'm having trouble understanding it
23:46:40 <shachaf> Think of the outer lambda as a function that gets itself as an argument.
23:46:47 <kayess> I understand that partial application is nice -- I was just wondering if the nested lambdas in python are a requirement for a y combinator or not
23:47:08 <shachaf> Well, depends on what you mean by the Y combinator. :-)
23:47:30 <kayess> Ah :)
23:47:34 <shachaf> For the one that's defined to get nested lambdas, it obviously is.
23:47:42 <shachaf> But you could make one that doesn't, sure.
23:47:53 <shachaf> http://www.ccs.neu.edu/home/matthias/BTLS/sample.ps may be helpful.
23:47:57 <shachaf> (Scheme.)
23:48:12 <shachaf> Also note that you can't actually write the Y combinator in Haskell. :-)
23:48:21 <kayess> I've been looking at the wikipedia page on y combinators: http://en.wikipedia.org/wiki/Fixed_point_combinator
23:48:25 <kayess> That's interesting. Why not?
23:48:32 * copumpkin is tempted to kill lambdabot by showing why
23:48:39 <shachaf> kayess: Types.
23:49:05 <kayess> You can't describe it's type properly? That doesn't sound right or you'd not be able to use it
23:49:13 <shachaf> (Specifically, fix lets you write _|_, which you shouldn't be able to do in the typed Î»-calculus.)
23:49:28 <shachaf> Well, it's not so much that you can't describe its type properly as that its type isn't proper.
23:49:32 <kayess> That's bottom right? like nil in lisp?
23:49:42 * copumpkin whistles @pl (\x -> x x) (\x -> x x)
23:49:46 <shachaf> No, like an infinite loop in LISP. :-)
23:49:52 <kayess> Oh
23:49:58 <Berengal> kayess: bottom is like an infinite loop or an uncatchable exception
23:50:07 <kayess> Ok
23:50:24 <shachaf> undefined is one _|_.
23:50:29 <shachaf> @ty undefined
23:50:31 <lambdabot> forall a. a
23:50:33 <Berengal> > undefined
23:50:34 <lambdabot>   * Exception: Prelude.undefined
23:50:36 <Berengal> > fix error
23:50:38 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
23:50:49 <shachaf> Berengal: That's nasty. :-(
23:50:49 <kayess> so, if I have functions as values, a function that can call a function passed as a value, and a function that applies arguments to a function is that enough to write a y combinator?
23:50:54 <copumpkin> > error (+)
23:50:56 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
23:51:00 <copumpkin> :t error
23:51:02 <lambdabot> forall a. [Char] -> a
23:51:04 <copumpkin> aw
23:51:07 <Berengal> fix error: an infinite loop of uncatchable exceptions
23:51:16 <shachaf> kayess: If I understand correctly, no. :-)
23:51:20 <shachaf> Not in Haskell, at least.
23:51:34 <kayess> My language is untyped so there's no problem there
23:51:36 <shachaf> What sort of type is "a"? It's crazy; it shouldn't exist.
23:51:46 <kayess> And the language is eager
23:51:53 <copumpkin> it's anything you need it to be
23:51:53 <kayess> What else do I need?
23:51:55 <copumpkin> same with unefined
23:52:00 <Berengal> @type let f x = f x in f
23:52:01 <shachaf> You can write Y with just S and K. :-)
23:52:01 <copumpkin> oh, you knew that :)
23:52:02 <lambdabot> forall t t1. t -> t1
23:54:01 <copumpkin> it's mmorrow!
23:54:13 <shachaf> kayess: When you say your language, do you mean Python? :-)
23:54:21 <kayess> No, this is a new language
23:54:36 <shachaf> (Read that chapter of TLS if it makes sense out of context.)
