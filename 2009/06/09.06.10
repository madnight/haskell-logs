00:26:18 <jinjing> @bot
00:26:18 <lambdabot> :)
00:26:18 <lunabot>  :)
00:56:01 <rob__> is there a way to print every a in [a] in a new line, given that a is showable?
00:56:25 <shachaf> @ty mapM_ print
00:56:26 <lambdabot> forall a. (Show a) => [a] -> IO ()
00:56:40 <Zao> @src print
00:56:41 <lambdabot> print x = putStrLn (show x)
01:02:01 <rob__> can I use this IO monad in an instance declaration of Show?
01:08:51 <Zao> rob__: That depends on what you mean.
01:09:29 <Zao> If you're talking about the implementation of "show" for Show YourType, unlikely.
01:09:32 <Zao> @src Show
01:09:32 <lambdabot> class  Show a  where
01:09:33 <lambdabot>     showsPrec :: Int -> a -> ShowS
01:09:33 <lambdabot>     show      :: a   -> String
01:09:33 <lambdabot>     showList  :: [a] -> ShowS
01:10:05 <integral> @type unsafePerformIO
01:10:06 <lambdabot> Not in scope: `unsafePerformIO'
01:10:07 <Zao> As it's pure, you can't run IO actions inside.
01:10:25 <Zao> (unless you unsafePerform it, but you most probably do not need or want to)
01:10:55 <Zao> Escape hatches are rather useless if you don't need to run away :P
01:11:11 <rob__> I want to print a binary tree, and each level in a new line, so I was trying to define Show for the Tree
01:12:07 <mmorrow> what's people opinion on which endianness to choose for bitmasks (they cannot depend on the endianness of the system)?
01:12:14 <Zao> rob__: So spit out a String with newlines in it.
01:12:25 <mmorrow> (context: you're writing a program that has to make this choice)
01:12:46 <mmorrow> i kinda want to go with little
01:12:46 <Zao> instance Show Pie where show x = "omg\nlol"
01:13:05 <rob__> Zao: so does this only work with strings, or with all a's that are showable?
01:13:17 <Zao> show shouldn't print anything by itself, it should just provide a String suitable for displaying.
01:13:26 <Zao> rob__: Eh?
01:13:54 <Zao> (mapM_ print) will work with any a that has a Show instance.
01:14:02 * mmorrow goes with big
01:14:18 <rob__> Zao: instance (Show a) => Show (Tree a) where ...?
01:14:56 <Zao> instance Show Tree where show tree = ...
01:15:39 <Zao> Similarly formatted to the class lambdabot showed above, but with instance instead of class, your concrete type instead of a, and function bodies.
01:16:15 <Zao> You can do whatever you want inside the show :: a -> String function, as long as you get a nice and shiny String out of it in the end.
01:17:33 <rob__> Does this still work with a (Tree a) datatype?
01:18:38 <mmorrow> if (Show a)
01:19:14 <mmorrow> rob__: i wouldn't use Show for that
01:19:45 <rob__> mmorrow: what would you use?
01:19:46 <mmorrow> personally i'd just translate your tree type to Data.Tree and then use its excellent drawTree function
01:20:03 <mmorrow> @type putStrLn . drawTree . fmap show
01:20:05 <lambdabot> forall a. (Show a) => Tree a -> IO ()
01:20:35 <mmorrow> , text . drawTree . fmap show $ Node 0 [Node 1 [], Node 2 []]
01:20:38 <lunabot>  0
01:20:38 <lunabot>  |
01:20:38 <lunabot>  +- 1
01:20:53 <rob__> I didn't know about that, thanks for the tip
01:20:55 <mmorrow> (or just snake the drawTree function from the Data.Tree src)
01:20:57 <Zao> Making your own nicely indenting pretty printing tree display function is bothersome.
01:21:22 <mmorrow> yeah, it's definitely a pita
01:23:55 <rob__> ok I'm glad it's not trivial
01:27:55 <Yrogirg> Hello! How to convert Int64 to Int?
01:28:03 <Lemmih> Yrogirg: fromIntegral.
01:35:31 <quicksilver> be aware that on a 32bit platform that is a lossy conversion.
01:35:38 <quicksilver> on a 64bit platform is should compile down to a nop.
01:36:16 <ClaudiusMaximus> > (maxBound,maxBound)::(Int,Int64)
01:36:17 <lambdabot>   (9223372036854775807,9223372036854775807)
01:36:25 <quicksilver> LB is on a 64bit platform.
01:36:38 <mmorrow> , (maxBound,maxBound)::(Int,Int64)
01:36:39 <lunabot>  (2147483647,9223372036854775807)
01:42:19 <zeno> is there a version of haskell for the jvm?
01:42:40 <zeno> or arm
01:42:43 <ivanm> no
01:43:56 <quicksilver> there have been three or four projects for haskell on the jvm
01:44:08 <quicksilver> they're all more-or-less dead but they might be ressurectable
01:44:19 <quicksilver> GHC does compile on arm.
01:44:28 <quicksilver> there is a package in debian-arm, for example.
01:44:29 <quicksilver> It's slow.
01:44:50 <zeno> ah ok thx
01:45:12 <doserj> debian has hugs for arm, too
01:45:23 <quicksilver> hugs is in pretty portable C
01:45:28 <quicksilver> it compiles for most platforms.
01:46:03 <psygnisfive> hm
01:46:09 <psygnisfive> i had an idea! :o
01:46:09 <zeno> more practical just to ssh into my home box i guess
01:46:39 <psygnisfive> it might actually already be implemented in haskell, i dont really know, but
01:47:06 <Ferdirand>  -
01:47:24 <ClaudiusMaximus> my implementation of untyped lambda calculus does roughly the same amount of work to calculate  factorial 4, fib 6, and ackermann 2 3,  - any ideas for similar-cost functions i might try out?
01:47:55 <psygnisfive> hm.. well, actually, it might be identical to CPS, so nevermind :D
01:51:50 <dirk_> after one week of Hasekll I can finally parse nested tables, something I thought I would never manage
01:51:52 <zeroflag> !seen mauke
01:51:58 <zeroflag> mmh?
01:52:03 <zeroflag> don't you guys have a bot?
01:52:12 <cizra> nope. No bots here. Pass along.
01:52:19 <zeroflag> :\
01:52:22 <abbe> @slap zeroflag
01:52:22 * lambdabot hits zeroflag with a hammer, so they breaks into a thousand pieces
01:52:24 <purplepenguins> there is lambdabot
01:52:34 <zeroflag> can anybody tell me if mauke has been active in the past couple of days?
01:52:39 <zeroflag> been trying to reach him.
01:52:44 <zeroflag> @seen mauke
01:52:44 <lambdabot> mauke is in #xmonad and #haskell. I don't know when mauke last spoke.
01:52:51 <zeroflag> damn.
01:54:43 <ivanm> dirk_: how do you define a "nested table"? i.e. what are you calling a table?
01:54:56 <ivanm> preflex: seen mauke
01:54:56 <preflex>  mauke was last seen on #perl 10 hours, 34 minutes and 9 seconds ago, saying: hmm, now I get no output at all
01:55:01 <ivanm> @uptime
01:55:01 <lambdabot> uptime: 2d 5h 26m 9s, longest uptime: 1m 10d 23h 44m 29s
01:55:13 <ivanm> OK, mauke has just been avoiding haskellers then
01:55:42 <zeroflag> well, he joined you haskellers because the perl "compiler" was somehow using haskell...
01:55:46 <zeroflag> :P
01:55:57 <ivanm> ummmm..... no?
01:56:08 <ivanm> isn't pugs just an interpreter for perl6?
01:56:16 <ivanm> with "perl" usually taken to mean pearl5?
01:56:17 <zeroflag> dunno what it is.
01:56:32 <zeroflag> yeah, I meant perl6.
01:56:35 <ivanm> *perl5
01:56:50 <zeroflag> perl5 is a write-only language that's almost as terrible as C++.
01:57:40 <dirk_> ivanm paste http://de.wikibooks.org/wiki/Benutzer:Dirk_Huenniger/haskell
01:58:22 <ivanm> ahhhhh
01:58:35 <dirk_> what?
01:58:48 <ivanm> ahhhh == I understand what you're talking about now
01:58:49 <ivanm> ;-)
01:59:21 <ivanm> though I don't think your data structure is necessarily the best approach... (that is, using lists everywhere; that could just be the way it's printed there though)
02:00:03 <dirk_> don't understand: that could just be the way it's printed there though?
02:00:31 <ivanm> yeah
02:00:57 <dirk_> I did not understand what you meant with that sentences
02:01:01 <dirk_> -s
02:02:28 <ivanm> at first glance, the way you represent the tables in Haskell looks a bit weird
02:02:36 <dirk_> maybe
02:02:42 <ivanm> but that could just be the way you've printed/pasted it there
02:03:24 <dirk_> I want to write latex files in the end
02:03:40 <ivanm> ahhh
02:12:22 <mmorrow> heh, this could be useful... from ghc's nativeGen/PprBase.hs http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2671#a2671
02:12:58 <Berengal> I need a map that can be indexed by different keys... how do I do this best?
02:13:09 <Berengal> The simple solution is to simply use more than one map...
02:13:10 <mmorrow> what does that mean?
02:13:18 <mmorrow> oh
02:13:40 <Berengal> But it's not optimal... you'd have to make sure to update the other maps as well when one is changed
02:13:41 <mmorrow> are they all the same type?
02:13:47 <mmorrow> (the keys)
02:14:06 <Berengal> No, but the keys can all be created from the values
02:14:28 <mmorrow> so how many different keys do you need then?
02:14:33 <mmorrow> (different types of...)
02:14:50 <mmorrow> (because if that's fixed then i have one idea)
02:14:51 <Berengal> Take for example data Person = Person {firstName, lastName :: String, phoneNumber :: Int}, then create a map that can be indexed by lastName or phoneNumber
02:15:16 <mmorrow> oh, so you're looking the make a bunch of indexes here, similar to a db
02:15:20 <mmorrow> s/the/to/
02:15:26 <mmorrow> i've used:
02:15:26 <Berengal> Yes, very similar to a db
02:15:31 <Berengal> Except a db would be overkill...
02:15:38 <mmorrow> err, lemme paste
02:15:43 <Berengal> And I'd rather it not live in IO
02:15:59 <mmorrow> oh no need
02:15:59 <quicksilver> make a bunch of maps and stick them in a data structure
02:16:11 <quicksilver> and have functions which update them all at once
02:16:16 <quicksilver> (and don't cheat and update them by hand)
02:16:25 <mmorrow> the beauty of indexes too is that when you do queries, you get to union/isect/diff the *index* maps
02:16:40 <Berengal> quicksilver: Yes, that's the fixed version of the simple solution. I'm just wondering if there's a more elegant one
02:16:42 <mmorrow> then after all those shenanigans are done, you finally index into the real map
02:18:19 <quicksilver> Berengal: I'm not sure if that's inelegant.
02:18:30 <quicksilver> I certainly don't know of a super-clever multi-way map
02:18:39 <quicksilver> and I don't offhand see how it could be significantly different.
02:18:54 <mmorrow> Berengal: err, so here's just the whole module http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2672#a2672
02:19:00 <Berengal> quicksilver: I didn't say it was inelegant, I just wondered if there's an even more elegant way to do it...
02:19:00 <quicksilver> perhaps you could treat the different keys and different dimensions and preternd it was a spetial indexing problem.
02:19:01 <mmorrow> so the highlights are:
02:19:19 <mmorrow> type Ix k = Map k IntSet
02:20:05 <Berengal> Ah, so the values proper are indexed by int, with a bunch of key -> int maps?
02:20:07 <mmorrow> and suppose you want to query "where phonenumber = 18273464387 and name in ('mitch','sally')"
02:20:40 <mmorrow> ==> look up the locations of the recs for that phonenumber in the phonenumber index
02:20:54 <mmorrow> then look up both mitch and sally in the name map
02:21:09 <quicksilver> I think mmorrow's is just a refinement to explicitly permit multiple values to have the same key.
02:21:10 <mmorrow> and union mitch and sally, and intersect that with phonenumber
02:21:18 <quicksilver> It could easily just be Map k [v], couldn't it?
02:21:26 <quicksilver> you just get worse complexity on the [v]
02:21:34 <mmorrow> quicksilver: actually that won't work, because
02:21:54 <mmorrow> what if you have *more that one* key? you have to dup vals
02:22:14 <mmorrow> (but if you don't care about duplicating the values in each map, then you could do that i suppose)
02:22:31 <mmorrow> oh, and the value map that i'm assuming is:
02:22:36 <mmorrow> IntMap value
02:22:50 <mmorrow> and the IntSets are sets of indexes into *that* map
02:23:48 <Berengal> This looks even more powerful than what I need
02:24:21 <mmorrow> Berengal: i like that general idea though
02:24:51 <mmorrow> data DB k v = DB {dat :: IntMap v, indexes :: [Map k IntSet]}
02:25:05 <Berengal> Yeah, I like it too. It's the dbs without the annoying parts
02:25:11 <mmorrow> (where you've done something like data Key = StringK String | IntKey Int | ...)
02:25:34 <mmorrow> queries are pretty efficient this way too
02:25:56 <Berengal> Looks like it needs a bit of wrapping though, to make a cleaner interface to what I need
02:26:16 <Berengal> But shouldn't be too difficult
02:26:21 <mmorrow> totally
02:26:46 <Yrogirg> I still cant understand what to to do. I have:
02:26:46 <Yrogirg> toInt :: Integer -> Int
02:26:46 <Yrogirg> toInt a = fromIntegral a
02:26:46 <Yrogirg> toInt $ BL.length (encode points)
02:26:46 <Yrogirg> and I get:
02:26:47 <Yrogirg> Couldn't match expected type `Integer'  against inferred type `GHC.Int.Int64'
02:27:03 <Berengal> Essentially, I'd want something like 'createMap [lastName, phoneNumber]' to create an empty map...
02:27:31 <mmorrow> Berengal: exactly. my equiv of that in that module is:
02:27:35 <mmorrow> index :: (Ord v) => [(id, a -> v)] -> [a] -> [(id, Ix v)]
02:27:43 <MyCatVerbs> Yrogirg: you want to just write fromIntegral $ BL.length (encode point)
02:27:50 <mmorrow> (type Ix k = Map k IntSet)
02:28:12 <integral> :t fromIntegral
02:28:14 <lambdabot> forall a b. (Integral a, Num b) => a -> b
02:28:23 <MyCatVerbs> Yrogirg: the type signature you put on toInt makes it only work on Integers specifically, but BL.length returns an Int64.
02:28:25 <quicksilver> mmorrow: OK. I think it's a small refinement on my suggestion, but yes I agree.
02:28:26 <mmorrow> Berengal: err, so that `index' function only does half of the work your `createMap' would do
02:28:59 <mmorrow> quicksilver: yes totally, they'd accomplish the same thing, differing only in efficiency
02:29:42 <mmorrow> hmmm, actually they differ also in that the separate-index approach support queries with AND and OR
02:29:54 <quicksilver> my approach was also separate-index.
02:30:00 <Yrogirg> thanks, it works now
02:30:01 <mmorrow> hmm
02:30:04 <mmorrow> ohhh, i see ok
02:30:06 <quicksilver> I just wasn't doing the clever IntSets-as-values part
02:30:11 <quicksilver> which is a natural refinement.
02:30:20 <mmorrow> i gotcha, yeah they're the same thing then
02:30:22 <Berengal> mmorrow: I should be able to either easily make the rest, or steal the idea to build what I want easily
02:30:45 <mmorrow> Berengal: cool! yeah that module/general-idea has worked really nicely for me
02:31:07 <Berengal> mmorrow: Much obliged :)
02:42:02 <ManateeLazyCat> Hi, all. In code "date Page = forall a . PageBuffer a => Page {pageBuffer :: a}", what's mean `forall`? I know it's a keyword, someone can explain that when time use `forall`? Thanks!
02:42:25 <quicksilver> ManateeLazyCat: it means that constructor works for all types a
02:42:38 <quicksilver> :t map
02:42:39 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
02:42:46 <quicksilver> ManateeLazyCat: just like map works for all types a and b
02:42:48 <quicksilver> hence "forall"
02:43:01 <dcoutts> Page :: PageBuffer a -> Page
02:43:27 <dcoutts> ie the Page data constructor (when looked at as a function) has that type
02:43:36 <dcoutts> note that the 'a' does not appear in the result type
02:43:48 <dcoutts> so it's effectively hidden
02:43:57 <BONUS> usually you'd do data Page a = Page {pageBuffer :: a}, but if you don't want the type parameter and only need to assume that the a is part of the PageBuffer typeclass, you can kind of transfer the a to the other side of =
02:44:15 <dcoutts> erm,  Page :: PageBuffer a => a -> Page
02:44:17 <BONUS> so the type is Page instead of Page Int, Page Char, etc.
02:46:11 <dcoutts> ManateeLazyCat: in GADT syntax we'd write it:
02:46:14 <dcoutts> data Page where
02:46:15 <dcoutts>   Page :: PageBuffer a => a -> Page
02:46:27 <ManateeLazyCat> dcoutts: Yep, i use GADTs for solution my problem.
02:46:50 <ManateeLazyCat> dcoutts: And someone help me that use this style.
02:46:52 <BONUS> you don't need the forall if you use GADT syntax? cool, i didnt know that
02:47:01 <dcoutts> the forall there is implicit (I think), because the 'a' isn't in scope at the top
02:47:18 <ManateeLazyCat> BONUS: No, i need forall.
02:47:38 <ManateeLazyCat> BONUS: "data Page a = ... " is can't fix my problem.
02:47:51 <BONUS> i mean if you use GADT syntax, the forall is implicit
02:48:04 <BONUS> otherwise with normal ADT syntax you need it yeah
02:49:20 * ManateeLazyCat pasted "my code" at http://paste2.org/get/256982
02:49:23 <ManateeLazyCat> Above is my code.
02:49:31 <ManateeLazyCat> that use forall
02:50:13 <ManateeLazyCat> If i need get `pageBuffer` from page, i can write code "case page of Page {pageBuffer = x} -> do something with `x`"
02:54:34 <ManateeLazyCat> Before this solution, i found "data Page a = ..." (GADTs) is not i want, because i can't store Page object in other data structure, i can't reference Page instance. And "data Page = forall a . PageBuffer a => ..." is i want, and GADTs puzzle me long time.
02:58:01 <quicksilver> BONUS: well, the forall is implicit in normal ADT syntax too. Unfortunately it's implicit in the wrong place ;)
02:58:02 <dirk_> can I split a list with respect to a predicate?
02:58:12 <quicksilver> :t break
02:58:13 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
02:58:16 <BONUS> haha that's true
02:58:27 <dirk_> ok
02:58:41 <ziman> :t partition
02:58:42 <BONUS> there's also span and partition
02:58:42 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
02:58:58 <dirk_> it breaks into pairs
02:59:10 <dirk_> but I want it to break into a list of lists
02:59:19 <quicksilver> you have to call it repeatedly then.
02:59:36 <Berengal> Or use Data.List.Split
02:59:36 <quicksilver> there are some functions on hackage in Data.List.Split
02:59:37 <ManateeLazyCat> Thanks all for detail explain! :)
02:59:41 <ziman> or use unfoldr
02:59:47 <dirk_> so "aa|asa|aswe" -> ["aa","asa","aswe"]
02:59:54 <dirk_> looking at it
03:00:30 <ManateeLazyCat> Now i remove all code that use Dynamic, Dynamic is evil...
03:00:45 <quicksilver> Dynamic is a sledgehammer
03:00:59 <quicksilver> it's normally nicer to use your own existential, or even just an enumeration.
03:01:09 <quicksilver> Dynamic is like the 'magic all-seeing existential'
03:01:20 <Berengal> Sometimes you've got big nails...
03:01:29 <quicksilver> but it's almost always nicer to use something more specific.
03:01:43 <quicksilver> Berengal: If you become too fond of your sledgehammer, everything looks like a big nail.
03:02:10 <ziman> I don't understand why -cafe and everything is full of Typeable and Dynamic, i'd definitely consider it bad style; when is it really necessary?
03:02:28 <ziman> can't people just use plain old ADTs?
03:02:43 <Berengal> When all you've got is a fully automatic 12-gauge, everythink look like zombies
03:03:10 <Berengal> Also, your spelling turns bad
03:03:22 <ManateeLazyCat> quicksilver: Before i use "data Page = forall a. PageBuffer a => {pageBuffer :: a}", i use "data Page = {pageBuffer :: Dynamic}", when i use pageBuffer from Page, i need use "case pageBufferType of TypeA -> x :: A; TypeB -> x :: B;", and those code ugly.
03:03:41 <feret_mercedes> it could be the greatest
03:03:47 <feret_mercedes> haskell forth and common lisp
03:03:48 <BONUS> > unfoldr (\xs -> let (a,b) = break (=='|') xs in guard (not $ null xs) >> Just (a, drop 1 b)) "saf|asf|af"
03:03:49 <lambdabot>   ["saf","asf","af"]
03:03:55 <feret_mercedes> what other langs offer power?
03:03:59 <quicksilver> ManateeLazyCat: yup.
03:04:25 <dirk_> ok thank you, but will try to use a library function
03:04:42 <BONUS> yeah i suggest doing that too
03:04:46 <ManateeLazyCat> quicksilver: I'm happy now, because i just use one line replace 30 line that use Dynamic. And code is clearer.
03:05:06 <quicksilver> ;)
03:05:40 <ManateeLazyCat> quicksilver: Haskell is pretty cooool, but it's puzzle me long time... :)
03:05:56 <quicksilver> ;)
03:05:58 <ManateeLazyCat> quicksilver: Now continue explore Haskell....
03:09:43 * ManateeLazyCat I think i need ask more in haskell-cafe... or else i'm still puzzle now.
03:11:51 <jthing> I had a bit of trouble with Maybe
03:12:17 <dirk_> can I multiply int and string like "ab"*3 = "ababab" ?
03:12:27 <BONUS> no
03:12:32 <jthing> Seems problematc to extract the values
03:12:32 <BONUS> but you can do
03:12:52 <Berengal> jthing: How so?
03:12:58 <BONUS> > concat $ replicate 3 "ab"
03:12:59 <lambdabot>   "ababab"
03:13:03 <dirk_> ok
03:13:39 <jthing> well it's all down to pattern match which sems inefficient
03:13:54 <Berengal> jthing: It's not
03:14:17 <jthing> would you elaborate?
03:14:27 <Berengal> Pattern matching is not inefficient
03:14:37 <jthing> duh
03:14:46 <Berengal> Not sure there's much more to say about that...
03:15:07 <jthing> you mean it is done at compile time i suspect
03:15:26 <Berengal> No, you can't match on values that don't exist yet...
03:15:32 <quicksilver> it can be done at compile time
03:15:37 <quicksilver> if it's statically visible which case it is.
03:15:43 <Berengal> True...
03:15:47 <quicksilver> pattern matching is, in a sense, the most basic construct of haskell
03:15:49 <Zao> dirk_: Using multiplication to replicate + concat a string is a rather leaky abstraction.
03:16:00 <Berengal> On the other hand, pattern matching is what's driving evaluation
03:16:07 <quicksilver> pattern matching is the wheel which turns.
03:16:10 <ManateeLazyCat> I understand, if i don't write "forall a ." before "PageBuffer a =>" GHC will occur error "Not in scope: type variable `a`", so keyword `forall` like
03:16:10 <ManateeLazyCat> 																											  [18:15:50]
03:16:14 <Berengal> So if it was all done at compile time, there'd be no runtime
03:16:16 <ManateeLazyCat> explicitly
03:16:25 <Zao> ManateeLazyCat: That's a whole lot of tabs you pasted there.
03:16:36 <ManateeLazyCat> type [18:16:25]
03:16:41 <ManateeLazyCat> Bad Emacs ERC
03:16:43 <Zao> ManateeLazyCat: Needs more parens?
03:16:44 <ManateeLazyCat> Sorry.
03:17:02 <ManateeLazyCat> Zao: Sorry, it's a bug of ERC
03:17:26 <dirk_> the syntax does not matter, but the function is important
03:17:34 <Zao> ManateeLazyCat: I was more thinking about the PageBuffer a bit, but I'm inexperienced in those parts.
03:18:37 <jthing> Pagebuffer is a monad
03:18:51 <Beelsebob> Has anyone here played with Graphics.Rendering.OpenGL.GLU.Tesselation?
03:18:58 <Zao> ManateeLazyCat: Something like f :: Show a => a -> a works for me.
03:19:06 * ManateeLazyCat pasted "PageBuffer" at http://paste2.org/get/257036
03:19:12 <ManateeLazyCat> Zao: Above PageBuffer
03:19:38 <ManateeLazyCat> Zao: PageBuffer is interface for all type in Page.
03:20:02 <ManateeLazyCat> Zao: Then i can use Page contain all type  in `pageBuffer`
03:21:03 <ManateeLazyCat> `forall` is an explicitly quantified type. Now clear enough...
03:21:22 <Zao> Do you have a piece of code that doesn't work without the quantificatoin?
03:22:19 <ManateeLazyCat> Zao: Sorry?
03:23:13 <Zao> The error you got above. In what context was that?
03:23:53 * ManateeLazyCat pasted "Page.hs" at http://paste2.org/get/257078
03:24:18 <ManateeLazyCat> Zao: That's my Page.hs file that use "forall a . PageBuffer a =>"
03:25:04 <Zao> Ah, it's in that context.
03:25:45 <ManateeLazyCat> Zao: My english is not always best. :)
03:27:42 <ManateeLazyCat> Zao: So i can't understand others mean sometime....
03:30:17 <ManateeLazyCat> How to leave message to someone through lambdabot? I need thanks someone that help me.
03:31:01 <Zao> What about  data Page a = PageBuffer a => ...?
03:31:13 <Zao> Or am I misunderstanding the purpose of the code?
03:31:59 <quicksilver> @tell ManateeLazyCat Here is a mesage for you
03:31:59 <lambdabot> Consider it noted.
03:32:52 <ManateeLazyCat> @tell ryan Thank you so much, you help me solution my problem, and it puzzle me long time. Thank you! :)
03:32:52 <lambdabot> Consider it noted.
03:33:17 <ManateeLazyCat> quicksilver: That's okay?
03:33:17 <lambdabot> ManateeLazyCat: You have 1 new message. '/msg lambdabot @messages' to read it.
03:34:44 <mmorrow> this must be really fast or something "indexWord8OffFastPtrAsFastChar" :P
03:35:17 <Zao> I'm not pleased until it has at least one unsafe in it.
03:35:22 <ManateeLazyCat> Zao: If you use "Page a = PageBuffer a => s", how to create Page instance.
03:35:24 <quicksilver> ManateeLazyCat: that was right, yes.
03:35:32 <ManateeLazyCat> quicksilver: Thanks.
03:36:56 <ManateeLazyCat> Zao: I just want `pageBuffer` of `Page` use all type. `PageBuffer a` is interface, and Page is just container that contain PageBuffer object.
03:37:11 <ManateeLazyCat> Zao: That's my purpose.
03:40:06 <ManateeLazyCat> dcoutts: I use your suggestions, use child widget get event then callback to parent container, and works well. Thanks.
03:40:20 <dcoutts> ManateeLazyCat: great
03:40:33 <ManateeLazyCat> dcoutts: Use EventBox need setAbove with True, and it more complicate.
03:42:07 <ManateeLazyCat> dcoutts: If i use EventBox, i need filter all Event to child widgets, and it's not agility. Use child widget with callback is neat. Thanks for your help
03:43:47 <Zao> ManateeLazyCat: I defer that question to someone that actually knows what they are talking about.
03:43:50 <Zao> eg. not me
03:51:14 * ManateeLazyCat Dinner....
03:51:55 <MyCatVerbs> ManateeLazyCat: odd time for dinner, unless you're somewhere within about twenty degrees of India?
03:52:43 <MyCatVerbs> (Longitude, I mean)
03:56:06 <dirk_> I am working with Parsec and I want to revert the stream to a certain position
03:56:48 <jml> MyCatVerbs: a pretty large chunk of humanity are eating dinner right now. :)
03:57:00 <dirk_> So I consumed something, and I got some information that way, but I want to go on parsing, as if I had not consumed it
03:59:19 <doserj> dirk_: lookahead p
03:59:41 <dirk_> lookahead is not in the documentation
03:59:50 <dirk_> http://legacy.cs.uu.nl/daan/download/parsec/parsec.html
04:00:29 <doserj> that's over 7 years old!
04:01:57 <doserj> http://hackage.haskell.org/packages/archive/parsec/3.0.0/doc/html/Text-ParserCombinators-Parsec-Combinator.html#v%3AlookAhead
04:03:45 <dirk_> yes works, thank you
04:26:50 <ManateeLazyCat> MyCatVerbs: China
04:53:59 <ManateeLazyCat> I have type like this "data Page = forall a . PageBuffer a => Page {pageBuffer :: a}", if i need pick up pageBuffer from Page, i need write code like this "case page of Page {pageBuffer = x} -> do something with `x`". Have other way that pick up pageBuffer and don't use "case page of ... " style? Thanks
04:58:32 <Cale> ManateeLazyCat: no, you absolutely must use pattern matching
04:59:53 <Cale> ManateeLazyCat: Suppose that pageBuffer was allowed as a function, as field names normally are. What type would it have?
05:00:52 <Cale> ManateeLazyCat: Well, it would take a Page, and give you... well, we don't know, it's just some type a which satisfies PageBuffer. Not just *any* type a, but a specific one that we don't know.
05:01:05 <Cale> Another way to write that would be
05:01:27 <BONUS> how about pageBuffer :: PageBuffer a => Page -> a
05:01:40 <Cale> BONUS: too polymorphic :)
05:01:42 <doserj> Page -> exists a. PageBuffer a => a
05:01:50 <BONUS> ah, hmm
05:01:56 <Cale> pageBuffer :: Page -> (exists a. PageBuffer a => a), yes
05:02:15 <Cale> But Haskell doesn't have that type.
05:02:16 <BONUS> ah yeah, it's not universally quantified inside
05:02:23 <ManateeLazyCat> Cale: pageBuffer is *any* type that interface with PageBuffer type.
05:02:39 <BONUS> it can't produce any type that's part of PageBuffer
05:02:44 <BONUS> because it only has a value of one type inside it
05:02:45 <BONUS> i see
05:03:19 <Cale> ManateeLazyCat: inside of each Page value, you might have a value from a different type, as long as it's from a type which is an instance of that class
05:03:39 <Cale> ManateeLazyCat: Applying the Page data constructor "forgets" the original type
05:04:44 <BONUS> all that remembers is that the type is some type in the PageBuffer typeclass
05:04:45 <Cale> and there's no way to recover that type information unless you do something to explicitly preserve it in the first place
05:08:27 <ManateeLazyCat> If i write function "pageGetBuffer page = case page of Page {pageBuffer = x} -> x", how to write type signature?
05:08:44 <doserj> you can't
05:08:50 <Cale> ManateeLazyCat: Exactly. There is no valid type signature you could give it.
05:09:09 <Cale> (because GHC does not have first-class existentials)
05:09:58 <ManateeLazyCat> Cale: So i need write "case page of Page{pageBuffer = x} -> ... " everytime that i need pick up pageBuffer from Page instance?
05:10:29 <wjt> You can write withPageBuffer :: PageBuffer a => (a -> b) -> Page -> b
05:10:45 <inbuninbu> question for you gentlemen... is there an easier way to do control on an algebraic data type than pattern matching?
05:10:59 <inbuninbu> for example, if i have an adt:
05:10:59 <inbuninbu> data Mydata = Data1 Int String Int | Data2 String Int String | Data3 ...
05:11:20 <inbuninbu> and have (monadic) functions (say, print) that will operate on ints and strings, and want a function that will arbitrarily apply them on the components of Data...
05:11:48 <inbuninbu> is there a way to do that? basically, i want to avoid a gigantic case statement that uses pattern matchin
05:12:33 <Cale> wjt: not quite... withPageBuffer :: (forall a. PageBuffer a => a -> b) -> Page -> b
05:12:55 <BONUS> inbuninbu: make your type part of Functor? then you can map over it
05:13:24 <BONUS> or make a function that extracts certain fields depending on the constructor
05:13:33 <Cale> inbuninbu: It sounds as if you're looking for Data.Generics
05:13:39 <wjt> Cale: aye
05:13:43 * wjt forages for coffee :)
05:13:45 <Cale> inbuninbu: But that's usually overkill
05:13:56 <quicksilver> inbuninbu: alternatively, you only have to do it once, generically.
05:14:06 <inbuninbu> BONUS: in the functor impl, though, won't i still have to have a big case statment based on the constructor of the adt?
05:14:07 <quicksilver> (write the case statement I mean)
05:14:34 <mux> GHC can derive Functor automagically nowadays, I think
05:14:46 <inbuninbu> Cale: thanks, i'll take a look
05:14:49 <ManateeLazyCat> I wonder have way that avoid write duplicate case statement.
05:15:12 <inbuninbu> quicksilver: you mean with Data.Generics
05:15:29 <inbuninbu> mux: i'll give it a whirl
05:15:43 <deeflex> Hey can anyone help me with this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5728#a5728 .
05:16:12 <ManateeLazyCat> wjt: withPageBuffer :: (forall a. PageBuffer a => a -> b) -> Page -> b ?
05:16:22 <Cale> inbuninbu: If you have lots of very similar cases like that, chances are that thinking a bit more about how your datatypes are structured might help.
05:16:44 <Cale> ManateeLazyCat: yes
05:17:00 <BONUS> hmm why is the forall inside
05:17:01 <inbuninbu> mux: Cannot derive well-kinded instance of form `Functor(Payload ...)' Class `Functor' expects an argument of kind `* -> *' In the data type declaration for `Payload'
05:17:12 <BONUS> im not that good with existentials beyond the basic uses
05:17:14 <Cale> BONUS: Because the argument itself is what has to be polymorphic
05:17:35 <inbuninbu> Cale: unfortunately there isn't a way around it. it's a data structure as part of a protocol
05:17:36 <Cale> BONUS: It won't do to pick some type a and pass an a -> b function
05:17:39 <quicksilver> BONUS: because it only works on functions which guarantee they work with all "a"
05:17:47 <BONUS> aha
05:17:59 <quicksilver> BONUS: if the forall outsie, it would accept any function which worked on some particular a
05:17:59 <BONUS> and not the a's bound by the outer forall
05:18:00 <BONUS> i see
05:18:13 <mux> inbuninbu: the Functor class only applies to type constructors of kind * -> *
05:18:27 <MyCatVerbs> ManateeLazyCat: cool! How's the weather? :)
05:18:30 <inbuninbu> Cale: and i just want to apply a put (or custom put) function based on the type
05:18:45 <ManateeLazyCat> MyCatVerbs: Too hot.
05:18:49 <ManateeLazyCat> MyCatVerbs: In my city.
05:18:58 <MyCatVerbs> ManateeLazyCat: :/
05:19:15 <inbuninbu> Cale: so i have a great many functions like putDataX (DataX a b c) = put32 a >> put16 b >> put8 c
05:19:45 <ManateeLazyCat> MyCatVerbs: If at other city of China, won't too hot.
05:20:06 <inbuninbu> and then, because i have to decide which function to use, i need a big case statement with pattern matching...
05:20:25 <inbuninbu> it's a lot of repetitive stuff
05:20:58 <dirk_> haskell is turning philosophical pa.hs:211:20: Not in scope: `ruinParser'
05:21:21 <BONUS> see if you can farm that pattern matching out to a function
05:21:24 <BONUS> which you then use
05:22:39 <inbuninbu> BONUS: you just mean move the pattern matching elsewhere?
05:23:18 <doserj> deeflex: the problem is in "let result = map (\ x y -> string2seq x y) mylines"
05:23:25 <inbuninbu> BONUS: i was hoping that there may be a way to at least get it down to a lookup function
05:23:30 <deeflex> deeflex, yes I know
05:23:59 <deeflex> :t lines
05:24:01 <BONUS> the best way is to think about your data structures and try to put all the pattern matching in one simple function that you then call
05:24:02 <lambdabot> String -> [String]
05:24:15 <inbuninbu> BONUS: is there no way to refer to the constructor of the ADT outside of pattern matching? in an expression
05:24:24 <BONUS> it really depends on the data types
05:24:27 <Cale> inbuninbu: How many cases do you actually have?
05:24:38 <BONUS> did you post your code?
05:24:38 <ManateeLazyCat> Cale: How to write code for "withPageBuffer :: (forall a. PageBuffer a => a -> b) -> Page -> b"?
05:24:39 <inbuninbu> Cale: about 26
05:24:40 <deeflex> doserj, yes I know *
05:24:55 <ManateeLazyCat> Cale: I can't understand why need (a -> b)
05:25:03 <inbuninbu> BONUS: i can post some now... you'll get the idea
05:25:09 <Cale> ManateeLazyCat: withPageBuffer f (Page x) = f x
05:26:04 <Cale> inbuninbu: Writing functions across that many cases seems really awkward. Are you sure that there's no way to factor the type at all?
05:26:58 <deeflex> doserj, if I try this at the prompt: map (\x y -> string2seq x y) ["test","test2"] I get ERROR Cannot find "show" function for <myexpression> . The lambda expression takes two elements from the list, right?
05:27:13 <doserj> no
05:27:31 <inbuninbu> data Payload = Tversion {msize::Word32,version::String}|Rversion{msize::Word32,version::String}| Tauth{afid::Word32,uname::String,aname::String}| Rauth {aqid::Qid}| Rerror {ename::String}|..
05:27:34 <doserj> it takes only one, and returns a function that takes another one
05:27:48 <inbuninbu> Cale: there are 26 different message types
05:28:10 <inbuninbu> Cale: there isn't really a way around it
05:28:11 <doserj> deeflex: if you want to map over pairs, you first have to build a list of pairs
05:28:33 <BONUS> yeah but what are you then doing with that type
05:28:34 <ManateeLazyCat> Cale: Cool, thank you!
05:28:42 <BONUS> extracing out the version? or something?
05:28:43 <Cale> inbuninbu: Well, at least as long as you want types checked at compile time :)
05:28:48 <ManateeLazyCat> Cale: withPageBuffer is cool function.
05:28:59 <deeflex> doserj, aha ok.
05:29:04 <ManateeLazyCat> withPageBuffer f (Page {pageBuffer = x}) = f x
05:29:27 <Cale> ManateeLazyCat: or that, yes
05:29:40 <ManateeLazyCat> Sweet. :)
05:29:51 <inbuninbu> BONUS: reading from the network and writing from the network. i call a lookup function based on a message type field
05:30:06 <inbuninbu> and from that i call getTversion
05:30:20 <inbuninbu> which is , getTversion = liftM2 Tversion safeGet32 getS
05:30:24 <ManateeLazyCat> wjt: Thanks too.
05:30:55 <inbuninbu> but for my put method, i have a problem, i'm going from a full-on haskell adt, and need to put it. there is not way but to pattern match, it seems
05:31:28 <deeflex> doserj, Btw..im just learning IO and wonder if all pure functions must have 'let = <expression>' ..?
05:31:52 <ik> deeflex: all of them?  no
05:31:58 <ik> deeflex: just the ones you felt like using that construct in
05:32:03 <Cale> deeflex: well... if you want to make definitions in the middle of a do-block, that's the way to do it
05:32:29 <Cale> deeflex: But otherwise, you can make use of pure functions elsewhere
05:32:34 <ManateeLazyCat> Cale: For function "withPageBuffer :: (forall a. PageBuffer a => a -> b) -> Page -> b", i need enable option `-XRankNTypes`, what's mean -XRankNTypes?
05:32:38 <Cale> do x <- getLine; print (reverse x)
05:32:58 <Cale> Here, reverse :: String -> String is a pure function.
05:33:02 <deeflex> ik, Cale hmmf ok.
05:33:38 <Cale> ManateeLazyCat: See the "forall a." in the type there?
05:33:42 <Cale> ManateeLazyCat: It's that.
05:34:03 <Cale> Basically, the ability for functions to demand that their parameters be polymorphic values.
05:35:05 <ManateeLazyCat> Cale: I found a problem, if i use "{-# OPTIONS_GHC -XRankNTypes #-}" can pass compile, if i use "{-# LANGUAGE -XRankNTypes #-}" GHC report "ghc: panic! (the `impossible` happend)"
05:35:24 <Cale> {-# LANGUAGE RankNTypes #-}
05:35:45 <Cale> GHC doesn't handle misparsing of LANGUAGE pragmas very well
05:36:28 <ManateeLazyCat> Cale: Thanks.
05:37:16 <inbuninbu> Cale,BONUS: it would be easier if i could derive Enum from my data type, but it won't let me
05:37:55 <ivanm> :o what kind of weird datatype do you have that it can't derive Enum?
05:37:58 <deeflex> Cale, ye for definitions. Just tried removing 'let' and I got an error.
05:38:20 <BONUS> ivanm: a data type with fields?
05:38:40 <ivanm> BONUS: I've derived Enum for records before, IIRC
05:39:05 <ivanm> the only time I couldn't was when I had a field with a RandomGen or something, or when I had a function...
05:39:11 <BONUS> i don't recall ever doing that
05:39:18 * ivanm tests
05:39:54 <BONUS> to derive Enum, all constructors have to be nullary afaik
05:39:55 <ivanm> hmmm, you're right
05:40:08 * ivanm must be remembering it wrong
05:40:16 <ivanm> nullary = constructor only?
05:40:27 <inbuninbu> ivanm: "(`Payload' has non-nullary constructors)"
05:40:38 <ivanm> so it can only derive Enum for newtypes and things like A | B | C | ... ?
05:40:52 * ivanm thought as long as all the fields were instances of Enum, it could derive them...
05:41:35 <doserj> instantiating Enum for something like data A = A Int | B Int is non-trivial
05:43:00 <ivanm> *nod*
05:43:09 <ivanm> doserj: because B 1 might be < A 2 ?
05:43:37 <quicksilver> you can derive Ord
05:43:39 <quicksilver> just not Enum
05:43:44 <quicksilver> maybe that's what you were thinking of?
05:43:51 <ivanm> oh, yeah :s
05:44:01 * ivanm bangs his head against a convenient wall
05:44:50 <inbuninbu_> too bad ord won't help me...
05:45:25 <ivanm> anyone know why hmatrix had 0.5.2.1 released two days after 0.5.2.0 was released?
05:46:22 <quicksilver> inbuninbu_: why would deriving Enum for your datatype help you?
05:46:33 <quicksilver> inbuninbu_: I don't understand what you'd use it for.
05:51:56 <inbuninbu_> quicksilver: onelinecase n = lookup n $ zip (fromEnum payload) [putTversion,putRversion,..]
05:53:09 <BONUS> i still don't understand which function you're using those big pattern matches in. what does that function do
05:53:17 <quicksilver> inbuninbu_: but would putTversion, putRversion have the same type?
05:53:25 <quicksilver> it seems to me they wouldn't
05:53:29 <quicksilver> so you're not putting them in a list.
05:53:46 <inbuninbu_> quicksilver: yes. they both are of type Put
05:53:48 <quicksilver> You have to write the case statement once. If you think that's boilerplate, fair enough.
05:53:56 <quicksilver> you certainly shouldn't have to write them more than once.
05:54:02 <lilac> seems like you should be able to derive Enum if there's one Enum field per constructor, or all the fields are Enum and Bounded
05:54:03 <quicksilver> inbuninbu_: no, because they have parameters don't they?
05:54:20 <quicksilver> lilac: Bounded doesn't implie finitely enumerable.
05:54:27 <quicksilver> lilac: oh, Enum *and* bounded. sorry.
05:54:30 <quicksilver> lilac: yes, agreed.
05:54:41 <quicksilver> inbuninbu_: aren't they like a -> b -> c -> Put ?
05:54:44 <inbuninbu_> quicksilver: nope, they are all of type PAyload -> Put
05:54:53 <lilac> quicksilver: i'm not sure it's a /useful/ Enum instance though
05:55:07 <quicksilver> basically you have to write one case statement in your program.
05:55:13 <quicksilver> it shouldn't be necessary to write more than one.
05:55:24 <inbuninbu_> quicksilver: *Main> :t putRversion
05:55:24 <inbuninbu_> putRversion :: Payload -> PutM ()
05:55:24 <inbuninbu_> *Main> :t putTversion
05:55:25 <inbuninbu_> putTversion :: Payload -> PutM ()
05:55:29 <quicksilver> you should be able to write a generic destructor
05:55:35 <quicksilver> inbuninbu_: did you paste some code yet?
05:55:57 <inbuninbu_> quicksilver: i did, i'm going to post some more in a minute, per BONUS's request
05:57:21 <lilac> if you have 'data Foo = A | B X | C X Y', GHC could generate 'foo :: a -> (X -> a) -> (X -> Y -> a) -> Foo -> a' (is this a catamorphism?)
05:58:22 <lilac> indeed, i thought that's how GHC internally represents boxed data
05:59:06 <inbuninbu_> BONUS,quicksilver:putPayload p = case p of
05:59:06 <inbuninbu_>   Tversion _ _ -> putTversion p;Rversion _ _ -> putRversion p;  Tauth _ _ _ -> putTauth p
05:59:50 <inbuninbu_> and it goes on and on
05:59:50 <quicksilver>  inbuninbu_ well to be honest I don't see a problem with that.
06:00:06 <quicksilver> you've got N functions to call, you have to write them all once.
06:00:16 <quicksilver> if you had to write them twice, that would be annoying.
06:00:35 <quicksilver> but if you put the actual complete code in hpaste I may be able to suggest something
06:00:46 <inbuninbu_> quicksilver: i know it works. it's just it would be nice if i could zip them all up, like with lookup
06:01:11 <quicksilver> I don't see why it would be nice.
06:01:19 <quicksilver> I don't see why it's nice to turn a case statement, which is a fast dispatch
06:01:24 <quicksilver> into a slow list-based dispatch.
06:01:42 <quicksilver> I also don't think it's significantly shorter.
06:02:32 <inbuninbu_> quicksilver: i didn't think there was any significant difference between lookup and case. shows what i know, i guess :-)
06:02:50 <quicksilver> lookup is O(n) - the length of the list.
06:03:01 <quicksilver> case is, sort-of, constant time.
06:03:11 <quicksilver> it's certainly conceptually constant time.
06:04:44 <inbuninbu_> quicksilver: ok. i just assumed since the list is known at compile time, the compiler would optimize it
06:04:54 <inbuninbu_> and make it constant time
06:05:01 <eu-prleu-peupeu> hello
06:05:24 <EvilTerran> inbuninbu_, unfortunately, i don't believe recursive functions are inlined at all
06:05:54 <quicksilver> right, GHC doesn't do any unrolling yet.
06:05:59 <ivanm> EvilTerran: otherwise, the entire program could be "run" during compilation if it doesn't require any inputs?
06:06:14 <quicksilver> and it doesn't do constant folding on recursive data types either
06:06:26 <quicksilver> still I'm not quite sure that's the point.
06:06:41 <quicksilver> I honestly don't see why the lookup/fromEnum version is preferable even in principle
06:06:57 <quicksilver> why associate a synthetic number (fromEnum) with constructors just to use it to look up in a list?
06:07:20 <quicksilver> even ignoring issues of runtime complexity, it seems less attractive to me not more.
06:08:05 <EvilTerran> ivanm, sure, if you don't mind compilation failing to terminate sometimes
06:08:11 <ivanm> heh
06:08:44 <quicksilver> I imagine any unroll/inline pass under consideration woudl have termination guarantees ;)
06:08:46 <ivanm> and being a lot slower than actually running the program
06:08:56 <quicksilver> experimental unrolling work suggests it can be a huge performance benefit.
06:10:51 <inbuninbu_> quicksilver: i just wanted to shorten code. but looking at it, the payoff isn't that great, like you said
06:20:27 <inbuninbu_> anyway, thanks guys!
06:48:39 <b_jonas> hello
06:49:06 <gwern> i like pie
06:49:07 <lambdabot> gwern: You have 2 new messages. '/msg lambdabot @messages' to read them.
06:49:12 <gwern> @messages
06:49:12 <lambdabot> kowey said 4h 19m 28s ago: gitit-2009-06-10T10:26 uploaded (plus I now have an update-all.sh which makes this more mindless)
06:49:12 <lambdabot> tux_rocker said 3h 6m 8s ago: The wiki search seems to be broken for pages with spaces. Try searching for 'buildbot' and clicking either of the top two results.
06:49:21 <b_jonas> I have a vague question. I'm looking for a coroutine monad or monad transformer that allows me to switch between coroutines explicitly, but I'm not sure how exactly it would work
06:49:52 <PeakerWork> b_jonas: ContT?
06:49:57 <PeakerWork> b_jonas: or something higher-level?
06:50:03 <b_jonas> that is, whether it would encapsulate just one coroutine and have a run which would return when that yields, or whether it would switch between multiple coroutines like a restricted contT
06:50:12 <b_jonas> PeakerWork: yes, it's certainly possible to restrict ContT
06:50:14 <PeakerWork> b_jonas: look at roconnor's http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5308
06:50:15 <b_jonas> but that's not trivial
06:50:22 <b_jonas> so I'm wondering both if that's the best way,
06:50:29 <b_jonas> and whether there's an existing library implementation.
06:50:41 <PeakerWork> or is that someone else?
06:50:47 <PeakerWork> oh its mmorrow's, oops
06:51:02 <b_jonas> I seem to remember there was also some kind of example in some monad tutorial,
06:51:14 <PeakerWork> b_jonas: isn't that paste almost exactly what you need?
06:51:17 <b_jonas> which showed how you ran two computations concurrently and stop when the first stops
06:51:24 <b_jonas> PeakerWork: looking
07:00:03 <b_jonas> looks quite complicated. I'm lost in the heaps of type variables and don't know where to start. I guess maybe this is another example of something I have to write first to understand.
07:00:12 <b_jonas> thanks for the link anyway
07:00:22 <b_jonas> it may help me _after_ I write my version :-)
07:02:20 <PeakerWork> b_jonas: writing coroutines on top of callCC confused the hell out of me too :)
07:02:32 <lilac> b_jonas: you are trapped in a twisty maze of type variables, all alike
07:02:37 <PeakerWork> b_jonas: do you think there's a good alternative except using/reimplementing something like ContT?
07:02:57 <PeakerWork> I dislike Haskell conventions of using single-letter names even where names *could* pass useful information
07:03:23 <b_jonas> PeakerWork: I know, that confuses me too
07:03:27 <b_jonas> that's why I said it wasn't trivial
07:03:33 <PeakerWork> data Accessor whole part = ... ; and not   data Accessor a b = ...
07:03:43 <b_jonas> PeakerWork: and I don't know if there is a different implementation
07:03:47 <b_jonas> that's part of why I'm asking
07:17:28 <jeffersonheard> are there comments in cabal files?
07:17:47 <dcoutts> jeffersonheard: -- but they have to be on a line on their own
07:17:52 <jeffersonheard> k
07:17:52 <dcoutts> not at the end of another line
07:18:06 <dcoutts> since tool flags use --
07:53:15 <kowey> does anybody know what the latest thinking is on hacking a hackathon at ICFP this year?
07:53:21 <kowey> *having :-)
07:56:17 <Lemmih> Isn't there always a hackathon at the ICFP.
07:56:54 <Lemmih> Err, s/./?/
07:57:07 <kowey> has somebody stepped up and taken charge of this?
07:57:25 * kowey will not be there and is therefore not volunteering
07:58:02 <skorpan> Lemmih: "?sn't there always"
07:58:03 <skorpan> har har har
08:05:47 <lilac> skorpan: s/./!/g
08:06:42 <skorpan> lilac: but that becomes "!!!!!!!!!!!!!!!" doesn't it?
08:18:02 * QtPlaty[HireMe] ponders "Would it a good idea to have a type class "Relation" that had instances of list, hashes and functions, with a unified lookup operator for all of them?
08:18:06 <QtPlaty[HireMe]> "
08:22:11 <lilac> QtPlaty[HireMe]: 'Mapping' might be a better name. 'Relation' usually means a set of pairs (or a mapping from (a, a) to Bool)
08:22:42 <QtPlaty[HireMe]> lilac: I was thinking Relation in the mathmatical sence.
08:23:13 <QtPlaty[HireMe]> And mapping is already used.
08:23:23 <QtPlaty[HireMe]> well Map is.
08:26:59 <lilac> QtPlaty[HireMe]: I was thinking Relation in the mathematical sense too (a relation on set A being a subset of A x A)
08:28:07 <QtPlaty[HireMe]> lilac: A relation between sets A and B being a subset of A x B or are we thinking of diffrent things.
08:29:32 <QtPlaty[HireMe]> Functions are a type or relation, and lists can be seen as subsets of N x A (with further restrictions) and Maps/Hashes are also A x B
08:30:35 <quicksilver> QtPlaty[HireMe]: but the ones you can lookup, generally, are functions
08:30:48 <quicksilver> QtPlaty[HireMe]: a funciton is a single-valued relation, defined everywhere
08:30:56 <quicksilver> although it's common to relax 'defined everywhere'
08:30:59 <QtPlaty[HireMe]> quicksilver: True.
08:31:01 <quicksilver> (which makes it a partial function)
08:31:07 <tiedtoatree> where can i read about how lists are implemented in Haskell? and generally how one figures out the time complexity of a haskell function?
08:31:21 <quicksilver> tiedtoatree: lists in haskell are cons cells, like in lisp and ML
08:32:09 <lilac> QtPlaty[HireMe]: it sounds like you want a type class for functions, not for relations, in any case?
08:32:10 <mib_leftyi> hello
08:33:05 <QtPlaty[HireMe]> lilac: Well I wish to include functions, and the things that look like functions when you look at them from a high enought hight.
08:33:09 <QtPlaty[HireMe]> mib_leftyi: Hi
08:33:12 <lilac> QtPlaty[HireMe]: ... such as ([1,2,3]!!) or (array (1,2) [(1,'a'),(2,'b')]!) or (\x -> ...)?
08:33:35 <QtPlaty[HireMe]> lilac: Exactly.
08:33:58 <lilac> QtPlaty[HireMe]: it hardly seems worthwhile to me, given how easy it is to convert such things into real functions
08:34:19 <tiedtoatree> so is ++ implemented as a series of cons?
08:34:32 <QtPlaty[HireMe]> tiedtoatree: Yes.
08:34:41 <lilac> QtPlaty[HireMe]: that said, I could imagine a 'class Function f a b | f -> a b where ($) :: f -> a -> b'
08:34:59 <lilac> where ($) is pronounced 'thunderbirds'
08:35:09 <EvilRanter> ...
08:35:25 <quicksilver> tiedtoatree: ++ rebuilds the left list and points the tail of it to the right list.
08:35:34 <quicksilver> hence it is O(left list)
08:35:51 <QtPlaty[HireMe]> lilac: What does the bar | represent there?
08:35:59 <mib_leftyi> [if snd (quotRem a 5) == 0 then a else <don't put it in the list> | a <- list] <- what am I missing here? What do I need to put in place of <don't put it in the list> part so I only have a list of numbers that are multiples on 5?
08:36:26 <quicksilver> mib_leftyi: [a | a <- list, snd (quotRem a 5) == 0 ]
08:36:27 <mib_leftyi> this assumes list is filled w/ Integers, of course... :)
08:36:40 <mib_leftyi> quicksilver: wow, ok... thanks!
08:36:43 <lilac> QtPlaty[HireMe]: a functional dependency. it means, there's only one value of a and b for any given value of f
08:36:43 <quicksilver> there is nothing you can put to the left of the | to do exactly this
08:36:49 <quicksilver> but you can put booleans ont he right of the |
08:37:49 <QtPlaty[HireMe]> quicksilver: Is that a ghc extention of a part of standard haskell (I haven't encounted that syntax before)?
08:37:58 <QtPlaty[HireMe]> s/of/or/
08:38:51 <tiedtoatree> so what does (cons 1 (cons 2 (cons 3 nil))) look like in memory? something simple like a linked list?
08:39:19 <QtPlaty[HireMe]> tiedtoatree: Effectively yes.
08:39:21 <quicksilver> tiedtoatree: In my head (cons 1 (cons 3 (cons 3 nil))) *already* looks like a linked list.
08:39:27 <quicksilver> tiedtoatree: in fact, I'd say it is a linked list.
08:40:00 <quicksilver> in memory it looks similar but a haskell implementation is likely to need an extra level of indirection throughout.
08:40:06 <quicksilver> (for laziness)
08:40:35 <tiedtoatree> great! thanks everyone.
08:43:21 <gwern> :t ignore x = x >> return ()
08:43:24 <lambdabot> parse error on input `='
08:43:28 <gwern> :t x >> return ()
08:43:30 <lambdabot>     Couldn't match expected type `m a' against inferred type `Expr'
08:43:30 <lambdabot>     In the first argument of `(>>)', namely `x'
08:43:30 <lambdabot>     In the expression: x >> return ()
08:43:35 <gwern> :t \x -> x >> return ()
08:43:37 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
08:43:49 <gwern> @src sequence_
08:43:49 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
08:44:12 <gwern> :t let ignore x = x >> return () in map ignore
08:44:13 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> [m ()]
08:44:29 <gwern> :t let ignore x = x >> return () in mapM_ ignore
08:44:30 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
08:44:55 <gwern> hm. that looks like a nicer definition than using foldr, but I don't know if the left-to-rightness of sequence is important
08:45:16 <EvilRanter> isn't mapM_ defined in terms of sequence_, though?
08:45:19 <EvilRanter> ?src mapM_
08:45:19 <lambdabot> mapM_ f as = sequence_ (map f as)
08:45:23 <lilac> QtPlaty[HireMe]: it's a GHC extension. quicksilver was coincidentally talking about | in list comprehensions.
08:45:36 <gwern> EvilRanter: drat!
08:45:54 <lilac> QtPlaty[HireMe]: {-# LANGUAGE FunctionalDependencies #-}
08:45:59 <gwern> but wait, why is a map using a fold?
08:46:02 <QtPlaty[HireMe]> lilac: URL for documentation or is it in someone's paper?
08:46:13 <lilac> QtPlaty[HireMe]: IIRC it's actually | f -> a, f -> b that you need
08:46:17 <pumpkin> gwern: because it doesn't return anything
08:46:23 <pumpkin> (useful)
08:46:25 <EvilRanter> gwern, er, because maps are folds?
08:46:25 <gwern> a fold forces dependencies; when you're using mapM_, you're trying to say that each item is independent
08:46:34 <EvilRanter> you are?
08:46:46 <EvilRanter> they don't strike me as independent in, eg, a MonadState
08:46:53 <gwern> EvilRanter: I know I've only used mapM_ in the context of things like mapM_ (forkIO)
08:46:53 <lilac> QtPlaty[HireMe]: http://citeseer.ist.psu.edu/jones00type.html
08:47:01 <pumpkin> you still want to sequence them
08:47:08 <lilac> QtPlaty[HireMe]: these days, type families seem to be more in vogue than fundeps
08:47:09 <PeakerWork> gwern: a fold allows dependencies, it doesn't force them
08:47:17 <gwern> pumpkin: why's that?
08:47:35 * QtPlaty[HireMe] seems to never stop learning new stuff about Haskell.
08:47:53 <pumpkin> gwern: because the state of the world depends on it! :P
08:48:06 * gwern doesn't follow
08:48:34 <pumpkin> gwern: if they all started with the "same" RealWorld, they'd all be splitting reality off into parallel universes
08:48:48 <pumpkin> instead, they need to work off each other's changes to the real world, so we can stay in the same universe ;)
08:49:15 <gwern> obviously you're making some arcane joke related to the implementation of the IO monad which I'm not appreciating, nor would care much about
08:49:26 <pumpkin> my point is, they aren't indepdendent
08:49:39 <pumpkin> they need to be sequenced together for them to do anything meaningful
08:49:47 <pumpkin> even if separate forkIOs "feel" independent
08:50:52 * kowey waves a pom-pom - http://www.haskell.org/pipermail/haskell-cafe/2009-June/062678.html
08:51:08 <pumpkin> rah rah!
08:55:28 <jeffersonheard> is there any way to get the runtime to give a more explicit error than "Map.find: element not in the map", like with a line number or stack trace or something?
08:55:54 <Botje> write a wrapper for Map.find?
08:56:10 <Botje> then again, that won't change much :}
08:56:28 <jeffersonheard> Botje: no.  I mean, at least I'd get the key if there was an exception...
08:56:29 <pumpkin> use the CPP to substitute __LINE__ and stuff in for you?
08:57:15 <jeffersonheard> pumpkin: is there any good reason GHC can't do that if compiled with -g or some such?
08:57:23 <Botje> jeffersonheard: what find function is this?
08:57:24 <pumpkin> probably not :)
08:57:27 <jeffersonheard> Map.!
08:57:30 <Botje> Data.Map doesn't have it
08:57:36 <jeffersonheard> it's not exported
08:57:42 <pumpkin> jeffersonheard: but it should be coming soon
08:57:47 <pumpkin> with all that stack trace stuff
08:57:48 <jeffersonheard> Data.Map.! == Data.Map.find
08:57:51 <pumpkin> even though we still won't know the key
08:57:53 <Botje> oh
08:58:36 <Botje> don't use !, then? :)
08:58:48 <Botje> or wrap ! with a Debug.trace thing
08:59:01 <quicksilver> shadow (!) with a local defintion
08:59:04 <quicksilver> which gives better errors
08:59:09 <quicksilver> is probably your best option
08:59:16 <jeffersonheard> yeah, probably...
08:59:23 <quicksilver> (call the safe lookup function and give a sensible error if it returns not found)
08:59:38 <jeffersonheard> not entirely sure this is in my code
08:59:55 <quicksilver> let m ! k = case lookup m k of Just v -> v; Nothing -> error $ "lookup failed for " ++ show k
09:00:03 <quicksilver> which will chuck a show constraint on k, of course
09:00:11 <quicksilver> but hopefully that's going to be ok :)
09:00:40 <gwern> quick question: what do y'all make of the idea of adding 'ignore :: m a -> m (); ignore x = x >> return ()' to Control.Monad?
09:01:21 <maltem> gwern, i guess it wouldn't hurt :)
09:01:38 <quicksilver> I like it.
09:01:45 <quicksilver> Although it means a new base version of course.
09:01:46 <quicksilver> Yay!
09:02:17 <gwern> quicksilver: presumably there's going to be a new base version eventually anyway
09:02:31 <quicksilver> right
09:02:39 <quicksilver> I was being flippant. (flipping?)
09:02:55 <gwern> hm. I'm doing a recursive grep through my sources for examples of '>> return ()', but I have so many haskell source dirs that it's only up to the 'b's
09:03:03 <doserj> quicksilver: adding things doesn't imply a major version bump
09:03:26 <gwern> (it's very handy, incidentally, to have most of the haskell world on your hard drive so you can search for idioms when you're arguing for something :)
09:03:52 <gwern> doserj: I though the minor ones were only supposed to be bugfixes? and that top level additions or removals or type changes had to be major
09:04:29 <doserj> removals are major, additions not. (if you don't import qualified, it's your own fault)
09:05:06 <gwern> argh. so slow! up to 'bi'
09:05:15 <gwern> I shouldn't've skimped on the hard drive building this computer!
09:05:36 <SamB_XP> gwern: what kind of skimping did you do?
09:06:01 <gwern> SamB_XP: bought only a ~7600rpm drive, iirc
09:06:07 <gwern> thought about going up, but...
09:06:13 <SamB_XP> gwern: as opposed to?
09:06:23 <SamB_XP> also, that doesn't sound like the best speed measure to me
09:06:27 <gwern> 9k or 16k iirc are the next major steps up
09:06:27 <seliopou> anybody remember off the top of their heads in which version of base the types for containers changed?
09:06:40 <p_l> gwern: shouldn't that be be 7200?
09:06:47 <SamB_XP> well, I guess it might affect access time
09:06:51 <SamB_XP> well, would
09:06:56 <gwern> SamB_XP: for random access seeks like grepping a couple gigabytes? rpm is iirc the measure of interest
09:07:02 <SamB_XP> but there may be other factors?
09:07:30 <SamB_XP> gwern: well, RPM tells you how long it takes to spin once
09:07:43 <p_l> gwern: for grepping large amount of data, tons of RAM plus good cache ;-)
09:07:46 <SamB_XP> but then there's also how long it takes to move from one track to the next
09:07:55 <gwern> SamB_XP: of course there are other factors; like the number of disk heads matter
09:08:05 <SamB_XP> or, perhaps more importantly, from hub to rim
09:08:23 <quicksilver> doserj: are you sure that's true?
09:08:33 <quicksilver> doserj: in practice, nobody imports qualified.
09:08:40 <quicksilver> doserj: so all additions can and will break code.
09:09:09 <gwern> here we go, I bought a 'HD 500G|SAMG 7K 16M SATA2 HD501LJ '
09:09:23 <SamB_XP> and then there's the distribution of data across the tracks, which would affect how much radial motion was typically needed
09:10:16 <doserj> quicksilver: just checked, that is what is specified on http://www.haskell.org/haskellwiki/Package_versioning_policy
09:10:20 <quicksilver> doserj: ah, you're right.
09:10:25 <quicksilver> doserj: so the PvP is broken, but pragmatic.
09:10:26 <gwern> could've gone all the way up to 15k; why did I decide to go with more ram...
09:10:31 <quicksilver> possibly that's the right choice.
09:10:42 <quicksilver> it's particularly glaring for base, though.
09:11:02 <quicksilver> since modules from base are very rarely imported qualified, but they are imported in all kinds of haskell programs.
09:11:06 <doserj> for basic libraries like Control.Monad, Data.List, etc, it is a bit problematic, yes
09:11:11 <jeffersonheard> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5731#a5731
09:11:59 <doserj> quicksilver: you don't have to import qualified, though. it also sufficient to give an explicit import list
09:12:20 <jeffersonheard> in that last hpaste, can anyone tell me how using nothing but get/put/free on a non-full cache can occasionally lead to the IntMap.findMin (times cache) not existing in (store cache)
09:12:21 <doserj> which is a bit more reasonable
09:12:34 <jeffersonheard> it seems to happen at entirely random times.
09:12:34 <SamB_XP> quicksilver: what did you say would cause a bump in base's version?
09:12:52 <quicksilver> SamB_XP: adding ignore to Control.Monad, in particular
09:13:03 <quicksilver> SamB_XP: but obviously the general discussion is just about adding any new functions to an API
09:13:04 <SamB_XP> they're bumping the second component anyway
09:13:29 <SamB_XP> ... but hey, that's better than the first component like before, isn't it?
09:13:33 <quicksilver> doserj: I find both import qualified, and explicit import lists, ugly/inconvenient in slightly different ways.
09:13:33 * pumpkin petititions for &&&, ***, first, second, and <$> to be added to Prelude :P
09:13:51 * jeffersonheard seconds pumpkin's petition
09:14:15 <SamB_XP> pumpkin: ooh, that'd be kinda nice!
09:14:26 <pumpkin> not sure where to petition though :)
09:14:31 <SamB_XP> libraries@
09:14:33 * pumpkin writes a sign and holds it up
09:14:37 <pumpkin> oh
09:14:47 <doserj> quicksilver: I don't think explicit import lists are ugly, there is not enough tool support to keep them synchronized, though
09:14:53 <SamB_XP> oh, but doesn't that need Control.Arrow in base?
09:15:00 <SamB_XP> (is it in base?)
09:15:17 * doserj would like &&&, ***, etc. specialized ot (->)
09:15:20 <byorgey> maybe we could just have function-specific versions of &&&, ***, first, and second in base
09:15:21 <SamB_XP> I guess ideally Prelude would *not* be in base
09:15:40 <byorgey> then if you want the general Arrow versions you can just hide them in the Prelude, or import Arrow qualified, or something
09:15:43 <SamB_XP> doserj: that'd mean you'd need to hide them if you wanted to use the Arrow versions :-(
09:15:50 <doserj> SamB: yes
09:15:57 <SamB_XP> that's not fun
09:16:07 <byorgey> but the point is that MOST of the time people only want the (->) versions.
09:16:23 <SamB_XP> byorgey: &&& and *** would look horrible qualified ...
09:16:35 <pumpkin> byorgey: it still wouldn't hurt to just put in the regular ones, except that it might scare people if they :t'ed them
09:16:37 <byorgey> that's true.  what's so bad about hiding them?
09:16:38 <EvilTerran> put 'em in Data.Tuple
09:16:49 <doserj> you can also call the Arrow version &&&& and **** :)
09:16:53 <byorgey> yup, Data.Tuple is where they ought to go
09:16:57 <EvilTerran> or Data.Function
09:17:00 <pumpkin> &&&&&&&&&&&&&&& and *********************
09:17:00 <SamB_XP> @doc Control.Arrow
09:17:00 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Arrow.html
09:17:06 <EvilTerran> (although surely that should be Control.Function...)
09:17:23 <byorgey> SamB_XP: actually, I'm pretty sure Control.Arrow is already in base anyway
09:17:26 <PeakerWork> Is it possible for SECs (like first, second) to be composed alongside getters, like data-accessors/lens?
09:17:27 <pumpkin> it is
09:17:39 <ray> preludes suck
09:17:42 <SamB_XP> okay, Control.Arrow is in base so there's no technical issue with including the Arrow versions in Prelude
09:17:50 <pumpkin> yeah
09:17:55 <SamB_XP> byorgey: yes, I just checked with @doc
09:17:57 <pumpkin> only downside is scaring people who type :t I think
09:18:05 <SamB_XP> byorgey: the URL reveals that it is still in base
09:18:09 <pumpkin> we should change their type signature to use ~> infix
09:18:10 <PeakerWork> Data accessor setters are limited to not modifying the whole's type, whereas first/second/SECs in general do modify the whole's type
09:18:39 <ray> ~> is nice
09:18:43 <SamB_XP> PeakerWork: whole type?
09:18:44 <ski> (`SEC' ?)
09:18:50 <pumpkin> you accidentally the whole type?
09:18:57 <ray> it represents a vagueomorphism, which is what arrows are
09:19:15 <lilac> gwern: fwiw, i have 'ignore = (>> return ())' in Utils.hs in one of my projects
09:19:23 <gwern> which one?
09:19:28 <SamB_XP> anyway, wouldn't including less polymorphic versions in Prelude be Haskell 98 all over again?
09:19:35 <byorgey> ski: 'Semantic Editor Combinators', presumably
09:19:41 <lilac> gwern: it's about 3% of a c++ parser
09:19:42 <ray> maximum polymorphism
09:19:55 <pumpkin> ULTIMATE POLYMORPHISM
09:19:58 <ray> generalize maps and folds to functors
09:19:58 <pumpkin> multimorphism
09:20:02 <ski> (oh .. a la conor's combinators ?)
09:20:07 <ray> not folds
09:20:11 <ray> that's a different class
09:20:20 <ray> infinimorphism
09:20:24 <byorgey> ski: conal, but yes
09:20:26 <ray> or vagueomorphism
09:20:30 <SamB_XP> lilac: what's the difference between that and Language.C?
09:20:37 <ray> it's annoying how there's two different meanings of "morphism" at work here
09:20:37 <ski> byorgey : sorry, that's what i meant yes
09:20:50 <ski> (my fingers apparently mixed the two names up)
09:20:55 <byorgey> hehe =)
09:20:57 <lilac> SamB_XP: two pluses :)
09:21:16 <lilac> SamB_XP: plus drastically different design goals
09:21:50 <ray> drastically
09:21:56 <SamB_XP> lilac: I was implying that Langauge.C also parses about 3% of C++
09:22:00 <ski> it might be nice if one could reexport operations with more restricted types .. and then, import both those and the original, and get the general types back
09:22:11 <lilac> SamB_XP: yeah, a different 3% ;)
09:22:12 <SamB_XP> the joke being that C++ is ...
09:22:27 <ski> (since istr the system keeps track of whether they come from the same source anyway, no ?)
09:22:28 <SamB_XP> > 1/0.03
09:22:30 <lambdabot>   33.333333333333336
09:22:45 <ray> generalize ($) to a -> a!
09:22:54 <lilac> ski: yeah, that'd be neat
09:22:57 <SamB_XP> 33 and 1/3 times as complicated to parse as C
09:23:04 <ray> if you use it wrong you'll get type errors anyway
09:23:16 <ski> ray : which two meanings of `morphism' ?
09:23:20 <lilac> SamB_XP: is that all? i assume that means you're comparing C++98 to C99? :)
09:23:31 <quicksilver> doserj: if there was tool support to manage the import lists that would help, but...
09:23:35 <ray> morphism as in "monomorphism" and morphism as in "catamorphism"
09:23:43 <quicksilver> doserj: isn't it nasty to have to keep running tools over your source code to update things
09:23:44 <SamB_XP> lilac: no, to GNUC, actually
09:23:50 <ray> one of those shouldn't use "ism"
09:23:55 <ski> ray : why is that different meanings of `morphism' ?
09:23:56 <SamB_XP> isn't that what Language.C parses?
09:24:12 <ray> consider that one is a noun and one is an adjective
09:24:16 <byorgey> ray: both of those are names for arrows in some category.
09:24:28 * SamB_XP also thinks the "generalize" thing would be neat
09:24:28 <byorgey> no, both are nouns
09:24:43 <EvilTerran> it's (monomorph)ism and cata(morphism), isn't it?
09:24:49 <ray> yes
09:24:49 <doserj> quicksilver: you don't have to do it more frequently than compiling your code
09:24:50 <SamB_XP> the trouble being that it'd be a new keyword
09:24:51 <ski> a `monomorphism' is a `morphism' which is `monomorphic', a `catamorphism' is a morphism in some category satisfying some property
09:25:14 <SamB_XP> how could the need for a new keyword there be prevented?
09:25:17 <byorgey> EvilTerran: what? why?
09:25:37 <byorgey> mono(morphism), epi(morphism), ...
09:26:01 <SamB_XP> I thought monomorphism was an adjective meaning monomorphic ...
09:26:02 <EvilTerran> byorgey, i dunno, i'm just extrapolating from what seems to make most sense to me
09:26:06 <SamB_XP> er.
09:26:16 <SamB_XP> no, a noun version of the adjective monomorphic
09:26:31 <ray> hence "monomorphism restriction" for example
09:26:31 <SamB_XP> referring to the property itself
09:26:33 <doserj> quicksilver: but I think we agree mostly
09:26:45 * SamB_XP wonders if he fed the cats
09:26:46 <byorgey> SamB_XP: indeed.
09:27:39 <uzytkownik> > pl \x -> (f x, g x)
09:27:41 <lambdabot>   <no location info>: parse error on input `\'
09:28:02 * byorgey suddenly realizes that 'monomorphic' has two entirely different meanings
09:28:05 <ski> @pl \x -> (f x, g x)
09:28:06 <lambdabot> liftM2 (,) f g
09:28:36 <byorgey> depending whether it is referring to a type or an arrow in a category
09:28:46 <byorgey> le sigh.
09:28:54 <uzytkownik> ski: Thank you. Wiki is not clear what syntax should be used...
09:29:01 <lilac> import Control.Arrow ((***) :: (a -> b) -> (a' -> b') -> (a, a') -> (b, b'), (&&&) :: ...)
09:29:04 <ray> that is what i mean
09:29:23 <ski> byorgey : yes `monomorphic' and `polymorphic' vs. `monomorphic' and `epimorphic' :)
09:29:31 <byorgey> right, exactly =)
09:29:50 <ski> @help pl
09:29:52 <lambdabot> pointless <expr>. Play with pointfree code.
09:30:01 <byorgey> hmm, the word 'morphism' is sort of odd etymologically.
09:30:18 <ski> ray : ok
09:30:34 * byorgey ponders
09:31:29 <ski> lilac : if we even have something like JohnMeachams superclass proposal (?), we should allow restricting operations in superclasses, too
09:32:05 <PeakerWork> SamB_XP: whole type as in the whole tuple in the case of first/secodn
09:32:07 <quicksilver> doserj: yes, I know. I just don't like part of my code to have to be "written to" by the tool I run to compile it.
09:32:08 <PeakerWork> @type first
09:32:09 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
09:32:13 <quicksilver> doserj: I don't know why I don't like it, but I don't.
09:32:17 <Taejo> @where listToMaybe
09:32:18 <lambdabot> I know nothing about listtomaybe.
09:32:18 <quicksilver> doserj: it feels wrong.
09:32:26 <pumpkin> @index listToMaybe
09:32:27 <lambdabot> Data.Maybe
09:32:27 <Taejo> @hoogle [a] -> Maybe a
09:32:28 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
09:32:29 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
09:32:29 <lambdabot> Prelude head :: [a] -> a
09:32:35 <quicksilver> what if it doesn't have a steady state, for example ;)
09:32:44 <PeakerWork> SamB_XP: you can change the type of the whole tuple with first and second.  With lens you can't, but you can compose the getter as well as the setter. I wonder if its possible to get both advantages
09:32:50 <dirk_> > break ('c'==) "abcd"
09:32:52 <lambdabot>   ("ab","cd")
09:32:53 <ski> lilac : btw, that (`import ...') would be a nice idea, even if one couldn't restrict operations .. i sometimes list the types of imported (and exported) operations in comments, like that
09:33:12 <dirk_> I want only the first part
09:33:35 <quicksilver> dirk_: so pattern match it out
09:33:37 <ski> > takeWhile ('c' /=) "abcd"
09:33:39 <lambdabot>   "ab"
09:33:41 <quicksilver> let (x,y) = break ....
09:33:44 <quicksilver> and use the 'x'
09:33:49 <dirk_> ok
09:33:51 <quicksilver> of course, takeWhile is more sensible for this case.
09:33:55 <ski> `takeWhile', folks !
09:34:03 <quicksilver> but I think it's good to understand how to use pattern matches to unpack pairs
09:34:07 <quicksilver> you'll want it sooner or later.
09:34:18 <ski> yes
09:35:33 * ski wonders why `break' and `takeWhile', but not `span' and `dropWhile' is in LB `src'
09:35:42 <Taejo> @pl (\z -> z - f z/f' z)
09:35:43 <lambdabot> ap (-) (liftM2 (/) f f')
09:36:06 <doserj> quicksilver: you need to trust the tool to do the right thing, otherwise you feel like you lose control, I guess. We switched from assembler to higher-level languages because we trust the compiler nowadays
09:38:55 * doserj doesn't yet trust fancy tools, like eclipse has, either...
09:41:22 <ski> gwern : i've sometimes wanted `done :: Monad m => m (); done = return ()' too .. but maybe people feel that's too trivial ?
09:41:52 <ski> `if blah then done else do bleh' looks nice :)
09:42:14 <doserj> ski: when (not blah) bleh
09:42:24 <ski> yes, but consider a `case'
09:43:04 <Taejo> @hoogle Complex a -> a
09:43:05 <lambdabot> Data.Complex imagPart :: RealFloat a => Complex a -> a
09:43:06 <lambdabot> Data.Complex magnitude :: RealFloat a => Complex a -> a
09:43:06 <lambdabot> Data.Complex phase :: RealFloat a => Complex a -> a
09:43:08 <EvilTerran> i believe the conventional name would be "skip"
09:43:16 * ski took an `if'-`then'-`else' because he didn't want to write as much .. but should have taken `case', instead
09:43:33 <ski> i suppose that could work, as well
09:44:01 <ski> (it may be i've seen `done' in "Haskell: The Craft of Functional Programming" ..)
09:44:35 <alexsura1i> Is there a way to get the nth root of a number?
09:44:35 <ski> (at least that's where i've seen `(>@>)', which now seems to be called `(>=>)')
09:44:49 <ski> > 27 ** (1/3)
09:44:50 <lambdabot>   3.0
09:44:53 <ski> > 64 ** (1/3)
09:44:55 <lambdabot>   3.9999999999999996
09:45:21 <jeffersonheard> Weird.  Okay, so that problem I reported on earlier seems to be a bug in Data.IntMap
09:45:22 <alexsura1i> Thanks
09:45:36 <jeffersonheard> I switched the data structure to Data.Map and no longer see the clobbering
09:47:12 <ski> @let nthRoot radix radicand = radicand ** recip radix
09:47:14 <lambdabot>  Defined.
09:47:16 <ski> @type nthRoot
09:47:18 <lambdabot> forall a. (Floating a) => a -> a -> a
09:47:35 <ski> > nthRoot 5 32
09:47:38 <lambdabot>   2.0
09:47:44 <Gracenotes> D:
09:47:53 <Lemmih> jeffersonheard: Clobbering?
09:48:15 <gwern> ski: yeah, done probably isn't worthwhile; return () is only a little longer than done
09:48:28 <jeffersonheard> Yeah -- see my cafe post...  I was seeing map entries in Cache.times simply disappear and others fail to be deleted
09:48:36 <Axman6> i think done is a good idea
09:48:47 <mux> return should be called unit or inject or something
09:48:49 <Lemmih> jeffersonheard: URL? I don't subscribe to haskell-cafe@
09:48:51 * Axman6 raises his hand to vote for adding done
09:48:59 <ski> mux : or `pure' :)
09:49:18 * mux nods
09:49:30 <jeffersonheard> http://www.nabble.com/Weird-and-entirely-random-problem...-td23966061.html
09:50:33 <doserj> jeffersonheard: what is actually the problem with the result there?
09:51:02 * mux likes `inject' somehow
09:51:05 <ski> when on the topic of `ignore :: Monad m => m a -> m ()' ..
09:51:18 <ski> @let ma `after` mb = do b <- mb; ma; return b
09:51:20 <lambdabot>  Defined.
09:51:23 <ski> @type after
09:51:25 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
09:51:29 <ski> is handy sometimes, too
09:51:32 <jeffersonheard> well, in the hpasted module, times and store should always be symmetrical.  that is...  "times" should always have as values exactly the keys in "store"
09:51:43 <mux> ski: that's <*
09:51:51 <ski> that may be
09:51:56 <mux> (in an applicative functor setting)
09:52:11 <jeffersonheard> get, put, and free all preserve this invariant
09:52:13 * ski hasn't really looked that closely at all the applicative operations
09:52:15 <ski> mux : ty
09:52:30 <ski> (though i still think some of those operations have bad names)
09:54:09 <Asztal> <**> is a weird name.
09:54:19 <ski> as is `<*>'
09:54:44 <gwern> ok, there goes the email to library
09:54:56 <ski> (about ?)
09:55:05 <Asztal> is <,> a valid name? I have a feeling it's not :(
09:55:27 <gwern> ski: ignore. the thing I've been discussing and mentioning for the last hour or so
09:55:37 <ski> @type (<,>) = () in (<,>)
09:55:38 <lambdabot> parse error on input `,'
09:55:40 <ski> nope
09:55:52 <ski> gwern : ok
09:56:01 <gwern> > let (<,>) = (+) in 1 <,> 2
09:56:02 <lambdabot>   <no location info>: parse error on input `,'
09:56:14 <gwern> > let (<.>) = (+) in 1 <.> 2
09:56:16 <lambdabot>   3
09:56:24 <gwern> guess commas are reserved for lists
09:56:35 <byorgey> and tuples
09:56:44 <ski> and records
09:57:25 <doserj> import and export lists...
09:58:01 <byorgey> record field separators...
09:58:14 <byorgey> oh, ski already said that, whoops =)
09:59:22 <ski> (and list comprehension and pattern guards :)
10:00:38 <doserj> and functional dependencies
10:00:51 <byorgey> COMMAS ARE SPESHUL
10:01:38 <doserj> and context lists
10:02:12 <ski> and coordination in type signatures
10:02:16 <ski>   foo,bar :: Baz
10:04:43 * ski wonders if the "name uses of comma" game is over
10:05:07 <byorgey> that depends whether anyone names any more.
10:05:30 <byorgey> going once... going twice...
10:05:31 <ski> so it's a refutative question
10:05:57 <doserj> fixity declarations
10:06:07 <FliPPeh> If I use "main" somewhere in my code to restart the program, just like a loop, will it some day in the future, after a lot of "main" calls stack overflow, or will that be optimized?
10:06:12 <byorgey> oho!
10:06:50 <gwern> no, not the dreaded tail call question
10:06:53 <gwern> !
10:07:01 <byorgey> FliPPeh: nope, the memory associated with the old calls will get garbage-collected
10:07:17 <FliPPeh> :)
10:07:21 <SamB> FliPPeh: if you do a generalized tail call you're fine
10:07:34 <FliPPeh> I just call it on a single line in a DO block
10:07:52 <byorgey> as long as nothing is supposed to happen after that call to main returns
10:08:06 <SamB> yeah, there'd better be noplace to return to but main's caller
10:08:17 <FliPPeh> Left e      -> do liftIO $ putStrLn ("Failure receiving data: " ++ show e)
10:08:17 <FliPPeh>                   liftIO $ hClose h
10:08:17 <FliPPeh>                   liftIO main
10:08:20 <FliPPeh> Thie is it
10:08:24 <FliPPeh> this*
10:08:38 <hackagebot> fft 0.1.4 - Bindings to the FFTW library. (JedBrown)
10:08:57 <BONUS> do people usually factor out lifting operations
10:09:08 <SamB> FliPPeh: would the program exit without doing anything else if you didn't have that main call there?
10:09:17 <FliPPeh> Yes
10:09:26 <FliPPeh> Well, no
10:09:26 <SamB> well, you're probably safe then
10:09:29 <BONUS> e.g. do a; liftIO $ do a; b; c;
10:09:39 <FliPPeh> It would do nothing
10:09:42 <FliPPeh> Lock up I suppose
10:09:51 <pumpkin> @quote bonus
10:09:51 <lambdabot> No quotes match. Just what do you think you're doing Dave?
10:09:53 <SamB> FliPPeh: eh?
10:09:58 <SamB> what do you mean, lock up?
10:10:14 <FliPPeh> Not lock up
10:10:19 <SamB> I believe when main returns, all threads are killed
10:10:21 <FliPPeh> I have actually no idea what would happen
10:10:28 <jix_> FliPPeh: just try it then
10:10:29 <ski> BONUS : i would usually, i think
10:10:35 <FliPPeh> It's in a try-catch block
10:10:44 <BONUS> yeah me too. less characters to type
10:10:45 <FliPPeh> Captures and exception
10:11:05 <SamB> FliPPeh: oh. I guess you'd overflow some sort of stack, then
10:11:12 <ski> (i suppose in some cases one could expect that some non-`liftIO'ed operations would be inserted later, and then not do it)
10:11:14 <SamB> with all those try/catches piling up
10:11:34 <FliPPeh> How else could I restart there?
10:11:54 <SamB> FliPPeh: well, you could factor out the thing inside the try/catch
10:12:06 <FliPPeh> It's a socket error
10:12:09 <SamB> and call that instead
10:12:13 <FliPPeh> The connection code is in main
10:12:28 <SamB> FliPPeh: I meant, the code that gets called with the exception handler in place
10:12:36 <SamB> you could put that in it's own function
10:12:40 <SamB> realMain, or something
10:12:56 <SamB> then call THAT instead of main in your tail call
10:13:32 <SamB> it'd be nice if there was some kind of tail recursion checker tool ...
10:13:44 <SamB> to see if you're actually doing tail recursion when you want to be
10:13:44 <ski> ah
10:14:03 <ski> @type catch
10:14:04 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
10:14:23 <ski> you want an `IO a -> (IOError -> IO b) -> (a -> IO b) -> IO b' :)
10:14:35 <SamB> ski: eh?
10:15:34 <ski> see <http://martin.jambon.free.fr/extend-ocaml-syntax.html#lettry>
10:15:53 <ski> SamB : actually, i meant that for FliPPeh
10:16:11 <SamB> ski: I'm puzzled a bout why FliPPeh wants it, though
10:16:20 <FliPPeh> It's a bot
10:16:29 <FliPPeh> Automatic recover on connection failure
10:16:35 <ski> i suppose it depends on the structure of FliPPeh's actual code
10:16:46 <SamB> or rather how you came to the conclusion that FliPPeh wants it
10:17:23 <ski> but the case where you want to have a loop, where the body of the loop is inside a "try-catch block", but not the recursive call is what that link was about
10:17:32 <SamB> hmm. I wonder if I can read exception-using ML
10:17:42 <ski> the point is that in `catchBind :: IO a -> (IOError -> IO b) -> (a -> IO b) -> IO b'
10:18:14 <ski> say `catchBind body handler continue', only `body' has the new exception handler, not `continue'
10:19:31 <SamB> ski: how does it get from b to b'?
10:19:50 <SamB> oh, wait, that's supposed to be a right single quote
10:20:03 <ski> that's supposed to be a closing single-quote
10:20:07 <SamB> you do know ` isn't really a left quote, right?
10:20:30 <ski> (yes, but i don't know of a better alternative, rn)
10:20:42 <Zao>  do it like the french  ?
10:20:53 <ray> that's backwards
10:21:12 <Zao> Apparently one is supposed to use the angles like this over here.
10:21:54 <ray> that's rightwards
10:23:10 <ski> (SamB : `Some',`None' is the O'Caml version of `Just',`Nothing')
10:23:14 <dirk_> is there a way to flatten a list ["a","b","c"] -> "abc"
10:23:22 <ski> > concat ["a","b","c"]
10:23:24 <lambdabot>   "abc"
10:23:35 <dirk_> ok
10:23:44 <doserj> do it like the germans, or do it like the french
10:23:50 <glguy> single quotes
10:23:58 <glguy> double quotes
10:24:16 <doserj> actually, do it like the germans, or  do it like the french , I guess
10:24:43 <FliPPeh> !hpaste
10:24:46 <FliPPeh> @hpaste
10:24:47 <lambdabot> Haskell pastebin: http://hpaste.org/new
10:29:38 <uzytkownik> @pl \(x, y) -> (Just x, Just y)
10:29:39 <lambdabot> Just *** Just
10:29:53 <FliPPeh> If anyone has time, please take a look at my code (http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5736#a5736) and help me figure out how to implement part 4 of my TODO list? I already tried doing that with a thread, but it fails for StateT, since threads have to do IO
10:29:56 <FliPPeh> :(
10:30:30 <uzytkownik> @hoogle (***)
10:30:31 <lambdabot> Control.Arrow (***) :: Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
10:38:16 <gwern> huh. what a surprisingly positive response on libraries
10:38:57 <gwern> usually proposals get eaten alive there
10:39:27 <BONUS> for ignore?
10:39:34 * SamB decides to look rather than ask
10:41:45 <gwern> BONUS: yah
10:42:03 <Taejo> @pl \n x -> (,) n <$> x
10:42:03 <lambdabot> (<$>) . (,)
10:42:07 <BONUS> cool. i also like the previous suggestion of return () = done
10:42:13 <gwern> no, it's for my proposal to make ghc insert unsafeCoerces whenever statements don't typecheck, so as to make haskell more friendly to noobs
10:42:16 <gwern> -_-
10:42:27 <BONUS> haha
10:42:32 <gwern> BONUS: well, one thing at a time
10:42:35 <FliPPeh> Spam!
10:42:36 <BONUS> also add goto
10:42:39 <FliPPeh> If anyone has time, please take a look at my code (http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5736#a5736) and help me figure out how to implement part 4 of my TODO list? I already tried doing that with a thread, but it fails for StateT, since threads have to do IO
10:42:43 <gwern> I didn't suggest forkIO's type sig change either, even though that's sensible
10:42:53 <hackagebot> Hieroglyph 3 - Purely functional 2D drawing (JeffersonHeard)
10:43:05 <SamB> gwern: huh, funny how ZMachine is at the beginning of "alphabetical" order ;-P
10:43:18 <gwern> SamB: no, it's perfectly logical
10:43:30 <gwern> you see, my ~/bin goes agda, archive/ZMachine, ...
10:44:03 <conal> ack "functional drawing" -- oxymoron?
10:44:14 <jeffersonheard> latest upload of Hieroglyph fixes OpenGL support seriously
10:44:15 <SamB> is that in ext2fs_dir_entry order?
10:44:30 <jeffersonheard> uh...  yeah.  I guess that package descriptor is left over from when I made the original
10:44:37 <jeffersonheard> could change that in the next release
10:44:40 <jeffersonheard> :P
10:44:43 <conal> jeffersonheard: :)
10:45:32 <Taejo> @pl \n x -> ((,) n) <$> x
10:45:33 <lambdabot> (<$>) . (,)
10:45:39 <conal> jeffersonheard: could even be "functional 2d drawings" if that's what you mean.
10:45:52 <conal> noun==functional, verb==imperative
10:46:21 <jeffersonheard> functional 2d graphics for visualization more like, but yes, that's the general picture.
10:46:30 <conal> sounds good :)
10:46:36 <Taejo> Haskell: where doing is a thing
10:47:02 <conal> as in "haskell: the world's finest imperative programming language"
10:47:14 <jeffersonheard> starting to get a better handle on what a Primitive is, considering making it a typeclass, allowing people to define their own primitives
10:47:41 <conal> jeffersonheard: a handle on a denotational model for Primitive?
10:47:49 <jeffersonheard> gradually
10:47:54 <jeffersonheard> not ready to completely replace it
10:47:55 <jeffersonheard> yet
10:48:11 <jeffersonheard> but yes.  supporting the primitives in OpenGL has given me a much better handle on what they are
10:49:58 <conal> i've been puzzling over memoizing *polymorphic* functions.  anyone ever played with the idea?
10:50:28 <jeffersonheard> also getting closer to a release of a 3D fork of hieroglyph.  main barrier has been caching and supporting buffer objects for larger geometries
10:50:32 <Saizan> conal: so you'd take the concrete type as part of the key?
10:50:47 <jeffersonheard> but getting the cache nailed down today thanks to Neil has solved that problem
10:50:57 <conal> Saizan: perhaps.  in somehow-reified form
10:51:47 <pumpkin> hieroglyph needs support for hieroglyphs!
10:51:48 <conal> Saizan: though with "lazy" (Hughes-style) memoization, one doesn't need to delve into the representation.
10:52:05 <conal> Saizan: so a stable name is enough, except for getting types right.
10:53:08 <conal> i have a form that can handle polymorphic functions of type 'forall a. HasType a => k a -> v a', where HasType involves the GADT of type-equality proofs.
10:53:30 <conal> but i don't think that type is flexible enough for my uses.
10:53:44 <jeffersonheard> I hate to release a single module as a separate library, but if anyone wants the polymorphic LRU cache that i'm using in Hieroglyph split out into a separate library speak now
10:54:14 <jix_> sounds interesting
10:54:29 <conal> jeffersonheard: what do you use LRU for in Hieroglyph?
10:54:52 <Saizan> jeffersonheard: polymorphic in which sense?
10:55:08 <jeffersonheard> conal: caching images and soon bufferobjects in the OpenGL version of Hieroglyph
10:55:32 <conal> jeffersonheard: neat.
10:55:42 <jeffersonheard> just standard polymorphism: Anything you can store in Data.Map you can store in the cache
10:56:04 <jeffersonheard> cache supports upper bounds on size, and is compatible with the State monad if  you desire to use it that way
10:56:33 <jeffersonheard> as in keys must be Ord, but no other restrictions on storage
10:56:41 <m00re> Has anyone here useed the hscurses package?
10:58:17 <Saizan> jeffersonheard: but do you store polymorphic values or just values of different types?
10:58:45 <jeffersonheard> just values of different types.  I suppose it'd be a neat trick to support polymorphic values...
10:59:16 <Saizan> jeffersonheard: however i think i'd like to see it available, bonus points if it manages serialization :)
11:16:58 <FliPPeh> I just HAVE to run a Thread in a StateT-started code, to access the state..
11:17:03 <FliPPeh> I can't do it :(
11:20:02 <anq> Mh. I have seen on multiple occasions type classes that appear not to declare any methods. What are such constructs used for? Perhaps it's obvious, I just don't get it.
11:20:20 <sboult> how can i import a library?
11:21:11 <pumpkin> import Library
11:21:14 <FliPPeh> :)
11:21:45 <FliPPeh> Hah, fixed
11:21:46 <pumpkin> anq: to make statements about a class that people are expected to follow even if the rules aren't representable in haskell
11:21:57 <FliPPeh> Okay..
11:22:05 <FliPPeh> How do I get the current time in UNIX seconds?
11:22:30 <FliPPeh> Not that big bulky CalendarTime or ClockTime
11:22:48 <FunctorSalad_> System.Posix.Time
11:22:51 <FunctorSalad_> .epochTime
11:22:59 <sboult> but i need to write, for example "import Array", on my xt
11:23:00 <Zao> System.Posix.Time.epochTime
11:23:05 <sboult> txt*
11:23:07 <FliPPeh> Thanks :)
11:23:11 * Zao blames his slow internets.
11:23:13 <FliPPeh> @t epochTime
11:23:13 <pumpkin> anq: say you have Monoid and CommutativeMonoid as classes... we can write the Monoid methods just fine, but CommutativeMonoid is just a Monoid whose mappend is commutative... we can't express that, but if we have a function that has a constraint on CommutativeMonoid, it's saying that "we expect that if you've made an instance of this, that we can use your mappend commutatively"
11:23:13 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
11:23:19 <FunctorSalad_> Zao: :)
11:23:30 <FliPPeh> :t epochTime
11:23:31 <lambdabot> Not in scope: `epochTime'
11:23:33 <FliPPeh> :d
11:24:03 <pumpkin> anq: does that make sense? that's one reason I can see for a typeclass with no methods, but there may be others :)
11:24:21 <anq> pumpkin, perhaps. Let me think for a moment. :)
11:24:34 <FunctorSalad_> and type-level functions..
11:24:46 <FunctorSalad_> (with fundeps)
11:25:15 <pumpkin> ah
11:25:21 <dino-> pumpkin: Are phantom types related to this?
11:25:43 <FliPPeh> Okay, and how do I get the epoch time under WINDOWS?
11:26:16 <dino-> FliPPeh: Let me look, something with Data.Time... I think
11:26:35 <pumpkin> dino-: not sure, I've seen them used for various things where you want to enforce limits on the kinds of types you can use together without there being any "value-representable" reason for doing so
11:26:45 <pumpkin> dino-: but I'm no expert :)
11:26:51 <_Stefan_> hello everyone
11:27:40 <FliPPeh> If I can't use threads here, I'll just use the pauses from the "hWaitForInput" call to check if 5 minutes have passed, and run a command to check the connection status :)
11:27:41 <anq> pumpkin, therefore, given 'class Monoid [...] => CommutativeMonoid [...]' we would imply, by the name of the subclass, for the user that if he makes instances of it, then the mappend function is supposed to be commutative without the actual ability to enforce it by Haskell itself. Similarly to the Monad laws?
11:27:43 <_Stefan_> is someone willing to answer a noob a question
11:28:18 <pumpkin> anq: I think so, yeah... a typeclass can just be seen as a statement about the "capabilities" of a type (sometimes with methods to access those capabilities)
11:28:35 <pumpkin> or rather, a typeclass instance can be seen as a statement
11:28:48 <pumpkin> I'm not sure if that's a good way of looking at it
11:28:53 * pumpkin shrugs :)
11:29:04 <FunctorSalad_> can you make rewrite rules for such dummy typeclasses?
11:29:16 <pumpkin> what for?
11:29:19 <Cale> _Stefan_: yeah :)
11:29:20 <FunctorSalad_> that would be a possible use...
11:29:32 <pumpkin> oh I see
11:29:38 <_Stefan_> @Cale
11:29:38 <lambdabot> Unknown command, try @list
11:29:52 <_Stefan_> thanks, but i'm not very good with this
11:29:52 <Cale> _Stefan_: (Though it's impossible for anyone to answer if you will not ask it ;)
11:29:59 <pumpkin> can you put constraints on rewrite rules? I've never written any with constraints, but I don't see why it shouldn't be possible
11:30:03 <dino-> FliPPeh: Does this work? > Control.Monad.liftM (truncate . Data.Time.Clock.POSIX.utcTimeToPOSIXSeconds) Data.Time.getCurrentTime
11:30:04 <anq> pumpkin, aye, but then such constructs would be of a rather transient nature. More like synonyms that by their naming add some sense that is beyond Haskell's capabilities of expression. Still, not useless. :) Thanks for the perspective.
11:30:28 <voker57_> @hoogle (Floating a) (Integral b) => a -> b
11:30:29 <lambdabot> Parse error:
11:30:29 <FliPPeh> Yep
11:30:29 <lambdabot>   --count=20 "(Floating a) (Integral b) => a -> b"
11:30:29 <lambdabot>                                        ^
11:30:29 <FunctorSalad_> for commutativity, rewrite rules are sort-of a bad idea though ;)
11:30:30 <FliPPeh> Thanks!
11:30:33 <dino-> coool
11:30:39 <anq> FunctorSalad_, what are rewrite rules?
11:30:40 <voker57_> @hoogle (Floating a), (Integral b) => a -> b
11:30:41 <lambdabot> Parse error:
11:30:41 <lambdabot>   --count=20 "(Floating a), (Integral b) => a -> b"
11:30:41 <lambdabot>                          ^
11:31:13 <_Stefan_> How would I go about writing a program, that reads multiple lines from STDIN, and stores them in a list
11:31:13 <pumpkin> anq: maybe Cale has more perspective on it :) he's been around way longer than I have and seems to be good at expressing things clearly
11:31:13 <FunctorSalad_> anq: pragmas that tell ghc that it can simplify expressions in a given way
11:31:58 <FunctorSalad_> anq: like "{-# RULES "head/cons": forall x xs. head (x:xs) = x #-}" (not sure if that was the exact syntax0
11:32:19 <anq> Ah, right.
11:32:59 <anq> FunctorSalad_, covered here ( http://www.haskell.org/haskellwiki/GHC/Using_rules ) I suppose.
11:33:39 <FunctorSalad_> yep
11:34:04 <anq> Thanks. :)
11:38:07 <jix_> if i have a recursive algorithm on a tree that mutates the tree and have a lot of subtree sharing... how can i optimize that in haskell?
11:39:17 <FunctorSalad_> hmm... that wiki site says "We assume that non-confluent rewriting systems are bad design, but it is not clear how to achieve confluence for any system." -- what about Knuth-Bendix?
11:40:18 <EvilTerran> voker57_, the syntax you're looking for is (Floating a, Integral b) =>
11:41:23 <byorgey_> jix_: this algorithm is already written in Haskell and you want to optimize it?  or it is just an algorithm and you want to know how to write an optimized version in Haskell?
11:41:37 <jix_> byorgey_: not written already
11:42:09 <byorgey> jix_: well, from the way you've described it, it sounds like it would fit Haskell very naturally.  I don't think you'll need to do any "optimization", just write it.
11:42:16 <jix_> if i was to implement it in an imperative language i'd use pointers and thereby transform all shared subtrees automatically
11:42:22 <byorgey> jix_: in particular, the subtree sharing will happen automatically.
11:42:41 <pumpkin> not always
11:42:44 <jix_> byorgey: it seems it doesn't
11:42:57 <pumpkin> I've had trouble writing DAWGs
11:43:00 <jix_> byorgey: i did some simple test cases where the sharing was a lot more obvious than for the real problem
11:43:13 <jix_> and used trace to see how often things are evaluated
11:43:14 <pumpkin> jix_: used vacuum?
11:43:32 <jix_> pumpkin: what's that?
11:43:41 <pumpkin> @hackage vacuum
11:43:41 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/vacuum
11:43:43 <byorgey> jix_: well, then I'd have to see your code, or more details on exactly what you are trying to do
11:44:10 <anq> pumpkin, http://tinyurl.com/lmffz7 -- Here the application of said type class variant is demonstrated in X Monad's source. It's interesting.
11:44:13 <jix_> byorgey: ok i'll write a small subset of the problem unoptimized first then
11:44:25 <byorgey> ok.
11:44:46 <pumpkin> anq: ah yeah, cool :)
11:46:02 <conal> jix_: check out functional memoization, e.g., http://conal.net/blog/tag/memoization/
11:47:26 <conal> jix_: if you write a tree-transforming recursive function naively, you'll lose sharing & do redundant work -- possibly exponentially so.
11:48:09 <conal> jix_: one solution is memoization.  another is to avoid the traversal and build optimized trees bottom-up, e.g., with "smart constructors".
11:48:18 <jix_> conal: there isn't so much sharing that it would be exponentially...
11:48:30 <anq> Is there a comprehensive list of Haskell's features?
11:48:37 <jix_> conal: and not so much sharing that i think memoization using hash tables would help
11:48:47 <jix_> even tho i have to try it to be sure
11:48:50 <conal> jix_: or memo tries
11:49:14 <uzytkownik> To construct TypeRep for type Module.Type do I need to call mkTyConApp (mkTyCon "Module.Type") []? If not how should I do it?
11:49:35 <conal> jix_: if sharing is rare, then a naive functional recursive traversal may be efficient enough.
11:50:19 <jix_> conal: but i'd still loose sharing after a transform
11:50:32 <jix_> i'd probably have a lot of sharing... but not a lot of sharing of the same subtrees
11:51:01 <jix_> but otoh memory usage might turn out to be not a problem at all
11:51:09 <conal> jix_: sharing but not of trees?  leaves?
11:51:30 <jix_> conal: sharing of trees but not that i have one tree like 400 times... but 100 subtrees like 4 times
11:52:00 <conal> jix_: and you don't think memoization will help?
11:52:28 <gwern> anq: not really. features is so subjective
11:53:00 <jix_> i haven't tried it but i think that since most of the time it won't be computed already the lookup etc will cost more than it saves in the end
11:53:30 <conal> jix_: because the avoided computation is cheap?
11:53:40 <jix_> yeah very
11:53:46 <anq> gwern, perhaps - but there is (for me) new terminology all over the place in almost every respectable paper or lecture note about Haskell and I have no idea to approach the study of the language systematically without a compilation of concepts that are central to Haskell.
11:53:56 <conal> jix_: oh.  then why worry about sharing?
11:53:56 <anq> <how to>
11:54:00 <gwern> anq: wikipedia is pretty good in that respect
11:54:55 <jix_> conal: because i have to do that cheap calculation a lot
11:55:08 <jix_> conal: and if i can halve that... i'd be happy
11:56:47 <jix_> conal: building the optimized version right away sounds interesting and might be the solution to my problem
11:57:09 <conal> jix_: that's what i usually do.
11:57:20 <jix_> but i'm not sure i can do that
11:57:25 <anq> gwern, mhh. Not sufficiently exhaustive. :P But thanks.
11:57:37 <conal> jix_: see, e.g., "compiling embedded languages"
11:59:22 <mmorrow> omg, just built pimped-out doxygen docs for the linux kernel... 3.7GB or callEE/ER graphs (graphviz-rendered imagemaps), "cooperation diagram" graphs for every struct, header file dep graphs, global struct/function/defines index, highlighted source code with hyperlinked identifiers...
11:59:44 <mmorrow> putting it online if it ever finished bzip2'ing then uploading
11:59:48 <conal> mmorrow: holy crap!
11:59:50 <mmorrow> s/ed/ing/
11:59:55 <mmorrow> conal: they're amazing
12:00:42 <conal> mmorrow: please publish some teasers for us to look at w/o having to graph the whole bz2 file.
12:01:08 <mmorrow> heh, i was just trying to find the coolest few callgraphs to put up :)
12:02:29 <jix_> conal: i think by returning functions that allow me to interleave the transforms before the complete tree is constructed instead of returning the complete tree or something similar might work...
12:03:06 <conal> jix_: cool
12:10:16 <hackagebot> Hieroglyph 3.1 - Purely functional 2D graphics for visualization. (JeffersonHeard)
12:10:51 <jeffersonheard> just a minor bugfix for the selection buffer in OpenGL.  I forgot to take out a debug print statement
12:10:57 <conal> jeffersonheard: yay for the new description!
12:16:06 <mmorrow> conal: here're a few http://moonpatio.com/linux/
12:16:44 <conal> mmorrow: fun!
12:17:10 <mmorrow> totally, each file has two of these for every function :o
12:17:39 <mmorrow> (and each struct has an analogous graph with s/calls/member-types/)
12:18:11 <conal> mmorrow: what does *red* mean in box color?
12:19:29 <mmorrow> ah, one sec
12:20:55 <mmorrow> err, so this is the legend for the stuct graphs: http://moonpatio.com/ghc/rts/html/graph_legend.html
12:21:13 <PetRat> How do you make something an instance of Whow? I can't define 'print' because it tells me it's not a visible method of Show.
12:21:20 <mmorrow> the red means "A graph is truncated if it does not fit within the specified boundaries." for those
12:21:23 <PetRat> -> Show <-
12:21:30 <mmorrow> so i guess maybe the same for the callgraphs
12:21:37 <pumpkin> mmorrow: did you ever find a good way of compiling huge unboxed constructors without GHC's ram usage exploding?
12:21:54 <conal> PetRat: print is defined via 'show'.  so you define 'show'
12:22:28 <dino-> PetRat: It's also possible that Show can be derived for you. Try 'deriving Show' after the type definition.
12:22:33 <mmorrow> pumpkin: i haven't, but i haven't tried anything since when we were talking about it though
12:22:38 <pumpkin> ah
12:23:03 <PetRat> I'm trying to make Identity an instance of Show so I'm not sure I can derive it.
12:23:22 <conal> StandaloneDeriving
12:23:23 <PetRat> What is the type sig of show?  show :: a -> String?
12:23:28 <MyCatVerbs> Yes.
12:23:43 <PetRat> conal: is that something that can help me?
12:23:56 <MyCatVerbs> If you want to define a Show instance, you need to define showsPrec rather than just show, IIRC.
12:24:15 <conal> PetRat: yeah.  if you want to derive an instance but do so separately from the data/newtype definition.
12:24:35 <byorgey> so you will need GeneralizedNewtypeDeriving and StandaloneDeriving.
12:24:53 <byorgey> then say 'deriving instance Show a => Show (Identity a)'
12:24:59 <mauke> why generalized newtype?
12:25:02 <mmorrow> the docs are 2.8 GB bzip2ed, uploading now..
12:25:13 <mauke> we're not autolifting an instance here
12:25:18 <mmorrow> eta 3hours and climbing
12:25:20 <byorgey> oh, right, sorry
12:26:01 <PetRat> byorgey: are those pragmas?
12:26:57 <byorgey> PetRat: yes, just put  {-# LANGUAGE StandaloneDeriving #-} at the top of your .hs file
12:27:27 <byorgey> PetRat: and I was wrong, you don't need GeneralizedNewtypeDeriving
12:28:35 <PetRat> byorgey: it works! thanks
12:28:45 <byorgey> great!
12:29:01 <PetRat> Obviously this is just an exercise. This is not for any practical purpose, just trying out a few things.
12:29:50 <PetRat> byorgey: I'm working through typeclassopedia and currently looking at "Monad transformers step by step". What's valuable about your article is not jusst the article itself, but the references.
12:30:06 <dino-> Wait a second, that deriving above works?
12:31:01 <PeakerWork> byorgey: why do you need standalone deriving and not attach it to the type?
12:31:52 <byorgey> PetRat: good, I'm glad it's useful!
12:32:13 <byorgey> PeakerWork: PetRat wanted an instance for Identity, which is already declared in another module.
12:32:57 <byorgey> dino-: why not?
12:34:02 <dino-> byorgey: I hadn't seen that syntax, deriving instance...
12:39:58 <byorgey> dino-: http://www.haskell.org/ghc/docs/latest/html/users_guide/deriving.html#stand-alone-deriving
12:41:00 <byorgey> dino-: new since 6.8.1
12:42:41 <mmorrow> conal: here're some struct graphs, which i think are more interesting than the callgraphs actually http://moonpatio.com/linux/structs/
12:43:33 * conal looks
12:44:52 <conal> mmorrow: pretty
12:45:11 <mmorrow> i like how they label the edges
12:45:25 <mmorrow> (all of these are html imagemaps in the docs)
12:45:52 <conal> mmorrow: my favorite: http://moonpatio.com/linux/structs/structtimer__list__coll__graph.png . i like the symmetry & asymmetry.
12:46:11 <mmorrow> ooh yeah toally, i'm staring at that one too right now actually :)
12:46:22 <conal> :)
12:46:24 <mmorrow> not that many loops in these C graphs..
12:46:32 <mmorrow> (haskell on the other hand..)
12:46:35 <opqdonut> subprocess_info is cute
12:46:39 <mmorrow> s/loops/cycles/
12:47:01 <conal> mmorrow: i'm wishing for some kind of swirling animation.  especially in the timer_list/tvec_base interdependence.
12:47:11 <mmorrow> heh totally
12:52:09 <mmorrow> the doxygen parser seems to barf on function ptrs
13:15:31 <dino-> byorgey: re: deriving  Thanks!  I was called away from my desk for a while.
13:16:16 <bavardage> how do I chain a set number of monadic operations together
13:16:36 <bavardage> i.e. I want to basically do f >> f >> f >> f >> f >> f
13:16:50 <bavardage> oh wait, but I want a result
13:17:06 <bavardage> so kinda like mapM, but not mapping over anything
13:17:08 <dino-> :t sequence
13:17:10 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
13:17:11 <bavardage> just calling the function a set number of times
13:17:26 <dino-> Oh, same f
13:17:56 <bavardage> oh kk
13:18:03 <bavardage> so sequence
13:18:08 <dino-> Maybe replicateM
13:18:15 <dino-> :t Control.Monad.replicateM
13:18:17 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
13:18:31 <byorgey> bavardage: it depends.  should the result of each action be the input to the next?  or should the results be gathered in a list?
13:18:33 <bavardage> yes
13:18:38 <bavardage> replicateM I think is it
13:18:42 <bavardage> byorgey: in a list
13:18:47 <byorgey> ok, yeah, then replicateM.
13:20:00 <PeakerWork> @hoogle replicateM_
13:20:00 <lambdabot> Control.Monad replicateM_ :: Monad m => Int -> m a -> m ()
13:20:22 <PeakerWork> bavardage: or that if you don't keep the list
13:20:43 <bavardage> thanks
13:24:20 <uzytkownik> @pl maybe (return Nothing) (\x -> Just `fmap` (undefined x :: Int -> IO Int) x)
13:24:21 <lambdabot> (line 1, column 63):
13:24:21 <lambdabot> unexpected ">"
13:24:21 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or ")"
13:24:39 <uzytkownik> @pl \y -> maybe (return Nothing) (\x -> Just `fmap` (undefined x :: Int -> IO Int) x) y
13:24:40 <lambdabot> (line 1, column 69):
13:24:40 <lambdabot> unexpected ">"
13:24:40 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or ")"
13:24:59 <uzytkownik> @pl \y -> maybe (return Nothing) (\x -> Just `fmap` (undefined :: Int -> IO Int) x) y
13:24:59 <lambdabot> (line 1, column 67):
13:24:59 <lambdabot> unexpected ">"
13:24:59 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or ")"
13:25:58 <uzytkownik> @pl \y -> maybe (return Nothing) (\x -> Just `fmap` return x) y
13:25:59 <lambdabot> maybe (return Nothing) (return . Just)
13:26:28 <byorgey> what a strange error message.
13:27:14 <uzytkownik> @pl \y -> maybe (return Nothing) (\x -> Just `fmap` (return :: a -> IO a) x) y
13:27:15 <lambdabot> (line 1, column 62):
13:27:15 <lambdabot> unexpected ">"
13:27:15 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or ")"
13:27:25 <uzytkownik> it fails on ::
13:29:58 <uzytkownik> May be some human will know. I have a function a -> IO (Maybe b). I need to put it in function b -> IO c to get a function a -> IO (Maybe c). Is there any short way of doing it?
13:31:15 <uzytkownik> I've achived: firstFunction >>= maybe (return Nothing) (\x -> Just `fmap` secondFunction x)
13:31:26 <mauke> :t (>=>)
13:31:27 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
13:32:25 <mauke> :t \f g x -> f x >=> maybe (return Nothing) g
13:32:26 <lambdabot> forall t a a1 (m :: * -> *) a2. (Monad m) => (t -> a -> m (Maybe a2)) -> (a2 -> m (Maybe a1)) -> t -> a -> m (Maybe a1)
13:32:40 <mauke> :t \f g -> f >=> maybe (return Nothing) g
13:32:41 <lambdabot> forall a a1 (m :: * -> *) a2. (Monad m) => (a -> m (Maybe a2)) -> (a2 -> m (Maybe a1)) -> a -> m (Maybe a1)
13:33:14 <mauke> :t \f g -> f >=> maybe (return Nothing) (fmap Just . g)
13:33:15 <lambdabot> forall a a1 (f :: * -> *) a2. (Monad f, Functor f) => (a -> f (Maybe a2)) -> (a2 -> f a1) -> a -> f (Maybe a1)
13:35:01 <jix_> conal: i think i got an optimization that works in my case http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2699#a2699
13:43:42 <QP> hello, I have a question about XMonad
13:43:57 <QP> can anyone tell me how to change keyboard layout?
13:44:00 <TomMD> QP: You can ask, but the best help is probably in #xmonad
13:44:11 <TomMD> QP: You mean the hotkeys?
13:44:13 <QP> oh, i didn't realise there was another channel
13:44:23 <TomMD> Yes, xmonad has its own channel - sweet, huh?
13:44:28 <QP> no, i want to change from qwerty to dvorak
13:44:39 <TomMD> QP: That would be an X11/x.org change, would it not?
13:44:51 <QP> ok...
13:44:52 <TomMD> It isn't the window manager that dictates that.
13:45:27 <QP> i'm getting confused, becuase my previous way of changing layout seemed to be the window manager
13:45:51 <dino-> QP: That may actually be an xmodmap thing, I'm wondering.
13:45:51 <QP> so i'll just edit x.org then?
13:46:07 <TomMD> QP: I've seen a number of photos of Xmonad setups complete with a Dvorak.  I don't know how to help you but I see numerous people in #xmonad, they can probably help.
13:46:14 <dino-> QP: You may be able to run the program you used to use if it's some gui, to change that stuff
13:46:18 <mauke> the command is setxkbmap
13:46:36 <dino-> mauke: ah
13:47:23 <QP> ok, i'll head to #xmonad and see what's hanging there... thanks for your help
13:48:21 <[bjoern]> I have a function f(x,y) and want to display the values as an ascii matrix in ghc; suggestions?
13:48:59 <FunctorSal> [bjoern]: printf to get the values to fixed width
13:50:35 <dino-> That new machine I want (Sager NP8662) has 1 HDMI and 1 DVI
13:50:37 <dino-> ok!
13:50:40 <dino-> haha
13:50:47 <FunctorSal> then something like "line y = concat [ printTheValue (f x y) | x <- someRange ]"
13:50:57 <dino-> Sorry my Haskell friends, wrong irssi window
13:56:10 <Badger> @src cycle
13:56:10 <lambdabot> cycle [] = undefined
13:56:10 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
13:57:36 <conal> hm.  would black-hole detection spot the bottom if the [] case were missing?
14:01:56 <Badger> so
14:02:11 <Badger> why *is* -> needed in anonymous functions?
14:02:20 <Badger> rather than plain old =
14:02:50 <opqdonut> to simplify the syntax i guess
14:03:17 <Twey> Because = is semantically confusing
14:03:21 <opqdonut> foo = \x y = asdf
14:03:25 <opqdonut> that also
14:03:33 <opqdonut> and . was overloaded enough already
14:03:58 <Badger> ah
14:04:06 <Badger> good point.
14:04:22 <Twey> = is used for definitions
14:04:30 <Twey> A lambda is not a definition, it's a literal
14:05:27 <dirk__> how can I find out if a string begins with an other string
14:05:38 <Twey> dirk__: isPrefixOf, in Data.List
14:05:43 <dirk__> ok
14:13:06 <[bjoern]> Thanks. I was hoping for something more simple... I just did it manually instead.
14:19:02 <warrie> @type group
14:19:04 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
14:19:23 <warrie> > group "Three bees see Lee."
14:19:24 <lambdabot>   ["T","h","r","ee"," ","b","ee","s"," ","s","ee"," ","L","ee","."]
14:19:45 <warrie> > map length . group . sort $ "jijiwjisjiwjijsijwijsijwijisjiwjsijiwjisjiwjisjiwjisjiwjisjiwjisjiwjij"
14:19:46 <lambdabot>   [24,25,10,11]
14:20:16 * warrie pats lambdabot on the head.
14:20:28 <mauke> @botsnack
14:20:28 <lambdabot> :)
14:20:28 <lunabot>  :)
14:21:19 <QP> > sort "snthsntthsnttheuhnoteionetuhntsnthnthsnthsnthsnthsnth"
14:21:20 <lambdabot>   "eeehhhhhhhhhhhinnnnnnnnnnnnoossssssssttttttttttttttuu"
14:24:12 <FunctorSal> ehnostu! ehnostu!
14:24:19 <byorgey> it's like someone very slowly telling you how to pronounce some Finnish word
14:24:40 <mauke> ENOSTU
14:25:02 <byorgey> probably with two t's, ENOSTTU
14:28:29 <Gracenotes> patpat???
14:30:09 <benmachine> when I do let zwt = zipWith (*) in my ghci (to save on typing, mostly) it seems to decide that zwt is [Integer] -> [Integer] -> [Integer] instead of (Num n) => [n] -> [n] -> [n] as I'd expect, is there any way to force it to be the latter?
14:30:33 <benmachine> I tried doing let zwt = zipWith (*) :: blah but it didn't seem to care
14:30:52 <mauke> benmachine: three solutions
14:31:09 <mauke> 1) put a type annotation on zwt  2) add a parameter to zwt  3) disable the monomorphism restriction
14:32:41 <benmachine> can I do those at the interactive prompt? ghci didn't seem to pay attention to my type annotations
14:32:41 <FunctorSal> the dreaded monodwarfism constriction...
14:32:54 <FunctorSal> :set -XNoMonomorphismRestriction
14:32:57 <FunctorSal> ( benmachine )
14:33:08 <mauke> benmachine: you didn't annotate zwt
14:33:27 <benmachine> mauke: I guess not, how do I?
14:33:31 <mauke> let zwt :: (Num n) => [n] -> [n] -> [n]; zwt = zipWith (*)
14:33:49 <benmachine> ah
14:33:57 <mauke> but 'let zwt x = zipWith (*) x' is a lot easier to type
14:34:19 <benmachine> why does that change things?
14:35:07 <byorgey> benmachine: you probably don't want to know. see http://haskell.org/haskellwiki/Monomorphism_restriction
14:35:13 <benmachine> hah, okay
14:35:16 <benmachine> thanks everyone
14:46:40 <TomMD> Will killThread kill the thread even if it's blocked?
14:47:03 <monochrom> I think yes.
14:51:03 <malouin> http://hackage.haskell.org/packages/archive/formlets/0.4.8/doc/html/src/Text-Formlets.html#input'
14:51:23 <malouin> So I'm trying to make an input that displays its own errors.
14:51:34 <malouin> which means the display code has to validate itself.
14:52:48 <malouin> The "value"-generating part of the formlet that ordinarily does the validating does not ever send any of its intermediate result o the 'display' part.
14:53:44 <malouin> But I figured, the output of the display code as returned by runFormState is in the form's monad, so I should be able to run my (monadic) validator twice.
14:53:48 <malouin> Suboptimal, but ok.
14:54:07 <hackagebot> url 2.1 - A library for working with URLs. (IavorDiatchki)
14:55:05 <malouin> However, after getting into this for a while, I notice that the function that input' takes returns something *not* in the formlet monad, so I either have to write my own input' function, or what I'm trying to do is completely impossible.
14:55:44 <malouin> and the mystery for me is, why is the output of runFormState in the monad if this functionality is not used?
15:00:22 <gwern> so I've been wondering. is there any downside to make forkIO :: IO a -> IO ThreadId?
15:00:23 <travisbrady_> anyone know how many packages Hackage is up to these days?
15:00:31 <gwern> travisbrady_: >1k
15:00:51 <opqdonut> :t forkIO
15:00:53 <lambdabot> Not in scope: `forkIO'
15:00:57 <opqdonut> gah
15:01:06 <opqdonut> @hoogle forkIO
15:01:06 <lambdabot> Control.Concurrent forkIO :: IO () -> IO ThreadId
15:01:07 <mauke> IO () -> IO ThreadId, I think
15:01:12 <opqdonut> thought so
15:01:23 <opqdonut> gwern: no downside imo
15:01:32 <gwern> opqdonut: I was reading a post by ndm
15:01:34 <opqdonut> other than the current one makes you explicitly ignore the return value
15:01:38 <conal> gwern: loss of type-checking.
15:01:47 <gwern> where he complained about how people using mapM where they meant mapM_ lead to memory leaks
15:01:48 <opqdonut> i'd like forever to have a different type too
15:01:51 <conal> i have the same beef with the type of (>>)
15:01:51 <opqdonut> :t forever
15:01:52 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
15:02:01 <gwern> and said that if statements had to be IO () instead of IO a, code would be better
15:02:14 <conal> opqdonut: already got changed
15:02:16 <opqdonut> conal: oh you'd want it to be m () -> m a -> m a?
15:02:17 <gwern> since it forced you to do something with the results, and let you not slide
15:02:23 <opqdonut> oh, it did
15:02:25 <opqdonut> cool
15:02:41 <conal> opqdonut: yeah.  or Monoid o :: m o -> m o -> m o
15:02:49 <opqdonut> mhmm
15:03:11 <conal> tho the latter is liftM2 mappend
15:03:18 <conal> or liftA2 mappend
15:08:37 <eu-prleu-peupeu1> hello
15:09:01 <gwern> I've noticed that everytime I ask about something involving monads, people wind up wanking with some obscure derivation involving either monoids or applicatives
15:09:07 <gwern> I don't know whether to be bothered by this or not
15:09:20 <byorgey> hi eu-prleu-peupeu
15:10:47 <Saizan> gwern: ndm's point applies to forkIO as much as (>>)
15:10:56 <conal> gwern: monoid is an inevitable idea here, because it gives a default way to combine two values.  applicative fits because liftM2 is really an unnecessarily special case of liftA2.
15:11:17 <gwern> Saizan: I thought it did, but I'm unsure whether it's a good point in the context of forkIO
15:11:57 <gwern> conal: but where are we combining values? forkIO just returns a threadid, which might as well be a constant for all it matters
15:12:01 <Saizan> gwern: what's the difference between (>>) and forkIO here?
15:12:18 <gwern> yah.
15:12:22 <conal> gwern: in >>
15:12:34 <Saizan> they both discard the result of one action
15:13:22 <conal> url for ndm's post?
15:13:46 <gwern> conal: it's in the 'ignore' thread on libraries
15:14:09 <Saizan> conal: having (>>) = liftA2 mappend makes little sense for parsers, for example
15:14:18 <conal> gwern: thx.
15:14:58 <Saizan> conal: it's common to parse a keyword or any other delimiter and ignore its value
15:15:51 <conal> Saizan: sure.  i prefer m () -> m a -> m a
15:16:33 <Hunner> Is there a pragma to hide a package?
15:17:09 <Hunner> or another way to hide a package without specifying it on the command line?
15:17:48 <Taejo> read "sin x" :: Expr
15:17:50 <Taejo> > read "sin x" :: Expr
15:17:52 <lambdabot>   No instance for (GHC.Read.Read SimpleReflect.Expr)
15:17:52 <lambdabot>    arising from a use of...
15:17:56 <Taejo> :(
15:18:00 <Saizan> maybe {-# OPTIONS_GHC -hide-package foo #-} ?
15:19:15 <gwern> Taejo: the Expr stuff isn't an interpreter :)
15:19:30 <mauke> > read "x" :: Expr
15:19:31 <lambdabot>   No instance for (GHC.Read.Read SimpleReflect.Expr)
15:19:31 <lambdabot>    arising from a use of...
15:19:35 <gwern> > sin x
15:19:36 <lambdabot>   sin x
15:19:39 * mauke slaps his brain
15:19:41 <FliPPeh> I see that Xmonad and LambdaBot both can parse Haskell, atleast for lambdabot I know for sure. Is that some kind of built-in, or would I have to do that myself if I want to add something simiar?
15:19:44 <gwern> > map (sin) [1..10]
15:19:45 <lambdabot>   [0.8414709848078965,0.9092974268256817,0.1411200080598672,-0.75680249530792...
15:20:00 <gwern> hm, that wasn't what I intneded
15:20:08 <mauke> FliPPeh: XMonad simply calls ghc to compile files
15:20:12 <gwern> FliPPeh: what do you mean, xmonad can parse haskell?
15:20:14 <hackagebot> control-event 1.0.0.0 - Event scheduling system. (ThomasDuBuisson)
15:20:17 <Saizan> FliPPeh: there's hint, mueval, the ghc-api, haskell-src-exts ...
15:20:20 <gwern> FliPPeh: also, lambdabot just shells out to mueval
15:20:26 <Taejo> gwern: but I was hoping it was a parser
15:20:27 <FliPPeh> Okay
15:20:35 <gwern> FliPPeh: which accomplishes its haskell-fu by linking in the GHC API
15:21:10 <FliPPeh> Would have been a nice scripting language for my own IRCly
15:21:17 <Taejo> gwern: I've written a program that draws fractals ... the UI for Mandelbrot and Julia fractals are easy, Newton fractals not so much (without an expression parser)
15:21:41 <gwern> FliPPeh: well, there are just haskell parsers. haskell-src and haskell-src-exts
15:21:44 <gwern> they work pretty well
15:21:53 <FliPPeh> Oh no
15:22:01 <FliPPeh> I've seen that "Write Yourself a Scheme" tutorial
15:22:08 <FliPPeh> That would be my next action :)
15:22:11 <gwern> mueval uses haskell-src-exts to do some static analysis of submitted code, incidentally
15:22:29 <gwern> FliPPeh: no no! REUSE REUSE REUSE! we have a scheme interpreter on hackage already!
15:22:42 <FliPPeh> meh
15:22:44 <Nereid_> lol
15:22:53 <FunctorSalad> FliPPeh: there's a simplified interface to the ghc api on hackage (iirc called "hint")
15:22:59 <gwern> repeat after me: 'if there is an appropriate library on hackage, I will use it and not roll my own'
15:23:02 <gwern> all together now!
15:23:03 <FunctorSalad> might be the right thing for irc scripting
15:23:23 <FunctorSalad> but I didn't try it myself
15:24:21 <FunctorSalad> gwern: well... some packages have no haddock whatsoever :-(
15:24:32 <FunctorSalad> (a few)
15:24:39 <gwern> the source is the best haddock!
15:24:52 <FunctorSalad> sometimes there aren't even normal comments
15:25:03 * benmachine writes abnormal comments
15:25:11 <FunctorSalad> :)
15:25:42 <gwern> '-- | Come, it is time to discuss ships, sealing wax, of beavers and kings. Arg must be a non-negative integer.'
15:25:46 <RayNbow> @users
15:25:46 <lambdabot> Maximum users seen in #haskell: 658, currently: 595 (90.4%), active: 22 (3.7%)
15:25:49 <malouin> @src lookup
15:25:49 <lambdabot> lookup _key []          =  Nothing
15:25:50 <lambdabot> lookup  key ((x,y):xys) | key == x  = Just y
15:25:50 <lambdabot>                         | otherwise = lookup key xys
15:25:57 <conal> benmachine: always normalize your comments before checking in code!
15:26:11 <FunctorSalad> gwern: is that a quote?
15:26:26 <gwern> FunctorSalad: of course it is
15:26:42 <conal> lewis carrol rolls over in his grave
15:27:09 <gwern> conal: if carroll were alive today, he'd be writing quines and winning the obfuscated c contests!
15:27:19 <conal> :)
15:29:18 <RayNbow> hmm, http://www.cse.unsw.edu.au/~dons/irc/nick-activity.png <-- isn't the extrapolated nick count for 2009 a bit too optimistic?
15:29:59 <gwern> RayNbow: I think it's more humorous than serious
15:30:16 <gwern> dons knows perfectly well that on small bases, exponential extrapolations are more voodoo than science
15:30:29 <RayNbow> gwern: ah k :p
15:33:58 <FunctorSal> > let a=1/1000 in [ (1+a)**n - (1+n*a+n^2*a/2) | n <- [0..] ]
15:33:59 <lambdabot>   [0.0,-4.999999999999449e-4,-1.999000000000306e-3,-4.4969990000001125e-3,-7....
15:34:13 <FunctorSal> gwern: fair enough isn't it? ;)
15:34:13 <Badger> > e
15:34:15 <lambdabot>   e
15:37:46 <FunctorSal> I probably missed the context while I was offline..
15:42:23 <BONUS> say we have data F = forall a. F a
15:42:40 <BONUS> a function F -> (forall a. a -> b) -> b doesn't make sense right
15:43:00 <Saizan> why not=
15:43:01 <Saizan> ?
15:43:03 <BONUS> because the a contained in the type and the one that the funciton takes don't have to be the same
15:43:37 <Saizan> the function given as second parameter promises to be able to accept any a
15:43:54 <Saizan> so you can instance it to the type contained in F
15:44:00 <BONUS> aha i see
15:44:11 <Hunner> Is there a way to tell haskell to re-evaluate an expression?
15:44:18 <BONUS> but that function can only be const something then?
15:44:54 <Saizan> BONUS: or seq, or wrapping in another existential
15:45:05 <Saizan> BONUS: nothing really interesting though
15:45:20 <BONUS> ah, i see
15:46:27 <hackagebot> gps 0.2.4 - For manipulating GPS coordinates and trails. (ThomasDuBuisson)
15:46:32 <Botje> Hunner: why? it would just give the same result
15:49:11 <Berengal> Type hackery is hard
15:49:56 <Saizan> let's go shopping?
15:49:56 <Nereid_> Hunner: why would you do that?
15:50:19 <Berengal> Saizan: I'm tempted to, but it also feels like I'm on the verge of discovery, so I'll press on
15:50:20 <Nereid_> benchmarking perhaps
15:51:20 <Alpounet> Hi all.
15:51:23 <Nereid_> Hi.
15:51:55 <Hunner> Botje: not if it's IO
15:52:16 <Nereid_> but that's not evaluating, that's executing
15:52:41 <BONUS> another on existential. say with data F = forall a. C a => a - if we have forall b. F -> (forall a. C a => a -> b) -> b
15:52:42 <Hunner> okay, then I was using the wrong terms, sorry
15:52:55 <BONUS> why can't we move the forall a. to the forall b.
15:53:00 <Nereid_> Hunner: what are you having trouble with, then?
15:53:00 <Hunner> I'm using the ghc api to recompile code when it needs it from external files, but it only compiles it once per run of main
15:53:07 <BONUS> so it's forall a b. C a => F -> (a -> b) -> b
15:53:35 <Hunner> Nereid_: similar to http://www.bluishcoder.co.nz/2008/11/dynamic-compilation-and-loading-of.html
15:54:53 <Saizan> BONUS: because with that type the caller can instantiate 'a' to what it wants
15:55:00 <Hunner> I don't have to recompile the file with main in it, just re-run it to get it to re-execute the function that does the compiling
15:55:21 <uzytkownik> Whats the standard place for tests? Test.hs, tests/?
15:55:31 <Saizan> BONUS: while you need to keep that freedom for the body of the function
15:55:47 <BONUS> aahh
15:55:50 <BONUS> i get it
15:57:00 <Saizan> IOW the second argument must be polymorphic
15:57:44 <mmorrow> here are doxygen docs for the linux kernel, built with all the various graphviz graphs doxygen can do: http://moonpatio.com/docs/linux/
15:57:58 <jix_> and again this would be a monad if the definition of (>>=) would be restricted to one type instead of two
15:58:08 <habitue_> Hey I am trying to write a function with the signature (a -> a) -> a -> Int -> a  where it applies the function to itself x times, what is the easiest way to write this?
15:58:35 <mmorrow> struct index: http://moonpatio.com/docs/linux/classes.html
15:58:51 <mmorrow> file: http://moonpatio.com/docs/linux/files.html
15:58:52 <mmorrow> etc
15:59:10 <Saizan> jix_: it's just a monoid then :)
15:59:53 <conal> habitue_: maybe iterate & !!
15:59:57 <BONUS> i think i get existentials now, awesome
16:00:07 <Saizan> BONUS: yay!
16:00:15 <jix_> Saizan: really? to me a monoid looks like something completely different
16:00:25 <BONUS> :]
16:01:05 <Hunner> Nereid_: okay, is there a way to make haskell re-execute a function?
16:01:05 <habitue_> I tried something along the lines of :
16:01:07 <FunctorSal> habitue_: foldr (.) id $ replicate theFun n
16:01:10 <habitue_> repeatedly f k n -> foldl (\x y -> y x) k $ take n (repeat f)
16:01:19 <Saizan> jix_: you can write (a -> M a) -> (a -> M a) -> (a -> M a), that's the mappend, and "return" is mempty
16:01:37 <Nereid_> habitue_: repeatedly f k n = iterate f k !! n
16:01:58 <jix_> Saizan: ah... but i get no nice do notation then... ;)
16:01:58 <Nereid_> Hunner: I would think you'd need to load the module again or something
16:02:05 <habitue_> ok! thank you very much!
16:02:28 <Nereid_> but if the module is already loaded maybe reloading it again just returns something cached, so you'd need to find a way to clear that
16:02:33 <FunctorSal> habitue_: you can get exponential speedup (in n) by square-and-multiply, though...
16:02:35 <Hunner> Nereid_: It doesn't actually load the module. It uses ghc's api to compile it and load it into the context
16:02:41 <Nereid_> that's what I meant
16:03:07 <habitue_> FunctorSal: square and multiply?
16:03:26 <FunctorSal> habitue_: or wait, nevermind. that only makes sense for numbers, since for functions the function will still have to be applied n times anyway ;)
16:03:31 <Nereid_> FunctorSal: not really, you need to apply the function n times in any case
16:03:32 <Nereid_> yeah
16:03:33 <Nereid_> :-)
16:03:41 <FunctorSal> silly me
16:03:54 <Nereid_> habitue_: more explicitly you could do, repeatedly f k 0 = k; repeatedly f k n = f (repeatedly f k (n - 1))
16:04:17 <Nereid_> (probably want to error if n < 0)
16:04:59 <FunctorSal> I was thinking of function composition as a constant-cost operation... (which it is, but applying the thunk will be linear in n)
16:05:18 <Nereid_> indeed
16:05:57 <mmorrow> @type \n -> foldr (.) id . replicate n
16:05:58 <lambdabot> forall a. Int -> (a -> a) -> a -> a
16:06:43 <mmorrow> (my favorite way to do that)
16:07:04 <mmorrow> and it's `id' if n < 1
16:08:02 <conal> mmorrow: hm.  id for n < 1 would break some nice identities.  like saying x ^ n = 1 for all n <= 0.
16:08:37 <conal> to bad the Endo monoid isn't more convenient to use in settings like this one
16:09:59 <FunctorSal> yeah replicate with negative arg should make a formal inverse ;)
16:10:13 <conal> yep
16:10:34 <conal> or at least something *consistent* with inverse.
16:10:38 <conal> if not equal to it.
16:11:23 <jnwhiteh> Does anyone know of an implementation of the commstime network in Haskell?
16:11:44 <monochrom> inverse is hard.
16:11:58 <conal> monochrom: yeah.  but consistency with inverse is easy.
16:12:11 <FunctorSal> inverses of lists with respect to (++) aren't really much more imaginary than negative numbers ;)
16:12:20 <conal> i.e., if we can't agree, we can still agree not to disagree.
16:12:20 <jix_> i so want do notation for this :/
16:12:24 <FunctorSal> but I don't know what the elements should be
16:12:46 <monochrom> consistency with inverse is hard. that's what I meant.
16:12:47 <SamB> FunctorSal: sure they are, negative numbers are easy
16:14:22 <pedro-kun> hi.. sorry for asking such a question..
16:14:26 <conal> i guess "easy" & "hard" is binary (relation) not unary (property)
16:14:27 <pedro-kun> i have a [String]
16:14:34 <pedro-kun> and i want to putStrLn every item
16:14:37 <Nereid_> numbers with addition have a group structure
16:14:39 <pedro-kun> how can i do this?
16:14:40 <Nereid_> lists and concatenation don't
16:14:56 <conal> @ty mapM_
16:14:57 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
16:15:04 <Nereid_> pedro-kun: sequence
16:15:06 <conal> pedro-kun: ^^
16:15:11 <Nereid_> or that
16:15:15 <conal> @ty sequence
16:15:16 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
16:15:16 <Taejo> what's a good library for writing "permissive" parsers (I want to parse something that isn't meant to be machine readable, but follows a fairly regular format)
16:15:17 <monochrom> consistency with inverse is as hard as the halting problem.
16:15:22 <Saizan> ?ty mapM_ putStrLn
16:15:23 <lambdabot> [String] -> IO ()
16:15:30 <conal> @ty sequence_
16:15:31 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
16:16:08 <Saizan> Taejo: maybe uu-parsinglib? it does autocorrection
16:16:21 <Taejo> Saizan: I'll look into it
16:16:22 <FunctorSal> Nereid_: naturals with additions have only a monoid structure, so you invent negatives to make a group. you can do that with lists too (but it is more complicated because (++) isn't commutative)
16:17:01 <Berengal> How would negative-length lists work?
16:18:21 <conal> Berengal: maybe with anti-values that cancel out values when juxtaposed
16:18:24 <Nereid_> actually
16:18:24 <Nereid_> yeah
16:18:40 <conal> "annihilation, jim"
16:18:40 <FunctorSal> Berengal: ListGroup a = [Either a a], with ordinary lists included via \xs -> map right xs
16:18:42 <monochrom> "free groups" and "words". also "the word problem"
16:18:50 <wy_> hey, anybody familar with the implementation of haskell?
16:18:58 <Nereid_> asdf I was about to mention free groups. :(
16:19:00 <FunctorSal> concatenation is defined such that lefts and rights cancel out
16:19:23 * Nereid_ gets bored, and writes such a thing
16:19:26 <FunctorSal> then inverse [Right "foo", Left "bar"] = [ Right "bar", Left "foo" ]
16:19:38 <wy_> I was wondering how the currying is implemented. Does ghc create closures for every level of currying?
16:19:53 <FunctorSal> Nereid_: it needs an Eq context though :(
16:19:54 <Nereid_> how would we deal with infinite lists?
16:20:02 <Nereid_> yeah probably
16:20:16 <conal> FunctorSal: can these lists have negative length?
16:20:18 <Nereid_> actually nevermind, infinite lists would be easy anyway
16:20:19 <Berengal> Nereid_: [..Left 1] ish...
16:20:34 <conal> FunctorSal: so that length is still a monoid homomorphism
16:20:55 <Nereid_> well
16:20:57 <Berengal> wy_: Conceptually it does
16:20:58 <FunctorSal> conal: hmm if you define length as "number of rights - number of lefts" I think that's the case
16:21:05 <Nereid_> indeed
16:21:08 <wy_> Berengal: but in practice ..?
16:21:45 <conal> FunctorSal: hm.  what about [Right True] ++ [Left False] ?
16:21:54 <Berengal> wy_: Don't know, and it probably depends on the phase of the moon and if you're wearing your lucky socks or not
16:21:56 <conal> oh yeah. nm.
16:22:08 <conal> just drop the old notion of length
16:22:10 <FunctorSal> Nereid_: hmm with infinite lists it seems that either  "inverse x ++ x" or "x ++ inverse x" will be undefined :(
16:22:18 <Berengal> wy_: You could get ghc-core and try some experiments... if you know how to read core
16:22:22 <Nereid_> FunctorSal: indeed
16:22:57 <conal> FunctorSal: like infinity - infinity
16:23:12 <wy_> Berengal: I looked at SPJ's book, but STG etc are still too far from the machine to make this point clear
16:23:31 <Berengal> wy_: ghc-core shows the assembly as well
16:24:01 <wy_> Berengal: oh, what is ghc-core? I thought it was the core language
16:24:01 <SamB> wy_: when you apply several arguments in one go, it doesn't actually go through and make all those closures, no
16:24:27 <SamB> wy_: hackage package
16:24:41 <Berengal> wy_: No, ghc-core gets ghc to compile to core, then colours the ouput. It's on hackage, so cabal install ghc-core and you're golden
16:24:59 <SamB> I would probably not have figured it out if he didn't mention that it shows the assembly as well
16:25:34 <wy_> Thanks.
16:25:34 <jix_> :r
16:25:34 <jix_> whoops
16:25:34 <jix_> this isn't ghci...
16:25:34 <wy_> That's pretty clear now
16:25:38 <SamB> heh
16:26:04 <wy_> SamB: Is it considered an optimization?
16:26:14 <SamB> wy_: sort of
16:26:31 <wy_> That's nice.
16:26:57 <SamB> I mean, I don't think you need -O to get it
16:27:04 <Gracenotes> hm, I forget.. what's the problem with lambdabot and lefts/rights/partitionEithers?
16:27:25 <wy_> SamB: yeah. It should be the case by default
16:27:30 <Saizan> @versuion
16:27:30 <lambdabot> lambdabot 4.2.2
16:27:30 <lambdabot> darcs get http://code.haskell.org/lambdabot
16:28:01 <Gracenotes> I *thought* it was on 6.10 GHC..
16:29:52 <Cale> wy_: My mental model of how Haskell evaluation works (even when optimising code) is normally too high-level to include something like closures directly. :)
16:30:22 <wy_> Cale: what do you think in? combinatory logic?
16:30:24 <Cale> wy_: I normally think of the Haskell evaluator as repeatedly transforming a graph.
16:30:27 <ray> closures? aren't they those things that are so obvious that i'm not sure what they're actually supposed to be?
16:31:06 <Saizan> wy_: the recent paper "types are calling conventions" talk about that, afaik
16:31:34 <Cale> ray: A closure consists of a pair, consisting of some code, possibly with some unbound variables left in it, together with an environment mapping which maps any unbound variables in the code to values.
16:31:54 <Cale> ray: So that when the code gets run, it can look up the missing variables in the map.
16:32:22 <Berengal> Argh! I have an idea, but I don't know how to express it in haskell :(
16:32:29 <ray> in other words, it's "handle free variables in a way that makes sense"
16:33:00 <wy_> Cale: how do you think in graphs also dealing with free vars?
16:33:07 <Cale> ray: There are many ways to fill in the concrete details of how this works, but the important part is that what you have is a pair. If you can't take it apart anymore into separate code and environment parts, I wouldn't call it a closure anymore.
16:33:49 <Cale> wy_: Well, the values of variables are captured by the fact that the body of a function will have an arc which points to them.
16:34:36 <jix_> are there any tools that allow to trace haskell evaluation and generate graph reduction animations out of that?
16:35:00 <wy_> Cale: maybe it's too low-level, but when these things are translated to assembly, you will have to package things up
16:35:20 <ray> cale: i should write a compiler i guess
16:35:28 <Cale> jix_: The closest thing I've seen is for a language which is not really Haskell, and where you write the code as graphs as well. Also, it's still not open source, though it's not for any good reason :)
16:35:41 <Cale> http://www.cas.mcmaster.ca/~kahl/HOPS/ANIM/index.html
16:36:16 <Taejo> :t flip id
16:36:18 <lambdabot> forall b c. b -> (b -> c) -> c
16:36:48 <Cale> ray: There's an annoying (from my perspective) tendency for people to call first class functions or procedures "closures", when what is really true is only that they *might* be implemented as such.
16:37:17 <Cale> ray: A closure is an *implementation mechanism* for a first class function, procedure, or object.
16:37:46 <ray> so writing a compiler is probably the way to go
16:37:57 <Berengal> I think of a closure as a function and a list of (some of the) arguments. At the haskell-level, this is indistinguishable from any other function or value
16:38:25 <Cale> Berengal: Well, yeah, if you're thinking of a pair, then that's fine.
16:38:33 <Cale> Something like (a -> b -> c, a)
16:38:38 <Berengal> You only really need them in languages that lack first-class functions and currying. They're easy enough to implement yourself
16:38:44 <conal> Cale: thanks!  i appreciate the distinction between implementation notions and semantic notions.
16:39:04 <wy_> Cale: That's true if you think of lambda calculus. It doesn't have closures. The environment is just a "delayed substitution"
16:39:13 <Cale> wy_: right.
16:39:44 <Cale> wy_: Closures should not appear in language specifications. If they do, your spec is specifying too much about how the language is to be implemented.
16:40:09 <wy_> Cale: It seems to be damn truth that first-class functions when implemented in assembly, still have to take another argument which is the closure
16:40:14 <conal> Similarly, notions like graph reduction.
16:40:59 <wy_> I wonder whether ghc has avoided that
16:41:00 <conal> one can also implement first class functions via code generation.
16:41:24 <SamB> wy_: that's the info pointer
16:41:35 <SamB> er, I mean ...
16:41:41 <Cale> wy_: But they might also be implemented as a code graph where arcs from the body of the function point at other values in memory, and so there's no closure to speak of.
16:42:27 <wy_> Cale: yes. I mean, you may need to create a new processor to implement it nicely
16:42:47 <Cale> wy_: and when you partially apply a function, it takes the lambda variable, and rewires everything that points at that to point at the value instead.
16:42:55 <SamB> a GHC function object is not just a code address
16:43:05 <Cale> Nah, you can do graph transformations on stock hardware.
16:43:18 <Cale> You use pointers for arcs.
16:43:40 <SamB> the first word is a pointer to some code with a table immediately before it ...
16:43:46 <SamB> there rest, well, it depends
16:44:09 <wy_> It will introduce multiple level of indirections I guess
16:44:51 <wy_> It will introduce multiple level of indirections I guess.
16:44:54 <SamB> wy_: of course, to implement the FFI, it really *does* need to generate machine code closures dynamically...
16:44:56 <Cale> wy_: So despite working externally exactly like the closure implementation, there's never a separation between code and an environment of bindings.
16:45:05 <wy_> sorry I thought I'm kicked off before send
16:46:10 <wy_> It's a little strange that code is still not as flexible as data in the processors
16:46:14 <Cale> wy_: So I think it's a potentially dangerous abuse of terminology to speak about languages "supporting closures", and such.
16:46:17 <wy_> or is it?
16:46:23 <Taejo> "We do not use the class Applicative from the module Control.Applicative" -- RAGE
16:46:37 <Taejo> the standard libraries should be *standard*
16:47:09 <SamB> Taejo: who said that?
16:47:20 <wy_> Cale: well, that's a reasonable term if you think of languages that do not "support" it nicely, like javascript, python, ...
16:47:24 <Taejo> SamB: uuparsinglib tutorial
16:47:29 <Cale> wy_: Well... even at the processor level, code is data... but the implementation I'm talking about would represent the Haskell code as a non-machine-code graph, and have a piece of machine code which runs in some kind of recursive way to rewrite the graph over and over.
16:47:49 <SamB> Taejo: that sounds a bit strange
16:47:57 <SamB> what's the context?
16:47:59 <Taejo> SamB: it's for efficiency reasons
16:48:13 <SamB> for *what* now?
16:48:30 <Cale> wy_: We should speak about languages supporting first class procedures and functions properly, not closures :)
16:48:32 <SamB> and you said this was a tutorial
16:48:38 <wy_> Cale: The abstraction of graph sounds not as neat to me. It feels "undirected"
16:48:51 <conal> Taejo: uuparsinglib preceded Applicative.  i wonder if that's why.
16:48:51 <uzytkownik> @pf \f g x -> do t <- f x; g x; return t
16:48:53 <lambdabot> Maybe you meant: bf pl
16:48:59 <Cale> wy_: It is a digraph...
16:49:12 <Cale> wy_: Instead of expression trees, you have expression graphs
16:49:23 <uzytkownik> @pl \f g x -> do t <- f x; g x; return t
16:49:24 <lambdabot> (line 1, column 22):
16:49:24 <lambdabot> unexpected ";"
16:49:24 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
16:49:26 <Taejo> conal: if that's the case, they should be honest... they claim it's for optimization
16:49:32 <wy_> Cale: I mean... the graph doesn't contain semantic information itself
16:49:42 <Cale> wy_: Eh?
16:49:52 <conal> Taejo: oh!  if you learn how not using Applicative helps them optimize, i'd love to hear about it.
16:49:52 <Cale> wy_: It sort of does...
16:49:58 <wy_> I mean, it's less syntax directed
16:50:00 <Cale> wy_: Well, it has syntactic information.
16:50:04 <Cale> It *is* syntax.
16:50:29 <wy_> but it feels very far from logics
16:50:41 <Cale> http://www.cas.mcmaster.ca/~kahl/HOPS/Screenshots/BoolList.filter.png
16:50:49 <conal> Taejo: Applicative, like Arrow, allows static analysis that Monad thwarts.  the UU parsing stuff was one of the first to notice, and partially motivated arrows.
16:50:53 <Taejo> conal: I really don't see it, since their Applicative has <*>, <|>, <$>, pure and fail, all of which are class methods, so can be overridden in the standard libs (tho not all are Applicative)
16:50:58 <Cale> That has some pictures which show what the filter function might look like
16:50:59 <uzytkownik> @pl \x -> (x, x)
16:51:00 <lambdabot> join (,)
16:51:01 <dibblego> bos, ping
16:51:09 <SamB> too bad malcolmw is missing :-(
16:51:13 <Cale> The orange arrow shows the graph transformation to apply filter
16:51:20 <uzytkownik> @hoogle join
16:51:21 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
16:51:21 <lambdabot> System.FilePath.Posix joinDrive :: FilePath -> FilePath -> FilePath
16:51:21 <lambdabot> System.FilePath.Windows joinDrive :: FilePath -> FilePath -> FilePath
16:51:35 <Taejo> conal: yeah, but I'm not sure what their Applicative has that the standard one doesn't (except merging Applicative, ApplicativeChoice and Functor)
16:51:37 <Cale> The @ nodes are function applications
16:52:14 <Cale> The rule which is named filter_[] basically represents the Haskell code  filter p [] = []
16:52:17 <Taejo> s/ApplicativeChoice/Alternative/
16:52:21 <conal> Taejo: i was telling you thing you already know, wasn't i?
16:52:21 <wy_> Cale: It contains "side effects" in the graphs
16:52:42 <conal> (things)
16:52:43 <wy_> That would make it hard to reason about them
16:52:54 <Cale> and filter_: represents the code  filter p (x:xs) = if p x then x : filter p xs else filter p xs
16:53:00 <Taejo> conal: sort of (I know the idea but not its history)
16:53:06 <Cale> wy_: Well...
16:53:37 <Saizan> Taejo: the last version of uu-parsinglib uses the standard Applicative, btw
16:54:10 <Taejo> Saizan: oh, thanks. I guess one should never assume the documentation one is looking at is up-to-date
16:54:12 <wy_> hehe. So we must use side effects to think about a pure language
16:54:12 <Cale> wy_: It's still the same pure language at some level, it's just that this HOPS language makes the graph rewriting more explicit. You could place restrictions on the sorts of rewriting rules which are to be admitted in order to make it as pure as Haskell is
16:54:19 <Taejo> now I can calm down
16:54:29 <Cale> In some sense, it is lower-level than Haskell though.
16:54:49 <Cale> But something like it is how I think of Haskell code when reasoning about its performance
16:55:19 <Cale> This graph rewriting is actually a fairly close, if imperfect, representation of what GHC-compiled programs do in memory with pointers.
16:55:30 <wy_> You mean you will think about performance when you write programs?
16:56:00 <Cale> Well, usually not much more than asymptotics when I first write things.
16:56:15 <Taejo> hmm... I like the idea that to parse online, one must do it breadth-first instead of depth-first
16:56:28 <Cale> But if I have problems, I'll profile and then think about how the functions which are spending the largest amount of time are going to get reduced.
16:56:37 <Taejo> I guess in a sense you're just making the parser predictive
16:57:18 <monochrom> I think about performance when I write programs.
16:58:00 <wy_> I mean, everybody should think about performance, but it seems to be a little too much if laziness makes it harder to think about that
16:58:28 * SamB realizes that a guy from york wouldn't maintain a package from UU
16:58:33 <Cale> It's not really that much harder to think about
16:58:53 <wy_> so that's good :)
16:59:00 <Cale> It does change the way you need to reason about performance quite a lot, and it does mean that performance becomes more "global" of a property
16:59:04 <monochrom> "does laziness make it harder" and "what should we do about it" are two big questions always on my mind.
16:59:24 <jmcarthur_work> i also think about performance when i program. i have not found that laziness makes things difficult
16:59:39 <Cale> So in some sense, that's a little harder. But usually you can think about some specific access pattern to the result of a function, and then reason about its performance from there.
17:00:12 <Cale> Once you've fixed how the result will be pattern matched against, then the performance becomes not-a-problem to reason about.
17:00:44 <dibblego> I've seen laziness cause a lot of people a lot of problems, but invariably it was because they had already installed bad software in their brain
17:01:08 <Cale> For things which produce lists, for example, it's often enough to think of performance in terms of the size of the input, and the number of elements of the resulting list which are inspected.
17:01:17 <Nafai> dibblego: Too bad I can't just apt-get remove bad_software
17:01:29 <wy_> There are too many bad softwares already. I believe we all still have some of them installed
17:01:44 <monochrom> "Just" set up a new virtual machine in your mind.  <duck>
17:01:49 <Cale> So that's a *little* bit harder than only looking at the size of the input, but not so much worse, when you think of the benefit that it potentially gives you.
17:01:53 <dibblego> Nafai, indeed, it is ultimately because their apt-get has bugs
17:02:22 <Cale> In strict languages, the performance *can't* depend on the number of elements of the result which are inspected, which means that you always have the worst possible case there
17:02:30 <monochrom> Actually these days I tell people "set up a new blank virtual machine in your mind to learn haskell". I am serious about it.
17:02:38 <wy_> UNIX is the first bad software installed ;-)
17:02:54 <Nafai> monochrom: Sounds hard :)
17:02:59 <dibblego> monochrom, I do same, but the problem is that many people don't know how "blank" it really must be
17:03:50 <uzytkownik> @hoogle liftA
17:03:50 <lambdabot> Control.Applicative liftA :: Applicative f => (a -> b) -> f a -> f b
17:03:51 <lambdabot> Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
17:03:51 <lambdabot> Control.Applicative liftA3 :: Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
17:03:52 <wy_> so let's hope haskell can run on bare hardware :P
17:04:33 <wy_> but then you need to get processors other than Intel's
17:04:40 <TomMD> dcoutts: Is there a wiki with desired improvements and features for hackage-server?  Aside from signing, file serving, and prettier pages people always mention a lot of decent ideas (the most common one being per-package download counters).
17:05:04 <dcoutts> TomMD: we use the Cabal/Hackage trac generally
17:05:23 <dcoutts> TomMD: but there are many ideas that are just floating about. Quite a few are in my head :-)
17:05:38 <wy_> bah... our system is built up with gargage and band-aids
17:05:52 <dcoutts> TomMD: yes, stats of various forms, I can tell you more about any of the areas or specific ideas
17:06:10 <wy_> s/garbage ...
17:06:29 <dcoutts> TomMD: we can certainly try and flesh out more of the ideas as trac tickets
17:07:03 <dcoutts> TomMD: up 'til now I've not generally felt it that necessary I guess since it's been reasonably obvious what needs doing, since we're not yet at feature parity
17:07:28 <defun> I am on the verge of releasing a medium sized project that is to handle encrypted communication (chat and file transfer) over the internet. What license should I use? Or rather, what licenses do Haskell projects/devs usually use, and why? Thanks. Btw, I don't plan on selling the software.
17:07:46 <dcoutts> defun: usually BSD, LGPL or GPL
17:08:02 <dcoutts> defun: with the choice depending on your views and goals
17:08:45 <defun> dcoutts: compatibility with other haskell-based projects, and apparently freedom, are my goals.
17:09:37 <dcoutts> defun: freedom is tricky :-) it depends how you look at it. There are people who say BSD is more free than GPL and others who say the reverse :-)
17:09:43 <monochrom> Using a similar license as GHC's may work nicely.
17:10:42 <dcoutts> it's pretty much impossible to pick a license that isn't compatible with GHC's
17:10:51 <defun> dcoutts: ah. I see.
17:11:02 <wy_> In what sense is GPL less free than BSD?
17:11:16 <sjanssen> defun: I'd say BSD is the most popular.  There are concerns about the GPL and static linking, which is what GHC uses
17:11:29 <sjanssen> wy_: you're not free to modify it without sharing the modifications
17:11:59 <defun> sjanssen: Wait, is BSD compatible with GPL? If I wanted to link against GHC some-day?
17:12:00 <wy_> sjanssen: oh ... that's bad
17:12:11 <dcoutts> defun: if your goal is to have your software used as widely as possible then BSD is probably the right answer, if you're trying to encourage contributions and believe that people who make changes to your code should contribute them back, then choose GPL or LGPL
17:12:25 <TomMD> dcoutts: Alright then.  I'll hack some features into it building on the patches I sent you.
17:12:35 <Ycros> defun: GPL can include BSD code, yes, it's compatible
17:12:43 <Ycros> defun: the reverse is not true however
17:12:56 <dcoutts> TomMD: one of the things I'm interested in, apart from feature parity, is good modular design.
17:13:09 <sjanssen> defun: there are various meanings of "compatibility" there
17:13:10 <wy_> The laws are bad softwares in our minds
17:13:12 <dcoutts> TomMD: which is important to get right at the beginning before we add too many features! :-)
17:13:36 <defun> sjanssen: say, dynamic linking?
17:13:50 <hackagebot> iteratee 0.2.3 - Iteratee-based I/O (JohnLato)
17:13:55 <timmaxw> why can Haskell exceptions only be caught in IO?
17:14:03 <sjanssen> defun: the concern with GPL and static linking is that non-free software can't link to GPL software
17:14:23 <sjanssen> timmaxw: because they aren't deterministic
17:14:30 <dcoutts> TomMD: ideally each feature (I don't mean cross-cutting ones like security) could be enabled or disabled just by not including that module. Eg adding a new bit of saved state and a few new pages should be possible by adding a module and linking it in to the url namespace, so only one change in shared code.
17:14:46 <defun> sjanssen: oh, that sucks. But I would be pretty much safe if I licensed under GPL, right?
17:14:53 <timmaxw> sjanssen: ignoring exceptions from other threads, why not?
17:14:57 <defun> I meant BSD.
17:15:00 <defun> Not GPL.
17:15:08 <wy_> The laws are strictly static type systems. They don't adapt well to biological systems
17:15:26 <dcoutts> defun: BSD means you're saying anyone can do whatever they like with the software you write (more or less)
17:15:28 <Ycros> defun: do you ever want to link to non-free software with your GPL code though?
17:15:29 <wy_> and written in crappy languages like English ;-)
17:15:43 <TomMD> dcoutts: What about modifications to existing pages (such as the download counter)?  Would those be forced into separate pages?
17:15:54 <sjanssen> defun: the only concern with BSD is that somebody might modify your software and not share the modifications, does that bother you?
17:15:57 <eck> i have some multi-threaded code and one thread is going crazy and spinning the cpu and allocating memory until it runs out. does anyone have any tips for how to figure out which thread it is?
17:16:05 <defun> Ycros: I meant to say BSD, and yes I would like to give ppl as much freedom as possible.
17:16:12 <defun> sjanssen: no it does not.
17:16:13 <dcoutts> TomMD: that's a bit tricky, but I've got some ideas
17:16:45 <sjanssen> timmaxw: I suggest you read the GHC exceptions paper, with laziness and compiler optimizations exceptions become somewhat tricky
17:16:50 <sjanssen> defun: sounds like BSD is for you
17:16:54 <timmaxw> sjanssen: thanks
17:17:14 <defun> sjanssen: thanks.
17:17:21 <Ycros> defun: the way I see it, it comes down to freedom propagation. BSD lets anyone do anything with your code, even to the point of releasing their own closed sourced software based on your code. The GPL merely enforces that anyone further down the line has to also share their code
17:17:37 <dcoutts> TomMD: so as Lemmih and I were initially building it, I was learning about the REST style, which seems pretty sane to me
17:18:28 <defun> Ycros: what is the point or propagation? It sounds more like a restriction, but that's just me. I'll do more research. I've to go and polish up some code. Bye.
17:18:57 <dcoutts> TomMD: in principle one can adding new state, resources etc in a pretty modular way. Things like human readable summary pages that aggregate lots of info are less modular, but hopefully they can also be relatively thin presentation veneers
17:19:11 <Ycros> defun: it is a restriction, but which one is the greater freedom? *shrug*
17:20:11 <dcoutts> TomMD: so eg if we add some new statistic about a package, that should be available individually eg $root/$pkgid/$stat and also with an internal api to get the data. Then yes the package summary page does depend and aggregate several other bits.
17:20:33 <sjanssen> defun: the argument is that the restriction increases everyone else's freedom
17:21:02 <dibblego> is there a function to get ';' on Windows and ':' everywhere else for path separator?
17:21:43 <dcoutts> TomMD: do you see what I'm getting at? each of the resources are individual identifiable resources with a URL and you can "GET" them in an appropriate machine readable format. Then separately we have nice human readable html pages.
17:21:58 <Alpounet> :-)
17:22:37 <QtPlaty[HireMe]> dibblego: The path seperator is \ on windows
17:22:54 <dcoutts> dibblego: there's splitSearchPath :: String -> [FilePath]
17:22:56 <dibblego> QtPlaty[HireMe], no, it is ;
17:23:13 <dibblego> dcoutts, I want [FilePath] -> Separator -> String
17:23:22 <dcoutts> dibblego: and there's searchPathSeparator :: Char
17:23:37 <TomMD> dcoutts: I think I see.
17:23:47 <dibblego> ah System.FilePath
17:24:50 <TomMD> But what happens to these human readable HTML pages when the module isn't avaliable?  Presumably the composing page uses some default?
17:25:21 <dcoutts> TomMD: it doesn't need to be that dynamic. Just structured well and sufficiently easily modified.
17:25:38 <TomMD> ok
17:25:58 * TomMD goes for a walk with his wife.
17:26:43 * BMeph thinks about going for a walk with TomMD's wife, then decides his own wife would be more appropriate.
17:27:19 * TomMD would be happy to see a Hackathon in his living room when he returns
17:27:51 <ski> sjanssen,(defun) : afaiu : you are free to modify GPLed software, as long as you don't make the modification public. if you do, you also need to make the source public under GPL
17:28:20 <dcoutts> :-)
17:29:14 <sjanssen> ski: I believe the term is "distribute"
17:29:25 <ski> that is probably so
17:31:38 <Nereid_> ok, it's not pretty, but I extended lists with concatenation to a group
17:31:45 <Nereid_> except infinite lists don't behave nicely
17:34:40 <centrinia> Maybe they are a subset of the elements of a free group.
17:34:59 <centrinia> Free monoid.
17:35:48 <Nereid_> well it basically is a free group
17:36:24 <centrinia> You don't really have inverse lists. ;)
17:37:02 <centrinia> Although that would be very cool. :)
17:37:07 <Nereid_> I do have inverse lists. :-)
17:37:13 <Nereid_> like I said, I extended them
17:37:20 <centrinia> Yay!
17:37:46 <Nereid_> that is, I embedded the monoid of (finite) lists with concatenation in a group
17:38:11 <Nereid_> I don't know if it's useful at all
17:39:14 <monochrom> free groups are useful. the word problem is famous and important.
17:40:00 <Taejo> monochrom: isn't the word problem trivial for free groups?
17:40:31 <monochrom> I don't know. I have forgotten too many details.
17:40:41 <Nereid_> I think it is
17:40:58 <centrinia> type FreeGroup a = [(Bool,a)] -- Is this isomorphic to a free group?
17:41:02 <monochrom> free software and the license wording problem. :)
17:41:34 <centrinia> Oh.
17:41:45 <Taejo> centrinia: depends on your operations
17:42:11 <Nereid_> centrinia: restricted to finite lists, yes
17:42:23 <Nereid_> that's basically what I have.
17:42:32 <Nereid_> except what I have is more like [Either a a]
17:42:40 <Nereid_> same thing
17:43:17 <Taejo> really, you need to take an equivalence relation on [Either a a] or [(Bool, a)] (if you mean them as I think)
17:43:43 <Taejo> since [Left x, Right x] == [] as a free-group element
17:44:01 <Nereid_> that's what I did
17:44:10 <Taejo> ok
17:44:14 <centrinia> Oh, the equivalence relation is that any sublist [(True,a),(False,a)] or [(False,a),(True,a)] is equivalent to [] ?
17:44:20 <Nereid_> yes
17:44:51 <Nereid_> no standard typeclass for groups I take it
17:45:00 <Taejo> Nereid_: no
17:45:19 <Taejo> they're not nearly as useful as monoids
17:45:32 <centrinia> class (Monoid a) => Group a where { ginv :: a -> a; }
17:46:02 <monochrom> Haskell 2046 will have the Group typeclass.
17:46:33 <centrinia> The number 2046 rings a bell somehow.
17:47:20 <Taejo> it's the exponent bias in double precision IEEE 754
17:47:24 <FunctorSal> Taejo: are there fundamental reasons why groups shouldn't be as useful in computing, or has it just not been really tried?
17:47:37 <centrinia> Ah.
17:48:03 <centrinia> Groups are useful in cryptography.
17:48:13 <Taejo> centrinia: if it that's what rings a bell, then you've been studying IEEE 754 too much
17:48:18 <EvilTerran> FunctorSal, i think it's just that there's fewer of them, because the requirements are stricter
17:48:23 <flippo> FunctorSal, you have a good inverse for every operation?
17:48:28 <FunctorSal> centrinia: sure, but I mean on the level monoids are
17:48:54 <Taejo> FunctorSal: I think it's more that "accumulating" algorithms are common, but "unaccumulating" ones are not
17:49:03 <EvilTerran> monoids havethe right balance between generality and specificity
17:49:23 <EvilTerran> (being able to do more vs being able to work with more types)
17:49:26 <centrinia> I think that groups will gain tremendous importance once reversible computing finally takes off!
17:49:32 <Nereid_> lol
17:49:33 <Nereid_> :-)
17:49:55 <Taejo> and when you do unaccumulate, you're not unaccumulating something specific (e.g., you don't do "pop foo" on a stack -- because what if foo is not on the stack? -- you just do "pop")
17:50:49 <Nereid_> in conclusion, I pretty much wasted the last hour :)
17:50:51 <monochrom> You can have something very useful in computing but no one mentions it explicitly.
17:50:57 <centrinia> Instead of having one stack, you might have two stacks that already contain everything that you will ever want to push or pop.
17:51:06 <FunctorSal> EvilTerran: of course "right balance" depends on what you're doing with it... there are hardly any theorems about monoids
17:51:21 <FunctorSal> (too general)
17:52:30 <monochrom> monoid was popularized by the writer monad.
17:53:22 <monochrom> someone decided to use existing math vocab "monoid" rather than coin new vocab "logging-like"
17:54:00 <FunctorSal> I do see how free monoids/lists terms naturally have just one representation on a storage medium, while in free groups you have a less trivial equivalence relation... (not sure how to formulate this better)
17:54:59 <EvilTerran> i think the fact that a list is a monoid, but not so trivially a group, makes a big difference to each's popularity
17:54:59 <flippo> Where does the inverse come from?
17:56:42 <centrinia> flippo, we defined something like [Either a a] or [(Bool,a)]
17:57:29 <Ycros> guys, how do I resolve this compilation error: "Could not find module `Control.Monad.Trans': it was found in multiple packages: transformers-0.1.4.0 mtl-1.1.0.2"
17:57:36 <Ycros> is there a way to specify which one I want?
17:57:44 <Ycros> (I'm using ghc --make here)
17:57:46 <FunctorSal> ghc-pkg hide transformers -- Ycros
17:57:53 <Taejo> Some voting-type thing might be an application of groups: if you can vote yes, no, or neutral to x, y and z, then your vote might be [Yes x, No z], and mine [Yes x, No y, Yes z]. Then [Yes x, No z] ++ [Yes x, No y, Yes z] = [Yes x, Yes x, No y] forms the aggregate vote (I'm adding commutativity here)
17:57:53 <FunctorSal> (or mtl :))
17:58:09 <Ycros> FunctorSal: isn't that a system/user-wide setting though?
17:58:20 <Ycros> FunctorSal: would that adversly affect other things?
17:58:20 <FunctorSal> Ycros: yes
17:58:32 <Ycros> FunctorSal: I've noticed that it doesn't come up when I build things via cabal
17:58:35 <flippo> Taejo, sounds as if you only need an abelian monoid, not a group.
17:58:48 <EvilTerran> Ycros, i believe you could give an explicit list of package deps on the command line instead of --make, but that's probably tedious
17:58:50 <centrinia> Taejo, why not use Integer instead? :p
17:58:59 <FunctorSal> Ycros: right, if you use cabal, the visible packages are set to whatever is in the build-depends: field of the .cabal file
17:59:00 <Taejo> flippo: no, I want an abelian group
17:59:05 <Ycros> EvilTerran: that does sound tedious.
17:59:08 <monochrom> integers are a group
17:59:11 <Ycros> FunctorSal: aha! on a per-compilation basis?
17:59:13 <centrinia> Uh, [Integer]
17:59:13 <flippo> Taejo, why do you need an inverse for every operation?
17:59:21 <FunctorSal> Ycros: there are probably some ghc flags to do the same, but it would be easier to just make a cabal file I think :)
17:59:28 <FunctorSal> Ycros: (there's even a "mkcabal" utility)
17:59:35 <FunctorSal> Ycros: yes
17:59:36 <Ycros> FunctorSal: can't, I'm compiling/loading plugins at runtime ;)
17:59:48 <Taejo> flippo: the whole point is that Yes x and No x are inverses
17:59:51 <Ycros> FunctorSal: I'm using makeAll from the plugins package
17:59:56 <dcoutts> FunctorSal, Ycros: the ghc flats to expose/hide packages are: -hide-all-packages  -package foo -hide-package bar
18:00:09 <Ycros> dcoutts: okay, cheers
18:00:20 <centrinia> I know! You can keep track of antimatter with a free group!
18:00:35 <Taejo> type Vote a = Map a Integer probably would be a sensible representation
18:00:44 <centrinia> Your space would be discrete of course. :p
18:00:44 <dcoutts> FunctorSal, Ycros: cabal uses "-hide-all-packages -package foo -package bar" etc for all listed build-depends. It actually specifies exact versions like -package foo-1.0
18:01:41 <flippo> Taejo, Yes x and No x are two values.  What is the operation that needs the inverse?
18:01:59 <Nereid_> flippo: he's treating Yes x and No x as inverses
18:02:06 <Nereid_> and
18:02:12 <Taejo> flippo: in a group *elements* have inverses, not operations
18:02:20 <Nereid_> so a Yes vote and a No vote cancel out
18:02:50 <FunctorSal> Taejo: I was going to say that about Map a Integer... is there some sense in which lists and free abelian groups have "free" or "syntactic" encodings in data structures, but free groups don't? sorry if I'm not making any sense
18:02:52 <Nereid_> but the order of votes doesn't matter so you're just treating two lists as equivalent if they're permutations of each other
18:02:52 <flippo> Taejo, really?
18:03:11 <Taejo> flippo: yes, really
18:03:50 <Taejo> flippo: though you could consider "multiplication-by-inverse" to be the inverse operation of multiplication, that is not the definition
18:04:16 <Taejo> FunctorSal: interesting idea
18:04:19 <flippo> Taejo, so you are conflating a reciprocal with an inverse
18:04:59 <Taejo> you can call it reciprocal if you want, but it's usually called the inverse in group theory
18:05:12 <Taejo> see http://en.wikipedia.org/wiki/Inverse_element
18:05:17 <mgsloan> reciprocal and inverse are terms I've seen interchanged a lot
18:05:31 <Nereid_> reciprocal _is_ inverse if you're dealing with numbers
18:05:37 <Nereid_> and multiplication
18:05:40 <mgsloan> I'm not that good at math, but it seems like reciprocol is the multiplicative inverse
18:05:41 <mgsloan> yeah
18:05:41 <Nereid_> anyway, time to eat :-)
18:05:50 <mgsloan> you end up with id when you multiply by the inverse
18:06:18 <FunctorSal> x is invertible for some operation (*) iff the function (x *) is invertible, so they really are very similar concepts
18:08:10 <Taejo> FunctorSal: I think it depends what we consider to be data structures. if we don't allow quotients (i.e., we require (==) to be structural equality), then Map is "unnatural" too
18:08:28 <centrinia> mgsloan: Only for a multiplicative group.
18:08:47 <centrinia> The real numbers with multiplication isn't a group. ;)
18:08:56 <mgsloan> due to 0?
18:08:58 <centrinia> You need to remove zero to make it a group. :)
18:08:59 <centrinia> Yeah.
18:09:00 <FunctorSal> Taejo: yeah but you can encode the free abelian group as an integer array with one position for each generator
18:09:25 <FunctorSal> Taejo: good point about structural equality...
18:10:24 <centrinia> You could modulo out the structure though. :)
18:10:31 <FunctorSal> you could only allow terms in normal form for the free group, but then you waste memory
18:10:39 <FunctorSal> at least for naive encodings...
18:10:43 <Taejo> FunctorSal: I will put "think about data structures for free algebras" on my todo list, but right now it's 3 AM, and I must sleep
18:10:54 <FunctorSal> yes, 3 AM here too :)
18:11:01 <Taejo> hehe
18:12:07 <Taejo> TODO: apply for continued funding, deal with car insurance, think about data structures for free algebras ... I wonder which I'm going to spend the whole of tomorrow doing
18:12:13 <Taejo> or rather today
18:28:53 <SamB> did anyone tell Taejo about http://hackage.haskell.org/cgi-bin/hackage-scripts/package/uu-parsinglib-2.1.0 ?
18:41:27 <jasondew> anyone know if there's an easy way to parse double or float values of the form ".25" ?
18:42:07 <kpreid> > read ".25" :: Float -- since you're asking I suppose this doesn't work
18:42:09 <lambdabot>   * Exception: Prelude.read: no parse
18:42:43 <jasondew> right :)
18:43:46 <aavogt> > let pad ('.':x) = "0."++x; pad x = x in read (pad ".25") :: Float
18:43:47 <lambdabot>   0.25
18:44:21 <jasondew> > let pad ('.':x) = "0."++x; pad x = x in read (pad "0.25") :: Float
18:44:23 <lambdabot>   0.25
18:44:23 <kpreid> nothing in the Numeric module...
18:44:27 <Hunner> Is there a trick to getting haskell to re-evaluate IO functions?
18:44:40 <Hunner> mine seems to do it once and ignore any changes after that
18:44:40 <jasondew> that works, thanks :)
18:44:45 <kpreid> Hunner: you probably don't want what you're asking for
18:45:08 <kpreid> are you using unsafePerformIO or something?
18:45:27 <Hunner> it's something like this http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5744
18:45:35 <Hunner> that's from a while ago, but most of the code is the same
18:46:16 <Hunner> Anyway, the first time I call that function it compiles the module and loads it, and won't do it again after that without restarting the program
18:46:53 <kpreid> Are you sure the problem isn't that you can only load a module with a given name once?
18:47:35 <Hunner> I don't know the problem. I'm somewhat new to haskell and this is one of my first tries at IO beyond putStrLn
18:48:59 <Hunner> pasted the current version under that, but it's pretty much unchanged except for adding some abstraction for the types system
18:50:03 <Hunner> It knows what to do if the IO throws an exception, so I'm not worried about it being safe pretty much
18:50:30 <Hunner> But the whole point is that I don't have to restart the program every time I want to change the external modules
18:50:37 <kpreid> you need a ghc expert; this is not a general working-with-IO problem
18:50:52 <Cale> Hunner: So this isn't just IO, it's runtime evaluation of Haskell code using the GHC api...
18:51:00 <Hunner> Yeah, that :)
18:51:00 <kpreid> though it would be useful to say exactly what happens in the failing case
18:51:32 <Hunner> If you refresh the hpaste you see it returns (Left String) on a failing case
18:51:32 <kpreid> it has got to return something: is it Left "Compilation failed"? Or Right _|_? What?
18:52:19 <Hunner> as far as what type Right is, that is determined by the calling function
18:52:24 <Cale> What is the purpose of that unsafeCoerce?
18:52:49 <Cale> That seems scary to have to do...
18:53:05 <Hunner> Because it returns an HValue, and since I should know what type I'm getting I have to coerce it
18:53:16 <Hunner> this post explains a lot of it http://www.bluishcoder.co.nz/2008/11/dynamic-compilation-and-loading-of.html
18:53:38 <Cale> You might have an easier time with using hint than directly using the GHC API.
18:53:45 <Hunner> and it works pretty swimmingly, not having to recompile the main program
18:54:01 <roconnor> what is a Net String?
18:54:18 <Hunner> the Net monad is from http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
18:54:31 <Hunner> I'm trying to not have to restart the bot every time :)
18:55:08 <kpreid> btw your "force" is flip asTypeOf
18:55:14 <Hunner> oh, thanks
18:55:22 <kpreid> :t asTypeOf
18:55:23 <lambdabot> forall a. a -> a -> a
18:55:25 <kpreid> @src asTypeOf
18:55:26 <lambdabot> asTypeOf = const
18:55:37 <roconnor> that unsafeCoerce seems unsafe to me
18:55:40 <kpreid> > [] `asTypeOf` "aardvarks"
18:55:42 <lambdabot>   ""
18:55:43 <roconnor> why not just use return?
18:55:54 <Hunner> roconnor: probably, but step gingerly and you won't die :)
18:56:12 <roconnor> that unsafeCoerce seems extremely unsafe and will never work to me
18:56:23 <roconnor> why not just use return?
18:56:39 <Hunner> roconnor: how does returning an HValue keep me from having to coerce it?
18:56:45 <roconnor> oops
18:56:46 <roconnor> sorry
18:56:51 <roconnor> I misread the type annotation
18:57:26 * roconnor thought it was (unsafeCoerce :: String -> Net String)
18:57:31 <Hunner> Yeah, the type coersion is just matching the requested function in the compiled module, so it should be fine
18:57:56 <Hunner> no, I changed that. See http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5744#a5753
18:58:32 <Cale> hint provides: interpret :: (MonadInterpreter m, Typeable a) => String -> a -> m a  which produces a meaningful error if the value you're trying to get is the wrong type.
18:58:58 <Cale> er, no, actually that one lets you have a default
18:59:09 * Hunner pastes an example of use
18:59:40 <Cale> Oh, actually, I was right the first time :)
18:59:52 <Cale> the parameter of type a is just a witness for the type you want
19:00:04 <Hunner> Yeah... I think...
19:00:58 <Hunner> is there a way to get the @src thing in ghci?
19:01:58 <Cale> No, the @src thing is just a database of strings anyway.
19:02:19 <Cale> (it's not necessarily the actual source)
19:02:35 <Hunner> kk
19:02:39 <Cale> You can however click the source links in the Haddock documentation
19:03:55 <Hunner> So, any ideas on getting this function to evaluate the source file more than once? If the compile fails, then it will re-evaluate the file each time until it succeeds, then doesn't look at it again
19:04:17 <Hunner> each time it is called*
19:06:53 * Hunner rides home before the sunlight dies. Will read scrollback after getting home
19:07:31 <Nereid_> Hunner: no way to make it forget the compiled code?
19:09:05 <Nereid_> also, it seems like writing an irc bot is the popular thing to do in Haskell. I'm doing it :(
19:10:35 <dibblego> is there no way to "friend" modules -- export a function visible only to certain modules
19:11:42 <Nereid_> what if you write the function in its own module, and import it in each module that you want to share it?
19:11:58 <Nereid_> share it in, I mean
19:12:02 <Nereid_> or with
19:12:20 * Nereid_ is new, there are probably better ways
19:14:43 <SamB> dibblego: lay of the C++, *please*!
19:15:41 <Cale> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5744#a5755
19:15:45 <dino-> dibblego: I was thinking about this earlier too but from the angle of putting testing property function in the module they test so that they have scope to internals without having to export..
19:16:04 <dino-> But the downside of that seems to be all the cranky unused function compiler warnings that will fly out of that.
19:16:26 <pumpkin_> seems like the best option is to put the tests in the same module, but CPP them out for .cabal distribution
19:16:34 <pumpkin_> not sure, is there anything better?
19:16:55 <monochrom> No.
19:17:02 <Cale> oops, missed the module decl line in Command.hs
19:17:40 <Cale> (http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5744#a5756)
19:18:01 <dibblego> can you export record selectors and type-class instances but no constructors of a type?
19:18:14 <SamB> does the _ import rule apply to Haskell, or am I thinking of Python?
19:18:24 <Cale> dibblego: yes
19:18:58 <Cale> dibblego: In the export list, list the type name, but don't put (..) after it, and list the record selectors manually, I think.
19:19:12 <Cale> SamB: _ import rule?
19:19:31 <SamB> Cale: where _-prefixed names aren't imported without being explicitly asked for
19:19:41 <dibblego> Cale, I tried that to no avail ( the type-class instance was unavailable)
19:20:00 <Cale> dibblego: That's odd. It's impossible to prevent typeclass instances from being exported actually.
19:20:01 <dino-> hm, -fwarn-unused-binds
19:20:09 <dibblego> Cale, that's what I thunk
19:20:13 <Cale> SamB: I'm pretty sure that's only python.
19:20:26 <SamB> it might be neat though
19:20:44 <heatsink> Argh.  I somehow failed to anticipate the need to write TH Lift instances for my data structures.
19:21:03 <dibblego> Cale, my mistake, sorry
19:21:12 <dino-> there is something about reporting unused pattern matches but suppressed if it begins with _
19:21:15 <SamB> heatsink: you could probably write those with TH!
19:21:18 <dino-> http://www.haskell.org/ghc/docs/latest/html/users_guide/options-sanity.html
19:21:23 <SamB> heatsink: tried derive?
19:21:34 <dino-> At the very end of that page
19:21:34 <heatsink> SamB: I can derive lift?  Cool!
19:21:59 <SamB> heatsink: I expect so
19:22:14 <SamB> you might or might not have to write the code yourself, but it shouldn't be that hard ...
19:22:18 <heatsink> Hmm, GHC says no.
19:22:29 <SamB> heatsink: oh, sorry, I meant the library!
19:22:40 <SamB> @hackage derive
19:22:40 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/derive
19:23:53 <SamB> hmm, I don't see any modules that look quite right ...
19:24:05 <heatsink> SamB: Should I be looking for Data.Derive.Lift?
19:24:21 <SamB> ... looks like you'll have to make it yourself
19:24:34 <SamB> but there's that http://hackage.haskell.org/packages/archive/derive/0.1.4/doc/html/Data-DeriveGuess.html
19:24:38 <heatsink> Writing lift instances actually seems to be pretty straightforward as long as your data is finite
19:24:47 <heatsink> lift (Foo bar baz) = [| Foo bar baz |]
19:24:51 <heatsink> etc.
19:24:58 <SamB> heatsink: indeed
19:25:35 <SamB> I expect it won't give guess too much trouble, assuming you can nest [| |]
19:26:09 <SamB> > [| [| () |] |]
19:26:09 <lambdabot>   <no location info>: parse error on input `|'
19:26:09 <SamB> aww
19:26:11 <SamB> , [| [| () |] |]
19:26:13 <lunabot>  luna: Illegal bracket at level Brack 2
19:26:21 <SamB> , [| |]
19:26:22 <lunabot>  luna: parse error on input `|]'
19:26:27 <SamB> , [| () |]
19:26:29 <lunabot>  ConE ()
19:26:32 <SamB> typical
19:26:34 <SamB> you CAN'T
19:27:02 <Cale> heh, some of the code layout in this derive package is... suboptimal
19:27:03 <SamB> ... hmm, thinking about it, that makes sense
19:27:07 <Cale> makeIs = derivation is' "Is"
19:27:08 <Cale> is' dat = ((map (\(ctorInd,ctor) -> (FunD (mkName ("is" ++ ctorName ctor)) [(
19:27:08 <Cale>     Clause [((flip RecP []) (mkName ("" ++ ctorName ctor)))] (NormalB (ConE (
19:27:08 <Cale>     mkName "True"))) []),(Clause [WildP] (NormalB (ConE (mkName "False"))) [])]
19:27:08 <Cale>     )) (id (zip [0..] (dataCtors dat))))++[])
19:27:15 <heatsink> TH isn't impredicative I guess
19:27:19 <SamB> Cale: that's from Guess
19:27:24 <Cale> ah
19:27:33 <SamB> Cale: it just spits it out line-wrapped
19:27:59 <SamB> if a human had to edit it, it would be much nicer looking
19:28:48 <SamB> Cale: the real human-written part is in #ifdef GUESS
19:29:42 <heatsink> I'm uncomfortable synthesizing a lift instance when I don't know how the guess module works, so I'll just hack one out.
19:30:13 * SamB wonders how many MetaML programmers we'd need to kidnap to get that single-stage restriction lifted
19:30:57 <mmorrow> heatsink: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5757#a5757
19:30:58 <monochrom> I prefer Gauss to Guess.
19:32:00 <SamB> mmorrow: what library was that second module from?
19:32:18 <SamB> @doc Language.Haskell.Meta.Utils
19:32:18 <lambdabot> Language.Haskell.Meta.Utils not available
19:32:27 <SamB> lambdabot: look on hackage, you moron!
19:32:37 <SamB> @go Language.Haskell.Meta.Utils
19:32:38 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/haskell-src-meta
19:32:39 <lambdabot> Title: HackageDB: haskell-src-meta-0.0.3.1
19:32:39 <mmorrow> haskell-src-meta (which is needed for deriveLiftPretty *and* for the ability to lift the resulting `Dec's themselves in order to do that in ghci)
19:32:54 <mmorrow> because it include instances of Lift for all of the TH AST
19:33:13 <SamB> mmorrow: huh ... you'd think those ought to be in the box!
19:33:35 <mmorrow> SamB: hopefully one day
19:34:06 <mmorrow> hmm, i wonder what it'd take to add "deriving (Lift)" to ghc..
19:34:22 <SamB> mmorrow: I dunno if there's much point
19:34:30 <SamB> when you can use a library for that bit
19:34:39 <mmorrow> heh, so what are you saying then?
19:34:43 <mmorrow> oh, in the TH lib?
19:35:02 <SamB> putting it in the TH lib would be sensible, yeah
19:35:10 <SamB> but there's no need to add it to GHC proper
19:35:18 <mmorrow> ah, yeah that would work too
19:35:47 <dino-> Closest I could get to don't warn me about unused unit testing props is {-# OPTIONS_GHC -fno-warn-unused-binds #-}
19:35:54 <SamB> especially considering that the library approach is more friendly toward a potential second implementation
19:36:02 <dino-> Which works but will of course prevent warnings about unused other things you may want to have seen.
19:36:14 <mmorrow> SamB: yeah, i like the in-the-lib way more than in ghc
19:36:36 <mmorrow> SamB: for some reason i just didn't' think of in-the-lib first
19:37:02 <SamB> I mean, if you want a Lift instance, you're already using TH, so you might as well use TH to get it, too ;-)
19:37:28 <mmorrow> totally. TH is great in this way, it's self-replicating!
19:37:29 <SamB> hmm, I need to upgrade GHC :-(
19:38:39 <mmorrow> argh, that reminds me i have to update all my TH stuff for the changes to the TH lib coming in 6.12
19:38:56 * mmorrow doesn't look forward to this
19:39:22 <mmorrow> (to the updating-my-code part ;)
19:39:37 <SamB> I wonder why they only update that at releases anyway
19:39:57 <mmorrow> because it would break a ton of code? :)
19:40:23 <SamB> I mean, they could have multiple versions on cabal, as long as the AST types themselves didn't get changed
19:40:46 <SamB> though I guess that would be a real pain ...
19:40:47 <mmorrow> the AST types themselves are what got changed slightly though
19:40:55 <SamB> mmorrow: ah
19:40:59 <mmorrow> to accomodate type families
19:41:19 <SamB> it's a pity they can't add stuff without breaking the binary interface
19:41:47 <SamB> and somehow just soft-fail if you actually try to use it
19:42:06 <SamB> but also allow apps to interrogate GHC for what it supports ...
19:42:27 <SamB> ... or maybe not. I dunno.
19:42:28 <mmorrow> hmm
19:43:41 <heatsink> No instance for (Lift Double) ???
19:43:54 <mmorrow> heatsink: oh that's annoying, there're two ways to do it
19:43:57 <mmorrow> i'll paste
19:44:11 <mmorrow> (the efficient way requires you to import GHC.Exts into the module with the instance)
19:44:46 * mmorrow just needed Lift for Double yesterday coincidently
19:45:09 <heatsink> thanks
19:46:19 <SamB> mmorrow: why can't you just derive it using TH again?
19:48:16 <mmorrow> heatsink: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5757#a5759
19:48:45 <mmorrow> SamB: the TH Lit type has to place to stick a Double... so you need to go about it by one of the two ways in that paste
19:49:37 <mmorrow> (and that lift deriving code would do  instance Lift Double where lift (D# d) = ..... lift d .....)
19:49:45 <mmorrow> and `d' :: Double#..
19:49:59 * SamB wonders why they bother having totally uninstallable pakcages in Debian testing
19:50:06 <Hunner> Cale: Thanks
19:50:10 <SamB> mmorrow: hmm, yeah, point ...
19:50:17 <Cale> Hunner: no problem :)
19:50:17 <SamB> that's not even well-typed ...
19:50:21 <heatsink> Cool, it compiles now.  I wonder if it works.
19:50:26 <mmorrow> woo
19:50:38 <SamB> or well-kinded
19:51:00 <mmorrow> yeah
19:51:34 <SamB> mmorrow: are they adding that in GHC 6.12 as well?
19:52:03 <SamB> have you tried sending in a patch?
19:54:15 <SamB> kaol: where do you keep the REAL ghc packages?
19:54:42 <SamB> these ones in unstable are all out-of-sync wrt eachother
19:54:43 <mmorrow> SamB: i should
20:10:56 <heatsink> Cool, my pattern match compiler compiles pattern matches!  I'll have to write some more code before I can test whether it works.
20:11:10 <heatsink> TH FTW.
20:11:31 <heatsink> Thanks SamB, mmorrow
20:13:52 <mmorrow> heatsink: nice! no problem
20:15:46 <mmorrow> heatsink: fwiw here's list-comprehension desugaring for the TH ast http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2490
20:17:27 <mmorrow> it spits out stuff like this http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2260 :)
20:19:05 <mmorrow> i had to do a (minimal) pattern match compiler a few days ago, goooh it's epic (left a "XXXXX: probably rewrite this module" note at the top, but it works good enough for now ;)
20:19:31 <heatsink> Ah, I see.  But why would you want to desugar list comprehensions?
20:20:15 <mmorrow> heatsink: as one of the many steps to go from haskell-like lang to lower-level reps
20:20:27 <heatsink> what
20:20:32 <heatsink> are you writing a compiler in TH or something
20:20:56 <mmorrow> heatsink: (but that code i wrote to learn the list-comp desugaring process, and just happened to use TH because it's "right there")
20:21:15 <mmorrow> heh, no, but the technique is the same in whatever AST
20:21:28 <mmorrow> (i rewrote that code for my ast)
20:21:41 <heatsink> Oh I see.
20:21:51 <dibblego> dcoutts, if I wish to create a package for hackage, is there a starting point for what is required?
20:21:56 <heatsink> Heh, rapid prototyping in GHC
20:22:04 <mmorrow> totally! ;)
20:22:55 <heatsink> So, it sounds like you're writing a compiler
20:23:38 <mmorrow> heatsink: yes, i'm writing an interpreter
20:24:16 <heatsink> Is it for a new programming language?
20:25:31 <mmorrow> heatsink: it's about 90% done, i'm in the final pass to backpatch all the things i broke (in the translation process) when i finally got the C part all sorted out, so.. one more AST-to-AST translation module to repair, then it'll actually work from top-to-bottom
20:26:04 <mmorrow> heatsink: i'm shooting for an interp that any lazy functional language could in principle target
20:26:37 <mmorrow> and am just doing the haskell-like input lang for convenience/so i can type stuff into a repl and have it run
20:27:13 <mmorrow> but the focus is on the C interp/runtime and ByteCode-ish haskell bits
20:28:26 <Berengal> type-level is a completely different language, and requires completely different thinking :/
20:29:20 <heatsink> Isn't that more or less what the STG work was about though?
20:30:54 <mmorrow> heatsink: yes, the abstract machine i'm using is similar in some ways to STG, but it uses no stack and has native callCC, so in that sense it's similar to smlnj's cps stuff
20:31:28 <heatsink> Ah
20:32:01 <mmorrow> ah, and also it's a register machine
20:32:11 <mmorrow> (err, which i guess follows from no stack)
20:32:52 <mriou> mmorrow sorry I overheard, so what are you planning to use it for?
20:39:23 <mmorrow> mriou: i'm going to release it once i've got it minimally working and documented, and once at that point i'd like to continue to improve and work on it
20:40:09 <SamB> mmorrow: that's a use?
20:40:29 <mmorrow> SamB: well i'm gonna run programs on it too ;)
20:41:30 <mriou> I'm sort of interested when you release it, I've been noodling with a functional, dynamically typed pet language recently
20:41:36 <mmorrow> also, (once it's working) translating ghc's external core to its input language would be pretty easy, so it could be hooked to ghc for instance
20:41:49 <mmorrow> mriou: ooh, cool
20:42:28 <mriou> so far I've implemented a crude interpr in Haskell but I'd be interested in checking yours, sounds like fun :)
20:42:36 <mmorrow> mriou: i'll make an annouce on haskell-cafe when i do
20:42:40 <ManateeLazyCat> How to improve code "liftM2 Statusbar (statusbarSubitemNew statusBox) (statusbarSubitemNew statusBox)" that don't write "(statusbarSubitemNew statusBox)" twice? Thanks!
20:42:49 <mriou> mmorrow: will keep an eye on it then
20:43:02 <pumpkin_> ManateeLazyCat: if you really want to
20:43:05 <mmorrow> mriou: yeah, i've learned more working on this than i have in all the time i've been programming
20:43:18 <pumpkin_> do: join (liftM2 Statusbar) (statusbarSubitemNew statusBox)
20:43:24 <pumpkin_> but I'm not sure that's much better
20:43:28 <heatsink> mmorrow: It will be interesting if you can get several different lanaguages to all target your interpreter, and write mixed language programs
20:43:46 <mriou> mmorrow: similar experience here :)
20:44:06 <mriou> although I've tried to work more on the lang than the interpr
20:44:16 <mriou> so yours is probably far better
20:44:37 <mmorrow> mriou: sorting out the gc/interp/compiler-knowing-about-everything mutual interdependency was the hardest part i'd say
20:44:52 <ManateeLazyCat> :t join
20:44:53 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
20:44:54 <mmorrow> mriou: yeah, i've mostly been focusing on the interpreter/virtual machine
20:45:40 <mmorrow> heatsink: yeah, that would be really interesting
20:45:47 <ManateeLazyCat> pumpkin_: Thanks
20:45:51 <heatsink> ManateeLazyCat: let x = statusbar SubitemNew statusBox in Statusbar x x
20:46:01 <mriou> mmorrow that's a very fun part, what made you choose a register machine instead of stack?
20:46:05 <heatsink> err
20:46:09 <ManateeLazyCat> heatsink: Yep, that's a better idea. :)
20:46:09 <heatsink> ManateeLazyCat: let x = statusbar SubitemNew statusBox in liftM2 Statusbar x x
20:46:35 <ManateeLazyCat> heatsink: Thanks.
20:46:58 <heatsink> np
20:47:34 <heatsink> Well, bedtime
20:47:34 <SamB> mriou: don't stack machines perform badly these days?
20:48:23 <mriou> SamB: depends, they have some advantages and with deep pockets you can make them perform just like register machines
20:48:47 <mriou> it requires more effort to get to that I think
20:48:59 <mmorrow> mriou: register-based interps seem to have better performance (from what i've read), and also then if i wanted to compile to machine code i wouldn't have to rewrite everything. those were my two motivating fators i'd say
20:49:03 <mriou> at least that's my take
20:49:09 <SamB> mriou: isn't it better to do something cheaper, and spend the savings on chocaolate?
20:49:39 <mmorrow> and also i was (am) interested in register allocation
20:49:50 <mriou> SamB: depends what you're optimizing for, most people find generating code for stack machines easier
20:50:12 <mriou> so one argument is that you can gain a bigger ecosystem
20:50:14 <SamB> I don't think it helps much for lazy functional languages
20:51:01 <mriou> SamB: probably true, I don't have enough experience with a lazy functional impl. to say
20:51:02 <mmorrow> and since i'm doing callCC too i can't (easily) use a stack for control
20:51:15 <mriou> mmorrow: right
20:51:37 <mriou> mmorrow so what does you IR looks like?
20:51:51 <mriou> mmorrow sorry, I'm mayve too curious
20:51:58 <mmorrow> heh, not at all
20:52:00 <SamB> mriou: you mean "what do your IRs look like?"
20:52:40 <mriou> SamB I meant the highest level Intermediate Representation
20:52:49 <mriou> i.e. 3 address code
20:53:10 <SamB> ... that's what you call high-level ?
20:54:00 <mriou> from a VM perspective it is, no?
20:54:08 <mmorrow> mriou: so i've kinda got two different versions right now that i'm merging (this is the final bit i mentioned earlier). initially i was using one that was ANF-ish, but i'm converting that to a more CPS-ish one to make the ->bytecode part a little simpler
20:55:21 <mriou> mmorrow nice
20:55:57 <mmorrow> and since i didn't have the entire thing planned out exactly at the start of all this, writing and getting each phase to work would put constraints on the other phases, which then needing tweaking/fixing, which then put constraints on the other phases, which then needed ....., so i think i'm at the fixed point
20:57:00 <mriou> mmorrow I know the feeling, those things require a lot of rewrites
20:57:57 <mriou> mmorrow so you already have bytecode generators?
21:00:47 <mriou> I have to admit I'm somewhat clueless in what a lazy functional bytecode looks like and how you optimize it
21:03:10 <mmorrow> mriou: yes, i've got haskell code that spits out all the C boilerplate code given a sort of byecode definition (but it doesn't autogen the actual bytecode implems in the C interp itself), along with a huge haskell data decl and misc module, and then there's the serialization bit which isn't too bad. so what i basically have to left is (1) sort out the lowest-level IR lang, (2) fix the translation of that to the abstract haskell bytecode
21:03:10 <mmorrow> AST, (3) which'll finalize the bytecode def, (4) regenerate all the boilerplate if i have to make any small changes, (5) touchup the interp, (6) done! :)
21:05:46 <mmorrow> mriou: i've gotta run, but i'll let you know how it's going if you're around.
21:06:02 <mriou> mmorrow thanks! and thanks for all the explanations
21:06:13 <mriou> I'll be around
21:22:25 <Berengal> mmorrow: That querying code you showed me yesterday, it looks like it doesn't create or tend the IntMap itself, does it?
21:23:56 <eck> i'm trying to debug a program i've written, where one thread (i'm not sure which one) starts spinning at some point and allocating all available memory
21:24:01 <eck> i'm trying to figure out which thread it is
21:24:29 <eck> does anyone have any pointers? i was hoping that i could use the profiling stuff to see where all the memory is, and then run my code with +RTS -
21:24:53 <eck> i mean +RTS -M100M -p or similar; but when when the program runs out of memory, it doesn't seem to dump profiling data
21:27:04 <Berengal> lookupBy :: (Eq k) => (v -> k) -> k -> [v] -> Maybe v does what I want, but uses alists. Using Map seems much harder to accomplish...
21:27:30 <QtPlaty[HireMe]> Is there an interface to Data.Map that isn't sucky?
21:27:46 <Berengal> Meaning?
21:28:26 <QtPlaty[HireMe]> One that doesn't have a whole host of functions named the same as prelude functions?
21:29:09 <Berengal> If the names weren't reused, we'd be having pretty sucky names...
21:29:30 <Berengal> Besides, I think of it as the other way around. Map has first priority on those names :)
21:29:49 <Berengal> (The list functions shouldn't be in the prelude, but in Data.List)
21:30:16 <QtPlaty[HireMe]> Berengal: Well there is no need to use "map" for example when they can (and do) just define an instance of Functor
21:30:33 <mmorrow> Berengal: no, it just does the ops on the indexes and leaves what to do with those results up to the code that's using it (for one thing i used , data Key = IdC Id | DeptC Dept ..., type Id = String, data Acct a = Acct {acct :: Id, dept:: Dept, months :: [a] ... }, and then had  (IntMap (Acct Double), [(String, Ix Key)], where the String's were "acct", "dept", ...)
21:31:17 <mmorrow> so basically had an Ix on every "column" i was interested in
21:31:34 <Berengal> mmorrow: Right. I've been trying to move this to the type level, but I'm no type hacker :/
21:31:55 <mmorrow> sounds painful :)
21:32:40 <Berengal> In a perfect world, I'd be able to have something like (emptyMap, byName ::: byPhoneNumber ::: Nil) = createMap (name ::: phoneNumber ::: Nil)
21:33:03 <mmorrow> ah, yeah something like that would be nice if it could be sorted out
21:33:08 <roconnor> what is a good reference for the fact that the lambda calculus can be interpreted in any CCC?
21:33:12 <Berengal> where data a ::: b = a ::: b, data Nil = Nil, some fancy type families and classes
21:33:22 <roconnor> the simply typed lambda calculus can be interpreted in any CCC?
21:33:32 <mmorrow> Berengal: you might want to try GADTs for that
21:34:28 <Berengal> mmorrow: Maybe... I also need to be able to map type-functions on the types in a type-list
21:34:48 <mmorrow> data a ::: b where Nil :: ():::(); (:::) :: a -> b:::c -> a:::(b:::c)
21:34:51 <mmorrow> or something
21:34:56 * mmorrow disappears
21:34:57 <roconnor> oh
21:34:58 <mmorrow> good luck
21:35:05 <roconnor> this was done by Lambek
21:35:31 <Berengal> The input is a list of function from type 'v' to any type, and the result is a list of functions from the result types to type Int, or something...
21:45:17 <mmorrow> Berengal: (err, just checked and i didn't remember that exactly correctly, this gives essentially a summary of the app http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2705)
21:50:08 <Berengal> mmorrow: I think I see what you're doing. It's tantalizingly close, yet not completely there...
22:00:05 <Apocalisp> Is there some method of calculating the edit distance between two programs?
22:04:33 <blackdog> Apocalisp: in textual form or on an AST?
22:04:47 <blackdog> edit-distance is pretty easy on strings :)
22:04:52 <Apocalisp> algebraically
22:09:20 <blackdog> hm, not on general algebraic datatypes. might be able to do something with generics?
22:41:14 <ski> mmorrow : will you support delimited continuations ?
22:41:35 <Neut> if I have a data type like this,
22:41:52 <Neut> date Blah = Blah | Joke Cat | Bloke Name
22:42:02 <Neut> and I have a list of [Blah]
22:42:11 <Neut> how can I extract the name, from the bloke?
22:42:32 <Baughn> foo (Bloke name) = name, or any other pattern match
22:42:34 <ski> what do you want to do if not every `Blah' element is of the `Bloke name' form ?
22:42:55 <Baughn> Neut: I would probably not use the same name for the type and a constructor, unless it's a single-constructor type
22:43:13 <Neut> Baughn: Yeah I didn't bad example type sorry
22:43:23 <Neut> Baughn: I tried what you said but I get an error
22:43:45 <Neut> wait I used a captial
22:43:47 <Neut> ARGH
22:43:48 <Neut> thanks..
22:43:51 <ski> Neut : if you just want to ignore the non-`Bloke name's in the `blahList', try `[name | Bloke name <- blahList]'
22:45:06 <Neut> ok thanks alot guys
22:45:09 <Neut> got it
23:21:43 <quicksilver> HAHAHAHAHA. Priceless.
23:21:51 <quicksilver> "In as far as understanding it, it may be easier if you look at the generalized version of the anamorphism"
23:21:59 <quicksilver> only in haskell-cafe could you see that
23:22:02 <pumpkin_> lol
23:22:06 <quicksilver> (as the answer to a *beginner's* question)
23:22:41 <Beelsebob1> rofl
23:22:50 <DrSyzygy> *snerk*
23:30:39 <opqdonut> quicksilver: which thread?
23:36:00 <quicksilver> opqdonut: "Building a tree?"
23:41:42 <tibbe__> I'm jealous of Clojure's logo
23:41:46 <tibbe__> http://clojure.org/
23:42:17 <chromakode> pretty!
23:42:42 <dhun> is there a function to convert a string to lower, I was thinking about map \x-> ... and toLower. But is it in the library already?
23:43:41 <maltem> > map toLower "BluB"
23:43:42 <lambdabot>   "blub"
23:43:54 <maltem> dhun, short enough I'd say
23:44:14 <dhun> ok
23:44:20 <tibbe__> FWIW: map toLower is incorrect for Unicode
23:44:28 <dibblego> @pl liftM2 k (f a) (f b) -- can this be simplified?
23:44:29 <ziman> > toLower."BluB"
23:44:29 <lambdabot> liftM2 k (f a) (f b)
23:44:29 <lambdabot>   Couldn't match expected type `a -> GHC.Types.Char'
23:44:48 <ziman> liftM2 k `on` f
23:44:52 <tibbe__> since one character might translate to two or more characters in lower case
23:45:08 <dhun> what shall I use instead
23:45:09 <dibblego> @hoogle on
23:45:10 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
23:45:10 <lambdabot> Text.PrettyPrint.HughesPJ OneLineMode :: Mode
23:45:10 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
23:45:14 <tibbe> Data.Text does it correctly
23:45:31 <tibbe> dhun: if you're using String that's the best you can do without rolling your own lowercasing code
23:45:50 <tibbe> dhun: but a correct lower casing algorithm is not a `map`
23:45:58 <dhun> I see
23:46:02 <tibbe> dhun: as map translates elements 1->1
23:46:08 <dhun> yes
23:46:13 <DrSyzygy> tibbe: concatMap ?
23:46:22 <tibbe> :t concapMap
23:46:23 <lambdabot> Not in scope: `concapMap'
23:46:30 <tibbe> :t concatMap
23:46:31 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
23:46:42 <tibbe> DrSyzygy: yes that would indeed work
23:47:09 <DrSyzygy> Though ... is that enough? Or are there instances of the preimage being larger than one char?
23:47:16 <tibbe> http://hackage.haskell.org/packages/archive/text/0.3/doc/html/Data-Text.html#v%3AtoLower
23:47:21 <dhun> where is it defined in Data.Text?
23:47:25 <tibbe> DrSyzygy: I don't think so
23:47:31 <tibbe> dhun: see my link ^
23:47:42 <DrSyzygy> tibbe: For toUpper, this certainly is the case.
23:47:43 <tibbe> dhun: it has type Text -> Text
23:47:59 <tibbe> DrSyzygy: do you have an example?
23:48:04 <DrSyzygy> See the turkish i for a Counterexampletoeverything.
23:48:11 <tibbe> hah
23:48:12 <tibbe> great
23:48:20 <tibbe> so maybe concat map is not enough then
23:48:28 <DrSyzygy> Also, in some cases, in German, SS should become  and sometimes it should become ss
23:48:33 <tibbe> then there's the question of combining characters (whatever they're called)
23:48:35 <dhun> can I apply it to a string?
23:48:43 <tibbe> DrSyzygy: true
23:48:48 <DrSyzygy> I think the Right Thing To Do is to work on graphemes or on code points or something like that.
23:48:53 <tibbe> dhun: not efficiently but yes
23:49:02 <tibbe> dhun: Text is a relatively new replacement to String
23:49:16 <tibbe> dhun: so if all your code uses String then maybe a map toLower is OK for now
23:49:28 <dhun> yes maybe
23:49:37 <maltem> I think the right thing is to always write text in proper capitalization, so you won't have to change afterwards
23:50:00 <tibbe> dhun: you could use Data.Text.unpack/pack to convert back and fort but that adds a dependency on the text library to your code and isn't as efficient as using only Text
23:50:39 <tibbe> dhun: not that a dependency on Data.Text is bad, it's a very nice library
23:50:58 <dhun> I think I will do it
23:51:06 <tibbe> dhun: alright, have fun :)
23:51:09 <dhun> I need it only for 200 Strings
23:51:17 <tibbe> ok
23:52:30 <Cale> dhun: By the way, with map and toLower, of course you don't need a lambda
23:52:46 <Cale> > map toLower "HeLLo"
23:52:47 <lambdabot>   "hello"
23:54:28 <dhun> yes right
23:55:20 <Cale> dhun: This is probably why there isn't a string-specific version of it. However, while this works well for plain English strings, it doesn't really work out properly in unicode as some languages make changing between upper/lowercase impossible at a character by character level.
23:56:18 <dhun> yes
23:56:20 <Cale> (but the base library just doesn't handle that... there might be something on hackage though)
23:57:09 <tibbe> Cale: Data.Text !
23:57:28 <dhun> does anyone know the name of the debian package containing Data.Text
23:57:45 <tibbe> dhun: there might not be one yet
23:57:56 <tibbe> Here's the blog post about Data.Text's case folding: http://www.serpentine.com/blog/2009/06/07/case-conversion-and-text-03/
23:57:58 <dhun> any other way to get it
23:58:03 <tibbe> dhun: yes, sec
23:58:14 <dhun> what the hell is sec
23:58:14 <tibbe> dhun: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/text
23:58:15 <Cale> dhun: Install cabal-install and then you can cabal install <packagename>
23:58:24 <tibbe> dhun: just a second ;)
23:59:44 <Cale> Or, you can download the source from hackage and install it manually, but cabal-install is convenient.
