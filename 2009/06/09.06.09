00:03:05 <tibbe> is there an efficient way to copy the values of one STArray into another?
00:04:16 <pumpkin> I don't think so
00:05:24 <pumpkin> lol, in the comment:         -- No Ix context for STArray.  They are stupid,
00:05:49 <Berengal> Which comment?
00:05:57 <pumpkin> for STArray
00:06:44 <Berengal> Ix contexts are stupid now?
00:07:17 <pumpkin>         -- No Ix context for STArray.  They are stupid,
00:07:18 <pumpkin>         -- and force an Ix context on the equality instance.
00:07:26 <pumpkin> -- Just pointer equality on mutable arrays:
00:07:26 <pumpkin> instance Eq (STArray s i e) where
00:07:26 <pumpkin>     STArray _ _ _ arr1# == STArray _ _ _ arr2# =
00:07:26 <pumpkin>         sameMutableArray# arr1# arr2#
00:08:13 <dolio> Contexts on data declarations are stupid.
00:08:38 <Berengal> Oh, yes, like that
00:08:47 <Berengal> Indeed, data declarations have no need for contexts
00:12:52 * tibbe finds the default Haskell arrays complicated
00:13:26 <pumpkin> me too
00:13:29 <pumpkin> uvector ftw :P
00:15:52 <tibbe> unfortunately I need a mutable array
00:16:04 <tibbe> in fact I need a vector<T>
00:16:07 <pumpkin> MUArr
00:16:12 <pumpkin> hmm
00:16:17 <pumpkin> oh, not unboxed
00:16:21 <tibbe> i.e. dynamic resize
00:16:25 <pumpkin> oh
00:16:36 <tibbe> I need Int indexes and function values
00:16:40 <tibbe> (i.e. callbacks)
00:16:41 <pumpkin> build a simple wrapper around Array# ?
00:16:52 <tibbe> pumpkin: it's all but simple ;)
00:16:54 <tibbe> I tried though
00:17:01 <tibbe> around MutableArray#
00:17:02 <Berengal> Are there no arrayCopy functions anywhere?
00:17:08 <tibbe> couldn't find one
00:17:10 <pumpkin> Berengal: I was looking for one
00:17:11 <tibbe> I'm sure there are
00:17:18 <pumpkin> I typically just FFI to memcpy
00:17:23 <pumpkin> but that'll only work for unboxed stuff
00:17:26 <Berengal> If not, that's a pretty big hole in the array api...
00:17:51 <dolio> It should work for boxed arrays, too, I think.
00:18:05 <dolio> You're just memcpying pointers instead of unboxed values.
00:18:43 <pumpkin> ah
00:19:05 <dolio> At least, I assume it'd work. I don't know if anything special happens when you read/write MutableArray#s.
00:20:19 <tibbe> mm, thaw/freeze should copy so perhaps I can find a reference there
00:20:50 <tibbe> it kinda sucks to work with STRefs if multiple readSTRef to the same ref can't be optimized away
00:20:51 <Berengal> thaw/freeze copies, but it doesn't resize...
00:20:55 <tibbe> it really hurs composability
00:21:13 <tibbe> Berengal: I can allocate a new one if I can figure out how to copy the old one
00:22:09 <dolio> Well, worst case you can write your own copying loop. That's what I did in uvector-algorithms before I convinced dons to add some memcpy stuff to uvector.
00:22:56 <tibbe> I'm looking at http://www.haskell.org/ghc/docs/latest/html/libraries/array/src/Data-Array-Base.html#freeze and STUArray is memcpy but normal arrays are a naive loop
00:23:25 <dolio> Huh, maybe it's not safe to use memcpy on the pointer arrays, then.
00:23:27 <Berengal> Maybe something like 'mapM_ insert $ toList oldArray' will be fused, or something?
00:23:34 <Berengal> Wouldn't bet on it though...
00:24:00 <tibbe> me neither
00:24:08 <tibbe> I haven't seen any RULES for it
00:25:22 <dolio> Wait, freezeSTArray isn't in this module.
00:27:24 <dolio> freezeSTArray is still a loop, though.
00:27:47 <tibbe> http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-Arr.html#thawSTArray
00:27:51 <tibbe> that looks better
00:27:52 <dolio> Oh, I think I know why you can't memcpy the MutableArray#s.
00:28:04 <dolio> Whenever you write to them, you need to set the dirty bit.
00:28:11 <dolio> Which memcpy obviously wouldn't.
00:28:12 <tibbe> hmm
00:28:14 <tibbe> right
00:28:20 <tibbe> but does every write do that?
00:28:31 <dolio> I think so.
00:28:33 <tibbe> isn't that a bit inefficient if you want to copy in a loop?
00:28:47 <dolio> Yes.
00:29:05 <dolio> Well, setting the bit isn't inefficient, probably.
00:29:21 <dolio> Having the garbage collector scan all the pointers in the array is.
00:29:47 <dolio> For however many times the collector runs during your copying.
00:30:05 <mmorrow> tibbe: you can get I# with GHC.Exts
00:30:12 <tibbe> mmorrow: thanks ;)
00:30:13 <mmorrow> GHC.Exts(Int(I#))
00:30:22 <Berengal> Why would you need to set the dirty bit when copying?
00:30:31 <tibbe> looks like I have to go with MutableArray# instead of STArray to get at the goodies
00:30:31 <pumpkin> mmorrow: onoes, getAllocations never gives me anything :(
00:30:34 <Berengal> I'd think you'd only have to if the source was dirty...
00:30:55 <tibbe> time to go to work
00:30:57 <tibbe> ttyl
00:31:03 <mmorrow> pumpkin: oh noes
00:31:08 <mmorrow> pumpkin: what do you mean?
00:31:19 <pumpkin> well the difference of two calls is always 0 in my tests
00:31:26 <pumpkin> but I should see if the return value is 0 too
00:31:54 <pumpkin> yeah, it is
00:31:55 <pumpkin> hmm
00:32:02 <pumpkin> I wonder what's wrong
00:32:11 <mmorrow> err, i don't understand, so the retval of the C function is always 0?
00:32:14 <pumpkin> yup
00:33:05 <pumpkin> oh it isn't
00:33:13 <mmorrow> does peeking total_allocated give you nonzero?
00:33:15 <pumpkin> I just hadn't done anything when I first called it
00:33:20 <mmorrow> ah
00:33:21 <pumpkin> but the difference is still always 0
00:33:32 <pumpkin> I wonder whether gmp is really using our allocators :o
00:33:37 <pumpkin> I guess it has to
00:33:38 <mmorrow> i'm getting values by peeking total_allocated
00:33:40 <dolio> Berengal: I don't really grok the whole dirty bit for arrays thing, myself.
00:34:07 <mmorrow> pumpkin: ohh, did you pass the ghc alloc functions to gmp_set_alloc_functions (or whatever)?
00:34:28 <mmorrow> pumpkin: or maybe those functions allocate somewhere where total_allocated doesn't record
00:34:34 <pumpkin> this is still using 6.10.3
00:34:38 <pumpkin> with primops etc.
00:34:43 * mmorrow tries
00:35:16 <dolio> Berengal: Somehow GHC only has to crawl arrays of pointers to see what's live if you've modified the array. I guess it remembers from past crawls if you don't modify it.
00:36:23 <dolio> So if you're copying, it needs to crawl to establish what's live based on the new array, I guess.
00:36:33 <dolio> Although if you were smart, you could just copy that information from the old array.
00:36:44 <dolio> Assuming I'm correctly understanding how it all works.
00:37:24 * pumpkin is trying to come up with a really cool benchmarking suite
00:37:30 <pumpkin> for integers
00:38:25 <pumpkin> maybe I'm overengineering it, but it's fun
00:41:02 <mmorrow> pumpkin: it changes, but a lot of the time the diff'll be zero
00:41:14 <pumpkin> hmm, but I'm doing really big integer operations between the calls
00:41:37 * pumpkin tries even bigger ones
00:41:47 <mmorrow> pumpkin: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2614#a2614
00:42:05 <mmorrow> yeah, you have to build huger things than you first think too
00:42:09 <pumpkin> 401225798736931
00:42:09 <pumpkin> [(5.012781,0),(5.074234,0),(5.106006,0),(5.439548,0)]
00:42:17 <pumpkin> I'm raising that number to the power of 500000
00:42:32 <mmorrow> on mine it was only changing every 100 samples or so..
00:42:33 <pumpkin> the first is the number of seconds elapsed for each try
00:42:44 <pumpkin> the second is the difference in calls to getAllocations
00:42:56 <mmorrow> and each loop i was doing (100000^n), n `in` [100..4242]
00:43:22 <pumpkin> mine is a much bigger number, but I'm only doing it once
00:43:24 <pumpkin> hmm
00:43:29 <mmorrow> (i'm peeking total_allocated directly, but don't see why that would change anything)
00:43:42 <mmorrow> pumpkin: oh, you have to do it hundreds of times
00:44:20 <pumpkin> oh, maybe it only updates the allocations counter after a GC?
00:44:25 <pumpkin> that would be odd though
00:44:28 <mmorrow> all my diffs are roughly 65026 too ..
00:44:39 <mmorrow> so i guess that's the granularity of this counter
00:44:59 <mmorrow> , 2 ^ 16 - 1
00:45:01 <lunabot>  65535
00:45:24 <pumpkin> there is definitely allocation going on here
00:45:42 <pumpkin> I'm raising 631603098302601^5000000
00:45:46 <mmorrow> it looks like you need to allocate > 65535 bytes
00:45:50 <pumpkin> the program is using 165 megabytes
00:45:54 <pumpkin> from that computation alone
00:46:02 <pumpkin> let's see if it shows me any allocations now! :P
00:46:03 <mmorrow> maybe it only ticks it every 100 or so spins?
00:46:10 <pumpkin> maybe that's it
00:46:29 <mmorrow> (literally my test prog was only show a nonzero diff every 100 or so spins)
00:46:40 <pumpkin> how do I get it to spin idle?
00:46:41 <mmorrow> so once every 100 or so allocations
00:46:56 <mmorrow> you have to allocate each spin
00:47:04 <pumpkin> hm
00:47:09 <pumpkin> I guess I could allocate something tiny
00:47:14 <pumpkin> newByteArray# 1
00:47:19 <pumpkin> :P
00:47:23 <mmorrow> 42 `seq` ...
00:47:30 <pumpkin> that's enough?
00:47:39 <mmorrow> that'll allocate (i think)
00:47:49 <mmorrow> length [0..4095] `seq` ...
00:47:53 <mmorrow> will definitely allocate
00:48:11 <pumpkin> but I don't want to allocate more than I need to, or it'll add a big constant to my measurements
00:48:18 <pumpkin> I guess I can measure how much that adds and subtract it
00:48:26 <pumpkin> assuming it's constant
00:51:15 <pumpkin> dammit
00:54:06 <binarycodes> hey all
00:54:08 <mmorrow> pumpkin: hmm, it looks like tot_allocs doesn't get updated very sanely, i'd use the block/mblock counts
00:54:21 <mmorrow> MemStats {blocks = 131, mblocks = 1, totalloc = 0}
00:54:21 <mmorrow> MemStats {blocks = 16007, mblocks = 68, totalloc = 0}
00:54:29 <pumpkin> I wonder how ghci's works consistently
00:54:35 <pumpkin> or maybe it doesn't
00:54:39 <pumpkin> and everyone just ignores that number
00:54:50 <mmorrow> pumpkin: that's wired in to the interpreter or something like that i think
00:54:58 <mmorrow> i don't think it's from here
00:55:09 <pumpkin> it is, that's where I found the function
00:55:21 <mmorrow> hmm
00:55:29 <binarycodes> i have a function factor num = x: num `div` x , where num `mod` x == 0. now how do i specify that x is to be drawn from a list of primes, till the clause num `mod` x is true ?
00:55:38 <mmorrow> pumpkin: if you just use the block/megablock count you can sidestep this whole issue :)
00:55:55 <pumpkin> fair enough
00:56:06 <binarycodes> i have a function that generates the list of primes, just cant figure out how to make that factor function draw x from there
00:56:33 <pumpkin> mmorrow: so a megablock is the result of an OS malloc, and a block is some subunit of that?
00:57:53 <mmorrow> pumpkin: there're both used with haskell alloc
00:57:56 <mmorrow> *they're
00:58:10 <mmorrow> a megablock is 1MB and a block is 4K
00:58:21 <pumpkin> zomg, I'm still getting a difference of 0!!!!11
00:58:27 * pumpkin tries throwing more allocation in between
00:59:08 * pumpkin @#!$!#&$
00:59:38 <binarycodes> any help on the above, or atleast what i should be looking for?
01:00:04 <doserj> binarycodes: head . filter (\x -> n`mod`x==0)
01:00:43 <binarycodes> doserj, ah compose. right. thanks
01:00:53 <pumpkin> mmorrow: alright, no more cursing and swearing, time for bed instead... still haven't been able to get a meaningful difference between values
01:04:01 <mmorrow> pumpkin: oh, it does reset those counters on a gc, and it looks like it only updates them after a gc as well
01:04:26 * pumpkin sobs
01:05:32 <prince_arioch> haskell, a demon of great power from the lower levels of the demonic abyss
01:05:37 <prince_arioch> we must be cautious
01:05:42 <pumpkin> indeed!
01:05:52 <pumpkin> do not let the GC get in the way of your measurements
01:06:07 <mmorrow> pumpkin: check out the output of this one http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2614#a2615
01:06:21 <pumpkin> grr at the observer effect
01:07:04 <mmorrow> (the fact that we're making a ccall also might be having some effect of something or other too)
01:07:16 <pumpkin> bah :)
01:07:17 <mmorrow> err, well i'm just peeking, so i guess not
01:07:41 <pumpkin> maybe there's a special case in ghc saying "if he peeks at this address, fuck with him"
01:08:54 <pumpkin> anyway, tomorrow will bring new inspiration on how to do this right
01:09:05 <prince_arioch> hm
01:09:11 <prince_arioch> I love myself
01:09:26 <pumpkin> prince_arioch: glad to hear it
01:09:27 <mmorrow> that'd be sweet if there was a way to monitor mem access that was lighter weigth than a signal
01:09:43 <pumpkin> I wonder how that interactive profiler is doing it
01:09:48 <pumpkin> the one that person is working on
01:09:59 * pumpkin is so abstract
01:10:11 <prince_arioch> I have this task: there are 6000 movies on a unix box
01:10:35 <prince_arioch> each is /home/dir/movieX/wmv/movieID
01:10:49 <prince_arioch> and some movies has 2 or 3 mvoieID folders
01:11:02 <prince_arioch> my task is to delete all but the newest if there are multiple
01:11:08 <prince_arioch> how do in haskell?
01:11:27 <mmorrow> System.Directory and System.FilePath would be two you'd need
01:11:35 <mmorrow> @hoogle getModificationTime
01:11:36 <lambdabot> System.Directory getModificationTime :: FilePath -> IO ClockTime
01:12:05 <mmorrow> (you'll probably need to rename all the functions from System.Directory in your module to avoid going insane)
01:12:22 <prince_arioch> er
01:12:22 <prince_arioch> ?
01:12:22 <mmorrow> getTheContentsOfTheDirectoryPassedAndReturnThem
01:12:33 <mmorrow> (they're painfully long)
01:12:37 <prince_arioch> im already batty
01:12:41 <mmorrow> ls = getTheContentsOfTheDirectoryPassedAndReturnThem
01:12:44 <mmorrow> wee
01:13:02 <mmorrow> @hoogle getCurrentDirectory
01:13:03 <lambdabot> System.Directory getCurrentDirectory :: IO FilePath
01:13:03 <prince_arioch> I love girls who are curvey, and michael moorcock novels, and I like netbsd
01:13:06 <mmorrow> pwd = ..
01:13:26 <prince_arioch> so haskell is well able to do files and directoies
01:14:26 <pumpkin> it's a general-purpose language, I should hope it knows how to do files
01:14:27 <prince_arioch> Im just totally fascinated
01:14:37 <pumpkin> unless you have different notions of "do" ;)
01:14:40 <prince_arioch> even tho sysadmin I know scoff at me and say I should learn python
01:15:06 <pumpkin> prince_arioch: haskell is a fascinating language :) but if you stare too much you'll get drawn in and will never escape
01:15:08 <pumpkin> get away while you still can!
01:15:30 <prince_arioch> I feel lame because I tried learning common lisp 4 times
01:15:34 <prince_arioch> and got frustrated
01:15:48 <prince_arioch> I really only know a bit of tcl and bash
01:17:47 <dever> sysadmin scoff at everyone
01:18:03 <pumpkin> :)
01:18:10 <dever> sysadmin make the baby dever cry
01:18:29 <pumpkin> maybe I should make my benchmarking stuff available as a library when I'm done with it
01:18:54 <pumpkin> it's slightly different from other approaches I've seen
01:19:05 <pumpkin> closer to quickcheck
01:21:18 * dever must learn how to do *proper* testing in haskell
01:21:47 <hatds> "but if you stare too much you'll get drawn in and will never escape" god isn't that the truth
01:22:17 <pumpkin> it's a total timesink
01:22:31 <PeakerWork> hmm.. I need a binary-search over data that's in IO.  Is there any existing "monadic binary search"?
01:22:34 <pumpkin> I just can't stop reading about it, experimenting with it, learning more, and branching out into the kind of theory that other haskellers enjoy
01:22:51 <pumpkin> PeakerWork: how do you mean?
01:23:03 <hatds> like binary tree or like find?
01:23:22 <PeakerWork> (Ix a, Ord b) => b -> (a, a) -> (a -> IO b) -> a
01:23:36 <pumpkin> hmm
01:23:39 <PeakerWork> Something like this -- that binary searches using the given (a -> IO b), in the range (a, a)
01:23:50 <hatds> here, I just wrote such a thing I think
01:23:51 <pumpkin> ah I see
01:23:56 <PeakerWork> s/IO/Monad m => m
01:24:08 <PeakerWork> (Monad m, Ix a, Ord b) => b -> (a, a) -> (a -> m b) -> m a
01:24:10 <hatds> scanfind1 :: [a] -> (a -> IO Bool) -> IO (Maybe a)
01:24:12 <hatds> scanfind1 [] f = return Nothing
01:24:14 <hatds> scanfind1 (a:as) f = do
01:24:16 <hatds> 	boolean <- f a
01:24:17 <hatds> 	if (boolean == True)
01:24:19 <hatds> 	 then return $ Just a
01:24:21 <hatds> 	 else scanfind1 as f
01:24:30 <hatds> maybe should have hpasted that :)
01:25:03 <pumpkin> not quite binary :)
01:25:17 <hatds> oh didn't see that
01:25:43 <hatds> also I apparently wrote boolean == True (covers face)
01:25:57 <PeakerWork> hatds: I don't have a list, I have a range
01:26:12 <PeakerWork> I guess I'll just write that binary search
01:26:23 <hatds> there really should be a better way to get these functions
01:26:34 <hatds> but you can fake it with unsafePerformIO/interleaveIO
01:27:27 <PeakerWork> where is there binary search for pure stuff?
01:27:33 <PeakerWork> @hoogle bisect
01:27:33 <lambdabot> No results found
01:27:35 <PeakerWork> @hoogle binary
01:27:36 <lambdabot> package binary
01:27:36 <lambdabot> package binary-search
01:27:36 <lambdabot> package binary-strict
01:27:40 <PeakerWork> aha
01:27:50 <yitz> PeakerWork: a and b are also instances of some numeric class?
01:28:32 <hcube> hi! i've a problem. Id like to compose two functions(f1 and f2), but it dont know how to do it. f1 :: c -> d   f2 :: a -> b -> c    the required result: (f1 . f2) :: a-> b -> d
01:29:08 <PeakerWork> yitz: I have a set of files that can be viewed as one huge array of lines. a is an index into those lines (probably something that represents (Filename, LineNumber)
01:29:17 <PeakerWork> yitz: b is basically an integer, yeah
01:29:25 <yitz> @djinn (c->d)->(a->b->c)->a->b->d
01:29:25 <lambdabot> f a b c d = a (b c d)
01:29:36 <Botje> @pl f1 (f2 a b)
01:29:36 <lambdabot> f1 (f2 a b)
01:29:43 <Botje> @pl \a b -> f1 (f2 a b)
01:29:43 <lambdabot> (f1 .) . f2
01:29:51 <Botje> hcube: there's your answer
01:30:00 <hcube> thank you :)
01:30:09 <doserj> @type (.).(.)
01:30:11 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
01:30:21 <cadZzz> waaat the fuk
01:30:37 <cadZzz> what's (f1 .) even mean/
01:30:46 <hatds> left section of (.)
01:30:48 <hatds> :)
01:30:50 <opqdonut> it's a section with the . operator
01:30:51 <doserj> but i usually define f .: g = (f .) . g
01:31:10 <pumpkin> is .. a valid operator? probably not, eh
01:31:43 <hatds> I just go with pointed syntax when it comes to this
01:31:45 <opqdonut> > (+1) Prelude.. (*2) $ 3
01:31:46 <lambdabot>   7
01:31:51 <opqdonut> pumpkin: ^
01:32:01 <opqdonut> > let (..) = (+) in 1 .. 2
01:32:02 <lambdabot>   <no location info>: parse error on input `..'
01:32:04 <pumpkin> that's different :)
01:32:13 <opqdonut> yeah it isn't a valid operator
01:32:16 <yitz> @type (..)
01:32:17 <lambdabot> parse error on input `..'
01:32:18 <pumpkin> > let (...) = (+) in 1 ... 3
01:32:20 <lambdabot>   4
01:32:29 <yitz> pumpkin: it's a reserved op
01:32:35 <pumpkin> for the list thing, I guess
01:32:40 <yitz> yeah
01:32:41 <Alpounet> yeah
01:33:51 <cadZzz> @type (f .)
01:33:53 <lambdabot> forall b c a. (Show b, SimpleReflect.FromExpr c) => (a -> b) -> a -> c
01:34:01 <yitz> PeakerWork: and the a's are monotonic under the test function, I suppose
01:34:41 <pumpkin> > let (...) f g = (f .) . (. g) in (("moo" ++) ... (++ "baa")) (++ "oi") "hohoho"
01:34:43 <lambdabot>   "moohohohobaaoi"
01:34:51 <pumpkin> :P
01:35:32 <cadZzz> that is not entirely wholesome.
01:36:10 <pumpkin> wHOlesome?
01:36:43 <yakov> hello
01:37:08 <PeakerWork> yitz: what does monotonic mean?
01:37:08 <yitz> PeakerWork: Ix is a pain in the neck. Maybe just use some numeric type there also?
01:37:25 <hatds> I always use Ints instead of Ix
01:37:26 <yitz> PeakerWork: increasing or decreasing
01:38:10 <PeakerWork> yitz: yeah, I'm looking at the binary-search package, their type is nicer
01:38:23 <PeakerWork> yitz: Just use (Integral a) and (a->Bool) rather than an Ord b
01:38:29 <cadZzz> *either non-decreasing or non-increasing
01:38:46 <yitz> cadZzz: right, that's better
01:38:56 <PeakerWork> (Monad m, Integral a) => (a, a) -> (a -> m Bool) -> m a
01:39:14 <cadZzz> hehe I should be sleep
01:39:22 <cadZzz> night all
01:39:28 <yitz> PeakerWork: are you sure you don't want a -> m Ordering?
01:39:41 <yakov> i've converted socket to fd in order to set O_NONBLOCK to do non-blocking accept and accept refused to work on such a socket after (can't perform accept on socket in status ConvertedToHandle) do we have ability to set O_NONBLOCK for sockets?
01:40:28 <PeakerWork> yitz: For binary search, you don't really need Ordering, you can have a "least one satisfying a condition"
01:40:35 <PeakerWork> yitz: which is simpler and just as powerful, I think
01:41:41 <yitz> PeakerWork: ah, ok
01:42:10 <MyCatVerbs> yakov: use forkIO, accept in a seperate thread to the rest of the program.
01:42:32 <PeakerWork> yitz: Making an Integral instance for (FileName, LineNumber) might be a little bit of a pain, though
01:43:09 <PeakerWork> All-encompassing classes like Num are a pain to instantiate, even if nice to use.
01:43:28 <MyCatVerbs> yakov: (Other than that, I'm not sure, the RTS deals with blocking-ness of IO inside itself. Best not to mess with it. But using forkIO to have (accept) run in a seperate Haskell thread works Just Fine, No Worries. ^_^)
01:43:54 <yitz> PeakerWork: well you could define just the ops you need for binary search
01:44:02 <yakov> MyCatVerbs, well, it's dirty workaround for api flow as for me (i know about the trick).. I need to poll for connections and in case there's no connections to something
01:44:22 <PeakerWork> yitz: type-unsafe, though
01:44:24 <Lemmih> ?ask dons Didn't you once have some benchmarking tools for Haskell implementations?
01:44:24 <lambdabot> Consider it noted.
01:44:41 <yakov> MyCatVerbs, the only question with this approach is how to kill thread gracefuly when it's blocked on foreign accept?!
01:45:01 <yakov> seems like no sane way!
01:45:15 <yakov> because of missing non-blocking call.. :-(
01:45:15 <yitz> PeakerWork: if you need it to be general, roll your own type class. Or an ADT that wraps up the functions you need.
01:46:09 <yitz> yakov: what's wrong with just killing it?
01:46:13 <MyCatVerbs> yakov: do { mv <- newEmptyMVar; forkIO (forever $ do { (h,_,_) <- accept sock; putMVar mv h; }; {- rest of program goes here. -} )
01:46:24 <PeakerWork> yitz: I'm basically copying the binary-search code, and replacing it with monadic binary search
01:46:32 <MyCatVerbs> yakov: and then you can poll the MVar mv.
01:46:57 <yakov> yitz, killing is NOT portable and wrong by design
01:46:59 <yitz> PeakerWork: bin search itself is pretty trivial, that
01:47:03 <yitz> 's not your issue
01:47:21 <yitz> yakov: not portable?
01:47:35 <MyCatVerbs> yakov: Control.Concurrent.killThread works just fine, whether the thread being blown to smithereens is blocking in accept or not.
01:47:44 <yakov> MyCatVerbs, yeah, but in case if there is NO connection accept will block for a long time and there's no way to know about it AFAIU
01:48:14 <yakov> MyCatVerbs, really? i though that throwTo works only when I get out of foreign call after all
01:48:15 <PeakerWork> yitz: http://hackage.haskell.org/packages/archive/binary-search/0.0/doc/html/src/Numeric-Search-Bounded.html
01:48:25 <PeakerWork> yitz: simple, not trivial
01:48:33 <MyCatVerbs> yakov: No. Sure, there's no way to time out on accept *in that thread*. But you can have more than one thread running!
01:48:35 <PeakerWork> yitz: easy to make "off-by-one" bugs
01:48:55 <yitz> PeakerWork: eh, after you've written them a few times you get used to it.
01:49:31 <PeakerWork> yitz: I've written it a few times, but I'd still rather slightly adapt an existing one :-)
01:49:53 <yitz> PeakerWork: most of the one-off issues actually are legitimate alternatives - you have to decide what you want your search to do when it gets close
01:50:28 <MyCatVerbs> yakov: Network.accept is not implemented by just a bare call to C's accept(2). Internally it has to be implemented in a non-blocking manner, because otherwise it would block the rest of the RTS (when you're not using the threaded RTS, anyway).
01:51:16 <yakov> well, yeah, i've checked it implementation but did not payed enough attention to investigate it's non-blockines.. thx for tip!
01:51:24 <yakov> i need to dig this deeper
01:55:35 <cjs> > let expr = return () :: IO () in expr `Control.Exception.Base.catch` const (return ())
01:55:36 <lambdabot>   Not in scope: `Control.Exception.Base.catch'
01:55:58 <cjs> > let expr = return () :: IO () in expr `Control.Exception.catch` const (return ())
01:55:59 <lambdabot>   Not in scope: `Control.Exception.catch'
01:56:15 <cizra> @src last
01:56:15 <lambdabot> last [x]    = x
01:56:16 <lambdabot> last (_:xs) = last xs
01:56:16 <lambdabot> last []     = undefined
01:56:37 * cizra pats lambdabot 
01:57:02 <cjs> Bah. But anyway, I get "Ambiguous type variable `e' in the constraint: Exception e..." Any nice way of getting around that in the above code, except by extrating the 'return ()' to a separate function and adding a type signature to it?
01:58:35 <sjanssen_> cjs: I think the point of catch's new type is that it isn't typically valid to ignore all exceptions
01:59:30 <PeakerWork> pretty ugly that fail takes a string..
01:59:36 <PeakerWork> @src MaybeT fail
01:59:36 <lambdabot> Source not found. Just what do you think you're doing Dave?
01:59:57 <PeakerWork> @src MonadError
01:59:57 <lambdabot> class (Monad m) => MonadError e m | m -> e where
01:59:58 <lambdabot>     throwError :: e -> m a
01:59:58 <lambdabot>     catchError :: m a -> (e -> m a) -> m a
02:00:36 <PeakerWork> I wonder if it makes sense to have a  Monad m => MonadError () (MaybeT m) instance
02:01:05 <PeakerWork> because such an instance does not seem to exist, and could work
02:01:57 <deeflex> hey I get a stack overflow with my newbie code. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5671#a5677 . Can someone please help out?
02:02:13 * sjanssen searches for foldl
02:03:01 <BONUS> PeakerWork: pretty cool idea
02:03:38 <Botje> deeflex: add a ! to every parameter of the loop definition
02:03:47 <Botje> loop !fi !di !vi !ei !i | ....
02:05:05 <prince_arioch> good night nobel haskellers
02:06:11 <PeakerWork> BONUS: then I wouldn't have to use   fail ""
02:06:19 <PeakerWork> throwError () is nicer :-)
02:06:53 <deeflex> Botje, ok let me try.
02:08:46 <quicksilver> PeakerWork: well it overlaps.
02:08:55 <quicksilver> PeakerWork: that's the general problem with instance schemes like that.
02:08:57 <PeakerWork> quicksilver: with what?
02:09:08 <quicksilver> PeakerWork: with a (possible) lifted MonadError instance
02:09:11 <quicksilver> if "m" already had one.
02:09:41 <PeakerWork> quicksilver: that's true of any instance of MonadError on a transformer, perhaps even of any type-class on a transformer?
02:10:09 <deeflex> Botje, That didn't work. Syntax error in declaration (unexpected `!') . Do I need to import something?
02:11:09 <mux> deeflex: add {-# LANGUAGE BangPatterbs #-} at the first line
02:11:16 <mux> woops, make that BangPatterns :-)
02:11:57 <deeflex> mux, heh ok...hold on
02:11:58 <quicksilver> PeakerWork: yes, it is.
02:12:07 <quicksilver> PeakerWork: it's the problem of instance schemes on transformers.
02:12:34 <quicksilver> PeakerWork: the "suggested" fix is to newtype your *actual* stack, and then write the instance on that.
02:12:34 <mux> deeflex: alternatively, you could have compiled with -XBangPatterns
02:12:50 <quicksilver> ...would be nice if there was a way to reduce the boilerplate on that.
02:13:55 <deeflex> mux, that line..is that GHC specific? Im running hugs and that's not working.
02:14:21 <psygnisfive> deeflex: you need to running kisses along side to make it work properly
02:14:23 <sjanssen> deeflex: Hugs doesn't support bang patterns
02:14:37 <deeflex> OK
02:14:55 <sjanssen> deeflex: by the way, I don't think anybody seriously uses Hugs any more
02:17:05 <deeflex> sjanssen, well ...there must be a solution to my problem, not involving switching to ghc. =)
02:17:40 <quicksilver> deeflex: bangpatterns are just syntactic sugar
02:17:43 <quicksilver> you can use seq instead
02:18:01 <quicksilver> loop !a !b !c = (....) is rewritten as
02:18:11 <quicksilver> loop a b c = a `seq` b `seq` c `seq` (....)
02:18:58 <sjanssen> deeflex: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5671#a5678
02:19:07 <sjanssen> ie. do as quicksilver says :)
02:19:18 <quicksilver> good advice.
02:19:36 <sjanssen> deeflex: if this doesn't fix the issue, you probably have an infinite loop somewhere
02:20:18 <deeflex> sjanssen, ok...let me try your (and quicksilver's ) solution
02:21:22 <PeakerWork> quicksilver: hmm. What about not having lifted instances?
02:21:26 <PeakerWork> quicksilver: (Except explicit ones)
02:22:59 <quicksilver> PeakerWork: well, then you'd miss out on the MonadState instance of MaybeT (StateT (...))
02:23:02 * quicksilver shrugs
02:23:05 <deeflex> sjanssen, nope didn't work :)
02:23:14 <quicksilver> obviously you could take a decision to only have instances for the top-level constructor.
02:24:49 <PeakerWork> quicksilver: I don't want that instance
02:25:12 <PeakerWork> quicksilver: I want explicit lifting for the state, because otherwise it has no name. I like giving my state a name
02:25:31 <quicksilver> fair enough.
02:25:41 <quicksilver> I also haev misgivings about MonadState
02:25:51 <quicksilver> but it would be nicer if there was easier ways to *write* the instances.
02:26:14 <quicksilver> you're obviously going to want, in some way, a special version of get/put/modify for your custom newtype.
02:26:20 <quicksilver> it would be nice if it was simple to write those.
02:26:59 <PeakerWork> quicksilver: I'd be ok with get/put/modify hard-coded for StateT, and just have liftMyStatename $ get ..
02:27:32 <sjanssen> deeflex: I see you're using minimumBy, that has a space leak with long lists
02:29:27 <dhun> lambda.org is gay website, don't want to hurt anybodies feelings, neither gay ones nor functional programmers, but still I smile about it, "a programmer could not but be gay such a functional company ", freely adapted from Daffodils by William Wordsworth
02:31:44 <deeflex> sjanssen, oh ok. Anyway I don't quite understand, even if I for example call neighbor with an empty list, I get a stack overflow.
02:32:05 <ski> (PeakerWork : .. i'd like something like that, as well)
02:33:19 <ski> (i.e. being able to associate names with the layers of a monad transformer stack, and then use the names to refer to which layer an operation should be run in)
02:33:42 <PeakerWork> ski: I do it manually by newtype'ing a stack and writing boiler-plate lifters
02:33:51 <PeakerWork> liftBlah = lift . lift ; liftBleh = lift . lift . lift
02:34:45 <ski> PeakerWork : yes, except some of the operations aren't as simple to lift as just a few `lift' calls chained
02:35:45 <ski> e.g.
02:35:46 <ski> @type catchError
02:35:47 <lambdabot> forall (m :: * -> *) a e. (MonadError e m) => m a -> (e -> m a) -> m a
02:38:33 <quicksilver> antyhing with a callback.
02:40:19 <ski> *nod*
02:42:46 <ski> ideally we'd like a solution that allows to write down once how to lift `MonadFoo'-operations over each `BarT' monad transformer, like currently with the instances, but which also allows one to pick and choose which layer one wants certain operations to execute in (e.g. if one has several `StateT' layers)
02:43:47 <quicksilver> ski: yes. I want a "instance recipe"
02:43:52 <quicksilver> ski: that I can apply
02:43:57 <quicksilver> ski: a little bit like an ML functor
02:44:05 <quicksilver> in the sense that I give it parameters and it generates code.
02:44:41 <ski> hm .. maybe it's similar to ML functors in some way i don't see clearly
02:45:16 * ski was before thinking of some kind of type system extension which lets you label the layers in the type, and use those labels in operations to specify which layer is wanted
03:03:18 <PeakerWork> ski: You can use (lift . lift $ catchError ..) if you're only using monadic operations of the inner monads, right?
03:03:53 <PeakerWork> ski: is it possible for catchError buried deep inside to be used to perform exception handling with actions of outer monads?
03:05:34 <ski> PeakerWork : how do you mean ?
03:09:34 <PeakerWork> ski: what's the problem with a lifted catchError?  That the "m a" in your catch handler is limited to the inner monads, right?
03:11:21 <quicksilver> inner or outer depending which way out your mental model is
03:11:23 <quicksilver> but, yes.
03:11:53 <PeakerWork> heh
03:12:55 <ski> PeakerWork : look e.g. at the `MonadError' instance at <http://haskell.org/ghc/docs/latest/html/libraries/mtl/src/Control-Monad-State-Lazy.html#(line208)>
03:12:57 <PeakerWork> So if I have (StateT s (MaybeT m)) -- is it equivalent to   MaybeT (StateT s m)   in terms of failure handling?
03:13:19 <ski> `throwError' there is defined by using `lift', like you suggested
03:13:33 <ski> but `catchError' there can't be implemented that way
03:13:53 <ski> you need to know implementation details about `StateT' to define it
03:14:05 <ski> that's not something which you want to do in your own code
03:14:06 <PeakerWork> ah, so each monad has to be specifically aware of catchError to implement it, it cannot be implemented in the general case?
03:14:32 <PeakerWork> maybe StateT could implement some more generic operation?  Perhaps that alternate monad transformer implementation that avoids the O(N*N) instance problem?
03:15:19 <ski> at least in the way the monad classes are implemented right now, you need (at most) one instance for each combination of a monad transformer and a monad class providing certain operations
03:15:33 <ski> (and i'm not sure how one could avoid this)
03:15:41 <PeakerWork> ski: does the catchError implementation of StateT   make the ordering of StateT and the error monad not meaningful?  e.g: Making the   (StateT s (ErrorT e m))  and  ErrorT e (StateT s m)    equivalent?
03:16:14 <PeakerWork> ski: Someone told me a little while ago that there's an implementation of monad transformers that avoids the N^2 instance problem by defining a method more general or more powerful than "lift"
03:16:22 <ski> there might be some more general operation .. like `lift', but also allowing handling callbacks in some way, that could be used, yes
03:16:33 <ski> but i don't know which operation that would be
03:17:41 <ski> no, that `instance MonadError e m => MonadError e (StateT s m)' doesn't by itself make `StateT s (ErrorT e m)' and `ErrorT e (StateT s m' equivalent
03:18:26 <ski> all it does is allow you to use the `MonadError' operations (`throwError',`catchError') on `StateT s m', assuming you can already use them on `m'
03:19:13 <ski> you could already do the same as `throwError' on `StateT s m' before by doing `lift . throwError', which is not very hard/problematic
03:19:13 <Cale> PeakerWork: istr it was a package on hackage
03:19:14 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
03:19:21 <PeakerWork> Cale: yeah
03:19:41 <ski> what is problematic is having to know about internal implementation details to "lift" `catchError' in a similar way
03:19:50 <Cale> http://hackage.haskell.org/packages/archive/mmtl/0.1/doc/html/Control-Monad-Trans.html
03:19:53 <Cale> tmap :: (Monad m, Monad n) => (forall a. m a -> n a) -> (forall b. n b -> m b) -> t m c -> t n c
03:20:39 <ski> that instance therefore allows one to use `catchError' directly on `StateT s m' monads .. but you can't select which layer of the transformer stack you want the `MonadError' operations to apply to
03:21:26 * ski wouldn't have `(forall b. n b -> m b)' there in the type of `tmap'
03:21:44 <ski> (yes, i know it's probably required for some instance .. but it's more restrictive)
03:21:48 <Cale> ski: It appears needed for Cont
03:22:11 <Cale> Many other instances seem to ignore it...
03:22:16 <ski> so `Cont' should use an `tExpMap' (or whatever it is to be called)
03:22:44 <ski> often it is not possible to do both a `forall a. m a -> n a' and a `forall b. n b -> m b' for certain `m',`n'
03:22:59 <ski> it should not be required, unless it is needed
03:24:57 <ski> (an endo-functor over the category of haskell-monads should just have the `forall a. m a -> n a' direction, as argument)
03:25:01 <PeakerWork> why does tmap need a two-way conversion, and not just one-way to convert the transformed monad?
03:25:11 <Cale> PeakerWork: for Cont
03:25:16 <PeakerWork> ah
03:25:33 <Cale> (and monads of that sort, I suppose)
03:25:33 <PeakerWork> I thought ski asked about the forall there
03:26:05 <ski> nono .. i commented about both having `m -> n' and `n -> m' natural transformations
03:26:21 <ski> (should maybe actually be monad morphisms ..)
03:58:23 <mamalujo> hi! So, Id like to try haskell platform tar on my deban. I presume I should remove debian packages of libs and tools included in the platform first?
04:01:50 <dever> quit
04:05:33 <Tarrant> So I'm playing with some basic IO stuff. I have a function along the lines of 'contents <- getContents; hPutStr handle contents' I call said function in GHCi and ^D doesn't work to send the eof. Does eof just not work in ghci or am I doing something wrong?
04:05:58 <cizra> Perhaps you're on Windwoes?
04:06:17 <Tarrant> cizra: Nope definitely a Unix (FreeBSD) box.
04:06:34 <Tarrant> I should also mention said code works great when run using 'runhaskell'
04:06:40 <cizra> Tarrant: Are you really sure? Perhaps it's just a cleverly disguised wolf in a lamb skin...
04:06:50 <cizra> Tarrant: Oh, please don't listen to me
04:08:59 <quicksilver> Tarrant: in ghci, stdin of your process is just stdin of ghci
04:09:14 <quicksilver> Tarrant: if you managed to send EOF it would be EOF for ghci, not EOF for your program
04:09:20 <quicksilver> that wouldn't be good, so it's blocked.
04:11:10 <Tarrant> Makes sense.
04:13:45 <quicksilver> of course, it would be nice if there was a clever way to make it work.
04:14:14 <Tarrant> quicksilver: Wouldn't life just be great :)
04:23:31 <lilac> quicksilver: there is a clever way to make it work, but it'd require ghci to do smarter terminal handling stuff
04:24:24 <quicksilver> lilac: does ghci do its own terminal handling? or delegate it to the readline flavour in use?
04:24:31 <quicksilver> lilac: presumably the key is to allocate a fresh pty?
04:25:05 <lilac> i don't know what ghci does if it's using readline; my ghci is more broken than that :)
04:25:14 * lilac has no line editing at all
04:25:58 <lilac> but readline should restore the terminal to a sensible state while a command is running, so i think that's a red herring
04:27:02 <lilac> in any case, i was thinking that if ghci insists on switching the terminal into raw mode, it should simulate cooked mode for things run within it
04:27:36 <lilac> (that is, translate the EOF key into an actual EOF when running code)
04:27:52 <lilac> allocating a new pty sounds good too; either way I guess it means hacking the IO implementation a bit
04:35:14 <PeakerWork> @src filterM
04:35:14 <lambdabot> Source not found. Maybe you made a typo?
04:36:45 <PeakerWork> how do I find out what modules are exposed by an installed package?
04:40:57 <PeakerWork> tar tvzf ~/.cabal/packages/*/<package-name>/<version>/*  I guess
04:41:21 <dcoutts> PeakerWork: cabal info thepkgname
04:41:46 <PeakerWork> ah, thanks
04:41:47 <dcoutts> lists the modules and more useful info
04:42:47 <PeakerWork> if cabal-install re-exposed some ghc-pkg stuff (unregister, find-module, list) it could allow users to know just a single interface, no?
04:57:07 --- mode: ChanServ set +o Lemmih
04:57:17 --- mode: Lemmih set -o Lemmih
05:10:18 <hatds> what's the idiomatic way of writing a list to a file so that it is easy to append values to the list later?
05:13:22 <hatds> is there a middle ground between writing each element of the list to a line (makes reading less nice) and just 'show'ing the list (makes appending less nice)?
05:13:50 <FliPPeh> Man, the tutorials did not lie
05:14:10 <FliPPeh> Once you manage to surpress type errors, you'll be surprised too see how often a code works on the first try
05:14:34 <cizra> FliPPeh: amen, brohter
05:14:40 <mmorrow> hatds: write a `show'ed list to each line
05:14:50 <kig> and still does the wrong thing when unit-tested ;D
05:14:51 <hatds> then concat?
05:14:53 <hatds> I see
05:14:54 <mmorrow> they don't even need to be the same size
05:14:57 <mmorrow> yeah
05:15:01 <FliPPeh> I mean
05:15:06 <mmorrow> concatMap read . lines
05:15:09 <FliPPeh> I just learned catching exceptions
05:15:19 <FliPPeh> And it runs flawlessy here
05:18:42 <FliPPeh> Anyone would like to look at my short code and tell me, if that's good coding style, and if I'm thinking Haskell correctly?
05:19:07 <EvilTerran> hatds, using, say, "mapM_ (hPrint fh)" to write them out one line at a time could be inverted with something fairly simple like  "mapM readIO . lines =<< hGetContents fh"
05:19:34 <FliPPeh> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2620#a2620
05:19:37 <FliPPeh> Good so far?
05:20:46 <EvilTerran> FliPPeh, if you line up the first character of "case" with the first character of "handle <-", you won't need that semicolon
05:21:13 <EvilTerran> similarly for the bit with isAvailable further down
05:21:20 <FliPPeh> Okay, thanks :)
05:21:24 <FliPPeh> I wondered why I had to put that
05:22:00 <EvilTerran> FliPPeh, if you indent a line more than the first line in a do block, it's considered to be a continuation of the previous line
05:22:10 <EvilTerran> iirc
05:22:38 <EvilTerran> FliPPeh, also, you could probably write handleInput neater with guards
05:22:39 <ski> FliPPeh : in `handleInput', use pattern-matching instead of  if head s == ':'
05:22:54 <EvilTerran> and that
05:22:59 <FliPPeh> Thanks, didn't think about that!
05:23:08 <ski> and use a `case' instead of  if head (words s) == "PING"  and  if length (words s) > 1
05:23:45 <ski> (well, a guard might work instead)
05:24:40 <gwern> huh. I just realized that my conviction that GNU Hurd development was being pushed forwards by a bunch of Turkish hackers, actually comes from a dream the other day
05:24:41 <lambdabot> gwern: You have 2 new messages. '/msg lambdabot @messages' to read them.
05:24:44 <gwern> I hate when that happens
05:25:30 <ski> (.. happened often ?)
05:25:39 <gwern> ski: distressingly so
05:25:41 <EvilTerran> FliPPeh, actually (considering ski's comment), i'd write something like: case words s of ... "PING":ws -> ...; _ -> return ()
05:25:57 <FliPPeh> I just used guars
05:25:59 <FliPPeh> guards
05:26:01 <FliPPeh> Erm
05:26:03 <FliPPeh> Pattern Matching
05:26:12 <gwern> it's something of a problem; I'll dream I did something, or I'll learn something in a dream, and then I won't forget it in real life
05:26:13 <FliPPeh> handleInput h (':':rest) = return ()
05:26:13 <FliPPeh> handleInput h s          = if head (words s) == "PING"
05:26:15 <FliPPeh> :)
05:26:21 <gwern> @messages
05:26:22 <lambdabot> kowey said 4h 2m 34s ago: gitit: Server error: UnknownError: mergeContents requires 'git' or 'merge', and neither was found in the path -- happens if I'm editing something, and somebody updates the
05:26:22 <lambdabot> page before I hit save
05:26:22 <lambdabot> kowey said 4h 2m 12s ago: I've also uploaded gitit-with-help which I believe has John's RST-help stuff
05:26:23 <marco_g> gwern: Many Hurd hackers live in Germany, the USA and France in reality :-)
05:26:30 <EvilTerran> actually, "PING":pinger:_ -> ...
05:26:38 * marco_g wonders why gwern dreams about Hurd developers...
05:26:41 <EvilTerran> would work nicely
05:26:44 <ski> FliPPeh : that's not a guard ..
05:26:48 <FliPPeh> As I said
05:26:51 <FliPPeh> [14:25:21] <FliPPeh> Erm
05:26:51 <FliPPeh> [14:25:24] <FliPPeh> Pattern Matching
05:27:08 <gwern> marco_g: dunno either. it just was in my dream! dreams aren't known for making sense
05:27:08 <ski> it's using `if'-`then'-`else'
05:27:25 <ski> using guards would be like
05:27:30 <FliPPeh> EvilTerran, I'm getting the input as a single string, so it won't come as ["PING" ":894372894"] but as "PING :89456465"
05:27:30 <ski>   handleInput h (':':rest) = return ()
05:27:34 <ski>   handleInput h s
05:27:40 <ski>     | head (words s) == "PING" = ...
05:27:47 <ski>     | ...
05:27:52 <marco_g> gwern: Were they singing the free software song?
05:27:54 <EvilTerran> FliPPeh, say: case words s of ... "PING":pinger:_ -> sendLine h $ "PONG " ++ pinger; _ -> return ()
05:27:55 <gwern> @tell kowey yeah, that's what happens with edit conflicts. gitit first trys to use git's merge functionality, then falls back to generic unix util merge. guess neither was in wiki.darcs.net's $PATH...
05:27:55 <lambdabot> Consider it noted.
05:28:06 <FliPPeh> Oh, didn't think about PM in case expressions
05:28:09 <EvilTerran> FliPPeh, that's why it's "case words s of", not just "case s of" :)
05:28:15 <gwern> marco_g: no, I have the vague impression that I was reading about the turks in some mailin list
05:29:28 <FliPPeh> Man
05:29:31 <FliPPeh> I love pattern matching
05:29:32 <FliPPeh> case words s of
05:29:32 <FliPPeh>    "PING":pingString:_ -> sendLine h $ "PONG " ++ pingString
05:29:37 <FliPPeh> :)
05:29:41 <FliPPeh> Thanks EvilTerran
05:29:52 <EvilTerran> pattern matching is _awesome_. every language should have it. :)
05:29:58 <FliPPeh> Again killed off 4 lines of unneccessary error checking
05:30:48 <EvilTerran> so, what do you have now?
05:31:21 <FliPPeh> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2621#a2621
05:31:22 <FliPPeh> This
05:31:53 <FliPPeh> I now don't even have to check if the input is long enough to actually do head (tail s) and not worry about exceptioning
05:32:10 <ski> (FliPPeh : maybe next time annotate the existing paste ?)
05:32:21 <FliPPeh> okay
05:33:52 <FliPPeh> handleInput h (':':rest) = case words rest of
05:33:52 <FliPPeh>                               (nick:'!':user:'@':host):command:params -> return ()
05:33:57 <FliPPeh> That did ACTUALLY COMPILE?
05:34:18 <FliPPeh> Just a fun thing I wanted to try out
05:34:18 <EvilTerran> i doubt it meant what you wanted, though
05:34:27 <FliPPeh> I'll test that
05:34:32 <PeakerWork> to break out of a forM_, is it customary to callCC?
05:34:32 <EvilTerran> nick, user :: Char; host :: String
05:35:04 <FliPPeh> Yep
05:35:06 <FliPPeh> It made it a char
05:35:10 <FliPPeh> Too bad :)
05:35:15 <EvilTerran> PeakerWork, i've used EitherT for that
05:35:23 <EvilTerran> (not mtl's broken ErrorT, mind)
05:35:32 <PeakerWork> EvilTerran: how si mtl's ErrorT broken, which one isn't?
05:35:51 <PeakerWork> EvilTerran: and how do you "catch" the error, or do you just runErrorT and ignore it?
05:35:54 <EvilTerran> the Error class constraint is trouble
05:35:56 <dhun> how can I say that a type should be bound to two classes like :: Show a,Eq a =>  ?
05:36:13 <PeakerWork> dhun: () around the constraints
05:36:22 <PeakerWork> dhun: (Show a, Eq a) => a -> Bool
05:36:27 <dhun> ok
05:36:44 <ski> @src Error
05:36:45 <lambdabot> class Error a where
05:36:45 <lambdabot>     noMsg  :: a
05:36:45 <lambdabot>     strMsg :: String -> a
05:36:57 <EvilTerran> PeakerWork, i'd <- runEitherT and then pattern-match the result
05:36:59 <ski> PeakerWork : presumably that it insists on having those two methods implemented for any exception type ?
05:37:09 <EvilTerran> ski, exactly
05:37:23 * ski has been irked by that several times
05:37:32 <EvilTerran> PeakerWork, if you're breaking out because you've got an error, ErrorT would be fine. i was thinking for the more general use of short-circuiting out when it's not actually an error
05:39:26 <ski> (also the fact that the `Monad (Either e)' instance is destroyed by adding a `Error e' constraint ..)
05:39:37 <PeakerWork> EvilTerran: I guess ErrorT is more specifically suited to "breaking" loops than ContT which can do anything at all
05:39:46 <PeakerWork> EvilTerran: hey, even MaybeT
05:40:08 <dhun> so I got my first polymorphic type, the funny thing about Haskell is that I can generalize things, of which I believed that even special cases were to hard to implement
05:40:08 <EvilTerran> FliPPeh, for the purposes of splitting up a nick!user@host, i'd suggest using 'break'
05:40:18 <FliPPeh> okay
05:40:22 <EvilTerran> PeakerWork, sure, MaybeT works if you don't want to pass a value out when you're done
05:40:32 <EvilTerran> > break (=='!') "nick!user@host"
05:40:33 <lambdabot>   ("nick","!user@host")
05:40:40 <PeakerWork> EvilTerran: ErrorT is a bad name, should have been EitherT
05:40:43 <EvilTerran> > break (=='!') "no excalamation marks"
05:40:44 <lambdabot>   ("no excalamation marks","")
05:40:49 * ski hasn't really an idea for when `ErrorT' would be appropriate .. maybe in some open-ended exception-type situation
05:41:16 <EvilTerran> PeakerWork, well, it's the right name for the instance, considering the Error e => constraint
05:41:33 <fasta> EvilTerran: what's wrong with ErrorT?
05:41:36 <EvilTerran> PeakerWork, but i'd rather have an instance without the constraint, and call it EitherT.
05:41:37 <PeakerWork> ski: consider having no IO exceptions at all, but instead having the type of stuff that can break be ErrorT IOError IO a ?
05:41:46 <EvilTerran> fasta, ski has explained above
05:42:06 <PeakerWork> EvilTerran: yeah, what does the constraint help with?
05:42:20 <EvilTerran> PeakerWork, "fail" :/
05:42:21 <PeakerWork> EvilTerran: can have more functions with more restrictions, if one wants
05:42:38 <PeakerWork> EvilTerran: the incorrectness of the monad class design manifests itself everywhere, eh?
05:42:42 <EvilTerran> ?src Either fail
05:42:42 <lambdabot> fail msg      = Left (strMsg msg)
05:42:55 <EvilTerran> >:[
05:43:25 <ski> @src Either mzero
05:43:25 <lambdabot> mzero            = Left noMsg
05:43:59 <EvilTerran> ^ the problem is the Error constraint in the Either instance, really; i can always define my own newtype EitherT, but it'd be extra clunky to have my own type isomorphic to just Either
05:44:49 * ski defined `Exn' and `ExnT' just to get around this
05:54:41 <akamaus> can someone help with building curl binding on windows? Cabal says it couldn't find curl library but I have dev version of curl installed in cygwin
05:55:26 <FliPPeh> > join ["a", "b"] ','
05:55:27 <lambdabot>   Couldn't match expected type `GHC.Types.Char -> t'
05:55:29 <FliPPeh> Mhh
05:55:38 <FliPPeh> > interpserse ["a", "b"] ','
05:55:39 <lambdabot>   Not in scope: `interpserse'
05:55:43 <FliPPeh> > intersperse ["a", "b"] ','
05:55:44 <lambdabot>   Couldn't match expected type `[[[GHC.Types.Char]]]'
05:55:52 <FliPPeh> > intersperse ',' ["a", "b"]
05:55:53 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
05:55:55 <FliPPeh> :(
05:55:56 <quicksilver> why does LB give these stupid error messsages ?
05:56:08 <quicksilver> is it because it has GHC.Types in scope?
05:56:12 <quicksilver> if so, can we remove it?
05:56:20 <quicksilver> :t intersperse
05:56:21 <lambdabot> forall a. a -> [a] -> [a]
05:56:29 <quicksilver> FliPPeh: the type tells you what you need to know
05:56:37 <quicksilver> > intersperse ',' "ab"
05:56:38 <lambdabot>   "a,b"
05:56:52 <PeakerWork> > intersperse "," ["a", "b"]
05:56:53 <lambdabot>   ["a",",","b"]
05:56:53 <FliPPeh> Well, Got a list of strings here
05:57:11 <PeakerWork> @type (concat.) . intersperse
05:57:12 <lambdabot> forall a. [a] -> [[a]] -> [a]
05:57:13 <FliPPeh> Want to join them from ["aaa","bbbb"] to aaa,bbb
05:57:19 <jix_> > concat $ intersperse "," ["a", "b"]
05:57:20 <lambdabot>   "a,b"
05:57:23 <PeakerWork> forecasted you :-)
05:57:29 <FliPPeh> :)
05:57:44 <PeakerWork> > concat . intersperse "," $ ["hello", "world"]
05:57:45 <lambdabot>   "hello,world"
05:57:46 <ClaudiusMaximus> @src intercalate
05:57:47 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
05:58:01 <PeakerWork> @. pl src intercalate
05:58:02 <lambdabot> (line 1, column 1):
05:58:02 <lambdabot> unexpected end of input
05:58:02 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
05:58:12 <PeakerWork> @pl intercalate xs xss = concat (intersperse xs xss)
05:58:12 <lambdabot> intercalate = (join .) . intersperse
05:58:48 <quicksilver> FliPPeh: "well I got a list of strings here" -- the answer is : So in that case, use that type with a = String, see?
05:58:51 <quicksilver> ;)
05:58:59 <FliPPeh> > concat . intersperse "," $ ["hello"]
05:59:00 <lambdabot>   "hello"
06:00:08 <FliPPeh> :type concat
06:00:13 <FliPPeh> :t concat
06:00:14 <lambdabot> forall a. [[a]] -> [a]
06:00:28 <FliPPeh> > concat [1,3,4,3,2,4,4]
06:00:29 <lambdabot>   No instance for (GHC.Num.Num [a])
06:00:29 <lambdabot>    arising from the literal `1' at <inter...
06:00:40 <FliPPeh> > show (concat [1,3,4,3,2,4,4])
06:00:41 <lambdabot>   No instance for (GHC.Num.Num [a])
06:00:42 <lambdabot>    arising from the literal `1' at <inter...
06:00:53 <FliPPeh> > concat ['s','o']
06:00:54 <lambdabot>   Couldn't match expected type `[a]'
06:00:55 <ski> > concat [[0,1,2,3],[4,5,6],[7,8],[9],[]]
06:00:56 <lambdabot>   [0,1,2,3,4,5,6,7,8,9]
06:00:57 <FliPPeh> ;S
06:00:59 <FliPPeh> Oh..
06:01:05 <FliPPeh> Stupid me
06:01:07 <RayNbow> FliPPeh, intercalate = concat . intersperse
06:01:08 <FliPPeh> double list
06:01:18 <ski> > concat ["a","quick","brown","fox"]
06:01:20 <lambdabot>   "aquickbrownfox"
06:01:37 <RayNbow> > unwords ["a","quick","brown","fox"]
06:01:38 <lambdabot>   "a quick brown fox"
06:02:03 <RayNbow> > intercalate "--" ["a","quick","brown","fox"]
06:02:04 <lambdabot>   "a--quick--brown--fox"
06:02:06 <FliPPeh> > intercalate ',' ["testing", "furiously"]
06:02:06 <lambdabot>   Couldn't match expected type `[a]'
06:02:10 <RayNbow> ah wait
06:02:15 <jthing> > words "a quick brown fox"
06:02:16 <lambdabot>   ["a","quick","brown","fox"]
06:02:30 <FliPPeh> > intercalate "," ["testing", "furiously"]
06:02:31 <lambdabot>   "testing,furiously"
06:02:41 <bryan1> > reverse ["a","quick","brown","fox"]
06:02:42 <lambdabot>   ["fox","brown","quick","a"]
06:02:59 <ski> @free concat
06:03:01 <lambdabot> $map f . concat = concat . $map ($map f)
06:03:24 <FliPPeh> Sooo
06:03:44 <jthing> > reverse "ablewasiwhenisawelba"
06:03:45 <lambdabot>   "ablewasinehwisawelba"
06:03:59 <FliPPeh> I just managed to write my own IRC Bot without using that tutorial. This marks the start of my active Haskelling phase
06:04:14 <FliPPeh> :)
06:04:25 <FliPPeh> Fetish of mine, I have to write one in every language I try
06:05:02 <EvilTerran> > let cs = map toLower . filter isAlpha $ "Doc, note I dissent - a fast never prevents a fatness. I diet on cod!" in cs == reverse cs
06:05:04 <lambdabot>   True
06:05:04 <jthing> well I'll warn orhers of your IRC's
06:13:01 <TFHosting> http://tfhosting.servehttp.com/services.php <<--- Need a SeedBox?
06:14:03 --- mode: ChanServ set +o Lemmih
06:14:18 --- mode: Lemmih set -o Lemmih
06:14:41 <EvilTerran> Lemmih, beaten to the punch?
06:14:51 <Lemmih> Yeah :(
06:14:57 <EvilTerran> (or the kick, in this case :P)
06:15:16 * Lemmih will go kick an orphan instead.
06:15:58 * edwardk waves hello.
06:17:50 <Saizan> hi
06:23:03 <byorgey_> > intercalate "," ["a", "b"]
06:23:04 <lambdabot>   "a,b"
06:23:30 <byorgey_> hey edwardk
06:24:54 <edwardk> I'm finally able to get back to writing Haskell and my brain is a blank slate ;)
06:25:32 <SamB_XP_> edwardk: isn't that the ideal state ?
06:25:50 <SamB_XP_> well, I mean, it's better than having it full of bad OO methodologies, right?
06:25:54 <edwardk> alas the ideal and the useful rarely coincide ;)
06:27:22 * SamB_XP wonders what -e is
06:28:10 <byorgey> E is for Execute!
06:28:16 <FliPPeh> If I want to keep a state and update it sometimes, I will need a Monad, right?
06:28:39 <edwardk> in general yes
06:28:44 <byorgey> FliPPeh: you don't NEED a monad, you can just pass the state around as an extra parameter to all your functions
06:28:51 <byorgey> but the State monad will automate that for you.
06:28:52 <FliPPeh> Like I am doing now
06:28:58 <edwardk> you can get away without it but the monad is the most convenient method
06:29:00 <FliPPeh> autoJoinChannels :: Handle -> IO ()
06:29:08 <FliPPeh> Always passing a handle
06:29:27 <edwardk> then you might consider working in StateT Handle IO
06:29:39 <edwardk> or making a bigger environment if you commonly use other things
06:29:53 <FliPPeh> I won't keep the handle alone in there
06:30:08 <FliPPeh> I want to pass around current nickname and channel details
06:30:10 <edwardk> the usual idiom is StateT MyState IO ...
06:30:26 <edwardk> and in MyState you have fields for your nickname, channels, etc.
06:30:34 <byorgey> data MyState = MyState { nick :: String, channel :: Foo, handle :: Handle }
06:32:02 <SamB_XP> byorgey: it looks like it actually means "ban exception", possibly ...
06:32:26 <byorgey> oh.
06:32:33 <edwardk> One thing I love about this community is that I'm rarely the only person thinking about something (unless it involves too many uses of the co- prefix) http://www-ps.informatik.uni-kiel.de/~sebf/data/pub/icfp09.pdf provides a nice way to handle some sharing issues i've been having in an EDSL for bayes using gibbs sampling
06:32:53 <SamB_XP> well, except -e would be "no ban exception"
06:33:10 <byorgey> "ban exception excepted"?
06:33:50 <dhun> I am trying to parse my own tokens with Parsec I try to use the "token" function, it takes a function of time  (tok -> SourcePos)  but I don't know how to implement it?
06:33:56 <byorgey> edwardk: yeah, that lazy monadic sharing stuff is neat =)
06:33:59 <SamB_XP> well, +e is supposed to be "ban exception"
06:34:05 <dhun> type
06:34:46 <edwardk> byorgey: i had basically worked out something nigh identical from reading another paper of kiselyov and shan the one on the statistical EDSL in ocaml using delimited continuations
06:34:55 <edwardk> but they packaged it with a better type than I had
06:35:15 <ski> @type Text.ParserCombinators.Parsec.Prim.token
06:35:17 <lambdabot> forall tok a st. (tok -> String) -> (tok -> Text.ParserCombinators.Parsec.Pos.SourcePos) -> (tok -> Maybe a) -> Text.ParserCombinators.Parsec.Prim.GenParser tok st a
06:35:48 <edwardk> i've been trying to avoid dipping down into monads, sticking to applicatives where possible lately because i can play tricky games with stable names to recover sharing info
06:36:15 <ski> dhun : probably you should create a `MyToken' type which contains information about the source position of the token as well as what token it is
06:36:40 <edwardk> note their share :: m a -> m (m a) operator (which is roughly a duplicate/cojoin) doesn't require m to be a monad per se.
06:37:23 <edwardk> i should go through and take their share laws and see how they map onto Alternative
06:37:34 <Botje> phew
06:37:39 <Botje> just finished my written haskell exam
06:40:34 <ray> written haskell?!
06:40:39 <ray> like on paper!?
06:41:00 <dhun> ski I do pos<-getPosition;
06:41:01 <dhun>         token show
06:41:01 <dhun>         (\x -> pos)
06:42:58 <Botje> ray: yeah
06:43:17 <edwardk> i never got to take an exam on haskell =/
06:43:19 <boegel> ray: I think we had something like that too, many years ago
06:43:32 <boegel> ray: hell, I even had a Java exam on paper (partly)
06:43:47 <boegel> Botje: how was it?
06:44:15 <fasta> Let met guess: parsers + folds + a simple inductive proof?
06:44:43 <Botje> good
06:44:59 <Botje> had to rewrite my erlang solution because i missed the final condition in the question
06:45:32 <aCiD2> Hey all, I'm trying out cabal for the first time, but when I run `cabal update` I get the error: "cabal: user error (Codec.Compression.Zlib: premature end of compressed stream)"
06:45:53 <aCiD2> I'm behind a proxy, so it might be that (though it's correctly set in http_proxy), so I'm not sure what else could be the problem
06:46:44 <Axman6> dcoutts: you around?
06:46:45 <fasta> aCiD2: it depends a lot on the actual proxy.
06:47:06 <dcoutts> @arr!
06:47:06 <lambdabot> Ahoy mateys
06:47:13 <dcoutts> Axman6: arr?
06:47:29 <Axman6> thought you might be able to help aCiD2
06:47:42 <Beelsebob> how does one ask cabal to build multiple/a specific target from your cabal file?
06:47:47 <dcoutts> aCiD2: that'll almost certainly be due to a truncated or otherwise borked download
06:47:52 <dino-> @type Control.Arrow.arr
06:47:53 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
06:48:01 <Beelsebob> i.e. I have both a library and an executable specified in the same cabal file
06:48:05 <Beelsebob> atm, it only builds the library
06:48:14 <Beelsebob> how do I get it to build the executable too
06:48:31 <dcoutts> Beelsebob: it builds everything by default unless you set any of them to be not buildable
06:48:40 <aCiD2> dcoutts: ok, but how do I fix that :)
06:48:42 <aCiD2> fasta: how so?
06:48:48 <dcoutts> aCiD2: take a look at the ~/.cabal/packages/$server/00-index.tar.gz
06:48:52 <aCiD2> ok
06:48:55 <Beelsebob> oh hmm, it built the other after a clean
06:48:56 <dcoutts> aCiD2: does it look like a short download?
06:48:57 <Beelsebob> how odd
06:48:59 <dino-> Beelsebob: It's not building both?
06:49:02 <dino-> ah, nm
06:49:06 <deeflex> how do I read from stdin?
06:49:22 <Axman6> hGetcontents
06:49:27 <aCiD2> Yea, unexpected EOF
06:49:28 <Axman6> Contents*
06:49:29 <fasta> aCiD2: proxies generally suck
06:49:54 <aCiD2> dcoutts: it is indeed too short, removing it and trying again results in the same problem
06:50:00 <dino-> Or just getContents
06:50:03 <aCiD2> maybe I should use a ssh tunnel and update through that?
06:50:11 <pastorn> deeflex: if you just want to do a program that reads from stdin and prints stuff to stdout, check out 'interact'
06:50:34 <dcoutts> aCiD2: ok, when you run update with -v3 and see the http conversation, does it report anything odd? What version of the HTTP lib did you build the cabal program against?
06:50:58 <aCiD2> lol, it works fine if I use -v3
06:50:59 <aCiD2> weird
06:51:05 <deeflex> pastorn, no I don't want to print to stdout.
06:51:30 <Axman6> dcoutts: hGetContents
06:51:35 <Axman6> uh, deeflex
06:51:36 <Axman6> even
06:51:37 <dcoutts> aCiD2: that is indeed weird, it doesn't do anything different, just dump the headers sent in each direction
06:51:40 <fasta> aCiD2: I am also behind a proxy and other than my http_proxy variable I don't have to do anything specific. Did you try again?
06:52:03 <aCiD2> yea, it now seems trying for the 5th time is breaking again (as is cabal install hledger)
06:52:06 <Axman6> deeflex: there's getLine
06:52:13 <dino-> Axman6: Is there a benefit, if you specifically want stdin, to NOT using getContents?
06:52:17 <fasta> aCiD2: time to contact your network administrator.
06:52:37 <dcoutts> aCiD2: can you get the 00-index.tar.gz file using wget?
06:52:40 <Axman6> dino-: only if you forgot getContents existed, like i did ;)
06:52:44 <aCiD2> I highly doubt this is a problem with the proxy (as I have never seen any problems in over 2 years) and this runs over the whole of the university...
06:52:49 <dcoutts> aCiD2: I mean can wget work with your proxy but cabal cannot?
06:52:57 <deeflex> Axman6, mhm interesting. I'll look into it
06:53:06 <Axman6> :t getContents
06:53:07 <lambdabot> IO String
06:53:07 <quicksilver> dino-: getContents has broken interleaved IO semantics which mask errors and can't recover from them. Not using it avoids that problem.
06:53:26 <Axman6> quicksilver: alternative is...?
06:53:32 <aCiD2> dcoutts: yep
06:53:34 <dcoutts> aCiD2: in which case we should look at the -v3 debug log and compare it to the wget one. What version of the HTTP lib are you using?
06:53:35 <aCiD2> wget is fine
06:53:43 <aCiD2> How can I check that?
06:53:46 <quicksilver> Axman6: not using it.
06:53:51 <dcoutts> aCiD2: ghc-pkg list HTTP
06:53:51 <quicksilver> Axman6: getLine, for example.
06:53:56 <quicksilver> Axman6: or hGetBuf.
06:54:00 <Axman6> quicksilver: that's what i wanted to know
06:54:14 <aCiD2> that just shows ghc 6.10.3
06:54:15 <quicksilver> or strict bytestring's version of getcontents
06:54:23 <quicksilver> which is fine if you're happy to read it all at once
06:54:25 <dcoutts> aCiD2: where did you get the cabal program from?
06:54:40 <dino-> Ya, I was thinking of that too, that if your task gets serious enough, you end up knocking on ByteString's door.
06:54:42 <aCiD2> I run Arch Linux, so I installed cabal from the community repository
06:55:01 <dcoutts> aCiD2: ok, and what version of HTTP do they use?
06:55:42 <dcoutts> aCiD2: it might be worth building your own version with a known HTTP lib version and reproducing the problem with that, so we know the real version.
06:55:59 <aCiD2> they depend on ">=4000" from the package source
06:56:33 <dcoutts> aCiD2: I'm afraid we need to know the exact version, perhaps try building it from source
06:57:02 <dcoutts> aCiD2: there are several 4000.x versions and there were some important fixes for proxies
06:57:24 <aCiD2> I just installed 4000.0.6
06:57:36 <aCiD2> should I update to 4000.0.7?
06:58:00 <dcoutts> aCiD2: doesn't matter, so long as you've rebuilt the cabal-install package from source using one version or the other
06:58:14 <dcoutts> so that we know the exact version we're testing
06:58:17 <aCiD2> ok, I'll upgrade HTTP and build cabal-install from source now
06:58:22 <dcoutts> great
07:04:15 <aCiD2> dcoutts: Well, I'm pretty sure everything is up-to-date, but the same error happens
07:04:40 <dino-> You know, I still have cabal-install 0.6.0 manually installed. I wonder if I should have it cabal-install itselup up to 0.6.2
07:04:41 <aCiD2> It's odd, because if I keep re-running `cabal update` one of them does happen (and I can't see the problem from -v3)
07:04:53 <dino-> ..itself up..
07:05:15 <dcoutts> aCiD2: and the symptom, when it fails, is that the download is 0-size right?
07:05:44 <dcoutts> ac: could you file a ticket with the cabal update -v3 log of a failing case.
07:05:49 <dcoutts> oops
07:05:50 <aCiD2> No, not size, but incomplete
07:05:51 <dcoutts> aCiD2: ^^
07:05:52 <aCiD2> Sure
07:06:04 <dcoutts> http://hackage.haskell.org/trac/hackage/
07:06:07 <Saizan> dcoutts: yes, you can simply run "cabal install Cabal cabal-install" so that it upgrades Cabal too
07:06:24 <Saizan> ops
07:06:27 <Saizan> dino-: ^^^
07:06:30 <dcoutts> ;-)
07:06:56 <dcoutts> aCiD2: mention the HTTP version, and what would make it really useful is a log of wget getting the same file for comparison.
07:07:19 <dcoutts> aCiD2: do you know how to run wget so that we can see all the headers sent and received?
07:07:26 <dino-> @type (^^^)
07:07:27 <lambdabot> Not in scope: `^^^'
07:07:28 <aCiD2> No, but I'm sure it's in the man page :)
07:07:36 <dcoutts> aye :-)
07:07:48 <ray> :t (&&&)
07:07:50 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
07:07:51 <ray> close enough
07:08:14 <edwardk> i am amused that the fischer, kiselyov and shan paper basically used the Codensity (Reader t) encoding encoding of State t. =)
07:08:32 <ray> > (fst &&& snd) (1,2)
07:08:33 <edwardk> er s/encoding encoding/encoding/
07:08:34 <lambdabot>   (1,2)
07:14:26 <aCiD2> dcoutts: is --verbose -S for wget what you need (verbose + http headers)?
07:15:10 <dcoutts> aCiD2: we want to see what HTTP headers wgets sends, and what the proxy/server sends back.
07:15:22 <aCiD2> Yea, -S seems to give that
07:15:24 <dcoutts> what HTTP headers the proxy/server sends back.
07:15:33 <dcoutts> we don't care so much about the data
07:17:38 <aCiD2> dcoutts: is http://hackage.haskell.org/trac/hackage/ticket/562 ok?
07:19:25 <dcoutts> aCiD2: just to confirm, the first is it failing? the second working?
07:19:30 <aCiD2> yep
07:20:27 <aCiD2> The only difference I can see is that the working one has "Proxy-Connection: Close" and the failing one has "Connection: close"
07:20:37 <aCiD2> wget always uses the former, and never fails (at least over 10 runs)
07:20:55 <defun> HI. I am trying to install some cabal pkgs (i.e. plugins, haskell-src) and they fail because cabal can't install happy. I tried installing happy directly with cabal install happy; and I get this http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5683#a5683         any ideas?
07:20:58 <dcoutts> aCiD2: and the first returns X-Cache: MISS
07:21:25 <aCiD2> Yea, I don't understand why it seems to query the cache twice though
07:21:39 <aCiD2> It hits first, then misses
07:22:10 <dcoutts> aCiD2: perhaps one proxy is talking to another
07:22:20 <dcoutts> defun: looks like some packages are borked
07:22:41 <defun> dcoutts: borked? what's that mean?
07:22:42 <aCiD2> I'll try changing my proxy to exactly wwwcache3 - wwwcache is a sort of round-robin server, I believe
07:23:12 <aCiD2> and loe and behold, it now always works
07:24:03 <defun> dcoutts: is there a way to fix a borked package? How do I know which ones are borked?
07:24:18 <codebliss> What else do you need to do other than "cabal install foo"?
07:24:28 <codebliss> I should have mtl, but there's still a compiler error
07:24:42 <codebliss> Simply compiling http://haskell.org/haskellwiki/Roll_your_own_IRC_bot
07:25:06 <byorgey> codebliss: what's the error?
07:25:47 <FliPPeh> Can anyone help me enhance my code to use a state monad? I've tried it a all, but I just can't get it done :(
07:26:17 <dcoutts> defun: do you by any chance have more than one version of the unix package installed? eg globally and per-user?
07:26:18 <byorgey> FliPPeh: I can probably give you some hints if you paste the code somewhere
07:26:26 <codebliss> GHCI:  unknown package: mtl-1.1.0.0
07:26:26 <codebliss> GHC:  ghc-6.8.2: unknown package: mtl-1.1.0.0 (dependency of parsec-3.0.0)
07:26:34 <FliPPeh> I'm commenting it right now, hold on a second!
07:27:12 <dcoutts> aCiD2: could you update the ticket with that, and can you confirm that you were using HTTP-4000.7 (and you're sure you were then testing using the rebuilt one, not the system one)
07:27:34 <dcoutts> aCiD2: I've added a note about the differences
07:27:42 <defun> dcoutts: no idea. Not sure how to check. Should i use ghc-pkg? Trying it now...
07:27:44 <aCiD2> Ok
07:27:52 <byorgey> codebliss: can you paste the output of 'ghc-pkg list'?  I suspect the problem may be with local vs global package installation
07:28:15 <dcoutts> codebliss: also, ghc-pkg check will report that mtl is missing but that other packages still depend on it
07:28:30 <dcoutts> codebliss: this happens when packages get unregistered but other things still need them
07:28:47 <aCiD2> In a slightly more unrelated question: where do packages get installed to? I had some installed in /usr/local/lib, but I've since removed them
07:28:48 <FliPPeh> byorgey: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2624#a2624
07:28:59 <codebliss> http://pastebin.com/m290a631a
07:29:37 <Baughn> aCiD2: With cabal-install? ~/.cabal, usually.
07:29:45 <aCiD2> ah, ok
07:29:45 <Baughn> aCiD2: THough the registry is in ~/.ghc
07:29:45 <aCiD2> thanks
07:29:47 <byorgey> FliPPeh: so, what fields do you want to be part of your state?
07:30:17 <Baughn> aCiD2: You can tell it to install globally using --global, in which case you should also set a root-cmd in .cabal/config
07:30:26 <FliPPeh> Nickname, Fullname, the Handle of course, Channellist, Server IP and Port
07:30:26 <dcoutts> codebliss: so you've installed mtl-1.1.0.2 but unregistered mtl-1.1.0.0
07:30:30 * Baughn thinks that ought to default to sudo
07:30:36 <dcoutts> codebliss: but other packages still need that mtl-1.1.0.0
07:30:48 <dcoutts> codebliss: run "ghc-pkg check" it'll tell you which
07:30:50 <codebliss> How would I register said package?  =D
07:30:54 <codebliss> kk
07:30:54 <FliPPeh> that's how far I got myself, I also created the StateT Monads, but it kept failing on my exception codes
07:30:58 <defun> dcoutts: I have 2 pkgs. one in /usr/local/lib/ghc-6.10.1/./package.conf and one unix in /export/home/zivkovic/.ghc/i386-solaris2-6.10.1/package.conf both contain unix-2.3.1.0 here is a copy of the output: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5684#a5684
07:30:58 <FliPPeh> So I gave up
07:31:09 <Baughn> codebliss: Best option, if possible, is to reinstall the mtl-dependent packages
07:31:24 <codebliss> http://pastebin.com/m44bee47f
07:31:31 <codebliss> --reinstall?
07:31:32 <dcoutts> defun: so the user one is shadowing the global one and that's causing the linker errors
07:31:37 <Baughn> Yes
07:31:38 <dcoutts> defun: remove the per-user one
07:31:51 <dcoutts> defun: because they're not exporting the same ABI
07:31:59 <byorgey> FliPPeh: a couple points: (1) if you switch to using types like  StateT MyState IO a, you will need to wrap any IO actions in a call to 'liftIO'
07:32:06 <defun> dcoutts: how? edit the file?
07:32:18 <Baughn> codebliss: Well, the downside of reinstalling mtl-1.1.0.0 would be that you may get type errors in programs that use both, for example, network and parsec
07:32:33 <Baughn> codebliss: But only in interfaces that use mtl types
07:32:34 <FliPPeh> liftOP putStrLn "Like that?"
07:32:50 <codebliss> I doubt I personally will use mtl in my code for a while now
07:32:54 <byorgey> FliPPeh: more like  liftIO $ putStrLn "Like this"
07:33:03 <FliPPeh> Okay
07:33:04 <Baughn> codebliss: Considering that you've got gtk2hs in there I'd say reinstall mtl and deal with it if it happens. :)
07:33:05 <dcoutts> defun: no, use ghc-pkg unregister --user thepkgname-x.y
07:33:18 <defun> thanks!
07:33:22 <codebliss> Alright, thanks mate.
07:33:26 <Baughn> It defaults to --user, doesn't it?
07:33:34 <byorgey> FliPPeh: 'gets fieldname' is useful for extracting one particular component of a state record
07:34:00 <byorgey> FliPPeh: updating one component of the state is a bit annoying, but I suggest making separate functions to do this, like:
07:34:17 <FliPPeh> updateNick
07:34:22 <Baughn> @type runState
07:34:23 <lambdabot> forall s a. State s a -> s -> (a, s)
07:34:36 <codebliss> Baughn: ghc-pkg check now yields nothing, thank you =D
07:34:56 <byorgey> setNick :: StateT MyState IO () ;  setNick n = do s <- get; put (s { nick = n })
07:35:05 <Baughn> > runState (put =<< (+1) <$> get) 2
07:35:07 <lambdabot>   ((),3)
07:35:27 <Baughn> > runState (replicateM 3 (put =<< (+1) <$> get)) 2
07:35:29 <lambdabot>   ([(),(),()],5)
07:35:45 <byorgey> FliPPeh: I'm not sure exactly what you mean when you say that it was "failing on your exception codes"
07:36:11 <FliPPeh> Had to do with IO vs new Monad
07:38:04 <defun> I masked the pkg and now I get a new error... :(    http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5685#a5685
07:38:57 <FliPPeh> hmmm
07:39:46 <Saizan> defun: some problem but with another package
07:40:06 <defun> Saizan: you mean 'same problem'?
07:40:18 <FliPPeh> How can I manually create an empty, invalid IO State?
07:40:21 <Saizan> defun: yes, sorry
07:40:45 <Saizan> FliPPeh: what's your main problem?
07:41:03 <Saizan> FliPPeh: that you can't pass something using StateT s IO to catch?
07:41:06 <defun> Saizan: perhaps I should unregister the global unix pkg and use the usr unix pkg?
07:41:08 <FliPPeh> I'll have to add the Handle to my Botstate
07:41:16 <FliPPeh> And in order to create the StateT
07:41:19 <FliPPeh> ..
07:41:23 <Saizan> defun: no, the opposite
07:41:31 <FliPPeh> main = runStateT sample (BotState ...)
07:41:38 <FliPPeh> I have to initialize it first
07:41:47 <FliPPeh> But I cannot initialize a handle
07:41:48 <defun> I just did the opposite. i.e. unregistered unix user pkg...
07:42:22 <Saizan> FliPPeh: i'd open the connection before running the action, or you can use "error "handle not set yet"" for the Handle field
07:42:31 <defun> Saizan: Is it possible that both unix pkgs are messed up?
07:42:45 <FliPPeh> I'll try connecting before state
07:43:00 <Saizan> defun: it might be, can you paste the output of ghc-pkg list?
07:43:10 <defun> sure.
07:43:42 <Saizan> it's more likely you've two versions of process
07:43:49 <defun> Saizan: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5686#a5686
07:44:09 <defun> you'll see that unix usr has been unregistered before the error.
07:44:45 <Saizan> defun: i'd unregister process-1.0.1.1 too
07:45:11 <defun> Saizan: ok. 1 sec.
07:45:13 <kig> is there a ready-made function for stripping duplicates from a list?
07:45:19 <SamB> kig: nub
07:45:30 <Saizan> defun: it probably dependend on the old unix
07:45:36 <SamB> it apparantly means "essance"
07:45:39 <Saizan> defun: s/old/user/
07:45:43 <SamB> er. "essence"
07:46:03 <kig> SamB: perfect, thanks
07:46:41 <defun> Saizan: it's saying that unregistering process would break the haskell98 pkg... should i use --force to override?
07:46:51 <codebliss> kig: Check out (http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html), you use those funcs a lot
07:48:32 <defun> ok, i'll use --force.
07:49:18 <Saizan> defun: unregister the user haskell98 too :)
07:50:13 <Saizan> defun: did you use "cabal upgrade" perhaps? it's been a while since i've seen this kind of packages breakage
07:50:53 <defun> Saizan: now Happy installed! Yay! Thanks! No, I used cabal install. What does cabal upgrade do? upgrade a pkg or upgrade cabal itself?
07:51:26 <ray> it tells you what packages to upgrade
07:51:39 <Saizan> defun: upgrades a package and its dependencies
07:51:55 <Saizan> defun: i do not recommend using it
07:52:03 <defun> i see. thanks.
07:53:32 <FliPPeh> Maaan
07:53:33 <defun> Saizan: what do i do if I need to re-register those pkgs in the future?
07:53:41 <FliPPeh> Main.hs:40:27:
07:53:41 <FliPPeh>     Couldn't match expected type `()'
07:53:41 <FliPPeh>            against inferred type `((), BotState)'
07:53:49 <FliPPeh> runStateT run (BotState server port nick name channels h)
07:53:49 <FliPPeh> run :: Bot ()
07:53:50 <FliPPeh> What?
07:54:47 <byorgey> @type runStateT
07:54:48 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
07:55:00 <byorgey> @type execStateT
07:55:01 <lambdabot> forall s (m :: * -> *) a. (Monad m) => StateT s m a -> s -> m s
07:55:09 <byorgey> @type evalStateT
07:55:10 <lambdabot> forall s (m :: * -> *) a. (Monad m) => StateT s m a -> s -> m a
07:55:16 <byorgey> perhaps you want one of those instead?
07:55:25 <byorgey> runStateT gives you back a pair of the result and the final state
07:56:16 <PeakerWork> why are run/exec not in MonadState for consistency, btw?
07:56:26 <PeakerWork> oh, I see why
07:57:49 <quicksilver> you can only run when StateT is outermost.
07:58:06 <PeakerWork> and you don't want the result in a monad if its just State
07:59:28 <defun> I am trying to install haskell-src, but cabal can't find happy. I *just* installed it. Here is the output: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5688#a5688
07:59:38 <PeakerWork> I understand how ContT (StateT s ...) behaves. How does StateT s (ContT ...) behave differently?
07:59:39 <Saizan> defun: you shouldn't install the same version of a package in both the global and user database (this should be fixed for ghc-6.12), but otherwise you can just cabal install them
07:59:52 <Saizan> defun: do you have happy on your $PATH ?
08:00:28 <defun> I don't even know where happy is... I just assume it's in the .cabal directory. Anyway I could find out?
08:00:40 <Saizan> ~/.cabal/bin by default
08:00:51 <defun> I see.
08:00:53 <defun> 1 sec.
08:00:58 <mapreduce> "the happy path"
08:01:20 <edwardk> PeakerWork: think of the StateT s (ContT ...) -- as its expansion to: s -> ((a, s) -> m r) -> m r -- then it should be more obvious
08:01:33 <quicksilver> PeakerWork: the different is whether, when you do "weird control flow", do you take your state with you?
08:01:47 <quicksilver> PeakerWork: or do you "reset" the state to that which applies to the new control flow location.
08:02:10 <PeakerWork> edwardk, quicksilver: Thanks!
08:02:15 <PeakerWork> quicksilver: but what exactly do you reset to?
08:02:27 <edwardk> unfortunately both of those are valid interpretations of what to do with the state, so you wind up having conflicting semantics for dealing with cps'd state
08:04:08 <edwardk> quicksilver: erm, isn't it instance MonadState s m => MonadState s (ContT m) that has the issue?
08:04:27 <quicksilver> is this an "issue"
08:04:30 <edwardk> StateT m doesn't care what m is or how it affects control flow, merely that it is a monad.
08:04:35 <quicksilver> isn't it just what they things mean?
08:04:48 <quicksilver> compare ErrorT StateT and StateT ErrorT
08:04:55 <quicksilver> in one case you still have a final state, in case of error
08:05:04 <defun> Saizan: added ~/.cabal/bin to my path. Still says happy not found...
08:05:06 <quicksilver> in the other case, you don't have a final state, you only have an error.
08:05:14 <quicksilver> ErrorT is a very simple case of ConT
08:05:21 <defun> Saizan: so should they be installed in usr or global?
08:05:22 <quicksilver> (where the only thing you can do is jump to the end)
08:05:23 <edwardk> quicksilver: well what i mean by issue is that you have the ensuing religious war as to whether you get 'commit' or 'rollback' =)
08:05:47 <dcoutts> defun: if it's in your path, ie you can run $ happy, then cabal will find it
08:06:39 <defun> 1 sec. it looks like it's not in my path after all... I hate bash...
08:07:35 <hatds> what's the proper way to open, say, a 40 MB .txt file and read the contents to a haskell value?
08:07:37 <edwardk> personally i've always thought it made the most sense to just define ContT (State s ...) with the opposite behavior of StateT s Cont ..., but mmorrow convinced me that its useful to offer both
08:07:49 <koeien> hatds: what "value"? a String or ByteString?
08:07:52 <quicksilver> hatds: if you have 40M of memory spare, then a strict bytestring is quite a good way.
08:08:07 <hatds> value in the sense of Read a
08:08:12 <koeien> hatds: or a very long integer for example
08:08:25 <defun> dcoutts: ok it is now. and haskell-src is installing... thnx.
08:08:32 <quicksilver> Ouch. You really don't want to call "read" on a 40M string
08:08:37 <quicksilver> read is not built for performance ;)
08:08:42 <koeien> read is slow
08:08:43 <hatds> yea, so what should I do
08:08:43 <defun> YES! It worked!
08:09:13 <skorpan> is hs-plugins deprecated or something?
08:09:30 <koeien> hatds: do you know the type you want to read ?
08:09:34 <skorpan> the homepage hasn't been updated in more than three years
08:09:53 <defun> thanks! now everything works as expected. :-D
08:09:58 <hatds> koeien: yes
08:10:24 <Twinside> hi, I would like to add an instance to MArray STUArray (or IOUArray, I don't car which one) for one of my simple type, is there a documented way somewhere?
08:10:34 <koeien> hatds: you can try to `read' it, but i doubt it'll be fast
08:10:48 <Saizan> skorpan: it's still used by, e.g. turbinado
08:10:55 <hatds> even just reading the file to a String is ridiculous, ghc is paging like crazy
08:10:59 <hatds> I don't know why
08:11:32 <fasta> Haskell is not C, that's why.
08:12:00 <fasta> Or the compiler is not smart enough to make something run as if it were written in C.
08:12:02 <hatds> yea, but a String is how many times bigger than a .txt?
08:12:22 <Saizan> 10x?
08:12:52 <Saizan> maybe more
08:12:55 <fasta> 16 bytes/char, or something like that? I never had to care about those details, but maybe in some time.
08:13:13 <hatds> task manager says ghc is holding onto 1.6 GB
08:13:30 <fasta> hatds: that's just the maximum memory usage.
08:13:36 <vegai> I suppose it could be just 16bits+list overhead
08:13:41 <vegai> 16bits/char
08:13:43 <Lemmih> String is 20bytes per character on 32bit machines. Then comes the 3x GC overhead.
08:13:53 <vegai> whoa, vhy?
08:14:01 <vegai> pardon my surprising german accent
08:14:19 <fasta> hatds: GHC doesn't return memory to the OS.
08:14:25 <hatds> why isn't it like 4 bytes for the Char, and a few more bytes for the Box and Cons?
08:14:34 <quicksilver> it is.
08:14:40 <fasta> hatds: the argument is that especially on 64 bit systems, the virtual memory system handles it.
08:14:47 <Lemmih> hatds: It is.
08:14:52 <quicksilver> 4 bytes for the char, 4 bytes for the indirection, 4 bytes for the cons cell, 4 bytes for the cons cell indirection
08:15:04 <quicksilver> and 4 bytes for the tail pointer
08:15:08 <vegai> ah
08:15:11 <quicksilver> == 20 bytes per char, if I got that right.
08:15:21 <fasta> hatds: the real reason is that nobody cares enough for that particular issue.
08:15:32 <quicksilver> hatds: that's why we have bytestring
08:15:38 <vegai> why 4 bytes for the char?
08:15:41 <hatds> teach me how to love bytestring then
08:15:44 <quicksilver> hatds: which is why all the initial answers to your question mentioned bytestring
08:15:52 <quicksilver> vegai: uniform representation.
08:15:56 <quicksilver> vegai: everything is 4 bytes
08:16:01 <quicksilver> that's how polymorphism works.
08:16:08 <hatds> can bytestring be used to serialize and unserialize haskell values?
08:16:10 <Axman6> hatds: uses arrays of unboced chars i think
08:16:12 <quicksilver> yes.
08:16:13 <Saizan> well, also because Char is an unicode codepoint
08:16:14 <koeien> yes.
08:16:24 <vegai> quicksilver: ok
08:16:26 <quicksilver> Saizan: sure, but Word8 is 4 bytes as well.
08:16:33 <Lemmih> fasta: It's not that we don't care. It's not technically possible for it to be smaller with the same representation.
08:16:33 <quicksilver> Saizan: ...and Char is 8 bytes on a 64 bit machine.
08:16:43 <Axman6> unboxed*
08:17:14 <Axman6> hatds: i've never used them, but bytestrings are supposed to be very fast, and very efficient
08:17:20 <koeien> they are
08:17:28 <koeien> you can get close to C performance
08:17:32 <jmcarthur_work> very fast
08:17:33 <fasta> Lemmih: I am sorry, I don't understand why that is the case. We are talking about returning memory to the OS, right?
08:17:45 <jmcarthur_work> a bit of a pain to mess with namespacing though
08:17:51 <dino-> Just to throw this out, the data parts of happstack do some of this too, deserialize data on disk back into your type(s) in mem. But structuring around that storage may not fit your needs.
08:17:54 <Saizan> hatds: see the binary package for serialization with bytestring
08:18:11 <jmcarthur_work> i wish the default String type was ByteString and that we also just had ListString or something instead
08:18:17 <vegai> is there a technical reason why String and Bytestring don't both implement a typeclass?
08:18:23 <koeien> or polymorphic string literals ;)
08:18:25 <Lemmih> fasta: Oh sorry, I through you were referring to the String issue. My bad.
08:18:25 <vegai> jmcarthur_work: exactly :)
08:18:41 <jmcarthur_work> :t fromString
08:18:42 <lambdabot> Not in scope: `fromString'
08:18:46 <jmcarthur_work> eh, i don't remember it
08:18:52 <vegai> factor's sequence protocol is so nice...
08:19:11 <jmcarthur_work> with the overloaded strings extension you can make string literals convert to a type other than String
08:19:28 <jmcarthur_work> like Num
08:20:16 <jmcarthur_work> class IsString a where fromString :: String -> a
08:20:20 <jmcarthur_work> that's the class
08:20:43 <doserj> vegai: for one thing, in Haskell'98 String, can't implement any typeclass...
08:20:55 <jmcarthur_work> http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#overloaded-strings
08:21:44 <quicksilver> jmcarthur_work: I don't.
08:21:51 <quicksilver> if ByteString was the default string type then
08:22:07 <quicksilver> foldr, unfoldr, map, filter, foldl', concat .... woudln't work on it
08:22:16 <quicksilver> that's not the language I want to use.
08:22:22 <jmcarthur_work> toList?
08:22:30 <jmcarthur_work> unpack, whatever
08:22:36 <quicksilver> right. So I have to add "toList" to every single operation
08:22:42 <quicksilver> and I end up back at [Char]
08:22:47 <quicksilver> I'd rather start with [Char], please ;0
08:22:48 <jmcarthur_work> not every single operation, just the ones that are list-like
08:22:54 <quicksilver> and use ByteString when I choose to.
08:22:56 <quicksilver> which is seldom.
08:23:31 <jmcarthur_work> :t concat
08:23:31 <lambdabot> forall a. [[a]] -> [a]
08:24:08 <jmcarthur_work> would work fine on [ByteString] if it was the properly overloaded version of concat
08:24:21 <jmcarthur_work> i still get your point
08:24:32 <quicksilver> ByteString isn't a monad, either ;)
08:24:50 <jmcarthur_work> i tend to use strings as lists rather infrequently
08:24:51 <quicksilver> I don't think overloading is a good solution for this.
08:25:33 <doserj> what would that overloaded type for concat be?
08:25:34 <jmcarthur_work> and anyway, having String be ByteString by default doesn't mean we can't have prelude functions that don't work on [Char] or return IO [Char] or whatever
08:25:47 <jmcarthur_work> it just means String is a different type
08:26:05 <quicksilver> that is, of course, true.
08:26:05 <jmcarthur_work> :t Data.Foldable.concat
08:26:06 <lambdabot> forall (t :: * -> *) a. (Data.Foldable.Foldable t) => t [a] -> [a]
08:26:10 <jmcarthur_work> err
08:26:20 <jmcarthur_work> :t Data.Foldable.fold
08:26:21 <lambdabot> forall (t :: * -> *) m. (Data.Foldable.Foldable t, Monoid m) => t m -> m
08:26:22 <quicksilver> that generalises in the wrong direction ;)
08:26:27 <quicksilver> yeah, that's the one you want.
08:26:45 <doserj> ah
08:27:24 <quicksilver> in fact that's more generalised that jmcarthur_work was specifically after
08:27:29 <jmcarthur_work> :t fold
08:27:31 <lambdabot> Not in scope: `fold'
08:27:34 <quicksilver> he was after the particular case where t = []
08:27:41 <quicksilver> but, it is obviously good enough ;)
08:28:41 <jmcarthur_work> @hoogle Monoid m => [m] -> m
08:28:42 <lambdabot> Data.Monoid mconcat :: Monoid a => [a] -> a
08:28:42 <lambdabot> Prelude head :: [a] -> a
08:28:42 <lambdabot> Prelude last :: [a] -> a
08:28:46 <jmcarthur_work> mconcat!
08:29:56 <jmcarthur_work> does hoogle even care about type classes?
08:30:17 <quicksilver> I think the latest version might do?
08:30:21 <quicksilver> I'm not sure the one in LB does.
08:33:34 <alinp> Hi
08:33:51 <alinp> can anyone please tell me, why/when I'll need infinite lists in haskell ?
08:34:15 <Vq^> alinp: you don't _need_ them
08:34:17 <alinp> Some infinite term explained link will help
08:36:06 * Vq^ can't think of a problem that can't be solved without infinite lists
08:36:38 <jmcarthur_work> i tend to consider lists as a control structure rather than a data structure
08:36:44 <PhilRod> but they're often a nice way of framing a problem
08:36:46 <jmcarthur_work> and an infinite list is basically an infinite loop
08:36:48 <alinp> Vq^: sorry, but I can't understand your statement :)
08:36:55 <jmcarthur_work> but you can break out of that loop, of course
08:37:02 <jmcarthur_work> and even go back into it later
08:37:04 * PhilRod used them all the time for project euler
08:38:24 <ClaudiusMaximus> > let converge (x:y:xs) = if x == y then x else converge (y:xs) in converge . iterate (\x -> x + 1/x) $ (1::Double)
08:38:30 <lambdabot>   mueval-core: Prelude.read: no parse
08:38:30 <lambdabot>  mueval: ExitFailure 1
08:38:43 <Vq^> alinp: you don't need infinite lists, but sometimes they simplify your code in a nice way
08:38:55 <alinp> I see
08:39:00 <PhilRod> alinp: somewhere I used them a lot (for euler) was for looping over the primes, say
08:39:01 <jmcarthur_work> typically the alternative to an infinite list is explicit recursion
08:39:25 <alinp> yes, I know, primes is the best example for infinite lists
08:40:10 <jmcarthur_work> > head . filter (\x -> x `mod` 2000 == 0) $ [2001..]
08:40:11 <lambdabot>   4000
08:40:13 <alinp> I asked this about infinite list, because one friend of mine, asked me "and how infinite lists can help me ? "
08:40:13 <mxc> hi, getting a strange error regarding overlapping instances..  I defined my own instance Monad Data.Either and am getting this error: Matching instances:
08:40:14 <mxc>       instance (Control.Monad.Error.Class.Error e) => Monad (Either e)
08:40:14 <mxc>         -- Defined in Control.Monad.Error
08:40:14 <mxc>   
08:40:19 <jmcarthur_work> ^^ would require some recursion otherwise
08:40:22 <alinp> and I didn't know what to answer to thaty
08:40:25 <alinp> *that
08:40:30 <mxc> is there anyway to hide the instance from Control.Monad.Error?
08:40:34 <jmcarthur_work> or math, i guess
08:40:45 <jmcarthur_work> but there are other things which wouldn't simplify with arithmetic
08:40:45 <Vq^> zip [0..]  is a nice idiom that uses an infinite list
08:41:01 <jmcarthur_work> > zip "Hello, world!" [0..]
08:41:02 <lambdabot>   [('H',0),('e',1),('l',2),('l',3),('o',4),(',',5),(' ',6),('w',7),('o',8),('...
08:41:13 <Axman6> alinp: one simple example would be f xs = zip [0..] xs, which would give you an index for each element in a list
08:41:28 <doserj> mxc: only by not importing Control.Monad.Error
08:41:49 <mxc> doserj - thats the strange thing, I dont import it anywhere
08:42:03 <doserj> mxc: you do, indirectly, probably
08:42:10 <mxc> !find . -name "*.hs" | xargs grep -i Monad.Error  give nothing..
08:42:12 <jmcarthur_work> this is a problem with type classes. they are global
08:42:23 <mxc> doserj - you must be right
08:43:23 <Vq^> alinp: it's often more troublesome to add a limit than to have something infinite
08:44:51 <dhun> how can I remove the element x from the list y
08:45:22 <jmcarthur_work> filter (/= x) y
08:45:32 <jmcarthur_work> something like that?
08:45:40 <dhun> yes
08:45:41 <EvilTerran> > delete 'a' "abracadabra"
08:45:42 <lambdabot>   "bracadabra"
08:45:48 <jmcarthur_work> that works too :P
08:45:54 <jmcarthur_work> but will only delete one
08:45:58 <jmcarthur_work> which may be what you want
08:46:01 <dhun> thats ok
08:46:03 <EvilTerran> ^ delete takes only the first copy, so would be more efficient if you know there's no duplicates
08:46:18 <EvilTerran> > filter (/='a') "abracadabra" -- while filter, naturally, takes all of them
08:46:19 <lambdabot>   "brcdbr"
08:46:23 <dhun> I got no duplictes
08:47:39 <mxc> thanks guys
08:47:41 <dhun> : Not in scope: `delete'
08:47:51 <EvilTerran> dhun, it's in Data.List
08:48:16 <EvilTerran> "import Data.List (delete)" at the top of the module (or after the "module ... where", if you've got one)
08:48:46 <PeakerWork> @index delete
08:48:47 <lambdabot> Data.HashTable, Data.IntMap, Data.IntSet, Data.List, Data.Map, Data.Set
08:49:15 <dhun> hehe but I can not compare data constructors for equality, so I can't do that
08:49:34 <jmcarthur_work> oh this is a list of functions?
08:49:51 <dhun> a list of data consturctors
08:50:03 <jmcarthur_work> those are essentially functions
08:50:06 <dhun> data A= A Int | B int
08:50:10 <dhun> [A,B]
08:50:18 <quicksilver> you don't want to do that, IMO.
08:50:25 <jmcarthur_work> A :: Int -> A and B :: Int -> A
08:50:34 <quicksilver> you want to do
08:50:40 <jmcarthur_work> dhun, if you really need that, perhaps you should have a Map or something
08:50:46 <jmcarthur_work> instead of a list
08:50:58 <quicksilver> data A = A Int | B Int; data A_Con = AC_A | AC_B deriving (Eq)
08:51:08 <jmcarthur_work> what he said
08:51:09 <quicksilver> then put [AC_A,AC_B] in the list, where you can compare them.
08:51:26 <quicksilver> i.e. have a simple "enum-like" type which mirrors your constructor structure.
08:51:27 <jmcarthur_work> and a function construct :: A_Con -> Int -> A
08:51:32 <Saizan> or data A = Con Kind Int; data Kind = A | B
08:51:38 <quicksilver> yup.
08:51:46 <quicksilver> if it really is Int in all cases
08:51:50 <quicksilver> oh, obviously it is
08:51:56 <dhun> I think I will just have two list, the lists are fixed at compile time anyway
08:51:57 <quicksilver> or you wouldn't be able to put them in a list
08:52:00 <jmcarthur_work> yeah, the list worked
08:52:02 <quicksilver> so yes, I'm with Saizan.
08:52:11 <quicksilver> data A = Con Kind Int;
08:53:33 <EvilTerran> or just "data A = A | B", and use (A,Int)
08:53:52 <EvilTerran> although that's a bit quick-and-dirty-er
08:53:54 <dhun> interesting
08:55:12 <doserj> data A = Con Kind Int gives you the Con_A constructor essentially for free, though. (A,) doesn't work unfortunately..
08:55:29 <quicksilver> you just spell it (,) A
08:55:35 <quicksilver> maybe that's uglier than Con A
08:55:38 <quicksilver> but it's not very different.
08:55:41 <doserj> true
08:55:49 <Saizan> if you hate the overhead you could derive Data and use its reflection features, but that's probably not the best route for a beginner
08:56:02 <quicksilver> the advantage of (A,Int) is you get fst and snd for free
08:56:05 <quicksilver> I suppose.
08:56:18 <dhun> haskell has got reflection?
08:56:24 <EvilTerran> quicksilver, and all the Arrow functions for pairs
08:56:29 <jmcarthur_work> dhun, what kind of reflection?
08:56:45 <jmcarthur_work> oh Data
08:56:47 <dhun> the one Saizan mentioned?
08:56:51 <FliPPeh> "do h <- gets handleS" How would I write that without using DO notation?
08:56:53 <Saizan> dhun: you can reify constructors and types using Typeable/Data
08:57:11 <EvilTerran> FliPPeh, depends on what you're doing with h
08:57:16 <quicksilver> dhun: no, and yes.
08:57:21 <FliPPeh> Mhh..
08:57:23 <quicksilver> haskell doesn't have reflection, technically.
08:57:25 <FliPPeh> I want to use it.
08:57:32 <Saizan> FliPPeh: gets handleS >>= \h -> ...
08:57:46 <EvilTerran> where "..." is where you're using it
08:57:47 <quicksilver> but there are metaprogamming facilities which enable you to accomplish much the same thing
08:58:11 <quicksilver> "deriving Typeable" is relatively lightweight metaprogramming, "deriving Data" is much more complex.
08:58:17 <quicksilver> and TH is even more powerful.
08:58:30 <quicksilver> All these things happen at compile-time whereas "Reflection" normally happens at runtime.
08:58:34 <jmcarthur_work> i don't think macros count as reflection
08:58:39 <Saizan> does the "lots of boilerplate written by the compiler" qualifies as metaprogramming?
08:58:45 <quicksilver> obviously that makes reflection inferior.
08:59:02 <jmcarthur_work> Saizan, i'd say it does, just not reflection
08:59:04 <EvilTerran> quicksilver, well, there's a fair bit of runtime shennanigans involved in SYB, isn't there?
08:59:10 <quicksilver> jmcarthur_work: they are different but can be used to solve the same problem.
08:59:26 <FliPPeh> I want to use it there: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2627#a2627
08:59:33 <quicksilver> jmcarthur_work: (some of the same problems, I mean)
08:59:55 <dhun> my parser finally understands this
08:59:55 <dhun> # 1
08:59:55 <dhun> #* 2
08:59:55 <dhun> #;; 3  ''dd''
08:59:55 <dhun> #** 4
08:59:55 <dhun> # 5
09:00:06 <dhun> very happy
09:00:06 <EvilTerran> FliPPeh, i'd stick with do-notation there
09:00:07 <jmcarthur_work> @undo do h <- gets handleS; doSomething h
09:00:08 <lambdabot> gets handleS >>= \ h -> doSomething h
09:00:10 <quicksilver> EvilTerran: Hmm. Well, yes and no.
09:00:22 <jmcarthur_work> @@ @pl @undo do h <- gets handleS; doSomething h
09:00:22 <lambdabot>  doSomething =<< gets handleS
09:00:23 <quicksilver> EvilTerran: there is a *compile-time* process which arranges for lots of stuff to be reified as values
09:00:28 <quicksilver> EvilTerran: which can be inspected at runtime.
09:00:30 <Axman6> @. pl undo do h <- gets handleS; doSomething h
09:00:31 <lambdabot> doSomething =<< gets handleS
09:00:32 <FliPPeh> Keeps telling me the last statement must be an expression
09:00:32 <EvilTerran> gotcha
09:00:53 <doserj> FliPPeh: indentation error. align the "case" with the h
09:01:00 <EvilTerran> FliPPeh, 'case' has to be lined up with the first line in the do block, not the do itself
09:01:20 <FliPPeh> Ohh--
09:01:27 <EvilTerran> {-not here-}do {-but here!-}h <- gets handleS
09:01:29 <FliPPeh> Stupid me, forgot that when adding that
09:01:43 <FliPPeh> The "return ()" at the end is right, right?
09:01:59 <EvilTerran> yeah, looks fine
09:02:09 <FliPPeh> :)
09:02:12 <FliPPeh> Thank you!
09:02:31 <EvilTerran> assuming handlePrivmsg and autoJoinChannels  are both :: ... -> IO (), anyway
09:02:51 <Saizan> Bot ()
09:02:53 <Saizan> rather
09:02:57 <FliPPeh> Bot ()
09:02:58 <FliPPeh> yep
09:02:58 <EvilTerran> er, yes
09:03:26 * EvilTerran is used to the monad being IO when monads and handles occur together <.<  >.>
09:05:43 <FliPPeh> I hate errors that should not pop up
09:05:49 <FliPPeh> Main.hs:81:160: parse error on input `->'
09:06:03 <FliPPeh> Line 81 = " "376"     -> autoJoinChannels "
09:07:20 <Twey> FliPPeh: Looks like an indentation error.
09:07:25 <FliPPeh> I think
09:07:28 <FliPPeh> Just can't find it
09:07:36 <Twey> Been mixing tabs and spaces?
09:08:05 <FliPPeh> I configured my editor to only use spaces
09:08:57 <FliPPeh> O
09:08:58 <FliPPeh> Ohh
09:09:00 <FliPPeh> haha
09:09:17 <EvilTerran> FliPPeh, ?
09:09:26 <FliPPeh> "376"     -> autoJoinChannels                                                    _         -> return ()
09:09:30 <FliPPeh> Dead line on the end of it
09:09:38 <FliPPeh> Must have tapped "DEL" one too often
09:09:48 <FliPPeh> Was outside of the viewpoint :)
09:09:54 <EvilTerran> dead line?
09:10:04 <FliPPeh> It belongs under that line
09:10:07 <FliPPeh> Not right behind it
09:10:25 <EvilTerran> ah
09:11:20 <EvilTerran> FliPPeh, incidentally, you could fold those two nested cases into case words rest of sender:"PRIVMSG":para -> ...; _:"376":_ -> ...; _ -> return ()
09:15:22 <Eiler> how do i make a table with a string representing a function?
09:15:56 <EvilTerran> that depends entirely on what you mean by "table" and "representing"
09:16:07 <quicksilver> and possibly "function"
09:16:12 <quicksilver> oh language, how you fail us.
09:16:48 <Eiler> "sqrt" -> sqrt
09:17:24 <EvilTerran> ... that'll be manually, then
09:17:45 <EvilTerran> names given to haskell values have no meaning at runtime
09:17:55 <Eiler> what does "->" represent in words then?
09:18:12 <EvilTerran> α-renaming is kinda useful to keep working
09:18:38 <Zao> function taking _ "giving" _?
09:18:42 <EvilTerran> Eiler, er, that looks like some kind of introspection, or runtime evaluation of haskell code, or something of that nature
09:18:58 <doserj> Eiler: do you want sth. like Data.Map.fromList [("sqrt",sqrt),...], or sth like eval::String -> (...)?
09:19:16 <Zao> EvilTerran: Map String f , where f is a nice and cuddly monomorphic function type?
09:19:34 * EvilTerran pokes Zao's tab key a second time
09:19:58 <FliPPeh> EvilTerran: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2629#a2629 is this what good haskell should look like? :)
09:20:06 <dhun> why does this definition work: notFollowedBy p  = try (do{ c <- p; unexpected (show [c]) }
09:20:06 <dhun>                        <|> return ()
09:20:06 <dhun>                        )
09:20:07 <Zao> EvilTerran: Alternatively, I could type out more than one character before I complete, but that'd be work :)
09:20:12 <Zao> EvilTerran: IRC needs more DWIMC.
09:20:24 <Eiler> doserj: yes that might be it. now i have like: functionpointer fn = case fn of \n "factorial" -> factorial \n "sqrt" -> sqrt \n _ -> id
09:20:31 <dhun> to me it look that return () is alway executed
09:20:34 <Eiler> and it is runtime evaluation im going to do
09:20:37 <Zao> EvilTerran: Will the functions always be  a -> b ?
09:20:44 <Zao> Dammit... Eiler :P
09:20:57 <Zao> With the same a and b for everything?
09:21:18 <Eiler> not sure but i think so
09:21:20 <EvilTerran> FliPPeh, looks pretty good, yeah
09:21:43 <EvilTerran> FliPPeh, i think forever may be written for you in Control.Monad
09:22:07 <EvilTerran> not that "import Control.Monad (forever)" is substantially shorter than "forever m = m >> forever m"
09:22:16 <Eiler> what is eval::String?
09:22:35 <FliPPeh> :)
09:22:36 <doserj> Eiler: sth that doesn't exist in Haskell
09:22:37 <FliPPeh> Thanks
09:22:48 <Saizan> it does exist
09:22:50 <Eiler> sth = something?
09:22:59 <Saizan> look at the hind package
09:23:02 <Saizan> *hint
09:23:15 <EvilTerran> FliPPeh, and you could write "connect s = connectTo s . PortNumber . fromIntegral", but it's a matter of personal taste whether that or yours is preferrable
09:23:31 <FliPPeh> And now just by giving a function the type of Bot, I can use the gets and put methods to get any value from the BotState data?
09:24:15 <ClaudiusMaximus> EvilTerran: i thought PortNumber had a Num instance, which was preferrable to using the PortNumber constructor, for endianness reasons
09:24:17 <FliPPeh> I somehow like parantheses
09:25:00 <EvilTerran> ClaudiusMaximus, i forget, i was just giving something with the same semantics as what was in the paste
09:25:00 <Saizan> ?hoogle PortNumber
09:25:00 <lambdabot> No results found
09:26:06 <jmcarthur_work> afaik, PortNumber is an instance Num
09:26:59 <quicksilver> ClaudiusMaximus: that's right.
09:27:09 <quicksilver> ClaudiusMaximus: and by calling fromIntegral explicitly, EvilTerran is using the Num instance.
09:27:24 <quicksilver> (PortNumber 42) is the same as (PortNumber . fromIntegral $ 42)
09:27:41 * quicksilver thinks that through for a moment
09:27:46 <quicksilver> hang on that's rubbish
09:27:53 <quicksilver> this is the constructor you're not supposed to use, isn't it?
09:27:59 <quicksilver> and it's a bug that it's exported.
09:28:10 <Saizan> no
09:28:15 <Saizan> PortNumber is fine
09:28:16 <lilac> if so, i have some code to fix...
09:28:21 <Saizan> it's a constructor of PortID
09:28:33 <haonan> could someone help me out with a question ? http://www.nabble.com/help-with-a-question-td23946402.html
09:28:33 <Saizan> the constructor of the type PortNumber shouldn't be used, instead
09:28:34 <jmcarthur_work> not a bug, but just fromIntegral should work, shouldn't it?
09:28:53 <quicksilver> Saizan: Ah, thanks.
09:29:01 <Saizan> PortID is not an instance of Num either
09:29:06 <quicksilver> Saizan: I knew there was one constructor you're not supposed to use ;)
09:29:09 <jmcarthur_work> ah!
09:29:17 <quicksilver> type + constructor with same name
09:29:21 <quicksilver> (but not being the same type)
09:30:55 <lilac> haonan: i think your solution to (1) is wrong
09:31:15 <haonan> wrong?
09:31:29 <Axman6> i do too
09:31:32 <lilac> haonan: well, for a start, what's as and at? :)
09:31:43 <Axman6> considering as and at aren't defined anywhere
09:32:19 <Axman6> haonan: also, just for convention's sake, you might consider using xss@(x:xs) and yss@(y:ys)
09:32:21 <lilac> haonan: also, with the as and at corrected to be xs and xt, this appears to only work if the two lists are in the same order
09:32:43 <lilac> haonan: are you aware of the 'elem' function?
09:32:52 <lilac> > 4 `elem` [1,2,3,4,5]
09:32:54 <lambdabot>   True
09:32:55 <haonan> axman6: noted
09:32:59 <lilac> > 10 `elem` [1,2,3,4,5]
09:32:59 <haonan> nope i'm not
09:33:01 <lambdabot>   False
09:33:06 <lilac> you might find it useful.
09:33:35 <haonan> ah alright
09:33:49 <Axman6> hmm, i'm confused what should happen if say 1 is in both lists, and is in one list more than once
09:34:15 <haonan> question 1 ??
09:34:21 <Axman6> yes
09:34:52 <Badger> :t elem
09:34:53 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
09:34:57 <haonan> i haven't gt a single clue. i only got on to haskell yesterday and i'm not particularly strong in programming
09:35:13 <Axman6> haonan: yeah i'm struggling with it too ;)
09:35:44 <lilac> haonan: ok. your answer for question 1 is close, but not quite right
09:36:05 <haonan> lilac: yup i figured out that one with some help here. thanks
09:36:14 <haonan> now need major help with question 2 haha
09:36:53 <Axman6> > let interset xs ys = filter (`elem` ys) xs in linterset [1,2,3] [1..10]
09:36:54 <lambdabot>   Not in scope: `linterset'
09:36:58 <Axman6> > let interset xs ys = filter (`elem` ys) xs in interset [1,2,3] [1..10]
09:37:00 <lambdabot>   [1,2,3]
09:37:04 <Axman6> > let interset xs ys = filter (`elem` ys) xs in interset [1,2,3] [2..10]
09:37:05 <lilac> > let intersect [] ys = []; intersect xs [] = xs; intersect xs@(x:xt) ys@(y:yt) = if x == y then x:intersect xt yt else intersect xt ys  in  intersect [1,2,3] [3,2,1]
09:37:05 <lambdabot>   [2,3]
09:37:07 <lambdabot>   [3]
09:37:19 <lilac> haonan: when the question says 'set', what does it mean?
09:37:25 <Saizan> haonan: have you been exposed to list comprehensions?
09:37:40 <Axman6> > let interset xs ys = filter (`elem` ys) xs in interset [1,2,3] []
09:37:41 <lambdabot>   []
09:37:55 <haonan> A = { x, y , z} ?
09:38:28 <Axman6> haonan: we're helping you with question 1 because it's more fundamental to your learning. imo, questions 2 is just annoying
09:38:37 <lilac> haonan: by 'set' do you just mean a list, or do you mean a list with no duplicates, or do you mean a sorted list with no duplicates, or do you mean something else?
09:38:40 <haonan> mm ok
09:38:47 <haonan> just a list
09:39:14 <lilac> what should 'intersect [1,1,1] [1,1]' return?
09:39:29 <haonan> hold on
09:39:57 <Axman6> > let interset xs ys = filter (`elem` ys) xs in interset [1,1,1] [1,1]
09:39:58 <lambdabot>   [1,1,1]
09:40:07 <Axman6> > let interset xs ys = filter (`elem` ys) xs in interset [1,1] [1,1,1]
09:40:09 <lambdabot>   [1,1]
09:40:25 <Axman6> associativity fail :(
09:40:52 <haonan> it shld return [1,1]
09:40:55 <Saizan> that's commutativity
09:41:19 <Axman6> ah, yeah
09:41:28 <lilac> > let intersect xs ys = concat [[y | y <- ys, y == x] | x <- xs] in intersect [1,1,1] [1,1]
09:41:29 <lambdabot>   [1,1,1,1,1,1]
09:41:34 <lilac> > let intersect xs ys = concat [[y | y <- ys, y == x] | x <- xs] in intersect [1,1] [1,1,1]
09:41:36 <lambdabot>   [1,1,1,1,1,1]
09:41:55 <lilac> haonan: what about 'intersect [1,1] [1,1,1]'?
09:42:23 <haonan> same
09:42:28 <haonan> [1,1]
09:43:09 <Axman6> Saizan: what's aqssociativity again? (should really know this by now, i've learnt it enough times)
09:43:42 <lilac> Axman6: associativity means x * (y * z) == (x * y) * z
09:43:52 <Axman6> ah yes, right
09:44:49 <paolino> what is needed on windows to run a gtk2hs application ?
09:45:12 <haonan> hmm
09:46:18 <haonan> i think i'll come back again tml for help. it's past midnight here and i'm too sleepy to do this
09:46:40 <haonan> thanks guys
09:47:23 <Axman6> night
09:49:09 <andrewsw> I have two noob IO questions, 1) when doing `readFile somefile >>= putStr` what really goes on in the background?
09:49:28 <andrewsw> does it just stream the whole file through or are there readLine's going on in there somehow?
09:50:08 <jmcarthur_work> @src readFile
09:50:09 <lambdabot> readFile name = openFile name ReadMode >>= hGetContents
09:50:19 <jmcarthur_work> @src hGetContents
09:50:20 <lambdabot> Source not found. Where did you learn to type?
09:50:26 <jmcarthur_work> grr
09:50:46 <jmcarthur_work> well, if you look at the source you will see some unsafeInterleaveIO and stuff
09:50:51 <andrewsw> heh...
09:50:57 <andrewsw> whoosh
09:51:04 <vegai> andrewsw: try reading a 100GB file :P
09:51:06 <jmcarthur_work> :t unsafeInterleaveIO
09:51:07 <lambdabot> Not in scope: `unsafeInterleaveIO'
09:51:14 <jmcarthur_work> :t System.IO.Unsafe.unsafeInterleaveIO
09:51:15 <lambdabot> forall a. IO a -> IO a
09:51:16 <lilac> andrewsw: what really happens is that readFile returns you a magic list
09:51:32 <andrewsw> okay, I see.
09:51:35 <andrewsw> more or less.
09:51:38 <lilac> andrewsw: when you try to look at later elements of that list, more of the file is read in and cached
09:51:49 <dcoutts> paolino: just the gtk dll files
09:51:51 <jmcarthur_work> unsafeInterleaveIO basically means take an IO action and give me a value that, when evaluated in pure code, executes the action
09:51:52 <jmcarthur_work> lazy IO
09:52:15 <lilac> andrewsw: thus it's important that you operate on the list in such a way that you don't keep references to earlier bits
09:52:29 <dcoutts> paolino: are you trying to distribute a gtk2hs program for systems that don't have ghc or gtk installed?
09:52:33 <lilac> (otherwise you will end up with the whole file in memory as a [Char], and that can be pretty bug)
09:52:42 <lilac> *big
09:52:45 <dcoutts> paolino: for a demo of that, see http://haskell.org/~duncan/gtk2hs/LSystemSetup.exe
09:52:48 <andrewsw> lilac: got it thanks
09:53:03 <andrewsw> now 2) I want to filter that stream, and I'm having small troubles with it
09:53:18 <alinp> Hi
09:53:38 <lilac> andrewsw: what sort of troubles?
09:53:42 <andrewsw> I'm thinking I need to readFile someFile >>= someFunction :: String -> IO()
09:54:19 <alinp> I'm not a mathematical person, what book can be recomanded ?
09:54:28 <alinp> ofc, Haskell book
09:54:42 <Axman6> real world haskell?
09:54:52 <alinp> Axman6: yes, been there
09:54:52 <lilac> andrewsw: minor point, :: has really low precedence, that should be readFile someFile >>= (someFunction :: String -> IO ())
09:54:53 <Axman6> or learn you a haskell maybe?
09:54:57 <alinp> somethingelse ?
09:54:58 <MyCatVerbs> alinp: the two favourite ones are RWH and LYAH.
09:54:59 <paolino> dcoutts: thanks , but I don't have a windows running machine
09:55:01 <MyCatVerbs> @where lyah
09:55:01 <lambdabot> www.learnyouahaskell.com
09:55:10 <lilac> andrewsw: but yes, that's essentially right
09:55:42 <alinp> the reason why I'm asking that is because there are a lot of cathegory theory concepts
09:55:50 <alinp> Functors, Monoids, Monads .. etc
09:55:52 <andrewsw> lilac: yeah, just trying to describe what I'm doing. Basically, I want to drop some of the lines that come through using, I assume filter (predicate) <input from readFile here>
09:55:57 <paolino> dcoutts: I was asking just to know for casual users if it is a pain or not
09:56:00 <alinp> and it seems that they are explained in a mathematical way
09:56:02 <lilac> alinp: for those, the typeclassopedia is pretty good
09:56:04 <alinp> which I can't handle
09:56:13 <lilac> @where typeclassopedia
09:56:14 <lambdabot> I know nothing about typeclassopedia.
09:56:17 <lilac> @where typeclassopaedia
09:56:18 <lambdabot> I know nothing about typeclassopaedia.
09:56:39 <lilac> andrewsw: do you know about the 'lines' and 'unlines' functions?
09:56:56 <lilac> > lines "hello world\nline 2\ngoodbye"
09:56:57 <lambdabot>   ["hello world","line 2","goodbye"]
09:57:00 <alinp> ok, I'll give them a try
09:57:04 <alinp> thanks guys
09:57:30 <MyCatVerbs> http://www.haskell.org/haskellwiki/The_Monad.Reader <- Issue 13 includes the Typeclassopedia.
09:57:44 <andrewsw> lilac: yeah, I'm doing some version of:
09:57:48 <alinp> MyCatVerbs: RWH = ? and LYAH = ?
09:57:59 <alinp> ah, LYAH = Learn Yourself ..
09:58:04 <lilac> alinp: Real World Haskell, Learn You A Haskell (For Great Good)
09:58:05 <alinp> but RWH ?
09:58:08 <alinp> ah, ok
09:58:22 <andrewsw> lilac: removeTarget target = putStr =<< (\x -> filter (contains target) (lines x))
09:58:28 <MyCatVerbs> alinp: RWH is "Real World Haskell", LYAH is "Learn You A Haskell (For Great Good)". Neither have any chunky bacon in them, IIRC.
09:58:30 <andrewsw> lilac: but having little success with various permutations
09:58:59 <alinp> MyCatVerbs: ok, thanks but I don't really like RWH
09:59:11 <alinp> why is that ? because it's not what I want
09:59:19 <paolino> dcoutts: with wine the program doesn't show well :), but it was very easy
09:59:24 <alinp> it's too real .. if I may say so
09:59:35 <alinp> LYAH I think is better
10:00:06 <MyCatVerbs> alinp: Hrmn, thank you for the anecdote.
10:00:38 <alinp> :)
10:00:54 <alinp> sorry, I didn't wanted to sound like this
10:01:40 <alinp> but the thing is that I don't consider RWH to be too good organised
10:01:53 <alinp> it gives me different concepts without knowing them
10:02:25 <lilac> andrewsw: ok, well that particular formulation won't work because the RHS is a function, so it'll be in the wrong monad
10:02:29 <alinp> I need to read few more chapters in order to get any idea about 1st chapter concepts
10:02:42 <MyCatVerbs> Hrmn.
10:02:52 <MyCatVerbs> alinp: don't apologise, feedback is useful. :)
10:03:13 <lilac> andrewsw: you don't want to combine two things in the IO monad here, so you don't need (>>=)
10:03:16 <andrewsw> oh yeah, duh, I think...
10:03:24 <andrewsw> lilac: on the function part
10:03:26 <alinp> In fact RWH is pretty ok ... pretty practical, but I can't follow it
10:03:46 <alinp> like I said, few concepts are introduced too soon, without knowing what they mean
10:03:51 <andrewsw> lilac: I really want to take the output of the removeTarget function and just print it
10:03:54 <Axman6> yeah, i do think that RWH needs another revision
10:04:17 <alinp> I don't know if is ok, but Monads are a very important concept in haskell
10:04:17 <andrewsw> lilac: but the input to that function is an IO String and I'm a lost noob
10:04:24 <alinp> if not maybe the most
10:04:42 <alinp> and should be very well explained, at least in that RWH
10:04:56 <lilac> andrewsw: you want removeTarget to be the someFunction you mentioned above
10:05:02 <lilac> andrewsw: so it's :: String -> IO ()
10:05:13 <andrewsw> lilac: yes
10:05:20 <lilac> andrewsw: that is, its argument is just a String, not an IO String
10:05:25 <alinp> haskellwiki is pretty good, but some times too much mathematics for me
10:05:28 <andrewsw> lilac: right, I follow
10:05:54 <alinp> and I'm starting too feel sorry that I wasn't paying atention to mathematics in highschool/university
10:06:14 <andrewsw> lilac: hence I'm doing: readFile someFile >>= removeTarget (and I"ve hard coded the target despite my previous post)
10:07:02 <alinp> anyone knows when "Coming soon" of Monads and rest of concepts from LYAH will be ?
10:07:10 <lilac> andrewsw: ok, so you'll have something like 'removeTarget fileContents = putStr (something)'
10:07:16 <Botje> alinp: ask BONUS
10:07:22 <lilac> @seen BONUS
10:07:23 <Botje> but i'm guessing he's smack in the middle of exams atm
10:07:23 <lambdabot> BONUS is in #haskell. I last heard BONUS speak 8h 4m 20s ago.
10:08:17 <alinp> I think all current computer science world needs a practical explanation of monads & co.
10:08:22 <andrewsw> lilac: I think I got it!
10:08:28 <lilac> andrewsw: great!
10:08:46 <andrewsw> lilac: removeTarget = putStr . unlines . filter (contains "TARGET") . lines
10:08:59 <andrewsw> lilac: at least it compiles, that's sufficient right? heh
10:09:03 <lilac> andrewsw: right. and bonus marks for points-free style :)
10:09:27 <andrewsw> lilac: that's the part that was getting me... where does the '>>=" put stuff
10:09:51 <andrewsw> lilac: so I was thinking along the lines of points-free and ended up down the lambda hole somehow
10:10:10 <lilac> andrewsw: that's the key thing about monads; the RHS of >>= is just an arbitrary function that returns something in the monad
10:11:33 <andrewsw> lilac: yeah, I see now. Thanks for helping me through that. big light starting to glow there
10:11:50 <FliPPeh> Just out of couriosity, why do I have to use liftIO inside of StateT?
10:11:52 <FliPPeh> :)
10:11:52 <lilac> andrewsw: incidentally, it's considered good style to separate the 'pure' parts of your code from the 'monadic' parts, as in...
10:11:59 <FliPPeh> curiousity?
10:12:02 <FliPPeh> Bad word
10:12:04 <FliPPeh> I hate it.
10:12:17 <byorgey> curiosity, only one u and one o =)
10:12:27 <FliPPeh> :D
10:12:34 <FliPPeh> Saved.
10:12:45 <lilac> andrewsw: readFile "foo" >>= putStr . removeTarget "TARGET" where removeTarget target = unlines . filter (not . contains target) . lines
10:13:02 <byorgey> FliPPeh: it's because the types would not match otherwise.  You can't sequence a StateT s IO  action with an IO action because they have not the same type.
10:13:14 <FliPPeh> :t liftIO
10:13:15 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
10:13:19 <byorgey> FliPPeh: liftIO is for 'lifting' IO actions into  StateT s IO  actions which don't modify the state.
10:13:23 <lilac> andrewsw: here, removeTarget :: String -> String -> String (no IO involved)
10:13:39 <andrewsw> lilac: yeah, i wondered about that a bit. and nice catch that my function didn't do what it said... heh
10:13:42 <byorgey> well, as you can see, it's actually more general than that, it works for any monad which is an instance of MonadIO
10:13:46 <FliPPeh> Okay, thanks :)
10:13:49 <byorgey> but StateT s IO is such a monad
10:14:01 <FliPPeh> So it's just a bridge?
10:14:24 <lilac> andrewsw: incidentally, do you know about 'do' notation?
10:14:36 <hatds> why isn't there a hGetLine for lazy ByteStrings?
10:14:59 <andrewsw> lilac: a little bit. I use it when I see something that is clearly imperative like:
10:15:01 <byorgey> FliPPeh: more like a box.  If you're going to ship your cat somewhere you have to put it in a box first, since cats are not stackable
10:15:15 <FliPPeh> If you train them right..
10:15:21 <FliPPeh> You might aswell stack them :)
10:15:27 <byorgey> well, the analogy breaks down I guess =)
10:15:59 <andrewsw> lilac: updateFile line = do print "updating file
10:16:00 <FliPPeh> http://www.craftycrafty.tv/stackablecats_shop.jpg
10:16:05 <FliPPeh> See, stackable
10:16:18 <byorgey> hahaha
10:16:24 <andrewsw> lilac:   appendFile someFile line
10:16:35 <andrewsw> lilac:  or something like that
10:17:21 <byorgey> FliPPeh: but anyway, yes, liftIO is just for translating from the IO-world to the m-world where m is essentially any monad built by stacking transformers on top of IO
10:17:36 <lilac> andrewsw: right. your case might read more clearly as: do { contents <- readFile "foo"; putStr (removeTarget "TARGET" contents) }
10:17:50 <FliPPeh> ;)
10:17:54 <FliPPeh> Okayyy
10:18:06 <lilac> andrewsw: however, if you're a fan of point-free form, you'll probably like the >>= version more...
10:18:06 <FliPPeh> I'm making great progress in Haskell
10:18:08 <FliPPeh> [19:16:44] <@FliP^2eH> !uptime
10:18:08 <FliPPeh> [19:16:44] <+LambdaZero> I've been running for 8m 4s.
10:18:09 <FliPPeh> Worky!
10:18:19 <byorgey> =D
10:18:39 <andrewsw> lilac: I'm not necessarily a fan of points-free but for some idioms it just seems right to me
10:18:53 <andrewsw> lilac: this filtering of a file is jsut the sort of thing that fits it, in my opinion
10:19:12 <lilac> andrewsw: well, i'm with you on that. sometimes it's helpful to think of the process, sometimes it's helpful to think of the data
10:19:13 <FliPPeh> > getClockTime
10:19:14 <lambdabot>   Not in scope: `getClockTime'
10:19:16 <FliPPeh> ;O
10:19:24 <andrewsw> lilac: if only because it *looks* like it's filtering something through a funnel
10:19:31 <FliPPeh> > :m System.Time
10:19:32 <lambdabot>   <no location info>: parse error on input `:'
10:19:34 <FliPPeh> :d
10:20:01 <FalconNL> Does anyone know if 480.000 Array lookups are supposed to take about a second? It seems kind of long to me.
10:20:13 <lilac> FalconNL: certainly sounds like a long time
10:20:55 <FalconNL> http://codepad.org/qe1ieCLt
10:21:14 <FliPPeh> Hey, new Fedora is out
10:21:16 <FalconNL> I can't see what's supposed to be taking this long
10:21:20 <FliPPeh> Sticking to Arch Linux, tho
10:21:26 <FliPPeh> I wonder if there are many linuxers here?
10:21:28 <andrewsw> lilac: all this just to write a simple todo after seeing http://www.reddit.com/r/programming/comments/8nv63/ask_proggit_how_do_you_todo/
10:21:46 <thoughtpolice> FliPPeh: plenty :)
10:21:48 <andrewsw> lilac: great excuse to learn some haskell
10:21:54 <andrewsw> lilac: anyways, thanks a ton
10:22:13 <MyCatVerbs> andrewsw: to learn a Haskell.
10:22:21 <MyCatVerbs> andrewsw: (for great good!)
10:22:27 <andrewsw> MyCatVerbs: my bad, I knew that ;-P
10:22:32 <Badger> @where lyah
10:22:33 <lambdabot> www.learnyouahaskell.com
10:22:41 <FliPPeh> Learn You A Haskell is great :(
10:22:42 <FliPPeh> :)
10:22:50 <FliPPeh> Should add monads
10:23:04 * Badger looks slyly at BONUS 
10:25:07 <lilac> FalconNL: interpreted in ghci, it takes 12s on my fast machine and 40s on my slow machine to read 500000 entries from a 1000000 entry array
10:25:32 <lilac> andrewsw: no problem
10:25:42 <FliPPeh> I wonder how stable my Bot is
10:26:00 <FliPPeh> My previous ones in the first days all died because of string parsing failures
10:26:50 <FalconNL> lilac: hm. I don't suppose you know another list-like data type with fast random access? I tried Vector, but the type inference seems to hate it.
10:28:35 <paolino> dcoutts: do I need a local windows machine to make an installer like LSystem ?
10:29:25 <MyCatVerbs> FalconNL: there's Data.Sequence.
10:29:57 <lilac> i don't understand reddit. isn't there supposed to be a link on which people are commenting?
10:30:17 <FalconNL> MyCatVerbs: sadly, the elements are non-unique
10:30:22 <jmcarthur_work> lilac, you can also do a self link which is solely for comment threads
10:30:22 <ray> sometimes they're "self" posts
10:30:28 <ray> and there's no link, just a title
10:30:38 <andrewsw> it's just an "ask proggit" thing
10:30:44 <ray> it can get a bit stupid though
10:31:05 <ray> well it's not that there's no link exactly, but the link is to the reddit post itself
10:32:07 <lilac> so it's like taking the fixed point of commenting?
10:32:28 <ray> it's the fixed point of something
10:33:24 <dcoutts> paolino: you might be able to run InnoSetup under Wine
10:33:27 <lilac> FalconNL: well, array should be the go-to type for that sort of thing.
10:33:55 <FalconNL> lilac: That was my thought too, but I assumed it would be faster in ghci
10:33:56 <malouin> So who releases the haskell report?  Is there a haskell standards body, or something like the perl foundation for haskell, or is it individuals?
10:34:14 <ray> is it considered bad form to use Data.Set for the implicit sorting?
10:34:23 <ray> i'm thinking yes (but doing it anyway)
10:34:26 <mauke> ray: no
10:34:44 <ray> i'd figure the implicit uniqueness is ok though
10:36:22 <lilac> FalconNL: compiled with -O9 using GHC 6.8.2 it takes 3.5 seconds here :-/
10:37:05 <mauke> -O9? stop making up options
10:37:05 <lilac> ray: the Ord constraint and element ordering is all explicit in the Set contract, so I think it's fine
10:37:34 <burp> lol
10:37:48 <lilac> mauke: what's with the attitude? -O9 is fully documented
10:37:58 <mauke> oh, is that new in 6.8?
10:38:10 <lilac> mauke: -O<n> Set optimization level <n>
10:38:19 <ray> it's not like i'm doing a sort with toList . fromList or anything silly like that
10:38:20 <FalconNL> lilac: the sample I posted on codepad runs in 0-15 ms when compiled with O2 on GHC 6.10.2
10:38:34 <lilac> mauke: looks like 9 is equivalent to 2, but i don't see that's a problem...
10:39:11 <hatds> can one convert between ByteStrings and Lazy.ByteStrings?
10:39:18 <mauke> lilac: where does it say 9 is equivalent to 2?
10:39:23 <thoughtpolice> hatds: convert I believe
10:39:41 <lilac> mauke: it doesn't. but it says various things are implied by -O2
10:39:45 <thoughtpolice> hatds: ah no wait
10:39:48 <thoughtpolice> hatds: http://hackage.haskell.org/packages/archive/bytestring/0.9.1.4/doc/html/Data-ByteString-Lazy.html#v:fromChunks
10:39:51 <thoughtpolice> ^^ that's what you want
10:40:18 <mauke> lilac: I think 6.8 did make -O<n> for n > 2 equivalent to -O2, but in older GHCs it was worse than -O1
10:40:25 <thoughtpolice> hatds: essentially a lazy bytestring is just a set of strict bytestrings, hence toChunks/fromChunks for conversion
10:40:27 <mauke> but not quite -O0
10:41:05 <lilac> mauke: well, i appreciate the history lesson :)
10:59:02 <FliPPeh> If I want to parse very simple configuration files with key/value pairs like NAME="Santa", is parsec suitable?
10:59:14 <FliPPeh> I want a result like ("NAME", "Santa")
10:59:17 <FliPPeh> Tuple
10:59:40 <Lemmih> Yes.
10:59:59 <Lemmih> You could also do it without parsec.
11:00:13 <FliPPeh> I fear of those whitespace interferences
11:01:46 <Saizan> do you allow " in values or not?
11:01:56 <FliPPeh> I won't
11:02:02 <FliPPeh> Not right now
11:02:02 <MyCatVerbs> map (second tail . span (/='=')) . lines $ "NAME=Santa\nNOSE=red\nMOOD=jovial\n"
11:02:08 <MyCatVerbs> > map (second tail . span (/='=')) . lines $ "NAME=Santa\nNOSE=red\nMOOD=jovial\n"
11:02:09 <lambdabot>   [("NAME","Santa"),("NOSE","red"),("MOOD","jovial")]
11:02:32 <FliPPeh>  > map (second tail . span (/='=')) . lines $ "NAME=Santa\nNOSE=red\nMOOD=  jovial\n"
11:02:37 <FliPPeh> > map (second tail . span (/='=')) . lines $ "NAME=Santa\nNOSE=red\nMOOD=  jovial\n"
11:02:38 <lambdabot>   [("NAME","Santa"),("NOSE","red"),("MOOD","  jovial")]
11:02:40 <FliPPeh> Bad spaces
11:02:46 <MyCatVerbs> Heehee. :3
11:03:34 <FliPPeh> Some time later I will consider adding "" for strings and quoteless for numbers
11:03:41 <FliPPeh> But I don't see much use for this right now
11:03:50 <FliPPeh> As only I use it and I know how to not-break it :)
11:04:21 <Saizan> it's also easy to trim spaces
11:04:27 <FliPPeh> Thought so
11:09:29 <FliPPeh> @src second
11:09:30 <lambdabot> Source not found. You untyped fool!
11:09:48 <FliPPeh> > map (tail . span (/='=')) . lines $ "NAME=Santa\nNOSE=red\nMOOD=  jovial\n"
11:09:49 <lambdabot>   Couldn't match expected type `[a]'
11:09:54 <FliPPeh> > map (second tail . span (/='=')) . lines $ "NAME=Santa\nNOSE=red\nMOOD=  jovial\n"
11:09:55 <lambdabot>   [("NAME","Santa"),("NOSE","red"),("MOOD","  jovial")]
11:09:56 <FliPPeh> :S
11:09:59 <FliPPeh> second = ?
11:10:01 <FliPPeh> :t second
11:10:02 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
11:31:37 <FliPPeh> > Just (takeWhile (/= '!') str) where str = "Test!String"
11:31:38 <lambdabot>   <no location info>: parse error on input `where'
11:32:05 <FliPPeh> > let str = "Test!String" in Just (takeWhile (/= '!') str)
11:32:06 <lambdabot>   Just "Test"
11:32:12 <FliPPeh> Why does it work here?
11:32:16 <FliPPeh> But no in my code?
11:32:47 <MyCatVerbs> FliPPeh: Can't tell you without seeing the code in question. hpaste?
11:32:50 <FliPPeh> Wait
11:32:52 <FliPPeh> Trying to cpoy
11:33:01 <FliPPeh> getUserDetails u = 	if '!' `elem` u
11:33:01 <FliPPeh>                       then (Just (takeWhile (/= '!') u), Just "dbg", Nothing)
11:33:01 <FliPPeh>                       else (Nothing, Nothing, u)
11:33:04 <FliPPeh> There we go
11:33:11 <FliPPeh> getUserDetails :: String -> (Maybe String, Maybe String, String)
11:33:15 <mauke> don't use tabs in the middle of lines :-(
11:33:29 <MyCatVerbs> @where hpaste
11:33:30 <lambdabot> http://hpaste.org/
11:33:38 <MyCatVerbs> For the love of hpaste, please use hpaste.
11:33:45 <FliPPeh> I will
11:33:45 <mauke> FliPPeh: Nothing :/: String
11:33:58 <FliPPeh> Oh wow
11:34:00 <FliPPeh> I'm stupid
11:34:14 <FliPPeh> Looking for the right error in the wrong place
11:34:16 <FliPPeh> Thanks
11:35:09 <FliPPeh> > let str = "Test!String@teeeeheee" in Just (takeWhile (/= '!') . (dropWhile (/= '@')) str)
11:35:11 <lambdabot>   Couldn't match expected type `a -> [GHC.Types.Char]'
11:35:26 <FliPPeh> > let str = "Test!String@teeeeheee" in Just takeWhile (/= '!') . dropWhile (/= '@') str)
11:35:27 <lambdabot>   <no location info>: parse error on input `)'
11:35:32 <FliPPeh> > let str = "Test!String@teeeeheee" in Just takeWhile (/= '!') . dropWhile (/= '@') str
11:35:33 <lambdabot>   Couldn't match expected type `(GHC.Types.Char -> GHC.Bool.Bool)
11:35:36 <FliPPeh> Meh
11:35:37 <FliPPeh> ghci time
11:39:04 <jeffersonheard_h> well, today is apparently weird bug day
11:47:22 <Taejo> anybody know what C function System.Process.runProcess uses? I'm trying to get it to run 'vim'
11:48:14 <Lemmih> The exec family, I think.
11:48:47 <quicksilver> fork and exec, under *nix, I believe
11:48:53 <quicksilver> something else under windows
11:49:23 <Taejo> quicksilver: I don't care hugely about Windows atm, tho I think it uses CreateProcess there
11:49:24 * Badger gives everyone a monkfish
11:50:08 <Badger> (disregard that, I etc. etc.)
11:50:27 <quicksilver> it's OK. An unsolicited monkfish is never unwelcome.
11:51:48 <Badger> heh.
11:52:09 <Badger> never leave autospeaking scripts on
11:52:21 <Lemmih> What's a monkfish? Is it similar to getting a hummer?
11:52:59 <Badger> Slightly cheaper.
11:53:11 <quicksilver> Not. It's just a fish. Unless there is some double entendre that has passed me by.
11:53:24 <MyCatVerbs> No, it's a tasty animal with firm, juicy flesh.
11:53:39 <MyCatVerbs> It's commonly used as a scampi substitute, but it's good stuff in its own right too.
11:54:16 <guenni_> hi, does cabal that ships with ghc 6.10.3 have problems with finding c libs?
11:54:29 <dcoutts> guenni: nope
11:55:14 <dcoutts> guenni: that doesn't mean it can do magic :-)
11:55:25 <guenni_> rather strange dcoutts , I tried to reinstall stuff when switching from 6.10.2
11:55:45 <guenni_> dcoutts: hdbc driver for isntance
11:55:55 <dcoutts> eg if you've got C libs that are not on the normal linker path then you'd have to tell Cabal about that
11:56:41 <guenni_> I can't figure out what I could have changed in my systems config,
11:56:58 <dino-> Taejo: What's it doing? I was able to run vim with import System.Process ... runCommand "vim" >>= waitForProcess
11:57:23 <dino-> But HSH  runIO "vim", not so much
11:57:53 <guenni_> dcoutts: just to be on the safe side, how do I do that on xp, ie tell cabal where the libs are?
11:58:35 <dcoutts> guenni: --extra-include-dirs --extra-lib-dirs
11:58:37 <guenni_> dcoutts: I noticed that gcc seems to be missing in 6.10.3
11:58:48 <guenni_> dcoutts: thx
11:58:59 <dcoutts> guenni_: it's there in the default windows installer
11:59:17 <Taejo> dino-: "Vim: Error reading input, exiting... Vim: Finished."
11:59:24 <dcoutts> guenni_: check in the dir where it's installed, it'll be there. It's used every time for assembling and linking.
12:00:08 <guenni_> dcoutts: yep, you're right, false alarm, sry
12:01:43 <Taejo> dino-: it looks like System.Cmd.rawSystem is what I need
12:23:18 <jmcarthur_work> wow this code to convert CamelCase to underscore_separated took me entirely too long to write
12:23:34 <mauke> spoj.pl?
12:25:03 <jmcarthur_work> wow i never heard of spoj.pl
12:25:11 <mauke> http://www.spoj.pl/problems/JAVAC/
12:26:22 <jmcarthur_work> i actually went the other direction than that
12:26:34 <jmcarthur_work> this would have been easier!
12:27:03 <Cale> > intercalate "_" . map (map toLower) . groupBy (\x y -> isUpper x && isLower y) $ "CamelCase"
12:27:05 <lambdabot>   "camel_case"
12:27:23 <Cale> hmm, maybe not the best way
12:27:24 <jmcarthur_work> > intercalate "_" . map (map toLower) . groupBy (\x y -> isUpper x && isLower y) $ "CamelXXCase"
12:27:26 <lambdabot>   "camel_x_x_case"
12:27:35 <jmcarthur_work> mine handled that too
12:27:39 <jmcarthur_work> camel_xx_case
12:27:46 <mauke> that's wrong
12:27:46 <Cale> Perhaps groupBy (\x y -> isLower y) $ "CamelCase"
12:28:08 <Taejo> a version of getEnv that returned IO (Maybe String) would be very nice
12:28:22 <Taejo> but since it's not there... time to learn how to catch exceptions
12:28:31 <Cale> > intercalate "_" . map (map toLower) . groupBy (\x y -> isLower y) $ "camelCase"
12:28:33 <lambdabot>   "camel_case"
12:29:03 <mauke> getenv def var = getEnv var `catch` (const $ return def)
12:29:30 <Cale> Since, for example...
12:29:34 <Cale> > groupBy (\x y -> isUpper x && isLower y) $ "camelCase"
12:29:36 <lambdabot>   ["c","a","m","e","l","Case"]
12:29:38 <Cale> which is wrong
12:29:51 <Cale> > groupBy (\x y -> isLower y) $ "camelCase"
12:29:53 <lambdabot>   ["camel","Case"]
12:30:20 <mauke> s/([A-Z])/_\l$1/g
12:30:25 <thoughtpolice> dcoutts: ping
12:30:26 <olsner> cool abuse of groupBy
12:30:37 <Cale> I don't consider it an abuse :)
12:30:37 <mauke> groupBy is meant to be abused
12:30:49 <dcoutts> thoughtpolice: pong
12:30:53 <jmcarthur_work> still doesn't handle camelXXCase properly
12:31:03 <Cale> jmcarthur_work: It doesn't?
12:31:04 <mauke> jmcarthur_work: your definition of "proper" is wrong!
12:31:15 <Cale> > groupBy (\x y -> isLower y) $ "camelXXCase"
12:31:16 <lambdabot>   ["camel","X","X","Case"]
12:31:17 <jmcarthur_work> camelURLCase
12:31:21 <Cale> Seems right to me.
12:31:23 <olsner> I wouldn't want to rely on groupBy using the head of the group to compare with
12:31:28 <jmcarthur_work> camel_u_r_l_case?
12:31:29 <Cale> olsner: I would.
12:31:37 <mauke> jmcarthur_work: yes
12:31:42 <jmcarthur_work> yuck!
12:31:44 <mauke> that just shows why camelCase sucks
12:31:56 <jmcarthur_work> why?
12:32:13 <dcoutts> Cale: so you want it to compare each element to the first in the group, or to compare runs, ie each to the previous in the group?
12:32:31 <Cale> dcoutts: I think we should have both, but the existing groupBy should be the first.
12:32:32 <olsner> seems to me that there should be an implicit demand for the condition to have pretty much the same properties as (==)
12:32:53 <Cale> dcoutts: There should also be a groupByAdj which compares pairs of adjacent elements
12:33:01 <dcoutts> Cale: I remember bumping into this issue when implementing the streamable groupby
12:33:02 <jmcarthur_work> olsner, you mean commutative? lists are ordered. i think we should be able to rely on ordering
12:33:18 <olsner> using the head of the group or using the adjacent element should be an undefined implementation detail of group, I think
12:33:19 <Cale> dcoutts: I think both of them are useful
12:33:34 <Cale> I really hate what's been done to nubBy recently.
12:33:35 <dcoutts> Cale: and the nub/nubBy issues is similar right?
12:33:37 <Cale> yeah
12:33:45 <jmcarthur_work> mauke, why does this mean camel case sucks?
12:33:48 <Cale> We should be able to rely on its behaviour
12:33:53 <mauke> because it can't represent underscore_URL_separated identifiers
12:33:55 <dcoutts> Cale: wasn't that fixing things so nub = nubBy (==)
12:33:58 <jmcarthur_work> yes it can
12:34:01 <olsner> jmcarthur_work: actually, I would also expect it to work the same if it groups backwards
12:34:05 <jmcarthur_work> underscoreURLSeparated
12:34:08 <jmcarthur_work> it's unambiguous
12:34:12 <Cale> dcoutts: But in the process, they broke nubBy
12:34:20 <mauke> jmcarthur_work: underscore_u_r_l_separated
12:34:21 <dcoutts> Cale: perhaps it should be the other way around, but we must have nub = nubBy (==)
12:34:28 <Cale> yes, we should :)
12:34:30 <jmcarthur_work> mauke, your mental algorithm is wrong
12:34:32 <ray> underscoreUrlSeparated
12:34:36 <ray> and then you lose case information
12:34:47 <Cale> It wasn't nubBy's fault, it was the implementation of nub, as far as I can tell.
12:34:52 <jmcarthur_work> i managed to get my converter to work right...\
12:34:56 <Cale> nubBy in 6.8.3 was correct.
12:35:01 <mauke> jmcarthur_work: well, how do you turn underscore_u_r_l_separated into camel case?
12:35:16 <ray> _ separated things can have case information, but can't have _s
12:35:19 <dcoutts> Cale: send in some QC tests to specify the behaviour. I remember being somewhat disappointed that the list lib functions are not that well specified. Eg the generic ones do not always match the specialised ones.
12:35:45 <Cale> dcoutts: Okay, but on the mailing list, I gave a mathematical definition of the behaviour I want them to have.
12:35:46 <jmcarthur_work> mauke, oh i see what you mean now. but when would you ever write something like that in underscore notation anyway?
12:35:47 <Zao> Some camel standards encourage camelUrlCase.
12:35:55 <dcoutts> Cale: eg when doing the stream versions I noticed that genericTake is not the same as take, or perhaps it was drop.
12:36:09 <Zao> As a capital letter unambigiously maps to a _ then, it's all fine.
12:36:51 <mauke> jmcarthur_work: struct spork_c_style { ... };
12:37:00 <Cale> dcoutts: An easy way to check if you have it right for nubBy is the implementation of primes
12:37:06 <jmcarthur_work> sporkCStyle still seems okay to me though
12:37:21 <mauke> visually clashy, but you're right, I suppose
12:37:30 <Cale> nubBy (\x y -> y `mod` x == 0) [2..]  should be the list of primes
12:37:54 <mauke> let's see if I have x_x_x_x identifiers anywhere
12:38:12 <FliPPeh> Using StateT, is there a way to get all of my state data, or do I have to "gets" each of them as single?
12:38:44 <mauke> FliPPeh: lol wut
12:38:52 <FliPPeh> wat wat
12:38:57 <jmcarthur_work> FliPPeh, what do you mean? if you have a record as your state then get should return the entire thing anyway
12:39:15 <mauke> FliPPeh: 'get', but even if you only had 'gets', it's just 'gets id'
12:39:16 <FliPPeh> okay!
12:39:59 <dirk_> me for example
12:40:51 <mauke> move_x_y_origin
12:42:50 <jmcarthur_work> mauke, arguably, the x and y there aren't necessary anyway
12:43:12 <jmcarthur_work> could be replaced with 2d or something
12:43:34 <jmcarthur_work> and even so, moveXYOrigin is still readable
12:43:43 <jmcarthur_work> move_xy_origin would mean the same thing to me
12:44:25 <jmcarthur_work> anyway, i'm tired of meaningless syntactical debate, and I accept that there are other valid opinions ;)
12:44:49 <dirk_> is there serialization in Haskell?
12:45:03 <jmcarthur_work> > show [1,2,3,]
12:45:04 <lambdabot>   <no location info>: parse error on input `]'
12:45:09 <jmcarthur_work> > show [1,2,3]
12:45:10 <lambdabot>   "[1,2,3]"
12:45:11 <jmcarthur_work> my bad
12:46:52 <dino-> I had a job a few years ago where they decided to start imposing coding style guidelines on the entire 300 person engineering division. A huge argument raged for a couple of weeks about whether or not to outlaw // style comments and force /* */ only.
12:47:22 <Cale> jmcarthur_work: I think that to convert between camelCase and underscores in a pretty way, human intervention is sometimes required.
12:47:41 <dino-> > read "[1,2,3]"
12:47:43 <lambdabot>   * Exception: Prelude.read: no parse
12:47:48 <jmcarthur_work> certainly to convert from underscores to camelCase
12:47:53 <dino-> > read "[1,2,3]" :: [Int]
12:47:54 <Cale> > read "[1,2,3]" :: [Integer]
12:47:55 <lambdabot>   [1,2,3]
12:47:55 <lambdabot>   [1,2,3]
12:48:05 <jmcarthur_work> since mauke has already show that the former is strictly more expressive
12:48:07 <jmcarthur_work> *shown
12:48:27 <Cale> (and more typing ;)
12:48:31 <jmcarthur_work> i think camelCase to underscore can be automated well enough though
12:48:38 <jmcarthur_work> heck, i just did it
12:48:50 <ray> aw heck
12:49:01 <jmcarthur_work> darn it all to heck
12:49:10 <_Jordan_> Is State both a type constructor (like Maybe) and a data constructor (like Just)?
12:49:14 <ray> > read "fromList [1,2,3]" :: Set Integer
12:49:16 <lambdabot>   Not in scope: type constructor or class `Set'
12:49:19 <dino-> I feel like the real struggle isn't camel/underscore, it's getting people to write good identifiers
12:49:25 <ray> g;fjd;lsj;lfs
12:49:25 <Cale> _Jordan_: yes
12:49:37 <jmcarthur_work> ray, that is unfortunate
12:49:39 <ray> that's a nice-looking read instance anyway
12:50:00 <_Jordan_> Cale: Thanks. So what is "runState" then?
12:50:01 <Cale> _Jordan_: There are two things called State in Control.Monad.State, one at the type level, and one at the value level. They're in different namespaces, so it doesn't hurt that they're named the same thing.
12:50:03 <jmcarthur_work> dino-, agreed
12:50:16 <jmcarthur_work> :t runState
12:50:17 <lambdabot> forall s a. State s a -> s -> (a, s)
12:50:20 <Cale> _Jordan_: runState is what you use to run a State monad computation with a given initial state.
12:50:22 <jmcarthur_work> that's runState :)
12:50:50 <jmcarthur_work> _Jordan_, if you are looking at the source for State, then runState is defined by using record syntax as a shortcut
12:51:04 <Cale> Given a computation, and an initial state, it results in a pair consisting of the result and final state.
12:51:19 <_Jordan_> alright, thanks
12:51:27 <_Jordan_> Yeah, I was wondering why it was defined with record syntax
12:51:31 <ray> the use of record syntax for defining runStuff certainly confused me for a while
12:51:32 <dino-> Also, some of our conventions in the big H are excellent. Like *M and *_ as in mapM_
12:51:38 <jmcarthur_work> yeah, that's just a handy shortcut
12:51:51 <Cale> _Jordan_: Simply because we're using a representation for State monad computations which allows that.
12:51:55 <jmcarthur_work> and unsafe*
12:52:03 <ray> then i converted it in my head to non-record-syntax, and it made sense
12:52:22 <Cale> _Jordan_: (basically, we define a State monad computation internally to be the function which will result when you apply runState to it)
12:52:41 <Cale> _Jordan_: If we were using a different implementation of the State monad, runState might be more complicated.
12:52:56 <_Jordan_> ah, I see
12:53:18 <Baughn> _Jordan_: (However, that's pretty much the most natural definition, and it's hard to think of alternatives)
12:53:22 <jmcarthur_work> some of the CPS transformer libraries might have more complicated state monads
12:53:25 <dino-> yes, unsafe*  hm: partialHead = head
12:53:56 <jmcarthur_work> dino-, i agree with you (maybe not on the actual prefix, but that there should be one)
12:54:08 <jmcarthur_work> but many functions are partial
12:54:12 <Cale> It's possible to define the State monad in a sort of dual way, using a GADT to represent the operations explicitly.
12:54:50 <Taejo> has the web hoogle stopped including hackage packages in its results?
12:54:56 <Taejo> @hoogle hmm
12:54:56 <Cale> (But GADTs are new to Haskell)
12:54:57 <lambdabot> package hmm
12:55:03 <jmcarthur_work> Taejo, try hayoo?
12:55:35 <Cale> Did anyone else go and implement that Hammurabi game after the blog post yesterday? :)
12:55:48 <Taejo> jmcarthur_work: I don't mean indexing the *contents* of the package. I meant <lambdabot> package hmm
12:55:59 <jmcarthur_work> ah
12:56:23 <Taejo> Cale: I found BASIC code, but I don't think the basic package supports multiple statements per line
12:56:30 <edwardk> hammurabi?
12:56:39 <Cale> Taejo: I implemented the game in Haskell.
12:56:45 <jmcarthur_work> the number guessing one?
12:56:47 <Cale> http://playtechs.blogspot.com/2009/06/messing-with-haskell.html
12:57:06 <Cale> It's not a number guessing game -- this guy mentioned the number guessing game though.
12:57:11 <jmcarthur_work> yeah, i did it too, but it wasn't impressively shorter... only about 40% shorter. i was sure i could do better
12:57:15 <jmcarthur_work> ah
12:57:20 <jmcarthur_work> i forget it now
12:57:48 <jmcarthur_work> well, i could have done better, but it would have been obfuscation
12:58:02 <jmcarthur_work> i think a lot of other haskellers think i am a fan of obfuscation already
12:58:10 <Cale> http://www.apollowebworks.com/russell/samples/hamurabi.html -- here's an implementation of the game he wanted to implement in Haskell.
12:58:14 <Taejo> it's only a few hundred lines of basic, but I think it has quite high semantics-to-syntax ratio
12:58:38 <Cale> Yeah, my Haskell implementation was still ~200 lines.
12:59:13 <harlekin> In the pdf's version of Programming with Arrows there are no pictures but the captions suggest there should be some. Is it available in some other format containing the figures?
12:59:17 <Cale> But I still feel unhappy about a bit of it. The I/O still isn't as separate as it could be
13:00:00 <Hunner> Why do I get `read' is not a (visible) method of class `Read'
13:00:12 <Hunner> when trying to define my own read for a data type?
13:00:19 <opqdonut> because it aint
13:00:25 <opqdonut> @info Read
13:00:25 <lambdabot> Read
13:00:25 <jmcarthur_work> Cale, ryan ingram always pushes his monadprompt stuff for separating IO from a stack, which seems to especially come up in games. i haven't tried it yet though
13:00:30 <opqdonut> @src Read
13:00:30 <lambdabot> class Read a where
13:00:30 <lambdabot>   readsPrec    :: Int -> ReadS a
13:00:30 <lambdabot>   readList     :: ReadS [a]
13:00:30 <lambdabot>   readPrec     :: ReadPrec a
13:00:30 <lambdabot>   readListPrec :: ReadPrec [a]
13:00:31 <Gracenotes> ..wha
13:00:33 <Cale> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5692#a5692 -- here's what I threw together, anyway :)
13:00:45 <Gracenotes> oh, yes. "read" is a utility
13:00:48 <Cale> jmcarthur_work: Yeah, the MonadPrompt way would be cool. I could have done that.
13:00:51 <Gracenotes> @src read
13:00:51 <opqdonut> Hunner: read is defined on top of readS
13:00:51 <lambdabot> read s = either error id (readEither s)
13:01:01 <Gracenotes> @src readEither
13:01:01 <lambdabot> Source not found. You type like i drive.
13:01:04 <Gracenotes> pssh.
13:01:16 <deech_> Hi all, I am having some difficulty processing XML with the HXT library. I have an XML document with an "Items" root node that contains many "Item" node. I would like process each of these in turn and collect the results into a list. Is there a map-like function in HXT?
13:01:26 <Cale> jmcarthur_work: I was actually just thinking about fixing up MonadPrompt to have decent Haddock documentation, and then implementing the MTL monads and maybe LogicT in terms of it.
13:01:36 <deech_> The closest I could find was processChildren and I can't figure out how it works.
13:01:51 <jmcarthur_work> woah mtl in terms of prompt? i didn't even think about that
13:02:18 <Cale> The next step after that would be to benchmark it.
13:02:25 <jeffersonheard_h> so....  would there be anyone out there interested in helping with the ongoing development of either Hieroglyph or Buster
13:02:32 <Gracenotes> hm. it does seem to be defined in terms of readPrec, though ... and in terms of readPrec_to_S...
13:02:40 <Hunner> okay, I'm not sure what to do with Read if I can't tell it how to read my string...
13:02:41 <Gracenotes> gawsh, the Haskell Read system is complicated
13:02:54 <opqdonut> Greit is
13:03:04 <Cale> I might expect a little bit of a hit in performance for the extra abstraction it affords, but internally, MonadPrompt uses a continuation passing style which I can imagine compiling to fairly efficient code, so I don't know.
13:03:17 <opqdonut> Hunner: http://haskell.org/ghc/docs/latest/html/libraries/base/Text-Read.html#t%3ARead <- read it up
13:03:22 <Hunner> Thanks
13:03:25 <jmcarthur_work> yeah that would be interesting to find out
13:03:38 <opqdonut> Hunner: "Minimal complete definition: readsPrec" is the most important part
13:04:01 <opqdonut> Hunner: you can basically ignore the Int parameter to readsPrec for simple stuff
13:04:11 <jmcarthur_work> wouldn't there be a lot of GADT going on to implement mtl in terms of prompt though? i can't imagine that would be free of overhead
13:04:13 <jeffersonheard_h> oh, and I've got a question about cabal: do you put stuff you need to be compiled and linked in, but not exposed in "extra source modules"
13:04:26 <jeffersonheard_h> source files, whatever
13:04:30 <Cale> jmcarthur_work: Well, there would be one GADT for each set of operations.
13:04:33 <Baughn> jeffersonheard_h: Yes
13:04:47 <jeffersonheard_h> Baughn, thanks
13:04:59 <jmcarthur_work> prompt essentially requires an interpreter
13:05:29 <Cale> jmcarthur_work: Yeah, representing operations as data is the part I thought might be expensive.
13:05:45 <Cale> The nice thing about it is that you can have multiple intepreters for the same computations then.
13:06:01 <jmcarthur_work> yeah
13:06:08 <jmcarthur_work> would be awesome
13:06:28 <Cale> And in fact, that's how the lifter from Prompt to PromptT works :)
13:06:45 <Taejo> was base-4 the first split up one? or base-3?
13:06:57 <Taejo> and what's a reasonable version range of container to depend on?
13:07:00 <Cale> (just run the computations with an interpreter that reapplies the prompt for PromptT to each primitive :)
13:07:38 <Cale> Taejo: I believe it started with 3
13:08:21 <Cale> Taejo: I'm not sure... there really ought to be a wiki page somewhere with a big table of the version numbers of packages that come with various GHCs...
13:08:24 <jmcarthur_work> Cale, do you think the MonadPrompt approach to MTL would basically replace the need for the MTL type classes, like MonadState, etc.?
13:08:27 <Cale> (but I don't think there is :)
13:08:45 <jmcarthur_work> since you can interpret the ops differently "on the outside"
13:08:59 <Taejo> Cale: indeed. I guess I'll just guess, until somebody tells me my program doesn't compile somewhere
13:09:11 <Cale> jmcarthur_work: Sort of, though you still will want a way to combine sets of operations and a corresponding way to combine interpreters for those.
13:09:42 <jmcarthur_work> yeah
13:09:46 <jmcarthur_work> it's just different
13:10:15 <Cale> I think I'll hack up a bit right now and see how it goes.
13:10:20 <jmcarthur_work> sweet
13:11:30 <Baughn> @type (>>=)
13:11:31 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
13:11:48 <jmcarthur_work> =<< > >>=
13:12:03 <Yokisho> @type mapM_
13:12:04 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
13:12:28 <sneep> Hi everyone, I'm experiencing a (probably really simple) problem... I was trying to write a function in Haskell that gets two arguments and tests if the first arg equals the first element of the second argument (which is a list)
13:12:34 <Taejo> why does containers-0.1.0.1 not satisfy container >=0.1 && <0.3
13:12:43 <sneep> My code (along with the error message I get) is here: http://pastebin.com/d619cfbd4
13:13:19 <Cale> sneep: The problem is that you use == which isn't defined for any type a
13:13:30 <Cale> sneep: Only for types a which are instances of the class Eq
13:13:45 <Cale> sneep: So you want  firsteq :: Eq a => a -> [a] -> Bool
13:14:18 <Cale> sneep: Another way to discover this is to comment out your type signature and ask hugs for what it infers
13:14:22 <Cale> :t firsteq
13:14:24 <lambdabot> Not in scope: `firsteq'
13:14:34 <sneep> Thanks, works now :D
13:14:48 <Taejo> d'oh, "container" /= "containers"
13:15:37 <Yokisho> ehms, functions overloaded?
13:16:04 <opqdonut> Yokisho: ?
13:16:19 <sinelaw> "Microsoft SQL Server 2008 and the Data Platform: Your Data, Any Place, Any Time"
13:16:23 <FliPPeh> Say I have a number, from 1 - 31, say it's a month, how would I append a zero in front of it, if it's below 10? 01, 02, 04, 10, ...
13:16:25 <sinelaw> heh, truly.
13:16:33 <sinelaw> YOUR data, any place, any time :)
13:16:35 <dino-> sneep: I might also replace some of your bindings with _
13:16:46 <Yokisho> opqdonut, http://pastebin.com/d619cfbd4
13:16:52 <sneep> Is _ in Haskell like _ in Prolog?
13:17:03 <sneep> (Anonymous variable)
13:17:07 <Yokisho> there are functions overloaded :S
13:17:11 <sneep> (Matches everything)
13:17:18 <Cale> sneep: _ is a pattern which matches anything and binds no variable
13:17:26 <sneep> If that thing about overloading was directed at me, I had the two functions in different files before... Forgot to rename them before submitting
13:17:30 <sneep> Ah, okay
13:17:37 <sneep> In Prolog it's the same :P
13:17:57 <opqdonut> Yokisho: the type of firsteq needs to be "Eq a => a -> [a] -> Bool"
13:18:00 <dino-> I don't know Prolog. Does it have pattern matching?
13:18:03 <opqdonut> Yokisho: like Calse said
13:18:05 <opqdonut> dino-: yes
13:18:34 <Yokisho> ahms, oops, sorry
13:18:35 <omer> its a programmers chat right?
13:19:09 <Cale> 。。。
13:19:28 <Cale> What is with these people who show up for 10 seconds and leave? :)
13:19:42 <FliPPeh> Dunno
13:19:55 <FliPPeh> So how do I smartly prepend numbers under 10 with one zero?
13:20:39 <tromp> > 0: show 6
13:20:40 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
13:20:40 <lambdabot>    arising from the literal `0...
13:20:45 <tromp> > '0': show 6
13:20:46 <lambdabot>   "06"
13:21:04 <opqdonut> there's printf for haskell but it isn't type safe
13:21:10 <dino-> tromp: Oh that's clever. I would have reached immediately for printf, yeah
13:21:18 <Cale> > printf "%2d" 6
13:21:20 <lambdabot>   Add a type signature
13:21:22 <Cale> > printf "%2d" 6 :: String
13:21:23 <lambdabot>   " 6"
13:21:28 <Cale> > printf "%02d" 6 :: String
13:21:29 <lambdabot>   "06"
13:21:46 <pastorn> > printf "%02d" 12 :: String
13:21:47 <lambdabot>   "12"
13:21:51 <pastorn> cool :)
13:22:00 <Cale> printf is pure evil though ;)
13:22:11 <dino-> We have that new TotalPrintf
13:22:11 <pastorn> Cale: howcome?
13:22:22 <dino-> from Oleg
13:22:24 <Yokisho> under 10 pastorn :P
13:22:35 <byorgey> dino-: tromp's code doesn't work for things over 9 though.
13:22:51 <Cale> pastorn: It doesn't check until runtime that the arbitrarily many arguments you've given it are the right types.
13:22:53 <pastorn> Yokisho: i just wanted to test that it didn' prepend the '0' if the number was > 10 :p
13:23:04 <dino-> byorgey: yes, but it's clever for that small set of numbers!
13:23:10 <Cale> pastorn: (by design, it couldn't possibly do so)
13:23:11 <byorgey> true =)
13:23:27 <Cale> Also, the format strings are arcane and convoluted.
13:23:29 <pastorn> Cale: how do you give a function an arbitrary amount of arguments?
13:23:44 <Cale> pastorn: By having its type be in a typeclass which includes function types as an instance.
13:24:10 <pastorn> so THAT'S how you do that
13:24:21 <dino-> ah, here it is: http://article.gmane.org/gmane.comp.lang.haskell.general/17251
13:24:27 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Text-Printf.html
13:24:28 <dino-> TotalPrintF
13:24:39 <Cale> You can see how the trick works there
13:24:41 <mauke> Text.Printf is actually completely H98 :-)
13:24:45 <pastorn> i had been thinking about doing a weird type class some weeks ago, but i had a deadline and din't bother to put my brain through that
13:24:47 <Cale> class PrintfType t
13:24:55 <Cale> IsChar c => PrintfType ([] c)
13:24:55 <Cale> PrintfType (IO a)
13:24:55 <Cale> (PrintfArg a, PrintfType r) => PrintfType (a -> r)
13:24:55 <Taejo> I just installed a package with the wrong name, how do I remove it (or rename it)?
13:25:05 <jmcarthur_work> Cale, well, it could do so with a dependently typed language of course, just not in haskell
13:25:10 <jmcarthur_work> type check, that is
13:25:14 <mauke> (the format strings are extremely convenient if you already know printf)
13:25:25 <byorgey> Taejo: ghc-pkg unregister ?
13:25:38 <Cale> jmcarthur_work: Not without changing the meaning of the thing.
13:25:56 <jmcarthur_work> what do you mean changing the meaning?
13:26:07 <Cale> jmcarthur_work: The thing about printf is that by design, the format string is a value given at runtime.
13:26:26 <Cale> jmcarthur_work: So there's no way to statically check that it's correct.
13:26:31 <Cale> (in general)
13:26:48 <jmcarthur_work> still could be checked in many cases. would just require horrible proofs
13:26:58 <FliPPeh> preZero i
13:26:58 <FliPPeh>       | i > 9     = show i
13:26:58 <FliPPeh>       | otherwise = '0': (show i)
13:26:59 <FliPPeh> :)
13:27:13 <Cale> preZero (-1)
13:27:20 <FliPPeh> Bam
13:27:23 <FliPPeh> You just broke my program
13:27:28 <FliPPeh> I hope you're happy :(
13:27:42 <Yokisho> @type SqlValue
13:27:43 <lambdabot> Not in scope: data constructor `SqlValue'
13:28:02 <byorgey>     | i < 0  = error "I HOPE YOU'RE HAPPY CALE"
13:28:07 <Cale> haha
13:30:12 <olsner> @paste
13:30:12 <lambdabot> Haskell pastebin: http://hpaste.org/new
13:30:18 <Baughn> conal: Is the Monoid instance for events diagonalizing mappend?
13:35:41 <pedro-kun> hi there
13:36:10 <pedro-kun> how can i make haskell programs properly display accented characters?
13:36:22 <mauke> define "properly"
13:36:31 <mauke> also, what's your environment?
13:36:38 <pedro-kun> the way it is now, i just get squares
13:36:45 <pedro-kun> define environment, please :)
13:36:48 <jmcarthur_work> Baughn, it merges the event streams by time
13:36:53 <mauke> where do you get squares?
13:37:10 <Baughn> jmcarthur_work: Yes, I got that
13:37:17 <pedro-kun> mauke: i do something like putStrLn "lalalala"
13:37:20 <pedro-kun> oops
13:37:24 <pedro-kun> "laáááá"
13:37:34 <pedro-kun> and I get "la" followed by 4 rectangles
13:37:40 <mauke> yes
13:37:45 <Baughn> jmcarthur_work: I'm wondering why, when I stick a trace-show on the event being joined in joinE (which calls mappend), I get them in diagonal order. Well, it makes sense though.
13:37:47 <jmcarthur_work> ah, i assumed that "diagonalizing" meant that it was more of a lifted mappend
13:37:52 <mauke> pedro-kun: where do you get them?
13:38:39 <pedro-kun> sorry, i don't understand... what do you mean by where? console output?
13:38:55 <Baughn> jmcarthur_work: Nope, I'm debugging joinE. It likes giving me bottoms instead of a maxBound when the event ends, which /ought/ to be a simple fix.. well, once I understand it anyhow.
13:38:56 <mauke> pedro-kun: using my psychic debugging skills, you're seeing them in a terminal emulator that expects UTF-8
13:39:13 <Baughn> jmcarthur_work: Had to detour for some days to fix a ghc bug first. (Well, wound up working around it..)
13:39:14 <pedro-kun> hmm, probably mauke
13:40:05 <mauke> pedro-kun: putStrLn is actually broken; it just truncates characters at 8 bits and then treats them as raw bytes
13:40:13 <Baughn> jmcarthur_work: I _will_ get reactive working, so I can learn to use reactive, so I can write my map editor, so I can play a game! *burning eyes*
13:40:36 <mauke> which is fine for ASCII and happens to work for Latin-1, but isn't going to work for UTF-8
13:40:39 <jmcarthur_work> Baughn, heh. i've been playing with reactive-style frp implementations for a while. it is tricky!
13:40:49 <pedro-kun> so, what do you recommend? :)
13:41:11 <mauke> http://hackage.haskell.org/packages/archive/utf8-string/0.3.5/doc/html/System-IO-UTF8.html
13:41:24 <pedro-kun> hmm
13:41:27 <pedro-kun> i'll go see :)
13:41:29 <pedro-kun> thanks
13:42:59 <mauke> the other places you could have seen squares: linux system console (no GUI), printing to a file and looking at it in some text editor, sending html to a browser from a web application, or using some GUI toolkit to draw your own text
13:43:25 <pedro-kun> oh, right
13:43:35 <pedro-kun> thanks for that, next time i'll know what to answer
13:43:40 <mauke> :-)
13:44:14 <pedro-kun> so, besides using utf8-string, i could just format the source code using latin1 and it would work too, right?
13:44:27 <mauke> no
13:44:41 <pedro-kun> why wouldn't it?
13:44:58 <mauke> why would it?
13:45:04 <Taejo> how do I tell Cabal I want a README file to be included in the cabal sdist?
13:45:07 <mauke> haskell strings are unicode
13:45:30 <mauke> your source representation of strings has to be turned into actual data; this is done by the compiler
13:45:31 <Saizan_> Taejo: extra-source-files
13:45:42 <mauke> ghc understands utf-8, so that part worked fine
13:46:04 <mauke> using latin-1 will either cause a decoding error or give the same result
13:46:33 <mauke> the problem is in the IO libraries, which don't properly encode the unicode strings before writing them out
13:47:14 <pedro-kun> oh, i see
13:47:26 <pedro-kun> i tried utf8-string now and it seems to work :)
13:47:28 <pedro-kun> thanks
13:48:41 <pedro-kun> i'm kinda new in haskell so i tend to have these strange doubts :p
13:48:48 <pedro-kun> *new to haskell
13:49:37 <pedro-kun> is there any way to have utf8-string's functions "replace" the standard ones?
13:49:54 <pedro-kun> or do i have to use them in a qualified form everytime?
13:50:04 <pedro-kun> (sorry if i'm making no sense at all)
13:50:15 <FliPPeh> I can't find any way to remove certain items from a list :S
13:50:19 <Saizan_> you can hide the standard ones
13:50:23 <FliPPeh> I think I'm stupid
13:50:27 * Baughn wishes there was a way to automatically add Show restrictions to type annotations
13:50:28 <pedro-kun> Saizan_: how do i do that?
13:50:39 <pedro-kun> import the prelude hiding them?
13:50:45 <Saizan_> yes
13:51:05 <ClaudiusMaximus> :t delete
13:51:06 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
13:51:54 <pedro-kun> Saizan_: thanks, it worked
13:51:56 <pedro-kun> :)
13:51:56 <Nereid_> FliPPeh: filter?
13:52:32 <FliPPeh> Filter works, too :)
13:52:51 <Nereid_> I guess delete x is the same as filter (/=x)
13:53:05 <ClaudiusMaximus> > delete 3 [1,1,2,2,3,3,4,4,5,5]
13:53:06 <lambdabot>   [1,1,2,2,3,4,4,5,5]
13:53:12 <Nereid_> nope
13:53:15 <Nereid_> only removes the first one
13:53:28 <Nereid_> filter (/=3) [1,1,2,2,3,3,4,4,5,5]
13:53:30 <Nereid_> > filter (/=3) [1,1,2,2,3,3,4,4,5,5]
13:53:31 <lambdabot>   [1,1,2,2,4,4,5,5]
13:54:00 <Nereid_> depends on which behaviour you want I guess
13:55:09 <ClaudiusMaximus> > deleteBy ((1==) . fst) [(1,"a"),(1,"b")]
13:55:10 <lambdabot>   Couldn't match expected type `(a, b) -> GHC.Bool.Bool'
13:55:37 <Cale> hmmmm
13:55:42 <ClaudiusMaximus> :t deleteBy
13:55:43 <lambdabot> forall a. (a -> a -> Bool) -> a -> [a] -> [a]
13:55:49 <Cale> I wonder if the lack of a RecPromptT is a fundamental limitation.
13:56:01 <Yokisho> :i Int
13:56:11 <ClaudiusMaximus> > deleteBy (comparing fst) (1,undefined) [(1,"a"),(1,"b")]
13:56:12 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
13:56:15 <Yokisho> O_o
13:56:19 <ClaudiusMaximus> doh
13:56:31 <mauke> > deleteBy ((==) `on` fst) (1,undefined) [(1,"a"),(1,"b")]
13:56:32 <lambdabot>   [(1,"b")]
13:56:49 <Taejo> how do I put quotes into a Cabal Description file? 'quoted text' gets turned into monospace
13:56:58 <mauke> \'
13:57:07 <Taejo> thank
13:57:12 <Taejo> *thanks, mauke
13:57:35 <mauke> (it's haddock markup)
13:57:57 <Taejo> ok
13:59:35 <Nereid_> :t comparing
13:59:36 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
13:59:41 <Nereid_> lol
14:00:29 <malouin> @source Plus
14:00:29 <lambdabot> Plus not available
14:00:55 <malouin> @source Eq
14:00:55 <lambdabot> Eq not available
14:00:59 <Cale> @src Eq
14:01:00 <lambdabot> class  Eq a  where
14:01:00 <lambdabot>     (==), (/=)   :: a -> a -> Bool
14:01:09 <malouin> thanks Cale
14:01:11 <Cale> @source Prelude
14:01:11 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
14:01:15 <malouin> @src Plus
14:01:15 <lambdabot> Source not found. My pet ferret can type better than you!
14:01:32 <Cale> What's Plus?
14:01:42 <malouin> that's what I'm trying to figure out.  It's a class.
14:01:44 <malouin> that's all I know.
14:01:52 <malouin> ran into it in some Formlets code
14:02:11 <jeff_s_> @src otherwise
14:02:12 <lambdabot> otherwise = True
14:02:18 <jeff_s_> oh, heh
14:02:19 <byorgey> maybe it's for doing type-level addition?
14:02:21 <Nereid_> there's no Plus in hoogle
14:02:21 <byorgey> malouin: link?
14:02:32 <malouin> http://chrisdone.com/blog/html/2008-12-14-haskell-formlets-composable-web-form-construction-and-validation.html
14:02:51 <malouin> label :: (X.HTML xml, Monad m, Plus xml) => String -> Form xml m a -> Form Html m a
14:03:42 <Nereid_> I'm guessing you should replace Plus with Monoid
14:03:49 <malouin> yay, it's HaXmL
14:04:03 <Nereid_> the source doesn't mention Plus, but it does show Monoid in that context
14:04:08 <malouin> or maybe I spoke to soon
14:04:40 <Cale> I think it's from the XML library
14:04:52 <Nereid_> malouin: if you look at the source, you will see
14:04:59 <Nereid_> label :: (X.HTML xml, Monad m,Monoid xml) => String -> Form xml m a -> Form Html m a
14:05:03 <Cale> xhtml rather
14:05:34 <Cale> hmm
14:05:49 <malouin> ok, s/Plus/Monoid/ seems to do what I want.
14:06:00 <malouin> Nereid_: what source particularly?
14:06:21 <Cale> Ah, there's a link to it
14:06:24 <Cale> http://chrisdone.com/blog/haskell/Main.hs
14:06:26 <byorgey> I can't seem to find Plus in xhtml, or any other xml library for that matter
14:06:37 <Cale> byorgey: Yeah, I didn't find it either.
14:06:59 <malouin> Nereid_: Nereid the polychaete ;)
14:07:03 <byorgey> oh, that file you linked to uses Monoid
14:07:06 <malouin> err ?;)
14:07:09 <Cale> yeah
14:07:12 <byorgey> that must be what it is
14:07:26 <byorgey> ah, Nereid_ was right all along =)
14:07:47 <malouin> ok, thank you all.
14:07:53 <Nereid_> :-)
14:08:21 <malouin> unary ++ needs to be distributive ( Nereid_ , byorgey , Cale )++
14:08:40 <Cale> @karma )
14:08:40 <lambdabot> ) has a karma of 3
14:08:50 <malouin> ha
14:09:53 <Nereid_> :)
14:10:00 <roconnor> @karma ]
14:10:01 <lambdabot> ] has a karma of 0
14:10:03 <lunabot>  luna: parse error on input `of'
14:10:08 <Nereid_> lol
14:10:15 <roconnor> > [ 7 ]++ [ 8 ]
14:10:16 <lambdabot>   [7,8]
14:10:18 <roconnor> @karma ]
14:10:19 <lambdabot> ] has a karma of 1
14:10:20 <lunabot>  luna: parse error on input `of'
14:10:22 <Nereid_> :-)
14:10:28 <malouin> > map (++ "++") [" Nereid_", " Cale", " byorgey"]
14:10:29 <lambdabot>   [" Nereid_++"," Cale++"," byorgey++"]
14:10:45 <Nereid_> I don't think that works
14:10:56 <Nereid_> maybe want "++ " instead of "++"
14:10:56 <malouin> lambdabot doesn't read its own output for karma?
14:10:59 <Cale> Yeah, lambdabot doesn't parse its own output
14:11:01 <ray> you need to make some other bot say it
14:11:11 <Nereid_> how does lunabot work? :)
14:11:12 <roconnor> , map (++ "++") [" Nereid_", " Cale", " byorgey"]
14:11:13 <lunabot>  [" Nereid_++"," Cale++"," byorgey++"]
14:11:24 <pumpkin> @karma Cale
14:11:25 <lambdabot> Cale has a karma of 16
14:11:27 <pumpkin> oh my
14:11:34 <Nereid_> ah
14:11:35 <skorpan> @karma skorpan
14:11:36 <lambdabot> You have a karma of 1
14:11:38 <skorpan> skorpan++
14:11:39 <skorpan> @karma skorpan
14:11:39 <lambdabot> You have a karma of 1
14:11:41 <Nereid_> lol
14:11:42 <pumpkin> @karma
14:11:43 <skorpan> fuuuuuuuu...
14:11:43 <lambdabot> You have a karma of 6
14:11:47 <Nereid_> @karma
14:11:47 <lambdabot> You have a karma of 0
14:11:52 <Nereid_> indeed, so
14:12:00 <Nereid_> , map (++ "++ ") [" Nereid_", " Cale", " byorgey"]
14:12:01 <lunabot>  [" Nereid_++ "," Cale++ "," byorgey++ "]
14:12:06 <Cale> I think the karma information has gotten reset a couple of times.
14:12:08 <ray> shouldn't it subtract one from you if you increment yourself?
14:12:09 <Nereid_> @karma
14:12:09 <lambdabot> You have a karma of 1
14:12:13 <Cale> @karma
14:12:13 <Nereid_> lol
14:12:14 <lambdabot> You have a karma of 17
14:12:23 <Nereid_> so yeah you need the space after ++
14:12:24 <skorpan> hey let's make a deal i give you karma, you give me karma
14:12:31 <Lemmih> , map (++ "++ ") (repeat " Lemmih")
14:12:32 <lunabot>  [" Lemmih++ "," Lemmih++ "," Lemmih++ "," Lemmih++ "," Lemmih++ "," Lemmi...
14:12:34 <Cale> @karma dons
14:12:34 <lambdabot> dons has a karma of 9
14:12:37 <Cale> heh
14:12:44 <pumpkin> zomg Lemmih is a karmawhore
14:12:45 <Cale> Definitely has been reset
14:12:46 <Lemmih> ?karma
14:12:46 <lambdabot> You have a karma of 12
14:12:47 <FliPPeh> How can I return some value out of the Maybe monad? I've got Just "String" and I want just.. the string!
14:12:54 <FliPPeh> Any pre-made function?
14:12:54 <Lemmih> Kewl.
14:12:56 <skorpan> FliPPeh: pattern matching
14:13:00 <skorpan> FliPPeh: fromJust
14:13:01 <pumpkin> FliPPeh: fromMaybe/fromJust
14:13:03 <byorgey> FliPPeh: maybe, fromMaybe, fromJust
14:13:04 <Cale> FliPPeh: case
14:13:11 <pumpkin> FliPPeh: or the maybe function
14:13:14 <malouin> Lemmih: thanks for your response to my email the other day.
14:13:14 <ray> do what cale says
14:13:14 <Nereid_> depends on whether you care about the Nothing or not
14:13:17 <skorpan> maybe doesn't really give you the value though
14:13:20 <Cale> case foo of Nothing -> ... ; Just x -> ...
14:13:49 <skorpan> hm
14:13:59 <skorpan> maybe "lol" id (Just "hey")
14:14:01 <skorpan> > maybe "lol" id (Just "hey")
14:14:02 <lambdabot>   "hey"
14:14:05 <FliPPeh> Caseis no option
14:14:06 <malouin> Lemmih: I decided not to use berkeleydb because I had many concurrent processes accessing the database and I wasn't sure how it was going to work.
14:14:12 <FliPPeh> Case is no option
14:14:12 <Nereid_> > fromMaybe "lol" (Just "hey")
14:14:13 <Cale> FliPPeh: Why not?
14:14:13 <lambdabot>   "hey"
14:14:17 <Nereid_> > fromMaybe "lol" Nothing
14:14:17 <FliPPeh> It has to be inline
14:14:18 <lambdabot>   "lol"
14:14:25 <Cale> FliPPeh: case is an expression form :)
14:14:31 <skorpan> FliPPeh: as Cale showed you, "case" can be "inline"
14:14:36 <FliPPeh> sendLine $ "NOTICE " ++ fromJust (getNick (getUserDetails from))
14:14:37 <Lemmih> malouin: Right, that might make things "interesting".
14:14:44 <Nereid_> > case (Just "hey") of Nothing -> "lol"; Just x -> x
14:14:45 <lambdabot>   "hey"
14:15:11 <malouin> Lemmih: So I implemented a key/value pair schema on top of hdbc/sqlite, as ugly as that is :)
14:15:12 <skorpan> maybe is one of those "two-way monads" that i read about, but what monad was the other one?
14:15:17 <Cale> FliPPeh: Your bot will die if getNick ever returns Nothing
14:15:18 * jeff_s_ sees a semicolon and collapses
14:15:20 <Nereid_> skorpan: Either
14:15:24 <ray> maybe isn't really two way
14:15:28 <Baughn> conal: So I managed to trigger another GHC bug, apparently.
14:15:31 <ClaudiusMaximus> > case (lookup "foo" [("foo, "bar")]) of Just x -> x
14:15:32 <lambdabot>   <no location info>:
14:15:33 <lambdabot>      lexical error in string/character literal at end o...
14:15:34 <skorpan> ray: why not?
14:15:42 <ray> nothing
14:15:44 <Cale> > fromJust Nothing
14:15:46 <lambdabot>   * Exception: Maybe.fromJust: Nothing
14:15:46 <FliPPeh> Meh
14:15:49 <FliPPeh> Okay okay
14:15:54 <FliPPeh> Inline case :)
14:16:00 <ClaudiusMaximus> oops
14:16:03 <Cale> Or you could use fromMaybe
14:16:04 <skorpan> ray: what about it?
14:16:05 <Cale> or maybe
14:16:10 <dschoepe> Is there a reason HasTrie from memo-trie lacks a Char instance, or has it just been overlooked?
14:16:17 <Nereid_> FliPPeh: case getNick (getUserDetails from) of Nothing -> return (); Just x -> sendLine $ "NOTICE " ++ x
14:16:20 <sjanssen> dschoepe: overlooked, probably
14:16:21 <skorpan> ray: what i mean by two-way is that you can actually "get out of it", without unsafe stuff
14:16:31 <FliPPeh> "PING":what:_ -> sendLine $ "NOTICE " ++ case (getNick (getUserDetails from)) of Nothing -> "null"; Just x -> x ++ " :\SOHPING " ++ what ++ "\SOH"
14:16:33 <Nereid_> then it will do nothing if you get Nothing
14:16:35 <Baughn> conal: But for what I've figured out so far: merge (in PrimReactive.hs) seems to have trouble when *both* events are not going to happen, which is why joinE ends up throwing an exception instead of capping the generated Event. Comments?
14:16:45 <ray> and you can't get anything from Nothing
14:16:47 <skorpan> hm, i think i'm talking out of my ass
14:16:50 <ray> except bottom
14:16:55 <Nereid_> or
14:16:56 <Nereid_> better
14:16:59 <dschoepe> sjanssen: Okay, thanks.
14:17:00 <Cale> FliPPeh: You probably don't want to sendLine unless it is Just x
14:17:33 <Nereid_> maybe (return ()) (\x -> sendLine $ "NOTICE " ++ x) (getNick (getUserDetails from))
14:17:35 <Nereid_> I dunno
14:17:47 <Cale> yeah
14:18:27 <Cale> case getNick (getUserDetails from) of
14:18:31 <Cale>   Nothing -> return ()
14:19:20 <Cale>   Just x  -> sendLine . concat $ ["NOTICE ", x, " :\SOHPING ", what, "\SOH"]
14:19:29 <pumpkin> @quote BONUS If we think of a list as a monster, here's what's what.
14:19:30 <lambdabot> No quotes for this person. There are some things that I just don't know.
14:19:36 <pumpkin> @remember BONUS If we think of a list as a monster, here's what's what.
14:19:37 <lambdabot> I will remember.
14:20:17 <Cale> That is the best diagram ever.
14:20:46 <Cale> http://learnyouahaskell.com/listmonster.png
14:20:57 <pumpkin> I love it
14:21:11 <pumpkin> @quote monster
14:21:12 <lambdabot> dcoutts says: (:[]) looks like a monster
14:21:16 <ClaudiusMaximus> transparency fail :(
14:21:29 <Cale> transparency?
14:21:43 <ClaudiusMaximus> yes.  my default browser background is not white
14:21:46 <Cale> ah
14:21:53 <pumpkin> zomg why not
14:22:47 <Cale> Yeah, given that it's a png, it could have made better use of the alpha channel
14:23:12 <pumpkin> I bet he did it on purpose to prevent people from reusing his graphics on sites with ugly backgrounds!
14:23:24 <Cale> It looks like it would if it was converted from a gif
14:24:10 <Berengal> Mmm, lists...
14:24:41 <Nereid_> I eat list monsters for breakfast
14:24:55 <Berengal> list monsters eat lists for breakfast
14:25:06 <Berengal> I wonder what lists eat for breakfast...
14:25:12 <Botje> .. other lists!
14:25:25 <Botje> and i still want a poster-sized version of that drawing
14:25:26 <Nereid_> I guess a list of type [a] would eat things of type a for breakfast
14:25:30 <skorpan> yeah, the mouth is located at the head of the list, which consumes other lists
14:25:31 <Botje> .. or maybe just a tshirt
14:25:39 <Botje> a tshirt would be awesome.
14:26:05 <Berengal> Hmm, yeah, a t-shirt would be fine too
14:26:12 <skorpan> a cat would be fine too...
14:26:47 <pumpkin> ceiling cat?
14:27:08 * Berengal just wrote a chat server thingamajig in 45 minutes
14:27:13 * ceilingcat iz watchin u
14:27:35 <Berengal> STM is good stuff
14:27:46 <Botje> too much STM will kill you
14:27:51 <Botje> but so will too little STM
14:27:53 <Botje> BE WARNED!
14:28:21 <Berengal> I coudn't find a modifyTVar function though. Granted, it's only two lines, but still...
14:29:07 <FliPPeh> > case "123test123:D" of ('1':'2':'3':x:'1':'2':3':x) -> x
14:29:08 <lambdabot>   <no location info>:
14:29:09 <lambdabot>      lexical error in string/character literal at chara...
14:29:20 <FliPPeh> > case "123test123:D" of ("123":x) -> x
14:29:21 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
14:29:24 <FliPPeh> :(
14:29:30 <Botje> yeah.
14:29:31 <FliPPeh> > case "123test123:D" of "123":x -> x
14:29:32 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
14:29:48 <FliPPeh> Looks like I have to do real splitting
14:29:59 <Nereid_> FliPPeh: I don't think "123":x does what you think it does
14:30:02 <Berengal> Or use view patterns
14:30:32 <Nereid_> > case "123test123:D" of '1':'2':'3':x -> x
14:30:33 <lambdabot>   "test123:D"
14:30:34 <pumpkin> > case "123test123:D" of '1':'2':'3':x -> x
14:30:36 <lambdabot>   "test123:D"
14:30:36 <sjanssen> Berengal: writeTVar v . f =<< readTVar v -- is two lines? :)
14:30:39 <pumpkin> I fail
14:30:43 <ray> : is not ++
14:30:49 <FliPPeh> I know
14:30:56 <Berengal> sjanssen: Type signature too :P
14:30:56 <FliPPeh> I'm just hoping :)
14:31:16 <Nereid_> and this won't work either:
14:31:16 <ray> and ++ isn't a constructor. EVERYONE LOSES
14:31:20 <Nereid_> > case "123test123:D" of "123"++x -> x
14:31:21 <lambdabot>   <no location info>: Parse error in pattern
14:31:31 <ray> LAMBDAS FALL EVERYONE DIES
14:32:04 <Nereid_> since ++ isn't a constructor
14:32:45 <Berengal> case "123test123:D" of (prefixMatch "123" -> Just x) -> x
14:33:03 <Berengal> prefixMatchBy _ (x:xs) [] = Nothing
14:33:03 <Berengal> prefixMatchBy _ [] ys = Just ys
14:33:03 <Berengal> prefixMatchBy (≡ ) (x:xs) (y:ys) | x ≡  y = prefixMatchBy (≡ ) xs ys
14:33:03 <Berengal>                                  | otherwise = Nothing
14:33:26 <FliPPeh> > case "|test 123|" of '|':text:'|'
14:33:27 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
14:33:28 <Berengal> prefixMatch = prefixMatchBy (==)
14:33:35 <FliPPeh> > case "|test 123|" of '|':text:'|':""
14:33:36 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
14:33:47 <FliPPeh> Meh
14:34:02 <Nereid_> you forgot the -> etc
14:34:12 <Nereid_> anyway text would have to be a Char in that case
14:34:13 <Berengal> Wouldn't help
14:34:24 <FliPPeh> Okay
14:34:25 <magthe> is there some way to hide a standard instance definition... I'd like to redefine `instance Pretty a => Pretty [a]`?
14:34:28 <FliPPeh> Need real splitting then
14:34:30 <Nereid_> yeah
14:34:40 <mauke> magthe: no
14:35:36 <magthe> mauke: oki, so my only option is to wrap the list in a custom datatype, e.g. `data MyPrettyList a = MyPrettyList [a]` and then define the Pretty instance on that?
14:35:49 <Nereid_> FliPPeh: if you want anything much more complicated then a parser is good
14:35:52 <Nereid_> have a look at the irc package too
14:35:56 <FliPPeh> Not complicated
14:35:58 <mauke> magthe: yeah (also s/data/newtype/)
14:36:13 <ville> Half the ##C++ population is here, eh?
14:36:19 <magthe> mauke: ah, ok... a bit more typing then, but not too bad :)
14:36:21 <magthe> thanks
14:37:14 <Peaker> ville: I wouldn't expect that
14:37:22 <guenni> how can I get [a, b, c, d, e, .... , aa, ab, ac, ad] again?
14:37:37 <Peaker> would there be a lot of overlap between C++ and Haskell crowds?
14:37:56 <Raevel> i would hope not :-P
14:37:57 <Nereid_> guenni: maybe [a..ad] is what you're looking for?
14:38:00 <ville> Peaker: surprisingly lot it seems.
14:40:13 <conal> Baughn: "conal: Is the Monoid instance for events diagonalizing mappend?"  it's more like set union, if you think of events as sets of time/value pairs.  or with E a = T -> [a], then it's the usual function monoid.
14:41:16 <Baughn> conal: I'm just thinking of the order in which they get evaluated. Sure looks like diagonalization.. well, never mind.
14:41:22 <Baughn> conal: As you can see, I hit another GHC bug. ^^;
14:41:35 <conal> Baughn: yeah.
14:42:12 <conal> Baughn: by diagonalization, do you mean \ x -> f x x (join on functions)?
14:42:38 <conal> Baughn: and are you asking about evaluation or meaning?
14:42:43 <Baughn> conal: Evaluation.
14:42:48 <conal> (operational or denotational)
14:42:54 <Baughn> conal: Actually, it's blatantly obvious, and I believe you state it outright in your paper. :P
14:43:05 <Baughn> So there's no need to worry about that.
14:43:30 <Baughn> That is, what joinE needs to do to merge infinite events correctlyt
14:43:44 <conal> yep
14:43:49 <Peaker> does ghci have a short line limit?
14:44:02 <conal> Baughn: potentially, an infinite stream of infinite streams.
14:44:10 <conal> merged into temporal order
14:44:57 * jmcarthur_work finds the procrastinating-variable package dangerously interesting
14:44:59 <Baughn> conal: Right. And if you make a 2d array from the occurences, and look at the merge order, you get diagonalization. Well, in the simplest case at least.
14:45:21 <conal> Baughn: i don't think so.
14:45:37 <conal> Baughn: diagonalization discards most values, right?
14:46:24 <Baughn> conal: Hm. "Diagonalization" may not be the right term. When I checked, it appears to not mean the same as what I meant..
14:46:59 <jmcarthur_work> well, you might see a pattern which your mind might interpret as diagonal on one end and flat on the other
14:47:12 <Baughn> conal: What I meant was the occurences in the merged event, if you map them back to the original 2D occurence grid, will be in a diagonal-ish order
14:47:17 <jmcarthur_work> if you were to, say, see when things evaluate
14:47:20 <Peaker> ville: 55 nicks in both ##c++ and #haskell
14:47:26 <Baughn> conal: I don't think we're actually disagreeing here, so I'm going to get back to debugging ghc. :P
14:47:52 <conal> Baughn: good luck, and thanks.
14:51:18 <ville> Peaker: heh, ok.
14:52:46 <Peaker> ville: Had to struggle with ghci to get that, apparently there's some really short line length limit
14:55:34 <deeflex> Learnin IO now. I want to write a function which reads from stdin and returns like IO [a]. I'm so confused with this :)
14:55:53 <mauke> what's the problem?
14:55:59 <BONUS> what does it return
14:56:11 <Cale> IO [a]? You want it to be polymorphic?
14:56:16 <BONUS> i.e. what do you want it to do
14:58:06 <FliPPeh> Hey, C knows global compiler set values such as __FILE__ and __DATE__
14:58:12 <FliPPeh> Can Haskell do that, too? GHC?
14:58:48 <deeflex> ye I have defined a data type, say A. I want to read from stdin, for each line: create an instance of that data type and then return the list of all instances.
14:59:06 <Peaker> FliPPeh: You can run cpp on a Haskell program too :-)
14:59:14 <BONUS> how many lines do you want to read?
14:59:21 <FliPPeh> Any easy way? :)
14:59:39 <luqui> cpp myfile.hs ?
15:00:14 <Peaker> deeflex: You should separate the side-effecting part from the pure processing part.  You want to read the entire file (effect), divide it into lines (pure), apply a constructor on each line (pure),  right?
15:00:57 <pumpkin> {-# LANGUAGE CPP #-} at the top
15:01:18 <Peaker> deeflex: do { contents <- hGetContents stdin ; ... apply pure functions to contents here ... ; return (whatever you want here) }
15:01:19 <luqui> deeflex, write function makeA :: String -> A, then map makeA (lines fileContents)
15:01:46 <Peaker> deeflex: try to separate your program into the computational part, and the part that interacts with files/world
15:03:18 <deeflex> BONUS: until EOF.
15:03:55 <BONUS> yeah then do what the guys said
15:04:41 <deeflex> Ok is this even correct? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5695#a5695 I don't have a haskell environment so I cant test anything now :). But main should call another function which reads from stdin and creates type A.
15:04:58 <deeflex> Peaker: oh ok I see
15:06:43 <Peaker> deeflex: if readStuff takes "stdin" as an arg, then its not an IO value, its a function. Only functions have args
15:06:46 <Berengal> deeflex: For small and easy programs, take a look at 'interact'. It takes a function of type String -> String and gives it the contents of stdin as input, and prints the output to stdout
15:07:03 <Peaker> deeflex: so readStuff must be   Handle -> IO something
15:08:14 <deeflex> Peaker: ok
15:08:31 <Peaker> deeflex: you don't need to do isEOF stuff, you have  hGetContents :: Handle -> IO String
15:08:41 <Peaker> deeflex: gives you the whole file as a string, inside an IO action
15:09:19 <deeflex> Peaker: ok, this is my first attempt so.. =)
15:10:20 <thoughtpolice> dcoutts: sorry, ping again
15:10:41 <thoughtpolice> dcoutts: I'm running the latest HEAD cabal/cabal-install, and ghc-pkg dump is failing, but not if I provide the '-v2' flag to it
15:10:50 <thoughtpolice> dcoutts: this happens on every package pretty much
15:11:11 <Peaker> deeflex: you can define, for example:  hReadLines :: Handle -> IO [String]  ; hReadLines handle = do { contents <- hGetContents handle ; return (lines contents) }
15:11:49 <Peaker> deeflex: note that instead of:   do { x <- act ; return (f x) }   you can use:  fmap f act.  So you can alternatively use:  hReadLines handle = fmap lines hGetContents
15:12:04 <Peaker> hReadLines handle = fmap lines (hGetContents handle)  -- that was
15:12:26 <Nereid_> or liftM instead of fmap
15:12:56 <Nereid_> which seems more intuitive to me
15:13:04 <Peaker> Nereid_: its just a different name?
15:13:10 <Peaker> Nereid_: how is a name "more intuitive"? :)
15:13:22 <pumpkin> <$> is even nicer I think
15:13:41 <Peaker> pumpkin: and then you need to import stuff :-(
15:14:06 <pumpkin> I think it should be in prelude :)
15:14:28 <Peaker> I am wondering whether to create a Scripting module that imports everything from all over the place
15:14:36 <Peaker> (e.g a bit like lambdabot's import list)
15:14:38 <Nereid_> likewise for liftM, but my point is that liftM is monads, and fmap is for functors
15:14:50 <Gracenotes> just doesn't call fmap (.), plox.
15:14:54 <Peaker> Nereid_: liftM=fmap for well-behaved monads
15:14:59 <pumpkin> so, just because people call it the IO monad doesn't mean it's only a monad
15:15:10 <Nereid_> sure
15:15:15 <Nereid_> but that's how I tend to think of it
15:15:16 <Berengal> I almost always import Control.Applicative anyway...
15:15:16 <Peaker> Nereid_: so they are just aliases
15:15:21 <Gracenotes> all monads are functors, anyweh..
15:15:22 <dcoutts> thoughtpolice: how peculiar
15:15:23 <pumpkin> it's the IO functor just as much as it's the IO monad
15:15:30 <Nereid_> and liftM works for all monads, not just IO
15:15:35 <pumpkin> so does fmap
15:15:38 <Peaker> Berengal: I always import qualified or with (). Don't hurt your code readers :(
15:15:39 <Nereid_> fine
15:15:40 <Nereid_> :-)
15:15:41 <pumpkin> and I like to use the most general function when I can :)
15:15:45 <dcoutts> thoughtpolice: does ghc-pkg fail normally when you run it directly?
15:15:52 <Gracenotes> <$> isn't so bad.... raly.
15:15:59 <sjanssen> pumpkin: modulo Haskell '98 sucking
15:15:59 <Berengal> Peaker: I have none :(
15:16:02 <luqui> pumpkin, (or rather, what ought to be the more general function)
15:16:02 <Peaker> Nereid_: Using fmap makes your code more general, sometimes
15:16:03 <dcoutts> thoughtpolice: or only when Cabal calls it
15:16:07 <pumpkin> sjanssen: true :)
15:16:11 <Nereid_> I'm new to haskell anyway
15:16:13 <Peaker> Berengal: maybe that's why! :)
15:16:18 <Berengal> Anyway, fmap is specialized, so might in some cases be more efficient than liftM
15:16:46 * Botje always uses liftM in monad context.
15:16:52 <Botje> fmap just seems .. wrong :)
15:16:55 <pumpkin> what's a monad context?
15:17:08 <jmcarthur_work> i only use liftM if it prevent another type constraint
15:17:08 <Apocalisp> as opposed to Functor
15:17:24 <Botje> in a do block
15:17:26 <jmcarthur_work> Monad *should* imply Functor anyway, but since it doesn't...
15:17:31 <Botje> or when i'm just working with monads
15:17:31 <luqui> i always grumble and flip a coin
15:17:40 <deeflex> Peaker: ok thanks a lot. I'll give it I try tomorrow, it's late and I don't have a hugs env. here.
15:17:47 <Apocalisp> I like (.)
15:17:51 <Peaker> deeflex: install ghci, not hugs, if you can
15:17:59 <Peaker> (.) should be Control.Category's, probably
15:18:21 <luqui> :t fmap `fmap` fmap
15:18:22 <jmcarthur_work> yeah i have come to agree with (.) being part of Category
15:18:22 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
15:18:28 <luqui> :t (.).(.)
15:18:30 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
15:18:33 <Apocalisp> > (* 2) . [1,2,3]
15:18:34 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[a1]'
15:18:37 <Berengal> fmap /= Control.Category.(.)
15:18:37 <luqui> oh no more Caleprelude?
15:19:12 <Cale> That's been gone a long time, since the GHC API or hint is bad at hiding.
15:19:14 <jmcarthur_work> yeah i kind of miss Caleskell
15:19:17 <Peaker> fmap and Control.Category.(.) seem to be strongly related
15:19:28 <Cale> Weird. 'xset r off' here makes X think that the Enter key is held down or something
15:19:45 <Cale> I had to switch to a terminal...
15:20:37 <Vulpyne> :r
15:20:38 <quicksilver> Cale: Why does it give bogus error messages in volving GHC.Types now?
15:20:44 <quicksilver> Cale: can it be fixed?
15:20:57 <Cale> hmm?
15:20:58 <quicksilver> > take "hi" "there"
15:20:59 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
15:21:03 <deeflex> Peaker: OK. Btw in hReadLines it should be Handle -> IO [someType] (instead of [String], right? And from main I should write do { return hReadLines }. will that write to stdout?
15:21:18 <quicksilver> Int, sure. Prelude.Int, sure. GHC.Types.Int? no thanks.
15:21:19 <Cale> quicksilver: Isn't that a correct error message?
15:21:21 <Cale> Oh.
15:21:27 <pumpkin> yeah, that started recently
15:21:46 <quicksilver> it's distracting noise and confuses learners
15:21:57 <aluink> anyone got any ideas on this? http://aluink.pastebin.com/m38beb3de
15:22:04 <FliPPeh> > let para = ":test" in (case para of (':':clean) -> clean; clean -> clean)
15:22:06 <lambdabot>   "test"
15:22:09 <FliPPeh> > let para = "test" in (case para of (':':clean) -> clean; clean -> clean)
15:22:10 <lambdabot>   "test"
15:22:25 <aluink> i can't find a nice solution for trhsx
15:22:39 <Cale> I have no idea.
15:22:51 <Zao> deeflex: return just wraps a value in a monad.
15:23:02 <Cale> Perhaps it started when I upgraded it to 6.10.3
15:23:16 <Zao> deeflex: In the case of (return foo) it yields an action that when executed yields foo.
15:23:27 <Zao> deeflex: It doesn't print anything, unless that's an side effect.
15:23:38 <jmcarthur_work> :t (<=<)
15:23:40 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
15:23:41 <Zao> deeflex: hPutStr or print tends to be IO functions suitable.
15:23:42 <Berengal> return never has any side effects
15:23:42 <deeflex> Zao: ok so I putStr then?
15:23:46 <Berengal> Well, shouldn't
15:23:53 <Zao> Berengal: Muahaha.
15:24:00 <Nereid_> FliPPeh:
15:24:04 <Gracenotes> @src (>=>)
15:24:04 <lambdabot> Source not found. My mind is going. I can feel it.
15:24:08 <Nereid_> > let para = ":test" in stripPrefix ":" para
15:24:09 <lambdabot>   Just "test"
15:24:22 <Nereid_> ok, not quite what I was looking for
15:24:25 <FliPPeh> Nereid: I'm gonna use that inline
15:24:28 <FliPPeh> So case is faster
15:24:36 <Peaker> deeflex: hReadLines :: Handle -> IO [String] -- why someType? it reads lines, specifically.    whatever main returns does not go anywhere
15:24:38 <FliPPeh> "NICK"    -> handleNickChange sender (case para of (':':clean) -> clean; clean -> clean)
15:24:46 <Cale> (f <=< g) x = do v <- g x; f v
15:24:53 <Zao> @type ("lol", return "lol")
15:24:54 <lambdabot> forall (m :: * -> *). (Monad m) => ([Char], m [Char])
15:25:11 <Cale> return is a left and right identity for <=<
15:25:15 <Cale> and <=< is associative
15:25:26 <Cale> That's another way to say the monad laws :)
15:25:29 <luqui> FliPPeh, is speed really a key concern in this code?
15:25:39 <FliPPeh> Noo, faster to write for me
15:25:41 <jmcarthur_work> (<=<) is the closest way to relate fmap to Control.Category.(.) that i can think of
15:25:44 <Berengal> Cale: The better way, imho
15:26:08 <luqui> FliPPeh, oh... faster than a library func
15:26:18 <luqui> > stripPrefix ":" "foo"
15:26:19 <lambdabot>   Nothing
15:26:32 <FliPPeh> Library func using Maybe
15:26:37 <FliPPeh> Wich I'll have to strip, too
15:26:41 <Cale> Berengal: yes
15:26:43 <Nereid_> > let para = ":test" in fromMaybe para $ stripPrefix ":" para
15:26:44 <lambdabot>   "test"
15:26:47 <Nereid_> > let para = "test" in fromMaybe para $ stripPrefix ":" para
15:26:48 <lambdabot>   "test"
15:26:52 <Berengal> FliPPeh: view patterns
15:26:56 <Nereid_> less writing than the case version
15:27:08 <luqui> > let strip x = fromMaybe x $ stripPrefix ":" x in strip "foo"
15:27:10 <lambdabot>   "foo"
15:27:15 <Cale> Berengal: I sometimes wonder if it wouldn't be better for Monad to be defined in terms of (<=<) and return
15:27:35 <algal> newbie question. I'm trying to convert an integer to list of its digits. "integerDigits n = map Char.digitToInt (show n)" performs better than my own efforts, but then it doesn't have a sensible type signature.
15:27:43 <Cale> That might be a little awkward in writing some instances though.
15:27:48 <FliPPeh> @src fromMaybe
15:27:48 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
15:27:48 <Berengal> Cale: Maybe. It wouldn't be worse, at least
15:27:51 <algal> is there a way to fix it up so it goes Integral -> [Int] ?
15:27:59 <FliPPeh> @module fromMaybe
15:27:59 <lambdabot> Unknown command, try @list
15:28:02 <algal> Or else fixup my arithmetic version so it performs well?
15:28:02 <FliPPeh> @list
15:28:02 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
15:28:11 <luqui> > let strip = ap fromMaybe . stripPrefix in (strip ":" ":foo", strip ":" "foo")
15:28:13 <lambdabot>   ("foo","foo")
15:28:17 <Nereid_> algal: use (fromIntegral . Char.digitToInt) instead of Char.digitToInt perhaps
15:28:20 <Berengal> We could put (<=<) in the class and use defaults...
15:28:34 <Nereid_> ?
15:28:54 <deeflex> Peaker: Ok nvm. That's where the mapping comes in...map a function to the result of hReadLines and then return [someType]. right?
15:28:55 <Nereid_> :t digitToInt
15:28:56 <lambdabot> Char -> Int
15:29:03 <Cale> > reverse . map (`mod` 10) . takeWhile (/= 0) . iterate (`div` 10) $ 12345
15:29:05 <lambdabot>   [1,2,3,4,5]
15:29:14 <Cale> Does that not perform well?
15:29:51 <algal> Cale: hmm.. that's more compressed than my arithmeti version. not sure if it's doing the same thing..
15:30:00 <Cale> (How incredibly large are the numbers you're doing this with that you need to care about the performance of it?)
15:30:06 <algal> the character-manipulating version beat the elegant version.
15:30:25 <Cale> I suppose you can save some work by using divMod instead
15:30:26 <algal> Cale: I'm working thru the project euler problems in Haskell & other langs, so I end up handling big integers and needing performance.
15:30:38 <luqui> plus, it's more natural to have the least significant digit up front
15:30:54 <Berengal> > reverse $ unfoldr (\n -> let (rest, digit) = divMod n 10 in if n == 0 then Nothing else Just (digit, rest)) 12345
15:30:55 <lambdabot>   [1,2,3,4,5]
15:31:04 <Peaker> deeflex: yeah, but such mapping happens outside of hReadLines and does not affect its type
15:31:04 <luqui> algal, it's still log time wrt the size of the number.. you shouldn't hit a barrier
15:31:05 <Cale> Yeah, if you can stand to have the digits in the opposite order, not reversing would be better.
15:31:28 <algal> mine was:
15:31:39 <deeflex> Peaker: YE ok thanks.
15:31:40 <algal> intToDigits = reverse . intToDigitsReversed
15:31:40 <algal> intToDigitsReversed  n | (n == digit) = [digit]
15:31:40 <algal>                        | otherwise    = digit : intToDigitsReversed rest
15:31:41 <algal>     where (rest, digit) = quotRem n 10
15:31:57 <algal> I can't quite tell if that's the same as yours.. My haskell-fu is not strong enough yet.
15:32:12 <Berengal> Looks very similar to mine
15:32:13 <luqui> algal, it's almost the same.  you do divMod, cale does div and mod.
15:32:33 <Peaker> deeflex: main = do { lines <- hGetLines stdin ; let result = map whatever lines ; print result } -- note the get-input(effect), input -> compute -> output, print-output(effect)
15:32:33 <FliPPeh> > let para = [":test"] in fromMaybe para $ stripPrefix ":" head para
15:32:34 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
15:32:36 <luqui> hopefully the rest will fuse (?)
15:32:40 <FliPPeh> > let para = [":test"] in fromMaybe para $ stripPrefix ":" (head para)
15:32:41 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
15:33:01 <Peaker> deeflex: whatever would convert each line from String to whatever you want
15:33:39 <algal> luqui: so you think the divMod version should be comparable to the Char-based version?
15:33:47 <Peaker> deeflex: of course, as Haskell mojo goes up, you end up writing that as:  main = print =<< map whatever . lines <$> getContents
15:34:08 <luqui> algal, what do you mean the char-based version?
15:34:33 <Berengal> Peaker: main = iteract $ unlines . map whatever . lines
15:34:34 <Peaker> deeflex: You can see it as sort of a "pipeline".  getContents starts the pipeline, gives it to lines, then to map whatever, eventually to print
15:34:44 <luqui> algal, although yes, show on Integer should be pretty fast.
15:34:46 <algal> luqui: digitToInt is in Char. My (blurry) understand is that it's doing a non-mathematical character manipulation.
15:35:01 <Peaker> Berengal: needs even more mojo :-)
15:35:11 <ClaudiusMaximus> @src show Integer
15:35:11 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
15:35:24 <luqui> algal, oh.  i'm not sure.  i'd use cale's, because it's purdy
15:35:26 <Berengal> algal: digitToInt is probably just '(-65) . ord' or something similar
15:35:40 <luqui> algal, project euler is about algorithms, not raw speed
15:35:59 <sjanssen> Peaker: I don't think anybody should write it that way
15:36:07 <sjanssen> Peaker: print . map whatever . lines =<< getContents
15:36:08 <algal> luqui: I have a terrible weakness for the purdy. But prettiness does not equal speed. Which makes me sad.
15:36:28 <Cale> algal: It often does
15:36:34 <luqui> algal, but in this case it ought to be comparable, and if you need that extra boost in project euler, you are doing the problems wrong
15:36:51 <Berengal> algal: Which problem are you currently working on? Just curious...
15:37:06 <Peaker> sjanssen: yeah, there are various better variants of that, just showing PL style in general
15:37:17 <deeflex> Peaker: much appreciated. Should be able to finish this now :)
15:37:32 <algal> Berengal: this is just prob4. I'm only up to 40-something, but I'm going back and doing everything in c++, Java, python, Cl, and Haskell.
15:38:19 <algal> I need to learn c++ & Java for bloody interviews. Haskell for fun.
15:38:26 <luqui> deeflex, please use interact... :)
15:39:14 <algal> Cale: is there a convention for naming a function which produces a reversed list? Seems like it must happen a lot.
15:39:28 <deeflex> luqui: maybe I will..better if I come back tomorrow where I can actually test the code =)
15:39:28 <Cale> Not really.
15:39:58 <algal> Cale: oh. what about for predicate functions?
15:40:14 <Cale> :t null
15:40:16 <lambdabot> forall a. [a] -> Bool
15:40:22 <luqui> deeflex, you could always do it with a little one on one time with lambdabot
15:40:30 <Cale> Normally they're named quite plainly. There are some which start with 'is'
15:40:34 <Cale> :t isUpper
15:40:36 <lambdabot> Char -> Bool
15:40:43 <Cale> :t toUpper
15:40:44 <algal> Cale: ok.
15:40:45 <lambdabot> Char -> Char
15:41:02 <Cale> I might add 'Rev' to the end of a function if it produced a reversed result.
15:41:32 <luqui> or, god forbid, Reversed
15:41:40 <algal> Cale: yeah, that's what I was thinking. But I always try to follow native idiom
15:42:02 <luqui> reversed lists are very uncommon in my experience
15:42:11 <Berengal> You're often creating reversed lists when you just start out. At least I remember I did. I don't anymore...
15:42:14 <luqui> they delazify an otherwise nice stream program
15:42:16 <Cale> http://loadingreadyrun.com/videos/view/440/The-Joystique -- haha
15:42:27 <algal> luqui: oh, interesting.
15:42:34 <luqui> Berengal, yeah, from the tail recursion fever
15:42:40 <deeflex> luqui: i'll pass ;)
15:43:42 <algal> Nereid_: btw, fromIntegral didn't solve my puzzle. Maybe this is my excuse to go slow and pretty after all.
15:44:12 <Cale> algal: You can add explicit type signatures if you get a type which is too polymorphic
15:44:26 <Berengal> algal: What exactly are you doing that is slow? I just tested the naive implementation, and it finished in about a second...
15:44:33 <Luckytoilet> > test
15:44:35 <lambdabot>   Not in scope: `test'
15:44:53 <Luckytoilet> > "test"
15:44:55 <lambdabot>   "test"
15:45:16 <malouin> Is the function (\x -> case x of Left _ -> Nothing Right a -> Just a) in a lib somewhere?
15:45:47 <algal> Berengal: it came up on prob34. calculate the sum of all numbers which are equal to the sum of the factorial of their digits.
15:45:48 <Berengal> malouin: either (const Nothing) Just
15:46:11 <Berengal> algal: Ah, I thought you were just on problem 4
15:46:12 <algal> so I did a generate & test going up to 2540160
15:46:26 <algal> I've solved higher in other langs, but now I'm re-doing in haskell
15:46:33 <malouin> Berengal: aha!
15:46:34 <algal> for some reason I've done 34 in haskell and mathemtiaca.
15:46:39 <malouin> thank you!
15:46:40 <Luckytoilet> project euler?
15:46:48 <Nereid_> yeah
15:46:51 <algal> Luckytoilet: project euler = teh awesome
15:47:03 <Luckytoilet> 230/248 done =]
15:47:29 <yairchu> Luckytoilet: couldn't solve problem 60 yet.. don't tell me though!
15:47:50 <Luckytoilet> ok
15:47:53 <Berengal> algal: Ah, for problem 34 I think I just did something like 'scanl1 (+) (filter isCurious [1..])'
15:47:54 <algal> My question is, where the hell are all these assembly languages programmers on project euler coming from?
15:48:13 <Cale> My question is, why is the answer to every Project Euler problem a number?
15:48:20 <algal> Berengal: Yes, but isCurious requires pulling out digits!
15:48:21 <Luckytoilet> not every
15:48:35 <Eiler> why not?
15:48:35 <Cale> Pretty much :)
15:48:40 <Berengal> algal: Yes, I know. Don't remember exactly how I did it...
15:49:28 <yairchu> Cale: numbers are easy to compare?
15:49:46 <Luckytoilet> hmm 162 isn't a number
15:52:10 <yairchu> algal: digits = map (read . (:[])) . show
15:52:14 <Berengal> algal: digits = map digitToInt . show seems fast enough. It just solved problem 34 in much less than a second for me...
15:52:56 <Berengal> Well, "solved"... using scanl1 (+) produces an infinite list of only two elements...
15:53:03 <Berengal> (In this case)
15:54:27 <Berengal> > let digits = map digitToInt . show; isCurious = (==) <*> sum . map (product . enumFromTo 1) . digits in take 2 $  scanl1 (+) (filter isCurious [3..])
15:54:28 <lambdabot>   [145,40730]
15:54:38 <Luckytoilet> > fact 5 where fact x | x == 0 = 1 | x * fact (x-1)
15:54:40 <lambdabot>   <no location info>: parse error on input `where'
15:54:58 <Luckytoilet> fact 5 where fact x | x == 0 = 1 | otherwise = x * fact (x-1)
15:55:19 <Luckytoilet> > fact 5 where fact x | x == 0 = 1 | otherwise = x * fact (x-1)
15:55:21 <lambdabot>   <no location info>: parse error on input `where'
15:55:27 <Luckytoilet> gah how do i use this
15:55:35 <Berengal> Lambdabot doesn't do where, I believe...
15:55:39 <Berengal> > foo where foo = 5
15:55:40 <lambdabot>   <no location info>: parse error on input `where'
15:55:52 <Luckytoilet> > foo = 5 in foo
15:55:53 <lambdabot>   <no location info>: parse error on input `='
15:56:01 <Berengal> > let foo = 5 in foo
15:56:02 <lambdabot>   5
15:56:04 <Luckytoilet> > let foo = 5 in foo
15:56:06 <lambdabot>   5
15:56:13 <Luckytoilet> ah yum
15:56:20 <algal> Berengal: umm. say again. is there a pastepad?
15:57:00 <Berengal> > let digits = map digitToInt . show; isCurious = (==) <*> sum . map (product . enumFromTo 1) . digits in take 2 $  scanl1 (+) (filter isCurious [3..]) -- algal, this
15:57:01 <lambdabot>   [145,40730]
15:57:22 <Luckytoilet> let fact x | 0 = 1 | otherwise = x * fact x-1 in fact 5
15:57:28 <Luckytoilet> > let fact x | 0 = 1 | otherwise = x * fact x-1 in fact 5
15:57:29 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
15:57:29 <lambdabot>    arising from the literal `0'...
15:57:44 <Luckytoilet> > let fact x | x == 0 = 1 | otherwise = x * fact x-1 in fact 5
15:57:46 <lambdabot>   * Exception: stack overflow
15:58:42 <Berengal> > let fact x | x == 0 = 1 | otherwise = x * fact (x-1) in fact 5
15:58:43 <lambdabot>   120
15:59:40 <zloog> Anyone know why cabal would tell me I do and don't have a particular dependency met? http://www.moonpatio.com/fastcgi/hpaste.fcgi/view?id=2640#a2640
16:00:47 <Nereid_> let fact x = product [1..x]
16:00:47 <Berengal> zloog: I assume it has to do with global vs user package repositories
16:00:52 <dcoutts> zloog: use "cabal" or use "runhaskell Setup.lhs". There is no need to use a mixture of both, you'll just confuse yourself.
16:01:35 <dcoutts> zloog: there's no need to use both, it just means you have to remember whether you're doing --global or --user installs (since the defaults are reversed between the two)
16:03:16 <zloog> Ah thanks, I'll try to see about the user settings
16:04:18 <zloog> !! worked. thanks
16:04:47 <dcoutts> zloog: remember that you can just run "cabal configure" rather than "runhaskell Setup.lhs configure"
16:05:04 <dcoutts> the cabal tool replaces the runhaskell Setup.lhs interface
16:06:00 <zloog> dcoutts: Yea, I really need to sit and learn about cabal sometime. It makes sense for this issue though.
16:06:40 <Saizan_> though running "cabal configure" make sense only for cabal haddock and sdist, since install will reconfigure (unless you use an undocumented flag)
16:06:43 <dcoutts> zloog: fortunately if you're familiar with the "runhaskell Setup.lhs" command line interface then it's easy, since it's exactly the same for the "cabal" tool.
16:07:15 <dcoutts> Saizan_: usually that doesn't matter
16:08:23 <Saizan_> dcoutts: when you don't pass any option, right?
16:08:33 <dcoutts> right
16:09:26 <dcoutts> Saizan_: I accept it's not ideal. If you've got any suggestions for distinguishing the "do everything" from just copy+register then I'd be happy to hear them.
16:09:56 <algal> is there some kind of visual atlas of the HOFs? I think it would make them easier to learn.
16:10:26 <dcoutts> Saizan_: in particular it's tricky in the general case where Setup.hs uses its own build system so we cannot know when it's safe to not reconfigure
16:10:29 <gwern> 'Extract interesting commands and add them to a text file. "Interesting" means not matching any regular expression in the file. This allows one to keep a textual database of commands. Never again say "I wish I remembered what arguments to give wibble to make it flibber the gibbet" three months after you looked it up. WARNING: historian truncates ~/.bash_history. '
16:10:36 <gwern> okay, I'm no longer interested in historian
16:11:09 <gwern> too bad, because the idea is a sound one. wouldn't it be cool if there was a tool which could look through your shell history and tell you what things you should turn into aliases and functions?
16:12:45 <Saizan_> dcoutts: yeah, it's more like a job for the build system, but also an UI problem, if it's acceptable at all for "cabal install" to use the options passed to the last "cabal configure"
16:13:25 <jix> i hope unsafePerformIO works as i want ...
16:13:53 <byorgey> algal: what would such a visual atlas look like?
16:13:57 <gwern> hm. I don't really see what historian buys one; looks like it's just a gussied up grep
16:14:29 <dcoutts> Saizan_: we can certainly save the flags we passed to configure, so perhaps if they're unchanged then we just build + install
16:14:52 <algal> byorgey: not sure. will tell you next time.
16:14:59 <byorgey> =)
16:15:03 <algal> thanks for the help, chaps.
16:15:21 <dcoutts> Saizan_: so we'd re-plan and compare if the configuration has changed
16:15:43 <Saizan_> dcoutts: if you're used to the Setup.hs interface you'd expect to not have to pass the options again to install
16:16:09 <dcoutts> Saizan_: right
16:16:39 <Saizan_> dcoutts: ah, so you'd reconfigure only with conflicting options?
16:16:51 <dcoutts> Saizan_: right
16:17:14 <dcoutts> Saizan_: which I guess also works if you install --with-extra-flags
16:17:31 <idnar> gwern: I just use zsh with a gigantic history file and histignorealldups so it doesn't grow too quickly
16:18:00 <gwern> idnar: the important thing is to factor out repeated patterns
16:18:16 <idnar> gwern: well, the thing is, I'm too lazy to create aliases or whatever
16:18:21 <gwern> I do the same thing with bash, but it doesn't save one from repetition unless one knows one is repeating something
16:18:22 <idnar> gwern: I just use history-incremental-search-backward a lot
16:20:27 <_Lucretia_> anyone know anything about wxhaskell? well, the wxc bit
16:21:19 <Cale> _Lucretia_: I don't really, but if you ask a question, I can try to help anyway
16:22:06 <_Lucretia_> well, i just want to get the c bit built, tried using the wxc source, fails miserably, the wxhaskell version is at least up to date
16:22:21 <_Lucretia_> how can i build it without the haskell bit?
16:23:41 <Cale> This is on linux?
16:24:27 <flipflap> Meh, I've got a StateT using function, which I want to launch in a thread.. how'd I do that?
16:24:39 <Cale> flipflap: runStateT first
16:24:43 <flipflap> forkIO $ liftIO $ spam to does not wor
16:25:06 <Cale> flipflap: Of course not. liftIO turns IO computations into other computations, not the other way around
16:25:07 <SamB> flipflap: yes, that only works in Python
16:25:18 <Cale> You can liftIO . forkIO $ foo
16:25:26 <flipflap> Other way around didn't work, too
16:25:37 <Nereid_> don't you mean
16:25:38 <Cale> But that results in a StateT (or other) computation
16:25:39 <Nereid_> liftIO forkIO foo
16:25:39 <Nereid_> ?
16:25:47 <flipflap> Thing is, forkIO naturally wants the function to be IO (), but it has to be Bot ()
16:25:51 <Cale> Nereid_: I'm sure I mean what I said :)
16:25:57 <flipflap> Fr the StateT
16:26:04 <Cale> flipflap: It cannot be.
16:26:18 <Nereid_> hmm
16:26:18 <Nereid_> wait
16:26:21 <flipflap> So I should just pass the state as a plain value to it?
16:26:22 <Nereid_> liftIO (forkIO foo)
16:26:28 <Nereid_> no, that's not right
16:26:38 <Cale> flipflap: There's no way to thread the state parameter through a computation if it's running in another thread.
16:26:44 <vininim> @type liftIO
16:26:45 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
16:26:45 <Cale> flipflap: In fact, it doesn't even make sense.
16:26:47 <vininim> @type forkIO
16:26:48 <lambdabot> Not in scope: `forkIO'
16:27:06 <Nereid_> iirc, forkIO :: IO () -> ThreadId
16:27:18 <vininim> certainly not
16:27:21 <flipflap> So just give it a copy and let it go manually?
16:27:23 <Nereid_> I'm going crazy then
16:27:29 <Cale> flipflap: However, you can take a StateT computation and turn it into an IO computation by running the state layer, and run *that* in another thread.
16:27:29 <Nereid_> IO ThreadId
16:27:37 <vininim> oh
16:27:38 <Cale> yeah
16:28:00 * Nereid_ is noob :-)
16:28:16 <flipflap> Cale, how?
16:28:25 <Cale> Something like...
16:28:55 <Cale> do s <- get; liftIO . forkIO $ runStateT foo s
16:29:10 <flipflap> Where foo is my function?
16:29:21 <Cale> Where foo is a StateT s IO computation
16:29:48 <Cale> and we're assuming that the whole thing is as well.
16:30:08 <Cale> This will fork a new thread, but note that the thread will have no impact on the state of the original thread
16:30:25 <_Lucretia_> Cale: yeh
16:30:44 <Cale> (How could it anyway? StateT just saves you from passing parameters around by hand)
16:31:16 <flipflap> So how would I go running my test function?
16:31:26 <flipflap> do s <- get; liftIO . forkIO $ runStateT test s does not work
16:31:39 <flipflap> Ah meh wait
16:32:39 <flipflap> No, no idea
16:32:42 <flipflap> How do I start it?
16:34:31 <Cale> hm?
16:34:50 <Cale> What are you actually trying to accomplish?
16:35:52 <flipflap> Trying to start my function as a thread with it having at least read access to the state
16:36:20 <flipflap> I'll just put that off some time, maybe I find a solution not based on threads
16:37:28 <Cale> Oh, I see, it needs a  >> return ()
16:38:53 <Peaker> or () <$
16:42:11 <aavogt> Is there a haskell-style shell out there that builds with ghc-6.10? I've come across HaSh, which has not been written yet, and Hashell, which doesn't build, due to some changes in the GHC api. Are there others?
16:42:36 <idnar> @type (<$)
16:42:38 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
16:43:06 <SamB> aavogt: the one you're about to start writing because we say "no"?
16:43:56 <Berengal> There's always ghci + convenience functions...
16:44:05 <idnar> Hashell sounds like hell
16:44:05 <idnar> ;)
16:44:20 * luqui would like a nice modular extensible ghci for this kind of thing
16:44:25 <luqui> i guess that probably possible using the api
16:44:28 <Berengal> Except the already existing convenience functions aren't convenient for shell use yet
16:44:56 <Berengal> ... and as such can't really be called convenience functions...
16:47:34 <byorgey> aavogt: there's HSH, although I haven't used it so I don't know if it's exactly what you're looking for
16:47:47 <byorgey> but CosmicRay just released a new version so I imagine it ought to work with 6.10.
16:48:29 <ray> inconvenience functions
16:49:59 <aavogt> byorgey: from the documentation, HSH looks quite promising
16:52:25 <aavogt> thanks for the suggestions everybody
16:54:14 <hoooopy> OT: what's a good live linux distro that allows you to burn CDs and is just generally good for diagnostic purposes?
16:54:46 <Cale> aavogt: HSH is more useful for writing shell-script-like things with Haskell rather than as an actual interactive shell
16:54:49 <SamB> hoooopy: well, generally you'll need two CD drives for that
16:55:20 <ray> not really
16:55:54 <SamB> okay, maybe I'm still in the stone ages where RAM < CD
16:56:10 <ray> even my computer can handle a little ramdisk
16:56:56 <SamB> isn't it hard to get Linux to even see the CD drive it was booted from after an El Torito boot?
16:57:42 <aavogt> Cale: true, seeing as it doesn't offer any completion, and things need to be prefixed with run
16:57:53 <ray> if that's the case, just have grub or whatever do the ramdisk thing (i think it can)
16:58:02 <dumael> SamB: yes. the boot kernel is on an emulated floppy disk image though the magic of the BIOS. the kernel still needs the appropiate drivers to access the cd-rom drive and the like.
16:58:21 * pumpkin is trying to figure out how to write "quickbench"
16:58:30 <SamB> isn't it tricky to get the floppy disk emulation to stop?
16:58:34 <ray> > text "quickbench"
16:58:36 <lambdabot>   quickbench
17:00:31 <dumael> SamB: floppy disk emulation is how El Torito works afaik. After you've boot up any OS off a cd, they still need drivers for things like IDE/SATA controllers. Windows and linux get a fair shock when they can't detect the boot cd due to a lack of drivers.
17:00:35 <ray> opera software clobbered my hoogle shortcut :(
17:00:48 <ray> i had to change it to :h
17:01:01 <SamB> dumael: well, you ALSO need to get the BIOS to stop emulating the floppy, don't you?
17:01:13 <TheColonial> :k [Int]
17:01:14 <lambdabot> *
17:01:39 <idnar> SamB: I'm not sure it matters
17:01:41 <SamB> and do whatever else is needed to eject the CD?
17:02:02 <SamB> or does it load the whole emulated floppy into RAM?
17:02:13 <SamB> and just waste that piece of RAM forever?
17:02:13 <dumael> er, not wholly certain.
17:03:03 <mcnster> hi.  what is an elegant way to map/fold a type of [(a,b)] into [(b,[a])]?
17:03:20 <idnar> SamB: apparently "no emulation" mode is mostly used these days
17:03:30 <Peaker> mcnster: you mean (b,[a]) ?
17:04:20 <mcnster> i mean [(b,[a])]
17:04:38 <ray> that question requires more detail than just the types
17:04:44 <SamB> idnar: ah.
17:05:06 <p_l> dumael: that's wrong. There are few modes, with *one* of them being floppy emulation
17:05:12 <SamB> even so, it'd take a pretty hefty amount of RAM in my way of thinking to actually unmount your knoppix CD
17:05:31 <ray> knoppix is fat
17:05:33 <SamB> or a good-sized swap partition, I guess
17:05:38 <dumael> p_l: thanks for the correction.
17:05:40 <p_l> dumael: Win9x used floppy emulation mode, and that's probably the only OS I know of that used that :)
17:05:43 <SamB> ray: no, cloop ext2, I think
17:05:52 <idnar> haha
17:05:56 <ray> fat as in obese :)
17:06:20 <SamB> (wouldn't be much point in it's using ext3, now would there?)
17:08:05 <pumpkin> hmm
17:08:12 <mcnster> example [('a',1),('b',1),('a',2)] -> [(1,['a','b']),(2,['a'])]
17:08:31 <pumpkin> so what's a good strategy for "exploring" a multidimensional input space for benchmarking?
17:09:44 <Cale> well...
17:10:00 <pumpkin> lol, I guess it's a rather abstract question
17:10:55 <Cale> > M.fromListWith (++) . map (\(x,y) -> (y,[x])) $ [('a',1),('b',1),('a',2)]
17:10:57 <lambdabot>   fromList [(1,"ba"),(2,"a")]
17:11:04 <Cale> > M.toList . M.fromListWith (++) . map (\(x,y) -> (y,[x])) $ [('a',1),('b',1),('a',2)]
17:11:06 <lambdabot>   [(1,"ba"),(2,"a")]
17:11:48 <pumpkin> so say I want to benchmark a function with a single-dimensional (numerical) input, I can start with 1, and multiply by 2 until it gets too slow (with a timeout), and then sample the range more or less uniformly
17:11:54 <Cale> mcnster: how's that?
17:12:34 <mcnster> cale, i'm in my 2nd day of being awake, so you'll excuse me if i take a moment to grok :)
17:12:44 <Cale> pumpkin: Wouldn't you want a bunch of inputs of varying complexity?
17:13:11 <pumpkin> Cale: yeah, that's what I mean...
17:13:48 <Cale> pumpkin: Oh, I suppose you could compare algorithms by the largest input they can handle in a fixed amount of time
17:13:56 <Cale> But that seems funny :)
17:14:15 <pumpkin> well, the idea was to keep the benchmark to a reasonable time in all cases
17:14:29 <pumpkin> because things like factorial 10000 (like what's in the ghc testsuite) aren't always possible
17:14:48 <pumpkin> integer-simple would take hours to compute it in the current state
17:15:25 <mcnster> @hoogle fromListWith
17:15:26 <lambdabot> Data.IntMap fromListWith :: (a -> a -> a) -> [(Key, a)] -> IntMap a
17:15:26 <lambdabot> Data.Map fromListWith :: Ord k => (a -> a -> a) -> [(k, a)] -> Map k a
17:15:26 <lambdabot> Data.IntMap fromListWithKey :: (Key -> a -> a -> a) -> [(Key, a)] -> IntMap a
17:15:39 <pumpkin> Cale: still getting a sense of the complexity and coefficients
17:17:09 <pumpkin> Cale: does it seem silly?
17:17:22 <Cale> pumpkin: I think it's a reasonable thing to try :)
17:17:26 <ray> cale's one liner isn't especially fancy this time, he's just exploiting the natural properties of Map
17:17:42 <ray> i recognize it because i was exploiting Set earlier
17:18:37 <pumpkin> Cale: the idea was to write a "quickbench" that "explored" the input space with typeclasses a bit like quickcheck's Arbitrary, and presented timings from a bunch of samples in a reasonable time window
17:18:58 <pumpkin> so far I have a really simple interface to 1-d exploration
17:19:53 <pumpkin> but I'm trying to decide what a good way is to explore multidimensional input in such a way that will still reveal meaningful trends
17:20:25 <smorg> @faq Can haskell do what haskell cannot do?
17:20:25 <lambdabot> The answer is: Yes! Haskell can do that.
17:20:40 <ray> the actual answer is "occurs check &c"
17:21:28 <Cale> @ghc
17:21:29 <lambdabot> ghc says: You can get a PhD for explaining the True Meaning of this last construct
17:21:32 <Cale> @ghc
17:21:33 <lambdabot> ghc says: From-type of Coerce differs from type of enclosed expression
17:21:41 <Cale> @ghc
17:21:41 <lambdabot> ghc says: Can't match unequal length lists
17:22:11 <smorg> @gcc
17:22:12 <lambdabot> ghc says: GHC internal error
17:22:48 <Cale> (it's full of funny error messages and comments from GHC)
17:22:51 <Cale> @ghc
17:22:52 <lambdabot> ghc says: Only unit numeric type pattern is valid
17:22:54 <Cale> @ghc
17:22:55 <lambdabot> ghc says: On Alpha, I can only handle 4 non-floating-point arguments to foreign export dynamic
17:23:06 <thoughtpolice> applicative parsers rox my sox
17:23:13 <pumpkin> thoughtpolice: zomg
17:23:22 <pumpkin> thoughtpolice: u dun wit flaout3?
17:23:38 <ray> nice command
17:23:50 <jeffersonheard_h> okay.  I'm stumped.  completely.  stumped
17:23:50 <thoughtpolice> pumpkin: ftm, beat another game too while I was playing it
17:23:56 <pumpkin> lol
17:24:07 <mcnster> wow, that's pretty cool.  thanks again cale :)
17:24:08 <smorg> @faq Can haskell help Smorg understand Haskell?
17:24:08 <lambdabot> The answer is: Yes! Haskell can do that.
17:24:23 <jeffersonheard_h> I've been poking at this bug in hieroglyph all day and I've solved half a dozen others, but not the one I came to solve
17:24:38 <ray> @faq Can Haskell make UPS go faster?
17:24:38 <lambdabot> The answer is: Yes! Haskell can do that.
17:25:27 <jeffersonheard_h> does anyone care to look at why I seem to be missing saving the cache once per iteration?
17:29:43 <jeffersonheard_h> I'll take that as a no
17:32:09 <Cale> jeffersonheard_h: Well, if you posted a link, I would look at it, but I don't really understand what that means.
17:32:32 <malouin> why is the Identity monad not Applicative?
17:32:42 <Cale> malouin: Probably no good reason.
17:32:53 <smorg> > [ helpers | helpers <- people in channel, elem (people paying attention), elem (people who know the answer) ]
17:32:55 <lambdabot>   <no location info>: parse error on input `in'
17:33:08 <Cale> malouin: Other than that it existed prior to Applicative and nobody's added the instance.
17:33:23 <jeffersonheard_h> Cale: thanks.  I shall in a sec...
17:36:50 <malouin> does instance Applicative Identity where pure  = return ; (<*>) = ap make sense?
17:37:08 <pumpkin> that works for all Monads
17:37:13 <malouin> great!
17:37:20 <pumpkin> :)
17:37:29 <pumpkin> it's not necessarily the only valid instance for all Monads though
17:37:36 <malouin> @src ap
17:37:36 <lambdabot> ap = liftM2 id
17:37:42 <malouin> ah
17:37:53 <jeffersonheard_h> Cale: http://www2.renci.org/~jeff/hieroglyph/Graphics/Rendering/Hieroglyph/
17:38:47 <jeffersonheard_h> the problem is either in OpenGL/Compile.hs::compileText, OpenGL/Render.hs, or OpenGL.hs in the functions that actually call render
17:39:55 <jeffersonheard_h> basically i've got a texture cache for holding onto images so that youdon't have to reload them between frames.  speeds things up like 10x for medium sized images.
17:41:32 <jeffersonheard_h> but, the problem is that once the textures that are allocated have been expended, I start freeing textures from the cache, but they don't stay out of the cache between iterations
17:42:34 <jeffersonheard_h> it's a really odd little problem.  I've narrowed it down to the render function in OpenGL/Render.hs -- it has to happen before that function is finished
17:44:06 <jeffersonheard_h> I thought initially it was between calls to render, but since then I've discovered that's not correct -- it happens so long as there are multiple cache misses on the same call to render
17:44:15 <malouin> ...so... Text.Formlets stuff is parameterized by an (Applicative m, Monad m), but I don't see why I need it, so... Identity!
17:47:37 <ray> if monad were a subclass of applicative like it SHOULD be that wouldn't happen
17:48:13 <ray> you can blame those fat cats on wall str-i mean, haskell 98
17:54:52 <SamB> ray: we didn't HAVE applicative in Haskell 98
17:55:07 <SamB> I think it's much more realistic to complain about Functor ...
17:55:15 <TheColonial> :t (.*.)
17:55:16 <lambdabot> Not in scope: `.*.'
17:56:08 <Peaker> I think maybe   Functor => Applicative => Monad   subclassing is a different kind of subclassing than other kinds, in the sense that each subclass contains all the methods to be as powerful as its super-class.  Maybe this kind of sub-classing does not need to be tied to the definition of the class, but define-able separately, like type-classes and instances are definable separately from types
17:56:32 <ray> don't forget pointed, and i was thinking something similar
17:57:14 <Peaker> The methods in the Monad class don't really depend on Applicative's methods, as you can obviously reimplement <*> and pure as ap and return -- if there's no real dependency, why should it be a class restriction?  It should probably be a different kind of relationship between the classes
17:57:41 <ray> it's not something that can currently be expressed in haskell
17:57:49 <pumpkin> well, those should all be unified into one name?
17:57:50 <ray> it should be
17:57:51 <Peaker> yeah, it would be nice if it were
17:58:21 <ray> ap is used infix anyway, so just having <*> would be nice
17:58:24 <Peaker> pumpkin: of course, my point is that maybe a class restriction (=subclassing) is the wrong approach when your sub-class has all the power in its own methods to define all the super-class methods
17:58:30 <ray> and i prefer "pure" to "return"
17:58:34 <hatds> it is expressed by wrapped newtypes, basically
17:58:50 <Peaker> ray: how about "wrap" ?
17:59:01 <pumpkin> I don't like wrap
17:59:04 <ray> i was thinking of being able to include default definitions
17:59:06 <Peaker> pumpkin: why?
17:59:09 <ray> i still prefer pure
17:59:13 <ray> but return is terrible :)
17:59:36 <hatds> what about Eq and Ord then?
17:59:54 <Peaker> hatds: Similarly, I think
18:00:04 <ray> and also being able to define the methods of the superclass in instance declarations for the subclass
18:00:33 <ray> i should write something
18:00:34 <Peaker> hatds: the question is how these class relations should be expressed.  Perhaps an auto-deriving rule (That either disallows or is overridden by more-specific instances)
18:01:31 <ray> if i don't write something, i can't get decisively shot down by the ghc hackers
18:02:19 <hatds> I think if you took away this kind of subclassing then instance declarations would be messier... if 'a' is an instance of Eq and Ord what should the instance of Eq [a] be?
18:03:08 <hatds> well, I guess just using Eq
18:04:18 <Berengal> Thanks guys, you're a big help
18:04:40 <Berengal> (I was about to ask a question, but in doing so the answer, which had previously eluded me for quite a while, appeared)
18:04:54 <EvilTerran> hatds, well, Eq usually has a natural recursive definition for algebraic data types
18:05:05 <EvilTerran> Ord likewise, to a certain extent - see deriving (Eq, Ord)
18:05:10 <hatds> yea.. my example wasn't what I thought it was
18:07:03 <ray> hmm, copure isn't quite as nice sounding as pure
18:07:17 <pumpkin> pucore
18:07:30 <EvilTerran> pureco
18:07:39 <EvilTerran> ... (tm) programming languages. now with more pure!
18:07:45 <ray> category-extras has point and extract
18:09:20 <EvilTerran> Peaker, i thought the point of the Functor (=> Pointed) => Applicative => Monad heirarchy was that each class would only contain a couple of methods, but each class's semantic equations would involve methods of its superclasses
18:10:20 <ray> if you include pointed it's only one method each (bind is borderline)
18:10:24 <EvilTerran> so a definition of Monad would only need join or >>=, as fmap and pure are defined by virtue of the superclass constraint
18:10:57 <ray> the problem is you end up having to write 4 instances
18:10:58 <SamB> EvilTerran: it would be preferable to be able to instanciate several classes in one go
18:11:27 <SamB> ray: and typically, some of the superclass methods are the ones you'd want defaulted
18:12:00 <ray> if we want prettiness all around, something's got to give
18:12:01 <EvilTerran> i agree; got to get some class aliases going
18:12:04 * EvilTerran goes tobed
18:12:10 <Berengal> SamB: Can be done by going the other way for instances: instance Monad m => Applicative m => (Pointed m) => Functor m
18:12:36 <SamB> Berengal: what the?
18:12:59 <hatds> I'm wary of instances which don't peel off type constructors
18:13:26 <SamB> hatds: eh?
18:13:35 <Berengal> SamB: making a monad instance then automatically makes the type an instance of all the other classes, with default implementations
18:14:10 <SamB> Berengal: I don't think it's safe to do it that way
18:14:41 <hatds> SamB: instance Eq a => Eq [a] would be an example
18:15:05 <hatds> (reading right to left)
18:15:07 <Berengal> instance (Monad m) => Functor m where fmap = liftM
18:15:09 <SamB> hatds: well, that kind of thing doesn't make sense for Monad
18:15:13 <SamB> or Applicative
18:15:18 <SamB> or Functor
18:15:20 <SamB> or Pointed
18:15:28 <SamB> or CoPointed
18:15:33 <SamB> or CoMonad
18:15:33 <pumpkin> or ContraFunctor
18:15:42 <hatds> SamB: which is why I'm wary of using instance declarations to express a super-class like hierarchy
18:15:43 <pumpkin> or AppliCotive
18:15:45 <pumpkin> ;)
18:15:51 <SamB> what the hell?
18:15:57 <ray> ContraFunctor is fun
18:16:05 <SamB> what happened to putting Co at the beginning?
18:16:15 <ray> it went into cofashion
18:16:16 <pumpkin> well, CoApplicative didn't feel right
18:16:22 <pumpkin> SamCoB
18:16:37 <Cale> Coapplicative seems good to me
18:16:48 <SamB> yeah, and Alan x comaintains part of the Linux kernel
18:17:41 <hatds> is there a coapplicative?
18:18:16 <SamB> probably
18:18:32 <SamB> in Haskell? I have no idea
18:21:27 <BMeph_> Are there Pointed, non-Functor things?
18:21:41 <ray> monoids?
18:22:03 <byorgey> I guess it depends what you mean by Pointed.
18:22:06 <BMeph_> It reminds me of everything I dislike about for Arrow.
18:22:25 <BMeph_> S/for//
18:22:25 <ray> i guess it depends on what you mean by non-Functor
18:22:40 <byorgey> the way Pointed is usually used in a Haskell context it is an abbreviation for 'pointed functor', so the answer would be no.
18:22:53 * pumpkin pointed
18:23:00 <byorgey> but you could imagine having it just mean "any type for which we can pick out a distinguished element"
18:23:26 <SamB_XP> mattam: help! http://mattam.org/repos/coq/prelude/html/index.html is down!
18:24:10 <BMeph_> ray, byorgey: I meant where there's an a -> p a, but not an (a -> b) -> (p a -> p b); hmm, both things are stuff to ponder. :)
18:24:20 <SamB_XP> BMeph: looks like Pointed is a subclass of Functor: http://mattam.org/repos/coq/prelude/Functor.v
18:25:59 <SamB_XP> well, there might be things that have a function with "point"'s signature but not "fmap"'s
18:26:14 <ray> well, a -> p a is easy if you have any data constructors that take arguments
18:26:28 <ray> finding things that aren't functors is probably harder
18:26:42 <ray> er, finding things like that
18:27:13 <byorgey> BMeph_: sure, for example, if  p a = a -> Int
18:28:17 <byorgey> maybe that's sort of cheating though, since the  a -> p a  would just have to be 'const (const 3)' or something like that
18:28:38 <BMeph_> I just "know" that Pointed + Applicative gives you fmap anyway, so I'm trying to see if there's another way to put all of those types together.
18:39:13 <Berengal> Well, in haskell at least Set isn't a functor, but it could be pointed... maybe...
18:39:24 <mattam> SamB_XP: ah yeah... I need to regenerate the doc it seems
18:39:42 <Berengal> If there was a fromSingletonSet function
18:41:56 <mattam> The Pointed hierarchy comes from category-extras, I didn't invent anything.
18:42:05 <pumpkin> Berengal: it could be an RFunctor
18:42:28 <ray> set really is a functor, it's just that ord constraint getting in the way
18:42:36 <pumpkin> and that's what the R deals with
18:42:36 <ray> which is what pumpkin means
18:42:46 <pumpkin> @hackage rmonad
18:42:47 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/rmonad
18:42:59 <BMeph> Sets can be empty, so that doesn't work. Maybe it's CoPointed, though? ;)
18:43:39 <ray> other way around
18:43:52 <pumpkin> I think Pointed should be called Pointy
18:43:53 <pumpkin> it's cuter
18:44:23 <Berengal> I think Functor should be called Functron
18:44:58 <Berengal> Hmm, Applicatron also sounds nice
18:46:09 <ray> i think they should be called Mappable, Purable, Appable, and Joinable
18:46:17 <pumpkin> lol
18:46:34 <BMeph> CT bots, from the planet Funcatron! ;p
18:46:41 <Berengal> s/pure/purè/ ?
18:48:08 <Berengal> We need an Acme category on hackage
18:48:48 <ray> category-extras-extras: nonsense too abstract for category-extras
18:50:48 <byorgey> is MonadSupply (from http://www.haskell.org/haskellwiki/New_monads/MonadSupply) packaged anywhere?
18:52:03 <pumpkin> can't we just use a captcha instead of disabling signup?
18:52:11 <pumpkin> (to the wiki)
18:52:44 <SamB_XP> I think we should just put the name of the person you have to ask for an account in text on the page where you would ordinarily sign up
18:52:49 <ray> there's a cmptcha instead
18:53:01 <BMeph> pumpkin: We could if you'd hurry up and write a haskell-y captcha package! ;)
18:53:02 <SamB_XP> and anyone smart enough to figure out how to email that person can have an account
18:53:14 <SamB_XP> how's that for a captcha?
18:53:36 <SamB_XP> (of course, they also have to ask for an account on haskellwiki in that email ;-)
18:54:01 <ray> otherwise the viagra spammers would get in
18:54:11 <SamB_XP> quite
19:11:26 <roconnor> @djinn () -> ()
19:11:27 <lambdabot> f a = a
19:13:06 <sjanssen> @djinn a -> b
19:13:06 <lambdabot> -- f cannot be realized.
19:14:09 <pumpkin> little does djinn know, unsafeCoerce to the rescue
19:14:16 <pumpkin> to prove anything and everything!
19:14:49 <idnar> haha
19:14:55 <idnar> ex falso, quodlibet
19:18:39 <adu> @djinn (a, b) -> b
19:18:40 <lambdabot> f (_, a) = a
19:18:43 <roconnor> @src Const
19:18:43 <lambdabot> Source not found.
19:18:57 <adu> @djinn (a, b) -> a
19:18:57 <lambdabot> f (a, _) = a
19:19:13 <adu> @djinn a -> b -> a
19:19:13 <lambdabot> f a _ = a
19:20:30 <pumpkin> @@ @djinn @type on
19:20:32 <lambdabot>  f a b c _ = a (b c) (b c)
19:21:09 <BMeph> @type on
19:21:10 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
19:21:28 <pumpkin> does the programmatic interface to djinn allow us to enumerate all functions?
19:21:49 <SamB_XP> pumpkin: ALL functions?
19:21:55 <SamB_XP> you must be kidding!
19:22:25 * SamB_XP doesn't think djinn accepts types suitable for such in any case
19:22:43 <pumpkin> I meant all functions that fit :P
19:23:08 <pumpkin> and yeah, even if there are infinite ones, I don't see why I shouldn't be able to enumerate them
19:23:33 <SamB_XP> well, there *are* types that have countless functions
19:23:45 <SamB_XP> which is to say, uncountably many
19:24:05 <SamB_XP> that is, you can't give them each an ordinal
19:24:12 <pumpkin> I know :P
19:24:48 <pumpkin> @djinn Integer -> Integer
19:24:48 <lambdabot> Error: Undefined type Integer
19:24:54 <SamB_XP> yeah, I'm half kidding and half just not sure I'm using the right terminology, with my over-repetetiveness ;-)
19:26:22 <pumpkin> I haven't heard much about the GSOC projects recently
19:27:07 <dino-> I still feel confused about seq. Specifically, when would I use it myself as opposed to using ($!)
19:27:23 <pumpkin> sometimes you want to force something without evaluating a function, I guess?
19:27:35 <pumpkin> *applying
19:32:19 * adu <3 λ
19:32:30 <byorgey_> @src ($!)
19:32:30 <lambdabot> f $! x = x `seq` f x
19:32:40 <adu> byorgey!
19:32:51 <byorgey_> dino-: $! is just a convenient shorthand for seq, essentially
19:32:54 <byorgey_> adu!
19:33:03 <adu> byorgey_: how are you doing?
19:33:25 <byorgey> adu: I'm very well, enjoying summer. =)  how are you?
19:33:29 <adu> I started a blog, wanna see?
19:33:31 <dino-> But I feel like just chalking it up as seq exists basically so we can have ($!) is not right.
19:33:36 <byorgey> adu: sure!
19:33:42 <adu> http://straymindcough.blogspot.com/
19:33:47 <adu> its about Haskell and XML mostly
19:34:02 <byorgey> dino-: no, I mean, $! just encapsulates a common pattern of using seq
19:34:13 <byorgey> dino-: so there's no particular reason to use seq vs. $!
19:34:21 <dino-> But what's the other pattern(s)?
19:34:27 <dino-> er, what is/are
19:34:30 <monochrom> Suppose I want "f x y z" and I want to force y but not x or z. How would you write it with $! ?  It's much easier with seq.
19:34:37 <adu> byorgey: I also am between jobs... got an interview in 3 days
19:34:59 <byorgey> adu: ah, good luck with that
19:35:06 <adu> thanks
19:35:10 <byorgey> adu: coming to Hac phi? =)
19:35:20 <adu> byorgey: dunno, what is it?
19:35:49 <byorgey> a Haskell hackathon, in Philadelphia!
19:35:50 <dino-> hm, so you're saying it could be  y `seq` f x y z
19:35:52 <byorgey> http://haskell.org/haskellwiki/Hac_%CF%86
19:36:51 <byorgey> ok, off to bed, night all
19:36:58 <dino-> byorgey: Thank you
19:37:02 <monochrom> Yes I would just write y `seq` f x y z
19:37:26 <dino-> monochrom: So simple, but I was having a crazy time thinking about other uses than ($!) expresses. :o
19:37:31 <dino-> monochrom: Thank you
19:37:50 <adu> byorgey: I registered
19:38:12 <pumpkin> @hoogle getCPUTime
19:38:13 <lambdabot> System.CPUTime getCPUTime :: IO Integer
19:38:37 <dino-> As far as when you know you need these things, that's really more like you get into space leakage situation, I'm guessing. Or your profiling is pointing to it.
19:49:14 <Marake> What is this channel?
19:52:35 <pumpkin> I love curiosity
19:52:40 <jeff_s_> why?
19:53:35 <Berengal> Presumably because he hates cats
19:53:55 <p_l> Berengal: or loves, depending on version
19:54:22 <Berengal> p_l: Maybe a love-hate relationship?
19:55:08 <p_l> Berengal: or trains future cat army :P
19:56:52 * ceilingcat iz watchin u
19:58:24 <Apocalisp> > unsafePerformIO $ print "Can haz IO"
19:58:26 <lambdabot>   Not in scope: `unsafePerformIO'
19:58:39 <ceilingcat> no can not haz IO
19:59:40 <Apocalisp> ceiling cat iz watching u mutate ur data
20:00:14 <pumpkin> my quickbench is working hard now
20:00:35 <pumpkin> mmorrow: I haz quickbench almoast!
20:01:01 <mmorrow> pumpkin: ?
20:01:21 <pumpkin> my quickcheck-inspired benchmarking system
20:01:45 <mmorrow> pumpkin: oh nice, so you mean you;ve almost got it packaged?
20:02:01 <pumpkin> oh no, I still need to figure out some things, and I haven't been writing it as a separate library
20:02:14 <pumpkin> it's just that my integer benchmarking suite got overengineered so I decided to give it a name
20:02:19 <mmorrow> hehe
20:02:38 <SamB_XP> lol
20:08:06 <pumpkin> > maximum []
20:08:08 <lambdabot>   * Exception: Prelude.maximum: empty list
20:08:09 <pumpkin> grr
20:08:13 <pumpkin> damn partial functions
20:08:24 <pumpkin> I NEED MOAR
20:09:14 <thoughtpolice> pumpkin: ORLY?
20:09:18 <pumpkin> YARLY
20:09:27 <pumpkin> MUST HAZ MOAR
20:10:00 <pumpkin> @src maximum
20:10:00 <lambdabot> maximum [] = undefined
20:10:01 <lambdabot> maximum xs = foldl1 max xs
20:10:50 <pumpkin> @type foldl' (liftA2 max) Nothing
20:10:51 <lambdabot> forall a. (Ord a) => [Maybe a] -> Maybe a
20:11:17 <pumpkin> @type foldl' (liftA2 max) Nothing . map Just
20:11:19 <lambdabot> forall a. (Ord a) => [a] -> Maybe a
20:12:30 <thoughtpolice> oh yeah and like I said earlier: applicative parsers rox my sox
20:12:45 <pumpkin> lol
20:12:50 <pumpkin> which one are you using?
20:12:57 <thoughtpolice> i was playing with attoparsec
20:16:58 <pumpkin> clearly that function sucks
20:16:59 <pumpkin> dammit
20:17:13 <pumpkin> not sure why I thought it would work just cause it had the right type :P
20:17:31 <pumpkin> > foldl' (liftA2 max) Nothing . map Just $ []
20:17:32 <dino-> pumpkin: I was just realizing that too in ghci, non workingness. :D
20:17:32 <lambdabot>   Nothing
20:17:37 <pumpkin> > foldl' (liftA2 max) Nothing . map Just $ [1, 2, 3]
20:17:38 <lambdabot>   Nothing
20:17:39 <pumpkin> lol
20:18:19 <dino-> Because the right type is so often a harbinger of success.
20:19:56 <pumpkin> dammit, there must be an elegant way to write this
20:20:10 <pumpkin> that doesn't involve hardcoding a Nothing for empty lists
20:20:43 <pumpkin> @type maybeToList
20:20:45 <lambdabot> forall a. Maybe a -> [a]
20:23:31 <Berengal> pumpkin: For an extra Bounded constraint, you can have a monoid
20:23:52 <pumpkin> yeah, but I don't really want one
20:24:13 <pumpkin> I'm mostly working with Integers here
20:24:26 <pumpkin> anyway, I just wrote a total maximum in Maybe
20:24:28 <pumpkin> *sigh*
20:24:35 <pumpkin> no golfing to be seen :(
20:24:52 <Berengal> if' <$> null <*> const Nothing <*> foldl1' max
20:25:14 <pumpkin> lol
20:25:30 <pumpkin> I thought of doing something like that but didn't want to write if'
20:25:47 <pumpkin> it should be in the prelude, and the if syntax should be eradicated!
20:25:54 <pumpkin> it's too conventional!
20:25:56 <Berengal> Indeed!
20:26:11 <Berengal> We don't need no stinkin' ifs!
20:27:49 <Berengal> We need a fold-with-default
20:28:13 <Berengal> foldx1-with-default that is
20:28:21 <Berengal> like maybe...
20:28:24 <pumpkin> yeah
20:28:59 <RyanT50001> has anyone tried doing OpenGL stuff on ubuntu (in haskell)?
20:29:31 <Berengal> unsafePerformIO (evaluate $ Just . foldl1' max list) `catch` const Nothing
20:29:32 <RyanT50001> glxgears runs fine, and the output of glxinfo doesn't have any problems (that I can detect, anyhow), but haskell-based opengl stuff is all strange
20:29:45 <pumpkin> Berengal: lol, not a fan of those approaches :)
20:29:53 <RyanT50001> it either flashes a lot (~30 hz) or doesn't ever redraw window borders
20:30:33 <Berengal> pumpkin: That's okay, I'll put it in a library :P
20:30:43 <pumpkin> oh okay, then it's fine :P
20:30:52 * Berengal creates a new file: Acme/Tricks.hs
20:31:35 <Berengal> By the way, anyone have any nice instances for Acme.Orphanage?
20:32:13 <SamB_XP> how about Acme.Dynamite or Acme.Fan or Acme.DistancePaintedOnABrickWall
20:32:41 <Berengal> I wouldn't know what to put in them...
20:33:43 <SamB_XP> but you DO know what they'll end up doing to the coyote, yes?
20:34:19 <pumpkin> :t when
20:34:20 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
20:34:32 <pumpkin> that's an annoying type signature
20:35:00 <pumpkin> why can't it be Bool -> m a -> m a ?
20:35:13 <SamB_XP> because it wouldn't know what to return when NOT
20:35:21 <pumpkin> stick MonadPlus on
20:35:31 <SamB_XP> you mean MonadFail?
20:35:39 * thoughtpolice attemps to build ThreadScope to look at DPH programs...
20:35:49 <pumpkin> MonadFail doesn't exist though :(
20:35:56 <pumpkin> ceiling cat disapproves
20:36:21 <mmorrow> @let f <!> a = join (f `ap` a); infixr 1 <!>
20:36:23 <lambdabot>  Defined.
20:36:23 * SamB_XP tries to figure out what that has to do with ^|^
20:36:46 <pumpkin> @type (<!>)
20:36:48 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => m (a -> m a1) -> m a -> m a1
20:36:50 <mmorrow> @type \f a b c d -> f <$> a <*> b <*> c <!> d
20:36:52 <lambdabot> forall a a1 a2 a3 (m :: * -> *) a11. (Applicative m, Monad m) => (a -> a1 -> a2 -> a3 -> m a11) -> m a -> m a1 -> m a2 -> m a3 -> m a11
20:36:58 <mmorrow> bindN
20:37:03 <pumpkin> ooh
20:37:14 <mmorrow> @type \f a b c -> f <$> a <*> b <!> c
20:37:14 <pumpkin> I like the operator name too
20:37:15 <lambdabot> forall a a1 a2 (m :: * -> *) a11. (Applicative m, Monad m) => (a -> a1 -> a2 -> m a11) -> m a -> m a1 -> m a2 -> m a11
20:37:24 <mmorrow> heh, yeah it fits nicely
20:37:29 <mmorrow> join!!!!
20:38:07 <monochrom> /join
20:38:10 <monochrom> /part
20:38:46 <monochrom> Hmm! "part" could be a nice name for an operation in co-monads!  part :: cm a -> cm (cm a)  :)
20:39:01 <mmorrow> heh
20:39:04 <pumpkin> @let part x = x >>= const
20:39:06 <lambdabot>  Defined.
20:39:07 <monochrom> question: "why is it called part?" answer: "because I learned in on IRC"
20:39:14 <pumpkin> oh
20:39:23 <pumpkin> dammit, I stole your comonadic operation, sorry :/
20:39:49 <SamB_XP> @type part
20:39:50 <lambdabot> forall b a. (b -> a) -> b -> a
20:39:53 <pumpkin> :P
20:39:59 <pumpkin> really useful, eh
20:40:01 <SamB_XP> that's pretty dumb looking ...
20:40:04 <mmorrow> > fix part
20:40:06 <lambdabot>   Overlapping instances for GHC.Show.Show (b -> a)
20:40:06 <lambdabot>    arising from a use of `...
20:40:08 <mmorrow> > fix part 99
20:40:14 <lambdabot>   mueval-core: Prelude.read: no parse
20:40:14 <lambdabot>  mueval: ExitFailure 1
20:40:22 <SamB_XP> @pl part x = x >>= const
20:40:22 <SamB_XP>  in part
20:40:23 <lambdabot> part = (const =<<)
20:40:33 <pumpkin> wow, that's really smart of it :P
20:40:36 <SamB_XP> oh, woops
20:40:42 <SamB_XP> I meant to say "let
20:40:50 <SamB_XP> and not put the newline in there
20:40:58 <SamB_XP> but it worked out okay ...
20:41:13 <SamB_XP> but still, it's not going as far as it could!
20:41:25 <SamB_XP> > part 1
20:41:26 <lambdabot>   No instance for (GHC.Num.Num (b -> a))
20:41:26 <lambdabot>    arising from the literal `1' at <...
20:41:34 <SamB_XP> > part (+1)
20:41:35 <lambdabot>   Overlapping instances for GHC.Show.Show (b -> b)
20:41:36 <lambdabot>    arising from a use of `...
20:41:38 <SamB_XP> > part (+1) x
20:41:40 <lambdabot>   x + 1
20:41:54 <SamB_XP> @check ($) == part
20:41:55 <lambdabot>   Not in scope: `part'
20:42:03 <SamB_XP> aww
20:42:13 <SamB_XP> oh, but the == wouldn't have worked ...
20:44:39 <pumpkin> > part (+1) 2
20:44:41 <lambdabot>   3
20:44:45 <pumpkin> ZOMG!
20:46:01 <thoughtpolice> whoa
20:46:20 <malouin> Is there some name for getting a value out of a monad, ie namethisfunc (Identity a) = a
20:46:34 <roconnor> @type runIdentity
20:46:35 <lambdabot> forall a. Identity a -> a
20:46:35 <pumpkin> for certain specific monads yes, but not in general
20:48:02 <malouin> is it usually called runMymonad?
20:48:19 <malouin> I think runMonad is not what I am looking for.
20:48:21 * jmcarthur realizes he is creating something which may venture into unholy territory
20:48:22 <pumpkin> @hoogle runST
20:48:23 <lambdabot> Control.Monad.ST runST :: ST s a -> a
20:48:23 <lambdabot> Control.Monad.ST.Lazy runST :: ST s a -> a
20:48:23 <lambdabot> Data.Array.ST runSTArray :: Ix i => ST s (STArray s i e) -> Array i e
20:48:51 <pumpkin> jmcarthur: quick, kill it with fire!
20:48:55 <pumpkin> jmcarthur: what is it?
20:48:58 <malouin> ok,nm.
20:49:17 <pumpkin> malouin: but in general, it's not even meaningful to ask to get a value out of a monad
20:49:32 <thoughtpolice> threadscope is really neat
20:49:37 <thoughtpolice> although it does still need a lot of work
20:49:55 <jmcarthur> pumpkin: some of my test code: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5708#a5708
20:50:24 <malouin> I think I see how this works.
20:50:54 <wagle> @zow
20:50:54 <lambdabot> YOU!!  Give me the CUTEST, PINKEST, most charming little VICTORIAN
20:50:55 <lambdabot> DOLLHOUSE you can find!!  An make it SNAPPY!!
20:50:57 <malouin> Incidentally, I understand that IO is a one way monad, but what is to prevent me from writing "pluckIO IO a = a"?
20:50:58 <jmcarthur> essentially i'm using IO to fill in the thunks after binding the variable
20:51:03 <jmcarthur> one at a time
20:51:07 <pumpkin> malouin: the fact that the constructor isn't public
20:51:17 <pumpkin> @hoogle unsafePerformIO
20:51:18 <lambdabot> Foreign unsafePerformIO :: IO a -> a
20:51:18 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
20:51:21 * pumpkin whistles
20:51:29 <malouin> pumpkin: that would do it!
20:51:46 <pumpkin> malouin: but in general don't use it unless it would be pure to do so otherwise (but something's in the way)
20:51:46 <jmcarthur> mentally substitute True and False with Cons and Nil
20:52:05 <pumpkin> malouin: it'll break some assumptions the compiler makes if you use it impurely and will lead to all sorts of headaches, it's not just a philosophical thing
20:52:11 <malouin> I'm not doing that!
20:52:15 <pumpkin> just making sure :)
20:52:43 <malouin> I'm using formlets, it wants a monad.  I gave it Identity.  I wasn't sure how to get a value out of Identity.
20:52:58 <aavogt> @hoogle Identity
20:52:58 <lambdabot> module Control.Monad.Identity
20:52:58 <lambdabot> Control.Monad.Identity newtype Identity a
20:52:58 <lambdabot> Control.Monad.Identity Identity :: a -> Identity a
20:53:04 <pumpkin> malouin: ah okay :)
20:53:14 <malouin> so I wrote "pluckIdentity Identity a = a", but now I see that that is just called runIdentity
20:53:50 <jmcarthur> with overlapping instances i could get rid of the map getValue part
20:54:10 <thoughtpolice> http://img198.imageshack.us/img198/7665/threadscopeosx.png <- mac view of threadscope
20:54:16 <thoughtpolice> unfortunately the interface is horribly buggy
20:54:28 <thoughtpolice> but it does display the parallel execution nicely
20:54:50 <jmcarthur> thoughtpolice: that's pretty sexy though
20:55:08 <thoughtpolice> the binary trees dph benchmark with GHC HEAD is just as fast as parallel strategies with HEAD
20:55:16 <thoughtpolice> it was a few seconds slower with 6.10.1 or so
20:55:49 <thoughtpolice> although, the parallel strategies code seems to have changed a little, which is something I have not accommodated for in the dph version
20:57:22 <pumpkin> we need a repeatM
20:57:32 <jmcarthur> @hoogle repeatM
20:57:32 <lambdabot> No results found
20:57:43 <Cale> :t forever
20:57:44 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
20:57:52 <pumpkin> not the same though
20:58:01 <jmcarthur> pumpkin: i hear no cries of terror. does my code not frighten you?
20:58:02 <Cale> I suppose
20:58:19 <pumpkin> jmcarthur: maybe I didn't look closely enough, let me look again :)
20:58:36 <jmcarthur> i guess in a perverted way it could be considered pure. no more pure than unsafeInterleaveIO, for sure
20:58:41 <Cale> I suspect there wouldn't be too many monads in which repeatM would be all that useful...
20:58:47 <jmcarthur> heh
20:58:59 <pumpkin> there are several monads for which forever is pretty useless too aren't there?
20:59:16 <jmcarthur> @src forever
20:59:17 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
20:59:20 <Cale> > (sequence . repeat $ reverse) "hello"
20:59:22 <lambdabot>   ["olleh","olleh","olleh","olleh","olleh","olleh","olleh","olleh","olleh","o...
20:59:30 <Cale> It works in Reader
20:59:41 <Cale> and probably Identity
21:00:05 <pumpkin> I'm looking for something I can feed randomRIO to
21:00:08 <jmcarthur> :t iterateM
21:00:09 <lambdabot> Not in scope: `iterateM'
21:00:10 <Cale> pumpkin: But with forever, the focus is on effects, since it never produces a result.
21:00:15 <pumpkin> yeah, exactly
21:00:25 <jmcarthur> @hoogle iterateM
21:00:25 <lambdabot> No results found
21:00:30 <jmcarthur> i thought one existed...
21:00:44 <Cale> So it's actually useful in all the monads in which repeatM is useless, and vice versa.
21:00:51 <pumpkin> jmcarthur: I don't quite get it, although I sort of see what's happening
21:01:03 <jmcarthur> pumpkin: not sure if you saw my explanation earlier
21:01:21 <pumpkin> oh I see
21:01:43 <pumpkin> sort of a mutable list?
21:01:49 <jmcarthur> not mutable
21:01:50 <jmcarthur> write-once
21:01:53 <pumpkin> ah
21:01:54 <jmcarthur> from IO
21:02:01 <pumpkin> what if you write twice?
21:02:03 <jmcarthur> but the list itself is a pure value
21:02:09 <jmcarthur> epic fail if you write twice
21:02:18 <pumpkin> seems like you could stick it in ST in that case
21:02:32 <jmcarthur> the point is that you can pass the list around before it is complete
21:02:35 <pumpkin> ah
21:02:37 <jmcarthur> as a pure value
21:02:44 <pumpkin> oh
21:03:09 <pumpkin> so it's like passing around a volatile explosive
21:03:13 <jmcarthur> since it is built one thunk at a time, you can even use parts of it when other parts aren't done
21:03:23 <jmcarthur> basically
21:03:51 <pumpkin> I feel there should be a minimumMaximum function
21:05:08 <pumpkin> @src sequence
21:05:09 <lambdabot> sequence []     = return []
21:05:09 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
21:05:09 <lambdabot> --OR
21:05:09 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
21:08:14 <jmcarthur> there, comments http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5708#a5710
21:22:16 <RyanT50001> is there any way to get -prof to output wall-clock time instead of user time?
21:22:46 <RyanT50001> (i'm trying to track down why something's spending ~99.9% of its time blocking)
21:24:36 <pumpkin> what's an efficient way of taking the elements of a list until the sum that far exceeds a particular value?
21:25:10 <RyanT50001> pumpkin: using an accumulator?
21:25:20 <RyanT50001> there's probably some syntactically-awesome way of doing that that i don't know
21:25:31 <pumpkin> well, I'd prefer not to recurse by hand
21:25:58 <pumpkin> I guess I could foldl and stop asking for the next element
21:26:52 <pumpkin> but then I'd need to build the list myself
21:26:56 <ClaudiusMaximus> > let xs = [1,2,3,4] in takeWhile ((<5) . fst) (zip (scanl1 (+) xs) xs)
21:26:57 <lambdabot>   [(1,1),(3,2)]
21:27:14 <pumpkin> yeah, I thought of the scanl but that seemed inefficient
21:27:17 <pumpkin> or is it not?
21:27:30 <pumpkin> I guess it wouldn't be
21:30:19 <dibblego> how can one use lambdabot to quantify on functions using @check since overlapping instances for Show?
21:30:54 <sjanssen> dibblego: fix lambdabot's imports?
21:32:24 <dibblego> I wonder why there were broken
21:32:38 <sjanssen> it's been like that for some time
21:42:37 <pumpkin> is there a good way to get unsafeInterleaveIO to get me part of a mapM on an infinite list?
21:42:54 <pumpkin> or is that not what it does?
21:43:52 <ClaudiusMaximus> @src getContents
21:43:52 <lambdabot> getContents = hGetContents stdin
21:44:15 <ClaudiusMaximus> @src hGetContents
21:44:16 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
21:45:54 <ClaudiusMaximus> > let a 0 n k = (n+1, k+1) ; a m 0 k = a (m-1) 1 (k+1) ; a m n k = let (a', k') = a m (n-1) k in a (m-1) a' (k' + 2) ; work m n = snd (a m n 0) in work 3 3
21:45:55 <lambdabot>   3619
21:46:00 <pumpkin> ah well, I can just replicateM it
21:46:24 <ClaudiusMaximus> is there a name for that function (amount of work done by ackermann's function)?
21:59:04 * Hunner wonders how `func x | "foo" `isPrefixOf` x = ...` works
22:04:48 <Berengal> @src mapM
22:04:48 <lambdabot> mapM f as = sequence (map f as)
22:05:04 <Berengal> @src sequence
22:05:04 <lambdabot> sequence []     = return []
22:05:04 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
22:05:04 <lambdabot> --OR
22:05:04 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
22:17:09 <RyanT50001> so, i'm profiling this program, and i run it for like 30 seconds
22:17:34 <RyanT50001> and then the profiling output says that it's been running for .06 seconds
22:17:46 <RyanT50001> 3 ticks @ 20ms/tick
22:17:58 <RyanT50001> i presume it's blocking on something
22:18:02 <RyanT50001> how can i debug this?
22:18:54 <asoare> hi guys, I'm having a problem with gtk2hs, can someone please help me ? http://pastebin.com/d67647e90 - nothing happens when I select a file :-s
22:20:36 <araujo> asoare, i recommend you to use fileChooserDialog
22:21:28 <asoare> araujo: make a button and onClicked => launch a fileChooserdialog ?
22:21:45 <sclv_> RyanT50001: does it use mvars?
22:21:48 * araujo also points asoare to check the himerge code which use extensively these functions
22:21:58 <sclv_> or does it use io? and if so does it use -threaded?
22:22:01 <RyanT50001> sclv_: almost certainly; it's FRP
22:22:24 <sclv_> does it use Reactive?
22:23:01 <RyanT50001> sclv_: yeah
22:23:04 <asoare> thanks
22:23:23 <sclv_> is it a problem that it blocks, or is it just weird profiling output?
22:23:32 <RyanT50001> it's a problem that it blocks
22:23:41 <RyanT50001> it should be an FPS display
22:23:52 <RyanT50001> but it only updates like once every 10 seconds at best
22:24:36 <sclv_> sorry i don't have better advice, but i'd start by simplifying it, and especially looking for recursive dependencies.
22:24:39 <araujo> asoare, fileChooserDialog already connects signals to buttons
22:24:50 <RyanT50001> sclv_: well, the problem is that my code is quite simple
22:25:05 <RyanT50001> sclv_: and i'm really looking to improve Reactive itself
22:25:09 <araujo> asoare, so yeah, you only need to create the fileChooserDialog and connects a signal handler to it
22:25:13 <RyanT50001> i.e.: by making situations like this harder to run into
22:25:18 <RyanT50001> and i also want to understand reactive
22:25:35 <RyanT50001> so i want to figure out how to track down whatever's blocking, if possible
22:25:52 <RyanT50001> is there really no way to track wall-clock time in the Haskell profiler?
22:26:35 <asoare> araujo: i want a main window, with a few buttons and when I press a button I want it to launch a FileChooserDialog, so I think I need my buttons as well :)
22:26:49 <sclv_> the one thing i can think of is defining lots of trace calls (carefully, so they evaluate each time a value is updated, say) and littering them about.
22:27:26 <sclv_> attaching them to your various reactive values.
22:27:30 <RyanT50001> sclv_: hm, alright
22:28:30 <araujo> asoare, the fileChooserDialog includes its own buttons ..... you specify them during its creation
22:29:09 <araujo> asoare, now, if you are talking about other buttons, sure, you need to create other widgets buttons manually, but the fileChooserDialog makes this easy for its own buttons, it is pretty standard
22:29:24 <asoare> araujo: yes, I know what you're talking about, but I need other windows apart from the Dialog in my program, anyway, I know what to do, thanks for you help ;)
22:29:54 <pumpkin> ugh, underscored module names! http://hackage.haskell.org/packages/archive/game-tree/0.1.0.0/doc/html/Data-Tree-Game_tree-Game_tree.html
22:30:12 <araujo> asoare, correct, if you need more buttons in other widgets, you have to do them manually, fCD is just a convenient function for a standard file chooser, welcome
22:37:35 <Cale> asoare: glade is a handy way to create user interfaces if you're using gtk2hs
22:43:21 <mxc> good morning..
22:43:40 <mxc> just curious, performance wise, how does Rational compare with Floats and Doubles?
22:44:33 <mxc> since it uses Integers and not Ints, seems like it might be worse.. on the other hand, integer ops are faster than floating point, so not sure
22:45:57 <sjanssen> mxc: they probably compare rather poorly
22:46:22 <sjanssen> mxc: the fraction is simplified after each operation, which isn't terribly fast
22:46:23 <quicksilver> very poorly I imagine.
22:46:50 <ClaudiusMaximus> @hoogle Double -> Rational
22:46:50 <lambdabot> Prelude toRational :: Real a => a -> Rational
22:46:51 <lambdabot> Data.Ratio approxRational :: RealFrac a => a -> a -> Rational
22:46:51 <lambdabot> Prelude floatRadix :: RealFloat a => a -> Integer
22:46:59 <quicksilver> integer ops aren't *that* much faster than floating point, if your code generator is good.
22:48:19 <mxc> thinking about it, arb precision int ops are probably worse
22:49:54 <quicksilver> much worse, yes.
22:49:59 <quicksilver> they involve function calls!
22:50:22 <_willard> Can anyone answer a quick question? I am looking for a function in the standard library which tokenises (splits into parts) a list according to a predicate. It would (ideally) have the type (a -> Bool) -> [a] -> [[a]]. Any ideas?
22:50:41 <Tsion> @hoogle (a -> Bool) -> [a] -> [[a]]
22:50:41 <lambdabot> Distribution.Simple.Utils breaks :: (a -> Bool) -> [a] -> [[a]]
22:50:42 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
22:50:42 <lambdabot> Prelude filter :: (a -> Bool) -> [a] -> [a]
22:51:13 <ClaudiusMaximus> @hoogle Data.List.Split
22:51:14 <lambdabot> Data.List splitAt :: Int -> [a] -> ([a], [a])
22:51:14 <lambdabot> Data.List genericSplitAt :: Integral i => i -> [b] -> ([b], [b])
22:52:00 <ClaudiusMaximus> @type groupBy
22:52:01 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
22:52:10 <mornfall> Almost. :)
22:52:39 <mornfall> _willard: Does your predicate say True -> drop this element and break the list here?
22:53:20 <mornfall> _willard: (with groupBy, the predicate says False -> break between these two elements...)
22:54:10 <mxc> weir,d i couldn't find breaks
22:54:16 <mxc> I just stick this in my code:  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5717#a5717
22:54:25 <_willard> mornfall: @True->drop: That would be preferable, although the reverse case would be easy to work with as well.
22:54:27 <mornfall> mxc: It's in the Cabal lib.
22:54:56 <mornfall> _willard: Well, the question is whether you want to drop and break, or break between elements. The former case is probably not in the standard lib for whatever reason...
22:55:09 <mornfall> It does exist for bytestrings though.
22:55:32 <mxc> mornfail: I realize from the module, but i'm looking for that function in the haddock docks for that module and dont see it
22:55:41 <mxc> i'm on 6.10.1, i wonder if its new
22:56:03 <mxc> (about it being in the cabal libs)
22:57:24 <mornfall> Dunno.
23:00:33 <_willard> mornfall: Great, thanks
23:01:00 <mornfall> The best I invented so far is split p = map (dropWhile p) . groupBy (curry $ not . p . snd)  :)
23:03:48 <_willard> mornfall: Then this makes for a challenging exercise for my students ;-)
23:04:13 <_willard> mornfall: (... one they cannot easily Google away from, at least)
23:04:47 <mornfall> :)
23:06:10 <_willard> mornfall: I got filter (/= " ") (groupBy (\x y -> x /= ' ' && y /= ' ') "Hello, Dolly") , although that runs through the list twice.
23:06:34 <_willard> mornfall: (umm, "Hello, Dolly" is a test string)
23:11:48 <mornfall> _willard: Hard to reformulate with a generic predicate though, seems to me.
23:11:57 <mornfall> Anyway, breakfast time. :) See you around...
23:13:50 <Hunner> What do I need to put on the command line to use this: "Could not find module `Control.Monad.Reader' it was found in multiple packages: monads-fd-0.0.0.1 mtl-1.1.0.2"
23:14:43 <Berengal> _willard: The "split" package provides for most of your splitting needs
23:15:14 <_willard> mornfall: @ generic predicate: The definition tok t xs = filter (/= [t]) (groupBy (\x y -> x /= t && y /= t) xs) should work ;-)
23:17:32 <_willard> Berengal: Got it. Thanks
23:20:04 <BMeph> @unpl liftM2 (&&) (/= ' ')
23:20:05 <lambdabot> (\ e -> (\ f -> f /= ' ') >>= \ b -> e >>= \ a -> return (b && a))
23:20:51 <sjanssen> Hunner: -package mtl or monads-fd, whichever you intend to use
23:21:44 <Hunner> thanks
23:22:10 <Hunner> or -hide-package for the one I'm not
23:23:51 <quicksilver> Wild_Cat: I note that it's "wrong" to use groupBy that way.
23:23:58 <quicksilver> _willard: oops that was for you.
23:24:26 <quicksilver> _willard: the spec for groupBy only covers the case where the predicate is a binary equivalence relation. If you use it elsewise, it may choose to emit nasal demons.
23:41:30 <mxc> hi byorgey_
23:41:46 <mxc> was curious, who's your advisor at penn?
