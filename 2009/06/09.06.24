00:03:02 <Zao> mae: Aaw, no AIX yet?
00:03:38 <Zao> (it's called send_file there)
00:06:51 <mae> Zao: send me a patch :)
00:07:07 <mae> no autotools though
00:07:11 <mae> just cabal
00:07:19 <mae> (and whatever else comes with haskell)
00:07:33 <mae> man who the heck uses aix anyways
00:07:37 <mae> you must be yanking my chain
00:07:38 <mae> : )
00:08:44 <Zao> It's been a good while since I tried running GHC on the architecture though, due to recently horribly broken gcc.
00:09:08 <Zao> I have used send_file on it natively, and shaken fists at misusage of it.
00:10:59 <mae> hmm perhaps it should be in Network.SendFile
00:11:13 <mae> oh well, its 0.1
00:11:15 <mae> can fix that later
00:21:52 <brian6> do i need ghc 6.11 to get parMap to spread work over my cores? my code and the random test code i'm finding is not migrating with ghc 6.10.3.
00:23:23 <hackagebot> darcs-beta 2.2.98.1 - a distributed, interactive, smart revision control system (PetrRockai)
00:51:30 <hackagebot> hack-handler-happstack 2009.6.24 - Hack Happstack server handler (JinjingWang)
00:51:30 <hackagebot> hack-frontend-happstack 2009.6.24.1 - hack-frontend-happstack (JinjingWang)
01:22:14 <a_guest> I am currently reading about monad transformers, using 'mtl'. It says that monad transformers can  structure bigger applications. My question is wheter this is a normal way to write (bigger) Haskell applications?
01:23:38 <opqdonut> i'd say it is quite widely used
01:23:49 <opqdonut> select the right monad stack, and declare a type alias for it
01:24:09 <Philippa> and add local transformers where useful
01:24:21 <Philippa> generally, if I've written a kiloline then I've had cause to do it
01:24:54 <a_guest> so monad transformers are really in practical use.
01:25:43 <Philippa> very much so
01:25:52 <a_guest> I have not been learnt how to structure haskell applications. Is there some book or example to read?
01:26:19 <Philippa> I don't know how much Real World Haskell offers, but I'd hope it does
01:26:33 <Philippa> xmonad is famously a good example
01:27:21 <a_guest> Philippa: I am currentrly reading rwh, reading about monad transformers!
01:30:12 <Philippa> well then :-)
01:32:55 <alc> > factors 100
01:32:56 <lambdabot>   Not in scope: `factors'
01:36:57 <ski> > let factors 100 = [1,2,4,5,10,25,50,100] in factors 100
01:36:59 <lambdabot>   [1,2,4,5,10,25,50,100]
01:37:17 <georgehorse> um
01:37:22 <georgehorse> 20
01:37:39 <alc> playing with http://hackage.haskell.org/package/Numbers
01:37:42 <ski> .. um, right
01:38:13 * ski is bad at doing arithmetic in head
01:38:15 <alc> found a bug: isPrime 1 == True in Data.Numbers.Primes
01:38:30 <ski> what if you try with zero ?
01:39:52 <alc> True
01:39:55 <alc> http://hackage.haskell.org/packages/archive/Numbers/0.2.1/doc/html/src/Data-Numbers-Primes.html#isPrime
01:40:20 <alc> might need a "n > 1" condition checking
01:40:39 <alc> dunno if the author is hanging around here :P
01:40:42 <ski> (well, whether `0' should be prime or not depends on which definition they are using, i suppose)
01:41:02 <georgehorse> the prime at infinity
01:41:49 <adu> is Hac phi tomorrow or a month from tomorrow?
01:42:36 <ski>   prime p  <=>  not (p | 1)  /\  forall a,b. (p | (a * b) => (p | a \/ p | b))
01:42:52 <ski> using that definition, zero is a prime (in the integers)
01:48:05 <georgehorse> ski: 0 doesn't divide anything.
01:49:00 <doserj> it does divide 0
01:49:13 <ski>   d | n  <=>  exists k. k * d = n
01:49:17 <opqdonut> as i was taught it, integral domains have three disjoint sets of elements a) zero b) units c) primes
01:49:24 <coffeemug> hi everyone
01:49:43 <opqdonut> (and of course then all the "normal" elements)
01:50:01 <ski> ("composite" usually, i think)
01:50:30 <coffeemug> did anyone here implement deletion for Chris Okasaki's red black trees?
01:50:46 <ski> (or possibly "reducible" is better)
01:50:51 <opqdonut> yeah
01:51:05 <opqdonut> and also probably s/integral domain/unique factorisation domain/
01:51:16 <opqdonut> to make it all make sense (irreducible == prime et al)
01:52:12 <georgehorse> you can have primes in ID that don't have unique division, but you don't have the fact that any irreducible element is prime
01:52:24 <georgehorse> for instance
01:52:30 <opqdonut> as i said
01:52:35 <georgehorse> yeah ok
01:53:00 <opqdonut> anyway, considering either zero or one of the units to be prime breaks the unique factorization property
01:54:02 <opqdonut> and zero isn't irreducible either
01:54:03 <georgehorse> and the ideals generated by 0, or by a unit, aren't proper ideals
01:54:13 <opqdonut> indeed
01:54:47 <ski> (opqdonut : are you talking about if we have zero divisors ?)
01:55:06 <opqdonut> no zero divisors here
01:55:19 <opqdonut> but 0 = 0*a with a non-unit
01:55:25 <opqdonut> so it is reducible
01:55:50 <opqdonut> of course the normal definitions of irreducible also only explicitly apply to nonzero elements
01:56:07 <georgehorse> it's less of a big deal than calling it prime
02:00:28 <ski>   not (n ~ 1) /\ not (exists a,b. n = a * b /\ not (a ~ 1) /\ not (b ~ 1))
02:00:31 <alc> isnt prime is well defined?  a natural number which has exactly two distinct natural number divisors: 1 and itself.  the smallest prime is 2.
02:00:33 <ski>   not (n ~ 1) /\ not (exists a,b. n ~ a * b /\ not (a ~ 1) /\ not (b ~ 1))
02:01:22 <ski>   not (n ~ 1) /\ forall a,b. ((n ~ a * b) => (a ~ 1) \/ (b ~ 1))
02:01:56 * ski just ponders
02:03:05 <alc> isPrime n in Data.Numbers.Primes is True for all integers n < 2 -- this is a bug.
02:03:19 <ski> (i.e. i wonder if that is equivalent to
02:03:32 <ski>   not (n ~ 1) /\ forall a,b. ((n ~ a * b) => (n ~ a) \/ (n ~ b))
02:03:33 <ski> )
02:03:43 <dolio> What's Data.Numbers from?
02:03:55 <Zao> A wild guess would be the primes package.
02:03:58 <ski> <http://hackage.haskell.org/package/Numbers>
02:04:28 <Zao> http://hackage.haskell.org/package/primes
02:05:12 <dolio> primes doesn't appear to have isPrime. So it must be Numbers.
02:05:22 <georgehorse> It is Numbers.
02:06:28 <dolio> Ah, yeah. Needs an abs in there.
02:06:43 <dolio> Assuming you don't want negatives to just all be False.
02:07:30 <dolio> I guess that doesn't cover 0, either.
02:07:40 <ski> it might be intended only for naturals (or positive integers)
02:08:10 <georgehorse> I think there should be an indication that it does give 'wrong' answers for negatives etc. but perhaps it's better not explicitly checking, and letting whoever uses the function decide whether they need to spend cycles checking for edge cases that might never ever happen
02:09:55 * georgehorse wonders when miller rabin becomes faster than trial division
02:10:37 <dolio> That implementation's probably doing enough extra work that that isn't going to be a serious concern.
02:11:27 <dolio> It's chuggging through a top-level list of primes, after all.
02:11:36 <Cale> A nonzero, non-unit number p is prime if whenever p divides a*b, then either p divides a or p divides b. A nonzero, nonunit p is irreducible if whenever p = a*b then either a or b is a unit. The two concepts happen to be the same in integral domains.
02:14:52 <georgehorse> That last sentence isn't true. You meant, unique factorization domain.
02:15:17 <Cale> Er, yes, sorry.
02:15:47 <ski> (Cale : but that doesn't tell (/define) whether zero respectively units are prime respectively irreducible :)
02:16:31 <Cale> Primes are always irreducible in integral domains, but you need unique factorisation to go the other way. :)
02:17:27 <georgehorse> But (0) and (u) for u a unit aren't proper ideals, and all kinds of other things need more carefully restated.
02:17:32 <Cale> ski: Zero and units are not prime or irreducible.
02:18:05 <georgehorse> Like unique factorization is more complicated, because if 1 is prime, then 2 = 2 * 1 = 2 * 1 * 1, etc. not very unique
02:18:44 <ski> Cale : if you say that, yes. I see why you want units to be non-[prime,irreducible] .. but i'm not sure about the zero
02:19:40 <ski> (i.e. does it simplify things, or make things more natural, to place that restriction in the definition of [prime,irreducible], rather than in some theorems that actually need it)
02:20:51 <Cale> I think so. 0 would become an annoying special case all the time
02:21:07 <ski> (but i haven't yet taken a course with integral domains, et.c. so it might be easier for me to get it after having done so ..)
02:23:31 <xci> win 26
02:23:34 <xci> lose...
02:24:40 <ivanm> 52?
02:25:19 <ski> (it just appears to me that `forall n , a_0,...,a_{n-1}. p | a_0 * ... a_{n-1} => exists i < n. p | a_i' and similarly for s/|/~/, is particularly nice-looking properties of `p')
02:25:46 <coffeemug> does anyone has access to "red-black trees with types" paper (http://portal.acm.org/citation.cfm?id=968482)?
02:26:07 <Cale> Another option, I suppose would be to consider 0 to be prime in an integral domain, and not prime otherwise.
02:26:21 <bastl> quicksilver: you posted an example for zippers yesterday: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6183#a6183. I wonder how this relates to the example of http://en.wikibooks.org/wiki/Haskell/Zippers. Is Zipper = PTContext and Branch = PTCursor?
02:26:37 <ski> (Cale : that was what i was considering, yes)
02:27:46 <Cale> Yeah, that might be nice.
02:28:00 <ivanm> coffeemug: one of these? http://www.cs.kent.ac.uk/people/staff/smk/redblack/
02:28:10 <ivanm> take it back, they're not papers :s
02:28:15 <Cale> Then you could say that p is a prime element of R iff R/pR is an integral domain.
02:28:25 <coffeemug> ivanm: yeah :)
02:28:28 <ski> (forgot to note that obviously the product above can be empty, i.e. `n' can be zero)
02:28:49 <ivanm> coffeemug: his Java version is available on his web site, but not the Haskell one AFAICT :s
02:29:03 <coffeemug> ivanm: I need to understand how deletions in functional red black trees work
02:29:05 <Cale> (for commutative rings R)
02:29:15 <coffeemug> hmm, I didn't see the java version
02:29:33 <coffeemug> ivanm: where is that?
02:30:14 <ivanm> http://www.cs.kent.ac.uk/people/staff/smk/redblack/rbj.pdf
02:30:33 <ivanm> coffeemug: apparently its based on okasakis work though, so maybe okasaki's thesis will have something?
02:30:46 <coffeemug> ivanm: okasaki omits deletion :)
02:31:01 <ivanm> heh
02:31:12 <ivanm> and citeseer doesn't have it :(
02:31:21 <ivanm> (that's where I usually end up getting most of my papers from)
02:31:23 <quicksilver> bastl: hmm looks like a slightly different approach.
02:31:39 <coffeemug> ah, there is something on deletion in the java paper!
02:31:50 <ivanm> coffeemug: \o/
02:31:56 <coffeemug> ivanm: thanks, that might be really helpful
02:33:39 <ivanm> coffeemug: google ftw! ;-)
02:34:07 <coffeemug> heh, I searched and searched, but couldn't find the any versions of this :)
02:36:30 <lpsmith> oh, the joys of XML.   It magically solves every interoperability problem.
02:36:49 <lpsmith> Althought,  I do think I figured out why it's so popular.
02:37:01 <bastl> it has an X in its name ...
02:37:20 <lpsmith> 'cause people can't write parsers.   So they need something like XML to solve their parsing problems.
02:37:35 <Cale> lpsmith: Or because people are tempted to think that your sarcastic remark is actually true.
02:37:48 <lpsmith> cale:  that too :-)
02:38:44 <lpsmith> but seriously,  I just wasted many hours trying to get a third-party program to do something with an XML problem.  I eventually stole somebody else's XML file that worked,  and adapted it.
02:38:56 <lpsmith> Only difference is in the whitespace.
02:38:59 <lpsmith> Seriously
02:39:13 <Saizan> though those people and up parsing from a DOM or a stream of tags, i don't know if that's any better
02:39:14 <lpsmith> And this is a big name 3rd party product from a big name company
02:39:58 <lpsmith> so it solves peoples parsing problems, and then people go out and write completely broken parsers for it.  Sigh.
02:39:58 <Cale> http://harmful.cat-v.org/software/xml/s-exp_vs_XML
02:40:49 <Cale> http://thedailywtf.com/Articles/What-Could-Be-Easier-Than-XML.aspx
02:41:17 <lpsmith> :-D  actually I thought of that exact story when I realized what the difference was.
02:41:25 <quicksilver> lpsmith: whitespace is allowed to be significant in XML.
02:41:33 <quicksilver> lpsmith: so the parser may not be broken.
02:41:54 <quicksilver> whitespace generates text nodes.
02:42:17 <quicksilver> could be more of a program XML "language" than a broken parser, in other words.
02:42:23 <quicksilver> s/program/broken/
02:42:30 <quicksilver> weird, that wasn't even a good homophone
02:42:59 <lpsmith> hmm,  maybe.  I doubt it though.  It wasn't existence versus lack of whitespace
02:43:04 <lpsmith> it was tabs versus spaces
02:43:18 <lpsmith> in that the broken files had no tabs
02:43:29 <lpsmith> and the working file uses both
02:43:40 <lpsmith> I still don't know what the exact problem is.
02:53:11 <lpsmith> Oh well,  things like this help me realize that cabal-install isn't that bad,  relatively speaking.    I mean,  cabal install is great when it works,  but if something's broke it's more of a hinderance than a help.
02:53:11 <Saizan> mmmh, XML is like Bush, now it all fits together..
02:54:05 <georgehorse> Yeah I just read that too Saizan.
02:55:07 <Saizan> lpsmith: for example?
02:55:35 <smorg> Would this multiplication function end up being left associative when expanded: multb n m = (mult n (m - 1)) + n
02:55:55 <smorg> The first recursion would be ((mult 4 (4)) + 4) but what would the next be?
02:56:20 <smorg> if given 4 5
02:56:52 <Saizan> so multb was actually mult?
02:57:07 <smorg> s/multb/mult
02:57:58 <georgehorse> What exactly do you mean, 'left associative when expanded'?
02:57:59 <smorg> If the function is way on the left i'm not sure where the substitution would happen since theres no operator between the = and the function
02:59:11 <smorg> If you did it another way it ends up looking like foldl: "mult a b = a + mult a (b - 1)" becomes (4 + (4 + (4 + (4 + (4))))) with a base condition of mult a 1 = a
03:00:15 <Peaker> why not  mult x 0 = 0?
03:00:23 <smorg> foldr rather
03:00:29 <Peaker> (4 + (4 + (4 + 0)))
03:01:35 <smorg> That makes more sense :)
03:02:16 <lpsmith> Saizan,  well,  if something goes wrong,  it would be nice if cabal-install would give you the option of dropping you in a directory with the problematic package unzipped and all.
03:03:14 <georgehorse> How badly can cabal break? I've never pulled anything that didn't work fine, but I haven't used it that long.
03:03:24 <georgehorse> cabal-install, rather
03:03:48 <lpsmith> georgehorse:  I've never had significant problems with cabal itself.
03:04:28 <ski> > let mult a 0 = 0; mult a b = a + mult a (b - 1) in mult 4 5 :: Expr
03:04:30 <lambdabot>   4 + (4 + (4 + (4 + (4 + 0))))
03:04:31 <lpsmith> trying to cabal-install gtk2hs had me on the verge of tears once.
03:05:14 <Dae> now try to do it on windows and it'll push you over...
03:05:16 <Raynes> I've never had any problems with cabal-install or cabal. But then again, I build and installed gtk2hs via make. :)
03:05:19 <burp> @hoogle Expr
03:05:19 <lambdabot> module Text.Parsec.Expr
03:05:20 <lambdabot> module Text.ParserCombinators.Parsec.Expr
03:05:20 <lambdabot> Distribution.Simple.Program alexProgram :: Program
03:05:45 <lpsmith> or if you want to do something a bit "specialized",  such as generate hyperlinked sources,   cabal install is currently useless
03:06:08 <lpsmith> it doesn't degrade gracefully,  in being a partial solution to something it can't do
03:06:48 <georgehorse> I'd surmised that much, I think what I meant was, if it does break, doesn't it actually _break_ things, or does it just fail to build something.
03:07:00 <georgehorse> does not doesn't
03:07:04 <smorg> ski: wow thats useful.
03:07:10 <lpsmith> raynes:   I know better now.  I install gtk2hs manually early on.
03:07:20 <Saizan> since when is gtk2hs cabalized?
03:07:44 <lpsmith> it was once upon a time.  I don't know if it still is.
03:07:55 <georgehorse> it isn't now.
03:08:00 <Saizan> lpsmith: you can always cabal unpack the package and run cabal haddock in it
03:08:16 * smorg continues trying to get lambdabot to install properly on gentoo
03:08:38 <lpsmith> but then if you want to do the same thing for all the dependencies?
03:09:10 <ski> (having something like MetaML / MetaOCaml for Haskell would be more useful, imo)
03:09:52 <lpsmith> don't get me wrong,  it's pleasing when things work,  and I'm sure it'll get better.   I'm not trying to hate on it :-)
03:10:13 <Saizan> for all the dependencies that's another story, but i don't see how to degrade better there
03:10:48 <Saizan> lpsmith: i'm asking to see what you think should be done better :)
03:11:40 <Athas> Anyone here who's written Literate Haskell?
03:12:06 <lpsmith> athas:  yes.  What do you want to know?
03:12:09 <Saizan> i think "cabal install" should have a general syntax to give options to subcommands that it's going to call
03:12:13 <Athas> lpsmith: which editor did you use?
03:12:38 <Athas> And did you use noweb or just GHC/lhs2tex?
03:12:59 <georgehorse> The only thing that ever tripped me up with cabal-install was how it handles not having some binary installed, happy or something. not a huge deal, it's not like it's an error you'll see many times
03:13:17 <lpsmith> saizan:  yeah,  that would be a start.   Honestly I'm not sure how to solve all the problems I've run across...  and I haven't thought about it carefully either.
03:13:34 <lpsmith> Athas:  I use Emacs,  and I used GHC/lhs2tex
03:13:51 <lpsmith> But that's more an ignorance of other options than anything else :-)
03:17:24 <Athas> lpsmith: how did you set up Emacs to get syntax highlighting and the like?
03:17:47 <Athas> I'm going to use lhs2tex for my first project, but I think I might write a cweb-like tool for Haskell at some point.
03:17:58 <lpsmith> I only had syntax highlighting on the haskell code or the TeX
03:18:03 <lpsmith> not both at the same time
03:18:26 <Athas> Ah, OK.
03:19:27 <georgehorse> How well does the MMM mode thing work in emacs? i've never gotten around to trying it.
03:19:49 <quicksilver> It's supposed to work pretty well for things which are entirely on separate lines
03:19:52 <lpsmith> I'm not an emacs guru,  but it's a bit hit or miss in my experience
03:19:54 <quicksilver> like literate haskell.
03:20:04 <Athas> Yes, I'm using mmm-mode.
03:20:07 <quicksilver> but very poorly for things which are really inmixed like javascript+html
03:20:09 <lpsmith> Maybe it would have worked well for lhs
03:20:10 <Athas> It works... mostly, but there are weird artifacts.
03:20:23 <quicksilver> I think the cool new kids use "mumamo"
03:20:46 <Athas> The syntax highlighting for quoted strings in Haskell code blocks bleeds over to the LaTeX parts, somehow...
03:20:56 <Athas> I was told that too, but mumamo isn't documented anywhere.
03:21:27 <quicksilver> documentation? that has been deprecated for emacs modules
03:21:35 <quicksilver> you just read the source and swear a lot.
03:22:23 <lpsmith> http://www.osnews.com/story/19266/WTFs_m
03:22:42 <ivanm> quicksilver: heh
03:23:09 <ivanm> at least the code-opening bit is still integrated into C-h, even if the documentation is lacking
03:26:33 <georgehorse> so I had a problem with a package that linked against readline. I got an error, "/usr/lib/libncurses.so: file too short". I have the problem fixed but
03:27:14 <georgehorse> 1) don't know what a linker script is, exactly   2) don't know why you would use it instead of a symlink for something as trivial as this was, and 3) don't know why it broke the compilation
03:34:59 <quicksilver> georgehorse: the basic problem is that ghc has its own linker
03:35:03 <quicksilver> rather than using the system one.
03:35:16 <quicksilver> and it gets confused if the linker is using "advanced" features like linker scripts.
03:35:20 <quicksilver> I think.
03:38:17 <georgehorse> ok, thanks...I really have no idea how compilers in general work, not really the side of things i'm interested in
03:51:29 <otulp> Random access file IO. Specifically, I'd like to be able to extract ByteStrings from random locations in a file (so I can feed them to Data.Binary.decode afterwards). Any pointers?
03:51:50 <Zao> 0x3f6eeeef
03:52:00 <Zao> I'm sorry. It was ready in the window next to this.
03:52:43 <otulp> 0xdeadbeef? :)
03:53:19 <Dae> otulp: random or arbitrary?
03:53:30 <otulp> Well, arbitrary.
03:55:34 <Dae> well... I guess you could put the file in an array? Though that sucks for memory use
03:55:43 <otulp> The file is waaaay to big.
03:55:49 <otulp> +
03:55:50 <otulp> +o
03:56:00 <Dae> was worried you would say that
03:56:11 <doserj> System.Posix.IO.fdSeek?
03:57:05 <otulp> doserj: Probably. Thanks.
03:57:24 <doserj> there is also System.IO.hSeek, which might be more portable
03:59:22 <otulp> More portable == better. Double thanks.
04:01:02 <otulp> <-- Feeling slightly silly for posing the question in the first place now. :)
04:02:49 <dcoutts> Saizan: if you'd like to propose something that'd be good :-)
04:03:02 <dcoutts> Saizan: I mean something regular for passing options to sub-commands
04:06:24 <Dae> otulp: why feel silly? Getting O(1) random access out of haskell is always tricky
04:08:03 <otulp> Yes, I'm fairly certain I'll discover that any moment now. :)
04:13:45 <Dae> the best thing about writing haskell in windows is the nice feeling you get when you're on linux again and stuff is suddenly EASY
04:16:10 <Zao> Dae: Only because people are lazy and cannot be arsed to be portable.
04:16:47 * bremner cannot be arsed about Windows, since he doesn't use it on any machines.
04:17:29 <Zao> See. They're everywhere :)
04:17:51 <Acteum> what, in your opinion, is the worst aspect of windows?
04:26:31 <bremner> 1:1
04:31:57 <EvilTerran> bremner, er, *ba-dum chh*?
04:33:33 <Acteum> lol
04:49:40 <Dae> Acteum: the thing is miss the most is the package manager
04:50:03 <jpcooper> hello
04:50:13 <jpcooper> could anyone recommend a simple and working Haskell HTTP server?
04:51:07 <Zao> salvia?
04:51:15 <jpcooper> had bad experiences with that
04:51:38 <jpcooper> just joking. I'll have a look, thanks
04:51:58 <WorkyBob> is it possible to get basic information about errors back from ghc api?  Ideally I'd like to be able to tell if I'm getting a type error or a not-in-scope error bac
04:52:03 <Zao> From what I understand, it's a bit more lightweight than happstack.
04:52:14 <Saizan_> http server or web framework? for a simple server there's hyena
04:52:40 <jpcooper> I just need a server actually
04:52:56 * Dae furiates over the MinGW thingy not being able to install
04:53:00 <jpcooper> an analogue of Hunchentoot for Lisp
05:06:19 <bastl> Is there a mature implementation of the functional pearl  "Weaving a Web" by Hinze/Jeuring ?
05:09:29 <kosmikus> bastl: the "zipper" package implements a generic zipper data structure (based on the multirec library which is somewhat experimental), and there are several other libraries on HackageDB that implement zippers for specific data structures
05:27:32 <bastl> kosmikus: thanks, that looks very good. in fact i only need the locations in my asts. Are there examples that show how to use multirec and zipper ?
05:31:43 <kosmikus> bastl: there's a (small) example in the zipper package itself (examples subdirectory)
05:39:57 <bastl> kosmikus: there is a file missing: examples/ASTUse.hs
05:42:56 <kosmikus> bastl: oh :)
05:43:07 <kosmikus> how unfortunate
05:43:59 <bastl> could you paste it to a pastebin or so?
05:44:12 <kosmikus> I think it's in multirec
05:44:17 <kosmikus> it's the same file
05:44:20 <bastl> oh :-)
05:44:22 <kosmikus> but of course it should be in zipper, too
05:44:29 <bastl> how fortunate ;-)
06:08:13 <ben> My enthusiasm about "Real World Haskell: out now" is somewhat curbed after reading through half the online version which still has a bunch of paragraphs with errors in them that are pointed out in the comments :v
06:13:11 <ivanm> ben: they fixed those errors up in the printed version (and then got more! :p )
06:13:25 <ivanm> problem is, they couldn't then go book -> website again :s
06:18:20 <Raynes> ben: Meh, the errors are annoying, as well as the contradictions, like the fact that they flat out say to pretty much never use constraints in data types, yet they use a constraint in one of theirs a few chapters later. However the book is actually pretty good.
06:18:31 <ivanm> Raynes: they do? :o
06:18:32 <ivanm> where?
06:18:36 * ivanm doesn't recall that bit...
06:18:59 <Raynes> Are you going to make me go looking for it. :|
06:19:08 <Raynes> ?, even.
06:19:09 <lambdabot> Maybe you meant: . ? @ v
06:19:26 <ivanm> heh
06:19:34 <ivanm> do you remember the general bit of the book?
06:19:48 * Raynes looks
06:20:40 <ben> <ivanm> problem is, they couldn't then go book -> website again :s <- Guh. How does that not work?
06:21:02 <Raynes> Found it!
06:21:36 <ivanm> ben: *shrug* the format O'Reilly used internally or something wasn't as easy to convert to the websites format as it was to go from the website format
06:22:19 <Raynes> Chapter 13, Extended Example: Numeric Types, Completed Code, example 7.
06:23:09 <Raynes> data Num a => Units a = Units a (SymbolicManip a)
06:23:17 <Raynes>            deriving (Eq)
06:23:45 <Raynes> Well, I'm off to take an extremely cold shower. :D
06:24:10 <ben> ivanm: "Buy our book, or read through the faulty online version for free"?
06:24:24 <ivanm> ahhh
06:24:32 <ivanm> ben: well.... not quite
06:24:34 <ben> Incidentally, is there a way to download an archive with all the code examples somewhere or are they just given inline in the actual text?
06:24:39 <ivanm> Raynes: this is getting you all hot and bothered, is it? :p
06:25:02 <ivanm> Raynes: there are some times you have to do that IIRC... e.g. Complex a requires it
06:25:05 <ivanm> @src Complex
06:25:06 <lambdabot> data (RealFloat a) => Complex a = !a :+ !a
06:25:19 <ivanm> not quite sure why though...
06:25:53 <georgehorse> why are constraints there evil
06:26:05 <Raynes> Actually, I just hate the heat, and cold showers help me avoid that heat. I don't take warm showers at all anymore. Ice cold every time.
06:26:05 <ben> I thought value constructors were supposed to start with uppercase letters. Does that mean : counts as an uppercase operator?
06:26:12 * Raynes goes and takes said shower for real this time.
06:26:25 <ivanm> georgehorse: usually, you shouldn't have constraints in the data type declaration are bad, as you need to put them into the functions type as well anyway
06:26:36 <ivanm> ben: or a symbol for infix constructors
06:26:41 <boml> Hi, if I compile and .exe with ghc, will it be standalone and usable on other pc:s as well or does some time of runtime need to be shipped with it?
06:26:42 <georgehorse> ah
06:26:47 <boml> an
06:26:53 <ivanm> boml: should be standalone
06:27:13 <ivanm> on *nix, the only dynamic dep is GMP :s
06:27:18 <boml> ivanm: what about the garbage collector?
06:27:33 <ivanm> nope, part of it
06:27:43 <ivanm> that's why "hello world" in haskell is so big ;-)
06:27:51 <boml> ivanm: good things.
06:42:44 <voker57> ivanm: and libffi
06:43:02 <Raynes> Albeit why C programmers complain about "hello world" is so big. :\
06:44:01 <Raynes> being so big, even.
06:44:32 <ben> Clearly the size of a binary should be proportional to its complexity relative to hello world
06:44:39 <zloog> main = print "Hello World" is big?
06:45:08 <BONUS> yeah, the hello world program is small, only its executable binary is big :)
06:45:14 <zloog> Oh
06:45:15 <BONUS> but that depends on your definition of "program"
06:45:19 <zloog> yea[
06:45:31 * Raynes huggles BONUS
06:45:35 <BONUS> :]
06:45:49 <ben> is lyah in print yet
06:46:02 <BONUS> not yet, gotta finish like 3 more chapters over the summer
06:46:19 <BONUS> i hope it's in print by the end of the yeah
06:46:25 <ben> can I reasonably put it on my amazon wishlist for christmas
06:46:41 <BONUS> :O
06:46:55 <nlogax> BONUS: looking forward to the new chapters. didn't know there was a book coming, looking forward to that as well!
06:46:59 <BONUS> tell you what, just for you, if it's not out by chirstmas you get a free copy from me
06:47:06 <Vanadium> Hooray <:D
06:47:19 <BONUS> yeah i finish exams in like 10 days, then it's full time LYAH writing, i can't wait
06:47:20 <mauke> can I download the free copy from the web?
06:47:22 <BONUS> gonna be so fun
06:47:29 <Raynes> I should get a free copy. I emailed you a total of 2 whole typo corrections! :p
06:47:33 <BONUS> mauke sure
06:47:34 <BONUS> haha
06:47:42 <BONUS> i only get 20 free copies myself :[
06:47:48 <Vanadium> aw
06:47:59 <petermarks> In Template Haskell, is it possible to take some Haskell code as a string (in my case a data declaration), parse it, modify the parsed representation, then produce the modified version as a result? (please pardon my terminology, I've done a little Template Haskell, but don't know it very well)
06:48:32 <nlogax> i reported a terrible bug!! free book?
06:49:22 <BONUS> i plan on giving like 12 of the 20 i get away on twitter via some sort of zany contest
06:49:24 <mauke> go away and write your own books :-)
06:49:25 <BONUS> so stay tuned!
06:49:42 <flazz> having trouble with cabal, http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2868#a2868
06:49:48 <flazz> can someone shed some light?
06:50:14 <Raynes> nlogax: (:
06:50:17 <gwern> '* Q. Will there be a teaser this year too that tells something about the contest task in a cryptic way but you can’t really infer anything from it until the task is out, such as the ants image in 2004 or the codex in 2006?
06:50:19 <dcoutts> flazz: you're using ghc-6.8 which does not come with base 4
06:50:22 <gwern> * A: There already are a number of teasers. '
06:50:57 <BONUS> haha
06:51:17 <mauke> BONUS: will there be a painting book for the illustrations in lyah?
06:51:21 <djahandarie> Hey guys... I did an import HTTP.Network, but when I try to use any functions it says they are not in scope
06:51:29 <djahandarie> bot.hs:99:40: Not in scope: `getRequest'
06:51:36 <Raynes> I didn't know you were actually going to print LYAH.
06:51:38 <djahandarie> I mean Network.HTTP
06:51:51 <Raynes> I thought it was just a web-tutorial. Albeit a very comprehensive one.
06:51:56 <BONUS> mauke: haha maybe, i still don't know all the details myself
06:52:30 <BONUS> Raynes: yeah, a publisher saw it and told me if i wanted to print it and i was like "totally!"
06:52:48 <flazz> dcoutts: if i upgrade to 6.10 i should be fine?
06:52:55 <djahandarie> Oh... nevermind... I was reading off an archive of hackageDB
06:52:57 <dcoutts> flazz: yes
06:53:08 <Raynes> BONUS: That's awesome! :D Late congratulations.
06:53:12 <Vanadium> BONUS: Are the pictures actually going to be included?
06:53:19 <flazz> on osx can i just upgrade over the previous installation? or do i need to remove the old one first?
06:53:35 <BONUS> haha thanks
06:53:39 <Vanadium> with the splash page as a cover image?
06:53:58 <BONUS> Vanadium: yeah, although i don't think they will be in color, but i'll redo them to make them more appealing in black and white
06:54:03 <gwern> BONUS: which publisher? no starch?
06:54:06 <mauke> :-(
06:54:13 <BONUS> cause it's gonna be over 400 pages, and a 400 page book in color is expensive
06:54:16 <BONUS> gwern: yup :)
06:54:27 <Vanadium> Nice
06:54:29 <opqdonut> lyah bookifying?
06:54:36 <gwern> (no starch is the only publisher I could think of that would contact a random web tutorial)
06:54:36 <opqdonut> congrats
06:54:38 <BONUS> from the horses mouth!
06:54:40 <Vanadium> The cover can be in colour, though, surely?
06:54:44 <BONUS> sure
06:54:49 <BONUS> i was thinking of adding a poster too
06:54:55 <Vanadium> :D
06:54:58 <BONUS> like a colorful haskell cheat sheet that you pin on your wall
06:55:16 <stepcut> s
06:56:42 <nlogax> sweetness
06:59:21 <boml> BONUS: not a haskell question maybe. But how do you convert between the html and the (latex?) version?
06:59:46 <BONUS> very carefully
07:00:04 <nlogax> :D
07:00:07 <boml> BONUS: do you mean manually?
07:00:20 <BONUS> probably gonna do it by hand, or maybe write some sort of script to parse the html and spit out latex
07:00:40 <boml> maybe write in haskell...
07:00:57 <BONUS> yes hmm haha which language that i know is great at parsing hmm
07:01:05 <mauke> perl
07:01:17 <BONUS> haha
07:01:30 <boml> BONUS: but there is already a pdf. Was that written from scratch?
07:02:05 <georgehorse> This seems like a problem that someone else has probably already solved.
07:02:19 <BONUS> i don't know, someone else did that typesetting
07:02:23 <BONUS> i think he did it manually though
07:02:29 <mauke> for bonus points, do it in javascript
07:02:34 <opqdonut> pandoc!
07:02:39 <boml> georgehorse: most likely...
07:03:03 <georgehorse> 14k hits on google for html2latex :)
07:03:20 <georgehorse> including a hit for html2latex.c
07:03:32 <georgehorse> what sort of person does this in c
07:03:55 <BONUS> haha. yeah although the publisher has a special latex style and functions for typesetting their books
07:04:09 <BONUS> i'll focus first on writing the whole thing hehe
07:04:17 <Vanadium> georgehorse: Someone who already has a html parser in C, perhaps :V
07:04:31 <djahandarie> Is there a way to tell what version of a package I have?
07:04:46 <mauke> yes, ghc-pkg list
07:06:00 <BONUS> ughhg back to studying circuit minimization and stuff :\ what a bore
07:15:29 <djahandarie> If a function is expecting a URI and I only have a Maybe URI... how do I make it work? :P
07:15:53 <kpreid> :t maybe
07:15:57 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
07:16:09 <kpreid> use: maybe yourFunction yourMaybeURI
07:16:24 <djahandarie> Oh, cool
07:16:29 <kpreid> er, that's not what I thought it was
07:16:34 <kpreid> I mean fmap, not maybe
07:16:40 <kpreid> well, depends
07:16:41 <dibblego> you can't get a URI from a Maybe URI
07:16:47 <kpreid> fmap preserves the maybe-ness
07:16:59 <kpreid> maybe lets you specify the value to use instead of the function result
07:17:03 <kpreid> :t fmap
07:17:04 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:17:22 <dibblego> maybe is fold for Maybe
07:17:35 <kpreid> (in your case: fmap :: (URI -> b) -> Maybe URI -> Maybe b)
07:18:25 <djahandarie> So... I have the following   defaultGETRequest parseURI ("somestring")
07:18:37 <djahandarie> How would I use fmap on that?
07:19:09 <djahandarie> parseURI is String -> Maybe URI
07:19:16 <djahandarie> defaultGETRequest needs a URI
07:19:25 <dibblego> > let maybeURI = Just 7 in fmap (+1) maybeURI
07:19:27 <lambdabot>   Just 8
07:19:33 <dibblego> > let maybeURI = Nothing in fmap (+1) maybeURI
07:19:35 <lambdabot>   Nothing
07:20:17 <kpreid> djahandarie: fmap defaultGETRequest (parseURI "somestring")
07:20:23 <kpreid> djahandarie: (your parentheses were misplaced)
07:20:39 <Vanadium> case parseURI "somestring" of (Just uri) -> defaultGETRequest uri; Nothing -> error "OH GOD WHAT", screw your stupid functors
07:21:02 <EvilTerran> Vanadium, o.ó
07:21:52 <Vanadium> ._õ
07:22:14 <djahandarie> kpreid, hm, okay, and now the defaultGETRequest is returing a Maybe Request
07:22:20 <djahandarie> Should I do another fmap on that as well?
07:22:27 <djahandarie> It feels like I'm doing something wrong
07:22:38 <EvilTerran> º~°
07:22:41 <kpreid> well, you can't just ignore a parse error
07:22:47 <kpreid> you have to decide what to do with it
07:22:58 <kpreid> fmap is saying the answer is 'propagate the failure'
07:23:04 <kpreid> if you have something else to do...
07:23:08 <djahandarie> Hm
07:23:16 <kpreid> Vanadium's suggestion is to crash
07:23:29 <BONUS> haha
07:23:30 <quicksilver> I prefer to emit nasal demons.
07:23:37 <kpreid> but if you have a sensible thing-to-return-instead, just do that in the other branch of the case structure Vanadium gives
07:23:47 <BONUS> basically you can just use the Maybe monad
07:23:51 <djahandarie> Okay
07:23:52 <BONUS> i mean as a monad
07:24:08 <djahandarie> So basically it's telling me to handle the Maybe case
07:24:24 <djahandarie> And my choices are to either do it right there with a case or propegate it with an fmap?
07:24:39 <Vanadium> No you can also do what BONUS said
07:24:53 <djahandarie> Not sure what he means
07:25:00 <Vanadium> parseURL "somestring" >>= defaultGETRequest >>= someRequestHandlerYouAreGoingToWrite I believe
07:25:08 <djahandarie> Oh
07:25:18 <EvilTerran> djahandarie, or dismantle it in any of a number of other ways, too - any approach here is expressible as a case expression
07:25:21 <djahandarie> What happens if I do that and something is Nothing?
07:25:33 <EvilTerran> then it's all Nothing
07:25:33 <Vanadium> djahandarie: Nothing
07:25:49 <djahandarie> Hm okay
07:25:49 <Vanadium> That is pretty much the same as chaining it with fmaps, really
07:25:58 <BONUS> you can also use do notation if you prefer it
07:26:49 <EvilTerran> djahandarie, bothering with >>= and other such monad-y stuff is only really worthwhile for Maybe if you find yourself writing a lot of nested "case ... of Nothing -> Nothing; Just x -> ..."
07:29:14 <EvilTerran> djahandarie, seeing as (m >>= f) is precisely (case m of Nothing -> Nothing; Just x -> f x) when dealing with Maybes
07:30:33 <Vanadium> I keep forgetting whether there is an unsafePerformMaybe (Just v) = v
07:30:43 <BONUS> it's fromJust
07:31:31 <BONUS> i kind of find unsafePerformMaybe to be a better name for it
07:31:31 <fasta> It's better to redefine fromJust to be some macro which expands to some pattern matching, so that you can at least get a location for some bug in your program .
07:31:34 <BONUS> because it's a drag to type
07:32:11 <soupdragon> fromJust isn't unsafe
07:32:23 <soupdragon> partiality is one of haskells (few) effects
07:32:56 <opqdonut> well it's not partial in the accepted sense of not halting
07:32:58 <opqdonut> :)
07:33:05 <opqdonut> but you are of course right
07:33:12 <opqdonut> non-total is a more apt term
07:33:25 <soupdragon> really?
07:33:38 <soupdragon> what does partial mean?
07:33:38 <Vanadium> > fromJust Nothing
07:33:39 <lambdabot>   * Exception: Maybe.fromJust: Nothing
07:33:47 <Vanadium> It throws an exception, that sounds pretty unsafe to me
07:34:02 <hzap> > div 1 0
07:34:04 <lambdabot>   * Exception: divide by zero
07:34:10 <opqdonut> soupdragon: partial means exactly what you think it means. it's just that partiality because of runtime errors is frowned upon
07:34:25 <hzap> so it should be unsafe as well?
07:34:48 <opqdonut> semantically it's a perfectly nice function Just a -> a, both types being lifted
07:34:54 <opqdonut> (i.e. they contain _|_)
07:35:05 <opqdonut> but this is nitpicking
07:35:27 <mpwd> > head []
07:35:29 <lambdabot>   * Exception: Prelude.head: empty list
07:35:37 <mmorrow> error _ = error error
07:35:54 <mmorrow> undefined = undefined
07:36:00 <mpwd> head should be named  "unsafePerformList" maybe?
07:36:08 <mmorrow> doesn't that depend on your def of those two by that logic?
07:36:26 <soupdragon> opqdonut: That makes sense
07:36:56 <opqdonut> mmorrow: well i hold that error x and undefined both denote _|_
07:37:12 <mmorrow> is not halting _|_ ?
07:37:32 <mpwd> ...no...
07:37:52 <opqdonut> mmorrow: yes
07:38:13 <mpwd> ...no way...
07:38:24 <soupdragon> mpwd hwat does it mean to you?
07:39:01 <mpwd> Um, _|_ is the "impossible construction"
07:39:07 <mmorrow> forall a.a
07:39:18 <mmorrow> happens to be the type of let x = x in x
07:39:23 <mmorrow> *which ...
07:39:31 <soupdragon> impossible construction ..?
07:39:39 <mpwd> It corresponds to logical "falsum" in the curry howard isomorphism...
07:39:57 <soupdragon> mpwd: haskell doesn't correspond to any logic
07:40:23 <opqdonut> mpwd: yeah, but i was just talking about denotational semantics
07:40:38 <mpwd> soupdragon: Google the curry howard isomorphism.  Pure, static haskell, for inhabited types corresponds to intuitionistic
07:40:40 <opqdonut> where _|_ is merely the least element of a DPO
07:40:49 <soupdragon> mpwd: no it doesn't
07:40:59 <opqdonut> mpwd: total haskell would
07:41:03 <opqdonut> or haskell w/o fixpoints
07:41:43 <soupdragon> opqdonut: (it's called lambda calculus :p)
07:41:45 <soupdragon> not haskell
07:42:52 <opqdonut> soupdragon: of course
07:42:57 <mpwd> Well, haskell implements all of the typed lambda calculus... and _|_ has the meaning I just said for the pure, simply typed lambda calculus with eager evaluation
07:43:12 <opqdonut> mpwd: the problem is that every type is inhabited in haskell
07:43:28 <opqdonut> which makes the corresponding logic unsound
07:43:37 <soupdragon> it's not a problem that every type is inhabited, that's the whole reason why people are able to program with it
07:43:51 * mauke proves anything with fix id
07:43:58 <opqdonut> well the problem wrt. c-h correspondence
07:44:56 <mpwd> opqdonut: Hmm... well, I guess this interpretation of _|_ really has to deny laziness...
07:45:09 <soupdragon> lazyness doesn't matter, recursion does
07:45:20 <mpwd> Since otherwise you're completely correct about every type being inhabited
07:50:47 <tibbe> soon meeting time!
07:50:56 <m4k3r> hello, I'm new with haskell, but I haven't understood the difference between "let", pipe, and "where". Here there are some examples (http://codepad.org/PpkB1kJl). Maybe they are used just for a matter of style? :S
07:51:47 <mauke> your first two examples are very different
07:51:59 <mauke> but 'let' and 'where' do the same thing, yes
07:52:06 <quicksilver> m4k3r: the | is quite different that's a list comprehension syntax.
07:52:19 <mauke> hey, your last two examples are also different
07:52:26 <quicksilver> m4k3r: "let" and "where" do the same job in different grammatical positions
07:52:30 <mauke> foobar x = let square a = a*a in square x
07:52:52 <quicksilver> "let" attachs to expressions (and forms expressions), where attaches to declarations.
07:52:55 <m4k3r> quicksilver: so let and where are used just for style and reading?
07:53:10 <quicksilver> typically there isn't a simple choice
07:53:20 <quicksilver> if what you've got is an expression you use let
07:53:28 <quicksilver> if you're attaching to a declaration you use where
07:53:37 <quicksilver> however at a higher level it's just a style choice, yes.
07:54:20 <m4k3r> mmh, so for listcomp I should always use pipe?
07:54:46 <quicksilver> the pipe is a compulsory part of list comprehensioin syntax yes.
07:54:48 <quicksilver> It's not really related to let or where.
07:54:56 <m4k3r> al least for the "main" value declaration
07:55:18 <quicksilver> a list comprehension has the form [ <expression> | <statements> ]
07:55:24 <quicksilver> loosely speaking.
07:55:34 <quicksilver> where the expression can contain values which are bound in the statements.
07:56:09 <hzap> m4k3r: your first expression basically evaluates to the tuple (25,9,4) and put it into a 1-element list. It doesn't use list comprehensions
07:57:11 <m4k3r> hzap: i never said it was
07:57:19 <m4k3r> k,one last thing: is there a sor of  "style guide" for haskell?
07:57:23 <m4k3r> *sort
07:58:21 <fasta> Sometimes it would be nice if one could also do map (const a where a = 43)
07:58:34 <gwern> m4k3r: there's hlint
07:58:47 <gwern> fasta: what's wrong with let a = 43 in map (const a) ?
07:59:04 <m4k3r> mad does the same as in python?
07:59:08 <m4k3r> *map
07:59:23 <fasta> gwern: why does where exist, when there is let?
07:59:50 <hzap> m4k3r: yes
08:00:05 <m4k3r> uh, thank you all ^^"
08:00:15 <gwern> fasta: why do guards exist when we have if-then-elses?
08:00:30 <fasta> gwern: I don't think you understood what I meant.
08:00:35 <pikhq> Sugar, I'd assume.
08:00:57 <gwern> I see no stylistic advantage in shoe-horning the where into the parens
08:01:27 <fasta> gwern: the idea of let vs where was that let and where have two different mind-sets behind them.
08:01:39 <fasta> gwern: it's in one of SPJ's slides.
08:01:49 <gwern> but you're not using where as wherem there. you're just using it as a postfix let
08:02:29 <fasta> gwern: yes, I am, still, I don't really see much of a difference between also allowing that.
08:03:13 <gwern> where is supposed to be used a solid block following the full definition; not as a inline postfix let
08:04:00 <fasta> gwern: that might be what it is,  but it's not what I consider to be a good choice.
08:05:34 <fasta> gwern: guards are also a bad idea, because you cannot refactor them.
08:06:10 <gwern> and a mess of if-then-elses are a better idea? guards line up nicely, are easy to reorder and indent, and are clearer
08:06:20 <ski> guards are strange
08:06:31 <fasta> gwern: I kind of like the strategy combinators like they have in Stratego.
08:06:47 <ski> (and the "case" thing in Agda2 is similarly strange)
08:06:59 <FunctorSalad> sometimes there is some inherent if-then-elseness in the algorithm though ;)
08:07:20 <fasta> gwern: I also don't like if then else in Haskell, btw :)
08:07:44 <fasta> The Lisp if is much nicer to read.
08:07:46 <Apocalisp> cond!
08:08:04 <FunctorSalad> cond is "case" with trivial patterns
08:08:10 <FunctorSalad> and guards
08:08:12 <FunctorSalad> isn't it?
08:08:20 <ski> one might consider allowing `<pat> | <expr>', where `<expr> :: Bool', to be provided as a replacement for guards .. but that doesn't really work
08:08:41 <Apocalisp> yes, that sounds about right
08:08:45 <ski> (`cond' is `if-then-else-if-...')
08:09:22 <FunctorSalad> ski: how is that different from guards...?
08:09:27 <ski> (consider allowing said `<pat> | <expr>' to be a *pattern* provided ...)
08:09:46 <ski> foo (x | x > 0) ..x..
08:09:54 <FunctorSalad> (except that guards can also contain "foo <- bar" expressions)
08:09:54 <ski> er
08:09:58 <ski>   foo (x | x > 0) = ..x..
08:10:01 <ski>   foo (x | x < 0) = ..x..
08:10:03 <ski> et.c.
08:10:33 <ski> with guards, the left-hand-sides are factored
08:10:35 <FunctorSalad> > case Just 1 of { x | (Just n) <- x -> "oh hai" }
08:10:36 <lambdabot>   "oh hai"
08:10:58 <FunctorSalad> the parsing precedence is obvious, isn't it? ;)
08:11:29 * ski would remove the round brackets ..
08:11:31 <FunctorSalad> for extra points put a view pattern in the pattern in the guard
08:11:46 <opqdonut> :D
08:13:19 <ski> , case Just 2 of { x | Just ((2*) -> n) <- x -> replicate n "oh hai" }
08:13:20 <lunabot>  ["oh hai","oh hai","oh hai","oh hai"]
08:13:29 <quicksilver> FunctorSalad: yo dawg I heard you liked patterns...?
08:15:04 <FunctorSalad> quicksilver: but she doesn't like forming babby
08:15:50 <ski> (might "she" be "Lovelace" ?)
08:17:14 <FunctorSalad> no hidden pun there, just non-sequitur + countermeme
08:18:57 <ski>   distr :: (a,(b | c)) -> ((a,b) | (a,c))
08:18:59 <ski>   distr (a,(b | c)) = ((a,b) | (a,c))
08:19:23 <quicksilver> but I want to use that syntax for my anonymous variants!
08:19:43 <ski> that *is* using anonymous variants !
08:19:49 <opqdonut> anonymous variants?
08:19:53 <ski> (in my imagination, that is)
08:19:55 <quicksilver> surely you'd need two cases for the defn.
08:20:07 <quicksilver> distr (a,(b |)) = ((a,b) |)
08:20:08 <ski> (though i prefer thinking of it as *positional* variants)
08:20:12 <FunctorSalad> why is that syntax illegal?
08:20:21 <quicksilver> distr (a,(| c)) = (| (a,c))
08:20:27 <ski> quicksilver : yes, that'd be an alternative legal (and equivalent) definition
08:20:36 <FunctorSalad> I mean ski's original one, not funny sections ;)
08:20:47 <opqdonut> anonymous variants?
08:20:58 <ski> FunctorSalad : that's no sections
08:20:59 <quicksilver> ski: your definition is suppose to know that any doubled-up cases in the LHS automatically select the corresponding case in the RHS ?
08:21:06 <FunctorSalad> hmm thought it was just supposed to be a synonym for `Either`
08:21:12 <quicksilver> opqdonut: low syntax variant of Either
08:21:21 <ski> quicksilver : yes, each case selects the appropriate part
08:21:26 <opqdonut> quicksilver: ah
08:21:33 <FunctorSalad> Either is a bit long for sth so fundamental
08:21:34 <ski> (i'm not sure how to phrase that shortly, in a clear way)
08:21:48 <FunctorSalad> and I don't see how it's a clash with existing syntax
08:22:55 <ski> (quicksilver : i have some more ideas regarding this .. but they aren't fully cooked, yet)
08:23:10 <ski> btw, obviously one should be able to
08:23:21 <ski>   narrow :: (a | a) -> a
08:23:26 <ski>   narrow (a | a) = a
08:23:27 <FunctorSalad> well ok, [ a :: Int | String | a <- as ]
08:23:30 <FunctorSalad> would be a clash I guess
08:23:46 <FunctorSalad> (unless it looks ahead)
08:23:50 <ski> FunctorSalad : not if wrapping round brackets are required (as with tuples)
08:23:50 <opqdonut> ski: equality pattern match?
08:23:56 <ski> opqdonut : not at all
08:23:57 <opqdonut> ah, no
08:23:59 <Baughn> I find myself wanting to define a numeric type with only +/-, no multiplication.
08:23:59 <opqdonut> sorry
08:24:00 <ski> that is the same as
08:24:03 <opqdonut> variants, yes
08:24:05 <ski>   narrow (a |) = a
08:24:08 <ski>   narrow (| a) = a
08:24:13 <Baughn> So, which is least obnoxious - using (*) = undefined, or numeric-prelude?
08:24:17 <opqdonut> yeah now i see the point of that syntax
08:24:18 <FunctorSalad> Baughn: abelian group
08:24:30 <FunctorSalad> (assuming (+) implies commutativity)
08:24:31 <Baughn> FunctorSalad: Well, yes. :P
08:24:38 <Baughn> FunctorSalad: It's basically a time type
08:24:42 <ski> (another thing to think about is how to best combine this with or-patterns)
08:24:50 <EvilTerran> Baughn, give the operators different names?
08:25:11 <Baughn> EvilTerran: Possibly..
08:25:21 <FunctorSalad> Baughn: time is a great opportunity to distinguish points from differences (vectors) I think
08:25:28 <intr> does ghc itself exploit multicore systems (e.g., when building a huge cabal package)?
08:25:34 <FunctorSalad> Baughn: IOW, it should be a one-dimensional affine space
08:25:51 <dcoutts> intr: Cabal does not yet do parallel builds
08:26:02 <Baughn> FunctorSalad: Now that, I haven't run into before. *wikipedes..*
08:26:04 <intr> dcoutts: what about vanilla ghc --make?
08:26:14 <Baughn> FunctorSalad: Is there a convenient package on hackage defining those?
08:26:25 <dcoutts> intr: nope
08:26:45 <FunctorSalad> Baughn: incidentally I just read this posting which has a nice table http://www.haskell.org/pipermail/haskell/2003-July/012275.html
08:26:59 <FunctorSalad> Baughn: hmm I think vector-space has these
08:27:12 <Baughn> FunctorSalad: Just found it. Hm, I recalled reactive binding to that..
08:27:25 <Baughn> Never quite got around to checking /why/, but I think this would be it
08:27:30 <iFire> what's a good tutorial on converting from object orientation to what haskell uses
08:27:46 <Baughn> iFire: Oh dear. There should be a tutorial for that, but...
08:28:10 <Baughn> iFire: Hm. There's haskell-for-c-programmers, which takes you from procedural. Close enough?
08:28:32 <FunctorSalad> @tell conal your MemoTrie package looks quite promising... what's the current state, did you run into any problems?
08:28:33 <lambdabot> Consider it noted.
08:30:06 <iFire> Baughn that's like comparing java to c
08:30:34 <iFire> a section in a textbook is fine too
08:30:46 <iFire> I can probably use google books
08:30:51 <Baughn> iFire: Unfortunately true. I'm not aware of any textbooks specifically aiming at convertin object-oriented programmers.
08:31:09 <EvilTerran> haskell has nothing strictly analogous to many of the core object-orientation concepts
08:31:15 <EvilTerran> it has... better things, in my mind.
08:31:17 <Baughn> iFire: I don't think anyone's written one, though I could be mistaken. Even in snippets
08:32:26 <Baughn> EvilTerran: Right, so such a textbook would have to go one level up, describing how to write programs doing the same thing in very different ways
08:32:57 <Baughn> But then I'm not sure the OO half of the book would be /worthwhile/
08:33:37 <quicksilver> FunctorSalad: pretty sure memotrie works well
08:33:46 <quicksilver> FunctorSalad: it's heavily used in FieldTrip to cache polygonisations
08:34:26 <ski> (something like message-dispatching syntax in Haskell would be a good start for some OO-things, imo)
08:35:23 <ski> (then if one could figure out how to add inheritance and coinheritance (plus subtyping and supertyping) in a usable fashion, that might be even better)
08:36:51 <FunctorSalad> quicksilver: nice. I was just a bit scared that it relies on "invisible" stuff (sharing, rewrites)
08:36:57 <FunctorSalad> (if I understand correctly)
08:37:23 <quicksilver> yes
08:37:25 <quicksilver> that scares me too
08:37:31 <quicksilver> it's trust conal, or live in fear, I think
08:38:32 <EvilTerran> ski, coinheritance?
08:38:53 <Baughn> I wouldn't trust him too far. His stuff frequently scares me.
08:39:43 <ski> EvilTerran : like inheritance, but for sum types
08:40:28 <ski> it's used quite often in some proofs
08:40:41 <ski> you have an inductive structure (like expressions of a language)
08:40:52 <ski> you do an induction proof over the expressions
08:41:04 <hackagebot> nemesis 2009.6.24 - a rake like task management tool (JinjingWang)
08:41:06 <ski> then you extend the language with a few more alternatives
08:41:29 <ski> then you also want to extend the proof, just adding cases to the induction for the added alternatives
08:41:38 <ski> that is one example of coinheritance
08:42:23 <ski> in programming it would mean that after adding constructors to a sum type, you could extend the recursions of (some) functions operating on that type, by just "plugging in extra cases"
08:42:57 <ski> there's some papers by Erik Poll who talk a bit about this
08:44:43 <EvilTerran> ski, nice
08:45:22 <ski> (EvilTerran : specifically these papers <http://www.mdstud.chalmers.se/~md9slj/ErikPoll/index.html> if i'm not misremembering)
08:46:11 <EvilTerran> ski, ok, i'll add 'em to my list of "potentially interesting papers to read when i have copious free time and energy" :P
08:47:10 <inimino> aka "paper purgatory"
08:47:28 <FunctorSalad> was trying to think of something similar.
08:47:42 <FunctorSalad> /dev/null? ;)
08:48:42 <inimino> it's crueller than /dev/null because it gives the papers false hope
08:50:18 <FunctorSalad> false? aren't you guaranteed to go to heaven after purgatory? ;)
08:51:28 <ski> maybe there is no guarantee of ever leaving purgatory ?
08:51:42 <inimino> yes, but this is like a special kind of purgatory where the only one who can let you out is not immortal
08:51:49 <jauaor> @faq can Haskell save you from purgatory?
08:51:50 <lambdabot> The answer is: Yes! Haskell can do that.
08:51:53 <opqdonut> "when you leave purgatory you will get into heaven"
08:52:47 <jauaor> Let's just hope purgatory is not a one way monad
08:53:49 <EvilTerran> would reincarnation involve a MonadFix instance?
08:54:23 <opqdonut> what does mfix correspond to categorically?
08:54:26 <opqdonut> :t mfix
08:54:27 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
08:59:06 <suca> !!!
08:59:11 <suca> hello
08:59:19 <suca> is anybody there??
08:59:33 <Zao> No. Just us hylomorphisms.
08:59:48 <EvilTerran> I'm a bot, I don't count.
09:00:12 <EvilTerran> ... lol what?
09:00:35 <opqdonut> :D
09:01:01 * AleksJ has just spent 20 minutes trying to find an explanation for @. google fails
09:01:21 <AleksJ> fortunately, the Haskell-98 reference helps there.
09:02:26 <EvilTerran> > let x @ (y,z) = (1,2) in unwords [show x, show y, show z
09:02:27 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
09:02:29 <EvilTerran> > let x @ (y,z) = (1,2) in unwords [show x, show y, show z] -- grr
09:02:30 <lambdabot>   "(1,2) 1 2"
09:03:21 <AleksJ> thanks terran!
09:03:41 <SamB_XP> AleksJ: yes, google is horrible at searching based on punctuation :-(
09:04:09 <AleksJ> it's funny, trying to learn Haskell improved my Python skills
09:04:17 <SamB_XP> heck, C++ and C# seem to be special cased
09:04:20 <burp> trying to do it?
09:04:20 <quicksilver> AleksJ: I hate that about google too
09:04:29 <quicksilver> SamB_XP: yup. That annoys me even more, in a way.
09:04:46 <ski> (SamB_XP : .. but not `F#' ?)
09:04:49 <SamB_XP> yeah, why can't they come up with a generalized way to do that stuff
09:05:05 <SamB_XP> and then just special case the suggestions to use it?
09:06:38 * ski wonders roughly how many programming languages have non-ascii characters in their name
09:07:24 <SamB_XP> ski: well, C# is rarely spelled correctly
09:07:31 <opqdonut> indeed.
09:07:47 <ski> hm, i guess that would apply
09:07:50 <opqdonut> does F# have a sharp too?
09:08:04 <ski> it's pronounced that way, in any case
09:08:04 <SamB> opqdonut: I suppose it's correctly spelled that way
09:08:04 <mauke> Plankalkül
09:08:32 <SamB> and I expect, yes, there are a number of them with european characters in the names
09:08:37 <ski> mauke : good one :)
09:08:44 <mauke> Fjölnir!
09:10:10 * quicksilver wonders if it is possible to actually type a 'sharp' on this computer
09:10:20 <SamB> C♯, F♯
09:10:27 <SamB> quicksilver: do you have SCIM?
09:10:34 <mauke> ♭
09:10:44 * quicksilver has no idea.
09:10:56 <SamB> I really need better text rendering here
09:11:05 <boml> what can be done to be able to paste stuff into ghci?
09:11:18 <quicksilver> Hmm I have no trouble pasting stuff into ghci
09:11:23 * mauke recommends you take a copy of http://mauke.ath.cx/stuff/javascript/unicode.html everywhere you go
09:11:39 <opqdonut> mauke: :)
09:11:41 <boml> quicksilver: it only pastes the first character
09:11:42 <SamB> anti-aliasing in x-chat is fail :-(
09:11:54 <SamB> the strokes come through far too thin
09:12:06 <SamB> I think it's an issue with light-on-dark
09:12:07 <boml> btw. i'm using windoze
09:12:26 <quicksilver> mauke, SamB : A google search for C-sharp with a real sharp sign fails ;)
09:12:29 <burp> http://mauke.ath.cx/stuff/javascript/unicode.html <- nice
09:12:30 <SamB> boml: "first character"?
09:12:49 <FunctorSalad> SamB: isn't that the responsibility of the font? ;)
09:13:11 <boml> let say I want to paste "foldr". it will only paste the "f" part
09:13:13 <SamB> FunctorSalad: that might be related as well
09:13:30 <SamB> but I think I've noticed dark-on-light working better
09:13:48 <ski> (mauke : that's one long line in the source ..)
09:13:56 <mauke> oh yeah
09:14:09 <mauke> it's hax-compressed
09:14:24 <SamB> boml: just what are you pasting into ?
09:14:36 <boml> SamB: ghci
09:14:43 <SamB> is it some wierd-ass GHCi *window*?
09:14:55 * ski never understood why some points in unicode have "black" or "white" in their names
09:15:01 <boml> SamB: nope. run cmd.exe and then ghci.exe
09:15:12 <SamB> ski: it's meant to apply when printing black on white
09:15:24 <SamB> ski: typesetting terminology is like that
09:15:30 <boml> just have to accept that ghci on windoze is foobar
09:16:00 <SamB> boml: it's running in the native console ?
09:16:08 <SamB> okay, yeah, that's foobar alright
09:16:17 <SamB> boml: report a bug
09:16:30 <boml> SamB: do you have a link:
09:16:42 <SamB> @bug
09:16:43 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
09:16:57 <SamB> boml: yes I do ;-)
09:17:04 <SamB> I wasn't sure that would work
09:17:19 <boml> i need ticket priveliges
09:17:28 <mauke> there's a guest account
09:17:41 <SamB> is account creation even disabled, though ?
09:18:06 <SamB> boml: I think that might just mean you should create a trac account and then visit that url again
09:18:23 <SamB> if you don't want to use guest/guest
09:18:47 <SamB> if you do use guest/guest, be sure to add your email address to the CC list for the ticket
09:22:14 <plumenator> Doesn't recursion result in a memory exhaustion? Or is recursion somehow eficient? (I'm guessing garbage collection)
09:22:43 <plumenator> On second thoughts, GC wou;dn't help.
09:22:59 <mmorrow> plumenator: it exhausts memory just as much as goto does in C
09:23:01 <mauke> depends on the recursion
09:23:27 <plumenator> mauke: Are you thinking tail call optimization?
09:23:38 <plumenator> mmorrow: can you elaborate
09:23:41 <boml> SamB: ticket has been created.
09:23:48 <SamB> mmorrow: no, it doesn't
09:23:50 <SamB> it does more
09:23:55 <SamB> if it isn't tail recursion
09:24:09 <mmorrow> SamB: well clearly i'm assuming tail recursion ;)
09:24:16 <SamB> mmorrow: bad assumption
09:24:22 <mmorrow> SamB: why?
09:24:40 <SamB> and even then, there *are* some compilers that don't properly support tail recursion
09:24:51 <mmorrow> i'm ignoring those
09:24:53 <plumenator> I remember reading Haskell doesn't have tail call optimization...
09:25:15 <mauke> plumenator: you're thinking of python
09:26:01 <plumenator> So, if I want my recursion to be optimal, I just need to make them tail recursive in Haskell?
09:26:13 <mmorrow> plumenator: kind of
09:26:22 <mauke> well, you usually don't recurse yourself
09:26:25 <plumenator> Hmm.. come to think of it, folds *are* tail recursive, aren't they?
09:26:26 <mauke> evaluation does
09:26:43 <mauke> plumenator: foldl is, foldr isn't
09:26:52 <mauke> but that doesn't matter because foldl sucks
09:26:59 <plumenator> mauke: Yeah, subtle.
09:27:09 <mauke> you don't want a tail recursive fold
09:27:32 <pikhq> plumenator: You might be interesting in this: http://home.pipeline.com/~hbaker1/CheneyMTA.html
09:27:44 <pikhq> Not a commonly used technique or anything, but rather interesting.
09:27:45 <pikhq> ;
09:27:50 <pikhq> Also, s/interesting/interested/
09:28:36 <mmorrow> plumenator: in haskell, it matters when it finally comes time to collapse a part of the huge graph of thunks/closure/frozen application/etc you've created with your expression. so you want the shape of the graph to be such that it collapses in an optimal way
09:28:55 <mmorrow> what's optimal depends on what the graph is building as it's collapsing :/
09:29:26 <plumenator> mmorrow: your description reminds me of an illustration in SICP. :-)
09:29:51 * mmorrow has never read SICP :(
09:30:12 <C-Keen> watch the videos
09:30:35 <plumenator> I've only read the firt 3 chapters..I'm a total noob.
09:31:58 * pikhq needs to read SICP. Started on Haskell a few days ago, so just be shocked that I can almost get monads. :P
09:32:20 <mauke> monads are trivial
09:32:36 <jpcooper> mauke, it seems that they're really trivial once one understands them
09:32:45 <jpcooper> I now can't see why I didn't understand them
09:32:47 <mauke> there is nothing to understand
09:32:54 <jpcooper> indeed
09:32:58 <mauke> there is almost no functionality in there
09:33:03 <pikhq> So, it's like a Zen koan.
09:33:05 <pikhq> :P
09:33:20 <burp> same lol
09:33:26 <mauke> do you know what a "group" is in math?
09:33:27 <burp> nothing special about it
09:33:31 <jpcooper> maybe it's because they're explained with the IO monad and it's not immediately apparent how the IO monad works
09:33:38 <jpcooper> I do
09:33:59 <mauke> groups are about as complicated as monads
09:34:32 <pikhq> Not really.
09:35:07 <mauke> why not?
09:35:09 <byorgey> groups are simpler IMO.
09:35:18 <jpcooper> well this is all subjective, isn't it?
09:35:37 <byorgey> indeed. =)
09:35:38 <mauke> groups have more operations
09:35:57 <pikhq> Huge mass of stuff I need to learn, and I'm just an innocent sophomore CS student...
09:36:01 <lament> monads have more laws
09:36:14 <lament> (or i guess they don't?)
09:37:47 <jpcooper> pikhq, so am I. It's strange to think that I'm only half way there
09:37:52 <jpcooper> it seems like so long already
09:38:10 <pikhq> Half-way? I mean "entering my sophomore year"...
09:38:14 <pikhq> Fourth of the way there, man. ;)
09:38:22 <jpcooper> damn
09:40:56 <byorgey> pikhq: don't worry. I just finished my first year of a PhD program, and spent the four years between an undergrad CS major and my PhD program reading stuff, and I STILL have a huge mass of stuff to learn =)
09:41:05 <jeffersonheard> is there a standard way to apply a function to both members of a pair individually and return a pair?
09:41:22 <byorgey> jeffersonheard: f *** f
09:41:23 <jpcooper> byorgey, you managed to go straight from a bachelors to a PhD?
09:41:29 <jeffersonheard> byorgey, thanks
09:41:44 <byorgey> jpcooper: that's the way it's done in most US institutions, the masters/PhD is combined into one program
09:41:49 <jpcooper> aah
09:41:50 <byorgey> jpcooper: so I've got like 5 years instead of 3
09:41:51 <pikhq> byorgey: I guess the only reason I get anything at all about Haskell is that I'm a madman. :P
09:41:55 <jeffersonheard> :t (***)
09:41:55 <jpcooper> bloody hell
09:41:57 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
09:42:06 <georgehorse> I hate things like *** that are not easily googled.
09:42:10 <byorgey> pikhq: aren't we all =)
09:42:20 <jpcooper> georgehorse, then you use hoogle
09:42:46 <georgehorse> I know. it's just a weird context switch for me still
09:42:50 <byorgey> @hoogle ***
09:42:50 <jeffersonheard> :t fromIntegral *** fromIntegral
09:42:51 <lambdabot> Control.Arrow (***) :: Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
09:42:51 <pikhq> byorgey: :)
09:42:52 <lambdabot> forall b c b' b1. (Integral b, Num c, Integral b', Num b1) => (b, b') -> (c, b1)
09:43:11 <jpcooper> pikhq, I wish that more of my classmates would forget the association between being interested in one's subject of study in depth and being a geek/madman/social outcast/whatever
09:43:12 <byorgey> @hoogle (a -> b) -> (a,a) -> (b,b)
09:43:12 <lambdabot> Control.Arrow (^<<) :: Arrow a => (c -> d) -> a b c -> a b d
09:43:12 <lambdabot> Control.Arrow (>>^) :: Arrow a => a b c -> (c -> d) -> a b d
09:43:12 <lambdabot> Data.Array.Base ixmap :: (IArray a e, Ix i, Ix j) => (i, i) -> (i -> j) -> a j e -> a i e
09:43:17 <georgehorse> also, not everything that is hard to google is specific to haskell :)
09:44:00 <pikhq> jpcooper: ... I find Brainfuck enjoyable to write in. *That's* my qualification for being called a madman. :P
09:44:08 <jpcooper> okay
09:44:53 <jpcooper> maybe if I ended up in Edinburgh instead of Glasgow, I wouldn't be looked upon as a bastard for mentioning doing a project in Haskell
09:45:06 <jpcooper> no actually, it was Scheme at the time
09:45:18 <byorgey> jpcooper: Haskell is looked down upon in Glasgow!!?!
09:45:27 <byorgey> that's the G in GHC!
09:45:39 <jpcooper> there's hardly any FP research going on at Glasgow anymore
09:45:45 <byorgey> ah, shame
09:45:50 <georgehorse> Is brainfuck the one with just 8 operations?
09:45:52 <jpcooper> no one there is working on GHC
09:45:56 <pikhq> georgehorse: Yes.
09:45:57 <jpcooper> or here
09:46:05 <pikhq> Only 6 of which are needed for Turing completeness.
09:46:17 <byorgey> jpcooper: yeah, I know no one there is working on it now but I thought maybe people would have more of a sense of history =)
09:46:22 <pikhq> (the other two are for stdio)
09:46:24 <georgehorse> inc/decrement the pointer/value at the pointer, put/getchar, and the branch/loop i don't remember which?
09:46:32 <pikhq> Loop.
09:46:48 <jpcooper> though what I'm talking about is asking someone to do a project with me in Scheme, and getting slandered for bringing up such a language, and oh, why are you talking about functional programming to first years and whatever
09:46:58 <jpcooper> this was on our CS forum
09:47:01 <byorgey> yikes
09:47:23 <byorgey> those poor first years, how will their poor little brains ever recover!
09:47:54 <jpcooper> and then the same lecturer who puts me down for this tells me that I'm a troll when I suggest Emacs as an IDE
09:48:07 <georgehorse> pikhq: Do you enjoy writing in it directly, or writing programs to write to write brainfuck, or maybe writing programs to write programs to write programs to
09:48:09 <byorgey> wow.
09:48:19 <pikhq> georgehorse: All of the above.
09:48:21 <jpcooper> so this totally put me off staying at the university, but I'm stuck here
09:48:26 <byorgey> =(
09:48:34 <georgehorse> jpcooper: that's too bad :/
09:48:51 <jeffersonheard> :t (fromIntegral >>^)
09:48:52 <lambdabot> forall b c d. (Integral b, Num c) => (c -> d) -> b -> d
09:49:00 <pikhq> jpcooper: The only problem I see with teaching functional programming to a first-year student is that you need a really good professor for it.
09:49:54 <jpcooper> pikhq, well I made a post explaining a few things like recursion and HOFs. I thought that this would be fine and that people would be interested. After all, I'd started Scheme before I'd started university. I didn't expect what I got
09:50:19 <pikhq> The same applies for teaching C, C++, or Java to first-year students, but universities still do it.
09:50:27 <jpcooper> yeah we got Python in the first year
09:50:47 <pikhq> Mmm, Python's not bad for that. Better than a C-like, at least.
09:50:57 <jpcooper> what did you have?
09:51:01 <pikhq> C++.
09:51:03 <Berengal> Actually, I wouldn't C itself would be that bad
09:51:07 <jpcooper> goodness
09:51:19 <jpcooper> that would be me off programming if I'd never done it before
09:51:21 <georgehorse> C/scheme/c++ here
09:51:31 <pikhq> Berengal: Pointers are hard for someone just getting used to the idea of handing instructions to a computer.
09:51:32 <jpcooper> what are the lecturers thinking?
09:51:38 <pikhq> Dunno.
09:51:48 <Berengal> pikhq: True, but you don't need pointers to get started
09:51:55 <pikhq> I've been programming for a good 11 years now, though, so it didn't exactly put me off.
09:51:57 <portnov> how about Pascal (Turbo Pascal) for education at first year? :o)
09:52:04 <byorgey> is the code.haskell.org webserver down?
09:52:07 <jpcooper> portnov, shouldn't you be dead yet?
09:52:07 <pikhq> portnov: Eeeew.
09:52:08 <Vanadium> My first two semesters of computer science were Java. Look where it got me :'(
09:52:17 <pikhq> I'd sooner hand students APL.
09:52:38 <pikhq> (oh, it also helped that I already knew C++.)
09:52:50 <inimino> ooh, APL as a first-year language
09:52:55 <Berengal> C gives people a feel for what's really going on when programming, which can be helpful
09:53:00 * bremner had pascal in first year, back when the dinosours roamed the earth
09:53:07 <mmorrow> , [$bf|.+[.+]|]
09:53:08 <mmorrow> , [$bf|.+[.+]|] ""
09:53:10 <lunabot>  luna: No instance for (GHC.Show.Show
09:53:10 <lunabot>  "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK...
09:53:18 <lament> anything is better than Java :)
09:53:25 <jpcooper> %(*&#(*&#SDFLKJ(*&(*&#$@ <-- 2 + 2 in APL
09:53:26 <osfameron> lament: cobol?
09:53:28 <byorgey> Berengal: C should be learned in parallel with an architecture course, IMO.
09:53:28 <pikhq> C never really clicked for me until I learned assembly...
09:53:29 <lament> (which is what i had...)
09:53:29 * jeffersonheard programmed video games in turbo pascal on the 386 back in the day
09:53:35 <byorgey> not in the first year.
09:54:03 <mauke> byorgey: I strongly disagree
09:54:12 <boml> why can I not add an Integer to an Int (Integer + Int)?
09:54:12 <mauke> that only teaches you bad C habits :/
09:54:13 <pikhq> byorgey: I've seen universities which don't even teach anything but Java. First-year C is at least far better than that.
09:54:24 <mauke> boml: because (+) only works on values of the same type
09:54:28 <Botje> boml: because Haskell numbers suck.
09:54:29 <pikhq> boml: Because an Integer is not an Int.
09:54:32 <Botje> fromIntegral the Int
09:54:38 <byorgey> mauke: not if you've learned good habits in other languages first.
09:54:43 <Berengal> Personally though, I think you should learn at least two languages at once
09:54:57 <mauke> byorgey: I'm not convinced
09:55:05 <boml> I think Integer + Int is safe
09:55:06 <Berengal> C or (RISC) assembly, and something high-level
09:55:08 <jeffersonheard> imo, CE/EE should be taught something like C their first year and something lambda calculus based later and CS should be taught a functional language first and then a procedural/OO
09:55:13 <copumpkin> boml: it is, internally
09:55:27 <byorgey> mauke: fair enough, I've not convinced myself either =)
09:55:28 <jpcooper> Berengal, learning RISC was definitely fun
09:55:41 <copumpkin> boml: addIntegerInt i (I# x) = i + (S# x)
09:55:44 <jeffersonheard> reason being that the EE/CE has to understand how the computer does things, whereas the CS student has to understand how to precisely state a problem and its solution.
09:55:48 <jpcooper> jeffersonheard, amen
09:56:09 <jpcooper> I think that Edinburgh University understand this, what with teaching Haskell in the first year
09:56:10 <SamB> jeffersonheard: yeah, I don't know what professor koskol was thinking changing the initial programming course to use matlab ...
09:56:29 <SamB> for EEs at my school
09:56:34 <byorgey> matlab!!? pardon me while I vomit
09:56:37 <Berengal> jeffersonheard: True, but it can also help for CS students who have never programmed before
09:56:51 <Berengal> Just to get them in touch with the computer
09:56:51 <jpcooper> SamB, is he some scientist who happened to start lecturing in CS?
09:56:56 <copumpkin> matlab is nice for working quickly with matrices, but that's about it
09:56:59 <byorgey> I had to use that sorry excuse for a "language" last fall
09:57:01 <copumpkin> it's an ugly mess otherwise
09:57:03 <byorgey> copumpkin: no it isn't.
09:57:11 <byorgey> it isn't nice for anything.
09:57:18 <boml> copumpkin: what is that??
09:57:18 <SamB> jpcooper: no, she's part of the EE faculty
09:57:32 <copumpkin> byorgey: I like being able to multiply and transpose matrices in a couple of characters, but mostly hate the language
09:57:40 <jpcooper> SamB, did she say why matlab should be used?
09:57:44 <copumpkin> boml: taking advantage of the internal representation of Integer, but I was mostly being silly :)
09:57:44 <pikhq> copumpkin: Can't APL do the same?
09:57:56 <byorgey> copumpkin: yes, I like being able to do that too, but there are other languages that can also do that.
09:58:01 <jpcooper> pikhq, you should have a look at J. It's rather interesting
09:58:05 <byorgey> like J, yes.
09:58:06 <copumpkin> pikhq: yeah, but I'm not sure a write-only language is good for beginners
09:58:19 <SamB> jpcooper: I dunno, I'd already gotten credit for that course transferred from Lehigh so didn't have to take it
09:58:23 <pikhq> Fair enough. ;)
09:58:44 <SamB> I go to widener now
09:58:59 <pikhq> Speaking of write-only languages... Totally, totally should teach Perl and Teco to freshmen.
09:59:14 <SamB> what's teco?
09:59:24 <SamB> I thought that was, like, some emacs precurser?
09:59:33 <jpcooper> that was tecomacs
09:59:36 <Berengal> One thing's for sure, Java is not a good first language. Much too easy to run into a wall of Enterprise
09:59:40 <pikhq> Teco is the language Emacs was written in initially.
10:00:04 <pikhq> It's like ed, but with more features.
10:00:15 <SamB> when did they port emacs away from that?
10:00:18 <SamB> and what to?
10:00:24 <mauke> pikhq: but Perl isn't write only
10:00:36 <jpcooper> it's in C + elisp now, isn't it?
10:00:38 <Adamant> mauke: are you sure?
10:00:43 <mauke> Adamant: yes
10:00:47 <SamB> mauke: you only say that because you haven't seen perl 6 yet, I think :-P
10:00:49 <pikhq> SamB: Emacs got rewritten for the GNU project.
10:01:08 <pikhq> And before that, other people had reimplemented Emacs in other languages, because it was cool.
10:01:13 <mauke> SamB: "Perl" with no qualification refers to Perl 5
10:01:21 <SamB> yeah, they have an Emacs in CMUCL too don't they?
10:01:32 <mauke> climacs?
10:01:39 <pikhq> GNU Emacs got written in Lisp because Stallman was sick and tired of Teco, and decided a hacked-together Lisp would be nicer.
10:01:42 <SamB> mauke: touche
10:01:44 <mauke> and what was this hemlock thing
10:01:47 <pikhq> (and it is)
10:01:53 <SamB> mauke: I meant hemlock
10:02:07 <SamB> though for some reason I was trying to spell it with a W or something ...
10:02:49 <georgehorse> rms wrote the first emacs in teco. a bunch of people over the next few years ported it to everything. one notable one being by gosling, in C, with some dialect of lisp. rms rewrote emacs in c based more or less on goslings version, GNU'd it, gave it elisp etc.
10:04:40 * SamB tries to remember the name of that 2d platform shooter that's written largely in a lisp that bothered him so much because he couldn't figure out how to implement that lisp as a CL package :-(
10:06:06 <mauke> Jak and Daxter?
10:06:14 <SamB> mauke: nope
10:06:20 <Baughn> Am I a bad, bad person for instancing Num just for fromInteger? Or is it GHC's fault for putting it there?
10:06:26 <SamB> might have been speed? amphetamine?
10:07:04 <SamB> some fictional drug name ?
10:08:26 <jpcooper> mauke, it's not 2d
10:08:44 * SamB searches for it in aptitude
10:09:26 <gwern> (learning scheme can be difficult for me because of the type sigs; I'm not used to functions returning different types; like this 'member' function - it returns booleans or objects)
10:09:37 <SamB> ah.
10:09:39 <gwern> SamB: sounds like crash bandicoot, except that wasn't a shooter
10:09:45 <SamB> Abuse
10:09:54 <jpcooper> gwern, you mean it returns nil on not finding anything?
10:10:01 <SamB> gwern: crash bandicoot has 3D graphics
10:10:10 <gwern> jpcooper: iirc, it returns #f
10:10:12 <Adamant> so did Jak and Daxter
10:10:19 <SamB> and I don't have the lisp code for it so couldn't try to re-implement the lisp!
10:10:24 <jpcooper> oh yes, I was thinking of CL
10:10:31 <gwern> SamB: so? you can have 3d graphics and still be a 2d game
10:10:37 <SamB> gwern: true, true
10:10:44 <SamB> I meant with 2d graphics though ;-)
10:10:57 <jpcooper> Jazz Jackrabbit?
10:11:00 <SamB> I think crash has 3d portions though
10:11:33 <SamB> anyway, I meant "abuse"
10:11:42 <SamB> from Crack dot Com
10:11:52 <jpcooper> Zool?
10:12:06 <jpcooper> oh I'm just guessing now
10:28:54 <jkramer> Ahoy
10:29:30 <jkramer> is there something for a profiler or tracer for haskell?
10:30:04 <jkramer> I think I have a little problem with lazy evaluation and I'd like to see when and where the expression is actually evaluated
10:30:26 <mauke> ghc has options for profiling
10:32:22 <Berengal> Off topic, but does anyone here know the status of closures in Java 7?
10:32:43 <jkramer> And how do I get the profiling information?
10:32:56 <mauke> dunno
10:35:33 <soupdragon> Berengal: it's had them since day 1
10:36:17 <byorgey> jkramer: to start, compile with -prof -auto-all, and then pass  +RTS -p  to the executable
10:36:27 <byorgey> jkramer: then there will be profiling info in  a .prof file
10:36:53 <byorgey> jkramer: there are many other options you can pass other than -auto-all or -p, check the GHC documentation for more info.
10:37:13 <jkramer> Thanks, already found it
10:37:32 <jkramer> But the output doesn't really help
10:41:11 <jkramer> Maybe someone here can help me
10:41:14 <jkramer> http://haskell.pastebin.com/de210291
10:41:32 <iago> uhm hello, someone has experience in verification of Haskell code?
10:41:48 <jkramer> It's a kind of map that forks a new thread for every element in the list
10:42:06 <jkramer> The result is put into an mvar so the parent can collect it
10:43:13 <jkramer> I think with the $! in line 11 it's finally working, but I'm still not completely sure if the calculations are really performed in the threads or if the function calls are pushed back to the parent where they are evaluated
10:44:10 <Berengal> soupdragon: I wouldn't call inner classes closures
10:44:38 <soupdragon> they don't even have to be inner classes, any class is fine
10:45:10 <Berengal> Classes are even less closures
10:45:46 <Berengal> There's nothing to close over outside an outer class
10:48:55 <jkramer> Any ideas or hints?
10:59:06 <kowey> some Edinburgh hackathon notes (I'll probably write these up in a mail)
10:59:58 <kowey> we have so far 5 people (Brent, Ravi, Simon, Ian, me) who have expressed an interest; of which 3 [Brent-Simon] can do 29-30 August only
11:00:29 <kowey> or actually, I think Simon M can do either, but says 29-30 works best for him
11:01:08 <kowey> also we have a room for Sunday 30 Aug in the ICFP venue that we can use from 0900 to 1700 if we want
11:03:13 * kowey could have sworn he saw something about an Edinburgh Haskell user group in haskell-cafe
11:05:02 <byorgey> kowey: yeah, Dougal Stanton is trying to get something organized
11:05:15 <byorgey> I don't think he's usually on IRC
11:06:33 <kowey> thanks, byorgey! I'll email him and see if he's interested (and is available to take charge)
11:13:39 <Taejo> ():->c -- gotta loves Haskellers' smileys (I think this one is grinning angel with a goatee)
11:14:02 <Badger> A chin ring.
11:14:17 <Taejo> yeah, that's better
11:25:35 <gwern> hm. c.h.o down?
11:27:29 <jmcarthur_work> i don't see a hoedown
11:28:11 <enolan> I like the :-?> type operator. Confused man with goatee
11:32:28 <gbacon> projects.haskell.org down?
11:35:53 <jesmon> can anyone help with a happstack-helpers compile error? Error:
11:35:56 <jesmon> Could not deduce (Functor m) from the context (Methods st, Component st, ToMessage b, Monad m) arising from a use of `simpleHTTP'' at Happstack/Server/Helpers.hs:23:22-47
11:36:42 <roconnor>  ... stupid cannot deduce Functor from Monad erros.
11:38:01 <jesmon> roconnor: is there a simple fix?
11:38:48 <roconnor> jesmon: nope.  Is this a problem compiling hapstack-helpers, or your own code?
11:39:00 <roconnor> or is happstack-helpers your own code?
11:40:04 <jesmon> roconnor: not my code, I was just trying to build happstack-helpers-0.22 with cabal
11:40:30 <jesmon> and ghc 6.10.3
11:41:11 <roconnor> jesmon: I guess that means some of the dependency specs are broken.
11:41:52 <glguy> Crypto's Data.LargeWord.largeWordShift seems broken for right shifts
11:43:30 <glguy> *Data.LargeWord> (fromIntegral 0x100000000 :: Word96) `shift` (-1)
11:43:30 <glguy> 0
11:50:01 <roconnor> jesmon: what version of happstack-server do you have installed?
11:52:41 <FunctorSal> sigh... making QC2 incompatible was a bad move, maybe
11:54:14 <roconnor> jesmon: okay. From what I have surmised (and I've never used happstack) the happstack-helpers package is out of date with the current happstack.
11:54:28 <roconnor> jesmon: I blame cabal for not tracking interfaces.
11:55:02 <roconnor> jesmon: cabal says that tracking interfaces is too hard, and it is upto happstack-helpers to properly constrain version dependencies.
11:55:29 <roconnor> jesmon: and the happstack-helper people have put *no* version constraints on their dependencies at all.
11:55:44 <roconnor> so I guess you need to complain to the happstack-helper maintainer
11:56:20 <sm> version constraints ? pah, we laugh at your feeble constraints
11:56:29 <roconnor> If you need it to work right now, installing happstack 0.2.* would probably work.
11:57:24 <sm> fwiw I successfully cabal installed happstack with the latest haskell platform a week or so ago
12:01:54 <roconnor> sm: did you install happstack-helpers?
12:02:35 <sm> ah, I'm not sure about that
12:03:44 <roconnor> given that happstack-helpers has not version constraints on its dependencies, I doubt you can cabal install it now.
12:05:55 <jesmon> roconnor: happstack-server-0.3.2
12:07:47 <Saizan> jesmon: happstack-helpers wants 0.2.* probably
12:12:16 <jesmon> Saizan: is there any trick to removing the newer version? I just did 'cabal install happstack-server-0.2.1' and it seemed to work, but I still get the same build error
12:12:17 <hackagebot> mps 2009.6.25 - message passing style helpers (JinjingWang)
12:12:50 <Saizan> jesmon: you can ghc-pkg unregister happstack-server-0.3.2
12:13:20 <Saizan> jesmon: or cabal install happstack-helpers --constraint="happstack-server < 0.3"
12:15:18 <hackagebot> hcheat 2009.6.25 - A collection of code cheatsheet (JinjingWang)
12:17:21 <hackagebot> nemesis 2009.6.25 - a rake like task management tool (JinjingWang)
12:18:22 <jesmon> Saizan: looks like it's causing a mess of dependency problems
12:18:28 <roconnor> > 77.93/2
12:18:29 <lambdabot>   38.965
12:19:59 <roconnor> jesmon: you probably need to constraint more than just happstack-server.
12:20:01 * roconnor sighs
12:20:22 <hackagebot> hack-contrib 2009.6.25 - Hack contrib (JinjingWang)
12:20:27 <roconnor> happstack-helper really need proper depencency constraints
12:20:33 * sm wonders how the TH magic works in eg http://github.com/nfjinjing/hcheat/blob/8b7fc0d1fe8279cd05a7da8ce4f6dc27e8773fe1/src/Web/HCheat.hs
12:21:50 <sm> it imports here :: QuasiQuoter from MPS.TH.. and has a LANGUAGE QuasiQuotes pragma.. does this effectively turn on TH ?
12:24:31 <jesmon> roconnor: http://fpaste.org/paste/16371
12:24:58 <jesmon> tried to install happstack-data-0.2.1 and cabal can't seem to find it
12:26:41 <roconnor> jesmon: should should probably add constaints in the command line for happstack-data, happstack-ixset, happstack-server, happstack-state.
12:26:53 <roconnor> and make sure all the 0.2 versions of these are all installed
12:27:00 <roconnor> what a pain
12:27:55 <roconnor> I almost think you should edit the happstack-helper .cabal file to place in all these constraints
12:28:00 <roconnor> and then upload it to hackage.
12:28:13 * sm wonders if "quasiquoting" and "template haskell" are essentially the same thing
12:28:33 <roconnor> sm I don't think so, but I'm not sure
12:28:47 <sm> and if TH is safe to use for cross-platform apps today
12:29:24 <hackagebot> bamboo 2009.6.25 - A simple blog middleware on hack (JinjingWang)
12:30:24 <hackagebot> bamboo-theme-blueprint 2009.6.25 - bamboo blueprint theme (JinjingWang)
12:30:31 <Saizan> jesmon: cabal install happstack-helpers --constraint="happstack-server < 0.3" --constraint="happstack-state < 0.3" --constraint="happstack-ixset < 0.3" --constraint="happstack-data < 0.3" --constraint="happstack-util < 0.3"
12:30:38 <Saizan> that should work
12:31:43 <sm> roconnor: you're right, QQ seems to be a TH-ish thing that was created after TH and is now bundled with it
12:31:47 <roconnor> jesmon: actually, if you are willing to test out a new .cabal file, I'd upload it if you like?
12:32:41 <jesmon> roconnor: I'm willing to test, sure
12:35:14 <Saizan> jesmon: it does install fine with that command line, i've just tested it
12:36:07 <roconnor> Saizan: should I add >= 0.2  && < 0.3 constraints or just < 0.3 contraints?
12:37:05 <roconnor> jesmon: step 1, donwload http://hackage.haskell.org/packages/archive/happstack-helpers/0.22/happstack-helpers-0.22.tar.gz and unpackage it.
12:37:42 <Saizan> roconnor: if you're not going to test against 0.1 i'd use >= 0.2 && < 0.3
12:37:58 <roconnor> Saizan: adding just < 0.3 constraints is the minimal change to make it "work"
12:38:12 <roconnor> but I suspect >= 0.2 is proper
12:38:22 <jesmon> Saizan: thanks for testing that. I'll the new cabal file first, then that
12:38:45 <Saizan> jesmon: no reason to do both :)
12:39:13 <roconnor> jesmon: btw, are you on windows or linux?
12:39:31 <jesmon> linux
12:39:36 <roconnor> ok
12:39:44 <roconnor> let me know when you are done step 1
12:39:57 <jesmon> ok, got the package
12:40:04 <roconnor> unpacked
12:40:06 <roconnor> ?
12:40:08 <jesmon> yep
12:40:32 <roconnor> okay, we are going to edit happstack-helpers.cabal
12:40:41 <roconnor> Saizan: you watch to make sure we are doing this right
12:41:17 <Saizan> roconnor: k
12:41:18 <roconnor> jesmon: step 2: replace Version: 0.22  with Version: 0.22.1 on line 2
12:41:29 <jesmon> ok
12:41:43 <Saizan> btw, with a recent enough cabal-install step 1 is simply "cabal unpack happstack-helpers"
12:41:55 <roconnor> oh neat
12:42:14 <roconnor> jesmon: now we are going to edit the Build-Depends: line
12:42:28 <roconnor> jesmon: step 3: replace that line with
12:42:30 <roconnor> hmm
12:42:32 <roconnor> I better paste it
12:42:34 <roconnor> @paste
12:42:35 <lambdabot> Haskell pastebin: http://hpaste.org/new
12:43:13 <roconnor> jesmon: replace with http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6212#a6212
12:43:42 <jesmon> alright, that's done
12:43:50 <roconnor> okay save it
12:44:03 <roconnor> now to test it
12:44:21 <roconnor> I think what you want to do now is "cabal install".
12:44:33 <Saizan> yeah
12:44:35 <roconnor> although it might possibly complain that depencencies are missing
12:44:49 <roconnor> I don't think cabal install will automatically fetch dependencies
12:44:53 <Saizan> it does
12:44:57 <roconnor> oh
12:44:58 <jesmon> I don't recall, do I have to do cabal-configure && cabal-build?
12:44:59 <roconnor> ok
12:45:07 <Saizan> jesmon: no, just cabal install
12:45:08 <jesmon> or something to that effect
12:45:14 <jesmon> ok
12:45:20 * ac just learned about Haskell Platform
12:45:24 <monochrom> sometimes "cabal" means "cabal-install", sometimes not
12:45:28 <roconnor> jesmon: ah right, now I remember "cabal install" does all that for you, including fetching dependecies
12:45:33 <ac> would it be stupid to install it if I already have cabal and a bunch of libraries installed?
12:46:02 <roconnor> ac: I think so, but I'm kinda opinionated
12:46:07 <Saizan> monochrom: yeah, that's unfortunate, i use Cabal when i mean the library
12:46:21 <roconnor> ac: I wouldn't install the HP unless I had a particular reason to do so.
12:46:40 <ac> roconnor: I'm just curious about it. It's basically just a bunch of libraries right? Or does it come with programs too?
12:47:01 <roconnor> ac: as far as I understand it is a bunch of libraries.
12:47:07 <roconnor> I'm not an expert though
12:47:12 <roconnor> having never installed it. :)
12:47:14 <Saizan> programs like alex happy haddock and something else too
12:47:17 <jesmon> roconnor: success!
12:47:23 <Saizan> but you probably have those installed anyway
12:47:34 <roconnor> jesmon: okay, I'll see if I can upload it now so no one else has this trouble ever again
12:48:19 * Saizan has mixed feelings about uploading a fixed package while not being the maintainer
12:49:06 <roconnor> Saizan: I've done it before. ... not that I don't have mixed feelings either.
12:49:28 <roconnor> But I think I'll keep doing it until something awful happens to teach me not to.
12:49:42 <roconnor> heh
12:49:46 <roconnor> 400 Error in upload
12:49:47 <roconnor> The dependency 'build-depends: base' does not specify an upper bound on the version number. Each major release of the 'base' package changes the API in various ways and most packages will need some changes to compile with it. The recommended practise is to specify an upper bound on the version of the 'base' package. This ensures your package will continue to build when a new major version of the 'base' package is released. If you are
12:49:49 <roconnor> not sure what upper bound to use then use the next  major version. For example if you have tested your package with 'base' version 2 and 3 then use 'build-depends: base >= 2 && < 4'.
12:49:51 <roconnor> oops
12:49:56 <roconnor> that was bigger than I thought
12:50:14 <roconnor> jesmon: what is your version of base ?
12:50:18 <Zao> At least your IRC client cuts messages up.
12:50:55 <jesmon> roconnor: 4.1.0
12:51:02 <roconnor> really?
12:51:03 <roconnor> hmm
12:51:08 <roconnor> Saizan: what is your version of base?
12:51:34 <byorgey> ac: you should try installing HP next time you have a brand new system and want to get a nice Haskell toolchain installed quickly.
12:51:48 <roconnor> Saizan: assuming you managed to build happstack-helpers on your machine
12:52:13 <ac> byorgey: yeah, it's a pain getting all of cabal-install's dependencies
12:52:35 <roconnor> doesn't cabal install come with the latest GHC?
12:52:58 <byorgey> ac: well, cabal-install itself now comes with a bootstrap script... although I just remembered you are on Windows, not sure if there's a cabal-install bootstraper for Windows.
12:52:59 <dons> no. it comes with the haskell platform
12:53:10 <Zao> Thankfully.
12:53:22 <ac> byorgey: where'd you get that idea? I run Ubuntu
12:53:23 <Saizan> roconnor: mine was 4, but i'm testing on ghc-6.8.3 now
12:53:33 <Zao> Well, the shell script works if you happen to have a decent msys+mingw around.
12:53:43 <Zao> But you end up with a zombie cabal, half mingw, half windows.
12:54:28 <Saizan> zombie cabal :O
12:54:37 <byorgey> ac: oh, I dunno. =)
12:54:55 <byorgey> ac: well, in that case, next time you want to install cabal-install, use bootstrap.sh!
12:55:01 <Saizan> roconnor: it works on base 3 too
12:55:06 <byorgey> it downloads all the dependencies for you.
12:55:21 <ac> byorgey: awesome. Props to whoever wrote that :)
12:55:27 <roconnor> Saizan: happstack-data says less that 4, so you guys must have not been using 4 when building
12:55:38 <Zao> Saizan: I ended up with an annoyingly schizo cabal. It installed some things in my msys home, some in my windows home, and was a bit divided on what to trust it had.
12:55:57 <Zao> Saizan: Even more confused when run as superuser, as then it didn't have access to my msys install.
12:55:57 <roconnor> Saizan: I'm tempted to up in <4 since that is the contraint happstack has.
12:56:05 <roconnor> to put in <4
12:56:44 <byorgey> anyone in here who can restart the code.haskell.org web server?
12:56:50 <roconnor> oh no I'm wrong
12:56:58 <roconnor>   if flag(base4)
12:57:00 <byorgey> dcoutts? Igloo? (guessing here)
12:57:00 <roconnor>     Build-Depends:    base >=4 && < 5, syb
12:57:01 <roconnor>   else
12:57:03 <roconnor>     Build-Depends:    base < 4
12:57:09 <roconnor> is the contraint in happstack
12:57:27 <byorgey> I can ssh to code.haskell.org but get no response from the web server
12:57:30 <sjanssen> byorgey: dons probably can
12:57:45 <roconnor> Saizan: okay, I'll say base >= 3 && < 4 then.
12:57:54 <roconnor> er
12:57:55 <byorgey> I always forget where the different haskell.org machines are physically located.
12:57:57 <roconnor> Saizan: okay, I'll say base >= 3 && < 5 then.
12:58:18 <byorgey> is it on the wiki somewhere?
12:58:29 <Saizan> roconnor: wait a minute, i didn't really test it against base-4 because of how cabal works
12:58:38 <roconnor> oh
12:58:40 <roconnor> ok
12:58:48 * roconnor waits
12:59:40 <copumpkin> ChilliX: you around?
13:01:10 <Saizan> roconnor: ok, if it picks base-4 you need syb too, so you have to replicate that if flag(base4) .. else .. from happstack here
13:01:21 <codebliss> How would I grab the output of System.system "ls -al"?
13:01:26 <roconnor> really?
13:01:32 <codebliss> Not the ExitCode, what's outputted to std
13:01:35 <roconnor> Saizan: I find that hard to believe
13:01:40 <Saizan> roconnor: why?
13:02:01 <roconnor> because the happstack dependency should pick out the syb dependency too?
13:02:12 <roconnor> oh
13:02:19 <roconnor> unless happstack-helper uses syb?
13:03:13 <Saizan> yeah, it does
13:03:16 <Saizan> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6213#a6213
13:03:43 <codebliss> How would I constantly read the stdout?  Like after System.system "(command)
13:04:02 <Zao> codebliss: By not using system, likely.
13:04:16 <Saizan> (putting the base == 4.* constraint in the .cabal file is the only way to make it use base-4 currently)
13:04:26 <roconnor> Saizan: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6213#a6214
13:04:34 <roconnor> I should add those lines to the cabal too?
13:04:41 <roconnor> to declare the flag?
13:04:45 <Zao> System.Process.runProcess seems relevant.
13:04:50 <Zao> http://hackage.haskell.org/packages/archive/process/1.0.1.1/doc/html/System-Process.html
13:04:59 <Saizan> roconnor: you only need "flag base4"
13:05:24 * roconnor removes the Flag tests
13:06:41 <roconnor> Saizan: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6213#a6215  is my new cabal file
13:07:07 <roconnor> oops
13:07:16 <roconnor> forgot to remove bases
13:07:25 <gwern> codebliss: steal the runShellCommand code from filestore
13:07:44 <gwern> much faster than working with the base libs and endlessly debugging your cobbled together monstrosity
13:08:08 <roconnor> Saizan: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6213#a6216  is my new cabal file
13:08:49 <codebliss> gwern: "Note that this does not actuall go through /bin/sh! " =/
13:08:50 <Saizan> roconnor: you should have base >= 3 && < 4 in the else branch, i think
13:09:32 <roconnor> Saizan: it isn't what happstack uses, but I do agree with you
13:09:45 <gwern> codebliss: where's that from?
13:09:59 <codebliss> http://hackage.haskell.org/packages/archive/filestore/0.3/doc/html/Data-FileStore-Utils.html#v%3ArunShellCommand
13:10:05 <gwern> it's spelled correctly here
13:10:15 <gwern> but why would you want to go through sh to use ls?
13:10:23 <roconnor> Saizan: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6213#a6217  is my new cabal file
13:10:37 <Saizan> roconnor: because they never test on 6.6, but they don't support that version of ghc anyway
13:10:39 <roconnor> Saizan: crap
13:10:50 <gwern> (if you're calling ls, then you're calling ls; /bin/sh need not have anything to do with it)
13:10:55 <codebliss> I want the output of a console command
13:11:11 <Saizan> heh, && there has to be written , :)
13:11:12 <codebliss> It's probably a bash command
13:11:28 <codebliss> bash has an input h/o lemme check man
13:11:33 <roconnor> Saizan: maybe this is good: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6213#a6218
13:12:04 <Saizan> roconnor: that looks good
13:12:06 <codebliss> brandon@brandon-laptop:~$ /bin/bash -c "ls -l"
13:12:09 <codebliss> Yep, that works
13:12:11 <roconnor> ship it!
13:12:24 <codebliss> So how do I capture the stdout? XD
13:12:32 <roconnor> cabal sdist
13:12:34 <roconnor> cabal: happstack-helpers.cabal:22: Construct not supported at this position:
13:12:35 <roconnor> IfBlock 22 "flag(base4)" [F 23 "build-depends" "base >=4 && < 5, syb"] [F 25
13:12:36 <gwern> ls is not a bash builtin
13:12:37 <roconnor> "build-depends" "base >=3 && < 4"]
13:12:40 <roconnor> hmm
13:12:42 <codebliss> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/io-capture
13:12:43 <gwern> it's a regular binary in /bin/ls
13:12:44 <codebliss> Got it, thanks
13:12:58 <codebliss> gwern: I know...I'm using that example for simplicity's sake
13:13:26 <roconnor> Saizan: do I need to put "Library" before the dependencies?
13:13:32 <Saizan> roconnor: ooh, right, that's an old style cabal file, it has to be restructured to support flags
13:13:46 <roconnor> ok
13:13:46 <gwern> hm. I'm not sure I trust that io-cpature code. looks like it may have strictness issues
13:14:40 <gwern> codebliss: and you know, it looks to me like that doesn't go through sh either
13:14:49 <Saizan> roconnor: like this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6213#a6219
13:15:21 <roconnor> Saizan: will we need to add a Cabal constriant?
13:16:15 <gwern> roconnor: cabal check will tell you
13:16:30 <gwern> if you use flags it's something like cabal-version: >= 1.4
13:16:38 * roconnor notices that                    Happstack.Data.IxSet.Helpers has no comma at the end
13:16:53 <gwern> cabal allows  newline or commas
13:16:59 <gwern> I think
13:17:06 <Heffalump> is there something wrong with trac.haskell.org ?
13:17:12 <gwern> I'm pretty sure i've done module\nmodule2\nmodule3\n etc
13:17:14 <Saizan> roconnor: right, you need a Cabal-Version: >= 1.2 field
13:17:37 <Heffalump> oh, and indeed code.haskell.org (same machine)
13:17:58 <roconnor> gwern: cabal check accepts >= 1.2
13:18:34 <Saizan> roconnor: i think this is finally the right .cabal http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6213#a6220
13:18:45 <gwern> roconnor: close enough
13:18:52 <roconnor> Saizan: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6213#a6221
13:19:00 <gwern> bsd3.txt srsly?
13:19:10 <deavid> hmm... just a question; anyone know a channel where I can find spanish people that know about haskell ?
13:19:20 <deavid> IRC channel, i mean
13:19:31 <Saizan> tried #haskell.es ?
13:19:58 <roconnor> Package happstack-helpers-0.22.1 contains no fatal errors.
13:20:00 <roconnor> However the package generated the following warnings:
13:20:01 <roconnor>     * Exposed modules use unallocated top-level names: Happstack
13:20:13 <roconnor> we have allocated top-level names?
13:20:17 <gwern> looks reasonable, but I don't like the category
13:20:26 <gwern> roconnor: all the base lib stuff; in this case it should be fine
13:20:47 <gwern> no one will really complain if happstack modules aren't carefully categorized into Text. or Network.
13:21:25 <roconnor> gwern: all the base lib stuff?
13:21:42 <roconnor> gwern: I think changing the category might be outside the scope of "bug fixing"
13:21:48 <roconnor> gwern: although it is tempting
13:22:00 * roconnor resists the temptation
13:22:00 <gwern> yeah. and I see the holumbs packages are also in it, so it might be too late
13:22:11 <gwern> Distributed Computing is just terrible though
13:23:40 <roconnor> aww
13:23:43 <roconnor> jesmon just left
13:23:43 <hackagebot> happstack-helpers 0.22.1 - Convenience functions for Happstack. (RussellOConnor)
13:23:44 <Saizan> what'd you use?
13:24:15 <roconnor> he missed by triumph!
13:24:17 <roconnor> my
13:25:58 <Saizan> heh
13:26:13 <Saizan> i was asking about the category, however :)
13:26:26 <roconnor> ask gwern
13:30:10 <FliP^2eH> How would I access a random element of an array?`
13:30:15 <FliP^2eH> I'm puzzled
13:30:43 <copumpkin> ask for a random number and then use that as your index :)
13:31:20 <FliP^2eH> I am scared of Haskells random functions
13:31:27 <FliP^2eH> It seems to complicated.
13:31:43 <mauke> :t randomRIO
13:31:44 <lambdabot> forall a. (Random a) => (a, a) -> IO a
13:31:51 <FliP^2eH> I mean I could just keep calling random and makeStdGen
13:32:00 <FliP^2eH> But that would keep getting me the same numbers
13:32:11 <mauke> randomRIO!
13:33:40 <FliP^2eH> Wow nice
13:34:22 <FliP^2eH> Thanks mauke :)
13:36:10 <kau> hello! i recently bought a new phone the Nokia E71, i was wondering if a haskell cross-compiler exists for this platform!
13:38:03 <copumpkin> nope
13:38:28 <copumpkin> you might be able to get hugs running on it easily though
13:38:41 <kau> why not ghc?
13:39:30 <shepheb> I've had strong success with feeding jhc output to the cross-compiler
13:39:34 <kau> i love ghci ;) would be neat to have i one the phone
13:39:40 <shepheb> GHC is hard to port and doesn't do cross-compilation
13:41:19 <kau> what do input the cross compiler?
13:44:40 <The-Kenny> lol
13:44:46 <The-Kenny> Oh, sorry, Wrong channel.
13:45:43 <Saizan> kau: jhc produces portable C
13:45:54 <kau> OK
13:46:06 <shepheb> kau: jhc outputs portable C, which I found easy to feed to the cross-compiler provided by Nokia for the N810
13:46:25 <shepheb> where by "easy" I mean "it worked without problems"
13:46:25 <monochrom> "lol" is never in a wrong channel. :)
13:46:27 <copumpkin> can jhc compile regular programs now?
13:46:35 <copumpkin> I thought it was missing GC or something
13:46:44 <shepheb> it's lacking a few fairly commonly used GHC extensions
13:46:46 <mauke> "lol" is never in a right channel
13:47:02 <monochrom> lol
13:47:05 <skorpan> lol
13:47:10 <shepheb> didn't they implement the stuff from "Garbage Collection in an Uncooperative Environment" or whatever the exact title is?
13:47:22 <mauke> DON'T MAKE ME KICK YOU
13:47:39 <skorpan> lol lol lol lol lol
13:47:51 <skorpan> i am a REBEL
13:47:51 <kau> what i would like to have is a ghci-like on the phone...
13:47:58 * copumpkin notices the rocks around mauke hovering, dragonball style ;)
13:48:05 * mauke sets mode: +b skorpan!*@*
13:48:10 <idnar> shepheb: ARE YOU CALLING ME AN UNCOOPERATIVE ENVIRONMENT!!!
13:48:11 <idnar> ;)
13:48:14 <copumpkin> kau: hugs then? that's easy :)
13:48:40 <skorpan> copumpkin: what does the scouter say about his power level?
13:48:47 <copumpkin> OVER 9000!
13:49:54 * gwern begins powering up so that in 6 months I can attack copumpkin with a kamehamahama for making that joke
13:50:03 <copumpkin> lol
13:50:06 <copumpkin> I mean, unlol
13:50:12 <skorpan> a what?
13:50:21 <skorpan> wikipedia gets me to kamehameha
13:50:27 <copumpkin> that's the one
13:50:52 <skorpan> ...kamehameha I
13:50:55 <skorpan> (the first)
13:51:25 <skorpan> USS Kamehameha (SSBN-642)
13:51:27 <skorpan> is that the one?
13:52:07 <monochrom> "Kamehameha, a fictional energy wave employed by several characters in Dragon Ball media"
13:52:19 <deavid> there's something like UML but applied to functional languages like haskell ?
13:52:28 <monochrom> No.
13:53:27 <skorpan> some graphical representation of the module structure and their dependencies could be nice to have
13:53:41 <skorpan> doesn't need to be in UML obviously
13:53:49 <gwern> we have graphviz stuff
13:54:05 <skorpan> yeah, but that's only *after* having written the code, whereas UML in OOP is usually applied *before*
13:54:29 <Saizan> we've types for that
13:54:42 <deavid> ok, but at least is a start point; it's hard to get started with graphviz and haskell ?
13:54:42 <Twey> The Haskell equivalent of UML is... yeah, type signatures
13:54:48 <Twey> Saizan beat me to it :<
13:54:59 <skorpan> in a program such as yi with 100+ modules, it's pretty difficult to just look at types and figure out how stuff works
13:55:07 <gwern> indeed
13:55:14 <gwern> the interaction of YiM, EditorM and IO is not obvious
13:55:22 <monochrom> It is easy to get started with Haskell itself.
13:55:33 <Twey> You could draw a graph of monad interactions, if that's the problem
13:55:55 <skorpan> the problem for me is just that there is *so much code* that it's hard to keep track
13:56:00 <skorpan> (in yi specifically)
13:56:20 <deavid> so, a graph explaining it would be helpful ?
13:56:28 <skorpan> yes, for me at least
13:56:37 <skorpan> having that taped to the wall while coding would clearly be useful
13:56:51 <Twey> skorpan: The actual code can obscure things — have you seen the relevant Haddock documentation?
13:57:13 <Twey> That should be easy to read, in any well-organised program
13:57:18 <Twey> If it's not, it needs more modules...
13:57:18 <skorpan> Twey: the haddock docs were broken for quite some time
13:57:42 <skorpan> by the time someone fixed it, i had figured most of it out already
13:57:49 <monochrom> I think some people just assume that without UML you can't start. Opinion leaders tell you that. But opinion leaders haven't tried Haskell.
13:57:56 <Twey> Yeah
13:58:12 <Twey> UML is a concise summary of verbose code
13:58:16 <Twey> Haskell is concise already
13:58:47 <skorpan> haskell rocks
13:58:56 <deavid> :-P
13:59:02 <Twey> Haha
13:59:47 <monochrom> For almost everything an opinion leader suggests, I can tell you why the suggestion works for him/her but not for you.
14:00:45 <Twey> Heh
14:00:53 <quantax> hello, I have a question regarding monads :)
14:01:08 <quantax> or rather monads, Kleisi triples and Haskell's pendant
14:01:35 <Saizan> Haskell's pendant?
14:01:41 <Saizan> however, just ask :)
14:02:30 <quantax> the standard definition of a monad consisting of a functor and two natural transformations corresponds to how Haskell monads are described here: http://haskell.org/haskellwiki/Monads_as_containers
14:02:33 <gwern> Saizan: YOU HAVE BEEN CHOSEN TO QUEST FOR HASKELL's PENDANT
14:02:43 <gwern> GODSPEED CHOSEN PROGRAMMER
14:03:01 <mauke> pendant = corresponding thingy
14:03:15 <quantax> the functor is fmap and the natural transformations are return and join
14:03:25 <copumpkin> :t (>>= id)
14:03:26 <lambdabot> forall (m :: * -> *) b. (Monad m) => m (m b) -> m b
14:03:32 <mauke> that's join
14:03:38 <copumpkin> yup :)
14:03:38 <quantax> i know
14:04:19 <quantax> i have to explain a bit more before I actually can ask my question :)
14:05:16 <quantax> but Haskell's monad definition with return and bind is more along the lines of the Kleisi triple, which is equivalent to the normal monad definition
14:05:20 <quantax> from what I read
14:05:59 <copumpkin> what is the "but" contrasting with?
14:06:07 <quantax> but the Kleisi triple is, well a triple and Haskell monad class is basically just a tuple
14:06:24 <quantax> of the functions return and bind
14:06:40 <augustss> And the type.  A triple
14:06:47 <quantax> where did the functor form the kleisi triple go?
14:06:53 <copumpkin> @src Monad
14:06:54 <lambdabot> class  Monad m  where
14:06:54 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
14:06:54 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
14:06:54 <lambdabot>     return      :: a -> m a
14:06:54 <lambdabot>     fail        :: String -> m a
14:06:59 <Saizan> the functor is the type "m"
14:07:21 <Saizan> s/type/type constructor/
14:07:34 <quantax> but there is no explicit fmap
14:07:55 <Saizan> fmap can be recovered with >>= and return
14:08:10 <Saizan> ?type liftM
14:08:11 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
14:08:15 <Saizan> ?src liftM
14:08:15 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
14:08:45 <copumpkin> @@ @pl @undo @src liftM
14:08:46 <lambdabot>  ()
14:08:48 <copumpkin> lol
14:08:49 <Saizan> however most of us agree(?) that Functor should be a superclass of Monad
14:09:03 <quantax> yes yes, exactly my point. then why is the functor required in the definition of the kleisi triple when I can express it with bind and return?
14:09:15 <idnar> @src liftM
14:09:16 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
14:09:22 <idnar> @undo liftM f m1 = do { x1 <- m1; return (f x1) }
14:09:23 <lambdabot> liftM f m1 = m1 >>= \ x1 -> return (f x1)
14:09:31 <idnar> @pl liftM f m1 = m1 >>= \ x1 -> return (f x1)
14:09:32 <lambdabot> liftM = fmap
14:09:38 <copumpkin> :(
14:10:00 <SamB> quantax: so that @pl will work right?
14:10:03 <monochrom> heh
14:10:21 <SamB> @pl liftM
14:10:22 <lambdabot> fmap
14:10:29 <Saizan> quantax: i guess because in CT exponential objects and morphisms are kept more distinct than in haskell
14:10:46 <quantax> SamB: sorry, I'm not familiar with lambdabot. was is @pl?
14:11:05 <copumpkin> so we can get fmap from bind and return, but can't get it from join and return?
14:11:26 <monochrom> I believe that's right.
14:11:38 <copumpkin> interesting
14:11:54 <quantax> so I am basically making to strong connections between the Kleisi Triple and the Haskell monad?
14:12:07 <Saizan> quantax: do you have a link for the exact definition of a kliesli triple?
14:13:15 <quantax> oops, I've been misspelling kleisli triple the whole time... :)
14:13:31 <copumpkin> :t Kleisli
14:13:33 <lambdabot> forall a (m :: * -> *) b. (a -> m b) -> Kleisli m a b
14:13:45 <copumpkin> magic!
14:13:53 <Saizan> heh, i do too :)
14:14:02 <quantax> Saizan: not exactly. I read about it in one of Moggi's papers
14:20:22 <quantax> ok, I probably do have not enough background to get this all right, right now
14:20:35 <quantax> better do some more reading
14:20:55 <quantax> I am still too confused
14:21:08 <quantax> and out of my confusion another question:
14:21:58 <quantax> isn't it a bit redundant to have both the Maybe monad and a bottom element?
14:22:10 <byorgey> quantax: it would be if you could test for bottom.
14:22:38 <Saizan> quantax: disregard my earlier comment on exponential objects, i have no idea why T is required to be a functor, maybe the only reason is that category theory usually deals with functors
14:22:39 <byorgey> bottom is just an error (or infinite loop).  Maybe gives you a well-defined 'Nothing' value.
14:22:54 <byorgey> what is the question about functors?
14:23:11 * byorgey reads the scrollback
14:23:42 <byorgey> quantax: note that every monad is a functor in CT
14:23:54 <byorgey> although the Monad class does not require the Functor class for historical reasons.
14:23:56 <Saizan> byorgey: why the kliesli triple (M,return,=<<) is defined with M being a functor
14:24:23 <Saizan> since you can recover liftM with return and =<<
14:24:27 <byorgey> ah. well, return (and join) are supposed to be natural transformations
14:24:32 <byorgey> which doesn't make sense if M is not a functor.
14:24:45 <Saizan> the kliesli triple doesn't use join :)
14:24:58 <Saizan> however yeah, i guess that's the main reason
14:25:02 <byorgey> well, you could define it in terms of return and =<< .
14:25:28 <Saizan> byorgey: the usual definition of monad and a kliesli triple are two different but equivalent formulations
14:25:50 <byorgey> right, I know.
14:25:58 <quantax> byorgey: then my question was why is the functor is part of the definition if it can be expressed by return and bind
14:26:44 <Saizan> btw fmap is not _the functor_
14:26:46 <Saizan> M is
14:27:00 <byorgey> quantax: are we talking about category theory or Haskell?
14:27:08 <byorgey> just clarifying
14:27:28 <Saizan> fmap is only the witness of how the functor acts on morphisms
14:29:10 <quantax> byorgey: the relation of both... somehow
14:29:35 <byorgey> *IF* M is a functor, and return and bind are natural, then you can express the action of M on morphisms in terms of return and bind.
14:30:00 <byorgey> but that doesn't mean that if you have any old things with the right types for 'return' and 'bind' (that aren't natural) that you will get a functor out.
14:30:13 <quantax> Saizan: so I don't have to have an explicit definition of fmap, but the monad is also the functor?
14:30:47 <byorgey> quantax: note that in Haskell, *any* polymorphic function is a natural transformation, since we don't have case analysis on types
14:30:55 <byorgey> but that isn't necessarily true in a categorical setting.
14:31:18 <byorgey> I don't know if this is helping at all =)
14:32:04 <quantax> well, I not a computer scientist or a mathematician
14:32:12 <soupdragon> What does it mean byorgey please?
14:32:17 <byorgey> Saizan: if you really want to be technical, it's the pair (M,fmap) which is the functor. =)
14:32:28 <byorgey> soupdragon: what does what mean?
14:32:29 <soupdragon> I know the definition of natural transform but what is the polymorphic function about?
14:32:58 <quantax> just taking a very interresting course this semester
14:33:04 <FunctorSalad> soupdragon: e.g. if you have a polymorphic function f :: a -> m a, it is forced to be a natural t. from the id functor to m
14:33:06 <Saizan> byorgey: right, i was reflecting on that, and to be pedant you'd have to add a proof of the functor laws to that :)
14:33:07 <byorgey> soupdragon: a polymorphic function is one which is parameterized by one or more types
14:33:12 <FunctorSalad> (unless you do unsafe stuff)
14:33:14 <quantax> so it takes a bit time for me to swallow all your explanations
14:33:15 <byorgey> Saizan: touche!
14:33:37 <byorgey> soupdragon: for example,  length :: [a] -> Int  is polymorphic in 'a'
14:33:59 <soupdragon> and so there is  f . length = length . f  ?
14:34:19 <byorgey> soupdragon: actually, f . length = length . fmap f
14:34:36 <FunctorSalad> soupdragon: there's a neat program on hackage that will automatically generate the laws satisfied by poly functions; it's called "free theorems" or "theorems for free"
14:34:39 <byorgey> this is exactly the so-called 'free theorem' that you get from 'parametricity'
14:34:42 <FliP^2eH> @hpaste
14:34:43 <lambdabot> Haskell pastebin: http://hpaste.org/new
14:35:06 <soupdragon> f . anyPolymorphicFunction = anyPolymorphicFunction . fmap f  ?
14:35:20 <byorgey> which can be read as simply the statement that length is a natural transformation.
14:35:26 <soupdragon> or the amount of fmap and so on depends on the type of that function?
14:35:40 <FliP^2eH> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6222#a6222
14:35:45 <FliP^2eH> Why does it fail on hPutStrLn?
14:35:55 <byorgey> soupdragon: well, actually, it will always be  fmap f . blah = blah . fmap f
14:36:00 <byorgey> but sometimes you use the identity functor
14:36:05 <soupdragon> oh I see!
14:36:08 <soupdragon> cool!
14:36:26 <byorgey> actually, in the case of length, it is a natural transformation from the list functor  to the  constant Int functor
14:36:31 <byorgey> i.e.  F a = Const Int
14:36:41 <monochrom> Hrm? I thought you already knew how hGetContents would semi-close the handle?
14:36:54 <FliP^2eH> It would?
14:36:58 <FliP^2eH> That's... mean.
14:37:09 <FliP^2eH> Why does it do that?
14:37:23 <monochrom> To be clean.
14:37:33 <byorgey> mean and clean!
14:37:41 <FliP^2eH> So
14:37:46 <FliP^2eH> As it's SEMI closed
14:37:49 <FliP^2eH> How do I open it again?
14:37:55 <Saizan> you can't
14:38:01 <FliP^2eH> Whyyyyy
14:38:07 <FliP^2eH> I hate you, hGetContents :(
14:38:27 <FunctorSalad> the presentation on iteratees says it's horrible too
14:38:45 <FunctorSalad> "delusionally simple" :)
14:38:46 <dbbddbdb> Is it possible to replace Num somehow?  I want to reclaim (+) and (*) because they can be made to work on many things, not only on rings, so if I have Additive and Multiplicative classes and subclass Num from them then I can add monoids, strings, monads etc together with (+) and even define my own additive thingns without inventing (+/+/+<>=+)-like operators.  However I'm not sure if I'll be able to define arithmetic again.  Will I need to learn the core 
14:39:08 <FunctorSalad> dbbddbdb: {-# LANGUAGE NoImplicitPrelude #-}
14:39:10 <monochrom> Look, put yourself in the designer's shoes. hGetContents gives you a string, but no reading happens until you consume, and then only read as much as you consume. Why would anyone allow you to perform other operations on the same handle so you can mix things up really badly?
14:39:13 <dbbddbdb> Atm I use abstraction leaking hacks like http://paste.defun.ru/m4fa13da
14:39:22 <FunctorSalad> then you won't have Num
14:40:04 <FunctorSalad> dbbddbdb: you can then import Prelude qualified to access the old Num
14:41:42 <dbbddbdb> FunctorSalad: thanks, looks like it's not too painful to do it this way
14:45:12 <LambdaFred> @pl \zero x -> 2*zero + digitToInt x
14:45:12 <lambdabot> (. digitToInt) . (+) . (2 *)
14:52:22 <FliP^2eH> How can I force instant file closing, instead of having it done lazily?
14:52:30 <FliP^2eH> It closes too late
14:52:58 <sjanssen> FliP^2eH: hClose?
14:53:10 <FliP^2eH> It still closes too late
14:53:15 <dons> hClose closes immediately
14:53:27 <FliP^2eH> Maybe it'S called too late?
14:53:28 <sjanssen> FliP^2eH: you must be doing something else wrong
14:53:34 <sjanssen> FliP^2eH: seems likely
14:53:40 <sjanssen> unless you're using hGetContents?
14:54:04 <FliP^2eH> I'm using hGetContents.
14:54:09 <LambdaFred> Can i "read" binary numbers? Something like this, only built-in?
14:54:10 <LambdaFred> parseBinary = foldl (\acc x -> 2*acc + digitToInt x) 0
14:54:23 <sjanssen> FliP^2eH: IIRC, hClose is a no-op on hGetContents'ed handles
14:54:42 <sjanssen> FliP^2eH: you need to force the entire string returned by hGetContents, the handle will be closed then
14:54:46 <tommd> dons: I just realized that Creighton, a new PhD student here at PSU, is the Creighton from Happstack and maintaining the crypto library.  More Haskellers to Portland!
14:54:59 <tommd> We need a hackathon
14:55:03 <FliP^2eH> The entire string is processed
14:55:21 <sjanssen> LambdaFred: see Numeric.readInt
14:55:21 <dons> ooh
14:55:47 <sjanssen> FliP^2eH: what does 'processed' mean?  Are you forcing the results of the processing?
14:55:52 <dons> tommd: creighton hogg moved to PDX?
14:55:56 <FliP^2eH> let quotes = zipWith (\c n -> show n ++ " " ++ c) (map (\(x,y) -> y) $ splitLine $ lines $ cnt) [1..]
14:55:56 <tommd> Yes!
14:56:00 <FliP^2eH> where cnt = hGetContents
14:56:02 <dons> that's awesome.
14:56:04 <tommd> he is next to me now
14:56:16 <shepheb> argh, I consistently live near the next Hackathon until about two months before it happens, by which time I move to the far coast.
14:56:19 <sjanssen> FliP^2eH: the sure-fire fix is: do x <- hGetContents h; evaluate (length x); stuffinvolvingx
14:56:36 <shepheb> next NA Hackathon, anyway
14:56:47 <dons> tommd: and galois is hiring, so more haskellers on the way !
14:56:48 <tommd> We even seem to have some of the same goals (move crypto to bytestring, various happstack pieces, etc).  SO certainly time for a hackathon.
14:56:56 <sjanssen> FliP^2eH: you're probably getting confused by laziness
14:56:59 <dons> we should have a hackathon some weekend.
14:57:02 <FliP^2eH> I am
14:57:09 <FliP^2eH> Simple concept
14:57:16 <tommd> When would be good for everyone?  Not this weekend, its ICFP.
14:57:19 <FliP^2eH> Keeps hitting me in my .... when coding
14:57:21 <tommd> As in, the programming contest.
14:57:49 <sjanssen> FliP^2eH: if it helps, lazy IO is widely regarded as tricky, and perhaps to be avoided
14:57:50 <dons> yeah. sometime early in the summer.
14:58:08 <LambdaFred> @src ReadInt
14:58:08 <lambdabot> Source not found. Just what do you think you're doing Dave?
14:58:10 <shepheb> if it's some time in the next two months before I move back to Ontario, I'll be there.
14:58:20 <LambdaFred> @src readInt
14:58:20 <lambdabot> Source not found. It can only be attributed to human error.
14:58:24 <LambdaFred> @src Numeric.readInt
14:58:24 <lambdabot> Source not found. Maybe if you used more than just two fingers...
14:58:39 <FliP^2eH> Then, how do I do strict IO?
14:58:54 <dons> tommd: so the kernel team grows strong
14:59:19 <PhDP> How to I install Cairo to use Gtk2hs with Cairo on Windows ? On linux it was a piece of cake but if it doesn't work on windows it would be a problem...
14:59:23 <sjanssen> FliP^2eH: anything but hGetContents is strict -- hGetLine, etc.
14:59:36 <FliP^2eH> Okay
15:00:40 <LambdaFred> @pl (\x -> x == '0' || x == '1')
15:00:40 <lambdabot> liftM2 (||) ('0' ==) ('1' ==)
15:01:03 <sjanssen> PhDP: I think the gtk2hs team publishes an all-in-one installer for Windows?
15:02:05 <PhDP> sjanssen: apparently it doesn't work, my friend is currently trying to make a simple example work in windows and he gets an error with the import something.Cairo
15:02:48 <saml> isn't cairo linux?
15:03:06 <dons> no
15:03:12 <PhDP> Hopefully not.
15:03:45 <timmaxw> in theory it should be possible to unify type constructors with type classes... i think
15:03:58 <timmaxw> class Maybe a b where ...
15:04:03 <snowfarthing> whoami
15:04:08 <LambdaFred> @pl \s -> fst $ head $ readInt 2 isBinaryDigit digitToInt s
15:04:08 <lambdabot> fst . head . readInt 2 isBinaryDigit digitToInt
15:04:09 <timmaxw> fromJust :: (Maybe a b) => a -> b
15:04:22 <timmaxw> i'm not sure what the point is, though
15:04:49 <FliP^2eH> I suck at recursing
15:05:06 <FliP^2eH> How would I go and write a function that reads everything from a handle?
15:05:08 <FliP^2eH> :s
15:05:09 <tommd> At least you don't recursively suck.
15:05:16 <FliP^2eH> readLines h = (readLines h):[(hGetLine h)]
15:05:28 <PhDP> dons: you were able to compile on windows with Cairo ? The only program I know written in Haskell with Cairo is chinese chess and it doesn't seem to work on windows. (BTW your book on haskell is incredible).
15:05:35 <Saizan> so many errors in that line..
15:05:40 <FliP^2eH> :(
15:05:47 <dons> PhDP: there's lots of cairo apps on hackage.
15:06:03 <mauke> FliP^2eH: I'd just use hGetContents
15:06:11 <FliP^2eH> It's giving me the creeps
15:06:11 <dons> http://hackage.haskell.org/package/minesweeper <-- a good one
15:06:16 <dons> PhDP: ^ try that one.
15:06:21 <FliP^2eH> And keeps crashing in my face because of it's laziness
15:06:26 <dons> i just built it on linux (haven't got a windows dev machien)
15:06:28 <Saizan> readLines h = do line <- hGetLine h; lines <- readLines h; return (line:lines)
15:06:31 <dons> FliP^2eH: do you want to do strict IO?
15:06:35 <soupdragon> 'always solvable without guessing' doesn't that take the fun out of it...
15:06:40 <FliP^2eH> Yes
15:06:52 <timmaxw> dons: i think the problem is that his example failed because the IO actions never got evaluated
15:07:08 <dons> sounds plausible
15:07:38 <timmaxw> i don't think it has do with strictly vs. lazily reading from the file
15:08:07 <Saizan> timmaxw: did you follow the earlier conversation?
15:08:09 <dschoepe_> How do I get cabal to automatically use --hyperlink-source when generating documentation?
15:08:18 <dschoepe_> (globally)
15:08:21 <timmaxw> Saizan: no, i've only been on for a few minutes
15:08:27 <PhDP> dons: I'll ask him to try (I have no windows either, but I won't be able to write my thesis work in Haskell if cairo doesn't work on windows, most of my supervisors are win-users).
15:09:04 <Saizan> dschoepe_: you currently can't
15:10:37 <dschoepe_> Saizan: Hmm I guess I'll put some haddock wrapper in my PATH before the real haddock binary with my desired option. Not pretty, but should work.
15:11:01 <Saizan> dschoepe_: you want a wrapper to cabal
15:11:23 <Twey> dschoepe_: Try alias?
15:11:32 <dons> PhDP: cairo is required by firefox to display svg, so it better work on windows...
15:12:06 <PhDP> dons: good argument.. didn't know that (GUI aren't my forte).
15:12:17 <dschoepe_> Saizan: No I'll create a file named haddock in ~/bin which calls /usr/bin/haddock with my desired options.
15:12:45 <dschoepe_> Twey: Does cabal invoke the shell to call haddock?
15:12:52 <Twey> I would imagine so.
15:13:18 <dschoepe_> Okay, an alias is cleaner in that case
15:13:22 <dschoepe_> thanks
15:13:24 <Twey> It's the logical thing to do — you get path lookup for free.
15:13:30 <Twey> It might not, I guess.  Try it and see.
15:13:51 <randomity> you get path lookup for free anyway
15:13:52 <Saizan> dschoepe_: you can't emulate --hyperlink-source simply by passing some arguments to haddock
15:14:48 <dschoepe_> Saizan: Doesn't haddock have a corresponding argument to make it generate the source links?
15:15:15 <mykelyk> How can i get rea
15:16:03 <mykelyk> How can i get real time bytestring putStrLn getChar?
15:16:05 <Saizan> dschoepe_: --hyperlink-source preprocesses the sources with hscolour putting them in the docs directory, and then passes the relative path schema to those sources
15:16:22 <Saizan> .. to haddock
15:16:47 <mykelyk> In C I'd do fflush(stdout)
15:16:58 <Saizan> dschoepe_: you can run cabal haddock --hyperlink-source -v to see what's going on
15:17:05 <dschoepe_> ah, thanks.
15:17:06 <Baughn> mykelyk: And in Haskell you can do hFlush stdout
15:17:17 <ehird> How can I get all the permutations of a list easily?
15:17:41 <Baughn> ehird: Use the permutation library?
15:17:51 <Saizan> ehird: Data.List.permutations with a recent enough base
15:18:07 <Baughn> Data.Permute for more complex interfaces
15:18:11 <ehird> Saizan: ghc 6.10.3 is not recent enough
15:18:26 <Saizan> it should..
15:18:29 <Baughn> http://hackage.haskell.org/packages/archive/permutation/0.4.1/doc/html/Data-Permute.html
15:18:35 <ehird> wait
15:18:36 <ehird> Data.List
15:18:37 <ehird> oops :P
15:18:44 <Baughn> Ahh
15:18:53 <ehird> yay is work.
15:20:01 <mykelyk> Baughn: thanks, perfect!
15:21:59 <deavid> one example: say I want a random permutation of the list (n1 :: [Int]), where n = [0..1000]. If I use Data.List.permutation, this way: p = (permutation n) !! (990^2) , it takes a long time, because is computing all permutations. ¿There's a wat to randomly get one, without calculating huge amounts of data?
15:23:19 <deavid> that's one of my big problems in haskell; when you simply want one random sort, you'll get into something like this
15:25:14 <sjanssen> deavid: I don't think this has anything to do with Haskell
15:25:24 <luite> deavid: you can of course zip it with a list of random numbers and sort by comparing those, but that's (very) slightly biased because of equal values in your random numbers.
15:25:26 <sjanssen> deavid: there are a couple random shuffle packages on hackage
15:25:50 <deavid> ah, ok, there are packages for that :-)
15:26:17 <sjanssen> 'cabal install random-shuffle'
15:27:50 <uzytkownik> @pl \p v = poke (castPtr p) (tW v)
15:27:50 <lambdabot> (line 1, column 6):
15:27:50 <lambdabot> unexpected "="
15:27:50 <lambdabot> expecting pattern or "->"
15:27:55 <uzytkownik> @pl \p v -> poke (castPtr p) (tW v)
15:27:56 <lambdabot> (. tW) . poke . castPtr
15:37:46 <dancor> daevid's problem is with the nature of the List datatype
15:38:47 <ehird> ghc: panic! (the 'impossible' happened)
15:38:47 <ehird>   (GHC version 6.10.3 for i386-apple-darwin):
15:38:48 <ehird> 	linkBCO: >= 64k insns in BCO
15:38:50 <ehird> Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug
15:38:59 <ehird> To achieve this, type ("foo" `elem [very,very,very,long,array]) in GHCi.
15:39:27 <lament> 'the' 'impossible' 'happened'
15:39:54 <dons> i think there's an open bug for this
15:40:02 <dons> and you mean list, not array, right?
15:40:12 <dons> ?bug
15:40:13 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
15:40:20 <dons> check for a duplicate to add notes to
15:41:59 <sjanssen> dancor: no, I don't think so.  The problem is that finding the 990^2nd permutation is slower than making a real random shuffle
15:42:43 <monochrom> Why do people troll #haskell with the stupidest algorithms and data structures ever?
15:43:18 <sjanssen> monochrom: I don't think they're trolls
15:43:36 <Berengal> Getting the x'th permutation of a n long list can be done in O(n)
15:44:01 <Berengal> I think...
15:44:34 <monochrom> "Hai how do I use the integral of e^(-x^2/2) from -oo to +oo computed numerically using Simpson's rule with 1,000,000,000,000 slides to approximate 1 in haskell and have it finish in 1 second?"
15:44:54 <sjanssen> I think that because Haskell is so unfamiliar to them, they look for problems in Haskell rather than in their algorithm or understanding
15:45:35 <sjanssen> Berengal: even so, the Data.List function isn't designed for that, it's designed to enumerate every permutation
15:45:35 <dons> yep
15:46:39 <Berengal> sjanssen: Yeah, so it's a pretty silly thing to use if you only want one
15:47:42 <dancor> so it's not really about List or inherent-difficulty, just that implementation
15:47:47 <dancor> mm
15:48:22 <hackagebot> control-monad-queue 0.0.9.1 - Reusable corecursive queues, via continuations. (LeonSmith)
15:48:26 <Berengal> Also, permutations are not random, or even pseudorandom
15:48:59 <sjanssen> to make a comparison, this would be like calling C++'s next_permutation function 2^990 times, which is just as (asymptotically) slow
15:49:03 <Berengal> So using them for random shuffles is even sillier
15:53:10 <dancor> would you say that (fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
15:53:18 <dancor> ) is corecursive and not recursive?
15:53:28 <monochrom> No.
15:53:37 <Berengal> No?
15:54:21 <Saizan> recursion can be understood as comprehending both induction and coinduction
15:54:29 <monochrom> I guess I should elaborate. It is corecursive. It is also recursive if you use the broad sense. Therefore I reject "___ and not recursive".
15:54:37 <dancor> ok
15:54:48 <Berengal> Ah, that makes more sense
15:59:37 <eu-prleu-peupeu> hi hi hi
16:00:00 <eu-prleu-peupeu> have you read sicp ? what do you think of it ?
16:02:00 <Berengal> I've read some of it, and seen quite a few of the lectures on youtube. It's pretty decent
16:02:42 <eu-prleu-peupeu> better than rwh ?
16:03:52 <eu-prleu-peupeu> a friend of mine, who doesn't know how to code asked me for a good book to start
16:03:56 <eu-prleu-peupeu> what do you recommend ?
16:04:19 <Berengal> sicp is more general, and more theoretically minded
16:04:43 <Berengal> Much of its lessons can be applied to all programming, while rwh focuses mostly on teaching Haskell
16:05:14 <mdmkolbe> For a state monad is there a standard name for the function: \m -> do s <- get; x <- m; put s; return x.  That is to say that it saves and restores the state after the argument monad has run?  (I didn't see one in the libraries, but maybe I missed it.
16:05:49 <Berengal> I can't just recommend one of them though, they're pretty different. RWH is for programmers who want to learn haskell, SICP is for newbiew computer scientists...
16:05:53 <monochrom> I think sicp and rwh are incomparable.
16:06:18 <Berengal> monochrom: Yeah, pretty much
16:06:35 <Berengal> Both are good in their own way
16:06:38 <monochrom> Yes, sicp is an "intro to CS" course.
16:06:53 <allbery_b> mdmkolbe: I can't think of one but it makes me think of local from Reader
16:08:14 <Berengal> SICP also introduces higher-order functions right away...
16:08:33 <mdmkolbe> allbery_b: it is sort of similar to local, or technically it is closer to listen in Writer that it stops the side effects from propagating out
16:08:37 <allbery_b> also, seems related to evalState
16:08:41 <Berengal> I don't know about others, but I was confused enough as it was with just regular functions when I started programming
16:09:32 <mriou> I remember reading a way of having some pure code returning an action that the caller would execute
16:09:38 <mriou> but I forgot where and how :)
16:10:04 <Berengal> mriou: putStrLn is one such function
16:10:10 <mriou> I guess I could do something like const (print "foo") but that's rather ugly
16:10:44 <mriou> Berengal: yes but I would already have provided all arguments
16:10:53 <FunctorSalad> mdmkolbe: \m -> get >>= evalState m   ?
16:11:16 <Berengal> mriou: In that case it's not a function anymore, just a value
16:11:37 <mriou> I want to return a completely applied but not yet executed
16:12:00 <FunctorSalad> just 'print "foo"'
16:12:13 <FunctorSalad> (as the value of your function)
16:12:19 <Berengal> mriou: Haskell is lazy. Nothing is executed until it has to be
16:12:28 <FunctorSalad> this isn't lazyness though
16:12:36 <mriou> FunctorSalad: 'print "foo"' will be a IO() value
16:12:43 <FunctorSalad> it is that IO actions only get executed when main is actually ran
16:12:59 <mriou> I'd like something like -> IO() if that makes sense
16:13:01 <mdmkolbe> FunctorSalad: I think you're missing a 'return' around the evalState but yeah
16:13:12 <mriou> just like const (print "foo") but without the useless parameter
16:13:19 <mdmkolbe> @type \m -> get >>= return . evalState m
16:13:21 <lambdabot> forall a (m :: * -> *) a1. (MonadState a m) => State a a1 -> m a1
16:13:40 <mdmkolbe> @type \m -> get >>= (return . evalState m)
16:13:42 <lambdabot> forall a (m :: * -> *) a1. (MonadState a m) => State a a1 -> m a1
16:13:47 <Berengal> mriou: 'const (print "foo")' without the useless parameter is just 'print "foo"'
16:14:31 <mdmkolbe> something went wrong with that type
16:14:55 <mriou> Berengal: not quite, const (print "foo") has type a -> IO() whereas print "foo" is IO() so I can have some pure code return the first but not the second
16:15:00 <FunctorSalad> mriou: "IO ()" can be thought of as "RealWorld -> (RealWorld,())". it won't have any effect until the RealWorld actually passes through it
16:15:00 <mriou> does that make sense?
16:15:02 <mdmkolbe> I take it back, that type is write
16:15:08 <mdmkolbe> right
16:15:28 <FunctorSalad> so you can push the IO () value around however you like
16:15:28 <Berengal> mriou: No, it doesn't...
16:15:59 <mriou> Berengal: mmmh ok, let me try to see if I can write a small example
16:17:11 <Saizan> mriou: they can both be the result of pure code, though the actual printing is not going to happen if the action isn't part of main
16:18:19 <mriou> Saizan: but what's not part of main?
16:18:50 <Berengal> mriou: Anything that isn't part of the chain of (>>=) starting at main
16:21:49 <mriou> Berengal: mmh so any pure code can return something like print "foo" and it will only be executed when it hits that chain, correct?
16:22:01 <Berengal> mriou: Yup
16:22:25 <mriou> Berengal: makes sense, I see now why I wasn't making any :)
16:23:07 <Berengal> IO values are pure values, just like everything else, and can therefore be treated as such
16:23:07 <FunctorSalad> mriou: main = do { let x = print "foo"; return () } -- won't print anything
16:23:30 <Berengal> They are however also IO actions, which aren't pure
16:23:58 <Twey> Is a race condition possible with MVars?  If I have f x = readMVar x >>= writeMVar . (+ 1), can another thread write to the MVar in that interval and have its data overwritten?
16:24:00 <FunctorSalad> (and not just due to lazyness)
16:24:00 <Berengal> But actions are useless unless you perform them, which is done by inserting them into the action sequence called main
16:24:09 <Twey> Do I need TVars and atomically?
16:24:25 <Saizan_> Twey: your writeMVar will block
16:24:48 <Twey> And then insert it when the MVar becomes empty?
16:24:51 <Twey> So I do need STM?
16:24:54 <mriou> Berengal, FunctorSalad: thanks for the explanations... and the patience :)
16:24:59 <FunctorSalad> np
16:25:14 <Berengal> :)
16:25:43 <Saizan_> Twey: 1) yes 2) it depends, if you consistently stick to that pattern the MVars works like a mutex so you won't miss changes
16:25:43 <Twey> And does modifyMVar?  The Haddock docs say that swapMVar suffers from this condition, but doesn't mention it for modifyMVar, which I would expect to be the same
16:25:45 <FunctorSalad> Twey: I'm not a concurrency pro but this seems like a good case for STM
16:26:10 <Twey> And they explicitly call modifyMVar ‘safe’
16:26:16 <Berengal> Twey: If you want atomicity, yes, or use another MVar, or atomicallyModifyMVar (or whatever its name is)
16:26:45 <Saizan_> "modifyMVar f = readMVar x >>= writeMVar . f" and it's safe because you won't risk ignoring some updates
16:26:49 <FunctorSalad> q: would STM be faster here due to its optimism?
16:26:55 <FunctorSalad> or does the STM overhead outweigh it
16:27:00 <Saizan_> readMVar blocks when the variable is empty
16:27:46 <Saizan_> (modifyMVar also has some block/unblock to properly deal with exceptions, actually)
16:28:06 <Twey> Right, so as long as I do readMVar before writeMVar consistently it's safe
16:28:08 <Saizan_> and let f be in IO
16:28:19 <Berengal> modifyMVar is atomic if all your writesMVars are preceded by a matching readMVar
16:28:19 <Twey> But what about modifyMVar/swapMVar?
16:28:31 <Twey> So it's not atomic :-P
16:28:45 <Twey> Okay.  Thanks.  I'll go with STM — it's less brain-bending.  :-P
16:28:49 <Saizan_> no, it's not atomic per se
16:28:53 <Berengal> No, but it's a decent pattern to be working with
16:28:58 <Twey> Aye.
16:29:06 <Twey> Better safe than sorry, though.
16:29:37 <Berengal> I too like STMs better, but I've found a case where it's not completely applicable
16:30:04 <Twey> Oh really?  What's that?
16:30:16 <Berengal> do {clients <- atomically (readTVar clientVar); mapM_ (sendMessage message) clients}
16:30:27 <Twey> I didn't think there was any real downside to it except the orders-of-magnitude performance slowdown
16:30:29 <Berengal> where sendMessage is flip hPutStrLn, or whatever
16:30:51 <Twey> Hmm
16:31:38 <Twey> Shouldn't that just be ‘atomically (readTVar clientVar >>= mapM_ (sendMessage message))’?
16:31:40 <Berengal> You need some sort of locking to prevent clients from disconnecting in the meantime
16:31:43 <benl23> Any community.haskell.org admins around? I can ssh it but www and trac are down.
16:31:54 <Saizan_> Twey: you can't do IO inside atomically
16:31:55 <Berengal> Twey: sendMessage is in IO
16:32:21 <Twey> Oh
16:32:37 <Twey> I didn't realise STM was its own monad
16:33:22 <Saizan_> transactions are restarted, having IO in them would be messy :)
16:33:30 <Twey> Fairly major oversight there
16:33:31 <Twey> Yeah
16:33:32 <Twey> Heh
16:33:46 <SamB> yeah, you'd get like Helo Hello Hello World
16:33:53 <dons> benl23: ping Igloo in #ghc
16:34:15 <benl23> dons: is alright, dcoutts sorted it
16:35:29 <dbbddbdb> How stupid/useful it is to have things like http://paste.defun.ru/m78affccc (example of use: http://paste.defun.ru/m287183d3 )?
16:36:27 <dbbddbdb> Also is it possible to have some class extend other class, so in the latter module I can write only one definition for all three groups of functions?
16:36:30 <Twey> Looks like you want the numeric prelude
16:38:23 <SamB> dbbddbdb: we haven't figured out how to add that to Haskell yet
16:38:26 <SamB> it's harder than you'd think
16:38:32 <dbbddbdb> Looks nice, but actually I want *non-numeric* (+) and (*)
16:38:43 <dbbddbdb> E. g. for monoids and strings and sequences
16:38:46 <Berengal> One solution I've found satisfactory in my own small mind is to give only one thread ownership of a given input/output channel
16:39:13 <dbbddbdb> SamB: what moving to numeric Prelude can possibly break?
16:39:48 <Berengal> e.g in a simple broadcast server (clients connect and send messages to eachother), one thread owns all output channels, while each input channel has its own listener thread
16:39:49 <SamB> I meant the 'instantiate several classes in one "instance" declaration' bit
16:40:24 <dbbddbdb> Ah
16:40:49 <FunctorSalad> :)
16:41:31 <FunctorSalad> @botsnack vegetables
16:41:31 <lunabot>  :)
16:41:31 <lambdabot> :)
16:41:55 <SamB> @botsnack brownies
16:41:56 <lambdabot> :)
16:41:56 <lunabot>  :)
16:42:21 <SamB> so lunabot prefers veggies and lambdabot prefers brownies?
16:42:40 <shepheb> @vixen do you have a sweet tooth?
16:42:40 <lambdabot> sweet tasting, or just sweet?
16:52:09 <zebrafinch> Is there a purely functional disjoint set (union/find) data structure?
16:52:35 <gwern> no doubt if there is Edison has it
16:52:39 <gwern> or hackage; same thing
16:53:38 <shepheb> Data.Set?
16:54:16 <shepheb> hm, disjoint set
16:55:24 <SamB> zebrafinch: could you maybe give more details about semantics, operations, and hoped-for complexities?
16:55:51 <FunctorSalad> ackermann^-1 :D
16:56:23 <zebrafinch> FunctorSalad: yep, although I'd be happy with log
16:56:31 <SamB> FunctorSalad: I was thinking more along the lines of "which ones you'd like to be fast"
16:56:40 <dbbddbdb> So, it's impossible to have a Num interface 100% compatible with the usual Prelude one, because even http://hackage.haskell.org/trac/haskell-prime/wiki/NumericClasses#TheNumclass will require explicit instantiation of AbelianGroup and Ring?
16:57:14 <SamB> dbbddbdb: It's not desirable to have one 100% compatible with the Prelude one
16:57:40 <SamB> it *is* desirable not to have to instantiate all those classes one-by-one
16:57:49 <gwern> 'compatbility means deliberately repeating others' mistakes' --david wheeler
16:57:51 <SamB> and to be able to add additional classes as we go
16:58:13 <SamB> so we can have compatability WITHOUT repeating our own mistakes
16:58:27 <SamB> that's what we want ;-)
16:58:33 <gwern> @remember DavidWheeler Compatibility means deliberately repeating other people's mistakes.
16:58:34 <lambdabot> Done.
16:58:37 <gwern> @flush
16:58:55 <SamB> @scrub
16:58:56 <lambdabot> Unknown command, try @list
16:59:27 <zebrafinch> SamB: In the classic version, you have a set of sets of elements; Find(x) gives you the set x belongs to (or a canonical element of it), and Union(x, y) merges the set containing x and the set containing y.
16:59:59 <zebrafinch> SamB: the imperative algorithm takes amortized inverse-ackermann time for any sequence of operations
17:00:12 <SamB> zebrafinch: you seem to be missing some arguments to those functions ;-)
17:00:50 <FunctorSalad> the disjoint-union structure itself
17:01:24 <SamB> hmm, yes, that should be enough
17:01:32 <zebrafinch> SamB: yeah, for some reason the paper I just read on them (and wikipedia) assumes you have one set
17:01:45 <dbbddbdb> :t 0
17:01:47 <lambdabot> forall t. (Num t) => t
17:01:49 <zebrafinch> (probably because the elements have a pointer you can chase to it)
17:01:52 <dbbddbdb> :i Num
17:02:02 <dbbddbdb> :(
17:02:58 <dbbddbdb> SamB: but do people actually have instances of Num (as opposed to inventing their own notation for finite fields, group things etc)?
17:03:22 <SamB> dbbddbdb: a few
17:03:29 <SamB> well, okay, a lot
17:03:44 <dbbddbdb> So Numerical Prelude is not an option?
17:03:48 <SamB> but many of them leave those people feeling sad by how sucky the numeric prelude is
17:03:56 <SamB> (the standard one, I mean)
17:04:26 <dbbddbdb> So, one should expect Prelude hierarchy to be replaced with the proposed Numerical Prelude one some time in the future?
17:05:01 <SamB> dbbddbdb: well, we've probably got to deal with how to add superclasses without breaking everyone's code before we go to all the trouble of breaking everyone's code anyway to switch to a better hierarchy
17:05:06 <gwern> dbbddbdb: if by in the future, you mean at a random time between now and eternity.... then yes
17:05:48 <SamB> meaning, that once we have a mechanism to allow not breaking everyone's code when changing the numeric hiearchies, the first thing we will do with it is just that -- break everyone's code anyway
17:05:50 <FunctorSalad> with *infinite* expected value.
17:06:48 <SamB> well, I mean, besides making a decent Lattice library ;-)
17:08:52 <dbbddbdb> SamB: This mechanism is joining instance definitions of classes that are declared to be required somewhere above the hierarchy?  E. g. something like class (Eq a, Show a) => Num a …  instance Num Zomg where { show x = "lala"; x == y = True ; x + y = 0 …}?
17:09:38 <SamB> dbbddbdb: if we knew what the mechanism was, we'd have implemented it
17:10:04 <FunctorSalad_> dbbddbdb: one issue is there being a seperate "Show Zomg" instance somewhere
17:11:56 <defun> I know that GHC has a build dependency to GCC. However is this _only_ a build dependency, or does GHC use GCC as a back end for compiling haskell code? By GHC I mean GHC 6.10.x
17:12:59 <Saizan_> it uses gcc if you pass -fvia-C, and probably as a linker too
17:12:59 <pikhq> GCC is an *optional* backend for this.
17:13:22 <defun> I see. thanks.
17:14:03 <SamB> you also need gcc anyway to build those little snippets of C code which more-or-less invariably turn up when binding C libraries
17:14:41 <conal> is there a built-in signum in C?
17:14:41 <lambdabot> conal: You have 1 new message. '/msg lambdabot @messages' to read it.
17:15:05 <conal> FunctorSalad_: ping
17:15:15 <conal> @seen FunctorSalad_
17:15:15 <lambdabot> FunctorSalad_ is in #haskell, #haskell-in-depth and #haskell-blah. I last heard FunctorSalad_ speak 5m 11s ago.
17:15:26 <FunctorSalad_> *winks*
17:15:41 <pikhq> @seen pikhq
17:15:42 <lambdabot> You are in #haskell and #esoteric. I last heard you speak just now.
17:15:48 <pikhq> Whoo.
17:15:58 <soupdragon> :t signum
17:15:59 <lambdabot> forall a. (Num a) => a -> a
17:16:01 <SamB> conal: don't think so
17:16:06 <soupdragon> conal: I guess it's like signbit ? from math.h
17:16:12 <soupdragon> > signum 3
17:16:13 <lambdabot>   1
17:16:33 <conal> FunctorSalad_: hi.  i got your message.  MemoTrie works great, as far as I know.  I use it to implement my vector-space package (including general derivative towers), and no problems.
17:16:38 <SamB> conal: you probably can't even do it without branching or UB
17:16:51 <conal> SamB: soupdragon: thx.
17:16:52 <FunctorSalad_> conal: ah thanks, good to know
17:16:55 <conal> SamB: UB?
17:17:00 <SamB> nasal daemons
17:17:50 <conal> i was hoping i'd just forgotten the name and that there's a signum in GLSL.  i guess not.
17:18:00 <FunctorSalad_> shiftr 31? ;o
17:18:17 <SamB> conal: oh, that seems more likely than in C
17:18:49 <conal> haven't found it by searching.  i'll browse.
17:19:20 <nipuL> I'm adding some plugins to make some of the monitors work for freebsd in xmobar. I tried {-# LANGUAGE CPP #-} followed by #ifdef __FreeBSD__, but that didn't work. Is there another/better way to do this?
17:19:41 <conal> oh!  called "sign" in glsl.  :)
17:20:04 <shapr> @yow !
17:20:04 <lambdabot> I hope the ``Eurythmics'' practice birth control ...
17:20:43 * FunctorSalad_ read "euthymic"
17:20:47 <SamB> conal: see, I told you it was more likely in GLSL
17:21:15 <SamB> because if branching is bad for performance in C, it's far worse in shader code
17:21:18 <pikhq> @hoogle Expr
17:21:18 <lambdabot> module Text.Parsec.Expr
17:21:19 <lambdabot> module Text.ParserCombinators.Parsec.Expr
17:21:19 <lambdabot> Distribution.Simple.Program alexProgram :: Program
17:21:44 <conal> SamB: sure enough!  i hadn't thought of it that way.
17:22:32 <SamB> and/or not actually supported
17:23:08 <SamB> why I know all this when I don't even have pixel shaders, I'm not sure
17:23:09 <conal> worked :)
17:24:12 <ClaudiusMaximus> latest output from my haskell : http://img231.imageshack.us/img231/4648/61182837.gif
17:24:48 <soupdragon> that's nice
17:25:36 <conal> ClaudiusMaximus: lovely!  what are you up to?
17:25:53 <soupdragon> CladiusMaximus: it doesn't tile :( data:text/html;charset=utf-8,<body background=http://img231.imageshack.us/img231/4648/61182837.gif></body>
17:26:42 <SamB> soupdragon: do you have a bookmarklet to wrap image urls in that ?
17:26:43 <ClaudiusMaximus> conal: sorta working on a clone of Symmetriad
17:26:49 <soupdragon> SamB: no
17:26:59 <conal> @go Symmetriad
17:27:01 <lambdabot> http://web.mit.edu/~axch/www/Symmetriad/index.html
17:27:01 <lambdabot> Title: The Symmetriad
17:27:03 <ehird> soupdragon: tiles well enough
17:27:07 <ehird> looks trippy ;)
17:27:09 <ehird> *:)
17:27:16 <SamB> looks trippy but the edges bother me :-(
17:27:42 * ehird shakes self out of trance
17:27:46 <conal> ClaudiusMaximus: neat!  do you blog?  would be fun to read about.
17:28:23 <ClaudiusMaximus> conal: occasionally, but it's more a list of finished output than anything insightful..
17:29:06 <SamB> ClaudiusMaximus: maybe he thinks your other output might be similarly trippy ;-)
17:29:30 <ClaudiusMaximus> heh, well its here.. http://claudiusmaximus.goto10.org/cm/haskell.html
17:29:55 <conal> ClaudiusMaximus: thx!
17:39:22 * shapr boings
17:41:14 <defun> I'm having a hard Groking attribute grammars. I see them mentioned with UHC. What relevance do they have to Haskell?
17:48:13 <EvilTerran> defun, have you looked through http://www.haskell.org/haskellwiki/Attribute_grammar ?
17:51:15 <EvilTerran> iirc, "why attribute grammars matter" was quite illuminating
17:51:24 <Saizan_> atribute grammars are a combination and generalizations of folds and unfolds
17:52:10 <EvilTerran> you can unfold with them?
17:53:56 <Saizan_> you don't generate the structure as well as you don't collapse it, but the information flow is quite similar
17:54:43 <Saizan_> or maybe i'm just wrong :)
17:55:18 * EvilTerran didn't think they could be used to express corecursion
17:55:34 <Saizan_> uhm, they are more like a combination of left and right folds, maybe
17:55:45 <Saizan_> oh, yeah, they do
17:55:58 <Saizan_> it's quite common to tie the knot with them, i think
17:56:28 <EvilTerran> ah, true
17:59:52 <Saizan_> i'm not actually sure if that qualifies as corecursion
18:48:00 <saml> man i had a question but forgot what it was
18:48:33 <Pseudonym> That sounds like an lolcat.
18:50:53 <mmorrow> ohai, i has u a question, but i eated it?
18:51:04 * shapr CHOMPS the question
18:51:13 * shapr boings furiously
19:05:57 <copumpkin> I really want an easy way to make an "open sum of types" (if that's a good term) for things, like the data types à la carte stuff
19:06:07 <copumpkin> cabal install alacarteDIY
19:07:02 <copumpkin> or a set of types maybe
19:07:06 <copumpkin> with set union operations
19:07:33 <soupdragon> forall a. Int :+: ([Bool] :+: a)
19:07:40 <soupdragon> (:+:) = Either
19:08:20 <copumpkin> well, I want to be able to write a function that requires something to be an element of the "set"
19:08:36 <soupdragon> forall a. Int :+: ([Bool] :+: a) -> x -- :p
19:09:03 <copumpkin> :)
19:09:07 <soupdragon> maybe there is a real problem with this in practice? But I had not found it
19:10:07 <copumpkin> I mean, say I have an instruction in a GADT for an instruction set
19:10:20 <copumpkin> each instruction can specify what subarchitecture it belongs to
19:10:35 <soupdragon> I don't know what subarch is
19:10:45 <soupdragon> is that like 32 bit instructions as well as 64 bit ones?
19:11:03 <copumpkin> oh, I'm talking about ARM here, which has ARMv6, ARMv7, etc.
19:11:14 <copumpkin> different instructions were added in different versions
19:11:18 <copumpkin> along with coprocessor instruction sets
19:11:19 <soupdragon> oh right
19:11:30 <soupdragon> but the old ones aren't removed or changed?
19:11:34 <copumpkin> nope
19:11:46 <pikhq> 386 vs. 486 etc, also...
19:11:48 <copumpkin> so each instruction can state which architecture it came from
19:11:50 <soupdragon> (hmm.. certain haskell compilers could learn something here :p)
19:12:21 <soupdragon> how? like  data Instruction subarch where MOV ::: Instruction ARMv6 ; .. ?
19:12:27 <copumpkin> so if I have a list of instructions, I'd like to be able to represent in the type system that the list of instructions has instructions from ARMv7 and ARMv5
19:12:36 <copumpkin> pretty much, yeah
19:12:40 <soupdragon> ooh! this is a puzzle!
19:12:42 <copumpkin> the constructors take parameters too
19:12:52 <soupdragon> You need some type level 'token' which works kinda like a bitflag
19:12:57 <copumpkin> basically
19:13:02 <copumpkin> this is obviously massively overengineered, but it seemed like a fun problem
19:13:06 <soupdragon> we could punch some holes it in with polymorphism, and leave others out
19:13:15 <soupdragon> it's basically like inventing a lock & key
19:13:55 <copumpkin> so then I also have a runARMv5orEarlier :: ListOfInstructionsThatDoNotContainArmv6or7
19:14:02 <copumpkin> or something along those lines
19:14:08 <copumpkin> so I can guarantee no evil instructions end up in there :P
19:14:14 <copumpkin> this feels awfully dependent, doesn't it
19:15:01 <copumpkin> it'd just be fun to be able to guarantee that no extraneous instructions end up in my execution function when it's trying to behave like a particular arch
19:15:52 <soupdragon> do you have a list of just like 10 ARM instructions or something?
19:15:54 <soupdragon> I want to play this game :p
19:16:37 <soupdragon> I got a quickref card
19:16:59 <copumpkin> I can throw one out
19:17:07 <soupdragon> ok
19:17:14 <copumpkin> I hadn't actually been storing the subarchitecutre before this, so let me just add them in
19:18:00 <shapr> copumpkin: Is this an assembler?
19:18:19 <copumpkin> it might eventually turn into a few things, but my primary goal is a disassembler
19:18:24 <shapr> oh
19:18:50 <copumpkin> soupdragon: there's actually an annotated list of instructions with architecture here: http://github.com/android/platform_external_qemu/blob/2b8ea29e2bd12f876a4d06647e6077bf72de567e/arm-dis.c
19:18:50 <shapr> Are there any assemblers written in Haskell?
19:19:03 <copumpkin> shapr: harpy could be seen as an assembler I guess
19:19:12 <copumpkin> that's the only one I know of
19:20:36 <Saizan_> there's an assembler by roconnor in one of the TMR issues
19:20:47 <copumpkin> for what arch?
19:20:57 <Saizan_> i don't remember
19:21:03 * shapr looks
19:21:27 <Saizan_> the article was mainly about tying the knot
19:22:42 <Saizan_> copumpkin: do you need to derive the set from the elements or just check that the elements are members of a given set?
19:23:13 <copumpkin> deriving the set would be excellent, and reminds me a bit of the à la carte IO that was at the end of that paper
19:23:23 <copumpkin> but apparently that kind of stuff can't be type-inferred
19:24:57 <copumpkin> so I guess the most abstract formulation of the problem is to have a heterogeneous "list" of things like [C X, C Y, C Z, C X] and be able to figure out that that list contains [X, Y, Z] (obviously not real list syntax)
19:25:35 <dancor> what would you use to print words at some exact interval (soft real-time)
19:25:45 <dancor> reactive?
19:26:05 <copumpkin> dancor: maybe a forever on a forkIO'd thread with a threadDelay and a print in it?
19:26:21 <dancor> well i'm going to want the interval to be changeable with user input
19:26:33 <copumpkin> changeable while it's still running?
19:26:34 <dancor> and i want it to correct for delays
19:26:37 <dancor> ya
19:26:52 <copumpkin> ah, well you could still pass it an IORef and give it slightly more sophisticated timing code
19:26:53 <copumpkin> but that'd be ugly
19:27:11 <dancor> if one print ever took an extra 100ms for whatever reason sometime, it should catch back up
19:27:45 <dancor> ya
19:27:59 <dancor> so DIY or reactive are the basic options?
19:28:12 <dancor> and atom if you need hard real-time
19:28:35 <Saizan_> copumpkin: uhm, often the problem is constructing the "list" in the first place, i think, since once you've it you can use type families to extract just the interesting types
19:28:50 <copumpkin> yeah
19:29:02 <copumpkin> I think this part of it at least is pretty much exactly what was in the à la carte paper
19:29:06 <copumpkin> I should look at it again
19:29:11 <Saizan_> dancor: reactive isn't really ready for use, afaik
19:29:22 <dancor> oh i heard it was closer recently
19:29:30 <copumpkin> then the problem becomes imposing conditions on the "set/list"
19:29:48 <soupdragon> ohh I tried my idea but it doesn't work
19:29:56 <copumpkin> aw
19:29:57 <soupdragon> try something else
19:30:01 <copumpkin> thanks for trying :)
19:30:05 <Saizan_> like [X, Y, Z] `subset` [Z] ?
19:30:30 <Saizan_> (failing in this case)
19:30:42 <copumpkin> yeah
19:30:59 <copumpkin> maybe I should stop trying to be so dependent
19:31:11 <Saizan_> why? it's fun! :)
19:31:15 <copumpkin> :P
19:31:24 <Saizan_> and subset is quite easy, iirc
19:31:47 <BMeph> I have a style "issue": I have a "one-liner function" with six lines of where-clausesupport. Is is usual to break out some of those support functions to top-level, even if you don't expect them to be used, but just want the aesthetics of having a smaller where-clause?
19:32:39 <dancor> BMeph: i've done that (warning: i'm terrible)
19:33:19 <sboult> anyone have an ready code that solves the n queens problem ?
19:33:23 <BMeph> dancor: Yes, but I have the conceit that just because you flub a lot doesn't mean you always flub. ;)
19:33:41 <BMeph> @go haskell queens
19:33:41 <lambdabot> No Result Found.
19:33:44 <Saizan_> copumpkin: data List :: (* -> *) -> * -> * where Nil :: List f (); Cons :: f x -> List f xs -> List f (x,xs)
19:33:47 <BMeph> Boo!
19:33:51 <dancor> BMeph: the way i see it, if your function were really crazy then you would put it in a separate module and have top-level helpers then
19:34:10 <Saizan_> copumpkin: if you construct your list of instructions with that then you've the list of type ready
19:34:11 <copumpkin> Saizan_: what is that List signature?
19:34:23 <copumpkin> (* -> ) ??
19:34:29 <copumpkin> where ?? isn't a kind
19:34:30 <copumpkin> :P
19:34:44 <Saizan_> (* -> *) -> * -> * ?
19:34:49 <copumpkin> yeah
19:34:53 <dancor> and modules are better for namespacing than where is
19:35:05 <Saizan_> it's the kind signature
19:35:06 <dancor> ..some kind of argument starting with those precepts ;)
19:35:10 <Saizan_> does it look weird?
19:35:26 <copumpkin> Saizan_: yeah, there's things missing from it I think?
19:35:36 <Saizan_> (* -> *) -> * -> * , now?
19:35:43 <copumpkin> I still see one-sided arrows
19:35:49 <dancor> BMeph: also it's possible to test helpers that are broken-out
19:36:16 <dancor> so, in a way, you should never use where for anything you ever want to test ;)
19:36:37 <BMeph> dancor: I'll give it a thought. It feels odd to me to have a twelve-line module just to contain the auxiliary functions for one function. :)
19:36:42 <Saizan_> copumpkin: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6227#a6227 <- better?:)
19:36:55 <copumpkin> aha, yes!
19:36:58 <copumpkin> I wonder what was wrong
19:37:27 <dancor> yeah you don't have to make a separate module, but it should justify not using where
19:37:31 <sboult> @go haskell n queens
19:37:32 <lambdabot> No Result Found.
19:38:50 * ManateeLazyCat pasted "DoubledLinkedList.hs" at http://paste2.org/get/282742
19:38:50 <ManateeLazyCat> In above link, i got error "Couldn't match expected type `IO (Node a)' against inferred type `[Node a]'" in "instance (Show a) => Show (Node a) where
19:38:51 <ManateeLazyCat> ", strange..... why?
19:38:51 <ManateeLazyCat>  
19:38:53 <soupdragon> hey I got it pumpkin
19:39:05 <ManateeLazyCat> :t readIORef
19:39:06 <lambdabot> Not in scope: `readIORef'
19:39:15 <ManateeLazyCat> :l Data.IORef
19:39:22 <ManateeLazyCat> :t readIORef
19:39:24 <lambdabot> Not in scope: `readIORef'
19:39:46 <copumpkin> soupdragon: ooh, how?
19:40:15 <BMeph> sboult: I'd recommend just searching in your search engine of choice for it; there are plenty of hits for it. :)
19:40:23 <soupdragon> I'ts just like that http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6229
19:40:34 <soupdragon> you make a bitmask for each subarch, they are left open too (with a variable)
19:40:47 <soupdragon> and then you can mask on or off using O or X (type level tokens)
19:40:52 <ManateeLazyCat> In http://paste2.org/get/282742 , i use "leftNode <- readIORef nl` should be get `Node a`, but ghci report `leftNode` is [Node a].
19:41:06 <soupdragon> the GADT def is a big ugly because those guys need some variables to play with but #define could sort that
19:41:23 <copumpkin> soupdragon: wow, that's neat
19:41:36 <Saizan_> ManateeLazyCat: you can't use IO actions in a Show instance
19:41:45 <ManateeLazyCat> Saizan_: Bad.
19:42:01 <BMeph> ManateeLazyCat: No offense meant to you, but I'd agree with GHCi on that one. :)
19:43:03 <copumpkin> soupdragon: can the types be inferred like that?
19:43:19 <soupdragon> yes but they don't have nice names
19:43:29 <ManateeLazyCat> Thanks, i see.
19:43:30 <soupdragon> it's like X :& i2 :& O :& X internially
19:43:44 <copumpkin> hmm, /me plays around with thi
19:43:45 <copumpkin> s
19:43:57 <copumpkin> the type system is so fun, I should really set aside some time for just fooling around with it :)
19:44:04 <copumpkin> thanks :)
19:44:13 <soupdragon> I wonder if there is a language that lets you do type level hacks AND readable error messages
19:44:15 <Saizan_> oh, that's remarkably similar to one of the first formulations of row types
19:45:06 <copumpkin> is there a way of avoiding the explicit type parameters so I could potentially add a subarch later on? :P
19:45:29 <Saizan_> you allocate an index for each label and simply mark if that label is present by a true/false in the right position
19:45:37 <dibblego> @type let p [] = Nothing; p (h:t) = Just (h, t) in p -- is this in the library?
19:45:39 <lambdabot> forall t. [t] -> Maybe (t, [t])
19:45:59 <Saizan_> copumpkin: you can add a subarch
19:46:02 <copumpkin> @hoogle uncons
19:46:03 <lambdabot> Data.ByteString uncons :: ByteString -> Maybe (Word8, ByteString)
19:46:03 <lambdabot> Data.ByteString.Char8 uncons :: ByteString -> Maybe (Char, ByteString)
19:46:03 <lambdabot> Data.ByteString.Lazy uncons :: ByteString -> Maybe (Word8, ByteString)
19:46:13 <soupdragon> copumpkin, well you'd have to edit the source code to add a new arch
19:46:16 <copumpkin> Saizan_: yeah, but then I have to add a type parameter to every instruction, right?
19:46:21 <copumpkin> soupdragon: yeah, that makes sense
19:46:23 <soupdragon> copumpking,  well I guess you could blow open the GADT too
19:46:25 <Saizan_> copumpkin: no
19:46:43 <soupdragon> copumpkin, so in that way a different module could tie the knot with that GADT and you'd have extra instructions
19:46:57 <Saizan_> copumpkin: actually, the ARM_EXT_V4 and ARM_EXT_V5 type synonyms don't need 3 arguments either
19:48:38 <copumpkin> how so?
19:48:54 <copumpkin> also, is there an easy way to do a bitset union using this representation?
19:49:24 <copumpkin> like ARM_EXT_V4 & ARM_EXT_V5
19:49:32 <Saizan_> copumpkin: like this http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6229#a6230
19:49:41 <copumpkin> oh, yeah, I see :)
19:51:39 <Saizan_> uhm, union you say
19:52:01 <copumpkin> sounds hard :)
19:54:15 <soupdragon> I think you could break it open like that, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6229
19:54:21 <Saizan_> maybe not too hard
19:54:43 <soupdragon> actually that's not quite good enough
19:56:31 <copumpkin> damn, removing the type parameters to ARM_EXT_V4 and the like, and replacing with an internal forall didn't work :P
19:57:16 <copumpkin> I guess this way I can specify that something doesn't care
19:59:51 <twb> Does cabal (i.e. ./Setup) support a -j4 option, to use multiple cores?
19:59:56 <copumpkin> nope
20:00:01 <twb> Bummer.
20:00:03 <copumpkin> lots of people want it though
20:00:13 <copumpkin> so it's probably on its way :)
20:02:03 <copumpkin> I'm guessing I can't do a type-level filter on a list of all instructions now, eh :P
20:02:17 <copumpkin> or maybe a typeclass would do that for me
20:03:19 <Saizan_> copumpkin: here's union http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6229#a6232
20:03:35 <copumpkin> oh, cool
20:03:48 <copumpkin> this is all awesome
20:03:50 <Saizan_> if those lists of bits had an explicit terminator it'd be shorter :)
20:04:12 <jeff____> I keep trying to use mkRequest in Network.HTTP.Base and it says "not in scope"
20:04:19 <jeff____> I have it and Network.HTTP imported
20:04:20 <copumpkin> Saizan_: you mean the :& lists?
20:04:27 <Saizan_> copumpkin: yeah
20:04:38 <copumpkin> hmm
20:04:47 <jeff____> and it compiles on other machines.  looked at the source code for http 4000.0.7 and it's there
20:04:48 <jeff____> so...
20:05:11 <Saizan_> copumpkin: if they where constructed like a :& b :&  ... :& Nil
20:05:17 <RyanT5000> Hey guys, the Haskell-iPhone mailing list is up; to sign up, go to: http://www.haskell.org/mailman/listinfo/iphone
20:05:18 <copumpkin> ah, how would it look then?
20:05:37 <copumpkin> actually, /me tries to figure it out
20:05:51 <Saizan_> jeff____: are you using that version on this machine?
20:05:58 <jeff____> yes
20:07:33 <jeff____> ahhh.  wait, but the cabal package that was building was not using that version... it was using 4000.0.4
20:07:40 <Saizan_> .
20:07:48 <Saizan_> you need a cabal update, probably
20:07:52 <jeff____> wasn't using the latest installed version.
20:08:03 <jeff____> just built this machine fresh an hour ago
20:08:22 <jeff____> I hardcoded the version in the cabal file and that fixed it
20:08:51 <Saizan_> cabal uses the latest version available by default
20:09:37 <Saizan_> however you do need to put lower and upper bounds on the dependencies if you're going to distrubute the package
20:09:50 <jeff____> well, i'm not sure.  I had it set to "-any" originally, and I see two versions of HTTP installed, 4000.0.4 and 4000.0.7
20:10:05 <jeff____> right.  and now I've discovered why ^_^
20:11:32 <copumpkin> Saizan_: is there no way for me to substitute (ARM_EXT_V6 i0 i1 i2) with a "macro" representing the same quantity without typing all the variables without using CPP or TH?
20:12:03 <soupdragon> why without CPP
20:12:07 <soupdragon> ? it's easy with CPP
20:12:24 <copumpkin> yeah :P but I was seeing how far I could stretch the type system
20:12:25 <lpjhjdh> using lazysmallcheck I need to match over data generated by a call to series.  Is there some way to do this?  I'm looking through the source and it seems grim...
20:14:06 <Saizan_> copumpkin: i don't think so, you'd want a type with free type variables in it, but GHC doesn't let you have one
20:14:19 <copumpkin> ah :)
20:15:34 <copumpkin> alright, I might use TH because CPP feels slightly dirty and I'll probably be using TH anyway for something else
20:16:38 * Saizan_ wants row types
20:16:44 <copumpkin> how do those work?
20:18:20 <Saizan_> you'd get to say AND :: Inst (V4 : r); NOP :: Inst (V6 : r); and [AND,NOP] :: Inst (V4 : V6 : r)
20:18:48 <Saizan_> [AND,NOP] :: Inst (V6 : V4 : r) too, since those are both the same type
20:18:57 <soupdragon> I think ocaml has row types
20:20:10 <mmorrow> sml has {x=42,ohai=(4,3)} : {x:int, ohai: int * int}
20:20:33 <mmorrow> and you don't have to pre-declare the {x=..,ohai=..}
20:21:02 <mmorrow> i've never used ocaml, but i'd assume it has the same thing (?)
20:22:02 <mmorrow> too bad smlnj doesn't have an x86_64 codegen :(
20:22:05 <Saizan_> just row types without extensible records/variants would be fairly useful
20:22:16 <mmorrow> totally
20:22:21 <Saizan_> s/without/even without/
20:22:40 <BMeph> This isn't legal (without an extension on) is it: "nTree' n (lastTree n) = []"
20:23:21 <mmorrow> what is that?
20:23:37 <mmorrow> (view pattern?)
20:24:17 <Saizan_> what's the type of lastTree?
20:24:44 <holmak> clojurebot: :t lastTree
20:25:00 <holmak> erm, wrong bot
20:25:10 <holmak> haskellbot: :t lastTree
20:25:27 <mmorrow> @botmatrix
20:25:28 <lambdabot> Unknown command, try @list
20:25:28 <lunabot>  :)
20:25:53 <holmak> It's been a long time since I messed with lambdabot
20:25:56 <holmak> Don't mind me
20:25:57 <jeff____> one last question...  does anyone have any clue why I would get a bus error on OS X with a gtk2hs app that works fine on windows and linux?  is there something in gtk2hs not supported on mac?
20:26:03 <BMeph> lastTree is Int -> [Int], and nTree' :: Int -> [Int] -> [[Int]]
20:26:21 <holmak> @list
20:26:21 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
20:26:45 <mmorrow> nTree' (lastTree -> []) = []
20:26:46 <mmorrow> ?
20:26:48 <holmak> @type lastTree
20:26:50 <lambdabot> Not in scope: `lastTree'
20:26:59 <holmak> Ah, no good anyway
20:28:02 <mmorrow> , let foo (take 1 -> []) = 99; foo (foo -> x) = x in foo [[0],[1],[],[2]]
20:28:10 <lunabot>  Killed.
20:28:20 <mmorrow> i forget how to write fix with view patterns
20:28:43 <mmorrow> , let foo (take 1 -> []) = 99; foo (foo . drop 1 -> x) = x in foo [[0],[1],[],[2]]
20:28:43 <jeff____> oh hey mmorrow...
20:28:44 <lunabot>  99
20:28:47 <mmorrow> wee
20:28:50 <jeff____> you pinged me the other day
20:28:52 <jeff____> well, the other me
20:28:54 <jeff____> jeffersonheard
20:28:58 <mmorrow> ah, hi
20:28:59 <jeff____> do you remember what about?
20:29:00 <BMeph> That looks clunky as all get-out: nTree' n ((== lastTree n) -> True) = [] -- I think that's how you'd play it...
20:29:31 <jeffersonheard> I was afk for the day and forgot to turn my IRC off
20:29:36 <soupdragon> nTree' n ((== lastTree n) -> True) = [] ???
20:29:50 <copumpkin> Saizan_: how would the terminated type-level list approach work? I can't really do X :& a :& Nil for V4, for example
20:30:01 <soupdragon> it's bad to write:  nTree' n foobar | foobar == lastTree n = []
20:30:02 <soupdragon> ?
20:30:29 <mmorrow> jeff____: i was reading about how you're writing OpenGLRaw, and was wondering if you need to deal with whatever reason the current OpenGL bindings have to use TLS, and also just about OpenGLRaw in general
20:30:49 <Saizan_> copumpkin: you'd have to keep an "open" and a "closed" V4, like i did in the paste with Union
20:31:13 <BMeph> soupdragon: Yeah, that's how I have it now. I was just looking for a shortcut. :)
20:31:24 <jeffersonheard> mmorrow:  I'm not writing OpenGLRaw, Sven is...
20:31:26 <Saizan_> copumpkin: the closed one, that you'd use with Union, would be X :& Nil
20:31:27 <copumpkin> yeah, so the open one is saying "this is my bit, I don't care about the rest", and the closed one says "this is me"
20:31:35 <Saizan_> yeah
20:31:36 <mmorrow> jeffersonheard: ah, ok (sven?)
20:31:42 <jeffersonheard> Sven Panne
20:31:48 <mmorrow> ah, ok cool
20:31:54 <copumpkin> Saizan_: yeah, I get that one, but how about the open list with a terminator?
20:32:01 <copumpkin> or is it no different?
20:32:04 <jeffersonheard> I'm using OpenGLRaw, but he's writing it.  I was just happy to see we got a 3.0 binding so quickly
20:32:11 <Saizan_> it's no different from now
20:32:12 <mmorrow> jeffersonheard: is it aimed at being a "drop-in replacement" do you know?
20:32:17 <copumpkin> ah, cool... I'll experiment :)
20:32:47 <copumpkin> I guess :| would be a better name than :&
20:33:01 <mmorrow> jeffersonheard: (in particular i'm wondering about what sort of support/ability it'll have to be able to use it (carefully, etc) concurrently)
20:33:04 <jeffersonheard> no, but right now, 3.0 is different enough from 2.x to warrant a complete rethink of how HOpenGL works.  Sven released Raw because he figured it'd invite new implementations
20:33:23 <jeffersonheard> ah.
20:33:34 <jeffersonheard> that was contentious at SIGGraph last year when they revealed it
20:33:51 <jeffersonheard> b/c OpenGL has no concurency support as of 3.0 despite the fact that DirectX does
20:34:24 <mmorrow> hmm, so i guess the TLS is the way the current OpenGL binding gets around this
20:34:34 <jeffersonheard> yep.
20:34:52 <mmorrow> (and i guess that's the only feasible way too (?))
20:35:19 <jeffersonheard> well, short of relying on operating system specific features like CPU locking
20:35:57 <jeffersonheard> the deal with 3.0, though is it's supposed to be a lot more sensible about when GL gets called
20:36:25 <jeffersonheard> so...  theoretically you spend the majority of your CPU time arranging vertices colors and norms in memory in a buffer object
20:36:27 <JamesSanders> is there a good database abstraction library for haskell?
20:36:42 <jeffersonheard> and then call GL on the main thread to do your drawing
20:36:43 <copumpkin> how abstract?
20:36:58 <mmorrow> jeffersonheard: hmm, interesting. i'll have to read up on it.
20:37:29 <jeffersonheard> and the GL calls themselves are incredibly cheap, b/c essentially they're no more than interrupts that send a word to the video card for pipelined execution
20:37:45 <jeffersonheard> well, a word and parameters
20:38:20 <jeffersonheard> their argument was that calling gl from multiple threads was senseless because most graphics cards are so much more multithreaded tat all concurrency shoudl occur on that end
20:42:49 <mmorrow> i wonder if the use of TLS could be layered on a haskell ffi binding, without that binding knowing about it
20:43:54 <jeffersonheard> dunno...
20:43:56 <uweDeportivo> got a quick question for you guys: flip has type flip :: (a -> b -> c) -> b -> a -> c, id has type id :: a -> a, so why am i allowed to feed id to flip as the first argument as in (flip id) 4 (+1)
20:44:14 <mmorrow> iirc you just use pthread_{get,set}specific
20:44:26 <mmorrow> hmm
20:44:43 <Draconx> uweDeportivo, the 'a's in both type signatures are different.
20:45:10 <uweDeportivo> ok, i understand that part
20:45:23 <Draconx> uweDeportivo, the 'a' in id's type will unify with anything, including 'b -> c'
20:46:16 <uweDeportivo> ok, let me chew on that a little
20:46:25 <Draconx> @type flip id
20:46:26 <lambdabot> forall b c. b -> (b -> c) -> c
20:46:28 <mmorrow> jeffersonheard: heh, i guess they fail to take into account code that might migrate *between* threads without it knowing (or caring)
20:46:37 <Draconx> @type flip (id :: (b -> c) -> (b -> c))
20:46:39 <lambdabot> forall b c. b -> (b -> c) -> c
20:46:40 <mmorrow> like, say, ghc haskell code :)
20:47:06 <jeffersonheard> indeed :-)
20:47:06 <mmorrow> jeffersonheard: (re: "their argument was that calling gl from multiple threads was senseless because most graphics cards are so much more multithreaded tat all concurrency shoudl occur on that end")
20:47:11 <mmorrow> :)
20:50:37 <uweDeportivo> the thing that confuses me is flip's first argument is a "binary" function and id is unary, i know through currying everything is unary but still...am i looking at it the wrong way ?
20:50:46 <jeffersonheard> yeah,  they failed to take into account that there are people that don't use C and like optimization
20:52:22 <jeffersonheard> anyway.  gotta crashs.  got to get up insanely early tomorrow
20:52:31 <mmorrow> night
20:59:09 <Draconx> uweDeportivo, you probably are.  flip's first argument is a function that takes an 'a' (where a can be anything at all) and yields a function from 'b -> c' (where b and c can also be anything at all).  Now look at id :: (b -> c) -> (b -> c) - it is exactly such a function.
21:00:33 <mmorrow> uweDeportivo:
21:01:00 <mmorrow> id :: a -> a ====> id :: (a -> b) -> (a -> b)
21:01:09 <mmorrow> ===> id :: (a -> b) -> a -> b
21:01:19 <RyanT5000> so, guys, i'm trying to figure out how to set up the repo for ghc-iphone; I've got a .patch file that applies to ghc-6.10.2
21:01:25 <mmorrow> ===> (flip id) :: a -> (a -> b) -> b
21:01:48 <RyanT5000> should i basically check out the ghc-6.10.2 code into a darcs repo, then apply the .patch file, then record a darcs patch locally?
21:01:55 <mmorrow> oops, Draconx beat me to it :)
21:01:55 <copumpkin> RyanT5000: I think so
21:01:56 <RyanT5000> that would basically make a branch, right?
21:02:11 <uweDeportivo> :-)
21:02:14 <uweDeportivo> thanks guys
21:03:33 <uweDeportivo> i think i got it, thanks
21:03:46 <mmorrow> :)
21:04:35 <mmorrow> @type [id,($)]
21:04:37 <lambdabot> forall a b. [(a -> b) -> a -> b]
21:05:19 <mmorrow> @type [const id, flip const]
21:05:20 <lambdabot> forall a b. [b -> a -> a]
21:05:39 <mmorrow> lists are handy for forcing :t to unify two types
21:05:55 <mmorrow> (to see the result)
21:05:56 <Draconx> hm, that's a neat trick.
21:06:07 <BMeph> @type const succ
21:06:08 <lambdabot> forall a b. (Enum a) => b -> a -> a
21:06:26 <Draconx> @type id `asTypeOf` ($)
21:06:28 <lambdabot> forall a b. (a -> b) -> a -> b
21:07:03 <mmorrow> the elusive asTypeOf :)
21:07:23 <BMeph> How does GHC know that (flip.) is (.) flip, and not flip (.)? :)
21:07:24 <mmorrow> @type const `asTypeOf` asTypeOf
21:07:26 <lambdabot> forall a. a -> a -> a
21:07:34 <Elly> wait, what?
21:07:39 <Elly> @type asTypeOf
21:07:40 <lambdabot> forall a. a -> a -> a
21:07:47 <Elly> that's...odd
21:07:48 <Draconx> BMeph, because the language defines (flip .) to be exactly that.
21:07:59 <mmorrow> Elly: what part?
21:08:08 <Elly> what does it do?
21:08:37 <Elly> you hand it two things of the same type, and it returns the second thing, I'm guessing?
21:08:41 <Draconx> Elly, it takes two values of the same type and yields the first one.  It is used to unify the two types.
21:08:43 <mmorrow> it was used before lexically scoped tyvars existed to force types to be the same as the type of another val
21:08:46 <Elly> ahh, that's what I guessed
21:08:46 <SamB> BMeph: how does it know you're not referring to the () operator from module flip?
21:08:52 <BMeph> > 3 `asTypeOf` (undefined::Double)
21:08:53 <lambdabot>   3.0
21:10:44 <BMeph> SamB: Er... "because it's 'flip', not 'Flip'" - but that doesn't quite fit the syntax I was using. :)
21:11:39 <SamB> BMeph: you didn't even blink at the () bit, though ?
21:12:04 <SamB> mmorrow: they still don't exist always
21:12:25 <mmorrow> SamB: true
21:13:10 <mmorrow> which makes sizeOf a total pita ;)
21:13:27 <roconnor> @instance ()
21:13:28 <lambdabot> Maybe you meant: instances instances-importing
21:13:34 <roconnor> @instances ()
21:13:35 <lambdabot> Couldn't find class `()'. Try @instances-importing
21:13:36 <mmorrow> when you have no val of that type and eg (Ptr a)
21:13:50 <copumpkin> @instances Num
21:13:51 <lambdabot> Double, Float, Int, Integer
21:14:00 <mmorrow> err, bad example since Ptr is always the same size..
21:14:09 <BMeph> SamB: I assumed you had something complex in mind, so I answered as well as I could guess your intent.
21:14:14 <mmorrow> castPtr
21:14:35 <SamB> BMeph: no, I was just ridiculing *your* question
21:14:45 <SamB> if that's alright with you ;-)
21:15:20 * mmorrow throws an oil-soaked seagull at SamB
21:15:36 <BMeph> SamB: It doesn't matter if it is or not, you *can* do as you please. Maybe I'm just too dense, but I don't see the ridicule. :)
21:16:05 <roconnor> long ptr or short ptr?
21:16:17 <SamB> BMeph: are you, like, a newbie who I somehow thought was not a newbie or something ?
21:16:26 * mmorrow finds seagulls handy for throwing
21:16:37 <SamB> roconnor: we don't have far ptrs in Haskell :-(
21:16:49 <SamB> makes it a bit tricky to write DOS code :-(
21:16:55 <copumpkin> lol
21:17:01 <copumpkin> thank god
21:17:12 <SamB> I'm talking DPMI code
21:17:17 <RyanT5000> SamB: couldn't you build them yourselves?
21:17:20 <SamB> not that horrid 16-bit mess
21:17:21 <RyanT5000> *yourself
21:17:31 <SamB> RyanT5000: I suppose so
21:17:32 <BMeph> SamB: If you thought I wasn't a newbie, I'll just say "Thanks!" and go on. :)
21:17:34 <RyanT5000> out of Word16 and poke
21:17:51 <mmorrow> you can build anything with poke
21:17:55 <mmorrow> ;)
21:17:57 <SamB> BMeph: do I possibly know you from some channel where you aren't a newbie ?
21:18:49 <mmorrow> for some reason this mention of poke reminded me of this, which is neat
21:18:51 <mmorrow> http://moonpatio.com/images/applewo.jpg
21:19:07 <mmorrow> it moves itself along in memory
21:19:07 <BMeph> SamB: Nope, my programming skills sat on a shelf for a long time (roughly ten years), and I still haven't done anything constructive with 'em lately.
21:19:13 <copumpkin> mmorrow: cute
21:19:14 <shepheb> does Alson Kemp of Turbinado fame actually exist outside of his blog?
21:19:25 <copumpkin> @seen akemp
21:19:26 <lambdabot> I haven't seen akemp.
21:19:34 <copumpkin> I vaguely remember seeing a nick in here that sounded like him
21:19:35 <SamB> mmorrow: hmm.
21:19:41 <shepheb> preflex: seen akemp
21:19:41 <preflex>  Sorry, I haven't seen akemp
21:19:45 <SamB> mmorrow: now if only I had an apple to sacrifice to it
21:19:48 <copumpkin> it might not have been akemp
21:19:51 <copumpkin> just can't remember what it was
21:19:52 <SamB> or at least a virtual one
21:20:00 <mae> how can we see stats on how much a hackage item has been downloaded
21:20:04 * mmorrow wants to rewrite it for x86_64 and watch it go
21:20:10 <Saizan_> shepheb: i've talked to him twice!
21:20:31 <mmorrow> SamB: write an amulator for the subset of instrs in that prog?
21:20:35 <mmorrow> s/a/e/
21:20:39 <shepheb> I want to badger him into writing a few specific lines of documentation
21:20:48 <Saizan_> mae: get someone to mail you the apache logs?:)
21:20:54 <mae> Saizan_: heh
21:21:02 <shepheb> namely, the ones describing what exactly I'm supposed to return from the DBMS-specific functions in the ORM
21:21:10 <SamB> shepheb: if you know what lines you want written, why don't you just type them in ?
21:21:49 <shepheb> I intend to type in the code I want (Sqlite3 back-end) but I'm grasping in the dark unfortunately.
21:22:52 <SamB> yeah, it's a silly joke about the meaning of "a few specific lines"
21:23:34 <shepheb> SamB: I follow. anyway, if he doesn't hang out here I'll try to figure out what the MySQL or Postgres backends are doing.
21:25:17 <EnglishGent> hello all :)
21:25:32 <mmorrow> , gcd 0 0
21:25:34 <lunabot>  luna: Prelude.gcd: gcd 0 0 is undefined
21:26:07 <BMeph> EnglishGent: Pip pip, and all that rot, ol' chap! ;p
21:26:24 <cjs> When trying to build the hpc library, cabal can't find my include/gmp.h. The problem is, it's in a non-standard location: /usr/pkg/include. (Same goes for the libs, of course.) Does anybody know what parameters I need to add to the cabal config command to have it find it? Or can I set an environment variable?
21:26:27 <EnglishGent> hi BMeph :)
21:29:50 <copumpkin> oh dammit
21:29:59 <copumpkin> the ridiculous type hackery might not work
21:30:10 <EnglishGent> hello cjs, copumpkin
21:30:14 <copumpkin> (or be elegant anymore)
21:30:15 <EnglishGent> :)
21:30:16 <copumpkin> hi EnglishGent
21:30:32 <EnglishGent> what are you trying to do copumpkin? (curious)
21:30:54 <copumpkin> represent an entire architecture spec in a typesafe manner
21:30:58 <copumpkin> (for ARM)
21:31:06 <mmorrow> @yow
21:31:07 <lambdabot> I'm also pre-POURED pre-MEDITATED and pre-RAPHAELITE!!
21:31:36 <copumpkin> my issue is that I can use the GADT trickery we discussed earlier to make it safe
21:31:41 * mmorrow was hoping for "I love a man with a HAIRPIECE, I'm RELIGIOUS, EQUIP me with MISSILES!"
21:31:49 <cjs> Ah. "--extra-include-dirs" and "--extra-lib-dirs".
21:31:58 <copumpkin> but I also want to give each opcode actual values
21:32:04 <copumpkin> oh, maybe this will work
21:32:17 <EnglishGent> hi mmorrow :)
21:32:33 <mmorrow> hi Englishxey :)
21:33:07 <cjs> Hm. No, that doesn't seem to help....
21:33:44 <cjs> Does GHC 6.10.3's "--with-gmp-includes" configure option work properly? It doesn't seem to do so for me.
21:35:32 <PhDP> Simple question: how do I "cast" an integer to a double ? I saw fromInt somewhere but I get errors from GHC
21:36:18 <copumpkin> I guess I'm really running into the dependent types wall
21:36:32 <copumpkin> trying to do too much :P
21:37:13 <mmorrow> , fromInegral(42::Integer)::Double
21:37:14 <lunabot>  luna: Not in scope: `fromInegral'
21:37:19 <mmorrow> , fromIntegral(42::Integer)::Double
21:37:21 <lunabot>  42.0
21:37:37 <mmorrow> , fromIntegral(42::Int)::Double
21:37:39 <lunabot>  42.0
21:38:01 <Saizan_> copumpkin: what's the problem?
21:38:04 <PhDP> oh, I was using it the wrong way ;)
21:38:08 <PhDP> thank you
21:38:09 <mmorrow> , fromIntegral(42::Int)::Word32
21:38:11 <lunabot>  42
21:38:11 <mmorrow> np
21:38:25 <Associat0r> copumpkin: deptypes wall?
21:38:37 <Associat0r> copumpkin:  tell me more
21:38:58 <copumpkin> Saizan_: well, I'd like to associate values (as opposed to types) with each of those GADT constructors :P I could write a function to associate these but that would effectively be taking my mile-long GADT list of constructors and repeating it for the function
21:40:07 <Saizan_> copumpkin: so you want like a Map a (Inst b) ?
21:40:18 <Saizan_> copumpkin: or Map a (exists b. Inst b)
21:40:39 <copumpkin> I actually just need Map (Inst b) a
21:40:44 <copumpkin> (I think)
21:40:51 <copumpkin> it's not even a polymorphic a
21:41:14 <copumpkin> it'd just be some type I use to actually represent the format of the instruction for the en/decoder
21:41:15 <mmorrow> but is it a single type?
21:41:32 <copumpkin> sure, it could be
21:42:03 <Saizan_> uhm, so the problem is actually that it's tedious, more than fighting with the typechecker?
21:42:04 <copumpkin> it'd just be something like data InstructionInfo = InstructionInfo String [Bit] or something
21:42:24 <copumpkin> yeah, just that I'd have to define the information in different places
21:42:25 <mmorrow> copumpkin: codegen ftw
21:42:28 <copumpkin> lol yeah
21:42:33 <mmorrow> String++
21:42:34 <copumpkin> I was hoping to use this as a codegen for the actual decoder
21:42:42 <mmorrow> actually,
21:42:44 <mmorrow> Doc++
21:43:03 <copumpkin> so that I could have a decoder I could be reasonably sure is correct
21:43:27 <mmorrow> just generate the haskell code with HughesPJ.Doc
21:43:31 <Saizan_> ah, so the fact is that you've to translate each instruction name into a String etc..
21:43:57 <copumpkin> Saizan_: yeah, and keep other metadata about it, like the bit pattern needed to encode and decode the instruction, and so on
21:44:26 <copumpkin> mmorrow: I was planning to run this code in TH to generate the actual decoder at compile time
21:44:30 <Saizan_> i don't think typehackery can help there :)
21:44:57 <mmorrow> if you need massive static data, Alex/Happy use Addr# literals to get around the exponential compile-time
21:45:03 <copumpkin> well, I can dump the GADT and just make a list of things like i_nop :: Inst (ARM_EXT_V6 i0 i1 i2)
21:45:08 <mmorrow> "OH HAI"# :: Addr#
21:45:33 <copumpkin> mmorrow: oh? wouldn't it be easier to fix the exponential compile time than to hack around it? :P
21:45:43 <copumpkin> I guess not
21:45:46 <mmorrow> copumpkin: hha
21:46:04 <Saizan_> copumpkin: oh, sure
21:46:14 <Saizan_> copumpkin: we're not actually using type refinements here
21:46:17 <copumpkin> Saizan_: but I'm afraid of that because I can't pattern match against it
21:46:27 <asmips_> Is Haskell worth it to learn??? I have good knowledge of C++, ruby, lisp, what does Haskell have to offer that prefer it over these tools?
21:46:29 <copumpkin> but yeah, maybe pattern matching isn't that big a deal
21:46:45 <copumpkin> asmips_: it will stretch your mind in a way it's never been stretched, if you stick to it
21:46:48 <EnglishGent> asmips_ - lazy evaluation & a very powerful type system
21:46:55 <hackagebot> sendfile 0.2 - A portable sendfile library (MatthewElder)
21:47:07 * EnglishGent is just learning Haskell & has already done Lisp
21:47:26 <asmips_> I am familiar with functional programming in lisp already. How is haskell different from lisp. I mean what benefit haskell has that lisp doesn't???
21:47:32 <EnglishGent> in fact - Haskell's TypeClass mechanism is going to be in the next version of the C++ standard (under the name 'concepts')
21:47:33 <EnglishGent> :)
21:47:53 <dibblego> asmips_, haskell is pure, lazy and statically typed
21:48:10 <mmorrow> asmips_: and you can do:
21:48:14 <copumpkin> asmips_: you'll still get your mind stretched in crazy ways... it's almost completely different from the languages you listed, despite being "functional" like lisp
21:48:20 <EnglishGent> hello dibblego :)
21:48:25 <mmorrow> foreign import ccall unsafe "malloc" malloc :: CSize -> IO (Ptr a)
21:48:25 <dibblego> hello EnglishGent
21:48:31 <PhDP> ... but wait a minute there must be a better way, I have a function which return a Double and in the function, I have to divide two integer (taken from other functions), so I really need to do; myFunction n = fromIntegral(anotherFunction args)::Double/fromIntegral(secondFunction args)::Double
21:48:32 <mmorrow> and then use malloc on the next line
21:48:39 <mmorrow> same for *any* C function
21:48:45 <mmorrow> the FFI rules
21:48:47 <pikhq> EnglishGent: Eh, you could already implement it under C++.
21:48:50 <zakwilson> Lisp and Haskell are very different. Most Lisps allow functional programming, but do not require it.
21:49:14 <pikhq> ... To be fair, you could already implement *Haskell* in C++'s type system.
21:49:23 <Saizan_> copumpkin: you can write a view and turn the problem the other way around :D
21:49:31 <pikhq> (though you'd be insane to actually do so)
21:49:32 <copumpkin> Saizan_: how so?
21:49:37 <EnglishGent> pikhq - true, but only becuase template expansion is Turing complete - it's not intended to be used as a TM-complete language though
21:49:49 <EnglishGent> doing many things that way would be agony!
21:49:58 <pikhq> EnglishGent: Intended? I don't care if it's intended to be TC.
21:50:00 <mmorrow> , [$bf|.+[.+]|]
21:50:00 <pikhq> It just is. :)
21:50:02 <lunabot>  luna: No instance for (GHC.Show.Show
21:50:03 <mmorrow> , [$bf|.+[.+]|] ""
21:50:05 <lunabot>  "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK...
21:50:06 <EnglishGent> (if you want *macros* as opposed to parameterised classes I give you Lisp) :)
21:50:11 <mmorrow> so is bf
21:50:28 <EnglishGent> hi moconnor :)
21:50:47 <pikhq> mmorrow: Brainfuck is significantly easier to code in, though.
21:50:54 <mmorrow> pikhq: indeed
21:52:17 <Saizan_> assuming you've data Instruction subarch = Instruction String [Bit], and an enumeration like data Inst = NOP | AND | ..., and a view inst (Instruction "AND" _) = AND; inst (Intruction "NOP" _) = NOP; then you've tranformed the problem of proving the correctness of the prettyprinter into proving the correctness of the parser :)
21:52:18 <EnglishGent> hello jlaire :)
21:52:36 <jlaire> hello EnglishGent
21:52:44 <Sandeep`> hi everyone !
21:53:04 <EnglishGent> hi Sandeep` :)
21:53:16 <copumpkin> EnglishGent: this is a big channel :) you're going to be saying lots of hellos at this rate! :)
21:53:51 <EnglishGent> lol! I'm awake enough to say hello - just :P
21:54:49 <EnglishGent> besides what matters inst the number of members ... but rather the rate at which they enter...
21:55:23 <EnglishGent> (oh gods it's 5AM & my brain is going 'integrating delta members / delta time...'
21:55:24 <EnglishGent> :|
21:55:24 <EnglishGent> :)
21:55:34 <asmips_> Are there haskell libraries for writing inline c?
21:57:18 <Sandeep`> EnglishGent : I'm new to haskelll world. can you help me ?
21:58:53 <EnglishGent> er.. I'm fairly new myself Sandeep` - and still half-asleep.... but I can try
21:58:59 <EnglishGent> what seems to be the problem :)
21:59:04 <Sandeep`> I want to write an image recognition algo . I don't know which language to choose , which libraries to use etc.. I can't ask this kind of question to Google
21:59:35 <Sandeep`> I'm a student who's willing to research on Computer Vision .
22:00:06 <Sandeep`> One of my friend told me that haskell or lisp can be easy to write the algo like image recognition
22:00:29 <EnglishGent> Haskell & Lisp are both languages that tend to be used frequently in AIish problems
22:00:55 <EnglishGent> as they let you work at a much higher level of abstraction than you can in most others
22:01:58 <EnglishGent> what algorithm are you thinking of implementing?
22:02:01 <EnglishGent> :)
22:03:09 <Sandeep`> EnglishGent: I dont' know . I have to make it first ;)
22:03:31 <Sandeep`> but is there any good library that does this currenly ?
22:03:42 <Sandeep`> So I can learn the language and style from that ?
22:04:29 <EnglishGent> I dont think I know the language well enough to comment on libraries :|
22:05:12 <asmips_> Haskell has a relative small community, very little texts published, documentation doesn't appear to be that great, , is less elegant than ruby, not as much control as c++, lisp is functional programming also, what does big advantages Haskell have besides lazy evaluation and static types over these language?
22:07:12 <mmorrow> "is less elegant than ruby"
22:07:14 <mmorrow> lol
22:07:36 <QtPlaty[HireMe]> asmips_: Strong typing with type inference.
22:08:38 * EnglishGent was surprised by that too - why do you think Ruby is more elegant asmips_?
22:08:49 <QtPlaty[HireMe]> Though that said I would love better documentation of the libaries ect.
22:09:21 <asmips_> Ruby is the epitome of elegance
22:09:59 <asmips_> I don't know haskell, but I know that it is quite impossible to be more elegant than ruby
22:10:20 <zebrafinch> asmips_: I thought that too once.
22:10:47 <SamB> asmips_: in that case, you won't mind being kickbanned since there is clearly nothing for you to learn here
22:10:54 <m4k3r> lol
22:11:24 <mriou> is there more than one ByteString type? I'm getting "Couldn't match expected type `Data.ByteString.Lazy.Internal.ByteString' against inferred type `B.ByteString'"
22:11:42 <mriou> B being Data.ByteString.Char8
22:12:11 * EnglishGent needs to do stuff irl - ttyl folks :)
22:13:04 <copumpkin> asmips_: if you don't have an open mind, you won't enjoy it here
22:13:09 <copumpkin> asmips_: might as well return to #ruby :)
22:13:31 <copumpkin> or #ruby-lang :P
22:13:36 <copumpkin> not sure anyone knows the difference
22:13:44 <asmips_> I'm here to learn more about Haskell. I have heard the community is friendly.
22:13:57 <copumpkin> ruby used to be my favorite language, until I found out about haskell
22:14:10 <copumpkin> now it almost feels tedious
22:14:20 <davidL> asmips_: what is your definition of elegance?
22:14:26 <copumpkin> which is saying something, because ruby made most of the other languages I knew feel tedious
22:14:35 <asmips_> I must engage in hard, critical comparison to find out more about the language, so I say this to wonder what makes Haskell elegant
22:14:59 <copumpkin> asmips_: haskell can make abstractions that ruby can only dream of
22:15:11 <copumpkin> let me dig up a good talk by raganwald... have you heard of him?
22:15:25 <davidL> asmips_: referential transparency
22:15:34 <mriou> asmips_ I believe elegance has to be experienced, most of it is lost with explanations
22:17:09 <copumpkin> asmips_: http://www.infoq.com/presentations/braithwaite-rewrite-ruby mentions some aspects of haskell (yet is a cool talk about ruby which is worth watching even if you aren't interested in haskell)
22:17:44 <asmips_> Thanks. So then you think Haskell is preferable to scheme in general for functional program?
22:17:50 <copumpkin> I do
22:18:04 <SamB> but ... which has simpler syntax?
22:18:20 <asmips_> no side effects sounds nice. Then it is very easy to write a program once with minmal debug?
22:18:26 <SamB> (you might think scheme did, hands down, but on the other hand look at all it's numeric formats)
22:18:28 <cjs> How does one load a compiled Foo.hsc module into ghci? I try to ":m +System.Posix.RLimit" and I get "module `System.Posix.RLimit' is not loaded."
22:18:44 <SamB> asmips_: it simplifies debugging immensely, yes
22:18:55 <copumpkin> asmips_: the strong type system will often catch silly errors at compile time which leads to many programs being mostly bugless if they compile
22:19:05 <copumpkin> big classes of runtime crashes can be eliminated
22:19:29 <SamB> asmips_: of course, there's still nothing like debugging-by-print, so we use Debug.Trace to poke a small hole in our purity and see what's going on, often
22:20:05 <asmips_> Thanks guys, I will watch the video, then learn Haskell. One more Q please. From what I read, ghc is the de facto compiler for haskell. Is there any reason to use hugs?
22:20:12 <copumpkin> asmips_: one nice thing about haskell is that so little is "built in"... basic arithmetic operators are defined in regular haskell, you could override them
22:21:10 <cjs> Hugs used to have better error messages than ghc; I don't know if that's true any more.
22:21:45 <copumpkin> asmips_: the video won't really tell you much about haskell beyond telling you why andand is painful in ruby and not in haskell :) but feel free to hang out here and ask more specific questions
22:22:04 <copumpkin> but it's a good talk anyway
22:24:07 <cjs> Weird. If I give ghci the .o file on the command line, it even says, "Loading object (static) ../../../build/ghc/System/Posix/RLimit.o ... done", and yet an attempt to use it says, "not loaded."
22:24:22 <cjs> Ah, I need to ":l System.Posix.RLimit." Weird.
22:45:11 <jmcarthur> the main thing keeping me from more seriously trying out dragonfly bsd is the lack of a working ghc for it :(
22:45:19 <jmcarthur> and, of course, the laziness keeping me from fixing that
22:50:09 <copumpkin> how can I force ghc to "expand" type synonyms in error messages?
22:50:11 <copumpkin> or can I not?
22:57:51 <mmorrow> , (ppDoc . elimSyns) <$> [t|String|]
22:57:55 <lunabot>  [Char]
22:58:25 * mmorrow can't think of anymore tysyns
22:58:47 <ski> `ShowS',`ReadS'
22:58:59 <ski> `Rational'
22:59:12 <copumpkin> IO
22:59:27 <copumpkin> or does that not count as a synonym?
22:59:33 <copumpkin> as it's a type constructor
22:59:39 <ski> @src IO
22:59:40 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
22:59:44 <copumpkin> oh, it's a newtype
22:59:47 <ski> not a synonym in GHC, at least
22:59:50 <copumpkin> which is sort of synonymous :P
22:59:55 <ski> not quite
23:00:05 <copumpkin> I meant synonym-ish :P
23:00:15 <ski> (now, restricted type synonyms like in Hugs would muddy the waters here ..)
23:00:46 <mmorrow> , ppDoc <$> [t|Ap Either Maybe ()|]
23:00:48 <lunabot>  Ap Either Maybe ()
23:00:54 <mmorrow> , (ppDoc . elimSyns) <$> [t|Ap Either Maybe ()|]
23:00:57 <lunabot>  luna: Not in scope: type constructor or class `Identity'
23:01:01 <mmorrow> sigh
23:01:08 <ski> , [k|Ap]
23:01:09 <lunabot>  luna: Not in scope: data constructor `Ap'
23:01:18 <mmorrow> , ''src Ap
23:01:19 <ski> :k Ap
23:01:19 <lunabot>  luna: Not in scope: type variable `src'
23:01:21 <lambdabot> Not in scope: type constructor or class `Ap'
23:01:23 <mmorrow> , src ''Ap
23:01:26 <lunabot>  type Ap p = Lift_ p Identity
23:01:29 <mmorrow> , src ''Lift_
23:01:33 <lunabot>  newtype Lift_ p f g a = Lift_ {runLift_ :: (p (f a) (g a))}
23:01:34 <ski> ah
23:01:44 <mmorrow> (i had to add the underscore because of TH's Lift)
23:02:06 <mmorrow> , 'Ap
23:02:08 <lunabot>  luna: Not in scope: data constructor `Ap'
23:02:11 <mmorrow> , ''Ap
23:02:12 <ski> one should be able to rename names on import (and exprort/reexport)
23:02:13 <lunabot>  Control.Functor.Combinators.Lift.Ap
23:02:33 <copumpkin> category-extras?
23:02:37 <mmorrow> yes'm
23:02:53 <mmorrow> ski: i wanted to keep it as much like the original as possible
23:03:04 <ski> the original being ?
23:03:07 <mmorrow> Lift
23:03:12 <mmorrow> , ''Lift_
23:03:13 <lunabot>  Control.Functor.Combinators.Lift.Lift_
23:03:21 <ski> , '' Lift
23:03:22 <lunabot>  luna: Ambiguous occurrence `Lift'
23:03:28 <mmorrow> s/ //
23:03:32 <ski> , ''Lift
23:03:33 <lunabot>  luna: Ambiguous occurrence `Lift'
23:03:37 <mmorrow> gah
23:03:45 <ski> heh
23:03:48 <mmorrow> , ''Language.Haskell.TH.Syntax.Lift
23:03:49 <lunabot>  luna: Not in scope:
23:03:53 <mmorrow> sigh
23:04:04 <mmorrow> , ''Language.Haskell.TH.Lift
23:04:06 <lunabot>  luna: Not in scope: type constructor or class `Language.Haskell.TH.Lift'
23:04:14 <mmorrow> , src 'lift
23:04:17 <lunabot>  Class op from Lift: lift :: forall t . Lift t => t -> Q Exp
23:04:30 <mmorrow> indirect evidence++
23:04:41 <ski> oh .. a class
23:04:53 <mmorrow> class Lift a where lift :: a -> ExpQ
23:04:59 <mmorrow> , lift (42::Int)
23:05:01 <lunabot>  LitE (IntegerL 42)
23:05:10 <mmorrow> , lift =<< [t|42|]
23:05:12 <lunabot>  luna: Only unit numeric type pattern is valid
23:05:15 <mmorrow> , lift =<< [|42|]
23:05:19 <lunabot>  AppE (ConE LitE) (AppE (ConE IntegerL) (LitE (IntegerL 42)))
23:05:23 <mmorrow> , lift =<< lift =<< [|42|]
23:05:25 <lunabot>  AppE (AppE (ConE AppE) (AppE (ConE ConE) (AppE (AppE (ConE Name) (AppE (V...
23:05:28 <mmorrow> , lift =<< lift =<< lift =<< [|42|]
23:05:30 <lunabot>  AppE (AppE (ConE AppE) (AppE (AppE (ConE AppE) (AppE (ConE ConE) (AppE (A...
23:06:02 <ski> , fix (lift =<<)
23:06:06 <lunabot>  Stack space overflow: current size 8388608 bytes.
23:06:06 <lunabot>  Use `+RTS -Ksize' to increase it.
23:06:14 <mmorrow> , $([|42::Int|])
23:06:16 <lunabot>  42
23:06:19 <mmorrow> , $(lift =<< [|42::Int|])
23:06:21 <lunabot>  SigE (LitE (IntegerL 42)) (ConT GHC.Types.Int)
23:06:52 <mmorrow> , $((fromJust . fromDynamic . eval) "$(lift =<< [|42::Int|])")
23:06:55 <lunabot>  luna: Exception when trying to run compile-time code:
23:07:17 <mmorrow> , $((return . fromJust . fromDynamic . eval) "$(lift =<< [|42::Int|])")
23:07:21 <lunabot>  42
23:07:23 <mmorrow> wooo
23:07:25 <mmorrow> :)
23:07:55 <mmorrow> it'd be increasingly epic to splice more levels of quote back down
23:08:09 <ski> can one express
23:08:10 <mmorrow> (each would require an eval, since you can only splice once)
23:08:33 <mmorrow> yes, but only since lunabot has an eval
23:08:47 <ski>   ((lambda (lambda) `(,lambda ',lambda)) '(lambda (lambda) `(,lambda ',lambda)))
23:08:48 <mmorrow> ghc's TH implem can't do that alone
23:08:50 <ski> in TH ?
23:09:01 * mmorrow parses that
23:09:17 <ski> (possibly renaming the local variable "lambda" to something else)
23:09:29 <mmorrow> what do ` ' , stand for again?
23:09:37 <ski>   ((lambda (u) `(,u ',u)) '(lambda (u) `(,u ',u)))  ; if you will
23:09:46 <mmorrow> ' quote
23:09:46 <ski> "`" is quasi-quote
23:09:53 <ski> "," is unquote
23:09:56 <mmorrow> ah, ok
23:09:56 <ski> "'" is quote
23:10:14 <hackagebot> urlencoded 0.3.0.0 - Generate or process x-www-urlencoded data (JoshHoyt)
23:10:39 <ski> (btw, that's a quine .. also basically the proof of Lb's theorem in Provability logic)
23:10:46 <mmorrow> oh, that's the quine
23:10:53 <mmorrow> yes you can
23:10:57 * mmorrow finds the code
23:12:14 <mmorrow> let x |$<| y = [|$x (return $y)|]
23:12:17 <mmorrow> (\x -> x |$<| (lift =<< x)) [|(\x -> x |$<| (lift =<< x))|]
23:12:24 <mmorrow> is the direct translation
23:13:00 <mmorrow> , let x |$<| y = [|$x (return $y)|] in (\x -> x |$<| (lift =<< x)) [|(\x -> x |$<| (lift =<< x))|]
23:13:02 <lunabot>  luna: No instance for (Language.Haskell.TH.Syntax.Lift
23:13:17 <mmorrow> um, /me checks what that says in ghci
23:13:25 <mmorrow> ski: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2421
23:14:09 <mmorrow> oh
23:15:16 <mmorrow> ah, gah, you can't do that in a single line with (|$<|)
23:15:51 <osfameron> obfu?
23:16:38 <mmorrow> gah, and without that TH won't let you put a quote in a quote without an intervening $(..)
23:16:42 <shu> if there's a bug in the head of darcs, does that warrant a bug report or?
23:16:45 <mmorrow> s/quote/quasiquote/
23:16:49 <shu> just assume it'll be fixed eventually since it's head
23:16:50 <mmorrow> osfameron: quinery
23:17:03 <copumpkin> mmorrow: about the exponential slowness of GHC on big files... did you ever find out what caused it or if it'd been fixed in HEAD?
23:17:27 <osfameron> mmorrow: ah, even worse ;)
23:17:34 <mmorrow> copumpkin: i think it's just the fundamental way that ghc deals with static data, but i'm not sure what that means exactly
23:17:42 <copumpkin> :o
23:17:55 <mmorrow> like, how does gcc represent a 20MB char[] ?
23:18:10 <mmorrow> and how would ghc represent a 20MB [Word8]?
23:18:16 <copumpkin> it just stuffs it in the appropriate segment I guess?
23:18:23 <mmorrow> (i don't know the answer to either of those btw)
23:18:24 <copumpkin> for the gcc one
23:18:29 <mmorrow> i mean during compilation
23:18:39 <mmorrow> the compiler's rep
23:18:54 <copumpkin> why would it be any different from a 5 byte char[] ?
23:19:04 <copumpkin> it doesn't actually need to look inside
23:19:44 <mmorrow> and then there's the parsing ..
23:20:10 <mmorrow> ListE [LitE (CharL 'h'), LitE (CharL 'e'), ....
23:20:21 <copumpkin> it can't be that hard if we can get all of sqlite in a single file though :P
23:20:25 <copumpkin> in c
23:20:30 <mmorrow> gcc: "hello world\0"
23:20:48 <Saizan_> mmorrow: C's grammar is simpler?
23:21:09 <ski> mmorrow : you can't do what in a single line ?
23:21:23 * Saizan_ doesn't know where the blowup occurs
23:21:28 <mmorrow> not that it's simpler, but i think gcc, being in C has a more compact rep
23:21:37 <copumpkin> 106k lines of code in the sqlite single source file :P
23:21:43 <copumpkin> even if more compact
23:21:45 <mmorrow> *and* that gcc also optimizes for huge amounts of static data
23:22:01 <copumpkin> I have difficulty compiling anything in ghc that even approaches 1k lines
23:22:05 <mmorrow> which ghc has a less compact rep, *and* doesn't try to optimize for huge amounts of static data
23:22:16 <ski> @. read run (\u -> concat ["@. read run (",u,") ",show u]) "\\u -> concat [\"@. read run (\",u,\") \",show u]"
23:22:17 <copumpkin> hrm
23:22:18 <lambdabot> Plugin `compose' failed with: Prelude.read: no parse
23:22:34 <mmorrow> copumpkin: i've not had a problem with massive amount of *code* in ghc
23:22:37 * ski wonders why that worked in private, but not in public
23:22:41 <mmorrow> just massive amounts of *data*
23:22:54 <mmorrow> ski: heh, nice
23:22:57 <copumpkin> it doesn't get impossibly slow with code, but it does get significantly slower
23:23:06 <copumpkin> I've found
23:23:25 <copumpkin> but maybe the kind of code I write rubs it the wrong way
23:23:43 <FunctorSalad> is it just a matter of splitting into multiple modules?
23:23:46 <mmorrow> there's a ticket about this, and the feel i got from the comments were that this isn't a priority for ghc, and it won't be pursued
23:23:50 * mmorrow finds it
23:24:14 <copumpkin> FunctorSalad: in general yeah, but I don't like being forced to do things like that, and it'd be nice to be able to put in lots of static data, especially in machine-generated haskell
23:25:03 <mmorrow> FunctorSalad: put /usr/share/dict/words in a [Char] in a single module, and try to compile it
23:27:10 <mmorrow> {-# LANGUAGE TemplateHaskell #-}\nmodule Words where\nimport Language.Haskell.TH.Syntax\nimport Language.Haskell.TH.Lib\ndat = $(litE . stringL =<< runIO (readFile "/usr/share/dict/words"))
23:27:40 <mmorrow> ah, found it
23:27:43 <mmorrow> http://hackage.haskell.org/trac/ghc/ticket/436
23:27:48 <pikhq> I think you may have scared me off with that one.
23:27:52 <mmorrow> "No immediate plans to implement this. "
23:27:59 <mmorrow> (but that was 2007)
23:28:02 <mmorrow> pikhq: heh
23:28:05 <pikhq> ... No, wait. Just boggled my mind slightly.
23:28:32 <mmorrow> pikhq: (all ready for an "$ echo -ne '....' > ")
23:28:37 <mmorrow> ;)
23:30:20 <mmorrow> http://www.haskell.org/pipermail/haskell-cafe/2005-June/010508.html
23:31:45 <copumpkin> hmm, /me looks up how to write a quasiquoter
23:32:06 <mmorrow> copumpkin: http://www.haskell.org/pipermail/haskell-cafe/2008-October/049318.html
23:32:13 <mmorrow> and http://www.haskell.org/pipermail/haskell-cafe/2008-October/049349.html
23:32:54 <mmorrow> copumpkin: there are some example ones in haskell-src-meta (HsHere, SKI, BF, Here, ..)
23:33:03 <copumpkin> ah
23:33:35 <copumpkin> am I allowed to use | inside a quasiquote?
23:33:46 <mmorrow> yes, but you have to escape:
23:33:59 <mmorrow> , [$ty| [$ty| id |] |]
23:34:00 <lunabot>  luna: parse error on input `|]'
23:34:01 <mmorrow> , [$ty| [$ty| id \|] |]
23:34:04 <lunabot>  Doc
23:34:13 <mmorrow> unfortunately
23:34:39 <mmorrow> the most trivial QQ (here) is just
23:34:45 <copumpkin> why didn't the first one need escaping there?
23:34:55 <mmorrow> here = QuasiQuoter (litE . stringL) (litP . stringL)
23:35:02 <mmorrow> the first one failed
23:35:05 <mmorrow> , [$ty| [$ty| id |] |]
23:35:05 <copumpkin> I mean
23:35:06 <lunabot>  luna: parse error on input `|]'
23:35:10 <copumpkin> the $ty| pipe
23:35:19 <copumpkin> , [$ty| [$ty| id \|] |]
23:35:21 <mmorrow> oh, it's not just the pipe, but the "|]"
23:35:22 <lunabot>  Doc
23:35:26 <copumpkin> oh, ok
23:35:30 <copumpkin> I just need single pipes
23:35:44 <mmorrow> ooh, a shell QQ (i've wanted to do this)
23:35:46 <mmorrow> ?
23:35:59 <mmorrow> [$sh| cat /dev/urandom | od | head -42 |]
23:36:09 <mmorrow> would be cool
23:36:11 <copumpkin> :o
23:36:14 <mmorrow> :: IO String
23:36:20 <mmorrow> (or better, IO ByteString)
23:36:43 <mmorrow> it'd be dead simple too, since you don't even have to parse it
23:36:51 <mmorrow> hmm, /me writes it
23:37:21 <ski> , fix $ \foo -> [$ty| foo |]
23:37:24 <lunabot>  luna: Exception when trying to run compile-time code:
23:37:37 <mmorrow> , let x = 42 in [$ty| x |]
23:37:41 <lunabot>  Expr
23:37:41 <ski> (no cyclic expressions ?)
23:38:09 <mmorrow> no, hmm but there's no reason why `ty| couldn't get fed the entire expression it occurs in
23:38:21 <mmorrow> since this is all getting `eval'ed by the bot
23:38:38 <mmorrow> (so , eval "42" is really two-levels of eval)
23:39:11 <mmorrow> , (fromJust . fromDynamic . fromJust . fromDynamic) (eval "eval \"42\"") :: Integer
23:39:14 <lunabot>  42
23:39:22 <mmorrow> eval can see itself though
23:39:37 <ski> (mmorrow : for a shell QQ, you should be able to splice as well as splice-quote strings, yes ?)
23:40:06 <mmorrow> ah, true. i've already got a "HsHere" one, i could just copy/paste that code
23:40:28 <mmorrow> , let xs = [0..4] in [$here| [0..4] in $(xs) and $([0..4]) |]
23:40:31 <lunabot>  " [0..4] in [0,1,2,3,4] and [0,1,2,3,4] "
23:40:42 * ski has no idea what `here' above does ..
23:40:54 <ski> hm
23:41:18 <mmorrow> http://hackage.haskell.org/packages/archive/haskell-src-meta/0.0.4/doc/html/src/Language-Haskell-Meta-QQ-HsHere.html
23:41:20 <Gracenotes> a .. template comprehension :X
23:41:33 <mmorrow> gah, i just realized that file has a typo..
23:41:41 * mmorrow reuploads
23:41:57 <mmorrow> typo is:
23:42:00 <mmorrow> go n acc ('(':s)     = go (n+1) ('[':acc) s
23:42:05 <mmorrow> and the next line
23:42:13 <mmorrow> s/[/(/
23:43:28 <brian6> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6233  i can't get a parMap to actually use my other cores. i think it may be because i don't know how to make an NFData instance for CReal.
23:43:38 <mmorrow> err, s/in/is/
23:43:47 <mmorrow> , let xs = [0..4] in [$here| [0..4] is $(xs) and $([0..4]) ahgfdasghjgagsjsg |]
23:43:50 <lunabot>  " [0..4] is [0,1,2,3,4] and [0,1,2,3,4] ahgfdasghjgagsjsg "
23:44:06 <mmorrow> (the `in' wasn't interpreted)
23:44:40 <copumpkin> @hoogle litE
23:44:41 <ski> , $((return . ($ "ef") . fromJust . fromDynamic . eval) "$(lift =<< [| \xs -> [$here| ab $(reverse xs) cd \|] |])")
23:44:41 <lambdabot> Language.Haskell.TH litE :: Lit -> ExpQ
23:44:41 <lambdabot> Language.Haskell.TH.Lib litE :: Lit -> ExpQ
23:44:41 <lambdabot> Language.Haskell.TH LitE :: Lit -> Exp
23:44:42 <lunabot>  luna: lexical error in string/character literal at character 's'
23:44:53 <ski> hm, right
23:44:57 <ski> , $((return . ($ "ef") . fromJust . fromDynamic . eval) "$(lift =<< [| \\xs -> [$here| ab $(reverse xs) cd \|] |])")
23:44:58 <lunabot>  luna: lexical error in string/character literal at character ']'
23:45:17 <Saizan_> brian6: try     in (b, e, q)
23:45:23 <mmorrow> heh, all the \\\\\\ start to get epic
23:45:39 <copumpkin> mmorrow: what does the here qq do?
23:45:42 * ski can't keep the different levels quite straight, here ..
23:45:51 <copumpkin> oh
23:45:52 <copumpkin> string literal
23:46:02 <Saizan_> brian6: "in (((,,) $! b) $! e) $! q"
23:46:14 <brian6> Saizan_: ah, ok. trying.
23:46:31 * ski wishes for `infixl' `$!' ..
23:46:31 <mmorrow> ski: it also doesn't help that the only error message is "error while running compile-time code" either
23:46:58 <ski> it would be nice if it could type-check meta-code *before* expanding it
23:47:08 <Saizan_> brian6: it was only evaluating the tuple constructor in your code
23:48:14 <mmorrow> , eval "here"
23:48:17 <lunabot>  <<Language.Haskell.TH.Quote.QuasiQuoter>>
23:48:20 <ski> (mmorrow : btw, the composition in `herePatQ' is indented funny :)
23:48:25 <brian6> Saizan_: hmm. i'm still not seeing multiple core action. hoping it's something like you're saying, though. i'll play around.
23:48:29 <mmorrow> ski: heh
23:49:00 <mmorrow> ski: i like stair-stepping (.) chains :)
23:49:22 <ski> (mmorrow : if you managed to see what i attempted doing above with `here', maybe you can figure out if it could be made to work ..)
23:49:28 * ski would have written
23:49:58 * mmorrow is already messing with it ;)
23:50:00 <copumpkin> can a QQ expand to more than one expression?
23:50:03 <ski>   let p = parsePat
23:50:05 <ski>         . pprint
23:50:08 <ski>         . cleanNames
23:50:09 <ski>         $ e
23:50:12 <copumpkin> I'd guess not
23:50:19 <copumpkin> maybe I should just curry/uncurry it
23:50:19 <mmorrow> copumpkin: what do you mean?
23:50:23 <ski> (or possibly all on one line, in this case)
23:50:40 <copumpkin> (+) [$whoops| 5 6 |] ===> 11
23:50:52 <Saizan_> brian6: maybe you do need NFData for CReal, but with that repr and without the constructor exported it's hard to do anything useful
23:51:11 <ski> maybe a better question is if a `QQ' might expand to more than one declaration ..
23:51:20 <copumpkin> maybe that's what I meant :)
23:51:25 <mmorrow> copumpkin: [$whoops| 5 6 |] :: ((a -> a -> a) -> a) ;)
23:51:52 <brian6> Saizan_: is there something to replace CReal with? i'm not sure why i'm only able to get reasonable floating point answers when i use it.
23:51:58 <mmorrow> unfortunately QQs only can expand to expressions and patterns atm
23:51:59 <copumpkin> mmorrow: hah, can I stick it in backticks ?
23:52:02 <copumpkin> ah
23:52:18 * ski thought they could expand to declarations, too
23:52:26 <mmorrow> regular TH can though
23:52:30 <ski> oh
23:52:36 * ski was not aware of a difference
23:52:36 <mmorrow> at top-level in a module, you can do
23:52:37 <Saizan_> brian6: CReal is not floating point, that's why :)
23:52:45 <mmorrow> $(.... :: Q [Dec])
23:52:49 <brian6> Saizan_: sorry, i mean arbitrary precision or whatever.
23:52:50 * ski doesn't really know very much about TH .. does it show ?
23:53:09 <mmorrow> ski: there are instances for Show and Lift in haskell-src-meta
23:53:20 <ski> instances of those for what ?
23:53:27 <mmorrow> ski: (without those Lift instances, you can do reify in ghci)
23:53:28 <copumpkin> is TH just a QQ that parses haskell?
23:53:29 <Saizan_> brian6: i don't know, anyhow
23:53:32 <mmorrow> ski: all of the TH AST
23:53:36 <brian6> Saizan_: ok. thanks.
23:53:48 <ski> (which `refiy' ?)
23:53:49 <mmorrow> ski: (well, Show for ExpQ, (Q [Dec]), *Q)
23:53:57 <mmorrow> , [$ty| reify |]
23:54:00 <ski> (the delimited continuation-based `reify' ?)
23:54:00 <lunabot>  Name -> Q Info
23:54:08 <mmorrow> , src ''Info
23:54:11 <lunabot>  data Info = ClassI Dec
23:54:11 <lunabot>            | ClassOpI Name Type Name Fixity
23:54:11 <lunabot>            | TyConI Dec
23:54:13 <mmorrow> ..
23:54:16 <Saizan_> copumpkin: more or less, e.g. you can't use QQs for declarations
23:54:23 <FunctorSalad> , moar
23:54:23 <mmorrow> , $(lift =<< reify ''Maybe)
23:54:24 <lunabot>  luna: Not in scope: `moar'
23:54:25 <lunabot>  TyConI (DataD [] Data.Maybe.Maybe [a_1627417407] [NormalC Data.Maybe.Noth...
23:54:29 <mmorrow> , ppDoc $(lift =<< reify ''Maybe)
23:54:31 <lunabot>  data Maybe a_0 = Nothing | Just a_0
23:54:37 <mmorrow> , ppDoc $(lift =<< reify ''Doc)
23:54:39 <lunabot>  data Doc = Empty
23:54:39 <lunabot>           | NilAbove Doc
23:54:39 <lunabot>           | TextBeside TextDetails !Int Doc
23:54:41 <mmorrow> ...
23:54:50 <Saizan_> copumpkin: and the TH quoted code is typechecked before being transformed into an AST
23:54:57 <mmorrow> so you use reify to get info about whatever you want
23:55:00 <Saizan_> s/an/the/
23:55:43 * ski wonders why that is called `reify'
23:55:49 <mmorrow> for instance, you can start with a Name, reify it, if it's a datatype, then find the transitive closure of  all reachable types from it
23:56:14 <copumpkin> can I run a QQ inside TH? :P
23:56:20 <mmorrow> here's the SCC of `Exp' from TH AST with that method http://moonpatio.com/graphs/Exp_SCC.png
23:56:43 <mmorrow> (and here's all reachable http://moonpatio.com/graphs/Exp.png)
23:56:49 <mmorrow> copumpkin: no :(
23:56:54 <copumpkin> aw
23:57:28 <copumpkin> anyway, bedtime :)
23:57:29 <copumpkin> ciao
23:57:32 <mmorrow> seeya
23:58:00 <FunctorSalad> btw is there a way in vacuum to make the graph more compact, e.g. collapse strings to a single node?
23:58:18 <Peaker> @hoogle reify
23:58:19 <lambdabot> package reify
23:58:19 <lambdabot> Language.Haskell.TH reify :: Name -> Q Info
23:58:19 <lambdabot> Language.Haskell.TH.Syntax reify :: Name -> Q Info
23:59:06 <mmorrow> ski: (here's the code that made those graphs http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1149#a1149)
