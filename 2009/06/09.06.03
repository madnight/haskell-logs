00:00:02 <MyCatVerbs> Murr. Puny humans! Whatever happened to good old fashioned quivering mortal patience?
00:01:19 <sjanssen> solrize: Ubuntu has a meta-package you should install before trying to build any piece of software
00:01:28 <MyCatVerbs> build-essential, IIRC.
00:01:34 <solrize> sjanssen, hmm, what's that?
00:01:36 <MyCatVerbs> apt-get build-essential, even.
00:01:39 <solrize> oh i have that i'm sure
00:01:45 <sjanssen> solrize: yep, build-essential
00:01:47 <MyCatVerbs> Double check. :)
00:01:57 <sjanssen> solrize: if Unix couldn't find headers, I bet you don't
00:02:09 <solrize> hmm, installing
00:02:48 <solrize> i wasn't missing headers, i just get a lot of compiler warnings about allow-undecidable-instances and things like that
00:03:01 <solrize> looks like i didn't have build-essential on this box, who'd a thunk it
00:03:18 <solrize> platform make still hits same error, configuring editline failed
00:03:27 <solrize> trying make -k
00:03:38 <sjanssen> solrize: got a link to the build output?
00:03:46 <MyCatVerbs> The allow-undecidable-instances warnings are mostly because the names of the options that turn language extensions on have changed. They're harmless.
00:03:49 <MyCatVerbs> mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm
00:03:52 <MyCatVerbs> mmmmmmmmmmmmmmm
00:04:00 <solrize> sjanssen want me to save it and paste it?
00:04:11 <MyCatVerbs> Agh. Sorry, m key sticking. Hitting control didn't do what I wanted at all. >>
00:04:17 <sjanssen> solrize: sure
00:04:24 <sjanssen> solrize: you didn't do that for your bug report?
00:04:26 <solrize> re-running
00:04:33 <solrize> sjanssen, no i just typed in a summary
00:04:41 <amckinley> hey, could someone help me with a weird parsec problem?
00:04:46 <amckinley> heres the code: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5524
00:04:57 <amckinley> and heres an example file: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5523
00:05:26 <amckinley> the problem is that i throw a parse error at line 12 of that input
00:05:31 <pumpkin> we need the world's most gratuitous feature on haddock: each function should have a little plot next to it of the time elapsed on quickcheck tests vs. the test size
00:05:31 <solrize> hmm, this is weird, now it crashes because it wants to run happy and can't
00:05:44 <pumpkin> for "at a glance" complexity :P
00:06:01 <pumpkin> with adaptive size changing
00:06:10 <amckinley> which i dont understand: i thought that the failure of the parser would cause the many block that im calling nextToken in to end
00:06:25 <amckinley> instead of having that failure bubble up to me
00:07:37 <MyCatVerbs> amckinley: What's the error message that Parsec gives you, please?
00:07:38 <dons> solrize: re. distros, we will just state that the distro "doesn't support haskell" if they don't do it right.
00:07:51 <amckinley> MyCatVerbs: Left (line 12, column 41):
00:07:51 <amckinley> unexpected "\n"
00:07:52 <amckinley> expecting ";", letter or digit, "@", "-", ".", "$", "(" or ")"
00:09:15 <amckinley> which makes sense: records in this file are newline-delimited. finding a newline unexpectedly means you've reached the end of the record
00:09:28 <MyCatVerbs> Thanks. That is kind of strange.
00:09:29 <MyCatVerbs> > "                                86400 )         ; whatever
00:09:30 <lambdabot>   <no location info>:
00:09:31 <lambdabot>      lexical error in string/character literal at end o...
00:09:32 <solrize>  dons, for something as widespread as ubuntu, that's not so hot as advocacy
00:09:40 <MyCatVerbs> Agh, dammit, got the newline too. Sorry.
00:09:40 <solrize> anyway i just attached the typescript
00:09:45 <solrize> http://trac.haskell.org/haskell-platform/attachment/ticket/56/typescript
00:09:48 <MyCatVerbs> > drop 40 "                                86400 )         ; whatever\n"
00:09:49 <lambdabot>   "        ; whatever\n"
00:10:07 <sjanssen> dons: Debian and Ubuntu are listed in the supported platforms, what does that mean?
00:10:08 <tibbe> where exactly is MutableArray# defined?
00:10:19 <sjanssen> tibbe: it's a primitive
00:10:26 <MyCatVerbs> tibbe: OH DEAR GODS NO. It's in GHC.Base somewhere.
00:10:27 <ksf> somewhere in the GHC.* hierarchy
00:10:51 <sjanssen> tibbe: the preferred import for that stuff is GHC.Exts
00:10:55 <amckinley> MyCatVerbs: the really weird thing is that it works in the "normal" case, where normal means all the pieces of the record fit on a single line
00:11:04 <tibbe> sjanssen: how can I find out which functions it supports?
00:11:13 <pumpkin> browse GHC.Prim
00:11:20 <MyCatVerbs> amckinley: what's confusing me is that it apparently got the column number wrong. :)
00:11:22 <solrize> i tried erasing the directory and re-unpacking the tarball and it's getting much further this time
00:11:34 <amckinley> MyCatVerbs: and if i add a token after the rparen, everything works
00:11:42 <Baughn> tibbe: Why do you *want* it?
00:11:49 <sjanssen> tibbe: this is one of those "if you have to ask, it isn't for you" things, for the most part
00:11:50 <amckinley> MyCatVerbs: whoops, that was my fault
00:11:55 <tibbe> Baughn: out of curiosity
00:11:59 <amckinley> Left (line 12, column 59):
00:12:00 <amckinley> unexpected "\n"
00:12:00 <amckinley> expecting ";", letter or digit, "@", "-", ".", "$", "(" or ")"
00:12:02 <ksf> amckinley, tokenise before you parse?
00:12:04 <tibbe> sjanssen: heh
00:12:10 <Baughn> tibbe: It killed the cat. Are you feline?
00:12:15 <ksf> usually straightens up the parser a fair bit.
00:12:21 <amckinley> ksf: this is my attempt at tokenizing :)
00:12:25 <sjanssen> tibbe: or perhaps "for Simons only"
00:12:34 * pumpkin feeds the cat
00:12:36 <pumpkin> tibbe: http://www.haskell.org/ghc/docs/latest/html/libraries/ghc-prim/GHC-Prim.html#t%3AMutableArray%23
00:12:42 <pumpkin> tibbe: you probably don't want it though
00:12:50 <solrize> ok, it crashes at editline again
00:12:59 <amckinley> MyCatVerbs: sorry about that; i fiddled with the sample file after i grabbed the error message
00:13:57 <pumpkin> tibbe: you'll notice the source links don't work :P
00:14:11 <solrize> http://trac.haskell.org/haskell-platform/attachment/ticket/56/typescript.2  new typescript added
00:14:13 <amckinley> MyCatVerbs: and if you remove the parenthesized record (lines 7-12), everything works fine as well
00:14:45 <tibbe> so I have a function ensureCapacity :: Array a -> Int -> IO (Array a) but I'm considering changing it to ensureCapacity :: Array a -> Int -> IO () but I wanted to check how other mutable arrays work in GHC
00:14:49 <MyCatVerbs> amckinley: er. Your rule for (RToken,True) is immediately recursing on nextToken after reading the close bracket.
00:15:10 <sjanssen> tibbe: other arrays are fixed size
00:15:28 <amckinley> MyCatVerbs: is that a problem? the paren isnt the token, its just syntax that im trying to get rid of
00:15:41 <MyCatVerbs> amckinley: but it'll never advance over a newline?
00:15:41 <pumpkin> tibbe: you'd have to make your own growable array on top of this
00:15:42 <tibbe> sjanssen: since ensureCapacity invalidates the original array I thought I would stick an IORef in there and update it in place instead
00:15:53 <tibbe> pumpkin: that's what I'm trying to do :)
00:15:58 <pumpkin> ah
00:16:22 <pumpkin> might as well use a MutVar# while you're down there :P
00:16:26 <amckinley> MyCatVerbs: right. but the normal case relies on the same behavior and works fine. is there something magic about the recursion?
00:17:21 <MyCatVerbs> amckinley: it's looking for another token after the right bracket, and there aren't any more tokens on the same line.
00:17:41 <MyCatVerbs> amckinley: and the nextToken parser can't advance over the line boundary. So it has to fail.
00:18:09 <amckinley> MyCatVerbs: yes. but why doesnt that break the "all items on the same line" case in the same way?
00:18:53 <amckinley> on line 3, after nextToken returns "bar", it cleans up the line so that the next call to nextToken starts at the newline
00:19:29 <amckinley> and then it presumably fails, which ends the many1 combinator at line 29
00:19:31 <pumpkin> tibbe: also, if you're going to do it, you might as well bind to memcpy so you can copy your array to the new location as quickly as possible when you grow
00:19:40 <MyCatVerbs> amckinley: when yo uput everything on one line, are you putting the "bang bash" at the end there on the same line too?
00:19:42 <pumpkin> (do an FFI binding to it, that is)
00:20:00 <MyCatVerbs> *you put, argh.
00:20:10 <amckinley> MyCatVerbs: no
00:20:42 <tibbe> pumpkin: realloc already does that
00:20:58 <tibbe> pumpkin: given that reallocArray actually calls realloc
00:21:19 <amckinley> the whole point of the parens is to tell the parser "discard newlines until you see a closing paren"
00:21:30 <amckinley> because normally dns zone files are completely line-oriented
00:21:38 <MyCatVerbs> amckinley: you didn't perchance have a right paren on a line by itself at any point? Because if I'm reading this right, that case should always break.
00:21:39 <sjanssen> pumpkin: there's already a binding to memcpy, copyArray IIRC
00:21:50 <pumpkin> sjanssen: ah, I didn't know about that, cool :)
00:22:23 <amckinley> MyCatVerbs: no, why?
00:22:56 <MyCatVerbs> amckinley: because (RParen,True) will try to get another token out, and end up failing.
00:23:31 <MyCatVerbs> Ah, just thought. I'm not sure what Parsec does in the case of failure in a choice branch where the state has been changed.
00:23:33 <amckinley> but how is that different from the regular case trying to get a token out and failing?
00:23:38 <pumpkin> tibbe: wait, so you'll be using memory outside the GC's jurisdiction?
00:23:41 <amckinley> where the STATE has changed!!!!!
00:23:43 <amckinley> thats IT!
00:23:52 <amckinley> :D
00:24:01 <tibbe> pumpkin: yes I will pass it to C
00:24:07 <pumpkin> ah, ok :)
00:24:27 <MyCatVerbs> amckinley: I have no idea whether it is or not. I'd have to ask dcoutts, myself. I don't know what behavoir happens in crazytown o'er thar.
00:24:31 <amckinley> i bet parsec is failing hard because ive changed the state without successfully exiting the parser
00:25:03 <MyCatVerbs> amckinley: anyways. You probably do *not* want LParen and RParen to recurse on nextToken.
00:25:36 <MyCatVerbs> amckinley: instead, just return a meaningless symbol which the consuming parser will filter out afterwards and let the outer many1 handle getting the next token.
00:25:38 <amckinley> MyCatVerbs: im open to suggestions :) i thought i was being clever by putting the paren status in the parser state
00:26:44 <MyCatVerbs> It's pretty rare, AFAIK, to use the parser state for nesting like that. More common is to have different Parsec actions for different parsing states.
00:27:23 <amckinley> MyCatVerbs: but if the parser just returns a bogus DnsToken instead of failing, how do i ever exit the many1?
00:27:43 <amckinley> oh wait
00:27:52 <MyCatVerbs> amckinley: it doens't emit a bogus DnsToken on failing, it emits a bogus DnsToken on seeing a paren.
00:27:57 <amckinley> right :)
00:28:05 <MyCatVerbs> Then you just filter (/=Bogus) the result.
00:28:10 <amckinley> right right right
00:28:15 <amckinley> one sec, let me try that
00:28:23 <pumpkin> tibbe: you could also use a PinnedByteArray and let the GC manage it
00:28:52 <MyCatVerbs> Haaaaaouw much allocation are you actually doing, tibbe?
00:28:57 <tibbe> pumpkin: there are so many options! I wish there was a good guide for all the tradeoffs
00:29:06 <tibbe> MyCatVerbs: not that much
00:29:12 * MyCatVerbs facepalms.
00:29:44 <tibbe> MyCatVerbs: avoiding indirections is more important than having slightly slower allocations in my case
00:29:54 <MyCatVerbs> If you aren't doing much then it will not matter much if you use a suboptimal allocation method.
00:30:45 <pumpkin> but if you're going to make a library, you might as well do it cheaply
00:30:50 <tibbe> MyCatVerbs: sure, but if there are two equal choices but one is faster I will go with that
00:30:54 <pumpkin> since you don't get much benefit doing it the other way
00:31:11 <MyCatVerbs> In particular, I would advise you to stick to Foreign.* for things that need to talk to C, because for starters they're well supported by all of the current crop of Haskell compilers.
00:31:12 <tibbe> this is an event loop library that I'd like to replace GHC's event loop so it better be fast
00:31:26 <tibbe> MyCatVerbs: I'm using a plain Ptr now
00:31:39 <tibbe> MyCatVerbs: since it supports realloc
00:31:39 <fynn> Anyone here used qtHaskell?
00:31:54 <fynn> Trying to get a sense of how mature it is.
00:31:54 <amckinley> MyCatVerbs: it works! :D
00:31:58 <tibbe> MyCatVerbs: I could change to ForeignPtr and FFI import memcpy
00:32:12 <MyCatVerbs> amckinley: thank goodness. I was worried for a minute there.
00:32:23 <pumpkin> sjanssen: I can't find the fast array copy op
00:32:43 <MyCatVerbs> tibbe: y'know what? Profile, benchmark.
00:32:52 <tibbe> MyCatVerbs: Sure
00:32:55 <amckinley> MyCatVerbs: thank you so much :) on further reflection, the state changing + recursion was definitely what was biting me
00:33:04 <tibbe> MyCatVerbs: although these things are a bit harder to benchmark
00:33:15 <hackagebot> serial 0.1
00:33:24 <tibbe> MyCatVerbs: and you can easily end up with something where no part is really slow but together you get a factor of 2-3 slowdown
00:33:42 <MyCatVerbs> tibbe: just use bare Ptrs (no indirection whatsoever yo, they'll practically always get put into registers, they'll get all but buggerin' well strength-reduced.)
00:33:47 <fynn> I wish the Haskell logo was more awesome :(
00:33:49 <MyCatVerbs> Er, for the moment.
00:34:05 <tibbe> MyCatVerbs: I
00:34:08 <MyCatVerbs> fynn: trust me that it is an enormous improvement on the previous one. That one was just confusing.
00:34:10 <tibbe> MyCatVerbs: I'll do that
00:34:15 <amckinley> MyCatVerbs: while you're looking at it, is there anything you see thats stylistically weird or just plain bad? this is my first project in haskell, so any feedback you could give would be helpful
00:34:22 <sjanssen> pumpkin: maybe called copyBytes?
00:34:25 <sjanssen> @hoogle copyBytes
00:34:26 <lambdabot> Foreign.Marshal.Utils copyBytes :: Ptr a -> Ptr a -> Int -> IO ()
00:34:34 <sjanssen> pumpkin: that's the ticket
00:34:55 <fynn> MyCatVerbs: the old one was a magical lambda, the new one is an airline logo :/
00:35:03 <MyCatVerbs> amckinley: nothing interesting. I haven't written all that much Haskell code under fire though, so eh.
00:35:42 <MyCatVerbs> fynn: y'know what? I bet if you took the airline haskellogo and struck transparent lines through it (like IBM's logo), it'd look rawkin'.
00:35:47 <sjanssen> MyCatVerbs, tibbe: ForeignPtr really doesn't have much overhead, and will help correctness and memory safety very much
00:36:12 <tibbe> sjanssen: you're probably right
00:36:37 <tibbe> sjanssen: I'm still unsure if I should use IORefs or not
00:36:54 <tibbe> sjanssen: for ensureCapacity
00:37:01 <MyCatVerbs> tibbe: do. They're fine, and you need to if you're re-allocating.
00:37:09 <sjanssen> tibbe: now IORefs do have some overhead
00:37:23 <tibbe> sjanssen: that's what I'm afraid of
00:37:32 <tibbe> sjanssen: most of the time I won't realloc
00:37:38 <MyCatVerbs> IORefs are boxed. If you're desperate, use Ptrs to Ptrs.
00:37:41 <sjanssen> tibbe: perhaps you can use the arrays in a more persistent fashion?
00:37:44 <tibbe> sjanssen: but I will read the content of the Ptr often
00:38:10 <tibbe> sjanssen: it's for passing to kqueue which will fill it with event structs
00:38:29 <sjanssen> tibbe: will multiple threads/calling contexts need to call it?
00:38:45 <tibbe> sjanssen: potentially yes
00:39:01 <amckinley> MyCatVerbs: good deal. thanks so much; have a great night! :)
00:39:03 <tibbe> sjanssen: since other threads might need to add events they want to monitor
00:39:13 <solrize> any idea how to get editline out of the platform dependencies?  i removed it from the package list and the rest of the platform built ok
00:39:19 <sjanssen> tibbe: okay, I'd go with type Array = IORef ArrayContents; data ArrayContents = AC ForeignPtr Int, etc.
00:39:26 <solrize> but now the build won't compelte because editline is a dependency and is missing.
00:39:30 <tibbe> sjanssen: ok
00:39:37 <MyCatVerbs> amckinley: Thank you. Have a good morning. :)
00:39:49 <sjanssen> tibbe: because the pointer is going to change too when you fill capacity
00:40:03 <tibbe> sjanssen: yes
00:40:30 <sjanssen> tibbe: you need to think about race conditions too
00:40:54 <sjanssen> tibbe: so that IORef should probably be an MVar if you're really going to use it concurrently
00:40:57 <tibbe> sjanssen: yes
00:41:06 <tibbe> sjanssen: I can atomicallyModifyIORef
00:42:21 <sjanssen> tibbe: that only takes pure functions, which probably isn't going to cut it
00:42:30 <tibbe> sjanssen: ah right
00:47:10 <MyCatVerbs> Probably you need to strictly serialise access to the structs you're passing around anyway, to stop threads from accidentally trampling on each other (iff there is the possibility of two different threads trying to modify the same structure at once.)
00:48:18 <tibbe> yes
00:48:52 <tibbe> what I'm trying to do is similar to what libev does with the difference that GHC uses its event loop differently
00:49:23 <MyCatVerbs> GHC's current IO scheme (in the threaded RTS) has all IO handled by a single thread. So you could just keep the kqueue entries in an ordinary IORef, or even as parameters passed to a little infinitely looping function - provided no more than one thread can see them, you avoid concurrency issues pretty much by definition.
00:49:50 <MyCatVerbs> (If you're planning to have your kqueue implementation replace the current threaded IO implementation, I mean.)
00:50:10 <MyCatVerbs> Er, all IO on Handles, I mean! Should be as specific as possible with this stuff. :3
00:51:06 <MyCatVerbs> The non-threaded RTS just has a syscall to select() somewhere in its C code, IIRC. Replacing that should not in theory be insurmountable. :)
00:51:44 <tibbe> MyCatVerbs: the current (threaded) event loop have a few problems I need to solve
00:51:52 <tibbe> MyCatVerbs: it's O(watched events)
00:52:21 <tibbe> MyCatVerbs: because it scans a list of all pending events and compares it to what's returned by select
00:52:43 <tibbe> MyCatVerbs: epoll, kqueue, et al are O(1) in the number of pending events
00:52:51 <tibbe> MyCatVerbs: I of course want to keep it that way
00:52:52 <MyCatVerbs> Heh. That's not O(watched events), that's O(watched events + open descriptors).
00:53:14 <lindzeyn> It's been a while since I've worked with Haskell.  I want to make a new type that is a natural number in the set [0..11].  I tried this: data Pitch = 0 | ... | 11 , but to no avail
00:53:52 <tibbe> MyCatVerbs: there is some concurrent access as Read/Write constructors holding an MVar are enqueued in a global list
00:54:13 <MyCatVerbs> Yes, I'm familiar with select(2)'s issues. It baffles me that POSIX.1-2001 defined poll(2) instead of a syscall which could give O(1) y
00:54:18 <MyCatVerbs> s/y/behavoir.
00:54:32 <tibbe> MyCatVerbs: my hope is to replace that scheme with every thread registering a closure that unblocks the MVar and put that in the void* user data section of the C struct
00:55:04 <tibbe> MyCatVerbs: so once e.g. kqueue returns with the array of ready events we can immediately get to the callbacks to unlock the MVars
00:55:06 <MyCatVerbs> lindzeyn: those are getting parsed as numbers. Data constructors have to begin with an uppercase letter.
00:55:30 <MyCatVerbs> tibbe: out of curiosity, why kqueue specifically rather than libevent?
00:55:48 <tibbe> MyCatVerbs: libevent would have us make callbacks from C
00:55:57 <tibbe> MyCatVerbs: which is apparently rather slow
00:55:59 <lindzeyn> MyCatVerbs:  How do I create a type that is synonymous with the natural numbers % 12?
00:56:08 <tibbe> MyCatVerbs: this way we can make the callbacks from Haskell
00:56:15 <tibbe> MyCatVerbs: which would hopefully be faster
00:57:10 <doserj> lindzeyn: data Pitch = Pitch0 | Pitch1 | ... | Pitch11 would work, you can also make a custom Num instance, if you really want.
00:57:16 <MyCatVerbs> Yeah, letting C functions call IO actions as callbacks requires generating trampolines, which can be dirt slow.
00:57:37 <tibbe> MyCatVerbs: so that's why
00:58:06 <MyCatVerbs> lindzeyn: you either define a type with twelve constructors, like doserj says, or you could wrap an existing type in a newtype and give a new Num instance for it.
00:58:16 <lindzeyn> Thanks
00:59:05 <MyCatVerbs> e.g. newtype ModTwelve = MT Int; instance (Num ModTwelve) where { ... }
00:59:55 <MyCatVerbs> abs = id; signum = 1; a + b = (a + b) `mod` 12, etc.
01:00:05 <MyCatVerbs> Er, signum = const 1.
01:00:38 <MyCatVerbs> Usually you wouldn't expose the constructor MT directly, but instead give a smart constructor, like: mkMT i = MT (i `mod` 12)
01:00:54 <fynn> I have an infinite list; how do I get its 61st element?
01:01:07 <MyCatVerbs> fynn: infiniteList !! 61
01:01:09 <Twey> fynn: list !! 61
01:01:23 <Twey> However, doing so probably indicates that your design is wrong
01:01:45 <MyCatVerbs> Er, !! 60, even, if you count element zero as the first. :)
01:01:45 <fynn> thanks
01:01:46 <fynn> Twey: why is that?
01:01:47 <Twey> Lists aren't really designed for random access.  Perhaps some kind of lazy map?
01:02:02 <fynn> Twey: it's for a project euler question :)
01:02:08 <Twey> Oh, okay then
01:02:10 <Twey> Do what you like :-P
01:02:14 <fynn> I'm generating an infinite list of primes, and I need the Nth
01:02:24 <Twey> Okay.
01:02:25 <MyCatVerbs> (!! 0) = head; (!! 1) = head . tail; (!! 2) = head . tail . tail; -- etc.
01:02:33 <Twey> That's a fair usage.
01:03:37 <mxc> on the subject of infinite lists, does sequence :: [m a] -> m [a] for the evaluation of the spine of the list?  as in, if I have a function readMsg :: IO String and a processing function proc :: String -> IO (), could I run something like mapM_ proc $ sequence $ repeat readMsg to process every message that gets read?
01:04:16 <MyCatVerbs> mxc: sequence_ and sequence force the list spine as they go, but no sooner.
01:05:15 <MyCatVerbs> e.g. sequence_ (cycle $ putStrLn "BASIC is not my favourite programming language.") -- works just fine, and is a pretty good antidote to that "10 PRINT YEAH AWESOME \n 20 GOTO 10" crap.
01:06:00 <mxc> :t cycle
01:06:01 <MyCatVerbs> Personally I prefer fix ((putStrLn "BASIC is not my favourite programming language.") >>) -- for my insulting needs, however.
01:06:01 <lambdabot> forall a. [a] -> [a]
01:06:11 <MyCatVerbs> Oh, repeat, not cycle. Sorry.
01:06:16 <MyCatVerbs> mxc: thanks.
01:06:20 <dmwit> forever (putStrLn ...)?
01:06:23 <mxc> no worries
01:06:49 <MyCatVerbs> dmwit: no. The point is that we're being deliberately byzantine, yo.
01:07:01 <dmwit> Oh, well!
01:07:26 <dmwit> fix ((mapM_ putChar "BASIC is not my language.\n") >>)
01:08:16 <mxc> well, forever works instead of mapM, but if you need to thread a state with foldM, it wouldn't, rihgt?
01:08:24 <MyCatVerbs> :t \x -> let knot = fmap ($knot) in knot x
01:08:25 <lambdabot>     Occurs check: cannot construct the infinite type:
01:08:25 <lambdabot>       a = f (a -> b) -> f b
01:08:25 <lambdabot>     Probable cause: `fmap' is applied to too few arguments
01:09:26 <dmwit> :t \x -> let knot = fmap ($knot) x in knot x
01:09:27 <lambdabot>     Occurs check: cannot construct the infinite type:
01:09:27 <lambdabot>       f = (->) (f (f b -> b))
01:09:27 <lambdabot>     Probable cause: `knot' is applied to too many arguments
01:09:47 <dmwit> hehe
01:09:53 <dmwit> :t \x -> let knot = fmap ($knot) x in knot
01:09:54 <lambdabot> forall b (f :: * -> *). (Functor f) => f (f b -> b) -> f b
01:09:57 <dmwit> yay!
01:10:02 <dmwit> GHC's suggestions were right. =D
01:10:27 <MyCatVerbs> Handy like that, innit? :)
01:10:49 <MyCatVerbs> I just put x in the wrong place. Buuuu.
01:11:56 <MyCatVerbs> What in the Nine Hells does: loeb (return unsafePerformIO) -- do? :)
01:12:40 <MyCatVerbs> When I try it at GHCi, I just get a GHC.Prim.Any in return. Heh.
01:20:29 <MyCatVerbs> Oh, of course.
01:22:36 <MyCatVerbs> :t let k = ($k) <$> [((putStrLn "BASIC is not my favourite programming language.") >>) . head] in head k
01:22:40 <lambdabot> forall b. IO b
01:23:17 <MyCatVerbs> Actually, for brevity's sake, we should probably, er.
01:23:34 <MyCatVerbs> @let badger = "BASIC is not my favourite programming language."
01:23:35 <lambdabot>  Defined.
01:24:16 <Beelsebob1> @hoogle Monad m => m Bool -> m a -> m a -> m a
01:24:17 <lambdabot> Control.Monad liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
01:24:17 <lambdabot> Control.Exception bracket_ :: IO a -> IO b -> IO c -> IO c
01:24:17 <lambdabot> Text.ParserCombinators.ReadP between :: ReadP open -> ReadP close -> ReadP a -> ReadP a
01:24:18 <MyCatVerbs> :t let k = ($k) <$> [(putStrLn badger >>) . head] in head k -- much better.
01:24:20 <lambdabot> forall b. IO b
01:25:22 <MyCatVerbs> :t (\mbool ma mb -> mbool >>= \r -> if r then ma else mb)
01:25:24 <lambdabot> forall (m :: * -> *) b. (Monad m) => m Bool -> m b -> m b -> m b
01:25:37 <MyCatVerbs> :t if'
01:25:39 <lambdabot> Not in scope: `if''
01:27:52 <MyCatVerbs> :t let { if' True (x,_) = x; if' False (_,y) = y; } in (\cond ma mb -> cond >>= (`if'` (ma,mb))) -- I thnk I may be coming down with something horrible.
01:27:53 <lambdabot> forall (m :: * -> *) b. (Monad m) => m Bool -> m b -> m b -> m b
01:32:22 <dmwit> :t <+>
01:32:23 <lambdabot> parse error on input `<+>'
01:32:25 <dmwit> :t (<+>)
01:32:26 <lambdabot>     Ambiguous occurrence `<+>'
01:32:26 <lambdabot>     It could refer to either `Control.Arrow.<+>', imported from Control.Arrow at /home/cale/.lambdabot/State/L.hs:4:0-19
01:32:26 <lambdabot>                           or `Text.PrettyPrint.HughesPJ.<+>', imported from Text.PrettyPrint.HughesPJ at /home/cale/.lambdabot/State/L.hs:54:0-46
01:32:36 <dmwit> :t (Control.Arrow.<+>)
01:32:37 <lambdabot> forall (a :: * -> * -> *) b c. (ArrowPlus a) => a b c -> a b c -> a b c
01:32:49 <dmwit> not quite
01:32:51 <dmwit> :t (|||)
01:32:52 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
01:34:43 <dmwit> MyCatVerbs: Don't worry, if you had a case of something horrible, you would have written "if' True = fst; if' False = snd" instead of this wordy pattern-matching junk. ;-)
01:35:35 <dmwit> if' b (x, y) = head $ [x | b] ++ [y]
01:35:39 <dmwit> yuck
01:36:05 <dmwit> :t \b x y -> head $ [x | b] ++ [y]
01:36:06 <lambdabot> forall a. Bool -> a -> a -> a
01:36:25 <dmwit> ?pl \b x y -> head $ [x | b] ++ [y]
01:36:25 <lambdabot> ((head .) .) . flip flip return . (((.) . (++)) .) . flip flip [] . ((:) .) . flip (|)
01:36:30 <dmwit> haha
01:36:32 <dmwit> not likely
01:36:42 * dmwit keeps forgetting that ?pl doesn't do list comprehensions
01:36:48 * Twey raises a sign and marches back and forth
01:37:02 <Twey> Down with if'!  Down with if'!
01:39:10 <monn> Just curious.. Why haskell doesn't support memoisation natively?
01:39:36 <dmwit> space
01:40:10 <QtPlaty[HireMe]> And its hard to work out what should be memoized.
01:40:19 <osfameron> memoization seems surprisingly hard to do programmatically
01:40:24 <osfameron> in haskell I mean
01:40:28 <MyCatVerbs> monn: good question. The compiler can't memoize everything without running out of RAM, and nobody appears to have written a compiler clever enough to know which expressions are worth memoizing. :)
01:40:57 <MyCatVerbs> monn: the good news is that there are a couple of very easy to use libraries for lazy memoization on Hackage.
01:40:58 <dmwit> osfameron: Have you seen Okasaki's post about this?
01:41:00 <osfameron> I mean, in Perl you can do.  use Memoize;  memoize \&foo;  <-- sub foo is now memoized
01:41:02 <dmwit> http://article.gmane.org/gmane.comp.lang.haskell.cafe/7737
01:41:04 <osfameron> dmwit: nope
01:42:10 <quicksilver> I'm not sure what monn means by 'natively'.
01:42:30 <quicksilver> if he meant 'automatically', then dmwit and QtPlaty[HireMe] are of course right.
01:42:31 <osfameron> dmwit: yeah, I've come across the "rewrite as an array" technique, but I don't really understand it (it also seems like a lot of boilerplate compared to "memoize foo")
01:43:00 <Jedai> osfameron: I'm not sure what you mean ? You can't change the meaning of an already written function, but it's pretty easy to add memoization in a function (see http://hackage.haskell.org/cgi-bin/hackage-scripts/package/MemoTrie-0.4.5 for instance)
01:43:01 <quicksilver> osfameron: what's to understand? an array is a cache of values.
01:43:17 <quicksilver> it would probably be more sophisticated to use a map or a trie.
01:43:27 <monn> I see
01:43:34 <quicksilver> "let foo = bar x in ... foo ... foo ... foo "
01:43:40 <quicksilver> ^^ I mean, that's memoization in a sense.
01:43:46 <quicksilver> it does rather depend what you mean.
01:43:53 <Jedai> osfameron: with this library it's really easy to add memoization to a function
01:44:09 <osfameron> Jedai: given that a memoized function would give exactly the same results as the non-memoized one, the fact that it would be theoretically unsafe would be encapsulated, even if the function was effectively modified inplace though, no?
01:44:43 <monn> Is there a way too use memoisation without hackage?
01:44:44 <osfameron> quicksilver: yeah, I should look at it again.  It seemed surprisingly hard *to me* but maybe I wasn't concentrating last time I looked at it...
01:44:58 <quicksilver> monn: Yes. Just do it. It's easy.
01:45:06 <quicksilver> monn: cache the values in an appropriate structure.
01:45:09 <quicksilver> like a map or an array.
01:45:21 <quicksilver> or a trie ;)
01:45:27 <quicksilver> tries are a bit more fiddly.
01:45:34 <monn> What is lazy memoisation?
01:45:46 <quicksilver> The hard part in conal's (sjanssen's) code is the fiddly details of tries.
01:46:08 <quicksilver> monn: I have no idea.
01:46:15 <quicksilver> sounds like a meaningless juxtaposition of two words, to me.
01:46:16 <quicksilver> ;)
01:46:29 <MyCatVerbs> monn: you have an infinite (or near-as-in-practice) trie which is generated on demand.
01:46:31 <quicksilver> Perhaps what they mean is a caching structure where values are lazily computed the first time they are accessed, though.
01:46:51 <Jedai> osfameron: True, you could add memoization without changing the meaning of a function... Well I guess we'll seea support for that in a future compiler version
01:47:58 <MyCatVerbs> monn: the leaves of that trie contain the outputs of your memoized function, and the trie itself maps from the input to the outputs.
01:49:25 <MyCatVerbs> Actually "trie" isn't necessarily the right term. Complete-n-ary tree would be more common for many data types, I think.
01:52:00 <Berengal> ghc-pkg find-module can tell you which package a module belongs to, but is there an easy way to find what modules a package contains?
01:52:15 <Jedai> monn: Lazy memoisation doesn't seem right to me, but maybe it was meant to speak of the fact that writing memoizing function with lazyness often avoid the boilerplate you could see in other languages (supposing you don't have a native support for memoisation or you can't use it in this particular case)
01:52:57 <quicksilver> Berengal: ghc-pkg describe
01:53:26 <Berengal> quicksilver: Thanks, must've overlooked it..
01:54:09 <Jedai> monn: For instance, you can easily use an array to do dynamic programming in Haskell because when you ask for the contents of an element of this array only it and its dependance will be evaluated, not the whole array
01:55:11 <Berengal> See also the loeb function
01:57:42 <monn> I think that's not belong to the definition of DP,where values should be computed in some kind of order.
01:58:40 <Jedai> monn: Yes, and the order is dictated by the dependance between values, right ?
02:00:20 <Jedai> monn: but in a lazy language, you won't have to code the computation in order, as long as they depend correctly on each others, you can just evaluate the one you want and its dependance will be evaluated in turn
02:01:40 <Jedai> monn: I'll try to find a simple example for you
02:04:12 <Jedai> monn: http://www.haskell.org/haskellwiki/Dynamic_programming_example
02:04:27 <monn> Is that mean we can't trade space for time in lazy language? Since IMHO memoisation is requiring more time but less space than DP
02:05:12 <monn> (in imperative language)
02:05:43 <lindzeyn> Dynamic programming in Haskell must be intense
02:05:58 <Jedai> monn: http://caffeinatedcode.wordpress.com/2009/03/26/laziness-and-dynamic-programming/
02:06:55 <Jedai> monn: in fact this second reference is clearer for me and the conclusion is clearly that Haskell makes DP far easier than in an imperative language (or a strict functional one)
02:07:09 <Berengal> > let loeb x = let r = fmap (\f -> f r) x in r in loeb $ const 0:const 1:[(+1).(!!(if mod n 2 == 0 then div n 2 else n*3+1)) | n <- [2..]]
02:07:11 <lambdabot>   [0,1,2,8,3,6,9,17,4,20,7,15,10,10,18,18,5,13,21,21,8,8,16,16,11,24,11,112,1...
02:07:13 <Jedai> lindzeyn: Well in fact it's very easy and clean
02:09:23 <monn>  I'll check the example later (can't go :80 now)
02:09:41 <Jedai> monn: that's a strange description of DP and memoization
02:10:36 <Jedai> monn: I would say that memoization can be used to simplify the writing of DP, I don't see them as concurrent techniques
02:11:29 <Jedai> monn: DP is a design method for algorithms, memoization is a mechanism to trade space for time on the calls of a function that's often used with the same arguments
02:13:51 <monn> CMIIW, I mean in the sense, memoisation needs recursion, but DP doesn't need it for the cost of more space and extra function calls
02:14:25 <Jedai> monn: note that you can do memoization in Haskell (as I said, check the MemoTrie, it's a single pure Haskell module, so you don't really have an excuse not to use it), my argument was just that DP is made easy with lazy array, you don't need memoization as often
02:14:45 <Jedai> monn: memoization doesn't need recursion
02:15:20 <monn> Well, of course I need to check the links
02:15:28 <Jedai> monn: You probably means that doing DP using memoization needs recursion
02:18:03 <monn> I'll check it
02:18:22 <Berengal> corecursion is a nice way to do simple memoization...
02:18:54 <monn> Oh, I mean that
02:19:09 <Berengal> Not neccessary though
02:20:25 <monn> For example is calculating the 7th fibonacci number
02:21:03 <Jedai> Berengal: note that it is possible to use TH to simply add memoization to the declaration of a function (even a recursive one), apparently that has already been done (though I didn't find the code), it would be nice to add that to Conal's library
02:21:29 <Jedai> monn: what about it ?
02:22:03 <Berengal> Jedai: Yes, using conals library requires a slightly different way of writing things
02:22:35 <Berengal> usually just 'foo = memo go where go [...]' instead of just 'foo = [...]'
02:22:51 <Jedai> let fib n = let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs !! n in fib 7
02:22:58 <Jedai> > let fib n = let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs !! n in fib 7
02:22:59 <lambdabot>   13
02:23:13 <yaxu> anyone know if the CLI for ghci in the new version of the haskell platform has improved?
02:24:18 <Jedai> yaxu: it use haskeline now (or rather GHC6.10.3 use haskeline) instead of editline, so it's better (editline sucks)
02:24:48 <BONUS> what's improved?
02:25:15 <Jedai> BONUS: unicode support to begin with
02:25:19 <monn> That's nice to know
02:26:18 <BONUS> awesome
02:27:12 <yaxu> Jedai: I'm really used to readline features, like ^T doing transliteration, and the kill ring
02:27:20 <Jedai> BONUS: also haskeline is a Haskell library, that's more actively maintained than editline, we can hope for a really good library rivaling readline in all aspect in the future
02:27:32 <Jedai> yaxu: add them to haskeline !
02:28:04 <yaxu> I'm not that good a haskell programmer, and the kill ring isn't trivial
02:28:23 <dqd> Oh, that's a cool library.
02:28:24 <Jedai> yaxu: If you really can't live without those features, I think there still is a way to compile GHCi to use Readline
02:28:56 <yaxu> yep I might end up doing that, shame as the haskell platform is a very nice thing otherwise
02:29:09 <Jedai> yaxu: a little search in the haskell-cafe archive (or other haskell mailing list) shoud find a procedure to do that
02:29:24 <yaxu> ok thanks Jedai
02:30:34 <koala_man> is 'sort' O(n^2)?
02:31:14 <quicksilver> no
02:31:19 <quicksilver> O(n log n)
02:31:27 <quicksilver> GHC makes it a merge, I believe.
02:31:35 <quicksilver> the standard doesn't specify.
02:32:08 <koala_man> lambdabot's @src sort seems to say that it's insertion sort
02:32:20 <quicksilver> lambdabot's @src is a work of fiction.
02:32:29 <quicksilver> you should not believe anything you see there.
02:32:32 <koala_man> it's just an example of how it could be implemented?
02:32:35 <quicksilver> right.
02:33:00 <Berengal> @src sort
02:33:01 <lambdabot> sort = sortBy compare
02:33:06 <Berengal> @src sortBy
02:33:07 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
02:33:32 <koala_man> is this because the actual implementation is huge and ugly?
02:33:35 <monn> merge sort?
02:33:42 <Jedai> koala_man: I think it's extracted from the Prelude of the report but it's only there to specify what's the behaviour must be like, not the real implementation
02:33:58 <koala_man> ah
02:34:02 <quicksilver> mostly I think @src is designed to be clear and concise.
02:34:08 <quicksilver> it's a manually maintained thing.
02:34:12 <Jedai> monn: it's either a merge sort or a quick sort, I think it's a merge sort now
02:34:34 <Berengal> quick sort on linked lists isn't preferable...
02:34:37 * quicksilver belongs to the school of thought that you can't do a quicksort in haskell without using mutable arrays.
02:34:57 <Jedai> Berengal: I agree, anyway I don't like quicksort
02:35:35 <Jedai> quicksilver: Well it depends on what you call quicksort I guess
02:35:43 <Berengal> I think sort was quicksort way back when, but don't quote me on that...
02:35:47 <quicksilver> right.
02:35:54 <quicksilver> that's why I said 'school of thought'.
02:36:05 <quicksilver> In my book, half the point of quicksort is the clever swapping algorithm.
02:36:16 <quicksilver> which requires a mutable array to faithfully implement.
02:36:19 <Jedai> But the main problem was that quicksort without randomness degrade too fast on some pretty current input
02:36:42 <Jedai> Berengal: You're right
02:36:52 <quicksilver> the naive  haskell quicksort only implements the recursion strategy of quicksort
02:36:58 <quicksilver> not the clever swapping part.
02:37:14 * Berengal wants bitonic sort
02:37:15 <quicksilver> Jedai: well, median-of-3 works fairly well, but you can't even do that in haskell ;)
02:37:24 <Gracenotes> if you have (say) a pile of papers, the important part of quicksort would be to pick a pivot and sort less than/greater than.
02:37:28 <quicksilver> Jedai: (because it's O(n) to pick out the 3 elements to median)
02:37:44 <ultrakrankerhamp> @help pl
02:37:44 <lambdabot> pointless <expr>. Play with pointfree code.
02:38:18 <quicksilver> Gracenotes: and if you have no aviation fuel, the important thing about an aeroplane is that it keeps the rain off.
02:38:18 <koala_man> is there a list somewhere of many/some of the cute optimizations that ghc can perform?
02:38:19 <Gracenotes> hm. I wonder what the most efficient physical sorting method would be for human workers for a given size of pile of papers
02:38:33 <ultrakrankerhamp> @pl (\ xs ys -> sum $ zipWith (*) xs ys)
02:38:34 <quicksilver> Gracenotes: however, that doesn't mean that *is* the important thing about an aeroplane in general :)
02:38:34 <lambdabot> (sum .) . zipWith (*)
02:38:35 <Gracenotes> quicksilver: a useful tool
02:38:36 <maltem> array /~ pile
02:38:37 <Berengal> koala_man: You could take a look at the ghc user manual
02:38:43 <Gracenotes> that's why I buy all my airplanes
02:39:14 <koala_man> Berengal: I found a list of flags, but it wasn't very specific
02:39:19 <quicksilver> maltem: I would say a pile is more like a list, in the sense that removing an element form the middle and letting everything else slop downwards feels more like O(1) than O(n).
02:39:28 <Gracenotes> hm. there must be research into the area of physical sorting... but anyway, I digress
02:39:29 <quicksilver> koala_man: there is some stuff scattered on the GHC wiki
02:39:34 <quicksilver> 'compiler commentary'
02:39:46 <Berengal> Gracenotes: Bucketsort, with insertion sort on the smaller piles
02:39:48 <Jedai> Gracenotes: I think that depending on the size of the pile I would use a mix of quicksort and selection sort
02:40:05 <koala_man> neat, thanks
02:40:06 <quicksilver> koala_man: http://hackage.haskell.org/trac/ghc/wiki/Commentary
02:40:20 <QtPlaty[HireMe]> Jedai: I recall sorting libary cards.  We did a radix sort.
02:40:22 <quicksilver> koala_man: it's pretty large and not comprehensive
02:40:36 <quicksilver> certainly to sort a hand of cards I use selection sort.
02:41:14 <Jedai> QtPlaty[HireMe]: That demands a certain structure on the sorting criteria
02:41:25 <Berengal> quicksilver: Really? I use insertion sort, since I know the already sorted part better than the unsorted part
02:41:45 <Jedai> QtPlaty[HireMe]: but I agree that if you can it's one of the best
02:41:47 <QtPlaty[HireMe]> Jedai: Yeah, thats why I said libary cards, they each had an index.
02:41:58 <quicksilver> Berengal: eh, your'e right.
02:42:00 <Gracenotes> once my compsci teacher had us sort permission slips from the entire school, and we used a sort of mergesort, given that the teachers had been required to sort it for their individual classes
02:42:02 <quicksilver> Berengal: just got confused :)
02:42:21 <Berengal> quicksilver: I do too. I usually have to think for a few seconds to remember the difference
02:42:39 <quicksilver> Gracenotes: a merge step makes sense if you share the work.
02:42:41 <Gracenotes> (she was also the school 'administrator')
02:42:49 <quicksilver> Gracenotes: that's how we used to merge exam papers after an exam
02:42:57 <Gracenotes> admin in a tech sense
02:43:00 <quicksilver> (they had to be sorted into student ID number order)
04:41:17 --- topic: '["Real World Haskell: out now", "#haskell-in-depth launched!", "Haskell News:  http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste:  http://moonpatio.com", "Logs: http://tunes.org/~nef/logs/haskell/"]'
04:41:17 --- topic: set by glguy on [Sun Mar 01 16:39:50 2009]
04:41:17 --- names: list (clog bremner_ Associat0r sw17ch fbru02 ergodicsum dolio noddy levitation[A] fishey sioraiocht dort Pthing Jem1 jrib kaol nvoorhies EvilRanter tibbe ulfdoz masklinn dionoea Pellwurst Snark_ IamMilan zax mpwd tgdavies cjs IntergalacticOwl doserj TaucherMK Schmallon paper_cc X-Scale rjack hkBst ketil flenter shintah malcolmw trin_cz demolithion true\false mxc icqn thingwath ivanm travisbrady_ Athas MasNitram lametier RayNbow jnj jsgf_ athos)
04:41:17 --- names: list (sclv_ bobatkey dikini LouisJB Bleadof ttmrichter mkrauskopf sasha76 igel pozic gnomnain tew88 maltem yowgi tvaal mornfall Manyfold Yoric[DT] eno__ WorkyBob s76__ araujo TheRealMarko aapole QplQyer shag Smokey` nohluhtC marco_g Kagami__ iblechbot dmwit ksf dumael mvr amiddelk Sup3rkiddo saynte niksnut Beelsebob drwhen zakwilson Dessous alinp neurocyte jfredett base_16 kynky Haudrex kayess_ alexsuraci solrize sshc_ anders^^ twanvl copumpkin)
04:41:17 --- names: list (bogner pumpkin stepnem doctormach ac psygnisfive woggle kerm|t nwf Cobra^^ SamB fbru02_ SamB_XP sii blackdog BONUS ssttss otto_s Mr_Awesome AtnNn mbz_ kyevan dibblego guenni Raynes JBGood turjo blackh Hunner kniu agentzh chylli erg0t_ fnordus ddvlad Time`s_Witness AnMaster mreggen Petrosian jrick Boney ytshen Paradox924X mattam Choko dax mikezackles ToRA majoh sior|oifig_ dancor_ gwern juhp loupgaroublond kig pshc thetallguy1 JusticeFries)
04:41:17 --- names: list (ksandstr DarthArachides cky Shurique moozilla u_quark maxote Saizan mgsloan BfrOv3rfl0w jeremiah bartek bombshelter13_ StoneToad danopia mkfort augustss Mortomes crem Adamant McManiaC tetha hnr xd_ nanothief seliopou dr4wd3 thetallguy trofi shepheb wagle gpolo Blub\0 sad0ur webframp JaffaCake h9b8 lilac tromp trofi^w nathanic kpreid lambdabot avlan cognominal synthase philipp_ fophillips smorg Valodim agemo det MrAwesome Zao tuukkah mightybyte)
04:41:17 --- names: list (thorkilnaur bind_return mfp British0zzy dfeuer bos qwr ava1an nlogax notsmack Country-Strike XGas sjanssen frwmanners balboa02 cpfr Nereid lanaer jrockway netcat yahooooo sbok kar-1 Anthraxx drhodes Vq^ ryanakca Heffalump Ferdirand mux snhmib oubiwann koeien OnionKnight _dls BMeph Cale Gracenotes tarbo pastorn maskd Deewiant Tobsan stevan nnunley profmakx flux MyCatVerbs aempirei hackagebot Mitar wjt mapreduce spopp zeno nasloc__ dancor)
04:41:17 --- names: list (joed octaviou1 Nafai Jaak_ davidL randomity AndyP mrd joga Caelum xci kolmodin Schmidt aleator ik a2n qebab Poeir shachaf LeoD welterde karld hoopy dfranke chr1s segher icee sebas__ jlouis_ saccade Japsu adimit djahandarie dcoutts Salve sunnavy hemulen drbean alexbobp djinni thirsteh matthew-_ preflex BrianHV Lemmih tensh_ issal_ Vulpyne C-Keen trez PeakerWork frederik grncdr Guiga|afk neofreak koninkje_away qz amiri rdd tchakkazulu proq)
04:41:17 --- names: list (eyck jensen_ willb encryptio Jedai Twey jotik dino- hlg mm_freak Plareplane ken-p Liskni_si marmolak_ dvekravy dqd Tarrant clanehin xinming Axman6 nablaa guerby lostman_ daf epokal jnwhiteh luite J11 DRMacIver jeffersonheard Qriva arjanoosting dogmaT ClaudiusMaximus purplefistmixer bremner Dr_Sunglasses converter jaredj jtootf_ agoode Hong_MinHee orbitz Boxo wh1t3 igglyb miasma Draconx rizzix acieroid Tsion scook0_ sbahra sohum PsiOmega)
04:41:17 --- names: list (minisquish ErhardtMundt Wraithan Reiv ibid byorgey ArneB mlh mansour atsampson cYmen andrewsw allbery_b codemac faXx zsol wli tony_ nimred csko Stephan202 qba eelco_ glguy desp aavogt borism_ gbacon stew Igloo kalven mercury^ ray felipe_ peddie mle edwinb laz0r frink And[y] laddy sebbe1991_ Ycros LeCamarade|Away gnuvince_ desu jonafan Berengal Gokul steveklabnik dufflebu1k authentic thomastc opqdonut osfameron mcglk_ mikezackles_ mauke)
04:41:17 --- names: list (r0bby Eelis kosmikus hesselink yango electrogeek t kokekola gereedy Martinp23 yottis shapr Nanar p_l idnar inimino dixie omnihil Ornedan liesen poucet thedward leimy QtPlaty[HireMe] Elly ehamberg Raevel earthy dejones TML epmf raxas equanimity periodic iratsu nothingmuch _br__ ski erk timothy|trg xian z` Khisanth Maddas ingy boyscared User6067 DrSyzygy nornagon lstor sgwizdak SubStack Debolaz Baughn Gabbie integral Botje smg megaTherion)
04:41:17 --- names: list (raimo_ Gilly Philippa harlekin rey_ tiglionabbit mjrosenb klugez liyang thoughtpolice stroan gnuvince deiga mstr jaj ertai PHO_ quicksilver malouin jml saiam taruti ponzao___ roadwarrior nemik Twigathy josh ath ido bd_ Badger quarks bran_ mokus pcc1 jones- Laney cjay koala_man lunabot loop ski__ pragma_ ski_ mattikus endojelly burp suiside jimki ziman hiredman glith Ginzor mgs` canvon lispy Sisu Tomas lament jvoorhis dons hellige _janne)
04:41:17 --- names: list (keseldude regulate ahf Aisling bohanlon newsham Asztal Sargun_screen decklin gdsx @ChanServ)
04:46:47 <jeffersonheard> what kind of thing would error out and give me a "Negative exponent" ?
04:47:20 <MyCatVerbs> jeffersonheard: x ^ y, where y is negative.
04:47:34 <jeffersonheard> MyCatVerbs, thanks
04:47:43 <jeffersonheard> That makes sense as you say it
04:47:52 <MyCatVerbs> In which case, only x ^^ y, or x ** y, would both be acceptable, depending on the types involved.
04:48:12 <MyCatVerbs> Really? Wow, and that despite being totally incoherent. ;)
04:50:57 <ulfdoz> vdb: unknown partition table
04:51:01 <ulfdoz> ewin
04:51:09 <jeffersonheard> sure enough.  thanks.  you just saved me an hour of scratching my head
05:04:04 <nibro> @seen malcolmw
05:04:04 <lambdabot> malcolmw is in #haskell-in-depth, #darcs, #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell. I don't know when malcolmw last spoke.
05:20:08 <malcolmw> nibro: pong
05:24:54 <nibro> hey malcolmw
05:25:25 <nibro> malcolmw: I was looking at cpphs, since I'm using it for haskell-src-exts
05:25:37 <malcolmw> nibro: yep
05:25:50 <nibro> malcolmw: and I was curious to find that it depended on a lot of old haskell98 modules
05:26:10 <nibro> malcolmw: is there a reason for this extra dependency other than "haven't gotten round to fixing yet"? :-)
05:26:11 <ksf> I want to write a TH function like  "foo ident = [d| data Foo = Foo|]", what's the syntax to use ident inside the quote?
05:27:17 <malcolmw> nibro: deliberately so.  cpphs comes with nhc98, and in that context, the base library is full of CPP-isms, so cpphs needs to be built before the base library
05:27:47 <nibro> malcolmw: I expected the answer would be something like that
05:28:28 <malcolmw> nibro: nice bootstrapping behaviour is a property I am loathe to break
05:28:35 <nibro> malcolmw: though the library depends on base as well, no?
05:29:17 <malcolmw> nibro: haskell98 package depends on base package, only in ghc I think.  certainly in nhc98, the H'98 libraries are more basic than "base"
05:29:47 <nibro> malcolmw: I meant the cpphs library, it's listed as depending on base and haskell98 on hackage iirc
05:30:04 <malcolmw> but since ghc does not distribute cpphs, that is not a problem
05:30:17 <malcolmw> nibro: let me check...
05:31:02 <ksf> meh I don't wanna work with the TH ADT. I want sexprs.
05:31:06 <malcolmw> nibro: you are right, the cabal file does claim it needs base
05:32:03 <Berengal> Is there a better way to write this: (thousands, (hundreds, (tens, ones))) = (second (second (divMod' 10) <<< divMod' 100) <<< divMod' 1000) n
05:32:46 <ksf> map read . show
05:33:08 <malcolmw> nibro: ah, the only module cpphs uses from base is System.IO.Unsafe
05:33:35 <Berengal> ksf: Needs reverse before read, but it could work
05:33:49 <nibro> malcolmw: so I take it this is not something slated for a "fix" with anything less than a major rewrite of nhc98?
05:33:51 <ksf> > showIntAtBase 10 id 1234 ""
05:33:53 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
05:34:01 <philipp_> i'm using parMap to parallelise a program which works fine for half an hour but then uses only one core, here's the output of +RTS -s : http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5526#a5526 is there a problem with garbage collection?
05:34:02 <ksf> :t showIntAtBase
05:34:03 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
05:34:04 <nibro> malcolmw: ...which I presume is not in the pipeline any time soon?
05:34:11 <ksf> ...now that's mean.
05:34:43 <malcolmw> nibro: is it a problem for you?
05:34:46 <byorgey> > showIntAtBase 10 (['0'..'9']!!) 1234 ""
05:34:46 <ksf> @src showIntAtBase
05:34:47 <lambdabot>   "1234"
05:34:47 <lambdabot> Source not found. Take a stress pill and think things over.
05:35:04 <nibro> malcolmw: certainly not a problem except for my aesthetical sense
05:35:07 <byorgey> ksf: the Int -> Char just tells it how to display the digits
05:35:07 <Berengal> ksf: thousands also needs to hold the entire remaining sum, but that's not too hard...
05:35:37 <nibro> malcolmw: I tend to think of the haskell98 package as deprecated, and was surprised to find the transitive dependency on it from haskell-src-exts
05:35:47 <ksf> byorgey, sure, but Berengal wants it to be Int -> Int
05:36:09 <malcolmw> nibro: my aesthetic sense must be opposite to yours :-)
05:36:12 <nibro> malcolmw: but I'm sure I can live with that :-)
05:36:20 <byorgey> ksf: oh, right, showIntAtBase won't be very useful for that =)
05:36:26 <nibro> malcolmw: what does your aesthetic sense say regarding this?
05:36:38 <nibro> malcolmw: that haskell98 is preferred over base?
05:37:18 <malcolmw> nibro: for me, the haskell98 libraries are a standard that is well-defined, and unchanging.  I can rely on them.  Base does not have those properties.
05:38:21 <Berengal> Going via lists also brings problems when it comes to pattern matching
05:38:24 <malcolmw> nibro: my aesthetics prefer semantic consistency :-)
05:38:36 <nibro> malcolmw: then we truly do have opposite senses - to me unchanging == stale, while change == progress
05:39:01 <Igloo> malcolmw: So do you still import List etc rather than Data.List?
05:39:05 <nibro> malcolmw: unchecked change is bad of course, but I think base is definitely a step up from haskell98
05:39:20 <malcolmw> Igloo: I always prefer that, yes
05:41:01 <malcolmw> nibro: of course, there are some things that haskell98 lacks, so I'm not too bothered about using base if those features are absolutely necessary to my application
05:42:37 <nibro> malcolmw: so you don't acknowledge that the changes that have been made to the haskell98 libraries as they now appear in base have been improvements?
05:42:45 * JaffaCake thinks we should deprecate haskell98 on the grounds that it doesn't use hierarchical names
05:43:04 <malcolmw> but for instance, when hsc2hs switched from using the haskell98 libraries to using base, it caused the nhc98 bootstrapping process a huge amount of grief
05:43:21 <nibro> JaffaCake: well, it does use hierarchical names, only the hierarchies are very short :)
05:43:39 <malcolmw> nibro: I would be hard-pushed to name any actual changes between haskell98 and base, as opposed to additions
05:44:13 <JaffaCake> nibro: that's one way to look at it (but not the right way, IMO)
05:44:20 <nibro> malcolmw: I can certainly see pragmatic reasons for wanting to depend on haskell98 over base (such as bootstrapping), but I was surprised to hear you actually saw it as preferable :-)
05:44:29 <Igloo> exceptions is the only change that comes to mind
05:44:38 <nibro> JaffaCake: oh, I totally agree with you :)
05:44:43 <malcolmw> Igloo: yes, that's the only one I can think of too
05:44:57 <nibro> malcolmw: there's also the differences in the time package
05:45:06 <nibro> malcolmw: which is what would affect cpphs the most
05:45:07 <Igloo> That and the module hierarchisation, of course
05:45:30 <JaffaCake> aren't System.IO exceptions the same as haskell98 IO?
05:45:35 <nibro> malcolmw: this is not base per se obviously, but it's something that has been changed since haskell98
05:46:15 * ksf still can't believe TH can't do unquoting
05:46:18 <Igloo> System.IO.catch doesn't exist
05:46:40 <JaffaCake> it's in System.IO.Error, isn't it?
05:46:50 <JaffaCake> but it's the same one as haskell98's catch
05:46:50 <Igloo> Ah, yes, OK
05:47:03 <malcolmw> nibro: I'm no particular fan of Haskell'98's Time library, but both of the old-time and time packages are available, and I would have no problem using them if I needed them
05:47:31 <JaffaCake> malcolmw: old-time == haskell98 Time
05:47:45 <Igloo> malcolmw: So is CPP the main reason nhc has base on top of haskell98?
05:47:45 <malcolmw> nibro: actually, since old-time just duplicates haskell98, I would not use that, you are right
05:48:08 <malcolmw> Igloo: no, it is not the main reason
05:49:34 <JaffaCake> malcolmw: so it's historical, right?
05:49:46 <malcolmw> JaffaCake: yes, mainly it is just historical
05:50:00 <JaffaCake> and it would be a lot of effort to change, I understand that
05:51:01 <malcolmw> there is still a little part of me that wants to argue that since Haskell'98 is the only actual standard we possess right now, then all the newer things ought to be built on top of that
05:52:01 <JaffaCake> I'd argue that since we moved to hierarchical libraries, we should be striving to avoid haskell98
05:52:11 <JaffaCake> also, haskell98 has some clearly wrong and deprecated stuff in it
05:52:33 <malcolmw> If haskell-prime decides to bless a particular fixed set of libraries, then that would be the new standard to build everything else on.
05:52:38 <nibro> malcolmw: I would counter-argue that what we really need is a new standard, or perhaps in particular a way to introduce better standards
05:53:16 <JaffaCake> malcolmw: so I see the structure of the packages as moving towards that
05:53:33 <JaffaCake> if/when haskell98 is really deprecated, it'll be an easy change to make
05:54:03 <malcolmw> yep, I agree with all that
05:54:09 <Igloo> I'm not sure that standardising libraries is the right thing to do. We've had 10 years of Exceptions pain, amongst other things, because of it
05:54:41 <quicksilver> if the concern is bootstrapping, then it seems at least as sensible to target a particular distribution as a bootstrap. nhc98 will bootstrap from GHC 6.6, GHC 6.8 or NHC X.Y
05:54:56 <quicksilver> that seems just as sensible as bootstrapping from a slightly-mythical "haskell98 platform"
05:55:07 <nibro> Igloo: I think the idea to standardize the incremental standardization process rather than deciding on one single haskell-prime standard is the way to go
05:55:11 <malcolmw> quicksilver: well, nhc98 likes to be able to bootstrap on a platform that has no haskell compiler at all
05:55:24 <ksf> backward-compability layers are always better than freezes, up to breakage.
05:55:36 <quicksilver> malcolmw: well for a true bootstrap I don't see how haskell98 vs base matters?
05:55:45 <saml> > let f l@(x:xs) = x : zipWith (-)  xs l  in f [1,2,6,9] --what would you call f ??
05:55:46 <lambdabot>   [1,1,4,3]
05:56:09 <quicksilver> nibro: OMG we have to standardise the standardisation process before we can make a standard?
05:56:12 <quicksilver> ouch.
05:56:24 <malcolmw> quicksilver: base was a rapidly-changing entity until relatively recently, so being able to guarantee to bootstrap from it was not so easy
05:56:25 <ksf> saml, delta
05:56:34 <saml> ksf, thanks
05:56:44 <ksf> reactive has a similar thing for events and calls it withPrevE
05:56:48 <JaffaCake> malcolmw: that's why we have package versions :)
05:57:24 <nibro> quicksilver: I believe that's where the haskell-prime committee is at right now, though there are several here who would know better :)
05:57:34 * JaffaCake hides
05:57:47 <malcolmw> JaffaCake: but it would be a bit odd for a compiler to bootstrap itself using base-2.0, only to then go on to supply base-3.x to the user?
05:58:05 <JaffaCake> not at all, that's what GHC does
05:58:08 <malcolmw> JaffaCake: although that is certainly possible I guess.
05:58:08 <nibro> quicksilver: the idea being that creating one huge standard would take waaaaay too much time, and we would still be stuck with something that would be obsolete soon after
05:59:07 <JaffaCake> malcolmw: if you force the bootstrapper to be the same as the bootstrappee, then you have big bootstrapping problems
05:59:16 <ksf> quicksilver, there are RFCs about how to write RFCs.
05:59:50 <JaffaCake> quicksilver: we semi-decided to modularise the haskell prime process, though things have been quiet for a while
05:59:57 <quicksilver> ksf: yes, but they didn't write them first.
06:00:04 <quicksilver> JaffaCake: I recall the semi-decision.
06:00:11 <malcolmw> JaffaCake: but that is essentially what nhc98 does - it bootstraps with its own current version, in order to avoid needing to distribute multiple diverging copies of source code
06:00:12 <JaffaCake> I should really start prodding people again
06:00:29 <quicksilver> JaffaCake: AIUI it was around the time you took a sabattical with the modest ambition of solving all the world's problems in 3 months ;)
06:01:02 <nibro> JaffaCake: you really should :)
06:01:19 <JaffaCake> malcolmw: you have to bootstrap using *something*, what if that is an older compiler? (ignore bootstrapping from C files for now)
06:01:40 <JaffaCake> quicksilver: I made a start ;)
06:02:08 <ksf> ...using nothing but your bootstraps to pull you out of the swamp is the _very_essence_ of bootstrapping.
06:02:16 <malcolmw> JaffaCake: yeah, so booting with a different compiler (ghc, hbc, older nhc98) all works OK, but that is partly because we try not to depend on moving targets like the base package :-)
06:02:47 <JaffaCake> ok, so it's entirely possible that you're bootstrapping from base-2.x and supplying base-3.x or whatever
06:03:26 <malcolmw> JaffaCake: yes, sure, but when booting without a Haskell compiler, I don't want to be supplying multiple copies of the base library
06:03:37 <JaffaCake> no, 'course not
06:04:12 <malcolmw> JaffaCake: and as I already said, by avoiding as many dependencies on base as possible, it doesn't really matter which version the bootstrapping compiler has.
06:04:53 <JaffaCake> so would you rather we didn't make any changes to libraries at all?
06:05:09 <malcolmw> Now that base is more stable, it could certainly make sense for nhc98 to switch over to it instead of haskell98
06:05:26 <malcolmw> JaffaCake: I'm not saying that at all
06:06:18 <JaffaCake> ok, good :)
06:06:22 <malcolmw> bugfixes are good, API additions are often good, it is just that bootstrapping can be a pain if you are not extremely careful
06:06:29 <malcolmw> that's all
06:07:11 <malcolmw> and I've had my share of pain in that department
06:08:28 <JaffaCake> it occurs to me that supplying base-3 with GHC 6.10 wasn't really a fix for anything
06:08:47 <JaffaCake> packages that don't update themselves just get broken a bit later
06:09:42 <Igloo> It does make it easier for packages to support "this release and the previous release"
06:09:52 <Igloo> But I think that the extensible-exceptions package is a better way to do that
06:09:55 <JaffaCake> yes, true
06:10:30 <JaffaCake> packages still get broken once per year, unless we're willing to indefinitely keep old base versions around
06:10:37 <hackagebot> heap 1.0.0
06:11:37 <malcolmw> JaffaCake: how about freezing base, and never changing it again? :-)
06:11:47 <JaffaCake> yikes
06:12:13 <JaffaCake> we'd just end up with a heap of cruft that we have to keep working for ever
06:12:31 <malcolmw> JaffaCake: it would make sense, if base wasn't so full of unnecessary junk
06:13:03 <JaffaCake> maybe when it really is stripped down a lot further, but even then I'd be very wary
06:13:40 <malcolmw> the idea that all library packages will break every time there is a new release of GHC doesn't seem very friendly either
06:13:43 <JaffaCake> if it was basically just Prelude minus IO stuff, then maybe
06:14:50 <quicksilver> one of the benefits of splitting base, though, is that packages only depend on what they actually need
06:15:06 <malcolmw> with the new hackage policy of closed upper limits on base version, it does seem likely that it really will be _all_ packages breaking every year.
06:15:08 <quicksilver> then they only break if one of the things they actually depend upon changed.
06:15:08 <JaffaCake> yes, and some of those pieces will change rarely
06:15:21 <quicksilver> malcolmw: only if base does indeed get bumped once a year
06:16:15 <JaffaCake> it'll probably get bumped again this year
06:16:26 <byorgey> I thought the idea was to always ship two versions of base, to give package maintainers a whole year to upgrade
06:16:53 <byorgey> the upper limit is so that the packages don't break *by necessity*.
06:16:54 <JaffaCake> byorgey: yes, but now we have a bunch of packages depending on last year's base, and they are all about to break
06:17:23 <malcolmw> so the solution is to make them break more often?
06:17:32 <JaffaCake> mind you, it's only 10% of hackage, which is surprisingly low
06:17:52 <jeffersonheard> I'm getting "Map.find: Element not in the map", but I'm not using Map.find anywhere.  Is it the same as Map.!
06:17:52 <Igloo> malcolmw: Depaying each breakage by 1 year doesn't actually fix anything at all
06:17:54 <jeffersonheard> ?
06:18:03 * byorgey is OK with things breaking occasionally in the name of progress
06:18:25 <JaffaCake> Igloo: right
06:18:29 <Igloo> JaffaCake: I suspect it's because most packages are unaffected by the changes, and don't specify any bounds
06:18:38 <quicksilver> Igloo: erm. doesn't it?
06:18:40 <malcolmw> Igloo: I'm not arguing in favour of delay
06:18:46 <JaffaCake> Igloo: oh, so that's accidental, and it's about to get worse
06:18:47 <quicksilver> Igloo: breaking less often is better than breaking more often.
06:18:58 <byorgey> jeffersonheard: the source says yes
06:19:05 <Igloo> quicksilver: Delaying all breakages by a year doesn't change the frequency of breakages
06:19:29 <quicksilver> it does, dpeneding how you interpret that english phrase.
06:19:33 <byorgey> it does in the short term ;)
06:19:39 <quicksilver> if it means a library released in 2009 works until 2011
06:19:41 <quicksilver> instead of 2010
06:19:48 <JaffaCake> the only way to change the frequency of breakages is to change the frequency of changes, and the only way to do that (reasonably) is to split up base some more
06:19:48 <quicksilver> then that's two years of working, not one.
06:20:13 <jeffersonheard> byorgey: thanks.  I suppose I should consult myself, but I've got an hour and a half before a demo of this, and I haven't had a lot of sleep
06:20:47 <JaffaCake> quicksilver: good point - it means package authors can wait 2 years between updates instead of 1
06:21:36 <quicksilver> although the situation is worse if your program depends on more than one library
06:21:43 <quicksilver> and the library authors fix things on different timescales.
06:22:28 <malcolmw> to my mind, the underlying problem is that base is too closely associated with ghc.  A really wide-ranging split-up would undoubtedly help, by reducing the surface area prone to breakage
06:23:10 <doserj> sure, if old base versions could be installed from hackage, that would solve many problems.
06:23:52 <JaffaCake> malcolmw: yes, though of course the act of splitting is itself breakage (that's what happened in the base-2 to base-3 transition)
06:24:08 <malcolmw> yep
06:24:22 <quicksilver> lots of jam tomorrow, but today we just have salt?
06:24:24 <Igloo> Yes, but it's (hopefully) little pain now for much less pain in the future
06:24:25 <quicksilver> ;)
06:26:13 <JaffaCake> I suppose if we weren't that interested in sharing *code* between compilers, we could rename base to base-ghc, and put a base veneer on top of it to hide the GHC.* modules
06:26:44 <JaffaCake> that would change less frequently
06:27:24 <Igloo> We could do that anyway if we wanted, but choosing a different name for base-ghc
06:27:37 <Igloo> And then e.g. nhc's base would just reexport all of the other package
06:27:47 <malcolmw> I'm just pondering - this whole versioning semantics thing - why have we not yet got a true FP mindset on it?  Isn't the PVP just a hacky way of specifiying a compatibility function (or relation), which necessarily ought to be more lazy in some of its arguments.  e.g. is bytestring-3.4 compatible with base-5.2?  well, we don't know until base-5.2 is released, so the answer is bottom until that point in time.
06:27:57 <Igloo> Or it would not export NHC.*, or whatever
06:28:22 <Igloo> malcolmw: So what does cabal-install do with the bottoms?
06:29:25 <Igloo> JaffaCake: Even if we did that, I suspect that base's version number would need to be bumped for each major GHC release
06:29:46 <malcolmw> Igloo: There are no bottoms for packages that are already released.
06:29:57 <JaffaCake> Igloo: perhaps only the minor version though - e.g. what have we changed so far since base-4?
06:30:09 <Igloo> malcolmw: OK, so when base 5.2 is released, what actually happens?
06:30:42 <malcolmw> Igloo: so somehow, at the point of release, the compatibility function needs to be updated to resolve to a definite answer
06:31:16 <malcolmw> Igloo: there may even be automatic ways of helping to do that
06:31:19 <Igloo> malcolmw: Right, it's the "somehow" I'm interested in  :-)
06:31:26 <JaffaCake> what would be more useful is a way to make packages able to build against newer versions if they don't depend on anything that changed
06:31:35 <doserj> who maintains the compatibility function? and how is that different to just changing the dependency field?
06:32:23 <JaffaCake> refining dependencies to something more accurate, e.g. "I depend on Foo.Bar :: [a] -> Int"
06:32:49 <JaffaCake> but that's hard, and requires heavy tool support
06:33:06 <malcolmw> JaffaCake: it would be the Right Thing though
06:33:25 <JaffaCake> not *the* right thing, but it is more accurate than versions, yes
06:33:48 <Igloo> JaffaCake: Hmm, OK, I didn't see any changes that would need a major versino bump from a quick skim of the changes
06:33:48 <JaffaCake> you can imagine even more accuracy, such as depending on strictness properties
06:33:50 <quicksilver> doserj: its maintained by the authors of the library packages themselves, not the authors of the "client" packages
06:33:52 <Absolute0> How do I bind a value to a name once and then update it thereafter?
06:33:54 <quicksilver> doserj: that would be the key different.
06:33:57 <Absolute0> in a do block
06:34:28 <quicksilver> Absolute0: you don't. This is haskell.
06:34:34 <Absolute0> quicksilver: i know
06:34:36 <quicksilver> you can re-use a name if you want to, though.
06:34:49 <quicksilver> but that's not really updating, it's shadowing.
06:34:53 <Absolute0> quicksilver: I am having a problem where i initialize once and need to update
06:34:59 <JaffaCake> Igloo: the unicode I/O stuff will change a lot under GHC.*, but nothing anywhere else
06:35:19 <JaffaCake> except perhaps if we decide to add some new encoding-related functionality
06:35:19 <Absolute0> is there a way to check if a name has already been binded to a value?
06:35:28 <JaffaCake> but that will be a minor bump
06:35:30 <malcolmw> Absolute0: do { x <- foo; x <- x+1; return x }
06:35:34 <Absolute0> this way i can check the first time and the update afterwards
06:36:29 <quicksilver> Absolute0: you can't update.
06:36:52 <quicksilver> Absolute0: I'm not convinced I understand your question, but it really sounds to me like you're labouring under a misapprehension.
06:36:57 <quicksilver> you can't update values.
06:37:23 <wli> do { x <- foo ; x <- return $ x + 1 ; return x }
06:37:24 <quicksilver> what you can do, is use a number of special reference box types (IORef, MVar) which have special primitives (writeIORef, putMVar) to change their contents.
06:37:28 <Absolute0> http://pastie.org/499078 <- line 11 intializes line 19 updates
06:37:29 <quicksilver> but I'm not sure if that's what you want.
06:37:40 <Absolute0> but since it runs forever line 11 always runs
06:37:48 <Absolute0> theres no way to initialize setup only once?
06:38:08 <quicksilver> you can't change 'setup'.
06:38:13 <Absolute0> If i could check if x is binded to a value, that would be a solution
06:38:20 <quicksilver> (ignoring the fact that your code isn't quite valid)
06:38:26 <quicksilver> you cannot update values.
06:38:30 <Absolute0> if binded(setup) initalize else update
06:38:35 <quicksilver> you cannot update.
06:38:41 <Absolute0> quicksilver: s/update/rebind
06:38:42 <quicksilver> I think we're failing to communicate, sorry ;)
06:38:44 <Absolute0> is that better? :)
06:38:46 <quicksilver> no.
06:38:58 <quicksilver> all you would be deoing is making a new, local variable called 'setup'
06:38:59 <Absolute0> you can do let x = 5; and then let x = 6;
06:39:04 <Absolute0> so don't say you can't
06:39:05 <quicksilver> it would be completely unrelated to the existing setup
06:39:11 <quicksilver> it would just happen to have the same name.
06:39:18 <Absolute0> ok that's what i want
06:39:19 <Absolute0> :)
06:39:21 <Absolute0> whatever you call it
06:39:26 <quicksilver> no it's not.
06:39:31 <quicksilver> because then when 'main' looped
06:39:37 <quicksilver> the "new" local variable would be out of scope
06:39:44 <quicksilver> and the "old" top-level setup would be back in scope.
06:39:59 <Absolute0> so i need to resort to some sort of monadic solution?
06:40:00 <quicksilver> what you could do is make 'setup' a parameter of main
06:40:09 <quicksilver> and call yourself recursively (with the new value)
06:40:11 <Absolute0> yeah
06:40:20 <quicksilver> passing parameters through a recursion is one way to model a mutating value.
06:40:24 <Absolute0> but can main take parameters?
06:40:31 <Absolute0> i guess mainHelper :)
06:40:32 <quicksilver> no
06:40:35 <quicksilver> right :)
06:40:37 <Absolute0> thanks
06:41:05 <quicksilver> malcolmw: in your proposal, how would an 'end-user' specify a dependency?
06:41:30 <quicksilver> malcolmw: an 'end-user' would say "I need bytestring-5.4", and it would be the job of the system to decide if bytestring-12.16 is backwards compatible or not?
06:42:05 <malcolmw> quicksilver: it's not a proposal, just a random thought that occurred :-)
06:43:45 <malcolmw> quicksilver: possibly the user says "I need the interface of bytestring-5.4", and some automatic tool discovers whether parts of the API in 12.16 have been removed or changed since 5.4
06:44:12 * quicksilver nods
06:44:24 <JaffaCake> like the tool we proposed as a SoC project?
06:44:55 <malcolmw> quicksilver: so you would be specifying a minimum version, rather than a maximum
06:45:05 <quicksilver> I'm not sure a tool would be sufficient
06:45:10 <quicksilver> although it might be helpful
06:45:15 <SamB_XP> malcolmw: I'm not quite understanding the differencew between "random thought" and "proposal"
06:45:24 <quicksilver> the visible ABI/API might look totally compatible but some important semantic different might be there
06:45:26 <JaffaCake> malcolmw: but the point is, the version was  bumped because the API changed
06:45:39 <malcolmw> SamB_XP: proposals are usually more well-thought out :-)
06:45:50 <malcolmw> JaffaCake: yes, but changed in what way?
06:45:52 <quicksilver> JaffaCake: but that is necessarily conservative.
06:46:08 <quicksilver> JaffaCake: it might turn out to be backward compatible with a large class of programs.
06:46:11 <JaffaCake> malcolmw: so just comparing APIs isn't enough, you need to know which part of the API the package depended on
06:46:29 <malcolmw> version numbers are a poor substitute for the real information we want
06:46:58 <malcolmw> so is there some compact way in which we could get closer to the semantics of what is going on?
06:47:02 <JaffaCake> s/poor substitute/safe approximation/ :)
06:47:25 <JaffaCake> malcolmw: I think it's really quite hard
06:47:36 <SamB_XP> and the real problem is if one of the functions has the same type but does something a bit different ...
06:47:39 <malcolmw> data VersionChange = SignaturesChanged | SignaturesAdded | SignaturesDeleted
06:47:57 <JaffaCake> e.g. if you import a module M from a package without an import list, then you implicitly depend on the *absence* of everything that would name-clash
06:48:23 <malcolmw> yes that is a nasty one
06:48:33 <JaffaCake> and then there's instances....
06:48:34 <SamB_XP> JaffaCake: and, even worse, the list of things that would name clash is variable
06:48:40 <malcolmw> but it could still be automated
06:48:57 <ksf> data SemanticsChange = DontWorry | Hope | Pray
06:48:58 <quicksilver> malcolmw: automation could never spot a semantic change.
06:49:18 <JaffaCake> in theory you could come up with some more accurate dependency that could be derived automatically, yes
06:49:45 <quicksilver> malcolmw: the function "happyBunny :: IO ()" could continue to have the same interface even though in version 5.1 it actually summons an angry bear.
06:49:47 <JaffaCake> whether it would describe completely the conditions necessary for compilation to succeed, I'm not sure
06:50:37 <JaffaCake> and semantic changes mean it's all hopeless, yes
06:51:24 <malcolmw> quicksilver: we can't do anything about evil package makers who live in the IO netherworlds, but we _do_ know how to check type signatures, strictness, overlapping names, and so on.  Just because these techniques don't solve the whole problem is not a reason to reject them
06:52:32 <quicksilver> malcolmw: well IO might have been a bad example.
06:52:40 <quicksilver> malcolmw: it certainly wasn't the point I was making.
06:52:44 <JaffaCake> the advantage of version numbers is that they can be checked easily without heavyweight tool support
06:52:54 <malcolmw> even in my own programs, never mind using other people's packages, I might accidentally make the happyBunny summon the angry bear, and the type system will not help me.
06:53:08 <quicksilver> malcolmw: (+) :: Int -> Int -> Int continues to have the same API even if in version 5.1 I choose, for some reason to make it do multiplication.
06:55:12 <Saizan> the idea of keeping version numbers around and updating the "compatibility" function might work though
06:55:31 <JaffaCake> I doin't think I understand that
06:56:35 <quicksilver> Saizan: yes, if the compatibility function was manually maintained, then yes.
06:56:41 <Saizan> JaffaCake: instead of having the .cabal file specify the version range you can calculate them externally and store them in hackage, so tools can download them
06:56:44 <quicksilver> Saizan: or at least partly manual.
06:56:58 <quicksilver> Saizan: and in theory it could be higher-resolution than whole-package.
06:57:26 <JaffaCake> Saizan: oh, so we'd determine automatically which versions a package depended on?
06:57:27 <quicksilver> so, bunnyWorld-5.1 is entirely backward compatible with bunnyWorld-3.2 *except* for the function happyBunny.
06:57:28 <Saizan> mostly automated, or at least automatically checked for silly errors is my main goal
06:57:42 <quicksilver> since I am the maintainer I could maintain that fact.
06:57:49 <quicksilver> I was the one who changed the semantics.
06:58:02 <quicksilver> argubaly makes more sense for me to maintain it than some consumer of my code to try to work it out.
06:58:21 <JaffaCake> it's not a bad idea to keep the dependencies separate and allow Hackage to update them
06:58:24 <Saizan> JaffaCake: yes, maybe letting the maintaners override it with semantic information
06:58:32 <dcoutts> Saizan: if hackage keeps a machine-readable description of the api then checking interface compatibility should be possible
06:58:42 <malcolmw> so, type-inferrable API changes are discovered automatically, semantic changes are recorded manually - sounds good
06:58:44 <Saizan> i.e. like type-inference with possibly user-supplied signatures
06:59:08 <SamB_XP> dcoutts: but how will it know whether the semantics of a function have been altered in an incompatible way ?
06:59:31 <quicksilver> SamB_XP: I believe you'd have to have a manual override.
06:59:43 <SamB_XP> what if you forget until it's too late?
06:59:46 <dcoutts> so what, the suggestion is that someone uploads a new version of a dependency and we email the authors of dependent packages to say, "we think your package will continue to work with this new version, would you care to test it and update the dep appropriately" ?
06:59:48 <quicksilver> SamB_XP: "even though the API of foo :: Bar -> Baz looks the same, the semnatics have changed"
06:59:57 <SamB_XP> ... will there not be a "too late" ?
06:59:57 <quicksilver> SamB_XP: all possible systems contain room for human error.
07:00:04 <Saizan> dcoutts: yeah, though it came out that it's complex and maybe expensive, so we might cache the result in the form of version ranges
07:00:11 <quicksilver> dcoutts: no.
07:00:15 <JaffaCake> dcoutts: if we follow the PVP, there's no need to do that
07:00:25 <quicksilver> dcoutts: the dependent packages declare a dependency on one version which definitely works.
07:00:40 <Saizan> dcoutts: and version ranges also allow maintainers to add semantic information
07:00:47 <quicksilver> dcoutts: the dependEE pacakge is responsible for maintaining the fact that other later versions may also work.
07:00:57 <quicksilver> dcoutts: so I depend on haxml-1.2.3
07:01:06 * edwardk waves hello.
07:01:10 <quicksilver> dcoutts: and malcolmw later adds the information that haxml-1.2.4 is perfectly compatible with it
07:01:19 <quicksilver> dcoutts: so then cabal knows to allow my library to be installed with 1.2.4
07:01:31 <dcoutts> JaffaCake: but the PVP is about being conservative, I thought the suggestion was to work out when new versions came out if actually it's not using the bit that changed.
07:01:45 <JaffaCake> quicksilver: but the version number tells you whether it's "compatible" or not
07:01:48 <quicksilver> Yes. The suggestion is to explore the possiblity of something less conservative than the pvp.
07:02:01 <dcoutts> quicksilver: I see
07:02:13 <quicksilver> maybe there is nothing useful in this part of the design space
07:02:15 <JaffaCake> the problem we're trying to solve is that packages don't depend on the whole API, and hence don't need to break when only a part of it changes
07:02:16 <quicksilver> but I think that's the suggestion.
07:02:59 <JaffaCake> so it's a property of the source of the dependency, not the target
07:03:04 <quicksilver> JaffaCake: the other problem I'm trying to solve is that the dependENT package isn't necessarily the person in possession of the best information.
07:03:04 * Saizan is mostly concerned with the fact that build-depends field are completely unchecked, only tested
07:03:04 <dcoutts> JaffaCake: exactly
07:03:43 <malcolmw> dcoutts: we were musing on the likelihood of _all_ packages breaking every time that ghc is released, because of the new forced upper-bound on package versions, and trying to work out if there is a way to be less conservative
07:03:44 <doserj> in short, do type-checking on the package level, i.e., compare needed interfaces with provided interfaces?
07:04:10 <sjanssen> wait, forced upper bound?
07:04:27 <doserj> (taking things into account like no name-clash inducing additions, no duplicate instance declarations, etc)
07:05:03 <dcoutts> malcolmw: I prefer them "breaking" in easily recognisable ways with clear error messages than what we used to have.
07:05:09 <JaffaCake> quicksilver: I'm not sure how you can improve things there, other than automating the PVP
07:05:14 <malcolmw> sjanssen: well, closed upper bound on the version of base, but since base is bumped with every release of ghc, it affects all packages.
07:05:18 <dcoutts> malcolmw: and if we can continue to ship multiple versions then it becomes pretty smooth.
07:05:30 * sjanssen predicts package authors will all use base < 1024 just so they don't have to release a new version every year
07:05:54 <dcoutts> sjanssen: good point, perhaps we need to ban deps more than major+1 :-)
07:06:01 <malcolmw> dcoutts: I think our worry is that packages will "break" according to the PVP, but in actually they are not borken at all.
07:06:11 <sjanssen> dcoutts: are you going to ship every past version?
07:06:40 <Saizan> is it that much of a problem to make a release once a year?
07:06:41 <sjanssen> dcoutts: if you ship N past major versions, about 1/N packages will need to be updated per year
07:06:52 <doserj> Saizan: yes
07:07:09 <sjanssen> Saizan: if the updates are only in the meta-data, yes
07:07:31 <dcoutts> malcolmw: on account of them making one tiny incompatible change
07:07:42 <dcoutts> malcolmw: perhaps it'll make package authors think more :-)
07:07:57 <Saizan> sjanssen: i'd think that if you've to only update the meta-data it'd be less of a problem
07:08:12 <sjanssen> Saizan: it's less work, yes, but it's useless work
07:08:34 <dcoutts> right, being able to adjust deps for packages that happen to continue to work would make the whole thing much more manageable
07:08:52 <JaffaCake> so why don't we let Hackage do that on its own?
07:09:03 <JaffaCake> we already have a separate set of .cabal files, don't we?
07:09:03 <dcoutts> exactly, get bots doing builds to try it out
07:09:16 <dcoutts> and then tell package maintainers the results
07:09:21 <JaffaCake> right
07:09:30 <dcoutts> with an interface in hackage to let the maintainers make the suggested adjustments
07:09:37 <malcolmw> dcoutts: the point is that it is not the package author's fault.  the package, with no changes, is still fully safe.  But a change of version number elsewhere makes cabal think it is not safe
07:09:42 <dcoutts> so there's a human in the loop to consider semantic changes
07:09:43 <JaffaCake> don't let them update to a new version without taking into account the new deps, or something
07:09:56 <Saizan> you won't solve the problem of doing "useless work" for the maintainers that way, though?
07:09:58 <sjanssen> JaffaCake: so Hackage is going to generate versions of packages that don't exist in upstream source control?
07:10:07 <SamB_XP> yeah "click here to not upload a new version"
07:10:23 <dcoutts> sjanssen: no, only maintainers should do that
07:10:34 <dcoutts> malcolmw: I do not follow that
07:11:35 <dcoutts> Saizan: what's the useless work?
07:11:52 <dcoutts> Saizan: checking if their package still works with a new major version of a dep?
07:12:04 <Saizan> dcoutts: releasing a new version with an updated upper bound when it still works
07:12:05 <dcoutts> doesn't seem especially useless to me
07:12:17 <sjanssen> dcoutts: s/base < n/base < n+1/ and making a new release each year
07:12:27 <dcoutts> Saizan: right, I'd like maintainers to just be able to adjust the deps of the package on hackage
07:12:28 <quicksilver> also it increases the chance of bitrotting packages
07:12:57 <quicksilver> that is, the situation of needing to re-release every year would increase the chance of bitrotting packages
07:13:01 <dcoutts> Saizan: and hackage would just maintain the revision of the .cabal file. Clients could then choose to use the new or original one.
07:13:14 <sjanssen> dcoutts: so it's click some buttons on Hackage once a year, you're just making the useless work a bit easier
07:13:32 <dcoutts> quicksilver: for awol maintainers we can have "distro maintainers" who look at the build/test results
07:13:44 <dcoutts> sjanssen: yes, exactly.
07:14:00 <quicksilver> sjanssen: making work easier is quite a positive step ;)
07:14:06 <sjanssen> dcoutts: I'd rather have no useless work
07:14:14 <quicksilver> so would I.
07:14:19 <quicksilver> do you have a proposal for how to acheive that?
07:14:32 <dcoutts> sjanssen: perhaps you should tick the box "don't ask me, just do it! I abdicate responsibility"
07:14:56 <dcoutts> sjanssen: in principle there's no problem with doing it automatically, except that as a maintainer that might make you nervous
07:15:16 <dcoutts> sjanssen: especially if your package has no automatic testsuite being run by the hackage build clients
07:15:26 <sjanssen> dcoutts: if we need all these mechanisms to cope with the policy, isn't that an indication the policy isn't the best one?
07:15:55 <dcoutts> sjanssen: then look for a mechanism that captures the semantics too
07:16:05 <dcoutts> api/types is only part of it
07:16:07 <Berengal> What do other repositories do?
07:16:17 <dcoutts> Berengal: test and iterate
07:16:18 <sjanssen> quicksilver: off the top of my head, I'd rather see a 'preferred base version' field than required upper bound dependency
07:16:44 <sjanssen> we make building without the preferred base version a strong warning rather than a build failure
07:17:37 <quicksilver> but the base authors wouldn't have bumped the version without reason.
07:17:44 <quicksilver> if they bumped the version that was because something changed.
07:17:52 <quicksilver> why is base different from other packages
07:17:59 <quicksilver> (I confess to playing devil's advocate)
07:18:02 <dcoutts> the key thing is that you probably were not using the thing that changed
07:18:15 <SamB_XP> they're just talking about NOT bumping the version to base-5 in #ghc right now ;-)
07:18:16 <dcoutts> which is why doing more detailed api subtype comparisons is a useful thing
07:18:25 <dcoutts> version numbers are an approximation
07:18:27 <sjanssen> quicksilver: the preferred version thing should work on any package
07:18:43 <SamB_XP> they're thinking 4.2 might be better
07:18:44 <sjanssen> dcoutts: useful, but still "pie in the sky", right?
07:18:51 <dcoutts> sjanssen: yes
07:19:15 <dcoutts> sjanssen: I don't see how a "I know it worked with this version" is really any different from an upper bound
07:19:31 <dcoutts> sjanssen: except perhaps in the ease of ignoring it?
07:19:43 <dcoutts> sjanssen: assuming the packages are following the PVP
07:19:46 <SamB_XP> dcoutts: well, the upper bound could be wrong
07:19:54 <sjanssen> dcoutts: it's the difference between a warning and an error
07:20:21 <dcoutts> sjanssen: we can add a flag to let user force override
07:20:25 <SamB_XP> well, I mean, people could lie about what versions packages have worked with, too, but ...
07:20:58 <quicksilver> dcoutts: "I know it worked with the version" says "If you can prove that some other version is as good as that version, then it should be OK"
07:20:58 <dcoutts> sjanssen: cabal install foobar --try-it-anyway!!
07:21:06 <sjanssen> dcoutts: that's hardly a solution, because users won't know about the flag, they'll still write me emails about my artificially outdated package
07:21:09 <quicksilver> dcoutts: whereas an upper bound implies "definitely doesn't work"
07:21:13 <dcoutts> quicksilver: that's equivalent to the PVP
07:21:20 <quicksilver> no it's not.
07:21:27 <quicksilver> if the proof can take into account specific things
07:21:33 <dcoutts> quicksilver: huh?
07:21:44 <dcoutts> quicksilver: specific to the package in question?
07:21:46 <quicksilver> the reasons that base-4 *is* equivalent to base-3 for every single haskell program I personally have ever written.
07:21:55 <quicksilver> yes, specific to the package in question.
07:22:16 <quicksilver> (although I didn't personally know it would be, before base-4 came out, nonetheless it turned out to be the case)
07:22:23 <dcoutts> quicksilver: ok, so it's not just "I know I worked with this version" then, it's also a whole lot of info about what that package uses
07:22:40 <dcoutts> which is the "pie in the sky" idea I was mentioning to sjanssen
07:22:42 <quicksilver> well the maintainer provides "I know I wored with this version"
07:22:48 <sjanssen> quicksilver: you've never used exceptions?
07:22:50 <quicksilver> and some automated tool works out what I *actually* used
07:23:01 <dcoutts> quicksilver: right, that's what I've suggested
07:23:06 <dcoutts> (and others)
07:23:06 <quicksilver> and the base maintainer makes some kind of note of which parts of base *actually* changed
07:23:13 <quicksilver> (that step could be manual, not automatic)
07:23:16 <dcoutts> quicksilver: or that bit can be automated too
07:23:23 <quicksilver> not covering semantics.
07:23:29 <quicksilver> sjanssen: you better beleive it. And proud of it too.
07:24:06 <dcoutts> quicksilver: right I accept that, it's different from what sjanssen was suggesting I think, which is just to make the suggestion/upperbound a warning rather than an error
07:24:17 <dcoutts> so in other word it'd not be used in dep planning
07:24:37 <dcoutts> but we'd warn after constructing the dep plan if any upper bounds were violated
07:25:04 <quicksilver> sjanssen: (actually I've used killThread, which is an exception, but in a way which would work with either base version as it happenes)
07:26:09 <pozic> Do you always package up your algorithm parameters in a datastructure? Or do you just use separate parameters (as a result you get e.g. an 7-ary function)
07:26:22 <dcoutts> sjanssen: so if we ignored upper bounds by default in cabal-install's planner and then just warned later you think that'd be better than having it as a flag that users have to try after the first time when it says it cannot install something.
07:26:38 <sjanssen> pozic: once you've got 7 parameters, some sort of alternative approache is necessary, yes
07:26:53 <dcoutts> 7 is the magic number :-)
07:26:57 <sjanssen> dcoutts: in my opinion, upper bounds in build-depends should be followed strictly
07:27:23 <dcoutts> sjanssen: and "soft" recommended be a separate class of bounds?
07:27:30 <sjanssen> dcoutts: right
07:28:40 <dcoutts> hrm, I don't like it :-)
07:28:49 <dcoutts> though in principle it doesn't make the solver harder
07:28:56 <dcoutts> we've already got soft prefs from the users
07:29:02 <dcoutts> but not from the packages themselves
07:29:34 <doserj> "soft recommended" meaning first look for a solution following them; if that is not possible, ignore them?
07:30:01 <sjanssen> doserj: ignore them and leave warning messages
07:30:20 <dcoutts> doserj: it's somewhat less defined than that to give the solver some flexibility
07:30:29 <quicksilver> sjanssen: but as a package author how am I supposed to decide when to use a soft depend?
07:30:44 <dcoutts> doserj: otherwise the problem becomes exponential :-)
07:30:52 <dcoutts> problem/solution
07:30:59 <quicksilver> I just have some fuzzy feeling that people "try pretty hard" to keep base backward compatible, so a soft bound is acceptable?
07:31:17 <quicksilver> but I think that the guys who wrote 'memotrie' are a bunch of fly-by-nights and I need a hard bound?
07:31:21 <dcoutts> quicksilver: hah hah, base 2 -> 3 -> 4, major breakage each time
07:31:46 <quicksilver> well I'm trying to understand when sjanssen would use soft + hard bounds
07:31:50 <JaffaCake> but only for very good reasons :)
07:31:55 <quicksilver> and what policy he'd reocmmend package authors follow
07:32:07 <dcoutts> JaffaCake: of course
07:32:13 <sjanssen> quicksilver: use an upper bound when that version exists and you know your package won't build with it
07:32:22 <quicksilver> ah, OK.
07:32:28 <dcoutts> that does seem pretty reasonable
07:32:43 <quicksilver> that seems plausible indeed. Although in that case I might just fix it :P
07:33:08 <pozic> Didn't all the autoconf (and Emacs)  people decide that feature testing was better than testing version numbers?
07:33:21 <quicksilver> yes.
07:33:32 <dcoutts> pozic: when all you've got is software soup that's probably true
07:33:33 <quicksilver> but listing all the features of a base that a package used would take a while
07:33:37 <sjanssen> dcoutts: you could also support/enforce both of these policies.  Require either an upper bound on base or a preferred version on base
07:33:37 <quicksilver> and we don't have names for them.
07:34:04 <mapreduce> pozic: Should we call that duck versioning?
07:34:37 <dcoutts> sjanssen: how about deriving if the upper bound is soft or hard based on upload time? :-)
07:34:52 <dcoutts> sjanssen: if they uploaded it before the other one was released then it's soft
07:35:09 <pozic> mapreduce: it depends on your point of view. If you can encode all the properties you need from a package, you won't have version hell.
07:35:15 <sjanssen> dcoutts: shouldn't uploading be referentially transparent, if possible?
07:35:38 <dcoutts> sjanssen: why? it matches the semantics you wanted doesn't it?
07:36:10 <sjanssen> dcoutts: I guess I wonder where the information will be stored, Hackage will modify my tarball?
07:36:12 <dcoutts> sjanssen: I admit it seems a little odd, I was partly joking, but I don't see anything especially wrong with it except that it feels a little implicit
07:36:33 <dcoutts> sjanssen: nothing needs modifying, the upload times are available to the clients
07:38:14 <sjanssen> dcoutts: it seems odd to have installation via cabal install and manually via tarball have different behaviors
07:38:19 <mapreduce> pozic: I imagine it's hard to verify binary compatibility with that approach, in a reasonable amount of time.
07:38:38 <sjanssen> dcoutts: they already behave differently, but this difference is extreme
07:38:50 <dcoutts> sjanssen: that's already the case and will be more-so when we allow maintainers to adjust deps on hackage
07:39:15 <dcoutts> sjanssen: cabal uses the preferred versions stuff while Setup.hs doesn't
07:39:54 <sjanssen> dcoutts: that's just really scary
07:40:14 <sjanssen> dcoutts: what about from-source distros like Gentoo?
07:40:16 <dcoutts> why? it's automatic vs manual package management
07:40:25 <Saizan> pozic: pure feature testing doesn't let cabal-install do its job reasonably, i'd think, but i agree that we should develop a tool to check interfaces to help in inferring the right version constraints considering the libs available
07:40:48 <sjanssen> dcoutts: will the ebuild maintainers manually patch packages where an upper dependency should actually be a soft dep?
07:41:05 <dcoutts> sjanssen: sure, they do it all the time
07:41:39 <JaffaCake> I missed the discussion - what's a soft dep?
07:42:27 <dcoutts> JaffaCake: sjanssen would like to distinguish upper bounds that are there because we know it doesn't work vs speculative/pessimistic upper bounds on as-yet-unreleased versions
07:42:36 <sjanssen> dcoutts: but every package is going to potentially have one of these, and every distribution is going to have to do the same work
07:42:52 <dcoutts> JaffaCake: and to treat those kinds of upper bounds differently, more as suggestions than hard constraints
07:43:15 <JaffaCake> sounds reasonable
07:43:29 <dcoutts> sjanssen: there's plenty of infrastructure we can share to help automatic translation
07:43:36 <sjanssen> dcoutts: and there's also the problem of non-hackage users determining when an upper bound should be soft or hard.  Do I print out a table of base release dates and hang them on my wall?
07:44:01 <seliopou> Well, it'd be nice if you could contain those differences in major/minor versions
07:44:28 <seliopou> something like releases with the same major version have the same API, or something
07:44:36 <sjanssen> dcoutts: I really think we want all the metadata in the tarball
07:45:03 <dcoutts> sjanssen: so the advantage of making it explicit is that it's explicit! :-) you can see it clearly. On the other hand it's more semi-redundant information for package authors to supply
07:45:45 <dcoutts> sjanssen: generally I agree that all the meta-data should be in the .cabal file (and the original is of course in the tarball)
07:46:37 <McManiaC> has anyone used the Network.Curl librarie under windows? i tried to install it with cabal and get the error "sh: runProcess: does not exist (No such file or directory)"??
07:46:51 <dcoutts> McManiaC: it uses a ./configure script
07:46:59 <dcoutts> McManiaC: meaning it needs MSYS/mingw
07:47:18 <McManiaC> oh ok
07:47:50 <dcoutts> McManiaC: feel free to complain to the package author :-) we'd like to reduce the number of packages using configure scripts for just that reason
07:48:02 <McManiaC> ok cool
07:52:32 <Badger> hah
07:52:40 <Badger> the very same thing happens with SDL.
07:53:06 <Badger> but I have msys :/
07:53:16 <McManiaC> dcoutts: what exactly do i need? ive installed mingw now, what next?
07:53:27 <roderyk> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2546  - can someone take a look at this snippet
07:53:42 <roderyk> I can't seem to get a skeleton gtk2hs app to loop a timeoutAdd
07:53:53 <dcoutts> McManiaC: MSYS is the command line bit, like a dos window but using a POSIX shell
07:54:21 <dcoutts> Badger: you have to run it from within msys, so that sh.exe is actually on the path
07:54:44 <McManiaC> ok
07:55:35 <Badger> ah, l.
07:55:37 <Badger> er, k
07:56:40 <gwern> I have just discovered a downside to using trackballs instead of mice
07:56:47 <gwern> it's really easy for someone to steal the ball
07:57:26 <dino-> gwern: Oh wow, I'd be mighty upset.
07:57:27 <SamB> gwern: it's easy either way, if there *is* a ball
07:57:48 <dino-> <- dedicated Kensington user of 16 years
07:57:50 <SamB> the problem with trackballs being that they NEED a ball
07:57:51 <Philippa> SamB: it's the work of half a second on my trackball though
07:57:55 <gwern> SamB: with a mouse, it's not so obvious how to steal it. heck, many people don't know they have balls
07:58:03 <SamB> gwern: what???
07:58:03 <Philippa> many of them don't
07:58:09 <SamB> how do you NOT KNOW THAT?
07:58:25 <Philippa> by growing up with laser mice
07:58:26 <gwern> dino-: well, I am fairly annoyed. but it's not such a big deal since all I really need a mouse for is firefox and copy-pasting of text
07:58:26 <SamB> Philippa: true!
07:58:38 <SamB> I didn't know it was possible to grow up with laser mice yet
07:58:47 <gwern> and I just installed one of the hit-a-hint style extensions, so firefox is half-usable
07:58:59 <gwern> xmonad/tiling wms ftw, btw
07:59:01 <Philippa> if you're 18, plenty viable
07:59:04 <Badger> dcoutts: what's the alternative to configure?
07:59:15 <SamB> hey, I started with a serial mouse
07:59:22 <Berengal> The thing about laser mice is... transparent tape
07:59:25 <SamB> ... one that had ears!
07:59:26 * Baughn started with a freakin' busmouse
07:59:34 <dcoutts> Badger: doing any necessary tests in the Setup.hs script
07:59:37 <SamB> at least, I think it was serial ...
07:59:38 <gwern> SamB: how long have laser mice been out? early 90s, right? so you could be fairly old and never use a mouse with balls for your computing pleasure
07:59:41 <Badger> ah
07:59:42 <SamB> it might have been bus
07:59:43 <SamB> I forget
07:59:44 <Baughn> Berengal: Won't the tape be awfully obvious?
07:59:49 <dino-> gwern: absolutely, keep mousing to a minimum, yay xmonad
07:59:55 <SamB> gwern: really ... ???
07:59:57 <Adamant> gwern: early 90's, I doubt
08:00:22 <Berengal> Baughn: Depends on the tape and the mouse. I've found combinations that are almost invisible
08:00:27 <SamB> what is a bus mouse anyway ?
08:00:30 <gwern> the really irksome thing is that apparently firefox disabled the Backspace = go back in history
08:00:42 <dino-> btw, I was so disappointed by the cheapness of that black Kensington with the scroll ring around the ball that I bought 2 extra of the silver one with blue ball to tough out the wait for something better.
08:00:52 <Baughn> gwern: You can still use alt-left
08:01:06 <dino-> It takes me about 5 years to wear out the left button on one of these usually.
08:01:33 <gwern> hm. looks like *laser* mice only were released in 2004, but optical mice long preceded that
08:01:43 <Baughn> SamB: http://en.wikipedia.org/wiki/Bus_mouse
08:01:53 <Adamant> trackballs suck, all hail the MX Revolution!
08:01:54 * malcolmw used a laser mouse on a sun workstation in 1987
08:01:55 <gwern> those were invented in 1980, and seem to've been sold shortly thereafter
08:02:05 <Adamant> malcolmw: seriously? wow.
08:02:10 <Zao> malcolmw: And now you lack an eye?
08:02:17 <gwern> malcolmw: how do you know it was laser and not just optical?
08:02:17 <dino-> Also, if we're doing war stories, I have my first mouse ever from 1984. With the ginormous serial connector on the end. It's a square Logitech.
08:02:19 <Berengal> Baughn: I had one of those on my first computer
08:02:41 <malcolmw> ok, maybe it was jsut optical.  it needed a special mousepad with a grid etched into it
08:02:48 <dcoutts> sjanssen: will you be at ICFP btw?
08:03:05 <roderyk> I consider myself a youngin, and even I remember the "mouse cleaning kits - liquid, ball, and chain!" :-)
08:03:06 <dcoutts> sjanssen: or any of the related workshops, HIW, HS etc
08:03:25 <sjanssen> dcoutts: I'm not planning on it
08:03:43 <dcoutts> sjanssen: ah well
08:04:55 <gwern> there's something very soothing about watching the links get dumped to stdout in my new wikipedia bot
08:05:26 <gwern> each link was lovingly selected by a human and emplaced into a new article; one wonders who they are, what they're writing about, why. what kind of chair they are sitting in
08:05:58 <McManiaC> dcoutts: do you have any idea why this fails? http://pastie.org/499193
08:06:10 <Berengal> gwern: Hehe, seems soothing indeed
08:06:11 <gwern> this 'Singapore Sympony Children's Choir' link - is it being edited by someone from singapore? perhaps it is one of the well-paid elite mandarins, bringing an article about something his daughter is in up to snuff
08:06:26 <gwern> who is this Lemuel Carpenter?
08:06:43 <gwern> 'I Fight Dragons'? probably vandalism, but it sounds like a hazardous hobby
08:07:01 <dcoutts> McManiaC: looks like it's not linking to openssl
08:07:10 <Berengal> http://en.wikipedia.org/wiki/I_Fight_Dragons
08:07:17 <sjanssen> gwern: are you watching all edits live?
08:07:25 <gwern> or, 'Chiari Syringomyelia Foundation' - this makes me wince just reading it
08:07:41 <gwern> sjanssen: just New Pages. Recent Changes would scroll by a bit fast to read
08:08:44 <gwern> one almost can compose stories. 'I Fight Dragons, and in revenge they made my beloved Irina Salomykova succumb to septica; in revenege, I founded the Chiari Syringomyelia Foundation, that none need suffer like I did again!'
08:09:39 <gwern> (and all this took place in the Albuquerque Air Defense Sector; if only the radar operators had been vigilant enough to spot the dragons that fateful day!)
08:10:00 <Zao> malcolmw: One of these? http://sunstuff.org/hardware/systems/sun4/sun4m/SPARCstation10/sun.sparcstation10.jpg
08:10:24 <Zao> I still have that gridded pad somewhere in storage.
08:12:21 <gwern> 'Tmpk', 'Matrilineality in Judaism', almost sound like you know what they're about, but then you realize you don't
08:14:04 <gwern> (you know, I half suspect Oleg implemented his new probability stuff in ocaml rather than haskell just because it meant he would have to use delimited continuations...)
08:14:48 <gwern> it's a little interesting how many of the external links seem to be on sports subjects, when sports articles are not even close to a majority of new articles
08:21:40 <muiro> hey, I'm a c, java and or ruby programmer and some folks told me I should learn your totally zany and bonkers language. Is this true or were they lieing to me?
08:21:53 <kpreid> muiro: YES!
08:22:17 <muiro> hmm
08:22:21 <kpreid> > tails "YES! YES!"
08:22:22 <lambdabot>   ["YES! YES!","ES! YES!","S! YES!","! YES!"," YES!","YES!","ES!","S!","!",""]
08:23:09 <skorpan> > fix ("YES! " ++)
08:23:10 <dmwit> muiro: Yes, it's true or they were lying to you!
08:23:11 <lambdabot>   "YES! YES! YES! YES! YES! YES! YES! YES! YES! YES! YES! YES! YES! YES! YES!...
08:23:14 <gnuvince> muiro: well, that depends mostly on you, but Haskell is different from most languages out there, so if nothing else, it'll open your eyes to a different way of doing things.
08:23:51 <dmwit> > cycle "Well, yeah, kinda."
08:23:52 <lambdabot>   "Well, yeah, kinda.Well, yeah, kinda.Well, yeah, kinda.Well, yeah, kinda.We...
08:23:52 <muiro> I have links to a few books, one looks silly as hell. I think I'll read that one today and see if I like the feel of it.
08:24:07 <sjanssen> muiro: let me guess, LYAH?
08:24:10 <dmwit> ?where lyah is silly as hell
08:24:10 <lambdabot> www.learnyouahaskell.com
08:24:12 <gnuvince> muiro: the silly as hell one wouldn't happen to be "Learn you a Great Haskell"?
08:24:23 <muiro> mostly I justed wanted to gauge a reaction of a channel full of haskell programmers upon asking that question
08:24:34 <muiro> because do you know what would happen in a channel full of c programmers if I asked that?
08:24:37 <dmwit> Did you expect somebody to say no?
08:24:42 <kpreid> muiro: haskell will stretch your brain
08:24:53 <muiro> c/++: "Go F yourself kid"
08:24:56 <muiro> anyway
08:24:56 <gnuvince> muiro: if you asked whether you should learn C or whether you should learn Haskell?
08:25:00 <muiro> yes, learn you a haskell
08:25:16 <muiro> the title makes me laugh, so I'm going to read it right now
08:25:21 <kpreid> the reaction of the C folks is more because they're the default, I think
08:25:26 <gnuvince> muiro: go with LYAH, great intro, BONUS is a very good writer
08:25:29 <kpreid> so It's A Silly Question
08:25:48 <muiro> no, I didn't expect to hear "no", I just wanted to see the reaction
08:25:48 <gwern> c programmers tend to be cranky
08:25:50 <muiro> I'm sorry I manipulated you. <3
08:25:52 <gwern> don't blame'em
08:26:08 <gnuvince> gwern: what do you expect?  Break their concentration one second and they'll forget a free()!
08:26:11 <kpreid> Has Haskell had any cranks?
08:26:24 <gwern> kpreid: harmless ones like Cale and conal :)
08:26:24 <kpreid> (I do mean cranks, not cranky)
08:26:45 <dmwit> ?protontorpedo
08:26:45 <lambdabot> does haskel work one windows?
08:26:48 <dmwit> ?protontorpedo
08:26:48 <lambdabot> and haskell is general purpose?
08:26:49 <gwern> gnuvince: beat a dog long enough, and it'll snap at anything
08:26:51 <dmwit> ?protontorpedo
08:26:51 <lambdabot> I am banned from like 6 rooms
08:26:54 <gnuvince> kpreid: those guys are scary, especially Cale.
08:27:10 <dino-> gnuvince: Ok, that was hilarious!
08:27:18 <dino-> Some make lamby remember that.
08:27:22 <dino-> Somebody
08:27:24 <dino-> I don
08:27:32 <dino-> In addition to not being able to type, I don't know how.
08:27:53 <conal> gwern: :)
08:27:54 <dmwit> Also, that guy that was convinced the NSA was trying to stop him from developing his advanced mathematics.
08:28:02 <dmwit> What was his nick again?
08:28:20 <dons> for those who didn't see, late yesterday, the Haskell Platform 2009.2.0.1 is now out. http://www.reddit.com/r/programming/comments/8ph8u/the_haskell_platform_2009201_a_standard_haskell/
08:28:26 <kpreid> dmwit: Keal
08:28:32 <gwern> @keal
08:28:32 <lambdabot>  what have you been smoking? you narrow minded Haskell user?
08:28:40 <gwern> @keal
08:28:41 <lambdabot> write an algorthim that generates the correct responses for a phone survey based on number of rings whether answered how quickly hung up on and the mood of the receiver
08:28:43 <dmwit> Yeah, keal.  what a guy
08:29:12 <gwern> @quote qwe
08:29:12 <lambdabot> jmelesky says: I've figured out the problem. qwe1234 has different definitions of "functional programming", "compiler", "complexity theory", "math", and "optimization" than everybody else who deals
08:29:12 <gnuvince> hahaha
08:29:12 <lambdabot> with computers or computer science.
08:29:24 <gwern> @quote qwe
08:29:24 <lambdabot> pjdelport says: [on qwe1234:] It must be a drag, being the sole beacon of sanity in a field where all the established researchers are unanimously insane.
08:29:37 <gwern> @quote qwe
08:29:38 <lambdabot> pjdelport says: qwe1234, boldly defining where no man has defined before!
08:29:41 <gnuvince> That should be a QOTW
08:30:43 <muiro> woah, this is weird
08:32:27 <gwern> <reeves>WHOAH</reeves>
08:33:42 <sjanssen> <reeves>I know lambda calculus</reeves>
08:34:11 <skorpan> comparing strings should generally be slower than comparing constructors, right?
08:34:45 <Botje> yeah
08:34:55 <Botje> ehh
08:34:58 <sjanssen> skorpan: assuming the constructors have no arguments?
08:35:02 <byorgey> muiro: have fun stretching your brain! =)
08:35:02 <Botje> unless they don't share a common suffix, of course
08:35:03 <skorpan> yes, assuming that
08:35:08 <sjanssen> skorpan: yes
08:35:13 <skorpan> great, thanks
08:35:24 <Botje> if you're comparing vs "apple", and "banana" you can still compare in O(1)
08:35:29 <sjanssen> one less dereference in the worst case
08:39:45 <Berengal> Comparing strings also compares constructors...
08:50:37 <gwern>  @hoogle (Monad m) => m a -> m ()
08:50:48 <gwern> @hoogle (Monad m) => m a -> m ()
08:50:48 <lambdabot> Control.Monad forever :: Monad m => m a -> m ()
08:50:48 <lambdabot> Control.Monad replicateM_ :: Monad m => Int -> m a -> m ()
08:50:48 <lambdabot> Prelude sequence_ :: Monad m => [m a] -> m ()
08:51:16 <dmwit> I love hoogle.
08:51:25 <Berengal> hoogle is nifty
08:51:29 <gwern> that's no good. you'd think that for forkIO alone, we'd have something like 'ignore = \x -> x >> return ()'
08:51:51 <gwern> so you could do '
08:51:59 <gwern> forkIO (ignore stuff)
08:52:18 <fasta> gwern: imho, a better solution is to change the type of forkIO
08:52:28 <mux> I don't mind writing forkIO (stuff >> return ())
08:52:28 <burp> how would you make an cyclic permutation of a list?
08:52:29 <lilac> > fmap fmap fmap fmap fmap fmap (+) [1,2,3] <*> [Just 5, Nothing, Just 9]
08:52:29 <gwern> fasta: probably, but everyone would scream
08:52:31 <lambdabot>   [Just 6,Nothing,Just 10,Just 7,Nothing,Just 11,Just 8,Nothing,Just 12]
08:52:34 <Berengal> Agreed with fasta
08:52:47 <fasta> gwern: that's why you define these kinds of things in an Util library.
08:52:55 <fasta> gwern: no need to get approval from anyone.
08:53:08 <gwern> mux: once isn't too bad, but when your code starts to look like 'forkIO (foo bar baz >> return ()) >> return ()', then you start to think maybe this should be factored out
08:53:16 <fasta> gwern: it's the same for when.
08:53:17 <jmcarthur_work> forkIO $ () <$ stuff
08:53:48 <fasta> gwern: also return () == void
08:53:55 <lilac> forkIO $ (>>mzero) stuff
08:53:55 <mux> did  you mean forkIO $ () <* stuff ?
08:53:58 <gwern> :t void
08:53:59 <lambdabot> Not in scope: `void'
08:54:05 <fasta> gwern: something from Util
08:54:12 <jmcarthur_work> > () <$ Just 5
08:54:13 <lambdabot>   Just ()
08:54:18 <mux> :t \f -> (<* f)
08:54:18 <lilac> fasta: return () == mzero for IO
08:54:19 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f b -> f a -> f a
08:54:25 <gwern> fasta: well, the problem is that this wikipedia bot in theory should be usable by non-haskell devs, so even if I would upload a util library to hackage, I still wouldn't use it
08:54:35 <lilac> fasta: perhasp that's what you were thinking of?
08:54:54 <fasta> lilac: I was thinking of whatever I said, I am not sure what you are thinking of.
08:55:00 <mux> :t let ignore f = () <* f in \stuff -> ignore stuff
08:55:01 <lambdabot>     Couldn't match expected type `f a' against inferred type `()'
08:55:02 <lambdabot>     In the first argument of `(<*)', namely `()'
08:55:02 <lambdabot>     In the expression: () <* f
08:55:17 <jmcarthur_work> :t let ignore f = () <$ f in \stuff -> ignore stuff
08:55:18 <lambdabot> forall (f :: * -> *) b. (Functor f) => f b -> f ()
08:55:32 * mux nods
08:55:42 <mux> applicative functors ftw !
08:55:46 <jmcarthur_work> :t let ignore f = return () <* f in \stuff -> ignore stuff
08:55:47 <lambdabot> forall (f :: * -> *) b. (Applicative f, Monad f) => f b -> f ()
08:55:49 * mux leaves work on that happy note
08:55:56 <jmcarthur_work> :t let ignore f = pure () <* f in \stuff -> ignore stuff
08:55:57 <lambdabot> forall (f :: * -> *) b. (Applicative f) => f b -> f ()
08:55:59 <athos> :t (<$)
08:56:00 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
08:56:19 <jmcarthur_work> (<$) = fmap . const
08:57:12 <Berengal> <$ has some nifty uses
08:57:59 <jmcarthur_work> > "yes" <$ "Is <$ cool, or what?"
08:58:00 <lambdabot>   ["yes","yes","yes","yes","yes","yes","yes","yes","yes","yes","yes","yes","y...
08:58:20 <lilac> would have been nicer to have ($>) :: (a -> b) -> f a -> f b, (<$) :: f (a -> b) -> a -> f b, (<$>) :: f (a -> b) -> f a -> f b, IMO
08:59:27 <jmcarthur_work> there are certainly nicer ways than what we have. i would need to think about your proposal a bit before i say i agree with that particular version though
09:00:12 <lilac> basically it's a generalization of ($) where the arrows point to things in functors
09:00:17 <jmcarthur_work> right
09:01:37 <lilac> i've never been very happy with (<$) meaning 'this structure with that value' since $ and <$> are both function application
09:01:46 <jmcarthur_work> agreed
09:07:52 <fynn> So... to install the Haskell Platform, I need to install latest GHC, then the package from http://hackage.haskell.org/platform/ right?
09:08:42 <hatds> ghci question:  say I have an IO [Int] which is a really long list, is there a way to evaluate it and bind it to a result without printing it?
09:09:54 <gnomnain> result <- list ?
09:10:08 <fasta> hatds: rnf
09:10:08 <dmwit> :set -fno-print-bind-result
09:11:57 <Jedai> hatds: Do you mean evaluating it completely ? Then the solution is rnf from Control.Parallel.Strategies
09:12:08 <Jedai> :t rnf
09:12:09 <lambdabot> forall a. (NFData a) => a -> Done
09:12:32 <dmwit> Or compare it for equality with itself as a quick hack. ;-)
09:12:36 <hatds> Jedai: no, I just mean "compute" as in go from IO [Int] to [Int] like ghci does
09:13:13 <Jedai> hatds: Well then gnomnain gave you the answer
09:13:14 <jmcarthur_work> hatds, use functor/applicative/monad stuff
09:13:45 <Saizan> if the problem is not getting flooded at the ghci prompt then you want :set -fno-print-bind-result
09:13:53 <hatds> result <- list still prints it  :/
09:13:55 <Jedai> hatds: you can't extract values from the IO monad, but you can use bind (>>=) to act on them inside the monad
09:13:55 <sm> good morning haskell brothers and sisters
09:13:57 <sm> what is the difference between regex-pcre and regex-pcre-builtin ?
09:14:12 * dmwit wins
09:14:15 <jmcarthur_work> hatds, what do you mean it "prints" it if you aren't in ghci?
09:14:18 <Saizan> hatds: :set -fno-print-bind-result
09:14:20 * sm just tried haskell platform on windows, pretty slick
09:14:23 <hatds> I *am* in ghci
09:14:42 <hatds> :set -fno-print-bind-result, and result <- list don't seem to have an effect
09:14:50 <quicksilver> it bound a name to it
09:14:56 <quicksilver> what were you expecting to see? ;)
09:14:57 <Jedai> dmwit: Yay, you correctly understood the problem (which was quite amazing given the lack of details)
09:15:13 <Saizan> hatds: try "head result"
09:15:37 <dmwit> Jedai: Luck more than anything, once somebody suggested rnf I figured that was the most probable right answer. =P
09:16:03 <dmwit> Maybe :set -fno-print-bind-contents?
09:16:31 <Saizan> no i think you got the flag name right, and ghci will yell if it's wrong
09:16:41 <dmwit> Both flags exist.
09:17:33 <dmwit> But no-print-bind-result works for me, so I'm not sure.
09:18:44 <duaneb> after ghci
09:18:46 <duaneb> and hugs
09:18:51 <duaneb> the ocaml repl seems to be lacking
09:20:12 <hatds> man, none of the flags are work
09:20:17 <hatds> *working
09:21:01 <Saizan> how are you using them?
09:21:02 <dmwit> hatds: Uh... what version of ghc(i)?
09:21:26 * dmwit demands proof in the form of a transcript
09:22:09 <hatds> tried ":set -fno-print-bind-result" for both flags and also using the flags at startup "ghcii.sh -fno-print-bind-contents -fno-print-bind-result"
09:22:33 <sjanssen> hatds: what are the symptoms?
09:23:02 <hatds> sjanssen: evaluating an expression prints it, whereas I want to temporarily disable that
09:23:25 <sjanssen> hatds: are you using "x <- theexpression"?
09:25:30 <hatds> ah, you gotta use the flag and the "x <- " notation togeteher
09:25:32 <hatds> :)
09:25:44 <quicksilver> or you can just do "tehexpression >> return ()"
09:25:58 <quicksilver> then it is of type IO () and ghci won't print the result anyway.
09:26:05 <hatds> yea, but I don't want to bind () to it
09:26:13 <quicksilver> that's not binding anything to anything.
09:26:18 <quicksilver> that's just a way to avoid ghci printing anything.
09:26:28 <fynn> To install the Haskell Platform, I need to install latest GHC, then the package from http://hackage.haskell.org/platform/ right?
09:26:29 <hatds> in my case I do want to bind, just not print
09:26:31 <hatds> :)
09:26:42 <quicksilver> ok, then use x <- as suggested
09:26:45 <quicksilver> ;)
09:28:14 <fynn> Yes?  No?  Nobody ever installs the Haskell Platform? :)
09:28:47 <Jedai> fynn: yes
09:29:05 <kpreid> fynn: give it a lil more than 2 minutes. There may be well be lots of users who just aren't right-here-ready-to-answer!
09:30:17 <fynn> cool, thanks.
09:31:43 <Zao> fynn: I just installed the EXE installer :)
09:32:02 <lament> what exactly does it mean that the haskell platform is blessed?
09:32:27 <fynn> lament: a saint said a prayer over it
09:32:54 <fynn> Zao: well, we're installing it on a bunch of *nix and Mac machine, so... :)
09:34:18 <fynn> lament: also, that website could be better organized
09:34:59 <fynn> You go to http://www.haskell.org/haskellwiki/Haskell_Platform and click on the big image as any reasonable person would do, but rather than let you in, it sends you to a page with some useless information about that image.
09:35:47 <fynn> (it's the fault of the underlying Wiki software to be sure, but still a UI bug)
09:36:20 <gwern> @hoogle Maybe a -> (a -> a)
09:36:20 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
09:36:20 <lambdabot> Prelude asTypeOf :: a -> a -> a
09:36:20 <lambdabot> Data.Generics.Aliases orElse :: Maybe a -> Maybe a -> Maybe a
09:36:39 <gwern> > fromMaybe 6 (Just 5)
09:36:40 <lambdabot>   5
09:37:03 <gwern> :t maybe
09:37:04 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
09:37:47 <gwern> > let archiveBot = undefined in maybe () (archiveBot) (Just "foo"
09:37:49 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
09:38:06 <deech> Hi all, I'm having trouble using HXT to parse an XML document. I have pasted a small program ( http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5538#a5539 ) that reproduces the error. It seems to be in importing the network module. Any ideas? Thanks ...
09:38:45 <gwern> > let archiveBot = undefined in maybe () (archiveBot) (Just "foo")
09:38:46 <lambdabot>   * Exception: Prelude.undefined
09:38:53 <gwern> > let archiveBot = id in maybe () (archiveBot) (Just "foo")
09:38:54 <lambdabot>   Couldn't match expected type `()'
09:39:21 <Zao> fynn: Judging by the documentation on the site, that would be the right approach.
09:39:24 <gwern> > let archiveBot = \x -> id x >> return () in maybe () (archiveBot) (Just "foo")
09:39:26 <lambdabot>   Couldn't match expected type `()' against inferred type `m ()'
09:39:36 <gwern> > let archiveBot = \x -> id x >> return () in maybe (return ()) (archiveBot) (Just "foo")
09:39:37 <lambdabot>   [(),(),()]
09:39:57 <gwern> hm. I guess I'll just leave that case expression alone; maybe doesn't seem any clearer
09:40:07 <quicksilver> deech: you are loading two version of 'network'
09:40:15 <quicksilver> Loading package network-2.2.1
09:40:21 <quicksilver> Loading package network-2.2.1.2
09:40:21 <deech> quicksilver: Yes I know, I don't know why it is doing that.
09:40:32 <quicksilver> because one of your packages dpeneds on one and another depends on another.
09:41:00 <mux> the dreaded diamond dependency problem
09:41:13 <quicksilver> you'll have to compile them all (well all the ones you want to use together) with the latest.
09:41:50 <roconnor> or the earliest
09:45:40 <deech> quicksilver: Ok, so to unregister network-2.2.1 I had to unregister HTTP 4000.0.6. But I was able to re-install HTTP 4000.0.6 without a problem and the problem has gone away. Thanks!
09:53:06 <jmcarthur_work> > let archiveBot = (() <$) in archiveBot <$> Just "foo"
09:53:07 <lambdabot>   Just [(),(),()]
09:53:43 <jmcarthur_work> > (fmap.fmap) (const ()) (Just "foo")
09:53:44 <lambdabot>   Just [(),(),()]
09:55:06 <PeakerWork> OS X is 64 bits right?  Seems ghc says maxBound :: Int  is just 2^31 - 1?
09:55:10 <jmcarthur_work> > (fmap.fmap.const) () $ Just "foo"
09:55:12 <lambdabot>   Just [(),(),()]
09:55:43 <jmcarthur_work> PeakerWork, the ghc binaries for os x seem to only be 32 bit
09:55:50 <PeakerWork> jmcarthur_work: ah, thanks
09:56:17 <fynn> PeakerWork: yeah, Leopard is 64 bit
09:58:22 <sm> fynn, Jedai: I thought the point of the HP is that it includes ghc as well as everything else
09:58:41 <sm> the windows installer certainly does
09:59:38 <Zao> sm: If you're building from source, there's not much you can do.
09:59:47 <sm> ah I see
09:59:53 <sm> bring on the installers!
09:59:54 <Zao> Distribution packages most likely do the Right Thing.
10:00:26 <Zao> sm: I'm unsure, maybe the source package bundles source for the GHC version it wants?
10:00:33 <Zao> sm: So the system one is just for bootstrapping?
10:03:41 <gwern> jmcarthur_work: the actual code looks like 'case foo bar of Nothing -> return (); Just a -> (archiveBot $ baz $ buz a) >> return ()', and maybe just wasn't doing the right thing
10:06:15 <PeakerWork> I like maybeAction :: Maybe a -> (a -> IO ()) -> IO ()
10:06:38 <PeakerWork> maybeAction = flip (maybe (return ()))
10:07:10 <gwern> yeah, but defining maybeAction doesn't shorten my code
10:07:38 <PeakerWork> @type ($>)
10:07:39 <lambdabot> Not in scope: `$>'
10:07:45 <PeakerWork> @type (<$)
10:07:46 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
10:07:51 <PeakerWork> If that's the goal, then replace >> return ()   ()$<  :-)
10:08:01 <PeakerWork> oops, ()<$
10:09:29 <gwern> but then I'd no longer understand it
10:09:51 <jmcarthur_work> sequence_ $ archiveBot . baz . buz <$> foo bar
10:10:02 <gwern> you haskellers with your crazy monads and applicatives; I'm happy just going along with my meager understanding of monads
10:10:04 <jmcarthur_work> where sequence_ comes from Data.Traversable or Foldable or whichever
10:10:15 <jmcarthur_work> @hoogle sequence_
10:10:15 <lambdabot> Prelude sequence_ :: Monad m => [m a] -> m ()
10:10:15 <lambdabot> Control.Monad sequence_ :: Monad m => [m a] -> m ()
10:10:15 <lambdabot> Data.Foldable sequence_ :: (Foldable t, Monad m) => t (m a) -> m ()
10:10:18 <jmcarthur_work> foldable
10:10:32 <edwardk> http://graphics.cs.cmu.edu/projects/scene-completion/scene-completion.pdf is sexy
10:12:09 * gwern would click on that and read but my trackball ball was stolen
10:13:21 <inimino> that's a good excuse :-)
10:14:44 <gwern> well, that and I don't know how to copy-and-paste in screen
10:14:51 <gwern> (probably should learn)
10:15:03 <sm> wow, clever
10:15:08 <sm> (edwardk )
10:15:36 <sm> gwern: forget it, you're never going to figure that out. Use dtach :)
10:15:44 <jmcarthur_work> gwern, does (sequence_ $ archiveBot . baz . buz <$> foo bar) work for your mind? :)
10:16:29 <gwern> sm: but the man page is right there! I'm sure I can figure it out if I just read carefully enough...
10:16:48 <gwern> jmcarthur_work: that handles the case expression itself?
10:16:54 <sm> oh alright, go forth and study
10:16:58 <gwern> :t (<$>)
10:16:59 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:17:03 <inimino> gwern: it's ^[ and then motion keys, and then space, more motion, space again, done
10:17:19 <jmcarthur_work> gwern, if i did my thinking right, that should be the entire thing
10:17:35 <gwern> inimino: and the pasting?
10:17:42 <defun> what is difference of using Map datatype to store pairs or tuples to do the same? When should I prefer one over the other?
10:17:51 <inimino> erm, ^A [, not ^[
10:17:59 <gwern> inimino: yeah, I got that much :)
10:18:03 <inimino> gwern: the pasting is ^A ]
10:18:14 <gwern> ah. that makes sense
10:18:16 <Saizan> defun: a list of tuples you mean?
10:18:33 <Saizan> defun: that lookup is O(log n) instead of O(n)
10:18:35 <gwern> http://graphics.cs.cmu.edu/projects/scene-completion/scene-completion.pdf
10:18:36 <gwern> yay
10:18:51 <inimino> ^.^
10:18:58 <defun> Saizan: yes a list of tuples.
10:19:12 <defun> Saizan what is O(..) mean
10:19:36 <Saizan> defun: it refers to the time cost of the function
10:19:46 <defun> so which is more costly?
10:19:53 <Saizan> defun: the list of tuples
10:19:59 <defun> i see. thanks.
10:20:13 <Saizan> defun: because you'll pay a cost that increases linearly with the length of the list
10:20:23 <Saizan> defun: instead of logaritmically
10:22:50 <FunctorSalad> is there any documentation for this? http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hacanon-light-2008.10.28     -- seems cool otherwise
10:23:36 <FunctorSalad> (not even in the source :()
10:24:40 <dons> Platform out. upmods plz. We need to get the word out about the release. http://www.reddit.com/r/programming/comments/8pih1/the_haskell_platform_2009201_a_standard_haskell/
10:24:48 <dons> also, anyone tried the Mac OSX installer ?
10:25:27 <FunctorSalad> first upvote ;)
10:27:04 <Zao> So that's what those arrows to the left of reddit posts are.
10:27:30 <gwern> I thought those were munchies for when one got hungry
10:28:50 <dons> it was so nice to try the installer on a windows machine, and it just worked.
10:29:06 <Beelsebob> Zao: they're for voting the post up/down
10:29:10 <Beelsebob> i.e. saying you like it or not
10:29:42 <Zao> Beelsebob: So I deduced after seeing dons talking about modding up.
10:29:53 <gwern> I always thought they were for moving a post's count closer to what you thought they should be
10:30:20 <FunctorSalad> "(\n -> [| \action -> action $(n)|])"
10:30:35 <FunctorSalad> slightly confusing me ;)
10:34:16 <EvilTerran> FunctorSalad, \n -> [| ($ $n) |] -- :D
10:34:49 <burp> sandwich
10:36:12 <FunctorSalad> EvilTerran: that would actually produce a clearer splice in this case, since these things get nested...
10:41:00 <jeffersonheard> so I tried installing theHaskell platform on a fresh Windows install and then tried using the Gtk2Hs 0.10.0 installer, and it complains that it can't find GHC...  is there a way to reconcile this without regedit?
10:43:57 <Saizan> jeffersonheard: the gtk2hs installer probably wants an earlier version of ghc
10:44:21 <jeffersonheard> Saizan - I got the versions correct.  that much I'm sure of
10:44:50 <jeffersonheard> it's that the paths the installer looks in for a GHC installtion are not the same as the paths the platform installs in
10:47:26 <Zao> jeffersonheard: gtk2hs is horribly broken.
10:47:35 <Zao> jeffersonheard: Especially with regard to paths with spaces in them.
10:47:56 <Zao> jeffersonheard: I tried for a day or so to hack life into it. It's not meant to be built by mortals :)
10:51:03 <jeffersonheard> I'm not trying to build it, just install it...  I thought "Hey, Haskell platform, great idea" and I'm afraid it's unusable for me right now
10:51:15 <jeffersonheard> I use Gtk2Hs in everything
10:51:45 <PeakerWork> jeffersonheard: what stuff do you write with it?
10:51:55 <Zao> As for installing gtk2hs, it requires 6.10.1 last I checked (yesterday).
10:51:57 <jeffersonheard> Hieroglyph, and everything I write taht depends on it
10:52:02 <Zao> They haven't built any .2 or .3 packages yet.
10:52:11 <Zao> And it's highly non-trivial to build it yourself.
10:52:22 <Zao> And I'm not sure if the author has fixed the finalizer bugs with .2+ yet.
10:52:27 <jeffersonheard> I've built it myself just fine on Linux and Mac.  Not easy on Windows
10:52:48 <jeffersonheard> that is, everythign I write that depends on Hieroglyph
10:52:51 <Zao> jeffersonheard: Building GTK is non-trivial. Building gtk2hs is even more so.
10:52:54 <jeffersonheard> which since I'm a viz guy, is everything
10:52:55 <Zao> (on windows)
10:53:19 <jeffersonheard> yeah, which is why I'm going to have to stick to something that will work with the installer
10:53:22 <jeffersonheard> not a problem
10:53:26 <fracture> anyone here use wxHaskell much on windows?
10:53:28 <jeffersonheard> I've been using cabal for awhile
10:53:57 <fracture> (I have a problem where it pops up errors about comctl32.dll; nothing on the mailing list or faqs about it)
10:54:02 <PeakerWork> all these non-pure toolkits have to be replaced :-)
10:55:24 <jeffersonheard> PeakerWork: I agree, however at some level we've got to build the pure on the non-pure
10:56:19 <fracture> well, also it'd just be nice to have a decent GUI library at all... ;)  (I can't seem to get any of them to work right)
10:56:40 <jeffersonheard> gtk2hs is a pain, but I'm used to programming with it these days
10:56:56 <roconnor> I've used GuiTV for making little GUIs
10:57:06 <roconnor> it depends on wxHaskell
10:57:24 <fracture> I'm suspecting the problems I'm having might be vista-specific
10:57:29 <fracture> dunno though
10:58:04 <jeffersonheard> fracture, I've had luck with gtk2hs on Vista...
10:58:10 <jeffersonheard> haven't tried anything else
10:58:29 <jeffersonheard> actually, surprisingly, OpenGL seems to perform really well on Vista throug hthe Gtkglext
10:58:55 <fracture> yeah... not so sure I'd want to use gtk on windows though
10:59:31 <jeffersonheard> I actually use the gtk part of gtk fairly minimally, though.  I basically just use dialogues and the gtkglext
11:00:30 <Cale> Heh, I'm a crank?
11:00:57 <jeffersonheard> Why hello, Cale!  No, last time I checked you were a green leafy vegetable
11:01:05 <roconnor> Cale: cool
11:01:14 <Cale> jeffersonheard: That's Kale. :)
11:01:21 <roconnor> Cale: do you have a list of scientist who have found no flaw in your proof?
11:01:32 <Cale> (It sounds the same though.)
11:01:34 <Cale> roconnor: haha
11:01:37 <jeffersonheard> Cale: I'm aware ;-) but the consonant was not about to get in my way
11:03:18 <lament> i thought Cale was a straight
11:03:34 <gwern> a straight deuce
11:03:46 <roconnor> Cale: who says you are a crank?
11:05:00 <Cale> roconnor: kpreid asked if Haskell had any cranks, and gwern said "harmless ones like Cale and conal :)"
11:05:11 * Trafalgard didn't realize I had XChat already open :P
11:06:23 <monochrom> It is probably due to advocating . for fmap.
11:07:27 <roconnor> Cale: ah.  Presumably shapr kicked out all the cranks.
11:08:11 <lament> were there any even?
11:08:24 <lament> does smerdyakov qualify?
11:08:44 <roconnor> nope
11:08:50 <Cale> Right, that was the name I was trying to think of... I'm not sure if he's a crank, but he is a bit ill-natured.
11:08:54 <roconnor> he was kicked out for other reasons
11:09:16 <roconnor> presumably keal is a crank
11:09:23 <olsner> what's a crank?
11:09:48 <roconnor> olsner: http://en.wikipedia.org/wiki/Crank_(person)
11:09:50 <monochrom> My idea of a crank is someone who thinks he has the solution to all the world's problems.
11:10:09 <roconnor> "Crank" is a pejorative term for a person who holds a belief that a vast majority of their contemporaries consider false.
11:10:18 <Cale> Keal is as far as I can tell genuinely delusional. It's a bit sad, he's a pretty nice guy when he's on his medication.
11:12:30 <gwern> monochrom: you see why I included conal in my pair
11:13:24 * conal is honored
11:14:32 <Cale> My mathematical logic prof in university at one point said "It's well-known that I'm a quack. I tried to prove that P = NP for quite a few years."
11:14:47 <leimy_> > printf "%0.2X" 10
11:14:49 <lambdabot>   Add a type signature
11:14:54 <Baughn> That's different. Trying to prove it is the same thing as trying to disprove it. :P
11:15:02 <leimy_> > printf "0.2X" 10 :: String
11:15:03 <lambdabot>   "0.2X* Exception: Printf.printf: formatting string ended prematurely
11:15:37 <Cale> Well, yeah, but even working on it directly is a bit strange to begin with, I think.
11:16:16 <leimy_> , printf "%0.2X" 10
11:16:18 <lunabot>  luna: Couldn't match expected type `t -> a'
11:16:38 <leimy_> , printf "%0.2X" 10 :: String
11:16:39 <lunabot>  luna: Couldn't match expected type `t -> GHC.Base.String'
11:17:02 <Axman6> :t printf "%0.2X"
11:17:03 <lambdabot> forall r. (PrintfType r) => r
11:17:15 <leimy_> I am finding that that works in ghci
11:17:23 <leimy_> but that I am not able to get it to behave correctly
11:17:30 <leimy_> it does not print the expected 0A
11:17:32 <leimy_> just A
11:19:04 <Baughn> > printf "%0.2x" 10 :: String
11:19:05 <lambdabot>   "a"
11:19:15 <Baughn> > printf "%3.4x" 10 :: String
11:19:17 <lambdabot>   "  a"
11:19:39 <leimy_> ?
11:19:41 <leimy_> weird
11:19:47 <Baughn> > printf "%3.4d" 10 :: String
11:19:49 <lambdabot>   " 10"
11:19:54 <Baughn> > printf "%3.9d" 10 :: String
11:19:56 <lambdabot>   " 10"
11:20:14 <edwardk> cale: nothing wrong with trying, if nothing else it gives you an appreciation for the subtlety of the problem ;)
11:20:28 <leimy_> > printf  "%2.0X" 10 :: String
11:20:29 <lambdabot>   " A"
11:20:36 <leimy_> That's wrong :-)
11:20:55 <leimy_> it's %<pad>.<width><type
11:21:09 <tetha> well, it is padded, with spaces
11:21:16 <Baughn> > printf "%09d" 10 :: String
11:21:18 <lambdabot>   "000000010"
11:21:20 <leimy_> the 0 means "pad with 0s"
11:21:29 <Baughn> Aha. Right, reading the documentation is good. :P
11:21:33 <leimy_> printf "%02X" 10 :: String
11:21:36 <Cale> edwardk: Sure. :)
11:21:38 <leimy_> oops
11:21:47 <leimy_> > printf "%02X" 10 :: String
11:21:48 <lambdabot>   "0A"
11:21:56 <leimy_> hmmm that works, but isn't what the docs say :-)
11:22:02 <leimy_> nor is it C like :-)
11:22:17 <Baughn> Right you are, but.. well, it works
11:22:33 <Baughn> Probably a bug
11:22:38 <Baughn> (So report it :)
11:22:48 <Cale> edwardk: I think it would be really funny if P = NP, but that the best polynomial time algorithm for an NP-complete problem had some combinatorially large exponent.
11:23:04 <Cale> (Like Graham's number, for example :)
11:23:18 <Baughn> ..that DOESN'T COUNT, then. o_O
11:23:39 <Baughn> Cale: Or perhaps the twenty-symbol busy beaver number?
11:23:43 <Cale> :)
11:23:47 <edwardk> i figure we're more likely to find a nice connection between say BQP and NP than P and NP in my lifetime, but that even there i'm not holding my breath
11:23:55 <tetha> leimy_: how does that not match the documentation of Text.printf? it is "%" followed by "0" for "pad with 0", followed by a num, which is the width, followed by the type, which is x for hex
11:24:13 <leimy_> I think I confused the "." for decimal places over width
11:24:16 <Baughn> tetha: The documentation mentions a period
11:24:19 <leimy_> but C lets you do it either way it seems.
11:24:32 <tetha> Baughn: the period is for separating the width from a precision
11:24:33 <Baughn> Oh..
11:24:33 <leimy_> it's num vs .num
11:24:34 <leimy_> right
11:24:36 <Baughn> Right you are
11:24:42 <leimy_> C just lets you get away with it :-)
11:24:52 <leimy_> so I'm in "undefined territory"
11:25:34 <Baughn> > printf "%02.2f" pi
11:25:36 <lambdabot>   Add a type signature
11:25:39 <Baughn> > printf "%02.2f" pi :: String
11:25:41 <lambdabot>   "3.14"
11:25:55 <Baughn> > printf "%05.2f" pi :: String
11:25:56 <lambdabot>   "03.14"
11:29:04 <EvilTerran> edwardk, my money's on P=NP being independent of the axioms, like AoC
11:29:37 <Elly> is that just your sense of mathematical elegance talking?
11:29:50 <seliopou> lol
11:30:17 <EvilTerran> Elly, i guess so. then there's my evil side that's rooting for a non-constructive proof that P=NP
11:30:51 <edwardk> evilterran: yeah. i think the BQP ?= NP question will hinge on something like a continuum hypothesis
11:31:20 <tetha> hehe, I kind of hope of a constructive algorithm with a proof that all polynomials solving NP-problems must have some really huge degree
11:31:21 <seliopou> supraempirical virtues ftw
11:32:50 <goldenpuffs> is it faster to use b*b instead of b^2 ?
11:32:58 <monochrom> A bit.
11:33:05 <goldenpuffs> why is that?
11:33:15 <tetha> goldenpuffs: dont micro-optimize
11:33:35 <goldenpuffs> tetha: what's wrong with that?
11:33:39 <monochrom> b^2 goes through one more definition to reach b*b. But inlining may very well eliminate it.
11:34:00 <edwardk> @src (^)
11:34:01 <lambdabot> x ^ 0            =  1
11:34:01 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
11:34:01 <lambdabot>   where f _ 0 y = y
11:34:01 <lambdabot>         f x n y = g x n
11:34:01 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
11:34:03 <lambdabot>                       | otherwise = f x (n-1) (x*y)
11:34:05 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
11:34:24 <seliopou> It's like using minimum on a list you always know the length of
11:34:29 <tetha> goldenpuffs: a) the compiler might already do this for you. b) if your bottleneck really is such a multiplication, use a different algorithm or a different language if no better algorithm exists, that will result in far greater speedups
11:34:44 <seliopou> it's a good thing to eliminate when you're concerned with speed
11:36:20 <akamaus> hello all. I'm looking for  "A Recursive do for Haskell: Design and Implementation" paper by   by Erkök and Launchbury . I found  this link in Haskell-Cafe archives, but presently it doesn't work. Does anybody know where to get this paper??
11:36:42 <SamB> akamaus: citeseer?
11:37:03 <edwardk> akamaus I may have it on a flashdrive somewhere if it has vanished off the internet forever
11:37:09 <goldenpuffs> ok thanks for the explanations
11:37:35 <edwardk> rather i may have it on the flashdrive somewhere, and if it has vanished off the internet forever i might be bothered to spend a couple hours looking for it ;)
11:37:54 <SamB> edwardk: you know that right after you find it, it's going to show up again!
11:38:11 <SamB> ... and maybe not just because you uploaded it ;-P
11:38:26 <Berengal> SamB: But if he doesn't it won't
11:38:33 <edwardk> samb: like is difficult like that. i.e. you always find stuff in the last place you look. =)
11:38:44 <edwardk> er life
11:39:50 <Baughn> conal: Before I start searching, I'd like to ask - had you solved the partial time information problem for makeEvent?
11:40:10 <Baughn> conal: That is to say, did it link up with the Ord instance for Improving properly?
11:40:19 <akamaus> SamB, citeseer points there: http://www.ogi.edu/csee/PacSoft/projects/rmb/recdo.pdf
11:40:20 <conal> Baughn: yes, i think so.
11:40:40 <byorgey> akamaus: try http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.6.5172&rep=rep1&type=pdf
11:40:46 <SamB> akamaus: citeseer usually has a download link of their own as well ...
11:40:58 <byorgey> I found it by searching with Google scholar
11:41:04 <SamB> like the one byorgey pasted just now
11:41:51 <edwardk> conal: are you familiar with the WOOT algorithm? i was playing around the other day trying to see if i could use something like that for the 'locally clocked' distributed FRP stuff we talked about forever ago.
11:42:06 <conal> edwardk: never heard of it.
11:42:28 <akamaus> byorgey, thanks a lot
11:42:40 <Baughn> conal: Okay. This should be fun, then..
11:42:51 <Baughn> conal: Since I can't actually find the code. :P
11:42:54 <conal> Baughn: check out makeTVal and its uses (transitively).
11:42:55 <byorgey> akamaus: sure, no problem =)
11:43:15 <aledge> what's the most haskell-y way to implement a list that can be arbitrarily nested?
11:43:28 <conal> Baughn: and i'm not at all satisfied with the simplicity of that code.
11:43:28 <edwardk> conal: http://wooki.sourceforge.net/papers.htm
11:43:34 <SamB> aledge: use a tree
11:43:35 <conal> edwardk: thsx
11:43:36 <SamB> call it a tree
11:43:40 <aledge> you can imagine doing something like List = Empty | Cons (a, List)
11:44:40 <edwardk> conal: you have to view it through really fuzzy lenses to see any application to this space, but as a nice 'eventually consistent' distributed event model it could be interesting.
11:44:43 <aledge> SamB: hm that makes sense
11:44:47 <aledge> SamB: hehe
11:46:09 <edwardk> http://wooki.sourceforge.net/papers/oster06cscw.pdf is a direct link to the most interesting paper they have
11:47:14 <Baughn> conal: Well, I'm having fun debugging joinE. Wish me luck.
11:48:07 <conal> Baughn: glad to hear.  good luck and thanks!  :)
11:57:34 <bentson> Has anyone seen the compiler for pH (as referenced in "Implicit Parallel Programming in pH")?
11:58:20 <Baughn> conal: Oh, and I tried to explain FRP to an imperative programmer, in particular how yours works internally..
11:58:43 <Baughn> conal: He was quite impressed, actually, but decided the model wasn't for humans. ^^;
11:58:45 <Zao> Baughn: I'd reckon one'd get better luck explaining it to an electrical engineer.
11:58:53 <Zao> All those latches and whatnot.
11:59:21 <edwardk> s/humans/people with an ingrained imperative mindset/
11:59:56 <Baughn> Mm. OTOH, it did get him thinking maybe he should learn haskell.
11:59:57 <Zao> Using FRP feels like throwing a bunch of code in a sack, shake and put it on fire.
12:00:11 <FunctorSalad> . o O (instained imperative mindset)
12:00:22 <conal> programmers are also programmees
12:00:32 <Apocalisp> Is there a datastructure for mapping (possibly overlapping) ranges to values?
12:00:43 <Baughn> s/programmers/humans/, and if more people would understand that the world'd be a better place
12:00:47 <Baughn> Apocalisp: Enum
12:00:59 <FunctorSalad> ?
12:01:06 <tony__> whats a .hsc file?
12:01:12 <conal> Baughn: agreed
12:01:17 <Zao> tony__: A .hs file that should be preprocessed with cpp.
12:01:25 <MyCatVerbs> Erk.
12:01:26 <tony__> Zao: oh thanks
12:01:26 <FunctorSalad> Apocalisp: Map (Double,Double) Foo?
12:01:31 <Baughn> tony__: Nononono
12:01:35 <MyCatVerbs> tony__: a .hs file that should be preprocessed with hsc2hs.
12:01:41 <Zao> tony__: http://www.haskell.org/ghc/docs/latest/html/users_guide/hsc2hs.html
12:01:43 <Baughn> tony__: It's a .hs file that should be preprocessed with hsc2hs, which normally also involves cpp
12:01:58 <Zao> MyCatVerbs: Am I confusing it with .chs?
12:01:59 <Baughn> tony__: See also: c2hs
12:02:16 <Baughn> Zao: {-# LANGUAGE CPP #-} works on .hs too
12:02:32 <MyCatVerbs> Zao: c2hs and hsc2hs are different programs that do somewhat similar jobs.
12:02:54 <FunctorSalad> Apocalisp: hmm, I guess you want fast lookup for points inside the ranges
12:03:02 <Apocalisp> FunctorSalad: Yes, exactly
12:03:03 <tony__> interesting
12:03:31 <MyCatVerbs> Apocalisp: you want a mapping from values in a certain range to some other data type?
12:03:52 <MyCatVerbs> Apocalisp: if the values that you are mapping from are dense, that is an array that you are describing. :)
12:03:54 <FunctorSalad> Apocalisp: maybe a sort of decision tree "if x < pivot then search this subtree else this", with the leafs being sets of ranges
12:04:08 <Zao> Handling overlaps sounds like fun.
12:04:13 <FunctorSalad> (the leafs wouldn't be disjoint)
12:04:22 <Apocalisp> Yes, something like (Ord a) => a -> [b]
12:04:27 <Zao> Should the ranges have priorities or is it first/last in that goes?
12:04:54 <FunctorSalad> I think he wants all the ranges inside of which the given point lies
12:05:19 <FunctorSalad> the tree-with-sets-as-leaf would be good for that, don't know if updating it would be efficient
12:05:30 <FunctorSalad> the rebalancing could be a bit messy ;)
12:05:33 * EvilTerran would suggest sth like Map Key (Map Key Val)
12:05:36 <Apocalisp> FunctorSalad: I want all the values associated with the ranges inside of which the given point lies.
12:06:01 <FunctorSalad> EvilTerran: that doesn't let you look up values inbetween ranges
12:06:07 <FunctorSalad> *inbetween endpoints
12:06:07 <EvilTerran> pull out all the elements with first key <x, then all the elements of those with second key >x
12:06:22 <FunctorSalad> does Data.Map let you do that?
12:06:58 <EvilTerran> FunctorSalad, sure, with split
12:07:02 <Apocalisp> split!
12:07:04 <Apocalisp> that's it
12:07:12 <FunctorSalad> nice, didn't know.
12:07:18 <MyCatVerbs> :t Data.Map.split
12:07:20 <lambdabot> forall k a. (Ord k) => k -> M.Map k a -> (M.Map k a, M.Map k a)
12:07:22 <Zao> I'd do it naively with filtering a list of (Range, t) according to a predicate on the input.
12:07:29 <Zao> And then bother to optimize it if needed.
12:07:38 <EvilTerran> > M.split 3 (M.fromList $ zip [0..] "abracadabra")
12:07:39 <lambdabot>   (fromList [(0,'a'),(1,'b'),(2,'r')],fromList [(4,'c'),(5,'a'),(6,'d'),(7,'a...
12:08:23 <Apocalisp> nice, thanks
12:08:40 <Apocalisp> FunctorSalad: How would you do "all the ranges"?
12:09:16 <FunctorSalad> Apocalisp:  like EvilTerran said, with Val := Range
12:09:45 <PeakerWork> cool, binary search trees have many interesting properties that hash tables don't, and yet are relatively less popular in mainstream languages
12:10:12 <EvilTerran> PeakerWork, like the O(log n) split, you mean?
12:10:16 <PeakerWork> yeah
12:11:00 <FunctorSalad> Apocalisp: hmm, wait
12:11:09 <jmcarthur_work> yeah, it's amazing to me how general binary trees really are
12:11:11 <jmcarthur_work> and finger trees
12:11:35 <FunctorSalad> Apocalisp: I think you'd still need sets as values
12:11:54 <PeakerWork> @type let takeBelow = fst . M.split in takeBelow
12:11:55 <lambdabot>     Couldn't match expected type `(a, b)'
12:11:55 <lambdabot>            against inferred type `M.Map a2 a1 -> (M.Map a2 a1, M.Map a2 a1)'
12:11:55 <lambdabot>     In the second argument of `(.)', namely `M.split'
12:12:11 <PeakerWork> @type let takeBelow n = fst . M.split n in takeBelow
12:12:12 <lambdabot> forall k a. (Ord k) => k -> M.Map k a -> M.Map k a
12:12:23 <PeakerWork> @type let takeAbove n = snd . M.split n in takeBelow
12:12:24 <lambdabot> Not in scope: `takeBelow'
12:12:35 * PeakerWork stops flooding :)
12:13:22 <FunctorSalad> Apocalisp: nevermind what I said, I got a bit confused there
12:15:38 * sm wonders if recompiling an app with base4 vs. base3 is likely to affect performance
12:16:23 * FunctorSalad thought you meant number bases...
12:16:41 <sm> heh
12:18:24 <sm> I also wonder, when testing with alternate versions of ghc, when you need to use cabal's --with-hc-pkg flag. -w often seems sufficient
12:19:41 <FunctorSalad> EvilTerran: did you mean to map every lower boundary L to (map every upper boundary U to the value associated with [L,U])? hmm
12:22:15 <FunctorSalad> so you'd split the outer map at the given point and take the top entry of the lower part of the outer map :)
12:23:19 <sayyestolife> so, how's it going with replacing gcc with c--?
12:30:24 <Chemistry> fap fap fap
12:30:44 <FunctorSalad> did you mean: fmap?
12:31:19 <gwern> @hoogle fap
12:31:19 <lambdabot> No results found
12:31:42 <Chemistry> google fap fap fap
12:32:16 <ziman> :t fmap fmap fmap
12:32:17 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
12:33:22 <Chemistry> fap fap fap: the sound one makes when masturbating
12:34:17 <gwern> masturbating? oh that thing you fleshly ones do
12:34:21 <facedown> what if you have noiseless fapping
12:34:28 <gwern> faking fitness, I understand is its function
12:34:34 <Chemistry> then you need to fap fap fap harder
12:34:39 <FunctorSalad> cf "how to be funny, not just stupid"...
12:36:02 <Chemistry> cf?
12:37:10 <gwern> pg 68, ibid.
12:40:14 <fracture> any problem with installing the haskell platform if I have ghc installed already?
12:40:29 <fracture> (maybe I should uninstall ghc and all its foo firsts?)
12:41:22 <Saizan> if you install it from source it's required, otherwise i don't think it'll clash
12:41:33 <Saizan> ghc is required, i mean
12:42:25 <SamB> heck, GHC is required to install GHC from source ;-)
12:43:31 <FunctorSalad> is it seriously floating in the air now with no way to bootstrap it? :)
12:44:19 <mle> FunctorSalad: is C any different?
12:44:40 <FunctorSalad> mle: I don't know
12:45:07 <Heffalump> I doubt it
12:45:11 <mle> Lots of languages require themselves to build.
12:45:12 <sayyestolife> bootstrapping sounds kinky
12:45:16 <Heffalump> except C has more implementations to cross-compile with
12:45:41 <fracture> I distrust compiled languages that don't have at least one implementation in the language itself
12:45:55 <FunctorSalad> I guess it's somewhat true of civilisation in general ;)
12:46:26 <FunctorSalad> or technology
12:48:24 <PeakerWork> fracture: what about total languages? They can't interpret themselves.. I guess they can compile themselves, though
12:48:31 <mib_cm40m336> hi guys!i have a question.is it possible to write a type defintion for example f:: Float-> Float ,then write the function in the ghci shell ?thank you(sorry for my english)
12:48:55 <PeakerWork> > let f :: Float -> Float ; f x = (x/2) in f 5
12:48:56 <lambdabot>   2.5
12:49:07 <PeakerWork> mib_cm40m336: that should work in ghci too
12:52:01 <fracture> PeakerWork: I guess I feel differently about interpreted languages...
12:53:07 <PeakerWork> fracture: interpreter implementations, I supposed you mean, languages that are interpreted can be compiled and vice-versa
12:54:16 <fracture> right...
12:55:46 <mib_cm40m336> thank you.but i have another question:whats the problem whit this: let f :: Double -> Double ; f x=3.0^x
12:55:55 <Berengal> @type (^)
12:55:57 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
12:56:08 <Berengal> mib_cm40m336: Wrong type, see above
12:56:13 <BONUS> use **
12:57:32 <mib_cm40m336> thank you.but why is there two power function in haskell?(sorry im beginner)
12:57:55 <araujo> because haskell is too powerful
12:57:58 <Berengal> mib_cm40m336: There are three, actually, ^, ^^ and **
12:58:02 <Cale> mib_cm40m336: There are three actually. They have different types and correspond to three different definitions in mathematics.
12:58:27 <Cale> mib_cm40m336: (^) works with any type of number for the base, but only admits positive exponents
12:58:37 <jeffersonheard> here's a new one...  I seem to be all over them today... runtime error: "no match in record selector"
12:58:47 <Cale> mib_cm40m336: (^^) works with any *fractional* type of number for the base, and admits negative exponents as well
12:59:37 <Cale> mib_cm40m336: (**) admits arbitrary real number (Floating) exponents but requires the same type of base.
13:00:58 <Cale> Oh, I somehow neglected to mention that (^) and (^^) only allow integer-like exponents
13:01:03 <jeffersonheard> anyone ever seen the No match in record selector error before?
13:01:07 <jeffersonheard> not even sure what it means
13:01:18 <jeffersonheard> I would assume such things would get caught by the type checker
13:01:22 <Cale> jeffersonheard: hmm...
13:01:33 <Cale> jeffersonheard: Is it a panic?
13:01:44 <jeffersonheard> thebigboard: No match in record selector
13:01:45 <jeffersonheard> Graphics.Rendering.Hieroglyph.Primitives.bottomleft
13:01:47 <jeffersonheard> yes
13:01:53 <jeffersonheard> it's an IOException anyway
13:01:54 <jeffersonheard> dies
13:01:58 <Cale> oh, that's different :)
13:02:14 <mib_cm40m336> thanks for your help.
13:02:19 <Cale> You don't see "The impossible happened!" or anything like that.
13:02:24 <jeffersonheard> yeah -- iit's not the impossible happened
13:02:28 <jeffersonheard> right
13:02:34 <jeffersonheard> so no, not a panic
13:02:37 <jeffersonheard> just a weirdness
13:02:39 <Cale> Let's have a look...
13:02:51 <jeffersonheard> you want an hpaste?
13:02:52 <hackagebot> network 2.2.1.3
13:03:19 <FunctorSalad> can I indent stuff in haddock without ">"? (which ignores any further markup)
13:03:41 <Cale> oh, I know what it is
13:03:50 <jeffersonheard> do tell...
13:03:50 <Cale> bottomleft :: Primitive -> Point
13:04:05 <Cale> but only Text values have that field
13:04:26 <Cale> So it means that you applied bottomleft to a Primitive value which was not a Text, I think.
13:05:00 <jeffersonheard> ought to mean that.  only thing I can think of is that I botched the Ord instance for Primitive, though
13:05:59 <Cale> Do you explicitly call bottomleft from thebigboard?
13:06:32 <jeffersonheard> Ah ha
13:06:33 <jeffersonheard> I found it
13:06:36 <jeffersonheard> good old grep
13:06:41 <jeffersonheard> not where I thought I did
13:07:22 <jeffersonheard> thought I was only using it as a record constructor.  I really ought to disambiguate.  I'm standardizing on cartesian plane, so all should be from bottomleft
13:07:32 <Cale> ah
13:07:45 <jeffersonheard> or southwest as it were
13:07:50 <jeffersonheard> will probably change that in a few version
13:08:03 <jeffersonheard> more people are using Hieroglyph now, so I'm going to have to have a deprecation policy
13:08:53 <hackagebot> hack-middleware-cleanpath 0.0.1
13:11:54 <hackagebot> hack-handler-cgi 0.0.2
13:12:17 <Berengal> When will I learn not to start deleting things right away when they don't work?
13:12:55 <hackagebot> hack-handler-fastcgi 0.0.4
13:13:56 <hackagebot> hashed-storage 0.3.2
13:18:32 <BONUS> interesting thing about ContT monad that i figured out: if you have a CPS transformed monadic value (a -> m a) -> m a, the resulting m a can be different than the one returned by the continuation
13:18:44 <BONUS> which is pretty cool, anyone ever taken advantage of this?
13:19:45 <hatds> I've struggled to use ContT practice
13:19:53 <hatds> *in practice
13:19:58 <BONUS> i find this good for using withFile
13:20:42 <BONUS> you can do handle <- ContT $ withFile "foo" ReadMode; lift $ some_big_io_action
13:20:59 <BONUS> and then when the big I/O action is done, the handle will get closed
13:24:42 <hatds> how's that any different than what you can do without ContT?
13:25:08 <BONUS> well without it you do withFile "foo" ReadMode (\handle -> some_big_io_action)
13:25:37 <hatds> does the former offer any advantages?
13:26:07 <BONUS> it pretty much evaluates to the same thing
13:26:27 <BONUS> it might be easier to read if you have many functions that take (\blah -> something) as parameters
13:26:31 <BONUS> where something can get pretty big
13:27:16 <BONUS> or say you want to open like 5 files with withFile
13:27:40 <BONUS> then it might be more readable
13:27:56 <Peaker> BONUS: what might be more readable?
13:27:59 <hatds> ContT is not hat readable to begin with though
13:28:24 <edwardk> BONUS: re the ability to not have to use the continuation or to tweak the result of it. yes, thats actually kind of the point of using Cont(T) =)
13:28:39 <Peaker> Need a composition operator for bracket that tuples up or such the multiple results, like Python's nested (withFile could be composed that way)
13:28:47 <Peaker> (.) composes bracket_ nicely, but not bracket
13:29:14 <edwardk> BONUS: without that, if you can only use the result without inspecting it, as in forall r. (a -> m r) -> m r -- you have the codensity monad! =)
13:29:45 <edwardk> BONUS: (the ability to use alternative 'm r's that you have lying around is what lets you define callCC.
13:30:04 <BONUS> aha
13:30:19 <BONUS> previously i thought that the point of ContT was lifting other monads to ContT
13:30:29 <Berengal> Hah, well what do you know, ripping out the guts of ghc and putting them back in worked relatively pain-free
13:30:32 <BONUS> because >>= ContT doesn't use the underlying monad's >>=, but lift does
13:30:55 <edwardk> if you just lift other monads into it then Codensity is a smaller type that serves that purpose.
13:31:13 <edwardk> Codensity enforces that you never use callCC basically
13:31:22 <BONUS> yeah i guess it's better to use codensity if you do just that
13:31:36 <SamB> what's the point of Codensity?
13:32:06 <BONUS> i was thinking of something like this http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5541#a5541
13:32:55 <edwardk> samb: tightening the asymptotics when you are working with monads with an expensive bind operation (i.e. a binary tree, etc)
13:32:59 <Cale> Odd that the constructor isn't exported. I wonder if that's just an oversight.
13:33:17 <edwardk> cale: of which?
13:33:22 <Cale> Codensity.
13:33:30 <edwardk> cale: oversight =)
13:34:12 <Daimonic> Hail Haskell
13:34:20 <Daimonic> This Summer 2009 - I will return
13:34:20 <Daimonic> :D
13:34:31 <Cale> hehe :)
13:34:45 <edwardk> cale: you can always runCodensity to extract it
13:34:58 <Daimonic> but only, because I failed my exams
13:34:59 <edwardk> but i need to add that to my growing list of stuff i should fix
13:35:15 <Cale> edwardk: Except that doesn't appear to be exported either.
13:35:20 <edwardk> gah
13:35:40 <edwardk> you can er codensityToRan and then pattern match to extract? =)
13:37:05 <Cale> The fix is 4 characters long, shouldn't be too hard ;)
13:37:27 <edwardk> gah, i feel like a sql newb i just fixed a heisenbug that has been plaguing me for two years.
13:38:17 <Cale> Oh?
13:39:09 <edwardk> (i had an update statement that used a select with a left join from the table against itself to copy down some information about the parent into the child (breaking 3rd normal form because its going into an olap database) that would occasionally deadlock on me.
13:39:50 <edwardk> and the reason was i had other transactions that ran updates, so they would grab an upgradeable read lock, and then to get the data from the parents my update statement would grab a read lock, which would be permitted in by the upgradable read of the other update
13:40:07 <hashkool> I've a nasty type problem:
13:40:10 <edwardk> and then it would try to upgrade the read while an upgradable read was being held and deadlock
13:40:29 <edwardk> of course it only showed up under load and on my biggest customers ;)
13:40:34 <hashkool>     Inferred type is less polymorphic than expected       Quantified type variable `d' escapes     In the first argument of `gmapQ', namely `(genf expr)'     In the expression: (gmapQ (genf expr))     In the definition of `xpath': xpath expr = (gmapQ (genf expr))
13:41:19 <Cale> hashkool: Usually that kind of type error can be solved by commenting out your type signature and seeing what's inferred.
13:41:34 <Cale> (or at least, it provides a decent clue)
13:41:35 <hashkool> code is here: http://www.mibbit.com/pb/K8m3pk
13:41:41 <edwardk> so basically two update statements could deadlock because one joined the table against itself and sql server tried to be too slick about parallelizing the tasks
13:42:19 <Cale> heh, strange.
13:42:44 <hashkool>  Inferred type is less polymorphic than expected       Quantified type variable `d' is mentioned in the environment:         genf :: t -> d -> u               In the first argument of `gmapQ', namely `(genf expr)'     In the expression: (gmapQ (genf expr))     In the definition of `xpath': xpath expr = (gmapQ (genf expr))
13:43:02 <Cale> gmapQ requires a polymorphic function as its argument
13:43:02 <hashkool> that's without type signatures :P
13:43:19 <Cale> hmm
13:43:27 <edwardk> patching the offending update statement to always grab the rowlocks from the self-join as upgradeable locks makes the potential deadlock go away
13:43:42 <hashkool> genf :: Data a => [String] -> a -> [a]
13:43:54 <hashkool> is allready polymorphic isn't it?
13:44:00 <edwardk> i realize its completely off topic, but it drove me nuts ;)
13:45:06 <Cale> hashkool: There are actually a number of problems here...
13:45:32 <Cale> hashkool: One is that genf returns xpath expr x in one case, but that has type [[a]] rather than [a]
13:46:25 <hashkool> oh yeah stupid. That's at least one problem
13:46:29 <hashkool> do you expect more?
13:46:30 <Cale> All right, after applying concat there to make up for the difference, and replacing xpath's definition (but not its type signature) with undefined, then the code compiles.
13:46:34 <shepheb> anyone have a favourite example to demonstrate the difference between imperative and functional style?
13:47:03 <Cale> So the problem is that gmapQ (genf expr) doesn't have the type you think it does. Let's look at what type it is.
13:47:19 <Cale> expr :: [String]
13:47:40 <Cale> genf :: [String] -> a -> [a]
13:47:59 <Cale> Er, (Data a) =>
13:48:09 <Cale> genf expr :: (Data a) => a -> [a]
13:48:37 <mholub> I get this http://pastie.org/private/mqsokbhazbwizko4ot0tw when installing hspread (need for happstack). Is this something serious? I don't understand..this is linker warning or error
13:48:46 <Cale> however, gmapQ :: forall a u. (forall d. Data d => d -> u) -> a -> [u]
13:48:54 <Berengal> shepheb: The lack of loops
13:49:05 <Cale> So the type u must be selected before the type d
13:49:12 <Cale> and so it can't depend on the type d
13:49:14 <Berengal> (Might not be a good example, but I like it)
13:49:37 <Cale> So (Data a) => a -> [a] won't unify with that.
13:49:56 <Heffalump> mholub: weird. I don't know.
13:50:00 <doctormach_> mholub: http://hackage.haskell.org/trac/ghc/ticket/2578
13:50:22 <hashkool> I don't really understand "So the type u must be selected before the type d"
13:50:53 <mholub> doctormach_:  thanks
13:51:14 <Cale> hashkool: Well, gmapQ has a higher-rank type, which is a bit fancy...
13:51:44 <hashkool> ghe that's certainly true.
13:52:19 <Cale> gmapQ :: forall a u. (forall d. Data d => d -> u) -> a -> [u]
13:52:37 <Cale> This says that if you select some types a and u, then
13:52:51 <Cale> it takes a parameter of type forall d. Data d => d -> u
13:53:12 <Cale> er, sorry
13:53:19 <Cale> gmapQ :: forall a u. (Data a) => (forall d. Data d => d -> u) -> a -> [u]
13:53:26 <Cale> but anyway
13:53:32 <Cale> it also takes a parameter of type a
13:53:41 <Cale> and gives a list of results of type u
13:54:44 <Cale> But it's going to supply the polymorphic function of type (Data d => d -> u) with values of various types d, and no matter which type it gets, it must produce a value of type u
13:54:52 <Cale> That is, u cannot in any way depend on the type d
13:55:00 <Cale> Is that any clearer?
13:55:37 <Cale> In your case, you're passing a function of type Data d => d -> [d], and since the type of the result depends on the type of the parameter, that's no good
13:56:29 <hashkool> Yeah i am thinking about it. I think I'll get it....
13:56:31 <Cale> Note that it's really important that they all be the same type, regardless of the type d
13:56:44 <Cale> Because the results of type u are all going to be collected into one list
13:57:06 <Cale> so if for various types d, you get different types u, then there's no way you could have them all in one list
13:58:01 <Berengal> Is there a canonical example higher-rank typed function?
13:58:16 <Cale> Berengal: runST is good
13:58:25 <Cale> Though, that's sort of a special case application
13:58:30 <Cale> If you want a simple example...
13:58:47 <Cale> Consider something like...
13:59:01 <Cale> foo f = (f "hello", f [1,2,3])
13:59:04 <Berengal> Cale: runST uses it to restrict, not enable...
13:59:08 <hashkool> yes, but but... I assure that they will get an u (in this case, a value of datatype A)
13:59:55 <Cale> Berengal: It seems intuitive that something like reverse should be a valid parameter to f
14:00:02 <Cale> To foo, rather
14:00:19 <Cale> But in HM, foo is a type error.
14:00:19 <Berengal> Cale: Indeed
14:00:41 <Cale> > let foo f = (f "hello", f [1,2,3]) in foo reverse
14:00:42 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
14:00:43 <lambdabot>    arising from the literal `1...
14:01:06 <Cale> It expects the type of f to be monomorphic (even if it's something to be later generalised by the let)
14:01:35 <Cale> > let foo :: (forall a. [a] -> [a]) -> (String, [Integer]); foo f = (f "hello", f [1,2,3]) in foo reverse
14:01:36 <hashkool> genf takes an a and produces an [a]. So where does haskell think I change its type anyhow. I mean the a in xpath and in genf are really the same
14:01:36 <lambdabot>   ("olleh",[3,2,1])
14:01:57 <Cale> hashkool: If a changes, then [a] changes
14:02:04 <Cale> hashkool: That's the problem.
14:02:32 <Cale> The function parameter to gmapQ must have a result type which is the same no matter what its input type is
14:04:18 <hashkool> yeah but I do not change a.
14:04:24 <hashkool> > :t gmapQ
14:04:24 <lambdabot>   <no location info>: parse error on input `:'
14:04:41 <dons> mac installer for the platform : http://projects.haskell.org/pipermail/haskell-platform/2009-June/000457.html  anyone around to test it?
14:04:43 <hashkool> gmapQ :: (Data a) => (forall d. (Data d) => d -> u) -> a -> [u]
14:04:46 <Cale> hashkool: gmapM f will call f at many different types
14:05:12 <hashkool> would the situation be different when we had
14:05:13 <Cale> hashkool: In particular, it calls f on each subterm of the term you give it.
14:05:44 <hashkool> gmapQ' :: (Data a) => (a -> u) -> a -> [u]
14:06:09 <yitz> dons: tiger ok?
14:06:26 <Philonous> Cale: Does that mean his f is not polymorphic enough in it's first argument?
14:07:02 <Cale> hashkool: very different
14:07:05 <hashkool> Cale: true. gmapM is monadic. But you feel that I could use this one?
14:07:23 <Cale> hashkool: I think you need to reconsider what it is that you're trying to do.
14:07:32 <Cale> What is the goal of this program?
14:07:48 <Cale> Prelude Data.Data> gmapQ (dataTypeOf) (1 :: Integer, "hello" :: String)
14:07:48 <Cale> [DataType {tycon = "Prelude.Integer", datarep = IntRep},DataType {tycon = "Prelude.[]", datarep = AlgRep [[],(:)]}]
14:08:05 <Cale> Prelude Data.Data> gmapQ toConstr (1 :: Integer, "hello" :: String)
14:08:05 <Cale> [1,(:)]
14:08:33 <Cale> (note that 1 and (:) there are values of type Constr, which have a funny show instance ;)
14:08:59 <hashkool> the goal is to give a path which you want to look for in a given value. The program searches the path according to the names of the constructors
14:09:08 <Cale> Prelude Data.Data> gmapQ toConstr (1 :: Integer, "hello" :: String, Just 5, Nothing :: Maybe Integer)
14:09:09 <Cale> [1,(:),Just,Nothing]
14:09:10 <hashkool> something like xpath
14:09:42 <hashkool> in xml
14:10:19 <Cale> So, you want to expect a particular type in the end.
14:10:28 <Cale> and if the result is not that type?
14:10:36 <hashkool> so call would be xpath ["A2", "A1"] (A2 (A1 "foo")
14:10:48 <hashkool> return is  A1 "foo"
14:10:49 <Cale> You'll probably want to have a result which is Maybe
14:11:04 <hashkool> yeah
14:11:07 <hashkool> or an empty list
14:11:18 <Cale> Ah, so return all matching results in a list, okay
14:11:30 <hashkool> yep!
14:11:53 <hashkool> I know we get problems when the value comprises multiple datatypes
14:12:13 <hashkool> so I first look at a function for a single datatype
14:12:25 <hashkool> but that is already very hard seemingly.
14:12:30 <dons> yitz: unknown. ask gcollins in #ghc
14:12:45 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/syb/Data-Generics-Aliases.html -- these functions are important
14:13:19 <Peaker> when does one need these generics?
14:13:53 <malouin> I'm interested in working on haskell's XML/XHTML support.  Anyone know who would be most interested in talking to me about the best way to contribute?
14:14:40 <Cale> Peaker: Generics are useful when you have a polymorphic algorithm which depends only on the structure of an algebraic datatype
14:15:18 <Cale> Peaker: So while you could create a typeclass and implement it once for every datatype you want it to apply to, the implementations would all be structurally similar.
14:16:00 <Peaker> Cale: sounds like a case for auto-deriving rules
14:16:17 <yitz> malouin: the authors of haxml and hxt would be a good start.
14:16:21 <Cale> Right, if we had a way to write auto-deriving rules, then they would use generics.
14:16:29 <yitz> malouin: any specific ideas?
14:16:43 <malouin> yitz: ok.
14:16:55 <hashkool> Cale: yeah these functions seems to be lower
14:16:56 <hashkool> level
14:16:59 <Cale> Peaker: But already, we can derive instances of Typeable and Data, and these are in some sense universal, if a little ugly.
14:17:21 <malouin> yitz: well, the functionality that I can't find is a facility for producing XML that is guaranteed to be valid according to a certain DTD.
14:18:15 <fynn> Trying to build GHC 6.10.3 from source, I'm getting ./configure: line 3317: utils/pwd/pwd: No such file or directory
14:18:25 <yitz> malouin: there's stuff like that out there - but I think there's a lot to be done, have a look.
14:18:37 <fynn> why is that file not there?
14:19:11 <Cale> fynn: Is it really not there, or is it that this program reported that error?
14:19:13 <hashkool> malouin: you can at least parse a certain xml file according to a dtd
14:19:28 <malouin> yes, I am looking for the other direction :)
14:19:37 <fynn> Cale: ~/Downloads/ghc-6.10.3/utils/pwd$ ls
14:19:37 <fynn> Makefile  Setup.hs  pwd.cabal  pwd.hi  pwd.hs  pwd.o
14:19:38 <yitz> malouin: malcomw once came out with something that reflects a dtd into the haskell type system, i forget what it was called
14:19:38 <Cale> fynn: Also, before we continue, what platform are you on, and do you intend to make modifications to GHC itself?
14:19:59 <malouin> ideally with typing mechanisms to prevent the usual over/under escaping bugs when outputting XML
14:20:00 <fynn> OS X, I don't intend to make any modifications, just set a specific installation directory
14:20:26 <Cale> fynn: In that case, the binary package should do. You still get to run the configure script.
14:20:28 <yitz> malouin: yes, there is less for generating than for parsing. see if you can find malcolmw's stuff.
14:20:51 <MyCatVerbs> fynn: just manually ghc --make pwd; IIRC I've hit the same issue myself under strange circumstances.
14:20:53 <fynn> Cale: yeah, but I want to build from source at least once, because some of our servers are running FreeBSD
14:20:53 <Cale> (though I suppose there's a possibility that things are different on OS X.)
14:20:54 <malouin> Ok, thanks a lot!
14:21:00 <MyCatVerbs> fynn: (in that directory, I mean.)
14:21:28 <yitz> malouin: i'm sure the author of hxt has a lot of interesting things to say also, contact him.
14:21:33 <Cale> It appears there's a cabal file there too, so if you have cabal install, you could also cabal build
14:21:39 <fynn> MyCatVerbs: thanks, but ld: library not found for -lgmp
14:21:50 <Cale> fynn: You're missing libgmp
14:21:53 <yitz> malouin: please post your progress :) cafe, or whatever
14:22:06 <malouin> yitz: ok, will do.
14:22:09 <Cale> fynn: Which means that your existing install of ghc will also be broken.
14:22:18 <fynn> Cale: *nod*, but it's actually installed through macports; should I specify the path somehow?
14:22:24 <Cale> (libgmp is required for the Integer type)
14:22:28 <malouin> yitz: I am still in feasibility planning mode, but I will let you know if I come up with anything.
14:22:35 <Cale> I actually don't know how this works on mac...
14:22:41 <malouin> s/ty pl/ty\/pl/
14:22:50 <Cale> http://haskell.org/ghc/dist/6.10.3/GHC-6.10.3-i386.pkg -- start with this though
14:22:59 <Cale> Do you have Xcode 3.0 installed?
14:23:05 <fynn> yeah, I do
14:23:16 <fynn> I'd still like to understand what the issue is, and fix it :>
14:23:41 <fynn> we're planning to deploy GHC on a variety of platforms, if I can't even get it built on my mac then that's a problem.
14:23:47 <Cale> Probably the .pkg installer will come with libgmp if it's not available on OS X by default.
14:24:11 <Cale> You should never compile GHC yourself unless it's absolutely necessary to do so.
14:24:14 <fynn> I have libgmp installed /opt/local/lib
14:24:18 <fynn> *in
14:24:21 <Cale> hmm
14:24:31 <mib_718wke> hi guys
14:24:32 * fynn looks back at the log
14:24:33 <Cale> So the problem is that ld doesn't appear to know about that path
14:24:38 <fynn> I bet configure fiound it
14:24:41 <fynn> Cale: yup.
14:25:05 <yitz> hi mib_718wke
14:25:06 <Cale> mib_718wke: hi anonymous mibbit user! ;)
14:25:20 <mib_718wke> hi haha
14:25:44 <mib_718wke> I had a compiling problem
14:25:59 <mib_718wke> what is the library -lSM called?
14:26:19 <Cale> SM?
14:26:49 <mib_718wke> the llinker says it cannot find -lSM
14:26:58 <Cale> mib_718wke: Could you give a little more context? What are you trying to compile?
14:27:19 <mib_718wke> Im compiling an opengl program
14:27:44 <mib_718wke> actually compiling the nehe tuts from hackage
14:28:15 <Cale> I have that library as /usr/lib/libSM.so.6.0.0 on my machine
14:28:56 <MyCatVerbs> It's an Xorg library. Apparently the Xorg Session Management library.
14:29:13 <mib_718wke> yep I find it
14:29:34 <mib_718wke> im running on cygwin, so I didnt installed
14:29:55 * Beelsebob wands libBD.so.6.0.0 too now
14:29:57 <Beelsebob> wants*
14:30:25 <Cale> BD?
14:30:34 <Cale> oh, I get it
14:31:49 <MyCatVerbs> I don't. libBD?
14:31:56 <MyCatVerbs> Oh, wait.
14:32:00 * MyCatVerbs thwaps Beelsebob.
14:32:18 <Beelsebob> lol
14:32:25 <mreh> can someone suggest simple 2d graphics library for haskell?
14:32:29 * Beelsebob loves how everyone is going "huh?"
14:32:32 <mreh> HGL is broken
14:32:33 <Beelsebob> and then suddenly twigging
14:32:39 <MyCatVerbs> Beelsebob: git.
14:32:39 <Beelsebob> mreggen: OpenGL
14:33:05 <mreh> OpenGL for simple graphics
14:33:06 <yowgi> mreh: gd ?
14:33:13 <Beelsebob> OpenGL for any graphics, yes
14:35:35 <fracture> ugh... I really wish there were a select api in haskell
14:35:50 <Cale> fracture: What do you need it for?
14:35:51 <fracture> a bunch of forkIOs is a lot more complex to reason about
14:35:58 <Cale> hmm
14:36:06 <fracture> doing some interaction with a tty and a socket at the same time
14:36:19 <fracture> it'd be so nice in haskell too... no FD_SET nonsense
14:36:24 <fracture> just a list of handles returning a Maybe Handle
14:36:30 <Cale> It's possible to ffi import select, but I'm not sure that's really the best answer.
14:36:43 <mreh> SDL is more complete in comparison to DirectX though
14:36:53 <mreh> openGL has no sound for instance
14:37:08 <fracture> I'm also not exactly sure this will work with this readline-esque lib I got
14:37:12 <fracture> (trying now though)
14:37:22 <p_l> SDL is more portable, but DirectX has much wider scope, afaik
14:37:24 <fracture> but basically I'm going to have one thread calling their read-a-line function while another might be printing
14:38:30 <Cale> You should easily be able to write an abstraction which uses forkIO and hWaitForInput to deliver the first in a list of handles which has input available.
14:38:54 <mathijs> Hi all, I posted a message on haskell-cafe this morning, but didn't get any replies yet. Not that I'm impatient, but I'm kind of eager for some feedback :)  can anyone have a look at http://groups.google.com/group/haskell-cafe/browse_thread/thread/518c3726668ed57c? It's a question about having a data structure (like Data.Tree) mandating some structure _and_ payload rules.
14:39:09 <fracture> one thread per handle, eh?
14:39:13 <Cale> fracture: yeah
14:39:17 <Cale> fracture: threads are cheap
14:39:18 <fracture> yeah... maybe I'll do that
14:39:26 <fracture> well, certainly more expensive than select() :)
14:39:34 <Cale> Probably not actually.
14:39:42 <Cale> Threads are astoundingly cheap.
14:40:01 <fracture> I don't see how it could possibly be as cheap as calling select directly
14:40:08 <fracture> at the very least, the runtime has to allocate some information about each thread
14:40:35 <fracture> anyway I'm mainly complaining because this is an extremely common task in day to day programming
14:40:38 <Cale> Yeah, there's a small datastructure associated to each thread, but istr it was something like 24 bytes.
14:41:03 <fracture> it feels like ... haskell's making many hard things easy, but some extremely easy things unnecessarily hard :)
14:41:16 <fracture> got ya
14:41:21 <Cale> This really isn't so bad :)
14:41:32 <Cale> The OS has to allocate its own resources to do a select anyway.
14:41:46 <Cale> So I'm not certain :)
14:42:01 <fracture> yeah; it has to be less than this though
14:42:07 <fracture> probably not important for my current situation
14:42:43 <Cale> Oh, wait, what do you mean by Maybe Handle?
14:42:53 <Cale> Is there a timeout?
14:42:59 <fracture> sure, could be
14:43:09 <fracture> select takes 3 sets of file descriptors and a timeout
14:43:14 <fracture> (IIRC)
14:44:27 <Heffalump> fracture: it's making things like select compositional
14:44:30 <Heffalump> surely that's a good thing?
14:45:08 <fracture> I don't see how that makes it any more compositional
14:45:09 <Cale> Yeah, normally you'd just do things in multiple threads and not worry about which handle has stuff available first.
14:45:51 <Heffalump> fracture: the thing doing the select has to know about every handle something might want to wait on
14:46:40 <fracture> sure...  but it's not like you can't still do a threaded approach if you have a N-handle select call when it makes sense
14:46:55 <Heffalump> ok, I guess the RTS could offer that hook too
14:47:16 <Heffalump> but it'll still need to merge them in with whatever any other threads are doing
14:48:33 <fracture> just how concurrent are the RTS's threads?
14:48:42 <fracture> can you be pre-empted in the middle of anything pretty much?
14:49:33 <jmcarthur> fracture: well, constructions and pattern matches are atomic, afaik
14:49:43 <jmcarthur> and thunk evaluation
14:50:08 <jmcarthur> although the same thunk could be evaluated multiple times in different threads if they try
14:50:18 <jmcarthur> (i think)
14:50:23 <roconnor> um pattern matching is immutable, it doesn't really make sense to say this is atomic or not
14:50:38 <roconnor> only state changing matter for atomicity
14:50:50 <jmcarthur> roconnor: right, but without looking at the implementation, it's important to understand that the semantics are atomic
14:51:11 <jmcarthur> roconnor: plus, pattern matching forces thunks
14:51:35 <jmcarthur> anyway, the point is that pure semantics is preserved
14:52:29 <Cale> fracture: Anything except for an FFI call, and all the basic I/O stuff uses nonblocking I/O under the covers to allow it to be pre-empted.
14:54:19 <Cale> Well, actually, a tight loop which does no allocation whatsoever can be a problem due to the way that GHC's runtime system works, but these are pretty much restricted to contrived examples from what I understand.
14:55:17 <Philonous> Cale: If you encounter this case you can alwys just throw a yield in
14:55:18 <Heffalump> cale: or code that got optimised into a tight loop
14:55:26 <Heffalump> Philonous: how?
14:55:38 <Berengal> Cale: sum foo where foo is already fully evaluated?
14:55:43 <Philonous> Oh wait, you weren't talking about IO code, where you
14:56:27 <Cale> Berengal: That's still going to allocate new integers.
14:56:33 <Cale> (or numbers of whatever type)
14:56:48 <Berengal> Cale: You sure? Even when optimized?
14:56:54 <Heffalump> not if you write a sum to use an accumulating parameter that gets unboxed, surely?
14:57:40 <Berengal> @src sum
14:57:41 <lambdabot> sum = foldl (+) 0
14:58:06 <Berengal> For Ints that looks like a tight loop to me...
14:58:23 <Berengal> At -O2
15:00:10 <Cale> actually, I can't seem to get it to happen even with contrived examples now
15:03:50 <fracture_> yeah, this forkIO approach won't work with the readline-esque library (haskeline)
15:04:02 * dancor tired of manually downloading things to remove thier parsec < 3 constraints
15:04:13 <Cale> fracture_: What is the effect you're trying to acheive?
15:04:15 <fracture_> calling it's printer while another thread is waiting for the user to type doesn't print anything until the user presses enter
15:04:45 <fracture_> I want line-editing on a prompt while my program might still be printing things
15:04:58 <fynn> Cale, MyCatVerbs: I fixed that problem.
15:05:16 <fracture_> this would be somewhat hard in their library anyway, I guess... it looks a bit less mature than readline (which I think can process just "some input" from the tty fd)
15:05:17 <idnar> fracture_: I guess you want something more curses-like then
15:05:23 <fracture_> this guy only has a get-a-whole-line function
15:05:24 <Cale> Ah, right, it wasn't designed to do that. You can print things while the user enters text, but it's tricky to get it to work in a way which is not a mess.
15:05:28 <fynn> export LIBRARY_PATH=/opt/local/lib:$LIBRARY_PATH
15:06:46 <Cale> I expect the first thing you'd need to do is turn off echo on stdin, and handle displaying that text yourself.
15:07:37 <fracture_> well, basically I'd need to write my own line editing is what it sounds like
15:07:43 <fracture_> or import readline somehow if that is doable
15:07:54 <Cale> Does even readline allow for that?
15:07:59 <fracture_> pretty sture
15:08:01 <fracture_> err sure
15:08:11 <fracture_> I think you have something like readline_fd that gives you the file descriptor so you can select on it
15:08:24 <Cale> There is a binding to readline
15:08:33 <fracture_> (been a while since I've played with it... pretty sure I did something like this though in an NNGS client I made)
15:09:17 <fracture_> so if I were to do it without that though, for sake of understanding, how do you coordinate the user-input thread and the network-or-whatever thread that can be producing output?
15:09:28 <Cale> But I don't think I've ever seen a simple readline program doing any printing while the line was being edited.
15:10:02 <fracture_> wish I had that program here to look at what I did...
15:10:23 <dancor> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/haskeline-0.6.1.6
15:10:29 <Cale> Well, I'd have the main thread handling the screen I/O, and then additional threads handling network connections and filling a Chan or something with text to displat.
15:10:31 <dancor> that is a rewrite instead of a binding to readline, right?
15:10:32 <Cale> display*
15:10:36 <Cale> dancor: yes
15:10:44 <Cale> There is *also* a binding to readline itself.
15:10:52 <Cale> But it is of course GPLed.
15:11:04 <dancor> so haskeline might be a good place to start if you need to do something crazier
15:11:10 <fracture_> so there'd be a screen thread, a thread blocking on getting a character, and then the net thread
15:11:18 <fracture_> the screen thread blocks on a chan
15:11:27 <Cale> (It's the licensing issue combined with editline's suckiness which caused haskeline to come into existence)
15:11:33 <fracture_> which uses some datagram that tells the screen thread whether it is sending user input or network input
15:11:35 <fracture_> eh?
15:11:41 <dancor> ya editline was bad for me
15:11:45 <travisbrady> I'd like to improve performance on some haskell I've written that uses lots of lists.  So far I've got some strictness annotations in there, but after reading http://bit.ly/PmMLe I'm thinking I should consider using arrays.  Where do I start?  I'm thinking I'd have to fully rewrite everything since I make heavy use of (x:xs) matching and other list ops
15:11:59 <fynn> Heh, GHC throws a ton of deprecation warnings while being built.
15:12:22 <Cale> travisbrady: You should also consider using Data.Map and/or Data.Set
15:12:51 <dancor> IntMap in particular
15:12:57 <byorgey> fynn: that makes sense, actually, since you generally want to make sure that a self-hosting compiler will still compile with the oldest possible version of itself.
15:12:57 <travisbrady> Cale: are those strict?
15:13:08 <Cale> travisbrady: In the structural components.
15:13:13 <hackagebot> atom 0.0.5
15:13:14 <Cale> travisbrady: But not in the elements.
15:13:24 <fracture_> ok so the readline way is actually that you just call rl_callback_read_char() every time you realize there is input available from the terminal
15:13:26 <travisbrady> for my use case a list makes sense, i'm encoding a tour for the travelling salesman problem
15:13:35 <byorgey> IIRC you can still compile GHC with something like GHC 4.
15:13:44 <byorgey> or maybe it's 5.x now.
15:13:52 <fracture_> (has a setup and teardown function for that usage mode too)
15:13:52 <Cale> travisbrady: How do you manipulate such tours?
15:14:28 <Cale> travisbrady: Is there a lot of concatenation?
15:14:40 <dancor> does that mean ghc 4 still gets like security updates
15:14:40 <travisbrady> i need to be able to shuffle them to generate random tours, to do subtour reversal, to combine two tours greedily choosing edges from each
15:15:04 <Cale> travisbrady: If you need lots of random access, then lists are bad.
15:15:10 <byorgey> dancor: I doubt it, but maybe it should.
15:15:24 <travisbrady> Cale: yeah, i'm using !!, the code is here incidentally http://github.com/travisbrady/shabonkie/blob/d34f2f0e493376071dd266aeaa5856b731df3764/GA.hs
15:15:55 <Cale> oh, yes, that looks very troubling
15:16:08 <travisbrady> haha
15:16:09 <Cale> elemIndex is O(n) and then !! is another O(n)
15:16:28 <Cale> So every time you use getNextCity, it traverses the list twice
15:16:35 <travisbrady> btw this was written over a weekend some time ago in an attempt to learn Haskell
15:16:56 <travisbrady> yeah, getnextcity is terrible, i've got a port of this in OCaml where getNextCity is much more sensible
15:17:23 <Cale> Maybe storing the tour as a Map a a would be more sensible?
15:17:44 <Cale> That is, a map from the city you're at to the next one.
15:18:00 <Cale> I suppose that doesn't work for reversal.
15:18:05 <Cale> So you'd need two maps.
15:18:42 <Cale> Well, depending on how often you reverse...
15:19:10 <Cale> It's possible to reverse a Map representing a tour like that in O(n log n) time.
15:19:45 <Cale> But if you maintain the reversed map as you go, then that obviously is avoided.
15:21:06 <travisbrady> i'd considered that but couldn't really conceive of how to reverse a subtour
15:21:13 <fynn> OK, fun.
15:21:13 <fynn> I fixed a few other problems, and now I'm getting:
15:21:13 <fynn> ghc-6.10.3/libraries/Cabal/dist-bootstrapping/build/libHSCabal-1.6.0.3.a, archive has no table of contents
15:21:20 <fynn> from ld.
15:21:33 <fynn> it almost seemed like it's going to build this time.
15:21:57 <Cale> travisbrady: Well, first getting a map corresponding to a given subtour takes O(k log n) time, where k is the length of the subtour and n is the number of elements in the larger tour
15:22:44 <fynn> Looks the same as this output: http://hackage.haskell.org/trac/ghc/attachment/ticket/3137/make.output
15:22:57 <Cale> travisbrady: and then to reverse it, you can use Map.fromList . map (\(x,y) -> (y,x)) . Map.toList
15:23:51 <Cale> fynn: What version of GHC do you already have installed on the machine?
15:24:09 <fynn> Cale: 6.10.2
15:24:51 <Cale> I wonder what all the stuff about bootstrapping is...
15:26:03 <Zao> fynn: Got an 'ar' on the box?
15:27:06 <Cale> travisbrady: That is obviously somewhat expensive, but if you simply carry around a reversed version of every tour at the same time as you build it, then you can avoid that.
15:27:56 <sm> what's that +RTS flag to show where a Prelude.undefined error is generated ?
15:28:12 <fynn> Zao: hm?
15:28:18 <Cale> sm: Compile with -prof -auto-all and run with +RTS -xc
15:28:31 <sm> oh it needs -prof eh.. thank you
15:29:09 <Cale> sm: It uses the cost centres to tell you where it was generated.
15:29:58 <Cale> But, it's usually just easiest to grep the code for undefined...
15:37:19 <Saizan_> or you can use the ghci debugger
15:41:34 <Peaker> Saizan_: that thing is usable?
15:42:45 <Saizan_> i've used it a few times to find where an exception were coming out
15:43:07 <Peaker> Saizan_: do you have a blog? I think I tried using it a few times and didn't undesratnd what was going on
15:43:50 <FunctorSalad> it seems most exception have sourcelocs lately
15:44:00 <Saizan_> :set -fbreak-on-exception RET :trace expression RET  ??? RET PROFIT
15:44:43 <Saizan_> FunctorSalad: even the ones like "Prelude.head: empty list" ?
15:44:51 <Saizan_> Peaker: no blog, no
15:45:33 <FunctorSalad> Saizan_: hmm, that one now
15:45:35 <FunctorSalad> *not
15:45:48 * Peaker fires up emacs to keep that debug session somewhere, but by the time its up, kinda lose interest :(
15:45:54 <Saizan_> though if the exception comes from deep in compiled code you won't get much informations
15:45:56 <Peaker> computers suck :-(
15:46:24 <FunctorSalad> Peaker: did you try -xc? if it's just to find the error location
15:46:30 <FunctorSalad> +RTS -xc
15:46:36 <Peaker> FunctorSalad: what does that do?
15:47:08 <Peaker> maybe pure exceptions should have been disallowed - that would have forced people to put stuff in Maybe/Either/ErrorT's where they should have
15:47:09 <fynn> Can I compile GHC without Cabal until they fix that build issue?
15:47:24 <FunctorSalad> Peaker: prints the cost center stack on failure (you need to compile with "cabal --enable-[executable|library]-profiling"
15:47:30 <FunctorSalad> )
15:47:43 <Peaker> FunctorSalad: thanks
15:47:59 <FunctorSalad> you can add your own cost centers with "{-# SCC "foo" #-}" :)
15:48:50 <Peaker> aren't functions already cost centers?
15:49:39 <olsner> not sure that's the best thing always... div :: Int -> Int -> Maybe Int :S
15:49:48 <Peaker> olsner: what's wrong with that?
15:49:58 <periodic> Hrm... thinking lazilly is hard when you're not used to it.
15:50:11 <periodic> I'm trying to write astar in haskell and keep getting stack overflows.
15:50:18 <FunctorSalad> Peaker: you can do that with -auto or -auto-all or -caf-all (don't ask me what exactly the diff is)
15:50:50 <olsner> at least I wouldn't want to have to fromMaybe for every division
15:50:50 <Peaker> olsner: I'd very much like that
15:50:55 <FunctorSalad> but it's in order of increasing number of generated cost-centres
15:51:06 <Peaker> olsner: Why? Put your result in a Maybe and use >>= and fmap
15:51:42 <Saizan_> @wiki Stack overflow
15:51:42 <lambdabot> http://www.haskell.org/haskellwiki/Stack_overflow
15:51:46 <Saizan_> periodic: ^^^
15:51:57 <olsner> though I'd very much like div :: Int -> Int { /= 0 } -> Int or something similar, if the type system allowed such constructs
15:52:00 * tibbe_ 's ugly kqueue binding finally does something
15:52:17 <tibbe_> @seen bos
15:52:17 <lambdabot> bos is in #haskell-in-depth, #ghc and #haskell. I last heard bos speak 16h 31m 6s ago.
15:52:33 <FunctorSalad> olsner: doesn't that imply full-on dependent types?
15:52:41 <olsner> probably :)
15:52:52 <periodic> Saizan_: thanks.  Trying to figure out where I've built up too many thunks or whatever.  Right now I'm starting to think I have runaway recusion instead.
15:52:57 <FunctorSalad> but I agree it would be cool... maybe the proofs could be optional
15:53:35 <bos> tibbe_: hey
15:54:00 <olsner> or, of course, automatic :) but I don't know to which extent the system would be able to usefully infer x /= 0 for common code
15:54:06 <tibbe_> bos: so I have the ugliest kqueue wrapper possible doing something
15:54:23 <bos> tibbe_: i like the description :-)
15:54:27 <tibbe_> bos: as an experiment
15:54:40 <fynn> bos: it is rumored that you know everything and can fix every problem
15:54:55 <fynn> maybe you want to fix my GHC build issue? :>
15:55:18 <tibbe_> bos: so, while I have you on the line. so you also think we should try to build our own event loop?
15:55:34 <tibbe_> bos: still busy with some book deadline? saw a tweet that suggested that
15:55:52 <bos> tibbe_: it's the middle of my work day at the moment
15:55:59 <FunctorSalad> olsner: I'm pretty optimistic - it will fail for anything complex, but many errors like that are in boilerplate code...
15:56:09 <bos> tibbe_: i have a magazine deadline, but that's nearly done
15:56:12 <tibbe_> bos: ok, i'll drop you an email once I have something to show
15:56:15 <FunctorSalad> (the automatic proving, I mean)
15:56:18 <bos> tibbe_: sweet
15:56:21 <bos> fynn: heh, i wish
16:01:45 <periodic> If I have a function written for foldr, but want to use it in a foldl, is there an easy way to switch the arguments?
16:02:40 <byorgey> periodic: flip
16:02:45 <byorgey> @type flip
16:02:46 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
16:03:29 <periodic> ah, that's the one, thanks byorgey.  Searching for topics on "reverse" doesn't help much.
16:03:45 <byorgey> heh, yeah, 'reverse' is for lists. =)
16:11:50 <Peaker> periodic: why would you want foldl?
16:13:32 <Peaker> would it break Haskell to have symmetric handling of let bindings and argument bindings, in terms of type unification?
16:13:59 <Peaker> I mean, what would be the problem with having let-like type-semantics for function argument bindings too?
16:14:52 <hatds> what
16:14:59 <hatds> what's the difference in type semantics?
16:17:56 <Peaker> @type let x = show in (x,x)
16:18:15 <Twey> Bad timing :-P
16:19:03 <Twey> What's with all the netsplits lately *grumbles*
16:19:51 <Peaker> hatds: if you let blah = show   it can get show's type.  (blah, blah) or (show, show)  gives you:  (Show a, Show a1) => (a -> String, a1 -> String)
16:20:19 <FunctorSalad> anyone familiar with hacanon here?
16:20:22 <Peaker> hatds: if you have:  f x = (x, x) ;  the type of "f show" is   Show a => (a -> String, a -> String)
16:20:45 <FunctorSalad> (I'm wondering how to deal with C functions which want callbacks)
16:21:17 <FunctorSalad> it doesn't seem to have a DIS that handles FunPtrs
16:29:07 <Peaker> hatds: basically, the function's type is something like:   forall a. Show a => a -> (a, a)   when it could have been:  (forall a. Show a => a) -> (forall b c. (Show b, Show c) => (b, c))  -- the type of the arg is unified with the type of the results, even though it could be forall'd further
16:29:41 <Peaker> I wonder what this kind of change would do to Haskell
16:29:45 <hatds> Peaker: I think it would break something like  f x@1 = (x,x), f x = (x,x)
16:30:06 <Peaker> why?
16:30:32 <hatds> the result can't have type Num a, Num b => (a,b)
16:30:40 <hatds> because it does case analysis on the argument
16:31:40 <Peaker> hatds: it does (==1) there
16:32:05 <Peaker> hatds: but the "x" there could be completely polymorphic for the function, so it could return two values that are equally polymorphic
16:32:11 <Peaker> rather than equal
16:32:44 <Peaker> Haskell args usage creates values of equal types, rather than values that are equally polymorphic types
16:32:59 <Peaker> the forall is put outside, instead of copied into each
16:34:18 <fynn> So GHC generally compiles Haskell to C, which gcc then compiles to executable?
16:34:28 <MyCatVerbs> fynn: not any more.
16:34:37 <Peaker> AFAIU, even -fvia-c doesn't really do that
16:34:51 <hatds> what does it do?
16:34:51 <fynn> MyCatVerbs: OK, so what's the situation right now?
16:34:57 <MyCatVerbs> fynn: it used to kind of at one point, and it still has the code to do that, but it usually isn't used any more.
16:35:00 <inimino> I thought that's what -fvia-c did?
16:35:20 <fynn> MyCatVerbs: so it compiles directly to object code now?
16:35:33 <fynn> i.e. a machine-language executable?
16:35:39 <MyCatVerbs> By default, the -fasm backend is used now, which is pure Haskell code and outputs object code.
16:35:48 <fynn> OK, hm
16:35:57 <fynn> My ulterior motive here is to try to bridge Haskell and Python
16:36:03 <Peaker> fynn: Why?
16:36:20 <Peaker> if I understood correctly -fvia-c generates code that is not really valid C, but good enough to pass through gcc, whose result is then used somehow
16:36:24 <Peaker> (manipulated further)
16:36:29 <fynn> Initial plan assumed Haskell compiles to C files, which I can then call from Python via the usual Python=>C bridges
16:36:51 <MyCatVerbs> The -fvia-c backend does a complicated little dance - AIUI, it compiles Haskell to C, runs gcc -s on the C, then puts the resulting assembly through the evil mangler (a horrifying Perl script).
16:36:53 <Twey> fynn: You can call Haskell from C
16:36:56 <p_l> Peaker: Or maybe you would be surprised to find how many things are valid C (Duff's device, anyone?)
16:36:59 <fynn> Peaker: the vast majority of our company's codebase is Python, and we'd like to keep it that way
16:37:14 <Twey> So you can call Haskell from Python, too
16:37:28 <MyCatVerbs> fynn: what you'll want to do is write a Python extension module which calls the Haskell code from C.
16:37:40 <fynn> MyCatVerbs: hehe, but at least you seem to say that path is hardly ever used any more and is sort of deprecated really?
16:37:58 <MyCatVerbs> fynn: or you could use ctypes/equivalend with Haskell's C FFI.
16:38:03 <thoughtpolice> -fvia-C used to be the default
16:38:20 <MyCatVerbs> thoughtpolice: er, -fvia-C used to be the default with the optimizer switched on.
16:38:28 <fynn> isn't it quite a leap, from generating C to straight object code?
16:38:44 <MyCatVerbs> At -O0, AIUI -fasm has always been the default.
16:39:05 <MyCatVerbs> fynn: No, not really. The leap is going from generating object code to generating *good* object code.
16:40:05 <MyCatVerbs> fynn: -fvia-C isn't really deprecated yet, but it makes compilation much slower than using -fasm, and -fasm is starting to generate better object code than -fvia-C.
16:40:37 <jmcarthur> i'd say they are mostly on par, right now
16:40:56 <jmcarthur> worth trying one or the other for each project
16:42:57 <fynn> MyCatVerbs: it's still impressive if GHC can now generate object code that can compete with gcc
16:43:25 <thoughtpolice> the native code gen has gotten much better over the years
16:43:33 <thoughtpolice> hopefully the NEW native code backend should be even better :)
16:43:45 <fynn> when would that be released?
16:43:58 <thoughtpolice> ghc 6.12 hopefully
16:46:56 <hermanChess> haskell or scala?
16:47:44 <Apocalisp> In what context?
16:48:18 <fynn> which would kick us?
16:48:24 <fynn> heh, (ass
16:48:25 * Twey chuckles.
16:48:42 <Twey> Well... do you like Java?  :)
16:48:52 * Apocalisp hearts Java
16:49:05 <hermanChess> I'm studying java currently, I'm in this mental state of looking for other languages to learn
16:49:17 <Apocalisp> in that case, learn Haskell
16:49:21 <hermanChess> so I'm between scala, python, haskell interests me too
16:49:32 <Cale> hermanChess: Scala is nice if you're restricted to the JVM, but Haskell still seems like more fun to me.
16:49:35 <fynn> MyCatVerbs, thoughtpolice: but it's safe to say that -fvia-C is in the process of getting deprecated?
16:49:54 <SamB> then again, Python can be nice on the JVM too, can't it ?
16:50:04 <fynn> hermanChess: Python vs Scala/Haskell are very different
16:50:09 <fynn> SamB: not really, no
16:50:33 <fynn> if you really want to use the JVM, you probably want Scala more than Jython
16:50:43 <hermanChess> Haskell compiles into an executable like c++ ? or is  it interpreted?
16:50:46 <fynn> unless you're a hardcore Python fan or something.
16:50:47 <Twey> fynn: There's a brief example of Haskell->Python FFI here: http://wiki.python.org/moin/PythonVsHaskell
16:50:49 <Cale> hermanChess: It's both
16:50:53 <SamB> well, it's not for if you really WANT to use the JVM so much as if you have no choice ...
16:51:05 <fynn> Twey: cool thanks.
16:51:07 <Twey> (at the bottom of the page)
16:51:11 <SamB> it's probably at least handy for trying stuff out quick ...
16:51:19 <Apocalisp> hermanChess: Haskell makes you think in ways that other languages don't. It's all to easy to get away with writing Java-like code in Scala. Learning Haskell first will improve your Scala fu when the time comes.
16:51:25 <Cale> hermanChess: The main compiler, GHC, comes with GHCi which contains a (bytecode) interpreter.
16:51:47 <hermanChess> I see
16:51:49 <Cale> hermanChess: There are also other compilers and interpreters for it, but they are more experimental in nature.
16:51:59 <fynn> SamB: my impression is that you have a pretty good chance of integrating Scala seamlessly into a Java shop, while the same isn't true of Jython (and probably other dynamic JVM languages as well)
16:52:16 <fynn> i.e. it's probably not true for Clojure or JRuby as well.
16:52:21 <SamB> does scala have a REPL ?
16:52:26 <hermanChess> and in what situations is haskell used mostly?
16:52:36 <fynn> yeah, only startup time is slow as crap :)
16:53:07 <Twey> hermanChess: Situations where you want a good language.  :-P
16:53:13 <Cale> hehe
16:53:24 <fynn> so, don't use it if you want a bad language, you hear?
16:53:26 <hermanChess> What's the best place to start?
16:53:38 <Twey> (and don't need to eke the most possible performance out of the code — Haskell is fast, but it's not yet at the top of the list as far as speed goes)
16:53:41 * fynn chuckles and refers to the Gentle Introduction
16:53:58 <Twey> hermanChess: Well, you're obviously familiar with programming, so I'd suggest RWH
16:54:04 <SamB> also, situations where it isn't too much trouble to get the compiler installed where it's needed
16:54:07 <Twey> http://book.realworldhaskell.org/
16:54:19 <Cale> Yeah, it's general purpose, so there's not really a set of applications which it is specifically geared to. There are some particularly nice libraries for parsing, it is great at concurrency and parallelism (and this situation is rapidly improving), and it also tends to be really good at combinatorial optimisation problems in my experience.
16:54:22 <Twey> You can buy it or read it online
16:54:42 <hermanChess> Awesome thanks
16:54:44 <Apocalisp> I found that the Clean tutorials were actually better for learning Haskell than Gentle Intro.
16:54:45 <Cale> Also, there's...
16:54:48 <Cale> @where lyah
16:55:00 <Cale> oh, is lambdabot down?
16:55:06 <Twey> She got netsplit
16:55:09 <Apocalisp> @where lambdabot
16:55:09 <Cale> ah
16:55:11 <Apocalisp> doh!
16:55:18 <jmcarthur> thanks, freenode
16:55:21 <Cale> http://learnyouahaskell.com/ anyway
16:55:22 <Twey> Gentle Intro confused the heck out of me when I was learning
16:55:39 <jmcarthur> i learned from yaht... not the greatest
16:55:49 <Peaker> YAHT was Ok. Its Monad section helped a lot
16:55:49 <Twey> LYAH has less practical stuff than RWH.  You could maybe mix-and-match them.
16:55:50 <Cale> The gentle intro is only gentle if you're rather accustomed to pain.
16:55:56 <mauke> preflex: store lyah http://learnyouahaskell.com/
16:56:05 <Twey> I never got monads from YAHT
16:56:12 <Twey> Cale: Haha
16:56:13 <Peaker> Cale: yeah, and calling it Gentle may scare people off, too
16:56:34 <Twey> ‘This is the *gentle* version?!  What must the real thing be like?’
16:56:53 <Berengal> I learned the syntax and basic elements from the wikibook, then bootstrapped myself using project euler...
16:57:01 <Cale> Perhaps it's gentle in the same sense that "A Modest Proposal" is modest.
16:57:07 <Peaker> I did manage to learn from the "Gentle" one, mostly, except Monads which I got when I implemented the State monad
16:57:18 <Twey> Hahahaha
16:57:25 <SamB> Cale: but it then fails to deliver on the implicitly promised humour
16:57:43 <fynn> I finally understood monads at about the time I proved P=NP
16:58:03 <Cale> heh
16:58:17 <jmcarthur> the entire world will understand monads when _|_
16:58:23 <Peaker> Implementing a couple of Monads really helps
16:58:46 <Cale> Learning parsec is what made the monad abstraction click for me.
16:58:50 <mauke> preflex: quote duqicnk
16:58:51 <preflex>  <duqicnk> a monad is like a train that runs backwards in time, which is made of tiny chocolate robots
16:59:01 <Boney> Twey: When I started learning haskell that was my exact thought about the gentle introduction.
16:59:07 <fynn> Peaker: I actually implemented Monads in Python, sort of.
16:59:14 <Berengal> Cale: I wrote my own parser instead :)
16:59:19 <Peaker> fynn: is it really useful?
16:59:22 <fynn> So for two days I though I understood them, and it wasn't a big deal
16:59:26 <Berengal> That's when I got it...
16:59:29 <Peaker> fynn: I saw a wiki page with Monad implementations in lots of languages
16:59:31 <fynn> and then yeah, I saw how they were used in Haskell
16:59:40 <Boney> Peaker: yep, same.
17:00:00 <fynn> Peaker: the kind of limited stuff you can do with them in Python probably means you don't really understand them
17:00:11 <Cale> fynn: A big hint about whether you've properly implemented them is whether you can write a piece of code and have it work polymorphically with any monad.
17:00:19 <Cale> If you can, then you've done it right.
17:01:35 <Cale> If not, then you've done something like implemented one particular monad (or a few). The abstraction is only useful if you can have an equivalent of Control.Monad around.
17:01:43 <Peaker> fynn: You can have a "duck-type-class" in Python with >>= (__irshift__) and a class-method "return"
17:02:19 <Peaker> and then it can work on any value that happens to have those duck-type-class methods
17:02:21 <Cale> return is actually the tricky part
17:02:35 <Cale> because it's polymorphic in its result type
17:03:01 <Peaker> yeah, you need to take in a class and use a class-method, much like type-classes translate to taking in a vtable/dictionary
17:03:04 <Berengal> return would have to be some magic class of its own which calls __return or something when bound
17:04:29 <Peaker> Data.Binary.Get  uses "fail" in the Get monad which uses pure exceptions.  It could be nice to have polymorphic fail there, but if you give it any (MonadGet m) then any transformer you have around Get needs a MonadGet instance too, causing the O(N^2) transformer instances problem.. any idea how this could be solved elegantly?
17:04:34 <Berengal> a >>= b | a instanceOf return = b.__class__.return(a.val) >>= b
17:05:06 <Berengal> (sorry for mixing syntax... it's been so long since I've done anything but haskell, anything else feels unnatural)
17:05:42 <Twey> Woah
17:05:53 <Twey> Heh, oh
17:06:13 <mauke> sub liftM { my ($M, $mf, $mx) = @_; $M->{bind}($mf, sub { my ($f) = @_; $M->{bind}($mx, sub { my ($x) = @_; $M->{return}($f->($x)) }) }) }
17:06:27 * Twey threatens mauke with an axe
17:06:30 <Berengal> augh!
17:06:33 <Berengal> My eyes!
17:06:37 <mauke> FATALITY
17:06:45 <fynn> lol@Perl
17:06:47 <Twey> Hahahaha
17:06:56 <Twey> Truly
17:07:20 <Peaker> Some people say Haskell operators sometimes look like Perl.  This kind of code reminds us that they aren't quite THAT bad :)
17:07:29 <luqui> come on, be fair.  ->bind instead of ->{bind} at least
17:07:48 <mauke> ->bind is pointless
17:07:57 <Peaker> mauke: taking a type-class dictionary explicitly?
17:08:01 <mauke> yep
17:08:05 <Peaker> cheat
17:08:14 * Twey twitches.
17:08:42 <luqui> i think explicit dictionary passing is a better solution than trying to half-assedly piggyback on OO features
17:09:46 <Berengal> luqui: How about full-assedly piggybacking?
17:09:48 <mauke> def liftM(M, mf, mx): return M["bind"](mf, lambda f: M["bind"](mx, lambda x: M["return"](f(x))))
17:09:57 <FunctorSalad> Peaker: obviously we should use 20-character method names for elementary operations instead of operators
17:10:00 <mauke> hmm, python wins here because the functions are trivial
17:10:02 <FunctorSalad> :-(
17:10:11 <Peaker> FunctorSalad: false dichotomy..
17:10:31 <FunctorSalad> Peaker: I wasn't making a dichotomy, I was ranting against certain languages ;)
17:10:40 <kpreid> I think it is *possible* to make return happen in the absence of type inference by deferring the instantiation of it until you compose it with some other monadic action (of a known type)
17:10:48 <Saizan_> Peaker: have you seen mmtl?
17:10:56 <Peaker> FunctorSalad: Python has better naming than Haskell, IMO. Also simpler indentation rules (but I'm not sure how they could apply to an FP)
17:11:04 <kpreid> At least, I wrote a Haskell interpreter that managed to work that way for trivial cases.
17:11:06 <Peaker> Saizan_: nope, what's that?
17:11:11 <kpreid> (I should publish that...)
17:11:31 <Peaker> Saizan_: you referring to the MonadGet problem?
17:11:38 <Saizan_> Peaker: yes
17:12:04 <sm> I'm following http://haskell.org/ghc/docs/latest/html/users_guide/hpc.html , and not finding the .hpc directory
17:12:18 <Peaker> Saizan_: What's mmtl? How does it solve the N^2 instance problem?
17:12:28 <Peaker> Saizan_: Maybe Get itself should be in MaybeT, always, given its primitive operations use fail?
17:12:41 <sm> I do --make -fhpc, then run the resulting binary - that should save tix files somewhere, am I right ?
17:12:55 <Saizan_> @hackage mmtl
17:15:12 <Saizan_> Peaker: it solves it with a richer MonadTrans and a single lifting instance per class
17:15:15 <FunctorSalad> is beta reduction always correct in haskell? barring unsafe*
17:15:30 <Peaker> Saizan_: ah, cool
17:15:52 <Peaker> Saizan_: is its ListT also not broken?
17:16:07 <Saizan_> Peaker: i don't remember
17:16:24 <FunctorSalad> (actually I'm just beta reducing some template haskell splices for readability so it doesn't matter ;))
17:16:41 <Saizan_> btw, if python had TCO you could implement only the Cont monad and piggyback everything else on it
17:16:42 <Cale> FunctorSalad: It should be
17:17:02 <Cale> FunctorSalad: But it may affect performance.
17:17:07 <Cale> Depending on how you do it.
17:17:08 <idnar> Saizan_: why do you need TCO?
17:17:17 <FunctorSalad> Cale: yes, sharing...
17:17:42 <Cale> FunctorSalad: But if you use let to reflect the sharing, then there's no problem.
17:18:00 <idnar> Saizan_: if it's just to avoid blowing the stack, you can probably simulate it with generators and an appropriate trampoline; although it'll be a bit ugly...
17:18:50 <Saizan_> idnar: heh, ok
17:19:01 <goldenpuffs> is there a symbol for infinity?
17:19:16 <mauke> ∞
17:20:18 <goldenpuffs> can you use that in haskell?
17:20:31 <jrick> last [1..] ;)
17:20:33 <goldenpuffs> to compare to other numbers?
17:20:37 <dolio> If you implement TCO by hand, you don't need TCO. :)
17:21:15 <FunctorSalad> goldenpuffs: you can, but it is an operator character
17:21:34 <hatds> could use maxBound, goldenpuffs
17:21:37 <FunctorSalad> goldenpuffs: so you need to put ( ) around it if you want to use it as a constant...
17:22:02 <Saizan_> goldenpuffs: if you're dealing with floats you can use (1/0) as infinity
17:22:06 <Saizan_> > 1/0
17:22:18 <sm> so nobody's doing code coverage with -fhpc ?
17:22:40 <dolio> I used it on uvector-algorithms.
17:23:04 <dolio> You need to run the program to generate the tix file, I think.
17:23:17 <sm> dolio: did you just build with -fhpc, run the program, and it made a .hpc dir containing tix files ?
17:23:32 <goldenpuffs> cool thx
17:23:47 <sm> mine isn't generating any .hpc or .tix
17:24:40 <hatds> is there a common way of phrasing the difference between a function that is defined in a class declaration versus a function that is only overloaded on that typeclass?
17:25:35 <Saizan_> the first is a class method while the second is only polymorphic with a typeclass constraint?
17:25:48 <hatds> ah, 'class method', thanks
17:26:13 <dolio> sm: I compile with -fhpc, I run the program, and then I do 'hpc markup <program>'.
17:26:32 <Peaker> so, would it break Haskell if function arguments were fully polymorphic? I think maybe its right to say they'd be 2nd rank polymorphic
17:26:35 <sm> dolio: and step 2 generates a .tix file ?
17:26:46 <Peaker> are there really good reasons for function args not to be?
17:27:03 <FunctorSalad> syb is really neat sometimes. TH beta reduction in 13 lines ;) http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5546#a5546
17:27:25 <sm> this is weird
17:27:35 <dolio> sm: I'm not sure. Let me see...
17:27:40 <FunctorSalad> (I'm sure there are some corner case bugs there)
17:28:37 <FunctorSalad> (er, 13 short lines. otherwise it wouldn't be very remarkable)
17:29:26 <dolio> What's it look like in uniplate?
17:29:34 <sm> ah! I should have cleared the old .o files. Thanks dolio
17:29:54 <dolio> Ah, yeah. That'll do it, if you're not using -fforce-recomp.
17:31:55 <Botje> FunctorSalad: don't you want go (f x1) at the last line? :)
17:32:02 <Botje> or at least go x1
17:33:34 <FunctorSalad> Botje: right, thanks! apparently my example case needed only 1 or 2 passes ;)
17:34:44 <FunctorSalad> Botje: hmm wait, the current version is correct, just inefficient
17:34:51 <FunctorSalad> I wanted go x1
17:34:55 <Botje> yeah, so go x1:)
17:40:09 <sm> I see.. the .hpc dir containing mix files is generated at build time, and the tix file in the current dir at run time
17:44:37 <sm> dolio: is -fforce-recomp still supported ? I don't find it at http://www.haskell.org/ghc/docs/latest/html/users_guide/flag-reference.html
17:44:49 <dolio> As far as I know.
17:46:54 <dolio> -fforce-recomp is 4.17.9
17:48:30 <sm> doh! I am losing it
17:48:36 <sm> and I was typing --force-recomp
17:48:42 <sm> --fforce-recomp. thanks
17:51:23 <FunctorSalad> sm: one dash only
17:51:35 <sm> yup
17:53:14 <dolio> Yeah, it's the -f option with force-recomp parameter, or something.
17:53:17 <dolio> Is how you justify it.
17:53:26 <dolio> Although ghc breaks that convention elsewhere.
17:53:53 <fynn> Twey: btw, why did you make a point of mentioning Haskell isn't fast, earlier?
17:54:05 <Twey> I didn't
17:54:10 <Twey> In fact I specifically said it was fast
17:54:37 <Twey> It's just not one of the fastest options available (yet)
17:54:46 <Twey> (for most uses)
17:54:50 <fynn> From benchmarks I've seen, it doesn't look like there's a lot of faster choices out there...
17:55:06 <fynn> only C/++.
17:55:09 <Twey> So if you need to squeeze the last possible drops of performance out of something, you'd probably be better off going with C
17:55:28 <fynn> yeah... but that might be the only exception =)
17:55:35 <fynn> btw, did you use Python with Cython?
17:55:37 <Twey> Heh
17:55:44 <Twey> Pardon?
17:56:03 <Twey> Oh, a successor to Pyrex
17:56:14 <fynn> there's a library called Cython, that compiles Python to efficient C (*Some limitations apply)
17:56:16 <fynn> yeah...
17:56:16 <Twey> No, I didn't know it existed.  I've never done high-performance stuff in Python
17:56:31 <fynn> you didn't use Pyrex either then, I take it
17:56:35 <Twey> And I suspect I switched to Haskell before it came out :)
17:56:38 <Twey> No, but I looked at it
17:56:56 <fynn> Cython offers quite the speedup for a few type annotations.
17:57:02 <ik> has anyone done high-performance stuff in python?
17:57:04 * ik runs
17:57:29 <Twey> ik: Yeah, Ruby programmers!
17:57:34 <ik> hahaha
17:57:43 <fynn> for example, you can reliably get a x200-300 boost for integer calculations just by annotating a function as taking integers.
17:57:54 <fynn> ik: well, with Cython (or plain C) you can
17:57:57 <Twey> fynn: Impressive
17:58:17 <ik> fynn: just a dig, I really haven't kept up with the state of python lately
17:58:46 <fynn> yeah, I'm a bit surprised it didn't make serious headlines already
17:59:06 <p_l> I heard of people doing scientific stuff, but not really HPC
17:59:27 <fynn> thinking of a benchmark like the Shootout, you can basically bounce Python to the top of the table with an extra 4-5 lines of code in most cases.
18:00:04 <FunctorSalad> how do I get the TH Name of an operator?
18:00:28 <dolio> , '+
18:00:29 <lunabot>  luna: parse error on input `+'
18:00:37 <dolio> , ''+
18:00:38 <lunabot>  luna: parse error on input `+'
18:01:24 <FunctorSalad> , Prelude.'+
18:01:25 <dolio> , '(+)
18:01:25 <lunabot>  luna: parse error on input `+'
18:01:26 <lunabot>  GHC.Num.+
18:01:34 <FunctorSalad> hmm thought I tried that
18:01:52 <FunctorSalad> , '(>>=)
18:01:53 <lunabot>  GHC.Base.>>=
18:02:04 <FunctorSalad> doesn't work here...
18:02:25 <dolio> Do you have -XTemplateHaskell enabled?
18:02:28 <dolio> ' and '' are magic.
18:02:35 <FunctorSalad> yep
18:02:38 <Twey> What's the difference between them?
18:02:44 <FunctorSalad> '' is for types
18:02:44 <Twey> , ''(+)
18:02:46 <lunabot>  luna: Not in scope: type variable `+'
18:02:46 <Twey> Oh
18:03:51 <dolio> I don't know. "main = print '(+)" works here.
18:04:28 <Cale> , '(+)
18:04:29 <lunabot>  GHC.Num.+
18:04:57 <FunctorSalad> hmm it works at the toplevel but not inside this expression I have :)
18:05:24 <aconbere> so, this might be a dumb question. But a monad provides order to computation, is there a analog to map in the monadic world, the provides a sequence of computational steps as opposed to a list?
18:05:57 <SamB> aconbere: mapM_ ?
18:06:38 <Twey> sequence?
18:06:44 <Twey> Oh, no
18:06:50 <Twey> You do want mapM(_)
18:07:45 <FunctorSalad> dolio: oh, figured it out. I can't put names into a pattern ;)
18:07:54 <dolio> Oh, yeah.
18:13:39 <duaneb> I have a list of Maybe Bool
18:13:40 <duaneb> s
18:13:52 <duaneb> any good way to use `all' with it?
18:14:03 <roconnor> what do you want to do with the nothings?
18:14:08 <roconnor> @type catMaybes
18:14:33 <roconnor> @bot
18:14:34 <lunabot>  :)
18:15:00 <duaneb> roconnor: return a nothing
18:15:13 <duaneb> basically, I want
18:15:15 <kpreid> @type all
18:15:22 <kpreid> erf
18:15:27 <roconnor> duaneb: so if there is one Nothing in the list you want to return Nothing?
18:15:30 <duaneb> (a -> Maybe Bool) -> [a] -> Maybe Bool
18:15:41 <kpreid> that's called sequence
18:15:42 <duaneb> err
18:15:49 <roconnor> duaneb: maybe you should give us some sample inputs and outputs
18:15:53 <duaneb> (Maybe a -> Maybe Bool) -> [Maybe a] -> Maybe Bool
18:15:55 <kpreid> wait, no, that's MapM
18:16:10 <kpreid> Or, no it isn't
18:16:13 <hatds> mplus
18:16:15 <hatds> :)
18:16:20 <kpreid> Do you really have a Maybe a -> Maybe Bool function?
18:16:31 <duaneb> roconnor: all' [Just True, Just False, Just True] = Just True, all
18:16:33 <duaneb> sorry
18:16:39 <duaneb> err
18:16:40 <kpreid> Anyway, you can use sequence :: [Maybe Bool] -> Maybe [Bool] for one step.
18:16:45 <duaneb> that was meant to be Just False
18:16:50 <duaneb> sequence?
18:16:50 <duaneb> ok
18:16:52 <hatds> looks like all . msum, perhaps duaneb?
18:16:57 <kpreid> all' = and . sequence
18:17:02 <duaneb> I don't know msum
18:17:05 * duaneb looks up msum
18:17:11 <roconnor> kpreid: is right
18:17:14 <duaneb> gah
18:17:17 <duaneb> I hate hugs
18:17:20 <kpreid> it's not msum, it's sequence
18:17:22 <roconnor> although this is a bit of an odd function.
18:17:24 * duaneb hugs ghci
18:17:35 <kpreid> with respect to success/failure, msum is "or" and sequence is "and"
18:17:38 <dolio> , [$ty| and . sequence |]
18:17:40 <lunabot>  luna: Exception when trying to run compile-time code:
18:17:46 <dolio> , [$ty| fmap and . sequence |]
18:17:48 <lunabot>  forall a . (Functor a, Monad a) => [] (a Bool) -> a Bool
18:18:27 <kpreid> ah yeah. and has to be lifted into the maybe
18:18:33 <roconnor> Prelude> :type fmap and . sequence
18:18:34 <roconnor> fmap and . sequence :: (Monad m, Functor m) => [m Bool] -> m Bool
18:18:50 <hatds> ah yea, not msum then :)
18:19:07 <kpreid> it's interesting just how many different 'obvious' functions you can write on [Maybe Bool] -> Maybe Bool
18:19:41 <kpreid> if Djinn worked on lists I'd ask it what it would do
18:21:00 <roconnor> duaneb: you realize if you have one nothing in your list, you will end up with nothing.
18:22:23 <Berengal> roconnor: Assuming Nothing = False in this context: isJust <*> fromJust
18:22:59 <Berengal> (&&) <$> ...
18:23:47 <Ferdirand> would it make sense to define Bool as Maybe () ?
18:24:18 <hatds> usually it reads better to use an actual Bool
18:24:33 <dolio> They're (roughly) isomorphic.
18:24:54 <Berengal> Appart from bottoms
18:24:58 <dolio> () = 1, Bool = 2, Maybe a = 1 + a, Maybe () = 1 + 1 = 2.
18:25:32 <Ferdirand> and there's this annoying dissymetry of join
18:25:53 <roconnor> Berengal: I'd expect he want catMaybes
18:26:04 <roconnor> only he knows :)
18:26:08 <Berengal> Bool = False | True | _|_, Maybe () = Nothing | Just () | _|_ | Just _|_
18:26:32 <duaneb> I just rolled my own function :P
18:26:37 <duaneb> it's less brain explosion
18:26:44 <roconnor> aww
18:26:50 <roconnor> you don't get to learn sequence
18:27:14 <roconnor> sequence is awesome cause it does everything.
18:27:21 <dolio> Yeah, but we ignore bottoms. :)
18:27:27 <dolio> Because fast-and-loose reasoning is morally correct.
18:27:40 <roconnor> , sequence [(+1), (*2), (`div` 3)] 6
18:27:42 <lunabot>  [7,12,2]
18:27:43 <Absolute0> How can I enforce a monad type on a simple return x expression?
18:27:46 * fynn is slightly uneasy about the fact that he couldn't compile GHC on his own 
18:27:56 <Berengal> dolio: Usually I would agree with you, but I like bottoms :)
18:28:04 <roconnor> , sequence [[1,2],[3,4],[5,6]]
18:28:05 <lunabot>  [[1,3,5],[1,3,6],[1,4,5],[1,4,6],[2,3,5],[2,3,6],[2,4,5],[2,4,6]]
18:28:07 <Absolute0> return 5::Maybe fails
18:28:21 <fynn> I'm fairly sure GHC doesn't build on *BSD without some serious hacks.
18:28:27 <Absolute0> > (return 5)::Maybe
18:28:41 <Berengal> Absolute0: Maybe isn't a type, it's a type constructor
18:28:46 <Absolute0> > (return 5)::Maybe Int
18:28:52 <Absolute0>  > (return 5)::Maybe Int
18:28:55 <Berengal> Also, lambdabot is dead...
18:29:00 <Berengal> :(
18:29:01 <Absolute0> ehh
18:29:02 <Absolute0> :)
18:29:09 <Absolute0> ok that works anyways
18:29:10 <Absolute0> thanks
18:29:11 <Absolute0> :)
18:29:30 <Absolute0> what is the purpose of the >> operator it seems to simply return the second parameter
18:29:43 <Berengal> Absolute0: It also runs the first
18:29:49 <roconnor> , Nothing >> Just 5
18:29:50 <lunabot>  Nothing
18:29:58 <duaneb> fynn: don't worry about it
18:30:03 <duaneb> nobody actually builds ghc
18:30:04 <roconnor> , "hello" >> "world"
18:30:05 <lunabot>  "worldworldworldworldworld"
18:30:06 <Berengal> putStrLn "hello" >> doStuff
18:30:10 <Absolute0> (>>) :: (Monad m) => m a -> m b -> m b
18:30:25 <fynn> duaneb: well, we're considering the usage of GHC in production
18:30:30 <fynn> so that's kind of scary.
18:30:33 <roconnor> , Left "hello" >> Right "world"
18:30:35 <lunabot>  Left "hello"
18:30:45 <roconnor> , Right "hello" >> Right "world"
18:30:47 <lunabot>  Right "world"
18:30:56 <Absolute0> , Just 5 >> Just 6
18:30:57 <lunabot>  Just 6
18:31:07 <Absolute0> that's the example i originally played with.
18:31:12 <Absolute0> so there is a function in play...
18:31:15 <Absolute0> what does it do?
18:31:26 <roconnor> , Nothing >> Just 5
18:31:28 <lunabot>  Nothing
18:31:43 <Berengal> a >> b = a >>= \_ -> b
18:31:46 <sjanssen> fynn: production for you is BSD?  Yeah, that platform gets less love from the GHC team
18:31:47 <Berengal> That's the default
18:32:06 <roconnor> Berengal: not only that any non-default needs to be equivalent to that
18:32:11 <sjanssen> fynn: but I'm not so sure about "serious hacks"
18:32:37 <Berengal> roconnor: Indeed
18:33:11 <Absolute0> Why does Just "Hello" >> Just "World" print world 5 times? doesnt "hello" match with _ ?
18:33:34 <Berengal> , Just "Hello" >> Just "World"
18:33:35 <lunabot>  Just "World"
18:33:45 <roconnor> , [[x] | x <- "hello"]
18:33:46 <lunabot>  ["h","e","l","l","o"]
18:33:51 <roconnor> , [[x,x] | x <- "hello"]
18:33:52 <lunabot>  ["hh","ee","ll","ll","oo"]
18:33:56 <Absolute0> ah "hello" >> "world" sorry
18:34:00 <roconnor> , [[x,x]++"world" | x <- "hello"]
18:34:02 <lunabot>  ["hhworld","eeworld","llworld","llworld","ooworld"]
18:34:02 <Berengal> , ["world" | n <- "hello"]
18:34:04 <lunabot>  ["world","world","world","world","world"]
18:34:07 <roconnor> , ["world" | x <- "hello"]
18:34:08 <lunabot>  ["world","world","world","world","world"]
18:34:11 <roconnor> , ["world" | _ <- "hello"]
18:34:13 <lunabot>  ["world","world","world","world","world"]
18:34:20 <Absolute0> oh right lists are monads..
18:34:24 <roconnor> , "hello" >> "world"
18:34:26 <lunabot>  "worldworldworldworldworld"
18:35:00 <fynn> sjanssen: we also develop on BSD/Macs, and yeah, some of our production boxen are FreeBSD
18:35:01 <Berengal> Not only are lists monads, but they're weird monads
18:35:12 <Berengal> I'd say weirder even than reader
18:35:15 <Absolute0> roconnor: why does  [[x] | x <- "hello"] get evaluated by the >>?
18:35:43 <Absolute0> recursive sequencing?
18:35:49 <Ferdirand> Berengal, why is that ?
18:36:01 <roconnor> , "hello" >>= (\x -> [x,x])
18:36:02 <lunabot>  "hheelllloo"
18:36:06 <fynn> sjanssen: I've looked at the portfile for GHC... definitely more special case logic than for most other ports.
18:36:09 <roconnor> , "hello" >>= (\x -> [x,x]++"world")
18:36:10 <lunabot>  "hhworldeeworldllworldllworldooworld"
18:36:14 <Berengal> Ferdirand: Because of concatMap
18:36:16 <roconnor> , "hello" >>= (\x -> "world")
18:36:17 <lunabot>  "worldworldworldworldworld"
18:36:21 <roconnor> , "hello" >>= (\_ -> "world")
18:36:22 <lunabot>  "worldworldworldworldworld"
18:36:27 <roconnor> , "hello" >>  "world"
18:36:28 <lunabot>  "worldworldworldworldworld"
18:37:01 <Absolute0> [x,x]++"world" ??
18:37:12 <Berengal> , filterM (const [True, False]) [1,2,3]
18:37:14 <lunabot>  [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
18:37:34 <Ferdirand> ah yes, this one is amazing
18:37:39 <roconnor> Absolute0: "hello" >>= \x -> foo x  takes each character of "hello" and runs foo  on that character and concats the results.
18:37:55 <roconnor> , "hello" >>= (\x -> [x,x])
18:37:56 <lunabot>  "hheelllloo"
18:38:16 <Berengal> Absolute0: Are you familiar with Prolog?
18:38:21 <roconnor> in this example foo x takes the character and makes a string with each character twice.
18:38:24 <Absolute0> Berengal: barely
18:38:47 <Berengal> Absolute0: Well, consider what the list monad looks like in do notation, and compare that with prolog
18:38:58 <roconnor> , "hello" >>= (\x -> "("++[x,x]++")")
18:38:58 <Absolute0> Isnt "hello" similar to Just "hello" ?
18:38:59 <lunabot>  "(hh)(ee)(ll)(ll)(oo)"
18:39:16 <roconnor> now we are putting parens around each [x,x]
18:39:24 <roconnor> (remembering that strings are the same as lists of characters)
18:39:47 <Absolute0> roconnor: thanks you've made it very clear :)
18:39:58 <Absolute0> nice animation by the way!
18:40:14 <roconnor> , "hello" >>= (\x -> "("++")")
18:40:15 <lunabot>  "()()()()()"
18:40:24 <roconnor> now we are leaving out the pairs of characters entirely
18:40:29 <roconnor> , "hello" >>= (\x -> "()")
18:40:30 <lunabot>  "()()()()()"
18:40:32 <roconnor> same thing
18:40:37 <roconnor> , "hello" >>= (\_ -> "()")
18:40:39 <lunabot>  "()()()()()"
18:40:40 <roconnor> same thing
18:40:46 <roconnor> , "hello" >> "()"
18:40:47 <lunabot>  "()()()()()"
18:40:50 <roconnor> same thing again.
18:40:59 <Absolute0> yup
18:41:09 <aavogt> @src [] >>=
18:41:19 <roconnor> one "()" for each character
18:41:34 <roconnor> , "hello out there" >> "()"
18:41:35 <lunabot>  "()()()()()()()()()()()()()()()"
18:41:37 <Absolute0> >>= seems like a fancy fmap chaining...
18:41:41 <roconnor> , "h" >> "()"
18:41:42 <lunabot>  "()"
18:41:44 <Absolute0> correct to think so?
18:41:45 <roconnor> , "" >> "()"
18:41:46 <lunabot>  ""
18:42:00 <roconnor> Absolute0: >>= is the same as concatMap
18:42:02 <roconnor> for lists
18:42:19 <roconnor> well, flip concatMap
18:42:22 * Absolute0 looks up concatMap
18:42:29 <aavogt> Cale: is lambdabot coming back soon?
18:42:43 <roconnor> concatMap f x = concat (map f x)
18:42:54 * Berengal must admitt he sometimes uses >>= where concatMap would've been clearer
18:43:44 <Ferdirand> btw, are there other clever use examples of filterM beyond the nice powerset trick ?
18:43:55 <Apocalisp> You're better off if you ever want to replace [] with another monad :)
18:44:05 <roconnor> Ferdirand: nope. :P
18:44:47 <Berengal> Project Euler solution: p17 = length $ [1..1000] >>= showNumAsWord
18:45:00 <Absolute0> concatMap (\x -> [x+1]) [1,2,3].. when would concatMap be useful?
18:45:17 <Absolute0> project euler is cool :-P
18:45:29 <Ferdirand> rconner: we were discussing that last week on .fr. The only vaguely interesting trick was interactive filtering by the user in IO
18:45:55 <Axman6> > concatMap (\x -> if even x then "EVEN" else "") [1..10]
18:45:58 <roconnor> , let x = 1:(concatMap (\a -> [a+1,1/(a+1)]) x) in x
18:45:59 <lunabot>  [1.0,2.0,0.5,3.0,0.3333333333333333,1.5,0.6666666666666666,4.0,0.25,1.333...
18:46:01 <Axman6> rawr
18:46:06 <Axman6> , concatMap (\x -> if even x then "EVEN" else "") [1..10]
18:46:07 <roconnor> , let x = 1:(concatMap (\a -> [a+1,1/(a+1)]) x) in x::[Rational]
18:46:08 <lunabot>  "EVENEVENEVENEVENEVEN"
18:46:08 <lunabot>  [1 % 1,2 % 1,1 % 2,3 % 1,1 % 3,3 % 2,2 % 3,4 % 1,1 % 4,4 % 3,3 % 4,5 % 2,...
18:47:36 <Absolute0> [1,2,3] >>= (\x -> [x + 1]) is much clearer than concatMap :P
18:47:43 <roconnor> Ferdirand: oh neat.  I can see it being used with the reader monad too.
18:48:06 <Axman6> map
18:48:10 <aavogt> Absolute0: but map (+1) is better
18:48:13 <Axman6> map (+1) is eve clearer
18:48:15 <Axman6> bah
18:48:19 <Absolute0> yeah
18:48:25 <roconnor> Absolute0: genreally you wouldn't use concatMap or >>= for a function of the form (\x -> return (foo x)), since that is just the same as map foo
18:48:27 <Absolute0> i was referring to a previous comment
18:48:52 <Absolute0> [21:42]  * Berengal must admitt he sometimes uses >>= where concatMap  would've been clearer
18:49:13 <roconnor> , let x = 1:(x >>= (\a -> [a+1,1/(a+1)])) in x::[Rational]
18:49:14 <lunabot>  [1 % 1,2 % 1,1 % 2,3 % 1,1 % 3,3 % 2,2 % 3,4 % 1,1 % 4,4 % 3,3 % 4,5 % 2,...
18:50:08 <Absolute0> x should go on a diet
18:50:13 <Absolute0> its getting very fat
18:50:15 <Absolute0> :(
18:50:15 <duaneb> is there a readline module for haskell?
18:50:23 <gwern> haskeline
18:50:24 <Axman6> sure
18:50:29 <Axman6> and readline
18:50:40 <Axman6> ghci uses(/used) readline
18:50:44 <duaneb> or editline or whatever
18:50:45 <duaneb> haskeline
18:50:45 <duaneb> ok
18:50:48 <aavogt> and editline (libedit?)
18:50:54 <Axman6> yeah
18:51:07 <Axman6> there's at least three choices
18:51:16 <Berengal> Gotta catch 'em all
18:53:36 <duaneb> ahh
18:53:37 <duaneb> I love haskell
18:53:42 <duaneb> even if it does make me think too much
18:54:00 <gwern> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5548#a5548 <-- any thoughts on my code?
18:54:08 <Axman6> programming is supposed to make you think. if you're not thinking, you're doing it wrong
18:54:28 <Twey> He's right you know.
18:54:31 <Absolute0> [1,2,3,4,5,6,7,8,9] >>= (\x -> if even x then "EVEN" else "ODD")
18:54:31 <Absolute0> "ODDEVENODDEVENODDEVENODDEVENODD"
18:54:33 <duaneb> Axman6: I know
18:54:36 <Absolute0> thats very useful!
18:54:38 <duaneb> I was saying it in an ironical sense
18:54:40 <Absolute0> don't know why
18:54:41 <Absolute0> :)
18:54:44 <Twey> If you're not thinking then your job will shortly be replaced by a small plastic box with flashing lights
18:55:21 <FunctorSalad> hmm I think programming tools *are* supposed to decrease the amount of routine thinking needed
18:55:21 <Ferdirand> that applies to an horribly broad set of jobs
18:55:25 <Absolute0> Twey: that's inevitable no matter how smart you are.
18:55:27 <Twey> @let (y ?? n) p = if p then y else n
18:55:37 <FunctorSalad> so we have more time for the mind-expanding stuff ;)
18:56:09 <Berengal> I want one of those "go away, or I will replace you with a small <foo>" t-shirts, where foo is either "shell script" or "lambda expression"
18:56:10 <Absolute0> fmap ceasarSaladNow! FunctorSalad :-P
18:56:14 <Twey> > map (("EVEN" ?? "ODD") . even) [1..9]
18:56:29 <Twey> Oh, yeah, lambdabot's not back yet?
18:56:57 <Absolute0> where is ?? defined?
18:57:18 <Twey> I just defined it
18:57:23 <Twey> Well, I didn't
18:57:24 <Absolute0> oh
18:57:25 <inimino> 4 lines up
18:57:26 <Absolute0> missed that
18:57:27 <Berengal> Twey: @let (y ?? n) p = if p then y else n
18:57:27 <Absolute0> :)
18:57:29 <Twey> Because there's no lambdabot
18:57:34 <Twey> But I *would* have defined it
18:57:45 <inimino> if a definition falls in the forest...
18:57:45 <Twey> It's also in chrisdone's HigherOrder library
18:57:47 <duaneb> ahh, cabal
18:57:49 <duaneb> I hate thee
18:57:49 <Twey> inimino: *grin*
18:57:58 <duaneb> and thy ignorance of my config file
18:58:03 <Berengal> If Twey defines, but no bot is around to bind it, is it really defined?
18:58:04 <Absolute0> Twey: ternary operato?
18:58:14 <Absolute0> p should go first
18:58:16 <jimmyjazz14> quick question, is there a way to pattern match against a constructor using  with out using all of its arguments
18:58:25 <Berengal> What is the sound of a single client chatting?
18:58:28 <Twey> Absolute0: No it shouldn't
18:58:30 <Absolute0> jimmyjazz14: case of
18:58:35 <Twey> That's if'
18:58:39 <Twey> But if' is pointless
18:58:45 <Twey> Nobody wants to curry on the no-branch
18:58:56 <Peaker> woohoo! fixed lui's Image abstraction and thus scroll widget
18:58:58 <Twey> The most common case is to curry on the predicate
18:59:06 <Absolute0> Twey: well you expression is not consistent with the evaluation..
18:59:11 <jimmyjazz14> hm
18:59:17 <Twey> Absolute0: What do you mean?
18:59:20 <Peaker> maybe I'm on a roll again :)  (Takes staying up to 5 am though, with full-time job :(  )
18:59:24 <Berengal> Twey: I like to call the predicate-last function fi...
18:59:44 <Absolute0> p is last -> (y ?? n) p         p is first -> if p then y else n
19:00:16 <Berengal> Absolute0: Why should the rhs matter when defining argument order?
19:00:31 <Absolute0> just not consistent goddamnit
19:00:43 <Twey> Absolute0: That's deliberate — if does not have a useful order
19:00:45 <Absolute0> haskell is making you people too lazy
19:00:53 <Twey> That's kind of the whole point of defining it in the first place
19:01:11 <Twey> (rather than if' p y n = if p then y else n)
19:01:46 <Absolute0> whats the use of ??
19:02:00 <Absolute0> if you have if'
19:02:12 <Ferdirand> partial application
19:02:20 <Berengal> I like if' for its applicative though: if' <$> pred <*> true <*> false; if' <$> even <*> flip div 2 <*> (+1).(*3)
19:02:54 <Absolute0> ooh look at the spaceships zoom
19:02:55 <Absolute0> :)
19:03:14 <Twey> Absolute0: Its arguments are in a sane order
19:03:32 <Absolute0> sane shmane
19:04:07 <Twey> map ("EVEN" ?? "ODD") is so much nicer than map (flip (flip if' "EVEN") "ODD")
19:05:05 <SamB> @pl map (flip (flip if' "EVEN") "ODD")
19:05:27 <Berengal> SamB: That's pretty pointless as it is
19:05:31 <SamB> @pointless map (flip (flip if' "EVEN") "ODD")
19:05:37 <Berengal> Also, lambdabot is dead
19:05:44 <SamB> yeah, looks like
19:05:48 <SamB> :-(
19:05:52 <Absolute0> the question marks do nicely emphasis the question :)
19:06:01 <Twey> SamB: It's already pointless
19:06:08 <Absolute0> sort of shakespeare like :)
19:06:09 <SamB> I realize it's pointleess
19:06:21 <Twey> So @pl wouldn't do anything
19:06:23 <SamB> but @pl can optimize already-pointless expressions too ...
19:06:30 <Twey> Huh, truly?
19:06:36 <SamB> to a certain extent
19:06:41 <SamB> for some value of optimize
19:08:05 <mmorrow> , [$pl| \a b -> g (f a b) |]
19:08:08 <lunabot>  (g .) . f
19:08:37 <Twey> , [$pl| \x -> if' x "EVEN" "ODD" |]
19:08:39 <lunabot>  flip (flip if' "EVEN") "ODD"
19:08:42 <Twey> There you go.
19:09:03 <mmorrow> , [$bf| .+[.+] |]
19:09:05 <lunabot>  luna: No instance for (GHC.Show.Show
19:09:08 <mmorrow> , [$bf| .+[.+] |] ""
19:09:09 <lunabot>  "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK...
19:09:26 <FunctorSalad> ACK
19:10:04 <Twey> Haha
19:10:39 <Peaker> what does 400 error in upload mean, when trying "cabal upload .."? The package is already there?
19:10:41 <Berengal> , map ord ([$bf| .+[.+] |] "")
19:10:43 <SamB> > if' True 1 2
19:10:43 <lunabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,2...
19:10:48 <SamB> , if' True 1 2
19:10:49 <lunabot>  luna: Not in scope: `if''
19:11:10 <SamB> ,let if' c x y = if c then x else y
19:11:12 <lunabot>  luna: parse error on input `)'
19:11:15 <Peaker> hmm -- supposedly bad HTTP request, so maybe "cabal upload" is broken?
19:11:21 <mmorrow> , [$pl| \a b -> take 4 (zip a b) |] $ [$bf| .+[.+] |] ""
19:11:23 <lunabot>  luna: Couldn't match expected type `a -> b'
19:11:28 <SamB> lunabot: let if' c x y = if c then x else y
19:11:39 <mmorrow> , [$pl| \a -> take 4 (zip a a) |] $ [$bf| .+[.+] |] ""
19:11:42 <lunabot>  luna: Couldn't match expected type `a -> b'
19:11:44 <SamB> , if' True 1 2
19:11:45 <lunabot>  luna: Not in scope: `if''
19:11:51 <SamB> lunabot: !let if' c x y = if c then x else y
19:11:53 <Absolute0> doesn't all that punctuations cause eye sore?
19:12:08 <mmorrow> lunabot doesn't have @let unfortunately
19:12:16 <Absolute0> haskell is big on punctuation.
19:12:16 <Berengal> Absolute0: Only if you read it, not when you write it
19:12:34 <Absolute0> i like the longMethodNames from Java :)
19:12:35 <Peaker> aha, 400 errors are used to complain about your .cabal file
19:12:39 <Absolute0> very pleasant to read.
19:12:40 <Berengal> So it's good to write as much of it as possible, to minimize the time you spend reading them instead
19:12:56 <mmorrow> Absolute0: :o
19:13:40 <Berengal> longMethodNames in haskell don't like it here and tend to march off somewhere, usually to the right...
19:13:40 <Absolute0> Berengal: where are <$> <*> defined, they're not in Control.Monad
19:13:47 <Berengal> Absolute0: Control.Applicative
19:13:51 <Absolute0> ah thanks
19:14:27 <mmorrow> , [$ty| [$pl| \a -> take 4 (zip a a) \|] |]
19:14:30 <lunabot>  Doc
19:14:38 <mmorrow> oh no wonder
19:14:50 <mmorrow> , 'plQ
19:14:52 <lunabot>  luna: Not in scope: `plQ'
19:15:10 <mmorrow> , parseExp . render $ [$pl| \a -> take 4 (zip a a) |]
19:15:12 <lunabot>  Right (InfixE (Just (AppE (VarE take) (LitE (IntegerL 4)))) (VarE .) (Jus...
19:15:24 <mmorrow> , $(either undefined . id . parseExp . render $ [$pl| \a -> take 4 (zip a a) |])
19:15:27 <lunabot>  luna: Couldn't match expected type `b -> c'
19:15:38 <mmorrow> , $(either undefined return . parseExp . render $ [$pl| \a -> take 4 (zip a a) |])
19:15:40 <lunabot>  luna: No instance for (GHC.Show.Show ([a] -> [(a, a)]))
19:15:53 <mmorrow> , $(either undefined return . parseExp . render $ [$pl| \a -> take 4 (zip a a) |]) $ $ [$bf| .+[.+] |] ""
19:15:54 <lunabot>  luna: parse error on input `$'
19:15:59 <mmorrow> , $(either undefined return . parseExp . render $ [$pl| \a -> take 4 (zip a a) |]) $ [$bf| .+[.+] |] ""
19:16:01 <lunabot>  [('\NUL','\NUL'),('\SOH','\SOH'),('\STX','\STX'),('\ETX','\ETX')]
19:16:03 <mmorrow> woo
19:17:11 <Absolute0>  (+1) <$> (+1) <$> Just 5 :)
19:17:13 <Absolute0> fun stuff
19:17:27 <Absolute0> for functors created before monads?
19:17:33 <Absolute0> they seem to be essentially the same
19:17:48 <mmorrow> join is the difference
19:17:53 <Ferdirand> join and return
19:18:05 <Berengal> Ferdirand: Applicatives have return, called pure
19:18:34 <Ferdirand> ah, not reading enough lines, sorry :)
19:18:41 <mmorrow> , join [[0..3],[4..8]]
19:18:42 <lunabot>  [0,1,2,3,4,5,6,7,8]
19:18:48 <mmorrow> , join (Just Nothing)
19:18:49 <lunabot>  Nothing
19:19:05 <Peaker> , join $ Just (Just 5)
19:19:07 <lunabot>  Just 5
19:19:42 <Absolute0> data SimplyMaybe a =
19:19:50 <Absolute0> data SimplyMaybe a = Simply a | Nothing
19:19:53 <Absolute0> thats much better
19:20:12 <Absolute0> i can practice monads on that
19:20:13 <Peaker> Absolute0: in Functor, you cannot get rid of double-wrapped values, and in Monad you can. This disallows you from using contents of functors to get new functor values, but allows it in monad
19:20:17 <Absolute0> as Maybe is already defined
19:20:28 <Peaker> Absolute0: Nothing is a taken name :)
19:20:36 <Absolute0> SimplyNothing
19:22:03 <Peaker> cool, uploaded my new LUI to hackage. The widget set finally makes progress :-)
19:22:27 <roconnor> LUI?
19:22:30 <Absolute0> Lui is a French adult entertainment magazine created in November 1963 by Daniel Filipacchi, a fashion photographer turned publisher.
19:22:37 <Peaker> roconnor: A purely functional widget set
19:22:41 <Absolute0> yeah what is LUI??
19:22:51 <hermanChess> what does it means that haskell has its roots on academia??
19:22:53 <Peaker> roconnor: currently draws via haskgame (a simple incomplete SDL wrapper)
19:23:23 <Peaker> roconnor: the software design of the widgets is innovative too, I'd like to believe :-)
19:23:44 <Absolute0> hows is haskell GUI coding compared to OOP languages?
19:23:46 <Peaker> (The way I do focus management, and widget composition, I think is new)
19:23:54 <roconnor> Absolute0: awful
19:24:00 <Peaker> or awesome
19:24:04 <Absolute0> GUI's seem to be very object oriented :)
19:24:07 <Peaker> There are many GUI paradigms
19:24:15 <roconnor> Absolute0: awful until 5 minutes ago
19:24:21 <Absolute0> :)
19:24:25 <Peaker> heh, LUI isn't ready for real work yet
19:24:30 <Peaker> but Phooey might be
19:24:38 <Absolute0> Peaker: got any screenshots?
19:24:39 <Peaker> and is already cooler than OO GUI's :)
19:24:57 <Peaker> Absolute0: interesting idea -- though there's an example you can just run if you "cabal install lui"
19:25:24 <hermanChess> what does an academic language is?
19:25:43 <Absolute0> only used in courses?
19:26:52 <hermanChess> hmm
19:27:06 <Axman6> hermanChess: it's very actively developed by people working at universities, and they do a lot fo research with it
19:27:30 <hermanChess> ahh I see
19:27:52 <Axman6> it does not mean it has no real world use, nor does it mean that it's slow ;)
19:29:46 <Peaker> Absolute0: can you cabal install lui and run the example therein?
19:30:00 <Absolute0> Peaker: haven't tried
19:30:10 <Absolute0> let me check if i have cabal
19:30:13 <Absolute0> i am on archlinux
19:30:30 <Absolute0> runhaskell == cabal?
19:30:38 <Axman6> no
19:30:46 <Absolute0> runhaskell Setup.hs == cabal?
19:30:54 <Axman6> sort of...
19:30:56 <Absolute0> community/cabal-install == cabal :)
19:31:04 <Axman6> yes ;)
19:32:47 <Peaker> btw, my UI toolkit is not very similar to Gtk/Qt in either API nor look&feel. I think they were both horrible
19:33:10 <Absolute0> Peaker: whats the command to build?
19:33:17 <Peaker> Absolute0: cabal install lui
19:33:27 <Absolute0> under root?
19:33:31 <Peaker> anywhere
19:33:33 <Axman6> Peaker: how do you run the demo?
19:33:36 <Peaker> though it won't build the example
19:33:44 <Peaker> Axman6: You have to unpack the tarball, and compile the Example therein
19:33:45 <Axman6> oh
19:33:49 <Axman6> ah
19:33:51 <Peaker> sorry about that, not sure how to make it better
19:34:05 <Peaker> I don't want to install an executable. Maybe I can make the example a separate package, but its kind of useless
19:36:27 <Absolute0> Peaker: i ran cabal install lui as regular user
19:36:31 <Axman6> http://haskell.org/haskellwiki/LUI :(
19:36:39 <Absolute0> where would the example reside?
19:36:53 <Peaker> Absolute0: ~/.cabal/packages/*/lui/--tarball here--
19:36:58 <Peaker> Axman6: editing this now
19:37:02 <Axman6> :)
19:37:44 * Axman6 finally upgrades to 6.10.3
19:37:56 <Absolute0> Peaker: http://pastie.org/499924
19:38:21 <Absolute0> haskgame-0.0.5 depends on SDL-ttf-0.5.5 which failed to install.
19:38:21 <Absolute0> lui-0.0.4 depends on SDL-ttf-0.5.5 which failed to install.
19:38:37 <Absolute0> configure: error: *** SDL_ttf lib not found! Get SDL_ttf from
19:38:37 <Absolute0> http://www.libsdl.org/projects/SDL_ttf/index.html
19:38:46 <Absolute0> let me do that
19:40:16 <Peaker> Axman6: http://haskell.org/haskellwiki/LUI -- so far
19:40:30 <Axman6> dang, just refreshed and missed it :P
19:49:35 <Peaker> Absolute0: got it?
19:54:00 <Peaker> Axman6: yet more updates: http://haskell.org/haskellwiki/LUI
19:54:17 <Axman6> hoorah
19:56:10 <goldenpuffs> is there a way to put a bunch of data types into another data type?
19:56:32 <araujo> Peaker, interesting
19:56:39 <araujo> Peaker, any web site yet?
19:56:45 <Peaker> araujo: just that wiki
19:57:02 <araujo> I like the name btw
19:57:03 <araujo> hah
19:57:21 <mmorrow> goldenpuffs: you mean without defining a new one?
19:57:56 <mmorrow> data Foo a b c = Foo (Map a b) (Tree c) | Boo (Set (Foo a b c))
19:58:04 <goldenpuffs> mmorrow: I am looking for a way to bundle some datatypes so that I can address all of them
19:58:24 <mmorrow> goldenpuffs: what do you mean by "address"?
19:58:40 <Peaker> araujo: thanks :)
19:59:17 <araujo> Peaker, I am very interested on haskell gui stuff
19:59:18 <Peaker> araujo: the name originated from the fact we were supposed to be 3 guys working on it, my name starts with L, another guy's with S, and if it were called LUIS with both our names, it spells the 3rd guy's name :)
19:59:24 <araujo> Peaker, do you have any example up?
19:59:39 <Peaker> araujo: yeah there's an example inside lui itself -- can you cabal install it?
19:59:50 <Peaker> araujo: it requires SDL/SDL--tf
19:59:52 <araujo> Peaker, hah, my name is that one
19:59:54 <Peaker> SDL-ttf
20:00:04 <mmorrow> goldenpuffs: if i'm guessing right, maybe you're looking to do something like:
20:00:05 <Peaker> you're luis? :)
20:00:10 <araujo> Peaker, hah yeah
20:00:23 <araujo> Peaker, ok, I will give it a try
20:00:26 <mmorrow> say you have types A a, B a b, C a b c, then you can do:
20:00:42 <Peaker> araujo: are you interested in the way the example renders like, or the code looks like?
20:01:04 <mmorrow> data D a b c d e f = One (A a) | Two (B b c) | Three (C d e f)
20:01:05 <araujo> Peaker, the project itself
20:01:29 <mmorrow> goldenpuffs: so kinda similar to a C union
20:01:41 <araujo> Peaker, I work with gtk2hs for graphical development mainly , and it is always nice to see other toolkit around
20:02:55 <Peaker> araujo: cool
20:03:12 <goldenpuffs> mmorrow: I'm trying to get it straight in my head what I'm trying to do;), so I have data A, data B, data C and I want an arbitrary number of A, B,C to be part of some other datatype
20:03:43 <timmaxw> goldenpuffs: so maybe data X = X [A] [B] [C]
20:03:53 <timmaxw> goldenpuffs: is that what you want?
20:04:04 <mmorrow> goldenpuffs: so i guess the question is, what do you want the structure of this other datatype to be?
20:04:59 <goldenpuffs> mmorrow: yes, i think that is what i'm looking for
20:05:07 <mmorrow> data Foo = Foo (Map A (Map B C)) ..... data Foo = One A | Two B | Three C; type Baz = [Foo], ..
20:05:18 <Peaker> araujo: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5549#a5549 -- Here's the example, need to clean it more
20:05:28 <Peaker> araujo: you know how examples tend to be more tests than examples :)
20:05:29 <mmorrow> goldenpuffs: you mean timmaxw's X type?
20:05:45 <Peaker> araujo: I have a little problem with Haskell record fields being getters rather than accessors :-(
20:06:04 <mmorrow> type Foo = ([A],[B],[C])
20:06:11 <mmorrow> (so many options :)
20:06:26 <goldenpuffs> oh I see,  I was confusing value constructors and values I think
20:06:59 <goldenpuffs> data X = X [A] [B] [C] is what I'm looking for I believe
20:07:06 <mmorrow> nice
20:07:12 <goldenpuffs> thanks a bunch
20:07:14 <Peaker> araujo: there's the thing here that you define the model separately from the view. Gtk/etc usually have a stateful model inside each widget -- here the widget gets an accessor to a model to edit
20:07:22 <mmorrow> goldenpuffs: np
20:07:33 <Peaker> araujo: It may seem a little less convenient, I am not sure, as I haven't yet used it for anything real...
20:10:19 <araujo> nic Peaker
20:10:26 <araujo> Peaker, it looks very nice code :)
20:11:05 <Peaker> araujo: thanks :)
20:11:23 <araujo> Peaker, I notice that part, the way you separate the model from the view
20:11:51 <Peaker> araujo: if Haskell records didn't suck and used accessors, I wouldn't have to build accessors to each part of my model manually :(
20:12:17 <Peaker> note the duplication of: avboxModel = accessor vboxModel (\new x -> x{vboxModel=new}) -- et al
20:12:54 <Peaker> also, maybe it could be nice if type-inference built the record on its own
20:13:03 <araujo> Peaker, yeah, i see it
20:13:03 <Peaker> by seeing which fields and field types it had
20:13:43 <Peaker> I could compose models anonymously and then no need for all that
20:14:47 <Peaker> araujo: can you run it?
20:15:02 <Peaker> I think its a nice riddle to figure out exactly what it does -- it is meant to test a bunch of things :)
20:15:37 <araujo> Peaker, ok, i will get it installed first in a minute
20:15:38 <araujo> :)
20:15:48 <araujo> seems very nice code
20:16:20 <Peaker> :)
20:17:18 <aavogt> Peaker: you've seen data-accessor-template?
20:17:34 <aavogt> or template haskell in general
20:17:48 <Peaker> aavogt: nope, and yeah
20:19:21 <Peaker> aavogt: oh cool, *exactly* what I need, except data-accessor didn't really compile with my code, maybe I'll try again
20:20:06 <Nereid> @pl \a (b,_) -> c a b
20:20:28 <Nereid> oh, it's gone
20:21:10 <aavogt> (c .) . snd -- maybe?
20:21:47 <aavogt> , ((,) .) . snd $ 1 (2,3)
20:21:48 <lunabot>  luna: No instance for (GHC.Show.Show (a -> b1 -> (b, b1)))
20:22:09 <goldenpuffs> mmorrow:hi, I'm goldenpuffs' teammate, in charge of that Object business. So basically I have a type class called Surface (similar to an interface in Java I believe) that defines methods like intersect, computeNormal, etc... Then I have different shapes (data types) called Sphere, Plane, etc. I defined instances of Surface for those datatypes, bu I'd like to have a "superclass" called Shape that includes all of these, with several c
20:22:10 <goldenpuffs> onstructors. This way I can have a list of shapes, and when I map a method like intersect on the list, it calls the right definition of intersect on depending on the type of shape. Do you get what I mean ?
20:22:32 <aavogt> , flip (((,) .) . snd) $ 1 (2,3)
20:22:33 <lunabot>  luna: No instance for (GHC.Show.Show ((a1, a -> b) -> b1 -> (b, b1)))
20:22:43 <timmaxw> goldenpuffs: try using existential types.
20:22:44 * mmorrow reads
20:23:10 <timmaxw> something like: data AnyShape = forall a. (Shape a) => a
20:23:31 <timmaxw> oops, data Shape = forall a. (Surface a) => a
20:23:44 <timmaxw> no wait, data Shape = forall a. (Surface a) => Shape a
20:23:51 <aavogt> , flip ((+) . snd) $ 1 (2,3)
20:23:53 <lunabot>  luna: No instance for (GHC.Show.Show ((a, b) -> b))
20:23:56 <timmaxw> i think that's what you want
20:24:07 <timmaxw> but read up on existential types
20:24:51 <goldenpuffs> timmaxw:thx, I'll do that. the "forall a." has to do with existential types then?
20:24:54 <aavogt> , flip (((,) .) . snd) 1 $ (2,3)
20:24:55 <lunabot>  luna: No instance for (GHC.Show.Show (b1 -> (b, b1)))
20:24:58 <timmaxw> goldenpuffs: yes.
20:25:35 * aavogt gah, I'm no match for @pl :)
20:26:05 <Peaker> @pl could make much prettier stuff if it used arrow combinators
20:26:27 <hatds> speaking of - am I the only one suspect of using existentials?
20:26:39 <BMeph> Peaker: ...and 'on', for that matter. :)
20:26:48 <Peaker> yeah
20:27:36 <mmorrow> goldenpuffs: ok, so one thing you might want to do is to intersect a Sphere and a Plane, correct?
20:27:53 <aavogt> and those unknown pointfree combinators on hackage
20:28:27 <mmorrow> goldenpuffs: because that setup, as-is, can't handle that. it can only handle intersecting two of the same type
20:29:27 <mmorrow> goldenpuffs: so my first thought is that you'll need some way to separate from an arbitrary shape the information you'll need to do the ops in Surface
20:29:43 <timmaxw> i think each pair of shapes would have to be hand-coded
20:30:13 <timmaxw> the simplest solution might be data Shape = Sphere Sphere | Plane Plane | Line Line | ...
20:30:15 <Nereid> well if f a (b,_) = c a b, then f a = c a . fst, but I don't know where to go from there
20:30:34 <timmaxw> and intersect :: Shape -> Shape -> Bool (or whatever return type you want)
20:30:36 * Nereid is new
20:30:40 <mmorrow> maybe include in the Surface class a  (getConvexHull :: a -> TriangularMesh)   (s/TriangularMesh/whatever)
20:30:54 <aavogt> lunabot: help
20:30:56 <hatds> sometimes creating a list of functions is better than creating a list of objects.  If you have some top level array which maps "draw" over all your shape objects you could instead create an array of draw functions
20:30:58 <mmorrow> , help
20:31:00 <lunabot>  type of an expression:      , [$ty| \x -> x |]
20:31:00 <lunabot>  get info for a type/class:  , src ''Monad
20:31:00 <lunabot>  get info for a var/con:     , src 'fix
20:31:29 <aavogt> , [$ty| (+) . fst]
20:31:30 <lunabot>  luna: lexical error in string/character literal at end of input
20:31:45 <mmorrow>  [$qq-name| ... |]
20:31:56 <goldenpuffs> mmorrow: no intersections other than between a ray and an object so far, but maybe later
20:32:17 <timmaxw> goldenpuffs: then you can go with the existential type solution for now
20:32:35 <mmorrow> , [$ty| (+) . fst |]
20:32:38 <lunabot>  forall a b . Num b => (b, a) -> b -> b
20:32:57 <hatds> imho I would avoid existenstials until I was convinced I needed them
20:33:11 <mmorrow> data Shape = forall a. (Surface a) => Shape a
20:33:29 <hatds> I think the data solution works fine, if you hide the constructors for data Shape then it is just as good as an existential
20:33:55 <goldenpuffs> alright, the existential types seem exactly right, so I'll go with that, thanks again
20:34:09 <mmorrow> hatds: but you need to modify the Shape type and every function that pattern matches on its cons with that way
20:34:18 <mmorrow> (when you add a shape)
20:34:44 <hatds> mmorrow: right, a data type would only work if you could keep it abstract
20:34:58 <timmaxw> mmorrow: that might not be that hard.
20:35:08 <timmaxw> what's considered bad about existentials, by the way?
20:35:11 <mmorrow> yeah, it depends on the type
20:35:31 <mmorrow> (say the type has 40 constructors that all intermesh with each other..)
20:35:50 <mmorrow> that become a huge pita to add cons
20:36:19 <timmaxw> mmorrow: remember that pattern matches dont have to be exhaustive
20:36:36 <mmorrow> timmaxw: heh
20:36:44 <Nereid> aha
20:36:48 <Nereid> f = flip (.) fst . c
20:36:57 <hatds> I'm with timmaxw here
20:37:07 <hatds> I'd go with the naive algebraic type first
20:37:08 <timmaxw> mmorrow: you can put off defining "intersect (ParabolicHyperboloid ...) r" until later
20:37:23 <Nereid> , (flip (.) fst . (+)) 5 (6,7)
20:37:24 <lunabot>  11
20:37:29 <mmorrow> oh, we're debating goldenpuff's solution in particular here?
20:37:41 <wli> You're intersecting quadrics?
20:37:43 <mmorrow> hmm, yeah personally i'd use the ADT solution too
20:37:47 <Nereid> aavogt: :)
20:37:59 <timmaxw> wli: that was an example of a type that might hypothetically be added if there were 40 type constructors.
20:37:59 <goldenpuffs> wli: quadrics with rays, yes
20:38:10 <aavogt> , ((.fst) . (+)) 1 (2,3)
20:38:12 <lunabot>  3
20:38:18 <Nereid> that too
20:38:38 <mmorrow> data Shape = Sphere ... | Cone .... | Plane .. | TriangularMesh ... | ParametricSurface ... |
20:38:40 <wli> x^t A_k x + b_k^t x + c = 0 for 0 < k <= n?
20:39:01 <wli> Oh dear, that can get real ugly real quick.
20:39:02 <hatds> I'm skeptical of how often people really need to overload a function on 40 types
20:39:30 <wli> 3D quadrics only?
20:39:31 <mmorrow> hatds: (>>=) ?
20:39:40 <goldenpuffs> mmorrow: but when I do that, I can't use Sphere etc in the type class wich defines intersect and normal, right?
20:40:07 <aavogt> define a hierarchy of typeclasses
20:40:09 <timmaxw> goldenpuffs: no. if you define it as an algebraic type like in your last suggestion, then you have to do everything using pattern matching
20:40:09 <mmorrow> goldenpuffs: with the ADT way, you no longer have a type Sphere, just a type Shape
20:40:11 <wli> I'd just try to represent things via equations and inequalities.
20:40:27 <hatds> mmorrow: still skeptical -- programs we write aren't at all like general purpose data libraries
20:40:49 <jmcarthur> sometimes i think things like this can benefit from a Map rather than a type class so you can handle the presence or absence of an "instance" at runtime, and also get the benefits of the existential quantification approach since you can just carry around a tag to annotate what would otherwise be data all of the same type
20:40:56 <goldenpuffs> timmaxw: that's what I was trying to avoid, so that I can add more shapes easily later
20:41:10 <wli> So intersections are just conjunctions of conditions.
20:41:10 <mmorrow> hatds: (what exactly are we discussing, the usefulness of existential types with class constraints in datatypes?)
20:42:11 <timmaxw> so, exactly how hard is it to add a new type of shape with each method? i think with the ADT method you can just add a new constructor, and you can let the pattern matches be non-exhaustive for the functions if you don't need those capabilities.
20:42:14 <jmcarthur> it's essentially the same thing as existential quantification, but with a little more work for a little more control
20:42:30 <timmaxw> that doesn't seem insurmountable to me UNLESS the new shape is being added by an entirely new module
20:43:08 <wli> So I don't think the algebraic data type helps.
20:43:42 <timmaxw> wli: how?
20:43:55 <hatds> mmorrow: I don't know, I just feel that going with fancy solutions first isn't always the best approach.  Even typeclasses are fancy for certain things
20:44:05 <mmorrow> yeah, if we're talking about the need to add Shapes without modifying the code of the module that defines Shape, then the ADT solution doesn't work... but you could make an ADT which defines the most basic building blocks of shapes, and has cons which "glue" (or something) other shapes together
20:44:29 <hatds> I think it is easy to refactor simple -> fancy, but starting out with fancy gives you headaches
20:44:35 * bos is trying to come up with a good name for a type that handles unicode encoding errors
20:44:41 <bos> CodingError? bleh.
20:44:42 <wli> x^t A_k x + b_k^t x + c = 0 for 0 < k <= n, for instance, just wants the solution of a system of equations. You can get some more things like triangular planar patches with inequalities.
20:44:43 <timmaxw> mmorrow: that's only important if third parties are going to extend it
20:44:50 <bos> i thought about :-<
20:44:51 <mmorrow> timmaxw: yes
20:44:56 <bos> as in Char :-< Word
20:44:58 <Cale> One thing you can do is decide which operations you need shapes to have and define a shape as a record consisting of those operations.
20:45:05 <timmaxw> mmorrow: which seems unlikely to me, although i don't know exactly what goldenpuffs is doing
20:45:22 <timmaxw> Cale: that's basically a desugared typeclass, i think
20:45:25 <Cale> That's more or less the OO approach, and doesn't require existentials.
20:45:35 <Cale> Desugared existential, sort of.
20:45:44 <jmcarthur> Cale's suggestion allows you to create new shapes at runtime, even, by constructing new functions.
20:45:56 <mmorrow> bos: i like infix constructors
20:45:57 <jmcarthur> new *records
20:46:01 <Cale> (though existentials are strictly speaking able to handle some cases which this method can't)
20:46:06 <timmaxw> Cale: what are the advantages over an actual existential?
20:46:20 <Cale> I think it's more straightforward sometimes.
20:46:36 <wli> Triangular planar patches I think are just things like b_0^t x = c_0, and then b_k^t x <= c_k for 0 < k <= n, or some such.
20:46:53 <Cale> and also that way you don't need to turn on extensions
20:47:07 <wli> s/Triangular/Polygonal/
20:49:42 <Cale> hmm, where did I put that example...
20:50:13 <wli> I guess allowing A_k = 0 and also throwing in a case in the data type for individual "equations" for inequalities of the form b_k^t x <= c_k will do it.
20:50:46 <timmaxw> wli: if you only need a handful of types, it's much simpler to hard-code the solutions for them than to have an solver for arbitrary polynomials
20:51:55 <wli> I don't think the solver is that involved for 3 variables. Also, the "handful of types" explode combinatorially when you carry out intersections.
20:52:15 <Cale> Oh, looking back at the previous text, if you already have a typeclass, an existential type should serve well.
20:52:39 <mmorrow> yeah, i like wli's suggestion here
20:53:08 <mmorrow> a shape is completely determined by its polynomial
20:53:39 <mmorrow> Cale: yeah, the typeclass being a given makes an existential more attractive
20:53:41 <amz> a bit off-topic, but I can't think of a better place to ask... I'm planning on starting a blog about game development, including studying gamedev in Haskell and other functional languages, so I wanted a title that reflects that. I was thinking of something along the lines of "The Gamedev Monad", or "Monadic Gamedev"... any thoughts? Too cheesy? Stupid? Wrong?
20:54:33 <QtPlaty[HireMe]> I prefer "The Gamedev Monad" over the other one.
20:55:20 <Twey> Fêl
20:55:36 <amz> I do too, but I wasn't sure if it wouldn't sound bizarre
20:55:57 <Cale> amz: hehe, I suppose it's fine, though conal might flinch a little.
20:56:05 <falmor> i prefer " functional gaming "
20:56:10 <Twey> (Ilaksh monadic perspective of ‘game’)
20:56:15 <mmorrow> amz: heh, people in this channel are probably way to desensitized to that for their opinions to be representative :)
20:56:16 <Cale> (Reactive is more Applicative than Monadic ;)
20:56:27 <Twey> Conlang punning is fun for all the family.
20:56:30 <pumpkin> Arrowdic?
20:56:36 <mmorrow> functional gaming sounds good
20:56:37 <falmor> functional gaming " makes it seem right
20:56:50 <falmor> or pedantic people can get all fussy bout the terminology
20:56:58 <amz> well, the blog isn't only ABOUT functional programming
20:57:02 <amz> it will presumably also cover gamedev on oop
20:57:14 <falmor> ah
20:57:18 <aavogt> existential?
20:57:18 <falmor> ok let me think
20:57:30 <falmor> " gamedev 360"
20:57:33 <amz> I feel that "Gamedev Monad" doesn't imply it's only functional, even if monads are a functional concept
20:57:47 <amz> eh, that sounds like it's about the xbox 360
20:57:52 <falmor> no
20:57:53 <amz> also, twey, I have no idea what you just said :)
20:57:56 <falmor> its like in chess
20:58:12 <falmor> just meaning gamedev covered in all respects or more
20:58:13 <falmor> most
20:58:17 <falmor> gamedev 270 maybe
20:58:19 <falmor> ?
20:58:20 <falmor> :D
20:58:29 <ray> monads suck
20:58:34 <Cale> Newsflash: Microsoft has patented geometry and the degree unit of angle.
20:58:34 <amz> D:
20:58:38 <amz> haha
20:58:47 <falmor> Cale what
20:58:48 <ray> you should be using radians anyway
20:58:48 * pumpkin invents the digree
20:58:55 <pumpkin> there are 180 digrees in a circle
20:58:59 <pumpkin> and 90 in a triangle
20:59:00 <falmor> is that for real
20:59:09 <Cale> falmor: Of course not :)
20:59:12 <falmor> oh
20:59:13 <falmor> :D
20:59:30 <pumpkin> they are the perfect unit of digression
20:59:38 <falmor> ok so amz
20:59:58 <amz> if I forget Haskell for a moment and go with Wikipedia's definition of a Monad: "In functional programming, a monad is a kind of abstract data type used to represent computations (instead of data in the domain model). Monads allow the programmer to chain actions together to build a pipeline, in which each action is decorated with additional processing rules provided by the monad."
21:00:04 <amz> then "Gamedev Monad" seems right
21:00:04 <ray> how about "pointed discussion"
21:00:15 <Cale> A license for Microsoft Degree 2009 Home Edition will only cost you $220.
21:00:23 <amz> that would be really hard to google, ray
21:00:24 <Twey> A bargain!
21:00:38 <Twey> Heh, amz :-P
21:00:45 <ray> how about applicative FUNctor
21:00:51 <amz> hah
21:00:53 <pumpkin> yeah, but if you want Degree Pro, you'll need twice that
21:00:59 <amz> that's not a bad one ;)
21:01:02 <pumpkin> with Degree Home you can only perform sines on it
21:01:09 <pumpkin> no cosines or tangents
21:01:12 <Cale> I hear the total cost of ownership is much lower than those "radians" the open source guys keep talking about.
21:01:13 <Twey> I don't care what I can do with it, I want Pro
21:01:16 <amz> if it was on ML, I could probably do a pun on "fun fact"
21:01:16 <falmor> raay i was thinking along those lines
21:01:19 <pumpkin> luckily, you can get the other ones, but it's a pain
21:01:22 <falmor> but functor to pronounce is funny
21:01:25 <Twey> It's called *Pro*
21:01:34 <conal> amz: about "The Gamedev Monad", or "Monadic Gamedev"..., i worry that such a title would perpetuate the idea that Monad is somehow particularly important to functional programming.  mostly (certainly not always), folks use Monad in haskell in order *not* to program functionally.
21:01:36 <falmor> gamedev OOmonad
21:01:38 <Twey> Unless there's an ULTIMATE version.
21:01:38 <pumpkin> functor sounds like an ancient warrior
21:01:39 <pumpkin> functOR
21:01:39 <falmor> how about that?
21:01:44 <SamB> Cale: what if I just want MCSE Home?
21:01:47 <falmor> gamedev OO!monad
21:01:56 <falmor> nay
21:01:57 <falmor> skip
21:02:15 <conal> amz: so, i'm with falmor.  something with "functional" rather than "monad(ic)".
21:02:29 <amz> conal: well, I thought that was the whole point, to build a procedural pipeline inside functional code
21:02:35 <falmor> conal: but he's going to write stuff in OO too it seems
21:02:36 <falmor> ..
21:02:37 <falmor> so
21:02:40 <wli> x^2+y^2=1, y^2+k^2*z^2=1 gives you something perhaps more interesting (elliptic functions w00).
21:02:44 <pumpkin> conal: I recommended unamb for the first time today! I feel so advanced (but I'm not sure I recommended it appropriately)
21:02:52 <conal> pumpkin: woot!
21:03:12 * pumpkin beams
21:04:50 <falmor> "gamedev functOOr"
21:04:51 <falmor> :P
21:05:02 <conal> amz: indeed, haskell is not only a awesome functional language, it's also "the world's finest imperative programming language".  maybe you're more interested in the latter than the former.  if so, then "monad" probably fits well.
21:05:30 <amz> I'm not yet sure if I agree with Simon PJ on that comment ;)
21:05:45 <Cale> Actually, I disagree with conal about most monads. Only the IO monad is really imperative.
21:05:55 <conal> Cale: we don't disagree there.
21:06:02 <Cale> Okay :)
21:06:25 <Cale> Most monads just capture basic functional idioms.
21:06:44 <amz> anyway, conal, the idea of the blog is to explore general topics in game dev and programming, but also explore how to do that stuff in FP
21:06:50 <amz> which is why I wanted a nod at them in the title
21:06:51 * BMeph prefers to do trig using gradians - you cn't beat triangles adding up to 100! ;p
21:07:12 <amz> but it's not an exclusive thing, so a title with "functional" might be misleading
21:07:22 <conal> Cale: my impression is that most of the popularity of Monad is so that people can program imperatively.  i'm not commenting on Monad itself.  just its popular use.
21:07:33 <Cale> okay
21:08:07 <conal> for people who use Monad functionally, Monad is nothing special.  for people who use it imperatively, it's very special.
21:08:24 <amz> I see
21:08:48 <Cale> Grads are cool when it comes to adding or subtracting right angles, but radians have the glorious property that it's easy to convert to lengths along circles to radian angles.
21:08:49 <amz> what about "Higher-order fun"? :)
21:09:24 <Cale> amz: That's a nice name. :)
21:09:33 <monochrom> If I learned arithmetic in base pi, radians would be cool for adding right angles.
21:09:36 <BMeph> FuncTours? ;)
21:09:54 <amz> maybe "Higher-order FUNction"
21:09:57 <roconnor> radians have the property that the derivative of sin is cos
21:09:59 <amz> though that's harder to google
21:10:07 <conal> amz: maybe something with "HOT" (higher-order typed)
21:10:17 <monochrom> funtorial
21:10:30 <SamB> HOT FUN
21:10:38 <amz> "Fun and Functions"
21:10:52 * amz never even heard the "HOT" acronym, so it might be too obscure
21:10:57 <conal> or "hot action", "hot pixels", ...
21:11:00 <SamB> amz: are you kidding?
21:11:03 <monochrom> hot high fun
21:11:10 <amz> conal: I might get blocked by some family filters with a title like that ;)
21:11:19 <amz> SamB: :(
21:11:20 <conal> amz: oh yeah!
21:11:22 <amz> I'm afraid I'm not
21:11:22 <SamB> it's, like, one of our favorite jokes
21:11:32 <amz> I don't hang around here much :(
21:11:36 <monochrom> Everything is obscure. What's new.
21:11:53 <conal> oh hey -- maybe a take-off on the "sexy types in action" paper title
21:11:58 <monochrom> Also, HOT as a joke is so year 2000.
21:11:59 <luqui> @bot
21:11:59 <lunabot>  :)
21:12:11 <BMeph> SamB: Heck, according to one of sigfpe's blarticles, kowey never heard of CA until December '06. So sad, how Education os Failing our Kids... :\
21:12:30 <SamB> BMeph: that's because he didn't read enough books about fractals!
21:12:40 <SamB> or fractal programs
21:12:49 <mmorrow> lunabot uptime:
21:12:50 <BMeph> SamB: Or Bill Gosper. :)
21:12:53 <monochrom> CA is Canada isn't it?
21:12:58 <mmorrow> mmorrow  11442  0.1  0.1 239732 10984 pts/2    Sl+  Mar17 162:25 ./bot +RTS -N8 -RT
21:13:01 <SamB> Cellular Automations
21:13:06 <SamB> er.
21:13:08 <SamB> automatons
21:13:08 <mmorrow> 2.5 months!
21:13:13 <BMeph> monochrom: I meant Cellular Automata. :)
21:13:14 * monochrom 's domain is a ca, too.
21:13:20 <mmorrow> forkIO for every irc message
21:13:24 <SamB> er, yeah, automata is the right plural ;-P
21:13:43 * mmorrow wonders how many forkIOs that is over two and a half months
21:15:15 <mmorrow> woo 163 hours of cputime
21:15:20 <BMeph> So, can you install vacuum-cairo straight from the Platform?
21:15:44 <mmorrow> BMeph: you need gtk2hs and all that jazz, which i think you can't
21:15:52 <BMeph> mmorrow: Sugoi! ;)
21:15:54 * mmorrow needs to release his vacuum-gl
21:16:32 <mmorrow> which is actually an interactive viewer for *any* haskell graph
21:17:11 * mmorrow digs that up
21:17:25 <pumpkin> :o
21:18:50 <conal> mmorrow: yow!  sounds like great fun.
21:19:26 <mmorrow> conal: it binds directly to graphviz C functions too, so it's all in-process
21:19:34 <conal> mmorrow: sweet!
21:20:36 <mmorrow> (the unfortunate part though is that for every graph it has to slurp up a .bmp from graphviz, then copy that into video memory, but i think that's the best one could hope for)
21:21:20 <mmorrow> (using .bmp instead of png to avoid having to decompress the png right after graphviz compresses it)
21:21:31 <conal> mmorrow: i've been playing with andy gill's data-reify, described at http://www.ittc.ku.edu/~andygill/paper.php?label=DSLExtract09 .  have you seen/read it?
21:21:43 <mmorrow> conal: ooh, yeah! that's a really nice concept
21:21:55 <goldenpuffs> I have a question about the dotproduct between two vectors
21:22:03 <goldenpuffs> I defined it this way: t \*/ v = map (t*) v
21:22:13 <goldenpuffs> is there an easy way to make it commutative?
21:22:16 <conal> mmorrow: yeah!  i want to use it to replace the CSE in my functional->GPU compiler
21:23:12 <conal> mmorrow: i wonder if there's some lovely merger of data-reify and vacuum.
21:23:24 <mmorrow> conal: i used that idea recently to make self-describing C structure serialization.... so the datarep in serialized first, then the raw data, and to de-serialize you first read the description of the data, then use that info the parse the rest. where the "visible sharing" bit come in is in how you build C data descriptions, eg:
21:24:44 <mmorrow> myRep = Struct[B, S, P myRep, Struct[..]]
21:25:35 <mmorrow> so you need to break that (:: Rep) into a (type RepGraph = (Word32, [RNode]))
21:25:45 <mmorrow> (where RNode isn't resursive)
21:26:22 <mmorrow> conal: i think there is a merger for sure. they use basically the exact same idea. it'd be great to have:
21:26:30 <mmorrow> serialize :: forall a. a -> ByteString
21:26:49 <mmorrow> reify :: ByteString -> a  -- this direction would need rts C code though
21:26:53 <conal> mmorrow: capturing sharing & cycles?
21:26:58 <mmorrow> exactly
21:27:04 <mmorrow> all sharing being preserved
21:27:07 <conal> totally
21:27:11 <mmorrow> , vacuum (fix (0:))
21:27:13 <lunabot>  [(0,[1,0]),(1,[])]
21:27:15 <mmorrow> wee
21:27:28 <pumpkin> mmorrow: what would it do about functions?
21:27:40 <chromakode> hey guys, I'm trying to define a type class with a parameter with the ST monad, and am running in a wall: the part with state requires the parameter s, but the Eq class does not expect it. could anyone take a look and let me know what I'm doing wrong? http://www.moonpatio.com/fastcgi/hpaste.fcgi/view?id=2548#a2548
21:28:38 <mmorrow> pumpkin: that's a tough part, there're no hooks for the haskell side to get at that data in the rts currently, and even if you could, it'd be arch-specific (and reifying would probably be hard)
21:29:05 <luqui> conal, you are a purity zealot like me. I wonder why you expect to be able to break the rules...
21:29:33 <mmorrow> whose rules? ;)
21:30:27 <luqui> R.T. mcFunction's.
21:30:51 <pumpkin> scottish eh
21:31:02 <pumpkin> gotta fight the man!
21:31:05 <pumpkin> don't bow to the rules
21:31:08 <mmorrow> wouldn't that be MacFunction then?
21:31:15 <conal> luqui: i *am* a fellow purity zealot, indeed.  have you seen andy's paper?
21:31:43 <luqui> conal: which?
21:31:59 <conal> luqui: http://www.ittc.ku.edu/~andygill/paper.php?label=DSLExtract09
21:32:04 <yav> do we have any haskellers that use windows here?
21:33:09 <mmorrow> goldenpuffs: u \*/ v = sum (zipWith (*) u v) -- ?
21:33:56 <luqui> conal, I'll read it and present my argument later, if I still maintain it. :-)
21:33:58 <conal> or (\*/) = (fmap.fmap) sum (zipWith (*))
21:34:05 <mmorrow> :)
21:34:08 <conal> luqui: please.
21:34:25 <pumpkin> conal: I'm not sure I can approve of that operator
21:34:44 <conal> luqui: i don't mind if internal representations break purity (distinguish between semantically equal representations), as long as there a semantically tight abstraction in the end.
21:35:09 <mmorrow> pumpkin: are you throwing an UnapprovedOperator exception?
21:35:11 <goldenpuffs> mmorrow: oh my bad, I said dotproduct but I meant multiplication with a scalar actually
21:35:17 <luqui> conal, so because you are so good at programming, you don't need to use pure functions for reasoning, just for your interface?  ;-)
21:35:21 <pumpkin> mmorrow: indeed :/
21:35:25 <conal> luqui: andy moves observable sharing into IO.  from there, one can do a safePerformIO and wrap the rewult.
21:35:57 <timmaxw> So. Cyclic data structures. Thoughts?
21:36:10 <luqui> I'm becoming more and more of the impression that I have to follow the rules as much as anybody else.
21:36:14 <timmaxw> for example, a graph
21:36:19 <mmorrow> goldenpuffs: hmm, so you want :: Vec -> Scalar -> Vec and :: Scalar -> Vec -> Vec?
21:36:32 <luqui> and if I run into limitations, those limitations should be brought to light so we can improve our language
21:36:43 <mmorrow> goldenpuffs: you could make two versions:  \*  and  /*
21:36:47 <mmorrow> err, */
21:36:56 <pumpkin> or a typeclass with fundeps
21:37:01 <mmorrow> (*/) = flip (\*)
21:37:15 <timmaxw> one way to deal with it is to have arcs be indices into a list, so type Graph = [(StateData, [Int])]
21:37:16 <goldenpuffs> thought about that, was just wondering if there is something like Commutative a =>
21:37:24 <conal> luqui: i'm with you.  i think i follow the rules.  the important tricky bit is clarifying the preconditions for safePerformIO
21:37:30 <timmaxw> where StateData is associated with each state
21:37:35 <timmaxw> and the Ints are indices into the Graph itself
21:37:37 <timmaxw> but that's messy
21:37:43 <luqui> conal: *IO is not following the rules :-)
21:37:50 <timmaxw> Are there better ways?
21:37:51 <mmorrow> timmaxw: a fast rep that i use a lot is   IntMap Node
21:38:01 <mmorrow> timmaxw: where there's some (Node -> [Int])
21:38:07 <conal> luqui: all of pure functional programming is built on (un)safePerformIO
21:38:08 <mmorrow> (or Node -> IntSet)
21:38:13 <conal> luqui: s/built/implemented/
21:38:25 <timmaxw> that's still the same general concept though
21:38:29 <mmorrow> timmaxw: exactly
21:38:30 <timmaxw> are there alternatives?
21:38:44 <timmaxw> for example, i think you could build the entire graph as a cyclic data structure
21:38:51 <timmaxw> so data Node = Node StateData [Node]
21:38:58 <timmaxw> but you wouldn't be able to detect cycles
21:39:04 <timmaxw> so that's only useful for some applications
21:39:29 <timmaxw> i'm pretty sure it's possible to construct such a data structure because of lazy evaluation
21:39:33 <luqui> conal,  but going into IO and back out of it destroys the local reasoning properties of your program.
21:39:47 <mmorrow> timmaxw: oh, well you can always map between  (Map a (Set a) <===> IntMap Node), where Node = Node a IntSet
21:40:08 <luqui> *local* being a key word
21:40:09 <mmorrow> timmaxw: but other than this general idea i don't know of any
21:40:36 <conal> luqui: it's a trickier kind of reasoning.
21:40:46 <timmaxw> I can think of two ways to "untangle" a genuinely cyclic data structure
21:40:53 <luqui> conal, by trickier you mean informal, thus unverifiable
21:40:54 <timmaxw> into a finite-sized representation
21:40:57 <mmorrow> timmaxw: oh, you can build a circular structure using sharing, but then you need to break it apart somehow (like with andyjgill's library's method or equiv)
21:41:10 <timmaxw> i've got to google those then
21:41:20 <mmorrow> (StableName + hashStableName) is one easy way
21:41:23 <conal> luqui: no, i meant formal.
21:41:29 <timmaxw> the ideas i had were System.Mem.StableName and adding unique tags to nodes
21:41:32 <mmorrow> and throw an unsafePerformIO on top
21:41:39 <timmaxw> where the algorithm generating the graph guarantees the tags are unique
21:41:44 <mmorrow> timmaxw: that works well
21:41:49 <luqui> conal, don't you need a semantics for IO for that?
21:41:55 <timmaxw> which one?
21:42:02 <mmorrow> StableName
21:42:15 <mmorrow> (what's the other?)
21:42:17 <timmaxw> the unsafePerformIO approach seems a little messy to me, but i'll consider it
21:42:18 <luqui> also have to know how said semantics interact with the normal pure semantics of the language... which must endow them with a different semantics, no?
21:42:21 <conal> luqui: i wouldn't start with all of IO.
21:42:37 <mmorrow> timmaxw: well you can untangle with StableName without it just the same)
21:42:44 <timmaxw> suppose we have data Node = Node (Maybe String) SomeData [Node]
21:43:07 <timmaxw> where the (Maybe String) is the "name" of the node
21:43:14 <timmaxw> and some nodes have strategically places names on them
21:43:24 <mmorrow> the unsafePerformIO is only if you want  (untangle :: Tangle -> Untangle) rather than (untangle :: Tangle -> IO Untangle)
21:43:39 <timmaxw> the former is preferable
21:44:09 <luqui> conal, i need my argument to simmer a bit.  expect a blog post :-)
21:44:12 <mmorrow> timmaxw: do everything in IO then put a single unsafePerformIO at the very top
21:44:21 <timmaxw> i'll consider that
21:44:33 <timmaxw> does the tagged/named node approach make sense?
21:44:46 <Cale> whaaaat
21:44:54 <timmaxw> or do i need to explain in more detail
21:45:10 * Cale needs to read this to see what mmorrow is really suggesting
21:45:26 <mmorrow> Cale: this is how you break apart circular data
21:45:27 <conal> luqui: okay.  and i'm teasing you a bit.  if you think we disagree, you're probably missing my meaning.  and i'm not making a great effort to prevent you missing it.
21:45:30 <Cale> oh
21:45:49 <Cale> But that's not how you really want to represent graph structures in Haskell.
21:46:00 <mmorrow> StableName+hashStableName + IntMap [(StableName, a)] -- keys are hashes of StableNames
21:46:32 <mmorrow> Cale: oh, no. but it's a way to untangle if that's what you need to do
21:46:47 <Cale> If you have lazy cyclic structures, I wouldn't recommend messing with them like that at all. If you need to manipulate them, you should not have chosen them in the first place.
21:46:59 <timmaxw> what can i google for to find more about "andyjgill's library method"? I can't seem to find anything.
21:47:09 <luqui> conal, it's possible.  i am more inclined to think we disagree because i've had a recent change in perspective.  but i still don't quite know what I'm saying...
21:47:10 <mmorrow> Cale: sometimes it's more convenient though to build them with the facilities of the language, then untangle
21:47:17 <Cale> If you need to represent a graph, use something like Map Vertex (Set Vertex)
21:47:28 <mmorrow> Cale: edsls are the canonical example
21:47:37 <conal> luqui: oh!  i'll watch for your blog post.
21:47:48 <Cale> mmorrow: hmm, maybe
21:47:56 <Cale> mmorrow: But that seems really fragile.
21:48:01 <conal> Cale: have you read andy's paper?
21:48:04 <mmorrow> Cale: check out andyjgill's pap
21:48:05 <mmorrow> yeah
21:48:19 <Cale> I think you'd be better off in general constructing combinators which built an explicit graph.
21:48:23 <timmaxw> "A Haskell Hosted DSL for Writing Transformation Systems"?
21:48:38 <Cale> Than using unsafePerformIO and StableNames
21:48:52 <conal> Cale: andy doesn't use unsafePerformIO
21:48:56 <Cale> Okay
21:49:00 <mmorrow> yeah, i added that part :)
21:49:06 <Cale> I was only referring to mmorrow's suggestion
21:49:11 <mmorrow> you don't need it for anything essential
21:49:14 <bnijk> how do i write a program that, say
21:49:19 <bnijk> computes value x, and writes it to ~/x
21:49:31 <bnijk> for maximum monaditude
21:49:39 <Cale> :t writeFile
21:49:41 <conal> mmorrow: i wouldn't want to add unsafePerformIO unless it was really safePerformIO, i.e., it preserved functional semantics.
21:49:53 <Cale> Is lambdabot still gone?
21:50:04 <pumpkin> I can bring pumpkinbot in for a while if you want
21:50:05 <mmorrow> conal: yeah, it's safe how i'm thinking of it being used
21:50:07 <bnijk> yes
21:50:09 <timmaxw> Is the andyjgill paper you're referring to the one titled "A Haskell Hosted DSL for Writing Transformation Systems"?
21:50:16 <conal> mmorrow: me too
21:50:25 <bnijk> not the type, i want to see the actual implementation
21:50:27 <timmaxw> i'm trying to find the paper under discussion
21:50:37 <conal> timmaxw: no.  it's the one i linked to twice above.
21:51:05 <conal> timmaxw: "Type Directed Observable Sharing" -- http://www.ittc.ku.edu/~andygill/paper.php?label=DSLExtract09
21:51:11 <timmaxw> thanks
21:51:13 <mmorrow> Cale: (the only reason the IO pops into the picture is when using StableName, which are all discarded after you've done your business)
21:51:13 <Cale> bnijk: It's more or less primitive, but I suppose you could write it in terms of openFile and hPutStr
21:51:16 <conal> to appear at the Haskell Symposium.
21:51:32 <bnijk> you suppose?
21:51:33 <Heffalump> is the paper list out yet?
21:52:11 <mmorrow> Cale: so the unsafePerformIO just drops that IO after all remnants of IO have already been discarded
21:52:19 <Cale> mmorrow: But isn't explicitly relying on how the compiler shares values a bit dangerous?
21:52:38 <timmaxw> Cale: any sane implementation of StableName would produce an equivalent result
21:52:38 <Heffalump> Cale: it's fine if it's just to save you doing CSE yourself
21:52:39 <Cale> It seems to me that an optimisation could change that.
21:52:49 <timmaxw> not necessarily the same result, but results that are equivalent enough
21:52:50 <Heffalump> I'm not sure of any other safe uses
21:52:56 * bnijk reads the wiki
21:52:59 <conal> mmorrow: you still have to be careful.  if you expose a graph rep, then the sharing detection can distinguish between semantically equal values.
21:53:10 <Cale> conal: right.
21:53:17 <timmaxw> conal: that's acceptable.
21:53:25 <Cale> It breaks referential transparency...
21:53:28 <Cale> That's kind of bad.
21:53:33 <mmorrow> conal: true, in some cases you can't use Eq for Eq
21:53:40 <conal> however, you can wrap an abstraction around the graph rep and recover RT
21:53:48 <mmorrow> totally
21:54:13 <conal> that's what i call "safePerformIO"
21:54:31 <mmorrow> and you can also always map *back* to the circular knotted version from the graph
21:54:34 <mmorrow> so, then
21:54:37 <falmor> is there a channel for monads?
21:54:43 <mmorrow> a == b = reKnot a == reKnot b
21:54:46 <mmorrow> et voila
21:54:48 <mmorrow> :)
21:54:55 <Cale> falmor: This is probably the closest thing you will find.
21:55:01 <falmor> ok
21:55:09 <^Someone^> Wow, a channel just for monads, lol
21:55:10 <conal> mmorrow: make sure you don't "show" the graph.  would also break RT
21:55:15 <^Someone^> That'd be nice : D
21:55:42 <mmorrow> ah true
21:55:47 <conal> if we have a Monad channel, we'll have to have channels for Functor and Applicative, which are more common than Monad
21:56:47 <chromakode> can you put a forall. in a class definition?
21:57:03 <conal> chromakode: in some places but not others.
21:57:14 <conal> chromakode: where do you want to put the forall?
21:57:42 <chromakode> conal: I have a class that has a phantom type from the ST monad, and I'd like to make it inherit from Eq
21:58:00 <chromakode> e.g. "Eq (a s) => Game a", but that breaks.
21:58:07 <Hunner> I'm used to using regexes to parse strings in ruby and perl. What is the Haskell Way?
21:58:13 <chromakode> I think what I mean is Eq (forall s. a s)?
21:58:28 <timmaxw> so it looks like andyjgill is basically using StableName without unsafePerformIO... or do i need to read more than the first 2 pages?
21:58:41 <mmorrow> timmaxw: unsafePerformIO isn't needed for StableName
21:58:54 <chromakode> Hunner: maybe parsec?
21:59:00 <conal> chromakode: i've wanted that ability also.  haskell typing is *almost* a higher-order logic programming language (Lambda-Prolog), but not quite.
21:59:49 <mmorrow> timmaxw: basically, you work in (StateT Env IO a), where
21:59:59 <falmor> lol ^Someone^
22:00:06 <falmor> thats why i joined that xmonads
22:00:10 <mmorrow> data Env a = Env {graph :: IntMap [(StableName, a)]
22:00:11 <falmor> stupid me
22:00:12 <chromakode> conal: rats, thanks :(
22:00:21 <mmorrow> err, so StateT (Env b) IO a
22:00:30 <conal> chromakode: yeah, bummer :(  leads to unfortunate hacks.
22:00:34 <mmorrow> well, s/b/the untangled node rep/
22:00:36 <timmaxw> i don't know what StateT is off the top of my head
22:00:45 <chromakode> conal: so there's no way I can mitigate the lack of this, and properly inherit from Eq?
22:00:45 <mmorrow> @src StateT
22:00:46 <lambdabot> Source not found. You speak an infinite deal of nothing
22:00:58 <mmorrow> it's just  s -> IO (a, s)
22:01:15 <mmorrow> so you accumulate the graph in the state
22:01:32 <mmorrow> and runStateT :: StateT s m a -> s -> m (a, s)
22:01:58 <conal> chromakode: i wouldn't jump to "no way".
22:02:11 <timmaxw> i would have to look at that for a while to understand it - monads aren't my strong point
22:02:23 <bnijk> what's good functional style
22:02:51 <mmorrow> timmaxw: the method is essentially to perform the same algo that a Cheney GC uses
22:03:03 <mmorrow> timmaxw: so reading about that might be helpful
22:03:13 <mmorrow> (or at least, that's the algo i use)
22:03:20 <timmaxw> ok, maybe i'll look at that
22:03:43 <mmorrow> where the "tospace" is the IntMap in the StateT's state
22:03:49 <conal> bedtime for me.  good-night/day all!
22:03:53 <mmorrow> night
22:03:58 <chromakode> conal: thanks for the help, have a nice rest :)
22:04:04 <conal> :)
22:04:12 <chromakode> btw, I enjoyed your post on C as a pure language!
22:04:20 <conal> chromakode: :)!
22:04:57 <rick_2047> conal, what post
22:05:06 <rick_2047> what do u mean by pure??
22:05:10 <chromakode> it was good brain food as I was learning monads
22:05:24 <bnijk> hmm
22:05:29 <rick_2047> can i have a lin
22:05:32 <rick_2047> link*
22:05:41 <chromakode> http://conal.net/blog/posts/the-c-language-is-purely-functional/
22:05:49 * chromakode does not intend to stir up the flame war again
22:05:55 <chromakode> read the reddit comments for some interpretation
22:06:13 <rick_2047> chromakode, dont worry i never war
22:06:22 <chromakode> :)
22:09:16 <eck> is there a way to convert between the bytestring type of Data.ByteString.Internal and Data.ByteString.Lazy.Internal ?
22:09:24 <rick_2047> chromakode, i dont get it does he mean c++ when he says cpp??
22:09:29 <mmorrow> eck: toChunks/fromChunks
22:09:39 <mmorrow> @hoogle toChunks
22:09:39 <lambdabot> Data.ByteString.Lazy toChunks :: ByteString -> [ByteString]
22:09:39 <lambdabot> Data.ByteString.Lazy.Char8 toChunks :: ByteString -> [ByteString]
22:09:45 <mmorrow> @hoogle fromChunks
22:09:45 <lambdabot> Data.ByteString.Lazy fromChunks :: [ByteString] -> ByteString
22:09:45 <lambdabot> Data.ByteString.Lazy.Char8 fromChunks :: [ByteString] -> ByteString
22:10:04 <eck> nat
22:10:06 <eck> neat, even
22:10:45 <chromakode> rick_2047: he means the c preprocessor
22:10:57 <rick_2047> chromakode, o then all is well
22:16:28 <ski> chromakode : iirc, you can make an auxilary `Eq' class
22:16:44 <chromakode> ski: EqST, or something?
22:16:47 <ski> no
22:17:03 <chromakode> I'm afraid I don't understand, thne
22:17:05 <ski>   instance AllEq a => Game a
22:17:08 <rick_2047> are tuples member of the Enum typeclass??
22:17:13 <ski>   class AllEq f
22:17:14 <ski>     where
22:17:25 <ski>     feq :: f a -> f a -> Bool
22:17:28 <ski>     fneq :: f a -> f a -> Bool
22:17:41 <chromakode> ski: ! thanks, that's a great idea
22:17:49 <ski>     f0 `feq` f1 = not (f0 `fneq` f1)
22:17:54 <ski>     f0 `fneq` f1 = not (f0 `feq` f1)
22:18:02 <bnijk> so x <- y, what is the definition of y
22:18:03 <ski> if you had wanted
22:18:19 <ski>   instance (forall s. Eq s => a s) => Game a
22:18:23 <ski> then you'd had
22:18:29 <ski>     feq :: Eq a => f a -> f a -> Bool
22:18:32 <ski>     et.c
22:18:34 <ski> instead
22:19:03 <ski> bnijk : where is this snippet coming from ?
22:19:09 <bnijk> nowhere
22:19:14 <bnijk> what are the possible values for y
22:19:24 <ski> that depends on how you've defined `y'
22:19:36 <chromakode> ski: thanks -- so I think you'd use feq instead of ==,?
22:19:44 <ski> yes
22:19:48 <chromakode> alright, it
22:20:01 <bnijk> mmnn
22:20:01 <chromakode> that's a reasonable workaround, thanks.
22:20:17 <bnijk> what are all possible values for y
22:20:19 <bnijk> is my question
22:20:25 <bnijk> or types
22:20:27 <bnijk> or whatever
22:20:43 <ski> oh .. the possible types is a quite different question :)
22:20:45 <chromakode> bnijk: I think your question is too vague to answer properly
22:21:05 <bnijk> i don't know how to make it any more specific
22:21:22 <ski> the possible types of that (assuming it's part of a `do'-block) is types of form `m a' where `a' is any type, and `m' is any type that is an instance of the typeclass `Monad'
22:21:32 <bnijk> now there's the answer
22:21:39 <bnijk> things are starting to come together
22:21:51 <bnijk> what's going on if it's not part of a do block?
22:21:52 <ski> if you provide more detail, we might be able to answer with more detail
22:22:03 <mmorrow> Cale: (err, to be clear i wasn't suggesting using all that as a general-purpose way to do graph stuff with haskell, but rather as a special-purpose tool to accomplish certain things that are impossible otherwise)
22:22:10 <ski> > [(x,y) | x <- "abc" , y <- [4,5]]
22:22:11 <lambdabot>   [('a',4),('a',5),('b',4),('b',5),('c',4),('c',5)]
22:22:22 <Cale> mmorrow: Yeah, that became clearer :)
22:22:23 <ski> bnijk : ^ it could be part of a list comprehension
22:22:43 <bnijk> those things are nifty
22:22:59 <ski> bnijk : also, it could be part of a "pattern guard" (an extension)
22:23:17 <chromakode> I think what bnijk might be running against is Haskell's type inference?
22:23:21 <ski> (and also possibly part of arrow syntax, iirc)
22:23:30 <bnijk> > [(x,y,z) | x <- [1..2] , y <- [1..4] , z <- [1..8]]
22:23:31 <lambdabot>   [(1,1,1),(1,1,2),(1,1,3),(1,1,4),(1,1,5),(1,1,6),(1,1,7),(1,1,8),(1,2,1),(1...
22:23:42 <bnijk> i wanted the whole thing you stupid bot
22:23:51 <ski> bnijk : try in private :)
22:23:57 <bnijk> > [(x,y,z) | x <- 1 , y <- [1..2] , z <- [1..4]]
22:23:58 <lambdabot>   No instance for (GHC.Num.Num [t])
22:23:58 <lambdabot>    arising from the literal `1' at <inter...
22:24:02 <bnijk> > [(x,y,z) | x <- [1] , y <- [1..2] , z <- [1..4]]
22:24:03 <lambdabot>   [(1,1,1),(1,1,2),(1,1,3),(1,1,4),(1,2,1),(1,2,2),(1,2,3),(1,2,4)]
22:24:08 <pumpkin> o.O
22:24:20 <ski> bnijk : /msg lambdabot > [(x,y,z) | x <- [1..2] , y <- [1..4] , z <- [1..8]]
22:25:08 <bnijk> :t $
22:25:09 <lambdabot> parse error on input `$'
22:25:15 <bnijk> :t ($)
22:25:16 <ski> @type ($)
22:25:16 <lambdabot> forall a b. (a -> b) -> a -> b
22:25:17 <lambdabot> forall a b. (a -> b) -> a -> b
22:25:34 <bnijk> WHAT
22:25:49 <ski> @src $
22:25:49 <bnijk> hmmm
22:25:49 <lambdabot> f $ x = f x
22:26:03 <bnijk> (drop 1 (drop 1 ("hello"))
22:26:10 <bnijk> > (drop 1 (drop 1 ("hello"))
22:26:11 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
22:26:24 <bnijk> uughhgs
22:26:26 <ski> > (drop 1 . drop 1) "hello"
22:26:26 <chromakode> that's odd.
22:26:27 <lambdabot>   "llo"
22:26:27 <bnijk> > drop 1 (drop 1 ("hello")
22:26:28 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
22:26:36 <ski> > drop 1 . drop 1 $ "hello"
22:26:37 <lambdabot>   "llo"
22:26:41 <ski> > drop 1 (drop 1 "hello")
22:26:42 <lambdabot>   "llo"
22:26:51 <bnijk> drop 1 . reverse . drop 1 $ "hello"
22:26:55 <bnijk> > drop 1 . reverse . drop 1 $ "hello"
22:26:56 <lambdabot>   "lle"
22:27:00 <pumpkin> > text "why not take it to PM?"
22:27:01 <lambdabot>   why not take it to PM?
22:27:08 <bnijk> > text "why take it to PM?"
22:27:09 <lambdabot>   why take it to PM?
22:27:17 <bnijk> are you guys doing something more important ;)
22:27:37 <pumpkin> do 600 people really need to see your experiments unless you're trying to show us something?
22:27:43 * pumpkin shrugs
22:27:47 <bnijk> 600 people, 597 idling
22:27:59 <lametier> I rather watch the joins and parts
22:28:05 <pumpkin> I like to check up on my IRC client periodically to see if any interesting talk happens in here
22:28:15 <pumpkin> seeing unread messages in here gets me excited :)
22:28:23 <chromakode> hah, lametier
22:28:24 <pumpkin> until I see they're just lambdabot output :)
22:28:25 <lametier> pretty true
22:28:46 <ray> lambdabot output is fine
22:28:55 <ray> BORING lambdabot output, otoh
22:28:56 <pumpkin> but, I'm guilty of it myself sometimes, so I'll just shut up
22:29:33 <lament> > "boring output"
22:29:34 <lambdabot>   "boring output"
22:30:06 <ray> @unpl fmap fmap fmap fmap fmap
22:30:07 <lambdabot> fmap fmap fmap fmap fmap
22:31:08 <chromakode> if you copy an STArray, will it be == the copy?
22:31:36 <pumpkin> only if its elements are Eq ;)
22:31:37 <bnijk> > pumpkin sucks
22:31:38 <lambdabot>   "yes he does"
22:31:42 <bnijk> ;)
22:31:52 <chromakode> pumpkin: but not if they aren't?
22:31:52 <pumpkin> is that a new kind of popsicle?
22:32:08 * bnijk wins, champagne for everyone
22:32:10 <pumpkin> chromakode: well, if they aren't, the question isn't necessarily meaningful :)
22:32:18 <chromakode> pumpkin: hmm.
22:32:31 <chromakode> well, my derived Eq doesn't seem to be working
22:32:40 <pumpkin> if I have an STArray of functions
22:32:57 <chromakode> nah, I have an STArray of types with Eq
22:33:19 <ski> chromakode : copy how ?
22:33:30 <pumpkin> well, your equality needs to keep in mind that the STArray is in ST
22:33:40 <bnijk> > pumpking andTheTravellingThieves
22:33:41 <lambdabot>   Not in scope: `pumpking'
22:33:43 <bnijk> > pumpkin andTheTravellingThieves
22:33:44 <lambdabot>   "oh yeah baby, take off your wig, let me see that shav'd head"
22:33:44 <chromakode> ski:     bounds <- getBounds board
22:33:44 <chromakode>     elems  <- getElems board
22:33:44 <chromakode>     newListArray bounds elems
22:34:19 <pumpkin> :)
22:36:57 <chromakode> ski: it seems it's not comparing the arrays by value
22:37:16 <chromakode> I guess I'll just define Eq manually
22:37:41 <bnijk> > pumpkin willYouMarryMe
22:37:43 <lambdabot>   "oh babyy u r so romanticc"
22:38:25 <bnijk> that's a yes then
22:38:33 <bnijk> legally binding you should know
22:39:04 <ski> chromakode : yes, reference and (mutable) array equality is "pointer equality" .. i was going to let lambdabot demonstrate that, but it appears `newArray' is not in scope in its evaluator
22:39:28 <pumpkin> , newArray
22:39:30 <lunabot>  luna: No instance for (GHC.Show.Show ((i, i) -> e -> m (a i e)))
22:39:38 <chromakode> thanks ski! bummer :)
22:39:57 <pumpkin> , let x = newArray (0, 5) 4 in x == x
22:39:58 <lunabot>  luna: No instance for (GHC.Classes.Eq (m (a t t1)))
22:40:39 <pumpkin> , let x = newArray (0, 5) 4 :: ST s (STArray Int Int) in x == x
22:40:40 <lunabot>  luna: `GHC.Arr.STArray GHC.Types.Int GHC.Types.Int' is not applied to eno...
22:40:44 <ski> (chromakode : and btw, that's the only sensible choice for mutable structures, given a non-IO/ST/whatever equality operation)
22:40:46 <pumpkin> bah, I give up :)
22:40:52 <bnijk> you're breaking my heart pumpkin ;(
22:40:53 <pumpkin> I need more state types in there
22:40:58 <chromakode> ski, ah, you're absolutely right!
22:41:49 <pumpkin> bnijk: oh no!
22:41:53 * bnijk is heartbroken
22:42:04 <ski> (however, i don't atm recall whether they're actually in `Eq' ..)
22:42:14 <chromakode> ski, they are :(
22:42:19 <bnijk> reddit keeps showing ads saying "You remember ________" and then a picture of a game, where that happens, and it's creeping me out because i DO remember them, and ALL of them
22:42:35 <bnijk> not to mention all the chatbots i've seen recently which appear to be sentient
22:42:39 <Gracenotes> is this really so
22:42:41 <chromakode> you should give the marketers a pat on the back, then
22:42:53 <pumpkin> it's just trying to send you to the games subreddit
22:43:03 <chromakode> man, is everyone here a redditor?
22:43:12 <bnijk> we're all internet deities i assume
22:43:19 <bnijk> i'm loki, which makes pumpkin.....venus
22:43:30 <chromakode> O_o
22:43:36 <Gracenotes> pumpkin: I don't quite get why most reddit ads are internal
22:43:37 * bnijk inches closer to pumpkin
22:43:43 <chromakode> Gracenotes: because they can
22:43:45 <pumpkin> bnijk: #haskell-blah
22:43:50 <Gracenotes> yeah, I know, but still..
22:48:51 <ski> , let new :: Ix i => (i,i) -> a -> ST s (STArray s i a); new = newArray in runST (do board <- new (0,3) 'a'; bounds <- getBounds board; elems <- getElems board; board' <- newListArray bounds elems; return (board == board'))
22:48:53 <lunabot>  False
22:49:06 <ski> , let new :: Ix i => (i,i) -> a -> ST s (STArray s i a); new = newArray in runST (do board <- new (0,3) 'a'; return (board == board))
22:49:08 <lunabot>  True
22:49:26 <ski> , let new :: Ix i => (i,i) -> a -> ST s (STArray s i a); new = newArray in runST (do board <- new (0,3) id; return (board == board))
22:49:28 <lunabot>  True
22:49:47 <ski> there
22:51:13 <ski> (pumpkin : you were trying to compare `ST s'-actions, instead of arrays ..)
22:51:24 <pumpkin> yeah, makes sense
22:52:01 * ski had a hard time convincing lunabot that those arrays actually were `STArray s's, though
22:52:58 <bnijk> > drop 1 . take 2000 . show $ fix ("blah " ++)
22:52:59 <lambdabot>   "blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah...
22:53:04 <bnijk> oh baby
22:53:40 <ski>   fix ("blah " ++) = cycle "blah "
22:54:58 <Gracenotes> ski: sometimes you need scoped type variables too
22:55:22 <quicksilver> Gracenotes: well you never *need* scoped type variables.
22:55:28 <quicksilver> Gracenotes: but it can be a pain without them.
22:55:35 <Gracenotes> ski: someone had written a module that acted as a specific "id" for mutable arrays to get around that issue
22:55:59 <bnijk> > forever young
22:55:59 * ski tried with `foo :: forall s. ...; foo = do ...' as well as `board :: STArray s Int Char <- newArray ...' .. to no avail
22:55:59 <lambdabot>   Ambiguous occurrence `forever'
22:55:59 <lambdabot>  It could refer to either `L.forever', defin...
22:56:03 <bnijk> mmn
22:56:16 <Gracenotes> ski: which helped to infer the correct type
22:56:56 <bnijk> > foreverr "young"
22:56:57 <lambdabot>   "youngyoungyoungyoungyoungyoungyoungyoungyoungyoungyoungyoungyoungyoungyoun...
22:57:01 <bnijk> get it?
22:57:04 * bnijk winces
22:57:07 <pumpkin> heh
22:57:17 <Gracenotes> forever for [] actually doesn't do anything
22:57:35 <Gracenotes> it makes more sense for IO
22:58:03 <ski> (and for expression-monads ..)
22:58:07 <Gracenotes> @undefine forever
22:58:24 <ski> `undefine' doesn't take an argument
22:58:41 <Gracenotes> eesh. messy system.
22:58:42 <pumpkin> (his function was foreverr)
22:58:56 <Gracenotes> I know, but there's a duplicate forever as well
22:59:33 <ski> > forever Nothing
22:59:34 <lambdabot>   Nothing
22:59:40 <Gracenotes> *there was
22:59:44 <Gracenotes> eesh, no extraneous PM @lets. Such a mess to clean up :/
22:59:52 * bnijk burps
22:59:53 <pumpkin> > forever id 5
22:59:57 <pumpkin> :)
22:59:59 <lambdabot>   mueval-core: Prelude.read: no parse
22:59:59 <lambdabot>  mueval: ExitFailure 1
23:00:21 <bnijk> > foreverr "disco-dancing "
23:00:22 <lambdabot>   "disco-dancing disco-dancing disco-dancing disco-dancing disco-dancing disc...
23:00:40 <amckinley> how does lazy evaluation work with monads?
23:00:53 <pumpkin> no differently
23:01:03 <pumpkin> they're just another typeclass
23:01:14 <pumpkin> or instances of one :)
23:01:41 <amckinley> pumpkin: so if i have something like "regularList <- someActionThatReturnsAList" in my monad, that doesnt force the evaluation of the list?
23:02:08 <pumpkin> nope, it's just syntactic sugar for someActionThatReturnsAList >>= \regularList ->
23:02:19 <Gracenotes> well, monads do sequence things, but it might be possible for a monad's current state to include unevaluated parts of previous actions
23:03:05 <amckinley> neat, thanks
23:03:47 <Gracenotes> now, there are monads that are informally considered "lazy" and those that are considered "strict", and as far as I can tell it's partly due to whether these unevaluated parts occur "naturally", and in practice, if stack overflows result...
23:03:52 <ski> ("sequence" here is different from "force" .. the former is on a high conceptual level, while the latter is on a low operational level)
23:04:45 <Gracenotes> or, s/naturally/inherently/...
23:05:34 <amckinley> Gracenotes: what im doing is writing a parser in parsec. ive got a parser called lexer and a parser called tokenizer. for tokenizer to return the next token, it might need to consume multiple lexemes
23:05:46 <pumpkin> :o
23:06:40 <amckinley> so im trying to figure out if i can do something like "lexemeList <- many lexer", or if that will consume the entire input stream
23:07:14 <Gracenotes> hmmm... well, it might be simpler to split the lexing and tokenizing phases for the time being...
23:07:36 <amckinley> Gracenotes: as in, make two calls to runParser?
23:08:56 <Gracenotes> if you do have "lexemeList <- many lexer", it will consume as many as possible before moving onto the next step
23:09:11 <amckinley> Gracenotes: yeah, just discovered that :/
23:09:52 <amckinley> Gracenotes: if you can explain how i could turn my lexeme list into a Stream that i can build another parser around, that would do it :)
23:11:35 <Gracenotes> amckinley: well. For better or worse, Parsec is a very general parser :)
23:11:49 <Gracenotes> so instead of parsing a String, you could parse a [String]
23:12:36 <Gracenotes> or in terms of GenParser: having a GenParser of [Char] instead of one of Chars
23:13:25 <amckinley> Gracenotes: right. im actually using parsec 3, so i think its even easier
23:13:43 <Gracenotes> in general it makes sense to lex and then higher-level parse, although it differs from case to case of course...
23:13:56 <amckinley> Gracenotes: thats fine with me :)
23:14:06 <amckinley> heres the type signature for my lexer:
23:14:06 <amckinley> lexer :: Parsec String DnsParseState Lexeme
23:14:21 <amckinley> so i would need a tokenizer that looks like
23:14:35 <amckinley> tokenizer :: Parsec [Lexeme] DnsParseState Token
23:15:05 <Gracenotes> you could sometimes combine the steps without much harm..
23:15:17 <Gracenotes> ah, you're parsing DNS?
23:15:27 <amckinley> Gracenotes: guilty as charged :) dns zone files
23:15:45 <Gracenotes> just wondering, for a client or a server?
23:16:34 <amckinley> for a parser :) im building a library for programatically interacting with dns zone files
23:17:11 <Gracenotes> ah
23:17:37 <amckinley> and then validating the resulting config and pretty-printing it back out
23:19:25 <amckinley> Gracenotes: so can i just declare a function like that^ and everything will work? or do i need to make [Lexeme] an instance of Stream or something?
23:19:47 <Gracenotes> uh. I think lists already are stream
23:19:50 <Gracenotes> s
23:20:03 <amckinley> Gracenotes: oh, that would make sense :)
