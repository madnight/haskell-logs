00:14:00 <ivanm> I noticed that harrop seems to be expanding his trolling repetoire...
00:14:21 <Twey> Oh?
00:14:41 <ivanm> he was trolling about a linux vs windows article on reddit
00:14:50 <ivanm> (he was pro-windows)
00:27:07 <Peaker> does anyone here use Iteratee?
00:27:15 <Peaker> ivanm: link?
00:27:36 * ivanm goes off to find it on reddit
00:28:11 <ivanm> I was reading it before on a different computer, which is why I didn't post the link initially
00:28:36 <ivanm> http://www.reddit.com/r/programming/comments/8u60s/linux_is_not_windows/
00:42:18 <portnov> dons: is `plugins' package working with ghc 6.10.1 ?
00:44:26 <Peaker> ivanm: Do you think Harrop is a troll, or just someone with really controversial (and silly!) opinions?
00:44:52 <ivanm> AFAICT, the only difference is that a troll goes and says those opinions ;-)
00:45:03 <ivanm> but in this instance, he appears at least slightly troll-ish
00:45:20 <Twey> I'm pretty sure he does it deliberately
00:45:52 <dibblego> he is sociopathic
00:46:08 <Saizan> it's trolling used as propaganda for his products and the platforms where they work
00:46:54 <ivanm> dibblego: all set for the tute? ;-)
00:47:04 <dibblego> yeah think so
00:49:23 <Peaker> Twey: why do you think?
00:49:45 <Peaker> I think he's not necessarily a troll, just what one might call.. an idiot :-)
00:51:34 <Peaker> heh, ok he said:  'where it is said that "BASIC (and Lisp) pollute your mind and make you a worse programmer".'  so I guess he is trolling indeed :)
01:01:11 <Peaker> ok, after a bit of research, Harrop is definitely trolling on purpose
01:01:18 <ivanm> heh
01:01:26 <ivanm> notice the whole .Net bit...
01:02:01 <Alpounet> where ?
01:02:12 <ivanm> in the link I pasted above
01:03:30 <Alpounet> I wasn't connected, can you please give it again ?
01:04:41 <ivanm> http://www.reddit.com/r/programming/comments/8u60s/linux_is_not_windows/
01:05:52 <Alpounet> thanks
01:07:22 <Alpounet> heh, nice Troll indeed.
01:07:33 <Alpounet> Harrop runs Debian, among other, IIRC.
01:07:45 <ivanm> :o
01:07:50 <ivanm> and he _still_ trolls! :o
01:11:35 <Alpounet> haha
01:17:00 <Botje> @pl \x -> writeArray arr x 1
01:17:01 <lambdabot> flip (writeArray arr) 1
01:17:03 <Botje> doh
01:17:16 <maltem_> Harrop probably tries to be as snappy as Torvalds :)
01:26:26 <Botje> damn
01:26:40 <Botje> Data.Array.Marray efficiently packs an Array of Bool into size n/8
01:26:45 <Botje> that's cool :)
01:28:56 <Gracenotes> isn't MArray a typeclass?
01:29:31 <Botje> yes, it's implemented by IOArray and friends
01:29:43 <Botje> I think regular Arrays use it too
01:29:49 <Gracenotes> but also by STArray and friends, no? :)
01:30:20 <kniu> Can universal types be encoded in terms of existential types?
01:30:34 <Botje> yes :)
01:56:12 <maltem> That must be unboxed arrays, no?
01:56:43 <maltem> It's definitely a nice interface to a bitfield :)
02:00:24 <araujo> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6103#a6103
02:00:34 <araujo> quicksort version in my tiny language
02:00:37 * araujo just got it working
02:00:39 <araujo> :)
02:01:46 <uzytkownik> @pl \m k -> m {runConnection = runConnection m >>= runConnection k}
02:01:47 <lambdabot> (line 1, column 11):
02:01:47 <lambdabot> unexpected "{"
02:01:47 <lambdabot> expecting variable, "(", operator or end of input
02:02:00 <uzytkownik> @pl \m k -> Connection (runConnection m >>= runConnection k)
02:02:01 <lambdabot> (Connection .) . (. runConnection) . (>>=) . runConnection
02:02:21 <uzytkownik> @hoogle isomorphism
02:02:22 <lambdabot> No results found
02:02:30 <AllNight^> hello :)
02:03:42 * Botje waves at AllNight^ 
02:04:14 * AllNight^ waves back to Botje :)
02:09:36 <AllNight^> hows things Botje? :)
02:10:06 <MyCatVerbs> Greetings, comrade Botje!
02:10:45 <AllNight^> hi MyCatVerbs :)
02:11:07 <Botje> MyCatVerbs: a majestic morning to you sir!
02:11:17 <Botje> i'm refactoring my solution for project euler #204
02:11:38 <MyCatVerbs> Having fun?
02:13:15 * AllNight^ is fiddling with Wine :|
02:13:42 <AllNight^> btw... does anyone know if there's a Haskell library for getting at raw posix data - like Inode numbers?
02:13:50 <AllNight^> or am I going to have to code that using the FFI?
02:14:43 <Botje> MyCatVerbs: i noticed my approach couldn't be more wrong :)
02:17:23 <Botje> bleah.
02:17:23 <AllNight^> bah!
02:17:25 <Botje> it is :(
02:17:33 <AllNight^> sorry about that :|
02:17:55 * AllNight^ wonders if anyone answered his question during his brief enforced absence :|
02:20:51 <Heffalump> AllNight^: no, they didn't
02:21:52 <Heffalump> and I don't see anything on hackage
02:21:55 <AllNight^> thanks Heffalump :)
02:22:04 <Heffalump> so likely the answer is no
02:22:20 <AllNight^> ah well - I'm just learning Haskell - but I dont mind contributing code back :)
02:22:42 <Heffalump> oh, but the basic System.POSIX library might have it
02:22:45 * AllNight^ thinks it would make a rather superior scripting language
02:23:08 <Heffalump> look in System.Posix.Types - there's a CIno type
02:23:13 <AllNight^> I was actually telling people about 10 years ago that the unix shell was trying to be a lazily evaluated functional language (pipes) -- and failing miserably
02:23:19 <AllNight^> ty :)
02:23:25 <Heffalump> and System.Posix.Files has fileId which wraps up a CIno
02:23:36 * Heffalump has been playing with John Goerzen's HSH library recently
02:23:56 <AllNight^> HSH library?
02:24:02 <Heffalump> found a few problems with both it and with GHC though (some I've reported already, some I'm still writing up)
02:24:07 <Heffalump> Haskell Shell
02:24:10 <Heffalump> it's on hackage
02:26:13 <Heffalump> the basic summary of my problems is that it works a lot better if you use the threaded runtime (-threaded to GHC when compiling) but then things are somewhat slower
02:26:36 <uzytkownik> @pl \f -> StateT (runKleisli (Kleisli f &&& arr id))
02:26:36 <lambdabot> StateT . runKleisli . (&&& arr id) . Kleisli
02:27:56 <uzytkownik> @pl \s -> liftC (\h -> hPutStr h s >> hPutStr h nEOLSeq >> hFlush h)
02:27:56 <lambdabot> liftC . (`ap` hFlush) . ((>>) .) . (`ap` flip hPutStr nEOLSeq) . ((>>) .) . flip hPutStr
02:28:11 <uzytkownik> @pl \h -> hPutStr h s >> hPutStr h nEOLSeq >> hFlush h
02:28:12 <lambdabot> ap ((>>) . ap ((>>) . flip hPutStr s) (flip hPutStr nEOLSeq)) hFlush
02:52:25 <ski> (Botje : how ?)
02:53:33 <Botje> ski: i was walking the entire list of 10^9 numbers
02:53:52 <Botje> and eliminating all multiples of primes > 100
02:55:45 <ski> sorry, i should provide more context
02:55:54 <ski> you affirmed "Can universal types be encoded in terms of existential types?"
02:57:21 <AllNight^> actually - that reminds me of another question - is there a guide to all the GHC options somewhere?
02:57:38 * AllNight^ kinda staggered by the number of flags available
02:59:25 * portnov .oO ( ... there are only 527 users on #c++; which language is more popular now? :o) )
03:01:58 <stulli> AllNight^, you might find some here: http://www.haskell.org/ghc/docs/latest/html/users_guide/
03:03:22 <AllNight^> ty stulli :)
03:25:39 <rprije> Does anyone know where cabal puts hackage documentation (if anywhere) after doing a cabal install?
03:37:33 <ziman> @index comparing
03:37:33 <lambdabot> bzzt
03:40:54 <rprije> s/hackage/haddock/
03:50:09 <dschoepe> rprije: I don't know about the defaults, but cabal install has a --docdir and --htmldir flag.
04:13:29 <Saizan> rprije: ghc-pkg field $pkg haddock-html
04:40:52 <mamalujo_> how do I tell cabal haddock to put documents in /usr/local/share/doc ?
04:48:22 --- mode: irc.freenode.net set +o ChanServ
04:48:49 <Saizan> mamalujo_: --docdir=/usr/local/share/doc
04:48:58 <mamalujo_> thx
04:49:32 * Cale writes a FizzBuzz implementation for a friend which uses both the Monad and Monoid instances for Maybe :)
04:50:04 <Saizan> there's also --prefix=/usr/local which influences the other paths too
04:50:12 <Saizan> or maybe you want a --global installation
04:50:25 <BONUS> haha
04:51:13 <Cale> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6110#a6110
04:51:19 <BONUS> note to self: write fizzbuzz with ContT
04:51:33 <mamalujo_> i did a --global instalation, but it didnt create documents, paco tells me
04:52:01 <BONUS> awesome
04:52:06 <Saizan> mamalujo_: you can use --enable-documentation for that
04:52:22 <Philonous> @type []
04:52:24 <lambdabot> forall a. [a]
04:52:27 <mamalujo_> ah, thx
04:52:55 <BONUS> wait where is Maybe  used as a monad though
04:53:03 <Cale> Well, MonadPlus
04:53:07 <Saizan> mamalujo_: you can also make it the default by putting documentation: True in the ~/.cabal/config file
04:53:57 <BONUS> ah yeah
04:54:08 <BONUS> thats a great implementation though, i never would have thought of that
04:55:51 <Cale> Yeah, completely avoiding mod is fun :)
04:56:02 <BONUS> haha
04:57:46 <BONUS> i've been thinking about representing permutations in haskell. since permutations are bijective endomorphisms, it seems natural to represent them as functions
04:58:01 <BONUS> then they can also easily be made monoids because mempty = id
04:58:11 <BONUS> however, then you can't make an inverse easily
04:58:32 <Cale> Well, that's okay, they're a special type of Monoid. Specifically, they're a group.
04:58:45 <Cale> class Monoid a => Group a where
04:58:47 <BONUS> if you use [(a,a)] to represent them, getting the inverse is easy
04:58:49 <Cale>   inverse :: a -> a
04:58:58 <Cale> Oh, well, yes :)
04:59:01 <BONUS> but getting mempty is beyond me
04:59:13 <Cale> That representation does make them tricky to invert.
04:59:33 <Cale> You basically have to work out some other representation first, and then construct the inverse from that.
04:59:55 <BONUS> hmm yeah
05:00:13 <uzytkownik> @hoogle get
05:00:13 <lambdabot> Text.ParserCombinators.ReadP get :: ReadP Char
05:00:13 <lambdabot> Text.ParserCombinators.ReadPrec get :: ReadPrec Char
05:00:13 <lambdabot> Control.Monad.State.Class get :: MonadState s m => m s
05:01:31 <Cale> Of course, you could also represent them as pairs of functions.
05:01:47 <Cale> That is, just save a witness that it's really invertible
05:01:47 <FunctorSalad_> BONUS: I guess if you want it to be efficient you should use an integer array
05:01:48 <BONUS> like f and f^-1?
05:01:52 <Cale> Then you can do
05:01:57 <Cale> inverse (f,g) = (g,f)
05:02:12 <Cale> Trivial ;P
05:02:20 <FunctorSalad_> (but I don't actually know about the efficiency issues in detail here)
05:02:22 <BONUS> FunctorSalad_: yeah but permutations can operate on any type, not just integers
05:02:37 <BONUS> haha, pairs of functions is nice yeah
05:02:50 <BONUS> especially since it's also trivial to get that pair of functions from an [(a,a)] list
05:03:03 <FunctorSalad_> the problem with functions is you can't do anything with them except insert stuff ;)
05:03:39 <Cale> I think I probably prefer disjoint cycle notation for most operations of any importance.
05:04:06 <Cale> To get the inverse there, you'd just reverse all the cycles.
05:04:17 <Cale> You can also very quickly tell the order of the element
05:04:32 <FunctorSalad_> *nod*
05:04:34 <Cale> (just take the lcm of the lengths of the cycles)
05:04:46 <mamalujo_> hm, do I need to tell cabal to re-read its configuration before it takes effect somehow? --enable documentation works, but the flag in config has no effect, maybe because I did a reinstall?
05:05:07 <BONUS> yeah disjoin cycle notation is handy
05:05:16 <Cale> mamalujo_: cabal configure ?
05:05:20 <mamalujo_> ah
05:05:40 <Saizan> no, cabal configure doesn't matter here
05:05:54 <Saizan> mamalujo_: which version of cabal?
05:06:10 <Cale> Well... it does make it re-read the .cabal file, though it usually checks to see if that's changed anyway, doesn't it?
05:06:17 <mamalujo_> 1.6.0.3
05:06:22 <Saizan> mamalujo_: and do you have "documentation: True" on a line by itself, with no preceding --?
05:06:50 <BONUS> ah, if you leave out the fixed points of the permutation, the mempty for the monoid instance can be just []
05:06:52 <mamalujo_> ah, right, thats commented out then - i thought it was like a command line argument
05:06:59 <BONUS> assuming you use [[a]] to represent the disjoint cycles
05:07:11 <Cale> BONUS: yep :)
05:07:30 <FunctorSalad_> BONUS: another option is generators and relations
05:07:33 <yitz> Cale: your inverse witness notation is nice. you could give that an Arrow instance. :)
05:07:40 <Saizan> (btw, 1.6.0.3 is the version of Cabal the library, the executable cabal also has its own version you can get with cabal --version)
05:08:10 <Cale> yitz: Category... but it's hard to do 'arr'
05:08:13 <mamalujo_> 0.6.2 then :)
05:08:34 <FunctorSalad_> but I don't know how easy it is to get an expression into normal form with the symmetric group (generated by, say, the transpositions)
05:08:43 <FunctorSalad_> or adjacent transpositions maybe
05:08:56 <Cale> There is no guarantee of a normal form.
05:09:11 <FunctorSalad_> for arbitrary groups you mean?
05:09:15 <Cale> ah, yeah
05:09:24 <FunctorSalad_> surely it's decidable for the symmetric group :)
05:09:24 <Cale> I suppose for symmetric groups specifically, there would be
05:09:32 <Philonous> Is there a reason there is no show instance for ZipList?
05:09:32 <Cale> hmm...
05:09:33 <rprije> answering my own question before; I had no haddock documentation because I need to supply an --enable-documentation flag to cabal when using cabal install. Thanks to those who helped.
05:09:44 <Cale> Well, all finite groups, at least.
05:09:45 <BONUS> Philonous: i always thought it would have been handy too
05:10:23 * EvilTerran wants a Show instance for Mu, too
05:10:28 <yitz> Cale: ah right. *very* hard to do arr. impossible in fact (I hope)
05:10:31 <Cale> and I don't think an infinite symmetric group can have a finite presentation
05:11:52 <FunctorSalad_> Cale: by cardinality alone...
05:11:57 <Cale> FunctorSalad_: right
05:12:07 <Cale> FunctorSalad_: You can just use brute force :)
05:12:34 <Cale> er, oh, you mean about my comment about finite presentation
05:12:35 <Cale> yeah
05:13:02 <yitz> FunctorSalad_: is it decidable even whether a given presentation is a finite group?
05:13:23 <FunctorSalad_> yitz: I don't know :(
05:14:04 <Cale> It's probably just semidecidable, hmm...
05:14:12 <yitz> It sounds like if it were, you could decide the halting problem for combinators
05:14:40 <ivanm> with the whole Paths_<cabal-name> usage to get version, etc. from the .cabal file, I seem to recall a way of doing so with a temporary file when you haven't run cabal configure or something yet... anyone know if I'm remembering correctly?
05:14:48 <yitz> just an idea for the beginnings of a proof...
05:16:15 <mamalujo_> haskell-platform install doesnt generate documents though? can I regenerate those?
05:19:52 <Cale> yitz: Well... supposing that you could tell when a finitely presented group is finite, you could extend that easily to a test to see if the FP group is trivial, yeah?
05:20:16 <yitz> ok
05:20:47 <Cale> hmm..
05:21:08 <Cale> No, sorry, that doesn't go where I wanted it to :)
05:26:00 <profmakx> Cale  where did you want it to go?
05:26:37 <Cale> profmakx: I wanted to construct an FP group whose triviality would solve the word problem for another FP group.
05:26:50 <Cale> But it didn't work out
05:27:00 <ivanm> Cale: you want another group talking about Functional Programming? :o
05:27:01 <ivanm> ;-)
05:27:10 <Cale> heh
05:27:24 <uzytkownik> @pl \x -> liftIO . x =<< handle `fmap` Connection get
05:27:24 <lambdabot> (handle `fmap` Connection get >>=) . (liftIO .)
05:28:03 <FunctorSalad_> how is FP group formed?
05:28:43 * yitz pokes around the internet a bit
05:29:03 <ivanm> FunctorSalad_: well, first you want to create another group to discuss functional programming... then you convince other people to become interested in such a group and join it...
05:29:12 * ivanm gets over the joke
05:29:20 <Cale> They need to do way instain generator> who kill thier relations.
05:29:42 <FunctorSalad_> those relations can't fight back :(
05:31:26 <ManateeLazyCat> If i want to swap two element in list, how do it?
05:31:51 <Cale> ManateeLazyCat: It's expensive. splitAt on the list twice, and then concatenate pieces of it
05:32:07 <Cale> ManateeLazyCat: If you're doing it a lot, lists are not the data structure for you
05:32:27 <ivanm> sequences might be better
05:33:03 <Cale> (unless they are a specific two elements, like the first two ;)
05:33:04 <yitz> ManateeLazyCat: if you can limit yourself to elements near the beginning of the list, you're ok
05:33:08 <yitz> ha
05:33:52 <ManateeLazyCat> Cale: And bad efficient, O (2n)
05:34:42 <Cale> Well, something like O(n) where n is the larger of the two indices
05:34:54 <Cale> O(max n m) ;)
05:36:26 <maltem> O(n+m) is even less to type
05:36:38 <Cale> I suppose that works too :)
05:36:44 <ManateeLazyCat> Thanks all! :)
05:37:03 <Cale> ManateeLazyCat: Data.Sequence has fast splitting.
05:37:36 <ivanm> Cale: by "fast" you mean log(n)?
05:37:45 <Cale> (It takes on the order of the logarithm to the nearer end of the sequence)
05:37:47 <FunctorSalad_> yitz: maybe this approach: given a presentation P and two words w1 w2, construct a presentation P' that presents a finite group iff w1 ~ w2
05:37:59 <Cale> Er, logarithm of the distance to the nearer end
05:37:59 <FunctorSalad_> (that's obvious, just thinking aloud)
05:38:24 <yitz> FunctorSalad_: urgh
05:39:16 * ManateeLazyCat pasted "DoubeLinkedList.hs" at http://paste2.org/get/277256
05:39:16 <ManateeLazyCat> Above is DoubleLinkedList library, any suggestions are welcome! :)
05:39:26 <Cale> Or equivalently, given a presentation P and a word w, construct a presentation P' that presents a finite group iff w = 1
05:39:49 <wjt> presumably if you need to swap elements a lot, you should use an STArray or similar
05:40:02 <Cale> singletion -> singleton
05:40:03 <yitz> eww ST
05:40:16 <EvilTerran> nothing wrong with ST
05:40:20 <EvilTerran> in the right situation
05:40:24 <ManateeLazyCat> I just implement some swap functions in my DoubleLinkedList.hs
05:40:31 <Cale> ST?
05:40:36 <Cale> oh
05:40:40 <yitz> EvilTerran: most uses I've seen are premature optimization though
05:40:43 <ManateeLazyCat> now just implement swapLeft and swapRight. :)
05:40:43 * Cale just saw wjt's line :)
05:41:03 <Cale> You can also use Data.IntMap :)
05:41:40 <EvilTerran> ManateeLazyCat, er, a doubly linked list's an odd choice of data structure for a pure functional language
05:42:04 <Cale> Is this really a doubly linked list?
05:42:11 <ManateeLazyCat> http://paste2.org/get/277256 ?
05:42:14 <EvilTerran> seeing as you wouldn't be able to make a modified version of an existant doubly-linked list without copying the entire spine
05:42:18 <ManateeLazyCat> Just interface like.
05:42:21 <EvilTerran> so any modification would be at least O(n)
05:42:22 <Cale> It looks more like a list zipper
05:42:46 <EvilTerran> ah, k
05:42:53 <ManateeLazyCat> EvilTerran: Yep
05:43:20 <Cale> ManateeLazyCat: Is there a good reason for the lists to be strict fields? It's only going to cause the top-level constructor in them...
05:43:33 <Cale> er, to be forced
05:43:39 * Cale has been up a long time :P
05:44:03 <ManateeLazyCat> Before i write DoubleLinkedList.hs, i found PointedList, but it always need an element for create. I don't like it.
05:44:20 <Cale> Hmm, curious, the ListZipper package on Hackage does that as well.
05:44:27 <Cale> data Zipper a = Zip ![a] ![a]
05:44:40 <ManateeLazyCat> I read source code of Zipper, and add more functions that i need.
05:45:04 <FunctorSalad_> with the zipper, the top (:) can get changed a lot I suppose
05:45:05 <yitz> Cale: are you originally from Asia? You often seem to be working on their time zone. :)
05:45:18 <Cale> yitz: No, my hours just drift.
05:45:28 <ManateeLazyCat> Cale: ListZipper have too little functions.
05:45:40 <yitz> ah, like those biological clock experiments
05:45:40 <Cale> I'm apparently originally from a planet whose days are 32 hours long instead of 24.
05:45:54 <yitz> mars?
05:46:52 <Cale> Huh, the Martian day is apparently not much longer than Earth's.
05:47:09 <Cale> 24 hours, 39 minutes, and 35.244 seconds
05:48:43 <Cale> I wonder if that's really a coincidence, or if it follows from the way in which the planets originally formed... hmmm...
05:49:27 <Cale> Well, Venus is way out.
05:49:46 <Cale> 243 Earth days per day on Venus.
05:49:56 * EvilTerran appears to be from a planet with 30-hour days
05:50:01 <Cale> Which is longer than the Venus year.
05:50:18 <ivanm> Cale: I guess coincidence
05:52:11 <mamalujo> maybe venus was faster some time in the past, but was slowed with some tidal interactions with the sun and or some planetary resonances? like with mercury, with rotation-orbit resonance of 3:2
05:56:53 <ManateeLazyCat> Have more suggestions about http://paste2.org/get/277256 ? I always use tree functions: getLeft, getRight, find.
05:58:18 <ManateeLazyCat> I wonder have a better `find` algorithm for DoubleLinkedList.hs
05:58:33 <FunctorSalad_> btw another problem with HOAS: Say you are parametric in the variable type: data Term v where Var :: v -> Term v ; Lam :: (Term v -> Term v) -> Term v
05:58:38 <ManateeLazyCat> Now `find` is O (n) same as List.
05:58:58 <FunctorSalad_> now this isn't covariant in v although it ought to be since it's covariant with other representations
05:59:12 <FunctorSalad_> (IOW, I can't make it a Functor instance)
05:59:43 <mamalujo> ah, yes, wiki agrees, but adds that a major cause of such curious venusian motion is the thick atmosphere and its tides
06:01:47 <FunctorSalad_> now I think one way to make it covariant in v is: "data Term v where { Var :: v -> Term v;  Lam :: (forall w. (v -> w) -> Term w -> Term w) -> Term v }"
06:02:24 <FunctorSalad_> but then I can't make it a Data instance ("can't match a monotype with ....")
06:04:48 <FunctorSalad_> (with that typing, lambda abstracting x ::v from a term t :: Term v goes like this: given conv :: v -> w and t2 :: Term w, plug in t2 for x, then fmap the result with conv). I think
06:05:26 <Saizan_> the second Term is almost like Yoneda of the first Term
06:05:42 <Saizan_> where Yoneda is the newtype wrapper defined in category-extras here
06:06:19 <FunctorSalad_> Saizan_: yes it feels like it but I don't see the exact relationship yet :)
06:06:42 <EvilTerran> ,src ''Yoneda
06:06:46 <lunabot>  newtype Yoneda f a = Yoneda {runYoneda :: (forall b . (a -> b) ->
06:06:46 <lunabot>                                                        f b)}
06:07:07 <FunctorSalad_> lunabot knows every package?
06:07:36 <EvilTerran> ''Foo is template haskell syntax, so Yoneda must be in scope
06:09:03 <hackagebot> fmlist 0.5 - FoldMap lists (SjoerdVisscher)
06:09:34 <FunctorSalad_> "newtype F v = F (Term v -> Term v)" isn't covariant either, though
06:10:04 <FunctorSalad_> I'm a bit puzzled in general why you use covariance with HOAS when with a naive encoding you obviously have it
06:10:08 <FunctorSalad_> *lose
06:10:33 <EvilTerran> , [$ty| Yoneda (<$> "abracadabra") |]
06:10:36 <lunabot>  Yoneda [] Char
06:10:46 <FunctorSalad_> hmm... maybe it's related to the fact that fmap'ing a non-injective function over a lambda term yields nonsense?:)
06:11:06 <FunctorSalad_> s/use covariance/lose covariance/
06:12:07 <Saizan_> the other representations are less accurate about scoping, so they represent more than lamda terms
06:14:06 <Philonous> Is there a foldl for zipLists ?
06:14:30 <FunctorSalad_> Saizan_: *nod*, if I fmap (const ()) over      Lam "x" (Lam "y" (foo "x" "y"))      that won't respect scoping, at least
06:15:02 <FunctorSalad_> so maybe Term is just a Functor for f a bijection
06:17:13 <mamalujo> can I generate documentation recursively? that is, not having to hunt down the correct ordering of doing cabal haddock so that it doesnt complain with "The documentation for the following packages are not installed. No links will be generated to these packages:.."
06:18:56 <Saizan_> mamalujo: not directly, but if you unregister the packages than install will hunt the dependencies recursively and so rebuilding them with docs, if you enable them
06:19:43 <mmorrow> mamalujo: no, but i've used the cabal api to parse cabal files, extract the deps, then find all .cabal files recursively in the subdir tree, parse them, them toposort and run a shell command in each dir..
06:20:19 <mmorrow> not exactly "a quick solution" though ;)
06:20:24 <Saizan_> .cabal files in the subdir tree?
06:20:56 <mmorrow> "find . | grep -E "\.cabal$" | grep -v _darcs" essentially :/
06:21:45 <mmorrow> (this code was meant to be run in a directory that has a bunch of dirs of cabal packaged code under it)
06:21:47 <Saizan_> uhm, i suppose one could start with cabal unpack on all the interested packages, but that wasn't the starting point
06:22:46 <mamalujo> morrow, heh :) , well, I might simply reinstall them 'correctly' as Saizan_ you suggest. But, i tried to save time of hunting down stuff by trying out the platform package. Should I expect a --reinstall on that .cabal to regenerate documentation for all included packages?
06:24:17 <Saizan_> mamalujo: if you unregister the previously installed packages, then yes
06:24:40 <Saizan_> mamalujo: with ghc-pkg unregister
06:24:51 <mamalujo> hm, great, thx
06:24:54 <skorpan> "Perhaps you haven't installed the profiling libraries for package `pcre-light-0.3.1'" <- is profiling a separate library for pcre-light?
06:24:58 <Saizan_> only those installed by installing the platform though
06:25:21 <mauke> skorpan: no, it just has to be enabled at build time
06:25:28 <Saizan_> don't unregister those that came with ghc like base or ghc-prim etc.. or you'll have to reinstall ghc too
06:25:41 <mmorrow> heh, "oops"
06:25:45 <skorpan> mauke: isn't passing -prof to ghc --make enough?
06:25:52 <mamalujo> Saizan_: noted!
06:25:56 <ivanm> Saizan_: not always
06:26:01 <mauke> skorpan: dunno, I've only done it with cabal
06:26:08 <ivanm> if you can find a backup copy of the package.conf file, you can hack around that
06:26:11 <skorpan> mauke: i am doing it with cabal as well
06:26:17 <skorpan> ghc-options:   -Wall -fno-warn-orphans -threaded -prof -auto
06:26:19 <Saizan_> ivanm: true
06:26:27 <mauke> skorpan: eww
06:26:34 <ivanm> we've had to do it a few times on gentoo when we accidentally forgot to state that certain versions came with ghc, so you build them, then uninstall them and it unregisters it from ghc :s
06:26:40 <mauke> skorpan: put 'library-profiling: True' in your config
06:26:44 <skorpan> oh!
06:28:33 <skorpan> mauke: hm, specifically in which part of the config? cabal configure tells me it's an invalid key no matter where i put it
06:28:47 <skorpan> .cabal/config?
06:29:05 <skorpan> okay, thanks :P
06:53:55 <Yrogirg> Hey guys! Why does ghc print such a result?
06:53:55 <Yrogirg> Prelude> let a = 38 :: Int
06:53:55 <Yrogirg> Prelude> (fromIntegral a) * 0.1
06:53:55 <Yrogirg> 3.8000000000000003
06:54:14 <mauke> because that's what the result is
06:55:03 <Beelsebob> why should it not print that result?
06:55:24 <Yrogirg> so it's a processor's accuracy?
06:55:27 <yitz> In python: >>> 38*0.1 gives the same thing
06:55:42 <Beelsebob> > let a = 38 :: Int in (fromIntegral a) * 0.1 :: CReal
06:55:42 <mauke> preflex: calc '2 0.1
06:55:42 <preflex>  0.00011001100110011001100110011001100110011001100110011
06:55:45 <lambdabot>   3.8
06:55:46 <yitz> Yrogirg: the answer is - floating point numbers are weird
06:55:51 <Saizan_> yeah, that's defaulting to Double, which is a machine floating point number
06:55:52 <mauke> not weird, just binary
06:56:09 <mauke> preflex: calc '2 38 * 0.1
06:56:09 <preflex>  11.1100110011001100110011001100110011001100110011
06:56:10 <yitz> mauke: weird is always relative of course
06:56:12 <kynky> the wobble due to precision
06:57:32 <kynky> keep the numbers with the accuracy, when it comes to displaying them, parse them to the level of accuracy you want, i.e. 4dp
06:57:33 * Botje just reached 128 solved problems on project euler
06:57:34 <Botje> yay!
06:58:06 <yitz> Botje: yay! it's not a milestone though. next prime...
06:58:24 <Botje> next prime is 131 i guess? :)
06:58:42 <yitz> Botje: if you've solved that many, I'll rely on you
06:59:52 <yitz> Botje: I have the same thing with my birthdays. People always seem to make a big deal out of multiples of 10. I find prime birthdays more notable.
07:00:19 * Botje is holding out for 42
07:00:46 <Botje> but yes, i think prime numbers are much more beautiful than silly multiples or even powers of 10
07:01:16 <skorpan> i keep getting this error when trying to build my program with profiling: "/usr/bin/ld: cannot find -lHStestpack-1.0.2_p" ...any ideas?
07:01:27 <yitz> Botje: 41 is much more interesting. besides being prime, it's also the first number that has a square root in the 10-adic integers but not the integers.
07:02:00 <Botje> heh heh :)
07:02:28 <Botje> you know, the futurama dvd (bender's big score) has a discussion among the actors of the lowest non-interesting number
07:02:44 <Botje> turns out there isn't any, because that property would, in itself, make it interesting :)
07:03:21 <mauke> old math joke
07:03:24 <yitz> Botje: hehe
07:07:06 <a_guest> I am confused with FFI: C function: void f(const char** errptr);, as FFI: c_f :: Ptr CString -> IO (). After a call to 'c_f' (inside 'alloca'), the pointer now checked against nullPtr. My confusion lies here, since Haskell is a functional language, values should not change.
07:07:54 <a_guest> Or might I read the code wrongly?
07:11:09 <Botje> can you show the whole code? that's probably easier :)
07:11:19 <lpsmith> good morning #haskell
07:11:34 <Botje> hello, lpsmith
07:11:49 <a_guest> Botje: where and how?
07:11:52 <lpsmith> Anybody have a suggestion for spellchecking .lhs files?  Obviously I don't want to spellcheck the code itself :-)
07:12:00 <Botje> hpaste.org is probably best
07:12:33 <a_guest> Botje: ok. I shall write some code there now.
07:16:10 <aavogt> a_guest: since it is in IO, the calls to c_f have an execution order, just like in other languages. I other words, the argument to c_f is constant (same as in C here), but whatever that pointer refers to can be modified (since it is in IO).
07:21:01 <a_guest> my confusion pasted: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6113#a6113
07:23:27 <Cheery> http://i42.tinypic.com/2w2pzet.jpg a lambdaball
07:23:28 <a_guest> the value of Ptr might not be visible in Haskell, hence it might work?
07:23:33 <Cheery> http://bitbucket.org/cheery/lambdaballs/overview/
07:23:59 <Cheery> though, the information yield of that thing is small right now, because it looks so alien
07:24:24 <Cheery> should put some maximum for the length of step.
07:24:29 <EvilTerran> Cheery, looks like some kind of alien language symbol O.o
07:24:56 <Cheery> EvilTerran: it's a lambdaball, I refined their visualization a bit
07:25:18 <EvilTerran> what expression does that screenshot correspond to?
07:25:59 <kacper_> how to compile .hs file to executable?
07:25:59 <Cheery> I didn't capture that info, since it's only random sample I picked while the app was running.
07:26:24 <Zao> ghc --make Foo.hs
07:26:31 <Zao> If using GHC, that is.
07:26:50 <a_guest> aavogt: the argument is constant, but the actual value of the pointer, which changes, is not a value in Haskell?
07:27:08 <Cheery> EvilTerran: from quick glance, it has three lambdas, which have inner lambdas
07:27:14 <eu-prleu-peupeu> hey
07:27:15 <eu-prleu-peupeu> 'sup ?
07:28:07 <Cheery> second of those inner lambdas is I
07:28:28 <a_guest> aavogt: ...is not the Haskell value of Ptr a?
07:28:55 <kacper_> an where is my executable file?
07:29:12 <aavogt> a_guest: the errptr stays constant, what it refers to will change, since you are allowed side-effects for functions in IO
07:29:22 <Cheery> also there's one (xy -> yx) I see.
07:29:55 <Cheery> and another (x -> x(y -> y))
07:30:06 <Cheery> so it represents combination of those
07:30:06 <EvilTerran> Cheery, er, is that "i" on the right and "\xy.yx" on the top?
07:30:28 <EvilTerran> (the top looks more like \xy.xy to me...)
07:30:31 <Cheery> (x -> x(y -> y)) (i -> i) (xy -> yx)
07:30:39 <Cheery> it's in that order
07:30:48 <EvilTerran> ah, read clockwise?
07:30:52 <a_guest> aavogt: yes, that is right, but values in Haskell will not change. Hence the actual pointer value is not the Haskell value of Ptr a.
07:31:10 <Cheery> EvilTerran: yep, start from the line intruding the center
07:31:20 <aavogt> a_guest: define actual pointer value
07:32:04 <a_guest> aavogt: the C pointer to (here) const char*
07:32:41 <EvilTerran> Cheery, do you gain anything from wrapping it up in a circle instead of presenting it straight?
07:33:09 <EvilTerran> (given that it looks like you could "unroll" it to a rectangle)
07:33:36 <Cheery> EvilTerran: actually I first represented it straight.
07:33:50 <Cheery> well.. I get this awesomeness factor in them.
07:34:05 <EvilTerran> that's a good enough reason for me :D
07:34:43 <Cheery> I turn it to polar coordinates and apply distortion with bezier according to the radius.
07:36:57 <Cheery> EvilTerran: I also want the ball form because I am going to do some fun with them.
07:37:24 <Cheery> darn glitches.
07:37:29 <EvilTerran> bouncing lambdaballs?
07:37:49 <Cheery> basicly, I put them to eat oach other too
07:38:50 <Cheery> occassionally the renderer algorithm makes glitches, ones I've noticed are flat lambdas and broken lambda sectors
07:39:38 <Cheery> and since it's basicly woodoo arithmetic and art, it requires lot of effort to fix them.
07:44:34 <Cheery> mockingbirds give fun and staying shapes
07:44:59 <Cheery> I'd hope having couple of ways doing those. perhaps having to remember Y combinator
07:45:26 <EvilTerran> (\f. (\x. f (x x)) (\x. f (x x)))!
07:47:41 <Cheery> heh.
07:48:33 <Cheery> I added that to my random combinator generator, and now it produces shapes that pulse.
07:48:51 <Cheery> pure awesomeness. :)
07:49:17 <Cheery> have to screenshot this piece, that I can do it again later.
07:50:51 <Cheery> pasting the pic before deciphering it
07:51:37 <Cheery> http://i39.tinypic.com/24fl3ph.jpg
07:54:24 <Cheery> hm
07:55:31 <Cheery> WOAH!
07:55:51 <Cheery> while ago it gave me a lambda that grew infinitely.
07:56:07 <Cheery> such thing will bring my algorithm to knees.
07:56:29 <Cheery> I hope those won't appear being interesting too often
07:56:40 <Cheery> otherwise I have to tackle with them.
07:57:39 <Cheery> (x -> x(y -> y)(xx))
07:57:52 <Cheery> hm. pretty much looks like something mixed with Y
07:59:18 <Cheery> really would make a great screensaver
07:59:21 <Cheery> though not stopping there.
08:11:22 <stulli> is there an easy way to construct the list [0,0,1,1,2,2,...] ?
08:11:54 <Zao> > zip [0..] [0..]
08:11:56 <lambdabot>   [(0,0),(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10),(11,11...
08:12:00 <Zao> Erm... no :)
08:12:01 <Cheery> stulli: sounds like you are looking for repeater
08:12:13 <Cheery> :T repeat
08:12:21 <Cheery> @t repeat
08:12:22 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
08:12:32 <Cheery> @type repeat
08:12:35 <lambdabot> forall a. a -> [a]
08:12:52 <Cheery> > repeat 1
08:12:54 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
08:12:57 <Cheery> gah
08:13:04 <mauke> > concatMap (replicate 2) [0 ..]
08:13:06 <lambdabot>   [0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,1...
08:13:33 <Zao> > [x | x <- [0..], y <- [0,1]]
08:13:35 <lambdabot>   [0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,1...
08:13:36 <stulli> this looks good, thanks
08:13:41 <EvilTerran> > map floor [0, 1%2 ..]
08:13:42 <lambdabot>   [0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,1...
08:14:01 <EvilTerran> (mauke's version's probably the neatest you'll get)
08:14:41 <EvilTerran> > concat [[x,x] | x <- [0..]] -- similar
08:14:42 <lambdabot>   [0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,1...
08:14:44 <mauke> > map (`div` 2) [0 ..]
08:14:45 <lambdabot>   [0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,1...
08:15:01 <mauke> > [x | x <- [0..], [x,x]]
08:15:02 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
08:15:23 <copumpkin> wouldn't the [x,x] be on the left of the | ?
08:15:28 <EvilTerran> mauke, [y | x <- [0..], y <- [x,x]]?
08:15:41 <copumpkin> oh yeah
08:15:43 <mauke> EvilTerran: that's just Zao's solution
08:15:57 <EvilTerran> not quite
08:16:05 <mauke> > do x <- [0..]; [x,x]; [x]
08:16:07 <lambdabot>   [0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,1...
08:16:18 <EvilTerran> > do x <- [0..]; [x,x]
08:16:19 <lambdabot>   [0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,1...
08:16:37 <stulli> ill go with the concatMap version because i didnt know that function
08:18:41 <EvilTerran> > [0..] >>= ((:)<*>return)
08:18:42 <lambdabot>   [0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,1...
08:19:46 * EvilTerran could've completely eliminated letters and spaces by making that [0..]>>=((:)<*>(:[]))  :P
08:20:05 <copumpkin> make it shorter with pure?
08:20:26 <mauke> EvilTerran: now you just need to eliminate the 0
08:20:52 <copumpkin> oh I missed the other one
08:28:38 <mmorrow> copumpkin: hai
08:28:43 <copumpkin> ohai
08:34:40 <brian6> logBase 2 n where n is kind of big is giving Infinity.
08:34:53 <EmielRegis> really
08:35:05 <Elly> define "kind of big"
08:36:06 <copumpkin> > logBase 2 (2^5000 :: Double)
08:36:07 <lambdabot>   Infinity
08:36:29 <brian6> Elly: the one i'm doing is ~20k digits.
08:36:35 <copumpkin> lol
08:36:54 <copumpkin> do you want a real logBase 2 or just an approximate one?
08:37:25 <brian6> approximate might be ok. i just thought it was crazy to get back Infinity.
08:37:36 <copumpkin> well, Double can't hold that much
08:37:49 <copumpkin> you could convert it to a CReal but then you might have to wait until heat death
08:38:18 <brian6> oh, damn. is Double really bounded.
08:38:19 <brian6> ?
08:38:20 <copumpkin> you could get an integer log 2 by dividing repeatedly by 2 until you hit 0 and seeing how many divisions you have
08:38:31 <copumpkin> well, it isn't bounded in the sense of the Bounded typeclass
08:38:41 <copumpkin> but it is a 64-bit value, there's only so much you can cram in :)
08:38:55 <brian6> oh, jeez.
08:41:48 <copumpkin> > logBase 2 (2^5000 :: CReal)
08:41:53 <lambdabot>   mueval-core: Prelude.read: no parse
08:41:54 <lambdabot>  mueval: ExitFailure 1
08:41:59 <copumpkin> > logBase 2 (2^500 :: CReal)
08:42:00 <lambdabot>   500.0
08:42:10 <copumpkin> > logBase 2 (3^500 :: CReal)
08:42:12 <lambdabot>   792.4812503605780907268694719739082543799072
08:42:28 <mauke> what package is CReal in?
08:42:35 <copumpkin> numbers iirc
08:44:53 <burp> @hoogle CReal
08:44:53 <lambdabot> No results found
08:47:35 <copumpkin> dons: you around?
08:54:41 <brian6> copumpkin: ok, thanks. :: CReal is letting me get a reasonable answer, i think. ~81918.
08:54:54 <copumpkin> took quite a while eh? :P
08:55:15 <brian6> copumpkin: took longer for numbers to download and install.
08:55:53 <brian6> dunno. hope haskell quits with wack old school limited numeric types. think that's my biggest error class.
08:56:22 <copumpkin> Double and Float are really fast as they're supported natively by most CPUs, but should probably come with more warnings :)
08:56:32 <noteventime>  Is there some function in the prelude that removes the first element in a list that satisfies some predicate?
08:56:54 <sampointon> @hoogle (a -> Bool) -> [a] -> [a]
08:56:55 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
08:56:55 <lambdabot> Prelude filter :: (a -> Bool) -> [a] -> [a]
08:56:55 <lambdabot> Prelude takeWhile :: (a -> Bool) -> [a] -> [a]
08:56:58 <ClaudiusMaximus> @hoogle deleteBy
08:56:58 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
08:57:15 <noteventime> sampointon: Like filter, but it stops at the first one that satisfies the predicate
08:57:38 <noteventime> ClaudiusMaximus: deleteBy just allows you to use your own equality
08:58:05 <noteventime> I could do it by deleteBy (\_ x -> elem i x)
08:58:13 <noteventime> But that's kinda ugly :)
08:59:22 <BONUS> const (elem i) is equivalent to that
08:59:38 <BONUS> a bit prettier
09:00:38 <sampointon> there's still the bogus element parameter to deleteBy though
09:11:25 <mmorrow> sampointon: that's what `const' is made for though :)
09:12:43 <mamalujo_> hm, documentation seems to be compiling, but one of the missing packages, one it still complaints about is rts-1.0, apparently part of ghc6 install. I installed it from a debian source package, since platform requires one to already have it, and thought it most practical. I did install ghc6-doc however, perhaps I just need to explain haddock where to loock for it? but I dont notice rts mentioned among directories, files of ghc6-doc ...
09:12:49 <mamalujo_> ... package.
09:13:40 <mmorrow> > (\p -> uncurry (++) . fmap (drop 1) . break p) (==4) [0..9]
09:13:42 <lambdabot>   [0,1,2,3,5,6,7,8,9]
09:13:57 <aavogt> does the rts have haddock documentation?
09:14:04 <copumpkin> no
09:14:06 <mmorrow> aavogt: you mean the C code?
09:14:15 <mmorrow> i have sweet doxygen docs for it though :)
09:14:41 <mmorrow> http://moonpatio.com/ghc/rts/html/main.html
09:15:09 <aavogt> mamalujo_: ^^ that's your answer then (I was wondering about this too)
09:15:14 <copumpkin> mmorrow: whoa, there's c++ in the RTS? http://moonpatio.com/ghc/rts/html/namespaceDynInvoke.html
09:15:15 <mmorrow> (this is particularly handy: http://moonpatio.com/ghc/rts/html/classes.html)
09:15:37 <mamalujo_> heh, so what the install is seeking doesnt even exist? I guess I'll just ignore it then
09:15:40 <mmorrow> copumpkin: heh, yeah there's that one straggler file
09:15:57 <copumpkin> that's odd
09:16:08 <mmorrow> aavogt: ahh, i didn't know the context of your question ;)
09:16:22 <mmorrow> mamalujo_: yeah, it doesn't even exist :)
09:17:29 <mmorrow> copumpkin: it looks like it's some file (bitrotted?) for some sort of dotnet bridge
09:18:45 <mmorrow> err actually maybe that's not the c++ one (i can't find it atm)
09:20:01 <mmorrow> ah yeah, it's something to do "C callable bridge to the .NET object model"
09:32:19 <mmorrow> copumpkin: whoa, i've never looked at this file before http://moonpatio.com/ghc/rts/html/Pack_8c_source.html
09:33:34 <mmorrow> the GUM/GrAnSim stuff sounds like it was pretty cool
09:35:02 <copumpkin> ooh
09:35:04 <mmorrow> wow, this code seems like it could be hacked to get heap (de)serialization
09:35:26 <copumpkin> that does seem cool
09:35:27 <mmorrow> i wonder just how bitrotted it is
09:36:15 <mmorrow> eek, "Time-stamp: <Wed Mar 21 2001 16:32:47 Stardate: [-30]6363.44 hwloidl>"
09:39:20 <FunctorSalad_> ancient ruins...
09:43:26 <mmorrow> http://moonpatio.com/ghc/rts/html/SysMan_8c_source.html
09:43:34 <mmorrow> "OK children, buckle down for some serious weirdness, it works like this ..."
09:44:57 <FunctorSalad_> comfortably readable at 300% zoom ;)
09:45:32 <mmorrow> haha, yeah i replaced the original stylesheet's fontsize because it was massive an non-resizable
09:46:03 <mmorrow> but some other css rule is interacting with it or something
09:46:32 <mmorrow> i like the doxygen C highlighting colors
09:48:11 <FunctorSalad_> could be more saturated. I like the "euphoria" color scheme in emacs ;)
09:48:26 <mmorrow> hmm, i'll have to check that one out
09:49:16 <mamalujo_> can I make runhaskell Setup install also automatically build documentation?
09:49:50 <mmorrow> mamalujo_: you can get it to build it, but you have to install it yourself to your desired location
09:50:07 <mmorrow> this makes nice docs:
09:50:10 <mmorrow> ./Setup haddock --hyperlink-source --hoogle --haddock-options=--html
09:50:31 <mmorrow> and gives you a <pkgname>.txt hoogle input file for hoogling
09:51:06 <mmorrow> ($ hoogle --convert=foo.txt) ==> $ hoogle --data=foo.hoo SomeType
09:51:29 <mmorrow> super nice for big pkgs that you know nothing about
09:52:13 <lpsmith> How do you quote the pipe | character in lhs2TeX?
09:52:18 <mamalujo_> good, thx! Ive been trying to keep track of installed files with paco, and its not perfectly practical to make it log two separate commands. I can do && mv ... and it can keep track of that, but doesnt support sudo inside itself, so I think Im going to need to go su before instaling..
09:55:48 <lpsmith> ahh,  || does the trick
09:56:03 <mmorrow> (docs being put in dist/doc/html/<pkgname>)
09:57:31 <gwern> mmorrow: why do you --haddock-options=--html?
09:57:40 <gwern> doesn't it build html by default?
09:59:54 <mmorrow> gwern: probably, just to be safe though ;)
10:00:02 <gwern> -_-
10:00:20 <gwern> what would haddock build without it, one wonders...
10:00:23 <gwern> troff!
10:00:28 <mmorrow> yuhuh!
10:00:37 <mmorrow> heh
10:01:03 <SamB> postscript!
10:01:11 <SamB> or maybe Fuun DNA
10:01:12 <mmorrow> i've been meaning for a while to track down the options cabal passes to haddock to do --hyperlink-source
10:01:26 <dcoutts> mmorrow: -v is your friend
10:01:26 <lambdabot> dcoutts: You have 1 new message. '/msg lambdabot @messages' to read it.
10:01:29 <mmorrow> because it's extremely non-trivial looking
10:01:33 <mmorrow> dcoutts: ooh
10:01:35 <gwern> SamB: don't even mention the dna...
10:01:36 <mmorrow> nice
10:01:42 * roconnor uses DNA to typeset his thesis
10:02:10 <Zao> Speaking of DNA, this is quite amusing: http://www.bunniestudios.com/blog/?p=353
10:02:29 <Zao> The flu virus from a hacker perspective.
10:03:24 <mamalujo_> so, the documentation built with cabal install --enable-documentation doesnt have --hyperlink-source and --hoogle? nor can those be specified in .cabal/config?
10:04:15 <SamB> gwern: okay, well, maybe it's that bytecode-y stuff then ?
10:04:16 <dcoutts> mamalujo_: not yet, there's an open ticket on the issue if you'd like to work on it
10:06:02 <mamalujo_> I see. well I think it will take some time learning this system before i can be of much use to the community :) so its either very pretty or automatical dependency resolved but not both :)
10:09:48 <lpsmith> roconner:  what is DNA?
10:10:05 <lpsmith> talk about a terrible name for a software package
10:10:33 <SamB> lpsmith: see the ICFP Contest, 2006
10:10:54 <FunctorSalad_> * roconnor uses DNA to typeset his thesis
10:10:57 <FunctorSalad_> ...
10:11:01 <SamB> so I'm pretty sure he was making a joke
10:11:18 <lpsmith> ahh
10:11:21 <SamB> ... for one thing, it'd give a really low page size and resolution
10:11:41 <SamB> the RNA only covers, what, a 400x400 output area?
10:12:38 <lpsmith> heh.  I hate TeX, but it does make pretty pictures
10:12:50 <lpsmith> actually it doesn't.   But it sure makes pretty formulas
10:13:11 <lpsmith> Any actual pictures / vector graphics,  you are best off avoiding TeX
10:13:34 <SamB> lpsmith: yeah, it doesn't have floating point instructions ;-)
10:13:48 <Botje> lpsmith++ # fellow tex hater.
10:14:08 <SamB> or vector-drawing operations, either
10:14:37 <SamB> I hate the language too
10:14:50 <FunctorSalad_> ;)
10:15:00 <SamB> but boy can it make lovely-looking text
10:15:27 <FunctorSalad_> why don't IRC clients use tex?
10:15:46 <SamB> because TeX doesn't support this?
10:15:50 <FunctorSalad_> for rendering, not for input ;o
10:15:54 <FunctorSalad_> hmm
10:16:12 <FunctorSalad_> well, you could render to a picture and display that
10:16:21 <SamB> ☂
10:17:04 <Botje> ♥
10:17:21 <FunctorSalad_> I was thinking more of the pretty text, not the symbols
10:17:29 <jmcarthur> edwardk: ping
10:17:33 <gwern> tex being a tc-language, sounds a little dangerous
10:17:43 <gwern> there've been enough irc-related exploits...
10:18:02 <FunctorSalad_> gwern: it wouldn't read tex from the network. just use it as a renderer
10:18:04 <Botje> FunctorSalad_: how else will we impede Haskell's success! we don't want people to just _type in_ our operators, do we?
10:18:20 <FunctorSalad_> :)
10:18:45 <olsner> maybe we could use typed lazily evaluated tex
10:18:54 <lpsmith> what,  like lout?
10:19:01 <lpsmith> lout's a lazy language
10:19:06 <lpsmith> Never used it myself.
10:19:17 <olsner> hah, maybe, I just assumed no-one'd tried that :)
10:19:27 <jmcarthur> dude, tex math expression would be awesome for irc
10:19:45 <jmcarthur> for channels like this, anyway
10:20:34 <yowgi> gaim has had TeX rendering for a while, through a plugin afaik
10:20:40 <aavogt> don't some clients have plugins that render tex between $$\textrm{these?}$$?
10:20:51 <monochrom> They have been saying that for 20 years. They will continue to say that for another 20 years. You know why? Because unicode is here-and-now, while "tex on irc" is vapourware.
10:20:52 <jmcarthur> yowgi: interesting!
10:21:05 <yowgi> and by gaim I mean pidgin :)
10:21:21 <lpsmith> olsner:  there isn't that many languages that I haven't heard of.   You have to get really, truly obscure for that.  ;-)
10:21:32 <aavogt> kopete too
10:21:44 <FunctorSalad_> monochrom: but it's prettier for ascii too ;)
10:22:07 <monochrom> Vapourware. Mark my words and watch 20 more years.
10:22:16 <lpsmith> Actually, if lout offered good PDF generation capabilities,  I'd give it a serious go.
10:23:38 <Botje> my crutch of choice has been docbook
10:24:38 <mmorrow> lpsmith: yeah, tex is one of those horrendously ugly things that make amazingly pretty things
10:24:54 <mmorrow> i especially love trying to tweak alignment
10:25:06 <FunctorSalad_> *awaits witty analogy*
10:25:14 <osfameron> is tex hard-to-debug like latex?
10:25:21 <monochrom> Yes.
10:25:25 <osfameron> gah
10:25:28 <mmorrow> err, i meant latex too
10:25:46 <lpsmith> heh, speaking of debugging TeX, for some reason my paper stopped rendering with an obscure message, and I have no idea what I did
10:25:48 <osfameron> life is too short to debug /documents/ ;-)
10:25:51 <monochrom> It is a write-only language. Not much better than Perl.
10:26:08 <unC0Rr> Hello! I have a question... I got a problem, probably due to lazyness of the language. I have a thread: timerLoop tick messagesChan = threadDelay (30 * 10^6) >> writeChan messagesChan $ TimerAction tick >> timerLoop (tick + 1) messagesChan, and it seems to fail to send anything sometimes for minutes or even hours
10:26:10 <osfameron> perl is far easier to debug tho
10:26:20 <monochrom> OK. Much worse than Perl!
10:26:33 <osfameron> heh
10:26:34 <unC0Rr> So, the question is: is it lazyness? and what should I do to solve the issue?
10:26:41 <lpsmith> Actually,  my opinion is,  it's never been easier to produce a solid replacement for TeX.   All you have to do is generate PDF,  which is relatively easy.
10:26:46 <skorpan> debugging latex is like debugging c++ templates
10:26:48 <monochrom> The saving grace for TeX is that people precisely use it for write-only purpose, so there is no complaint.
10:27:12 <lpsmith> HPDF is not a bad start,  but it's not documented,  and there are a few things I don't like about it
10:27:43 <lpsmith> maybe reimplement lout using HPDF,  offer a way to escape out and use HPDF directly,  sort of like pstricks
10:28:20 <FunctorSalad_> unC0Rr: ($) binds more weakly than even (>>), is that what you intended?
10:28:45 <skorpan> what's HPDF?
10:29:15 <unC0Rr> well, there should be brackets, just rewrote it from do notation
10:29:45 <unC0Rr> messagesChan = threadDelay (30 * 10^6) >> (writeChan messagesChan $ TimerAction tick) >> timerLoop (tick + 1)
10:30:14 <unC0Rr> timerLoop tick messagesChan = threadDelay (30 * 10^6) >> (writeChan messagesChan $ TimerAction tick) >> timerLoop (tick + 1) messagesChan
10:31:02 <jmcarthur> that being an IO expression, i can't imagine that laziness would have anything to do with it not sending things regularly
10:31:39 <unC0Rr> okay, what are the other possible reasons then?
10:31:45 <FunctorSalad_> I was trying to say something like that, but not sure if "a chain of IO actions is evaluated eagerly" is the right way to say it
10:31:47 <jmcarthur> have you tried printing debug messages as you send from that end and receive from the other end?
10:32:38 <unC0Rr> no, I didn't try that... it's hard to debug, because it work okay, but then just stops to work with no obvious reason
10:32:41 <FunctorSalad_> unC0Rr: I'm not sure whether you need it here, but maybe compile with -threaded
10:32:47 <jmcarthur> are Chans bounded?
10:32:52 <jmcarthur> i'm not sure
10:32:58 <FunctorSalad_> I think not jmcarthur
10:33:02 <unC0Rr> when the message is recieved, I should get msg via tcp socket
10:33:46 <jmcarthur> are you using any dodgy FFI anywhere?
10:33:46 <unC0Rr> there are many other messages passing through the same channel, and they work well
10:33:52 <unC0Rr> nope
10:34:38 <jmcarthur> oh that's interesting. other senders are having no problem?
10:34:43 <unC0Rr> yes
10:34:50 <jmcarthur> are they sending messages very very fast?
10:34:59 <jmcarthur> err
10:35:00 <unC0Rr> nope
10:35:01 <jmcarthur> frequently?
10:35:02 <jmcarthur> ah
10:35:27 <unC0Rr> well, I guess... or server wouldn't respond
10:35:46 <Zao> unC0Rr: Tried sniffing with Wireshark or similiar tools?
10:36:18 <unC0Rr> nope, I just connect with netcat to test
10:36:54 <jmcarthur> is it possible that runaway (infinite loop bug) threads are flooding the channel or something? or maybe something is stealing your tick messages from the thread you expect to read them?
10:37:33 <jmcarthur> beyond those, i'm completely out of ideas
10:37:53 <kacper_> if i run ghc --make 'path' i received two files .hi and .o Where is exe?
10:37:54 <unC0Rr> I have only one recieving routine, and all other things work okay, protocol isn't violated anywhere
10:38:01 <jmcarthur> weird
10:38:05 <kacper_> or sth like that
10:38:42 <Botje> kacper_: it should be there
10:38:46 <unC0Rr> if the channel was flooded, server would stop responding or smth like that, but it works, and doesn't consume much CPU time
10:39:01 <Botje> or it gets saved under path, that's also an option
10:40:34 <unC0Rr> the problem is that I'm not able to reproduce problem locally, only on quite busy server after some time
10:43:24 <gwern> @seen newsham
10:43:25 <lambdabot> newsham is in #haskell. I last heard newsham speak 2d 23h 15m 16s ago.
10:43:37 <gwern> @tell newsham sp 'Logical disjunction corresponds to Haskell types which can contain a constiuent value of one type or of another type. The prototypical example is the "Either a b" data type.' http://www.thenewsh.com/~newsham/formal/curryhoward/
10:43:38 <lambdabot> Consider it noted.
10:44:21 <unC0Rr> probably it sometimes floods channel with ticks, haven't seen that, but users report ping timeouts sometimes, which suggests such behaviour of this routine
10:50:08 <lpsmith> skorpan: http://hackage.haskell.org/package/HPDF
10:50:40 <skorpan> dude no way
10:50:45 <skorpan> duuuudo
10:50:57 <lpsmith> lol, what?
10:51:39 <gwern> waasssuuupppp duuuudddesss
10:52:58 <RayNbow> what about (if any?) dudettes in this channel?
10:53:04 <Zao> Phew. I've now reached April in my haskell-cafe reading.
10:53:09 <Zao> Just a few months left now.
10:54:05 <skorpan> in english, can you pronounce "mature" as "mah-tour"?
10:54:21 <mike-burns> Sure.
10:57:18 <newsham> gwern: hi
10:57:19 <lambdabot> newsham: You have 1 new message. '/msg lambdabot @messages' to read it.
10:57:33 <Beelsebob> skorpan: you can, but you might well get punched for it
10:57:56 <Beelsebob> actually... in fact, it's just plain wrong
10:58:02 <Beelsebob> it has the wrong sylables in it
10:58:08 <aavogt> unC0Rr: one of those modules has a main, right?
10:58:11 <Beelsebob> mature is mat-ure
10:58:35 <mike-burns> If someone pronounced "mature" as "mah-tour", in context, I'd understand what they meant.
10:59:03 <unC0Rr> aavogt: what do you mean? it's network server, written only in haskell, no Chan interaction in main
10:59:04 <Beelsebob> agreed, doesn't make it in any way english though...
10:59:09 <Beelsebob> might pass for southern american
10:59:35 <Beelsebob> I'd also have a tough time telling if they were trying to say mature or marter
10:59:43 <newsham> gwern: "constiuent" -> "constituent" ?
11:00:04 <aavogt> kacper_: one of those modules has a main, right? (sorry unC0Rr)
11:00:11 <unC0Rr> :D
11:00:24 <jimmyjazz14> why does: liftM (take 4) (hGetContents hd) : close my the handle "hd" using ghci?
11:01:52 <Saizan_> because of hGetContents
11:02:30 <jimmyjazz14> hmm so hGetContents reads and closes the handle?
11:03:23 <steveklabnik> > :t (<*)
11:03:25 <lambdabot>   <no location info>: parse error on input `:'
11:03:31 <Saizan_> it half-closes it at the start,i.e. it'll look as closed from haskell, but it'll really close it only at the end
11:03:41 <steveklabnik> :t (<*)
11:03:43 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
11:04:17 <Saizan_> jimmyjazz14: http://haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html#v%3AhGetContents
11:05:45 <gwern> newsham: indeed
11:10:42 <newsham> fixed, danke.
11:34:04 <Leftblank> Could someone perhaps help me figure out why this would return "ero"; head [tail] "zero"?
11:34:12 <Leftblank> it's like the head is being ignored
11:34:23 <Leftblank> nvm
11:34:32 <Leftblank> head works on the function list, doh
11:35:00 <ziman> yeah, it's left-associative
11:35:15 <ziman> head [tail] "zero" = (head [tail]) "zero"
11:35:33 <Leftblank> hmhm, took a little for the link to be made
11:35:41 <Leftblank> pretty logical actually
11:36:07 <ziman> especially when all your functions are curried ;)
11:49:19 <foobar> Is there a way to call functions from the STL (as an example) in Haskell polymorphically?
11:49:36 <Cynner> New web browser based game, intresting peoples, good admins and lot of fun, enjoy - http://www.lostworlds.lv/go.php?1139730844
11:49:47 <Lemmih> foobar: What's the STL?
11:50:19 <trofi_> standard template library?
11:50:24 <foobar> Lemmih:  C++ Standard Template Library
11:50:33 <copumpkin> ##c++ doesn't like that name
11:50:36 <trofi_> :t head
11:50:37 <lambdabot> forall a. [a] -> a
11:50:59 <trofi_> > head [1,2,3]
11:51:00 <lambdabot>   1
11:51:07 <trofi_> > head ["hello", "world"]
11:51:09 <lambdabot>   "hello"
11:51:11 <skorpan> @karma c
11:51:11 <lambdabot> c has a karma of 1
11:51:25 <Lemmih> foobar: Probably. Using phantom types.
11:51:52 <Lemmih> foobar: Kinda like 'Ptr'.
11:52:07 <foobar> I am mostly interested in the general way to call C++ templated code from Haskell. All of the code I have seen until now, uses extern C declarations only to call e.g. vector<int>, but not vector<T> functions.
11:52:08 <mmorrow> foobar: do you mean the actual mechanical process of ffi-interfacing to C++ code?
11:52:33 <gwern> @seen dcoutts
11:52:33 <lambdabot> dcoutts is in #haskell-soc, #haskell-in-depth, #gentoo-haskell, #darcs, #ghc, #haskell-overflow and #haskell. I last heard dcoutts speak 1h 46m 33s ago.
11:52:36 <gwern> @seen dcoutts_
11:52:38 <lambdabot> dcoutts_ is in #haskell-in-depth, #gentoo-haskell, #ghc and #haskell-overflow. I last heard dcoutts_ speak 2d 5h 20m 5s ago.
11:52:49 <foobar> AFAIK, it is not mechanical yet, although it can be done in general.
11:52:56 <mmorrow> yeah, i don't know much about what you'd need to do to ffi to C++, but from what i understand it's not easy (but how hard i don't know)
11:53:00 <Lemmih> foobar: You can't call C++ code directly. You must go through a C interface.
11:53:10 <mauke> foobar: there are no vector<T> functions
11:53:15 <mauke> it's just a template
11:53:17 <trofi_> @google verrazano
11:53:18 <lambdabot> http://en.wikipedia.org/wiki/Giovanni_da_Verrazzano
11:53:18 <lambdabot> Title: Giovanni da Verrazzano - Wikipedia, the free encyclopedia
11:53:24 <foobar> Lemmih: right, with extern c.
11:53:35 <trofi_> @google verrazano gccxml C++ ABI
11:53:36 <mmorrow> foobar: well, mechanical := the "nuts and bolts" of it, rather than trying to fit it in with haskell's type system
11:53:41 <lambdabot> http://common-lisp.net/project/fetter/docs/design.pdf
11:53:41 <lambdabot> Title: Verrazano Design Specification
11:53:43 <gwern> @ask dcoutts did the 'MIT' license only get added to cabal after the last version cabal-install uses? because using it gets me a warning with cabal-install but not runhaskell, and I'm wondering if I can upload that to hackage
11:53:45 <lambdabot> Consider it noted.
11:53:53 <foobar> But then you lose the templated type information.
11:54:27 <mauke> you can't call macros either
11:54:31 <mmorrow> foobar: and therein lies the difficulty i guess... you'd need to figure out a way to extend the ffi of ghc to do this
11:54:45 <foobar> All these type-systems seem to create a modern tower of Babel.
11:55:12 <int-e> gwern: you can upload MIT licensed packages.
11:55:17 <mmorrow> foobar: isn't that done by inspecting the mangled symbols or something?
11:55:23 <mmorrow> foobar: (at runtime)
11:55:28 <mmorrow> iirc
11:56:01 <mmorrow> as in, it needs some sort of runtime support on the C++ end?
11:56:15 <qwrgw> Hi! Could anyone recommend a LaTeX package for source code typesetting? Specifically, I need to deal with ML-style stuff. I'd like to use a sans-serif font, but with correct indentation.
11:56:41 <trofi_> it's hard to use C++ templates(as a standalone binary library) even from C++
11:56:45 <mmorrow> qwrgw: there's lhs2tex and pandoc
11:57:45 <jimmyjazz14> is there a way to do the equivlent of import qualified in ghci?
11:57:53 <foobar_> It seems I got disconnected.
11:58:23 <foobar_> Please repeat whatever you said.
11:58:31 <mmorrow> foobar_: exactly what runtime support does accessing/whatever the templated type info need on the C++ end?
11:58:33 <gwern> jimmyjazz14: no, not really
11:58:34 <shapr> RyanT5000: You're in Boston?
11:59:11 <foobar_> mmorrow:
11:59:17 <foobar_> mmorrow:
11:59:46 <mmorrow> foobar_: it seems like being able to do this from haskell is a matter of "providing" that runtime support somehow
12:00:07 <RyanT5000> shapr: yes, i am
12:00:23 <mike-burns> Oh hey, I'm in Boston too.
12:00:25 <foobar__> mmorrow: what do you mean?
12:00:37 <RyanT5000> cool; there's a meetup at MIT on the 23, right?
12:00:43 <mike-burns> Yup.
12:01:09 <mmorrow> foobar__: so what does C++ do to access this type info? iirc it has something to do with inspecting mangled symbols, since C++ stores type info in them. so does support need to be in the linker?
12:01:27 <olsner> foobar_: taking vector<T> and instantiating it for arbitrary types T (if that's what you're trying to do...) requires a full C++ compiler -  Haskell doesn't come with one :)
12:01:35 <mmorrow> foobar__: if so, then you'd probably need to hack ghc's runtime linker to get what you want
12:02:12 <mauke> mmorrow: this is the equivalent of using TH through the FFI
12:02:28 <dcoutts> gwern: using "license: MIT" requires "cabal-version: >=1.4"
12:02:28 <lambdabot> dcoutts: You have 1 new message. '/msg lambdabot @messages' to read it.
12:02:28 <mauke> you'd have to run the meta-code, generate the code, compile it, then link to it
12:02:41 <mmorrow> mauke: heh, ok this sounds like you'd need to augment ghc's rts with g++ then..
12:02:51 <dcoutts> gwern: and cabal upload --check will tell you that if you violate it
12:02:53 <mmorrow> (and extend the rts's linker)
12:03:11 <mmorrow> (and add an assembler to ghc too :)
12:03:18 <gwern> dcoutts: 'k. incidentally, why are cabal install and runhaskell using different cabal versions?
12:03:43 <erikc> olsner: actually, haskell does come with a full c++ compiler :P
12:03:43 <dcoutts> gwern: check cabal --version vs ghc-pkg list Cabal
12:04:05 <gwern> dcoutts: no, I mean '                   Cabal >= 1.6 && < 1.7,
12:04:10 <olsner> erikc: eh, really?
12:04:24 <erikc> it assumes g++, and comes packaged with it on windows
12:04:32 <ziman> foobar__, nope, templating is done by the compiler and the code is specialized when compiling; the binary code always handles a concrete type
12:04:35 <dcoutts> gwern: I've no idea what you mean
12:05:16 <erikc> you'd need to have ghc produce a c++ file that instantiates the desired template, invoke the c++ compiler to produce a .o, and figure out the mangled name for the call
12:05:37 <mmorrow> oh nice, so then ghc's linker wouldn't need modifying (?)
12:05:43 <erikc> nope
12:05:57 <foobar__> ziman: what do you mean nope? I didn't say how any part worked.
12:06:10 <Zao> erikc: Would that take into account specialized templates?
12:06:12 <erikc> there'd be the usual c++ interop limitations, e.g. never ever throw exceptions across dll boundaries
12:06:16 <mmorrow> so then it'd just be a matter of adding to ghc the ability to generate C++ files which "instantiate templates"
12:06:37 <Zao> erikc: There's nothing wrong with throwing over boundaries, provided you have the same dynamic runtime.
12:06:43 <erikc> right
12:06:46 <Zao> erikc: And exported exception types if you have those.
12:07:07 <int-e> dcoutts, gwern: Cabal 1.6.0.3 does not recognize the MIT license (Warning: 'license: MIT' is not a recognised license.) - Cabal head does. Hackage seems to use a relatively recent head version.
12:08:02 <erikc> it'd work fine with specialized templates
12:08:19 <gwern> dcoutts: ok, I see that in darcs cabal-install the dep has been bumped upwards
12:08:20 <dcoutts> int-e: yes, 1.6 does not recognise it but it does not fall over
12:08:32 <gwern> obviously my automated darcs pull script fails because of the bloody zlib thing
12:08:48 <dcoutts> int-e: which is why the minimum is 1.4 not 1.7
12:09:07 <erikc> mmorrow: yea, that and name mangling, and a way of representing templates in the ghc ffi
12:09:18 <foobar__> dcoutts: http_proxy='' cabal update doesn't work
12:09:48 <ziman> foobar__, i was answering to the question whether templated c++ code can be called from outside without having it specialized to concrete types by a c++ compiler
12:09:58 <dcoutts> foobar__: '' isn't the same as not being set
12:10:00 <dcoutts> foobar__: so do you think it's wrong?
12:10:08 <ziman> but i figure i'm way offtopic on #haskell ;)
12:10:16 <foobar__> dcoutts: many applications interpret '' as unset.
12:10:28 <foobar__> dcoutts: as a result, many users expect that too.
12:10:33 <dcoutts> foobar__: sounds wrong to me
12:10:55 <dcoutts> foobar__: feel free to file a ticket
12:12:37 <foobar__> ziman: to call any code, it must have been specialized, yes. But one would ideally want to be able to drive the compilation of the instances required from Haskell, without manually making all the bindings.
12:14:03 <mauke> hah, good luck
12:14:08 <mauke> not even C++ lets you do that
12:16:34 <olsner> pushBackChar = unsafePerformIO (compileAndImport "vector<char>::push_back")
12:22:04 <gwern> whew. got most of the hlist examples running
12:22:04 <foobar> olsner: that's pseudo-code for something that doesn't exist, right?
12:22:39 <olsner> foobar: yeah
12:25:04 <iop> anyone do haskore?
12:25:09 <iop> my music plays way to slow
12:25:28 <nibro> @src fix
12:25:28 <lambdabot> fix f = let x = f x in x
12:29:35 <hackagebot> HList 0.1.1 - Heterogeneous lists (GwernBranwen)
12:29:47 <iop> @src nibro
12:29:47 <lambdabot> Source not found. Do you think like you type?
12:30:25 <ritek> does anyone knows a good tutorial/e-book about genetic and ai algorithms??
12:31:08 <ritek> i would like to use them in haskell
12:31:49 <foobar> ritek: Haskell is too slow for the implementation of genetic algorithms. If you want to toy around, then Haskell can work, however.
12:33:02 <iop> foobar: only C works?
12:33:19 <opera> what
12:34:15 <foobar> iop: or C++ or maybe OCaml.
12:34:34 <jmcarthur> conal: besides not needing an Applicative constraint, is there any difference between Monoid_f and Alternative?
12:35:02 <jmcarthur> the paper linked to makes no mention of Alternative or MonadPlus
12:36:36 <conal> jmcarthur: i think that paper predated Applicative.  offhand, the only difference i know of is whether or not one needs Alternative/MonadPlus
12:38:48 <jmcarthur> conal: okay thanks
12:39:46 <jmcarthur> i'm looking over reactive to see what does and does not match up with the model i'm trying out
12:42:06 <foobar> Is there anywhere specified what reactive is supposed to do? I.e. what problem it tries to solve?
12:43:04 <erikc> it tries the performance problems of previous functional reactive programming approaches
12:43:09 <erikc> tries to solve
12:43:32 <foobar> But FRP itself is not defined as a problem.
12:43:45 <foobar> There are a few papers, but they all solve slightly different problems.
12:43:45 <sampointon> @pl \ a -> foldr ($) (return a) . map (=<<)
12:43:46 <lambdabot> (. map (=<<)) . foldr id . return
12:43:56 <foobar> There is not one language what makes up FRP.
12:44:07 <dumael> ritek: http://www.gp-field-guide.org.uk/ there's a ebook there on genetic programming afaik. No idea how good it is though.
12:44:12 <foobar> By language, I mean a bunch of primitives with associated semantics.
12:44:51 <sampointon> @pl \ a -> foldr ($) a . map (=<<)
12:44:52 <lambdabot> (. map (=<<)) . foldr id
12:49:14 <iop> anyone good with haskor
12:49:15 <iop> Haskore.Basic.Duration.T
12:49:21 <iop> how do I write that?
12:49:27 <iop> en = 1 % 8
12:49:33 <iop> but that doesnt seem to work if i do
12:49:35 <iop> 1 % 64
12:50:31 <ritek> dumael, thanks :P
12:50:43 <sampointon> @djinn m a -> [a -> m a] -> m a
12:50:44 <lambdabot> Error: Undefined type []
12:50:52 <byorgey> iop: Duration.T is the same as Dur, which is the same as Rational
12:51:01 <byorgey> iop: so 1%8 and 1%64 ought to both work.
12:51:15 <dumael> ritek: np.
12:51:19 <byorgey> iop: I suspect perhaps it has to do with the context in which you're trying to use 1%64, could you give more detail?
12:51:19 <sampointon> djinn doesn't like lists?
12:51:26 <iop> ah
12:51:30 <iop> en / 4 works
12:51:38 <byorgey> sampointon: well, it doesn't know about them.
12:51:42 <byorgey> iop: ah, yes, that should work.
12:51:59 <byorgey> iop: % is only for *constructing* Rationals out of two Integers
12:52:01 <sampointon> byorgey: did it used to? http://www.haskell.org/pipermail/haskell/2005-December/017056.html has some examples with them
12:52:12 <byorgey> iop: in general you can just use / for everything and it should Just Work.
12:52:28 <jmcarthur> well, foobar left, but just to say to whoever is listening... my best definition of frp is an attempt to do away with imperative manipulation of state, replacing it with more declarative code... for some definition of "declarative"
12:52:29 <byorgey> sampointon: oh, I have no idea.  I didn't even know Haskell existed in 2005.
12:52:50 * Taejo_ is looking forward to another perl-and-c++-filled ICFP contest
12:53:06 <byorgey> infidel!
12:54:04 <Taejo_> haha, when one has a 6-time IOI medallist on ones programming team, one uses the languages they use
12:54:17 <byorgey> heh, I guess so =)
12:54:37 <roconnor> @karma @hoogle
12:54:38 <lambdabot>  @hoogle has a karma of 0
12:55:01 <Heffalump> how successful has this individual been at the ICFP contest, though? :-)
12:55:23 <Taejo_> Heffalump: we were the second team in 2007
12:56:14 <roconnor> Are we talking about Derek?
12:56:35 <Taejo_> roconnor: Bruce Merry
12:56:57 <Taejo_> who is Derek?
12:56:58 <roconnor> ah
12:57:04 <roconnor> IOI not IMO
12:57:09 <Taejo_> yes
12:58:23 <FliP^2eH> > map (&&) [True, False, False, False]
12:58:24 <roconnor> Derek Kisman
12:58:25 <lambdabot>   Overlapping instances for GHC.Show.Show
12:58:25 <lambdabot>                              (GHC.B...
12:58:36 <FliP^2eH> > map (and) [True, False, False, False]
12:58:37 <lambdabot>   Couldn't match expected type `[GHC.Bool.Bool]'
12:58:38 <FliP^2eH> :s
12:58:49 <roconnor> Taejo_: he's been on Google's winning team for the last however many years.
12:59:02 <FliP^2eH> Oh
12:59:06 <ziman> you probably want some kind of fold
12:59:12 <FliP^2eH> > foldl (&&) [True, False, False, False]
12:59:12 <Taejo_> roconnor: nah, they beat us in 2007.
12:59:13 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
12:59:17 <FliP^2eH> Stupid me
12:59:31 <Taejo_> > and [True, False, False, False]
12:59:32 <FliP^2eH> > foldl (&&) True [True, False, False, False]
12:59:33 <lambdabot>   False
12:59:34 <lambdabot>   False
12:59:46 <FliP^2eH> Taejo_ wins
12:59:47 <iop> > foldr1 (&&) [False,True]
12:59:48 <roconnor> Taejo_: they will always win.
12:59:49 <lambdabot>   False
12:59:57 <iop> > foldr1 (&&) [True,True]
12:59:58 <lambdabot>   True
13:00:08 <iop> @type and
13:00:09 <lambdabot> [Bool] -> Bool
13:00:11 <mike-burns> :src and
13:00:13 <roconnor> Derek doesn't lose at anything, and he has team up with other such superheros
13:00:15 <iop> @type (&&)
13:00:16 <lambdabot> Bool -> Bool -> Bool
13:00:20 <mike-burns> @src and
13:00:20 <iop> @src and
13:00:20 <lambdabot> and   =  foldr (&&) True
13:00:20 <lambdabot> and   =  foldr (&&) True
13:00:57 <Taejo_> roconnor: we consider Bruce a superhero, but his sidekick is not competing this year
13:01:10 <roconnor> http://www.the-elite.net/thehall/snap.htm
13:03:21 <jimmyjazz14> is there way to determine the type of a variable (as in print it to the screen) from within normal code? (specifically in ghci)
13:03:36 <roconnor> jimmyjazz14: at run time?
13:03:48 <jimmyjazz14> yeah, in ghci
13:04:07 <roconnor> jimmyjazz14: so you don't mean just :t foo
13:04:15 <iop> does haskore have volume at all or that is external?
13:04:18 <roconnor> jimmyjazz14: there is proably something in Data.Typeable
13:04:20 <jimmyjazz14> like say I had: [1..10] >>= \x -> :t x
13:04:47 <roconnor> > typeOf 1
13:04:49 <lambdabot>   Integer
13:04:51 <byorgey> jimmyjazz14: if it's an instance of Typeable, you can use typeOf
13:04:59 <byorgey> from Data.Typeable
13:04:59 <roconnor> > map typeOf [1..10]
13:05:00 <lambdabot>   [Integer,Integer,Integer,Integer,Integer,Integer,Integer,Integer,Integer,In...
13:05:04 <jimmyjazz14> hmm okay
13:05:11 <jimmyjazz14> thanks!
13:05:50 <iop> what is octave in music?
13:06:09 <roconnor> @wn octave
13:06:12 <lambdabot> *** "octave" wn "WordNet (r) 2.0"
13:06:12 <lambdabot> octave
13:06:12 <lambdabot>      n 1: a feast day and the seven days following it
13:06:12 <lambdabot>      2: a musical interval of eight tones [syn: {musical octave}]
13:06:12 <lambdabot>      3: a rhythmic group of eight lines of verse
13:06:12 <jimmyjazz14> the range of 16 notes
13:06:13 <byorgey> iop: it's an interval where the pitches are in a ratio of 2:1
13:06:18 <Beelsebob> lop: rather off topic, but an octave is a period in which the frequency of the sound doubles
13:06:30 <byorgey> iop: twelve semitones.
13:06:34 <roconnor> @wn musical octave
13:06:35 <lambdabot> *** "musical" wn "WordNet (r) 2.0"
13:06:35 <lambdabot> musical
13:06:35 <lambdabot>      adj 1: characterized by or capable of producing music; "a musical
13:06:35 <lambdabot>             evening"; "musical instruments"
13:06:35 <lambdabot>      2: talented in or devoted to music; "comes from a very musical
13:06:37 <lambdabot> [15 @more lines]
13:06:41 <roconnor> @wn {musical octave}
13:06:42 <lambdabot> *** "musical" wn "WordNet (r) 2.0"
13:06:42 <lambdabot> musical
13:06:43 * sampointon always thought of it as the distance between congruent keys on a piano
13:06:43 <lambdabot>      adj 1: characterized by or capable of producing music; "a musical
13:06:45 <lambdabot>             evening"; "musical instruments"
13:06:47 <roconnor> bah
13:06:47 <lambdabot>      2: talented in or devoted to music; "comes from a very musical
13:06:49 <lambdabot> [15 @more lines]
13:06:54 <byorgey> sampointon: it's that too =)
13:07:13 <iop> @wn iop
13:07:13 <jimmyjazz14> [a,a#,b,c,c#,d,d#,e,e#,f,f#] umm I think
13:07:13 <lambdabot> No match for "iop".
13:07:22 <iop> does haskore have volume at all or that is external?
13:07:44 <byorgey> jimmyjazz14: e# and f are the same, and you left out g and g#
13:07:55 <jimmyjazz14> man its been a while since I've thought about music, uhhg
13:07:59 <byorgey> =)
13:08:11 <mike-burns> Funny for a guy with 'jazz' in his nick.
13:08:24 <jimmyjazz14> hey its a punk rock reference
13:08:36 <jimmyjazz14> I only know g c d
13:08:41 <mike-burns> Hah.
13:08:42 <jimmyjazz14> in that order
13:09:38 <byorgey> iop: well, the 'Event' data type in Haskore.Performance has a field for eventDynamics
13:10:10 <byorgey> but I'm not that familiar with Haskore (yet)
13:12:03 <jmcarthur> conal: I get that when occs e == [], extract e is _|_, but how does extract fit into the semantic model for Behavior? It seems to be only because of the implementation that extract is even possible, not because of the semantics. Is adding such extra functionality in pace with your type class morphisms philosophy?
13:12:48 <gwern> @quote bruijn
13:12:49 <lambdabot> Botje says: <Cheery> oh man. de bruijn again kicked me to groin  <Botje> the easy fix is to label your groin as (-1) :)
13:12:56 <jmcarthur> not trying to call you out, just picking your brain a bit more
13:12:56 <gwern> @quote shootout
13:12:57 <lambdabot> MyCatVerbs says: The *real* best way to optimize a program is to tell dons that it's been added to the Shootout.
13:13:07 <gwern> @quote shootout
13:13:08 <lambdabot> MyCatVerbs says: The *real* best way to optimize a program is to tell dons that it's been added to the Shootout.
13:13:09 <gwern> @quote shootout
13:13:10 <lambdabot> MyCatVerbs says: The *real* best way to optimize a program is to tell dons that it's been added to the Shootout.
13:13:23 <gwern> @quote Pseudonym
13:13:23 <lambdabot> Pseudonym says: Or did you put in a call to unsafePierceEyeball?
13:13:25 <gwern> @quote Pseudonym
13:13:26 <lambdabot> Pseudonym says: the halting problem is [solved] in GHC HEAD
13:13:28 <gwern> @quote Pseudonym
13:13:29 <lambdabot> Pseudonym says: "Run GHC", by the way, is a lesser-known 80s kip hop group.
13:13:39 <gwern> @quote Pseudonym
13:13:40 <lambdabot> Pseudonym says: Well, personally, I don't think dumb people should be let near a programming language.
13:13:43 <opqdonut> gwern: please
13:13:48 <hackagebot> synthesizer-core 0.2 - Audio signal processing coded in Haskell: Low level part (HenningThielemann)
13:13:51 <gwern> @quote dons.*oleg
13:13:52 <lambdabot> No quotes match. The more you drive -- the dumber you get.
13:13:53 <jmcarthur>  /msg is your friend
13:14:05 <gwern> @remember Pseudonym Telling dons that something has been added to the shootout is the new telling Oleg that it can't be done in the type system.
13:14:05 <lambdabot> I will remember.
13:14:08 <gwern> @flush
13:14:23 <opqdonut> :)
13:14:28 <jmcarthur> haha
13:15:09 <conal> jmcarthur: what's extract?  (lost context)
13:15:19 <jmcarthur> Copointed
13:15:22 <jmcarthur> requisite for Comonad
13:15:29 <opqdonut> extract :: w a -> a
13:15:33 <jmcarthur> right
13:15:35 <conal> oh, thx.
13:15:36 <opqdonut> aka coreturn
13:15:53 <conal> "coreturn" i can remember
13:16:00 <conal> jmcarthur: looking ...
13:16:03 <sampointon> not nruter?
13:17:11 <conal> jmcarthur: i'm confused about the question.  are you asking about Event or Behavior?  or some combination?
13:17:44 <jmcarthur> Behavior
13:17:49 <hackagebot> synthesizer-dimensional 0.2 - Audio signal processing with static physical dimensions (HenningThielemann)
13:17:49 <jmcarthur> extract :: Behavior a -> a
13:18:02 <jmcarthur> doesn't seem like it would fit with (t -> a) -> a
13:18:17 <conal> oh.  if not, it's a semantic design bug.
13:18:42 <conal> jmcarthur: in the sense you mentioned (TCM failure)
13:18:45 <jmcarthur> it seems to rely on what the "current" value of the Behavior is, but that isn't in the type for extract
13:18:48 <mmorrow> mauke: ping
13:19:21 <jmcarthur> conal: okay. i was thinking it was either that or maybe a TCM "slight of hand" that was decent practice
13:20:03 <jmcarthur> which i wasn't aware of ;)
13:20:48 <conal> jmcarthur: i haven't looked at this bit in a while.  right now, i'm not seeing the semantic mismatch.  do you see one?
13:21:15 <jmcarthur> conal: oh, have you switched to relative time now?
13:21:22 <conal> jmcarthur: no, not yet.
13:21:37 <jmcarthur> ah i saw some notes about it in the comments
13:21:50 <hackagebot> synthesizer-inference 0.2 - Audio signal processing with dynamic physical dimensions (HenningThielemann)
13:21:51 <Philonous> Why is it preferrable to use f . g $ x rather than f $ g $ x ?
13:22:25 <conal> jmcarthur: probably so.  i remember realizing that relative time fits more nicely with a comonadic design.  and eliminates the oddness with the Event Applicative I mention in the paper.
13:22:34 <Taejo_> Philonous: because the former focusses on the functions, the latter on the values
13:22:39 <conal> "dynamic physical dimensions"?
13:22:43 <conal> sounds cool
13:23:04 <jmcarthur> conal: actually, i can think of (behavior `at` minBound) or (behavior `at` 0), i guess
13:23:21 <jmcarthur> @hackage synthesizer-inference
13:23:22 <Taejo_> Philonous: at least, that's my opinion
13:23:22 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/synthesizer-inference
13:23:22 <RayNbow> @quote RayNbow
13:23:23 <lambdabot> No quotes match. Wrong!  You cheating scum!
13:23:27 <FliP^2eH> My lines keep growing in length, man
13:23:29 <FliP^2eH> check s = map (\x -> if x `elem` glyphs then case x `elemIndex` glyphs of Just n -> if (n+1) > base then False else True; Nothing -> False; else False) s
13:23:29 <conal> jmcarthur: yeah.  different monoids.
13:23:31 <FliP^2eH> :)
13:23:36 <jmcarthur> ah mempty, yeah
13:23:43 <RayNbow> wait... lambdabot forgot my out-of-context quote? :p
13:24:15 <jmcarthur> conal: okay, so extract :: (t -> a) -> a isn't right, but that isn't really the model. the model is extract :: Monoid t => (t -> a) -> a
13:24:16 <conal> jmcarthur: a while back it hit me that the difference between global and relative time is exactly the choice of Max vs Sum monoids.
13:24:20 <conal> jmcarthur: which is pretty neat!
13:24:22 <jmcarthur> i didn't catch that i guess
13:24:27 <jmcarthur> conal: awesome!
13:25:10 <jmcarthur> makes me wonder what other monoids would result in
13:25:16 <jmcarthur> like Min
13:25:26 <conal> jmcarthur: hey, yeah.  could be a fun exploration!
13:25:34 <Heffalump> conal: how does that work? Intuitively, global and relative time can always be translated into each other by just knowing the base, whereas Max is a lossy monoid and Sum isn't (you can't replicate the other input to Max from one input and the result, but you can with Sum)
13:25:37 <roconnor> @remember Meehl [The null hypothesis significance test is] a potent but sterile intellectual rake who leaves in his merry path a long train of ravished maidens but no viable scientific offspring
13:25:37 <lambdabot> Done.
13:26:04 <conal> jmcarthur: Cool paper title: "Temporal Monoids"
13:26:22 <jmcarthur> heh
13:26:37 <conal> Heffalump: it's in the reactive paper
13:26:47 <roconnor> @djinn Monoid t => (t -> a) -> a
13:26:47 <lambdabot> Error: Class not found: Monoid
13:26:54 <roconnor> damn
13:27:03 <RayNbow> roconnor: @djin-env
13:27:09 <RayNbow> (just don't do it here :p)
13:27:22 <conal> roconnor: ($ mempty)
13:28:03 <Heffalump> the 08 or 09 one?
13:28:06 <roconnor> RayNbow: that's okay I don't know how to use djinn-env to add classes
13:28:12 <jmcarthur> @djinn t -> (t -> t -> t) -> (t -> a) -> a
13:28:13 <lambdabot> f a b c = c (b a a)
13:28:22 <jmcarthur> meh, didn't need to use the mappend
13:28:27 <jmcarthur> @djinn t -> (t -> a) -> a
13:28:27 <lambdabot> f a b = b a
13:28:29 <roconnor> conal: I know that, but does djinn know that? :)
13:28:38 <conal> roconnor: oh, okay.
13:29:00 <jmcarthur> djinn knows it if you give it the type for mempty
13:29:02 <roconnor> heh
13:29:13 <RayNbow> let's see...
13:29:15 <RayNbow> @djinn-add class Monoid a = where mappend :: a -> a-> a; mempty :: a
13:29:16 <lambdabot> Cannot parse command
13:29:19 <roconnor> ($ (mempty `mappend` mempty))
13:29:26 <conal> Heffalump: i think both.  not positive about 08.
13:30:11 <RayNbow> @djinn-add class Monoid a where mappend :: a -> a-> a; mempty :: a
13:30:34 <jmcarthur> @djinn Monoid t => (t -> a) -> a
13:30:35 <lambdabot> f a = a (mappend mempty mempty)
13:30:38 <jmcarthur> haha
13:30:52 <jmcarthur> well, it's correct at least
13:31:01 <roconnor> djinn++
13:31:32 <opqdonut> :D
13:31:36 <opqdonut> lovely
13:31:56 <FliP^2eH> The Haskell Int is 32 bits, right?
13:31:59 <roconnor> I guess djinn kinda knows.
13:32:02 <FliP^2eH> How'd I get a 64 bit wide?
13:32:03 <jmcarthur> FliP^2eH: architecture dependent
13:32:15 <roconnor> FliP^2eH: use Int32 or Int64
13:32:23 <FliP^2eH> What module?
13:32:26 <roconnor> FliP^2eH: no guarentees are made about the size of Int
13:32:27 <jmcarthur> Data.Int
13:32:29 <RayNbow> @hoogle Int64
13:32:30 <lambdabot> Data.Int data Int64
13:32:33 <FliP^2eH> Thanks :)
13:32:33 <roconnor> > maxbound :: Int
13:32:35 <lambdabot>   Not in scope: `maxbound'
13:32:37 <opqdonut> well it's guaranteed to be at least 30 bits?
13:32:40 <roconnor> > maxBound :: Int
13:32:42 <lambdabot>   9223372036854775807
13:32:43 <jmcarthur> opqdonut: yes
13:32:45 <roconnor> opqdonut: oops, right
13:32:50 <opqdonut> or rather, required by h98
13:32:52 <roconnor> , maxBound :: Int
13:32:53 <lunabot>  2147483647
13:33:22 <RayNbow> > maxBound :: Bool
13:33:24 <lambdabot>   True
13:33:41 <Heffalump> conal: all I can see there is a brief comment at the bottom of section 4.2?
13:34:34 <jmcarthur> yeah my intuition is failing me on Sum for relative time as well... i don't see why it wouldn't still be Max
13:34:44 <dons> i'm glad to see turbinado still ticking over, http://www.reddit.com/r/programming/comments/8uebz/turbinado_v07_is_out_fast_light_concurrent_web/
13:35:00 <BMeph> jmcarthur: What's Max?
13:35:17 <conal> Heffalump: that brief comment plus structuring the semantics around time as a monoid.
13:35:25 <jmcarthur> BMeph: as in the newtype wrapper for the Monoid instance
13:36:25 <Gracenotes> yeeaaahh newtype
13:37:03 <jmcarthur> > Max 5 `mappend` Max 4
13:37:05 <lambdabot>   Not in scope: data constructor `Max'Not in scope: data constructor `Max'
13:37:05 <Heffalump> but in 4.4 you say that "0 must be the future that never arrives". How would that work in Sum?
13:37:07 <FliP^2eH> Any equivalent of C's "long" in Haskell?
13:37:10 <iop> is # supposed to work in haskore?
13:37:11 <jmcarthur> meh
13:37:16 <ehird> Does yi work yet?
13:37:32 <Heffalump> FliP^2eH: C's long is normally just 32 bit
13:37:34 <ehird> FliP^2eH: Just use Int if you're working with small integers, or Integer otherwise.
13:37:39 <Heffalump> so Int32 (which is Int in GHC)
13:37:43 <Gracenotes> FliP^2eH: it's called an Int64
13:37:44 <ehird> Relax GMP Is Fast.
13:37:47 <FliP^2eH> Integer does not want to be used :(
13:37:49 <ehird> Gracenotes: or that, but why bother?
13:37:53 <ehird> FliP^2eH: Wut?
13:37:55 <dons> FliP^2eH: what do you want? Word64 ? Int64?
13:37:57 <dons> Integer?
13:37:58 <Gracenotes> where's also Word64 for unsigned long
13:38:08 <Gracenotes> but really, Integer pls
13:38:13 <ehird> yah
13:38:18 <ehird> Integer! it's for awesome people.
13:38:28 <Gracenotes> three cheers for integer
13:38:35 <dons> yay!!
13:38:36 <Gracenotes> hip hip, hooray! hip hip, hooray! hip hip, hooray!
13:38:38 <Botje> hurray!
13:38:40 <ehird> Integer is like happiness.
13:38:43 <ehird> Only moreso.
13:38:43 <Gracenotes> >_<
13:38:44 <FliP^2eH> I'm using Integer now
13:38:47 <FliP^2eH> It keeps wrapping
13:38:52 <ehird> FliP^2eH: ...WHAT
13:38:52 <jmcarthur> wrapping?
13:38:55 <FliP^2eH> I don't want no wrapping.,
13:38:57 <ehird> Are you sure you don't mean Int?
13:39:01 <ehird> Int != Integer.
13:39:04 <jmcarthur> Int /= Integer
13:39:05 <Heffalump> you have a very odd computer :-)
13:39:06 <ehird> Int is tiiiny. Integer is biiiiiiiiiiiig.
13:39:07 <FliP^2eH> fromBase :: Int -> String -> Maybe Integer
13:39:08 <jmcarthur> ehird: ew, not haskell
13:39:16 <Gracenotes> of course if there are performance issues..
13:39:16 <ehird> jmcarthur: Shush thou.
13:39:22 <ehird> Gracenotes: GMP is pretty fast...
13:39:26 <ehird> FliP^2eH: "Int ->"
13:39:32 <ehird> FliP^2eH: Your Int is wrapping.
13:39:34 <FliP^2eH> That's just the Base
13:39:39 <ehird> Oh.
13:39:42 <Gracenotes> ehird: I have used Word64 in cases where Integer was too slow
13:39:42 <FliP^2eH> The base will only go from 2 - 36
13:39:46 <jmcarthur> FliP^2eH: if your calculations are in Int and then you convert to Integer at the end, you're doing it wrong
13:39:50 <jmcarthur> convert to Integer first!
13:39:51 <ehird> FliP^2eH: Yes... that's part of the algorithm.
13:39:56 <ehird> FliP^2eH: What digits would it use past 36?
13:40:05 <ehird> 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ
13:40:09 <ehird> ...and then...
13:40:10 <Gracenotes> whoa
13:40:37 <Gracenotes> > text $ take 500 $ ['z'..]
13:40:38 <lambdabot>   z{|}~ ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂ...
13:40:43 <FliP^2eH> Couldn't match expected type `Int' against inferred type `Integer'
13:40:51 <FliP^2eH> How'd I cast?
13:40:54 <ehird> FliP^2eH: listen, it's not the Int wrapping
13:40:55 <BMeph> jmcarthur: Oh, you mean conal's proposal Max?
13:40:55 <Gracenotes> that may be your problem
13:40:57 <jmcarthur> Gracenotes: yes! we need numbers to look like that
13:40:58 <FliP^2eH>        where convert (n, c) = (fromGlyph c) * (base^n)
13:41:00 <ehird> FliP^2eH: fromBase only handles bases 2-36
13:41:11 <jmcarthur> BMeph: i suppose. seems obvious enough to be in Data.Monoid, but i guess not
13:41:42 <FliP^2eH> @hpaste
13:41:43 <lambdabot> Haskell pastebin: http://hpaste.org/new
13:41:57 <FliP^2eH> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6124#a6124
13:42:10 <FliP^2eH> Add one more F in main and it will wrap to -1
13:42:42 <BMeph> FliP^2eH:
13:43:08 <Gracenotes> > text $ showIntAtBase 1000 (['a'..]!!) (2^100) ""
13:43:09 <lambdabot>   bŬ˫ʹŅņǲɑ̠ĮǙ
13:43:25 <ehird> bŬ˫ʹŅņǲɑ̠ĮǙ — $10 to the first person to give a pronunciation .wav
13:43:40 <jmcarthur> text to speech!
13:44:00 <BMeph> Whoops, I blame whoever decided to put the quote marks right next to the ENTER key. :)
13:44:00 <monochrom> I want $1,000,000,000,000
13:44:24 <BMeph> FliP^2eH: "I do not think this word means, what you think it means." :)
13:44:26 <ehird> @pl (\x y -> (x*b)+y)
13:44:26 <lambdabot> (+) . (b *)
13:44:37 <FliP^2eH> What.
13:44:38 <nibro> is there any way to tell haddock not to list an instance of a package-internal type class?
13:44:40 <Gracenotes> great success
13:44:45 <FliP^2eH> I just want to to go as high as it can
13:44:48 <FliP^2eH> Without going to -1
13:45:04 <ehird> @hoogle [a]->a->Int
13:45:04 <lambdabot> Data.List elemIndex :: Eq a => a -> [a] -> Maybe Int
13:45:04 <lambdabot> Data.List elemIndices :: Eq a => a -> [a] -> [Int]
13:45:04 <lambdabot> Prelude (!!) :: [a] -> Int -> a
13:45:07 <jmcarthur> nibro: perhaps you want to have a different newtype wrapper for the exposed version?
13:45:14 <Gracenotes> @pl rearranges + and * since it's commutative (sometimes)
13:45:15 <lambdabot> rearranges + and * since it's commutative sometimes
13:45:18 <nibro> jmcarthur: I don't want to expose it at all
13:45:21 <Gracenotes> :3
13:45:26 <Gracenotes> >success<
13:45:31 <jmcarthur> oh, you don't want to expose the _type_ at all?
13:45:33 <ehird> :t \b -> foldl ((+) . (b *)) . map ("0123456789abcdefghijklmnopqrstuvwxyz" `elemIndex`)
13:45:34 <lambdabot>     No instance for (Num [Maybe Int])
13:45:34 <lambdabot>       arising from a use of `+' at <interactive>:1:13-15
13:45:34 <lambdabot>     Possible fix: add an instance declaration for (Num [Maybe Int])
13:45:40 <ehird> :t \b -> foldl ((+) . (b *)) 0 . map ("0123456789abcdefghijklmnopqrstuvwxyz" `elemIndex`)
13:45:41 <nibro> jmcarthur: the type class itself is not exported, nor any of its methods
13:45:41 <lambdabot>     No instance for (Num (Maybe Int))
13:45:42 <lambdabot>       arising from a use of `+' at <interactive>:1:13-15
13:45:42 <lambdabot>     Possible fix: add an instance declaration for (Num (Maybe Int))
13:45:45 <ehird> hm what
13:45:47 <ehird> oh
13:45:49 <Gracenotes> lolwut
13:45:50 <ehird> elemIndex returns maybe
13:45:56 <ehird> :t \b -> foldl ((+) . (b *)) 0 . map (fromJust . "0123456789abcdefghijklmnopqrstuvwxyz" `elemIndex`)
13:45:57 <lambdabot>     The operator `elemIndex' [infixl 9] of a section
13:45:57 <lambdabot>         must have lower precedence than that of the operand,
13:45:57 <lambdabot>           namely `.' [infixr 9]
13:46:00 <ehird> ...
13:46:02 <nibro> jmcarthur: nor any functions that need it in the context
13:46:03 <Gracenotes> burn
13:46:04 <ehird> :t \b -> foldl ((+) . (b *)) 0 . map (fromJust . ("0123456789abcdefghijklmnopqrstuvwxyz" `elemIndex`))
13:46:06 <lambdabot> Int -> [[[Char]]] -> Int
13:46:11 <ehird> Er.
13:46:13 <Gracenotes> burn
13:46:16 <jmcarthur> nibro: oh so it really is just a hackage thing. i have no idea then
13:46:20 <ehird> Oh, wrong way around.
13:46:28 <ehird> :t \b -> foldl ((+) . (b *)) 0 . map (fromJust . (`elemIndex` "0123456789abcdefghijklmnopqrstuvwxyz"))
13:46:29 <lambdabot> Int -> [Char] -> Int
13:46:32 <nibro> jmcarthur: ok, thanks anyway
13:46:37 <ehird> FliP^2eH: i rewrote your fromBase shorter.
13:46:44 <ehird> > let fromBase = \b -> foldl ((+) . (b *)) 0 . map (fromJust . (`elemIndex` "0123456789abcdefghijklmnopqrstuvwxyz")) in fromBase 16 "ff"
13:46:46 <lambdabot>   255
13:47:08 <Gracenotes> ffffffffffuuu
13:47:22 <FliP^2eH> MAn
13:47:26 <ehird> Hey, using the Maybe monad we could even do the -> Maybe Int thing.
13:47:30 <jmcarthur> > let fromBase = \b -> foldl ((+) . (b *)) 0 . map (fromJust . (`elemIndex` "0123456789abcdefghijklmnopqrstuvwxyz")) in fromBase 16 "fffffffffff" :: Integer
13:47:30 <ehird> That would be fun!
13:47:32 <lambdabot>   Couldn't match expected type `GHC.Integer.Internals.Integer'
13:47:39 <FliP^2eH> I guess my whole program can be reduced to 5 lines if I gave it to you
13:47:43 <ehird> jmcarthur: Yeah yeah. Blame elemIndex.
13:47:47 <jmcarthur> oh, yeah
13:47:53 <ehird> jmcarthur: Do fromInteger like dis:
13:47:59 <ehird> > let fromBase = \b -> foldl ((+) . (b *)) 0 . map (toInteger . fromJust . (`elemIndex` "0123456789abcdefghijklmnopqrstuvwxyz")) in fromBase 16 "ff"
13:48:00 <lambdabot>   255
13:48:02 <ehird> toInteger, rather
13:48:05 <ehird> > let fromBase = \b -> foldl ((+) . (b *)) 0 . map (toInteger . fromJust . (`elemIndex` "0123456789abcdefghijklmnopqrstuvwxyz")) in fromBase 16 "ff" :: Integer
13:48:05 <jmcarthur> i was about to do that :P
13:48:07 <lambdabot>   255
13:48:09 <ehird> Voila.
13:48:20 <ehird> Okay, now someone use the Maybe monad to make it return Maybe Integer :-P
13:48:22 <jmcarthur> > let fromBase = \b -> foldl ((+) . (b *)) 0 . map (toInteger . fromJust . (`elemIndex` "0123456789abcdefghijklmnopqrstuvwxyz")) in fromBase 16 "fffffffffffffffff" :: Integer
13:48:24 <lambdabot>   295147905179352825855
13:50:24 <ehird> > let fromBase b = foldl (\x y -> ((+) . (b *)) `fmap` (x >>= y)) (Just 0) . map (`elemIndex` "0123456789abcdefghijklmnopqrstuvwxyz") in fromBase 16 "z"
13:50:26 <lambdabot>   Couldn't match expected type `(a -> a) -> Data.Maybe.Maybe a'
13:50:28 <ehird> > let fromBase b = foldl (\x y -> ((+) . (b *)) `fmap` (x >>= y)) (Just 0) . map (`elemIndex` "0123456789abcdefghijklmnopqrstuvwxyz") in fromBase 16 "z"
13:50:30 <lambdabot>   Couldn't match expected type `(a -> a) -> Data.Maybe.Maybe a'
13:50:35 <ehird> Grumble.
13:50:44 <FliP^2eH> Stop making me feel like and idiot
13:50:45 <FliP^2eH> :(
13:50:53 <ehird> FliP^2eH: Nooo, you're not.
13:51:00 <ehird> We just have a compulsive tendency to shorten stuff.
13:51:03 <ehird> And we hate points.
13:51:03 <FliP^2eH> Why did you squish my 17 lines of fromBase into 1 line?
13:51:13 <ehird> FliP^2eH: Well it doesn't do the Maybe thing yet.
13:51:20 <ehird> :P
13:51:23 <Gracenotes> nooooooooooooooooooooooooo
13:51:36 <ehird> :t \b -> foldr (\x y -> ((+) . (b *) . toInteger) `fmap` (x >>= y)) (Just 0) . map (`elemIndex` "0123456789abcdefghijklmnopqrstuvwxyz")
13:51:38 <lambdabot>     Couldn't match expected type `Integer -> Integer -> Integer'
13:51:38 <lambdabot>            against inferred type `Maybe t'
13:51:38 <lambdabot>     In the second argument of `foldr', namely `(Just 0)'
13:51:52 <ehird> ...................................................................................WAT, Oh!
13:51:55 <ehird> Duhh.
13:51:56 <sampointon> FliP^2eH: it's the #haskell compression algorithm -- if you want something shortened, tell this channel :)
13:52:14 <FliP^2eH> And if I want to shorten myself
13:52:16 <FliP^2eH> ?
13:52:20 <FliP^2eH> I want to be as good as this :(
13:52:29 <ehird> :t \b -> foldl (\x y -> x >>= \x' -> y >>= \y' -> return ((x*b)+y)) (Just 0) . map (`elemIndex` "0123456789abcdefghijklmnopqrstuvwxyz")
13:52:31 <lambdabot>     Occurs check: cannot construct the infinite type: a = m a
13:52:31 <lambdabot>       Expected type: m a
13:52:31 <lambdabot>       Inferred type: m (m a)
13:52:31 <Gracenotes> senor, la function es börked
13:52:35 <ehird> FliP^2eH: Keep learning Haskell ;-)
13:52:38 <FliP^2eH> I think my whole app can be shortened at about 70%
13:52:43 <ehird> :t \b -> foldl (\x y -> x >>= \x' -> y >>= \y' -> return ((x'*b)+y')) (Just 0) . map (`elemIndex` "0123456789abcdefghijklmnopqrstuvwxyz")
13:52:44 <lambdabot> Int -> [Char] -> Maybe Int
13:52:48 <ehird> OK, that's a start.
13:52:51 <ehird> Ugly, but it's a start.
13:52:57 <Gracenotes> senor, la function es börked y no puedo reparar!
13:52:59 <ehird> > let fromBase = \b -> foldl (\x y -> x >>= \x' -> y >>= \y' -> return ((x'*b)+y')) (Just 0) . map (`elemIndex` "0123456789abcdefghijklmnopqrstuvwxyz") in fromBase 16 "z"
13:53:00 <lambdabot>   Just 35
13:53:04 <ehird> Erm.
13:53:06 <ehird> Oh, I see.
13:53:10 <FliP^2eH> Yeah yeah
13:53:15 <FliP^2eH> Now the range check
13:53:22 <ehird> > let fromBase = \b -> foldl (\x y -> x >>= \x' -> y >>= \y' -> return ((x'*b)+y')) (Just 0) . map (`elemIndex` (take b "0123456789abcdefghijklmnopqrstuvwxyz")) in fromBase 16 "z"
13:53:23 <lambdabot>   Nothing
13:53:26 <ehird> 8)
13:53:28 <ehird> > let fromBase = \b -> foldl (\x y -> x >>= \x' -> y >>= \y' -> return ((x'*b)+y')) (Just 0) . map (`elemIndex` (take b "0123456789abcdefghijklmnopqrstuvwxyz")) in fromBase 16 "ff"
13:53:29 <lambdabot>   Just 255
13:53:35 <ehird> Now to deuglimate.
13:54:02 <dancor> if you are searching a graph with infinite-depth and infinite-degree nodes, then either depth- or breadth- first might never search parts of the graph.  what kind of search do you do then?
13:54:04 <sampointon> @pl  (\x y -> x >>= \x' -> y >>= \y' -> return ((x'*b)+y'))
13:54:05 <lambdabot> liftM2 ((+) . (b *))
13:54:11 <sampointon> ehird: voila!
13:54:45 <ehird> sampointon: nice
13:54:51 <ehird> > let fromBase = \b -> foldl (liftM2 ((+) . (b *))) (Just 0) . map (`elemIndex` (take b "0123456789abcdefghijklmnopqrstuvwxyz")) in fromBase 16 "ff"
13:54:53 <lambdabot>   Just 255
13:54:54 <sampointon> wait, isn't that what there was before?
13:54:55 <ehird> > let fromBase = \b -> foldl (liftM2 ((+) . (b *))) (Just 0) . map (`elemIndex` (take b "0123456789abcdefghijklmnopqrstuvwxyz")) in fromBase 16 "z"
13:54:56 <lambdabot>   Nothing
13:55:00 <Heffalump> dancor: some kind of iterative deepening and widening?
13:55:02 <ehird> sampointon: w/o the liftM2, yes
13:55:04 <dancor> ya..
13:55:15 <Gracenotes> o nos
13:55:15 <sampointon> ehird: oh, that makes sense, yes
13:55:25 <ehird> @pl \b -> foldl (liftM2 ((+) . (b *))) (Just 0) . map . flip elemIndex . take b $ "0123456789abcdefghijklmnopqrstuvwxyz"
13:55:26 <lambdabot> ($ "0123456789abcdefghijklmnopqrstuvwxyz") . ap ((.) . flip foldl (Just 0) . liftM2 . ((+) .) . (*)) (((map . flip elemIndex) .) . take)
13:55:31 <ehird> I'll pass on that one, lambdabot
13:55:47 <ehird> > let fromBase = \b -> foldl (liftM2 $ (+) . (b *)) (Just 0) . map . flip elemIndex . take b $ "0123456789abcdefghijklmnopqrstuvwxyz" in fromBase 16 "ff"
13:55:49 <lambdabot>   Couldn't match expected type `[Data.Maybe.Maybe GHC.Types.Int]'
13:55:54 <ehird> Well gosh darnit.
13:55:54 <Gracenotes> but... it doesn't wrap, of course
13:55:58 <Gracenotes> I mean it does. you're using ints
13:56:05 <ehird> Gracenotes: I had fromInteger before
13:56:09 <ehird> I'll add that back in once this types
13:56:10 <ehird> > let fromBase = \b -> foldl (liftM2 $ (+) . (b *)) (Just 0) . map . elemIndex . take b $ "0123456789abcdefghijklmnopqrstuvwxyz" in fromBase 16 "ff"
13:56:11 <lambdabot>   Couldn't match expected type `[Data.Maybe.Maybe GHC.Types.Int]'
13:56:14 <ehird> Grrr.
13:56:20 <ehird> Oh.
13:56:43 <ehird> > let fromBase = \b -> foldl (liftM2 $ (+) . (b *)) (Just 0) . map (flip elemIndex . take b "0123456789abcdefghijklmnopqrstuvwxyz") in fromBase 16 "ff"
13:56:44 <lambdabot>   Couldn't match expected type `a -> [a1]'
13:56:47 <ehird> :t \b -> foldl (liftM2 $ (+) . (b *)) (Just 0) . map (flip elemIndex . take b "0123456789abcdefghijklmnopqrstuvwxyz")
13:56:48 <lambdabot>     Couldn't match expected type `a -> [a1]'
13:56:48 <lambdabot>            against inferred type `[Char]'
13:56:48 <lambdabot>     In the second argument of `(.)', namely
13:56:58 <ehird> Oh, hm.
13:57:00 <ehird> :t \b -> foldl (liftM2 $ (+) . (b *)) (Just 0) . map (elemIndex . take b "0123456789abcdefghijklmnopqrstuvwxyz")
13:57:02 <lambdabot>     Couldn't match expected type `a -> b'
13:57:02 <lambdabot>            against inferred type `[Char]'
13:57:02 <lambdabot>     In the second argument of `(.)', namely
13:57:10 <ehird> Argh. oh!
13:57:12 <sampointon> > let fromBase = \b -> foldl (liftM2 ((+) . (b *)) `on` fromInteger) (Just 0) . map (`elemIndex` (take b "0123456789abcdefghijklmnopqrstuvwxyz")) in fromBase 16 "ffffffffffff"
13:57:14 <lambdabot>   Couldn't match expected type `GHC.Integer.Internals.Integer'
13:57:25 <ehird> :t elemIndex
13:57:27 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe Int
13:57:30 <ehird> @pl \x -> elemIndex x (take b "0123456789abcdefghijklmnopqrstuvwxyz")
13:57:31 <lambdabot> flip elemIndex (take b "0123456789abcdefghijklmnopqrstuvwxyz")
13:57:38 <ehird> :t \b -> foldl (liftM2 $ (+) . (b *)) (Just 0) . map (flip elemIndex $ take b "0123456789abcdefghijklmnopqrstuvwxyz")
13:57:40 <lambdabot> Int -> [Char] -> Maybe Int
13:58:10 <ehird> (\x y -> x >>= \x' -> y >>= \y' -> return ((x'*b)+(toInteger y')))
13:58:12 <ehird> oops
13:58:13 <ehird> @pl (\x y -> x >>= \x' -> y >>= \y' -> return ((x'*b)+(toInteger y')))
13:58:13 <lambdabot> liftM2 ((. toInteger) . (+) . (b *))
13:58:19 <sampointon> > let fromBase = \b -> foldl (liftM2 ((+) . (b *)) `on` toInteger) (Just 0) . map (`elemIndex` (take b "0123456789abcdefghijklmnopqrstuvwxyz")) in fromBase 16 "ff"
13:58:21 <lambdabot>   Couldn't match expected type `m a1'
13:58:24 <patch-tag> patch-tag (a happs server application) garbage collects like crazy. and is beginning to have performance degredation. when I run it with +RTS -B that bell is dinging like mad
13:58:24 <ehird> :t \b -> foldl (liftM2 ((. toInteger) . (+) . (b *))) (Just 0) . map (flip elemIndex $ take b "0123456789abcdefghijklmnopqrstuvwxyz")
13:58:25 <lambdabot>     Couldn't match expected type `Int' against inferred type `Integer'
13:58:26 <lambdabot>     In the first argument of `take', namely `b'
13:58:26 <lambdabot>     In the second argument of `($)', namely
13:58:30 <ehird> Nooooooooooo
13:58:31 <ehird> So close.
13:58:35 <patch-tag> what causes app to GC like mad?
13:58:38 <ehird> :t \b -> foldl (liftM2 ((. toInteger) . (+) . (b *))) (Just 0) . map (flip elemIndex $ take (fromInteger b) "0123456789abcdefghijklmnopqrstuvwxyz")
13:58:39 <lambdabot> Integer -> [Char] -> Maybe Integer
13:58:42 <ehird> YESSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS
13:58:45 <patch-tag> could I find this out by profiling?
13:58:56 <ehird> > let fromBase = \b -> foldl (liftM2 ((. toInteger) . (+) . (b *))) (Just 0) . map (flip elemIndex $ take (fromInteger b) "0123456789abcdefghijklmnopqrstuvwxyz") in fromBase 16 "ff"
13:58:58 <lambdabot>   Just 255
13:58:59 <ehird> > let fromBase = \b -> foldl (liftM2 ((. toInteger) . (+) . (b *))) (Just 0) . map (flip elemIndex $ take (fromInteger b) "0123456789abcdefghijklmnopqrstuvwxyz") in fromBase 16 "z"
13:59:00 <lambdabot>   Nothing
13:59:02 <ehird> I win.
13:59:22 <enolan> patch-tag: the +RTS -p profiling will give you %alloc and %time per cost-center. So yes.
13:59:37 <sampointon> @unpl ((. toInteger) . (+) . (b *))
13:59:38 <lambdabot> (\ f l -> (b * f) + (toInteger l))
13:59:48 <patch-tag> I'll try that
14:00:00 <ehird> sampointon: That's probably clearer, yeah.
14:00:08 <sampointon> ehird: I dunno, doesn't seem like a huge win
14:00:16 <sjanssen> patch-tag: frequent GCs aren't necessarily a problem
14:00:23 <ehird> sampointon: Seems clearer than the pointless version; that (. toInteger) trips me up.
14:00:32 <sjanssen> patch-tag: are you seeing frequent minor collections, or major collections?
14:00:43 <sampointon> ehird: well, I was trying to work `on` toInteger in somewhere :)
14:01:50 <dancor> Heffalump: perhaps you could also transform your graph
14:02:22 <ehird> Here's an 80-column one:
14:02:23 <ehird> fromBase :: Int -> String -> Maybe Integer
14:02:24 <ehird> fromBase b = foldl (liftM2 addUp) (Just 0) . map (elemIndex digits)
14:02:26 <ehird>     where addUp x y = (toInteger b * x) + toInteger y
14:02:28 <ehird>           digits = take b "0123456789abcdefghijklmnopqrstuvwxyz"
14:03:20 <ehird> FliP^2eH: Sorry about that ;-)
14:03:32 <FliP^2eH> aw
14:04:07 <dancor> seems possible to unwind the infinite-degree nodes and then apply breadth-first search
14:04:37 * dancor wonders if it is possible to change the graph so that you can apply depth-first search
14:05:42 <patch-tag> sjanssen: how can I tell if it's a minor or major collection?
14:05:51 <dancor> take b $ ['0'..'9'] ++ ['a'..'z']
14:05:52 <sampointon> @unpl foldr (<=<) id
14:05:52 <lambdabot> foldr (<=<) (\ a -> a)
14:06:04 <ehird> dancor: oh! of course
14:06:17 <ehird> hmm
14:06:22 <ehird> i bet this could be two 80-col lines
14:06:40 <ehird> hmm, naw
14:07:05 <ehird> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6125 ;; (FliP^2eH) improvements welcome ;-)
14:07:14 <dancor> i would say don't worry about microoptimizing lines, or at least write a program to do it for you ;)
14:07:22 <ehird> we could call it @pl
14:07:33 <dancor> pl80
14:07:37 <FliP^2eH> I feel stupid now
14:07:43 <ehird> @pl liftM2 (\x y -> (toInteger b * x) + toInteger y)
14:07:43 <lambdabot> liftM2 ((. toInteger) . (+) . (toInteger b *))
14:07:55 <ehird> FliP^2eH: eh, your code is better than most of mine looks first cut...
14:07:56 <sampointon> then we'd have @unpl80, for exploding the right-hand edge of the screen?
14:08:46 <ehird> FliP^2eH: you'll get the knack sometime :)
14:08:52 <ehird> just takes a while
14:08:55 <FliP^2eH> I'm happy when my programs work
14:09:01 <FliP^2eH> It's gotten better
14:09:06 <ehird> hehe
14:09:14 <ehird> hmm, thought
14:09:20 <sjanssen> patch-tag: I think one of the RTS flags can spit out periodic messages with more detail
14:09:23 <FliP^2eH> I think my smartest and most integrated line so far is my "check" function
14:09:26 <ehird> maybe the * (base^n) method would be more concise
14:09:28 <Gracenotes> there should be an unpl where all monads and applicatives that are marked are function instances
14:09:31 <FliP^2eH> check s = map (\x -> if x `elem` glyphs then case x `elemIndex` glyphs of Just n -> if (n+1) > base then False else True; Nothing -> False; else False) s
14:09:32 <FliP^2eH> ;s
14:09:39 <ehird> @hoogle [a] -> [(Int,a)]
14:09:40 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
14:09:40 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
14:09:40 <lambdabot> Test.QuickCheck two :: Monad m => m a -> m (a, a)
14:09:43 <ehird> @hoogle [a] -> [(Integer,a)]
14:09:43 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
14:09:43 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
14:09:43 <lambdabot> Test.QuickCheck two :: Monad m => m a -> m (a, a)
14:09:45 <ehird> hmm
14:09:48 <ehird> oh
14:09:55 <Gracenotes> @type zip [1..]
14:09:55 <ehird> zip xs [1..]
14:09:55 <ehird> :-)
14:09:56 <lambdabot> forall t b. (Num t, Enum t) => [b] -> [(t, b)]
14:10:09 <Gracenotes> INDEEDY SO
14:10:12 <ehird> @pl (\i x -> x*(b^i))
14:10:13 <lambdabot> (*) . (b ^)
14:10:47 <ehird> foldl (liftM2 addUp) (Just 0)
14:10:48 <ehird> sum . map ((*) . (b ^)) . zip [1..]
14:10:50 * BMeph personally HATES FliP^2eH's 'check' function. Nothing personal, it's just Evil and must be destroyed. ;)
14:10:52 <ehird> oh wait
14:10:55 <ehird> that doesn't include addUp's source
14:10:56 <ehird> haha
14:11:14 <ehird> :t liftM2
14:11:15 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
14:11:40 <Gracenotes> u has liftm 2? :D
14:12:40 <ehird> :t \b->sum . map (liftM2 $ (*) . (b ^)) . zip [1..] . map (elemIndex $take b $ ['0'..'9'] ++ ['a'..'z'])
14:12:41 <lambdabot>     No instance for (Integral (Maybe Int))
14:12:41 <lambdabot>       arising from a use of `^' at <interactive>:1:31-33
14:12:41 <lambdabot>     Possible fix:
14:12:45 <dancor> @80 would need a haskell parser that preserves whitespace
14:12:45 <Gracenotes> hm. I recall that you can get liftM3 from liftM2, and generally liftMX from liftMX-1... right?
14:12:46 <lambdabot> Maybe you meant: . ? @ bf ft id pl rc v wn
14:12:47 <BMeph> FliP^2eH: Case in point: If someone gives your fromBase function the empty string, it crashes ungracefully. But, that's just a personal peeve of mine, so please feel free to ignore me. :)
14:12:56 <ehird> :t (*) . (3 ^)
14:12:57 <lambdabot> forall b a. (Num b, Integral a) => a -> b -> b
14:13:00 <FliP^2eH> Mine won't fail!
14:13:02 <ehird> hmmm
14:13:03 <FliP^2eH> It's fail prrof!
14:13:06 <FliP^2eH> proof.
14:13:21 <ehird> nah, I don't see this as being shorter than the fold route
14:13:22 <Gracenotes> profy
14:13:22 <BMeph> FliP^2eH: I think you had it right the first time. ;)
14:13:34 <FliP^2eH> Mine is longer
14:13:40 <FliP^2eH> Way longer. But uncrashable.
14:14:37 <ehird> Mine's uncrashable too :P
14:15:21 <sampointon> Gracenotes: liftMn f a_1 a_2 ... a_n == (liftM(n-1) f a_1 a_2 ... a_(n-1)) `ap` a_n
14:15:33 <sampointon> Gracenotes: I think. Something like that, anyway
14:15:34 <Gracenotes> oh, right. I always forget that use of ap
14:15:50 <BMeph> So, has anyone made a utility function boolToMaybe :: Bool -> Maybe (), yet? ;)
14:16:11 <opqdonut> isn't that specialised guard?
14:16:18 <opqdonut> :t guard :: Bool -> Maybe ()
14:16:19 <lambdabot> Bool -> Maybe ()
14:16:22 <opqdonut> :)
14:16:49 <Gracenotes> gard ... evoir
14:16:59 <BMeph> opqdonut: Yes, it is - good eye. :)
14:17:33 <opqdonut> of course using guard in non-monadic code is probably not very reader-friendly
14:18:22 <BMeph> Gracenotes: The use of 'ap' is easy to remember when you recall that one defn for ap is liftM2 id. Okay, it's easy for me, so YMMV. :)
14:18:51 <Gracenotes> any other definition would be equivalent
14:19:29 <BMeph> Gracenotes: Well, yeah, but usual other definitions don't explicitly use liftM2, which was my point. :)
14:23:37 <dancor> is Language.Haskell.HsColour.Classify.tokenise really the best tokenizer to use that preserves whitespace?
14:25:45 <Philippa> possibly. I assume you want an actual haskell one - I've got a 'haskell-like' one for my own projects, though it's probably not too fast as it uses Parsec
14:26:54 <BMeph> ehird: BTW, does your version handle negatives? ;)
14:28:08 * BMeph is now thinking that he should spend more brain-power on making his own version, instead of Harrop-ing everyone else's...
14:28:18 <ehird> BMeph: nope
14:28:25 <Cale> Version of what?
14:28:40 <ehird> Cale: fromBase :: Int -> String -> Maybe Integer
14:28:43 <ehird> my entry:
14:28:43 <ehird> fromBase :: Int -> String -> Maybe Integer
14:31:05 <ehird> as I was saying
14:31:06 <ehird> fromBase :: Int -> String -> Maybe Integer
14:31:07 <ehird> fromBase b = foldl (liftM2 addUp) (Just 0) . map (elemIndex digits)
14:31:09 <ehird>     where addUp x y = (toInteger b * x) + toInteger y
14:31:11 <ehird>           digits = take b $ ['0'..'9'] ++ ['a'..'z']
14:31:17 * Cale would use readInt
14:31:36 <deech> Hi all, I have question about HXT's XPath capabilities, can I ask it here?
14:31:48 <ehird> Cale: that results in an Int
14:31:55 <Cale> no it doesn't
14:31:59 <Cale> :t readInt
14:32:00 <lambdabot> forall a. (Num a) => a -> (Char -> Bool) -> (Char -> Int) -> String -> [(a, String)]
14:32:10 <Gracenotes> whooa
14:32:15 <ehird> oh.
14:32:20 <ehird> hey FliP^2eH
14:32:21 <ehird> use that.
14:32:47 <Gracenotes> what's up, doc, http://haskell.org/ghc/docs/latest/html/libraries/base/Numeric.html#v:readInt
14:32:53 <ehird> :t elem
14:32:55 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
14:33:09 <ehird> ah, wait
14:33:14 <ehird> Cale: that doesn't handle invalid digits
14:33:16 <ehird> mine does
14:33:18 <ehird> so nyah :)
14:33:24 <Cale> It can.
14:33:25 <ehird> wait
14:33:26 <ehird> yes it does
14:33:33 <ehird> :t elemIndex
14:33:34 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe Int
14:33:55 <ehird> :t \b -> readInt 0 (`elem` b') (fromJust . (`elemIndex` b'))
14:33:56 <lambdabot> Not in scope: `b''
14:33:56 <lambdabot> Not in scope: `b''
14:33:57 <ehird> er
14:34:05 <Cale> It does not handle sign, but by applying readSigned to it, you get a reader for signed values.
14:34:10 <Cale> :t readSigned
14:34:11 <lambdabot> forall a. (Real a) => ReadS a -> String -> [(a, String)]
14:34:18 <ehird> :t \b -> readInt 0 (`elem` b') (fromJust . (`elemIndex` b')) where b' = take b $ ['0'..'9'] ++ ['a'..'z']
14:34:19 <lambdabot> parse error on input `where'
14:34:22 <ehird> grr
14:34:40 <ehird> :t \b -> let digits = take b $ ['0'..'9'] ++ ['a'..'z'] in readInt 0 (`elem` digits) (fromJust . (`elemIndex` digits))
14:34:42 <lambdabot> forall t. (Num t) => Int -> String -> [(t, String)]
14:34:44 <Cale> That is odd...
14:34:46 <ehird> almost!
14:34:49 * yaxu gets a blog post in haskell weekly news twice
14:34:53 <Cale> What does readSigned need Real for?
14:34:59 <ehird> grr
14:35:07 <ehird> to just get a t back, you need to sacrifice pointfreeity
14:35:26 <ehird> wait, no
14:35:29 <ehird> :t \b -> let digits = take b $ ['0'..'9'] ++ ['a'..'z'] in fst . head . readInt 0 (`elem` digits) (fromJust . (`elemIndex` digits))
14:35:30 <lambdabot> forall a. (Num a) => Int -> String -> a
14:35:36 <ehird> hmm
14:35:39 <ehird> @hoogle [a] -> Maybe a
14:35:39 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
14:35:39 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
14:35:39 <lambdabot> Prelude head :: [a] -> a
14:35:46 <ehird> no safeHead :-(
14:36:58 <Cale> Hmm, that's stupid.
14:37:08 <Cale> readSigned has a Real context that it doesn't need.
14:37:26 <Cale> It could be (Num a)
14:37:51 <Cale> The inferred type of the implementation used is (Num a) => ReadS a -> ReadS a, even.
14:38:00 <opqdonut> heh
14:38:29 <Cale> Also, I don't understand the comment here:
14:38:33 <Cale> -- It's turgid to have readSigned work using list comprehensions,
14:38:33 <Cale> -- but it's specified as a ReadS to ReadS transformer
14:38:33 <Cale> -- With a bit of luck no one will use it.
14:38:39 <ehird> Cale: getting readInt into a passable form is more work than just using my fromBase :P
14:39:21 <Cale> ehird: Why do you want a safeHead?
14:39:35 <Cale> ehird: What value were you going to return if the parse failed?
14:39:36 <ehird> Cale: for (Int -> String -> Maybe Integer) in the [(t,String)] results
14:39:39 <ehird> Nothing.
14:39:43 <Cale> oh, right
14:39:45 <ehird> I'm trying to rewrite this with readInt to be shorter:
14:39:46 <ehird> fromBase :: Int -> String -> Maybe Integer
14:39:47 <ehird> fromBase b = foldl (liftM2 addUp) (Just 0) . map (elemIndex digits)
14:39:49 <Cale> :t listToMaybe
14:39:49 <ehird>     where addUp x y = (toInteger b * x) + toInteger y
14:39:50 <lambdabot> forall a. [a] -> Maybe a
14:39:51 <ehird>           digits = take b $ ['0'..'9'] ++ ['a'..'z']
14:39:53 <ehird> and I don't think it's gonna work proply.
14:40:27 <Cale> > listToMaybe [1,2,3]
14:40:28 <lambdabot>   Just 1
14:40:30 <Cale> > listToMaybe []
14:40:31 <lambdabot>   Nothing
14:40:46 <ehird> coo
14:40:47 <copumpkin> that should be called safeHead :P
14:40:49 <ehird> yes
14:40:54 <ehird> copumpkin: no, it should be called head
14:41:01 <ehird> and head should be called unsafeDoHead#
14:41:03 <Cale> I don't think listToMaybe is all that bad a name, is it?
14:41:11 <copumpkin> I guess, if you want to make everything total
14:41:16 <ehird> Cale: it's terrible
14:41:19 <ehird> Cale: it doesn't convert the list
14:41:21 <ehird> it just converts the head
14:41:22 <iop> > let safeHead (x:xs) = Just x; safeHead [] = Nothing in safeHead [12,3,4]
14:41:22 <Cale> head is fine as it is.
14:41:23 <lambdabot>   Just 12
14:41:28 <iop> > let safeHead (x:xs) = Just x; safeHead [] = Nothing in safeHead []
14:41:30 <lambdabot>   Nothing
14:41:31 <ehird> iop: safeHead = listToMaybe
14:41:34 <Cale> I like head to be partial.
14:41:39 <ehird> 22:41 copumpkin: I guess, if you want to make everything total ← YESPLZ!
14:41:42 <copumpkin> totally partial
14:41:44 <Gracenotes> hm. what would a safeHead one-liner look like?
14:41:53 <copumpkin> safeHead = listToMaybe ;)
14:41:58 <Cale> head is for when you're sure that the list really does have a member
14:42:02 <Gracenotes> probably with foldr
14:42:03 <iop> > listToMaybe []
14:42:04 <lambdabot>   Nothing
14:42:06 <iop> > listToMaybe [12,3]
14:42:07 <lambdabot>   Just 12
14:42:09 <Gracenotes> or perhaps listToMaybe
14:42:10 <Cale> and not for any other time :)
14:42:13 <Gracenotes> u has pointilism
14:43:34 <Cale> Did people see my funny implementation of fizzbuzz?
14:43:41 <dancor> what would be the most annoying thing about always using listToMaybe and never using head
14:43:58 <dons> mmorrow: why does haskell-src-meta depend on old haskell-src-exts?
14:44:06 <dons> its a pain: i can't build vacuum on arch now from packages.
14:44:31 <Cale> dancor: Sometimes you really want to fail when the result is an empty list, because your assumptions about what you've written would have had to be wrong.
14:44:56 <copumpkin> dons: I noticed the galois twitter username was unused, but it doesn't let people sign up for it (thought you might be interested in claiming it for galois)
14:45:03 <dons> oh, its unused?
14:45:06 <dons> hmm.
14:45:14 <Cale> dancor: head is just a convenient way to say "I want one of these, and I'm assuming/willing to prove that one exists."
14:45:16 <dons> it was in use last we checked..
14:45:26 <dons> huh
14:45:36 <copumpkin> dons: it says the page doesn't exist, but it won't let anyone sign up for it... maybe contact the twitter people to claim it?
14:45:43 <dons> yeah, good idea.
14:46:33 <deech> Hi all, in a State monad if I 'put' a value like ((getIntegerFromFile  "file")+ 1) and I call "get" multiple times is 'getIntegerFromFile "file" run over and over?
14:47:27 <mmorrow> dons: because it translates from the haskell-src-exts AST to the TH one (among other things)
14:47:46 <dons> mmorrow: any chance to support the newer version?
14:47:54 <dons> or should i downgrade haskell-src-exts in Arch?
14:47:54 <Cale> deech: That won't typecheck if it has IO in it.
14:47:55 <mmorrow> dons: although splitting the haskell-src-exts/pure-TH related out into sep pkgs seems nice
14:48:07 <mmorrow> dons: oh, it doesn't work with the current one?
14:48:12 <gwern> @remember BrianWKernighan /* lasciate ogne speranza, voi ch'intrate. */
14:48:13 <Cale> deech: Or else, your State monad has an IO action as its state parameter, in which case it won't get run at all.
14:48:13 <lambdabot> Good to know.
14:48:27 <dons> mmorrow: well, it specifies < 5
14:48:29 <dons> 0.5
14:48:39 <mmorrow> dons: oh. ok, i'll upgrade src-meta
14:48:43 <dons> yay
14:48:46 <gwern> @quoe kernighan
14:48:46 <mmorrow> :)
14:48:46 <lambdabot> No quotes match. Take a stress pill and think things over.
14:48:54 <gwern> @quoe Kernighan
14:48:55 <lambdabot> No quotes match. stty: unknown mode: doofus
14:49:02 <gwern> hm
14:49:08 <gwern> @quote lasciate
14:49:09 <lambdabot> BrianWKernighan says: /* lasciate ogne speranza, voi ch'intrate. */
14:49:11 <Cale> deech: Though, the fact that you're adding 1 to it seems to indicate that it's just a type error.
14:49:21 <Cale> deech: Since IO Integer is not an instance of Num usually.
14:49:21 <gwern> ah, I guess it doesn't do substring on the author
14:50:00 <deech> Cale: I have a function that retrieves and XML document, processes it and puts it in State: put (runX getProcessXML) . This seems to typecheck and work fine.
14:50:15 <deech> Cale: I was trying to use a simpler example, sorry.
14:50:21 <mmorrow> dons: hmm, that's another thing too.. vacuum only uses src-meta for `ppHs', which while convenient and nice, adds like 4MB to the binary size via src-exts.. i think i might drop that dep from vacuum altogether
14:50:53 <Cale> deech: Uhh... runX getProcessXML  would have to have type (IO t), since it does IO.
14:51:14 <Cale> deech: So, I think your answer is that it's not run, but simply held in the state.
14:51:26 <deech> Cale: I just want it so the XML is retrieved and processed only once, so subsequent 'get' don't have to re-run 'runX ...'
14:51:36 <Cale> deech: But this is a very strange thing to do in the first place
14:51:47 <Cale> It's not running runX at all.
14:52:05 <Cale> The only way to run an IO action is from another IO action.
14:52:22 <Cale> and you're not in the IO monad, you're in the State monad, apparently.
14:52:27 <gwern> huh. kernighan thinks that among scripting languages, awk 'gets you the most bang for the buck'
14:52:39 <dancor> hah
14:52:42 <Cale> So IO actions are inert values as far as the State monad is concerned, and will not run.
14:53:17 <Cale> (even in the IO monad, they will not run unless you write something like  v <- runX ..
14:53:20 <Cale> )
14:53:44 <dancor> gwern: well if you talking about bang-for-buck-for-total-noobs, it's all about what you can copy
14:53:54 <dancor> so i would think like js would get you the most bang
14:53:55 <Cale> deech: Does that make sense?
14:54:11 <ehird> dancor: I'm fairly sure Kernighan wouldn't talk about what a newbie would want.
14:54:12 <deech> Cale: Yes, I have my code at http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6126#a6126 and it works.
14:54:38 <dancor> well if we are not talking about total noobs, the statement is clearly false
14:54:57 <dancor> something more general purpose is going to get you a lot more bang..
14:55:16 <Cale> deech: Oh, okay, you're not in the State monad, you're in StateT over IO
14:55:27 <deech> Cale: The process runs when do a 'runStateT (respIsbndb' isbn) mzero'
14:55:32 <Cale> deech: So yeah, there is a way to run an IO action...
14:55:37 <ehird> dancor: the k in awk
14:55:41 <Cale> except...
14:55:44 <ehird> are you surprised?
14:55:46 <sampointon> dancor: from the command line, as far as thoughtless text munging goes, awk is hard to beat
14:56:03 <Cale> deech: Why are you using put and get?
14:56:15 <dancor> maybe the most bang for $1
14:56:16 <gwern> huh. edison dates back to 1998
14:56:21 <deech> Cale: So I can store the result of the 'runX ...' for later use.
14:56:32 <Cale> deech: But you're not storing the result
14:56:32 <gwern> I wonder whether there are any older non-ghc non-base libraries still actively maintained
14:56:41 <Cale> deech: You're storing the action to run itself.
14:56:47 <dons> gwern: example?
14:56:52 <deech> Cale: Yes that's what I was afraid of ... How do I store the result?
14:56:57 <gwern> dons: pardon?
14:56:59 <Cale> By running it first.
14:57:08 <dancor> i really think perl is better than awk for thoughtless text munging and that awk just feels better
14:57:10 <dons> gwern: what were you thinking of? haxml?
14:57:19 <deech> Doesn't
14:57:23 <Cale> v <- liftIO . runX . respIsbndb $ isbn
14:57:25 <dancor> perl takes awk and sed etc and offers consistency
14:57:25 <gwern> dons: yes, but I don't actually know how old haxml is
14:57:27 <Cale> put v
14:57:31 <dons> gwern: a decade.
14:57:41 <dons> gwern: there's a fair few things older than the base split still maintained.
14:57:46 <gwern> so that'd put it at a year younger than edison
14:57:51 <dons> of course, a fair few things that aren't
14:57:59 <dons> gtk2hs is around a decade too.
14:58:01 <deech> Cale: I gettit! Cool!
14:58:03 <dons> x11 is more than that.
14:58:15 <dons> x11 was originally written in greencard
14:58:15 <gwern> wasn't x11 written for xmonad?
14:58:18 <dons> nope
14:58:29 <dons> back to the history books!!!
14:58:30 <deech> Cale: that makes my life a lot easier, thanks!
14:58:34 <Cale> deech: Despite its name, evaluating (runX ...) on its own will not actually cause the action to run
14:58:42 <dons> copyright:	        Alastair Reid, 1999-2003, libraries@haskell.org 2003-2007
14:58:55 <dons> bits of the x11 lib are older still
14:58:58 <Cale> deech: It just evaluates into an IO action which, when executed, will run the action :)
14:59:06 <gwern> dons: oh. so it's just the repo which goes back to 2003
14:59:10 <Cale> (run the XML arrow action)
14:59:20 <dons> gwern: yeah, everytthing was moved out of cvs around then.
14:59:34 <gwern> '97, so x11 is older than edison
14:59:37 <deech> Cale: Yeah the whole lazy thing is taking a *long* time to sink in.
14:59:39 <dons> though you see the occasional pserver:cvs address now and then
14:59:48 * gwern is surprised x11 is so old. I really had thought it was written shortly before xmonad
14:59:48 <Cale> deech: It's not really laziness at this point.
14:59:53 <Cale> deech: It's something separate from that.
14:59:56 <dons> the xinerama parts were
14:59:58 <dons> one module.
15:00:04 <Cale> deech: The fact that we represent IO actions as values.
15:00:13 <Cale> (first class values)
15:00:38 <Cale> So you can pass IO actions around between functions, put them in datastructures and so on, and only when you *really* ask for them to be run will they run.
15:00:39 <ehird> 22:59 gwern is surprised x11 is so old. I really had thought it was written shortly before xmonad
15:00:43 <ehird> Bam! Out of context!
15:01:25 <deech> Cale: I see. Thanks so much! I appreciate the help!
15:01:43 <deech> Got to go.
15:01:48 <Cale> deech: While it's somewhat required that we do this because of lazy evaluation, it would actually be a smart thing to do even if the language was strict :)
15:03:52 <gwern> 'A library like Edison will only be successful if embraced by the community' <-- oops
15:05:30 <ehird> gwern: 22:59 gwern: '97, so x11 is older than edison
15:05:32 <ehird> also out of context!
15:05:58 <gwern> well, everyone knows edison was inspired to invent lightbulbs by the glow of his CRT monitor
15:06:11 <gwern> the vacuum was the crucial breakthrough
15:08:03 <ehird> :-)
15:08:17 <ehird> gwern: but tesla was already using OLEDs!
15:08:36 <gwern> and da vinci was using plastic polymers; discoveries mean nothing if there's no followup
15:09:02 <ehird> gwern: no, tesla used a full OLED 24" monitor
15:09:08 <ehird> with his 4ghz Teslasun workstation
15:09:14 <ehird> (700 cores)
15:09:17 <ehird> that's just how awesome he was.
15:09:40 <gwern> ehird: you misread the articles; he used a Rock, and *rode* around in a tesla
15:10:04 <ehird> tesla invented food
15:10:24 <ehird> can you claim that?
15:10:39 <gwern> sure.
15:10:40 <ehird> exactly
15:10:43 <gwern> I invented food.
15:10:43 <idnar> so hey, Tesla invented wireless power, why don't we have that anymore? :P
15:10:45 <ehird> gwern: but did you invent drink
15:10:56 <gwern> it'd be silly of me to invent food but not drink
15:11:00 <ehird> see before tesla everyone died within days.
15:11:12 <ehird> he really innovated human advance.
15:11:18 <gwern> 'So that was a great mammoth; but I'm thirsty. are you thirsty? it'd be nice if we all weren't thirsty'
15:11:43 <ehird> tesla was a mammoth.
15:12:27 <ehird> a clever mammoth!
15:13:05 <gwern> if he was so clever, why'd we eat'im?
15:13:26 <ehird> because you're plotting with edison.
15:13:44 <ehird> or should I say deadison.
15:15:45 <gwern>  edison: he knows! quick, get westinghouse's 'alternative electro-current' execution device - the need is dire
15:16:40 <FliP^2eH> How do I modify an element in the middle of a list, and keep it in that place?
15:16:51 <FliP^2eH> Using StateT-
15:16:53 <copumpkin> you don't modify anything
15:17:04 <copumpkin> you could map
15:17:11 <FliP^2eH> Hmm
15:17:12 <copumpkin> but you might need to zip it with indices
15:17:15 <sjanssen> you can, however, create a new list with only one item different
15:17:35 <Adamant_> "Nikola Tesla and You" is a great way to improve your Energy Weapon skills with the Comprehension perk
15:17:38 <sjanssen> FliP^2eH: what do you have, an element's index?  An element itself?
15:17:48 <FliP^2eH> map and match by predicate.. that's easy
15:17:54 <FliP^2eH> Get the one I need, that's easy.
15:18:06 <FliP^2eH> But changing it and replacing it by the new modifyed one
15:18:09 <gwern> Adamant_: if it isn't at least a +2, then it isn't worth bothering reducing my sanity index
15:18:11 <FliP^2eH> That's the tough thing
15:18:19 <FliP^2eH> modified*
15:18:32 <sjanssen> right, you can't modify data structures in Haskell
15:18:43 <FliP^2eH> I'm aware of that
15:18:45 <gwern> he did say he was working in State, tho
15:18:58 <gwern> presumably he could get it, do the normal filter, and then set it
15:19:29 <FliP^2eH> I could do it like they do in popular quicksorts
15:19:34 <FliP^2eH> Get the one before my items
15:19:40 <FliP^2eH> And the ones after it, and assemble later
15:21:02 <Cale> > let replaceAt n x xs = ys ++ x : zs where (ys,z:zs) = splitAt n xs in map (\n -> replaceAt n 'b' "hello") [0..4]
15:21:04 <lambdabot>   ["bello","hbllo","heblo","helbo","hellb"]
15:21:05 <gwern> you mean like 'let n = takeWhile foo bar in let m = drop 1 n in n ++ modified ++ m'
15:21:21 <ehird> hebbo
15:21:38 <gwern> lists aren't really meant for random access like that, though
15:23:05 <gwern> (but I'm sure you know that already)
15:23:07 <Cale> Yeah, in quicksort's case, it's reasonably natural, since you're just concatenating the two completely new lists which you got from sorting the elements less and greater than the pivot.
15:23:36 <Cale> But in this case, it certainly seems wasteful to need to do that, since the whole first part of the list is the same, and yet can't be shared.
15:24:16 <FliP^2eH> Should I use arrays?
15:24:22 <Cale> arrays would be worse
15:24:28 <Cale> Then you can't even share the tail
15:24:31 <FliP^2eH> Binary Trees?
15:24:33 <Cale> You could use Data.Sequence
15:24:40 <Cale> Which is internally a tree structure
15:24:51 <Cale> It has log time concatenation and splitting at any point
15:25:11 <Cale> (in fact, log of the size of the smaller piece)
15:25:15 <gwern> Cale: does sequence allow modifying at a random index?
15:25:24 <Cale> gwern: In log time, yes.
15:25:46 <gwern> log sounds better than n
15:25:57 <Cale> Yeah, log time is essentially constant.
15:26:05 <Cale> Since you have a finite amount of memory anyway.
15:26:43 <Cale> and so the thing you're applying the log to is bounded by something reasonably small in logarithmic terms
15:27:19 <Cale> In fact, all accesses to memory are technically at least log time already, but we ignore that.
15:27:33 <Cale> (because it's hidden by hardware :)
15:28:10 <gwern> actually, it's nicer than just log n
15:28:12 <gwern> 'O(log(min(i,n-i))). The element at the specified position, which should be a positive integer less than the size of the sequence. If the position is out of range, index fails with an error. '
15:28:30 <Cale> yeah, I mentioned that
15:28:39 <Peaker> I'd say log times are hidden by the fact we used constant-limited memory sizes
15:28:45 <Cale> (it's log of the size of the smaller piece)
15:28:52 <gwern> I've long thought that data.sequence is probably underused
15:28:52 <Cale> Peaker: well, that too.
15:29:08 <Cale> Data.Sequence is not to be used for things that we normally use lists for though.
15:29:26 <Cale> It's much much slower in terms of constants if you're just iterating over something linearly.
15:29:57 <Cale> (which to be fair is the common case)
15:30:28 <FunctorSal> meh. instanceD should take Q [Dec], not [Q Dec]
15:30:29 <Philonous> Is there material on data structures in a (lazy) functionaly environment?
15:30:42 <FunctorSal> the former being returned by quoted haskell
15:30:44 <Cale> Yes, there's a book and thesis by Okasaki
15:30:53 <gwern> there are probably any number of complex uses of lists that could benefit; we're so used to lists that they're like strings in unix scripting. using a datastructure closer to what you mean has costs just because of the prevalence of regular lazy lists
15:31:15 <Philonous> Oh, ok, I think I've even got that one somewhere
15:32:14 <Cale> The structure which Data.Sequence uses is newer though
15:32:27 <gwern> fingertrees are awfully neat, 'tis true
15:32:39 <copumpkin> armtrees
15:32:41 <FliP^2eH> The thing I need it for, is maintaining a list of channels on my bot, and on topic changes and others, I need to update an existing item, which can be way in the middle of my list
15:32:43 <FliP^2eH> :/
15:32:50 <FliP^2eH> Won't grow big anyways
15:32:52 <Cale> It's called a finger tree, which is like a cleverly modified monoidally-indexed binary tree, which ensures constant-time access to the ends.
15:33:07 <Cale> FliP^2eH: Then the cost of using lists won't really matter.
15:33:21 <gwern> FliP^2eH: why does it need to be a list? sounds like a random set structure would be fine
15:33:32 <FliP^2eH> Would be fine, too
15:33:39 <FliP^2eH> Anything is fine
15:33:41 <Cale> Yeah, Data.Map / Data.Set work well too
15:33:51 <FliP^2eH> I just need to be able to easily modify any item
15:33:57 <Cale> If it's really a Set, I highly encourage using Data.Set
15:34:52 <Peaker> Cale: what does "monoidally-indexed" mean?
15:34:53 <Cale> and there's never really a great excuse for using [(a,b)] when you really want Map a b and are doing lots of indexes.
15:36:31 <Cale> Peaker: Normally, if you were using a binary tree to store a sequence of elements such that you wanted to access a random index quickly, a tactic you might use is to store the size of each tree in the root
15:36:33 <gwern> Cale: hurray for rolling your own?
15:37:01 <Cale> Peaker: That way, you can look at the size and tell which subtree you need to recurse on.
15:38:03 <Cale> Peaker: It's possible to generalise this approach... assigning the leaves of the tree elements in some monoid (with the unit of the monoid being for the empty tree), and then use the monoid operation to combine subtrees
15:38:53 <Philonous> Btw. I love that I can just dive into the source code of any library via the documentation. That really helps in understanding the libs and learning a great deal about design patterns
15:39:22 <gwern> haddock is a not too shabby tool. when it isn't erroring out or regressing...
15:39:53 <Peaker> Cale: what other monoids except addition/size would you like there?
15:40:10 <Peaker> Cale: I mean, why generalize at this dimension, rather than countless other possible generalizations?
15:41:08 <gwern> Peaker: you know, you could read the WP article on fingertrees
15:41:29 <Cale> It turns out that many other data structures, like priority queues, interval trees, and so on, are accessible in this way
15:41:40 <gwern> Peaker: 'Basically, they allow you to write fast implementations for pretty much every abstract data type mentioned in Okasaki's book on purely functional data structures. For example, you can do sequences, priority queues, search trees and priority search queues. Moreover, any fancy and custom data structures like interval trees or something for stock trading are likely to be implementable in this framework as well.'
15:41:47 <gwern> http://apfelmus.nfshost.com/monoid-fingertree.html
15:42:03 <Cale> Suppose we have the monoid:
15:42:04 <gwern> ^ linked from the WP article
15:42:21 <Cale> data Prio a = Infinity | P a
15:42:30 <Cale> instance (Ord a) => Monoid (Prio a)
15:42:35 <Cale>   mempty = Infinity
15:42:47 <Cale>   mappend Infinity b = b
15:42:54 <Cale>   mappend a Infinity = a
15:43:06 <Cale>   mappend (P x) (P y) = P (max x y)
15:43:27 <Peaker> gwern: ah, thanks. I think I had seen that link a few times, but I'm too lazy/overworked each time to read it :-(
15:43:43 <Philonous> I wonder whether it is a good idea to stick bloom filters into those
15:44:15 <Cale> Then the nodes of a monoidal tree of this sort will contain the maximum priority of one of their subtrees.
15:44:24 <gwern> probably not. constructing maybe, but using a bloom filter you want arrays
15:44:26 <hackagebot> vacuum 0.0.95 - Extract graph representations of ghc heap values. (MattMorrow)
15:47:09 <Cale> Or, say we want to have a tree of intervals where it's possible to find an interval which overlaps with a given one in log time, it's possible to construct a monoid which gives that too.
15:48:15 <Cale> Well, stealing from the paper, if we define
15:48:23 <Cale> data Key a = NoKey | Key a
15:48:31 <Cale>   deriving (Eq, Ord)
15:48:36 <Cale> instance Monoid (Key a) where
15:48:42 <Cale>   mempty = NoKey
15:48:51 <Cale>   mappend k NoKey = k
15:49:01 <Cale>   mappend _ k = k
15:49:39 <Philonous> gwern: I meant using a bloom filter as the monoid. That's propably not the worst idea if you have to store the tree on the disc.
15:49:39 <Cale> A tree annotated with this monoid has subtrees annotated with the last key they contain
15:50:11 <gwern> Philonous: oh, you mean seeing the addition of new items into the bloom filter as a monoid? yah, that makes sense. it's not like you can remove items from a bloom filter...
15:51:13 <Cale> If we have the type:
15:51:45 <Cale> data Interval a = Interval { low :: a, high :: a }
15:52:25 <Cale> then we can associate intervals with elements of the monoid (Key a, Prio a), by measure i = (Key (low i), Prio (high i))
15:53:01 <Philonous> gwern: If you annotate your tree with a bloom filter for every node, where the parent is constructed by zipWith (&&) of it's children, you get a tree where you can see in which subtree you have to look for any given item
15:53:34 * gwern wonders whether that is ridiculous or awesome
15:53:36 <Cale> We can store the intervals in the tree, ordered by their low endpoints
15:54:50 <Cale> So then we can tell what the largest low endpoint in a subtree is, and additionally, we're storing the maximum high endpoint in the branches.
15:56:12 <Cale> making use of that information, it's possible to drill through the tree to determine if there's an appropriate interval which overlaps the one we're querying about
15:57:02 <Cale> and it's also easy to find all intervals which overlap a given one, with not much extra complexity
15:57:33 <Cale> (it's O(m log(n/m)) time)
15:57:48 <Cale> (where m is the number of matching intervals)
15:59:02 <Cale> Peaker: does any of that make sense? :)
16:00:41 <Cale> Peaker: Basically, the idea is that no matter what kind of information you might annotate a tree with in order to search through it quickly for information at the leaves which you're interested in, you'll usually need some way to combine information about the subtrees at each branch node
16:02:22 <Cale> The associativity means that the information you're storing does not depend on how the tree is balanced
16:04:06 <Cale> and the identity is used to deal with empty subtrees
16:04:32 <Philonous> So basically you are storing a hash of every subtree, that happens to be composable so it is cheap to - well - compose them?
16:04:50 <Peaker> Cale: was away for a while there, sorry.. Reading back now
16:05:11 <Cale> I wouldn't normally use the word 'hash', because randomness is usually not involved, but some small, easy-to-compare piece of information, yes
16:06:00 <Philonous> With hash I mean the gist of it, the subsummation
16:06:30 <Cale> You have a way to get that piece of information from any value which you store at the leaves, and then the information about subtrees is combined using the monoid operation, and if you end up needing empty subtrees, then the identity for the monoid is used.
16:07:04 <Peaker> Cale: Yeah, I see, thanks :)
16:07:11 <Cale> The associativity comes in because you want the information to be invariant of the way that the tree has happened to be balanced
16:08:14 <Cale> (and in the case of finger trees, it's essential because the "tree" is hardly a tree at all, and the results would be rather confusing if they revealed information about the finger structure)
16:09:20 <Philonous> That's actually so straight forward that I wonder why no one has come up with that before
16:10:49 <Cale> I think the general idea of monoidally labelled trees is not so new, but the finger trees additionally make access to the ends cheap
16:12:42 <sjanssen> Cale: I hadn't seen monoid trees until the finger tree paper
16:13:11 <br1> how do I tell ehc to output the result of intermediate transformations? There was a flag before, but I can't find it now.
16:13:14 <sjanssen> labeled trees are an old idea, but I don't know if anyone realized there was a nice abstraction until that paper
16:20:14 <Cale> sjanssen: That's interesting.
16:21:31 <Cale> (and strange)
16:22:05 <Cale> I wonder how well finger-tree-based priority search queues compare with the PSQueue implementation on Hackage performance-wise.
16:23:16 <Cale> Asymptotically, it gives the same results.
16:23:46 <Cale> I should try it :)
16:23:59 <MyCatVerbs> br1: there's a set of flags that start -ddump. -ddump-simpl is the one you usually want.
16:24:43 <Cale> It is somehow not surprising that finger trees and the priority search queue structure are both care of Ralf Hinze
16:25:21 <Cale> (well, working with other people :)
16:25:49 <MyCatVerbs> br1: if you have libpcre or don't mind installing it, you should probably cabal install ghc-core. It makes reading the GHC Core much more pleasant by colourising it.
16:26:02 <FunctorSalad_> conal: that extended de-bruijn notation in the paper you told be about is really neat
16:26:35 <FunctorSalad_> they made the type for the gfoldE for extended notation unnecessarily weak though...
16:26:56 <FunctorSalad_> fourth arg should have "n a" rather than "a"
16:28:13 <br1> MyCatVerbs: I'm using ehc, not ghc. I tried -ddump anyway, but it didn't work.
16:28:35 <conal> FunctorSalad_: clever stuff, indeed!
16:28:58 <FunctorSalad_> conal: I would never had noticed that you need this extended notation to keep sharing :)
16:29:07 <conal> FunctorSalad_: please send that typing comment to Ross and see what he says.
16:32:05 <conal> FunctorSalad_: i did a variation of that representation for a *typed* lambda calculus for my functional->gpu compiler.  sort of came out, though it got awfully tricky.  eventually, i dropped it.
16:32:39 <FunctorSalad_> conal: what part became tricky?
16:34:54 <conal> first there's choosing a generalization of Incr.  then adding some class constraints i needed for typeability, showability etc. i didn't manage to get gfold's type generalized.  got bogged down.  then that final representation change for sharability.
16:36:07 <conal> FunctorSalad_: and my compilation speed was lousy, and i couldn't figure out how to get helpful information out of profiling (as usual for me) :(.  i was also doing bottom-up purely functional CSE.
16:37:01 <conal> FunctorSalad_: it was a pretty hairy experience wrestling with typing.  i never knew if the next obstacle would defeat me.
16:37:36 <conal> FunctorSalad_: have you read "I am not a number: I am a free variable"?  i haven't.  it looks pretty related.
16:38:00 <defun> @botsnack
16:38:01 <lunabot>  :)
16:38:01 <lambdabot> :)
16:39:40 <sampointon> we need another bot with a lower latency than lunar bot, and whose smiley is indented with two spaces
16:39:40 <FunctorSalad_> conal: no, haven't read that one. I'm having class constraint issues too; did you try a Data constraint and then using gshow and geq?
16:40:03 <conal> FunctorSalad_: no.  i've never played with Data
16:40:10 <sampointon> erm. Lunabot, not 'lunar bot'. In my defence, I have been reading up on the moon landings lately
16:40:15 <FunctorSalad_> it seems to work that way, and I have somewhat complicated types too (a GADT)
16:40:40 <conal> FunctorSalad_: are you making a deep dsel?
16:40:51 <conal> (mine is a gadt also, for static typing)
16:42:14 <FunctorSalad_> conal: here's my expression type, is it similar to what you were doing? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6128#a6128
16:43:53 <conal> FunctorSalad_: yeah.  very similar to what i was using (and am no longer).
16:44:07 <FunctorSalad_> conal: that single Data constraint is enough to get Show,Eq and Ord
16:44:16 <conal> FunctorSalad_: hm.  Quant looks like a constant, and application, and a lambda, all rolled together.
16:44:42 <FunctorSalad_> conal: it stands for "quantifier" :) (data Quant = All | Exists)
16:44:44 <conal> FunctorSalad_: oh??  where's the Data constraint?
16:44:50 <conal> FunctorSalad_: i figured it did.
16:44:51 <FunctorSalad_> conal: in the Ap constructor
16:44:58 <conal> FunctorSalad_: as i said, a constant, an application, and a lambda
16:45:01 <FunctorSalad_> the string is just for printing
16:46:19 <conal> FunctorSalad_: couldn't you use church's encoding of higher-order logic into lambda calculus?
16:46:41 <conal> forall, exists :: (a -> Bool) -> Bool
16:47:20 <FunctorSalad_> conal: the function being in the object language? it's FOL, I don't have first-class functions
16:47:21 <conal> FunctorSalad_: are you avoiding constants?  such as forall, exists, nil, and cons
16:47:58 <conal> FunctorSalad_: oh.  fol.
16:48:00 <FunctorSalad_> conal: yeah, many traversals don't care about the type of constant so it saves a lot of typing to factor them out
16:48:20 <FunctorSalad_> so I put them all in "Logical" and "Quant"
16:49:48 <conal> FunctorSalad_: i'll look into using Data, gshow & geq.  thanks for the tip!
16:50:13 <FunctorSalad_> :)
16:50:26 <conal> FunctorSalad_: your use in Ap is connected to the choice of first-order language, right?
16:52:04 <FunctorSalad_> conal: the ap is currently somewhat of an overkill; the only way functions can get into that position is through the connectives and symbols enumerated in "Logical"
16:53:26 <FunctorSalad_> conal: but don't you need Ap in a higher-order language as well?
16:53:54 <Gracenotes> idle question; why is it called ExistentialQuantification and not ExistentialQualification?
16:54:34 <conal> FunctorSalad_: yeah.  i meant specifically using a Data constraint there.
16:56:05 <FunctorSalad_> conal: the data declaration is like "instance (Data a, Data v) => Data (E a v)", and the "a" in "Ap" is the only variable that doesn't appear in the result type
16:56:13 <conal> FunctorSalad_: eep: gshow (2,3) --> "((,) (2) (3))"
16:56:22 <FunctorSalad_> (the variables appearing in the result type get the "Data" from the Data instance, is what I'm trying to say)
16:56:49 <conal> FunctorSalad_: does (->) have a Data instance?  i'd assumed not.
16:56:57 <conal> (hence the FOL connection)
16:57:21 <FunctorSalad_> conal: IIRC it does, but throws exceptions if you try to do impossible stuff with it
16:57:51 <SamB> FunctorSalad_: I hate that kind of instance :-(
16:58:17 <FunctorSalad_> conal: but I don't have function *values* anywhere in the object language, the "->" is just a typing token actually
16:58:33 <conal> FunctorSalad_: that's what i figured (FOL)
16:58:45 <FunctorSalad_> conal: for example, I have "And:: L (P -> P -> P)" which is included via Logical
16:59:07 <FunctorSalad_> and "FunctionSymbol :: String -> L (TL -> P)" (TL = term list)
16:59:16 <conal> FunctorSalad_: oh, i see.  i take it back then.  i do something similar, but not specific to logic/bool
16:59:36 <conal> FunctorSalad_: because i'm generating code.
16:59:49 <FunctorSalad_> I see. if you have actual function values, show and so on become a problem of course
17:00:01 <gwern> (generating generating generating code; generating code in a dude's backyard)
17:02:24 <FunctorSalad_> SamB: seems to be a neccessary evil if you want to be able to derive Data for types containing functions somewhere..
17:02:46 <SamB> FunctorSalad_: mmm-hmm.
17:03:12 <SamB> well, I wish that classes wouldn't have so many methods that you'd feel the need to do that very often
17:03:42 <SamB> for instance, Bits should at the very least not assume finite width -- it should have a subclass for that
17:04:40 <FunctorSalad_> SamB: the dillemma there was presented nicely in that blog article advocating superclass defaults, don't have the link handy
17:05:08 <SamB> FunctorSalad_: I don't think there *is* a dillemma in the case of Bits
17:05:11 <FunctorSalad_> (the problem with very fine-gained hierarchies is that the user has to know about all the classes)
17:05:16 <SamB> oh.
17:05:34 <FunctorSalad_> yes, one additional class for Bits wouldn't be bad
17:05:42 <SamB> even two wouldn't be too bad
17:05:50 <SamB> if you split out the bitwise boolean stuff
17:06:00 <SamB> because that makes sense in even more cases
17:06:19 <conal> have-to-know-lots-of-classes sounds like a UI problem.
17:06:26 <FunctorSalad_> he used all the levels of specialisation between an ordering and a lattice as an example... it would annoy users who just want lattices, not semisomethings
17:06:33 <mmorrow> woohoo, int-e just fixed vacuumLazy, and it's working-like-you'd-want-it-to in the darcs repo. will upload to hackage shortly.
17:06:40 <shapr> Ooh, I want a semisomething!
17:06:58 <mmorrow> http://moonpatio.com/repos/vacuum/
17:07:03 <FunctorSalad_> :)
17:07:20 <conal> hm.  i meant a more specific remark.  have-to-know-lots-of-classes could be addressed by making class collections easier to browse.  we all win.
17:07:27 <SamB> FunctorSalad_: the really annoying thing is the defaults the fine-grained hierarchy deprives you of
17:07:32 <SamB> but I cant
17:07:51 <SamB> think of any ways it would make sense to split up Bits that have any issues with that
17:08:01 <zeno_> instead of using the applicative parsec module in http://book.realworldhaskell.org/read/using-parsec.html , someone said parsec 3 has this already.  how do i use it?
17:08:07 <conal> SamB: since sub-classes cannot yet provide defaults for superclass method?
17:08:15 <SamB> conal: yeah
17:08:16 <FunctorSalad_> SamB: conal: yeah, I threw together "have to know about the classes" and "have to do superclass defaults manually" here
17:08:23 <SamB> and it hurts our heads to think how that would make sense
17:09:03 <FunctorSalad_> SamB: there are fundamental issues with it?
17:09:08 <FunctorSalad_> didn't know
17:09:26 <SamB> FunctorSalad_: not fundamental
17:09:35 <SamB> but it gets hairy
17:09:38 <FunctorSalad_> "retroinstance Group v => Monoid v where ..."? :)
17:10:17 <SamB> it's basically UI
17:11:53 <SamB> well, and trying to come up with fairly simple algorthms to get methods all pushed out to the resulting instances
17:12:33 <SamB> but that's kinda UI-y too
17:12:49 <SamB> since the user should be able to do the algorithm too
17:12:57 <SamB> to understand what's going on
17:13:01 <SamB> you know?
17:14:24 <FunctorSalad_> SamB: hmm I don't know enough about how instances are handled internally
17:16:19 <SamB> FunctorSalad_: well, I mean, *what* the algorithms do should also be simple, so the user can do that too
17:16:42 <SamB> of course, usually a simple algorithm computes a simple thing
17:16:46 <FunctorSalad_> I see there would be some issues if you suddenly add a module that has an"instance (Functor Foo)" to a module where Foo is a Functor through its Monad instance already
17:18:04 <SamB> FunctorSalad_: well, that's why you probably end up having to have the code indicate clearly to the compiler which classes it must instantiate, even if the user would have to look carefully at docs or :i to figure it out
17:18:07 <Gracenotes> instances and modules interact rather crudely
17:18:38 <SamB> like, maybe you'll have to use different names to instantiate several classes together
17:20:13 <FunctorSalad_> SamB: explicitly specifying the superclasses to default would still be a step forward...
17:20:26 <SamB> FunctorSalad_: or that
17:20:27 <FunctorSalad_> or are there still issues with that?
17:20:37 <BMeph> zeno_: Still here? :)
17:22:51 <SamB> FunctorSalad_: well, there might be more than one possible way to do such defaulting
17:24:22 <FunctorSalad_> SamB: e.g. in a diamond hierarchy, I suppose
17:27:13 <FunctorSalad_> maybe just emit a warning if there are multiple paths and make coherence the users responsibility (at first glance it seems unlikely that someone would come up with an incoherent diamond diagram)
17:27:34 <FunctorSalad_> but maybe I'm thinking of too simple cases
17:31:24 <dmwit> :t (<*>)
17:31:26 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
17:34:11 <SamB> FunctorSalad_: I might not quite understand what you mean
17:34:52 <SamB> but the way I see it, there might even sensibly be more than one scheme to default a superclass defined to work in exactly the same circumstances
17:35:15 <Taggnostr> I'm trying to play with GHCi but I don't remember anymore how it works. when I want to define a function I need to use 'let', but if I use it twice only the first definition is lost, right?
17:35:18 <SamB> maybe such schemse should be named?
17:35:22 <FunctorSalad_> SamB: I thought you meant the problem "A is a superclass of B1 and of B2, and both are superclasses of C, and all these connections have superclass defaults"
17:35:54 <SamB> I haven't actually read this "superclass defaults" proposal or anything
17:35:55 <FunctorSalad_> then a C instance would have two defaulting paths to A, but it seems unlikely that they would be unequal
17:36:35 <SamB> in Coq, it might be good to then have to prove that they are equal
17:36:54 <SamB> well, that would work better if equality in Coq was a little closer to reality
17:37:23 <FunctorSalad_> totally. equality is my major problem with Coq too
17:37:42 <FunctorSalad_> (but maybe I'm just doing it wrong)
17:38:15 <SamB> you're not just doing it wrong
17:38:20 <FunctorSalad_> I hear that the problem with extensional equality is that typechecking is undecidable, but what's the big deal with that?
17:38:47 <FunctorSalad_> is "couldn't typecheck in less than <timeout>" any worse than a type error due to intensional equality?
17:39:07 <SamB> FunctorSalad_: typechecking doesn't just become undecidable the instant you get some, no
17:40:36 <SamB> but I don't think I would much like having the typechecker automatically attempt to decide the undecidable
17:40:46 <monochrom> Taggnostr: Roughly speaking, if you use "let" to define "f" n+1 times, the first n definitions are lost.
17:41:16 <SamB> I might prefer having it simply categorize some things as "don't know" and give you a chance to prove that they are or aren't well-typed
17:41:24 <Peaker> hmm.. iteratee is really similar to Binary.Get (But as a Monad Transformer)
17:41:53 <Taggnostr> monochrom, ok, how can I avoid this (for example if I want to do func 0 = 0; func n = 1)?
17:41:59 * Peaker finally understands iteratees
17:42:13 <Peaker> ok, now I can decide that I don't like them :-)
17:42:17 <monochrom> Use only one let. let {func 0 = 0; func n = 1}
17:42:18 <EvilTerran> Taggnostr, write them on one line like that, with the semicolon
17:42:53 <Taggnostr> ok
17:42:59 <Peaker> if they end up as a monad transformer, they could probably use ErrorT/EitherT for error handling rather than shoving it in the iteratee itself, not to mention that its shoved as a string
17:43:20 <Taggnostr> now I'm trying to play with a program that I wrote long ago, and it seems broken, let me paste it
17:43:26 <SamB> monochrom: the braces aren't needed though, right?
17:43:42 <monochrom> I do not know.
17:43:48 <Taggnostr> what was your favourite pastebin?
17:44:47 <monochrom> Iteratee doesn't just solve the error handling problem.
17:45:18 <Peaker> monochrom: right, but I dislike the ad-hoc nature of its definitions
17:45:19 <Taggnostr> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6130#a6130
17:45:37 <Peaker> monochrom: And I think it could probably be structured better
17:45:45 <Peaker> monochrom: my personal attempt was mlist, but that too is not ideal
17:45:53 * Peaker gotta sleep :(
17:46:39 <Taggnostr> here is my program, it should do prime factorization but it doesn't always work, can it be cleaned up before debugging it?
17:48:12 <BMeph> Taggnostr: What does that last statement mean? :)
17:49:03 <Taggnostr> it should append the factors to a list
17:50:03 <hackagebot> haskell-src-exts 0.5.7 - Manipulating Haskell source: abstract syntax, lexer, parser, and pretty-printer (NiklasBroberg)
17:50:28 <Taggnostr> actually it seems to work fine with small numbers, but I tried with "factors 5564646645164654132" and it returned [2,2,107409293], but 2*2*107409293 = 429637172
17:50:43 <monochrom> Int is small.
17:51:12 <Taggnostr> so it can't handle arbitrary big numbers, right?
17:51:23 <monochrom> use Integer
17:51:29 <Taggnostr> let me try
17:52:51 <Taggnostr> btw, do you have any idea what are those 3 lines at the beginning? they look like comments but I don't know if they have any meaning or if they are just the result of some experiment I was doing and I forgot there
17:52:54 <monochrom> > 5564646645164654132 `mod` (2^31)
17:52:56 <lambdabot>   429637172
17:53:25 <BMeph> Taggnostr: Ah "can it be cleaned up before debugging it" == "would you (help me to) clean it up before debugging it"? :)
17:53:35 <monochrom> If you uncomment them, they will define a user custom data type. Err three data types.
17:53:46 <monochrom> There is nothing to clean up.
17:54:12 <monochrom> Apart from the obsession with "meaningful" identifier names.
17:54:31 <monochrom> Should have written formal specifications instead.
17:54:34 <Taggnostr> with Integer is going better, it found the first 4 factors, but it's taking a while to find the last one
17:55:13 <monochrom> 2 * 2 * 79 * 241 * 73069050963347
17:55:43 <Taggnostr> yes, it's having some problem with 73069050963347
17:56:02 <BMeph> monochrom: I was just going to ask, if you were a believer that "meaningful" names should be placed in accompanying documantation that explains what the program is supposed to do. :)
17:56:05 <monochrom> Your program will take 36534525481673 steps to discover that 73069050963347 is prime.
17:56:53 <Taggnostr> monochrom I know, but that shouldn't take so long
17:58:57 <monochrom> BMeph: There was once in a math channel when we have great fun saying "let f be a group, G be an element of the group, x be a homomorphism..." :)
17:59:24 <monochrom> Assume your computer takes 1 nanosecond to perform each step. 36534525481673 steps will take...
18:00:03 <monochrom> > 36534525481673 / 10^9 / 60 / 60
18:00:05 <lambdabot>   10.148479300464722
18:00:07 <monochrom> 10 hours.
18:00:26 <BMeph> monochrom: Silly rabbit! There's no time in maths! Just like there are no gurlZ on teh intarwebZ! ;p
18:00:34 <Taggnostr> 10 hours? the same thing takes 13 seconds in python
18:01:43 <QtPlaty[HireMe]> Could not find module `Control.Monad.Identity': it was found in multiple packag\
18:01:47 <QtPlaty[HireMe]> es: transformers-0.1.4.0 mtl-1.1.0.2
18:01:56 <monochrom> Kill one of them.
18:02:03 <dmwit> > (sqrt 73069050963347, 73069050963347 `div` 2)
18:02:05 <lambdabot>   (8548043.69217583,36534525481673)
18:02:06 <QtPlaty[HireMe]> monochrom: How?
18:02:17 <dmwit> Taggnostr: Do those two numbers look any different to you? ;-)
18:02:34 * BMeph recommends a .50 caliber rifle with a 10x scope.
18:03:04 <Taggnostr> dmwit, I think you just found the problem
18:03:20 <monochrom> Lies, Damn Lies, and Programmers.
18:04:06 <dmwit> Not bad for never even having seen the code.
18:04:06 <Pseudonym> Lies, Damn Lies and Benchmarks.
18:04:07 <monochrom> 8548043 steps at 1 microsecond per step would be just 8.5 seconds.
18:04:22 <Taggnostr> well, I wrote them both months ago, I didn't remember that I worked some more to the python version
18:04:24 * BMeph has complete belief in the honesty of .50 cal bullets.
18:04:41 <dmwit> A microsecond is longish in computer-land.
18:05:04 <Pseudonym> It depends what you're measuring.
18:05:11 <dmwit> of course
18:05:17 <Pseudonym> If it's asymptotic complexity, microseconds are good units.
18:05:21 <monochrom> Probably just right for the python interpreter on most computers. I mean 8.5 and 13 are somewhat close.
18:05:27 <dmwit> A microsecond is longish for a mod operation in computer-land.
18:05:33 <Pseudonym> Yes, true.
18:05:41 <Taggnostr> if I use sqrt I get a float, how can i convert it to int?
18:05:48 <dmwit> :t ceiling
18:05:50 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
18:05:54 <tommd> :t floor
18:05:56 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
18:05:56 <dmwit> And floor, round, etc.
18:05:59 <monochrom> ceiling is probably the safest.
18:06:04 <Taggnostr> ok
18:06:11 <Pseudonym> Taggnostr: Do you want the integer square root of an integer?
18:06:21 <monochrom> I am too lazy to prove that floor will work.
18:06:36 <Taggnostr> Pseudonym, yes
18:06:46 <Pseudonym> http://andrew.bromage.org/darcs/numbertheory/Math/Util.hs
18:06:54 <dmwit> monochrom: Even if it works, it saves you at best numFactors mod operations.
18:06:58 <Taggnostr> monochrom, one more division wouldn't change anything
18:07:00 <dmwit> monochrom: That's not much...
18:07:27 <Pseudonym> That's optimised for large Integers, but will still do the job.
18:07:38 <BMeph> Say, is there a function that tells the number of bits it would take to represent an Integral (i.e., log 2 by "direct" shifting, not an actual log function)? :)
18:07:51 <s11d> could anyone please tell me why foldl ($) (,,) [0..2] is wrong?
18:08:01 <Pseudonym> BMeph: Why don't you work in log-space?
18:08:39 <monochrom> Wrong types.
18:08:46 <dmwit> s11d: Because ($) takes two different types in the fold.
18:09:09 <dmwit> s11d: Consider the type of ($) in (,,) $ 0 $ 1 $ 2 -- here, it takes three different types.
18:09:37 <monochrom> (,,) has one type, (,,)$0 has another, (,,)$0$1 has yet another.
18:09:56 <dmwit> Let's do ((,) $ 0 $ 1) instead, it's simpler and has the same problem.
18:10:04 <monochrom> Before you apply equational reasoning you should first check ypes.
18:10:30 <s11d> oh I see. thanks
18:10:36 <dmwit> The first ($) has type (Int -> Int -> (Int, Int)) -> (Int -> INt -> (Int, Int)); the second ($) has type (Int -> (Int, Int)) -> (Int -> (Int, Int))
18:10:38 <BMeph> Pseudonyms: Because I want to "exploit" the binary representation of the number, especially if it's too big for whatever type you're using for log functions. :)
18:10:39 <dmwit> ok =)
18:11:03 <BMeph> Er, Pseudonym, not Pseudonyms. :)
18:11:09 <Taggnostr> but now sqrt doesn't work with Integer, how can I fix that?
18:11:12 <Gracenotes> @type flip id
18:11:13 <lambdabot> forall b c. b -> (b -> c) -> c
18:11:21 <dmwit> :t bitSize -- BMeph
18:11:22 <lambdabot> forall a. (Bits a) => a -> Int
18:11:43 <dmwit> I don't think there's anything better than that.
18:11:45 <Gracenotes> floor . sqrt . fromIntegral $ x
18:11:48 <dmwit> (I know it's not quite what you're asking for.)
18:11:58 <Gracenotes> unfortunately needs conversion
18:12:05 * Cale implements priority search queues in terms of finger trees.
18:12:12 <BMeph> dmwit: Keep reading, bitSize "Return the number of bits in the type of the argument" I want the bits in the value, not the bits in the value's type. :)
18:12:21 <dmwit> BMeph: Yes, I know.
18:12:28 <Taggnostr> Gracenotes, not it compile, thanks
18:12:28 <dmwit> BMeph: I'm telling you this is the closest we have.
18:12:34 <Taggnostr> let's see if it works too
18:12:48 <dmwit> Taggnostr: Why not just use the Util.hs that Pseudonym linked to?  Don't re-invent wheels. ;-)
18:13:38 <dmwit> Pseudonym: Is that on hackage, by the way?
18:14:20 <Pseudonym> I didn't put it there.
18:14:25 <Taggnostr> dmwit, I'm just playing around and trying to understand how it works, reinventing wheels is a good way to do it
18:14:47 <Pseudonym> I don't even know if the Cabal stuff works or not.
18:14:52 <dmwit> Pseudonym: You should. =)
18:15:21 <Taggnostr> it works fine now, and it takes 13 seconds too
18:15:40 <dmwit> 13 seconds in ghci = 0.5 seconds when compiled ;-)
18:15:59 <Taggnostr> that is the next thing I was going to ask
18:17:10 <BMeph> Taggnostr: I don't believe him; I think you should compile it anyway, and see how fast it Really is... ;p
18:17:16 <Taggnostr> ghci said "compiling main" when I loaded the module, did it actually compiled the program somewhere (on a temp dir or in memory) or is it still interpreting the original source?
18:17:36 <BMeph> dmwit: (Note the "I'm just joshing smilie, please? ;p)
18:18:15 <Cale> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6131#a6131 -- whee
18:18:20 <monochrom> when ghci says "compiling" it only means some bytecode of its own.
18:18:35 <Cale> That has to be the simplest implementation of a priority search queue ever ;)
18:18:46 <SamB> Taggnostr: so, yes and no, and in-memory
18:19:30 <Taggnostr> ok, how can I compile it then?
18:19:48 <Cale> Taggnostr: run ghc on it
18:19:51 <Axman6> ghc --make file.hs
18:20:14 <Taggnostr> ok, thanks
18:20:24 <dmwit> ghc --make -O2 file.hs
18:20:50 * Axman6 is typing with his pinkies,so left out optimisation
18:22:02 <Taggnostr> it says factors.hs:1:0: The function `main' is not defined in module `Main'
18:22:19 <dmwit> try
18:22:25 <dmwit> main = print (factor someBigNumber)
18:22:51 <dmwit> Substituting my placeholders "factor" and "someBigNumber", of course. ;-)
18:22:58 <Cale> oops, type of range was a little off :)
18:23:49 <Taggnostr> ok, now it took 3 seconds :)
18:25:47 <Taggnostr> let's see if I can make a loop that asks the user to insert numbers
18:26:41 <Axman6> try interact
18:26:45 <Axman6> :t interact
18:26:47 <lambdabot> (String -> String) -> IO ()
18:27:14 <Axman6> main = interact (show . yourFunc . read)
18:28:22 <mmorrow> @type fix (\again accum -> do l <- getLine; case l of ":q" -> return (reverse accum); _ -> print l >> again (l:accum))
18:28:23 <lambdabot> [String] -> IO [String]
18:28:28 <mmorrow> @type fix (\again accum -> do l <- getLine; case l of ":q" -> return (reverse accum); _ -> print l >> again (l:accum)) []
18:28:29 <lambdabot> IO [String]
18:28:42 <Taggnostr> I did http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6130#a6133
18:29:26 <Axman6> why print l?
18:30:38 <mmorrow> @type \eval env -> fix (\again env -> do l <- getLine; case l of ":q" -> return env; _ -> do (x,env') <- eval env l; again env') env
18:30:39 <lambdabot> forall b t. (b -> String -> IO (t, b)) -> b -> IO b
18:30:46 <mmorrow> err
18:30:56 <mmorrow> @type \eval env -> fix (\again env -> do l <- getLine; case l of ":q" -> return env; _ -> do (x,env') <- eval env l; print x; again env') env
18:30:57 <lambdabot> forall b t. (Show t) => (b -> String -> IO (t, b)) -> b -> IO b
18:31:02 <mmorrow> insta-repl
18:31:15 <Gracenotes> nos :X?
18:31:39 <mmorrow> it'd be handier if eval got the cc
18:32:06 <mmorrow> @type \eval env -> fix (\again env -> do l <- getLine; eval env l again) env
18:32:07 <lambdabot> forall t b. (t -> String -> (t -> IO b) -> IO b) -> t -> IO b
18:34:37 <mmorrow> @let repl = (\eval env -> fix (\again env -> do l <- getLine; case l of ":q" -> return env; _ -> do (x,env') <- eval env l; print x; again env') env) :: (env -> String -> (env -> IO res) -> IO res) -> env -> IO res
18:34:38 <lambdabot>  Couldn't match expected type `IO env'
18:35:07 <mmorrow> wut
18:35:52 <mmorrow> ih
18:35:54 <mmorrow> oh
18:36:18 <mmorrow> @let repl = (\eval env -> fix (\again env -> do l <- getLine; eval env l again) env) :: (env -> String -> (env -> IO res) -> IO res) -> env -> IO res
18:36:20 <lambdabot>  Defined.
18:36:23 <mmorrow> @type repl
18:36:25 <lambdabot> forall env res. (env -> String -> (env -> IO res) -> IO res) -> env -> IO res
18:37:09 <Associat0r> can haskell do exhaustiveness checking for pattern matches at compile time?
18:37:33 <BMeph> @faq can haskell do exhaustiveness checking for pattern matches at compile time?
18:37:33 <lambdabot> The answer is: Yes! Haskell can do that.
18:37:38 <BMeph> LOL
18:37:53 <aavogt> -Wall does it
18:38:00 <Associat0r> ok thanks
18:38:20 <djahandarie> @faq can lambdabot reply anything other than yes?
18:38:20 <lambdabot> The answer is: Yes! Haskell can do that.
18:38:24 <djahandarie> -_-
18:38:26 <aavogt> on ghc at least
18:38:29 <mmorrow> @type repl (\hist cmd k -> case cmd of ":q" -> return (reverse hist); _ -> System.Cmd.system cmd >>= print >> k (cmd:hist)) []
18:38:31 <lambdabot> IO [String]
18:38:39 <Taggnostr> I guess it can also create so/dll that can be used from other places, right?
18:41:18 <mmorrow> Associat0r: -Wall should turn it on (if it's not on by default?)
18:41:27 <mmorrow> ah, too late
18:41:46 <Associat0r> mmorrow:  and how in ghci?
18:42:01 <jimmyjazz14> Anyone working on a better haskell emacs mode?
18:42:11 <mmorrow>  :set -Wall
18:42:14 <mmorrow> in ghci
18:43:00 <FunctorSalad_> jimmyjazz14: in particular it would be cook if someone unbroke the "insert type signature here" command ;)
18:43:12 <FunctorSalad_> broke for me with 6.10.2 or 3
18:43:12 <Associat0r> mmorrow:
18:43:14 <Associat0r> thanks
18:43:19 <FunctorSalad_> s/cook/cool
18:43:19 <mmorrow> :)
18:43:54 <jimmyjazz14> I would just like indentation to work right
18:44:02 <Taggnostr> I found http://www.haskell.org/ghc/docs/latest/html/users_guide/win32-dlls.html but it looks quite complicated
18:44:57 <FunctorSalad_> (it prints the sig in the minibuffer, but claims "no sig found" because it misparses somehow)
18:46:23 <zeno_> BMeph: im back
18:46:38 <zeno_> re parsec applicative
18:47:40 <BMeph> zeno_: Okay. I don't have an answer, but if you ask again now, you might be heard by someone who will. :)
18:49:01 <BMeph> [17:07] <zeno_> instead of using the applicative parsec module in http://book.realworldhaskell.org/read/using-parsec.html , someone saidparsec 3 has this already.  how do i use it?
18:49:35 <Taggnostr> how can I read the argv?
18:50:13 <aavogt> @type System.Environment.getArgs
18:50:14 <lambdabot> IO [String]
18:51:58 <Associat0r> Can haskell bring amiga back?
18:52:26 <Associat0r> now lambdabot doesn't respond
18:52:53 <sjanssen> @faq can Haskell bring sexy back?
18:52:53 <lambdabot> The answer is: Yes! Haskell can do that.
18:53:02 <Associat0r> @faq can haskell do this
18:53:03 <lambdabot> The answer is: Yes! Haskell can do that.
18:53:13 <Associat0r> I forgot @faq
18:54:52 <Taggnostr> how do I convert a string to int?
18:57:07 <copumpkin> :t read
18:57:09 <lambdabot> forall a. (Read a) => String -> a
18:57:10 <aavogt> > read "12"
18:57:11 <lambdabot>   * Exception: Prelude.read: no parse
18:57:16 <aavogt> > read "12" :: Int
18:57:17 <lambdabot>   12
18:58:23 <Taggnostr> I'm trying to do n <- System.Environment.getArgs
18:59:44 <BMeph> Taggnostr: And, what's stopping you is...you keep forgetting that that makes n into a [String]? ;)
19:01:36 <Taggnostr> the problem apparently is that the IO [String] doesn't work with read
19:05:02 <sjanssen> Taggnostr: do x <- getArgs; let n = read x -- closer, but not quite
19:05:31 <sjanssen> Taggnostr: getArgs returns a list of strings, read takes one string, what should we do?
19:05:48 <Taggnostr> something like n = read . head $ args, right?
19:06:04 <sjanssen> sure, that works
19:06:30 <sjanssen> and we might put that into one statement: n <- fmap (read . head) getArgs
19:06:57 <Taggnostr> actually is not working, parse error on .
19:07:08 <Taggnostr> let me play with it some more
19:07:14 <sjanssen> Taggnostr: you forgot a 'let'?
19:07:39 <Taggnostr> I'm not from ghci
19:12:31 <Taggnostr> uhm
19:13:16 <Taggnostr> I keep getting the same error even if I removed the . and commented the code, the 5 and 30 in factors.hs:5:30: are line and column?
19:13:28 <dmwit> right
19:13:33 <sjanssen> Taggnostr: paste the whole thing
19:13:55 <Taggnostr> does it start the count from the first line (including comments and everything)?
19:14:10 <sjanssen> Taggnostr: comments are included, the first line is line 1
19:14:30 <Taggnostr> ok, find the problem
19:14:40 <Taggnostr> there was indeed an extra .
19:16:05 <Associat0r> mmorrow:  how do I unset a cmdline flag in ghci?
19:17:09 <dmwit> :set
19:17:26 <dmwit> i.e. :set -fno-monomorphism-restriction or :set -fmonomorphism-restriction
19:18:11 <Taggnostr> when I do args <- getArgs, is args a normal list of strings, or is it a list of IO strings?
19:18:53 <mike-burns> Normal list.
19:18:55 <dmwit> it is an IO list of strings, but temporarily unwrapped for your pleasure
19:19:18 <sjanssen> Taggnostr: in the context of the statements below args has type [String]
19:19:36 <sjanssen> note that the statements below must also be in IO
19:19:38 <Associat0r> dmwit:  I am trying to unset -Wall
19:19:53 <sjanssen> Associat0r: there's also :unset, IIRC
19:20:15 <sjanssen> and -Wnone or -Woff or something like that
19:20:43 <Associat0r> it can't unset it
19:20:46 <sjanssen> oh, it might be '-wall'
19:20:46 <Taggnostr> if in the next line I put "n = read (head args) :: Integer" it gives a parse error on the '=', if I use <- instead it complains about the type (IO t vs Integer)
19:20:50 <Associat0r> because it's a cmdline flag
19:20:56 <sjanssen> Taggnostr: you need to use let
19:21:13 <mike-burns> Taggnostr: let n = read (head args) :: Integer
19:21:29 <Taggnostr> now it works, thanks
19:21:35 <Associat0r> *Test> :unset -Wall
19:21:35 <Associat0r> can't unset GHC command-line flags
19:22:16 <Associat0r> -Woff and -Wnone also doesn't work
19:22:55 <dmwit> Just start ghci again, then.
19:23:11 <Taggnostr> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6130#a6135 is it ok now?
19:23:15 <SamB_XP> Associat0r: feel free to report a ticket
19:24:55 <Taggnostr> hpaste should use some url rewrite
19:25:14 <Taggnostr> does the author of hpaste happen to be here?
19:27:14 <mmorrow> Associat0r: :unset
19:27:24 <mmorrow> Associat0r: :? is "help"ful
19:27:25 <mmorrow> :)
19:27:48 <mmorrow> Associat0r: ah, yeah some flags you can't revert
19:30:34 <Taggnostr> when I do import foo, does it imports all the names defined in foo?
19:30:55 <dmwit> No, only the names exported by foo.
19:31:47 <Taggnostr> and with import foo (bar, baz), do I import only bar and baz?
19:31:55 <dmwit> Correct.
19:32:02 <dmwit> orr... not quite correct
19:32:12 <dmwit> That imports bar, baz, foo.bar, and foo.baz.
19:32:59 <Taggnostr> is there a way to import only foo.bar and foo.baz or only foo (if I do import foo)?
19:34:44 <dmwit> import qualified
19:34:45 <jmcarthur> import qualified
19:34:52 <jmcarthur> yeah that
19:35:23 <Taggnostr> ok
19:36:44 <Taggnostr> if I have the name of a function as a string, how can I get the function?
19:37:13 <dmwit> You can't.
19:37:26 <dmwit> If you want that, you have to build yourself some kind of mapping manually.
19:37:33 <dmwit> f "foo" = foo; f "bar" = bar
19:37:43 <Taggnostr> ok
19:37:55 <dmwit> or functionMap = fromList [("foo", foo), ("bar", bar)]
19:37:58 <dmwit> or whatever
19:38:34 <Taggnostr> :t fromList
19:38:35 <lambdabot> Not in scope: `fromList'
19:38:41 <dmwit> :t M.fromList
19:38:42 <lambdabot> forall k a. (Ord k) => [(k, a)] -> M.Map k a
19:40:26 <booboo1a> Which is better for a newbie to learn, haskell or ocaml?
19:41:24 <dmwit> Obviously Haskell.
19:41:38 <Taggnostr> I don't know ocaml but I'm learning Haskell tonight
19:42:19 <bombshelter13p_> Taggnostr: the whole thing?
19:42:22 <booboo1a> thats a tall order
19:43:02 <Taggnostr> bombshelter13p_, actually I'm just playing around and checking if I remember what I studied some time ago
19:43:41 <araujo> booboo1a, haskell!
19:44:05 <araujo> @faq can haskell beat any language to start learning programming?
19:44:06 <lambdabot> The answer is: Yes! Haskell can do that.
19:44:24 <booboo1a> lol
19:44:33 <Twey> booboo1a: Scheme, if you ask me.
19:44:58 <Twey> Come back to Haskell when you understand the fundamentals and want to start writing real programs.  :)
19:45:20 <Taggnostr> hey Twey
19:45:36 <Twey> o/ Taggnostr
19:45:57 <Twey> oノシ
19:46:03 <Taggnostr> I'm putting some Haskell in Svadilfari
19:46:09 <Twey> Interesting
19:46:28 <Taggnostr> yep
19:46:41 <shachaf> @faq Can Haskell fail miserably if you make a tiny mistake?
19:46:42 <lambdabot> The answer is: Yes! Haskell can do that.
19:46:44 <Taggnostr> and it's all Dareena's fault
19:48:06 <Twey> shachaf: The key is, it fails at compile-time ;)
19:48:22 <shachaf> @faq Can Haskell silently corrupt your data at run-time?
19:48:22 <lambdabot> The answer is: Yes! Haskell can do that.
19:49:06 <aavogt> @faq Can Haskell fail shachaf's worst expectations?
19:49:07 <lambdabot> The answer is: Yes! Haskell can do that.
19:49:13 <Adamant_> @faq Can Haskell raise the Dread Lord Cthulu from his watery grave?
19:49:14 <lambdabot> The answer is: Yes! Haskell can do that.
19:49:20 <Twey> Hahaha
19:49:29 <Twey> Taggnostr: Dareena's?  Why's that?
19:49:56 <shachaf> @faq Can Haskell generate a program so complicated that even Haskell couldn't type-check it?
19:49:57 <lambdabot> The answer is: Yes! Haskell can do that.
19:50:09 <Taggnostr> I compiled factors.hs and now I have factors.hi, factors.o and factors, what are those?
19:50:13 <Twey> shachaf: Of course it can
19:50:18 <Twey> That's easy :-P
19:50:25 <shachaf> @faq Could Haskell then type-check that program?
19:50:25 <lambdabot> The answer is: Yes! Haskell can do that.
19:50:38 <shachaf> Taggnostr: See `man ghc`.
19:50:44 <aavogt> @faq
19:50:44 <lambdabot> The answer is: Yes! Haskell can do that.
19:50:48 <pchiusan> hello
19:50:55 <pchiusan> @seen conal
19:50:56 <lambdabot> conal is in #haskell-blah, #haskell-iphone, #haskell, #ghc and #haskell-in-depth. I last heard conal speak 2h 42m 48s ago.
19:50:58 <Twey> Taggnostr: factors is the executable, factors.hi is the interface (stores the types in case you want to link against it) and factors.o is the intermediate object code used in building
19:51:39 <m3ga> @seen arjanoosting
19:51:40 <lambdabot> arjanoosting is in #haskell.dut and #haskell. I don't know when arjanoosting last spoke.
19:51:47 <pchiusan> conal, you around?
19:52:17 <pchiusan> we need to figure out the One True Definition for RT :)
19:53:16 <Taggnostr> Twey, we were talking about programming and I said her to learn python, she said she's lazy, so I said her to learn haskell, I linked her a tutorial and I ended up reading it and playing with haskell for the whole night
19:53:49 <mike-burns> #haskell-blah ?
19:54:27 <Tsion> import Data.List as L.I.S.T
19:54:28 <Tsion> main = putStrLn $ L.I.S.T.intersperse ',' "abcde"
19:54:35 <Tsion> That's interesting :P
19:55:48 <monochrom> import Control.Monad as System.IO
19:55:59 <mike-burns> Hah.
19:56:02 <Tsion> Haha :)
19:56:36 <monochrom> import GHC.Prim as Prelude
20:00:57 <conal> pchiusan: i'm here
20:01:50 <conal> pchiusan: were you just looking at my recent blog comments?
20:02:10 <Twey> Taggnostr: Oh, right :-D
20:04:29 <BMeph> Warning: Haskell is known to be extremely addictive and habit-forming - use at you own risk! ;p
20:11:50 <Taggnostr> Twey, it works :)
20:23:54 <Taggnostr> how can I interrupt via code a function if it's still working after 10 seconds?
20:24:18 <dmwit> killThread
20:24:35 <Taggnostr> do I have to run the function in a thread?
20:24:58 <dmwit> What kind of non-threaded interface do you propose for such a thing...?
20:25:38 <Taggnostr> I'm not so familiar with threads
20:26:35 <roconnor> tuple tupple
20:27:53 <Twey> Tuple tipple — alcohol made from distilled pairs
20:27:59 <SamB_XP> Taggnostr: it gets worse :-(
20:28:15 <Twey> SamB_XP: System.Timeout
20:28:18 <Twey> Er, Taggnostr
20:28:20 <SamB_XP> GHC might never manage to stop the first thread
20:28:22 <SamB_XP> :-(
20:28:36 <SamB_XP> in certain instances
20:28:45 <SamB_XP> when it doesn't do any allocation but loops forever
20:28:49 <Twey> System.Timeout can, right?
20:28:56 <SamB_XP> Twey: nope!
20:29:01 <SamB_XP> it's rather a bug
20:29:29 <Twey> Oh >.<
20:29:36 <Twey> But that's fairly uncommon?
20:29:44 <SamB> fairly
20:30:00 <Twey> So Taggnostr should'n
20:30:05 <Twey> shouldn't be worrying about it
20:30:12 <Taggnostr> uhm
20:30:17 <gwern> oh, it's uncommon
20:30:23 <gwern> if you aren't evaluating malicious code
20:30:39 * gwern coughs*mueval*cough
20:30:50 <Taggnostr> assuming that I know what my programs does, could it work?
20:31:02 <SamB> Taggnostr: yeah
20:31:03 <Twey> Heh
20:31:14 <SamB> you can make sure not to run code that won't terminate or allocate ;-)
20:31:29 <Twey> Taggnostr: Just using System.Timeout
20:31:33 <Twey> s/using/use/
20:31:36 <gwern> SamB: hm, rewrite fragments to make them do allocation?
20:31:44 <Twey> If you experience problems, *then* start worrying about it :-P
20:31:46 <physique> tony morris is...
20:31:48 <gwern> that'd be interesting. I wonder how/whether one could do that
20:31:55 <Taggnostr> I want to use it for my factors program
20:32:11 <Taggnostr> if it can't find the factors in 10 seconds I want it to abort
20:32:15 <gwern> short of implementing a haskell interpreter which at every step does some allocation
20:32:24 <SamB> gwern: or replace bottoming-out, non-allocating code with undefined ;-P
20:32:24 <physique> tony morris is...masquerading as a logician...
20:32:51 <Twey> How so?
20:34:08 <ryant5000> is there any way to *partially* specify the type of something? maybe with existential qualification? e.g.: suppose i have a function Blah -> b, and b is inferable, but I don't want to bother typing it out
20:34:38 <SamB> ryant5000: no :-(
20:34:40 <SamB> sorry
20:34:49 <SamB> I've wished for that too
20:35:01 <monochrom> You can hire me to type it out. $100 per byte. UTF-8 encoding.
20:35:06 <Twey> Haha
20:35:12 <ryant5000> lol
20:35:22 <Twey> If you're using haskell-mode, just infer, then yank and modify
20:35:30 <Taggnostr> monochrom, I suggest utf-32 then
20:35:43 <ryant5000> well, i'm trying to avoid the necessity of propagating type constraints up to the top level of the call chain
20:35:53 <gwern> (for 800 a character, I'd rather buy a high-class prostitute for an hour. or 8 low class prostitutes)
20:36:11 <Twey> ryant5000: You can always just enforce type constraints on a specific argument
20:36:30 <Twey> genericDouble n = (n :: Double) * 2
20:36:32 <monochrom> Well, I am a high-class coding prostitute.
20:36:42 <SamB> gwern: what character is 8 bytes long in UTF-8 ?
20:36:47 <Taggnostr> monochrom, if you are payed per byte, writing code in utf-8 or ascii wouldn't be any difference
20:36:49 <Twey> No character
20:36:53 <SamB> ur UCS-4, even!
20:37:01 <Twey> No character :)
20:37:03 <Taggnostr> utf-8 is 1 to 4 bytes
20:37:11 <Twey> UCS-4 is 4 bytes, UTF-8 is 1-4
20:37:12 <Taggnostr> utf-32 is always 4 bytes
20:37:16 <gwern> oh, monochrom said byte, not bit. oops
20:37:18 <SamB> some variants of UTF-8 can go higher than four
20:37:21 <ryant5000> well, what i'm trying to accomplish is an extensible internationalization system
20:37:26 <ryant5000> so i'd like something like this:
20:37:32 <gwern> SamB: my variant goes to 11
20:37:39 <Twey> Taggnostr: I'm reliably informed that we ought to call that UCS-4, since UTF- is for variable-size encodings
20:37:56 <ryant5000> class Utterance language phrase where utter :: language -> phrase -> String
20:38:03 <SamB> > ord (maxBound :: Char)
20:38:05 <lambdabot>   1114111
20:38:16 <SamB> > showHex (ord (maxBound :: Char)) ""
20:38:16 <Taggnostr> I thought that UCS-2/4 were obsolete and we should use UTF-16/32 instead
20:38:17 <lambdabot>   "10ffff"
20:38:32 <SamB> Taggnostr: UCS-4 is the same thing as UTF-32
20:38:37 <Twey> Right
20:38:45 <Twey> It's purely a nomenclature issue
20:38:45 <Taggnostr> that's the highest codepoint available so far
20:38:52 <SamB> UCS-2 is a supposedly obsolete subset of UTF-16
20:38:55 <Twey> Taggnostr: The highest codepoint in Unicode
20:38:58 <SamB> Taggnostr: so far?
20:39:04 <SamB> they're not going to add a higher one!
20:39:10 <Taggnostr> are you sure?
20:39:11 <SamB> not in Unicode, anyway
20:39:17 <Twey> UCS-2 is a fixed-width two-byte character system, so it can't encode all of Unicode
20:39:18 <SamB> they swore it
20:39:19 <Taggnostr> check unicode.org
20:39:40 <SamB> I'm pretty sure they've picked something ridiculously low like that, yes
20:39:47 <Twey> So they deprecated it for UTF-16, which is also mostly two-byte, but allows longer sequences
20:39:55 <Taggnostr> http://unicode.org/roadmaps/tip/
20:40:01 <ryant5000> so, the point of the Utterance class is that I'd like to be able to statically verify that there's a translation for each phrase to each language it's being used with
20:40:02 <Taggnostr> 00030000-000317FF Oracle Bone Script
20:40:06 <SamB> Twey: but also rather nasty
20:40:15 * BMeph cyber-reaches, and cranks up gwern's variant
20:40:24 <gwern> unicode's complexity never fails to amaze me
20:40:43 <Twey> Somewhat, yes
20:40:48 <Taggnostr> there's also #unicode if you want
20:41:00 <SamB> > chr 0x317FF <= maxBound
20:41:01 <gwern> or rather I should say that humanity's perversity/genius for inventing symbols never fails to amaze me?
20:41:02 <lambdabot>   True
20:41:30 <Taggnostr> SamB, indeed
20:41:47 <SamB> gwern: what bothers me is that they don't standardize the character widths for terminals at all
20:41:50 <Taggnostr> I always fail to parse codepoints
20:41:59 <monochrom> You can embed types inside expressions.
20:42:34 <SamB> monochrom: but it'd still be oh-so-sweet to be able to just stick _ in where you don't want to bother typing a sub-type-expression
20:42:45 <monochrom> There is a small complication if you want to do that polymorphically, but there is a small solution too --- scoped type variables, the "forall".
20:42:52 <Taggnostr> since we group thousands in groups of 3 digits and codepoints are in groups of 4
20:44:50 <ryant5000> monochrom: well, i want to do it a bit polymorphically
20:45:01 <ryant5000> monochrom: i'll have a lot of "phrase combinators"
20:45:25 <Twey> gwern: And yet it still can't encode Ilakš's script!
20:45:37 <SamB> Twey, Taggnostr: the bug I referred to earlier is documented here: http://hackage.haskell.org/trac/ghc/ticket/367
20:48:28 <Taggnostr> SamB, I think I'll go out for some jogging now, when (if) I come back I'll try to experiment some more with it
20:50:46 <nainaide> why I can not  # :k  Control.Monad.liftM
20:51:04 <nainaide> > :t Control.Monad.liftM
20:51:06 <lambdabot>   <no location info>: parse error on input `:'
20:51:18 <nainaide> >:t Control.Monad.liftM
20:51:39 <BMeph> :t Control.Monad.liftM
20:51:40 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
20:51:52 <nainaide> :k Control.Monad.liftM
20:51:53 <lambdabot> parse error on input `Control.Monad.liftM'
20:52:15 <nainaide> :t Int
20:52:17 <lambdabot> Not in scope: data constructor `Int'
20:52:26 <nainaide> :k Int
20:52:27 <lambdabot> *
20:53:11 <nainaide> :k Maybe
20:53:12 <lambdabot> * -> *
20:54:01 <mle> :k Either
20:54:03 <lambdabot> * -> * -> *
21:04:54 <dmwit> > ord maxBound
21:04:55 <lambdabot>   1114111
21:04:59 <dmwit> > chr 1114112
21:05:01 <lambdabot>   * Exception: Prelude.chr: bad argument
21:05:11 <dmwit> > showHex 1114111 ""
21:05:12 <nainaide> Does UML suit for Haskell?
21:05:13 <lambdabot>   "10ffff"
21:05:27 <dmwit> UML doesn't suit for anything.
21:05:40 <dmwit> s/anything/any language/
21:06:40 <jmcarthur> especially for haskell, though
21:07:05 <nainaide> If I want to develop a program in haskell,  what else other than UML ?
21:07:25 <nainaide> I think UML is only for OOP
21:07:48 <jmcarthur> UML should never be a design tool. If anything, it's for documentation.
21:07:57 <dmwit> If you want to develop a program in Haskell, why not develop it in Haskell?
21:08:16 <jmcarthur> well, never in the cases i can think of, to be fair, but i think it's a bad idea
21:08:26 <nainaide> : P,
21:09:02 <jmcarthur> anyway, the way one typically designs a program in haskell is by composition. create small parts, then use them to create bigger parts
21:09:25 <jmcarthur> it sounds like a naive, high-level way to explain it, but that really is the best advice i can give
21:09:56 <jmcarthur> the simpler your parts, the better, usually
21:10:10 <jmcarthur> simpler semantics, that is
21:10:11 <nainaide> jmcarthur, at least I should have data dictionary
21:10:28 <jmcarthur> nainaide: you mean like Data.Map?
21:10:49 <jmcarthur> perhaps i misunderstand
21:11:46 <nainaide> noj, I would have some documents on all kind of data type I defined, and something about data stream direction.
21:12:20 <jmcarthur> nainaide: we have haddock to generate documentation from special markup in the comments of the code
21:12:58 <nainaide>  haddock?
21:12:59 <jmcarthur> nainaide: and as for data flow diagrams (i think that's what you are hinting at), i don't think that's really a good fit for haskell
21:14:06 <nainaide> jmcarthur, that's the what I want to konw, if data flow doesn't fit, then how
21:15:04 <jmcarthur> nainaide: for example, in haskell i might compose several functions together: f . g . h ... one could say that the data "flows" from one function to the next, but what i actually did there is create a *new* function. data flow is really irrelevant
21:15:43 <nainaide> jmcarthur, yeah!
21:16:04 <dmwit> Maybe you should make something small before you dream about which tools would be good for designing something big.
21:16:07 <pchiusan> hi
21:16:28 <dmwit> Howdy, pchiusan.
21:16:38 <pchiusan> hi dmwit
21:16:39 <jmcarthur> nainaide: the big things really just fall into place once you understand the small things
21:16:54 <nainaide> jmcarthur, sure.
21:16:55 <jmcarthur> well, the medium things, anyway
21:17:02 <pchiusan> conal, you around?
21:17:10 <pchiusan> @seen conal
21:17:11 <lambdabot> conal is in #haskell-blah, #haskell-iphone, #haskell, #ghc and #haskell-in-depth. I last heard conal speak 1h 5m 18s ago.
21:17:13 <dmwit> nainaide: What have you got in mind to build?
21:17:21 <jmcarthur> pchiusan: i think he already popped in when you asked last time ;)
21:17:46 <pchiusan> jmcarthur: yeah, I saw that... like a hour later :)
21:17:55 <pchiusan> like two ships passing in the night
21:18:05 <nainaide> Is there any document on how to design a program on haskell?
21:18:11 <dmwit> Yes!
21:18:20 <dmwit> http://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program
21:18:29 <nainaide> dmwit, thank you!
21:19:05 <jmcarthur> eek, the only thing that page has about program structure is a link to something about monad transformers
21:19:49 <dmwit> Yeah, that's not so much a good "design" guide as it is a good guide to the typical tools in a Haskell buildchain.
21:19:52 <jmcarthur> there are really quite a few different approaches to writing haskell programs. i wonder if it would be worth it to try to document a few of them
21:20:34 <nainaide> jmcarthur, yes, of course
21:20:57 <Cale> Yeah, that's a bit scary.
21:21:26 <jmcarthur> nainaide: the thing is, it's mostly an acquired skill anyway. you can take after somebody else's style after you have seen enough of it, but there aren't really many "rules" to follow
21:21:29 <Cale> Monad transformers are a good way to construct certain types of library, but I'm hesitant to recommend them for ordinary programs.
21:21:59 <dmwit> I challenge you to write a large program without every once using a monad transformer.
21:22:03 <nainaide> jmcarthur, yeah, :P
21:22:04 <jmcarthur> Cale: i would certainly recommend them for ordinary programs, but a monad transformer is only one way to compose types!
21:22:21 <dmwit> s/every/ever/ of course
21:22:30 <Cale> dmwit: Sure. Normal functional programming idioms work :)
21:23:05 <nainaide> anyway, I can start from http://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program
21:23:10 <Cale> I feel that perhaps I have a somewhat high tolerance for explicit parameter passing.
21:23:18 <dmwit> The biggest Haskell projects I know of are GHC, xmonad, and pugs.  I already know xmonad uses mtl; I'm almost certain GHC uses mtl; and pugs probably does, too.
21:23:29 <dmwit> mmm... darcs
21:23:46 <dmwit> I have no knowledge of darcs' source.
21:24:01 <jmcarthur> i've been digging into category-extras a lot lately. i love the whole idea of using type composition to create desired behavior. it seems to still be a rather uncommon approach outside of monad transformers so far, though
21:24:20 <copumpkin> I like it
21:24:29 <dmwit> I should have a look through category-extras some day.  It's just such a big library, I hardly know where to start.
21:24:41 <Cale> I usually avoid transforming the IO monad, since it always seems excessive to me.
21:24:41 <jmcarthur> yeah, and it has big words
21:25:00 <Cale> But StateT over list is kind of cool :)
21:25:29 <jmcarthur> i'm still lost in it, but now that i dove in i am feeling a slightly more mild version of what i felt once haskell started clicking for me
21:25:36 <jmcarthur> like this is how programming, eventually, should be
21:25:39 <copumpkin> there's very little documentation
21:25:45 <jmcarthur> i don't think haskell is quite right for this, though
21:25:50 <copumpkin> it'll say things like "This is a prepromorphism"
21:25:52 <copumpkin> uhh, ok :)
21:25:53 <jmcarthur> we need better language-level support for it
21:25:58 <copumpkin> I agree
21:26:26 <copumpkin> {-# LANGUAGE LoadsaMorphisms #-}
21:26:45 <dmwit> Hey!
21:26:49 <ryant5000> is "lift" free at runtime?
21:26:53 <dmwit> There's no such thing as a "destroymorphism"!
21:27:05 <dmwit> ryant5000: No, but it's pretty cheap.
21:27:09 <jmcarthur> ryant5000: maybe, maybe not
21:27:11 <dmwit> ...usually
21:27:11 <nainaide> haskell is still on the niche?
21:27:20 <jmcarthur> it could be free if it's just a newtype
21:27:48 <dmwit> Monad transformers are not so often just a newtype, are they?
21:27:53 <jmcarthur> nainaide: niche, but growing. even accelerating, i think
21:28:10 <jmcarthur> dmwit: no, not usually, but perhaps it could be
21:28:19 <dmwit> I mean... Identity is pretty much the only one with a free lift, I would think.
21:28:26 <dmwit> IdentityT, of course.
21:28:50 <ryant5000> hm; intuitively, it seems like StateT should be able to be optimized away
21:28:58 <jmcarthur> dmwit: well, these nicely fusing continuation style monad transformer libraries might have free lift
21:29:01 <ryant5000> not the whole monad trasformer, i mean
21:29:04 <ryant5000> just the lift through it
21:29:46 <jmcarthur> they are probably mostly newtypes, too
21:29:52 <jmcarthur> but i'm not sure
21:29:55 <dmwit> ryant5000: Generally the lift is pretty cheap.  Construction of a lambda or wrap in a single constructor.
21:30:20 <lpsmith> ryant5000:   depends,  especially whether or not "lift" gets inlined.
21:30:30 <lpsmith> My suggestion is to read ghc-core
21:30:55 <ryant5000> hm
21:31:07 <jmcarthur> always fun reading
21:31:21 <lpsmith> it takes some effort, but it's not too bad.    There are still a few things I've been meaning to dig in deeper,  wading through some serious ghc-core
21:31:31 <ryant5000> another thing: does the nesting order of monad transformers matter, usually?
21:31:34 <ryant5000> (or ever?)
21:31:39 <dmwit> yes
21:31:45 <dmwit> it can
21:31:52 <lpsmith> definitely, yes
21:31:59 <ryant5000> how so?
21:32:09 <ryant5000> obviously, it changes the number of lifts required to access each layer
21:32:19 <dmwit> No, it can be more fundamental than that.
21:32:25 <dmwit> Compare:
21:32:26 <ryant5000> hm
21:32:31 <dmwit> ?unmtl StateT s Maybe a
21:32:31 <lambdabot> s -> Maybe (a, s)
21:32:39 <dmwit> ?unmtl MaybeT (State s) a
21:32:39 <lambdabot> s -> (Maybe a, s)
21:33:21 <ryant5000> ah, righto
21:33:24 <dmwit> That's one example, but in general there's no reason to expect monad transformers to commute.
21:33:35 <ryant5000> hmm
21:33:50 <ryant5000> it seems like when they *can* commute, it would be useful to have a generic way of indexing them
21:33:57 <jmcarthur> indexing?
21:34:06 <lpsmith> I don't like monad transformers
21:34:10 <ryant5000> well, there seems to be a syntactic upper bound on using monad transformers
21:34:17 <ryant5000> especially using identical monad transformers
21:34:30 <jmcarthur> the idea is that you use monad transformers to create new types
21:34:39 <jmcarthur> so the stack should be abstracted away, ideally
21:34:41 <lpsmith> monad transformers are not robust abstractions.
21:34:51 <ryant5000> e.g.: even if it "made sense" to someone to use 40 nested StateTs, they wouldn't be able to do it because of the sheer annoyance of the many required lifts
21:34:52 <jmcarthur> then you can always add more to that type without clashing
21:34:54 <dmwit> If you've got a lot of lifts in your code, you're doing it wrong. ;-)
21:35:03 <jmcarthur> you abstract those lifts away ;)
21:35:13 <ryant5000> yeah, that makes sense, i guess
21:35:24 <jmcarthur> also, if you have 40 nested StateTs, you're doing it wrong ;)
21:35:31 <dmwit> hehe
21:35:33 <ryant5000> haha, i know that
21:35:33 <copumpkin> one for each variable, right? :P
21:35:43 <copumpkin> dammit, I think I've been doing it wrong all this time :(
21:35:44 <lpsmith> jmcarthur:  you beat me to it :)
21:35:48 <lpsmith> at that point, use ST
21:35:56 <jmcarthur> @unmtl StateT a (StateT b (StateT c (StateT d))) e
21:35:57 <lambdabot> err: `StateT d (e, a, b, c)' is not applied to enough arguments.
21:36:17 <dmwit> @unmtl StateT a (StateT b (StateT c (StateT d Identity))) e
21:36:17 <lambdabot> a -> b -> c -> d -> (e, a, b, c, d)
21:36:32 <dmwit> I don't believe that.
21:36:33 <jmcarthur> woops
21:36:37 <ryant5000> i'm not suggesting it's a good idea, i just want to provide programmers with as much flexibility as reasonable
21:36:54 <jmcarthur> yeah, there was some magic going on there
21:36:55 <dmwit> (e, (a, (b, (c, d)))) -- more likely
21:37:04 <lpsmith> indeed
21:37:20 <jmcarthur> lpsmith: why do you say transformers aren't robust?
21:37:32 <lpsmith> One of my favorite examples
21:37:39 <lpsmith> Compare
21:37:56 <ryant5000> oh, what do you guys think of HeteroMap?
21:38:04 <lpsmith> StateT e Identity,  to StateT e Cont
21:38:08 <lpsmith> Different semantics
21:38:15 <lpsmith> One's result is lazy
21:38:18 <lpsmith> The other is not.
21:38:23 <ryant5000> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hetero-map
21:38:33 <lpsmith> Adding "cont" changes the underlying semantics
21:38:45 <lpsmith> Another example
21:38:51 <copumpkin> homomap?
21:38:57 <jmcarthur> i would think adding any monad to a stack should change the semantics...
21:39:01 <ryant5000> haha, well, i have nothing against homomaps
21:39:12 <ryant5000> and i certainly support `union`ing them
21:39:13 <lpsmith> no
21:39:25 <BMeph> copumpkin: Please, I believe the PC term is "FlamerMap". ;p
21:39:26 <lpsmith> The problem is that you aren't just adding semantics
21:39:38 <lpsmith> you are fundamentally changing the way the StateT works
21:39:43 <ryant5000> but i thought hetero-map was a pretty cool use of the type system
21:39:49 <jmcarthur> regardless, i definitely agree that transformers are not the only form of type composition somebody should know
21:40:00 <ryant5000> it statically guarantees the presence of its keys, e.g.
21:40:01 <jmcarthur> oh you do have a point, i suppose
21:40:14 <lpsmith> Another example:   if you want to enforce the linear use of a data structure,  you can wrap it in a State monad
21:40:30 <ryant5000> (which is a feature i'd really like in homomaps as well :P)
21:41:06 <jmcarthur> Data.Map is HomoMap?
21:41:08 <lpsmith> However that doesn't work if you wrap the structure in a StateT
21:41:11 <ryant5000> jmcarthur: yeah
21:41:17 <ryant5000> it's got homogeneous values :P
21:41:25 <jmcarthur> awesome, now i must always do import Data.Map as HomoMap
21:41:32 <ryant5000> whereas heteromap only has (kinda, not really) homogeneous keys
21:41:32 <copumpkin> lol
21:41:38 <lpsmith> Consider the monads you can pass as an argument to StateT and be able to use state non-linearly
21:41:38 <BMeph> Map E Coyote - Hetero-geneous! ;p
21:41:53 <copumpkin> how does heteromap get an ordering between heterogeneous keys?
21:42:18 <copumpkin> or is it just heterogeneous values?
21:42:18 <lpsmith> Or,   my favorite darn near pathological example
21:42:23 <lpsmith> A corecursive queue transformer
21:42:43 <ryant5000> the keys are only heterogeneous in an index type used to statically prove their presence in a given map
21:42:44 <lpsmith> Just plain doesn't work for most possible monadic arguments,  or doesn't work transparently
21:42:57 <jmcarthur> there is more than one kind of monad composition, fortunately
21:43:11 <ryant5000> also, the keys don't hold values; they're generated by the map itself
21:43:12 <jmcarthur> the unfortunate thing is that they haven't been embraced as transformers have :(
21:43:20 <copumpkin> I bet beethoven would've been very good at it
21:43:31 <ryant5000> (actually, they might just be a newtype of ())
21:44:10 <lpsmith> jmcarthur:  do you have anything in particular in mind?
21:44:34 <jmcarthur> nah, just generally, although i could link to a few in category-extras
21:44:55 <jmcarthur> but even they are incomplete
21:44:59 <lpsmith> heh,  I haven't played around with category extras much
21:45:02 <jmcarthur> the monad instances for the compositions are incomplete
21:45:18 <lpsmith> Yeah,  I haven't explored alternatives very broadly,  or any particular one in much depth
21:45:34 <jmcarthur> TypeCompose mentions a couple in the comments, too, but doesn't have any of the instances either
21:45:45 <lpsmith> http://okmij.org/ftp/Haskell/ShiftResetGenuine.hs
21:45:49 <jmcarthur> they do exist, i promise!
21:46:13 <lpsmith> That seems to be a promising alternative,  maybe.   I don't really know what I mean by that yet though ;-)
21:46:59 <jmcarthur> alternative to monads, you mean?
21:47:05 <jmcarthur> well, to the kind we have right now
21:47:55 <jmcarthur> indexed monads are very cool
21:48:02 <lpsmith> Well, maybe.  More importantly,  alternative to monad transformers
21:48:37 <lpsmith> I've worked up a few more advanced examples using that code as a starting point, but I haven't played with that in particular for a few months
21:48:49 <jmcarthur> wait, there's monad composition in there? i'm not noticing it
21:48:49 <lpsmith> Though I'm sure I have enough to write a paper about it
21:49:31 <lpsmith> heh,  well,  composition might not be the right word,  and I don't know how to do something transformer-like with it exactly
21:49:48 <lpsmith> but it feels right,  I think with some thought you can do something like it better
21:50:05 <lpsmith> the nice thing is that you can mix and match monads easier.
21:50:33 <jmcarthur> lpsmith: i'm thinking composition in the sense of, e.g. (Maybe :. State s :. [])
21:50:35 <jmcarthur> or whatever
21:51:35 <jmcarthur> with appropriate type class instances to derive Monad and whatever else from that
21:51:51 <jmcarthur> it will be nice once such things have more polish
21:53:25 <jmcarthur> i believe category-extras even includes some composition rules for bifunctors and stuff, things that even parameterized monads could possibly benefit from
21:53:36 <lpsmith> lol
21:53:52 <jmcarthur> lol?
21:53:58 <lpsmith> Somebody needs to write a category theory tutorial using category-extras.
21:54:35 <jmcarthur> lpsmith: http://comonad.com/reader/ :P
21:54:35 <lpsmith> My understanding of category theory is kind of shallow,  despite some of the things I've done. :-)
21:54:57 <jmcarthur> mine is, too. i don't understand the vast majority of what i see in category-extras
21:54:59 <lpsmith> Oh,  I know,  I follow edwardk's blog :)
21:55:01 <jmcarthur> i accept most of it as magic
21:56:03 <lpsmith> I could write a monad tutorial,  but not of the burrito variety.
21:56:12 <lpsmith> I've been thinking about it
21:56:31 <lpsmith> More of an advanced monad tutorial,  with several examples of the most interesting monads I know
21:56:46 <jmcarthur> i think the world has plenty of those :P
21:56:57 <jmcarthur> monads are scary enough without all these tutorials!
21:57:07 <jmcarthur> ;)
21:57:08 <lpsmith> No,  most of the examples I see in the tutorials are pretty boring
21:57:21 <jmcarthur> i agree
21:57:32 <lpsmith> they iterate the MTL for the most part
21:57:41 <jmcarthur> but then again, whenever i explain something like the reader monad to an imperative programmer he thinks it sounds crazy cool
21:57:58 <jmcarthur> even though it's really one of the simplest
21:58:52 <lpsmith> heh
21:58:56 <jmcarthur> although sometimes i have to take some extra time to explain why it's different and better than a global variable
21:59:16 <jmcarthur> s/different/different from/
22:01:00 <jmcarthur> i think what's lacking from most monad and monad transformer tutorials is a good explanation of the fact that you are supposed to make new types from monads, not just always use the mtl stuff raw
22:01:26 <jmcarthur> the most common complaint i see is about having to use lift all the time
22:01:38 <lpsmith> Actually,  what I have in mind probably wouldn't be that useful as a tutorial;  you'd probably want to be fairly comfortable with monads.
22:04:57 <lpsmith> And all three examples I have in mind make essential use of Continuations.
22:05:17 <lpsmith> which you don't see in monad tutorials much
22:10:46 <mriou> I'm trying to make this point-free but somehow the solution is eluding me: (\acc e -> e + shift acc 8)
22:11:07 <mriou> I'm sure there's a simple solution though
22:11:13 <copumpkin> dibblego: how do you feel about scala vs. haskell?
22:11:22 <aavogt> @pl        , lowerOnStart = True
22:11:22 <lambdabot> (line 1, column 1):
22:11:22 <lambdabot> unexpected ","
22:11:22 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
22:11:32 <aavogt> @pl \acc e -> e + shift acc 8
22:11:33 <lambdabot> (+) . flip shift 8
22:12:32 <mriou> :t (+) . flip shift 8
22:12:34 <lambdabot> forall a. (Bits a) => a -> a -> a
22:14:16 <mriou> aavogt strange, I had it this way too but for some reason I can't use it in a foldl
22:14:38 <mriou> :t foldl ((+) . flip shift $ 8)  . map chr . split '.'
22:14:39 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a
22:14:39 <lambdabot>     Probable cause: `$' is applied to too many arguments
22:14:39 <lambdabot>     In the first argument of `foldl', namely `((+) . flip shift $ 8)'
22:14:42 <lpsmith> >  ((+) . flip shift 8)   3 10
22:14:43 <lambdabot>   Add a type signature
22:15:09 <mriou> :t foldl ((+) . flip shift 8)  . map chr . split '.'
22:15:10 <lambdabot>     Couldn't match expected type `a -> [Int]'
22:15:11 <lambdabot>            against inferred type `(Char, Char)'
22:15:11 <lambdabot>     In the second argument of `(.)', namely `split '.''
22:15:24 <mriou> silly me, bad $
22:15:38 <lpsmith> mriou:  remove the $ and add another argument to foldl,  or use foldl1
22:15:59 <lpsmith> :t foldl
22:16:01 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
22:16:04 <lpsmith> :t foldl1
22:16:05 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
22:16:10 <mriou> lpsmith: yeah, it was the $, sorry my paste was actually partial
22:16:32 <mriou> I was just being a bit stupid
22:16:39 <mriou> thanks for the help!
22:24:01 <Gracenotes> ..foldlol1
23:14:13 <ryant5000> is there an instance of Random whose split is both fast and known to be decent?
23:14:32 <ryant5000> (i guess i need the whole thing to be pretty fast, actually)
23:15:19 <ryant5000> sorry, instance of RandomGen
23:22:36 <opqdonut> ryant5000: afaik there is really no research on splitting prngs
23:22:39 <mmorrow> ryant5000: apparently there's some trouble with splitting the mersenne twister (i have no idea what), but it's super fast
23:22:55 <opqdonut> but of course that only affects cryptography and other serious applications
23:24:00 <ryant5000> yeah, i'm doing fractal terrain generation; i don't think i have too much to worry about :P
23:24:10 <ryant5000> i was just wondering
23:43:20 <Taggnostr> SamB, Twey, System.Timeout seems to work fine
23:57:10 <Guest47479> anybody has Raymond Smullyan - To Mock a Mockingbird ebook? 0_0
23:58:17 <Zao> Anybody has topical discussion not involving piracy_
23:59:20 <Adamant_> what about pirates using Haskell in their piracy? I mean the ones with parrots and swords, or RPG's and AK's.
