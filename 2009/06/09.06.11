00:00:31 <dhun> Is this lib open source by the way?
00:01:19 <dhun> ok if I can download the source it obviously is
00:10:20 <dhun> its BSD to be precise
00:10:38 <dhun> building cable from source
00:17:22 <dhun> can not compile Text
00:17:39 <dhun> so falling back to none unicode version
00:18:05 <pumpkin_> ?
00:18:28 <dhun> I don't have Data.Text and I don't manage to get it
00:19:04 <pumpkin_> you used cabal-install?
00:19:44 <dhun> I compiled cabal, and I got a file "Setup"
00:20:08 <dhun> but I don't know what to do with it
00:20:20 <pumpkin_> that counts as "cannot compile"? :)
00:20:37 <dhun> no I tryed manually
00:20:45 <dhun> Data/Text/Encoding/Error.hs:87:9:
00:20:45 <dhun>     Type constructor `Exception' used as a class
00:20:45 <dhun>     In the instance declaration for `Exception UnicodeException'
00:20:45 <dhun> debian:/home/dirk/text-0.3#
00:21:01 <pumpkin_> you're on ghc 6.8?
00:21:15 <dhun> The Glorious Glasgow Haskell Compilation System, version 6.8.2
00:22:11 <pumpkin_> maybe that package needs a base > 3 constraint on it
00:23:24 <dhun> ?
00:23:43 <pumpkin_> basically, I think your compiler is too old for it
00:23:56 <pumpkin_> it's a relatively new package and seems to expect things that have changed since your version
00:24:02 <dhun> maybe
00:24:36 <dons> Galois is hiring Haskell programmers: http://www.haskell.org/pipermail/haskell/2009-June/021401.html
00:24:51 <pumpkin_> oh my
00:24:55 <dhun> well I wrote my own toUpperCase function now, and i can implement it to use Data.Text later on
00:25:12 <dhun> for now I get the right result
00:25:50 <pumpkin_> dammit, I wanna work for galois
00:31:22 <QtPlaty[HireMe]> If you go   data Foo = Foo { bar :: Int; baz :: Int }
00:32:47 <QtPlaty[HireMe]> And have gone on to define foo = Foo {bar = 0;baz = 0}
00:33:28 <QtPlaty[HireMe]> Is there any function/sytnax that allows be to return foo' where foo' is foo but with bar=1?
00:39:07 <cizra> QtPlaty[HireMe]: Shouldn't be difficult to write?
00:39:37 <QtPlaty[HireMe]> cizra: Yeah but I don't wish to write half a dozen of them.
00:39:54 <cizra> *nod* I see. I don't know, though.
00:39:58 * QtPlaty[HireMe] thinks he has found out how to do it.
00:40:17 <QtPlaty[HireMe]> foo' = foo { bar = 1}
00:55:26 <ivanm> rather quite tonight...
00:55:31 <ivanm> *quiet
00:56:05 * QtPlaty[HireMe] nods.
00:56:17 <pumpkin_> shh, I'm hunting bunny wabbits
00:56:23 <ivanm> QtPlaty[HireMe]: still no work?
00:59:04 <QtPlaty[HireMe]> Still nothing on the funtime scope.
00:59:38 <ivanm> what does that have to do with work?
01:01:49 <QtPlaty[HireMe]> fulltime
01:02:05 <QtPlaty[HireMe]> Sorry type.
01:02:10 <ivanm> ahhh, so "n" == "ll"? :p
01:02:37 <ivanm> well, I know of a sysadmin job here in Brisbane, which probabaly doesn't help you... >_>
01:04:35 <QtPlaty[HireMe]> ivanm: I live in brisbane.
01:04:47 <ivanm> but do you want a sysadmin job?
01:04:54 <ivanm> I thought you were after a programming one...
01:05:23 <QtPlaty[HireMe]> ivanm: I'm after a programing one, but in this economy I'm willing to go back to systems administration.
01:06:25 * ivanm goes to look for the ad
01:09:07 <ivanm> QtPlaty[HireMe]: http://www.uq.edu.au/jobs/index.html?page=110931&pid=11218
01:09:28 <ivanm> if you get that, you'll be replacing me...
01:09:44 * ivanm is doing a casual job to replace someone that transferred at the end of last year
01:11:14 <QtPlaty[HireMe]> ivanm: Thankyou.
01:11:23 <ivanm> no worries
01:11:34 <ivanm> btw, have you heard about the brisbane functional programming group?
01:11:36 <dhun> I got a funny problem what I feel to need is globale integer that I can read and write
01:11:50 <jthing> I am annoyin my nabors with tecno
01:11:53 <ivanm> dhun: you don't
01:12:03 <ivanm> jthing: and you're telling us that _why_?
01:12:06 <jthing> seems I like GOA
01:12:11 <dhun> Well I am walking on a tree
01:12:25 <dhun> and I am making string
01:12:32 <jthing> Iv'e discovered satanism
01:12:39 <dibblego> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5765#a5765 why is this more strict than I'd like?
01:12:58 <ivanm> dhun: if all else fails, there's the State monad...
01:13:02 <jthing> anyhow how is the wold lisp?
01:13:30 <dhun> and if I find something special, I must write integer to that string and increment it by one
01:13:39 <ivanm> jthing: why don't you ask on #lisp?  you're in that channel...
01:13:52 <ivanm> seeing as how lisp /= haskell and all...
01:14:04 <jthing> lol
01:15:17 <jthing> I love both what can I say (I'm a bigamist)
01:15:36 <ivanm> no, my point was that you asked (if I understand it) how is lisp
01:15:41 <ivanm> and this isn't #lisp
01:16:20 <jthing> No, I 've studied lsip for 10 years now
01:16:46 <jthing> and I am quite aware of what lisp is ivanm
01:16:58 <ivanm> <jthing> anyhow how is the wold lisp?
01:17:05 <ivanm> ^^ I was referring to this comment of yours
01:17:28 <jthing> I am looking for CUDA support
01:17:44 <jthing> not finding it I am writing it
01:17:54 <quicksilver> jthing: keep to the topic please
01:17:59 <jthing> THATS the lisp way..
01:18:02 * pumpkin_ is confused
01:18:21 <jthing> what topic?
01:18:26 <quicksilver> jthing: haskell.
01:18:51 <jthing> opps, wrong group
01:18:55 <pumpkin_> lol
01:19:41 <ivanm> jthing: yeah, that's what I was trying to tell you all along...
01:20:57 <dhun> I found a way to do it
01:20:58 <earthy> hm. I love my new job. I get to play with Haskell, and Barendregt just greeted me by name.
01:22:21 <fergie> Does anyone know of a library for doing statistical tests? I'm particularly interested in the G-Test
01:24:33 <earthy> you could generate R code to perform it and call R...
01:25:04 <earthy> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/statistics-fusion also exists
01:25:16 <fergie> I've no experience with R. Is it easy to learn?
01:25:38 <earthy> fergie: no clue. it's just the first thing that pops to mind. :)
01:26:11 <fergie> using statistics-fusion will make things a bit easier I think but it doesn't have quite what I'm looking for
01:26:26 <earthy> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/probability may help
01:27:56 <fergie> Yeah, I think that will be useful. Thanks earthy
01:30:44 <Berengal> Boo yeah!
01:30:56 <Berengal> first part of the puzzle, solved!
01:31:31 <Berengal> Sometimes I feel really smart...
01:32:25 <cizra> Berengal: Puzzle? What? Where? Gimme!
01:32:56 <Berengal> cizra: I'm trying to make a map that can be indexed by several indexes
01:33:30 <Berengal> Something like 'lookupBy :: (Eq k) => (v -> k) -> k -> [v] -> Maybe v, except using maps
01:33:38 <Berengal> So it'll be efficient
01:34:55 <cizra> Hmmm.
01:35:02 <Berengal> I might just have gotten the preliminary types correct: createMap  ∷ (indexList ~ FuncFrom value (FuncRet indexList), List indexList) ⇒ indexList →  (MultiIndexMap value, FuncTo Int (FuncRet indexList))
01:35:44 <cizra> What weird characters.
01:38:20 <Berengal> I'll probably have to figure out a way to make the returned lookup functions only able to look stuff up in the returned map, or maps derived from it...
01:49:27 <jeffwheeler> Man, I have been playing with C# for a few days, and hadn't used Haskell in, maybe a week or two before that, and I really forgot why Haskell was so beautiful.
01:49:36 <jeffwheeler> It just makes so much sense . . .
01:49:56 * jeffwheeler is happy.
01:51:38 * QtPlaty[HireMe] compiles his BNF using jeffwheeler 
01:51:49 <jeffwheeler> :P
01:52:02 <jeffwheeler> If only Happy really could use plain BNF.
01:53:00 <anders^^> mhmm
02:04:13 --- mode: irc.freenode.net set +o ChanServ
02:10:13 --- mode: irc.freenode.net set +o ChanServ
02:11:15 <dhun> can I split a list in parts that contain 3 items at most like "abcdefgh"->["abc","def","gh"]
02:12:17 <QtPlaty[HireMe]> yes
02:12:53 <mauke> > unfoldr (\xs -> if null xs then Nothing else Just $ splitAt 3 xs) "abcdefgh"
02:12:54 <lambdabot>   ["abc","def","gh"]
02:13:05 <dhun> ok thank you
02:13:36 <QtPlaty[HireMe]> :t unfoldr
02:13:38 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
02:13:40 <mux> > unfoldr (\xs -> guard (not (null xs)) >> return (splitAt 3 xs)) "abcdefgh"
02:13:41 <lambdabot>   ["abc","def","gh"]
02:14:11 <Cale> > map (take 3) . takeWhile (not . null) . iterate (drop 3) $ "abcdefgh"
02:14:12 <lambdabot>   ["abc","def","gh"]
02:14:31 * mux likes Cale's version
02:16:11 <couloir> this is a pretty active community here, how long before haskell takes over the world?
02:16:35 <mux> haskell's motto is "avoid success at all costs"
02:16:50 <Cale> I was about to say, it depends on how many of us actually want that ;)
02:16:59 <couloir> heh
02:17:16 <mux> how am I going to look cool in front of other programmers if everyone does haskell?
02:17:32 <couloir> well, i doubt many vb.net people will convert
02:17:42 <Cale> Small number of users -> easier to change the language -> awesome language to be kept secret from others :)
02:17:53 <dibblego> haskell took over yesterday -- we are sending out the emails now
02:18:00 <mux> damn, noone told me!
02:18:31 <couloir> i hear of all of these ambitious projects created with haskell
02:18:31 <dibblego> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5765#a5765 why does this print bar?
02:18:38 <couloir> national security stuff and so on
02:18:49 <couloir> and of some sort of standard platform which is on the immediate horizon?
02:19:20 <mux> dibblego: why wouldn't it print it?  you're running all the commands with the mapM
02:19:21 <Beelsebob> dibblego: why shouldn't it?
02:19:29 <dibblego> why isn't mapM lazy?
02:19:45 <Beelsebob> it is...
02:19:50 <mux> mapM is as lazy as it can be
02:20:01 <mux> but you're forcing the results in your code
02:20:07 <dibblego> ah yeah of course
02:20:07 <Beelsebob> it's just that whether it does each of the actions does not depend on the results of any of the actions
02:20:08 <Cale> Mm... you might have heard of the Haskell platform, which is just a convenient-to-install distribution consisting of a Haskell compiler (GHC) with a bunch of common libraries, for a number of platforms.
02:20:32 <Beelsebob> oh... that reminds me
02:20:54 <Beelsebob> can we do a new Haskell platform logo to fit in with the branding -- maybe the haskell logo with the two bars of the = being the batteries
02:21:01 <couloir> cale, yes, that was it
02:21:19 <Beelsebob> half inserted, or something like that
02:25:46 <ivanm> Beelsebob: hmmm.... batteries...
02:25:56 <Beelsebob> sec, just bocking something up
02:27:30 <quicksilver> Cale: it's already hard to change the language. Look at the pain the last two base upgrades causes.
02:27:37 <quicksilver> OK, that's the libraries not the language.
02:27:39 <quicksilver> but the pain is similar.
02:28:21 <mmorrow> having VLC capture video from you desktop while simulatenously monitoring the input (i use 28fps), then dragging the window around slowly/fullscreen, take screenshots etc. is friggin crazy
02:28:52 * mmorrow did this by accident
02:29:06 <ivanm> _sure_ you did...
02:29:28 <mmorrow> it's like when you're standing between two mirror, and you try to move out of the way to see forever, but your body always gets in the way, but you're body's not in the way this time!
02:30:23 <dancor> you don't see forever bc there's not infinite resolution
02:32:09 <ivanm> dancor: well, if you use an analog display rather than digital... >_>
02:32:19 <dancor> photon
02:32:42 <fasta> Changing the language is not a problem in theory. It is only one in practice, because apparently it is non-trivial to create good source to source transformations to do the upgrades.
02:32:59 <dancor> and if you get around that there's always the planck length :)
02:33:20 <fasta> Oh, is it we all live in a cellular automata time again? ;)
02:33:47 <dancor> fasta: well mapping idioms is sure uncomputable in some sense right?
02:33:49 <ivanm> dancor: yeah, dammit, stupid quantum stuff...
02:34:55 <dancor> it seems like the problem of writing "good" code and the problem of translating languages "well" have similar issues
02:35:23 <dancor> and typically the first is taken to be uncomputably hard right?
02:35:29 <fasta> dancor: e.g. things like the Exceptions could be done automatically.
02:35:56 <mmorrow> dancor: nu uh!!
02:36:00 <dancor> yes your code transformer can certainly 1) create correct code and 2) follow specifiable heuristics
02:36:37 <dancor> if you could write a utility function for "good" code you could search to max that, but even that's impossible right
02:36:45 <mmorrow> http://moonpatio.com/images/forever2.png
02:36:58 <Beelsebob> ivanm: http://www.cs.kent.ac.uk/people/rpg/tatd2/HaskellBatteries.png -- the font isn't dead right, it needs to be more bold, but it gives the general idea
02:38:25 <dhun> why does this not work
02:38:27 <dhun> galcolnum :: Int
02:38:27 <dhun> galcolnum=3
02:38:27 <dhun> galscale :: Float
02:38:27 <dhun> galscale=(1.0/galcolnum)-12.0/448.0
02:38:39 <dancor> :t (/)
02:38:40 <dhun>   Couldn't match expected type `Float' against inferred type `Int'
02:38:40 <dhun>     In the expression: (1.0 / galcolnum) - 12.0 / 448.0
02:38:40 <dhun>     In the definition of `galscale':
02:38:40 <dhun>         galscale = (1.0 / galcolnum) - 12.0 / 448.0
02:38:41 <lambdabot> forall a. (Fractional a) => a -> a -> a
02:38:41 <mux> :t (/)
02:38:42 <lambdabot> forall a. (Fractional a) => a -> a -> a
02:39:03 <dancor> > 1.0 / fromIntegral (3 :: Int)
02:39:04 <lambdabot>   0.3333333333333333
02:39:11 <dhun> ok
02:39:14 <mux> dhun: this means that the (/) operator needs to be passed two identical types on the right and on the left
02:39:22 <dhun> I see
02:39:23 <mux> dhun: here you're passing it an Int and a Float
02:39:28 * dancor will sometimes do   where fI = fromIntegral  if something needs it over and over
02:39:29 <dhun> yes sure
02:39:31 <mux> furthermore, both types need to be in the Floating type class
02:39:59 <mmorrow> yeah, `fi' is crucial for sanity when doing stuff with Double/Float
02:40:39 <dancor> i think coding "well" involves balancing so many trade-offs that doing it is like playing NxN go well
02:40:55 <fasta> mmorrow: if you take a picture with a camera of a tv with the flash enabled you don't see this recursion.
02:41:27 <mmorrow> fasta: ah, interesting. i had to think about that for a second.
02:41:33 <dancor> i think you could make a language transformer that did ok if you spent enough time, but really well is probably beyond current ai
02:42:09 <fasta> Beelsebob: nice idea, but the battery doesn't really stand out.
02:42:28 <dancor> ivanm: maybe infinite resolution hides in the infinite-resolution of quantum probabilities?
02:42:54 <fasta> dancor: what do you think is current ai?
02:43:09 <fasta> dancor: that what actually is used in production or that what has been written on paper?
02:43:46 <fasta> dancor: because the latter is certainly beyond human capability.
02:44:03 <dancor> i've never really understood the planck length anyway, i guess it means you can get away with assigning positions snapped to a grid of planck-length-sized cubes tho?
02:44:15 <dancor> fasta: i have no idea
02:44:53 <fasta> dancor: that is my understanding of it, yes.
02:44:56 <dancor> where current ai is for this problem, but it seems to be low compared to humans on things with many options at each turn requiring balance
02:45:27 <dancor> i could also be wrong about programming having many options at each turn and requiring balance
02:45:49 <fasta> dancor: current ai only has a hardware problem.
02:45:54 <dancor> if you are going for pythonic maybe there aren't so many options etc
02:46:09 <dancor> fasta: heh
02:46:38 <dancor> do you think if a simple neural net as big as the brain was made it would just start being intelligent
02:46:55 <dancor> or are there important more difficult algorithms genetically baked in
02:47:10 <dancor> to the brain
02:47:46 <couloir> you'd have to organize it the same way as the brain at higher levels of structure, for one thing
02:47:59 <dancor> well that's the question
02:48:07 <Jedai> dancor: As couloir said, the brain is more than just a big neural net
02:48:19 <dancor> it is, but how important is that.  brain development does seem a bit haphazard
02:48:33 <fasta> It is completely irrelevant how the human brain works.
02:49:01 <dancor> is there a good utility function for intelligent behavior
02:49:13 <fasta> Unless you believe we can do certain metaphysical computations.
02:49:13 <dancor> i think current ai is all very specific
02:49:22 <dancor> so that they can have such utility functios
02:49:31 <fasta> dancor: if you mean current ai on paper, then that's not true anymore.
02:49:44 <dancor> fasta: what is current ai on paper like
02:49:56 <dibblego> is there a foldM with early drop-out?
02:50:05 <fasta> dancor: http://www.idsia.ch/~juergen/goedelmachine.html
02:50:18 <dancor> dibblego: well you could fail i suppose
02:50:27 <Jedai> dibblego: well foldM in any Monad that has an early drop out
02:50:29 <dancor> dibblego: or you want like  (a -> b -> m (Maybe a)) -> ..
02:50:32 <dancor> ?
02:50:46 <dancor> you might be able to get it with MaybeT
02:50:48 <fasta> The problem with utility functions, is that it is hard to define one which won't have any bad side-effects.
02:50:53 <dibblego> I think I am fried
02:51:18 <dancor> fasta: what side-effects
02:51:27 <fasta> dancor: like getting killed by the machines ;)
02:53:17 <dancor> fasta: that abstract is nice, i guess it really is just about practicallity now
02:53:33 <fasta> dancor: yes, that's why I said it was a hardware problem.
02:53:38 <Jedai> fasta: ok... So where can I find an implementation of these Gödel machine ?
02:53:40 <mmorrow> > flip runCont id (callCC (\k -> foldM (\a b -> if b==0 then k 0 else return (a*b)) 1 ([1..9]++[0..])))
02:53:42 <fasta> dancor: or essentially an economic problem.
02:53:42 <lambdabot>   0
02:53:46 <fasta> Jedai: nowhere.
02:54:13 <dancor> fasta: well, unless you can show certain problems cannot be solved in this way to a certain degree in the lifetime of the universe etc
02:54:15 <mmorrow> > flip runCont id (callCC (\k -> forever (k 42)))
02:54:16 <lambdabot>   42
02:54:30 <fasta> dancor: what do you mean?
02:54:32 <dancor> then it's like a theoreticopractical problem
02:55:20 <dancor> you might be able to show that optimization problems of a certain complexity cannot be solved by such a wholly-arbitrary method in any size computer that can ever possibly exist
02:55:22 <Jedai> fasta: a description on a paper without implementation, claiming it can be implemented on a classic Turing machine isn't that convincing in my humble opinion, I'll reserve judgment on the real value of this concept
02:55:50 <fasta> Jedai: I investigated it in detail. I see no reason why it would not work.
02:55:58 <dancor> Jedai: i think the point is that it's obviously possible to search for self-improvement forever
02:56:07 <fasta> Jedai: and there is a FAQ btw.
02:56:31 <dancor> and that any possible self-improvement will be found eventually
02:56:40 <dancor> and so eventually you will become optimal
02:56:41 <Jedai> fasta: Sure, but would it work in a reasonnable amount of time on a computer of the next century ?
02:56:58 <dancor> Jedai: of course not, for any real problem
02:57:04 <fasta> Jedai: that is something they also answer in terms of the sizes of programs.
02:57:18 <mmorrow> fasta: ooh, that link looks interesting
02:57:46 <fasta> mmorrow: yes, solving every problem in computer science in one go is kind of interesting ;)
02:58:15 <fasta> Jedai: but predicting technology trends is not really scientific.
02:58:43 <dancor> putting bounds on the amount of possible computation in the life of the universe is
02:58:47 <Jedai> fasta: If it takes as much times as nature to evolve a brain as self-conscious and capable of abstraction as the human brain then it isn't really interesting. Even if it takes some millenia it isn't very practical
02:59:09 <fasta> Jedai: it will be a lot faster than evolving the brain.
02:59:17 <dancor> that i don't believe
02:59:22 <Jedai> fasta: How can you be sure ?
02:59:28 <dancor> evolution never had to prove anything
02:59:45 <dancor> i think it will obviously be slower than evolution
02:59:47 <fasta> Jedai: because I understand how it might work.
03:00:05 <fasta> Jedai: if you read the whole bibliography, you might be convinced too.
03:00:05 <Jedai> fasta: As long as you don't have an implementation and result I'll stay on the line.
03:00:33 <fasta> Jedai: I think the first application will be in the military.
03:00:54 <Jedai> fasta: there was plenty of very impressive and convincive idea in the history of IA, this may be the breakthrough but we can't be sure
03:00:56 <fasta> Jedai: there is already some military research facility who is working on this.
03:01:24 <fasta> Jedai: that*
03:01:33 <dancor> i think it's easy to fall into the trap of doing overgeneral ai
03:01:39 <Jedai> fasta: that's not the first such IA concept the military tried to use (sometimes with success)
03:02:04 <fasta> I think general AI is way beyond the capability of a PC or a super computer for that matter, currently.
03:02:08 <Jedai> fasta: It looks interesting but I'll reserve my judgment until I see results
03:02:20 <fasta> The actual amount of required computation required is unknown.
03:02:27 <fasta> You can only know if you have tried it once.
03:02:51 <dancor> beware holy grails
03:02:54 <couloir> can these godel machines react to a dynamic environment?
03:02:59 <fasta> couloir: yes
03:03:14 <fasta> Now, go and read the papers, if you are interested.
03:03:22 <Jedai> couloir: From the concept, that's one of their strength
03:03:28 <couloir> skimming through the first paper on the website
03:07:12 * mmorrow is reading the "G ̈del Machines: Fully Self-referential Optimal Universal Self-improvers∗" one
03:07:38 <mmorrow> i was wondering where the 'o' at the beginning of "Universal" came from..
03:09:28 <fasta> I doubt anyone can understand it if you just read this paper, without reading some of the bibliography.
03:09:51 <fasta> I mean really understand it, not just on some superficial level.
03:14:10 <Isabella> Enthi
03:14:13 <Beelsebob> Can anyone see why the monomorphism restriction is being applied here?
03:14:13 <Beelsebob> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5768
03:14:15 <Isabella> hi
03:14:27 <Beelsebob> I would have expected that the NoMonomorphismRestriction comment would have fixed that
03:15:40 <sm> ack.. how do I sortBy multiple functions ?
03:17:13 <wli> Dictionary ordering?
03:18:08 <wli> sortBy (\x y -> case cmp1 x y of { EQ -> cmp2 x y ; o -> o })
03:18:43 <Saizan> you can write (\x y -> cmp1 x y `mappend` cmp2 x y)
03:19:00 <Saizan> and since (a -> b) is a Monoid too
03:19:13 <Saizan> (cmp1 `mappend` cmp2) works too
03:19:54 <Saizan> ?type comparing snd `mappend` comparing fst
03:19:55 <lambdabot> forall a b. (Ord b, Ord a) => (a, b) -> (a, b) -> Ordering
03:20:07 <Saizan> for example
03:20:12 <sm> wli: thank you!
03:20:36 <sm> and Saizan
03:21:21 <quicksilver> Beelsebob: because those are pattern bindings
03:21:29 <quicksilver> Beelsebob: (because of the extra level of ())
03:22:01 <quicksilver> Beelsebob: http://haskell.org/ghc/docs/latest/html/users_guide/monomorphism.html
03:23:49 <sm> the second seems more concise but is harder to compile.. ghc wants a type signature
03:24:47 * sm perseveres
03:25:17 <Saizan> that may be the case if your cmpN are polymorphic enough
03:26:06 <sm> odd.. it seems happy now
03:26:21 <sm> great, nice trick
03:27:29 <sm> yes, it's happy as long as I don't inline (comparing snd `mappend` (comparing fst)) - I have to give it a temporary name and use that. Odd.
03:29:15 <sm> oops, I need to flip one of them..
03:29:34 <sm> as in, reverse the order
03:29:45 <Saizan> flip cmp1
03:30:24 <Saizan> > sortBy (flip (comparing snd) `mappend` comparing fst) $ zip [1..10] [11..20]
03:30:25 <lambdabot>   [(10,20),(9,19),(8,18),(7,17),(6,16),(5,15),(4,14),(3,13),(2,12),(1,11)]
03:31:43 <sm> nice
03:32:57 <sm> tests pass :)
03:33:34 * sm is trying to infer/clean up darcs show authors output automatically
03:39:30 <jthing> darcs is cool
03:39:51 <jthing> it is one of the apps that actually work
03:40:48 <jthing> abeit a bit slower than GI
03:40:53 <jthing> GIT
03:41:32 <dancor> well it doesn't always work, e.g. the recent corrupted-zip debacle
03:41:38 <dancor> or glib rather
03:41:47 <dancor> i don't think that's been cleaned-up yet
03:42:05 <ivanm> dancor: what's this?
03:42:08 <ivanm> which debacle?
03:42:15 * ivanm doesn't recall hearing of any debacle...
03:43:09 <Saizan> some problem with chechsums of gzipped patches
03:43:28 <dancor> http://lists.osuosl.org/pipermail/darcs-users/2008-November/016276.html
03:43:53 <Saizan> it's fixed now, in the sense darcs won't produce patches like that anymore
03:44:47 <dancor> ya they just need some plan for the fact that current darcs dies on previous-darcs bad-patches
03:45:05 <dancor> e.g. add that fix to the repair command
03:45:21 <dancor> or more automagic solution
03:45:39 <jthing> hey! darcs works rather well..
03:45:54 <dancor> just the facts
03:46:11 <jthing> Iuse it dayly
03:46:56 <jthing> no doubt it has it's bugs too.
03:47:03 <ivanm> so was this a problem with darcs or the haskell bindings to zlib?
03:48:54 <Saizan> ivanm: with darcs' internal bindings to zlib
03:49:07 <ivanm> to C zlib or haskell zlib?
03:49:16 <Saizan> C zlib
03:49:41 <ivanm> so which version of darcs was this? and how big a problem is/was it?
03:49:48 <ivanm> that email just mentions the problem in parsing...
03:50:47 <Saizan> i think it's around darcs-2 that they made possible to use haskell's zlib instead of the internal binding with a flag
03:50:59 <Saizan> and that's when you could experience the problem+
03:51:08 <Saizan> because haskell's zlib controls the checksum
03:51:30 <Saizan> s/controls/checks/
03:51:35 <sm> dancor: it's being worked on
03:52:20 <Saizan> it's not a big problem because you can use gzip to rezip the bad patches
03:53:27 <ivanm> so could this be why I'm having so many problems getting old patches not applying properly when trying to darcs get the haskell overlay for gentoo?
03:54:09 <sm> ivanm: repo url ?
03:54:18 <Saizan> ivanm: the error is quite explicit
03:54:49 <dancor> crc check does not match 123abc != def456
03:55:02 <ivanm> sm: http://code.haskell.org/gentoo/gentoo-haskell
03:55:11 <ivanm> dancor: OK, not that then
04:04:22 <dibblego> @type let fold _ _ e [] = return e; fold z k e (h:t) = k h >>= \c -> if z c then e `seq` fold z k e t else return e in fold -- can this be improved?
04:04:23 <lambdabot> forall a t (m :: * -> *) a1. (Monad m) => (a -> Bool) -> (t -> m a) -> a1 -> [t] -> m a1
04:05:01 <sm> ivanm: darcs get works here, are you using an old version ?
04:07:07 <dhun> how can I remove the last two characters of string
04:07:08 <dhun> ?
04:07:20 <quicksilver> take (length s - 2)
04:07:33 <quicksilver> or init . init, if you like.
04:07:35 <dhun> ok
04:09:29 <osfameron> the latter will fail with strings of length 0 or 1 though
04:09:35 <dhun> can I try to convert a string to a float and do something else if it didn't work?
04:10:12 <quicksilver> yes. Use reads.
04:11:17 <quicksilver> > case reads "1.234" of [(f,"")] -> "Read succeeded, float value is " ++ show (f::Float); _ -> "Read failed for any of a number of reasons"
04:11:18 <lambdabot>   "Read succeeded, float value is 1.234"
04:11:22 <quicksilver> > case reads "x1.234" of [(f,"")] -> "Read succeeded, float value is " ++ show (f::Float); _ -> "Read failed for any of a number of reasons"
04:11:23 <lambdabot>   "Read failed for any of a number of reasons"
04:12:42 <dhun> thank you
04:12:57 <ivanm> sm: Unapplicable patch:
04:12:57 <ivanm> Sat May 31 00:08:53 EST 2008  Ivan.Miljenovic@gmail.com
04:12:57 <ivanm>   * Split cabal-darcs into seperate branches to reflect upstream
04:13:01 <ivanm> gah
04:13:07 <ivanm> forgot to remove newlines
04:13:30 <sm> what darcs version have you ?
04:13:32 <ivanm> sm: using 2.2.1 which AFAIK is latest...
04:13:43 <sm> yes it is.. strange
04:13:57 <ivanm> you just did "darcs get http://..." ?
04:13:59 <sm> and I assume you're not on windows or a mac ?
04:14:02 <sm> yup
04:14:03 <ivanm> nope
04:14:09 <sm> I added --lazy
04:14:19 <ivanm> ahhh, see, I didn't
04:14:20 <ivanm> ;-)
04:14:28 <sm> darcs 2.2.0+162 patches here
04:14:50 <sm> might be more recent than 2.2.1, I'm not sure
04:15:31 <ivanm> since I've had problems before with trying to revert other patches, etc. when I didn't have all the patches...
04:16:40 <sm> ivanm: I think those have improved.. if you ever have problems due to a lazy repo, you can darcs check --complete to make it non-lazy
04:17:07 <ivanm> *nod*
04:17:10 * sm goes --lazy by default
04:17:38 <sm> --lazy --partial in fact, since many haskell projects are still in darcs-1 repos
04:17:50 <ivanm> yeah, this is IIRC
04:17:54 <ivanm> so you used partial as well?
04:18:02 <sm> not this time, no
04:21:17 <osfameron> lazy repo?
04:22:24 <quicksilver> yes, just lies on the couch all day
04:24:04 <sm> ivanm: --lazy probably makes no difference with this repo anyway. It also works here with just darcs get. Might you have a corrupt cache due to full disk or something ? Try cleaning it out or adding --no-cache
04:24:45 * osfameron runs away from the darcs weirdoes ;-)
04:25:15 <sclv> ?bot
04:25:15 <lambdabot> :)
04:26:01 <osfameron> aha, http://mark.stosberg.com/blog/2008/10/darcs-2-a-major-update.html explains it. That makes sense actually
04:26:22 <ivanm> osfameron: how are we "weirdos" just because we're discussing darcs?
04:26:39 <osfameron> though wouldn't merely typing whatever the equivalent of "git log" immediately summon all the old patches ?
04:27:05 <osfameron> ivanm: I was being obnoxious.  But I followed it with ";-)" which makes it ok, right? ;-P
04:27:21 <ivanm> yeah
04:27:35 <ivanm> I was just wondering how you defined us to be weirdos, rather than just users
04:27:43 <ivanm> or does darcs user imply weirdo?
04:27:44 <ivanm> ;-)
04:27:58 <sm> osfameron: no, darcs changes knows the full history even though you only have some of the patches locally
04:28:05 <ivanm> osfameron: my problem is that for some reason, there seems to be some patches that are always corrupted whenever I try to apply them
04:28:06 <osfameron> ah I see
04:28:24 <sm> it's pretty transparent, everything should work normally
04:28:33 <osfameron> ivanm: I guess it's just it's a specialist vcs, and seems to have some even more academic ideas than git (which already terrified me :-)
04:28:52 <sm> ivanm: so any luck ? rm -rf ~/darcs/cache ?
04:29:00 <sm> er ~/.darcs/cache
04:29:46 * ivanm didn't know he had a .darcs dir :o
04:29:47 <sm> osfameron: I'd say darcs is an excellent vcs for non-vcs specialists
04:29:55 <quicksilver> osfameron: I find bzr more approachable than git; I find darcs appealing in principle but I disagree completely with its model.
04:30:06 <ivanm> you don't like patches?
04:30:12 <quicksilver> I reject patch theory; I like trees + merges.
04:30:38 * sm finds all vcs's terrifying compared to darcs
04:30:40 <osfameron> sm: non-vcs specialists don't care.  So the only system that makes sense is the one everyone else is using :-)
04:31:19 <ivanm> sm: so you find darcs terrifying compared to darcs? :p
04:31:22 <osfameron> anyway, darcs is perfectly sane for haskell use (because it *is* what everyone else is using) and I'm just idly trolling, so I'll shut up.  Sorry.
04:31:53 * quicksilver finds grocers apostrophe's terrifying.
04:31:54 <ivanm> quicksilver: patch theory is more of a graph approach, right (rather than just trees)?
04:32:00 <quicksilver> ivanm: Yes.
04:32:17 <ivanm> osfameron: *shrug* it's not like there's any on-topic discussions going on ;-)
04:32:40 <quicksilver> ivanm: What I specificaly reject is the notion of pushing and pulling around patches - just because darcs believes a large set of patches mutually commute doesn't meant it is sane to apply some subset independently.
04:32:48 <sm> ivanm: indeed. So, not to nag, but I hate to leave with darcs still acting up. Any luck ?
04:32:49 <ivanm> quicksilver: *nod*
04:33:01 <quicksilver> ivanm: as a user you should pull a *tree* which represents a tested state.
04:33:10 * ivanm often wishes that patches can be compacted together if you know they're old and don't need to be seperate anymore)
04:33:14 <quicksilver> if you want to "cherry-pick" then you merge in a new tree, which you test and make available.
04:33:19 <ivanm> sm: still pulling ;-)
04:33:23 <sm> ack
04:33:23 <quicksilver> so the correct unit is tree not patch, for me.
04:33:24 * quicksilver shrugs
04:33:38 <sm> quicksilver: recent discussion of that very point on the bzr list
04:34:18 <ivanm> sm: and I can't tell if it's come to that problem patch yet, because the error message before didn't say what patch number it was :s
04:34:41 <sm> ivanm: you can unrecord those old patches and re-record as one
04:34:49 <sm> it'll have the new date though
04:34:56 <ivanm> sm: that's a little dodgy though, isn't it?
04:35:03 <sm> not at all
04:35:10 <sm> patch theory at work
04:35:13 <ivanm> basically, it would be nice to say that no-one cares about things from more than 2 years ago, etc.
04:35:39 <quicksilver> sm: interesting. I don't read the bzr list though. I'd expect them to agree with me since that's the model they chose :)
04:36:01 <ivanm> or else that since I've deleted some files, all patches that dealt with those files are no longer needed (since theoretically, we only record patches on a per-package basis; if we no longer include that package anymore, no need to keep its history)
04:37:21 <ivanm> osfameron: I've read through that link... what did you think it was explaining?
04:37:27 <ivanm> sm: same problem :s
04:37:35 <sm> ivanm: easily done if the patches dealing with those files don't also touch others.. just obliterate them
04:37:50 <sm> otherwise, you'd need to amend them
04:38:21 <sm> and as for 2 years ago, just unrecord all those old patches and re-record as "initial commit"
04:38:22 <osfameron> ivanm: ah - that was the best/first explanation of lazy repos that I could see by the cunning search "darcs lazy repos".  (I didn't really look very hard to be fair)
04:38:56 <deeflex>  how do I type several "where" in a prompt? Example: map (\x -> x == item ) list where item =... AND list = .... ?
04:39:15 <sm> ivanm: could you paste the output ?
04:40:03 <EvilTerran> where foo = ...; bar = ...
04:40:13 <quicksilver> deeflex: just use a new line
04:40:19 <quicksilver> deeflex: and line 'list' up with 'item'
04:40:25 <quicksilver> deeflex: (or alternatively use ;)
04:40:57 <quicksilver> deeflex: incidentally your example is wrong. "map foo where bar" is not haskell. Where clauses attach to definitions not expressions.
04:41:04 <quicksilver> I imagine your actual source is more sane though.
04:41:20 <sm> oh I see it, nm
04:43:02 <ivanm> @paste
04:43:03 <lambdabot> Haskell pastebin: http://hpaste.org/new
04:43:38 <sm> ivanm: so you deleted ~/.darcs/cache, did darcs get, and your disk is not full now I assume
04:44:03 <ivanm> no, I didn't delete ~/.darcs/cache, I used --no-cache
04:44:07 <ivanm> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5773#a5773
04:44:54 <ivanm> sm: and the problem with obliterating patches... you need another patch to record you obliterating those patches :s
04:46:03 <dhun> why does this not work ?
04:46:04 <dhun> readf::String->(Float, [Char])
04:46:04 <dhun> readf x=reads x
04:46:08 <sm> well, you can either rewrite history with obliterate, in which case all repo copies must follow you, or you can use rollback
04:46:48 <EvilTerran> ?type reads
04:46:49 <lambdabot> forall a. (Read a) => String -> [(a, String)]
04:47:01 <EvilTerran> dhun, the [...]s around the (a,String) there is why
04:47:32 <sm> this sounds  a little like http://bugs.darcs.net/issue894 . I don't know why it works for me and not you, probably worth building latest darcs
04:47:35 <dhun> ok
04:48:12 <ivanm> sm: they do? :o I didn't know that obliterate got pushed to other repos...
04:49:15 <sm> ivanm: I mean, if you obliterate you must tell any downstream repo owners to do the same
04:50:07 <ivanm> sm: yeah, _that's_ bad
04:50:29 <sm> what's bad ?
04:50:41 <ivanm> telling users to do a manual obliterate
04:50:47 <ehird> darcs obliterate is so *angry* and *violent* a command name
04:50:48 <ehird> I love it
04:51:11 <sm> ivanm: if you don't want to, then don't rewrite history; use darcs rollback instead
04:51:24 <pltonik> hello all. when you can use a type class or a data type to achieve the same functionality which should be used when? and why? eg. i can either have: func1 :: a -> MyType, func2 :: MyType -> MyType, data MyType = ... OR: class MyTypeable a where func1 :: b -> a, func2 :: a -> a.
04:52:09 <sm> ehird: wouldn't darcs OBLITERATE be better ?
04:52:12 <pltonik> ...not sure if that makes sense - either because i didnt explain it properly or because i said something really stupid...
04:52:16 <flux> sm, what happens if other repo owners don't do it?
04:52:20 <ehird> smg: maybe that's valid!
04:52:40 <sm> flux: next time they send or push to you, it will want to send those patches again
04:52:45 <sm> each time
04:52:55 <ivanm> sm: but doesn't that create a patch on top of all the other patches? how is that better than rm'ing, then darcs record?
04:52:57 <flux> sm, no, nothing extremely bad anyway
04:53:07 <flux> s/no/so/ :-)
04:53:16 <sm> right
04:53:45 <sm> nothing you can't correct easily. Which imho is, generally speaking, darcs' hallmark
04:54:00 <dhun> > init ""
04:54:01 <lambdabot>   "* Exception: Prelude.init: empty list
04:54:26 <sm> ivanm: sorry, I'm lost. I feel whatever it is you're wanting, there's a way
04:54:50 <dhun> > take (length "" - 2) ""
04:54:52 <lambdabot>   ""
04:55:04 <ivanm> sm: heh
04:56:46 <ivanm> sm: even rm'ing ~/.darcs/cache didn't help :s
04:57:04 <sm> ivanm: aha - darcs check in that repo reports "WARNING: Fixing removal of non-empty file ./dev-haskell/cabal-darcs/cabal-darcs-0.ebuild"
04:57:35 <sm> I think my darcs is newer than yours
04:57:38 <pltonik> EvilTerran: hey how goes it? last time you found my questions easy. any such luck this time?
04:57:40 <ivanm> well, darcs repair works now...
04:57:52 <ivanm> but in the copy I had before, it complains of other patches missing :s
04:58:31 <sm> I think you need to get a newer darcs and repair that repo, then all will be well
04:58:46 <sm> oops, catching up
04:58:58 * ivanm can't find a newer darcs... >_>
04:59:26 <ivanm> is there a way for a --partial repo to get the rest of the patches?
04:59:55 <EvilTerran> pltonik, hm?
04:59:59 <ivanm> or is it safe to cp <repo1>/_darcs/patches/* <repo2>/_darcs/patches/ ?
05:00:16 <sm> sounds safe
05:00:39 <sm> you need to do the repair in the upstream repo, before you can get a copy
05:00:46 <EvilTerran> pltonik, ah; well, if you're using a data, it's easy to add new functions that use the same domain of values
05:00:58 <sm> or get latest darcs.
05:01:06 <EvilTerran> pltonik, and, if you're using a typeclass, it's easy to add new values to the domain
05:01:29 <EvilTerran> (by defining a new instance)
05:01:44 <ivanm> sm: which latest darcs? :s
05:01:45 <pltonik> EvilTerran: ahh indeed.
05:01:46 <EvilTerran> however, in either case, it's harder to do the other
05:01:58 <sm> darcs-darcs
05:02:02 <ivanm> ahhh
05:02:09 <ivanm> OK, it somehow didn't get all the patches properly
05:02:16 * ivanm seems to recall having this problem before...
05:02:21 <pltonik> EvilTerran: gotcha. is there some standard or rule-of-thumb for such matters?
05:02:22 <ivanm> anyway, it seems to be right now *shrug*
05:02:42 <EvilTerran> also, using a datatype, all the values have the same type, while they'd have distinct types if you're using a typeclass
05:03:11 <EvilTerran> you can't make a list of Foo a => a, with different "a"s, in haskell98
05:03:58 <pltonik> EvilTerran: ahhhhhhhhhh very nice.
05:04:50 <pltonik> simple but can certainly stuff you up if you don't plan for such things
05:05:32 <EvilTerran> pltonik, well, datas are more for when you just want to structure data nicely, and typeclasses are more for encapsulating a simularity between (potentially lots of) data types
05:06:40 <pltonik> EvilTerran: would you say, then, that classes are for managing functionality while datatypes are for managing data?
05:06:46 <EvilTerran> if you're planning on considering all the "options" that the type could be within a single function, a data is the way to go
05:08:07 <EvilTerran> or, as i say, if you want to hold values of different "options" in the same container structure (a list, or Map, or Seq, or whatever)
05:08:27 <pltonik> EvilTerran: ahh so even though it's easier to add similar functions to different types using classes you wouldn't use classes if such a function deals with more than one datatype?
05:09:11 <pltonik> ...not sure if i said what i really meant there
05:10:04 <EvilTerran> pltonik, if you've got a fixed set of constructors you'll want to use, you almost certainly want a data. that's the simplest guideline i can think of.
05:10:43 <EvilTerran> typeclasses describe a fixed set of functionality, datas describe a fixed structure
05:15:52 <pltonik> EvilTerran: hmm makes sense. so in the event where you're dealing with arbitrary data types i.e. you're building say a new container you'd go with defining the functions using classes such that your container can be extended to any new datatypes? ...now that i read that to myself it kinda seems obvious.
05:16:11 <quicksilver> IMO, classes do not describe a set of functionality.
05:16:25 <quicksilver> classes are a technique for overloading functions.
05:16:43 <pltonik> fair call
05:16:51 <quicksilver> a set of functionality is simply described by a tuple of functions (probably polymorphic)
05:17:09 <quicksilver> you can (ab)use the typeclass mechanism to *choose* the right tuple automatically, based on compile time type inference.
05:17:30 <quicksilver> but, if you're thinking down the set of functionality road you should first consider the "simple" higher order approach
05:17:43 <quicksilver> before asking if it makes sense to use a typeclass to "help" choose the right bundle of functions.
05:18:09 <pltonik> quicksilver: not sure what you mean by the higher order approach
05:18:20 <quicksilver> pltonik: a tuple of functions is a higher order construct.
05:18:22 <quicksilver> that's all.
05:18:38 <quicksilver> "higher order programming" is passing functions around as value
05:18:45 <pltonik> oh
05:18:49 <pltonik> righto
05:19:05 <ivanm> anyone know when the ICFP contest page will start putting up their hints/clues like they've done the last few years?
05:19:12 <ivanm> or aren't they going to be as cutesy this year?
05:19:51 <quicksilver> pltonik: now, to respond to a specific comment
05:20:06 <quicksilver> pltonik: "dealing with arbitrary data types ... new container..."
05:20:16 <quicksilver> pltonik: ideally you make such things *fully* polymorphic
05:20:19 <quicksilver> not typeclass polymorphic.
05:20:31 <quicksilver> pltonik: note that lists [a] can store any type a.
05:20:55 <quicksilver> so ideally, if you want to deal with abitrary data, you write your data types to be parametrically polymorphic
05:20:58 <quicksilver> works out more elegant all round.
05:22:42 <jix> if i have a recursive data structure... data Expr = Add Expr Expr | Const Int ... and for some algorithm on it need to have an additional value for Expr only used internally... is there any way i can do that?
05:23:06 <jix> without adding it to Expr directly... wrapping it somehow would be ok
05:23:15 <pltonik> quicksilver: so if i understand you correctly you mean (pardon my n00b speak) encapsulating functionality within some constructor passing around the actual parameter regardless of its datatype?
05:23:59 <pltonik> quicksilver: as in: data MyType = SomeC a, and then writing functions which do not check/rely on the particular datatype of a?
05:24:37 <quicksilver> data MyType a = SomeC a
05:24:46 <pltonik> quicksilver: oh yea my bad
05:24:58 <quicksilver> jix: Either Expr OtherStuff ?
05:25:06 <jix> quicksilver: won't work with the recursion
05:25:13 <pltonik> which is similar to the definition of a list
05:25:17 <quicksilver> pltonik: right.
05:25:19 <jix> because i can't put an Either Expr OtherStuff into an Add foo foo
05:25:46 <quicksilver> parameterise Expr
05:26:09 <quicksilver> data Expr otherstuff = Add .. | Const ... | OtherStuff otherstuff
05:26:19 <quicksilver> then "Expr Void" is isomorphic to your original otherstuff
05:26:35 <quicksilver> but Expr [Int] has also the choice of a list of ints
05:26:36 <jix> quicksilver: well changing Expr is something i wanted to avoid but i guess that can't be done
05:26:57 <quicksilver> it's quite common to do the multiplicative version of this
05:27:09 <quicksilver> where data Expr label = ... exprs labelled with label ...
05:27:17 <quicksilver> and thence Expr () is the plain expr
05:27:23 <quicksilver> I've not see the additive version before I must admit.
05:28:41 <jix> i'm writing some functions to do efficient recursive tree rewriting when there are shared subtrees... and for that i sometimes have to put barriers in the tree structure i'm working on
05:30:02 <pltonik> quicksilver: so based on your suggestion that if dealing with arbitrary data types you should write 'fully polymorphic' datatypes and functions then are you implying that using typeclasses is the 'next best thing' when you *can't* write in fully polymorphic manner?
05:30:24 <quicksilver> pltonik: well that's not what I was saying. Maybe it's what I implied, a bit.
05:30:50 <pltonik> quicksilver: lol i'm not trying to put words in your mouth i'm just clarifying
05:31:11 <pltonik> just need to understand when/where each method has its uses/advantages etc.
05:33:09 <quicksilver> I only have one rule of thumb, really.
05:33:13 <quicksilver> and that's don't use typeclasses.
05:33:38 <pltonik> curious
05:34:00 <pltonik> seems like a godsend coming from an imperative language
05:34:30 <quicksilver> why?
05:34:38 <quicksilver> I don't see the link between imperative and typeclasses at all
05:35:21 <pltonik> perhaps imperative hasnothing to do with it. what i meant is that i havent seen such ease of extending functionality to any new data type in other languages.
05:35:45 <fasta> pltonik: that's not what type-classes do.
05:36:08 <pltonik> fasta: polymorphism?
05:36:19 <fasta> pltonik: it's just adhoc polymorphism.
05:36:27 <fasta> pltonik: (which is not always a good idea)
05:37:59 <pltonik> fasta: umm to me polymorphism means functionality on a datatype which didn't have it before, and any future ones too. also, why isn't always a good idea?
05:38:32 <quicksilver> pltonik: that's doesn't really describe either of the forms of polymorphism that haskell has.
05:38:42 <quicksilver> although it is close to typeclass (adhoc) than parametric.
05:39:03 <quicksilver> parametric polymorphism is writing code which uniformly doesn't care what type its arguments are, like map
05:39:03 <pltonik> hmm sounds like i just jumbled up the terms.
05:39:06 <quicksilver> :t map
05:39:07 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
05:39:36 <fasta> pltonik: asking is also kind of pointless. Just write a Haskell program of over >5k lines of code and see whether you need user-defined type-classes.
05:39:37 <quicksilver> adhoc polymorphism is (in the haskell sense) having overloaded methods so you can define 'corresponding' operations on multiple types.
05:39:44 <Zao> This kind of polymorphism is closer to C++ templates than inheritance.
05:40:43 <pltonik> Zao: that's what i was refering to, hence why in haskell they are so much easier (templates suck)
05:41:08 * Zao binds pltonik to a non-type template template parameter.
05:41:27 <pltonik> cheers mate
05:41:42 <quicksilver> yes, templates are like parametric polymorphism, but totally unchecked
05:41:53 <quicksilver> so you get incomprehensible type errors if you do something wrong.
05:42:17 <quicksilver> template specialisation is more like adhoc , in that you are then allowed to do specific implementations for specific types.
05:42:54 <pltonik> quicksilver: indeed, so i didnt jumble anything up and the haskell way is indeed much better. then why the rule of thumb against typeclasses?
05:43:41 <quicksilver> because 99.9% of the time they are used, they are used incorrectly.
05:43:54 <quicksilver> this is an epidemiological judgement, of course.
05:44:05 <Philippa> hrmm
05:44:18 * Philippa wonders whether her uses are considered incorrect
05:44:30 <pltonik> none-the-less certainly good to know if that is a fact
05:44:42 <quicksilver> it is especially likely that someone from a C++ background will be misled by the use of the words "method" and "class" and try to use them "like" a C++ class.
05:44:52 <quicksilver> (also java C# VB etc.)
05:45:13 * quicksilver doubts he would be brave enough to pass judgement on Philippa's code.
05:45:16 <Philippa> if you understand the actual mapping involved, sometimes that's not incorrect
05:45:17 <pltonik> indeed. having no problem with that though, are there any other issues with typeclasses?
05:45:18 <Philippa> ...heh
05:45:22 <Eelis> quicksilver: do i understand correctly that you're arguing that 99.9% of the type classes on, say, hackage, are inappropriate?
05:46:05 <quicksilver> Eelis: no, probably not. Hackage is probably biased (at least slightly) towards better code.
05:46:14 <Eelis> quicksilver: then i'm not sure what code you /are/ talking about.
05:46:30 <quicksilver> Eelis: I meant more like 99.9% of the uses occurring in pastes or examples discussed in this channel or on -cafe
05:46:37 <Eelis> i see.
05:46:37 * mux is guilty of having abused type classes on hackage
05:47:03 <Philippa> do you count type-level programming hackery as an abuse, then? :-)
05:47:11 <quicksilver> Philippa: No.
05:47:13 <pltonik> quicksilver: ...discussed predominantly by n00bs or every/anyone
05:47:37 <Philippa> quicksilver: settle on 80 or 90% as a value more likely to get the point across?
05:48:12 <Philippa> (mind you, I'm still contemplating the effect that some of parsec 3's new classes have in practice - ideally it wouldn't be a problem, but arguably they're an abuse in the presence of eg the monomorphism restriction
05:48:14 <quicksilver> Philippa: as a rule of thumb, for example, if anyone is bemoaning the fact that they can only have one instance per type, then they probably should be using a simple higher order approach (a.k.a. "explicit dictionaries") and I find this common.
05:48:14 <Philippa> )
05:48:51 <quicksilver> Philippa: If you wish to re-train of my habit of absurd exagerration (and poor spelling) then you have an uphill task ahead of you.
05:48:56 <Philippa> quicksilver: I'm in two minds regarding that or newtyping as the better approach
05:49:27 <Philippa> quicksilver: 90% is still an absurd exaggeration, it's just one that usefully communicates that it's still possible to intentionally use them well :-)
05:50:51 <pltonik> thanks to everyone who chipped in their thoughts on my question(s). im off. bye!
05:50:57 * Philippa also thinks that there're sensible tradeoffs to be made away from explicit dictionaries - they're potentially error-prone
05:52:36 <quicksilver> I rather like that with records or tuples of higher-order functions, you can override them one by one
05:52:47 <quicksilver> you can do things more like you can in prototype OO.
05:52:48 <Philippa> yeah, that's nice
05:52:56 <quicksilver> I mean, change them for a specific value
05:52:59 <quicksilver> (rather than a whole type)
05:53:12 <quicksilver> it's just more flexible, opens up the design space.
05:53:19 <quicksilver> At which point you can clamp it down to the parts you want.
05:53:27 <Philippa> honestly, my preference is for extending typeclasses further. It's just that to really do that right, you have to break H98
05:53:38 <quicksilver> and *then* if you want the type-inference machine to do some automagic for, you bring a typeclass into the mix.
05:53:38 <Philippa> because you need to let types parameterise on instances
05:53:54 <quicksilver> I honestly don't see how that makes things better
05:54:08 <quicksilver> isn't that just obfuscated compared to passing around HOFs?
05:54:22 <eu-prleu-peupeu> hi
05:54:26 <Philippa> you'd also want to parameterise on the HOFs
05:54:39 <Philippa> maps are dependent on the orderings they use
05:54:44 <Philippa> to pick an example
05:55:42 <quicksilver> yes.
05:55:42 <Philippa> worse, you might have a situation where you need to, say, compare two such types - and can't yield a valid comparison if they don't use the same ordering
05:55:50 <quicksilver> it's a big project to fix that in the type system.
05:56:04 <quicksilver> now, you might have a beautiful proposal to do so - and I'd probably think it was rather clever.
05:56:06 <Philippa> I did /say/ it breaks H98
05:56:26 <quicksilver> but talking about what we have now (even haskell extensions commonly used)
05:56:32 <quicksilver> I find typeclasses overused.
05:57:46 <Philippa> *nod*. I do, but not by as much: I think there's a large space where it's at least a matter of taste if not something stronger, because inference is an important engineering tool - it abstracts over the passing and it keeps code agile
05:58:20 <Philippa> admittedly, that's a particularly high priority for me. YMMV
05:58:33 <quicksilver> Most of my comments in this channel are matters of taste, not fact.
05:58:42 <quicksilver> using haskell in first place is a matter of taste, after all :)
05:58:45 <marcot> Good morning.  In uuagc, how can I generate a module with the type definitions, and another module with the semantic functions, that imports the other module?
05:59:04 <ivanm> quicksilver: good taste, presumably ;-)
05:59:05 <hackagebot> hscamwire 0.2 - Haskell bindings to IIDC1394 cameras, via Camwire (FrederickRoss)
05:59:11 <quicksilver> ivanm: the very best.
05:59:31 <Philippa> yeah, but many of the arguments I'd give for it are in themselves not about taste and/or apply for a fair variety of tastes
05:59:55 <quicksilver> the line between abuse and use is a matter of taste, though.
06:00:22 <quicksilver> it is a matter of fact that the typeclass system is a mechanism whereby you can "hook into" GHC's type inference and cause it to "select" a tuple of (typically) functions.
06:00:35 <quicksilver> it is a matter of taste when that is a good idea, and when it is a bad one.
06:01:03 <codebliss> I'm starting monad transformers.  Are there any simple examples to get my mind into their purpose?
06:01:36 <Philippa> assuming you understand their non-transformer equivalents, StateT, ReaderT and WriterT are good
06:01:36 <fasta> codebliss: not using monad transformers would do exactly that.
06:01:48 <Philippa> fasta: IdentityT?
06:01:54 <EvilTerran> MaybeT's relatively easy to implement yourself
06:01:57 <EvilTerran> and instructive
06:02:20 <Philippa> good call
06:02:33 <codebliss> EvilTerran: Thanks.  I remade Maybe from scratch and that's why best got me to understand monads.  Sounds like a place to start
06:02:44 <Philippa> MaybeT over IO especially so
06:03:01 <fasta> Philippa: like everything they are here to scratch an itch. If codebliss never encountered the use case, it's hard to appreciate.
06:03:11 <fasta> But MaybeT over IO is a good example.
06:03:24 <Philippa> fasta: it's easy to not know you've encountered it, though
06:03:48 <codebliss> Well are monad transformers ways to combine two monads?  brb 5m quick, ty for answers
06:04:00 <Philippa> codebliss: almost, yeah
06:04:03 <Twey> Basically.
06:04:24 <quicksilver> combine the functionality of monads
06:04:29 <quicksilver> might be slightly more precise.
06:04:36 <quicksilver> But, the short answer is "yes".
06:05:46 <Twey> A monad transformer is like a monad that takes another monad as a type argument, allowing one to insert another monad into which computations can be ‘lifted’.
06:06:04 <mux> yo, I heard you like monads, so...
06:06:05 <EvilTerran> unfortunately, monads aren't composable in general
06:06:17 <Twey> @src liftM
06:06:17 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
06:06:24 <Twey> That is truly a great shame
06:06:36 <Twey> I feel we should just be using monad transformers for everything
06:06:44 <Twey> With Identity at the bottom of the stack
06:07:08 <mux> unfortunately that doesn't generate great code
06:07:20 <Twey> It tends to be kind of slow, as I understand it
06:07:32 <Twey> A worthy area of research, then
06:07:41 <Twey> Now if only I were smart enough :-P
06:07:45 <mux> I'm hoping that future optimizations will make  that a non-issue
06:07:49 <Twey> Yeah
06:08:22 <Twey> Doesn't Identity get optimised out already/
06:08:23 <Twey> ?**
06:08:23 <lambdabot> Maybe you meant: . ? @ bf ft id pl rc v wn
06:08:31 <Twey> @botsmack
06:08:31 <lambdabot> :)
06:08:31 <lunabot>  :)
06:08:41 <Twey> Silly things
06:09:01 <EvilTerran> you can't always have Identity at the bottom, anyway
06:09:05 <EvilTerran> for instance, you can't define IOT
06:09:08 <codebliss> Philippa: I still can't see the usefulness of MonadT's.  Any examples?  I'm still relatively new to haskell (2mo)
06:09:14 <Twey> Oh, right :-\
06:09:20 <Twey> That's a shame
06:09:38 <Twey> codebliss: Well, the classic example is when you want to use State and IO together.
06:09:55 <codebliss> I should probably take a look at state first =D
06:10:32 <EvilTerran> codebliss, the point as i see it is that it's a higher level of describing what your monad can do than writing it out manually would be
06:10:46 <Philippa> yeah. I end up using stacks like ReaderT $ StateT $ Error a lot
06:10:52 <codebliss> Ah.  Okay thanks
06:10:54 <Philippa> EvilTerran: not to mention quicker and easier
06:10:56 <EvilTerran> so less error-prone, as you're not going to accidentally stuff up your definition of >>=
06:11:05 <EvilTerran> Philippa, that follows from higher-level, imo
06:11:17 <lilac> what's the fundamental reason that IOT can't be defined?
06:11:27 <Philippa> lilac: nothing can override the real world
06:11:41 <Philippa> if your computer gets hit by a meteorite, the fatal exception /happens/ :-)
06:12:11 <EvilTerran> unsafeLaunchMeteorite?
06:12:20 <lilac> EvilTerran: don't do it!
06:12:24 <Philippa> you can't let Maybe undo the fact you just launched an ICBM or overwrote important data
06:12:35 <RayNbow> @hoogle unsafeLaunchMeteorite
06:12:36 <lambdabot> No results found
06:12:55 <fasta> Can Yi already load ghci in a buffer? I am getting annoyed with the slowness of Emacs.
06:13:20 <Saizan_> yes, since an year ago, at least
06:13:28 <Philippa> lilac: similarly, IOT [] would require that your computer have access to a multiverse and the ability to change which universe it's nominally working it. You don't want to think about what space leaks might mean
06:13:49 <lilac> Philippa: do you mean that, if you had IOT Maybe () (so runMaybeT x :: Maybe (IO ())), the Just-ness of the result could depend on the result of /running/ an IO action?
06:14:00 <Twey> Philippa: Hahahahaha
06:14:17 <Philippa> lilac: amongst other things, yes
06:14:21 <fasta> Does anyone actually use Yi on a day to day basis?
06:14:35 <Twey> There's a point: how does one do monad transformers with []?
06:14:50 <Saizan_> @wiki ListT done right
06:14:51 <lambdabot> http://www.haskell.org/haskellwiki/ListT_done_right
06:14:53 <Twey> The syntax doesn't seem to allow currying
06:15:07 <Twey> Saizan_: But how about [] inside another transformer?
06:15:20 <Saizan_> e.g. StateT s [] ?
06:15:23 <EvilTerran> ?unmtl StateT s [] a
06:15:23 <lambdabot> s -> [(a, s)]
06:15:30 <EvilTerran> > [] :: [] Int
06:15:32 <lambdabot>   []
06:15:36 <Twey> Oho
06:15:40 <Twey> That's legal?
06:15:45 <Saizan_> sure
06:15:48 <Twey> Nice
06:15:59 <Philippa> lilac: the semantics of the Maybe monad (transformer) are such that if you catch something that happened in a transformer above it, you undo /all/ its effects
06:16:05 <Twey> I thought it had to be like [Int]
06:16:09 <codebliss> How is this interpreted?  I never understood "newstate"
06:16:09 <codebliss> newtype State s a = State { runState :: (s -> (a,s)) }
06:16:10 <Philippa> you clearly can't do that with IO
06:16:18 <ray> [Int] is just sweet, sweet sugar
06:16:22 <codebliss> What's the brackets and the type for runState doing?
06:16:31 <mauke> codebliss: if you don't understand "newtype", think "data" instead
06:16:35 <Philippa> it's defining a record
06:16:36 <codebliss> Isn't [Foo] [] Foo?
06:16:42 <mauke> codebliss: record syntax
06:16:43 <Philippa> with one field called runState
06:16:44 <codebliss> And [] is a monad?
06:16:49 <codebliss> Okies.
06:16:58 <codebliss> What does runState do?
06:17:08 <EvilTerran> codebliss, ask ghci for the type
06:17:18 <EvilTerran> ?type runState -- or lambdabot
06:17:20 <lambdabot> forall s a. State s a -> s -> (a, s)
06:18:01 <codebliss> Mh hm, that's in the def.
06:18:01 * Philippa does think that particular definition of the State monad is rather newbie-unfriendly
06:18:20 <Axman6> i agree
06:18:26 <opqdonut> the state comonad is much clearer!
06:18:26 <Philippa> what with it being reliant on a somewhat confusing idiom
06:18:36 <codebliss> I'm just pretty new to monads etc, I get haskell quite well.
06:18:41 <Axman6> i understand the concepts of State, but the implementation and usage is a bit beyond me
06:18:43 <EvilTerran> codebliss, "newtype State s a = State (s -> (a,s)); runState (State f) = f" would mean approximately the same thing
06:19:00 <mauke> Axman6: heh, the implementation is trivial :-)
06:19:07 * mux was wondering whether he'd be able to write the State monad from scratch and succeeded in ~10minutes - quite happy about it :-)
06:19:23 * EvilTerran has done that on napkins in pubs <.< >.>
06:19:23 <Axman6> well, not of the State type, but mainly the monad parts of it
06:19:32 <Axman6> and trying to figure out where i'd use it
06:19:45 <mux> EvilTerran: heh
06:20:12 <codebliss> So newtype State s a makes a new type (basically like data), and the constructor is named State and is :: s -> (a, s)?
06:20:14 <mux> EvilTerran: did the people you were with stayed with you at that point? :-)
06:20:32 <codebliss> Then why is State s a having 2 parameters and State constructor 1?
06:20:32 <EvilTerran> mux, yeah; it was a Principles of Programming Languages revision session, so it was relevant
06:20:41 <EvilTerran> (yes, in a pub - why not?)
06:20:44 <EvilTerran> :P
06:20:45 <mux> sure!
06:20:51 <mux> sounds like a perfect place :-)
06:21:20 <EvilTerran> codebliss, the type State takes two parameters; the type of the state, s, and the type of the monadic result, a
06:21:21 <mauke> codebliss: because they have nothing to do with each other?
06:21:38 <mauke> [] has one parameter; its constructors have 0 and 2, respectively
06:21:42 <codebliss> EvilTerran: Aha.
06:21:52 <Axman6> EvilTerran: wish pubs were quiet enough for that around here
06:21:55 <EvilTerran> codebliss, and the type "State s a" is isomorphic to the type "s -> (a,s)"; that's what the newtype tells you
06:22:00 <codebliss> mauke: Aha again, thanks
06:22:15 <couloir> could any of you recommend a haskell tutorial? i've had some exposure to the language as part of a course, but the instructor was more keen on lisps, and i'd like a more inspired overview
06:22:26 <Axman6> couloir: LYAH
06:22:28 <mauke> preflex: ? lyah
06:22:28 <preflex>  http://learnyouahaskell.com/
06:22:29 <Axman6> @where lyah
06:22:29 <lambdabot> www.learnyouahaskell.com
06:22:35 <EvilTerran> heh
06:22:38 <couloir> great, thanks
06:22:40 <C-Keen> or even RWH
06:22:45 <Axman6> @quote stereo
06:22:45 <lambdabot> Anonycale says: Welcome to #haskell, where your questions are answered in majestic stereo!
06:22:46 <Philippa> that reminds me
06:22:46 <C-Keen> @where RWH
06:22:46 <lambdabot> is http://www.realworldhaskell.org/blog/
06:22:54 <codebliss> OHHH, note to self:  always load into ghci first
06:23:02 <Philippa> @tell BONUS my dad is finding LYAH useful, thought you'd like to know :-)
06:23:02 <lambdabot> Consider it noted.
06:23:29 <fasta> How do I get rid of this? Either there needs to be a way to select which version I want, or I need to deinstall one, but I need one for my project and one for Yi. Could not find module `Control.Monad.Trans':it was found in multiple packages: transformers-0.1.4.0 mtl-1.1.0.2
06:23:31 <mauke> BONUS++
06:23:56 <Saizan_> fasta: :set -hide-package transformers
06:24:27 <Axman6> BONUS++ indeed, it's a great tutorial from what i've seen of it
06:25:30 <couloir> this is somewhat hilarious
06:25:38 <codebliss> So runState and State are like opposites?  That's why type sig is showing me
06:25:39 <Axman6> what is?
06:25:43 <couloir> LYAH
06:25:52 <Axman6> ah yes
06:25:57 <couloir> "Also, I think you can do Haskell development with that wacky mouse with one button, although I'm not sure."
06:26:04 <EvilTerran> codebliss, indeed, they're inverses
06:26:05 <codebliss> Learnyouahaskell is pretty great, I liked it more than rwh
06:26:14 <EvilTerran> codebliss, that's why people tend to use the record syntax when defining newtypes
06:26:20 <codebliss> AH
06:26:29 <Axman6> BONUS should have it published when it's finished
06:26:36 <fasta> Saizan_: it would be better if you could specify a configuration in the directory of the project.
06:26:37 <ivanm> Axman6: *shudder*
06:26:41 <EvilTerran> codebliss, in that "newtype Foo ... = InFoo { outFoo :: ... }" gives you InFoo and outFoo as mutual inverses
06:26:43 <Axman6> ?
06:27:07 <ivanm> Axman6: so we'll have scholarly haskell books, we'll have "real world" haskell books, and then we'll have "what the" haskell books :s
06:27:11 <fasta> Saizan_: since if I would ever decide to hack on Yi, that wouldn't work if I would add it to my .ghci
06:27:14 <Twey> couloir: RWH > LYAH
06:27:14 <Axman6> oh hey ivanm, you wouldn't happen to want a nice cheap thinkpad would... oh they sold out :(
06:27:14 <codebliss> So State is inState and runState is outState essentially?
06:27:23 <Twey> LYAH annoys me
06:27:32 <ivanm> Axman6: hmmm, what's this?
06:27:39 <ivanm> Twey: the name alone annoys me
06:27:42 <EvilTerran> codebliss, effectively, yes
06:27:42 <couloir> Twey: i'll probably do both
06:27:44 <Twey> Also, it doesn't cover some of the cool real-world stuff that RWH does, which you're really going to need if you intend to do anything serious with Haskell
06:27:45 <Axman6> RWH has some problems, i think it could have been organised better
06:27:49 <Philippa> LYAH is good for a lot of things that RWH isn't, though
06:27:50 <Axman6> ivanm: http://www.zazz.com.au/
06:27:51 <idnar> ivanm: oh good, it's not just me
06:27:53 <fasta> Saizan_: unless the idea is that everyone writes their own scripts to start ghci with a different .ghci for every project.
06:28:06 <codebliss> I suggest LYAH -> RWH
06:28:14 <couloir> codebliss, noted
06:28:15 <codebliss> LYAH has a better beginning section IMO
06:28:16 <fasta> Saizan_: which doesn't really work together with existing "tools".
06:28:22 <ivanm> Axman6: so there's only a few left, which are sold out? :s
06:28:33 <codebliss> Better for those new to fprogramming, and lesser yet to pure fprogramming
06:28:36 <ivanm> *shrug* I bought a new laptop last year
06:28:45 <couloir> technically i learned the basics of haskell at one point
06:28:50 <ivanm> my laptop from 5 years ago looks to be better than that thinkpad!
06:28:52 <couloir> enough to do some simple list processing
06:28:53 <codebliss> ivanm: HP has very good bang for buck.
06:28:58 <Saizan_> fasta: let cabal load the project you're working on in ghci with flags based on the .cabal file should work too
06:28:59 <Philippa> couloir: *hah*
06:29:06 <ivanm> codebliss: Dell had a better bang for buck ;-)
06:29:10 <couloir> of course that's like 10% of the basics, lol
06:29:17 <codebliss> ivanm: HP has awesome customer service =D
06:29:24 * ivanm recommends Craft/SoE -> RWH
06:29:33 <dcoutts> Saizan_: there's a partial patch for that btw
06:29:35 <fasta> Saizan_: how exactly does that work?
06:29:39 <Twey> Craft's nice
06:29:47 <ivanm> codebliss: yeah, I should go and ping Dell at some point about why it takes to long just to get to the _BIOS_ :@
06:29:51 <Saizan_> fasta: btw, maybe you can put something in your .ghci to load a project-local .ghci on startup?
06:30:01 <Axman6> ivanm: well, they were really cheap, and i've coverted a thinkpad for a long time. and preferably wanted a pre lenovo one
06:30:02 <couloir> @where craft
06:30:02 <lambdabot> I know nothing about craft.
06:30:03 <codebliss> When I was introduced to fprogramming, this made me lawl in awesome.  add a b = a + b; inc = add 1
06:30:13 <dcoutts> Saizan_: it needs a bit of cleaning up, and really it should be based on a refactored ghc module using an ghc flags type like we talked about the other day
06:30:17 <codebliss> But that was in f#, but still.  It was pretty sweet
06:30:21 <ivanm> Axman6: you mean "coveted"?
06:30:21 <codebliss> Functions are your friends!
06:30:29 <Axman6> it shall compliment my macbook pro nicely, i'll just stick FreeBSD on it i think
06:30:38 <Saizan_> fasta: it doesn't work yet, but it'd be like "cabal ghci [Module]"
06:30:45 <Axman6> ivanm: probably, i've never seen it written down ;)
06:30:49 <ivanm> heh
06:31:07 <fasta> Saizan_: yes, that would be nice.
06:31:08 <ivanm> Axman6: but still, "factory refurbished"? :s
06:31:11 <codebliss> My intro programming class is java =(
06:31:24 <Axman6> meh, it'll be a nicve machine
06:31:38 <Twey> couloir: In Haskell it's even more awesome.
06:31:40 <Axman6> nice*
06:31:43 <ivanm> Axman6: compared to what?
06:31:45 <Twey> couloir: inc = (+1)
06:31:57 <Twey> Or, inc = succ
06:32:02 <Axman6> compared to it's what i've wanted for quite some time, and it was cheap
06:32:05 <Twey> Then you can apply it to any Enum, not just numbers
06:32:06 <Saizan_> dcoutts: i should try it out :)
06:32:25 <EvilTerran> Twey, although there are Nums that aren't Enums, too
06:32:26 <ivanm> Axman6: lack of funds to get anything better?
06:32:30 <EvilTerran> (or rather ,shouldn't be Enums)
06:32:33 <Twey> Oh, true
06:32:53 <Baughn> In which case, applying 'inc' to them is also a bit off
06:33:00 * Baughn pokes Double
06:33:01 <Twey> Not necessarily
06:33:14 <opqdonut> (+1) is perfectly sane for example for a rational
06:33:17 <opqdonut> or a complex number
06:33:20 <opqdonut> or a polynomial
06:33:20 <Twey> Right
06:33:28 <Twey> Because inc has a fixed semantic ‘step’ of 1
06:33:57 <Twey> Whereas succ is about ‘the next available step’ which doesn't make sense for dense things
06:33:59 <Baughn> Hm. Say, could you make an inc that works with /either/ Enum or Num
06:34:03 <dhun> I will apply for the competition for the most obfuscated Haskell code http://de.wikibooks.org/wiki/Benutzer:Dirk_Huenniger/haskell2
06:34:09 <Twey> Baughn: No :(
06:34:12 <opqdonut> also, succ shouldn't be cyclical right?
06:34:17 <EvilTerran> > succ [0 :: Fixed E6]
06:34:18 <opqdonut> but (+1) will be for a finite field
06:34:18 <lambdabot>   Ambiguous occurrence `Fixed'
06:34:18 <lambdabot>  It could refer to either `Data.Fixed.Fixed', ...
06:34:21 <opqdonut> (or ring)
06:34:27 <Twey> Baughn: Not without a better typeclass system
06:34:29 <EvilTerran> > succ 0 :: Data.Fixed.Fixed E6
06:34:30 <lambdabot>   0.000001
06:34:32 <Twey> (or TH)
06:34:41 <Twey> (but that's cheating)
06:35:42 <EvilTerran> or olegian type hackery, no doubt
06:37:28 <Baughn> You know, Double isn't actually dense. Wouldn't it be nice to have an Enum instance that works like the standard says it should?
06:41:10 <kynes>  with Hugs, is there a way to run an expression directly from the command line and get the result ?
06:41:15 <kynes> I tried runhugs but it requires me to create a file
06:41:21 <kynes> can I just directly provide the expression ?
06:41:34 <Baughn> I don't have it installed, but.. hugs -e or some such?
06:41:43 <Baughn> I imagine hugs --help would be helpful
06:41:46 <couloir> <3 zipWith
06:42:08 <ClaudiusMaximus> hugs --help isn't helpful here
06:42:22 <Axman6> > let fibs = 1:1: zipWith (+) fibs (tail fibs) in fibs
06:42:23 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
06:42:50 <couloir> infinite lists are pretty jaw dropping too
06:42:57 <Axman6> heh
06:43:09 <Axman6> i think seemingly infinite numbers are better
06:43:18 <kynes> in the THINGS part of a  "let .. in do THINGS " expression in Haskell
06:43:22 <Axman6> 2^(2^1024)
06:43:25 <Axman6> > 2^(2^1024)
06:43:30 <lambdabot>   mueval-core: Prelude.read: no parse
06:43:31 <lambdabot>  mueval: ExitFailure 1
06:43:32 <kynes> I'm doing many things, like 2000 or so..
06:43:38 <Axman6> > 2^(2^24)
06:43:41 <kynes> and Hugs gives me "ERROR - Garbage collection fails to reclaim sufficient space"
06:43:41 <lambdabot>   181858529856973800789277132777499061892485968097894083110781124867581621200...
06:43:46 <codebliss> Is there any way to act like your running a command in ghci without doing so? (linux)
06:43:46 <couloir> whoa
06:43:46 <Baughn> kynes: You could use ghc -e. Or you could, at least, pipe your code into hugs.
06:43:48 <dcoutts> Saizan_: there's a patch attached to the ticket http://hackage.haskell.org/trac/hackage/ticket/382
06:43:59 <codebliss> So say I could start with :set prompt >
06:44:01 <kynes> Baughn, how can I pipe the code ?
06:44:03 <Baughn> kynes: ..I can't find an eval option for hugs, strangely enough
06:44:25 <Baughn> kynes: "echo let fibs = 1:1:zipWith(+)fibs(tail fibs) in fibs | hugs"
06:44:33 <Baughn> 'course, then it can't read stdin
06:44:35 <codebliss> Baughn: Use ghci?
06:44:39 <Axman6> kynes: echo "putStrLn \"Hello world\""|hugs
06:44:49 <Baughn> codebliss: You'd think, but he specified hugs
06:45:09 <codebliss> Is there any advantage to hugs over ghci?
06:45:18 <Baughn> Hm.. nope, not really
06:45:23 <C-Keen> :t ((x:) *** id)
06:45:26 <lambdabot> forall b'. ([Expr], b') -> ([Expr], b')
06:45:28 <Baughn> Well, I think hugs is smaller. :P
06:45:29 <kynes> Axman6, but it also prints the logo and interpreter stuff..
06:45:37 <kynes> Axman6, how can I avoid these ?
06:45:43 <codebliss> :t (***)
06:45:44 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
06:45:46 <Axman6> no idea, i've never used hugs
06:45:49 <codebliss> Hootie hoo!
06:45:56 <Baughn> kynes: Why do you insist on /hugs/, anyhow/
06:45:58 <Baughn> ?
06:46:04 <C-Keen> :t ((x:) *** id) $ 22 * 21
06:46:05 <lambdabot> forall b'. (Num ([Expr], b')) => ([Expr], b')
06:46:16 <C-Keen> hm..
06:46:22 <kynes> Baughn, because Hugs and GHC differs in interpretation of Haskell code.. GHC is correct btw
06:46:31 <kynes> Baughn, Hugs is not in some cases
06:46:42 <codebliss> I love hugs, but not when they have to do with computers.
06:46:49 * Whoof hugs haskell
06:46:51 <C-Keen> > ((x:) *** id)
06:46:52 <lambdabot>   Overlapping instances for GHC.Show.Show
06:46:52 <lambdabot>                              (([Sim...
06:47:06 <Baughn> kynes: And you deliberately want the broken interpretation
06:47:23 <Axman6> :t ((x:) *** id)
06:47:24 <lambdabot> forall b'. ([Expr], b') -> ([Expr], b')
06:47:28 <kynes> Baughn, I have to.. because I'm evaluating some code written using Hugs
06:47:43 <Baughn> kynes: Right. Well, option three: Write to file, run runhugs on file.
06:48:10 <ClaudiusMaximus> kynes: echo 'main = putStrLn "Hello"' | runhugs /dev/stdin   # works here on linux
06:48:14 <kynes> Baughn, yes, that was always an option I considered .. but it requires me to create like 2000 files.. separately
06:48:29 <Baughn> kynes: So? It's all automated.
06:48:40 <kynes> ClaudiusMaximus, that was the one! thanks!
06:48:43 <Baughn> At least, it /should/ be
06:49:20 <kynes> Baughn, yes it's automated but it would be too messy
06:49:41 <kynes> Baughn, ClaudiusMaximus Axman6 : thank you all for helping
06:50:07 <codebliss> The ghc manpage is inhumanly long
06:50:22 <Axman6> kynes: the normal development cycle for writing haskell, even small stuff, is you write it in a file, the load into ghci, test it, edit the file, and reload it
06:50:27 <Baughn> The html is more useful, yes. ^^;
06:50:33 <Whoof> long manpages rock... lots of options to play with
06:50:36 <Axman6> codebliss: it's a compiler, they usually are
06:50:48 <codebliss> Axman6: Just saying, it's cool =D
06:51:08 * Baughn will stick to the hyperlinked "manpage"
06:51:29 <codebliss> 1640 lines.
06:52:01 <kynes> Axman6, yes I work like that too normally.. but in this case, I'm testing many expressions with different modules (same functionality provided by different, possibly broken modules)
06:52:23 <Axman6> sounds like a job for ghci then ;)
06:52:39 <Axman6> Baughn: link... or something?
06:52:44 <kynes> Axman6, :) yes.. I'm in real pain because I didn't specify using GHCi first
06:52:59 <Axman6> you should ;)
06:53:01 <Baughn> Axman6: Um..
06:53:15 <Axman6> my man page doesn't have hyperlinks...
06:53:20 <Baughn> Axman6: file:///usr/local/share/doc/ghc/users_guide/index.html
06:53:24 <Baughn> Or so
06:53:28 <Axman6> ta
06:53:45 <nanothief> I have some code for precalculating the factors of a lot of numbers, however my haskell implementation http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2710#a2710 is running a lot slower than my cpp implementation  http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2709#a2709 . Any suggestions on getting the haskell faster?
06:56:08 <fasta> nanothief: define a lot
06:56:53 <fasta> nanothief: there is a wiki page on optimizing Haskell code. That said, there are certain things where functional Haskell is simply slower, because the compiler does not recognize your code is single-threaded.
06:57:09 <nanothief> fasta: c++ runs in 2.5 seconds, haskell runs in 38 seconds (both compiled with -O2)
06:57:24 <codebliss> Should you always use foldr instead of foldl where it doesn't matter?
06:57:37 <fasta> nanothief: also, Haskell doesn't really play well with caches.
06:57:38 <Baughn> codebliss: If it doesn't matter, then it doesn't matter
06:57:49 <codebliss> Just most of the time I see foldr...hm
06:57:51 <fasta> nanothief: so, in this case you would want to eliminate all laziness.
06:58:06 <Baughn> codebliss: http://haskell.org/haskellwiki/Stack_overflow
06:58:33 <fasta> nanothief: for example your repeat is less specified than the C++ version.
06:58:40 <fasta> nanothief: in short, apples and oranges.
06:58:51 <fasta> nanothief: I agree that it would be nice if it would run faster.
06:59:15 <nanothief>  fasta: so is there a better way to write it for better performance?
06:59:19 <fasta> nanothief: if you want people to race for the fastest implementation, send an email to Haskell Cafe.
06:59:32 <fasta> nanothief: yes, like I said: make them run the exact same algorithm.
06:59:43 <Baughn> nanothief: I see you're calculating the factors of each number independently
06:59:57 <Baughn> nanothief: It should be possible to take advantage of the earlier results to speed this up..
07:00:34 <nanothief> Baughn, not exactly, it starts with 2, and adds that as a factor to all even numbers. Then 3 to all 3,6,9... and so on
07:00:57 <fasta> nanothief: do you understand that you are asking the computer to do two very different things?
07:01:14 <fasta> nanothief: that they might compute the same is not relevant.
07:01:18 <nanothief> fasta: not really, I don't get the difference you are seeing between the c++ and haskell versions
07:01:23 <Baughn> nanothief: Hum. Also, Data.Array is probably not optimal for this..
07:01:29 <Baughn> nanothief: Have a look at uarray.
07:02:05 <nanothief> Baughn, I had a look at that, however uarrays can't store variable sized arrays in them right?
07:02:37 <fasta> nanothief: if you would look at the bitpatterns that actually occur in the machine as it does the transformations, you would see the Haskell version doing a lot more work than the C++ version.
07:03:06 <Baughn> nanothief: That's true. Hm..
07:03:10 <Axman6> :t accumArray
07:03:11 <lambdabot> forall e a i. (Ix i) => (e -> a -> e) -> e -> (i, i) -> [(i, a)] -> Array i e
07:03:46 <nanothief> fasta: yes definitely, however they are both using the same algorithm. I'm trying to find a way to write the c++ algorithm quickly in haskell.
07:04:28 <fasta> nanothief: they use the same "abstract method in your head" or use the same mathematical properties, but they do different amounts of work.
07:04:35 <fasta> nanothief: if you want to write C in Haskell, look at the FFI.
07:04:48 <fasta> nanothief: or runST if you want a safe Haskell program.
07:04:57 <Baughn> Yes, yes. Let's try to find a way of writing this fast /in haskell/.
07:05:24 <fasta> nanothief: ST would get you closer to the machine, but there is still the GC running.
07:05:26 <nanothief> well actually I wrote the program first in haskell, then in c++ to see if my algorithm was bad...
07:06:10 <fasta> nanothief: in Python the performance penalty is even worse, because the computer needs to spend a lot of time to figure out what exactly to do.
07:06:32 <Zao> Has anyone happened upon T-trees before?
07:07:17 <fasta> nanothief: in Haskell the "deciding what to do-factor" is a lot smaller, but laziness is one of these factors. The only way to get around that is not to use lazy structures and use data structures which compile to about the same as what C would do.
07:07:51 <fasta> It's not usual that people want to see how their lazy algorithm in imperative language X works in Haskell.
07:09:15 <nanothief> fasta: right. Well I'll have a look at strictness, and using runST to see if that speeds it up. The thing is, I can't think of a more efficient algorithm for generating lots of factors for numbers quickly, so I want to try and get it to work
07:09:43 <Zao> Usually algorithms go hand-in-hand with data structures.
07:09:53 <fasta> nanothief: I mean one obvious thing is that in the Haskell version, you use lists.
07:10:07 <fasta> nanothief: in the C++ version there is no such thing.
07:10:35 <fasta> A C++ vector and a Haskell list are completely different structures.
07:11:12 <Baughn> nanothief: ..meanwhile, I'll be trying to make a nice, haskelly version faster. :P
07:11:44 <Zao> fasta: Didn't the real STL have a slist<T> for singly linked lists?
07:12:03 <nanothief> fasta: definitely, however the list in the Array Int [Int] is a fairly appropriate choice, since I only ever add to that part of the array. I'm not sure about removing the values list, since that's what the accumArray function takes
07:12:18 <nanothief> Zao: I think it is just std::list<T>
07:12:26 <Zao> nanothief: That's standard C++ and doubly linked.
07:12:40 <Zao> nanothief: The original STL by HP/SGI had lots of fun stuff in it.
07:12:51 <Zao> Singly linked lists, rope-y strings, hashmaps.
07:13:15 <fasta> Zao: I didn't program a lot in C++, although I know some things about it.
07:13:33 <nanothief> oh yes single linked, forgot about that (with std::list<T>)
07:13:33 <osfameron> ah, doubly linked lists make sense in imperative datastructures?  (cos they really don't in FP, hence zippers)
07:14:11 <hyper-one> I need a little help.  I've downloaded the Darcs tree and now I'm trying to run the command  ./darcs-all --extra get.  I then get an error message --extra command not found.
07:14:21 <mauke> doubly linked lists make sense in FP if you never need to modify them :-)
07:15:31 <fasta> There are no n-place zippers, (with n known only at run-time), so they are kind of limited.
07:16:22 <fasta> If you have lots of data structures that need to reference each other by position, you can better just use ST to boot.
07:19:07 <dino-> hyper-one: I'm not sure but that sounds like part of being a developer of darcs, that script. If nobody here has experience with it, maybe on the #darcs channel
07:22:07 <int-e> nanothief: see http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2710#a2712 ... the most important realization is that garbage collection is killing your performance. (accumulating huge amounts of data in mutable arrays is a worst case in ghc's garbage collector)
07:23:17 <Baughn> *mutable boxed arrays
07:23:31 <int-e> right.
07:24:02 <jkramer> Hello
07:24:35 <Vector_> hi
07:24:48 <jkramer> I'm trying to write a very simpel interpreted language with Parsec that I can embed in a bigger application
07:24:54 <nanothief> int-e: that is excellent thanks!
07:25:07 <jkramer> Is there a good example for such a simple interpreter?
07:25:27 <jkramer> I didn't find anything that's coming close to what I want
07:25:30 <quicksilver> int-e: does it help to use an an unboxed array of Ints and then an IntMap ?
07:25:44 <nanothief> I did try using an ST array however didn't use the unsafe operations, which I think were killing performance
07:26:40 <hyper-one> I was not clear, The darcs archive is for GHC not Darcs itself.  I've been trying to get a current GHC build on my Ubuntu system and have been having a little trouble.  I have Darcs running and now I want to get the latest GHC version running on my machine.  When I first downloaded the sources they built OK, but when I was trying to do a manual install of Cabal I was getting an error about "exception" class being used as a type or so
07:26:44 <int-e> quicksilver: I don't understand the suggestion.
07:27:20 <quicksilver> int-e: you can always replace an Array i e with a UArray i Int and an IntMap e
07:27:37 <quicksilver> int-e: effecitvly taking the "pointers" out of the array and managing your own "pointers" as Ints
07:27:42 <quicksilver> I wondered if that helped.
07:27:54 <dcoutts> hyper-one: the --extra flag isn't needed anymore
07:29:02 <dino-> hyper-one: Wait, your goal is to get a recent (let's say 6.10.x) GHC on your Ubuntu system?
07:29:18 <dino-> If so, may I recommend the generic Linux binary install of GHC
07:29:22 <hyper-one> Dino: yes
07:29:48 <nanothief> int-e: is the effect of the +RTS -H500M to allocate more memory by default? Also, where do you find out about the "RTS" flags?
07:30:20 <dino-> hyper-one: This page, where it says Binary Packages, one of those: http://haskell.org/ghc/download_ghc_6_10_3.html
07:30:50 <jkramer> No hint, anyone?
07:31:01 <int-e> nanothief: -H specifies the minimum heap size. http://www.haskell.org/ghc/docs/latest/html/users_guide/runtime-control.html describes the +RTS option. +RTS --help  exists, too (but does not give a complete list of options)
07:31:41 <Gracenotes> :3
07:32:25 <nanothief> int-e, thanks
07:32:28 * edwardk waves hello.
07:32:35 <hyper-one> Dino: I tried that first but I was getting an error trying to install the cabal-install package.  Something about "exception" class being used as a type.  I gooled it and found some refference that indicated it's a problem that's been corrected on the Darcs archive
07:32:38 <lilac> does GHC's RTS's GC play nicely with other processes on the same machine?
07:32:46 * Twey greets edwardk.
07:33:03 <edwardk> hah one year later i finally got around to transcoding my old recursion scheme field guide from google reader back into my blog
07:33:36 <lilac> i ask because Sun's JVM's GC really does not...
07:33:51 <quicksilver> lilac: what specific behaviour would help?
07:33:55 <edwardk> lilac: play nice in what sense? memory pressure?
07:34:27 <edwardk> you can ask the RTS to use only so much heap space, etc. so in that sense you can control how nice you want it to be
07:34:47 <lilac> quicksilver: well, the Java situation seems to be that you set a max heap size, and the JVM quickly uses that much memory (plus a little bit) regardless of the memory needs of the app
07:35:07 <dino-> hyper-one: Ok, so you have a functioning GHC 6.10.3 and are having problems with cabal-install.
07:35:14 <lilac> edwardk: i'd like it to use less memory if the system is running low
07:35:19 <quicksilver> lilac: GHC's RTS uses bsically 3 times as much memory as it needs.
07:35:31 <hyper-one> Dino: yes that the problem
07:35:32 <quicksilver> lilac: there isn't really any room for doubt - your program either needs the memory or it doesn't.
07:35:43 <quicksilver> lilac: programs don't have a way of altering their behaviour based on free memory.
07:35:46 <lilac> quicksilver: and that's a hard bound? it won't use more just because it feels like it
07:35:58 <quicksilver> no, it will use what gets allocated times 3
07:35:59 <dino-> I'm not sure what the exception class stuff is. But how have you tried to install cabal-install? From the .tar.gz?
07:36:03 <quicksilver> plus a small fixed overhead.
07:36:26 <lilac> quicksilver: programs in general can, but i guess you mean GHC's RTS does not?
07:36:41 <quicksilver> lilac: I mean the haskell language.
07:36:52 <quicksilver> lilac: the haskell language has no API for "how much memory is there, OK I'll do this instead"
07:37:07 <quicksilver> lilac: haskell programs allocate the memory that they need. GHC's RTS will use 3x that much, plus fixed overheads.
07:37:08 <hyper-one> quicksilver: yes, I'm using the latest version of Cabal-install.
07:37:13 <lilac> right. it would need to be OS-specific in any case (and i was imagining this being part of the RTS not a program-level thing)
07:37:27 <quicksilver> but my point is there is not much the RTS can do!
07:37:28 <lilac> is the 3x limit part of the GC's design, or is it tunable?
07:37:35 <quicksilver> haskell programs allocate what they need to, to run.
07:37:40 <quicksilver> there is no flexibility there.
07:37:49 <quicksilver> if they were to do something different, the programmer would have to choose that
07:37:57 <quicksilver> I.e. it would have to be the application, not the OS or the RTS
07:38:04 <lilac> sure, but 3x is a lot of overhead
07:38:09 <int-e> quicksilver: I don't know. In this particular case, perhaps we could build the linked lists in another unboxed array instead. With the IntMap I'd expect that we could get rid of the unboxed array altogether without making any difference. I'm too lazy to try it out though.
07:38:20 <quicksilver> lilac: 3x is with the copying collector. It is 2x with the compacting collector I believe.
07:38:25 <quicksilver> int-e: yes, fair enough.
07:38:49 <lilac> quicksilver: the RTS could choose how often to perform a GC based on the amount of available memory
07:38:59 <dino-> hyper-one: I think you're saying you don't have a functioning cabal-install yet.
07:39:02 <lilac> quicksilver: and with OS support a GC could be triggered by low memory conditions
07:39:29 <dino-> Someone can correct me if this isn't accurate any longer, but I believe the thing to do is get the 0.6.2 .tar.gz from Hackage and install cabal-install with it.
07:39:31 <mux> but most UNIX OSes still lack such a mechanism
07:39:33 <lilac> but it sounds like nothing of that form happens
07:39:34 <mux> AIX has SIGDANGER
07:39:42 <Twey> SIGDANGER?  Nice
07:39:44 <hyper-one> Dino: yes, I'm using runghc to try and install everything
07:40:15 <EvilTerran> SIGDANGER, will robinson
07:40:15 <mux> Twey: isn't it?
07:40:24 <p_l> AIX even had clustering software written in Perl, so...
07:40:33 <Twey> I imagine other unices expect one to malloc() and check for null...
07:40:40 <mux> Twey: not really
07:40:41 <lilac> quicksilver: so (i'm guessing here) a GC is triggered when allocated memory reaches twice the memory at the end of the previous GC?
07:40:47 <mux> most UNIX OSes will never return NULL
07:40:54 <Twey> Really?
07:40:56 <Twey> O.O
07:40:57 <mux> because they do lazy allocation
07:41:00 <Twey> Oh
07:41:01 <quicksilver> lilac: how often you trigger a GC does not matter.
07:41:04 <Twey> Oo-er
07:41:10 <mux> you usually get a segfault when you touch the memory :-)
07:41:10 <quicksilver> lilac: (well it makes some trivial short-term difference)
07:41:17 <Twey> That's not good
07:41:20 <mux> malloc() still returns NULL when you reach administrative limits though.
07:41:21 <EvilTerran> out-of-memory is sudden, painful death
07:41:24 <dino-> hyper-one: For a new everything, like this sounds like, you'll need to run the bootstrap.sh in cabal-install's dir first.
07:41:26 <quicksilver> lilac: let us assume that the GC is magical, instant, and runs every nanosecond.
07:41:30 <lilac> quicksilver: if i allocate and then drop the reference to a billion items, then the frequency of GC makes a massive difference
07:41:32 <quicksilver> lilac: the point is - you still need ALL the live data.
07:41:38 <quicksilver> lilac: you need everything live. you just do.
07:41:47 <quicksilver> so, haskell programs always need all the memory they need.
07:41:54 <mux> Twey: yeah, it's clearly sub-optimal
07:41:54 <quicksilver> do you see what I'm trying to say?
07:41:59 <lilac> quicksilver: it's the amount of *non-live* memory that is nonetheless allocated which matters
07:42:04 <p_l> mux: depends on configuration. Reporting NULL is correct, but so many OSes now have this stupid overcommit...
07:42:10 <lilac> quicksilver: the amount of live memory is obviously needed
07:42:13 <lilac> that's NOT overhead
07:42:16 <quicksilver> lilac: and yes, there are a bazillion parameters to tune the frequence and kind of GCs operated.
07:42:17 <hyper-one> Dino: thanks I'll go give it a try
07:42:18 <dino-> It takes care of grabbing cabal-install's dependencies and installing those. That being Cabal, HTTP and zlib
07:42:26 <quicksilver> lilac: in my experience, 99.999% of memory is live.
07:42:33 <dino-> One more thing
07:42:34 <mux> Twey: there has been quite some discussion about this for FreeBSD; some people wanted to implement SIGDANGER, others wanted to implement specific malloc() options to ensure that if malloc() returns a non-NULL pointer, then the memory really is there
07:42:38 <quicksilver> lilac: GHC purges dead memory viciously and rapidly.
07:42:45 <mux> p_l: that is precisely what I was saying ;-)
07:42:46 <quicksilver> lilac: it scarcely has a chance to breathe ;)
07:42:54 <dino-> It may not be what everybody else does, but I prefer everything to be installed systemwide (not per-user)
07:42:59 <lilac> quicksilver: is that a qualitative assessment, or are there any guarantees here?
07:43:10 <p_l> mux: I have weird lags between me an my shell server, so I sent my response before I have seen yours :/
07:43:13 <dino-> So I go into the bootstrap and change the --user flags to --global
07:43:29 <lilac> quicksilver: Sun's JVM has a "good GC" according to many sources, but it's completely pathetic at this
07:43:32 <mgee> hi, how can i discard an IO type? I have a function which return IO Options, but I need IO () ...
07:43:56 <BONUS> >> return ()
07:43:56 <lambdabot> BONUS: You have 1 new message. '/msg lambdabot @messages' to read it.
07:44:06 <dino-> But I also then find it cleaner to always run cabal as root with root's ~ like: sudo -H cabal <blah blah cabal args here>
07:44:07 <BONUS> your_function >> return ()
07:44:18 <p_l> mux: AFAIK, the common API for requesting memory that *has* to be there is through mmap()
07:44:20 <EvilTerran> mgee, if you've got "foo :: IO Bar", then "do foo; return ()" will be IO (), and be the same as foo other than the result value
07:44:25 <dino-> Of course, not everybody may want to do it that way.
07:44:28 <mgee> BONUS: works! thanks
07:44:31 <EvilTerran> mgee, or, as others have said, foo >> return ()
07:44:40 <mgee> yep, works very good :)
07:44:52 <quicksilver> lilac: it's a qualitative assessment but there are some particular reasons
07:45:16 <lilac> quicksilver: what i'm trying to determine ultimately is, is there any GC implementation which is appropriate for long-lived, reasonably-high-memory-usage desktop apps? i figure if it exists, it's likely GHC has it
07:45:24 <mux> p_l: mmap() does the same overcommit
07:45:34 <quicksilver> lilac: sure. GHC's is absolutely fine for that.
07:45:40 * EvilTerran ponders __ = (>> return ()), so one could write (foo`__`), like sequence_ etc only uglier :P
07:45:42 <mux> p_l: the overcommit stuff is deep down in the kernel's VM
07:45:55 <quicksilver> lilac: most dead data is GC'ed before it even leaves the processor cache.
07:46:01 <quicksilver> lilac: it never even hits main memory.
07:46:05 <lilac> mux: you can turn it off in linux
07:46:09 <opqdonut> quicksilver: is that so?
07:46:12 <mux> lilac: yup
07:46:13 <Saizan> btw, does having a big long-lived structure hurts GC performance? since it has to copy more memory..
07:46:14 <Axman6> lilac: apple has released their GC as an open source project
07:46:16 <BONUS> EvilTerran: gwern suggested ignore x = x >> return ()
07:46:26 <quicksilver> opqdonut: yes. The size of the nursery is tuned to be smaller than typical process caches.
07:46:28 <EvilTerran> BONUS, yeah, that's probably a better name
07:46:32 <Axman6> or, the sources are available anyway, not sure if they;ve made it a 'project'
07:46:38 <opqdonut> quicksilver: cool.
07:46:51 <quicksilver> Saizan: major collections are rare, but yes, major collections are slower in that kind of situation.
07:47:03 <quicksilver> Saizan: conceivably there are workloads where a 3-generation GC is worth it
07:47:07 <BONUS> i think done = return () might be cool, so you write do foo; bar; baz; done
07:47:17 <quicksilver> Saizan: (so the big data is in the "Major Major" colelction which is even rarer)
07:47:27 <quicksilver> GHC's GC supports any number of generations but the default is two.
07:47:29 <Saizan> quicksilver: how rare? seconds? more?
07:47:37 <quicksilver> I don't recall. It's tunable.
07:47:41 <Saizan> k
07:47:45 <quicksilver> and documented, I think :)
07:47:53 <lilac> quicksilver: i believe in the case of our app, we get lots of data making it out of the young generation and then becoming unreachable
07:48:08 <quicksilver> I believe the GHC guys experimented with generations and found, to their suprise, that 2 is optimal for a wide range of situations.
07:48:21 <quicksilver> lilac: you may experiment with (1) adding another generation (2) making the nursery explicitly bigger
07:48:29 <quicksilver> there are some hints on the RTS docs IIRC.
07:48:31 <dino-> dcoutts: I've had vague thoughts in the past about cabal-install's bootstrap.sh  One being should the --user/--global be parameterized or at least changed to a variable near the beginning of the script. And (more radically) how nice would bootstrap.sh be as a Haskell script.
07:49:17 <dcoutts> dino-: I welcome patches, there's already a patch for the --global/--user thing. I've not reviewed it yet, perhaps you'd like to?
07:49:27 <dino-> That bad boy keeps getting bigger. :D
07:49:28 <quicksilver> lilac: http://www.haskell.org/ghc/docs/latest/html/users_guide/runtime-control.html#rts-options-gc
07:49:44 <dino-> dcoutts: Yes, I could do that.
07:49:46 <dino-> That patch
07:50:24 <dcoutts> dino-: http://haskell.org/pipermail/cabal-devel/2009-May/005216.html
07:51:07 <Axman6> hmm, i want to write something in haskell that's long running. everything i write with it usually runs for a minute or so, using full CPU power
07:51:10 <dcoutts> dino-: it's not worth putting a huge amount of effort in though since cabal-install is distributed with the platform
07:51:12 <p_l> mux: I meant that in theory (because Linux's VM says "fuck yourself"), mmap() on linux has MAP_RESERVE and MAP_NORESERVE
07:51:34 <dino-> dcoutts: In the sense of writing something fully Haskell for bootstrapping, I see
07:52:21 <mux> p_l: ah, that's entirely Linux-specific though
07:52:22 <dino-> I guess the question there is, is the platform going to serve people who are installing from scratch in the future and want the latest things. This is how I got to not using apt-get in the first place for GHC. It's just too damn stale unless you run with a scary unstable Debian system.
07:53:23 <p_l> mux: It appears that those flags are actually from SunOS/Solaris, and I recall them being included in *BSDs
07:53:40 <p_l> they don't exist in POSIX, at least the version of the docs I have
07:55:14 <mux> p_l: they're not on BSD, I think you're confusing with the madvise() flags
07:55:50 <mux> (which btw would be a better place to put those flags :-P)
07:56:30 <p_l> mux: last time I checked, Free/Net/OpenBSD had those flags in header files, but maybe through madvise(). I know that in Linux you can put them in mmap(), as in theory mmap() w/ NO_RESERVE should be able to mmap more memory than available on non-overcommit capable system
07:56:57 <mux> mux: they don't, I'm a former freeBSD kernel developer, and since I'm also an idiot, I checked the manpage, so I'm very, very sure.
07:58:12 <ehird> 15:56 mux: mux: they don't, I'm a former freeBSD kernel developer, and since I'm also an idiot, I checked the manpage, so I'm very, very sure.
07:58:15 <ehird> why are you talking to yourself?
07:58:52 <wjt> ehird: clause three? :)
07:58:57 <ehird> wjt: wut
07:58:59 <mux> sorry, must be because as I said, I'm an idiot =)
07:59:02 <p_l> mux: interesting. I remember finding that through grepping header files, so maybe the definitions are there for portability, but they are not supported.
07:59:08 <Baughn> ehird: Could be a split brain
07:59:10 <p_l> (also, damned network fails me)
07:59:18 <mux> p_l: I very much doubt they are even on the header files, commented or not
07:59:50 <p_l> Baughn: Not really, as split brain case would both consider themselves the one who wrote the message
08:00:29 <Baughn> p_l: Intuitively, yes. However, if it's still working well enough, it might manage to override that in order to actually transfer information.
08:00:38 <couloir> IO ensures the launching of the missiles
08:00:48 <Baughn> ..no, that's unsafePerformIO
08:02:23 <p_l> Baughn: They are too tightly coupled, AFAIK
08:03:07 <p_l> mux: source/sys/mman.h, line 73. Dunno if that works, but that's what made me think that *BSD supported it :)
08:03:23 <p_l> (only MAP_NORESERVE, there are two variants on MAP_RESERVE defined there)
08:03:40 <mux> p_l: that's totally unrelated and also unimplemented IIRC.
08:04:40 <p_l> mux: Well, it would be nice to have proper API for address space manipulations. :/
08:04:46 <mux> yup
08:05:05 <mux> I'll send some emails to know whether things have advanced in that area
08:05:33 <p_l> the funny thing is that L4 had some support (afaik no API, but the way the memory was organised would make it dead easy to implement)
08:14:38 <scriptdevil> Is there a way to locally use a library I downloaded from hackage though cabal is not installed on this system?
08:14:59 <quicksilver> yes.
08:15:04 <quicksilver> you mean cabal-install.
08:15:17 <scriptdevil> quicksilver: Yeah
08:15:17 <quicksilver> cabal-install is just a handy commandline utility, it is not necesary.
08:15:22 <quicksilver> "cabal" the library comes with GHC
08:15:29 <quicksilver> it is on your system unless you manually broke it ;)
08:15:35 <quicksilver> runhaskell Setup.hs configure
08:15:40 <quicksilver> then build, then install
08:16:13 <dino-> Don't forget test and haddock!
08:16:34 <scriptdevil> quicksilver: Do I do a runhaskell Setup.hs configure --prefix=~/hlib ? where hlib is my local library dir?
08:16:59 <lilac> quicksilver: "our app" is a java app :(
08:17:57 <quicksilver> scriptdevil: I'm sorry, I don't know. I only know about user and global. (Global goes in /usr/local, user goes in to ~/.cabal)
08:18:15 <quicksilver> lilac: ah :)
08:18:17 <scriptdevil> quicksilver: That is all that I need
08:18:49 <scriptdevil> Well, isnt parsec a part of haskell now? Setup.hs: At least the following dependencies are missing:     parsec -any
08:19:43 <Saizan> there's something that doesn't make sense to me: the more i increase the suggested heap size the more beeps i hear using -B, even if -s reports fewer collections
08:20:16 <quicksilver> scriptdevil: parsec has never been part of haskell; but aparently it wasn't part of the library bundle you installed on that machine.
08:20:27 <quicksilver> Saizan: that doesn't make sense to me either.
08:20:39 <quicksilver> Saizan: is one showing only major and the othe showing minor as well?
08:22:17 <Saizan> quicksilver: both runs have major and minors collections, if i understood your question
08:22:25 <scriptdevil> quicksilver: Where do you give user in configure?
08:22:50 <Saizan> -B should report only major collections, yes
08:23:43 <dcoutts> scriptdevil: btw, there's runhaskell Setup.hs configure --help
08:25:06 <scriptdevil> dcoutts: I did. I asked because this came up Setup.hs: /usr/local/share/doc: createDirectory: permission denied (Permission denied)
08:25:38 <dcoutts> scriptdevil: if you were using the default --global, yes
08:25:55 <dcoutts> scriptdevil: so you want --user and you said you also wanted --prefix=$HOME/hlib
08:28:00 <scriptdevil> I did both. I got Setup.hs: Unrecognised flags:  --prefix=/home/scriptdevil/hlib
08:29:07 <dcoutts> scriptdevil: did you miss the 'configure' command?
08:29:20 <dcoutts> runhaskell Setup.hs configure --user --prefix=~/hlib
08:29:57 <scriptdevil> dcoutts: I am very sorry. I did it under install by mistake.
08:30:03 <scriptdevil> I pressed up arrow :P
08:30:06 <dcoutts> np :-)
08:30:39 <boegel> scriptdevil: you should _never_ press the up arrow when using Haskell!
08:30:52 <dcoutts> scriptdevil: btw, I recommend using the 'cabal' command line tool, rather than using the old "runhaskell Setup.hs" command line interface
08:31:02 <quicksilver> dcoutts: he doesn't have it installed
08:31:06 <quicksilver> dcoutts: (hence the conversation)
08:31:10 <dcoutts> ah
08:31:17 <scriptdevil> dcoutts: I am on a university system. The lab admin is asleep
08:31:51 <boegel> scriptdevil: then wake the fucker up and slap him for not having cabal installed!
08:31:56 <dcoutts> scriptdevil: fortunately all this stuff can be installed per-user
08:32:15 <scriptdevil> boegel: I am the only person working on Haskell here.
08:32:17 <dcoutts> boegel takes the hard line
08:32:37 <scriptdevil> dcoutts: Yeah. It saves me time too.
08:33:03 <scriptdevil> boegel: I would rather say, I am the only one who gets work that also gives me pleasure
08:33:11 <dcoutts> scriptdevil: once you get the 'cabal' prog installed it's a bit easier. It defaults to per-user installs.
08:33:29 <scriptdevil> I use Archlinux at home and dons as usual made me lazy :P
08:33:43 <burp> :src sum
08:33:47 <burp> ?src sum
08:33:47 <lambdabot> sum = foldl (+) 0
08:34:00 <scriptdevil> dcoutts: I will get it once he wakes up
08:38:22 <gnuvince> wouldn't it make more sense to use foldl' for sum?
08:38:32 <dcoutts> scriptdevil: my point is you don't need to wait for anyone, if you can install things in your home dir then you can install the cabal program
08:38:53 <scriptdevil> dcoutts: I get it. Thanks
08:39:31 <dcoutts> gnuvince: foldl' was never part of H98. It's a bit silly though because either it should be foldr to allow non-strict numbers, or it should be foldl'
08:42:08 <burp> @hoogle foldl'
08:42:08 <lambdabot> Data.ByteString foldl' :: (a -> Word8 -> a) -> a -> ByteString -> a
08:42:08 <lambdabot> Data.Foldable foldl' :: Foldable t => (a -> b -> a) -> a -> t b -> a
08:42:08 <lambdabot> Data.List foldl' :: (a -> b -> a) -> a -> [b] -> a
08:43:10 <ray> gnuvince: you are absolutely correct. stupid haskell 98 :)
08:44:48 <jmcarthur_work> well, with -O2 it makes no difference, at least for sum
08:48:42 <quicksilver> jmcarthur_work: only with Int, I think
08:48:52 <quicksilver> ghc -O2 specialises sum<Int>
08:54:14 <FunctorSalad> is this a bug? I can use (/\) as an operator, but I can't infixl it
08:54:26 <FunctorSalad> (parse error)
08:55:07 <EvilTerran> > let infixl /\; (/\) = (,) in 1 /\ 2
08:55:08 <lambdabot>   (1,2)
08:55:22 <EvilTerran> > let infixl 4 /\; (/\) = (,) in 1 /\ 2 /\ 3
08:55:24 <lambdabot>   ((1,2),3)
08:55:38 <FunctorSalad> "let infixl"?
08:55:40 <FunctorSalad> :)
08:56:00 <EvilTerran> let { infixl /\; ... } in (...)
08:57:16 <FunctorSalad> still, parse error
08:57:36 <EvilTerran> well, it works in lambdabot
08:58:05 <FunctorSalad> or wait, the let form actually works
08:58:21 <FunctorSalad> but not the toplevel form...
08:58:37 <quicksilver> \ at the end of a line hmm
08:58:41 <quicksilver> are you preprocessing?
08:58:43 <quicksilver> cpp?
08:59:14 <FunctorSalad> yeah was just going to write the semicolon fixes it :)
08:59:17 <FunctorSalad> thanks
08:59:47 <quicksilver> \ at the end of a line shouldn't be special unless you're using CPP though
08:59:53 <quicksilver> and CPP is a bit broken with haskell.
08:59:55 <FunctorSalad> cpp is on indeed
09:00:12 <cads> do you guys know John Baez?
09:00:18 <FunctorSalad> hmm I like the cpp "\" for large string literals
09:00:47 <anq> Yes, cads.
09:01:24 <fasta> quicksilver: do you know how to let #define head "head" expand to "head" as opposed to some infinite recursion with plain CPP as used in GHC?
09:01:58 <fasta> cpphs didn't do this recursive expand.
09:02:15 <EvilTerran> fasta, that shouldn't infinite recurse, anyway; #defines shouldn't be substituted in string literals
09:02:35 <EvilTerran> so it should only substitute once
09:02:47 <fasta> EvilTerran: I am fairly sure that was exactly what happened. I can try again, as it has been a few days already.
09:03:23 <quicksilver> fasta: No, is the short answer.
09:03:24 <FunctorSalad> seems reasonable that they are subted in literals in the macro expansion
09:03:34 <quicksilver> I think plain CPP is deprecated though, for haskell.
09:03:39 <quicksilver> am I wrong?
09:03:50 <FunctorSalad> e.g. #define TRACE(X) (trace ("X="++show X) X)
09:04:04 <fasta> quicksilver: There is language CPP, so I doubt that.
09:04:14 <fasta> EvilTerran: odd, I cannot reproduce it now.
09:04:18 <FunctorSalad> quicksilver: it has a place at least for conditional compilation like with cabal flags I think
09:04:26 <quicksilver> FunctorSalad: can't cpphs do that?
09:04:26 <[bjoern]> Hi. Why can't I define mysum :: Int -> Int -> Int with mysum a a = 2 * a, and what should I use instead?
09:04:33 <quicksilver> I admit I don't know much about this.
09:04:53 <quicksilver> [bjoern]: you have two parameters you need to give them different names.
09:04:54 <FunctorSalad> quicksilver: I don't now whether ghc uses cpphs, actually
09:05:00 <FunctorSalad> *know
09:05:18 <dcoutts> FunctorSalad: it doesn't
09:05:28 <cads> anq, his brain makes my brain gawp in amazement
09:06:07 <quicksilver> FunctorSalad: there are a couple of other minor warts with using real CPP with haskell btu I forget what they were.
09:06:08 <cads> but that might be just because he preaches category theory so well
09:06:09 <[bjoern]> Yes, the point is, it should only match if both parameters are equivalent
09:06:31 <quicksilver> [bjoern]: you can't do that (like that)
09:06:34 <malcolmw> you can persuade ghc to use cpphs with the incantation -cpp  -pgmPcpphs  -optP--cpp
09:06:38 <quicksilver> sum a b | a == b = a * s
09:06:43 <quicksilver> [bjoern]: you can do that ^^
09:06:44 <FunctorSalad> hehe
09:06:52 <anq> cads, from my perspective, most people's brain in this very channel does that to me. ;)
09:07:52 <[bjoern]> Would anyone know the reasoning for this restriction? I could guess that sometimes code like that is written in error and so should be complained about, but other than that?
09:09:19 <FunctorSalad> it would require Eq (which usually does deep comparison)
09:09:31 <andrewe_> bjoern: what should mysum 5 7 evaluate to?
09:10:10 <[bjoern]> That would go mysum a b = a + b
09:10:56 <andrewe_> [bjoern]: wasn't the definition mysum a a = 2*a?
09:11:33 <[bjoern]> You have both, if the numbers are the same, you do 2*number, if they are different, you do number1+number2
09:11:49 <andrewe_> [bjoern]: i see
09:12:19 <FunctorSalad> [bjoern]: I don't know whether this is the actual reason, but usually you expect a pattern match to force the evaluation of just the head constructor
09:12:32 <FunctorSalad> so it might be a bit misleading...
09:12:52 <BONUS> i don't like this because it kind of silently eats laziness and forces typeclass contexts
09:13:01 <BONUS> whereas | a == b is much more explicit
09:13:11 <FunctorSalad> foo hugeTree hugeTree = ... :)
09:13:49 <BONUS> also i don't kind of see much use for it beyond add a a = 2*a, why write that out when the general case add a b = a + b has the same effect?
09:13:57 <[bjoern]> It's a common pattern in Prolog... :)
09:14:23 <[bjoern]> Well that's because I could not come up with a better minimal example
09:14:29 <eu-prleu-peupeu> hi
09:15:16 <quicksilver> [bjoern]: I think the objection is that not all things have a notion of equality
09:15:28 <quicksilver> [bjoern]: so you can't always reliably compare.
09:15:39 <quicksilver> You'd have to add an Eq constraint to patterns with multiple occurences of the same naem
09:15:48 <quicksilver> (which is what my | ... == ... guard does, of course)
09:15:56 <fasta> I guess the reason that length [return ()] doesn't work is because it is undecidable to decide whether or not the elements are ever needed?
09:16:18 <fasta> Annotating functions with this information would allow this case to work however.
09:16:26 <FunctorSalad> > length [return ()]
09:16:27 <lambdabot>   Add a type signature
09:16:36 <FunctorSalad> > length [return ()::IO ()]
09:16:37 <lambdabot>   1
09:17:11 <fasta> FunctorSalad: yes, but if the stuff inside the list has a type like I -> Do -> Not -> Care -> About -> The -> Actual -> Type, it's just more boilerplate.
09:18:04 <FunctorSalad> fasta: you mean type inference fails for the thing inside the list?
09:18:31 <fasta> FunctorSalad: the problem is that length never inspects the elements, so the types are of no interest.
09:18:52 <fasta> FunctorSalad: we will talk later or not.
09:19:40 <asoare> hi guys, can someone help me with a program in gtk2hs ? :-s http://pastebin.com/d4b1b0c9a my question is: why does line 259 draw something and line 285 doesn't ? :-s
09:22:53 <FliPPeh> How do I find out the operating system the program is running on?
09:24:11 <mauke> @hoogle os
09:24:12 <lambdabot> System.Info os :: String
09:24:12 <lambdabot> Distribution.PackageDescription OS :: OS -> ConfVar
09:24:12 <lambdabot> Distribution.System data OS
09:27:14 <dcoutts> asoare: it probably does draw something, but it's not persistent, as soon as you get another expose event then the first one draws again
09:27:46 <birdspider> hi, http://bugs.haskell.org/haskellwiki/HsLua#Example_1:_running_Lua_scripts explains usage of lua with haskell by using "Lua.dofile", but when I browse Scripting.Lua there is no such function, what did I miss ?
09:27:47 <asoare> dcoutts: I made it an expose event and now it's persistent
09:27:50 <asoare> dcoutts: thanks
09:28:23 <dcoutts> asoare: generally the technique is to use a single expose handler and only ever draw from within that
09:28:54 <dcoutts> asoare: so if you want to draw from elsewhere you change the state and request a redraw (called invalidating)
09:29:23 <dcoutts> that generates another expose event and your handler draws using the updated state
09:31:45 <FliPPeh> > intercalate "." [1,2,3]
09:31:46 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
09:31:46 <lambdabot>    arising from the literal ...
09:31:53 <FliPPeh> > intercalate "." ["1","2","3"]
09:31:55 <lambdabot>   "1.2.3"
09:32:19 <FliPPeh> > intercalate "." (map show [1,2,3])
09:32:20 <lambdabot>   "1.2.3"
09:36:06 <dever> hey all, should there be a problem trying to use cabal from behind a proxy?
09:36:17 <dever> is there an option for setting the proxy?
09:36:27 <dcoutts> dever: nope, just use the normal http proxy env var
09:36:49 <dever> hmm, thats set, I can wget stuff no bother
09:37:18 <dcoutts> dever: so eg, if you run with -v3 does it say that it's connecting to the proxy?
09:38:59 <dever> nope, heres what I get trying to isntall FileManip: FileManip-0.3.2 failed while unpacking the package. The exception was:
09:39:03 <dever> user error (Codec.Compression.Zlib: premature end of compressed stream)
09:40:08 <dever> and I get that regardless of what file I try to install
09:40:26 <dcoutts> dever: can you stick a log of cabal update -v3 on hpaste.org please?
09:40:37 <dcoutts> dever: I presume update fails too right?
09:40:59 <asoare> is there any NULL constant of type IO () ?
09:41:28 <asoare> i need to pass a value that has no meaning to a function that needs type IO ()
09:41:31 <ClaudiusMaximus> :t return ()
09:41:32 <lambdabot> forall (m :: * -> *). (Monad m) => m ()
09:41:39 <asoare> thanks
09:42:20 <ClaudiusMaximus> :t undefined :: IO ()
09:42:21 <lambdabot> IO ()
09:42:38 <ClaudiusMaximus> depending on what no meaning means
09:43:08 <asoare> I don;t care, i just need a function or value that doesn't execute any other operations
09:43:20 <asoare> and its type must be IO()
09:43:22 <dever> dcoutts: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5778#a5778
09:43:24 <hackagebot> OpenGLRaw 1.0.0.0 - A raw binding for the OpenGL graphics system (SvenPanne)
09:43:32 <dever> thats cabal ruupdate run 3 times in a row
09:43:49 <dever> ill be back in a minute, my screen doesn't seem to like updateing atm
09:44:07 <conal> asoare: i'm guessing you want a value that has a particular meaning, rather than no meaning.  specifically, the meaning of doing nothing at all.
09:44:13 <conal> asoare: right?
09:44:42 <asoare> yes
09:44:59 <conal> asoare: cool.  then i'd go with 'return ()'
09:45:03 <dever> back
09:45:21 <dever> ahh no this screen isn't updating
09:45:26 <conal> 'return ()' is what some older languages (algol?) called "skip"
09:46:10 <conal> and C calls ";"
09:46:46 <lilac> conal: i'd argue C calls it "(void)"
09:47:06 <asoare> conal: worked - thanks
09:47:08 <conal> lilac: is "(void)" an expression?  i was going for a statement.
09:47:11 <conal> asoare: :)
09:47:14 <lilac> (or at least, that's what C calls ">> return ()")
09:47:55 <conal> lilac: i don't know "(void)".  what's an example of its use?
09:48:16 <mauke> (void)42;
09:48:20 <quicksilver> (void)fopen("Hi"); // make it explicit we are ignoring the return value
09:48:29 <conal> it's a coercion?
09:48:32 <lilac> conal: it's usually used for an expression-statement to show the value is being ignored
09:48:35 <lilac> cast-to-void
09:48:37 <bremner> (void)malloc(-1);
09:49:02 <lilac> conal: it's also used in the case where you want to ignore a function argument and have the compiler not complain that you did so
09:49:18 <lilac> int f(int unused) { (void)unused; return 42; }
09:49:34 <conal> oh, wow.
09:49:38 <dcoutts> dever: http://hackage.haskell.org/trac/hackage/ticket/562#comment:6
09:49:45 <lilac> it's the closest that C has to "fmap (const ())"
09:49:49 <conal> makes sense to me.  one can relate C expressions or C statements to Haskell IO expressions.  i was doing the latter.
09:50:28 <conal> as in http://conal.net/blog/posts/the-c-language-is-purely-functional
09:50:51 <dcoutts> dever: if you have the time to experiment, it'd be interesting to try rebuilding the cabal program against HTTP-4000.0.6
09:51:19 <lilac> conal: right. but C doesn't have the last-statement-is-the-value-of-the-block feature of Haskell, perl, etc. so it's not an exact mapping onto do-notation
09:51:43 <conal> lilac: right.  both comparisons are problematic.
09:52:12 <conal> lilac: and boy do i wish C had that feature (which gcc-C has) when doing code generation from functional dsels!
09:52:32 <dever> ah tahnks dcoutts, yeah, I'm using HTTP-4000.0.7
09:52:59 <dcoutts> dever: you're the third person in as many days to report this problem, which previously I'd never seen
09:53:27 <dcoutts> dever: so if you've got the time it'd be great if you could help us track it down
09:54:04 <dever> i shall take a look when I get home, im in work so I shouldn't even be doing anything remotely haskellish now :D
09:54:42 <xian> Hi. I have a set of size k^2 and I want to efficiently generate all partitions of size k whose sets are comprised of k elements each. Example for k=2: set = [1,2,3,4], partitions = [[[1,2],[3,4]], [[1,3],[2,4]], [[1,4],[2,3]]]
09:54:56 <harlekin> @hoogle Int -> [a] -> [[a]]
09:54:56 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
09:54:57 <lambdabot> Prelude drop :: Int -> [a] -> [a]
09:54:57 <lambdabot> Prelude take :: Int -> [a] -> [a]
10:02:44 <xian> Hmm, I don't think using replicateM would be very efficient here. At least I don't see how.
10:15:32 <harlekin> xian, this wasn't an answer to your question. I was just trying to use hoogle. Sorry. ^^
10:18:43 <xian> I sort of assumed that, but wasn't entirely sure if you were trying to point me to a certain direction.
10:21:01 <jeff_s_> does anyone know why "runhaskell Setup.hs configure --ghc" for qtHaskell would tell me that "OpenGL -any" is missing, even though I just installed it without errors?
10:24:55 <conal> jeff_s_: see what 'ghc-pkg list' has to say about OpenGL.  also 'ghc-pkg describe OpenGL'
10:26:24 <jeff_s_> i'll do that, but I just tried it without the "-ghc" option that the instructions said to use and it seems to be working
10:27:15 <jeff_s_> ghc-pkg seems to know about OpenGL
10:27:24 <jeff_s_> thx for the suggestion
10:27:30 <conal> cool.  i don't know what '--ghc' means in that context.  i've never used used it.
10:29:00 <uzytkownik> @pl \x -> if head x == "." then Left x else Right x
10:29:00 <lambdabot> ap (ap (if' . ("." ==) . head) Left) Right
10:29:25 <harlekin> @src if'
10:29:25 <lambdabot> Source not found. I feel much better now.
10:29:32 <harlekin> @type if'
10:29:33 <lambdabot> Not in scope: `if''
10:30:16 <uzytkownik> @pl \x -> if head x == '.' then Left x else Right x
10:30:16 <lambdabot> ap (ap (if' . ('.' ==) . head) Left) Right
10:30:45 <harlekin> @pl \x -> if head x == '.' then Left '.' else Right x
10:30:45 <lambdabot> ap (flip if' (Left '.') . ('.' ==) . head) Right
10:32:10 <harlekin> @pl \x -> (if head x == '.' then Left else Right) x
10:32:11 <lambdabot> join (flip (flip if' Left . ('.' ==) . head) Right)
10:37:25 <conal> is if' if-then-else?  i think that @pl could be a lot neater with the permuted if, namely bool :: a -> a -> Bool -> a
10:38:31 <Baughn> It would fit tradition better, too.
10:38:55 <conal> oh -- or with liftA3 ifthenelse
10:39:39 <Baughn> conal: As for reactive.. well, joinE... futures with bottom occurence times are sneaking in. Somehow. I could use better debugging tools. :/
10:40:14 <Baughn> conal: But right now, my plan is to implement a (simpler) reactive-style library of my own. I can't do much with yours until ghc has been fixed anyway.
10:40:23 <conal> Baughn: amen! on better debugging tools.  that's where i got burnt out on debugging in february or so.
10:41:14 <Baughn> conal: There's also the fact that reactive looks very elegant, and should be nice to use, but its implementation is so tightly woven, it's hard to extract bits for testing
10:42:16 <conal> Baughn: i wonder if a reactive-alternative-implementation club has formed yet.  i keep hearing of spinoffs.
10:42:22 <Baughn> ..but even the debugging tools we /have/ tend to assume values won't be bottom quite so often
10:43:11 <Baughn> This isn't a spinoff, exactly. I just think I'll understand it better by trying to write one from scratch.
10:43:36 <conal> Baughn: i see.  i guess that's a fair description of some others' attempts also.
10:43:44 <conal> Baughn: if your intention is to stay faithful to the semantics, i'll be very interested in what you learn.
10:43:54 <Baughn> conal: They are.
10:44:21 <Baughn> Faithful to the semantics, but with more of an eye towards implementation efficiency
10:44:21 <conal> cool! :)  i mentioned because not everyone cares about semantics as much as i do.
10:44:36 <Baughn> Well, I'd rather have a working program than a fast one
10:44:38 <conal> wonderful!
10:44:50 <conal> Baughn: nice to hear :)
10:44:56 <Baughn> But I'd rather have a fast program than one that forks /eight hundred threads/ to merge sixteen events
10:45:08 <conal> wow!
10:45:09 <Baughn> It's just a bit absurd..
10:45:21 <conal> Baughn: do you know why so many?
10:45:31 <Baughn> No.
10:46:01 <conal> Baughn: oh, wait.  threads come from merging future values, and an event can have any number of future values.
10:46:04 <Baughn> In any case, I'll try to avoid that by liberal use of pseudo-imperative/unsafePerformIO programming
10:46:45 <Baughn> ..probably end up crashing GHC again
10:46:45 <conal> Baughn: okay.  be careful.  many have tried (including me), and i don't know of anyone succeeding.
10:47:03 <conal> Baughn: at least this time it'll be your bug and not theirs. :)
10:47:04 <Baughn> conal: Well, it helps that low-level code is somewhat of a specialty of mine. :)
10:47:38 <CalJohn> I'm trying to write an event handler for hinotify, but it seems to be hanging.  I have, through putStrLn's, managed to narrow the problem down to the line of the function where it reads a file into a lazy bytestring.  Why would it hang at this point?  (I am new to haskell.)
10:47:40 <conal> Baughn: if you can combine that speciality with semantic rigor, you may get there.
10:47:43 <CalJohn> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2713#a2713 <-- paste
10:47:53 <Baughn> Let's hope so. For now..
10:48:11 * Baughn walks off to play TF2. Six hours of debugging reactive is enough for one day.
10:48:25 <conal> Baughn: ack!  have fun.
10:49:12 <jmcarthur_work> an alternative-reactive-implementation club sounds great...
10:49:37 <Baughn> There's a "reactive" category on hackage, right?
10:49:41 <Baughn> (If there isn't, there should be)
10:49:45 <conal> yeah
10:49:47 <jmcarthur_work> there is
10:49:53 <jmcarthur_work> i think
10:50:03 <jmcarthur_work> reactivity or something
10:50:04 <ClaudiusMaximus> would anyone like to beta-test my computation visualizer?
10:50:15 <PeakerWork> ClaudiusMaximus: what does it do?
10:50:18 <ehird> ClaudiusMaximus: is it a computation actualizer knowledge engine like wolfram alpha?
10:50:19 <conal> jmcarthur_work: oh -- there's a "reactivity" category, but not "reactive"
10:50:43 <jmcarthur_work> oh, i wasn't making a distinction
10:50:45 <ClaudiusMaximus> PeakerWork: it generates videos of untyped lambda calculus expressions undergoing lazy graph reduction
10:50:50 <b_jonas> "computation actualizer knowledge engine" -- wow
10:51:12 <PeakerWork> ClaudiusMaximus: what input can it handle? untyped lambda calculus only? No Haskell?
10:51:26 <b_jonas> ClaudiusMaximus: ah, you're making films of crocodiles?
10:51:29 <ehird> b_jonas: Mnemonic reduction web searching engine.
10:51:33 <ClaudiusMaximus> PeakerWork: correct
10:51:48 <ClaudiusMaximus> b_jonas: crocodiles?
10:51:51 <PeakerWork> ClaudiusMaximus: Ah, sounds like a great basis to later do Haskell on? :)
10:54:10 <ClaudiusMaximus> PeakerWork: i doubt it, my code is a bit rubbish (needs more monads)
10:55:06 <PeakerWork> ClaudiusMaximus: is it very imperative?
10:56:03 <ClaudiusMaximus> PeakerWork: not sure, but there's lots of manual plumbing
11:01:18 <edwardk> hrmm. would anyone cry if i factored out most of Control.Comonad.* into a self-contained 'comonads' package and made category-extras depend on that instead?
11:01:36 <edwardk> the only breaking change i think would be to the cofree comonad, which I think I want to make into a simpler type
11:01:50 <edwardk> rather than recycle the heavy PCofree machinery
11:02:39 <pumpkin> not me
11:02:51 <jmcarthur_work> edwardk, i would prefer that
11:02:53 <conal> edwardk: sounds lovely
11:03:05 <jmcarthur_work> in fact, i would have no objections to further subdividing category-extras, even
11:03:11 <pumpkin> are you going to move to associated types and/or type families too?
11:03:18 <edwardk> I'm thinking Control.Comonad with .Coideal .Cofree .Reader .Exponent .Context .Stream .Trans and .Pointer
11:03:43 <edwardk> jmcarthur_work: yeah i keep meaning to do so, but its a fairly daunting task since there are so many interdependencies
11:04:12 <edwardk> pumpkin: i'd like to, but i think these are best expressed as fundeps to remain consistent with the mtl style
11:04:42 <edwardk> the Control.Category.* stuff i think would move nicely to type families though (which is how i had initially designed them)
11:04:46 <conal> edwardk: or lead the way and let mtl follow
11:04:53 <conal> evolve
11:05:28 <edwardk> well, they seem to be evolving on their own into monads-fd and monads-tc or whatever
11:05:38 <edwardk> just not sure i want to start supporting two variants
11:05:42 <jmcarthur_work> yeah, i would love to see a general migration from mtl to one of the nicer ones
11:06:39 <pumpkin> mmm
11:09:04 <edwardk> i'm just trying to not foist off my own idiosyncracies on the interface for no reason ;)
11:09:13 <pumpkin> lol
11:10:02 <Gracenotes> :o
11:10:58 <edwardk> i do want to go back and build a nice little class Fixpoint t where type Base t :: * -> *; inF :: Base t t -> t; outF :: t -> Base t t -- like class so you can use things like [a] as a fixpoint in a catamorphism
11:11:50 <edwardk> probably with something heavier like class Functor (Base t) => Fixpoint t
11:13:56 <edwardk> i figure if i do that and go back through and typeclass Control.Category.* i'll get a fairly decent interface. i think i'm going to drop the bifunctor combinators or factor them out into another lib. they just confuse the everliving crap out of people
11:16:40 <edwardk> the only thing that seems to lose is the ability to cleanly express a gibbons-style metamorphism, but it wins for so many other scenarios that i think its a net gain
11:16:43 <jmcarthur_work> edwardk, i love that idea. it annoys me that i can't use the *morphisms on my data structures in their common forms
11:17:02 <edwardk> that and i never bothered to build an optimized metamorphism anyways!
11:17:03 <jmcarthur_work> it's the make-or-break thing, for me
11:17:16 <CalJohn> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2713#a2713 <-- Sorry to ask again, does anyone know why this event handler would hang on B.readfile?
11:17:41 <Accolade> hello there! Can I pose questions about Haskell/ghc here?
11:17:56 <edwardk> jmcarthur: what do you think of me adopting the infix data constructor for cofree that i used in my incremental fold post?
11:18:55 <edwardk> data f :> a = (f :> a) :> a
11:19:51 <mux> looks like an inverse subtyping relation =)
11:20:05 <edwardk> the name is less explicit but it reads a lot nicer when you are looking at things folded with it
11:20:18 <edwardk> heh
11:20:20 <CalJohn> Accolade: IRC questions work better when you just go ahead and ask them, then leave them a while for people to see
11:20:44 <edwardk> Accolade: yes you can
11:22:07 <edwardk> right now i'm thinking i break category-extras up into 'comonads' 'categories' and 'morphisms' and possibly a base 'functors' package they all need
11:23:03 <jmcarthur_work> edwardk, that constructor looks pretty nice to me. i haven't read your post yet. i will need to do that later
11:23:06 <Cale> CalJohn: hmm... why might readFile block... could the file be a pipe?
11:23:14 <jmcarthur_work> skimming it, it looks elegant
11:23:32 <CalJohn> Cale: it isn't, but it is reading from /tmp, could that be related?
11:23:35 <edwardk> with the fixpoint change to the morphisms and the conversion of the control.category stuff to type families
11:24:30 <edwardk> that way the comonads and functors stuff can be stable and separated, and just use well tested old features (bare bones MPTCs) and the more experimental toys can go off and party
11:25:22 <CalJohn> Cale: apparently it does make a difference
11:25:25 <edwardk> and i can pack the parameterized and indexed esoterica into functor-extras, monad-extras and comonad-extras or something
11:25:46 <Cale> CalJohn: It's trying to read a directory as a file?
11:25:59 <CalJohn> Cale: no, it is certainly a file
11:25:59 <FunctorSalad> edwardk: sounds good, the long list of modules really is a bit intimidating :)
11:26:08 <edwardk> that should bring me down from 100+ modules in category-extras to ~10-20 per module
11:26:14 <CalJohn> Cale: moving the action to my home directory seems to make it start working
11:26:15 <edwardk> yeah
11:26:57 <Accolade> Ok, thanks! Excuse me for 'asking to ask' - as a friend pointed me out to - just wanted to make sure that it's ok here. So here goes: Couldn't match expected type `Sheep' against inferred type `Int' In the second argument of `(>>=)', namely `addSheepCount'
11:26:57 <Accolade> Is it correct, that this means that the conflict can be in any of the function's (here: addSheepCount) parameters or its return value?
11:27:21 <Baughn> edwardk: Oh yeah. What I'd like to see (which may already exist, but you're handy to ask) is a nice overview of /why/ I should use category-extras. :)
11:28:07 <Cale> Accolade: What's the type of addSheepCount?
11:28:13 <uzytkownik> @pl \x -> if head x == '.' then '.':x else x
11:28:14 <lambdabot> join (ap (if' . ('.' ==) . head) ('.' :))
11:28:20 <PeakerWork> Baughn: I think its for similar reasons you'd want to use the Monad type-class?
11:28:23 <edwardk> Baughn: hah, fair enough. i mostly use the stuff in the 'comonads' and 'functors' sections that i'm looking to splinter off because they aren't available anywhere else. i use cofree comonads a lot because i find almost any annotated structure can be expressed as one cleanly
11:28:27 <CalJohn> Cale: thanks for the prompt, btw
11:28:27 <Accolade> addSheepCount :: Sheep -> Int -> State DB Int
11:28:37 <paolino> Accolade: looks like the first argument of >>= is producing a Int
11:28:44 <Baughn> PeakerWork: Sure, but it took quite a lot of reading to figure out why I'd want to use Monad
11:29:01 <Cale> Accolade: Okay, so that's probably the wrong type for the right parameter to >>=
11:29:11 <uzytkownik> @pl \f x -> if f x then Right x else Left x
11:29:11 <lambdabot> (`ap` Left) . (`ap` Right) . (if' .)
11:29:22 <Cale> (at least, assuming that you want to use the State monad)
11:29:49 <edwardk> i use the bifunctor combinators in control.functor.combinators because they let me define things like derivatives once by using those combinators rather than a home grown ADT.
11:29:55 <Cale> Accolade: If you were to partially apply it to a Sheep, then it would have type  Int -> State DB Int, which you could combine with a State DB Int using >>=
11:29:57 <Accolade> The monad is actually State s, State DB in particular.
11:30:10 <Cale> Accolade: What's the rest of the expression?
11:30:19 <Cale> Accolade: Indeed.
11:30:20 <Accolade> Cale: exactly, that was my idea.
11:30:39 <edwardk> i use the stuff in control.category.* because i can define something that works like an arrow but is bidirectional. i.e. benjamin pierce's 'lens' stuff, which aren't quite arrows
11:30:47 <jmcarthur_work> Accolade, hpaste.org
11:30:49 <Accolade> Cale: this one? addSheeps = foldl (>>= addSheepCount) (return 0)
11:30:54 <jmcarthur_work> if it's long, i mean
11:30:56 <Cale> Accolade: So that would look like  myStateDBInt >>= addSheepCount mySheep
11:31:13 <edwardk> the control.morphism.* stuff is mostly mental masturbation though ;)
11:31:24 <Cale> ah, okay
11:31:31 <kig> is there a gl + window system event handling library that recurses a state accumulator over the event loop? (then again, how do you handle timer events with that?)
11:31:43 <Accolade> jmcarthur_work: I'm not sure which parts are relevant. I originally meant to pose a general question on the compiler feedback (not on my homework, lol ;-)
11:31:46 <kig> *timers
11:32:07 <Cale> Accolade: you want (\a s -> a >>= addSheepCount s)
11:32:26 <FunctorSalad> edwardk: one nice thing I noticed about functor-algebra-folds is that they can be applied to a zipper
11:32:27 <jmcarthur_work> Accolade, we are willing to help with homework here as long as you don't intend for us to do it for you. we get a lot of homework questions
11:32:34 <Cale> Accolade: That operator section applies >>= to addSheepCount alone, which isn't what you want
11:32:51 <edwardk> FunctorSalad: incrementally?
11:32:52 <Cale> Accolade: (you want it applied to a sheep before that)
11:33:00 <jmcarthur_work> Accolade, plus a lot of us have the attitude that if you are getting direct answers for your homework from us (cheating, essentially) then you're just making things harder for yourself in the long run anyway
11:33:18 <edwardk> thats basically the approach i take when i build things up in my parser combinators ;)
11:33:19 <FunctorSalad> edwardk: e.g., say you have an algebra for pretty printing and want to print the thing focused by the zipper with different background :)
11:33:28 <edwardk> yeah
11:33:38 <Accolade> jmcarthur_work: That's nice. In fact, I prefer to do it myself anyway for greater skill gain! ;)
11:33:38 <edwardk> then we're talking about the same thing
11:33:53 <edwardk> great example btw
11:33:57 <Accolade> Btw, sorry to you three responding, I'm not catching up! :(
11:34:07 <Cale> Warning: I will typically steal your homework problems from you if you tell me too much about them. ;)
11:34:16 <FunctorSalad> edwardk: I'm using the "zipper" package btw, are there zippers in -extras too?
11:34:29 <Accolade> Cale: Ok thanks for warning me, I'll be wary... ;)
11:35:08 <edwardk> FunctorSalad: i started to add them so i could have a nice 'pointing' comonad, but never finished adding them
11:35:15 <jmcarthur_work> Accolade, then you are the kind of person that belongs here :)
11:35:17 <paolino> Accolade: the firts argument of (>>=) is  passing a Int to a function expecting a Sheep
11:35:32 <paolino> :t (>>=)
11:35:34 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
11:35:36 <Accolade> jmcarthur_work: Thanks, that's kind. ^^
11:35:48 <mib_76g1dj> hi all
11:35:55 <paolino> Accolade: it's tha 'a' there
11:35:57 <edwardk> they were the original motivation behind the functor combinators, i needed type level Ap, etc. to be able to build the derivatives for the zipper
11:36:09 <Cale> I think everyone has a responsibility to think about their homework problems for their own benefit, and so if someone asks for a solution, I don't hesitate to answer if I have the time to do so. It's their loss if it means that they didn't get to think about the question.
11:36:09 <Cale> :)
11:36:45 <SamB> Cale: well, I think it's sometimes usefull to remind them of that fact ...
11:36:51 <SamB> rather than just telling them
11:36:55 <FunctorSalad> edwardk: hmm is there an advantage to building zippers in the type system rather than with TH? (the mechanism in the "zipper" package is very complicated)
11:37:30 <Baughn> FunctorSalad: Well, you get bonus points
11:37:48 <FunctorSalad> (but it supports mutually recursive types :))
11:37:56 <SamB> FunctorSalad: one may be more portable than the other
11:38:02 <SamB> ... just don't ask me which!
11:38:13 <edwardk> FunctorSalad: well, the type system one is more likely to be correct and consistent if it compiles because its fully evaluated rather than just the cases that have emerged in practice
11:38:24 <SamB> that's true
11:38:31 <FunctorSalad> *nod*
11:39:22 <Accolade> paolino, Cale, jmcarthur_work: I'm copying your answers over to another window and try to go through them so talk to you in some minutes. :)
11:39:37 <jmcarthur_work> i don't think i really helped at all ;)
11:39:48 <mib_76g1dj> I've inherited a haskell app that uses some packages that are (from what  I can tell) no longer a part of hackage. Specifically, System.Log.Logger.DateStamp and Text.Regex. I am having trouble finding info on them. Am I simply missing them on hackage? Are they part of core haskell?
11:40:17 <edwardk> the other argument was that it generated something that i could invoke polymorphically, which i needed for some GADT based zippers
11:40:23 <SamB> @google System.Log.Logger.DateStamp
11:40:23 <lambdabot> No Result Found.
11:40:41 <edwardk> i.e. i have a zipper i use that walks down a GADT based applicative, (its not build by those combinators though!)
11:41:07 <C-Keen> what are MonadWriters used for?
11:41:24 <SamB> mib_76g1dj: google the module names, maybe?
11:41:25 <Cale> I would have thought the first was from http://hackage.haskell.org/package/hslogger but the latest version doesn't appear to have that module...
11:41:35 <Cale> Perhaps its contents were moved...
11:41:41 <SamB> despite lambdabot's failure to find anything, you get results if you search manually
11:41:46 <SamB> Cale: hmm
11:41:49 <SamB> well, it's in 1.02
11:41:50 <FunctorSalad> edwardk: that sounds crazy
11:41:51 <SamB> er.
11:41:52 <FunctorSalad> :)
11:41:53 <SamB> 1.0.2
11:42:15 <mib_76g1dj> SamB: is it common to have packages wiped out of hackage?
11:42:15 <edwardk> C-Keen: I use a MonadWriter when I want to log what i've done, or update some monoid like a counter or maximum value seen so far
11:42:21 <SamB> I think
11:42:29 <FunctorSalad> the type has two parameters, one a GADT parameter, the other for the applicative? :)
11:42:36 <edwardk> FunctorSalad: its not so bad, but it does make you think.
11:42:39 <SamB> oh, datestamp is just a datatype I think
11:42:43 <Cale> ah
11:42:50 <SamB> or ... not
11:43:00 * SamB should have quoted his query...
11:43:01 <Cale> I don't see it anywhere
11:43:12 <SamB> huh
11:43:16 <SamB> maybe it never existed?
11:43:57 <Cale> anyway, Text.Regex can be obtained from http://hackage.haskell.org/package/regex-compat
11:44:09 <SamB> mib_76g1dj: who'd you inherit it from ?
11:44:12 <edwardk> i don't have the code in front of me at the moment, but the gist is I have a GADT like data Grammar t a where App :: Grammar t (a -> b) -> Grammar t a -> Grammar t b; Pure :: (a -> b) -> Grammar t (a -> b); Symbol :: t -> Grammar t t; ...
11:44:15 <SamB> maybe he has a module called that?
11:44:20 <Cale> It's old though. There are newer regex libraries which are better.
11:44:34 <mib_76g1dj> SamB: a co-worker that left :(
11:45:06 <edwardk> and a Path GADT for walking down it. i know the leaves that i'm concerned with are all Symbol nodes so I know concretely the type of the leaves
11:45:10 <mib_76g1dj> I looked, it looks like stuff that was installed on the system (via cabal or however)
11:45:15 <edwardk> but the type along the path changes
11:45:41 <mib_76g1dj> Cale: ok thanks
11:45:48 <FunctorSalad> t is constant apparently
11:45:49 <C-Keen> edwardk: ok
11:45:52 <edwardk> so i need to tell my path the type of the root of the grammar that it is descending through
11:46:09 <Cale> edwardk: You're reminding me a bit of palomer, perhaps you'll be capable of what he was trying to do. :)
11:46:32 <edwardk> cale: ?
11:46:33 <FunctorSalad> who is that?
11:46:36 <edwardk> @quote palomer
11:46:36 <lambdabot> No quotes match. I've seen penguins that can type better than that.
11:46:40 <Cale> @palomer
11:46:41 <lambdabot> xml stands for "xtremely mild lullaby"
11:46:44 <Cale> hehe
11:47:07 <edwardk> i mostly remember him moping about depressed on channel ;)
11:47:20 <edwardk> i don't remember what he was trying to accomplish at the time
11:47:30 <Cale> For a very long time it seems he was trying to construct a GADT based parser framework, but somehow he ran into complicated difficulties. I think GADTs had some problems back then.
11:47:38 <edwardk> ah
11:47:49 <edwardk> the gadt stuff works fine and dandy actually
11:48:10 <edwardk> the reason i haven't been all that keen on playing with it lately is i haven't found any practical wins yet in performance
11:48:18 <FunctorSalad> could use 'deriving' support though
11:48:39 <SamB> Cale: infelicities in the type sytem specifications?
11:49:12 <edwardk> either my constants wind up huge or my chunking introduces a new 'n' term that means i don't get any win out of chunking the input n ways or ...
11:49:15 <Accolade> So, first the easy one. ;) jmcarthur_work: Ok, thanks for the meta-infos! I agree that we have the same approach to helping (to help oneself). :)
11:49:26 <Cale> SamB: Possibly, anyway.
11:49:39 <edwardk> or i wind up with so many side conditions on error productions that you are limited to rather academic examples, etc.
11:50:02 <Cale> He was mostly motivated by the fact that monadic parsers don't support left recursion.
11:50:18 <Philippa> yeah, which is just... obsessive
11:50:19 <lambdabot> Philippa: You have 1 new message. '/msg lambdabot @messages' to read it.
11:50:22 <FunctorSalad> edwardk: what is the context? (what sort of app are you building there?)
11:51:22 <Cale> @yhjulwwiefzojcbxybbruweejw
11:51:22 <lambdabot> Just 'J'
11:52:10 <edwardk> FunctorSalad: oh, so back to the path thing, data Path r t a where Root :: Path r t r; AppL :: Path r t (a -> b) -> Grammar r t a -> Path r t b; AppR :: Grammar r t (a -> b) -> Path r t a -> Path r t b -- (off the cuff, so don't expect perfection)
11:52:21 <yitz> @whatsWithTheSeeminglyRandomLambdabotCommandNames
11:52:21 <lambdabot> Unknown command, try @list
11:52:37 <edwardk> lets you walk down the tree on a path, but you know all your 'leaves' are Symbol nodes, so you'll have a Path r t t in the end
11:52:37 <Taejo> :( -- I just unregistered all my packages -- is it possible to reregister them without rebuilding from source?
11:52:39 <Cale> Accolade: But also don't be afraid to ask questions here! It's often easier than digging through documentation, and people generally enjoy helping.
11:52:51 <edwardk> so if you want to enumerate all the Symbol nodes with their paths you can generate something like
11:52:58 <deeflex> Hey can someone help me with this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5783#a5783 . "Pattern match failure"
11:53:03 <Accolade> Cale: that's great to hear, thanks!
11:53:04 <lilac> why doesn't \b say 'unknown command, try <url that @list points you at>?
11:53:33 <FunctorSalad> edwardk: am I understanding correctly that "Grammar" essentially represents quoted applications?
11:53:57 <yitz> lilac: last I checked, that url was so far out of date that it doesn't matter
11:54:04 <edwardk> type Leaves r = [(Path r t t, t)] -- which will give you all of the leaf level symbols in a Grammar of type r.
11:54:26 <edwardk> read 'Parser' or 'Parsec' where i say Grammar, i say grammar instead because you can recycle a grammar for multiple parsers.
11:54:37 <edwardk> you say something like
11:55:06 <Cale> deeflex: hmmm
11:55:11 <lilac> deeflex: i'm guessing the lambda in the map in newdi is receiving a list which doesn't have 2 elements
11:55:15 <Cale> deeflex: Can you try it in ghci?
11:55:16 <edwardk> many p = ps where ps = (:) <$> p <*> ps <|> pure [] -- is a valid Grammar in this framework
11:55:28 <Cale> deeflex: I can imagine one problem in particular...
11:55:48 <deeflex> Cale, I am installing ghc right now. Running hugs atm.
11:55:54 <Cale> deeflex: what happens if groupedValues comes up with a list which has something other than 2 elements?
11:56:15 <edwardk> (assuming you extend the above example with a Grammar constructor for alternatives like Alt :: [Grammar t a] -> Grammar t a )
11:56:24 <Cale> deeflex: It's not altogether obvious that it can't.
11:56:26 <deeflex> Cale, It shouldn't :)
11:56:29 <edwardk> so you can compile <|> and empty
11:56:37 <deeflex> Cale, Oh I see..
11:57:10 <edwardk> FunctorSalad: but yeah, basically the grammar is just an applicative expressed in GADT form
11:57:22 <edwardk> with some extra node types added to make it useful
11:57:42 <ehird> i wish where was a convenient way to inject monads into a stack without a bunch of liftery
11:58:06 <FunctorSalad> edwardk: the problem is storing the intermediate types in the path? apparently "zipper" stores them as existentials (over your family of types, so it's not so bad)
11:59:00 <edwardk> FunctorSalad: thats why Path is a GADT, because as i recurse into the left side of an application the type of the current node changes from a Grammar b to a Grammar (a -> b) for some other type a
11:59:44 <edwardk> but i can be tricky and recover type info at the leaves because i know that a leave in a grammar always has a given type
12:00:27 <edwardk> i abuse this and some extra-linguistic sharing info extracted from stable names to build the parsers and handle things like the left-recursion cale was mentioning
12:01:23 <Cale> Yeah, from looking at your code before, it occurs to me that you're doing some tricky things which palomer hadn't tried :)
12:01:39 <Cale> There was some unsafeCoercing in there too, wasn't there?
12:01:55 <edwardk> i need to put up a new version of parsimony on comonad.com later
12:02:06 <edwardk> yeah, but i've retired that for now
12:02:12 <edwardk> i found a safer way to get the functionality
12:02:17 <Cale> ah, good :)
12:02:21 <p_l> btw, has anyone any recommendations for a tool to see which pages are shared by processes? I'm interested mainly to see how COW semantics of fork() work with GCed language
12:03:08 <edwardk> by building up a right-seminnearring as an incremental fold over my alternative i can be sure that i get a consistent recognizer and applicative parser.
12:03:52 <edwardk> (if you only need recognition you can bypass (or more importantly share) all the pure nodes since you'll discard the information anyways
12:03:57 <deeflex> Cale, Tried it in ghci6 : *** Exception: Neighbor.hs:46:32-115: Non-exhaustive patterns in lambda
12:04:10 <Cale> deeflex: aha, that's more revealing isn't it?
12:04:31 <Cale> deeflex: The only lambda pattern you have is that (\[x,y] -> ...)
12:04:34 <edwardk> this can lead to increased sharing because the undecidability of the equivalence of functions is what is the biggest barrier to sharing in my parsers
12:04:38 <deeflex> Cale, indeed. Don't know why I've been running hugs
12:04:39 <FunctorSalad> *headspins*
12:05:35 <ehird> is there a decent, minimalist haskell w/s?
12:05:38 <ehird> webserver
12:05:46 <ehird> just for dev stuff
12:05:53 <edwardk> FunctorSalad: http://comonad.com/haskell/parsimony/dist/doc/html/parsimony/Text-Parsimony-Prim.html was the original version of what cale was talking about back when i used to abuse unsafeCoerce
12:06:53 <CalJohn> deeflex: if you can also use -Wall with ghci, which would have told you off for having non-exhaustive patterns straight before runtime
12:07:00 <edwardk> I had the notion of a 'Parser Recognizing Char a' -- and a 'Parser Parsing Char a' which were capable of just telling you that you had a match or were capable of extracting an a (or an arbitrary Alternative worth of 'a's) from a match
12:07:03 <CalJohn> *straight away
12:07:21 <Cale> ehird: There are a few webserver libraries available on hackage... I can't really tell you a concrete opinion about how good they are.
12:07:24 <FunctorSalad> edwardk: sorry this is a bit over my head... still in the process of completely understanding regular zippers ;)
12:07:27 <edwardk> since the argument 'a' is irrelevant for 'Parser Recognizing Char a' I unsafecoerce it away
12:07:46 <ehird> Cale: Orly? I haven't found any actual web servers.
12:07:56 <Cale> ehird: But for example, mohws and salvia look like they might be the sort of thing you're looking for
12:07:57 <deeflex> CalJohn, OK
12:08:14 <ehird> mohws is far too general purpose for me
12:08:21 <FliPPeh> Say I want to create a scripting language for my shiny new bot...
12:08:26 <FliPPeh> What'd be a good start?
12:08:26 <edwardk> later i wanted to simplify the types and only have one kind of parser, which led to the scheme i was mentioning above where i calculated it as an incremental fold
12:08:28 <ehird> salvia,
12:08:29 <ehird> Lightweight Haskell Web Server Framework with modular support for serving static files, directories indices, default error responses, connection counting and logging, HEAD and PUT requests, keep-alives, custom banner printing, default handler environments for parsing request and printing responses, dispatching based on request methods, URI, paths and filename extension, URI rewriting and redirection, virtual hosting, cookie, session and user management an
12:08:33 <ehird> d more...
12:08:35 <ehird> ditto
12:08:52 <ehird> I just want something that'll start a socket, listen for multiple requests, hand off to a handler function, really
12:09:00 <ehird> like ruby's mongrel.
12:09:32 <sm> ehird: happstack isn't the most minimal lib, but it does that
12:09:48 <Cale> http://hackage.haskell.org/package/httpd-shed ?
12:09:53 <ehird> sm: yeah, uh, no... happstack does the world and a million other things
12:10:05 <sm> only if you want
12:10:14 <ehird> Cale: that could work, but it requires your handler to be in IO
12:10:17 <ehird> instead of just MonadIO
12:10:25 <Cale> Why is that a problem?
12:10:46 <dirk_> I want to unpack somthing so I got \x -> ...    and x=Str "abc", and I want "abc"
12:10:53 <ehird> Cale: because my handler isn't in IO, it's in MonadIO
12:11:09 <Cale> Can't you simply run whatever stack of monad transformers beforehand?
12:11:26 <ehird> Cale: not if it maintains such monadic state across requests.
12:11:32 <ehird> (for efficiency & caching purposes.)
12:11:43 <Cale> But IO already has facilities for state
12:11:52 <ehird> I am well aware...
12:12:01 <Cale> (so you should never have to StateT over IO)
12:12:17 <ehird> Cale: Sure, you should.
12:12:22 <ehird> It is more organized than a pile of IORefs.
12:12:37 <Cale> You could ReaderT (package of IORefs) IO
12:13:00 <ehird> This doesn't change the fact that going into IO really isn't practical for my situation
12:13:04 <ehird> Guess I'll write my own server...
12:13:38 <dirk_> usually I would write   f (Str y)= ...
12:13:47 <dirk_> but I don't want to define f
12:13:54 <dirk_> I want to  use \x ->
12:13:58 <Cale> dirk_: It's possible to write (\(Str x) -> ...)
12:14:02 <dirk_> ok
12:14:04 <dirk_> I see
12:14:07 <Cale> dirk_: But if there are other cases, you should really use case
12:14:22 <dirk_> there is one case
12:14:23 <Cale> (\u -> case u of Str x -> ...; Other y -> ...)
12:14:36 <dirk_> ok but thanks anyway
12:14:42 <dirk_> will need it sooner or later
12:15:17 <Cale> But if it's inside a lambda like that, I usually find it easier just to use let/where to define it separately.
12:15:31 <Cale> (and not use lambda)
12:15:45 <dirk_> ok
12:17:43 <Cale> (except in the case which you have, which is where there's only one possible pattern)
12:23:38 <deeflex> Cale, how do I use where in the ghci prompt? neighbor di where di = <long list> yields parse error on input `where'  :(
12:23:42 <Accolade> Cale, paolino: I read your messages. I'm not all sure I understood though. Maybe you misunderstood my intention - I'm adding the type signature: addSheeps :: [Sheep] -> State DB Int
12:23:42 <Accolade> addSheeps = foldl (flip (>>= addSheepCount)) (return 0)
12:23:42 <Accolade> addSheepCount :: Sheep -> Int -> State DB Int
12:24:12 <Cale> deeflex: 'where' isn't part of expression syntax, but declaration syntax
12:24:19 <Accolade> paolino, the Int is supposed to be the 'a'.
12:24:26 <Cale> Accolade: I did understand
12:24:34 <deeflex> Cale, ok worked in hugs tho :)
12:24:41 <Cale> Accolade: (>>= addSheepCount) has the wrong type
12:24:43 <Accolade> btw, the flip up there didn't fix it
12:25:05 <Cale> Accolade: Because you want (\a s -> a >>= addSheepCount s)
12:25:18 <Cale> and that is *not* the same as (>>= addSheepCount)
12:25:26 <ehird> bleh; no way I want to parse http
12:25:43 <Cale> deeflex: You can use let instead
12:26:26 <Cale> deeflex: ghci also allows you to write  let foo = bar  on its own, and it will make that temporary definition
12:26:37 <Accolade> is "\a s ->" the same as "\a -> \s ->" ?
12:26:38 <deeflex> Cale, that's REALLY good
12:27:07 <Cale> Accolade: Apart from a very minor technical detail, yes.
12:27:42 <skorpan> Cale: what detail is that?  (brace for monomorphism restriction...)
12:27:54 <Cale> Nothing to do with the MR this time
12:28:07 <Cale> It's a subtle detail regarding strictness...
12:28:22 <Cale> Let's see if I can remember how to trigger it :)
12:29:00 <FunctorSalad> the lambda isn't touched by seq?
12:30:09 <FunctorSalad> nevermind, different problem
12:31:14 <roconnor> skorpan: they aren't the same if patterns get involved in the lambdas.
12:31:48 <deeflex> Cale, how do I import Observe? The old import Hugs.Observe doesn't work obviously ;)
12:32:22 <roconnor> skorpan: where the case statement gets created differes between \pat1 -> \pat2 -> and \pat1 pat2 ->
12:32:42 <roconnor> skorpan: and seq might be able to semi-tell them apart.
12:32:47 <Cale> deeflex: I'm not sure what that is.
12:32:59 <deeflex> Cale, for debugging.
12:35:23 <Cale> deeflex: ghci has a debugger built into it.
12:35:31 <Cale> deeflex: I'm not certain about how good it is yet.
12:35:51 <Cale> deeflex: For printing messages as expressions get evaluated, there's Debug.Trace
12:35:52 <opqdonut> it's pretty nice
12:37:10 <Accolade> Cale, I don't get it. "a >>= addSheepCount s"? Is that the a from ":t (>>=)"? Because I thought the left side must be a 'filled' monad.
12:37:32 <deeflex> Cale, ok cool
12:38:02 <Accolade> (the left side of ">>=")
12:38:27 <opqdonut> :t (>>=)
12:38:28 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
12:38:32 <opqdonut> or rather
12:38:37 <opqdonut> :t x? >>= f?
12:38:38 <lambdabot> parse error on input `>>='
12:38:46 <opqdonut> :t ?x >>= ?f
12:38:47 <lambdabot> forall (m :: * -> *) a b. (?x::m a, ?f::a -> m b, Monad m) => m b
12:38:51 <opqdonut> there, see
12:38:58 <Cale> Accolade: The problem is that addSheepCount :: Sheep -> Int -> State DB Int
12:39:05 <opqdonut> left side is of type "m a", right side of type "a -> m b"
12:39:16 <Cale> Accolade: which is the *wrong* type for the second parameter to >>=
12:39:24 <Cale> Accolade: You need to apply it to a sheep first.
12:39:34 <kniu> So I got an interpreter.
12:40:09 <kniu> Thing is, getLine is sometimes not sufficient.
12:40:32 <Accolade> Cale, that Sheep is supposla to come from the list: addSheeps :: [Sheep] -> State DB Int
12:40:32 <Accolade>    //   addSheeps = foldl (flip (>>= addSheepCount)) (return 0)
12:40:43 <Accolade> *supposed
12:40:43 <kniu> I want to use the arrow keys and be able to remember previous entries.
12:40:47 <kniu> is there a library for that.
12:40:48 <kniu> ?
12:40:55 <Cale> Accolade: yes, that's wrong. It doesn't mean what you think it does.
12:41:54 <Cale> Accolade: (>>= addSheepCount) is not the same as (\a s -> a >>= addSheepCount s)
12:42:23 <Cale> (and I'm not sure what the flip is for, but it's not helping either)
12:42:43 <roconnor> map (wake `up`) sheeple
12:42:54 <Accolade> heh
12:44:13 <byorgey> kniu: readline or editline
12:44:17 <b_jonas> @type up
12:44:18 <lambdabot> Not in scope: `up'
12:44:23 <byorgey> kniu: or haskelline
12:44:33 <kniu> oh
12:44:34 <kniu> thanks
12:44:47 <Accolade> Cale, what (type) is your a? (I take it your s is a Sheep.)
12:44:52 <byorgey> kniu: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/haskeline
12:45:10 <b_jonas> or just run the program with rlwrap, that's my favourite method, and it's sufficent if you don't want the program to give settings and hints for readline (like tab expansions and stuff)
12:45:21 <FliPPeh> clean = dropWhile (== ' ') . reverse . dropWhile (== ' ') .reverse :: String -> String
12:45:30 <FliPPeh> Any nicer way to cut all spaces on both ends of a string?
12:47:01 <kniu> rlwrap works like a charm.
12:47:47 <Cale> Accolade: State DB Int
12:47:58 <FliPPeh> ;t rkwrao
12:48:00 <Accolade> oh ok
12:48:01 <FliPPeh> :t rlwrap
12:48:02 <lambdabot> Not in scope: `rlwrap'
12:48:38 <dever_> dcoutts: what was the ticket number for the problem with cabal???
12:48:49 <b_jonas> FliPPeh: http://utopia.knoware.nl/~hlub/uck/rlwrap/
12:49:27 <dcoutts> dever: http://hackage.haskell.org/trac/hackage/ticket/562
12:49:36 <dever_> dcoutts: cool, cheers
12:51:20 <michaeldever> damnit, what was that again? :)
12:52:09 <Accolade> Cale, seems you're right, thanks! Though I still didn't 100% get it, maybe after a break. I worked on this all day. -_-
12:53:39 <michaeldever> ???
12:54:17 <michaeldever> ah nevermind, got it
12:54:59 <Accolade> Now that we got that sorted out, I'll try again in a more abstracted way for my orginial question: What is the general meaning of ghc error "Couldn't match expected type `a' against inferred type `b' In the second argument of `f', namely `exp'"?
12:56:22 <ClaudiusMaximus> Accolade: ghc thinks f :: _ -> a -> _  and exp :: b   so   f _ exp   is an error
12:56:44 <byorgey> Accolade: it means that just by looking at 'exp', GHC figured out that its type is 'b', but from the context in which it was used, GHC was expecting something of type 'a' there instead of 'exp'
12:56:52 <Cale> Accolade: It means that GHC inferred the type b for the term exp, but that the context which exp is in (specifically a parameter to f) requires an a
12:57:07 <Cale> It's probably the most common type of type error :)
12:59:06 <Accolade> I figured it may pertain to any of the parameters that exp can take (if it's a function expression) or it's return value. But I take it from your answers that it is always the return value (which seems more logical, but it seemed to contradict my earlier problem (I'll have another look at it)).
13:01:36 <Accolade> Check this out: (Before Cale kindly fixed my mistake ;) I had: Couldn't match expected type `Sheep' against inferred type `Int' In the second argument of `(>>=)', namely `addSheepCount'
13:01:36 <Accolade> addSheepCount :: Sheep -> Int -> State DB Int
13:02:08 <Cale> Accolade: Ah, I suppose that it can
13:02:28 <Accolade> So the compiler stated that addSheepCount :: Int, but obviously it's not.
13:02:36 <Cale> Accolade: It tells you exactly which types didn't match, even if they're only part of the type of the term involved.
13:02:55 <Accolade> Oh, I think I got the culprit.
13:03:08 <Cale> addSheepCount takes a Sheep as a parameter
13:03:25 <Cale> but you're using it like it takes an Int as a parameter
13:03:35 <Cale> That's why it's complaining.
13:03:36 <Accolade> addSheepCount contradicts its type declaration: 			then return (count + 1)
13:03:46 <Cale> There's more wrong with the type than just that, actually.
13:03:59 <Accolade> which was supposed to use the Monad's     return a = State (\s -> (a,s))
13:04:57 <jeffersonheard> you know, it occurs to me that I could rewrite the entirety of GTK using nothing but the TreeView
13:05:07 <roderyk> in HSparklines, using the bar graph, what does the step designate?
13:05:14 <jeffersonheard> I don't exactly consider this a compliment to the TreeView's architecture...
13:06:19 <Accolade> Cale, so my "return"-theory was wrong? But so the ghc error message did in fact pertain to addSheepCount's argument and not it's return value?
13:06:36 <Cale> Accolade: yeah
13:06:52 <MyCatVerbs> Accolade: addSheepCount? Are you writing a Haskell program to sing you to sleep or something?
13:06:53 <Cale> Accolade: It's not only the wrong parameter type though, the result is in the wrong monad
13:07:14 <Accolade> MyCatVerbs, hehe kinda I guess.
13:07:33 <Cale> Accolade: So actually, the typechecker would have done a better job telling you the error at a higher level... it's just a quirk of the way that the typechecker works that it didn't.
13:07:57 <Accolade> uh huh
13:08:35 <Cale> Sheep -> (Int -> State DB Int)  could be the appropriate type for the second parameter to >>= if you're working in the (->) Int monad.
13:09:14 <Cale> x >>= f will typecheck if x :: Int -> Sheep and f :: Sheep -> Int -> State DB Int
13:09:30 <Accolade> That is addSheepCount's type: addSheepCount :: Sheep -> Int -> State DB Int
13:09:36 <Cale> and it will have type  Int -> State DB Int
13:09:54 <Cale> Accolade: But x is the wrong type then :)
13:10:26 <FliPPeh> > 1:2:3:[]
13:10:27 <lambdabot>   [1,2,3]
13:10:52 <Cale> Because you would want x :: Int -> Sheep, but that type also has to match the type of  return 0
13:11:18 <Cale> But the only way that could be okay is if there's an instance of Num for Sheep
13:11:28 <Accolade> x :: Int -> Sheep ? Not x :: State DB Int ?
13:11:40 <Cale> Accolade: right.
13:11:47 <Cale> Accolade: This would be the (Int ->) monad
13:12:27 <Cale> Accolade: Because the right parameter to >>= is not a function which returns a State DB Int, it's a function which returns a *function* from Int to State DB Int
13:12:50 <Cale> and so the monad would have to be the monad of functions from Int (which happens to actually be a monad)
13:13:13 <Cale> > (do x <- (*10); y <- (*100); return (x+y)) 5
13:13:13 <lambdabot>   550
13:14:03 <Cale> Does that make sense?
13:15:07 <Cale> (Perhaps it's that you were thinking only that the result of the function is in the State DB monad, and so it would have to magically steal a Sheep from somewhere to get the types to match, but it doesn't do that much dwimmery :)
13:17:19 <Accolade> The sense doesn't reveal itself to me right now, sorry. :( I guess it's because I worked too long, so my brain is somewhat clotted.
13:17:51 <Accolade> Maybe I should have another look at your comments another day.
13:20:23 <uzytkownik> @pl \ai -> socket (addrFamily ai) Stream 0
13:20:23 <lambdabot> flip (flip socket Stream . addrFamily) 0
13:26:35 <FliPPeh> @hpaste
13:26:36 <lambdabot> Haskell pastebin: http://hpaste.org/new
13:26:48 <FliPPeh> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5786#a5786
13:26:57 <FliPPeh> Can someone help me? I somehow suck at recursing
13:27:14 <FliPPeh> I keep getting mismatching types for line 28, where the recursing happens
13:28:06 <Zao> FliPPeh: What's the type of the expression on line 32?
13:28:21 <FliPPeh> Must be IO [(String, String)]
13:28:28 <FliPPeh> Because that's the function recursing
13:29:12 <Zao> The type of  (readFile h) is [(String, String)] -> IO [(String, String)]
13:29:20 <FliPPeh> > delete ' ' "  l"
13:29:21 <lambdabot>   " l"
13:29:23 <FliPPeh> Mh.
13:29:31 <Zao> You then proceed to pass that an IO [(String, String)]
13:29:42 <Zao> Which most definitely isn't [(String, String)]
13:30:06 <dirk_> is there a lib for urlencodeing utf8 strings?
13:33:50 <\stro> hi, I'm using Numeric.FAD and am getting "Inferred type is less polymorphic than expected"
13:34:04 <\stro> I'm however not that progressed that I understand existential types yet
13:34:17 <monochrom> readFile h ((key l, value l):last).  don't "return". Not what you thought.
13:34:27 <\stro> what am I supposed to do?
13:35:04 <Zao> FliPPeh: return wraps a value into a monadic action that "contains" that value.
13:35:10 <Zao> @type return
13:35:12 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
13:35:12 <FliPPeh> I know
13:35:16 <FliPPeh> I kind of got lost in there
13:35:21 <FliPPeh> And tried all kind of things
13:35:30 <FliPPeh> Actually I just resolved the ERROR itself by myself
13:35:35 <FliPPeh> Just the function does not work :(
13:35:41 <FliPPeh> Always returning an empty list
13:36:44 <monochrom> change "last <- b" to "let last = b"
13:41:45 <FliPPeh> Hah, fixed it
13:42:51 <Accolade> me too! =)
13:43:08 <Accolade> all done now, phew! What a feeling. :)
13:43:39 <rotsiopoulostomh> hi
13:44:49 <Accolade> Cale, this was the catch (if you care): BAD: then return (count + 1)  GOOD: then ((count + 1),newDb)
13:45:11 <Accolade> I'm pretty sure the error message for my other mistake willl change now, gonna test that.
13:45:59 <byorgey> suppose I want to write a Haskell program that can read an audio file from disk and cause it to be realized as sound coming out of my speakers.  at which Hackage libraries should I look?
13:46:16 <byorgey> there are lots of sound-related libraries so I'm just looking for some advice on a simple place to get started.
13:46:33 <Accolade> No, my error message didn't change, duh!
13:48:05 <Zao> Accolade: Sounds like a perfect refactoring. You didn't change the outward facing behaviour of the application.
13:48:16 <Accolade> lol
13:52:25 <FliPPeh> In a List of type (Key, Value), how could I look for a specific key?
13:53:08 <FunctorSalad> FliPPeh: Prelude.lookup
13:53:25 <FunctorSalad> but use Data.Map if you have more than a few elements
13:53:27 <pumpkin> moo
13:53:40 <Badger> oink
13:53:48 <Accolade> gazonk
13:53:52 <FliPPeh> Teehee
13:53:57 <FliPPeh> Prelude loves me
13:53:58 <FunctorSalad> @slap it
13:53:58 * lambdabot hits it with a hammer, so they breaks into a thousand pieces
13:54:16 <FliPPeh> > lookup "key" [("key", "value"), ("not this one", "failure")]
13:54:17 <lambdabot>   Just "value"
13:54:20 <FliPPeh> :D
13:54:21 * Badger teaches lambdabot the Rules of Grammar.
13:54:24 <FliPPeh> > lookup "key" [("ky", "value"), ("not this one", "failure")]
13:54:25 <lambdabot>   Nothing
13:54:48 <monochrom> Everyone loves Prelude but Prelude loves only me.
13:54:53 <byorgey> @slap the Rules of Grammar
13:54:54 * lambdabot moulds the Rules of Grammar into a delicous cookie, and places it in her oven
13:55:21 <monochrom> @slap all humans
13:55:21 <lambdabot> stop telling me what to do
13:55:21 <byorgey> hmm, looks like lambdabot needs to learn the Rules of Spelling too
13:55:26 <monochrom> ...
13:55:44 <Zao> So the Prelude is monoamoric?
13:55:47 <monochrom> I'll try just once more.
13:55:49 <monochrom> @slap all humans
13:55:50 * lambdabot secretly deletes all humans' source code
13:55:54 <monochrom> Yay!
13:56:04 <mux> nooooooo!
13:56:09 <byorgey> unfortunately, said source code includes that for lambdabot herself.
13:56:17 <byorgey> who disappears in a puff of logic.
13:56:25 <monochrom> lambdabot no longer needs source code to run.
13:56:56 <byorgey> @src loookup
13:56:57 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
13:57:02 <byorgey> oh no! it really worked!
13:57:06 <monochrom> hehe
13:57:20 <Accolade> I see what you did there. o_O
14:03:37 <FliPPeh> Okay, last question regarding this topic. I got a string in the form of "Some text and an embedded $(VARIABLE)"
14:03:54 <FliPPeh> How would I go around and replace the $(...) with the actual Text of VARIABLE?
14:04:44 <FliPPeh> 'expand "VARIABLE" list' would be the function to run, that's what I know, I just don't know how to get that far
14:04:59 <Twey> FliPPeh: http://www.haskell.org/haskellwiki/String_interpolation
14:05:29 <byorgey> FliPPeh: I am not sure exactly what you are trying to do.
14:05:38 <FliPPeh> Okay byorgey, let me explain it
14:05:43 <byorgey> FliPPeh: "VARIABLE" is a key into some map?
14:05:50 <byorgey> ok, go ahead
14:06:25 <FliPPeh> I've got a list of Macros here, a macro is a tuple in the form of (Key, Value). Now the expand function starts with a macro name and looks up the string for more macro names to replace
14:06:49 <FliPPeh> Example list: TEST=Replace $(ME)    ME=Hello!
14:06:57 <dcoutts> FliPPeh: another example is templateSubstitute in http://code.haskell.org/gtk2hs/tools/apiGen/src/Utils.hs
14:06:59 <FliPPeh> expand "TEST" list -> "Replace Hello!"
14:08:57 <byorgey> FliPPeh: well, a naive way would be to go through the list of pairs, checking whether each Key `isInfixOf` the string being processed
14:09:46 <FliPPeh> hmm
14:09:48 <byorgey> if so, replace it with the Value.  But unfortunately you'll have to write the replacing function yourself.
14:10:17 <FliPPeh> And a better way?
14:10:35 <byorgey> or you could use an existing solution like the templateSubstitute that dcoutts linked to, or something like HStringTemplate, perhaps
14:10:59 <byorgey> FliPPeh: may I ask why you need to do this, in a larger sense?
14:11:13 <byorgey> Strings seem like the wrong type.
14:11:25 <FliPPeh> I don't need to do anything I'm doing here, code wise. I do it for the joy of it, for learning haskell
14:11:29 <byorgey> perhaps you want a more algebraic sort of structure.
14:11:43 <byorgey> FliPPeh: well, maybe 'need' was the wrong word, I mean, what sort of program are you writing?
14:11:46 <FliPPeh> I don't need anything else but strings here
14:11:54 <FliPPeh> It's an extension to my IRC bot for now
14:12:26 <FliPPeh> A nicely expendable and on-the-fly reloadable settings/trigger list
14:13:03 <FliPPeh> ALT_NICK=$(PRIMARY_NICK)_new
14:13:06 <FliPPeh> Good example
14:13:10 <byorgey> FliPPeh: the way I would do it is to first write a parser that takes Strings into some sort of algebraic type which can represent chunks of text along with 'holes' (indicated by the $(...)) syntax
14:13:29 <byorgey> FliPPeh: then it's very easy to go through and look up the substitution for each hole
14:13:42 <byorgey> then finally render the resulting structure back to a string for output.
14:13:50 <byorgey> that's what I meant by "Strings seem like the wrong type".
14:14:01 <FliPPeh> (Text "VAR = " (Variable "VAR"))
14:14:03 <FliPPeh> Like that ?
14:14:12 <FliPPeh> For "VAR = $(VAR)"
14:14:19 <byorgey> yes, something like that.
14:14:29 <FliPPeh> Doesn't seem too hard
14:14:31 <byorgey> maybe  data Chunk = Text String | Var String
14:14:34 <FliPPeh> I'll give it a shot :)
14:14:38 <byorgey> then parse a String into a list of Chunks
14:14:55 <FliPPeh> data Chunk = Text String Chunk | Var String Chunk
14:15:03 <FliPPeh> Don't you mean that?
14:15:13 <byorgey> no, no need to mix up the list-ness with the Chunk-ness
14:15:24 <byorgey> I meant what I wrote, then have a list of Chunks
14:15:26 <FliPPeh> Okay, so just a List
14:15:40 <FliPPeh> [(Text "Text"), (Var "VAR")]
14:15:43 <FliPPeh> Even easier
14:15:45 <byorgey> right.
14:16:07 <FliPPeh> Alright, I'll try that!
14:16:10 <FliPPeh> Thanks so far :)
14:16:13 <byorgey> sure =)
14:18:41 <Peaker> I find closed type sums pretty rarely useful, I think
14:20:16 * Berengal looks at his 5-line long type signature...
14:21:38 <Botje> Berengal: make your screen wider!
14:22:17 <Berengal> Botje: createMap :: (typeList ~ LFuncRet indexerList, indexerList ~ LFuncFrom value typeList, map ~ MultiIndexMap value typeList, List indexerList) => indexerList -> (map, LFuncTo (map -> Maybe value) typeList)
14:22:36 <Botje> woah.
14:22:44 <Botje> that _is_ scary
14:22:47 <byorgey> sweet!
14:22:52 <byorgey> Berengal++
14:23:14 <Berengal> Botje: I also have: (emptyPersonMap, lookupLastName ::: lookupPhoneNumber ::: Nil) = createMap (lastName ::: phoneNumber ::: Nil)
14:23:15 <byorgey> you know, it would be a lot shorter if you used one-letter names for all the type variables ;)
14:23:33 <Berengal> byorgey: If I used one-letter variable names, I'd still be trying to figure this out...
14:23:43 <byorgey> hence the winky face =)
14:23:45 <Berengal> The implementation is currently "undefined"
14:24:04 <FliPPeh> @hpaste
14:24:05 <lambdabot> Haskell pastebin: http://hpaste.org/new
14:24:26 <FliPPeh> Any hints, byorgey?
14:24:26 <FliPPeh> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5788#a5788
14:24:30 <Berengal> But I foresee the major type hackery is done, now there's just some minor stuff left, pluss the actual code of course
14:24:52 <Botje> Berengal: heh. "it typechecks, now all i have to do is write the code"
14:25:16 <Botje> FliPPeh: [Macro] [Chunk] is a syntax error
14:25:28 <Botje> well, a kind error. but who's counting
14:25:36 <FliPPeh> Didn't notice that, did not try to compile so far
14:25:40 <FliPPeh> Would have known that :)
14:26:06 <Botje> what's the other problem you're having?
14:26:06 <byorgey> FliPPeh: what kind of hints?
14:26:15 <byorgey> I'm not sure what this function is supposed to do
14:26:17 <FliPPeh> How to walk that list
14:26:26 <FliPPeh> string*
14:26:31 <FliPPeh> So my pattern would match
14:27:06 <FliPPeh> > case "$(VAR)" of ('$':'(':_)_ -> "Match!"
14:27:07 <lambdabot>   <no location info>: Parse error in pattern
14:27:15 <FliPPeh> > case "$(VAR)" of ('$':'(')_ -> "Match!"
14:27:16 <lambdabot>   <no location info>: Parse error in pattern
14:27:20 <FliPPeh> > case "$(VAR)" of ('$':'('):_ -> "Match!"
14:27:21 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
14:27:32 <FliPPeh> > case "$(VAR)" of ('$':'(':_):_ -> "Match!"
14:27:33 <FliPPeh> Duh
14:27:33 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
14:28:17 <anq> Berengal, what do the tildes in your context represent?
14:28:19 <byorgey> > case "$(VAR)" of ('$':'(':_) -> "Match!"
14:28:20 <lambdabot>   "Match!"
14:28:27 <Berengal> anq: type equality
14:28:30 <byorgey> you had an extra _ there, after the parens
14:31:26 <anq> Berengal, I have not seen that feature before. Haskellwiki has no article on 'type equality', so where can I find out more?
14:32:24 <Berengal> anq: It comes with type families, which this piece of code is depending on
14:33:03 <anq> http://www.haskell.org/haskellwiki/GHC/Type_families  - This, Berengal?
14:33:07 <byorgey> anq: see http://www.haskell.org/ghc/docs/latest/html/users_guide/type-families.html
14:33:19 <byorgey> in particular see "equality constraints" at the bottom of the page I linked to
14:33:30 <byorgey> anq: yes, that
14:33:33 <anq> Ah. Thanks. :)
14:34:11 <byorgey> anq: http://www.cse.unsw.edu.au/~chak/papers/SCPD07.html has the gory technical details, if you really want them =)
14:36:54 <Baughn> conal: I think I've figured out how to represent improving values.. without unamb, without lazy lists of values, and with (up to) one thread per value. Well, time to implement..
14:37:05 <FliPPeh> > inits
14:37:07 <lambdabot>   Overlapping instances for GHC.Show.Show ([a] -> [[a]])
14:37:07 <lambdabot>    arising from a us...
14:37:17 <FliPPeh> > inits "Test $(L)"
14:37:18 <lambdabot>   ["","T","Te","Tes","Test","Test ","Test $","Test $(","Test $(L","Test $(L)"]
14:37:24 <FliPPeh> Too bad
14:37:30 <Baughn> conal: The solution is a bit unsafePerformIO-happy, though. Heh.
14:37:36 <byorgey> FliPPeh: what are you looking for?
14:37:41 <jmcarthur> Baughn: sounds like you have taken up my adventure
14:38:09 <FliPPeh> I'm looking for anything that could help me find the beggining ( $( ) of a variable
14:38:13 <byorgey> > tails "Test $(L)"
14:38:14 <lambdabot>   ["Test $(L)","est $(L)","st $(L)","t $(L)"," $(L)","$(L)","(L)","L)",")",""]
14:38:15 <FliPPeh> > tails "Test $(L)"
14:38:16 <lambdabot>   ["Test $(L)","est $(L)","st $(L)","t $(L)"," $(L)","$(L)","(L)","L)",")",""]
14:38:35 <Baughn> jmcarthur: The FRP club is growing. Is there a membership card?
14:38:40 <byorgey> I don't know how much that will really help though.
14:38:54 <FliPPeh> Not much
14:39:07 <conal> Baughn: neat.
14:39:10 <FliPPeh> > "$(" `isInfixOf` "TEST $(TEST) :d"
14:39:12 <lambdabot>   True
14:39:16 <FliPPeh> Meh
14:39:17 <conal> Baughn: oh -- have you seen http://conal.net/blog/posts/another-angle-on-functional-future-values/ ?
14:39:26 <jmcarthur> Baughn: i'm wondering if it might be wise at some point to make our own irc channel
14:39:32 <conal> Baughn: i'd forgotten about it
14:39:35 <byorgey> FliPPeh: you might want to take a look at a parsing library like Parsec.
14:39:47 <byorgey> it will take a little bit of time to learn, but makes this kind of thing a snap.
14:41:41 <Baughn> conal: That looks like you had a similar idea, but it's not quite the same. I think I've side-stepped the nondeterminism problem.
14:41:55 <FliPPeh> > "$(" `elemIndex` "TEST $(TEST) :d"
14:41:56 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
14:42:03 <FliPPeh> > '$' `elemIndex` "TEST $(TEST) :d"
14:42:05 <lambdabot>   Just 5
14:42:07 <FliPPeh> AHA!
14:42:17 <Twey> I'd go for regex.
14:42:19 <MyCatVerbs> Baughn, jmcarthur, conal: there already exist two good channels for FRP. #haskell, and #haskell-in-depth for the overspill.
14:42:28 <FliPPeh> I don't want regex :(
14:42:32 <FliPPeh> Always had bad experiences
14:42:34 <FliPPeh> Too buggy
14:42:36 <Zao> FliPPeh: Sucks to be you then.
14:42:43 <Zao> FliPPeh: A regex does exactly what you tell it to.
14:42:47 <Zao> It's not its fault that you suck :)
14:43:34 <monochrom> I don't believe it.
14:43:38 <Baughn> conal: Oh, and I'm using 'data Future a = Fixed a | Served a' for optimization purposes. It represents Never just fine, but it'll also use Fixed for every case where the exact value of a future is known at the time it's created
14:43:45 <MyCatVerbs> Zao: hi kids. Y'know that friendly, helpful atmosphere that #haskell is known for?
14:44:07 <FliPPeh> I feel offended and hurt.
14:44:10 <Zao> MyCatVerbs: You forgot "light hearted joking" in that list of adjectives.
14:44:12 <FliPPeh> Nawww kidding.
14:44:46 <monochrom> I feel offended and hurt too on behalf of regex.
14:45:02 <jmcarthur> MyCatVerbs: i only mention that because i have noticed a few times that we have monopolized the channel
14:45:09 <jmcarthur> not recently i guess
14:45:11 <MyCatVerbs> jmcarthur: that's what #-in-depth is for.
14:45:13 <Baughn> conal: If the names aren't suggestive enough, I'm creating a server thread per-(served-)future to take care of comparisons and such
14:46:28 <MyCatVerbs> Zao: well, I guess if everyone knows that, fair enough. I'm just paranoid about drama starting up because people might not take things as they're intended.
14:47:50 <Twey> That was obviously light-hearted, even to me
14:49:08 <\stro>     Couldn't match expected type `forall n. (Num n) => n'
14:49:08 <\stro>            against inferred type `Double'
14:49:13 <\stro> what am I misunderstanding?
14:50:14 <byorgey> \stro: something of type  forall n. (Num n) => n  has to be able to take on *any* numeric type.  Double is only one specific such type.
14:50:53 <monochrom> You have some mistaken type signature.
14:50:59 <byorgey> I suspect you are misunderstanding how polymorphism works in Haskell (which is quite easy to do, especially if you're just starting out/coming from an OO background?)
14:51:13 <byorgey> \stro: I'd have to see the code to be able to offer more help.
14:51:39 <\stro> hum, moment
14:52:45 <byorgey> if it inferred  forall n. (Num n) => n  and expected Double, that would be fine, since something which can take on any numeric type can certainly act like a Double.  It's like asking an impersonator to please ONLY impersonate George Bush.
14:53:41 <byorgey> but the other way around is a problem.  Something which is of type Double cannot act like ANY numeric type.  If you ask George Bush to be an impersonator you will have problems.
14:54:22 <monochrom> like "expected type President, inferred type Bush"
14:55:49 <\stro> byorgey: http://www.astro.spaceboyz.net/gitweb/?p=hirn.git;a=blob;f=Neuronal/Operations.hs
14:58:01 <sjanssen> I can't believe this page with this title exists http://haskell.org/haskellwiki/Do_notation_considered_harmful
14:58:34 <jmcarthur> why not?
14:58:52 * bremner tempted to write Monads_considered_harmful, just for completeness
14:59:09 <sjanssen> "considered harmful" has a lot of history, and I feel it's a gross misuse to apply it to do notation
14:59:25 <sjanssen> do notation compared to goto?  Ridiculous.
14:59:40 <byorgey> \stro: can you also paste the complete error message somewhere?  my brain does not have a built-in type checker ;)
14:59:47 <jmcarthur> ah, yeah, "considered harmful" doesn't really mean the same as "not always good"
14:59:57 <byorgey> (well, actually, it does, but it is much less powerful and prone to error than GHC's)
15:00:12 <sjanssen> jmcarthur: in our sub-culture, it means "burn it with fire"
15:00:17 <jmcarthur> yeah
15:00:29 <conal> sjanssen: maybe "some drawbacks of do notation"
15:00:34 <jmcarthur> and anyway, everybody knows that comefrom is way better than goto
15:00:52 <sjanssen> conal: that would be much better
15:00:53 <bremner> yeah, but actually, reasonably people use gotos too, so maybe it is not so bad
15:01:01 <Baughn> jmcarthur: Only with the multi-come extension
15:01:21 <conal> sjanssen: do notation *is* harmful, like most things.  iswym about that phrase having non-literal connotations in our field.
15:01:24 <jmcarthur> goto is the only alternative to the lack of certain features, like error handling in C
15:01:42 <lament> lack of certain features considered harmful
15:01:46 <jmcarthur> heh
15:01:55 <bremner> exactly: goto's, sure they're evil, but they're what we have.
15:02:00 <Twey> @remember sjanssen in our sub-culture, it ["considered harmful"] means [not "not always good" but] "burn it with fire"
15:02:00 <lambdabot> Okay.
15:02:03 <byorgey> "considered harmful" considered harmful
15:02:26 <lament> ""considered harmful" considered harmful" considered harmful
15:02:26 <jmcarthur> that quote is hard to swallow in one pass
15:03:00 <jmcarthur> let consideredHarmful = consideredHarmful
15:03:15 <monochrom> remember monochrom [haskell] [is] [excellent] [beyond] [belief]
15:03:28 <Twey> Hahaha
15:04:08 <Twey> fix show ("considered harmful" ++) ++ " considered harmful"
15:04:13 <Twey> Uh
15:04:21 <Twey> fix (show . ("considered harmful" ++)) ++ " considered harmful"
15:04:30 <Twey> Missing space... never mind :-P
15:05:08 <MrChutney> Is it normal for cabal to give compile errors when trying to instal libraries? :/
15:06:19 <\stro> byorgey: http://gist.github.com/128262
15:06:35 <Cale> MrChutney: If, say, you have the wrong version of GHC, yes.
15:06:36 <jmcarthur> MrChutney: not all libraries are in optimal condition
15:06:52 <Cale> (Or yeah, if the library is not in a compilable state)
15:07:05 <Cale> Which one are you trying to install?
15:07:13 <MrChutney> hmatrix
15:07:31 <Cale> Do you have the development version of the C libraries it requires installed?
15:07:50 <Cale> (Cabal can't install that for you)
15:07:57 <MrChutney> I've gone over the readme, and I've downloaded all the packages it says it wants.
15:08:01 <Cale> okay
15:08:14 <jmcarthur> well, just fyi, it builds for me on 6.10.3
15:08:21 <Cale> I'll try installing it myself. I remember it working in the past.
15:08:28 <MrChutney> Hm! I'll check my version of GHC...
15:08:40 <jmcarthur> i've been using hmatrix on a side project
15:08:41 <monochrom> Perhaps the source code is super commercial NDA secret and will never be posted. Only error messages are allowed by the lawyers.
15:08:48 <MrChutney> Hm. 6.8. Maybe It's time for an upgrade!
15:08:51 <Cale> Yes :)
15:08:56 <Cale> 6.8 is rather old
15:09:03 <MrChutney> Thanks. I'll give that a go now.
15:10:38 <wy_> huh. NDAs are disgusting
15:10:42 <\stro> byorgey: it complains about the type variable `tag'
15:11:31 <wy_> Is it okay to develop a huge idea and only give a very small portion to an employer? ;-)
15:12:09 <Peaker> wy_: NDAs are pretty much everywhere -- companies have secrets they keep with employees
15:12:29 <monochrom> Yes it is ok. Beware of those "end-of-year performance review" though. Your employer may say you are not contributing.
15:12:56 <Peaker> jmcarthur: goto's aren't the "only" alternative, they may be the best one, though
15:13:01 <piroko> I'm trying to compile ghc 6.10.3 in openbsd using the ghc 6.6.1 found in packages. I was able to compile ghc 6.10.1 about two weeks ago, but there was an update to the ghc 6.6.1 package and now I can no longer compile ghc 6.10.1 or 6.10.3. It says it can't find the "haskeline" dependency...
15:13:10 <wy_> That's not possible. My contribution is already a hundred times their money's worth :P
15:13:12 <jmcarthur> they are the cleanest alternative in some cases
15:13:22 <monochrom> OK then you're fine.
15:13:30 <wy_> cheers
15:15:29 <piroko> But when I try to compile haskeline, it says     Failed to load interface for `Distribution.System':
15:16:12 <Peaker> jmcarthur: yeah, but not the only one
15:16:23 <Peaker> jmcarthur: can also simulate these goto's by nesting more functions and using "return"
15:16:37 <\stro> byorgey: should I rather move back to an explicit type variable to State and Operation?
15:17:23 <monochrom> Just replace goto by tail calls. No one complains about tail calls.
15:17:28 <jmcarthur> Peaker: except when you have to clean up resources behind you. in that case, you either have to write redundant code, write lots of extra functions on the side, or use goto
15:17:50 <jmcarthur> and yes, those extra functions would all be tail calls
15:18:01 <byorgey> \stro: your definition of State is sort of bogus.
15:18:15 <Peaker> jmcarthur: lots of nested functions using success/error to determine whether to clean up
15:18:24 <Peaker> jmcarthur: I prefer goto myself, but its not that big a deal, imo
15:18:28 <jmcarthur> sometimes cleanup must be done in order
15:18:32 <byorgey> \stro: it says that opLinkWeight can return a value which can take on every numeric type.
15:18:36 <byorgey> there are no such values.
15:18:42 <\stro> byorgey: it's not a monad but a read-only state to be stored in the reader
15:18:58 <\stro> byorgey: uh, replace with explicit type variable?
15:19:11 <Heffalump> monochrom: how do you tailcall out of a loop? :-)
15:19:20 <byorgey> \stro: maybe you want some sort of existential?  it returns a value of *some* numeric type, but you don't know which?
15:20:03 <byorgey> \stro: yeah, an explicit type parameter for State and Operation sounds like the way to go.
15:20:14 <\stro> byorgey: either Double or Numeric.FAD.Dual tag Double, i think
15:20:33 <\stro> byorgey: thank you, i'll try that
15:21:02 <monochrom> Here is an example. "f x = if x=0 then g 0 else f x".  g 0 is a tail call out of the loop.
15:23:09 <Heffalump> monochrom: hmm..how about nested loops?
15:24:41 <monochrom> Here is an example. "outerloop x = if x=0 then goto 0 else outerloop (innerloop x)"; "innerloop x = if x=1 then goto 1 else innerloop x". goto 0 and goto 1 are tail calls jumping out.
15:25:49 <Heffalump> I see. Sort of.
15:26:04 <Peaker> jmcarthur: cleanup must be done in LIFO order, almost always, as the function call stack lets you
15:27:55 <monochrom> Loops make you think "if I don't write a special command, the default is looping back". You can't carry this mindset over to recursive functions. Recursive functions make you think "if you don't write a call, the default is to exit".
15:29:29 <aluink> so i'm looking for a nice way of creating a data type for a rating, i had thought of something like "data Rating = Good | Average | Poor", but don't really like that, any suggestions? can i create a type that draws it's values from a finite subset of [1..]? similar to C enums?
15:29:48 <Heffalump> use your datatype and derive Enum
15:30:03 <aluink> Heffalump: what do you mean?
15:30:14 <Heffalump> there's an Enum type class
15:30:16 <aluink> oh, derive as in derive a class instnace?
15:30:19 <Heffalump> yes
15:30:24 <aluink> oh, ok, i'll look into that, thanks ;)
15:30:27 <FunctorSalad> you can do "deriving (Enum,Bounded)" for types which have only nullary constructors
15:30:35 <sjanssen> aluink: you probably want to reverse the order of your constructors as well
15:30:43 <sjanssen> then you can automatically have Poor < Average
15:31:43 <aluink> sjanssen: yeah, i think you're right
15:32:14 <aluink> sweet, hoogle confirms this is what i was looking for, thanks! I can have the best of both worlds with this solution! Haskell FTW!
15:32:34 <aluink> now for a little play in ghci to make sure things check ot ;)
15:34:30 <jmcarthur> Peaker: that's assuming cleanup must happen even in the absence of failure
15:34:42 <Peaker> jmcarthur: nope, you can cleanup only if error is returned
15:36:01 <aluink> is there a way to defing a datatype in ghci without loading a file?
15:36:08 <monochrom> No.
15:36:27 <jmcarthur> Peaker: unless i am missing something critical: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5789#a5789
15:37:00 <jmcarthur> clearly it can be done without redundancy as i showed in the second version, but that is with extra functions
15:37:12 <aluink> monochrom: thanks
15:39:32 <jmcarthur> of course, with TCO, the last two versions compile to basically the same thing
15:40:03 <Peaker> jmcarthur: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5789#a5790
15:40:44 <jmcarthur> Peaker: still, required more than one function
15:40:53 <Peaker> jmcarthur: yeah, convert "goto" to "return"
15:41:04 <Peaker> jmcarthur: I prefer goto's too, but its a possible alternative
15:41:23 <jmcarthur> right. the argument is for people who think you can do anything with just nested ifs
15:45:45 <habitue> \exit
15:50:49 <Peaker> jmcarthur: you could also do nested if's and return success with everything allocated inside or clean up if return didn't skip it
15:54:38 <dibblego> how does one go about getting a hackage account?
15:54:59 <FliPPeh> How can I run a shell command and return the output, instead of just the exit code?
15:55:24 <dibblego> FliPPeh, look at System.Process
15:55:38 <FliPPeh> Thanks!
15:55:40 <gwern> dibblego: you just email the right person
15:55:50 <gwern> I believe the hackage front page has a link abotu getting an account
15:55:53 <dibblego> right@person.com?
15:55:59 <gwern> the process is similar to that of getting a c.h.o login
15:56:15 <monochrom> mr.right@matching.com
15:56:43 <jmcarthur> Peaker: oh hmm you're right. the obvious thing. i must have come up with the wrong example. i know there is a similar case where you can't just do that
15:57:14 <gwern> FliPPeh: running a shell command is reasonably complex, actually
15:57:23 <gwern> FliPPeh: you're best off looking for existing code that does this
15:57:36 <gwern> for example, runShellCommand in filestore; or the hsh package are good places to start
15:57:55 <Peaker> jmcarthur: I'm all for tiny/cute 3-liner functions in C too, anyway :-)
15:57:56 <gwern> if you try to cobble together something from the primitive low-level base libraries, you're sure to get something wrong
15:58:21 <FliPPeh> Meh
15:58:56 <gwern> sorry. the base libraries are just rather low-level. I blame it on bikeshedding
15:59:10 <gwern> who knew there were so many subtleties to running a shell command?!
15:59:54 <Peaker> escaping rules, argv[0], pty's, etc?
16:00:09 <gwern> indeed
16:00:11 <SamB> gwern: it's not merely bikeshedding
16:00:27 <SamB> this stuff is tricky no matter how little bikeshedding you have
16:00:29 <gwern> not to mentining the blocking and buffering behaviors etc
16:01:09 <gwern> SamB: but I think if there weren't bikeshedding, someone would've simply written a little module along the lines of hsh and just stuck it in, and everyone would get on using
16:01:27 <gwern> it's not like there aren't similar complexities in a lot of the filesystem stuff
16:01:37 <gwern> but we still have reasnoably high level modules/functions there
16:02:18 <SamB> also, there's those accursed Unix/Windows issues
16:03:14 <gwern> again, we have reasonably high level filesystem functions which are portable; but we can't seem to do that with processes and shells
16:03:17 <SamB> gwern: well, the really big issue is that there are THREE streams to deal with
16:03:19 <FliPPeh> Might look for another way to get CPU load
16:03:26 <SamB> and there are a zillion ways to manage them all
16:03:33 <gwern> FliPPeh: couldn't you just open a file in /proc?
16:03:43 <FliPPeh> That'd be my next attempt :)
16:03:53 <FliPPeh> Unixoid only, tho.
16:04:05 <TomMD> writeFile doesn't seem to close the file - is that correct?
16:04:12 <FliPPeh> Correct
16:04:17 <FliPPeh> hClose handle
16:04:28 <TomMD> FliPPeh: There is no handle with writeFile
16:04:40 <TomMD> @type System.IO.writeFile
16:04:40 <SamB> TomMD: it should ...
16:04:42 <lambdabot> FilePath -> String -> IO ()
16:13:10 <FliPPeh> How could I run a command every 5 minutes without using a thread?
16:13:11 <FliPPeh> tee-hee.
16:13:49 <TomMD> FliPPeh: control-engine
16:13:52 <TomMD> err
16:13:55 <TomMD> control-event
16:13:59 <TomMD> @hackage control-event
16:14:00 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/control-event
16:15:23 <TomMD> I considered making a 'persistant event' feature but decided not to bother.
16:18:27 <altmattr> is there a ctags/cscope equivalent for haskell?
16:20:20 <aavogt> @go hasktags
16:20:21 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/utils.html
16:20:21 <lambdabot> Title: Chapter�10.�Other Haskell utility programs
16:20:49 <Cale> FliPPeh: Is there a particular reason why you're avoiding using another thread?
16:20:57 <aavogt> altmattr: that one comes with recent GHCs, there are others too
16:21:07 <FliPPeh> It has to stay inside the StateT Monad
16:21:14 <FliPPeh> To access said state
16:21:27 <Cale> FliPPeh: You could create an infinite loop
16:21:38 <FliPPeh> I've got one
16:21:49 <Cale> and either use threadDelay, or getCurrentTime
16:21:50 <altmattr> aavogt: cheers
16:22:09 <Cale> (appropriately lifted of course)
16:22:31 <FliPPeh> TimeDifference?
16:22:35 <Cale> yeah
16:22:41 <FliPPeh> How can I get that in seconds?
16:22:50 <Cale> But StateT over IO seems a little excessive to me anyway. :P
16:23:47 <SamB> Cale: hey, StateT Char IO is good for unlambda isn't it ?
16:23:54 <dancor> i want to easily be able to swap columns in a matrix of Char's
16:23:57 <Cale> FliPPeh: use secondsToDiffTime and compare with that
16:24:01 <altmattr> let me preface this by saying - I love everything that comes with ghc - but is it really OK to have hasktags only index functions with type signatures?
16:24:07 <Cale> SamB: is it?
16:24:17 <dancor> i thought hmatrix would work but idk if it would be a hack since there are only Double and Complex instances for that
16:24:37 <SamB> Cale: I think that's the natural translation of the C code
16:24:37 <Cale> SamB: I think I'd usually prefer using ReaderT over IO with some MVars or IORefs
16:25:03 <Cale> (if I didn't just go with straight parameter passing)
16:25:06 <SamB> Cale: and it came out faster, so ...
16:25:21 <Cale> Faster than using IORefs?
16:25:25 <SamB> maybe you could go faster still, in fact I bet I've heard you can, but
16:25:32 <SamB> Cale: faster than the C I translated from
16:25:43 <Cale> ah
16:25:45 <SamB> of course, that was using libgc, so I guess it shouldn't be a surprise
16:25:59 <SamB> (and not mutating anything)
16:26:07 <SamB> (besides the one variable)
16:26:12 <dancor> i wonder if i should use array or something crazy with intmap
16:26:41 <gnuvince_> @hoogle (Monad m) => m a -> m b -> m (a, b)
16:26:42 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
16:26:42 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
16:26:42 <lambdabot> Control.Monad.RWS.Lazy execRWST :: Monad m => RWST r w s m a -> r -> s -> m (s, w)
16:27:07 <aavogt> @type liftM2 (,)
16:27:08 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m (a1, a2)
16:27:56 <aavogt> I guess hoogle can't generalize stuff like that
16:28:10 <Cale> dancor: It's rather unfortunate that we don't have a good multidimensional datastructure with fast indexes along each axis.
16:32:11 <dancor> Cale: maybe we will after i do this :)
16:33:12 <aavogt> so the nested intmap choice is slow?
16:34:45 <Cale> aavogt: Well, it's not terrible if you arrange that you only want to swap things at the outer layer
16:35:09 <Cale> But if you wanted to be able to quickly swap either columns or rows, that gets tough.
16:35:39 <dancor> what would you call a tensor that doesn't have to be numbers
16:35:52 <Cale> not-a-tensor ;)
16:36:02 <Cale> Perhaps a multidimentional array.
16:36:07 <Cale> dimensional*
16:37:14 <malouin> I'm sure this is a silly question, but how do I send end-of-file to a handle that I've opened with runInteractiveProcess?
16:37:20 <aavogt> swap :: Map x (Map y a) -> Map y (Map x a) -- I guess this would be the holdup, though maybe it wouldn't be too slow, if the swaps can be grouped together?
16:37:29 <mauke> malouin: close it
16:37:42 <malouin> great!
16:37:56 <Cale> aavogt: Yeah, if you could find a way to do that operation super-quickly, it would be great :)
16:39:10 <Cale> I wonder if there's a Map representation which admits a kind of swapping operation of that sort in less than linear time.
16:40:13 <TomMD> So you want an algorithm thats O(1/n) ?
16:40:23 <Cale> O(log n) will do.
16:40:38 <TomMD> Oh come on - if your going to wish for something...
16:40:48 <Cale> Or O(1)
16:41:04 <aavogt> O(0) ?
16:41:27 <Cale> I have a strange feeling that with the right representation, O(1) is possible.
16:42:23 <Cale> But without adding a constant cost to the lookup of every element on every such swap, it might be hard ;)
16:46:17 * Baughn finds the "putMVar <$> newEmptyMVar" construct /fascinating/. Such a density of code..
16:47:26 <aavogt> @type putMVar `fmap` newEmptyMVar
16:47:27 <lambdabot> Not in scope: `putMVar'
16:47:27 <lambdabot> Not in scope: `newEmptyMVar'
16:47:50 <Cale> aavogt: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent-MVar.html
16:48:17 <Baughn> aavogt: It's 'IO (a -> IO ())'
16:48:29 <Baughn> Or, as I like to call it, IO (Sink a)
16:49:01 <aavogt> what good is it, if the reference to the mvar disappears?
16:49:23 <aavogt> ah, I see what you mean by sink
16:50:17 <aavogt> @type return $ const ()
16:50:19 <lambdabot> forall (m :: * -> *) b. (Monad m) => m (b -> ())
16:50:28 <aavogt> @type return $ return . const ()
16:50:29 <lambdabot> forall (m :: * -> *) (m1 :: * -> *) a. (Monad m, Monad m1) => m (a -> m1 ())
16:51:08 <Boxo> what's the best way to do restricted datatypes is haskell?
16:51:14 <Baughn> aavogt: ..you have a point there. I out-clevered myself a bit. ^^;
16:51:20 <aavogt> but I guess the implementation has to allocate an mvar in Baughn's example?
16:51:39 <Baughn> aavogt: Well, I did intend for someone to read the mvar.
16:51:49 <Baughn> Compiler would've caught my mistake, but.. ^^;
16:52:02 <aavogt> Boxo: newtype
16:52:57 <Baughn> Boxo: Define "restricted datatype", please
16:53:21 <aavogt> which is supposed to only exist at compile time
16:54:07 <Baughn> "Supposed", nothing. It /does/ only exist at compile-time.
16:54:07 <Boxo> Baughn: an example would be "an odd integer"
16:54:27 <pumpkin> oh, that's not happening
16:54:27 <TomMD> Boxo: There is actually a paper on using MPTC for this.  http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.39.2816
16:54:35 <Baughn> Boxo: Ah. newtype, or data, with constructors and functions/instances that enforce the restriction.
16:54:40 <Boxo> I'm trying to make a datatype to represent a puzzle and make it so that only valid puzzles are even of that type
16:54:42 <aavogt> Baughn: but, but instances...
16:54:47 <Cale> Baughn: Well, it technically could support the semantics it has with a less efficient runtime representation.
16:54:54 <Baughn> aavogt: What about them?
16:55:10 <SamB> Cale: newtype?
16:55:13 <Cale> Boxo: Create a module and don't export the data constructors for the puzzle type
16:55:15 <Cale> SamB: yes
16:55:15 <TomMD> Boxo: You could declare a new ADT (with 'data' or 'newtype') and not export the constructors.  Instead, export only custom construction function which perform the check and return a 'Maybe a'
16:55:20 <SamB> Cale: but that's not how Haskell 98 defines it!
16:55:33 <SamB> not that I love Haskell 98 or anything ;-)
16:55:34 <Cale> Boxo: Instead, only export operations on puzzles which move between valid puzzle states.
16:55:40 <Baughn> Haskell 98 is relevant? (??)
16:55:42 <Cale> SamB: hm?
16:55:53 <Cale> SamB: Haskell 98 doesn't say anything about the runtime representation of newtypes
16:56:05 <Cale> (nor should any reasonable standard)
16:56:10 <Baughn> aavogt: Remember, the instance selection is done at compile-time too
16:56:47 <aavogt> Baughn: if they are unique to the newtype (ie. not newtype deriving), then the dictionaries for the instances are separate at runtime
16:57:12 <Baughn> aavogt: That's true
16:57:30 <Baughn> aavogt: Oh, I see. No, I don't consider the instances to be part of the newtype.
16:57:32 <SamB> 4.2.3  Datatype Renamings
16:57:34 <SamB> ...
16:57:43 <SamB> A declaration of the form
16:57:44 <SamB> newtype cx => T u1 ... uk = N t
16:57:44 <SamB> introduces a new type whose representation is the same as an existing type.
16:57:46 <Baughn> So newtype only exists at compile-time, instances picked due to it certainly exist at runtime
16:58:03 <Baughn> SamB: Hum. So it /does/ say they only exist at compile-time
16:58:06 <Boxo> guess I'll go with the Maybe idea. But things will still be messed up if I make a mistake in a function that takes a valid puzzle and in supposed to return a valid puzzle.
16:58:12 <SamB> Cale: regardless of what you say about any reasonable standard ... it DOES
16:58:38 <Baughn> Boxo: If you can, write a function that confirms the puzzle is valid, then use quickcheck
16:58:45 <SamB> http://www.haskell.org/onlinereport/decls.html#sect4.2.3
16:59:11 <Boxo> Okay
16:59:47 <Cale> SamB: hm?
17:00:06 <SamB> Cale: read it!
17:00:18 <Cale> SamB: Oh, interesting.
17:00:38 <Cale> That is kind of unreasonable.
17:00:46 <aavogt> Baughn: agreed, since instances can be defined nearly anywhere
17:00:53 <SamB> yeah, I've always thought they were getting a bit carried away
17:01:13 <Cale> I don't think the standard should discuss how things are represented explicitly. That's something for the implementations to worry about.
17:01:42 <SamB> and should have merely specified the semantics and the *intent* that a newtype share the same representation as the underlying type in most cases
17:02:06 <Cale> actually, I think more important than the semantic differences, or the fact that there's no overhead in the implementation for newtype is the difference imparted by the newtype-deriving extension.
17:02:32 <Cale> But of course, that's not part of Haskell 98.
17:03:17 <lispy> I bet the authors wanted to make sure you could newtype a C type for the FFI and get right results?
17:03:33 <SamB> lispy: H98 doesn't cover that either
17:03:39 <SamB> that's in a seperate addendum
17:03:52 <SamB> maybe it's notionally part of H98 now, but ...
17:03:56 <sjanssen> Cale: newtype deriving is quite tricky without the stipulation that both types have the same representation
17:04:00 <Baughn> Cale: I can see where you're coming from. But at the same time, I'm /highly/ interested in knowing the performance characteristics of the code I'm writing..
17:04:07 <SamB> ... that doesn't explain why they wrote THIS document the way that they did!
17:04:38 <Cale> sjanssen: But even if the standard implies a particular implementation, it should not specify that implementation as being necessary.
17:04:47 <SamB> sjanssen: yeah, but GHC takes the unsafeCoerce# way out
17:05:01 <SamB> you can even write unsafeCoerce using NewtypeDeriving, did you know that?
17:05:13 <Cale> Oh?
17:05:13 <sjanssen> SamB: every other approach seems very difficult
17:05:23 <sjanssen> I think they plugged that
17:05:27 <SamB> oh
17:05:28 <SamB> they did?
17:05:29 <lispy> By the way, their newtype Age = Age { unAge :: Int }, example brings out an interesting point.  Age :: Int -> Age, unAge :: Age -> Int, I find the latter one a bit confusing because the "Age" parameter to unAge is not all that obvious.
17:05:31 <sjanssen> but you can still break parametricity, IIRC
17:05:32 <Cale> That would have to be a bug.
17:05:35 <SamB> what'd that do to Type Families
17:05:37 <SamB> ?
17:05:38 <Cale> How is it that you can do that?
17:06:17 <Cale> (If it involves Typeable somehow, then I'm not impressed ;)
17:06:32 <sjanssen> Cale: it doesn't
17:06:39 <sjanssen> lemme try to find the bug
17:07:26 <SamB> you can't do that shit with Typeable
17:07:39 <SamB> at least, not without lying
17:09:05 <SamB> I think it's http://hackage.haskell.org/trac/ghc/ticket/1496
17:09:08 <lispy> SamB: re: addendum, this section of the report has been updated to have bang patterns.  Was that part of H98?
17:09:27 <lispy> data D2 = D2 !Int
17:09:56 <SamB> lispy: that isn't bang patterns
17:09:57 <lispy> I guess that's not a bang pattern, but a bang in a data constructor
17:10:09 <lispy> Either way, was that part of h98?
17:10:10 <SamB> though I got confused similarly not long ago ;-)
17:10:14 <SamB> lispy: yeah
17:10:15 <sjanssen> SamB: yeah, that's the one
17:10:17 <lispy> Ah okay
17:10:24 <SamB> that's always been there
17:13:22 <aluink> what's wrong with my inclusion of Location in my LogRating type? http://aluink.pastebin.com/d6ccce9dd
17:13:37 <aluink> sorry, in my HikeLog type
17:13:55 <mauke> Location is not a type
17:14:17 <mauke> why does it have a parameter?
17:14:28 <pumpkin> zomg the phantom type!
17:16:35 <aluink> mauke: oh, ok, i'm sure you can see what i'm trying to do, how should i do it?
17:16:46 <mauke> remove the parameter
17:16:59 <SamB> Cale: I think that newtype deriving ought to involve the derivation of equations for each class member ... which could then be simply discarded after being verified for type-correctness
17:17:11 <aluink> oh
17:17:44 <lispy> Just read the ticket, that bug is very deep
17:17:53 <SamB> lispy: I'm not trivializing it
17:18:02 <SamB> generating those equations could be quite tricky
17:18:40 <hackagebot> tconfig 0.2 - Simple text configuration file parser library. (AnthonySimpson)
17:18:52 <lispy> Reading the ticket reminds me that I want GHC to have a 'type checking' debugger so you can see how/why it inferres what it does
17:18:55 <SamB> but if we could hit upon generation rules that work in most cases, that would save us a lot of work without getting us into this mess
17:21:35 <SamB> lispy: the issue seems to be that GHC figures that just substituting the RHS of the newtype everywhere in a type is safe, when it's only actually safe to convert a value of either type to the other ...
17:23:45 <Accolade> hey Cale, just wanted to let you know that I got it by now. It all seems so obvious now. ;) Thanks again for your patience!
17:23:52 <Cale> okay :)
18:57:47 <rickasaur> I was wondering, how many of you guys work with Haskell for money
18:58:01 <rickasaur> I really like the language and was wondering how difficult it would be to find a job
18:59:47 <lindzeyn> A job for coding exclusively in Haskell is virtually non-existant
19:00:05 <CalJohn> there are lots of jobs in the right areas
19:00:16 <p_l> is it rarer than for Common Lisp? :)
19:00:31 <CalJohn> though often with languages that are _like_ haskell, but not haskell
19:00:36 <dibblego> non-existant is non-existent :)
19:00:38 <blackh> rickasaur: It's pretty much only early adopters at present.  It is possible to get Haskell jobs, but making your own luck is also an option.
19:00:43 <CalJohn> finance is the big employer, afaik
19:00:51 <lindzeyn> In most areas of industry, you will never code in a functional language.
19:00:54 <rickasaur> yeah, I've been working with F# a lot
19:01:09 <rickasaur> it's much like Haskell but has microsoft backing, but I'd rather do Haskell
19:01:28 <dibblego> F# is quite different to Haskell
19:02:01 <rickasaur> well, It's much different true, but more like it than another option available to me
19:02:05 <lindzeyn> I read a bunch of papers about Haskell written by dudes in MS Research.  I believe F# is their baby.
19:02:21 <CalJohn> (it's not, really)
19:02:36 <rickasaur> Yeah, Simon Peyton Jones works at Microsoft
19:02:53 <rickasaur> His office is right up the hall from Don Syme (the father of F#)
19:03:15 <rickasaur> but in any case, I wish I could use Haskell for money
19:03:22 <lindzeyn> rickasaur: are you a janitor at microsoft or something?
19:03:58 <hatds> I thought that was well known
19:04:02 <rickasaur> Naw, I just read a lot on F# and I heard it in an interview
19:04:30 <rickasaur> sorry if I offended you, It wasn't my intent
19:04:55 <lindzeyn> rickasaur: I was kiddin
19:05:40 <rickasaur> I managed to work through the entirety of Real World Haskell.  I'm really head over heels for the language.
19:05:51 <blackh> rickasaur: So am I!
19:06:07 <lindzeyn> I wonder if C# and F# together are as harmonious as the perfect fourth C#/F#
19:06:31 <rickasaur> No, they clash horribly.  I mean the reason F# has null is C#
19:06:48 <rickasaur> and mutability is everywhere in the .NET framework
19:07:15 <lindzeyn> so C# = not (F#)
19:07:46 <lindzeyn> Okay, time for me to shutup
19:14:09 <hatds> gah, I want to kick myself.  Mixed up Ratio and Rational
19:16:34 <monochrom> ha
19:26:16 <Neut> can someone please tell me waht is wrong with this expression,
19:26:17 <Neut> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2717#a2717
19:27:30 <Cale> Neut: it looks like you have guards without the parameter and |
19:27:36 <sjw> do you mean treeDiv k | k == 1 = ... | k > 1 ...?
19:28:30 <Neut> yeah huh
19:28:57 <Neut> when i cahnge it,
19:29:06 <Neut> I get Not in Scope: data constructor Tree
19:29:14 <Cale> right
19:29:28 <Cale> it should be clear why that is
19:29:35 <RyanT5000> is it possible (or sane) to nest darcs repos?
19:29:53 <Cale> did you mean treeDiv (k `div` 2) ?
19:29:59 <RyanT5000> e.g.: if i want to use someone else's package as part of my own project
19:30:07 <RyanT5000> with some local modifications
19:30:37 <Neut> ohh
19:30:38 <Neut> thanks Cale
19:31:14 <Cale> Neut: Tree is a type constructor in your code, and has no place outside a type :)
19:31:36 <Neut> Cale: Now Im getting the error that Could not deduce Integral
19:31:42 <Neut> how can I round the div?
19:31:50 <Cale> mhm, there's more problems.
19:32:10 <Cale> Your tree type has an unused type parameter -- is there any reason for that?
19:32:54 <Neut> To be honest, I just had an exam and that was the question. Im trying to see how I went, so far I have forgotten the guards and the rounding on this particular question and now Im trying to figure out hte correct answer.
19:33:23 <Cale> no fractional Int values are possible, so rounding doesn't make sense
19:33:45 <Neut> so what is incorrect in my code? Can you point it out to me?
19:33:50 <Cale> Did you change it to  treeDiv k `div` 2 perhaps?
19:34:11 <Neut> wait
19:34:13 <Cale> The parens around k `div` 2 are not optional.
19:34:25 <Neut> I forgot some brackets
19:34:29 <Cale> because that would mean  (treeDiv k) `div` 2
19:34:31 <Neut> bugger
19:34:59 <Neut> argh well - fairly close xds
19:35:02 <Neut> thanks Cale
19:35:35 <Cale> The 'a' in your Tree datatype seems not to serve a real purpose
19:35:46 <Neut> We were given that type,
19:35:50 <Cale> Really?
19:35:53 <Neut> Just had to write the definition of it
19:35:55 <Neut> yeah
19:36:01 <Cale> It should either be:
19:36:05 <Neut> should it be Tree Int?
19:36:11 <Cale> data Tree a = Leaf a | Node a (Tree a) (Tree a)
19:36:13 <Cale> Or it should be
19:36:26 <Cale> data Tree = Leaf Int | Node Int (Tree Int) (Tree Int)
19:36:45 <Neut> yeah Im not sure why it was that way?
19:36:50 <Cale> er
19:36:56 <Cale> data Tree = Leaf Int | Node Int Tree Tree
19:36:58 <Cale> rather
19:37:05 <Neut> Additionaly, I forgot my prelude so I mixed up max and maximum
19:37:53 <Neut> anyway im off
19:37:54 <Neut> later.
19:37:56 <Neut> thanks
19:38:57 <RyanT5000> is there a better chatroom for darcs questions?
19:39:03 <pumpkin> #darcs
19:42:23 <RyanT5000> pumpkin: oh, i didn't realize it had its own :P
20:04:12 <amuck> What does ::: mean?
20:04:50 <dibblego> amuck, do you mean :: ?
20:05:37 <amuck> dibblego: No, it's used at http://augustss.blogspot.com/2009/06/more-llvm-recently-someone-asked-me-on.html
20:05:56 <kpreid> @hoogle :::
20:05:56 <lambdabot> Parse error:
20:05:57 <lambdabot>   --count=20 :::
20:05:57 <lambdabot>              ^
20:06:08 <sjanssen> amuck: probably a custom constructor defined in the LLVM library
20:06:09 <kpreid> That's a constructor, I think
20:06:17 <kpreid> > 1 ::: 2
20:06:17 <dancor> is there anything like List that supports random-access inserting and deleting elements well
20:06:18 <lambdabot>   Not in scope: data constructor `:::'
20:06:22 <kpreid> Yup
20:06:27 <amuck> Ok, thanks
20:06:32 <kpreid> Just like : is a constructor (well, not entirely, : is magic)
20:06:34 <roconnor>  dancor: check out Edison
20:06:53 <roconnor> dancor: and there is also Data.Sequence
20:06:55 <kpreid> :: is an exception, much like = is an exception but you can have operators named == or /= or <=>
20:06:58 <roconnor> or is it Data.Seq?
20:07:12 <kpreid> so you can have ::: and >:< and <::
20:07:16 <kpreid> or :=
20:07:26 <sjanssen> roconnor: Data.Sequence, but the type in that module is Seq
20:07:30 <sjanssen> (confusing, yes)
20:07:50 <kpreid> Except that anything beginning with : is a constructor. So ::: is a constructor, := is a constructor, and >:< is a plain function
20:08:02 <roconnor> dancor: Data.Sequence is probably what you want
20:08:02 <kpreid> (":" is uppercase punctuation)
20:08:26 <dancor> ah, i wasn't sure if doing like drop on splitAt was a good way to do a random-access delete
20:08:39 <amuck> kpreid: Is there any reasoning behind : beginning a constructor?
20:08:52 <kpreid> There is no good way to random-access * on a list.
20:08:53 <dancor> i guess it's log in the size or better
20:09:04 <kpreid> amuck: there had to be something...
20:09:20 <sjanssen> amuck: there needs to be some way of disambiguating constructor operators vs. functions, and there was already present in the list operator (:)
20:10:11 <amuck> Why do constructor operators need to be differentiated from functions?
20:10:40 <kpreid> because "foo + bar = baz" and "foo :+ bar = baz" mean different things
20:10:53 <aavogt> pattern matching can only be done on the former
20:10:55 <kpreid> the former defines + and the latter pattern matches against baz
20:11:01 <amuck> Ok
20:11:08 <kpreid> This is easier to see in the non-pattern version
20:11:54 <kpreid> > let left x = "foo" in left 99 -- this defines a function "left"
20:11:55 <lambdabot>   "foo"
20:12:18 <kpreid> > let Left x = Left "foo" in x -- this pattern matches a value
20:12:20 <lambdabot>   "foo"
20:12:39 <kpreid> :+ is like Left and + is like left
20:15:51 <amuck> kpreid: Thanks, that makes sense
20:25:39 <dancor> is there a reason there is no Seq.toList
20:27:35 <aavogt> dancor: there's a Foldable instance that provides a toList
20:27:39 <sjanssen> dancor: it's in Data.Foldable
21:07:49 <pumpkin> is (repeat 10) an Algebra?
21:07:56 <pumpkin> :t repeat 10
21:07:57 <lambdabot> forall t. (Num t) => [t]
21:08:02 <pumpkin> oh whoops
21:08:04 <pumpkin> I meant replicate
21:08:10 <pumpkin> :t replicate 10
21:08:12 <lambdabot> forall a. a -> [a]
21:08:20 <pumpkin> I meant a coalgebra too :P
21:08:59 <roconnor> pumpkin: I think so
21:09:20 <ClaudiusMaximus> i don't know.  but i do know that if i have to reduce my font size to fit my type signature in my display, i should maybe define some synonyms
21:09:22 <pumpkin> and so sum, product, and any other [a] -> a function are Algebra?
21:09:33 <roconnor> i think so
21:09:43 <roconnor> f a -> a
21:09:54 <pumpkin> so we could just call one a producer and the other a consumer?
21:10:20 <pumpkin> or a nsumer and a consumer ;)
21:10:41 <jleedev> eta-sumer and coeta-sumer?
21:10:44 <roconnor> http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Functor-Algebra.html
21:10:55 <roconnor> oh
21:11:03 <roconnor> f a -> a is an f-Algebra
21:11:05 <Cale> F-algebras and F-coalgebras don't have very many requirements on their own
21:11:11 <roconnor> a -> f a is an f-Coalgebra
21:11:12 <pumpkin> roconnor: yeah, saw that... I was just wondering if there were any associated laws with them, or if anything fit
21:11:23 <Cale> roconnor: It's not even required to be polymorphic either
21:11:27 <pumpkin> *if anything that fit counted as an Algebra/Coalgebra
21:11:40 <purplepenguins> category-extras is mathematical black magic
21:11:47 <Cale> (Integer, sum) is an F-algebra of [] in Hask
21:12:01 <Cale> In fact, every function [Integer] -> Integer is.
21:12:22 <Cale> So it's not all that special to say that something is an F-algebra or F-coalgebra ;)
21:12:24 <roconnor> Cale: ah right
21:12:36 <pumpkin> alright :) just trying to bring category-extras down to earth for myself :)
21:12:43 <Cale> However, morphisms between F-algebras or F-coalgebras are interesting
21:12:53 <purplepenguins> what is an F-algebra?
21:13:10 <Cale> http://en.wikipedia.org/wiki/F-algebra
21:13:32 <purplepenguins> ah
21:13:40 <pumpkin> Cale: how do morphisms between them work?
21:13:44 <purplepenguins> i have an understanding of category theory
21:13:56 <purplepenguins> but i do not know how haskell works with categories
21:14:11 <Cale> purplepenguins: There's a category of types and Haskell-definable functions between them
21:14:25 <Cale> (so pretty much the most obvious way ;)
21:14:29 <purplepenguins> okay
21:14:38 <roconnor> Cale: which actually doesn't work :/
21:14:42 <roconnor> stupid seq
21:14:45 <Cale> roconnor: eh?
21:14:58 <Cale> roconnor: it's still a category, it's just not as nice a category
21:15:03 <jleedev> In a nutshell, undefined messes everything up
21:15:16 <Cale> It's not really undefined's fault
21:15:19 <roconnor> it's not a category in the obvious way
21:15:26 <Cale> Huh?
21:15:47 <Cale> What axiom do id and (.) fail?
21:16:34 <pumpkin> Cale: do you know what a generalized histomorphism is?
21:16:47 <malouin> Is there a function :: Maybe [a] -> Maybe a  that grabs the first item of the list, if exists?
21:17:00 <pumpkin> malouin: why would you want Maybe [a] ?
21:17:06 <Tsion> malouin: liftM head
21:17:07 <Tsion> I think
21:17:16 <Cale> pumpkin: anyway, if you have two F-algebras, (A,a) and (B,b), then an F-algebra morphism between them is a map f: A -> B such that f . a = b . fmap f
21:17:21 <Tsion> > liftM head $ Just [1,2,3]
21:17:23 <lambdabot>   Just 1
21:17:33 <malouin> pumpkin: a DB thing returns Maybe a, and it's returning list here.
21:17:44 <Cale> Tsion: that fails in the wrong way :)
21:17:49 <Cale> > liftM head []
21:17:49 <pumpkin> malouin: ah, so what do you want to happen if you have Just [] ?
21:17:51 <lambdabot>   []
21:18:01 <Tsion> Cale: Oh.
21:18:01 <Cale> > liftM head $ Just []
21:18:03 <lambdabot>   Just * Exception: Prelude.head: empty list
21:18:03 <malouin> pumpkin: Nothing
21:18:09 <Axman6> > (1/(2^256) :: Double, 1/(2^256) :: CReal) -- this annoys me somewhat, asuming all goes well...
21:18:10 <lambdabot>   (8.636168555094445e-78,0.0)
21:18:18 <Axman6> yes, i do not like that :(
21:18:24 <malouin> pumpkin: I don't care why it's not there in this case.
21:18:43 <mgsloan> Axman6: yeah that is strange :/
21:18:44 <Cale> Axman6: whoa...
21:18:46 <pumpkin> Cale: I'm thinking about it
21:19:02 <Cale> showCReal 300 (2^256)
21:19:04 <Axman6> > showCReal 100 (1/(2^256))
21:19:05 <lambdabot>   "0.000000000000000000000000000000000000000000000000000000000000000000000000...
21:19:07 <Axman6> heh
21:19:13 <pumpkin> it makes sense
21:19:16 <Axman6> yeah that does work, i already tested it
21:19:17 <Cale> > drop 200 $ showCReal 300 (2^256)
21:19:18 <lambdabot>   ""
21:19:24 <Cale> ...
21:19:30 <Axman6> > dtop 50 $ showCReal 100 (1/(2^256))
21:19:31 <pumpkin> it doesn't have that many digits
21:19:31 <lambdabot>   Not in scope: `dtop'
21:19:33 <Axman6> > drop 50 $ showCReal 100 (1/(2^256))
21:19:34 <lambdabot>   "0000000000000000000000000000086361685550944446253864"
21:19:46 <mgsloan> ah excellent :)
21:20:08 <ClaudiusMaximus> > fmap (foldr (const . Just) Nothing) $ Just [1,2,3]
21:20:10 <lambdabot>   Just (Just 1)
21:20:16 <Cale> I think it's sort of a fundamental limitation.
21:20:24 <Axman6> still, 0.00000000000... would be somewhat nicer than 0.0 in this case, since the answer is not 0.0
21:20:25 <Cale> (on what is possible with computable reals)
21:20:45 <Cale> Knowing that a number is really not 0 can require doing an arbitrarily large amount of work.
21:20:45 <Axman6> but it makes sense if CReal doesn't print things in exponential format
21:20:55 <Axman6> good point
21:21:05 <Cale> So it makes sense for the show instance to just give up after a point.
21:21:10 <Axman6> and makes sense why Double is ok
21:21:33 <ClaudiusMaximus> > map (join . fmap (foldr (const . Just) Nothing)) $ [Nothing, Just [], Just [1,2,3]]
21:21:34 <Cale> yeah
21:21:34 <lambdabot>   [Nothing,Nothing,Just 1]
21:21:38 <mgsloan> it would be interesting if CReal could give a certain E value
21:21:52 <mgsloan> for instance if there's 1000 zeros before any nonzero digits
21:22:09 <Cale> It might be a good idea for it to do a bit more work than it does -- at least comparable to the precision of Double, before giving up and displaying 0.
21:22:16 <malouin> what about listToMaybe . concat . MaybeToList?
21:22:28 <malouin> oops
21:22:58 <Cale> :t join . listToMaybe
21:22:59 <lambdabot> forall a. [Maybe a] -> Maybe a
21:23:05 <Cale> er
21:23:08 <Cale> right :)
21:23:12 <pumpkin> Cale: so say my F-algebras are (Integer, sum) and ([Integer], head), then I want an f such that f . sum = head . fmap f?
21:23:31 <pumpkin> which I guess makes sense :)
21:23:49 <pumpkin> actually
21:24:13 <Cale> There isn't one, of course, but yes :)
21:24:25 <pumpkin> oh okay, I was trying to find something :P
21:24:33 <pumpkin> so did I just pick a bad pair?
21:24:36 <Cale> yeah
21:24:53 <Cale> Though, one shouldn't expect there to be a map between a randomly chosen pair
21:25:15 <Cale> F-algebra morphisms are special :)
21:25:19 <pumpkin> :o
21:25:28 <roconnor> Cale:
21:25:32 <roconnor> > seq (undefined . id) 5
21:25:32 <pumpkin> have any tangible examples of such a thing?
21:25:33 <lambdabot>   5
21:25:38 <roconnor> > seq undefined 5
21:25:39 <lambdabot>   * Exception: Prelude.undefined
21:26:03 <malouin> > map (listToMaybe.concat.maybeToList) $ [Nothing, Just [], Just [1,2,3]]
21:26:05 <lambdabot>   [Nothing,Nothing,Just 1]
21:26:06 <Cale> roconnor: oh, I see
21:26:51 <malouin> ClaudiusMaximus: what is 'just'?
21:26:55 <malouin> err 'join'?
21:27:10 <purplepenguins> :t join
21:27:11 <Cale> roconnor: Right, I suppose you have to ignore that fact, that seq gives you a kind of comparison of functions which would otherwise be impossible.
21:27:11 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
21:27:25 <purplepenguins> that is a bit more complicated than what my ghci shows...
21:27:29 * roconnor likes to ignore seq
21:27:46 <malouin> ok, I get it though.
21:27:59 <Cale> purplepenguins: yeah, lambdabot has extensions turned on
21:28:15 <purplepenguins> i thought i understood haskell until i discovered ghc extensions
21:28:21 <Cale> :)
21:28:21 <purplepenguins> now i feel dumb again :|
21:28:27 <pumpkin> purplepenguins: that's always fun
21:28:34 <pumpkin> (feeling dumb)
21:28:39 <Cale> Isn't that a great feeling in some ways though?
21:28:39 <purplepenguins> it's like a teeming universe of mathematical concepts i've never heard of
21:29:01 <pumpkin> I love it
21:29:23 <purplepenguins> yeah
21:29:34 <purplepenguins> it's great to feel totally lost in the wonders of mathematics
21:29:53 <roconnor> 12:%4
21:33:11 <Cale> roconnor: I wonder if there's an evaluation strategy which is not strict, but has seq, and in which seq is incapable of distinguishing undefined . id and undefined.
21:34:10 <pumpkin> maybe sticking strictness into type annotations instead of as a function might help?
21:36:05 <Cale> actually, what if seq didn't go to WHNF but to HNF proper?
21:36:48 <Cale> That is, it would evaluate underneath a lambda.
21:37:23 <Cale> that seems to work
21:37:34 <Cale> So a minor variation on seq is good.
21:37:41 <Cale> FSVO 'minor'
21:38:22 <Cale> It would only require completely redesigning the runtime system. ;)
21:39:00 <sjanssen> what does HNF mean for functions?
21:39:29 <Cale> It means that if you hit a lambda, you start evaluating the inside of it into HNF
21:39:30 * roconnor wants to get rid of seq for functions.
21:39:45 <sjanssen> roconnor: with a seq class, or what?
21:39:59 <Cale> and (\x -> undefined) then evaluates to undefined
21:40:24 <pumpkin> how does undefined . id work with that?
21:41:01 <sjanssen> it's hard for me to imagine what it means to evaluate a function without knowing the parameter
21:41:32 <Cale> undefined . id --> (\f g x -> f (g x)) undefined id --> (\g x -> undefined (g x)) id --> (\x -> undefined (id x)) --> undefined
21:41:33 <sjanssen> (\x -> case x of () -> undefined) -- is this undefined in HNF?
21:42:08 <Cale> sjanssen: I suppose you have to be careful about how it interacts with case.
21:42:49 <Cale> sjanssen: My initial impression is that it wouldn't be.
21:43:00 <pumpkin> (\x -> case (round x - 1) of 1.5 -> something; _ -> undefined)
21:43:07 <Cale> (that is, that it's in HNF already)
21:43:17 <pumpkin> ah
21:43:52 <sjanssen> Cale: but (\x -> undefined) would be undefined?
21:43:55 <Cale> right
21:44:05 <sjanssen> seems counter-intuitive
21:44:54 <Cale> I suppose the rule for case would be that a case expression is in HNF if its scrutinee is in HNF (which single variables are) and is not a constructor
21:45:25 <roconnor> you should evalute the branches of case too
21:45:32 <Cale> Should you?
21:45:48 <roconnor> hmm
21:46:15 <Cale> I think you only start evaluating a branch if you can select it, because the HNF of the scrutinee is a constructor which matches
21:46:46 <roconnor> Cale:  I guess you are right
21:47:07 <roconnor> you should evaluate the scrutinee to head normal form.
21:47:13 <Cale> After all, you don't want  case ys of [] -> undefined; (x:xs) -> 1  to evaluate to undefined before ys is known
21:47:20 <roconnor> but if it exposes a constructor, you should of course then evaluate the case.
21:47:26 <Cale> right
21:48:41 <roconnor> sjanssen: with a seq class (called Eval)
21:48:44 <Cale> sjanssen: Evaluating inside the body of a lambda is something which is easy to do if you think of things in terms of lambda calculus and expression rewriting.
21:49:25 <Cale> But if you think in terms of closures and actual machine code which has to run, well, it gets harder to imagine.
21:50:19 <roconnor> Cale: does it?  It seems almost natural.  Do as much computation as you can given that you don't know the parameter.
21:50:42 <Cale> roconnor: Well, machine code tends not to be happy about some things being unbound. ;)
21:50:56 <roconnor> ya
21:51:06 <Cale> I'm not saying that it's impossible, just that it requires a reworking of the way you do things.
21:51:40 <roconnor> true, but I think it isn't so hard to imagine.
21:52:12 <Cale> I did say that it's easy if you're thinking at the level of lambda calculus / term rewriting
21:52:19 <roconnor> do callcc and then pass in some fancy continuation for the value.
21:52:24 <Cale> oh, hmm
21:52:24 <Cale> :)
21:52:43 <Cale> Oh, I wonder if that works
21:52:56 <roconnor> so when the parameter is evaluated you get back, and you are done.
21:53:08 <Cale> right :)
21:53:08 <roconnor> ya, not sure it is the same.
21:53:19 <roconnor> heh, if it is the same, then it is easy to imagine.
21:53:23 <Cale> I think it does, given that it's *head* normal form
21:53:36 <roconnor> if it isn't the same, then I guess it is hard to imagine (from the closure point of view)
21:53:43 <roconnor> Cale: exactly
21:53:49 <Cale> So if you try to evaluate a lambda bound variable, there's nothing else you could conceivably want to do.
21:53:59 <Cale> So you must be finished
21:54:13 <roconnor> there are only 2 things to do with the parameter, case evaluation of function evaluation.
21:54:18 <roconnor> I think that is it.
21:54:23 <Cale> yeah
21:54:26 <roconnor> I guess you could also call seq on it. ...
21:54:37 <Cale> but even then, you are done :)
21:54:41 <roconnor> but I think we just pass through that.
21:54:45 <Cale> yeah
21:55:16 <Cale> We wouldn't want to prematurely evaluate the second parameter of a seq, I think.
21:55:32 <Cale> I suppose you could decide to do that, but it seems unnatural
21:55:44 <roconnor> I think so
21:56:15 <roconnor> now when people use seq on functions, do they really want WHNF or do they want HNF?
21:56:24 <roconnor> ie is seq wrong or right?
21:56:26 <Cale> after all, seq x is supposed to be like case
21:56:44 <Cale> I think HNF is the right thing in order to have the semantics work out pretty.
21:56:52 <roconnor> my answer is to not answer:  get rid of seq on functions. :P
21:57:01 <roconnor> Cale: ah
21:57:09 <pumpkin> doing case on functions seems odd in the first place
21:57:10 <Cale> and yes, I think people do want that
21:57:25 <Cale> Doing seq on functions in order to get HNF would be useful
21:57:50 <Cale> It would give us an explicit way to evaluate inside a lambda before parameters were applied
21:58:09 <roconnor> Cale: but you would lose the ability to evaluate case upto the lambda.
21:58:35 <Cale> yeah, you would go a bit past that
21:59:01 <roconnor> I don't know what people want to do, since I never have used seq on functions
21:59:18 <Cale> Currently it's sort of pointless to do it.
21:59:25 * pumpkin tries to do something useful with category-extras
21:59:38 <Cale> hmm
21:59:45 <Cale> or is it? :)
21:59:51 * roconnor heads to sleep
21:59:58 <Cale> I'm trying to think of a case where you want to foldl a bunch of functions together
21:59:59 <roconnor> tell me tomorrow if you learn anything
22:00:01 <Cale> with some operator
22:00:12 <Cale> (which isn't (.), because you're an idiot if you do that ;)
22:00:17 <pumpkin> lol
22:00:24 <pumpkin> damn, you pre-empted my example :P
22:00:29 <pumpkin> how about >>>? :P
22:00:56 <Cale> See if it's an associative operator, you might as well use foldr
22:01:04 * mgsloan tries to figure out why you'd be an idiot to fold on [a -> a]
22:01:14 <Cale> mgsloan: you want foldr
22:01:24 <Cale> foldr (.) id  is the efficient one
22:01:48 <mgsloan> ah
22:01:58 <Cale> foldl (.) id  will immediately accumulate the whole list before allowing the first function in it to evaluate
22:02:07 <mgsloan> right
22:02:11 <Berengal> My brain is a splode...
22:02:27 <mgsloan> when the functions can be partially evaluated, foldl is as fast though?
22:02:28 <Berengal> ghc tells me so is its brain, but it doesn't make it better :/
22:03:28 <Cale> mgsloan: can't be? Well, I suppose it amounts to the same thing there.
22:03:56 <Cale> The stack will build up regardless in that case.
22:04:11 <Cale> er...
22:04:12 <Cale> hmm
22:04:30 <Cale> yeah, pretty much
22:04:39 <mgsloan> alright :P
22:05:23 <Cale> Prelude> foldl (.) id (replicate 1000000 (+1)) 0
22:05:23 <Cale> *** Exception: stack overflow
22:05:23 <Cale> Prelude> foldr (.) id (replicate 1000000 (+1)) 0
22:05:23 <Cale> *** Exception: stack overflow
22:05:27 <Cale> Prelude Data.List> foldl' (.) id (replicate 1000000 (+1)) 0
22:05:27 <Cale> *** Exception: stack overflow
22:05:49 <hatds> couldn't \fs -> \a -> foldl' ($) a fs  use constant stack space
22:05:54 <Cale> The function you construct is just wasteful of stack in that case.
22:06:16 <hatds> say for fs = [Int->Int]
22:06:20 <Cale> Prelude Data.List> foldl' (flip ($)) 0 (replicate 1000000 (+1))
22:06:20 <Cale> 1000000
22:06:25 <pumpkin> 	category-extras-0.53.5: Various modules and constructs inspired by category theory	Source code	Contents	Index
22:06:25 <pumpkin> Control.Functor.Algebra	
22:06:25 <pumpkin> Portability	non-portable (rank-2 polymorphism)
22:06:25 <pumpkin> Stability	experimental
22:06:25 <pumpkin> Maintainer	Edward Kmett <ekmett@gmail.com>
22:06:26 <pumpkin> Description
22:06:28 <pumpkin> Algebras, Coalgebras, Bialgebras, and Dialgebras and their (co)monadic variants
22:06:30 <pumpkin> Synopsis
22:06:32 <pumpkin> type Dialgebra f g a = f a -> g a
22:06:34 <pumpkin> type GDialgebra f g w m a = f (w a) -> g (m a)
22:06:36 <pumpkin> type Bialgebra f g a = (Algebra f a, Coalgebra g a)
22:06:38 <Cale> hello pumpkin
22:06:42 <Cale> hehe
22:07:02 <pumpkin> fromAlgebra :: Algebra f :~> Dialgebra f Identity
22:07:04 <pumpkin> fromBialgebra :: Bialgebra f g :~> Dialgebra (f :*: Identity) (Identity :*: g)
22:07:06 <pumpkin> Documentation
22:07:07 <Cale> ahahaha
22:07:48 <ClaudiusMaximus> > foldr (concatMap (\n -> [0..n])) (:[]) [1,2,3]
22:07:50 <lambdabot>   Couldn't match expected type `b -> b' against inferred type `[a]'
22:07:52 <Cale> With any luck, his IRC client will cache those pasted unsent lines to disk and reload them when he restarts it :)
22:09:16 <pumpkin> did I catch myself in time to avoid spamming?
22:09:18 <pumpkin> (sorry if I didn't)
22:09:23 <Cale> pumpkin: somewhat
22:09:26 <BMeph> Has anyone else noticed the odd name change for mtl in 10.3?
22:09:35 <pumpkin> my apologies
22:09:41 <Cale> It was kind of funny when you reconnected and the lines continued to paste :)
22:09:47 <Cale> <Cale> With any luck, his IRC client will cache those pasted unsent lines to disk and reload them when he restarts it :)
22:09:47 <pumpkin> ack, weird
22:09:52 <pumpkin> this client sucks
22:09:59 <pumpkin> that is clearly not the behavior someone wants :P
22:10:32 <ClaudiusMaximus> > foldr (concatMap (\n -> [0..n])) (:[]) [id] 3
22:10:33 <lambdabot>   Couldn't match expected type `b -> b' against inferred type `[a]'
22:10:40 <ClaudiusMaximus> > foldr (concatMap (\n -> [0..n])) (:[]) id 3
22:10:41 <lambdabot>   Couldn't match expected type `b -> b' against inferred type `[a]'
22:10:48 * ClaudiusMaximus gives up
22:10:55 <pumpkin> anyway, I was wondering if anyone could provide some intuition on the GAlgebra type
22:11:05 <pumpkin> I can clearly just come up with [[]] instances and so on
22:11:21 <Cale> :t concatMap (\n -> [0..n])
22:11:23 <lambdabot> forall a. (Num a, Enum a) => [a] -> [a]
22:11:29 <Cale> ClaudiusMaximus: ^^ there is your problem :)
22:11:38 <Cale> (not enough function parameters)
22:11:53 <ClaudiusMaximus> aha
22:12:43 <Cale> pumpkin: Where is that defined?
22:13:05 <pumpkin> same as http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Functor-Algebra.html#t%3AGAlgebra
22:15:05 <Cale> oh, odd
22:15:24 <Cale> I wonder if there's anything they have to satisfy
22:15:26 <pumpkin> RunComonadCofree f w seems to be a common constraint on its first two parameters
22:15:49 <pumpkin> histo :: RunComonadCofree f w => GAlgebra f w a -> FixF f -> a	
22:17:28 <Berengal> Someone should figure out a nice language to do type programming in...
22:18:01 <lispy> Berengal: but when you program in the type system it is untyped...
22:18:06 <lispy> Berengal: so where is the fun in that :)
22:18:17 <Berengal> It's kinded
22:18:25 <lispy> True
22:18:39 <lispy> I guess in a sense, we're just low level prolog programmers
22:18:44 <jmcarthur> lispy: only in haskell, you mean
22:18:50 <jmcarthur> heh
22:18:58 <Berengal> Prolog has a much nicer syntax...
22:19:00 <pumpkin> we need kindclasses!
22:19:08 <Berengal> kind families?
22:19:13 <lispy> pumpkin: yeah, I've said taht before
22:19:22 <lispy> Doesn't Omega basically have kind classes?
22:19:24 <jmcarthur> yeah i have made the prolog analogy myself at one point, but i forgot what was so revolutionary about that to me at the time
22:19:57 <lispy> jmcarthur: I barely get prolog, but my understanding is that type classes work just like prolog's search
22:20:11 <lispy> type classes == horn clauses, essentially
22:20:49 <ClaudiusMaximus> > foldr map [100,200,300] [(+1), (*5)]
22:20:50 <lambdabot>   [501,1001,1501]
22:21:25 <lispy> > foldl map [100, 200, 300] [(+1), (*5)]
22:21:27 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[b]'
22:25:11 <Tsion> > foldl (flip map) [100,200,300] [(+1), (*5)]
22:25:13 <lambdabot>   [505,1005,1505]
22:26:10 <blackdog> what's the procedure when you need to upgrade Cabal but you have a whole bunch of code (including ghc) dependent on the old version? Is there an easy way to recompile, or do you just have to reinstall everything?
22:26:14 <lispy> ?scheck foldl (flip map) == foldr map
22:26:15 <lambdabot>   No instance for (GHC.Classes.Eq ([b] -> [b -> b] -> [b]))
22:26:15 <lambdabot>    arising from a...
22:26:39 <Berengal> Anyone know how to do conditionals in the type system?=
22:26:42 <lispy> ?scheck \xs -> foldl (flip map) xs == foldr map (xs::[Int])
22:26:43 <lambdabot>   No instance for (GHC.Classes.Eq
22:26:43 <lambdabot>                     ([GHC.Types.Int -> GHC....
22:27:09 <lispy> ?scheck \xs ys -> foldl (flip map) xs ys == foldr map (xs::[Int]) ys
22:27:10 <lambdabot>   Overlapping instances for GHC.Show.Show
22:27:10 <lambdabot>                              (GHC.T...
22:27:14 <lispy> hmm
22:27:27 <lispy> Berengal: iirc, the HList paper has them
22:27:30 <lispy> data HTrue
22:27:32 <lispy> data HFalse
22:27:56 <Berengal> lispy: Is it possible to use them in value computations as well?
22:28:13 <lispy> Berengal: not sure what you're after
22:28:18 <Berengal> Neither am I ... :/
22:28:31 <lispy> Berengal: you want the value to depend on the type?
22:28:48 <lispy> Berengal: that just sounds like ad-hoc polymorphism (type classes should work)
22:29:08 <Berengal> Yeah, trouble is I'm having some problems fitting this into type classes...
22:29:51 <pumpkin> big crypto result this year! we need a haskell implementation now
22:30:08 <Berengal> I'd need to introduce a Map type family in the class ...
22:31:28 <lispy> what are you trying to do?
22:31:39 <BMeph> lispy: (reverse ys) :)
22:31:42 <Berengal> I feel like I'm so close to getting this to do what I want... I've got several ugly workarounds that should work, but they're ugly...
22:32:04 <lispy> BMeph: ah
22:32:07 <Berengal> lispy: Create a map that can be indexed by several different indexes
22:32:29 <lispy> Berengal: map meaning Data.Map?
22:32:32 <lispy> Berengal: not fmap?
22:32:33 <Berengal> Yes
22:32:50 <lispy> Berengal: huh, not sure how that makes sense
22:33:04 <pumpkin> we need a modern crypto package or two
22:33:04 <lispy> Berengal: so you have one instance of your map and you want multiple types to behave as the index set?
22:33:05 <pumpkin> or a dozen
22:33:06 <Berengal> To put it simple: I want the Data.Map version of 'lookup :: (Eq k) => (v -> k) -> k -> [v] -> Maybe v
22:33:40 <lispy> ?hoogle Data.Map.lookup
22:33:40 <lambdabot> Data.Map lookup :: (Monad m, Ord k) => k -> Map k a -> m a
22:33:40 <lambdabot> Data.Map lookupIndex :: (Monad m, Ord k) => k -> Map k a -> m Int
22:33:40 <lambdabot> Data.Map insertLookupWithKey :: Ord k => (k -> a -> a -> a) -> k -> a -> Map k a -> (Maybe a, Map k a)
22:34:07 <Berengal> So you can do stuff like 'lookupBy phoneNumber personWithPhoneNumberMap'
22:34:18 <Berengal> (plus a phone number, obviously...)
22:35:10 <lispy> huh, so phoneNumber :: Eq k => v -> k
22:35:19 <lispy> What is v?
22:36:11 * pumpkin is trying desperately to actually construct valid parameters to histo
22:36:41 <Berengal> v is the value
22:36:56 <Berengal> and phoneNumber would be Person -> PhoneNumber
22:37:12 <jmcarthur> pumpkin: big crypto result? you mean the fully homomorphic encryption paper?
22:37:21 <pumpkin> jmcarthur: yeah
22:37:31 <lispy> Berengal: I wouldn't expect that to need to be part of the lookup function itself
22:37:35 <Berengal> The best solution I can currently see working is something like 'lookupBy phoneNumberIndex Person{phoneNumber = foo} personMap'
22:37:44 <jmcarthur> yeah, i'm excited by the possibilities it might open up. i'm crossing my fingers that there isn't some huge catch to it
22:37:49 <jmcarthur> i wish i could understand it
22:38:16 <jmcarthur> need some prereqs :\
22:38:29 <pumpkin> jmcarthur: yeah, I look forward to companies offering services that can do stuff to my data without me worrying about privacy :)
22:38:40 <Berengal> lispy: the regular lookup function would be 'lookup = snd . lookupBy fst'
22:38:44 <Berengal> fmap snd
22:38:50 <pumpkin> jmcarthur: I'm itching to make a haskell implementation but the math is over my head :(
22:38:56 <jmcarthur> pumpkin: i'll make sure and let everybody at work know about this ;)
22:39:03 <jmcarthur> pumpkin: yeah me too :(
22:39:28 <pumpkin> we need more of an intersection between crypto/security people and the haskell world
22:39:32 <lispy> Berengal: but the type you are wanting to use seems like it needs more things than it should (to me)
22:39:56 <lispy> Berengal: and why does it take [v] ?
22:40:04 <jmcarthur> pumpkin: probably much of that intersection is absorbed into the classified depths of Galois projects or somewhere
22:40:08 <Berengal> lispy: No, it needs a function from values to keys, a key, and a list of values, and return Maybe value
22:40:11 <pumpkin> jmcarthur: yeah :/
22:40:18 <pumpkin>     No instance for (Show ([Cofree [] Int] -> Int)) :(
22:40:41 <jmcarthur> can't say i only looked at the Galois job posting on the mailing list once
22:40:59 <jmcarthur> especially since they have foosball ;) (we have foosball where i currently work, too)
22:41:17 <pumpkin> jmcarthur: it's awfully tempting... makes me want to not be "otherwise engaged" :P
22:42:25 <lispy> Berengal: I have this feeling like I'd just map the (v -> k) function over the list and then pass that and the key I want
22:42:32 <pumpkin> I wish there were more documentation on category-extras
22:42:37 <jmcarthur> i'm satisfied with not going for it though. i don't want to be stuck in the classified world
22:42:40 <pumpkin> type PAp p = Biff p Identity	
22:42:42 <lispy> pumpkin: just bug ed
22:42:43 <jmcarthur> well, i already am to an extent
22:42:44 <Berengal> lispy: Then you'd lose all the other information
22:42:50 <jmcarthur> but not with my haskell stuff
22:43:04 <Berengal> lispy: You'd just find a phone number you already have. It'd become the elem function
22:43:05 <pumpkin> lispy: yeah, but he's been quite absent recently
22:43:16 <lispy> Berengal: Such as?  in your example it was forall v. so what do you know about v?
22:43:23 <jmcarthur> pumpkin: he was just in here earlier today
22:43:29 <pumpkin> jmcarthur: yeah, but I missed him :/
22:43:38 <jmcarthur> wait, no you didn't!
22:44:06 <pumpkin> I was around?
22:44:08 <jmcarthur> you were asking about the prospect of type families in category-extras
22:44:15 <pumpkin> oh, that time
22:46:00 <Berengal> lispy: Whatever the caller knows
22:46:06 <lispy> Berengal: okay.  I think I see what you mean.  So, I would zip something :)
22:46:07 <hackagebot> nemesis 2009.6.12 - a rake like task management tool (JinjingWang)
22:46:33 <Berengal> lispy: Yeah, it's not hard to alists, but how would you do it for maps?
22:46:57 <Berengal> The entire point of maps in O(log n) lookup and insert. You need to preserve that
22:47:16 <lispy> but, you gave it [v]
22:47:36 <Berengal> And a function (v -> k)
22:47:51 <Berengal> 'find' is just 'lookupBy id'
22:48:03 <lispy> lookup ::  (Eq k) => (v -> k) -> k -> [v] -> Maybe v
22:48:11 <lispy> So I guess your map is missing in the type?
22:48:31 <Berengal> The thing about maps is that they have only one index
22:48:34 <lispy> I thought you were looking it up on lists because of the [v]
22:48:51 <Berengal> You could of course make more than one map, but that means administrating all of them whenever you modify it
22:49:12 <Berengal> I said I wanted to Data.Map version of the alist function
22:49:38 <lispy> I guess I misunderstood the question since that type
22:49:44 <lispy> I thought that *was* the type you were after
22:49:55 <Berengal> Yeah, I don't even know what the type I'm after is, completely...
22:50:32 <lispy> lookupBerengal :: (Eq k) => (v -> k) -> k -> BerengalMap k v -> Maybe v
22:50:56 <lispy> at least for some v that would work, right?
22:51:14 <Berengal> What I have now is: createMap :: (typeList ~ LFuncRet indexerList, indexerList ~ LFuncFrom value typeList, map ~ MultiIndexMap value typeList, List indexerList) => indexerList -> (map, LAp (Indexer map) typeList)
22:51:32 <Berengal> That creates an empty map...
22:51:34 <lispy> lookupBerengal :: (Keyable v k, Eq k) => (v -> k) -> k -> BerengalMap k v -> Maybe v
22:52:03 <lispy> oh oops, I didn't need the first param
22:52:16 <lispy> lookupBerengal :: (Keyable v k, Eq k) => k -> BerengalMap k v -> Maybe v
22:56:03 <Berengal> It's not too hard to build something like this given cases, but doing it for the general case eludes me...
22:58:59 * ivanm likes geezusfreeek's responses here: http://www.reddit.com/r/programming/comments/8rnrr/c_versus_c/
23:02:13 <pumpkin_> jmcarthur: zomg have you seen geezusfreeek's responses? :P
23:03:48 <pumpkin_> ☝
23:05:57 <ivanm> pumpkin_: oh, is that what you guys were talking about before? :s
23:06:05 <pumpkin_> nah :)
23:06:08 <pumpkin_> just being silly really
23:06:11 <ivanm> and is that meant to be a disabled person?
23:06:19 <ivanm> pumpkin_: you mean being your normal self? :p
23:06:20 <pumpkin_> nope, it's a hand pointing up
23:06:22 <jmcarthur> ivanm: i am geezusfreeek ;)
23:06:29 <pumpkin_> ivanm: yeah :)
23:06:30 <ivanm> oh :s
23:06:49 <ivanm> > "geezusfreeek" == "jmcarthur"
23:06:51 <lambdabot>   False
23:07:10 <pumpkin_> it seems really hard in many cases to create values of many of the types in category-extras
23:07:14 <jmcarthur> hmm.... i wonder if maybe i should associate this nick with my old one
23:07:46 <pumpkin_> jmcarthur: on twitter you can actually change your nickname if you want to
23:08:28 <jmcarthur> pumpkin_: oh i didn't know that. thanks. i might get around to doing that
23:08:35 <jmcarthur> i haven't been twittering lately
23:08:43 <pumpkin_> it's a bit of a pain though, there's no transitioning mechanism
23:08:47 * ivanm has never been twittering... what's your point?
23:08:54 <pumpkin_> so your old nick is up for grabs and has no indication that you were ever there
23:09:01 <jmcarthur> oh, ugh
23:10:03 <pumpkin_> yeah, someone's squatting my old nick already :P
23:10:18 <pumpkin_> anyone who was following you gets updated, at least
23:11:06 <ivanm> what's your old nick?
23:11:20 <pumpkin_> I was pumpkingod, decided to change it to copumpkin
23:13:54 <walter_> In newtype Parse a = Parse {runParse :: ParseState -> Either String (a, ParseState)},  if I create a instance Parse a, how does runParse work?
23:15:54 <walter_> Does every instance run the runParse right after it was created?
23:17:54 <sjanssen> walter_: I don't quite understand your question
23:18:32 <pumpkin> can I make a type synonym for a partially applied type constructor?
23:18:32 <sjanssen> in your example, 'runParse' doesn't run anything, it just extract the data stored in a Parse (in this case a function)
23:19:01 <sjanssen> pumpkin: there are some restrictions on that
23:19:16 <pumpkin> ah
23:19:22 <walter_> sjanssen, I mean, is the Parse a same as runParse :: ParseState -> Either String (a, ParseState)?
23:19:22 <pumpkin> type PAp p = Biff p Identity	-- was confusing me
23:19:31 <pumpkin> since Biff takes 5 type parameters
23:20:33 <sjanssen> walter_: a value of type 'Parse a' and 'ParseState -> Either String (a, ParseState)' have the same representation, but don't have the same type
23:21:41 <pumpkin> and then we get type PCofree = PAp (,)
23:21:49 <pumpkin> and PCofree gets applied to type arguments
23:21:59 <sjanssen> pumpkin: I think it's a GHC extension
23:22:01 <pumpkin> so it ends up being PCofree = Biff (,) Identity
23:22:04 <pumpkin> ah
23:22:34 <pumpkin> that's kind of fun... I remember trying that a while back and it not working
23:22:38 <walter_> sjanssen, I am not understand why there is a runParse in the constructor Parse.
23:22:43 <pumpkin> I guess I didn't bother looking for an extension :)
23:22:48 <sjanssen> walter_: that's record syntax
23:23:16 <sjanssen> walter_: that part automatically defines a runParse function that extract the value wrapper by Parse
23:23:53 <sjanssen> pumpkin: well, there are loads of restrictions.  For example, you're not allowed to partially apply types like PAp
23:24:14 <pumpkin> ah
23:24:37 <walter_> sjanssen, I see. Thank you! Well, I think I have to find some more details on record syntax
23:28:14 * pumpkin expanded Cofree f a into (Biff (,) Identity f a (Fix (Biff (,) Identity f) a))
23:31:28 <pumpkin> maybe that's a sign I should be going to sleep
23:47:16 <Mr_Awesome> if i type "ghc --make Test" in a directory with Test.hs containing a main function, should there be an executable produced, or just object files?
23:48:08 <ivanm> Mr_Awesome: Test.hs you mean, not just Test ?
23:48:25 <ivanm> and it should produce an executable if Test is the Main module (or doesn't have a module defined)
23:48:33 <ivanm> not sure what happens if it is a different module name
23:49:41 <Mr_Awesome> ah, so the module itself must be named Main.
23:49:46 <Mr_Awesome> that must be where i went wrong.
23:50:26 <ivanm> yeah
23:50:35 <ivanm> or I think you can not bother giving it a module declaration
23:51:17 <Mr_Awesome> i was not aware of that. thank you.
23:59:34 <shachaf> ivanm: --make Test works, the .hs is not necessary.
23:59:47 <ivanm> oh.... *shrug*
