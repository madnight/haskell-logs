00:00:32 <rob__> is there no way to do     class Object Plane where ... for data Objects = Plane ...?
00:03:17 <dmwit> rob__: You may be a little confused about what class means.
00:03:25 <dmwit> It doesn't mean the same thing in Haskell that it does in other languages.
00:03:49 <dmwit> In Haskell, a "class" is a collection of types, and some operations that work on those types.  Nothing more, nothing less.
00:04:07 <dmwit> If you have a data declaration, that creates one single type; not much sense creating a class just for that one type.
00:04:17 <bos> @let m n = if n > 200000 then n - 20000 else m (m (n + 20001))
00:04:20 <lambdabot>  <local>:7:40:
00:04:20 <lambdabot>      Ambiguous occurrence `m'
00:04:20 <lambdabot>      It could refer to either `L...
00:04:27 <rob__> so would I have to define a new data type for every object then?
00:04:43 <bos> @let eff n = if n > 200000 then n - 20000 else eff (eff (n + 20001))
00:04:58 <lambdabot>  Defined.
00:05:05 <bos> > eff 2
00:05:11 <lambdabot>   mueval-core: Prelude.read: no parse
00:05:11 <lambdabot>  mueval: ExitFailure 1
00:05:17 <dmwit> rob__: I'm not even sure I understand your question.
00:05:21 <dmwit> rob__: What is an object?
00:05:25 <bos> huh.
00:05:36 <bos> > eff (222::Int)
00:05:42 <lambdabot>   mueval-core: Prelude.read: no parse
00:05:42 <lambdabot>  mueval: ExitFailure 1
00:05:50 <rob__> oh by object I just meant a sphere, plane, torus etc...
00:05:53 <bos> lambdabot--
00:06:14 <ray> @thump
00:06:14 <lambdabot> Unknown command, try @list
00:06:44 <dmwit> rob__: I expect you'd have a single data type for shapes, and spheres, planes, toruses, etc. would simply be values of that type.
00:07:02 <dmwit> rob__: But I can't say for sure, as I don't know the problem space very well.
00:09:24 <rob__> dmwit: that's what I was doing, but I wanted to implement an intersect function for each one of them, so I tried using a type class and make each object an instance of it
00:16:26 * edwardk waves hello.
00:16:58 <dmwit> Hiya, edwardk!
00:17:10 <dmwit> Are you coming to Hac Phi?
00:17:20 <edwardk> Looks highly probable
00:17:32 <dmwit> awesome!
00:18:03 <dmwit> I look forward to days of type hackery. =D
00:18:09 <edwardk> I may drag a statistician friend of mine who is doing some work on the hbc BUGS model compiler, and see if we/he can interest folks in helping out on that project
00:18:45 <dmwit> hbc?
00:19:00 <edwardk> http://www.cs.utah.edu/~hal/HBC/hbc.pdf
00:19:00 <dmwit> Whoa, this?
00:19:04 <dmwit> http://www.cs.chalmers.se/~augustss/hbc/hbc.html
00:19:14 <edwardk> the other one
00:19:27 <dmwit> Okay, your link looks a lot more recent than mine. =)
00:19:28 <edwardk> I've been teasing Aleks that he should try to get Hal to change its name =)
00:20:09 <dmwit> Ah, this looks pretty cool.
00:21:37 <FERRET_SWAMI> haskell whats up folks
00:21:45 <FERRET_SWAMI> seems like a rpetty exciting lang you all have here
00:22:00 <edwardk> Personally, I'm interested in updating the interpreter that has fallen into disuse to include the current feature set of the compiler and in looking into what can be done to distribute the model over the network, etc.
00:22:44 <edwardk> That, and seeing if some/all of the surface language could be rewritten into just an EDSL for haskell rather than a traditional compiler model.
00:23:02 <edwardk> that would allow for the use of haskell to provide higher order tools for model specification.
00:23:13 <edwardk> FERRET_SWAMI: we're fond of it =)
00:23:53 <FERRET_SWAMI> paul graham site said he was disappointed with staatic typing
00:23:55 <FERRET_SWAMI> languages
00:24:09 <Twey> Paul Graham says a lot of things
00:24:09 <FERRET_SWAMI> can haskell let em write programs bit by bit
00:24:13 <FERRET_SWAMI> me-
00:24:15 <Twey> Yes
00:24:28 <FERRET_SWAMI> for example a program to monitor a website I build
00:24:31 <edwardk> paul graham also has a nice little law in which he points out that 'no one sees the point in any language more powerful than his own' it seems he is somewhat hoist on his own petard in that regard ;)
00:24:33 <FERRET_SWAMI> using snmp
00:24:39 <Twey> edwardk: Heheheh
00:24:42 <p_l> FERRET_SWAMI: Yes, it can, though I miss Lisp-style development
00:24:55 <FERRET_SWAMI> I have 2 or 3 haskell book
00:25:01 <FERRET_SWAMI> but when I see -->
00:25:04 <p_l> edwardk: that would be the matter with Arc, I guess. It became a laughing matter in Lisp circles as well :P
00:25:15 <FERRET_SWAMI> and stuff I feel like I missed some prereq class..
00:25:22 <FERRET_SWAMI> can I learn programmign from scratch with ahskell?
00:25:35 <sjanssen> edwardk: yes, I always found his talk about "blub" ironic
00:25:35 <edwardk> i like the idea of arc, i've even stolen some ideas from it in my toy compilers, but yeah
00:25:49 <p_l> FERRET_SWAMI: I guess you can, though the way of programming would be slightly different than let's say C
00:25:59 <FERRET_SWAMI> haskell one thing I like is that it can utilize many cpu
00:26:01 <FERRET_SWAMI> right?
00:26:11 <FERRET_SWAMI> I never learned c
00:26:12 <FERRET_SWAMI> ..
00:26:18 <FERRET_SWAMI> I have the k+r book
00:26:35 <FERRET_SWAMI> plan9 people even told me that c can be quite high level with file abstractions
00:27:09 <edwardk> FERRET_SWAMI: haskell can work nicely on multiple cpus because it carefully controls the side effects of code, so you can know how multiple threads will interact in ways you can't with a more traditional language
00:27:10 <Twey> That's not making C high-level
00:27:19 <p_l> FERRET_SWAMI: They are right, but C is different - it's more like portable assembler, frankly speaking. But steer away from C++ :D
00:27:30 <Twey> That's using existing C interfaces to interact with a high-level system
00:27:37 <edwardk> FERRET_SWAMI: plan9 just makes everything into a file. if you only have a hammer...
00:27:44 <FERRET_SWAMI> llol
00:27:56 <FERRET_SWAMI> happstack looks liek cool website tool
00:28:17 <edwardk> don't get me wrong, its an incredibly general interface, but not everything can be cleanly mapped onto the file abstraction, nor necessarily should it
00:28:19 <FERRET_SWAMI> I have booko by hutton an antoher bybhudak
00:28:33 <FERRET_SWAMI> haskell is super 'high level'
00:28:35 <FERRET_SWAMI> I hear
00:28:38 <edwardk> FERRET_SWAMI: i'd recommend two sources. Learn You a Haskell for Great Good, and Real World Haskell.
00:28:49 <FERRET_SWAMI> does this really make it way more fun than popular langs liek ruby
00:28:53 <Twey> FERRET_SWAMI: Well
00:28:53 <FERRET_SWAMI> ok
00:28:58 <edwardk> Real World Haskell will dispel the 'super high level' myth to some extend, and Learn You a Haskell is very accessible.
00:29:02 <Twey> It's kind of high-level, and kind of low-level.
00:29:02 <edwardk> er extent
00:29:16 <Twey> It's quite far away from the hardware (by default)
00:29:33 <Twey> But in terms of language and mathematics, I'd say it's closer to its foundations than C
00:29:38 <edwardk> to me what i like about haskell is that it is the best language i've found to 'think in'.
00:29:52 <FERRET_SWAMI> think in
00:30:11 <FERRET_SWAMI> functional you try to jsut think about howto compute the asnwer you want
00:30:15 <FERRET_SWAMI> like my bank balance
00:30:18 <edwardk> Its my own personal Blub. I don't see the point of those weird dependently typed languages in which you can never seem to get anything done, and I don't like less powerful languages because they are missing so many features I'm used to.
00:30:22 <FERRET_SWAMI> or order for 4 new cool t shirt
00:30:35 <FERRET_SWAMI> hmm
00:30:37 <FERRET_SWAMI> hmmmmmmmmmm
00:30:46 <jeffwheeler> That makes me think we need Haskell shirts that don't suck.
00:31:11 <FERRET_SWAMI> now what about the schuette problem: 95% of servers at load avg 0.3 while 5% of servers at load avg 17
00:31:17 <dmwit> edwardk: heh, I like that
00:31:34 <dmwit> Managers rise to their level of incompetence, programmers rise to their level of Blub. =)
00:31:43 <edwardk> dmwit: heh
00:31:50 <FERRET_SWAMI> "once you go hask, you never go back!: haskell.org"
00:32:10 * Twey twitches.
00:32:16 <edwardk> well, I generally just look at what I can get done in a weekend in Haskell, and then I compare it to what a good Coq developer can get done, he won't have finished trying to figure out what he's trying to say yet ;)
00:32:22 <FERRET_SWAMI> the dream of business people is apps on commodity hardware that are immune to failure
00:32:43 <p_l> FERRET_SWAMI: No, the dream of business people is clients who have money and no brains
00:32:56 <dmwit> Immune to failure?
00:33:01 <dmwit> That sounds tricky.
00:33:07 <FERRET_SWAMI> uh oh, looks like I thought wrong, again
00:33:07 * dmwit pulls the plug and shoots the UPS
00:33:16 <FERRET_SWAMI> well somehow you have 40 servers
00:33:18 <edwardk> p_l: i'm fond of clients with both money and brains, its easier to reason with them, and you can make them more profitable more easily so they keep coming back to you for more.
00:33:24 <FERRET_SWAMI> and the app adjsuts if 3 die
00:33:28 <FERRET_SWAMI> and notifies you
00:33:38 <edwardk> FERRET_SWAMI: then you probably want Erlang ;)
00:33:44 <FERRET_SWAMI> mogileFS I think by danga interactive is a huge step
00:33:47 <p_l> edwardk: that's rare, the big players want idiots :_
00:33:49 <p_l> *:P
00:33:54 <edwardk> they've been doing that sort of thing for years =)
00:34:04 <FERRET_SWAMI> Im amazed how much idiots pay for 'managed' hosts
00:34:06 <FERRET_SWAMI> hosting
00:34:13 <FERRET_SWAMI> 'managed hosting'
00:34:30 <FERRET_SWAMI> erlang, hmm, erlang....I heard its nice
00:34:36 <FERRET_SWAMI> even has a webserver yaws
00:34:38 <Twey> It's not nice
00:34:43 <Twey> It's a horrible language
00:34:47 <edwardk> FERRET_SWAMI: its not all that idiotic to focus on your core competencies and farm out the rest, specialization is one path to suceess.
00:34:51 <Twey> But it is built on some nice concepts
00:35:33 <Twey> I agree with edwardk
00:35:42 <Twey> People with brains are much nicer to work for than people with no brains
00:36:23 <p_l> Twey: to work for. Hearing some of "big industry" (not necessarily computer industry) heads talk, I think they want cattle
00:36:29 * jeffwheeler likes Cabal's new warning about the package index being more than 15 days old or so
00:36:40 <dmwit> The nicest part is when they succesfully identify the clever solution to a hard problem. =D
00:36:48 <edwardk> I like the idea of erlang, but perhaps I'm a language bigot. I want some types and I miss laziness and its slightly better asymptotics too much. And I much prefer constructors with variable arities and Haskell's partial applicative style to the prolog full application style
00:36:59 * Twey nods.
00:37:24 <dmwit> jeffwheeler: Boy howdy!
00:37:33 <p_l> edwardk: well, my policy is to learn a few good tools and then use "choose best tool for the job" way :)
00:37:41 <jeffwheeler> dmwit: your work? :)
00:37:56 <dmwit> jeffwheeler: Nope, I just totally agree with you!
00:37:58 <dmwit> Cabal rocks!
00:38:04 <jeffwheeler> Ah, yep.
00:38:22 <edwardk> p_l: yeah. i'm glad i added haskell to my toolbox, though i seriously took a left turn somewhere and it became more of the focus of my research than the means ;)
00:38:36 <jeffwheeler> The whole system kicks the pants off of those for other languages . . . Python's mess of installation tools comes to mind.
00:40:14 <dmwit> It helps that our main implementation started out with a pretty sane packaging system.
00:40:27 <hackagebot> minesweeper 0.4
00:40:34 <dmwit> Minesweeper??
00:40:42 <dmwit> ?hackage minesweeper
00:40:42 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/minesweeper
00:40:46 * jeffwheeler installs.
00:41:00 <edwardk> my biggest fear for hackage/cabal is the 'layering problem', which is more of a language design/library feature interaction issue. its hard to layer in new abstractions, because if you have a suitably large non-trivial library that introduces new instances for a lot of existing code, you can't split it in a way that makes it palatable to push all of the instances down into the source libraries without making orphan 
00:41:03 <p_l> dmwit: that's true. On Lisp, the last sensible package manager I had seen was for Genera, I think :D
00:41:06 <FERRET_SWAMI> I heard darcs got beat up for performance problems
00:41:11 <edwardk> so there is a 'new abstraction tax' inherent in the language that bugs me
00:41:20 <FERRET_SWAMI> and mercurial and git are these really good code lockup tools
00:41:49 <FERRET_SWAMI> is darcs no longer considered a competitor?
00:41:54 <FERRET_SWAMI> in the source safe wars
00:42:12 <MyCatVerbs> FERRET_SWAMI: depends on how large your repositories are, mostly.
00:42:15 <edwardk> FERRET_SWAMI: i prefer darcs over git for my personal projects, because its so much nicer to be able to pick and choose bits and pieces of patches in darcs, but git does seem to work in the large well.
00:42:22 <Beelsebob1> darcs is an excellent compettitor still, as long as you only have small to medium sized repos
00:42:34 <Beelsebob1> Mercurial I've found horibly unreliable
00:42:50 <edwardk> what i like about darcs is that when i'm working on a 1-3 developer project, darcs just slots right into the work flow and gets out of the way.
00:42:52 <MyCatVerbs> I still use darcs myself, but friends of mine have switched over to Mercurial, and the GHC project switched to Git because of darcs' performance issues.
00:43:01 <edwardk> and i'm never messing around dealing with messy merges, etc.
00:43:12 <dmwit> No other system beats darcs' UI yet.
00:43:25 <edwardk> ghc also has to deal with ~10 years of history or something crazy like that
00:43:28 <cads> git's cola is not a bad ui
00:43:43 <MyCatVerbs> Mmmmmost of darcs' problems don't come up until you get to a fairly large quantity of code.
00:43:52 <cads> rather, cola for git
00:44:31 <FERRET_SWAMI> good night all
00:44:36 <jeffwheeler> That minesweeper game is great.
00:44:43 <edwardk> the main thing i like about darcs is that i just sort of initialize the repository and i don't think about it until its saving my ass
00:44:56 <maxote> darcs' performance issues can be improved if the GHC's performance issues are solved
00:45:00 <jeffwheeler> I love the probabilities features.
00:45:14 <edwardk> jeffwheeler: the oz thing?
00:45:34 <jeffwheeler> edwardk: C-p in the minesweeper package on Hackage that was just updated
00:45:58 <jeffwheeler> edwardk: it shows the probabilities that each square might contain a mine, given the revealed locations.
00:45:59 <edwardk> ah
00:46:09 <edwardk> ok, so the same idea
00:46:27 <dmwit> uh-oh
00:46:35 <dmwit> I accidentally ln -s something .
00:48:09 <sjanssen> maxote: darcs issues at this point don't really have anything to do with the compiler
00:51:55 <dmwit> Hey, this minesweeper game is really cool!
00:52:37 <dmwit> jeffwheeler: Try focusing another window while you're playing.
00:53:48 <jeffwheeler> dmwit: you mean that it pauses?
00:54:13 <dmwit> yep
00:54:18 <jeffwheeler> The default GNOME Minesweeper does that, but I'm impressed with the 'lucky' stuff at the top.
00:54:22 <dmwit> But just in general the idea is totally rad.
00:54:30 <dmwit> Guaranteed no guessing.
00:54:40 <dmwit> If you die, it's because you didn't reason well enough. =)
00:54:43 <jeffwheeler> I'm not that good, though. ;)
00:54:49 * dmwit is
00:55:00 <dmwit> More importantly
00:55:04 <jeffwheeler> I'm trying to learn, based on its probabilities.
00:55:06 <MyCatVerbs> dmwit: IIRC there's a paranoid version of Minesweeper too.
00:55:07 * dmwit 's mother is
00:55:30 <MyCatVerbs> Where the game plants a mine under the cursor whenever it's possible for a mine to be there.
00:55:33 <dmwit> MyCatVerbs: What, it always kills you if it can?
00:55:37 * dmwit nods
00:55:39 <dmwit> jerks
00:55:46 <MyCatVerbs> Aye.
00:56:19 <jeffwheeler> It must be very difficult to start that game. ;)
00:56:47 <jeffwheeler> (Alternatively, that could make it very easy to program.)
01:02:45 <dmwit> yipe!
01:02:59 <dmwit> It gets a little slow if you guess randomly a lot at the beginning. =P
01:05:38 <MyCatVerbs> Heh.
01:06:01 <cads> http://projectfortress.sun.com/Projects/Community/wiki/FortressQuestions#InwhatwaysdoesFortresssyntaxresemblemathematicalnotation
01:06:07 <cads> oh my god
01:06:16 <cads> I want to code in that.
01:06:58 <cads> except... those semantics look imperative ...
01:08:29 <flux> cads, but here clearly is a difference between bindings and assignments
01:08:44 <cads> ah, very very true!
01:08:58 <cads> I missed right over that
01:09:55 <flux> haven't heard of Fortress much since it was announced
01:10:09 <cads> nope
01:10:22 <cads> people are commiting code to it though
01:10:45 <cads> I think they lost their funding and now it's just an open project
01:11:05 <cads> I'm trying to find a mailing list or something
01:11:20 <cads> the whole rendering to tex thing is fucking supreme.
01:12:01 <cads> something that's been really souped up like that could be pretty nice for haskell
01:12:29 <cads> the day I see an integral symbol in computer code will be a happy day
01:12:42 <rick_2047> well in there general forums there is only one topic and that too 2 years old
01:12:49 <MyCatVerbs> There's TeX style literate Haskell notation, though that doesn't do much for you.
01:12:51 <dmwit> Well, Agda uses Unicode.
01:13:03 <dmwit> So you can get the integral symbol if you really want it.
01:13:24 <rick_2047> cads, http://research.sun.com/projects/plrg/faq/index.html#twelve <-- here is your mailing list
01:13:50 <ray> it's true, haskell should look like that
01:14:30 <MyCatVerbs> ray: excuse me if I take a sliiiightly derisory view of combinators whose names are difficult to type on any keyboard that I own.
01:15:14 <cads> rick_2047: thanks bud :)
01:15:49 <rick_2047> cads, your most welcome
01:16:13 <ray> monospaced code listings are so 1970s
01:16:37 <cads> MyCatVerbs: you'd type \special_shit_{underscript}^{overscript}_subscript^superscript (function args) 3 beers a cigarette some pizza
01:17:09 <cads> you you have to touch tex, that is
01:17:15 <ray> i was thinking more "a fancy editor" than "write it in latex" myself
01:17:31 <ray> if it doesn't look pretty while you're entering it what good is it
01:17:37 <cads> I think this has special rules for turning it pretty
01:17:42 <MyCatVerbs> cads: aye, but that's TeX notation (which I'm happy with), rather than putting Unicode characters right in (which is a pain in the unmentionables, for the moment).
01:18:12 <MyCatVerbs> cads: ray suggested the latter, so I went "bletch!".
01:19:13 <cads> a generic way of mapping tex to various programming semantics would be neat
01:19:27 <cads> I wouldn't mind writing code in renderable tex
01:19:40 <cads> as long as well written programs would typeset well :)
01:20:08 <QtPlaty[HireMe]> Well TeX is turing compleate.
01:20:15 <cads> I'd be killing two birds with one stone, coding and documentation
01:20:26 <ray> you just need a fancy editor
01:20:29 <ray> emacs could probably do it
01:20:32 <MyCatVerbs> SCIM has a mode that lets you put unicode maths characters in by giving their TeX names, but it was a pain in the arse last time I tried to set it up, and it's kind of incomplete.
01:20:40 <cads> QtPlaty[HireMe]: sure, but the symbols don't have any semantics of their own
01:21:02 <MyCatVerbs> Plus, it wouldn't work anywhere near Windows, which is a bit of a problem too. (And that's me saying that as a diehard Unix goon.)
01:21:35 <MyCatVerbs> QtPlaty[HireMe]: not only that, but TeX is deliberately Turing-complete several times over. :)
01:21:47 <cads> when you say \sum_{a in E} a^2 in tex you're not telling it to "sum the square of every element in E", you're telling it to gorgeous-print the summation symbol
01:21:55 <MyCatVerbs> QtPlaty[HireMe]: IIRC, at least two different phases of TeX are both Turing complete, and it's deliberate too.
01:22:45 <cads> MyCatVerbs: really? where could I read about this?
01:23:24 <cads> does tex have the stuff it would take to emit executable code in another language as a side effect of printing its symbols?
01:23:55 <cads> heh, would we want to code that system in tex, in other words
01:24:03 <ray> ouch
01:24:16 <dmwit> cads: Oh, that's easy, the answer to that one is no.
01:24:41 <ray> tex has what it takes to emit tex, i think
01:25:25 <cads> that's what I thought too
01:25:47 <ray> i doubt it can really emit, say, ELF
01:25:48 * cads remembers getting lost in the directory trees of tex macros for writing papers
01:26:54 <ray> anyway, haskell source should look like the output of tex, not the (hideous) input
01:27:30 <cads> working with that kind of format is pretty hideous in itself
01:27:46 <cads> have you ever tried to seriously edit a typeset equation in mathematica?
01:28:12 <ray> i don't claim that a sufficiently smart editor exists
01:28:16 <ray> just that it's not impossible
01:28:33 <ray> maybe it's impossible with current input devices :)
01:29:49 <cads> well in mathematica you have a palette of symbols that you can click on, and once you've inserted say an integral sign, then putting your mouse directly over or beneath it highlights a box that you can click on to put in symbols on top or below the integral
01:29:57 <rick_2047> where can i have a look into the base libs of haskell??
01:30:06 <dmwit> ?where hhl
01:30:06 <lambdabot> I know nothing about hhl.
01:30:08 <ziman> rick_2047, http://www.haskell.org/ghc/docs/latest/html/libraries/
01:30:12 <dmwit> ?where hierarchical
01:30:12 <lambdabot> I know nothing about hierarchical.
01:30:15 <dmwit> damn
01:30:49 <cads> ray, that's pretty simple, but there's no way to enter code quickly that way, it's purely for final typesetting
01:31:03 <rick_2047> ziman, i meant there source
01:31:13 <rick_2047> ziman, i am presuming that they are written in haskell itself
01:31:26 <cads> well I take that back, sometimes I build up integrals and stuff using pretty equations
01:31:52 <ray> yeah, i was thinking more emacs
01:32:39 <cads> but mathematica code is written like  Integral[x^2, {x,-1,1}], and then that can both be evaluated to yield zero in this case, or a typeset integral equation
01:33:10 <ziman> rick_2047, choose a lib, click it, scroll down the page and there you'll have a "Source" link on the right, at every function
01:33:31 <rick_2047> ziman, isnt it included in /usr/lib/ghc??
01:33:44 <rick_2047> ziman, are they all executables of some type?/
01:33:46 <cads> emacs would be good as it would get you away from the temptation to make people write things using their mouse :)
01:34:20 <ziman> rick_2047, yes i've got a copy in file://localhost/usr/share/doc/ghc-6.10.1/libraries/index.html
01:35:47 <ray> pretty-entry shouldn't have to mean mouse
01:35:52 <cads> hmm, perhaps the trick is to write haskell code that emits tex as a side effect
01:36:02 <rick_2047> ziman, arent there any plain text files just of the source and some comments, dont want this web page crap
01:36:29 <cads> and then lets you edit the tex rendered equations
01:36:33 <ziman> rick_2047, i've already described how you get to the source
01:37:04 <ray> if you do some just-in-time conversion of your expressions to tex, you can render them
01:37:07 <ray> or something
01:37:07 <sjanssen> rick_2047: http://darcs.haskell.org/packages
01:37:10 <cads> wait, the haskell code wouldn't emit the tex, whatever you were using for this exercise would do it
01:37:12 <Athas> How do I force the complete evaluation of a term?
01:37:27 <cads> ray, yeah
01:38:01 <cads> and I think we could bind positions in the rendered tex to positions in the code, and allow bidirectional editing
01:38:09 <sjanssen> Athas: evaluation to WHNF is via seq, NF can be achieved with Control.Parallel.Strategies.rnf
01:38:21 <ray> if your computer is fast enough, and people tend to lug around these multi-core gigglehertz behemoths these days, you can basically type in rendered tex
01:38:38 <Athas> sjanssen: thanks.
01:39:20 <cads> god what I would give for read access to the mathematica code tree
01:39:56 <ray> tell wolfram you'll give him some fancy cellular automata in exchange
01:40:10 <cads> would that be wolfram speak for a blowjob?
01:40:22 <cads> because I don't think I want the code that much
01:40:59 <cads> wolfram is nuts :)
01:41:32 <cads> thinks the universe is cellular automata and stuff
01:41:56 <ray> i have his doorstopper
01:42:02 <ray> and by doorstopper, i mean garage door stopper
01:42:07 <rick_2047> cads, well even though he is selfrighteous and cocky but he knows how to do things
01:42:25 <cads> oh I got some respect
01:42:49 <rick_2047> cads, u should me too not a big fan but the things he makes force me to respect him
01:43:03 <cads> gonna start a company with my last name and all that some day
01:43:30 <rick_2047> whats ur age??
01:43:50 <cads> well, I mean, he was a professor, starting a company, used code his students wrote with him
01:44:06 <cads> academia type, politically savvy
01:44:21 <rick_2047> i sometimes like the path he took
01:44:23 <cads> just something I don't like about those kinds of people
01:44:35 <cads> the path of industry you mean?
01:44:40 <mgsloan> I agree, I have utmost respect for his products, but the man is a douche
01:45:03 <rick_2047> cads, the path of industry through academia
01:45:07 <mgsloan> reading a good portion of NKS convinced me of that
01:45:15 <rick_2047> it shows people the value of academia
01:45:18 <cads> and they're not even _his_ products, they're the work of countless developers most likely, and they just bear his name
01:45:40 <rick_2047> cads, he has done his work in the field
01:45:49 <cads> sure
01:46:19 <cads> there were others too, and I don't know their name or their work
01:46:33 <cads> I don't know him because of his work, but from his company
01:46:45 <rick_2047> cads, that also sticks in my craw
01:46:57 <rick_2047> he never gives creadit u know
01:47:25 <cads> why should he, he's wolfram
01:48:16 <cads> as far as i'm concerned computer algebra systems should be farther along than they are now
01:48:25 <sohum> is there a screenplay for a thriller where the climax happens when a frantic haskell programmer is asked by his tormentor to calculate the fibonacci sequence and ends up launching nuclear missiles?
01:48:29 <sohum> "Damn yoooooooou, unsafePerformIO! I thought this code was puuuuuuuure!"
01:48:30 <rick_2047> u know if u google a quote (i dont remember exactly) but it invovles "wolfram created mathematica" google will correct u " did u mean wolfram created mathematics?"
01:49:23 <mgsloan> I think mathematics should follow some functional stuff, and use more things like streams
01:49:35 <mgsloan> indices as used in summation etc, are soo ugly
01:50:36 <Berengal> mgsloan: Wouldn't that mean we need to teach high-schoolers induction?
01:50:52 * quicksilver learnt induction at high school.
01:51:03 <rick_2047> Berengal, we are taught basic theory of induction in high school
01:51:05 <cads> rick_2047: rofl
01:51:06 <ski> indices is just another notation for function arguments
01:51:09 <mgsloan> so did I :) but yes, it would be good
01:51:14 <cads> @wolfram joke
01:51:14 <rick_2047> Berengal, very basic though
01:51:15 <lambdabot> Unknown command, try @list
01:51:28 <rick_2047> cads, its true
01:51:35 <rick_2047> cads, wait i find out the quote
01:51:56 <Berengal> rick_2047: Well, I did too, in its basic form, but I was doing indexing long before that
01:52:22 <ray> @quote wolfram
01:52:22 <lambdabot> No quotes match. :(
01:52:26 <ray> :(
01:52:47 <rick_2047> now now people dont convert this into wolfram bashing day
01:52:49 <cads> have you caught any of the hype on wolfram alpha?
01:52:52 <rick_2047> or is it always like this
01:53:06 <rick_2047> cads, i like its easter eggs
01:53:09 <cads> whenever people mention wolfram the love is released
01:53:16 <cads> I haven't used it yet
01:53:18 <quicksilver> Ok, well wolfram-bashing is certainly off-topic.
01:53:26 <rick_2047> cads, but mostly mathematica online
01:53:38 <rick_2047> net split run run
01:53:38 <quicksilver> Can't we bash somethign on-topic like implicit args, or qualified imports?
01:53:45 <cads> can it do PDEs?
01:53:49 <rick_2047> quicksilver, no no
01:53:57 <rick_2047> quicksilver, i need to study more to understand
01:54:15 <cads> I should know better...
01:54:23 <cads> what's the haskell off topic chan
01:54:27 <rick_2047> and they are back
01:54:30 <ray> -blah
01:54:34 <cads> h-chan if you will
01:54:37 <rick_2047> ray, nice name
01:54:41 <ejt> qualified bashing: I wish the 'qualified' keyword came after the module name, so I could sort my lines
01:55:01 <juhp> hmm pandoc s5 doesn't seem to display well in chromium
01:55:11 <Berengal> I want two types of export lists for modules: One that gets imported when no import list is given, and one of functions that can only be imported when explicitly told to
01:56:26 <dibblego> cads, #haskell-blah
01:56:29 <quicksilver> Berengal: the supported way to do that is do make another dummy module
01:56:37 <quicksilver> Berengal: for the 'default' set.
01:56:42 <quicksilver> which just imports + re-exports.
01:56:58 <quicksilver> However there are some ways in which re-exporting is not very satisfactory.
01:56:58 <Berengal> quicksilver: But that's ugly, no?
01:57:59 <Berengal> Hmmm, "module Foo (foo, bar, baz) hiding (quux, fuxsputzle) where"
01:58:46 <ray> not exactly pretty
01:58:52 <ray> better
02:01:02 <quicksilver> Berengal: I don't think it's particularly ugly.
02:01:12 <quicksilver> Berengal: it's a broadly similar amount of typing.
02:01:14 <Berengal> It'd also be nice to be able to enter a package in ghci, analogous to entering a module
02:01:39 <quicksilver> it's mildly annoying to have a separate file but that's all
02:01:46 <quicksilver> Berengal: packages don't have source
02:01:54 <walter_> I am trying HStringTemplate code from http://blog.uncommons.org/2008/12/03/generating-html-with-haskell/, but I got a parse error.  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5492#a5492
02:02:05 <Berengal> quicksilver: No, but they have modules, which can be hidden
02:03:14 <doserj> walter_: let template = ... instead of template = ...
02:03:41 <quicksilver> Berengal: oh, I see what you mean. Yes.
02:04:00 <dibblego> how would you pronounce (***) :: (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c') ?
02:04:54 <Berengal> dibblego: "foo, of type, a is an arrow in a b c gives a b c gives a b b c c"
02:05:02 <codolio> (***) is the action of the product bifunctor on morphisms.
02:05:03 <dibblego> I mean the function name
02:05:16 <Berengal> foo
02:05:20 <dibblego> heh
02:06:03 <walter_> doserj, after add let , got another error : test.hs:6:62: Not in scope: `template'  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5492#a5493
02:07:50 <doserj> walter_: yes. template is not in scope in the 'where'. try making that a let to
02:08:07 <quicksilver> I pronounce it star-star-star
02:08:16 <quicksilver> I'm not sure if there should be a cleverer way.
02:08:25 <dibblego> ok cheers
02:08:26 <ski> star-thrice
02:08:51 <walter_> doserj, thanks
02:10:23 <Peaker> quicksilver: vertical arrow composition?
02:11:37 <ray> i convert punctuation operators like that to grunts in my internal vocalizer
02:11:44 <ray> they're all the same grunt because i guess it only does lexing
02:12:00 <quicksilver> not unreasonable but I'd have to spend a few seconds each time remembering which way vertical was ;)
02:12:00 <ray> so, it's pronounced *grunt*
02:12:55 <Peaker> quicksilver: the arrows are always drawn horizontal :)
02:22:45 <walter_> help please! Ambiguous type variable error:  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5492#a5494
02:23:59 <walter_> how to fix it by add type signature
02:24:31 <doserj> walter_: let template = (newSTMP templateText :: whatever_your_type)
02:24:55 <ski> or
02:24:57 <ski>   let template :: Stringable a => StringTemplate a; template = newSTMP templateText
02:25:27 <walter_> got, thank you both.
02:29:19 <poucet> Am I the only one that finds it appalling that jonharrop owns "haskell-news.blogspot.com" where he mostly reports on negative things and then has a bunch of links to f# and ocaml books of his?
02:30:04 <quicksilver> there are many things about jdh which sometimes appal
02:30:17 <poucet> Disgusting
02:34:48 <walter_> doserj, ski, still doesnt work.    http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5492#a5496
02:35:44 <doserj> let template = (newSTMP templateText::Stringable a) doesn't work because it simply doesn't have this type.
02:36:14 <doserj> try let template = (newSTMP templateText::StringTemplate String) or sth similar.
02:36:31 <ski> `Stringable a' isn't a type
02:36:43 <walter_> I see
02:36:49 <doserj> let template :: Stringable a => StringTemplate a doesn't work, because you also need to give a definition for template.
02:36:59 <doserj> try let template :: Stringable a => StringTemplate a; template = ...
02:37:08 <walter_> This work:  let template = (newSTMP templateText::StringTemplate String)
02:37:21 <walter_> thanks, doserj
02:37:24 <ski> (doserj : which was what i suggested above :)
02:37:58 <doserj> (ski: I know :)
02:38:25 <ski> walter_ : btw, why are you entering this into GHCi, instead of into a file, as you seemed to try before ?
02:39:16 <walter_> ski, because I the demo code  doesn't work, and I want to find why.
02:39:50 <walter_> this is the demo code from http://blog.uncommons.org/2008/12/03/generating-html-with-haskell/,
02:40:42 <walter_>  let template :: StringTemplate String
02:41:21 <ski> (walter_ : i would try binary search, instead of trying to enter the code in GHCi)
02:42:16 <walter_> Infact, I am very green on Haskell. Just want do that step by step to understand. :) thank you.
02:42:50 <ski> (i.e. binary search debugging)
02:43:45 <walter_> ski, I still have no idea on debugging, btw how to do binary search
02:45:33 <ski> comment out about half the code (making sure not to comment out code which the non-commented-out code depends on, optionally instead making stubs); if still error, repeat on non-commented-out code; otherwise; flip what is commented-out and repeat
02:46:55 <ski> (btw, generally, if you get actual static error messages, that provides you with hopefully-not-too-far-off file positions from which to look for an error)
02:50:05 <walter_> ski, thank you very much.
02:50:50 <cads> hey, ski, I always wonder, what's the ski combinator do?
02:51:17 <cads> i've looked it up multiple times I'm sure, but either couldn't get it or it was so basic I subsequently forgot it
02:51:39 <dolio> @type ap const id
02:51:45 <lambdabot> forall b. b -> b
02:51:57 <hackagebot> explicit-sharing 0.5.0
02:52:00 <cads> oh it's the whole combinator calculus
02:52:47 <dolio> s and k are all you need, technically. You can define i in terms of them.
02:53:08 <cads> aaaah skiskiskiski
02:53:18 <cads> wonder what I just programmed
02:53:37 <dolio> skxy = ky(xy) = y, so skx = i for all x.
02:53:46 <ski> i
02:54:16 <dolio> Provided the types work out, if you worry about that.
02:55:16 <ski> @type let s = ap; k = return; i = id in s k i s k i s k i s k i
02:55:23 <lambdabot> forall a. a -> a
03:13:43 <Tarrant> So I'm loving this lazy thing. It is kinda freaking me out. So: take 10 (reverse [1..100]) really only generates 100-91?
03:13:59 <ejt> nope
03:14:30 <Berengal> It generates [1..100] and [100..91]
03:15:12 <BONUS> the thing about reverse is that it needs all the elements
03:15:33 <Tarrant> That makes sense
03:15:40 <idnar> BONUS: surely reverse only forces the spine?
03:15:44 <BONUS> haskell is smart but not smart enough to figure out that it could only use 100..91
03:16:07 <Tarrant> If you have a pre-generated list can it take the shortcut?
03:16:15 <idnar> hmm
03:16:24 <idnar> > take 10 (reverse [1..100000])
03:16:30 <lambdabot>   mueval-core: Prelude.read: no parse
03:16:30 <lambdabot>  mueval: ExitFailure 1
03:16:44 <BONUS> for instance, suppose you have a list iterate (*2) 1
03:17:03 <hackagebot> minesweeper 0.4.1
03:17:26 <Berengal> > iterate (*2) 1
03:17:32 <lambdabot>   mueval-core: Prelude.read: no parse
03:17:32 <lambdabot>  mueval: ExitFailure 1
03:17:39 <Berengal> > 2 + 2
03:17:46 <lambdabot>   mueval-core: Prelude.read: no parse
03:17:46 <lambdabot>  mueval: ExitFailure 1
03:18:00 <Berengal> Lambdabot's in a funk :/
03:18:02 <BONUS> > take 3 . reverse . take 10 $ iterate (*2) 1
03:18:06 <idnar> @src reverse
03:18:07 <lambdabot> reverse = foldl (flip (:)) []
03:18:07 <lambdabot>   [512,256,128]
03:18:35 <BONUS> haskell has to calculate all the elements up to the tenth one
03:19:12 <BONUS> it can't figure out that it could just do [2^9, 2^8, 2^7] on its own
03:19:19 <Tarrant> Makes sense.
03:19:20 <idnar> > take 3 . reverse . take 1000000 $ iterate (*1) 1
03:19:26 <lambdabot>   mueval-core: Prelude.read: no parse
03:19:26 <lambdabot>  mueval: ExitFailure 1
03:19:35 <idnar> bleh, it takes too long, but I think that should stack overflow
03:19:38 <BONUS> this is much like take 10 ( reverse [1..100]), only a bit more obvious
03:19:50 <mgsloan> wouldn't it not actually perform the calculations, and thunk them all?
03:20:48 <BONUS> fing is, with iterate (*2) 1, to get the nth element, it has to know the n-1th element
03:21:08 <BONUS> so they will all have to be evaluated eventually, but most of them will be dropped
03:21:44 <opqdonut> yeah, instead of keeping the list in memory, that keeps the huge 2*2*2*2*2*2*...1 thunk in memory
03:24:24 <Tarrant> So lets say I have: xs = [1..100]. Using the function: "take 10 (reverse xs)" It reverses 100-91 before realizing that it has the 10 it needs and stops reversing the list, correct?
03:24:48 <opqdonut> it has to iterate to the end of the list first
03:24:57 <opqdonut> and build the reversed list at the same time
03:24:57 <opqdonut> so no
03:25:09 <Tarrant> Yes, sorry I'm using [1..100] as shorthand instead of writing [1,2...
03:25:15 <opqdonut> but "take 10 [1..1000000]" will only generate ten numbers
03:25:48 <opqdonut> Tarrant: getting to the end of a haskell list is O(n)
03:25:55 <opqdonut> so no magical help here
03:26:11 <Tarrant> opqdonut: Ok I think I have it now.
03:26:16 <Beelsebob1> I think the key phraze here is that reverse is strict in the spine of the list
03:26:26 <Beelsebob1> so the whole list spine will get evaluated
03:26:31 <opqdonut> yeah
03:26:31 <Beelsebob1> but not all the numbers will
03:26:35 <BONUS> yeah
03:26:40 <BONUS> the : : : : [] things
03:26:54 <ejt> It's more obvious if you put an expensive comuptation in the list
03:26:56 <ejt>  take 10 . reverse . map fib $ [1000,999..1]
03:27:05 <opqdonut> good point
03:27:08 <Beelsebob1> yep
03:27:15 <Beelsebob1> so that will only do 10 expensive computations
03:27:38 <Beelsebob1> but will still create a 1000 element list of thunks
03:29:45 <Tarrant> Thanks. That's really awesome.
03:31:30 <BONUS> this is a pretty good read if you want to understand laziness in depth http://en.wikibooks.org/wiki/Haskell/Laziness
03:35:08 <koala_man> where does the word "thunk" come from?
03:35:56 <quicksilver> old english future tense of 'think'
03:36:06 <quicksilver> it means 'something which I may or may not think in the future'
03:37:52 <dibblego> @check \a b -> a + b == b + a
03:37:56 <lambdabot>   mueval-core: Time limit exceeded
03:38:08 <ejt> koala_man: http://www.ccil.org/jargon/jargon_35.html
03:38:45 <ejt> 'the sound made by data hitting the stack' lol
03:41:52 <mornfall> Hackage does not love me? : - ( ERROR: dist/hashed-storage-0.3.1.tar.gz: 400 Error in upload
03:51:30 <TThijs> can somebody tell me what the $ does in a haskell functions
03:51:55 <wjt> TThijs: f <$> x = f x
03:52:01 <wjt> erm. f $ x = f x
03:52:32 <ejt> TThijs: it applies a function to an argument
03:52:34 <wjt> it's used to let you omit parentheses around the argument when they would otherwise be necessary
03:52:38 <wjt> > show (5 + 3)
03:52:45 <lambdabot>   mueval-core: Prelude.read: no parse
03:52:45 <lambdabot>  mueval: ExitFailure 1
03:52:50 <wjt> lambdabot: uh...
03:52:54 <wjt> > show (5 + 3 :: Int)
03:52:55 <BONUS> f $ x is just f x, thing is it has rly low precedence
03:52:55 <lambdabot>   "8"
03:53:01 <wjt> > show $ 5 + 3
03:53:02 <lambdabot>   "8"
03:53:07 <wjt> > show 5 + 3
03:53:08 <lambdabot>   No instance for (GHC.Num.Num GHC.Base.String)
03:53:08 <lambdabot>    arising from the literal `...
03:53:26 <BONUS> so instead of writing reverse (take 10 [1..]), you can write reverse $ take 10 [1..]
03:54:00 <mgsloan> and usage of $ leads to a very direct path to compositional style
03:54:52 <Gracenotes> anything has lower precedence than function application
03:55:29 <TThijs> thanks wjt
03:55:42 <ejt> try not to chain more than one $ together, use (.) instead.  eg, "take 10 $ map fib $ [1..]"  is better written "take 10 . map fib $ [1..]"
03:56:50 <koala_man> why is it better written like that?
03:57:34 <ejt> because it's getting you thinking in a more compositional (point free) way
03:58:22 <BONUS> take 10 . reverse . tail $ xs is cool because you can do z = take 10 . reverse and then say z . tail $ xs
03:58:33 <BONUS> but you can't say z = take 10 $ reverse
03:58:41 <BONUS> cause that tried to apply take 10 to reverse
03:58:42 <Gracenotes> not to mention, "a $ b $ c" relies on the infixity of ($) being right.
03:59:04 <Gracenotes> so a $ b $ c $ d means (a $ (b $ (c $ d)))
03:59:46 <Gracenotes> if the infixity is left -- not a terribly mind-boggling change to make -- then a $ b $ c $ d's won't be valid a . b . c $ d will be, though
04:00:22 <Gracenotes> just a note. Since I have heard arguments for changing the infixity before
04:00:47 <canvon> so the underlying difference is that (.) is associative, ($) isn't? interesting...
04:00:48 <ejt> Gracenotes: wow, that would break _so_ much
04:01:01 <ski> Gracenotes : .. except `@',`~',`!',record construction/update)
04:01:41 <Gracenotes> then "a $ b $ c $ d" will be equivalent to "a b c d", not "a (b (c d))". It would break a lot, but not if (.) is used where appropriate :)
04:01:50 <ski> > (:[]) Node {rootLabel = 1,subForest = []} {rootLabel = 42}
04:01:53 <lambdabot>   [Node {rootLabel = 42, subForest = []}]
04:02:08 <canvon> (okay, ($) can't be associative, as the type signature tells ($) uses two arguments that /have/ to be of different type...)
04:02:36 <canvon> Gracenotes: what's the point of using $, then? :)
04:02:54 <ski> Gracenotes : additionally, it seems more useful for `$!' to be `infixl' (or renamed)
04:03:07 <Gracenotes> canvon: The main difference is how they're used in practice to eliminate parens :)
04:03:27 <ejt> canvon: just read some haskell code, it's used a lot
04:03:30 <Gracenotes> (.) composes functions. ($) applies functions
04:03:35 <canvon> Gracenotes: no, I meant: when it would be changed to being left associative
04:03:38 <ejt> plus people pass it around too as ($)
04:03:53 <canvon> Gracenotes: in response to what you said
04:03:55 <BONUS> it's cool to write stuff like
04:04:18 <BONUS> filter (>3) $ take 10 xs
04:04:23 <BONUS> you could write that as
04:04:28 <BONUS> filter (>3) . take 10 $ xs
04:04:40 <BONUS> but i think the first option is better
04:04:58 <Gracenotes> canvon: for function application. "map show . filter even $ [1..10]" could still be used. The function is "map show . filter even", and the value is "[1..10]". However, you couldn't chain function application, merely apply more arguments
04:05:40 <Gracenotes> so if it was left-associative, you could write "filter $ const True $ [1..10]", although I'm not sure how useful this would be :)
04:06:53 <ski> (BONUS : the first option work work with left-associative `$' as well ..)
04:07:05 <BONUS> yeah
04:07:08 <ski> consider
04:07:10 <Gracenotes> plus, ($) and (.) are frequently used together, and mixing left-associative operators and right-associative operators tends to be a nightmare if not done carefully. in languages like C/C++/Java, too
04:07:13 <ski>   foldl' f z [    ] = z
04:07:14 <ski>   foldl' f z (a:as) = (foldl' f $! f z a) as
04:07:41 <ski> if `$' (and `$!') were left-associative, we could write the last equation as
04:07:48 <ski>   foldl' f z (a:as) = foldl' f $! f z a $ as
04:08:05 <BONUS> yeah, $ should have been made left associative
04:08:24 <PeakerWork> ski: that's one big empty list!
04:08:42 <quicksilver> there is an argument not to make it associative
04:08:48 * ski likes the empty lists lining up with the cons pattern :)
04:09:00 <quicksilver> withWidgets $ withFudgets $ do .....
04:09:00 <BONUS> i never thought of matching up the [ and ] and the cons pattern
04:09:04 <BONUS> it actually looks really nice
04:09:24 <quicksilver> sorry "not to make it associate to the left", I mean
04:09:58 <ski> you could use `.' there .. but one might consider that unnatural, i suppose
04:10:01 <Gracenotes> BONUS: hm. I like the idea of matching "(x:xs)" with "[]   " (with spaces), mahself
04:10:22 <ski> (i don't recall which i've used)
04:10:41 <quicksilver> ski: that's not quite the point
04:10:51 <quicksilver> ski: it was a warmup
04:10:54 <quicksilver> ski: now suppose you have
04:11:14 <quicksilver> withThisWidget $ \widg -> withThisFudget $ \fudg -> do ....
04:11:22 <quicksilver> ski: now you *really* have to use $.
04:11:49 <quicksilver> ski: so the full argument is - it would be annoying swapping between $ and . based on whether the with construct has a binding or not
04:12:11 <Saizan> nah, you simply rewrite that in the ContT monad ;)
04:12:11 <ski> Gracenotes : how about lining up ` Nothing  ' with `(Just foo)' ? :)
04:12:31 <ski> (Gracenotes : or `(Left  e)' with `(Right a)' ?)
04:12:58 <Gracenotes> I'd probably go with "(Left e) " and "(Right a)" :) But it depends
04:12:58 <ski> quicksilver : i see your point
04:13:10 <quicksilver> I line up the = signs in defintions. I don't bother to line up the () in the constructors.
04:13:22 <quicksilver> if there are multi-arg constructors I line the args up though
04:13:34 <quicksilver> (or multiple args to the function)
04:13:52 <Gracenotes> it depends..
04:13:52 <quicksilver> ski: it was someone else's point, I dont' remember whose, but it struck me as a good one :)
04:13:56 <Gracenotes> hm
04:15:17 <Gracenotes> on the other hand, changing the infixity of (.) from right wouldn't exactly break anything
04:15:46 <Gracenotes> but.. given the way we think of composition.. possibly not bright
04:15:54 <ski> it might be nice if editing modes lined up things like the `='/`->' (& `|') ..
04:16:19 <Twey> ski: I always line up my arguments
04:16:32 <philipp_> i've got a function with a memory leak because of lazyness, printing the variable seems to fix this but how can i get the same effect without printing? already tried several possibilities with `seq` but it seems that i need hnf data, here's the function: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5497#a5497 where "  lift $ print (f2i 0)
04:16:38 <philipp_> is the fix
04:16:50 <Twey> You end up with a sort of ‘table’ of functions, instead of a bunch of discordant lines
04:16:56 <ski> Twey : maybe you should create a poll for this ? :)
04:17:08 <ski> s/you/we/
04:17:19 <Twey> It's possibly the only good thing about different patterns require the same number of arguments :-P
04:17:23 <Twey> A poll?  What sort of a poll?
04:17:29 <ski> @list poll
04:17:30 <lambdabot> poll provides: poll-list poll-show poll-add choice-add vote poll-result poll-close poll-remove
04:17:35 <Twey> Oho
04:17:36 <Twey> Good idea
04:17:42 <Twey> How does this work?
04:17:53 <ski> @help poll-add
04:17:54 <lambdabot> poll-add <name>             Adds a new poll, with no candidates
04:18:02 <ski> @help choice-add
04:18:03 <lambdabot> choice-add <poll> <choice>  Adds a new choice to the given poll
04:18:03 <Twey> @help choice-add
04:18:04 <lambdabot> choice-add <poll> <choice>  Adds a new choice to the given poll
04:18:05 <Twey> Heh
04:18:11 <Twey> Noted
04:18:28 <quicksilver> ski: I make frequent use of M-x align-regexp
04:18:31 <Twey> @poll-list
04:18:32 <lambdabot> ["logoVotingMethod"]
04:18:41 <Twey> @poll-show logoVotingMethod
04:18:41 <lambdabot> ["Schulze"]
04:18:46 <Twey> o.@
04:19:20 <Saizan> philipp_: can you paste the definition of Model too?
04:19:21 <Twey> @poll-add functionFormatting
04:19:22 <lambdabot> Added new poll: "functionFormatting"
04:19:31 * ski hasn't seen that emacs command before ..
04:19:40 <philipp_> Saizan: sure, one second
04:19:54 <Twey> @choice-add functionFormatting Line up = and all arguments
04:19:54 <lambdabot> usage: @choice-add <poll> <choice>
04:20:09 * Twey scratches his head.
04:20:33 <philipp_> Saizan: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5499#a5499
04:22:05 <quicksilver> ski: it's great for not just making code pretty. It also lets you line up text data into columns, so you can edit them with rectangle mode
04:22:08 <Saizan> philipp_: i'd probably make all the fields strict
04:22:19 <Twey> quicksilver: Cool
04:22:38 <Saizan> philipp_: also, i don't see where the getF2I field is populated
04:22:46 <philipp_> Saizan: how? bang patterns?
04:23:16 <Saizan> philipp_: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5499#a5500
04:23:24 <mornfall> Oh.
04:23:29 <ski> (quicksilver : ty)
04:23:36 <mornfall> Btw, what's the cabal version that comes with ghc 6.8?
04:23:41 <philipp_> Saizan: thanks, I'll try that
04:23:49 <dcoutts> mornfall: 1.2.x
04:25:19 <hackagebot> hashed-storage 0.3.1
04:25:21 <mornfall> Hm, "cabal upload" should probably give full error text from hackage, not just "ERROR". :)
04:25:26 <philipp_> Saizan: now i get a strange error while running the binary
04:25:33 <ski> philipp_ : style comment : i'd define  arnold'  in a `let' in the `do'-block, to avoid passing in `fina',`finb',`f2i' .. or even use `flip parMapM [(a,b) | ...] $ \(a,b) -> do ...'
04:25:55 <Saizan> philipp_: which error?
04:26:05 <philipp_> Saizan: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5499#a5501
04:26:10 <philipp_> ski: thanks
04:27:09 <dcoutts> mornfall: http://hackage.haskell.org/trac/hackage/ticket/549
04:27:13 <Saizan> philipp_: uhm, that's weird, try with -fforce-recomp
04:27:29 <ski> i.e.
04:27:33 <ski>   flip parMapM (liftM2 (,) omegaA omegaB) $ \(a,b) -> do
04:27:36 <ski>     ...
04:27:37 <mornfall> dcoutts: : - )
04:27:58 <dcoutts> mornfall: patches gratefully accepted :-)
04:28:01 <philipp_> Saizan: didn't work
04:28:05 <mornfall> I imagine. :)
04:28:24 <mornfall> But if I get cabal hacking time, I'll first and foremost fix the double compile that darcs suffers.
04:28:28 <Saizan> philipp_: i meant recompiling with that flag
04:28:42 <Saizan> philipp_: if it still doesn't work it looks like a ghc bug
04:28:48 <philipp_> I did
04:28:53 <dcoutts> mornfall: great then you can work on this ticket, because the double compile is fixed :-)
04:28:55 <mornfall> Which ought to have happened long time ago, but I somehow managed to not have that time.
04:29:04 <mornfall> dcoutts: \o/
04:29:05 <mornfall> : - )
04:29:20 <mornfall> Maybe I should upgrade my cabal, then. :)
04:29:41 <dcoutts> mornfall: it's not released yet, it went in the day before yesterday
04:29:57 <mornfall> Well, I can sustain some breakage from unreleased cabal versions.
04:29:59 <philipp_> Saizan: it's probably also not a good idea to use bang patters since constructing the Model takes a lot of time and the program should only construct those Models which are actually used in a function
04:30:01 <mornfall> I guess.
04:30:10 <mornfall> : - )
04:30:20 <dcoutts> mornfall: then you need Cabal head and cabal-install head
04:30:30 <mornfall> Aye, working on it. Let's see.
04:30:54 <Saizan> philipp_: the strict fields will only ensure that if you use a Model it won't hide unevaluated thunks in it
04:31:06 <Saizan> philipp_: they won't force the creation of the whole model by themselves
04:31:26 <philipp_> Saizan: ah ok
04:31:32 <philipp_> that should be fine
04:31:50 <Saizan> philipp_: however since most fields are functions they can "hide" unevaluated thunks inside them, depending on how they are constructed
04:33:36 <Saizan> or keep something alive that should be GC'ed
04:33:55 <Saizan> you could use heap profiling to get a better idea of what's going on
04:34:03 <Saizan> ?google ghc heap profiling
04:34:04 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/prof-heap.html
04:34:04 <lambdabot> Title: 5.4.�Profiling memory usage
04:34:18 <philipp_> Saizan: thanks!
04:35:34 <philipp_> Saizan: now it works, but it doesn't have the same effect as printing
04:37:02 <Saizan> philipp_: you mean it uses less memory but not so much less?
04:37:28 <Saizan> maybe with "!f2i <- gets .."
04:37:53 <Saizan> the code is a bit dense and partial so i'm kind of shooting in the dark :)
04:38:24 <philipp_> also doesn't work, memory goes up all the time
04:39:42 <philipp_> Saizan: added some revisions
04:39:54 <Saizan> a bruteforce option is to write !() <- rnf (f2i 0) `seq` return ()
04:40:10 <Saizan> instead of the lift (print (f2i 0))
04:41:40 <philipp_> yes, that works
04:41:56 <LeCamarade> @tell conal Well, it was only tangentially about threads. I had asked about what prompted different behaviour between native and runhaskell, and you asked if my program was threaded.
04:41:57 <lambdabot> Consider it noted.
04:43:00 <LeCamarade> @tell conal Well, it is threaded, and learning the vagaries of threads under both native and runhaskell GHC programs (from you, I hoped) would likely be helpful.
04:43:00 <lambdabot> Consider it noted.
04:44:35 <philipp_> (f2i 0) `seq` parMapM ... also seems to work
04:44:59 <Saizan> LeCamarade: native without -threaded doesn't use the threaded runtime which is instead used by ghci and runghc
04:45:08 <MarcWeber> Any chance implementing something like SQLAlchemy (python lib) in haskell ?
04:45:29 <Saizan> LeCamarade: the threaded runtime can run haskell threads in multiple OS threads
04:45:31 <Baughn> MarcWeber: What's it do?
04:46:03 <Baughn> LeCamarade: The threaded runtime can also spawn OS threads to handle blocking system/library calls, which may otherwise block a program with multiple haskell threads
04:46:12 <LeCamarade> Ha!
04:46:18 <MarcWeber> Baughn I'ts a SQL framework for python including an ORM (object relational mapper). So you can get "users" and lazy load associated adresses.
04:46:32 <quicksilver> I started to explain this to LeCamarade yesterday
04:46:37 <LeCamarade> So ... I'm probably being bitten by that.
04:46:40 <quicksilver> evidently my explanation didn't entirely satisfy :)
04:46:40 <Baughn> MarcWeber: Well, an object-relational mapper doesn't really make sense in haskell?
04:46:53 <LeCamarade> quicksilver, You were much help, but I want a PhD in Haskell threads, it seems. :o)
04:47:02 <Baughn> MarcWeber: Lazily reading results, of course, is easy.
04:47:04 <quicksilver> MarcWeber: lazy loading of columns is the biggest make an ORM ever made :)
04:47:06 <MarcWeber> Baughn It depends on how you do define "object" if you consider AGDTs beeing objects (estimatino) then yes!
04:47:07 <LeCamarade> GHC threads, to be precise.
04:47:24 <quicksilver> LeCamarade: did you try compiling with -threaded?
04:47:43 <MarcWeber> quicksilver The point is : It's short to write. I don't even know if you can get such a nice syntax in haskell.
04:48:10 <LeCamarade> quicksilver, Yes, and I'm closer to a solution because of that.
04:48:11 <quicksilver> I was making a specific point about lazy column loading.
04:48:16 <LeCamarade> Now, it blocks immediately.
04:48:19 <quicksilver> not a general point about conveneitn database mappers.
04:48:28 <MarcWeber> And if it works (I haven't tried) its really nice to use. While writing you applications you don't want to bother with IO, you don't want to think about monads, you don't want to think about relations. This lib seems ome close to this.
04:48:28 <LeCamarade> It deadlocks immediately, rather.
04:49:01 <Baughn> MarcWeber: You can do quite interesting things with SYB/TH and relatives
04:49:02 <quicksilver> I think some of the haskell database libraries try to be convenient in this way
04:49:08 <quicksilver> I haven't used any opf them.
04:49:25 <MarcWeber> Baughn You can't do users[0].adresses[0].user.name
04:49:30 <Baughn> MarcWeber: Also, in my experience, you /do/ want to think about monads. They help a lot, when appliable.
04:49:47 <Baughn> MarcWeber: Sure you can. You might have to write the code first, but you can do that.
04:50:24 <MarcWeber> Baughn How does it look then?
04:50:35 <p_l> MarcWeber: I think I had seen it work quite nicely, easily, in something that might be quite nicely modified into functional world...
04:50:52 <quicksilver> users ! 0 # Address ! 0 # User # Name
04:51:02 <quicksilver> assuming appropriate definitions (and fixities!) for ! and #
04:51:17 <MarcWeber> users >>= \l -> l!!0 >>= adresses >>= x \-> x!!1 >>= user ? @ Baughn
04:51:28 <Baughn> MarcWeber: Ugh. That's awful.
04:51:35 <quicksilver> where Address, User, Name would be constructors from appropriate field datatypes.
04:52:42 <MarcWeber> Baughn By the way my example showed how back references can be used.
04:53:11 <Baughn> MarcWeber: Unfortunately it was also unreadable. I prefer mercury's version.
04:53:20 <MarcWeber> users[0].adresses[0].user.name thus the user at the end is the same object as users[0]. Of course you can start messing around with fix types and such.. but you don't want to.
04:54:01 <MarcWeber> So how I can I represent this 1 user has many addresses relation easily? Using data User = User [Adress] ?
04:54:20 <Baughn> That's one way
04:54:36 <Baughn> Of course, instead of Address being the literal address value, it'd probably be some kind of reference to SQL-reading code
04:54:39 <MarcWeber> Then when passing an address I don't have a reference to users. (I know this is nice if you want to start using multithreading..)
04:55:43 <MarcWeber> Baughn: users[0].adresses[0].user.name so how many selects do you want to run here?
04:56:05 <Baughn> MarcWeber: One, of course
04:56:52 <Baughn> Though it'd be a pretty complex one, I suppose
04:57:10 <Baughn> Still. There's only one deRefSQL call in there.
04:57:31 <ketil> Is there a way to get my own URL using (Fast)CGI?
04:57:31 <lambdabot> ketil: You have 3 new messages. '/msg lambdabot @messages' to read them.
04:57:49 <MarcWeber> Baughn: The alchemy lib can do more. You can just do users[3].name="newname" and do a session.commit() afterwards. Only the "users" which have changed will be written back to the database.
04:58:14 <Baughn> MarcWeber: A simple matter of programming. What's your point?
04:58:52 <MarcWeber> Baughn That I'd like haskell to take off. But all the sql libs made me having headache for different reasons.
04:59:22 <quicksilver> well it's certainly not a limitation of haskell as a language
04:59:23 <MarcWeber> And reading that documentation made me think: Yes, that's what I want to use, no matter wether it has been written in haskell or python.
04:59:32 <quicksilver> it may be a limitation of the libraries, or their docs
05:12:42 <saynte> WTB: someone who has used the LLVM hackage-package ;)
05:13:51 <ejt> I played with LLVM last week
05:14:06 <ejt> working through Lennarts posts
05:15:25 <portartus> Hallo
05:15:57 <portartus> ihr seid doch alle schwul!
05:16:29 <portartus> hello
05:16:33 <portartus> any1 here?
05:17:35 <Beelsebob> people are here
05:17:41 <Beelsebob> but you may want to try #haskell.de
05:17:48 <ejt> he's gone
05:17:52 <MarcWeber> he's gone and he's lacking brain.
05:17:52 <Beelsebob> oh, so he has >.<
05:18:26 <MarcWeber> Beelsebob: he said "you're all gay"
05:18:42 <quicksilver> statistically it's likely that some of us are
05:18:48 <quicksilver> but overwhelmingly unlikely that we all are
05:18:58 <quicksilver> poor chap just doesn't understand demographics very well
05:19:24 <saynte> ejt: have you tried to create anything like a compiler yet?
05:19:40 <saynte> ejt: in the sense of going from AST -> bytecode using the bindings?
05:19:51 <ejt> saynte: no, I was tempted to code up the 'kaleidescope' example from the llvm docs
05:20:36 <ejt> I basically worked through Lennarts posting, then decided that I need to understand LLVM more so worked through writing assembly directly for a bit
05:21:15 <ejt> I'm looking at it to compile a little fractal rendering DSL
05:21:19 <saynte> ejt: hmm. yeah. i was curious, because it seems like the strong typing that they have used to represent functions is rather too restrictive.
05:21:39 <ejt> I had terrible trouble with the for loop construct
05:22:02 <ejt> and it's return type
05:22:17 <saynte> In their "examples" directory, or from the LLVM tutorial?
05:22:22 <tux-foo> twanvl, ping
05:22:36 <tux-foo> twanvl, tux-foo=foo-nix
05:22:41 <ejt> from Lennarts posting
05:22:43 <jacobian> yarg, for some reason my program isn't lazy enough
05:23:03 <ejt> there is an examples dir of haskell code ?
05:25:14 <saynte> yeah, in the repository/package.
05:25:20 <saynte> did you get it from cabal?
05:26:33 <ejt> y, but I just installed it
05:26:43 <ejt> ok, I should look through those
05:27:15 <ejt> I was very impressed with the code that LLVM produces
05:27:46 <saynte> yeah, it has this reputation :)
05:27:50 <ejt> very similar performance to gcc on the little examples I tried
05:28:13 <ejt> what are you using it for ?
05:28:42 <saynte> and the binding the have on hackage is pretty good i think except for this one area that I can't for the LIFE of me figure out how to write functions from an AST in it.
05:28:53 <saynte> just trying to write a small language as an experiment.
05:29:02 <saynte> so far (as you can tell) I am hung up on functions.
05:31:00 <ejt> ok, let me dig a bit ...
05:31:55 <saynte> yeah. the trick is this: it's easy to do if you write your functions in Haskell, because you'll define them like a Haskell function, and it will use it's type-class trickery to make it all ok.
05:32:30 <saynte> however, if you have a representation of a function from a file at runtime, then you're in more trouble.
05:32:39 <ejt> hmm, I don't think that's much different
05:32:43 <ejt> let me try
05:33:13 <blackh> Hi all. Is there a 'touch' function that allows you to prevent a data structure (with a finalizer attached) getting GC'ed, like touchForeignPtr but for general data structures?
05:33:34 <ejt> blackh: just hold onto a reference ?
05:33:52 <Lemmih> blackh: The short answer is no.
05:34:20 <blackh> ejt: I've pulled a Chan out of my data structure and I'm waiting on that, and I want to keep it alive until something is received... I could add the finalizer to the Chan but that doesn't solve the problem.....
05:34:36 <blackh> because Chan in turn has its own internal structure.
05:34:44 <saynte> ejt: a good example may be to try to create an "incr" function, fairly simple but should show you the problem.
05:34:48 <blackh> Lemmih: Thanks.  I'll see if I can't dream something up.
05:34:52 <ejt> saynte: y
05:35:13 <ejt> blackh: just have another thread wait on the channel ?
05:36:16 <blackh> ejt: Well, waiting on the Chan doesn't actually necessarily keep the top-level 'Chan' data structure alive.  That assumes things about how it's implemented.
05:36:32 <saynte> ejt: because it's very hard to do. so essentially go from a function data-type to an LLVM function.
05:37:25 <blackh> In case anyone's wondering what I'm trying to do, it's a client for a communications channel (socket based).  I want the socket to get cleaned up when the client is no longer used.
05:37:51 <blackh> I just want to ensure it gets kept alive for the during the 'request' function.
05:38:45 <blackh> Not very functional code. :)
05:42:26 <blackh> touch x = newIORef x >> return ()   <-- this seems to work
05:44:12 <Lemmih> blackh: That's unlikely to work with compilers such as LHC.
05:47:30 <blackh> Lemmih: Thanks. Well, either I could use something from FFI (since C must makes concrete assumptions), or I maybe I re-think the whole thing.
05:48:02 <byorgey>  /win 3
05:48:09 <byorgey> sigh
05:48:55 <Lemmih>  /fail (:
05:49:00 <ejt> saynte: have you looked at the BASIC example ?
05:49:48 <ejt> (and I see your problem :(  )
05:52:56 <saynte> ejt: just took a look, that's kinda ninja, hehe.
05:53:44 <saynte> ejt: yeah, it's sort of fundamental i think. i've considered using existential types, TH and Data.Dynamic, i don't think any of those give a solution.
05:54:55 <saynte> I think it just needs a less-typed version of the function to do it. In a compiler you're probably doing your own type-checking anyway, so I think this is ok. Although I'd be curious to see if there is a way to do it with the available bindings.
05:55:36 <ejt> augustss: ?
06:00:21 <RayNbow> Functor has fmap :: (a->b) -> f a -> f b, ContraFunctor has contramap :: (b->a) -> f a -> f b... is there a class that contains a function of type (a->b) -> (b->a) -> f a -> f b?
06:01:11 <Saizan> ExpFunctor in category-extras
06:02:43 <RayNbow> Saizan: ah nice... and there's also a link to the Comonad Reader :)
06:02:46 <RayNbow> thx :)
06:03:08 <RayNbow> (not that I'm all too familiar with CT, but I was wondering about it earlier today when I was waiting for a train to depart)
06:11:32 <RayNbow> Saizan: data Socket a = Socket (Source a) (Sink a) -- this would be a nice candidate for ExpFunctor, right? :)
06:12:35 <ejt> saynte: maybe the point is the type of your entry point should always be the same
06:12:42 <Saizan> probably, iirc the definition of Source and Sink
06:14:14 <kig> how do i make a ptr out of a bytestring? (drudging through using cairo imagesurfaces as gl textures)
06:14:48 <Saizan> look at Data.ByteString.Internal
06:15:16 <saynte> ejt: could be, but this is rather restrictive. I feel that it's just a design flaw.
06:15:35 <RayNbow> Saizan: well, I don't know whether Source/Sink already exists in some package... but they seem like a functor/contrafunctor resp. to me
06:16:35 <MyCatVerbs> blackh: er, if you want Haskell values to stay in-place and existent for specific lengths of time, use Foreign.StablePtr
06:17:07 <blackh> MyCatVerbs: Thanks - that looks promising.
06:17:38 <Saizan> RayNbow: ah, i thought you were referring to reactive
06:20:06 <kig> Saizan: thanks, let (fptr,_,_) = toForeignPtr bstr in let ptr = unsafeForeignPtrToPtr fptr seems to work
06:20:47 <kig> now to bang head against getWidth and getHeight being inside Render monad
06:21:30 <quicksilver> kig: you don't need to nest the lets like that
06:21:53 <quicksilver> let (fptr,_,_) = toForeignPtr bstr; ptr = unsafeForeignPtrToPtr fptr in ...
06:22:52 <quicksilver> and 'withForeignPtr' is the preferred way, not unsafeForeignPtrToPtr
06:23:29 <kig> oh, there's withForeignPtr. nice, thanks
06:23:40 <quicksilver> and finally...
06:23:52 <quicksilver> ignoring the two other fields of toForeignPtr is not a good idea.
06:23:57 <quicksilver> they are there for a reason :P
06:28:31 <blackh> Lemmih, ejt, MyCatVerbs: The whole finalizer thing doesn't work. GHC seems to be optimizing out the containing object. I need to abandon the idea and close it explicitly with a 'withClient' sort of function. Thanks again.
06:37:45 <quicksilver> blackh: if you need reliable finalizers, attach them to an MVar or an IORef
06:37:46 <lambdabot> quicksilver: You have 1 new message. '/msg lambdabot @messages' to read it.
06:38:02 <quicksilver> lambdabot: why tell me that now? I only said something 14 minutes ago?
06:38:05 <quicksilver> @messages
06:38:05 <lambdabot> ivanm said 3d 41m 19s ago: after playing with kuribas' indentation mode, I recall using it once and discarding it because I keep expecting tab to indent no matter where in the line I am (and
06:38:05 <lambdabot> backspace doesn't unindent the same amount as tab indents either) :s
06:38:06 <ksf> @seen conal
06:38:07 <lambdabot> I saw conal leaving #haskell and #ghc 4m 14d 8h 23m 51s ago, and .
06:38:11 <quicksilver> Oh, that's an old one.
06:38:21 <blackh> quicksilver: much appreciated
06:38:36 <ksf> someone raise lambdabot's wage, she can't even afford her meds.
06:39:16 <ejt> has conal really been missing for 4 months !
06:40:28 <Gracenotes> is there a particular reason Real requires Ord?
06:40:41 <byorgey> ejt: no =)
06:40:58 <byorgey> looks like lambdabot crashed and lost some state.
06:41:22 <Gracenotes> seen has been somewhat suspect..
06:41:27 <Gracenotes> preflex: seen conal
06:41:27 <preflex>  conal was last seen on #haskell 16 hours, 32 minutes and 34 seconds ago, saying: mempty :: Sum a
06:50:06 <quicksilver> blackh: using addMVarFinalizer, not using the standard addFinalizer
06:50:14 <quicksilver> the standard addFinalizer is soggy and hard to light.
06:53:55 <kig> if i hit a mysterious problem like image w*h*4 != dataLength, i should throw an exception, right? or wrap the retval inside Maybe ?
06:54:35 <ksf> loadFile :: Either LoadError Image
07:00:55 <mux> someone unbreak reddit please!
07:20:59 <hackagebot> bindings-common 0.1.2
07:26:01 <hackagebot> bindings-libusb 0.0.2
07:28:29 <PeakerWork> given an incoming XML on top of streaming data -- what XML library lets me read it incrementally and tell me when its done?
07:29:50 <quicksilver> none of them, probably.
07:30:35 <PeakerWork> so I have no way to read a "whole XML" from a pipe?
07:31:30 <quicksilver> dunno for sure
07:31:32 <mux> HaXml can do that with lazy parsing
07:31:33 <quicksilver> I only said 'probably'
07:31:54 <mux> it's actually the only XML library for haskell that I've used that allowed me to parse a _big_ XML file incrementally
07:31:55 <quicksilver> mux: HaXml knows when it is done and gives you back the rest of the stream then?
07:32:08 <mux> no, but the lazy parser of HaXml lets you parse only part of the document
07:32:15 <mux> you'll have to write some boilerplate code around that
07:34:02 <bd_> mux: clear your reddit cookies and you should be able to get in, apparently
07:34:27 <bd_> though commenting seems broken still
07:34:59 <mux> bd_: mmm, just tried that and I still get a "service unavailable" error
07:35:15 <quicksilver> mux: well, you can't get a stream back out of a String which has interleaved IO in it
07:35:24 <quicksilver> that's one of the many many reasons that interleaved IO is broken.
07:36:18 <mux> quicksilver: yeah, I was thinking about a usage scheme when you read incrementally, ie with hGetLine
07:37:10 <quicksilver> haxml supports that?
07:37:14 <quicksilver> you can feed it lines one by one?
07:37:36 <mux> yes
07:37:44 <mux> this is how I achieved parsing a ~50MB XML file
07:37:51 <mux> any other way would result in a space leak
07:38:13 <quicksilver> mux: Nice.
07:38:14 <quicksilver> haxml++
07:38:25 <quicksilver> PeakerWork: The correct answer is: Yes, HaXML
07:38:34 <quicksilver> although you need to development version for the incremental parsing.
07:38:37 <quicksilver> IIRC>
07:38:42 <mux> but in my case I didn't have to hGetLine stuff; I just used readFile
07:39:12 <mux> but it worked, otherwise my program would have quickly crashed after having consumed all of my RAM
07:39:51 <blackh> Hexpat does lazy parsing too
07:40:15 <mux> but it's impure :-)
07:40:27 <blackh> No it isn't - I wrote it, so I should know
07:40:50 <mux> I was assuming Hexpat would be a bidnings module to expat
07:40:59 <blackh> It is, but I did it all properly
07:41:33 <quicksilver> mux: readFile is the impure thing, if anything is impure :P
07:41:38 <mux> blackh: however you did it, it's still in IO, right?
07:41:43 <mux> quicksilver: hah. touch.
07:42:04 <blackh> mux: There's a low-level interface that's in IO and a high-level interface that's pure
07:43:09 <mux> cool
07:46:36 <mux> blackh: mmm, except that it doesn't look like hexpact can actually do incremental XML parsing (not lazy XML parsing), at least not without using the SAX interface$
07:47:12 <blackh> mux: It can definitely do lazy parsing with the tree interface.
07:47:26 <blackh> I've written a lot of code that relies on that.
07:47:42 <mux> blackh: I repeat that I'm talking about incremental parsing, not lazy parsing
07:48:04 <blackh> mux: Oh. What's incremental parsing?
07:48:10 <mux> ie, a way to explicitely parse an incomplete XML document
07:48:12 <rick_2047> can haskell have function overloading???
07:48:39 <mux> (like you get when you parse XML streams such as the Jabber protocol - it seems this was the motivating example for this technique in HaXml)
07:49:33 <blackh> mux: I use hexpat to implement communications protocols using lazy parsing.
07:49:51 <quicksilver> rick_2047: yes. That's what typeclasses are for.
07:50:12 <rick_2047> quicksilver, typeclasses ok
07:50:26 <blackh> mux: But you're right - you can't do it explicitly, i.e non-lazily, without using the lower level interface.
07:50:53 <uccus> hi guys, anyone here uses Cygwin? I am trying to build hmatrix and running into trouble, experienced help needed
07:51:11 <mux> blackh: this is way cool then; what I liked about the HaXml way was that I was __sure__ that it didn't try to read more of the file than it should :-)
07:51:34 * mux notes most reddits are back up except proggit
07:51:56 * quicksilver dislikes this use of the term "lazy"
07:52:05 <gnuvince> mux: nothing works here :(
07:52:16 <quicksilver> I think it inhibits discussion.
07:52:38 <mux> gnuvince: it's a bit weird though: I can access haskell reddit for instance, but only the main page. clicking on "new" gives me a service unavailable error
07:52:46 <borisl> > map (+1) [1..10]
07:52:50 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
07:53:34 <gnuvince> That'll teach those guys not to have XXL hoodies!
07:54:40 <blackh> mux: It could well be that it is technically incorrect to rely on Haskell being maximally lazy.  I will add incremental parsing next time I work on hexpat.
07:55:07 <mux> blackh: it's true that the "level" of laziness (cannot think of a better term) isn't guaranteed by the standard, AFAIK
07:55:14 <blackh> mux: Thanks for the assistance you inadvertently gave me.
07:55:26 <mux> blackh: I'm glad :-)
07:56:01 <blackh> mux: I've had a few people say they wanted features that I hadn't thought of, so it's great to talk to people about it.
07:57:23 <PeakerWork> ByteString.Char8 returns its own bytestring type -- how can I use existing functions that work with either Strict or Lazy bytestring with it?  e.g: Data.Binary.Get.runGet?
07:59:03 <alexsuraci> Is HaskellDB the preferred way to work with databases?
07:59:08 <quicksilver> alexsuraci: no.
07:59:21 <alexsuraci> It hasn't been updated in a while and the documentation on it seems pretty sparse
07:59:27 <quicksilver> alexsuraci: AFAIK there is no preferred way.
07:59:37 <quicksilver> there are just a bunch of libraries, each one used by a small number of people.
07:59:46 <quicksilver> takusen, HDBC, haskelldb
07:59:56 <alexsuraci> Haven't heard of takusen, I'll check that out
08:00:00 <Saizan> PeakerWork: it returns either a strict or a lazy BS, depending which .Char8 it is
08:00:10 <Saizan> PeakerWork: there are only two ByteString types
08:00:17 <PeakerWork> Saizan: ah, thanks
08:01:02 <alexsuraci> Huh, no MySQL support on that one, strange
08:01:06 <blackh> BerkeleyDBXML
08:01:22 <alexsuraci> well, "full" support anyway
08:07:18 <quicksilver> alexsuraci: that's because mysql is so full of fail no self-respecting haskell programmer would use it? ;)
08:08:11 <alexsuraci> I understand that, but it's the most popular with whoever will be using this software.
08:08:37 <Saizan> hsql has mysql support, iirc
08:09:03 <alexsuraci> Saizan: yea, it does
08:17:15 <gwern> it always distresses me to see how shite my computer performs when a little load is put on the hard drive
08:17:39 <gwern> I knew when I was building it that hard drive performance was more important these days than ram or gigahertz, but apparently I didn't compensate enough
08:18:15 <walter_> Did anyone know something about HStringTemplate? I want to put serveral into <p>$paragraph$</p>, but I dont know exactly how many paragraph, it depends on the data I get.
08:22:33 <doserj> walter_: I think there is sth like $foreach x in list$ sth $end$?
08:23:25 <walter_> doserj, yeah, that is what I need.
08:26:08 <walter_> doserj, thanks. $foreach  works well.
08:31:53 <skorpan> i'm looking for a function which given a function f and an integer n returns the composition of "n" fs
08:32:09 <skorpan> i.e. g f 3 = f . f . f
08:32:13 <skorpan> is this possible?
08:32:19 <Beelsebob> @hoogle (a -> a) -> Int -> a -> a
08:32:20 <lambdabot> Data.Sequence adjust :: (a -> a) -> Int -> Seq a -> Seq a
08:32:20 <lambdabot> Data.IntMap adjust :: (a -> a) -> Key -> IntMap a -> IntMap a
08:32:20 <lambdabot> Data.Generics.Basics gmapQi :: Data a => Int -> (a -> u) -> a -> u
08:32:28 <Beelsebob> nope, none of them...
08:32:29 <skorpan> already hoogled :)
08:32:54 <mux> skorpan: I don't know how to write it point-free but you can write it point-wise with iterate and (!!)
08:32:57 <Beelsebob> > let nTimes f 0 = id; nTimes f n = f . nTimes f (n-1) in nTimes (+1) 6 $ 1
08:32:59 <lambdabot>   7
08:33:19 <trez> r la bara att skriva sjlv
08:33:19 <mux> > let double = (*2) in iterate double 1 !! 10
08:33:20 <lambdabot>   1024
08:33:26 <skorpan> trez: redan gjort, men vill ha en snyggare
08:33:31 <mux> > let double = (*2) in iterate double 1 !! 11
08:33:32 <lambdabot>   2048
08:33:37 <Beelsebob> > let nTimes f = foldr (f .) id . enumFromTo 1 in nTimes (+1) 6 $ 1
08:33:39 <lambdabot>   No instance for (GHC.Num.Num (a -> a))
08:33:39 <lambdabot>    arising from the literal `1' at <...
08:33:45 <skorpan> :t iterate (*2)
08:33:46 <lambdabot> forall a. (Num a) => a -> [a]
08:33:48 <Beelsebob> oops, not quite right
08:37:29 <Philonous> @type replicate
08:37:30 <lambdabot> forall a. Int -> a -> [a]
08:38:17 <skorpan> > (replicate 3 (*2)) 1
08:38:18 <lambdabot>   Couldn't match expected type `t1 -> t'
08:38:29 <skorpan> :t replicate 3 (*2)
08:38:30 <lambdabot> forall a. (Num a) => [a -> a]
08:39:04 <ski> it might be nice with a `Num Church' where `newtype Church = MkChurch {unChurch :: forall a. (a -> a) -> (a -> a)}
08:39:05 <skorpan> > foldr1 (replicate (*2)) 1
08:39:06 <lambdabot>   The section `GHC.Num.* 2' takes one argument,
08:39:06 <lambdabot>  but its type `GHC.Types.Int'...
08:39:18 <Beelsebob> > let nTimes f n = foldr (.) id $ replicate n f in nTimes (+1) 6 $ 1
08:39:19 <lambdabot>   7
08:40:35 <PeakerWork> Why doesn't Get have a typeclass MonadGet/etc like State/et-al?
08:41:04 <PeakerWork> I would like getWord8 to be in MaybeT Get Word8  rather than in Get Word8 so it can fail reasonably
08:43:03 <quicksilver> PeakerWork: i suspect the answer is because the authors were terribly concerned with extremely good performance
08:43:11 <quicksilver> (to both of your questions, basically)
08:43:28 <PeakerWork> but type-classes can be inlined in compile-time when possible :-(
08:43:29 <quicksilver> I think it's axiomatic that Get Word8 can't fail; failure should be handled at a higher level.
08:43:46 <Beelsebob> can't it?
08:43:53 <PeakerWork> quicksilver: Well, getByteString can fail, and it fails with pure exceptions, rather than the polymorphic method "fail"
08:43:55 <Beelsebob> what if it's past the end of the input?
08:44:08 <PeakerWork> quicksilver: (it does use "fail" but its hard-coded to be in the Get monad, rather than some monad that had MonadGet)
08:44:23 <quicksilver> by 'axiomatic' I mean 'an assumption of the design'
08:44:48 <quicksilver> you call runGet on ByteStrings - you're only supposed to call it on ByteStrings which hold enough input
08:44:52 <PeakerWork> quicksilver: I need to manually call "remaining" and verify its big enough, which forces the rest of the string :(
08:44:56 <quicksilver> to do otherwise is a programming error, in terms of the API.
08:45:06 <PeakerWork> quicksilver: what if I want binary parsers that can fail?
08:45:10 <PeakerWork> Get is no good?
08:45:37 <quicksilver> get isn't really a parser in the normal sense
08:45:43 <quicksilver> it's a high performance bytestring reader
08:45:55 <quicksilver> it's pretty limited as a parser
08:45:57 <PeakerWork> its not a terribly powerful parser, but it is a kind of parser combinator
08:46:04 <quicksilver> but you can layer a parser above it.
08:46:24 <PeakerWork> are you supposed to really verify that the data you're giving to Get wasn't corrupted/truncated along the way?
08:46:46 <quicksilver> look I'm not saying it's perfect, or it can do everything.
08:46:52 <quicksilver> I'm explaining its intended use.
08:47:04 <quicksilver> I"m not saying it wouldn't be better if it was different, or you can't imagine something better, or...
08:47:34 <quicksilver> of course, no reliable system should even consider using Get on a Lazy Bytestring which comes from IO
08:48:10 <quicksilver> reliability and interleaved IO are at worst completely incompatible, and at best a research topic.
08:49:02 <Saizan> and in teh middle you can use attoparsec
08:49:32 <quicksilver> attoparsec is described as 'text-oriented'
08:54:39 <fracture> how do you wait for input from multiple Handles in haskell?  (i.e. something like unix select)
08:55:11 <mux> fracture: you typically don't do that but use threads instead
08:55:18 <Beelsebob> fracture: there may be a more basic way of doing it, but fire off threads to monitor each
08:55:24 <Beelsebob> and get each to feed into a channel when it gets data
08:55:41 <quicksilver> fracture: indeed, threads use unix select behind the scenes.
08:55:55 <mux> also, haskell threads are very, very, veeeery cheap.
08:55:57 <fracture> what do they use on windows?
08:55:57 <quicksilver> so threads are the "simplest" way to get select-like behaviour
08:56:07 <quicksilver> some windows API whose name escapes me
08:56:13 <fracture> WaitForMultipleObjects?
08:56:16 <mux> WaitForMultipleEvents or something
08:56:19 <quicksilver> WaitForNextThingyWotsitBuriedDeepInSomeUglyAPI
08:56:20 <mux> heh, yeah
08:56:43 <fracture> so... if I were writing say a telnet client
08:56:48 <fracture> I'd want a thread for interaction with the user
08:56:53 <fracture> and a thread for interaction with the remote host
08:56:53 <fracture> ?
08:56:56 <mux> yup
08:56:58 <fracture> ok
08:57:00 <quicksilver> probably four
08:57:03 <fracture> I'll learn about threads now :)
08:57:06 <mux> each blocking on its file descriptor
08:57:07 <fracture> four?
08:57:10 <quicksilver> hmm
08:57:17 <mux> and you'll probably have a third one to manage the rest
08:57:21 <quicksilver> maybe just three.
08:57:25 <fracture> ahh I see
08:57:26 <fracture> ok
08:57:27 <quicksilver> at least two threads for the socket.
08:57:27 <mux> that will be blocking on MVar's or Chan's
08:57:48 <quicksilver> (so reading and writing don't accidentally block each other)
08:58:06 <fracture> ok
08:58:23 <mux> in the case of a telnet client, I think you can actually get away with only two threads
08:58:25 <fracture> and... I'm hoping the referential transparency stuff probably simplifies MT correctness a lot in haskell, eh?
08:58:39 <quicksilver> yes, hugely
08:58:48 <fracture> (the idea of using threads for something like this in other languages would be pretty scary, from a reliability perspective)
08:58:49 <quicksilver> everything is immutable and can be safely shared between threads
08:58:54 <fracture> cool, sounds good
08:58:59 <mux> the one blocking on the socket will just putStrLn stuff when it has some, and the thread blocking on the keyboard input will write to the socket when it has lines to send
08:59:12 <Beelsebob> fracture: note though – while executing an IO action you don't have referential transparency
08:59:13 <fracture> makes sense
08:59:20 <Beelsebob> so, be careful still ;)
08:59:25 <quicksilver> Beelsebob: eh?
08:59:27 <quicksilver> Beelsebob: what?
08:59:28 <fracture> I might actually try a telnet client first to make sure I grok all this (should be pretty quick to whip up)
08:59:38 <Beelsebob> quicksilver: creating IO actions is pure, running them is not
08:59:51 <quicksilver> Beelsebob: what's that got to do with referential transparency.
09:00:00 <quicksilver> haskell is referentially transparent, inside IO and out.
09:00:08 <fracture> quicksilver: well, you could communicate with side-effects by putting data on the filesystem
09:00:15 <Beelsebob> yes, but the haskell runtime evaluating an IO action does not
09:00:15 <fracture> (that's what you mean, right beel?)
09:00:21 <Beelsebob> you don't get the same result from getChar every time
09:00:24 <fracture> you could get deadlocks that way if you tried
09:00:27 <quicksilver> Beelsebob: referential transparency is a static property.
09:00:31 <quicksilver> it applies to code
09:00:32 <quicksilver> terms
09:00:33 <quicksilver> expressions
09:00:35 <quicksilver> not running code.
09:00:41 <quicksilver> All of haskell is referentially transparent
09:00:43 <quicksilver> including IO
09:00:49 <quicksilver> "getChar" always denotes the same thing
09:00:50 <Beelsebob> quicksilver: yes, it's a static property of Haskell, but not of the programs that IO based code generates
09:00:52 <quicksilver> (an IO action)
09:01:01 <fracture> quicksilver: that is definitely not how I understand that terms "referentially transparent"
09:01:03 <Beelsebob> the IO action you get back, is not referentially transparent
09:01:12 * quicksilver counts to 10, slowly.
09:01:33 <quicksilver> Beelsebob: it is absolutely meaningless to say "...not of the programs that IO based code generates".
09:01:47 <quicksilver> referential transparency is a property of terms - or source code.
09:02:11 <Beelsebob> it's a property of a program - and when we use IO we talk about two programs
09:02:15 <Beelsebob> the one we write in haskell
09:02:16 <quicksilver> it is not meaningful to discuss if a compiled program is referentially transparent.
09:02:24 <Beelsebob> and the one it generates and causes the runtime to execute
09:02:45 <quicksilver> I am very sorry. I do not have time to have this argument with you now.
09:02:51 <quicksilver> Some time later when I have more time, perhaps.
09:03:14 <kynky> haskell communcating with world full of side effects
09:03:25 <quicksilver> However, lest anyone else in the channel get confused, haskell *is* referentially transparent, and Beelsebob, much as I respect him, and value his friendship, is quite wrong here.
09:03:35 <tromp> evaluating getChar just gives you getChar, it's already evaluated. executing it is something quite different
09:03:45 <Beelsebob> quicksilver: note – I'm not claiming haskell isn't RT
09:03:53 <Beelsebob> I'm claiming that the programs it generates are not
09:04:07 <tromp> so in terms of evaluation yeielding substitutable values, it is perfectly RT
09:04:13 <Beelsebob> IO actions are not RT
09:04:15 <Beelsebob> Haskell is
09:04:17 <Ferdirand> what does it mean for a program not to be RT ?
09:04:28 <Ferdirand> it cannot be substituted with its output ?
09:04:35 <Beelsebob> Ferdirand: indeed
09:04:40 <tromp> it's not evaluation that gives its output
09:04:44 <kynky> IO is just a special case of Monad ?
09:04:55 <Beelsebob> kynky: it's a secret special case that has hooks into the runtime
09:05:12 <ski> "referentially transparent" is about being able to replace variables with the expressions they're defined as
09:05:28 <fracture> I don't see how IO could be considered RT if it can change filesystem state
09:06:03 <opqdonut> there's a trick to it
09:06:04 <tromp> the real IO takes place outside of haskell's evaluation
09:06:05 <Philonous> I wonder whether unsafePerformIO is referentially transparent or not haskell.
09:06:09 <fracture> what's the difference between evaluating and running IO actions?
09:06:15 <Beelsebob> fracture: IO code in Haskell generates an action
09:06:17 <ski> one may replace variables of type `IO Whatever' with their defining expressions in exactly the same way as variables of other types
09:06:19 <Beelsebob> and that action is always the same action
09:06:20 <opqdonut> fracture: openFile "asdf" is always the same action
09:06:28 <Beelsebob> the action however, is itself not RT
09:06:44 <ski> the action is a value
09:06:47 <kynky> the consequence of the action
09:06:48 <opqdonut> fracture: you could interpret a haskell program as producing a tree of IO operations and reactions to them
09:06:58 <Beelsebob> ski: programs are values too
09:06:59 <opqdonut> fracture: the production of the tree is pure
09:06:59 <Ferdirand> why not ? the effects of an action are not its values, right ?
09:06:59 <Beelsebob> ;)
09:07:14 <ski> Beelsebob : you mean the `main' action ?
09:07:35 <Beelsebob> Ferdirand: take for example the unsafeLaunchMissiles function – when run, it has side effects - it itself is not RT
09:07:38 <Beelsebob> *however*
09:07:46 <Beelsebob> the unsafeLaunchMissiles function is always the same value
09:07:55 <Beelsebob> so a program that refers to it and passes it around *is* RT
09:08:12 <fracture> is "actions" a concept applicable to other monads?  (I thought I understood monads by now... guess not)
09:08:18 <Beelsebob> fracture: no
09:08:20 <fracture> meaning, a distinction between evaluating and running them
09:08:22 <kynky> the program, and the system the program runs on ?
09:08:26 <fracture> ok
09:08:28 <Beelsebob> an "action" is a secret runtime thing that's magical
09:08:34 <fracture> I see
09:08:39 <Beelsebob> it's applicable only with the IO monad
09:08:51 <SamB> Beelsebob: well ... not quite!
09:09:10 <ski> fracture : yes :) `action' is applicable to every monad
09:09:11 <SamB> STM, for instance ...
09:09:33 <ski> e.g. here's an action in the list monad
09:09:37 <SamB> maybe ST
09:09:49 <SamB> have similar magical runtime secret things
09:09:50 <ski> > [(+),(*)] `ap` [2,3] `ap` [4,5]
09:09:51 <lambdabot>   [6,7,7,8,8,10,12,15]
09:10:24 <fracture> (where's ap defined?)
09:10:29 <ski> @index ap
09:10:30 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List, Data.Graph.
09:10:30 <lambdabot> Inductive.Query.ArtPoint, Data.Graph.Inductive.Query, Data.Graph.Inductive
09:10:30 <opqdonut> fracture: you can think of things in the State monad as actions too
09:10:39 <opqdonut> fracture: you run them with execState
09:10:39 <ski> `Control.Monad', really
09:10:44 <ski> @src ap
09:10:44 <lambdabot> ap = liftM2 id
09:10:50 <opqdonut> of course, running the other monads is doable with a pure function
09:10:58 <gwern> ಥ_ಥ  beautiful
09:11:16 <opqdonut> there are many metaphors for monads. which ones are most applicable depends on the situation
09:11:27 <fracture> ski: what makes that an action?
09:12:11 <ski> fracture : it having a type of form `M Foo' for a type constructor `M' (here `[]') being an instance of `Monad'
09:12:40 * EvilTerran talks about actions in monads other than IO
09:13:21 <fracture> ok so, "action" is either a metaphor for understanding what monads do, or a part of the implementation details of the IO monad.... (or both)?
09:13:40 <Saizan> the former
09:13:42 <fracture> when I write a user defined monad though, there doesn't seem to be a separate evaluation step vs. "run the actions" step
09:14:19 <fracture> ok... so how can IO be referentially transparent at evaluation time then?
09:14:24 <ski> (imo whether a monad is defined (wrt some implementation) in haskell or not isn't that important (here). the important part is that it obeys the same reasoning laws as all the rest of haskell)
09:14:31 <Beelsebob> fracture: because those two steps are seperate
09:14:33 <Beelsebob> first you evaluate
09:14:36 <Beelsebob> and you get an action
09:14:41 <Beelsebob> that action is always the same action
09:14:45 <Beelsebob> then you run the action in the runtime
09:14:48 <roconnor> @wiki IO_Semantics
09:14:48 <lambdabot> http://www.haskell.org/haskellwiki/IO_Semantics
09:14:50 <Beelsebob> the action itself is not RT though
09:15:02 * ski disagrees with Beelsebob
09:15:04 <fracture> can I manipulate IO actions in code?
09:15:07 <Saizan> Beelsebob: that's confusing
09:15:25 <Saizan> you can pass IO actions around as the other values, yes
09:15:27 <fracture> (if they are purely an implementation detail of the compiler, I think that makes no sense, and we should call IO non-referentially transparent)
09:15:54 * roconnor kinda agrees with Beelsebob
09:16:07 <fracture> can you give an example saizan?  (sorry if I'm being dense; just trying to grok)
09:16:12 <Ferdirand> but you cannot run an action from haskell code
09:16:19 <Beelsebob> no, sure
09:16:22 <Beelsebob> that's why Haskell is RT
09:16:23 <Saizan> Ferdirand: for example replicateM
09:16:28 <Saizan> ?type replicateM
09:16:29 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
09:16:41 <Beelsebob> we use main to create an IO action and the runtime happens to run it for us as well
09:16:55 <Saizan> fracture: that takes a number and an action and performs it that number of times
09:17:32 <dmwit> A value of type "IO a" is a description of how to generate a value of type "a", perhaps doing some IO in the process.
09:17:35 <Ferdirand> no, that builds a new action that when performed, will perform the other a number of times
09:17:41 <dmwit> It can be referentially transparent because it is always the same description.
09:17:45 <ski> executing `IO'-actions may cause "effects" to happen. in most languages, these would be "side-effects", while in haskell they're not, because the effects are accounted for in the types - you can't use an `State Foo Int' in place of an `Int' or vice versa (similarly for any other monad than `State Foo')
09:17:53 <dmwit> But following its instructions can produce different values.
09:17:56 <Saizan> Ferdirand: yeah, right
09:18:00 <Beelsebob> dmwit: no no - that would be the program *generating* the IO action that's referentially transparent
09:18:07 <Beelsebob> the description itself is not RT
09:18:24 <Beelsebob> otherwise all C programs would be RT - after all, it's always the same program you're running
09:18:24 <dmwit> Sure, I'm fine with that distinction.
09:19:06 <dmwit> That's not how the term RT is usually used, I think, but it's a fine way to use it if you're consistent.
09:19:08 <ski> in the same way as `IO'-effects, we can talk about `State Foo'-effects, `Cont Answer'-effects, and even `[]'-effects and `Parser Token'-effects
09:19:13 <Saizan> Beelsebob: i think you're mixing layers
09:19:35 <dmwit> (i.e. usually we would say the "IO a" value is RT because we can refer to it many times, and it is still the same value, i.e. the same description.)
09:19:37 <Beelsebob> ski: yes, but those ones actually always will give the same value when run
09:19:40 <Beelsebob> unlike IO actions
09:19:52 <Saizan> Beelsebob: i can subsitute the description for the expression that evaluates to it anywhere
09:19:57 <ski> Beelsebob : "run" isn't well-defined here, i'd claim
09:20:13 <Beelsebob> Saizan: sure - that makes the program generating the description RT
09:20:20 <Beelsebob> what you can't do, is substitute the value that the description computes for the description
09:20:24 <fracture> Saian: ok that seems to make sense (w/ the replicate)
09:20:27 <Beelsebob> so the description is *not* RT
09:20:39 <fracture> is there a function that just runs an IO action?
09:20:56 <dmwit> But the value the description computes doesn't even have the same type!
09:21:00 <Saizan> fracture: no
09:21:06 <dmwit> Of *course* you can't substitute it for the description itself.
09:21:12 <fracture> @src replicateM
09:21:13 <lambdabot> replicateM n x = sequence (replicate n x)
09:21:26 <dmwit> fracture: Yes, but we don't use it. ;-)
09:21:29 <ski> (Beelsebob : in Clean, one can easily imagine `IO a' being implemented as `*World -> (a,*World)', would you claim such an `IO'-action to not be RT, as well ?)
09:21:47 <SamB> doesn't the description compute the program ?
09:22:03 <Beelsebob> ski: sure - but that's not in any way useful - if you want nice strong guarentees about how the program behaves, you don't want to have to think about how the world behaves too
09:22:10 <SamB> I wish you'd stop saying RT, I keep thinking of Real Time
09:22:19 <Beelsebob> and as we were talking about whether RT helps with threading using forkIO, that's pretty useless
09:22:34 <Beelsebob> RT helps with threading, as long as the threading happens in the RT bit, not in the description
09:22:49 <fracture> ok so.... something like putStrLn is referentially transparent, because it always returns the same action.  But sequence or replicateM or main (anything that runs actions) is not RT.
09:22:51 <fracture> correct?
09:22:58 <ski> Beelsebob : the point of defining such an `IO' would be to not "have to think about how the world behaves" .. just as with haskell's `IO'
09:23:03 <SamB> referential transparency helps a lot with threading
09:23:13 <quicksilver> RT helps enormously with threading.
09:23:17 <quicksilver> and there is no RT bit.
09:23:19 <Saizan> fracture: sequence is still RT
09:23:21 <quicksilver> all of haskell is RT
09:23:21 <Beelsebob> sure it helps with threading
09:23:21 <dmwit> fracture: replicateM is RT
09:23:24 <quicksilver> there is no "bit" which is not.
09:23:26 <Beelsebob> what it doesn't help with is forkIO
09:23:30 <quicksilver> (sorry, I know I said I didn't have time)
09:23:30 <quicksilver> ;)
09:23:32 <Beelsebob> because forkIO is not threaded
09:23:35 <SamB> if most of your computations are done in referentially transparent code, you have a heck of a lot less mutation to worry about the interactions between ...
09:23:37 <fracture> how can it be RT if it runs actions that have side effects?
09:23:42 <Beelsebob> it's an action that happens to generate threads
09:23:45 <Saizan> fracture: they just build bigger actions out of smaller ones
09:23:53 <dmwit> fracture: It doesn't run actions that have side effects, that's the thing.
09:24:00 <ski> (Beelsebob : my point there was that haskell's `IO' could have been defined in haskell, provided lower primitives in terms of `*World' was given, and provided haskell had uniqueness types)
09:24:09 <jacobian> hmmm, if I use the error monad it serialises in such a way that the computation doesn't terminate.  Is there some way to do errors that wont have this problem?
09:24:10 <SamB> fracture: only if the side effects end up cancelling out ...
09:24:15 <SamB> or something like that
09:24:26 <Beelsebob> ski: sure – but then you have to think about "World" when dealing with your values - and you're back at square one with threading being hard
09:24:31 <fracture> ok... so only main is not RT?
09:24:32 <dmwit> fracture: replicateM takes a description of how to build an "a" value and returns a description of how to return several "a" values in a list.
09:24:33 <Beelsebob> if all threading does is manipulate the "world"
09:24:36 <Saizan> fracture: only the action corresponding to main gets run
09:24:47 <SamB> for instance, RT code is allowed to use dynamically allocated memory
09:24:47 <Saizan> fracture: but that doesn't mean main is not RT
09:24:53 <ski> (Beelsebob : these lower-level primitives might be defined in C or some assembler .. but the same may be true of `cos' .. what matters is what modes of *reasoning* is allowed)
09:25:13 <Beelsebob> ski: but they're not allowed - they're no easier when talking about IO code than when talking about C code
09:25:23 <ski> Beelsebob : no, the point of defining an abstract data type `IO' is exactly *not* to have to think about `World'
09:25:30 <Beelsebob> they're easier when talking about magically parallelising things because we're not affecting the world
09:25:35 <Beelsebob> but they're not easier in IO at all
09:25:47 <roconnor> Nothing in Haskell runs any actions.  The only thing that runs actions in the "run-time system" which runs the action called main (which is probably has been built up from lots of little actions), and the "run-time system" isn't accessible inside Haskell
09:25:51 <Philonous> Beelsebob: If haskell ist RT, what about unsafePerformIO? Clearly let a = unsafePerformIO ( randomIO ) can not be replaced with a value, because haskell is not lazy after all
09:25:54 <SamB> Beelsebob: um, IO code is a lot easier than C code
09:26:06 <Beelsebob> SamB: what extra guarentee do you get?
09:26:10 <Beelsebob> when it comes to threading?
09:26:24 <roconnor> unsafePerformIO isn't part of Haskell.  It is part of GHC, and other perhaps implementations.
09:26:25 <dmwit> Philonous: SSSHHHH!  You're not helping.
09:26:31 <SamB> Beelsebob: well, a lot of the function calls in your IO code can be plainly seen to not involve IO
09:26:37 <SamB> that helps
09:26:46 <SamB> so you only have to look at the ones that do
09:26:51 <Beelsebob> SamB: that's not what I asked – that's a case of non-IO code is nice to reason about
09:26:55 <SamB> in C, any of them code!
09:26:59 <Beelsebob> that's not a guarentee that you get in IO code, but not in C
09:27:01 <SamB> er. could
09:27:10 <dmwit> Philonous: We've even consciously avoided that when he asked whether there was a function that just runs an IO action. ;-)
09:27:11 <SamB> Beelsebob: sure it is!
09:27:12 <Beelsebob> that's a guarentee you get by *not* using IO
09:27:32 <SamB> what I'm saying is that IO isn't all-or-nothing, which is really nice
09:27:42 <Beelsebob> sure - but that doesn't make it easy to reason about IO
09:27:44 <SamB> in C, it's all C ...
09:27:47 <Saizan> it's a guarantee you get by the existence of IO, that let you make a distinction
09:27:47 <Beelsebob> it makes it easy to reason about things that aren't IO
09:27:55 <Beelsebob> IO is no easier to reason about than C code
09:27:59 <SamB> Beelsebob: well, it cuts down the stuff you need to be careful about
09:28:07 <fracture> it's seeming harder so far
09:28:09 <SamB> it's a reason to use IO instead of C ...
09:28:14 <Beelsebob> SamB: again -- that's not something that IO gives you
09:28:18 <Beelsebob> it's something that *not* using IO gives you
09:28:29 <fracture> so, I need to change my mental model here is what it sounds like
09:28:39 <SamB> well, it's something Haskell gives you ...
09:28:44 <Beelsebob> sure
09:28:57 <Beelsebob> but that doesn't make reasoning about threading code in IO any easier than reasanoing about threading code in C
09:29:00 <Beelsebob> ...
09:29:06 <Beelsebob> it makes reasoning about *pure* code easy
09:30:24 <SamB> yeah, well, IO has that advantage over C
09:30:29 <Beelsebob> no
09:30:31 <fracture> so in practice, does the program really build this action tree before executing?
09:30:33 <Beelsebob> pure code has that advantage over C
09:30:33 <SamB> you don't have to use it everywhere!
09:30:41 <Beelsebob> I don't have to use C everywhere
09:30:45 <Beelsebob> I can make FFI calls into Haskell
09:30:46 <dmwit> fracture: Yes, but lazily.
09:30:51 <fracture> I see
09:30:57 <SamB> it can invoke pure code, and you can tell AT A GLANCE when it does
09:30:57 <Beelsebob> in fact, if we consider IO in Haskell to be referentially transparent, then IO actions like forkIO are not multi threaded by nature – we can use a single thread to evaluate the IO action that contains the instruction to fork a new thread
09:31:04 <TomMD> dcoutts: Did you ever get the hackage patches I sent?  I sent them again just now just in case.
09:31:17 <fracture> and the value of main is an action, composed of other actions... this sorta makes sense
09:31:19 <Beelsebob> so it's totally useless to talk about threading being easy to reason about in haskell if we consider haskell to be RT
09:31:24 <SamB> you CAN write pure code in C; you can even annotate it as such.
09:31:28 <Saizan> fracture: if by "in practice" you mean "how GHC implements this" then no, but you shouldn't care
09:31:31 <ski> in some sense, the point of using monads for traditional effects (state, i/o, exceptions, environment/reader, output/writer, continuations, angelic nondeterminism, demonic nondeterminism, ...) is to know when you're *not* using a certain kind of effect
09:31:35 <Beelsebob> SamB: or... I can make an FFI call into some pure Haskell code
09:31:36 <SamB> but what you can't do is tell at a glance from the call site that it's pure!
09:31:43 <quicksilver> Beelsebob: reasoning about threaded code in haskell is about a million times easier than reasoning in C
09:31:53 <Beelsebob> quicksilver: exactly how
09:31:54 <quicksilver> Beelsebob: the main reason being that data is immutable and safely shared.
09:32:04 <quicksilver> it's still not easy, but it's at least a million times easier.
09:32:06 <Beelsebob> no it's not
09:32:13 * Beelsebob points at the iORef
09:32:17 <SamB> Beelsebob: you can't mutate a cons cell
09:32:20 <SamB> that helps!
09:32:26 <Beelsebob> SamB: yes - *pure* code again
09:32:27 <quicksilver> in C someone can modify one byte of a word when you're halfway through reading it.
09:32:28 <Beelsebob> not IO code
09:32:33 <Beelsebob> IO code however car do mutation
09:32:37 <lilac> Beelsebob: when you said earlier that haskell's not referentially transparent when running IO actions, presumably you meant that you can say "do forkIO $ evilUnsafePointerFiddling; let { x = pureThing; y = pureThing }; return (x, y)"
09:32:38 <mreh> can I implement the exponential operator in pure code?
09:32:38 * Beelsebob points at the IORef again
09:32:39 <Saizan> Beelsebob: you don't use IORef everywhere in IO code either
09:32:42 <SamB> Beelsebob: IO code can't mutate a cons cell either, though
09:32:47 <quicksilver> you don't even use IORef mostly.
09:32:49 <Beelsebob> lilac: I never said that
09:32:51 <quicksilver> you use it very sparingly.
09:32:54 <Beelsebob> I said that the IO action is not RT
09:32:56 <lilac> ... and have it be different from " ... let { x = pureThing; y = x }; ..."
09:32:57 <Philonous> quicksilver: If you say haskell is referentially transparent, does that include unsafePerformIO or is that function not haskell (but a compiler extension)
09:32:57 <quicksilver> and never with threads.
09:33:04 <quicksilver> Philonous: it's not even a function.
09:33:12 <SamB> so, you can tell WHAT code could mutate stuff, and WHAT things could possibly be mutated
09:33:17 <quicksilver> Philonous: it's a compiler primitive which breaks everything about the language which is good.
09:33:23 <lilac> Beelsebob: pity, because i was going to agree with you :)
09:33:47 <lilac> inside the IO monad, you can tell how a pure function was written
09:33:48 <Beelsebob> lilac: well, evilUnsafePointerFiddling isn't part of Haskell
09:33:49 <SamB> it reduces the places you have to pay attention to by about 99% ...
09:33:55 <Philonous> quicksilver: Right it's not a function. But it's there and I wonder if this is haskell or not
09:33:57 <lilac> Beelsebob: is the FFI part of haskell?
09:34:12 <lilac> what do you call 'Haskell' here?
09:34:12 <Beelsebob> lilac: yes, but everything's wrapped up in an IO type
09:34:20 <Beelsebob> so that's all safe
09:34:21 <lilac> Beelsebob: yes, my do-block was in IO
09:34:23 <lament> gets() is not part of C!
09:34:23 <SamB> lilac: yeah, mutating cons cells by using unsafe pointer manipulations is NOT done in any serious code ...
09:34:32 <Beelsebob> lilac: well then your two programs don't have the same type
09:34:34 <TomMD> Beelsebob: IORef is a poor example for your argument -  I use it in threaded code all the time.  Once I read the IORef I know the data structure won't change - sure the IORef might get updated with a newer piece of information but the copy I have is _new enough_ that my opertions can continue... and the copy I have won't change, a promise I wouldn't have in C.
09:34:36 <lilac> SamB: no, absolutely not.
09:34:36 <Beelsebob> quicksilver: okay, so... Haskell is easy to do multithreading – if you avoid all the nasty parts of it
09:34:39 <lilac> Beelsebob: yes they do...
09:34:39 <SamB> lilac: Linus would never allow such things in his tree ;-P
09:34:44 <Beelsebob> which is roughly what I was trying to say
09:34:51 <Beelsebob> it's not inhearantly easier in Haskell
09:34:57 <Beelsebob> it's just easier to dodgy the nasty things
09:35:00 <Beelsebob> dodge*
09:35:06 <lilac> Beelsebob: they're both :: IO (x, y) for some x and y
09:35:10 <Guest39336> anyone know if those libs for updating record fields kill any performance optimizations or rewrite rules?
09:35:20 <Beelsebob> lilac: then they both return the same IO action every time
09:35:22 <Beelsebob> and are RT
09:35:30 <lilac> Beelsebob: it's not the IO action i'm looking at
09:35:35 <Beelsebob> the IO actions that are run by the runtime when you evaluate the Haskell program is not RT though
09:35:57 <quicksilver> Beelsebob: it *is* inherently easier.
09:35:58 <lilac> Beelsebob: the IO action invokes some pure code, and that pure code can produce different results for the same input depending on what evils the IO code surrounding it does
09:36:08 <quicksilver> it's inherently easier because data is immutable
09:36:08 <Beelsebob> quicksilver: sure – but it needs some qualification
09:36:12 <lilac> Beelsebob: given all Haskell code is surrounded by IO code I consider this to be an issue
09:36:15 <Botje> Guest39336: why, are you running into problems?
09:36:16 <quicksilver> I don't understand what's so controversial about that.
09:36:19 <TomMD> Guest39336: Its just sugar so it shouldn't harm anything compared with rebuilding the structure by hand.
09:36:19 <Beelsebob> threading is not easier in Haskell
09:36:23 <quicksilver> yes it is.
09:36:24 <SamB> the dangerous things in Haskell mostly have yellow-and-black stripes on them, and there is much less need to use them than in C -- C doesn't have any other option in most cases.
09:36:29 <Beelsebob> threading is easier in a subset of haskell that's inherantly safe
09:36:34 <quicksilver> I have programmed using threads in quite a few languages
09:36:44 <quicksilver> and it honestly is much easier in haskell
09:36:47 <ski> in Mercury, there's a `promise_pure' construct that can be used on code the implements a pure inferface (regardless of implementation details). if one lies to the compiler, all bets are off. it would be nice if (e.g.) GHC would give similar guarrantees about `unsafePerformIO' (or similar)
09:36:52 <quicksilver> (than C, C++, Java for example)
09:37:01 <Saizan> Beelsebob: how the language is normally, and most naturally used does have an importance in such discussions
09:37:09 <jkramer> Hello
09:37:16 <fracture> thanks for all the help grokking that all (gotta go play scrabble now... haha)
09:37:18 <opqdonut> ski: indeed, something like how unsafePerformIO is used in unamb
09:37:21 <Beelsebob> Saizan: true – and I'd 100% agree if we consider the naturally part
09:37:29 <Beelsebob> but completelly disagree if we consider the normally part
09:37:29 <Guest39336> TomMD: are you talking about the haskell98 accessors?
09:37:33 <opqdonut> er, insert "for" into previous sentence
09:37:37 <jkramer> How can I kill a thread in Haskell?
09:37:44 <opqdonut> :t killThread
09:37:44 <Beelsebob> because the normal use of Haskell involves all sorts of crazy calls out to other languages, and weird shit going on
09:37:45 <lambdabot> Not in scope: `killThread'
09:37:49 <opqdonut> gah
09:37:55 <Saizan> Beelsebob: why? we don't write datastructures with mutable variables at every node
09:37:57 <Guest39336> Botje: nah no problems yet just curious before i change code to use it
09:38:13 <jkramer> Are you sure? The description if killThread sounds like it doesn't really kill it
09:38:19 <Saizan> Beelsebob: and that's exactly what makes threading much easier
09:38:20 <TomMD> Guest39336: I was talking about the record field updating, which I believe is just sugar.  i.e.  let newFoo = Foo { fieldOne = x }
09:38:31 <TomMD> jkramer: It kills it.
09:38:32 <Beelsebob> Saizan: certainly if we're writing naturally – however, I suspect the majority of packages on Hackage involve a large amount of crazyCallToCBecauseI'mBindingStuff
09:38:35 <opqdonut> jkramer: anyway, killThread :: ThreadId -> IO ()
09:38:46 <opqdonut> ah, you were talking about it already
09:38:53 <jkramer> And how do I get the ThreadId?
09:38:59 <TomMD> @type forkIO
09:38:59 <Beelsebob> so naturally - yes
09:39:01 <lambdabot> Not in scope: `forkIO'
09:39:01 <Beelsebob> normally - no
09:39:03 <TomMD> grrr
09:39:05 <ski> opqdonut : yes, and in variouse byte-string implementations too, iirc .. it would be nice if the implementations could rely on more than the optimizer in GHC not currently botching it up (cf. `NO_INLINE' nonsense)
09:39:06 <dmwit> jkramer: from forkIO
09:39:08 <opqdonut> jkramer: you got it from forkIO
09:39:14 <opqdonut> :t Control.Concurrent.forkIO
09:39:15 <lambdabot> IO () -> IO GHC.Conc.ThreadId
09:39:19 <Saizan> Beelsebob: bindings are quite a different thing, and most provide an RT interface
09:39:20 <opqdonut> qualified works
09:39:22 <jkramer> And inside the thread?
09:39:28 <Beelsebob> Saizan: most?
09:39:29 <Beelsebob> o.O
09:39:33 <lament> Beelsebob: probably because the majority of useful packages on hackage are library wrappers, but surely that's not the way to judge a language
09:39:33 <Beelsebob> dunno which you've looked at
09:39:41 <opqdonut> ski: yeah
09:39:41 <Beelsebob> I think I've only met 1 binding that provided an RT interface
09:39:47 <Saizan> Beelsebob: which have you looked at?
09:39:52 <Beelsebob> OpenGL is a good start
09:39:54 <dmwit> jkramer: Inside the thread, you can just die, you don't need to commit suicide.
09:39:59 <Beelsebob> wanna try using that + threading?
09:40:05 <Beelsebob> or GLUT
09:40:14 <lament> Beelsebob: if you judge haskell by what's in library bindings, that's like saying you can't write a useful program in the language itself :)
09:40:15 <dmwit> jkramer: However, all the usual methods of inter-thread communication work here, in case you really want to kill your own self.
09:40:16 <Beelsebob> or any of the graphics/UI packages for that matter
09:40:21 <Saizan> ah, ok, i've never worked with graphics
09:40:30 <Saizan> but that's a peculiar subset, i'd think
09:40:32 <jkramer> dmwit: I just want the thread to disappear :)
09:40:45 <dmwit> jkramer: It disappears when it stops running.
09:40:49 <jkramer> exitSuccess seems to work, but I'm not sure if it's intended to be used in threads
09:41:04 <Beelsebob> Saizan: maybe for natural code – but I don't think so for "normal" people – I know very few coders who don't at some point have to write a UI
09:41:25 <TomMD> Outside of graphics you don't run into such issues as GLUT or OpenGL... take the OpenSSL, Network, XML, and Xen bindings as examples.
09:41:26 <dmwit> jkramer: forkIO (return ()) -- does not strand any threads or anything, that thread just "disappears"
09:41:28 <Saizan> graphic toolkits tend to impose you a mainloop, even, right?
09:41:37 <Beelsebob> Saizan: some of them, yeh
09:41:40 <Beelsebob> (most?)
09:41:52 <Guest39336> glfw doesnt
09:42:06 <Beelsebob> Saizan: I don't know of one single one that's thread safe though
09:42:10 <Beelsebob> nor one that's RT
09:42:21 <Saizan> well, there's lot of networking where concurrency is important that's quite far from GUIs
09:43:00 <TomMD> Indeed, graphics are unique in their terrible use of TLS.
09:43:18 <Philonous> @type myThreadId -- jkramer
09:43:19 <lambdabot> Not in scope: `myThreadId'
09:43:25 <Beelsebob> which is a shame... because graphics is one of the main areas where RT is *most* beneficial
09:43:29 <TomMD> @type Control.Concurrent.myThreadId
09:43:31 <lambdabot> IO GHC.Conc.ThreadId
09:43:42 <Beelsebob> because we have lovely hardware that can run 1600 threads at once
09:43:58 <jkramer> Philonous: Great, thanks :)
09:44:11 <lament> my computer can only run two threads at once :(
09:44:22 <ski> a binding not providing an RT interface would be similar to calling `unsafePerformIO' on specific impur `IO'-actions .. if the bindings bind side-effecting actions into haskell `IO', and (roughly) don't mutate values which can be "inspected" in haskell without using `IO', then it should be RT
09:44:41 <TomMD> I think Beelsebob is talking about GPUs, which is somewhat conflating the issue if that's the case.
09:45:14 <ski> of course, an `IO'-intersive binding would be an *imperative* (/ effectful) interface .. but still RT
09:45:28 <mightybyte> Is there an easy way to have cabal-install rebuild all dependencies with profiling enabled?
09:45:48 <alexsuraci> oi, neither hsql nor hdbc seem to work with the latest ghc
09:45:54 <Saizan> mightybyte: nothing automatic
09:46:03 <ski> this is similar to how an `State Foo'-based solution for a problem is imperative/effectful
09:46:13 <alexsuraci> hsql gives me a segfault, hdbc errors with "schedule: re-entered unsafely"
09:47:21 <TomMD> alexsuraci: If you're using the hsql package, I think haskelldb (and thus haskelldb-hsql) are the recommended DB libraries these days.
09:48:08 <alexsuraci> TomMD: I'd go further with HaskellDB if I could find some decent documentation on it. Plus if it uses hsql and hsql is "broken" it's doubtful I'd have much luck there. :/
09:48:48 <TomMD> alexsuraci: It could potentially use it safely, but admitadly I haven't used the DB libraries in a while.
09:55:55 <mightybyte> Saizan: Hmm, that seems like a pretty significant omission.
09:59:12 <Athas> Where do I get the profiling libraries for binary-0.4.4?
10:00:19 <mux> Athas: you have them by building the package with profiling libraries enabled
10:00:33 <mux> Athas: you can do that by passing the -p flag to the configure command (of cabal)
10:00:38 <mux> ie runhaskell Setup.hs configure -p
10:01:28 <Athas> mux: I think I used 'cabal install binary' to get them (at least they seem to be installed locally).  Can I do that with cabal install?
10:01:55 <mux> there's most likely a similar flag to use, but I don't know it
10:03:35 <Athas> Where can I find a manual for cabal-install?  It didn't install any manpages.
10:04:22 <mux>  -p --enable-library-profiling     Enable Library profiling
10:04:26 <mux> from cabal help install
10:04:32 <Athas> Thanks.
10:04:34 <mux> so you can pass the very same flag
10:08:06 <tibbe> @seen bos
10:08:06 <lambdabot> bos is in #haskell-in-depth, #ghc and #haskell. I don't know when bos last spoke.
10:08:54 <philipp_> i'm using parMap to parallelise a job which works fine for half an hour (cpu is constantly at 180%) but after that it drops to ~100% for the remaining 2 hours, any ideas?
10:09:40 <tibbe> philipp_: does profiling output give anything? i.e. is lots of time spent in GC?
10:10:10 <philipp_> tibbe: have to check that...
10:10:20 <philipp_> what if so?
10:10:29 <tibbe> philipp_: don't remember the exact flag
10:10:40 <tibbe> philipp_: if there's excessive GC you need to figure out why ;)
10:10:45 <tibbe> i.e. profile
10:12:41 <lilac> philipp_: does your list have two entries, one of which takes 5x longer to process than the other, by any chance? :)
10:14:14 <jkramer> Is there a way to work around circular module imports?
10:15:05 <jkramer> I have two modules and both use functions from the other module
10:15:30 <roconnor> jkramer: usually you can pull apart modules further to break the cycle.
10:15:48 <roconnor> jkramer: for example putting one of those functions into it's own module
10:16:00 <lilac> philipp_: http://www.nabble.com/Control.Parallel.Strategies.parMap-CPU-usage-td22497395.html
10:16:15 <roconnor> jkramer: then just re-export it from the module you originally wanted it in.
10:16:24 <saynte> jkramer: you can define a the necessary function in interface files, hs-boot i think. but you have to do this manually.
10:17:02 * dons ponders why the 'probability monad' post is at the top of programming reddit.
10:18:04 <mux> reddit is being weird today
10:19:29 <philipp_> lilac: thanks, so I'll try the head revision
10:22:45 <voker57_> how to convert numbers between bases?
10:22:57 <JamesSanders> I keep get this error in one of my programs "Not in scope: type constructor or class `True'"
10:23:11 <kpreid> JamesSanders: True is not a type; it is a value.
10:23:36 <Twey> voker57_: That is not a valid question
10:23:51 <Twey> Numbers are simply numbers; they have no associated base until they're formatted for human reading
10:24:30 <Twey> (which can be done with Numeric.showIntAtBase, as well as several small helper functions for common cases like Numeric.showHex)
10:25:07 <Botje> #haskell: we fix your question _AND_ answer it!
10:25:16 <mightybyte> How do you do a ghc build with profiling when it tells you "You need to build the program twice...using -osuf"?
10:25:33 <JamesSanders> so when something calls for Bool then I should be able to use True right?
10:25:40 <JamesSanders> @type True
10:25:41 <lambdabot> Bool
10:27:44 <kpreid> JamesSanders: Yes, but you can't give it a *type* True
10:28:10 <kpreid> JamesSanders: The difference between True and other Bools (i.e. False) does not show up at the type level.
10:28:18 <kpreid> If that's still confusing, show us your code
10:31:19 <Beelsebob> kpreid: sure it does... look... data True; data False
10:31:38 * Twey twitches.
10:31:44 <Beelsebob> >.>
10:31:45 <Beelsebob> <.<
10:32:14 <JamesSanders> so there is a Conf constructor and it looks a bit like this Conf = Conf {
10:32:14 <JamesSanders> priority :: !Bool
10:32:14 <JamesSanders> groupMembership :: !Bool
10:32:53 <JamesSanders> and my code is like so : conf = Conf True True
10:33:08 <JamesSanders> what am I doing wrong?
10:33:09 <kpreid> That's fine.
10:33:19 <Beelsebob> looks good to me :)
10:33:23 <kpreid> There's something else wrong.
10:33:25 <JamesSanders> yeah but it throws those errors in ghci
10:33:37 <Saizan> it must be something else
10:33:42 <ski> @paste
10:33:43 <lambdabot> Haskell pastebin: http://hpaste.org/new
10:33:47 <kpreid> You're not trying to define the data type at the ghci command line, are you?
10:33:54 <kpreid> ghci only takes expressions.
10:33:57 <JamesSanders> no
10:34:02 <kpreid> If that's not the problem, pastebin ^ your code
10:34:15 <JamesSanders> when I load the module into ghci I get the error
10:34:23 <ski> (also paste the error you get)
10:34:58 <JamesSanders> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5507#a5507
10:35:25 <Beelsebob> that's not all the source
10:35:30 <Beelsebob> nor the error
10:35:45 <Saizan> well it's enough source
10:35:50 <JamesSanders> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5508#a5508
10:35:53 <JamesSanders> that is the error
10:36:04 <Saizan> JamesSanders: you've to put parentheses around               ("htest")::PrivateName
10:36:12 <mauke> ("htest" :: PrivateName)
10:36:20 <Saizan> otherwise it parses what comes after as part of the type
10:36:24 <ski> (JamesSanders : next time, annotate the same paste with related pastes :)
10:36:25 <mauke> ("test") is the same as "test"
10:36:25 <Beelsebob> oh, heh, well spotted Saizan
10:36:39 <JamesSanders> sorry
10:37:54 <kpreid> JamesSanders: Similar problem in 'main' -- you're saying that join "test" is of type Group a
10:38:12 <kpreid> well, I suppose it is if Group is a type alias for IO
10:38:21 <kpreid> but I suspect you meant ("test" :: Group a)
10:38:32 <kpreid> use spacing. :: is least-precedence, not highest
10:39:30 <JamesSanders> so I went ahead and removed main
10:39:40 <Saizan> you actually have to use mkGroup to get a Group
10:39:58 <Saizan> (that part of the api is a bit annoying maybe)
10:40:33 <JamesSanders> ah seems like I might need to read up a little more on hspread
10:41:02 <Saizan> i'm the author, so you can blame me for the lack of documentation :)
10:41:56 <karld> I'm a newbie.  Is there a way to apply something like ( take 2 ) to a list until there are no elements remaining and return a list of lists?
10:42:27 <mauke> > iterate (take 2) "foo bar"
10:42:28 <lambdabot>   ["foo bar","fo","fo","fo","fo","fo","fo","fo","fo","fo","fo","fo","fo","fo"...
10:42:32 <mauke> no!
10:42:38 <karld> iterate!
10:42:40 <karld> thanks
10:42:45 <mauke> > iterate (drop 2) "foo bar"
10:42:46 <lambdabot>   ["foo bar","o bar","bar","r","","","","","","","","","","","","","","","","...
10:42:56 <Saizan> > map (take 2) . iterate (drop 2) $ [1..10]
10:42:57 <lambdabot>   [[1,2],[3,4],[5,6],[7,8],[9,10],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[...
10:43:01 <JamesSanders> Saizan: small world
10:43:03 <mauke> > takeWhile (not . null) . iterate (drop 2) $ "foo bar"
10:43:04 <lambdabot>   ["foo bar","o bar","bar","r"]
10:43:34 <karld> Cool, thanks for all the answers
10:43:37 <ski> > unfoldr (\as -> guard (not (null as)) >> return (splitAt 3 as)) "foo bar baz"
10:43:39 <lambdabot>   ["foo"," ba","r b","az"]
10:44:01 <ski> > unfoldr (\as -> if null as then Nothing else Just (splitAt 3 as)) "foo bar baz"  -- if you prefer
10:44:02 <lambdabot>   ["foo"," ba","r b","az"]
10:45:16 <rfmge> > replicateM 3 "HT"
10:45:17 <lambdabot>   ["HHH","HHT","HTH","HTT","THH","THT","TTH","TTT"]
10:45:22 <rfmge> can someone explain how 'replicateM n list' generates all permutations of length n of the given list?
10:45:30 <lilac> @src replicateM
10:45:30 <lambdabot> replicateM n x = sequence (replicate n x)
10:45:49 <lilac> rfmge: replicate 3 "HT" returns ["HT", "HT", "HT"]
10:46:00 <ski> > unfoldr (\as -> const (splitAt 3 as) `liftM` guard (not (null as))) "foo bar baz"  -- hm, longer :)
10:46:01 <lambdabot>   ["foo"," ba","r b","az"]
10:46:01 <lilac> rfmge: sequence for the list monad is nondeterministic choice
10:46:30 <rfmge> lilac: okay, that helps
10:46:39 <ski> > return (,,) `ap` [0,1] `ap` [2,3] `ap` [4,5]
10:46:41 <lambdabot>   [(0,2,4),(0,2,5),(0,3,4),(0,3,5),(1,2,4),(1,2,5),(1,3,4),(1,3,5)]
10:47:02 <ski> > do x <- [0,1]; y <- [2,3]; z <- [4,5]; return (x,y,z)
10:47:04 <lambdabot>   [(0,2,4),(0,2,5),(0,3,4),(0,3,5),(1,2,4),(1,2,5),(1,3,4),(1,3,5)]
10:47:16 <ski> > [(x,y,z) | x <- [0,1] , y <- [2,3] , z <- [4,5]]
10:47:17 <lambdabot>   [(0,2,4),(0,2,5),(0,3,4),(0,3,5),(1,2,4),(1,2,5),(1,3,4),(1,3,5)]
10:47:19 <lilac> rfmge: sequence is nondeterministic choice because it's the repeated application of >>=, and >>= on lists applies the rhs to every element of the lhs
10:47:48 <ski> > liftM3 (,,) [0,1] [2,3] [4,5]  -- for completeness, i suppose
10:47:50 <lambdabot>   [(0,2,4),(0,2,5),(0,3,4),(0,3,5),(1,2,4),(1,2,5),(1,3,4),(1,3,5)]
10:47:53 <ski> @src liftM3
10:47:53 <lambdabot> liftM3 f m1 m2 m3 = do { x1 <- m1; x2 <- m2; x3 <- m3; return (f x1 x2 x3) }
10:48:03 <rfmge> > "H" >>= "HT"
10:48:04 <lambdabot>   Couldn't match expected type `GHC.Types.Char -> [b]'
10:48:09 <lilac> rfmge: put another way, if you think of [] as the nondeterminism monad, you're asking "give me 3 things taken nondeterministically from ['H', 'T']"
10:48:30 <ski> > "ab" >>= \x -> x : "cd"
10:48:31 <lambdabot>   "acdbcd"
10:48:45 <Cale> > replicateM 3 "HT"
10:48:46 <lambdabot>   ["HHH","HHT","HTH","HTT","THH","THT","TTH","TTT"]
10:48:50 <ski> > "ab" >>= \x -> "cd" >>= \y -> [x,y,'*']
10:48:51 <lambdabot>   "ac*ad*bc*bd*"
10:49:30 <lilac> > do x <- "ab"; y <- cd; x:y:"*"
10:49:31 <lambdabot>   Not in scope: `cd'
10:49:37 <lilac> > do x <- "ab"; y <- "cd"; x:y:"*"
10:49:38 <trofi> > eval "1+2"
10:49:38 <lambdabot>   "ac*ad*bc*bd*"
10:49:39 <lambdabot>   Not in scope: `eval'
10:49:45 <wjt> @pl \f x -> fromMaybe x (f x)
10:49:45 <lambdabot> ap fromMaybe
10:49:59 <ski> @redo "ab" >>= \x -> "cd" >>= \y -> [x,y,'*']
10:49:59 <lambdabot> do { x <- "ab"; y <- "cd"; [x, y, '*']}
10:50:01 <wjt> is there a better name for that other than ap?
10:50:26 <Saizan> the only other name is <*>
10:50:35 <Cale> wjt: Oh, what a curious application of ap :)
10:50:35 <lesshaste> hi all
10:50:45 <ski> @type \f x -> fromMaybe x (f x)
10:50:46 <Cale> hello
10:50:47 <lambdabot> forall a. (a -> Maybe a) -> a -> a
10:50:52 <lilac> rfmge: another way of looking at it is, replicateM n x = do v1 <- x; ...; vn <- x; return [v1,v2,...,vn]
10:50:56 <trofi> :t fromMaybe
10:50:57 <lambdabot> forall a. a -> Maybe a -> a
10:51:06 <wjt> Cale: yeah, it made me smile
10:51:20 <wjt> in this case, i want to strip a prefix from a path if it has it, but otherwise leave it intact
10:51:25 <rfmge> lilac: okay, it makes more sense now, thanks
10:51:30 <ski> \f -> fromMaybe `ap` f
10:51:37 <ski> (fromMaybe `ap`)
10:51:38 <wjt> so i'm using \p -> fromMaybe p (stripPrefix "foo/bar" p)
10:51:48 <^Someone^> lilac: I use Konversation, and it has colored nicks. Interestingly, your nick color is very close to lilac xD
10:51:58 <ski> fromMaybe `ap` stripPrefix "foo/bar"
10:52:02 <lilac> ^Someone^: woo yay :)
10:53:13 <^Someone^> lilac: http://imagebin.org/51219
10:53:19 <wjt> using the ((->) r) monad makes me a bit sad
10:53:36 <wjt> I guess I'm surprised that S isn't sitting around somewhere less obtuse :)
10:53:38 <Cale> wjt: I suppose you could use  fromMaybe <*> stripPrefix "foo/bar"
10:54:02 <Cale> wjt: <*> is in Control.Applicative
10:54:45 <Cale> wjt: Though, that's using the ((->) e) Applicative functor instance instead :)
10:54:50 <wjt> Cale: well exactly :P
10:55:06 <Cale> wjt: The lovely thing about that is that the Applicative methods for ((->) e) are *exactly* K and S.
10:55:12 <wjt> i guess i'm golfing here anyway
10:55:27 <wjt> Cale: oh, sure
10:55:29 <Cale> and the Functor instance has fmap = (.)
10:55:32 <lilac> wjt: in that case, use stripPrefix "foo/bar" p <:> p
10:55:51 * lilac still pimping out <?> and <:>
10:55:56 <Cale> <:>
10:55:57 <Cale> ?
10:56:00 <wjt> @src (<:>)
10:56:00 <lambdabot> Source not found. Maybe you made a typo?
10:56:03 <wjt> @ty (<:>)
10:56:04 <lambdabot> Not in scope: `<:>'
10:56:11 * Cale does not know of it
10:56:14 <ski> @index <:>
10:56:15 <lambdabot> bzzt
10:56:19 <lilac> <?> :: Bool -> a -> Maybe a; <:> :: Maybe a -> a -> a
10:56:33 <Cale> ah
10:56:35 <mauke> :t fromMaybe
10:56:36 <Cale> cute
10:56:36 <lambdabot> forall a. a -> Maybe a -> a
10:56:42 <wjt> nice
10:56:42 * lilac will get around to uploading to hackage Real Soon Now
10:57:36 <Cale> I actually rather like how (fromMaybe <*> stripPrefix "foo/bar") reads.
10:57:44 <lilac> @let False <?> a = mzero; True <?> a = return a; (<:>) = flip fromMaybe
10:57:46 <lambdabot>  Defined.
10:57:47 <Saizan> why <:> ?
10:57:59 <Cale> Saizan: It agrees with C syntax in a funny way
10:58:00 <wjt> Saizan: by analogy to ?: in C
10:58:06 <hackagebot> bindings-libusb 0.0.3
10:58:10 <Saizan> ah, i see
10:58:22 <lilac> > map (\a -> (a > 3) <?> a - 3 <:> 0) [1..10]
10:58:24 <lambdabot>   No instance for (GHC.Num.Num (m a))
10:58:24 <lambdabot>    arising from the literal `0' at <int...
10:58:35 * monochrom is eager for Haskell Weekly News
10:58:44 <lilac> :(
10:58:49 * Cale is lazy for Haskell Weekly News
10:59:27 <kig> is there an optimized lib for fiddling with 4x4 opengl transformation matrices?
10:59:34 * monochrom is strict for Haskell Weekly News
10:59:43 <ski> > map (\a -> (a > 3) <?> (a - 3) <:> 0) [1..10]
10:59:45 <lambdabot>   [0,0,0,1,2,3,4,5,6,7]
11:00:07 <lament> Haskell Weekly World News?
11:02:17 <lilac> > (<:> '?') <$> safeHead <$> ["foo", "bar", "", "baz"]
11:02:18 <lambdabot>   "fb?b"
11:11:11 <hackagebot> bindings-common 0.1.3
11:25:49 <olsner> hmm, ghci seem to get the column numbers wrong (one off, presumably from the '>') for literal haskell
11:35:03 <JamesSanders> Saizan: join expects a Group but mkGroup gives Maybe(Group), how do I get around that
11:35:24 <JamesSanders> sorry talking about hspread btw
11:35:54 <Saizan> JamesSanders: you've to pattern match on the returned Maybe
11:36:07 <Saizan> JamesSanders: the point is that not all strings are valid group names
11:36:14 <JamesSanders> ah
11:36:17 <JamesSanders> makes sense
11:36:47 <gwern> System.Directory is in directory, which works on windows, right
11:37:09 <EvilTerran> gwern, in my experience, yes
11:37:18 <gwern> experience? no guarantees?
11:37:36 <EvilTerran> i've used it, it worked for me. YMMV.
11:37:56 <Saizan> System.Directory is supposed to abstract over the platform, yeah
11:38:17 <EvilTerran> i don't know the official status; i've not felt the need to look it up, seeing as it WFM.
11:48:57 <voker57_> @hoogle (a, a) -> [a,a]
11:48:57 <lambdabot> Parse error:
11:48:57 <lambdabot>   --count=20 "(a, a) -> [a,a]"
11:48:57 <lambdabot>                          ^
11:50:06 <ClaudiusMaximus> is call-by-need an optimal evaluation strategy for untyped lambda calculus?  my naive evaluator is very slow (in  (\x . f x x) y  it ends up evaluating y twice...)
11:51:23 <mauke> then it's obviously not optimal
11:51:41 <byorgey> ClaudiusMaximus: call-by-need is only efficient if you do some sort of sharing / graph reduction.
11:51:55 <ClaudiusMaximus> my naive evaluator isn't call-by-need
11:52:00 <Cale> ClaudiusMaximus: You seem to be doing plain outermost-first evaluation
11:52:06 <ClaudiusMaximus> Cale: yes indeed
11:52:18 <Cale> (I don't understand these call-by-X evaluation strategy names)
11:52:53 <ibid> ClaudiusMaximus: call by need is not optimal, if measured by number of beta reductions. see the work of levy et al on optimal beta reduction
11:52:55 <Cale> In order to do lazy evaluation, you need to ensure that whenever a function parameter occurs more than once in the body of a function, then any results of evaluating it are shared between the copies.
11:52:59 <byorgey> call-by-need = outermost-first
11:53:07 <byorgey> call-by-name = that, but with sharing
11:53:19 <ibid> byorgey: you have that backward
11:53:25 <Cale> byorgey: Yeah, but those names are very unintuitive to me.
11:53:26 <byorgey> oh, do I?
11:53:30 <byorgey> Cale: me too.
11:53:40 <byorgey> well, and apparently I had them backwards. =)
11:53:42 <mornfall> call-by-{need,name} is stupid :)
11:53:46 <ibid> yes, call-by-name is weak normal order reduction
11:53:55 <Cale> I don't see why people don't just say what they mean :)
11:53:57 <ibid> call by need is that + sharing
11:54:01 <mornfall> call-by-value and call-by-reference make some limited sense I guess :)
11:54:15 <ibid> call by name goes back to Algol 60
11:54:30 <mornfall> Yes, and it was really by name then, IIRC.
11:54:38 <ibid> and call by need is iirc almost as old as wadsworth's thesis
11:55:51 <ibid> (the name, i mean)
11:55:59 <Cale> Even for call-by-value, it makes more sense to me just to say 'innermost-first'
11:56:14 <ibid> ah, but call by value is *not* innermost first
11:56:21 <mornfall> Lol. :)
11:56:21 <ibid> call by value is the weak version of that
11:56:32 <ibid> (ie. never reduce under a lambda)
11:56:59 <mornfall> call by value = strict, call by *cough* name = normal, call by need = lazy? : - )
11:57:23 <ibid> mornfall: call by name is weak normal, otherwise correct
11:57:43 <Cale> Ah, well then, it's still clearer to say weak innermost-first or innermost-first without evaluating under lambdas.
11:58:03 <mornfall> So what's the weakness about, then?
11:58:19 <Cale> mornfall: Whether the evaluator will evaluate inside of an unapplied lambda
11:59:03 <ibid> and basically no evaluator that is intended for programming does that
11:59:26 <mornfall> http://en.wikipedia.org/wiki/Evaluation_strategy has all of it :)
11:59:31 <Cale> Yeah, when I say 'innermost first' I usually mean 'without evaluating under lambda'
11:59:31 <ibid> (evaluators that are inside theorem provers or partial-evaluation optimizers do)
11:59:44 <marcot> Why aren't more licenses add to the list in Distribution.License?
11:59:44 <lambdabot> marcot: You have 1 new message. '/msg lambdabot @messages' to read it.
12:00:11 <marcot> http://www.opensource.org/licenses/category
12:00:14 <ibid> lambdabot: why do you insist on that broken message interface, when Freenode provides a better one?
12:00:16 <Cale> I think it's probably more sensible to adopt a convention of calling the versions which do evaluate underneath lambdas 'strong'
12:00:16 <marcot>  .:: Licenses that are popular and widely used or with strong communities ::.
12:00:35 <ibid> Cale: people do that, when it is important, yes :)
12:04:46 <ClaudiusMaximus> so for sharing i guess i need something like data Term = Variable Name | Lambda Name Term | Apply Term Term | Reference Integer  along with  type Graph = Map Integer Term
12:06:41 <marcot> I'm trying to use UnkownLicense in the license field of a cabal file, but I'm getting: Setup: questionary.cabal:5: Parse of field 'license' failed.
12:08:33 <MyCatVerbs> marcot: spelling error? It's UnknownLicense.
12:09:38 <marcot> MyCatVerbs: no, this was only to type here on IRC.
12:09:45 <marcot> I tried here:
12:09:55 <marcot> > read "UnknownLicense \"FreeBSD\"" :: License
12:09:56 <lambdabot>   Not in scope: type constructor or class `License'
12:10:02 <mmorrow> what is the reverse postorder of the graph [(0,[1,2]),(1,[0,2]),(2,[])] ?
12:10:04 <marcot> And it worked in ghci.
12:10:13 <mmorrow>  [0,1,2], right?
12:10:45 <MyCatVerbs> marcot: er... why specify the license as unknown "FreeBSD"?
12:10:49 <mmorrow> suprisingly there are no examples to verify on google...
12:11:02 <marcot> MyCatVerbs: can you configure a cabal package with this field there?  I'm using ghc 6.10.3, and cabal 1.6.0.3
12:11:18 <MyCatVerbs> There are BSD-2, BSD-3 and BSD-4 entries for the license, and people will be much happier if you write one of those in.
12:11:40 <marcot> MyCatVerbs: There's not BSD-2.
12:11:55 <marcot> MyCatVerbs: If there was, I think it would mean the same license as FreeBSD.
12:12:12 <MyCatVerbs> Eh, just make it BSD-3. BSD-2 and BSD-3 aren't, AIUI, interestingly different.
12:12:53 <marcot> http://www.gnu.org/licenses/license-list.html#FreeBSD
12:14:19 <marcot> 3. The name of the author may not be used to endorse or promote products derived from this software without specific prior written permission.
12:14:23 <marcot> This is the difference.
12:14:38 <marcot> And I don't want to have this clause in my license.  So, it's not BSD3.
12:14:57 * roconnor uses MIT
12:15:11 <marcot> MIT is also cool.
12:15:21 <marcot> roconnor: do you use BSD3 in .cabal?
12:15:41 <fracture> I am trying to import Control.Monad.Reader, and get
12:15:42 <fracture>     Failed to load interface for `Control.Monad.Reader':
12:15:42 <fracture>       it was found in multiple packages: monads-fd-0.0.0.1 mtl-1.1.0.2
12:15:44 <roconnor> no
12:15:47 <fracture> (in ghc)
12:15:55 <fracture> anyone know what I need to do?
12:15:56 <roconnor> I use unknown licence
12:16:11 <MyCatVerbs> fracture: ghc-pkg hide monads-fd # at the command prompt, should solve this.
12:16:18 <marcot> roconnor: UnknownLicense or OtherLicense?  I can't make UnknownLicense work here..
12:16:40 <MyCatVerbs> What the Hell is monads-fd anyway? People really should not be writing packages that conflict with mtl!
12:16:44 <roconnor> sorry OtherLicense
12:16:45 <seliopou> fracture, or you can use ghc's -hide-package flag
12:16:50 <fracture> dunno
12:16:53 <fracture> ok thanks
12:16:55 <marcot> Has anyone ever used UnknownLicense?
12:16:56 <fracture> I dunno what monads-fd is
12:17:04 <seliopou> it's mtl with functional dependencies
12:17:11 <seliopou> instead of type classes
12:17:15 <fracture> I think the only package I've installed that is not default was a Data.Numbers thing
12:17:21 <fracture> (prime number functions)
12:17:28 <roconnor> marcot: conal was trying a few days ago, and failing IIRC
12:17:41 <marcot> roconnor: hum, good to know I'm not the only one.
12:18:12 <MyCatVerbs> fracture: cabal install chases dependencies. So if Data.Numbers requires monads-fd then it'll install both.
12:18:20 <fracture> *nod*
12:23:31 <marcot> roconnor: They've added MIT in darcs version of cabal.
12:24:44 <roconnor> marcot: yes
12:25:59 <thoughtpolice> well, the idea is that cabal is smart enough to do the hard stuff providing you write your dependencies correctly
12:26:05 <thoughtpolice> but shadowing names is never a good idea, no
12:26:36 <thoughtpolice> it makes it particularly problematic for GHC just on the command line (since you have to -hide-package) unless you use the PackageImports extension, which helps
12:27:02 <thoughtpolice> but it's still not very fun to deal with
12:27:15 <thoughtpolice> mtl may be on the way out anyway
12:27:24 <thoughtpolice> providing we can get some sort of consensus to switch
12:28:16 <thoughtpolice> I do *not* like how monads-fd and monads-tf etc. shadow the mtl names, however.
12:28:37 <thoughtpolice> i should probably just use monadLib or something
12:29:19 <roconnor> > sqrt (1-0.568)
12:29:20 <lambdabot>   0.6572670690061994
12:29:42 <roconnor> thoughtpolice: they are supposed to be drop in replacements for the mtl
12:30:17 <roconnor> > 1-sqrt (1-0.568)
12:30:18 <lambdabot>   0.34273293099380064
12:31:17 <thoughtpolice> roconnor: can packages which work with mtl work without problem using e.g.transformers+monads-fd as a drop-in?
12:31:50 <sjanssen> thoughtpolice: I believe you have to add extra imports to get the classes
12:32:41 <thoughtpolice> the problem is that I have packages which I use, some of which use mtl, some of which use transformers+something, and it makes it annoying to test things with ghci sometimes
12:33:36 <thoughtpolice> if we see a shift hopefully it will be soon, so I can cabal uninstall mtl and not have that problem anymore
12:33:55 <roconnor> thoughtpolice: *shrugs* that's what you get for using a global environment for ghc packages.
12:34:10 <Berengal> thoughtpolice: If you're only troubled in ghci, you can use :set -hide-package to hide one of them
12:34:37 <thoughtpolice> Berengal: I can totally get around it (PackageImports works good,) I just don't like it. :)
12:36:39 <thoughtpolice> sjanssen: really? awesome. that makes switching simple, worthy of automating, even if that's all it takes.
12:38:35 <roconnor> thoughtpolice: switch to monadLib instead
12:39:26 <thoughtpolice> roconnor: I like monadLib a lot (and use it,) I just want a solution for *that* problem. :)
12:39:47 <thoughtpolice> although last I remember I had to do something to get it to work with 6.10
12:39:52 <thoughtpolice> that was a while ago
13:01:11 <MrChutney> I'm trying my hand at a lexical analyzer for this small project of mine. I have a language designed, and I have this datatype which describes a set of instructions.
13:01:45 <MrChutney> And I want to make some function, f, which converts from the language to the instructions.
13:01:58 <MrChutney> I've considered a certain approach, but I'm not terribly certain of myself:
13:02:32 <MrChutney> I'm wanting to create an intermediate language, which is a subset of valid code under the entire language:
13:02:45 <MrChutney> And under this subset, all code is unsynonymous
13:03:18 <MrChutney> And thus any line of code corresponds uniquely to an instruction in my datatype, so that there is an isomorphism between the two.
13:04:05 <MrChutney> The drawback is that this involves a lot of rearranging of code, and since I am trying to make an interpreter with concerns about efficiency, I'm not utterly convinced of my method :/
13:04:51 <Saizan> the representation of the syntax tree and the code interpreted by your runtime can be different
13:04:51 <MrChutney> Can anyone offer any advice on the subject?
13:05:06 <Saizan> i.e. you might have more than one layer
13:05:34 <Saizan> that's what's usually done nowadays, afaik
13:06:35 <Baughn> MrChutney: Modern "interpreters" typically compile to bytecode, which is then interpreted
13:06:49 <Baughn> FWIW, a primitive compiler can be really very simple indeed
13:07:07 <MrChutney> I've honestly never heard of syntax trees until now, and this gives me something to work with. Thanks a bunch!
13:08:13 <lunarisbluemoon> Hi #haskell; I'm writing up a benchmark in Haskell which is essentially a port of a C program. Any tips for speed?
13:08:28 <Saizan> ah, the "abstract syntax tree" is how the result of parsing is generally called
13:09:18 <mgee> hi, i am using the HERA package, which provides the datatype CReal. Now ghc tells me that I have to add "(RealFloat CReal) =>" to every function using CReal... how can i prevent this? I just want to use the datatype without any instance declarations...
13:09:23 <MrChutney> Oh, I see.
13:09:35 <lunarisbluemoon> I've read several articles on the matter, but really I'm not a Haskell guru and am wondering if it's standard practice to use a state monad to mimic an imperative program.
13:09:50 <lunarisbluemoon> mgee: what is the exact error message?
13:10:17 <Beelsebob> lunarisbluemoon: people seem to do it a lot
13:10:23 <Beelsebob> but I would hardly call it natural
13:10:32 <Saizan> lunarisbluemoon: direct recursion or the use of combinators like foldl' / foldr are often more natural
13:10:36 <Beelsebob> better to find a truely functional description of the problem
13:10:43 <mgee> lunarisbluemoon: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2537#a2537
13:10:47 <Saizan> it mostly depends on the problem
13:11:31 <Saizan> a State monad is most useful to organize a larger program than a little benchmark
13:11:33 <lunarisbluemoon> mgee: That's not asking you to add "(RealFloat CReal) => " to every function, is it?
13:11:44 <lunarisbluemoon> Saizan: this benchmark isn't that little.
13:11:46 <lunarisbluemoon> :)
13:11:51 <mgee> lunarisbluemoon: instead?
13:12:15 <lunarisbluemoon> mgee: You need something like "instance RealFloat CReal where ..." somewhere don't you?
13:12:30 <lunarisbluemoon> I've never used the package, sorry.
13:12:39 <lunarisbluemoon> Does it provide both RealFloat and CReal?
13:12:53 <Saizan> ?src RealFloat
13:12:53 <lambdabot> Source not found. The more you drive -- the dumber you get.
13:13:00 <mgee> lunarisbluemoon: mhh. it provides fractional. but not realfloat :-/
13:13:54 <lunarisbluemoon> Which function do you want?
13:13:54 <roconnor> CReal isn't an instance of RealFloat
13:13:56 <lunarisbluemoon> floatDigits?
13:14:10 <lunarisbluemoon> Isn't CReal for "exact real arithmetic?"
13:14:17 <roconnor> oh
13:14:23 <roconnor> or is this some other CReal?
13:14:46 <lunarisbluemoon> I'm not sure :)
13:14:52 <mgee> lunarisbluemoon: yes it is. I want to use /=. This should be covered by Eq. mhh ok I investigate a little bit. thanks
13:15:06 <mgee> roconnor: It is exact real arithmetic
13:15:15 <lunarisbluemoon> mgee: As you say, shouldn't CReal have an Eq instance?
13:15:15 <J11> Is there a monadic operator that works almost like >>= but is m a -> (a -> m b) -> m a ?
13:15:41 <mgee> lunarisbluemoon: it has. i am wondering why haskell tells me to add an instance of realfloat just because i am using /=
13:15:50 <Baughn> @type (/=)
13:15:51 <lambdabot> forall a. (Eq a) => a -> a -> Bool
13:16:04 <Baughn> Well, I don't think /= is what is doing it.
13:16:10 <lunarisbluemoon> mgee: That may not be it - what are f and g's types in your pasting?
13:16:27 <lunarisbluemoon> mgee: Alternatively, do the bodies of f and g reference any of the functions in the RealFloat typeclass?
13:17:16 <mgee> lunarisbluemoon: I am not quite sure. Actually I am modifying someone else's work. I think f and g are "((Bool,Bool) -> Complex CReal)"
13:17:17 <lunarisbluemoon> J11: Hoogle doesn't think so.
13:17:17 <roconnor> mgee: using (/=) doesn't require a RealFloat instance
13:17:34 <lunarisbluemoon> J11: At the risk of sounding stupid, what's the second argument's purpose?
13:17:45 <lunarisbluemoon> (Since b seems unused?)
13:18:14 <lunarisbluemoon> mgee: It's certainly not Eq that's causing this.
13:18:26 <roconnor> what a strange error.
13:18:44 <lunarisbluemoon> HeHe says :)
13:19:17 <roconnor> oh
13:19:23 <Zao> J11: const  would satisfy your signature, but that's probably not what you intended.
13:19:23 <lunarisbluemoon> Sorry, irssi went a bit haywire.
13:19:28 <roconnor> Complex is broken
13:19:32 <roconnor> and doesn't work with CReal
13:19:55 <roconnor> some idiot wrote:
13:19:55 <mgee> roconnor: whaat? oh no
13:19:57 <roconnor> data  (RealFloat a) =>
13:19:58 <roconnor>        Complex a = !a :+ !a
13:19:59 <J11> I don't needs it's output, the function will change a state
13:20:00 <roconnor>                       deriving (Eq,Read,Show)
13:20:03 <roconnor> into the standard
13:20:10 * roconnor glares at Simon
13:20:16 <mgee> roconnor: so?
13:20:37 <roconnor> the :+ constructor requires that the parameters be RealFloat for no good reason.
13:20:46 <roconnor> @type (:+)
13:20:47 <lambdabot> forall a. (RealFloat a) => a -> a -> Complex a
13:20:51 <mgee> roconnor: oh no
13:20:56 <lunarisbluemoon> God bless '98 xD
13:21:16 <Saizan> roconnor: it's required for something in the instance of Num, iirc
13:21:25 <roconnor> oh?
13:22:10 <roconnor> I see
13:22:16 <roconnor> That's still stupid
13:22:28 <Zao> @type \a f -> a >>= \x -> f x >> pure x
13:22:29 <lambdabot> forall (m :: * -> *) a a1. (Applicative m, Monad m) => m a -> (a -> m a1) -> m a
13:22:30 <Zao> J11: Like that?
13:22:52 <roconnor> mgee: the solution is to write your own Complex module/type
13:22:58 <roconnor> mgee: and use that instead
13:23:29 <Zao> @type \a f -> do { x <- a ; f x ; pure x }
13:23:31 <lambdabot> forall (m :: * -> *) b a. (Monad m, Applicative m) => m b -> (b -> m a) -> m b
13:23:35 <Zao> Or if you want to use fancy sugar :)
13:23:54 <J11> yes looks like it
13:23:56 <mgee> roconnor: I just discovered another CReal: http://darcs.augustsson.net/Darcs/CReal/ (this has an instance Num)
13:24:24 <roconnor> mgee: you can probably just copy the Complex module from the report and fix it.
13:24:31 <roconnor> mgee: that is the CReal I was thinking of.
13:24:56 <mgee> roconnor: first I try to use that other CReal... this way I also get rid of the mpfr dependency
13:25:19 <roconnor> oh
13:25:38 <roconnor> mgee: right, I think that Augustsson's CReal might have a stupid RealFrac instance.
13:26:17 <roconnor> I guess that is another solution, write a RealFrac instance for your CReal.  I don't like that idea much myself.
13:26:36 <mgee> ^^
13:27:24 <Geheimdienst> hey guys, i got a newbie question
13:27:34 <roconnor> instance RealFloat CReal where
13:27:36 <roconnor>   floatRadix _ = error "CCeal.floatRadix"
13:27:37 <roconnor> ...
13:27:40 <Geheimdienst> i'm seeing a linker error when compiling
13:28:25 <Geheimdienst> about 20 errors like this: t.o: In function `rWb_info':
13:28:25 <Geheimdienst> (.text+0xaa): undefined reference to `mtlzm1zi1zi0zi0_ControlziMonadziError_zdf13_closure'
13:28:35 <Saizan> Geheimdienst: use --make
13:28:44 <Zao> Or -package whatever
13:29:02 <Geheimdienst> you mean ghc --make ?
13:29:11 <roconnor> CReal really ought not to be an instance of RealFloat.
13:29:11 <Zao> Or cabal, which concocts a nice command line from the packages listed in the .cabal file.
13:29:14 <Zao> Geheimdienst: YEs.
13:29:25 <roconnor> > magnitude (1:+1) :: CReal
13:29:26 <lambdabot>   1.4142135623730950488016887242096980785697
13:29:41 <Geheimdienst> ok great, that fixed it :-)
13:29:42 <roconnor> but it seems to work
13:29:47 <Geheimdienst> thanks a ton
13:30:09 <lunarisbluemoon> So guys, excuse me asking again - will a state monad cost me a lot of speed?
13:32:49 <dons> Haskell Platform testing time: http://projects.haskell.org/pipermail/haskell-platform/2009-June/000411.html
13:32:53 <Saizan> lunarisbluemoon: it can cost some speed, yes, a way to make it faster is using the monad-ran package, however it depends on the use-case
13:33:03 <dons> If you're on windows: check this installs, and let me no YES/NO: http://code.haskell.org/~refold/HaskellPlatform-2009.2.0.1-rc2-setup.exe
13:33:09 <dons> Unix, same story,  http://haskell.org/~duncan/haskell-platform-2009.2.0.1.tar.gz
13:33:34 <dons> note: the windows installer will install GHC on your   system
13:34:11 <lunarisbluemoon> Saizan: Thanks; also should I be worried about using mutable arrays (IOArray for example)?
13:35:25 <roconnor> lunarisbluemoon: the state monad does exactly the same thing as manually threading the state through your code.  It simply provides combinators that make doing so easier.
13:36:01 <lunarisbluemoon> roconnor: That makes sense, I'm just worried I'm making stupid errors.
13:36:05 <roconnor> lunarisbluemoon: to answer if this is slow, I need to know what this is opposed to doing.
13:36:06 <lunarisbluemoon> Since I'm way off getting the C speed.
13:36:33 <lunarisbluemoon> roconnor: At the top level it's replacing having globals in C.
13:36:42 <lunarisbluemoon> (I never said it was a nice benchmark :)
13:37:00 <Saizan> lunarisbluemoon: large mutable arrays have poor GC performance currently
13:37:06 <mm_freak> is there any way to easily parse any reasonable date/time string?
13:37:15 <mm_freak> no specific format, that is
13:37:18 <lunarisbluemoon> Saizan: I see; thanks for your help.
13:37:48 <lunarisbluemoon> mm_freak: I only know of the parsedate package; not sure if it does what you want.
13:38:18 <lunarisbluemoon> Afaik I think you need to give it a format string though.
13:38:22 <lunarisbluemoon> :/
13:38:28 <mm_freak> Date.Time.Format has the parseTime function, but it asks for a specific format "with some variations allowed"
13:39:24 <paper_cc> mm_freak: well, you won't be able to tell MM/DD/YYYY from DD/MM/YYYY in some cases anyway =)
13:39:48 <mm_freak> hmm, then i
13:39:58 <mm_freak> hmm, then i'll accept specific formats only =)
13:41:55 <roconnor> ISO 8601 FTW!
13:41:58 * paper_cc lives in Russia and has great trouble understanding US dates formatted as MM/DD
13:42:37 <Zao> Big-endian padded dates are nice.
13:42:40 <Zao> Sorts well too.
13:43:31 <riddochc> Right, so... now that I'm in front of my computer, I can see from ghci what (,) does.  It wasn't obvious from when it's first used in the monads chapter of real world haskell.
13:44:21 <riddochc> I'm running into a surprisingly large number of things in the real world haskell book, showing up in the code but never get explained.
13:46:27 <riddochc> In the logger example, for the regexes, I can't find any definition for the execLogger aka runLogger function.
13:46:28 <paper_cc> @where LYAH
13:46:28 <lambdabot> www.learnyouahaskell.com
13:46:45 <paper_cc> @ty runWriter
13:46:46 <lambdabot> forall w a. Writer w a -> (a, w)
13:47:04 <paper_cc> riddochc: Logger is a Writerish thing?
13:48:58 <riddochc> paper_cc: It says it's a "specialized version of the standard Writer monad" but it doesn't elaborate on that for another 50 pages, and I haven't gotten that far yet.
13:49:18 <paper_cc> @where RWH
13:49:18 <lambdabot> is http://www.realworldhaskell.org/blog/
13:50:39 <riddochc> paper_cc: Yeah, I haven't looked at what's on the site very carefully, I'm working through the dead-tree version from the library.
13:52:57 <mgee> Ok now I got it nearly working! Just one thing missing. CReal is missing the Random instance. So I wanted to add one and let is just wrap around the Double Random instance. I use this code: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2538#a2538
13:53:00 <paper_cc> the @where was for me =)
13:53:00 <paper_cc> riddochc: the logger example starts with "We'll intentionally keep the internals of the Logger module abstract." and section title "Information hiding"
13:53:04 <mgee> the error is also in the paste
13:53:32 <mgee> I know that the right side will evaluate to a double value. but if i use read $ random ... I get errors tooo... :( so,ebopdy know why?
13:54:09 <paper_cc> @ty randomR
13:54:10 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> (a, g)
13:54:30 <mgee> Here is the paste with the read $ and the new errors: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2539#a2539
13:54:42 <riddochc> Hmm.  Seems several other people had the same confusion I have - see comments on first paragraph of "Using a new monad: show your work!"
13:54:52 <paper_cc> @instances RandomGen
13:54:53 <lambdabot> Couldn't find class `RandomGen'. Try @instances-importing
13:55:15 <Saizan> ?type random
13:55:16 <lambdabot> forall g a. (Random a, RandomGen g) => g -> (a, g)
13:55:34 <Saizan> mgee: ^^^ the argument is the generator
13:55:47 <mgee> ah oh
13:55:52 <paper_cc> mgee: well, Double is not an instance of RandomGen
13:55:57 <Saizan> mgee: not of the type of value you want to generate
13:56:03 <paper_cc> @instances-importing System.Random RandomGen
13:56:04 <lambdabot> StdGen
13:56:30 <mgee> paper_cc: mhh... so how would i wrap my instance around the random instance of double?
13:56:37 <Saizan> so you need something like random g = let (d,g') = random g in (read $ show d,g')
13:56:55 <sjanssen> Saizan: or just fromRational?
13:56:56 <mgee> Saizan: ah ok. I will try
13:57:05 <paper_cc> sjanssen: or realToFrac?
13:57:12 <Saizan> sjanssen: yeah, i was going to suggesting some other conversion
13:57:19 <sjanssen> paper_cc: yeah, that's the one I meant
13:57:24 <Saizan> but i'm not sure what works for Double -> CReadl
13:57:50 <Saizan> *CReal
13:58:12 <sjanssen> > realToFrac (1 :: Double) :: CReal
13:58:12 <refold>  /quit
13:58:13 <lambdabot>   1.0
13:59:53 <riddochc> Hey, cool!  My 2:00 AM idea has actually already been looked into - I had the idea that doing things with monads is like working with variations on progn in lisp.
13:59:54 <fynn> Hey.
13:59:55 <fynn> What's the equivalent of optparse for Haskell?
14:00:33 <fynn> (A library like Python's optparse, for parsing command-line arguments)
14:01:38 <trofi> @hoogle getOpt
14:01:39 <lambdabot> System.Console.GetOpt getOpt :: ArgOrder a -> [OptDescr a] -> [String] -> ([a], [String], [String])
14:01:39 <lambdabot> module System.Console.GetOpt
14:01:39 <lambdabot> System.Console.GetOpt getOpt' :: ArgOrder a -> [OptDescr a] -> [String] -> ([a], [String], [String], [String])
14:01:41 <kynky> ts a string, just parse it ?
14:02:11 <paper_cc> @hackage parseargs
14:02:11 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/parseargs
14:02:14 <JamesSanders> Saizan: any good (src code) examples of hspread in use
14:03:56 <fynn> trofi: so, System.Console.GetOpt should actually be in any 98-compliant Haskell implementation?
14:04:33 * trofi googles getopt page to read portability section
14:04:39 <paper_cc> s/98-compliant/H'98-with-hierachical-modules-compliant/ at lease
14:04:43 <paper_cc> *at least
14:05:09 <trofi> Portability	portable
14:05:09 <trofi> Stability	experimental
14:05:30 <trofi> http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-Console-GetOpt.html
14:06:00 <hackagebot> BoundedChan 1.0.0.2
14:06:12 <paper_cc> cabal-install and darcs use their own custom parsers anyway
14:06:27 <mgee> Saizan: that works nearly... http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2539#a2540 sorry it seems like I am a bit slow today. I tried adding ::Double and ::CReal in some places but it didn't help
14:06:50 <trofi> GetOpt.hs does not have any special exts
14:07:51 <gwern> trofi: I suspect the stability is experimental because getopt is fairly hard to figure out
14:08:08 <mgee> Saizan: i solved it :)
14:08:14 <gwern> I had a dickens of a time working getopt out when I was trying to add real options to mueval
14:08:25 <idnar> getopt is bad enough in C, why would you inflict it on yourself in Haskell?
14:08:40 <Igloo> idnar: What would you recommend instead?
14:08:47 <tibbe> is it possible import macros using hsc2hs?
14:08:51 <gwern> Igloo: ad hoc parsing using drop and take!
14:08:57 <BONUS> what's that library that draws data structures
14:09:01 <BONUS> how they point to each other etc
14:09:08 <gwern> BONUS: graphvzi
14:09:09 <fynn> trofi: thanks.
14:09:11 <gwern> *viz
14:09:16 <fynn> paper_cc: you too.
14:09:18 <idnar> Igloo: I'm not exactly an expert on Haskell command line parsing libraries :/
14:09:21 <trofi> gwern: heh, true. i used C' getopt, then ruby's and then haskell's. it was not so intuitive w/o reading docs :]
14:09:23 <BONUS> i mean like the one where you pass it [1,2,3]
14:09:30 <kau> hello all! how to display a counter that increment itself every seconds (using the State monad)?
14:09:31 <BONUS> and it draws the cons' and stuff
14:09:34 <Igloo> BONUS: vacuum
14:09:39 <BONUS> ah vacuum, yeah
14:09:49 <gwern> oh, you meant live haskell datastructures
14:10:02 <paper_cc> BONUS: it's actually vacuum-graphviz || vacuum-ubigraph
14:10:02 <fynn> gwern, Igloo, idnar: so the general consensus is, it's getOpt or nothing?
14:10:02 <gwern> (graphviz can draw data structures. graphs, specifically)
14:10:08 * fynn misses Python :(
14:10:15 <gwern> fynn: well, there are a few obscure other approachs
14:10:19 <BONUS> ah :)
14:10:22 <gwern> fynn: but who knows what other packages lurk on hackage!
14:10:23 <kau> i can't figure it out with State
14:10:30 <paper_cc> fynn: there's something called parseargs on hackage
14:10:43 <fynn> gwern: there's this other one (yeah, parseargs) but it's self-designated Alpha
14:10:50 <Igloo> fynn: getOpt is the best solution I know of
14:11:12 <fynn> Igloo: cool. who knows, maybe we'll write an optparse port ourselves
14:11:35 <fynn> we're going to be possibly the first commercial entity to release open source Haskell libraries... exciting
14:11:49 <gwern> fynn: may not mean much. secretly, haskellers believe a package is only out of alpha/beta when the code is written in coq and compiled to haskell, and has been firetested by the nsa
14:12:00 <gwern> fynn: sorry, but galois at least beat you to the punch by years
14:12:18 <fynn> gwern: well, 2nd place is pretty good too ;)
14:12:31 * gwern stares at shoes. no, not there either
14:12:40 <kau> nobody has got an idea for my problem?
14:13:06 <paper_cc> kau: you can't do that
14:13:22 <gwern> kau: where would the state monad get 'seconds' from?
14:13:22 <kau> yes we can!
14:13:31 <fynn> gwern: we're getting this guy to work in Haskell sort of full time. I'm a bit concerned that there's no large, open-source Haskell codebases out there that commercial entities depend on
14:13:54 <fynn> I hope we won't discover down the road that it's because there are huge problems we can't foresee right now.
14:14:01 <gwern> fynn: I'd say that just about every commercial entity depending on haskell also depends on that large open-source codebase we call ghc
14:14:22 <fracture> is wxHaskell supposed to be good enough for real use?  (it's randomly crashing and sometimes giving error dialog boxes about loading comctrl32.dll for me)
14:14:23 <fynn> well, the thing is there's no visibility to those applications.
14:14:52 <kau> gwern: there is threadDelay?
14:14:59 <gwern> kau: but that's up in the IO monad
14:15:00 <fynn> gwern: like, in Python, everything depends on CPython, so I can go "yeah, Google Groups and YouTube and a million Django websites are fire-testing CPython daily"
14:15:14 <Hunner> If I have a (String -> IO ()) and I want to apply it to a [String], what am I looking for?
14:15:14 <riddochc> Is there a good list of larger apps written in Haskell?
14:15:41 <gwern> fynn: galois does high-performance, high security programs & libraries for government etc. and dons who works there tells me they're happy with ghc
14:15:45 <fynn> with Haskell it's "there are rumored to be some super-secret Haskell stuff done by Galois for the nsa or something, but you need top-secret clearance to even know about it"
14:15:46 <Zao> @src mapM_
14:15:47 <lambdabot> mapM_ f as = sequence_ (map f as)
14:15:52 <Zao> @type mapM_
14:15:53 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
14:15:55 <gwern> Hunner: mapM
14:15:59 <Hunner> thanks
14:16:07 <kau> i would like my program to just output the number of seconds since it started, never ending...
14:16:17 <Zao> As your function yields IO (), you probably don't care about the result, so mapM_
14:16:21 <roconnor> Hunner: mapM_
14:16:23 <Zao> mapM is when you want a list of the results.
14:16:23 <travisbrady> fynn: did you see "Commercial Uses: Going functional on exotic
14:16:23 <travisbrady> trades
14:16:27 <gwern> fynn: nah, they're released stuff like cryptol which are pretty darn big
14:16:29 <travisbrady> woops
14:16:32 <Hunner> Yeah, saw that difference. Thanks guys
14:16:42 <fynn> travisbrady: nope
14:16:46 <paper_cc> kau: when you have time, it's either IO or FRP. State is pure so you can't use it
14:16:47 <gwern> fynn: and travisbrady is linking you to a paper whose compiler/dsl was about 30k lines iirc
14:16:58 <kau> gwern: oh
14:17:01 <travisbrady> fynn: http://www.google.com/url?sa=t&source=web&ct=res&cd=3&url=http%3A%2F%2Fwww.lexifi.com%2Fdownloads%2Ffrankau.pdf&ei=wpYlSrzWI6eWswOxmozIBg&usg=AFQjCNGTOcU4y7JhznjELS76oxBpn9dweg&sig2=iR9U9TP98Zq7BATc1_ZD3Q
14:17:13 * Hunner wonders why mapM_ is the name of the function and not mapM'
14:17:24 <travisbrady> ugh, woops again: www.lexifi.com/downloads/frankau.pdf
14:17:30 <Raevel> @hoogle mapM
14:17:30 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
14:17:30 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
14:17:30 <lambdabot> Data.Traversable mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
14:17:33 <Zao> Hunner: It owes it to sequence_. Now where that got the underscore from...
14:17:43 <gwern> kau: if you just want that, then your program will look something like 'main = main' 0; main' x = print x >> main' (x+1)'
14:17:43 <paper_cc> @ty sequence'
14:17:44 <lambdabot> Not in scope: `sequence''
14:17:46 <Botje> Hunner: maybe because it resembles _ in pattern matching?
14:17:50 <Raevel> oh i can't read
14:17:58 <Zao> Hunner: Probably related to how you use _ to skip binding pattern matches.
14:18:21 <gwern> kau: and if you want every second, it'd be like 'threadDelay 1000 >> print x >> main' (x+1)', if you follow
14:18:31 <kau> gwern: OK super
14:18:43 <fynn> travisbrady: cool, thanks
14:18:44 <Zao> > let f _ _ = "lol" in f 42 3
14:18:45 <lambdabot>   "lol"
14:18:56 <gwern> I can never remember, is it threadDelay 100 that is a second, or threadDelay 1000...
14:19:01 <fynn> gwern: we're still sort of pioneering here. well, I guess it's also exciting.
14:19:05 <jmcarthur_work> 1000000
14:19:07 <Berengal> gwern: 10^6
14:19:09 <kau> gwern: can i use map to remove the recursion?
14:19:51 <eu-prleu-peupeu> hello
14:19:58 <O_4> kau: why would you want to?
14:20:00 <gwern> kau: not really. you're thinking something like 'main = map (\x -> threadDelay 1000 >> print x) [1..]', right?
14:20:18 <paper_cc> @ty repeat
14:20:19 <kau> gwern: exactly
14:20:19 <lambdabot> forall a. a -> [a]
14:20:21 <gwern> kau: but there's no guarantee that this will perform the way you think it will
14:20:24 <Zao> @type sequence_ $ repeat $ threadDelay 1000
14:20:26 <lambdabot> Not in scope: `threadDelay'
14:20:30 <Zao> @type sequence_ $ repeat $ ?threadDelay 1000
14:20:31 <lambdabot> forall (m :: * -> *) a t. (Monad m, ?threadDelay::t -> m a, Num t) => m ()
14:20:47 <gwern> kau: in theory, ghc could make it so that 1000 of those maps happen simultaneously. that's allowed
14:21:02 <paper_cc> gwern: sequence_ $ zipWith (>>) (threadDelay 1000000) (map print [1..]) -- won't this work?
14:21:18 <kau> gwern: oh, i guess some sort of strictness is needed here?
14:21:23 <Zao> gwern: Which would be harmless as threadDelay is an IO action, and all yours does is generate a list of actions.
14:21:24 <gwern> paper_cc: I don't know enough about sequence to say
14:21:31 <paper_cc> @src sequence
14:21:32 <lambdabot> sequence []     = return []
14:21:32 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
14:21:32 <lambdabot> --OR
14:21:32 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
14:21:35 <roconnor> paper_cc: I don't think that typechecks
14:21:52 <paper_cc> @ty threadDelay 1
14:21:53 <lambdabot> Not in scope: `threadDelay'
14:22:01 <Zao> paper_cc: Control.Concurrent
14:22:02 <Berengal> @type let threadDelay :: Int -> IO (); threadDelay = undefined in mapM_ (\x -> threadDelay 1000 >> print x) [1..]
14:22:04 <lambdabot> IO ()
14:22:39 <paper_cc> @type let threadDelay :: Int -> IO (); threadDelay = undefined in zipWith (>>) (threadDelay 1) (map print [1..])
14:22:40 <lambdabot>     Couldn't match expected type `[m a]' against inferred type `IO ()'
14:22:40 <lambdabot>     In the second argument of `zipWith', namely `(threadDelay 1)'
14:22:40 <lambdabot>     In the expression:
14:22:50 <gwern> now, a fold might work
14:22:52 <paper_cc> oh
14:22:55 <Berengal> @src sequence_
14:22:56 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
14:23:02 <gwern> oh :)
14:23:12 <jmcarthur_work> heh
14:23:14 <Berengal> @src sequence
14:23:14 <lambdabot> sequence []     = return []
14:23:14 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
14:23:14 <lambdabot> --OR
14:23:14 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
14:23:26 <mgee> Is it in Haskell impossible to use a Complex Number with arbitrary precision? I think so because the Complex Type requires the RealFloat instance. And this instance want decodeFloat and encodeFloat, which is not possible for a real with arbitrary precision, right?
14:23:46 <rubendv> paper_cc: do a repeat on the threadDelay
14:23:52 <paper_cc> roconnor: it should be (repeat $ threadDelay 1000000), sorry
14:23:52 <Berengal> mgee: Write your own Complex type
14:23:54 <gnuvince_> @index comparing
14:23:55 <lambdabot> bzzt
14:23:55 <rubendv> zipWith needs two lists
14:23:57 <roconnor> mgee: unless you give make a "fake" RealFloat instance, yes
14:24:10 <ray> encodeFloat = error "floats suck"
14:24:29 <roconnor> mgee: this is what numbers package does.
14:24:32 <mgee> yeah then my programm terminates
14:24:37 <jmcarthur_work> :t (1 :: CReal) :+ 2
14:24:39 <lambdabot> Complex CReal
14:25:04 <fynn> paper_cc: what does "with compliant hierarchal modules" mean?  what kind of a standard is that?
14:25:10 <paper_cc> @ty let threadDelay = undefined :: Int -> IO (); print = undefined :: (Show a) => a -> IO () in sequence_ $ zipWith (>>) (repeat $ threadDelay 1) (map print [1..])
14:25:11 <lambdabot> IO ()
14:25:13 <mgee> Mhh so I have to find the function which is causing the encodeFloat to be called, right?
14:25:19 <roconnor>   decodeFloat _ = error "CReal.decodeFloat"
14:25:21 <roconnor>   encodeFloat _ _ = error "CReal.encodeFloat"
14:25:27 <kau> sequence $  map (\x -> threadDelay 1000000 >> print x) [1..] works fine!!
14:25:32 <roconnor> this is how numbers defines those functions for CReal.
14:26:02 <gwern> fynn: it means that one could do 'import Data.List' instead of 'import List'
14:26:12 <Berengal> kau: 'seuqence . map' is called mapM, and 'sequence_ . map' is called mapM_, just FYI
14:26:22 <gwern> fynn: otherwise you basically have a flat module hierarchy - no nesting
14:26:24 <roconnor> mgee: Complex uses magnitude which uses scaleFloat and exponent for precision.
14:26:28 <paper_cc> fynn: the hierachical modules addendum (IO -> System.IO, Random -> System.Random etc)
14:26:30 <roconnor> @src magnitude
14:26:30 <lambdabot> Source not found. Maybe if you used more than just two fingers...
14:26:39 <kau> Berengal: tks
14:26:42 <roconnor> @type magnitude
14:26:44 <lambdabot> forall a. (RealFloat a) => Complex a -> a
14:26:44 <gwern> fynn: the hierarchical module is an addition to the haskell '98 standard
14:26:44 <Berengal> kau: Also note that it will never return, so using 'sequence' over 'sequence_' is a space leak
14:26:47 <mgee> roconnor: ah ok. I saw some code piece which used magnitude
14:26:49 <roconnor> src is so random
14:27:03 <mgee> roconnor: thanks
14:28:08 <kau> i first asked this question to me reading the State monad chapter from RWH
14:28:09 <fynn> gwern, paper_cc: OK, so the 3 levels of standards are: 1) Core '98,  2) standard additions to the '98 standard (where are those defined?),  3) platform-specific extensions, defined ad-hoc by the extender (I understand GHC has a ton of those)
14:28:18 <kau> indeed i understood quite nothing
14:28:48 <kau> is this example re-writable with State?
14:28:55 <paper_cc> fynn: really I'm not much into this, but at least there are 1) the FFI addendum and 2) the hierachical modules addendum
14:29:02 <paper_cc> kau: no
14:29:03 <gwern> fynn: I'd add the common subset of platform-specific extensions between ghc/hugs/yhc as 3.5
14:29:11 <gwern> CPP, for example. I think everyone has CPP
14:29:25 <paper_cc> kau: time is an impure thing
14:29:39 <kau> but State is monadic!
14:29:50 <paper_cc> kau: Maybe is monadic too
14:29:54 <kau> i figured out that monads where for impure things ;)
14:30:02 <paper_cc> kau: nope
14:30:11 <gwern> kau: monads are mu!
14:30:19 <kau> a state is impure?
14:30:29 <paper_cc> kau: State, Writer, Reader, Maybe are perferctly pure
14:30:31 <Cale> kau: That's only part of what they're good for.
14:30:36 <gwern> do not ask what monads are; let monads ask what you are
14:30:37 <kau> yes
14:30:42 <Cale> heh
14:30:44 <gnuvince_> Is it normal that with a very large list (235,000 words) the following code overflows the stack: maximumBy (comparing length) myWords
14:30:53 <gnuvince_> (unless I compile with -O2)
14:30:57 <Cale> gnuvince_: yeah
14:30:57 <ray> do not use monads, use haskell
14:31:08 <gwern> realize the truth: there is no monad.
14:31:16 <paper_cc> kau: a state emulates a mutable state, but there's no mutability inside it
14:31:19 <ray> there is only Monad
14:31:20 <Heffalump> @src maximumBy
14:31:20 <lambdabot> Source not found. That's something I cannot allow to happen.
14:31:27 <Heffalump> @src Data.List.maximumBy
14:31:27 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
14:31:34 <mux> monads hide side effects under the carpet.
14:31:37 <paper_cc> kau: s/a state/the State/
14:31:40 <gnuvince_> Cale: to much thunking?
14:31:43 <gnuvince_> *too
14:32:03 <Heffalump> it's a foldl, is the problem
14:32:04 <Cale> gnuvince_: The problem is that without optimisations, strictness analysis isn't done, and a large expression is constructed consisting of all the elements of the list combined with a max-type function.
14:32:07 <Heffalump> so not designed for lazy things like that
14:32:30 <paper_cc> kau: State s a is just a fancy way to write a function s -> (s, a) which is perfectly pure
14:32:36 <Cale> gnuvince_: Finding a reducible subexpression in that is what causes the stack to overflow.
14:32:45 <kau> imaging you receive input from time to time from the user, and you have to compare each inputs to others, would you use State?
14:32:48 <Heffalump> why is sum a foldl?
14:33:02 <Cale> There really ought to be a sum'
14:33:11 <Cale> and a maximumBy' and all those.
14:33:38 <conal> time needn't be modeled impurely.
14:33:38 <Cale> Though, strictness analysis is good enough now that it usually finds this sort of thing.
14:33:41 <Zao> let maximumBy' = tickify maximumBy
14:33:59 <Zao> The implementation of tickify is left as an exercise for the reader.
14:34:10 <ray> compiler magic
14:35:59 <paper_cc> conal: well, is there a way to access time other than doing some IO?
14:36:09 <kau> the State monad is a mystery for me ;)
14:37:17 * gwern has a sudden vision of 50 years from now. people will be writing webpages like 'The Road to FRP', and creating motivational posters of conal which read 'programming: ur doing it rong', and the mainstreamers will be looking up from their GADT design patterns and deriding those FRPers
14:37:33 <roconnor> @src State
14:37:33 <lambdabot> Source not found. Just try something else.
14:37:35 <Berengal> kau: The State monad is just regular code, except it carries one extra value around for you behind the scenes. You can read this value as you wish, and exchange it for a new value in the remaining computation
14:38:18 <gwern> @quote state
14:38:18 <lambdabot> state says: ?. ++ . read . show . state ?. ++ . read . show . state
14:38:24 <kau> Berengal: i see
14:38:29 <gwern> @quote state
14:38:29 <lambdabot> state says: ?. ++ . read . show . state ?. ++ . read . show . state
14:38:33 <conal> gwern: :)
14:38:45 <gwern> I'm tempted to delete that quote because it makes no sense whatsoever
14:38:53 <gwern> @hoogle (?.)
14:38:54 <lambdabot> No results found
14:39:20 <roconnor> kau: the state monad just offers a better way of writing f s x = y where {(s1,y1) = foo s x; (s2,y2) = bar s1 y1; (s3,y3) = baz s2 y2; (s4,y) = quux s3 y3}
14:39:41 <conal> paper_cc: yeah.  check out frp.
14:40:16 <paper_cc> conal: well, the interface is pure, but there's still IO under the hood
14:40:34 <Heffalump> paper_cc: that's true of any Haskell code
14:40:40 <conal> paper_cc: there's IO under the hood of 2+3
14:40:45 <Heffalump> it's just hidden by the compiler rather than by unsafePerformIO
14:40:49 <kau> ok, then there is no possibility to hold a state through time (during a certain amout of time)?
14:41:16 <roconnor> kau: time is not really relvent to state.
14:41:24 <Berengal> kau: Not with State
14:41:30 <roconnor> kau: depending on what you mean by time.
14:41:32 <conal> all of functional programming is implemented via unsafePerformIO (by some name).
14:41:49 <Twey> Ergo, unsafePerformIO is a compiler hook, not a part of Haskell.
14:41:55 <kau> Berengal with what instead?
14:42:08 <conal> Twey: indeed!
14:42:24 <gwern> IO? in *my* 2+3?
14:42:51 <augustss> gwern: not in your 2+3, because you never see the result :)
14:43:03 <Berengal> kau: There are IORefs, which are mutable references living in the IO monad
14:43:04 <Twey> Hehe
14:43:09 <paper_cc> > let 2+3 = "IO" in 2+3
14:43:10 <lambdabot>   "IO"
14:43:12 <gwern> augustss: dang it, you were supposed to say 'it's more likely than you think!'
14:43:17 <conal> i mean things like side-effecting registers.
14:43:18 <kau> roconnor: say user inputs
14:43:25 <kau> Berengal: oh
14:43:36 <Twey> > let 2+3 = print "hi" in 2+3
14:43:37 <lambdabot>   <IO ()>
14:43:50 <SubStack> what
14:43:55 <jkramer> Hello, I have another newbie question
14:44:08 <augustss> > let 2+3 = "Hello" in 2+3
14:44:09 <lambdabot>   "Hello"
14:44:14 <kau> Berengal: thats the way to do it? i missed that! ;)
14:44:15 <gwern> SubStack: it's lambdabot's l33t security measures
14:44:16 <jkramer> When I have a rather complex data type and I want to change a single element
14:44:43 <jkramer> Is there a nice way to do it or should I make a constructor that copies all the other values and only sets the one I change?
14:44:46 <SubStack> I am more boggled by the ability to define 2+3 like that
14:44:51 <Berengal> > let 2+2 = 5; a+b = a - (-b); fibs = 1:1:zipWith (+) fibs in sum (take 10 fibs)
14:44:52 <lambdabot>   Couldn't match expected type `[t]'
14:44:56 <Berengal> :/
14:45:08 <Berengal> kau: That's one way to do it
14:45:08 <jmcarthur_work> jkramer, look into records?
14:45:12 <byorgey> jkramer: there is a nice way to do it if you have given the elements of the structure names using record syntax.
14:45:13 <sjanssen> jkramer: you can use record syntax
14:45:14 <BONUS> or zippers
14:45:24 <byorgey> i.e. data Foo = { x :: Int, y :: Double, z :: Char }
14:45:41 <kau> jkramer: there is someting like let a = rec { foo = "toto"}
14:45:42 <byorgey> jkramer: then if  f :: Foo, you can change just the x field of f by  f { x = 6 }
14:45:57 <roconnor> jkramer: also see the Data.Accessor package.
14:46:31 <jkramer> If record syntax is the :: Type-stuff then I'm already using it :)
14:47:11 <gwern> no, records are more like {}
14:47:28 <jkramer> Like: data Foo = Foo { something :: String } deriving ...
14:47:37 <paper_cc> jkramer: that's it
14:47:39 <byorgey> yup, that's record syntax
14:47:42 <jkramer> \o/
14:47:49 <byorgey> jkramer: as opposed to just   data Foo = Foo String
14:48:14 <Axman6> jkramer: nice thing about it is you can still pattern match on those datatypes too
14:48:39 <paper_cc> jkramer: you can then write things like \(foo :: Foo) -> foo { something = "changedValue" }
14:49:16 <jkramer> I'll try it, wait a second :)
14:49:18 <Axman6> so you can have data Vec = V {x,y,z :: Double}, and you can still have a function f :: Vec -> Double; f (V a b c) = a + b + c
14:49:25 <Jedai> Axman6: and contruct them the same way you always did... In fact record syntax is more or less just syntax sugar over algebraic data types
14:49:34 <Axman6> yup
14:50:07 <BONUS> do {handle <- ContT $ withFile "foo.txt" ReadMode; lift $ putStrLn "blah"; ...
14:50:12 <BONUS> learned this trick today here
14:50:14 <BONUS> pretty cool :]
14:50:21 <Axman6> so you can also say V 1.0 2.5 3.7, which is the same as V { x = 1.0, y = 2.5, z = 3.7}
14:50:21 <Jedai> but you can also do "f (V {y = yv}) = yv + 3
14:50:39 <BONUS> never thought of withFile as returning a CPS transformed value
14:50:40 <Axman6> :o
14:50:55 <paper_cc> @ty ContT
14:50:56 <lambdabot> forall a (m :: * -> *) r. ((a -> m r) -> m r) -> ContT r m a
14:51:08 <paper_cc> wow
14:51:13 <kau> are "IOref" academic? i didn't came across it since i began with haskell that's why i'm asking lol
14:51:29 <paper_cc> @google Monadic state transformers
14:51:29 <Jedai> What's funny is that with GHC at least, you can use the special pattern "Contructor {}" even with datatypes that don't use record syntax
14:51:30 <lambdabot> http://en.wikibooks.org/wiki/Haskell/Monad_transformers
14:51:32 <Axman6> kau: i don't understand what you mean
14:51:53 <kau> are IOref safe?
14:51:55 <jkramer> Hmm, I don't completely get it. I have: updateSessionInput session newInput = UserSession { userInput = newInput }
14:51:56 <Axman6> they're pretty widely used, the OpenGL bindings use them a lot
14:52:10 <jkramer> Now I get a lot of warnings that everything but userInput is uninitialized
14:52:13 <jkramer> Did I mis something
14:52:14 <jkramer> ?
14:52:15 <Jedai> kau: IORef, academic ? IORef are pretty much like normal variables in imperative languages
14:52:24 <kau> and good programming style ;)
14:52:25 <Axman6> Jedai: replace the UserSession with session
14:52:32 <Jedai> kau: they're as "safe" as those always are
14:52:43 <O_4> s/Jedai/jkramer/
14:52:46 <jkramer> Yay, works!3! \o/
14:52:51 <jkramer> Thanks a lot :)
14:52:56 <Axman6> uh yeah, sorry. meant jkramer
14:53:02 <jkramer> I have no Idea where the 3! came from
14:53:39 <kau> Jedai, Axman6: ok i see
14:53:51 <Axman6> kau: MVars are far more interesting imo
14:54:10 <kau> Axman6: i'll have a look;)
14:54:25 <paper_cc> IORef -> MVar -> TVar -> ?
14:54:33 <Axman6> MVars let you do pretty safe and fast concurrency
14:54:45 <Axman6> TMvar ;)
14:56:40 <kau> i have to go, thanks a lot for your answers!!!
14:56:44 <conal> paper_cc: -> NoVar
14:56:45 <Axman6> kau: also, if you feel you need to use mtuable variables, check out the ST monad. it's basically the IO monad without all the dangerous stuff
14:57:50 <paper_cc> conal: -> Behavior ?
14:58:09 <conal> paper_cc: yeah!
15:02:28 <FunctorSalad> any ideas what this could be? "error: macro "hsc_const" passed 2 arguments, but takes just 1"
15:02:40 <FunctorSalad> (when running hsc2hs on something generated by hsffig)
15:03:19 <FunctorSalad> I know it's referring to a CPP macro, but why would it mismatch? :(
15:04:44 <Axman6> what's the macro?
15:05:08 <FunctorSalad> "hsc_const" - no idea what its purpose is
15:05:36 <FunctorSalad> some version mismatch of hsffig and hsc2hs?
15:05:52 <jkramer> Is there a nice way to check if there's input on a handle or EOF reached? hIsEOF seems to block until there's actually input or EOF, and if I do hWaitForInput first, it crashes when EOF is reached
15:07:07 <FunctorSalad> I don't know of a *nice* way, but you could run either isEOF in a seperate thread, or run hWaitForInput and catch the exception
15:07:44 <paper_cc> jkramer: maybe hReady?
15:08:15 <jkramer> paper_cc: I think hReady would crash on EOF too
15:08:23 * paper_cc opens ghci
15:08:26 <jkramer> FunctorSalad: How can I catch the exception?
15:08:33 <jkramer> paper_cc: At least it says so in the docs
15:08:35 <paper_cc> @hoogle catch
15:08:35 <lambdabot> package catch
15:08:36 <lambdabot> Prelude catch :: IO a -> (IOError -> IO a) -> IO a
15:08:36 <lambdabot> Control.Exception catch :: IO a -> Exception -> IO a -> IO a
15:09:59 <troutwine> Anybody have resources for stateful parsing with Parsec? (I'm parsing chess notation out of PGN files and would like the resulting AST to have absolute positioning.)
15:15:45 <troutwine> Ah, seems Parsec has an embedded user state. Nevermind, then.
15:15:50 <paper_cc> @ty \h -> (hReady h >> (return . Just)) `catch` (\e -> if isEOFError e then return Nothing else ioError e) -- the not-so-pretty way to solve jkramer's problem
15:15:51 <lambdabot> Not in scope: `hReady'
15:15:51 <lambdabot> Not in scope: `isEOFError'
15:17:49 <dons> The Haskell Platform 2009.2.0.1 release is live: be a little bit more awesome today: http://hackage.haskell.org/platform/
15:19:00 <sm> woot!
15:19:39 <FunctorSalad> if anyone cares, the offending expression generated by hsffig (on which hsc2hs chokes) was "#const( 2 ), #const( 2 )"
15:19:47 <dons> tell your friends. install haskell on their machines :)
15:19:53 <FunctorSalad> apparently the preprocessor misinterprets the comma?
15:20:10 <Badger> dons: or House? :P
15:21:28 <troutwine> dons: Is the Haskell Platform not installing on Arch a known issue (wants happy 1.18.2, system has 1.18.4)?
15:21:47 <sm> dons: are there release notes ? any word on the mac installer ?
15:22:17 <dons> troutwine: Arch isn't updated yet (look at the version)
15:22:22 <dons> working on it NOW, troutwine
15:22:36 <dons> sm, mac installer close. i'll put up some release notes.
15:22:49 <dons> http://trac.haskell.org/haskell-platform/wiki/2009.2#CandidatesforUpgradein2009.2.0.1
15:22:51 <sm> fantastic, thanks a lot for working on this
15:22:53 <dons> release notes ^^
15:23:05 <sm> this = HP
15:23:12 <troutwine> dons: Woops, quite true. My apologies.
15:26:36 <olsner> @oeis 1 2 145 40585
15:26:36 <lambdabot>  Factorions: equal to the sum of the factorials of their digits in base 10.
15:26:36 <lambdabot>  [1,2,145,40585]
15:28:19 <ziman> @oeis 33 37 88
15:28:20 <lambdabot>  Sequence not found.
15:29:18 <olsner> @oeis 1 2 75
15:29:18 <lambdabot>  GCD of n and the product of the anti-divisors of n.
15:29:18 <lambdabot>  [1,1,1,2,1,1,3,2,1,4,1,2,15,1,1,6,1,4,21,2,1,8,5,2,27,4,1,30,1,1,33,2,35,12,...
15:29:35 <gnuvince_> @oeis 1 2 3
15:29:37 <lambdabot>  Fibonacci numbers: F(n) = F(n-1) + F(n-2), F(0) = 0, F(1) = 1, F(2) = 1, ...
15:29:37 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
15:29:42 <lament> @oeis 1 1 1
15:29:43 <lambdabot>  Pascal's triangle read by rows: C(n,k) = binomial(n,k) = n!/(k!*(n-k)!), 0<=...
15:29:43 <lambdabot>  [1,1,1,1,2,1,1,3,3,1,1,4,6,4,1,1,5,10,10,5,1,1,6,15,20,15,6,1,1,7,21,35,35,2...
15:29:45 <gnuvince_> @oeis 1 2 3 4 5
15:29:46 <lambdabot>  The natural numbers. Also called the whole numbers, the counting numbers or ...
15:29:46 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
15:30:33 <Axman6> @oeis 1 2 3 4 3 2 3 4 5 7
15:30:34 <lambdabot>  Sequence not found.
15:31:26 <olsner> @oeis 1 2 75 6 7
15:31:26 <lambdabot>  A common Swedish drinking song.
15:31:26 <lambdabot>  [1,2,75,6,7,75,6,7,75,6,7,1,2,75,6,7,75,6,7,73,107,103,102,107,6,19,27,17,18...
15:31:29 <olsner> :)
15:31:38 <idnar> haha
15:31:48 <sclv_> !?
15:31:50 <peanuts> quick question: what's the best way to access the ith element of a list?
15:32:07 <gnuvince_> > [1,2,3,4,5] !! 3
15:32:08 <olsner> > [1,2,3] !! 2
15:32:09 <lambdabot>   4
15:32:09 <lambdabot>   3
15:32:57 <peanuts> i see thx
15:33:09 <gnuvince_> peanuts: that's O(n) though
15:33:15 <gnuvince_> (linked lists and all)
15:33:42 <peanuts> it's a short list, so shouldn't be too bad
15:34:28 <gnuvince_> ok
15:34:39 <gnuvince_> Just thought I'd mention it
15:34:44 <olsner> sclv: it is indeed :) most people use the "lyrics" while singing it though, the ending is kind of hard to remember (17, 18, 16, 15, 13, 19, 14, 17, 19, 16, 15, 11)
15:35:23 <gnuvince_> @oeis 4 8 15 16 23
15:35:23 <lambdabot>  Nonprime number of 1's in binary expansion (complement of A052294).
15:35:24 <lambdabot>  [1,2,4,8,15,16,23,27,29,30,32,39,43,45,46,51,53,54,57,58,60,63,64,71,75,77,7...
15:35:31 <dons> troutwine: updated.
15:35:39 <dons> troutwine: though haskell-http in pacman needs tweaking
15:36:32 <mgsloan> how does one compose lambdabot commands, again?
15:36:51 <mgsloan> i remember that used to be popular
15:36:55 <mgsloan> or maybe I'm crazy
15:40:37 <troutwine> dons: Thanks.
15:41:42 <yairchu> weird mystery I have: I make my program with -O2 and its memory usage skyrockets, without -O2 it runs fine..
15:42:40 <Cale> THat sounds like a GHC bug. What GHC are you using?
15:43:02 <yairchu> Cale: 6.10.2
15:43:17 <sclv_> -fno-state-hack?
15:43:27 <yairchu> what is that?
15:43:33 <mgsloan> @. oeis run concat $ intersperse " " $ map show $ [1,3..15]
15:43:35 <lambdabot>  The odd numbers: a(n) = 2n+1.
15:43:35 <lambdabot>  [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
15:44:33 <paper_cc> @run [1..10]
15:44:34 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
15:44:50 <paper_cc> @oeis
15:44:50 <lambdabot> Plugin `oeis' failed with: Math/OEIS.hs:316:10-40: Irrefutable pattern failed for pattern ('%' : c : _, rest)
15:45:03 <paper_cc> ahem
15:45:21 <mgsloan> @. vixen compose oeis run concat $ intersperse " " $ map show $ [1,3..15]
15:45:22 <lambdabot> I'm your huckleberry
15:45:27 <Cale> yairchu: My guess is that something which uses lots of memory is accidentally getting lifted up and computed/defined at a higher level. This means that it won't be recomputed over and over, but also means that it will never go out of scope, so it will consume memory forever.
15:45:32 <yairchu> sciv_: with -fno-state-hack it has same behaviour (memory usage explodes)
15:46:04 <Cale> If that's the case, then it's definitely possible to call it a bug.
15:46:28 <Cale> (In general, if you turn on optimisations and they harm performance, it's considered a bug)
15:47:08 <Cale> yairchu: Is your program simple enough to paste somewhere?
15:47:19 <mgsloan> @. elite compose oeis run concat $ intersperse " " $ map (show.(^2)) $ [1,3..15]
15:47:21 <lambdabot> 0Dd 5QuaR35: (2n+1)^2. AL50 C3n73R3D o(ta9Ona1 Nu/\/\BeR$. [1,9,25,49,81,121,169,225,289,361,441,529,625,729,841,961,1089,1225,1369,152...
15:47:21 <yairchu> I'm doing it right now. one sec
15:48:45 <yairchu> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5511
15:50:57 <Cale> How long should I have to wait to see lots of space usage?
15:51:20 <yairchu> not much
15:51:36 <yairchu> I killed it after 6 seconds last time
15:51:59 <yairchu> it was close to 1GB VSIZE
15:52:04 <Cale> Currently, compiled with -O2 using ghc 6.10.3, it seems to be running in constant space for over a minute...
15:52:16 <Cale> oh, it just finished with space: Prelude.head: empty list
15:52:38 <yairchu> yeah that's how it finishes
15:52:55 <Cale> It never got over 4.8 MB here.
15:53:08 <Cale> (with 2.9 resident)
15:53:18 <Cale> So maybe it's a bug in 6.10.2?
15:53:22 <yairchu> hmm. maybe I should try to upgrade to ghc 6.10.3
15:53:34 <yairchu> thanks :)
15:53:36 <TomMD> I'm trying to remember the GHC action :: IO Int which returns the number of capabilities.  Anyone?
15:53:47 <Cale> Capabilities?
15:53:55 <Axman6> numCapabilities?
15:53:59 <Axman6> no...
15:54:23 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/GHC-Conc.html#v%3AnumCapabilities
15:54:25 <Cale> that?
15:54:37 <TomMD> Yes, thank you
15:54:39 <TomMD> I thought it was IO
15:55:02 <Cale> Interesting. I would expect it to be as well.
15:55:07 <fracture> so it seems if you have multiple record-style data types with fields that have the same name it creates name conflicts by generating functions with the same names
15:55:14 <fracture> which... sucks, eh?
15:55:20 <fracture> so do people just name mangle those functions?
15:55:33 <Saizan> or put them in different modules
15:55:42 <Cale> fracture: Usually I'll use a prefix to disambiguate, or try to factor out the common portions of the datatypes.
15:55:51 <Cale> Or yeah, put them in different modules.
15:56:00 <fracture> ok
15:56:29 <fracture> I guess it just stems from lack of type-based overloading for functions, eh?
15:56:43 <TomMD> yep
15:56:49 <fracture> d'oh.
15:56:53 <Cale> Well, there's typeclasses, but the record system doesn't take advantage of that.
15:56:56 <Saizan> you'd have to use a typeclass
15:56:58 <TomMD> The most common complaint I hear from intermediate Haskell programmers.
15:57:15 <fracture> (coming from C++ I guess I'm just used to getting to name stuff really terse instead of mangling)
15:57:18 <fracture> got ya
15:57:57 <Cale> fracture: So, if you really need that kind of polymorphism, you can always define a typeclass and make the extractor functions into instances.
15:58:02 <fracture> Cale: btw in this case, I think I can actually factor these together some, so it's not all bad
15:58:07 <Cale> yeah
15:58:23 <uzytkownik> ?hoogle if'
15:58:24 <lambdabot> No results found
15:58:40 <Cale> Like instead of having x :: Double and y :: Double in a bunch of different record types, create a type Point for that.
15:58:48 <dmwit> uzytkownik: It's a \bot-ism.
15:58:53 <dmwit> if' b t f = if b then t else f
15:59:29 <uzytkownik> dmwit: I know. I just cannot find it (or rather ghc cannot find it ;) )
15:59:55 <Saizan> that's because it's not defined anywhere:)
16:00:47 <riddochc> Buh.  Real World Haskell doesn't mention Debug.trace.  Man, I wish I'd known about this sooner.  Grr.
16:00:53 <dmwit> uzytkownik: Yep, it's strictly a \bot-ism, you have to write it yourself if you want it.
16:01:05 <dmwit> ?quote oasis
16:01:05 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
16:01:40 <uzytkownik> dmwit: OK. I understend now
16:10:24 <yairchu> Cale: I upgraded to GHC 6.10.3 and my problem persists. could it be a platform dependent bug?
16:14:00 <Twey> @src length
16:14:00 <lambdabot> Source not found. Where did you learn to type?
16:17:12 <riddochc> Hmm.  hmake 3.14 doesn't build on my system.   It's trying to run "ghc-pkg-6.10.1 -l", which doesn't have a "-l".
16:18:02 <Twey> @src ($!)
16:18:03 <lambdabot> f $! x = x `seq` f x
16:22:32 <HttpError> peanuts:
16:25:03 <HttpError> peanuts: if you are there, PM me.
16:25:21 <peanuts> how do I do that?
16:25:37 <HttpError> never mind
16:26:06 <HttpError> the nick you are using is owned by me, i ask that you be careful with it, dont get banned anywhere
16:27:40 <peanuts> oh I wasn't aware you can own a nick, I'll just change it then
16:28:23 <HttpError> hey, you can use it, just dont be bad :)
16:28:36 <HttpError> Also: /ns help
16:32:58 <Peaker> sounds like yairchu might have hit the Integer bug in 6.10.2 there
16:33:11 <Peaker> I heard about it here -- someone said it ruins one of the shootout benchmarks too
17:04:04 <sm> how do you make a form with Text.Xhtml ?
17:04:19 <sm> http://hackage.haskell.org/packages/archive/xhtml/3000.2.0.1/doc/html/Text-XHtml-Transitional.html#16 is no help
17:06:13 <Cale> sm: Is there something that you need which is missing from that?
17:06:56 <sm> hi Cale. Yes, an example of defining a form. I expected to see a form function to get things rolling
17:07:05 <Cale> There is one
17:07:11 <Cale> http://hackage.haskell.org/packages/archive/xhtml/3000.2.0.1/doc/html/Text-XHtml-Transitional.html#v%3Aform
17:07:30 <sm> huh. Thank you!
17:07:47 <Cale> No problem. In-page search is awesome, btw :)
17:07:57 <sm> indeed.. mine was too hasty
17:08:48 <sm> I worked a bit on ledger performance, still tinkering around as time allows
17:10:16 <yurinotigor> do you know of any hosted haskell provider? Ideally, something along the lines of AppEngine but at least a hosting specialized in haskell
17:10:38 <Cale> yurinotigor: Anything which allows arbitrary executables will do.
17:10:53 <Cale> yurinotigor: Since you can simply compile your program.
17:11:06 <mgsloan> nearlyfreespeech.net doesn't host haskell specifically, but it supports it as a language (ghc is on their servers and such)
17:12:12 * sm started reimplementing my tree utilities using your trie-tree but found it tricky. Then I tried to force more strictness, and mean to try again. Then I looked at the app and decided it doesn't need to use a tree at all, and started building an abstract AccountTree data type that I could easily change the implementation of.
17:12:22 <yurinotigor> I see. It would be great if there was a provider that would provide a infrastructure for haskell with some of the common services already taken care of such as web authentication, persistent storage in the cloud. Something along the lines of AppEngine for Haskell
17:12:56 <sm> yurinotigor: good idea. I'm sure the #happs folks would be interested in that
17:13:28 <mmorrow> yurinotigor: you just need to get a hosted account with ssh access and a decent linux distribution whose pkg manager has at least ghc-6.4, and you can boot from there.
17:14:22 <yurinotigor> mmorrow: yes, but things like Amazons Simple DB or AppEngine bigtable make a big difference. But your point is still valid its just that I would have to build the infra myself
17:15:17 <Cale> If you're starting from ghc 6.4, why not just download a newer binary?
17:15:31 <mmorrow> yurinotigor: as far as i'm aware, you'll need your bootstrap shoes on to get a haskell setup on a hosted box :)
17:15:41 <Cale> Compiling your way up seems like a waste of time :)
17:15:43 <mmorrow> Cale: oh yeah, the newer the better
17:16:15 <mmorrow> (one of my hosted accounts is on CentOS, and its yum had ghc-6.4 as the newest..)
17:16:33 <mmorrow> it took ~4 hours to build 6.8.3
17:16:37 <Cale> It's usually easy enough, given the space, just to wget the ghc binary package and install it in your homedir
17:16:56 <mmorrow> Cale: it wouldn't function on that CentOS setup
17:17:07 <mmorrow> the libc wasn't compatible or something
17:17:13 <Cale> ah
17:17:37 <mmorrow> but yeah, if the bindist works you're sitting pretty
17:19:14 <yurinotigor> Would Happs be the closest to an "container" like that for Haskell?
17:20:31 <Saizan> in happs each application gets compiled to a standalone server
17:20:41 <Saizan> but it does provide a nice base to start with
17:20:45 <mmorrow> (and in the case that it *doesn't* work, and you have to build a ghc from an older version.... ghc needs alex+happy top build, and each of those needs itself to build (for the initial processing step of the .x and .y files that provide each with their parser/lexer), and chances are good that if you have no ghc bindist you won't have a binary alex or happy, so all you have to do is preproc the .x and .y files on another computer, then upl
17:20:45 <mmorrow> oad the resulting .hs's to the hosted machine.
17:21:07 <mmorrow> that was a huge pita to figure out the first time around..
17:21:54 <mmorrow> (then build alex and happy, and finally you can build the new ghc)
17:22:32 <Saizan> why not build alex an happy with the old ghc? the hackage packages have the preprocessed files in them
17:22:39 <mmorrow> maybe i've just had bad luck though and being in the situation where you need to build everything is rare
17:23:07 <mmorrow> Saizan: ah sure, or that (i was building from darcs i think)
17:23:21 <mmorrow> err, the hackage packages have the already processed .hs's?
17:24:37 <Saizan> the .hs corresponding to the .x/.y , yes
17:24:38 <mmorrow> the hackage happy package doesn't seem to
17:24:51 <Saizan> under dist/build
17:24:56 <mmorrow> i only see Parser.ly in the tarball
17:25:11 <mmorrow> but you need happy to get it!
17:25:14 <mmorrow> :)
17:25:30 <Saizan> saizan@astarte:~/trash/happy-1.18.4/dist/build/happy/happy-tmp$ ls
17:25:30 <mmorrow> oh
17:25:30 <Saizan> AttrGrammarParser.hs  Parser.hs
17:25:33 <mmorrow> so it's there
17:25:35 <mmorrow> :)
17:25:43 <mmorrow> good to know..
17:26:05 <mgsloan> what would be the simplest representation / interface through which to analyze haskell source?
17:26:23 * mmorrow takes back his hacky happy build scheme
17:26:37 <mmorrow> mgsloan: analyze it how?
17:26:51 <mmorrow> mgsloan: (probably haskell-src-exts)
17:27:24 <mgsloan> just view it as a simple graph basically, an easily traversable graph
17:27:53 <mmorrow> mgsloan: a graph of calls/types/tycondeps//modules/.. ?
17:28:32 <mgsloan> just a bunch of expression graphs would be good enough
17:28:41 <mmorrow> mgsloan: you want haskell-src-exts
17:28:45 <mgsloan> for every method or function definition
17:29:39 <mgsloan> yeah I suppose you are right
17:30:37 <yurinotigor> Saizan, Cale, mmorrow, mgsloan: thanks for the insights.
17:54:40 <mmorrow> gah
17:55:11 <mmorrow> @tell yurinotigor here're some useful haskell-src-exts functions http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5512
17:55:11 <lambdabot> Consider it noted.
17:58:57 <mmorrow> arg, this `pExp' is better http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5512#a5513
17:59:12 <mmorrow> (the other one fails to parse package.conf, this one works)
18:00:39 <mmorrow> look at how pretty package.conf is with a little prettyPrinting! http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5512#a5514
18:00:57 <mmorrow> (ppHs :: forall a. (Show a) => a -> Doc)
18:01:34 <mmorrow> never have to look at jumbled show output again
18:02:08 * mmorrow is so adamant about this because he uses it so often and can't get over how much easier it makes inspecting data
18:02:39 <Adamant> mmorrow: you are Adamant too? welcome to the collective of Adamant!
18:02:43 <Adamant> :P
18:02:47 <pumpkin> :o
18:03:00 <mmorrow> :0
18:03:15 <Adamant> I iz kiddin'
18:03:19 <mmorrow> :)
18:03:24 <pumpkin> :I
18:03:25 <ray> i'm adamant that people should stop talking about ray tracers on irc
18:03:33 <Adamant> ray: me too
18:03:42 <mmorrow> @hoogle trace
18:03:42 <lambdabot> Debug.Trace trace :: String -> a -> a
18:03:42 <lambdabot> module Debug.Trace
18:03:42 <lambdabot> package traced
18:03:49 * pumpkin port rays himself in a picture
18:04:09 * mmorrow project pumpkin onto a nurb
18:04:10 <pumpkin> I guess I'd need to separate the S too, to be really annoying
18:04:18 <Adamant> pumpkin: are you adamant about this?
18:04:23 <ray> maybe i highlight on my own plural
18:04:28 <pumpkin> more adamant than a pumpkin
18:04:44 <pumpkin> (yeah, I suck)
18:05:00 <Adamant> pumpkin: copumpkin is funnier than thou
18:05:05 <pumpkin> :(
18:05:24 <ray> bring back copumpkin
18:05:26 <Adamant> just kidding, you're doing fine :P
18:05:32 * pumpkin sobs
18:06:01 * mmorrow carves a smiley face into pumpkin
18:07:22 <mutjida> @hoogle mapAccumL
18:07:23 <lambdabot> Data.ByteString mapAccumL :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
18:07:23 <lambdabot> Data.List mapAccumL :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
18:07:23 <lambdabot> Data.ByteString.Char8 mapAccumL :: (acc -> Char -> (acc, Char)) -> acc -> ByteString -> (acc, ByteString)
18:17:58 <Chile`> so I see GHC has a 'SPECIALIZE' pragma.. is it considered bad form to use this for anything other than optimizations?
18:18:23 <Hunner> If I wanted to have a haskell program that didn't restart, but I could modify the "backend" which passed something back and forth as requests came in, what am I looking for?
18:19:06 <Hunner> an irc bot where you could modify the functions and triggers is specifically what I'm looking at
18:19:21 <Hunner> as long as the framework code for the bot doesn't change
18:19:33 <Hunner> in ruby I just open a pipe to another ruby script
18:21:09 <aavogt> Hunner: maybe something like what I think happs does, or plugins (formerly hs-plugins) would interest you
18:22:19 <Hunner> so it would most likely be something heavy duty? I'm looking to build something from scratch if possible to learn more
18:24:19 <defun> How would I test a value to tell if it is a string or an int? If I hand 'func x' I would like the 'func' to take different actions depending on the type of 'x'. Any ideas?
18:24:33 <Saizan> defun: use a typeclass
18:25:03 <Saizan> or an union type
18:25:15 <defun> thanks. anything else?
18:25:17 <Saizan> like data StringOrInt = S String | I Int
18:25:56 <Chile`> if you use a type class, can you assign a function to 'any type not already listed'?
18:26:15 <aavogt> Hunner: and you could communicate by pipes with haskell code too
18:26:18 <dino-> Or pack it in (Either String Int)
18:26:41 <Saizan> there's also Typeable/Dynamic, but those are generally the last option one considers
18:26:58 <Saizan> Chile`: you can with OverlappingInstances
18:27:24 <Saizan> but it's not considered good style
18:27:56 <Saizan> mostly because importing another module which defines another instance can change the behaviour of your code
18:28:01 <Hunner> aavogt: thanks for the help. Class is done so I'm heading out, and will look at hs-plugins and pipes later
18:28:18 <dino-> I think Either when it comes up that something is "this or that"
19:02:17 <fracture> is there an invalid Handle value, or do you have to use Maybe Handle ?
19:02:32 <monochrom> Use Maybe Handle.
19:03:23 <Cale> Even if there were, using Maybe Handle out of principle would probably still be a good idea :)
19:03:24 <dancor> template haskell can really crank up compile time
19:03:45 <dancor> do you guys put crazy deriving blocks in separate files so they might get recompiled less often, or other tricks
19:03:47 <byorgey> fracture: Haskell style is to never include 'invalid values' in a type, leaving that up to 'Maybe' or 'Either e' (for some appropriate error type e), etc.
19:04:03 <FunctorSal> dancor: are you sure it's th?
19:04:18 <Twey> data Bool = True | False | FileNotFound -- had to
19:04:20 <FunctorSal> it shouldn't be slower than executing the TH + compiling the resulting code
19:04:30 <dancor> FunctorSal: only change is adding  deriving (Data, Typeable) everywhere
19:04:30 <FunctorSal> I guess the former is insignificant...
19:04:40 <gwern> hm. I'm trying to think. has anyone here ever used information theoretical concepts in real life (non-programming)? I'm sure I've done so, but I can't seem to remember what I decided or di
19:04:47 <FunctorSal> dancor: wouldn't call that TH
19:04:59 <dancor> ok, SYB
19:05:05 <FunctorSal> ah
19:05:25 <mmorrow> dancor: i usually compilte a program that's sole purpose is touch output the (prettyprinted and cleaned) code it generates on stdout, then > Foo.hs
19:05:30 <mmorrow> *compile
19:05:44 <mmorrow> *.. is to output
19:05:45 <FunctorSal> gwern: yes! put often-used items in the best places
19:06:17 <fracture> Cale: don't think I agree re the Maybe Handle... if you can set up situations where it is a precondition that the Handle is valid, it would avoid some use of Maybe in the code
19:06:27 <gwern> FunctorSal: hm. I'd say that's actually more data structure stuff
19:06:42 <Cale> fracture: But if you know that the Handle is valid, then you don't need Maybe Handle
19:06:43 <dancor> mmorrow: i can't tell if that's a joke or some haskell thing i don't know about (i never can)
19:06:46 <fracture> (probably no different from normal Handle use... you're often assuming it hasn't be closed as a precondition)
19:06:50 <gwern> I was thinking more like 'each question gets me less than a bit so I can't hope to do it any faster than n'
19:07:15 <FunctorSal> gwern: it's "encoding theory" (can't think of the right name of the field ;)) I would call that information scienec
19:07:16 <fracture> well you might have a data structure that contains a handle if a particular step has occured, after which it will always be valid
19:07:52 <fracture> by the way, refactoring that data type didn't really fix the problem... the logical names for the members are the same as logical names for them in other locations in the code, which sucks
19:07:57 <fracture> so you get name hiding
19:08:17 <MyCatVerbs> > 3 `mappend` 4
19:08:18 <lambdabot>   Add a type signature
19:08:29 <gwern> FunctorSal: the context for my question is someone suggested a book covering the basic simple math of every important field for laymen, and I was thinking information theory is very important but it's not obvious witout examples - you can explain bits and uncertainty and the pigeonhole principle and it still looks like trivia
19:08:39 <Cale> fracture: There are at least a couple benefits to using Maybe to explain failures. One is that you can tell from the type of a function that it might not give you a valid value. Secondly, there are lots of functions for manipulating and combining values of Maybe type.
19:08:41 <fracture> (was worth merging them though)
19:09:06 <fracture> yeah but this wouldn't be for a failure (I agree that the maybe manipulation utilities are pretty badass)
19:09:14 <FunctorSal> gwern: I thought huffman coding was very similar to storing items you need often on the table, and rarely used items in boxes etc.
19:09:29 <gwern> too close to common sense
19:09:37 * gwern keeps pondering
19:09:37 <sclv_> gwern: I don't think with the exact maths of shannon, but like lots of folks, I often use signal/noise and information bandwidth type analogies about different forms of communication
19:09:48 <Twey> fracture: Maybe is used for ‘optional’ arguments and return values in general
19:09:49 <FunctorSal> gwern: isn't that a good thing? :)
19:10:10 <fracture> Twey: yeah I grok that
19:10:12 <Twey> Not just failures, although that's often the meaning when used as a return value
19:10:13 <gwern> FunctorSal: no, if it's too obvious people will mentally go 'that's stupid' and forget the lessons
19:10:44 <Cale> fracture: There's at least one library which makes explicit the notion of a future value -- one which becomes defined at some point and thereafter remains constant.
19:10:53 <gwern> a good example will be a common situation where your intuitions are obviously muddled, and a bit of thinking about information and certainty will give you an obvious and clearly better answer
19:10:56 <pumpkin> or will think, "oh wow, it's a fancy name on something I already knew *build mental association of fancy name to already known thing*"
19:11:00 <FunctorSal> gwern: oh, right... shouldn't be too trivial
19:11:07 <pumpkin> ah
19:11:08 <gwern> ideally, it'll make the person think, 'how extremely stupid of me not to have thought of that!'
19:11:10 <Twey> gwern: I disagree
19:11:16 <dancor> what is the $(..) equivalent of: deriving (Data)
19:11:24 <SamB> Cale: but the notion of time involved is a bit mind-boggling, isn't it?
19:11:27 <Twey> Formal reformulations of concepts the reader already knows are the easiest to remember
19:11:44 <Twey> Because they can relate them (and everything deriving from them) directly to their ‘common sense’
19:11:46 <FunctorSal> dancor: cabal install derive; $(derive makeData ''MyDatatype)
19:11:52 <Cale> SamB: perhaps, yeah
19:11:53 <FunctorSal> (or similar)
19:11:58 <dancor> FunctorSal: thanks
19:12:06 <Cale> It makes more sense in an explicitly concurrent setting than a pure one
19:13:44 <FunctorSal> hmm is there a consensus that only the existing top-level branches in the module namespace should be used? Data.* seems a bit overworked...
19:14:04 <Cale> FunctorSal: No, you can make up new stuff as you see fit.
19:14:17 <gwern> consensus? not as such. but there seems to be a weak prejudice against it
19:14:26 <gwern> kind of like adding new categories to hackage...
19:14:34 <fracture> is there a way to get at names in the enclosing namespace if you have shadowed them?
19:14:36 <Cale> The difference between Data and Control is hazy
19:14:48 <fracture> like if you have a data Foo = Foo { bar :: Int } or something
19:14:58 <fracture> and a local name is bound to bar
19:14:59 <Cale> fracture: Don't shadow them :)
19:15:01 <fracture> Foo.bar or something
19:15:23 <fracture> Cale: that'd be my preference, but (much to my disappointment) the names from data structures are basically global
19:15:26 <Cale> Well, you can refer to the module
19:15:27 <fracture> (module-wide)
19:15:29 <fracture> ahhh
19:15:36 <fracture> so Main.bar would get it?
19:15:48 <Cale> Basically, pick field labels which you are not going to want to reuse for something else.
19:15:52 <Twey> fracture: Which is why I recommend putting records in their own namespaces
19:15:58 <fracture> yeah... that's really disappointing though
19:16:02 <Cale> At least, that's what I do.
19:16:08 <Twey> It's not, when you think about it.
19:16:10 <fracture> (having to mangle names in fields)
19:16:17 <Cale> You don't have to mangle them.
19:16:26 <Twey> Named data fields is the task of records.
19:16:30 <Twey> Namespacing is the task of modules.
19:16:36 <Twey> If you want both, combine the two.
19:16:37 <Cale> Just make the name a bit more specific.
19:17:00 <fracture> hrm
19:17:02 <Twey> It's a Good Thing that we have this composable simplicity.
19:17:10 <Cale> Like, attach the type name (or an abbreviation of it) to the beginning of the field name.
19:17:12 <FunctorSal> or make a typeclass if it is a thing that many types could have
19:17:18 <fracture> Cale: that's mangling...
19:17:19 <FunctorSal> (fracture)
19:17:24 <fracture> (that's like what we had to do back in C)
19:17:27 <Cale> I don't see it as mangling...
19:17:40 <Cale> It's just giving a specific name to the extractor function for that type and field.
19:17:52 <fracture> well, whatever you call it
19:18:01 <fracture> (the C++ guys call it "mangling")
19:18:08 <Twey> That is technically the definition of mangling.
19:18:18 <FunctorSal> class Bar a where bar :: a -> Int
19:18:21 <fracture> ok so the alternative is to make a module just for the data definition, eh?
19:18:24 <fracture> hrm
19:18:24 * Cale thinks of mangling as more the sort of thing which is done by the linker...
19:18:29 <Twey> fracture: And related functions.
19:18:38 <fracture> ahh... well that's not too bad
19:18:40 <pumpkin> I've brought this up before, but can anyone think of some "theoretical" basis for functions that are efficient to calculate on a sliding window over a stream?
19:18:44 <fracture> anything non-trivial is probably going to have related functions
19:18:48 <Twey> fracture: No, it's not :)  Right.
19:18:49 <SamB> Cale: not just a linker ...
19:19:12 <aavogt> @go evil mangler
19:19:13 <lambdabot> http://hackage.haskell.org/trac/ghc/wiki/Commentary/EvilMangler
19:19:13 <lambdabot> Title: Commentary/EvilMangler - GHC - Trac
19:19:15 <Twey> What *would* be nice is to be able to put multiple modules in the same file.
19:19:19 <Cale> pumpkin: It seems they fit into a particular comonadic view.
19:19:24 <fracture> ah is that illegal?  .. d'oh
19:19:32 <pumpkin> Cale: how so?
19:19:32 <smorg> is it possible (or sane) to represent the output function of a comprehension as a variable to use as a predicate within the same statement?
19:19:52 <Twey> But, well, it's okay to have to use different files, especially since, as you say, most non-trivial records are going to have associated functions on them anyway.
19:20:03 <fracture> true
19:20:05 <smorg> let y = [ 2*x | x <- [0..9], y>10 ] or [ y = (2*x) | x <- [0..9], y>10 ]
19:20:15 <Cale> pumpkin: Have you read the stuff about how cellular automata are easily expressed in a particular comonad?
19:20:27 <pumpkin> Cale: I can think of good ways of computing mean, entropy, and a few other simple measurements over a sliding window in constant time per additional sample
19:20:39 <pumpkin> nope, do you have a URL?
19:20:45 <Cale> pumpkin: Oh, that's a little different...
19:20:58 <pumpkin> ah, yeah, that's the kind of thing I was talking about
19:21:04 <FunctorSal> >  [ 2*x | x <- [0..9], y>10 ] -- smorg
19:21:05 <lambdabot>   [0,2,4,6,8,10,12,14,16,18]
19:21:17 <pumpkin> but I'd still be interested in reading about that... I'm still pretty unfamiliar with comonads beyond the basic definition
19:21:20 <Cale> http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html -- it was supposed to be here, but this is a 404
19:21:29 <pumpkin> worked for me
19:21:31 <FunctorSal> hmm I thought it would make an infinite list of zeroes
19:21:41 <pumpkin> maybe edwardk has a special rule for your IP :)
19:21:42 <FunctorSal> oh, there's no generator for y...
19:21:46 <pumpkin> I mean sigfpe :)
19:21:51 <FunctorSal> nevermind :)
19:21:52 <pumpkin> damn comonad confusion in my head
19:21:54 <Cale> heh, that's strange if true
19:22:12 <smorg> I'm thinking there must be some interesting application for doing something like that - akin to a recursive function
19:22:13 <Cale> So, anyway, look at the type of =>>
19:22:44 <pumpkin> do you still think it would be applicable to sliding window-type computations?
19:22:47 <dibblego> @type (=>>)
19:22:48 <lambdabot> Not in scope: `=>>'
19:22:59 <pumpkin> sliding windows feel a bit like convolution, but not quite
19:23:21 <Cale> pumpkin: Perhaps not in quite the efficient sense that you were describing, but for describing such computations in the first place, yes.
19:23:36 <Cale> Stream a -> (Stream a -> b) -> Stream b
19:23:41 <FunctorSal> pumpkin:  they are a convolution with the "window weighting" function, no?
19:24:09 <pumpkin> I guess, but I'm not sure how I'd express an entropy computation over a sliding window as a traditional convolution
19:24:14 <pumpkin> it doesn't feel possible, but I'm no expert :)
19:24:16 <FunctorSal> (something like f x = if x >= 0 && x < 1 then 1 else 0)
19:24:30 <Cale> Where the function parameter gets some tail of the Stream as its input, and is expected to look at some initial window of it.
19:24:41 <pumpkin> I see
19:24:44 <FunctorSal> pumpkin: I meant for a single window it's a convolution
19:24:49 <pumpkin> ah
19:25:09 <FunctorSal> so you'd have the function you convolute with varying in time...
19:25:50 <Cale> Or, if you need more, there are lots of other possible valid cojoin implementations -- you can enforce the window size/scope in your instance of Comonad as well.
19:26:27 <Cale> (at the cost of a little prettiness)
19:26:52 <pumpkin> hmm
19:27:04 <smorg> I guess that seems more elegent than filter (>10) [ 2*x | x <- [0..9] ]
19:27:11 <pumpkin> that's interesting
19:27:24 <pumpkin> any thoughts on how I could bring my definition of "efficiency" into it all?
19:27:43 <pumpkin> that is, constant or sub O(window size) complexity per additional sample
19:27:51 <Cale> > [y | x <- [0..9], let y = 2*x, y > 10]
19:27:52 <lambdabot>   [12,14,16,18]
19:27:53 <sclv_> heh. i was just talking about how to model windows in streaming computations today and i forgot all about comonads!
19:29:13 <sclv_> zippers = best comonads evah
19:29:16 <smorg> Cale: oh didn't think of that. neat.
19:29:35 <smorg> heh very cool actually...
19:29:39 <Cale> pumpkin: I suppose that if you want to go that way, perhaps the pure comonadic view isn't going to work out. The important thing is being able to reuse your previous result to compute your next one. (Along with perhaps the element before the sliding window and the element after)
19:29:51 <pumpkin> yeah
19:30:12 <pumpkin> being able to maintain who's "coming" and who's "going", basically
19:30:18 * BMeph still snickers a little every time he see's "Paul Potts" in a reference.
19:31:28 <monochrom> Paul Potts is the best Haskell programmer ever!
19:31:31 <monochrom> (like that?)
19:32:02 <monochrom> Or is it like the following?
19:32:53 <monochrom> 12. Paul Potts. How to sing and write Haskell at the same time. Journal of Functional Vocal Programming 4:16 2007
19:36:00 <smorg> So you can use let right in the middle of an expression to specify a function to use within the same expression (and it can be used anywhere at all inside the expression)?
19:36:22 <fracture> say you have a function inside a StateT-transformed monad... is there any way to declare that the function can't modify the state?
19:36:31 <fracture> (kinda like a const member function in a C++ class)
19:37:43 <sclv_> fracture: you can write a wrapper that gets the state, runs the function, then replaces the state with the original one.
19:37:55 <sclv_> so even if it does modify the state, it doesn't really
19:38:10 <fracture> I see
19:38:15 <monochrom> Yes smorg if I understand you correctly.
19:38:59 <sclv_> if you want to do it with typesafety, wrap the StateT in a newtype with a phantom type parameter that is either ReadOnly or ReadWrite
19:39:28 <sclv_> then have the modify functions require the parameter be ReadWrite
19:39:45 <sclv_> and allow the user to step "down" with runReadOnly but not step up.
19:40:00 <fracture> makes sense
19:40:14 <fracture> maybe would be worth doing if I had a significant amount of code that shouldn't be allowed to modify it... probably not for my current case
19:40:36 <fracture> although, that wouldn't quite be what is desired actually
19:40:39 <fracture> now that I think about it
19:40:43 <fracture> because internally it could still replace the state
19:40:46 <fracture> while it does whatever it does
19:40:55 <fracture> ideally you'd want a compile-time error for attempts to modify it
19:40:58 <gwern> (sure, maybe now we can sing and write haskell at the same time, but can we debug it?)
19:41:25 <sclv_> aha! you could also just have a readerToState that takes ReaderT m a -> StateT m a !
19:41:31 <sclv_> cleanest solution yet
19:41:41 <fracture> ok sorry to jump to another question:  if I'm in a function in the StateT Foo IO monad, and I want to forkIO to another function, how do I get the types to work?
19:41:46 <fracture> tried various combos of liftIO to no avail
19:41:50 <BMeph> gwern: And how will we ever be able to keep track of all those precious stack frames? >;p
19:42:16 <byorgey> fracture: you should be able to  liftIO  any IO action to a  StateT Foo IO  action.
19:42:33 <byorgey> i.e., it should just take wrapping the forkIO call in a call to liftIO.
19:42:40 <sclv_> fracture: there's a technique for writing deep embeddings like that -- it involves un and rewrapping so you can get forkMyMonad
19:42:40 <gwern> BMeph: we can only balance on so many
19:43:05 <sclv_> see the code for catchIO on hackage for how its done with exceptions, which is v. similar
19:43:20 <byorgey> the 'minesweeper' package on Hackage lists 'glade' as a requirement--anyone know where to get this mythical 'glade' package?
19:43:22 <fracture> oh the problem is my guy is a Foo (), not an IO ()... I probably need to forkIO a new call to runStateT passing the current state, eh?
19:43:46 <sclv_> fracture: right. but the states won't sync back up again, so the semantics might be wrong...
19:43:52 <fracture> hmm
19:43:56 <fracture> oh
19:43:58 <jeffwheelerPhone> byorgey: Gtk2Hs
19:44:00 <fracture> I am just doing this wrong :)
19:44:06 <fracture> these threads can't share state anyway
19:44:10 <fracture> I should fork before I go into my monad
19:44:27 <byorgey> jeffwheelerPhone: I installed gtk2hs, and used the --enable-libglade flag, but it didn't install a package called 'glade'
19:44:38 <byorgey> jeffwheelerPhone: is there some other magic incantation I have to give while building gtk2hs?
19:44:53 <sclv_> with some cleverness you could make it work for reader and writer tho!
19:45:21 <sclv_> (you'd have to specify an explicit join to merge back)
19:45:37 <byorgey> oh wait!  the second time when I used --enable-libglade I forgot to do 'make install' after 'make'
19:45:41 <byorgey> duh, problem solved =)
19:45:44 <jeffwheelerPhone> byorgey: I didn't even have to do that; is there a libglade package that you can install first on your OS
19:46:12 <jeffwheelerPhone> byorgey: That works too :)
19:46:37 <byorgey> jeffwheelerPhone: thanks for the help =)
19:47:23 <jeffwheelerPhone> byorgey: No problem
19:48:03 <kw317> quick question: does Haskell (an if you know ML, then ML as well) erase type information after compilation?
19:48:10 <monochrom> Yes.
19:48:15 <monochrom> Both of them.
19:48:29 <pumpkin> the closest thing to type information it retains is dictionaries of methods for typeclasses
19:48:49 <aavogt> there is Dynamic though
19:49:00 <pumpkin> which works through dictionaries of typeclasses doesn't it?
19:49:04 <kw317> cool, thanks
19:49:19 * kw317 is having a compilers (among other things) exam tomorrow :-)
19:49:42 <pumpkin> good luck :)
19:49:49 <sclv_> as far as i recall ml and ocaml in particular don't retain dictionaries
19:49:55 <kw317> thanks :-)
19:49:57 <pumpkin> how do they get around it?
19:50:15 <sclv_> no typeclasses.
19:50:18 <pumpkin> oh :)
19:50:23 <pumpkin> that'll do it
19:50:29 <pumpkin> I guess they have their fancy modules to do the same thing
19:50:50 <sclv_> the upshot tho, as i recall again, is that, e.g., syb style generics can't be done in ocaml
19:55:03 <hackagebot> simgi 0.1.1
19:56:13 <gwern> @pl foo x = "quux" ++ x ++ "bar"
19:56:13 <lambdabot> foo = ("quux" ++) . (++ "bar")
20:01:31 <BMeph> So, is there a co-Kleisli operator, (w a -> b) -> (w a -> w b)?
20:02:13 <byorgey> BMeph: sure, that's just cobind with the arguments switched
20:04:14 <pumpkin> is there a comonadic equivalent to kleisli composition then?
20:04:31 <MyCatVerbs> BMeph: category-extras has that exactly, under the name (extend). It's just cobind, as byorgey says.
20:04:57 <byorgey> pumpkin: let's see... it would have type  (w a -> b) -> (w b -> c) -> (w a -> c) ?
20:04:59 <sclv_> ?hoogle (>=>)
20:05:00 <lambdabot> Control.Monad (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
20:05:06 <pumpkin> yeah
20:05:23 <pumpkin> I don't think hoogle does category-extras
20:05:35 <pumpkin> @hoogle (Comonad w) => (w a -> b) -> (w b -> c) -> (w a -> c)
20:05:35 <lambdabot> Warning: Unknown class Comonad
20:05:36 <lambdabot> No results found
20:05:53 <sclv_> extend :: w a -> w (w a)
20:06:21 <byorgey> pumpkin: there's an instance (Comonad w) => Arrow (CoKleisli w)  in category-extras, so yes
20:06:24 <sclv_> oh wait that's duplicate i think
20:06:38 <byorgey> sclv_: yeah, that's duplicate/cojoin
20:12:04 <BMeph> Well, we have a symbol for "bind with the arguments switched" - is there one cobind, and is it used much? :)
20:12:15 <BMeph> one *for
20:13:30 * pumpkin slaps BMeph
20:15:59 <MyCatVerbs>  
20:16:02 <pumpkin>  
20:16:02 <Badger>  
20:16:32 <MyCatVerbs> BMeph: (=>>) in Control.Comonad.
20:16:54 <Badger> What's a comonad? :)
20:17:21 <aavogt> What's a copumpkin?
20:17:29 <pumpkin> it's the opposite of a pumpkin, just like a comonad is the opposite of a monad
20:17:40 <gwern> aavogt: it's a strawberry
20:17:49 <gwern> seeds on the outside to te pumpkin's seeds on the inside, y'see
20:17:58 <FunctorSal> and like the sum is the opposite of a product ;)
20:18:06 <FunctorSal> *a sum
20:18:19 <pumpkin> and a contrafunctorsteak is the opposite of a functorsalad?
20:18:34 <FunctorSal> :O
20:18:39 <Badger> > 1 * (-1)
20:18:40 <lambdabot>   -1
20:18:48 <pumpkin> that's wrong btw
20:18:52 <pumpkin> according to mr timecube
20:18:58 <Badger> > 1 + (-1)
20:18:59 <lambdabot>   0
20:19:09 <Badger> damn
20:19:18 <pumpkin> yeah, all of mathematics is wrong, sorry
20:19:23 <ray> you are an educated stupid
20:19:26 <Badger> if only we had comathematics
20:19:28 <FunctorSal> pumpkin: (-1) * (-1) is stupid and evil.
20:19:28 <pumpkin> also, the earth is a cube but has four faces
20:19:37 <pumpkin> and they rotate independently
20:19:38 <ray> four CORNERS
20:19:38 <Badger> > (-1) * (-1)
20:19:39 <lambdabot>   1
20:19:41 <Badger> WHAT
20:19:44 * aavogt reads up on coma thematics
20:20:05 <FunctorSal> hmm I'm overtired. there was an "= 1" supposed to be tehre
20:20:20 <ray> > let (-1)*(-1)=(-1) in (-1)*(-1)
20:20:21 <lambdabot>   -1
20:20:27 <ray> so many parentheses. damn you, unary minus
20:20:38 <FunctorSal> it's intriguing how it's not just stupid, it's stupid *and* evil.
20:20:42 <ray> unary minus is stupid and evil
20:21:25 <ray> > let time = cubic in fourCornerDay
20:21:26 <lambdabot>   Not in scope: `cubic'Not in scope: `fourCornerDay'
20:21:47 <ray> lambdabot is stupid and evil too, QED
20:23:07 <Badger> @vixen are you stupid and evil?
20:23:07 <lambdabot> yes, i am
20:23:14 * BMeph reads up on psycho the rapists
20:24:11 <aavogt> @vixen are you wrong?
20:24:11 <lambdabot> i truely am
20:25:36 <ray> among my fellow rays, there are many cranks
20:25:43 <ray> like gene ray
20:25:46 <pumpkin> yeah
20:25:48 <ray> or the even bigger crank, ray kurzweil
20:26:04 <pumpkin> I don't think you can be a bigger crank than gene ray
20:26:15 <pumpkin> he's the only one with >1 wolfram, after all
20:26:26 <ray> wolfram number?
20:26:39 <ray> or are wolframs now a unit of crankness
20:26:54 <pumpkin> http://www.aleph.se/andart/archives/2009/04/monumental_egos.html :)
20:27:11 <ray> similar to the farad in that picowolframs are the normal unit
20:27:13 <ray> or something
20:27:23 <pumpkin> yeah :)
20:27:27 <pumpkin> well
20:27:30 <pumpkin> not really in this case
20:27:37 <aavogt> is it possible to tell cabal install to pass --hyperlink-source to the haddock stage?
20:27:38 <pumpkin> because most people have relatively high opinions of themselves, as he explains
20:28:47 <QtPlaty[HireMe]> pumpkin: That seems to be a very ethnocentric view.
20:28:52 <pumpkin> true
20:28:56 <ray> well, he's not measuring egos on a linear scale
20:29:04 <ray> no picowolframs necessary
20:29:33 <ray> not linear. once again the correct word evades me
20:29:42 <pumpkin> log?
20:29:50 <QtPlaty[HireMe]> You wouldn't get that in an "asian" culture, hell it would be looked down on in Australian and British cultures as well to diffrent extents.
20:30:14 <pumpkin> this is just about how people actually evaluate themselves, not how they feel they should talk about it to other people
20:30:26 <pumpkin> just because you don't admit to thinking you're better than I am
20:30:28 <pumpkin> doesn't mean you don't
20:30:35 <aavogt> I see the --PROG-option, but --haddock-option doesn't seem to be accepted
20:31:40 <pumpkin> but I agree that isn't the case in all cultures :)
20:34:58 <aavogt> hmm, --haddock-option="--hyperlink-source" is silently rejected if specified before the package to install
20:36:16 <ray> hmm, i can't measure my own ego in wolframs per that guy's post
20:38:06 <gwern> aw shucks. I put too much parallelism into my program
20:38:08 <gwern> '
20:38:08 <gwern> 'wp-rc-archivebot: socket: resource exhausted (Too many open files)
20:38:08 <gwern> "http://www.webcitation.org/archive?url=http://www.njpw.co.jp/result/index.php?COM=result_main&SRNO=76&TKNO=1&email=gwern0@gmail.com"
20:39:31 <sclv_> gwern: depending on the os, you can raise the ulimit
20:39:41 <sclv_> some kernels its hard compiled in. :-(
20:40:25 <gwern> yeah, but open files is a root ulimit
20:40:40 <encryptio> not really
20:40:56 <encryptio> the hard limits are always root-only, but the soft limits might not be
20:41:06 <gwern> ulimit -n 100000 certainly asks me for root privileges
20:41:20 <encryptio> that won't work on any os
20:41:42 <encryptio> no unix-like kernel i know of supports more than 32k systemwide
20:42:05 <gwern> well, there's no point in asking for just 1k when I already have 1024
20:42:24 <gwern> and asking for 4k I just get 'bash: ulimit: open files: cannot modify limit: Operation not permitted
20:42:30 <encryptio> personally, i think if you're using more than a thousand filehandles, something is wrong (probably architecture)
20:42:37 <MyCatVerbs> ulimit for open files? Uh, I've blown past about... either seventy or a hundred and ten thousand before.
20:42:52 <bos> you can easily set ulimit -n to a very high number
20:43:04 <gwern> encryptio: I need to open a shitload of http connections, that is what this program *does*
20:43:07 <MyCatVerbs> I think I had to poke something in /proc for that, and needed root privs to raise ulimit -n.
20:43:19 <gwern> there's no architecte to design
20:43:43 <encryptio> gwern: thousands? i do hope you have the oc12 for that
20:43:56 <gwern> if I want to archive a couple thousand web addresses using the http web interface to webcitation.org, then I'm going to have to make a couple thousand connections
20:44:06 <sclv_> gwern: you probably know this but it doesn't hurt to check that you're managing filehandles strictly enough vis a vis closing them
20:44:27 <MyCatVerbs> Specifically, I've had one process open way north of 70k recieving sockets on Linux. (epoll() FTW). Trying to open more than 32k outgoing TCP sockets in Linux did not work for me, though.
20:44:41 <gwern> sclv_: this is via Network.HTTP. I'm not sure how I could be strict about closing them?
20:44:44 <bos> gwern: are you trying to get that many sockets open from haskell at once?
20:44:53 <bos> gwern: that definitely won't work.
20:45:10 <sclv_> you probably want no more than ~50 connections open at once
20:45:29 <MyCatVerbs> gwern: Oh dear. I would recommend using the libcurl bindings instead.
20:45:30 <encryptio> gwern: and if i were a web administrator, i'd be very unhappy with anyone using more than 50 or so connections. in fact, i might look into suing them.
20:46:06 <gwern> encryptio: eh. the webcitation.org folks basically encouraged/dared me to do this in their FAQ
20:46:07 <bos> Network.HTTP *should* work OK, but only up to about 1024 open files.
20:46:18 <gwern> bos: yes, that does seem to be the limit
20:46:20 <MyCatVerbs> gwern: to the best of my knowledge, Network.HTTP does not handle file descriptors in particularly beautiful ways.
20:46:34 <bos> MyCatVerbs: it just handles them in the usual way
20:46:39 <bos> via Network.Socket
20:46:50 <gwern> (I base this '1024 sounds right' on just looking at how many webcite acknowledgement emails land in my trash)
20:46:52 <MyCatVerbs> bos: I thought it was a bit crap about closing them? Not sure.
20:47:11 <MyCatVerbs> Plus I think there's a file handle limit in the GHC RTS, I think, aside from your ulimit -n entirely.
20:47:30 <MyCatVerbs> Don't quote me on that, though.
20:47:38 <bos> i know there is. it's 1024.
20:47:45 <bos> which is why i said 1024 :-)
20:47:58 <MyCatVerbs> bos: can you kick it up with an RTS option?
20:48:11 <encryptio> gwern: to be completely blunt, it's a stupid idea to have so many connections to a single site. you'd be better served limiting it to 10-50, and even that's a high number.
20:48:14 <bos> nope, it's a built-in limitation imposed by the RTS's use of select.
20:48:25 <gwern> encryptio: why is that?
20:48:31 <MyCatVerbs> bos: oh, select(2) is made of ouchies. I can see why that limit is in there.
20:48:35 <encryptio> because you won't gain anything from it
20:48:57 <gwern> (incidentally, if you're wondering by what I mean by daring me to do it: '# develop a wikipedia bot which scans new wikipedia articles for cited URLs, submits an archiving request to WebCite®, and then adds a link to the archived URL behind the cited URL'
20:49:00 <sclv_> when using Network.Socket directly tho, it is, and i speak from experience, very easy to accidently leave sockets open.
20:49:12 <ray> someone should write a haskell interface to kqueues
20:49:16 <encryptio> gwern: and what part of that says open THOUSANDS of simultaneous connections?
20:49:33 <sshc_> what is the haskell equivelent of the C typedef?
20:49:38 <gwern> encryptio: you appreciate the scale of WP?
20:49:44 <sclv_> the precise circumstances under which they are closed in event of various sorts of errors are rather undocumented and tricky to manage.
20:49:48 <MyCatVerbs> sshc_: type Foo = Bar;
20:49:50 <ray> sclv_: type i suppose
20:49:55 <sshc_> thanks
20:50:09 <MyCatVerbs> e.g. there's type String = [Char] somewhere in the base.
20:50:11 <ray> hrm
20:50:13 <gwern> I mean, even assuming they're only talkign about en!
20:50:19 <ray> i'm sure you guys are the same person anyway
20:50:19 <sclv_> i have some specific code to deal with it, but it would be nice to wrap it up and add it to the library.
20:50:26 <sclv_> my socket-fu is weaker than many however.
20:50:28 <encryptio> gwern: yes, and i know, for a fact, it's doable with a hundred. less if you're willing to let some lag through
20:50:39 <encryptio> and that's to WIKIPEDIA
20:51:38 <encryptio> that "bot" isn't meant to have the job be done in seconds after every edit. it's meant to have the job be done within days of the edit.
20:52:03 <gwern> within days? the article could be gone within minutes. its refs could be gone in days
20:52:14 <encryptio> then it wasn't very worthy, was it?
20:53:05 <gwern> as everyone knows, new page patrol is infallible
20:54:05 <encryptio> i still stand by my reasoning that it's a stupid idea to even consider using so much parallelism.
20:54:32 <encryptio> even without the very lenient time limitations i mentioned.
20:54:47 <sclv_> the bottleneck isn't going to be something that more threads solve, is the point.
20:55:01 <sclv_> they might just create a difft. bottleneck in fact.
20:55:53 <gwern> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5517
20:57:18 <hackagebot> HsOpenSSL 0.6.1
20:58:19 <Cale> or . map p = any p
20:58:24 <encryptio> worker model. put jobs (requests to either wp or webcite) in a queue (Chan (IO ()), probably) and have a fixed number of workers pull a job and do it.
20:59:56 <gwern> encryptio: and how much code would this cost me?
21:00:09 <encryptio> does your code work?
21:00:16 <gwern> seems to
21:00:30 <encryptio> then why are you having problems?
21:01:29 <gwern> my problem is that looking at the number of external links in articles, I think I should be seeing more reply messages from webcite
21:01:58 <gwern> my working theory being that the program is too slow and is being left behind by RC
21:14:01 <sshc_> what does this type signature mean?  "(Num b) => [a] -> b"
21:14:19 <pumpkin> it returns any instance of Num
21:14:54 <encryptio> it takes a list of anything and returns some number type (specifically, an instance of Num)
21:15:26 <dmwit> It also means, slightly less obviously, that the function cannot depend on any of the elements of the list; at most it depends on the length of the list.
21:16:22 <SamB_XP> @type genericLength
21:16:24 <lambdabot> forall b i. (Num i) => [b] -> i
21:16:31 <dmwit> ;-)
21:16:33 <pumpkin> that's different!
21:16:51 <SamB_XP> pumpkin: say what ?
21:17:06 * SamB_XP invokes the color rule
21:17:09 <pumpkin> (Num i) => [b] -> i vs. (Num b) => [a] -> b, can't you see they're different!!?!?
21:17:50 <aavogt> @type const 0 . flip asTypeOf []
21:17:51 <lambdabot> forall t a. (Num t) => [a] -> t
21:17:52 <dmwit> Of course, not all functions with that type are actually genericLength.
21:18:30 <SamB_XP> http://worrydream.com/AlligatorEggs/#colorrule
21:19:05 <pumpkin> @type \x -> snd (length x, 1)
21:19:07 <lambdabot> forall a t. (Num t) => [a] -> t
21:20:54 <aavogt> why the different order in the forall?
21:21:11 <dmwit> There's nothing deep about it.
21:21:31 <aavogt> just how the inference worked out?
21:21:48 <aavogt> @type \x -> fst (1,length x)
21:21:49 <lambdabot> forall t a. (Num t) => [a] -> t
21:21:54 * SamB_XP isn't sure why kids would mind *alligators* dying ...
21:21:57 <dmwit> aavogt: right
21:22:24 <hackagebot> Lucu 0.3
21:22:25 <SamB_XP> aavogt: there's no meaning to the order in a forall
21:22:48 <pumpkin> @hackage Lucu
21:22:48 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Lucu
21:23:10 <pumpkin> demonic!
21:23:24 <hackagebot> haskeem 0.6.10
21:23:55 <pumpkin> Network.HTTP.Lucu.Abortion o.O
21:24:01 <dmwit> There's an Abortion module!
21:24:04 <dmwit> damn, beat me to it
21:24:15 <sshc_> what is the purpose of (Num b)? (before the <=)
21:24:24 <dmwit> sshc_: It's a class constraint.
21:24:25 <pumpkin> sshc_: it puts a constraint on the type variable b
21:24:26 <SamB_XP> sshc_: you mean the =>
21:24:35 <dmwit> sshc_: It says that "b" has to be a type that implements the Num interface.
21:24:52 <dmwit> sshc_: Num has methods like (*), (+), (/), negate, etc.
21:25:02 <aavogt> @class
21:25:02 <lambdabot> Unknown command, try @list
21:25:07 <dmwit> ?src Num
21:25:07 <lambdabot> class  (Eq a, Show a) => Num a  where
21:25:07 <lambdabot>     (+), (-), (*)           :: a -> a -> a
21:25:07 <lambdabot>     negate, abs, signum     :: a -> a
21:25:07 <lambdabot>     fromInteger             :: Integer -> a
21:25:22 <sshc_> thanks, guys.
21:25:28 <dmwit> Okay, so (/) isn't in there, sorry for that bit of misinformation.
21:25:46 <dmwit> "This site is surely hosted by Lucu."
21:25:52 <dmwit> Glad we definitely know that! =)
21:26:49 <outchanter> ?src Fractional
21:26:49 <lambdabot> class  (Num a) => Fractional a  where
21:26:49 <lambdabot>     (/)             :: a -> a -> a
21:26:49 <lambdabot>     recip           :: a -> a
21:26:49 <lambdabot>     fromRational    :: Rational -> a
21:27:45 <aavogt> SamB_XP: yep. I was mostly wondering how type variable names are propagated
21:28:11 <SamB_XP> aapole: well, I think they have to sacrifice a virgin once a month or so ...
21:29:04 <SamB_XP> er.
21:29:06 <SamB_XP> aavogt:
21:29:11 <dmwit> :t genericLength :: [a] -> Num b => b -- this ought to confuse people
21:29:13 <lambdabot> on the commandline:
21:29:13 <lambdabot>     Warning: -fno-th is deprecated: use -XNoTemplateHaskell or pragma {-# LANGUAGE NoTemplateHaskell#-} instead
21:29:13 <aavogt> or rather, that the order in the forall depends on the order the expressions they represent occur (but clearly could be done differently)
21:29:38 <dmwit> Damn, I only confused myself
21:29:58 <SamB_XP> dmwit: no, I think Cale or gwern must have messed something up ...?
21:30:08 <SamB_XP> :t genericLength
21:30:10 <lambdabot> forall b i. (Num i) => [b] -> i
21:30:16 <Cale> hmm...
21:30:21 <dmwit> SamB_XP: Typing the same thing into ghci here makes ghc panic!
21:30:23 <SamB_XP> :t genericLength :: [a] -> Num b => b -- this ought to confuse people
21:30:24 <lambdabot> on the commandline:
21:30:24 <lambdabot>     Warning: -fno-th is deprecated: use -XNoTemplateHaskell or pragma {-# LANGUAGE NoTemplateHaskell#-} instead
21:30:28 <SamB_XP> what the!
21:30:37 <Cale> odd
21:30:40 <dmwit> SamB_XP: But I know I've done this before...
21:30:41 <SamB_XP> oh.
21:30:55 <SamB_XP> that's unusual syntax ...
21:31:02 <dmwit> Yes indeedy.
21:31:05 <aavogt> dmwit: implicitly doing Rank2 polymorphism?
21:31:13 <dmwit> aavogt: No rank-2 here.
21:31:15 <SamB_XP> maybe it messes up HSX ?
21:31:19 <dmwit> Plain old rank-1 polymorphism.
21:31:36 <SamB_XP> :t genericLength :: [a] -> Num b => b
21:31:37 <dmwit> The type should be totally equivalent to Num b => [a] -> b.
21:31:38 <lambdabot> on the commandline:
21:31:38 <lambdabot>     Warning: -fno-th is deprecated: use -XNoTemplateHaskell or pragma {-# LANGUAGE NoTemplateHaskell#-} instead
21:31:48 <SamB_XP> :t (genericLength :: [a] -> Num b => b)
21:31:49 <lambdabot> on the commandline:
21:31:49 <lambdabot>     Warning: -fno-th is deprecated: use -XNoTemplateHaskell or pragma {-# LANGUAGE NoTemplateHaskell#-} instead
21:31:54 <aavogt> [a] -> (forall b. Num b => b) -- isn't too far from what you put
21:32:09 <SamB_XP> :t [a] -> (forall b. Num b => b)
21:32:11 <lambdabot> parse error on input `->'
21:32:15 <aavogt> or is that just normal?
21:32:22 <SamB_XP> :t _ :: [a] -> (forall b. Num b => b)
21:32:24 <lambdabot> Pattern syntax in expression context: _
21:32:28 <QtPlaty[HireMe]> I have a structure S x which I wish to interate over the elemetents within this structure to generate a second struture S y.
21:32:31 <SamB_XP> :t undefined :: [a] -> (forall b. Num b => b)
21:32:32 <lambdabot> forall a b. (Num b) => [a] -> b
21:33:13 <dibblego> QtPlaty[HireMe], check out the (>>=) function
21:33:22 <QtPlaty[HireMe]> However the elements that I use within the second structure depend on all the previous elements I've iterated over.  What is the best abstraction for this?
21:34:04 <aavogt> SamB_XP: that clears it up for me
21:34:13 <BMeph> dibblego, QtPlaty[HireMe]: Perhaps, the (=>>) function is better? ;)
21:34:27 <dibblego> heh yeah praps
21:35:04 <QtPlaty[HireMe]> BMeph: Which libary is =>> in?
21:35:13 <BMeph> I wrote a function like that - I just broke it down all nasty-like. I'll have to see what comonads get me.
21:35:34 <BMeph> QtPlaty[HireMe]: That's in the category-extras lib. :)
21:35:44 <dmwit> aavogt: Sorry, I was filing a bug report.  Yeah, that's basically what I put, but it is still not rank-2 polymorphism. =)
21:36:20 <dmwit> rank-2 has foralls to the left of arrows
21:36:42 <dmwit> (rank-3 has a rank-2 type to the left of an arrow, rank-4 has a rank-3 type to the left of an arrow, etc.)
21:38:16 * aavogt wonders if rank-0 is not actually polymorphism, or something different...
21:38:58 <dmwit> Well, rank-1 polymorphism would have rank-0 types to the left of arrows, so... rank-0 sounds like monomorphism to me.
21:40:30 <QtPlaty[HireMe]> BMeph: Which module?
21:45:39 <BMeph> QtPlaty[HireMe]: Control.Comonad
21:47:10 <dancor> what is better x1:_ or x0:_
21:47:22 <dmwit> They look the same to me.
21:47:24 <dancor> don't say x:_, you have to choose one
21:47:31 <dancor> mm
21:47:36 <BMeph> dancor: What'sa wrong with x:_? ;p
21:47:37 <dmwit> 0-indexing is consistent with (!!)
21:47:38 <SamB_XP> y:_
21:47:44 <dancor> dmwit: that's true
21:47:59 <dancor> sold
22:01:06 <dmwit> Amazing.  I just found a book in my school's library via Google books that I couldn't find via our own catalog.
22:07:21 <pumpkin> wow
22:09:41 <dons> dmwit: google books knows what is in your library?
22:09:48 * dmwit nods
22:09:52 <dmwit> Amazing, isn't it?
22:10:09 <dons> is your library the library of congress?
22:10:13 <dmwit> hehe
22:10:45 <dmwit> Google apparently interfaces with worldcat.org.
22:10:51 <dmwit> It is way cool.
22:11:56 <dons> "Find this book in a library" <-- cool
22:12:12 <mmorrow> dancor: haha. i was dead serious :)
22:12:26 <dons> oh man, and it knows where i live.
22:13:03 <dons> huh. that is cool. so yeah, it says RWH is in a nearby library.
22:17:05 <bos> not bad. lazy text does "wc -w" on a 300MB UTF-8 file in 2.5x the time of the real "/usr/bin/wc -l".
22:17:18 <bos> and that's without the slightest attempt at speeding it up.
22:18:11 * bos loves combining quickcheck with code optimisation
22:18:12 <dons> hmm. its interesting how easy it is to beat wc. that was the first benchmark i used for strict bytestrings back in the day.http://haskell.org/haskellwiki/Wc
22:18:28 <dons> very small buffer size, in wc, iirc
22:19:47 <bos> my UTF-8 decoding code for chunked bytestrings is not in the slightest bit optimized :-)
22:19:52 <dons> mmm
22:20:02 <dons> chunked is a pain too, i bet.
22:20:14 <bos> it can be, but doesn't have to be awful.
22:20:28 <dons> so how far are we from recommending 'text' for the platform set?
22:21:13 <dmwit> dons: Do you respect locale the way wc does?
22:21:14 <bos> i'd really like people to start using it and reporting bugs and shortcomings for a few months.
22:21:30 <dmwit> I seem to recall wc does something wackily slow in some locales...
22:21:34 <bos> but in order to do that, it needs a little more performance tuning.
22:21:59 <bos> if i can speed up UTF-8 decoding by say 50%, i'll start asking people to actively use it.
22:27:21 <ryant5000> what would be a good datastructure for storing tags?  I need to be able to do queries that  accept any combination of "must have tag X" or "must not have tag Y"
22:27:51 <ryant5000> i.e.: taking tags as predicates, i should be able to specify any conjunction of possibly-negated predicates
22:28:32 <sjanssen> maybe Map Tag (Set object)?
22:28:52 <ryant5000> sjanssen: well, then i have to do intersections all the time; aren't they slow?
22:29:25 <ryant5000> (intersections and set-subtractions, i suppose)
22:29:31 <sjanssen> hmm, linear I suppose
22:30:02 <ryant5000> (if my analysis is correct, writing an efficient datastructure that allows *arbitrary* boolean expressions is equivalent to solving the binary satisfiability problem in P, so i'm not trying for that)
22:30:10 <mmorrow> dancor: here's an example of a prog that uses TH to gen code, and spits it to stdout (experimenting with unrolling... this particular attempt was a failure (==> much slower because of the overhead of more function calls))
22:30:12 <mmorrow> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5521
22:30:14 <ryant5000> linear in the size of the smallest set would be fine
22:30:20 <mmorrow> it spits 5500 lines of this to stdout:
22:30:30 <mmorrow> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5521#a5522
22:30:31 <ryant5000> but linear in the largest set isn't so good
22:30:54 <outchanter1> ryant: keep the sets in a heap?
22:33:12 <outchanter> wait, that wouldn't help
22:33:21 <sjanssen> ryant5000: it can be done in O(n log m) where n are the total number of objects in each tag an m is the number of tags
22:34:07 <ryant5000> outchanter: yeah, i need fast intersection, not fast union (had to look up heaps, lol; it's been a while)
22:34:14 <mmorrow> bos: re utf8 stuff, this is interesting http://www.daemonology.net/blog/2008-06-05-faster-utf8-strlen.html
22:34:22 <mmorrow> bos: __builtin_prefetch ftw
22:34:30 <ryant5000> sjanssen: how so?
22:34:37 <mmorrow> (ft huge w)
22:34:38 <bos> mmorrow: yeah
22:34:47 <bos> mmorrow: but not of much practical relevance here
22:34:55 <dmwit> ryant5000: How about Map Tag (Set object, Set object), where for each Tag, the union of the two sets is all of the objects?
22:34:57 <sjanssen> ryant5000: using an n-way merge algorithm
22:35:01 <mmorrow> bos: heh, true
22:35:12 <mmorrow> (although i secretly hoped it might be ;)
22:35:18 <outchanter> ryant5000: I meant to find the smallest set, but you'd only want the smallest out of the subset you're interested in, not all of them
22:35:35 <dmwit> ryant5000: So selecting those with tag foo is (fst . (!foo)), and selecting those without tag foo is (snd . (!foo)).
22:36:12 <dmwit> Adding or removing a tag from an object moves it from one Set to the other.
22:36:20 <mmorrow> i wonder what an ffi wrapper for gcc's __builtin_prefetch would give
22:36:29 <pumpkin> mmorrow: I don't think it's a function
22:36:29 <ryant5000> outchanter: ah, i see
22:36:34 <dmwit> Of course, you won't want to be adding tags that you've never seen before very often...
22:36:36 <mmorrow> pumpkin: just wrap it
22:36:46 <pumpkin> mmorrow: but ffi wrappers try to link to that symbol
22:36:51 <ryant5000> dmwit: yeah, that makes adding new tags really expensive
22:36:53 <sjanssen> ryant5000: basically you keep the sets in a min-heap, repeatedly popping the set with the smallest value, then putting it back with that value removed
22:36:55 <pumpkin> and it's not an exported symbol
22:37:00 <pumpkin> of anything
22:37:05 <mmorrow> pumpkin: sure, so wrap it in another C function :)
22:37:15 <mmorrow> and ffi import that
22:37:18 <pumpkin> mmorrow: oh, lol
22:37:33 <pumpkin> seems like we could make a primop for it though
22:37:35 <pumpkin> just like gcc did :P
22:37:40 <ryant5000> would it be helpful to think of this datastructure as a matrix of booleans with tags on one side and objects on another?
22:37:49 * mmorrow is wrapping it now
22:37:54 <pumpkin> mmorrow: TMI
22:38:03 <dmwit> > let merge ((x:xs):xss) = x : insert xs xss; merge ([]:xss) = merge xss; merge [] = [] in merge [[2,3,5], [4,6]]
22:38:04 <lambdabot>   Occurs check: cannot construct the infinite type: t = [t]
22:38:06 <sjanssen> ryant5000: are the set of tags closed?
22:38:06 <ryant5000> then it would be reminiscent of a Karnaugh (sp?) map
22:38:17 <mmorrow> touch hs-prefetch.cabal
22:38:17 <dmwit> > let merge ((x:xs):xss) = x : merge (insert xs xss); merge ([]:xss) = merge xss; merge [] = [] in merge [[2,3,5], [4,6]]
22:38:18 <lambdabot>   [2,3,4,5,6]
22:38:39 <dmwit> n-way merge for ascending lists =)
22:39:02 <ryant5000> sjanssen: hm; i'm not sure
22:39:23 <ryant5000> sjanssen: (i'm willing to make compromises on the API of this datastructure if they help a lot)
22:39:52 <sjanssen> ryant5000: anyway, I think n log m is pretty good, and the algorithm will be easy to write
22:40:26 <dmwit> ryant5000: May I suggest pushing this into a database?
22:40:39 <dmwit> Relations are what they're good at.
22:40:52 <ryant5000> sjanssen: yeah, that's probably good enough
22:40:57 <dmwit> And queries of the kind you're suggesting are definitely a one-liner in SQL.
22:41:13 <ryant5000> dmwit: well, i've struggled with that issue for a long time
22:41:27 <ryant5000> dmwit: there are lots of things i'd love to put in databases... but they're usually complicated Haskell datstructures
22:41:37 * dmwit nods
22:41:37 <ryant5000> dmwit: i don't want to serialize/deserialize stuff all the time
22:41:52 <ryant5000> i kind of want to build a haskell-native RDBMS
22:41:57 <outchanter> what algorithm does the average database use for finding intersections?
22:44:18 <outchanter> the fastest I can think of off the top of my head is (1) of the tags you're interested in, find the smallest set (assuming you have a map from tags to sets) (2) filter that set according to the other tags
22:44:48 <outchanter> which is order (sum of tags on item i for i in smallest set)
22:45:04 <pumpkin> if you already have an index (which many databases do) you can do it more efficiently
22:46:48 <outchanter> doesn't the map from tags to sets count as an index?
22:48:25 <mathijs> Hi all, I'm building a tree-like structure but I want some extra rules to apply, let's say that certain tupes of nodes can only 'grow' on top of some other nodes, but x..7 levels deep. ofcourse I can make a 'validate' function that checks if a tree plays by the rules, but I would like to put the typesystem to use somehow, since there aren't that many rules.
22:49:01 <sjanssen> outchanter: hmm, I like your idea better
22:49:01 <mathijs> s/7/y/
22:49:56 <sjanssen> O(n log m) where n is the smallest set, m are the number of tags you need to check
22:51:29 <sjanssen> wait, no.  O(n m log t), where t is the total number off tags.  Not so nice when your query involves lots of tags
22:51:52 <ryant5000> sjanssen: isn't it O(n t log m)?
22:52:50 <outchanter> it depends how you do the filtering. If each item has very few tags, you just have to check that none of them are forbidden and that all the required ones are there. If each item has very few tags and there are lots of required tags, your query will return no items anyway
22:53:15 <ryant5000> can we get any traction out of having a converse mapping?
22:53:23 <ryant5000> Map Object (Set Tag)?
22:53:41 <ryant5000> that might make filtering each object cheaper
22:53:55 <sjanssen> ryant5000: yes, you'd have to have this mapping as well
22:55:05 <sjanssen> the question is, given an object's tag set, the set of tags the object must have and must not have, what is the fastest way to determine whether the constraints are satisfied?
22:55:30 <sjanssen> sum of the cardinality of each set, right?
22:56:33 <ryant5000> sjanssen: yes, that's the question
22:58:07 <ryant5000> sjanssen: i suppose it could be as bad as the sum of the cardinalities of all the sets referred to in the query
22:58:58 <outchanter> actually I think you can do it in the smaller of the cardinalities
22:59:15 <outchanter> if the item has fewer tags than the number of required tags, it's out by default
23:00:21 <tibbe> does Haskell ship with a mutable array type equivalent of data Array a = Array { elems :: !(Ptr a), size :: !Int, capacity :: !Int } ?
23:00:32 <ryant5000> outchanter: yeah, that's true
23:00:46 <tibbe> for Storable a
23:00:54 <sjanssen> tibbe: StorableArray
23:01:26 <ryant5000> is there a tutorial on how to write your own rdbms?
23:01:34 <ryant5000> i'd like to just skim some stuff on it
23:01:46 <ryant5000> i guess that might be more of a "huge tome-like book" sort of thing
23:02:18 <ryant5000> i think ideally i'd like to be have a pile of objects
23:02:24 <ryant5000> and a bunch of projection functions
23:02:39 <ryant5000> with an index corresponding to each projection function
23:02:57 <ryant5000> and each index allows the objects to be looked up based on their projected values
23:03:00 <blackh> ryant5000: I am online and saying hello.
23:04:25 <solrize> is 6.10.3 the best ghc to use these days?  or should non-bleeding-edge users stay with earlier versions?
23:04:41 <dons> solrize: use whatever the haskell platform specifies
23:05:14 <solrize> "Note: the source tarball requires that you already have ghc-6.10.3 (or 6.10.4) installed."
23:05:22 <tibbe> sjanssen: does it used pinned memory or not? I only intend to pass it it "unsafe" FFI functions
23:06:04 <sjanssen> tibbe: via ForeignPtr, so pinned
23:06:18 <Cale> solrize: Yes, use the latest released GHC.
23:06:25 <solrize> thanks
23:06:44 <solrize> looks like that's 8.10.3 and not .4 ?
23:06:49 <solrize> 6.10.3
23:06:51 <Cale> yeah
23:07:01 <sjanssen> solrize: the only thing you generally want to wait on is the first minor release in a new major release series
23:07:04 <Cale> solrize: There are a few bugs in 6.10.1 and 6.10.2 which made them somewhat unusable for me.
23:07:15 <MyCatVerbs> I dunno, 6.6.2 had a nice, solid oaken feel to it.
23:07:28 <solrize> yeah, i remember hearing something about the first 6.10's being for early adopters
23:07:34 <solrize> downloading
23:07:39 <MyCatVerbs> 6.8.* weren't that much of a step up or down. 6.10.3's good, though.
23:07:41 <sjanssen> solrize: things tend to break, and it's usually a month or so before most of hackage catches up
23:07:46 <tibbe> sjanssen: so if I want to pass it to the kevent system call on Mac OS X I want a StorableArray? Is it unboxed?
23:08:03 <solrize> i can install 6.10.3 over top of the 6.8.2 that i'm already using?
23:08:10 <sjanssen> tibbe: you should probably see the fine manual at this point
23:08:24 <tibbe> sjanssen: the GHC manual you mean?
23:08:31 <Cale> solrize: yes, though it won't overwrite it
23:08:32 <quicksilver> tibbe: I'm not sure your question even makes sense.
23:08:33 <sjanssen> tibbe: the docs for Data.Array.Storable
23:08:38 <solrize> cool
23:08:39 <quicksilver> tibbe: a Ptr is a Ptr.
23:08:52 <quicksilver> tibbe: although Ptrs themselves are boxed, the data they point to is just data.
23:09:01 <MyCatVerbs> solrize: yeah, they put everything into entirely seperate directories, except for the top-level invocation stuff in /usr/local/bin.
23:09:03 <tibbe> quicksilver: I want to pack it together with the capacity and current number of used elements
23:09:23 <tibbe> quicksilver: and I want a type that unpacks nicely like the one I gave above
23:10:02 <MyCatVerbs> solrize: AFAIK most of the GHC devs have at least three forgotten but still working copies of GHC hanging around in various places in their filesystems. It's a pretty well-supported situation, all told. ;)
23:10:06 <Cale> tibbe: The bounds of the array will already be available from getBounds
23:10:49 <Cale> tibbe: A Storable array is unpacked, in fact, it's usable from C code, since it uses the Storable instance to write the elements into a continuous block of memory.
23:10:56 <sjanssen> tibbe: the array infrastructure actually provides more than you want, you'd probably be better off with your own type
23:11:05 <tibbe> Cale: right, that's what I want. I initially rolled my own array type which had fields for bounds and size. I was wondering if there's a predefined type I could use
23:12:00 <tibbe> sjanssen: want I'm trying to do is to implement a growable array which I from time to time will pass to C
23:12:05 <bos> tibbe: i wouldn't use StorableArray. it's pretty heavyweight.
23:12:28 <tibbe> bos: :)
23:12:32 <tibbe> bos: there you are
23:12:47 <tibbe> bos: I need a growable array for kqueue
23:12:51 <roconnor> tibbe: doesn't Edison implement containers such as that?
23:12:52 <tibbe> bos: I rolled my own
23:12:58 <tibbe> roconnor: dunno
23:13:02 <bos> tibbe: seems like a reasonable thing to do.
23:13:07 <tibbe> roconnor: I need a pretty barebones container
23:13:10 <tibbe> bos: OK
23:13:20 <roconnor> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/EdisonCore
23:13:29 <tibbe> roconnor: I'll have a look
23:13:35 <MyCatVerbs> bos: it's perfectly cromulent for conversing with C code. And AIUI the only interesting slowdown it should have in current GHC is that they're much slower to allocate than IOU or STU arrays.
23:13:37 <sjanssen> tibbe: StorableArray also isn't growable
23:13:38 <roconnor>     * Data.Edison.Seq.BankersQueue
23:13:43 <roconnor> Data.Edison.Seq.MyersStack
23:13:53 <tibbe> bos: I'm thinking about putting a Haskell function
23:13:56 <roconnor> Data.Edison.Assoc.PatriciaLoMap
23:14:03 <tibbe> bos: (pointer) in the Storable instance
23:14:07 <roconnor> I don't even know what these are!
23:14:13 <roconnor> it must be good!
23:14:14 <tibbe> bos: so I can easily get hold of it once an event fires
23:15:20 <mmorrow> pumpkin: hs-prefetch: http://moonpatio.com/repos/hs-prefetch/
23:15:24 <bos> tibbe: yep
23:15:26 <pumpkin> mmorrow: zomg
23:15:37 <mmorrow> it's got function to prefetch ByteString for either read or writes
23:15:38 <tibbe> bos: would I use FunPtr for that?
23:15:45 <solrize> GHCi, version 6.10.3: http://www.haskell.org/ghc/  :? for help
23:15:45 <solrize> Loading package ghc-prim ... linking ... done.
23:15:45 <solrize> Loading package integer ... linking ... done.
23:15:45 <solrize> Loading package base ... linking ... done.
23:15:45 <solrize> Prelude>
23:15:45 <mmorrow> and with 4 levels of temporal locality
23:15:46 <solrize> woo hoo
23:15:48 <solrize> thanks
23:15:55 <mmorrow> http://moonpatio.com/repos/hs-prefetch/haddocks/
23:15:58 <pumpkin> mmorrow: does it make any difference?
23:16:03 <bos> tibbe: you want to be able to call it from C? i think so, then.
23:16:17 <tibbe> bos: no, just from Haskell
23:16:18 <mmorrow> pumpkin: i haven't even tried it yet :)
23:16:24 * bos does calls from C to Haskell once a year, maybe, so always has to RTFM then
23:16:28 <pumpkin> mmorrow: but it compiles so it must be correct, right? :D
23:16:34 <bos> tibbe: oh, then just store the function directly.
23:16:37 <pumpkin> mmorrow: I'd be interested though
23:16:47 <mmorrow> pumpkin: i'm definitely going to test it out
23:16:48 <MyCatVerbs> pumpkin: I call your dangerous assumptions and raise you fix id.
23:16:57 <tibbe> bos: it needs to be persisted on the C side though in a void * field
23:17:08 <bos> tibbe: i see.
23:17:09 <pumpkin> MyCatVerbs: you don't know my definition of correct :D
23:17:21 <tibbe> bos: so some kind of stable pointer
23:17:28 <bos> tibbe: right
23:17:29 <tibbe> bos: so the GC won't move the closure
23:17:50 <tibbe> bos: I'm a bit lost in the pletoria of *Ptrs in the FFI spec
23:17:59 <tibbe> bos: I'll go rtfm again
23:18:11 <pumpkin> mmorrow: maybe worth making a prefetch :: TemporalLocality -> a -> IO () ?
23:18:12 <MyCatVerbs> pumpkin: so far I'm beginning to suspect that it comes to, "generates an executable file which matches the pattern B*, where B denotes a byte in the range 0-255." ;P
23:18:20 <pumpkin> :P
23:18:31 <pumpkin> what if it doesn't even do that
23:19:10 <MyCatVerbs> tibbe: for throwing bare Ptrs around, Foreign.Storable and Foreign.Marshall.Alloc.
23:19:38 <tibbe> MyCatVerbs: are Ptrs relocatable or not?
23:19:48 <bos> tibbe: a Ptr is a C pointer
23:19:51 <MyCatVerbs> tibbe: Christ no.
23:20:08 <tibbe> bos: so then that won't work for the void* user data field
23:20:11 <pumpkin> mmorrow: or even just a referentially transparent version, prefetch :: a -> a that acts a bit like a seq (maybe the form I'd like to see if it were a primop)
23:20:14 <bos> right.
23:20:43 <bos> tibbe: the magic needed for the ability to store a pointer to a haskell function in a C-compatible way is a bit involved.
23:20:51 <bos> i think dons has an example of it in the FFI chapter of RWH.
23:20:56 <pumpkin> mmorrow: since it should never affect the behavior of your program if you provide it a valid address
23:21:10 <bos> it's nice to be able to read one's own book for examples of stuff one forgets how to do.
23:21:45 <mmorrow> pumpkin: here're the opcodes it uses on x86_64: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2544
23:21:48 <MyCatVerbs> tibbe: generally, alloca (in Foreign.Marshal.Alloc) if you want to allocate space for a single temp variable, and usually use StorableArrays if you want to cons up arrays that are easy to access from both C and Haskell.
23:21:59 <mmorrow> pumpkin: yeah, inlinePerformIO even
23:22:35 <tibbe> bos: I tend to reread RWH for the FFI stuff often
23:22:50 <tibbe> MyCatVerbs: ok
23:22:51 <MyCatVerbs> tibbe: for passing structs around, you really ought to use hsc2hs or something, because doing it all by hand is no fun at all.
23:22:54 <mmorrow> pumpkin: hmm, but prefetch :: TemporalLocality -> a -> IO () ... how do you get the ptr to `a'?
23:23:02 <tibbe> MyCatVerbs: I use hsc2hs
23:23:08 <mmorrow> (just saw that part)
23:23:18 <tibbe> MyCatVerbs: the problem is that I want to store a pointer to a haskell function in a C struct
23:23:32 <pumpkin> mmorrow: it's gotta be somewhere? :P GHC knows where to go look for the box
23:23:34 <mmorrow> pumpkin: (or are you assuming here it's been made a
23:23:36 <mmorrow> ok
23:23:42 <mmorrow> .. made a primop)
23:23:48 <pumpkin> unpackClosure maybe in the mean time?
23:23:52 <pumpkin> #
23:24:06 <pumpkin> not sure if that'd be meaningful unless you had a lot of unboxed values in your constructor though
23:24:37 <mmorrow> oh, i know of a way that's steals an StgClosure* from a StablePtr, but that has the overhead of making a StablePtr..
23:24:45 <MyCatVerbs> tibbe: and my last bit of advice is that if you feel the need to use FunPtr... Christ, that's a pain in the neck, rethink a little ;)
23:24:49 <mmorrow> (and the Ptr can move next GC)
23:24:51 <pumpkin> mmorrow: it doesn't need to be stable though
23:25:11 <mmorrow> but i need the StablePtr to get at the StgClosure*
23:25:20 <tibbe> MyCatVerbs: heh
23:25:25 <mmorrow> (there's literally no non-haX way)
23:25:29 <pumpkin> doesn't unsafeCoercing any value to an Addr have that effect though?
23:25:40 <pumpkin> any evaluated
23:25:41 <mmorrow> pumpkin: possibly
23:25:41 <MyCatVerbs> tibbe: oh, there's also Foreign.ForeignPtr if you want a slightly lighter-weight alternative to Data.Array.Storeable.
23:25:41 <solrize> oh man, the platform has a bunch of ubuntu package dependencies that aren't so easy to figure out
23:25:53 <mmorrow> pumpkin: try it!
23:25:54 <pumpkin> mmorrow: I mean, it can't too indirect to get at the location in memory
23:25:55 <pumpkin> lol
23:26:08 <mmorrow> you'd probably want to seq it too
23:26:13 <mmorrow> (or better, pseq it)
23:26:30 <tibbe> MyCatVerbs: as I understand it it's safe to pass a Ptr to C if the C function is "unsafe" and doesn't hold on to the Ptr
23:26:51 * mmorrow gives it 5-7% chance of working, but that's > 0% ;)
23:27:19 <MyCatVerbs> tibbe: er, the situation is not quite *that* bad. :)
23:28:01 <mmorrow> pumpkin: hmm, you probably want to coerce it to an unboxed type (i don't think you're allowed though..)
23:28:11 <MyCatVerbs> tibbe: it's safe to pass a Ptr to C if the C code won't attempt to use that Ptr after it's no longer being backed by memory. Different ways of getting ahold of Ptrs have different lifespans!
23:28:13 <pumpkin> I was planning on doing Addr#
23:28:19 <mmorrow> ooh nice
23:28:37 <MyCatVerbs> tibbe: e.g. Ptrs from alloca become invalid as soon as the IO action passed to alloca returns.
23:28:38 <mmorrow> can you coerce to unboxed types?
23:28:49 <pumpkin> with unsafeCoerce# you can
23:28:53 <mmorrow> woo
23:29:08 <tibbe> MyCatVerbs: but if I mallocArray to get a pointer can I pass that to C?
23:29:15 <MyCatVerbs> tibbe: Ptrs from malloc won't ever become invalid until you pass them to free, after which they're in crazytown.
23:29:20 <tibbe> MyCatVerbs: is that malloc on the C side
23:29:47 <MyCatVerbs> tibbe: I mean Foreign.Marshal.Alloc.malloc -- where's mallocArray?
23:29:54 <mmorrow> grr Couldn't match kind `*' against `#'
23:30:08 <pumpkin> ur doin it rong
23:30:32 <tibbe> MyCatVerbs: Foreign.Marshal.Array
23:30:37 <Gracenotes> ugh. I always forget what Russel's paradox is
23:31:02 <Gracenotes> only that set containing itself is paradoxical
23:31:07 <MyCatVerbs> tibbe: yeah, those are all implemented using malloc. You'll need to free them afterwards, of course.
23:31:13 <Gracenotes> or something like that
23:31:22 <tibbe> MyCatVerbs: so no free finalizer attached by default?
23:31:38 <MyCatVerbs> No. ForeignPtrs have finalisers, but malloc and free work just like in C.
23:31:58 <solrize> tons of "magic number mismatch" errors from depended packages
23:32:19 <mux> mallocForeignPtr calls malloc and attaches a finalizer at the same time
23:32:19 <MyCatVerbs> Most of the time you want to allocate with a ForeignPtrs. The Ptrs you get from ForeignPtrs stay alive until the final time that touchForeignPtr is called on the ForeignPtr.
23:32:46 <mux> but if you can use alloca instead, it's even better/safer
23:33:19 <solrize> compiler warnings
23:33:40 <MyCatVerbs> The most common way to use ForeignPtrs is a combinator called (withForeignPtr), which unwraps the ForeignPtr to give you a Ptr, executes the IO action that you pass to it, and then calls touchForeignPtr afterwards. That way the lifetime never comes out wrong.
23:33:40 <smorg> Gracenotes: sets that are not members of themselves.
23:34:01 <Gracenotes> right
23:34:11 <Gracenotes> also, hurray wikipedia
23:34:21 <tibbe> MyCatVerbs: I'm rereading the ffi spec ;)
23:34:35 <MyCatVerbs> The dude in Bristol who shaves the faces of the dudes in Bristol who do not shave their faces themselves.
23:34:57 <MyCatVerbs> Does that dude shave his own face? Scary knives to the first person who figures it out.
23:35:18 <lindzeyn> Russel's Paradox
23:35:30 <lindzeyn> *Russell
23:35:52 <mmorrow> pumpkin: dang, doesn't seem to work (the way i just tried at least)
23:35:52 <outchanter> it works if you add a delay. He could shave himself on alternate days
23:36:06 <pumpkin> isn't working for me either, but I haven't given up!
23:36:27 <MyCatVerbs> tibbe: I think SPJ's "Tackling the Awkward Squad" notes had a whole thing on the FFI, and it's fun to read besides. Perhaps you might want to hit it at some point.
23:36:49 <tibbe> MyCatVerbs: I'll put it on top of my reading stack
23:36:53 <smorg> barber paradox woot
23:37:05 <tibbe> > push readingStack "awkward squad"
23:37:06 <lambdabot>   Not in scope: `push'Not in scope: `readingStack'
23:37:08 <MyCatVerbs> I would like to note that Russell's Paradox sort of slinks away if you refuse to work in naive sets, but instead exclusively in recursively enumerable sets.
23:37:10 <mmorrow> pumpkin: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2544#a2545  fail
23:37:35 <MyCatVerbs> Then the question of the dude's face-shavery becomes trivial. You just reject it, because it's not a computable set. ^^
23:37:58 <smorg> Doesn't haskell being strongly typed fix such problems?
23:38:05 <lindzeyn> Yes it does smorg
23:38:16 <MyCatVerbs> smorg: ahahahaahah.
23:38:18 <tibbe> hmm, when should one use an array allocated on the Haskell heap vs. the C heap?
23:38:18 <MyCatVerbs> smorg: it helps. :)
23:39:00 <MyCatVerbs> tibbe: you pretty much always want to do your allocations in Haskell. Haskell's allocators are much faster than C malloc.
23:39:07 <pumpkin> mmorrow: there's got to be a way! :P
23:39:21 <tibbe> MyCatVerbs: but didn't we just conclude that mallocArray et al used C malloc?
23:39:28 <pumpkin> the true address can't be far off from whatever gets passed around in GHC
23:39:48 <solrize> crashed with "configuring the editline-0.2.1.0 package failed".  i opened trac ticket #56
23:40:35 <mmorrow> pumpkin: i tried for a good week and came up with nothing but that StablePtr hack (which depends on the particular workings of Stable.c)
23:40:58 <MyCatVerbs> tibbe: IIRC they do indeed. But ForeignPtrs are allocated from Haskell's heap, and alloca is allocated on the stack.
23:41:08 <mmorrow> pumpkin: the best part of it too is that the true address is so close you don't even realize it's there
23:41:20 <lindzeyn> Is the problem still paradoxical if you use classes as presented in PM
23:41:32 <mmorrow> reallyUnsafePtrEquality# is implemented with cmp
23:41:36 <mmorrow> (or something)
23:41:54 <mmorrow> you literally have the ptrs but you can't touch them!
23:42:08 <pumpkin> hmm
23:42:10 <pumpkin> feels fishy
23:42:17 <MyCatVerbs> tibbe: in terms of allocation speed, it goes (roughly): registers are fastest, then alloca, then Haskell values, then ForeignPtr, then malloc is way off in the corner feeling sorry for itself.
23:42:53 <tibbe> MyCatVerbs: then ForeignPtr it is
23:43:08 <mmorrow> pumpkin: emitPrimOp [res] ReallyUnsafePtrEqualityOp [arg1,arg2] _ = stmtC (CmmAssign (CmmLocal res) (CmmMachOp mo_wordEq [arg1,arg2]))
23:43:38 <MyCatVerbs> (No, you don't get control over what values end up in registers. But hey, maybe if we're all really good boys and girls, Simon Claus will have made the optimizer even cleverer by the time next Christmas rolls past.
23:44:30 <mmorrow> pumpkin: (one could of course add a primop that hands you a ptr to whatever it gets passed and then watches with amusement as you blow your abdomen in half :)
23:45:12 <pumpkin> yeah :)
23:45:17 <mmorrow> do it!
23:45:35 <MyCatVerbs> mmorrow: aren't there already, like, three in GHC.Base alone?
23:45:53 <mmorrow> MyCatVerbs: not to get the ptr itself
23:46:18 <mmorrow> (they change every gc..)
23:46:35 * MyCatVerbs nods. The perils of compacting GC.
23:46:50 <tibbe> MyCatVerbs: hmm, ForeignPtrs can't be realloced
23:47:32 <pumpkin> bah, this is really pointless :P but it should be possible!
23:47:42 <pumpkin> surely what we're passing around is the pointer to the closure
23:47:55 <pumpkin> when it boils down to it
23:48:40 <MyCatVerbs> tibbe: indeed they can't. I think the only thing that *does* let you realloc is plain old malloc.
23:48:43 <Gracenotes> soooooo.
23:48:47 <dons> solrize: the platform source for unix requires you to install C libraries
23:49:02 <dons> it would be far better if it was just packaged for your distro.
23:49:05 <tibbe> MyCatVerbs: ok
23:49:29 <tibbe> dons: what data type would you use for a growable mutable array that needs to be passed to C?
23:49:34 <MyCatVerbs> tibbe: On the bright side, that won't really hurt you interestingly badly unless you are allocating thousands of the things. And, hey, most C programmers seem to be just about happy with their malloc() implementations.
23:49:37 <mmorrow> pumpkin: ly
23:49:41 <mmorrow> exact
23:49:49 <pumpkin> orrow
23:49:55 <dons> tibbe: hmm. Foreign.Marshall.Array
23:49:58 <pumpkin> mm: you feeling backwards?
23:49:59 <dons> (supports realloc)
23:50:23 <tibbe> dons: we were just discussing allocation speed of Ptrs vs ForeignPtrs
23:50:26 <mmorrow> pumpkin: more inside outy
23:50:27 <solrize> dons, i think it would help if it said exactly what packages to install.  also it's not obvious that the editline configuration error is due to a C library installation issue
23:50:45 <tibbe> dons: I want realloc that often (I expect the size to grow to some constant C and stop there)
23:51:15 <MyCatVerbs> tibbe: trust me that that'll be fine. Just make sure you always grow by *doubling* the size of your array, not by adding a constant factor.
23:51:48 <tibbe> MyCatVerbs: I'll give it a whirl
23:53:18 <sjanssen> MyCatVerbs: I've read that increasing according the the Fibonacci sequence is typically better
23:53:23 <dons> solrize: hmm, how can we find out what package they're called on each system?
23:53:35 <dons> via a wiki? maybe we should just encourage distros *more*
23:53:45 <dons> to solve it on the distro side, rather than on the ./configure side
23:54:46 <araujo> hello
23:54:47 <MyCatVerbs> sjanssen: asymptotically it's O(1) either way, and most malloc implementations work in powers of two until you get up to *really* big allocations, no?
23:55:00 <araujo> anybody knows a good site with nice algorithms implemented in Haskell?
23:55:35 <sjanssen> MyCatVerbs: I'm not sure what most mallocs do, just thought I'd share
23:55:37 <lindzeyn> google quicksort,Haskell
23:55:51 <MyCatVerbs> sjanssen: where did you *hear* that? oO
23:56:00 <sjanssen> MyCatVerbs: don't remember
23:56:26 <MyCatVerbs> araujo: there are a number of pretty good Haskell blogs around the place. That's how I usually get my fix. :)
23:57:18 <MyCatVerbs> araujo: http://augustss.blogspot.com/ <- does some interesting things, twisting Haskell to make it look like languages that are not Haskell.
23:57:18 <araujo> MyCatVerbs, I know, just asking if anybody knew a place specially dedicated on this
23:57:57 <solrize> dons, distro maintainers tend to have their own views of things and be hard to convince, so a wiki seems like an ok approach.  also it would be good to have a way to build the platform without the gui stuff.  the gui stuff shouldn't be essential if the platform is supposed to be available in every ghc system.  some of them (like embedded systems) may not have any gui at all.
23:58:57 <blackdog> lindzeyn: argh, do we have to? that quicksort implementation quite rightly gets torn apart when people start counting the number of operations it does...
23:59:12 <MyCatVerbs> araujo: Conal Elliott's blog is nifty - http://conal.net/blog/ and sigfpe's is generally e...
