00:00:09 <Zao> I doubt any self-respecting pirate would touch a book.
00:00:26 <osfameron> ARRRows!
00:00:34 <Taggnostr> how can I do a multiline comment?
00:00:52 <cizra> Taggnostr: {- ... -}
00:00:58 <Taggnostr> thanks
00:00:58 <Zao> osfameron: ...
00:00:59 <Adamant_> Zao: the modern ones have double-entry bookkeeping and timecards
00:01:46 <Zao> Bad Haskell pirates get to tie their own noose knot.
00:02:40 <Guest47479> i havent paid for books about 4 years
00:07:58 <mmorrow> ryant5000: i'd use mersenne twister, since System.Random is slooow
00:09:03 <dmwit> Guest47479: To Mock a Mockingbird costs what, $10? $20?
00:09:22 <dmwit> Consider: the computer you're on probably cost $500-$1000.
00:09:30 <dmwit> Would you have noticed if that range was $510-$1010 instead?
00:10:01 <Taggnostr> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6137#a6137 impressive
00:10:26 <dmwit> Taggnostr: There are implementations that are faster still.
00:10:39 <Zao> Guest47479: Bragging about not paying for things in a channel full of software developers will in general not earn you any points.
00:11:20 <Guest47479> <dmwit> thanx for the information, but its not possible to reach/get a hardcopy for my situation.
00:11:35 <dmwit> I don't believe you.
00:11:45 <Guest47479> but piracy is another issue
00:12:09 <johnnowak> need is not a claim. find a legitimate way to get the book.
00:12:19 <Guest47479> i dont agree with you about "Bragging about not paying for things in a channel full of software developers will in general not earn you any points."
00:12:40 <inimino> I disagree with that as well
00:12:43 <Zao> I'm sure that there's at least one store in let's see... Turkey that carries the book.
00:12:49 <inimino> though I doubt this channel is the place for the great IP debate ;)
00:13:36 <Guest47479> unfortunately there is not <Zao>
00:13:48 <Zao> Have you've checked them all?
00:14:05 <Guest47479> all? im not sure about that
00:14:13 <Guest47479> but i couldnt find
00:14:34 <johnnowak> you've no friends on the planet that can buy you the book and mail it to you?
00:15:07 <Guest47479> <johnnowak> no :(
00:24:02 <Taggnostr> how can I display the number here -> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6137#a6137 in esponential form?
00:25:35 <Zao> If it had been floating you could have used Text.Printf.printf "%g"
00:25:50 <dmwit> It's much too big for Float/Double, I think.
00:27:19 <Taggnostr> are there alternatives?
00:27:35 <mmorrow> , showFFloat (Just 9) pi []
00:27:36 <lunabot>  "3.141592654"
00:27:37 <mmorrow> , showFFloat (Just 2) pi []
00:27:38 <Zao> let s = show n in printf "%c.%se%d" (head s) (take 5 . tail $ s) (length magic here s)
00:27:38 <lunabot>  "3.14"
00:27:49 <dmwit> > let integralExponential x = case show x of { s | length s < 10 -> s; (d:ds) -> d:'.': take 9 ds ++ 'e' : length ds } in integralExponential 1234567890123
00:27:51 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
00:28:02 <dmwit> > let integralExponential x = case show x of { s | length s < 10 -> s; (d:ds) -> d:'.': take 9 ds ++ 'e' : show (length ds) } in integralExponential 1234567890123
00:28:03 <lambdabot>   "1.234567890e12"
00:28:44 <mmorrow> , showEFloat (Just 4) (pi^42) []
00:28:45 <lunabot>  "7.5909e20"
00:29:16 <dmwit> > let integralExponential x = case show x of { s | length s < 10 -> s; (d:ds) -> d:'.': take 9 ds ++ 'e' : show (length ds) } in integralExponential (product [1..5000])
00:29:17 <lambdabot>   "4.228577926e16325"
00:29:21 <mmorrow> , ''showFFloat
00:29:22 <dmwit> Taggnostr: done
00:29:23 <lunabot>  luna: Not in scope: type variable `showFFloat'
00:29:36 <mmorrow> Numeric.show*Float
00:29:51 <dmwit> :t Numeric.showFFloat
00:29:52 <lambdabot> forall a. (RealFloat a) => Maybe Int -> a -> String -> String
00:30:00 <dmwit> ?instances RealFloat
00:30:01 <lambdabot> Double, Float
00:30:01 <Taggnostr> uhm
00:30:14 <dmwit> mmorrow: Let me know when Double can store 1e16325.
00:30:16 <dmwit> =)
00:30:30 <Taggnostr> thanks, let me play with it
00:30:33 <mmorrow> Taggnostr: if you're looking to show Double/Float, use the stuff in Numeric
00:30:55 <mmorrow> dmwit: is that max Double + 1 or something :)
00:31:09 <dmwit> > maxBound :: Double
00:31:10 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Types.Double)
00:31:11 <lambdabot>    arising from a use o...
00:31:26 <dmwit> mmorrow: I think it's significantly more than maxBound :: Double.
00:31:32 <dmwit> > 1.16325 :: Double
00:31:33 <lambdabot>   1.16325
00:31:36 <dmwit> > 1e16325 :: Double
00:31:37 <lambdabot>   Infinity
00:31:44 <dmwit> > 1e1325 :: Double
00:31:45 <lambdabot>   Infinity
00:31:48 <mmorrow> > 1e1024
00:31:48 <dmwit> > 1e132 :: Double
00:31:50 <lambdabot>   Infinity
00:31:50 <lambdabot>   1.0e132
00:31:55 <mmorrow> > 1e512
00:31:56 <lambdabot>   Infinity
00:32:23 <Zao> eps(1e16325)  gives ans = NaN in MatLAB.
00:32:24 <mmorrow> i forgot how to figure it out
00:32:25 <dmwit> mmorrow: Anyway, Taggnostr wanted to see 5000! in scientific notation.
00:32:44 <mmorrow> dmwit: i didn't realize 5000 was so exciting!
00:32:50 <dmwit> > 1e16325 :: Rational
00:32:52 <lambdabot>   100000000000000000000000000000000000000000000000000000000000000000000000000...
00:33:01 <dmwit> Haskell > MatLAB
00:33:03 <Taggnostr> it's not, that's just the beginning
00:33:22 <mmorrow> heh, 5000!
00:33:28 <mmorrow> (bad joke)
00:33:36 <mmorrow> :)
00:34:01 <Zao> dmwit: When it comes to easy numeric and linalg prototyping, I pick matlab over Haskell.
00:34:07 <Zao> Mostly because vector-space scares me.
00:34:24 <dmwit> Yeah, for quick-and-dirty matrix stuff, matlab is better.
00:34:27 <dmwit> But J is better yet.
00:34:32 <Zao> Does Haskell have an eps-like function?
00:34:38 <Twey> How about APL?
00:34:40 <mmorrow> , decodeFloat (1/0)
00:34:41 <lunabot>  (4503599627370496,972)
00:34:50 <dmwit> :./* 3+    (this is a complete game of life in J)  (just kidding)
00:34:51 <Zao> (distance to next representable number)
00:35:00 <mmorrow> , logBase 2 4503599627370496
00:35:02 <lunabot>  52.0
00:35:10 <mmorrow> , logBase 2 972
00:35:11 <lunabot>  9.92481250360578
00:35:12 <Taggnostr> Twey, have you seen http://www.youtube.com/watch?v=uKfKtXYLG78 ?
00:35:16 <mmorrow> err, gah
00:35:38 <mmorrow> , toInteger (1/0)
00:35:38 <lunabot>  luna: Ambiguous type variable `t' in the constraints:
00:35:42 <mmorrow> , toInteger (1/0::Double)
00:35:43 <lunabot>  luna: No instance for (GHC.Real.Integral GHC.Types.Double)
00:35:47 <dmwit> Zao: Not that I know of.
00:36:10 <mmorrow> , ceiling (1/0::Double) :: Integer
00:36:12 <lunabot>  1797693134862315907729305190789024733617976978942306572734300811577326758...
00:37:20 <dmwit> > let integralExponential x = case show x of { s | length s < 10 -> s; (d:ds) -> d:'.': take 9 ds ++ 'e' : show (length ds) } in integralExponential (ceiling (1/0 :: Double) :: Integer)
00:37:21 <lambdabot>   "1.797693134e308"
00:37:38 <dmwit> > 1.79e308 :: Double
00:37:39 <lambdabot>   1.79e308
00:37:43 <dmwit> > 1.8e308 :: Double
00:37:44 <lambdabot>   Infinity
00:37:48 <dmwit> neat
00:38:19 <Axman6> > 1.8e308 :: CReal
00:38:20 <lambdabot>   180000000000000000000000000000000000000000000000000000000000000000000000000...
00:38:51 <mmorrow> , length . takeWhile (> 0) . iterate (`div` 2) $ (ceiling (1/0::Double) :: Integer)
00:38:52 <lunabot>  1025
00:39:18 <mmorrow> , length . takeWhile (> 1) . iterate (`div` 2) $ (ceiling (1/0::Double) :: Integer)
00:39:19 <lunabot>  1024
00:39:55 <mmorrow> , logBase 2 . fromIntegral . length . takeWhile (> 1) . iterate (`div` 2) $ (ceiling (1/0::Double) :: Integer)
00:39:56 <lunabot>  10.0
00:39:57 <dmwit> > 2 ^ 1024
00:39:59 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
00:40:04 <dmwit> aha
00:40:05 <mmorrow> 10 bit exponent i think this means
00:40:16 <mmorrow> or something
00:40:21 <mmorrow> err, is it 11?
00:40:21 <Axman6> yeah
00:40:23 <dmwit> > 2 ^ 1024 - ceiling (1/0 :: Double) :: Integer
00:40:24 <lambdabot>   0
00:40:26 <dmwit> wow
00:40:34 <dmwit> Oh, of course.
00:40:37 <Axman6> > 2^1024
00:40:39 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
00:42:16 <Axman6> > 2^1024 :: Double
00:42:17 <Gracenotes> annoying how ghci crashes when gmp does into overdrive
00:42:18 <lambdabot>   Infinity
00:42:30 <Gracenotes> can't interrupt
00:42:33 <dmwit> Gracenotes: ^Z works every time
00:42:34 <Gracenotes> goes
00:42:53 <dmwit> And I agree that it's annoying.
00:42:57 <Gracenotes> dmwit: iirc it crashed once for me
00:43:07 <Zao> ghci's recent change of editing libraries get me all the time.
00:43:15 <Zao> ^Z<CR> doesn't exit it anymore.
00:43:26 <Zao> Now it's ^D for EOF, which is quite unusual.
00:43:27 <dmwit> Zao: Windows?
00:43:32 <Zao> Yup.
00:43:39 <dmwit> I think I spotted your problem. ;-)
00:43:47 <Gracenotes> actually, the most recent total crash was due to something like length $ sequence $ replicate 2 <$> ['a'..'z']
00:43:59 <Gracenotes> which should be 2^26
00:44:06 <Gracenotes> but it balked badly
00:44:22 <dmwit> I guess I'm not surprised.
00:44:42 <dmwit> That's trying to allocate and free somewhere around 2^30 bytes...
00:44:56 <Gracenotes> at first I had mistakenly thought it to be 26^2. But then when my computer slowed down, I realized too late what it was :3
00:45:27 <dmwit> :t (<$>)
00:45:29 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
00:45:32 <Gracenotes> well, I do have 4 GB of memory..
00:46:00 <dmwit> Gracenotes: Oh, yes, but have you ever tried allocating 4GB of memory, 8 bytes at a time...?
00:46:42 <Zao> Sounds like the overhead fairy will stab you.
00:47:01 <mmorrow> dmwit: sounds like a jhc program gone bad
00:47:05 * mmorrow ducks
00:47:08 <mmorrow> :)
00:47:13 <dmwit> hehe
00:48:14 <dmwit> > replicateM 2 ['a'..'z']
00:48:15 <lambdabot>   ["aa","ab","ac","ad","ae","af","ag","ah","ai","aj","ak","al","am","an","ao"...
00:49:21 <Gracenotes> abcdefghijlkmnopqrstuvwxyz
00:49:24 <Gracenotes> abcdefghijlkmnopqrstuvwxyz
00:49:39 <dmwit> Oh, yeah, it's much worse than 2^26 bytes, isn't it?
00:49:43 <Gracenotes> whereas the above code traverses all this vertically, my code traverses all combinations horizontally
00:50:29 <dmwit> It's 2^26 * sizeof("abcdefghijklmnopqrstuvwxyz") = 2^26 * (24*26) ~= 2^35 bytes...
00:50:36 <Gracenotes> as far as I know the recursion depth is at most 26, so I'm not sure why ghci can't garbage collect it in time, or even if the bug is something more subtly worse
00:50:57 <Gracenotes> after all, when you take the length, you should be able to forget about the previous elements
00:51:23 <dmwit> Gracenotes: Oh, it's probably not necessary to keep the whole thing in memory.  But you're still allocating and freeing memory that whole time.
00:51:42 <dmwit> The only thing worse than allocating in a tight loop is allocating and freeing in a tight loop.
00:52:34 <dmwit> Also:
00:52:34 <Gracenotes> and this would slow down an OS, making even the terminal unclosable, before sending everything to an absolute halt?
00:52:38 <dmwit> ?src length
00:52:39 <lambdabot> Source not found. I've seen penguins that can type better than that.
00:52:52 <dmwit> um
00:53:06 <dmwit> Anyway, length uses the non-strict left-fold, so that's definitely keeping the whole thing in memory. =)
00:53:10 <Gracenotes> I didn't know strictness was ever an issue
00:53:24 <Gracenotes> oh... but it's a right fold
00:53:35 <Gracenotes> unless it uses a helper function
00:53:37 <dmwit> hm?
00:53:52 <Gracenotes> un momento
00:54:14 <dmwit> Wow, you're right.
00:54:36 <Gracenotes> hm. Perhaps you are: len :: [a] -> Int# -> Int
00:54:48 <Gracenotes> len []     a# = I# a#
00:54:49 <Gracenotes> len (_:xs) a# = len xs (a# +# 1#)
00:55:07 <Gracenotes> but it is primitive add, no thunks
00:56:12 * dmwit isn't confident he really understands all the answers here
00:56:53 <Gracenotes> still, crashing does happen too often for my tastes :)
00:59:55 <Taggnostr> dmwit, I can't understand the s | part in the code you gave me before
01:00:14 <dmwit> Do you know about guards?
01:00:25 <Taggnostr> I assume that it takes the value of show x, but I don't understand how/why
01:00:41 <Taggnostr> yes, I know something about guards
01:00:43 <dmwit> It might make more sense with proper indentation.
01:00:45 <dmwit> Give me a second.
01:01:11 <Taggnostr> yep, I was trying to reindent it but didn't know what to do with that s |
01:02:08 <dmwit> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6138#a6138
01:02:37 <Taggnostr> now it makes more sense
01:03:05 <Taggnostr> thanks
01:11:54 --- mode: irc.freenode.net set +o ChanServ
01:18:38 * WorkyBob ponders, I have a dependancy tree, to compute the order I need to evaluate in, I just grab the strongly connected components in topological order; but then when an item is updated on the graph, I must update everything below it, what do I need to get a minimal set of items to evaluate to be up to date
01:20:15 * Taggnostr reaches 50000!
01:20:51 <WorkyBob> it's not as simple as just doing SCCs in TO again, because where there's only a partial order I can end up re-evaluating things I don't need to
01:23:21 <paper_cc> WorkyBob: do the updates always affect only one node?
01:23:38 <paper_cc> (one node at a time, that is)
01:23:47 <WorkyBob> well, they can be encoded that way, yes
01:28:37 <paper_cc> then, if vertex V is updated, the problem is to enumerate the subtree of V in the transpose graph in TO
01:28:49 <paper_cc> *transposed
01:29:07 <WorkyBob> ohhhhhhh.... well spotted
01:29:26 <WorkyBob> so transpose, grab all reachable nodes, transpose that subgraph, and recompute dependancies
01:29:36 <WorkyBob> also, that works for the multiple vertex problem as well
01:30:46 <WorkyBob> cheers paper_cc :)
01:32:27 <Twey> @faq Can Haskell accommodate cizra by performing lots of audiovisual effects and the raising of the dead?
01:32:27 <lambdabot> The answer is: Yes! Haskell can do that.
01:32:54 <cizra> \o/
01:34:23 <paper_cc> WorkyBob: =)
01:35:58 <quicksilver> WorkyBob: every haskell program of sufficient size contains a topological sort as a sub problem ;)
01:36:43 <WorkyBob> lol
02:10:08 <hackagebot> level-monad 0.4.1 - Non-Determinism Monad for Level-Wise Search (SebastianFischer)
02:12:52 <voker57_> can i get cabal to generate haddock for all the installed packages?
02:13:16 <voker57_> i see cabal haddock can make it for one at time, using .cabal and unpacked sources
02:19:35 <ivanm> QtPlaty[HireMe]: http://www.uq.edu.au/jobs/index.html?page=111965&pid=11218
02:23:58 <TheColonial>  #mercurial
02:28:47 <fasta> There is no way to enable the MonoMorphism restriction in a file, is there (i.e. one which overrides what is given on the cli)?
02:30:56 <WorkyBob> I don't think so, I think you have to override it the other way round :/
02:31:03 <WorkyBob> which could be a lot of useless
02:35:42 <fasta> WorkyBob: yes, it's kind of stupid that the file doesn't take precedence.
02:38:00 <WorkyBob> hmm, it does doesn't it/
02:38:21 <WorkyBob> just there's no language flag to say I *do* want the monomorphism restruction
02:42:32 <fasta> WorkyBob: oh, yes, I was confused.
03:15:28 <jauaor> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6140#a6140
03:15:36 <jauaor> new version of quicksort :)
03:19:31 <quicksilver> "quicker"sort ?
03:19:45 <quicksilver> looks more like forth or joy than haskell though.
03:20:31 <idnar> someone write quickestsort already
03:20:31 <idnar> :P
03:21:00 <araujo> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6141#a6141
03:21:05 <araujo> new version, with one less swap
03:21:07 <araujo> yeah
03:21:12 <araujo> a stack based language i am writing
03:21:57 <PeakerWork> Does anyone here use Iteratee? I think I have some ideas on how to improve on its design, wondering if anyone knows about it to discuss that?
03:39:44 <opqdonut> hmm, i guess there is no way to guarantee nontermination in a monadic actions typesig
03:39:54 <opqdonut> like "Integer -> Void" would guarantee
03:40:09 <opqdonut> or forall a. Integer -> a
03:40:17 <opqdonut> (that is, nontermination or an error)
03:40:33 <Twey> Yep
03:40:35 <opqdonut> because m a usually is inhabited even though a might not be
03:40:55 <Twey> It's not even possible to guarantee non-termination in a pure function, so of course it's not possible in a monad
03:41:31 <opqdonut> well x :: Void has to diverge semantically
03:41:45 <Twey> x = x
03:41:53 <opqdonut> yes, that diverges
03:41:57 * Twey nods.
03:42:13 <Twey> Only possible value is bottom
03:42:27 <opqdonut> hmmm
03:42:36 <opqdonut> m Void would work if m were a "strict" monad
03:43:30 <opqdonut> that is, a monad for which every constructor is strict in the arguments of the type parameter
03:43:46 <opqdonut> and also every constructor would need to have such a constructor
03:43:57 <opqdonut> gah, such an argument
03:43:59 <mmorrow> @type undefined :: (Monad m) => a -> m (forall b. b)
03:44:00 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m (forall b. b)
03:44:06 <mmorrow> maybe
03:44:17 <opqdonut> yeah, no easy way around this i guess
03:46:17 <mmorrow> couldn't you just go (bam m = m >>= \x -> x `seq` return x) ?
03:46:57 <mmorrow> that with the m (forall b . b) and i couldn't see how you could terminate and still be alive
03:48:00 <mmorrow> (\m -> bam m >> undefined) for good measure ;)
03:48:09 <opqdonut> > let m >>= \x -> x `seq` return x in bam Nothing
03:48:11 <lambdabot>   <no location info>: parse error on input `in'
03:48:19 <opqdonut> > let bam m = m >>= \x -> x `seq` return x in bam Nothing
03:48:19 <opqdonut> gah
03:48:20 <lambdabot>   Nothing
03:48:23 <opqdonut> there
03:48:38 <mmorrow> the undefined would catch that
03:48:52 <opqdonut> ah
03:49:05 <opqdonut> > let bam m = (m >>= \x -> x `seq` return x) >> undefined in bam Nothing
03:49:06 <lambdabot>   Nothing
03:49:19 <opqdonut> how about mplus?
03:49:29 <opqdonut> > let bam m = (m >>= \x -> x `seq` return x) `mplus` undefined in bam Nothing
03:49:31 <lambdabot>   * Exception: Prelude.undefined
03:49:33 <mmorrow> > let bam m = m >>= \x -> (x `seq` return x >> undefined) in bam Nothing
03:49:35 <lambdabot>   Nothing
03:49:37 <mmorrow> goo
03:49:47 <mmorrow> a sly fox that Maybe
03:49:50 <opqdonut> :)
03:51:03 <mmorrow> maybe wrap the monad in some monad transformer, because since Monads can have arbitrary (>>=)'s, i just realized that this is impossible to get
03:51:19 <opqdonut> indeed
03:51:49 <mmorrow> newtype Goob a = Goob; instance Monad Goob where return = const Goob; Goob >>= _ = Goob
03:52:00 <opqdonut> indeed
03:52:58 <opqdonut> basically any monad with mzero would evade that
03:53:30 <opqdonut> of course mplus can be used to catch those MonadZeros that are also MonadPluss
03:54:03 <yitz> how do I write a function of this type: Applicative t => (b -> t c) -> (a,b) -> t (a,c)
03:54:15 <mmorrow> newtype M m a = M {unM::m a}; instance (Monad m) => Monad (M m) where return a = M (return a); M m >>= k = M (unM . k =<< m) >> undefined
03:54:50 <Gracenotes> yitz: remember that fmap is defined for Applicative... but hmm... you might need >>=. not sure.
03:55:00 <yitz> yeah
03:55:13 <Gracenotes> certainly possible with Monad
03:55:14 <mmorrow> then we can wrap the inner monad, and if it ever returns, just evaluate undefined ;)
03:55:37 <opqdonut> yitz: one could use that to write >>= for the applicative in question by using a=()
03:55:46 <opqdonut> yitz: so it probably won't be possible :)
03:56:04 <opqdonut> on the other hand if the first arg where t (b->c) that would just be a few fmaps
03:56:05 <yitz> Gracenotes: I actually do have a Monad instance in this case
03:56:28 <yitz> opqdonut: ok, then. let's see...
03:56:29 <Gracenotes> even if you have fmap you'll need join. so, monad
03:56:45 <opqdonut> yitz: try it with do notation first
03:56:51 <opqdonut> it'll be simpler
03:57:02 <opqdonut> mmorrow: hmm let me see
03:57:08 <Gracenotes> hm, wait, do you need fmap? lemme think harder >:[
03:58:09 <opqdonut> mmorrow: well effectively that's just applying "const undefined" on the result
03:58:13 <opqdonut> :P
03:58:19 <Gracenotes> never mind, you don't need a monad
03:58:32 <Gracenotes> @type \f (a, b) -> fmap ((,) a) (f b)
03:58:34 <lambdabot> forall t t1 a (f :: * -> *). (Functor f) => (t1 -> f a) -> (t, t1) -> f (t, a)
03:58:44 <opqdonut> oh
03:58:57 <opqdonut> ah of course
03:59:05 <yitz> ah! thanks.
03:59:38 <Gracenotes> the (a, b) is given to you for free
03:59:39 <opqdonut> ah yeah, it was (a,b) and not t (a,b)
03:59:54 <yitz> @pl \f (a, b) -> fmap ((,) a) (f b)
03:59:54 <lambdabot> (`ap` snd) . (. fst) . flip ((.) . fmap . (,))
04:00:51 <yitz> I thought there is some way to use "second" though
04:01:08 <Gracenotes> not without using join
04:01:19 <Gracenotes> afaik
04:01:34 <yitz> ok
04:01:48 <yitz> these things seem like they should be so simple.
04:03:07 <yakov> hey
04:03:16 <Gracenotes> ap and >>= and fmap can be applied in many permutations
04:03:49 <Gracenotes> it's not always simple to reason about, although do notation is much clearer
04:04:21 <Gracenotes> halo
04:05:22 * mapreduce spots osfameron on the geekup mailing list.  Nice to know there's someone good at Haskell nearabouts.
04:05:54 <osfameron> mapreduce: good, not really ;-P
04:06:02 <mapreduce> heh
04:06:03 <osfameron> mapreduce: where are you based?  geekup is a wide region
04:06:23 <mapreduce> Manchester to Warrington.
04:06:58 <osfameron> cool.  If you're around Manchester on the 1st I'll probably be at http://northwestengland.pm.org/meetings/006.html
04:07:36 <osfameron> couple of people in the northwest sometimes suggest a haskell/erlang/FP-in-general meetup at some point
04:08:47 <mapreduce> I'd be up for that.
04:09:07 <mapreduce> The FP-in-general one; I'm not really into Perl anymore.
04:09:16 <osfameron> fair enough :-)
04:20:38 <plumenator> How come I can do this in ghci? "let l = 6" and then "let l = 5"? Aren't names immutable?
04:21:07 <johnnowak> plumenator: you're defining a new 'l' that "shadows" the old one
04:21:50 <plumenator> johnnowak: So does every 'let' mask the previous bindings?
04:22:16 <plumenator> johnnowak:  even within a single scope?
04:22:19 <johnnowak> plumenator: for the extent of that let, yes
04:22:38 <quicksilver> plumenator: that is not a single scope
04:22:48 <quicksilver> plumenator: you are defining nested scopes, although it may not feel like it.
04:23:07 <johnnowak> > let x = 5 in let f y = x + y in let x = 6 in f 10
04:23:08 <lambdabot>   15
04:23:13 <mmorrow> opqdonut: i just tried to make a monad wrapper that's also a monad but that somehow makes the wrapped monad loop, and failed miserably :)
04:23:16 <osfameron> > let {i = 1; i = 1} in i + 2
04:23:18 <lambdabot>   Conflicting definitions for `i'
04:23:18 <lambdabot>  In the binding group for: i, i
04:23:20 <mmorrow> (all i could do was loop)
04:23:37 * mmorrow returns to his regularly scheduled program
04:23:45 <ivanm> mmorrow: which is?
04:24:05 <mmorrow> code for whatever it was that i was doing before i sidetracked ;)
04:24:56 <plumenator> Uh, I guess I need to understand 'let' a little better. Thanks.
04:24:59 <johnnowak> plumenator: it may seem confusing in ghci because you're effectively working in the 'do' monad. as such, you're not required to write 'in' to indicate where the expression within that 'let' begins.
04:25:10 <johnnowak> er.. the IO monad.
04:25:32 <quicksilver> do { let l = 1; let l = 2; putStrLn "hello" }
04:25:39 <quicksilver> is just syntactic sugar for
04:25:50 <quicksilver> let l = 1 in (let l = 2 in (putStrLn "hello"))
04:25:57 <quicksilver> () added for emphasis
04:26:05 <quicksilver> so you can see the scopes are really nested.
04:26:13 <johnnowak> what was the motivation for the alternative form of 'let' in do syntax?
04:26:16 <stulli> I have trouble understanding this typeclass: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6144#a6144
04:26:33 <stulli> I would understand instance Reducer Integer where...
04:26:55 <stulli> But instance Reducer c [c] doesnt make sense to me
04:27:56 <loupgaroublond> hi all
04:28:56 <loupgaroublond> i'm trying to get FFI functions to work in ghci, but it seems ghc doesn't link the object files to the system unless it's compiling programs, how can i go about getting this to work via ghci?
04:29:27 <Saizan> johnnowak: not having "in do" and another level of indentation at the end to continue with do-notation
04:29:59 <Saizan> loupgaroublond: pass the .o file as argument to ghci at startup
04:30:33 <johnnowak> Saizan: why not another word like 'val' or something instead of 'let' to avoid the confusion?
04:30:54 <quicksilver> stulli: it's a type class with two parameters.
04:30:59 <Saizan> stulli: Reducer is a multi-parameter typeclass, i.e. it's a relation on types instead of a set of types
04:30:59 <quicksilver> stulli: (this is a GHC extension)
04:31:06 <loupgaroublond> Saizan, will i have to restart ghci every time i recompile it then? currently i'm using :load and :reload
04:31:20 <quicksilver> johnnowak: is it confusing? It is very closely related to the other let.
04:31:28 <johnnowak> that's why it's confusing.
04:31:28 <quicksilver> johnnowak: just a simple translation.
04:31:31 <Saizan> loupgaroublond: not sure about that
04:32:27 <loupgaroublond> ah, at least now it's being honest with me:
04:32:27 <loupgaroublond>  ghc: RpmLog.o: unknown symbol `rpmlogSetMask'
04:32:28 <loupgaroublond>  final link ... linking extra libraries/objects failed
04:32:37 <ryant5000> loupgaroublond: you can also specify your .hs file(s) on the command line, i believe; if you write a simple shell script, you can then just substitute :q for :r
04:37:49 <Reiver> Aha, I missed this place
04:38:12 <Reiver> So, um, I've sat an exam today so my brain is tired, and while coding itself seems fine I'm failing at understanding error messages. Go fig.
04:38:12 <Reiver> *** Expression     : display (m,i,o)
04:38:12 <Reiver> *** Term           : (m,i,o)
04:38:12 <Reiver> *** Type           : ([Char] -> MemVal,[Value],[Value])
04:38:12 <Reiver> *** Does not match : [Char] -> MemVal
04:38:25 <Reiver> What is this telling me is wrong? I may be getting the last two lines mixed up.
04:40:39 <fasta> Reiver: you are using Hugs, I think that says it all ;)
04:40:58 <quicksilver> Reiver: it appears to say that "display" expects as its first argument something of type ([char]->memval)
04:41:00 <Reiver> fasta: hehe, yeah
04:41:04 <quicksilver> Reiver: and you are instead giving it a 3-tuple.
04:41:13 <Reiver> hrn, oh, I see
04:41:20 <fasta> Reiver: try (\(a,b,c) -> a)
04:41:25 <Reiver> I was misreading it and thinking it wanted /more/ values
04:41:36 * Reiver has a go.
04:44:16 <Reiver> whaaaat
04:44:21 <Reiver> Okay, I'm pastie-ing this.
04:45:16 <dmwit> What!
04:45:28 <dmwit> cabal-install isn't installed on community.haskell.org?
04:45:57 <Jedai> Reiver: "display m" may work better than "display (m,i,o)" if I understand the message correctly
04:46:55 <lyndon> Hi. What's up with this? http://www.haskell.org/ghc/docs/latest/html/libraries/ghc-prim/GHC-Tuple.html#t%3A%28%2C%2C%29
04:47:09 <Reiver> Jedai: That... got even weirder
04:47:10 <Reiver> *** Expression     : Error "Unbound identifier" ++ display m
04:47:10 <Reiver> *** Term           : Error "Unbound identifier"
04:47:10 <Reiver> *** Type           : ExpVal
04:47:10 <Reiver> *** Does not match : [Char]
04:47:25 <Gracenotes> > (,,,,) 1 2 3 4 5
04:47:26 <lambdabot>   (1,2,3,4,5)
04:47:52 <Saizan> Reiver: Error ("Unbound identifier" ++ display m)
04:47:55 <dmwit> Reiver: In the future, please post long error messages to a pastebin.
04:47:56 <quicksilver> Reiver: I expect you wanted Error ("Unbounded id" ++ display m ++ " PS this programmer doesn't know about precedence")
04:48:05 <Reiver> dmwit: Sorry 'bout that
04:48:35 <dmwit> lyndon: Could you be more specific?
04:48:51 <lyndon> Not really. It just looks totally weird to me.
04:49:02 <dibblego> @type (,,)
04:49:03 <dmwit> lyndon: I agree, it's a little weird.
04:49:04 <lambdabot> forall a b c. a -> b -> c -> (a, b, c)
04:49:14 <dibblego> > (,,) 2 3 4
04:49:17 <lambdabot>   (2,3,4)
04:49:36 <Gracenotes> and instances are defined to various extents
04:49:38 <dmwit> lyndon: You'll notice that this means you can't have 64-tuples if you want to use GHC. =P
04:49:59 <lyndon> ah. it does mean that.
04:50:09 <dibblego> > length "(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)" - 2
04:50:11 <lyndon> thanks
04:50:11 <lambdabot>   61
04:50:18 <Gracenotes> +1
04:50:21 <dibblego> +1
04:51:55 <dmwit> :t (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
04:51:57 <lambdabot> forall a b c d e f g h i j k l m n o p q r s t u v w x y z t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t52 t53 t54 t55 t56 t57 t58 t59 t60 t61 t62
04:51:57 <lambdabot> t63 t64 t65. a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> t34 -> t35 ->
04:51:57 <lambdabot> t36 -> t37 -> t38 -> t39 -> t40 -> t41 -> t42 -> t43 -> t44 -> t45 -> t46 -> t47 -> t48 -> t49 -> t50 -> t51 -> t52 -> t53 -> t54 -> t55 -> t56 -> t57 -> t58 -> t59 -> t60 -> t61 -> t62 -> t63 ->
04:51:57 <lambdabot> t64 -> t65 -> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t28, t29, t30, t31, t32, t33, t34, t35, t36, t37, t38, t39, t40, t41, t42, t43, t44, t45, t46, t47, t48,
04:51:59 <lambdabot> t49, t50, t51, t52, t53, t54, t55, t56, t57, t58, t59, t60, t61, t62, t63, t64, t65)
04:52:13 <dmwit> whoops =P
04:52:37 <WorkyBob> @. djinn . t (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
04:52:38 <lambdabot> Plugin `compose' failed with: Unknown command: "t"
04:52:44 <WorkyBob> @. djinn t (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
04:52:45 <lambdabot> Plugin `compose' failed with: Unknown command: "t"
04:52:46 <dmwit> Now, why would the numbered 't's start at 28?
04:52:52 <WorkyBob> @. djinn type (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
04:52:54 <lambdabot> f a
04:52:54 <lambdabot>   b
04:52:54 <lambdabot>   c
04:52:54 <lambdabot>   d
04:52:54 <lambdabot>   e
04:52:56 <lambdabot>   f
04:52:58 <lambdabot>   g
04:53:00 <lambdabot>   h
04:53:02 <lambdabot>   i
04:53:03 <WorkyBob> oops >.<
04:53:04 <lambdabot>   j
04:53:06 <lambdabot>   k
04:53:08 <lambdabot> Plugin `compose' failed with: thread killed
04:53:10 <WorkyBob> well done \bot
04:53:23 <Saizan_> well done WorkyBob :P
04:53:27 <WorkyBob> lol
04:53:38 <trofi> "nice"
04:53:40 <dmwit> Aww, I wanted to see what djinn would do when it reached 'z'.
04:53:43 <WorkyBob> @ . . pl djinn type (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
04:53:48 <WorkyBob> @. . pl djinn type (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
04:53:50 <lambdabot> f a
04:53:50 <lambdabot>   b
04:53:50 <lambdabot>   c
04:53:50 <lambdabot>   d
04:53:50 <lambdabot>   e
04:53:51 <lambdabot>   f
04:53:53 <WorkyBob> damn it!
04:53:53 <lambdabot>   g
04:53:56 <lambdabot>   h
04:53:57 <WorkyBob> that was *not* meant to happen
04:53:58 <lambdabot>   i
04:53:59 <lambdabot>   j
04:54:02 <lambdabot>   k
04:54:04 <lambdabot> Plugin `compose' failed with: thread killed
04:54:04 <WorkyBob> sorry :(
04:54:20 * WorkyBob wonders why it did happen
04:54:34 <Reiver> I suddenly don't feel so bad about pasting Hugs errors. ;)
04:54:39 <WorkyBob> lol
04:54:42 * Reiver stares. O-kay, why is that doing... that
04:54:58 <dmwit> Hmm.  community.haskell.org has got some seriously outdated Haskell technology on it.
04:55:02 <Reiver> Oh! Wait!
04:55:06 <Reiver> That's a totally different line! HAHA!
04:55:40 <Reiver> Helps if you read the line numbers when staring at a "Where the heck did that error come from... I don't even have those variables in that line!" error. :p
04:56:03 <WorkyBob> heh
04:56:23 <Gracenotes> djinn only does pairs
04:57:04 <quicksilver> because there aren't destructors for triples and above
04:57:24 <quicksilver> oh, sorry, djinn, not pl ;)
04:57:35 <quicksilver> yeah, no good reason for djinn not to do n-tuples.
04:57:38 <Gracenotes> @. djinn type maybe (,) . maybe
04:57:40 <lambdabot> f a b c =
04:57:40 <lambdabot>     case b of
04:57:40 <lambdabot>     Nothing -> a
04:57:40 <lambdabot>     Just d -> case c of
04:57:40 <lambdabot>               Nothing -> a
04:57:42 <lambdabot>               Just e -> d e
04:57:47 <quicksilver> although nested pairs are the same, logically.
04:57:52 <Gracenotes> well, you can define n-tuples for it, djinn-env, except without sugar
04:58:01 <Saizan_> ?djinn a -> (a,a,a,a)
04:58:01 <lambdabot> f a = (a, a, a, a)
04:58:12 <Saizan_> ?djinn a -> (a,a,a,a,a)
04:58:13 <lambdabot> f a = (a, a, a, a, a)
04:59:04 <Saizan_> ?. pl djinn a -> (a,a,a,a,a)
04:59:05 <dmwit> > [1..63] >>= "a,"
04:59:05 <lambdabot> f = join (join (join (join (,,,,))))
04:59:06 <lambdabot>   Couldn't match expected type `t -> [b]'
04:59:12 <dmwit> > [1..63] >> "a,"
04:59:14 <lambdabot>   "a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,...
04:59:23 <dmwit> aww, too short
04:59:42 <dmwit> :t join (,,)
04:59:43 <lambdabot> forall a c. a -> c -> (a, a, c)
04:59:52 <Saizan_> so pl can parse n-tuples in values but not in types?
05:00:04 <Saizan_> err, expressions but not in patterns
05:00:04 <dmwit> pl doesn't do types
05:00:16 <dmwit> ?pl f (a, b) = a + b
05:00:16 <lambdabot> f = uncurry (+)
05:00:26 <dmwit> seems to do patterns just fine
05:00:36 <dmwit> ?pl f (a, b, c) = a + b + c
05:00:37 <lambdabot> (line 1, column 13):
05:00:37 <lambdabot> unexpected "="
05:00:37 <lambdabot> expecting variable, "(", operator or end of input
05:00:42 <dmwit> mmm
05:00:43 <dmwit> =)
05:01:11 <Gracenotes> .
05:01:31 <EvilTerran> ?pl f (a,(b,c)) = (a,b,c)
05:01:31 <lambdabot> f = uncurry ((`ap` snd) . (. fst) . (,,))
05:01:36 <Reiver> http://pastebin.com/d79551e75 - again, silly question time. I should really do this in the morning, but I'm keen to get this much done before I call it a night.
05:02:08 <EvilTerran> Reiver, er, what code is this in the context of?
05:02:32 <Saizan_> Reiver: same error as in the triple case
05:02:47 <Reiver> Saizan_: ... interesting, 'cuz as far as I was aware I wasn't passing it a triple.
05:02:55 * Reiver goes to look at what the heck his code is doing again.
05:03:22 <Botje> it's best to paste the whole code, because the type inferencer goes pretty far
05:03:30 <Reiver> OK, a sec
05:05:10 * Reiver tries again, this time with highlights.
05:05:28 <Reiver> http://pastebin.com/d66ef991f - the code as a whole. Prior link gives the error it threw me.
05:05:58 <Reiver> Have highlighted the line I'm working on, can also highlight the other [suspected] relevant lines if desired.
05:06:05 <tommd> Who is able to setup the hackage.haskell.org/trac for projects?  (Ex: Haskell-prime's track)
05:06:48 <Botje> okay
05:06:50 <Botje> so s is a tuple
05:07:10 <Botje> because the other forms of exp_semantics also take a tuple in that position
05:07:34 <Botje> and display is of type Memory -> String
05:07:39 <Botje> whereas you're passing it a tuple
05:07:44 <Reiver> ... oh. So I am. Whoops.
05:07:45 <Botje> that's why it's complaining :)
05:07:49 <Reiver> Hrn.
05:08:01 <Reiver> I need to find a Memory in that somewhere to throw at the error message then.
05:08:12 <Reiver> I can do that by... hm
05:08:12 <jeffersonheard> I hate it when I forget and leave this logged in over the weekend, and then someone messages me, and the only sign when I get in on monday is the little red flash of an alert icon
05:08:17 <jeffersonheard> no actual message
05:08:18 <Reiver> How do you get things /out/ of a tuple, again?
05:08:30 <dmwit> Reiver: pattern match
05:08:55 <dmwit> Instead of OK (Numeric v) s1, use something like OK (Numeric v) (m, i, o)
05:09:19 <Botje> jeffersonheard: if you go /away you can do /back to read your messages
05:10:08 <jeffersonheard> yeah, I forgot to go /away
05:10:15 <Botje> jeffersonheard: fwiw, it was a ping from mmorrow
05:10:19 <Reiver> dmwit: Am I able to get the m out of s1?
05:10:21 <dmwit> tommd: You can get a trac on community.haskell.org if you want.
05:10:34 <jeffersonheard> Botje, thanks
05:10:37 <jeffersonheard> that helps
05:11:01 <dmwit> Reiver: Yes, but if you really want to refer to s1 as a whole, then it's better to use the pattern s1@(m, i, o) than to use the pattern s1 and match on it again.
05:13:10 <Reiver> dmwit: Hrn. It /does/ clean the code up a lot to use s1 in favor of (m, i, o) all the time, when the only time I need the m alone is for error handling. Even then, it's tempting to just upgrade the Error handling so it ... hm
05:13:34 <Reiver> I might do that afterall. If 'output' handled the triple, that'd be both more info and less work, yes?
05:13:41 <dmwit> Reiver: Why not match on s1 by default, and only match on (m, i, o) when you actually need to break it down?
05:13:44 <[AM]-Kasp> New web browser based game, intresting and fun peoples, nice admins and more, enjoy - http://www.lostworlds.lv/go.php?1139730844
05:14:16 * mux_ keeps reading articles about erik naggum (RIP), and cannot help thinking he was full of shit.
05:16:02 <fasta> mux_: I got the impression he has written quite some software. I don't know whether that is true or not, but it seems he could communicate quite precisely, which is also required for programming.
05:16:46 <mux_> fasta: for now, the only domain where I've seen proofs that he was skilled in is plain trolling.
05:17:16 <fasta> mux_: well, then I don't think you have read a lot of him.
05:17:19 <mux_> clearly, he writes very well and has some serious talent at guing with people
05:17:26 <mux_> arguing
05:17:46 <mux_> fasta: I'm trying to make sense of the generalized feeling of loss :-P
05:17:52 <mux_> I'm still failing
05:18:57 <fasta> mux_: his bookshelf is also kind of big:  http://www.librarything.com/catalog/nocebo
05:19:01 <Reiver> dmwit: That was a vastly more intelligent suggestion. Thanks!
05:19:15 <Reiver> I'd forgotten you could do that. >_>
05:19:45 <fasta> mux_: although, I cannot actually find any of his software anywhere nor a thesis or something like that.
05:19:51 <mux_> fasta: someone should have bought him 'how to make friends' =)
05:21:53 <fasta> mux_: that would have been an epic usenet post.
05:25:04 <bastl> im generating modules with haskell-types from various XML DTDs. What would be the "right" place in the module hierarchy?
05:26:12 <bastl> Language.XML.* or Text.XML.* or ?.DTD.* ?
05:26:29 <doserj> neither
05:26:44 <bastl> but?
05:27:13 <doserj> depends on what the specific XML is used for
05:27:54 <themroc> anyone can explain me the following header:
05:27:56 <themroc> schuetze_funktion :: (a -> Bool) -> (a -> b) -> a -> b
05:27:59 <bastl> its things like XHTML, web.xml, google-webtoolkit descriptors, hibnernate cfg. could be anything ...
05:28:20 <themroc> im sort of confused by the (a -> b)
05:28:55 <quicksilver> themroc: it's a function from type 'a' to type 'b'
05:29:09 <EvilRanter> themroc, that means "a function that takes an 'a' and returns a 'b'", the same way the (a -> Bool) means "a function that takes an 'a' and returns a Bool"
05:29:14 <bastl> themroc: perhaps "given an a that satifies a predicate, a function that transforms an a to a b, transform it if the predicate is true
05:29:38 <themroc> hmm
05:29:48 <doserj> bastl: and if not?
05:29:48 <themroc> so the function only has one parameter?
05:30:06 <EvilRanter> themroc, schuetze_funktion has three parameters, the first two of which are functions of one parameter
05:30:06 <bastl> schuetze could mean smthing like "guard"
05:30:11 <bastl> doserj: undef?
05:30:19 <doserj> bastl: :(
05:30:56 <themroc> hmm anyone could point me to a source where the header stuff is explained?
05:30:58 <EvilRanter> themroc, and whoever's calling schuetze_funktion gets to choose what types 'a' and 'b' represent, because they're type variables
05:31:27 <EvilRanter> ?hoogle Data.List.map
05:31:27 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
05:31:27 <lambdabot> Data.List mapAccumL :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
05:31:27 <lambdabot> Data.List mapAccumR :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
05:32:37 <loupgaroublond> are there CFile handles that point to stdout, stderr, and stdin in the FFI?
05:33:19 <Saizan_> themroc: http://www.haskell.org/tutorial/goodies.html
05:33:34 <themroc> thx
05:37:06 <d_tech> I had a function programming test today, and my buddy and I can't agree about one question. Can anyone help? Here it goed:
05:37:08 <d_tech> Give the most generic type of: `flip head`
05:37:09 <d_tech> I thought it might be [(a->b->c)] -> (b -> a ->c) but he thought it is something else and hugs isn't a lot of help with "a -> [a -> b] -> b"
05:37:36 <Saizan_> hugs is right :)
05:37:47 <Saizan_> no, wait
05:37:52 <loupgaroublond>  :t flip head
05:37:52 <loupgaroublond>  flip head :: b -> [b -> c] -> c
05:38:01 <Saizan_> ?type flip head
05:38:03 <lambdabot> forall b c. b -> [b -> c] -> c
05:38:07 <Saizan_> yes, it is.
05:38:48 <d_tech> Why?
05:38:58 <Saizan_> the type inference algorithm works by collecting equations about types and later solving them with unification
05:39:26 <ziman> there's difference between "flip head" and "flip . head"
05:39:31 <ziman> :t flip . head
05:39:33 <lambdabot> forall a b c. [a -> b -> c] -> b -> a -> c
05:39:38 <Saizan_> so, head :: [a] -> a, flip :: (b -> c -> d) -> (c -> b -> d)
05:39:53 <ziman> ^^ this is what you had in mind
05:40:12 <d_tech> Yes, I realised that a few moments ago
05:40:28 <Saizan_> since you pass head as argument to flip, then you've [a] -> a == (b -> c -> d), and since -> is right associative, you get [a] -> a = b -> (c -> d)
05:40:47 <d_tech> But okay, flip :: (a->b->c) -> (b->a->c) and head :: [a] -> a
05:40:50 <Saizan_> which gives a = (c -> d) and b = [a] = [c -> d]
05:41:20 <Reiver> http://pastebin.com/da043ec7 gives me the error http://pastebin.com/d360520d9 - what puzzles me is that Output and Input have the same type, yet the i gives no error but the o does? Or is it working right to left, and thus simply hasn't hit the i yet?
05:42:10 <Saizan_> the result of flip head has then type c -> b -> d == (substituting) c -> [c -> d] -> d
05:42:21 <Gracenotes> @type const <*> const
05:42:22 <lambdabot> forall b. b -> b
05:42:39 <Gracenotes> ah.. I.
05:42:53 <byorgey> Reiver: you need to have 'show i' and 'show o'
05:43:00 <byorgey> instead of just 'i' and 'o'
05:43:11 <Reiver> ... oh, duh.
05:43:18 <Saizan_> d_tech: it's important to note that the 'a' in the type of head and the one in the type of flip are different variables
05:43:20 <byorgey> Reiver: yeah, I think it just hasn't gotten to the i
05:43:22 <Reiver> And was I right in that it's erroring at the o before it /sees/ the i
05:43:26 <Reiver> Right, then
05:43:27 <Saizan_> d_tech: that's why i've used different names instead
05:43:30 <byorgey> something like that
05:43:39 <Reiver> That was the bit that was throwing me, distracting me from looking at the 'show' part itself >_>
05:43:50 <byorgey> hehe
05:43:51 <bremner> anyone know about a haskell library for parsing BibTeX?
05:44:37 <georgehorse> http://www.mail-archive.com/haskell@haskell.org/msg16400.html
05:44:52 <d_tech> Okay: so basically `flip head 5 [succ]` => `head [succ] 5` => `succ 5` => `6`
05:45:30 <Saizan_> d_tech: yeah
05:45:39 <bremner> georgehorse: thanks!
05:47:51 <georgehorse> bremner: sure, hope it's what you were looking for
05:48:18 <d_tech> Saizan_: "it's important to note that the 'a' in the type of head and the one in the type of flip are different variables" so flip head :: a -> [a->b] -> b would actually be :: a -> [b->c] -> c ?
05:49:12 <bremner> this also looks relevant to Bibtex: http://code.haskell.org/citeproc-hs/
05:49:46 <bremner> except that it is XML :-(
05:50:27 <georgehorse> d_tech: I believe that he meant, when you write out the types as head :: [a] -> a and flip :: (a -> b -> c) -> (b -> a -> c), it's wrong, the two variables denoted `a' should be distinct
05:56:02 <byorgey> well, it's not wrong, just potentially confusing =)
05:58:47 <Saizan_> d_tech: no, flip head :: a -> [a -> b] -> b, i meant what georgehorse said
06:00:14 <Saizan_> d_tech: in standard haskell we don't use qualifiers to introduce variables, and so it might be ambiguous which is the scope of a particular variable
06:05:43 <Invisible> anybody know how to work the GHCi debugger?
06:09:18 <Invisible> ...hello?
06:09:31 * EvilRanter doesn't know
06:10:01 <Invisible> well, I guess that makes two of us. :-(
06:10:23 <d_tech> Okay. (this might be annoying for you but I'm just a 1st year CS student who has had about 6 weeks of college about haskell & functional programming from a mediocre professor but still tries to learn it well and understand it fully).
06:10:24 <d_tech> So if I try this: `flip head 5 [succ]` I get `6`. So `flip head x y` then x :: a and y :: [(a->b)]. But where in this example is the (p->q->r) that flip wants and (q->p->r) flip returns?
06:10:26 <quicksilver> Invisible: very few people have tried it, I think.
06:10:56 <Invisible> quicksilver: I see...
06:11:11 <Invisible> I was kind of hoping I could use the debugger to... debug... my code. :-/
06:11:17 <quicksilver> perhaps you can.
06:11:24 <Axman6> Invisible: have you reasd the GHC docs? they're quite clear
06:11:26 <Invisible> it won't tell me anything.
06:11:27 <burp> Invisible, http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-debugger.html are you looking for this?
06:11:29 <quicksilver> I'm just saing there aren't that many people here who have used it.
06:11:31 <Axman6> with examples and everything
06:11:36 <EvilTerran> d_tech, "head :: [a] -> a", so "head :: [b -> c] -> b -> c", taking a = b -> c
06:12:00 <EvilTerran> d_tech, so "flip head :: b -> [b -> c] -> c", etc etc
06:12:15 <Invisible> I've tried every command I can find in the manual, but at no time will the debugger tell me what values the local variables currently have.
06:12:32 <fasta> Invisible: I used the debugger.
06:12:41 <Invisible> fasta: did it work?
06:12:51 <burp> used it too, and it worked
06:13:06 <fasta> Invisible: let me say I am not a fan, but I have been more negative of it then it deserves, but still it is often useless.
06:13:13 <fasta> than*
06:13:41 <Invisible> all it seems to tell me is that the result isn't computed yet... right up until it spits out the wrong result.
06:13:44 <themroc> hmm, so how could a function of "schuetze_funktion :: (a -> Bool) -> (a -> b) -> a -> b" look like?
06:13:54 <fasta> Invisible: it doesn't show all variables in scope because of some reason I don't understand. There is a ticket for that in GHC.
06:13:59 <Invisible> what I want to know is what values are going through the local variables before it gets to that point...
06:14:15 <Invisible> fasta: It doesn't show ANY variables! >_< only the end result.
06:14:22 <fasta> Invisible: someone else was annoyed with this behaviour and decided to fix it. It requires 6.10.3 however.
06:14:54 <fasta> Invisible: show the code, show what you see.
06:14:59 <Invisible> fasta: The manual makes some comment about "including all variables made it too slow", but that's about it.
06:15:38 * Invisible finds hpaste
06:17:45 <Invisible> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=6149
06:18:07 <EvilTerran> themroc, well, const id would work
06:18:10 <fasta> When I install 6.10.3 I will apply the patches of this Peter <something> person and I will have a working debugger.
06:18:17 <EvilTerran> ?type const id :: (a -> Bool) -> (a -> b) -> a -> b
06:18:18 <lambdabot> forall a b. (a -> Bool) -> (a -> b) -> a -> b
06:18:32 <doserj> @djinn (a -> Bool) -> (a -> b) -> a -> b
06:18:32 <lambdabot> f _ a b = a b
06:18:50 <Invisible> my first question would have to be... why the hell did the debugger stop THERE?? that's not the entry point...
06:19:15 <themroc> EvilTerran: hmm
06:19:16 <Zao> Evaluation works in mysterious ways.
06:19:24 <themroc> i dont understand yet how this works
06:19:36 <themroc> so i should have a function which tests if a is true
06:19:54 <fasta> Invisible: if you want people to help you, paste something they can comprehend. In this case the whole code for match.
06:19:58 <themroc> or no, it should test a on something i mean
06:20:09 <themroc> and if its True, another function should be called
06:20:11 <themroc> resulting in b
06:20:14 <EvilTerran> and if not?
06:20:19 <themroc> its undefined
06:20:51 <EvilTerran> um... what're you planning on doing with the result of this function?
06:20:52 <Invisible> fasta: I just appended the code to the same paste.
06:21:24 <themroc> EvilTerran its a homework and we have to define a function which has that header
06:21:31 <EvilTerran> i see
06:21:35 <themroc> no matter what kind of function
06:21:38 <EvilTerran> that's a weird example
06:22:36 <fasta> Invisible: I don't use step a lot, but doesn't step, step over a function?
06:22:38 <themroc> i just dont understand how i can write that dependance
06:22:49 <themroc> i could do an if statement but i guess its not what they want
06:22:52 <fasta> Invisible: which would mean that it does exactly what it should do?
06:22:57 * EvilTerran can't think of any total semantic functions that would have that as their most general type
06:23:01 <Invisible> fasta: not sure.
06:23:10 <Invisible> the manual claims that :step <expr> will single-step that expression.
06:23:18 <EvilTerran> themroc, why not? if you're branching based on a Bool, that's what "if" is there for
06:23:31 <fasta> Invisible: just use :break
06:23:39 <ivanm> @seen ndm
06:23:40 <lambdabot> I haven't seen ndm.
06:23:41 <fasta> Invisible: then you can know exactly where you get your breaks.
06:24:11 <themroc> hmm EvilTerran so there is no structure in haskell which describes this without an if?
06:24:36 <EvilTerran> themroc, well, you can use guards instead, or a case expression, but they're all equivalent in the end
06:24:38 <Invisible> fasta: what do you suggest? :break 106?
06:24:39 <gwern> @quote invisible
06:24:40 <lambdabot> No quotes match. Are you on drugs?
06:24:56 <fasta> Invisible: for example
06:24:57 <Sam___> how'd it know?
06:26:41 <Invisible> what the hell....?
06:26:58 <Invisible> it won't let me set a breakpoint on line 106, or 107, only 108. um, WHY?
06:27:16 <fasta> Invisible: please calm down, just assume for a moment that you don't understand how it works, instead of that it is broken (which is only partly true).
06:27:34 <EvilTerran> themroc, ie, "foo x | p x = f x | otherwise = g x" is the same as "foo x = if p x then f x else g x", and are both the same as "foo x = case p x of True -> f x; False -> g x"
06:27:40 <Invisible> fasta: I'm calm, just confused...
06:29:14 <themroc> ok but the False case should be undefined
06:29:21 <themroc> so i cannot work with if
06:29:40 <EvilTerran> themroc, why not?
06:29:46 <EvilTerran> "if p x then f x else undefined"?
06:29:50 <themroc> ahhhh
06:29:51 <themroc> ok
06:29:54 <themroc> i see
06:29:58 <EvilTerran> a single guard would work, too
06:30:15 <themroc> hmm i might not have understood guards yet
06:30:17 * Invisible scratches his head.
06:30:29 <EvilTerran> "foo x = if p x then f x else undefined" would be the same as "foo x | p x = f x"
06:30:32 <Invisible> maybe... I don't know... maybe it can only set breakpoints on certain kinds of expression?
06:30:39 <fasta> Invisible: I would just wait until http://www.mail-archive.com/glasgow-haskell-users@haskell.org/msg16074.html is in the distribution by default and assume there is no debugger until then.
06:30:42 <EvilTerran> in that it'd be (f x) when (p x) is true, and undefined otherwise
06:30:59 <themroc> ok lemme try
06:31:01 <loupgaroublond> are there any decent bindings for standard C libs? all i can find is 'bindings' which is supposedly deprecated
06:31:05 <Zao> You can't use guards anywhere else than in a function definition, right?
06:31:29 <EvilTerran> Zao, or a case branch
06:31:47 <EvilTerran> or, indeed, a let expression - anywhere after a pattern, really, appart from a lambda
06:32:05 <Invisible> fasta: OK. Time to go execute the code old-skool style [i.e., by hand...]
06:32:22 <ziman> @hoogle (Read a) => String -> Maybe a
06:32:22 <fasta> Invisible: there is Debug.Trace.trace
06:32:23 <lambdabot> Prelude read :: Read a => String -> a
06:32:23 <lambdabot> Text.Read read :: Read a => String -> a
06:32:23 <lambdabot> Distribution.Text simpleParse :: Text a => String -> Maybe a
06:32:36 <EvilTerran> themroc, http://www.haskell.org/tutorial/patterns.html goes into how patterns and guards work
06:32:40 <QtPlaty[HireMe]> ?hoogle m (Maybe t) -> (t -> m b) -> m b -> m b
06:32:41 <lambdabot> No results found
06:32:47 <Invisible> fasta: Generally, its output is incomprehensible due to the obscure execution order. ;)
06:33:44 <Zao> > let f x | x == True = 42 | otherwise = 3 in f False
06:33:45 <lambdabot>   3
06:33:47 <Zao> Neat.
06:33:48 <themroc> ok EvilTerran
06:33:53 <themroc> i will read it, thx
06:33:56 <fasta> Invisible: add strictness annotations to get an imperative order.
06:33:58 <themroc> i tried this now: http://pastebin.com/m31ac634c
06:33:58 <EvilTerran> Zao, protip, (==True) = id
06:34:11 <Zao> Well, yeah.
06:34:21 <fasta> Invisible: or try to think about evaluation order, since otherwise using a lazy language makes no sense at all.
06:34:33 <Zao> Be happy you didn't see the first few attempts.
06:34:58 <EvilTerran> themroc, the type you've given says that schuetze_funktion takes test_function and final_function as parameters as well as 'a'
06:35:03 <Invisible> fasta: oh, there's a logic to the execution order alright. It just doesn't match the way a human being thinks about the problem when they're trying to see why a given lump of code isn't working.
06:35:17 <Invisible> I mean, you can execute in any order and get the same answer... I'm trying to figure out why the answer is wrong.
06:35:55 <fasta> Invisible: adding strictness annotations makes sure you can use the traditional: "Now, I expect this and now I expect that"-debugging.
06:35:57 <themroc> hmm takes a function as parameter?
06:36:09 <themroc> im coming from oop, its confusing me :p
06:36:09 <EvilTerran> themroc, indeed!
06:36:19 <EvilTerran> > map (+1) [1,2,3] -- map takes a function as a parameter
06:36:20 <lambdabot>   [2,3,4]
06:36:27 <Invisible> fasta: Don't think there's a way to make lists strict tho...
06:36:35 <fasta> Invisible: yes, there is.
06:36:46 <EvilTerran> > let twice f x = f (f x) in twice (+1) 0 -- so does this function "twice" i just defined
06:36:48 <lambdabot>   2
06:36:50 <fasta> Invisible: length for the spine (or rnf in general)
06:37:06 <fasta> Invisible: and for the elements, you just show them.
06:37:18 <Zao> themroc: Well, you can pass function pointers and functors just fine in manly OO languages.
06:37:19 <fasta> Invisible: (before passing them somewhere else)
06:37:55 <fasta> What's a functor in first-order-logic terminilogy btw?
06:38:24 <Zao> Functor in the C++/C# sense, that is.
06:38:29 <fasta> terminology*
06:38:42 <themroc> hmmm
06:38:57 <Invisible> OK guys, I'm going to wander off now...
06:39:03 * Invisible wanders off
06:39:30 <fasta> Mark Tarver uses it in his Qi book, but I cannot remember what functor in this context means.
06:39:34 <EvilTerran> themroc, when you'd pass a function as a parameter in haskell, you'd probably pass an object with that function as a method in OOP
06:39:51 <themroc> yeah
06:39:52 <Zao> (+1) would be similiar to bind(&operator+, _1, 1) or (_1 + 1).
06:40:03 <Zao> With Boost.Bind and Boost.Lambda.
06:41:01 <byorgey> fasta: I've never heard "functor" used as a first order logic term.
06:41:05 <themroc> im trying to understand the map thing now
06:41:24 <Zao> Or template <typename T> T addOne(T const & t) { return t + 1; }  :)
06:41:41 <Zao> Some things indeed are more elegant in Haskell.
06:43:14 <fr0ggler> hi everyone
06:43:35 <fasta> byorgey: do you know a good online reference for first order logic? Something which is easy to transscribe into a theorem prover? I have two good references, but they are >800 km away.
06:43:53 <fr0ggler> i am trying to build hexpat-pickle, but I'm getting as "out of scope" error (ghc 6.8.2)
06:43:57 <fr0ggler> an*
06:44:06 <byorgey> fasta: not off the top of my head, sorry, but maybe someone else does
06:44:44 <ryant5000> what's an elegant way of accomplishing the same thing as Reader, but in non-monadic code? implicit parameters?
06:45:06 <quicksilver> ryant5000: implicit parameters are inelegant.
06:45:10 <quicksilver> IMO.
06:45:14 <ryant5000> quicksilver: i generally agree
06:45:23 <quicksilver> prefer the reader monad or just a shared parameter.
06:45:27 <quicksilver> (which is the same thing)
06:45:37 <ryant5000> hm
06:45:46 <quicksilver> I'm not really sure what "non-monadic" code is, either ;) Code using the reader monad doesn't have to use "do".
06:45:56 <ryant5000> yeah yeah
06:45:58 <Guest41938> ryant5000: or the (->) monad
06:46:01 <georgehorse> fasta: when you were asking about functors before, in what sense of the word did you mean?
06:46:20 <ryant5000> but i don't want to use a bunch of monad combinators either :P
06:46:25 <fasta> georgehorse: as used in chapter 15 in the Qi book (available online).
06:46:34 <ryant5000> what i *really* want is module parameters and sub-modules :P
06:47:04 <ryant5000> but i don't suppose i'm getting those any time soon
06:47:16 <ryant5000> openable records would be a reasonable way of doing that, too
06:47:32 <ryant5000> well, here's the problem i'm trying to solve:
06:47:44 <ryant5000> i want to create a language/utterance system for internationalization
06:47:57 <georgehorse> fasta: have a page number?
06:48:24 <ryant5000> with the following properties: "utterances" are non-linguistic statements of meaning, which, since NLP is not exactly a solved problem, are *very* application-specific
06:48:29 <fasta> georgehorse: it's in the syntax definition, somewhere at the start of chapter 15. I don't have a page number here.
06:49:10 <ryant5000> for example, if you need your program to say "You have 5 missiles.", you'd make an "utterance" that describes that idea
06:49:30 <ryant5000> and then, for each language you'd like to render to, you write a corresponding translation
06:49:37 <ryant5000> now, the question is
06:50:05 <georgehorse> fasta: is the chapter `Type Checking as Proof'? not sure if I'm looking at the version you mean, there seem to be several
06:51:49 <ryant5000> how do you make it so that (1) you can add a new language without changing any of the utterance-generating code; (2) you can add new utterances without changing any utterance-generating code that doesn't use it; (3) you don't have to implement every utterance in every language; and (4) you can statically determine whether a given utterance can be rendered in a given language
06:52:03 <fasta> georgehorse: http://www.lambdassociates.org/Book/page319.htm
06:52:19 <fasta> georgehorse: this is a different version than the document I thought I was referring too.
06:52:24 <quicksilver> ryant5000: statically?
06:52:28 <fasta> georgehorse: but that is the page.
06:52:34 <ryant5000> quicksilver: yeah
06:52:43 <quicksilver> ryant5000: that's a surprising goal. It suggests all your modules will be recursively dependent
06:52:54 <quicksilver> changing any must recompile all
06:53:02 <ryant5000> it does?
06:53:20 <quicksilver> maybe.
06:53:28 <ryant5000> well, here's what i was thinking
06:53:28 <quicksilver> It depends what the other things you said mean.
06:53:44 <ryant5000> a two-parameter class in one module
06:53:55 <ryant5000> where the parameters are "language" and "utterance"
06:54:02 <ryant5000> and then a *ton* of instances
06:54:14 <ryant5000> probably organized by language, but probably not *everything* from one language in the same place
06:54:46 * quicksilver isn't convinced.
06:54:54 <quicksilver> Sounds a bit like an abuse of the typesystem.
06:55:09 <quicksilver> Why should individual languages and utterances be types, and not values?
06:55:21 <quicksilver> do you really want to define a new type every time you add a new utterance to the syste,?
06:55:40 <ryant5000> should I care whether I do?
06:55:55 <ryant5000> i mean, i'm not thrilled, on a gut level
06:55:57 <quicksilver> not necessarily, no.
06:56:04 <quicksilver> If it solves your problem go for it.
06:56:14 <ryant5000> well, i'm not yet sure whether it does
06:56:17 <quicksilver> But the tools and langauge often work best when you follow idiomatic lines.
06:56:31 <georgehorse> fasta: is http://en.wikipedia.org/wiki/Predicate_functor_logic what you were talking about?
06:56:39 <quicksilver> and having a type per language and type per utterance seems, intuitively, a strange idea.
06:56:50 <georgehorse> with functors in the context of fol
06:56:55 <quicksilver> That is, I'd need to be show some good advantages of that model.
06:57:07 <quicksilver> (As opposed to the model where 'Utterance' is a type and 'Language' is a type)
06:57:15 <fasta> georgehorse: not that I know of. I am just talking about what this author wrote, but I don't know what he means by functor in this context, hence the question.
06:57:33 <ryant5000> well, what if i rephrase the problem, as follows: I want a multimethod that's resolved at compile-time, and i want to know whether my code can ever hit an unimplemented part of the multimethod
06:57:50 <ryant5000> a "sparse, static multimethod"
06:58:56 <quicksilver> then you have to use typeclasses or TH
06:59:07 <quicksilver> which are the only kinds of compile-time programming GHC gives us.
06:59:22 <georgehorse> fasta: Well, lines 2, 3, and 4 all say that a (predicate|name|functor) is any non-variable symbol other than ~ & -> v <-> forall forevery, so I think he just means any predicate in first order logic
06:59:48 <ryant5000> here's the use case: I have project A, which I want to release in English and Hindi; I have project B, which I want to release in English and Spanish; they share half of their utterances; I need my translators to know what work needs doing at any given time, without guessing
06:59:58 <fasta> georgehorse: it's silly to define the same concept 3 times in the syntax.
06:59:59 <ryant5000> (obviously, i never want the user to be presented with "???")
07:00:07 <fasta> georgehorse: so, that's probably not what he means.
07:00:16 <fasta> georgehorse: at least, I hope not.
07:00:39 * Woof speaks Hindi
07:01:08 <ryant5000> Woof: cool; my business partner does as well; i don't speak a word of anything but english :P
07:01:11 <quicksilver> ryant5000: that information doesn't *have* to be conveyed by a GHC compile error.
07:01:24 <quicksilver> ryant5000: your translators may not find type class errors terribly helpful anyway.
07:01:24 <Woof> I see, ryant5000. Lol
07:01:27 <georgehorse> fasta: *shrug* I don't claim to know what he intended, just that the three rules are word-for-word identical (except for 4. not having the word `any', but that seems a typo)
07:01:43 <quicksilver> ryant5000: that information could be conveyed by some tool which is part of your translation suite.
07:01:56 <quicksilver> ryant5000: but I agree that, if you want a missing translation to be a compile error, you have to use typeclasses or TH.
07:02:02 <georgehorse> and that I've never heard of the term `functor' meaning anything regarding the definition of first order logic
07:02:37 <ryant5000> quicksilver: yeah, i suppose it doesn't have to be the type system that tells me, but I'm having a hard time coming up with a more fool-proof way
07:03:23 <quicksilver> ryant5000: I strongly recommend you do a very small proof of concept implementation and find out the practical issues
07:03:29 <ryant5000> quicksilver: also, i wouldn't expect translators to work in GHC; instead, programmers (who would be the ones creating new utterances) would be expected to create the appropriate instances in some flagged way
07:03:29 <quicksilver> ryant5000: because this is basically a practical question ;)
07:03:36 <ryant5000> quicksilver: i'm about to :)
07:03:59 <quicksilver> ryant5000: my gut feeling is this is what I would call "abuse" of the Type system, but that doesn't mean it may not be the most effective way to solve your problem.
07:04:22 <quicksilver> if you trust GHC's type class resolution system to be correct, and you can encode your problem in it, then you can use it as a proof checker.
07:04:40 <ryant5000> i certainly trust it more than any system i'd be willing to build in the timeframe i've got :P
07:04:44 <quicksilver> quite.
07:04:49 <quicksilver> I trust it too :)
07:07:36 <themroc> EvilTerran?
07:09:12 <fasta> georgehorse: ok, well, two other people which agree with me that functor is weird to use in this context is enough for me. Thanks.
07:10:28 <hackagebot> gnome-desktop 1.0.0.0 - Randomly set a picture as the GNOME desktop background (ColinAdams)
07:10:39 <opqdonut> heh
07:10:54 <Saizan_> fasta: in a prolog context is not uncommon to see functor as "function symbol in terms", ime
07:12:16 <lpsmith> well,  then you have ML functor,  which mean something entirely different :-P
07:12:38 <fasta> lpsmith: yes, I know.
07:12:55 <fasta> Saizan_: but that's basically a synonym of predicate in Prolog, no?
07:13:01 <Saizan_> fasta: no
07:13:16 <Saizan_> fasta: predicates define relations over terms
07:13:27 <Saizan_> fasta: functors are what terms are made of
07:13:39 <fasta> Saizan_: oh, then please explain. In Prolog, the word functor is used to refer to the atom at the start of a structure. For example, in likes(mary, pizza), likes is the functor. In a more complex structure, like
07:13:40 <Saizan_> fasta: if you see constants as zero arity functors
07:13:42 <lpsmith> or C++ functors.   The word seems to be universal,  but every language uses it differently :-P
07:13:47 <fasta> Saizan_: http://www.cse.unsw.edu.au/~billw/prologdict.html
07:14:16 <Saizan_> fasta: functors are like constructors in haskell
07:14:17 <dschoepe> How do I remove a package installed via cabal-install?
07:14:38 <Saizan_> fasta: you use them to build values and in pattern-matching
07:14:40 <dschoepe> Just unregistering it and deleting the files manually or is there a better way?
07:15:15 <Saizan_> fasta: predicates instead are more like functions, except they define relations
07:15:22 <ryant5000> quicksilver: btw, one thing i neglected to mention is that i want to be able to write arbitrary Haskell in the implementation of a given utterance's render function
07:15:26 <nainaide> what difference between hdbc odbc driver and hdbc postgresql driver, can I use hdbc odbc driver on postgresql?
07:15:39 <lpsmith> Haskell's functors are at least related to functors in category theory
07:15:53 <ryant5000> quicksilver: specifically, i want "You have %d missiles." to be able to add and remove the pluralization of "missile" correctly for every conceivable language
07:15:56 <Saizan_> fasta: though you don't know a priori if something like likes(mary,pizza) is a term or a predicate invocation
07:16:29 <Saizan_> fasta: because prolog doesn't distinguish them syntactically
07:16:37 <fasta> Saizan_: ah, so if it is used as a term it's a functor, and otherwise a predicate?
07:16:49 <quicksilver> ryant5000: I imagined something like that, being vaguely aware of the problems of i18n, but didn't think hard about how you'd do it ;)
07:16:54 <Saizan_> fasta: yeah
07:17:16 <fasta> Saizan_: ok, then I guess you solved the mystery :)
07:17:19 <ryant5000> quicksilver: yup; it's an idea i've been toying with for a while :P
07:17:24 <Saizan_> fasta: and sometimes terms get interpreted as predicates by some meta- operators like call
07:17:42 <ryant5000> quicksilver: i've found that, generally, problems that *actually* require n*m code are very poorly supported by existing languages
07:17:54 <fasta> Saizan_: yes, I knew that was possible (though, I never did so).
07:17:55 <ryant5000> quicksilver: for practically any variables m and n
07:21:44 <quicksilver> ryant5000: interesting observation.
07:21:50 <quicksilver> ryant5000: I do think you should at least consider TH.
07:21:57 <quicksilver> ryant5000: it's horrible to use but very powerful.
07:22:14 <ryant5000> quicksilver: i might, to cut down on boilerplate
07:22:32 <ryant5000> quicksilver: i might end up using it completely, but i think it's more likely i'll use it together with some weird type hackery :P
07:22:35 <quicksilver> or just use poor-mans TH and write .hs code which generates more .hs files ;)
07:22:41 <ryant5000> haha
07:22:59 <ryant5000> i'm comfortable enough with TH, i think
07:23:08 <quicksilver> a mediocre programmer writes code to solve a problem. A good programmer writes code to write the code which solves the problem. etc.
07:23:16 <ryant5000> haha
07:23:30 <quicksilver> an exceptional programm writes the code for a bot called 'mmorrow' which then solves all the problems?
07:23:42 <ryant5000> the real trick would be to not even *know* how many layers deep your code is :P
07:24:12 <ryant5000> a lazy list generator that rewrites all its own code every time the remaining thunk gets forced >.>
07:24:38 <hackagebot> cpphs 1.7 - A liberalised re-implementation of cpp, the C pre-processor. (MalcolmWallace)
07:24:56 <ryant5000> is hsplugins still being maintained?
07:25:27 <ryant5000> (i've been away from the haskell scene for almost 3 years)
07:26:29 <quicksilver> ryant5000: not very actively, I think?
07:26:41 <quicksilver> there is plain "plugins" and also "mueval"
07:26:50 <ryant5000> hm
07:26:52 <quicksilver> dons would know I guess.
07:27:08 <gwern> hs-plugins just goes throug the ghc api now; you'd be better off using hint
07:27:10 <ryant5000> yeah; i'll have to talk to him about it some time
07:27:19 <fasta> What's the getopt Haskell equivalent of choice these days?
07:27:39 <gwern> getopt?
07:27:40 <ryant5000> gwern: ah, interesting
07:27:43 <fr0ggler> sorry to repeat my question... I'm trying to build hexpat-pickle, and am getting an out of scope error. i'm pretty new to Haskell so trying to fix it is a bit beyond my ken, but if anyone can help that's be great.  code with problematic line is highlighted here: http://paste.uni.cc/20056
07:28:06 <earthy> System.Console.GetOpt. :)
07:28:11 <quicksilver> fasta: I've always been happy with the System.Console one
07:28:52 <earthy> fasta: the docs actually show a nice pair of examples, even.
07:29:08 <doserj> fr0ggler: fix the indentation. Right _ should be aligned with the Left err
07:29:19 <fasta> Wow, documentation! ;)
07:29:24 <gwern> earthy: you can't use it without copying the examples...
07:29:42 <gwern> figuring out how to use getopt took me forever
07:29:52 <earthy> gwern: um. true enough.
07:29:56 <earthy> it's somewhat opaque
07:30:04 <fr0ggler> doserj, in the source, they are aligned - i think the pastebin mucked that up when i commented it :)
07:30:19 <earthy> but it's not *too* horrid otherwise
07:30:50 <doserj> fr0ggler: are you using tabs?
07:30:55 <gwern> no, to be horrid it'd need to use some gadts or fundeps or something; it's just terrible
07:31:50 <earthy> it's certainly nicer than doing it with C's getopt(3)
07:31:59 <fr0ggler> doserj, this is a straight copy from the source, and vim, nedit and other text editors all show them as aligned
07:32:06 <doserj> fr0ggler: ok, what exactly is out of scope, the 'm', or the 'rights'?
07:32:12 <fr0ggler> doserj, rights
07:32:28 <doserj> fr0ggler: and where is it defined?
07:33:01 <fr0ggler> nowhere, and hence the "out of scope", but i'm not experienced enough in Haskell to work out what type I need to declare
07:33:29 * saml do not use type annotation unless compiler complains
07:37:31 <doserj> fr0ggler: you should know what type m has, and what type unpickleTree' has
07:42:51 <fr0ggler> doserj, I guess m is a list of munge'd Elements?
07:44:08 <Athas> I have a problem with Haskell-mode in Emacs.  `haskell-indent-offset' is 4, yet it behaves as if it was 2 when I indent.
07:44:13 <doserj> fr0ggler: m = munge nodes, so I guess, yes (whatever "munged" and "elements" mean)
07:45:05 <int-e> Athas: check haskell-indent-after-keywords
07:45:28 <Athas> Ah yes, that's it.
07:45:45 <Athas> Is there any consensus in the Haskell community on what the indentation should be?  I don't have any particular preference myself.
07:46:10 <jauaor> mm
07:46:12 <themroc> hmm anyone defined a type which can handle infinity as value?
07:46:14 <jauaor> consensus
07:46:17 <jauaor> not really
07:46:26 <quicksilver> I don't care much as long as it's clear
07:46:29 <jauaor> Athas: i think the consensus is make it readable
07:46:31 <jauaor> :P
07:46:32 <quicksilver> I think I use 2 spaces after thinks like "do"
07:46:37 <opqdonut> themroc: well there is Nat which has infinity
07:46:39 <byorgey> themroc: sure.  for example,  data Nat = Zero | Succ Nat
07:46:46 <Athas> I'll just use Emacs defaults, then.
07:46:47 <byorgey> then infinity = Succ infinity
07:46:48 <opqdonut> infinity = fix Succ, that is
07:47:08 <byorgey> I think there's even a package for it on Hackage.
07:47:15 <quicksilver> Athas: I find kuribas' alternative indentation mode to be much better than one bundled with haskell-mode.
07:47:18 <themroc> hmm
07:47:35 <saml> > Infinity
07:47:37 <lambdabot>   Not in scope: data constructor `Infinity'
07:47:54 <saml> > NaN
07:47:56 <lambdabot>   Not in scope: data constructor `NaN'
07:48:13 <quicksilver> there are infinity and nan special values in Double
07:48:21 <quicksilver> but they're not terrible useful to most people
07:48:29 <quicksilver> (and they're not guaranteed to exist on all platforms)
07:48:56 <saml> what kind of operations do you want to perform on infinity?
07:49:09 <saml> cardinality infinityA > cardinality infinityB ?
07:49:15 <georgehorse> has anyone actually written a haskell compiler for a system that doesn't use ieee 754?
07:49:20 <themroc> i need to define a type which has normal integer numbers, and the sting "+Inf" as infitiy sign
07:49:28 <themroc> so hmm
07:49:39 <themroc> i thought of having a touple, one with integer and one with bool
07:49:46 <opqdonut> Maybe Int
07:49:49 <opqdonut> will probably work also
07:49:53 <saml> data MyNum a = Infinity | Integer a ?
07:49:59 <copumpkin> georgehorse: not that I know of
07:49:59 <quicksilver> data IntsPlusInf = JustAnInt Int | PlusInf
07:50:10 <quicksilver> (which is the same as Maybe Int, but with special names)
07:50:13 <themroc> what exactly means "|" ?
07:50:30 <saml> it means or
07:50:31 <quicksilver> it separates constructors, in that context
07:50:33 <Axman6> @src Maybe
07:50:33 <lambdabot> data Maybe a = Nothing | Just a
07:50:43 <quicksilver> I think you may need to read a basic haskell tutorial.
07:50:43 <quicksilver> I recommend lyah
07:50:46 <quicksilver> @where lyah
07:50:50 <lambdabot> www.learnyouahaskell.com
07:50:52 <quicksilver> erm
07:50:55 <quicksilver> ah, there we are.
07:50:57 <Axman6> the datatype MAybe a is wither Nothing or Just a
07:50:57 <quicksilver> slowbot!
07:50:58 <themroc> :p
07:51:09 <saml> values of type IntsPlusInf can be constructed with JustAnInt Int "or" PlusInf
07:51:12 <themroc> also we have to define it as type
07:51:25 <opqdonut> is this homework?
07:51:31 <themroc> yes
07:51:32 <themroc> sortof
07:51:40 <opqdonut> well, start reading a tutorial
07:52:13 <Axman6> @quote homewowk
07:52:13 <Athas> quicksilver: where can I get that indentation mode?
07:52:13 <lambdabot> No quotes match. :(
07:52:16 <Axman6> @quote homework
07:52:16 <lambdabot> vincenz says: sure, give us your homework and we'll email it straight to your teacher :)
07:52:24 <saml> we're here to do homeworks of other people. so, collectively, we'll finish all of our homeworks on time.
07:52:25 <themroc> haha
07:52:27 <Axman6> @quote homework
07:52:27 <lambdabot> dons says: [In reference to <joelr1> did you guys know that #ocaml has 37 members and #erlang has 34 vs. 202 on #haskell?] I think part of the #haskell success comes from the approach that we all
07:52:27 <lambdabot> know each other, it's not a homework channel like #java. We created a community of peers, working on the overall goals of the community. That's why people keep coming back
07:52:31 <quicksilver> @where kuribas-indentation
07:52:31 <lambdabot> http://kuribas.hcoop.net/haskell-indentation.el
07:52:35 <quicksilver> Athas: there.
07:53:03 <Athas> quicksilver: thanks.
07:55:35 <dhun> I am trying to parse (a very limited subset of) html with Parsec. I got a tag with one attribute. attr is my attributes if I say attr it works but if I say many(attr) it does not work anymore. I would expect to get a list that contains a single item, which it the result of attr
07:56:01 <dhun> ... attr is my parser for attributes ...
07:56:04 <a_guest> Are the scoping rules for "let in" and "where" blocks different? I look at them as equal, except pre, post syntax.
07:56:18 <ryant5000> dhun: did you include the leading space in the "attr" definition?
07:56:25 <dhun> yes
07:56:35 <dhun> is there anything wrong with it
07:56:37 <ryant5000> well, there goes my guess :P
07:56:49 <Axman6> a_guest: you can use let inside a do block to refer to something on the left of a <-
07:57:21 <Axman6> do str <- readLn; let f = str ++ str; putStrLn f
07:57:37 <georgehorse> what's the canonical place to put non-systemwide .el files? ~/.emacs.d ?
07:57:46 <dhun> thats the thing I am trying to parse <br a / >
07:58:31 <dhun> the funny thing is that <br a/ > works
07:59:17 <doserj> a_guest: where is for definitions, let for expressions. for example, f x | g x > 0 = ... | g x < 0 = ... where g y = ... is not possible with let
08:00:03 <a_guest> Axman6: your answer solved my confusion. I used a "where" block inside a monad.
08:01:25 <dhun> ryant5000 could you give me some more hints please?, I was also thinking about leading spaces but I currently don't understand why it does not work
08:01:52 <ryant5000> dhun: did you paste your code somewhere?
08:02:20 <dhun> I can paste the important part the overall code is to complex I am afraid
08:02:42 <ryant5000> dhun: you know about hpaste, right?
08:02:46 <ryant5000> @where hpaste
08:02:47 <lambdabot> http://hpaste.org/
08:02:51 <quicksilver> a_guest: they have very different grammatical locations.
08:03:03 <quicksilver> a_guest: "let in" applies to expressions (and forms expressions)
08:03:14 <quicksilver> a_guest: "where" attachs to declarations (which remain declarations)
08:04:03 <dhun> ryant5000 here it is http://de.wikibooks.org/wiki/Benutzer:Dirk_Huenniger/haskell2
08:04:26 <dhun> I am trying to match the parser start in the record brparser
08:06:13 <Axman6> a_guest: where is used after a function definition
08:07:14 <quicksilver> Axman6: or a value defintion. Or a case expression. :)
08:07:34 <fasta> How does System.Console.GetOpt use  "explanation of option for user"?
08:07:44 * copumpkin yawnles
08:07:58 <ryant5000> dhun: sorry, it's a bit much for me to sort through right now; i'd say there's probably some issue with one attribute eating into the next; you should see if you can break down your parser into smaller components and test each one very rigorously
08:08:08 <EvilTerran> fasta, presumably in error messages of some description?
08:08:14 <fasta> EvilTerran: never mind
08:08:23 <fasta> EvilTerran: it was the usageInfo function that I missed.
08:08:25 <dhun> ok thnak you ryant5000
08:09:02 <ryant5000> dhun: np; sorry i couldn't be of more help
08:15:22 <jrick> BONUS: hey, I'm going through your tutorial, but I don't really like the way you implement the elem function by using foldl.  If I call something like "elem' 4 [1..]", it will just hang there forever.  However, when using elem, this works.  Maybe you could say something about this?
08:19:14 <gwern> @src elem
08:19:14 <lambdabot> elem x    =  any (== x)
08:20:08 <skorpan> ah, MissingH is so nice
08:22:00 <fasta> How can you force that a certain argument must be there? Currently, calling the program as ./Foo arg1 doesn't return an error, even though it should. I only have one option currently which uses ReqArg.
08:22:44 <fasta> The correct way to call the program would be ./Foo --bar=2
08:24:00 <dhun> ryant5000 I made a very simply testcase that should work, but it does not, so from here it should be possible to see what I misunderstood http://de.wikibooks.org/wiki/Benutzer:Dirk_Huenniger/haskell2
08:24:01 <gwern> reqarg only distinguishes betwen --bar and --bar=foo
08:24:14 <Saizan_> ReqArg requires an argument for the option, if the option is given at all, i don't think there's a way to enforce the latter
08:24:29 <Saizan_> inside getopt
08:24:32 <roconnor> @hoogle split
08:24:32 <lambdabot> Data.ByteString split :: Word8 -> ByteString -> [ByteString]
08:24:32 <lambdabot> Data.IntMap split :: Key -> IntMap a -> (IntMap a, IntMap a)
08:24:32 <lambdabot> Data.IntSet split :: Int -> IntSet -> (IntSet, IntSet)
08:24:39 <roconnor> @hoogle++
08:24:39 <lambdabot> Data.Map split :: Ord k => k -> Map k a -> (Map k a, Map k a)
08:24:39 <lambdabot> Data.Set split :: Ord a => a -> Set a -> (Set a, Set a)
08:24:39 <lambdabot> System.Random split :: RandomGen g => g -> (g, g)
08:24:59 <roconnor> @type unfoldr
08:25:00 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
08:25:18 <roconnor> @type unfoldr (Just . split)
08:25:19 <lambdabot> forall b. (RandomGen b) => b -> [b]
08:25:44 <roconnor> @type findIndex
08:25:45 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe Int
08:25:54 <gwern> I'm sure there's a way to do it though; I'm fairly sure I did a required option in mueval
08:25:56 <roconnor> @type findElem
08:25:57 <lambdabot> Not in scope: `findElem'
08:26:07 <roconnor> @hoogle find
08:26:07 <lambdabot> Data.ByteString find :: (Word8 -> Bool) -> ByteString -> Maybe Word8
08:26:07 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
08:26:07 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
08:26:24 <roconnor> @type elemIndex
08:26:25 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe Int
08:26:43 <fasta> Saizan_: is there another library which does have that behaviour? It seems very silly to me. If it is _required_, it should be required ;)
08:27:00 <ryant5000> dhun: what's the output?
08:27:16 <gwern> oh, guess I didn't
08:27:20 <dhun> parse error at (line 1, column 6):
08:27:21 <dhun> unexpected end of input
08:27:21 <dhun> expecting letter or digit
08:27:46 <dhun> so if the first part matches and the second one fails
08:27:54 <dhun> many fails totally
08:27:57 <ryant5000> ok, so it's still in the "many attr" part
08:28:40 <ryant5000> i think you need to insert a try somewhere - although this is where my Parsec experience runs out :P
08:28:54 <dhun> yes I think so too
08:28:55 <ryant5000> i think perhaps it should be many (try attr)
08:29:02 <dhun> good idea
08:29:28 <Saizan_> fasta: different point of view on "required" :) and no i don't know other libraries, but i might be wrong as gwern says
08:29:44 <dhun> yes no it works
08:29:53 <dhun> thankyou ryant5000
08:29:57 <ryant5000> dhun: no problem
08:30:12 <ryant5000> hopefully that solution will translate to the overall problem :)
08:30:27 <ryant5000> anyway, i've got to head off now; good luck
08:30:28 <dhun> I am quite sure it will
08:30:45 <dhun> ok bye
08:34:26 <dhun> it works for the overall problem too
08:34:51 <koeien> what is the best way to use UTF-16 in combination w/ bytestrings ?
08:39:14 <doserj> koeien: what exactly do you want to do? maybe http://hackage.haskell.org/cgi-bin/hackage-scripts/package/text helps?
08:39:49 <koeien> doserj: yeah i'm taking a look at text right now.
08:40:03 <koeien> utf8-string might be inefficient for this specific file
08:40:50 <nainaide> can I use hdbc-odbc driver for postgresql
08:41:11 <doserj> koeien: utf8-string doesn't support utf16 anyways, does it?
08:41:27 <koeien> doserj: i'm talking about the internal representation of my strings
08:41:54 <koeien> text seems to use UTF-16 as internal representation, and is able to read UTF-{8,16,32} and more
08:42:21 <koeien> nainaide: not sure, if postgres supports ODBC it should work, but it seems more straightforward to use HDBC-postgresql instead
08:42:31 <koeien> so i'll go with text :)
08:42:57 <roconnor> > let trials = 1000 in map (\target -> (target,(fromIntegral $ sum $ take trials $ map (\g -> fromJust $ elemIndex target $ transpose $ take 8 $ tails $ (randoms g)) (unfoldr (Just . split) (mkStdGen 20090622)))/(fromIntegral trials))) [replicate 8 True,"1234">>[True,False],[True,True,False,False,True,False,True,True]]
08:43:00 <lambdabot>   [([True,True,True,True,True,True,True,True],482.416),([True,False,True,Fals...
08:43:35 <nainaide> koeien, thanks. HDBC-postgresql depends on libpq that forbidened by postgres-8.3+
08:44:24 <nainaide> by now, there is no  HDBC-postgresql  works on postgres I think, because of libpq
08:45:04 <jrick> 37
08:45:06 <jrick> oops
08:45:10 <jrick> sorry, wrong window
08:45:16 <EvilTerran> sixtyten!
08:45:23 <byorgey> 42!
08:45:57 <byorgey> roconnor: what on earth?
08:47:56 <deech> Hi all, I'm having an issue with HXT. Basically I want read an XML document from the web using 'readDocument' and store the result in a StateT monad. And then at some point in the future I want to run some HXT arrow operations. How do I convert it back into an Arrow? The code is here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6157#a6157.
08:48:35 <fasta> I won again!
08:49:06 <deech> I tried to read the source of 'readDocument' for some clues on how to create an IOSArrow but came up empty.
08:49:16 <fasta> You are supposed to ask what I won, now.
08:49:18 <koeien> nainaide: a simple test allowed me to connect to a postgresql-8.3 server though.
08:49:24 <fasta> ghc: panic! (the 'impossible' happened)
08:49:24 <fasta>   (GHC version 6.10.2 for i386-unknown-linux):
08:49:24 <fasta>         getOptions'.parseLanguage(1) went past eof token
08:49:27 <koeien> nainaide: are there any other problems?
08:49:54 <ryant5000> what's preventing haskell from having an ML-style module system?
08:50:02 <fsdfds> how do i download all the list of videos (streaming) from a site
08:50:14 <nainaide> koeien, through odbc?
08:50:19 <nainaide> koeien, through hdbc?
08:50:27 <koeien> nainaide: no. HDBC-postgresql
08:50:44 <fasta> ryant5000: economic laws
08:51:08 <ryant5000> fasta: how so?
08:51:17 <koeien> c <- connectPostgreSQL "user=haskell password=hunter2 hostaddr=127.0.0.1 port=5432 dbname=haskell"
08:51:19 <ryant5000> fasta: just too difficult?
08:51:45 <quicksilver> fsdfds: that doesn't sound like a haskell question.
08:51:46 <nainaide> Good, I use gentoo, it seems the HDBC-postgresql ebuild should modify
08:51:58 <koeien> nainaide: i'll check a simple SELECT
08:52:56 <fasta> ryant5000: for academics, I don't think it's interesting to write anything about it any more. It's kind of a dead horse. People in industry have other things to do. Fixing the module system has low priority. So, it's just a money problem.
08:53:35 <ryant5000> fasta: ah, i see
08:53:52 <ryant5000> fasta: i suppose practicality is not at the top of academics' lists of priorities :P
08:54:10 <byorgey> fasta: do you have a malformed {-# ... #-} pragma at the top of your file?  or perhaps the closing #-} is at the start of the line?
08:54:31 <byorgey> I think this bug is fixed in ghc HEAD
08:54:34 <fasta> byorgey: yes, I have. Good guess!
08:54:59 <koeien> nainaide: the SELECT worked as expected.
08:55:25 <nainaide> koeien,  I see, thank you!
08:55:46 <byorgey> http://arcanux.org/lambdacats/fixed-in-head.jpg
08:55:46 <koeien> (I don't know where you got your info re. 8.3+ and libpq though :)
08:55:58 <byorgey> fasta: I ran into that bug just the other day =)
08:56:06 <nainaide> So, I need to change the ebuild of HDBC-postgresql
08:56:10 <petermarks> deech: can't you just runX again later passing in the tree? A while since I played with HXT, do you know where runX is defined?
08:56:14 <koeien> nainaide: i used cabal
08:56:27 <nainaide> koeien,  understand!
08:58:35 <petermarks> deech ah, no, runX is a wrapper over runXIOState. You need the runXIOState so you can pass in the tree
08:58:35 <nainaide> koeien, btw, I think if hdbc-odbc works both MySQL and Postgres, that would be better
08:59:24 <koeien> nainaide: could be :) although configuring ODBC may be a bit more difficult then just the connection string
08:59:31 <koeien> i don't know about performance, et al
08:59:47 <koeien> debian has the package odbc-postgresql, so in theory it should work
09:00:14 <petermarks> I think: runXIOState (initialState tree) myProcessor
09:00:16 <deech> petermarks: Where is runXIOState defined? I can' t find it.
09:00:19 <nainaide> koeien, yeah, I found the package
09:00:47 <petermarks> Text.XML.HXT.Arrow.XmlIOStateArrow with runX :-)
09:03:25 <deech> petermarks: I am looking at the API documentation ( http://hackage.haskell.org/packages/archive/hxt/8.3.1/doc/html/Text-XML-HXT-Arrow-XmlIOStateArrow.html ) and I don't see this function? Is it perhaps in an older version of HXt?
09:05:30 <deech> petermarks: Oh I see it now, I don't think it is exported, but I could use it for ideas. Thanks !
09:05:32 <petermarks> hmm, seems it is not exported
09:06:03 <fsdfds> dont you feel scared of hot and cold and cut pains it hurts very bad so how do you have so many wars
09:06:53 <petermarks> deech: remember xmlIOStateArrow is a State and IO, so you may be able to doe everything in there nad not have to go out and in again
09:08:24 <skorpan> @index startsWith
09:08:25 <lambdabot> bzzt
09:08:32 <skorpan> @index startswith
09:08:33 <lambdabot> bzzt
09:08:53 <skorpan> this is weird, i'm using some function called startsWith but i don't know where i got it from
09:09:37 <skorpan> is there any easy way to find out?
09:11:43 <quicksilver> skorpan: load your code in ghci
09:11:48 <quicksilver> skorpan: nad type :i startsWith
09:11:55 <quicksilver> skorpan: (that will tell you which module it came frmo)
09:12:13 <dons> ghc parallel performance tuning, http://www.reddit.com/r/programming/comments/8um52/new_paper_parallel_performance_tuning_for_haskell/
09:12:24 <skorpan> it says not in scope :|
09:12:39 <skorpan> oh snap i've been editing the wrong file
09:12:42 <skorpan> FUUUUUUUUUU....
09:12:43 <quicksilver> taht can be it :P
09:13:33 <burp> nice
09:18:58 <enolan> @seen BSP
09:18:59 <lambdabot> BSP has changed nick to bsp_.
09:18:59 <lambdabot> I saw bsp_ leaving #haskell-in-depth, #ghc and #haskell 3d 3h 50m 40s ago, and .
09:37:03 <lavell> test
09:38:35 <lavell> quit
09:38:49 <saml> test
09:39:22 <saml> guit
09:43:17 <saml> hi lavell
09:43:25 <lavell> hi saml
09:43:39 <saml> do you know FRP?
09:43:56 <lavell> I'm just starting out in haskell
09:44:03 <lavell> This is day one for me
09:44:27 <saml> that's really nice
09:44:27 <lavell> Getting through "Real World Haskell" chapter 1
09:44:52 <saml> that's a really nice book
09:48:37 <byorgey> lavell: welcome!
09:49:01 * byorgey presents lavell with a golden lambda, inscribed with today's date
09:57:16 <lavell> thanks byorgey
09:57:54 <Plouj> I guess this is a better channel to ask how I can cleanly remove all files belonging to a user installation of cabal such as ~/bin/cabal.
09:59:10 <Synth-c> for a linguistic application i want to use a sort of heterogenous list of functions, something like: [a,a->b,b,(a->b)->a->b)]
09:59:38 <copumpkin> ryant5000: yo, you around?
09:59:58 <Synth-c> anybody have and idea how to do this?
10:00:34 <roconnor> Synth-c: what do all your elements have in common?
10:02:37 <Synth-c> they are all functions of composed of types a or b
10:02:44 <Synth-c> or values of type a
10:03:17 <Elly> so make a datatype that includes all those values, and use that for the list's base type
10:03:24 <roconnor> well, it's a bit hard to tell what is best with so little information to go on but:
10:04:33 <Synth-c> I tried that, the problem with that approach is that only a limited subset of functions can be put in the list
10:04:38 <roconnor> data Foo a b = Quux a | Quix b | Zugzuwang ((Foo a b) -> (Foo a b))
10:04:49 <roconnor> Thenn [Foo a b]
10:05:22 <skorpan> > "# hello" `startswith` "#"
10:05:24 <lambdabot>   Not in scope: `startswith'
10:05:30 <skorpan> Prelude Data.List.Utils> "# heohoehu" `startswith` "#"
10:05:30 <skorpan> False
10:05:31 <roconnor> isPrefixOf
10:05:41 <skorpan> > "# hello" `isPrefixOf` "#"
10:05:42 <lambdabot>   False
10:05:46 <skorpan> oh.........
10:05:49 <roconnor> flip isPrefixOf
10:06:03 <skorpan> i wonder if goerzen knows about this
10:06:11 <skorpan> startswith is an alias for isPrefixOf in MissingH
10:07:06 <Synth-c> thanks, i'll try that method
10:07:08 <roconnor> Synth-c: did that make sense?
10:07:12 <roconnor> good
10:07:13 <skorpan> i suppose he does know, but boy is that counter-intuitive
10:07:45 <Synth-c> yeah, it makes sense, let me sse if it plays nice with the rest of my code
10:08:43 <roconnor> mmmm Non-monotoic fixpoints
10:09:10 <skorpan> > "#hello" `isPrefixOf` "#"
10:09:12 <lambdabot>   False
10:09:16 <skorpan> this is just so wrong
10:09:35 <roconnor> "#hello" isn't a prefix of "#"
10:09:45 <skorpan> oh, right
10:09:54 <skorpan> startswith is still so wrong
10:10:02 <skorpan> no, it's not
10:10:03 <skorpan> ...
10:10:21 <skorpan> here i am, writing an e-mail to goerzen about changing the definition of startswith...
10:10:33 <roconnor> startswith might be wrong
10:10:45 <skorpan> oh, right
10:10:48 <skorpan> my brain is exploding
10:10:54 <skorpan> i don't know anything anymore
10:11:03 <roconnor> @quote exploding
10:11:04 <lambdabot> No quotes match. Are you on drugs?
10:11:10 <roconnor> @quote maiden
10:11:11 <lambdabot> Meehl says: [The null hypothesis significance test is] a potent but sterile intellectual rake who leaves in his merry path a long train of ravished maidens but no viable scientific offspring
10:14:19 <saml> @type startsWith
10:14:20 <lambdabot> Not in scope: `startsWith'
10:15:21 <Alpounet> @hoogle startsWith
10:15:22 <lambdabot> No results found
10:15:52 <ivan_> @hoogle isPrefixOf
10:15:52 <lambdabot> Data.ByteString isPrefixOf :: ByteString -> ByteString -> Bool
10:15:52 <lambdabot> Data.List isPrefixOf :: Eq a => [a] -> [a] -> Bool
10:15:52 <lambdabot> Data.ByteString.Char8 isPrefixOf :: ByteString -> ByteString -> Bool
10:16:43 <skorpan> startswith (lower-case) is an alias for isPrefixOf which is obviously incorrect
10:16:47 <skorpan> it should be flip isPrefixOf
10:17:58 <Synth-c> yeah, it makes sense, let me sse if it plays nice with the rest of my code
10:18:16 <Saizan> "foo" `isPrefixOf` "foobar"
10:18:40 <skorpan> > "foo" `isPrefixOf` "foobar"
10:18:41 <lambdabot>   True
10:18:50 <skorpan> > let startswith = isPrefixOf in "foo" `startswith` "foobar"
10:18:52 <lambdabot>   True
10:19:06 <petermarks> skorpan: seems fine to me
10:19:13 <skorpan> foo startswith foobar?
10:19:30 <petermarks> reads correctly too
10:19:35 <skorpan> > let startswith = flip isPrefixOf in "foo" `startswith` "foobar"
10:19:36 <lambdabot>   False
10:19:42 <skorpan> foo does *not* start with foobar
10:20:28 <petermarks> let startsWith = flip isPrefixOf in "foobar" `startsWith` "foo"
10:20:40 <petermarks> > let startsWith = flip isPrefixOf in "foobar" `startsWith` "foo"
10:20:42 <lambdabot>   True
10:20:57 <skorpan> foobar doesn't start with foo
10:21:01 <skorpan> uh...
10:21:05 <copumpkin> o.O
10:21:12 <skorpan> stop screwing with my brain
10:21:15 <skorpan> it's fragile
10:21:42 <petermarks> foobar does start with foo
10:21:55 <skorpan> yes
10:22:02 <skorpan> but startswith = isPrefixOf
10:22:07 <petermarks> so what's the problem?
10:22:12 <skorpan> > let startsWith = isPrefixOf in "foobar" `startsWith` "foo"
10:22:14 <lambdabot>   False
10:22:16 <skorpan> that's the problem
10:22:45 <petermarks> startsWith only equals isPrefixOf is you define it that way
10:22:55 <Alpounet> then, withStarts :-p
10:23:10 <skorpan> petermarks: what?  startswith is equal to isPrefixOf in MissingH, that's the problem
10:23:22 <Alpounet> or htiWstrats
10:23:38 <petermarks> ah, don't know MissingH. let me look...
10:24:36 <petermarks> can you give me a url fo MissingH, I can't find it
10:24:56 <skorpan> sure
10:25:04 <skorpan> http://software.complete.org/static/missingh/doc//MissingH/
10:25:07 <skorpan> in Data.List.Utils
10:25:10 <yitz> @seen Gracenotes
10:25:10 <lambdabot> Gracenotes is in #concatenative, #haskell-in-depth, #haskell-overflow, #haskell-blah and #haskell. I last heard Gracenotes speak 4h 42m 1s ago.
10:26:28 <davidL> > "foobar" `flip isPrefixOf` "foo"
10:26:30 <lambdabot>   <no location info>: parse error on input `isPrefixOf'
10:26:41 <davidL> why doesn't that parse?
10:26:58 <petermarks> looks like is is designed to be used prefix rather than infix: startsWith "foo" "foobar"
10:27:07 <skorpan> davidL: you can't put multiple words inside of that
10:27:14 <skorpan> petermarks: right, but it's still not intuitive
10:27:16 <petermarks> presumably so you can partially apply it easily
10:27:22 <skorpan> it would be way more useful if it was indeed "flip isPrefixOf"
10:27:28 <petermarks> so don't use it
10:27:33 <skorpan> right, i won't :)
10:27:39 <davidL> skorpan: is that just the way the grammar is defined?
10:27:43 <skorpan> davidL: yes
10:28:58 <yitz> @tell Gracenotes The answer is: define instance traversable ((,) a), then you have traverse :: Applicative f => (b -> f c) -> (a, b) -> f (a, c).
10:28:58 <lambdabot> Consider it noted.
10:29:14 <petermarks> i guess it is so you can write iCare = startsWith "somethingICareAbout"
10:29:37 <Taggnostr> what's a good way to count the digit of a big number (>100k digits) without converting it in string?
10:29:55 <copumpkin> take the log base 10 of it
10:29:55 <skorpan> petermarks: sure, but the addition of the function would be way more useful if it wasn't merely an alias...
10:30:26 <petermarks> I can see both sides of the argument
10:30:56 <skorpan> personally i still think that it would be more intuitive if you wrote iCare = (`startsWith` "something")
10:31:02 <skorpan> but i guess it's a matter of taste
10:31:30 <roconnor> how about iCare = startsWith "something"
10:31:48 <skorpan> that's what peter wrote
10:31:56 <roconnor> ah
10:31:57 <roconnor> sorry
10:32:00 <skorpan> :)
10:32:12 <roconnor> I really should minimize this window
10:32:15 <Taggnostr> copumpkin, let me try
10:32:44 <copumpkin> Taggnostr: get the bit length and multiply it by log_2 10
10:33:08 <Taggnostr> how? I'm new to haskell
10:33:12 <petermarks> if you are prepared to use a section you can already do iCare = ("something" `isPrefixOf`), so what would the new function add?
10:35:40 <petermarks> personally, I wouldn't bother with either. follow this track and you and up with perl, or at the very least Ruby
10:36:25 <byorgey> skorpan: presumably CosmicRay defined  startsWith = isPrefixOf because *he* found *isPrefixOf* to be backwards.
10:36:42 <skorpan> byorgey: i don't know
10:36:42 <byorgey> i.e. if you want to use it partially applied isPrefixOf makes no sense:
10:36:47 <byorgey> let myTest = isPrefixOf "foo"
10:36:50 <skorpan> i can't be bothered discussing it any further
10:37:01 <byorgey> but myTest = startswith "foo" now makes sense
10:37:06 <byorgey> hehe
10:37:40 <Taggnostr> ok, I found logBase
10:40:16 <sm> why does cabal install hledger --constraint "base >= 4" tell me "base-4.x was excluded because of the top level dependency base -any" ?
10:40:45 <dcoutts> sm: it actually means it requires an installed version of base
10:40:53 <dcoutts> but it doesn't say so
10:41:11 <dcoutts> sm: and you must be using ghc-6.8 which has base 3 installed, not 4
10:41:13 <sm> dcoutts: thanks, hmm
10:41:48 <jrick> sm: yeah, I had the same problem yesterday while trying to install yi
10:41:50 <sm> yes, I have a ghc 6.8 user and a base 4 dependency I overlooked
10:42:09 <jrick> using ghc 6.8 from freebsd ports
10:42:49 <Plouj> what gives:
10:42:50 <Plouj> $ cabal install xmonad
10:42:50 <Plouj> bash: /home/plouj/bin/cabal: No such file or directory
10:43:02 <georgehorse> I haven't tried to use it in a while, how is yi now?
10:43:09 <dcoutts> Plouj: hash -r
10:43:16 <Plouj> why would it try to execute that if I have /usr/bin/cabal
10:43:18 <sm> so wondering how 6.8 users can install without me needing to do another hackage release.. would cabal install base --constraint "base >= 4" work for them ?
10:43:45 <dcoutts> Plouj: because shells keep a cache
10:44:06 <Plouj> weird
10:44:13 <dcoutts> sm: no, base cannot be upgraded independently of ghc
10:44:15 <Plouj> never had to do that before, but that fixed it
10:44:24 <Zao> dcoutts: Some shells, that is.
10:44:31 <Zao> rehash is your friend if you have one of those.
10:44:39 <Taggnostr> why (ceiling (logBase 10 99)) works but 99 / (ceiling (logBase 10 99)) doesn't?
10:44:57 <Zao> Because / wants fractionals?
10:45:08 <sm> aha
10:45:17 <Taggnostr> I guess I have to use `div` then
10:45:19 <Taggnostr> let me try
10:45:25 <Zao> @type (/)
10:45:27 <lambdabot> forall a. (Fractional a) => a -> a -> a
10:45:41 <Taggnostr> nope, div is integer division, right?
10:45:43 <sm> so my 0.6 hackage release is just never going to work with 6.8, I'll need another
10:45:50 <dcoutts> sm: correct
10:46:06 <petermarks> any ideas why a hackage search for missingh doesn't list the missingh package? it is certainly on hackage, but It seems to be missing ;-)
10:46:28 <Taggnostr> > (ceiling (logBase 10 99))
10:46:29 <lambdabot>   2
10:46:35 <Taggnostr> > 99 / (ceiling (logBase 10 99))
10:46:37 <lambdabot>   Add a type signature
10:46:40 <Taggnostr> > 99 / 2
10:46:42 <lambdabot>   49.5
10:46:58 <jrick> > 99.0 / (ceiling (logBase 10 99))
10:47:00 <lambdabot>   Add a type signature
10:47:02 <petermarks> > 99 / (ceiling (logBase 10 99)) :: Double
10:47:04 <lambdabot>   No instance for (GHC.Real.Integral GHC.Types.Double)
10:47:04 <lambdabot>    arising from a use ...
10:47:08 <dcoutts> petermarks: what search?
10:47:19 <dcoutts> petermarks: it's on the packages list page
10:47:32 <jrick> @type (ceiling (logBase 10 99))
10:47:34 <lambdabot> forall b. (Integral b) => b
10:47:36 <petermarks> dcoutts: google missingh site:hackage.haskell.org/package
10:47:52 <dcoutts> petermarks: ahh google eh, who knows. :-)
10:48:06 <dcoutts> the google search is a hack
10:48:14 <dcoutts> it's necessarily out of date
10:48:16 <Taggnostr> > 99/ 10^((ceiling (logBase 10 99))-1)
10:48:18 <lambdabot>   9.9
10:48:19 <petermarks> that is the search from http://hackage.haskell.org/packages/archive/pkg-list.html
10:48:22 <Taggnostr> this works
10:49:20 <Athas> Anyone got a better setup for Literate Haskell in Emacs than what's on http://www.haskell.org/haskellwiki/Literate_programming ?
10:49:32 <petermarks> out of date? missingh has been on hackage since 2007
10:49:59 <dcoutts> petermarks: oh I don't mean that in this case it's out of date, I've no idea why google is missing missingh
10:50:23 <dcoutts> petermarks: but in general it's going to be out of date, for newly uploaded packages
10:51:03 <Taggnostr> how can I round a number to 3 decimal digits?
10:51:25 <SamB> Taggnostr: well, it helps if it's not represented in binary ;-)
10:51:44 <SamB> at least, not binary floating-point or fixed-precision
10:51:52 <petermarks> not sure how useful a code repository is if you can't search for code in it :-)
10:52:26 <SamB> dcoutts: is there a bug report for that?
10:52:30 <Zao> @type Text.Printf.printf "%.3f"
10:52:32 <lambdabot> forall r. (PrintfType r) => r
10:52:40 <Zao> > Text.Printf.printf "%.3f" 42.345678
10:52:41 <lambdabot>   Add a type signature
10:52:47 <dcoutts> SamB: you mean for replacing the google search with something better?
10:52:53 <Zao> > Text.Printf.printf "%.3f" 42.345678 :: String
10:52:54 <lambdabot>   "42.346"
10:53:02 <SamB> dcoutts: oh, is that what the problem is ;-)
10:53:08 <SamB> dcoutts: yeah, I guess that's what I mean
10:53:17 <dcoutts> SamB: or do you mean for "fixing" the google search results, which is probably impossible.
10:53:30 <SamB> don't you think I know that?
10:53:31 <dcoutts> SamB: the plan, if someone works on it, is to use hoogle
11:01:55 <petermarks> does hackage have a sitemap.xml?
11:02:59 <dcoutts> petermarks: no, what is one of those exactly?
11:03:20 <petermarks> it tells search engines what pages it should index
11:03:33 <petermarks> let me find the docs...
11:04:24 <petermarks> http://www.sitemaps.org/ is a good start
11:04:59 <petermarks> you can generate the sitemap duynamically and register it with google
11:05:21 <petermarks> this gives no guarantees, but tends to help a lot on a dynamic site
11:10:40 <[gbacon]> where can I find docs or examples of building .hsc sources with Cabal?
11:11:04 <dcoutts> [gbacon]: the zlib package uses .hsc
11:11:09 <dcoutts> and it's fairly small
11:11:17 <[gbacon]> dcoutts: thanks!
11:11:28 <dcoutts> [gbacon]: basically it's easy, just use .hsc instead of .hs, Cabal works it out
11:11:52 <[gbacon]> dcoutts: I tried Main-Is: Main.hsc, but cabal rejected it
11:12:05 <dcoutts> [gbacon]: use Main.hs
11:12:09 * Taggnostr fights with types
11:12:22 <dcoutts> [gbacon]: it'll go looking for Main.hsc if Main.hs does not exist
11:21:26 <Berengal> After weeks of java enterprise development, I long for some haskell...
11:22:00 <Zao> Berengal: I hear verbosity is fun.
11:22:28 <Berengal> Not as fun as lack of HOF
11:23:53 <monochrom> But oh God it (java) is so existential type and polymorphic variant!
11:24:19 <monochrom> Actually s/polymorphic/open/
11:25:38 <[gbacon]> dcoutts: I thought I had already tried that.. thanks for your help!
11:25:51 <dcoutts> [gbacon]: got it working then?
11:26:15 <[gbacon]> dcoutts: yes!
11:26:24 <dcoutts> great
11:27:19 <dschoepe> Whats the best way in ghci to deal with multiple packages providing the same module?
11:28:31 <Berengal> :set -hide-package foo
11:29:11 <Berengal> I usually just do that at the ghc-pkg level though...
11:29:16 <Taggnostr> I tried to do http://codepad.org/AqHblt3r but there's some problem with types that I can't figure out, apparently 'l' becomes a float and that creates confusion
11:30:40 <monochrom> @type logBase
11:30:42 <lambdabot> forall a. (Floating a) => a -> a -> a
11:30:42 <hackagebot> hledger 0.6.1 - A command-line (or curses or web-based) double-entry accounting tool. (SimonMichael)
11:30:44 <monochrom> @type ^
11:30:47 <lambdabot> parse error on input `^'
11:30:51 <monochrom> @type (^)
11:30:55 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
11:31:43 <hackagebot> curry-frontend 0.1 - A compiler for the functional logic language Curry to several intermediate language formats. (HolgerSiegel)
11:32:10 <Taggnostr> also the problem seems related to 'n' being an Integer, from ghci with Int works, with Integer it doesn't
11:32:52 <Berengal> Taggnostr: (/) doesn't work for Integral types, use div instead
11:33:03 <monochrom> There is no problem with l. There is a problem with "fact n" being required to be both Integer and (let's say) Double.
11:33:28 <Taggnostr> can I get decimals if I use div?
11:33:29 <monochrom> x / 10^(l-1)  is just fine.
11:33:49 <monochrom> expform (fact n) wants fact n to be Double.
11:34:02 <Berengal> You're right...
11:34:11 <Berengal> @type product
11:34:13 <lambdabot> forall a. (Num a) => [a] -> a
11:34:19 <monochrom> fact (n :: Integer) wants to be an Integer because of product [1..n] inheriting n's type.
11:34:40 <monochrom> All type errors are due to self-contradictions.
11:34:52 <monochrom> (OK that's a tautology, but few people actually use it!)
11:34:52 <Berengal> > let fact n = product [1..n] in fact 5 / 10
11:34:54 <lambdabot>   12.0
11:35:08 <Taggnostr> uhm
11:35:22 <monochrom> "let fact n = product [1..n] in fact 5 / 10" infers it's Double all the way down.
11:35:38 <monochrom> > let fact n = product [1..n] in fact (5 :: Integer) / 10
11:35:41 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Integer.Internals.Integer)
11:35:41 <lambdabot>    aris...
11:35:55 <monochrom> That is the situation we are facing.
11:35:59 <Berengal> So the answer is 'let n = fromIntegral . (read (head args) :: Integer)
11:36:19 <Berengal> In main
11:36:19 <Taggnostr> ok, so is / the problem?
11:36:42 <monochrom> I think product[1..n] is more efficient and accurate if you do it in Integers.
11:37:01 <monochrom> expfrom . fromIntegral . fact  is the solution.
11:37:22 <Taggnostr> @type fromIntegral
11:37:24 <lambdabot> forall a b. (Integral a, Num b) => a -> b
11:37:32 <Berengal> Both work anyway :)
11:37:33 <monochrom> @quote fromIntegral
11:37:34 <lambdabot> lilac says: <drdozer> gha! I'm drowning in the haskell number hierarchy again <lilac> drdozer: magic 8-ball says 'add calls to fromIntegral'
11:37:51 <monochrom> Um, where is *mine*?!
11:38:01 <Berengal> @quote monochrom fromIntegral
11:38:02 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
11:38:06 <Taggnostr> it compiles now
11:38:16 <monochrom> haha
11:38:50 <Taggnostr> I'll finish my dinner before it gets too cold and I'll come back to understand what happened
11:39:21 <Berengal> Taggnostr: Do some manual type inference in main, that should tell you what went wrong
11:39:30 <monochrom> [OO speak] fromIntegral is the adaptor pattern that plugs one number type to another.
11:39:51 <Berengal> fromIntegral is MAGIC!
11:40:28 <Berengal> Ah, how I've missed the haskell edit-compile-test cycle...
11:46:43 <Taggnostr> apparently the program doesn't work
11:47:02 <monochrom> Good.
11:49:14 <Taggnostr> and apparently haskell is more interesting than the dinner
11:50:00 <monochrom> you can eat haskell and write dinner at the same time
11:50:10 <monochrom> err eat dinner and write haskell
11:50:29 <Vulpyne> Haskell is good and good for you.
11:50:47 <lowlycoder> is there a terminal emulator, like urxvt/xterm, written in haskell? perferably with unicode support
11:51:36 <gwern> nope. not even close.
11:51:59 <gwern> (and given the amount of effort a terminal emulator is, I hope no one bothers)
11:52:12 <lowlycoder> explain
11:52:13 <lowlycoder> enlighten me
11:52:25 <Gracenotes> hm. I never really got the idea behind Traversable (@yitz). Perhaps I should look at the typeclassopedia again
11:52:25 <lambdabot> Gracenotes: You have 1 new message. '/msg lambdabot @messages' to read it.
11:52:30 <Gracenotes> @messages
11:52:30 <lambdabot> yitz said 1h 23m 32s ago: The answer is: define instance traversable ((,) a), then you have traverse :: Applicative f => (b -> f c) -> (a, b) -> f (a, c).
11:52:40 <Vulpyne> It's fairly complicated to get working, and there's not really an advantage to having it in Haskell.
11:52:43 <Gracenotes> oh, here's not here
11:52:46 <Gracenotes> he
11:53:01 <Vulpyne> It's also not the sort of project people are likely to get too excited about. :)
11:53:20 <trofi> one more terminfo/termcap entry!
11:53:37 <monochrom> There are conflicting standards and compatibility expectations over terminal emulators. Same story with html renderer.
11:54:14 <SamB> monochrom: hmm. at least HTML has DOCTYPES
11:54:36 <SamB> not sure how much that helps, though
11:54:54 <Gracenotes> so I'd imagine Traversable visits every "node" in an object once, at least all nodes with the outermost type
11:55:25 <Gracenotes> or does it just invert specific monads
11:56:10 <monochrom> doctype doesn't help. the devil is in drawing things, i.e., Firefox fans and IE fans expect to see different drawings with the same html code and the same css code.
11:56:48 <gwern> lowlycoder: and a good terminal emulator would require so much haskell effort; effort better spent on other things. unless one has some elegant theoretical model to use, like xmonad did, cloning well-done and old apps is of little profit
11:57:00 <monochrom> There are lots of undocumented extensions to html and css that IE users expect you to know.
11:57:31 <trofi> there is not so much IEs as terminal emulators
11:57:58 <HugoDaniel> hello
11:58:08 <monochrom> Everyone defines "vt100" slightly differently.
11:58:50 <gwern> hm. that's interesting. haddock seems to mangle utf characters
11:59:03 <erikc> reminds me of the total pita it was to get screen working on aixterm
11:59:13 <gwern> µ gets turned into
12:01:10 <monochrom> Old-enough versions of haddock will mangle non-ascii characters because they're using basic System.IO routines.
12:01:54 <gwern> yeah. I thought I had darcs haddock, but darcs haddock uses io.utf8, so it shouldn't've been a problem
12:11:34 <Taggnostr> > ceiling (logBase 10 (product [1..500])) == ceiling (logBase 10 (product [1..50000]))
12:11:35 <lambdabot>   True
12:11:48 <Taggnostr> why is this True?
12:12:10 <jmcarthur_work> > logBase 10 (product [1..500]
12:12:11 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
12:12:17 <jmcarthur_work> > logBase 10 (product [1..500])
12:12:19 <lambdabot>   Infinity
12:12:31 <jmcarthur_work> > ceiling (logBase 10 (product [1..500]))
12:12:33 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
12:12:47 <Taggnostr> > ceiling Infinity
12:12:49 <lambdabot>   Not in scope: data constructor `Infinity'
12:12:58 <monochrom> This is why I said Integer is more accurate (than Double).
12:13:01 <jmcarthur_work> > ceiling (1/0)
12:13:02 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
12:13:18 <jmcarthur_work> > ceiling (1/0) == ceiling (2/0)
12:13:19 <lambdabot>   True
12:13:28 <jmcarthur_work> > (1/0) == (2/0)
12:13:30 <lambdabot>   True
12:13:41 <monochrom> Why are programmers so innumerate.
12:14:04 <jmcarthur_work> :(
12:14:13 <Taggnostr> > 1/0
12:14:15 <lambdabot>   Infinity
12:14:38 <jmcarthur_work> :t logBase
12:14:39 <lambdabot> forall a. (Floating a) => a -> a -> a
12:14:40 <Taggnostr> why ceiling doesn't return Infinity?
12:14:49 <jmcarthur_work> :t ceiling
12:14:50 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
12:15:09 <copumpkin> not many integral types that contain infinity
12:15:10 <jmcarthur_work> maybe it could if the Integral type could
12:15:22 <jmcarthur_work> > 1 `div` 0
12:15:24 <lambdabot>   * Exception: divide by zero
12:15:30 <ClaudiusMaximus> > let sortalog10ish = length . show in sortalog10ish $ product [1..500] == sortalog10ish $ product [1..50000]
12:15:32 <lambdabot>   Couldn't match expected type `a -> b'
12:15:51 <ClaudiusMaximus> > let sortalog10ish = length . show in (sortalog10ish $ product [1..500]) == (sortalog10ish $ product [1..50000])
12:15:54 <jmcarthur_work> > logBase 10 (product [1..500] :: CReal)
12:15:56 <lambdabot>   mueval-core: Prelude.read: no parse
12:15:56 <lambdabot>  mueval: ExitFailure 1
12:16:00 <lambdabot>   mueval-core: Prelude.read: no parse
12:16:00 <lambdabot>  mueval: ExitFailure 1
12:16:25 <monochrom> There is no "infinity" in the Integer type.
12:16:53 <Taggnostr> uhm
12:17:11 <jmcarthur_work> product [1..500] :: Integer
12:17:17 <monochrom> I mean this. ceiling has to return something like an Integer. What do you want ceiling (1/0) :: Integer to be?
12:17:21 <jmcarthur_work> > product [1..500] :: Integer
12:17:22 <lambdabot>   122013682599111006870123878542304692625357434280319284219241358838584537315...
12:17:27 <jmcarthur_work> > product [1..50000] :: Integer
12:17:32 <lambdabot>   mueval-core: Prelude.read: no parse
12:17:33 <lambdabot>  mueval: ExitFailure 1
12:17:35 <jmcarthur_work> meh
12:17:40 <monochrom> Of course the current answer is wrong. My opinion is it should be an exception.
12:17:45 <Taggnostr> monochrom, it should raise an error imho
12:17:46 <jmcarthur_work> agreed
12:17:50 <jmcarthur_work> well
12:17:58 <jmcarthur_work> _|_ or something
12:18:06 <jmcarthur_work> i don't think pure code should raise real exceptions
12:18:11 <monochrom> In any case why the hell are you computing large factorials in Double.
12:18:19 <Taggnostr> I'm not!
12:18:35 <jmcarthur_work> :t logBase
12:18:37 <lambdabot> forall a. (Floating a) => a -> a -> a
12:18:39 <Taggnostr> or if I'm doing it I'm not aware of it
12:18:41 <jmcarthur_work> yes you are ;)
12:19:03 <monochrom> I agree you are not aware. Pay closer attention to types. Type-driven programming.
12:19:48 <Taggnostr> ok, so the problem is logBase, should I replace logBase with some cooler logBase that handles other types?
12:19:59 <jmcarthur_work> the logBase function is forcing the type to be an instance of the Floating type class, and defaulting makes it a Double
12:20:32 <jmcarthur_work> Taggnostr, like ClaudiusMaximus did, you could do (length . show) if you just want the length of the number
12:20:39 <jmcarthur_work> as a quick hack, anyway
12:20:43 <Taggnostr> in other words logBase doesn't work if the number can't fit in the Double type, right?
12:20:52 <monochrom> > 5 :: CReal
12:20:54 <lambdabot>   5.0
12:20:57 <monochrom> This may work.
12:21:02 <jmcarthur_work> Taggnostr, logBase won't work if it's not an instance of Floating
12:21:16 <jmcarthur_work> CReal would work, but maybe take a while
12:21:21 <monochrom> > logBase 10 (fromIntegral (product [1..500]) :: CReal)
12:21:23 <lambdabot>   1134.086408535134555059255931621031608846159
12:21:32 <monochrom> > logBase 10 (fromIntegral (product [1..50000]) :: CReal)
12:21:37 <lambdabot>   mueval-core: Prelude.read: no parse
12:21:37 <lambdabot>  mueval: ExitFailure 1
12:21:45 <monochrom> > logBase 10 (fromIntegral (product [1..5000]) :: CReal)
12:21:48 <jmcarthur_work> :t product
12:21:48 <lambdabot>   16325.6261943384233080060453170155486841484084
12:21:49 <lambdabot> forall a. (Num a) => [a] -> a
12:21:50 <Taggnostr> jmcarthur_work, that's what I was doing before, but it turned out that converting to string is more time consuming than calculating the factorial in the first place, so I was trying an alternative approach
12:21:52 <copumpkin> > logBase 10 (product [1..50000])
12:21:53 <lambdabot>   Infinity
12:21:56 <monochrom> Not too bad.
12:22:03 <copumpkin> onoes, it's infinity!
12:22:18 <jmcarthur_work> Taggnostr, monochrom has it right
12:22:29 <jmcarthur_work> if you want to use logBase, anyway
12:22:41 <monochrom> But you have to download CReal yourself. Doesn't come with GHC.
12:22:57 <Taggnostr> uhm
12:23:38 <Taggnostr> someone earlier mentioned bitlength, could that work?
12:23:45 <monochrom> Yes.
12:23:45 <copumpkin> > fromIntegral (bitSize (product [1..50000])) * (logBase 2 10)
12:23:47 <lambdabot>   Add a type signature
12:24:09 <monochrom> It's silly to take log of a large number just for counting digits anyway.
12:24:33 <dschoepe> .. and produces rounding errors
12:24:36 <Taggnostr> I'm assuming that it's faster than converting the number to string
12:24:47 <dschoepe> > logBase 10 1000
12:24:49 <copumpkin> converting it to a string is slow
12:24:49 <lambdabot>   2.9999999999999996
12:24:57 <jmcarthur_work> > exp $ pi * sqrt (-1) :: Complex CReal
12:24:59 <lambdabot>   (-1.0) :+ 0.0
12:25:06 <jmcarthur_work> > exp $ pi * sqrt (-1) :: Complex Double
12:25:08 <lambdabot>   (-1.0) :+ 1.2246467991473532e-16
12:25:13 <Cale> http://www.youtube.com/watch?v=6JPcimrnXGA# -- haha
12:25:28 <Cale> (completely offtopic though ;)
12:25:35 <copumpkin> no bitSize for Integer?
12:25:35 <monochrom> You have the wrong brainwashed idea of speeds of arithmetic operations, thinking that every operation is "O(1)".
12:25:40 <copumpkin> > bitSize (1 :: Integer)
12:25:41 <lambdabot>   * Exception: Data.Bits.bitSize(Integer)
12:26:01 <copumpkin> well, you can steal it by looking inside the Integer type, but that'd be bad
12:26:09 <monochrom> I mean, look, don't tell me that adding two 10-digit numbers has the same speed as adding two 1000-digit numbers.
12:26:26 <monochrom> And don't think that log is O(1) for a 1000-digit number either.
12:27:12 <monochrom> Programmers are beyond innumeracy. They are in this O(1) fantasy.
12:27:52 <jmcarthur_work> monochrom, sounds a bit harsh. many programmers never use numbers so large
12:28:28 <Cale> monochrom: hmm... if all was right with the world, I would expect that the complexity of computing a logarithm to base b should be equivalent in complexity to counting the digits in base b, though probably nothing in the library currently prevents it from doing a little more work than that.
12:28:43 <monochrom> I agree with you. I am just a bit harsh if I just say that. Wait until you hear me saying that programmers are illiterate too. :)
12:28:44 <Taggnostr> monochrom, I'm not assuming that it's O(1), just that it's faster, and I'm not sure that it really is, so I'm trying to verify it
12:29:20 <copumpkin> Taggnostr: why are you trying to get scientific notation for integers in the first place?
12:29:21 <Cale> Of course, if you already have the base b representation, it's cheaper just to count them.
12:29:52 <Taggnostr> copumpkin, because big numbers don't fit in the Double type?
12:30:03 <copumpkin> Taggnostr: huh?
12:30:11 <Taggnostr> do they?
12:30:19 <Cale> It makes sense as something to want to do.
12:30:22 <jmcarthur_work> Taggnostr, i think he means why do you need to get the length of the number
12:31:11 <Cale> Heh, write a physics simulation which uses Integer to store lengths as multiples of the Planck length :)
12:31:31 <Taggnostr> jmcarthur, to know the exponent of 10 that I have to use in the esponential notation
12:31:32 <jmcarthur_work> oh gosh...
12:32:07 <jmcarthur_work> Taggnostr, okay, so you are writing them out in scientific notation then. "why?" is the question copumpkin asked
12:32:07 <copumpkin> Taggnostr: but you're discarding significant digits that way?
12:32:45 <Taggnostr> jmcarthur, because the number is to big to print it all out
12:33:50 <Taggnostr> I want something similar to http://www10.wolframalpha.com/input/?i=249999!
12:33:54 <monochrom> > showEFloat (Just 10) (60 :: CReal) ""
12:33:56 <lambdabot>   "* Exception: CCeal.floatRadix
12:34:07 <Cale> > let digits b = length . takeWhile (/= 0) . iterate (`div` b) in digits 10 (product [1..1000])
12:34:08 <lambdabot>   2568
12:34:12 <Cale> > let digits b = length . takeWhile (/= 0) . iterate (`div` b) in digits 10 (product [1..10000])
12:34:14 <lambdabot>   35660
12:34:16 <monochrom> My question is why does it say "CCeal" rather than "CReal"? :)
12:34:21 <copumpkin> what is the point of knowing the first dozen significant digits of a number that big anyway?
12:34:32 <Cale> monochrom: lol
12:34:49 <monochrom> I think someone should change it to "Cereal"!
12:34:51 <copumpkin> weird :)
12:35:13 <Apocalisp> all hail Ceres!
12:35:45 <Cale> Taggnostr: ah, okay, to get the precise exponent like that, you definitely would want a proper arbitrary precision logarithm.
12:36:22 <Taggnostr> copumpkin, actually I want only the first digit with 3 decimals, it probably doesn't matter, but saying just "some number with n digits" doesn't look that good :P
12:36:36 <copumpkin> heh
12:37:31 <Cale> And... to compute 249999!, you probably want a better implementation of the factorial than just multiplying the numbers together one by one
12:37:45 <copumpkin> is there such a thing, that isn't an approximation?
12:37:56 <jmcarthur_work> > fromIntegral $ product [1..249999] :: CReal
12:38:01 <lambdabot>   mueval-core: Prelude.read: no parse
12:38:01 <lambdabot>  mueval: ExitFailure 1
12:38:03 <Cale> Yeah, it helps to keep the sizes of the numbers you're multiplying roughly balanced
12:38:25 <copumpkin> Cale: ah, I see
12:38:51 <SamB> Cale: so you at *least* want a binary-tree like structure for the multiplications?
12:38:51 <Cale> > logBase 10 (logBase 10 (fromIntegral (product [1..2499] :: Integer) :: CReal))
12:38:52 <lambdabot>   3.8696900664214301329041490455143685885069
12:39:15 <Cale> Well, it's already a binary tree, it's just a lop-sided one ;)
12:39:58 <Cale> But yeah, you want it to be more balanced than that, though it's not really the tree itself which is balanced, but the number of bits in the factors
12:39:58 <Taggnostr> Cale, time ghc -e 'let x = product [1..250000]' takes 1.194s
12:40:31 <Taggnostr> but than it takes minutes to convert it to esponential notation
12:40:31 <Cale> Taggnostr: that's because it doesn't compute anything
12:40:42 <Taggnostr> uhm
12:40:45 <Taggnostr> indeed
12:40:50 <monochrom> hahahahaha
12:41:32 <Taggnostr> how can I make it compute the result then?
12:41:47 <Cale> time ghc -e 'let x = product [1..250000] in x'
12:41:48 <Cale> or if you don't want to print it
12:41:52 <Cale> time ghc -e 'let x = product [1..250000] in x `seq` ()'
12:41:56 <Apocalisp> Taggnostr: What are you doing with numbers that big?
12:42:18 <Taggnostr> Apocalisp, searching for the limits of haskell
12:42:20 <copumpkin> it seems strange to want numbers that big but to want to discard the less significant digits
12:42:33 <jmcarthur_work> Taggnostr, you are searching for the limits of GMP ;)
12:42:44 <copumpkin> they're well advertised
12:43:01 <Apocalisp> normally you'd represent numbers that big with power towers or something like that
12:43:05 <jmcarthur_work> i think it's like (maxBound :: Int)^(maxBound :: Int) or something
12:43:07 <Taggnostr> 250k is the limit of wolfram
12:43:09 <copumpkin> "Support at the mpn and mpz levels for operands of up to 250 bits (on 64-bit machines). Current limits are: on 32-bit machines, 231 bits; on 64-bit machines, 237 bits."
12:43:33 <copumpkin> that's 2^50
12:43:38 <Cale> Taggnostr: Eh?
12:43:38 <copumpkin> 2^31 etc.
12:43:44 <Cale> Oh, the search engine thingy.
12:43:51 <copumpkin> I'd imagine mathematica uses gmp behind the scenes too
12:43:53 <Taggnostr> yep
12:43:54 <Cale> Mathematica can do much larger :)
12:44:07 <Taggnostr> Cale: http://www10.wolframalpha.com/input/?i=249999!
12:44:45 <Cale> I suspect they picked it so that it would take less than a particular amount of time on their servers.
12:44:57 <monochrom> Wolfram Alpha is not Mathematica.
12:45:13 <jmcarthur_work> perhaps they precalculated a bunch of factorials
12:45:13 <copumpkin> I thought it was built on top of it, or that's what the hype said
12:45:43 <monochrom> Even lambdabot is smart enough to not expose all of GHC to you.
12:46:15 <copumpkin> is your point that wolfram alpha isn't using gmp?
12:46:38 <monochrom> OK, tell me why lambdabot does not do everything GHC does. The reason is pretty obvious.
12:46:45 <roconnor> Does a monad have to be a strong monad for it to be an applicative functor?
12:47:00 <jmcarthur_work> "strong"?
12:47:09 * copumpkin is confused
12:47:14 <Cale> roconnor: Can you write 'ap' without using the monad strength?
12:47:24 <roconnor> Cale: I can't
12:47:29 <roconnor> but I'm dumb
12:47:34 <monochrom> If you give lambdabot a program that takes 10 years to complete running, should lambdabot do it?
12:47:45 <copumpkin> it has a time limit, so does wolfram alpha
12:47:57 <monochrom> That is why Wolfram Alpha is not Mathematica.
12:48:05 <copumpkin> oh, that's profound
12:48:14 <lament> ten BILLION years
12:48:24 <monochrom> No, it is not profound, and I did not say or imply it is profound.
12:48:28 <copumpkin> all I was saying is that it probably used gmp
12:48:32 <copumpkin> if you want to nitpick, go ahead
12:48:35 <Cale> copumpkin: It does.
12:48:39 <roconnor> @src ap
12:48:40 <lambdabot> ap = liftM2 id
12:48:44 <jmcarthur_work> > repeat '9' ++ " years"
12:48:44 <lambdabot>   "99999999999999999999999999999999999999999999999999999999999999999999999999...
12:48:52 <copumpkin> that's over 9000 years!
12:49:11 <monochrom> No, my "Wolfram Alpha is not Mathematica" was not directed at "it uses gmp". I do not know why you argued against it.
12:49:15 <roconnor> copumpkin: due to the leading high bit, the number is actually negative
12:49:16 <burp> > show (1/0) ++ "years"
12:49:17 <lambdabot>   "Infinityyears"
12:49:29 <lament> Infinity ears!
12:49:34 <copumpkin> monochrom: oh, then I'm sorry for reacting that way :)
12:49:39 <roconnor> > show infinity ++ " years"
12:49:41 <lambdabot>   "* Exception: stack overflow
12:49:49 <jmcarthur_work> :t infinity
12:49:51 <lambdabot> Natural
12:49:56 <jmcarthur_work> natural!
12:50:03 <jmcarthur_work> @hoogle infinity
12:50:03 <lambdabot> package infinity
12:50:08 <roconnor> > 3 < infinity
12:50:09 <lambdabot>   True
12:50:20 <jmcarthur_work> @hackage infinity
12:50:20 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/infinity
12:50:23 <Cale> It's not that
12:50:35 <Vulpyne> > infinity - infinity
12:50:37 <monochrom> My "Wolfram Alpha is not Mathematica" was directed at "Wolfram Alpha doesn't do 300000! therefore Mathematica is similarly limited".
12:50:40 <lambdabot>   mueval-core: Prelude.read: no parse
12:50:40 <lambdabot>  mueval: ExitFailure 1
12:50:41 <Cale> I believe it's from the numbers package...
12:50:58 <lament> > infinity + 1
12:51:01 <lambdabot>   * Exception: stack overflow
12:51:08 <jrick> > infinity / infinity
12:51:10 <lambdabot>   No instance for (GHC.Real.Fractional Data.Number.Natural.Natural)
12:51:10 <lambdabot>    arisin...
12:51:17 <lament> nice - a new exception each time
12:51:17 * jmcarthur_work just realized that hackage has both a Numbers and a numbers package...
12:51:18 <gwern> :t infinity
12:51:20 <lambdabot> Natural
12:51:25 <Cale> monochrom: Which itself was just a bit of confusion on my part over what was meant by "Wolfram"
12:51:51 <copumpkin> jmcarthur_work: they're not the same thing?
12:51:59 <jmcarthur_work> nope
12:52:02 <copumpkin> ack
12:52:14 <roconnor> down with Numbers, long live numbers.
12:52:32 <Gracenotes> syn-ack
12:52:34 <jrick> > (1/0) / (1/0)
12:52:37 <lambdabot>   NaN
12:52:50 <jmcarthur_work> > genericLength [0..10] < (genericLength [1..] :: Natural)
12:52:52 <lambdabot>   True
12:52:54 <jmcarthur_work> nice
12:52:56 <Gracenotes> (reverse TCP!)
12:53:30 <tibbe> @seen bos
12:53:30 <lambdabot> I saw bos leaving #haskell, #haskell-in-depth and #ghc 1d 4h 31m 28s ago, and .
12:54:04 <Cale> @pl \f' -> join (fmap (return . f') x)
12:54:04 <lambdabot> join . flip fmap x . (return .)
12:54:14 <Cale> hmm
12:54:37 * Cale tries to imagine what that means in terms of the category...
12:54:58 <Gracenotes> uh... our good friend fmap? :)
12:55:18 <Gracenotes> liftM to be precise
12:55:26 <Gracenotes> (but no more accurate)
12:55:40 <Cale> :t \f x -> join (fmap (join . flip fmap x . (return .)) f)
12:55:41 <lambdabot> forall a b (m :: * -> *). (Monad m, Functor m) => m (a -> b) -> m a -> m b
12:55:48 <Gracenotes> lol
12:56:06 <[gbacon]> @pl \x a b -> x /= a && x /= b
12:56:06 <lambdabot> ap (flip . (((.) . (&&)) .) . (/=)) (/=)
12:56:23 <[gbacon]> @pl \a b -> x /= a && x /= b
12:56:24 <lambdabot> (. (x /=)) . (&&) . (x /=)
12:56:53 <Cale> @pl \f x -> join (fmap (join . flip fmap x . (return .)) f)
12:56:53 <lambdabot> (join .) . flip (fmap . (join .) . (. (return .)) . flip fmap)
12:56:57 <Cale> heh
12:57:28 <Gracenotes> [gbacon]: or, (&&) `on` (x/=)
12:57:29 <Cale> completely points-free implementation of ap in terms of join, fmap and return
12:57:56 <Berengal> And flip and (.)
12:58:02 <Cale> indeed
12:58:04 <yitz> hi Gracenotes
12:58:06 <jmcarthur_work> :t \a b -> x /= a && x /= b
12:58:06 <Gracenotes> and ( and )
12:58:06 <Cale> :t (. (return .))
12:58:07 <lambdabot> Expr -> Expr -> Bool
12:58:07 <lambdabot> forall c b (m :: * -> *) a. (Monad m) => ((a -> m b) -> c) -> (a -> b) -> c
12:58:12 <Gracenotes> elo yitz
12:58:21 <Cale> That is curious :)
12:58:28 <Cale> I like it
12:58:31 * Berengal sometimes gives pointless the name flipdot in his mind
12:58:33 <yitz> Gracenotes: I figured out what was bothering me before.
12:58:43 <Gracenotes> @type on (&&) . (/=) -- [gbacon] : pointfree
12:58:43 <roconnor> Berengal, Cale: and id?
12:58:45 <lambdabot> forall a. (Eq a) => a -> a -> a -> Bool
12:58:48 <roconnor> @pl \x -> x
12:58:48 <lambdabot> id
12:59:19 <Cale> :t (join .)
12:59:20 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => (a1 -> m (m a)) -> a1 -> m a
12:59:55 <roconnor> :type ap return return
13:00:01 <Apocalisp> @unpl on (&&) . (/=)
13:00:02 <lambdabot> (\ c -> on (&&) ((/=) c))
13:00:05 <roconnor> :t ap return return
13:00:07 <lambdabot>     Ambiguous type variable `m' in the constraint:
13:00:07 <lambdabot>       `Monad m' arising from a use of `return' at <interactive>:1:10-15
13:00:07 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
13:01:10 <Taggnostr> I think I'll give up with this factorial thing
13:01:27 <roconnor> factorial thing?
13:02:05 <Taggnostr> yes, I was writing a program to calculate the factorial
13:02:44 <roconnor> product [1..n]
13:02:52 <erikc> haskell is really good at that one
13:03:26 <Taggnostr> yes, but I was doing it with n>100k
13:03:43 <roconnor> will the answer fit in the universe?
13:03:44 <mauke> > product [1 .. 1000000]
13:03:45 <lambdabot>   * Exception: stack overflow
13:04:00 <mauke> > foldl' (*) 1 [1 .. 1000000]
13:04:05 <roconnor> > product [1 .. 1000000] > (3::Natural)
13:04:05 <lambdabot>   mueval-core: Prelude.read: no parse
13:04:05 <lambdabot>  mueval: ExitFailure 1
13:04:07 <lambdabot>   * Exception: stack overflow
13:04:15 <mauke> hohoho
13:04:17 <roconnor> > foldr (*) 1 [1 .. 1000000] > (3::Natural)
13:04:19 <lambdabot>   * Exception: stack overflow
13:04:21 <sbahra> mauke, * Exception: stack overflow
13:04:23 <monochrom> You need more memory or time.
13:04:26 <roconnor> oh right
13:04:31 <roconnor> needs to check for 0
13:04:36 <sbahra> roconnor, * Exception: stack overflow
13:04:46 <roconnor> @quote overflow
13:04:46 <lambdabot> ghc says: GHC stack-space overflow
13:05:10 <monochrom> "when you fail, look for a quote"? :)
13:05:31 <roconnor> @quote fail
13:05:31 <lambdabot> Philippa says: < ihope> data Badger = Badger Badger Badger | Mushroom < Philippa> Pattern match failure: Snake!
13:08:43 <jmcarthur_work> [gbacon], generalized "on" http://matt.immute.net/content/pointless-fun :)
13:08:56 <lpsmith> There are much more efficient ways of computing the digits of (10^6)!,  does anybody know off the top of their head what they'd be?
13:09:30 <labo> > (sum $ map log [1..100000]) / log 10
13:09:32 <lambdabot>   456573.4508999695
13:09:39 <labo> log 100000!
13:09:46 <lpsmith> not the number of digits :)
13:09:50 <lpsmith> the actual digits
13:10:22 <lpsmith> Mathematica has the algorithm,  I'm pretty sure, I just don't know what it is.
13:10:27 <petermarks> In STM, is it possible to take a consistent snapshot of the whole "memory" whilst updates are going on? Looking at the description from the SPJ Beautiful Code chapter, it looks like the snapshotting transaction would continually retry and never complete.
13:11:27 <Heffalump> petermarks: how would you even get hold of the whole memory? Are you assuming the existence of some primitive that lets you?
13:11:46 <Cale> petermarks: Well, there's no actual primitive for getting hold of transactional variables that haven't been passed to you, but assuming that you had been passed them...
13:12:05 <lpsmith> http://www.luschny.de/math/factorial/FastFactorialFunctions.htm
13:12:08 <petermarks> no no, I am planning to use a few THash
13:12:11 <Heffalump> other than that, I don't see why it wouldn't work, since if it didn't work then no transaction that touched a superset of the variables touched by another transaction could ever be guaranteed
13:12:23 <Heffalump> and IIRC there is a progress guarantee
13:12:58 <Saizan> progress only guarantees that something happens
13:13:14 <Saizan> it doesn't prevent starvation of a particular transaction
13:13:17 <Saizan> afaik
13:13:18 <Cale> You could write a transaction which would try to read them all. However, if there were a lot of them, that transaction might have trouble competing in a basic optimistic implementation of STM>
13:13:52 <Cale> There's a lot of room to improve the way that STM works without changing its exposed interface.
13:13:56 <petermarks> cale, that is what i was thinking
13:15:10 <Cale> But it's generally considered a bad idea for transactions to be exceptionally large in terms of the time they'll take and things they'll touch without good reason.
13:15:29 <Heffalump> wanting to snapshot sounds like a good reason
13:15:42 <Cale> Yeah.
13:15:45 <Cale> However...
13:15:58 <petermarks> basically, I want to dump a consistent snapshot to disk
13:16:25 <Heffalump> do you have control over the other transactions?
13:16:39 <Heffalump> If so, you could create a "hold on a sec" TVar and use that as a flag to make them wait
13:17:33 <Cale> yeah
13:17:53 <petermarks> heffalump: that might work, but I don't know how long it would take and I can't suspend everything for more that a few seconds
13:18:11 <Heffalump> well, you definitely can't have both!
13:18:27 <jmcarthur_work> yeah you'd have to suspend either way
13:18:28 <Heffalump> at least not without an STM implementation that takes snapshots itself
13:18:32 <Cale> Another option (which may be impossible) is structuring your state so that you have something more like a TVar (Map ...) than a ton of smaller variables.
13:18:59 <jmcarthur_work> of course, that eliminates all the concurrency, pretty much
13:19:13 <jmcarthur_work> a Big Lock, essentially
13:20:06 <jmcarthur_work> i vote for the "hold on a second" TVar
13:20:18 <alpha_q> hey I have a list of values and a function check :: [a] -> Bool . I want to check each value and if there is even a single false return false. Now obviously foldr (&&) True (map check values) works
13:20:23 <petermarks> some databases have a read-only isolation level that basically means all reads get data as it was at the point the transaction started, but can't write anything. other simultanious transactions are free to write whatever they like, but those writes are not seen by the read-only transaction.
13:20:23 <alpha_q> but is there something smarter
13:20:32 <Heffalump> @type all
13:20:33 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
13:20:45 <a_guest> Is there some good guide on net about converting between simple types such as Int, Double, etc. ?
13:20:45 <Heffalump> I think you mean check :: a -> Bool btw
13:20:49 <jmcarthur_work> alpha_q, do you mean check :: a -> Bool?
13:21:01 <alpha_q> er, yes
13:21:03 <alpha_q> sorry
13:21:05 <Cale> a_guest: fromIntegral is what you want 90% of the time
13:21:13 <alpha_q> jmcarthur, that's what I mean
13:21:30 <Cale> a_guest: after that, realToFrac, and then there's round/floor/ceiling
13:21:33 <Heffalump> also, foldr (&&) True = and
13:21:45 <jmcarthur_work> alpha_q, there are certain kinds of situations where you can do something smarter
13:21:51 <Cale> a_guest: fromIntegral converts any integer-like type into any numeric type
13:21:55 <jmcarthur_work> @src all
13:21:56 <lambdabot> all p =  and . map p
13:22:01 <jmcarthur_work> @src and
13:22:01 <lambdabot> and   =  foldr (&&) True
13:22:18 <Cale> a_guest: realToFrac converts between fractional types (assuming that they are not complex)
13:22:19 <jmcarthur_work> huh, those won't terminate early, will they?
13:22:24 <Heffalump> of course they will
13:22:26 <Heffalump> laziness!
13:22:30 <Heffalump> @source (&&)
13:22:30 <lambdabot> (&&) not available
13:22:36 <Heffalump> @src (&&)
13:22:37 <lambdabot> True  && x = x
13:22:37 <lambdabot> False && _ = False
13:22:44 <jmcarthur_work> well, i know && would
13:22:52 <Cale> a_guest: and of course, round, floor and ceiling do what you're probably used to those names meaning :)
13:22:54 <Heffalump> well...
13:22:55 <Cale> :t round
13:22:56 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
13:22:56 <jmcarthur_work> oh, it's a foldr
13:23:00 <jmcarthur_work> i was thinking foldl
13:23:01 <lpsmith> jmcarthur:   yes,  it won't terminate early if you use forall...
13:23:04 <Cale> a_guest: does that help? :)
13:23:06 <lpsmith> err, foldl
13:23:10 <alpha_q> what's that forall you keep talking about? :)
13:23:14 <jmcarthur_work> i misread it is all
13:23:29 <Heffalump> shouldn't be allowed, mistakes on #haskell
13:23:32 <lpsmith> I have higher ranked types on the brian
13:23:35 <Heffalump> after all, the language is perfect!
13:23:50 <alpha_q> Not in scope: `forall'
13:24:07 <Cale> alpha_q: forall appears in types to quantify type variables explicitly
13:24:11 <lpsmith> > and (True : True : True : repeat False)
13:24:13 <lambdabot>   False
13:24:24 <Peaker> does anyone here know Iteratee?  It seems to me like its very similar to a Data.Binary.Get transformer -- and like Binary.Get, should sit in another monad transformer in order to implement error handling (Rather than the very weird stream type).. any ideas?
13:24:30 <lpsmith> > foldl (&&) True (True : True : True : repeat False)
13:24:33 <Cale> alpha_q: if you leave it out, type variables all get forall'd at the top of a type signature
13:24:39 <lambdabot>   mueval-core: Prelude.read: no parse
13:24:39 <lambdabot>  mueval: ExitFailure 1
13:25:03 <Cale> alpha_q: that is,  length :: forall a. [a] -> Integer   is the same type as  length :: [a] -> Integer
13:25:16 <Peaker> also, I think if Iteratee was called Consumer, Enumerator was called Producer, Stream was called StreamInput or StreamItem, or something to indicate that it is *not* a stream, it would make things much clearer for everyone :-)
13:25:17 <Cale> alpha_q: It's just explicitly saying "for all types a ..."
13:25:51 <lpsmith> > last (repeat True)
13:25:57 <lambdabot>   mueval-core: Prelude.read: no parse
13:25:57 <lambdabot>  mueval: ExitFailure 1
13:25:59 <monochrom> Everyone has a different naming fetish.
13:26:01 <jmcarthur_work> Peaker, i am learning iteratee. my understanding is that you are supposed to use the stream type so that the next enumerator gets a chance to handle the error
13:26:02 <mmorrow> @type let forall = undefined in forall
13:26:04 <a_guest> Cale: yes. The numeric typeclasses provides functions to convert to the instances??
13:26:05 <lambdabot> forall a. a
13:26:07 <jmcarthur_work> using a transformer would not allow that, i think
13:26:12 <Cale> a_guest: yeah
13:26:19 <Cale> :t fromIntegral
13:26:21 <lambdabot> forall a b. (Integral a, Num b) => a -> b
13:26:26 <Cale> ^^ this is the most important one
13:26:26 <Peaker> jmcarthur_work: I don't mean getting rid of the Stream type (but renaming it to a less misleading name would be nice!)
13:26:57 <a_guest> Cole: I shall look at the different typeclasses in Hoogle. thank you!
13:27:04 <mnkme> :t 'div'
13:27:05 <lambdabot>     lexical error in string/character literal at character 'i'
13:27:07 <monochrom> But since rich people have more say, they probably get to decide on words such as "consumer".
13:27:10 <mnkme> :t `div`
13:27:11 <lambdabot> parse error on input ``'
13:27:12 <jmcarthur_work> Peaker, i think it's just one of these cases where stream can mean multiple things :(
13:27:16 <lpsmith> :t div
13:27:18 <lambdabot> forall a. (Integral a) => a -> a -> a
13:27:19 <mnkme> :t div
13:27:21 <lambdabot> forall a. (Integral a) => a -> a -> a
13:27:22 <mnkme> thanks :)
13:27:30 <jmcarthur_work> it is "stream processing" after all
13:27:32 <Peaker> jmcarthur_work: But none of the meanings maps well to an input-event which is much closer to what it is
13:27:39 <jmcarthur_work> i agree
13:27:52 <Peaker> jmcarthur_work: What he calls Stream is just a single element in a stream of elements
13:28:10 <mmorrow> Peaker: the key is that the control keeps mutually inverting over and over again over the course of the input
13:28:10 <jmcarthur_work> well, the chunk is an input event, but what the chunk represents is a part of a larger hypothetical stream
13:28:28 <jmcarthur_work> you are supposed to treat it as a stream, even though it's not
13:29:17 <mmorrow> @let mutual f g a = f a (\b -> g b (\a -> mutual f g a))
13:29:19 <lambdabot>  Defined.
13:29:24 <Peaker> jmcarthur_work: hmm, sorry, you're right above - I did mean getting the error case outside of the stream type (Though not Eof) -- I wonder if that is possible
13:29:25 <jmcarthur_work> one could imagine the stream like chunk ++ chunk ++ chunk ++ chunk ++ ...
13:30:02 <mnkme> why do div and / have different types?
13:30:04 <Peaker> jmcarthur_work: consider that if you use   (EitherT error Iteratee) then you have  Iteratee (Either error a) -- which means you get to have an error in the stream - though that means you don't have a processing result (maybe a good thing?)
13:30:14 <Peaker> @type (div, (/))
13:30:16 <lambdabot> forall a a1. (Integral a, Fractional a1) => (a -> a -> a, a1 -> a1 -> a1)
13:30:20 <mmorrow> @let foldC _ z [] = z; foldC f z (x:xs) = f z x (\z -> foldC f z xs)
13:30:22 <lambdabot>  Defined.
13:30:43 <Peaker> mnkme: Because div is integer division, and (/) is fractional division -- different operations with different semantics
13:30:53 <Peaker> > (3 `div` 2, 3/2)
13:30:55 <lambdabot>   (1,1.5)
13:31:01 <jmcarthur_work> Peaker, i think part of the point of iteratee is that deeper enumerators get that chance though
13:31:10 <lpsmith> :t foldC
13:31:11 <jmcarthur_work> they are in IO, in most cases, anyway, so they might need to clean up
13:31:12 <Peaker> jmcarthur_work: by "deeper" do you mean later?
13:31:12 <lambdabot> forall t1 t. (t1 -> t -> (t1 -> t1) -> t1) -> t1 -> [t] -> t1
13:31:16 <mmorrow> > foldC (\a b k -> if b==0 then 0 else let c = a*b in c `seq` k c) 1 [1..10000]
13:31:16 <mnkme> thanks
13:31:19 <lambdabot>   284625968091705451890641321211986889014805140170279923079417999427441134000...
13:31:29 <jmcarthur_work> Peaker, my understanding is that deeper and later are really the same thing
13:31:37 <Peaker> jmcarthur_work: The later enumerators get the finished iteratee -- which includes the Either result?
13:31:37 <mmorrow> > foldC (\a b k -> if b==0 then 0 else let c = a*b in c `seq` k c) 1 ([1..1000]++[0]++[1..])
13:31:39 <lambdabot>   0
13:31:41 <copumpkin> what's foldC ?
13:31:43 <copumpkin> oh
13:31:46 <saml> @type foldC
13:31:48 <lambdabot> forall t1 t. (t1 -> t -> (t1 -> t1) -> t1) -> t1 -> [t] -> t1
13:31:49 <copumpkin> you definedz0red it up there
13:31:56 <mmorrow> you get to has the continuation too
13:32:27 <Peaker> jmcarthur_work: oh wait, EitherT error (Iteratee a) -- allows the iteratee to throw an error, but no the enumerator
13:32:45 <mmorrow> either side can abort at any time, the `f' side or the `foldC' side
13:33:47 <jmcarthur_work> Peaker, i'm only getting a small part of the big picture, myself
13:33:53 <jmcarthur_work> my advice is more like guesses
13:34:28 <Peaker> mmorrow: I find the (Error String) case in the Stream type (as well as the name "Stream") really ugly, and trying to find an alternative
13:34:31 <alpha_q> can I trace a function call?
13:34:41 <mmorrow> Peaker: what stream type?
13:34:58 <Peaker> mmorrow: In Iteratee, the type:  data Stream el = Error String | Eof | Chunk [el]
13:35:02 <mmorrow> ah
13:35:10 <jmcarthur_work> i do think the iteratee interface is not very pretty
13:35:19 <Gracenotes> alpha_q: ...to certain extents
13:35:31 <jmcarthur_work> whoever it is that's maintaining the hackage version is trying to clean it up at least, it seems
13:35:53 <Gracenotes> Debug.Trace provides a means of printing out debug messages before evaluating a given value
13:36:01 <alpha_q> Gracenotes for example a simple function that outputs some text and returns true: f = do putStrLn "test"; True
13:36:14 <Peaker> mmorrow: also, why does Iteratee hard-code the list-of into Chunks? Why not have it part of the parametrized type?  e.g: why   data Stream el = ... [el]   and not: data Stream a = ... a ?
13:36:24 <Gracenotes> Debug.Trace would handle that with: f = trace "test" True
13:36:36 <Gracenotes> however, if f's value is never needed, "test" will never be printed out
13:36:50 <alpha_q> Gracenotes, thanks, that's exactly what I need
13:37:02 <jmcarthur_work> Peaker, you aren't looking at iteratee 0.2 are you?
13:37:18 <jmcarthur_work> 0.2 has a ListLike type class for that, and parameterized StreamG
13:37:19 <Gracenotes> alpha_q: also useful might be this function: ts a = trace (show a) a
13:37:38 <alpha_q> thanks
13:38:16 <jmcarthur_work> Peaker, well, and i believe ListLike is only required for certain functions, too
13:38:24 <Peaker> jmcarthur_work: I looked at some pdf slides -- looking at the new one, looks better indeed
13:38:35 <Peaker> data StreamG c el= EOF (Maybe ErrMsg) | Chunk (c el)
13:38:40 <jmcarthur_work> yes
13:38:55 <Peaker> but still ugly (ErrMsg is)
13:39:00 <jmcarthur_work> the documentation still sucks though
13:39:18 <jmcarthur_work> i think ErrMsg is appropriate for what it is
13:39:41 <Peaker> why?
13:39:55 <mmorrow> Peaker: eek, i dunno. i'm not really familiar with that lib.
13:39:59 <jmcarthur_work> could be nice if StreamG itself was a type parameter for the other things rather than having it hard coded in. then you could have your own errors if you even want them
13:40:15 <Gracenotes> hm. kind inference is interesting
13:40:33 <Saizan> Gracenotes: really?
13:40:34 <jmcarthur_work> but you have to be able to communicate errors to the iteratees somehow...
13:40:44 <Gracenotes> well. superficially. how complicated an algorithm is it?
13:41:00 <mmorrow> isn't it just the simply typed lambda calculus?
13:41:07 <Gracenotes> probably to mostly see what's applied to what
13:41:08 <mmorrow> but simpler still?
13:41:18 <alpha_q> so is that a decent way for checking primes: http://pastebin.com/d1534237d (or is it too c-like)
13:41:31 <mmorrow> i think it's pretty trivial compared to anything where you actually have typevars
13:41:33 <Gracenotes> well. probably. Do you know where in the ghc path kind inference is?
13:41:55 <jmcarthur_work> @src any
13:41:55 <lambdabot> any p =  or . map p
13:42:02 <jmcarthur_work> @src all
13:42:02 <lambdabot> all p =  and . map p
13:42:07 <Saizan> it's mixed with type inference, surely
13:42:14 <jmcarthur_work> @and
13:42:14 <lambdabot> Maybe you meant: arr ask bid id kind undo wn
13:42:20 <jmcarthur_work> @src and
13:42:21 <lambdabot> and   =  foldr (&&) True
13:42:23 <Gracenotes> well, the question is about the internal implementation :)
13:42:33 <jmcarthur_work> alpha_q, you should definitely be using the all function
13:42:52 <jmcarthur_work> i'm not paying much attention to the algorithm, just the style
13:43:26 <mmorrow> Gracenotes: this seems like a promising lead http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2854#a2854
13:43:45 <Gracenotes> orite, grep
13:43:53 <alpha_q> jmcarthur_work the style is exactly what I'm trying to get
13:44:05 <jmcarthur_work> alpha_q, you could also do something like n /= 1 && n `mod` 2 /= 0 && all ... instead of the guards, if you wanted to, i suppose
13:44:18 <jmcarthur_work> @pl \p -> n `mod` p /= 0
13:44:19 <lambdabot> (0 /=) . (n `mod`)
13:44:33 <jmcarthur_work> @pl \p -> mod n p /= 0
13:44:34 <lambdabot> (0 /=) . mod n
13:44:53 <jmcarthur_work> i think ^^ is okay, personally
13:45:15 <mmorrow> heh, oops  s|\.?lhs|\.l?hs|
13:45:40 <mmorrow> didn't matter though for this search
13:46:00 <jmcarthur_work> contrary to popular belief, i think a lot of mathy things look about the same in haskell as they do in other languages... like math
13:46:13 <jmcarthur_work> and so i don't tend to criticize math code that much
13:46:27 <jmcarthur_work> list stuff, sure, but not the raw math. same for a lot of boolean logic
13:46:31 <Gracenotes> yeah, most compiler stuff is lhs
13:47:08 <monochrom> For example p∧q is an ideal notation but all programming languages do the sucky p&&q
13:47:27 <Beelsebob> > 5^6
13:47:28 <lambdabot>   15625
13:47:31 <Beelsebob> >.>
13:47:36 <Gracenotes> there are 202 lhs and 116 hs in the compiler directory
13:48:00 <jmcarthur_work> i wish unicode was pervasive in haskell code like it is in, say, agda
13:49:36 <monochrom> @type (=)
13:49:38 <lambdabot> parse error on input `='
13:49:57 <monochrom> And Haskell succumbs to this == nonsense, too.
13:50:29 <ryant5000> is there any other Haskell game studio? (than mine)
13:50:32 <mmorrow> let x := if 42 = 9 then explode else () -- ?
13:50:39 <copumpkin> ryant5000: not that I know of
13:50:42 <copumpkin> ryant5000: do you know liz kim?
13:50:43 <ryant5000> i'm about to claim that in an email, and i'd rather not make an ass of myself :P
13:50:56 <ryant5000> uhm, does she go to harvard law school?
13:51:05 <monochrom> Yes I would rather like x := 5=6.
13:51:10 <copumpkin> ryant5000: yup
13:51:15 <ryant5000> yeah
13:51:17 <ryant5000> i know her
13:51:23 <ryant5000> took a class with her
13:51:30 <mmorrow> monochrom: i think i would too actually
13:51:50 <ryant5000> how do you know her?
13:52:11 <copumpkin> ryant5000: we lived on the same floor our freshman year and hung out a lot
13:52:18 <ryant5000> ah, that's cool
13:52:21 <ryant5000> where did you go?
13:52:50 <copumpkin> dartmouth :) anyway, just random coincidence
13:53:04 <ryant5000> yeah, small world, and all that :P
13:53:15 <copumpkin> ryant5000: anyway, I don't think there are other haskell game companies but I can't guarantee it :P
13:53:47 <ryant5000> well, i'm gonna say it :P
13:53:54 <monochrom> If there are, they're funded by the NSA and keeping quiet. :)
13:53:56 <byorgey> ryant5000: which is your game studio?
13:53:59 <ryant5000> as far as i can tell, that's what businesspeople do
13:54:05 <ryant5000> iPwn Studios - it's newly-formed :P
13:54:10 <monochrom> ...
13:54:23 <ryant5000> yeah, it's a silly name; get over it
13:54:23 <yitz> ryant5000: enygma?
13:54:25 <byorgey> ryant5000: what about gamr7?
13:54:37 <erikc> gamr7 and anygma are content creation
13:54:53 <ryant5000> yeah, my impression was that anygma was more about multimedia content
13:54:53 <copumpkin> angina?
13:55:01 <ryant5000> with perhaps some interactivity
13:55:11 <byorgey> ok, I didn't know precisely what you meant by 'game studio' then =)
13:55:13 <ryant5000> yeah, and gamr7 is a tools house
13:55:21 <ryant5000> yeah, we're actually developing first-party games
13:55:30 <byorgey> cool!
13:55:43 <ryant5000> our first game will be an action-RPG in which you are a hammer-weilding knight
13:55:49 <monochrom> Is there such a thing as "second-party games"?
13:56:01 * copumpkin loves his war hammers
13:56:18 * latcauxehu loves copumpkin's war hammers also
13:56:18 <monochrom> I thought knight's definition said sword not hammer.
13:56:19 <ryant5000> monochrom: you might consider pencil and paper games that :P
13:56:24 <byorgey> how about a hammer-welding knight?
13:56:34 <byorgey> his hammer keeps falling apart
13:56:39 <ryant5000> monochrom: well, that's how badass he his :P
13:56:44 <latcauxehu> Sword, flail, mace, hammer, random stick
13:56:47 <monochrom> Perhaps I confused knight with samurai
13:56:50 <latcauxehu> All valid knightly weapons
13:56:54 <gwern> monochrom: knights could use any weapon they like, as could samurai
13:56:58 <erikc> monochrom: yes, independent studios who are funded to make exclusive content by/for platform owners (e.g. insomniac games)
13:57:00 <ryant5000> in any case, he knocks monsters around a lot
13:57:13 <erikc> second party studios also typically get access to all the first party developer network libraries and documentation
13:57:16 <latcauxehu> I think samuri were mandated to /carry/ a sword
13:57:22 <ryant5000> and then their blood (or mana, if the censors demand) spills on the ground
13:57:30 <ryant5000> and the knight can do weird magic or technological stuff to it
13:57:31 <gwern> for example, in japan there is reputedly a statute of a kami of war with >1000 weapons; no doubt there's a lot of redundancy there, but you get the picture
13:57:37 <ryant5000> (we're still working on setting and such)
13:58:25 <ryant5000> so, the point is to have really awesome-looking screenshots :P
13:58:29 <yitz> Gracenotes: here's another way of looking at it:
13:58:31 <yitz> @type \f (x,y) -> pure (,) <*> pure x <*> f y
13:58:33 <lambdabot> forall t a a1 (f :: * -> *). (Applicative f) => (t -> f a1) -> (a, t) -> f (a, a1)
13:59:01 <gwern> monochrom: and from a practical standpoint, warhammers and axes are superior to swords when dealing with fully plated enemies
13:59:08 * Cale feels a bit like writing a top-down space RPG/shooter sort of game. Hmm...
13:59:13 <monochrom> I am a >>=-wielding knight. I poke it into programmers' eyes.
13:59:45 <alpha_q> what's the quickest way to define a decrementing list from n to 1 ?
13:59:51 <alpha_q> [n, n-1 .. 1] ?
13:59:53 <EvilTerran> demon >>= sword
13:59:58 <byorgey> alpha_q: yep
13:59:58 <EvilTerran> alpha_q, yeah
14:00:06 <Gracenotes> by the way, I've never seen type *inference* fail from an ambiguous-type-variable complaint, but..
14:00:09 <Gracenotes> @type pure <*> pure
14:00:11 <lambdabot>     Ambiguous type variable `f' in the constraint:
14:00:11 <lambdabot>       `Applicative f'
14:00:11 <lambdabot>         arising from a use of `pure' at <interactive>:1:9-12
14:00:14 <Gracenotes> weird huh
14:00:24 <yitz> Isn't there a policy about violence on this channel?
14:00:24 <Peaker> mmorrow, jmcarthur_work: It seems to me like Iteratee corresponds pretty well to Data.Binary.Get and Enumerator to Data.Binary.Put -- and perhaps should even replace those entirely?
14:01:29 <Gracenotes> it's odd, because the type of (pure <*>) is definitely (a -> a1) -> a -> a given the Applicative function instance
14:01:31 <yitz> @slap monster
14:01:31 * lambdabot decomposes monster into several parts using the Banach-Tarski theorem and reassembles them to get two copies of monster!
14:01:33 <jmcarthur_work> i've never used Data.Binary.{Get,Put}
14:01:34 <Peaker> at least conceptually, they seem very similar
14:01:49 <Gracenotes> but it seems it can't unify (a -> a1) with pure's (a -> f a)
14:02:10 <Gracenotes> and it refuses to do type inference without it, claiming that the type variable is ambiguous
14:02:23 <jmcarthur_work> :t pure
14:02:25 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
14:02:26 <jmcarthur_work> :t (<*>)
14:02:27 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
14:02:40 <monochrom> lambdabot has awesome magic!
14:02:48 <Gracenotes> all I want is some S K K!
14:02:52 <yitz> Gracenotes: what do you expect the type to be?
14:03:02 <Gracenotes> SKK = I
14:03:16 <Gracenotes> a -> a
14:03:20 <jmcarthur_work> :t (pure <*>)
14:03:20 <yitz> Gracenotes: no, pure <*> pure
14:03:22 <lambdabot> forall b a. (b -> a) -> b -> b
14:03:29 <gwern> pure is not SKKI
14:03:38 <Gracenotes> pure is K
14:04:03 <jmcarthur_work> :t (pure <*>) pure
14:04:04 <lambdabot>     Ambiguous type variable `f' in the constraint:
14:04:04 <lambdabot>       `Applicative f'
14:04:04 <lambdabot>         arising from a use of `pure' at <interactive>:1:11-14
14:04:17 <yitz> oh
14:04:46 <EvilTerran> ?type pure <*> (pure :: a -> b -> a)
14:04:48 <lambdabot> forall b. b -> b
14:04:48 <Gracenotes> I expect the type of pure <*> pure to be a -> a for function instances... but hm... maybe it's displaying the error because it doesn't know how to apply an Applicative constraint when there is no Applicative constraint in the actual type
14:04:57 <jmcarthur_work> :t ((pure <*>) :: (a -> (e -> b) -> a -> a)
14:04:59 <lambdabot> parse error (possibly incorrect indentation)
14:05:06 <jmcarthur_work> :t ((pure <*>) :: a -> (e -> b) -> a -> a)
14:05:08 <lambdabot>     Occurs check: cannot construct the infinite type:
14:05:08 <lambdabot>       a = (e -> a) -> a1
14:05:08 <lambdabot>     In the expression: ((pure <*>) :: a -> (e -> b) -> a -> a)
14:05:11 <Gracenotes> this seems a bit... strict
14:05:36 <Gracenotes> const <*> const does work fine though :)
14:05:46 <EvilTerran> ?type const <*> pure
14:05:48 <lambdabot>     Ambiguous type variable `f' in the constraint:
14:05:48 <lambdabot>       `Applicative f'
14:05:48 <lambdabot>         arising from a use of `pure' at <interactive>:1:10-13
14:05:48 <jmcarthur_work> Gracenotes, EvilTerran got it there
14:05:54 <jmcarthur_work> earlier
14:06:05 <jmcarthur_work> :t pure <*> const
14:06:07 <lambdabot> forall b. b -> b
14:06:21 <EvilTerran> ?type (<*> pure)
14:06:22 <lambdabot> forall b a (f :: * -> *). (Applicative f) => (a -> f a -> b) -> a -> b
14:06:37 <yitz> @pl \f (x,y) -> pure (,) <*> pure x <*> f y -- obligatory
14:06:38 <lambdabot> (`ap` snd) . (. fst) . flip ((.) . (<*>) . (pure (,) <*>) . pure)
14:06:52 <Gracenotes> yitz: about your other way of looking at it, the applicative instance is superfluous here. after all, pure f <*> x -> f <$> x
14:07:02 <EvilTerran> yitz, i'm sure that'd ?pl better with liftA2
14:07:33 <Gracenotes> so both uses of <*> could be replaced with <$>. I guess pl doesn't know
14:07:44 <yitz> EvilTerran: hmm. can you help it?
14:08:25 <Gracenotes> @pl \f (x, y) -> liftA2 (,) (pure x) (f y)
14:08:26 <lambdabot> (`ap` snd) . (. fst) . flip ((.) . liftA2 (,) . pure)
14:08:29 <Gracenotes> O_O
14:08:42 <jmcarthur_work> man, this is a long one:  @pl \q w e r t y u i o p a s d f g h j k l z x c v b n m -> a b c d e f g h i j k l m n o p q r s t u v w x y z
14:08:44 <jmcarthur_work> don't do it here
14:08:45 <Gracenotes> eeek
14:09:08 <Gracenotes> @pl \x f y -> liftA2 (,) (pure x) (f y)
14:09:09 <lambdabot> (.) . liftA2 (,) . pure
14:09:12 <yitz> Gracenotes: well, yeah, we know it's superfluous, we already wrote it before with just fmap.
14:09:24 <Gracenotes> indeedy so, sir yitz
14:09:28 <luite> is there some standard function/operator to do this: let fixedPoint f x = let x' = f x in if x == x' then x else fixedPoint f x'
14:09:29 <Botje> jmcarthur_work: oh, that's just the alphabetize operator
14:09:37 <Peaker> @type \f (x, y) -> liftA2 (,) (pure x) (f y)
14:09:40 <lambdabot> forall t a b (f :: * -> *). (Applicative f) => (t -> f b) -> (a, t) -> f (a, b)
14:09:45 <copumpkin> @pl (\x -> x x x) (\x -> x x x) (\x -> x x x)
14:09:49 <lambdabot> ap (ap id id) id (ap (ap id id) id) (ap (ap id id) id)
14:09:49 <lambdabot> optimization suspended, use @pl-resume to continue.
14:10:02 <Gracenotes> @elite nooo, copumpkin, make it stop
14:10:03 <lambdabot> nOOO, cOpUMpxIn, mAkE i+ $ToP
14:10:05 * copumpkin feels rude with all that X
14:10:21 <RayNbow> luite, you could use until, but it would be slightly less efficient: fixedPoint f = until (\x -> f x == x) f
14:10:30 <byorgey> hey, this is a family-friendly channel, no triple-x stuff
14:10:39 <luite> RayNbow: wow how did you come up with that so fast ;)
14:10:43 <Botje> luite: groupBy (/=) (iterate f x) !! 1
14:10:48 <Peaker> @pl \f (x, y) -> (,) x <$> f y
14:10:49 <lambdabot> (`ap` snd) . (. fst) . flip ((.) . (<$>) . (,))
14:10:55 <Peaker> @type \f (x, y) -> (,) x <$> f y
14:10:56 <Botje> oh, and another head :(
14:10:57 <lambdabot> forall t t1 a (f :: * -> *). (Functor f) => (t1 -> f a) -> (t, t1) -> f (t, a)
14:11:12 <Gracenotes> you could say it's a head of its time
14:11:22 <RayNbow> luite: the secret is to precompute answers and cache them... for fast copy/paste actions ;)
14:11:25 <Peaker> yitz: what was that thing for?
14:11:34 <Peaker> yitz: with the superfluous applicative?
14:11:37 <luite> Botje: hm, that doesn't look much cleaner in my opinion :)
14:12:18 <yitz> Peaker: while traversing down a syntax tree, everything is written with applicative stuff, so that's consistent.
14:12:33 <yitz> in my code anyway, it looks nicer.
14:12:41 <Peaker> yitz: What do you mean? Which syntax tree?
14:12:52 <RayNbow> :t \f -> groupBy (/=) (iterate f x) !! 1
14:12:58 <yitz> Peaker: from haskell-src
14:12:59 <lambdabot> (Expr -> Expr) -> [Expr]
14:13:15 <yitz> Peaker: from parsing some Haskell
14:13:16 <RayNbow> :t \f x -> groupBy (/=) (iterate f x) !! 1
14:13:22 <luite> RayNbow: you need another head (like Botje said)
14:13:33 <lambdabot> thread killed
14:13:37 <RayNbow> ah, missed it
14:13:57 <EvilTerran> ?type (uncurry (fmap . (,)) .) . second -- yitz, well, this is what i end up with
14:14:00 <Peaker> yitz: not sure I understand why syntax tree is related to applicative stuff?
14:14:14 <Peaker> EvilTerran: Use SECs then
14:14:27 <EvilTerran> Peaker, yeah, i know
14:14:48 <yitz> oh oh, we've given \bot a headache
14:15:09 <yitz> @bots
14:15:10 <lunabot>  :)
14:15:33 <monochrom> :)
14:15:40 <EvilTerran> (:
14:15:50 <yitz> Cale: oops, we seem to have given \bot a headache
14:15:57 <profmakx> i wonder. is there anyone from st. andrews or edinburgh hanging around here?
14:16:42 <Cale> :t map
14:16:48 <Cale> hmm
14:16:53 <copumpkin> @seen ChilliX
14:17:04 <copumpkin> preflex: seen ChilliX
14:17:04 <preflex>  ChilliX was last seen on #ghc 25 days, 21 hours, 38 minutes and 44 seconds ago, saying: Moin
14:17:09 <copumpkin> preflex: seen Chilli
14:17:10 <preflex>  Sorry, I haven't seen Chilli
14:17:11 <Cale> Well, if it doesn't come back on its own in a minute, I'll restart it.
14:17:17 <copumpkin> wow, has he really been gone that long?
14:17:18 <SimonRC> preflex: I think edwinb is
14:17:26 <Cale> Usually it does manage to find a way to survive :)
14:17:33 <yitz> Cale: thanks. sorry about that.
14:18:15 <yitz> I think it may have been copumpkin's x x x stuff
14:18:50 <Botje> argh! UNDERAGE ECKS!
14:19:02 * edwinb might be from St Andrews or Edinburgh
14:19:16 * EvilTerran suspects @pl would do well to type-check its input before doing anything else
14:19:27 <copumpkin> yeah, it should
14:19:28 <monochrom> undergrad geeks?
14:19:29 <copumpkin> sorry about that
14:19:37 <copumpkin> it's pretty much guaranteed to kill lambdabot
14:19:41 <RayNbow> luite, Botje, how about the following two lines?
14:19:43 <RayNbow> pairs xs = zip xs (tail xs)
14:19:43 <RayNbow> fixpoint f x = head [a | (a,b) <- pairs (iterate f x), a==b]
14:20:27 <yitz> profmakx: it is reported that edwinb might be from St Andrews or Edinburgh
14:21:08 <Gracenotes> or instead of ==, closeEnough
14:21:25 <Gracenotes> or instead of list comprehensions, find
14:21:33 <Botje> head . dropWhile (uncurry (==)) . (zip`ap`tail) $ iterate f x
14:21:37 * Botje runs
14:21:43 <Botje> RayNbow: actually, that's pretty nice
14:21:51 <yitz> EvilTerran: anyway, assuming the type is right, I was hoping to see a solution using second. thanks.
14:22:32 <Gracenotes> Botje: it's also called 'find', s/head/safeHead/
14:22:57 <EvilTerran> , [$typ| (uncurry (fmap . (,)) .) . second |]
14:22:58 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Quote.QuasiQuoter'
14:23:03 <EvilTerran> , [$ty| (uncurry (fmap . (,)) .) . second |]
14:23:07 <lunabot>  forall a b c b . Functor c => Hask b (c b) -> (a, b) -> c ((a, b))
14:23:20 <EvilTerran> uh, what?!
14:23:38 <luite> RayNbow: hm, clever use of a list comprehension
14:24:05 <luite> RayNbow: although I don't find the name 'pairs' very descriptive
14:24:26 <yitz> EvilTerran: that's actually correct
14:24:28 <Pistahh> hello
14:24:32 <RayNbow> I haven't found a better name for pairs yet, luite
14:24:43 <Pistahh> I am trying to write a 8 queen solver in haskell but it does not work
14:24:46 <Pistahh> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6169
14:24:58 <Pistahh> but for 3 cols it gives a result but it shouldn't
14:25:00 <RayNbow> Botje: the use of "ap" makes my head hurt btw :p
14:25:05 <Pistahh> how can I figure out why?
14:26:20 <Botje> @quote ap`tail
14:26:29 <Botje> hmm :)
14:26:47 <RayNbow> @bot
14:26:48 <lunabot>  :)
14:27:00 <RayNbow> oh noes, lambdabot died again :p
14:28:36 <dancor> lambdabail
14:29:33 * Cale grumbles... reactive-fieldtrip seems to fail now even for the simple program which worked before...
14:30:10 <Cale> RayNbow: Yeah, I was waiting to see if it would return on its own
14:30:17 <Cale> I suppose not.
14:30:59 <dons> ryant5000: woo!
14:31:00 <Cale> hmm
14:31:01 <dons> http://www.reddit.com/r/programming/comments/8upau/ipwn_studios_releasing_haskell_on_the_iphone/
14:31:05 <Cale> it's in a very strange state
14:31:57 <luite> hm, by the way, is there a way to make lambdabot reconnect automatically when it loses its irc connection?
14:32:18 <Cale> It normally does.
14:32:29 <Cale> It was reconnecting and failing for some other strange reason.
14:32:32 <luite> oh, mine doesn't seem to do that
14:32:48 <Cale> Oh, I have it running in a shellscript loop :)
14:32:52 <yitz> Cale: someone typed in a deeply recursive @pl, \bot gave a weird message, and soon after that became unresponsive
14:33:04 <yitz> oh
14:33:16 <monochrom> @bots
14:33:16 <lunabot>  :)
14:33:17 <luite> my provider used to have some problems, dropping the connection for a few minutes sometimes. I had to restart lambdabot to get it to reconnect to irc
14:33:23 <lambdabot> :)
14:33:37 <yitz> @vixen welcome back
14:33:37 <profmakx> @type map
14:33:45 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
14:33:51 <lambdabot> what's the last book you read?
14:34:40 <Cale> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6170#a6170 -- can anyone think of a reason that this would sit at 100% CPU and be completely unresponsive?
14:34:52 <Cale> As far as I know, it used to work.
14:35:04 <Cale> (I don't think I changed anything...)
14:35:32 <Cale> I built it with -threaded too
14:36:20 <Cale> oh hmm
14:36:33 <Cale> Maybe I need the latest unamb
14:36:54 <Gracenotes> @vixen I read a book about the hilbert problems
14:36:54 <lambdabot> ever just get the urge to go out and kill a puppy?
14:37:07 <Gracenotes> @vixen nooooo, not a puppy :!
14:37:07 <lambdabot> you're cute. :)
14:37:18 <Gracenotes> @vixen no u
14:37:19 <lambdabot> no?
14:37:31 <Gracenotes> @vixen what is *your* favorite book
14:37:31 <lambdabot> it's hard for me to pick a favorite. what's yours?
14:37:45 <Gracenotes> @vixen I liked GEB a bit
14:37:46 <lambdabot> what type of car do you drive?
14:38:01 <Gracenotes> @vixen wat
14:38:01 <lambdabot> forget about it
14:38:27 <mauke> @vixen has anyone really been far even as decided to use even go want to do look more like?
14:38:27 <lambdabot> yup, really
14:38:37 <Axman6> @vixen i couldn't live without the nbible, what about you?
14:38:38 <lambdabot> what about me?
14:38:49 * Axman6 lied anyway
14:39:33 <Botje> what's the nbible? big-endian version?
14:39:48 <RayNbow> @vixen Hello, please tell me something about @vixen
14:39:49 <lambdabot> being a vixen isn't as easy as it sounds
14:40:01 * copumpkin cheers for ryant5000's email
14:40:12 <Cale> Nope.
14:40:16 <Cale> hmm
14:40:23 <Cale> any reactive people around? :)
14:40:32 <RayNbow> @seen conal
14:40:32 <lambdabot> Last time I saw conal was when I left ##english, ##freebsd, ##hrg, ##logic, #arch-haskell, #concatenative, #darcs, #dreamlinux-es, #friendly-coders, #functionaljava, #gentoo-haskell, #gentoo-uy, #
14:40:32 <lambdabot> ghc, #haskell, #haskell-blah, #haskell-books, #haskell-freebsd, #haskell-in-depth, #haskell-overflow, #haskell-soc, #haskell.cz, #haskell.de, #haskell.dut, #haskell.es, #haskell.fi, #haskell.fr, #
14:40:32 <lambdabot> haskell.hr, #haskell.it, #haskell.jp, #haskell.no, #haskell.ru, #haskell.se, #haskell_ru, #jhc, #jtiger, #macosx, #macosxdev, #novalang, #perl6, #rosettacode, #scala, #scannedinavian, #unicycling, #
14:40:32 <lambdabot> xmonad and #yi 18d 16h 49m 56s ago.
14:40:37 <RayNbow> O_O
14:40:44 <Cale> heh
14:40:48 <mauke> preflex: seen conal
14:40:48 <preflex>  conal was last seen on #haskell-blah 18 hours, 28 minutes and 56 seconds ago, saying: BoinkyDoinky
14:40:52 <copumpkin> ryant5000: you gonna come back to #haskell-iphone?
14:40:54 <Cale> I despise the seen plugin.
14:41:11 <Axman6> @seen Cale
14:41:11 <lambdabot> Cale is in #haskell-in-depth, #bfpg, #ghc, #haskell-overflow and #haskell. I last heard Cale speak 17s ago.
14:41:18 <ryant5000> copumpkin: sure; i just forgot to (i'm on a few different computers)
14:41:26 <mauke> preflex: seen Cale
14:41:26 <preflex>  Cale was last seen on #haskell 32 seconds ago, saying: I despise the seen plugin.
14:41:26 <copumpkin> :)
14:41:44 <RayNbow> preflex: seen preflex
14:41:45 <preflex>  what
14:42:10 <Cale> I should just remove it. It always ends up writing some blank state file to disk and can't recover from that situation, apparently.
14:42:34 <Cale> (so I have to copy an old state file over it)
14:42:38 <monochrom> Yay for deleting code. People write too much code and don't delete enough.
14:42:57 * copumpkin loves deleting code
14:43:18 <Cale> preflex: seen Baughn
14:43:18 <preflex>  Baughn was last seen on #haskell 2 days, 5 hours, 10 minutes and 30 seconds ago, saying: Cheery: I'm sure Intel would agree that it's good
14:43:27 <Cale> hmm
14:43:31 <yitz> Cale: oh, it was that again.
14:43:37 <Gracenotes> why stop at deleting code! rm -rf ~
14:43:46 <yitz> Cale: but @seen is one of the most useful features of \bot
14:43:49 <Cale> yitz: in part, but no, it was more than that
14:44:07 <Cale> yitz: yeah, but it's so broken that it should just be rewritten.
14:44:29 <lpsmith> Gracenotes:  I basically did that on accident once
14:44:40 <yitz> Cale: as a temporary fix, just have it private message preflex
14:44:40 <lpsmith> I was not a happy camper
14:44:45 <Cale> haha
14:44:55 <Cale> Reminds me of moochbot
14:45:12 <Cale> I used to run a mathbot in #math which evaluated mathematica expressions
14:45:30 <monochrom> don't tell me you deleted mathematica :)
14:45:33 <Cale> so my friend wrote moochbot which did that too, only it did it by privmsging my bot :)
14:45:43 <yitz> hehe
14:45:51 <monochrom> hahahahahah that's devious
14:46:09 <Gracenotes> mathematica API?
14:46:13 <soupdragon> nice hack
14:46:30 <monochrom> Your friend learned the I combinator.
14:46:42 <Cale> Gracenotes: no, it just ran the kernel with a little wrapper around it
14:46:59 <Gracenotes> hmm. kernel, command line?
14:47:10 <Cale> MathKernel, yes
14:47:29 <monochrom> yeah command line. you enter Sin[0] to stdin, it gives stuff to stdout.
14:48:54 <Cale> Well, this is a poor state of affairs, reactive's ability to react is getting worse!
14:49:07 <Gracenotes> oh noes
14:49:14 <Botje> time to rename it to inactive!
14:52:12 <yitz> repassive
14:52:30 <deech> Hi all, what library would you recommend to have a Haskell program download a JPG file from the web and store it locally?
14:52:32 <mauke> @localtime
14:52:59 <Cale> hmm... not only is this program using lots of CPU and not responding, it's also consuming memory at an insane rate
14:53:11 <monochrom> the HTTP library.
14:54:59 <lambdabot> Local time for mauke is an illusion
14:55:02 <Gracenotes> or the curl bindings
14:55:10 <yitz> @localtime lambdabot
14:55:11 <lambdabot> I live on the internet, do you expect me to have a local time?
14:55:12 <Cale> ugh, any integration at all fails miserably now
14:55:28 <Peaker> Are there any new interesting opensource projects using Haskell lately?
14:57:05 <monochrom> When has @localtime become @src ? :)
14:58:16 <Gracenotes> @localtime ChanServ
14:59:32 <yitz> @src localtime
14:59:33 <lambdabot> Source not found.
14:59:49 <yitz> @localtime src
14:59:54 <deech> Gracenotes: curl looks great. Thanks!
15:03:26 <Gracenotes>   process _ msg whoAsked "localtime" rawWho = do
15:03:26 <Gracenotes>     let whoToPing = Msg.readNick msg $ fst $ break (== ' ') rawWho
15:03:26 <Gracenotes>     if whoToPing /= Msg.lambdabotName msg
15:03:26 <Gracenotes>         then do modifyMS $ \st -> M.insertWith (++) whoToPing [whoAsked] st
15:03:26 <Gracenotes>                 lift $ ircPrivmsg' whoToPing ("\^ATIME\^A")
15:03:28 <Gracenotes>                 return []
15:03:30 <Gracenotes>         else return ["I live on the internet, do you expect me to have a local time?"]
15:03:32 <Gracenotes> lambdabot delivers
15:06:29 <mauke> @localtime
15:06:32 <lambdabot> Local time for mauke is approximately 00:06
15:07:43 * Cale wonders if he should even attempt to understand why uiIntegral completely fails now.
15:07:59 <mmorrow> @pl \(a,as) -> fmap (flip (,) a) as
15:07:59 <lambdabot> uncurry (fmap . flip (,))
15:11:56 <yitz> lambdabot's watch is slow
15:12:08 <Cale> yitz: watch?
15:12:12 <yitz> oh, that was a while back. nvm
15:12:37 <Cale> yitz: localtime just trusts whatever the user's client returns for the time
15:12:58 <EvilTerran> @let (toArg ~> toRes) f = toRes . f . toArg
15:12:59 <lambdabot>  Defined.
15:13:01 <yitz> ah right so it would have been mauke's watch
15:13:22 <mauke> actually, a broken script
15:14:00 <mauke> but lambdabot queues up the requests, so once it gets a valid reply, it'll react to everything
15:14:32 <mauke> hmm, this needs to be tested
15:15:21 <EvilTerran> > sortBy (length ~> length ~> id $ compare) ["123", "4567", "8", "9AB", "", "CD"]
15:15:23 <lambdabot>   ["","8","CD","123","9AB","4567"]
15:15:53 <Gracenotes> BOAT
15:16:27 <mauke> @localtime
15:16:31 <lambdabot> Local time for mauke is approximately 00:16
15:16:39 <mauke> stupid rng
15:16:57 <Gracenotes> BOATSWAIN
15:17:05 <Gracenotes> let txt = "Local time for " ++ Msg.showNick msg whoGotPinged ++ " is " ++ time; lift $ flip mapM_ targets $ flip ircPrivmsg' txt
15:17:25 <yitz> @check \f g x y -> on f g x y == (g ~> g ~> id) f x y
15:17:25 <mauke> @localtime
15:17:26 <lambdabot>   Not in scope: `~>'Not in scope: `~>'
15:18:03 <mauke> @localtime
15:18:17 <EvilTerran> @check let infixr 2 ~>; (toArg ~> toRes) f = toRes . f . toArg in \f g x y -> on f g x y == (g ~> g ~> id) f x y
15:18:18 <lambdabot>   Overlapping instances for GHC.Show.Show (b -> b -> c)
15:18:18 <lambdabot>    arising from a use...
15:18:28 <EvilTerran> what
15:19:42 <RayNbow> > (succ ~> pred ~> succ ~> id) (,,) 1 2 3
15:19:44 <lambdabot>   (2,1,4)
15:19:47 <RayNbow> @hoogle (~>)
15:19:48 <lambdabot> No results found
15:19:49 <mauke> I think lambdabot has two queued localtime requests for me now
15:20:10 <mauke> the next @localtime mauke that gets a reply should trigger three messages to this channel
15:21:29 <andresj> hello! :D I wonder, what is the recommended XML toolkit for Haskell? The answer probably depends on what I'm doing, so I'd like to hear what the different toolkits are good for. Thank you! :D
15:21:55 <Peaker> EvilTerran: why the "to"?    The convention is established by arrows to be   first, second,  etc?
15:22:11 <RayNbow> is (~>) described somewhere on the wiki?
15:22:27 <RayNbow> (the only description I have is the one I received from Peaker some time ago on IRC :p)
15:22:41 <Cale> RayNbow: EvilTerran just defined it
15:22:45 <EvilTerran> Peaker, well, the "to" is to make the shape of the thing for multi-arg functions mirror the shape of the type
15:22:56 <EvilTerran> RayNbow, Cale: i got it off http://matt.immute.net/content/pointless-fun
15:24:01 <Peaker> EvilTerran: I mean the name,  "first" isn't called "toFirst" etc
15:24:02 <Cale> conal: uiIntegral seems 100% broken now
15:24:36 <EvilTerran> yitz, (g ~> (g ~> id)) f x y = ((g ~> id) . f . g) x y = (g ~> id) (f (g x)) y = (id . f (g x) . g) y = f (g x) (g y) = on f g x y, []
15:24:52 <monochrom> andresj: http://groups.google.com/group/comp.lang.haskell/msg/322c2d080a6058d1
15:24:54 <Cale> conal: any program which uses it seems to eat memory at a ridiculous rate and do nothing at all.
15:25:11 <EvilTerran> Peaker, i guess; i tend to avoid shadowing the names of common combinators, though
15:25:15 <andresj> monochrom: thank you! :D
15:25:34 <EvilTerran> it's only the parameter names, it's not like it affects how it works
15:25:59 <Peaker> @where+ ~> http://matt.immute.net/content/pointless-fun
15:26:00 <lambdabot> It is forever etched in my memory.
15:26:04 <Peaker> @where ~>
15:26:05 <lambdabot> http://matt.immute.net/content/pointless-fun
15:26:18 <yitz> EvilTerran: yeah, @check was supposed to say that.
15:26:21 <conal> Cale: yeah.  it's in a bad state.
15:26:37 <Cale> conal: Do you have any idea what's wrong?
15:26:56 <conal> Cale: a general, vague, woozy idea
15:28:46 <Cale> Is it something to do with unamb?
15:28:56 <Cale> What else has changed?
15:29:04 <conal> Cale: possibly.  more likely Event join.
15:29:12 <RayNbow> > let {infixr 2 ~> ; (x ~> y) z = x >>> z >>> y} in (succ ~> pred ~> succ ~> id) (,,) 1 2 3
15:29:13 <lambdabot>   (2,1,4)
15:29:37 <conal> Cale: but even then, it might come down to unamb.  it's been terribly difficult for me to diagnose.
15:29:38 <RayNbow> :t (~>)
15:29:39 <lambdabot> forall a b c1 c. (a -> b) -> (c1 -> c) -> (b -> c1) -> a -> c
15:29:48 <RayNbow> :t let {infixr 2 ~> ; (x ~> y) z = x >>> z >>> y} in (~>)
15:29:50 <lambdabot> forall (cat :: * -> * -> *) a b b1 c. (Control.Category.Category cat) => cat a b -> cat b1 c -> cat b b1 -> cat a c
15:30:56 <RayNbow> Peaker: you came up with the arrow version, right?
15:31:31 <Peaker> RayNbow: yeah, but I'm not sure its interesting
15:31:32 <Cale> Do we at least know what the semantics ought to be? I seem to recall there was some ambiguity about how it ought to be defined even abstractly?
15:36:16 <mauke> @localtime
15:36:39 <lambdabot> Local time for mauke is an illusion
15:36:39 <lambdabot> Local time for mauke is an illusion
15:36:39 <lambdabot> Local time for mauke is an illusion
15:36:44 <monochrom> Hahahaha
15:36:58 <mauke> THREE HIT COMBO
15:37:15 <monochrom> It is the triumph of science.
15:38:14 <lament> @localtime
15:38:18 <lambdabot> Local time for lament is Mon Jun 22 15:53:11 2009
15:38:29 <enolan> How is it supposed to work? GeoIP?
15:38:38 <lament> no, it's much more complicated than that
15:38:38 <Dessous> @localtime
15:38:57 <mauke> @localtime enolan
15:38:57 <lambdabot> Local time for enolan is Mon Jun 22 15:38:56
15:39:07 <enolan> hehe.
15:39:14 <monochrom> Pray tell, how complicated? I want to know!
15:39:26 <monochrom> Please tell me something funny! :)
15:39:27 <enolan> CTCP TIME request
15:40:27 <Peaker> where did quickcheck's evaluate go to?
15:40:39 <Peaker> Why does QuickCheck break so much of its API with its version release? :(
15:40:59 <Peaker> Maybe version-porting documentation should exist for prominent libraries so you have any idea what to do when things completely break between versions?
15:41:18 <monochrom> You are right. They exist.
15:41:33 <monochrom> They exist for non-prominent libraries, too.
15:41:42 * ManateeLazyCat pasted "DoubleLinkedList.hs" at http://paste2.org/get/279307
15:41:45 <ManateeLazyCat> In above link, GHC report "Couldn't match expected type `Maybe (Node a)'" for function `getCurrent`. How to fix it?
15:42:25 <Peaker> monochrom: where?
15:42:27 <ManateeLazyCat> Is "    Occurs check: cannot construct the infinite type: a = Maybe a" error, sorry.
15:42:51 <mauke> ManateeLazyCat: Just (nodeContent n)
15:43:46 <Peaker> monochrom: A bunch of functions have disappeared from Test.QuickCheck - I can't find the documentation about why or where they've gone
15:44:24 <ManateeLazyCat> In http://paste2.org/get/279307 , GHC report "Occurs check: cannot construct the infinite type: a = Maybe a"error for function `getCurrent`
15:45:31 <ManateeLazyCat> mauke: Is "Occurs check: cannot construct the infinite type: a = Maybe a", sorry i typo.
15:45:57 <monochrom> http://hackage.haskell.org/packages/archive/QuickCheck/1.0/doc/html/Test-QuickCheck-Utils.html  is QuickCheck version 1.0
15:45:58 <mauke> ManateeLazyCat: what
15:46:16 <ManateeLazyCat> In http://paste2.org/get/279307 , GHC report "Occurs check: cannot construct the
15:46:17 <ManateeLazyCat> 				 infinite type: a = Maybe a"error for function `getCurrent`
15:46:18 <monochrom> I wish I could tell you "I made that up on the spot".
15:46:34 <Peaker> monochrom: that's not "version porting documentation", as in: "To get your code to use version 2 instead of version 1, you need to change this to that"
15:46:48 <Peaker> monochrom: e.g: http://doc.trolltech.com/4.3/porting4.html
15:46:56 <monochrom> Ooops.
15:48:09 <Peaker> monochrom: QuickCheck totally broke stuff between each version :(
15:48:10 <ManateeLazyCat> mauke: I have fix it.
15:48:29 <ManateeLazyCat> Just (Node {nodeContent = n}) -> Just n
15:48:48 <mauke> what was wrong with my solution?
15:49:54 <ManateeLazyCat> Is "Occurs check: cannot construct the infinite type: a = Maybe a" error , not "Couldn't match expected type `Maybe (Node a)'" error, i paste wrong error information at first time.
15:50:16 * edwardk waves hello.
15:50:43 <mauke> ManateeLazyCat: YES I GOT THAT THE FIRST TIME
15:51:14 <ManateeLazyCat> mauke: Sorry i typeo. :)
15:51:27 <mauke> I saw the problem and I solved it
15:51:36 <mauke> why did you have to repeat the compiler error two times?
15:52:18 <ManateeLazyCat> mauke: No, i have two source code to test, i paste error information in another ghci. :)
15:52:25 <andresj> > xread "<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<example><element attribute=\"value\" /></example>"
15:52:27 <lambdabot>   Not in scope: `xread'
15:52:27 <mauke> what?
15:52:35 <mauke> ManateeLazyCat: I have no idea what you're talking about
15:53:33 <ManateeLazyCat> mauke: I paste source code, but i paste wrong error information at the first time. I have fix my problem anyway.
15:53:43 <mauke> <mauke> ManateeLazyCat: YES I GOT THAT THE FIRST TIME
15:53:47 <mauke> and the second time
15:53:49 <mauke> and the third time
15:53:50 <ManateeLazyCat> mauke: Nevermind it.
15:53:54 <mauke> and the fourth time
15:53:57 <mauke> why do you keep repeating that?
15:54:46 <ManateeLazyCat> mauke: Okay, i think we misunderstand each other, thanks for your help!  :)
15:54:47 <andresj> any idea why:
15:54:52 <andresj> > Text.XML.HXT.Parser.XmlParsec.xread "<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<example><element attribute=\"value\" /></example>"
15:54:54 <lambdabot>   Not in scope: `Text.XML.HXT.Parser.XmlParsec.xread'
15:54:58 <andresj> returns an error?
15:55:08 <andresj> the error is: [NTree (XError 2 "\"string: \"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\" ?>\\n...\"\" (line 1, column 6):\nunexpected xml\nexpecting legal XML name character\n") []]
15:55:33 <mauke> ManateeLazyCat: what I meant was: change 'nodeContent n' to 'Just (nodeContent n)'
15:55:42 <mauke> (that also fixes the error)
15:56:18 <ManateeLazyCat> mauke: No "Occurs check: cannot construct the infinite type: a = Maybe a" is RIGHT error for my source code. I have fix  it now.
15:56:49 <mauke> ManateeLazyCat: change 'nodeContent n' to 'Just (nodeContent n)'
15:56:56 <ManateeLazyCat> mauke: Just n -> Just (nodeContent n) can't work
15:57:02 <mauke> why not?
15:57:28 * copumpkin fmaps all over nodeContent
15:57:36 <ManateeLazyCat> mauke: Because a is (Maybe a), it still will got error  "Occurs check: cannot construct the infinite type: a = Maybe a"
15:57:42 <mauke> ManateeLazyCat: no
15:57:53 <mauke> I know this because I actually tried it
15:57:57 <ManateeLazyCat> Right solution: Just (Node {nodeContent = n}) -> Just n
15:58:08 <mauke> MY SOLUTION WORKS
15:58:13 <rizzix_> lol
15:58:14 <troutwine> Would someone be kind enough to explain why threadDelay does not delay as I expect? : http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6174#a6174
15:58:15 <copumpkin> lol
15:58:38 <troutwine> The "writer" thread loops as fast as it can, so I must be using threadDelay incorrectly.
15:58:42 <troutwine> I don't see how, however.
15:59:29 <mauke> troutwine: are you on a 32-bit machine?
15:59:43 <Saizan> , 3600000000 :: Int
15:59:45 <lunabot>  -694967296
15:59:45 <ManateeLazyCat> mauke: You should load all source code, not just function `getCurrent`, then you will find where the problem.
15:59:52 <troutwine> Oh, haha!
15:59:54 <mauke> ManateeLazyCat: I did
16:00:10 <mauke> ManateeLazyCat: my solution works.
16:00:21 <mauke> why do you think it can't work?
16:00:24 <copumpkin> do not question the mauke
16:00:27 <ManateeLazyCat> mauke: Weired, GHC report error if i use your solution.
16:00:38 <copumpkin> he will throw a polyglot at you that insults you in 100 different languages
16:01:45 <thoughtpolice> copumpkin: fmap'ing like that in public? all over the place??! how indecent
16:02:01 <copumpkin> thoughtpolice: sometimes I can't help it
16:02:09 <thoughtpolice> everybody gets an urge
16:04:53 <Peaker> the authors of QuickCheck are not in #haskell right?
16:05:51 <aavogt> @faq Does the Haskell Prelude make `fmap' always in scope?
16:05:52 <lambdabot> The answer is: Yes! Haskell can do that.
16:07:10 * SimonRC goes to bed
16:08:07 <monochrom> fmap is in the prelude. always in scope
16:08:07 <troutwine> Thanks, all.
16:08:34 <Peaker> do freeze/thaw copy the array?
16:09:52 <monochrom> Some optimization eliminates the copying.
16:11:27 <dons> Peaker: usually they don't copy
16:11:38 <dons> esp. if you use unsafeThaw /unsafeFreeze
16:13:50 <Baughn> Cale: Nope, going on vacation now. Back in ~12 days, if you wanted to ask anything.
16:15:08 <Cale> Baughn: I was mostly wondering about the strange behaviour of uiIntegral
16:15:15 <Cale> Baughn: But conal showed up :)
16:15:41 <Cale> (I'm still pretty mystified if you happened to have any insights)
16:18:24 <Baughn> Cale: Sorry, I haven't even touched integral yet.
16:18:46 <Baughn> Cale: And since I'm now writing my own, I wouldn't know much about conal's bizarrities then. Just my own. :P
16:18:49 <Cale> It's apparently something to do with the join for events.
16:18:59 <Baughn> Oh.
16:19:01 <Baughn> Yeah. That's broken.
16:19:14 <conal> "conal's bizarrities"!  please!
16:19:18 <Baughn> And so's the mappend for events.
16:19:25 <conal> "conal's abominations", if you don't mind.
16:19:30 <Cale> ahaha
16:19:33 <Baughn> Sorry, sorry. :P
16:19:42 <Cale> I'm not even really certain that I'm sure about what the join for events should be.
16:19:46 <SamB> if it doesn't follow the laws, even in spirit, it's *broken*
16:19:46 <conal> can't get me no respect.
16:19:59 <edwardk> conal: erm where? =)
16:20:12 <Cale> Should it switch between events, or merge the streams of events as they start arriving?
16:20:20 <Baughn> SamB: Never mind the laws, it's broken comparing to its own documentation.
16:20:29 <edwardk> ah from baughn here
16:20:32 <SamB> Baughn: oh, that's *really* broken
16:20:36 <Baughn> SamB: Or, you know, any concept of not producing bottoms without good reason
16:20:44 <conal> Cale: my answer is that it merges, as in the Set & list monads
16:20:55 <Baughn> SamB: I tried debugging it. GHC crashed.
16:21:24 <conal> however, Event is really the weak link.  the other types have a clear denotational semantics and follow the type class morphism discipline, but not Event.  so it's no wonder that trouble lies with Event.
16:21:32 <SamB> Baughn: what, with that crappy debugger?
16:21:39 <Baughn> SamB: With trace
16:21:45 <conal> semantics & TCMs lead the way to solid design.
16:21:48 <SamB> wow!
16:21:52 <SamB> that's BAAAAD
16:21:59 <SamB> what is this, C code?
16:22:04 <Baughn> No
16:22:10 <Baughn> SamB: Reactive is *really* good at uncovering bugs in ghc. In this case, it turned out that block/unblock were not prepared to be called inside uPIO.
16:22:21 <SamB> er, that was a derogatory remark, not a serious question, Baughn ;-)
16:22:22 <Baughn> SamB: And that I now habitually acronymize that function is probably.. bad.
16:22:51 <SamB> Baughn: shouldn't it be usPIO?
16:23:14 <conal> Baughn: so is unamb still not solid?
16:23:15 <Baughn> SamB: No. That construction reminds me of bad disk drives.
16:23:29 <SamB> hmm?
16:23:35 <Baughn> conal: unamb looks decent, apart from the whole "Baughn is trying desperately not to use it" bit
16:23:41 <Baughn> SamB: PIO mode
16:23:52 <Baughn> SamB: Which emphatically does not produce microsecond timings
16:23:59 <SamB> heh
16:24:11 <conal> Baughn: i asked in respons to your remark about block/unblock not likeing uPIO.
16:24:31 <Baughn> conal: Oh. Well, the bug was fixed
16:24:39 <conal> Baughn: in ghc?
16:24:42 <Baughn> YEs
16:24:49 <Baughn> The bugfix should be in 6.10.4
16:24:52 <conal> Baughn: which version has the fix?
16:24:53 <conal> oh.
16:25:08 <SamB> Baughn: what? they fixed #367?
16:25:08 <conal> Cale: have you tried 6.10.4?
16:25:13 <Cale> conal: nope
16:25:16 <Baughn> SamB: #367? no..
16:25:18 <conal> me neither
16:26:12 <conal> reactive could probably redone without unamb, as i described in a blog post (http://conal.net/blog/posts/another-angle-on-functional-future-values/).
16:26:20 <Baughn> http://hackage.haskell.org/trac/ghc/ticket/3279 <-- This is the bug
16:26:34 <Baughn> conal: Right, but I'm trying to do without threads entirely
16:26:44 <Baughn> conal: ..hang on, this post is new
16:27:35 <Baughn> SamB: Hum. That's right, I got a reactive bug from #367 once, too.
16:27:49 <Adamant> conal: what makes stuff like future values and the stuff you are working with functional as opposed to requiring a monad? feel free to point me to a beginner link if that's too easy a question.
16:28:09 <Baughn> Adamant: Monads are functional, though. Do you mean "as opposed to requiring IO"?
16:28:18 <Baughn> Adamant: ..but they don't do IO
16:28:36 * Baughn glares at all the unsafePerformIO calls. No IO, I said!
16:28:49 <conal> Adamant: it's all about the semantic model.  the reactive types have precise & simple denotational semantics.  IO doesn't.
16:29:22 <conal> Adamant: that's why imperative programming (including haskell IO) is so much more semantically problematic than functional programming (without IO).
16:29:31 * erikc wishes windows presentation foundation had simple denotational semantics
16:29:44 <erikc> it's like reactive elisp
16:30:00 <Peaker> conal: do you consider the State monad functional?
16:30:04 <erikc> with a closed source implementation
16:30:14 * Cale does.
16:30:17 <Adamant> Baughn: maybe I don't understand "what is functional". I've heard monads variously referred to as functional or as a hack to allow functional languages to work, I know monads are expressable in terms of category theory so there's a theoretic basis for it
16:30:29 <Cale> The State monad just wraps a common FP idiom really.
16:30:33 <conal> Peaker: are you asking about the State monad or about how i use the word "functional"?
16:30:37 <conal> Peaker: or something else?
16:30:42 <Baughn> Adamant: There's a bit of a misunderstanding there. IO is the hack; monads are perfectly functional.
16:30:45 <Peaker> conal: how you use the word functional
16:31:00 <Baughn> Adamant: However, IO turned out to be a hack that matched the structure of monads well, thus the IO monad
16:31:06 <Adamant> right.
16:31:15 <conal> Peaker: i mean things with precise & fairly simple denotational semantics.
16:31:30 <Baughn> Adamant: And it was also the *first* monad, and the inspiration for having monads in haskell in the first place, which is why people confuse monads with nonfunctional code
16:31:34 <Cale> Adamant: Yeah, ignore the stuff about them being a hack. Monads are just a particular interface to a type of library which happens to be common.
16:31:35 <Peaker> Adamant: Monads are just a "strategy for combining computations together" as well as building trivial computations.   Those computations may be purely functional or imperative
16:31:42 <conal> Peaker: for clarity i sometimes use the term "denotational programming" instead of "functional programming"
16:31:53 <conal> since there's such diversity in how people use the term "functional"
16:32:05 <Cale> Adamant: It turns out that Haskell's IO library happens to have such an interface, so the general functions which work on all monads can be used with it if we recognise that.
16:32:06 <Adamant> generic monads are a nice organizational tool, and the IO that was needed could map onto it well, so it was implemented as a monad
16:32:11 <Baughn> Adamant: I prefer to think of a monad as a type that is already an applicative functor, and also happens to have a useful definition of join
16:32:38 <Baughn> *type constructor
16:32:48 <mmorrow> s/useful/existent/ ?
16:32:49 <Cale> Adamant: Yeah, other than the fact that it's convenient to have those functions from Control.Monad work, there's no particular reason that IO in Haskell must be a monad.
16:33:08 <Adamant> :P
16:33:12 <Cale> Adamant: In fact, it could have a completely different appearance, and it would still be fine with laziness.
16:33:14 <Baughn> mmorrow: If it wasn't useful in some way, chances are I wouldn't have come across it. I don't normally go searching for monads.
16:33:52 <Cale> Adamant: The key idea is really that we represent actions, or values which depend on the external world, as values of a special, separate type.
16:33:53 <conal> this habitual linking of IO & "monad" is why i'd rather people didn't refer to IO as "the IO monad".
16:34:09 <Adamant> right.
16:34:10 <mmorrow> Baughn: but the (imaginary) italics are on existent ;)
16:34:11 <Peaker> Adamant: Another POV:  There are tons of different imperative languages, that have different primitive operations. Some have goto's, some only have function calls. Most/all of them are hard-coded to only have those operations/statements, and have a hard-coded operator they usually call ; which combines those operations in a certain way.  If you generalize this pattern by allowing to build arbitrary statements and implementing your own ; -- you can essenti
16:34:11 <Peaker> ally build your own "imperative programming language". Actually it becomes more general and allows you to build non-imperative programming languages too
16:34:45 <conal> IO is a DSEL of imperative computation.
16:34:48 <Adamant> Peaker: which is why you can build continuations very easily with monads, right?
16:35:08 <conal> Adamant: continuations & monads are very different kinds of things.
16:35:15 <conal> Adamant: continuations are values. monads are types.
16:35:16 <Baughn> Adamant: The laziness is very important for implementing /those/
16:35:20 <conal> (type constructors)
16:35:31 <Peaker> Adamant: I don't know if it is "very easily", but you can build a monad (or an "imperative language") that supports continuations
16:35:41 <Adamant> conal: I'm just going on the "supercontrolflow" stuff
16:35:52 <mmorrow> `join' lets you read in half the file, then interpret the code that that represent to figure out how to parse the rest of the file eg
16:35:52 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
16:35:53 <lambdabot>   ("hello","olleh","HELLO")
16:36:07 <Saizan> the continuation monad is in some way fundamental as one
16:36:47 <Saizan> http://blog.sigfpe.com/2008/12/mother-of-all-monads.html <- as described here
16:36:53 <Cale> The function monad had better be considered functional ;)
16:38:22 <Adamant> anyway, thanks all!
16:38:38 * mmorrow associates ((->)e) with FORTRAN, i dunno know about you all
16:39:21 <Cale> Adamant: Actually, I'm a little more relaxed than conal in my view of IO. I'm willing to say that it's a purely functional way of writing imperative computations, which I think is better than not having that bit of leverage.
16:40:01 <Peaker> Cale: Isn't the CPP also adherent of that definition?
16:40:09 <Cale> Peaker: no, not really.
16:40:12 <Peaker> ("purely functional way of writing imperative computations")
16:40:22 <Peaker> why not?
16:40:31 <conal> Cale: i don't think we disagree, really.
16:40:54 <conal> Cale: i also say that it's technically functional.  and i bet you also say that there's no precise & tractable denotational semantics.
16:40:55 <Cale> The trouble with the CPP analogy is that there is no correspondence between string concatenation and the operation performed on those imperative semantics.
16:40:56 <Peaker> Cale: I don't think Haskell is really more purely functional than CPP, its just so much more powerful
16:41:08 <Cale> >>= at least tells you how the imperative semantics get wired up
16:41:59 <Cale> Whereas CPP's string concatenation isn't even guaranteed to result in anything *syntactically* correct, let alone have any correspondence with semantics.
16:42:27 <Peaker> Cale: I don't think it makes CPP less purely functional, just less powerful / badly designed
16:42:37 <conal> Cale: i agree that Haskell+IO is a more powerful imperative language than CPP+C.
16:42:56 <Peaker> Cale: Your points are good and valid, I just don't think they mean CPP isn't purely functional and a way of writing imperative programs
16:43:03 <conal> Cale: my point there is that the claims of Haskell+IO's "purity" also hold for CPP+C.
16:43:40 <Cale> The thing is that the pure operations are actually meaningful.
16:43:51 <Pseudonym> Don't #define and #undef mean that CPP isn't purely functional?
16:43:55 <Cale> (in Haskell's case)
16:43:57 <mmorrow> to be fair, CPP is compile-time
16:43:58 <conal> Cale: sure haskell is better.  but "pure" is an absolute.
16:44:05 <conal> Pseudonym: covered in the blog post
16:44:10 <mmorrow> you can create non-syntactically correct TH
16:44:15 <Pseudonym> There's a new one, or this is the old post?
16:44:32 <conal> http://conal.net/blog/posts/the-c-language-is-purely-functional
16:45:17 <Pseudonym> Right, this is the old one.
16:45:31 <Cale> Even if >>= represents a manipulation on imperative semantics, it is a pure manipulation of those semantic descriptions of what should happen.
16:46:05 <Cale> and corresponds to a meaningful operation on those semantics which always results in a valid new semantic description
16:46:08 <conal> Cale: yes.  yet another way that haskell is a better iptvlg than c.
16:46:14 <conal> (imperative language)
16:46:40 <Saizan> does CPP have higher order macros?
16:46:57 <conal> Saizan: probably.
16:46:58 <Pseudonym> That was my next point.  In cpp, functions aren't first-class.
16:47:14 <conal> Pseudonym: right.  haskell is better.  "pure" is absolute.
16:47:27 <Cale> So, that's what troubles me about that comparison. I just think we should be fair to what we do have already while looking for better ways to approach things.
16:47:29 <conal> these comparisons of haskell & cpp are irrelevant to my point.
16:47:36 <Pseudonym> conal: So even if cpp (modulo #undef) is pure, that doesn't mean it's purely functional.
16:47:37 <Pseudonym> Right.
16:47:40 <Saizan> no HOFs makes it not really functional, in my way, maybe pure
16:47:44 <Pseudonym> The question was whether or not Erlang was functional.
16:48:10 <Pseudonym> And the point is that if Erlang isn't functional, a lot of undeniably functional languages aren't functional.
16:48:33 <conal> Pseudonym: they are indeed deniably functional.
16:48:40 <Pseudonym> By the same measure,.
16:48:45 <conal> because people are using "functional" in different ways.
16:49:04 <conal> some mean fancy functions.  some mean lack of mutation.
16:49:12 <Cale> Bind is a higher order function, how much more do you want? ;)
16:49:27 <conal> Cale: want for what?
16:49:34 <Cale> "functional"
16:49:44 <conal> my beef isn't with "functional" and never was.
16:49:58 <Cale> Though, I do really view >>= as a pure manipulation of imperative descriptions.
16:50:00 <Pseudonym> The problem here is that lay people don't agree on what constitutes "functional".
16:50:08 <conal> Cale: so do i
16:50:20 <Cale> It's not values of type (IO t) which are impure, it's carrying them out :)
16:50:27 <conal> exactly
16:50:56 <Peaker> if you never execute main, there's no issue :-)
16:51:15 <conal> it's when people rely on the *semantics* of IO for their programs, and then claim that they're programming in a *purely* functional way, i think they're lying to themselves.
16:51:31 <conal> if on the other hand, they don't care what semantics IO has, then i believe them.
16:52:08 <Pseudonym> Here's the thing, though: All useful programming languages are multi-paradigm.
16:52:53 <Pseudonym> s/useful/sufficiently useful/
16:52:54 <Pseudonym> That includes supporting imperative-style IO.
16:53:06 <Peaker> Pseudonym: sufficiently for what?
16:53:20 <Pseudonym> Peaker: Sufficient to be a general-purpose programming language.
16:53:20 <Saizan> conal: i think "functional" doesn't really have anything to do with your statement
16:53:54 <Peaker> Pseudonym: I think its a bit premature to conclude about the future from that statement -- perhaps a general=purpose programming paradigm that has not yet been invented will make that obselete?
16:53:55 <Pseudonym> Haskell, for example, is pure function but also supports imperative and a form of OO programming.
16:54:11 <mmorrow> i'm fond of this one in particular (dunno, seems on-topic at the moment) http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2587
16:54:13 <Peaker> Pseudonym: What form of OO programming?
16:54:14 <Pseudonym> pure functional
16:54:29 <Pseudonym> Peaker: Typeclasses are a form of OO programming.
16:55:02 <Pseudonym> Or, at least, they effectively support a form of OO programming.
16:55:03 <mmorrow> all the IO monad does is save you from writing all those friggin cases..
16:55:35 <Pseudonym> mmorrow: To effectively support some programming paradigm, sometimes all you need is syntactic sugar.
16:55:45 <mmorrow> Pseudonym: i totally agree
16:55:50 <Peaker> Pseudonym: I think type classes are a generalization/more-powerful of some of OO's good ideas
16:56:04 <Pseudonym> Peaker: Some of, sure.
16:56:23 <Peaker> Pseudonym: Some other good ideas are supported by other stuff (e.g existential types) :)
16:56:54 <Pseudonym> Others are supported by ports/Concurrent.Channel.
16:57:25 <Pseudonym> But there's one good idea that Haskell doesn't support, and that's instantiable modules.
16:57:36 <mmorrow> tootally
16:57:44 <Pseudonym> But that's another rant.
16:57:52 <Pseudonym> Haskell's module system, as we know, is barely adequate.
16:58:23 <thoughtpolice> you mean functors?
16:58:41 <mmorrow> yes
16:58:51 <Pseudonym> But not Functors.
16:59:02 <SamB> thoughtpolice: that's "ML functors"
16:59:10 <SamB> say it like that ;-)
16:59:10 <mmorrow> that's what i'm thinking of
16:59:13 <thoughtpolice> yes, I thought the context was understood
16:59:36 <Peaker> I haven't ever used ML, which is maybe why I don't find Haskell modules that bad
16:59:38 <thoughtpolice> in any case, functors and type classes have a very large amount of overlap, so I'm not sure we would really need them
16:59:46 <SamB> call them that EVERY time
16:59:59 <erikc> functors are static only right (no dictionaries)
17:00:00 <thoughtpolice> so i don't really know if I would say the module system is 'barely adequate'
17:00:02 <mmorrow> there are no dictionaries with ML functors
17:00:10 <mmorrow> and there's no overlapping instances
17:00:46 * SamB may or may not have used ML functors in Coq
17:00:53 <erikc> without thinking about the implications, it seems like it'd be nice if there was a way to tell ghc that some typeclasses must never pass dictionaries (they must be devirtualzied at compile time, always)
17:00:57 <mmorrow> you get to give a module a type sig of its own, then write a function on modules (structs)
17:01:05 <thoughtpolice> i'm just playing conservative - I mean, there are papers on means of converting type classes to  ml functors and vice versa
17:01:14 <mmorrow> cabal could typecheck packages, like ghc typechecks functions
17:01:39 <dcoutts> mmorrow: yep
17:01:53 <thoughtpolice> type classes don't HAVE to have overhead, it's just the method that's used by all the major implementations
17:01:54 <mmorrow> dcoutts: that would be sweet
17:02:07 <dcoutts> mmorrow: it's an idea that's been rumbling around for a while.
17:02:14 <thoughtpolice> of course, that fact doesn't really mean much given that I suppose :)
17:02:17 <mmorrow> dcoutts: oh rly.
17:02:24 <dcoutts> mmorrow: the first bit is writing the tool to extract the package sig
17:02:38 <dcoutts> we proposed that as a GSoC project, but it didn't get funded
17:02:49 <Pseudonym> Module systems aren't sexy.
17:02:50 <thoughtpolice> erikc: do SPECIALIZE pragmas work with type class methods?
17:03:07 <erikc> no idea
17:03:17 <mmorrow> dcoutts: hmmm. so then would checking be comparing md5s of some canonical rep of the type forest of a module or something?
17:03:31 <mmorrow> (or would it be more?)
17:03:32 <thoughtpolice> Pseudonym: :)
17:03:48 <thoughtpolice> Pseudonym: I do agree ML functors are pretty sweet though
17:03:50 <Pseudonym> Seriously.  Haskell would have had a better module system by now if there had been a paper in it.
17:03:51 <dcoutts> mmorrow: it'd be checking if one sig is a subset of another
17:04:10 <Saizan> yeah, you want subtyping for modules :)
17:04:21 <mmorrow> ahh, ooh. hmm, that sounds better than i was picturing
17:05:01 * mmorrow thinks about this
17:06:08 * Saizan wonders if inference would be decidable
17:09:03 <erikc> thoughtpolice: the way i imagine it working (coming from a c++ background) is a 'must specialize' typeclass would make the compiler treat the function with that typeclass argument as a c++-style template (with instantiation/cloning) rather than taking a pointer with a vtable / dictionary
17:09:40 <erikc> but yea, i have no idea what that does to inferencing
17:11:54 <erikc> let foo x y z = x y z, bar = foo (+)
17:11:57 <erikc> wouldnt work so hot
17:12:29 <Saizan> i was talking about the "type system" for packages :)
17:12:32 <hackagebot> haskell-src-exts 1.0.0 - Manipulating Haskell source: abstract syntax, lexer, parser, and pretty-printer (NiklasBroberg)
17:13:23 <erikc> Saizan: i know :), they seem like the same thing to me though :)
17:13:30 <Saizan> erikc: i guess in that case you'd have multiple versions of bar
17:20:52 <jaredj> i've read the ghc/ultrasparc blog with interest. is anyone doing that sort of thing with the cell?
17:21:27 <jaredj> argh helps when i google "haskell cell" and not "haskell core"
17:22:29 <copumpkin> cell is mostly ppc, so someone would need to revive the PPC codegen
17:22:36 <copumpkin> and add the various candy on top
17:23:05 <jaredj> they'd want hardware first :/
17:23:21 <erikc> you'll need to gen asm for SPUs from a DSL as well
17:23:23 <copumpkin> well, I have a ps3
17:23:27 <copumpkin> yeah, probably
17:23:34 <erikc> haskell wont run in 256k :)
17:23:56 <copumpkin> do the non-ps3 cell CPUs have more memory on the SPUs?
17:23:57 <lament> @faq can Haskell run in 256k?
17:23:58 <lambdabot> The answer is: Yes! Haskell can do that.
17:24:00 <copumpkin> (I hope so)
17:24:05 <erikc> nope
17:24:39 <SamB> seriously? all SPUs have only 256k?
17:24:54 <jaredj> obligatory: 256k should be enough for anybody
17:25:15 <erikc> yup, only 256k
17:26:17 <erikc> some ppl at mcmaster already worked on the DSL stuff on SPU (http://www.cas.mcmaster.ca/~anand/papers/SPUSPMath.pdf), had good results
17:33:58 <thoughtpolice> yeah
17:34:34 <thoughtpolice> I have my doubts about haskell code running on the cell, but (E)DSLs in haskell for cell programming seem quite well suited apparently :)
17:35:04 <dcoutts> dons: what do you do for hpc coverage about things like return (), where the () is always unused
17:35:06 <thoughtpolice> erikc: they apparently had like a 4x speedup or something over the hand-written code if that's the same research I'm thinking of
17:35:22 <BMeph> I wonder if (John) tromp is writing a CL interpreter to run on a Cell procesor...
17:35:22 <thoughtpolice> hand-written C code, that is
17:36:18 <erikc> thoughtpolice: yes, i was part of the team at ibm that got beat by their code :)
17:36:40 * pikhq begins learning Haskell; mind blowing began... 5 minutes ago.
17:36:41 <erikc> first time i heard of haskell actually
17:37:34 <BMeph> erick: Welcome to the "If you can't beat 'em.." club, then. :)
17:37:41 <SamB> erikc: is that why you learned it ?
17:38:11 <erikc> it put it on my radar, then i learned it cause of STM
17:38:12 <SamB> erikc: and is this "only 256k" thing for ever and always?
17:38:28 <SamB> would they have to call it something else if it had 512k?
17:38:32 <erikc> since i was working on parallelizing the xlC optimizer and tearing my hair out
17:38:43 <BMeph> erikc: Sorry; my fingers have dyslexia, it seems. ;)
17:40:11 <erikc> SamB: nothing preventing them from having more local store (aside from hardware issues i guess, i am not particularly knowledge about that)
17:41:20 <erikc> there's some control register stuff on the SPU for setting how many bits to use for addressing
17:41:42 <erikc> so that if they add more local store, you can run your old 256k code in compatibility where pointer overflow around 256k would still work correctly
17:41:59 <erikc> so it's been thought of / planned for
17:53:39 <elliottt> conal: i'm writing an adapter for reactive and SDL, can i bother you with a few questions? :)
17:55:54 <conal> elliottt: sry.  not a good time.
17:56:06 <conal> elliottt: i'm distracted right now.
17:56:12 <elliottt> conal: maybe another time :)
17:56:17 <conal> yeah
18:03:51 <Peaker> Who has permissions to upload new versions of cabal packages? Only the original author? How is maintainership passed on?
18:04:08 <thoughtpolice> anybody can upload a package under any name/version
18:04:15 <thoughtpolice> unless of course it conflicts with another existing package
18:04:26 <jaredj> wha...
18:04:38 <dcoutts> though that's going to change so that only maintainers can upload, though they'll also be able to delegate
18:04:51 <thoughtpolice> dcoutts: hackage2 ETA? :)
18:05:01 <dcoutts> thoughtpolice: hard to say
18:05:14 <dcoutts> quicker if you send patches :-)
18:05:39 <thoughtpolice> i'm flooded with stuff right now, including osx64bit support
18:06:00 <thoughtpolice> which I should actually be able to work on tonight while I'm working
18:06:23 <thoughtpolice> dcoutts: but are there any guidelines/list of plans for hackage2? to give an idea of 'what is left'?
18:06:26 <dcoutts> thoughtpolice: aye, we're always so busy :-(
18:06:40 <dcoutts> thoughtpolice: hitting feature parity is the first thing
18:06:54 <dcoutts> which we're pretty close to now
18:09:08 <dcoutts> thoughtpolice: the easiest way to get a feel for what is needed is just to run the thing, which isn't hard
18:21:08 <jaredj> @seen sm
18:21:08 <lambdabot> Last time I saw sm was when I left ##english, ##freebsd, ##hrg, ##logic, #arch-haskell, #concatenative, #darcs, #dreamlinux-es, #friendly-coders, #functionaljava, #gentoo-haskell, #gentoo-uy, #ghc, #
18:21:08 <lambdabot> haskell, #haskell-blah, #haskell-books, #haskell-freebsd, #haskell-in-depth, #haskell-overflow, #haskell-soc, #haskell.cz, #haskell.de, #haskell.dut, #haskell.es, #haskell.fi, #haskell.fr, #haskell.
18:21:08 <lambdabot> hr, #haskell.it, #haskell.jp, #haskell.no, #haskell.ru, #haskell.se, #haskell_ru, #jhc, #jtiger, #macosx, #macosxdev, #novalang, #perl6, #rosettacode, #scala, #scannedinavian, #unicycling, #xmonad
18:21:08 <lambdabot> and #yi 18d 20h 30m 32s ago.
18:22:16 <shapr> argh, SPAM
18:23:46 <jaredj> i don't think it's been 18 days
18:24:49 <jaredj> SGML DTDs are apparently not written in the same syntax as XML DTDs :(
18:26:29 <SamB> jaredj: what's worse is that I'm not sure if XML DTDs were valid SGML DTDs before they added a few things to SGML...
18:33:09 <roconnor> "Monads for Functional Programming " seems published in two places
18:37:32 <jkup> I have a value defined, "debugMode", that is referenced all over an application I'm working on.  I would like to set this value at run time, and do so without adding an additional parameter to every function that references it.  Can anyone give me some advice? I'll gladly rtfm is you point me at an appropriate module.
18:39:43 <thoughtpolice> Reader monad?
18:40:10 <aavogt> implicit parameters (some people hate this extension)?
18:40:56 * BMeph hugs his stuffed ImplicitParams toy every night, along with a "Warm Fuzzy Thing"
18:43:52 <edwardk> bmeph: mine is more like a voodoo doll.
18:44:04 <edwardk> i keep stabbing it with things waiting for someone to die. ;)
18:44:08 <Cale> jkup: It is possible to cheat by doing some very evil things...
18:44:09 <thoughtpolice> edwardk: reflection? :)
18:44:26 <edwardk> thoughtpolice: reified stab wounds
18:44:32 <thoughtpolice> hehehe
18:44:41 <Cale> jkup: But yeah, you might want to try the implicit parameters extension first. :)
18:44:47 <b4taylor> Is there some vector art for the newer >\= logo?
18:45:14 <jkup> Okay,  I'm really new to haskell programming (functional programming too)..  If I were to implement "application verbosity level :: Int" in a reader monad,  I still have to pass around an Environment to each function that needs to read the value.. forgive my C like grammer,  can I keep this value defined in the.. uh.. global scope
18:45:36 <edwardk> jkup: you _can_ but its generally considered pretty bad form
18:46:04 <soupdragon> if anything has "global" in it... it's bad
18:46:18 <Cale> jkup: If it is constant. See... the result of applying a function in Haskell only depends on the parameters you pass it.
18:46:24 <edwardk> and all of the tricks either involve implicit params (which are one form of evil) or unsafePerformIO (which is a whole different level of evil)
18:46:50 <jkup> Yeah, I see your point.. I guess what i'm trying to do is somewhat.. 'evil'
18:46:57 <aavogt> b4taylor: http://evenmere.org/~bts/haskell-logo/
18:47:33 <b4taylor> aavogt: Thanks.
18:47:51 <edwardk> jkup: there is another way which is slightly less tedious in some circumstances based on a paper by oleg kiselyov and cc shan, but any time someone says 'based on a paper' you might want to run screaming ;)
18:47:55 <Cale> jkup: This is actually intended to make debugging easier. Consider a function which accidentally returns a different result when you change your debugMode parameter :)
18:48:35 <BMeph> "It's not 'really' evil, it's more of an...Evli 'Lite'." ;p
18:51:12 <Cale> jkup: at least when the debugMode is explicitly a parameter, you can tell that the function's result might conceivably depend on it.
18:52:00 <Reiver> hrn
18:52:18 <Reiver> Okay, I'm having a little trouble with some conceptual stuff in Haskell, while trying to tweak a parser for TINY.
18:53:04 <rzezeski> Can someone explain to me how to load multiple modules in ghci that depend on each other?  I'm asking in reference to the JSON Pretty Printer example in Ch5 of RWH.  I can't figure out how to load PrettyJSON b/c it relies on Prettify
18:53:13 <Cale> jkup: (whereas if it doesn't, you have to go through the implementation of the function in order to tell that that dependency is there)
18:53:39 <Cale> rzezeski: The module files have to be named appropriately, and then it is automatic.
18:54:02 <rzezeski> If you mean that Prettify module should be Prettify.hs, then I did that
18:54:02 <Cale> (the filename must agree with the module name so that ghc/ghci knows where to look)
18:54:08 <Reiver> what I'm trying to do: http://pastebin.com/d71851e46 The code I'm doing it to: http://pastebin.com/d13908f3c (Sorry it's long, I'll highlight more once I have a better idea of what I'm hunting at)
18:54:18 <rzezeski> maybe my working directory?
18:54:20 <Cale> rzezeski: After that, it should just be automatic
18:54:28 <derenrich> any good libraries for monte carlo simulations?
18:54:36 <mmorrow> rzezeski: map Asdf.Qwerty.A.B to Asdf/Qwerty/A/B.hs, then make your pwd Asdf/../
18:54:39 <Reiver> So yeah, I'm stuck a bit on what it's actually /asking/ me to do...
18:54:40 <lpsmith> rzezski:  check out the -i option
18:54:49 <mmorrow> (err, by map i mean in your head)
18:54:54 <rzezeski> it was my working directory
18:54:59 <lpsmith> the default path is only the current directory
18:55:20 <rzezeski> I justed cd'd, all good now, thx guys
18:55:51 <mmorrow> rzezeski: are all the modules layed out in the sub-directory tree below your pwd like they would be in Dot.Foo.Bar in an import declaration?
18:55:54 <mmorrow> cool :)
18:56:05 <no_nickname> silly paths :D
18:56:25 <Cale> Reiver: okay, so you're changing the type Memory
18:56:33 <Reiver> Cale: Apparently, yes.
18:56:41 <Cale> Reiver: from  Ide -> MemVal  to  ([Ide], Ide -> MemVal)
18:56:48 <Reiver> As far as I can make out, I want the string to basically keep track of everything that's happened in memory so far?
18:57:02 <Cale> Reiver: Where the list in each case represents the identifiers which have been set.
18:57:14 <Reiver> Okay.
18:57:22 <BMeph> That looks like State.
18:57:41 <BMeph> I still want a "Monad State" sweat-shirt. :)
18:57:42 <Cale> There's no monad usage here :)
18:57:56 <Reiver> What's it mean by 'Identifiers which have been set', and where would one start with such things?
18:58:26 <Cale> Reiver: Well, in your programs, you have things like Assign "sum" Zero, yeah?
18:58:45 <Reiver> Cale: Aye
18:59:11 <Cale> This presumably sets the identifier "sum" to be the value Zero
18:59:27 <Cale> (when it is executed)
18:59:45 <Reiver> Right.
19:00:51 <Cale> cmd_semantics (Assign ident exp) s =
19:00:51 <Cale>    case (exp_semantics exp s) of
19:00:51 <Cale>    OK v1 (m1, i1, o1) -> OKc (update m1 ident v1, i1, o1)
19:00:51 <Cale>    Error a -> Errorc a
19:01:08 <Cale> (btw, I would indent the lines after 'case' by another couple spaces)
19:01:23 <Cale> So here's where that happens.
19:02:16 <Cale> You evaluate/execute the second parameter to Assign, and then continue by updating the resulting memory function m1 with the new binding.
19:02:49 <Cale> update m ide val =
19:02:49 <Cale>        \ide2 -> if ide == ide2 then Stored val else m ide2
19:03:21 <Cale> and that function is what does it
19:03:30 <Cale> So update is the main thing which will have to change.
19:04:02 <Cale> The other thing which hasn't been so nicely abstracted is how lookups are done on memories.
19:04:20 <Cale> Presently, since they're just functions, function application has been used
19:04:36 * Reiver ponders.
19:04:53 <Reiver> Would abstracting the lookups make altering the memory code more straightforward?
19:05:00 <Cale> yes
19:05:29 <Reiver> Right. It made sense in my head, but I thought I'd check just in case. :) Go on.
19:06:01 <Cale> So maybe do that first, using the initial implementation:  get m ide = m ide
19:06:26 <Cale> get :: Memory -> Ide -> MemVal
19:06:54 <Cale> update :: Memory -> Ide -> MemVal -> Memory
19:07:14 <aavogt> how do I get a blocking read of a fifo named pipe in haskell?
19:07:56 <aavogt> readFile gets me [], while hGetChar (and others) fail with 'end of file'
19:09:00 <Reiver> Cale: So that's... letting me use the functions get and update to call memory and store memory as opposed to the current setup which is... er, *doublechecks*
19:09:21 <Reiver> It's just referred to directly as a variable, isn't it.
19:09:26 <Reiver> (At the moment, I mean.)
19:09:50 <aavogt> @index forever
19:09:50 <lambdabot> bzzt
19:09:55 <aavogt> @hoogle forever
19:09:56 <lambdabot> Control.Monad forever :: Monad m => m a -> m ()
19:11:25 <roconnor> such a terrible type.
19:12:28 <hzap> terrible type?
19:12:45 <aavogt> the a is discarded?
19:12:49 <copumpkin> it's not that anymore is it?
19:13:01 <copumpkin> forever :: (Monad m) => m a -> m b
19:13:03 <copumpkin> on 6.10
19:13:40 <roconnor> :)
19:13:52 <hzap> didn't notice that :D
19:14:02 <Reiver> I'm a little puzzled as to what get would do, though. You pass it m ide and it returns... m ide? This puzzles me in terms of how it helps.
19:14:30 <aavogt> won't that result in some ambiguous types? Is that to make people specify main :: IO ()?
19:15:08 <aavogt> > forever (+1)
19:15:09 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> b)
19:15:09 <lambdabot>    arising from a use of `...
19:15:21 <aavogt> @type forever (+1)
19:15:22 <lambdabot> forall a b. (Num a) => a -> b
19:15:31 <aavogt> > forever (+1) 0
19:15:36 <lambdabot>   mueval-core: Prelude.read: no parse
19:15:36 <lambdabot>  mueval: ExitFailure 1
19:15:46 <aavogt> > forever (+1) 0 > (100 :: Nat)
19:15:47 <roconnor> > forever (fail "Monad fail!") :: Either String (Mu Maybe)
19:15:48 <lambdabot>   Not in scope: type constructor or class `Nat'
19:15:48 <lambdabot>   No instance for (GHC.Show.Show (L.Mu Data.Maybe.Maybe))
19:15:48 <lambdabot>    arising from a u...
19:16:05 <aavogt> > forever (+1) 0 > (100 :: Natural)
19:16:09 <roconnor> > forever (fail "Monad fail!") :: Either String Natural
19:16:10 <lambdabot>   mueval-core: Prelude.read: no parse
19:16:11 <lambdabot>  mueval: ExitFailure 1
19:16:11 <lambdabot>   Left "Monad fail!"
19:16:45 <aavogt> @src forever
19:16:45 <lambdabot> Source not found. Maybe if you used more than just two fingers...
19:17:12 <hzap> i don't think you have to main :: IO () even when the last thing is forever
19:17:27 <aavogt> roconnor: please explain forever
19:18:03 <monochrom> diamond is forever
19:18:50 <hzap> forever x = x >> forever x       (probably)
19:19:13 <monochrom> More seriously, if you have a monadic action "x :: MyMonad ()", then "forever x" means do x and repeat. Precisely like what hzap says.
19:19:22 <jimmyjazz14> what does an error like the following generally mean? Occurs check: cannot construct the infinite type: a = [a]
19:19:23 <monochrom> (We even chose the same variable x!)
19:19:33 <hzap> lol
19:19:47 <aavogt> diamond is metastable
19:19:50 <Cale> Reiver: Because very shortly it's not going to do just that anymore
19:19:53 <hzap> i was considering using "action" or "m" or something but "x" seems good enough
19:19:58 <Cale> Reiver: because the type of m is about to change
19:20:42 <Cale> jimmyjazz14: It usually means that you tried to use something as both a list and an element of that type of list
19:20:47 <georgehorse> jimmyjazz14: somewhere you mixed up some type, and a list of that type.
19:20:48 <monochrom> It generally means something in your code should have type 'a' according to one perspective but also '[a]' according to another. For example x = head x.
19:21:20 <hzap> i hate that error message
19:21:28 <aavogt> > forever "ab"
19:21:28 <georgehorse> The `infinite' part comes when it tries to solve the equation a = [a], the solution being that a is a list of lists of lists of lists of lists of list of...
19:21:29 <kynky> graphite is the stable form of crbon, diamond is unstable, creaed from high heat and pressure, experiment to prove this is done when diamond is subjected to drastic changs in heat
19:21:29 <lambdabot>   * Exception: stack overflow
19:21:32 <jimmyjazz14> Cale: ah thanks I suspected it was something along those lines, now just to figure out where I went wrong
19:21:44 <monochrom> It doesn't outright say "you are a moron" because someone is leaving room for a future extension, i.e., one day we may actually allow it.
19:21:59 <Cale> (but I doubt it :)
19:22:14 <Cale> Infinite types are *usually* bugs
19:22:36 <Cale> and the cases where they're not can be handled by defining recursive newtypes
19:22:59 <monochrom> Yes, one day when we decide that we no longer need "successful compilation means no bugs".
19:23:27 <aavogt> > Nothing `forever`
19:23:28 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
19:23:35 <aavogt> > forever Nothing
19:23:36 <lambdabot>   Nothing
19:23:45 <aavogt> > forever (Just 1)
19:23:50 <lambdabot>   mueval-core: Prelude.read: no parse
19:23:50 <lambdabot>  mueval: ExitFailure 1
19:23:57 <hzap> > take 20 $ forever [1]
19:23:58 <lambdabot>   * Exception: stack overflow
19:24:02 <araujo> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6158#a6158
19:24:18 <araujo> does that look like a stack based perlish lang? :P
19:25:15 <monochrom> All type errors are because people can't make up their minds.
19:25:43 <aavogt> so only if >> can produce a result without evaluating its second argument, will forever terminate?
19:25:52 <hzap> except when people made their mind.
19:26:57 <Saizan> aavogt: at least some part of the result without evaluating all of its second argument
19:27:06 <Reiver> Cale: Oh, I see. Okay. (Sorry, got called away for a moment there.)
19:27:18 <Saizan> well, not really terminate, but be useful
19:27:25 <Reiver> Go on?
19:27:29 <Saizan> ?type execWriter
19:27:31 <lambdabot> forall w a. Writer w a -> w
19:27:42 <Saizan> > execWriter $ forever (tell [1])
19:27:43 <Reiver> (Sorry, I'm trying to understand what's being done as I'm told about it. :) )
19:27:44 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
19:28:47 <aavogt> Saizan: thanks!
19:33:32 <soupdragon> araujo: is that program concurrent?
19:35:42 <hzap> is there something in the standard library that will convert a monadic value to the same value in its corresponding monad transformer?
19:38:35 * Reiver frowns.
19:38:48 <Reiver> Hey, Cale - the types you gave for update and get throw errors.
19:39:42 <monochrom> No.
19:39:43 <Cale> Reiver: Perhaps, if you've changed other things.
19:39:56 <Reiver> hrm
19:39:59 * Reiver doublechecks
19:40:04 <aavogt> hzap: I don't think so, but perhaps the apropriate runMonad, and put, you can transplant such values
19:40:14 <Cale> Well, I could have made a mistake anyway.
19:40:31 <Reiver> Were they for the code as written then, or what I was aiming for as a final result?
19:40:39 <araujo> soupdragon, yeah, no variables involved
19:40:57 <soupdragon> cool
19:41:10 <soupdragon> did you design this language?
19:41:20 <araujo> soupdragon, yeah
19:41:23 <soupdragon> any docs?
19:41:28 <araujo> soupdragon, i am designing it and developing
19:41:36 <araujo> soupdragon, not yet, i hope to get something uploaded soon
19:41:38 <soupdragon> :(
19:41:44 <araujo> hah
19:41:53 * araujo will get something up soon :)
19:41:55 <aavogt> @type partition
19:41:56 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
19:42:18 * araujo will post on his blog when something is up
19:42:28 <soupdragon> what is the URL?
19:42:47 <araujo> soupdragon, araujoluis.blogspot.com , but it is added to haskell planet
19:42:50 <araujo> if you read it
19:43:00 <soupdragon> thanks
19:43:06 <araujo> so, i will spam the haskell community with it
19:43:07 <araujo> :P
19:43:15 <aavogt> > let qsort = uncurry (++) . (qsort *** qsort) . partition (<) in qsort "oienzxclb;yulwfp;ulars"
19:43:16 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
19:43:51 <aavogt> hmm, getting the head is not going to be easy pointfree
19:43:56 <Cale> Reiver: The types should not have to change, but the implementations will
19:44:12 <Reiver> hmm, okay.
19:44:14 * Reiver has a go.
19:44:30 <araujo> aavogt, haha that's where the trick is in my code
19:44:47 <araujo> aavogt, i kind of had a hard time to get the head and moving it around ... with only basic primitives
19:44:48 <Reiver> So what I need is for update to take the old ide, and ide:[ide] it to its buddies, before progressing onwards, yes?
19:45:52 <aavogt> @hoogle partitionM
19:45:52 <lambdabot> No results found
19:46:04 <aavogt> @hoogle filterM
19:46:04 <lambdabot> Control.Monad filterM :: Monad m => (a -> m Bool) -> [a] -> m [a]
19:47:24 <hzap> how do you make those messages like * Reiver has a go."? (me == IRC newbie)
19:47:37 <aavogt>  /me
19:47:40 <georgehorse>  /me
19:47:48 * hzap just testing
19:47:49 <hzap> ok
19:47:50 * aavogt said /me first
19:47:50 <hzap> thanks
19:48:11 <monochrom> You losers need a spacing before /me. Get this:
19:48:13 <monochrom> /me
19:48:28 <aavogt> \/me?
19:48:37 <aavogt> :(
19:48:50 <Reiver> Xchat. :)
19:48:50 <georgehorse> /me
19:48:55 <soupdragon> /you
19:48:59 <georgehorse> yay nonprinting characters
19:49:25 <Reiver> heh, I can do it without even a nonprinting character. I just hold ctrl+enter.
19:49:26 <monochrom> /say may work for you.
19:49:32 <Cale> Reiver: it needs to make sure that if the identifier isn't already in the list, it is there after the update
19:49:32 <Reiver> (IIRC, anyway... been a while...)
19:49:35 <aavogt> > "/me"
19:49:36 <lambdabot>   "/me"
19:49:49 <aavogt> > putStr "/me"
19:49:49 <Reiver> Cale: Hmm. Hrn.
19:49:50 <lambdabot>   <IO ()>
19:49:58 <hzap> lol
19:50:04 <Reiver> What about if the identifier is the same as the old one?
19:50:16 <Cale> Reiver: by the way, this suggestion is really poor as far as efficiency is concerned, and using Data.Map would be both more efficient and result in prettier code, but an assignment is an assignment, I suppose :)
19:50:34 <Reiver> Cale: Exactly right. :)
19:50:36 <Cale> Reiver: You don't want the list to always group
19:50:38 <Cale> grow*
19:50:40 <Reiver> I'm learning a lot from it, if that helps...
19:50:55 <Reiver> Only if the new identifier is different to the old one?
19:51:25 <Cale> Reiver: Yeah, you only want to add it if it's not already there
19:51:47 <monochrom> We love to help people use way advanced techniques in their homework. We want their graders to get confused and give out 0s.
19:51:49 <Reiver> Right. So I can leave that if-then-else the same, and just screw with the 'else'
19:52:29 <hzap> monochrom: cool idea
19:52:48 <jimmyjazz14> If you think of monads as context (or as an onion) would it be fair to say that IO is almost always the outer context (or skin) of most programs?
19:53:03 <monochrom> Yes.
19:53:07 <hzap> and haskell is especially good at this stuff
19:53:07 <Reiver> ... actually, hum. Hum hum hum. *looks at the code again*
19:53:22 * monochrom hugs material implication
19:53:33 <jimmyjazz14> monochrom: was that yes to me?
19:53:37 <monochrom> Yes.
19:53:58 <jimmyjazz14> ah, perhaps I am starting to understand these monads!
19:55:47 <Reiver> Cale: Is update :: Memory -> Ide -> MemVal -> Memory
19:55:48 <Reiver> update ([ides], m) ide val =
19:55:48 <Reiver>        \ide2 -> if ide == ide2 then Stored val else (ide:ides, m ide2)
19:55:51 <Reiver> on the right track?
19:56:19 <Reiver> ... oops, that was meant to be a pastie. *stabs Opera, learn to copy an URL when I tell you to copy an URL. >.<
19:57:05 <Cale> Reiver: Well... the type is strange...
19:57:29 <Reiver> Cale: That would help explain all he errors I'm getting, certainly.
19:57:38 <Cale> Remember the type of update (ides, m) ide val is supposed to be Memory
19:58:10 <Cale> (and you certainly don't want to force ides to be the unique element of a list of length one)
19:58:18 <Cale> So what does that say about what should go on the right side of the = ?
19:58:27 <Cale> type Memory = ...
19:58:30 <Reiver> hrn
19:59:41 <Reiver> I'd changed Memory to be Memory = ([Ide],Ide) -> MemVal
19:59:52 <Reiver> That was wrong?
20:00:12 <Cale> That is wrong.
20:00:32 <Cale> Didn't the assignment tell you that it's supposed to be something different from that?
20:01:48 <Reiver> "So, change the code so that the memory is now a pair of type
20:01:48 <Reiver> ([Ide], Ide -> MemV al)
20:02:11 <Reiver> ...oh, wait. I see what I did there. Hrn.
20:02:59 <Reiver> O-kay then. Now to figure out how that affects the code below...
20:04:20 * Reiver grumbles, stabbities the code.
20:07:48 <Reiver> ... that's a fun error.
20:09:58 <Reiver> http://pastebin.com/d69ccf6c2 - error and current code
20:10:20 <Reiver> I am starting to get the feeling I'm digging myself into a hole instead of out of one. ;)
20:11:16 <Reiver> (The goal: http://pastebin.com/d7d5114ac )
20:11:34 <Cale> Reiver: right, since in the old code, memories were functions
20:11:42 <Cale> Reiver: In the new version, you have to use get
20:11:43 <Reiver> Okay
20:11:52 <Cale> But your get also needs to be updated
20:12:04 <Reiver> ... aha.
20:12:09 <Cale> I gave you the get for the old version so that you could make the old code use it before changing the type
20:12:20 <Cale> But either way is fine :)
20:12:48 <Reiver> hm
20:13:44 <Reiver> If I use the new version, how do I use get to, uh, get the results?
20:14:25 <Cale> Well, before if you had  m "x", you'll now have  get m "x"
20:15:24 * monochrom hates those cute metaphors and analogies but is great at creating them. Here is one: if you seem to be digging yourself into a hole, go on, you will come out at the other end of the Earth.
20:15:28 <Reiver> Oh, that's all? Okay then.
20:15:43 <Reiver> What would the new get be like, anyway?
20:16:02 * Reiver suspects he's Utterly Broken his Update command; he's yet to get far enough down the code to see what error it gives. :p
20:16:50 <Cale> Reiver: well, now the memory is a pair consisting of a list of identifiers and a function mapping the identifiers to values
20:17:00 <Cale> get (ides, m) ide = ...
20:17:17 <Cale> So to look up the identifier ide, we apply m to it.
20:17:22 <Cale> get (ides, m) ide = m ide
20:17:45 <Reiver> Ah! Hm.
20:18:03 <Reiver> And I'd call it via, say, show (get m "x")
20:18:14 <Reiver> ... no wait, those parenthesis are wrong aren't they
20:19:20 <soupdragon> monochrom: I'm sick of "reinventing the wheel"
20:19:26 <soupdragon> people say this soo much
20:20:34 <Cale> Reiver: No, that seems sensible :)
20:20:50 <Reiver> hm, then let me work out what the /other/ error is ;)
20:21:52 <SamB> soupdragon: how about "reimplementing the wheel"?
20:21:59 <Reiver> Oh, heee - I put it on Show get o, when o has no need for it. Dur.
20:22:16 <soupdragon> SamB: I don't heard that as much but I guess iit sucks too
20:23:32 <Reiver> Cale: You mind if I pm you a couple lines to look at? I dislike spamming the channel, and pastie has mysteriously stopped working for me as of thirty seconds ago.
20:23:47 <Cale> go right ahead
20:26:41 <gwern> soupdragon: well, if we created any other idiom for that, that'd be reinventing the wheel.
20:32:03 <m3ga> whats the difference between the (hackage packages) 'transformers' and 'mtl'? is there any reason for two monad transformer libraries?
20:33:37 <Pseudonym> m3ga: mtl is the first and most used.
20:33:42 <Cale> According to the description, the transformers package is just the Haskell-98 compatible part.
20:34:02 <Pseudonym> Others are better in various respects, but none have emerged as a common replacement.
20:34:11 <m3ga> ok, so why would something like 'yi' use transformers instead of mtl?
20:34:25 <Pseudonym> Probably for the reason Cale says.
20:35:11 <m3ga> ok
20:35:27 <m3ga> thanks
21:13:59 <Reiver> http://pastebin.com/d4fb6f502 - I've gotten things mixed up, I think. Typing is both wonderful and frustrating, sometimes >.>
21:16:41 <Reiver> ... huh. I wonder if it was knock-off time in a timezone somewhere.
21:20:42 * Reiver waves experimentally.
21:21:00 * QtPlaty[HireMe] waves back.
21:21:26 <Reiver> Ah, there /is/ life, good to know ;)
21:21:36 * Reiver is wrestling with Types, and wondering what he's done wrong.
21:22:01 <QtPlaty[HireMe]> Making a statement that is to broad.
21:22:04 <QtPlaty[HireMe]> ?
21:22:13 <Reiver> http://pastebin.com/d4fb6f502 - I've gotten things mixed up, I think. Typing is both wonderful and frustrating, sometimes >.>
21:22:34 * SamB_XP grogs back to Reiver 
21:25:31 <QtPlaty[HireMe]> get takes a single argument that is a string.
21:26:58 <QtPlaty[HireMe]> Or the other way around.  Does your error have a line number?
21:27:49 <Reiver> Bottom yellow in that example
21:27:56 <Reiver> Er, sec
21:28:22 <Reiver> 120
21:30:23 <QtPlaty[HireMe]> Ok you have two problems there.  You need to stick brackets around your m:ms
21:30:55 <Reiver> ...oh, that might help yes
21:31:41 <QtPlaty[HireMe]> But that will not help much as Memory takes a function as an argument not a list.
21:32:05 <QtPlaty[HireMe]> This also looks like a job for a state monad.
21:33:02 <Elly> that sounds like a superhero
21:33:12 <Elly> "This looks like a job for... Captain State Monad!"
21:50:02 <mgsloan> lol
21:53:40 <habitue> Hey I have a beginner question about writing a monad instance declaration, my code is at http://gist.github.com/134366
21:54:05 <habitue> basically, I can't automatically derive Monad because the type is a little bit complicated
21:54:59 <habitue> I want to end up with a CommandLineT transformer, but I'm not sure what the >>= function should look like
22:19:31 <aavogt> > return 1 >>= (+) =<< return 1
22:19:32 <lambdabot>   Precedence parsing error
22:19:32 <lambdabot>      cannot mix `GHC.Base.>>=' [infixl 1] and `Con...
22:20:13 <aavogt> habitue: I'm not sure that such a type can be a monad
22:20:27 <aavogt> what happens to the state when somebody does:
22:20:41 <aavogt> happystate >>= return undefined
22:20:57 <aavogt> happystate >>= return . const undefined
22:21:33 <aavogt> how will the types be made to match up with the state?
22:24:04 <aavogt> In general, you may be able to get around it with existentially quantified type for the state (or a monomorphic state), not using a monad...
22:31:14 * jmcarthur gives in and starts a rewrite of Hammurabi
22:31:49 <jmcarthur> i tried typing up a comment explaining what could be done to improve it, but such things never really get the point across...
22:41:29 <roconnor> > 166 `mod` 4
22:41:30 <lambdabot>   2
23:04:53 <Reiver> ... what on earth does unification would give infinite type
23:04:57 <Reiver> mean?
23:05:37 <Twey> It means you've got an infinite type loop
23:06:20 <Twey> Like f x = (f x, f x)
23:06:31 <Reiver> Wow, that's... clever of me.
23:07:01 <Twey> Try to define a type for that.  I dare you.  :-P
23:07:14 * Reiver eyes his code.
23:09:27 <Cale> > let f [] = []; f (x:xs) = xs:x:xs in f
23:09:28 <lambdabot>   Occurs check: cannot construct the infinite type: t = [t]
23:09:35 <Cale> There's another example
23:09:43 <Reiver> Guards are easy. Concatination is easy.
23:09:57 <Reiver> How the heck is concatenation via guards breaking? O.o
23:12:35 <Reiver> http://pastebin.com/d66a6848 - I'm baffled how I'm getting this wrong. Today really isn't being my day... I blame having to code databases all morning. >.>
23:12:45 <soupdragon> coding databases is fun!
23:12:53 <soupdragon> :t any
23:12:55 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
23:13:25 <soupdragon> I think you should replace [ls] with ls
23:14:38 <Reiver> Heh, oh the stories to tell for that one... We had 90min lectures all semester. One entire lecture was dedicated to types (Which we've dealt with before, but only in "Here is 3NF make sure you use it" style). 20mins each to 1NF, 2NF and 3NF, and detailing the nuances and differences between them. 5 mins each on 4NF, 5NF and BCNF, in the 'brief overview, and a note these don't come up much' style of teaching.
23:15:02 <cjs> Ouch.
23:15:33 <Reiver> Oh, it was okay. Actually somewhat useful; it came up a lot in our assignments and stuff.
23:16:03 <Reiver> Being able to go step-by-step through 1-3NF helped catch some errors you'd otherwise miss, and the like.
23:16:15 <Reiver> So! What did the exam question request? "Describe 4NF, 5NF and BCNF. Give examples."
23:17:03 <Reiver> >.<
23:17:23 <soupdragon> lol
23:17:27 <soupdragon> but you didn't cover 0NF
23:17:31 <Reiver> Yes folks, this was the only question on Normal Forms in the exam. We'd not dealt with them in the entire course but for the 5-mins-on-each. But apparently we were expected to not only know them, but know them inside out /and to the exclusion of the ones we'd actually used/.
23:17:59 <soupdragon> obviously the people that passed the exams are the ones that really love NFs and studied it beyond the minimum
23:18:31 <Reiver> Well, I'd be happy enough if they demanded all six, or the like.
23:19:24 <Reiver> But to completely ignore the most importaint three (And there is actually a fair bit to knowing them right - how often do you get asked to give an example of a table in 1NF or 2NF /and not 3NF/?), and give out marks only for the obscure stuff got on my nerves a bit.
23:20:30 <erikc> they forgot to teach you the legendary 6NF
23:21:01 <ClaudiusMaximus> my "iterate (\l -> nubBy e $ liftM2 o l l) gs" code, while it 'works', is really far too slow to be useable :(  any better algorithms for this kind of stuff?
23:21:01 <Reiver> She forgot to teach us /any/ of the >3NFs, then tested 10% of our exam grade on them, to the exclusion of the others.
23:21:50 * Reiver mumbles. Oh, and Question 1 (Worth 10%) took an hour to do, because it was a UML diagram, by hand, in pen, on over fifty attributes and 9 tables.
23:22:01 <Reiver> This was a 3 hour exam. Yeah...
23:22:13 <Reiver> And now I can't even do simple Haskell. ;)
23:23:39 <ClaudiusMaximus> context: i have some elements of a group (gs), and the group operation (o), and equality on group elements (e), and want to find all elements of the group
23:26:02 <Cale> ClaudiusMaximus: I think at that level of generality, you're doing the best you can with iterate and nubBy... If you knew a little bit more about the group, then perhaps. :)
23:26:59 <ClaudiusMaximus> ok - i know quite a lot more (they're finite reflection groups)
23:30:26 * Reiver stares.
23:30:30 <Reiver> Oh for geez
23:31:18 <Cale> hmm...
23:31:34 <Cale> Are the gs necessarily the reflections which generate the group/
23:31:35 <Cale> ?
23:31:38 <ClaudiusMaximus> yes
23:33:05 <ClaudiusMaximus> i think i can hack together some ugly code that avoids duplicating so much work, but the shortness of the nubBy/liftM2 is appealing
23:35:12 * Reiver eyes.
23:35:32 <Reiver> I've got no less than three guards written in prior assignments without any of these type issues.
23:35:59 <Reiver> Clearly the Functional Programming exam yesterday drained all my Haskell-fu when I sat it
23:36:16 <soupdragon> you can get extra haskell foo
23:36:55 <Reiver> Oh?
23:39:11 <Zao> One free refill with every type clash.
23:39:58 <Reiver> If that were the case, I'd be the freakin' saudi arabia of functional programming by now.
23:41:12 <Reiver> soupdragon: Er. /Which/ [ls] needed replacing with ls?
23:45:47 <Reiver> http://pastebin.com/d6de9a1b5 - I've never seen *that* error before, either.
23:46:20 <soupdragon> Reiver: all of them
23:46:46 <Reiver> soupdragon: I tried that, gave an error too
23:46:59 <Reiver> ^ That one, in fact. :)
23:47:19 <soupdragon> weird
23:47:35 <soupdragon> :t let listadd l ls | any (l==) ls  = ls | otherwise     = (l:ls) in listadd
23:47:36 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
23:47:43 <soupdragon> so what's missing is the Eq bit
23:47:57 <Reiver> What's an Eq and why do I need it?
23:47:58 <soupdragon> but you know if you jstu don't write the type annotation at all then the type inference does it for you
23:48:05 <soupdragon> :t (==)
23:48:07 <lambdabot> forall a. (Eq a) => a -> a -> Bool
23:48:08 <soupdragon> that's why
23:48:13 <soupdragon> for example
23:48:15 <Axman6> @src Eq
23:48:16 <soupdragon> > 3 == 5
23:48:16 <lambdabot> class  Eq a  where
23:48:16 <lambdabot>     (==), (/=)   :: a -> a -> Bool
23:48:17 <lambdabot>   False
23:48:19 <soupdragon> > id == (\x -> x)
23:48:21 <lambdabot>   No instance for (GHC.Classes.Eq (a -> a))
23:48:21 <lambdabot>    arising from a use of `GHC.Cla...
23:48:28 <soupdragon> so numbers have Eq but functions don't
23:48:30 <Axman6> Reiver: Eq is the class that defines == and /=
23:49:12 <Reiver> ... Ah-hah.
23:49:26 <Reiver> Could I rewrite the code to not use ==, or?
23:49:59 <Axman6> well, how would you check if i was in is if you can't check for equality?
23:50:03 <soupdragon> just delet the type signature
23:51:08 <Axman6> :t elem
23:51:10 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
23:51:19 <Axman6> @src elem
23:51:20 <lambdabot> elem x    =  any (== x)
23:52:39 <Axman6> Reiver: might want to use elem
23:53:26 <dibblego> Reiver, Eq is a type-class and it is used to constrain the type parameters to only those types which are members of that type-class
23:53:37 <Reiver> hm
23:56:09 <Axman6> @src Maybe Eq
23:56:10 <lambdabot> Source not found. It can only be attributed to human error.
23:56:12 <Axman6> :(
23:56:33 <Reiver> Ha!
23:56:40 <dibblego> (Eq a) => Maybe a
23:56:47 <Axman6> @src Eq Maybe
23:56:47 <lambdabot> Source not found. That's something I cannot allow to happen.
23:56:54 <Axman6> bleh
23:56:55 <dibblego> Maybe is a type-constructor
23:56:59 <Reiver> So I replace the any (== l) with elem... and get back to an infinite type error.
23:57:02 * Reiver laughs.
23:57:19 <Axman6> you replace the all (==1) with elem l
23:57:25 <Axman6> uh, l, not 1
23:57:28 <dibblego> Reiver, aren't you glad you're stopped from making mistakes ;)
23:57:35 <Axman6> @src elem
23:57:36 <lambdabot> elem x    =  any (== x)
23:57:49 <Axman6> see how that's the same as your all (l==)?
23:57:54 <Axman6> um, any
