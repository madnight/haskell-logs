00:13:28 <Axman6> > let p ? (y,n) = if p then y else n in even 4 ? ("Yep","Nope")
00:13:30 <lambdabot>   "Yep"
00:14:33 <Axman6> that's defined in the LLVM package i think
00:17:38 <Cale> jimmyjazz14: At first if you don't know what the error messages mean, make use of the fact that you're given a line number, so you can start by looking at the code around that point. Also, if all else fails, we can help :)
00:18:32 <jimmyjazz14> Cale: Thanks, the channel has been extremly helpful in my learning experience
00:18:34 <Cale> jimmyjazz14: Also, you might already know this, but whitespace is much easier to get right if you make sure that your editor converts all tabs to spaces. (Most editors have such a feature)
00:19:25 <Axman6> jimmyjazz14: i never found hugs errors all that much more useful
00:19:43 <Cale> After that, the rule is basically that things which are logically at the same level should start in the same column -- note that while we might call this indentation, the actual amount of whitespace on the left edge is not as important as which character starts the block.
00:20:16 <Cale> Well, things at the same level start in the same column, and things which are part of something else start in a deeper column.
00:20:26 <Fragsworth> Is there a nice shell for haskell similar to ipython for Python? (with tab completion, etc.)
00:20:40 <Axman6> ghci?
00:20:47 <Axman6> it has tab completion
00:20:58 <Axman6> works a lot like this...
00:21:06 <Cale> The actual rule is more forgiving than that, but if you follow this idea, you should always get something correct.
00:21:15 <Axman6> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs
00:21:17 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
00:21:24 <Twey> @let (y ?? n) p = if p then y else n
00:21:25 <lambdabot>  Defined.
00:22:09 <Twey> > fmap ("yes" ?? "no") $ Maybe True
00:22:10 <lambdabot>   Not in scope: data constructor `Maybe'
00:22:14 <Twey> Er
00:22:17 <Twey> > fmap ("yes" ?? "no") $ Just True
00:22:19 <lambdabot>   Just "yes"
00:22:28 * Twey dies.
00:22:47 <Axman6> quite OT, but this is realy cool, and probably quite important for out future energy needs: http://www.youtube.com/watch?v=GbLRKN3srUs&feature=sdig&et=1244305777.78
00:22:51 <Axman6> really*
00:22:54 <Twey> I've been at this for a year and a half now and I still mix up data and type constructors
00:23:02 <Cale> jimmyjazz14: For example, even though it's not strictly required to do so, applying this rule to if/then/else dictates that since the 'then' and 'else' are siblings, they should start in the same column, and since they're both part of the 'if', they should start in a column which is deeper than it.
00:23:11 <Cale> jimmyjazz14: So you get things which look like:
00:23:13 <Cale> if foo
00:23:15 <Cale>    then bar
00:23:19 <Cale>    else quux
00:23:21 <Cale> Or:
00:23:25 <Cale> if foo then bar
00:23:29 <Cale>        else quux
00:23:44 <Cale> jimmyjazz14: Make sense? :)
00:27:54 <jimmyjazz14> Cale: yeah
00:29:36 <jimmyjazz14> I'm using haskell-mode in emacs which seems to sometimes get indentation a little wrong sometimes
00:30:19 <jimmyjazz14> auto indenting a block of haskell code is not pretty in emacs
00:32:24 <Tarrant> jimmyjazz14: Its nto that much better in vim.
00:37:54 <juhp_> anyone working on bindings to webkit?
00:38:41 * Axman6 isn't sure what haskell webkit bindings would do, but would like to know
00:39:51 <Tarrant> Build the interface for a browser in haskell?
00:42:56 <Axman6> seems you'd need more than webkit bindings for that though. i guess the webkit-gtk stuff is the best place to start
00:43:42 <Cale> jimmyjazz14: Oh, yeah, it can be annoying. I ended up using the simple-indent mode.
00:43:57 <Cale> (though I use vim a lot more myself)
00:44:24 <Tarrant> How is Yi's indenting?
00:57:09 <ksf> Tarrant, it's better.
00:58:07 <ksf> juhp_, I quickly looked into it, and we should have a TK, first.
00:58:28 <ksf> ...or generally, rendering layer.
00:59:16 <juhp_> Tarrant: yeah that would be the idea or at least allow embedding webkit into gtk apps say
00:59:24 <ksf> I couldn't find any xml descriptions to use to generate bindings to webkit-gtk, either.
00:59:38 <ksf> there's mozembed
00:59:43 <juhp_> ksf: toolkit?
00:59:49 <ksf> yes
00:59:49 <juhp_> ksf: it segfaults for me
01:00:03 <ksf> well, but we _do_ have it :)
01:00:18 <juhp_> true
01:00:38 <juhp_> also webkit is fast
01:21:34 <kuribas> jimmyjazz14: Use my haskell indentation mode.
01:22:07 <kuribas> http://kuribas.hcoop.net/haskell-indentation.el
01:26:15 <ivanm> kuribas: is it possible to have all the fancy C-c C-= keybindings work with your indentation mode?
01:27:44 <kuribas> ivanm: What does that do again?
01:28:17 <ivanm> inserts and = sign, and lines up all the = signs above it in the same function (for pattern matching, etc.)
01:29:08 <kuribas> It doesn't do it now, but I guess it should be possible.
01:30:14 <ivanm> it seems to be in haskell-indent.el rather than haskell-mode.el :s
01:33:26 <kuribas> yes
01:35:47 <performance> has any one installed Leksah lately? [ with ghc 6.10.3 ? ]
01:37:07 <Ycros> yep
01:37:15 <kuribas> ivanm: I'll put it on my TODO list.
01:37:28 <ivanm> thanks kuribas
01:38:02 <ivanm> on another note, your documentation at the beginning of the .el file is wrong: it says to use 'turn-on-haskell-indenting or something, which doesn't exist :s
01:38:22 <Ycros> performance: are you having issues installing it?
01:38:25 <kuribas> oh
01:38:50 <performance> yarcos, not yet, but thehome page has special instructions for 6.10.2
01:39:11 <Ycros> yes, they work for 6.10.3
01:39:20 <performance> ok. thanks
01:39:38 <performance> so just have to get gtk2hs from source, and the rest of it is through cabal right?
01:39:59 <Ycros> performance: yep
01:40:20 <performance> thanks :)
01:41:01 <performance> and if getting for the first time, shouldn't  darcs get is to be used isntead of darcs get --partial
01:41:03 <performance> ?
01:42:37 <dmwit> performance: Depends on whether you care about the history or about how long it takes.
01:42:48 <dmwit> --partial is fast(er), but doesn't grab the whole history
01:43:30 <Ycros> performance: dunno, I didn't grab anything out of darcs
01:43:37 <ivanm> of course, for some repos, you _have_ to use --partial because there's some breakage somewhere if you try and get the whole thing... >_>
01:43:57 <ivanm> so should we start talking about the performance of GHC just to confuse/annoy performance? :p
01:47:23 <performance> ivanm, no
01:47:36 <ivanm> awwwwww
01:47:51 <performance> Ycros, what did you do? where did you get gtk2hs from then?
01:48:32 <mike-burns> http://haskell.org/gtk2hs/download/
01:48:40 <Ycros> performance: tarball
01:48:59 <Peaker> Who's the main man behind Haskell prime?
01:49:26 <performance> hmm any way it finished very fast, if run into issues, i'll get the tar ball too
01:49:57 <ivanm> Peaker: there's someone behind it? :o
01:50:37 <Peaker> ivanm: I donno
01:52:11 <Ycros> Peaker: maybe it created itself
02:01:28 <barbseven> can someone please help me i am new to java programming, and im using BuleJ to create a simple game, how would i go about adding some music to the game?
02:02:18 <joga> this may not be the right channel to ask that..
02:02:23 <barbseven> ????\
02:04:13 <dcoutts> barbseven: perhaps try asking in the #java channel
02:05:04 <Botje> sigh, the downside of being a biggish channel
02:06:42 <Twey> I don't get how people can join #haskell and think it's a Java channel
02:06:47 <ivanm> well, there was the case of someone (last year?) who googled programming help and thus found his way here, whom we half-way converted to haskellianism
02:06:58 <ivanm> he thought this was a general-purpose programming channel :/
02:07:12 <dmwit> I think it would be funny for ##java to send people here for help as a prank.
02:07:25 <Botje> "haskell? that can't be a real programming language!"
02:07:41 <ivanm> @slap dmwit
02:07:41 * lambdabot beats up dmwit
02:07:45 <ivanm> don't give them any ideas!
02:07:47 <Twey> Heh
02:07:52 <Twey> Don't give them ideas :-P
02:07:57 * Twey chuckles.
02:09:16 <dibblego> does Data.Array have a constant time length function?
02:10:06 <Beelsebob> interesting, we seem to have moved on - software engineers have stopped ignoring FP, and started ridiculing it
02:10:08 <dmwit> It should, yes.
02:10:17 <dmwit> dibblego: Are you asking what the function is, or whether it's constant-time?
02:10:18 <Beelsebob> now we only need to go through fighting it and us winning :)
02:10:28 <dibblego> dmwit, both
02:10:34 <dmwit> :t bounds
02:10:36 <lambdabot> forall i e. (Ix i) => Array i e -> (i, i)
02:10:40 <dibblego> ah thanks
02:10:45 <ivanm> Twey: well, yes, my statement can be taken two ways
02:10:52 <ivanm> s/taken/interpreted/
02:11:03 <Botje> Beelsebob++ for the gandhi reference
02:13:11 <deeflex> I have a list [a] where a is an instance of a data type (String,String,Float) with getters "from","to" "dst". I would like to calculate for each distinct "from", the sum of all "dst".
02:13:36 <dmwit> :t groupBy
02:13:37 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
02:13:41 <dmwit> :t sort
02:13:42 <lambdabot> forall a. (Ord a) => [a] -> [a]
02:13:44 <Botje> sort by comparing from, group by from, count then up
02:13:45 <dmwit> err...
02:13:47 <dmwit> :t sortBy
02:13:48 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
02:14:18 <dmwit> deeflex: Play around with those a bit. =)
02:16:16 <deeflex> This is my only (failed) attempt. groupBy (\x y -> from x == from y) [DistElement "a" "to1" 1.0, DistElement "b" "to2" 2.0, DistElement "a" "to3" 1.0]
02:17:14 <deeflex> but that results in three elements, not two as I want it.  :)
02:17:44 <Botje> yeah
02:17:49 <Botje> you need to sort by from first
02:18:18 <Botje> groupBy ((==) `on` from) . sortBy (compare `on` from)
02:18:27 <Botje> (on is in Data.Function)
02:18:39 <deeflex> ye I had problems with that one last night
02:18:43 <deeflex> 'on' that is
02:19:11 <deeflex> "can't find module Data.Function". So I need another way
02:19:18 <Botje> @src on
02:19:18 <lambdabot> (*) `on` f = \x y -> f x * f y
02:19:30 <Botje> or just write the lambdas yourself as you did for groupBy
02:22:53 <deeflex> Botje, ok, but how do I use the src for on. Do I create a new file and import it where I want to use it?
02:23:27 <Botje> for example
02:23:33 <Botje> or just include it when you need it
02:23:45 <Botje> it's just a prettier way of writing \x y -> foo x `compare` foo y
02:24:17 <mmorrow> import Data.Function (on)
02:24:22 <deeflex> ok
02:24:34 <mmorrow> import Data.Function -- or just this to get all of the module
02:24:48 <Botje> 11:19 < deeflex> "can't find module Data.Function". So I need another way
02:24:48 <ivanm> mmorrow: he says ghc[i] can't find Data.Function
02:24:57 <mmorrow> oh, what ghc version?
02:25:01 <mmorrow> (before 6.8?)
02:25:02 <deeflex> no Hugs
02:25:05 <mmorrow> oh
02:25:10 <Botje> brrr
02:25:10 <ivanm> ahhhh
02:25:28 <Twey> @src on
02:25:29 <lambdabot> (*) `on` f = \x y -> f x * f y
02:25:31 <mmorrow> you may have to define it then, i'm not sure where it is in hugs (if anywhere)
02:25:32 <Twey> Define that
02:25:37 <Twey> It's nowhere in Hugs
02:28:15 <ziman> i've already asked once but i'm quite curious about this; http://codepad.org/lTxA58kh should split a SQL dump into one-file-per-table parts (it's already a stripped down version); but it does not work in O(1) space and gradually eats all available memory. Does anybody see why?
02:30:11 <ziman> if I use Data.List.Split.split, the behavior is the same and if I use (const True) as the predicate (thus only one line per section), the program works in constant space
02:30:58 <ziman> but the memory doesn't free up between sections/files when there's this hasPrefix predicate
02:32:42 <performance> Ycros: did you get any error messages about gtksourview2 not beign found?
02:33:18 <ivanm> performance: you have to have gtksourceview (C-lib, not haskell) installed
02:33:44 <performance> hmm
02:33:48 <ivanm> and build gtk2hs with --enable-gnome
02:34:23 <deeflex> Botje, The ' . ' is the composition operator, right? What is the diff. in writing groupBy (..) . sortBy (...) [a] --- AND --- groupBy (...) (sortBy (...) [a]) . The latter works, while the first yields an error.
02:34:56 <ivanm> deeflex: you need a $ somewhere to tell hugs that you've stopped forming a function and want to apply it
02:35:06 <ivanm> e.g. groupBy (..) . sortBy (..) $ [a]
02:36:20 <deeflex> Ok thanks ivanm.
02:36:41 <deeflex> Well I prefer the latter anyway.. so
02:36:42 <deeflex> :)
02:36:52 <Botje> deeflex: yes, but it looks a bit silly
02:37:01 <ivanm> and doesn't scale as well
02:37:06 <Botje> if you have foo a = groupBy (....) (sortBy ... a)
02:37:23 * ivanm thinks groupSortBy should be defined in Data.List
02:38:07 <ivanm> as in groupSortBy f = groupBy ((==) `on` f) . sortBy (compare `on` f)
02:38:40 <performance> Ycros: i still get that error, i installed gtksoureview2 through my distro's package manager.
02:39:38 <performance> did you install gtk2hs in its default location?
02:40:06 <twb> Are the bytestring-mmap and mmap packages complementary, or competetive?
02:40:13 <twb> That is, do they do different things, or the same thing?
02:40:14 <ivanm> performance: where you install it doesn't really matter, as long as ghc knows where it is
02:41:00 <Cale> deeflex: The nice thing about something like f . g . h $ x is that apart from not requiring so many parens that have to be matched, it also makes clear lots of various ways of breaking the computation down into smaller parts: f . g,  g . h,  h $ x,  g . h $ x, and so on are all well-typed and meaningful here.
02:41:18 <dmwit> twb: They do different things, I think.
02:41:25 <dmwit> twb: bytestring-mmap does not allow updates
02:41:36 <dmwit> (i.e. it's read-only)
02:41:53 <twb> I see.
02:42:18 <Cale> deeflex: (.) is a nice associative operator, so expressions using it effectively have more subexpressions than they otherwise would :)
02:42:21 <performance> ivanm, in that case, how do i tell ghc where my --prefix for gtk2hs is when doing ghc --make Steup.lhs ?[ probably findable by hunting the man page..]
02:42:29 <deeflex> Cale, ok :>
02:42:32 <ivanm> hmmmm?
02:42:38 <ivanm> why are you using ghc --make ?
02:42:45 <mornfall> Well, bytestring-mmap is a subset of mmap.
02:43:31 <twb> OK, so I need both for hashed-storage.
02:43:40 <twb> I thought maybe cabal-debian was being a bit too inclusive
02:44:02 <mornfall> twb: Hm. I'll rip bytestring-mmap out then.
02:44:03 <Ycros> performance: did you rebuild gtk2hs after you installed gtksourceview2?
02:44:13 <performance> nope
02:44:18 <performance> thats what struck me just now
02:44:23 <mornfall> twb: The thing is I used bytestring-mmap in hashed-storage until it turned out that I need the more powerful API from mmap.
02:44:32 <mornfall> twb: But I didn't get around to converting all calls to mmap.
02:44:40 <performance> ivanm, to speed up instead of runhaskell everytime
02:44:42 <twb> mornfall: is it going to cause problems when Darcs uses bytestring-mmap?
02:44:51 <ivanm> performance: >_>
02:44:54 <mornfall> twb: Ah. Well, we should maybe switch darcs to mmap as well.
02:44:58 <twb> i.e. will they "fight"?
02:44:59 <twb> Nod.
02:45:02 <mornfall> No fighting.
02:45:08 <ivanm> I don't think that will make much of a difference...
02:45:18 <twb> I suggest making a task for that in the Darcs BTS.
02:45:32 <twb> Presumably even if they won't fight, using the same API for both will be less sucky.
02:45:37 <performance> it was given on the cabal README, so i just adopted it :)
02:45:56 <mornfall> twb: For darcs, the the advantage with mmap would be that it works on Win32, unlike bytestring-mmap.
02:45:56 <twb> mornfall: shall we move this discussion to #darcs?
02:46:40 <performance> ivanm: what is >_> ?
02:46:52 <ivanm> an emoticon ;-)
02:46:59 <performance> for...
02:47:44 <smorg> you mean O_o isn't a monad?
02:48:08 <performance> looks like a dont care got into a sequence operator :)
02:49:39 <ivanm> "disbelief, looking around shiftily [when alternating (>_>) and (<_<)]"
02:49:44 <ivanm> ^^ according to wikipedia
02:49:56 <kyevan> Compose is confusing...
02:50:02 <kyevan> I don't know WHY, but it is
02:51:19 <dmwit> You think composition is confusing... wait until you try to claw your way up the abstraction ladder through functors, natural transformations, adjoints, monads, universal elements, and the Yoneda lemma.
02:51:40 * dmwit made it to stage 3 of 6
02:51:57 <performance> kyevan: what is confusing about it?
02:52:09 <kyevan> I don't know.
02:52:13 <dmwit> hehe
02:52:20 <dmwit> kyevan: Composition glues together two functions.
02:52:22 <kyevan> It seems like it shold be simple but I somehow /can't quite get it/
02:52:27 <dmwit> The output of one becomes the input of the other.
02:52:29 <performance> :) well then it will go away
02:53:36 <performance> ugh.. i wanted to sleep early yesterday, to watch the FO finals today morning .. but im just installing and configuring my linux box now
02:53:41 <aleator> Hi all. I've got algorithms and datastructures to lecture. What is your favourite exotic algorithm/datastructure?
02:54:00 <performance> not exotic but redblack trees and tries :)
02:54:19 <dmwit> Composition takes a transformer, and a function that produces values that can act as inputs to the transformer, and applies the transformer to all the outputs of the function.
02:54:27 <dmwit> aleator: Skip lists are neat!
02:54:40 <performance> if it suits the theme..  BDDs are cool too
02:55:27 <kyevan> > map ((+) 1) [1, 2, 3, 4, 5]
02:55:28 <lambdabot>   [2,3,4,5,6]
02:55:43 <dmwit> > map (+1) [1, 2, 3, 4, 5]
02:55:45 <lambdabot>   [2,3,4,5,6]
02:55:57 <dmwit> Actually, a more literal translation is
02:55:57 <performance> oh as for algos, hashing is always top:) that way you can talk about the birthday paradox also and get your class excited
02:56:03 <dmwit> > map (1+) [1, 2, 3, 4, 5]
02:56:04 <lambdabot>   [2,3,4,5,6]
02:56:07 <kyevan> Og. You can do that? o.O
02:56:19 <kyevan> I didn't know you could partially apply operators as operators.
02:56:27 <dmwit> kyevan: Yep, it's special syntax for partial application of operators.
02:56:32 <aleator> Next lecturer already booked red-blacks, but skip lists and tries are neat.
02:56:38 <kyevan> Awesome ^_^
02:56:51 <dmwit> Oh, in the realm of hashing, cuckoo hashing is the tops!
02:57:21 <RayNbow> @google cuckoo hashing
02:57:22 <lambdabot> http://en.wikipedia.org/wiki/Cuckoo_hashing
02:57:22 <lambdabot> Title: Cuckoo hashing - Wikipedia, the free encyclopedia
02:58:06 <dmwit> If you get too many collisions... just start over with a new hash! O_o
02:58:29 <dmwit> And yet you get some beautiful theoretical run-time guarantees, and good performance in practice.
02:58:34 <aleator> RayNbow: I already have cuckoos. I love the condition "If you have infinite loop, reserve more space" :)
02:59:14 <dmwit> Let's see... what else did I get excited about in algorithms class?
02:59:16 <RayNbow> aleator: or kill more cuckoos :p
02:59:40 <dmwit> O(n) median was neat, but doesn't take too long to explain.
03:00:17 <dmwit> Are you doing sorts?
03:00:26 <dmwit> Radix sort is neat for people who haven't seen it.
03:00:42 <ivanm> bogosort! :p
03:00:50 <dmwit> It's fun to show it to people and then ask why the famous O(n * log n) bound on all sort algorithms doesn't apply. =)
03:01:03 <aleator> Sorts were in the previous course, incl. radix sort. People were getting drowsy after 5th sorting method :)
03:01:04 <performance> i found that merge sort is a hit with the class :)  easy to have the class do it while they learn
03:01:12 <ivanm> dmwit: radix sort requires some other criteria to be valid though, doesn't it?
03:01:19 <dmwit> ivanm: Yep.
03:01:28 <aleator> performance: I was forbidden to sort people according to size :P
03:01:37 <ivanm> aleator: heh
03:01:41 <dmwit> ivanm: The O(n * log n) bound only allows comparisons; radix sort does more than compare, and that accounts for the discrepancy.
03:01:46 <performance> no give them data, like name etc
03:01:47 <aleator> Damn this era of political correctness
03:02:19 <dmwit> Oh, there's always graph algorithms.
03:02:24 <aleator> I gave them numbers.. (And I was not allowed to use either one or zero there!)
03:02:26 <ivanm> aleator: why, is it discriminatory to say that one person is taller than another?
03:02:30 <dmwit> Kruskal's, Prim's, Djisktra's, A*, etc.
03:02:32 <RayNbow> @hoogle bogosort
03:02:32 <lambdabot> No results found
03:02:43 <RayNbow> wait, no one has made a bogosort yet? :p
03:03:19 <aleator> ivanm: Apparently there has been issues of height in basic school leading to traumatized uni-students...
03:03:28 <ivanm> aleator: :/
03:03:44 <kyevan> > [1..]
03:03:45 <ivanm> aleator: in _Finland_? or is your /whois info misleading me?
03:03:46 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
03:04:21 <aleator> Yeah. We actually have a lecturer that is forbidden by faculty council to talk about women, old people, or people of color during his lectures.
03:04:51 <ivanm> aleator: due to sexism, etc.?
03:04:55 <aleator> ivanm: There is just 1 hypersensitive student who raises a fuss, not general culture.
03:05:03 <ivanm> ahhh
03:05:20 <dmwit> What, he can't talk about old people?  Like Alonzo Church or Alan Turing? ;-)
03:05:22 <aleator> No, he said "this is easy for a white man" - an old saying and this resulted in the ban.
03:05:48 <ivanm> aleator: is it? never heard of it before...
03:05:52 <performance> Ycros: grrh, now it says:  Configuring leksah-0.4.4.1...
03:05:54 <performance> Setup.lhs: At least the following dependencies are missing:
03:05:55 <performance> glib >=0.10, gtk >=0.10, gtksourceview2 >=0.10.0
03:06:16 <dmwit> performance: Check whether those libraries are available with "ghc-pkg list".
03:06:28 <aleator> ivanm: a finnish thing. Not really racist, but from more incorrect times.
03:06:29 <dmwit> performance: I'll bet they're available, but only under user or so.
03:06:45 <ivanm> aleator: *nod*
03:07:03 <dmwit> performance: (There's global and user libraries.  When configuring, it defaults to global, and hence won't use user libraries, but cabal install defaults to user...)
03:07:48 <performance> ram:$ ghc-pkg list | grep glib
03:07:49 <performance> vector:/~/pax/ghc/leksah/leksah-0.4.4.1
03:07:54 <performance> no results
03:08:36 <Botje> ziman: have you tried changing mySplit to use take and drop?
03:08:38 <dmwit> Install it, then?
03:09:02 <dmwit> oh, wait
03:09:14 <dmwit> performance: Have you installed gtk2hs?
03:09:23 <performance> umm, how do i? its not a cabal package.  and my package manager says i already have gtk+ :D which obviously do
03:09:36 <dmwit> performance: There should be instructions on the gtk2hs website.
03:11:20 <ivanm> performance: this gtk+ is different from the gtk it's talking about
03:11:36 <performance> umm i cant find any instructions , just a list of deps
03:11:52 <dmwit> http://www.haskell.org/gtk2hs/download/
03:12:27 <dmwit> Grab a package if you happen to be on one of the systems that has one; otherwise grab the sources and build it.
03:13:21 <performance> hmm. yeah i will get the tar ball now. teh darcs get --partial did not work ; may be there is a change that i dont want.
03:13:32 <dmwit> did not work?
03:13:38 <dmwit> Didn't work how?
03:14:31 <dmwit> Gah, I have to go to bed.
03:14:48 <dmwit> But say what you did and exactly what errors you got as a result; people in here will help get you straightened out. =)
03:15:22 <performance> gtk2hs builds and installs fine, but Leksah does not :(
03:15:45 <dmwit> But you just said ghc-pkg list didn't show glib.
03:15:51 <dmwit> So obviously gtk2hs didn't install.
03:15:55 <dmwit> How did you install it?
03:16:20 <performance> when i try to configure Leksah it says it has un met deps . yeah  where does ghc-pkg look ?
03:16:34 <dmwit> ...how did you install gtk2hs?
03:16:48 <dmwit> Did you "runhaskell Setup.hs install" at any point? =P
03:16:57 <dmwit> Because that's the critical one.
03:17:51 <dmwit> uh... huh
03:17:59 <dmwit> Of course gtk2hs isn't cabalized.
03:18:04 <dmwit> So consider that a lie.
03:18:07 <performance> ughghggh.. shoot me :(. after installing gtksourceview2 i rebuilt gtk2hs but forgot to make install it
03:18:17 <dmwit> Nice. =)
03:18:41 <ivanm> heh
03:19:47 <performance> now Leksah error during runhaskell ./Setup.lhs build  src/IDE/Completion.hs:88:18:
03:19:48 <performance>     Not in scope: `sourceLanguageManagerGuessLanguage'
03:20:01 * dmwit really goes to bed this time
03:21:14 <MyCatVerbs> Sleep well.
03:21:16 <performance> hmm i should too, but i cant sleep well until i get closure on this thing.. [the english closure not the  lambda one ]
03:21:17 <Ycros> performance: how did you build the gtk2hs package?
03:21:23 <Ycros> performance: oh, nvm
03:21:46 <performance> nevermind? hmm ok
03:22:42 <performance> ram:$ ./configure --with-hc=`which ghc` --with-user-pkgconf --prefix=/home/ram/pax/gtk2hs
03:22:45 <performance> just in case
03:24:55 <performance> any way , thanks for the help folks, i'll get back to this after the final tomorrow
03:30:25 <performance> wonder how this compiled for others, grep for sourceLanguageManagerGuessLanguage shows all occurances are just uses, its not defined anywhere?
03:38:16 <performance> hmm well these are supposed to be part of gtk2hs, so something did not go right there
03:52:44 <Vq^> good day #Haskell
03:53:20 <Vq^> i had this idea of a fairly naïve numerical approximation framework
03:53:33 <ray> ieee floats?
03:53:47 <Vq^> Floating was my first thought
03:53:56 <Vq^> it's mostly a toy
03:54:11 <Vq^> and it only needs to find a local minimum in the error
03:54:20 <Vq^> runApprox (do {x <- scalar 0 100; y <- scalar (-50) 50; let z = constructValue x y; calcError z; return z})
03:54:49 <Vq^> the question is if it fits a monad
03:55:08 <Vq^> my idea was to determine x and y at calcError
03:56:03 <deeflex> Botje, still there? back from breakfast. Anyway..the groupby . sortby yielded the correct result, so now I want function like [[a]] -> [a] . The elements in [[a]] are grouped by 'from' (remember: DistElement from to dst). So for each group I want to create a new Distelement with the new dst as a mean value of the dsts in the group. Clear enough? :)
03:56:46 <opqdonut> you basically want "map mean"
03:56:58 <Botje> deeflex: i don't see what's the problem then :)
03:57:21 <Botje> you know how to extract the dst from a DistElement, you know how to compute a mean, and you know how to construct a DistElement
03:57:34 * Vq^ does some experiments
03:59:24 <deeflex> Botje, well I'm not quite getting it to work. Hold on...
04:04:47 <deeflex> Botje, map (\x -> DistElement (from (head x)) "v1" (dist (head x) + dist (tail x))/2) [[DistElement {from = "a", to = "to1", dist = 1.0},DistElement {from = "a", to = "to3", dist = 1.0}],[DistElement {from = "b", to = "to2", dist = 2.0}]] . Each element in the group will only have two elements, that's why I use tail.
04:04:48 <deeflex> brb
04:05:26 * Saizan_ starts a petition to save our libraries from Henning Thielemann
04:06:23 <Botje> deeflex: almost correct. If you know for certain all lists will only have two elements you can use pattern matching to grab the two elements separately: \[x,y]
04:06:34 <Botje> it's almost correct because tail returns a list, you want head $ tail x
04:12:42 * Vq^ learns that monads doesn't quite fit his problem
04:14:42 <Botje> monads are like violence: if it's not working, use more
04:15:20 <PeakerWork> Vq^: I don't think it fits -- for example, I think "sequencing" two inaccurate float computations accumulates their inaccuracy, does not keep the same inaccuracy, so it shouldn't probably use the same "container" type
04:15:25 <Vq^> i'd say use Arrows :o)
04:15:39 <Gracenotes> :o
04:15:47 <Vq^> PeakerWork: yeah, i think you're right
04:16:20 <PeakerWork> Vq^: If you find it hard to see if it fits monads or arrows, just write the combinators first, and see what type-classes it fits later
04:16:21 <Vq^> it's just that it would have been a nice looking interface
04:16:46 <EnglishGent> hi all :)
04:16:48 <PeakerWork> Vq^: after you write it you can still see that it fits monads or arrows or whatever
04:16:53 <Vq^> EnglishGent: hello mr Gent
04:17:18 <EnglishGent> does someone know a tutorial for using Haskell to work with HTML?
04:17:27 <EnglishGent> hi Vq^ :)
04:17:35 <Vq^> EnglishGent: parsing or generating?
04:18:08 <bnijk> have you guys heard of this "haxe" language
04:18:09 <EnglishGent> Vq^ - ultimately I want to do both - I'd like to write a web proxy in Haskell
04:18:11 <EnglishGent> :)
04:18:18 <EnglishGent> but I'll start with either! :)
04:18:32 <bnijk> build it on top of happs, make it a noodle proxy
04:19:00 <EnglishGent> happs? noodle?
04:19:05 <EnglishGent> hi bnijk
04:19:08 <Vq^> does your proxy need to understand HTML?
04:19:10 <bnijk> hello bnijk
04:19:36 <EnglishGent> yes - I want to be able to do things like extract a list of all the pages some given page links to
04:19:41 <bnijk> proxies generally don't need to understand HTML, EnglishGent, unless it's gonna be parsing it - even then, better to just use XML libraries
04:19:48 <bnijk> to do what little editing you want to do
04:20:04 <bnijk> what is it...haxr?
04:20:25 <bnijk> no, haxml
04:20:29 <Isajha> Hi.  I got a question on determism (as CTMCP says "a declarative operation is [...] deterministic (always gives the same results when given the same arguments)").  I understand that monads allow me to order IO operations (or anything else that needs to performed "in order"), however I really do not understand how a function in Haskell performing on any data that does not originate from...
04:20:31 <Isajha> ...within the program could be called deterministic?  Now considering that this initial "world" state is an argument to any Haskell program, could a Haskell program be called deterministic because actually this "world" state is an argument to a Haskell program? (main :: IO ())
04:20:35 <Ycros> bnijk: I have heard of the haxe language, but never used it
04:21:29 <EnglishGent> I want to be able to build up a directed graph of pages - so I can render the graph using something like dot (www.graphviz.org/doc/info/lang.html)
04:21:53 <MyCatVerbs> Isajha: IO actions are indeed not always deterministic.
04:22:05 <EnglishGent> basically I want the proxy to remember what pages where visited & when - and the relationships between them
04:22:14 <MyCatVerbs> Isajha: but running pure functions on the data that they generate is perfectly deterministic.
04:22:28 <astrolabe> Isajha: You can think of the haskell program as deterministically generating a program, which then runs non-deterministically.
04:24:20 <MyCatVerbs> Isajha: e.g. take the IO action (do { c <- getChar; putChar (toUpper c); }. getChar may return a completely different value every time you run this IO action. The toUpper function, however, will always return the same output when given the same input, no matter when or where you run it.
04:24:33 <deeflex> Botje, ok I see. Let me try.
04:25:40 <Twey> getChar >>= putChar . toUpper
04:25:40 <MyCatVerbs> Isajha: you can tell from the types of things whether or not they might be non-deterministic. The non-deterministic things are the ones marked with IO. ^_^
04:25:41 <Twey> >.>
04:25:52 <Vq^> EnglishGent: have you seen this? http://ubietylab.net/ubigraph/
04:26:35 <MyCatVerbs> Twey: I wrote it that way first, but then wasn't sure whether or not the person I'm addressing would be familiar with pointless style. :P
04:26:40 <Vq^> EnglishGent: a proxy visualising the traffic in realtime with that library would be really cool :)
04:27:06 <Twey> Hehe
04:27:13 <Isajha> so basically there is a deterministic parts and not deterministic parts of a program
04:27:16 <Saizan_> non-deterministic doesn't look like the right term
04:27:31 <Isajha> the bigger the deterministic parts are the better (most likely)
04:27:33 * EnglishGent has a look
04:27:51 <Isajha> *there are
04:27:56 <Saizan_> depending on external factors /= not-deterministic, imo
04:28:08 <EnglishGent> no - I havent Vq^
04:28:23 <MyCatVerbs> Isajha: yep, you're pretty much got it in one. ^_^
04:28:32 <Isajha> nice^^
04:28:45 <EnglishGent> but doing it in realtime was my aim - I was inspired by the visual thesuras: http://www.visualthesaurus.com/
04:28:46 <EnglishGent> :)
04:29:05 <EnglishGent> so that I could have a 'map' showing me where I was in surfing sessions
04:29:13 <MyCatVerbs> Isajha: IO gives you, oh, multithreading, raw pointer access (largely for C compatibility, funnily enough ^_^), syscalls...
04:29:16 <EnglishGent> I figured it would be really useful for sites like wikipedia, etc :)
04:29:28 <Isajha> yep that would be the next question
04:29:29 <deeflex> Botje, How do I return a more precise answer? Now I got: map (\[x,y] -> DistElement (from x) "v1" ((dist (x) + dist (x))/ fromIntegral 2)) [[DistElement {from = "a", to = "to1", dist = 1.0},DistElement {from = "a", to = "to3", dist = 1.0}],[DistElement {from = "b", to = "to2", dist = 2.0},DistElement {from = "b", to="to2", dist = 1.3}]] . Returns [DistElement {from = "a", to = "v1", dist = 1.0},DistElement {from = "b", to = "v1", dis
04:29:29 <deeflex> t = 2.0}]
04:30:18 <EnglishGent> I'm learning Haskell & fairly new to it - but I have lots of experience programming with Lisp, Scheme & other languages - so I figured it would be a good project for me to do :)
04:30:37 <Isajha> the parts of a program that are deterministic, the compiler/interpreter can optimize them way more (i.e. automatic distribution on different cpu cores)
04:31:15 <MyCatVerbs> Isajha: we're not quite at "automatic distribution on different cpu cores", but yeah. Pure calculations are very easily to safely introduce parallelism to with the par combinator. (*)
04:32:20 <Botje> deeflex: what do you mean more precies?
04:32:23 <Botje> *precise
04:32:39 <MyCatVerbs> Isajha: (* "safety" is defined roughly as "no matter how badly you mess up using (par), it should not break your program, but it might turn out to run slower than without it.)
04:33:35 <Gracenotes> :3
04:33:36 <MyCatVerbs> EnglishGent: nifty. The main bits that're different in pure computation are that you have laziness and strong typing. The really huge difference IO-wise is that, rather than expressions having side effects, you construct programs using a term algebra on IO actions. :)
04:34:48 <deeflex> Botje, the second element should result in 1.65 instead of the rounded value 2.0
04:35:07 <MyCatVerbs> EnglishGent: oh and the syntax is infix rather than prefix. As much as I love s-expressions, I was never quite so fond of how hysterically my Scheme programs would implode if I put in one too many or few ('s. :)
04:35:43 <Isajha> well I just came across it when i was reading about the dataflow variable based concurrency in CTMCP (all is threaded and when a thread needs an unbound value it waits until another thread binds it; as there is single assignment only he can be sure to continue when it's bound)
04:36:03 <EnglishGent> the I/O is the most confusing thing for me MyCatVerbs - but I've been through a couple of tutorials & I can do line based I/O with getLine, putStr & friends
04:36:41 <Botje> deeflex: take a good long look at your code :)
04:36:47 <EnglishGent> I'm just wanting to avoid writing a whole HTML parser & so on from scratch - I'm sure there must be one already :)
04:37:09 <PeakerWork> EnglishGent: If you don't think of an (IO a) as an a, but as some complicated thing that depends on lots of input and has lots of output, of which "a" is directly available, its probably less confusing
04:37:38 <MyCatVerbs> EnglishGent: oh yeah, there are a couple on Hackage.
04:37:51 <deeflex> Botje, haha lol. Ok got it :)
04:37:54 <RayNbow> hmm... I'm reading a paper where the notation for function composition is also used for function application...
04:38:15 <MyCatVerbs> AFAIK the one that you are most likely to be interested in is Tagsoup - it's designed for consuming relatively crap HTML (of which the entire web is of course composed) and being usable anyway.
04:38:40 <MyCatVerbs> Except that I got the name wrong. It's TagSoup, not Tagsoup. ^_^
04:38:49 <MyCatVerbs> http://community.haskell.org/~ndm/tagsoup/ <- ndm FTW.
04:39:01 <EnglishGent> ah - ty! I agree - with the application I have in mind I dont think we can assume well-formed HTML!
04:39:04 <MyCatVerbs> @where hackage
04:39:05 <lambdabot> http://hackage.haskell.org/
04:39:29 <mmorrow> this is a good read: http://mail.python.org/pipermail/python-dev/1999-July/000467.html
04:39:54 <MyCatVerbs> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/tagsoup <- this is probably a more useful link for TagSoup, come to think of it.
04:47:03 * EnglishGent looks through TagSoup
04:55:05 <EnglishGent> ty all btw :)
05:00:04 <mmorrow> does anyone know off-hand whether pthreads has a way to pin a thread to a core?
05:00:27 <mmorrow> or does this need hackery?
05:00:43 <mmorrow> (in C)
05:01:37 <MyCatVerbs> This needs hackery.
05:01:43 * mmorrow finds the sweet spot in the google search string
05:01:46 <Isajha> thanks for the help by the way - that really cleared things up
05:01:58 <mmorrow> MyCatVerbs: oh wonderful
05:02:04 <MyCatVerbs> mmorrow: sched_setaffinity(2) in Linux.
05:02:15 <mmorrow> MyCatVerbs: oh beautiful, thanks
05:04:58 <MyCatVerbs> Can't find anything offhand about affinity in the BSDs, though.
05:05:38 <mmorrow> reading this currently, not sure if there's a happy ending yet http://unix.derkeiler.com/Mailing-Lists/FreeBSD/hackers/2007-02/msg00107.html
05:06:16 <mux> MyCatVerbs: http://www.freebsd.org/cgi/man.cgi?query=cpuset&apropos=0&sektion=0&manpath=FreeBSD+7.2-RELEASE&format=html
05:06:20 <mmorrow> i should just look at ghc's code for this
05:06:32 <mmorrow> mux: wooo, nice
05:06:35 <mux> FreeBSD has affinity since 7.1
05:07:03 <mux> also, the syscall: http://www.freebsd.org/cgi/man.cgi?query=cpuset&sektion=2&apropos=0&manpath=FreeBSD+7.2-RELEASE
05:07:19 <MyCatVerbs> mux: nifty, thank you!
05:07:25 <mux> my pleasure
05:07:39 <Gracenotes> :O
05:08:09 <MyCatVerbs> All I'd been finding was old unanswered questions on mailing lists. >>
05:08:37 <mux> doh, finally: http://www.freebsd.org/cgi/man.cgi?query=cpuset_setaffinity&sektion=2&apropos=0&manpath=FreeBSD+7.2-RELEASE
05:09:16 <mmorrow> if anyone's interesting in browsing the ghc rts code, i build doxygen docs the other day *with the works* (caller/ee graphs for every function (graphviz), mentions/ed by list, list of structs, lists of fields, lists of types, highlighted code with hyperlinked idents, ...)  http://moonpatio.com/ghc/rts/html/main.html
05:09:19 <mmorrow> it's handay
05:09:26 <mmorrow> *built
05:09:42 <MyCatVerbs> mmorrow: is that from stable or the HEAD?
05:09:51 <mmorrow> HEAD
05:10:32 <mmorrow> MyCatVerbs: but the doxygen config file i used is (stolen from bitc, which it appears stole in the the manual):
05:10:47 <mmorrow> http://moonpatio.com/ghc/ghc_rts.doxygen.html.cfg
05:10:53 <mmorrow> in ghc/
05:11:03 <mmorrow> $ doxygen ghc_rts.doxygen.html.cfg
05:11:07 <mmorrow> et voila
05:11:09 <MyCatVerbs> Niiifty.
05:11:20 <mmorrow> (it's like 200MB of output...)
05:12:23 <mmorrow> i've never seen doxygen docs that didn't suck before last week and was stunned by the awesomeness
05:12:30 <uzytkownik> Is there any notability rule or any haskell FLOSS project can request a hosting on community.haskell.org? I've created LGPL NNTP library in haskell and it'd be good to 1) share it 2) protect from disk IO errors.
05:12:44 <mmorrow> uzytkownik: you should upload it to hackage
05:13:01 <mmorrow> (and you can get a community.haskell.org account too)
05:13:31 <mmorrow> uzytkownik: http://community.haskell.org/admin/account_request.html
05:13:54 <uzytkownik> mmorrow: I know. I read. I just asked about notability rule :)
05:14:03 <mmorrow> none such
05:14:29 <mmorrow> (the notability rule is to want one in the first place :)
05:16:08 <mmorrow> MyCatVerbs: here's ghci's interpreter loop's call graph http://moonpatio.com/ghc/rts/html/Interpreter_8c_93b7c81a9edc64cf6f8e958faacd8d7c_cgraph.png
05:17:41 <Ycros> hmm, ton of compiler warnings building Yi
05:19:29 <EvilRanter> unsafeSmiteUser 'EvilTerran
05:20:55 <kacper_> how Can I make a list of same elements with size n, function = 0:0:0.. of size n, not using my own function?
05:21:08 <mauke> :t replicate
05:21:09 <lambdabot> forall a. Int -> a -> [a]
05:21:37 <kacper_> thanks man
05:25:13 <kacper_> and how Can I add el as head for every list in list of lists using prelude?
05:25:39 <Saizan_> map (el:) listoflists ?
05:26:14 <EvilTerran> > map (x:) [[a,b,c],[d,e],[f],[]]
05:26:15 <lambdabot>   [[x,a,b,c],[x,d,e],[x,f],[x]]
05:26:29 <kacper_> ok, thanks
05:26:50 <MyCatVerbs> mmorrow: preeeetty :)
05:27:39 <Gracenotes> :O
05:28:17 <Gracenotes> > map head $ map (x:) [[a,b,c],[d,e],[f],[],undefined]
05:28:19 <lambdabot>   [x,x,x,x,x]
05:33:13 <kacper_> how create type of 1 | 0 ? i have error all time
05:33:23 <ivanm> you can't
05:33:30 <ivanm> since 1 and 0 are already taken
05:33:41 <ivanm> you can, however, have: data Foo = One | Zero
05:34:33 <ivanm> kacper_: ^^
05:34:43 <kacper_> is this optimal?
05:34:45 <EvilTerran> or data Foo = D0 | D1, say
05:34:54 <EvilTerran> or you could just use Bool
05:34:56 <EvilTerran> ?src Bool
05:34:56 <lambdabot> data Bool = False | True deriving (Eq, Ord)
05:36:43 <kacper_> thanks
05:41:01 <EnglishGent> if kacper_ wants a list of size n - wont he have to use (take n (replicate f)) - not just replicate f?
05:41:24 <opqdonut> :t replicate
05:41:25 <lambdabot> forall a. Int -> a -> [a]
05:41:30 <opqdonut> you're probably thinking of repeat
05:41:32 <opqdonut> :t repeat
05:41:33 <lambdabot> forall a. a -> [a]
05:41:36 <opqdonut> ?src replicate
05:41:36 <lambdabot> replicate n x = take n (repeat x)
05:41:38 <opqdonut> :)
05:42:30 <smorg> If i define a recursive function, whats the proper way to grab an output after n iterations?
05:42:40 <smorg> The best I can think of is something like: let iter x y = (take (x+1) $ [y])!!x
05:42:58 <opqdonut> > iterate (+1) 2 !! 100
05:42:59 <lambdabot>   102
05:43:05 <opqdonut> :t iterate
05:43:06 <lambdabot> forall a. (a -> a) -> a -> [a]
05:43:07 <opqdonut> that help?
05:48:12 <smorg> Yeah that kind of makes sense. I don't think it would work though If you input a function which already is a recursive function which yields an infinite list. Like fib = 1 : 2 : zipWith (+) fib (tail fib)
05:48:29 <opqdonut> fib isn't a function
05:48:33 <opqdonut> it's a list
05:49:23 <ray> who says lists aren't functions
05:49:23 <opqdonut> so you'd want the list that comes out when you apply that definition of fib to itself n times?
05:49:27 <mauke> ray: I do
05:49:29 <opqdonut> ray: the type
05:49:40 <ivanm> @type let fib = 1 : 1 : zipWIth (+) fib (tail fib) in fib
05:49:42 <lambdabot> Not in scope: `zipWIth'
05:49:48 <ivanm> @type let fib = 1 : 1 : zipWith (+) fib (tail fib) in fib
05:49:49 <lambdabot> forall a. (Num a) => [a]
05:49:55 <ivanm> ^^ no -> there, so not a function
05:50:10 <opqdonut> :)
05:50:27 <smorg> opqdonut: basically, except the result would just be an int
05:50:50 <opqdonut> smorg: you can't just cut a recursive function open
05:51:02 <opqdonut> you have to define one step of it as a function and then iterate that n times
05:51:26 <opqdonut> what you want isn't really clear
05:53:12 <smorg> opqdonut: A function which returns the nth element of fib. by that definition if it were a list, I would think you could go [fib]!!n
05:53:28 <opqdonut> [fib] makes no sense
05:53:31 <opqdonut> !!n makes sense
05:53:39 <opqdonut> > let fib = 1 : 1 : zipWIth (+) fib (tail fib) in fib !! 100
05:53:40 <lambdabot>   Not in scope: `zipWIth'
05:53:42 <opqdonut> gah
05:53:46 <opqdonut> > let fib = 1 : 1 : zipWith (+) fib (tail fib) in fib !! 100
05:53:47 <lambdabot>   573147844013817084101
05:53:48 <opqdonut> there
05:54:02 <mauke> @let zipWIth x = zipWith x
05:54:03 <lambdabot>  Defined.
05:54:07 <opqdonut> mauke: :D
05:54:17 <ivanm> opqdonut: heh, did my mistake? :p
05:54:29 <opqdonut> ivanm: yeah, i copypasted because i was lazy :)
05:54:30 <ivanm> or did you copy/paste my original @type rather than my fixed one?
05:54:38 <opqdonut> yeah
05:54:41 <opqdonut> and didn't pay attention
05:56:03 <smorg> but you had to change the function
05:56:34 <opqdonut> i didn't change fib
05:57:05 <ivanm> just added !! 100
05:57:10 <opqdonut> on the other hand, if i have something like "factorial 0 = 1; factorial x = x*factorial (x-1)", theres no way of getting the "nth iteration"
05:57:29 <ivanm> without evil hacks like trace
05:57:52 <smorg> hm.
05:57:58 * smorg looks up what "in" does.
05:58:03 <sven_> does anyone know a good source for some nice monads & monads transformer exercises?
05:58:18 <opqdonut> smorg: let ... in
05:58:19 <mauke> smorg: let BINDINGS in BODY
05:59:10 <ivanm> mauke: are you starting to channel @yow or something? :p
05:59:25 <opqdonut> :P
05:59:29 <opqdonut> @yow
05:59:30 <lambdabot> I have seen these EGG EXTENDERS in my Supermarket ... I have read the
05:59:30 <lambdabot> INSTRUCTIONS ...
05:59:36 <mauke> I don't ever want to be a baby thrower, but I can't wait to be a baby catcher!
05:59:46 <mmorrow> let BINDINGS in BODY, EQUIP me with MISSILES!
05:59:55 <opqdonut> :D
06:00:05 <mmorrow> @yow
06:00:06 <lambdabot> I just forgot my whole philosophy of life!!!
06:00:12 <mauke> I mean, how can they GUARANTEE to blow your mind?
06:00:17 <ivanm> @. elite yow
06:00:18 <lambdabot> YoUt|-| Of TOD4y! Join mE IN A MASz Ra1Ly for +RadItIONal m3N+A1 aT+iTuD3S!
06:00:21 <trofi> @go lolcode
06:00:25 <lambdabot> http://lolcode.com/
06:00:25 <lambdabot> Title: home · LOLCODE
06:00:45 <mauke> @quote lolcode
06:00:45 <lambdabot> No quotes match. You untyped fool!
06:08:07 <smorg> grr I keep getting confused with python
06:09:05 <smorg> Maybe i'll write a 1337 translator in haskell :)
06:10:09 <licksjp> Hello
06:16:14 <kacper_> can I use pattern: list == [h,t] for list of 2 elems?
06:16:24 <kacper_> i have error like not in scope 't
06:17:07 <mike-burns> Maybe you should represent that as a pair instead?
06:17:21 <harlekin> > let list = (1:2:[]) in list == [1,2]
06:17:22 <lambdabot>   True
06:17:46 <harlekin> You should be able to do that. The error means that t is not in scope. (; t is not defined or defined but not accessible from where you try to access it.
06:23:50 <kacper_> | list == [h,t] = ( map ( h: ) solveRow xs hori vert ) ++ ( map ( t: ) solveRow xs hori vert )
06:24:03 <kacper_> not in scope 't'
06:26:19 <EvilTerran> kacper_, guards don't introduce new variables
06:26:23 <EvilTerran> that's what patterns are for
06:27:04 <kacper_> but h is ok?
06:27:35 <EvilTerran> if it's in scope from somewhere else, you wouldn't get an error
06:28:02 <EvilTerran> although you may well not get the behaviour you expect
06:30:16 <smorg> let iter x y = last $ take x $ y
06:30:37 <EvilTerran> > [a,b,c,d,e] !! 3
06:30:38 <lambdabot>   d
06:45:36 <paolino> hi, is there a wai to forkIO the main loop of gtk2hs and experiment via ghci the IO actions of the library ?
06:46:25 <dcoutts> paolino: you'd have to use postGUISync or postGUIAsync
06:46:46 <dcoutts> paolino: otherwise it'll go horribly wrong :-)
06:47:42 <paolino> mhh, how it gets the right thread ?
06:49:22 <dcoutts> paolino: it posts the GUI actions to the correct thread
06:49:57 <dcoutts> internally there's global state for the main gtk event loop
06:50:28 <paolino> ok
06:50:40 <paolino> very unhaskell :P
06:52:05 <dcoutts> paolino: yep, that's what we get for wrapping C libs :-)
06:53:49 <Geheimdienst> hi, i have a newbie question about this tiny 2-liner i wrote
06:53:54 <mike-burns> Is there a tutorial for using a gtk2hs IconView? I'm having trouble figuring it out from the docs alone.
06:56:01 <Geheimdienst> this here works: http://pastebin.com/m2ab275ba . now i want to move the contents of main to a new function as outlined. main should only contain this: putStrLn (getconf "abc" "def" "ghi")
06:56:06 <Geheimdienst> how?
06:58:33 <EvilTerran> Geheimdienst, well, as getconf will be doing IO, it needs to indicate this in the type
06:58:46 <EvilTerran> Geheimdienst, so getconf :: String -> String -> String -> IO String
06:58:52 <mauke> main = do x <- getconf "abc" "def" "ghi"; putStrLn x
06:59:05 <EvilTerran> and then you can do as mauke suggests
06:59:49 <EvilTerran> or "main = putStrLn =<< getconf ..."
07:01:23 <EvilTerran> Geheimdienst, you wouldn't be able to write putStrLn (getconf "abc" "def" "ghi"), as putStrLn takes a String, and (getconf ...) would be an IO String
07:01:57 <Geheimdienst> mauke: ok yes, i actually got that far. but i thought x <- ... putStrLn x was a little clumsy
07:02:18 <mux> you can write putStrLn =<< getconf "abc" "def" "ghi"
07:02:26 <Geheimdienst> evilterran: yeah, putStrLn =<< getconf was what i was looking for. thanks
07:02:30 <mauke> getconf "abc" "def" "ghi" >>= putStrLn
07:02:56 <EvilTerran> (=<<) :: (a -> IO b) -> IO a -> IO b -- in this case
07:03:51 <EvilTerran> (do x <- m; f x) = (m >>= f)
07:04:49 <hackagebot> Added by RohanDrape, Sun Jun  7 13:51:59 UTC 2009.: Haskell Postscript  http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hps-0.1
07:04:49 <hackagebot> Added by RohanDrape, Sun Jun  7 14:01:44 UTC 2009.: Haskell SuperCollider Unit Generator Database  http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hsc3-db-0.7
07:06:49 <hackagebot> Added by RohanDrape, Sun Jun  7 14:05:41 UTC 2009.: Cairo rendering for haskell postscript library  http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hps-cairo-0.1
07:06:52 <Geheimdienst> yeah baby, it works. thanks guys. 1 tiny step closer to world domination
07:07:42 <gwern> 'Unsafe Haskell SuperCollider'
07:07:43 <gwern> what
07:10:44 <paolino> dcoutts : initGUI >> forkIO mainGUI >> postGUISync (windowNew >>= widgetShowAll) is right ?
07:11:12 <paolino> sometimes xmonad seems doesn't show a window ....
07:12:51 <hackagebot> Added by RohanDrape, Sun Jun  7 14:12:38 UTC 2009.: Haskell SuperCollider Record Variants  http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hsc3-rec-0.7
07:13:47 <dcoutts> paolino: that should be ok, but note that you loose the reference to the window
07:17:31 <paolino> sure
07:18:21 <Axman6> @hoogle fork
07:18:22 <lambdabot> Control.Concurrent forkIO :: IO () -> IO ThreadId
07:18:22 <lambdabot> Control.Concurrent forkOS :: IO () -> IO ThreadId
07:21:23 <dcoutts> any OS X users here who can check the behaviour of 'ar' for me? This is so we can make sure Cabal does the right thing.
07:22:19 <dcoutts> I want to check if ar -q -s works when we've got duplicate object files
07:22:44 <Raevel> dcoutts: sure, how do it check?
07:23:11 <dcoutts> Raevel: lets use #haskell-in-depth so we don't annoy everyone else :-)
07:23:22 <Raevel> alright
07:24:00 <paolino> haskell-in-breadth
07:25:12 <opqdonut> :)
07:36:56 <mav`> {Uptime} [10:26am up 1:57, 2 users] {Load average} [0.09, 0.17, 0.37]
07:44:58 <hackagebot> Added by RohanDrape, Sun Jun  7 14:29:08 UTC 2009.: Haskell SuperCollider Language  http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hsc3-lang-0.7
07:44:58 <hackagebot> Added by RohanDrape, Sun Jun  7 14:32:24 UTC 2009.: Minimalist haskell html library  http://hackage.haskell.org/cgi-bin/hackage-scripts/package/html-minimalist-0.1
07:45:07 <mike-burns> gtk2hs question: I've written this: http://pastebin.com/m6307b19f as a straight translation of http://www.andreagrandi.it/2008/04/15/using-gtkiconview-in-python-a-small-tutorial/ . It gives me this error when I run it, and no icons: Gtk-CRITICAL **: gtk_icon_view_set_pixbuf_column: assertion `column_type == GDK_TYPE_PIXBUF' failed
07:45:19 <mike-burns> Is the IconView implementation wrong, or am I doing it wrong?
07:45:36 <dcoutts> mike-burns: I'd ask on the gtk2hs users list
07:45:46 <mike-burns> Will do.
08:07:10 <mmorrow> is there a standard abbreviation for "complement"?
08:07:17 <mmorrow> cmpl, comp, ?
08:07:34 <mmorrow> err, i wonder what it is in asm
08:07:47 <Philippa> sometimes cmp, where it's not compare
08:08:34 <mmorrow> hmm
08:22:24 <Botje> IA32 assembly guide only has NEG and NOT
08:22:45 <Botje> for negation in two's complement and one's complement, resp.
08:28:35 <Raevel> what are the steps necessary to uninstall a cabal package i installed with cabal-install?
08:29:27 <dcoutts> Raevel: ghc-pkg unregister [--user] and rm for the files which by default for --user installs are under ~/.cabal/lib/pkgid
08:29:42 <Raevel> thank you!
08:48:29 <algal> a possibly naive question: is it possible, in principle or in practice, to do automatic worst-case time/space complexity analysis of a haskell function?
08:50:01 <EvilTerran> algal, i think haskell being turing-complete renders that problem undecidable
08:50:17 <EvilTerran> seeing as you can't even decide termination
08:50:45 <Saizan_> it might be workable in practice though
08:50:47 <EvilTerran> although you may be able to approximate upper bounds of complexity more easily in haskell than in other languages
08:52:29 <algal> Interesting. It seems that if a person can often informally calculate an asymptotic complexity, then it should be automatable some of the time.
08:53:22 <algal> But I'm not sure how the possibility of big-O analysis squares with the undecidability of the halting problem (if I'm remembering the issues right).
08:54:59 <dcoutts> complexity analysis is complicated by laziness
08:56:01 <PeakerWork> it always confuses the hell out of me :(
08:57:40 <algal> I wonder if there are automated complexity-analyzers in any language at all..
08:58:02 <PeakerWork> you can automatically deduce a worst-case bound, but it won't necessarily be a tight bound
08:58:19 <PeakerWork> proving the bound is better than the "obvious" one is very difficult sometimes
08:58:55 <mike-burns> There are cyclomatic complexity analyzers (e.g. http://saikuro.rubyforge.org/), but I've never heard of one that will take a function and tell you that it's O(log n).
08:59:10 <aavogt> or measure the asymptotic complexity empirically?
09:01:39 <algal> hmm, interesting. thanks everyone.
09:06:27 <PeakerWork> aavogt: dangerous, and would probably be impossible to differentiate O(1) from O(logN)
09:36:59 <Asztal> hmm... I had no idea about the -<< in arrow notation...
09:38:01 <Asztal> well that makes things somewhat simpler
09:42:03 <dino-> oh boy, hackage is failing to respond to my upload
09:43:10 <PeakerWork> dino-: use the web page for checking the package upload
09:43:28 <hackagebot> Added by DinoMorelli, Sun Jun  7 16:38:52 UTC 2009.: Rename JPEG photo files based on shoot date  http://hackage.haskell.org/cgi-bin/hackage-scripts/package/photoname-2.2
09:43:30 <dino-> checking was quick but upload finally worked after minutes.
09:43:37 <dino-> I was sure it was going to fail
09:43:52 <Geheimdienst> newbie question: how do i write a lambda with pattern-matches? i.e. how would i write this function http://pastebin.com/m1dc86e8c as a lambda?
09:44:19 <Axman6> you'd need to use a case statement
09:44:27 <mauke> \s -> case s of "charging" -> "+"; "discharging" -> "-"; "charged" -> "+/-"
09:44:45 <Axman6> which is basically what that code gets compiled into i think
09:46:44 <Geheimdienst> ok thanks
09:47:47 <Geheimdienst> out of curiosity, when do you use this? http://haskell.org/onlinereport/exps.html#sect3.3
09:48:11 <Geheimdienst> there's no example given for "\ apat1 ... apatn -> exp"
09:48:57 <Axman6> \x y -> x + y
09:49:26 <roconnor> > (\"hi" "ho" -> "go work") "hi" "ho"
09:49:27 <lambdabot>   "go work"
09:50:21 <Axman6> Geheimdienst: you're not trying to learn haskell by reading the report are you?
09:50:31 <Geheimdienst> ah i see, that's just multiple parameters
09:50:59 <Geheimdienst> no :) just came across that while googling "lambda pattern matching"
09:52:13 <Geheimdienst> thanks guys, you're always very helpful
09:54:41 <Gracenotes> so you can have one pattern match in a lambda expression, but case allows many
09:55:05 <Gracenotes> unfortunately if there's only one pattern matching scenario, if can fail :/
09:55:37 <roconnor> > (\"hi" "ho" -> "go work") "hi" "FAIL"
09:55:39 <lambdabot>   "* Exception: <interactive>:1:134-156: Non-exhaustive patterns in lambda
09:55:45 <Axman6> FAIL!
09:56:15 <Gracenotes> it
09:59:22 <Pellwurst> how can i run a shell-script within a haskell program?
10:00:05 <Botje> hoogle system
10:00:09 <Botje> @hoogle system
10:00:09 <lambdabot> System.Cmd system :: String -> IO ExitCode
10:00:09 <lambdabot> module Distribution.System
10:00:09 <lambdabot> package system-inotify
10:00:10 <Botje> argh :)
10:00:12 <mauke> like any other executable
10:00:16 <Botje> or you can look at runProcess
10:00:45 <Pellwurst> thx...
10:01:00 <roconnor> mauke: don't you need to run the shell and pass it the script?
10:01:04 <mauke> no
10:01:15 <roconnor> oh
10:01:16 <roconnor> nice
10:01:32 <Twey> Not if it's got its magic numbers in order...
10:01:35 <mauke> one of the executable formats supported by the kernel is #!
10:02:30 <roconnor> aww.  Chanserve owns #!
10:02:55 <sbaader> hi!
10:03:31 <sbaader> I'm looking for examples/tutorials fro the SDL bindings, but I apparently don't know where to look ..
10:03:42 <sbaader> really new to haskell..
10:03:51 <sbaader> any hints?
10:04:23 <Axman6> well firstly, how much haskell do you know?
10:04:56 <Axman6> if you're trying to use a rather advanced library in a language you're not familliar with, you're just asking for trouble and frustration
10:05:14 <sbaader> I know
10:05:28 <sbaader> Enough to make sense of example code and learn from modifying it
10:05:40 <sbaader> too little to put something otgether on my own
10:06:11 <Twey> spoop: http://lazyfoo.net/SDL_tutorials/index.php works fine for Haskell
10:06:15 <sbaader> to impationet to chew thhrough list conprenhensions and pure code, i want something on the screen ;)
10:06:16 <Twey> Tho transformations are obvious
10:06:25 <Twey> The**
10:06:52 <Twey> import qualified Graphics.UI.SDL as SDL instead of #include <sdl.h>; SDL.foo instead of SDL_foo
10:06:59 <Twey> And of course everything is in IO
10:07:56 <sbaader> Thanks. I was using them, but I know SDL but not haskell, so it's hard for me to translate that to haskell...
10:08:06 <Axman6> sbaader: pure code is where all the interesting stuff happens
10:08:33 <sbaader> Axmann6: sure ;)
10:08:52 <Axman6> anyway, sounds to me like you need to use haskell more, before trying to use the SDL bindings
10:08:58 <Twey> Yeah
10:09:08 <sbaader> hm...
10:09:19 <Axman6> i've been using haskell for over a year now, and probably wouldn't touch them (mainly because i have no need though)
10:10:30 <sbaader> ok, it doesn't really matter - I just want some real haskell code that runs and modify it to learn haskel lhands on
10:10:52 <sbaader> the tutorials are very focused on theoretical execises
10:11:50 <Axman6> as they should be really
10:12:01 <sbaader> hehe
10:12:18 <sbaader> i totally agree that the pure code is the interesting part and that the stringth of haskell in in FP
10:12:30 <Axman6> doing things like SDL is probably quite out of the ordinary really
10:13:02 <sbaader> but at the end of the day, a program is interesting to me if it does something (elegantly) and not if it does nothing in an elegant way
10:13:10 <sbaader> *nods
10:13:27 <sbaader> (no criticism intended in that)
10:13:49 <sbaader> but -- anything elese you'd recommend for hands-on learning?
10:18:19 <Axman6> sbaader: tutorials ;)
10:18:26 <Axman6> learn you a haskell is a good start
10:19:01 <sbaader> yeah ;)
10:19:31 <sbaader> i am reading real world haskell and am doing real world haskell as well
10:19:53 <sbaader> they are great
10:20:29 <sbaader> they really introduce the possibilities in haskell
10:21:44 <sbaader> but - I also like to hack away on an existing program, modify it and learn from that as well. reading and doing tutorials all day is quite theoretical...
10:22:11 <sbaader> games are much more fun than fibonnaci series .. ;)
10:22:31 <inimino> I think you have an unusual definition of "theoretical"
10:22:33 <Axman6> and much less instructive ;)
10:22:37 <Axman6> me too
10:23:12 <Axman6> fibonacci is used as just one example of some very useful, and extremely iportant concepts (usually recursion)
10:23:34 <yitz> sbaader: fibonnaci nim. Start with a pile of stones, each player in turn takes a number of stones equal to a fibonnaci number, the player to take the last stone loses.
10:24:26 <sbaader> hehe
10:24:29 <sbaader> :)
10:24:52 <Axman6> if all you want to do is get your hands dirty and make some form of game, might as well just use VB
10:25:01 <inimino> heh
10:25:06 <inimino> noooo
10:26:24 <minormelodic> Hi!
10:27:22 <Axman6> o/
10:28:10 <minormelodic> If I have a list and I want a new list with only the 1st 3rd 5th 7th etc. elements, what functions can I use, please ?
10:29:09 <mauke> well, you could write it directly
10:29:12 <Botje> minormelodic: zip the list with [0..], filter out all element with odd numbers, and discard the numbers
10:29:26 <mauke> Botje: I'd zip with cycle [True, False]
10:29:36 <Botje> heh, of course
10:29:40 <paolino> dcoutts:  are gtk2hs widgets multithread tolerant ?
10:29:42 <Botje> i wonder if ghc is smart enough to notice that ;)
10:29:55 <Axman6> probably not
10:30:07 <gwern> Botje: you could submit a rewrite rule
10:30:14 <dcoutts> paolino: no, you need to use the provided functions if you want to use multiple threads
10:30:24 <mauke> > let f (x : _ : xs) = x : f xs; f xs = xs in f [1 .. 10]
10:30:25 <lambdabot>   [1,3,5,7,9]
10:30:37 <Botje> gwern: it seems too specific :)
10:30:59 <gwern> Botje: then maybe there's a research project there in finding generalized rewrite rules for it!
10:31:19 <paolino> dcoutts: widgets have special functions ?
10:31:23 <Botje> :)
10:31:30 <yitz> > let f = tail . map head . iterate (drop 2) in f [1..20]
10:31:32 <lambdabot>   [3,5,7,9,11,13,15,17,19,* Exception: Prelude.head: empty list
10:31:56 <yitz> > let f = tail . map head . takeWhile (not . null) . iterate (drop 2) in f [1..20]
10:31:57 <lambdabot>   [3,5,7,9,11,13,15,17,19]
10:32:11 <yitz> the first one is ok if your lists are infinite
10:32:27 <yitz> minormelodic: ^
10:32:36 <aavogt> > [1,3..]
10:32:37 <lambdabot>   [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
10:32:41 <minormelodic> thank you all !
10:34:08 <paolino> dcoutts: the postGUI functions ?
10:34:13 <dcoutts> paolino: right
10:36:39 <paolino> so I can share  references to widget among threads as long as  always use postGUI ? I was thinking to use TVars...
10:45:12 <deeflex> Botje, hey again. I need help with my file. Not sure I understand loops. Take a look at this (horrible?) code http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5632#a5633  =) .
10:47:01 <Botje> deeflex: woah. complex.
10:47:05 * Axman6 agrees with the horrible
10:47:09 <Botje> deeflex: the role of fi in your code is unclear
10:47:16 <Axman6> deeflex: you need to break things down into smaller pieces
10:47:20 <Botje> according to the type you give for neighborJoining, fi should be [String]
10:47:36 <Botje> but then you map selection over fi, which has type [Distance] -> (Distance, Float)
10:47:45 <Botje> so which one is it? [String] or [[Distance]] ?
10:47:51 <Axman6> "(""++show i)"?
10:48:04 <Axman6> that's exactly the same as (show i)
10:49:02 <Botje> deeflex: i'd give loop a type annotation
10:49:03 <deeflex> Botje, fi should be [String]. As you can see from line 7. I get all "from" from the DistElement, which are strings.
10:49:14 <Botje> deeflex: so why are you mapping selection over fi?
10:49:40 <deeflex> should be di
10:49:53 <deeflex> must have missed that
10:49:55 <Botje> well, add a type annotation to loop
10:50:05 <Botje> that makes the role of all elements that much clearer
10:51:19 <deeflex> Botje, type annotation to a loop? Never done/seen/heard that. How do I do that?
10:51:30 <Botje> deeflex: just put a type annotation before it :p
10:51:32 <Botje> loop :: .....
10:51:43 <Botje> s/before/on the line before/
10:52:09 <Botje> for documentation, if nothing else
10:53:10 <deeflex> ok didn't know I could do that..hehe
10:53:17 <deeflex> still learning :)
10:53:40 <Botje> also, that zlist and zlist2 stuff at the bottom looks fishy
10:54:19 <akamaus> hi, what's the prefered library for url encoding of strings?
10:56:52 <Botje> deeflex: term2x = sum [ dist x | x <- (list:rest), from x == from list]
10:56:57 <Botje> likewise for term2y
10:57:03 <Botje> so you can skup the zlist stuff
10:57:21 <Botje> deeflex: heh, and if you're just going to add the two terms, you can even do:
10:57:32 <deeflex> Botje, it is this algorithm I am trying to implement: http://en.wikipedia.org/wiki/Neighbor-joining  . The zlist and zlist2 are the \sigmas in Q-matrix.
10:57:35 <Botje> term2x = sum [ dist x | x <- (list:rest), from x == from list || from x == to list ]
10:57:37 <gwern> '
10:57:38 <gwern> 'Hi, how can I change the value of a variable.
10:57:38 <gwern> let x = 1
10:57:39 <gwern> x = x + 2'
10:57:48 <gwern> wow. I don't even know how to begin to reply to this email
10:58:09 <Botje> "use another language" ? :)
10:58:20 <gwern> akamaus: url encoding string? network.uri. the code looks something like 'escapeURIString (isAllowedInURI)'
10:58:36 <Botje> deeflex: i don't really have time to inspect your algorithm in detail, i'm just suggesting cleanups to your code atm
10:58:49 <gwern> Botje: I think I'll just punt on it. I don't have dons levels of patience to deal with such Fail
10:59:03 <Botje> gwern: forward it to dons! that's it! brilliant! :)
10:59:20 <Cale> gwern: Email?
10:59:22 <gwern> Botje: but dons is already on -cafe, so he'll see it anyway
10:59:28 <gwern> Cale: -cafe, as of a few minutes ago
10:59:29 <Cale> oh
11:00:51 <deeflex> Botje, oh no I didn't want that, but pasted the link to make things more clear. Anyway your help is much appreciated, gonna do the cleanup now.
11:04:36 <akamaus> gwern, I have troubles building network for windows and I need to stay crossplatform
11:04:49 <akamaus> I use curl for fetching data and need to encode urls for it.  There is a bunch if libraries like url, urlencoded, web-encodings. I just can't choose.
11:05:09 <gwern> akamaus: network is crossplatform; windows just sucks
11:05:23 <gwern> I've told you the right library to use
11:05:49 <performance> OT where can one download teh gtksourceview2 source code from?  i see only ready made packages on google :(
11:05:56 <akamaus> gwern, Personally I agree, but I need to make a windows build of my program )
11:13:04 <roconnor> > 2^100
11:13:05 <lambdabot>   1267650600228229401496703205376
11:17:20 <dever> hey all, i know I can set the attributes of stuff in gtk2hs, but how o I get the attributes of something?
11:17:51 <monochrom> Yay, Haskell Weekly News is out!
11:18:27 <Cale> dever:  set button [ buttonLabel := value ]
11:18:52 <dever> yep, thats set, but I want to get the value
11:18:55 <monochrom> (that doesn't seem to get)
11:19:04 <Cale> er, oh
11:19:08 <Cale> heh
11:19:12 <dever> :)
11:19:13 * Cale is not awake
11:19:22 <Cale> value <- get button buttonLabel
11:19:33 <Cale> http://haskell.org/gtk2hs/docs/current/System-Glib-Attributes.html#t%3AAttrOp
11:19:35 <dever> ah ok, cheers cale
11:19:49 <pumpkin> looks very glib
11:46:05 <Asztal> :t jpeg
11:46:06 <lambdabot> Not in scope: `jpeg'
11:46:20 <Asztal> you're not my terminal
11:46:29 * Asztal hides
11:51:43 <dev31212> hi all
11:51:54 <byorgey> hi dev31212
11:51:58 <Axman6> o/
11:52:02 <dev31212> hi byorgey
11:52:10 <dev31212> I have  a question regarding "Show" instances
11:52:27 <dev31212> If someone cares to have a quick go at it.
11:52:27 <Axman6> ask away
11:52:43 <Axman6> rule #1 of IRC: don't ask to ask, just ask
11:53:10 <dev31212> ok.  The error is "Could not deduce (Show a) from the context (Show (MyTree a))"
11:53:27 <dev31212> I am assuming this means it doesnt know how to "Show" whatever the type variable "a" is?
11:53:35 <Axman6> yes
11:53:45 <dev31212> The type is defined like so: data (Show a)=>MyTree a = EmptyTree | MyTree a (MyTree a) (MyTree a)
11:53:58 <dev31212> I am wondering whyt that doesnt solve it...or better yet, how can I fix this?
11:54:01 <Axman6> huh, should be ok
11:54:22 <dev31212> yeah, odd
11:54:37 <lysgaard> Anyone ever used the AdHoc-network library for haskell?
11:54:42 <Axman6> though a better way to do it would be data myTree a ...; instance (Show a) => Show (MyTree a) where ...
11:55:47 <dev31212> Ahhh
11:55:53 <dev31212> ok axman ill try it, thanks :)
11:57:38 <dev31212> Thanks, that did the trick
11:58:04 <hackagebot> Added by HenningThielemann, Sun Jun  7 18:53:42 UTC 2009.: Non-negative numbers  http://hackage.haskell.org/cgi-bin/hackage-scripts/package/non-negative-0.0.5
11:58:25 <PeakerWork> I think that (Show a)=> context on a data-declaration does not do what people expect it to do
11:58:38 <PeakerWork> dev31212: it also makes the type more useful -- can be used without a Show instance if you don't want to Show the tree
11:58:58 <dev31212> That makes good sense.
11:59:31 <algal> i am re-implementing the classic search algorithms in multiple languages, for my own edification. Is it really possible  to try to implement the standard sorts in Haskell in an FP style (e.g., insertion sort, quicksort, etc.), or are the classic algorithms fundamentally too imperative for that to be possible?
11:59:44 <PeakerWork> (I'm not sure what an ADT class restriction actually does)
11:59:58 <Cale> algal: It can be done...
12:00:01 <algal> I'm sort of guessing it's not really possible, but maybe I'm missing something.
12:00:12 <performance> any one compiled Leksah lately?
12:00:21 <PeakerWork> Cale: Quicksort swapping of elements requires destructive assignments, doesn't it?
12:00:33 <PeakerWork> algal: Haskell is also the world's best imperative language, you know? :)
12:00:36 <Cale> But quicksort doesn't really say that you have to mutate anything.
12:00:44 <algal> Yeah, quicksort is a good example.
12:00:52 <donnelly> a lot of the imperative sorts could be done in a monad, couldn't they?
12:00:54 <PeakerWork> Cale: It kinda does say you swap around elements, according to augustuss blog
12:00:55 <Cale> It's just a way to recursively break down the problem of sorting.
12:00:57 <algal> Cale: don't you need to mutate things to get quicksort's asymptotic complexities?
12:01:08 <dev31212> Peaker, what do you say to those people who say Haskell is not practical?
12:01:15 <Cale> algal: Not really. Only space complexity is affected.
12:01:22 <donnelly> using Data.Array.ST?
12:01:29 <Cale> algal: You can get the same time complexity without mutation.
12:01:33 <TomMD> @tell Saizan_ A while ago you asked if I was publishing my darcs repo of hackage server.  I'm still finishing up the quarter (one more week!), but just shoved the repo up on code.haskell.org/~tommd/hackage-server - all patches should go to dcoutts, not me, I'm not forking!
12:01:33 <lambdabot> Consider it noted.
12:01:38 <PeakerWork> dev31212: I say they have already been proven wrong. But that's not to say Haskell is ready for practical use in every niche
12:01:49 <algal> Cale: is that widely true for some general reason, or only w/r/t to quicksort?
12:01:50 <dev31212> Yeah.
12:01:53 <ski> PeakerWork : given `data Foo a => Bar a = ...' one might expect to be able to use `Bar a' in types without having to mention the `Foo a' constraint .. also one might expect that matching on a value of type `Bar a' would bring a constraint `Foo a' constraint into scope
12:02:17 <ski> PeakerWork : neither of these expectations are fulfilled here, though
12:02:32 <Cale> algal: Actually, if you're willing to change your list representation, you can do it with only a log space complexity hit.
12:02:37 <Cale> and *that* is general.
12:02:40 <PeakerWork> ski: What does it do then? What code would break if you removed all restrictions from ADT's?
12:02:47 <Axman6> dev31212: it'd certainly be my first choice for any parallel comutation, at least on a small scale
12:02:50 <ski> (it's another question to ask whether any of these expectations would be warranted, though)
12:03:15 <Cale> algal: It's possible to devise an immutable associative datastructure with O(log n) lookup and update.
12:03:15 <dev31212> Axman, yeah Ive read it is great for that.
12:03:25 <algal> Cale: why is that true in general? is there a theorem or some equivalence that explains it.
12:03:26 <dev31212> I still only about 3 months into serious study.
12:03:41 <PeakerWork> algal: some algorithms are more efficient as imperative, and Haskell allows that with the ST and other monads
12:03:42 <ski> PeakerWork : afaik, it adds the `Foo a' constraint to every constructor .. and maybe also requires that matching on `Bar a' *requires* a constraint `Foo a' in scope
12:03:52 <Axman6> dev31212: for a quick intro, check out the thread-ring benchmark on the language shootout
12:03:52 <ski> @src Complex
12:03:53 <lambdabot> data (RealFloat a) => Complex a = !a :+ !a
12:03:55 <algal> Cale: ah, so the possibility of this datastructure makes lots of classical imperative algorithms portable to FP with only a space hit?
12:03:55 <Cale> algal: Which means that essentially any algorithm that uses mutation could just use one of those instead, with only at most a log factor extra cost.
12:03:59 <Axman6> @where shootout
12:03:59 <lambdabot> http://shootout.alioth.debian.org/
12:04:04 <algal> Cale: I mean, a time hit?
12:04:04 <ski> @type (:+)
12:04:06 <lambdabot> forall a. (RealFloat a) => a -> a -> Complex a
12:04:07 <dev31212> Will do axman, thanks
12:04:08 <Cale> algal: Possibly a time cost as well.
12:04:09 <PeakerWork> ski: so it can't break compilations, just make code less type-safe?
12:04:19 <Cale> algal: But sometimes you can avoid one or both of them.
12:04:23 <ski> @type let f (x :+ y) = (x,y) in f
12:04:24 <lambdabot> forall t. (RealFloat t) => Complex t -> (t, t)
12:04:37 <Philippa> algal: basically it's possible because you can replace the mutable store with an immutable implementation using, say, a binary tree
12:04:38 <algal> Cale: thanks. interesting.
12:04:40 <Axman6> dev31212: i happen to be the one with the fastest entry there btw (though i only made a small imporvement to other people's work)
12:04:47 <ski> @type let f :: Complex a -> (a,a); f = undefined in f
12:04:48 <lambdabot> forall a. Complex a -> (a, a)
12:04:49 <dev31212> nice
12:04:54 <algal> Cale: what's the name for hte immutable associative ADT in haskell?
12:05:01 <Philippa> algal: there's a more precise statement, but that's the gist of it
12:05:06 <Philippa> algal: Map
12:05:08 <Cale> algal: Data.Map
12:05:14 <Axman6> dev31212: which i submitted after only using haskell for a year too :)
12:05:17 <PeakerWork> Axman6: I think the shootout is misleading. Haskell performance is only great if you're a pretty experienced Haskell hacker
12:05:18 <algal> thanks, all.
12:05:29 <Cale> algal: Also, just for straight lists you can do something which is identifiably quicksort which is O(log n) average time, and O(n) space complexity.
12:05:35 <ski> PeakerWork : those tests suggest that both calling and matching on the constructor *requires* the constraint (the latter arguably a bug)
12:05:40 <PeakerWork> I don't think Haskell's uniprocessor performance is that great, when compared to some performance-oriented languages
12:05:42 <Axman6> PeakerWork: a lot of the things that make haskell are fast are pretty easy to grasp though
12:06:01 <ski> PeakerWork : also, it doesn't appear to be an error to use the *type* `Complex a' in a context where `Foo a' is not known
12:06:03 <algal> are their syntactic sugars for the Map? It seems like everything is built for lists, like lisp...
12:06:07 <Cale> > let sort [] = []; sort (x:xs) = sort less ++ [x] ++ sort greater where (less,greater) = partition (<= x) xs in sort [5,2,6,2,8,9,1,10]
12:06:08 <lambdabot>   [1,2,2,5,6,8,9,10]
12:06:10 <hackagebot> Added by HenningThielemann, Sun Jun  7 19:05:22 UTC 2009.: Event lists with relative or absolute time stamps  http://hackage.haskell.org/cgi-bin/hackage-scripts/package/event-list-0.0.9.1
12:06:13 <Cale> algal: ^^
12:06:40 <PeakerWork> algal: In a lazy language, lists are a fundamental concept, as they basically encapsulate both the data structure and the concept of iteration
12:06:42 <Axman6> anyway, sleep time. night all
12:06:43 <Cale> algal: There's no syntactic sugar for Maps, but they are easy to use.
12:06:59 <PeakerWork> algal: Maps are less fundamental, but easy to use indeed
12:07:07 <ski> PeakerWork : iirc, if you want constructing to require the constraint, and matching to *provide* the constraint, then istr GADT can do that
12:07:10 <PeakerWork> I think List's syntactic sugar is unnecessary, too
12:07:12 <algal> Cool, thanks.
12:07:41 <PeakerWork> ski: thanks for the deeper explanation :)
12:07:49 <ski> PeakerWork : i don't know whether it (what exactly is "it" ?) can break compilations
12:07:50 <byorgey> you can always make your own syntactic sugar for Maps, since defining new operators is so lightweight.
12:08:03 <PeakerWork> ski: an automatic removing of all contexts from ADT's
12:08:07 <algal> byorgey: interesting, don't know anything about operator re-definition. still getting started.
12:08:33 <byorgey> > let x **& y = x + 2 * y in  3 **& 5
12:08:34 <lambdabot>   13
12:08:36 <Cale> algal: Basically, operators are not special in Haskell. Any string of symbol characters is a valid name for an infix function.
12:08:37 <ski>   data Bar :: * -> * where B0 :: Bool -> Bar Int; B1 :: Foo a => Bar a
12:08:53 <algal> cool.
12:08:53 <Cale> (apart from a few special things reserved by the syntax)
12:08:57 <ski> mathcing on `B1' there would *provide* `Foo a' to the local context, iirc
12:09:16 <byorgey> so, e.g. you could make --> an alias for map insertion.  or whatever.
12:09:18 <algal> By the way, is it bad form to use $ as a kind of data-pipe operator? it seems to function that way but I ran into a comment dissing "abuse of $"
12:09:33 <PeakerWork> Except for unboxed arrays and ST -- how does one go about improving Haskell's performance?
12:09:41 <PeakerWork> any other thumb rules like those?
12:09:44 <byorgey> algal: if you have  f $ g $ h $ x, it's considered better style to say  f . g . h $ x  instead
12:09:50 <Cale> algal: $ is a very low-precedence function application operator
12:09:52 <byorgey> . is function composition
12:09:58 <Cale> @src ($)
12:09:59 <lambdabot> f $ x = f x
12:09:59 <david48> Good evening everyone.
12:10:04 <byorgey> hi david48
12:10:10 <algal> yeah but if I'm partially applying something in the middle then I can't use . , right?
12:10:17 <Cale> You can.
12:10:28 <algal> f . g . filter h . j $ data
12:10:36 <Cale> > map head . group . sort $ "what letters are in this string?"
12:10:37 <lambdabot>   " ?aeghilnrstw"
12:10:37 <RayNbow> byorgey: are you familiar with the notation where . both means function composition *and* application?
12:10:42 <algal> hmm.. I clearly need to experiment with operator precedence more.
12:10:55 <Cale> algal: Function application binds tighter than any operator
12:11:03 <algal> Cale: thx
12:11:06 <byorgey> RayNbow: no...
12:11:10 <Cale> algal: That's the rule which is probably more important than any other :)
12:11:14 <byorgey> RayNbow: how would that work?
12:11:41 <PeakerWork> algal: the idea is that the composed functions are typically more useful than the applied functions on the specific value, and the nice artifact of using a.b.c$d  notation means that you can take any valid sub-string in there (e.g:  b.c$d  or a.b) and its a valid sub-expression you can refactor into its own function
12:11:55 <RayNbow> byorgey: this paper by Lambert Meertens on Paramorphisms uses this notation...
12:12:15 <Cale> And just the fact that you *can* do this is often enough to help you think about the code in different ways, even if you don't actually do it.
12:12:21 <RayNbow> and treats values of type A as nullary functions of type A <- 1
12:12:28 <Cale> (with regard to what PeakerWork was saying)
12:12:36 <algal> PeakerWork: I see!
12:12:38 <byorgey> RayNbow: oh, I get it
12:13:11 <byorgey> that's a very category-ish point of view =)
12:13:28 <Cale> algal: Also, there is a growing consensus that $ has the wrong associativity.
12:13:40 * RayNbow has the feeling he has to pick up Awodey's CT book again and continue reading :p
12:13:50 <Cale> and so if you write things like  f $ g $ h $ x  it makes it harder for that to change in the future. :)
12:13:52 <algal> Cale: interesting. What is $ really? hard to find the page on is on the 98 report?
12:13:59 <Cale> It's just defined as
12:14:01 <Cale> f $ x = f x
12:14:20 <algal> oh.
12:14:24 <Cale> But! It has an infix declaration which gives it very low precedence.
12:14:31 <PeakerWork> algal: $ is nothing special, just the fact its very low-precedence function application means its pretty much equivalent to having parenthesis on the full expressions on both of its sides
12:14:33 <Cale> That is, it happens last.
12:14:46 <Cale> (for some definition of happens)
12:14:49 <algal> ok.
12:14:57 <Cale> (which is unrelated to evaluation order -- just grouping :)
12:14:59 <PeakerWork> algal: so instead of having (f g x y) (blah bleh bluh)  you can use:  f g x y $ blah bleh bluh
12:15:20 <algal> and why is the smart money against it, these days?
12:15:37 <PeakerWork> algal: there is quite a bit in Haskell's syntax dedicated to having less redundant ()'s. I think maybe someone was burned by a Lisp experience :-)
12:15:38 <Cale> The abuse is just when you chain more than one in a row
12:15:56 <ehird> 20:13 Cale: algal: Also, there is a growing consensus that $ has the wrong associativity.
12:15:57 <ehird> really?
12:16:05 <Cale> ehird: At least around here :)
12:16:08 <RayNbow> hmm, a new sigfpe blogpost...
12:16:26 <ehird> Cale: so a $ b $ c $ d -> a b c d?
12:16:26 <PeakerWork> ehird: having the same associativity as (.) means that they overlap where they could cover more useful territory
12:16:29 <ehird> that's wacko
12:16:32 <Cale> One $ is okay, but if you're writing something like f $ g $ h $ x, it's better style to write f . g . h $ x
12:16:35 <ehird> a $ b is intuitively a (b) to me
12:16:38 <ehird> and yeah, I know that
12:16:39 <ehird> still
12:16:41 <algal> Cale: interesting, the abuse was the only usage that attracted me, naively.
12:16:51 <PeakerWork> ehird: why not (a) (b) ?
12:16:57 <ehird> PeakerWork: well, sure, whatever
12:16:59 <ehird> that's not the point :)
12:17:12 <mauke> f $ x $ y
12:17:38 <algal> a shame we only have capitalized and non-capitalized. would love a way to distinguish types vs  functions vs  variable, instead of just types vs. (functions or variables)
12:17:40 <Cale> f $ x $ y  would be equal to  f x y  if there were any justice in the world. But it's not.
12:18:01 <bremner> tanj!
12:18:06 <Cale> Instead we have that it's equal to  f (x y)
12:18:09 <dev31212> ok, be back later
12:18:17 <ehird> Cale: that's wacko.
12:18:23 <Cale> (because $ is defined as right associative)
12:18:24 <ehird> i can't see why you would want that
12:18:38 <algal> Cale: thx
12:18:46 <mauke> f $ sqrt x $ y + 1
12:18:50 <Cale> ehird: Every use of multiple $'s right now can be replaced by one which uses only one $ and function composition.
12:18:52 <inimino> Cale: you could introduce a left-associative operator and get people to use it in new code
12:18:57 <ehird> Cale: sure, and it's prettier that way
12:18:58 <PeakerWork> ehird: because you can already express f (g y)   with f . g $ y
12:19:09 <ehird> i suppose f $ a b $ c d could be useful BUT
12:19:13 <Cale> ehird: But if $ was left associative, then we could write  f $ g x y $ h y z, for instance
12:19:15 <ehird> to me that's clearer & prettier as f (a b) (c d)
12:19:24 <Cale> Also, consider $!
12:19:31 <Cale> Have you ever tried to use $! ?
12:19:41 <skorpan> :t ($!)
12:19:42 <lambdabot> forall a b. (a -> b) -> a -> b
12:19:47 <skorpan> @src ($!)
12:19:47 <lambdabot> f $! x = x `seq` f x
12:19:53 <skorpan> ah well... :P
12:19:55 <Cale> I think anyone who does quickly runs into the problem that they have to bracket their expressions in a funny way to use it.
12:20:04 <Cale> Essentially forcing $! to be left associative.
12:20:13 <hackagebot> Added by HenningThielemann, Sun Jun  7 19:19:29 UTC 2009.: An experimental alternative hierarchy of numeric type classes  http://hackage.haskell.org/cgi-bin/hackage-scripts/package/numeric-prelude-0.1.1
12:20:43 <Cale> But we certainly would not want $! and $ to have opposite associativities.
12:21:11 <Cale> inimino: But there are not many characters which are free or which I'd be willing to steal.
12:21:38 <mauke> €
12:21:58 <Cale> I can't type € very easily.
12:22:01 <PeakerWork> ehird: you realize that the choice is pretty arbitrary, and that you're simply more used to one style than the other?
12:22:20 <ehird> PeakerWork: yes, but i don't think either way is useful
12:22:20 <ehird> :P
12:22:41 <Cale> Basically, since function application is always left associative, $ and $! should be as well :)
12:23:26 <Cale> Can you imagine what things would be like if function application associated to the right by default in Haskell?
12:23:45 <Cale> Using functions with multiple parameters would be painful :)
12:23:51 <ehird> Cale: that could be fun
12:23:52 <inimino> Cale: use a Unicode character
12:23:52 <mauke> that's what tuples are for
12:23:58 <ehird> printf "%s" b
12:23:59 <ehird> →
12:24:00 <Cale> inimino: Same problem.
12:24:02 <ehird> printf ("%s" b)
12:24:06 <PeakerWork> Cale: it could be nice if it was rassoc AND flipped
12:24:08 <Cale> inimino: It's too hard to type
12:24:12 <ehird> so we'd have strings = constructors
12:24:12 <ehird> :-D
12:24:14 <PeakerWork> Cale: kind of like FORTH :)
12:24:26 <inimino> it's not hard in any decent text editor
12:24:26 <Cale> I mean that f x y z would mean f (x (y z))
12:24:29 <inimino> I think Haskell users can handle it :)
12:24:36 <Asztal> £ is easy to type (for me, anyway :)
12:24:36 <Cale> That would be annoying!
12:24:46 <ehird> Asztal: ALL YOU THINK ABOUT IS ££££
12:24:50 <ehird> doesn't really have the same ring does it
12:26:15 <Cale> You would constantly be bracketing things to the left
12:26:43 <Tsion> (((f x) y) z)
12:26:52 <Tsion> imagine coding like that for a day :S
12:26:52 <Cale> Mind you, that is a bit of a straw man, but there is an analogy to be made there.
12:27:08 <Tsion> It's like Lisp, heh
12:27:16 <PeakerWork> Lisp with currying everywhere
12:27:53 <Cale> Basically, I think we should encourage the style which makes maximal use of function composition.
12:28:10 <paolino> anyone is able to fill a combobox with gtk2hs , using the ListStore String ?
12:29:05 <Cale> (.) is an associative operator, which seems like maybe it's not a big deal, but it really gives you a lot of ways to break down and think about code written with it.
12:29:48 <ehird> lisp is inherently inelegant because you can't reduce it to currying without adding an (a b c d) → (((a b) c) d) hack
12:29:50 <ehird> /semi-random
12:31:49 <mauke> lisp is inherently inelegant because you can't write a g such that (f x y z) == (f (g x y z))
12:32:03 <Cale> If you have something like f $ g $ h $ x with the current right associative $, then the subexpressions are f, g, h, x, h $ x, g $ h $ x, f $ g $ h $ x. So there are 7 of them. If you have f . g . h $ x, the effective subexpressions are f, g, h, x, f . g, g . h, h $ x, f . g . h, g . h $ x, and f . g . h $ x, so there are 10 of them. As the chain gets longer, this effect becomes more pronounced.
12:33:00 <dons> http://shootout.alioth.debian.org/u64q/shapes.php  star graphs of haskell
12:33:06 <algal> poor lisp. gets beat up even by the haskellers.
12:33:12 <Cale> (essentially linear vs. quadratic growth)
12:33:36 <ehird> 20:31 mauke: lisp is inherently inelegant because you can't write a g such that (f x y z) == (f (g x y z))
12:33:36 <ehird> ↑ you can in scheme, with a little bit of bending the standard
12:33:55 <ehird> (f (values 1 2 3)) is undefined and its meaning is debated, so...
12:33:59 <mauke> come on, this is trivial in perl
12:34:02 <mauke> sub g { @_ }
12:34:18 <ehird> mauke: besides
12:34:29 <ehird> you can't write a g such that (f x y z) == (f (g x y z)) in Haskell, mauke
12:34:46 <mauke> yeah, but (f x y z) means something different in haskell
12:35:04 <mauke> haskell sidesteps the issue by simply not having parameter lists
12:35:31 <algal> thansk for all the help
12:36:04 <donnelly> A library packaging question:
12:36:17 <donnelly> I wrote a little toy graphics library, similar in concept to chalkboard.
12:36:37 <donnelly> Then I got ambitious, and now the library has support for drawing with GTK, WX, and GD.
12:37:00 <donnelly> Now I'm trying to figure out cabal, and I want to package it so that the support code for GTK or WX or GD is optional.
12:37:13 <donnelly> What's the recommended way to achieve that?
12:37:38 <ehird> donnelly: yi does it with flags.
12:37:45 <ehird> but then you have to explicitly specify it, to wit:
12:37:54 <ehird> cabal install magicdrawything -fgtk -fwx -fgd
12:38:00 <donnelly> hmm
12:38:12 <donnelly> I considered doing it as multiple packages
12:38:16 <donnelly> as in
12:38:18 <ehird> donnelly: that is probably the best option
12:38:25 <donnelly> 'Library', 'Library.WX', 'Library.GTK'
12:38:39 <aavogt> ehird: the flags can be on by default
12:38:49 <ehird> aavogt: but that'll fail if you don't have e.g. gtk/wx/gd
12:38:52 <paolino> Cale, any help with gtk2hs, please ?
12:38:55 <ehird> donnelly: +1 for the separate packages idea
12:38:59 <donnelly> but then the question becomes, how do I specify that in the cabal file?
12:39:04 <ehird> it'll be a lot clearer
12:39:10 <ehird> donnelly: oh, i thought you meant separate
12:39:13 <donnelly> do I have to keep it all in separate trees and files?
12:39:14 <ehird> as in, separate hackage releases and all
12:39:17 <ehird> and yes
12:39:20 <donnelly> hmm
12:39:32 <donnelly> i was hoping for a more elegant solution
12:39:41 <Cale> paolino: sorry, what was your question?
12:39:48 <Cale> paolino: oh...
12:40:07 <ehird> donnelly: it is quite elegant imo :)
12:40:11 <ehird> encapsulation and all
12:40:13 <paolino> Cale, to fill a combobox, should be trivial ...
12:40:19 <donnelly> for some definition of elegant, yes
12:40:21 <Cale> paolino: err... I haven't really used that part of gtk2hs before, but I can try to figure out how it's done :)
12:41:00 <donnelly> but I'd really like to keep all the associated code in the same source tree, and I'm not exactly sure how to do that and still make multiple separate libraries
12:41:11 <paolino> Cale: thanks
12:41:45 <Cale> comboBoxModel :: (ComboBoxClass self, TreeModelClass treeModel) => ReadWriteAttr self TreeModel treeModel
12:42:20 <Cale> paolino: and a ListStore is an instance of TreeModelClass
12:42:52 <Cale> So you should be able to  set myComboBox [comboBoxModel := myListStore]
12:43:16 <Heffalump> donnelly: what exactly do you mean by same source tree?
12:43:34 <Heffalump> would different subdirectories, but using -idir1 -idir2 -idir3 when developing the code be enough?
12:43:45 <paolino> Cale: myListStore being ?
12:43:56 <Cale> paolino: The ListStore value which you mentioned having
12:44:07 <paolino> le <- G.listStoreNew r
12:44:20 <donnelly> Heffalump: mainly, the same repository in a VCS
12:44:40 <Heffalump> donnelly: well, that's fine, you just have the VCS control the directory at the top
12:44:40 * paolino tries "set"
12:44:48 <Heffalump> and put the cabal packages into subdirectories
12:46:10 <donnelly> Yeah, I suppose that's the best option, I just wanted to make sure there wasn't some facility for that kind of thing that I was missing
12:47:50 <paolino> Cale, still an empty combobox
12:48:05 <Cale> paolino: Did you insert items into the ListStore?
12:48:13 <paolino> :) yes
12:48:16 <paolino> strings
12:48:23 <Cale> hmm
12:48:26 <Cale> I will try it.
12:49:48 <paolino> Cale , how can it be that there is no constraints on the a of ListStore a ?
12:51:25 <Cale> What? Oh, I was looking at the wrong documentation.
12:51:39 <Cale> (there's apparently also an order ListStore with no type parameter)
12:51:42 <Cale> older*
12:53:55 <paolino> that with the TMs, I 've lost time there also :)
12:54:05 <bremner> any of you ever call a Haskell library from perl (i.e. not via shell, but via some FFI or so)?
12:54:13 <performance> hurraahhh, at last despite my stupidity, i got Leksah to build and install and finally work :) now to actually do something with it
12:54:21 <hackagebot> Added by RemcoNiemeijer, Sun Jun  7 19:53:21 UTC 2009.: Benchmarking code through strict evaluation  http://hackage.haskell.org/cgi-bin/hackage-scripts/package/StrictBench-0.1
12:54:59 <TomMD> dons: ping
12:55:21 <performance> @seen Ycros
12:55:22 <lambdabot> Ycros is in #haskell-blah, #haskell-in-depth, #arch-haskell and #haskell. I last heard Ycros speak 7h 37m 40s ago.
12:55:44 <Heffalump> bremner: I've done the reverse
12:56:09 <dons> TomMD: pong
12:56:14 <bremner> Heffalump, I want to call pandoc from ikiwiki, so direction is important :-)
12:56:26 <FalconNL> Does anybody happen to have a checklist of the required steps to get the documentation for your module on Hackage? Apparently I've missed something.
12:56:34 <Ycros> performance: hmm?
12:56:45 <Heffalump> FalconNL: did you wait a bit
12:56:49 <Ycros> performance: oh, congratulations
12:56:51 <Heffalump> it takes some time for it to build the docs
12:57:00 <performance> ycros, :) thanks, ultimately i got leksah to work
12:57:38 <FalconNL> Heffalump: It's probably been about a minute or two since I uploaded it. How long is it supposed to take?
12:57:52 <performance> now to play with some graphics and music
12:58:01 <Ycros> performance: yay
12:58:24 <Heffalump> FalconNL: not sure, but I think potentially some hours
12:59:10 <FalconNL> Heffalump: Really? Ok, can't imagine why it should take that long, but I guess I'll wait
12:59:46 <Heffalump> I'm not quite sure either. It's a pain, because I see stuff on RSS and want to look at the docs immediately
13:02:41 <paolino> Cale, also I'm using glade-3, maybe that combobox is not the right version for the ListStore ....
13:03:57 <FalconNL> Anyway, I just uploaded a little convenience library for benchmarking the strict evaluation of a value: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/StrictBench (see the home page link for a short example).
13:04:03 <pumpkin> @where+ whyt http://whathaveyoutried.com/
13:04:04 <lambdabot> It is stored.
13:04:55 <malouin> Does anyone use Data.BerkeleyDB (distinct from Data.Berkeley.DB)?
13:05:18 <Gracenotes> :>
13:05:31 <malouin> I have spent about 3 hours trying to figure out how to create/open/close a bdb with this module.
13:06:04 <malouin> the interface is seductive, but apparently equally elusive.
13:07:05 <ehird> 21:04 malouin: Does anyone use Data.BerkeleyDB (distinct from Data.Berkeley.DB)? ← this is the problem with the naming conventions
13:07:26 <Cale> paolino: oh, hmm...
13:07:45 <Cale> paolino: I just noticed the existence of comboBoxSetModelText, but one moment, I want to try this other way
13:07:45 <dmwit> How is that a problem with the naming conventions?  I'd say any language that has two libraries for a particular use will have problems like that.
13:08:07 <paolino> Cale, that is the first I tried
13:11:13 <Cale> hey, I got it to work :)
13:11:25 <Cale>      combo <- getWidget castToComboBoxEntry "comboboxentry1"
13:11:25 <Cale>      ls <- comboBoxEntrySetModelText combo
13:11:25 <Cale>      mapM_ (listStoreAppend ls) ["hello", "there", "world"]
13:12:06 * Cale tries with a plain combo box
13:12:09 <ehird> Cale: looks like a prime suspect for abstraction there
13:12:15 <ehird> ehm
13:12:18 <ehird> replace subject with a proper word.
13:12:20 <ehird> er.
13:12:21 <ehird> suspect. argh.
13:12:59 <Cale> Yes, it works similarly with a normal uneditable combo box
13:13:27 <hackagebot> Added by JinjingWang, Sun Jun  7 20:13:05 UTC 2009.: A simple blog middleware on hack  http://hackage.haskell.org/cgi-bin/hackage-scripts/package/bamboo-2009.6.8
13:14:13 <ehird> "A simple blog middleware on hack"?
13:14:19 <Cale> But I wonder what this comboBoxModel property is in general...
13:14:38 <pumpkin> *on crack
13:14:38 <ehird> "Bamboo is a port of Panda, but runs on top of Hack."
13:14:39 <ehird> Ah.
13:14:43 <ehird> ... how is that middleware?
13:14:57 <ehird> Enterprise middleware ajax 2.0
13:15:21 <pumpkin> http://jinjing.easymic.com/ ooh
13:15:24 <pumpkin> he's running it himself
13:15:31 <ehird> wait
13:15:35 <ehird> pumpkin: that's the original author of Panda
13:15:42 <ehird> how confusing
13:16:27 <hackagebot> Added by JinjingWang, Sun Jun  7 20:15:20 UTC 2009.: bamboo blueprint theme  http://hackage.haskell.org/cgi-bin/hackage-scripts/package/bamboo-theme-blueprint-2009.6.8
13:16:27 <ehird> @quote ehird
13:16:28 <lambdabot> ehird says: 2009: The Year of the Combinatorial Explosion of Haskell Web Frameworks. Also, the Linux Desktop.
13:16:37 <ehird> ↑ totally accurate
13:17:04 <BMeph> ehird: s/suspect/candidate/ maybe? :)
13:17:18 <ehird> BMeph: yes :P
13:19:28 <hackagebot> Added by JinjingWang, Sun Jun  7 20:18:43 UTC 2009.: bamboo-launcher  http://hackage.haskell.org/cgi-bin/hackage-scripts/package/bamboo-launcher-2009.6.8
13:19:38 <Botje> @pl minimaal p = or . fmap not . fmap meerderheid . filter (== p) $ subsequences p
13:19:38 <lambdabot> minimaal = ap (((or . fmap (not . meerderheid)) .) . filter . (==)) subsequences
13:20:07 <malouin> ehird: well, to bamboo's credit, at least Middleware has a technical meaning in Rack/Hack
13:20:21 <ehird> in rack it's just app→app
13:20:26 <ehird> but i can't see why a blog would do that
13:20:29 <ehird> wouldn't it just be app?
13:20:37 <malouin> ehird: I had the same question the other day.
13:20:39 <mike-burns> Nah, it's a Middleware in Rack.
13:20:41 <ehird> heh
13:20:52 <ehird> mike-burns: ?
13:20:54 <paolino> Cale, thanks, that library is just to messy/complex  for me :-/
13:21:14 <mike-burns> A Rack middleware is something that implements #call. By analogy to the Hack middleware.
13:21:35 <ehird> mike-burns: Sorry, you're completely wrong.
13:21:45 <mike-burns> What is a Rack middleware then?
13:21:47 <ehird> That's a Rack _application_, and furthermore, Hack is based on Rack, not the other way around.
13:22:08 <ehird> mike-burns: A Rack middleware is a Rack application that has Rack application "inside" and wraps over it.
13:22:18 <ehird> That is, \app -> \env -> ... pass to app, mangle, etc ...
13:22:28 <ehird> There seems to be no reason why some blog software would be one.
13:23:28 <mike-burns> So a Rack middleware implements #call but does something else?
13:23:42 <malouin> maybe they are expecting the common case to be passing the identity Application, heh.
13:23:44 <ehird> mike-burns: Rack middleware is-subset-of Rack application.
13:24:15 <ehird> mike-burns: Rack middleware is just an informal term for an application you create by doing FooMiddleware.new(FooApp.new)
13:24:24 <ehird> It might, say, add a unicorn to every one of FooApp's page.
13:24:31 <ehird> Or change /pony to display a pony and pass every other request through.
13:24:38 <ehird> Or catch errors and display a pretty page, etc. etc. etc.
13:24:50 <mike-burns> Okay.
13:25:18 <ehird> So yeah; no idea why blog software would be middleware.
13:25:19 * malouin is using Hack atm.
13:25:21 * Cale fails to understand what is being discussed.
13:25:45 <ehird> Cale: Hack, which is a port of Ruby's rack.
13:25:46 <malouin> Cale: the hackagebot announcement about bamboo
13:25:51 <ehird> And why Bamboo is a Hack middleware.
13:25:54 <ehird> Instead of a Hack application.
13:26:29 <RyanT5000> does anyone know how to get checkers-0.1.4 running on ghc-6.10.3?
13:26:51 <RyanT5000> (i'm trying to install reactive-fieldtrip, and cabal install is failing to install checkers)
13:26:59 <malouin> I quite like Hack though, for not really doing anything it is pretty handy.
13:27:19 <BMeph> So, does Ruby have a nice rack? ;p
13:28:37 <ehird> BMeph: You're so witty.
13:29:00 <Asztal> if you mean the AMD/ATI demo girl, then yes :)
13:29:22 <BMeph> ehird: Eh, I blame early-onset senility; I turn 40 on Tuesday. ;p
13:29:33 <Ycros> sif credit Ruby though
13:29:36 <ehird> BMeph: Wow, you're aaaaaaancient. Like a fossil.
13:29:38 <ehird> An alive fossil.
13:29:54 <Ycros> Rack is based off Python's WSGI, which was probably inspired in part by Java's servlet APIs
13:30:09 <ehird> which was, in a time accident, based off Hack
13:30:19 <Ycros> thus we come full-circle
13:30:59 <BMeph> ehird: Well, I'm not augustss' age, but I aspire to it. I aspire to a lot of his accomplishments, but I'm thinking that his age may be one I can match. ;)
13:31:01 <dmwit> a time machine.  I accidentally created
13:31:29 <ehird> BMeph: older than 40? Impossible. I therefore conclude that augustss is -40 years old. Wrapping integers!
13:32:02 <ehird> dmwit: it's actually "Machine. Unexpectedly, I'd invented a time"
13:32:03 * BMeph pages augustss, pointing to ehird's remark...
13:32:11 <pumpkin> BMeph: omg!
13:32:19 <ehird> BMeph: ssh! He will destroy us all with the power of his not-being-born-yet.
13:32:34 <BMeph> Now I understand that meme...
13:32:51 <ehird> BMeph: Wait, which meme
13:33:03 <BMeph> the whole thing. Is that dangerous? I accidentally
13:33:08 <ehird> !
13:41:57 <BMeph> RyanT5000: I've noticed that sometimes, cabal installs get stalled. Try killing the process and re-trying it - checkers installed for me, but I haven't tried it out, so it may not work; I'll check.
13:42:14 <RyanT5000> BMeph: it's not stalled; it has an actual error
13:42:25 <RyanT5000> src/Test/QuickCheck/Checkers.hs:56:7:
13:42:25 <RyanT5000>     Could not find module `Test.QuickCheck.Utils':
13:42:25 <RyanT5000>       it is a member of the hidden package `QuickCheck-1.2.0.0'
13:42:25 <RyanT5000>       Use -v to see a list of the files searched for.
13:44:15 <RyanT5000> i've run ghc-pkg expose QuickCheck-1.2.0.0, though
13:45:33 <BMeph> RyanT5000: That shouldn't be a problem if the checkers package is set right - which it looks like to me: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=5634#a5634
13:46:35 <RyanT5000> oh; maybe if i try to install checkers-0.2, it'll work
13:49:20 <BMeph> RyanT5000: Maybe. I just installed checkers (no qualification) by itself, and it loaded up just fine - as my ghc-pkg list showed. :)
13:55:15 <hape> hi everybody, i try using ghci and want to edit my files with emacs. i've set   ":set editor emacs" - fine, but when i open a file with ":edit a.hs" emacs is blocking the ghci shell, until i end it. how can i go in parallel on both, emacs and ghci?
13:56:13 <dmwit> hape: Use screen, or two terms?
13:56:36 <hape> sorry, i did not understand. what do you mean with screens?
13:56:45 <dmwit> ?go screen multiplexer
13:56:48 <lambdabot> http://www.bangmoney.org/presentations/screen.html
13:56:48 <lambdabot> Title: screen - The Terminal Multiplexer
13:56:57 <mike-burns> hape: Set the editor to a shell script that launches emacs in the background?
13:58:17 <hape> sorry i am new to this materia. ghci is already opening emacs in another window, but i cannot go on in ghi with entering commands, until i leave emacs window and close it.
13:58:28 <hape> "in ghci"
13:58:53 <SamB> hape: well, how about you start your own emacs window instead?
13:59:08 <SamB> using the "&" to make it not block your shell
13:59:21 <andrewsw> why not run ghci within emacs?
13:59:21 <SamB> *then* start ghci
13:59:27 <hape> & i now, but this did not work in the ghci command :set editor emacs &
13:59:29 <SamB> or, yeah, you could run ghci inside emacs
13:59:51 <SamB> hape: well, I personally just run my own emacs
13:59:58 <hape> Thank you
14:00:55 <SamB> you could submit a ticket requesting that ":set editor emacs &" try to run emacs asynchronously, though
14:01:28 <hape> SamB: i could do this, am i right i find on haskell.org a ticket box?
14:01:41 <SamB> let me see...
14:01:45 <SamB> @go ghc trac
14:01:47 <lambdabot> http://hackage.haskell.org/trac/ghc/
14:01:47 <lambdabot> Title: GHC - Trac
14:01:58 <SamB> hape: there should be something easy to find there
14:01:58 <hape> perfect :-) thanks i do this
14:02:03 <hape> thanks
14:03:25 <andrewsw> hape: there is an emacs library "haskell-ghci" that does some nice stuff like "haskell-ghci-load-file" etc
14:04:02 <hape> andrewsw, i will have a look on that, thanks
14:10:20 <RyanT5000> how do i get cabal-install installed globally?
14:10:27 <RyanT5000> (instead of in ~/.cabal/)
14:10:31 <Heffalump> configure cabal to install things globally
14:10:43 <Heffalump> there should be a commented out line in ~/.cabal/config to that effect
14:10:43 <thoughtpolice> RyanT5000: it should be in ~/.cabal/config
14:10:50 <RyanT5000> thoughtpolice: thanks
14:10:51 <Heffalump> then cabal install cabal-install
14:11:53 <RyanT5000> Heffalump: thanks :)
14:15:50 <RyanT5000> after changing the config of cabal install to generate profiling for all the libraries, is there a way to make it rebuild *all* my libraries with profiling?
14:16:07 <RyanT5000> (including the ones already installed)
14:22:36 <dmwit> RyanT5000: I don't think there's a convenient way.
14:22:44 <RyanT5000> dmwit: alright, np
14:22:51 <dmwit> RyanT5000: However, several people have asked for this, so you should check for a cabal bug and vote for it. =)
14:23:23 <RyanT5000> where's the bug tracking system?
14:25:57 <dmwit> uh...
14:25:59 <dmwit> dunno?
14:26:12 <RyanT5000> dmwit: alright; i'll look around
14:26:19 <dmwit> http://hackage.haskell.org/trac/hackage/wiki/CabalInstall looks promising
14:32:51 <skorpan> i cabal installed xmobar but "ghc-pkg unregister xmobar" tells me it's not found
14:32:53 <skorpan> any ideas?
14:34:34 <skorpan> it's not shown in "ghc-pkg list" either
14:34:37 <skorpan> but i'm sure it's installed?
14:35:11 <skorpan> meh
14:44:03 <alexsuraci> I'm getting an "incorrect header check" error with the Zlib lib, anyone know what that means besides that the header check was incorrect? ;)
14:44:41 <alexsuraci> A primitive inspection of what I'm trying to unzip seems to line up with what decompress expects (both the data and a compressed string test begins with "x\156")
14:47:38 <alexsuraci> afaik the unzipping works fine with Python's zlib, I'll test now
14:47:42 <dmwit> ?tell skorpan I don't think xmobar is a library, so it shouldn't be listed in ghc-pkg list.
14:47:43 <lambdabot> Consider it noted.
14:48:40 <dmwit> alexsuraci: It sounds like there's some checksum that didn't sum. =P
14:49:00 <alexsuraci> oh boy :P
14:51:04 * pumpkin wishes more GHC hackers were in non-European timezones
14:52:01 <Alpounet> are there that much European GHC hackers ?
14:52:18 <pumpkin> most of them seem to be in the UK :)
14:54:47 <sioraiocht> pumpkin: probably because UK universities love to teach Haskell
14:55:52 <p_l> sioraiocht: only few of them, it seems
14:56:32 <p_l> I'm getting Haskell only in last year, in a course about "alternative computation models"
14:56:58 <pumpkin> lol
14:57:01 <mmorrow> does anyone know if there's a particular latex symbol used for '::' ?
14:57:32 <pumpkin> I know that agda has a special symbol for it
14:57:37 <pumpkin> so unicode must define one
14:57:45 <mmorrow> yeah, there's the unicode one
14:57:57 <pumpkin> \dblcolon
14:58:01 <mmorrow> woot, thx
14:58:10 <mmorrow> (was that a guess?)
14:58:10 <sioraiocht> p_l: which uni?
14:58:15 <Gracenotes> hrm. It seems the longest Haskell solution for the shootout is even longer than the longest C one...
14:58:16 <pumpkin> mmorrow: http://www.ctan.org/tex-archive/info/symbols/comprehensive/symbols-a4.pdf
14:58:16 * mmorrow finds out
14:58:23 <Gracenotes> must be the hash table implementation :/
14:58:24 <mmorrow> pumpkin: i've got that open :)
14:58:27 <pumpkin> mmorrow: :D from mathtools apparently
14:58:27 <p_l> sioraiocht: University of Aberdeen
14:58:31 <Gracenotes> silly built-in implementation
14:58:43 <mmorrow> \dblcolon is a sneaky one
14:58:45 <sioraiocht> p_l: ah.  Well, most people in the US _never_ see it
14:58:54 <pumpkin> whenever I'm writing a mathematical document in LaTeX I have that document open
14:59:44 <pumpkin> mmorrow: have you noticed the \Maggie
14:59:49 <pumpkin> \Marge etc.
15:00:05 <p_l> sioraiocht: in Edinburgh, I had seen haskell book packaged together with Java book, apparently targeting CS majors :D
15:00:05 * BMeph says, "D'OH!"
15:00:24 <sioraiocht> p_l: that's ashame, CS majors shouldn't have to be targeted with Java =p
15:00:42 <pumpkin> mmorrow: did it work?
15:01:25 <pumpkin> there's also \squaredots that approximates it
15:01:27 <pumpkin> but is too square
15:02:09 <Gracenotes> you're too square, pumpkin!
15:02:38 <pumpkin> :(
15:03:15 <pumpkin> does anyone here know what the "desugaring" rules are for FFI declarations?
15:03:21 <mmorrow> oh yesh worked nicely
15:03:29 <pumpkin> the only FFI spec I can find doesn't mention implementation
15:03:32 <mmorrow> (i dunno how i feel about it though, it's kinda narrow)
15:03:54 <pumpkin> and \squaredots is too wide
15:03:57 <mmorrow> grr
15:04:08 <duaneb> so
15:04:11 <duaneb> I have been hired
15:04:11 <duaneb> to
15:04:16 <pumpkin> how about :\hspace -x: ?
15:04:19 <duaneb> essentially write a replacement for gmp
15:04:20 <mmorrow> i've always wanted to learn metapost .. (now's not the time though ;)
15:04:26 <pumpkin> duaneb: :o by whom?
15:04:37 <duaneb> pumpkin: a local professor
15:04:44 <duaneb> so
15:04:46 <pumpkin> duaneb: funny you should mention that :P
15:04:52 <pumpkin> mmorrow: just a pair of colons with a negative h space between them?
15:05:03 <mmorrow> duaneb: what's his gain from paying you?
15:05:15 <duaneb> mmorrow: he gets a gmp replacement
15:05:22 <pumpkin> he doesn't want GPL?
15:05:24 <mmorrow> pumpkin: oh i'm sure i'd go off the deep end if i ever get around to learning metapost
15:05:26 <duaneb> anyway, I can license it however I want to
15:05:38 * pumpkin is puzzled
15:05:40 <bremner> duaneb, AGPL3
15:05:42 <duaneb> just so long as he can use it for his own work
15:05:50 <pumpkin> mmorrow: any idea on how FFI is implemented in GHC?
15:06:09 <mmorrow> duaneb: what in particular do you mean by "implemented"?
15:06:13 <duaneb> I understand that haskell has had problems with gmp; anyone have any specific problems with is right now?
15:06:14 <mmorrow> err, @pumpkin
15:06:37 <duaneb> I've found this: http://hackage.haskell.org/trac/ghc/wiki/ReplacingGMPNotes
15:06:48 <pumpkin> mmorrow: well, given that at the stage of compilation at which I need the FFI, base does not exist, I can't use IO, Foreign.C.Types (I got around that with unlifted FFI types), and the like
15:07:06 <duaneb> bremner: I'm probably going to do MIT
15:07:07 <mmorrow> duaneb: pumpkin's been hacking on essentially this exactly for a little while now
15:07:17 <p_l> duaneb: good luck
15:07:19 <bremner> duaneb, AGPL was not a serious suggestion
15:07:20 <pumpkin> mmorrow: and trying to replace IO with a State# RealWorld -> (# State# RealWorld, a #) makes ghc complain about it being inappropriate
15:07:30 * p_l failed MIT application ^_^
15:07:51 <mmorrow> pumpkin: ah, so State# realworld stuff is IO without the monad
15:07:54 <Gracenotes> p_l: failed to get in? Me too! :D
15:07:56 <duaneb> p_l: thanks :)
15:08:04 <pumpkin> duaneb: I'd take the task of writing a gmp replacement separately from integrating it with GHC
15:08:05 <mmorrow> pumpkin: you just have to use case to sequence
15:08:07 <duaneb> I'll be living in c/assembly for the next three months :|
15:08:08 <bremner> p_l, don't worry, I know someone denied as a student, succeeded as a prof :-)
15:08:16 <pumpkin> mmorrow: yeah, except the FFI doesn't like that
15:08:24 <pumpkin> it complains that the type isn't suitable for an FFI declaration
15:08:27 <mmorrow> pumpkin: ohh
15:08:29 <pumpkin> so it wants IO, but I have no IO to give it
15:08:36 <mmorrow> pumpkin: is this in cmm?
15:08:40 <pumpkin> nope, just plain haskell
15:08:45 <pumpkin> but haskell - base package
15:08:46 <p_l> bremner: I'm more angry at not *trying* to go on MEXT scholarship
15:09:06 <pumpkin> mmorrow: it says   Unacceptable argument type in foreign declaration: State# RealWorld
15:09:17 <duaneb> pumpkin: what's your approach to the problem?
15:09:17 <mmorrow> pumpkin: hmm, maybe just fabricate your own fake IO (equivalent to the regular in all respects), an unsafeCoerce
15:09:39 <pumpkin> duaneb: well, so far I've been working with Igloo's replacement, called integer-simple (http://darcs.haskell.org/packages/integer-simple/)
15:09:45 <Gracenotes> Unacceptable!
15:09:47 <mmorrow> pumpkin: ohh, also you can just not have the result be in IO too
15:09:51 <alexsuraci> ok, tested GHC zlib vs. Python zlib, GHC zlib fails with "incorrect header check" where Python zlib decompresses fine
15:10:04 <pumpkin> mmorrow: yeah, but then GHC might optimize it incorrectly?
15:10:10 <mmorrow> foreign import ccall unsafe "malloc" malloc :: Int -> Int -- ;)
15:10:17 <p_l> duaneb: Wait, you applying for class of 2013 or 2014? Because 2013 should have their acceptance letters already
15:10:23 <mmorrow> pumpkin: we'll find out :)
15:10:33 <alexsuraci> Even made sure they have the same zlib options.
15:10:37 <pumpkin> mmorrow: lol
15:10:41 <mmorrow> pumpkin: (it doesn't seem like you have many options)
15:10:48 <pumpkin> duaneb: be aware that if your goal is actually to _be_ GHC's integer replacement, you can't use any of the functionality in the base library
15:10:54 <duaneb> p_I: err, what?
15:10:58 <pumpkin> mmorrow: Igloo was talking about moving IO out of base and into prim
15:11:14 <pumpkin> but that seems like more than what I want to do
15:11:23 <duaneb> pumpkin: what base library?
15:11:39 <pumpkin> _the_ base library :P the library that contains pretty much everything you're used to
15:11:43 <mmorrow> pumpkin: what's the sig of the particular C function you're trying to import, and what's the type that you ave?
15:11:45 <mmorrow> *have
15:11:46 <duaneb> pumpkin: I'm writing it in c
15:11:53 <pumpkin> duaneb: ah
15:11:55 <p_l> duaneb: Well, undergraduates starting this year would have already gotten their acceptance letters. So unless you're applying for a year later or as graduate, you'd have your letter already
15:12:05 <duaneb> p_I: what are you talking about? :P
15:12:18 <p_l> duaneb: concerning MIT ;-)
15:12:26 <pumpkin> duaneb: did you see the jmp gmp replacement linked from the replacing gmp bug? mmorrow also had a self-contained gmp link
15:12:28 <duaneb> oh
15:12:30 <duaneb> hell no
15:12:36 <duaneb> I'm going to caltech next year :D
15:12:56 <mmorrow> duaneb: ah, those were links into the gmp src
15:12:59 <pumpkin> mmorrow: well, even something like mpz_init (mpz_t integer)
15:13:04 * p_l dropped caltech from his list very fast
15:13:11 <pumpkin> where mpz_t is a typedef struct[1]
15:13:29 <pumpkin> basically a pointer :P
15:13:34 <duaneb> pumpkin: http://hackage.haskell.org/trac/ghc/attachment/ticket/601/jmp.c?
15:13:36 <duaneb> err
15:13:39 <pumpkin> duaneb: yeah
15:13:41 <duaneb> that question mark on the end isn't part of the URL
15:13:47 <duaneb> yea, I've been perusing it
15:13:57 <pumpkin> duaneb: mmorrow also had a gmp-in-a-file thing
15:14:03 <mmorrow> err, so what's the type of the C function and what do you need to squirt through the call hole?
15:14:12 <duaneb> ahh
15:14:13 <duaneb> well
15:14:16 <pumpkin> http://moonpatio.com/repos/LIBS/Language/ghc/gmp/gmp-4.2.1/dumbmp.c
15:14:31 <duaneb> I'm in the "let's think about it" stage right now
15:14:42 <duaneb> I'm trying to figure out about multiple custom allocators :P
15:15:05 <pumpkin> mmorrow: I don't understand? what I have so far for that foreign import is foreign import ccall "__gmpz_init" mpz_init :: MPZ -> IO () where MPZ is Ptr MPZT and MPZT is a void type
15:15:18 <mmorrow> duaneb: this header is some nice light reading http://moonpatio.com/repos/LIBS/Language/ghc/gmp/gmp-4.2.1/gmp-impl.h
15:15:23 <alexsuraci> Anyone know what's going wrong here? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5637#a5637
15:15:47 <mmorrow> pumpkin: ahh, cool. so you can just drop the IO and have it be
15:15:49 <duaneb> mmorrow: I was actually thinking about hot-swappable
15:15:53 <mmorrow> MPZ -> ()
15:15:57 <duaneb> that looks like compile-time
15:16:00 <pumpkin> mmorrow: it actually has to be Addr# -> ()
15:16:01 <duaneb> err wait
15:16:08 <pumpkin> mmorrow: but you sure that'll actually do anything?
15:16:15 <mmorrow> Word64 -> ()
15:16:17 <pumpkin> I got the impression that it'd be run once
15:16:20 <mmorrow> pumpkin: positive
15:16:22 <pumpkin> I can actually use Addr#
15:16:44 <wot4n> i can't get this example code running in ghci. "length' xs = sum [1 | _ <- xs]" is returning a parse error on the =. i know it's simple, i'm just a newbie
15:17:01 <goldenpuffs> general haskell question: is there a way to stop an algorithm prematurely like for example in an imperative language with if (a) return b
15:17:09 <mmorrow> oh, i dunno about what'll happen with running it multiple times but it'd be interesting to find out
15:17:20 <mmorrow> duaneb: hot-swappable?
15:17:24 <mmorrow> duaneb: how do you mean?
15:17:24 <pumpkin> mmorrow: yeah, that was my issue :)
15:17:31 <erikc> wot4n: in ghci you need to put 'let' in front
15:17:48 <duaneb> mmorrow: I mean, you can switch allocators during runtime
15:18:11 <Saizan_> goldenpuffs: no, you can throw an exception in some monads, but that's not a normal return
15:18:34 <aavogt> goldenpuffs: Control.Monad.Cont, primitive recursion, laziness... maybe other ways too
15:19:01 <wot4n> erikc: thanks. :)
15:19:10 <duaneb> mmorrow: which is something that, apparently, gmp already has
15:20:37 <erikc> goldenpuffs: you need to formulate it as an if/else
15:21:23 <pumpkin> duaneb: hot-swappable allocators?
15:21:27 <pumpkin> duaneb: that seems unsafe
15:21:42 <pumpkin> Be sure to call mp_set_memory_functions only when there are no active GMP objects allocated using the previous memory functions! Usually that means calling it before any other GMP function.
15:21:45 <pumpkin> from the GMP manual
15:21:57 <goldenpuffs> erikc: using guards for different cases should work as well, right?
15:22:10 <pumpkin> you don't want to use one allocator to create an mpz and another allocator's free() to free it
15:22:14 <duaneb> pumpkin: well, there would be guards
15:22:14 <erikc> sure
15:22:22 <goldenpuffs> ok I'll try that then
15:22:29 <duaneb> pumpkin: and you couldn't, for example, use an allocator with tagged pointers
15:22:55 <pumpkin> what would be the point of allowing it though?
15:23:07 <pumpkin> just tell someone to call the allocator setter at the beginning of the program if they need it
15:24:26 <duaneb> pumpkin: http://hackage.haskell.org/trac/ghc/wiki/ReplacingGMPNotes#ReasonsforReplacingGMPastheBignumlibrary, #2
15:24:31 <duaneb> err: http://hackage.haskell.org/trac/ghc/wiki/ReplacingGMPNotes#ReasonsforReplacingGMPastheBignumlibrary
15:24:36 <pumpkin> I know :P
15:25:13 <duaneb> well then, unless you want foreign functions to use separate instances of gmp
15:25:26 <duaneb> wouldn't "hot-swappable" allocators be the way to go?
15:25:30 <pumpkin> ?
15:25:35 <duaneb> anyway, I just want to experiment :)
15:25:48 <pumpkin> fair enough :)
15:26:33 <Gracenotes> whether or not to replace GMP, surely their algorithms are too useful to pass up...
15:27:11 <pumpkin> mmorrow: foreign import ccall "malloc" malloc  :: Word# -> Addr# ?
15:27:22 * pumpkin trembles
15:28:41 <duaneb> pumpkin: I suspect you're right, but I can always revert to the single (easiest) allocator
15:30:15 <Cale_> wot4n: ghci normally doesn't expect you to type declarations at the prompt, it wants expressions instead
15:30:21 <Cale_> (things which evaluate to values)
15:30:28 <BMeph> pumpkin: Those make great handbags... ;)
15:31:31 <Cale_> wot4n: If you want to make a quick temporary declaration, you can prefix it with 'let', but it's usually better just to put it into a file and load that
15:31:31 <Cale_> Then when you modify the file, :r will reload
15:39:13 <pumpkin> mmorrow: it's not recomputing
15:39:13 <pumpkin> somewhat unsurprisingly
15:39:13 <pumpkin> bah
15:39:13 <pumpkin> main = replicateM 10 (print =<< mallocBytes 5) gives me 10 different addresses
15:39:37 <pumpkin> replicateM 10 (print (I# (addr2Int# (malloc (int2Word# 5#))))) doesn't
15:39:38 <jmillikin> Is there a built-in list function: split (/= 4) [1, 2, 3, 4, 5, 6, 7] -> ([1, 2, 3], [5, 6, 7])  ?
15:39:48 <pumpkin> :t span
15:39:49 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
15:39:50 <PeakerWork> pumpkin: addr2Int# uses unsafePerformIO?
15:39:56 <PeakerWork> :t addr2Int#
15:39:57 <lambdabot> Not in scope: `addr2Int#'
15:40:01 <PeakerWork> @hoogle addr2Int#
15:40:01 <lambdabot> No results found
15:40:06 <pumpkin> addr2Int# :: Addr# -> Int#
15:40:13 <pumpkin> IO doesn't exist at that point
15:40:17 <jmillikin> span includes the "sentinel" value in one of the result lists.
15:40:22 <PeakerWork> what's malloc?
15:40:30 <pumpkin> PeakerWork: a bad FFI binding
15:40:38 <BMeph> > span (/= 4) [1, 2, 3, 4, 5, 6, 7] -> ([1, 2, 3], [5, 6, 7])
15:40:39 <lambdabot>   <no location info>: parse error on input `->'
15:40:40 <jmillikin> I'm using it currently, but don't know if I'm re-inventing a square wheel.
15:40:42 <pumpkin> PeakerWork: foreign import ccall "malloc" malloc  :: Word# -> Addr#
15:40:45 <PeakerWork> oh, malloc is an unsafePerformIO around C's malloc?
15:40:50 <PeakerWork> pumpkin: ah, heh
15:40:50 <pumpkin> not even
15:40:51 <BMeph> > span (/= 4) [1, 2, 3, 4, 5, 6, 7]
15:40:52 <lambdabot>   ([1,2,3],[4,5,6,7])
15:40:59 <pumpkin> PeakerWork: I can't use IO :/
15:41:04 <PeakerWork> pumpkin: hwy?
15:41:06 <PeakerWork> pumpkin: why?
15:41:29 <pumpkin> PeakerWork: IO lives in the base package and it hasn't been compiled yet when I need it
15:41:29 <mauke> > groupBy (const (4 /=)) [1 .. 7]
15:41:29 <lambdabot>   [[1,2,3],[4,5,6,7]]
15:41:49 <mauke> > groupBy (const (4 /=)) [1,2,3,4,4,5,6,4,1,3,2,4]
15:41:50 <pumpkin> PeakerWork: yet the FFI doesn't let me use State# RealWorld either
15:41:51 <lambdabot>   [[1,2,3],[4],[4,5,6],[4,1,3,2],[4]]
15:41:58 <PeakerWork> pumpkin: hmm. what are you doing??
15:42:25 <pumpkin> PeakerWork: making an FFI binding to GMP as a replacement for the current system... everything else is ready for it, but I need GMP in a library
15:42:44 <PeakerWork> pumpkin: why can't GMP depend on base?
15:43:09 <pumpkin> because Integer is used in various places in ghc, and needs to be present very early in the compilation, before base has been compiled, apparently
15:43:43 <pumpkin> it's frustrating
15:45:37 <RyanT50001> i've got an issue where, after running a certain IO action, ghci takes up 100% of a CPU
15:45:49 <RyanT50001> is there any way for me to use the newfangled debugger to track down the thread that's causing that?
15:46:14 <RyanT50001> (i can still issue commands to ghci, but they're slow)
15:47:58 <RyanT50001> also, quitting ghci doesn't work; it says "Leaving GHCi." and then hangs
15:48:00 <PeakerWork> pumpkin: surely its insane to not be able to use base
15:48:59 <sioraiocht> RyanT50001: post the cost in hpaste?
15:48:59 <PeakerWork> pumpkin: Can't ghc and base inter-depend?
15:48:59 <pumpkin> PeakerWork: I'm asking on cvs-ghc now... maybe they'll have some suggestions...
15:48:59 <RyanT50001> sioraiocht: cost?
15:48:59 <pumpkin> PeakerWork: not sure, it'd be nice, but I don't think things like .hs-boot would work at that level
15:48:59 <sioraiocht> RyanT50001: code, sorry
15:52:07 <eu-prleu-peupeu> hi
15:52:07 <PhDP> Is there a way to get to the nth element of a list without having to go thru the list from the first element to the element n. For example I get reach the element before the last element with pmLastButOne [a, b] = a and pmLastButOne (x:xs) = pmLastButOne xs but it doesn't seem very efficient.
15:52:17 <dmwit> PhDP: No, there is no way to do it without going through the list.  However, (!!) will go through the list for you.
15:52:43 <RyanT50001> sioraiocht: well, it's using a million libraries, but here it is: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5638#a5638
15:52:52 <dmwit> :t last . init
15:52:54 <lambdabot> forall a. [a] -> a
15:52:58 <dmwit> :t (!!1) . reverse
15:52:59 <lambdabot> forall a. [a] -> a
15:53:40 <dmwit> > last . init $ [1..5]
15:53:42 <lambdabot>   4
15:53:47 <dmwit> > (!!1) . reverse $ [1..5]
15:53:49 <lambdabot>   4
15:53:51 <RyanT50001> sioraiocht: it's making a freeglut window and rendering some stuff into it
15:54:22 <sioraiocht> RyanT50001: and it never displays the window?
15:54:44 <RyanT50001> sioraiocht: it does, but after i close the window it uses 100% of a CPU forever
15:54:48 <RyanT50001> until i kill ghci
15:55:12 <sioraiocht> yes, I would suggest compiling it with ghc
15:55:13 <PeakerWork> RyanT50001: Are you using freeglut?
15:55:21 <RyanT50001> PeakerWork: not directly
15:55:28 <RyanT50001> it's all through reactive-fieldtrip
15:56:12 <PeakerWork> RyanT50001: I remember reading this problem existed in some GLUT that wasn't freeglut
15:56:12 <PhDP> But I'm curious, if there's no way to do it without going through the list, how can Haskell be so fast ? Because in practice it seems to be really fast, on the Computer Language Benchmarks Game it recently got behing only C and C++ (+ATS but it's not really a general purpose language) ?
15:56:18 <mauke> PhDP: you can't do it faster in C or C++ either
15:56:19 <PeakerWork> PhDP: Haskell supports other data structures except linked lists
15:56:19 <RyanT50001> PhDP: if you need efficient access to the second-to-last member, you can use datastructures other than lists
15:56:19 <dmwit> PhDP: If you're trying to pick out the last element of a linked list in any language, you've probably designed your solution incorrectly.
15:56:27 <dmwit> PhDP: Haskell is no exception.
15:56:28 <RyanT50001> haha
15:59:18 <PeakerWork> dmwit: s/linked list/singly linked list or non-circular doubly-linked-list
15:59:18 * dmwit nods
15:59:18 <RyanT50001> step 1: semi-criticize haskell; step 2: ... ; step 3: profit (in the form of many, many responses)
15:59:18 <erikc> RyanT50001: i had a similar problem with ghci and glut, but it was a toy program and worked outside of ghci so i didnt investigate any further
15:59:18 <RyanT50001> erikc: ah, ok
15:59:18 <RyanT50001> maybe i should just not do 3d graphics from inside ghci... :P
15:59:18 <sioraiocht> RyanT50001: that tactic is a common way to try and get attention in IRC help channels
15:59:18 <RyanT50001> sioraiocht: yeah, lol
15:59:18 <RyanT50001> such tactics don't seem necessary here, though
15:59:18 <RyanT50001> this is the one chatroom i've never had any trouble with getting help in
15:59:18 <mauke> <KimmoA> I used to be all about linked lists. Now I know better, I stay away from linked lists.
15:59:59 <PhDP> So in short, if I want to get to the element just before the last element, this solution is among the best I can do; pmLastButOne [a, b] = a and pmLastButOne (x:xs)
16:00:00 <PhDP> ?
16:00:16 <shapr> Does the source version of 6.10.3 include cabal?
16:00:25 <sioraiocht> RyanT50001: Asking for help in #haskell usually gets you WAY more than you bargained for
16:00:26 <mauke> PhDP: yes
16:00:32 <Botje> PhDP: someone gave you "last . init" as a solution
16:01:47 <RyanT50001> PhDP: for performance purposes, the naive solutions are basically ideal
16:01:47 <erikc> more like #haskelp
16:01:47 <dcoutts> shapr: no, you're thinking of the Haskell Platform
16:01:47 <shapr> oh
16:02:00 <PhDP> mauke & Ryan: ok great. Botje; I'm not looking for a solution, I'm looking for the fastest solution... beside I don't understad the synthax of "last . init", I'll probably get there later.
16:02:18 <mauke> PhDP: what other lanugages do you know?
16:04:53 <david48> speaking of the haskell platform, it doesn't build on (K)ubuntu unless you manually make a simlink to libGL.so
16:04:53 <PhDP> mauke: Well I'm a scientist so I'm not an expert in any language but I've had to deal with C, Java and Matlab (+ a little CPython).
16:04:53 <Tsion> PhDP: . is function composition. (last . init) list is the same as last (init list)
16:04:53 <gwern> last . init sounds terribly inefficient
16:05:08 <pumpkin> it's still just linear
16:05:08 <mauke> gwern: O(n) :-)
16:05:33 <gwern> mauke: well, when I compare against data.sequence's complexity...
16:05:41 <sioraiocht> PhDP: if you want access to both ends of a list there are a LOTof more efficient data structures
16:05:48 <dmwit> PhDP: Haskell also has arrays, so if you know the size ahead of time, you can do much better.
16:05:50 <sioraiocht> PhDP: data.sequence uses a finger tree
16:06:01 <pumpkin> don't give him the finger... tree!
16:06:10 * pumpkin cries
16:06:13 * sioraiocht is a big fan of finger trees
16:06:35 <pumpkin> me too
16:07:00 <PhDP> wow, thanks for all the comments ;). I just tried (last . init) and it does work.
16:07:17 <gwern> > (last . init) [1..] -- oh noes
16:07:18 <hackagebot> Added by SterlingClover, Sun Jun  7 23:06:42 UTC 2009.: StringTemplate implementation in Haskell.  http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HStringTemplate-0.5.1.2
16:07:22 <PhDP> I guess I'll have to learn a little about big O notation and theory if I want to design efficient code
16:07:23 <lambdabot>   mueval-core: Prelude.read: no parse
16:07:23 <lambdabot>  mueval: ExitFailure 1
16:07:41 <gwern> last . init will only work on a finite list, and if you have a finite list, data.sequence is your man
16:08:17 <pumpkin> or woman, if you prefer those
16:08:17 <pumpkin> or anything else
16:08:26 <dmwit> Computers hate it when you anthropomorphize them. ;-)
16:08:34 <gwern> pumpkin: no, I'm using 'man' in the etymologically old english sense, where man means human, and not male
16:08:57 <gwern> man = male is a post-old-english redefinition
16:09:14 <david48> so what was male in old english ?
16:09:19 <PhDP> I guess I'll have to look at data.sequence. What's the best structure to deal with matrices (say, the kind you have to deal with to solve big Markov processes) ?
16:09:20 <pumpkin> so is a lot of what we speak
16:09:20 <erikc> human
16:10:34 <RyanT50001> david48: "wer"
16:10:34 <mmorrow> pumpkin: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2587#a2587
16:10:34 <david48> weird
16:10:34 <dmwit> PhDP: Oh, I've got some bad news for you...
16:10:34 <gwern> PhDP: matrices? for that I guess you'd have to go hackage
16:10:34 <pumpkin> mmorrow: :o
16:10:34 <mmorrow> :)
16:10:34 <pumpkin> mmorrow: alright, I'll give it a go :)
16:10:34 <pumpkin> oh, I didn't realize that ## gave you a word
16:10:46 <mmorrow> oh yesh! (iirc it's new in the last year)
16:11:08 <pumpkin> nice
16:11:26 <pumpkin> alright, back to ugly magichash for me then
16:11:26 <mmorrow> yeah, the '#' is imo the ugliest possible one to choose..
16:11:46 <mmorrow> it's like a little porcupine stabbing your retinas every time you look at it
16:11:56 <PhDP> dmwit: what's the bad news ? I'd rathre know now than after (if) I start writting Haskell code for my thesis ;)
16:12:50 <gwern> PhDP: well, when it comes to arrays, we like to say that haskell has the best arrays in the world
16:12:57 <gwern> at least, it'd better - we have every other kind of array
16:13:02 <pumpkin> mmorrow: foreign import ccall "__gmp_set_memory_functions" mp_set_memory_functions :: Addr# -> Addr# -> Addr# -> Void ;)
16:13:09 <mmorrow> weee
16:13:23 <gwern> strict ones, lazy ones, boxed ones, unboxed ones, strict unboxed, lazy unboxed, strict lazy cats in hats...
16:13:56 <PhDP> So there's no problem
16:14:05 * pumpkin is basically throwing out all the type safety in this
16:14:11 <PhDP> Unless there is a "but..." ?
16:14:26 <dmwit> PhDP: Well, a while ago, there wasn't much in the way of good matrix libraries.  But Hackage seems to have some stuff now, so maybe my news is out of date. =)
16:17:09 <gwern> PhDP: no, that's basically the 'but' for haskell arrays. there's a ton of different ones which nobody knows how they perform
16:17:09 <PhDP> As long as it's not GPL I'm ok with it
16:17:10 <ArneB> The hmatrix package is GPL.
16:17:10 <gwern> zing
16:17:10 <PhDP> ah ok, that's a problem, but not so bad, I'll mostly have to deal with trees and I doupt haskell has any problem with those.
16:17:10 <PhDP> Then I won't use hmatrix
16:17:10 <Hunner> Hi, I have a data type with two constructors of different types. Given a string (say, containing "ID1" and "ID2" which tells which constructor to use) how do I construct a function of type "String -> Datatype"? Or am I going about it wrong?
16:17:10 <dmwit> Hunner: Check out the Read class.
16:17:10 <dmwit> Hunner: You can add "deriving (Read)" to your data type definition and get such a function written for you.
16:17:10 <pumpkin> mmorrow: now for another hard question
16:17:10 <pumpkin> mmorrow: foreign import ccall "&__gmpz_clear" mpz_clear_ptr :: Addr#
16:17:20 <pumpkin> I need the address of the function
16:17:27 <pumpkin> normally I'd use a FunPtr
16:17:29 <mmorrow> hmm, that might work?
16:17:32 <pumpkin> nope
16:17:52 <mmorrow> aw
16:17:52 <Hunner> dmwit: thanks
16:17:52 <pumpkin> you can't have unlifted constants
16:17:52 <pumpkin>     Expecting an ordinary type, but found a type of kind #
16:18:25 <mmorrow> i guess just write a function   void *wrap(int x){return __gmpz_clear;}
16:18:35 * pumpkin weeps
16:19:13 <mmorrow> haha
16:19:25 <pumpkin> ah well, freeing memory is for wusses anyway
16:19:31 <pumpkin> I'll leave it out for now
16:22:19 <ray> you deserve that memory
16:41:56 <shapr> Building ghc from source is a pain.
16:44:24 <shapr> Brings me back to the days of ghc 5.04.
16:44:24 <shapr> Still, cabal is involved, so it's way better than 5.04 days.
16:44:24 <dcoutts> shapr: you can use the binaries
16:45:56 <shapr> Truly, that would make more sense.
16:47:25 <CSWookie> How do I make something like a Python iterator?  I want to be able to say, "Give me the next one in that infinite series."
16:47:25 <dino-> shapr: Whatcha building it for?
16:47:25 <SamB> it's called a list
16:47:25 <SamB> ;-)
16:47:26 <dino-> shapr: I mean, what OS
16:47:42 <BMeph> CSWookie: You mean like "iterate <function> <first value>"? ;)
16:48:23 <CSWookie> BMeph: Maybe?  Do I?
16:48:43 <CSWookie> BMeph: I want to be able to periodically say, give me the next one.
16:49:21 <pumpkin> :k (->)
16:49:23 <lambdabot> ?? -> ? -> *
16:49:31 <pumpkin> I don't supposed there's a way of changing that * to a ?
16:49:44 <CSWookie> BMeph: I don't think so.
16:49:44 <shapr> dino-: Just x86 at the moment, but I figured I should be prepared for ppc.
16:49:59 <heatsink> What are these questionmark kinds?
16:50:16 <CSWookie> BMeph: For example, I want to make something that counts by 3's.
16:50:18 <dino-> shapr: Gotcha. Practicing then, sounds like.
16:50:37 <CSWookie> BMeph: iterate seems more like it creates a cycle.
16:51:05 <heatsink> > take 10 $ iterate (3 +) 0
16:51:06 <lambdabot>   [0,3,6,9,12,15,18,21,24,27]
16:51:49 <dino-> > take 10 [x | x <- [1..], x `mod` 3 == 0]
16:51:50 <lambdabot>   [3,6,9,12,15,18,21,24,27,30]
16:51:50 <TomMD> CSWookie: If you have an IO action to perform on each IO input then you can use a Channel - fork a receiver of sorts to get each item and have a worker pulling the work.  If you want a more linear approach then perhaps "forM_" is all you want?
16:51:54 <dino-> oho, iterate
16:52:53 <TomMD> CSWookie: There are also a number of libraries to aid you in building a REPL loop for things like interpreters.  Haskline is the latest and greatest.
16:52:59 <TomMD> @hackage haskeline
16:52:59 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/haskeline
16:53:52 <TomMD> I've recently used that to improve the REPL of Tim Sheards lambda calculator - it was really quick.
16:54:28 <heatsink> CSWookie: If there are no side effects involved, then a Haskell list is a Python generator.
16:54:40 <mike-burns> > take 10 [0,3..]
16:54:42 <lambdabot>   [0,3,6,9,12,15,18,21,24,27]
16:55:20 <gwern> TomMD: shellac is better for interpreter repls than plain haskeline
16:55:30 <dino-> mike-burns: Ah! I guessed (incorrectly) that that would create 0,3,4,5...
16:56:43 <TomMD> I used Shallac too - it certainly is more powerful but took not insignificant porting for me to get it to work.
16:56:57 <gwern> dino-: right. the enum operator subtracts the first 2 numbers, and then begins incrementing by the difference
16:57:32 <dino-> gwern: That is handy
16:57:57 <gwern> dino-: dunno. I haven't had all that much call to use it
16:58:10 <dino-> Ok, maybe it's not so much handy as geekily neat.
16:58:28 <gwern> well, it is pretty neat
17:01:28 <pumpkin> mmorrow: I almost have the thing compiling again
17:14:00 <pumpkin> mmorrow:
17:14:00 <pumpkin> I tried adding 5 and 7, and it gave me 14 :(
17:14:00 <pumpkin> ugh
17:14:03 <bremner> > 5+7
17:14:04 <lambdabot>   12
17:14:12 <pumpkin> yeah, might be a problem, eh
17:14:29 <pumpkin> I know why it's happening, too, but I don't know how to fix it
17:16:55 <dmwit> 5 == 7
17:17:00 <dmwit> problem solved
17:19:33 <gwern> > let 5 = 7 in 5+5
17:19:35 <lambdabot>   10
17:19:49 <gwern> hm. I thought that used to work
17:20:01 <dmwit> > let 5 + 7 = 14 in 5 + 7
17:20:02 <lambdabot>   14
17:20:18 <gwern> oh, I remembered it backwards
17:20:52 <pumpkin> :)
17:21:02 <pumpkin> unfortunately that doesn't fix my problem
17:21:19 <CSWookie> Thank you, TomMD heatsink dino- others...  I had to tuck a kid in.
17:22:06 <pumpkin> I think I know what I have to do
17:22:06 * pumpkin sighs some more
17:22:06 <jmillikin> > let 5 + 7 = 14 in 5 + 7 + 6
17:22:06 <lambdabot>   * Exception: <interactive>:1:165-174: Non-exhaustive patterns in function +
17:22:13 * dmwit points out it's pumpkin's fault for playing with unsafe*
17:22:19 <pumpkin> dmwit: I'm not!
17:22:31 <pumpkin> dmwit: not one occurrence of unsafe* in my file anywhere!
17:22:35 <dmwit> Why not?
17:22:36 <pumpkin> ;)
17:22:42 <dcoutts> TomMD: you mentioned some time ago some state/serialisation problem with the hackage-server since moving to happstack. What was the problem exactly and how do I reproduce it?
17:23:01 <pumpkin> dmwit: I use lots of MagicHash to make up for it though
17:23:03 <pumpkin> :(
17:23:07 <dmwit> hehehe
17:23:39 <pumpkin> that flag should be illegal
17:31:37 <gwern> everybody loves hash
17:33:23 <kniu> @src words
17:33:24 <lambdabot> words s = case dropWhile isSpace s of
17:33:24 <lambdabot>     "" -> []
17:33:24 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
18:12:21 <pumpkin> quiet in here
18:12:50 <ray> there is no more haskell to discuss
18:13:18 <physique> haskell has been deprecated
18:15:24 <luqui> we decided that haskell was too good for computers, so now we just do it on paper
18:15:24 <lambdabot> luqui: You have 1 new message. '/msg lambdabot @messages' to read it.
18:22:15 <blackdog> was there a pragma to use bytestring literals in GHC?
18:22:15 <TomMD> OverloadedStrings
18:22:22 <blackdog> ah, cheers
18:22:28 <pumpkin> {-# LANGUAGE OverloadedStrings #-}
18:36:27 <heatsink> In Cabal, is there a way to include extra object files in Distribution.Simple.Build.build?
18:37:51 <donnelly> object files? there's 'extra-source-files'
18:39:46 <heatsink> I don't think that's used when linking.
18:40:29 <Adamant> Distribution.Haskell.Compile.Compile.compile
18:42:13 <Paradox924X> Any reason why an application running fine on a computer running arch segfaults on another using jaunty with this error (from gdb)?:
18:42:15 <Paradox924X> strcpy () at ../sysdeps/x86_64/strcpy.S:74
18:42:15 <Paradox924X> 74	../sysdeps/x86_64/strcpy.S: No such file or directory.
18:42:15 <Paradox924X> 	in ../sysdeps/x86_64/strcpy.S
18:43:21 <Paradox924X> ghc 6.10.3 on both
18:44:18 <Cale> Paradox924X: Is one of the machines 64 bit and the other 32?
18:44:27 <Paradox924X> nope, they're both 64bit
18:45:28 <Paradox924X> I tried it in a 32bit choot as well just in case
18:45:40 <Paradox924X> but pretty much same error except i686 instead of x86_64
18:45:45 <Cale> That's a strange looking error. Are you transferring the binary directly or have you tried recompiling?
18:45:58 <Paradox924X> I recompiled myself
18:49:01 <Paradox924X> and the backtrace in gdb shows it goes back to my_inet_ntoa() from libmysqlclient.so.(16|15) and further back into s9ZA_info(), if that helps
18:50:09 <alexsuraci> or
18:50:09 <alexsuraci> well
18:50:13 <alexsuraci> er, wrong chan
18:50:14 <alexsuraci> <_<
18:50:55 <Cale> Paradox924X: libmysqlclient sounds like a C library.
18:51:11 <Paradox924X> I believe it is
18:51:21 <Paradox924X> this app uses hdbc-mysql
18:51:36 <Cale> Paradox924X: Perhaps the version it expects is somehow different?
18:51:42 <Cale> I'm not really sure.
18:51:52 <SamB> Paradox924X: do you get arguments for my_inet_ntoa?
18:52:40 <Paradox924X> no, no symbol table information available
18:54:00 <pumpkin> , let (&&&) f g = \x -> (f x, g x) in (read :: String -> Integer) . map intToDigit . uncurry (++) . ((reverse . takeWhile (/=0)) &&& (reverse . dropWhile (==0) . dropWhile (/=0))) . map (round . realPart) . ifft . map (^2) . fft . map (:+0) $ [0, 0, 0, 0, 0, 0, 1, 2, 1, 1, 0, 0, 0, 0, 0,
18:54:02 <lunabot>  luna: parse error on input `)'
18:54:13 <pumpkin> , let (&&&) f g = \x -> (f x, g x) in (read :: String -> Integer) . map intToDigit . uncurry (++) . ((reverse . takeWhile (/=0)) &&& (reverse . dropWhile (==0) . dropWhile (/=0))) . map (round . realPart) . ifft . map (^2) . fft . map (:+0) $ [0, 0, 0, 0, 0, 0, 1, 2, 1, 1, 0, 0, 0, 0, 0, 0]
18:54:14 <lunabot>  1466521
18:54:59 <pumpkin> , let (&&&) f g = \x -> (f x, g x) in (read :: String -> Integer) . map intToDigit . uncurry (++) . ((reverse . takeWhile (/=0)) &&& (reverse . dropWhile (==0) . dropWhile (/=0))) . map (round . realPart) . ifft . map (^2) . fft . map (:+0) $ [0, 0, 0, 0, 0, 0, 4, 2, 7, 3, 0, 0, 0, 0, 0, 0]
18:55:00 <lunabot>  luna: Char.intToDigit: not a digit 16
18:55:09 <pumpkin> , let (&&&) f g = \x -> (f x, g x) in (read :: String -> Integer) . map intToDigit . uncurry (++) . ((reverse . takeWhile (/=0)) &&& (reverse . dropWhile (==0) . dropWhile (/=0))) . map (round . realPart) . ifft . map (^2) . fft . map (:+0) $ [0, 0, 0, 0, 0, 0, 4, 2, 1, 3, 0, 0, 0, 0, 0, 0]
18:55:11 <lunabot>  luna: Char.intToDigit: not a digit 16
18:55:13 <pumpkin> boo :P
18:55:22 * pumpkin needs to implement "carry"
18:56:47 <pumpkin> at least my first example worked
19:00:39 <pumpkin> , let (&&&) f g = \x -> (f x, g x) in (read :: String -> Integer) . map intToDigit . uncurry (++) . ((reverse . takeWhile (/=0)) &&& (reverse . dropWhile (==0) . dropWhile (/=0))) . map (round . realPart) . ifft . map (^2) . fft . map (:+0) $ [0, 0, 0, 0, 0, 0, 2, 2, 1, 1, 0, 0, 0, 0, 0, 0]
19:00:41 <lunabot>  4888521
19:00:55 <dmwit> Holy paragraph code, Batman!
19:01:02 <pumpkin> :)
19:01:11 <pumpkin> isn't it pretty?
19:01:18 <byorgey> o.O
19:01:24 <Tsion> Pretty as barf
19:01:25 <pumpkin> yeah, didn't think so :P
19:01:29 <byorgey> what does it... do?
19:01:35 <pumpkin> squares a number!
19:01:43 <pumpkin> duh! ;)
19:01:45 <byorgey> ...I see.
19:01:54 <dmwit> Style points for being totally point-free... except for the definition of (&&&).
19:01:57 <luqui> :t fft
19:01:58 * byorgey nods sagely
19:01:58 <lambdabot> Not in scope: `fft'
19:02:03 <pumpkin> squares a very restricted set of numbers, really
19:02:06 <luqui> :t ifft
19:02:07 <lambdabot> Not in scope: `ifft'
19:02:20 <luqui> ,t fft
19:02:21 <lunabot>  luna: Couldn't match expected type `([Data.Complex.Complex
19:02:23 <pumpkin> dmwit: yeah, I needed &&& to be truly point-free, and lunabot doesn't have it
19:02:31 <pumpkin> :(
19:02:37 * dmwit notices a map (^2) in there... surely it's cheating to implement squaring with squaring.
19:02:43 <pumpkin> lol
19:03:03 <pumpkin> yeah, but I'm squaring each digit, which makes it okay
19:03:08 <dmwit> =)
19:03:24 <luqui> &&&, |||, +++, *** should all be prelude
19:03:30 <pumpkin> yeah
19:03:36 <luqui> they are essential to product and coproduct types
19:03:37 <dmwit> , let f &&& g = \x -> (f x, g x) in succ &&& pred $ 43
19:03:39 <lunabot>  (44,42)
19:04:12 <pumpkin> that is what happens when I don't want to do the dishes
19:04:30 <pumpkin> not sure where I'll get my bouts of inspiration from once I move into the new apartment with a dishwasher
19:04:31 <dmwit> luqui: Well, they're in Prelude.Dmwit. ;-)
19:08:28 <pumpkin> anyone want to fix my function?
19:08:32 <pumpkin> I've had enough of it
19:08:48 <TomMD> > fix function
19:08:49 <lambdabot>   Not in scope: `function'
19:09:02 <TomMD> lambdabot is lazy today, sorry.
19:09:06 <pumpkin> aw
19:09:15 <TomMD> paste it if you'd like.
19:09:32 <pumpkin> just the nasty beast I ran in lunabot a minute ago :)
19:09:39 <pumpkin> it only squares some numbers!
19:09:56 <TomMD> Oh, screw that ;-)
19:10:01 <pumpkin> :(
19:10:07 <TomMD> it is a nasty beast.
19:10:53 <dmwit> > fix my function
19:10:55 <lambdabot>   42
19:11:08 <TomMD> ha, yes, that is good.
19:11:49 <TomMD> @remember dmwit > fix my function      [lambdabot: 42]
19:11:50 <lambdabot> Okay.
19:12:31 * pumpkin wonders about realWorld#
19:12:44 <TomMD> Real world unboxed?
19:13:02 <TomMD> Well, you'd have no pointers.  Sounds tough.
19:13:10 <pumpkin> I can't find it anywhere
19:13:12 <pumpkin> but I know it exists
19:13:26 <pumpkin> well, I can find it in compiler/basicTypes/MkId.lhs
19:14:04 <luqui> :t my
19:14:06 <lambdabot> forall b1 b t. (Num t) => b1 -> b -> t
19:14:09 <luqui> :t function
19:14:10 <lambdabot> forall a. a
19:14:18 <pumpkin> > my 1 2
19:14:20 <lambdabot>   42
19:14:25 <pumpkin> :o
19:14:33 <pumpkin> > function 4
19:14:35 <lambdabot>   * Exception: Prelude.undefined
19:14:36 <pumpkin> > function=
19:14:37 <lambdabot>   <no location info>: parse error on input `='
19:14:44 <pumpkin> the shock, the horror!
19:14:49 <dmwit> =)
19:15:13 <dmwit> I figured, if I wasn't going to use it, why define it at all? =)
19:15:37 <TomMD> > my function
19:15:38 <lambdabot>   Overlapping instances for GHC.Show.Show (b -> t)
19:15:38 <lambdabot>    arising from a use of `...
19:15:44 <TomMD> > fix my function
19:15:45 <lambdabot>   42
19:16:28 <dmwit> > my (my function) function
19:16:30 <lambdabot>   42
19:16:38 <mike-burns> > my final answer
19:16:40 <lambdabot>   Not in scope: `final'Not in scope: `answer'
19:17:57 <luqui> > my ?final ?answer
19:17:58 <lambdabot>   Unbound implicit parameters (?answer::b, ?final::b1)
19:17:58 <lambdabot>    arising from a use ...
19:18:58 <dmwit> Man, implicit parameters are definitely a weird corner of the language.
19:19:11 <dmwit> I wonder if there's any actual code floating around that needs them.
19:19:49 <luqui> i used to use them a lot, until my enlightenment :-p
19:20:03 <Tsion> What is the fix function for?
19:20:10 <dmwit> recursion
19:20:15 <luqui> > fix (1:)
19:20:16 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
19:20:28 <dmwit> Tsion: You know about the Y combinator?
19:20:44 <luqui> > fix (\self x -> if x == 0 then 1 else x * self (x-1)) 10
19:20:45 <lambdabot>   3628800
19:20:48 <Tsion> dmwit: No
19:20:53 <luqui> > product [1..10]
19:20:54 <lambdabot>   3628800
19:21:24 <dmwit> Tsion: Well, the reason the Y combinator is neat is because it lets you do recursive things in languages without recursion.
19:21:38 <dmwit> Tsion: Specifically, if a name isn't in scope in its own binding, that makes it tricky to do recursion.
19:21:48 <dmwit> Tsion: Consider the standard fibonacci definition.
19:22:01 <dmwit> fibonacci n | n > 2 = fibonacci (n-1) + fibonacci (n-2)
19:22:21 <dmwit> In a language where "fibonacci" isn't in scope on the right-hand side, you wouldn't be able to write that function in that way.
19:22:28 <Tsion> right
19:22:32 <dmwit> The "fix" combinator is the answer to that.
19:22:40 <dmwit> It lets you write that case as
19:23:10 <dmwit> fibonacci = fix (\fibRecurse n -> if n > 2 then fibRecurse (n-1) + fibRecurse (n-2) else baseCase)
19:23:26 <dmwit> You'll notice that fibonacci is not used in the RHS any more.
19:23:29 <dmwit> And the definition of fix:
19:23:31 <dmwit> ?src fix
19:23:31 <lambdabot> fix f = let x = f x in x
19:23:45 <dmwit> also doesn't use "fix" in its RHS.
19:24:00 <luqui> (but it does use x in its own RHS)
19:24:02 <dmwit> (although it does use 'x' in the RHS of the let, so it's cheating slightly)
19:24:25 <luqui> fix f = \f. (\x. x x) (\x. f (x x))
19:24:26 <Tsion> Cool, thanks for the explaination dmwit :)
19:24:34 <dmwit> Anyway, the true Y combinator doesn't have that cheat (but can't be expressed in Haskell).
19:24:34 <luqui> that's the proper definition :-)
19:25:33 <pumpkin> > loop (take 5 . snd &&& repeat . fst) 5
19:25:35 <lambdabot>   [5,5,5,5,5]
19:25:37 <TomMD> Tsion: If you are interested in this and want to dive into some simple lambda calculus I'll probably be pushing a version of Tim Sheards Lambda Calculator onto Hackage soon.
19:25:53 <TomMD> Tsion: But thats only if you are _really_ interested.
19:25:55 <luqui> :t loop
19:25:56 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowLoop a) => a (b, d) (c, d) -> a b c
19:26:18 <Tsion> I read a bit about labmda calculus on wikipedia, but there's not too much there
19:26:29 <TomMD> Its a simple language.
19:26:48 <Tsion> lambda*
19:27:04 <luqui> God *is* untyped pure lambda calculus
19:28:09 <TomMD> Are you sure he isn't a turing machine?
19:28:12 <heatsink> What mailing list is appropriate for questions about making Cabal packages?
19:29:38 <TomMD> heatsink: If you've already seen examples, read the webpage and still have questions then I'd suggest haskell-cafe or cabal-devel both at haskell.org.
19:29:54 <TomMD> I suppose cabal-devel if you feel you've found a deficency.
19:30:50 <heatsink> Alright, thanks
19:31:16 <pumpkin> bonus points if someone comes up with something cool and concise using Kleisli and loop
19:31:17 <heatsink> I subscribed to haskell-cafe briefly, but it's too much for me to keep up with.
19:32:03 <dmwit> ?instances mfix
19:32:04 <lambdabot> Couldn't find class `mfix'. Try @instances-importing
19:32:07 <dmwit> um
19:32:10 <dmwit> ?instances MonadFix
19:32:11 <lambdabot> ((->) r), Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
19:32:12 <dmwit> duh
19:32:13 <Saizan> dmwit: you can write the Y combinator with the help of a recursive type, newtype Rec a = In { out :: Rec a -> a }
19:33:08 <ClaudiusMaximus> i've been working on a lazy untyped lambda calculus graph reduction stuff lately
19:33:11 <dmwit> That type looks difficult to inhabit without using fix in the first place.
19:33:44 <dmwit> :t mfix
19:33:46 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
19:34:21 <dmwit> > execState (mfix (\a -> put (1:a) >> get)) []
19:34:22 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
19:34:34 <pumpkin> luqui: why flip mod?
19:34:40 <dmwit> :t Kleisli
19:34:41 <lambdabot> forall a (m :: * -> *) b. (a -> m b) -> Kleisli m a b
19:34:55 <pumpkin> it works nicely with x `mod` 5
19:35:57 <pumpkin> I guess you can approximate mfix easily with loop and Kleisli
19:37:27 <kniu> I thought this would never happen,
19:37:39 <kniu> but a runtime error is giving me trouble.
19:38:48 <heatsink> kniu: You need dependent types.
19:39:27 <pumpkin> or you need to use the power of haskell types to their fullest!
19:39:28 <kniu> I thought this would never happen,
19:39:29 <Saizan> dmwit: http://r6.ca/blog/20060919T084800Z.html
19:39:40 <kniu> but typechecking is taking forever to finish.
19:40:11 <luqui> pumpkin, (`mod` 5) makes more sense as a function in its own right than (5 `mod`)
19:40:18 <pumpkin> true
19:40:23 <luqui> i.e., whenever I have curried mod in the past, it has always been on its second argument
19:40:39 <pumpkin> I guess mod was written that way to be used infix
19:40:41 <pumpkin> and only for that reason
19:40:44 <luqui> yeah
19:40:47 <luqui> probably
19:43:42 <SamB> pumpkin: you mean there are other ways too call it ?
19:47:40 <pumpkin> :o
19:50:39 <outchanter> it's also the same ordering as div
19:53:11 <hackagebot> Added by GregoryCrosswhite, Mon Jun  8 02:52:13 UTC 2009.: Haskell values that cannot be evaluated immediately.  http://hackage.haskell.org/cgi-bin/hackage-scripts/package/procrastinating-variable-1.0
19:55:42 <gwern> I know I asked for hackagebot to print the synopses as well, but I didn't intend the date to come with it...
19:56:12 <hackagebot> Added by DmitryGolubovsky, Mon Jun  8 02:55:59 UTC 2009.: Parser and Pretty Printer for the Web IDL Language  http://hackage.haskell.org/cgi-bin/hackage-scripts/package/webidl-0.1.1
19:58:14 <luqui> outchanter, arguably div should be swapped as well.  it allows the pretty definition:  div = (*) . recip
19:59:12 <luqui> which allows base factorization to be expressed as liftA2 (&&&) div mod
19:59:23 <luqui> (which would be prettier if we could lift infix)
19:59:56 <luqui> div <^ (&&&) ^> mod, in Beelsebob's style
20:01:14 <hackagebot> Added by GregoryCrosswhite, Mon Jun  8 03:00:14 UTC 2009.: Haskell values that cannot be evaluated immediately.  http://hackage.haskell.org/cgi-bin/hackage-scripts/package/procrastinating-variable-1.0.1
20:03:54 <luqui> > liftA2 (&&&) (flip div) (flip mod) 10 25
20:03:56 <lambdabot>   (2,5)
20:05:32 <dmwit> > divMod 25 10
20:05:34 <lambdabot>   (2,5)
20:08:09 <luqui> (uncurry (+) . first . (*)) (2,5)
20:08:13 <luqui> > (uncurry (+) . first . (*)) (2,5)
20:08:14 <lambdabot>   Couldn't match expected type `(a, a)'
20:10:38 <outchanter> > reverse $ unfoldr (\x -> if x == 0 then Nothing else (Just.swap.divMod) x 10) 12345
20:10:40 <lambdabot>   Not in scope: `Just.swap'
20:11:01 <luqui> > (fmap (uncurry (+)) . first . (*)) 10 (2,5)
20:11:03 <lambdabot>   25
20:11:06 <outchanter> > reverse $ unfoldr (\x -> if x == 0 then Nothing else (Just . swap . divMod) x 10) 12345
20:11:07 <lambdabot>   Not in scope: `swap'
20:11:24 <kniu> I'm writing a repl.
20:11:42 <kniu> Is there a getLine equivalent that does backspaces?
20:11:46 <luqui> > liftA2 (.) (fmap (uncurry (+)) . first . (*)) (liftA2 (&&&) div mod) 10 25
20:11:47 <lambdabot>   10
20:11:58 <luqui> > liftA2 (.) (fmap (uncurry (+)) . first . (*)) (liftA2 (&&&) (flip div) (flip mod)) 10 25
20:12:00 <lambdabot>   25
20:12:13 <outchanter> > reverse $ unfoldr (\x -> if x == 0 then Nothing else (Just.swap.divMod) x 10) 12345 where swap (x, y) = (y, x)
20:12:15 <lambdabot>   <no location info>: parse error on input `where'
20:12:48 <luqui> @check \x -> liftA2 (.) (fmap (uncurry (+)) . first . (*)) (liftA2 (&&&) (flip div) (flip mod)) 10 x == x
20:12:49 <lambdabot>   "OK, passed 500 tests."
20:12:54 <Cale> > let swap (x, y) = (y, x) in reverse $ unfoldr (\x -> if x == 0 then Nothing else (Just.swap.divMod) x 10) 12345
20:12:56 <lambdabot>   Not in scope: `Just.swap'
20:13:03 <Cale> > let swap (x, y) = (y, x) in reverse $ unfoldr (\x -> if x == 0 then Nothing else (Just . swap . divMod) x 10) 12345
20:13:04 <lambdabot>   Couldn't match expected type `(t, t1)'
20:14:38 <Cale> > let swap (x, y) = (y, x) in reverse $ unfoldr (\x -> if x == 0 then Nothing else (Just . swap $ divMod x 10)) 12345
20:14:40 <lambdabot>   [1,2,3,4,5]
20:15:16 <outchanter> ah, thanks
20:15:21 <Cale> > reverse . map (`mod` 10) . takeWhile (/= 0) . iterate (`div` 10) $ 12345
20:15:22 <lambdabot>   [1,2,3,4,5]
20:16:21 * luqui wonders if that can be prettily pointfree on "10" also
20:17:20 <SamB> @pl let swap (x, y) = (y, x) in reverse $ unfoldr (\x -> if x == 0 then Nothing else (Just . swap $ divMod x 10)) 12345
20:17:20 <lambdabot> reverse (unfoldr (ap (flip if' Nothing . (0 ==)) (Just . uncurry (flip (,)) . flip divMod 10)) 12345)
20:17:40 <Cale> > reverse . map (`mod` 10) . takeWhile (/= 0) . iterate (`div` 10) $ 10
20:17:42 <lambdabot>   [1,0]
20:17:54 <outchanter> @pl reverse . map (`mod` 10) . takeWhile (/= 0) . iterate (`div` 10) $ 12345
20:17:55 <lambdabot> reverse (map (`mod` 10) (takeWhile (0 /=) (iterate (`div` 10) 12345)))
20:18:05 <Cale> heh
20:18:25 <outchanter> @pl (\x -> reverse . map (`mod` x) . takeWhile (/= 0) . iterate (`div` x) $ 12345) 10
20:18:26 <lambdabot> reverse (map (`mod` 10) (takeWhile (0 /=) (iterate (`div` 10) 12345)))
20:18:38 <outchanter> that's cheating!
20:18:44 <Cale> luqui: oh, I see what you mean
20:19:00 <luqui> woah... @pl does beta conversion?
20:19:03 <Cale> @pl (\x -> reverse . map (`mod` x) . takeWhile (/= 0) . iterate (`div` x))
20:19:04 <lambdabot> (reverse .) . ap ((.) . map . flip mod) ((takeWhile (0 /=) .) . iterate . flip div)
20:19:19 <luqui> @pl (\x -> x x) (\x -> x x)
20:19:23 <lambdabot> ap id id (ap id id)
20:19:23 <lambdabot> optimization suspended, use @pl-resume to continue.
20:19:30 <Cale> outchanter: you shouldn't apply the function if you don't want @pl to simplify it away
20:19:40 <outchanter> fair enough
20:20:02 <luqui> @pl (\x -> x x) (\x -> x x x)
20:20:06 <lambdabot> ap id id (ap (ap id id) id)
20:20:06 <lambdabot> optimization suspended, use @pl-resume to continue.
20:22:28 <SamB> @pl-resume
20:22:34 <lambdabot> pointless: sorry, nothing to resume.
20:23:03 <luqui> i think that's minimal anyhow
20:23:10 <lambdabot> luqui: You have 1 new message. '/msg lambdabot @messages' to read it.
20:23:47 <luqui> lambdabot, i know.  did you just reboot or something?
20:24:23 <SamB> @pl (\x -> x x) (\x -> x x x)
20:24:27 <lambdabot> ap id id (ap (ap id id) id)
20:24:27 <lambdabot> optimization suspended, use @pl-resume to continue.
20:24:29 <SamB> @pl-resume
20:24:36 <lambdabot> ap id id (ap (ap id id) id)
20:24:36 <lambdabot> optimization suspended, use @pl-resume to continue.
20:24:49 <pumpkin> that's got an extra x! :P
20:25:37 <luqui> pumpkin, yeah, the extra x causes the term to grow with each reduction
20:25:50 <pumpkin> it has the same effect on @pl without it
20:25:59 <pumpkin> but yeah
20:26:21 <luqui> pumpkin, no, pl internally is probably using a decent amount of memory trying to optimize it
20:26:24 <lambdabot> luqui: You have 1 new message. '/msg lambdabot @messages' to read it.
20:26:26 <luqui> that it wouldn't use with the usual one
20:26:32 <pumpkin> @pl (\x -> x x) (\x -> x x)
20:26:42 <lambdabot> ap id id (ap id id)
20:26:42 <pumpkin> @pl-resume
20:26:44 <luqui> maybe that's why it keeps rebooting...
20:26:48 <lambdabot> optimization suspended, use @pl-resume to continue.
20:26:58 <lambdabot> ap id id (ap id id)
20:27:04 <lambdabot> Plugin `pl' failed with: thread killed
20:27:06 <pumpkin> I crash lambdabot regularly with that one, I'm pretty sure it's the exact same issue :)
20:27:50 * pumpkin admires the photos someone invited haskell-cafe to see
20:28:00 <selmanj> Question, when I run haddock on my Main.hs file, i get "parse error on input `module'", which is the first non-commented line in the file.  Any ideas why this would happen?
20:28:04 <kniu> 7.hs:14:1: `read' is not a (visible) method of class `Read'
20:28:14 <SamB> pumpkin: but has haskell-cafe seen them yet?
20:28:16 <kniu> what methods must I write to instance Read, then?
20:28:20 <pumpkin> SamB: not sure!
20:28:45 <SamB> kniu: try doing :i Read
20:29:03 <kniu> huh?
20:29:08 <pumpkin> in ghci
20:29:43 <kniu> oh
20:29:44 <Cale> selmanj: haddock has rules about the syntax of comments as well... my guess would be that it doesn't like the comment you have before
20:30:06 <selmanj> Cale: hmm, i didn't know that.  I'll double check it, thanks
20:30:52 <kniu> man, that's confusing.
20:31:02 <kniu> what's ReadS?
20:31:21 <pumpkin> mmorrow: did you see my wonderful squarer before?
20:31:30 <Cale> type ReadS a = String -> [(a,String)]
20:32:04 <Cale> It takes a string and produces a list of values of type a resulting from possible parses, each along with the remaining string left over
20:32:25 <malouin> Does this function exist somewhere: foo :: Maybe String -> IO () ... foo Just str = ioError $ userError str ?
20:32:32 <Cale> (usually the list will either be empty or have one element, which is the case for all the Prelude and derived instances)
20:32:34 <selmanj> Cale: the entirety of the comment is "-- | The main function of the code.  This is the starting point.".
20:32:40 <luqui> > reads "\"Hello\" world" :: ReadS String
20:32:43 <lambdabot>   Couldn't match expected type `Text.ParserCombinators.ReadP.ReadS
20:32:44 <lambdabot> luqui: You have 1 new message. '/msg lambdabot @messages' to read it.
20:32:53 <luqui> > reads "\"Hello\" world" :: [(String, String)]
20:32:55 <lambdabot>   [("Hello"," world")]
20:33:00 <Cale> selmanj: hmm, I don't see anything wrong with that.
20:33:23 <selmanj> Cale: ooh, think i found it
20:33:35 <selmanj> Cale: above that line i have a subversion Id, ie -- $Id$
20:33:39 <selmanj> that seems to be messing with haddock
20:34:00 <Cale> ah, hmm
20:38:40 <RamzaB> How do you create data structure like a binary tree in Haskell if variables are not "variable"?
20:39:15 <kniu> make a new tree every time you modify/add/delete an element.
20:39:55 <luqui> RamzaB, I don't understand your question.  Those two things seem to be independent...
20:40:07 <luqui> ("how do you create data structure like a list ...")
20:40:14 <luqui> like this:  x = 1:2:3:[]
20:40:18 <RamzaB> thats going to be kind of slow if the tree is big?
20:40:37 <RamzaB> list is like a built-in data structure in haskell right? how do you create your own
20:40:39 <luqui> RamzaB, turns out not to be if you're smart with laziness
20:40:54 <luqui> data List a = Nil | Cons a (List a)   -- my own list
20:40:57 <sjanssen> RamzaB: luckily, asymptotics save us.  In a balanced binary tree, only O(log n) new nodes have to be created
20:41:15 <sjanssen> (per insert)
20:41:51 <RamzaB> sjanssen, I dont understand that
20:42:18 <sjanssen> RamzaB: you know that in a balanced binary tree, it is O(log n) from the root to any node, right?
20:42:20 <luqui> RamzaB, if you "modify" only in the right branch of the tree, you don't have to copy the left branch
20:43:03 <sjanssen> RamzaB: we only have to modify the branches we follow, the others can remain unchanged
20:43:14 <RamzaB> ok, but you're going to have to balance the tree manually, then thats going to be slow if u have to copy the tree everytime right?
20:43:30 <kniu> you're not copying the entire tree.
20:43:43 <luqui> you maintain invariants so that the tree stays balanced after every operation
20:43:45 <sjanssen> RamzaB: balancing the tree will also only require O(log n) steps
20:46:24 <hackagebot> Added by DinoMorelli, Mon Jun  8 03:46:11 UTC 2009.: Simple functions for loading config files  http://hackage.haskell.org/cgi-bin/hackage-scripts/package/fez-conf-1.0.1
20:47:52 <Cale> data Tree a = Empty | Branch a (Tree a) (Tree a)
20:48:26 <Cale> Just figured I should write that since I think it was perhaps what he was looking for.
20:51:39 <ClaudiusMaximus> anyone know of any incremental graph layout libraries?  i want to generate video of lazy evaluation...
20:52:22 <ClaudiusMaximus> ...and i fear my naive attempt at spitting out .dot files for graphviz will lead to horrible flickering chaos
20:52:47 <kniu> k, so I got this repl function.
20:53:02 <kniu> prints " >" every line, reads the input, evals, prints.
20:53:03 <kniu> works fine.
20:53:13 <kniu> repl :: IO ()
20:53:16 <SamB> ClaudiusMaximus: so, you want not just incremental, but animated
20:53:16 <kniu> BUT
20:53:28 <SamB> smoothly
20:53:40 <SamB> never heard of anything like that, but ...
20:53:40 <kniu> I write main = repl, and compile it, the program starts printing "> " at the wrong place.
20:53:48 <kpreid> I was working on that once
20:54:11 <Cale> kniu: How is it written?
20:54:14 <SamB> I bet you can hack something up involving interpolation between graphviz layouts, or something ;-)
20:54:15 <Tsion> kniu: what wrong place?
20:54:17 <kpreid> I got a program which would take input to add nodes and edges, and display them in space with a repulsion rule
20:54:27 <dino-> kniu: Buffering of stdout perhaps
20:54:27 <kniu> it prints "> " AFTER getLine
20:54:31 <Cale> kniu: It could have something to do with the default buffering being different.
20:54:33 <sjanssen> kniu: you're getting different behavior in ghci vs. a compiled program?  Check your buffering
20:54:41 <kniu> well, dang.
20:54:52 <SamB> I have no idea how ugly the interpolation-between-graphviz-layouts approach would be ...
20:54:54 <RevGreen> this language is too hard
20:54:56 <RevGreen> I give up
20:54:56 <kniu> is there a fflush(stdout); equivalent in haskell?
20:54:58 <RevGreen> back to MATLIB
20:55:03 <ClaudiusMaximus> SamB: i basically need small changes in input graph to lead to small changes in output layout - beyond that i don't need anything fancy (it would make the video too long)
20:55:12 <Cale> kniu: hFlush stdout
20:55:16 <dino-> I end up doing this a lot in cli programs early: mapM_ (flip hSetBuffering NoBuffering) [ stdout, stderr ]
20:55:19 <kniu> thanks.
20:55:19 <Cale> kniu: Or just: hSetBuffering stdout NoBuffering
20:55:27 <RevGreen> of course
20:55:29 <kniu> oh?
20:55:30 <RevGreen> NoBuffering
20:55:33 <RevGreen> I didn't think about that
20:55:36 <SamB> ClaudiusMaximus: I suppose you could feed the previous layed-out graph back into graphviz along with the changed nodes ...
20:55:55 <SamB> but, hmm, you'd have to remove the other nodes ...
20:56:07 <SamB> well ..., there was some graphviz package on hackage that should make it a lot easier
20:56:10 <Cale> (You'll need to import System.IO in either case)
20:58:57 <ClaudiusMaximus> SamB: sounds like it'd be a nightmare in any case..
20:59:33 <SamB> hmm, http://hackage.haskell.org/packages/archive/graphviz/2009.5.1/doc/html/Data-GraphViz.html#v%3AgraphToGraph is the function I was thinking of
20:59:40 <SamB> but it's not quite what you'd want
21:00:00 <SamB> you'd want something that would allow positional information to be passed *in* as well
21:00:48 <ClaudiusMaximus> kpreid: sounds like something i might like to take a look at
21:03:12 <kpreid> ClaudiusMaximus: well, it was rather unfinished. I didn't publish it. if you're still interested let me know *tomorrow* and I'll see about it
21:13:47 <bos> sigfpe warps my brain, as usual
21:15:48 <SamB_XP> personally, I think I find SIGSEGV from vm86() more interesting
21:16:30 <TheColonial> Hi guys, can someone give me a hand with an exercise i'm trying to do with Applicative functors?
21:16:59 <Cale> okay
21:17:00 <Berengal> TheColonial: Sure we can. What's the problem?
21:17:26 <TheColonial> Berengal: Thanks :) I'm trying to get my head around how they work, so I thought I'd attempt to implement an Applicative functor for a tree like structure. defined:
21:17:43 <TheColonial> data Tree a = Node a [Tree a] deriving (Show)
21:17:52 <TheColonial> simple stuff right?
21:18:06 <TheColonial> so i have figured out the functor, and I understand that...
21:18:17 <TheColonial> data Tree a = Node a [Tree a] deriving (Show)
21:18:19 <TheColonial> oops
21:18:40 <TheColonial> instance Functor Tree where
21:18:42 <TheColonial>     fmap f (Node n ns) = Node (f n) (map (fmap f) ns)
21:18:47 <TheColonial> that's what i came up with
21:18:56 <TheColonial> now i'm trying to tackle applicative functors
21:19:11 <TheColonial> at first i thought that i would end up with a tree of trees.. but that's obviously wrong :)
21:19:26 <pumpkin> :t (<*>)
21:19:29 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
21:19:36 <TheColonial> so i'm struggling to visualise a valid end result before i can even attempt to write the applicative functor
21:19:45 <pumpkin> so you have a tree of functions, and want a function that takes trees to trees
21:19:57 <TheColonial> pumpkin: Thanks, I have that down already... hence I knew tree of trees was wrong :)
21:20:14 <TheColonial> well, as an exercise yes.. but i dont even know if it's a valid thing to do!
21:20:20 <TheColonial> yup, I'm a noob :)
21:20:50 <Cale> There are a few ways you could try to handle it. Probably the simplest one would be the "zipping" approach.
21:21:27 <TheColonial> aye, that's what i thought
21:21:30 <TheColonial> but first...
21:21:42 <TheColonial> i need to see what the result of the following would be:
21:21:48 <TheColonial> x = Node 1 [Node 2 []]
21:21:50 <TheColonial> y = Node 3 [Node 4 []]
21:22:06 <TheColonial> (+) <$> x <*> y
21:22:14 <TheColonial> that is what Im finding confusing :)
21:22:33 <TheColonial> would anyone be able to guess what the result might look like?
21:22:36 <Berengal> It could be Node 4 [Node 6 []]
21:22:45 <aavogt> instance Applicative Tree where (Node f _) <*> t = fmap f t -- does this pass the laws?
21:22:54 <Cale> Yeah, with the zipping approach, it would be pointwise.
21:23:07 <dmwit> aavogt: What's pure?
21:23:13 <dmwit> aavogt: All the laws use pure. =)
21:23:18 <TheColonial> aavogt: doesn't that ignore the full list of functions?
21:23:22 <TheColonial> s/list/tree
21:23:42 <aavogt> right, pure = flip Node []
21:23:55 <dibblego> TheColonial, do x' <- x; y' <- y; return (x + y)
21:24:27 <dmwit> aavogt: It doesn't pass the pure (.) <*> u <*> v <*> w = u <*> (v <*> w) law, I think.
21:24:40 <aavogt> TheColonial: yep
21:24:49 <dmwit> err..
21:24:55 <TheColonial> aavogt: is that how  it should work?
21:25:03 <TheColonial> aavogt: i thought it'd have to parse the whole tree?
21:25:51 <jmcarthur> there is no law that requires that
21:25:53 <dmwit> aavogt: Actually, that law passes, but u <*> pure y = pure ($ y) <*> u -- this one doesn't pass.
21:25:54 <TheColonial> ok guys i'm a bit lost :)
21:26:16 <dmwit> TheColonial: Ignore aavogt and go with the zipping idea. ;-)
21:26:23 <aavogt> TheColonial: I think the "zipping" approach suggested by Cale is probably a more useful instance. The one I suggested seems to break some laws...
21:26:57 <TheColonial> dmwit: aavogt: ok... would you be able to show me what my example would result it in if I had the correct implementation? :)
21:27:04 <TheColonial> that's what I'm struggling to visualise more than anything
21:27:14 <dmwit> TheColonial: See Berengal's answer above, he got it right.
21:27:31 <TheColonial> ok, so how did he get that result? it doesn't make sense to me (yup, i feel stupid)
21:27:53 <jmcarthur> TheColonial: there is often more than one way to define the semantics of a type class instance for some type. the suggested semantics is zipping
21:28:08 <jmcarthur> where zipping is simple left-to-right application of functions to arguments
21:28:12 <TheColonial> ah i see it, perhaps if i give another example.... let's pretend that y had another element
21:28:15 <dmwit> One way to think of it is to imagine laying the trees on top of each other, then applying the functions in the top-most tree to the values in the bottom tree.
21:28:46 <dmwit> If there are places where there's a tree only on top or only on bottom, the result doesn't have any tree there.
21:28:55 <TheColonial> dmwit: right, i see, so in other words, if using the zipping approach, wed simply ignore those leaves which don't have respective functions and vice versa?
21:29:03 <dmwit> right
21:29:04 <TheColonial> thank you :)
21:29:07 <mriou> hi, question about monad transformers
21:29:14 <mriou> I'm defining a stack with more than one StateT and would like to use deriving on the new type
21:29:17 <TheColonial> i'll be back with my attempt for scrutiny!
21:29:26 <Berengal> TheColonial: Also, the 'pure' function needs to create an infinitely wide and infinitely deep tree
21:29:33 <mriou> how can I derive several times MonadState (... deriving (MonadState Foo, MonadState Bar)) ?
21:29:37 <dmwit> mriou: Fundeps mean you only get to derive MonadState once, I'm afraid.
21:29:55 <jmcarthur> mriou: MonadState (Foo, Bar) might be nicer
21:29:58 <mriou> dmwit: thought so, but it was worth checking :)
21:30:30 <dmwit> Yep, jmcarthur's suggestion is nice (though you have to write the instance yourself, then).
21:30:35 <mriou> jmcarthur: yeah. that might end up being easier
21:31:09 <mriou> just wanted to try the full-on monadic transformer thing first :)
21:31:32 <dmwit> You can still use a monad transformer with two StateTs in it.
21:32:17 <dmwit> instance MonadState (Foo, Bar) (StateT Foo (StateT Bar Id)) where get = liftM2 (,) get (lift get)
21:32:22 <jmcarthur> mriou: it's typical to not use the transformer stack directly, but to abstract it as a new type and define specific operations on it. you could hide one StateT behind such an abstraction and then still be able to put another StateT on top
21:32:27 <mriou> dmwit: but I won't be able to make it an instance of MonadState that could access both states, right?
21:32:34 <dmwit> mriou: ;-)
21:32:40 <dmwit> I type the answers faster than you type the questions. =)
21:33:04 <mriou> dmwit he he that's useful
21:33:14 <dmwit> 'course, you have to mess with some newtype wrapping and unwrapping
21:33:16 <dmwit> But you get the idea.
21:33:30 <mriou> dmwit I think so yes
21:34:35 <mriou> jmcarthur: in practice, which approach is "better", declare new types for each state or the (Foo, Bar) trick?
21:35:11 <jmcarthur> mriou: depends on whether it makes sense for the MonadState to be exposed or not
21:35:45 <dmwit> If you have a choice, I strongly recommend collapsing all your StateTs into one.
21:35:54 <jmcarthur> and you don't necessarily have to make a new type for each state, just a new type for each abstraction
21:35:55 <dmwit> Of course, you don't always have the luxury of choice. =)
21:36:05 <mriou> dmwit: why? performance?
21:36:14 <jmcarthur> simplicity
21:36:18 <dmwit> mriou: Nah, because you can get the compiler to write more of your code for you.
21:36:43 <mriou> ok, makes sense
21:37:02 <jmcarthur> mriou: you could consider your state to be a record of values, rather than a single value
21:37:35 <jmcarthur> even though it is just a single value
21:37:54 <mriou> jmcarthur: yes, it's actually a global state that has several 'entries'
21:38:32 <mriou> so I guess in that sense it's appropriate to consider it as a single state, same lifecycle
21:39:05 <mriou> jmcarthur, dmwit thanks a lot for the help
21:42:32 <TheColonial> Berengal: Infintely wide and deep? why is that?
21:42:48 <Berengal> TheColonial: What else would it be?
21:43:00 <TheColonial> Berengal: touche :)
21:43:22 <Berengal> pure x = let tree = Node x (repeat tree) in tree
21:44:16 <kniu> sometimes, I wish Haskell discriminates between let, let*, letrec and letrec*
21:45:02 <idnar> I have no idea what that means
21:45:50 <pumpkin> kniu: why?
21:45:50 <Axman6> wth is letrec?
21:46:07 <jmcarthur> recursive let
21:46:12 <luqui> let*?
21:46:17 <jmcarthur> i dunno what that is
21:46:17 <luqui> multiple bindings?
21:46:26 <kniu> let* is sequential.
21:46:34 <Cale> A french painter? No, no, that was Lautrec.
21:46:37 <jmcarthur> that makes no sense in haskell context to me...
21:46:49 <jmcarthur> sequential let, that is
21:46:57 <luqui> let* x = x + 1  -- uses the x from the outer scope?
21:47:10 <kniu> I just like being able to differentiate between which context I want the right hand values to come from.
21:47:14 <jmcarthur> oh
21:47:32 <jmcarthur> eh, i don't have a problem with the way let is right now, i think
21:47:33 <Cale> kniu: Well, you can always just not shadow things :)
21:47:45 <jmcarthur> -Wall complains about shadowing anyway
21:47:45 <Berengal> 'let* foo = x; bar = foo; foo = bar + 1' would be about the same as 'let foo = x in let bar = foo in let foo = bar + 1'
21:47:46 <luqui> what is the difference between let and let*?
21:47:49 <Cale> So long as you don't reuse variables, there's no difference.
21:47:55 <kniu> It sucks having to come up with new names for stuff.
21:47:55 * roconnor wishes all do was mdo
21:48:33 <luqui> roconnor, so x <- f x    would be an error for non MonadFixes?
21:48:38 <luqui> makes sense
21:48:45 <Berengal> kniu: This is what ' is for
21:48:46 <roconnor> x <- f x would add a MonadFix contraint
21:48:54 <luqui> kniu, I still don't know what the difference between let and let* would be
21:49:02 <kniu> I thought more guys in here would know Scheme.
21:49:15 <kniu> luqui, let in Scheme doesn't do recursion.
21:49:16 <pumpkin> I took SCIP a few years ago
21:49:17 <SamB_XP> kniu: we tend to forget those complicated nasty little details
21:49:26 <luqui> kniu, I didn't say letrec anywhere...
21:49:30 <pumpkin> SICP even
21:49:35 <luqui> kniu, both of those are nonrecursive
21:49:44 <kniu> it's equivalent to ((lambda (v1 v2 v3 ...) body) x1 x2 x3)
21:49:49 <Cale> I always thought it was ugly how scheme had so many variations on let, when all you need is the recursive one.
21:49:59 <luqui> kniu, which is?  let or let*?
21:50:02 <kniu> let
21:50:15 <luqui> kniu, and let* does them one at a time?
21:50:17 <roconnor> luqui: apparently let isn't even sequential
21:50:21 <SamB_XP> Cale: and how were they going to do that in a strict imperative langauge ?
21:50:25 <roconnor> it is simultaneous
21:50:31 <kniu> let* is equivalent to ((lambda (v1) (lambda (v2) (...))) x1 x2 ...)
21:50:39 <Cale> SamB_XP: hm?
21:50:51 <SamB_XP> Cale: that's what scheme *is*, you know
21:50:53 <luqui> oh, so let x = 42; y = x   does not define y = 42
21:50:55 <Axman6> > let !x = x + 1 in x - 1
21:50:57 <lambdabot>   Recursive bang-pattern bindings aren't allowed: { !x = x + 1 }
21:51:06 <Axman6> :(
21:51:09 <kniu> but let* x = 42; y = x does.
21:51:09 <Cale> SamB_XP: Well, if you want, but I still don't see your point.
21:51:10 <Axman6> > let x = x + 1 in x - 1
21:51:15 <lambdabot>   mueval-core: Prelude.read: no parse
21:51:16 <lambdabot>  mueval: ExitFailure 1
21:51:22 <Axman6> > let x = x + 1 in x - 1 :: Int8
21:51:27 <lambdabot>   mueval-core: Prelude.read: no parse
21:51:28 <lambdabot>  mueval: ExitFailure 1
21:51:33 <Axman6> ok, as expected
21:51:39 <luqui> kniu, eh, I like it better with only one semantics
21:51:41 <SamB_XP> I guess I just haven't seen too many strict imperative languages where the norm was letrec
21:51:55 <jmcarthur> huh?
21:51:56 <luqui> then when I'm reading, if I see x = ..., I don't have to scan for the binder to know what it means
21:52:03 <luqui> i just scan outward until I find a definition
21:52:17 <Cale> Explicitly having a separate non-recursive let just seems pointless to me.
21:52:20 <jmcarthur> i haven't seen any strict imperative languages where the norm *isn't* some equivalent to letrec
21:52:33 <pumpkin> @pl nonrecursive let
21:52:34 <lambdabot> (line 1, column 14):
21:52:35 <lambdabot> unexpected reserved word "let" or "l"
21:52:35 <lambdabot> expecting variable, "(", operator or end of input
21:52:35 <luqui> jmcarthur, huh?
21:52:41 <Cale> I mean, sure, you theoretically need a powerful fixpoint operator to implement recursive let
21:52:53 <luqui> jmcarthur, i've never seen an imperative language do letrec.
21:53:03 <jmcarthur> C, Ruby, etc. etc. all function definitions allow recursion
21:53:14 <SamB_XP> jmcarthur: ... that's not let!
21:53:15 <luqui> jmcarthur, oh, you're talking about functions.  yeah.
21:53:17 <roconnor> Cale: can you do let ((x y)  (y x)) to "swap" x and y?
21:53:45 <luqui> let (x',y') = (y,x)  :-)
21:53:54 <jmcarthur> eh, okay, i guess i missed that i made a very loose analogy
21:53:57 <Cale> See luqui's answer :)
21:54:05 <roconnor> Cale: in scheme I mean
21:54:17 <pumpkin> in ruby I can do that
21:54:28 <Cale> roconnor: I think so.
21:54:44 <roconnor> I guess that is why they have separate let and let*
21:54:49 <Cale> (though I think it's just confusing to do that)
21:56:26 <Cale> > (define x 1)
21:56:26 <Cale> > (define y 2)
21:56:26 <Cale> > (let ((x y) (y x)) (list x y))
21:56:26 <Cale> (2 1)
21:56:29 <lambdabot>   <no location info>: parse error on input `)'
21:56:29 <lambdabot>   Not in scope: `define'
21:56:29 <lambdabot>   Not in scope: `define'
21:56:36 <Cale> oops, sorry :)
21:56:59 <Cale> But yes, it works, though I don't see why you'd ever actually want to do that.
21:57:45 <Cale> It's so much clearer when you don't shadow variables.
21:58:32 <luqui> also it pushes the headslap idea for noobs farther down the line, since it appears that let x = x+1  works as intended
21:59:02 <SamB_XP> Cale: that's probably why sparse warns about that
22:26:55 <supermanchhakchh> main = do
22:26:55 <supermanchhakchh>     h <- connectTo server (PortNumber (fromIntegral port))
22:26:55 <supermanchhakchh>     hSetBuffering h NoBuffering
22:26:55 <supermanchhakchh>     t <- hGetContents h
22:26:55 <supermanchhakchh>     print t
22:27:07 <supermanchhakchh> ANY DEMALE WHO WANTS TO CHAT
22:27:34 <Axman6> lambdabot is a demale
22:27:41 <supermanchhakchh> ANY FEMALE WHO WANTS TO CHAT
22:27:44 <supermanchhakchh> SORRY
22:27:51 <Axman6> @vixen supermanchhakchh is hot for you
22:27:52 <lambdabot> *giggles*
22:28:58 <sjanssen> supermanchhakchh: uh, what?
22:29:29 <Axman6> :t (&&&)
22:29:29 <Cale> haha
22:29:30 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
22:29:40 <supermanchhakchh> JUST WANT TO MEET CHICKS
22:29:47 <Nigga[Jew]> i have a large penis and lots of money
22:29:48 <supermanchhakchh> WHO CAN MAKE ME HAPPY
22:29:51 <Nigga[Jew]> nigga jew powers!
22:30:04 --- mode: ChanServ set +o sjanssen
22:30:08 --- mode: sjanssen set +b *!*n=NaDa@87.196.235.*
22:30:08 --- kick: Nigga[Jew] was kicked by sjanssen (sjanssen)
22:30:52 <sjanssen> supermanchhakchh: is this some sort of joke I don't get?  Please keep the discussion on Haskell
22:30:59 --- mode: ChanServ set -o sjanssen
22:31:17 <Axman6> #haskell is certaily not the place to meet chicks
22:31:27 <ClaudiusMaximus> afaik you shouldn't use the PortNumber constructor (use PortNumber's Num instance instead)
22:32:03 <supermanchhakchh> SORY
22:32:14 <Axman6> that was very odd
22:32:32 <Axman6> :t (&)
22:32:33 <Tsion> Haskell doesn't get people like that very often?
22:32:33 <lambdabot> Not in scope: `&'
22:32:39 <Axman6> nope
22:32:42 <Cale> Tsion: Hardly ever.
22:32:49 <Axman6> first time i've seen it that i can remember
22:32:59 <sjanssen> Tsion: we get a few people that clearly clicked the wrong channel
22:33:06 <sjanssen> but this one pasted some on-topic stuff first
22:33:19 <Axman6> yeah, that was very confusing
22:34:58 <MMcGee> Can someone help me with an excercise from YAHT?
22:35:21 <luqui> MMcGee, just ask
22:35:47 <MMcGee> data Tuple a b c d e = One a
22:35:47 <MMcGee> | Two a b
22:35:47 <MMcGee> | Three a b c
22:35:47 <MMcGee> | Four a b c d
22:36:07 <MMcGee> it asks you to write a function to convert this to a haskell n-tuple
22:36:13 <MMcGee> n being the size of the data tuple
22:36:18 <MMcGee> using either
22:36:29 <Axman6> ouch
22:36:38 <MMcGee> im looking at the answer and i dont understand how they have nested left/right
22:36:51 <MMcGee> fromTuple :: Tuple a b c d -> Either (Either a (a,b)) (Either (a,b,c) (a,b,c,d))
22:36:55 <MMcGee> i can understand the type
22:36:56 <MMcGee> but then
22:37:01 <MMcGee> fromTuple (One a ) = Left (Left a
22:37:15 <MMcGee> what exactly is Left ( Left a ) doing here?
22:37:26 <Axman6> @src Either
22:37:26 <lambdabot> Source not found. Take a stress pill and think things over.
22:37:39 <Axman6> um
22:37:56 * inimino offers Axman6 a stress pill
22:38:08 <Axman6> MMcGee: that's the Either (Either a .. part of the type signature
22:38:46 <MMcGee> But isnt a just an instance of Tuple, not an Either?
22:38:54 <MMcGee> how can we get the left of a "One"
22:39:19 <Axman6> i'm not sure what you mean
22:39:50 <Axman6> i thing the definition for Two would be fromTuple (Two a b) = Left (Right (a,b)) right?
22:39:58 <MMcGee> yeah
22:39:59 <johnnowak> MMcGee: it's not getting the left of 'a', it's creating an Either type from 'a'
22:40:00 <Axman6> MMcGee: do you understand the Either type?
22:40:10 <MMcGee> i think so
22:40:16 <MMcGee> so "Left" is making a new instance?
22:40:24 <Axman6> it's a constructor
22:40:30 <johnnowak> you could say that. It's a constructor, not an accessor.
22:40:35 <Axman6> data Either a b = Left a | Right b
22:40:43 <MMcGee> but wouldnt the function return an instance of the either type rather than a tuple?
22:40:54 <johnnowak> MMcGee: yes, Left returns an either
22:40:57 <MMcGee> if Left (Left a) was constructing an Either?
22:41:02 <Axman6> MMcGee: yes, it's returning Eithers, with typles in the,
22:41:09 <MMcGee> the function returns a haskell tuple though?
22:41:10 <Axman6> it's constructing two eithers reallty
22:41:14 <Axman6> no
22:41:20 <MMcGee> oh :/
22:41:28 <johnnowak> fromTuple returns an either
22:41:44 <MMcGee> Right
22:41:44 <Axman6> look at the type again
22:41:45 <Axman6> fromTuple :: Tuple a b c d -> Either (Either a (a,b)) (Either (a,b,c) (a,b,c,d))
22:42:10 <Axman6> it returns an Either with with a nother Either inside
22:42:44 <ryant5000> so, i'm interested in writing a video game using FRP; what's the best FRP implementation to use?
22:42:57 <ryant5000> i've seen Yampa, Grapefruit, and Reactive
22:43:00 <MMcGee> so how would we get the tuple out of the return value from the fromTuple function?
22:43:04 <Axman6> so you have four choices: Left (Left a), Left (Right (a,b)), Right (Left (a,b,c)), or Right (Right (a,b,c,d))
22:43:21 <Axman6> MMcGee: you can't really
22:43:26 <luqui> ryant5000, i haven't seen an frp which is good for a "whole program"
22:43:42 <luqui> ryant5000, but it's good at localized stuff, like the behavior of a single entity
22:43:46 <Axman6> you can't have a function that can return both say (a,b) and (a,b,c)
22:43:53 <luqui> ryant5000, Yampa being the most mature, though I haven't played with grapefruit
22:44:02 <luqui> ryant5000, don't touch reactive yet unless you're a researcher
22:44:10 <MMcGee> ok, thanks
22:44:30 <Axman6> it'd have to have a type like Tuple a b c d -> a | (a,b) | (a,b,c) | (a,b,c,d), which you can't do in haskell
22:44:38 <MMcGee> right
22:44:57 <MMcGee> but i dont get why exactly we would want this function then
22:44:57 <ryant5000> luqui: well, i'm not a researcher by trade, but i didn't have much difficulty understanding Conal's paper on Reactive
22:45:05 <MMcGee> if its returning one of four things, and we cant tell which?
22:45:23 <luqui> ryant5000, i mean as far as the stability of the library.  it's a very cool idea, but it needs work to be viable.
22:45:50 <luqui> ryant5000, the implementation is beautiful, but not ready.  whereas the others are much more ready, and much less beautiful
22:46:25 <Axman6> MMcGee: well, the function is wort of useless, but it highlights being able to return alternatives i guess
22:47:07 <Axman6> sort*
22:47:14 <MMcGee> ok, i get it now
22:47:28 <ryant5000> luqui: hm... well, i'm starting a (for-profit) game studio based on Haskell; so i see two main alternatives here: either get a short-term benefit from using a well-developed one, or make an investment in a less-well-developed (but more promising) one, which becomes a long-term asset (to my company as well as the haskell community)
22:48:01 <luqui> ryant5000, see Anygma for prior art
22:48:09 <ryant5000> luqui: so i guess the question is: how much work does it need to be viable?
22:48:29 <luqui> ryant5000, the software world is just barely becoming ready for FRP.  i wouldn't put any financial investment on it.
22:48:58 <luqui> ryant5000, you can try reactive, but it is unknown how much work it will take
22:49:05 <thoughtpolice> AFAIK, the main thing holding up reactive was an issue with ghc/unamb, which has been fixed since ghc 6.10.2 - but I still can't get much stuff to work using it, e.g. reactive-fieldtrip
22:49:20 <luqui> ryant5000, use good software engineering to build in a backup plan, at the very least
22:49:22 <thoughtpolice> since then I just don't think conal has had as much time to put into it
22:49:39 <ryant5000> luqui: yeah, that's definitely important
22:49:56 <luqui> thoughtpolice, unamb is what we think the problem is.  but there's no guarantee that that's the only problem
22:49:57 <ryant5000> luqui: most of the most difficult parts of a game probably wouldn't be written in reactive style anyway
22:50:09 <luqui> ryant5000, why not?
22:51:01 <ryant5000> luqui: hm; well, i was assuming that physics steps could be pretty easily isolated from the reactive paradigm
22:51:03 <Axman6> hmm, anyonw know of a nice definition for a FIFO stack datatype?
22:51:06 <luqui> ryant5000, my vision is to be able to write a game without ever touching the IO monad.
22:51:12 <Axman6> seems that Chans could be used quite easily for this
22:51:14 <luqui> ryant5000, (all software, really)
22:51:26 <ryant5000> luqui: oh, i'm not proposing more IO
22:51:43 <ryant5000> luqui: i'm proposing more traditionally-pure code
22:51:51 <luqui> ryant5000, but... that's another story.  just, keep it real.  I started wanting to make a game in FRP, became an FRP researcher, and am now a foundations researcher
22:51:59 <luqui> FRP research extremely frustrating
22:52:25 <luqui> (this sentence no verb)
22:52:29 <ryant5000> lol
22:52:35 <ryant5000> (made sense anyway)
22:53:06 <ryant5000> well, hm
22:53:47 <ryant5000> so, what are the main issues?
22:53:51 <ryant5000> efficiency?
22:54:05 <luqui> ryant5000, there is a very very strong efficiency/expressivity tradeoff
22:54:37 <luqui> particularly, the desired *asymptotic* complexity is hard to achieve
22:54:43 <luqui> i.e. make reasonable programs not leak memory/time
22:54:47 <ryant5000> you mean particularly in FRP?
22:54:48 <ryant5000> ah ok
22:56:39 <luqui> and there are all sorts of almost-possible things which would make it all better
22:57:12 <luqui> so it leads you on... :-)
22:57:34 <luqui> i think focusing on purity is very important, but trying to make an FRP library is probably going to run you into walls
22:57:52 <luqui> model the precise kind of purity you need, rather than trying to encapsulate it all into a unified framework
22:58:49 <luqui> that's what i'd do, at least
22:58:53 <ryant5000> yeah, i've often thought that Haskell's notion that there's a single universal definition of "purity" was rather odd
22:59:17 <luqui> ryant5000, huh?  it defines what it means by that term
22:59:32 <ryant5000> well, i'm sure the tech docs are quite clear
22:59:36 <ryant5000> and the papers and such
22:59:41 <luqui> enough to give all values an extensional mathematical semantics
22:59:53 <dolio> I suspect the report doesn't say much about "purity" at all.
23:00:23 <dolio> Not that I've done any specific reading of it for that purpose.
23:01:00 <ryant5000> well... i suppose i'm just disputing haskell's choice of a definition of purity
23:01:17 <luqui> ryant5000, feel free to define it however you like.  :-)
23:01:30 <sjanssen> ryant5000: what do you mean?
23:01:32 <ryant5000> i do :P
23:01:37 <dolio> What I'm saying is, I don't think "Haskell" has a definition of "purity".
23:01:46 <dolio> :)
23:01:57 <dolio> Amr Sabry has one that applies to Haskell, though.
23:02:17 <ryant5000> gah, i didn't mean to start a debate really; i'm not trying to say that anyone's incorrect
23:02:23 <dolio> More or less. You'll get argument from some people, of course.
23:02:47 <luqui> ryant5000, sure.  we're just wondering why you would dispute that...
23:03:07 <ryant5000> well, particularly the absence of time from the domain of discourse
23:03:33 <luqui> ryant5000, absense of time *and* space
23:03:35 <ryant5000> observational equivalence only gets you as far as you can observe
23:03:37 <ryant5000> yeah
23:03:51 <pumpkin> and heat emitted, and energy consumption!
23:03:54 <luqui> ryant5000, because including those things mucks up your reasoning when you're *not* interested in them
23:04:01 <ryant5000> right
23:04:04 <pumpkin> (which may or may not be proportional to the other ones)
23:04:15 <ryant5000> so what i've been wondering about recently is whether there'd be some way of modularly including or excluding those things
23:04:32 <luqui> ryant5000, dana's strategy: use layers of expressivity, with the lowest layer talking about all those real world issues, and take them away one at a time
23:04:33 <ryant5000> in the same way that typeclasses can be applied to type signatures
23:04:46 <luqui> ryant5000, you'd first have to come up with *any* way to talk about them
23:04:53 <luqui> which is an open problem in CS research for sure
23:04:53 <ryant5000> that's true :P
23:05:29 <luqui> i am a huge fan of the extensional denotational semantics for talking about a wide variety of things though
23:05:46 <luqui> and i hope to use it as a reasoning tool (not execution) for talking about the harder things
23:05:48 <ryant5000> anyway, i'm not so happy about the type system choosing the things that the programmer cares about for him
23:05:56 <ryant5000> ah, that sounds interesting
23:06:35 <luqui> it's all pie-in-the-sky right now though :-)
23:06:35 <pumpkin> it's the most easily quantifiable
23:06:58 <pumpkin> you return what you explicitly say you return... the rest are "covert channels" :P
23:07:04 <ryant5000> everything starts out pie-in-the-sky :P
23:07:36 <ryant5000> pumpkin: lol; covert channels are *exactly* what ever programming system needs :P
23:07:40 <ryant5000> *every
23:07:52 <pumpkin> I admit, it'd be nice for a system that can prove things about them too
23:07:59 <pumpkin> no more timing attacks on crypto implementations and the like
23:08:15 <ryant5000> well, i'd be surprised if you could completely eliminate covert channels
23:08:19 <pumpkin> me too :)
23:08:48 <ryant5000> but you can certainly know some things about them
23:09:10 <ryant5000> i suppose i'm mostly just begging for more CS research :P
23:09:23 <luqui> i'm an advocate of systems which know enough about themselves to be able to prove lots of stuff
23:09:28 <luqui> (and not prove it if you don't want to)
23:10:00 <luqui> eg. types are nothing essential; they're just properties of typeless functions
23:10:53 <ryant5000> right
23:11:11 <ryant5000> some of which proofs might be very useful to the compiler in producing code
23:11:17 <ryant5000> (e.g.: the size of a datastructure)
23:12:11 <Neut> hey,
23:12:19 <Neut> can someone explain what is wrong with this statement:
23:12:25 <Neut> toEnum 69
23:12:31 <Neut> || toEnum '69'
23:12:41 <pumpkin> ?
23:12:47 <luqui> ;t toEnum 69
23:12:51 <Cale> :t toEnum
23:12:52 <pumpkin> 69 isn't a character literal
23:12:53 <Neut> if I try to evaulate that in ghci for example
23:12:53 <lambdabot> forall a. (Enum a) => Int -> a
23:13:00 <pumpkin> "69" maybe?
23:13:11 <pumpkin> but even then, [] isn't an instance of Enum is it?
23:13:13 <Cale> toEnum turns an Int into any enumerable type
23:13:16 <luqui> Neut, are you looking for "read"?
23:13:21 <Cale> > toEnum '69' :: Char
23:13:22 <lambdabot>   <no location info>:
23:13:23 <lambdabot>      lexical error in string/character literal at chara...
23:13:23 <luqui> > read "42" :: Int
23:13:24 <lambdabot>   42
23:13:32 <Cale> > toEnum 69 :: Char
23:13:34 <lambdabot>   'E'
23:13:48 <Axman6> :t toEnum
23:13:49 <lambdabot> forall a. (Enum a) => Int -> a
23:14:02 <Cale> > fromEnum 'E'
23:14:03 <lambdabot>   69
23:14:08 <Neut> got it
23:14:10 <Neut> thanks
23:23:20 <jordandanford> hi, I'm new to Haskell, and I'm having a bit of trouble with types and typeclasses
23:23:55 <jordandanford> I'm trying to write a function that compares test answers (such as "abcbada") with a reference and returns how many are correct
23:24:34 <jordandanford> the function looks like this
23:24:35 <jordandanford> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2589#a2589
23:25:22 <luqui> jordandanford, try using length, filter, and zipWith
23:25:29 <Axman6> what you'll want it something like: score x y = foldr (\b acc -> if b then acc + 1 else acc) 0 $ zipWith (\a b -> a == b) x y
23:25:30 <luqui> that accumulator fold isn't really neessary
23:26:15 * Axman6 would just use score x y =  length . filter id . zipWith (==) x $ y
23:26:18 <jordandanford> luqui: can you be more specific, please?
23:26:38 <luqui> jordandanford, well i don't want to do it for you.  your zipWith looks good
23:26:49 <luqui> you just want to filter out all the ones that are true, and then count them
23:27:00 <jordandanford> okay
23:27:16 <jordandanford> just out of curiosity, why isn't my version working?
23:27:22 <jordandanford> I get the this error: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2591#a2591
23:27:28 <luqui> oh your currying is a little too aggressive
23:27:44 <luqui> changing score to score x y, and zipWith (...) to zipWith (...) x y  would do it
23:27:46 <luqui> as Axman6 said
23:27:55 <jordandanford> really?
23:27:59 <luqui> i think so
23:28:02 <Axman6> yeah
23:28:02 <Cale> jordandanford: yeah
23:28:24 <jordandanford> I've been reading 'Learn You a Haskell...' and there are a lot fo similar examples
23:28:26 <jordandanford> *of
23:28:37 <luqui> the problem is $
23:28:51 <luqui> if you were currying over one argument, you would have to change that to .
23:29:14 <luqui> but since you are currying over 2, you'd need a 2 argument composition (fmap (.) I think), which is getting too complex to be clean
23:29:21 <jordandanford> oh, okay
23:30:04 <Cale> If you can write your function like  f x = u . v $ x, then you can also write f = u . v
23:30:55 <Axman6> but you can't write f x y = u $ v x y as f = u . v
23:31:24 <jordandanford> I see
23:31:46 <Cale> Though you could write it like f x = u . v x
23:31:55 <Cale> But that's liable to be confusing :)
23:32:02 <jbauman> :t (. (.))
23:32:03 <Axman6> indeed
23:32:03 <lambdabot> forall c b c1 a. (((a -> b) -> a -> c1) -> c) -> (b -> c1) -> c
23:32:11 <Axman6> bad jbauman
23:32:20 <Cale> Or if you want more confusing, you could go with  f = (u .) . v
23:32:29 * jbauman hides in corner
23:32:30 <jordandanford> okay, too much
23:32:32 <jordandanford> :)
23:32:44 <luqui> :t curry $ length . filter id . uncurry (zipWith (==))
23:32:45 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Int
23:32:55 <luqui> we're just being nerds
23:33:45 <jordandanford> haha I noticed
23:33:58 <Cale> jordandanford: Though, yeah,  length . filter id  is probably clearer than that fold
23:34:06 <jordandanford> okay, thanks
23:35:23 * Axman6 was quite proud he came up with that length . filter id thing
23:35:38 <jordandanford> it's very crafty
23:36:29 <luqui> :t (length . filter id <$>) . zipWith (==)
23:36:31 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Int
23:36:46 <jordandanford> okay well I'm gonna go try out some more stuff
23:36:47 <pumpkin> why use <$> there and not just . ?
23:36:54 <jordandanford> thank you all!
23:37:03 <luqui> pumpkin, beats me.
23:37:08 <pumpkin> :)
23:37:11 <luqui> i would most like to use "result"
23:37:43 <luqui> er i'm not sure.  i feel like this should have a really super mega clean solution
23:37:59 <luqui> but i can't get rid of the two argument cruft
23:38:26 <pumpkin> :t transpose
23:38:27 <lambdabot> forall a. [[a]] -> [[a]]
23:38:32 <pumpkin> :P
23:38:38 <pumpkin> that'd make it even uglier though
23:38:59 <luqui> transpose is the universal black magic function? :-)
23:38:59 <jbauman> luqui, this is why we have to switch to stack-based languages :P
23:39:05 <pumpkin> how about a parallel list comprehension?
23:39:21 <pumpkin> with a guard
23:39:25 <luqui> pumpkin, i don't want to mention either argument
23:39:33 <luqui> just eta expanding isn't too bad
23:39:38 <luqui> but i want it pointfree :-)
23:39:53 <pumpkin> onoes
23:40:10 <luqui> yeah i'm becoming a pointfree whore.
23:40:14 <luqui> but only when it's beautiful
23:40:19 <luqui> :-)
23:41:28 <luqui> :t let o = fmap.fmap in length `o` filter id `o` zipWith (==)
23:41:29 <lambdabot>     Couldn't match expected type `Bool' against inferred type `[a]'
23:41:29 <lambdabot>     In the first argument of `filter', namely `id'
23:41:29 <lambdabot>     In the second argument of `o', namely `filter id'
23:42:22 <Axman6> @check (fmap fmap fmap) == (fmap . fmap)
23:42:23 <lambdabot>   No instance for (GHC.Classes.Eq ((a -> b) -> f (f1 a) -> f (f1 b)))
23:42:23 <lambdabot>    aris...
23:42:27 <Axman6> :(
23:42:29 <kniu> All this time I didn't know how to use exceptions in Haskell.
23:42:37 <luqui> kniu, good!
23:42:44 <luqui> exceptions are for losers
23:42:51 <Axman6> and should eb avoided
23:43:09 <Axman6> produce code that connot produce exceptions, rather than code that can handle the possible ones
23:43:13 <luqui> i do know how to use them, but haven't used them for at least six months
23:43:34 <Axman6> my AVar package uses them, i think it does a pretty good job
23:43:48 <Axman6> i don't think that anyone has even used my AVar package though :(
23:44:04 <jbauman> Axman6, but what if exceptional conditions arise?
23:44:14 <luqui> jbauman, for example?
23:44:30 <Axman6> jbauman: how can they when you've written the code to not produce such conditions
23:44:35 <jbauman> can't think of anything at the moment :)
23:44:47 <luqui> Axman6, exactly! :-)
23:44:49 <Axman6> 1/0?
23:44:55 <jbauman> Axman6, the external conditions may be out of your control
23:45:05 <Axman6> but that's not your problem
23:45:15 <luqui> jbauman, if you could raise the exception, you could check for the condition
23:45:18 <jbauman> it's often made to be my problem
23:45:30 <jbauman> luqui, and...?
23:45:32 <luqui> speaking in abstractions is no good here
23:45:46 <jbauman> true enough
23:45:50 <luqui> these arguments arise from an imperative mindset
23:45:52 <BMeph> luqui: We should see about "drafting" edwardk into making a fork of one of the FRP systems using comonads. ;)
23:45:58 <nbsd_in_prod> ok how is haskell different from standard ml?
23:46:08 <luqui> nbsd_in_prod, it is lazy
23:46:09 <Axman6> it's much more pure i believe
23:46:14 <nbsd_in_prod> build a world of warcarft clone in haskell
23:46:20 <nbsd_in_prod> just to show it off
23:46:25 <Axman6> why?
23:46:38 <luqui> why would we use a beautiful, simple language to write a horrible, complicate game
23:46:42 <jbauman> nbsd_in_prod, are you volunteering to do that?
23:46:52 <nbsd_in_prod> common lisp and haskell seem to be the most powerful programming languages?
23:47:07 <nbsd_in_prod> I will test out the game and rate the art of the monsters.
23:47:09 <luqui> BMeph, ... if comonads really are any good for FRP.  I'm not convinced...
23:47:09 <MMcGee> hah
23:47:33 <nbsd_in_prod> how is erlang different from haskell and common lisp?
23:47:53 <Axman6> it's designed with large scale concurrency in mind
23:47:53 <luqui> erlang isn't terribly functional afaik
23:48:12 <luqui> i.e. does not work smoothly with HOFs
23:48:13 <Axman6> luqui: i think it is, doesn't have ,utable variables
23:48:17 <Axman6> m*
23:48:24 <luqui> but i know little about erlang
23:48:39 <BMeph> luqui: I'd like to get some practice using them, but the "category-extras" module is pretty hefty.... =8*O
23:49:00 <luqui> the biggest, baddest way haskell differs from every other popular language to me is:  Haskell's semantics are denotational (composable)!
23:49:24 <luqui> BMeph, just rewrite the class yourself, why not?
23:49:45 <luqui> or are you talking about everything that is built on top of them?
23:50:13 <luqui> anyway, i'm not sure *Haskell* is good enough for FRP
23:50:40 <luqui> because it is trying to endow time upon a language which abstracts time away
23:51:01 <luqui> routing water from a leak into your sink
23:51:28 <BMeph> luqui: Does it really abstract it away, or was it simply overlooked as a controllable variable? ;)
23:51:40 <luqui> BMeph, same diff
23:52:02 <kniu> well, dang.
23:52:13 <kniu> I thought I had some beautiful purely functional code,
23:52:22 <BMeph> luqui: Well, the first argument implies that the exclusion of time was deliberate. ;)
23:52:43 <luqui> BMeph, i'm pretty sure that SPJ & co. were aware of the concept of time when designing the language
23:52:46 <kniu> but I'm threading one associative list through a whole bunch of functions, I kind of want to put it in a state monad.
23:53:01 <dmwit> If it never changes, consider Reader instead! =)
23:53:08 <Axman6> kniu: well stick it in the state monad then :P
23:53:16 <kniu> one hand: stay monad-free, pass the damn state explicitly,
23:53:33 <kniu> other hand: put it in a monad, lose pretty looking purity.
23:53:42 <luqui> the state monad is *for* pure code which threads a parameter.
23:53:45 <dmwit> And on the other hand... there is no other hand!
23:53:55 <Axman6> yeah, State is totally pure
23:53:58 <luqui> kniu, you don't have to use "do" to write monadic code
23:54:02 <Axman6> @src State
23:54:02 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
23:54:06 <Axman6> gah
23:54:10 <Axman6> why do you hate me luqui
23:54:12 <Axman6> uh, lambdabot
23:54:14 <luqui> kniu, use =<< and <=<
23:54:20 <kniu> wha
23:54:25 <kniu> :t (=<<)
23:54:25 <Axman6> if you hate me luqui, it'd be interested to know why too
23:54:26 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
23:54:27 <dmwit> luqui: <3
23:54:30 <luqui> Axman6, because you confuse me with a bot!
23:54:35 <Axman6> :(
23:54:37 <luqui> :-)
23:54:38 <dmwit> luqui: Thank you for not suggesting (>>=) and (>=>). =)
23:54:50 <kniu> :t (<=<)
23:54:51 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
23:54:57 <dmwit> kniu: Compare:
23:54:58 <dmwit> :t (.)
23:55:00 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
23:55:01 <luqui> kniu, composition of monadic functions
23:55:08 <kniu> how come I never seen these functions before?
23:55:17 <dmwit> Because people have bad taste!
23:55:26 <Axman6> because you never asked
23:55:41 * luqui loves kleisli composition
23:55:44 <flux> :t (>=>)
23:55:45 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
23:55:54 <dolio> <=< doesn't have a lot of strictly necessary uses.
23:55:59 <Axman6> @src (>=>)
23:55:59 <lambdabot> Source not found. :(
23:56:05 <Axman6> god damn lambdabot
23:56:08 <dolio> It's a lot like how you don't have to use (.) when you have the current ($).
23:56:13 <Axman6> @src (>>=)
23:56:13 <lambdabot> Source not found. My pet ferret can type better than you!
23:56:29 <Axman6> @src map
23:56:29 <lambdabot> map _ []     = []
23:56:29 <lambdabot> map f (x:xs) = f x : map f xs
23:56:30 <Axman6> ...
23:56:34 <Axman6> thank you!
23:56:38 <kniu> wait, those things are just >>= and >=> backwards.
23:56:39 <nbsd_in_prod> FRP being fantasy roleplaying game?
23:56:47 <Axman6> kniu: yes
23:57:31 <dmwit> Axman6: What were you expecting for (>>=)?
23:57:44 <Axman6> that's a good question really
23:57:58 <Axman6> still, i haven't been able to get any source from lambdabot all day
23:58:04 <dmwit> heh
23:58:21 <nbsd_in_prod> so ok
23:58:27 <nbsd_in_prod> I learned a bit of lisp.
23:58:31 <pumpkin> <=< is nice in some pointfree cases
23:58:35 <Axman6> nbsd_in_prod: FRP = functional reactive programming
23:58:40 <pumpkin> but I don't like the forward-pointing ones
23:58:48 <nbsd_in_prod> but the tutorial kinda ground to  a halt becaus eI couldn't figure out one of the exercises.
23:58:55 <luqui> right to left, top to bottom :-)
23:59:13 <nbsd_in_prod> functional reactive programming? is that anything like even driven programming?
23:59:20 <dmwit> luqui: Just like normal Hebrew, amirite?
23:59:20 <Axman6> btw, karnaugh maps are awesome
23:59:53 <Axman6> nbsd_in_prod: i think so, basically it lets you use pure code to react to events (i could be wrong, i've never used it or enquited too deeply)
