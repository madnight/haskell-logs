00:04:19 <Zrs> So how does extending the Haskell standard library work? A guy was talking about extending Data.Text - can anybody do that?
00:04:26 <Zrs> (Well, assuming the result passes some kind of peer review I guess.)
00:05:02 <Axman6> wll, you could just make a hackage package
00:05:11 <Axman6> well*
00:10:22 <Zrs> For sure, I was just curious how GHC and Haskell itself get extended. Since, reading about it, it seems like so many features are from the 90s :p
00:12:53 <thoughtpolice> Zrs: contribute patches. GHC is always being extended with new features :)
00:12:57 <wmealing> what ! features from the 90s' ?
00:13:20 <wmealing> oh lies, most languages are not even catching up with stuff from the older languages.
00:13:25 <Saizan> Zrs: the "standard" libraries get extended by discussion on the libraries@haskell.org mailing list, other extensions to GHC itself are a matter of discussing it with the developers afaiu
00:13:32 <wmealing> now i'm _really_ interested in haskell.
00:13:58 <Saizan> but extensions get also standardized as part of the Haskell' process
00:15:14 <Saizan> wmealing: heh, someone says that haskell is continuosly on the edge between research and industry :)
00:15:36 <Saizan> *some
00:15:53 <wmealing> the big kicker is, will haskell i write today, work next year.
00:16:22 <wmealing> from what i see, java made some questionable improvements in the language, which they cant tear out now due to people requiring it
00:17:31 <kynky> i thought generics was good
00:18:18 <opqdonut> kynky: they're pretty messed up
00:18:22 <opqdonut> because of erasure
00:18:28 <Saizan> things don't get added to the language itself, but yeah there are some problems with keeping backwards compatibility with Haskell98
00:18:29 <opqdonut> and because of stupid APIs
00:18:53 <opqdonut> like the put of Map<K,V> having type put(K key, Object value) ...
00:18:55 <Saizan> e.g. "fail" in the Monad class
00:19:19 <Saizan> opqdonut: really? why that type?
00:19:49 <opqdonut> no, sorry
00:20:04 <opqdonut> void put(K,V) but V get(Object)
00:20:22 <Saizan> still weird.
00:20:29 <opqdonut> to keep backwards compatibility with people passing Hashmaps ad-hoc objects that have an overrided hash()
00:20:40 <opqdonut> to fetch a specific value
00:20:41 <opqdonut> horrible
00:20:59 <Saizan> ugh
00:21:53 <Saizan> however the main problem is where the subtyping should be invariant and you've no way to specify that
00:22:17 <Saizan> imo
00:27:29 <opqdonut> Saizan: indeed
00:27:32 <opqdonut> subtyping is hard
00:28:50 <Saizan> though i still have to learn what ? means when used in place of a type variable :)
00:29:40 <SColes> nick Sam___
00:29:44 <SColes> argh
00:31:05 <Zao> I think you have too few underscores.
00:33:20 <opqdonut> Saizan: Foo<?> is the supertype of all Foo<something>
00:33:52 <opqdonut> so having a function that takes Foo<?> is like having a function Foo a -> ...
00:33:57 <opqdonut> with a not present in ...
00:35:04 <opqdonut> then we can also have Foo<? extends Bar>
00:35:10 <opqdonut> which functions in a similar way
00:36:06 <dibblego> Foo<?> is more like Foo (forall a. a)
00:36:28 <opqdonut> no, not really
00:36:46 <dibblego> i.e. existential qualifier
00:37:14 <opqdonut> Foo (exists a. a) would be quite like it, yes
00:37:30 <dibblego> er yeah that
00:37:35 <opqdonut> :)
00:37:36 <Saizan> not (exists a. Foo a) ? which is different from both of those :)
00:38:22 <opqdonut> yeah, that type is stronger
00:38:27 <opqdonut> or tells you more
00:39:28 <opqdonut> and most uses of ? are either structural or involve "defaulting" to Object since it is the least type
00:48:21 <etpace_> How do I have ifs in lambdas? so something like
00:48:47 <Philonous> can I use where clauses in guards like this f x | p x = g x where p = ... ? GHC gives my syntax errors
00:49:02 <|Jedai|> > (\b -> if b then "hello" else "goodbye) False
00:49:04 <lambdabot>   <no location info>:
00:49:04 <lambdabot>      lexical error in string/character literal at end o...
00:49:08 <|Jedai|> > (\b -> if b then "hello" else "goodbye") False
00:49:10 <lambdabot>   "goodbye"
00:49:18 <etpace_> hmm
00:49:38 <|Jedai|> etpace_: What's the problem with if in lambda ? They're an expression like everything else
00:50:10 <etpace_> > foldr (\x xs -> if x > xs then x else xs) id [5, 3, -1, 3, -30, 6]
00:50:12 <lambdabot>   No instance for (GHC.Num.Num (a -> a))
00:50:12 <lambdabot>    arising from the literal `5' at <...
00:50:37 <|Jedai|> etpace_: that doesn't make sense typewise
00:50:37 <Philonous> Never mind, I have to place the where after all the guards, I remember now
00:50:57 <etpace_> ah, I guess the id is throwing it?
00:51:21 <|Jedai|> etpace_: the "then x else xs" too (both branch must have the same type
00:51:38 <etpace_> so whats the correct way?
00:51:43 <|Jedai|> etpace_: and the (>), it's kinda hard to compare a number with a function
00:51:54 <|Jedai|> etpace_: what do you wan to do ?
00:52:02 <|Jedai|> *want
00:52:11 <etpace_> find the minimum number in a lis
00:52:13 <etpace_> t
00:52:43 <|Jedai|> > foldl1' min [5, 3, -1, 3, -30, 6]
00:52:45 <lambdabot>   -30
00:53:10 <etpace_> @src min
00:53:10 <lambdabot> min x y = if x <= y then x else y
00:53:23 <etpace_> @src foldl1'
00:53:24 <lambdabot> Source not found.
00:53:30 <|Jedai|> @src foldl1
00:53:31 <lambdabot> foldl1 f (x:xs) = foldl f x xs
00:53:31 <lambdabot> foldl1 _ []     = undefined
00:53:35 <nlogax> > minimum [5, 3, -1, 3, -30, 6]
00:53:37 <lambdabot>   -30
00:54:04 <|Jedai|> etpace_: foldl1' is just a stricter version of foldl1
00:54:25 <|Jedai|> nlogax: Well sure, but that doesn't tell him how it's done... :)
00:56:11 <nlogax> |Jedai|: *i* don't know how it's done. :D but i poked lambdabot and the source fell out
00:56:30 <|Jedai|> @src minimum
00:56:31 <lambdabot> minimum [] = undefined
00:56:31 <lambdabot> minimum xs = foldl1 min xs
00:56:59 <|Jedai|> nlogax: one of the problem of minimum though is that it is a little bit too lazy for most usage
00:57:01 <nlogax> does that mean it exploded on large lists?
00:57:28 <|Jedai|> nlogax: yes, though GHC optimize this with -O1 and -O2
00:57:28 <opqdonut> yeah, foldr' would be better
00:57:37 <opqdonut> yeah, strictness analysis bites
00:57:39 <nlogax> i see
00:57:42 <opqdonut> oops, foldl'
00:57:52 <etpace_> Is there an id element for compare?
00:58:07 <zloog> etpace_: what do you mean?
00:58:10 <opqdonut> etpace_: do you mean Ordering?
00:58:33 <Philonous> opqdonut: Only if (<) is lazy in it's second argument, otherwise you'd have to traverse the whole list anyway, and then foldl' is better, is it not?
00:58:43 <|Jedai|> opqdonut: foldl1' would be the best for most purpose, foldr1 would be better than foldl1 in lazy cases... So the foldl1 is just an error from the report IMHO
00:58:46 <Philonous> Oh, never mind
00:58:52 <opqdonut> :)
00:58:53 <Raevel> @type foldl'
00:58:54 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
01:01:07 <etpace_> yes I do sorry, something that x > identity returns x, same as x < identity
01:01:14 <Philonous> etpace_: Not generally
01:01:25 <Philonous> There are some types that have one, though
01:01:33 <|Jedai|> etpace_: only if x is an instance of Bounded
01:01:38 <opqdonut> well er
01:01:45 <opqdonut> x > identity can't return x
01:01:51 <opqdonut> unless x :: Bool
01:01:58 <opqdonut> but i guess you meant min x identity ?
01:02:08 <etpace_> yeah, sorry, that :P
01:02:19 <|Jedai|> opqdonut: Oh...right o_O
01:02:29 <etpace_> I guess passing the first item of the list works, as with foldl1, but i was just wondering if there is an identity
01:02:39 <opqdonut> and there can be no identity such that: min x identity === x, and max x identity === x
01:02:46 <opqdonut> if the ordering has over 1 element, that is
01:02:52 <|Jedai|> > map (\x -> min x maxBound) [1..20]
01:02:53 <opqdonut> (that x was forall-quantified)
01:02:54 <lambdabot>   Add a type signature
01:02:59 <|Jedai|> > map (\x -> min x maxBound) [1..20::Int]
01:03:01 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
01:03:40 <Philonous> opqdonut: is (<) required to be transitive?
01:04:13 <opqdonut> etpace_: you could do:
01:04:15 <opqdonut> > foldl max Nothing $ map Just [3,5,7,4,2,1]
01:04:16 <lambdabot>   Just 7
01:04:18 <opqdonut> Philonous: i'd guess
01:04:28 <opqdonut> that doesn't work with min though
01:04:32 <opqdonut> or wait
01:05:10 <|Jedai|> > mconcat . map Min $ [5, 3, -1, 3, -30, 6]
01:05:12 <lambdabot>   Not in scope: data constructor `Min'
01:05:14 <opqdonut> > foldl min (Right ()) $ map Left [3,5,7,4,2,1]
01:05:15 <lambdabot>   Left 1
01:05:36 <opqdonut> ?hoogle Minimum
01:05:36 <lambdabot> Prelude minimum :: Ord a => [a] -> a
01:05:36 <lambdabot> Data.ByteString minimum :: ByteString -> Word8
01:05:36 <lambdabot> Data.Foldable minimum :: (Foldable t, Ord a) => t a -> a
01:05:38 <|Jedai|> > mconcat . map Data.Monoid.Min $ [5, 3, -1, 3, -30, 6]
01:05:40 <lambdabot>   Not in scope: data constructor `Data.Monoid.Min'
01:06:14 <opqdonut> those two examples mainly exploit the default ordering instances for Either and Maybe
01:09:43 * Dae discovers unsafeperformIO and gets confused
01:09:57 <Dae> I thought IO was supposed to be one way only? no lifting?
01:09:57 <opqdonut> Dae: ignore it :)
01:10:04 <|Jedai|> Dae: don't ! don't use it
01:10:30 <Sam___> i did an unsafeperformIO once and got the clap
01:10:33 <Dae> Reading someone elses code which seem to use it for making foreign calls pure?
01:10:53 <|Jedai|> Dae: unsafePerformIO is for when you can prove that this IO won't destroy the referencial transparency
01:11:37 <|Jedai|> Dae: all foreign calls are by default in IO, but in reality some of them may be pure, so it's an accepted usage for unsafePerformIO
01:12:39 <Dae> I see....
01:12:41 <|Jedai|> Dae: using unsafePerformIO must only be when you're absolutely sure that it won't perturb Haskell
01:13:22 <|Jedai|> Dae: it's a way to tell the compiler "I know better than you", so you better be pretty sure of yourself since the compiler will trust you
01:13:50 * Dae gets an idea for using this to make a proper pure random and is instantly smited by the hand of dons
01:14:00 <Philonous> You can do cool stuff with it, though *cough* *cough*
01:14:14 <Dae> yeah, I'll stay away from it till I have to do FFI myself :)
01:14:21 <|Jedai|> Dae: Yeah, that for instance is a bad idea
01:14:40 <Taejo> Dae: pretty much any Haskeller wil smack you if you try that... that's what MonadRandom is for
01:15:03 <Taejo> does Leksah compile with GHC 6.8.2?
01:15:36 <lament> Dae: don't be surprised if your random number is the same every time
01:15:40 <Dae> it compiles with 6.10.3..... but yes, I think so
01:15:42 <Taejo> nevermind, the manual says no
01:16:36 <Dae> I know how to do random numbers, it's just... it sometimes feels forced and unnatural. Which I guess goes to show I
01:16:44 <Dae> I'm not awesome enough
01:17:18 <Taejo> Dae: when you're awesome, impure "functions" will seem unnatural
01:17:46 <Dae> impure functions do seem unnatural..... I'm still not thinking in monads...
01:18:04 <Philonous> Dae: There are some uses apart from FFI. There is the umab operator for example, but they had to go to great lengths to make it behave
01:18:06 <Dae> but using random with pure functions means passing a list around everywhere
01:18:14 <Dae> umab?
01:18:20 <Philonous> unamb*
01:18:41 <Philonous> It takes two expressions, evaluates them in parallel and return the result of the one that finishes first.
01:18:54 <Dae> :o
01:19:02 <Philonous> But of course you have to ensure they both return the same result except for bottom
01:19:30 <Dae> seems like an expensive way to choose between two algorithms?
01:20:18 <Philonous> Well, if you have two expressions and you don't know which of them (if any) will terminate, it is the only thing you can do
01:20:34 <Philonous> And it is a good thing to do if one is considerably cheaper than the other
01:20:38 <LeCamarade> Yay! I just install cabal!
01:20:46 <LeCamarade> But that was a torturous compile. :o)
01:21:54 <Dae> yum install cabal?
01:23:30 <quicksilver> I hope yum doesn't refer to the program "cabal-install" by the package name "cabal" ?
01:23:40 <quicksilver> that compounds what is already a confusing situation.
01:24:26 <Dae> no, it's called cabal-install
01:24:29 <Dae> my bad
01:24:31 <quicksilver> phew.
01:24:32 <quicksilver> ;)
01:25:05 <Dae> "yum install cabal" allows your computer to sacrifice goats though....
01:26:26 <quicksilver> Handy if you have to use scsi.
01:28:05 <Dae> or debug c++
01:44:47 <tibbe> I'm trying to generalize data types which support lookup into a type class but it seems that I need FlexibleInstances: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=6388#a6388
01:44:52 <tibbe> is there another way to do this?
01:45:05 <tibbe> the only keys/values that make sense in my case is Text
01:46:06 <Saizan> i wouldn't care about using FlexibleInstances or not
01:46:16 <Saizan> however you can avoid them with a newtype
01:47:54 <mmorrow> does anyone know what it means for isIEEE to be false?
01:48:14 <mmorrow> (denormalized floats or something iirc(?))
01:48:30 <Saizan> ?type isIEEE
01:48:33 <lambdabot> forall a. (RealFloat a) => a -> Bool
01:49:02 <Saizan> no, isIEEE just tells you if the type is implemented via IEEE 754 floats at all
01:49:10 <Saizan> the argument is phantom there
01:49:24 <Saizan> > isIEEE (undefined :: Double)
01:49:26 <lambdabot>   True
01:49:33 <tibbe> Saizan: how can I avoid them with a newtype?
01:49:36 <quicksilver> mmorrow: isIEEE being false doesn't tell you much at all :)
01:49:45 <mmorrow> quicksilver: heh, just found the src
01:49:54 <quicksilver> mmorrow: but, for example, you may not have Inf or NaN; maybe you don't have +0 and -0
01:49:56 <mmorrow> (const True) for Float and Double
01:49:57 <quicksilver> etc.
01:50:03 <Saizan> tibbe: newtype TextMap = TM (Map Text Text)
01:50:17 <Saizan> tibbe: and then instance Context TextMap where ..
01:50:21 <quicksilver> tibbe: use FlexibleInstances. They are fine.
01:50:40 <tibbe> hmm ok
01:50:49 <tibbe> quicksilver: which compilers support them?
01:50:51 <mmorrow> quicksilver: do you know offhand if the endianness of a machine has anything to do with the (as bits) rep of machine doubles/floats?
01:50:59 <quicksilver> tibbe: which compilers? There is only one compiler.
01:51:00 <quicksilver> ;)
01:51:07 <mmorrow> i don't think it does, but i
01:51:08 <quicksilver> mmorrow: yes, it does.
01:51:15 <mmorrow> :(
01:51:34 <quicksilver> mmorrow: they are byteswapped in exactly the same way any other 64 bit quantity would be
01:51:35 <mmorrow> quicksilver: do you know how :)
01:51:40 <mmorrow> dang
01:51:53 <mmorrow> the entire thing as a whole you mean?
01:52:00 <quicksilver> one of the properties of IEEE Double is that you can sort it as if it was a 64 bit integer.
01:52:03 <mmorrow> (or the subparts individually?)
01:52:10 <mmorrow> ah, that's helpful
01:52:14 <quicksilver> arguably that the was one of the ikey design choices
01:52:17 <mmorrow> (as a way to think about it)
01:52:27 <quicksilver> so you'd expect the byte order to follow that of 64 bit ints
01:52:30 <quicksilver> for consistency
01:52:32 <quicksilver> (and it does)
01:52:45 <quicksilver> in C you can even use htonl on them
01:53:09 <quicksilver> htonl(*((long long *)&mydouble)))
01:53:14 <quicksilver> or whatever the syntax is.
01:53:37 <quicksilver> of course, that's not defined by any C standard to work.
01:53:49 <quicksilver> it just happens to work on the common archs around today (sparc,ppc,intel)
01:54:27 <mmorrow> ah, that's another thing. so you'd say this is a legit way to check endianness (?):
01:54:29 <mmorrow> #if 0x00000001 == 1\n#define LITTLE_ENDIAN\n...
01:54:48 <quicksilver> erm, no.
01:54:50 <mmorrow> haha
01:54:56 <quicksilver> 0x00000001 is always 1.
01:54:56 <mmorrow> what is?
01:55:01 <mmorrow> crap
01:55:26 <mmorrow> (really? wow, i can't believe that's never bitten me before ;)
01:55:31 <quicksilver> int x = 0x01020304; if (((char*)&x)[0] == 1) { ... }
01:55:46 <mmorrow> ooh, nice.
01:55:47 <quicksilver> but really, why are you trying to check?
01:56:06 <mmorrow> quicksilver: i want to have a reliable way to check with CPP
01:56:13 <quicksilver> CPP doesn't know.
01:56:22 <mmorrow> #if ..here...
01:56:26 <mmorrow> possible?
01:56:47 <quicksilver> the best you can do is use CPP to generate code, but it will still be a runtime check.
01:57:00 <quicksilver> well, that's not quite true - you might hope your compiler can optimise it out.
01:57:11 <quicksilver> conceptually runtime though.
01:57:17 <mmorrow> can't you have simple expressions in a #if ?
01:57:27 <mmorrow> err, i guess only ==
01:57:37 <quicksilver> You can, but #if doesn't know about pointers. Or bytes, or bits.
01:57:42 <quicksilver> or data representation, or memory.
01:57:47 <quicksilver> CPP is a very simple functional language.
01:57:47 <mmorrow> sigh
01:58:06 * mmorrow starts googling for a portable way to determine this
01:58:15 <quicksilver> I think programs which are *genuinely* endian dependent use a configure script
01:58:22 <quicksilver> which sets a #define, which CPP can then see.
01:58:38 <mmorrow> yeah, i've got the autoconf manual open on another workspace, but i'm scared to read it
01:59:02 * mmorrow gives in to the inevitable
01:59:31 <Zao> Resorting to configure scripts makes Windows kitty cry.
01:59:49 <mmorrow> what makes windows kitty die?
01:59:51 <mmorrow> :)
02:00:14 <Zao> Killing it will only result in zombie kittens, gnawing on your legs.
02:00:26 <mmorrow> that's what i feared
02:00:41 <Dae> Windows kitty is outside in the cold rain, looking in at all the fancy things its sibling Linux is doing with haskell
02:01:05 <quicksilver> mmorrow: why don't you have a look at how Data.Binary does it?
02:01:12 <Zao> There's nothing more awesome than painstakingly getting all the dependencies for a Hackage package building and finally encountering a package that requires sh and friends.
02:01:15 <mmorrow> speaking of windows, how painful is getting the equiv of pthreads and mmap on windows?
02:01:31 <mmorrow> quicksilver: it uses a #define that ghc gets from autoconf iirc
02:02:00 <mmorrow> (from MachDeps.h via ghcautoconf.h or something)
02:02:03 <Zao> mmorrow: CRITICAL_SECTION instead of mutexen, CreateThread or _beginthreadex instead of pthread_create.
02:02:03 <Dae> Zao: yes, I wanted to get hmatrix and leksah working on windows....no dice
02:02:20 <Zao> As for mmap, sure has that too, but in a different form.
02:03:04 <Zao> CreateFileMapping or suchlike, I believe.
02:03:12 <Zao> MapViewOfFile.
02:04:00 <mmorrow> Zao: hmm, actually istr the mmap pkg on hackage supports windows, i bet i can take a peek at their cbits/ maybe
02:04:03 <Zao> Note that what's called "mutex" in the Windows API is a cross-process primitive, quite expensive.
02:04:28 <mmorrow> sounds pleasant
02:04:29 <Zao> More along the lines of a sysv semaphore in scope.
02:09:59 <mmorrow> Zao: hmm, it looks like ghc uses VirtualAlloc to alloc its heap on windows
02:12:58 <greap> Is there somewhere that explains the type syntax for things like (&&&)?
02:13:13 <Taejo> :t (&&&)
02:13:14 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
02:13:39 <Taejo> greap: which part don't you understand?
02:13:48 <greap> Taejo: Not something that tells me what the type is, but tells me how to interpret a type like that.
02:14:06 <Zao> Don't you know your ABCs? :)
02:14:12 <Taejo> which part makes it "a type like that"?
02:14:14 <greap> Taejo: I'm not sure about the parts that look like function application in the type.
02:14:22 <Taejo> ok
02:14:54 <quicksilver> greap: "a b c" means that "a" is a type constructor which takes two arguments, b and c
02:15:10 <quicksilver> an example would be "Either Int String" -- here, Either is the "a"
02:15:12 <Taejo> Is this better: forall ((~>) :: * -> * -> *) b c c'. (Arrow (~>)) => (b ~> c) -> (b ~> c') -> (b ~> (c, c'))
02:15:15 <quicksilver> greap: does that help?
02:15:19 <mmorrow> quicksilver: hrm, actually binary uses the #define to find out wordsize, it just reads a byte at a time and uses shiftl/r to deal with endianess
02:15:22 <greap> yes, that helps a lot
02:15:59 <sjanssen> mmorrow: you just want to determine endianness?  Just use a simple peek/poke from Foreign.*
02:16:03 <mmorrow> wait, what am i saying. hold on
02:16:12 <mmorrow> sjanssen: i want to det it at compile-time
02:16:16 <mmorrow> for a C program
02:16:18 <greap> I hadn't been able to find anything that summed it up as succinctly as that.
02:16:19 <sjanssen> mmorrow: TH?
02:16:23 <meder> what are some decent web services like weather and wiki and such?
02:16:32 <mmorrow> sjanssen: (C :)
02:16:39 <sjanssen> pssh, who writes C programs?
02:17:01 <mmorrow> windows kittens and zombies from what i understand from Zao ;)
02:17:15 <mmorrow> (although i may be misquoting him :)
02:18:26 <det> mmorrow, yay, I'm a verb now!
02:19:06 <mmorrow> det: heh
02:19:34 <mmorrow> quicksilver: so what i'm trying to sort out in my head is this:
02:21:36 <mmorrow> suppose you want to construct bitmaps that will be big-endian, in the sense that the first bit will be 0x80000000. so the code that constructs it needs to know the endianness of the machine it's running on, and then also the code that's interpreting it needs to know the endianness of the machine /it's/ running on (i'm just saying this out loud so to get it clear in my head)
02:22:41 <mmorrow> and Data.Binary doesn't actually care the endianess of the machine it's running on since it just does what the programmer tells it to (wrt *be, *le, *host)
02:23:26 <Zao> How about generating a suitable source file when building, say from Setup.hs or something?
02:23:30 <mmorrow> so what i'm unclear about is whether there's some endian-independent way to both build *and* interpret these bitmaps without a runtime check
02:23:57 <mmorrow> (and whether i need to even know the endianness of the host machine at all)
02:23:58 <Zao> (or configure, but that would be evil :)
02:24:35 <mmorrow> Zao: yeah, that's a good simple idea. i'll just have a little prog that determines all this info, which runs at compile-time
02:26:27 <mmorrow> (and spits out a .h on stdout)
02:33:35 <quicksilver> mmorrow: what is a "bitmap that will be big-endian" ?
02:33:58 <quicksilver> I suspect what you are describe does not need to know the endianness of the host machine at all.
02:34:08 <quicksilver> I suspect you can just do byte-based IO and you're fine.
02:34:40 <balor> Does ghc have some option to switch to haskell98?
02:35:23 <mmorrow> heh, i mean so the bits positions correspond to indexes into a length-32 array, and the code that's interpreting one of these bitmaps might be running on a machine with different endianness than that of the machine which created the bitmap
02:35:36 <mmorrow> *..i mean that the bit pos..
02:36:15 <mmorrow> quicksilver: and they're being interpreted over and over again as uint32_t's
02:36:33 <mmorrow> so not just a one-time-read and be-done-with-it
02:37:53 <mmorrow> quicksilver: hmm, actually that's an idea. maybe i can just flip all the endian-dependent parts to the host-endianness when i first read in the data
02:38:06 <quicksilver> the use network byte order and the standard byte-swapping commands?
02:38:44 <mmorrow> hmm, this could make things a lot easier
02:41:59 <quicksilver> htons/htonl is there for a reason.
02:53:59 <Peaker> anyone remember what monad transformer library it was that didn't need N^2 lifters? I keep forgetting :-)
02:58:21 <Saizan_> Peaker: mmtl, but it's effectiveness should be verified :)
02:58:54 <Peaker> Saizan_: thanks
02:59:18 <Peaker> "Men married to lesbians" pops up in Google :-P
02:59:43 <Saizan_> ?hackage mmtl
02:59:43 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/mmtl
03:01:26 <Peaker> tmap :: (Monad m, Monad n) => (forall a. m a -> n a) -> (forall b. n b -> m b) -> t m c -> t n c  -- are the rank-2 types there really necessary?
03:02:12 <Saizan_> yes, afaiu
03:02:37 <Peaker> What advantages does ErrorT with the Error context have over EitherT?  Can't the Error context only be used when its actually necessary for the operations? (e.g: catch)
03:02:53 <Peaker> return, bind   don't really need the Error context, do they?
03:03:00 <quicksilver> the Error context is just there for "fail :: String -> m () "
03:03:38 <Saizan_> and since fail is part of Monad you need it there
03:04:18 <quicksilver> you also need something for mzero
03:04:25 <quicksilver> (which is the "noMsg" part of Error)
03:05:25 <Peaker> "fail" sucks :-(
03:05:35 <quicksilver> mzero doesn't, though.
03:05:42 <quicksilver> so you still need something for noMsg.
03:06:00 <quicksilver> unless you want: mzero = Left (error "mzero")
03:06:04 <quicksilver> but that's not very nice.
03:06:16 <Saizan_> you could avoid the Error context on Monad though
03:06:53 <Peaker> quicksilver: so it can have an Error Context only for the instance of MonadZero
03:07:43 <Peaker> also, "fail" can be ignored in EitherT and it can have its own MonadEither interface (like MonadState/etc) that has its own proper fail
03:08:00 <quicksilver> yes, that makes sense.
03:08:17 <quicksilver> instance (DefaultErrorValue e) => MonadPlus (Either e)
03:08:34 <quicksilver> instance (StringErrorValue e) => MonadFail (Either e)
03:08:48 <quicksilver> then you would be able to pick and choose.
03:09:07 <Saizan_> Peaker: and then tell the desugaring of do-notation to use that fail?
03:10:14 <quicksilver> you could go crazy and have a special class for that
03:10:19 <quicksilver> MonadPatternFailure ;)
03:10:21 <Peaker> "do" shouldn't call "fail",  "fdo" or something maybe should
03:11:01 <quicksilver> I don't think the keyword matters.
03:11:06 <Peaker> Pattern-match failures should be explicit, IMO.  Its error-prone to map them to a Monad's fail when its not necessarily visible from the code that the pattern match is even refutable
03:11:31 <quicksilver> I wouldn't mind if the presence of refutable patter matchs gave the do block a different type.
03:11:44 <quicksilver> I disagree in the strongest possible terms.
03:11:52 * Saizan_ is with quicksilver
03:12:01 <quicksilver> the automatic calling of something special for pattern match failure is an awesome feature
03:12:06 <quicksilver> it's just the details which are ugly.
03:12:31 <Saizan_> it's what makes list comprehensions nice, for example
03:13:31 <quicksilver> :t let lefts ee = [ x | Left x <- ee ] in lefts
03:13:32 <lambdabot> forall t t1. [Either t t1] -> [t]
03:13:37 <Peaker> Inexhaustive pattern matches are error-prone if not explicitly marked as such.  I think there should be a way to mark the pattern match as exhaustive (and then it would be verified as such) or non-exhaustive (and then you are aware that it may call fail)
03:13:58 <quicksilver> On the contrary, I am not an idiot.
03:14:05 <quicksilver> I can tell when my pattern matches are inexhaustive.
03:14:10 <quicksilver> I don't think I've ever done that by mistake.
03:14:33 <quicksilver> there's nothing stopping you adding a comment if you wish to, though.
03:17:20 <Peaker> quicksilver: in a do block, I might want to do:   Just x <- next -- I know for SURE its supposed to be a Just, don't use "fail", use "error".  vs:   Just x <- next  -- I thought I covered all cases, please tell me if I didn't.    vs:   Just x <- next -- I intend for it to sometimes match and sometimes call fail.  I'd like a way to distinguish these 3 cases to ghc
03:19:06 <Peaker> quicksilver: If I add a case to my ADT, I'd like ghc to warn me about places that expect they match it in full, for example
03:19:51 <quicksilver> Peaker: in the first case, you do "x <- fromJust <$> next"
03:20:09 <quicksilver> Peaker: in the second case, you are an idiot. How can you possibly not know how many cases there are in Maybe ?
03:20:21 <quicksilver> Peaker: and the third case is the current, correct, behaviour.
03:20:34 <Philonous> quicksilver: The point is, you might not know which constructors a function may return
03:20:36 <quicksilver> and for your last comment, you have a warning flag for that.
03:20:53 <quicksilver> Philonous: no, that's not the point.
03:20:59 <Peaker> quicksilver: Maybe is easy -- it might be something else.  Also, I have thousands of lines of code, I may have made idioitic mistakes in some of them, why not catch them if its possible? :)
03:21:07 <quicksilver> Philonous: the point of Peaker's second case is about how many constructors Maybe has.
03:21:10 <quicksilver> and that's all it is. nothign more.
03:21:18 <quicksilver> the first and third cases are about how many the function returns.
03:21:29 <quicksilver> and you have fromJust for the first, and <- for the third.
03:21:48 <quicksilver> Peaker: I contend that, for every data type, you know if it has one constructor, or more than one.
03:21:54 <quicksilver> if not, you are in a mess.
03:21:56 <Peaker> quicksilver: first and third are covered, second would still be nice
03:22:01 <mmorrow> this is cool http://www.muppetlabs.com/~breadbox/software/tiny/bf.asm.txt
03:22:14 <Peaker> quicksilver: well, second one is not just in do blocks
03:22:22 <quicksilver> I'm only talking about do blocks.
03:22:31 <mmorrow> "For the compiler, the text segment is also the data segment. The memory image of the compiler is inside the code buffer, and is modified in place to become the memory image of the compiled program."
03:22:36 <quicksilver> we are talking about monddfail, and fail, and the special behaviour of pattern match failure thereing.
03:22:49 <quicksilver> it's a different conversation entirel out of do blocks.
03:23:16 <quicksilver> I agree it would be nice to have a compiler pragma to say "this case statement was suposed to be exhaustive"
03:23:32 <quicksilver> currently we can only turn than on or off at a file level (using the warning flag)
03:23:35 <Peaker> quicksilver: if someone adds a second constructor to a single one, then all cases that used it in a do are screwed..
03:23:52 <quicksilver> I'm sorry, that's an absurd hypothetical construction.
03:24:04 <quicksilver> Adding a second constructor to a single one is a massive semantic change.
03:24:15 <quicksilver> You have to expect to look through your code after that :)
03:24:18 <Peaker> quicksilver: its one of the main reasons Haskell has lifted bottoms even for type products, is what I heard :)
03:24:36 <Peaker> (Having a less surprising behavior when adding a second constructor)
03:24:36 <quicksilver> incidentally, I never use "Foo x <- bar" when Foo is the only constructor.
03:24:46 <Peaker> quicksilver: you use unFoo?
03:24:51 <quicksilver> I would always use x <- unFoo bar
03:25:07 <quicksilver> if I use the syntax Foo x <- bar that is because - and only because - I wish to use the special fail behaviour.
03:25:20 <quicksilver> that's what pattern bindings before "<-" are for, IMO.
03:29:27 <Mobsan> Good day
03:29:39 <Saizan_> tsk, it's simple, add a proof that bar returns a Foo, if you change the datatype the proof won't typecheck anymore :P
03:30:09 <Peaker> quicksilver: I guess if you have unFoo and add another data constructor, then you can have fromFoo instead of unFoo, and gives you an opportunity to fix all the unFoo's
03:30:12 <Saizan_> (unless it still holds, and everyone is happy)
03:30:20 <Saizan_> Mobsan: hi
03:30:26 <quicksilver> right.
03:30:37 <quicksilver> I defnitely think the pragma woul dbe nice, though
03:31:00 <quicksilver> as it stands, I don't use the inexhaustive wwarning because it annoys me too much how many valid inexhaustive patterns there are.
03:32:03 <Peaker> quicksilver: when you say pragma, you imply {-# #-} syntax which is annoying :)
03:41:27 <Saizan_> does ML functors (as in SML or O'Caml) have structural subtyping?
03:41:50 <Saizan_> *do
03:42:56 <quicksilver> well you define a module to implement an interface rather explicitly, don't you?
03:42:57 <Peaker> quicksilver: say, what's the status of Deus FRP?
03:43:02 <quicksilver> it's been so long since I've used ML
03:43:14 <Peaker> quicksilver: it doesn't seem to even be cabalized?
03:43:35 <quicksilver> but basically you say "this module X is an instance of signature S in which S.bar is X.foo, S.baz is X.bam, ..." ?
03:43:44 * quicksilver should proabbly be quiet and see if anyone actually knows.
03:43:55 <quicksilver> Peaker: the latest form is that which I emailed to the reactive list a while back.
03:44:06 <quicksilver> it's not cabalised because it's not working, documented, or tested.
03:44:39 <Saizan_> yeah, but if i have two signatures S and T, is there a notion of subtyping between those? so that if S < T then each module implementing S also implements T
03:44:46 <Peaker> quicksilver: Reactive is documented, but not working or tested :-(
03:45:00 <quicksilver> Reactive has some tests!
03:45:10 <quicksilver> it just doesn't ehave enough, and doesn't pass all the ones it has.
03:45:25 * Saizan_ should ask in O'Caml
03:45:52 <quicksilver> Saizan_: whilst that's logically true my understand was that is specified by the user, not inferred automatically.
03:46:17 <quicksilver> Saizan_: I.e. there is an obvious recipe for writing an implementation of T given an implementatio of S but you still have to do it.
03:46:36 <Saizan_> quicksilver: ah, i see
03:46:51 <quicksilver> ICBW, though.
03:47:00 <doserj> Saizan: there is inheritance in the sense that you can include signatures in other signatures
03:47:03 <quicksilver> I've only really used them for simple ADTs and not for years.
03:47:47 <Saizan_> doserj: like submodules?
03:49:25 <doserj> I'm not sure what you mean with submodules
03:50:20 <Saizan_> that i can have sig { type T; module key : SomeSignature; .. }
03:51:15 <Saizan_> where key is just a name (e.g. the usual example of a dictionary parametrized by the ordering of keys)
03:51:25 <doserj> you can have signature FOO = sig { include BAR ; type t ... }
03:51:40 <Saizan_> ah, i see
03:51:41 <doserj> Saizan_: that looks more like functors
03:52:23 <Saizan_> doserj: though you don't get automatically that every instance of FOO is also an instance of BAR?
03:52:51 <doserj> every structure that matches FOO also matches BAR
03:53:55 <Saizan_> ok, so it's more like nominal subtyping
03:54:00 <doserj> yes
03:56:15 <doserj> Saizan_: you don't have to actually use "include", though. just copying the definition has the same effect.
03:56:52 <Saizan_> ah, so it's not!
03:57:07 <hackagebot> storablevector 0.2.3.1 - Fast, packed, strict storable arrays with a list interface like ByteString (HenningThielemann)
03:57:25 <doserj> Saizan_: :)
03:59:58 <doserj> Saizan_: the basic principle is the following: each structure has a "principal signature" (which is the most specified signature). A structure matches a signature if its principle signature specialises it.
04:01:53 <Saizan_> doserj: then i should ask for a definition of "specialises" :) but at this point i think i can guess
04:02:12 <doserj> it is pretty much what one would guess, yes
04:03:10 <BONUS> hmm someone asked me if i plan to cover lifting (i.e. lift0, lift1) in lyah
04:03:14 <BONUS> wonder what they mean by that
04:03:26 <BONUS> like lifting in transformers?
04:04:21 <Saizan_> mmh, maybe liftA* liftM*?
04:04:27 <nlogax> autobots - transform and roll out!
04:04:42 <BONUS> maybe, although i already covered liftA2
04:04:56 <BONUS> prolly best if i just ask them
04:07:15 <etpace_>  @src nub
04:07:28 <Saizan_> @src nub
04:07:29 <lambdabot> nub = nubBy (==)
04:07:33 <Saizan_> @src nubBy
04:07:33 <lambdabot> nubBy eq []             =  []
04:07:33 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
04:07:52 <etpace_> Is it possible to do nub with higher order functions, instead of explicit recursion?
04:08:43 <BONUS> yeah you can with a foldr imo
04:08:52 <BONUS> i mean foldl
04:09:28 <Saizan_> not with foldl
04:09:40 <Saizan_> > nub [1..]
04:09:41 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
04:10:05 <BONUS> maiNub = foldr (\x acc -> if x `elem` acc then acc else x:acc) []
04:10:32 <BONUS> i don't know if this preserves the order though
04:10:42 <BONUS> like the recursive one
04:11:04 <Saizan_> mmh, i don't think that works
04:11:18 <Saizan_> ?type foldr (\x acc -> if x `elem` acc then acc else x:acc) []
04:11:19 <lambdabot> forall a. (Eq a) => [a] -> [a]
04:11:27 <Saizan_> > foldr (\x acc -> if x `elem` acc then acc else x:acc) [] [1..]
04:11:28 <lambdabot>   * Exception: stack overflow
04:11:45 <BONUS> ah yeah
04:11:55 <quicksilver> > map fst . filter (\(a,b) -> a /= b) . (zip`ap`tail) $ [1,2,2,2,3,3,4,4,4,5]
04:11:56 <lambdabot>   [1,2,3,4]
04:12:08 <quicksilver> getting the last element back is an exercise for the reader.
04:12:14 <BONUS> haha
04:12:23 <opqdonut> :D
04:12:27 <BONUS> but that doesn't work if its not ordered
04:12:35 <Saizan_> > foldr (\x rec seen -> if x `elem` seen then rec seen else x:rec (x:seen)) (const []) [] [1..]
04:12:36 <lambdabot>   []
04:12:37 <quicksilver> I know :)
04:12:38 <BONUS> like [1,2,2,2,3,3,3,3,2,2,2]
04:12:40 <quicksilver> I just thought it was cool.
04:12:42 <BONUS> :]
04:12:50 <BONUS> zip`ap`tail is the best, really
04:12:57 <quicksilver> @quote aztec
04:12:58 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
04:13:01 <etpace_> @src ap
04:13:01 <lambdabot> ap = liftM2 id
04:13:09 <etpace_> No idea what lifts are :P
04:13:23 <lilac> @type ap
04:13:25 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
04:13:31 <lilac> ^^ should be enough to make it clear what it does :)
04:13:56 <lilac> @type ap :: (a -> b -> c) -> (a -> b) -> (a -> c)
04:13:57 <lambdabot> forall a b c. (a -> b -> c) -> (a -> b) -> a -> c
04:13:58 <doserj> ap = liftM2 ($) might be the clearer definition
04:14:03 <Saizan_> > foldr (\x rec seen -> if x `elem` seen then rec seen else x : rec (x:seen)) (const []) [1..] []
04:14:04 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
04:14:10 <etpace_> is it like map for monads or something?
04:14:14 <Saizan_> > foldr (\x rec seen -> if x `elem` seen then rec seen else x : rec (x:seen)) (const []) [1,2,2,2,3,3,4,4,4,5] []
04:14:15 <lambdabot>   [1,2,3,4,5]
04:14:30 <lilac> etpace_: it's generalized application for monads (applying a function in a monad to a value in a monad)
04:15:02 <BONUS> never saw a ternary function as the folding function
04:15:03 <BONUS> O_O
04:15:24 <Saizan_> etpace_: map for monads is liftM or fmap
04:15:42 <Saizan_> ?type foldr
04:15:43 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
04:15:49 <Saizan_> 'b' can be a function type :P
04:16:00 <BONUS> yeah it just never occured to me to use it that way
04:16:07 <BONUS> although this is probably isomorphic to doing
04:16:12 <BONUS> \x (rec, seen)
04:16:26 <BONUS> and then ((,) []) as the starting value
04:18:11 <etpace_> Are there any places where youd rather use foldl/r over foldl'/r'? as the latter seem to have the same functionality but dont ever stack overflow
04:18:53 <lilac> > uncurry (:) . (head &&& (snd <$>) . filter (uncurry (/=)) . (zip <*> tail)) $ [1,2,2,2,3,3,4,4,4,5]
04:18:54 <Saizan_> BONUS: uhm, i don't think so, since the two values flow in opposite directions
04:18:54 <lambdabot>   [1,2,3,4,5]
04:19:05 <opqdonut> etpace_: there is no foldr'
04:19:16 <opqdonut> etpace_: and when you want laziness, foldr is the way to go
04:19:22 <Saizan_> foldr' would only stack overflow
04:19:25 <opqdonut> but yeah, usually there is no case for foldl
04:19:37 <WorkyBob> is there a way to guarentee that two Haskell threads run on the same OS thread?
04:19:40 <opqdonut> ?src concat
04:19:41 <lambdabot> concat = foldr (++) []
04:19:50 <etpace_> @src foldr
04:19:50 <lambdabot> foldr f z []     = z
04:19:51 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
04:20:05 <totom> what does it mean if my program writes : Main: <<loop>> ?
04:20:06 <etpace_> @src foldl
04:20:06 <lambdabot> foldl f z []     = z
04:20:06 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
04:20:29 <mmorrow> :o http://www.stripedgazelle.org/cgi-bin/wiki_joey/asm86.scm
04:20:47 <lilac> totom: it means that your program has an infinite loop so obvious that even GHC can detect it ;-)
04:21:03 <totom> strange :p
04:21:08 <quicksilver> WorkyBob: isn't that what forkOS does?
04:21:18 <WorkyBob> quicksilver: no, the reverse
04:21:25 <WorkyBob> I want to guarentee that they're *not* on seperate OS threads
04:21:28 <opqdonut> quicksilver: that guarantees they run on different threads
04:21:28 <totom> it only detects it with -O, so it must not be so obvious ;-)
04:21:38 <etpace_> Do infinite lists work with foldr because you apply f x first, so if f does not need its second argument, it short-circuits, unlike foldl where f gets passed it's value "from above"?
04:21:40 <opqdonut> WorkyBob: well, run it with +RTS -n1
04:21:49 <opqdonut> and besides, why would you want to do that
04:21:52 <WorkyBob> opqdonut: I have other things that I do want to run on a seperate thread
04:21:57 <BONUS> hmm
04:22:01 <opqdonut> etpace_: yeah, basically
04:22:32 <opqdonut> WorkyBob: why do you want to keep ghc from scheduling your threads in the most efficient manner
04:22:58 <lilac> opqdonut: perhaps WorkyBob is calling thread-unsafe C code via FFI?
04:23:01 <quicksilver> opqdonut, WorkyBob : well, that's not really true.
04:23:06 <quicksilver> forkOS doesn't guaranteed difference.
04:23:11 <quicksilver> it guarantees binding.
04:23:31 <lilac> if you use forkIO within forkOS, do you still have the binding guarantee?
04:23:42 <lilac> i'm guessing not
04:23:48 <quicksilver> that's what I was wondering lilac.
04:24:19 <mmorrow> WorkyBob: are you doing opengl stuff?
04:24:21 <WorkyBob> opqdonut: yes
04:24:24 <WorkyBob> mmorrow: yes
04:24:26 <mmorrow> heh
04:24:27 <lilac> it seems slightly non-composable to enforce the binding guarantee on everything you use within a forkOS
04:24:33 <mmorrow> WorkyBob: forkOS
04:24:35 <WorkyBob> lilac: yes
04:24:38 <WorkyBob> mmorrow: hmm?
04:24:51 <WorkyBob> mmorrow: that guarentees that it *is* on a different thread, no?
04:24:53 <mmorrow> oh, *not*
04:24:55 <quicksilver> No.
04:25:02 <quicksilver> it doesn't no guarantee difference.
04:25:07 <quicksilver> it just guarantees that the new thread is bound.
04:25:11 <WorkyBob> oh, okay
04:25:16 <WorkyBob> but yeh, not what I want
04:25:18 <quicksilver> it could easily get bound to the same OS thread you were currentl using.
04:25:24 <quicksilver> but it doesn't solve the problem on its own :(
04:25:37 <WorkyBob> I have two threads, both of which talk to GLUT (one though is just posting redisplay messages)
04:25:40 <mmorrow> WorkyBob: you possibly do +RTS -N<# of cores> -RTS, and use forkOnIO maybe
04:25:42 <WorkyBob> they both need to run on the same OS thread
04:25:47 <mmorrow> *you could possibly do..
04:25:58 <WorkyBob> or GLUT will crash and burn
04:26:02 <quicksilver> the simple solution is to use a Chan to send stuff to your single, bound, openGL thread.
04:26:22 <WorkyBob> quicksilver: but then I somehow have to get GLUT to both wait for events and read that chan at the same time
04:26:24 <quicksilver> I fear only JaffaCake knows if there is a way to schedule two haskell threads both bound to a single OS thread.
04:26:43 <JaffaCake> nope
04:26:49 <mmorrow> WorkyBob: yeah, it seems you'd just want to have one forkOS'ed thread talking to opengl per-window, then just have a Chan to it
04:26:49 <WorkyBob> unless you know of a way to get glut to block on more than one thing at the same time?
04:26:51 <quicksilver> WorkyBob: that problem wouldn't go away.
04:27:01 <quicksilver> WorkyBob: even if you had two haskell threads bound to the same OS thread
04:27:06 <quicksilver> you'd just find the second never got scheduled
04:27:13 <quicksilver> (because the first was blocked in waiting for events)
04:27:19 <WorkyBob> quicksilver: yes it would -- because one of the events that GLUT is waiting for is a redisplay being posted
04:27:26 <quicksilver> no, it wouldn't.
04:27:26 <kynky> concurrency, would using session types be helpful ?
04:27:32 <quicksilver> the second haskell thread will never get scheduled
04:27:36 <quicksilver> while the first is waiting
04:27:41 <WorkyBob> really?
04:27:41 <WorkyBob> o.O
04:27:43 <quicksilver> because the first, whilst waiting, is blocking that OS thread.
04:27:45 <mmorrow> WorkyBob: just don't enter the mainLoop, and poll manually
04:27:46 <quicksilver> by definition.
04:27:50 <WorkyBob> oh, so it is quicksilver
04:27:51 <WorkyBob> yep
04:27:52 <quicksilver> at OS level, blocking calls block a thread.
04:27:54 <quicksilver> :)
04:27:59 <WorkyBob> mmorrow: glut allows you to poll manually?
04:28:06 <quicksilver> yes, the non-blocking getevent thing is the answer
04:28:12 <WorkyBob> oh cool
04:28:14 * WorkyBob goes looking
04:28:17 <mmorrow> WorkyBob: that worked out well for me in http://moonpatio.com/repos/vacuum-gl/System/Vacuum/OpenGL/HsGLIV.hs
04:28:38 <mmorrow> WorkyBob: (iirc you need free-glut for `mainLoopEvent')
04:28:44 <WorkyBob> mmorrow: cheers muchly
04:28:47 <WorkyBob> oh fail
04:28:48 <quicksilver> I fear so.
04:28:48 <mmorrow> WorkyBob: np :)
04:28:49 <WorkyBob> no go then
04:28:55 <mmorrow> oh noes!
04:28:56 <WorkyBob> freeglut is not doable on OS X
04:28:56 <quicksilver> I think stock GLUT has no solution to the problem you describe.
04:29:01 <mmorrow> :(
04:29:12 <WorkyBob> (no idea why not)
04:29:20 * mmorrow deletes "why not?"
04:29:39 <WorkyBob> well, it's hard enough to compile that I gave up
04:29:46 <WorkyBob> and it's not in fink or macports
04:29:56 <WorkyBob> so... :(
04:30:36 <quicksilver> well, I say no solution.
04:30:40 <quicksilver> that's not entirely true
04:30:41 <lilac> i guess one solution to the original problem would be to forkOS until you got two threads bound to the same OS thread :) good ol' pigeon-hole principle
04:30:49 <koeien> there is forkOS isn't there?
04:30:53 <quicksilver> register an idle callback to be called back.
04:30:57 <quicksilver> koeien: please read back. We've done this.
04:31:01 <koeien> ok n/m
04:31:02 <WorkyBob> quicksilver: ohhhhhh
04:31:03 <WorkyBob> duh
04:31:05 <WorkyBob> cheers
04:31:13 <quicksilver> the idle callback can read the chan every second, or so.
04:31:44 <WorkyBob> needs to be a bit more frequent than that, but it may be enough
04:32:05 <WorkyBob> I'm looking for near instant refresh when status changes
04:33:02 <quicksilver> well, I frequentlly have the idle callback every 15 milliseconds
04:33:06 <quicksilver> to get 60fps.
04:33:11 <paulvisschers> cabal: dependencies conflict: ghc-6.10.1 requires process ==1.0.1.0 however
04:33:11 <paulvisschers> process-1.0.1.0 was excluded because ghc-6.10.1 requires process ==1.0.1.1
04:33:13 <paulvisschers> :(
04:33:35 <Saizan_> paulvisschers: can you paste ghc-pkg list?
04:33:45 <dcoutts_> paulvisschers: http://haskell.org/cabal/FAQ.html#dependencies-conflict
04:33:54 <Saizan_> ah, we've a faq :)
04:34:45 <quicksilver> WorkyBob: I don't know why I didn't suggest this before. All my opengl programs have either idle callbacks or timer callbacks.
04:34:53 * WorkyBob nods
04:34:58 <WorkyBob> also, win, looks to be working
04:35:05 <WorkyBob> just with idleCallback $= Just (return ())
04:35:12 <WorkyBob> to keep the event loop ticking
04:35:28 <quicksilver> hmm
04:35:34 <quicksilver> that's odd.
04:35:47 <WorkyBob> nope, the other thread sends a glutPostRedisplay
04:35:48 <quicksilver> that shouldn't make any difference with -threaded
04:35:49 <paulvisschers> thanks Saizan_ and dcoutts_
04:35:51 <quicksilver> ah, ok.
04:35:55 <quicksilver> you're cheating and hoping it works :)
04:35:59 <quicksilver> (which apparently it does)
04:35:59 <WorkyBob> all it needs to do is get out of blocking on an event
04:36:08 <WorkyBob> >.>
04:36:12 <quicksilver> calling postredisplay from another thread, I mean.
04:36:24 * WorkyBob nods
04:36:31 * WorkyBob shall fix it in a bit
04:36:40 <quicksilver> maybe sven is clever and postredisplay always runs in the main thread
04:36:41 <WorkyBob> atm the display function pumps the chan, so it needs a bit of refactoring
04:36:44 <quicksilver> but I didn't think so.
04:37:01 <quicksilver> well I mean, obviousl I think he's clever :)
04:37:07 <quicksilver> but I didn't think he had done that.
04:37:08 <WorkyBob> hehe
04:37:34 <mjrosenb> hey, did anyone else start having issues with ^P not working in ghci recently?
04:37:52 * mjrosenb guesses this has been an issue since he upgraded to 6.10.3
04:38:00 <opqdonut> ^P ?
04:38:16 <opqdonut> ah, prev command?
04:38:21 <quicksilver> each version of ghc 6.10.x breaks the terminal/readline/haskeline subsystem in a new, different way
04:38:27 <quicksilver> it's designed to keep you on your toes.
04:38:29 <opqdonut> how exciting!
04:38:50 <WorkyBob> lol
04:39:30 * mjrosenb still wants bash's ^O to work
04:39:56 <opqdonut> mjrosenb: execute-and-infer-next-history?
04:40:12 <Peaker> @type (() <$)
04:40:14 <lambdabot> forall (f :: * -> *) b. (Functor f) => f b -> f ()
04:40:24 <mjrosenb> opqdonut: yeah, that sounds about right
04:40:41 <RayNbow> :t (<$)
04:40:42 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
04:40:59 <opqdonut> mjrosenb: ok
04:41:24 <RayNbow> :t fmap . const
04:41:26 <lambdabot> forall a (f :: * -> *) a1. (Functor f) => a1 -> f a -> f a1
04:41:26 <Peaker> @index (<$)
04:41:27 <lambdabot> bzzt
04:41:46 <RayNbow> @hoogle (<$)
04:41:47 <lambdabot> Control.Applicative (<$) :: Functor f => a -> f b -> f a
04:41:47 <lambdabot> Text.Parsec.Perm (<$$>) :: Stream s Identity tok => (a -> b) -> Parsec s st a -> StreamPermParser s st b
04:41:47 <lambdabot> Text.ParserCombinators.Parsec.Perm (<$$>) :: Stream s Identity tok => (a -> b) -> Parsec s st a -> StreamPermParser s st b
04:42:02 <Peaker> it should probably be in Control.Functor, not Applicative
04:45:10 <Peaker> @hoogle sequenceA
04:45:11 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
04:45:11 <lambdabot> Data.Foldable sequenceA_ :: (Foldable t, Applicative f) => t (f a) -> f ()
04:49:55 <RayNbow> @djinn Functor f => a -> f b -> f a
04:49:56 <lambdabot> -- f cannot be realized.
04:50:21 <mauke> :t fmap . const
04:50:22 <lambdabot> forall a (f :: * -> *) a1. (Functor f) => a1 -> f a -> f a1
04:50:39 <mauke> :t fmap fmap return
04:50:39 <RayNbow> hmm, djinn probably doesn't know about const...
04:50:40 <lambdabot> forall a b (f :: * -> *). (Functor f) => b -> f a -> f b
04:51:06 <mjrosenb> RayNbow: you can make it
04:51:10 <mjrosenb> RayNbow: at least you can locally
04:51:18 <Peaker> @type ((>>), liftA2 (flip const))
04:51:20 <lambdabot> forall (m :: * -> *) a b b1 a1 (f :: * -> *). (Monad m, Applicative f) => (m a -> m b -> m b, f a1 -> f b1 -> f b1)
04:52:22 <Peaker> @type (<*>)
04:52:23 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
04:52:42 <paulvisschers> What do I have to add to ~/.cabal/config to have packages install as global by default?
04:53:19 <RayNbow> @djinn Functor f => (a -> b -> a) -> a -> f b -> f a
04:53:19 <lambdabot> -- f cannot be realized.
04:54:34 <dcoutts_> paulvisschers: do you see the existing commented-out line user-install: True ?
04:54:46 <paulvisschers> no
04:54:56 <mauke> :t (.) fmap
04:54:57 <lambdabot> forall a b (f :: * -> *) a1. (Functor f) => (a1 -> a -> b) -> a1 -> f a -> f b
04:55:02 <paulvisschers> But I'm guessing I have to add that and set it to false?
04:55:14 <dcoutts_> paulvisschers: ah you've got an older config file
04:55:35 <mjrosenb> wait, since when does djinn know about type classes?
04:55:35 <paulvisschers> dcoutts_: Yeah it's 18 months old or so
04:55:36 <dcoutts_> paulvisschers: you might like to update, just move the current one out of the way, let it be re-created and then merge in your changes
04:56:17 <paulvisschers> dcoutts_: So just rename it, and then do an cabal update?
04:56:23 <dcoutts_> paulvisschers: that'd do
04:56:40 <dcoutts_> paulvisschers: there's also an option to use sudo for the install stage, so you don't have to run the whole thing with sudo
04:58:17 <paulvisschers> dcoutts_: What is that called?
04:59:47 <doserj> --root-cmd=...
04:59:51 <dcoutts_> yep
05:00:09 <dcoutts_> so the equivalent in the config file is root-cmd:
05:02:04 <paulvisschers> so I should make that into root-cmd: sudo?
05:04:01 <Zao> root-cmd: sudo rm -f /boot/vmlinuz && sudo shutdown -r now
05:04:28 <paulvisschers> ah thanks Zao
05:06:26 <Zao> (advice involving rm is usually unhealthy to try)
05:06:30 <Saizan_> paulvisschers: err, Zao was joking (i guess), just sudo (just to be clear)
05:06:57 <paulvisschers> Yeah I got that :)
05:07:50 <mauke> (good thing /boot isn't mounted by default here)
05:33:25 <harlekin_> #
05:46:28 <Peaker> @hoogle sprintf
05:46:29 <lambdabot> No results found
05:46:36 <Peaker> @hoogle printf
05:46:37 <lambdabot> Text.Printf printf :: PrintfType r => String -> r
05:46:37 <lambdabot> module Text.Printf
05:46:37 <lambdabot> package printf-mauke
05:46:48 <Peaker> so printf has a String instance and an IO String instance?
05:46:52 <Peaker> oops, IO () instance
05:47:43 <mauke> you pung?
05:47:50 <mauke> IO a, actually
05:47:56 <mauke> (it returns undefined)
05:48:07 <Peaker> why?
05:50:00 <Saizan_> Peaker: to be haskell98
05:50:18 <Peaker> is printf in Haskell98?
05:50:27 <mauke> no, but the code is H98
05:50:45 <Peaker> oh, it'd need FlexibleInstances
05:52:09 <mauke> my printf has a (Default a) constraint
05:53:06 <Saizan_> mauke: so you can't use it with >> directly?
05:54:01 <mauke> why not?
05:54:03 <Peaker> @hoogle Default
05:54:03 <lambdabot> keyword default
05:54:04 <lambdabot> Distribution.Simple.Setup defaultBuildFlags :: BuildFlags
05:54:04 <lambdabot> Data.ByteString.Lazy.Internal defaultChunkSize :: Int
05:54:16 <mauke> >> should work with any a
05:55:46 <Saizan_> yeah, but you need to add a type signature to printf "foo" >> bar, even if bar is IO Something
05:55:59 <Saizan_> or not?
05:56:55 <Peaker> @index toLower
05:56:55 <lambdabot> Data.Char
05:59:01 <quicksilver> Saizan_: yes, you would. it would not be able to resolve the (Default a) constraint
05:59:08 <quicksilver> and defaulting doesn't apply to non-numeric TCs.
05:59:19 <quicksilver> non-prelude TCs.
05:59:20 <quicksilver> something.
06:00:19 <Saizan_> :)
06:02:34 <quicksilver> http://www.serpentine.com/blog/2009/06/30/python-and-haskell-text-apis-compare/
06:03:27 <quicksilver> I'm interested to read (I've only read the intro) that bos says or the Data.List-based API ... If you?ve used the list API to do much text processing, you?ve probably spilled more than a few tears into your whiskey
06:03:54 <quicksilver> On the contrary I find the Data.List API more regular, more powerful, more composable, than text apis in any other language I've used.
06:04:01 <quicksilver> maybe it's a question of taste.
06:05:18 <quicksilver> hmm, seems he's talking about things like rfind and istitle.
06:06:42 <balor> Where might I find docs on haskell98, specifically Set?
06:08:19 <Saizan_> balor: http://haskell.org/ghc/docs/latest/html/libraries/containers/Data-Set.html
06:08:34 <balor> Saizan_: thanks
06:11:30 <Saizan_> quicksilver: split and findSubString are the two big missing ones
06:12:26 <quicksilver> Saizan_: isPrefixOf + tails gives you the latter
06:12:40 <EvilTerran> balor, incidentally, Set doesn't seem to be h98, according to http://haskell.org/onlinereport/
06:12:44 <quicksilver> and whilst that is admittedly more cumbersome.
06:12:49 <quicksilver> it is also more composable.
06:12:51 <EvilTerran> but it's a very widely accepted library
06:13:08 <quicksilver> once you see the code using inPrefixOf + tails you can immediately see how to generalise it in all sorts of interesting ways.
06:13:15 <balor> EvilTerran: I'm a n00b dealing with an old codebase.
06:13:16 <quicksilver> which you can't with findSubstring.
06:13:38 <quicksilver> Saizan_: I'll grant you the former, though. split is missing.
06:13:41 <balor> EvilTerran: And if I build against haskell98 I seem to get Set. If I don't it complains
06:13:47 <quicksilver> Saizan_: so is my most excellent "transmogrify" function.
06:13:49 <Saizan_> quicksilver: sometimes you need more efficiency though, maybe not much if you're using [Char]
06:14:17 <Saizan_> quicksilver: transmogrify?:)
06:14:43 <quicksilver> Saizan_: I didn't think I was talking about efficiency. I thought I was talking about API. :)
06:15:05 <quicksilver> inPrefixOf + tails is not inherently inefficient though, given a reasonable compiler.
06:15:39 <Saizan_> it's asymptotically slower than something like KMP, no?
06:15:46 <quicksilver> Saizan_: http://haskell.org/pipermail/haskell-cafe/2007-July/028032.html
06:15:55 <quicksilver> yes, it's asymptotically slower than KMP.
06:16:01 <quicksilver> but we're comparing to python, FFS.
06:16:20 <EvilTerran> balor, ah, you mean the module being called Set instead of Data.Set; i see
06:16:25 <Saizan_> true :)
06:16:29 <quicksilver> python is asymptotically slower than writing your problem description out long hand, flying to california, and arranging a private audience with Knuth to get a solution.
06:16:36 <desp> Does anyone have copies of bin4.obf and bin5.obf from the ICFP contest?
06:16:49 <balor> EvilTerran: I'm afraid I don't know which I'm looking for.
06:17:14 <byorgey> desp: I do. What's your email address?
06:17:44 <desp> byorgey: (privmsg)
06:17:46 <desp> Thanks.
06:18:04 <Saizan_> (the list functions are probably implemented in C though)
06:18:47 <EvilTerran> balor, they're the same, just "Set" is a valid haskell98 module name, and "Data.Set" is using the heirarchical modules extension (which everyone uses, and makes it possible to organise modules far better)
06:19:21 <balor> EvilTerran: Ah. I shall refactor the code over time. For now I just need a cross product operator on sets.
06:22:04 <quicksilver> Saizan_: Seriously though, I can't remember the last time I saw a problem where the conditions which make KMP genuinely better applied.
06:22:23 <quicksilver> Saizan_: it's the case where a string actually contains many partial matches.
06:22:32 <quicksilver> that's pretty unusual outside of DNA basepair strings.
06:25:24 <Gilly> I'm trying to find the longest increasing subsequence using the algorithm in http://en.wikipedia.org/wiki/Longest_increasing_subsequence but have trouble translating that to 'nice' functional algorithm (I want the O(n log n) complexity). Any ideas?
06:26:36 <Peaker> subsequence is an ordered subset or sequential ordered subset?
06:26:56 <Peaker> ah, not necessarily contiguous
06:26:59 * quicksilver imagines Peaker wanted to use the word 'continguous'
06:27:13 <Gilly> yea, not needed to be contiguous
06:27:15 <Saizan_> quicksilver: transmogrify is very cool, i'd want that built-in in a haskell shell :)
06:27:15 <Peaker> these things need names :-)
06:27:22 <Peaker> usually "subsequence" means contiguous subsequence?
06:27:28 <Gilly> no
06:27:29 <mauke> no
06:27:33 <quicksilver> not to mathematicians, no
06:27:36 <mauke> that is substring
06:27:41 <Gilly> yup
06:27:46 <quicksilver> I think it might to some computer scientists
06:27:47 <Peaker> ah,didn't know that
06:29:00 <opqdonut> Gilly: that looks like a fold with maps P and M as state
06:29:16 <quicksilver> Gilly: I think the best you'll do is O(n log^2 n)
06:29:30 <quicksilver> it relies on O(1) lookups to get that number.
06:29:39 <opqdonut> but you might need a custom map implementation to make the binary search possible
06:29:42 <opqdonut> quicksilver: where?
06:29:53 <opqdonut> ah, X[M[j]]
06:30:09 <opqdonut> but the data itself can be kept in an array
06:30:13 <opqdonut> since it's not mutated
06:30:15 <quicksilver> opqdonut: "Thus, the sequence has the form ..., X[P[P[M[L]]]], X[P[M[L]]], X[M[L]]"
06:30:26 <Gilly> quicksilver: even Data.Array won't give me O(n log n) ?
06:30:33 <quicksilver> in fact, that would be O(n log^3 n)
06:30:35 <opqdonut> ah, lookup in P
06:30:35 <opqdonut> right
06:31:28 <Gilly> I thought about constructing the array lazily somehow, to be able to reach that complexity... but really not sure if that can be done.
06:31:40 <quicksilver> Gilly: you could just use arrays, yes. I wouldn't think of that as a "nice" functional algorithm
06:31:43 <quicksilver> which is what you asked for :)
06:32:01 <Gilly> running in ST is out of question for 'nice' functional algorithm for me :)
06:32:16 <quicksilver> it's not entirely clear to me that haskell arrays have amortized O(1)
06:32:30 <quicksilver> I have a nasty feeling the GC costs make it amortized O(log n)
06:32:37 <quicksilver> for the boxed ones, at least.
06:32:56 <quicksilver> UArray Int is O(1).
06:33:01 <Gilly> well, we could use unboxed here.
06:33:12 <quicksilver> also, I could be wrong about that.
06:33:13 <quicksilver> :)
06:33:14 <Gilly> (my sequences are Int's not general Ord)
06:33:34 <Gilly> ((and general ord can be converted to Int's, i guess))
06:34:34 <Saizan_> quicksilver: why that? i thought the GC overhead was only for mutable arrays
06:35:14 <quicksilver> weren't we talking about mutable ones?
06:35:49 <Saizan_> ah, maybe
06:42:04 <balor> if [(a.b) | a <- foo, b <- bar] creates a list of tuples does {(a.b) | a <- foo, b <- bar} create a set of the same?
06:42:31 <mauke> no, it's a syntax error
06:43:03 <opqdonut> :t fromList
06:43:03 <balor> mauke: Is there some syntax for set?
06:43:06 <lambdabot> Not in scope: `fromList'
06:43:11 <opqdonut> :t Data.Set.fromList
06:43:12 <lambdabot> forall a. (Ord a) => [a] -> S.Set a
06:43:16 <opqdonut> balor: ^ use that
06:43:22 <mauke> balor: no
06:43:34 <opqdonut> it's linear time iirc
06:44:03 <opqdonut> no, fromAscList
06:44:06 <opqdonut> was linear time
06:44:11 <opqdonut> and requires the list to be ascending
07:21:26 <Peaker> could there be an IOT (transformer), in theory?
07:24:29 <etpace_> @src |||
07:24:30 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
07:28:25 <lilac> etpace_: (|||) is a typeclass method (on ArrowChoice iirc)
07:28:49 <lilac> @src (->) (|||)
07:28:50 <lambdabot> Source not found. There are some things that I just don't know.
07:29:28 <lilac> (f ||| _) (Left a) = f a; (_ ||| f) (Right a) = f a
07:29:32 <lilac> (for ->)
07:29:54 <mauke> context: xmonad
07:36:00 <quicksilver> Peaker: not unless you have a time machine.
07:36:40 <Peaker> :-)
07:38:57 <quicksilver> Peaker: E.g. IOT Maybe a, would be Maybe (IO a)
07:39:16 <quicksilver> Peaker: the desired semantics would be that, if it ever turned out to be Nothing, all the IO actions would get rolledback / undone.
07:40:01 <Axman6> actually, i watched a video today with a guy at MR research who had written just such an OS
07:40:11 <Axman6> he was explaining the State monad
07:40:41 <lilac> Peaker: consider this: runIOT $ do xs <- liftIO readLn; lift (xs :: [Int])
07:41:01 <lilac> Peaker: that would presumably be :: [IO Int]
07:41:09 <Peaker> lilac: no need to liftIO if IOT is at the bottom
07:41:19 <lilac> so you could find the length of the list without doing any IO
07:41:41 <quicksilver> Axman6: yes, you can certainly imagine things which do permit it.
07:41:41 <lilac> Peaker: only if you intend to change readLn's type
07:41:59 <Peaker> lilac: of course IO would have become IOT Identity, and everything would work with IOT directly :)
07:42:37 <lilac> Peaker: liftIO is a red herring. the fact that it allows pure expressions to perform IO is more of a problem :)
07:44:16 <Peaker> Yeah, just like you get a Nothing in the Maybe (IO a) case, where you needed to do IO to reach that Nothing
07:58:24 <tromp> > 75/(1.86^2)
07:58:30 <lambdabot>   21.678806798473808
07:58:58 <qwr> hmm. considering that multiple haskell api seem to provide same set of List processing functions... why couldn't there be a List type-class
07:59:59 <qwr> so i wouldn't have to tell which unlines or length i'm wanting today?
08:02:38 <lilac> qwr: there's already Traversible and Foldable
08:05:47 <qwr> lilac: Foldable seems to be almost that, although it could have few more members
08:05:58 <Axman6> qwr: what other list like types are you referring to?
08:06:11 <qwr> Axman6: ByteString for example :P
08:06:23 <qwr> Axman6: Map also
08:06:33 <Axman6> bytestring is quite a different beast really
08:07:08 <Axman6> considering it's imploemented using unboxed arrays, possibly with some unsafePerformIO thrown in there, if i remember rightly
08:07:27 <qwr> map seems to be Foldable
08:08:57 <Axman6> then it probably has an instance of it
08:17:05 <lilac> The wiki says: "if a Foldable is also a Functor, toList and fmap need not perfectly commute". Is that really true?
08:17:43 <lilac> I would think the Foldable is not able to inspect the elements (due to polymorphism) whereas the Functor is not able to inspect the structure, so they /must/ commute?
08:19:01 <lilac> that is, "fmap f" must exactly preserve the structure, so toList must produce the elements in the same order
08:25:47 <doserj> lilac: a (balanced) search tree, for example, would have a fmap that changes the structure.
08:27:33 <lilac> doserj: that's not a Functor
08:27:42 <mmorrow> doserj: you couldn't have fmap in that case (if search uses compare) though
08:27:43 <lilac> since it requires an Ord constraint on the contents
08:28:05 <lilac> doserj: a Functor's fmap cannot do anything with the elements (other than seq)
08:28:11 <mmorrow> if you have a separate key and value type, like Data.Map though you can fmap over the vals
08:28:17 <lilac> even seq is ruled out by "fmap id == id" i think
08:28:35 <lilac> mmorrow: sure, but that can't change the order in which the elements are produced by toList
08:29:11 <mmorrow> sure, it maps over the values, not the keys
08:30:01 <mmorrow> also, you can simply build a new map if you want to map the keys
08:31:09 <mmorrow> @type \f g -> M.foldWithKey (\k v -> M.insert (f k) (g v)) mempty
08:31:11 <lambdabot> forall k a k1 a1. (Ord k1) => (k -> k1) -> (a -> a1) -> M.Map k a -> M.Map k1 a1
08:31:53 <mmorrow> @type \f g -> M.foldWithKey (\k v -> M.insert (f k v) (g k v)) mempty
08:31:55 <lambdabot> forall k a k1 a1. (Ord k1) => (k -> a -> k1) -> (k -> a -> a1) -> M.Map k a -> M.Map k1 a1
08:33:51 <etpace_> Why are things like insertion and member checking faster for sets than lists?
08:34:12 <mmorrow> lists are O(n), and sets are O(lg n)
08:34:25 <mmorrow> since sets are balanced binary trees
08:34:49 <mmorrow> so they're at most (logBase 2 n) elements deep
08:34:50 <BONUS> well, implemented as :)
08:34:59 <etpace_> and lists are, linked lists?
08:35:16 <mmorrow> if comparison is used, (lg n) is the upper bound for efficiency
08:35:28 <mmorrow> so they might as well be binary trees :)
08:35:28 <Axman6> @src []
08:35:29 <lambdabot> data [] a = [] | a : [a]
08:35:58 <mmorrow> etpace_: yes, singly-linked
08:36:59 <kpreid> frivolous numeric coincidence:
08:37:01 <kpreid> > let f x = realPart (((-x) :+ x)^3) in f 1.2
08:37:02 <lambdabot>   3.456
08:37:16 <etpace_> ok, thanks
08:37:16 <kynky> use the right data structure for the right job :)
08:37:28 <etpace_> When would you want lists over sets?
08:37:32 <etpace_> when you want more than one element?
08:37:38 <etpace_> same element*
08:38:01 <opqdonut> etpace_: accessing lists at their head is constant-time
08:38:16 <opqdonut> for that kind of "stream-like" usage they're better than sets
08:38:18 <|Jedai|> etpace_: list are more lightweight
08:38:34 <soupdragon> hello world
08:38:35 <quicksilver> mmorrow: "if comparison is used, (lg n) is the upper bound for efficiency, so they might as well be binary trees :)" <- well, that depends what problem you were trying to solve. The original question was about lists and sets; fingertrees solve some of the problems you might solve with lists, and have better complexity that sets for certain operations.
08:38:42 <|Jedai|> etpace_: I don't think your question really make sense in fact...
08:38:50 <mmorrow> quicksilver: for search though
08:39:00 <quicksilver> etpace_: lists when what you have is a sequence, in order, and you intend to process the elements in order.
08:39:19 <mmorrow> err, s/search/"insertion and member checking"/
08:39:33 <quicksilver> mmorrow: Yes. I know. But we weren't (only) talking about that. etpace_ mentioned insertion. If you interpret that to be cons/snoc, fingertrees are faster.
08:39:39 <|Jedai|> etpace_: the question "why would you use a list to represent a set" makes sense, "why would you ever want a list rather than a binary tree represented set" doesn't...
08:39:51 <Philonous> Why does the haskell site host the solutions to project euler? Doesn't that defeat the idea of the project?
08:40:05 <mmorrow> quicksilver: true
08:40:34 <Axman6> Philonous: they can be learnt from. i've sometimes gone to have a look at how others have done it after i've done some
08:41:01 <|Jedai|> Philonous: A bit, there was some debate about that, but most thought that Haskell users should be mature enough to search by themselves before looking at the (quite good) solutions on these pages
08:41:13 <kynky> sorting/insertion/traversal/deletion/memory usage , lots of factors, lots of tradeoffs, maps/sets/arrays/lists, also the specialized versons, etc etc
08:41:29 <mmorrow> i've recently been using Data.Sequence for some misc graph things that need a queue.. it's great. way underused i think (by me, and it seams like everyone too)
08:41:42 <mmorrow> they're really nice
08:42:43 <|Jedai|> mmorrow: well the constant factors aren't really nice, so when you don't need cons and uncons simultaneously, you tend to try others data structures
08:43:07 <quicksilver> |Jedai|: the constant factors for Data.Sequence aren't that bad, AFAIK.
08:43:15 <|Jedai|> mmorrow: but I agree that Data.Sequence is really impressive when you need its strength
08:43:17 <mmorrow> well sure, i mean when you are needing a queue and fast append
08:43:19 <quicksilver> but lists have fusion rules
08:43:33 <mmorrow> , viewl
08:43:35 <lunabot>  luna: Not in scope: `viewl'
08:43:45 <quicksilver> adn the list fusion rules bring the constant factors of lists right down in certain cases - mostly long pipelines.
08:43:51 <|Jedai|> quicksilver: I thought they were pretty bad compared to lists for instance
08:44:07 <|Jedai|> quicksilver: even without considering fusion
08:44:14 <mmorrow> lists are pretty hard to beat, since they're just two pointers
08:44:17 <quicksilver> well if the only operation you care about is cons and tail, then yes.
08:44:21 <quicksilver> cons and tail are very fast.
08:44:28 <quicksilver> but most operations require at least something more :)
08:44:30 <|Jedai|> I guess we could have some fusion on Data.Sequence, no ?
08:44:50 <quicksilver> traversing a sequence, for example, should differ in only a small constant factor from traversing a list IMO
08:44:54 <mmorrow> |Jedai|: that'd be sweet if someone figured out a bunch of nice RULEs for them
08:45:05 <quicksilver> fingertrees don't add that many more pointers.
08:45:33 <mmorrow> obligatory sequence sequence http://moonpatio.com/vacuum/gallery/sequence.html
08:45:36 <quicksilver> mmorrow: I think the idea of stream fusion is to be a bit more data structure independent.
08:46:21 <mmorrow> ah, i wasn't thinking of fusion in particular, but that would be cool too if there was fusion rules to apply to Sequence
08:46:38 <mmorrow> *were
08:47:32 <mmorrow> hmm, do you mean like {-# RULES "doThis/undoThis"     doThis . undoThis = id #-} stuff?
08:47:51 <mmorrow> (mean this by "fusion"?)
08:47:53 <lilac> regarding Foldable and Functor, is the wiki actually wrong, or is there a case where "fmap f" and "toList" don't commute?
08:48:04 <quicksilver> well fusion is about avoid the construction of intermediate sequences.
08:48:15 <quicksilver> lilac: Data.Set would be such an example.
08:48:22 <quicksilver> lilac: however, it isn't an element of Functor.
08:48:34 <quicksilver> instance.
08:48:34 <lilac> quicksilver: exactly. inventing counterexamples which aren't is easy ;-)
08:49:00 <lilac> it's the parametricity of Functor and Foldable which i think means they have to commute
08:49:00 <quicksilver> lilac: I wonder if you can prove it with theorems for free techniques.
08:49:05 <quicksilver> right.
08:49:06 <|Jedai|> mmorrow: stream fusion use an intermediate data structure "Stream" to remove most of the recursion in the classic functions on sequence and use rules to fusion away those intermediate
08:49:18 <quicksilver> it's not about removing recursion.
08:49:26 <quicksilver> it's about removing intermediate structures.
08:49:55 <quicksilver> e.g. sum . fmap length :: Seq String -> Int
08:50:02 <|Jedai|> quicksilver: fusion is about removing intermediate structures
08:50:02 <quicksilver> do we really want to create the intermediate Seq Int?
08:50:42 <|Jedai|> quicksilver: stream fusion use some tricks to achieve that, and one of the trick remove apparent recursion
08:51:03 <|Jedai|> quicksilver: but I agree it wasn't really relevant here :)
08:52:03 <lilac> quicksilver: how about simply: suppose there exist f and x such that: fmap f . toList $ x /= toList . fmap f $ x. by parametricity, this must hold for all f. set f = id, then toList x /= toList x
08:52:41 <endojelly> I can't seem to interrupt (with C-c) anymore in ghci 6.10.2?
08:53:03 <|Jedai|> endojelly: there is a bug in this version
08:53:10 <|Jedai|> endojelly: in GHCi
08:53:16 <endojelly> oh okay.
08:53:24 <jmcarthur_work> 6.10.3 is okay afaik
08:53:28 <endojelly> is it fixed in 6.10.3?
08:53:28 <|Jedai|> endojelly: I would suggest installing 6.10.3 if possible
08:53:32 <endojelly> then I'll try that, thanks
08:53:43 <endojelly> |Jedai|, yes it is, I use a binary distribution and haskell platform. thanks!
08:54:30 <Raevel> download or download-curl hackage packages, is either preferred?
08:54:40 <gwern> hahah. haskell-src-exts has gone to 1.0.1
08:54:43 <lilac> can someone with write access to the wiki correct this sentence in "Foldable and Traversable": "if a Foldable is also a Functor, toList and fmap need not perfectly commute"
08:54:44 <gwern> so much for no bugs :)
08:54:46 <EvilTerran> Raevel, eh, i used http-simple
08:54:52 <|Jedai|> Raevel: download don't work on Windows I think
08:55:00 <EvilTerran> (which does work on windows)
08:55:16 <mmorrow> Sequence is totally handay for bfs-y stuff http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6391
08:55:16 <Raevel> EvilTerran: also DEPRECATED, says hackage
08:55:24 <EvilTerran> bah
08:55:28 <EvilTerran> wasn't when i used it =/
08:55:52 <Raevel> there's also http-wget :-o
08:56:04 <gwern> lilac: normally corrections involve a before and an after
08:56:23 <|Jedai|> mmorrow: unicode operators !! ^^
08:56:53 <mmorrow> |Jedai|: heh,  is so nice
08:58:35 <Raevel> okay, i was hoping for something a little more advanced, someway to check download progress for instance
08:59:25 <lilac> gwern: if a Foldable is also a Functor, toList and fmap necessarily commute
08:59:54 <lilac> gwern: basically the whole paragraph needs rewriting with this in mind
09:00:18 <gwern> ok... maybe I could just create an account for you
09:00:32 <Axman6> gwern: version bump doesn't necessarilly mean it had bugs, could be internal changes (like i'm doing for my TernaryTrees package right now)
09:04:54 <|Jedai|> Raevel: Well you could use something a little bit more advanced like HTTP or curl
09:05:18 <|Jedai|> Raevel: download-curl is a convenience package for quick and dirty downloading
09:10:36 <Cale> It's funny. In the font I use for IRC, both  and  look not the right size.
09:11:05 <mansour> what wrong with this code ? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2921#a2921
09:11:26 <Axman6> heh, i love haskell. making improvements to a package means that the code is getting shorter and better
09:11:27 <heatsink> it has a stack overlfow.
09:11:45 <heatsink> As for why it has a stack overflow, that's a strictness problem.
09:11:49 <Botje> mansour: you can'
09:11:51 <mansour> heatsink: wow,
09:11:53 <Botje> mansour: you can't define it like that.
09:12:05 <mansour> Botje: how do I do it then ?
09:12:06 <heatsink> Oh wait, I see.
09:12:07 <Botje> mansour: the second definition will overwrite the first
09:12:08 <doserj> let num i = i + ( num (i-1))
09:12:16 <Botje> put your definition in a file and :load that
09:12:25 <Cale> It's not a strictness problem at all
09:12:37 <heatsink> > let {num 0 = 0; num i = i + (num i - 1)} in num 2
09:12:40 <lambdabot>   * Exception: stack overflow
09:12:51 <heatsink> > let {num 0 = 0; num i = i + (num $ i - 1)} in num 2
09:12:53 <lambdabot>   3
09:12:56 <Cale> num i - 1 is the same as writing (num i) - 1
09:13:12 <Cale> (and it doesn't matter how you put the spaces)
09:14:08 <Cale> In the fixed version, num will be strict in i anyway, since on every step it compares i with 0
09:14:26 <Cale> (so there's no need for strictness annotations)
09:14:26 <heatsink> Oh, yeah.
09:14:43 <mansour> Botje: I don't understand why I need to put it in a file, the end program will be compiled, but the interpter should do the same code
09:14:45 <mansour> !!
09:15:01 <mansour> ok,
09:15:06 <Cale> mansour: The interpreter doesn't even want the same grammatical class of code :)
09:15:17 <heatsink> mansour, You don't need to put it into a file, but you need to put the definitions in brackets as above.
09:15:22 <Cale> mansour: The interpreter is asking for expressions, and inside a file you put declarations.
09:15:28 <mansour> heatsink: so the problem was the precedence
09:15:36 <|Jedai|> mansour: You can see GHCi as operating inside the IO monad
09:15:41 <heatsink> Precedence was one of the two problems
09:15:53 <EvilTerran> mansour, the problem with doing it in ghci was the multi-line definition
09:15:59 <Cale> mansour: There is a way in ghci to temporarily define additional values, but it's still better off putting them in a file.
09:16:06 <heatsink> The other was the fact that your second 'let' was redefining 'num', and your first 'let' was being ignored.
09:16:08 <|Jedai|> mansour: it also accept pure expression (and not definition), but that's just a trick
09:16:21 <mansour> ok, I did put it in a file and it's working
09:16:22 <SamB> mansour: even in Python it isn't actually a good idea to type entire programs into the interpreter ...
09:16:25 <mansour> :)
09:16:46 <mansour> no, I am just trying the code (newbie) in the interpreter,
09:16:51 <EvilTerran> mansour, writing "let ... = ..." in the ghci prompt is like writing "let ... = ... in <the rest of the ghci session>"
09:17:02 <mansour> but I though such a simple code should work the same
09:17:14 <EvilTerran> mansour, so writing "let num 0 = ..." then "let num x = ..." would be the same as writing "let num 0 = ... in let num x = ... in ..."
09:17:21 <mansour> I know I don't use let in the file
09:17:26 <SamB> EvilTerran: until you do :r ;-P
09:17:27 <Raevel> did ghc 6.10.3 break C-p and C-n in ghci (I'm on OS X)?
09:17:44 <EvilTerran> SamB, shh, you :P
09:17:46 <SamB> Raevel: perhaps by default, yeah
09:18:06 <EvilTerran> mansour, indeed, that's because a file's a list of definitions
09:18:11 <SamB> Raevel: they keep switching line-editing libraries, you know
09:18:29 <mansour> EvilTerran: this is a bit confusing ,
09:18:31 <SamB> Raevel: at least, default ones, dunno if you can build GHC to use a different one for ghci
09:18:37 <EvilTerran> mansour, while ghci works (mostly) with expressions, and "let" is how you put a definition in an expression
09:18:37 <mansour> the file is a list of definition ?
09:18:39 <Raevel> :-O
09:18:59 <Raevel> i will perish if this doesn't get fixed
09:19:13 <mansour> ok, now the new issue is, I can not use this in a compiled
09:19:16 <SamB> @bug Raevel
09:19:16 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
09:19:19 <mansour> can not compile and run it
09:19:25 <EvilTerran> @harass SamB
09:19:25 <lambdabot> Unknown command, try @list
09:19:31 <Raevel> SamB: okay :-)
09:19:49 <EvilTerran> mansour, in order to compile code, you need to start dealing with IO
09:19:52 <EvilTerran> ?go io monad don't care
09:19:53 <lambdabot> http://blog.sigfpe.com/2007/11/io-monad-for-people-who-simply-dont.html
09:19:53 <lambdabot> Title: A Neighborhood of Infinity: The IO Monad for People who Simply Don't Care
09:20:30 <|Jedai|> Raevel: What did C-p and C-n do ?
09:20:35 <mansour> ??
09:20:37 <EvilTerran> mansour, it's substantially easier to just stick to putting definitions in a file, loading that file into ghci, and playing around with them in there
09:20:53 <Cale> Raevel: At least now in 6.10.3, delete works sanely again :)
09:21:15 <mansour> yeah, but the final target will be executable, I am just exprementing and building as I go
09:21:17 <|Jedai|> Cale: And Unicode is correctly supported
09:21:18 <Raevel> |Jedai|: next/previous in history, the same as arrow up/down
09:21:25 <Cale> Yeah, and no licensing issues.
09:21:30 <EvilTerran> mansour, at least until you actually want to learn about doing input/output in haskell
09:21:40 <Cale> Raevel: Can you not just use up/down?
09:21:42 <|Jedai|> Raevel: Then you can create those shortcuts for Haskeline
09:22:02 <EvilTerran> mansour, (when you do want to learn about doing input/output, i find http://blog.sigfpe.com/2007/11/io-monad-for-people-who-simply-dont.html makes a good starting point)
09:22:10 <mansour> EvilTerran: hum, a programming language should be realy made easier than this
09:22:12 <Raevel> i stopped using the arrow keys a couple of years back :-)
09:22:21 <Raevel> |Jedai|: oh, okay, i'll look into that
09:22:45 <Cale> http://trac.haskell.org/haskeline/wiki/CustomKeyBindings
09:22:49 <heatsink> EvilTerran, I like how "the truth" is a link to Moggi's paper.  What a learning curve.
09:22:51 <Cale> (also http://trac.haskell.org/haskeline/wiki/UserPrefs)
09:22:57 <|Jedai|> http://trac.haskell.org/haskeline/wiki/CustomKeyBindings
09:23:03 <|Jedai|> oops :)
09:23:19 <EvilTerran> mansour, haskell may be harder than other languages initially, particularly compared to learning one imperative language after you've already learnt another, because it's so different
09:23:24 <Raevel> thank you @ both of you
09:23:54 <EvilTerran> mansour, but i find haskell easier to work in than other languages now i know it better
09:24:08 <|Jedai|> mansour: well learning Haskell is worthwile because it's so different from everything else, that makes it harder too of course
09:24:15 <mansour> EvilTerran: I am expecting a new concepts, but at this very initial stage ?
09:24:46 <EvilTerran> mansour, the point of that link i mentioned is that it avoids the weird maths concepts as far as possible
09:24:50 <|Jedai|> mansour: the basis of the language itself are pretty different from every mainstream language
09:25:13 <|Jedai|> mansour: it's not that hard though, just different
09:26:26 <|Jedai|> mansour: splitting the code between pure code and IO code is one of the big advantage of Haskell later on, though it can be surprising at first
09:26:59 <mansour> |Jedai|: all I need is to calculate the sum of 10, I have the sum function, but putting it in main is tricky ?
09:27:14 <mansour> I am not convinced that I should go to monad yet,
09:27:27 <Cale> mansour:  main = print (...)
09:27:35 <|Jedai|> mansour: well if it's all you want to do, it's not tricky at all
09:27:37 <daf> or you can load your code in ghci
09:27:42 <Cale> where (...) is whatever expression it is that you'd like to print
09:28:08 <Cale> for example:
09:28:13 <Cale> main = print (sum [1..10])
09:28:26 <Cale> I don't think that's too hard ;)
09:29:24 <mansour> Cale: thank you, that helped a lot, and it's what I wanted. I did a mistake by using "main = do .... "
09:29:36 <mansour> I don't know why/when to use "do"
09:29:50 <Cale> You could stick a do in there, but it's really only useful if there's two or more things to do in sequence.
09:29:54 <mauke> mansour: you use "do" when you don't want to call >>=/>> manually
09:30:01 <Cale> main = do print (sum [1..10])
09:30:04 <Cale> means the same thing
09:30:16 <|Jedai|> mansour: do introduce a block in "do-syntax", it's just syntaxic sugar for when you want to chain several actions in a monad
09:30:18 <Cale> You could write, perhaps...
09:30:25 <Cale> main = do n <- readLn
09:30:34 <Cale>           print (sum [1..n])
09:30:38 <mansour> let's keep it simple for now,
09:30:55 <Cale> So there's an example of using do-notation anyway
09:31:02 <mansour> it's working, and I will get there to use this fancy expressions
09:31:03 <heatsink> mansour, the simplest thing is to always use "do" for IO actions.  Later you can learn when to skip it.
09:31:06 <mauke> what cale wrote is syntactic sugar for: main = do { n <- readLn; print (sum [1 .. n]) }
09:31:22 <mauke> which is sugar for: main = readLn >>= \n -> print (sum [1 .. n])
09:31:39 <RayNbow> @undo do do print "dodo"
09:31:39 <lambdabot> print "dodo"
09:31:42 <mauke> wow, the parser in my head finds \n funny
09:31:45 <hackagebot> fsmActions 0.1 - Finite state machines and FSM actions (AndyGimblett)
09:31:47 <mansour> mauke: why did you use n<-ReadLn
09:31:49 <mansour> ?
09:32:03 <mauke> mansour: ask Cale, it's his example :-)
09:32:04 <Cale> mansour: Because I used it first ;)
09:32:22 <mansour> oh sorry, I use small font. LOL
09:32:23 <pikhq> mansour: Sticks the result of readLn in n, basically.
09:32:34 <Cale> mansour: readLn is an IO action which reads a line of text and parses it as some type of value (whatever is needed)
09:32:48 <|Jedai|> mansour: it reads a line and try to parse it into a value of the appropriate type (here Int probably)
09:32:52 <mansour> and readLn ? reads it from the promt ?
09:32:54 <mansour> cool
09:32:56 <Cale> mansour: n <- readLn inside of a do-block means "run readLn and name its result n"
09:33:08 <mansour> nice,
09:33:09 <pikhq> Reads from standard I/O.
09:33:13 <mansour> thank you all
09:33:21 <mauke> read line from stdin and parse into ... something
09:33:27 <Cale> getLine would be what you use to get just a plain string
09:33:41 <Cale> But in this case, we want to parse that line of text as an integer
09:34:04 <Cale> We could also write:
09:34:16 <Cale> main = do xs <- readLn; print (sum xs)
09:34:29 <Cale> and then it would parse a list of numbers instead of a single number
09:34:39 <mauke> yay for return type based overloading
09:34:41 <Cale> because the type of xs is inferred to be [Integer]
09:34:45 <hackagebot> TernaryTrees 0.1.2.0 - Efficient pure ternary tree Sets and Maps (AlexMason)
09:35:07 <Cale> (well, (Num a) => [a], and then defaulted to [Integer])
09:37:55 <sm> does test-framework work on windows ? I fear not, because of regex-posix
09:38:04 <desp> What would you recommend for doing real-time graphics in Haskell?
09:38:18 <Zao> desp: What kind of graphics?\
09:38:25 <Zao> OpenGL would probably be a good start.
09:38:43 <desp> Zao: simple vector graphics.
09:38:52 <desp> Hopefully portable to at least OS X and Linux.
09:39:58 <pikhq> Qt?
09:40:47 <Cale> It's unfortunate, but we don't really have many good simple answers to that.
09:41:22 <Cale> Once reactive-fieldtrip is in a good shape to be used I would recommend that, but it's not really so usable at present.
09:41:37 <desp> Cale: I'm reading about Hieroglyph at the moment.
09:41:40 <Cale> There's Cairo
09:41:45 <desp> I have yet to find out if I can use Cairo on OS X
09:41:47 <Cale> yeah, and Hieroglyph
09:42:05 <Cale> It does require installing gtk2hs, which isn't on hackage.
09:42:06 <deech> Hi all, this is slightly off-topic for a Haskell forum, but I was wondering if there is any material that allows a programmer with a functional background to transition into C++. BTW thanks to all who helped me with monad transformers yesterday.
09:42:48 <pikhq> deech: Don't start with C++.
09:43:07 <desp> That would be a regression ;)
09:43:19 <desp> Cale: did you take part in ICFPPC this year?
09:43:23 <pikhq> Maybe pick up C, and then C++ is trivial.
09:43:28 <Cale> desp: no
09:43:42 <Zao> pikhq: Or not, as you'll be braindamaged from C peculiarities.
09:43:47 <monochrom> I was planning to write a "C/C++ for Haskell programmers" :)
09:43:48 <pikhq> But C++ is just too much of a mess for anyone to pick up sanely.
09:43:53 <desp> Cale: a lot more fun than last year.
09:43:53 <Zao> pikhq: And would have to regress a bit if used to C99.
09:43:53 <Cale> If by 'trivial' you mean that 'only maybe 5 people in the world actually know C++'
09:43:58 <pikhq> Zao: And C++ is more brain-damaging.
09:44:10 <Zao> pikhq: I've got ten years of brain damage!
09:44:14 <pikhq> Cale: ... Well, yes. C++ is too complex to know all of.
09:45:18 <deech> pikhp: I understand, I am trying to make my way into the programming world and Haskell, although awesome, doesn't pay well. Also a giant portion of software out there is in C++ and I feel I'm missing out.
09:46:04 <deech> I understood from Google searches that C++ is a bitch, so I am trying to find the most productive way to learn it.
09:46:14 <Zao> deech: Consider C# or Java?
09:46:21 <Zao> Or maybe python to a lesser degree?
09:46:38 <kig> c++ is totally awesome
09:46:46 <djahandarie> How about D
09:46:53 <etpace_> Guys, if I have deriving Ord, my understanding is that the constructors are checked firstly, and if they're the same the first parameter is checked and compared -- if the constructor and multiple parameters, does it still only ever check the first?
09:47:04 <pikhq> Zao: C# and Java are flooded with programmers. You'll get hired for menial labor jobs. ;)
09:47:09 <deech> D /= jobs
09:47:31 <heatsink> etpace_, It will check all parameters, if it needs to
09:47:41 <Zao> Does anyone perhaps know why leksah depends on Cabal == 1.6.0.1?
09:47:42 <heatsink> > (1,2,3,5) < (1,2,4,5)
09:47:43 <lambdabot>   True
09:47:45 <Saizan> etpace_: no, it checks the second if the first is equal, and so on
09:47:59 <pikhq> deech: Do you want "I could get a job without any effort" or "I could get a job worth having"?
09:48:11 <Saizan> etpace_: giving you the lexicografical order
09:48:16 <deech> pikhq: worth having ... definitely
09:48:20 <dcoutts_> Zao: I'd say that's fairly bogus, though it may have been an attempt to work around some problem.
09:48:35 <etpace_> what if they're all equal?, does it just produce false?
09:48:36 <Cale> etpace_: It compares lexicographically
09:48:48 <pikhq> deech: Then don't learn C# or Java.
09:48:50 <Zao> dcoutts_: Overrode it to 1.6.0.3 now, time will tell.
09:48:54 <Cale> etpace_: If everything is equal then they compare as EQ
09:49:17 <etpace_> ah, of course, thanks
09:49:20 <pikhq> C++, maybe, C, maybe, ASM, maybe, but not those buzzword-compliant POSs.
09:49:24 <Zao> Is it possible to mutate such build-depends without having to unpack and edit the .cabal?
09:49:42 <dcoutts_> Zao: no, you can add constraints but not take them away
09:49:45 <deech> pikhq: So your recommendation is, first C, then C++ ?
09:49:55 <pikhq> deech: C's significantly easier to learn.
09:49:58 <etpace_> What does lexicographically mean? Checks them in the order they appear in the type constructor?
09:50:09 <pikhq> Just because there's less to it.
09:50:12 <Cale> There are also things about C which make it harder to use at first than C++
09:50:20 <Cale> C doesn't have a proper string type, for instance.
09:50:24 <lilac> etpace_: lexicographical order means left-to-right, item by item, like words are ordered in a dictionary
09:50:25 <Saizan> etpace_: essentially, yes
09:50:28 <wli> Any job without adequate health insurance is a death sentence to me.
09:50:29 <Zao> etpace_: Yes, much like the letters in a word in a lexicon.
09:51:20 <pikhq> Cale: Harder to use, sure, but... C++ is just a massive pile of features with little rhyme or reason, which makes anything beyond trivial programs really, really difficult to grok.
09:51:40 <pikhq> Especially when you're just getting used to imperative programming. ;)
09:51:55 <Cale> Indeed, I agree with you. (Though I don't really think C is all that much more coherent, it is certainly smaller)
09:52:12 <deech> pikhq: I know imperative programming. I used Java in school.
09:52:25 <pikhq> C's not exceptionally coherent, but it's significantly more-so than C++, and it helps you to understand what is going on with C.
09:52:38 <wli> Specify a minimalistic imperative language which is coherent/etc.
09:52:38 <Cale> Oh, if you know Java well enough, then using C or C++ should not be too hard.
09:52:39 <pikhq> Erm. Helps you understand what is going on with C++.
09:52:50 <pikhq> wli: Brainfuck.
09:53:00 <pikhq> (emphasis on the 'minimalist'.)
09:53:16 <Cale> Well...
09:53:44 <lilac> i've generally found that the subset of C++ which /isn't/ C is pretty coherent
09:53:46 <pikhq> Well, then. deech, your main headache is going to be memory management.
09:54:00 <heatsink> lilac: Haha, good point
09:54:12 <pikhq> lilac: ... You've not done much non-trivial C++ code, have you?
09:54:14 <wli> I'd try something very different from BF.
09:54:14 <pikhq> :P
09:54:22 <Cale> Yeah, the main difference between Java and C++ is the fact that in C++ you have to manage your own memory allocation.
09:54:27 <lilac> pikhq: quite the opposite. c++ is my bread and butter :)
09:54:32 <pikhq> It's a pile of clusterfucks.
09:54:37 <lilac> pikhq: i suppose that means i'm biased
09:55:06 <lilac> pikhq: an example is worth a thousand generalities, but perhaps we should take this to -blah
09:55:06 <wli> I'd also recommend devising something from scratch.
09:55:11 <etpace_> thanks all
09:55:23 <pikhq> Granted, that it's got C in it is a large part of *why* it's so messy, but that influences almost all of it, making it terrible.
09:55:27 <deech> pikhq: Ah, ok. I will keep that in mind. So the plan is to pick a five-star C and C++ book from Amazon and dive in!
09:55:28 <pikhq> Anyways.
09:55:41 <mauke> preflex: ? k&r
09:55:41 <preflex>  factoid not found
09:55:43 <mauke> preflex: ? k&r2
09:55:43 <preflex>  factoid not found
09:55:45 <mauke> what!
09:56:00 <pikhq> deech: Yeah, that's about the only way to learn C and C++. Just dive in, hacking as you go.
09:56:09 <pikhq> And be ready for a lot of screwy bugs.
09:56:11 <lilac> pikhq: i'm in #haskell-blah if you want to talk about this more
09:56:15 <mauke> preflex: store k&r2 Brian W. Kernighan and Dennis M. Ritchie, The C Programming Language, Second Edition, Prentice Hall, 1988, ISBN 0-13-110362-8, 0-13-110370-9.
09:56:21 <pikhq> lilac: Eh.
09:56:34 <Zao> deech: Thinking in C++ is available for free online, which is decent.
09:57:01 * Saizan is irrationally scared of "thinking in c++"
09:57:22 <Saizan> will my neurons shoot themselves in their feet?
09:58:51 <burp>   "thinking in c++" <- brr, same
09:59:44 <zebrafinch> Saizan: no, but instead of automatically consolidating memories in your sleep you'll have to manage them yourself.
10:00:38 <heatsink> You know, thinking in C++ actually sounds like a very _bad_ idea.  It's much better to be proficient at translating to/from C++.
10:01:31 <pikhq> When I code in C, I try to think in assembly and work from there.
10:01:40 <pikhq> (it's saner)
10:02:38 <mike-burns> Thinking in the language you're writing in makes sense.
10:02:55 <mauke> pikhq: not really
10:03:01 <Zao> Being Haskellic in C++ doesn't result in sane code.
10:03:08 <mauke> asmers tend to write ugly C
10:03:20 <mauke> also brittle
10:04:13 <olsner> C actually has a small measure of abstraction from hardware, so you better make use of what you get
10:04:26 <Axman6> argh! dyslexia strikes again. pikhq i thought you were the #archlinux bot  phrik >_<
10:04:36 <mauke> C is completely abstracted from hardware
10:05:34 <lilac> assembler is pretty abstracted from hardware these days
10:05:56 <wli> lilac: How so?
10:05:59 <lilac> at least for the cisc instruction sets
10:06:23 * Axman6 quite likes SPARC assembly
10:06:27 <lilac> wli: microcode on modern x86 processors translates the machine code into a different, risc-based instruction set first
10:06:56 <lilac> wli: and then there's register renaming and so on, on some cpus
10:07:00 <wli> That's not-entirely-accurate partial propaganda.
10:07:16 <mauke> C quiz: what does this program do?
10:07:17 <mauke> int main(void) { short i; for (i = 0; i < 10; --i) { printf("%hd\n", i); } return 0; }
10:07:27 <lilac> mauke: undefined behaviour
10:07:30 <wli> It also doesn't really mean asm is divorced from hardware.
10:07:32 <jelly12gen> er lol your in haskell
10:07:52 <Meady> guys if i do say a <- function or io etc, is it ran here, or when i actually reference to it?
10:07:56 <mauke> lilac: right :-)
10:08:10 <lilac> mauke: my favourite: double x = x * 2;
10:08:14 <mauke> next question, what does it do on your implementation and why?
10:08:26 <soupdragon> lilac haha
10:08:31 <Berengal> lilac: Microcode works on on machine code, which is implemented in hardware
10:08:36 <soupdragon> that's haskell
10:08:43 <Zao> Meady: When you suck out the value from the grips of IO.
10:08:46 <Axman6> mauke: %hd is ... something decimal...?
10:08:52 <mauke> Axman6: short int, decimal
10:08:53 <olsner> signed overflow is a classic undefined behaviour-that-almost-always-works
10:08:58 <heatsink> mauke, The abstraction is really complicated, though.  For example, preprocessed C++ is _not_ completely abstracted from hardware.
10:09:04 <Zao> let x = print "lol" -- x is completely inert until sequenced.
10:09:07 <heatsink> erm, preprocessed C
10:09:09 <Axman6> thought so. wondering if it meant half
10:09:27 <olsner> lilac: what always amazes me is that you don't get an error for it
10:09:39 <Meady> so say i have a <- io which gets time fro server, if i print a more than once, will the time have changed? or is a just a result now
10:09:45 <lilac> mauke: 65525 lines or so printed, wrapping around from -32768 to +32767, is what i'd expect
10:09:51 <mauke> Meady: a is just a result
10:10:00 <Zao> Meady: Something of type (IO t) is just something that represents a computation in IO.
10:10:16 <mauke> lilac: that's not what happens here (linux, gcc)
10:10:16 <Berengal> Meady: The value extracted is pure and unchanging. You'll have to do it more than once to make it change
10:10:17 <Meady> so printing a twice wont change the time, ill have to recall the function
10:10:23 <Zao> Something of type t is just a value, it's pure and nonchanging.
10:10:24 <Meady> ok thanks
10:10:51 <Zao> It's the sequencing of the IO action that runs it, not handling of the action or the result.
10:10:57 <lilac> mauke: oops, when it wraps around it'll stop. my bad
10:11:01 <Berengal> Also, it makes sense to speak of "performing actions" instead of "calling functions" when speaking of IO
10:11:07 <mauke> lilac: not that either
10:11:08 <kig> you still can only communicate with the cpu using asm so whether the cpu translates your instructions into microcode or migratory patterns of starlings is not all that relevant
10:11:17 <Axman6> mauke: you should be stayig away from IO while you're learning haskell imo ;)
10:11:21 <Axman6> uh, Meady, not mauke
10:12:16 <lilac> mauke: it's exactly what it does here (again, linux, gcc). are you using a 64-bit compiler?
10:12:34 <mauke> lilac: no; are you using -O2?
10:12:52 <Zao> There's a lot of X client bindings in Haskell. Are there any Haskell X servers out there?
10:12:54 <lilac> mauke: just tried that, interesting
10:12:56 <olsner> mauke: i get the numbers [0 .. -32768] printed on one line each
10:13:13 <mauke> olsner: with optimizations enabled?
10:13:19 <lilac> olsner: looks like -O2 causes the compiler to determine that the i < 10 condition always evaluates to false
10:13:19 <olsner> nope
10:13:27 <lilac> s/false/true/
10:14:14 <Berengal> Would there happen to exist a mail-sending library?
10:14:36 <olsner> if i starts at 0 and goes down and never wraps (and it "can't" wrap) it will always be less than 10 yes
10:14:59 <heatsink> Berengal, Network.Email.Sendmail
10:15:13 <lilac> the compiler is free to assume that i will never wrap, so it seems a good optimization :)
10:15:15 <heatsink> http://hackage.haskell.org/package/MissingH-1.0.0
10:15:24 <lilac> mauke: that's a really nice example
10:15:41 <Berengal> heatsink: Nice...
10:15:56 <dons> ghc 6.12 looks good: http://www.reddit.com/r/programming/comments/8x170/whats_new_in_ghc_612_improved_parallel/
10:16:10 <Meady> mauke, cale spent a couple of hours going through it yesterday
10:16:13 <Meady> collecting results etc
10:16:25 <Zao> dons: Now it just needs cluster parallelism :P
10:16:35 <Meady> we did some examples the compilers way >> then did it without them and do instead
10:17:04 <Berengal> Zao: Even better would be a fully distributed runtime (erlang style)
10:17:37 <copumpkin> 6.12 does look good, but I'd like to see language extensions
10:17:39 <copumpkin> :P
10:17:53 <Berengal> copumpkin: We don't have enough you mean?
10:17:57 <copumpkin> yup!
10:17:59 <copumpkin> needmoar
10:18:02 <copumpkin> ;)
10:18:04 <mauke> I'd like to see readline support in ghci and argv[0]
10:18:15 * copumpkin wants argv[-1]
10:18:25 <copumpkin> (that should get the kernel name)
10:18:53 <zebrafinch> copumpkin: or maybe the shell prompt
10:19:00 <Berengal> mauke: getProgName?
10:19:34 <mauke> Berengal: http://hackage.haskell.org/trac/ghc/ticket/3199
10:20:58 <Berengal> mauke: Ah... didn't know about that one
10:23:14 <Cale> Hey Meady! Getting any more comfortable with things?
10:26:53 <Cale> Meady: when you write v <- x, it means that when the IO action you're writing is run, x is run at this very point in it, and v is the (unchanging) result.
10:28:03 <sm> "perform the action and assign the value" vs. "assign the (unperformed) action"
10:30:56 <Administrator_> hi guys
10:31:26 <NEEDMOAR> copumpkin: were you talking to me?
10:31:37 <copumpkin> nope, sorry :) was just saying I needed moar
10:31:39 <Berengal> Hehehe
10:32:09 <lysgaard> Anyone know why leksa needs cabal 1.0.6.1 and not 1.0.6.3 that I've got installed? Is it possible to workaround?
10:32:22 <dcoutts_> lysgaard: hack the .cabal file
10:32:24 <Zao> lysgaard: Just cabal unpack and hack the .cabal.
10:32:40 * Zao gave up on leksah due to gtksourceview.
10:32:50 <Administrator_> hi
10:32:58 <Zao> Which required intltool, which required perl's XML::Parser, which required expat.
10:33:09 <lysgaard> Zao: You gave up or the author?
10:33:15 <Zao> I.
10:33:19 <Zao> Thus my use of /me
10:33:31 <Zao> Administrator_: Hellos.
10:38:13 <tromp> > 3^14
10:38:14 <lambdabot>   4782969
10:38:25 <tromp> > 3^14 `mod` 864
10:38:26 <lambdabot>   729
10:42:04 <tromp> > 3^14-3^6
10:42:06 <lambdabot>   4782240
10:42:21 <tromp> > 4782240 / 864.0
10:42:22 <lambdabot>   5535.0
10:44:42 <tromp> > 3^8
10:44:43 <lambdabot>   6561
10:44:48 <tromp> > 32*205
10:44:49 <lambdabot>   6560
10:45:21 <tromp> > 2*3^13 `mod` 864
10:45:23 <lambdabot>   486
10:45:28 <heatsink> tromp: lambdabot responds to private messages.
10:45:38 <nickel> anyone have a problem with code that usees underscores instead of camel case?
10:45:41 <tromp> thx:)
10:45:42 <nickel> for function names that is
10:45:52 <Axman6> i think my MBP got jealous
10:46:43 <Axman6> it's battery has been dying (the machine just losing power without warning) at about 20% charge. after getting my new 4 year old thinkpad, it's decicded it ca go all the way to 0% again
10:47:00 <Axman6> whoops, wrong chan
10:47:17 <Axman6> nickel: i have major aesthetic problems with it
10:48:17 <mauke> nickel: no, camel case is ugly anyway
10:48:26 <nickel> yay mauke I agree
10:48:29 <soupdragon> nickel: it is syntactically valid but it is obnoxious to write that way in Haskell
10:48:41 <Axman6> i _hate_ underscore in function names, or pretty much anywhere. even when following a tutorial that uses underscores, i'll replace them with camel case versions
10:48:53 <Axman6> they make code so ugly
10:48:54 <nickel> I'm the polar opposite
10:49:08 <nickel> function_name seems better to me than functionName
10:49:18 <soupdragon> I use the convention of the language, in Haskell the convention is camel case
10:49:19 <Axman6> i find do_this_thing much harder to read than doThisThing
10:49:21 <mauke> my preferences are: names-like-this > names_like_this > namesLikeThis
10:49:21 <copumpkin> I like underscores in names when it's conventional to write it in the language
10:49:24 <byorgey> it's mostly a function of what you're used to.
10:49:29 <copumpkin> but it isn't in haskell, so I used camelCase
10:49:33 * wli just uses f
10:49:52 <mauke> heh, or the C version: nmlkths
10:50:01 <Axman6> f, f', f'', f''' etc
10:50:09 <copumpkin> we need hungarian notation in haskell! ;)
10:50:10 <byorgey> nickel: IMO, you should either use camelCase, or just use underscores and don't bother to ask if it's OK =)
10:50:15 <nickel> generally I adhear the language trend
10:50:33 <copumpkin> nickel: the mighty oleg uses underscores, but I think it looks weird alongside all the camelcase
10:50:57 <nickel> so, aside from Axman there, I wouldn't be shunned for using them at least
10:51:13 <copumpkin> nope, but I wouldn't use your APIs if I could avoid them ;)
10:51:13 * nickel so very concerned that people will like him :D
10:51:17 * Axman6 will hunt you down
10:51:37 <copumpkin> nickel: whatever you do, don't do This_Is_A_Module_Name
10:51:44 <copumpkin> or I will hunt you down too
10:51:57 <nickel> I would shoot myself for that
10:52:04 <Axman6> or thisisafunctionatobandmaybec
10:52:17 <Zao> copumpkin: This_Is.A_Module.Name
10:52:37 * nickel is statisfied
10:52:49 <copumpkin> what's the verdict?
10:53:00 <centrinia> Just put everything in Main
10:53:03 <Axman6> good work heatSink
10:53:08 <copumpkin> centrinia: good idea!
10:54:15 <copumpkin> (I also think that camelcasing regular compound english words is weird)
10:54:23 <Axman6> indeed
10:54:30 <heatSink> ...
10:54:36 <copumpkin> :P
10:54:36 <Axman6> copumpkin is not one such word though
10:54:49 <copumpkin> Axman6: it is in my dictionary! so there!
10:54:53 <Axman6> but co is also a prefix, so copumpkin is ok
10:55:03 <copumpkin> you mean you don't know what a copumpkin is?
10:55:14 <Philonous> pumpkin->Void
10:55:19 <Axman6> ok, battery's about to die. night all
10:55:23 <copumpkin> lol
10:58:41 <nickel> copumpkin: if your asking me for a verdict I'm going to use underscores until I get to a point where people actually care enough about my haskell software to make an issue of it
10:59:07 <lysgaard> Zao: What is your perferred haskell editor?
10:59:45 <monochrom> Oleg uses this'is'a'zip
10:59:48 <copumpkin> nickel: you won't feel weird seeing camel case in all your imported APIs?
10:59:55 <copumpkin> you can't rename imports ;)
11:01:01 <monochrom> import qualified Data.List(zipWith) as Wrong
11:01:07 <soupdragon> nickel: You should use camel case
11:01:11 <monochrom> zip'with = Wrong.zipWith
11:01:27 <centrinia> Who cares about qualified names anyways? You can simply perform alpha-conversions on a whim. :)
11:01:39 <Zao> lysgaard: gvim
11:01:40 <monochrom> Forgot {-# LANGUAGE NoMonomorphismRestriction #-}
11:02:30 <paulvisschers> Are there any new developments in the new record implementation arena?
11:02:42 <paulvisschers> in the last few months
11:03:03 <lysgaard> Zao: I use vim too, but I feel that a don't know all the features that's needed.
11:03:11 <lysgaard> Zao: You have any tricks?
11:03:23 <heastink> How do you combine CamelCase with all-caps abbreviations?  getOSThing or getOsThing?  osGetThing or oSGetThing?
11:03:36 <soupdragon> getOSThing
11:03:51 <Zao> lysgaard: http://projects.haskell.org/haskellmode-vim/
11:03:53 <monochrom> gEToSthinG
11:04:08 <monochrom> @elite getOSThing
11:04:08 <lambdabot> GE70zThiNG
11:04:11 <monochrom> Do that!
11:04:15 <Zao> heastink: I tend to go the Qt way with TcpFrobnicator.
11:04:41 <lysgaard> Zao: Use it already, but I'm not intoo all it's features
11:05:10 <lysgaard> Zao: Never got haddoc etc. to work
11:05:42 <Zao> Never tried that.
11:11:36 <Arnar> perhaps I am misunderstanding the Haskell Platform page.. but should there be ubuntu packages somewhere?
11:12:07 <gwern> there should, except haskell is not well supported on debian/ubuntu
11:12:26 <Arnar> gwern: nope, seems 6.8.2 is the latest ghc package..
11:12:45 <Arnar> gwern: so I should just compile the latest ghc and install the platform from the tarball?
11:13:00 <gwern> sure. 'swhat I do
11:13:14 <Arnar> cool, thx
11:14:15 <Arnar> gwern: should one get ghc-...-extralibs, or is that all included in the platform?
11:14:26 * gwern isn't sure, actually
11:14:39 <Arnar> np, I'll find out :)
11:15:47 <georgehorse> I'm reasonably sure you should get and build the extralibs.
11:16:03 <Arnar> georgehorse: thanks.. already did just in case
11:16:36 <georgehorse> Arnar: No real reason not to, no sense spending half an hour compiling and then finding out you need tehm
11:17:18 <Arnar> any specific configure flags you recommend for ubuntu 9.10?
11:18:26 <georgehorse> http://hackage.haskell.org/platform/2009.2.0.1/haskell-platform.cabal
11:37:25 <tristes_tigres> Hello
11:39:13 <lysgaard> Wow, haskellmode for vim is quite comprehensive, I've only scratched the surface =)
11:43:41 <etpace_> @find fix
11:43:43 <lambdabot> Not in scope: type variable `fix'
11:44:06 <etpace_> hmm, what's the function that recurses on itself?
11:44:20 <wli> Ackermann's function
11:44:20 <amuck_> @src fix
11:44:20 <lambdabot> fix f = let x = f x in x
11:44:26 <etpace_> Where is it?
11:44:49 <ClaudiusMaximus> Data.Function
11:44:54 <etpace_> thanks
11:45:47 <BONUS> cool thing to try out in ghci: fix error
11:46:09 <yairchu> What is fix for?
11:46:56 <Peaker> yairchu: points-free combinator for recursive hookup of functions to call themselves
11:47:02 <Peaker> fix f = f (fix f)
11:47:32 <monochrom> http://www.vex.net/~trebla/haskell/fix.xhtml explains fix.
11:47:41 <Peaker> @pl f n = f (n-1) * 5
11:47:41 <lambdabot> f = fix (flip flip 5 . ((*) .) . (. subtract 1))
11:47:58 <Peaker> ok, not a great example :)
11:48:00 <Cale> > fix (\fac n -> if n == 0 then 1 else n * fac (n-1)) 10
11:48:01 <mansour> I am a bit confused about something like "if ( i / 2 ) == 0
11:48:01 <ClaudiusMaximus> fix is useful if you don't have recursive bindings, instead of "factorial = \n -> ... factorial (n-1)" ... you can do "factorial = fix $ \fact n -> ... fact (n-1) ..."
11:48:02 <lambdabot>   3628800
11:48:13 <monochrom> My url has more examples.
11:48:18 <Cale> > fix (1:)
11:48:18 <mansour> I am a bit confused about something like "if ( i / 2 ) == 0 " and "if (i - 3) ==0 "
11:48:21 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
11:48:26 <mansour> the seconf one works fine
11:48:29 <soupdragon> monochrom I like your cont monad stuff it is very good
11:48:35 <monochrom> Thank you.
11:48:36 <Peaker> yairchu: mfix is interesting
11:48:45 <yairchu> Coolness
11:48:49 <soupdragon> actually I think it is the best
11:49:04 <Cale> yairchu: It finds the least defined fixed point of a function.
11:49:12 <yairchu> I like Cale's example
11:49:13 <Peaker> yairchu: you know the term "fixpoint" from mathematics?
11:49:43 <Peaker> yairchu: a point where f(x) = x
11:49:49 <Cale> yairchu: If the function sends undefined to undefined, then that is what you will get. But if it sends it to something which is not completely undefined, then undefined isn't a fixed point of the function, and so you'll get something more interesting.
11:50:05 <yairchu> Peaker: I know fixed-point fractional numbers rep instead of floating point
11:50:07 <Peaker> Cale: by "sends" you mean maps?
11:50:19 <Cale> yairchu: Yeah, that's a completely unrelated use of the words :)
11:50:25 <Peaker> yairchu: no, not that fixed :)
11:50:41 <Cale> Peaker: yes, in the way that functions send values in one set to other values in another set. :)
11:50:56 <mansour> anyone who wants to answer my question ?
11:50:59 <mansour> I am a bit confused about something like "if ( i / 2 ) == 0 " and "if (i - 3) ==0 "
11:51:03 <mansour> the seconf one works fine
11:51:08 <yairchu> Oh I also know the other term but in another language..
11:51:29 <Cale> > let i = 3.4 in if i/2 == 0 then "hello" else "world"
11:51:30 <lambdabot>   "world"
11:51:54 <yairchu> mansour: Whats the confusion?
11:52:03 <mansour> why the first one wont work ?
11:52:09 <Cale> mansour: It might be that i is an Integer, in which case, i/2 doesn't make sense. Integer division is called div
11:52:24 <Peaker> @type mfix
11:52:26 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
11:52:27 <Cale> div i 2 or i `div` 2 is what you'd want to write in that case
11:52:38 <mansour> wonderful, Cale. Thanks
11:52:43 <yairchu> mansour: Perhaps i is Integral?
11:52:49 <mansour> ??
11:52:51 <Cale>  / is only used for fractional division
11:52:53 <mansour> yep it's integer
11:52:54 <Peaker> yairchu: ^^ this is interesting because it allows forward-references to monadic binds from the "future".  e.g:  mdo { x <- use y; y <- use x; blah }
11:53:11 <mansour> you mean when "franciton / fraction "
11:53:13 <mansour> ??
11:53:18 <Peaker> yairchu: if you can implement the MonadFix type-class - then your monad supports future references
11:53:30 <Cale> mansour: With types like Rational, Float, Double, etc.
11:53:47 <mansour> yeah, but even with "div" it's not working
11:54:23 <Cale> Well, you'd have to show us more of your program to be able to say why.
11:54:29 <mansour> Cale:         if  ( i div 3) == 0
11:54:34 <mansour> this wont work
11:54:38 <Cale> i `div` 3
11:54:43 <mansour> i is integer
11:54:46 <mansour> Int
11:54:51 <Cale> Notice the backticks
11:54:57 <Peaker> mansour: div is a prefix function. `div` is an infix function
11:54:58 <mansour> why did you put the quotes
11:54:59 <yairchu> Or div i 3
11:55:10 <Cale> mansour: because they turn functions into infix operators
11:55:10 <Peaker> mansour: backquotes convert to infix-ness
11:55:18 <Badger> backquotes are magic!
11:55:23 <mansour> okaaaaaaaaaay, I C
11:55:30 <Cale> > div 5 2
11:55:31 <lambdabot>   2
11:55:35 <Cale> > 5 `div` 2
11:55:36 <lambdabot>   2
11:55:41 <mansour> so I use backquotes for infix
11:55:45 <Cale> yeah
11:55:45 <mansour> that worked.
11:56:08 <Cale> > 5 / 2
11:56:10 <lambdabot>   2.5
11:56:15 <mansour> I tried them both
11:56:25 <mansour> that's why mod was not working
11:56:37 <Cale> > 5 `mod` 2
11:56:39 <lambdabot>   1
11:57:35 <Badger> :t pi
11:57:36 <lambdabot> forall a. (Floating a) => a
11:58:21 <mansour> Cale: thank you. Thanks all for your help and support
11:58:27 <Cale> no problem
11:59:00 <gwern> @ask nomeata http://darcswatch.nomeata.de/repo_http:__code.haskell.org_yi.html <-- how did that xmonad utf8 patch get in there?
11:59:01 <lambdabot> Consider it noted.
12:06:13 <tristes_tigres> suppose I declare data type newtype (Num a) => P a = P  [a] and want to put it into, say, Num class; why do I need to supply context like that:  instance Num a => Num [a] where ...
12:06:32 <tristes_tigres> the data declaration already says it's in Num cklass &
12:07:00 <tristes_tigres> like that  instance Num a => Num (P  [a])
12:07:18 <tristes_tigres> and not simply  instance  Num (P [a])
12:07:51 <Peaker> tristes_tigres: I think that the context of data/newtype isn't actually provided by the data-type at all. Most examples I see don't bother to specify any context in data/newtype declarations
12:08:02 <gwern> what channel is the icfp contest?
12:08:11 <gwern> all the binary links seem to be broken...
12:08:12 <Cale> tristes_tigres: That class context is pretty useless and doesn't mean what you want it to mean
12:08:27 <lilac> what does it mean then?
12:08:35 <tristes_tigres> I can't use constructor P on non-Num, but instance declaration doesn't see that ?
12:08:53 <Cale> tristes_tigres: It only affects the type of the data constructor P, and doesn't do anything like storing a typeclass dictionary along with the data.
12:08:59 <gwern> not to mention the icfp blog is gone
12:09:00 <tristes_tigres> Cale: well, it doesn't let me to use P on non-Num
12:09:09 <monochrom> Just write: newtype P a = P [a]; instance Num a => Num (P a) where ...
12:09:10 <Cale> You can't use P on a non-Num, but that's it.
12:09:26 <Cale> Pattern matching on P doesn't magically reconstruct the Num dictionary for you.
12:09:27 <gwern> it'd be hard to do the contest without the binary programs for the VM...
12:09:51 <Cale> If you want that, the GADT extension in newer GHCs will give you something like it
12:09:56 <Cale> data P a where
12:10:06 <Cale>   P :: (Num a) => [a] -> P a
12:10:18 <lilac> gwern: if you want a copy, i know some people who entered and will probably still have the binaries
12:10:36 <tristes_tigres> Cale: in GADT form Num context in instance won't be needed ?
12:10:38 <Cale> Then you'll be able to write things like:
12:10:48 <Cale> f :: P a -> a
12:10:53 <Cale> f (P xs) = sum xs
12:11:25 <Cale> But yeah, it's actually quite a subtle and fancy type extension.
12:11:34 <lilac> so the context is still necessary on the instance head in order to let ghc know that it has to pass a dictionary?
12:11:38 <lilac> that's depressingly operational
12:12:05 <Cale> Eh?
12:12:27 <Cale> Well, it's not just the operational part...
12:12:37 <gwern> hm, no, logging in doesn't help either
12:12:49 <gwern> lilac: that would be nice, since the site seems to be borked
12:12:55 <Cale> The typing rules are much more subtle too.
12:13:11 <tristes_tigres> Cale: strange that  f (P xs) = sum xs doesn't work on my defeinition of P ?
12:13:28 <gwern> lilac: gwern0@gmail.com kthnxbai
12:13:33 <etpace_> Can somebody explain binary search trees a bit? LYAH says that everything to the left of the node is smaller, but what if the node is created with the smallest node possible, surely it would be very unbalanced then? or is the tree rebuilt for each new item, or what?
12:13:39 <Cale> tristes_tigres: Well, it's just that the typeclass context *only* restricts the type of the P constructor
12:13:39 <tristes_tigres> I actually used newtype (Num a) => P a = P { coeff :: [a] }
12:13:45 <Cale> That's *all* that it does.
12:14:24 <Cale> Note that it doesn't mean that you can't have a value of type  P String, for instance
12:14:32 <Cale> undefined is such a value
12:14:38 <opqdonut> etpace_: yes, the tree nees rebalancing
12:14:40 <|Jedai|> etpace_: well you have several strategy to balance BST but for small example and to understand how it works you don't need that
12:14:44 <opqdonut> etpace_: there are many algorithms for that
12:15:07 <opqdonut> etpace_: AA trees are very easy to do functionally, okasaki's redblack-trees are also nice
12:15:21 <Cale> Also, it's not strange at all that it can't work with newtypes
12:15:24 <opqdonut> AA and redblack being to rebalancing schemes
12:15:42 <Cale> The whole point of newtypes is that their representation can be identical to an existing type.
12:16:01 <etpace_> ok, thanks guys
12:16:12 <tristes_tigres> Cale: but attempting to use P on non-Num results in error:  No instance for (Num Char)
12:16:27 <Cale> But if the class constraint meant what you wanted it to mean, then that would require the representation to include evidence that it really is an instance of Num
12:17:03 <tristes_tigres> Cale: OK, thanks
12:17:09 <Cale> Knowing that a type is an instance of Num because your constructor required it, and having the actual evidence for that instance are two different things :)
12:17:30 <Cale> (that is, the function needs to acquire the methods from somewhere)
12:17:56 <Cale> If it doesn't get them by having its own class context, then the methods will have to be carried along with the data
12:17:58 <monochrom> typeclass constraints in "data Blah = ..." and "newtype Blah = ..." are going out of fashion. There are some good reasons coming back from the field.
12:18:18 <Cale> monochrom: I think they should just be changed to mean what they mean for GADTs.
12:18:29 <Cale> and disallowed on newtypes
12:18:32 <tristes_tigres> monochrom: what is the recommended replacement ? GADT ?
12:18:45 <monochrom> The recommended replacement is don't do it.
12:18:57 <tristes_tigres> monochrom: but it is a useful thing
12:19:09 <monochrom> Have constraints in functions that uses your data type, fine. No need to have it in your data type.
12:19:16 <Cale> actually, I think we should get deriving to work on sufficiently restricted GADTs and then drop the other syntax
12:19:35 <Cale> (maybe)
12:19:43 <tristes_tigres> Cale: right now, GADT are insufficiently restrictive for that ?
12:19:44 <monochrom> 10 years ago people agreed with you that they thought it was useful. Now they see it's useless and it makes extensions harder.
12:19:52 <Cale> tristes_tigres: hm?
12:20:05 <Cale> tristes_tigres: deriving currently doesn't work at all for GADTs.
12:20:57 <monochrom> I think it is useful as a comment to humans "I only want to have Num here".
12:21:09 <Cale> This class context for plain-style data and newtypes is actually referred to as the "stupid context" in the GHC source code.
12:21:15 <tristes_tigres> Cale: deriving in the sence that I want ? Not requiring Num context in instance decl ?
12:21:28 <Cale> tristes_tigres: I mean like  deriving (Eq, Ord)
12:21:36 <tristes_tigres> monochrom: "only" ?
12:21:50 <Cale> tristes_tigres: That doesn't work on GADTs, which makes them a good deal more inconvenient for many things.
12:21:54 <monochrom> You don't understand "only"?
12:22:03 <Cale> But if it did, then we wouldn't need the original syntax so much anymore.
12:22:29 <tristes_tigres> monochrom: The whole point of *good* programming language design is facilitating communication between programmers
12:22:55 <monochrom> Yes. I agree. Does not contradict with other things I said.
12:23:00 <SamB> Cale: I remember I found the standard syntax very confusing when I was learning
12:23:05 <Cale> tristes_tigres: What most libraries do is not to restrict the constructor, but just to restrict all the operations.
12:23:20 <Cale> SamB: Yeah, I think the GADT syntax is much more transparent to beginners.
12:23:27 <Cale> (despite being more general)
12:23:31 <monochrom> A piece of stuff that only tells other humans should have no semantics to the compiler.
12:23:38 <monochrom> s/tells/talks to/
12:23:47 <tristes_tigres> Cale: any particular reason for not restricting cnstructor, when it only makes sense for particular class of operqands ?
12:24:06 <Cale> tristes_tigres: Well, because it doesn't make anything more convenient.
12:24:15 <tristes_tigres> monochrom: it also prevents errors
12:24:29 <monochrom> Haskell98 says the typeclass constraint in data should have semantics. We now regret it. It should have no semantics. You can keep the syntax and let the compiler ignore it.
12:24:33 <Cale> tristes_tigres: and you'll still probably catch those errors, since all the operations have that context anyway
12:24:35 <tristes_tigres> Cale: but the point of type-checking is to reduce error
12:24:49 <SamB> I personally think maybe it should have some semantics
12:24:56 <SamB> but not the ones that Haskell98 gives it
12:24:57 <Cale> tristes_tigres: yes, but as soon as you do anything with the values, you'll catch the problem
12:25:00 <tristes_tigres> SamB: me, too
12:25:07 <Cale> (at compile time)
12:25:21 <monochrom> The only "error" it prevents is using your data type for a more general purpose that you, the narrow-minded author, did not foresee. You will regret it.
12:25:25 <Cale> tristes_tigres: and it still doesn't prevent anyone from writing
12:25:27 <SamB> (and if it doesn't have any semantics, shouldn't it be in {- -} or whitespace?)
12:25:29 <tristes_tigres> Cale: then error detection is delayed, doesn't it ? Till runtime maybe, even
12:25:31 <Cale> x = undefined :: P String
12:25:39 <Cale> tristes_tigres: No!
12:25:50 <jmcarthur_work> not runtime, for sure
12:26:03 <Cale> f :: (Num a) => P a -> a
12:26:18 <monochrom> The fact is your functions that use that data type will have all the necessary and sufficient typeclass constraints and error-checking already.
12:26:20 <Cale> Just *try* to apply f to something of type P String. The compiler will catch the error.
12:26:59 <Cale> The point is that sure, you can construct values of silly types, but so long as all the operations have the context you want, you'll inevitably catch the problem anyway.
12:27:16 <tristes_tigres> Cale: if I forget class context in function declaration, , P ith restricted context still catxhes it
12:27:32 <jmcarthur_work> tristes_tigres, if you forgot it, did it need it in the first place?
12:27:42 <monochrom> newtype P a = P [a]  is a fine general type for everyone. Why force a to be Num?
12:27:48 <Cale> tristes_tigres: Well, if the function wouldn't have complained about not haivng the instance, maybe it shouldn't have that context anyway?
12:28:15 <monochrom> Oh you want f (P xs) = sum xs, that's f's constraint, not P's constraint.
12:28:22 <tristes_tigres> Cale: is there some harm in restricting type of P constructor &
12:28:44 <Cale> tristes_tigres: Well, your library is less general in an unnecessary way.
12:29:00 <monochrom> newtype (Num a) => P a = P [a]  is premature optimization.
12:29:13 <jmcarthur_work> it's not even an optimization, is it?
12:29:14 <tristes_tigres> Cale: but I *want* it to be less general. It has certain meaning
12:29:22 <Cale> Basically, just because you decided to give these extra restrictive types to things
12:29:25 <lilac> i guess the problem is that, given 'data Num a => Foo a = Foo a', Foo String has one inhabitant, not zero
12:29:44 <monochrom> where my "optimization" includes specialization, restriction... those things that "optimizes" human understanding prematurely.
12:29:48 <Cale> It's better for things to have the natural types which they would get via typechecking, usually.
12:30:13 <lilac> Cale: would you be in favour of ($) :: a -> a?
12:30:17 <Cale> Unless you actually need them to be monomorphic for performance, but the typeclass isn't even helping performance, it's making things slower.
12:30:44 <zloog> Does anyone know what the difference between an expected and an inferred type is when trying to understand ghc errors? Like a man page i could read or something?
12:31:05 <Cale> lilac: I wouldn't outright mind it, but since it's a binary operator, I think it ought to have two parameters.
12:31:16 <lilac> zloog: one is the type that ghc worked out, and the other is the type that ghc worked out :)
12:31:30 <zloog> lilac: that was what i was afraid of
12:31:55 <jesmon> zloag: sometimes the expected type is what is declared, AFAICS. Inferred is from context tho
12:31:55 <SamB> zloog: one is the type that GHC worked out for the expression, and the other is the type that GHC thought it should have based on the context
12:32:20 <lilac> zloog: understanding which one it had inferred and what it was expecting requires you to understand /how/ ghc infers types (and in what order), as far as i can see
12:32:20 <Cale> zloog: the expected type is the type coming from context, the inferred type is the type coming from the expression itself
12:33:08 <jmcarthur_work> as far as i understand it, expected with the type inferred from context and inferred is the type inferred from the local expression only
12:33:25 <Cale> That is, the expected type is what is expected to go here, and the type at which 'undefined' would be applied if it were there.
12:33:26 <jmcarthur_work> *expected is
12:33:49 <monochrom> My mnemoic is "expected"->"e"->"external", "inferred"->"i"->"internal".
12:33:49 <Cale> The inferred type is the type which would be inferred if you cut that expression out and gave it its own definition.
12:34:21 <tristes_tigres> OK, another thing; suppose I make data type an instance of some class, but only a subset of class operations has meaning for my datatype. Is the right way to define instance functions that I need and simply ignore compiler warnings ?
12:34:29 <monochrom> But in practice I don't care. One stakeholder wants it Int, another stakeholder wants it Bool. That's enough information.
12:34:35 <zloog> Cale: That sounds like a good rule of thumb
12:34:39 <zloog> Cale: thanks
12:34:51 <SamB> tristes_tigres: the right way is to bitch and moan at the people who designed the class that it should be split into pieces
12:34:56 <jmcarthur_work> tristes_tigres, some people follow that approach. others make new classes with the proper functionality
12:35:07 <Cale> tristes_tigres: I think usually the right thing to do is to actually define a new separate class, or yell at whoever designed the class you're writing an instance of :)
12:35:08 <jmcarthur_work> Num is a common class to rape like that
12:35:17 <SamB> and to start researching ways to make splitting up classes after the fact easier ;-)
12:35:19 <Cale> But yeah, for the Prelude, it's hard.
12:35:39 <Cale> If you want to turn off the errors, you can just write  signum x = error "signum is meaningless here"
12:35:55 <idnar> @type signum
12:36:03 <lambdabot> forall a. (Num a) => a -> a
12:36:04 <tristes_tigres> jmcarthur: yep, try defining signum for polynomials
12:36:17 <idnar> what is signum?
12:36:21 <ray> > signum (-5)
12:36:22 <lambdabot>   -1
12:36:26 <Cale> > map signum [-10..10]
12:36:27 <lambdabot>   [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,1,1,1,1,1,1,1,1,1,1]
12:36:29 <jmcarthur_work> @src abs
12:36:29 <lambdabot> Source not found. Just try something else.
12:36:34 <idnar> oh, right
12:36:36 <SamB> @src signum
12:36:37 <lambdabot> Source not found. You type like i drive.
12:36:44 <idnar> > signum (-0.3)
12:36:45 <lambdabot>   -1.0
12:37:19 <pikhq> > let abs a = signum a * a in map abs [-10..10]
12:37:21 <lambdabot>   [10,9,8,7,6,5,4,3,2,1,0,1,2,3,4,5,6,7,8,9,10]
12:37:27 <tristes_tigres> > signum 1/0
12:37:29 <lambdabot>   Infinity
12:37:36 <tristes_tigres> wha ?
12:37:38 <Cale> You could do something like define abs of a polynomial to be its leading coefficient, and signum to be the polynomial divided by that coefficient.
12:37:43 <jmcarthur_work> > 1/0
12:37:44 <lambdabot>   Infinity
12:37:47 <pikhq> 1/0 = Infinity.
12:37:52 <Cale> But it's kind of silly.
12:38:01 <tristes_tigres> pikhq: but NOT signum of it
12:38:12 <Badger> @index signum
12:38:12 <lambdabot> Prelude
12:38:13 <tristes_tigres> Cale: precisely
12:38:14 <idnar> > signum (1/0)
12:38:14 <jmcarthur_work> you do have a point
12:38:15 <lambdabot>   1.0
12:38:16 * pragma_ annoyed by the lower-cased 'I' in the "You type like i drive" message above.
12:38:16 <Cale> tristes_tigres: that's not what you wrote
12:38:22 <LeoD> how would you mapM over a Data.Map?
12:38:29 <Cale> tristes_tigres: you wrote  signum 1/0 which is (signum 1)/0
12:38:34 <idnar> pragma_: I pretty much find the whole message annoying
12:38:34 <jmcarthur_work> oh, haha, (signum 1)/0
12:38:38 <tristes_tigres> Cale: ahh, I see
12:38:40 <jmcarthur_work> i missed it too
12:39:00 <Cale> LeoD: You might toList it first
12:39:09 <jmcarthur_work> spacing messes up my mental haskell parser
12:39:11 <LeoD> hm, and then back to Map again?
12:39:25 <tristes_tigres> whitespace should work instead of brackets here, really
12:39:37 <Cale> LeoD: or, I think it's an instance of Traversable
12:39:37 <soupdragon> No
12:39:42 <Cale> yes...
12:39:44 <tristes_tigres> like it does in source files :-)
12:39:46 <jmcarthur_work> that would be great until you start aligning code
12:39:50 <Cale> :t Data.Traversable.mapM
12:39:52 <lambdabot> forall a (m :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
12:40:00 <LeoD> ah, great
12:40:13 <ray> @pl \a -> (signum a) * (abs a)
12:40:13 <lambdabot> liftM2 (*) signum abs
12:40:17 <Cale> however, that only traverses over the values in the Map and not the keys
12:40:32 <Cale> (you won't be able to depend on what the keys were)
12:40:39 <LeoD> that's ok :)
12:40:42 <ray> lifting (*) is pertty cool
12:40:43 <tristes_tigres> So, there is no clean, officially approved solution for writing instances of Num without signum and abs ?
12:40:45 <ray> pretty cool
12:40:54 <Cale> tristes_tigres: It's sad.
12:40:58 <ray> Num really sucks
12:41:01 <Cale> tristes_tigres: All you can do is error out.
12:41:09 <idnar> jmcarthur_work: maybe precedence should be whitespace-sensitive
12:41:24 <Cale> tristes_tigres: Almost everyone wants this fixed, but some people are hesitant to change the Prelude.
12:41:31 <tristes_tigres> idnar: that, I am afraid, would make compiler too smart for its own good
12:41:43 <Cale> My opinion is that we have an H98 package, and if people want to be H98 compatible, then they can use that.
12:41:45 <ray> people differ in how many typeclasses they want to replace it with, too
12:41:52 <idnar> tristes_tigres: it's not that different from the layout rule, is it? ;)
12:41:55 <Cale> We should not be so afraid to change things in new versions of base
12:42:31 <Cale> but yeah, the other half of the problem is that there are too many possibilities for improvement, and they have tradeoffs
12:42:36 <lilac> it is nice that we have a versioning system which /actually works/
12:42:38 <ray> ghc already breaks binary compatibility every release
12:42:43 <Cale> and people can't decide in which direction they want to go
12:42:59 <ray> why can't we break code compatibility while people are recompiling everything anyway?
12:42:59 <tristes_tigres> Cale: maybe something like "partial instance" ?
12:43:09 <Cale> ray: exactly
12:43:24 <lilac> i'd vote for type class aliases plus one type class per method :)
12:43:51 <ray> so would i, actually
12:43:58 <Cale> tristes_tigres: Well, we at least want to split Num up into at least a proper version of Num with just (+), (-), (*), negate, and fromIntegral, and then the rest in another class.
12:44:10 <Cale> But then there are more refined possibilities
12:44:12 <lilac> class Add a b c | a b -> c where (+) :: a -> b -> c
12:44:17 <Cale> nooooo!
12:44:31 <soupdragon> why is it a b -> c
12:44:31 <Cale> You have no idea how horrible that would be :)
12:44:51 <lilac> Cale: i don't want negate in Num. Think of the Naturals!
12:44:55 <Cale> soupdragon: because knowing the types a and b should be enough to determine what the type c would be
12:44:56 <soupdragon> I'd rather something like  Add a b c | c < a & c < b
12:44:59 <Zao> class LikeNum where, class Numish where, class Numberic, class Numeral
12:45:12 <Cale> er, I should have said fromInteger there
12:45:30 <Cale> lilac: Well, I just gave the coarsest possible split
12:45:43 <Cale> lilac: which would initially make everyone a bit happier
12:45:49 <tristes_tigres> Cale: and what about Integral class. Why does it requre Enum ?
12:46:05 <tristes_tigres> quot rem and div don't need Enum
12:46:11 <Cale> tristes_tigres: Well, that's another strange one
12:46:22 <Cale> another thing I'd like to do is remove Int from the Prelude altogether.
12:46:24 <lilac> Cale: i'd be happy with Num having just 'fromInteger' actually ;-)
12:46:38 <Cale> Int can be in a separate library which people can import when they want it
12:46:38 <|Jedai|> soupdragon: And what does that mean ? There is no subtyping in Haskell
12:46:49 <Cale> lilac: That's clearly not enough.
12:47:00 <soupdragon> |Jedai|: then I want to add it or something
12:47:09 <ray> Int should be treated like, say, ByteString (and Float too!)
12:47:27 <Cale> soupdragon: also, it's backward, isn't it?
12:47:43 <|Jedai|> soupdragon: Please no
12:47:47 <tristes_tigres> Cale: remove Int and keep Integer ?
12:47:56 <Cale> soupdragon: subtyping makes inference horrible
12:48:09 <soupdragon> Cale: yeah it's backwards thanks
12:48:11 <|Jedai|> soupdragon: subtyping is quite horrible in type system in my experience
12:48:17 <Cale> soupdragon: you really don't want it. Just look at scala. ;)
12:48:33 <monochrom> Java tells you that subtype+polymorphism is very hard. OCaml tells you that too but more elegantly.
12:48:36 <soupdragon> since everyone annotates the programs with types.. why do you care about inference?
12:48:48 <Cale> soupdragon: No, everyone does not.
12:48:50 <monochrom> I DON'T ANNOTATE!
12:49:09 <Cale> I don't annotate until I'm getting ready to release something.
12:49:22 <monochrom> I annotate some "important" ones but leave others inferred.
12:49:23 <|Jedai|> soupdragon: You may not have noticed but most people don't annotate every local variable/function
12:49:24 <Cale> Or until I'm having trouble.
12:49:38 <Cale> Yeah, there's some initial annotations I might write in the design stage too.
12:49:43 <Cale> But certainly not every single thing.
12:49:45 <tristes_tigres> because type inference is RAD COOL
12:49:50 <soupdragon> |Jedai|: if you knew a bit about type checking then you know that's not required
12:49:53 <Cale> and usually not things inside where clauses
12:50:00 <Cale> and usually not individual subexpressions
12:50:04 <tristes_tigres> @vixen19 what about type inference ?
12:50:05 <lambdabot> any type will due
12:50:15 <monochrom> type inference is why some python people like haskell.
12:50:17 <taruti> Is there a variant of hGetContents that does not close the Handle? I'd like to have some code like: foo <- hGetContents h foo; processFoo foo; hPutStrLn h "foobar"
12:50:32 <Cale> and subtyping requires a whole lot more annotations in those places than I'm willing to put up with
12:51:03 <|Jedai|> soupdragon: I don't understand what you mean ? You said type inference was useless because everyone annoted everything, I said that wasn't true, especially not the local variables/functions (in where or let)
12:51:09 <Cale> taruti: no, not really.
12:51:24 <monochrom> type inference is why lambdabot is so easy to use
12:51:28 <Cale> taruti: heh, you have the opposite problem that people usually do :)
12:51:48 <Cale> taruti: the other problem people have is with hGetContents not closing the handle soon enough :)
12:52:10 <|Jedai|> taruti: mixing lazy IO and opening a file in ReadWrite mode seems a good recipe for headaches to me
12:52:13 <taruti> yes, I know. So just reimplement it myself then
12:52:21 <Cale> taruti: if you can verify that the handle really is closed, then you can just reopen it, maybe
12:52:33 <taruti> |Jedai|: it is a socket.
12:52:49 <Cale> taruti: actually, you might use the strict ByteString version of hGetContents
12:53:00 <Cale> hmm
12:53:08 <Cale> I think that might still close it though, I'm not sure.
12:53:40 <Cale> oh, yeah, it does
12:53:55 <jmcarthur_work> you know? spacing to represent precedence might not be as horrible as it sounds to me
12:54:12 <jmcarthur_work> i just played with some of my code to see what it would look like, and it isn't bad at all
12:54:24 <Cale> jmcarthur_work: There's an extent to which it would be okay, but I'm used to the current way that things work
12:54:42 <Cale> My brain has equalised with Haskell's parser to a fair extent :)
12:54:48 <|Jedai|> jmcarthur_work: Well to you now it don't... Imagine someone else looking at your code (or yourself some years from now)
12:55:35 <tristes_tigres> well, whitespace already does something like that: like . means different things depending on wheter it has spaces around it
12:55:46 <jmcarthur_work> it seems to be easier to read than to write, though...
12:55:47 <Cale> People have considered requiring operators to be separated from their arguments by whitespace
12:55:48 <|Jedai|> tristes_tigres: True
12:55:57 <Cale> tristes_tigres: yes, I hate that too.
12:56:09 <Cale> tristes_tigres: We chose the wrong symbol for the module path separator.
12:56:16 <|Jedai|> I don't like it very much myself...
12:56:28 <Cale> (.) is by far my most commonly used infix operator
12:56:52 <Cale> I suspect probably something like 75% of all the infix operators in my code are (.)
12:57:06 <idnar> Cale: does function application count as an infix operator? :P
12:57:09 <Cale> no
12:57:15 * tristes_tigres thinks making whitespace denote precedence would make for great entries in "Obfuscated Haskell" contest
12:57:18 <Cale> It's really annoying to have a composition chain with qualified names in it.
12:57:36 <Cale> Heh, more whitespace -> more separation
12:57:44 <Cale> f  g x  h y
12:57:54 <Cale> --> f (g x) (h y)
12:57:54 <tristes_tigres> and also tabs
12:58:22 <Cale> k   f  g x  h y
12:58:30 <Cale> --> k (f (g x) (h y))
12:58:36 <jmcarthur_work> it gets ridiculous the further you take it
12:58:38 <Cale> horrible :)
12:58:39 <pikhq> Looks like HOMESPRING.
12:58:58 <tristes_tigres> Cale: see ? you are already using it. What a great feature !
12:59:00 <LeoD> agh, so it turns out that i do in fact need the keys... i guess there is no other way than toList to mapM over a Map with keys+values?
12:59:23 <Cale> LeoD: Is there a problem with that?
12:59:33 <jmcarthur_work> @pl \k f g x y -> k (f (g x) (h y))
12:59:33 <lambdabot> (. flip (flip . ((flip . ((.) .)) .) . (.)) h) . (.) . (.) . (.)
12:59:36 <jmcarthur_work> best!
12:59:50 <tristes_tigres> what aboit spaces around (.), do they count towards precedence ?
12:59:51 <LeoD> Cale: i guess not, except performance :P shouldn't matter though
13:00:01 <Cale> LeoD: you're going to pay for rearranging the results into a Map anyway. If the keys don't change, you can use fromAscList
13:00:06 <hackagebot> zoneinfo 0.4 - ZoneInfo library. (MarkAylett)
13:00:16 <LeoD> Cale: ah, right
13:00:18 <Cale> LeoD: (since they'll already be in order)
13:00:45 <jeffersonheard> which one is more used, hsc2hs or c2hs?
13:00:59 <Cale> You might complain about the intermediate list, but the cons cells will be immediate garbage anyway, so the memory usage is constant.
13:01:13 <LeoD> great :)
13:01:27 <Cale> (and in fact, in the future, it might be deforested altogether, I don't know about now)
13:03:09 <pikhq> HOMESPRING, aka: Hatchery Oblivion through Marshy Energy from Snowmelt Powers Rapids Insulated but Not Great. A valid (if useless) code example.
13:05:02 <etpace_> What's an ADT?
13:05:15 <Cale> etpace_: algebraic datatype
13:05:22 <etpace_> thanks
13:05:26 <Cale> etpace_: or abstract datatype, depending on context :)
13:05:36 <etpace_> It's in LYAH, when hes explaining kinds
13:05:39 <Cale> which is unfortunate, since they are opposites
13:05:53 <Cale> ah, then algebraic, almost certainly
13:06:02 <etpace_> All functions take concrete types, right?
13:06:19 <opqdonut> yes
13:06:19 <Cale> Well, you can make a type abstract by using the module system
13:06:42 <opqdonut> i guess by concrete he meant "of a kind with no arrows"
13:06:43 <opqdonut> ?
13:06:49 <Cale> or you can have a function which takes a value of any type in some typeclass
13:06:56 <tristes_tigres> so, just use abs x = error "No abs for you"
13:06:58 <etpace_> Maybe Int is concrete, Maybe a isn't, I think
13:07:02 <Cale> tristes_tigres: yeah
13:07:04 <opqdonut> yes
13:07:15 <Cale> tristes_tigres: It's really unfortunate, but it's the most reasonable option for now.
13:07:31 <tristes_tigres> Haskell-prime will fix that ?
13:07:37 <Cale> tristes_tigres: No idea.
13:07:46 <monochrom> jmcarthur_work: In practice I use "mathspad" ( http://www.cs.nott.ac.uk/~rcb/mathspad/ ) to create and maintain mathy papers and slides. It uses spacing to hint precedence at me. Internally it observes precedence, too.
13:07:48 <Cale> tristes_tigres: It's unclear whether haskell' will change the prelude.
13:08:06 <Cale> If Haskell' follows its own guidelines, then no, it won't change anything about the prelude.
13:08:42 <monochrom> Oh, and because it is graphical rather than fixed-width-font, it can use 1 pixel, 2 pixels, 3 pixels... for spacing and so things don't get too wide.
13:08:55 <monochrom> And so, I ask again:
13:09:18 <monochrom> Will Programming Be Liberated from the Plain Text File? At least the Fixed Width Font?
13:09:38 <jmcarthur_work> someday...
13:09:50 <tristes_tigres> monochrom: already was. Check Mondrian
13:10:08 <monochrom> I guess next time I'll just weaken to Fixed Point Font so I can get more people to agree.
13:10:24 <monochrom> Err Fixed Width Font.
13:10:25 <Cale> I find Haskell' to be a potentially important but sublimely boring enterprise. Standardising what's already been done is great, but it's not really very interesting. But if we're going to take that approach to standards, which I think is actually the best you can do, then we should not be afraid to break compatibility with the standard as long as there's a reasonable option for people who want to conform to it.
13:11:57 <monochrom> Except Mondrian isn't used often. Not even as often as Haskell.
13:12:12 <Cale> You obviously can't *both* hold off changing things because it would break compatibility with the standard *and* not change things in the standard.
13:13:03 <ray> LANGUAGE Haskell98
13:13:14 <tristes_tigres> monochrom: did I say mondrian ? I meant Piet, of course
13:13:21 <soupdragon> whats wrong with fixed width font?
13:13:35 <ray> maybe LANGUAGE Haskell2008 for whatever's commonly used now
13:13:47 <Cale> soupdragon: Mainly that requiring it is conceptually ugly.
13:13:47 <monochrom> I secretly think Haskell' is just for the sake of upgrading Oleg's work. :)
13:14:00 <Cale> soupdragon: (as Haskell does)
13:14:31 <monochrom> I no longer use fixed-width fonts for IRC.
13:14:38 <Vq^> Cale: in what way?
13:15:02 <Cale> Vq^: In what way does it seem a bit ugly, or in what way does Haskell require it?
13:15:03 <ray> in what way is assuming things about someone's *font* not ugly?
13:15:13 <Vq^> Cale: in what way does Haskell require it?
13:15:25 * heastink wonders if native CJK speakers have higher affinity for fixed-width latin fonts
13:15:27 <Cale> Vq^: Haskell cares about which column things are aligned with
13:15:44 <ray> consider that in most variable-width fonts, spaces are a lot narrower than, say, m
13:15:59 <Cale> For example...
13:15:59 <pikhq> Non-fixed-width programming is fail.
13:16:03 <soupdragon> It's possible to use non-fixed-width fonts with haskell -- you just have to do lots of hard work making an editor
13:16:04 <ray> say you have main = do ...
13:16:11 <Cale> f x y = do u <- getLine
13:16:12 <Vq^> Cale: i realised that now
13:16:17 <monochrom> CJK speakers have higher affinity for double-width latin letters! 
13:16:23 <Vq^> Cale: i don't code that way myself though
13:16:37 <ray> i don't actually see the double-widths that often
13:16:42 <Cale> then the next line has to be indented exactly length "f x y = do " spaces to be the next line of the do-block
13:17:06 <tristes_tigres> And also language with non ASCII - characters,  
13:17:39 <Cale> I never press enter immediately after 'do'
13:17:46 <Vq^> Cale: i would write a newline directly after the "do" in that example
13:17:46 <ray> so does  count as 4 or 8 characters to haskell layout?
13:17:47 <Cale> (but sometimes immediately before it)
13:18:56 <Cale> However, I think what would be best is just to have an editor which is aware of layout and draws light grey lines to show how the blocks are lined up.
13:19:10 <Vq^> that would be nice
13:19:54 <Cale> (and then makes sure to get it all right when saving to a file)
13:20:41 <Cale> Also, if you have, say, a do-block, and you put your cursor immediately before the 'do' and press enter, then the whole do-block should come with it.
13:21:02 <Cale> Even yi seems to get that wrong.
13:21:13 <Cale> (though it will push the do-block around if you type other characters)
13:21:22 <ray> this is stuff everyone wants but nobody wants to implement
13:21:58 <Cale> Actually, what I *really* want is something even smarter :)
13:22:09 <Cale> I want a Mathematica-style notebook interface for Haskell.
13:22:18 <monochrom> An incentive for not implementing it is that no one will use it. Everyone will cry "it breaks version control diffing!"
13:22:37 <opqdonut> :D
13:22:38 <Cale> fuck version control ;)
13:22:55 <heastink> So, how's darcs's indentation patche support coming?
13:22:59 <heastink> *patch
13:23:14 <tristes_tigres>    ,
13:23:19 <monochrom> Our version control is too deeply rooted with the plain-text-file assumption that we are stuck at this inertial pit hole.
13:23:19 <ray> you can't make an editor without breaking a few version control systems
13:23:30 <tristes_tigres> isn't darcs dead ?
13:23:34 <Cale> heh, that would be cool. A version of darcs that could tell that only layout had changed in a way which doesn't change the meaning of the code.
13:23:36 <ray> our text editing is too deeply rooted with that same assumption
13:23:46 <soupdragon> software isn't alive
13:23:47 <Cale> tristes_tigres: no.
13:23:55 <ray> well, there are word processors
13:23:57 <|Jedai|> tristes_tigres: Not at all
13:24:03 <ray> which serve an entirely different set of users
13:24:09 <Cale> tristes_tigres: Only its original programmer has stopped working hard on it.
13:24:09 <tristes_tigres> but GHC dumped it ?
13:24:24 <jmcarthur_work> tristes_tigres, darcs is quite alive and kicking
13:24:26 <Cale> tristes_tigres: Other people are still keeping it up.
13:24:30 <tristes_tigres> Cale: that does sound like a death knell
13:24:35 <Cale> tristes_tigres: It's not.
13:24:36 <|Jedai|> tristes_tigres: it bounced back nicely since the depressing post of its author for the release of the v2
13:24:38 <monochrom> Yes, the "dumb secretaries and essay-writing artsies" with their word processors are actually several decades ahead of us dumb programmers.
13:24:53 <Cale> tristes_tigres: Essentially the entire Haskell community uses darcs.
13:24:56 <ray> programmers are WAY too conservative
13:25:03 <opqdonut> monochrom: except they don't have version control
13:25:06 <ray> i mean, look at us (even me!) using unix
13:25:18 <Cale> tristes_tigres: So there's no chance of it dying.
13:25:30 <pikhq> ray: Because UNIX is good enough, yes.
13:25:31 <jeffersonheard> I keep thinking there's a better way to format code and format a code's history than we have now; not merely fixing the indentation, but visually rearranging Haskell code
13:25:32 <ray> opqdonut: they do!
13:25:35 <monochrom> IIRC Microsoft Office has version control and very concurrent (multiple authors).
13:25:41 <ray> word certainly does
13:25:45 <pikhq> And Plan 9 can't exactly take over because, well, UNIX still works.
13:25:49 <ray> random word clones probably do
13:25:55 <opqdonut> not proper version control
13:26:01 <Berengal> Plan 9 can be better than unix can. The problem is, it isn't
13:26:20 <|Jedai|> tristes_tigres: the community was a bit shaken by this announce and since then a team has organized itself around darcs, with weekly progress report, participation in Hackaton and a GSoC project
13:26:21 <Cale> Plan 9 needs a reasonable text editor first.
13:26:22 <opqdonut> yeah they can do merges nowadays, but we did that almost 40 years ago
13:26:26 <pikhq> Berengal: Plan 9 is certainly a better OS than UNIX. The problem is, an OS itself isn't much good.
13:26:35 <opqdonut> Cale: you don't like acme?
13:26:39 <opqdonut> (or was it wily?)
13:26:39 <jeffersonheard> not just like drawing grey lines or showing revisions, but showing characteristics of the revisions at a glance, like when you open a file, show a little timeline with revisions and microrevisions, whether they compile,
13:26:45 <jeffersonheard> whether they're tagged, etc
13:27:04 <jeffersonheard> be able to play back the revision of a file in the viewer and stop it where you want to fork
13:27:10 <Cale> opqdonut: It (supposedly) has no option for automatically expanding tabs into spaces, and is therefore practically unusable for writing Haskell code.
13:27:11 <opqdonut> jeffersonheard: there are good visualisations for the new dvcs systems
13:27:16 <ray> opqdonut: i'd invite you to fire up word, but that program is so prohibitively expensive!
13:27:19 <opqdonut> git-gui especially is nice
13:27:35 <opqdonut> Cale: ok
13:27:47 <tristes_tigres> Jedai: I think maybe letting darcs go into sunset could be smart move. Haskell is already plenty different enough, so using its own VCS is just another entry barrier
13:27:50 <jeffersonheard> opqdonut: I've seen them and I agree -- I just want to see that in integrated into a code editor, and not separate
13:27:54 <Berengal> jeffersonheard: I also like my VCS to keep out of my way when I don't need it. Even small coloured lines in the margin annoy me...
13:28:11 <jeffersonheard> Beregal: each to their own, certainly :-)
13:28:39 <tristes_tigres> ray: on the piratbay.org it isn't expensive at all :-)
13:28:39 <jeffersonheard> I personally have rather poor vision, so line-highlighting and syntax colouring are magic
13:28:39 <Berengal> A VCS minor mode could be useful though...
13:29:09 <opqdonut> Berengal: they exist :)
13:29:19 <|Jedai|> tristes_tigres: darcs is pretty good and not that hard to use. It's not like anybody is forcing you to use it to code in Haskell anyway, there's plenty of git repository in Hackage cabal descriptions
13:29:19 <Cale> The other thing which I'm never impressed with about plan 9 is that the GUI always looks like hell. Build a decent gui to leverage the cool features in the OS, and people will want to use it more, I think. :)
13:29:20 <Berengal> opqdonut: Yeah, I know, but not for yi
13:29:38 <Berengal> Besides, I don't have much use for VCS at home. At work, sure, but at work I use netbeans :(
13:30:06 <jmcarthur_work> i use both git and darcs for various projects and enjoy them both
13:30:14 <pikhq> Cale: It's X-like.
13:30:18 <tristes_tigres> Jedai: darcs not used outside Haskell commmuinity, as far as I understand ?
13:30:23 <Berengal> Speaking of darcs, how's darcs for windows? Or perhaps I should join #darcs...
13:30:44 <Vq^> tristes_tigres: it is
13:30:47 <Berengal> (At work we use CVS, which is an absolute nightmare)
13:30:58 <jmcarthur_work> i use both darcs and git at work, and we are very much not a haskell shop (although officially we use subversion :( )
13:30:58 <Michitux> tristes_tigres: it is. see e.g. dokuwiki, a wiki engine written in php.
13:31:00 <Cale> tristes_tigres: Well, it is, but not so much.
13:31:02 <|Jedai|> tristes_tigres: I think there was some other users of darcs outside the community, though with git it's probably less true now
13:31:17 <dcoutts_> tristes_tigres: it's fair to say that the higest density of darcs users is within the Haskell community, but it's not true that we are the only users
13:31:24 <Berengal> darcs' patch philosophy would fit in perfectly with how I work right now
13:31:44 <lysgaard> I'm getting an error i dont know how to fix, there's some coflicting libs: "Could not find module `Control.Monad.State': it was found in multiple packages: monads-fd-0.0.0.1 mtl-1.1.0.2"
13:31:57 <dcoutts_> lysgaard: ghc-pkg hide monads-fd
13:31:59 <|Jedai|> lysgaard: hide one of them
13:32:27 <lysgaard> Tried that, but then i get an error that it will break packages
13:32:59 <monochrom> promiscuous package installing is hazardous to your health
13:33:05 <jmcarthur_work> lysgaard, you could just add -hide-package monads-fd to your ghc line, or use cabal
13:33:07 <|Jedai|> lysgaard: that's more than strange... hiding a package should never break another, what's the message exactly ?
13:33:14 <Berengal>  -hide-package
13:33:25 <Berengal> (when compiling)
13:33:36 <lysgaard> Oh! Sorry, i did ghc-pkg unregister :S
13:33:50 <|Jedai|> lysgaard: Right, that's not the same thing
13:34:03 <lysgaard> Is there any way i can add the hide package in the file?
13:34:13 <Berengal> Not in the file, no
13:34:41 <|Jedai|> lysgaard: no, but that's not a problem, hiding a package is global and permanent
13:34:44 <jmcarthur_work> would be an odd thing to allows OPTIONS_GHC to do
13:35:16 * jmcarthur_work would still rather advocate -hide-package
13:35:20 <Berengal> I could see it being useful if you needed two modules that just so happened to have the same name
13:35:35 <lysgaard> Okay, but won't the packages requiring monads-fd behave strange when i hide it?
13:35:35 <|Jedai|> lysgaard: you can still use it explicitly in any compilation and you can show it again, all it does is that the package won't be considered during the search for a module by ghc --make
13:35:56 <lysgaard> Okay, thanks, hiding is the way =)
13:36:05 <monochrom> fileA.hs: {-# OPTIONS_GHC hide monad-fd, unhide mtl #-}. fileB.hs: {-# OPTIONS_GHC unhide monad-fd, hide mtl #-}.  ghc fileA.hs fileB.hs...  Whee!
13:36:08 <|Jedai|> lysgaard: No, they're already linked to it, that it is hidden is not an obstacle :)
13:36:32 <Berengal> monochrom: That actually works?
13:36:36 <Berengal> monochrom: What about ghci?
13:36:38 <jmcarthur_work> monochrom, i mean -hide-package
13:36:43 <monochrom> No, it should not work. :)
13:36:50 <Berengal> Ah, yes...
13:37:19 <monochrom> "Can GHC create a package it cannot hide..."
13:37:21 <jmcarthur_work> and yeah, of course it wouldn't work
13:37:24 <Berengal> I spent a couple of hours figuring out I couldn't do that when I started figuring out monad transformers...
13:39:38 <jeffersonheard> Is there anything out there other than the GHC manual for hsc2hs?  I'm trying to figure out how it works from the manual and the gtk2hs sources atm.
13:40:00 <jeffersonheard> I have four header files with functions I want to expose and I'd like not to end up with carpal tunnel from writing FFI code
13:40:42 <dcoutts_> jeffersonheard: if you've got lots of functions and not many structs then perhaps you need c2hs
13:41:15 <dcoutts_> jeffersonheard: hsc2hs does not help at all with importing functions, only with getting C contants and writing Storable instances
13:41:26 <dcoutts_> and some basic type mappings
13:41:36 <jeffersonheard> dcoutts_: thanks.  That was the answer I was looking for earlier
13:41:45 <jeffersonheard> is c2hs still maintained?
13:41:52 * dcoutts_ is one of the c2hs maintainers
13:41:59 <jeffersonheard> oh, ah ha!
13:42:03 <lysgaard> Can cabal-install downgrade a package?
13:42:22 <dcoutts_> lysgaard: you can install as many versions of a package as you like
13:42:36 <|Jedai|> lysgaard: cabal-install can install a specific version of a package, remember that you can install several versions at the same tiem
13:42:40 <|Jedai|> *time
13:42:55 <jeffersonheard> is this still the most up-to-date doc for it, duncan?  http://www.cse.unsw.edu.au/~chak/haskell/c2hs/
13:42:59 <lysgaard> Oh, can i. Cool
13:43:03 <dcoutts_> jeffersonheard: yep
13:46:27 <lysgaard> Then the question becomes, how do i use just one specific version? ghc-pkg hide again?
13:48:14 <jeffersonheard> oh yay.  there's much more doc on here than there was last time.
13:50:18 <Heffalump> lysgaard: or ghc -package foo-x.x.x
13:52:23 <lysgaard> Ah, see =)
14:05:34 <etpace_> In LYAH, they try to take a type with kind (* -> *) -> * -> * -> * be an instance of the Functor class, it says that we should apply two arguments so we're left with (* -> *), but uh, say the type is barry x y z, surely barry x y would result in a type * -> *, as the first two arguments correspond to the first two "sections" of the type?
14:06:11 <opqdonut> yes?
14:06:26 <opqdonut> which was exactly what was wanted
14:06:57 <etpace_> it is indeed, what was I thinking
14:07:09 <etpace_> I was forgetting about the final -> *, so I was thinking you'd need to use the first argument
14:07:23 <opqdonut> :)
14:09:37 <Japsu> In R'LYEH, they try to take : i Cthulhu fhtagn!
14:09:57 <Japsu> (sorry, couldn't resist)
14:11:22 <Zrs> The dreaded :[black box] command... *shudders*
14:12:12 <nlogax> r'lyeh world haskell
14:16:14 <lysgaard> What does it mean when cabal-install says that the "gtk" package is "not avaiable from server"?
14:17:31 <Cale> lysgaard: It means that while there's a dependency on the gtk package, that package is not available on the hackage server, and you'll have to download and install it separately
14:17:51 <Cale> http://www.haskell.org/gtk2hs/
14:18:09 * byorgey cries
14:18:15 <lysgaard> Cale: Ah, ok
14:18:19 <byorgey> gtk2hs not being cabalized is super sad =(
14:18:27 <dcoutts> aye
14:18:40 <byorgey> but I gather it would be super difficult.
14:18:48 <dcoutts> if anyone wants to help I can point you at the required tasks
14:18:57 <dcoutts> partly in gtk2hs, partly in Cabal
14:19:16 <lysgaard> There was one in my arch repo =)
14:19:17 <byorgey> dcoutts: what would be required in Cabal?
14:20:30 <dcoutts> byorgey: http://hackage.haskell.org/trac/hackage/ticket/48
14:20:50 <dcoutts> byorgey: basically building .chs files in dep order
14:22:46 <byorgey> dcoutts: ok, got it
14:23:46 <dcoutts> byorgey: the problem with the task is what level of generality we use
14:24:40 <dcoutts> byorgey: Saizan did a whole GSoC project on a very general approach, basically implementing a generic make-like dep language, though we've not yet integrated that code (it's a big change)
14:24:56 <byorgey> dcoutts: oh, yeah, I remember reading about that GSoC project
14:25:23 <byorgey> oh, so if that framework was included we could do .chs dependency stuff just as part of that framework
14:25:28 <dcoutts> right
14:25:38 <dcoutts> like we'd do with .hs/.hi/.o
14:25:43 <byorgey> yeah
14:25:54 <byorgey> dcoutts: will you be at the hackathon before ICFP?
14:25:59 <dcoutts> byorgey: yep
14:26:36 <byorgey> dcoutts: cool, me too.  I'd love to help on some Cabal stuff then.
14:26:48 <tommd1>  dcoutts: Is something wrong with the Hackage-server patches I sent?
14:26:49 <byorgey> perhaps even this very ticket, or whatever is helpful.
14:26:52 <dcoutts> byorgey: yay :-)
14:27:08 <dcoutts> tommd1: no, I've just been extraordinarily busy :-(
14:27:27 <dcoutts> and I was away all weekend, which is when I normally do patch review
14:27:40 <tommd> Got it!
14:27:48 <Cale> what did you patch?
14:28:04 <tommd> Fixed each file so they aren't all called 'tarball'
14:28:34 <tommd> Oh, and package checking.
14:28:59 <tommd> Which was really easy as someone already made the checked for upload but not just for the 'check' feature.
14:29:22 * tommd goes away for class
14:29:44 <byorgey> tommd: oh, yay!
14:30:02 <byorgey> I ran into that problem a couple weeks ago, glad to know someone fixed it =)
14:30:16 <byorgey> tommd++
14:40:38 <djsiegel> Hi, I am getting some crazy threading "user error" when trying to run a gtk2hs program with runhaskell.
14:40:57 <djsiegel> http://paste2.org/p/294952
14:41:23 <dcoutts> djinni: do you understand the message?
14:41:36 <dcoutts> oops
14:41:44 <shachaf> djsiegel: Compiling it would probably make it work.
14:41:46 <dcoutts> djsiegel: ^^
14:41:54 <shachaf> I seem to remember that Gtk2HS didn't work with runghc.
14:41:55 <djsiegel> yes, that made it work, but I am wondering about runhaskell
14:42:01 <djsiegel> oh, ok, too bad
14:42:07 <Cale> runhaskell uses the threaded rts by default
14:42:22 <djsiegel> Cale, is there an option to turn that off?
14:42:28 <Cale> I wonder.
14:42:36 <djsiegel> unsafeInitGUIForThreadedRTS works, but kind of ruins the beauty of my demo code :)
14:42:40 <dcoutts> djsiegel: it's not that it does not work, the crucial thing is whether you're using the single threaded or multi-threaded runtime system
14:43:23 <dcoutts> djsiegel: Gtk+ is a single threaded GUI toolkit and requires special care when used in a mutli-threaded application. Gtk2Hs is helping you to not shoot yourself in the foot.
14:43:49 <djsiegel> dcoutts: hmm, ok
14:44:22 <dcoutts> djsiegel: and as Cale says, ghc, runghc and runhaskell use the threaded rts. When you compile a program, by default you get the single threaded rts. You'd use the -threaded flag to get the multi-threaded one.
14:44:30 <Cale> hmm
14:44:45 <Cale> Is there an opposite flag to -threaded which we could pass to runghc?
14:44:54 <djsiegel> dcoutts: I understand the threaded nature of gtk (enough to write large Gtk apps that don't deadlock), it would be nice to have -unthreaded or something
14:44:56 <byorgey> -yarned
14:45:01 <SamB> Cale: I don't think you can switch out the RTS dynamically
14:45:02 <dcoutts> Cale: no, because ghc is statically linked
14:45:15 <dcoutts> SamB: though you soon will be able to :-)
14:45:34 <dcoutts> djsiegel: compile the program, or use ghci
14:45:36 <SamB> Cale: unless you actualy want it should compile the program and link it?
14:45:55 <Cale> SamB: well, that'd do in this case.
14:46:05 <dcoutts> djsiegel: gtk2hs uses a special hack to detect if it's running under ghci and it lets things slide on the assumption you're not actually using multiple Haskell threads in ghci
14:46:43 <Cale> oh, so that might work for demo purposes
14:46:56 <Cale> Just load it in ghci and type main :)
14:47:00 <djsiegel> dcoutts: ok. I am putting a demo together of writing Gtk apps with seed (js) and gtk2hs, I just hoped I could use runhaskell to give my demo the same interactive feel.
14:47:10 <djsiegel> Yeah, I will echo main | ghci ...
14:47:59 <djsiegel> echo main | ghci gtk2hs.hs
14:48:02 <djsiegel> that does it :)
14:48:10 <djsiegel> time for a shell alias
14:48:37 <shachaf> djsiegel: "ghc World.hs -e Main" also seems to work.
14:49:11 <djsiegel> shachaf: nice, thanks
14:49:22 <sm> sounds interesting
14:49:25 <shachaf> Er, that's "-e main"
14:49:36 <Berengal> I'm starting to become somewhat annoyed by the lack of documentation in haskell...
14:50:12 <dons> Berengal: for specific libraries?
14:50:14 <dons> or the language?
14:50:25 <dons> libraries vary wildly, based on the standards of the author.
14:50:40 <Berengal> dons: Specific libraries. The language itself it amazingly documented
14:50:42 <SamB> well, Haddock needs work too
14:50:52 <dons> best to consult the authors, and demand better docs.
14:51:04 <dons> i'm thinking of writing a revised version of the library QA standards
14:51:20 <dons> seems like an idea of what end users need isn't widely spread.
14:51:23 <Berengal> Not just API docs, but tutorials as well...
14:51:25 <djsiegel> shachaf: "#!/usr/bin/ghc -e main" at the top of the file with +x lets me run it like a script :)
14:51:35 <SamB> and I guess it would be nice to have hackage support non-haddock-based documentation
14:51:39 <dons> Berengal: right.
14:51:58 <sm> yes.. adding more docs support to hackage will motivate package authors
14:52:22 <Berengal> I wouldn't mind writing some tutorials though, but first I need to learn the libraries...
14:52:29 <Chandon> I'm looking for tools to work in a cluster environment, and the projects linked to from haskell.org look abandoned (GpH/GUM, Eden, GdH). Anyone have any suggestions for stuff I should look at? Descendant / similar projects that might be active?
14:52:51 <SamB> might be a pain to get cabal able to build those additional docs, though ...
14:53:09 <dons> Chandon: I'd look on Hackage. You'll be writing skeletons with possibly multicore Haskell code on each node.
14:53:36 <dons> I don't know of any "out of the box" transparently cluster-ready Haskell
14:53:55 <Berengal> I don't think such a thing exists yet
14:54:00 <dons> instead, you'll be e.g. talking the Erlang or Data.Binary wire protocols over tcp or maybe using mpi, to coordinate jobs on each node.
14:54:03 <Cale> I wonder how well using the Erlang library would work.
14:54:11 <dons> of course, on each node you might be using the multicore runtime
14:54:28 <Chandon> dons, That was my initial thought, but then Eden looked so beautiful...
14:54:35 <dons> there's beautiful research
14:55:07 <Berengal> I wouldn't mind someone inventing serializeable closures...
14:55:07 <Cale> http://hackage.haskell.org/package/erlang
14:56:15 <dcoutts> SamB: it'd be great to add markdown support in Cabal for user guides and man pages
14:56:17 <Chandon> Cale, Using the erlang library with haskell on both ends is definitely amusing.
14:56:30 <Cale> :)
14:56:32 <SamB> dcoutts: why markdown in particular?
14:56:40 <sm> ack, could we s/markdown/anything pandoc supports/
14:56:52 <dons> Cale: yeah, may as well use e.g. Data.Binary on both ends :)
14:56:53 <dcoutts> SamB: because it's sane, unlike say docbook or latex
14:57:03 * sm favours rst
14:57:11 * Vq^ too
14:57:13 <dcoutts> pandoc is really an excellent tool
14:57:19 <sm> agreed!
14:57:19 <SamB> dcoutts: I meant there are at least a half dozen similar formats
14:57:35 <SamB> (and I'm not sure pandoc actually supports them all fully)
14:57:47 <Chandon> Berengal, It looks like you can have serialized closures with GUM, as long as you don't mind running GHC 3 and going back in time to the last millenium.
14:57:53 <dcoutts> SamB: right, it supports markdown really well
14:58:06 <SamB> markdown seems awfully limited though
14:58:12 <dcoutts> that's a feature
14:58:18 <dcoutts> like haddock markup
14:58:51 <dcoutts> anything too sophisticated cannot be sensibly translated into multiple formats
14:59:12 <SamB> well, I think the features I noticed missing could easily
14:59:21 <SamB> but I forget what they were, so I couldn't swear to it
14:59:40 <dcoutts> the main thing is that adding support in Cabal has to be near zero configuration
14:59:50 <dcoutts> like you don't have to do lots of config to use .hsc files
15:00:07 <dcoutts> or like how you more or less get haddock support for free
15:00:15 <sm> dcoutts: how would it work ?
15:00:22 <dcoutts> convention
15:00:30 <SamB> dcoutts: conventin?
15:00:32 <dcoutts> that's the hope
15:00:39 <sm> could I tell cabal to scan my tree for files in doc markup formats, covert and link them all together ?
15:00:41 <SamB> I think that's a bad idea
15:00:57 <dcoutts> SamB: it works well for code, why is it bad for docs?
15:01:07 <Igloo> I think it would make sense to have doc sections, like there are library and executable sections
15:01:12 <dcoutts> igel: yep
15:01:14 <dcoutts> oops
15:01:15 <Igloo> (in cabal files)
15:01:16 <sm> or yes, specify in the .cabl
15:01:25 <SamB> dcoutts: well, many of these formats do not have distinguishing extensions or magic numbers ;-P
15:01:27 <sm> like a sphink config file
15:01:28 * dcoutts is falling over tab-completion this evening
15:01:31 <sm> sphinx!
15:01:38 * sm frowns at all keyboards
15:01:57 <dcoutts> Igloo: yes, that's how I imagine it too, but minimum info should have to be given in the .cabal file, like we don't need to give that much for code.
15:01:57 <Igloo> type = markdown, docdir = docs/usermanual, root=mydoc.markdown    or something
15:01:59 <SamB> might also want to support asciidoc...
15:02:42 <dcoutts> establishing a sensible convention is a good way to minimise the amount of info needed in the .cabal file
15:02:58 <SamB> ReStructured Text...
15:02:59 <dcoutts> like we have file extension conventions for haskell files, and the module name matches the file name
15:03:32 <dcoutts> ideally I'd like to just say which is my user manual and which are my reference (man) pages
15:03:40 <SamB> dcoutts: *some* of these formats are explicitly suggested to be in text files
15:03:57 <dcoutts> SamB: which is at the same time a great and an awful idea
15:04:08 <dcoutts> MyHsModuleFoo.txt
15:04:16 <dcoutts> nooo!
15:04:33 <SamB> dcoutts: I think it would be reasonable to expect the .cabal file to say what format a file is in unless it uses a non-.txt extension that is recognized
15:04:33 <pikhq> .txt
15:05:07 <dcoutts> SamB: maybe
15:06:54 <freedrull> whats up
15:07:36 <soupdragon> hi
15:07:52 <yairchu> > 'h':"i"
15:07:54 <lambdabot>   "hi"
15:09:28 <Cale> > replicateM 2 ['a'..'z'] !! 190
15:09:30 <lambdabot>   "hi"
15:09:41 <soupdragon> lol
15:10:47 <soupdragon> > foldr (\x ys -> ((-)`on`ord) x*26+ys) . reverse $ "hi"
15:10:49 <lambdabot>   Couldn't match expected type `GHC.Types.Char -> GHC.Types.Int'
15:10:52 <soupdragon> > foldr (\x ys -> ((-)`on`ord) x*26+ys) 0 . reverse $ "hi"
15:10:53 <lambdabot>   No instance for (GHC.Num.Num (GHC.Types.Char -> GHC.Types.Int))
15:10:53 <lambdabot>    arising ...
15:11:01 <sm> so.. simplest thing that could possibly work ? how about documentation-files: README USERS.rst docs/more-help.md; cabal docs runs pandoc to render each file, auto-detecting markup from suffix
15:11:25 <sm> and.. dump output wherever the haddock files go
15:11:54 <dcoutts> sm: yep, see http://hackage.haskell.org/trac/hackage/ticket/330
15:12:30 <dcoutts> sm: I think at least one wants to distinguish the purpose of the docs, there's a difference between README, AUTHORS, etc docs and a user guide or man pages.
15:12:50 <SamB> dcoutts: I hope you don't plan to format the reStructure Text with pandoc?
15:13:13 <dcoutts> SamB: I understand pandoc doesn't fully support rst
15:13:21 <SamB> yeah
15:13:29 <dcoutts> pitty
15:13:36 <Rotaerk> would you recommend reading a book or is there a web resource I should read instead, to learn haskell
15:13:37 <sm> oh it supports most of it.. not a big deal to polish up
15:13:39 <sm> I use it all the time
15:13:50 <soupdragon> oh my goodness
15:14:12 <SamB> you could *attempt* it if docutils isn't available, at the risk of rather different output
15:14:34 <soupdragon> > [] !! 700
15:14:36 <lambdabot>   * Exception: Prelude.(!!): index too large
15:14:36 <dcoutts> SamB: the key thing is that the doc toolchain be usable, for example not dockbook
15:14:43 <sm> I think it's totally worth using pandoc rather than messing with docutils.. less technology to deal with
15:15:15 <dcoutts> right, pandoc is very attractive because it doesn't require a lot of config
15:15:20 <psl> hi guys
15:15:27 <psl> anyone knows a good beginner tutorial?
15:15:40 <SamB> I don't see how pandoc is any better than docutils in that respect
15:15:53 <SamB> either way, you install the appropriate OS package and go
15:15:55 <Berengal> @where LYAH
15:15:55 <lambdabot> www.learnyouahaskell.com
15:15:58 <SamB> yeah?
15:15:59 <dcoutts> SamB: I'm not familiar with docutils
15:16:02 <sm> docutils gets you rst support
15:16:06 <psl> thx
15:16:11 <dcoutts> docbook is unusable because you can't find out where the right xsl filters are on the system in a portable way
15:16:28 <sm> pandoc gets you markdown, markdown+lhs, moinmoin, moinmoin+lhs, rst, rst+lhs, html, latex, latex+lhs plus whatever haskell hackers want to add
15:16:30 <SamB> dcoutts: hmm, yeah
15:16:32 <kynky> personally i lik yaht (yet another haskell tutorial, the haskell wiki book, and real world haskell(rwh), also i like the 26 xvid haskell uni lectres
15:16:46 <SamB> stupid non-standardization of XML catalogs
15:16:53 <dcoutts> SamB: right
15:16:56 <SamB> as they apply to UNIX
15:17:50 <SamB> I wish Debian would do a manifesto (RFC?) about it...
15:18:42 <SamB> of course ... even besides that, there are two completely distinct sets of stylesheets that could be applicable
15:18:50 <SamB> written in two completely different languages
15:18:56 <SamB> that doesn't make things any simpler
15:19:49 <SamB> (Though at least one of them has the advantage that it would be listed in SGML catalogs, which are perhaps a bit more standard?)
15:20:55 <SamB> (not to mention that that set of stylesheets is written in a *usable* purely-functional programming language)
15:21:00 <VK-kasoperro> Tomalaaaaa http://my-bikini-game.com/?id=4292320 pa fliparlo!
15:21:14 <SamB> @ops
15:21:15 <lambdabot> Maybe you meant: docs oeis pl
15:21:18 <SamB> @where ops
15:21:19 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
15:21:19 <lambdabot> mauke
15:21:23 --- mode: ChanServ set +o dcoutts
15:21:27 --- kick: VK-kasoperro was kicked by dcoutts (dcoutts)
15:21:43 <Elly> thanks, dcoutts
15:21:45 --- mode: ChanServ set -o dcoutts
15:22:32 <sm> dcoutts: your example on #330 seems nice. Although, hard to get the right categories
15:23:10 <dcoutts> sm: do suggest any other categorisations
15:24:18 <sm> does it go by target audience (users-guide) or format (man-page)..
15:24:57 <SamB> sm: manpage is more than a file format
15:25:08 <SamB> it's a format the same way "essay" is a format
15:25:14 <sm> I know, I'm using the word as you say
15:25:20 <sm> since I couldn't think of another :)
15:25:33 <dcoutts> eg "man" pages would be done as html on hackage
15:25:37 <dcoutts> or on Windows
15:25:43 <monochrom> Onoes, \~(p,q) -> blah is a syntax error. It wants \ ~(p,q) -> blah
15:26:04 <SamB> okay, thought maybe you meant nroff source in the 'an' or 'andoc' formats ;-P
15:26:07 <sm> there's type of documentation, as in reference, guide, tutorial, faq...
15:26:08 <dcoutts> on Unix systems they'd be actual man(1) pages
15:26:28 <SamB> a manpage is a type of documentation
15:26:56 <sm> SamB: I meant to include man pages as "reference"
15:27:11 <SamB> yeah
15:27:39 <sm> then there's target audience: user, developer, sometimes admin, and sometimes general
15:28:33 <SamB> "user" might often not apply either
15:28:54 <sm> and I imagine dcoutts doesn't want freeform documentation categories per-package, since standardisation becomes harder
15:31:27 <sm> I think man pages can be figured out from the suffix, we don't need a man-pages category
15:31:47 <sm> and they would usually be placed in reference category
15:34:23 <SamB> sm: um, no they can't
15:34:31 <SamB> not unless you expect us to write them in nroff
15:34:41 <SamB> and I really disrecommend that
15:34:53 <SamB> because it's pretty ugly in either format
15:34:54 <sm> I would. That's the standard I see for traditional man pages everywhere
15:35:08 <SamB> well, I mean, we could have cabal allow that
15:35:16 <dcoutts> generating actual man pages requires two things, knowing that the docs are intended as reference material (with a key word) and be in a format that can be transformed to man format
15:35:17 <sm> to work around that, add some other infrastructure
15:35:37 <dcoutts> I'd like to write my man pages using markdown
15:35:56 <SamB> or asciidoc, or reST ...
15:36:13 <dcoutts> right, anything that can be transformed to man format
15:36:19 <SamB> heck, perldoc
15:36:20 <sm> I think it could work to have general:, user:, admin:, developer: categories. Each containing files in whatever format, including .nroff for man pages
15:36:21 <dcoutts> but starting simply is ok :-)
15:36:46 <SamB> sm: nroff is tricky to get into any other format
15:37:19 <SamB> besides less-bound text, plain text, or postscript, I mean
15:45:30 <sm> ack.. curse all these markups.. I've misformatted another web comment
15:45:57 <sm> http://hackage.haskell.org/trac/hackage/ticket/330#comment:3
15:47:35 <sm> http://hackage.haskell.org/trac/hackage/ticket/330#comment:4
15:50:03 <dons> anyone know how to squash this, Setup: Haddock's internal GHC version must match the configured GHC version
15:51:07 <dons> victory
15:51:42 <Cale> rebuilding haddock :)
15:52:25 <dons> that, and then trying different permutations of things till it goes through
15:53:18 <SamB> maybe haddocks executable name should have the GHC version appended?
15:56:30 <lpsmith> It would be nice if hscolor would produce a useful HTML title.
15:56:50 <lpsmith> instead of "haskell code by hscolor"
15:57:50 <kynky> submit a patch ?
16:01:36 <troutwine> I recently updated network from 2.2.1.1 to 2.2.1.3. Now when I link with GHC I get this linking error: "/usr/bin/ld: cannot find -lHSnetwork-2.2.1.1"
16:01:48 <troutwine> I've run ldconfig. Is there something else I need to do for GHC?
17:05:49 <defun> Hey, can anyone point me to some online text that is good for learning the C language if you're a Haskell programmer. Something along the lines of "C for Haskell Programmers"?
17:06:32 <dons> oh, you're as Haskell programmer that wants to learn C?
17:06:34 <dons> hummm
17:07:00 <defun> yes.
17:07:07 <dons> hmm
17:07:36 <troutwine> defun: Anything wrong with The C Programming Language?
17:08:17 <defun> troutwine: not to my knowledge. Just wanted to see what other haskellers preferred.
17:08:26 <defun> will check it out now.
17:08:48 <troutwine> defun: I don't know that I'd quit label myself as a Haskeller, but it sure is a well written text.
17:09:30 <defun> troutwine: thanks.
17:10:13 <troutwine> defun: Sure. I also suggest "C: A Reference Manual", after the K&R.
17:11:16 <ville> defun: I bet it's easier going from Haskell -> C than the other way.
17:15:25 <troutwine> "C for Haskell Programmers" would be an interesting exercise. It does seem like there's a lot of intuitive context that you can cart from Haskell to C.
17:16:05 <ville> I'd imagine the audience to be rather small though.
17:16:27 <dsturnbull> one of the main things i learned when looking at haskell is that safety is king
17:16:30 <dsturnbull> hence distaste for C
17:17:39 <sm> I dunno, I think a series of "How to write like a Haskeller in X" would be quite useful
17:17:59 <troutwine> dsturnbull: Indeed and, yet, C is always there; waiting and lurking in the shadowy recesses of our computers.
17:18:04 <Cale> "All C functions are really as if they are in the ContT r IO monad, but there is no equivalent of callCC. Instead, you apply the continuation to a value using return, which is a keyword and not a first class function."
17:18:55 <monochrom> There is some setjmp longjmp trick to exploit it.
17:19:02 <mmorrow> gcc at least'll use jmps if all your return types are void and you just nevar return ;)
17:19:23 <dsturnbull> anyone know of any sort of OS written in a safe language?
17:19:54 <dibblego> dsturnbull, there is House
17:19:56 <troutwine> I seem to recall the House project being done up in Haskell.
17:19:56 <monochrom> Singularity
17:19:57 <thoughtpolice> galois has systems written in haskell, house has been written in haskell, etc.
17:20:05 <kynky> singularity (OS)
17:20:07 <Cale> Oh, and every function acts like it's been wrapped in callCC itself
17:20:13 <mmorrow> dsturnbull: http://web.cecs.pdx.edu/~kennyg/house/
17:20:31 <dsturnbull> ah yes, i remember dicking around with house before
17:20:34 <mmorrow> dsturnbull: but then, the C rts just essentially becomes the os
17:21:34 <mmorrow> dsturnbull: bitc is a neat idea
17:21:57 <mmorrow> http://www.bitc-lang.org/
17:23:28 <dsturnbull> too esoteric perhaps
17:23:49 <mmorrow> what is?
17:24:07 <dsturnbull> the above :)
17:24:55 <dsturnbull> i'd be interested to see standard tools rewritten
17:25:18 <mmorrow> i'm interested in writing new tools :)
17:25:45 <dsturnbull> oh me too, i implied someone else doing the work
17:25:46 <dsturnbull> haha
17:42:55 <stevan> there is the hasp project also
17:45:01 <nooga> i accidentaly the whole thing
17:46:41 <nooga> > :t 5
17:46:44 <lambdabot>   <no location info>: parse error on input `:'
17:46:53 <nooga> > let n = pi in foldl (+) 0 [y*n**x/(product[1..x]) | (x,y) <- zip [1,3..] (cycle [1,-1])]
17:46:58 <lambdabot>   mueval-core: Prelude.read: no parse
17:46:58 <lambdabot>  mueval: ExitFailure 1
17:47:13 <nooga> > let n = pi in foldl (+) 0 take 5 [y*n**x/(product[1..x]) | (x,y) <- zip [1,3..] (cycle [1,-1])]
17:47:14 <lambdabot>   Couldn't match expected type `[a]'
17:47:32 <nooga> ;C
17:57:17 <ski> > let n = pi in (foldl (+) 0 . take 5) [y*n**x/(product[1..x]) | (x,y) <- zip [1,3..] (cycle [1,-1])]  -- nooga ?
17:57:18 <lambdabot>   6.925270707505135e-3
17:57:35 <nooga> ah yes
17:57:50 <nooga> forgot .
17:58:10 <ski>   let n = pi in foldl (+) 0 (take 5 [y*n**x/(product[1..x]) | (x,y) <- zip [1,3..] (cycle [1,-1])])
17:58:14 <ski> would work as well
17:58:36 <ski> (possibly using `$' if you prefer)
18:04:25 <EvilTerran> writing `zip` infix would let you eliminate the parens around (cycle [1,-1]) - and you don't need the ones around product[1..x] anyway
18:04:48 * EvilTerran is an obsessive eliminator of parentheses which don't clarify
18:19:38 <conal> can anyone suggest some haskell code (preferably on hackage) that loads & uses OpenGL textures?
18:20:00 <gwern> what would those look like opengl?
18:26:18 <gwern> conal: offhand, maybe frag uses opengl textures? I'm sure it uses opengl, and I think it uses some sort of texture for the level's walls and surfaces
18:27:37 <conal> gwern: i'll check it out.  thanks.
18:33:34 <nooga> ski: i'm total noob in functional world
18:33:47 <lispy> conal: nehe-tuts
18:33:58 <conal> lispy: thx
18:33:58 <lispy> conal: there is a really simple example in one of the lessons
18:34:30 <conal> sweet!
18:35:14 <conal> i get lost pretty quickly in opengl details.
18:36:57 <lispy> conal: I don't recall if tehy made it to hackage, but I have a darcs repo of them on my server if you can't find them
18:37:09 <dsturnbull> frag?
18:37:37 <conal> lispy: i don't see tehy on hackage.  what is it?
18:37:42 <jmcarthur> dsturnbull: a quake clone
18:37:49 <dsturnbull> yeah i know
18:37:52 <dsturnbull> it's in cabal
18:38:09 <jmcarthur> conal: maybe on github?
18:38:14 <dsturnbull> segfaults on osx though
18:38:27 <zoheb> I am running ghci 6.10.2 on Vista and I cant use the emacs editline shortcuts
18:38:29 <jmcarthur> i think i saw haskell version of nehe on github before
18:38:34 <zoheb> liek Ctrl+R etc
18:38:50 <jmcarthur> conal: looks like i'm wrong
18:38:59 <zoheb> Is this not supported on Windows?
18:39:14 <jmcarthur> @hackage nehe-tuts
18:39:14 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/nehe-tuts
18:39:18 <jmcarthur> conal: ^^
18:39:27 <conal> lispy: oh!  tehy == "they".
18:39:41 <Axman6> @hackage iDontExistSadFace
18:39:41 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/iDontExistSadFace
18:40:09 <conal> lispy: yeah.  nehe-tuts is on hackage.  i'm playing with the examples now.  thanks a bunch.
18:41:08 <aavogt> @hackage iCantBelieveThisIsntAPackage
18:41:09 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/iCantBelieveThisIsntAPackage
18:42:01 <lispy> conal: np, I made those when I was learning Haskell by translating the official nehe tutorials, I'm glad you find them handy :)
18:42:02 <idnar> @hackage ICantBelieveItsNotHaskell
18:42:02 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/ICantBelieveItsNotHaskell
18:43:59 <conal> lispy: very handy!  opengl drives me batshit.  i don't know where to start guessing how various bits of state are to get strung together.
18:44:37 <lispy> conal: yeas, I fully agree. That's why I want a data driving rendering like a scene graph :)
18:46:14 <vyom> where can I find documentation for all the top level Haskell functions like odd, compare, head etc..?
18:46:32 <SamB> @where report
18:46:32 <lambdabot> http://www.haskell.org/onlinereport/
18:46:36 <SamB> vyom: there
18:47:03 <conal> is there a library that loads various image file formats into an opengl-friendly representation?
18:47:06 <SamB> vyom: or you could try using hoogle to find some
18:47:28 <vyom> SamB: Thanks
18:47:38 <lispy> conal: the SDL likely does that
18:47:53 <conal> lispy: :)  i'll look.  thx again.
18:48:50 <gwern> incidentally, anyone on ubuntu? my system has begun to error out on all compiles when it can't find -lgmp; I assume that an upgrade of the gmp libs caused this, but I am unsure whether recompiling/installing ghc will solve it
18:50:28 <lispy> a friend of mine just complained about this
18:50:34 <lispy> he had to install libgmp-dev
18:51:01 <zoheb> Its fixed in 6.10.3
18:51:23 <gwern> hm. libgmp-dev? not a deb package I take it
18:51:42 <lispy> gwern: it was a deb, maybe I got the name wrong, but it was the -dev version of gmp
18:51:46 <gwern> libgmp3-dev?
18:52:21 <conal> looks good also for image format conversion: http://hackage.haskell.org/package/Codec-Image-DevIL
18:52:35 <SamB> so did kaol forget to depend on that package ?
18:52:36 <gwern> lispy: yeah, that seemed to fix it
18:52:47 * gwern was hoping the solution would be that easy
18:52:50 <SamB> gwern: what was the package name exactly?
18:52:56 <gwern> SamB: the latter
18:53:28 <SamB> @tell kaol ghc apparently needs to depend on libgmp3-dev, says gwern
18:53:29 <lambdabot> Consider it noted.
18:59:02 <aavogt> can I use atomicModifyIORef everywhere would use readIORef, writeIORef?
18:59:19 <aavogt> or does it risk raising the nestedatomically exception?
18:59:55 <mmorrow> aavogt: the function that atomicModifyIORef takes isn't in IO, so you can't nest it
19:00:48 <aavogt> but atomically $ atomicModifyIORef ... -- this isn't safe?
19:01:23 <mmorrow> atomically is for STM
19:01:38 <mmorrow> which is a different kind of atomically
19:02:21 <mmorrow> (atomicModifyIORef is the atomic machine instruction kind, STM is the transaction-log-software-checks-to-see-if-anything-was-modified-if-so-reverts-memory-restarts-stuff)
19:04:46 <aavogt> I see, thanks
19:06:35 <mmorrow> aavogt: and STM can't allow IO to happen inside of the STM monad, or else you could pop the containing bubble, and let all the inconsistent-intermediate-state-info leak out with a `print'
19:07:49 <mmorrow> (because it really just provides the /illusion/ of atomicity, which is indistinguishable from that reality as long as nothing can leak out)
19:07:56 <aavogt> @type atomicModifyIORef
19:07:58 <lambdabot> Not in scope: `atomicModifyIORef'
19:08:09 <aavogt> @type Data.IORef.atomicModifyIORef
19:08:10 <lambdabot> forall a b. GHC.IOBase.IORef a -> (a -> (a, b)) -> IO b
19:08:16 <mmorrow> @type atomically
19:08:17 <lambdabot> Not in scope: `atomically'
19:08:35 <mmorrow> STM a -> IO a
19:09:58 <mmorrow> once you call `atomically' on the arbitrarily large STM action you've built, it's the end of the line
19:10:14 <aavogt> so the name atomic for the ioref function has nothing to do with STM
19:10:20 <mmorrow> exactly
19:11:32 <mmorrow> but they're related of course in the sense that they both serve the same purpose, just at different levels
19:11:57 <mmorrow> you could implement STM with atomicModifyIORef probably
19:12:04 <mmorrow> but not vice-versa
19:12:23 <mmorrow> (well, probably vice-versa, but you'd need to be implem by it first :) or something)
19:12:59 <aavogt> for NHC and hugs, the implementation of atomicModifyIORef doesn't seem to be a primitive
19:13:04 <aavogt> http://haskell.org/ghc/docs/6.10-latest/html/libraries/base/src/Data-IORef.html
19:18:54 <mmorrow> aavogt: i think you only need atomic machine instructions if you're concurrent/parallel
19:30:12 <drhodes> anyone witness type classes sneak into another language?
19:30:31 <SamB> drhodes: well, they didn't exactly *sneak* into Coq
19:30:37 <SamB> but they are there, after a fashion
19:31:32 <drhodes> hmmm, I should've qualified, a imperative language
19:31:49 <monochrom> the theorem prover Isabelle has typeclass.
19:31:59 * sm chuckles.. I love Gilad Bracha. http://gbracha.blogspot.com/2009/06/ban-on-imports.html
19:32:40 <SamB> monochrom: that's not imperative either ;-P
19:34:52 <monochrom> Some people may still like to know.
19:35:00 <Nafai> sm: That does make parameterized modules interesting though
19:35:34 <monochrom> The blogger promises even more interesting things in a later article.
19:36:00 <sm> I agree! Hopefully we have People working on the problem
19:36:54 <sm> if it wasn't clear, I'm a big fan of newspeak
19:37:18 <monochrom> I seldom read newspaper.  <duck>
19:38:08 <SamB> sm: you mean doublespeak, curtesy of the ministry of truth?
19:38:16 <Nafai> sm: I haven't looked closely enough at newspeak yet
19:38:43 * QtPlaty[HireMe] reads the blog "I don't like the 'Lets have the IDE solve it' statement near the end"
19:38:51 * sm means http://newspeaklanguage.org 
19:39:03 * SamB apologizes for not having read 1984 recently enough to get his terminology right
19:39:29 * sm remembers that was a scary book
19:39:42 * mmorrow just remember the rat facemask
19:39:45 <mmorrow> s
19:41:58 <hackagebot> Omega 0.1.3 - Operations on Presburger arithmetic formulae (ChristopherRodrigues)
19:42:29 <SamB> sm: yeah, and it only gets scarier as time goes on!
19:45:25 <monochrom> A group of language researchers really loved 1984 and decided to name their stuff "orwell", "newspeak", etc.
19:46:09 <SamB> monochrom: that was stupid
19:46:13 <SamB> the newspeak, I mean
19:46:14 <monochrom> Most every laptop comes with a webcam now.  <duck>
19:46:26 <Saizan> naming your language newspeak is not good PR, imo
19:46:33 <SamB> monochrom: fortunately most people have whiteout
19:46:52 <SamB> so even if they think others might have control over those things, they have a recourse
19:47:13 <monochrom> What is whiteout?
19:47:42 <SamB> monochrom: comes in a bottle
19:47:47 <SamB> with a brush
19:47:56 <SamB> you use it to cover over your mistakes on paper forms
19:48:00 <monochrom> Oh, correction fluid.
19:48:16 <PhDP> It seems there is very little interest in using the Qt toolkit with Haskell and that Gtk was preferred, is there a good reason ? (I don't know much about toolkits but Qt seems like a good toolkit and a friend of mine has completely sold his soul to C++/Qt in the Qt-Gtk "war")
19:48:25 <sm> smalltalk -> newspeak
19:48:47 <SamB> PhDP: not really a good reason, just it's a pain to FFI between Haskell and C++
19:49:25 <monochrom> I have a Pentel bottle of correction fluid without brush. A dispensing tip instead.
19:50:45 <monochrom> Inside there is a metal ball to help you stir the fluid. You shake and it stirs.
19:55:59 <PhDP> SamB: I have a pretty big project with this friend, and we've decided to do an important part in Haskell, but he still wants the GUI in Qt, and the binding between Qt and Haskell are too old (and they looked unsupported). His plan is to write a part in Haskell (the engines of the program if you like, where all the maths/logic is done), build a GUI in Qt, and run the two in parallel... in short an executable would be written in Haskell and would c
19:56:33 <SamB> ... in short an executable would be written in Haskell and would
19:57:11 <meder> does anyone know the first language to implement namespaces
19:58:13 <monochrom> I first heard of namespace from C++.
19:58:23 <PhDP> Well the "engines" are written in haskell, the client in Qt, the Haskell part receive arguments from the client and send back the result. Two programs are running in parallel.
19:58:48 <diapir> Can't you just stick to a C interface ?
19:59:34 <bremner> meder: namespaces are surely much older than C++. What precisely do you mean? Perl modules for example are pretty similar.
20:00:03 <meder> bremner: i just want to know the earliest date of an implementation of: late static binding and namespaces
20:00:35 <bremner> meder: not sure what late static binding is.
20:01:09 <meder> a way in which you can reference the called class in the context of static inheritance
20:13:43 <meder> hm
20:13:58 <moosm> hello
20:14:03 <moosm> hiii
20:14:17 <moosm> is this for programming
20:14:19 <moosm> software
20:14:23 <moosm> any help
20:15:22 <copumpkin> moosm: not unless you want help with haskell
20:16:40 <raxas> meder: forth had token dictionaries, which practically served as context namespaces
20:19:49 * gwern sighs. this gitit upgrade is going to break so much
20:20:28 <gwern> (I like categories more than most, but sometimes I wish I didn't have to be on the bleeding edge to help push development forward)
20:26:06 <Sarajevo> got bored of coding and being horny ? join ##webcam and have fun
20:26:16 <alexsura1i> lol.
20:27:13 <gwern> but if I'm bored of being horny, that channel doesn't sound very interesting
20:27:45 <bremner> gwern: well, I have heard category theory described as mental masturbation...
20:27:53 <SamB> gwern: presumably that channel is designed to get you un-horny so you can go back to coding
20:27:56 <gwern> @quote masturbation
20:27:56 <lambdabot> No quotes match. Your mind just hasn't been the same since the electro-shock, has it?
20:28:03 <gwern> bremner: lies! you heard nothing
20:28:03 <SamB> @quote mastur
20:28:03 <lambdabot> Philippa says:  in this case using the FFI sounds rather like masturbating with a running chainsaw
20:28:17 <SamB> @quote mastur
20:28:17 <lambdabot> Philippa says:  in this case using the FFI sounds rather like masturbating with a running chainsaw
20:28:17 <bremner> yikes
20:28:35 <gwern> she must've been talking about binding to c++
20:28:45 <soupdragon> @quote obey your mastur
20:28:45 <lambdabot> No quotes for this person. I feel much better now.
20:28:56 <gwern> soupdragon: you can't have spaces liek that
20:29:06 <gwern> @quote obey.your
20:29:06 <lambdabot> No quotes match. Do you think like you type?
20:29:10 <gwern> @quote obey.*your
20:29:10 <lambdabot> No quotes match. My mind is going. I can feel it.
20:29:21 <gwern> and it didn't match anything anyway
20:30:03 <monochrom> ##webcam is Big Brother's channel for watching you.
20:30:38 <SamB> in #git the said it was #webcam
20:36:13 <Vortex> j,sdhfgsjkldgfsldfjkgdf
20:40:47 <gwern> interesting. seems ubuntu messed with -lpcre too
20:41:18 <SamB> gwern: gwern hmm?
20:41:30 <gwern> gitit failed with that
20:41:42 <SamB> with what?
20:41:49 <gwern> I installed the respective *3*-dev package and seems to be linking
20:44:31 <SamB> gwern: it's perfectly normal for the .so symlink to only be provided by the -dev version of the package, fwiw
20:44:45 <SamB> also, I also have:
20:44:52 <SamB> libpcre3-dev: /usr/lib/libpcre.so
20:45:19 <bremner> iirc that is debian policy, which ubuntu follows sometimes by mistake
20:45:30 <SamB> bremner: by mistake?
20:45:38 <SamB> I thought it was to keep the delta down
20:46:07 <SamB> they don't like gratuitous differences between Debian and Ubuntu
20:46:18 <SamB> it makes for more work all around
20:46:31 <SamB> -- especially for them ;-)
20:47:15 <gwern> @quote mistake
20:47:15 <lambdabot> DavidWheeler says: Compatibility means deliberately repeating other people's mistakes.
20:47:41 <SamB> I'm pretty sure the idea of Ubuntu is *not* that Debian made a lot of mistakes
20:47:46 <Cale> Haha, I was reading some slides by SPJ and found the quote "Haskell users react to new features like hyenas react to red meat"
20:48:24 <SamB> Cale: laugh at 'em?
20:48:51 <Cale> It was followed by "Lesson: avoid success at all costs"
20:49:26 <SamB> too bad we fail at fail
20:49:55 <inimino> @quote fail
20:49:55 <lambdabot> Philippa says: < ihope> data Badger = Badger Badger Badger | Mushroom < Philippa> Pattern match failure: Snake!
20:50:15 <gwern> @quote fail.*fail
20:50:15 <lambdabot> No quotes match. I can't hear you -- I'm using the scrambler.
20:50:21 <SamB> @quote fail.*
20:50:21 <lambdabot> dons says: hugs should spot the blackhole, or fail gracefully
20:50:38 <gwern> I was sure we had a quote about the typeclass function fail being fail
20:50:52 <gwern> @hoogle fail
20:50:53 <lambdabot> Prelude fail :: Monad m => String -> m a
20:50:53 <lambdabot> Control.Monad fail :: Monad m => String -> m a
20:50:53 <lambdabot> Control.Monad.Instances fail :: Monad m => String -> m a
20:50:58 <aavogt> > fix fail
20:50:59 <lambdabot>   ""
20:51:40 <Saizan> hah
20:52:24 <gwern> @remember byorgey Monad's fail is fail
20:52:24 <lambdabot> I will never forget.
20:54:54 <aavogt> @vixen you forgot before?
20:54:54 <lambdabot> i'll hafta plead the fifth on that one.
20:56:38 <dibblego> I was in a court once, defending myself (I won), and some guy tried to "plead the fifth" but the magistrate told him he was in the wrong country
20:57:12 <SamB> aavogt: she forgot if she forgot
20:57:14 <monochrom> hyenas are "large and strong, but cowardly".
20:57:39 <SamB> dibblego: in australia, you say?
20:57:46 <SamB> that's pretty silly
20:57:47 <dibblego> yes
20:57:59 <dibblego> I don't think he was the brightest bulb in the box
20:58:37 <SamB> hmm, and I thought lightbulbs came in boxes of equal brightness
20:58:52 <dibblego> there are duds
20:59:05 <SamB> those actually work?
20:59:37 <gwern> dibblego: reminds me of stephenson's in the beginning was the commandline, when he mentions that starsky & hutch trained people all over the world to ask for their miranda rights
21:00:57 <SamB> gwern: but I thought the miranda rights were all owned by that one company?
21:01:12 <gwern> they were licensed out on RAND terms
21:01:21 <aavogt> random?
21:01:49 <gwern> return 4; // guaranteed chosen by fair roll of dice
21:02:11 * SamB loves that joke
21:02:40 <QtPlaty[HireMe]> Reasonable and Non Discrimitory
21:03:01 <inimino> non-discriminatory
21:03:17 <aavogt> hey, even your PRNG is deterministic
21:03:21 <SamB> what does that mean?
21:03:34 <QtPlaty[HireMe]> Which oddly enought tends to discriminate against FOSS.
21:03:40 <SamB> aavogt: that's usual
21:03:42 <gwern> QtPlaty[HireMe]: fancy that
21:04:09 <Meady> guys what programs have you made from haskell, just wondering wether its worth learning as im not interested in math based programming
21:04:15 <Meady> Sockets is my main interest
21:04:18 <gwern> @hackage
21:04:18 <lambdabot> http://hackage.haskell.org
21:04:33 <SamB> Meady: eh? well, we could lie and say that Haskell wasn't based on lots of mathematics
21:04:37 <gwern> ^ you want to know? look at the package list
21:04:47 <SamB> or we could just tell you that mathematics isn't what you think it is
21:04:56 <aavogt> prepare your math sockets
21:05:03 <dibblego> or programming
21:05:16 <gwern> everything is mathematics. the truth, neo, is that there is no spoon; there is only a topological distortion of a sphere
21:05:22 * QtPlaty[HireMe] has been contracted to write a compiler in haskell.
21:05:25 <SamB> lol
21:05:31 <copumpkin> QtPlaty[HireMe]: nice, for what language?
21:05:39 <gwern> QtPlaty[HireMe]: if you've been contracted, then why the nick?
21:05:50 <SamB> gwern: dangit, I was just gonna ask that!
21:05:51 <pstickne> (always looking to upgrade?)
21:05:54 <pikhq> Meady: Programming in general is very heavily math based.
21:06:07 <pstickne> pikhq:  it /really/ depends on what is being programmed
21:06:15 <pikhq> (to the extent that some consider computer science a subfield of applied mathematics)
21:06:17 <SamB> thankfully, matha actually has very little to do with numbers
21:06:18 <copumpkin> Meady: I just want to program, life doesn't interest me
21:06:41 <SamB> copumpkin: eh?
21:06:49 <SamB> copumpkin: you can't program if you're dead!
21:06:59 <copumpkin> I was trying to be ridiculous :)
21:07:05 <SamB> at least, not in hell you can't
21:07:07 <pstickne> SamB:  but at that point, nothing matters anyway -- double win
21:07:16 <SamB> that is, your programs will not *work* in hell
21:07:18 <QtPlaty[HireMe]> gwern: Because it was for a DSL and has been done now.
21:07:39 <gwern> well, if life doesn't interest you, there are all the other CAs
21:07:50 <SamB> gwern: I think he meant RL
21:07:54 <gwern> I think the minimal turing-complete problem for one of them is still open
21:08:06 <SamB> you know, where little simons come from?
21:08:24 <gwern> SamB: surely the current simon just divides
21:08:29 <gwern> that's much more efficient
21:08:35 <copumpkin> gwern: I was pointing out that it seems a bit silly to want programming "without math"
21:08:47 <SamB> gwern: we have *two* of them already, at least
21:08:51 <copumpkin> but I guess it depends on what you define as math
21:09:09 <SamB> gwern: and you know people suck at asexual reproduction
21:09:12 <gwern> SamB: so we could have 4 with the next generation! simons o(n^2)
21:09:39 <SamB> and apparantly the last time SPJ reproduced he got a Sarah
21:09:53 <SamB> so sexual reproduction isn't that reliable either
21:10:08 <gwern> with sexual reproduction, though, it's at best n^2/2
21:10:16 <gwern> assuming females are a free resource
21:10:45 <gwern> but since simons will make up an increasing fraction of a presumably constant global resource, we could expect simon growth to instead be more O(log n)
21:10:46 <SamB> gwern: are you sure you worked that out correctly?
21:11:19 <SamB> I guess there's always name-change forms...
21:11:52 <gwern> but with asexual reproduction, the females aren't an issue and the simons could grow at n^2 until they hit the earth's carrying capacity. but that's a low enough bound it may not make a huge difference
21:12:26 <gwern> hm hm. but this is all intellectual wankery; with a base of 2, it doesn't much matter what the right big-o is
21:12:54 <SamB> and you never did say what n is
21:13:29 <SamB> also, we only need a few simons at a time
21:13:40 <SamB> 2 seems ot be sufficient, though 3 might be better
21:13:54 <SamB> not sure if 4 wouldn't just leave them stepping on eachothers toes
21:14:09 <gwern> I'm sure they could sort themselves out
21:14:21 <Saizan> SamB: use STM for optimistic concurrency!
21:14:21 <gwern> even if 4 was too many, the others could just depart for scheme
21:14:43 <gwern> Saizan: but darcs doesn't give us atomicity on the ghc source tree!
21:15:03 <gwern> it's not like scheme couldn't use the help, and what's good for FP langs is good for haskell
21:15:07 <Saizan> ah, too bad, one simon could work on darcs then
21:15:50 <gwern> and one on xmonad, and so on. we could soak up plenty of simons
21:30:42 <Meady> i woudltn say python for example was very mathmatics based
21:31:03 <soupdragon> python is based on misconceptions
21:31:09 <soupdragon> :P sorry I'm just kidding
21:31:19 <dsturnbull> haha
21:31:30 <Meady> But can you see my point
21:32:01 <Meady> if i wasnt interested in Math and maybe a bit more interested in Network communication, which i understand is heavy maths
21:32:19 <QtPlaty[HireMe]> All programing languages are mathbased.
21:32:41 <Meady> I know
21:32:52 <Meady> But python is closer to writing structured english
21:33:09 <Saizan> some are made by people who don't want to think mathematically, "don't analyze the problem, just slap together hacks until it works"
21:33:28 <copumpkin> *cough* python *cough*
21:33:34 <monochrom> COBOL
21:33:43 <inimino> law
21:33:52 <Meady> Meh you can dislike other languages, but not deny there use
21:33:57 <QtPlaty[HireMe]> Saizan: I thought that PHP is more in that class then python though.
21:34:40 <monochrom> You are deducing from "millions of flies like shit" to "therefore shit has merits".
21:34:43 <copumpkin> Meady: no one's denying their use, but argumentum ad populum is a fallcay :)
21:34:46 <copumpkin> fallacy, even
21:35:12 <copumpkin> Meady: millions of people use AT&T because they have no better option or know no better :)
21:35:17 <monochrom> The fact is people tolerate a lot of horrible things just because they can.
21:35:20 <Cale> Meady: You should try the GHC network library
21:35:38 <Meady> I will do
21:36:02 <Cale> You might find that it's not so bad, now that you can do basic I/O stuff... there's a tutorial about writing an IRC bot which should get you started too.
21:36:39 <Meady> and whats threading like in Haskell
21:36:43 <monochrom> Most programmers actually care more about their families than doing things ideally in their jobs. It's just a job. Obey, get money, retire. Why voice an opinion at all? Why oppose anything?
21:37:24 <Cale> Oh, threading is lovely.
21:37:32 <copumpkin> Meady: it's one of the main selling points :)
21:37:59 <Cale> First of all, you have  forkIO :: IO () -> IO ThreadId
21:38:10 <Saizan> QtPlaty[HireMe]: probably yes, python seeks its own elengance, but GvR saying it can't understand reduce unless the operation is associative, and then mentioning only basic arithmentic operations as the associative one he can think of makes me doubt his ability to abstract. though i know i can't judge just from that
21:38:30 * QtPlaty[HireMe] nods.
21:38:42 <Cale> Which gives an action for constructing a new lightweight thread which runs the action you passed it.
21:38:43 <copumpkin> my opinion of GvR seems to go down with every new blog post of his I read
21:38:52 <copumpkin> maybe I'm just becoming more critical though
21:38:57 <copumpkin> (or an asshole)
21:39:07 <Cale> so...
21:39:21 <Cale> Prelude Control.Concurrent> forkIO (putStr "hello") >> putStrLn "goodbye"
21:39:21 <Cale> gohoedlblyoe
21:39:31 <QtPlaty[HireMe]> Saizan: Though I suspect that part of that is to reduce the cognative load on programers.  Which seems to be a big part of python's philosphy.
21:39:36 <Meady> Cale i see
21:39:47 <Meady> So i could keep my calcs and io seperate?
21:40:08 <copumpkin> QtPlaty[HireMe]: I love the example of stackless python with mutually recursive ping and pong functions that crash due to the lack of TCO, and how much extra work you need to do in stackless to make that simple example work
21:40:13 <copumpkin> due to TCO being "unpythonic"
21:40:37 <Saizan> QtPlaty[HireMe]: that seems to go toward "think less" to me
21:40:50 <Cale> Meady: Well, yes, but if you're doing pure computations and you want them to occur in parallel with other things, there's an even easier to use way.
21:41:31 <Cale> Meady: The expression  par x y  when evaluated, will add x to a queue of things which may be evaluated if there is time before they are needed, before resulting in y
21:41:45 <QtPlaty[HireMe]> Yeah.  TCO being unpythonic seemed ... stupid.
21:41:57 <SamB> copumpkin: well, you have to admit it plays bloody hell with your stack traces
21:42:19 <Cale> and then together with pseq x y, which evaluates x before resulting in y, you can inform the compiler how you'd like to evaluate pure expressions in parallel
21:42:20 <soupdragon> Actually I applaud not adding TCO
21:42:22 <copumpkin> I mean, I can see why he doesn't want it, but throwing up your hands in defeat and saying "this is not the way we do things, period" vs. "let's devise a good way to make this work"
21:42:27 <lpsmith> I've never found stack traces to be particularly useful for debugging though.  I guess others think differently
21:42:48 <monochrom> Some people are really afraid of the computer changing your O(n)-memory code to O(1)-memory.
21:42:48 <soupdragon> maybe not the best channel for language design issue though..
21:42:54 <Cale> The advantage of this way is that it's easy enough to be sure that it's not going to affect the actual result of the program
21:42:58 <Cale> only the performance of it
21:43:30 <QtPlaty[HireMe]> lpsmith: I like stack traces for debugging strict langagues.
21:43:31 <Cale> It can be very hard to figure out all the interactions of a properly concurrent program where multiple threads are changing and doing things
21:43:47 <Cale> So this just gives you the parallelism without the concurrency
21:43:55 <lpsmith> monochrom:  but TCO is an optimization that's easy to see where it's applied or not,  with 100% accuracy.  It's not an optimization that takes much thought
21:44:12 <SamB> monochrom: well, if you're going ot lose all that who-called-whom information, and the variables in each place ...
21:44:16 <monochrom> Therefore I attribute it to fear.
21:45:31 <Cale> Meady: but then for really concurrent programs like network servers, for instance, which have to do multiple concurrent threads of I/O, that's where forkIO comes in
21:45:34 <SamB> as a bzr user, I use stack traces to figure out where to file bugs ;-)
21:45:57 <Cale> Meady: and we have some really good answers for how concurrent threads might communicate safely
21:45:58 <lpsmith> ugh,  I'm sorry you use bzr ;-)
21:46:24 <SamB> well, actually, usually I just report them to jelmer ...
21:46:42 <SamB> ... because it's usually something he missed in bzr-svn
21:47:16 <Cale> Meady: there's a transactional memory system, which gives you mutable variables, but they're transactional, so you can wrap up chunks of code which manipulate them and have them run as if the rest of the world was stopped while they're running (even though that's not actually what's going on)
21:47:17 <SamB> lpsmith: hey, the UI is better than git's
21:47:32 <troutwine> Can someone quickly show me how to apply HXT's readString over an [XmlTree]? Following the practical examples in the wiki I can do one XmlTree well enough, but not a list.
21:47:41 <SamB> and the semantics of bzr-svn are WAY better than those of git-svn
21:47:45 <troutwine> I don't understand arrows properly, unfortunately.
21:48:14 <troutwine> Or not so quickly, actually. I'm not really sure why I added that stipulation.
21:48:42 <Cale> troutwine: er, doesn't readString give you an arrow that ignores its input and produces a big single XmlTree?
21:48:51 <SamB> troutwine: maybe you wanted to imply that you didn't want to use much of their time ;-)
21:49:18 <monochrom> readString is not applied to an XmlTree to begin with.
21:49:20 <Cale> Oh, perhaps you want  [IOStateArrow s b XmlTree] -> IOStateArrow s b [XmlTree] ?
21:49:52 <troutwine> Cale: Perhaps? To me HXT is a big monster full of unknowns, currently.
21:49:57 <Cale> okay
21:50:16 <SamB> Cale: that's a really ugly type :-(
21:50:22 <Cale> SamB: indeed it is
21:50:28 <SamB> those IOs, I mean
21:50:44 <Cale> troutwine: would you like to process all the documents as if they were one big one?
21:51:03 <monochrom> I disagree that it's an ugly type.
21:51:25 <soupdragon> [IOStateArrow s b XmlTree] -> IOStateArrow s b [XmlTree]  is sequence ?
21:52:31 <Cale> soupdragon: Yeah, sort of a generalisation of sequence
21:52:38 <troutwine> Cale: No. Well, maybe. I've currently the idea of processing them, taking the resulting list of data types and merging them according to business logics.
21:54:19 <Cale> troutwine: if you want to process them individually, you could just do a forM/mapM over the list of documents, where the body of that thing is runX (...)
21:55:05 <troutwine> Cale: Oh, damnit, indeed I could. What would be the result of treating the documents as a big, single one?
21:55:16 <Cale> forM documents $ \doc -> runX (readString attrs doc >>> ...)
21:56:01 <Cale> Well... your operations which are nondeterministic would search through all the documents at once to find results
21:56:15 <Cale> so I guess it would be very much like this
21:56:29 <Cale> only you end up with concat of what this forM thing is going to give you
21:56:40 <Cale> To do that, you'd write something like...
21:57:40 <Cale> runX (catA [readDocument attrs doc | doc <- documents] >>> ...)
21:58:00 <Cale> which would basically run the remainder of the transformation on all the documents and collect up the results
21:59:12 <Cale> So you'd end up with one big list of results, with not necessarily a way to tell which document they came from.
21:59:25 <Cale> (though you could always throw that in too...)
22:00:06 <troutwine> That's... hmm. I need to read up on Arrows and HXT more. A lot more.
22:00:26 <troutwine> Cale: Thanks so much for the code samples and food for thought.
22:05:49 <jleedev> riddle me this: "unsafeCoerce True :: Maybe a" crashes ghc 6.8 but prints "Just ()" in 6.10
22:07:47 <soupdragon> 6.10 is more stable :)
22:08:18 <SamB> jleedev: I bet it's just UB
22:08:23 <pikhq> Clearly, True's value depends on the state of the universe at the creation of the version of the Haskell implementation you're using.
22:08:24 <jleedev> UB?
22:08:30 <SamB> undefined behaviour
22:08:35 <jleedev> of course it's undefined.
22:08:40 <pikhq> Nastily physical things, these universes.
22:09:17 <SamB> and maybe 6.10 came up with a different type to actually treat it as
22:09:41 <SamB> that is, Maybe () vs. something where the field value came into play
22:09:56 <jleedev> that makes sense
22:09:58 <troutwine> pikhq: Does the uncompiles source of GHC have the Haskell nature?
22:10:08 <SamB> jleedev: I betcha "unsafeCoerce False :: Maybe a" doesn't crash either one
22:10:13 <troutwine> "uncompiled", rather.
22:10:23 <jleedev> yeah, it's just Nothing in both cases
22:10:45 <jleedev> i did get a kick out of "Just Segmentation fault", though
22:10:58 <pikhq> troutwine: What is the Haskell nature? Is it within us and without us?
22:11:34 <soupdragon> Does a lisp have haskell nature?
22:11:56 <pragma_> it is the nature of Zhivago's age
22:12:00 <pikhq> Does Buddha have Haskell nature?
22:12:09 <troutwine> The Haskell nature is and is not... until someone takes a peak.
22:12:13 <pikhq> Or does Haskell have Buddha nature?
22:12:38 <pikhq> troutwine: Clearly, Schrdinger's cat has Haskell nature.
22:12:54 <pragma_> Haskell is dead?
22:13:05 <Cale> Prelude GHC.Prim> unsafeCoerce# True :: Maybe Integer
22:13:05 <Cale> Just (-1210965780)
22:13:51 <Cale> Prelude GHC.Prim> unsafeCoerce# True :: Maybe Char
22:13:51 <Cale> Just '\-1210965780'
22:14:13 <Cale> whee!
22:14:27 <jleedev> that's a nice char you've got there
22:15:28 <pikhq> Haskell -- programming the Schrdinger way.
22:16:17 <Cale> http://erlang-factory.com/conference/London2009/speakers/SimonPeytonJones -- SPJ gave another talk
22:17:08 <jleedev> > unsafeCoerce# True :: IO Char --internal error: stg_ap_v_ret
22:17:09 <lambdabot>   Not in scope: `unsafeCoerce#'
22:29:23 <desp> Has anyone tried getting any of the examples here http://darcs.haskell.org/gtk2hs/demo/cairo/ to work with the current version of gtk2hs?
22:30:56 <desp> Oh, Drawing2 works.  Woop.
23:00:43 <ski> It was morning.
23:00:49 <ski> drhodes : Mercury,Clean
23:07:45 <hydo_> Hrm, for once, I'm going to spend a significant amount  of time away from a net connection.  Is there an accepted way to generate haddock documentation for all packages in ~/.cabal aside from undoing all of the source files and running haddock against them?
23:08:26 <hydo_> err.. going to spend this time tomorrow.  Not that that matters much, but the sentence didn't make much sense.
23:10:21 <altmattr> is there are better way to import when you have many modules with the same function names?
23:10:21 <altmattr> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2931#a2931
23:10:31 <Saizan> hydo_: not really, but you can add documentation: True in the config file and rebuild them all
23:10:42 <Saizan> hydo_: s/rebuild/reinstall/
23:11:02 <altmattr> importing them all qualified is just horrible
23:11:14 <altmattr> so I end up with a mix, which is confusing
23:11:21 <altmattr> what do you smart folks do?
23:12:03 <hydo_> Saizan: Cool, that'll work.  Actually, I think I remember an env variable - something like CABALOPTS or the like.  Maybe I can use that and just cabal reinstall to automate it.
23:12:04 <Saizan> i tend to stick to all qualified, with S and M
23:12:43 <Saizan> hydo_: well, documentation: True in ~/.cabal/config seems quite automated to be :)
23:13:02 <Saizan> hydo_: which just sets the default for --enable-documentation to True
23:13:05 <hydo_> Saizan: ahoy!  yes, that will work just fine.  Thanks a lot!
23:14:39 <Saizan> hydo_: i've also a patch to make cabal-install keep an index of all the installed documentations at ~/.cabal/share/doc/index.html , still to be reviewed though
23:15:23 <quicksilver> altmattr: I personal import everything qualified except the names of the types, and the operators, from Map/Set and friends.
23:15:39 <hydo_> Saizan: oooo that would be awesome.  Is that patch generally available?  I'd love to... ermm... test it. :)
23:16:08 * hydo_ holds off on for f in `cabal list --installed --simple-output | cut -f 1 -d \  | uniq`; do cabal reinstall $f; done
23:16:27 <altmattr> quicksilver: cheers
23:21:05 <glguy_> Anyone remember enough of ICFP'06 to tell me why my Elim rule isn't working? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6411#a6412
23:21:35 <soupdragon> Are you solving ICFP in the type level? :D
23:22:06 <glguy_> soupdragon: the "advise" language doesn't really have a type-level, afaik :)
23:22:26 <soupdragon> oh I thought it was haskell classes
23:23:25 <Saizan> hydo_: http://code.haskell.org/~Saizan/Cabal-1.7.2.tar.gz and http://code.haskell.org/~Saizan/cabal-install-0.7.tar.gz
23:23:53 <hydo_> Saizan: woo hoo!  I was combing through the cabal-devel archives hehe :)  Thanks!
23:25:58 <Saizan> hydo_: heh, it's in the trac actually :) let me know if you find any problem
23:26:23 <hydo_> Saizan: will do.  and thanks again!
