00:00:01 <luqui> I wish I could find the karnaugh map for love
00:00:43 <Axman6> luqui: it uses 7 variables :(
00:00:56 <dmwit> and changes with the moooooon
00:01:01 <luqui> nbsd_in_prod, it's just functional programming for talking about time
00:01:02 <Axman6> yup
00:01:23 <luqui> nbsd_in_prod, for example, functions of time (Behaviors), and pairs of values with a time (Events)
00:01:36 <luqui> nbsd_in_prod, beautifully simple to describe, horribly awful to implement
00:01:54 <Cale> Events are sequences of time/value pairs rather
00:02:07 <luqui> Cale, er, yeah, I meant Futures.
00:02:19 <RyanT50001> is there much funding for FRP?
00:02:20 <luqui> the duality between Behaviors and Futures is so deep that I kind of forget about Events
00:03:53 <luqui> RyanT50001, not as far as I know.
00:04:27 <RyanT50001> hm
00:04:39 <RyanT50001> how much is needed?
00:05:06 <RyanT50001> i.e.: a ballpark amount of effort to make FRP useful in some industry
00:05:59 * luqui isn't good with money
00:06:08 <RyanT50001> how about researcher-years?
00:06:28 <bos> It's had quite a few years already and shows not so many signs of life yet.
00:06:29 <luqui> it's kind of like physics
00:06:51 <luqui> like asking in 1895 how long it will take to develop quantum mechanics in some respect
00:07:01 <luqui> develop what? they reply
00:07:20 <erikc> how does FRP differ from something like Maya's hypergraph anyway, it seems to me like it's already in use
00:07:23 <luqui> i think there needs to be a breakthrough, it's not just about cranking away
00:07:25 <RyanT50001> yeah, i understand the basic problem with estimating the difficulty of fundamental research
00:07:42 <outchanter1> erikc: or the Gimp's GEGL
00:08:32 <outchanter> maybe those are like Greenspun's law applied to FRP
00:08:36 <RyanT50001> i'm mostly trying to figure out whether this is the kind of thing that could be tackled as a research-oriented startup company
00:09:04 <RyanT50001> *tackled by
00:09:34 <erikc> outchanter :), yea, unreal 3's kismet applies too http://upload.wikimedia.org/wikipedia/en/e/e6/Kismet_Roboblitz.PNG
00:10:20 <luqui> RyanT50001, I would talk to conal elliott about such things
00:10:29 <RyanT50001> which really depends on whether investors can be convinced that (1) the technology is on the cusp of completion; (2) the technology will lead to some kind of large profit
00:10:41 <RyanT50001> luqui: i certainly intend to
00:10:49 <luqui> RyanT50001, also see Anygma for prior art (as before)
00:10:59 <RyanT50001> i wasn't able to find much info on Anygma
00:11:04 <RyanT50001> i mean, i found their site
00:11:07 <luqui> RyanT50001, talk to Beelsebob
00:11:15 <luqui> he still works there I think
00:11:18 <RyanT50001> ah, ok
00:11:25 <RyanT50001> thanks
00:12:11 * WorkyBob wanders in
00:12:34 * WorkyBob pokes luqui in the spleens, and RyanT50001 somewhere less painfull
00:12:45 <RyanT50001> haha
00:15:38 <Pellwurst> does anyone know a good tutorial concerning makefiles for haskell
00:16:38 <mgsloan> multiset is to set as list is to ???
00:17:40 <kniu> a catch function should catch ALL exceptions coming from its first argument, right?
00:18:11 <mornfall> mgsloan: Hmm?
00:18:13 <outchanter> mgsloan: lists can already hold multiple copies
00:18:28 <mgsloan> I'm thinking of a list which _can't_
00:18:41 <mgsloan> I guess you could call it an ordered set
00:18:46 <dolio> I'm not sure that has a name.
00:19:04 <mgsloan> sorry, this isn't a very haskellish question, I'm just thinking about orthogonal features of data structures
00:19:10 <outchanter> set+permutation?
00:19:10 <dmwit> Pellwurst: Almost no Haskell projects use make.
00:19:25 <dmwit> Pellwurst: ghc --make is good enough for one-offs, and for more serious projects, cabal is quite nice.
00:19:36 <mgsloan> outchanter - yeah, that's a good way of looking at it
00:31:45 <luqui> outchanter, another thing to think about is that an associative commutative operator creates a set, whereas an associative operator creates a list
00:31:53 <luqui> s/set/multiset/
00:32:14 <luqui> an assoc. comm. idempotent operator creates a set, so what's an assoc. idempotent operator
00:32:52 <luqui> it could be a list with no subsequences of identical elements, although the list still might have duplicate elements
00:33:53 <Neut> Can someone help me fix up the type issues with this code,
00:33:54 <Neut> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2592#a2592
00:34:26 <outchanter> luqui: I'm having trouble seeing what the point of that would be :-P unless you're doing run length encoding without the lengths...
00:34:45 <dmwit> Neut: isSpace is in the standard libraries.
00:34:52 <dmwit> :t isSpace
00:34:54 <lambdabot> Char -> Bool
00:34:54 <Neut> oh nice
00:34:57 <dmwit> ?index isSpace
00:34:58 <lambdabot> Data.Char
00:35:09 <dmwit> Neut: As for fixing it, you likely want (==) rather than elem.
00:35:20 <luqui> outchanter, yeah i dunno.  just trying to draw an analogy from a different angle
00:35:25 <dmwit> Neut: (Since n is a Char, not a list.)
00:35:41 <luqui> outchanter, maybe you have a list of idempotent transitions
00:36:03 <Neut> dmwit: thanks
00:38:55 <dmwit> > map (\x -> if isAlpha x then chr (ord x + 2) else x) "G fmnc wms bgblr rpylgjyrc gr zw fylb."
00:38:57 <lambdabot>   "I hope you didnt tr{nil{te it |y h{nd."
00:39:02 <Neut> yeah
00:39:06 <dmwit> indeed
00:39:07 <Neut> there is one more thing I need to work out
00:39:32 <dmwit> Python Challenge?
00:39:44 <Neut> yeah but im doing it in haskell
00:39:48 <dmwit> right
00:39:49 <Neut> exams coming up
00:39:57 <Neut> just got one more kink
00:39:59 <Neut> dont do it please lol
00:40:16 <dmwit> They're mostly quite do-able.  The pickle one is tricky, since there's (obviously) no pickle library for Haskell.
00:40:24 <nikkos99> whats up
00:40:29 <dmwit> ?wn up
00:40:32 <lambdabot> Error: connect: does not exist (Connection refused)
00:40:38 <dmwit> =(
00:42:11 <luqui> ask wolfram alpha
00:44:10 <outchanter> luqui: I suppose so. Isn't there a groupBy function for that?
00:45:25 <luqui> map head . groupBy $ [1,2,2,3,3,3,5,5,5,5,5]
00:45:29 <luqui> > map head . groupBy $ [1,2,2,3,3,3,5,5,5,5,5]
00:45:31 <lambdabot>   Couldn't match expected type `[[a]]'
00:45:51 <outchanter> :t groupBy
00:45:52 <luqui> outchanter, you might want to maintain it as an invariant.  (i dunno, picking from thin air here)
00:45:52 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
00:45:55 <luqui> > map head . group $ [1,2,2,3,3,3,5,5,5,5,5]
00:45:57 <lambdabot>   [1,2,3,5]
00:47:08 <Neut> dmwit: if I add something like this,
00:47:22 <Neut> | x == '{' = 'a' : decrypt xs
00:47:26 <Neut> why doesn't it work?
00:47:47 <dmwit> Well, it isn't '{' before the decryption, now, is it? ;-)
00:49:32 <Neut> w00t
00:50:28 <Neut> granted its an ugly fix - it works
00:51:10 <luqui> I get the feeling you can do something with cycle ['a'..'z']
00:51:16 <luqui> but i don't know what...
00:51:58 <dmwit> > let translation = zip ['a'..'z'] (drop 2 . cycle $ ['a'..'z']) in map (`lookup` translation) "g fmnc wms bgblr rpylgjyrc gr zw fylb."
00:51:59 <lambdabot>   [Just 'i',Nothing,Just 'h',Just 'o',Just 'p',Just 'e',Nothing,Just 'y',Just...
00:52:12 <dmwit> err... right
00:52:57 <dmwit> > let translate x = fromMaybe ' ' (lookup (toLower x) translation); translation = zip ['a'..'z'] (drop 2 . cycle $ ['a'..'z']) in map translate "G fmnc wms bgblr rpylgjyrc gr zw fylb."
00:52:59 <lambdabot>   "i hope you didnt tranilate it by hand "
00:53:14 <dmwit> > let translate x = fromMaybe x (lookup (toLower x) translation); translation = zip ['a'..'z'] (drop 2 . cycle $ ['a'..'z']) in map translate "G fmnc wms bgblr rpylgjyrc gr zw fylb."
00:53:16 <lambdabot>   "i hope you didnt tranilate it by hand."
00:54:43 <Neut> nice,,
00:55:43 <Twey> > let alphabet = ['a'..'z']; translate c = if isAlpha c then alphabet !! (ord c + 2 `mod` length alphabet) else c in map translate "g fmnc wms  bgblr rpylgjyrc gr zw fylb.
00:55:44 <lambdabot>   <no location info>:
00:55:44 <lambdabot>      lexical error in string/character literal at end o...
00:55:46 <Twey> Gah
00:55:50 <Twey> > let alphabet = ['a'..'z']; translate c = if isAlpha c then alphabet !! (ord c + 2 `mod` length alphabet) else c in map translate "g fmnc wms bgblr rpylgjyrc gr zw fylb."
00:55:51 <lambdabot>   "* Exception: Prelude.(!!): index too large
00:55:55 <Twey> :(
00:56:01 <Twey> Oh, d'oh
00:56:25 <Twey> > let alphabet = ['a'..'z']; translate c = if isAlpha c then alphabet !! (ord c + 2 - 'a' `mod` length alphabet) else c in map translate "g fmnc wms bgblr rpylgjyrc gr zw fylb."
00:56:27 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
00:57:06 <Twey> > let alphabet = ['a'..'z']; translate c = if isAlpha c then alphabet !! ((ord $ c - 'a') + 2 `mod` length alphabet) else c in map translate "g fmnc wms bgblr rpylgjyrc gr zw fylb."
00:57:07 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
00:57:08 <lambdabot>    arising from a use of `GHC....
00:57:31 <Twey> > let alphabet = ['a'..'z']; translate c = if isAlpha c then alphabet !! ((ord c - ord 'a') + 2 `mod` length alphabet) else c in map translate "g fmnc wms bgblr rpylgjyrc gr zw fylb."
00:57:32 <lambdabot>   "i hope you didnt tr* Exception: Prelude.(!!): index too large
00:57:38 * Twey ponders.
00:57:43 <Twey> Almost there!
00:57:51 <mkfort> so close
00:58:56 <Twey> Hm
00:59:06 <Twey> So why isn't the `mod` causing it to wrap around?
00:59:27 <Twey> 'y' + 2 = 'z' + 1, then `mod` length alphabet should be 'a'
00:59:55 <Twey> I'm doing something stupid, but it's too early to puzzle it out :-P
01:01:02 * Beelsebob1 wonders where the best place to make a request that people don't put OpenGL or GLUT in the description of games/3D tools is – it makes trying to find the OpenGL or GLUT modules on Hackage hard, and seems to be the only pair of libraries that people feel the need to mention when writing a description
01:01:23 <Twey> Heh
01:01:33 <shachaf> Twey: You're using both ord/chr (ASCII) and indices in a list.
01:01:57 <shachaf> Why not use one or the other? :-)
01:02:32 <Twey> True
01:03:33 <Twey> > let translate c = if not isAlpha c then c else chr (ord c + 2 `mod` 26) + 'a' in map translate "g fmnc wms bgblr rpylgjyrc gr zw fylb."
01:03:34 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
01:03:42 <mmorrow> pumpkin: nice squarer :)
01:03:48 <pumpkin> mmorrow: yay!
01:03:58 <pumpkin> mmorrow: unfortunately it only works on very restricted inputs
01:03:58 <Twey> ... huh
01:04:18 <Twey> Oh
01:04:23 <Twey> > let translate c = if not $ isAlpha c then c else chr (ord c + 2 `mod` 26) + 'a' in map translate "g fmnc wms bgblr rpylgjyrc gr zw fylb."
01:04:24 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
01:04:25 <lambdabot>    arising from a use of `GHC....
01:04:29 <Twey> Damn, I'm bad today
01:04:36 <Twey> Why can't we add Chars?
01:04:41 <Twey> That would be useful.
01:05:00 <mmorrow> pumpkin: if we just had the polynomial representation of Integer sorted out, and conversion functions both ways, it'd be easy to implem fft Integer mult
01:05:03 <Twey> > 'a' + chr 2
01:05:04 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
01:05:04 <lambdabot>    arising from a use of `GHC....
01:05:07 <pumpkin> yeah
01:05:34 * mmorrow pokes Cale
01:05:39 <Twey> > let translate c = if not $ isAlpha c then c else chr $ (ord c + 2 `mod` 26) + ord 'a' in map translate "g fmnc wms bgblr rpylgjyrc gr zw fylb."
01:05:41 <lambdabot>   "\202 \201\208\209\198 \218\208\214 \197\202\197\207\213 \213\211\220\207\2...
01:05:45 <Twey> Oh blimey
01:05:54 <Twey> I give up *goes to get breakfast instead*
01:06:05 <shachaf> Aw.
01:06:10 <Cale> mmorrow: yeah?
01:06:19 <shachaf> ord c + 2 is ASCII -- it's way bigger than 26.
01:06:26 <Twey> Ah, yeah.
01:06:32 <pumpkin> mmorrow: any reason you don't have control.arrow loaded in lunabot btw?
01:06:48 <mmorrow> Cale: do you know off-hand the way that e.g. represents Integers as polynomials, and how to write conversion functions both ways?
01:07:00 <mmorrow> err, *..that e.g. gmp ...
01:07:23 <Twey> shachaf: But, I `mod`ed it down
01:07:40 <Cale> The only thing I can imagine is just the usual thing that Integers are polynomials in some base.
01:07:51 <mmorrow> Cale: yes exactly
01:07:52 <shachaf> > ord 'a' + 2
01:07:53 <lambdabot>   99
01:07:59 <shachaf> > (ord 'a' + 2) `mod` 26
01:08:01 <lambdabot>   21
01:08:06 <pumpkin> mmorrow: I think we just need to deal with "carry" essentially
01:08:10 * mmorrow is having a brain block
01:08:13 <Twey> Which may give me a horribly incorrect answer *nod*
01:08:16 <shachaf> > chr ((ord 'a' + 2) `mod` 26)
01:08:18 <lambdabot>   '\NAK'
01:08:25 <mmorrow> pumpkin: oh, hmm
01:08:27 <Twey> > let translate c = if not $ isAlpha c then c else chr $ (ord c + 2 - ord 'a' `mod` 26) + ord 'a' in map translate "g fmnc wms bgblr rpylgjyrc gr zw fylb."
01:08:29 <lambdabot>   "\183 \182\189\190\179 \199\189\195 \178\183\178\188\194 \194\192\201\188\1...
01:08:44 <Cale> d_0 b^0 + d_1 b^1 + ... + d_n b^n
01:08:49 <yitz> > let translate = zipWith (\x y -> if isAlpha y then y else x) <*> map (toEnum . (+2) . fromEnum) in translate "g fmnc wms bgblr
01:08:50 <lambdabot>   <no location info>:
01:08:51 <lambdabot>      lexical error in string/character literal at end o...
01:08:51 <Twey> Hmph
01:08:54 <pumpkin> ,  let (&&&) f g = \x -> (f x, g x) in uncurry (++) . ((reverse . takeWhile (/=0)) &&& (reverse . dropWhile (==0) . dropWhile (/=0))) . map (round . realPart) . ifft . map (^2) . fft . map (:+0) $ [0, 0, 0, 0, 0, 0, 4, 2, 1, 1, 0, 0, 0, 0, 0, 0]
01:08:56 <lunabot>  [16,16,12,12,5,2,1]
01:08:56 <mmorrow> newtype Integer = I [Int]
01:08:59 <yitz> > let translate = zipWith (\x y -> if isAlpha y then y else x) <*> map (toEnum . (+2) . fromEnum) in translate "g fmnc wms bgblr..."
01:09:01 <lambdabot>   "i hope you didnt..."
01:09:06 <yitz> > let translate = zipWith (\x y -> if isAlpha y then y else x) <*> map (toEnum . (+2) . fromEnum) in translate "g fmnc wms bgbl'r..."
01:09:07 <Cale> If b = 10, and each d_k is a digit from 0 to 9, that's the usual base 10 representation.
01:09:08 <lambdabot>   "i hope you didn't..."
01:09:08 <pumpkin> mmorrow: clearly those 16s aren't valid decimal
01:09:14 <mmorrow> heh
01:09:19 <Twey> yitz: Nic :-D
01:09:21 <Twey> Nice**
01:09:29 <yitz> Twey: tnx
01:09:37 <Twey> That works?
01:09:40 <pumpkin> mmorrow: but the 5 2 1 suffix there is the correct suffix of 4211^2
01:09:43 <yitz> appears to
01:09:46 <pumpkin> > 4211^2
01:09:48 <lambdabot>   17732521
01:10:03 <Twey> > toEnum . (+2) . fromEnum $ 'y'
01:10:04 <lambdabot>   * Exception: Prelude.Enum.().toEnum: bad argument
01:10:13 <shachaf> > let translate = zipWith (\x y -> if isAlpha y then y else x) <*> map (toEnum . (+2) . fromEnum) in translate "g fmnc wms bgblr rpylgjyrc gr zw fylb." -- Error error.
01:10:15 <lambdabot>   "i hope you didnt trynilyte it zy hynd."
01:10:24 <mmorrow> Cale: what i'm blocking on is how the write the conversion functions ([Int] -> {-real-} Integer), and (Integer -> {-coeffs-} [Int])
01:10:26 <Twey> Ah :)
01:10:45 <Cale> If b = 2^32, say, and each d_k is a number from 0 to 2^32 - 1, then you have something suitable for representing Integers.
01:10:54 <pumpkin> mmorrow: map digitToInt . show for the latter one? :P
01:11:00 <mmorrow> pumpkin: heh
01:11:10 <mmorrow> base-2!!
01:11:12 <pumpkin> lol
01:11:21 <shachaf> Twey: (By the way, the only thing wrong with yours was missing parentheses.)
01:11:23 <pumpkin> or base 2^64
01:11:31 <mmorrow> heh
01:11:34 <Cale> So, it's basically the same as interpreting a number written in some base or finding the base b digits of a number
01:12:27 <Twey> > let translate c = if not $ isAlpha c then c else chr ((((ord c + 2) - ord 'a') `mod` 26) + ord 'a') in map translate "g fmnc wms bgblr rpylgjyrc gr zw fylb."
01:12:29 <lambdabot>   "i hope you didnt tranilate it by hand."
01:12:37 <Twey> Huh.
01:13:01 <pumpkin> > sum . zipWith (*) (iterate (10*) 1) . reverse $ [16,16,12,12,5,2,1]
01:13:03 <lambdabot>   17732521
01:13:09 <Twey> > ord 'g' + 2 - ord 'a'
01:13:10 <pumpkin> mmorrow:
01:13:10 <lambdabot>   8
01:13:18 <Twey> > ord 'g' + 2 - ord 'a' `mod` 26
01:13:20 <lambdabot>   86
01:13:25 <Twey> Huh.
01:13:37 <Twey> I thought `` was lower-precedence than anything but $
01:13:49 <Cale> [Int] -> Integer would be something like foldl (\a x -> b*a + fromIntegral x) 0
01:13:52 <mmorrow> what about base 2^32 (or 2^64)
01:13:54 <mmorrow> woo
01:14:03 <shachaf> > 1 `mod` 26
01:14:04 <pumpkin> ,  let (&&&) f g = \x -> (f x, g x) in sum . zipWith (*) (iterate (10*) 1) . reverse . uncurry (++) . ((reverse . takeWhile (/=0)) &&& (reverse . dropWhile (==0) . dropWhile (/=0))) . map (round . realPart) . ifft . map (^2) . fft . map (:+0) $ [0, 0, 0, 0, 0, 0, 4, 2, 1, 1, 0, 0, 0, 0, 0, 0]
01:14:04 <shachaf> > 26 + 1 `mod` 26
01:14:04 <lambdabot>   1
01:14:05 <lambdabot>   27
01:14:06 <lunabot>  17732521
01:14:09 <pumpkin> there we go :)
01:14:17 <pumpkin> now I can haz zquarez
01:14:27 <mmorrow> wee
01:14:30 <Twey> > let translate c = if not $ isAlpha c then c else chr $ ((ord c + 2 - ord 'a') `mod` 26) + ord 'a' in map translate "g fmnc wms bgblr rpylgjyrc gr zw fylb."
01:14:31 <lambdabot>   "i hope you didnt tranilate it by hand."
01:14:48 <yitz> Twey: mod is declared as infixl 7
01:14:49 <pumpkin> now I just need to automatically pad the input list to a power of two
01:14:58 <Twey> Oh
01:15:01 <Twey> mod is special
01:15:17 <yitz> Twey: not really, you can declare fixity for any function
01:15:17 <Twey> > let translate c = if not $ isAlpha c then c else chr $ (ord c + 2 - ord 'a') `mod` 26 + ord 'a' in map translate "g fmnc wms bgblr rpylgjyrc gr zw fylb."
01:15:19 <lambdabot>   "i hope you didnt tranilate it by hand."
01:15:25 <pumpkin> mmorrow: almost ready for inclusion in integer-simple! :P
01:15:41 <pumpkin> I wonder at what point using doubles for the fft loses precision at the integer level
01:15:53 <pumpkin> we should probably use the discrete version
01:16:21 <mmorrow> pumpkin: i have a whole directory of fft C implems somewhere i collected from random places online..
01:16:27 * mmorrow digs them up
01:16:27 <pumpkin> :o
01:16:33 <pumpkin> FFeTish
01:16:36 <mmorrow> haha
01:16:56 <Neut> Twey/yitz - thanks for showing me how mediocre my solution is :D
01:17:00 <pumpkin> if you have an implementation of the NTT that'd be handy too
01:17:25 <mmorrow> in particular, we probably want to use a Real variant since we're not starting with Complex nums for the input
01:17:41 * Twey is tempted to call the function ‘tranilate’
01:17:42 <mmorrow> then you only have to do half the work
01:17:57 <pumpkin> true, but most real FFTs return the result in a weird interleaved fashion iirc
01:18:05 <Neut> btw Twey, my solution has the 's' not the 'i'
01:18:16 <mmorrow> pumpkin: yeah, and we've gotta sort out how to rearrange the result
01:18:23 <pumpkin> I still think the discrete one would be best
01:18:31 <pumpkin> no conversion to/from double
01:18:37 <mmorrow> pumpkin: what do you mean by, oh
01:18:43 <pumpkin> I guess we could benchmark different ones
01:18:48 <Twey> Neut: How did you do that?
01:19:00 <Neut> 1 sec
01:19:22 <pumpkin> (http://en.wikipedia.org/wiki/Number-theoretic_transform )
01:19:29 <mmorrow> pumpkin: i've never done anything with one that uses int arithmetic, not sure how it's done
01:19:30 <kyevan> > length [31, 34, 36, 37, 38, 39, 42, 46, 40, 59, 50]
01:19:32 <lambdabot>   11
01:19:34 <Neut> dont laugh => http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2595#a2595
01:19:34 <mmorrow> (one := fft)
01:19:47 <pumpkin> same basic idea, using modular exponentiation instead of complex
01:19:48 <kyevan> (blame that one on me being too sleepy to count :P)
01:19:57 <mmorrow> pumpkin: ah, hmm
01:20:33 <Neut> Twey: I didnt use mod (couldnt get it to work) so i just put cases in
01:20:47 <pumpkin> CPUs need a modular exponentiation instruction!
01:20:50 <pumpkin> 'tis useful :P
01:21:07 <Twey> Neut: o.@
01:21:19 <Neut> ?
01:21:20 <pumpkin> and multiplicative inverse mod x :P and discrete logarithm ;)
01:21:43 * mmorrow found his ffts, makes a darcs repo
01:21:48 <pumpkin> yay
01:21:52 <Twey> But how does this handle the i?
01:21:57 <pumpkin> fft galore
01:22:10 <yitz> Neut: some of those asciiGet x's should be just x, I think.
01:22:15 <Neut> it doesnt handle it specially
01:22:21 <mmorrow> here's a classic comment:
01:22:28 <mmorrow> and correction of some Fortran code.  I have tested it somewhat ...
01:22:33 <yitz> Neut: and btw it's a nice clear way of doing things, no laughter here.
01:22:36 <pumpkin> ,  let (&&&) f g = \x -> (f x, g x) in sum . zipWith (*) (iterate (10*) 1) . reverse . uncurry (++) . ((reverse . takeWhile (/=0)) &&& (reverse . dropWhile (==0) . dropWhile (/=0))) . map (round . realPart) . ifft . map (^2) . fft . map (:+0) $ [0, 0, 0, 1, 5, 0, 4, 2, 1, 1, 0, 7, 2, 0, 0, 0]
01:22:37 <lunabot>  62738941026509485
01:22:40 <mmorrow>  /* Here is a C function for doing a real fft (split radix).  It is a translation and correction of some Fortran code.  I have tested it somewhat ..
01:22:44 <pumpkin> lol
01:22:49 <Twey> Haha
01:22:59 <Neut> yitz: they need to be ascii'd first though before they can be decrypted
01:23:01 <Neut> dont they?
01:23:13 <pumpkin> oh no, I think that square got truncated
01:23:19 <Twey> Neut: Which case handles the i, then?
01:23:23 <pumpkin> it needz m0ar padding
01:23:39 <yitz> Neut: you're saying that if it's { *after* decryption, change it to an a.
01:23:53 <Neut> Twey: nothing special - I dont know why it makes it an 's' and yours doesn't, I was just commenting t'is all
01:24:13 <yitz> Twey: that i/s business is weird
01:24:36 <pumpkin> ah well, I should finish grading this damn homework
01:24:44 <shachaf> It has no excuse to make it an 's'.
01:24:49 <pumpkin> and quit wasting time with multiplication algorithms
01:25:17 <pumpkin> mmorrow: another option is to use the fastest known multiplication algorithm you dug up yesterday! we might be able to approach GMP yet :P
01:25:20 <Neut> > length [a..z]
01:25:22 <lambdabot>   * Exception: not a number
01:25:31 * yitz notes that pumpkins multiply slowly, but grow quickly.
01:25:32 <Neut> > length ['a'..'z']
01:25:34 <lambdabot>   26
01:25:48 <pumpkin> yitz: :o
01:25:52 <Neut> > length ['a'..'s']
01:25:53 <pumpkin> yitz: you callin me fat!
01:25:54 <lambdabot>   19
01:25:57 <Axman6> yitz: a lot like a CPU?
01:26:04 <Neut> length ['a'..'i']
01:26:13 <Neut> > length ['a'..'i']
01:26:15 <lambdabot>   9
01:26:19 <yitz> pumpkin: I didn't mention verticle or horizontal or intellectual orientation
01:26:29 <pumpkin> > ((-) `on` ord) 'a' 'i'
01:26:30 <lambdabot>   -8
01:26:36 <shachaf> ...What?
01:26:46 <shachaf> g-h-i. g *should* become an i.
01:26:49 * pumpkin sobs at yitz' insensitivity
01:26:55 <pumpkin> :P
01:27:06 <Axman6> pumpkin: quiet fatty!
01:27:18 <pumpkin> :'(
01:27:31 <yitz> pumpkin: sorry, really, no offense intended.
01:27:50 <pumpkin> yitz: I'm just playing, sorry :P I guess tone isn't very clear on IRC :)
01:28:19 <mmorrow> pumpkin: ok, here's a repo with two fft implems + a dir containing code for some "cwp lib" (dunno), i've got more code somewhere but i don't think it's on this laptop.. anyways:  http://moonpatio.com/repos/MISC/fft-misc/
01:28:37 <mmorrow> this one is lightning fast http://moonpatio.com/repos/MISC/fft-misc/rsplitfft.c
01:28:48 <pumpkin> ack, in-place though
01:28:57 <mmorrow> yeah
01:29:00 <yitz> pumpkin: your nick makes you sound like a former perl programmer though, so that does open you up to some occasional jabs.
01:29:48 <pumpkin> mmorrow: wow, that code definitely looks like it was translated from fortran! :P
01:29:55 <mmorrow> haha
01:29:55 <pumpkin> the comment does not surprise me
01:30:14 <mmorrow> this comment is classic too:
01:30:22 <mmorrow>  /* Currently it uses Fortran style: x[1] is first element not x[0].  I couldn't
01:30:22 <mmorrow> figure out a simple way to convert to C style.  I guess it's not a
01:30:22 <mmorrow> catastrophe to waste one element (x[0]).
01:30:22 <mmorrow>  */
01:30:29 <pumpkin> lol
01:30:33 <mmorrow> the catastrophe!!
01:31:19 <pumpkin> I wonder how much faster fftw is than that
01:31:39 * yitz is wary of the fft-based multiplication algos, and suspects that ffi is just obfuscating some underlying algebra.
01:32:11 <pumpkin> yitz: convolution of the polynomial coefficients? :P
01:32:35 <mmorrow> yitz: fft is just a linear-map of vector spaces (vector space of (C -> C))
01:32:45 <yitz> pumpkin: probably more complicated than that
01:33:03 <pumpkin> yitz: yet they make the difference between an hour and fifteen minutes to compute 123456789^54321 and about 6 seconds
01:33:16 <pumpkin> , 123456789^54321
01:33:18 <lunabot>  1531351230839406576305221343465325013324448746668945797218855545067222412...
01:33:26 <yitz> mmorrow: no reason that C should be involved here though. except for the stupid design of current cpu architectures.
01:33:33 <pumpkin> , length . show $ 123456789^54321
01:33:35 <lunabot>  439540
01:33:50 <pumpkin> yitz: oh, I wasn't planning on doing it in c, sorry I misunderstood
01:33:55 <mmorrow> yitz: but until then.. :)
01:34:04 <pumpkin> or you meant complex?
01:34:13 * yitz sighs pentively
01:34:20 <pumpkin> lol
01:35:17 <cizra> Hi. I've got a parametrized type Point Double Double. How do I make a type alias Vector for it? I tried type Vector = Point and type Vector = Point Double Double, but neither one works right.
01:35:24 <mmorrow> the speed *and* the style point both be retained though, if we just use haskell to /generate/ C which does out ffts :)
01:35:29 <mmorrow> *style pointS
01:35:35 <mmorrow> can
01:35:45 <mmorrow> s/out/our/
01:35:53 <mmorrow> </corrections>
01:35:56 <mmorrow> </html>
01:36:34 <mmorrow> (or just spit out SSE* vectorized asm!!)
01:36:51 <doserj> cizra: how does the data declaration look like? data Point a = Point a a? then type Vector = Point Double should work.
01:37:06 <cizra> data Point = Point Double Double
01:37:20 <doserj> then type Vector = Point
01:37:29 <pumpkin> mmorrow: yeah, that'd be nice
01:37:44 <cizra> doserj: It doesn't work: using Vector as a type gives 3-9.hs:19:39: Not in scope: data constructor `Vector'
01:37:45 <pumpkin> mmorrow: or rewrite fftw in haskell instead of ocaml and claim all the fame and glory :P
01:38:09 <doserj> cizra: that's a different problem then. how do you use Vector?
01:38:32 <yitz> cizra: how about type Vector a b = Point a b
01:38:37 <mmorrow> pumpkin: have you seen the (newest of the?) fftw paper?
01:38:43 <cizra> toVector :: Point -> Point -> Vector
01:38:43 <cizra> toVector (Point x0 y0) (Point x1 y1) = Vector (x1 - x0) (y1 - y0)
01:38:47 <pumpkin> mmorrow: nope, why?
01:39:03 <cizra> yitz: Nope, same error.
01:39:09 <doserj> cizra: toVector (Point x0 y0) (Point x1 y1) = Point (x1 - x0) (y1 - y0)
01:39:18 <doserj> Vector is a type, not a data constructor
01:39:19 <mmorrow> pumpkin: http://www.fftw.org/fftw-paper-ieee.pdf
01:39:40 <mmorrow> pumpkin: it's a nice overview of whattf fftw is doing
01:39:51 <pumpkin> cool
01:39:53 <yitz> cizra: oh wait, you're trying to use it as a data constructor?
01:40:08 <cizra> Cool, it works now.
01:40:13 <doserj> cizra: and maybe you want Vector to be a newtype, instead of a type synonym
01:40:19 <cizra> Umm. Will aliased types provide me with type safety?
01:40:25 <doserj> cizra: no
01:40:34 <cizra> OK, I'll make a new type then.
01:40:48 <pozic> Does cabal have an option to only install the documentation?
01:40:48 <cizra> I got confused what's a point and what's a vector and decided to separate them to clear my head.
01:41:03 <dcoutts> pozic: cabal install foobar --enable-documentation
01:41:12 <pozic> dcoutts: that also installs foobar, no?
01:41:29 <pozic> dcoutts: (which is not what I want. )
01:41:34 <dcoutts> pozic: oh, "only", I missed that
01:41:38 <yitz> pumpkin: an hour and fifteen minutes?
01:41:44 <yitz> ??
01:42:01 <dcoutts> pozic: http://hackage.haskell.org/trac/hackage/ticket/225
01:42:07 <pumpkin> yitz: yup, the integer-simple using quadratic multiplication of bigints in my test a couple of days ago
01:42:19 <pumpkin> using gmp it took a few seconds
01:42:41 <pumpkin> and I killed the integer-simple one after 1:15 so it might've taken a lot longer
01:42:55 <outchanter> fft is an O(nlogn) algorithm
01:43:00 <pumpkin> yup
01:43:06 <yitz> pumpkin: that was karatsuba?
01:43:08 <pumpkin> but naive multiplication is n^2
01:43:15 <pumpkin> karatsuba?
01:43:20 <outchanter> so is naive discrete fourier transform
01:43:31 <yitz> @google karatsuba multiplication
01:43:36 <lambdabot> http://en.wikipedia.org/wiki/Karatsuba_algorithm
01:43:36 <lambdabot> Title: Karatsuba algorithm - Wikipedia, the free encyclopedia
01:43:49 <mgsloan> is there indiscrete forier transform?
01:44:00 <cizra> yea
01:44:09 <cizra> Done with integrals n' such. Scary stuff.
01:44:12 <mgsloan> so no discrete timesamples? hrmm
01:44:14 <mgsloan> wierd
01:44:16 <mmorrow> mgsloan: *continuous
01:44:48 <mgsloan> continuous derivatives too?
01:44:50 <pumpkin> yitz: it looks like just naive multiplication to me, but you can find the source at http://darcs.haskell.org/packages/integer-simple/GHC/Integer.hs if you don't mind MagicHash
01:45:05 <mgsloan> (at least the first one for gods sakes!)
01:45:22 <outchanter> yitz: there's a good explanation of the fast Fourier transform in ch2 of this book: http://www.cs.berkeley.edu/~vazirani/algorithms.html
01:45:24 <mgsloan> then again I guess as n approaches infinity
01:45:56 <mgsloan> it can approximate discontinuities in the dirivative perfectly
01:46:44 <mmorrow> mgsloan: oh, do you mean a computing the continuous fourier transform?
01:47:08 <yitz> outchanter: fft-based bigint multiplication is only worth it for very, very large integers. Many thousands of digits. gmp uses naive multiplication for fairly small ints, then karatsuba, then thom (I think), possible other stuff, and only resorts to fft for really huge things.
01:47:18 <mmorrow> mgsloan: i guess if the case is one where you can symbolically computed the result..
01:47:44 <mmorrow> (result := a * cos .. + .. * sin + .......
01:47:45 <mmorrow> )
01:47:46 <yitz> thom-3 or something.
01:48:13 <outchanter> makes sense, asymptotically most efficient doesn't always translate to most efficient for small cases
01:48:35 <mmorrow> , 10000000^100000
01:48:37 <lunabot>  1000000000000000000000000000000000000000000000000000000000000000000000000...
01:48:43 <mmorrow> , 10000000^1000000
01:48:50 <lunabot>  Killed.
01:48:51 <pumpkin> yitz: well, that integer I tried it on had 400000 digits
01:49:07 <mmorrow> , length . show $ , 10000000^100000
01:49:08 <lunabot>  luna: A section must be enclosed in parentheses thus: (length . show $)
01:49:13 <mmorrow> , length . show $ 10000000^100000
01:49:15 <lunabot>  700001
01:49:28 <pumpkin> :o
01:49:34 <yitz> pumpkin: wasn't that integer-simple thing just a test of the capability of the infrastructure to plug in gmp alternatives to ghc? I don't think it was ever meant to actually multiply anything.
01:49:57 <pumpkin> yitz: yeah, but he wanted to see how practical it'd be as a real integer library too, I think
01:50:30 <yitz> pumpkin: the answer is: not.
01:50:45 <pumpkin> I know :)
01:51:08 <yitz> pumpkin: python uses just naive + karatsuba, it works fine in practice.
01:51:33 <mmorrow> yitz: isn't all of pythons stuff in C anyways ?
01:51:33 <pumpkin> maybe we should stick karatsuba onto it and see what happens, then
01:51:35 <yitz> pumpkin: I think naive up to about 2^1000, then karatsuba
01:51:47 <yitz> pumpkin: yeah, should be pretty easy.
01:51:55 <pumpkin> even the fft multiplication is pretty easy
01:51:57 <cizra> Can I use a function with guards with a let-expression?
01:51:57 <yitz> mmorrow: yeah
01:51:59 <pumpkin> we could do all three
01:52:04 <pumpkin> but then we'd need to play around with the boundaries
01:52:10 <mmorrow> yeah, fft mult isn't very hard to implem..
01:52:17 <cizra> Or, alternatively, is there a variant of the case expression that allows arbitrary boolean conditions?
01:52:59 <yitz> pumpkin: yeah. that's most of the work, how do you set the boundaries. it's not trivial. the gmp people have published papers about various kinds of tests.
01:53:20 <pumpkin> yeah :/
01:53:57 <yitz> pumpkin: but for most everyday apps, the simple approach python uses seems to work fine.
01:54:15 <cizra> Ohhh. I can use the where clause instead.
01:54:23 <doserj> > let f x | x>0 = True | x <= 0 = False in f 3
01:54:24 <lambdabot>   True
01:54:37 <pumpkin> yeah, it'd be nice to have a viable pure haskell alternative for people who don't want GMP's license and can live with a slightly slower library for everyday use
01:54:41 <hackagebot> Added by FrederickRoss, Mon Jun  8 08:53:30 UTC 2009.: POSIX serial port wrapper  http://hackage.haskell.org/cgi-bin/hackage-scripts/package/serial-0.2
01:54:41 <doserj> cizra: is that what you need?
01:54:56 <mmorrow> yitz: the stopper is though, there's a test in ghc's testsuite that does something like "factorial 10000000" ;)
01:55:06 <fasta> Is there anything one can do against? can't load .so/.DLL for: pthread (/usr/lib/libpthread.so: invalid ELF header) without a solution for http://hackage.haskell.org/trac/ghc/ticket/2615 ?
01:55:10 <pumpkin> yeah :/
01:55:30 <outchanter> wikipedia says "In practice the Schönhage–Strassen [fft based] algorithm starts to outperform older methods such as Karatsuba and Toom–Cook multiplication for numbers beyond 2215 to 2217 (10,000 to 40,000 decimal digits)" http://en.wikipedia.org/wiki/Sch%C3%B6nhage-Strassen_algorithm
01:55:30 <mmorrow> (w/ a^100000000 you only need to do 2 ffts, but with factorial n, you need to do 2*n ffts..)
01:55:31 <pumpkin> that's the one real failure left in my gmpless ghc tree
01:56:03 <mmorrow> err, sorry that should be  n+1 ffts
01:56:04 <outchanter> sorry, that should be 2^2^15, not 2215
01:56:08 <cizra> doserj: no. I needed something like f x { let a = computeA } | a > 0 = Zero; | a < 0 = Negative etc.
01:56:19 <cizra> doserj: But I got around with the "where" expression.
01:56:47 <fasta> dcoutts: You asked that question 4 years ago :) Sun May 16 17:48:07 EDT 2004
01:57:06 <fasta> dcoutts: er 5
01:57:15 <nomeata> Hi. A bit off topic: As I regular do Haskell, I kind of think in haskell terms. But now I have to do C++. The STL contains a Pair<a,b> construct, but what is the equivalent to Maybe? A simple pointer won’t do, becaues it won’t be copied correctly automatically etc.
01:57:24 <yitz> mmorrow: hard code that one in the multiplication code.
01:57:36 <doserj> cizra: that's exactly what where is there for :)
01:58:01 <Twey> nomeata: Exceptions
01:58:10 <dcoutts> fasta: you can just omit the -pthread flag
01:58:23 <yitz> nomeata: null
01:58:27 <fasta> dcoutts: I am not using the -pthread flag.
01:58:28 <Twey> Idiomatically, you just return the value and throw an exception if it goes wrong
01:58:35 <Twey> There's also null, yes
01:58:57 <dcoutts> fasta: or -lpthread, either in your package or any dependent package
01:59:03 <mmorrow> yitz: heh
01:59:11 <nomeata> Twey: right, but is there a ready made container that takes care of the memory management issues? Or should I create my own one?
02:00:39 <Twey> nomeata: No.
02:00:50 <Twey> The C++ way is to handle it yourself, every time.
02:00:51 <yitz> isn't there autoptr or something like that?
02:00:57 <Twey> There are a couple of solutions
02:01:04 <Twey> Smart pointers, garbage collection
02:01:04 <yitz> in STL
02:01:15 <Twey> But they're not generally used
02:01:29 <fasta> dcoutts: so, I should delete the pthreads entry in the extra-libraries field in the cabal file? There is no other mention of pthreads.
02:01:57 <yitz> Twey: yeah, I used autoptr for a while. It did help, but it wasn't a complete solution.
02:02:07 <dcoutts> fasta: that should do it
02:02:11 <nomeata> yitz: thx for the pointer (hehe), I’ll look at it
02:02:13 <outchanter> Boost.org has reference counting smart pointers
02:02:40 <yitz> nomeata: glad you got the point.
02:02:47 <Twey> Heh
02:02:55 <outchanter> and there is the Boehm-somebody garbage collector ... but at that point you should probably switch to D
02:04:08 <fasta> dcoutts: it does. Should I contact the author of the package to request the change? Or is this some temporary problem in ghc?
02:04:37 <TheColonial> aavogt: Berengal: thanks for your help earlier guys. I've got what I needed. cheers.
02:04:44 <kalven> nomeata: you'll get better help with this in ##c++
02:04:47 <dcoutts> fasta: it's not temporary, but pthreads may be required on other platforms, it's a bit of a mess.
02:04:56 * Twey looks at kalven.
02:05:11 <fasta> dcoutts: other platforms would include Windows?
02:05:50 <dcoutts> fasta: no, other unix systems
02:06:11 <fasta> dcoutts: ok, then it is not a problem for now. Thanks
02:06:27 <dcoutts> fasta: windows lacks pthreads entirely
02:06:38 <dhun> I wrote my first, not totally useless Haskell program. only problem it is 100 times longes and 20 slower than the python version, but it also more correct, lets see if I will to better in future
02:07:09 <fasta> dcoutts: ok, so hsmagick doesn't work on Windows?
02:07:23 <dcoutts> fasta: no idea
02:07:25 <mmorrow> fasta: hsmagick needs pthreads!?!
02:07:42 <fasta> mmorrow: it says so in the dependencies.
02:07:46 <mmorrow> fasta: (isn't that just an ffi binding to imagemagick?)
02:07:50 <mmorrow> fasta: weird
02:08:04 <fasta> mmorrow: yes, I think it is.
02:08:53 <Twey> dhun: Hehe, what was it?
02:09:18 <dhun> its a parser for wikilinks "[[blah]]", it can also do nested ones
02:09:29 <dcoutts> mmorrow, fasta: actually it looks messed up to me. It has "pkgconfig-depends:   GraphicsMagick >= 1.3.3" but then also "extra-libraries:     tiff jasper jpeg png wmflite bz2 z m pthread" which are almost certainly all already listed by pkg-config for GraphicsMagick
02:09:46 <yitz> dhun: paste
02:09:49 <yitz> @hpaste
02:09:49 <lambdabot> Haskell pastebin: http://hpaste.org/new
02:09:55 <mux> just for the record, using the -pthread is the posixly correct way to build with pthreads (as opposed to -lpthread)
02:10:28 <fasta> mux: what's so special about pthread that it is not -lphread?
02:11:29 <mux> the only thing special about it is that the standards say this is how you are supposed to build with pthreads :-)
02:11:44 <mux> in practice, using -pthread may define necessary flags that wouldn't be define if you had used -lpthread
02:11:50 <mux> (I mean CPP flags)
02:11:58 <yitz> dcoutts: shouldn't it anyway list libs it needs itself, even if they are also listed by GraphicsMagick? But yeah, the graphics format ones certainly look wrong.
02:12:21 <dcoutts> yitz: yes, if it needs them itself (which I doubt) zlib etc?
02:12:31 <yitz> dcoutts: you never know.
02:13:44 <dhun> http://de.wikibooks.org/wiki/Benutzer:Dirk_Huenniger/haskell
02:14:46 <hackagebot> Added by FrederickRoss, Mon Jun  8 09:14:09 UTC 2009.: POSIX serial port wrapper  http://hackage.haskell.org/cgi-bin/hackage-scripts/package/serial-0.2.1
02:15:51 <dcoutts> yitz: actually you can check easily by looking at the foreign imports
02:16:01 <mmorrow> pumpkin: hehe, convolution function with unrolled special cases for input vector up to length=30
02:16:10 <mmorrow> pumpkin: err, the link: http://moonpatio.com/repos/MISC/fft-misc/cwp/convolution.c
02:16:29 <dcoutts> it only imports C function from magick/api.h which we can reasonably assume to be defined in it's own lib, rather than in zlib etc
02:16:30 <pumpkin> wow, crazy
02:18:13 <mmorrow> saxpy (among other): http://moonpatio.com/repos/MISC/fft-misc/cwp/sblas.c
02:18:39 <mmorrow> (also a dblas.c in there... handay)
02:19:23 <dhun> yitz pasted: http://de.wikibooks.org/wiki/Benutzer:Dirk_Huenniger/haskell
02:23:26 <yitz> dhun: it does look like it could be simplified a bit, but isn't Parsec overkill for this?
02:24:16 <yitz> dhun: did you try Parsec's "between" operator?
02:24:21 <dhun> no
02:26:10 <dhun> maybe it could work
02:27:01 <cizra> How to find the smallest item in a list, functionally?
02:27:16 <ClaudiusMaximus> :t minimum
02:27:18 <lambdabot> forall a. (Ord a) => [a] -> a
02:27:20 <cizra> I could write a recursive function that remembers the current best, but that looks kinda ugly
02:27:33 <pumpkin> foldr1' min
02:27:38 <pumpkin> minus the tick
02:27:46 <mmorrow> @src minimum
02:27:47 <lambdabot> minimum [] = undefined
02:27:48 <lambdabot> minimum xs = foldl1 min xs
02:27:56 <Cale> foldl1' you mean :)
02:28:09 <pumpkin> how does it differ in this case?
02:28:18 <Cale> foldr1' doesn't exist
02:28:22 <cizra> Mm.. OK. But if my data type isn't trivially orderable?
02:28:28 <pumpkin> Cale: I said minus the tick :P
02:28:34 <Cale> pumpkin: ah
02:28:39 <pumpkin> I started with foldl1', and then partially corrected to foldr1
02:28:41 <mmorrow> and you want left for the same reason you want left with (+)
02:29:03 <Cale> cizra: Then you need to zip in some information which indicates how you're going to order it
02:29:04 <mmorrow> (result depends on traversal of entire list)
02:29:07 <cizra> I want to sort a list of 2d points by their y value (lower first) (RWH exercise 3-12)
02:29:13 <dhun> yitz the thing I am struggling with, it that I always want to falls back to characters if nothing else works but I want don't want "[[" to be parsed into characters
02:29:15 <Cale> :t minimumBy
02:29:17 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
02:29:19 <cizra> Aha!
02:29:20 <cizra> Thanks!
02:29:26 <Cale> :t minimumBy (comparing snd)
02:29:28 <lambdabot> forall a b. (Ord b) => [(a, b)] -> (a, b)
02:29:46 <Cale> comparing is a handy function from Data.Org
02:29:48 <Cale> Ord*
02:30:08 <Cale> comparing p x y = compare (p x) (p y)
02:30:18 <mmorrow> pumpkin: oooh, this is interesting
02:30:21 <mmorrow> pumpkin: http://www.fftw.org/pldi99.pdf
02:30:44 <pumpkin> mmorrow: that's what fftw is isn't it?
02:30:58 <pumpkin> but yeah, I've been wondering how it actually works
02:31:01 <mmorrow> pumpkin: yes, but that paper describes the codegen in-depth
02:31:26 <mmorrow> (well, i guess you could always read the code..)
02:31:32 <pumpkin> it's a simple idea at the highest level I think though?
02:31:40 <mmorrow> pumpkin: totally
02:31:49 <Cale> cizra: These a -> a -> Ordering functions also have a very useful instance of Monoid. If f and g are two such comparison functions, then f `mappend` g will take f's comparison result unless it was EQ, in which case it will give g's comparison result.
02:32:09 <Cale> cizra: So we can write things like...
02:32:37 <Cale> > sortBy (comparing length `mappend` compare) (words "here are a bunch of words to sort by length and then alphabetically")
02:32:39 <lambdabot>   ["a","by","of","to","and","are","here","sort","then","bunch","words","lengt...
02:32:41 <mmorrow> pumpkin: but the sequence of graph transformations + rewriting that fftw seems to use in the fft compiler isn't trivial
02:33:35 <dhun> yitz if I use between on "[[bla" it will fail. But the fallback to characters will happen and I will get "[[bla" as list of chars, but I to parse to Wikilink, that is tagged broken
02:33:50 <earthy> ooh, that's really useful
02:34:36 <mmorrow> pumpkin: (and that most-recently-linked to paper has ml code implementing the /compiler/ part)
02:35:16 <mmorrow> hehe, he defines mapM and (>>=) in ocaml
02:35:32 <cizra> Cale: Umm. That sounds like black magic. But it's interesting.
02:35:38 <pumpkin> :o
02:35:42 * cizra tries to remember the Algebra course
02:35:48 <Cale> cizra: It's not really black magic :)
02:35:50 <pumpkin> mmorrow: we should translate it to haskell just to piss off harrop
02:35:55 <mmorrow> pumpkin: yes!!
02:36:08 <cizra> Cale: What do you mean by "instance of Monoid"? Monoid in the algebra sense, a set with a couple of operations defined on it?
02:36:19 <Cale> Yeah, or in this case, a type
02:36:28 <cizra> Type ~= set
02:36:29 <yitz> dhun: (try wikilink >>= Wikilink) <|> (try (string "[[" >>= Fail) <|> (anyChar >>= C)
02:36:35 <Cale> A type with one associative operation which has an identity
02:36:48 <yitz> dhun: maybe S String instead of C Char to be more efficient?
02:36:57 <Cale> In this case, the operation is called mappend, and the identity is called mempty
02:36:58 <cizra> Cale: And in our case, the operation is ordering?
02:37:04 <Cale> They are unfortunate names ;)
02:37:15 <cizra> oh. hm
02:37:29 <Cale> Well, first of all, these Ordering values have a Monoid instance
02:37:43 <dhun> so a>>=b is equivalent to do {a; b} ?
02:38:11 <mmorrow> do x <- a; b x
02:38:12 <cizra> Cale: What does it mean to "have a Monoid instance"?
02:38:24 <Cale> instance Monoid Ordering where
02:38:30 <Cale>   mempty = EQ
02:38:50 <Cale>   LT `mappend` y = LT
02:38:56 <Cale>   GT `mappend` y = GT
02:39:02 <Cale>   EQ `mappend` y = y
02:39:07 <yitz> dhun: do x <- a; b x is shorthand for a >>= b
02:39:16 <Cale> cizra: Do you know about typeclasses?
02:39:17 <cizra> OK, we're yak shaving here. I'm not familiar with the "instance" keyword.
02:39:21 <Cale> ah, okay
02:39:34 <cizra> I know about how Ord, Eq and the like work, more or less.
02:39:35 <dhun> ok
02:39:43 <cizra> .. intuitively.
02:39:54 <Cale> okay, so Ord, Eq, etc are not built in.
02:40:04 <Cale> They're defined in the Prelude library
02:40:07 <Cale> class Eq a where
02:40:13 <Cale>   (==) :: a -> a -> Bool
02:40:20 <Cale> class Ord a where
02:40:27 <Cale>   compare :: a -> a -> Ordering
02:40:40 <Cale> are the abbreviated versions of the classes
02:40:51 <Cale> @src Eq
02:40:52 <lambdabot> class  Eq a  where
02:40:52 <cizra> Hmm. Supposing I want to make my Points Ord, what should I do?
02:40:52 <lambdabot>     (==), (/=)   :: a -> a -> Bool
02:40:54 <Cale> @src Ord
02:40:55 <lambdabot> class  (Eq a) => Ord a  where
02:40:55 <lambdabot>     compare      :: a -> a -> Ordering
02:40:55 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
02:40:55 <lambdabot>     max, min         :: a -> a -> a
02:41:09 <cizra> Define the (==) for my Point?
02:41:19 <Cale> Yeah, in order to do that, you write an instance
02:41:19 <cizra> oops, Eq, I meant
02:41:23 <Cale> instance Eq Point where
02:41:30 <Cale>   p == q = ...
02:41:40 <cizra> OK, I see.
02:42:02 <cizra> Scrolling back up... 12:17 < Cale> instance Monoid Ordering where
02:42:20 <Cale> So that's a monoid instance for Ordering values
02:42:24 <cizra> Hmm. What is Ordering?
02:42:25 <Cale> @src Ordering
02:42:26 <lambdabot> data Ordering = LT | EQ | GT
02:42:29 <cizra> aha
02:42:34 <Cale> It's the result of an order comparison.
02:42:50 <cizra> So here you declare that the Ordering algebraic type is a Monoid.
02:43:01 <Cale> But I actually used a more elaborate monoid: my functions were of type a -> a -> Ordering
02:43:04 <cizra> ... with an identity and one operation, mappend.
02:43:06 <Cale> yeah
02:43:30 <Cale> However, there's also a monoid instance which looks like this:
02:43:43 <Cale> instance (Monoid m) => Monoid (e -> m) where
02:43:57 <Cale>   mempty x = mempty
02:44:13 <Cale>   (f `mappend` g) x = (f x) `mappend` (g x)
02:44:56 <Cale> That is, we just mappend pointwise.
02:45:08 <cizra> Cale: 10 minutes of chatting with a pro is worth days of staring into books, sometimes.
02:45:37 <Cale> and so this automatically makes  e -> Ordering  into a monoid, and then  e -> e -> Ordering  is as well
02:45:58 <cizra> That last one got me confused again. Lemme htink..
02:46:01 <Cale> and the latter type is exactly the sort of function which we pass as a comparison to sortBy/maximumBy/etc.
02:46:25 <Cale> The instance declaration says that whenever m is an instance of Monoid, then so is e -> m
02:46:35 <cizra> A function returning m?
02:46:41 <Cale> yeah
02:47:19 <Cale> So how would we combine two such functions? Well we give the function which applies them both to its argument and combines the results.
02:47:20 <dons> mmorrow: have you thought about adding a 'sizeOf' function to vacuum? i'd like to accurately measure the size of a structure
02:47:32 <cizra> instance Monoid Ordering (typeclass, type). instance Monoid (e -> m) -- you're using a function as a type here!
02:47:49 <Cale> (e -> m) is a type
02:47:56 <Cale> :t chr
02:47:59 <lambdabot> Int -> Char
02:48:05 <cizra> Well, yeah, a type of a function
02:48:10 <Cale> right.
02:48:30 <cizra> So any function that conforms to the Monoid m => (e -> m) signature .. is what?
02:48:35 <cizra> Is a monoid?
02:48:51 <Cale> Any function type which conforms is a monoid, yes
02:49:04 <hackagebot> Added by AlbertoRuiz, Mon Jun  8 09:48:28 UTC 2009.: Linear algebra and numerical computations  http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hmatrix-0.5.2.0
02:49:51 <Cale> > (id `mappend` reverse) "hello"
02:49:53 <lambdabot>   "helloolleh"
02:49:57 <cizra> So to go back up a couple of screenfuls: f `mappend` g just lets me string together a bunch of comparators.
02:50:02 <Cale> > "hello" `mappend` "hello"
02:50:03 <lambdabot>   "hellohello"
02:50:10 <Cale> yeah
02:50:46 <Cale> and the combined effect is that if the first comparator says it's less or greater, we take that as the result
02:50:46 <cizra> :t mappend fails in my ghci. Which module should I load to get it?
02:50:47 <lambdabot> parse error on input `in'
02:50:58 <Cale> and if it gives EQ, then we take the result of the second comparator
02:51:04 <Cale> Data.Monoid
02:51:22 <cizra> *nod*
02:51:45 <Cale> This is analogous to how we compare words in a dictionary by comparing the first letters and only if they match, we compare the rest
02:51:45 <cizra> Where is the code that does the "if EQ then check the other one" logic?
02:51:53 <cizra> Yes, I got that point a while ago (;
02:52:01 <Cale> In the instance of Monoid for Ordering
02:52:08 <Cale> (which is in Data.Monoid, I think)
02:52:14 <cizra> OK
02:52:23 <Cale> I wrote it above
02:52:27 <cizra> Perhaps.
02:52:37 <Cale> -- lexicographical ordering
02:52:37 <Cale> instance Monoid Ordering where
02:52:37 <Cale>         mempty         = EQ
02:52:37 <Cale>         LT `mappend` _ = LT
02:52:37 <Cale>         EQ `mappend` y = y
02:52:38 <Cale>         GT `mappend` _ = GT
02:52:48 <Cale> copy/paste from the actual library :)
02:53:01 <cizra> *whew* That was a big bunch of theory.
02:53:06 <cizra> Thank you, Cale.
02:53:11 <Cale> No problem :)
02:53:32 <cizra> I originally started learning Haskell for its brain-twisting properties. It hasn't failed me ever since.
02:53:33 <Cale> I only wish that Monoid had better syntax.
02:53:50 <Cale> mempty should be called zero or something and mappend should be called ++
02:54:29 <Cale> instance Monoid [a] where
02:54:29 <Cale>         mempty  = []
02:54:29 <Cale>         mappend = (++)
02:56:01 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Monoid.html -- there are a bunch of other instances listed here
03:03:20 <fasta> I wrote some code which should eventually lead to me getting a 2d array from an image, but unfortunately hsmagick crashes at a random packed pixel (either position 54, 56 or 57 until now) http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5645#a5645 Is my approach in some sense wrong?
03:09:21 <TheColonial> I'm a little confused why something called "point free" would involve adding '.' :)
03:10:16 <wjt> TheColonial: it's referring to http://en.wikipedia.org/wiki/Pointless_topology , not to '.'
03:10:17 <fasta> TheColonial: . is ->
03:10:47 <fasta> TheColonial: \x.x+1 has a point
03:10:50 <TheColonial> :) aye true. my bad. i just see a lot of point free examples with function composition and hence .. :)
03:11:49 <Cale> Actually, it's not typographical in any way
03:12:07 <TheColonial> Cale: how so?
03:12:16 <Cale> You think of the elements of a type as points of an abstract space
03:12:36 <Cale> A points-free definition of a function is one which doesn't explicitly mention those points
03:12:56 <Cale> (for example, because it is defined as the composite of some other functions)
03:13:24 <TheColonial> that's a good explanation :)
03:13:45 <Cale> When we write (\x -> ...), the variable x ranges over all the points of the domain.
03:14:54 * araujo working in a new language and he already was told it looks a bit like epigram :P
03:15:10 <Cale> The term comes from topology, where they really were talking about topological spaces whose elements were indeed points :)
03:15:26 <ClaudiusMaximus> some output from my untyped lambda calculus lazy graph reducer:  http://img35.imageshack.us/img35/8858/sixteen.gif   (\a.(\j.(\d.(\f.d(d f))(\s z.s(s(s(s z)))))(j a))(\f x.f x x))(\m n s z.m s(n s z))
03:16:09 <Cale> ClaudiusMaximus: cool :)
03:16:11 <hackagebot> Added by ReinierLamers, Mon Jun  8 10:15:55 UTC 2009.: Easy unit test driver framework  http://hackage.haskell.org/cgi-bin/hackage-scripts/package/testrunner-0.9
03:18:31 <araujo> ( ( . ) ( .) )  --- Point free, What separate real men from children
03:18:44 * araujo wants a t-shirt with that now
03:18:55 <mux> asymmetrical boobs?
03:19:33 <araujo> the famous boob operator, only Haskell can offer that
03:20:07 <yitz> dhun: there's a problem with your approach
03:20:15 <dhun> which one?
03:20:56 <yitz> dhun: Bad is a valid Anything. So [[[[]] can parse as Wikilink [Bad]
03:21:37 <dhun> and as what would you like to have it?
03:22:08 * mux ponders a t-shirt "Type-safe boobs"
03:22:19 <mapreduce> > let __ = (.) in @type (__.__)
03:22:20 <lambdabot>   <no location info>: parse error on input `@'
03:22:38 <yitz> dhun: I think you're better off leaving out Bad. Just have your parser fail altogether when there is no closing ]], and deal with that exception when you run the parser. Make sense?
03:23:46 <dhun> don't really understand yet, I will have to do with broken files and want to try to get some information out of them
03:24:33 <dhun> furthermore I don't know how to make the parser fail, I think I would just trigger the fallback
03:25:26 <RayNbow> :t let __ = (.) in (__.__)    -- did you mean this, mapreduce?
03:25:27 <dhun> "[[[[]]" parses as [Wikilink [Wikilink [],Bad]]
03:25:27 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
03:26:06 <dhun> that looks ok to me
03:27:25 <dhun> to me this means there is Wikilink a, a contains a wikilink b, and a is broken
03:33:52 <dhun> maybe it would be better to have [C '[',C '[', Wikilink []]
03:33:58 <dhun> it certainly would
03:41:39 <EvilTerran> dhun, i think that may make your grammar non-context-free
03:41:57 <EvilTerran> (not that that's necessarily a problem)
03:51:05 <dhun> don't really know about context free yet, have to llok up
03:52:58 <dhun> perhaps you are right can't learn the topic now
03:55:20 <hackagebot> Added by HenningThielemann, Mon Jun  8 10:54:24 UTC 2009.: Audio signal processing coded in Haskell  http://hackage.haskell.org/cgi-bin/hackage-scripts/package/synthesizer-0.2
03:58:55 <dhun> my basic idea is that I got environments, each environment has got a start parser and end parser
03:59:37 <dhun> and environment parses to MyEnvironment [Anything]
04:00:26 <dhun> where Anything=  Char c | Environronment1[Anything]|...|Environmentn[Anything]
04:33:30 <skorpan> what's up with the facebook invite on haskell-cafe?
04:34:05 <boegel> skorpan: it's funny, that's about it :P
04:34:10 <wjt> presumably someone asked facebook to invite their entire GMail addressbook
04:34:20 * boegel would love a "No, I'm not on Facebook" T-shirt
04:34:36 <skorpan> hehe
04:39:40 <osfameron> social networking sites spamming your entire address book is a Bad Thing (TM)
04:43:28 * boegel leaves to ensure students don't cheat on their Compilers exam
04:45:35 <httpwwwMariegets> http://www.marie-gets-deflowered.com/?id=54f5dc21 need 12 peolpe to enter this site so I can see more pictures
04:47:12 <httpwwwMariegets> please copy that adres and enter that site only 1 time and thats all
04:47:25 <cizra> httpwwwMariegets: Please be kickbanned ASAP
04:47:28 <cizra> that's all
04:48:02 <httpwwwMariegets> if that will help you to go to that site then OK
04:48:08 <osfameron> ops?
04:48:11 <burp> LOLO
04:48:37 <burp> just don't click
04:49:37 <cizra> Eh, Latvians, Latvians...
04:49:45 <httpwwwMariegets> why don't click , you should say just click it
04:50:16 <osfameron> @where ops
04:50:16 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
04:50:16 <lambdabot> mauke
04:50:25 --- mode: ChanServ set +o dcoutts
04:50:38 --- kick: httpwwwMariegets was kicked by dcoutts (dcoutts)
04:50:42 <osfameron> ta
04:50:57 <RayNbow> dcoutts saves the day \o/
04:51:00 <araujo> dcoutts, next time, with a message... "Fear the lambda"
04:51:04 <araujo> dcoutts, :D
04:51:07 <dcoutts> :-)
04:51:08 <araujo> dcoutts!!!
04:51:45 <Itkovian> Yeah! I love the sound of spammers kicked in the morning.
04:51:55 <dcoutts> araujo!!?!
04:52:21 * RayNbow equips lambdabot with a few weapons
04:52:26 <RayNbow> lambdabot is now an anti-spam turret :p
04:52:52 <araujo> dcoutts, how is businesses?
04:53:08 <dcoutts> araujo: good actually
04:53:34 <araujo> dcoutts, so that means... Haskell domination plans are doing good then ....
04:53:40 * dcoutts is getting paid to make ghc even more awesome
04:53:42 <dcoutts> araujo: yep
04:53:59 <araujo> yes!!!
04:54:17 * araujo thinks world domination is near 
05:03:00 <zsol> hmm
05:03:24 <zsol> are these supposed to be the same, or is GHC optimising here?
05:03:30 <zsol> hamm = let x = 1 : merge (map (*2) x) (map (*3) x) in x
05:03:31 <zsol> hamm' = 1 : merge (map (*2) hamm') (map (*3) hamm')
05:04:25 <zsol> because the first one should be using sharing while the second is just plain old recursion
05:04:34 <zsol> or am I missing something?
05:06:08 <Lemmih> zsol: They both use sharing.
05:07:08 <zsol> oh, right..
05:08:46 <zsol> oh well, back to the drawing board before I make myself any more embarassed
05:21:11 <zsol> this is what I meant: hamm' f = f : merge (hamm' (2*f)) (hamm' (3*f))
05:21:11 <zsol> and it works as expected
05:21:32 <zsol> which is sl000oo0ww :)
05:23:07 <Philonous1> > let hamm' f = f : merge (hamm' (2*f)) (hamm' (3*f)) in hamm' 3
05:23:08 <lambdabot>   Not in scope: `merge'
05:23:36 <Philonous1> Well, as ham is a function, it's return values are not memoized
05:23:50 <Philonous1> hamm' even
05:29:14 <Philonous> But I doubt this makes much of a difference
05:32:59 <RayNbow> @let mergeByR cmp fxy fx fy z = go    where go []     ys     = foldr fy z ys ; go xs     []     = foldr fx z xs ; go (x:xs) (y:ys) = case cmp x y of ; LT -> fx  x   (go xs (y:ys)) ; EQ -> fxy x y (go xs ys) ; GT -> fy    y (go (x:xs) ys)
05:33:01 <lambdabot>  Defined.
05:33:15 <RayNbow> > let merge = mergeByR compare (const (:)) (:) (:) []; merge3 as bs cs = merge as (merge bs cs); hammings = 1 : merge3 (map (2*) hammings) (map (3*) hammings) (map (5*) hammings)    in   hammings
05:33:21 <lambdabot>   [1,2,3,4,5,6,8,9,10,12,15,16,18,20,24,25,27,30,32,36,40,45,48,50,54,60,64,7...
05:43:46 <mmorrow_> pumpkin: TH-generated fully-unrolled fft's for power-of-2-length inputs up to 64 http://moonpatio.com/repos/ffts_upto_64.hs
05:44:28 <mmorrow_> (i think ghc can only handle up to a 512 fully unrolled one or so, or else compile-time goes through the roof)
05:45:37 <mmorrow_> so i guess i have to add configurable unrolling depth (and get rid of those annoying "case [a,b,c] of [c,d,e] ->"'s, even though ghc probably eliminates those anyways)
05:45:59 <ClaudiusMaximus> hmm, (\x -> x x)(\x -> x x) loops in untyped lambda calculus, but how might i go about constructing more complicated terms that loop with longer periods?
05:46:12 <mmorrow_> the y combinator is
05:46:29 <mmorrow_> (\f -> (\x -> f (x x)) (\x -> f (x x)))
05:46:39 <mmorrow_> err
05:46:45 <mmorrow_> no that's it
05:47:03 <dolio> (\x -> x x) (\x -> x x) is typically named Omega, I think.
05:48:08 <EvilTerran> mmorrow_, that looks like y to me
05:48:23 <dolio> \x -> x x being omega.
05:49:04 <EvilTerran> ClaudiusMaximus, well, you could sprinkle it with "i"s
05:49:07 <mux> I thought Omega was Turing's fixed point combinator
05:49:15 <EvilTerran> mux, iirc, that's Theta
05:49:27 <mmorrow_> EvilTerran: yeah, i confused myself for a second there
05:49:29 <mux> ah, my problem is greek letters :D
05:49:30 <dolio> Omega's a pretty over-used symbol.
05:50:25 <ClaudiusMaximus> Omega reduces to Omega in 1 step, but I want to construct some term Quux that reduces to Quux in N steps, with N large but finite
05:50:35 <mmorrow_> , "ω"
05:50:37 <lunabot>  "\969"
05:50:45 <mmorrow_> , "α"
05:50:46 <lunabot>  "\945"
05:50:53 * mmorrow_ memorizes \945
05:51:33 <EvilTerran> y = λf. (λx. f (x x)) (λx. f (x x)); ω = λx. x x; Ω = ω ω = y i
05:51:55 <mmorrow> , (text . utf8enc . take 25) ['\945'..]
05:51:57 <lunabot>  αβγδεζηθικλμνξοπρςστυφχψω
05:52:13 <mmorrow> (25 since there are two sigmas)
05:52:40 <mmorrow> (end-of-word and not)
05:53:02 <ClaudiusMaximus> all i see is boxes with a lonely pi, my font is obviously lacking
05:53:04 <dhun> I'd like to know how to stick parsers together, currently I am doing it with a lot of code
05:53:13 <dhun> http://de.wikibooks.org/wiki/Benutzer:Dirk_Huenniger/haskell
05:53:20 <EvilTerran> and Θ = (λx y. y (x x y)) (λx y. y (x x y))
05:53:31 <dhun> my parsers are dikilink and wikilink
05:53:53 <dhun> in anything I got the lines with k and k1
05:54:11 <dhun> both look very similar, is there a way to avoid typing them twice
05:54:12 <dhun> ?
05:54:25 <EvilTerran> ClaudiusMaximus, given an expression E, iE reduces to E in one step, i(iE) in two steps, etc
05:55:17 <EvilTerran> (in fact, iiE would also reduce to E in two steps)
05:56:08 <EvilTerran> ClaudiusMaximus, so (i i...i (\x.x x)) (i i...i (\x.x x)) would reduce to itself in a number of steps equal to the number of i's on each side plus 1, i think
05:56:19 <EvilTerran> ClaudiusMaximus, although of course it depends on your reduction strategy
05:56:30 <mmorrow> , foldr (.) id (replicate 1000 id) 42
05:56:32 <lunabot>  42
05:56:37 <mmorrow> , foldr (.) id (replicate 10000000 id) 42
05:56:39 <lunabot>  42
05:57:05 <mmorrow> , foldr (flip id) 42 (replicate 10000000 id)
05:57:07 <lunabot>  luna: Occurs check: cannot construct the infinite type: c = a -> c
05:57:13 <Gracenotes> hm... join (.) is twice..
05:57:23 * ClaudiusMaximus tries that
05:57:25 <mmorrow> , foldr id 42 (replicate 10000000 id)
05:57:26 <EvilTerran> when i say "E reduces to E' in N steps", i mean "there exists a reduction path from E to E' of length N"
05:57:28 <lunabot>  42
05:57:44 <mmorrow> , foldr id id (replicate 10000000 id) 42
05:57:46 <lunabot>  42
06:00:55 <fasta> Random fact: Loading an image in Haskell. Tried 3 libraries, one has missing functionality, the next segfaults and the final one gives an exception. Loading an image in Python. import Python + 2 lines to write all the image data to stdout with a very well documented library. Conclusion: library situation in Haskell is basically a joke (I don't know of any functionality that's available in Haskell which is not available on some other platform in a better way (ot
06:00:55 <fasta> her than everything needing to be pure)).
06:02:18 <dhun> like Python too, but doing haskell just because it is quite hard for me
06:02:32 <fasta> I don't like Python.
06:02:38 <EvilTerran> fasta, i'd say "conclusion: image library situation in haskell is basically a joke", tbh. i've had no trouble with, eg, writing a web scraper using someone else's HTTP and HTML libraries
06:02:58 <fasta> EvilTerran: yes, HTTP stuff worked the last time I tried it.
06:03:12 <quicksilver> fasta: pick one particular example. generalise wildly. conclusion : arguments on the internet frequently suffer from fallacies and exagerration.
06:03:25 <fasta> EvilTerran: but then again, that probably would also work in $LANG.
06:03:36 * EvilTerran once tried to write bindings to the Allegro graphics library for haskell, but got stuck because they'd used a load of #defines instead of an enum >:[
06:03:47 <quicksilver> but there certainly isn't a decent image library for haskell - or I've never found one.
06:03:59 <quicksilver> I have successfully loaded images with Wx, for what it's worth.
06:04:09 <quicksilver> (without actually using Wx for the rest of the application, or not necessarily)
06:04:29 <PeakerWork> SDL image, maybe?
06:04:31 <EvilTerran> fasta, well, i did try implementing it in perl first; wrote a few hundred lines of code, and couldn't work out why they didn't work, so then switched to haskell and wrote something that worked as soon as it typechecked
06:04:39 <EvilTerran> (and was a quarter of the length)
06:04:42 <Axman6> Tried to write fast concurrent programs, got them working far easier than i expected, and was pleasently surprised. conclusion: haskell should replace all languages used for programming of any kind
06:04:50 <fasta> EvilTerran: Haskell is not a bad language for doing things from scratch.
06:04:59 <fasta> EvilTerran: in fact, it's a quite good language.
06:05:16 <EvilTerran> i agree that haskell's library situation isn't anywhere near as advanced as, eg, perl, python, C, etcetc
06:05:21 <EvilTerran> but we're working on it
06:05:56 <fasta> The problem is that porting a library requires work, instead of it just being there.
06:06:16 <Axman6> and there was no work writing those libraries in other languages?
06:06:18 <fasta> There is no fundamental reason why one cannot automate more of the porting.
06:06:24 <Axman6> i find that hard to believe
06:06:57 <Axman6> fasta: the thing is, you can do a direct binding to other libraries, but they don't end up being very haskell like
06:07:08 <EvilTerran> it's harder to nicely bind C libraries to haskell than to imperative languages, though; that's probably a contributing factor
06:07:11 <CSWookie> So, I'm wanting to have a loop, a mapping object, and a list which I append values to.  Am I thinking about this wrongly for Haskell?
06:07:37 <Saizan> mapping object?
06:07:42 <Axman6> CSWookie: not necessarilly, but appending to a list is usually a bad idea
06:07:58 <PeakerWork> CSWookie: you probably just want a map, or a list comprehension
06:07:58 <Saizan> and thinking in "loops" is not particulary haskelly
06:08:02 <EvilTerran> and we don't really have loops
06:08:08 <EvilTerran> or objects :P
06:08:16 <Saizan> or lists!
06:08:25 <EvilTerran> ... we've got lists. shush.
06:08:38 <Axman6> no, we've got [] a's
06:09:00 <EvilTerran> we've probably got a wider variety of linear containers than most languages
06:09:14 <EvilTerran> lists, arrays, sequences, bytestrings...
06:10:06 <fasta> EvilTerran: C++ probably has more.
06:10:18 <dhun> an especially user declared infix operators :-)
06:10:24 <FunctorSalad> random thought... could [] be implemented as a hybrid array/linked thing like (I think) lazy bytestrings are?
06:10:37 <FunctorSalad> (with the arrayness hidden)
06:10:56 <EvilTerran> fasta, well, haskell and C++ both have a countable infinity of 'em, if you squint right ;)
06:11:34 <fasta> EvilTerran: sure, I was just talking about a practical thing.
06:12:01 <EvilTerran> i've not subjected myself to enough C++ to be sure, so i'm happy to take your word for it
06:19:56 <dhun> how can I convert a Parser String to a Parser ()
06:20:00 <hackagebot> Added by NeilBrown, Mon Jun  8 13:19:18 UTC 2009.: Generic programming library  http://hackage.haskell.org/cgi-bin/hackage-scripts/package/alloy-1.0.0
06:20:06 <wjt> dhun: >> return ()
06:21:24 <dhun> you mean >>= ?
06:21:25 <EvilTerran> ?type (>> return ())
06:21:26 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
06:21:34 <EvilTerran> ?type (>>)
06:21:35 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
06:21:52 <EvilTerran> dhun, (>>) just sequences, it throws away the result of its first parameter
06:21:54 <EvilTerran> ?src (>>)
06:21:55 <lambdabot> m >> k      = m >>= \_ -> k
06:22:29 <EvilTerran> m >> k  =  m >>= const k
06:22:42 <dhun> I see
06:23:02 <Axman6> > [1,2,3] >> "abc"
06:23:03 <lambdabot>   "abcabcabc"
06:23:04 * EvilTerran suspects (>>= return ()) would produce some incomprehensible error message about () not being a monad
06:23:20 <EvilTerran> ?type (>>= return ())
06:23:21 <lambdabot>     Couldn't match expected type `m b' against inferred type `()'
06:23:22 <lambdabot>     In the first argument of `return', namely `()'
06:23:22 <lambdabot>     In the second argument of `(>>=)', namely `return ()'
06:24:18 <paolino> @seen dcoutts
06:24:18 <lambdabot> dcoutts is in #haskell-soc, #haskell-in-depth, #gentoo-haskell, #darcs, #ghc, #haskell-overflow and #haskell. I last heard dcoutts speak 23s ago.
06:24:43 <RayNbow> :t (>>= const$return ())
06:24:45 <lambdabot>     The operator `>>=' [infixl 1] of a section
06:24:45 <lambdabot>         must have lower precedence than that of the operand,
06:24:45 <lambdabot>           namely `$' [infixr 0]
06:24:54 <RayNbow> :t (>>= const (return ()))
06:24:55 <lambdabot> forall a (m :: * -> *). (Monad m) => m a -> m ()
06:33:08 <sinelaw> can someone explain the advantages of using Lava (or York Lava) instead of just writing VHDL?>
06:34:06 <PeakerWork> sinelaw: hey
06:34:16 <PeakerWork> @where lava
06:34:16 <lambdabot> I know nothing about lava.
06:34:20 <PeakerWork> @go lava
06:34:21 <lambdabot> http://en.wikipedia.org/wiki/Lava
06:34:21 <lambdabot> Title: Lava - Wikipedia, the free encyclopedia
06:34:30 <sinelaw> not that :)
06:34:34 <fasta> quicksilver: did anything happen to my bugreport?
06:34:57 <sinelaw> http://raintown.org/lava/
06:35:39 <fasta> sinelaw: currently there are no advantages, AFAIK.
06:35:49 <quicksilver> fasta: I can't remember what it was about, now ;)
06:36:03 <sinelaw> fasta, and eventually?
06:36:10 <sinelaw> i mean, what's the point
06:36:19 <fasta> sinelaw: It is meaningless to describe hardware in a description language which has no back-end that actually exists.
06:36:58 <sinelaw> what?
06:37:02 <fasta> sinelaw: eventually, it might be a good idea.
06:37:33 <RayNbow> hmm, Haskell-Cafe doesn't set the reply-to header?
06:37:38 <fasta> sinelaw: the idea of Lava should be that you describe your stuff in Lava and that some hardware company takes that description and gives you your hardware within some time.
06:37:46 <ClaudiusMaximus> EvilTerran: sprinkling i's (if by i you mean (\y.y)) didn't work (at least with my reduction strategy, being lazy evaluation/graph reduction) - reached the same cycle of 3 graphs (x -> y -> z -> x) as Omega did   (sorry for delay, i accidentally DOS'd myself)
06:38:05 <fasta> sinelaw: I don't think there is any company who accepts Lava as input currently or accepts anything which is the output of Lava.
06:38:17 <fasta> sinelaw: but it has been some time that I have taken a look at Lava.
06:38:23 <fasta> sinelaw: things might have changed.
06:38:29 <sinelaw> fasta, ok. i thought VHDL (or verilog) was exactly that
06:38:44 <fasta> sinelaw: VHDL has industry support.
06:39:12 <EvilTerran> ClaudiusMaximus, hm, that's strange
06:39:25 <fasta> sinelaw: oh, it seems they do have such a backend.
06:39:32 <fasta> sinelaw: so, maybe it is actually useful :)
06:39:33 <sinelaw> they convert it to VHDL
06:40:28 <EvilTerran> ClaudiusMaximus, surely (taking i = \x.x, w = \x.xx): iw(iw) -> w(iw) -> iw(iw)
06:40:31 <fasta> sinelaw: but I don't think it is very advanced; there is no routing in it etc.
06:40:45 <EvilTerran> and iiw(iiw) -> iw(iiw) -> w(iiw) -> iiw(iiw)
06:40:49 <sinelaw> ok
06:40:56 <EvilTerran> with leftmost reduction
06:42:33 <EvilTerran> ClaudiusMaximus, or does your reduction strategy exploit sharing?
06:43:05 <ClaudiusMaximus> EvilTerran: with lazy evaluation, iiw(iiw) -> iw(iiw) -> w(iiw) -> let x = iiw in x x -> let x = iw in x x -> let x = w in x x -> w w
06:44:20 <CSWookie> Hmm.  I'll let this cogitate on a back burner for a while (I imagine at least a week), and come back to it this weekend.
06:44:22 <EvilTerran> i see; it's the sharing that's preventing it from taking longer
06:45:09 <EvilTerran> i'm not sure how you'd subvert that aspect of lazy evaluation
06:46:07 <hackagebot> Added by HenningThielemann, Mon Jun  8 13:41:47 UTC 2009.: Fast, packed, strict storable arrays with a list interface like ByteString  http://hackage.haskell.org/cgi-bin/hackage-scripts/package/storablevector-0.2.3
06:46:13 <ClaudiusMaximus> nor i.  perhaps i'm trying to achieve the impossible (again)
06:46:36 <HugoDaniel> hi
06:47:44 <paolino> is it ever possible to write a MonadState instance for IO ?
06:48:30 <dhun> can I write that more concise (like assuming wikilink and dikilink to be elements of a list) 		k<-app wikilink p b [Empty]
06:48:31 <dhun> 		;k1<-app dikilink p b k
06:50:27 <doserj> k1 <- app wikilink p b [Empty] >>= app dikilink p b, if you want to avoid naming the intermediate k
06:50:35 <dhun> ok
06:50:58 <mmorrow> paolino: sure, use an IORef or MVar
06:51:01 <paolino> I wrote a MonadState r for ReaderT (TVar r) IO, but I cannot use it as callback to "on" functions in gtk2hs, as they must be pure IO
06:51:22 <dhun> but if I got [wikilink, dikilink. blahlink], can I do it with the list at once
06:51:26 <mmorrow> hmm, actually you'd have to keep a ref to the IORef/MVar..
06:51:34 <paolino> eh
06:51:35 <mmorrow> which i'm not sure you could do without globals
06:53:09 <hackagebot> Added by HenningThielemann, Mon Jun  8 13:52:28 UTC 2009.: Audio signal processing coded in Haskell  http://hackage.haskell.org/cgi-bin/hackage-scripts/package/synthesizer-0.2.0.1
06:54:24 <paolino> :t unsafePerformIO $ newIORef 0
06:54:25 <lambdabot> Not in scope: `unsafePerformIO'
06:54:25 <lambdabot> Not in scope: `newIORef'
06:54:41 <paolino> mmorrow: that is a global ?
06:54:43 <doserj> dhun: sth like foldM (\x f -> app f p b) [Empty] [wikilink, dikilink, blahlink] could work
06:54:47 <mmorrow> paolino: yes
06:54:54 <dhun> ok
06:55:11 <doserj> err, foldM (\x f -> app f p b x) ..., of course
06:55:15 <mmorrow> paolino: (if you use an IORef and you're concurrent, be sure to use atomicModifyIORef)
06:55:36 <paolino> mmorrow: will it work inside the MonadState methods ?
06:55:53 <mmorrow> paolino: you could make it to, but it'd be hacky
06:56:15 <mmorrow> ooh, i think you can actually write a wrapper function to do what you want
06:56:18 * mmorrow thinks
06:56:27 <paolino> more then gtk2hs ? :)
06:56:44 <Saizan> paolino: you can use ReaderT (IORef a) IO
06:56:51 <Saizan> paolino: instead of globals
06:57:14 <Saizan> paolino: it's easy to convert that to an IO action
06:57:32 <Saizan> (that you can pass to callbacks)
06:59:32 <paolino> but I lose the state monad, then
07:00:31 <dhun> did app2 l p b k= do {k1<-app (head l) p b k;app2 (tail l) p b k1}
07:00:36 <dhun> seems to work
07:00:47 <dhun> but maybe yours is more elegant
07:01:04 <paolino> Saizan: the monad must implement MonadState and be called inside a callback
07:01:44 <paolino> mhh, must think actually
07:01:51 <fasta> quicksilver: the bug was about the Emacs mode.
07:01:56 <doserj> dhun: you have en extra base case for app2 [], I hope?
07:02:06 <dhun> yes of course
07:04:13 <Saizan> paolino: you can implement MonadState for that type
07:05:18 <Saizan> paolino: get = do ref <- ask; lift $ readIORef ref; put x = do ref <- ask; lift $ writeIORef ref x
07:05:23 <quicksilver> fasta: oh that one. No, no response :( Maybe he's on holidays.
07:05:26 <Baughn> > (\False -> 1; \True -> 2) False -- ..somehow, I don't think so
07:05:29 <lambdabot>   <no location info>: parse error on input `;'
07:06:38 <Baughn> But shouldn't it be possible to do that, logically speaking?
07:06:46 * EvilRanter has seen proposed syntax "(case of False -> 1; True -> 2) False" for that
07:07:21 <Baughn> EvilRanter: I remember that. Mine's more general, though; consider having multiple parameters
07:07:30 <Baughn> Although I'm not sure it doesn't collide with existing syntax
07:07:39 <EvilRanter> as it stands, i guess you have to write (let f False -> 1; f True -> 2 in f) or (\x -> case x of ...)
07:07:56 <Baughn> You could do that.
07:08:08 <Baughn> Of course, that's verbose. And part of the reason why haskell works so well is that lambda is \.
07:08:44 <EvilTerran> true
07:10:30 <EvilTerran> with appropriate monoid instances etc, and the proposed (|PAT -> EXP) --> (\x -> case x of PAT -> Just EXP; _ -> Nothing) de-sugaring i've seen
07:10:47 <EvilTerran> you could make that ((|False -> 1) ++ (|True -> 2))
07:11:02 <mmorrow> paolino: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5651#a5651
07:11:50 <conal> EvilTerran: i guess one could also drop the Maybe and use unamb
07:11:56 <conal> oops -- i mean lub
07:12:16 <EvilTerran> conal, what, (\False -> 1) `lub` (\True -> 2) ?
07:12:24 <conal> EvilTerran: exactly
07:12:39 <EvilTerran> that's... evil genius material :D
07:12:45 <conal> :)
07:12:53 <RayNbow> lub..? least upper bound?
07:13:00 <conal> RayNbow: yeah
07:13:07 <RayNbow> ok :)
07:13:07 <conal> @hackage lub
07:13:07 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/lub
07:13:48 * EvilTerran notes that, while it intuitively looks like it might break lub's contract, it actually doesn't
07:13:50 <conal> and http://conal.net/blog/tag/lub/
07:13:54 <mmorrow> paolino: ooh, actually that doesn't even need the IORef
07:14:00 <EvilTerran> because, if one side is defined at all, the other side will be _|-
07:14:03 <EvilTerran> er, _|_
07:14:14 <conal> yeah.  nice :)
07:14:21 <EvilTerran> it's very cheeky, though
07:14:30 <conal> EvilTerran: lub's contract is looser than unamb's
07:15:25 <Saizan> well, only if the patterns don't overlap
07:15:41 <mmorrow> paolino: tunnel callback k = do r <- ask; liftIO (k (flip runReaderT r . callback))
07:15:47 <Saizan> and you mean \arg -> (\False -> 1) arg `lub` (\True -> 2) arg, right?
07:15:47 <EvilTerran> Saizan, yeah, that's what i mean; or at least, the result has to be the same where the patterns overlap
07:16:05 <conal> EvilTerran: it only has to be consistent, not necessarily the same
07:16:21 <mmorrow> paolino: tunnel :: (a -> ReaderT r IO b) -> ((a -> IO b) -> IO c) -> ReaderT r IO c
07:16:21 <EvilTerran> that's also what i meant
07:16:27 * EvilTerran is insufficiently familiar with lub to be entirely coherent about it :P
07:16:35 <paolino> mmorrow: thanks , I was there too :)
07:16:40 <Baughn> conal: I see what you're doing there. However, don't you think lub is just a /little/ too heavyweight for this?
07:16:44 <mmorrow> paolino: :)
07:16:49 <paolino> and Saizan
07:16:54 * CSWookie wonders if EvilTerran forgot an 'e', there...
07:17:13 <EvilTerran> ... or to be sure if it's okay to lub two partial functions together instead of lub'ing their results
07:17:16 <conal> Baughn: semantically heavyweight?
07:17:27 <Baughn> conal: No, implementation-wise heavyweight
07:18:07 <conal> Baughn: for the current implementation.
07:18:28 <Baughn> conal: Point. Though I don't think you can do without threads while still handling infinite loops.
07:18:29 <dolio> The Maybe version is probably more heavyweight than you'd really want.
07:18:50 <EvilTerran> dolio, yeah, i suspect CPS-transforming it would be worthwhile
07:18:51 <quicksilver> I'm not sure if this is what "Semantically heavyweight" means
07:19:00 <quicksilver> but lub is non-monotonic, isn't it?
07:19:04 <conal> Baughn: without digging into the RTS?
07:19:15 <Baughn> conal: Even /with/ digging into the RTS
07:19:24 <conal> quicksilver: it's monotonic in each argument.
07:19:56 <conal> quicksilver: which means its monotonic as a curried function.
07:19:57 <EvilTerran> maybe something like (|PAT -> EXP) --> (\next x -> case x of PAT -> EXP; _ -> next x)
07:19:59 <Baughn> conal: You can't /detect/ infinite loops, you can just try to spread your effort and hope one branch succeeds. Such spreading is, in itself, a thread.
07:20:04 <quicksilver> conal: not, it's not.
07:20:13 <quicksilver> conal: hmm.
07:20:16 <quicksilver> conal: maybe it is :)
07:20:51 <conal> quicksilver: if you know more about a or b, then you know more about a `lub` b
07:20:58 <EvilTerran> which'd get us "(|False -> 1) (|True -> 2) undefined" (or whatever)
07:21:12 <EvilTerran> well, with more parentheses
07:21:25 <conal> Baughn: yeah.  in a broad sense of "thread".
07:21:57 <Baughn> conal: Well, you would be stuck with the stack-freezing machinery and such that is the cause for threads being as costly as they are, so.. :)
07:22:47 <yowgi> hello.
07:22:49 <yowgi> > let f (x+1) = x in f 43 -- is this standard or just GHC?
07:22:50 <lambdabot>   42
07:23:02 <yowgi> (the x+1 part)
07:23:06 <RayNbow> n+k patterns?
07:23:07 <doserj> standard
07:23:09 <dolio> Standard, but unpopular.
07:23:14 <Saizan> lub does something more than what you actually want here, though, you want committed choice, while lub is more like "merged" non-determinism
07:23:15 <conal> Baughn: perhaps.  when implemented at run-time.
07:23:39 <yowgi> ok, thanks!
07:23:45 <conal> Baughn: i'm generally reluctant to say how things must be done, since often there's lots of room for creativity.
07:24:33 <Baughn> conal: Hm. There are some optimizations, I suppose..
07:24:53 <conal> Baughn: yeah.  lub is semantically foundational, so i wouldn't be surprised to see a compiler do smart things with it.
07:25:35 <Saizan> you can apply the optimizations some compilers for logic languages do
07:25:35 <Baughn> conal: Even with the current ghc, we only need to fork threads when trying to evaluate one branch takes a while, but never actually blocks or crashes
07:26:04 <Baughn> conal: It /might/ be useful to put a timeout on that, and only start evaluating the second in parallel if the first doesn't finish or crash within some period of time. Needs measurement.
07:26:29 <EvilTerran> , [x | x@(even->True) <- [1..]]
07:26:30 <lunabot>  [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,5...
07:26:43 <EvilTerran> yaay
07:27:24 <conal> Baughn: reminds me of research on speculative evaluation, which may relate.
07:27:33 <Baughn> conal: We could start by throwing the second thread into a spark, so if there's a free capability it'll run it anyhow
07:27:50 <alexsuraci> Anyone know how I'd fix this strange type error: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5652#a5652
07:27:54 <Baughn> Though, then unamb/amb would need to execute differently from race
07:27:55 <ski> hm
07:27:56 * EvilTerran notes that var@(f -> pat) could be a pretty useful idiom
07:28:01 <ski> , [x | x | even x <- [1..]]
07:28:02 <lunabot>  luna: Parse error in pattern
07:28:08 <ski> (:
07:28:32 <dolio> > filter even [1..]
07:28:33 <lambdabot>   [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
07:28:34 <EvilTerran> alexsuraci, i suspect you're somehow using two different versions of Socket
07:28:36 <conal> Baughn: i'm happy for the implementation to change radically.  it's really unamb & lub i care about.  not amb or race.
07:29:19 <alexsuraci> EvilTerran: The type headers in Network.Socket.ByteString.Lazy's source use the same Socket
07:29:26 <quicksilver> conal: On the other hand lub is nondeterministic, and it might seem heavyweight to try to use a nondeterministic construct to add a new deterministic construct to a deterministic language.
07:29:27 <alexsuraci> For send, etc.
07:29:41 <conal> quicksilver: lub is nondeterministic??
07:29:57 <Baughn> conal: I'm getting quite a large number of ideas for optimizations I can only test out after ghc (and then reative) have been fixed. I really hope that's soon..
07:30:07 <conal> quicksilver: oh -- i think i know what you mean.
07:30:08 <quicksilver> conal: what is the value of (1:xs) `lub` (2:xs) ?
07:30:27 <EvilTerran> quicksilver, mu, you've broken the contract
07:30:31 <conal> quicksilver: lub imposes a semantic restriction that "|" doesn't.
07:30:57 <quicksilver> the language I'm working in doesn't have a way to attach semantic restrictions to functions ;)
07:31:23 <quicksilver> all it has is a type system, and if the type system permits a term - which is a static property - then the term is well formed, well typed, and must have a denotation.
07:31:27 <conal> quicksilver: not only that, but case allows its cases to disagree
07:31:33 <quicksilver> apologies for getting oldfashioned/pedantic ;)
07:31:44 <quicksilver> so "lub" is not a well-defined term former.
07:31:55 <quicksilver> the only way to make it monotonic is to make it nondeterministic.
07:32:24 * EvilTerran suddenly gets what quicksilver means by "monotonic"
07:32:27 <conal> quicksilver: or partial
07:32:41 <quicksilver> conal: I don't think so , no.
07:32:43 <Saizan> the partiality breaks monotonicity
07:32:51 <conal> i didn't mean that kind of partial
07:33:00 <quicksilver> conal: _|_ `lub` (1:xs) is (1:xs)
07:33:15 <quicksilver> conal: meanwhile (2:xs) `lub` _|_ is (2:xs)
07:33:40 <quicksilver> therefore (1:xs) `lub` (2:xs) *must* be at least as defined as (1:xs), (2:xs)
07:33:43 <quicksilver> which is impossible, of course
07:33:51 <quicksilver> (1:xs) and (2:xs) have no common upper bound.
07:33:58 <quicksilver> so you have to go nondeterministic.
07:34:03 <EvilTerran> fork the universe!
07:34:19 <hackagebot> Added by NeilBrown, Mon Jun  8 14:33:16 UTC 2009.: Some add-on instances for the Alloy library  http://hackage.haskell.org/cgi-bin/hackage-scripts/package/alloy-proxy-fd-1.0.0
07:34:22 * ski supposes it could be assymmetric, instead
07:34:27 <conal> quicksilver: or don't go at all.  two different notions of partiality.
07:34:37 <quicksilver> conal: I don't know what you mean?
07:34:59 <quicksilver> ski: if it was left-favouring, so that the value chosen is (1:xs), that's a contradiction.
07:35:08 <quicksilver> ski: monotonicity says it must be a refinement of (2:xs)
07:35:13 <ski> ah, i see
07:35:36 <mxc> anyone here familiar with the FIX protocol?
07:36:20 <hackagebot> Added by GregoryCrosswhite, Mon Jun  8 14:35:37 UTC 2009.: Haskell values that cannot be evaluated immediately.  http://hackage.haskell.org/cgi-bin/hackage-scripts/package/procrastinating-variable-1.0.2
07:36:47 <quicksilver> lest anyone think I'm being too oldfashioned and pedantic, I'm not saying that "lub" isn't interesting, or fun, or a worthy thing to discuss and research.
07:36:57 <quicksilver> I'm just trying to point out it's incompatible with the static semantics of haskell.
07:37:03 <quicksilver> you've made the language something new.
07:37:19 <dhun> I got a parser for nested environments no and I am very happy about it
07:37:33 <Baughn> quicksilver: The way I read par, it does 'setPriority None . forkIO . evaluate', semantically speaking. That's well and good, but is there a setPriority call I could use on ordinary threads?
07:37:37 <conal> quicksilver: in that i've ventured outside of the type system to impose additionally partiality on the semantics.
07:38:16 <quicksilver> Baughn: sparks are different from forkIO'd threads.
07:38:17 <Baughn> quicksilver: (I want to spark a low-priority evaluation. I then want to kill it if it turns out to be unnecessary.)
07:38:18 <thomastc> @seen nominolo
07:38:18 <lambdabot> I saw nominolo leaving #haskell-soc, #yi, #ghc, #haskell-in-depth and #haskell 4d 17h 54m 22s ago, and .
07:38:25 <quicksilver> Baughn: they're *even* *more* lightweight than threads.
07:38:41 <quicksilver> Baughn: JaffaCake is probably the only person in IRC who really understand them at the level you're asking, though.
07:39:05 <conal> quicksilver: in that (1:xs) `lub` (2:xs) is not a meaningful expression, although it's type-correct.
07:39:07 <Baughn> quicksilver: I'll ask him, I suppose. I'd be happy with ordinary threads, though, I just want to reduce their priority.
07:39:17 <quicksilver> conal: which is quite a big semantic price to pay. (It might be worth paying, perhaps)
07:39:59 <conal> quicksilver: short of full dependent types, i think we'll always have contracts that the type system fails to capture.
07:39:59 <quicksilver> conal: by making the entire semantics partial - rather than merely modelling partiality within the semantics - you have broken various rules of the rewrite system.
07:40:11 <conal> quicksilver: another example is fromAscList
07:40:19 <quicksilver> well, it's not really the same.
07:40:26 <quicksilver> fromAscList obeys its type
07:40:36 <quicksilver> it just produces a value which is an ADT with a broken invariant.
07:40:39 <Baughn> JaffaCake: Might it be possible to abort a spark if I find out later that, no, I don't really need it (but can't have it GCed)? Or reduce the priority of an ordinary thread so it acts more like a spark?
07:40:58 <conal> quicksilver: the *semantics* of fromAscList as a map is undefined when the invariant is broken.
07:41:05 <JaffaCake> neither is supported right now
07:41:17 <conal> and not in the sense of _|_.  in the sense that it's not meaningful.
07:41:23 <Baughn> Could they be, or would it require major redesign?
07:41:38 <quicksilver> sure, but that's a different level of semantic interpretation.
07:41:59 <conal> quicksilver: yeah.
07:42:01 <quicksilver> fromAscList [(2,2),(1,1)] is a perfectly valid haskell value
07:42:12 <conal> quicksilver: just not a valid map
07:42:13 <quicksilver> it has a perfectly well understood denotation.
07:42:23 <conal> quicksilver: as a representation, but not as a map
07:42:23 <quicksilver> it violates an API contract, that's all.
07:42:43 <quicksilver> whereas (1:xs) `lub` (2:xs) is what, a runtime error?
07:43:03 <quicksilver> ...it can't be a runtime error, because that violates monotonicity ;)
07:43:25 <quicksilver> it has to be a deep dark hole in our semantics which is somehow not _|_
07:43:30 <quicksilver> like a meta-_|_
07:44:20 <conal> quicksilver: like the fromAscList example, it's a failure of the type system to reject an expression that does not denote a value of the semantic type i care about.
07:45:05 <conal> quicksilver: and i see the difference you're pointing out about these levels of meanings.
07:45:48 <frwmanners> lub :: a -> a -> Maybe a
07:45:49 <lambdabot> frwmanners: You have 1 new message. '/msg lambdabot @messages' to read it.
07:46:23 <Axman6> @djinn a -> a -> Maybe a
07:46:24 <lambdabot> f _ a = Just a
07:46:24 <quicksilver> conal: breaking monotonicity is fairly deep, though. Break monotonicity and you lose the fixed point theorem.
07:46:30 <quicksilver> recursion "doesn't work" any more.
07:46:37 <frwmanners> lub _|_ 4 = Just 4
07:46:39 <conal> frwmanners: the difficulty with that type is that it's undecidable whether two values are consistent.
07:46:56 <frwmanners> Could be inconvenient
07:47:14 <frwmanners> True
07:47:14 <conal> frwmanners: hm.  i didn't think through that claim very carefully.
07:47:47 <frwmanners> conal: no, you're right.  If we hide the result in a Maybe we lose the entire point
07:48:05 <conal> quicksilver: i agree with you that monotonicity is fundamental to denotational semantics.
07:48:22 <quicksilver> I strongly suspect it breaks static optimisations, too
07:48:26 <quicksilver> although I'm not sure.
07:50:12 <hashkool> why do I get an occurs check in xpath [http://www.mibbit.com/pb/gqSqNB ]
07:50:19 <leimy> SnoLepfail?
07:50:24 <leimy> oops !
07:50:27 <leimy> wrong channel
07:50:30 <leimy> hi Conal! :-)
07:50:42 <conal> hi leimy !
07:51:00 <leimy> conal: how are things in the land of reactive programming?
07:51:41 <conal> leimy: there seems to be some frp energy stirring.  my head has been more in functional GPU programming.
07:52:06 <Saizan> hashkool: hard to tell without the definition of Rep
07:52:14 <conal> leimy: what new with you?
07:52:23 <EvilTerran> hashkool, i think we may need to see the Reps module
07:52:46 <leimy> conal: oh not too much.. been working to keep the dream alive :-)  You know cuz it takes team work, to make the dream work.
07:52:48 <doserj> hashkool: the type signature says that the second argument of xpath is of type 'a'. But you pattern match on it?
07:53:04 <leimy> In other words I was at a customer site for 4 days (including working the weekend) in a small box, collecting data.
07:53:27 <conal> leimy: was that any fun at all?
07:53:37 <leimy> Actually it was surprisingly nice in there... but loud
07:53:40 <hashkool> Saizan: see here http://www.mibbit.com/pb/lPt77G  :-)
07:53:51 <leimy> We make this mobile containers.  they're little portable datacenters
07:54:05 <LeCamarade|Away> I've failed to get any PostgreSQL bindings that work.
07:54:10 <leimy> they're pretty darned "green", in that they're efficient.
07:54:18 <LeCamarade|Away> Even Takusen, which installed fine, didn't have the modules.
07:54:20 <leimy> And you can load em on a truck and move them :-)
07:54:29 <LeCamarade|Away> I'd have none of my current problems. :o(
07:54:34 <leimy> This was the first one I've seen, and it's a project I've been working on for months
07:54:34 <conal> leimy: wow
07:54:45 <leimy> The remote management system uses Erlang
07:54:59 <leimy> and the simulations I've been building to work against it are in Haskell :-)
07:55:12 <leimy> So all in all it was pretty freaking fun :-)
07:55:15 <leimy> but tiring.
07:55:28 <conal> leimy: cool! :)
07:55:31 <leimy> Of course the customers don't see Erlang, they see SNMP agents :-)
07:55:44 <EvilTerran> hashkool, it seems you're trying to use different types in different patterns on the second parameter of xpath
07:55:48 <leimy> And I was thinking that I wish I could have done the whole system in Haskell instead.
07:55:55 <leimy> but for lack of good SNMP libraries for Haskell
07:56:08 <EvilTerran> hashkool, if you want to do that, you're going to need to make xpath a method of a typeclass parameterised by xpath's second parameter
07:56:31 <leimy> I've been bitten by quite a few type-safety issues here and there.  And I was wondering about Reactive, and binary streams of network data.
07:56:56 <leimy> But I've yet to really dig into Reactive, so it was just a  casual wondering :-)
07:57:26 <conal> leimy: yeah.  might be cool to explore a genuinely functional approach to what you're doing.  whether frp or not.
07:57:26 <EvilTerran> hashkool, think "class Xpath a where xpath :: Rep a -> a -> [String] -> [a]
07:57:27 <EvilTerran> ; instance Xpath UnitT where xpath RUnit Unit ...""
07:58:07 <leimy> conal: yeah.  I was just thinking that SNMP requests are just "events".  Polling to fill up a cache is an event.  Asynchronous events are just events.  And evaluating stuff to produce a trap is just an event :-)
07:58:17 <leimy> So why not a Reactive SNMP agent implementation framework?
07:58:23 <conal> maybe so
07:58:31 <quicksilver> leimy: One of my concerns about using reactive to process realtime data streams is I suspect it won't degrade gracefully if data comes in too fast.
07:59:08 <hashkool> EvilTerran: In what cases do I not return [a]? Using classes is the method which is taken in EMGM, I need to use the LIGD-approach (if this sounds familiar to you)
07:59:32 <leimy> quicksilver: That's a problem with any asynchronous-response system though right?
07:59:36 <conal> quicksilver: and not just reactive, but perhaps *any* semantically precise framework.
07:59:37 <leimy> in that you can get flooded :-)
07:59:43 <quicksilver> conal, leimy: yes.
08:00:03 <quicksilver> however, I thik people are more familiary with teh memory-management and degradation modes of (say) a system written in C.
08:00:23 <leimy> yeah.... that's trick
08:00:23 <leimy> y
08:00:26 <EvilTerran> hashkool, i'm not familiar with those acronyms
08:00:29 <quicksilver> would a haskell-reactive system start slowing down and getting timestamps wrong? would it catastrophically spiral into swap?
08:00:46 <quicksilver> would it continue to produce output fine, just lagging further and further behind?
08:00:48 <EvilTerran> hashkool, and i didn't say anything about the return type; the problem is the type of the second parameter
08:00:54 <quicksilver> if the input paused, would it eventually catch up?
08:01:02 <quicksilver> I don't suggest these problems are insoluble.
08:01:04 <leimy> That was a big concern of mine.  I don't necessarily understand how to look at Haskell code yet, and see how the size of data grows
08:01:09 <quicksilver> I'm sure they're eminently soluble :)
08:01:13 <leimy> Lazy languages with all the thunking and what-not :-)
08:01:13 <quicksilver> I just think they need thinking about.
08:01:14 <conal> leimy, quicksilver: i'd suggest defined the desired semantics first.  and only then see if it matches frp semantics.
08:01:34 <hashkool> EvilTerran: not really too important, but EMGM is an haskell package for generic programming
08:02:37 <hashkool> Thanks for your feedback. I only don't see where I change the second parameter
08:03:56 <leimy> conal: makes sense.  The whole world isn't a nail because you've got a shiny, new hammer :-)
08:04:29 <PeakerWork> I think the goal is to have functional systems that react to the world. So if FRP means just that -- its probably just going to morph into whatever does that properly :-)
08:04:52 <conal> quicksilver: i'm summarizing our earlier semantic discussion in my notes, and i want to make sure i've captured it.  i think the essence of your point is this: unamb and lub introduce a new element to haskell programming in that we no longer have a monotonic semantics that is defined on all well-typed expressions.
08:04:57 <EvilTerran> hashkool, Unit is of type UnitT, (Prod a b) is of type (Prod something something), etc; you're using those as patterns in the second parameter
08:05:08 <EvilTerran> hashkool, but a parameter to a function has to always be the same type
08:05:14 <akamaus> greetings. I'm thinking about embedding .glade file into a haskell string in order to get a standalone executable. Can I use a cabal for such kind of preprocessing?
08:05:57 <conal> PeakerWork: yeah.  i think of "frp" very loosely as a functional/denotational approach to time-varying whatever.  it'll evolve.
08:06:18 <conal> i.e., work-in-progress
08:06:19 <dcoutts> akamaus: there's no special support but you can write code to generate modules in Setup.hs
08:06:45 <Saizan> EvilTerran: but Rep is a GADT
08:06:58 <Saizan> EvilTerran: so 'a' is refined by the constructor
08:07:18 <EvilTerran> Saizan, uh... does it really work that way?
08:08:24 <conal> quicksilver: did i get the essence of your remarks on lub?
08:08:34 <Saizan> EvilTerran: yes
08:09:17 <akamaus> dcoutts,  Can you please point me the api? Right now I'm looking at Distribution.Simple.PreProcess, but seems it's not what I need.
08:09:40 <Saizan> hashkool: the problem is that xpath ra a cns :: [x] while the result type of that branch must be [Sum x t]
08:10:00 <Saizan> hashkool: because the 'a' in the signature is refined to "Sum x t" by the pattern matching
08:10:21 <Saizan> hashkool: so you've to use map L (xpath ra a cns)
08:10:23 * EvilTerran gives up
08:11:25 * EvilTerran had no idea GADTs could do that
08:11:36 <Saizan> EvilTerran: well, if you can have case branches of different types you can also take additional arguments of different types
08:11:57 <EvilTerran> Saizan, i wasn't aware you could have case branches of different types
08:12:10 <Saizan> ah, ok
08:12:25 <dmwit> EvilTerran: Yup, GADTs do some pretty scary things. =)
08:12:26 <dcoutts> akamaus: you don't need to use anything special, just write the file out in the pre-build step
08:12:31 <SamB> EvilTerran: only with GADTs or similar
08:12:43 <quicksilver> conal: yes.
08:12:58 <SamB> but actually, they only have different types insofar as the cased-over expression does
08:14:19 <conal> quicksilver: thx.  and thx for the chat.  it helped to clarify a distinction i was glossing over in my mind.
08:14:45 <RayNbow> conal, lub (\x -> let loop = loop in loop) id 3 -- is this valid, and if so, what should it evaluate to?
08:16:00 <conal> RayNbow: (\x -> bottom) `lub` (\ x -> x) == \ x -> bottom `lub` x == \ x -> x == id
08:16:19 <RayNbow> conal: it crashes ghci here :p
08:16:32 <conal> RayNbow: oh!  i'll try it also.
08:16:42 <RayNbow> but it might be because I'm running GHC 6.10.1
08:16:57 <RayNbow> (I'm currently on an old laptop)
08:18:05 <Saizan> a "fix id" loop is not interruptible, iirc
08:18:22 <conal> RayNbow: hm.  just sits there in my ghci.  doesn't give 3 as i'd expect.
08:18:36 <LeCamarade|Away> I think I take the award for using GHC on the oldest machine here.
08:18:38 <conal> Saizan: oh.
08:19:06 * LeCamarade|Away runs to -blah.
08:19:10 <conal> Saizan: oh, so ghc's multithreading isn't letting the non-bottom thread ever run.
08:19:12 <conal> urg.
08:19:52 <conal> RayNbow: i guess ghc's threading isn't up for that example.  bummer.
08:20:28 <akamaus> dcoutts, what preBuild is supposed to return? Can I just return emptyHookedBuildInfo?
08:20:40 <quicksilver> conal: were you trying in ghci? try running ghci with -N2
08:20:41 <dcoutts> akamaus: yep
08:20:50 <quicksilver> you probably need another 'real thread' for that to have any chance
08:20:53 <conal> quicksilver: will do.
08:22:31 <conal> quicksilver: hm.  same result.  just hangs.  and i'm using 'lub (\x -> last [0..]) id 3'
08:23:18 <fasta> How lightweight are threads in GHC btw? In Linux it was about 860 cycles, IIRC.
08:23:40 <akamaus> dcoutts, It works, and is simplier than I expected. Thanks!
08:23:48 <PeakerWork> fasta: how much does a syscall cost on x86/64? Probably more than that?
08:23:50 <dcoutts> akamaus: np
08:24:03 <conal> hm.  unamb (\x -> last [0..]) id 3 also hangs.
08:24:26 <fasta> PeakerWork: what do you mean? Different system calls take differents amount of time.
08:24:34 <PeakerWork> fasta: the syscall overhead itself
08:24:39 <PeakerWork> fasta: kernel entry/exit
08:24:51 <conal> well, that unamb use wasn't legit.  but unamb (last [0..]) 3 hangs also.
08:24:58 <fasta> PeakerWork: on the order of tens, I would guess.
08:25:14 <dhun> I am asking my self how to structure my program I got several Parsers, which are only allowed to match if the current environment is element of a set of allowed environments for that particular parser, at the moment I call all parsers from am common function, but I want only allowed once to match
08:25:19 <conal> Baughn: ping.
08:25:21 <RayNbow> hmm, on my newer machine I also have GHC 6.10.1... time to do an upgrade...
08:25:46 <PeakerWork> fasta: the ring switch, stack switch, storing/restoring of user-level registers, etc, probably costs more
08:26:12 <Baughn> conal: Pong
08:26:34 <Baughn> conal: Oh, I see. Hmm.
08:26:44 <conal> in the latest unamb, 'unamb 3 (last [0..])' and 'unamb (last [0..]) 3' both hang in ghci on my machine.
08:26:56 <fasta> PeakerWork: why would the stack switch take more than a single mov?
08:28:05 <conal> Baughn: similarly, race (evaluate 3) (evaluate (last [0..]))
08:28:07 <PeakerWork> fasta: It happens automatically inside the ring switch, I think it switches both SS and ESP, it at least loads a new segment descriptor, checks the descriptor involved, etc
08:28:25 <Baughn> conal: Or amb, which is more convenient
08:28:33 <fasta> PeakerWork: right, but the segment stuff works in hardware.
08:28:56 <conal> Baughn: yeah
08:29:46 <fasta> PeakerWork: so, would you say the Haskell forkIO is never going to be more than 10 times faster than using pthreads?
08:30:07 <PeakerWork> fasta: no idea. in theory, analysis can eliminate forkIO's completely
08:30:17 <PeakerWork> (static language-level analysis)
08:31:29 <PeakerWork> fasta: perhaps thread forking can be made really really cheap, at the expense of slowing down stuff in general
08:32:48 <Baughn> conal: I've got it. This is interesting..
08:32:56 <conal> Baughn: yeah?
08:33:11 <Baughn> conal: It hangs when calling cleanup in race, presumably because the last [0..] is doing no allocation
08:33:12 <akamaus> dcoutts, I forgot the the most important. How to read GladeXML from string? I'm sure I saw it somethere
08:33:22 <Baughn> conal: The fix is to forkIO the cleanup
08:33:35 <Baughn> conal: Although, that's a bad fix. It'll still be eating CPU. Don't do that.
08:33:44 <conal> Baughn: how could last [0..] not allocation?
08:33:52 <conal> (not allocate)
08:33:53 <PeakerWork> piggy-backing allocations sounds like a bad idea :-(
08:34:07 <dcoutts> akamaus: oh, come to think if it, that may not have been bound, though it'd be easy to do so
08:34:25 <dcoutts> akamaus: if you want something that works now then use cabal's feature to install data-files
08:34:41 <conal> Baughn: oh!  killThread hangs.
08:34:47 <Baughn> conal: You should ask JaffaCake or someone, not me, but logically GHC is probably fusing the last and the [0..]
08:35:10 <conal> Baughn: oh, of course it could fuse last [0..].
08:35:21 <conal> Baughn: i hadn't thought of fusion.
08:35:28 <Baughn> conal: killThread is implemented in terms of throwTo, yes. Locally I've replaced the killThread with a different exception; that of course makes no difference.
08:35:32 <conal> i wonder: does *ghci* fuse?
08:35:37 <Baughn> It does.
08:35:40 <leimy> will it blend?
08:35:52 <Baughn> This is technically a ghc bug, I suppose..
08:36:22 <burp> mhm ghci smoke
08:36:55 <leimy> Don't inhale this
08:37:02 <quicksilver> conal, Baughn : ghci doesn't do any optimisations at all, does it?
08:37:07 <quicksilver> fusion happens at the core level
08:37:14 <Baughn> conal: Eh
08:37:17 <quicksilver> ghci users bytecode
08:37:18 <Baughn> conal: It /doesn't/ fuse
08:37:27 <Baughn> There are plenty of garbage collections
08:37:50 <BMeph> conal: what happens if you give unamb two different values?
08:37:58 <Baughn> BMeph: Don't.
08:38:13 <conal> BMeph: you have to go to confession
08:38:18 <Baughn> BMeph: You get whichever result evaluated first, of course..
08:38:40 <conal> BMeph: that's what amb is for
08:39:25 <conal> i've forgotten: how do i tell ghci to show GCs?
08:40:25 <Baughn> +RTS -Sstderr
08:40:54 <conal> there's no dynamic ghci flag?
08:41:42 <Baughn> Never looked. You can start ghci with that flag, of course.
08:42:10 <Axman6> :set +RTS -Sstderr?
08:42:13 <conal> Baughn: thx.  you're seeing GCs but killThread is hanging?
08:42:21 <Baughn> Yes
08:42:39 <conal> sigh
08:42:57 <Baughn> I'm having trouble replicating it as a standalone program, but.. let's see.
08:43:25 <conal> Baughn: that'd be great.  if we can get a simple example, ghc HQ will help.
08:44:02 <Baughn> Ah. No, I think it's my fault somehow.
08:44:33 * Baughn just stares
08:44:39 <Baughn> ..I forgot to throw an unblock around the forkIO calls
08:45:33 <Baughn> conal: "let f x = unblock $ forkIO $ putCatch x v" <-- Works fine. Use this.
08:45:51 <Baughn> Wait..
08:46:21 <Baughn> conal: "  let f x = forkIO $ unblock $ putCatch x v" <-- This. That's the correct line.
08:47:42 <Baughn> conal: So that would mean.. hm. Well, no threads ever got killed before; I'd say this needs to be released soonest..
08:47:55 * Baughn blinks. Hang on, removing the killThreads also removed that ghc bug
08:49:13 <Baughn> conal: And fixing this bug *ALSO STOPPED THE SEGFAULT*. Yay!
08:49:28 <Baughn> conal: Although that's still a ghc bug, I now have /useful/ information to provide.. plus, it no longer affects us
08:49:29 <conal> Baughn: :) !
08:50:06 <conal> Baughn: do you recommend "forkIO $ unblock $ putCatch x v"?
08:50:10 <Baughn> Yes
08:50:16 <Baughn> Hm
08:50:20 <Baughn> ..no
08:50:23 <Baughn> That's still subtly buggy
08:50:24 <dmwit> hehe
08:50:25 <Baughn> Darn it.
08:50:45 * Saizan throws more concurrency at Baughn 
08:50:57 <dhun> I made a tiny class hierarchy  http://de.wikibooks.org/wiki/Benutzer:Dirk_Huenniger/haskell could anybody tell me how to implements something like this in Haskell?
08:51:04 <Baughn> conal:   let f x = forkIO $ putCatch (unblock x) v
08:51:08 <Baughn> THERE.
08:52:03 <conal> Baughn: or move the unblock into putCatch?
08:52:18 <conal> Baughn: maybe keep with the forkIO line
08:52:22 <conal> since they're related.
08:52:27 <conal> i don't know
08:52:42 <Baughn> conal: Really, at the moment putCatch belongs inside race
08:52:43 <conal> i'm adrift.  i have no mental model for this stuff.
08:52:48 <Baughn> They're deeply interlinked
08:52:59 <Baughn> I'll look at decomposing them more cleanly, tomorrow.
08:53:09 <Baughn> For the moment, this version is at least bugless..
08:53:30 <conal> thanks.  good time to darcs-push and hackage-release?
08:53:35 <Baughn> Although, it changed the behavior of a reactive bug I was working on from "throws BothBottom" to "Hang"
08:53:39 <Baughn> Give me a few minutes
08:53:55 <conal> Baughn: sure.  just let me know.
08:56:03 <dhun> is there a set type in Haskell?
08:56:08 <dmwit> Data.Set
08:57:11 <dhun> ok
08:57:31 <dmwit> dhun: MyParser looks like a normal "data" declaration, and Environment seems to just wrap a "type" declaration.
08:57:40 <dmwit> dhun: But your "Anything" class is a little strange.
08:57:56 <dhun> ata Anything = Wikilink [Anything] | Dikilink [Anything]| C Char |
08:57:56 <dhun> 	Evil|Empty|Something [Anything]
08:58:21 <dhun> anything is a node in the parse tree
08:58:45 <dmwit> Okay.  That's not what it looked like from your paste. =)
09:00:32 <PeakerWork> Baughn: do you have an automated unit test thing for this?
09:01:23 <dhun> I can not have a set of types, can I?
09:02:11 <Baughn> PeakerWork: It's very hard to write unit tests for race conditions, I'm afraid
09:02:19 <Baughn> I don't know how to do it
09:09:07 <quicksilver> Baughn: add programmable delays at every point you can
09:09:20 <quicksilver> Baughn: fudge those delays to deliberately produce the racing interleaving.
09:09:25 <quicksilver> or, if you like, all interleaves.
09:11:09 <Baughn> quicksilver: I'm doing just that, and getting odd results
09:12:23 <Baughn> quicksilver: Namely, every time I think I'm starting to understand this, it changes behavior and what used to not work suddenly works.
09:13:40 <quicksilver> Baughn: I can well believe.
09:13:49 <quicksilver> I intend to add such fudges to my reactive implementation
09:13:54 <quicksilver> but I have not done so yet.
09:14:13 <Baughn> ..it hung. I /know/ it hung!
09:14:19 <Baughn> But now it doesn't.
09:14:44 <hackagebot> Added by RemcoNiemeijer, Mon Jun  8 16:13:28 UTC 2009.: Benchmarking code through strict evaluation  http://hackage.haskell.org/cgi-bin/hackage-scripts/package/StrictBench-0.1.1
09:17:06 <quicksilver> dcoutts: who administers hackagebot?
09:17:21 <sm> good timing.. that's me
09:17:35 <sm> was just checking it
09:17:38 <quicksilver> sm: could I suggest you push the URL through xrl.us ?
09:17:46 <quicksilver> or your favourite URL shortener?
09:17:54 <quicksilver> they are a bit spammy because they're so long.
09:19:07 <sm> that's more than I want to do, and I'm not fond of tiny urls, but I can drop the urls, or drop the timestamp which is less useful ?
09:19:25 <Baughn> conal: http://brage.info/~svein/unamb.patch
09:19:29 <sm> what do folks prefer ?
09:20:04 <quicksilver> sm: I personally think hackagebot is a useful service but it should strive to be as terse as possible.
09:20:05 <Baughn> conal: It should be good. I'm not sure what the cause of the hangs I was having were, since I suddenly can't reproduce them anymore, but it's at least a step towards correctness.
09:20:08 <doserj> quicksilver: that would lose the packagename and version information
09:20:22 <quicksilver> doserj: true.
09:20:31 <Axman6> hmm, O'Reilly's "recommended to you" thing is pretty broken. it's recommending three books, ttwo of which are already i my cart
09:20:34 <hackagebot> Added by RemcoNiemeijer, Sun Jun  7 19:53:21 UTC 2009.: Benchmarking code through strict evaluation
09:20:38 <sm> how's that
09:20:45 <quicksilver> another solution would be for hackage to support shorter URLs ;)
09:20:56 <quicksilver> hackage.haskell.org/p/StrictBench-0.1.1
09:21:07 <sm> indeed, I just show what's in their feed (with some rewrites & selection available)
09:22:23 <sm> the hackage-server repo awaits your patch for better urls, I think everyone would like it
09:22:31 <quicksilver> a shorter date format would help a little I suppose
09:22:53 <sm> I figure irc bots don't need to show timestamps, that's built in to your irc client
09:23:02 <conal> Baughn: applying patch ...
09:23:05 <sm> and this is more about real-time notifications
09:24:37 <quicksilver> as long as it is actually a recent feed the date is indeed redundant
09:24:44 <quicksilver> it's only if there was delays in the system it would matter
09:24:55 <hackagebot> Added by RemcoNiemeijer: Benchmarking code through strict evaluation
09:25:20 <doserj> I would put the url inbetween
09:25:56 <sm> oh yeah.. now I've lost the package name
09:25:59 * doserj is bikeshedding
09:26:06 <Baughn> conal: THat's it for today. I've an exam in, oh, fifteen hours, so..
09:26:58 <conal> Baughn: did you try the tests?  seems to be going quite a bit slower.
09:27:08 <conal> Baughn: first impression
09:27:38 <conal> Baughn: and yeah -- rest up & get ready for the exam.  thanks much for your help.
09:28:48 * RayNbow forgot cabal install doesn't work in Vista without elevated rights...
09:28:53 <Baughn> conal: The only difference with this patch is that subordinate threads are actually getting killed. Since they're doing /very little work/, that might actually cost more than just evaluating them to the end.
09:28:54 * BMeph looks into plans for a Lucite(TM) bikeshed, thus avoiding all of the paintint issues...
09:29:05 <Baughn> conal: Such optimizations are future work, anyhow.
09:29:09 * Baughn signs off
09:29:15 * BMeph meant "painting, not paintint
09:29:17 <conal> Baughn: take care!
09:29:41 <conal> Baughn: i'll push & release
09:32:50 <hackagebot> Added by FrederickRoss: Pure Haskell implementation of PGM image format
09:34:19 <hackagebot> bamboo 2009.6.8
09:34:47 <sm> frick, now it's upset
09:35:08 <Saizan> who runs hackagebot ?
09:35:12 <sm> I do
09:36:12 <hackagebot> bamboo 2009.6.8 - A simple blog middleware on hack (JinjingWang)
09:37:52 <sm> it's interesting how things impact people differently.. to me a single long irc message has no impact, my irc window has 15 tabs full of irc spam^h^h^h^hdiscussion
09:38:10 <TomMD> sm: Who are you?  Simon M.?
09:38:11 <hackagebot> unamb 0.2.2 - Unambiguous choice (ConalElliott)
09:38:11 <Saizan> oh, it's just that dons's one were taken down because it was considered mostly noise, so i'm surprised to see it here again
09:38:20 <sm> yes, Simon Michael
09:38:28 <monochrom> hahahaha
09:38:41 <TomMD> Arrr, serves me right for assuming there couldn't be more simons in the Haskell universe.
09:38:45 <sm> heh :)
09:39:05 <monochrom> "Simon M" is clearly ambiguous.
09:39:09 <skorpan> it's weird that so many haskellers are named simon
09:39:09 <conal> hackagebot++
09:39:11 <conal> sm++
09:39:26 <oal> hello
09:39:28 <sm> thanks conal :)
09:39:34 <Saizan> conal: why?
09:39:47 <oal> I have some troubles building head at a 64 bit linux machine
09:40:14 <sm> Saizan: ok, I don't know that history. I've had no negative comments re hackagebot yet
09:40:18 <BMeph> oal:  suspect the problems are with HEAD, not with you. ;)
09:40:21 <quicksilver> sm: 15 tabs? Hah! I have 86.
09:40:33 <quicksilver> sm: but the issue is vertical space, not horizontal.
09:40:37 <sm> I worked on dons' rss2irc specifically to make it be silent when entering the channel
09:40:40 <quicksilver> the hackagebot messages were taking 3+ lines.
09:40:48 <oal> BMeph, well, thought so
09:40:51 <conal> Saizan: for hackagebot
09:40:54 <oal> am trying at 32 bit
09:40:55 <sm> quicksilver: I see.. better now ?
09:41:06 <quicksilver> well, it takes much much less spce now :)
09:41:07 <oal> actually I want a working compiler for data parallel haskell
09:41:17 <quicksilver> I just can't decide whether I'm sad that the URL isn't there.
09:41:50 <sm> yeah.. why don't I add it back ? After all a hackage release is a joyous event, we can allow it two lines on your screen ? :)
09:41:57 <Saizan> well, it takes less space because it doesn't do bulk reports, right?
09:43:17 <Saizan> sm: tinyurl the links :)
09:43:27 <oal> oh well
09:43:29 <quicksilver> Saizan: that was my suggestion initially.
09:43:32 <oal> it fails for 32 bit too
09:43:38 <quicksilver> Saizan: he said he didn't like url shorteners :)
09:44:13 <monochrom> I don't like url shorteners either. I configure tinyurl to show me the full url first.
09:44:54 <Saizan> uhm, why?
09:44:55 <monochrom> I also don't like multiple lines on IRC. Everyone has 16:9 wide screens so why are you using vertical space?
09:45:06 <quicksilver> a shortened url from a trusted bot is different from a shortened URL from a random stranger.
09:45:06 <Saizan> it's not like the linked page can have anything surprising
09:45:09 <sm> yes, I don't like shortened urls. They lose useful information
09:45:24 <quicksilver> monochrom: because I use the other 2/3 of my screen for something else
09:45:34 <Saizan> and the useful information is on the rest of the line, anyway
09:45:58 <sm> I'm out of time, so I'll leave it for now (no urls) - if folks want these to be clickable, they should probably post on-list so we can see the consensus
09:46:11 <quicksilver> sm: there is no useful information which is not already there.
09:46:23 <quicksilver> sm: we already know it's on hackage (the name of the bot) the name of the package and the exact version
09:46:31 <quicksilver> so including the full URL is redundant.
09:46:44 <quicksilver> URLs *in general* contain useful information, sure.
09:46:55 <quicksilver> but this particular one contains no useful information whcih is not already present.
09:47:14 <monochrom> Everyone's IRC client wraps lines. If you write one long line, it means everyone chooses his IRC window geometry to fit his needs and you are respecting it. If you emit multiple short lines, it means you are arrogant and you are making a choice for everyone. Totally immoral.
09:47:33 <quicksilver> oh right.
09:47:38 <Saizan> monochrom: but one short line?
09:47:38 <quicksilver> were we even talking about that, though?
09:47:49 <quicksilver> we were just talking about one long line, versus one short line
09:47:58 <quicksilver> I don't think 3 short lines was in the choices under discussion ;)
09:48:01 <monochrom> We were talking about should hackagebot emit 3 lines or 2 or 1.
09:48:07 <quicksilver> no, we weren't.
09:48:17 <sm> quicksilver: agreed, including the url is only useful in allowing many readers to check out the new package with a click
09:48:26 <quicksilver> we were talking about if the 1 line it emits could be shortened enough not to wrap too much on quicksilver's screen.
09:48:31 <monochrom> Then what's this?  <sm> yeah.. why don't I add it back ? After all a hackage release is a joyous event, we can allow it two lines on your screen ? :)
09:48:33 <EvilTerran> i think we were, insofar as we were discussing whether the one line should be <80, <160, or <240 characters
09:48:44 <quicksilver> because the 1 long line being emitted was 3 lines on quicksilver's screen.
09:48:46 <EvilTerran> and hence how many lines it'd tend to wrap over
09:48:47 <Saizan> monochrom: he was assuming it would wrap
09:48:52 <monochrom> OK sorry.
09:48:56 <sm> hackage bot messages are always a single line. Yup.
09:48:56 <quicksilver> and clearly quicksilver's config is the only one worth basing decisions on.
09:49:28 <quicksilver> after all, anyone who insists on talking about himself in the third person is clearly someone to be reckoned with.
09:49:34 * EvilTerran is using 1024x768, and has a nicknames pane down the right, so it's almost always gonna be two lines here
09:50:12 <oal> btw
09:50:15 <hackagebot> combinat 0.2.2 - Generation of various combinatorial objects. (BalazsKomuves)
09:50:59 <sm> so to recap: hackagebot is now emitting a more terse description without the url ^^^, and if anyone wants the clicky url back, please post on haskell-cafe
09:51:08 <abbe> monochrom: interesting quote :)
09:51:08 <oal> oh, nevermind
09:51:27 <monochrom> I have an interesting quote recently?
09:51:27 * Saizan still doesn't see the point of redirecting any rss feed to a generally busy channel
09:51:52 <abbe> monochrom: that IRC line one :-)
09:51:59 <sm> and if anyone wants the bot gone, please post on haskell-cafe
09:55:23 <monochrom> I think we don't need url in hackagebot announcements. Perhaps you can call me 19th century because I don't advocate including a link in every sentence.
09:55:52 <Baughn> I'd like links. I just don't want to see them. So use <a> tags. :3
09:56:22 <CSWookie> monochrom: Well they didn't have URLs in the 1800s, so it would be hard to call you 19th century.  Perhaps 20th?
09:56:27 * Baughn drags IRC kicking and screaming into the 20th century
09:56:28 <sm> ah that would be ideal, but irc doesn't support it
09:56:33 <sm> (Baughn )
09:56:48 <Baughn> sm: Yeah, I know. IRC fails to support quite a lot of things.
09:57:03 <Saizan> clearly we need a different medium, like for example an rss reader on another window on your desktop ;)
09:57:15 <Baughn> No, let's modernize IRC. :P
09:57:38 <ik> again‽
09:57:40 <monochrom> postmodern IRC means every package is in XML.
09:57:40 <Baughn> It wouldn't be /that/ hard to have the client and server agree to use irc-2, otherwise fall back to irc-1. It's a wonder that nobody's done that.
09:57:49 <monochrom> s/package/packet/
09:58:03 <Saizan> yeah, see XMPP/jabber
09:58:08 <bd_> Baughn: it's because mirc's author's a jerk who doesn't participate in standards development :|
09:58:20 <ik> forget mirc
09:58:34 <bd_> ik: we can't forget mirc. Too many people use mirc. :|
09:58:36 <Baughn> bd_: So? mirc users would just be stuck with irc-1 limitations
09:58:36 <mux> it's not like mirc hindered IRC's standard development
09:58:59 <CSWookie> Baughn: People use mirc?
09:59:02 <dcoutts> sm, quicksilver: the way to make the hackagebot urls nicer is to make the hackage urls nicer, the new hackage-server uses just $host/packages/foo-1.0/
09:59:10 <CSWookie> s/Baugn/bd_/
09:59:11 <bd_> CSWookie: maybe not so much on freenode :)
09:59:21 <ik> you'd be surprised
09:59:24 <ik> there's enough of it
09:59:28 <monochrom> Ignore mirc but make sure you get all other irc clients to reach a consensus. Then mirc will just comply.
09:59:33 <sm> dcoutts: +1
09:59:58 <dcoutts> sm: I've pushed your hackage-server patches btw
10:00:07 <bd_> monochrom: just enforcing utf8 would be a huge improvement...
10:00:15 <sm> great!
10:00:25 <dcoutts> sm: TomMD also has some changes
10:00:54 <dcoutts> sm: if you have time to do any more then we should talk about what to do next
10:00:54 <BMeph> Forget mIRC. If someone makes another client that is better than mIRC, folks will use it, just to try something different. :)
10:01:04 <sm> ok
10:01:07 <mux> I'd rather have the IRC protocol properly forward charset information than enforcing UTF-8 everywhere
10:01:14 <sm> not yet, but if I do will ping you
10:01:21 <dcoutts> sm: ok
10:01:21 <Nafai> I haven't know anyone that uses mIRC for at least a decade :)
10:01:21 <bd_> mux: no need to forward charset info if it's utf8. just convert at the client.
10:01:35 <Baughn> mux: Simplest way would be to have the client convert to utf-8 and back. Nicely backwards-compatible.
10:01:38 <ik> encoding is hard.  Don't trust developers to get it right, use utf8.
10:01:43 <ik> It's superior anyway
10:01:51 <mux> simplest sure, but I'd rather have the protocol be charset indepedant
10:02:00 <Baughn> Why?
10:02:08 <ik> utf8 covers everything, doesn't it?
10:02:10 <bd_> mux: IRC proved that to be a bad idea :|
10:02:21 <dhun> how can I find out if x is element of the list y
10:02:27 <monochrom> human proved to be a bad idea.
10:02:27 <Baughn> ik: And then some. Want klingon hieroglyphs? Here you go.
10:02:28 <mux> bd_: IRC lacks such a mechanism
10:02:31 <Twey> dhun: x `elem` y
10:02:34 <mux> Baughn: to not be forced to use utf-8
10:02:35 <dhun> thanks
10:02:38 <bd_> mux: I hang out in channels where Japanese is spoken. You have no idea how bad things get with three or more charsets being in use at the same time...
10:02:41 <mux> this is an IETF recommandation btw
10:02:42 <abbe> yep, as telnet is also considered an IRC client :p
10:02:46 <ik> Baughn: I thought that proposal was rejected
10:02:53 <Twey> Baughn: They refuse to include Klingon in Unicode, I thought?
10:03:01 <mux> bd_: that just wouldn't be a problem if charset was propagated...
10:03:13 <Baughn> mux: People would get the conversion wrong
10:03:16 <bd_> mux: and while negotiation may help, it's really a lot simpler just to use utf8. What possible reason could there be not to?
10:03:21 <mux> not negociating
10:03:26 <mux> forwarding
10:03:30 <Baughn> mux: With your proposal, either the server has to convert, or every client has to understand every single charset
10:03:30 <EvilTerran> Twey, ok, shavian quickscript? i ching hexagrams?
10:03:33 <mux> the client then knows how to interpret the data
10:03:43 <Twey> bd_: On IRC, little
10:03:47 <EvilTerran> :P
10:03:49 <mux> every client just uses iconv, end of the problem
10:03:53 <Baughn> mux: If you stick to utf-8, then every client has to understand utf-8 - easy - and possibly what they want to convert to. Which they won't normally have to.
10:03:58 <mux> reencoding on the server would be hugely inefficient
10:03:59 <bd_> mux: FYI, some charsets have major de-facto but unofficial extensions. Eg, iso-2022-jp's hankaku extensions.
10:04:15 <bd_> mux: so even if you agree to use iso-2022-jp, that's not enough.
10:04:42 <bd_> mux: to make things even more fun, not all charsets even contain ascii. Shift-JIS has no halfwidth backslash or caret.
10:04:49 <mux> that's a non issue
10:04:50 <Baughn> mux: Why would I want to bloat my client with iconv when I can just pass-through unicode to the terminal?
10:04:59 <ik> It's so much easier to use unicode!  And I don't understand why you -want- to pass through every encoding
10:05:04 <ik> You still haven't explained that
10:05:12 <mux> Baughn: to avoid hardcoding a specific charset
10:05:23 <ik> Why?
10:05:26 <bd_> mux: It's a huge issue. You come in here with an english client and suddenly can't type backslash. Why? Who knows? IRC-2 is weird, let's go back to IRC-1.
10:05:43 <mux> bd_: huh?
10:06:08 <bd_> mux: like I said, shift-jis has no backslash. If the channel's using shift-jis, you can't represent backslash. period.
10:06:21 <mux> ik: because UTF-8 ain't "the best possible charset in the world such taht noone will never want to use anything else", and no such charset exists
10:06:35 <ik> mux: what symbols does it not cover?
10:06:36 <mux> bd_: the channel isn't using any charset
10:06:46 <Baughn> mux: Give one example of when you'd want to not use unicode. :)
10:06:50 <monochrom> every sentence is tagged with its charset
10:06:50 <mux> bd_: some client might, and too bad for it if it doesn't have backslash :)
10:06:56 <mux> Baughn: UTF-8 != unicode
10:07:00 <bd_> mux: So each client gets to pick their own? what happens if the other end doesn't have the coding tables for this charset?
10:07:11 <Twey> UTF-8 doesn't cover all of Unicode
10:07:28 <Twey> If you want to be safe you'd need to go with UTF-32...
10:07:29 <Baughn> Twey: Wait, what?
10:07:32 <mux> bd_: you realize that 99.999% of the clients will use either ASCII or UTF-8 anyways?
10:07:48 <mux> Twey: hence why its a bad idea imho to lock yourself with just one charser
10:08:05 <Twey> Baughn: Beg pardon.  WP says it does.
10:08:27 <dhun> is subtyping I got the data contructors of A and B and want to put them in a listß
10:08:32 <Baughn> Twey: For the time being. Unicode could conceivably exceed its limits, but it'd take some doing.
10:08:47 <Baughn> Twey: It doesn't cover the full 32-bit space, that's true. Oh, and it's ucs-32, not utf-32
10:08:55 <Baughn> Er. Rather, UCS-4
10:09:02 <Twey> Right.
10:09:20 <Twey> Oh really?
10:09:22 <monochrom> dhun: No, that is not subtyping.
10:09:33 <mux> it's very possible that one day utf-8 will be less used in favor of some other encoding, for instance for performance reasons
10:09:34 <Twey> What's with the naming?  WP has both ([[UTF-32/UCS-4]])
10:09:35 <bd_> mux: Yes, and nobody will test that last 0.001%.
10:09:52 <bd_> mux: And then if you don't have the charset it will *break* and nobody will know why.
10:10:06 <raji> Are there any tools that help you detect deadlocks or starvation ?  how not to make mistakes while doing multi threading
10:10:08 * EvilTerran encodes all his text in WTF-23
10:10:10 <dhun> well if I say A is Subtype of C and B is as well I can have a [C], in which I can put both
10:10:13 <Twey> mux: That's already the case where non-ASCII characters are common — you save 1/3 for Asian characters
10:10:22 <Twey> EvilTerran: Heh
10:10:22 <Baughn> Twey: Mm, utf-8 only covers unicode 0x0 through 0x10ffff
10:10:26 <EvilTerran> raji, that's a Hard Problem
10:10:28 <mux> bd_: nope, at worse people with a system that don't support such an encoding will get an error message saying that the message cannot be decoded
10:10:48 <Baughn> Twey: (It would obviously be trivial to extend, mind)
10:10:53 <Twey> Aye.
10:10:56 <bd_> mux: And how are they supposed to fix this? Think of the users :)
10:10:58 <dhun> can I do anything similar?
10:11:13 <bd_> mux: What actual, real languages have iconv-supported charsets but can't be represented by utf8?
10:11:30 <raji> EvilTerran,   how not to make mistakes while doing multi threading, any guidelines. There should be some form of emperical measurement ?  I mean in algorithms you can increase the data size ,draw a graph and make approximate O(n^x) .
10:11:35 <monochrom> If you write "data C = A | B" it is not subtyping. There is no subtype "A" created. Only the value "A" created.
10:11:51 <bd_> mux: hint: iconv, like just about every charset-conversion library, uses unicode as an intermediate representation :)
10:12:03 <dhun> yes right, but I would like to have subtyping as in OOP
10:12:07 <mux> bd_: it's not about utf-8 not being able to represent any character, it's about the fact that there is no "one charset that rules them all"
10:12:15 <mux> bd_: you want your protocol to last, don't you ?
10:12:16 <monochrom> Haskell98 doesn't have subtyping.
10:12:35 <dhun> any idea how to work around the problem
10:12:39 <Twey> dhun: I think you probably want a typeclass
10:12:43 <bd_> mux: Yes, and I trust unicode to do a lot better at that than making a list of ten thousand character sets every client needs to support.
10:12:51 <dhun> I will lool
10:12:57 <mux> bd_: once again, utf-8 != unicode
10:13:06 <bd_> mux: and utf8 covers all of unicode
10:13:08 <Twey> If both A and B are instances of C then you can have a [C a => a]
10:13:17 <Twey> Or rather, a C a => [a]
10:13:22 <mux> utf-8 is just one way to encode unicode, among many others
10:13:33 <mux> where others might be more suitable for performance reasons, for instance
10:13:46 <monochrom> Re-architect your design so you don't talk about subtypes subclasses etc.
10:13:54 * Twey nods.
10:13:57 <Baughn> [forall a. C a => a] <-- I want this ;_;
10:14:00 <bd_> mux: okay, and if that becomes a problem a server extension can be proposed where the server transcodes losslessly to another unicode representation
10:14:00 <mux> utf-8 is a nice default charset, and should definitely be supported, but I don't think you should limit yourself to it
10:14:02 <Twey> You're probably doing something wrong.
10:14:08 <Twey> Baughn: Hehehe
10:14:17 <mux> bd_: ugh, the server reencoding messages would be a terrible botleneck
10:14:20 <Saizan> Baughn: no, you don't, you want [exists a. C a => a]
10:14:31 <Baughn> Saizan: Probably.
10:14:36 <mux> bd_: this is why HTTP forwards charsets :-P
10:14:39 <bd_> mux: But what's worse is requiring the client to support an open-ended set of encodings.
10:14:43 <Baughn> Saizan: ..how did that translate to forall, again?
10:15:09 <Saizan> [(forall a. C a => a -> r) -> r]
10:15:09 <monochrom> Make good use of "data C = A | B". Although "A" is a value not a type, it still represents the high-level goal that "there are two cases, case A and case B".
10:15:11 <mux> bd_: in practice, it's not, and it works fairly well for HTTP
10:15:19 <dhun> just pasted http://de.wikibooks.org/wiki/Benutzer:Dirk_Huenniger/haskell
10:15:26 <Saizan> [forall r. (forall a. C a => a -> r) -> r] to be precise
10:15:31 <bd_> mux: I regard that as legacy, however.
10:15:36 <Baughn> Saizan: ..No, I don't think I want that
10:15:41 <bd_> mux: What -actual advantage- does this have?
10:15:41 <monochrom> You don't "need" OOP to represent "I have several cases".
10:15:43 <Baughn> Saizan: Is that /really/ the same type?
10:15:54 <dhun> this line does not work [WikitableP, WikilinkP]
10:16:00 <Saizan> Baughn: don't you want something like data AnyC = forall a. C a => AnyC a, [AnyC] ?
10:16:03 <mux> bd_: I said that already: the fact that you don't limit yourself to one specific charset
10:16:20 <bd_> mux: I consider that to be a disadvantage. Why do we want this?
10:16:44 <bd_> Yes, UTF-32 or what-have-you might be marginally better in some cases. But bandwidth is cheap. CPU is cheap for the client.
10:16:45 <Baughn> Saizan: ..I have no idea.
10:16:49 <Saizan> Baughn: exists a. C a => a ~~ AnyC ~~ forall r. (forall a. C a => a -> r) -> r
10:16:53 <Twey> Practically speaking, mux, you're probably never going to need more than UTF-16.
10:16:54 <Baughn> Saizan: Eh. I'll re-read the documentation later.
10:17:00 <Baughn> Saizan: And now you're just talking greek.
10:17:15 <Saizan> Baughn: by ~~ i meant isomorphic to
10:17:17 <Twey> At least in any reasonable timeframe for which your protocol could remain non-obsolete.
10:17:17 <mux> bd_: so that you don't have to reset to hacks such as the one you suggested: introduce extensions to support specific additional charsets (which will break some clients) and/or reencoding at the server level
10:17:24 <mux> s/reset/resort/
10:17:48 <Saizan> Baughn: and [exists a. C a => a] is a list of values potentially of different types but all being instances of the C class
10:17:50 <mux> Twey: most people asserting things like that end up being wrong, it's just a matter of time :-P
10:17:54 <Baughn> Saizan: I should be reading up on federated databases, not discussing haskell. See you tomorrow, probably. :P
10:17:58 <Twey> mux: Obviously this has happened before with ASCII to other things, but Unicode is different
10:18:04 <mux> Twey: and it's really not about a representation issue
10:18:05 <Twey> 'bye Baughn :)
10:18:21 <Twey> Unicode is a) HUGE and b) extensible with plenty of space left to spare
10:18:23 <Saizan> Baughn: it wasn't really a discussion :)
10:18:26 <bd_> mux: They're unnecessary anyway. If the unicode space is enough, just use utf8. If unicode space is not enough, what are you smoking? :)
10:18:31 <dhun> this does not work:
10:18:33 <dhun> lr ::(MyParser a=>[a])
10:18:33 <dhun> lr=[WikitableP, WikilinkP]
10:18:33 <mux> utf-8 makes some algorithms much slower since you can't have random access
10:18:42 <Twey> mux: So go for UTF-16
10:18:48 <Baughn> Twey: Same problem
10:18:54 <mux> it's not unlikely that one would be willing to use another encoding in specific situations, which is why those other encodings exist
10:18:54 <bd_> mux: it's a *transport encoding*. Convert it to UCS-4 at the client.
10:18:56 <Twey> Baughn: Oh, point
10:19:03 <Twey> UTF-32/UCS-4 it is, then
10:19:11 <Baughn> Twey: UCS-4. THere is no UTF-32.
10:19:27 <Twey> Baughn: I asked you to explain this nomenclature confusion :-P
10:19:36 <Twey> WP calls it UTF-32
10:19:37 <Saizan> dhun: that can't work
10:19:43 <Baughn> Twey: UTF-x means "variable-length encoding, x-bit chunks"
10:19:44 <mux> bd_: yes, and some day you might want to use another transport encoding :-) but we're going in circles here...
10:19:57 <Twey> UTF-32 was originally a subset of the UCS-4 standard, but the Principles and Procedures document of JTC1/SC2/WG2 states that all future assignments of characters will be constrained to the BMP or the first 14 supplementary planes, and has removed former provisions for private-use code positions in groups 60 to 7F and in planes E0 to FF.
10:20:02 <bd_> mux: 'might want to use' is no reason to give clients free license to annoy each other today ;)
10:20:02 <Twey> Accordingly UCS-4 and UTF-32 are now identical except that the UTF-32 standard has additional Unicode semantics.
10:20:03 <Baughn> Twey: UCS-n means "fixed-length encoding, n-byte code-points"
10:20:04 <Saizan> dhun: lr doesn't contain polymorphic values
10:20:24 <mux> bd_: this is not what would happen practically, and I think you agree to this.
10:20:59 <Baughn> Twey: UTF-32 would have been /eight/ bytes for anything in planes 80 through FF, four otherwise
10:21:23 <dhun> the question is, what is the right way to do it
10:21:25 <dhun> ?
10:21:29 <Twey> Hmn, okay.
10:21:33 <bd_> mux: No, it will. I assure you of this.
10:21:36 <Saizan> dhun: if lr :: MyParser a => [a], it means that the user of "lr" can decide what 'a' is, not lr
10:21:37 <Baughn> Twey: But we've got.. how many planes in use? Two?
10:21:48 <Twey> Yeah, I don't think they've filled up the second one, yet.
10:21:49 <dhun> ok
10:21:59 <bd_> mux: mIRC, even today, has incredibly broken unicode support. If mirc moved to irc-2, I can guarentee you it will start sending sjis or iso-8859-1 on the wire if allowed to.
10:22:02 <Baughn> Right, which makes utf-32 a mite silly
10:22:02 <mmorrow> @remember quicksilver after all, anyone who insists on talking about himself in the third person is clearly someone to be reckoned with.
10:22:03 <lambdabot> Done.
10:22:05 <mmorrow> lol
10:22:08 <Twey> Heh, bd_
10:22:10 <Saizan> dhun: first of all, why do you want it to have that type?
10:22:14 <mux> bd_: it will be as much as an annoyance as the day you'll want to support additional charsets in your irc-all-in-utf8 protocol
10:22:22 <Twey> mIRC sometimes likes to *alternate* character encodings.
10:22:22 <mux> who cares about mIRC, seriously?
10:22:27 <Saizan> dhun: and what are the types of the values contained?
10:22:27 <bd_> Twey: Within the same line.
10:22:34 <mux> we're talking about designing a new protocol
10:22:37 <And[y]> hi, how can i check, which types haskell implicty choose for a given function?
10:22:40 <Twey> I've never seen that.
10:22:41 <dhun> well look at http://de.wikibooks.org/wiki/Benutzer:Dirk_Huenniger/haskell
10:22:51 <Twey> And[y]: Open it up in GHCi and do a :t
10:23:00 <dcoutts> Baughn: huh? 8 bytes? surely even the crazy unicode people would not have thought we'd ever need more than 32bits for code points?
10:23:09 <Baughn> dcoutts: That's why utf-8 is silly
10:23:13 <dhun> both elements of the list are parsers
10:23:19 <Baughn> dcoutts: Er. utf-32
10:23:21 <bd_> mux: Yes, and if it gets popular, here comes mirc. My intent is to force clients to not screw up, and put blame on them if they do. The server should disconnect instantly if you break protocol rules. If you don't, people get lazy.
10:23:31 <And[y]> Twey: thats exactly what i wanted, thx :)
10:23:36 <Baughn> dcoutts: And no, utf-32 would've used eight bytes for code points where the 31st (highest) bit is set
10:23:38 <mux> bd_: if clients work so poorly that they can't decode messages properly, people won't be using them
10:23:48 <bd_> mux: So if you allow a completely open-ended set of encodings, without giving any recommendations or limits on what you can do, you WILL see ALL possible values used.
10:23:57 <bd_> mux: You wish :)
10:24:00 <dhun> Hey yitz, it works without Bad now
10:24:03 <dcoutts> Baughn: oh, crazy.
10:24:04 <Baughn> dcoutts: Or would it.. hm, I think I got that wrong. Well, it would've used eight bytes for /some/ points, anyhow
10:24:04 <mauke> Baughn: [citation needed]
10:24:14 <mux> bd_: not completely - utf-8 should be the default (this is also an IETF recommendation), because it is a sane default
10:24:22 <Saizan> dhun: i think you're still using a too OO design, that doesn't work out very well in haskell
10:24:31 <dhun> I think so too
10:24:33 <bd_> mux: Just because you say it should be the default, does not mean it will be the default.
10:24:42 <mux> IETF actually forbids not supporting utf-8
10:24:47 <dhun> the questing is how can I redesign it
10:24:54 <Baughn> Twey: He speaks the truth. Windows hands mirc unicode; if you give it a letter that can't be encoded using the current encoding.. guess what.
10:25:00 <bd_> mux: Basically, if you want to allow other charsets, fine, but don't force every client to deal with it.
10:25:07 <Twey> Gack.
10:26:13 <mux> anyways, I'm outta here, cya
10:26:48 <And[y]> now i have a function called nthElem:
10:26:53 <And[y]> nthElem (l:lr) 1 = l
10:26:54 <And[y]> nthElem (l:lr) n = nthElem lr (n-1)
10:27:02 <And[y]> i thought it should be typed like: nthElem :: [Int] -> Int -> Int
10:27:03 <Saizan> dhun: uhm, i'd make MyParser a record type rather than a class
10:27:10 <And[y]> haskell choose: nteElement :: Num a => [b] -> a -> b
10:27:18 <And[y]> whats wrong with my assumption? :D
10:27:53 <mauke> And[y]: why would it be restricted to [Int]?
10:28:01 <mauke> And[y]: it doesn't do anything with the list elements
10:28:23 <And[y]> only coz i wanted it to work on int lists, only, tbh
10:28:40 <mauke> well, it works for all lists :-)
10:28:52 <paggas_> when writing "par a b", what if b uses a before it is done computing?
10:28:52 <Baughn> And[y]: How does it differ from (!!)? ;)
10:29:09 <dhun> are there any exmaples on that?
10:29:23 <And[y]> hmmm, dunno Baughn ... never saw (!!) before :D
10:29:40 <Baughn> And[y]: At this point in your career, just assume there'S a function to do it. :P
10:29:48 <hackagebot> LambdaCalculator 0.0.1 - A basic lambda calculator with beta reduction and a REPL (ThomasDuBuisson)
10:30:12 <And[y]> lets say i wanted it to only accept int lists ... what should i write then? :>
10:30:37 <mauke> a type signature
10:30:39 <Baughn> And[y]: nthElement :: [Int] -> Int -> Int
10:30:44 <Baughn> And[y]: nthElement = (!!)
10:31:01 <And[y]> okay, thank you, i will try :)
10:31:16 <Apocalisp> How would you turn a String into a unix timestamp (Int)?
10:31:17 <Baughn> Though I don't understand why you'd want to.
10:31:24 <Baughn> Apocalisp: reads?
10:31:33 <Baughn> Apocalisp: Wait, what sort of string?
10:31:42 <Apocalisp> "12:45 AM"
10:31:46 <Apocalisp> that kind of thing
10:32:36 <Baughn> You'd have to parse the string, but Data.Time.Clock has some useful functions for this
10:32:38 * BMeph_ wants a fudge REPL...
10:32:52 <Baughn> Apocalisp: So does Data.TIme.Calendar.. but as you can see, it isn't a simple problem.
10:33:09 <Baughn> Apocalisp: What date is "1 year ago" on february 29th? How about on march 1st if there was a leap day?
10:33:27 <Baughn> Or if there was one last year?
10:33:48 <Baughn> Never mind that a year is 365.25 days. :P
10:33:58 <osfameron> and don't forget leap seconds!
10:34:02 <Baughn> Never!
10:34:21 <Baughn> You'll also have to do gregorian/julian conversions for sufficiently old dates
10:34:32 <BMeph_> What are leapseconds? Did I forget them, or was I never told? ;)
10:35:02 <Baughn> BMeph_: Corrections for the varying rotational speed of earth, mostly
10:35:13 <Baughn> BMeph_: They get announced some time in advance.
10:35:14 <osfameron> time-geeks get excited about them..
10:35:37 <osfameron> apparently they're Important
10:36:02 <osfameron> datetime maths makes me cry
10:36:58 <BMeph_> osfameron: Important like a cog is? ;)
10:37:18 <osfameron> cog?
10:37:31 <Baughn> BMeph_: As important as a horse-shoe.
10:37:50 <Apocalisp> Why would you wear a horse for a shoe?
10:38:00 <Baughn> Apocalisp: To go faster!
10:38:05 <gwern> Baughn: hey, kingdoms have been lost because of horsehoes
10:38:07 <Apocalisp> of course!
10:38:15 <osfameron> one horse per foot?
10:38:18 <Baughn> Yes!
10:38:24 <gwern> osfameron: oh, you need several hundred
10:38:24 <ski> Saizan : s/[exists a. C a => a]/[exists a. C a *> a]/
10:38:29 <Apocalisp> Horseskates
10:38:37 <gwern> if you want to have decent transportation
10:38:41 <Baughn> osfameron: http://ghostlightning.files.wordpress.com/2009/04/sengoku-basara-02-takeda-shingen-scales-a-castle-on-top-of-2-horses.jpg <-- Like this
10:39:22 <osfameron> heh
10:39:45 <Saizan> dhun: like this http://pastebin.com/m652a6154
10:40:27 <Saizan> dhun: then you can use [wikitablep,wikilinkp] :: [MyParser]
10:40:34 <Saizan> ski: oh, right :)
10:40:49 <mmorrow> paggas_: if `b' uses `a' and `a' hasn't produced any useable (sub-)results yet, b'll have to wait
10:41:28 <dhun> thank you
10:42:05 <BMeph_> osfameron: http://motivatedphotos.com/?id=454
10:42:08 <Saizan> dhun: except that maybe you want to change the type of the allowed field
10:42:18 <ski> (Saizan : i've not seen any other suggestion for notation for `*>', so i'm using that for the time being .. i'd like people to notice the difference to `=>')
10:42:21 <mmorrow> paggas_: so if (a = sum [0..999999999]) or something, and `b' uses `a', then the `par` was probably for the worst
10:42:33 <Saizan> dhun: maybe make it "Anything -> Bool"
10:43:12 <ski> Saizan> @src Anything
10:43:14 <Saizan> dhun: since you cant compare unapplied constructors like you are trying to do with elem in the body of anything
10:43:27 <Saizan> ski: http://de.wikibooks.org/wiki/Benutzer:Dirk_Huenniger/haskell
10:43:29 <ski> Saizan : oh, dhun provided it. nvm
10:44:42 <Saizan> or i guess one could change the Anything type
10:44:46 <dhun> will need some time to understand that, but will work
10:44:52 <hackagebot> test-framework 0.2.3 - Framework for running and organising tests, with HUnit and QuickCheck support (MaxBolingbroke)
10:45:03 <paggas_> mmorrow, but i can have e.g. (a = iterate f x) and b will be able to use the produced list element by element as they are computed, with a and b running in parallel indefinitely?
10:45:22 <ski> dhun : instead of `app2 l p b k se= ..(head l)..(tail l)..' use `app2 (x:l) p b k se = ..x..l..'
10:45:44 <ski> looks much nicer with pattern-matching
10:45:44 <dhun> yes
10:46:06 <ski> also, in `app' use matching on the left-hand side of `=', instead of `case'
10:46:19 <lilac> Baughn: unix timestamps don't use leap seconds. and they do leap-years wrong too.
10:46:47 <ski>   app z p b (Evil:_) = return [Evil]
10:46:53 <Baughn> lilac: Well, there is that..
10:47:03 <lilac> it makes the problem quite a lot easier
10:47:07 <ski>   app z p b (Empty:_) = try (...) <|> return [Empty]
10:47:16 <Baughn> lilac: No, it means you have to compensate for that
10:47:25 <ski>   app z p b (Something x:_) = return [Something x]
10:47:32 <ski> dhun : like that
10:47:36 <lilac> Baughn: why?
10:47:36 <dhun> ok
10:48:00 <ski> (dhun : i put `_' there since you weren't using `tail k' anywhere)
10:48:11 <dhun> yes
10:48:30 <Baughn> lilac: You can't just ignore the leap seconds. You might get whole seconds off from the truth.
10:48:48 <lilac> Baughn: the whole point of that simplification is that you /can/
10:49:37 <lilac> Baughn: Jan 1 2009 as a unix timestamp is (39 * 365 + 9) * 86400
10:50:02 <lilac> (yes, 2000 was a leap year according to time_t)
10:50:45 <lilac> although determining the number of actual seconds between two time_t values is hard...
10:50:46 <ski> dhun : instead of `if r==False then ... else ...' use `if not r then ... else ...'
10:51:21 <Saizan> dhun: oh, and try to avoid tabs, you'll find that dealing with layout becomes much simpler
10:51:28 <jthing> a year is approx 265.2425 day's (365 + 1/4 - 1/100 + 1/400) su oit is often easier to do date computations in julian days
10:51:31 <CSWookie> Don't forget double-leap seconds.
10:51:35 <CSWookie> My personal favorite.
10:51:46 <Saizan> dhun: set your editor to insert spaces when you use the tab key
10:51:51 <Axman6> ski: i'd usuallt recommend that too, but thinking about it, i think r == False is clearer
10:51:54 <roconnor> CSWookie: when do those happen?
10:51:54 <Axman6> reads better
10:51:55 <ski> dhun : instead of `if l==[Evil] then ... else ...' i'd probably do `case l of {[Evil] -> ... ; _ -> ...}' .. but ymmv
10:52:03 <yitz> CSWookie: there have never been any of those
10:52:19 <CSWookie> yitz: Of course there have.  They're an astronomical thing.
10:52:23 <ski> Axman6,(dhun) : hm, that might be in this particular case .. why ?
10:52:31 <CSWookie> yitz: Well, maybe not of course.
10:52:35 * ski has btw no idea what the code is really doing
10:53:17 <ski> hm, `r<-try(p)<|>return False' looks a bit strange, i suppose
10:53:36 <ski> there should be a better way to do this, i think
10:54:03 <yitz> CSWookie: @google table of leap seconds
10:54:09 <yitz> @google table of leap seconds
10:54:10 <lambdabot> Plugin `search' failed with: Lib.URL.isTextHTML: getHeader failed
10:54:15 <yitz> urgh
10:54:23 <ski> first, instead of that repeated `r == False' test, the test should be done once
10:54:24 <yitz> http://tf.nist.gov/pubs/bulletin/leapsecond.htm
10:54:31 <ski> dhun : ^
10:54:56 <dhun> I am reading the discussion
10:55:18 <ski> then, maybe one can avoid the `<|> return False' part, if that is a workaround
10:55:23 <yitz> dhun: sorry I had to run out earlier. glad to see that you're making progress. :)
10:55:32 <roconnor> @hackage leapseconds-announced
10:55:32 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/leapseconds-announced
10:56:21 <mmorrow> paggas_: yes
10:56:41 <roconnor> http://hackage.haskell.org/packages/archive/leapseconds-announced/2009/doc/html/src/Data-Time-Clock-AnnouncedLeapSeconds.html#leapSeconds
10:56:41 <ski> it appears that if `p' succeeds in parsing, you want to parse a few things more, otherwise you want to do something else
10:57:09 <ski> or, hrm
10:57:22 <dhun> if p fails!
10:57:24 <ski> `p' might succeed, but still return `False'
10:57:25 <ski> right
10:57:35 <paggas_> mmorrow, nice, thanks!
10:57:37 <dhun> p can only return true
10:57:39 <mmorrow> paggas_: a nice example of a `par` use is ==> mean xs = let n = length xs; s = sum xs in n `par` s `pseq` s / n
10:57:42 <dhun> thats may convention
10:57:54 <mmorrow> paggas_: (foldl' (+) 0 instead of sum and fromIntegrals omitted)
10:57:57 <ski> dhun : then why does it have a `Bool' monadic return type ?
10:58:00 <yitz> roconnor: ah, yes. much clearer. thank you. :)
10:58:15 <dhun> because I want to see if p matches or not
10:58:19 <ski> dhun : if it can't return `False', imo it should have type `Parser ()'
10:58:19 <dhun> so I need two states
10:58:28 <dhun> no
10:58:28 <ski> you can see that anyway
10:58:29 <mmorrow> paggas_: that'll run down the list in parallel computing length and sum
10:58:40 <dhun> I want r to be false if p didn't match
10:58:45 <ski> if you reach the second branch of the `<|>', then the first branch failed
10:58:50 <paggas_> mmorrow, and also in constant space?
10:58:55 <mmorrow> paggas_: exactly
10:59:02 <dhun> yes
10:59:07 <ski> dhun : yes, but for what *purpose* ?
10:59:21 <ski> why bother with `r' at all, if you can avoid it ?
10:59:30 <mmorrow> paggas_: (so if the list was infinite, although it wouldn't ever finish, i'm pretty sure it'd run in constant space)
10:59:41 <dhun> I think I can not avoid it
10:59:59 <ski> you're saying `p' will only ever return `True'
11:00:01 <mmorrow> paggas_: at least, if it didn't run in constant space that'd prob be considered a bug
11:00:08 <ski> (or fail, but then it doesn't return anything)
11:00:09 <paggas_> mmorrow, though it seems a little overkill in this case, a nice example nonetheless :)
11:00:12 <mmorrow> heh
11:00:24 <dhun> yes but I need to know if it matched
11:00:43 <dhun> its a parser
11:00:50 <ski> yes, wait a moment
11:04:00 * BMeph_ starts humming the tune, "UR DOIN IT RONG"...
11:04:05 <ski> assuming `p' never monadically returns `False', it appears to me what you wrote in the `Empty' branch there is the same as
11:04:08 <ski>       do try p
11:04:12 <ski>          return []
11:04:13 <paggas_> mmorrow, in the means example, to run in constant space the two threads should be synchronized, no? so neither runs too far in the list with the other lagging behind. but how do you make sure this doesn't happen?
11:04:15 <ski>   <|> do c <- anyChar
11:04:19 <ski>          l <- anything p b se
11:04:20 <ski>          return ([C c] ++ l)
11:04:25 <ski> dhun : what you say ?
11:04:37 <mmorrow> paggas_: heh, just tested the infinite mean const space thing, and it does NOT run in constant space :(
11:04:57 <hackagebot> iteratee 0.2 - Iteratee-based I/O (JohnLato)
11:05:21 <dhun> but in case true I want to return the empty list
11:05:34 <ski> dhun : in case `p' succeeds in parsing, the whole returns `[]'; otherwise, we read a char into `c', some "anything" stuff into `l' and return `C c : l' like you did in your code
11:05:40 <ski> yes
11:05:57 <ski> if `p' succeeds parsing, then the `return []' will be called
11:06:17 <ski> the second branch of `.. <|> ..' will not be used, since the first one succeeded
11:06:17 <dhun> ok I will try that
11:06:30 <paggas_> mmorrow, probably one thread is faster than the other and evaluates the list, taking up space, without the other thread consuming as fast
11:06:41 <ski> (also, this way there should be no need to put dummy values into `c' and `l' like you tried in your code)
11:06:42 <mmorrow> paggas_: yeah, one way threads/sparks sync is, when a node gets evaluated it's marked as a blackhole, and any other thread that tries to evaluate that blackhole gets grabbed and put in a wait queue for that node
11:07:10 <mmorrow> (and once it's done evaluating threads can access it in parallel, since it's never again mutated)
11:07:13 <ski> (dhun : if you prefer, you can put `{',`;',`}' delimiters into it ..)
11:07:47 <dhun> yes but it will take some time until I will be able to try it
11:07:54 <ski> ok
11:07:56 <mmorrow> paggas_: hmm, interesting. i wonder if there's some way to tweak that mean to force the threads to "stay close"
11:07:57 <dhun> first I have to get things working again
11:08:34 <ski> dhun : btw, note that my rewriting above dependend on `p' only ever returning `True', never `False' .. otherwise one can't rewrite that simply
11:08:58 <paggas_> mmorrow, seems to me it needs some annotations on the list itself :) no idea though
11:08:58 <dhun> but that is the case
11:09:10 <ski> fine, then
11:11:09 <mmorrow> paggas_: (i have 2 cores) interestingly up to -N7 all don't run in constant space, but -N8 or more does
11:11:28 <conal> is it possible to import a data constructor without importing the corresponding data type?
11:11:37 <mmorrow> (but this is probably for some random reason)
11:12:00 <conal> i know how to import just the data type, or the data type and some constructors, but not a constructor without the data type.
11:12:08 * BMeph_ is now away - Reason : Auto-Away after 30 minutes
11:12:29 * BMeph_ is no longer away : Gone for 30 minutes 20 seconds
11:13:03 * ski raises eyebrow
11:15:08 <dhun> ski it works
11:15:37 <ski> you can replace `[C c] ++ l' with `C c : l' if you want. it's the same
11:16:05 <dhun> yes
11:16:19 <dino-> conal: I'm not sure but I don't think so. I wonder if this is where one gets to making a mkMyDataType function that makes one and exporting that but not the type itself.
11:16:31 * ski feels tempted to fix up the formatting of dhun's code
11:16:52 <conal> dino-: i suppose so.
11:17:11 <ski> dhun : anyway, now possibly you can change the type of `p' from `Parser Bool' to `Parser ()' ?
11:17:33 <conal> dino-: although i also want to pattern-match against the constructor.
11:17:34 <dirk_> dirk_ <- dhun
11:18:14 <ski> * ski feels tempted to fix up the formatting of dhun's code
11:18:15 <ski> <ski> dhun : anyway, now possibly you can change the type of `p' from `Parser Bool' to `Parser ()' ?
11:18:41 <dirk_> yes
11:19:02 <ski> (which ? :)
11:19:14 <dirk_> ?
11:19:43 <ski> you want me to try fixing the formatting or you can change that `Bool' to `()' ?
11:20:11 <dirk_> no I will do it myself
11:20:32 <dino-> conal: You can export only selected constructors for matching (and construction). I'm having difficulty seeing a situation where you don't want the type as a whole visible. Can you give me an example?
11:21:30 <dirk_> ok done
11:22:09 <conal> dino-: i have a more general form of the type that i want to import qualified and then use it to define a more specialized form of the type, with the convenient name.   e.g., type Foo = R.Foo Integer
11:23:35 <dino-> huh, general form of the type
11:24:51 <dirk_> sky but if you got more things you are unhappy with in my code just tell me
11:25:47 <dino-> That gets me off down a rut thinking about OO and inheritance.
11:25:51 <mmorrow> paggas_: this is interesting: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2598#a2598
11:26:10 <mmorrow> paggas_: so walking in parallel over chunks of configurable size....
11:26:30 <mmorrow> paggas_: chunk-size = 10000000 and non-const mem use
11:26:34 <paggas_> mmorrow: but this works only for lists?
11:26:43 <mmorrow> paggas_: chunk-size = <1000000 ==> const-mem use
11:27:13 <mmorrow> paggas_: yes, although most structures probably have an analog of `parChunkAccum'
11:27:32 <mmorrow> (that might be a worthwhile class actually)
11:28:55 <paggas_> mmorrow: thing is, since one thread will probably be faster than the other, you end up with a constant distance between the progress of the two threads (of one chunk or so), and that distance remains more or less constant, so why not just synchronize them at a chuck of size 1? :D
11:29:07 <mmorrow> paggas_: oops, the poor-par one in that comment should read "./mean +RTS -N2 -RTS s/5000000/5000/"
11:29:26 <ski> dirk_ : i'm reformatting your code anyway, if you don't mind :)
11:29:43 <dirk_> do what you like
11:29:48 <ski> dirk_ : after that, i'll see if i can suggest anything substantive or not
11:29:49 <mmorrow> paggas_: with chunks of size 1, you'd be sparking sparks for every element of the list
11:30:32 <mmorrow> paggas_: i think a graph (of the (x,y) kind) would be interesting of (chunksize, parallelism)
11:31:02 <mmorrow> paggas_: (and you'd get no parallelism with size-one chunks also)
11:31:40 <mmorrow> err, make that (chunksize,parallelism,memusage)
11:31:48 <dirk_> now I am at the point where I can not compare Wikilink for equality
11:32:10 <dirk_> how can I get around it
11:32:29 <paggas_> mmorrow: hmmm, but too big a chuck size probably doesn't have much benefits after a point, no?
11:32:49 <mmorrow> paggas_: totally.. there's definitely an optimum chunk size
11:33:02 <mmorrow> s/optimum/optimal/
11:33:05 <ski> dirk_ : why not ?
11:33:45 <paggas_> mmorrow: these are the problems when doing parallel programming on the x86 with the threading paradigm! :P
11:34:00 * mmorrow puts (chunksize,parallelism,memusage) for chunked mean on his to-generate-data-for-and-plot-with-R list)
11:34:04 <mmorrow> paggas_: heh
11:34:31 <dirk_> wikilink is a data contructor of type anthing
11:34:59 <dirk_> Anything
11:35:04 <ski> did you lose the `deriving (Show,Eq)' on `data Anything = ...' ?
11:35:33 <dirk_> well (Wikilink []) is
11:36:08 <dirk_> actually I can use it
11:38:45 <dirk_> yes it works!
11:41:35 <dschoepe> Is there a better way to change particular keys in a Data.Map.Map than removing them and adding the new changed keys?
11:43:25 <dino-> dschoepe: There are the adjust* and update* functions for Data.Map
11:43:48 <dino-> Or maybe you mean better way than what those are doing.
11:44:00 <dschoepe> dino-: Ah, thanks I overlooked those.
11:44:02 <Cale> dschoepe: Doing an insert normally will replace a key if it is already in the map
11:44:37 <dschoepe> I meant something like exchanging part of a key and keeping the respective values.
11:44:55 <dschoepe> mapKeys seems to be what I want
11:50:55 <pumpkin> mmorrow: sorry, I missed what you said... it scrolled off my screen
11:53:39 <gio123> any german speaker?
11:53:46 <dirk_> Jawohl
11:53:50 <dirk_> I am german
11:54:12 <opqdonut> shouldn't that be, I german am
11:54:17 <opqdonut> ;)
11:54:32 <opqdonut> hmm, I guess germans should be good at stack languages like forth
11:56:20 <gnuvince> @src interact
11:56:21 <lambdabot> interact f = do s <- getContents; putStr (f s)
12:02:51 <ski> @hoogle (acc -> x -> m (acc,y)) -> acc -> [x] -> m (acc,[y])
12:02:52 <lambdabot> No results found
12:03:13 <ski> @hoogle mapAccumLM
12:03:14 <lambdabot> No results found
12:03:16 <ski> @hoogle mapAccumML
12:03:16 <lambdabot> No results found
12:03:18 <ski> @hoogle mapAccumM
12:03:19 <lambdabot> Data.Generics.Twins gmapAccumM :: (Data d, Monad m) => (a -> d -> (a, m d)) -> a -> d -> (a, m d)
12:04:03 <ski> (yes, i know i can do `mapM' with `StateT acc m' ..)
12:04:20 <ski> @hoogle (acc -> x -> m acc) -> acc -> [x] -> m acc
12:04:21 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
12:04:22 <lambdabot> Data.Foldable foldlM :: (Foldable t, Monad m) => (a -> b -> m a) -> a -> t b -> m a
12:04:22 <lambdabot> Control.Monad foldM_ :: Monad m => (a -> b -> m a) -> a -> [b] -> m ()
12:05:36 <ski> (.. of course)
12:08:52 <ski> dirk_ : in `app', is the call `anything p b se' every supposed to be able to monadically return `[Evil]' ?
12:09:13 <ski> (s/every/ever/)
12:09:27 <dirk_> wait looking at it
12:10:28 <dirk_> you mean ever instead of every?
12:10:33 <ski> yes
12:11:13 <dirk_> so you are asking if anything can return [Evil]
12:12:14 <dirk_> not it should not
12:12:21 <dirk_> return [Evil]
12:12:40 <dirk_> in case of Evil it should fail
12:12:44 <ski> ok, fine
12:12:55 <ski> so in
12:12:56 <ski>   l <- try (anything p b se) <|> return [Evil]
12:13:17 <ski> if `l' ever is `[Evil]' that means the `anything p b se' call failed
12:13:24 <ski> right ?
12:14:12 <dirk_> wait
12:14:28 <FliPPeh> Man, how can I split a string with some extra checking without trying to go into procedural programming?
12:14:54 * sm likes the split package
12:14:59 <FliPPeh> IRC Line ":Testnick!user@host PRIVMSG #testchan :wat", I want those little parameters in there :(
12:15:06 <FliPPeh> But the : at the start does not have to be there
12:15:21 <FliPPeh> Neither must there be a !, if the server sends that line
12:15:54 <dirk_> ski you are right (certainty 99%)
12:21:19 <hackagebot> synthesizer-alsa 0.0.2 - Control synthesizer effects via ALSA/MIDI (HenningThielemann)
12:21:36 <gwern> all glory to the hypnotoad!
12:25:06 <Baughn> conal: http://haskell.org/haskellwiki/Unamb <-- Looking at this wiki page, as of version 0.2.2 it supports recursive termination and restarting on 10.3 too
12:25:17 <Baughn> I think
12:25:20 <Baughn> conal: I think
12:27:20 <hackagebot> haskore-synthesizer 0.0.3 - Music rendering coded in Haskell (HenningThielemann)
12:27:58 <FliPPeh> Can noone help me? ;<
12:28:03 <FliPPeh> I know there are smart people here
12:28:15 <FliPPeh> Well, not smart, but fluent in haskell
12:29:46 <Geheimdienst> flippeh: sm said he likes the split package ... ?
12:30:06 <FliPPeh> I don't want any packages that do most of the work for me
12:30:11 <FliPPeh> I want to learn :(
12:30:13 <gwern> -_-
12:30:24 <gwern> FliPPeh: so write a split on your own
12:30:31 <gwern> it's not that hard
12:30:59 <FliPPeh> For you. I'm no Haskell-coder yet, I'm just starting to learn
12:31:01 <yitz> FliPPeh: what's wrong with words?
12:31:13 <mgsloan> yeah, split is an awesome bike shed
12:31:17 <mgsloan> so many ways to approach it
12:31:23 <yitz> > words ":Testnick!user@host PRIVMSG #testchan :wat"
12:31:25 <lambdabot>   [":Testnick!user@host","PRIVMSG","#testchan",":wat"]
12:31:31 <pumpkin> lol
12:32:01 <gwern> mgsloan: never use awesome and bikeshed in the same sentence again
12:32:12 <gwern> I spent quite a bit of time banging on the bikeshedding of split
12:32:25 <FliPPeh> I somehow struggle on combining all that splitting and filtering to one single result
12:32:51 <mgsloan> gwern - sorry, haha!  I spent a good hour or two doing my particular angle on it as well
12:32:52 <yitz> gwern: i put my awesom bicycle in the ... bike storage hut.
12:34:15 <Geheimdienst> flippeh, here is some code i wrote recently: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2600#a2600
12:34:29 <mgsloan> here is my particular splitter: http://www.haskell.org/haskellwiki/Data.List.Split#Break_on_Nothing
12:34:34 <Geheimdienst> (i'm a newbie myself)
12:35:01 <Geheimdienst> i wrote a function using the span function, then passed that into unfoldr
12:35:03 <yitz> FliPPeh: did you write anything yet? can you say exactly what result you want for the example input you provided?
12:35:10 <gwern> FliPPeh: just work on one piece at a time. split looks something like this: 'split delim (s:rest) = if s == delim then split delim rest else s : split delim rest'
12:35:30 <FliPPeh> I want a combined algebraic data type
12:35:37 <FliPPeh> I tried different things, buut
12:35:54 <FliPPeh> after looking at the code, I found it really... dumb.
12:35:58 <yitz> FliPPeh: what does the ADT look like? do you have anything you can paste?
12:36:43 <FliPPeh> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2601#a2601
12:36:45 <FliPPeh> Like that
12:36:48 <FliPPeh> You see, really bad
12:37:00 <FliPPeh> But the only solution I'd know about :/
12:38:49 <gwern> Maybe Params seems kind of odd, if Params = [String]. what do you do with Just [] that differs from Nothing?
12:39:17 <FliPPeh> I didn't even think about that..
12:39:35 <FliPPeh> So yeah, help me get on track to make more elegant solutions
12:42:20 <gwern> all raise to the hypnotoad!
12:45:13 <jelly12gen> hi i installed libmpd for haskell on Arch
12:45:17 <pastorn> can anyone here say something cool about C#3.0? please! i started a game development course today that is running all through this summer and i want to be positive, but i feel that it might be hard
12:45:30 <jelly12gen> but i can't import Network.MPD
12:45:56 <jelly12gen> ow wait it does but only in ghci
12:46:03 <BMeph_> @remember FliPPeh Well, not smart, but fluent in haskell
12:46:03 <lambdabot> It is stored.
12:46:10 <pastorn> i know there's lambdas in 3.0, but it seems like some weird sort of lambdas, not very nice at all
12:46:49 <BMeph_> C# 3.0: Now, with 50% more Haskell than C# 2.5! ;p
12:46:56 <koala_man> how are they weird?
12:46:57 <ski> dirk_ : i was thinking of something more like <http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5665>
12:47:28 <pastorn> all i can think of is that quote about object oriented languages "If i want a banana I want a banana. I don't want to have to take a whole jungle"
12:47:35 <pastorn> </rant>
12:48:10 <dirk_> reading it
12:48:31 <ski> dirk_ : i found a type error that you probably have already fixed in some way in your code
12:49:10 <ski> dirk_ : er, also, i forgot removing `run = undefined' :)
12:52:11 <dirk_> the funny thing about haskell is that I am getting scare of the function I am calling and defining
12:52:29 <Geheimdienst> guys, i'm looking for a little feedback on this: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2603#a2603
12:52:36 <gwern> pastorn: well, I hear c# has monads. of a sort
12:52:39 <Geheimdienst> kinda my first haskell program after hello world ...
12:52:45 <ski> dirk_ : btw, i noted your `app2' was basically a call to `foldM'
12:53:09 <dirk_> yes I see
12:54:21 <dirk_> still I do have problems undstanding foldl and Monads seperately so foldM is not really simple
12:55:05 <ski> @src foldM
12:55:06 <lambdabot> foldM _ a []     = return a
12:55:07 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
12:55:17 <ski> well, say
12:55:34 <ski>   foldM _ s [    ] = return s
12:55:52 <ski>   foldM _ s (a:as) = do s' <- f s a
12:56:16 <ski>                         foldM f s' as
12:56:28 <ski> that's basically what you had in `app2'
12:56:32 <dirk_> ok
12:56:35 <ski> (well, `foldM f ...' in the second case)
12:56:45 <dirk_> I can understand the second definition you gave
12:57:04 <ski> i.e. walk through a list, execute an action on each list element, passing in a state, and passing on the output as the next state
13:01:15 <dirk_> slowly starting to get a feeling for that
13:01:15 <ski> Geheimdienst : why the `do' in `nextSegment' ?
13:01:31 <yitz> Geheimdienst: nice!
13:01:58 <yitz> Geheimdienst: stylisticly, I might not make nextSegment a top-level.
13:02:13 <ski> Geheimdienst : instead of `x == ""' you may (or may not) prefer `null x'
13:02:27 <yitz> Geheimdienst: instead: splitPath p = ... where nextSegment = ... or something like that
13:02:29 <Geheimdienst> thanks yitz :-)
13:02:54 <ski> Geheimdienst : instead of `if null x then Nothing else Just (...)' you may say `do guard (not (null x)); return (...)', if you prefer
13:02:59 <Geheimdienst> ski: good question ...
13:03:22 <ski> (it doesn't really matter much, here)
13:03:43 <ski> hm
13:03:44 <ski> actually
13:03:49 <Geheimdienst> ski: when i remove the do, i need to add an "in" before the if
13:03:50 <ski> @hoogle Bool -> Maybe a -> Maybe a
13:03:51 <lambdabot> Data.Generics.Aliases orElse :: Maybe a -> Maybe a -> Maybe a
13:03:51 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
13:03:51 <lambdabot> Control.Monad unless :: Monad m => Bool -> m () -> m ()
13:03:52 <Geheimdienst> is that normal?
13:03:56 <ski> yes
13:04:40 <Geheimdienst> ok, but why does let even work without the in ?
13:04:53 <ski> > unless False (return ()) :: Maybe ()
13:04:55 <lambdabot>   Just ()
13:05:08 <ski> Geheimdienst : it only does that as a command in a `do'-block
13:05:22 <ski> > unless True (return ()) :: Maybe ()
13:05:24 <lambdabot>   Just ()
13:05:27 <Geheimdienst> yitz: ah i see, hadn't realized i could just define the function in a where clause. cool
13:05:48 <ski> @src unless
13:05:49 <lambdabot> unless p s = if p then return () else s
13:05:53 <ski> oh, right
13:06:01 <yitz> > let splitPath = map (takeWhile (/= ':') . takeWhile (not . null) . iterate (drop 1 . dropWhile (/= ':')) in splitPath "/usr/local/bin:/usr/bin:/bin:/usr/bin/X11:/usr/games" -- <-- Geheimdienst
13:06:02 <lambdabot>   <no location info>: parse error on input `in'
13:06:16 <yitz> > let splitPath = map (takeWhile (/= ':')) . takeWhile (not . null) . iterate (drop 1 . dropWhile (/= ':')) in splitPath "/usr/local/bin:/usr/bin:/bin:/usr/bin/X11:/usr/games" -- <-- Geheimdienst
13:06:18 <lambdabot>   ["/usr/local/bin","/usr/bin","/bin","/usr/bin/X11","/usr/games"]
13:06:27 <Geheimdienst> ski: so it's more like an implementation side-effect that should not be relied on?
13:07:03 <ski> Geheimdienst : sure you can rely on it. just as long as you understand when `in' is required, and when it is prohibited
13:07:23 <ski> (maybe `prohibited' is somewhat misleading, but ..)
13:08:19 <Geheimdienst> ski: just tried it with both do and in. won't work. so i see what you mean :)
13:09:26 <ski> Geheimdienst : it will work if you indent the `in' (and the following action)
13:09:49 <ski> but that's only because `let .. in ..' is a valid expression, and hence a valid command in a `do'-block
13:10:06 <ski> (so it's not really a `let'-command in a `do'-block, in that case)
13:10:35 <Geheimdienst> whoa, ok
13:10:45 <Geheimdienst> the whole layout thing is still freaking me out
13:10:59 <cygnus> Can anyone tell me where I might go to get help with hscurses?
13:11:00 <ac> ack, so many web servers: salvia, mohws, httpd-shed, happstack, HAppS, and probably others
13:11:35 * ski seems to recall there were some hackage-lib with `Bool -> a -> Maybe a', but doesn't recall which
13:12:03 <leimy> Is that even hard to do?
13:12:13 <leimy> 'Bool -> a -> Maybe a ' that is
13:12:16 <yitz> Geheimdienst: it's not so freaky - mostly it's the way you'd indent anyway, so why bother with the {;} noise, just let the compiler do it for you.
13:12:21 <ski> leimy : it's easy
13:12:26 <byorgey> @djinn Bool -> a -> Maybe a
13:12:26 <leimy> I was going to say
13:12:27 <lambdabot> f a b =
13:12:27 <lambdabot>     case a of
13:12:27 <lambdabot>     False -> Nothing
13:12:27 <lambdabot>     True -> Just b
13:12:34 <ski> the question was if there was a standard name
13:12:40 <leimy> AH
13:12:42 <conal> Baughn: thx.  i've added a comment to the unamb wiki page: "unamb seems to be working well in version 0.2.2, under GHC 6.10.3."
13:12:46 <ski> (well "standard", i suppose)
13:12:46 <leimy> deBoolifyValue!
13:13:02 <byorgey> maybefy?
13:13:04 <ski> (istr there was an operator name in the lib)
13:13:07 <leimy> Falsinate!
13:13:16 <leimy> falsifyNothing
13:13:25 <byorgey> uncertainize
13:13:26 <leimy> or "justTrue"
13:13:36 <yitz> @type \x y -> guard x >> return y
13:13:38 <lambdabot> forall (m :: * -> *) b. (MonadPlus m) => Bool -> b -> m b
13:13:49 <ski> possibly it was `(<?>)'
13:14:04 <BMeph_> ac: You... oh, I guess Turbinado is just one of the "probably others". ;)
13:14:09 <ski> yitz : yes, ideally we'd like one with the condition negated, too
13:14:23 <ski> (for a moment above i was thinking `when' and `unless' would do)
13:14:51 <BMeph_> @djinn Bool -> Maybe ()
13:14:51 <lambdabot> f a =
13:14:52 <lambdabot>     case a of
13:14:52 <lambdabot>     False -> Nothing
13:14:52 <lambdabot>     True -> Just ()
13:15:07 <yitz> @pl \x y -> guard x >> return y
13:15:07 <lambdabot> (. return) . (>>) . guard
13:15:46 <Geheimdienst> yitz, thanks for the code, i pasted it to a new file for future tinkering :)
13:15:48 * ski has often used the `guard foo >> bar' pattern in conjunction with `unfoldr' ..
13:15:58 <ski> but it's somewhat ugly-looking
13:16:31 <yitz> Geheimdienst: no prob :) just another fun style. unfoldr is also quite cool.
13:17:16 <yitz> ski: yeah, it's a common idiom, it needs neatening.
13:17:30 <ski> Geheimdienst : i forgot to mention, you can define `(x, y)' in a `where' inside `nextSegment' too, instead of using `let'
13:18:22 <yitz> @type curry (uncurry (>>) . (guard *** return))
13:18:24 <lambdabot> forall (m :: * -> *) b. (MonadPlus m) => Bool -> b -> m b
13:18:36 <yitz> yuck
13:18:46 <Geheimdienst> ski: ok
13:19:16 <Geheimdienst> last question: how would you combine lines 29 + 30 ?
13:19:30 <Geheimdienst> so that you don't need the temprorary 'x'
13:20:01 <yitz> filterM doesFileExist $ map (\dir -> dir ++ "/" ++ filename) paths >>= putStrLn . unwords
13:20:02 <ski> putStrLn . unwords =<< filterM doesFileExist (map (\dir -> dir ++ "/" ++ filename) paths)
13:20:05 <RayNbow> conal: did you solve the lub problem?
13:20:10 <olsner> what ski said :)
13:20:20 <yitz> filterM doesFileExist (map (\dir -> dir ++ "/" ++ filename) paths) >>= putStrLn . unwords
13:20:26 <jeffersonheard> ping roconnor
13:20:53 <olsner> filterM (doesFileExist . (</> filename)) paths
13:20:54 <chromakode> any tips on zeroing in on an Int space leak?
13:21:04 <conal> RayNbow: Baughn fixed it.
13:21:36 <RayNbow> conal: ah, any details how he fixed it? :)
13:21:48 <Baughn> I fixed it?
13:21:53 <Geheimdienst> i see. cool
13:21:57 <conal> Baughn: yeah, i think.
13:21:59 * Baughn hasn't touched lub
13:22:18 <conal> oh.  the lub bug was really an unamb bug
13:22:19 <yitz> chromakode: I thought Int was pretty limited in size
13:22:41 <chromakode> yitz: I seem to be allocating Ints in some recursive code and blowing the stack.
13:22:48 <yitz> oh. :)
13:22:52 <roconnor> jeffersonheard: ack
13:22:54 <jeffersonheard> roconnor: do I recall correctly that to convert your AlphaColours to 4-component vectors, the formula is: toSRGB $ (1/alpha) `darken` (c `over` black)
13:23:01 <chromakode> hp2ps shows it's in a mapping function, but I can't figure out what I need to strictify
13:23:06 <yitz> chromakode: do you use foldl anyplace?
13:23:17 <jeffersonheard> and expand the RGB and return alpha?
13:23:23 <chromakode> yitz: nope, this is ST monad code
13:23:35 <Geheimdienst> olsner: holy shmokes that's cool. i didnt know about </> and combine. thanks!
13:23:40 * RayNbow is going to figure out how to update unamb and reinstall lub... :p
13:23:50 <roconnor> jeffersonheard: yes, I think that is correct, plus you may wish to deal with the case when alpha = 0
13:23:58 <chromakode> yitz: does this set off any red flags? http://www.moonpatio.com/fastcgi/hpaste.fcgi/view?id=2605#a2605
13:23:59 <ski> @index </>
13:23:59 <yitz> chromakode: hmm. ok. I guess you'll have to paste then.
13:24:00 <lambdabot> Text.Html
13:24:03 <ski> @index combine
13:24:04 <lambdabot> Language.Haskell.TH.Lib
13:24:30 <chromakode> yitz: I'm a profiling noob -- profiling with -hc points to this code
13:24:54 <jeffersonheard> roconnor: ah yes, that's my problem
13:25:01 <Geheimdienst> ski: no, in system.filepath.posix
13:25:15 <roconnor> jeffersonheard: what is the problem?
13:25:29 <ski> @. type . (uncurry (++ "." ++)) (index *** id) combine
13:25:30 <lambdabot> Plugin `compose' failed with: Unknown command: "(uncurry"
13:25:33 <chromakode> yitz: I added some more code
13:25:39 <jeffersonheard> roconnor: oh, that I kept getting a divide by zero
13:25:44 <roconnor> :)
13:26:01 <roconnor> transparent has no well defined colour channels
13:26:02 <jeffersonheard> the alpha was being set programmatically, so I suppose that it was occasionally zero
13:27:06 <yitz> chromakode: a s is really STRef s Int?
13:27:13 <yitz> or whatever?
13:27:19 <ski> @type (System.Filepath.Posix.</>)
13:27:21 <lambdabot> Couldn't find qualified module.
13:27:32 <chromakode> yitz: hmm, a s is actaully just Int
13:27:47 <Geheimdienst> ski: FilePath
13:27:50 <roconnor> jeffersonheard: maybe I should make a package that depends on cairo and colour to provide this function.
13:27:58 <Geheimdienst> sorry for the sloppiness :)
13:28:03 <chromakode> yitz: if you refresh, I added where it's getting called
13:28:10 <ski> Geheimdienst : er, right, ok
13:28:14 <roconnor> jeffersonheard: (although I think this function really ought to go in cairo)
13:28:29 <chromakode> yitz: the heap graph shows a leak from (385)negamax/doUndo/mapMov...
13:28:33 <yitz> chromakode: oh, then why are you in the ST monad?
13:28:38 <jeffersonheard> roconnor, nah - I'm cross implementing Hieroglyph now in both OpenGL and Cairo so that the same code works on both
13:28:54 <chromakode> yitz: I'll understand if there's not much you can do with this little info -- it's in the ST monad because it's doing Array stuff behind the scenes
13:28:56 <jeffersonheard> so anyone who wants it can just import Hieroglyph and call colourToTuple
13:29:16 <roconnor> jeffersonheard: are you doing any shading with OpenGL?
13:29:33 <RayNbow> conal: lub works in GHC 6.10.3 :)
13:29:56 <RayNbow> (on my older machine it still crashes... but that might be because of a bug in 6.10.1)
13:30:07 <jeffersonheard> not yet.  Will probably implement the next round of this in vertex/fragment shaders later.  Right now I want it to be compatible with older cards
13:30:27 <roconnor> ok
13:30:38 <conal> RayNbow: sweet!  have fun with it.  have you read the blog posts?  http://conal.net/blog/tag/lub
13:31:01 <roconnor> jeffersonheard: you might want to read my long speil about OpenGL in my docs.  Let me know if you have any questions.
13:31:04 <roconnor> gotta go now
13:31:04 <conal> if you come up with nifty uses for unamb or lub, please let me know.
13:31:12 <RayNbow> conal: no, I haven't... I've only read one of your posts about unamb a few months ago
13:31:29 <RayNbow> (there's too much stuff to read on the web :p)
13:31:47 <RayNbow> (if only I could forkIO myself :p)
13:31:59 <conal> go forkIO yourself!
13:32:45 <yitz> chromakode: well, yeah, if you've got millions of moves, and you're in the lazy ST monad, you'll pile up a mountain of undoMove thunks with that.
13:33:37 <hackagebot> iteratee 0.2.1 - Iteratee-based I/O (JohnLato)
13:33:39 <chromakode> yitz: negamax is a function that returns a "Score", which is an Int -- I think something is preventing it from freeing old Scores as it recurses
13:34:10 <chromakode> yitz: why do the undoMove thunks get piled? isn't Control.Monad.ST strict?
13:34:22 <yitz> no it's lazy
13:35:02 <chromakode> I thought it was strict by default? http://www.haskell.org/ghc/dist/current/docs/libraries/base/Control-Monad-ST-Strict.html
13:35:17 <RayNbow> conal: currently I have http://conal.net/papers/icfp97/ in my reading queue btw
13:35:20 <chromakode> please excuse my noobiness
13:36:14 <chromakode> yitz: oh, I think I see what you're getting at -- undoMove never gets evaled, even though I expect it to have mutable effect
13:36:43 <conal> RayNbow: enjoy!
13:37:58 <conal> RayNbow: have you read the online fran tutorial (with animated illustrations)?  it's an easy intro to the ideas.  http://conal.net/fran/tutorial.htm
13:38:07 <pumpkin> @hoogle div
13:38:08 <lambdabot> Prelude div :: Integral a => a -> a -> a
13:38:08 <lambdabot> Data.Fixed div' :: (Real a, Integral b) => a -> a -> b
13:38:08 <lambdabot> Control.Exception DivideByZero :: ArithException
13:38:20 <yitz> chromakode: hmm, but you *do* do something with it - you negate . minimum it.
13:38:28 <RayNbow> conal: hmm, not yet... I'll read it :)
13:38:34 <yitz> chromakode: that should force those thunks.
13:38:43 <chromakode> yitz: that's what I thought -- it took care of some other space leaks.
13:38:58 <chromakode> yitz: any suggestions for zeroing in on exactly where the Ints are being allocated?
13:39:09 <chromakode> I am pretty new to space profiling
13:39:19 <RayNbow> btw conal, is it important to know what \sqsubseteq means?
13:40:12 <conal> RayNbow: yeah.
13:41:18 <conal> RayNbow: a [= b means that b has at least the information content of a
13:41:33 <RayNbow> ah k
13:41:40 <chromakode> yitz: the full stack is :(385)negamax/doUndo/mapMoves/negamaxMoves/negamaxMovesID/runNegamaxTurn/main -- so mapMoves calls doUndo, which calls negamax, which leaks
13:42:08 <yitz> chromakode: just for fun, put in let depth' = depth - 1 and see if that helps
13:42:13 <chromakode> hehehe
13:42:15 <chromakode> I thought about that
13:42:20 <chromakode> okay
13:43:06 <chromakode> is that enough to force evaluation? could a bang pattern on the signature work as well?
13:43:53 <chromakode> yitz: hmm, doesn't seem to have an effect.
13:44:23 <yitz> chromakode: eh, some people spray bangs all over the place when this happens. not my style, unless I have a specific reason that a particular bang will help. but your call.
13:45:03 <chromakode> yeah, that makes it hard to establish causality
13:45:09 <chromakode> depth doesn't seem to be affecting it
13:45:20 <chromakode> thanks very much for your help so far
13:46:34 <yitz> chromakode: ok, how about the (+1)'s on nodeCount. anything forcing that?
13:46:46 <chromakode> yitz: would that allocate Ints, though?
13:47:04 <yitz> don't know, what's its type?
13:47:07 <chromakode> I'm looking at 8 mb of Ints that shouldn't be appearing
13:47:09 <chromakode> it's an Int
13:47:13 <chromakode> STRef Int, actually
13:47:16 <yitz> right
13:48:21 <yitz> chromakode: stack overflows are usually thunks, not the Ints themselves. are you sure it's the actual Ints?
13:48:30 <chromakode> yitz: how can I check?
13:49:42 <chromakode> yitz: here's the entire file, including negamaxMoves: http://github.com/chromakode/havoc/blob/adf0d211a84574a9aa92cf9d2fb38de0cd082f3e/Havoc/Player/Negamax.hs
13:55:38 <chromakode> yitz: well, thanks for your help. I'll keep poking around and let you know if I find anything :)
13:57:53 <yitz> chromakode: one more idea. try changing the import to Data.STRef.Strict
13:58:15 <chromakode> okay
13:59:26 <chromakode> yitz: still getting overflows :(
13:59:41 <yitz> chromakode: hmm
14:00:09 <chromakode> it'll probably end up being something silly :)
14:01:56 <yitz> chromakode: yeah. try digging deeper in the profiling, I guess. (But I'm not good at that, maybe someone else here can help.)
14:03:04 <chromakode> yitz: thanks very much for all your help!
14:31:30 <TomMD> Incase anyone likes toys: I recently uploaded Tim Sheards LambdaCalculator which can perform beta-reduction one step at a time - fun to play with and useful if you're learning lambda calc.
14:38:42 <malouin> @type bindP
14:38:43 <lambdabot> Not in scope: `bindP'
14:40:31 <jix_> hi, is there any reason (a -> a) isn't an instance of Monoid? (where mappend is (.))
14:41:37 <mux> jix_: it is, wrapped in the Endo newtype
14:41:46 <jix_> thanks :)
14:42:12 <malouin> where is bindP defined?
14:42:49 <yitz> @hoogle bindP
14:42:50 <lambdabot> No results found
14:45:11 <chromakode> yitz: I sneezed a bunch of bangs all over the place and applied your suggestions, and it seems to be overflowing *slower* ;)
14:45:31 <yitz> heh. is that good or bad?
14:45:59 <chromakode> good, I hope
14:46:11 <chromakode> that would suggest it's wasting memory more slowly ;)
14:46:49 <irek_j> hi
14:48:29 <yitz> chromakode: this is why I try very hard to avoid ST. It makes things harder for both humans and ghc to really figure out what's going on.
14:48:35 <yitz> irek_j: hi
14:49:59 <irek_j> I am wondering what is the reason why multiple param type classes are not allowed in standard haskell? should I try to avoid them or substitute with something else or not bother and use ghc extention?
14:50:38 <Saizan> they weren't implemented at the time, probably
14:51:05 <TomMD> irek_j: in other words, feel free to use the GHC Extension.
14:51:12 <irek_j> what I'm trying to do is something like
14:51:13 <irek_j> class Box a b where
14:51:13 <irek_j>   unbox :: a b -> b
14:51:13 <irek_j> just for sake of an intellectual excercise for the moment
14:51:13 <quicksilver> it either wasn't obvious how useful they were, or it was obvious that they needed 'something else' to be useful
14:51:24 <quicksilver> (fundeps or type families)
14:51:29 <yitz> irek_j: MPTC was not part of Haskell when the standard was writtin in 1998.
14:51:29 <irek_j> I see
14:51:55 <SamB> yitz: well, duh
14:52:00 <SamB> it's not in the standard
14:52:06 <SamB> or the one before
14:52:08 <TomMD> @where haskell'
14:52:09 <lambdabot> http://hackage.haskell.org/trac/haskell-prime
14:52:18 <SamB> yitz: but was it implemented?
14:52:23 <quicksilver> irek_j: looks reasonable to me.
14:52:36 <yitz> SamB: no
14:52:53 <TomMD> They'll be in the next standard though... Haskell 2025 I think it is.
14:52:54 <yitz> SamB: I don't think people were thinking about that yet in 1998.
14:53:09 <irek_j> I believe this class would allow me to write a generic lift function given I make a type an instance of  Box
14:53:13 <yitz> SamB: or they were, and what quicksilver said.
14:53:20 <irek_j> thanks a lot guys
14:53:22 <SamB> TomMD: who gives a about Haskell 2025?
14:53:55 <SamB> quicksilver seems to have described why we're still at H98, actually ;-)
14:54:01 <pastorn> @seen ValarQ
14:54:01 <lambdabot> I haven't seen ValarQ.
14:54:02 <TomMD> Well that's when Haskell' will get approved and lots of people seem to care about Haskell'.  Why should we care less just because its a ways away.
14:54:21 <yitz> TomMD: you think so, do you? let's form a committee.
14:55:00 <TomMD> And see what finishes first... the committee agreeing on a guess when Haskell' gets out or Haskell' actually getting out?
14:55:08 <chromakode> yitz: I agree :(
14:56:08 <kowey> is anybody here running the Haskell Platform beta on MacOS X?
14:56:48 <yitz> kowey: not me
14:56:52 * yitz sobs
14:57:25 * kowey pats yitz on the back
14:57:30 <yitz> thanks
14:57:47 <yitz> (sniffle)
14:57:59 <kowey> if anybody is, I'd like to see if you get the same errors building the darcs darcs with it: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5670#a5670
15:00:59 <Saizan> haskell' is now a "rolling release", no?
15:04:03 <Zao> > let haskell' = ?derive ?haskell
15:04:05 <lambdabot>   not an expression: `let haskell' = ?derive ?haskell'
15:04:14 <Zao> Aaw, my lambda-fu is too weak.
15:04:28 <Saizan> that works only for ?type
15:14:46 <FliPPeh> How do I safely check the status of a socket?
15:14:58 <FliPPeh> Like with either?
15:15:17 <FliPPeh> case hOpen handle of ...
15:15:23 <FliPPeh> Left success, Right failure
15:17:25 <chromakode> yitz: still working, but I think you were right -- it's in the modifySTRef
15:17:33 <monochrom> Haskell 2025? Is that like Skynet Haskell? :)
15:18:27 <TomMD> No, its a Functional Language with a strong enough type system you can prove it _isn't_ Skynet.
15:18:29 <chromakode> Haskell Forever?
15:18:33 <Saizan> FliPPeh: so you've an Handle and want to know the staturs of the socket associated with it?
15:18:39 <FliPPeh> Yes!
15:18:44 <FliPPeh> I've got hIsOpen
15:18:49 <FliPPeh> Works fine is there is no error
15:18:56 <FliPPeh> But IF there is one, I get that:
15:18:59 <Saizan> ?hoogle hIsOpen
15:18:59 <lambdabot> System.IO hIsOpen :: Handle -> IO Bool
15:19:02 <FliPPeh> Main: getHostByName: does not exist (no such host entry)
15:19:08 <FliPPeh> It just throws at me
15:19:14 <FliPPeh> Although I've got it in a case
15:19:25 <Saizan> you can catch those exceptions with Control.Exception.catch
15:19:29 <FliPPeh> if isopen == True then putStrLn "Success!" else putStrLn "Fail!"
15:19:32 <Saizan> the case won't do it
15:19:51 <Saizan> i guess you can use try
15:20:00 <Saizan> ?type Control.Exception.try
15:20:01 <lambdabot> forall a e. (GHC.Exception.Exception e) => IO a -> IO (Either e a)
15:20:44 <TomMD> Gah!!! 'threadDelay' is getting replaced with 'sleep'?? Damn it, now all the new Haskell programmers will have one less reason to need hoogle.
15:20:54 <idnar> haha
15:21:03 <FliPPeh> catch (connect server port)
15:21:04 <FliPPeh> ?
15:21:11 <FliPPeh> How do I get the handle after that?
15:21:53 <Zao> @type catch
15:21:55 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
15:22:02 <chromakode> yitz: oh.. my.. god!!!! the Ints that were leaking was the '1' in (+1)
15:22:31 * chromakode rages
15:24:27 <FliPPeh> I don't understand that exception stuff in Haskell, it's so easy in other languages
15:24:39 <FliPPeh> catch (handle) (\e -> do let err = show (e :: IOException)  return (res <- handle))
15:24:41 <FliPPeh> The hell?
15:27:40 <FliPPeh> What the..
15:28:12 <TomMD> FliPPeh: The exception library underwent a major reworking recently so you might see contradictory uses and examples.  Just FYI.
15:28:31 <FliPPeh> I just want a working socket code
15:28:37 <chromakode> dunno FliPPeh -- first of all, some line breaks would help, and I just think Haskell's typing system is awesome enough to actually capture the semantics of exceptions natively
15:28:40 <FliPPeh> That does NOT kill my whole app when something doesn't work
15:29:03 <TomMD> FliPPeh: There now exists 'exception-old' and 'exception'.  As for Socket code - I even proposed a complete overhall ('Haskellization') of the network library before - it really needs to be more than just some FFI bindings.
15:29:10 <FliPPeh> I actually do linebreak, just when I copy it it doesn't break
15:29:38 <Saizan> FliPPeh: i don't understand the code you've pasted
15:29:43 <TomMD> *overhaul, as if that wansn't obvious.
15:30:15 <FliPPeh> I'm finding a lot of network code samples on the net
15:30:25 <FliPPeh> Just none of them even care about error checking
15:31:14 <Saizan> FliPPeh: however you can write do isopen <- try (hIsOpen h) :: IO SomeException Bool; case isopen of Right True -> putStrLn "success!"; _ -> putStrLn "fail!"
15:31:25 <Saizan> ops
15:32:03 <Saizan> do isopen <- try (hIsOpen h) :: IO (Either SomeException Bool); ..
15:32:10 <FliPPeh> It doesn't throw on hIsOpen
15:32:17 <FliPPeh> It throws on connectto
15:32:32 <Saizan> then wraps connectTo in try
15:32:34 <FliPPeh> So when I wrap in into a catch, I can't get the damn handle
15:32:45 <FliPPeh> At least I can't with my knownledge
15:32:45 <Saizan> why not?
15:33:34 <Saizan> do handle <- catch (connectTo ...) (\(SomeException e) -> <handle the exception here>); <use the handle here>
15:34:19 <Saizan> or you could wrap the whole thing in a catch
15:34:29 <Saizan> that's up to you
15:35:18 <Saizan> catch is usually written infix
15:35:39 <Saizan> like "connectTo .. `catch` \(SomeException e) -> .."
15:36:03 <FliPPeh> Okay
15:36:06 <FliPPeh> It's working
15:36:33 <FliPPeh> Man, it's hard to get unused of imperative programming.. it was so easy to just surround all of the dangerous codes with try-catch
15:37:11 <Saizan> here you just have to surround it with catch, it's not that different :)
15:37:17 <FliPPeh> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2608#a2608
15:37:23 <FliPPeh> I think that's a pretty good start so far
15:37:55 <FliPPeh> Haskell is so good when it's all working...
15:38:00 <Saizan> the "case .." should be aligned with the above handle
15:38:10 <Saizan> did you see my lines about catch?
15:38:13 <FliPPeh> Could rip out my hair when it's not working
15:38:15 <FliPPeh> Erm
15:38:18 <FliPPeh> Yep
15:38:39 <chromakode> hey all, could anyone take a look at modifySTRef with me? I'm having a weird strictness issue.
15:38:57 <Saizan> ?type modifySTRef
15:38:58 <lambdabot> forall s a. STRef s a -> (a -> a) -> ST s ()
15:39:09 <chromakode> right
15:39:23 <chromakode> I'm incrementing a counter in a recursive call tree
15:39:40 <Saizan> chromakode: well if you just modifySTRef a lot on a type like Int without ever reading then yeah, you're building an huge unevaluated thunk
15:39:41 <chromakode> modifySTRef ref (+1) is lazy, and thunkpiles
15:39:53 <chromakode> Saizan: how could I keep it from thunkpiling?
15:40:20 <chromakode> simply modifying the modifySTRef implementation to use "$!" does the trick
15:40:30 <chromakode> it's disconcerting that modifySTRef from STRef.Strict is Lazy...
15:41:06 <Saizan> yeah, write your own stricter version
15:41:16 <chromakode> Saizan: would you say that's a bug in the implementation?
15:41:21 <chromakode> or an issue of semantics?
15:41:37 <Saizan> it's just that the function is not written for your use case
15:41:58 <chromakode> Saizan: I see :(
15:42:23 <chromakode> I mean, I understand that for STRef.Lazy, but it doesn't feel like it's the default use case for .Strict
15:42:23 <Saizan> which might be an API design flaw
15:42:39 <chromakode> is it worthwhile to write a bug report for something like that?
15:42:45 <Saizan> the .Strict is only strict in the effects, not in the values contained
15:43:09 <Saizan> i wouldn't know :)
15:43:37 <chromakode> thanks Saizan, that's a good point
15:43:39 <brian6> i'm finding it really laborious to get the local seconds since midnight. i get get time of day with fmap (localTimeOfDay . zonedTimeToLocalTime) getZonedTime, but todSec is a Pico. am i supposed to fromEnum it and divide it by 10^12?
15:46:31 <Apocalisp> What's a concise way of building a list where the presence of each element depends on a corresponding Bool in another list?
15:47:06 <Apocalisp> f [True, False, True] [a, b, c] == [a, c]
15:48:11 <Saizan> > [ x | (True,x) <- zip [True, False, True] [a, b, c]]
15:48:12 <lambdabot>   [a,c]
15:48:41 <dino-> brian6: I think you can (truncate . utcTimeToPOSIXSeconds) maybe
15:48:49 <gnuvince_> > filter first $ zip [True, False, True] [a, b, c]
15:48:50 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
15:49:03 <brian6> dino-: thanks, checking.
15:49:09 <gnuvince_> hmm
15:49:10 <dino-> mm, what module is that in.. let me poke around a bit..
15:49:12 <Saizan> > filter fst $ zip [True, False, True] [a, b, c]
15:49:13 <lambdabot>   [(True,a),(True,c)]
15:49:19 <deeflex> Hey, Need some serious help guys. Check this out: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5671#a5671 . Crazy I know =)
15:49:23 <Saizan> > map snd . filter fst $ zip [True, False, True] [a, b, c]
15:49:24 <lambdabot>   [a,c]
15:49:27 <Apocalisp>  @pl (\x y -> filter fst (zip x y))
15:49:31 <Apocalisp> @pl (\x y -> filter fst (zip x y))
15:49:32 <lambdabot> (filter fst .) . zip
15:49:32 <deeflex> stack overflow
15:49:41 <eternal_champ> hey any happstackers here
15:50:51 <Saizan> deeflex: first of all, {-# LANGUAGE BangPatterns #-} and "loop fi di vi ei !i = ..."
15:50:59 <Saizan> eternal_champ: try #happs
15:51:43 <deeflex> Saizan, I'm not sure I understand?
15:52:23 <Saizan> deeflex: you're using i as an accumulator parameter, right?
15:52:24 <dino-> > Control.Monad.liftM truncate Data.Time.Clock.POSIX.getPOSIXTime
15:52:25 <lambdabot>   Not in scope: `Data.Time.Clock.POSIX.getPOSIXTime'
15:52:38 <dino-> bleh
15:52:57 <deeflex> Saizan, my intention was a counter..
15:53:07 <dino-> But getPOSIXTime seems to do that utcTimeToPOSIXSeconds step
15:53:16 <dino-> brian6: In Data.Time.Clock.POSIX
15:53:20 <Saizan> deeflex: the problem is that you never evaluate i until the end, where it has become an huge thunk of the form (1+1+1+1+1+1+1+...) and evaluating that stack overflows
15:53:49 <Saizan> deeflex: so, to avoid building the (1+1+1+1+1+..) thunk you've to evaluate it at each step
15:53:59 <Saizan> deeflex: there are many ways
15:54:23 <Saizan> deeflex: do you know about seq?
15:54:33 <brian6> dino-: hmm. that kind of helps, but it's seconds since the epoch, not since start of day.
15:54:37 <deeflex> Saizan, no I don't know about seq
15:55:02 <dino-> brian6: ah hm
15:55:29 <Saizan> deeflex: seq a b evaluates 'a' as far as determining it's outermost constructor before returning b
15:55:43 <Saizan> deeflex: so you can write loop fi di vi ei i
15:56:00 <brian6> dino-: oh, i can (truncate . todSec) tod.
15:56:05 <dino-> Could do epoch right now minus epoch from midnight today.
15:56:21 <Saizan> loop fi di vi ei i | (length fi > 3) =  let i' = i+1 in i' `seq` loop newfi newdi newvi newei i'
15:57:00 <Saizan> to force th evaluation of the i+1 expression
15:57:15 <Saizan> @wiki Stack overflow
15:57:15 <lambdabot> http://www.haskell.org/haskellwiki/Stack_overflow
15:57:17 <Saizan> for more
15:57:48 <deeflex> Saizan, ok thanks
15:58:19 <Baughn> Saizan: You pretty much need to understand the evaluation model to write correct haskell programs. So don't you think it should be emphasized a bit more in tutorials?
15:58:21 <dino-> Data.Time.Format.parseTime is like formatTime in reverse, same % codes
15:58:33 <Baughn> Saizan: I've yet to see a newbie that doesn't fall in this trap
15:58:37 <chromakode> I agree Baughn, I've been bitten by that frequently today
15:59:26 <Saizan> Baughn: i don't read enough tutorials to tell :)
15:59:37 <Baughn> chromakode: I usually manage to avoid it, but it hasn't been too long since last I got frustrated by a "memory leak" caused by lazy evaluation
15:59:46 <Saizan> Baughn: however i guess explaining lazy eval should be one of the central points
15:59:47 <dino-> brian6: Could be used to parse "2009-06-08 00:00:00" for that subtraction from time right now
15:59:53 <chromakode> Baughn: well, that was 5 hours of my day :)
16:00:14 <Baughn> "let a = ...; b = part of a in <use b>" -- a gets forced in order to produce b, never gets GC'd because it gets used right afterwards
16:00:20 <Saizan> avoiding explicit recursion tends to help.
16:00:38 <brian6> dino-: yeah. i think i'm still not getting it done the shortest way, but with truncate, it's not too bad. thanks.
16:00:41 <Baughn> Only so much. You still need to know when to choose foldr or foldl..
16:01:03 <Saizan> foldl' you mean :)
16:01:25 <Baughn> There you go. :P
16:01:29 <Baughn> No, foldl.
16:01:44 <Saizan> foldl?
16:01:56 <Baughn> ..I was testing unamb, and was folding bottoms
16:02:10 <Baughn> It's a bit unusual, granted.
16:02:17 <Saizan> ah, ok
16:02:50 <Saizan> well, right, you can't just program without knowing what you're doing
16:03:31 <Saizan> i guess the perils of lazy eval are not taken in consideration early to not scare newbies :) maybe that's counterproductive
16:03:46 <Baughn> I think it is.
16:04:25 <Baughn> I think strange stack/heap overflows or plain memory leaks are considerably more off-putting than a chapter on in-depth lazy evaluation..
16:05:30 <Saizan> and not being able to read type errors is quite worse than a chapter on the type system :)
16:05:47 <Saizan> i guess we'd like the same kind of tutorials
16:07:40 <mike-burns> I'm trying to install gtk2hs 0.10.1 on Ubuntu Intrepid (instead of using the old version in apt) and running into issues. I'm pretty bad with Ubuntu so maybe someone can tell me what I'm doing wrong? Here's configure, make, and a list of all package I have installed: http://mike-burns.com/misc/gtk2hs.log.txt
16:07:45 <mike-burns> (The make step is failing.)
16:08:41 <Baughn> mike-burns: Looks like your version of gtk doesn't match what gtk2hs expects. Probably it's too old
16:08:56 <mike-burns> Ah that makes sense.
16:09:30 <Baughn> mike-burns: For comparison, it builds fine with gtk+-2.14.7
16:11:16 <mike-burns> I'll try upgrading GTK. Thanks.
16:11:24 <_Jordan_> Couple of newbie questions, if I may. Reading through RWH, and spending a lot of time on the Monad chapter. 1) How often is List used in its monadic context (e.g. with do/>>=)? 2) To me, with lists at least, the >>= form (as opposed to do) seems a lot clearer, whereas with Maybe/IO, the do form seems clearer. Is this normal? 3) Is writing monadic code without "do" frowned upon?
16:12:39 <dino-> Me as well needing tutorials. I feel poorly educated so far with lazy eval. I just read something a day or so ago about irrefutable patterns and finally thought "Oh, so that's what the ~ is for" and am still shaky on seq.
16:12:57 <ray> 1) mostly with comprehensions, 2) i don't see why not, 3) hardly
16:13:10 <Saizan> 3) not really, but for some expressions do-notation is more terse
16:13:22 <aavogt> @quote seq
16:13:23 <lambdabot> _pizza_ says: i think Haskell is undoubtedly the world's best programming language for discovering the first few dozen numbers in the Fibonacci sequence over IRC
16:13:34 <aavogt> @quote seq
16:13:34 <lambdabot> skew says: [monads are] just like the sequences of statements in other languages. Except very rarely have they thought so deeply about what that sequencing means
16:13:41 <_Jordan_> ray, Saizan: thanks :)
16:14:18 <Saizan> i guess lists are most often used as reifications of loops
16:14:24 <Baughn> _Jordan_: Using the raw combinators is quite common, when pipelining data. For example, "takeMVar v1 >>= putMVar v2 . Foo" or some such
16:14:45 <Baughn> _Jordan_: Nobody is going to frown upon it unless the code is hard to read, in which case you presumably wouldn't do it. :)
16:15:05 <EvilTerran> the general guideline is "do what's clearest"
16:15:14 <ray> lists are fmapped over all the time
16:17:18 <EvilTerran> ray, well, in the same way (e ->)s are ;)
16:17:44 <aavogt> Baughn: =<< would be nicer in that example? What do people think about mixing left-to-right and right-to-left operators?
16:18:33 <_Jordan_> alright. Oh, one more question: I *think* I may have had an epiphany about IO last night... so there's not actually a way in Haskell code to implement the IO instance's (>>=) and return functions?
16:18:36 <ray> map and (.) should be generalized to all functors
16:18:42 <Baughn> aavogt: You may have a point there. :P
16:19:18 <mib_pzmoce> hi guys!i have a question:is it normal(or a reported or solved bug),that if write in the shell: "9^(9^9)",then it crashes?(sorry for my english)
16:19:24 <Baughn> _Jordan_: Indeed
16:19:33 <EvilTerran> _Jordan_, there's a fundamental core of the IO monad that's unimplementable, yeah
16:20:09 <Baughn> mib_pzmoce: Yes.
16:20:19 <ray> as it turns out, 9^(9^9) is a very large number
16:20:21 <_Jordan_> Awesome, so that means there's no way to "IOify" or "UnIOify" something pure without interacting with another IO, right?
16:20:41 <EvilTerran> _Jordan_, although there could be a concrete ADT underneath the abstract IO, you'd still need "magic" to actually run the side-effects
16:20:50 <bd_> mib_pzmoce: you would need about a gigabyte of memory just to hold the final result of that computation.
16:20:58 <Baughn> _Jordan_: Yep, that's the whole point.
16:21:10 <EvilTerran> _Jordan_, well, you can invoke pure code from IO code, but not the other way around
16:21:16 <EvilTerran> _Jordan_, and you can tell them apart by the types
16:21:17 <mib_pzmoce> but,i thought it shouldnt exit whit segmentation fault
16:21:17 <bd_> mib_pzmoce: add in some more for the intermediates, and you'll quickly run out of address space on the i386 for that computation. hence it will crash.
16:21:25 <Baughn> _Jordan_: ..unsafePerformIO kind of breaks that contract, but don't think too much about that one.
16:21:29 <_Jordan_> Amazing, thanks all :) Stuff is just now starting to click
16:21:36 <bd_> mib_pzmoce: Yeah, I guess.
16:22:43 <mib_pzmoce> could you try that it is in new version ghci,too?because mine is quite old
16:23:29 <bd_> I'm on 64-bit, it would probably succeed after bringing my system grinding to a halt for a few hours :)
16:24:24 <mib_pzmoce> bd_:how much memory do you have?
16:24:44 <deeflex> Saizan, It's late now think I'll dig into that article tomorrow. But how should I use that seq a b? Like seq((i+1) 1) in my loop? :S
16:24:58 <bd_> mib_pzmoce: 4G, most in use at the moment - and I don't have a recent GHC installed :)
16:25:06 <Baughn> > log 9 * (9^9)
16:25:08 <lambdabot>   8.512498201944165e8
16:25:21 <Baughn> bd_: No. No, I don't think it'd succeed for you either.
16:25:38 <ray> you might want to rent some time on a cluster
16:25:39 <Saizan> deeflex: loop fi di vi ei i | (length fi > 3) =  let i' = i+1 in i' `seq` loop newfi newdi newvi newei i'
16:26:05 <FliPPeh> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2609#a2609 in the case with the 3 "?", I want to get the handle.. but my handle variable has become an Either value..
16:26:13 <FliPPeh> Because of the catch
16:26:18 <FliPPeh> How do I "export" it outside?
16:26:29 <bd_> Baughn: log_2 (9^(9^9)) is 1.22809*10^9 which is ~1,228,090,000 bytes - indeed.
16:26:42 <bd_> was off by one order of magnitude there
16:26:44 <Botje> FliPPeh: your code can't do anything meaningful if the handle becomes a left
16:26:57 <Saizan> FliPPeh: you can simple move that code in the Right branch of the case
16:26:59 <Botje> so you have to push that code inside the case for Right
16:27:05 <Saizan> FliPPeh: or use catch instead of try
16:28:06 <mib_pzmoce> thank you guys for helping!
16:29:29 <Saizan> FliPPeh: refresh the page to see my pastes
16:29:31 <deeflex> Saizan, ok thanks, but I still get a stack overflow with that modification. :/
16:29:34 <jimmyjazz14> anyone know of any good examples of parsing nested blocks of code from a text file with haskell?
16:30:08 <Saizan> deeflex: ok, then there's some other problem
16:31:16 <deeflex> Saizan, ye..
16:31:54 <ray> tetration sure is expensive
16:32:10 <pumpkin> mmorrow: around?
16:32:24 <pumpkin> ray: you're surprised? :P
16:32:50 <ray> i'm not
16:33:01 <ray> just putting a finishing statement on that last discussion
16:33:01 <FliPPeh> Oh man, I forgot to stay in the right branch :)
16:33:05 <pumpkin> ah :)
16:33:08 <FliPPeh> Thanks for putting me back on track guys
16:33:18 <deeflex> Saizan, allright I'll come back tomorrow. Maybe some other ppl knows something. Thanks for your help still, much appreciated
16:33:22 <pumpkin> modular tetration, on the other hand... :P
16:33:24 <FliPPeh> I begin to understand all this already
16:34:22 <Saizan> deeflex: heh, it's not so easy to spot the problem without knowing the code and being able to play with it :)
16:35:05 <Saizan> deeflex: the recursion happens only in loop?
16:36:33 <eternal_champ> hi
16:36:52 <eternal_champ> haskell more fun than python/
16:37:16 <eternal_champ> ?
16:37:24 <Botje> totally
16:37:27 <Saizan> definitely.
16:37:49 <ray> is the pope more catholic than richard dawkins?
16:37:54 <eternal_champ> works smp well too
16:38:14 <Botje> eternal_champ: look at the language shootout and you tell us
16:38:29 <pumpkin> ray: probably
16:39:11 <ray> one assumes
16:40:29 <_Jordan_> Is it possible to type-annotate a function I definte in GHCi?
16:40:29 <deeflex> Saizan, yes I understand. Yes that's the only recursion I would say
16:40:35 <_Jordan_> define*
16:41:04 <eternal_champ> http://shootout.alioth.debian.org/gp4/benchmark.php?test=threadring&lang=all looks pretty good
16:41:17 <eternal_champ> wow
16:41:19 <pumpkin> eternal_champ: look at more recent benchmarks
16:41:22 <eternal_champ> so on multi cpu box
16:41:23 <pumpkin> we do even better
16:41:27 <eternal_champ> hasjel can relly be fast
16:41:39 <eternal_champ> pumpkin: got a link?
16:41:39 <pumpkin> eternal_champ: we sort of cheat, by implementing threading ourselves
16:41:44 <eternal_champ> ha!
16:41:49 <pumpkin> http://shootout.alioth.debian.org/u64q/benchmark.php?test=threadring&lang=all
16:41:54 <eternal_champ> hasell threads beast os theads of the linux?
16:41:57 <eternal_champ> hilarious
16:41:59 <pumpkin> definitely
16:42:07 <pumpkin> ghc has green threads
16:42:26 <aavogt> ray: map and . are specialized because otherwise the error messages can start asking newbies for new instances, but maybe that stuff belongs in something like helium, and not haskell
16:42:28 <pumpkin> so does mac os 10.6 :P
16:42:47 <ray> helium is that haskell for newbies thing right? if it is then i agree
16:42:57 <aavogt> yep
16:43:06 <ray> that "possible fix: add an instance" message is usually wrong anyway
16:43:22 <pumpkin> eternal_champ: we really kick ass here: http://shootout.alioth.debian.org/u64/benchmark.php?test=threadring&lang=all
16:43:26 <FliPPeh> I'm actually coding Haskell right now
16:43:26 <FliPPeh> Without too many errors
16:43:26 <FliPPeh> This is new.
16:43:35 <eternal_champ> wow
16:43:39 <pumpkin> eternal_champ: note how it does better without multithreading :P
16:43:42 <eternal_champ> amazing smalltalk is so close
16:43:47 <eternal_champ> without
16:43:50 <eternal_champ> wtf
16:44:08 <eternal_champ> uh
16:44:13 <pumpkin> eternal_champ: it might get a bit better with a more recent ghc though :)
16:44:20 <eternal_champ> so wait what does that mena
16:44:34 <eternal_champ> threads are not as fast?
16:45:02 <pumpkin> it means that the GHC RTS is essentially a mini threaded OS in that regard
16:45:21 <Saizan> deeflex: oh, since you always append you might need to do the same for the other arguments too
16:45:22 <pumpkin> and that it does a good job scheduling on its own terms, but if you introduce synchronization between real threads, it adds more overhead
16:45:41 <pumpkin> eternal_champ: that's why I think that benchmark is a bit silly, but it definitely makes GHC shine :)
16:46:05 <FliPPeh> I have been without sleep for soon to be 48 hours, and I'm not tired AT ALL
16:46:09 <Saizan> deeflex: like let i' = i + 1 in i' `seq` newfi `seq` newdi `seq` newvi `seq` newei `seq` loop newfi newdi newvi newei i'
16:46:10 <FliPPeh> I should go see the doctor
16:46:16 <ray> it means it's time to write our OS in haskell
16:46:31 <Saizan> deeflex: btw, appending is O(n), so doing it repeadetly is very costly
16:46:36 <FliPPeh> ray, port the linux kernel into haskell :)
16:46:44 <ray> now why would i do a thing like that
16:46:50 <deeflex> Saizan, oh really..well I could try that.
16:46:51 <Saizan> deeflex: you might want to prepend and reverse at the end
16:46:53 <ray> i'm not a sadist!
16:47:01 <FliPPeh> Awww
16:47:06 <FliPPeh> *BSD?
16:47:19 <ray> no copying :)
16:47:32 <aavogt> @where house os
16:47:32 <lambdabot> http://programatica.cs.pdx.edu/House/
16:48:14 <deeflex> Saizan, btw this is the algorithm im trying to implement  http://en.wikipedia.org/wiki/Neighbor-joining . Mine is a bit different though, but the lloop steps are the same i believe.
16:48:18 <ray> maybe windows 7 will piss me off and i'll turn my computer into HASKELL MACHINE
16:48:20 <ray> but i bet it won't
16:48:25 <ray> :(
16:49:25 <eternal_champ> yeah
16:49:28 <eternal_champ> haskell machine!
16:49:30 <eternal_champ> awesome!
16:49:48 <eternal_champ> so wow haskell apps can sure utilize multi cpu
16:49:54 <eternal_champ> but fastest was not multi threaded
16:49:55 <pumpkin> yeah, very easily in many cases
16:49:56 <eternal_champ> weird
16:50:07 <pumpkin> well, it'll be faster if the threads actually need to do something
16:50:15 <pumpkin> but in that contrived benchmark, it's faster to be single-threaded
16:50:17 <ray> it's not as concurrency-loving a language as, say, erlang
16:50:24 <eternal_champ> like serving web pages
16:50:26 <eternal_champ> :)
16:50:33 * SubStack wonders if anybody has done anything with house lately
16:50:46 <pumpkin> ray: one day I hope to change that :P
16:50:55 <eternal_champ> hapstack seems promising
16:51:04 <eternal_champ> last time i tried to installhapps i couldn't
16:51:07 <pumpkin> ray: to compete more directly with erlang in that regard
16:51:24 <eternal_champ> is erlang best language now?
16:51:28 <pumpkin> no
16:51:30 <eternal_champ> since it has that concurrentcy stuff
16:51:48 <eternal_champ> haskell allows more 'abstraction'
16:51:49 <eternal_champ> ?
16:52:00 <SubStack> happstack on house with yi and darcs
16:52:01 <pumpkin> definitely :) but I wouldn't say there's a clear best language
16:52:06 <pumpkin> there are clearly bad languages
16:52:10 <ray> c++
16:52:15 <SubStack> c--
16:52:15 <ray> i mean, there sure are
16:52:23 <eternal_champ> house?
16:52:28 <pumpkin> SubStack: GHC uses a variant of that :)
16:52:32 <eternal_champ> whats that besids a bad show for women
16:52:38 <ray> i'm sure house is less abandoned than lainos, and that wasn't even an os
16:53:07 <SubStack> http://programatica.cs.pdx.edu/House/
16:53:37 <ray> i'd like to get house on my olpc laptop somehow, but it's too frustrating
16:53:41 <ray> (the laptop is)
16:53:41 <SubStack> should rewrite haiku in haskell and call it hasku
16:54:08 <shapr> ray: Boot House from a cdrw?
16:54:30 <ray> like i said, complicated
16:54:38 <ray> i didn't say that
16:54:40 <ray> :(
16:55:08 <Nafai> shapr!
16:55:15 <shapr> Nafai!
16:55:24 <Nafai> How are you?
16:55:37 <shapr> I'm ok, how are you?
16:55:40 <u_quark> is there a specific how-to for memorization of functions ?
16:55:54 <u_quark> i remember something with arrays ...?
16:55:57 <Nafai> Good.  11 days until I get a new kidney!
16:58:05 <shapr> Nafai: Good to hear.
16:59:38 <Saizan> u_quark: "memoization", i can't find my preferred link though :\
17:00:35 <u_quark> yes memoization :$
17:00:44 <u_quark> damn you spell checker
17:00:55 <Saizan> http://www.haskell.org/haskellwiki/Memoization#Memoising_CAFS <- something like this
17:02:06 <u_quark> yes Saizan! tnx
17:11:56 <hatds> what would you call 'equality' between things that are mutable?
17:12:09 <hatds> i.e., for things that support a function a -> a -> IO Bool
17:16:27 <aavogt> @type liftM2 (==) `on` readIORef
17:16:29 <lambdabot> Not in scope: `readIORef'
17:16:31 <mmorrow> pumpkin: TH-generated fully unrolled fft's for powers of 2 up to 64: http://moonpatio.com/repos/ffts_upto_64.hs
17:16:40 <pumpkin> mmorrow: I saw, that looks wonderful
17:16:51 <aavogt> @type liftM2 (==) `on` (undefined :: a -> IO a)
17:16:52 <lambdabot> forall a1. (Eq a1) => a1 -> a1 -> IO Bool
17:17:02 <mmorrow> pumpkin: pure-fft take 4.2 seconds on 10,000 size-64 vectors, and that code takes 0.8 seconds :)
17:17:09 <pumpkin> wow, how does fftw compare?
17:17:18 <pumpkin> we have a binding to it already I think
17:17:21 <mmorrow> i'm not sure, haven't tested thatr yet
17:17:33 <mmorrow> but i haven't even started using efficient data reps yet either :)
17:17:35 <pumpkin> nice
17:17:45 <pumpkin> mmorrow: you going to work into making a real library out of this?
17:18:03 <mmorrow> i changed my mind, i think lightning-fast fft's could be /generated/ in haskell
17:18:12 <mmorrow> pumpkin: i think so yes
17:18:12 <pumpkin> I can't think of any fft uses who decide the size of their fft on the fly, so TH-generated FFTs is actually a good idea
17:18:49 <mmorrow> pumpkin: here's the Vector type i think i'm gonna use http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2597
17:19:13 <pumpkin> that's awesome
17:19:20 <mmorrow> pumpkin: i'll stick all the code in a repo shortly so it's accessible
17:19:21 <pumpkin> does GHC start throwing up on bigger ones than that?
17:19:44 <mmorrow> not sure yet, but i bet we could get at least Vec1024's
17:19:56 <pumpkin> someone really needs to work on putting SSE support into the codegen
17:20:01 * pumpkin whistles
17:20:14 <mmorrow> (the nice thing is is that there's no static data sitting around, those Vec types are just used in generated code's pattern matches
17:20:28 <pumpkin> yeah
17:20:49 <mmorrow> compiling http://moonpatio.com/repos/ffts_upto_64.hs  takes about 4 seconds i'd say
17:23:38 <pumpkin> not too bad
17:23:56 <pumpkin> I wonder how big a statically unrolled 1024 fft would be (in terms of code size)
17:25:05 <pumpkin> mmorrow: any idea of how much space your fft 64 funcion uses? compared to fft 32?
17:26:44 <mmorrow> you mean at runtime wrt allocation?
17:26:54 <pumpkin> I mean the generated code size
17:27:04 <mmorrow> oh, asm?
17:27:24 <mmorrow> 67254 ffts_upto_64.s
17:27:28 <mmorrow> [m@monire src]$ wc -l ffts_upto_64.s
17:27:37 <pumpkin> ah, not too bad
17:27:40 <mmorrow> (that's for all of them <64)
17:28:05 <mmorrow> yeah, considering it's the same few hundred lines repeated hundreds of times :)
17:28:35 <mmorrow> (the asm looks pretty good actually, i think it could look really good with those types with everything unpacked into the constructor)
17:29:06 <mmorrow> (e.g., for Vec64, it has 126 Double#s unpacked into its closure)
17:29:22 <mmorrow> so it's essentially an unboxed array that you can pattern match on
17:29:34 <mmorrow> (instead of index into with ints)
17:44:43 <kyevan_> Hmm. Does anyone know if OS X has a quick way to type λ? >_<
17:44:52 <kyevan_> (slightly-offtopic)
17:45:59 <mriou> what would be the easiest to convert an Integer to a string (byte by byte -> char)?
17:46:04 <Striki> +OK OfRzI0ip62G.YBuDA.ZkGn/0v9k8Y/JQZS70M9n0C1wRxmx/W24n1/45pu2.SGJjw.C2e2q/6lRVG/9mzpq.AyBWj.F6h700YI/8V0rZOmT0
17:46:09 <Striki> +OK SGsS/.Pkanp/
17:46:17 <bd_> Striki: what?
17:46:35 <Striki> +OK RlX9Q/sYORE1kYWPq1ige/B0tq.eJ1T6s8U1Hyjpz1DCFBd.DdiRc/Md3Da0
17:46:36 <dino-> > show 42
17:46:37 <lambdabot>   "42"
17:46:40 <dino-> mriou: ^
17:47:04 <mriou> dino I'm looking for byte by byte conversion
17:47:22 <mriou> like 80 would be 'P'
17:47:22 <dino-> mriou: If you want something fancier, I tend to go with printf. Say, leading zeroes, etc..
17:47:53 <dino-> > Data.Char.ord 'P'
17:47:54 <lambdabot>   80
17:48:25 <mriou> dino yep but then I'm missing how to slice an integer into its successive bytes
17:48:45 <mriou> like 2018155139523098493
17:49:04 <bd_> mriou: data.bits is one option. There's probably a more efficient way.
17:50:11 <mriou> bd_ yeah I couldn't find better which is why I was asking
17:50:22 <mriou> but I guess I'll have to do that
17:50:41 <bd_> data.binary might work. Or you could try decomposing the GHC.Num.J# constructor in the implementation.
17:51:35 <pumpkin> bd_: I wouldn't do it that way
17:51:56 <pumpkin> mriou: so you want a base-2^8 representation of the integer?
17:52:20 <mriou> pumpkin: yep
17:53:15 <pumpkin> mriou: might be best to just use an unfoldr'd divMod or quotRem for now, using the J# constructor would be really easy (if you don't mind ByteArray# reading) but it's likely to change soon
17:53:28 <mriou> I was hoping something like: splitInteger:: Integer -> Word8
17:53:35 <pumpkin> [Word8] ?
17:53:43 <mriou> huh yeah
17:55:05 <mriou> didn't know about divMod, that might make it slightly better
17:58:13 <shapr> What did Striki say?
18:04:00 <shapr> I'm trying to cabal install bamboo, but I get "base-4.0.0.0 was excluded because of the top level dependency base -any"
18:04:41 <dcoutts> shapr: it's not printing all the info
18:05:11 <dcoutts> shapr: what it doesn't say about the dependency "base -any" is that it's a restriction on it being installed
18:05:29 <dcoutts> ie, it must pick an installed version of base, not one that's available from hackage
18:05:51 <dcoutts> shapr: and you're presumably using ghc-6.8.x which has base 3 and not 4, but you're trying to install a package that uses base 4
18:05:58 <shapr> dcoutts: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5673#a5673 ?
18:06:12 <dcoutts> shapr: cabal can see that there's base 4 on hackage, but it's trying to pick an installed one
18:06:16 <dcoutts> hence the conflict
18:06:25 <shapr> huh
18:06:35 <skorpan> yeah, huh?
18:06:53 <skorpan> geez, bamboo had a *lot* of dependencies..
18:07:00 <shapr> dcoutts: thanks
18:07:09 <dcoutts> shapr: did that make ant sense?
18:07:16 <Eiler> does haskell have anything (package) that can evaluate haskell code at runtime.. besides hs-plugins?
18:07:17 <shapr> Yes, actually it did.
18:08:03 <gwern> Eiler: ghc api. the best maintained wrapper over it is probably hint
18:09:29 <Eiler> cool
18:12:14 <Eiler> got another question also. I want to make a program that works like: write a couple of functions, let the user write in functionnames in console where they should be called and print out the value. Say we got factorial:: Integer -> Integer, the user should be able to write: factorial 5, and the program should print out 120. Would this be hard to do?
18:13:08 <shapr> dcoutts: That's exactly it, it seems I installed and built cabal et al for 6.8.2
18:13:13 <shapr> foozle
18:14:08 <Cale> Eiler: It's not entirely trivial if you want to evaluate arbitrary Haskell expressions, but it's also not too hard.
18:14:24 <Cale> Eiler: Have a look at the documentation for hint on Hackage.
18:14:42 <rwanderley> hi, I want to try out web programming in haskell.  I saw 2 alternatives, happstack and cgi.  Do you guys recommend any of this two?
18:15:04 <pumpkin> does anyone remember a book that isn't TAPL called something like "type systems for functional languages?"
18:15:16 <pumpkin> someone mentioned it in here a few days ago but I can't find it in the logs
18:15:31 <Eiler> Cale: yeah, looking at the hint documentation now
18:16:00 <Eiler> Cale: well it dont really have to evaluate whole expression, just a functioncall at a time
18:17:27 <Cale> Eiler: Well, if you want to do something more static, you might write a parser for the syntax of the input, and have something like a table of possibilities.
18:18:21 <Eiler> eww the haskell logo has changed
18:18:52 <pumpkin> lol, the one before was eww-worthy
18:19:43 <Eiler> Cale: ye well the syntax should just be: functionname arg1 arg2 ...
18:20:19 <Saizan> if you've a DAG, how'd you find all the possible paths excluding those that are subpaths of others?
18:22:46 <QtPlaty[HireMe]> Saizan: I would take it in to steps.
18:22:51 <Cale> Saizan: Start by picking a vertex with no incoming arcs, then find all the maximal paths which start there and.
18:22:53 <Cale> er
18:23:03 <Cale> and end when there are no outgoing arcs
18:23:15 <QtPlaty[HireMe]> I would find all possable paths and then eleminate the subpaths.
18:24:25 <Cale> QtPlaty[HireMe]: You know that all the maximal paths start at a vertex with no incoming arcs though, since if there was an incoming arc, you could add the vertex it came from to your path.
18:24:43 <Cale> (and it certainly isn't already in your path, because that would lead to a cycle)
18:24:47 <QtPlaty[HireMe]> Cale: True so you can eleminate that step.
18:26:03 <Saizan> if you've many sources the maximal paths will probably share many subpaths too, maybe this can be done with some dynamic programming approach, starting from the sinks
18:26:10 <Cale> and a maximal path can't end at a vertex which has an outgoing arc, since if it does, then you could add the vertex which that arc leads to and extend your path (and again, it can't already be in your path, since the graph is acyclic)
18:26:22 <Saizan> where source = no incoming arc, sink = no outgoing arc
18:28:06 <Cale> Well, hmm...
18:28:25 <Cale> If you know that your DAG has some special structure, then you can perhaps make use of that.
18:28:57 <Cale> Like, if you know that every path goes through one particular vertex, you can split up the problem through that vertex and take a Cartesian product.
18:29:41 <Cale> But I'm not sure how much that really helps
18:30:08 <Saizan> actually, it's not really a DAG, i've something like uncurried functions returning many results, so they connect N vertexes to M others at once
18:34:58 <shapr> C# makes me feel pretty stupid. Haskell makes me feel smart.
18:35:35 <SamB> C# makes me feel like
18:35:42 <SamB> ... like I need a bigger hard drive
18:35:47 <shapr> At least part of that is that there's a whole lot of stupid pre-baked into the Microsoft stuff. Sometimes when I just can't solve the problem, I later discover it's because the library I got from Microsoft is broken.
18:36:23 <SamB> of course, lots of things do that these days ;-)
18:36:58 <shapr> SamB: Yeah, Windows XP seizes and dies every week at least. I've had two Linux kernel panics since 1999, and one of them was because I was hot swapping IDE drives (Linux, and motherboards, don't support that).
18:38:12 <shapr> I like Haskell :-)
18:39:04 <SamB> hmm, I've been getting a lot of kernel panics lately, but most of them from bad boot options when trying to boot qemu ;-)
18:52:25 <TomMD> I have lots of panics about kernels too... "!@#$!  Did I just delete the only kernel I've gotten to work on this hardware?"
18:54:07 <dino-> TomMD: heh. I include /boot in the nightly backups
18:55:41 <TomMD> dino-: You've probably heard that some people keep a repository (e.g. darcs or git) of their critical directories.
18:55:46 <dino-> SamB, shapr: Any chance of working in F# at these jobs? Would that even make a difference?
18:56:52 <dino-> TomMD: Yes, I have heard that. Source control: It's not just for breakfast or source anymore.
18:57:54 <dino-> I say that being nearly completely ignorant of F# other than something about it being MLish
18:59:00 <A1kmm> Has anyone else been having problems with programs using the parallel GC crashing with ghc HEAD (for some programs)?
19:11:34 <SamB> dino-: I never said I'd actually written anything in C#
19:16:56 <pumpkin> QtPlaty[HireMe]: have you thought of putting [ForHire] instead of [HireMe] ?
19:17:06 <pumpkin> imperatives may scare people
19:17:49 <dino-> pumpkin[YouKnowYouWantMe]
19:18:20 <dino-> @src ($!)
19:18:21 <lambdabot> f $! x = x `seq` f x
19:19:22 <pumpkin> :)
19:19:42 <pumpkin> pumpkin[poorSoGiveHimLotsOfMoneyWithoutAskingForAnythingInReturn]
19:20:18 <ray> ray[Bum]
19:21:13 <dino-> So wait, when do you use seq? The evaluating first argument and discarding is confusing me.
19:21:14 <A1kmm> Andrew[SighItOnlyCrashesWhenYouDontUse-debug]
19:21:33 <ray> it evaluates whatever x is
19:21:41 <ray> so when you use x somewhere else, it's evaluated
19:21:42 <pumpkin> A1kmm: and I suppose running it in gdb doesn't give much useful information?
19:21:51 <pumpkin> A1kmm: or does it crash in the RTS?
19:22:04 <A1kmm> I haven't managed to get it to crash in debug mode.
19:22:13 <pumpkin> I mean using the non-debug RTS
19:22:21 <A1kmm> and the stack-trace is different every time otherwise. I suspect some sort of race condition.
19:22:27 <pumpkin> ah :/
19:22:43 <A1kmm> It also only happens only when parallel GC is turned on.
19:22:56 <ray> f x would normally start evaluating f, and only evaluate x when it needs to, if ever
19:23:16 <ray> x `seq` f x evaluates x beforehand
19:23:49 <ray> remember all that referential transparency junk, x is always the same x
19:23:51 <dino-> Ok, but what about x `seq` y  (where y has nothing to do with x)?
19:24:05 <ray> basically, that's bottom if x is bottom, else it's y
19:24:38 <A1kmm> pumpkin: Actually without debug the result is sometimes reasonable: #0  0x000000000067262c in schedule (initialCapability=<value optimized out>, task=0x994370) at rts/Schedule.c:672
19:25:02 <pumpkin> but it isn't always there?
19:25:28 <A1kmm> 672         return (waiting_for_gc ||
19:25:30 <A1kmm> 673                 cap->returning_tasks_hd != NULL ||
19:25:37 <A1kmm> (gdb) print cap
19:25:39 <A1kmm> $2 = (Capability *) 0x0
19:25:43 <pumpkin> what kind of a crash?
19:25:43 <pumpkin> oh
19:25:46 <A1kmm> It seems to be consistent with this version of ghc.
19:25:47 <pumpkin> so segfault?
19:25:53 <dino-> ray: Thank you
19:25:56 <A1kmm> Yeah, null deref it looks like.
19:26:05 <pumpkin> so task isn't null, but cap is?
19:26:25 <pumpkin> cause both seem to get dereferenced
19:26:51 <pumpkin> A1kmm: how big is your failure case? can you reduce it enough to make it happen in a few lines maybe?
19:27:51 <pumpkin> A1kmm: also, you said it doesn't happen in the debug RTS, but the function you point at is only present in the threaded RTS, so maybe you need a threaded debug RTS?
19:27:59 <A1kmm> I tried earlier without success, but it looks different with the current HEAD vs one a few weeks ago, so maybe I should try a simple program. Although I earlier tried to work out which part of my Haskell code triggered it without much sucess.
19:28:23 <A1kmm> pumpkin: Well, the debug RTS was using 800% CPU at one point, so I'm pretty sure it is threaded.
19:28:37 <pumpkin> lol
19:28:55 <pumpkin> how many capabilities did you give it? I found that if I gave mine too many it would max out my CPU and do almost nothing
19:28:56 <A1kmm> Where 800% CPU means 100% of 8 CPUs (there are 24 in that system).
19:29:03 <pumpkin> ah, wow
19:29:54 <A1kmm> and it is computing a 10,000 element long list using computeAllMIs madata x = map (processMI madata) x `using` parListChunk 500 rnf
19:31:37 <idnar> man, wikipedia
19:31:40 <idnar> "One well-known (and perhaps the simplest) fixed point combinator in the untyped lambda calculus is called the Y combinator. It was discovered by Haskell B. Curry"
19:31:48 <pumpkin> lol
19:31:56 <idnar> that makes it sound like he was out for an afternoon stroll in the woods, and tripped over the Y combinator
19:32:11 <SamB> idnar: sure! it almost ate him
19:32:18 <SamB> @go alligator eggs
19:32:24 <lambdabot> http://worrydream.com/AlligatorEggs/
19:32:24 <lambdabot> Title: Alligator Eggs!
19:32:26 <pumpkin> he found the y combinator in someone's botom
19:32:51 <aavogt> Is Y the same as fix?
19:34:04 <SamB> no, Y isn't allowed in Haskell
19:36:02 <aavogt> SamB: so the wikipedia article is wrong?
19:36:24 <aavogt> @type fix f = f (fix f)
19:36:26 <lambdabot> parse error on input `='
19:36:29 <pumpkin> it's the same idea, and you can also encode it with a Mu type can't you?
19:36:34 <aavogt> @type let fix f = f (fix f) in fix
19:36:36 <lambdabot> forall t. (t -> t) -> t
19:36:53 <pumpkin> aavogt: that'll overflow quickly
19:37:35 <aavogt> @src fix
19:37:35 <lambdabot> fix f = let x = f x in x
19:38:33 <pumpkin> @src cycle
19:38:34 <lambdabot> cycle [] = undefined
19:38:34 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
19:39:36 <TheColonial> how do you get lambdabot to show you the source of, say, an instance of Applicative ?
19:39:48 <SamB> TheColonial: you can't
19:39:57 <TheColonial> SamB: thanks :)
19:39:57 <pumpkin> @src [] (<*>)
19:39:58 <lambdabot> (<*>) = ap
19:39:59 <SamB> the list is more-or-less hard-coded
19:40:07 <pumpkin> but yeah, a few of them are hardcoded in
19:40:26 <pumpkin> @src [] pure
19:40:27 <lambdabot> pure = return
19:40:50 <pumpkin> they don't always match the real implementations though
19:41:06 <pumpkin> sort is an example of that
19:41:18 <pumpkin> mmorrow: still around?
19:41:20 <TheColonial> pumpkin: cool thanks :)
19:41:53 <JusticeFries> lambdabot functions as an interpreter?
19:41:59 <pumpkin> > text "yes I do"
19:42:01 <lambdabot>   yes I do
19:42:13 <JusticeFries> that's awesome.
19:42:15 <aavogt> @type text
19:42:17 <lambdabot> String -> Doc
19:42:23 <aavogt> @index text
19:42:23 <lambdabot> Graphics.HGL.Draw.Text, Graphics.HGL.Draw, Graphics.HGL.Core, Graphics.HGL, Graphics.SOE, Language.Haskell.TH.PprLib, Text.Html, Text.PrettyPrint.HughesPJ, Text.PrettyPrint
19:43:44 <ray> fix is the "real" Y, not that stupid abnormal-order Y people love so much :)
19:56:40 <mmorrow> pumpkin: http://moonpatio.com/repos/hsfft/
19:56:51 <pumpkin> mmorrow: awesome :)
19:56:56 <pumpkin> mmorrow: know much about bytecode in ghci?
19:57:13 <pumpkin> lol: http://moonpatio.com/repos/hsfft/README
19:57:24 <mmorrow> pumpkin: just redid the the generation
19:57:28 <mmorrow> pumpkin: heh
19:57:56 <mmorrow> pumpkin: literally created that repo 30 seconds ago :)
19:58:17 <mmorrow> pumpkin: so compiling <=128 take about 16 seconds on my machine
19:58:25 <pumpkin> ah, not too bad
19:58:32 <mmorrow> and i ^C'ed out of 256<= after 40+ seconds
19:58:40 <pumpkin> lol
19:58:45 <mmorrow> :(
19:59:03 <pumpkin> it's compile time code generation, I wouldn't expect it to be fast
19:59:10 <ray> i need a new computer :(
19:59:19 <pumpkin> although maybe not that slow?
19:59:20 <pumpkin> not sure
19:59:20 <mmorrow> (also one nice thing is that for bigger vectors, you can just merge the results of ffts of smaller unrolled vectors recorsively)
19:59:41 <ray> the worst part of needing a new computer is that i actually have one in the mail
19:59:44 <pumpkin> yeah, and then you start running into the fact that ghc doesn't like large chunks of code
19:59:47 <mmorrow> pumpkin: oh, i'm writing the generated code to a file first
19:59:52 <pumpkin> ah I see
20:00:07 <mmorrow> <=512 is 65,000 lines :/
20:00:10 <ray> an agonizing two days of being so close to compiling things
20:00:14 <pumpkin> ack
20:00:42 <mmorrow> so i guess now it's time to add controllable-with-parameters unrolling
20:01:13 <mmorrow> oh, and also the get it using that Vec type or something better than lists..
20:01:36 <pumpkin> is it already all strict?
20:03:17 <mmorrow> pumpkin: for the most part, but there's the pointers in the lists to Complex's, which have pointers to two Doubles..
20:03:25 <pumpkin> ah
20:03:32 <bnijk> ok somebody explain to me the beauty of STMs
20:03:41 <mmorrow> so that Vec is aimed at getting rid of that
20:03:45 <pumpkin> ah
20:03:55 <pumpkin> bnijk: plural?
20:03:59 <bnijk> STM
20:04:00 <pumpkin> software transactional memory?
20:04:01 <pumpkin> ah
20:04:09 <mmorrow> i looked with vacuum, a Vec64 has literally 128 machine Doubles sitting in its closure
20:04:21 <pumpkin> nice
20:04:23 <pumpkin> :P
20:04:40 <pumpkin> bnijk: composability is the main thing that gets people excited, I think
20:04:53 <bnijk>  composability?
20:05:03 <jmcarthur> bnijk: you can compose smaller transactions into bigger transactions without risking deadlock
20:05:13 <mmorrow> the really nice thing about Vec too is that you can bind every single elem to a var in a single pattern match, and let ghc's code-gen compute the most optimal asm code to move it around
20:05:22 <pumpkin> bnijk: with standard sync constructs, you need to be aware of the order in which various components acquire locks, or you rick deadlock
20:05:26 <bnijk> you mean multiple smaller ones into one big one?
20:05:30 <pumpkin> you can't treat things as black boxes
20:05:46 <pumpkin> mmorrow: yeah
20:05:49 <mmorrow> rather than have to index into the vec length(vec) times to get at everything, and do this indexing at the haskell-level
20:06:06 <pumpkin> sounds cool
20:06:19 <bnijk> acquire locks on the same portion of state you mean, right
20:06:20 <bnijk> ?
20:06:24 <mmorrow> this is why i think that it's gonna be really fast
20:07:01 <bnijk> multithreading scares me a little
20:07:09 <bnijk> i am trying to overcome that fear!
20:07:37 * pumpkin tests an enormous unpacked closure
20:07:52 <pumpkin> bnijk: yeah, sort of
20:08:07 <dino-> I thought SPJ's chapter in _Beautiful Code_ on STM was useful in explaining the problem with conventional threading models.
20:08:20 <dino-> There was a draft of the chapter in PDF: http://www.google.com/url?sa=t&source=web&ct=res&cd=8&url=http%3A%2F%2Fwww.ece.iastate.edu%2F~pjscott%2Fbeautiful.pdf&ei=TNEtSr3-JIeytweG0vmJDA&rct=j&q=beautiful+concurrency&usg=AFQjCNGbHWwws-LjWnbb7aG042dpwm6trQ
20:08:27 <dino-> ugh, what a URL
20:08:35 <bnijk> dickensurl.com
20:08:58 <bnijk> http://dickensurl.com/b511/Liberty_equality_fraternity_or_death_the_last_much_the_easiest_to_bestow_O_Guillotine
20:10:30 <pumpkin> mmorrow: wow, ghc slows down so much when you have big code
20:10:38 <pumpkin> mmorrow: I'm starting to think it's quadratic in the size of your code or something
20:11:02 <mmorrow> pumpkin: yeah, i wonder what the main reason is?
20:11:06 <pumpkin> my 1024 unboxed doubles data with a one-line main function is using 700 MB
20:11:09 <wli> Pump out some charts and graphs? Regression?
20:11:39 <mmorrow> wli: good idea
20:11:46 <bnijk> when does the type of a function not have to be explicitly clarified
20:11:58 <bnijk> and don't say "when the compiler can infer it"
20:12:14 <pumpkin> wow, this is ridiculous
20:12:18 <dino-> bnijk: The chapter was called "Beautiful Concurrency" if that URL is a problem
20:12:22 <pumpkin> over a gig of RAM now
20:12:26 <pumpkin> the file has 1027 lines
20:12:27 <bnijk> oh that was for me :O
20:12:28 <mmorrow> :(
20:13:02 * wli is not entirely sure how to do rational regression, but I'd try rational functions of degree type (3, 2) (i.e. a cubic polynomial in the numerator and a quadratic polynomial in the denominator) if such turns out to be feasible.
20:13:56 <pumpkin> why would you expect it to be a rational function?
20:14:26 <pumpkin> alright, I guess no 1024-unboxed double data for me
20:14:39 <pumpkin> oh, it finally got around to linking
20:14:44 <aavogt> bnijk: see the MonomorphismRestriction, and also defaulting in haskell '98
20:14:55 <wli> Mostly it's that rational functions are "highly expressive" as opposed to thinking it's a rational function a priori. If there were some a priori expectation of the form of the curve then I'd use that.
20:15:03 <pumpkin> ah
20:15:09 <aavogt> for when you might have to put annotations
20:15:18 <aavogt> @where onlinereport
20:15:18 <lambdabot> I know nothing about onlinereport.
20:15:25 <aavogt> @where report
20:15:26 <lambdabot> http://www.haskell.org/onlinereport/
20:15:38 <pumpkin> mmorrow: finally finished after using 1.1 gigs of RAM and several minutes :)
20:16:12 <aavogt> bnijk: but most of the time, you don't have to annotate any types
20:16:44 <bnijk> why aren't cpus getting faster
20:17:06 <bnijk> and when did 90% of programming become religion
20:17:15 <pumpkin> bnijk: it's cheaper to make many lower-power cores than to make one superfast one
20:17:19 <wli> Bandwidth in terms of instruction-level parallelism vs. latency.
20:17:32 <pumpkin> bnijk: depends what community you ask, about the second questions
20:17:35 <pumpkin> -s
20:17:59 <wli> There's also, of course, actual parallelism going on.
20:18:07 <bnijk> well, which community is right
20:18:20 <pumpkin> bnijk: generally the really evangelical ones I'd say are wrong
20:18:21 <bnijk> it's haskell right ;)
20:18:40 <pumpkin> bnijk: I don't think there's a single best language, but many of us are working to make haskell better :)
20:19:20 <lament> pumpkin: what about Javascript?
20:19:30 <pumpkin> bnijk: I think you'll find that most people in #haskell are not particularly religious about the language, and tend to be programming language enthusiasts (admiring qualities of many different languages)
20:19:48 <bnijk> do you guys know brainfuck
20:19:51 <pumpkin> yeah :)
20:19:55 <bnijk> of course
20:19:58 <pumpkin> I wrote a few things in it
20:20:05 <pumpkin> for a class project a while back
20:20:12 <gwern> we can probably formalize the no-single-best-language idea, too. I'm sure some combination of rice's theorem or no free lunch theorems would do it. or better yet, some compression theorem - there's no language which optimally encodes all possible programs we might want to write
20:20:33 <pumpkin> lament: I don't think it's a bad language
20:20:35 <bnijk> yeah gwern
20:20:58 <pumpkin> lament: I think c++ for example is an ugly language, as is LaTeX, but they both have a purpose if suitably constrained
20:21:09 <pumpkin> :P
20:21:12 <bnijk> what is c++ suitable for
20:21:14 <gwern> since compressing all possible programs would violate the pigeonhole principle
20:21:19 <bnijk> i think i'd take c or java over it
20:21:20 <gwern> bnijk: working with c++...
20:21:29 <bnijk> that's sort of
20:21:31 <bnijk> tautological
20:21:41 <gwern> bnijk: not really
20:21:44 <pumpkin> bnijk: in c you often end up reimplementing a lot of c++'s basic object system for larger programs
20:21:52 <pumpkin> bnijk: might as well use c++, and avoid all the ugly stuff :)
20:22:01 <gwern> what I know of tex is pretty ugly to write in, but on the other hand, it renders pretty nice stuff
20:22:05 <pumpkin> exactly
20:22:14 <bnijk> isn't that what they say about lisp
20:22:23 <bnijk> most c programs contain half of a lisp implementation
20:22:27 <inimino> gwern: I'm not sure optimal compression is the ideal programming language quality metric...
20:22:43 <inimino> greenspun
20:22:43 <pumpkin> that'd give you an awfully CISCish language :P
20:23:40 <ray> most lisp programs contain half of a c++ implementation
20:23:51 <ray> and that's not a compliment to either language :)
20:24:11 <bnijk> i like the higher order stuff in haskell the most
20:24:15 <bnijk> from what i know
20:24:27 <bnijk> saves time
20:24:40 <ray> most haskell programs contain half of an implementation of themselves, and the other half too
20:24:54 <lament> inimino: it probably is, though
20:25:08 <gwern> inimino: nah, I think it's fine. a language should make all the programs we want to write short, at the expense of making all the programs we don't want to write either impossible or lengthy.
20:26:09 <Berengal> gwern: They're not exactly direct opposites
20:26:12 <bnijk> isn't the namespace of functions in haskell really equivalent to the namespace of programs for an OS
20:26:15 <gwern> ideally, a language would have all the programs we want to write be single identifiers :) 'oh you want to do a counting sort on stdin? that's just 538221'
20:26:51 <ray> godel
20:26:54 <jmcarthur> gwern: well, not really. with such a large number of identifiers, surely they must be indexed in some logical way so you can find them
20:27:01 <jmcarthur> which implies that you're just programming :P
20:27:01 <inimino> lament: it could be, but it's by no means a given :)
20:27:01 <gwern> then we could focus our efforts on deciding which program does what we really want - we'd discuss 'sufficiently smart hoogles'
20:27:12 <hatds> it feels like if read/write operations on mutable structures were separated you wouldn't have to worry so much about the order of effects
20:27:19 <bnijk> isn't programming just another level deeper into telling a computer what to do ;)
20:27:24 <lament> abstraction is exactly making a program shorter by taking advantage of patterns in it -- i.e. compression
20:27:25 <gwern> 'with a sufficiently smart hoogle, we could construct a decision tree to narrow down which ones we want'
20:27:27 <hatds> anyone else ever have that idea?
20:27:34 <jmcarthur> bnijk: most haskellers might disagree with that ;)
20:27:42 <bnijk> how so
20:28:17 <pumpkin> we tend to think of haskell as being rather divorced from the underlying computing model
20:28:32 <gwern> bnijk: well, you can write logical proofs in coq or something, and then the coq can compile it into haskell, which can be compild into machine code. I don't see how on earh a logic proof is 'telling a computer what to do'
20:28:36 <lament> bnijk: programming has nothing to do with a computer
20:28:53 * bnijk frowns
20:29:17 <gwern> bnijk: you'll like the djikstra quote 'computer science has as much to do with computers as astronomy with telescopes'
20:29:25 <lament> bnijk: you have a problem and you describe the solution formally. The side benefit of having described it formally is that a computer can now run it.
20:29:41 <bnijk> is that not an instruction
20:30:14 <gwern> look at a prolog program. it describes the properties of a satisfactory solution, but nothing whatsoever about how one could take the constraints and satisfy them
20:30:36 <lament> everything is an instruction if you want to look at the world that way.
20:30:49 <lament> but that's not the preferred way when dealing with Haskell.
20:31:46 <bnijk> what is it then
20:31:55 <bnijk> putting everything into a mathematical function
20:32:01 <bnijk> doesn't that still constitute an instruction
20:32:23 <bnijk> that's how it's interpreted, that's how you conceive of it if you consider its speed and its actual actions as a program
20:32:27 <inimino> everything in IO is an instruction
20:32:29 <inimino> you can't run a program without telling the computer to run it
20:32:41 <bnijk> yes
20:33:07 <lament> bnijk: sure, all programs are instructions for the computer to do something
20:33:17 <lament> bnijk: but that's not the only possible way of looking at programs
20:33:31 * gwern thinks bnijk is not arguing here but expounding dogmatic definitions here
20:33:34 <jmcarthur> "declarative" can be a vague word, sometimes
20:33:54 <lament> as a rule of thumb, if it's hard to debug, it's declarative :)
20:34:02 <jmcarthur> perhaps because it is more superficial than we stuck-up Haskell programmers care to think, perhaps not
20:34:19 <jmcarthur> regardless, it is at least beneficial to trick yourself into believing it is different, as it does change you style a bit
20:34:24 <jmcarthur> *your
20:35:09 <sclv> hmmm... does jgoerzen ever hang out on irc?
20:35:11 <jmcarthur> lament: hard to debug? that crazy talk. truly declarative programs have no bugs!
20:35:23 * sclv thinks no
20:35:26 <gwern> sclv: sometimes, as cosmic_mercury or something like that
20:35:58 <lament> bnijk: as an extremely declarative example, consider a program where you design and work with an electric circuit.
20:36:03 * jmcarthur goes elsewhere on the internet to spread disinformation
20:36:12 <lament> bnijk: ultimately you use this circuit to use some problem you have
20:36:33 <sclv> i mildly want to bug him about hdbc-odbc and safe vs. unsafe foreign calls, but only mildly at the moment.
20:36:55 <lament> bnijk: of course, in some sense, the circuit you design is converted into intsructions to the computer to do stuff, but that's certainl an odd way of looking at it. You're working with the circuit, not with the computer.
20:37:48 <bnijk> i'm telling the computer how to work with the circuit
20:37:56 <inimino> lament: but would you call a circuit a program?
20:38:01 <inimino> I'd call that a model
20:38:06 <hatds> if that's the case then I'll take that computer off your hands that you don't need
20:38:33 <sclv> programs can be evaluated by people as well as computers
20:39:03 <jmcarthur> inimino: i'd say that could be a difference between imperative and declarative styles. i would be more inclined to call a declarative concept a model than a set of instructions
20:39:16 <lament> bnijk: no, whoever wrote the circuit designer program did that
20:39:21 <lament> bnijk: you just build the circuit
20:39:36 <bnijk> that would be a model
20:39:36 <bnijk> then
20:40:01 <lament> for you it's much more natural to think of the circuit as a circuit as opposed to an extremely high-level language that somehow gets converted to machine code
20:40:03 <jmcarthur> bnijk: do you mean "as opposed to a program"?
20:40:08 <bnijk> yes
20:40:10 <sclv> oblig xkcd link (sorry haters): http://xkcd.com/505/
20:40:25 <bnijk> i do hate xkcd
20:40:30 <jmcarthur> bnijk: consider a DSL for describing circuits then, embedded in a language like haskell
20:40:34 <bnijk> man
20:40:35 <jmcarthur> is it still not programming?
20:40:41 <lament> bnijk: now s/circuit/haskell program, s/circuit designer/GHC, and consider the implications
20:40:52 <BMeph_> preflex: seen CosmicRay
20:40:52 <preflex>  CosmicRay was last seen on #haskell 4 days, 6 hours, 49 minutes and 9 seconds ago, saying: mauke: another reason 6.10.3 sucks?  sigh
20:41:13 <bnijk> does describing circuit designers?
20:41:21 <bnijk> uhhh
20:41:23 <bnijk> oops
20:41:50 <bnijk> are we talking about what you build in the circuit modelling program
20:41:53 <bnijk> or the program itself
20:42:19 <lament> what you build in it
20:42:21 <lament> the circuit
20:42:33 <lament> that's your declarative program
20:42:44 <jmcarthur> bnijk: take a look at this syntax, which is eerily similar to circuits http://www.haskell.org/arrows/syntax.html
20:42:58 <jmcarthur> you can actually write real programs with circuits
20:43:02 <inimino> XKCD rocks :D
20:43:47 <jmcarthur> that syntax only makes it more apparent, but you actually can approach a LOT of programming domains in a similar way
20:43:49 <Hunner> The previous one was much cooler imho
20:45:06 * sclv idly notices that haskell-beginners often has quite deep discussions while -cafe still gets lots of beginner questions...
20:45:32 <lament> compare with kernelnewbies :)
20:45:49 <jmcarthur> i think we shouldn't have #haskell-beginners. beginners don't know to go there, or when their questions are advanced enough to take into #haskell
20:45:51 <sclv> lament: same thing happens there?
20:46:05 <lament> sclv: kernelnewbies is/was a community of mostly kernel wizards
20:46:31 <sclv> i think we just need to push haskell-beginners more in the main haskell pages
20:46:33 <jmcarthur> #haskell-in-depth is probably a bad idea as well, in my opinion :\
20:46:48 <lament> does any discussion ever happen in #haskell-in-depth?
20:46:53 <jmcarthur> very occasionally
20:46:57 <jmcarthur> i don't go any more
20:47:29 <sclv> haskell-in-depth is pretty good on when you want some discussion on subtleties of the threaded runtime or some funny typechecker you're working on not to get drowned in noise.
20:47:59 <byorgey_> what, there's a #haskell-beginners channel?
20:48:08 <sclv> it would be really nice if more of the -cafe questions that belonged on the beginners list actually made it there.
20:49:08 <byorgey> oh, no, there isn't, false alarm =)
20:49:27 <byorgey> win move up
20:49:35 <byorgey> whoops
20:52:03 <bnijk> wow http://www.panda3d.org/showss.php?shot=ssg-flight/flight06
20:52:11 <bnijk> those are among the best graphics i've ever seen
20:54:02 <idnar> byorgey: lose move down!
20:54:36 <byorgey> idnar: you've got the idea!
21:01:36 * sclv is disappointed that the Alloy paper didn't benchmark against compos
21:02:51 <sclv> compos is a limited approach, i'll grant, but its so insanely simple compared to almost anything else.
21:14:07 <eck> i have a style/stm question: does this look correct and idiomatic, or is there a preferred way of doing this? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5675
21:17:06 <TomMD> eck: The only exceptions I know of that are thrown from STM contexts are rather serious and don't mean you should redo your action.
21:17:27 <eck> i have an orElse that fails in joinStm
21:18:07 <eck> joinStm ct m x n = do joinAction `orElse` (fail "") where joinAction = ...
21:18:10 <TomMD> orElse should just result in an STM retry, not an exception.
21:18:20 <TomMD> oh, fail... that is a different story
21:18:20 <eck> ok
21:18:22 <TomMD> why fail?
21:18:40 <eck> i'm trying to figure out how to signal that i need i/o to be done (to get the current time)
21:18:45 <TomMD> you can 'retry'... unless you are worried about retrying so often that the time grows stale.
21:19:07 <TomMD> I handled this once before... let me look at some old code (which might not be handled intelligently)
21:19:12 <eck> cool
21:21:42 <TomMD> eck: sorry, a design change looks to have eliminated the issue a while ago (I had this issue in control-event).
21:22:08 <sjanssen> TomMD: I though fail "" == retry in STM?
21:22:27 <TomMD> Does it?  That makes the catch all the less worth while in my eyes.
21:22:56 <eck> my code is untested :-/
21:22:57 <sjanssen> TomMD: ah, it does seem to throw an exception
21:22:58 <TomMD> I just use 'retry' and generally try to forget 'fail' exists except for when I'm using ErrorT or the like.
21:23:02 <eck> just wondering what the correct way to do this is
21:23:09 <sjanssen> I think I'd prefer fail to be retry, though
21:23:30 <sjanssen> eg. do Just x <- readTVar v -- be nice if this retried when it got Nothing
21:23:46 <TomMD> eck: Unless you have some sort of high assurance concern with this clock time I'd just trust the atomic action will happen reasonably quickly and eliminate the catch and handler/
21:24:11 <eck> ok
21:25:00 <eck> just thought of another thing i could do... i could spawn a thread that updates a TVar with the current time every second (which is really the granularity i'm concerned with), and then read from that TVar in the STM action
21:25:53 <eck> that also makes the stm function composable
21:27:44 <TomMD> You could - that is exactly what control-engine does!
21:27:58 <TomMD> Well, actually that is what haskell-DHT does, which uses control-engine.
21:28:27 <TomMD> It works well for me, but Control-Engine has very low contention for the TVar
21:42:38 <Habitue> Hey can anyone help me with an issue with digitToInt?
21:43:02 <pumpkin> we don't know until you ask the question :)
21:43:57 <Habitue> ok, I have a line like: putStrLn $ show $ toEnum (digitToInt selNum - 1) :: SomeEnumType
21:44:36 <Habitue> and I'd like to avoid a ton of exception catching if selnum isn't a char from 0 - 9
21:44:59 <jimmyjazz14> what type can I use to store list of different types like an array (or a vector in C++)
21:45:01 <Habitue> are there versions of toEnum and digitToInt that return Maybe's instead?
21:45:07 <pumpkin> filter out anything outside of 0-9 beforehand?
21:45:52 <Habitue> that's simple enough, I'll try that
21:45:56 <Habitue> thanks :)
21:46:24 <jimmyjazz14> I basically need a list like [1,2,3,[3,4,5],6,7,8]
21:46:46 <pumpkin> @type (\x -> guard (x >= '0' && x <= '9') >> pure (digitToInt x))
21:46:48 <lambdabot> forall (m :: * -> *). (MonadPlus m, Applicative m) => Char -> m Int
21:46:53 <pumpkin> :P
21:47:02 <malouin> jimmyjazz14: that list doesn't have different types.
21:47:02 <pumpkin> @type (\x -> guard (x >= '0' && x <= '9') >> Just (digitToInt x))
21:47:04 <lambdabot> Char -> Maybe Int
21:47:47 <malouin> Is it possible to have x :: ((->) r)?
21:48:08 <jimmyjazz14> @type [1,2,3,[3,4,5],6,7,8]
21:48:10 <lambdabot> forall t. (Num [t], Num t) => [[t]]
21:48:24 <jimmyjazz14> hmm right
21:49:11 <jimmyjazz14> not sure of this error I get from ghci when I try: let a = [1,2,3,[3,4,5],6,7,8]
21:49:28 <jimmyjazz14> No instance for (Num [t]) arising from the literal `8'
21:49:43 <dmwit> Lists are homogeneous.
21:49:57 <dmwit> You can't mix values of different types.
21:51:01 <jimmyjazz14> dmwit: is there a data structure in haskell that will allow me to (other than tuples)?
21:51:37 <dmwit> Not really.
21:51:45 <dmwit> It's kind of the whole point of Haskell. =P
21:52:05 <jimmyjazz14> hmm, right, perhaps I am just looking at the problem wrong
21:52:09 <malouin> jimmyjazz14: what about a tree?
21:52:32 <pumpkin> you can store heterogeneous things in lists, but you need an existential wrapper, and it helps if you know something "common" about the elements
21:52:32 <jimmyjazz14> a tree was my next thought
21:52:39 <pumpkin> but a tree looks more suitable for your problem
21:53:11 <malouin> something like data mytree = num Int | intlist [Int]
21:53:43 <jimmyjazz14> yeah I think a tree will work better thinking about it now
21:53:53 <pumpkin> malouin: no it isn't possible to have that, as far as I know
21:54:08 <pumpkin> malouin: x :: ((->) r), that is
21:54:29 <pumpkin> you can write instances for it, but you'd essentially be defining x as a type function in your example
21:54:40 <pumpkin> which is possible in other ways
21:54:59 <pumpkin> I may be wrong though :)
21:55:23 <malouin> pumpkin: ok, I didn't think it made sense to have x :: ((->) r), but I thought I'd check.
21:56:07 <Yrogirg> Hello. I have a program that takes a lot of time to run. I want to make it possible to interrupt the program by keypress so the data already processed can be stored and the progam can resume to the computation later. How can I implement this keyboard interruption?
21:56:25 <byorgey> malouin: ((->) r) has kind  * -> *.  Only things with kind * may classify values.
21:57:03 <malouin> kind, ok.
21:57:21 <byorgey> kinds are types for types.
21:57:29 <dmwit> Yrogirg: Sounds like the perfect use for threading.
21:57:37 <malouin> ok, yhat is what I figured.
21:59:47 <malouin> @type (\x -> x x)
21:59:48 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
21:59:48 <lambdabot>     Probable cause: `x' is applied to too many arguments
21:59:48 <lambdabot>     In the expression: x x
22:02:57 <roconnor> @type (\x -> out x x)
22:02:58 <lambdabot>     Occurs check: cannot construct the infinite type: f = (->) (Mu f)
22:02:58 <lambdabot>     Probable cause: `out' is applied to too many arguments
22:02:58 <lambdabot>     In the expression: out x x
22:03:44 <malouin> what is out?
22:03:47 <roconnor> @type (\x -> In (out x x))
22:03:49 <lambdabot>     Occurs check: cannot construct the infinite type: t = Mu ((->) t)
22:03:49 <lambdabot>       Expected type: t
22:03:49 <lambdabot>       Inferred type: Mu ((->) t)
22:03:53 <roconnor> @src Mu
22:03:53 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
22:04:19 <roconnor> oh right, Mu probably isn't enough to do this
22:04:29 <dmwit> http://r6.ca/blog/20060919T084800Z.html
22:04:33 <dmwit> roconnor: ^^
22:04:48 <roconnor> thanks I was looking for that
22:05:22 <byorgey> hehe
22:06:24 <roconnor> @type \f -> (\x -> f ((out x) x)) (In (\x -> f ((out x) x)))
22:06:26 <lambdabot>     Occurs check: cannot construct the infinite type: t = Mu ((->) t)
22:06:26 <lambdabot>       Expected type: t
22:06:26 <lambdabot>       Inferred type: Mu ((->) t)
22:07:03 <dmwit> hmph
22:07:17 <roconnor> @type \f -> (\x -> f ((out x) x)) (In (\x -> f ((out x) x))) :: (a -> a) -> a
22:07:19 <lambdabot>     Occurs check: cannot construct the infinite type: t = Mu ((->) t)
22:07:19 <lambdabot>       Expected type: t
22:07:19 <lambdabot>       Inferred type: Mu ((->) t)
22:07:30 <roconnor> @type (\f -> (\x -> f ((out x) x)) (In (\x -> f ((out x) x)))) :: (a -> a) -> a
22:07:31 <lambdabot>     Occurs check: cannot construct the infinite type: t = Mu ((->) t)
22:07:32 <lambdabot>       Expected type: t
22:07:32 <lambdabot>       Inferred type: Mu ((->) t)
22:07:36 <roconnor> humm
22:08:11 <roconnor> my my and lambdabot's My are different
22:08:18 <roconnor> er
22:08:25 <roconnor> my Mu and lambdabot's MU are different
22:08:27 <roconnor> @src Mu
22:08:28 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
22:08:32 <dmwit> roconnor: Mu is defined differently from that page, too.
22:08:42 <roconnor> dmwit: that is my page :)
22:08:47 <dmwit> ...oh =P
22:08:52 <dmwit> quite
22:09:05 * dmwit feels silly for pointing at the page now
22:09:14 <roconnor> dmwit: I was trying to find it.
22:09:20 * pumpkin moos
22:09:21 <idnar> haha
22:09:25 * byorgey is amused
22:09:32 <pumpkin> aMused?
22:09:37 <byorgey> hah!
22:09:40 <byorgey> pumpkin++
22:09:45 <dmwit> roconnor: That is the first sign of excellent website design. =)
22:09:54 <roconnor> The problem seems to be that we need f x to be (x -> a)
22:10:11 <roconnor> but that is soft of like (Flip (->) a)
22:10:19 <roconnor> rather than ((->) a)
22:10:20 <SamB_XP_> roconnor: shouldn't that be r7 ?
22:10:34 <roconnor> SamB_XP_: Russell is my name
22:10:39 <SamB_XP_> oh
22:10:50 <SamB_XP_> true
22:11:05 <roconnor> SamB_XP_: r7 was an understandable remark
22:11:23 <idnar> shouldn't that be r5l?
22:11:27 <malouin> r5l was too many characters.
22:11:38 <pumpkin> yeah, r6 is already a pain to type
22:11:39 * byorgey is very confused
22:11:44 <pumpkin> too many characters
22:11:53 <SamB_XP_> byorgey: arguing about his domain name
22:11:55 <idnar> and I suppose r was already taken?
22:12:03 <roconnor> @ask Cale can we have more type level combinators in addtion to Mu like Flip, Compose, Const, and, Join?
22:12:03 <lambdabot> Consider it noted.
22:12:06 <idnar> or should that be 7?
22:12:22 <byorgey> SamB_XP_: I got that part, but that's about as far as I got
22:12:22 <roconnor> idnar: you cannot have 1 or 2 letter domain names in canada
22:12:25 <SamB_XP_> idnar: I don't think bare numbers are legal
22:12:45 <pumpkin> roconnor: so r6 isn't allowed?
22:12:51 <SamB_XP_> byorgey: well, I was figuring "there are seven letters after the r in roconnor"
22:12:52 <roconnor> pumpkin: 6 isn't a letter
22:12:55 <roconnor> pumpkin: apparently
22:12:56 <pumpkin> oh I see
22:13:01 <byorgey> ohhhhh
22:13:03 <roconnor> as I found out
22:13:15 * byorgey should go to sleep
22:13:21 <pumpkin> .com doesn't allow one-letter domains either, except for a couple
22:13:32 <SamB_XP_> pumpkin: what "couple"?
22:13:42 <dmwit> wtf.com
22:13:48 <pumpkin> x.com belongs to paypal, and another one that I can't remember belongs to toyota iirc
22:14:04 <TomMD> SamB_XP_: ∀.com
22:14:08 <roconnor> :)
22:14:23 <SamB_XP_> TomMD: rectangle.com ... okay!
22:14:24 <idnar> xn--b9g.com?
22:14:33 <pumpkin> and q.com
22:14:38 <pumpkin> I don't think .com allows IDN yet?
22:15:04 <TomMD> SamB_XP_: You need better unicode support or fonts.
22:15:05 <SamB_XP_> oh, forall.com it was
22:15:11 <SamB_XP_> TomMD: I guess!
22:15:11 <TomMD> Indeed!
22:15:28 <malouin> gotta get ∀∃.ae
22:15:31 <SamB_XP_> if they add IDN support, will C-- finally be allowed?
22:15:44 <SamB_XP_> malouin: wouldn't it be better with a real ae character?
22:15:59 <malouin> yeah but that is the arab emirates tld that allows IDN
22:16:19 <malouin> and IIRC anyone to register
22:16:29 * malouin has an.alo.gy
22:17:16 <idnar> malouin: what about æ.ae?
22:17:30 <malouin> :)
22:21:16 <malouin> so ((->) r) is a type, but no value can have that type because it is of the * kind
22:21:36 <malouin> s/is/is not/
22:21:48 <idnar> it's a type constructor, and it has kind * -> *
22:22:06 <malouin> err... s/is of/is not of/
22:22:36 * malouin is trying to wrap the head around instance Functor ((->) r)
22:24:04 <roconnor> @src fmap (->)
22:24:04 <lambdabot> Source not found. Just try something else.
22:24:09 <roconnor> @src fmap ((->)  a)
22:24:10 <lambdabot> Source not found. Just what do you think you're doing Dave?
22:24:30 <SamB_XP_> @src fmap Reader
22:24:31 <lambdabot> Source not found. You type like i drive.
22:24:50 <roconnor> malouin: (r ->)  is a useful functor / applicative functor
22:24:57 <roconnor> and kinda useful monad
22:25:01 <SamB_XP_> @src Reader fmap
22:25:02 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
22:25:07 <SamB_XP_> @src fmap
22:25:07 <lambdabot> Source not found.
22:27:23 <malouin> I can't find it either.
22:27:39 <roconnor> malouin: anyhow, fmap = (.)
22:28:12 <Baughn> malouin: Which makes perfect sense if you think of a (possibly infinite) mape from all input values to all output values
22:28:31 <Baughn> malouin: Er. If you think of a function as a map from input to output values.
22:29:10 <roconnor> think of the function (r -> a) as an indexed set of a's (indexed by r) and you want to map (a -> b)
22:29:35 <roconnor> so you just look up a, and then apply your f :: a -> b to what you looked up
22:29:48 <rob_> hi everyone. I feel ashamed to ask, but I read on the Internet about totally unsafe printing functions, like printf, that don't need to be called inside the IO monad. I don't have time to learn how to use a debugger right now, so can you tell me where to find those ?
22:29:50 <malouin> Learn You a Haskell's way of explaining it makes sense to me.
22:30:07 <roconnor> fmap f indexedSet index = f (indexSet index)
22:30:15 <roconnor> malouin: oh, that's good.
22:30:20 <SamB_XP_> > f . [x,y,z]
22:30:21 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[a1]'
22:30:34 <malouin> It goes through
22:30:38 <malouin> fmap :: (a -> b) -> f a -> f b
22:30:40 <SamB_XP_> huh, that's not calaskell anymore?
22:30:46 <Baughn> rob_: Not printf. See Debug.Trace
22:30:47 <malouin> fmap :: (a -> b) -> ((->) r a) -> ((->) r b)
22:30:56 <malouin> fmap :: (a -> b) -> (r -> a) -> (r -> b)
22:31:03 <SamB_XP_> rob_: the debugger is lousy anyway, if you ask me
22:31:10 <roconnor> @djinn (a -> b) -> ((->) r a) -> ((->) r b)
22:31:11 <lambdabot> Cannot parse command
22:31:21 <roconnor> @djinn (a -> b) -> (r -> a) -> (r -> b)
22:31:21 <lambdabot> f a b c = a (b c)
22:31:30 <malouin> It seems reasonable composition makes sense for that signature.
22:31:53 <roconnor> malouin: its the only reasonable thing that has that signature
22:32:06 <rob_> yeah that's why I just want to call show on some of my variables without having to throw in some IO stuff or invoking error
22:32:27 <SamB_XP_> of course, the debugger is quite young -- it is convievable that it might get better
22:32:49 <SamB_XP_> but then again it is so ... so *temporal*
22:33:59 <Baughn> Would you prefer an eccleistical debugger?
22:34:53 <SamB_XP_> I ... don't get it
22:35:05 <SamB_XP_> that was a *serious* criticism of the debugger!
22:35:40 <Baughn> SamB_XP_: "Temporal" has multiple meanings. I picked the least convenient one.
22:35:46 <Baughn> Or the most convenient one, as it may be.
22:35:54 <malouin> roconnor: so it is possible to prove that fmap must be (.) for ((->) a)?
22:36:58 <Baughn> malouin: Prove? I don't know that you'd want to.
22:37:24 <SamB_XP_> malouin: try it and see!
22:37:27 <Baughn> THe fmap implementations are picked for usefulness, not generally for correctness - yes, they must obey some laws, but that's easy.
22:37:29 <mornfall> Quickie... is it better to use -- foo or -- | foo style comments for bits that are not exported from a module?
22:37:40 <malouin> don't want to do it, just wondering what disiderata you have to adopt to prove it or whether the Functor class and the type signature are enough.
22:37:46 <SamB_XP_> Baughn: but sometimes one wonders if there is a choice
22:38:33 <malouin> and the reason I ask is that I have a sense that it is possible to prove in this case.
22:38:37 <malouin> but I could be wrong.
22:39:22 <jmcarthur> @djinn (a -> b) -> (c -> a) -> (c -> b)
22:39:23 <lambdabot> f a b c = a (b c)
22:39:36 <jmcarthur> @pl f a b c = a (b c)
22:39:36 <lambdabot> f = (.)
22:39:41 <malouin> what is djinn?
22:39:50 <jmcarthur> not a proof of course
22:40:02 <jmcarthur> djinn takes a type and creates a function
22:40:11 <jmcarthur> for a limited subset of possible types
22:40:39 <jmcarthur> @djinn (a -> b) -> a -> b
22:40:40 <lambdabot> f a = a
22:40:48 <jmcarthur> @djinn a -> b -> a
22:40:49 <lambdabot> f a _ = a
22:40:53 <jmcarthur> etc.
22:41:20 <malouin> interesting
22:42:22 <malouin> @free fmap :: (a -> b) -> (c -> a) -> (c -> b)
22:42:23 <lambdabot> g . k = p . f => f . q = f1 . h => g . fmap k q = fmap p f1 . h
22:42:39 <malouin> that seems rather cryptic.
22:48:38 <hatds> > tail . reverse . tails $ reverse [1..5]
22:48:40 <lambdabot>   [[1],[2,1],[3,2,1],[4,3,2,1],[5,4,3,2,1]]
22:48:42 <hatds> bleh
22:49:04 <hatds> any better ideas?
22:49:44 <dolio> > scanl1 (:) [] [1..5]
22:49:45 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
22:49:57 <dolio> > scanl1 (flip (:)) [] [1..5]
22:49:58 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
22:50:02 <dolio> > scanl (flip (:)) [] [1..5]
22:50:03 <lambdabot>   [[],[1],[2,1],[3,2,1],[4,3,2,1],[5,4,3,2,1]]
22:50:10 <dolio> Boom.
22:50:12 <hatds> there we go :)
22:56:21 <solrize_> hey is there an idiomatic way to take an infinite [IO Bool] stream and chop it at the first false value?
22:56:39 <solrize_> like, something with foldM_ perhaps
22:56:41 <sclv> hoogle untilM
22:56:45 <sclv> ?hoogle untilM
22:56:46 <lambdabot> No results found
22:56:49 <sclv> ?hoogle whileM
22:56:49 <lambdabot> No results found
22:57:06 <sclv> i'd write untilM
22:57:47 <mbuf> newbie here; how do I install Haskell dependencies on Fedora if build-depends in .cabal says: curl, hslogger, base, test-framework, hxt?
22:57:59 <solrize_> sclv ok, i'm just surprised it's not in some library
22:58:05 <solrize_> websearch found one right away
22:58:09 <solrize_> http://porg.es/blog/simple-socket-programming-with-haskell
22:58:52 <hatds> funny, I was just writing a whileM
22:59:02 <pumpkin> can't you just sequence it and use until?
22:59:13 <solrize_> :t until
22:59:14 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
22:59:17 <sclv> sequence isn't lazy i think?
22:59:19 <hatds> no
22:59:22 <pumpkin> ah
22:59:26 <hatds> sequence constructs the whole list
22:59:34 <pumpkin> that's annoying
22:59:35 <hatds> (once it is demanded)
22:59:40 <hatds> it'd be unsafe otherwise
22:59:52 <hatds> yea, [IO a]'s are often more useful than IO [a]
23:00:12 <solrize_> > until (> 100) (**2) 1.5
23:00:13 <lambdabot>   656.8408355712891
23:00:21 <solrize_> @where until
23:00:21 <lambdabot> I know nothing about until.
23:00:28 <solrize_> @hoogle until
23:00:29 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
23:00:33 <sclv> @src until
23:00:34 <lambdabot> until p f x | p x       = x
23:00:34 <lambdabot>             | otherwise = until p f (f x)
23:00:37 <solrize_> hmm i didn't know about that
23:01:01 <solrize_> :t fix
23:01:02 <lambdabot> forall a. (a -> a) -> a
23:03:25 <hatds> there really should be a library of list-like functions generalizing find, takeWhile, dropWhile, etc. for working with [IO a]'s and functions (a -> IO Bool) that short circuit properly
23:04:28 <tibbe> I need a mutable array where I can store functions as elements, what should I use?
23:05:00 <Berengal> tibbe: IOArray or STArray, probably
23:05:15 <tibbe> Berengal: ok, thanks
23:05:41 <pumpkin> mmorrow:
23:05:42 <pumpkin> foreign import ccall unsafe "getAllocations" getAllocations :: IO Int64
23:05:42 <pumpkin> 	-- defined in ghc/rts/Stats.c
23:07:00 <mmorrow> pumpkin: oh nice
23:08:09 <m3ga> @atomically
23:08:09 <lambdabot> Unknown command, try @list
23:08:25 <m3ga> :t atomically
23:08:27 <lambdabot> Not in scope: `atomically'
23:09:47 <sclv> ?hoogle atomically
23:09:47 <lambdabot> Control.Exception NestedAtomically :: Exception
23:11:11 <m3ga> found it : http://hackage.haskell.org/packages/archive/base/latest/doc/html/GHC-Conc.html#v:atomically
23:11:35 * tibbe wonders why the library documentation never ranks highly on google
23:15:37 <thoughtpolice> yay: https://gist.github.com/7c21be754f21dd159ca6
23:15:41 <thoughtpolice> ghc annotations are neat :)
23:16:11 <pumpkin> thoughtpolice: ?
23:16:59 <pumpkin> as in BSP's plugins?
23:17:41 <pumpkin> or is this separate?
23:18:03 <thoughtpolice> pumpkin: using annotations for my own compiler
23:18:29 * pumpkin is still confused :o
23:18:37 <pumpkin> not that that's a rare thing
23:19:30 <tibbe> what do I have to import to access the I# constructor?
23:19:53 <pumpkin> GHC.Int is one of them
23:20:05 <pumpkin> it's actually in a bunch of places I think
23:20:25 <pumpkin> GHC.Types I think actually
23:21:00 <pumpkin> zomg I found it
23:21:01 <pumpkin> data [] a = [] | a : [a]
23:21:05 <pumpkin> it's hidden in GHC.Types
23:21:09 <pumpkin> not even covered by haddock
23:21:57 <pumpkin> wow, we have three edwardks now
23:31:30 <Berengal> View patterns are nice
23:31:53 <Berengal> But they tend to move computations to the lhs...
