00:00:09 <Cale> ivanm: no
00:00:25 <ivanm> well, why else would you be in #bfpg? :p
00:00:37 <Cale> Because it's about functional programming
00:00:50 <ivanm> ahhhh
00:00:54 <ivanm> so you're an FP whore? :p
00:01:13 <Cale> http://www.qwantz.com/index.php?comic=1486
00:01:51 <dmwit> Ugh, that episode is so annoying...
00:02:23 <ivanm> Cale: wtf? :s
00:05:49 <erikc> dinocomics is awesome
00:12:59 <ivanm> @seen dibblego
00:12:59 <lambdabot> dibblego is in #bfpg, #scala, #haskell-in-depth, #functionaljava, #xmonad and #haskell. I last heard dibblego speak 1h 41m 14s ago.
01:38:16 <alpha_q> hey how should I count the duplicate numbers in two lists that are not on the same position
01:38:43 <alpha_q> eg c_dupl :: [Int] -> [Int] -> Int
01:39:05 <BONUS> you can sort and then group
01:39:09 <Saizan_> you want to count the elements that appear in both lists?
01:39:10 <alpha_q> (c_dupl [1, 2, 3]) [3, 2, 1]
01:39:11 <alpha_q> 2
01:39:25 <alpha_q> yep, but not in the same position
01:39:46 <alpha_q> in my example 1 and 3 are counted and 2 isn't
01:39:52 <Beelsebob> countDupsNonPositionedDups = countDups <^(-)^> countPositionedDups
01:39:55 <BONUS> ah
01:40:21 <alpha_q> Beelsebob wha? :)
01:40:35 <Beelsebob> count the duplicates
01:40:43 <Beelsebob> (while ignoring position totally)
01:40:52 <Beelsebob> count the ones that are duplicated in the same position
01:40:54 <Beelsebob> subtract
01:40:55 <Beelsebob> done
01:41:25 <Beelsebob> oh, but there's a level of lifiting missing there thanks to the two lists
02:04:47 <alpha_q> Beelsebob i desided to implement your suggestion and here is how i count the positioned duplicates
02:04:50 <alpha_q> posDuplCnt :: [Int] -> [Int] -> Int
02:04:50 <alpha_q> posDuplCnt l1 l2 = filter (\p -> fst p == snd p) zip l1 l2
02:05:46 <alpha_q> but it tells me that the inferred type from zip [(a, b)] is different from the expected type for the closure [(a, a)]
02:06:39 <alpha_q> what should i do?
02:08:16 <alpha_q> whoops... missing brackets. my bad
02:08:33 <alpha_q> (i thought I was getting out of lisp :| )
02:20:41 <Jedai> alpha_q: You have options to avoid brackets that you wouldn't have in Lisp though, ($) or (.) for instance
02:20:48 <Jedai> as well as layout
02:22:27 <Jedai> A solution to your problem : let duplicates xs ys = sum . map (length . tail) . group . sort $ [ e | (x,y) <- zip xs ys, x /= y, e <- [x, y] ]
02:23:00 <Jedai> > let duplicates xs ys = sum . map (length . tail) . group . sort $ [ e | (x,y) <- zip xs ys, x /= y, e <- [x, y] ] in duplicates [1, 2, 3] [3, 2, 1]
02:23:01 <lambdabot>   2
02:26:33 <Jedai> Or maybe "let duplicates xs ys = length . filter (not . null . tail) . group . sort $ [ e | (x,y) <- zip xs ys, x /= y, e <- [x, y] ]" depending on what you exactly want
02:29:10 <BONUS> or maybe
02:29:14 <BONUS> sum . map (length . tail) . group . sort . concat . map (sequence [fst,snd]) . filter (uncurry (/=)) . zip xs $ ys
02:32:54 <BONUS> or @pl style: let duplicates = ((sum . map (length . tail) . group . sort . concat . map (sequence [fst,snd]) . filter (uncurry (/=)) .) . zip
02:33:21 <ivanm> BONUS: where's the in?
02:33:31 <BONUS> but this is just code golf wankery basically, the key is to take all the duplicates and subtract from them the positioned duplicates
02:33:44 <BONUS> it aint there :)
02:33:59 <BONUS> if you do: let f x y = x + y
02:34:00 <BONUS> in ghci
02:34:04 <BONUS> or in do notation
02:34:13 <BONUS> or in a list comprehension
02:34:17 <BONUS> you don't need the in
02:42:15 <Axman6> BONUS: did you see the lyah on the pirate bay?
02:42:32 <BONUS> axman no lol
02:42:34 <BONUS> is it the pdf?
02:42:39 <Axman6> dunno
02:42:45 <BONUS> haha let's see
02:43:00 <Axman6> Cale linked to it earlier
02:43:16 <Cale> <Cale> BONUS: lol, bookwarez: http://thepiratebay.org/torrent/4845954/Learn_You_a_Haskell_for_Great_Good
02:43:21 <BONUS> ah yeah lol
02:43:28 <BONUS> hahaha nice
02:43:43 <BONUS> i like the gesture
02:43:57 <BONUS> even though it's probably much easier to just download the pdf from the site
02:44:03 <Axman6> yah
02:44:06 <Bacta> @fag
02:44:06 <lambdabot> The answer is: Yes! Haskell can do that.
02:44:33 <Jedai> well at least it's a torrent... If there's suddenly an huge influx of people anxious to learn Haskell they'll be able to download the file all together !!! ;)
02:45:39 <Bacta> @faggot
02:45:40 <lambdabot> Unknown command, try @list
02:45:42 <BONUS> yeah haha. that's cool about open source and open books, people can spread them any way they want to
02:45:44 <Bacta> @list
02:45:45 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
02:51:49 <SColes>  Sam__
02:51:56 <Beelsebob> alpha_q: just so you know -- (\x -> fst x == snd x) is aka uncurry (==)
02:52:18 <Heffalump> not if (==) is lazy
02:52:53 <Beelsebob> *thinks*
02:52:59 <Heffalump> > (\x -> fst x == snd x) (undefined :: ((), ()))
02:53:00 <Beelsebob> why not?
02:53:00 <lambdabot>   * Exception: Prelude.undefined
02:53:16 <Heffalump> > uncurry (==) (undefined :: ((), ()))
02:53:18 <lambdabot>   * Exception: Prelude.undefined
02:53:20 <Beelsebob> ah, true
02:53:27 <Heffalump> > let _ == _ = True in (\x -> fst x == snd x) (undefined :: ((), ()))
02:53:28 <lambdabot>   True
02:53:32 <Beelsebob> heh, shame (==) isn't lazy there
02:53:36 <Heffalump> > let _ == _ = True in uncurry (==) (undefined :: ((), ()))
02:53:37 <lambdabot>   True
02:53:45 <Heffalump> oh!
02:53:50 <Beelsebob> oh, course
02:53:50 <Beelsebob> yeh
02:53:52 <Beelsebob> == is lazy
02:53:59 <Beelsebob> so fst and snd never get evaluated
02:54:13 <Heffalump> right
02:54:18 <Heffalump> but I'm confused about why uncurry works too
02:54:26 <Heffalump> @src uncurry
02:54:27 <lambdabot> uncurry f p = f (fst p) (snd p)
02:54:34 <Heffalump> ah. uncurry is lazy. I didn't know that.
02:54:39 <Heffalump> I always write it out with a tuple
02:54:41 <Beelsebob> heh, well, that's provably equal then :)
02:54:45 <Beelsebob> rather trivially
02:54:55 <Beelsebob> yeh, ditto
02:55:22 <idnar> Heffalump: use a lazy tuple :P
02:55:41 <Heffalump> won't somebody think of the poor GC, having to manage all these extra thunks?
02:55:55 <idnar> haha
02:56:19 <Beelsebob> the GC likes thunks
02:56:21 <Beelsebob> it gets to eat them
02:56:37 * Heffalump is eating breakfast
02:56:41 <BONUS> \f ~(a,b) -> f a b is equivalent though
02:56:48 <Beelsebob> thunk on toast Heffalump?
02:56:56 <BONUS> haha
02:57:04 <Sam___> bacon?
02:57:13 <Beelsebob> bastard
02:57:17 <Beelsebob> can't get good bacon here
02:57:18 <Heffalump> bacon would be nice, but not really a good idea to have every day for breakfast
02:57:38 <Sam___> cholesterol is like a videogame the higher your numbers the more you win
02:57:46 <Beelsebob> heh
02:57:47 <Heffalump> my wife and mother-in-law are about to go shopping to buy good bacon to take to my sister-in-law in Italy
02:58:35 <Beelsebob> Heffalump: damn it, meeting you has totally changed my expectations of you -- then again, I don't think you ever could have actually *been* a heffalump :(
02:58:57 <Beelsebob> :P
02:59:08 <Heffalump> I like making loud stomping noises when I go up and down stairs, if that helps?
02:59:16 <Beelsebob> that does help :)
03:05:39 <Heffalump> is there any sane way to get libtinfo.so.5 on Debian?
03:19:44 <alpha_q> thanks Beelsebob and Jedai :)
03:20:10 <Bacta> @fag
03:20:10 <lambdabot> The answer is: Yes! Haskell can do that.
03:23:12 <Bacta>  @fag can Haskell recognise trolls?
03:23:17 <Bacta> @fag can Haskell recognise trolls?
03:23:17 <lambdabot> The answer is: Yes! Haskell can do that.
03:29:28 <skorpan> lol
03:30:39 <Heffalump> the answer to my question seems to be to symlink /lib/libncurses.so.5 to /lib/libtinfo.so.5 -- evil!
03:56:29 <Axman6> SamB: you around?
04:27:57 <skorpan> will someone please teach me how to remember which is which of words/unwords and lines/unlines?
04:28:14 <BONUS> hmm well
04:28:38 <mauke> Just Do It™
04:28:55 <BONUS> "asf asf saf" is a string. with words "asf asf saf" you kind of turn it into several words ["asf","asf",saf"]
04:28:57 <mauke> words gives you the words of a string, lines the lines
04:29:09 <skorpan> that makes sense
04:29:11 <skorpan> thanks
04:30:12 <hatds> generally functions usually are named after the result and not the arguments
04:35:27 <tornvig> hello there. I'm taking my first steps in the world of haskell and I was wondering how one would make an "add" function to take 0, 1 or 2 arguments and add them together?
04:36:24 <mauke> that requires nontrivial typeclass hackery
04:36:31 <mauke> not recommended for beginners
04:36:41 <tornvig> right.. I thought so
04:36:46 <mauke> why do you need such a function?
04:36:47 <tornvig> thanks a lot
04:36:50 <Heffalump> @type sun
04:36:51 <Heffalump> @type sum
04:36:51 <lambdabot> Not in scope: `sun'
04:36:52 <lambdabot> forall a. (Num a) => [a] -> a
04:36:59 <Heffalump> you can write something with that type no problem
04:37:07 <Heffalump> i.e. take an arbitrary number of arguments
04:37:14 <mauke> yeah, arbitrary is much easier
04:38:58 <tornvig> ok. so the easy way is to just go with a list as one argument?
04:39:03 <mauke> yep
04:39:11 <tornvig> ye alright
04:59:03 <alpha_q> how do I generate a random number in Haskell?
04:59:15 <mauke> :t randomIO
04:59:17 <lambdabot> forall a. (Random a) => IO a
05:00:37 <dschoepe> :t randomRIO
05:00:39 <lambdabot> forall a. (Random a) => (a, a) -> IO a
05:00:41 <dschoepe> also useful
05:05:29 <Axman6> alpha_q: you can avoid IO if you use the if you use those function without the IO at the end
05:05:34 <Axman6> :t randomR
05:05:35 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> (a, g)
05:05:50 <Axman6> :t mkStdGen
05:05:52 <lambdabot> Int -> StdGen
05:06:43 <alpha_q> randomRIO was what I needed, thanks
05:09:34 <dschoepe> Axman6: Although one is very likely to need IO at some point anyway, or the numbers won't be very random
05:09:47 <Axman6> yah
05:13:57 <BONUS> however, using the pure random functions, you can get away with doing IO just once
05:14:22 <BONUS> instead of running to IO every time you need a random value
05:14:37 <alpha_q> another question: I am trying to make a small game. How do I define the game loop?
05:14:52 <alpha_q> something like while(!ended) { play(); }
05:14:56 <skorpan> recursion
05:15:07 <alpha_q> won't i run out of stack?
05:15:08 <dschoepe> alpha_q: if done then return () else mainLoop
05:15:26 <dschoepe> ghc will optimize it to run in constant space.
05:15:29 <BONUS> main = blah; blah; blah; when (condition) main
05:17:00 <alpha_q> thanks
05:26:58 <skorpan> @pl \(x, y) -> (map z x, y)
05:26:59 <lambdabot> ap (liftM2 ((,) .) map fst) snd
05:28:17 <dschoepe> @pl \(x,y) -> (f x, y)
05:28:17 <lambdabot> first f
05:28:26 <skorpan> oh, that's nicer
05:28:51 <skorpan> @index first
05:28:51 <lambdabot> Control.Arrow
05:33:44 <Botje> wonder why \bot didn't turn the first one into first (map z)
05:38:45 <ivanm> @seen dons
05:38:46 <lambdabot> dons is in #haskell-in-depth, #gentoo-haskell, #concatenative, #arch-haskell, #darcs, #yi, #xmonad, #ghc and #haskell. I last heard dons speak 14h 53m 43s ago.
05:40:12 <hackagebot> hunp 0.1 - Unpacker tool with DWIM (DenizDogan)
05:40:46 <ivanm> doesn't Deniz know about atool?
05:41:28 <ivanm> anyone know why in RWH, they print usage info for an app to stderr?
05:41:51 <mauke> in what cases?
05:41:55 <dschoepe> ivanm: Because it is displayed in case of an error(not used correctly)?
05:42:08 <ivanm> dschoepe: noep, they use that even if you do --help :s
05:42:14 <ivanm> mauke: all cases
05:42:14 <mauke> bug
05:42:18 <ivanm> yeah
05:42:23 <mauke> --help should go to stdout and exit with 0
05:42:30 <ivanm> that's what I figured
05:43:21 <skorpan> ivanm: what's atool?
05:43:40 <trofi> usuallu usage() is called when arguments are invalid
05:43:41 <ivanm> http://www.nongnu.org/atool/
05:43:56 <ivanm> "a script for managing file archives of various types" <-- desc from the gentoo ebuild
05:44:31 <ivanm> there's also unfoo, which only does unpacking (atool also does packing, listing, etc.)
05:44:35 <mauke> "atool identifies archives by their file extension." <- fail
05:44:55 <skorpan> yeah, hunp lets you configure this yourself using regexen since 0.1 :)
05:45:01 <ivanm> oh? how does hunp do it?
05:45:05 <mauke> ... regex?!
05:45:15 <ivanm> as in?
05:45:21 <ivanm> when would a file extension fail?
05:45:33 <mauke> when it's a rar file called foo.zip
05:45:34 <skorpan> seldom
05:45:43 <mauke> happened often enough to me
05:45:46 <ivanm> mauke: yeah... but how does hunp help with that?
05:45:54 <mauke> I have no idea
05:45:57 <ivanm> you have to _know_ that it's a zip file then, don't you?
05:46:05 <skorpan> hunp doesn't do that
05:46:06 <dschoepe> file signatures I guess, like the /usr/bin/file
05:46:16 <mauke> ivanm: http://mauke.ath.cx/stuff/sh/funpack
05:46:16 <ivanm> mauke: atool --format=zip
05:46:27 <mauke> ivanm: no
05:46:42 <ivanm> ahhh
05:46:45 <mauke> why would I use atool if I have to think about the archive type?
05:46:57 <skorpan> apparently atool does use "file"
05:46:59 <ivanm> mauke: I didn't think about doing it based on the mime type
05:47:23 <skorpan> but does atool DWIM on directories?
05:47:39 <skorpan> because i already knew about a tool called "unp", which didn't DWIM
05:47:44 <mauke> funpack DWIM :-)
05:47:44 <ivanm> skorpan: if it has more than one file, it creates a dir
05:48:11 <ivanm> skorpan: and atool's man page doesn't mention file... just says it uses the extension if --format isn't specified
05:48:26 <skorpan> ivanm: but that's not what i mean.. e.g. if i have a movie split up in a bunch of rar files in a directory, i only have to pass the directory name to hunp
05:48:41 <skorpan> ivanm: "atool identifies archives by their file extension. Sometimes this is not possible - for instance rar archives usually have varying numeric file extensions. In those cases when atool can't identify the format, file is used instead. (atool can be configured not to use file.)"
05:48:53 <ivanm> hmmm, didn't see that
05:48:58 <skorpan> that's on the homepage
05:49:06 <mauke> skorpan: that still fails in the "rar called .zip" case
05:49:06 <skorpan> but indeed it will try to unzip the file if it's a zip extension
05:49:11 <ivanm> skorpan: don't know about rar files in a dir... don't you normally specify the first rar file or something?
05:49:28 <skorpan> ivanm: it doesn't matter which rar file you specify if they're part of the same archive
05:49:35 <ivanm> *nod*
05:49:41 <ivanm> I don't use rar usually ;-)
05:49:42 <Zao> skorpan: Yes. foo.rar or foo.part01.rar
05:49:46 <skorpan> ivanm: when you pass a dir to hunp, it looks for the first file in that directory matching any regexp
05:49:52 <ivanm> fair enough
05:50:04 <ivanm> skorpan: I used to use unfoo, but switched to atool because of alist and apack
05:50:18 * ivanm can never remember which magic incantations are needed to manually create a .tar.gz, etc.
05:50:23 <skorpan> Zao: yeah, but what really bugged me, and made me write hunp, was that sometimes it's .r00 and sometimes part001.rar... hunp takes care of this
05:50:26 <HMAmemefan> sup fags
05:50:38 <mauke> HMAmemefan: have you read your SICP today?
05:50:38 <skorpan> [14:50] *** HMAmemefan is JWIRC applet user
05:50:49 <Zao> HMAmemefan: You're on the wrong side of the internets for that kind of language.
05:51:01 <ivanm> see 4chan
05:51:11 <HMAmemefan> oh yes i have
05:51:12 <Zao> (bix nood)
05:51:19 <mauke> Zao: wrong board
05:51:51 <mauke> ivanm: tars is all I create (it's "tar cf") :-)
05:52:26 <Zao> mauke: The best thing about tar is when a gtar user tries to use a real tar.
05:52:30 <skorpan> (also atool is written in perl...)
05:52:32 <HMAmemefan> hey guys I need your haskell bias opinion on something
05:52:39 <Zao> What do you mean, tar -fjx omg.tar  doesn't work?
05:52:39 <HMAmemefan> biased, rather
05:53:01 <HMAmemefan> care to indulge?
05:53:04 <Zao> (well, omg.tar.bz2, but yeah)
05:53:24 <ivanm> skorpan: why did you have to tell me that! :o
05:53:26 <ivanm> ;-)
05:53:35 <ivanm> mauke: not even gzipped ones?
05:53:38 <skorpan> ivanm: yeah, better switch to hunp!
05:53:52 <ivanm> skorpan: but atool can also do packing! and listing!
05:53:58 <ivanm> _that_ is why I use it
05:54:22 <skorpan> should be fairly easy to implement in hunp
05:54:28 <mauke> ivanm: well, that's tar cfz, but you don't have to remember that because you can just call gzip afterwards
05:54:38 <Alpounet> HMAmemefan, just tell us
05:54:41 <skorpan> maybe we can call it htool and make hunp the equivalent to aunpack
05:55:01 <HMAmemefan> if you had to hax something, what would it be?
05:55:11 <ivanm> skorpan: so you going to one-up mauke and start using file as well to check the mime-type? ;-)
05:55:22 <skorpan> ivanm: i may reimplement file in haskell ;P
05:55:27 <koala_man> gtar xf file.tar.*
05:55:33 <ivanm> HMAmemefan: well, if I was going to hex something I'd probably use evil magic...
05:55:37 <ivanm> but I have no idea what "hax" is
05:55:51 <Alpounet> neither do I
05:56:06 <HMAmemefan> READ SICP
05:56:12 <HMAmemefan> fuck
05:56:15 <HMAmemefan> i need a life
05:56:23 <HMAmemefan> it just dawned on me
05:56:29 <mauke> HMAmemefan: you also need better memes
05:56:56 <HMAmemefan> I stick with the tried and true
05:57:05 <skorpan> i found some old 4chan thread about SICP and "hax"
05:57:06 <HMAmemefan> im a meek person, not about to take a risk on a new meme
05:57:36 <ivanm> even though you're a fan of memes?
05:58:03 <mauke> his nick indicates he's a fan of one meme
05:58:07 <HMAmemefan> no, just the HMA meme
05:58:17 <mauke> (not really a meme since it's only used by one person, but whatever)
05:58:26 <skorpan> what's HMA?
05:58:34 <HMAmemefan> hax my anus, skorpan
05:58:37 <HMAmemefan> hax my anus
05:58:39 <skorpan> i see
05:59:22 * ivanm feels tempted to @where ops
05:59:54 --- mode: ChanServ set +o Heffalump
06:00:17 <ivanm> thanks Heffalump
06:01:15 <philipp_> if you use Language.Haskell.Interpreter is there any way to link against some shared library so you don't get >30mb binaries?
06:01:35 <Heffalump> not now, but hopefully soon
06:01:45 <philipp_> hm k
06:01:48 <philipp_> thanks
06:07:31 <ivanm> is there a neater way of saying "if (b1 == b2) then FooBar else if b1 then Foo else Bar" ?
06:08:05 <dschoepe> ivanm: guards
06:08:15 <Alpounet> or even pattern matching
06:08:19 <Alpounet> for the first if
06:08:26 <Alpounet> if it's at a function's top level
06:08:30 <ivanm> b1 and b2 are booleans representing if an option is chosen: if both or neither is chosen, it defaults to FooBar, otherwise chooses between Foo and Bar
06:08:33 <Alpounet> s/level/scope/
06:08:36 <ivanm> hmmm.... guards might work...
06:08:54 <ivanm> I was thinking more of some fancy logic approach
06:16:14 <eu-prleu-peupeu> hello haskell people
06:16:29 <Axman6> o/
06:17:42 <ivanm> hey eu-prleu-peupeu
06:18:02 <eu-prleu-peupeu> yo ivan
06:18:12 <eu-prleu-peupeu> now im earning big bucks coding in python
06:18:20 <eu-prleu-peupeu> one day ill earn big bucks coding in haskell
06:18:26 <eu-prleu-peupeu> ill just have to learn haskell before that
06:18:39 <eu-prleu-peupeu> it might come in handy
06:18:49 <ivanm> heh, might be a start ;-)
06:48:59 <philipp_> "GhcException "unable to load package `unix-2.3.1.0'" when using runInterpreter (ghci-6.11.20090603 and unix-2.3.1.0 exists)
06:50:04 <elbar> 6.11 is that a livebuild?
06:50:33 <Cheery> damn, my mockingbird doesn't obliviate
06:50:33 <philipp_> some daily snapshot
06:52:31 <ski>   case (b1,b2) of
06:52:34 <Cheery> now my mockingbird obliviates.
06:52:36 <ski>     (True ,False) -> Foo
06:52:38 <ski>     (False,True ) -> Bar; _             -> FooBar
06:52:44 <Cheery> I guess my reduction algorithm is correct then.
06:52:45 <ski> er, split that last line
06:52:51 <ski> ivanm : ^ ?
06:53:09 <Cheery> there's trouble though.. it seems my evaluation algorithm does full job.
06:53:20 <Cheery> therefore mockingbird kills it.
06:53:24 <ivanm> ski: heh, already did it with guards
06:53:26 <ivanm> but thanks anyway
07:06:14 <ivanm> @undo do (a,b) <- foo; bar a b
07:06:15 <lambdabot> foo >>= \ (a, b) -> bar a b
07:06:24 <ivanm> ^^ am I able to use liftM uncurry or something here?
07:06:40 <Cheery> I'm playing with some lambda calculus: http://paste.pocoo.org/show/124161
07:07:15 <Cheery> do you know what'd be simplest strategy to evaluate lambda calculus expressions in steps?
07:07:28 <Axman6> @. pl undo do (a,b) <- foo; bar a b
07:07:28 <lambdabot> uncurry bar =<< foo
07:08:27 <mercury^> Cheery: haha
07:08:53 <ivanm> Axman6: aha! didn't think about putting that in @pl
07:09:25 <ivanm> thanks!
07:09:43 <Axman6> aww shucks, lambdabot did all the hard work
07:09:44 <Axman6> :P
07:09:48 <ivanm> heh
07:17:53 <shapr> bartek: Are you Bartek Kochan?
07:18:04 <bartek> no.
07:18:08 <shapr> oh, ok then.
07:18:21 <bartek> can I ask, who he is?
07:18:23 <bartek> :)
07:18:34 <shapr> He's a guy who knows a lot about bladecenters.
07:18:43 <bartek> ah
07:19:38 <Heffalump> shapr: you still trying to get your blade collection going? :-)
07:24:01 <byorgey> Cheery: there are many different strategies for evaluating lambda calculus expressions, see https://secure.wikimedia.org/wikipedia/en/wiki/Evaluation_strategy
07:24:10 <byorgey> Cheery: call-by-value is probably the simplest.
07:24:46 <byorgey> i.e. always reduce the right-hand side of an application before actually reducing the application itself.
07:26:38 <Cheery> byorgey: how much does it matter which evaluation strategy one is using?
07:26:41 <hackagebot> penn-treebank 0.1.0.1 - Tools for manipulating the Penn TreeBank (EricKow)
07:27:00 <byorgey> Cheery: depends what you're doing.  but they will all give the same answers.
07:27:34 <byorgey> the differences mostly have to do with efficiency, laziness, and so on
07:27:48 <byorgey> but for your application I doubt it matters much.
07:30:49 <Cheery> byorgey: I'm doing a toy evaluator that'd visualize it all on a screen.
07:31:37 <Cheery> the thing I've been doing is using a certain flavour of call-by-value I think.
07:31:39 <byorgey> Cheery: in that case, why not let the user choose which evaluation strategy they want to see? =)
07:31:50 <byorgey> just start with one and once you get that working you can add more.
07:32:19 <Cheery> I'm not sure whether it's that simple.
07:33:22 <RyanT5000> are there any good books on functional program design?  I'm not looking for anything as formulaic as OOP's Design Patterns, but something attacking the same sorts of problems (how to get multiple programmers working together without a huge amount of communication overhead, etc.) might be useful
07:33:44 <Cheery> for the purposes, I think an evaluation strategy that evaluates lazily would be nice.
07:33:49 <Cale> Normal order evaluation is pretty simple.
07:35:13 <Cale> Just always evaluate outermost-first
07:35:14 <Cheery> yep, I guess I just need to change my data structure for it somewhat.
07:35:34 <Cheery> I represent combinators in this manner:
07:35:36 <Cheery> s = Lambda([2, 0, [1, 0]], arity=3)
07:36:03 <Cheery> (xyz -> xz(yz))
07:36:16 <skorpan> S!
07:36:43 <skorpan> de bruijn Cheery?
07:36:58 <Cheery> if I always evaluate outermost first, it causes one small trouble.
07:37:00 <hatds> there aren't many things written about functional design patterns
07:37:26 <Cheery> say I give that lambda itself.
07:37:47 <RyanT5000> hatds: hm; i wonder why that is
07:37:55 <Cale> That's because, for the most part, we strive to turn those into either libraries or language features
07:38:06 <Cheery> (xyz -> xz(yz))(xyz -> xz(yz))
07:38:16 <skorpan> Cheery: was that de bruijn?
07:38:19 <Axman6> so they don't have to be redesigned over and over again
07:38:20 <Cale> If there's a repeated pattern, and you can't abstract it, you must have failed somehow :)
07:38:26 <RyanT5000> Cale: that's a good point
07:38:35 <Cheery> skorpan: what's a de bruijn?
07:38:45 <RyanT5000> Cale: although i'm really more interested in *human interaction* patterns
07:38:51 <Axman6> i think foldl is the best example of that
07:38:58 <skorpan> Cheery: de bruijn notation, i read about it long ago and that reminds me of it.. it has to do with replacing formal parameters with integers
07:38:59 <hatds> you might find this interesting, although it's just about code:  http://eve-language.blogspot.com/2007/01/patterns-for-modules.html
07:39:00 <Cale> Cheery: The guy whose name is attached to that numbering scheme
07:39:01 <RyanT5000> Cale: many of which interact with the language
07:39:09 <byorgey> yikes, de bruijn indices are scary.  so easy to get wrong =P
07:39:16 <Cheery> (yz -> (xyz -> xz(yz))z(yz))
07:39:25 <Cheery> skorpan: oh! I didn't knew it has a name. :)
07:39:43 <skorpan> i think it's used for alpha conversion or something
07:39:49 <skorpan> as i said, it was a long time ago :P
07:40:15 <byorgey> if you use de bruijn indices there's no *need* for alpha conversion =)
07:40:25 <skorpan> ah, of course
07:40:27 <skorpan> that makes sense
07:40:49 <Cheery> Lambda([Lambda([2, 0, [1, 0]]), 0, [1, 0]])
07:41:14 <Cale> RyanT5000: Yeah, it would be interesting to see something about that...
07:41:29 <byorgey> Cheery: what's the trouble?
07:41:34 <RyanT5000> Cale: perhaps i'll write it once i'm done with a few commercial projects :)
07:41:43 <Heffalump> byorgey: there are various papers about type-based frameworks to help you not get them wrong
07:42:00 <RyanT5000> speaking of which, i emailed the guys at the Industrial Haskell Group a few days ago, and they haven't gotten back to me
07:42:05 <RyanT5000> is anyone here involved in that?
07:42:08 <Cheery> byorgey: I wonder how to continue from that, ie. how does the next step go?
07:42:14 <byorgey> Heffalump: I believe it.  Personally, I just use locally nameless representations instead =)
07:42:17 <RyanT5000> i'm not sure whether i sent it to the right address
07:42:26 <Heffalump> byorgey: you mean HOAS, or what?
07:42:35 <hatds> there might be some Galois presentations about this kind of thing
07:43:06 <byorgey> Heffalump: no, locally nameless means using names for free variables and de bruijn indices for bound variables
07:43:25 <Cheery> (yw -> (yz -> wz(yz))w(yw)) it's basicly this what happens next if I go normal-order further.
07:43:45 <byorgey> Heffalump: e.g. see McBride et al "I am not a number, I am a free variable"
07:45:16 <Cheery> (yw -> (yz -> wz(yz))(yw)) erm, meant.. this
07:47:09 <Cheery> (ywz -> wz(ywz))
07:47:19 <Heffalump> byorgey: right, yeah
07:51:10 <alpha_q> is there a smarter way to take the last n elements from a list than drop (length list - n) list
07:51:16 <Cheery> ok, so I get such silly combinator if I do SS, perhaps already knowing what I need to do though. :/ I need to mark the substituted stuff.
07:52:27 <gwern> 'Server load due to Wikpedia WebCiteBot We are migrating to a new server.'
07:52:29 <gwern> o.0
07:52:39 * gwern feels guilty http://twitter.com/eysenbach/status/2244531076
07:52:57 <Jedai> alpha_q: I think "reverse . take n . reverse" is probably better but I'm not sure
07:53:09 <alpha_q> it sounds way slower
07:53:14 <gwern> should - should I stop? should I email them and apologize? what's the proper etiquette in this sort of situation...
07:53:34 <maltem> alpha_q, if n is much smaller than the length of the list, then it's better
07:54:27 <maltem> laziness should pay off here a little
07:54:40 <Jedai> alpha_q: both are in O(L), so the question is on the precise complexity...
07:55:11 <Jedai> I think yours is in L + (L - n), while mine is in L + 2n
07:55:17 <alpha_q> well actuall I am experimenting with infinite lists and I am trying to define a fibonacci generator
07:55:29 <alpha_q> that doesn't work: fibs = 1:1:(sum (drop (length fibs - 2) fibs))
07:55:54 <Jedai> 2L - n against L + 2n, so it all depends on L/n
07:56:09 <sampointon> so, I'm going through the rite of passage of writing a scheme interpreter. What's the best way of mixing lisp application code with haskell system code?
07:56:49 <Jedai> alpha_q: by definition you can't find the last n elements from an infinite list
07:57:15 <sampointon> right now I'm keeping the scheme code in lists, formatting it nicely, and unwords-ing it together for evaluation
07:57:16 <alpha_q> yeah I figured that :)
07:57:28 <Jedai> alpha_q: there's a very classic infine list version of fibs, look at the zipWith function
07:57:33 <Jedai> :t zipWith
07:57:34 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
07:57:46 <maltem> Jedai, also consider memory behaviour. The length version needs the whole list to be in memory (yours shouldn't?)
07:57:50 <alpha_q> thanks
07:58:43 <Jedai> maltem: right, well I proposed my version because I think it's better but I fundamentally think lists aren't really the right structure if you're doing something like that often
07:59:08 <maltem> sure
07:59:10 <Axman6> hmm, trying to install the platform on FreeBSD, and it can't seem to find GL/gl.h in /usr/local/include
07:59:27 <Axman6> can't figure out how to tell it where it is either, LDFLAGS doesn't work
08:00:49 <Cheery> ggghhkk... damn. it's annoying when you notice yourself catching it..
08:00:53 <byorgey> Cheery: I'm not sure what you mean "mark the substituted stuff".  My guess is that your problems stem from handling de bruijn indices wrong.
08:00:59 <EvilTerran> > let fibs = scanl (+) 0 (1:fibs) in fibs
08:01:00 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
08:01:11 <byorgey> Cheery: substitution with de bruijn indices is quite tricky to get right.
08:01:27 <Cheery> byorgey: yeah, The Problem is that I use lambdas with n-arity
08:01:28 <maltem> Axman6, cabal has --extra-include-dirs, if that helps somehow
08:01:36 <Cheery> when I should actually use lambdas with 1-arity for this trick.
08:01:50 <EvilTerran> dB indices are a pain to do manually, regardless
08:01:51 <Axman6> not really, it's ./configure that's the problem
08:02:13 <byorgey> Cheery: yeah, I've never seen a version of the lambda calculus with explicit "arities"
08:02:17 <EvilTerran> ?go i am not a number i am a free variable
08:02:20 <lambdabot> http://www.e-pig.org/downloads/notanum.pdf
08:02:20 <lambdabot> Title: I am not a number: I am a free variable
08:02:33 <Axman6> EvilTerran: why? dB's are just 20log(|H(f)|) >_>
08:02:43 * Axman6 wonders if anyone got that
08:02:46 <EvilTerran> Cheery, ^ might be worth a look, if you're trying to represent lambda calc as an algebraic datatype
08:02:50 <byorgey> Axman6: heh
08:02:54 <EvilTerran> Axman6, (-.-). yes, i got that.
08:03:00 <Axman6> hooray
08:03:40 <Jedai> alpha_q: One of the problem your version shows is that you're not accustomed to recursion or at least data recursion
08:03:42 <byorgey> Cheery: you might also be interested in reading the first few chapters of "Types and Programming Languages" by Benjamin Pierce
08:03:45 <EvilTerran> Cheery, there's another idea too, the "calculus of indexed names and named indices", iirc, that abstracts away the deBrujin indices nicely
08:04:00 <EvilTerran> ?go cinni calculus names
08:04:01 <lambdabot> http://formal.cs.uiuc.edu/stehr/cinni_eng.html
08:04:01 <lambdabot> Title: CINNI - A Calculus of Indexed Names and Named Indices
08:04:05 <EvilTerran> ^
08:04:16 <skorpan> is there any haskell library for parsing unix-style configuration files?
08:04:22 <EvilTerran> although the main paper is _incredibly_ general
08:04:32 <skorpan> i.e. <setting>=<value> files
08:04:36 <maltem> let phi = (sqrt(5) + 1)/2; fib n = (phi**n - (-phi)**(-n))/sqrt(5) in map (round.fib) [1..]
08:04:37 <Axman6> is there such thing as a unix style config library?
08:04:45 <maltem> > let phi = (sqrt(5) + 1)/2; fib n = (phi**n - (-phi)**(-n))/sqrt(5) in map (round.fib) [1..]
08:04:47 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
08:05:04 <Axman6> argh!
08:05:20 <gwern> skorpan: sure
08:05:43 * Axman6 hates that definition, it's like assembly tricks in maths
08:05:47 <alpha_q> Jedai, yeah I've just started learning haskell today. As far as functional programming goes I do have some lisp and mathematica experience, but not that much actually
08:05:50 <gwern> skorpan: ConfigFile, for example. gitit uses that for unix-style configs
08:05:58 <skorpan> gwern: thanks, i'll check that out
08:05:59 <byorgey> > let phi = (sqrt(5) + 1)/2; fib n = (phi**n)/sqrt(5) in map (round.fib) [1..]
08:06:00 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
08:06:14 <byorgey> you don't even need the  - (-phi)**(-n) term =)
08:06:43 <alpha_q> byorgey how come this solution doesn't lose precision?
08:06:54 <byorgey> alpha_q: it will, eventually.
08:06:57 <alpha_q> ah ok
08:06:58 <alpha_q> :)
08:06:58 <sampointon> alpha_q: it does, just a very small amount
08:07:32 <maltem> oh indeed
08:07:34 <Jedai> alpha_q: so, the fact that you're trying to act on fibs as if it was finite and different at several point of the evaluation is typical, it isn't, it's always the same value at each point of the evaluation (conceptually at least and that's what's important for the conception)
08:07:46 <EvilTerran> > length . takeWhile id $ zipWith (==) (let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs) (let phi = (sqrt 5 + 1) / 2; fib n = phi**n / sqrt 5 in map (round.fib) [1..])
08:07:48 <lambdabot>   70
08:07:55 <skorpan> wouldn't it be nice if hackage would be able to take an optional changelog file when uploading packages, so that it could be displayed automagically in the HTML?
08:07:56 <int-e> > dropWhile (== 0) . zipWith (-) (let phi = (sqrt(5) + 1)/2; fib n = (phi**n)/sqrt(5) in map (round.fib) [1..]) (fix (scanl (+) 1 . (0:))
08:07:58 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
08:08:10 <EvilTerran> > drop 65 $ zip (let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs) (let phi = (sqrt 5 + 1) / 2; fib n = phi**n / sqrt 5 in map (round.fib) [1..])
08:08:12 <lambdabot>   [(27777890035288,27777890035288),(44945570212853,44945570212853),(727234602...
08:08:28 <EvilTerran> > drop 70 $ zip (let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs) (let phi = (sqrt 5 + 1) / 2; fib n = phi**n / sqrt 5 in map (round.fib) [1..])
08:08:29 <lambdabot>   [(308061521170129,308061521170130),(498454011879264,498454011879265),(80651...
08:08:40 <byorgey> heh, yup, off by one
08:08:58 <sampointon> hmm, that's odd. I'd expect the off-by-one to only affect one term, not two in a row
08:09:08 <sampointon> or is that floating point error?
08:09:10 <Jedai> alpha_q: like when you're trying to write a recursive function, the first thing to do is to assume it works for all value inferior to that of which you're trying to evaluate, with a recursive structure, you must assume it is already correctly defined and write it's definition using itself
08:09:35 <int-e> > first length . span (== 0) $ zipWith (-) (let phi = (sqrt(5) + 1)/2; fib n = (phi**n)/sqrt(5) in map (round.fib) [1..]) (fix (scanl (+) 1 . (0:)))
08:09:37 <lambdabot>   (70,[1,1,2,3,5,9,14,24,39,59,102,161,279,464,743,1207,2014,3157,5171,8584,1...
08:09:41 <byorgey> sampointon: it's floating point error.
08:09:53 <EvilTerran> > let xs = 1 : xs in xs -- = 1 : xs = 1 : (1 : xs) = 1 : 1 : (1 : xs) = ...
08:09:55 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
08:10:07 <Philonous1> Is there a reason why ($) (or (.)) is used instead of flip ($) (flip (.) respectively) ? I find functional composition much easier to read from left to right since I'm not speaking arabic
08:10:11 <alpha_q> Jedai thanks I'll try to keep that in mind
08:10:23 <byorgey> sampointon: why would you expect it not to affect two terms in a row?
08:10:23 <sampointon> byorgey: oh, that's alright then. So your approximation is accurate to about as far as we can trust a float :)
08:10:26 <EvilTerran> Philonous1, the mathematical convention of writing f(x)
08:10:32 <byorgey> sampointon: yes, exactly =)
08:10:49 <byorgey> sampointon: note that  (-phi)**(-n)  gets increasinly tiny as n increases.
08:10:52 <sampointon> byorgey: oh, the approximation was that phi^-n =~ 0
08:10:52 <hackagebot> pulse-simple 0.1.11 - binding to Simple API of pulseaudio (DaikiHanda)
08:10:52 <Philonous1> EvilTerran: Suprisingly many mathematicians don't seem to follow it
08:11:06 <byorgey> sampointon: right.  it starts out less than 1/2 and gets smaller from there =)
08:11:10 <EvilTerran> Philonous1, it'd make much more sense if that'd been written (x)f from the start, but it's a millenium or two too late to change the status quo
08:11:12 <sampointon> byorgey: so it'd be pretty unlikely for two terms to be in a row that would both round differently than that
08:12:10 <Jedai> alpha_q: it may seem a little mind-bending but it's really nice once you get it :) and in case you missed it, the traditional definition for fibs was given : "fibs = 1 : 1 : zipWith (+) fibs (tail fibs)"
08:12:11 <EvilTerran> Philonous, hm? i don't recall having seen many instances of people writing a function after its parameter, but i'll take your word for it :)
08:12:43 <maltem> Nothing is too late when you're designing a programming language :P
08:12:52 <Philonous> EvilTerran: I actually meant (f . g) x being g (f (x))
08:13:14 <kowey> anybody know what assumptions the Text.XML.Light parse functions make about character encodings?
08:13:23 <EvilTerran> Philonous, that looks hideously confusing to me
08:13:24 <Cheery> ok, now the horrors begin. I have to rewrite my visualizer to support the new style of lambdas I made.
08:13:24 <ski> that is often written `f ; g' .. at least in some CS neighbourhoods
08:13:37 <kowey> they take String as input, but I don't know if that means actual Unicode characters or padded bytes
08:13:44 <opqdonut> ski: ah, "f, then g"
08:13:58 <EvilTerran> maybe x (f . g) = (x f) g, with flipped application
08:14:03 <EvilTerran> and damn the status quo :P
08:14:30 <ski> if we have `f x', then we should really have `e <- x/', too ..
08:14:38 <alpha_q> Jedai yes it does seem mind bending... why doesn't "tail fibs" go into an endless recursion?
08:14:42 <alpha_q> :)
08:14:53 <sampointon> so, in summary: we should all be using a stack-based RPN language
08:15:04 <Jedai> alpha_q: we're in a lazy language, it evaluates only as much as it needs
08:15:11 <ski> alpha_q : it chases its own tail, but it's always one step ahead
08:15:20 <Philonous> alpha_q: because haskell is lazy. tail It only drops the head but doesn't evaluate the rest of the list
08:15:26 <maltem> sampointon, but one that allows for parentheses!
08:15:38 <EvilTerran> alpha_q, because you can work out that "tail fibs" is "1 : 1 : something" without needing to look at the zipWith
08:15:38 <maltem> otherwise it's no fun
08:15:51 <ski> sampointon : what does concatenative have to do with this ?
08:15:57 <EvilTerran> alpha_q, and that gives you enough information to work out the first item of "something", and so on
08:16:16 <Jedai> alpha_q: so for instance, if I ask for the 3rd element of fibs, zipWith (+) fibs (tail fibs) evaluates it's first element, and it can since we know the first element of fibs and tail fibs
08:16:17 <alpha_q> so the definition of tail is "drop the head" and not "give the last items"
08:16:30 <alpha_q> yeah I got it
08:16:34 <Philonous> alpha_q: Actually, scratch that. Haskell is in fact not lazy, only non-strict
08:16:40 <alpha_q> that's why my length based solution didn't work
08:16:41 * ski raises eyebrow ..
08:17:11 <Axman6> Philonous: why not lazy?
08:17:24 <Philonous> Axman6: Haskell doesn't memoize
08:17:37 <Axman6> fair enough'
08:17:37 <Jedai> alpha_q: your length based solution didn't work because it was gibberish (sorry), it wasn't even typed correctly
08:17:47 <EvilTerran> alpha_q, well, it's because you can remove the first item of a list in haskell without evaluating anything beyond it
08:17:50 <ski> (`(e <- x/) x = e' and `f x <- x/ = f' makes more sense than the usual formulations ..)
08:18:26 <EvilTerran> Philonous, Axman6: isn't it because "non-strict" is semantics and "lazy" is implementation?
08:18:37 <ski> "lazy" is *one* implementation
08:18:42 <EvilTerran> (and implementation is unspecified by the report)
08:19:20 <Philonous> EvilTerran: Haskell implementations are required to non-strict, not lazy, and ghc isn't lazy
08:19:20 <Jedai> Axman6: in fact Haskell do more memoization compared to a purely lazy evaluation
08:19:25 <Philonous> +be
08:20:28 <Jedai> Axman6: lazy evaluation IIRC don't keep the sharing that call-by-need evaluation (as in GHC) do
08:22:11 <skorpan> hm... join :: m (m a) -> m a, unsafePerformIO :: IO a -> a (i think)... is unsafePerformIO unsafe only because it's IO?
08:22:18 <Jedai> lazy evaluation or speculative evaluation would be correct for Haskell though, since as EvilTerran and Philonous said, the only requirement is non-strict
08:22:46 <Jedai> skorpan: join and unsafePerformIO don't have the same type
08:23:25 <alpha_q> Jedai well it would've worked if haskell worked like i thought it did :)
08:23:26 <Jedai> skorpan: join in the IO monad has type "IO (IO a) -> IO a" and is perfectly safe (though it has side effects)
08:23:52 <skorpan> i see... i thought the unsafe part was actually stripping of a "monadic layer"
08:23:55 <gwern> erik naggum is dead?
08:24:01 <skorpan> gwern: apparently according to reddit/twitter
08:24:04 <alpha_q> > let a = [1,1] in a ++ [(sum (drop (length a - 2) a))]
08:24:06 <lambdabot>   [1,1,2]
08:24:13 <alpha_q> see
08:24:14 <alpha_q> :)
08:24:32 <byorgey> skorpan: the unsafe part is stripping off the *last* monadic layer.
08:24:45 <byorgey> skorpan: but collapsing multiple layers into one is perfectly OK.
08:24:45 <gwern> so. I guess lisp is dying
08:24:48 <gwern> twitter confirums it
08:24:55 <ski> skorpan : `join' isn't stripping off any monadic layers .. it is *merging* two of them
08:24:59 <skorpan> byorgey: ah, so if we had join :: Monad m => m a -> a, that would still be unsafe?
08:25:25 <Jedai> alpha_q: your solution lacked the [] around the sum though (and of course it would have died since it couldn't have evaluated the sum without having evaluated it before... but I see what you mean
08:25:26 <ski> it would be bad, anyway
08:25:28 <Axman6> > join [[1..10],[1,2,4,2242341]]
08:25:29 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,1,2,4,2242341]
08:25:37 <byorgey> skorpan: well, that wouldn't be called join, but basically, yes. only some monads support such an operation, and it is often unsafe.
08:25:39 <sampointon> skorpan: very, it'd be like unsafePerformIO, unsafeSTMToIO, and unsafeKillKittens all in one
08:25:45 <Axman6> > join ([1..10]++[1,2,4,2242341])
08:25:47 <lambdabot>   No instance for (GHC.Enum.Enum [a])
08:25:47 <lambdabot>    arising from the arithmetic sequence...
08:25:48 <byorgey> skorpan: e.g.  head :: [a] -> a,  or fromJust :: Maybe a -> a
08:25:50 <BONUS> comonads however have m a -> a
08:26:01 <byorgey> those are both unsafe, just like unsafePerformIO :: IO a -> a
08:26:04 <skorpan> byorgey: that's a nice parallel
08:26:10 <skorpan> i never thought of it that way
08:26:24 <sampointon> skorpan: yeah, me neither. It's a good one
08:26:27 <sampointon> byorgey++
08:26:34 <skorpan> byorgey++
08:26:40 <Philonous> BONUS: But they don't have return
08:26:42 <Cheery> ooh
08:26:57 <Cheery> normal order evaluation strategy made it out well. :)
08:27:01 <ski> well, `head' and `fromJust' doesn't destroy the reasoning
08:27:22 <BONUS> yeah true
08:27:56 <Cheery> guessing I'd need lambda parsing now though. :/
08:28:28 <Cheery> writing those by hand will be terrible
08:28:47 <Cheery> but then, I have a composition tool right in my hand, so I should't need parser.. yet
08:28:50 <byorgey> yeah, head and fromJust aren't unsafe in the same way that unsafePerformIO is unsafe.
08:29:06 <EvilTerran> they're just partial
08:29:33 <Baughn> unsafePerformIO still shouldn't crash the program, any more than crazy non-uPIO IO code would
08:29:46 <Baughn> ..unless you use it to implement unsafeCoerce, granted
08:30:00 <ski> ..was just about to say that, yes :)
08:30:06 * EvilTerran too
08:30:18 <EvilTerran> ?djinn Maybe (Maybe a) -> Maybe a
08:30:19 <lambdabot> f a =
08:30:19 <lambdabot>     case a of
08:30:19 <lambdabot>     Nothing -> Nothing
08:30:19 <lambdabot>     Just b -> b
08:31:27 <Baughn> No join?
08:32:00 <Cheery> de bruijn notation roxors
08:32:20 <Cheery> at least for this purpose. :)
08:32:23 <mattam> Wait for the bug :)
08:32:42 <byorgey> mattam: I already tried to warn Cheery =)
08:33:16 <SamB> Axman6: hmm?
08:33:21 * mattam was just lifting a substitution 
08:33:27 <byorgey> but I guess everyone should try implementing de Bruijn indices once in their life.
08:33:46 <Axman6> SamB: dw, i was looking for someone else, nd managed to solve my problem
08:33:46 <mattam> Yeah, it's neat.
08:34:06 <Axman6> now if only i could get editline to work on freebsd
08:34:17 <Cheery> byorgey: is that a variation of sentence "everyone must die once in their life."?
08:34:29 <Jedai> Axman6: why do you need editline ?
08:34:38 * EvilTerran liked the way "I Am Not A Number, I Am A Free Variable" managed to hide most of the complexity of deBrujin indices
08:35:04 <Jedai> Axman6: it doesn't seem to be a very interesting library (it doesn't even understand Unicode, no ?)
08:35:11 <Axman6> Jedai: i'm trying to install the haskell platform, but it can't seem to find editline, even when using --extra-*-dirs
08:35:50 <byorgey> EvilTerran: yeah, locally nameless is great.  when I say 'de Bruijn indices' I mean 'using de Bruijn indices for free as well as bound vars'
08:35:55 <byorgey> Cheery: perhaps =)
08:35:57 <Jedai> Axman6: I though the latest version of the platform contained editline ?
08:36:06 <Axman6> it does
08:36:08 <Cheery> byorgey: comfy
08:36:19 <Axman6> but it won't compile, it can't find the C editline stuff
08:36:20 <EvilTerran> byorgey, yeah, that's asking for trouble
08:36:45 <skorpan> ConfigFile has awesome documentation... feels weird.
08:37:08 <Cheery> can someone give me a lambda unicode quick?
08:37:26 <skorpan> λ
08:37:30 <skorpan> Λ
08:37:34 <Axman6> dayum, that was quick
08:37:41 <skorpan> C-\ emacs win
08:38:00 <RyanT5000> suppose i have a program that's written without internationalization in mind, and i want to internationalize it; is there a good way of doing that refactor, assuming i want the ability to switch languages at run-time, and I don't want to do anything not-referentially-transparent?
08:38:11 <Axman6> sadly lambda isn't one of the default unicode characters on OS X
08:38:28 <skorpan> what do you mean?
08:38:55 <Axman6> well, i have things like œ∑´®†\¨ˆøπ“åß∂ƒ©˙∆˚¬…Ω≈ç√∫˜µ≤≥¡™£¢∞¶•ªº–
08:39:06 <Axman6> when i hold down option 9alt)
08:39:07 <Axman6> (*
08:39:24 <RyanT5000> maybe something involving typeclasses?
08:39:30 <sampointon> RyanT5000: all the i18n-needing strings are in the UI and such, right? Which is impure anyway, so I don't think you'd lose much by just keeping, say, the language in an IORef and checking that every time you redraw
08:39:40 <skorpan> oh, but C-\ sets a different input mode in emacs, it has nothing to do with my OS
08:39:45 <Jedai> RyanT5000: That doesn't seems very nice except if all the international strings are already in IO
08:40:03 <skorpan> ㅏ갣ㅁ
08:40:12 <skorpan> ..that was me trying the korean-hangul input mode
08:40:25 <SamB> the middle one doesn't render here at all
08:40:33 <skorpan> not here either
08:40:37 <skorpan> i messed up
08:40:39 <SamB> and the outer two look butt ugly anti-aliased
08:40:45 <skorpan> i tried writing "korea"
08:40:53 <RyanT5000> sampointon: yeah, that would work, but i'd rather not constrain myself to something being in IO; i'm actually looking into declarative rendering (e.g.: conal's 'fieldtrip' package)
08:41:09 <skorpan> "name: HANGUL SYLLABLE GAED"
08:41:31 <Cheery> damn mockingbird is still nasty since it doesn't do anything convoluted that'd look like cool.
08:41:44 <Cheery> it just simply jams. :)
08:41:51 <Jedai> RyanT5000: I think you should forget the referencial transparency if you want to be able to switch the language anytime
08:42:07 <RyanT5000> Jedai: how come?
08:42:39 <SamB> Cheery: remind me what combinator the mockingbird is ?
08:42:42 <Jedai> RyanT5000: or you'll have to have a value to indicate the current locale everywhere you manipulate strings
08:42:46 <Cheery> (x -> xx)
08:42:48 <RyanT5000> well, let me put it another way: what if it were a server, and it had to serve people in different languages simulataneously
08:42:54 <sampointon> RyanT5000: I think so long as you don't string-ify things until you strictly need to (does it need to be displayed RIGHT NOW?), you should be fine. The internal code can pass around ADTs happily, and only the things on the edges will ever need to see the state
08:43:01 <RyanT5000> Jedai: well, i'm interested in the problem of avoiding that :)
08:43:28 <mattam> Axman6: you know you can have it still. Ukelele lets you have the map you want.
08:43:38 <sampointon> RyanT5000: never worked with fieldtrip, so I can't help you there, but unless it has some way to keep state handy I can't see a convenient way to do it
08:43:49 <Axman6> yeah, but meh, i don't need lambdas that badly ;)
08:43:49 <RyanT5000> sampointon: yeah, that's one possible solution, i guess: replace every instance of "String" with "ThingIWantToSayToTheUser"
08:43:51 <Cheery> hm. SS shows that there is something very badly wrong in my algorithm.
08:43:57 <RyanT5000> and then have a thing that renders that down to english
08:44:02 <Jedai> RyanT5000: well look into what sampointon said, instead of passing strings around, pass identifier and only the renderer is aware of the local it need to display something
08:44:15 <mattam> Ah. I use it all the time, that and Π
08:44:55 <Jedai> RyanT5000: That seems to jibe not too badly with your server scenario
08:45:09 <RyanT5000> yeah
08:45:17 <sampointon> RyanT5000: might even make it easier to extend, you've got a handy messaging API then. Extensions won't have to parse strings to get at data
08:45:49 <Cheery> IC. there's one thing very badly wrong in substitution
08:45:50 <RyanT5000> sampointon: yeah
08:46:04 <RyanT5000> i wonder about the difficulty of creating a substitute for natural language
08:46:23 <RyanT5000> but obviously it would be a *very*-application-specific subset of English or whatever
08:47:01 <sampointon> RyanT5000: what do you mean? Like, pass a tree of X-bar data around?
08:48:07 <Cheery> RyanT5000: I'd hope just that english becomes universal language during this century.
08:48:22 <RyanT5000> sampointon: assuming you mean http://en.wikipedia.org/wiki/X-bar_theory , no. i meant more like having a common "phrasebook" interface, with renderers that produce various languages
08:48:24 <Cheery> (the flattened and understandable form)
08:48:33 <Jedai> Cheery: I think Chinese is more likely to do so ... ;)
08:48:52 <sampointon> RyanT5000: I doubt that will work. Natural languages are very very irregular in weird ways
08:48:53 <RyanT5000> Jedai: more likely, Indian English ;)
08:49:16 <sampointon> Cheery: that'd make life boring though :)
08:49:34 <Cheery> sampointon: because everyone would understand you? :P
08:49:37 <RyanT5000> sampointon: well, what if it's all parameterized; e.g.: "You have ____ bombs" becomes youHaveXBombs :: Int -> Utterance
08:50:01 <sampointon> RyanT5000: oh, that's very plausible. Much less general than what I was thinking of
08:50:21 <RyanT5000> sampointon: yeah, i don't want to get caught doing NLP research here :P
08:50:46 <RyanT5000> sampointon: although i did very much enjoy the class i took in it, it doesn't seem ready to be a part of something that makes money
08:50:52 <RyanT5000> (except for very languagey things)
08:51:16 <RyanT5000> (so, not just the task of internationalizing a video game or something)
08:51:30 <lpsmith> what's the default heap size?  32M?
08:52:18 <RyanT5000> lpsmith: do you mean initial or maximum? i know the default maximum is unlimited
08:53:33 <lpsmith> RyanT5000,   right,  yeah,  I guess that question didn't make much sense.  I just read that in the User's Guide
08:53:38 <Apocalisp> what's a good pedagogical example of an Applicative that's not a Monad?
08:56:19 <Philippa> Apocalisp: self-analysing parser
08:56:51 <Philippa> it can't be a monad because then you'd not have the grammar structure fixed at compile-time - it'd be input-dependent
08:56:58 <Philippa> and then you can't do analyses
08:57:05 <Philippa> also: zipping
08:57:34 <Apocalisp> ZipList?
08:57:36 <Philippa> (read the original papers on applicatives? The parser's cute as an engineering example of why you might want that with something that /could/ be a monad)
08:57:37 <Philippa> yeah
08:57:44 <Apocalisp> oh, yeah, that's a good one
08:58:03 <Apocalisp> ta very much
09:05:39 <Cheery> oh man. le bruijn again kicked me to groin
09:06:01 <Botje> the easy fix is to label your groin as (-1) :)
09:06:28 <Cheery> well, I guess I'm not yet at that point.
09:07:08 <Cheery> my stuff breaks when lambdas are getting evaluated from middle.
09:07:23 <byorgey> @remember Botje <Cheery> oh man. de bruijn again kicked me to groin  <Botje> the easy fix is to label your groin as (-1) :)
09:07:23 <Cheery> [(λ(λ(λ[2, 0, [1, 0]]))), (λ(λ(λ[2, 0, [1, 0]])))]
09:07:23 <lambdabot> I will never forget.
09:07:46 <b_jonas> is there a library function that slices a list to non-overlapping chunks of fixed size?
09:08:17 <Botje> b_jonas: Data.Split has some functions for that
09:08:18 <byorgey> b_jonas: you can use 'splitEvery' from the 'split' package on Hackage
09:08:19 <Cheery> lambdabot is somewhat rude pal.
09:08:21 <mauke> { @ @ } { @ @ }
09:08:26 <Cheery> (λ(λ[(λ(λ(λ[2, 0, [1, 0]]))), 0, [1, 0]]))
09:08:34 <Cheery> (λ(λ[(λ(λ[3, 0, [1, 0]])), [1, 0]]))
09:08:36 <mauke> ^ code in a language I almost invented
09:08:40 <b_jonas> thanks
09:08:48 <Cheery> anyway, there it happens.
09:08:57 <mauke> the { } are functions, @ is the argument (counted in unary)
09:09:30 <Cheery> or hm.. not yet there
09:09:33 <Cheery> that's correct
09:09:34 <b_jonas> byorgey: where's splitEvery?
09:09:37 <b_jonas> I can't find it in hackage
09:09:39 <b_jonas> I can find split
09:09:55 <byorgey> b_jonas: no, 'splitEvery' is a function in the 'split' package
09:10:27 <Cheery> or no, it isn't
09:11:23 <Cheery> (λ(λ[(λ(λ[2, 0, [1, 0]])), [1, 0]]))
09:11:26 <Cheery> (λ(λ[(λ[2, 0, [[1, 0], 0]])]))
09:11:43 <Cheery> ok, now that thing messes up.
09:12:38 <Cheery> since there's dropping a lambda from middle, the '2' should turn to '1'
09:13:40 <Cheery> still doesn't seem like perfectly correct though.
09:13:58 <Cheery> I see I have to do something for value substitutions.
09:15:19 <Cheery> I have to 'cut'
09:15:24 <shapr> Rumor has it that Erik Naggum has left this world.
09:16:27 <b_jonas> byorgey: oh, thanks
09:16:32 <mauke> <@avar> Erik Naggum dies; Position of Perl Hater #1 free
09:18:16 <b_jonas> I'll want to write a function like that and there are too many word I can use to name it.
09:18:40 <b_jonas> slice, chunk, shape, and stuff
09:21:41 <Cheery> now it looks like okay, but yet I need to handle a lambda.
09:21:57 <shapr> mauke: /whois nocebo for the last time!
09:22:21 <Cheery> Botje: now I understood what you just said.
09:23:04 <ClaudiusMaximus> > pred (1.0 :: Float) -- how might i find the largest representable Float less than 1.0, given that the Enum instance is broken
09:23:06 <lambdabot>   0.0
09:24:40 <Apocalisp> Hmm, there's a biimplication between List and ZipList
09:25:01 <b_jonas> biwhat?
09:25:09 <Baughn> ClaudiusMaximus: Alternative a: Subtract increasingly small values from 1.0, until == claims they're now the same one.
09:25:32 <Apocalisp> List implies ZipList, ZipList implies List
09:25:38 <Baughn> ClaudiusMaximus: Alternative b: implement an IEEE floating-point library, use that to find it directly
09:26:56 <RyanT5000> ClaudiusMaximus: is this something you need to solve once, or something you need to solve in general?
09:27:03 <Apocalisp> (IO . Maybe) is a good example of an applicative functor that isn't a monad
09:27:21 <Baughn> Apocalisp: What's . in type notation?
09:27:22 <ClaudiusMaximus> RyanT5000: well, i'm just curious really
09:27:33 <ClaudiusMaximus> RyanT5000: but i imagine someone might need to solve it in general
09:27:38 <Baughn> Maybe (IO a)?
09:27:56 <Apocalisp> Baugh: Yes, that's what I mean.
09:28:11 <RyanT5000> ClaudiusMaximus: http://grouper.ieee.org/groups/754/ -- i have a feeling this is your best bet
09:28:19 <Cheery> now I enjoy from my nearly correct normal-order-evaluator
09:28:26 <Apocalisp> How about comonads that aren't monads?
09:28:33 <Baughn> Apocalisp: I don't know. You say it's an applicative functor; to make it a monad, that only requires join :: Maybe (IO (Maybe (IO a))) to have a sane implementation
09:28:55 <Baughn> Apocalisp: So you just have to use unsafePerformIO.. ^_^
09:29:23 <roconnor> IO (Maybe a) -> Maybe (IO a) is a useful start
09:29:44 <Baughn> Sure, but you can't actually get all the way without uPIIO
09:30:16 <Cheery> http://paste.pocoo.org/show/124193 is this evil or not?
09:30:17 <Baughn> You need to run that outer layer of IO somehow, and you can't, since join here isn't in IO
09:30:42 <Apocalisp> Baughn: Boo!
09:30:45 <Apocalisp> Hiss!
09:30:48 <mauke> Cheery: yes, it's python
09:30:48 <roconnor> Cheery: looks evil.  It isn't haskell
09:30:52 <Baughn> Cheery: An interpreter interpreting code? Why would that be evil?
09:31:21 <Baughn> Cheery: ..boo. Hiss. It's this sort of code that drives the evolution of CPUs. ^^;
09:31:59 <roconnor> Cheery: I take it back, the code seems to be more or less purely functional.
09:32:00 <Cheery> so it's evil if you ask from intel?
09:32:11 <Jedai> ClaudiusMaximus: let predFloat f = flip subtract f . (2^) . until (\n -> f - 2^(n-1) == f) (subtract 1) $ 10
09:32:20 <roconnor> Cheery: but it needs more types
09:32:48 <Baughn> Cheery: I'm sure Intel would agree that it's good
09:33:00 <Jedai> ClaudiusMaximus: let predFloat f = flip subtract f . (2**) . until (\n -> f - 2**(n-1) == f) (subtract 1) $ 10
09:33:25 <Cheery> roconnor: I guess this piece would convert easily to haskell if I'd bother with it.
09:33:59 <sampointon> Cheery: idiomatic python would be turning all those isinstances to dispatching on class methods
09:34:56 <roconnor> > decodeFloat 1.0
09:34:57 <lambdabot>   (4503599627370496,-52)
09:35:01 <sampointon> Cheery: this way seems closer to Haskell though, it's just tagged vs untagged unions
09:35:19 <Cheery> sampointon: It's true idiotic python would be turning all those isinstances to class method dispatching.
09:35:22 <roconnor> > uncurry encodeFloat . (pred *** id) . decodeFloat $ 1.0
09:35:23 <lambdabot>   0.9999999999999998
09:35:32 <roconnor> ClaudiusMaximus: ^^
09:35:53 <sampointon> Cheery: it looks like Haskell written in Python, to be honest :)
09:35:56 <roconnor> ClaudiusMaximus: actually, sorry, that probably isn't right
09:36:19 <roconnor> ClaudiusMaximus: well, maybe it is.
09:36:20 <roconnor> hmm
09:36:28 <Cheery> sampointon: if you check out, there's a general case, then there's cases for lists and integers.
09:36:36 <lament> idiotic python? :)
09:36:49 <Jedai> :t decodeFloat
09:36:50 <roconnor> > showHex 4503599627370496 []
09:36:51 <lambdabot> forall a. (RealFloat a) => a -> (Integer, Int)
09:36:51 <lambdabot>   "10000000000000"
09:37:14 <Cheery> that means I'd need to introduce two types more on it to handle this all
09:37:15 <andrei> Why does, 'show 3' work? Should it be an ambiguous type variable?
09:37:16 <burp> is there a data type like IntMap that always keeps it's index keys continuous after removal of an entry?
09:37:25 <Cheery> and as a result, it'd spread all over my source code.
09:37:28 <burp> Like a have a map with keys from 1 to 100
09:37:31 <b_jonas> burp: a Seq
09:37:42 <b_jonas> burp: in Data.Sequenc
09:37:43 <b_jonas> e
09:37:51 <burp> can I easily remove items in Seq?
09:37:54 <mike-burns> Cheery: I have to know, since this is clearly Haskell in Python: why did you write this in Python?
09:37:58 <roconnor> > uncurry encodeFloat . (pred . (2*) *** pred) . decodeFloat $ 1.0
09:38:00 <lambdabot>   0.9999999999999999
09:38:14 <roconnor> ClaudiusMaximus: I think the above is right.
09:38:30 <roconnor> Although not yet robust for all implementations of Float.
09:38:31 <burp> b_jonas, I already had a look at Seq
09:38:37 <sampointon> Cheery: oh, also, is this on python 3.0 or 2.x?
09:38:42 <burp> but it didn't seem to offer easy removal of single items
09:38:46 <ClaudiusMaximus> roconnor: interesting
09:38:49 <Cheery> sampointon: python 2.5
09:39:19 <sampointon> Cheery: oh, k. If it was on 3.0, I was going to suggest using extended unpacking to make normal_order_eval_step simpler
09:39:25 <b_jonas> burp: there's no builtin function for that, sure, but it can remove an item in log size time if you split and concat
09:39:32 <Cheery> mike-burns: because it feeled the right way to do it. I may end up to replacing lists or integers with my own datatype, but probably not right now.
09:39:38 <Cheery> sampointon: extended unpacking?
09:39:54 <burp> b_jonas, hm, ok
09:40:08 <sampointon> Cheery: a kind of pattern-matching, basically
09:41:09 <Cheery> mike-burns: the reason why I am doing this in python and not haskell, is that I still prefer python for rest of my code.
09:41:23 <roconnor> > let foo x = uncurry encodeFloat . (pred . (floatRadix x *) *** pred) . decodeFloat $ x in foo 1.0
09:41:24 <lambdabot>   0.9999999999999999
09:41:39 <mike-burns> Cheery: It just seems odd to use Python this way when method dispatch is built into the language.
09:42:21 <roconnor> writing a proper implementation is kinda a pain
09:43:44 <Cheery> mike-burns: it may be I end up doing it through dispatching later.
09:44:30 <Cheery> because that may help me doing the visualization easier.
09:44:44 <lament> Cheery: that is indeed very evil code
09:45:38 <Cheery> lament: it was hell to get working correctly. basicly just trial and error.
09:45:46 <lament> no wonder. It's ugly.
09:46:10 <lament> it does look like haskell, though.
09:46:35 <mike-burns> Well it does contain the word `return'.
09:46:39 <Cheery> connecting it to my lambda balls to visualize the structures is probably going to force me rewriting it a bit different.
09:47:02 <byorgey> Cheery: if you translated that to Haskell it would be about ten lines long.
09:47:32 <lament> Cheery: just because python has isinstance and adhoc polymorphism, doesn't mean you should use them.
09:47:32 <byorgey> Cheery: in particular, all the  'if isinstance(value,foo) ... elif isinstance ... ' stuff would just be pattern matching.
09:47:34 <mike-burns> If you translated it to Haskell you probably wouldn't stick everything in a list.
09:47:46 <lament> byorgey: that's because it's Haskell written in Python
09:47:55 <byorgey> hehe
09:48:07 <lament> if you translated it to Python, it would also be about ten lines long :)
09:48:12 <mike-burns> Hah.
09:48:40 <Cheery> ok ok
09:48:48 <Cheery> I do it through dispatching now. :)
09:51:50 <burp> b_jonas, thanks "let srm i seq = ( Data.Sequence.take (i) seq ) >< ( Data.Sequence.drop (i+1) seq )" seems to do it
09:58:10 <skorpan> hm, it seems that ConfigFile doesn't work nicely with monads-fd, but *needs* mtl... is there any specific reason to this?
10:00:36 <mpwd> Monads are hard to implement in OCaml
10:00:56 <mpwd> Is there such a thing as an ML with typeclasses, or is this just a fantasy?
10:01:48 <Vq^> doesn't F# have something like that?
10:02:43 <mike-burns> A quick Web search indicates that lots of people have implemented monads in ocaml.
10:03:07 <mike-burns> I don't know ocaml too well; what makes it tricky?
10:03:29 <mpwd> I'm used to do notation and type classes
10:03:35 <mike-burns> Ah.
10:04:19 <mpwd> So if you want to do do notation, you have to define bind and translate the notation by hand
10:04:36 <mike-burns> Yeah, I ran into that when I did monads in Ruby.
10:05:43 <mpwd> It's a bit of a shame.  I'm working on formal proof this summer.  These OCaml hackers that invented HOL-Light just invent and reinvent monads over and over again
10:05:48 <ski> istr seeing some kind of `do'-notation being defined by Camlp4 .. but i've forgotten where
10:06:38 <Cheery> http://paste.pocoo.org/show/124202 ok, here's the dispatch version.
10:06:53 <mpwd> it's okay
10:07:31 <ski> mpwd : you might try asking in #ocaml (if you haven't already done so)
10:07:42 <mpwd> I'll just write less elegant ocaml code...
10:08:54 <Cheery> I think it's not easier to understand, introduces two types more, and looks somewhat.. dumb.
10:09:00 <Alpounet> mpwd, there is a start of monadic stuffs in OCaml Batteries Included (I'vre written them myself)
10:09:27 <mike-burns> Cheery: That's all very subjective (except for the two types thing).
10:09:31 <Cheery> you can't believe how horrible such lists are that aren't lists really.
10:09:51 <b_jonas> what? lists aren't lists?
10:10:03 <Cheery> class Call(list):
10:10:06 <mike-burns> Cheery: I would have replaced the list with a new class with custom behavior on it.
10:11:32 <skorpan> could someone help me out here? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6077#a6077
10:11:41 <skorpan> i'm using the ConfigFile package: http://hackage.haskell.org/packages/archive/ConfigFile/1.0.5/doc/html/Data-ConfigFile.html#v%3Aget
10:11:51 <skorpan> (i.e. get has nothing to do with the State monad)
10:13:20 <mike-burns> Isn't the type for `readPatterns' incorrect? It looks like it takes an argument, but the type is just IO ().
10:13:35 <skorpan> sorry about that, never mind the type
10:13:37 <Cheery> mike-burns: hmm.. list could indeed have slightly different behavior I guess, but in the end this thing expands, and even worse, the classes start containing lots of specific things that I don't care about elsewhere.
10:13:41 <byorgey> skorpan: it probably can't infer the right type for useFile since you never use it
10:13:54 <skorpan> byorgey: yeah, that sounds right...
10:14:38 <byorgey> skorpan: assuming you're going to replace 'return "hello"' with something more useful it may not actually be a problem.
10:14:40 <skorpan> yes, that was it :) thanks
10:14:46 <byorgey> sure =)
10:14:52 <skorpan> i just putStrLn making it understand it's a string
10:15:00 <skorpan> in this particular case it's a bool, but that's a later problem
10:16:06 <Cheery> mike-burns: just plain translation to object dispatching doesn't help my code a lot.
10:16:16 <mike-burns> Cheery: This isn't the channel for me to convince you to embrace OO, but if you're doing Python it makes sense to use OO.
10:17:19 <mike-burns> If I had to maintain your Python code I'd want it to be OO. Since you're maintaining it, it makes sense to write it however is easiest.
10:17:22 <Cheery> rewriting this kind of very specific piece in OO is just like jumping from mud to quicksand.
10:17:51 <monochrom> I don't like OO. I like IO.
10:17:59 <lament> code should be idiomatic, because idioms are idiomatic for a reason :)
10:18:08 <Cheery> I were first reading "I don't like OO. I like OO.
10:18:16 <mike-burns> lament: That's my feelings too.
10:18:54 <monochrom> "Turning IO Inside Outside" may be a fun title for a paper :)
10:19:09 <lament> python strongly discourages mixing types in lists, and using isinstance
10:20:11 <monochrom> People should learn to think outside the idioms.
10:21:24 <Cheery> anyway, I think my code very well expresses properties of whatever it is.
10:21:27 <lament> straight from the horse's mouth!
10:21:59 <Cheery> it's weirdo piece that looks like shabby.
10:22:39 <Cheery> also it's messed up just like my head is messed up right now, therefore there's synchronisation.
10:23:03 <Cheery> and I guess it's going to remain that way when I look at it, because it evaluates lambda calculus.
10:25:50 <tornvig> hey.. what does "!!" mean?
10:26:25 <stepnem> > [1,2,3] !! 1
10:26:27 <lambdabot>   2
10:26:27 <steveklabnik> tornvig: accesses a certain element of a list
10:26:27 <skorpan> :t (!!)
10:26:29 <lambdabot> forall a. [a] -> Int -> a
10:26:42 <tornvig> ah ok
10:26:43 <skorpan> in C: hello[3]
10:26:43 <skorpan> in Haskell: hello !! 3
10:26:44 <tornvig> thanks
10:28:30 <Botje> !! is not O(1), though
10:28:39 <Cheery> it's weird you guys need to yell in your code.
10:28:57 <Botje> yelling makes everything better.
10:28:58 <roconnor> !! is a sign of bad code
10:29:18 <Cheery> roconnor: ic, how does it connect to bad code?
10:29:29 <Cheery> I'd see it's more like a sign of inefficient code.
10:29:40 <roconnor> indexing lists with numbers is usually bad
10:29:51 <mike-burns> It's another idomatic thing.
10:29:53 <roconnor> folding and mapping is good
10:29:58 <Cheery> but inefficient code isn't evil.
10:30:21 <roconnor> !! is also inefficient, but that is a different issue
10:31:00 <Cheery> but !! is sometimes what you need, otherwise you wouldn't have such thing
10:31:09 <Cheery> so I find weird that you have a symbol for it.
10:31:27 <skorpan> why is it weird?
10:31:40 <mike-burns> It's a sign of bad code, not an automatic flag. Sometimes it has its use.
10:31:48 <Cheery> if something you use is rare, it usually has a longer name.
10:32:13 <skorpan> usually?
10:32:16 <mauke> it's longer than ! :-)
10:32:19 <ziman> like, unsafePerformIO :)
10:32:39 <Cheery> yeah.. like unsafePerformIO
10:32:47 <skorpan> i always unsafePerformIO
10:32:51 <skorpan> living on the edge baby
10:33:23 <Cheery> from some reason that function is named disturbingly
10:33:35 <Cheery> (from some reason I feel that way)
10:33:40 <Botje> unsafePerformIO is called ' ' in other languages
10:34:00 <Botje> is that less scary? :)
10:34:09 <skorpan> i would call it "fromIO"
10:34:23 <skorpan> but i guess it's important to discourage newcomers from using it
10:34:27 <copumpkin> Botje: not quite that easy though :P
10:34:33 <Botje> it's named like that because you're not supposed to use it
10:34:56 <ellisbben> ... unless you like undefined semantics
10:35:07 <skorpan> it's way too common on haskell-cafe that people ask "how do i convert IO Int to Int?"
10:35:08 <Cheery> "noCondom IN  OUT   IN   OUT"
10:35:23 <skorpan> or maybe not too common, since then people have a chance to tell them not to use it
10:35:32 <roconnor> I think that functions like head and (!!) are used during the transition from Scheme-like languages to full on Haskell
10:36:44 <idnar> roconnor: isn't stuff like (iterate f x !! n) a common idiom, though?
10:36:51 <Cheery> I guess I should have used unsafePerformIO more often when I were doing haskell.
10:37:01 <Phillemann> Isn't there a syntax for modifying one field of a record?
10:37:04 <b_jonas> Cheery: why?
10:37:18 <skorpan> Phillemann: yes there is
10:37:19 <ziman> Phillemann, x' = x { field = newValue }
10:37:28 <skorpan> Phillemann: the record "keys" are in fact functions
10:37:44 <Phillemann> Ah, the "before state" goes before the {}.
10:37:47 <skorpan> oh, i thought the other way around
10:37:55 <skorpan> never mind me
10:38:02 <Phillemann> ziman: Thanks then :)
10:38:12 <ziman> yw :)
10:38:15 <idnar> skorpan: well, you do get x' = x { field = transform (field x) }
10:38:19 <Cheery> b_jonas: because I used to have times when I wouldn't have cared less whether it is pure or safe functional code.
10:38:21 <roconnor> idnar: I still think that is a slight sign of bad code, although !! is far less bad on streams than on finite lists.
10:38:26 <skorpan> :t transform
10:38:28 <lambdabot> Not in scope: `transform'
10:38:31 <idnar> roconnor: what alternative would you suggest?
10:38:50 <b_jonas> Cheery: but in that case doesn't it make more sense to use a non-pure language?
10:38:54 <roconnor> idnar: I'd need more surrounding context to see how to eliminate the integer.
10:39:07 <b_jonas> a strict one so you can tell easily what's evaluated
10:39:26 <monochrom> It is a sign of translating from a bad language word for word.
10:39:33 <idnar> roconnor: mmm, bleh, I can't actually recall the specific f the last time I saw that used
10:39:58 <Cheery> b_jonas: depends so much. neither with python I'm sometimes not bothered by what is getting evaluated when.
10:40:22 <b_jonas> not _when_ but _at all_
10:40:23 <roconnor> idnar: your example isn't so bad, only slightly bad.
10:40:24 <ellisbben> idnar: I don't think there's anything wrong with iterate f x !! n
10:40:41 <roconnor> idnar: when !! is used on finite list, a much bigger flag is raised.
10:40:48 <b_jonas> why?
10:40:50 <Cheery> b_jonas: no, both.
10:40:53 <b_jonas> why's it worse on a finite list?
10:40:54 <ellisbben> idnar: but it's slicker if you write it as function exponentiation, because that's what it is.
10:40:57 <Cheery> when or at all.
10:41:11 <idnar> ellisbben: how do you write that in Haskell?
10:41:14 <roconnor> b_jonas: because it might error
10:41:30 <monochrom> I guess no one bothered to add function exponentiation to the Prelude.
10:41:32 <b_jonas> > [1..] !! -2
10:41:34 <lambdabot>   Precedence parsing error
10:41:34 <lambdabot>      cannot mix `GHC.List.!!' [infixl 9] and prefi...
10:41:39 <ellisbben> idnar: I'm kinda joking... I'd write function exponentiation in terms of _it_
10:41:39 <b_jonas> > [1..] !! (-2)
10:41:40 <lambdabot>   * Exception: Prelude.(!!): negative index
10:41:54 <Cheery> ok.. guessing it's going to be time to fix that lambdaball.
10:41:56 <roconnor> b_jonas: yes we all want a natural number type.
10:42:09 <ellisbben> idnar: let (f $^$ n) x = iterate f x !! n
10:42:14 <b_jonas> roconnor: and then (-) can err
10:42:17 <b_jonas> roconnor: not much better
10:42:34 <ellisbben> so f $^$ n = f.f.f. (...)
10:42:34 <roconnor> b_jonas: actually this is exactly why !! for even infinite lists is an indication of bad style.
10:42:40 <idnar> ellisbben: that operator is pretty ugly, but it would be nice if that were in Data.Function or the prelude or something
10:43:14 <roconnor> b_jonas: integers should be avoided for indexing
10:44:29 <idnar> roconnor: okay, what about something like primes !! 42?
10:44:40 <roconnor> idnar: for (iterate f x !! n), usually the n comes for the length of something.  Better to somehow zip the structures together, or some such association.
10:45:00 <monochrom> I don't understand why integers should be avoided for indexing. Perhaps I don't understand what it means either.
10:45:25 <roconnor> idnar: now you are using !! and an unnamed constant. :)
10:45:43 <idnar> roconnor: well, I'm looking at project euler code now :P
10:45:51 <Twey> :t let f $^$ 0 = f; f $^$ n | n < 0 = error "fail" | otherwise = f . (f $^$ (n - 1)) in ($^$)
10:45:52 <lambdabot> forall c t. (Ord t, Num t) => (c -> c) -> t -> c -> c
10:46:00 <idnar> roconnor: but you can pretend 42 is a command-line parameter
10:46:11 <roconnor> idnar: it's fine if you want the 42nd prime
10:46:31 <roconnor> monochrom: using integers for indexing is what languages without algebraic data types have to resort to.
10:46:38 <idnar> roconnor: the other case I found here has code like
10:46:39 <monochrom> In iterate f x !! n, n is read from the user too.
10:46:46 <idnar> roconnor: tens n   = ["twenty", "thirty", "forty", "fifty", "sixty", "seventy", "eighty", "ninety"] !! fromIntegral (n - 2)
10:46:56 <ellisbben> Twey: that's a better phrasing of it for sure.
10:47:08 <Cheery> hm. guessing I should draw this thing from outside to inside.
10:47:28 <Cheery> http://i43.tinypic.com/dqrfhz.jpg
10:47:34 <Twey> ellisbben: It's not that good — I was just curious about the type
10:47:45 <Twey> It would be better expressed as a fold
10:48:02 <idnar> roconnor: would you rewrite that as a case on n or something?
10:48:10 <roconnor> idnar: that isn't terrible, although it is less than ideal.  I'd use a case analysis myself.
10:48:34 <idnar> roconnor: I suspect the only reason I didn't do it that way is that it's a lot longer to write out :P
10:48:35 <Twey> :t let f $^$ n = foldr (.) f $ replicate n f in f
10:48:36 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
10:48:51 <Twey> Oops
10:48:54 <Twey> :t let f $^$ n = foldr (.) f $ replicate n f in ($^$)
10:48:55 <lambdabot> forall a. (a -> a) -> Int -> a -> a
10:48:58 <roconnor> idnar: yep.  I wouldn't even bother changing it.
10:48:59 <monochrom> I have reservations on that. Conceivably, using algebraic data types is what languages without integers for indexing have to resort to.
10:49:05 <Twey> That's the one
10:49:11 <Twey> Might have an off-by-one error
10:49:30 <Twey> :t let f $^$ n = foldr (.) f $ replicate n f in (+1) $^$ 3 $ 1
10:49:32 <lambdabot> forall a. (Num a) => a
10:49:33 <Twey> > let f $^$ n = foldr (.) f $ replicate n f in (+1) $^$ 3 $ 1
10:49:34 <lambdabot>   5
10:49:56 <idnar> roconnor: hmm, I think I vaguely recall what I was using iterate / !!
10:49:59 <Twey> > let f $^$ (n + 1) = foldr (.) f $ replicate n f in (+1) $^$ 3 $ 1
10:50:01 <lambdabot>   4
10:50:13 <Twey> There we go
10:50:31 <b_jonas> can't you use mconcat instead of foldr?
10:50:33 <idnar> roconnor: it was some kind of progressive algorithm where you got better results the more passes you ran, but obviously you have to stop at some point
10:51:41 <idnar> roconnor: random terrain generation or some such
10:51:59 <idnar> sort of like a fractal, I guess
10:52:05 <b_jonas> oh no you can't because functions aren't natively Monoid, only wrapped
10:52:47 <b_jonas> > appEndo (mconcat (replicate 5 (Endo (*2)))) 1
10:52:49 <lambdabot>   32
10:52:51 <roconnor> idnar: I see.  Like I said iterate f !! n isn't terrible, just a small flag.
10:53:18 <idnar> roconnor: well, I'm not about to charge off on a witchhunt to eradicate all knowledge of (!!) from my brain and code
10:53:44 <roconnor> idnar: just a mild electrial shock when you use it should be enough.
10:53:46 <idnar> roconnor: but if there's a better way of doing something, I'm always keen to know what it is :)
10:53:46 <monochrom> "bad code" is a global whole-program-analysis property.
10:53:58 <idnar> especially when it comes to issues of style
10:54:33 <idnar> (heck, I have yet to write any Haskell programs that aren't just disposable toys)
10:55:30 <EvilTerran> > let twice f = f . f; f $^$ 0 = id; f $^$ n | n > 0 = twice (f $^$ (n `div` 2)) . (if odd n then f else id) in (f $^$ 10) x
10:55:32 <lambdabot>   f (f (f (f (f (f (f (f (f (f x)))))))))
10:56:22 <b_jonas> EvilTerran: I don't think that really helps
10:56:22 <monochrom> Next, you're going to use Fourier transform to optimize f $^$ n.
10:56:29 <idnar> haha
10:56:39 * EvilTerran is just idly fiddling
11:03:13 <roconnor> idnar: http://www.haskell.org/pipermail/haskell-cafe/2007-July/028262.html
11:03:25 <roconnor> y <- concat (iterate (liftM2 (:) menu) [[]])
11:03:27 <roconnor> is better than
11:03:43 <roconnor> i <- [0..]
11:03:44 <roconnor> , y <- replicateM i menu
11:03:46 <lunabot>  luna: parse error on input `<-'
11:04:02 <bos> @seen dons
11:04:02 <lambdabot> dons is in #haskell-in-depth, #gentoo-haskell, #concatenative, #arch-haskell, #darcs, #yi, #xmonad, #ghc and #haskell. I last heard dons speak 20h 19m ago.
11:04:07 <roconnor> one example of removing integer indics
11:04:25 <idnar> roconnor: but that only works because you're using [0..]
11:04:41 <roconnor> idnar: of course
11:07:39 <skorpan> yay, i just used join for the first time
11:08:51 <b_jonas> skorpan: on which monad? reader?
11:09:06 <skorpan> b_jonas: ReaderT with IO
11:09:15 <b_jonas> great
11:09:23 <skorpan> it's a pretty silly use case though...
11:09:28 <skorpan> liftIO $ join $ putStrLn <$> fileFile fp
11:09:37 <skorpan> i'm sure there's a better way, but still "join" worked :P
11:09:54 <skorpan> fileFile :: FilePath -> IO String
11:10:02 <ellisbben> roconnor: well, if you use integers you could do i <- [0..total `div` minimum $ map snd menu]
11:10:18 <ellisbben> which is kinda nice because then your program terminates
11:10:38 <aavogt> @type catMaybes
11:10:39 <lambdabot> forall a. [Maybe a] -> [a]
11:10:48 <aavogt> @type concat
11:10:49 <lambdabot> forall a. [[a]] -> [a]
11:11:11 <mauke> skorpan: join (liftM f x) is x >>= f
11:11:21 <skorpan> uh... yeah, you're right
11:11:22 <skorpan> fsck.
11:11:30 <gwern> hm. 1000 * trillion is quadrillion, right?
11:11:39 <mauke> also, what's the difference between fileFile and readFile? :-)
11:11:46 <Twey> @hoogle Monad m => m (m a) -> m a
11:11:46 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
11:11:46 <lambdabot> Prelude (>>) :: Monad m => m a -> m b -> m b
11:11:46 <lambdabot> Control.Monad (>>) :: Monad m => m a -> m b -> m b
11:11:48 <skorpan> mauke: fileFile runs "file" on the file
11:11:55 <Twey> Isn't concat = join?
11:12:04 <mauke> skorpan: ah, nice
11:12:13 <gwern> @check \x y -> concat x y == join x y
11:12:14 <skorpan> mauke: i'm sure you understand what i'm coding right now :)
11:12:15 <lambdabot>   Couldn't match expected type `t -> a' against inferred type `[a1]'
11:12:23 <gwern> Twey: 'twould seem not!
11:12:32 <mauke> skorpan: yeah, a shell script
11:12:35 <aavogt> gwern: save the world and use scientific notation instead?
11:12:46 <aavogt> @check \x -> concat x == join x
11:12:47 <skorpan> mauke: no! "hunp" will start making use of "file" instead of regular expressions :)
11:12:48 <lambdabot>   "OK, passed 500 tests."
11:12:59 <Twey> @src concat
11:12:59 <lambdabot> concat = foldr (++) []
11:13:03 <aavogt> ha!
11:13:08 <mauke> @src join
11:13:08 <lambdabot> join x =  x >>= id
11:13:12 <Twey> Odd
11:13:25 <Gracenotes> join x = concatMap id x, for [] specifically
11:13:42 <Twey> Ah, I see
11:13:44 <copumpkin> aka concat
11:13:50 <Twey> But no
11:13:50 <Gracenotes> @type flip concatMap
11:13:52 <lambdabot> forall a b. [a] -> (a -> [b]) -> [b]
11:13:55 <Twey> @src [] join
11:13:56 <lambdabot> Source not found. My brain just exploded
11:14:03 <copumpkin> it's not a method
11:14:19 <mauke> <lambdabot> join x =  x >>= id
11:14:23 <int-e> @src [] (>>=)
11:14:23 <lambdabot> xs >>= f     = concatMap f xs
11:15:49 <aavogt> @type join . sequence
11:15:50 <lambdabot> forall a. [[a]] -> [a]
11:16:22 <aavogt> > join $ sequence [[1,2],[3,4]]
11:16:23 <lambdabot>   [1,3,1,4,2,3,2,4]
11:16:38 <mauke> > join . sequence $ ["abc", "XY"]
11:16:39 <lambdabot>   "aXaYbXbYcXcY"
11:17:51 <aavogt> making a function that is both join, and catMaybes would require a MPTC?
11:21:43 <roconnor> ellisbben: true, although I'd be inclined to do `concat (take <blah>(iterate (liftM2 (:) menu) [[]]))'.
11:23:22 <aavogt> I'm applled by all these functions that do xyz things at once. concatMap, maybe, divMod ... didn't haskell invent fusion and (.) for a reason!?!
11:23:41 <mauke> maybe does one thing only
11:23:47 <roconnor> ellisbben: but then again maybe `concat (takeWhile (not . null) (map (filter <blah>) (iterate (liftM2 (:) menu) [[]])))' is better still
11:23:52 <EvilTerran> aavogt, maybe is the catamorphism for the Maybe type, it's pretty fundamental
11:24:04 <aavogt> @type maybe
11:24:05 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
11:24:09 <aavogt> @type fromMaybe
11:24:10 <EvilTerran> and divMod does things in parallel, not sequentially, so (.)'s not relevant
11:24:10 <lambdabot> forall a. a -> Maybe a -> a
11:24:28 <ellisbben> roconnor: my poor brain is forced to think in Java too often to find such wizardry natural
11:24:39 <Saizan_> fromMaybe is just a convenience function for a common use case
11:24:41 <Philippa> aavogt: say hello to legacy code. Also, to the fact only GHC does fusion and only where it's been taught to with rewrite rules
11:24:47 <roconnor> ellisbben: you have been spoiled by integer indexing. :P
11:25:12 * roconnor is starting to like this code
11:25:20 <aavogt> @quote success
11:25:21 <lambdabot> JonHarrop says: We invested a lot of time and money diversifying into Haskell before I discovered that their industrial success stories were largely faked.
11:25:40 <profmakx> jonharrop for failident!
11:25:56 <dancor> quoteburn
11:26:30 <gwern> @quote jdh
11:26:30 <lambdabot> No quotes match. Where did you learn to type?
11:26:33 <mauke> :t \d f -> fromMaybe d . fmap f
11:26:34 <lambdabot> forall a a1. a -> (a1 -> a) -> Maybe a1 -> a
11:27:44 <ellisbben> roconnor: what is <blah> in the filter?  (total ==) $ sum $ map snd or something more elegantly expressed to the same effect?
11:28:06 <roconnor> ellisbben: something like that, with <=
11:28:26 <roconnor> I might need another map
11:28:28 <aavogt> EvilTerran: so use Foldable instead of maybe?
11:28:37 <aavogt> @index until
11:28:37 <lambdabot> Prelude
11:28:58 <ellisbben> roconnor: perfectly beautiful write-once code. :)
11:29:45 <aavogt> so I guess my complaint is mostly at concatMap, notElem then.
11:31:51 <aavogt> is there an `until' that lets me compare the previous value? I've done it frequently enough with:
11:33:32 <aavogt> @type listToMaybe . dropWhile (not . uncurry ?p) . (\x -> zip x $ tail x) . iterate ?improveGuess
11:33:33 <lambdabot> forall a. (?improveGuess::a -> a, ?p::a -> a -> Bool) => a -> Maybe (a, a)
11:35:24 <Gracenotes> oh, I've made one of those before. No explicit primitive recursion, rather nice :)
11:35:57 <Gracenotes> this might help, though
11:35:59 <aavogt> @src until
11:35:59 <lambdabot> until p f x | p x       = x
11:36:00 <lambdabot>             | otherwise = until p f (f x)
11:36:01 <Gracenotes> @type find
11:36:04 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
11:36:29 <Gracenotes> if you're doing the zip `ap` tail thing
11:38:01 <aavogt> @type find ?p . (\x -> zip x $ tail x) . iterate ?f
11:38:02 <lambdabot> forall a. (?f::a -> a, ?p::(a, a) -> Bool) => a -> Maybe (a, a)
11:38:38 <aavogt> Gracenotes: like that, or is there some other way?
11:39:08 <aavogt> @type until ?p (f . snd)
11:39:10 <lambdabot> forall a b. (?p::(a, b) -> Bool, Show b, SimpleReflect.FromExpr (a, b)) => (a, b) -> (a, b)
11:39:22 <aavogt> @type until ?p (?f . snd)
11:39:23 <lambdabot> forall a b. (?f::b -> (a, b), ?p::(a, b) -> Bool) => (a, b) -> (a, b)
11:40:00 <aavogt> @type until ?p (\(_,x) -> (x,?f x))
11:40:01 <lambdabot> forall t. (?f::t -> t, ?p::(t, t) -> Bool) => (t, t) -> (t, t)
11:40:08 <Gracenotes> well, you can replace with lambda with (zip `ap` tail) requiring Control.Monad, or (zip <*> tail) requiring Control.Applicative. Looks pretty sound to me, though, if you want the result in (oldguess, newguess) form
11:41:30 <aavogt> @type zip `ap` tail
11:41:31 <lambdabot> forall b. [b] -> [(b, b)]
11:41:50 <aavogt> @type ?f `ap` tail
11:41:51 <lambdabot> forall b a. (?f::[a] -> [a] -> b) => [a] -> b
11:42:17 <aavogt> @type ap
11:42:18 <roconnor> > map (map fst) $ filter (\y -> sum (map snd y) == 1505) $ concat $ takeWhile (not . null) (map (filter (\y -> sum (map snd y) <= 1505)) (iterate (liftM2 (:) menu) [[]]))
11:42:18 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
11:42:24 <lambdabot>   mueval-core: Prelude.read: no parse
11:42:24 <lambdabot>  mueval: ExitFailure 1
11:43:04 <aavogt> Gracenotes: neat!
11:44:52 <Gracenotes> also known as the S combinator: http://en.wikipedia.org/wiki/S_combinator#Examples_of_combinators
11:45:08 <BMeph> @type zip `ap` map
11:45:09 <lambdabot>     Couldn't match expected type `[a]' against inferred type `a1 -> b'
11:45:09 <lambdabot>     In the second argument of `ap', namely `map'
11:45:09 <lambdabot>     In the expression: zip `ap` map
11:45:21 <Gracenotes> they call it "applicative" for a reason :)
11:45:46 <Gracenotes> whereas (>>=) is like <*>/ap but with the arguments to the function flipped. not sure what the significance of that is
11:47:09 <BMeph> Gracenotes: Funny, but I've been trying to figure out if there's a name to express the relationship between "ap" and "=<<" for a while now. :)
11:49:40 <BMeph> It reminds me of the strength property, but all Applicatives/Monads of Haskell are strong.
11:49:43 <Saizan_> a f x = b (flip f) x ?
11:50:49 <Philippa> aavogt: concatMap exists not least because it's still fast with optimisation off, that fair enough?
11:51:10 <BMeph> Look at describing/"defining" fmap, in terms of ap/=<< and return.
11:51:15 <Gracenotes> @type \f x -> join (fmap f x)
11:51:17 <lambdabot> forall a (m :: * -> *) a1. (Functor m, Monad m) => (a -> m a1) -> m a -> m a1
11:52:19 <Gracenotes> join + fmap = (=<<). So, if x + fmap = ap, then what is x?
11:52:36 <Gracenotes> one answer would be f a -> f b -> f (a, b)
11:53:05 <BMeph> Gracenotes: That's Monoidal, right? :)
11:53:07 <Gracenotes> aka lax monoidal functor...
11:53:35 <aavogt> @go lax
11:53:36 <Gracenotes> yeah. Just according to the applicative paper. I'm not sure how interesting the link is wrt readers..
11:53:37 <lambdabot> http://www.lawa.org/welcomelax.aspx
11:54:33 <BMeph> Gracenotes: My example goes like this:
11:55:05 <BMeph> My example: fmap == ap . return == (=<<) . (return .)
11:55:15 <BMeph>  fmap == ap . return == (=<<) . (return .)
11:55:30 <Gracenotes> @type let lax :: Applicative f => f a -> f b -> f (a, b); lax = liftA2 (,) in \mf mx -> fmap (uncurry ($)) (lax mf mx)
11:55:32 <lambdabot> forall b b1 (f :: * -> *). (Applicative f) => f (b -> b1) -> f b -> f b1
11:56:41 <Gracenotes> @djinn (f -> a) -> (f -> b) -> (f -> (a, b))
11:56:41 <lambdabot> f a b c = (a c, b c)
11:57:19 <Gracenotes> ... describes (&&&) to a T...
11:58:14 <Gracenotes> this is getting too unwieldy >_>
11:59:13 <Gracenotes> BMeph: hm, interesting
12:00:17 <BMeph> I feel at times, that some of the Arrow trickery stuff should be "specialized" back to functions, and thrown into Data.Pair - it relies "too much" on using pairs for my tastes.
12:01:06 <Saizan_> what?
12:01:46 <BMeph> Saizan_: What "what"? ;)
12:02:11 * BMeph boings in greeting!
12:02:13 <heatsink> I have a cyclic module dependence, so I inserted a {-# SOURCE #-} import.
12:02:36 <heatsink> Now my TH splices won't run because one of my files is only availabe as a boot module
12:02:42 <heatsink> Is there a workaround for this?
12:03:06 <Philippa> put the TH code in the boot file?
12:05:21 <a_guest> in a data definition I see: 'data D = D !A !B'. What does that '!' mean?
12:05:34 <heatsink> I don't think that will work, because the TH code depends on a class constraint, and the class definition is part of the module recursion.
12:06:01 <heatsink> a_guest, It means that A and B are strict.  They will be fully evaluated whenever you create a D value.
12:06:01 <trofi> > let !a = undefined in 1
12:06:02 <lambdabot>   * Exception: Prelude.undefined
12:06:06 <trofi> > let a = undefined in 1
12:06:07 <lambdabot>   1
12:06:16 <Gracenotes> well. function bangs != data constructor bangs
12:06:38 <Gracenotes> but in practice, somewhat same thing, Can't be undefined, at least
12:08:10 <a_guest> So for a construct of data type without '!', the arguments in construction will not be evaluated until the type is needed?
12:08:32 <a_guest> ...the object...
12:08:52 * heatsink tries to refactor code to get rid of the cycle
12:09:01 <heatsink> a_guest, that's right
12:09:07 <heatsink> For example, I can say
12:09:23 <heatsink> > take 5 $ let ones = 1:ones in ones
12:09:25 <lambdabot>   [1,1,1,1,1]
12:10:13 <a_guest> heatsink: thank you
12:10:32 <Gracenotes> if you just have strict fields for no reason, it might worsen performance, with all the checking
12:11:11 <Gracenotes> however, if you allow compiler optimizations, with -O2 and whatnot, the compiler might be able to optimize *more* because the strictness analyzer knows more
12:11:41 <Gracenotes> certain shortcuts can be taken if the compiler knows a certain value is definitely strict, i.e. has a constructor to show in this case
12:11:49 <Saizan_> strict fiels also allow unpacking, where it applies
12:12:00 <Gracenotes> right, used with -funbox-strict-fields
12:12:07 <Gracenotes> the useful option that goes with it
12:12:38 <Heffalump> Gracenotes: all what checking?
12:12:54 <a_guest> function names should be started with lowercase. But value constructors are started with Uppercase, why? (aren't they considered functions?)
12:13:05 <Gracenotes> means that the compiler can just assume the presence of a constructor, and so don't have to do all the packing and unpacking :/
12:13:15 <burp> @hoogle fold
12:13:16 <lambdabot> Data.Foldable fold :: (Foldable t, Monoid m) => t m -> m
12:13:16 <lambdabot> Data.IntMap fold :: (a -> b -> b) -> b -> IntMap a -> b
12:13:16 <lambdabot> Data.IntSet fold :: (Int -> b -> b) -> b -> IntSet -> b
12:13:19 <Gracenotes> Heffalump: uh, checking that it's strict, I'd imagine
12:13:41 <Heffalump> Gracenotes: it just means evaluating values before putting them into the type
12:13:57 <Heffalump> when reading, you don't have to check for evaluated values because you know they must be
12:14:21 <Heffalump> so if the value will be wanted, it's usually a win
12:14:21 <Gracenotes> right. well, all the hnf'ing all over the place surely has a slight performance risk
12:14:48 <Heffalump> if the value wouldn't have been wanted, certainly
12:15:04 <Heffalump> but hnf'ing is the standard evaluation strategy in every other language and it's not so bad :-)
12:15:33 <Gracenotes> heh. true.
12:16:57 <Gracenotes> a_guest: hm... they are considered functions.
12:17:02 <byorgey> a_guest: they are very special functions.
12:17:11 <byorgey> because you can also use them to do pattern-matching.
12:17:16 <byorgey> which you can't do with normal functions.
12:17:17 <b_jonas> just like how (flip id) is considered a function too but starts with a parenthesis
12:17:31 <byorgey> hence the syntactic distinction.
12:17:58 <b_jonas> the uppercase is so that when a name appears in a _pattern_, if it's lowercase then it's bound to, if it's uppercase then it's a constructor that's unpacked on
12:18:05 <nibro> @seen malcolmw
12:18:06 <lambdabot> I saw malcolmw leaving #haskell-in-depth, #darcs, #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell 1d 2h 27m 4s ago, and .
12:18:49 <a_guest> byorgey, b_jonas: ok. that was a satisifying answer.
12:34:04 <Gracenotes> -funfolding-use-threshold .. funfolding sounds fun. but not as fun as a funbox, I'd guess
12:35:23 <mmorrow_> unfolded funboxes on the other hand
12:37:10 <frtysvnbytes> good evening everybody. i have an old version of ghc installed. can i just install a new version or do i have to uninstall ghc first?
12:37:19 <frtysvnbytes> my os is os x
12:37:35 <heatsink> frtysvnbytes, How did you install the old GHC?
12:37:57 <frtysvnbytes> with a package file
12:38:31 <heatsink> Hmm.  I don't know how OS X package files work.
12:38:49 <heatsink> Normally, different versions of GHC install in different directories, so one won't overwrite another.
12:39:33 <heatsink> Except for symbolic links in /usr/bin I think
12:40:52 <heatsink> If you're planning on uninstalling the old one, it would be safer to do that first.  Then you don't have to worry about whether the packages conflict.
12:42:08 <frtysvnbytes> hm okey
12:45:48 <skorpan> this is really bugging me..
12:45:52 <skorpan> parseFromFile parser "/home/deniz/.hunp/patterns"
12:45:59 <skorpan> running that in ghci does *nothing*
12:46:02 <skorpan> i don't get it
12:46:28 <skorpan> not even "trace"-ing in "parser" gives me anything
12:46:44 <monochrom> @hoogle parseFromFile
12:46:45 <lambdabot> Text.Parsec.ByteString parseFromFile :: Parser a -> String -> IO (Either ParseError a)
12:46:45 <lambdabot> Text.Parsec.String parseFromFile :: Parser a -> String -> IO (Either ParseError a)
12:46:45 <lambdabot> Text.Parsec.ByteString.Lazy parseFromFile :: Parser a -> String -> IO (Either ParseError a)
12:47:24 <skorpan> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6081#a6081
12:47:28 <skorpan> that's my entire code
12:48:33 <skorpan> any ideas?
12:48:42 <monochrom> Perhaps because PackRule cannot be shown.
12:48:47 <byorgey> skorpan: what do you mean, "does nothing"?
12:49:05 <skorpan> monochrom: but shouldn't the traces give me anything?
12:49:21 <skorpan> byorgey: i mean that i don't get anything to stdout
12:49:37 <skorpan> but yeah,
12:49:45 <skorpan> i had to instantiate Show for PackRule
12:49:54 <skorpan> thanks
12:50:11 <byorgey> weird that you wouldn't even get an error though... hmm...
12:50:27 <skorpan> yeah, very strange
12:53:33 <monochrom> Not seeing the I/O-effects of trace means there is laziness.
13:00:00 <mmorrow> skorpan: have "line" take a param that you pass to "trace"
13:00:12 <mmorrow> (could be `()' or anything)
13:00:19 <skorpan> to "strictify" it?
13:00:47 <mmorrow> the unsafePerformIO on that only gets exec once if it doesn't depend on anything else
13:01:07 <mmorrow> it probably gets lifted out or something
13:01:34 <mmorrow> and once the thunk gets evaluated, that's it
13:03:40 <mmorrow> let foo = unsafePerformIO (print 42); zoo !() = unsafePerformIO (print 43) in foo `seq` zoo() `seq` foo `seq` zoo() `seq` ()
13:03:43 <mmorrow> prints
13:03:47 <mmorrow> 42
13:03:48 <mmorrow> 43
13:03:49 <mmorrow> 43
13:04:49 <copumpkin> conal: did you post the iphone signage question on the iphone haskellwiki page?
13:08:06 <conal> copumpkin: no.  i haven't seen it.  looking ...
13:08:09 <mmorrow> copumpkin: i just put up a page for my interp, it has some (info/overview/a prettyprint of phases for a test module) so far.. getting sooo close.
13:08:21 <copumpkin> conal: oh I just noticed it on the iphone page you set up, assumed it was you :)
13:08:22 <mmorrow> http://moonpatio.com/lem/
13:08:26 <copumpkin> mmorrow: ooh nice
13:08:42 <copumpkin> that looks like a fun project
13:08:56 <mmorrow> totally fun
13:09:07 <mmorrow> also brain-paining
13:09:21 <conal> copumpkin: i think lispy added those questions.
13:09:51 <conal> copumpkin: does iPhone have a notion of app signing?
13:10:12 <copumpkin> yeah, definitely
13:10:27 <Alpounet> mmorrow, nice
13:10:34 <copumpkin> it's relatively straightforward to do on mac os
13:11:55 <copumpkin> conal: maybe it'd be worth to set up another channel for getting people together who are interested?
13:11:58 <mmorrow> Alpounet: :)
13:12:22 <conal> copumpkin: like #haskell-iphone?
13:12:34 <copumpkin> sure
13:12:44 <conal> copumpkin: good idea.  i hadn't thought to.
13:13:12 <copumpkin> :)
13:14:09 <eck> i'm trying to write a function encodeAsString that works like Data.Binary's encode, but outputs a String; the problem is i'm getting lost among all of the internal/lazy bytestring types and conversion functions. can someone give me a hand?
13:14:09 <conal> copumpkin: i don't know much about irc.  is anything required other than /join'ing the new channel?  e.g. setting up privileges/ops?
13:14:29 <conal> copumpkin: or helpful, even if not required.
13:15:23 <copumpkin> I think it's /msg chanserv register #channelname
13:15:38 <copumpkin> don't want to register it under my name :)
13:16:13 <conal> copumpkin: done.  what does it mean?
13:16:28 <conal> copumpkin: i got "ChanServ (ChanServ@services.) has changed mode for #haskell-iphone to -s+tc"
13:16:58 <copumpkin> it registers you as the owner of the channel
13:16:58 <conal> i've looked at these irc char-codes a few times, but they never stick in my head
13:17:10 <conal> oh -- cool :)
13:18:10 <byorgey> ah, is that how you do it?
13:18:24 <byorgey> I thought about figuring out how to do that for #haskell-hacphi
13:18:31 <copumpkin> Cale: you around?
13:18:34 <ibid> channel modes are codumented in http://freenode.net/using_the_network.shtml
13:18:40 <dmwit> Uh-oh, now we're actually going to have an op in hacphi? =P
13:18:43 <conal> ibid: thx.  was looking.
13:18:51 <byorgey> but now I've left and rejoined so I'm not an op anymore, so I can't =)
13:18:55 <yitz> conal: step one: ask Cale to get lambdabot to join the new channel
13:19:50 <copumpkin> anyone interested in haskell on the iphone?
13:19:51 <conal> @ask Cale would you please @join lambdabot to #haskell-iphone?
13:19:51 <lambdabot> Consider it noted.
13:19:52 <yitz> copumpkin: oh, I guess that's what you were trying to do
13:20:00 <copumpkin> yitz: yeah :)
13:20:52 <ibid> conal: just remember that channel and user modes are different (and use the same characters for different purposes) :)
13:21:07 <conal> ibid: eep.  thx for the warning
13:21:39 <yitz> eck: what are you stuck on?
13:22:12 <mauke> @join #haskell-iphone
13:22:12 <lambdabot> Not enough privileges
13:22:29 <conal> @join #haskell-iphone
13:22:29 <lambdabot> Not enough privileges
13:22:37 <conal> really requires cale, i guess.
13:22:38 <Heffalump> @join #haskell-iphone
13:22:38 <lambdabot> Not enough privileges
13:22:50 <copumpkin> there's the list of privileged people in the repo
13:23:02 <TheHunter> @join #haskell-iphone
13:23:09 <conal> copumpkin: what repo?
13:23:09 <copumpkin> lol
13:23:09 <copumpkin> the lambdabot repo
13:23:12 <Heffalump> lol
13:23:18 <conal> mauke: thx!
13:23:19 * copumpkin hugs lambdabot
13:23:34 <ibid> exceptional security :)
13:23:36 <Heffalump> who's a gullible little bot, then
13:23:46 <mauke> I've been doing that for years
13:23:46 <eck> yitz: i thought i could do something like \x -> unpack $ fromChunks [encode x]
13:23:50 <eck> but that doesn't work
13:24:27 <Saizan_> Heffalump: btw, you might want to deop yourself
13:24:49 <dirk_> I got MyType a b c and I want to return MyType (a+1) b c . How can I do that without unpacking everything. It is perfecty ok to me to use an other structure nut MyType, but don't know which one?
13:24:51 <Heffalump> oh, thanks, I keep forgetting that
13:24:56 --- mode: Heffalump set -o helgim_
13:24:59 --- mode: Heffalump set -o Heffalump
13:25:02 <mauke> @flush
13:25:02 * Heffalump fails at tab completion too
13:25:30 <mauke> dirk_: you can't really
13:25:36 <dmwit> dirk_: "f (MyType a b c) = MyType (a+1) b c" -- doesn't this work?
13:25:55 <dmwit> dirk_: Unless you actually mean MyType to be a type constructor, in which case, adding 1 to a type doesn't make sense.
13:26:26 <conal> what options are there for irc channel logging?
13:26:28 <dmwit> Oh, I think I see what your question is.
13:26:28 <dirk_> but can't I use a record type or something like that for such kind of problems?
13:26:34 <dmwit> dirk_: yes, exactly
13:26:37 <yitz> eck: why not just unpack?
13:26:47 <dmwit> MyType { a :: ..., b :: ..., c :: ... }
13:26:58 <dmwit> f m = m { a = a m + 1 }
13:27:16 <yitz> eck: that gives you a [Word8]
13:27:16 <dirk_> this looks good
13:27:24 <eck> hah, i guess i overlooked that somehow
13:27:28 <eck> thanks
13:27:37 <yitz> eck: which you then make into a String however you'd like, I'm not sure exactly what you want
13:28:19 <dirk_> dmwit I don't fully understand the second line of your example yet
13:29:49 <dirk_> ok I think I slowly understand
13:30:04 <dmwit> m { a = newA } -- record update
13:30:15 <dmwit> newA = a m + 1 -- record selection, then addition
13:30:47 <dirk_> yes thats it
13:31:48 <dirk_> thank you dmwit
13:32:50 <skorpan> @hoogle String -> String
13:32:51 <lambdabot> Distribution.Simple.Utils dotToSep :: String -> String
13:32:51 <lambdabot> Distribution.Simple.Utils fromUTF8 :: String -> String
13:32:51 <lambdabot> Distribution.Simple.Utils lowercase :: String -> String
13:33:11 <skorpan> how do i trim the whitespaces off the edges of a string?
13:33:34 <yitz> skorpan: dropWhile (not . isSpace) at one end
13:33:46 <The-Kenn1> skorpan: There is a package String.Utils or so in Hackage
13:33:53 <yitz> skorpan: the other end - well, you could wrap it in reverses
13:34:08 <skorpan> @hoogle [Maybe a] -> [a]
13:34:09 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
13:34:09 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
13:34:09 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
13:34:13 <skorpan> that's probably better
13:34:40 <Gracenotes> record update is not very flexible
13:34:40 <yitz> skorpan: if you have to do a lot of stuff at the end of the string, you are better off making it a Data.Sequence
13:35:18 <skorpan> yitz: yeah, but i'll just use Maybe, that's the best in this case
13:35:38 <Lemmih> ?arr
13:35:38 <lambdabot> Aye Aye Cap'n
13:35:51 <yitz> skorpan: I don't get it, but ok, if that does it for you.
13:36:02 <skorpan> yitz: it'd take some time to explain, but trust me :)
13:36:16 <yitz> skorpan: you have my full trust. :)
13:36:31 <yitz> hi Lemmih
13:36:58 <The-Kenn1> skorpan: http://hackage.haskell.org/packages/archive/MissingH/1.0.0/doc/html/Data-String-Utils.html#v%3Astrip
13:37:09 <dmwit> skorpan: The state-machine that does trimming lazily is not too hard to write with explicit recursion.
13:37:17 <yitz> ah, MissingH
13:37:52 <skorpan> MissingH is awesome
13:49:58 <Zao> Ooh, nice. Fedora 11 has GHC 6.10.3.
13:55:25 <Philonous> > let trimEnd [] = []; trimEnd (x:xs) = if ((not. isSpace $ x) || (end /= [] ) ) then x:end else [] where end = trimEnd (xs) in trimEnd "abcd   "
13:55:27 <lambdabot>   "abcd"
13:56:22 <hackagebot> data-binary-ieee754 0.3 - Parser/Serializer for IEEE-754 floating-point values (JohnMillikin)
13:57:24 <hackagebot> stm-io-hooks 0.3.0 - An STM monad with IO hooks (PeterRobinson)
13:59:16 <Zao> stm-io-hooks sounds scary.
13:59:58 <enolan> @seen sof
13:59:58 <lambdabot> I haven't seen sof.
14:00:23 <Vq^> Zao: it would be if it was 'unsafe' IO hooks
14:01:18 <ehird> Hmm. Polymorphic lists don't seem to like certain things.
14:01:42 <Jedai> > let trimEnd = foldr (\x end -> if isSpace x && null end then [] else x:end) [] in trimEnd "abcd  efg  "
14:01:43 <lambdabot>   "abcd  efg"
14:01:49 <ehird> Specifically, "data Foo = Foo [forall a. Bar a => a]", doing (Foo [thingThatSatisfiesIt]) complains that you're giving it a ThingThatSatisfiesIt, not an "a".
14:02:11 <Jedai> Philonous: a little bit better trmEnd ^^
14:02:48 <Philonous> Basically the same
14:03:06 <mauke> ehird: that doesn't look like a polymorphic list, at least not in the usual sense
14:03:17 <ehird> mauke: By polymorphic list I mean things like [Show a => a].
14:03:21 <mauke> or am I thinking wrong
14:03:26 <Philonous> But foldr is more elegant than explicit recursion, I agree
14:03:27 <ehird> Which lets you put anything showable inside, then (map show) it.
14:03:29 <SamB> ehird: you can *do* that ?
14:03:30 <Jedai> Philonous: exactly the same in fact :)
14:03:33 <ehird> SamB: Yep
14:03:37 <ehird> Sweet, isn't it?
14:03:55 <idnar> SamB: hooray existentials
14:03:58 <Jedai> ehird: No, you can't
14:04:08 <ehird> Jedai: Well, you -can- do it, I've just forgotten how.
14:04:09 <Jedai> ehird: well you can't with GHC rather
14:04:13 <ehird> Isn't it (Show a) => [forall a. a]?
14:04:18 <ehird> I've done it, I've just forgotten how
14:04:25 <Jedai> ehird: you must create a Showable type
14:04:37 <ehird> Ah.
14:04:40 <ehird> Well that's simple enough.
14:04:42 <Jedai> ehird: data Showable = forall a . (Show a) => S a
14:04:46 <ehird> No.
14:04:47 <ehird> No, that's wrong.
14:04:51 <ehird> You can do it without a wrapper.
14:04:54 <Jedai> ehird: then you can do a [Showable] list
14:04:54 <ehird> Let me find my code.
14:05:32 <Jedai> ehird: No you can't in GHC, I'm quite sure, though one of the most recent compiler allows you to do that (but with the exists keyword, not forall)
14:05:47 <mauke> this works in my ghc if you enable ImpredicativeTypes
14:06:22 <Jedai> mauke: What ? [forall a. Bar a => a] ?
14:06:27 <ehird> Jedai: I guess, then, that I just imagined doing it :)
14:06:28 <mauke> ehird: this type looks like a monomorphic list where all elements are of all Bar-able types
14:06:37 <ehird> mauke: yes, that's the semantics
14:06:44 <mauke> so basically, you can only put undefined in there
14:06:48 <ehird> hmm
14:06:48 <ehird> ah
14:06:54 <ehird> it seems my od code did wrap
14:06:56 <ehird> which is irritating
14:06:57 <ehird> *old
14:07:02 <ehird> Jedai: what's the exists thingy
14:07:04 <mauke> wait, this might work for monoids
14:07:42 <Jedai> ehird: the exists thingy is an extension of a recent Haskell compiler (UHC)
14:07:49 <ehird> oh.
14:07:52 <mauke> Foo [mempty] typechecks :-)
14:08:02 <ehird> bah, I WILL do this with ghc, even if it involves losing my right arm!
14:08:04 <ehird> or my wrong arm.
14:08:28 <Jedai> ehird: basically it allows you to do the same thing as my Showable exemple before but without having to declare a datatype
14:08:40 <ehird> yeah; that's what I'm attempting :)
14:08:50 <Jedai> You can use a [exists a . (Show a) => a] type
14:09:07 <ehird> unfortunately i'm on gh.
14:09:08 <ehird> ghc
14:09:40 <ehird> nothing i'm doing should be particularly hard, beh
14:10:20 <Jedai> ehird: Sorry, but I really don't think GHC can do that
14:10:33 <ehird> ferp.
14:10:36 <ehird> :(
14:10:43 <mauke> oops :: (Typeable a, Typeable b) => String -> a -> b -> wheee
14:10:45 <Jedai> [forall a. Bar a => a] is possible, but it don't work like you want
14:10:45 <ehird> maybe I could achieve the same thing in another way.
14:10:46 <mauke> what was I thinking
14:11:21 <ehird> I'm basically trying to represent a strongly-typed tree structure where some nodes can only contain a subset of the other node types, etc
14:11:40 <ehird> So "Foo [forall a. Child Foo a => a]"
14:12:28 <Jedai> ehird: GADT ?
14:12:50 <ehird> Jedai: how would that work?
14:13:29 <Jedai> data MyType where Foo :: Child MyType a => a -> MyType
14:13:51 <ehird> Jedai: That does not handle a list of child nodes.
14:13:54 <Jedai> ehird: something like that, with other tricks to allows you to have several children
14:14:02 <ehird> OK, guess I'll do trial and error :P
14:14:36 <Jedai> ehird: You could look at HList
14:14:54 <ehird> Jedai: Unfortunately, though, that doesn't let me use String as a node type. ...but I could do that with some typeclass stuff, which might just break it all again.
14:15:31 <ehird> 22:13 Jedai: data MyType where Foo :: Child MyType a => a -> MyType          ← one of these for each node type?
14:15:44 <Leftblank> I've been reading a lot about curry/uncurry and its signature, however, it doesn't seem to make sense, it a function and two arguments, yet the signature is ((a,b)->c)-> (a->b->c); exactly the opposite of what would make sense, why is this?
14:15:50 <ehird> Isn't that... just identical to "data MyType = Foo :: Child MyType a => a -> MyType"?
14:15:52 <ehird> err
14:16:06 <ehird> Isn't that... just identical to "data MyType = (Child MyType a) => Foo a?
14:16:08 <ehird> "?
14:16:46 <Jedai> ehird: Right, but GADT are more powerful that that, I was just suggesting they may offer a solution, depending on what you want to do exactly
14:17:10 <ehird> mm
14:17:12 <ehird> pretty much what I said :-)
14:17:15 <ellisbben> :t (curry, uncurry)
14:17:16 <lambdabot> forall a b c a1 b1 c1. (((a, b) -> c) -> a -> b -> c, (a1 -> b1 -> c1) -> (a1, b1) -> c1)
14:17:53 <yitz> > let addTuple = uncurry (+) in addTuple (5, 7)
14:17:55 <lambdabot>   12
14:17:57 <Jedai> ehird: But really, look at HList, I do think that it already has most typeclass for what you want to do
14:18:08 <yitz> @type uncurry
14:18:09 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
14:18:12 <Jedai> ehird: maybe... ;)
14:18:23 <ellisbben> LeftBlank: so, curry turns a function that operates on 1 tuple argument into a function that operates on 2 arguments
14:18:26 <ehird> Jedai: Looks terribly scary :)
14:18:45 <ellisbben> LeftBlank: and uncurry does the opposite.
14:18:48 <yitz> Leftblank: so it takes a function of two variables, and returns a function of one variable that takes a tuple. Make sense?
14:18:53 <ehird> Jedai: But no, that uses its own list types.
14:18:55 <Jedai> ehird: HList is scary, I won't disagree
14:19:00 <ehird> Hrrm.
14:19:00 <mauke> Leftblank: a -> b -> c is the same as a -> (b -> c)
14:19:09 <ehird> I basically just want to add a constraint to a polymorphic list. Bleh.
14:19:11 <Leftblank> mk
14:19:12 <Leftblank> thanks
14:19:15 <mauke> Leftblank: a function of two arguments is the same thing as a function returning a function
14:19:45 <Jedai> ehird: I don't see why you don't want to use my Showable solution then
14:19:57 <ehird> Jedai: It requires wrapping everything in a constructor
14:20:17 <Jedai> ehird: data Childable b = forall a . (Child b a) => C a
14:20:17 <ellisbben> ehird: what constraint?
14:20:24 <yitz> @check \x y -> curry id x y == (x, y)
14:20:25 <lambdabot>   "OK, passed 500 tests."
14:20:30 <ehird> ellisbben: "is one of these types"
14:20:35 <yitz> @type curry
14:20:37 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
14:20:40 <Jedai> ehird: that doesn't seems like a showstopper to me, given your requirement
14:20:41 <ehird> Jedai: Yes... C is a constructor.
14:20:54 <ehird> Jedai: It is, though; it rather defeats the point.
14:21:02 <ehird> I could just make different constructors for A-child-of-B if I did that.
14:21:37 <Jedai> ehird: I don't see it, look at my childable exemple again
14:22:05 <Jedai> ehird: you can use the same constructor in every case, its type would just be different from case to case
14:22:11 <ehird> Jedai: "data Childable b = forall a . (Child b a) => C a". C. You would have to do Foo [C (Bar []), C (Baz [Foo []])]
14:22:14 <ehird> Actually,
14:22:19 <ehird> Jedai: "data Childable b = forall a . (Child b a) => C a". C. You would have to do Foo [C (Bar []), C (Baz [C (Foo [])])]
14:22:22 <ehird> vs
14:22:26 <ehird> Foo [Bar [], Baz [Foo []]].
14:22:35 <ellisbben> ehird: I'm all for really simple approaches.  Have you seen the ShowBox example?
14:22:39 <ehird> Yes, having to put that C everywhere is a showstopper.
14:22:43 <ehird> ellisbben: Which?
14:23:07 <mauke> just use a custom list builder :-)
14:23:16 <Jedai> ehird: what mauke just said...
14:23:19 <ehird> ellisbben: Googling doesn't turn up anything.
14:24:38 <Jedai> let x .: xs = C x : xs in Foo (Bar [] .: Baz (Foo [] .: []) .: [])
14:24:43 <ellisbben> ehird: can't find the example, but you make a typeclass Foo and instances of it for all the types in your polymorphic list
14:24:59 <ehird> ellisbben: Yes... that is what I am doing...
14:25:19 <conal> RyanT5000: ping
14:25:33 <ehird> Jedai: non-type-safety is preferable to ugliness/verboseness in this case.
14:25:38 <ellisbben> *gets book
14:26:30 <Leftblank> Also, one thing that I can't wrap my head around is why books/tutorials seem to prefer this notation; "sum :: Integer -> (Integer -> Integer)" if sum takes two arguments - it'd make more sense to me to group the arguments
14:26:35 <Gracenotes> fake constructors *eyes glaze over*
14:26:47 <mauke> Leftblank: it doesn't really take two arguments
14:26:54 <Jedai> "Foo (Bar [] .: Baz (Foo [] .: []) .: [])" vs "Foo [Bar [], Baz [Foo []]]", are you sure the price is too high ?
14:27:01 <mauke> Leftblank: all functions take exactly one argument
14:27:18 <ehird> Jedai: Yes :-)
14:27:52 <Leftblank> mk mauke, that would explain it indeed
14:28:19 <Cale> "They are not identical.  The aspects you are willing to ignore are more important than the aspects you are willing to accept.  Robbery is not just another way of making a living, rape is not just another way of satisfying basic human needs, torture is not just another way of interrogation.  And XML is not just another way of writing S-exps.  There are some things in life that you do not do if you want to be a moral b
14:28:19 <Cale> eing and feel proud of what you have accomplished."
14:28:20 <lambdabot> Cale: You have 2 new messages. '/msg lambdabot @messages' to read them.
14:28:52 <ehird> Cale: Ah, Naggum. He will be missed, although probably not by his targets.
14:28:58 <Cale> hehe
14:29:14 <mauke> ding dong,
14:29:16 <ehird> Cale: (In case you haven't seen, he died.)
14:29:21 <Cale> yeah...
14:30:21 <ellisbben> ehird: uhh, what I'm seeing for this example is exceedingly similar to what you've been writing
14:30:29 <ehird> ellisbben: Oh?
14:30:31 <ellisbben> ehird: your stuff doesn't work?
14:30:32 <Cale> I actually somehow haven't seen too much by him before, but his writing seems amusing :)
14:30:35 <ehird> ellisbben: Indeed.
14:31:30 <conal> does anyone know how to set up channel logging?  (for #haskell-iphone)
14:32:10 <Cale> lambdabot: @join #haskell-iphone
14:32:32 <Cale> conal: hmm... lambdabot doesn't do it as far as I'm aware...
14:32:43 <mauke> @msg #haskell dohoho
14:32:43 <lambdabot> dohoho
14:33:51 <conal> Cale: thx.  i'll poke around
14:34:18 <conal> i guess some kind of bot.
14:34:32 <ellisbben> class Foo a where
14:34:32 <ellisbben>   foo :: a -> String
14:34:32 <ellisbben> data FooBox = forall a. Foo a => FooBox {unbox :: a}
14:34:32 <ellisbben> instance Foo FooBox where
14:34:35 <ellisbben>   foo (FooBox innerFoo) = foo innerFoo
14:34:37 <ellisbben> foos = map foo :: [FooBox] -> [String]
14:34:41 <ellisbben> whoopsie
14:35:15 <ellisbben> ehird: so, I fail at IRC but that works just fine for me with {-# LANGUAGE ExistentialQuantification #-}
14:35:42 <ehird> ellisbben: The problem is the box constructor.
14:35:54 <ellisbben> ehird: what's wrong with it?
14:36:17 <ehird> ellisbben: Well, it makes the usage too verbose for my purposes.
14:36:21 <ellisbben> hahaha
14:36:49 <ellisbben> ehird: well, if you want to construct polymorphic data structures in a static language, you have to pay for it as far as I know
14:36:56 <ehird> ellisbben: OCaml can do this.
14:37:03 <ehird> So nope.
14:37:10 <ehird> (w/ variant types.)
14:37:31 <ellisbben> ehird: hmm.  what's your use case?
14:37:34 <Alpounet> polymorphic variant, you mean ?
14:37:58 <RayNbow> hmm, anyone familiar with posets and interval orders?
14:38:01 <ehird> ellisbben: Type-safe, compile-time HTML generation. (Trivially extensible to XML, of course.)
14:38:10 <ehird> Compile-time type-checking of it, that is.
14:38:51 <ellisbben> ehird: and you have different types for different tags and text sections and attributes and whatnot?
14:39:03 <ehird> Yup
14:39:16 <ellisbben> ehird: ... and an ADT doesn't fit your needs?
14:39:46 <ehird> ellisbben: Not unless I can figure out how to make it work, no.
14:40:44 <ellisbben> it might be a pain to work out how to make a bunch of ADTs for representing HTML
14:41:03 <ehird> Yes, well, I'm aiming for a rather simpler structure tot est at first, of course.
14:41:05 <ehird> *to test
14:41:07 <Alpounet> anyone here interested in AI stuffs for Haskell ?
14:41:11 <ellisbben> right.  that's tough
14:41:45 <ehird> Yeah. With OCaml it is quite easy, but in Haskell... quite a chore.
14:41:53 <gwern> hm. 'sum (enumFromTo a b)'. how could that be optimized...
14:42:27 <ellisbben> being a lazy man myself, I'd just grab HaXmL and look at what it does
14:46:26 <RayNbow> hmm, is the more complex definition of Data.List.permutations (GHC 6.10) more efficient than the definition of permutations in the Haskell 1.3 report?
14:47:00 <RayNbow> (probably it is, since the former doesn't use (++) but function composition instead)
14:48:44 <gwern> :t enumFromTo
14:48:46 <lambdabot> forall a. (Enum a) => a -> a -> [a]
14:49:37 <Gracenotes> ...where is permutations in the online report?
14:50:12 <Gracenotes> oh. Well they look similar
14:50:52 <RayNbow> http://haskell.cs.yale.edu/haskell-report/List.html <-- at the bottom, for anyone else still looking
14:51:11 <gwern> hm. rewrite rules could fire on the Num instances for that
14:51:15 <RayNbow> Gracenotes: the report version is easier to understand though
14:51:35 <Boxo> I keep getting type errors when using type signatures inside "where ..." expressions, like "couldn't match expected type a1 against inferred type a". Is there a way around this so I can use type sigs in wheres?
14:51:37 <Gracenotes> 3 where clauses vs. 1
14:52:46 <dons> woo. DEFUN 2009 schedule is up. http://www.defun2009.info/blog/2009/06/the-tutorial-schedule-is-now-ready/
14:52:47 <gwern> > ((100-1) `div` 2)
14:52:49 <lambdabot>   49
14:52:57 <gwern> > ((100-1) `rem` 2)
14:52:59 <lambdabot>   1
14:53:03 <Gracenotes> FUN
14:53:12 <ellisbben> Boxo: do you get those errors if you write those "where"s as "let"s?
14:53:25 <gwern> > ((100-1) `div` 2 + 1)
14:53:27 <lambdabot>   50
14:53:36 <gwern> > ((100-1) `div` 2 + 1) * (100+1)
14:53:38 <lambdabot>   5050
14:53:45 <gwern> > sum [1..100]
14:53:48 <lambdabot>   5050
14:53:51 <Gracenotes> hm. I wonder if storing a number's divmod with the number divmod'd by can be more space efficient than storing the number itself
14:53:54 <mauke> Boxo: yeah, you need scoped type variables (a ghc extension)
14:54:04 <Boxo> ellisbben: No, but you can't use type sigs in lets can you?
14:54:04 <Gracenotes> must depend on the divisor/modulo
14:54:10 <mauke> Boxo: sure you can
14:54:23 <Boxo> oh
14:54:28 <gwern> @check \x y ->  ((y-x) `div` 2 + x) * (x+y) == sum [x..y]
14:54:30 <lambdabot>   "Falsifiable, after 0 tests:\n-1\n0\n"
14:54:39 <Gracenotes> pesky n's..
14:54:47 <gwern> no, that's a newline
14:54:51 <Gracenotes> yeah, I know
14:54:55 <Gracenotes> they're much pseky
14:55:18 <ellisbben> :t let x = 4.00000001 :: Float in x
14:55:19 <lambdabot> Float
14:55:22 <RayNbow> > text "Falsifiable, after 0 tests:\n-1\n0\n"
14:55:24 <lambdabot>   Falsifiable, after 0 tests:
14:55:24 <lambdabot>  -1
14:55:24 <lambdabot>  0
14:55:43 <gwern> > sum [-1..0]
14:55:44 <lambdabot>   -1
14:55:45 <Boxo> ellisbben: I get the type errors even with lets if I use type sigs
14:56:00 <Gracenotes> @. elite check \x y -> ((y-x) `div` 2 + x) * (x+y) == sum [x..y]
14:56:02 <lambdabot> "fAL5iphiable, 4phteR 0 Te5tz:\n0\n-3\n"
14:56:35 <ellisbben> Boxo: perhaps you have type errors?
14:56:44 <gwern> hm, how can I rescue my formula...
14:56:55 <ellisbben> Boxo: or you have type errors if the type signatures are applied?
14:57:26 <Gracenotes> disallow negative numbers>
14:57:27 <Gracenotes> ?
14:57:49 <gwern> well, I could chuck in an if-then
14:58:10 <Gracenotes> I assume you arrived at it by algebraic manipulation from sum [1..y] - sum [1..x-1]
14:58:11 <Boxo> yes
14:58:11 <Boxo> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6096#a6096
14:58:32 <gwern> @check \x y ->  if (x >= 0 && y >= 0) then ((y-x) `div` 2 + x) * (x+y) else sum [x..y] == sum [x..y]
14:58:33 <lambdabot>   No instance for (GHC.Real.Integral GHC.Bool.Bool)
14:58:33 <lambdabot>    arising from a use of ...
14:58:53 <gwern> @check \x y ->  (if (x >= 0 && y >= 0) then ((y-x) `div` 2 + x) * (x+y) else sum [x..y]) == sum [x..y]
14:58:55 <lambdabot>   "Falsifiable, after 3 tests:\n1\n1\n"
14:59:01 <gwern> argh
14:59:43 <Gracenotes> @check \x y -> y < x || x < 0 || ((y-x) `div` 2 + x) * (x+y) == sum [x..y]
14:59:45 <lambdabot>   "Falsifiable, after 1 tests:\n0\n1\n"
14:59:49 <ellisbben> Boxo: I believe you want "id :: int" not "id : Int"
14:59:56 <ellisbben> :t id :: int
14:59:57 <lambdabot>     Couldn't match expected type `int' against inferred type `a -> a'
14:59:57 <lambdabot>       `int' is a rigid type variable bound by
14:59:57 <lambdabot>             an expression type signature at <interactive>:1:6
15:00:04 <ellisbben> :t id :: Int
15:00:06 <lambdabot>     Couldn't match expected type `Int' against inferred type `a -> a'
15:00:06 <lambdabot>     In the expression: id :: Int
15:00:10 <Gracenotes> @check \x y -> y < x || x <= 0 || ((y-x) `div` 2 + x) * (x+y) == sum [x..y]
15:00:12 <lambdabot>   "Falsifiable, after 2 tests:\n3\n3\n"
15:00:16 <Gracenotes> >_<
15:00:19 <Boxo> are we looking at the same paste, because there is no "id" in my paste
15:00:21 <Gracenotes> okay, one more try
15:00:23 <Gracenotes> @check \x y -> y <= x || x <= 0 || ((y-x) `div` 2 + x) * (x+y) == sum [x..y]
15:00:25 <lambdabot>   "Falsifiable, after 19 tests:\n2\n3\n"
15:00:50 <Gracenotes> looks like you're out of luck.. why not try starting with algebraic formulas and simplifying ...
15:00:50 <ellisbben> whoops, url copy failed for some reason
15:01:18 <wjt> Boxo: those type sigs need the scoped type variables extension, I think
15:01:37 <ellisbben> Boxo: you can get it to work if you put the type signature on the same line with the definition
15:01:39 <gwern> > (\a k -> (a+k/2)*(k+1)) 1 1 == sum [1..1]
15:01:41 <lambdabot>   False
15:01:53 <gwern> > sum [1..1]
15:01:54 <lambdabot>   1
15:01:57 <ellisbben> Boxo: as in "result = Just x :: Maybe a"... I think
15:02:18 <ellisbben> unless it doesn't like using 'a' in that scope...
15:02:24 <gwern> Gracenotes: eh, I've given up and am googling for answers
15:02:47 <Boxo> ellisbben, doesn't work, not even with ":: Maybe x"
15:02:51 <gwern> surely wikipedia knows a fast way to sum consecutive integers
15:02:59 <Boxo> oh well I'll look into that extension
15:03:09 <Jedai> ehird: How would you do it in OCaml ? I fail to see how it is easier in OCaml
15:03:10 <Boxo> thanks for the help
15:03:36 <gwern> [[Arithmetic progression]] looks helpful
15:03:54 <ehird> Jedai: I have not written it, but here's a relevant type error: Error: This expression has type ([> `Li ] as 'a) elt = 'a XHTML.M.elt
15:03:54 <ehird>        but is here used with type [< `A | `Abbr | `Acronym | `B | ETC ] elt = 'b XHTML.M.elt
15:04:07 <ehird> http://ocsigen.org/ 's XHTML.M module
15:04:29 <mauke> @check \x y -> y < x || x < 0 || ((y - x + 1) * (x + y) `div` 2) == sum [x..y]
15:04:30 <lambdabot>   "OK, passed 500 tests."
15:04:42 <Gracenotes> gwern: it really should just be, for sum [x..y], (x + y + x^2 + y^2)/2
15:05:06 <Jedai> ehird: that don't really tell me how the expression look
15:05:14 <Gracenotes> whether that could be simplified or not, I don't know
15:05:35 <ehird> Jedai: Indeed; all I know is that it means it is possible.
15:06:11 <ehird> Jedai: example code looks like "b [li [pcdata "foo"]];;"
15:06:18 <ehird> so it's definitely baggage-free
15:06:19 <gwern> @check \x y -> sum [x..y] == ((x + y + x^2 + x^2) / 2)
15:06:21 <lambdabot>   "Falsifiable, after 0 tests:\n-2.25\n1.0\n"
15:06:27 <Gracenotes> for integers
15:06:48 <gwern> @check \x::Integer y::Integer -> sum [x..y] == ((x + y + x^2 + x^2) / 2)
15:06:49 <lambdabot>   Parse error at "::Int..." (column 3)
15:06:50 <Gracenotes> and, actually I screwed up the formula :/
15:06:56 * gwern didn't really think that'd work
15:07:07 <Jedai> ehird: It use list notation, but the alternative I proposed wasn't really heavier
15:07:14 <Gracenotes> it's (y - x + y^2 - x^2) `div` 2)
15:07:20 <ehird> Jedai: Sure, but list notation is easier to skim
15:07:48 <gwern> @check \x y -> sum [x..y] == ((y - x + y^2 - x^2) `div` 2)
15:07:50 <Jedai> ehird: would b (li (pcdata "foo")) ? that's possible
15:07:50 <lambdabot>   "Falsifiable, after 1 tests:\n-1\n2\n"
15:07:57 <ehird> Jedai: That's only one child.
15:08:05 <mauke> > (y - x + 1) * (x + y)
15:08:07 <lambdabot>   (y - x + 1) * (x + y)
15:08:07 <gwern> Gracenotes: only positive ints you said?
15:08:10 <Gracenotes> you keep on forgetting about negative numbers and y>x :/
15:08:25 <Jedai> ehird: li (pcdata "foo" . ul "truc" . ul "truc")
15:08:28 <Gracenotes> sum [1..3] = 0 after all... and actually, that probably should be x-1 instead of x
15:08:42 <Gracenotes> depends on how inclusive you want the sum to be
15:08:56 <Jedai> ehird: that's one of the approach you'll find in the existing html (type-checked) library
15:09:28 <Gracenotes> @check \x y -> y <= x || x <= 0 || sum [x..y] == (y - (x-1) + y^2 - (x-1)^2) `div` 2
15:09:29 <lambdabot>   "OK, passed 500 tests."
15:09:30 <ehird> Jedai: Mm, I know.
15:09:32 <gwern> > (\x y -> ((x-y) * (x + y) / 2)) 1 100
15:09:34 <lambdabot>   -4999.5
15:09:44 <Gracenotes> well, at least the above works
15:09:44 <gwern> > (\x y -> ((y-x) * (x + y) / 2)) 1 100
15:09:46 <lambdabot>   4999.5
15:09:57 <gwern> > (\x y -> ((y-x) * (x + y) `div` 2)) 1 100
15:09:58 <lambdabot>   4999
15:10:11 <Gracenotes> perhaps it can be simplified
15:10:15 <Jedai> ehird: anyway, the first approach is obviously possible, in fact it may be what OCaml does, with smart constructors
15:10:36 <ehird> mm
15:10:43 <Jedai> if you do "li = C . Li" or things like that, you can put them in a list
15:10:57 <Jedai> ehird: without the weight of the extra constructor
15:11:24 <ehird> Jedai: oh, you are right!
15:11:35 <ehird> Jedai: Heyyy, that's awesome.
15:11:39 <Jedai> I definitely don't think OCaml can do better than Haskell in this field (though I would like a good module system in Haskell)
15:11:40 <ehird> Why didn't I think of that? I'm stoopid.
15:12:10 <Gracenotes> @check \x y -> y <= x || x <= 0 || sum [x..y] == ((x+y) * (y-x+1)) `div` 2
15:12:12 <lambdabot>   "OK, passed 500 tests."
15:12:15 <ehird> Jedai: "data Node = (NodeType a) => Node (forall a. a)", right?
15:12:21 <Gracenotes> gwern: ... was this what you were thinking bout?
15:12:43 <Jedai> ehird: "data Node = forall a . (NodeType a) => Node a"
15:12:48 <gwern> looks like it. it's the simplification of the gauss summation
15:12:53 <ehird> Righty
15:12:56 <ehird> s/ $//
15:12:57 <gwern> I wonder whether it works as a rewrite rule...
15:14:25 <Gracenotes> depends on whether every column in [x, x+1, ..., y-1, y] [y, y-1, ..., x+1, x] adds up to x+y, and if there are y-x+1 columns. essentially..
15:14:26 <gwern> hm. if we can make on 'sum (enumFromTo x y)', then we can rewrite to 'if x>=0 && y >= 0 then ((x+y) * (y-x+1)) `div` 2 else sum [x..y]'
15:14:26 <mauke> Gracenotes: isn't that exactly what I did?
15:14:33 <gwern> but wait, that's circular
15:14:46 <gwern> because it'd fire on the else branch again
15:14:57 <ehird> Jedai: How did you add constraints to that? "data ChildNode a = forall b. (Child a b) => ChildNode b"?
15:14:58 <Gracenotes> mauke: .. it seems so? sorreh :o
15:15:18 <Gracenotes> and on examination y - (x-1) + y^2 - (x-1)^2 does == (x+y) * (x-y+1)
15:15:24 <gwern> @info Enum
15:15:25 <lambdabot> Enum
15:15:47 <Jedai> ehird: Right, something like that ought to do
15:15:54 <gwern> > enumToFrom True False
15:15:56 <lambdabot>   Not in scope: `enumToFrom'
15:16:03 <gwern> > enumFromTo True False
15:16:05 <lambdabot>   []
15:16:18 <gwern> > enumFromTo 'x' 'z'
15:16:19 <lambdabot>   "xyz"
15:16:20 <ehird> Jedai: And I can write them all as newtypes, for OMG OPTIMIZED. ;)
15:16:30 <gwern> :t sum
15:16:32 <lambdabot> forall a. (Num a) => [a] -> a
15:16:52 <gwern> wonder if quickcheck tested with all the different Nums
15:17:40 <mauke> no, just Integer
15:17:58 <dons> who was this?? http://twitter.com/SirLyric/statuses/2256622635
15:18:30 <Gracenotes> incidentally I went to Barnes+Noble the other day, did not see haskell books (although I saw a cobol book)
15:19:11 <ehird> dons: it was dons!
15:19:16 <gwern> mauke: how could we make it check on the others like floats?
15:19:26 <dons> not me!!
15:19:28 <ehird>     A newtype constructor cannot have an existential context,
15:19:28 <ehird>       but `Node' does
15:19:30 <ehird> Well, darnit!
15:19:39 <ehird> dons: it was one of your infinite Haskell-zealotry clones!
15:19:39 <dons> though i was in powell's portland when someone bought a copy of RWH. fun times
15:19:52 <ehird> if you don't know about them, it's because your knowledge is lazily evaluated
15:19:58 <ehird> strictly need-to-know basis.
15:19:59 <mauke> gwern: floats don't support div
15:20:10 <gwern> oh
15:20:15 <Gracenotes> but spans support div
15:20:29 <gwern> come to think of it, that algo probably doesn't work on floats or reals anyway
15:21:01 <ehird> Jedai: "data Node a = forall b. (Child a b) => Node b", alas, does not work.
15:21:06 <ehird>     No instance for (Child a P)
15:21:06 <ehird>       arising from a use of `Node' at typesafexml.hs:12:4-7
15:21:08 <ehird> etc
15:21:10 <Boxo> How do you use a ghc extension like -XScopedTypeVariables? I started ghci with that command line argument, but this http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6096#a6096 still doesn't work
15:21:36 <Boxo> ":show languages" shows that it's active too
15:21:47 <Gracenotes> {# #}
15:21:58 <mauke> Boxo: heh :: forall a. a -> Maybe a
15:22:15 <Cale> Boxo: ScopedTypeVariables requires you to explicitly quantify the variables for them to be scoped.
15:22:23 <Elchin> hello how from Russia? and may help me to install wxhaskell
15:22:29 <Cale> Elchin: hello :)
15:22:38 <gwern> how do i upgrade kde
15:22:55 <ehird> gwern: *How does I patch KDE2 under FreeBSD?
15:22:58 <ehird> *do
15:23:02 <Boxo> okay, that worked. No idea what this forall thing is though, heh
15:23:04 <gwern> everyone's a critic
15:23:07 <Cale> Elchin: I think it is on Hackage now, so you can probably cabal install it :)
15:23:28 <ehird> [[In December 2007, the question again became the most popular one preceding the Internet conference of Ukrainian President Viktor Yushchenko. He gave an answer, saying the programmers at his secretariat are able to help patch KDE2 under different operating systems. He also recommended the adoption of newer software (a possible reference to the existence of KDE3 at the time). [5]]]
15:23:31 <ehird> ↑ i love that :)
15:24:07 <Elchin> hackage & what it meen ?
15:24:10 <Jedai> ehird: What's the code ?
15:24:15 <Cale> http://hackage.haskell.org/packages/archive/pkg-list.html
15:24:27 <ehird> Jedai: Basically "newtype UL = UL [Node UL]"
15:24:28 <Cale> Elchin: It's a repository of Haskell software.
15:24:36 <gwern> > sin pi
15:24:37 <lambdabot>   1.2246467991473532e-16
15:24:41 <ehird> Jedai: Same if I s/newtype/data/.
15:24:48 <gwern> :t pi
15:24:50 <lambdabot> forall a. (Floating a) => a
15:24:55 <ehird> no, wait
15:24:59 <ehird> Jedai: the errors are in:
15:25:01 <ehird> p = Node . P
15:25:02 <Cale> Elchin: cabal-install is a tool which downloads and installs packages from there
15:25:07 <gwern> hm. it's been a while since I did geometry, but sin pi == 0?
15:25:24 <ehird> Jedai: because "Node :: (Child a b) => b -> Node a", P :: [Node P] -> P
15:25:30 <ehird> Jedai: and there's no (Child a P) instance
15:25:36 <ehird> it's haskell being hyper-literal :-)
15:25:40 <Cale> gwern: That number is very close to 0
15:25:54 <Cale> gwern: There are rounding errors.
15:26:08 <davidL> > sin pi :: CReal
15:26:09 <lambdabot>   0.0
15:26:12 <gwern> but I guess there would be no harm in a rewrite rule making sin pi = 0
15:26:20 <Cale> hmm
15:26:58 <copumpkin> 'twould be a sin
15:27:01 <Jedai> ehird: it works for me
15:27:22 <gwern> @slap copumpkin
15:27:23 <lambdabot> why on earth would I slap copumpkin?
15:27:29 <ehird> Jedai: maybe I need to type-signature-annotateify ul/li/p
15:27:33 * copumpkin hugs lambdabot
15:27:58 <ehird> Jedai: yep
15:28:05 <ehird> Jedai: with "ul :: (Child a UL) => [Node UL] -> Node a" everything is peaches and happiness
15:28:07 <Jedai> ehird: either you annotate or you get rid of the monomorphism restriction or you put a point
15:28:24 <Cale> gwern: The trouble is, that rule would essentially only apply to cases where you syntactically wrote sin pi, and not necessarily to cases where you wrote sin x and then x happened to be pi
15:28:27 <ehird> Jedai: i'll generate all of these verbose declarations with template haskell in the final thing
15:28:32 <ehird> so I'll go for the type sig solution
15:28:39 <gwern> Cale: better than nothing, though
15:28:50 <ehird> *Main> p []
15:28:50 <ehird> <interactive>:1:0:
15:28:51 <ehird>     No instance for (Child a P)
15:28:51 <Cale> gwern: That would produce inconsistencies in the result though, which I think is worse.
15:28:55 <Jedai> ehird: Right that seems the best solution, the ideal being to take a DTD input
15:28:57 <gwern> @src sin
15:28:58 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
15:29:04 <ehird> >:|
15:29:07 <Cale> gwern: It would break the referential transparency of the sin function.
15:29:09 <gwern> .
15:29:20 <ehird> Jedai: doesn't work when you call it
15:29:27 <Jedai> ehird: That's what (I don't remember the name, I have a crummy memory for names) library does
15:30:19 <Jedai> ehird: my exemple works (for now I only have HTML and P types but it works)
15:30:30 <ehird> Jedai: hpaste plz? :)
15:31:58 <Jedai> ehird: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6097#a6097
15:32:43 <ehird> Jedai: Yeah, uh, make "html = Node . Html".
15:32:51 <ehird> Jedai: It works because your "p" is trivial.
15:33:05 <ehird> Hm, wait.
15:33:14 <ehird> Jedai: (li []) doesn't type but (UL [li []]) does.
15:33:18 <ehird> So I guess it's all a matter of context.
15:33:59 <ehird> Jedai: It would be nice to get this working without a top-level wrapper, though.
15:34:12 <ehird> Or at least with a more human type for things than "(Child a UL) => Node a".
15:34:22 <ehird> I guess that could be "NodeOf UL".
15:34:31 <Jedai> ehird: Are you sure li [] doesn't type ? Or is it just defaulting and monomorphism restriction working against you in GHCI
15:34:41 <ehird> I think it's ghci, yeah
15:36:07 <jmillikin> @pl f x = Just $ f' x
15:36:07 <lambdabot> f = Just . f'
15:36:19 <mmorrow> pdp11 asm code http://www.psych.usyd.edu.au/pdp-11/hints.html
15:36:48 <ehird> Jedai: Meh, seems like the ugly "(Child a UL) => Node a" type can't be solved easily.
15:37:07 <mmorrow> "After loading memory with the trap catcher, deposit 777 into location 1000 as start (at location 1000). The processor should loop at 1000."
15:37:50 <ehird> Jedai: also, taking a DTD would be possible, but DTDs are yuck
15:38:13 <Jedai> ehird: I don't think it can, sorry, on the other hand your users should try to use inference as much as possible
15:38:20 <mmorrow> "If the processor doesn't halt, then your clock isn't running. If it halts at 6, then the clock register is missing."
15:38:23 <mmorrow> so classic
15:38:47 <ehird> Jedai: Dunno about that; if I write a function, say, "page :: String -> HTMLStuff -> HTMLStuff" I'd type-annotate it.
15:38:56 <jmillikin> @pl f x = (a x) . b
15:38:57 <lambdabot> f = (. b) . a
15:38:58 <mmorrow> oh noes, teh clock register si missing!
15:39:05 <ehird> I've always avoided inferring top-level definitions.
15:44:10 <hackagebot> control-monad-queue 0.0.9 - Resuable corecursive queues, via continuations. (LeonSmith)
15:47:12 <mmorrow> that sounds interesting
15:47:17 <BMeph> " corecursive queues, via continuations"? That sounds complex. Of course, using finger trees for sequences doesn't sound any simpler... :\
15:47:29 <lpsmith> they outperform finger trees
15:48:33 <BMeph> lpsmith: At what - massages? 'Cause if I were getting a massage, I'd expect finger trees to be really good at that... ;p
15:48:42 <uzytkownik> @pl \s -> runNNTP m s >>= either (return . Left) (flip (runNNTP . k) s)
15:48:42 <lambdabot> ap ((>>=) . runNNTP m) (either (return . Left) . flip (runNNTP . k))
15:48:45 <lpsmith> hah :-)
15:48:59 <mauke> massage queues, via finger trees
15:49:27 <uzytkownik> @hoogle ap
15:49:28 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
15:49:28 <lambdabot> Control.Arrow app :: ArrowApply a => a (a b c, b) c
15:49:28 <lambdabot> Language.Haskell.TH AppE :: Exp -> Exp -> Exp
15:49:30 * BMeph smells the makings of an April 1st hackage submission... ;p
15:50:35 <uzytkownik> @pl \m k -> NNTP (\s -> runNNTP m s >>= either (return . Left) (flip (runNNTP . k) s))
15:50:35 <lambdabot> (NNTP .) . (. ((either (return . Left) .) . flip . (runNNTP .))) . ap . ((>>=) .) . runNNTP
15:50:49 <BMeph> @pl \g f -> (. f) . g . f
15:50:49 <lambdabot> ap ((.) . flip (.)) . (.)
15:51:18 <Cale> Hey, are there any Haskell users on Windows here? Elchin is having trouble installing wxHaskell, since the C library isn't present. What's the right way to install it on Windows?
15:51:30 <ehird> 23:50 uzytkownik: @pl \m k -> NNTP (\s -> runNNTP m s >>= either (return . Left) (flip (runNNTP . k) s))
15:51:31 <ehird> 23:50 lambdabot: (NNTP .) . (. ((either (return . Left) .) . flip . (runNNTP .))) . ap . ((>>=) .) . runNNTP
15:51:35 <lpsmith> Haskell is the reason I use unix :-P
15:51:35 <ehird> now there's an example of pointless code!
15:51:52 * BMeph uses Haskell on Windows, but has NO idea how to get wxHaskell working on it...
15:52:22 <lpsmith> Seriously.   Back about 8 or 9 years ago,  GHC was much happier on Unix,  and was the reason I switched.   Now it wouldn't make that big a difference anymore
15:52:23 <BMeph> lpsmith: Unix is the reason I use Haskell. ;)
15:52:24 <Botje> install the C library first?
15:52:26 <uzytkownik> ehird: That's the reason I stay with the original code...
15:52:37 <ehird> :-)
15:53:10 <dmwit> That NNTP (\s -> runNNTP m s >>= ...) looks an awful lot like the State monad...
15:56:36 <lpsmith> I should add,  corecursive queues are faster than finger trees,  but nowhere near as general.  For starters, they aren't persistent,  which is the reason my library has a monadic interface.
15:57:27 <mmorrow> lpsmith: interesting lib
15:58:44 <mmorrow> ooh, cool http://www.csse.monash.edu.au/~lloyd/tildeFP/1989SPE/
15:58:59 <mmorrow> , vacuum (fix (\x -> 0 : x))
15:59:04 <lunabot>  [(0,[1,0]),(1,[])]
16:01:39 <mmorrow> this is a mind-bender http://moonpatio.com/vacuum/gallery/dlist.html
16:02:02 <mmorrow> (code from http://www.haskell.org/haskellwiki/Tying_the_Knot)
16:03:25 <monochrom> Eh? What is vacuum?
16:03:58 <lpsmith> hmm... what do I have to do to get the haddocks to appear on the hackage page?
16:04:16 <hackagebot> dlist 0.5 - Differences lists (DonaldStewart)
16:04:17 <enolan> Wait for a cron job to run I think.
16:04:26 <lpsmith> ahh, ok
16:05:24 <lpsmith> @def vacuum
16:05:25 <lambdabot> Maybe you meant: bf let
16:05:26 <mmorrow> monochrom: http://moonpatio.com/vacuum/
16:06:15 <lpsmith> sweet, this could be quite useful...
16:06:16 <monochrom> Ah, so [(0,[1,0]),(1,[])] is not supposed to be readable, just instructions to draw a graph.
16:06:31 <monochrom> (adjacency list)
16:07:00 <mmorrow> oh
16:07:12 <mmorrow> yes, just a plain adjacency list rep
16:07:27 <lpsmith> does vacuum disturb thunks,  or does it leave those alone?
16:07:31 <mmorrow> the literals don't show up
16:07:42 <mmorrow> lpsmith: it has to force them
16:08:02 <mmorrow> lpsmith: it uses getClosureData# from ghc-prim
16:08:27 <mmorrow> which doesn't work how you'd like it to if everything isn't `seq`ed
16:10:24 <mmorrow> (if the top-level isn't forced, it just always gives you an "AP" node, and if you force the top-level, but nothing else, it doesn't appear that THUNKs get updated (through the lens of getClosureData#), so i'm not sure if it's jsut an inherent limitation of getClosuredata# or what exactly the cause is)
16:10:45 <lpsmith> hmm
16:12:17 <mmorrow> and you segfault if you follow the ptrs in THUNKs
16:13:39 <uzytkownik> @pl \f m -> NNTP $ (arrowNNTP m >>> right (arr f))
16:13:39 <lambdabot> (NNTP .) . flip ((>>>) . arrowNNTP) . right . arr
16:16:26 <lpsmith> Wait,  are you referring to GHC.Prim, or something else?   I don't see getClosureData# in the docs anyway...
16:20:41 <int-e> @index unpackClosure#
16:20:41 <lambdabot> bzzt
16:22:34 <int-e> getClosureData is defined in the RtClosureInspect module the ghc package. unpackClosure# is the underlying primop.
16:25:13 <uzytkownik> @hoogle right
16:25:13 <lambdabot> Control.Arrow right :: ArrowChoice a => a b c -> a (Either d b) (Either d c)
16:25:13 <lambdabot> Prelude Right :: b -> Either a b
16:25:13 <lambdabot> Data.Either Right :: b -> Either a b
16:49:06 * Cale grumbles about wxcore from Hackage's build system being broken. It seems to forget to send the --user option to its configure script.
16:58:24 <uzytkownik> @pl \k m -> liftM k `fmap` runNNTP m
16:58:25 <lambdabot> (. runNNTP) . fmap . fmap
16:59:22 <uzytkownik> @pl \k m -> NNTP (liftM k `fmap` runNNTP m)
16:59:22 <lambdabot> (NNTP .) . (. runNNTP) . fmap . fmap
17:00:26 <copumpkin> I love . ) . ( .
17:01:58 <mamalujo> hm, tried installing haskell-platform on debian. make fails with configure: error: editline not found, so this package cannot be built. I installed libeditline-dev, didnt change its mind. Is there anything I can do?
17:05:23 <Alpounet> mamalujo, it still gives the same error ?
17:05:34 <mamalujo> yes
17:07:08 <Alpounet> hmm
17:07:09 <Alpounet> weird
17:07:17 <Alpounet> maybe version mismatch ?
17:07:30 <mamalujo> hm, possible
17:07:32 <Alpounet> (btw, haskell-platform is likely to come, little by little)
17:07:58 <uzytkownik> @pl \m k -> runNNTP m s >>= flip(\x -> runNNTP (k x)) s
17:07:58 <lambdabot> (. flip (flip . (runNNTP .)) s) . (>>=) . flip runNNTP s
17:08:19 <uzytkownik> @pl flip(\x -> runNNTP (k x))
17:08:19 <lambdabot> flip (runNNTP . k)
17:14:39 <copumpkin> how does the haskell ffi do vararg functions?
17:15:40 <mamalujo> hm, thought it would be more practical to install common stuff in one package, rather than hunting around. Will see if editline from tarball makes the platform more cooperative :)
17:24:34 <Alpounet> mamalujo, you can contact the debian-haskell team to help them providing platform on unstable (at least for now) ASAP
17:24:52 <Alpounet> if you want to, of course
17:26:42 <mamalujo> Oh, I'm interested both in haskell and debian maintainership, only rather noobish - was just reading the new maintainers guide, first time. So I cannot promise much yet, but I did have helping debian-haskell in mind
17:26:50 <uzytkownik> @pl \f m -> NNTP (return . f <=< runNNTP m)
17:26:50 <lambdabot> (line 1, column 26):
17:26:50 <lambdabot> unexpected "=" or "<"
17:26:50 <lambdabot> expecting variable, "(", ".", space, operator or ")"
17:26:50 <lambdabot> ambiguous use of a left associative operator
17:26:55 * EmielRegis http://www.youtube.com/watch?v=U8BWBn26bX0 best music video ever
17:28:29 <Alpounet> mamalujo, great, I'm also reading the guide currently
17:28:54 <Alpounet> hopefully we'd help on making Debian a great place for Haskell development.
17:29:07 <mamalujo>  :)
17:30:29 <copumpkin> I guess I'll just make a bunch of ffi imports for common lengths
17:30:40 <uzytkownik> @pl \x -> NNTP (\_ -> return x)
17:30:41 <lambdabot> NNTP . const . return
17:30:43 <erikc> im looking forward to the new avalanches album
17:32:03 <mmorrow> lpsmith: err, yeah i meant unpackClosure# (so name names with closure :)
17:32:09 <ehird> > let infiniteRange start step = start : infiniteRange (start+step) step in infiniteRange 3 2
17:32:10 <lambdabot>   [3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53,...
17:40:31 <mmorrow> *so _many_ names ...
17:40:59 <monochrom> names are just numbers.
17:41:36 <mmorrow> pictures are worth one thousand words.
17:42:27 <monochrom> an equation is worth a thousand pictures
17:43:25 <Tsion> a picture of an equation is worth...
17:43:44 <lpsmith> lol,  I think it depends on the idea you are trying to convey ;-)
17:43:46 <monochrom> a fixed-point equation
17:44:11 <lpsmith> Sometimes pictures are best,  sometimes formulas,  and sometimes natural language :-P
17:44:55 <mamalujo> well, i think the platform likes editline tarballs better, now at least I got a different error, and have hopes for the current try :)
17:47:59 <Alpounet> ok
17:53:21 * mmorrow pictures escher hands drawing equations on each other's wrists
17:54:11 <mamalujo> mmorrow, thats not recursive enough for escher
17:54:33 <mmorrow> true
17:55:15 <karlw> Which emacs mode do most people use?
17:56:38 <Alpounet> haskell-mode ?
17:56:58 <karlw> I guess so.
17:57:40 <karlw> Maybe I just don't like indentation sensitive syntax.
17:58:52 <monochrom> use elisp mode :)
18:00:56 <monochrom> In Escher's works you only see mutual recursion among 2 or more participants. You don't see the same kind of recursion as x = x. You don't see a hand drawing itself.
18:01:41 <mmorrow> heh, that would be a cool drawing if someone made that one
18:01:56 <mmorrow> the single hand drawing itself from nothing
18:03:14 <karlw> May one put guards in a lambda expression?
18:03:59 <karlw> Or have ``complex'' lambdas?
18:04:34 <roconnor> nope
18:04:56 <roconnor> only one pattern per variable
18:05:09 <Saizan_> karlw: there's kuribas' indentation mode which is much better than the standard one, i read
18:06:15 <Alpounet> karlw, if you need such a thing, you have to write a named function
18:06:28 <zloog> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6100#a6100  <-- Does anyone know what is wrong with my type for subscribeTVSortMethod?
18:06:38 <Alpounet> you may want to do so in a where clause
18:07:14 <karlw> Saizan: Yeah, the consensus seems to be ``use where.''
18:07:59 <Alpounet> zloog, 'a' and 'b' (at the end of your type) are undeclared
18:08:25 <Alpounet> you maybe want :       subscribeTVSortMethod :: MVar Maybe (TreeViewColumn, forall a. forall b. (a->b))  -- or something like that
18:08:27 <karlw> Well, that's one superiority of Lisp I suppose *cough* *cough*
18:08:37 * karlw ducks
18:09:01 <zloog> Alpounet: Thanks, I just want to be able to pass around a comparison function. This is probably where i need to learn what forall actually does
18:09:50 <karlw> oh, I meant Alpounet
18:10:00 <Alpounet> @where existential
18:10:00 <lambdabot> I know nothing about existential.
18:10:06 <Alpounet> hmm
18:10:13 <Twey> karlw: How is it a superiority of Lisp?  CL doesn't have patterns at all :-P
18:10:20 <Twey> Or guards!
18:10:23 <Alpounet> zloog, look for "Existential types" on HaskellWiki
18:11:08 <karlw> Twey: CL has case
18:11:50 <Alpounet> CL doesn't check for exhaustivity of catched-cases
18:12:22 <karlw> And you can write a more general version of case
18:12:44 <karlw> Though macros are a pain.
18:15:36 <karlw> \not \exist x . {x | perfect language}
18:16:08 <Twey> karlw: You can put a case in a lambda
18:16:16 <Twey> Just not a pattern guard
18:17:00 <Twey> > (\x -> case x of 3 -> 1; 2 -> 5) 3
18:17:01 <lambdabot>   1
18:19:01 <dmwit> karlw: When you say "a more general version of case", are you referring to cond?  If so, you can write cond in Haskell, too.
18:19:10 <dmwit> And you don't need macros to do it, thanks to lazy evaluation.
18:19:17 <Twey> 02:16:08 < Twey> karlw: You can put a case in a lambda
18:19:34 <Twey> Inside the lambda, you can do anything you can do in any expression
18:22:20 <karlw> dmwit: I know, macros are a big problem with strict languages :-)
18:22:32 <dmwit> > let cond = snd . head . filter fst in cond [(3 == 5, 72), (isAlpha ' ', 73), (otherwise, 0)]
18:22:33 <lambdabot>   0
18:23:17 <dmwit> > let foo | 3 == 5 = 72 | isAlpha ' ' == 73 | otherwise = 0 in foo
18:23:18 <lambdabot>   <no location info>: parse error on input `|'
18:23:41 <dmwit> Oh, man, do guards only work for functions?  Bummer.
18:23:52 <dmwit> > let foo() | 3 == 5 = 72 | isAlpha ' ' == 73 | otherwise = 0 in foo()
18:23:53 <lambdabot>   <no location info>: parse error on input `|'
18:24:06 <dmwit> uh
18:24:38 <aavogt> > let foo | 3 == 5 = 72; | isAlpha ' ' == 73; | otherwise = 0 in foo
18:24:40 <lambdabot>   <no location info>: parse error on input `|'
18:24:42 <karlw> Guards are a special syntax
18:24:56 <karlw> I think.
18:25:11 <dmwit> Yes, they are.
18:25:19 <dmwit> But the thing I wrote above works verbatim here.
18:25:26 <Alpounet> > let foo | True = 1 | False = 0
18:25:28 <lambdabot>   not an expression: `let foo | True = 1 | False = 0'
18:25:32 <Alpounet> > let foo | True = 1 | False = 0 in foo
18:25:34 <lambdabot>   1
18:25:55 <Alpounet> > let foo | 1==1 = 1 | otherwise = 0 in foo
18:25:57 <lambdabot>   1
18:26:03 <Alpounet> > let foo | 1==2 = 1 | otherwise = 0 in foo
18:26:05 <lambdabot>   0
18:26:27 <aavogt> > let foo |?1==2 = 1 |?otherwise = 0 in foo
18:26:29 <lambdabot>   <no location info>: Parse error in pattern
18:26:37 <dmwit> aavogt: 1==2 isn't an argument
18:26:39 * karlw will probably just use where
18:26:47 <Alpounet> dmwit, oh, "== 73", there's an additional "="
18:26:55 <Alpounet> that's why your code didn't get evaluated
18:26:56 <dmwit> Alpounet: Oh, duh.
18:27:10 <aavogt> Alpounet: which character did you put after the | ?
18:27:14 <dmwit> > let foo | 3 == 5 = 72 | isAlpha ' ' = 73 | otherwise = 0 in foo
18:27:16 <lambdabot>   0
18:27:27 <dmwit> aavogt: just a normal space works fine
18:27:29 <Alpounet> avalan, space
18:28:13 <aavogt> hmm, shows up as ?, since it was not plain ascii
18:28:33 <dmwit> whoa
18:28:37 <dmwit> It's char 160.
18:28:54 <dmwit> > map chr [96, 160, 96]
18:28:55 <lambdabot>   "`\160`"
18:29:11 <Alpounet> aavogt, it wasn't voluntary heh.
18:29:19 <dmwit> > expr (map chr [97, 160, 97]) :: Expr
18:29:21 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
18:29:23 <dmwit> > fun (map chr [97, 160, 97]) :: Expr
18:29:25 <lambdabot>   a a
18:29:31 <dmwit> huh
18:29:50 <aavogt> looks the same here =)
18:35:28 * dmwit notes that 160 is 0b1010 0000 and 32 is 0b0010 0000, so a simple preprocessor in lambdabot that turned off all the high bits in each octet would convert '\160' to a space in lambdabot's output
19:15:02 <xoclipse> if i'm sending a float over the network in 4 bytes, what is the easiest way in haskell to decode this?
19:15:14 <xoclipse> i've been using data.binary.get for extracting data
19:15:26 <xoclipse> i can pull this into a word32...but then i'm not sure how to convert it to a float
19:23:26 <monochrom> Supposedly data.binary is all you need.
19:23:46 <monochrom> I mean the "binary" package. I don't know which modules in it.
19:31:09 <heatsink> I just ran into a weird bug: GHC crashes if I try to compile test.hs
19:31:19 <jmillikin> #pl f x = (g x) >>= Just . format
19:31:22 <jmillikin> @pl f x = (g x) >>= Just . format
19:31:22 <lambdabot> f = (Just . format =<<) . g
19:32:02 <heatsink> It's a weird bug because if I rename the file to anything else, it works fine.
19:32:32 <copumpkin> mmorrow: you around?
19:43:51 * SubStack is discovering all sorts of curious monadic and applicative behaviors
19:47:15 <sohum> why does haskell complain on duplicate type signatures? shouldn't it be able to dispatch the appropriate function in any given scenario, assuming non-overlapping signatures?
19:47:57 <roconnor> one function cannot have two signatures
19:49:14 <aavogt> sohum: dispatching the apropriate function in any given scenario sounds like typeclasses
19:50:24 <sohum> aavogt: sure, so what's stopping the compiler from creating implicit typeclasses in a duplicate type signature situation? Probably with a warning that that's what it's doing
19:51:23 <aavogt> sanity? Explain what you mean by 'non-overlapping signatures'
19:52:22 <sohum> like, not Integer and Int (though that could be resolved by picking the most specific, even). Bool and Int, also - they have nothing to do with each other
19:53:05 <roconnor> Integer and Int have nothing to do with each other either
19:53:16 <sohum> sorry, meant Integral
19:54:14 <roconnor> Integral isn't a type
19:54:56 <roconnor> anyhow, you need to specify a type class to make dynamic dispatch
19:56:07 <roconnor> I'm not sure how you'd do type checking if you have two functions with the same name and different signatures
19:56:15 <roconnor> especially in the presence of polymorphism
19:56:33 <roconnor> f :: a -> Foo;   f :: Bar -> a
19:58:05 <aavogt> roconnor: why, you'd have the compiler arbitrarily pick a version!
19:58:18 <roconnor> aavogt: of course!
19:58:30 <roconnor> aavogt: let's have it always pick the one you don't want. :)
19:59:01 <heatsink> I want GHC to allow overloading so that I can use the typechecker as a SAT solver.
19:59:26 <roconnor> I think GHC already does that with undecidable instances
20:01:09 <heatsink> Oh, you're right.
20:03:07 <sohum> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2834
20:03:10 <SamB> roconnor: isn't what it does now basically a time-saving version of picking the one you don't want?
20:03:32 <roconnor> you mean throwing a compiler error?
20:03:52 <SamB> yeah
20:04:11 <roconnor> nah.  Programmers prefer to wait until runtime to find their errors.
20:04:22 <roconnor> that way they are less likely to find them at all
20:04:33 <roconnor> and hence don't need to fix it
20:04:40 <heatsink> hah
20:05:08 <roconnor> sohum: now do it for f :: a -> Bool and  f :: Foo -> a
20:05:48 <sohum> roconnor: presumably there'd be some restrictions to when the rewriting can occur
20:08:19 <heatsink> sohum, There's a reason not to make the type system too automatic.
20:08:24 <heatsink> If the compiler is too smart, then when something doesn't typecheck, the reason will be complicated and hard for humans to understand.
20:09:34 <heatsink> sohum, Have you run into a situation where your code has a type error, and GHC reports a bug somewhere other than where you actually made the mistake?
20:10:06 <roconnor> sohum: when you go further you need Multiparamter type classes
20:10:28 <roconnor> sohum: and MPTC is genrally useless without functional depencies
20:10:32 <roconnor> or something similar
20:10:42 <roconnor> and you won't be able to infer fun deps
20:21:36 <monochrom> No, the real reason is this: if the compiler is too smart, you will be unemployed.
20:24:52 <monochrom> Anyway, Haskell98 is defined to not "implicitly create typeclasses". That's a definition. There is no "why".
20:26:23 <jmillikin> In this pastebin, why does using a type class in the signature of "typeError" cause an error? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2835
20:26:51 <roconnor> monochrom: of course there is a why
20:29:04 <heatsink> jmillikin, The error is not because of the type class constraint
20:29:16 <heatsink> > let x = 1.0 :: Double
20:29:17 <lambdabot>   not an expression: `let x = 1.0 :: Double'
20:30:12 <jmillikin> heatsink: if I change the signature to this, it works: typeError :: Int -> [TestData]
20:30:19 <heatsink> Right
20:30:32 <heatsink> > [1.0 :: Double] :: [a]
20:30:34 <lambdabot>   Couldn't match expected type `a'
20:30:40 <heatsink> > [1.0 :: Double] :: [Double]
20:30:41 <lambdabot>   [1.0]
20:31:01 <jmillikin> I don't understand; is there no way to return a list of some object that's marked as belonging to a class?
20:31:11 <jmillikin> *of some type
20:31:30 <heatsink> TestData belongs to the class.
20:31:47 <heatsink> Can you be more specific about what you want to return?
20:31:59 <jmillikin> Sure, I'll put up another paste bin
20:32:17 <aavogt> @src userError
20:32:17 <lambdabot> Source not found. My brain just exploded
20:33:18 <jmillikin> I'd like to have some effect like this: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2836
20:33:28 <monochrom> The call site, not the callee, decides which instance of TestClass he wants.
20:33:39 <monochrom> You are making that decision in the callee.
20:35:04 <monochrom> Think of it as the parent deciding the child's career.
20:35:20 <Gracenotes> eek
20:36:51 <heatsink> As monocrhom is saying, your type lets the caller choose a type.  The caller could choose (typeError 0) :: [TestData], or it could choose (typeError 0) :: [ZeroData].
20:37:56 <heatsink> Do you want typeError to decide what type is in the list, and all list elements have the same type?
20:38:05 <jmillikin> Yes
20:38:21 <heatsink> The caller will only know that the list contains TestClass instances, it won't be able to get any more information.
20:38:48 <jmillikin> That's OK, all it needs is to call instance methods upon the returned values
20:38:56 <monochrom> This attempt looks like translating from OO word for word.
20:39:09 <sohum> heatsink, roconnor: hm, fair enough. danke.
20:39:10 <jmillikin> I'm a relatively recent convert
20:39:53 <monochrom> Why is "data Whatever = ZeroData | TestData Int" not acceptable?
20:41:10 <jmillikin> I'd like the class to be extensible, so that future data types may be added without having to modify the core code.
20:41:39 <SamB> monochrom: you mean OO Writer?
20:41:47 <heatsink> monochrom, he probably wants an existential type then.
20:42:10 <monochrom> "extensible" is an overrated over-abused abuse.
20:42:58 <ellisbben> jmillikin: if you use the typeclass route, you have to write an instance for every type you add
20:43:21 <monochrom> In more concrete terms, don't worry about the future now, come back to re-factor when you actually know what extension is necessary.
20:43:48 <ellisbben> jmillikin: that's about as hard as adding cases to the core functions that work with an algebraic data type
20:43:53 <mike-burns> The "You Ain't Gonna Need It" principle.
20:44:14 <SamB> yay yagni
20:44:30 <jmillikin> The instances can be in external modules though, right? Adding instances wouldn't require modifications to core functions.
20:44:45 <ellisbben> absolutely true.
20:44:54 <aavogt> @quote orphan instance
20:44:54 <lambdabot> No quotes for this person. You untyped fool!
20:44:57 <SamB> jmillikin: but adding methods would!
20:44:58 <aavogt> @quote orphan
20:44:58 <lambdabot> No quotes match. Where did you learn to type?
20:45:12 <shapr> @quote me
20:45:13 <lambdabot> ghc says: Malformed constructor signature
20:45:32 <jmillikin> That's true, but I doubt adding additional functions to the class would be required.
20:45:33 <shapr> @quote you
20:45:33 <lambdabot> qwe1234 says: you cannot write a lisp compiler that is as good as a C compiler
20:45:56 <ellisbben> jmillikin: I'm curious; what's the use case?
20:46:22 <mike-burns> jmillikin: Sounds like you want OO; perhaps Haskell isn't the solution to the problem (or perhaps you're approaching it wrong).
20:47:09 <jmillikin> I'm writing an XMPP bot library. I'd like to convert HXT's XmlTree type to varying kinds of XMPP stanzas. The stanzas each have functions to get to/from addresses, and render themselves to an XML tree in return.
20:47:30 <jmillikin> So I have class Stanza, and data Message, data Presence, etc
20:48:07 <jmillikin> The problem is since the set of stanzas that may appear within the XMPP stream isn't fixed, I'd like to be able to pass a list of functions to the parser, have it match on the namespace/element name pair, and return a value of the appropriate data type.
20:48:38 <ellisbben> hmmm...
20:48:41 <monochrom> This is why I hate most OO "design" courses. The TA shows you a task description and a fine data structure for it, and asks "what's wrong", as if the data structure doesn't already do the job. (Fact is, it already does.) And the model answer is, "oh, it doesn't anticipate this plausible future extension, it doesn't anticipate that other plausible future extension..." Speculative hypothetical armchair prophet nonsense. Look, t
20:48:41 <monochrom> he course description did not say "lateral thinking"! Fact is, when the time comes when the customer wants an extension, it will be nothing like all those 5 "plausible extensions" your TA said, in fact the customer's real extension will be working against the TA's 5 speculated extensions. You listen to the TA and you are screwed.
20:48:51 <ellisbben> have you looked at Data.Generics?
20:48:54 <mike-burns> Just to be clear, typeclasses are not the same as OO's classes. They are more similar to interfaces.
20:49:39 <jmillikin> Yes, I am not (consciously) trying to imitate OO classes. The "Stanza" class defines a common set of functions that apply to any Stanza.
20:50:56 <mike-burns> monochrom: Totally agreed; typically the client wants everything refactored and changed instead of extended.
20:51:48 <ellisbben> Hmm... so, you want to select Stanzas of a particular kind from a collection of heterogeneous Stanzas and call only Stanza functions on them?
20:52:47 <jmillikin> I don't need to select stanzas of a particular data class
20:53:28 <ellisbben> sounds like the typeclass route makes sense
20:57:52 <ellisbben> I don't know about the alternatives, but you can use existentially quantified types... data StanzaBox = forall a. Stanza a => StanzaBox {s_unbox :: a}
20:58:15 <ellisbben> make a Stanza instance for StanzaBox
20:58:46 <jmillikin> Thanks; I will try that, along with the Data.Generics module mentioned earlier
20:59:26 <ellisbben> (and I'm sure I'll piss someone off by saying) make a box function which uses cast to determine whether its argument is a StanzaBox and only boxes the value if the argument isn't a StanzaBox
21:00:12 <ellisbben> because you could end up with arbitrarily deep nesting of boxes... :)
21:03:31 <roconnor> is isabelle/isar based on set theory?
21:34:09 <jimmyjazz14> anyone know of a good explaination for liftIO online?
21:35:51 <monochrom> You're writing code in something like StateT Blah IO Int, and at some point in the code you want to print out a string. Instead of saying putStrLn "hello", you say liftIO (putStrLn "hello") . That is all.
21:36:49 <Twey> :t liftIO
21:36:51 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
21:37:19 <Twey> It's equivalent to n lifts, where n is the number of lifts required to get to an IO monad
21:38:00 <Twey> @index liftIO
21:38:01 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
21:38:30 <jimmyjazz14> Twey: okay, I still don't understand monads, damn I thought I did
21:38:56 <Twey> @src lift
21:38:56 <jimmyjazz14> I better go reread that chapter
21:38:56 <lambdabot> Source not found. My pet ferret can type better than you!
21:39:03 <Twey> jimmyjazz14: It's monad transformers you want
21:39:51 <Twey> lift is a class function, isn't it?  Of which class?
21:39:59 <Twey> Oh, MonadTrans I guess
21:40:32 <monochrom> StateT is one of those MonadTrans too and enjoys lift.
21:40:52 <jimmyjazz14> so tranforming one monad to another?
21:42:16 <monochrom> I guess you will need to read a tutorial on "monad transformers" properly.
21:44:13 <jimmyjazz14> monochrom: probably
21:46:09 <Twey> jimmyjazz14: In a nutshell, a monad transformer is a monad that allows you to wrap another monad inside it
21:46:48 <Twey> lift is a function that takes an action and ‘lifts’ it into an inner monad
21:47:19 <Twey> (or rather, takes an action in that inner monad and ‘lifts’ it into the outer monad — the spatial metaphors make my head spin a bit)
21:48:05 <jimmyjazz14> Twey: ah okay, I think its starting to come back to me a little now
21:48:57 <Twey> For example, if we have an action of type StateT foo IO bar, then the actions we're using are in State: if we want to execute an action in IO, then we have to lift it like so: lift $ print "baz"
21:49:36 <Twey> Where print "baz" :: IO (), and lift $ print "baz" :: StateT foo IO ()
22:01:39 <ray> they should be called monad stackers
22:01:46 <ray> if only that didn't sound like fast food
22:02:56 * copumpkin orders a quad hs stacker
22:12:36 <inbuninbu> does anyone have any recommendations for a good, *practical* arrow tutorial?
22:13:04 <Twey> No
22:13:16 <Twey> Nobody uses arrows for any practical purpose :-P
22:13:25 <inbuninbu> hahaha
22:13:42 <inbuninbu> i think hxt uses them, but that is a bit big to read through
22:13:43 <monochrom> http://www.vex.net/~trebla/haskell/hxt-arrow/index.xhtml  is practical but incomplete.
22:14:18 <inbuninbu> monochrom: thanks
22:14:30 <inbuninbu> i'd like to do an AI subsystem, for, say ants moving around an antihll. it seems like yampa would be good, but it seems inactive
22:14:42 <inbuninbu> so i figured i'd try to use arrows
22:32:04 <Smorg> If I represented a partial function in haskell with multiple arguments, would it try and solve it slowly with recursion or take advantage of differential equations?
22:32:19 <copumpkin> ?
22:32:35 <Smorg> er how do i say this...
22:35:21 <Smorg> essentially i'm writing a function which returns an nth element from the origin of a euclidean distance matrix - which i think can be done in 1 step but haskell will probably try to do it by calculating every n up to the element that gets searched for.
22:38:30 <Smorg> nvm I think i'm confusing myself.
22:40:11 <jimmyjazz14> how does one use an "if" with IO Bool ?
22:40:49 <mike-burns> do { x <- functionThatReturnsIOBool; if x ... else ... }
22:41:03 <jimmyjazz14> oh right, of course
22:41:06 <jmcarthur> if x _then_ ... else ...
22:41:23 <mike-burns> Oh, whoops.
22:41:28 <jmcarthur> ;)
22:42:10 <aavogt> @hoogle ifM
22:42:10 <lambdabot> System.Directory createDirectoryIfMissing :: Bool -> FilePath -> IO ()
22:42:10 <lambdabot> Distribution.Simple.Utils createDirectoryIfMissingVerbose :: Verbosity -> Bool -> FilePath -> IO ()
22:42:10 <lambdabot> Foreign.C.Error throwErrnoIfMinus1 :: Num a => String -> IO a -> IO a
22:42:50 <Gracenotes> alas no
22:42:51 <aavogt> @type when
22:42:52 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
22:43:11 <jmcarthur> :t let bool c a b = if c then a else b in liftM3 bool (return True) (return 1) (return 2)
22:43:12 <lambdabot> forall a2 (m :: * -> *). (Monad m, Num a2) => m a2
22:43:35 <jmcarthur> :t let bool c a b = if c then a else b in liftM3 bool
22:43:37 <lambdabot> forall a2 (m :: * -> *). (Monad m) => m Bool -> m a2 -> m a2 -> m a2
22:44:13 <Gracenotes> unfortunately, that will evaluate everything
22:44:18 <jmcarthur> oh you're right
22:44:21 <jmcarthur> nevermind then
22:44:49 <aavogt> how can you tell?
22:45:01 <jmcarthur> aavogt: that's what liftM3 does
22:45:10 <aavogt> @src liftM2
22:45:11 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
22:45:14 <Gracenotes> in the case of Applicative, everything definitely gets evaluated. With monads you have better control over context
22:45:31 <Gracenotes> so you can do x1 <- m1, but can choose what to do based on x1
22:45:40 <Gracenotes> all Applicative does is sequence and compose, essentially
22:46:15 <jmcarthur> yeah, but liftA and liftM are still the same. to control the order with Monad still requires some monad-specific code. you can't just lift a pure function into it and get the same laziness properties
22:46:22 <jmcarthur> as far as effects go, thatis
22:46:26 <aavogt> > take 10 $ liftM2 (,) [1..3] [1..]
22:46:27 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10)]
22:47:12 <Gracenotes> , diagonal [[1..3], [1..]]
22:47:13 <lunabot>  [1,2,1,3,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,...
22:47:42 <aavogt> I see, thanks
22:48:03 <Gracenotes> hmmm... I forget how to make pairs and whatnot with omega
22:48:19 <Gracenotes> jmcarthur: righty
22:48:27 <copumpkin> , runOmega
22:48:27 <lunabot>  luna: No instance for (GHC.Show.Show
22:49:02 <copumpkin> , runOmega $ liftM2 (,) (each [1..3]) (each [1..])
22:49:04 <lunabot>  [(1,1),(1,2),(2,1),(1,3),(2,2),(3,1),(1,4),(2,3),(3,2),(1,5),(2,4),(3,3),...
22:49:25 <Gracenotes> aha! that's it
22:49:31 <Gracenotes> ..senor
22:49:58 <copumpkin> :)
22:51:15 <Gracenotes> interesting how it cycles here, but not above. Must be a property of the list-monad-y-ness of Omega
22:54:38 <Gracenotes> , runOmega $ liftM2 (,) (each [1..]) (each [1..])
22:54:40 <lunabot>  [(1,1),(1,2),(2,1),(1,3),(2,2),(3,1),(1,4),(2,3),(3,2),(4,1),(1,5),(2,4),...
22:55:11 <Gracenotes> , filter ((==1) . uncurry gcd) . runOmega $ liftM2 (,) (each [1..]) (each [1..])
22:55:13 <lunabot>  [(1,1),(1,2),(2,1),(1,3),(3,1),(1,4),(2,3),(3,2),(4,1),(1,5),(5,1),(1,6),...
22:55:58 <ac> is it hard to compile Haskell to run on an Iphone?
22:56:36 <mike-burns> I believe much discussion of that is happening in #haskell-iphone .
22:58:12 <ac> ah. I see there seems to be interest and activity in that direction. I'll go check out that channel
23:16:24 <vininim> offtopic: hey, what do you guys use to draw control-flow graphs in latex?
23:16:48 <vininim> since haskell is used in compiler research I guess people had to deal with it more than once
