00:00:57 <profmakx> ?users
00:00:57 <lambdabot> Maximum users seen in #haskell: 658, currently: 566 (86.0%), active: 2 (0.4%)
00:12:12 <eck> is there a way to get printf to automatically do (show x) if you try to printf x as a string, and x is an instance of Show?
00:13:35 <lament> write a wrapper
00:16:16 <ivanm> lament: can you for arbitrary positions, etc.?
00:17:15 <eck> it looks like printf just exposes the PrintfArg typeclass
00:17:35 <lament> yeah, printf has crucial bits that say "Its implementation is intentionally not visible from this module."
00:18:01 <lament> probably the best way to do it is to poke augustss and ask him what to do? :)
00:20:01 <ivanm> lament: though depending on what client he uses, you may have already poked him ;-)
00:27:50 <augustss> eck: You can't do that in H98.
00:28:31 <eck> why not?
00:29:15 <saynte> augustss: oh, I wanted to ask you something about LLVM, have a moment?
00:29:44 <augustss> eck: it would need overlapping instances
00:29:49 <augustss> saynte: go ahead
00:30:31 <saynte> great, so I was looking at your bindings, and discussing it with someone else here on the channel a few days ago but: is it possible to take an abstract (data-type) description of a function and generate a function using the LLVM bindings on Hackage?
00:30:55 <augustss> yes
00:31:10 <saynte> Ah... how? :)
00:31:23 <eck> i see now, thanks
00:32:19 <augustss> saynte: first you generate code for the function getting a function using C calling conventions and then you convert that to a Haskell function.
00:32:46 <augustss> saynte: you can look at the BASIC package for a very simple example.
00:33:08 <saynte> augustss: is this on hackage? I saw something on your blog I think...
00:33:19 <augustss> saynte: it's on hackage
00:33:55 <augustss> it's a rather special case, but it shows how
00:35:13 <roderyk> gtk2hs - onButtonPressed is supposedly deprecated, but I can't find any examples of what to replace it with? any hints at what onEvent-like functions I should be reading in the api docs?
00:36:02 <dmwit> sec
00:36:08 <saynte> augustss: still looking at the BASIC package, getting hopeful :)
00:36:14 <davidL> is the P complexity class closed under concatenation?
00:37:15 <dmwit> roderyk: onClicked looks close
00:37:40 <dmwit> That's not quite the same, I know.
00:38:05 <dmwit> onButtonPress?
00:38:16 <dmwit> Is that the one you're saying is deprecated?
00:38:27 <dmwit> yes it is
00:38:50 <roderyk> dmwit: onClicked is for a button, I'm looking for the one that gets the mouse (x,y) clicked position in a drawingArea
00:39:00 <dmwit> I know, I know.
00:39:54 <saynte> augustss: looking at Gosub, do you model the calls using branching, or do you use the `call' instruction from LLVM?
00:40:26 <roderyk> supposedly there is a buttonPressEvent (which doesn't seem deprecated), but it just returns a signal. Don't know how the hook is expected to look like
00:41:13 <roderyk> (not familiar enough with gtk to know why they deprecated onButtonPressed - and what is the expected alternative)
00:42:40 <augustss> saynte: BASIC's gosub is too weird to use the call instruction.
00:43:19 <augustss> saynte: for any sane language you'd use call
00:43:54 <augustss> saynte: btw, the LLVM package also has a brainfuck compiler as an example
00:44:06 <saynte> augustss:  Heh, yeah. So I guess I'm not sure how to confert some abstract syntax in the way you describe.
00:45:15 <saynte> augustss: I sort of "get" everything except how to go from a datatype like "Func [Args] Body" to the LLVM-hs version, which seems very strongly typed.
00:48:00 <dmwit> roderyk: buttonPressEvent -- ?
00:48:39 <augustss> saynte: you could have a typed abstract syntax tree
00:48:48 <roderyk> dmwit: yea, I have no idea how to hook that signal into my program :)
00:48:55 <saynte> augustss: Hmmm.
00:49:28 <dmwit> roderyk: on drawWindow buttonPressEvent handler
00:49:42 <dmwit> roderyk: on :: object -> Signal object callback -> callback -> IO (ConnectId object)
00:50:01 <roderyk> dmwit: ah, ok. thanks :)
00:50:08 <augustss> saynte: I've not actually written a compiler to LLVM for a language with interesting types, so I'm not sure what the best way is.
00:50:32 <saynte> augustss: It's generally hard to do that, I think. Essentially with parsing you have to go from String -> a, without ever saying what 'a' is.
00:51:25 <augustss> saynte: you can do that with an existentially quantified a
00:51:39 <dmwit> roderyk: That was a fun puzzle, thanks! =)
00:51:58 <roderyk> dmwit: I'm sure I'll be back with more =)
00:52:18 <augustss> saynte: but I agree, it's a bit tricky
00:53:03 <saynte> augustss: Yeah, existentially qualified may work, I'd have to think about it. Initially I think then you'd run into the problem that you could never pin down the type-class again when you wanted reconstruct the function.
00:54:08 <saynte> augustss: I'll think about it a bit, see where it goes.
00:54:57 <augustss> saynte: You'd basically have parse::String->exist a.Expr a, and codegen::forall a.Expr a->Code.  And then you compose the functions.
00:55:31 <augustss> saynte: the type variable has to disappear from the final Code
00:56:49 <jaSync> hello everyone!
00:56:55 <jaSync> is this real? http://n.juokutis.lt/index.php?i=0c2e93265b179f56d30f7e4cbc073c0d
00:57:24 <saynte> augustss: Yeah, it's the `forall' part that that scares me :)
00:57:26 <flux> hmm, seems like a trick
01:03:17 <roderyk> dmwit: just found http://www.haskell.org/gtk2hs/docs/devel/Graphics-UI-Gtk-Gdk-EventM.html   very enlightening; thanks for the tip :)
01:04:36 <saynte> augustss: Thanks for the help though. Depending on the skill-level required for the existential quantification, I may see if I can wrap the C-bindings at a less-safe level of typing.
01:13:41 <saynte> augustss: FFI.Core, yay, I think this may do it :)
01:27:50 <Tarrant> Is it not possible to export constructors?
01:28:06 <opqdonut> it is possible to not export them
01:28:08 <opqdonut> :)
01:28:15 <opqdonut> module Foo (Foo (), ...)
01:28:27 <opqdonut> just the type Foo is exposed w/o constructors
01:28:38 <dmwit> Tarrant: Specify which constructors you want to export after the data type; (..) for all of them.
01:28:43 <dmwit> data Foo = Bar | Baz
01:28:53 <pozic> I get a <<loop>>. How can I show what exactly the loop is?
01:28:58 <dmwit> module Quux (Foo(Bar)) -- for example
01:29:05 <dmwit> module Quux (Foo(..)) -- another example
01:29:14 <opqdonut> pozic: you might want to try the ghci debugger
01:30:15 <Tarrant> I was confusing: "data Shape = Circle ... | Rectangle ..." Rectangle and Circle as the type. They aren't Shape is.
01:30:43 <pozic> opqdonut: when I remove one call to Debug.Trace.trace I get hClose: illegal operation (handle is finalized) and no longer then <<loop>>.
01:30:54 <dmwit> Tarrant: Yep, it's a common mistake, and easy to make.
01:31:00 <dmwit> You'll get the hang of it, though. =)
01:38:45 <pozic> opqdonut: Also, ghci doesn't do loop detection, AFAIK.
01:39:16 <opqdonut> yeah that might be
01:46:43 <quicksilver> well it's not really loop detection, it's blackhole detection
01:46:57 <quicksilver> I think ghci is capable of observing blackholes but they're less likely to happen, or something.
01:50:48 <doserj> http://hackage.haskell.org/trac/ghc/ticket/2786
01:54:47 <pozic> How can I make this work? (4 lines) http://paste.debian.net/38012/
01:57:28 <dmwit> :t let both :: Arrow (~>) => (forall b. b ~> c) -> (b, b') ~> (c, c); both f = f *** f in both
01:57:29 <lambdabot> forall (~> :: * -> * -> *) c b b'. (Arrow (~>)) => (forall b1. (~>) b1 c) -> (~>) (b, b') (c, c)
01:57:40 <dmwit> pozic: What's wrong with exactly what you wrote?
01:58:04 <dmwit> > let both :: Arrow (~>) => (forall b. b ~> c) -> (b, b') ~> (c, c); both f = f *** f in both length ("abc", [1, 2])
01:58:05 <lambdabot>   Couldn't match expected type `b' against inferred type `[a]'
01:58:13 <dmwit> ah!
01:58:16 <dmwit> I know what's wrong. =)
01:58:28 <opqdonut> there really isn't any nice way to make that work generically
01:58:31 <dmwit> > let both :: Arrow (~>) => (forall b. [b] ~> c) -> ([b], [b']) ~> (c, c); both f = f *** f in both length ("abc", [1, 2])
01:58:32 <lambdabot>   (3,2)
01:58:39 <opqdonut> but yeah, a [a]-version will work
01:59:12 <dmwit> Right, so this works only for lists.  And yours works only for functions that are really, really polymorphic. =)
01:59:13 <pozic> dmwit: I actually wanted it to work for anything. Not just lists.
01:59:29 <dmwit> pozic: Yours works for functions that can actually take anything.
01:59:35 <dmwit> Not very many (useful) functions do that.
02:00:37 <pozic> dmwit: oh, actually, I think I know the right type then.
02:00:48 * dmwit notes that "both f" is not that much shorter than "f *** f"
02:01:00 <quicksilver> inferring the most general rank n type to satisfy a set of constraints is known to be "hard" ;)
02:01:01 <Twey> It's more readable, though
02:01:13 <Twey> And doesn't require brackets in places where (f *** f) does
02:01:14 <dmwit> Yeah, I guess it could be.
02:02:45 <ivanm> quicksilver: in kuribas' mode, is tab meant to cycle back to the beginning again when you've tabbed your way to the end?
02:03:00 <pozic> dmwit: both :: Arrow (~>) => (forall b. container b ~> c) -> (container b, container b') ~> (c, c) works for any kind of container. Only, it still doesn't really do what I intended it to do.
02:03:05 <doserj> ivanm: no
02:03:13 <ivanm> *nod*
02:03:14 <pozic> dmwit: this only works for one specific use-case.
02:03:28 <ivanm> OK, from quicksilver's initial description the other day I thought it did
02:04:01 <bastl> What is the best way to install GHC 6.10 on Ubuntu 9.04 on amd64 architecture? Are there binaries somewhere or should I compile from source ?
02:04:04 <opqdonut> pozic: you see the problem is that "both f" forces both the fs in f *** f to have the same type
02:04:24 <dmwit> :t \f -> (f . Left) *** (f . Right)
02:04:25 <lambdabot> forall c b b1. (Either b b1 -> c) -> (b, b1) -> (c, c)
02:04:25 <opqdonut> which needs to bee something like the union of b->c and b'->c in this case
02:04:29 <pozic> opqdonut: yes, but "same type" is not actually needed.
02:04:38 <opqdonut> yes, but it still forces it
02:04:46 <dmwit> :t either length length
02:04:46 <ivanm> bastl: is keeping ubuntu a pre-condition? :p
02:04:47 <lambdabot> forall a a1. Either [a] [a1] -> Int
02:04:50 <pozic> opqdonut: yes, that's what Haskell 98 does.
02:04:53 <opqdonut> you need a much more powerful type system than haskells to express this
02:05:01 <bastl> ivanm: what else?
02:05:06 <opqdonut> not even arbitary rank polymorphism is enough
02:05:12 <ivanm> get a distro with better haskell support?
02:05:19 <bastl> e.g.?
02:05:25 <ivanm> gentoo, arch
02:05:32 <ivanm> even fedora 10 has ghc-6.10
02:05:33 <pozic> opqdonut: what language can do that?
02:05:34 <opqdonut> debian
02:05:35 <kynky> arch seems to have really good support, i use gentoo
02:05:36 <dmwit> :t let f = either length length; both f = (f . Left) *** (f . Right) in both f ("abc", [1, 2]) -- pozic: probably about the best you can do conveniently
02:05:37 <lambdabot> (Int, Int)
02:05:39 <opqdonut> err, i said union earlier, i guess i meant intersection
02:05:42 <ivanm> (I can't recall which version though)
02:05:43 <opqdonut> pozic: i really have no idea
02:05:49 <opqdonut> dmwit's solution is nice
02:06:03 <bastl> hmm. i live with ubuntu for some years quite good. but were getting OT.
02:06:21 <bastl> so any answers to the above question?`
02:06:22 <opqdonut> debian testing has 6.10, you could possibly backport that into ubuntu
02:06:24 <dmwit> pozic: But that's really not better than just using (length *** length) in the first place.
02:06:50 <pozic> dmwit: you are just using a let there, which nullifies the problem.
02:06:56 <dmwit> pozic: Since the point was to avoid duplication (I guess), and we're just pushing the duplication onto the "either" instead of the (***).
02:07:03 <pozic> dmwit: yes
02:07:35 <dmwit> The let has nothing to do with it.
02:07:58 <dmwit> Anyway, bedtime for me.
02:09:43 <pozic> :t let f = [length] both f = (f . head) *** (f . head) in both f ("abc", [1, 2])
02:09:44 <lambdabot> parse error on input `='
02:09:53 <pozic> :t let f = [length]; both f = (f . head) *** (f . head) in both f ("abc", [1, 2])
02:09:54 <lambdabot>     Couldn't match expected type `a -> c'
02:09:54 <lambdabot>            against inferred type `[[a1] -> Int]'
02:09:54 <lambdabot>     In the first argument of `both', namely `f'
02:10:22 <pozic> :t let f = [length]; both f = (head f) *** (head f) in both f ("abc", [1, 2])
02:10:23 <lambdabot>     No instance for (Num Char)
02:10:23 <lambdabot>       arising from the literal `1' at <interactive>:1:68
02:10:23 <lambdabot>     Possible fix: add an instance declaration for (Num Char)
02:12:38 <dmwit> pozic: Is it really so bad to give your function a name and then call (foo *** foo)?
02:12:54 <dmwit> pozic: I mean, this is exactly the use-case that let-polymorphism was made for.
02:13:04 <dmwit> (Or any kind of polymorphism, really.)
02:15:31 <Cale> :t let f :: [forall a. [a] -> Int]; f = [length]; both :: [forall a. a -> b] -> (c,d) -> (b,b); both f = (head f) *** (head f) in both f ("abc", [1, 2])
02:15:32 <lambdabot> on the commandline:
02:15:32 <lambdabot>     Warning: -fno-th is deprecated: use -XNoTemplateHaskell or pragma {-# LANGUAGE NoTemplateHaskell#-} instead
02:15:32 <lambdabot> Top level:
02:15:42 <Cale> okay...
02:16:10 <servotron3000> hey guys, one question. if i do getTemporaryDirectory, it returns /tmp. then i open a temporary file with openTempFile and give it that directory as the directory in which to be placed
02:16:32 <servotron3000> if i try to move that file later, i get an error because /tmp and the directory into which i'm moving aren't on the same filesystem
02:17:21 <Baughn> servotron3000: Yes..?
02:17:40 <servotron3000> yeah well so is it better to just create the temporary file in .
02:17:43 <Baughn> servotron3000: The most obvious solution is to open the file in the directory you want to put it in the first place
02:17:51 <servotron3000> and not mess with getTemporary Directory at all
02:17:59 <Baughn> getTemporaryDirectory is for /temporary files/
02:18:11 <servotron3000> ah i see, makes sense yeah
02:18:12 <Baughn> eg. ones where you don't care where they are, and you'll be deleting them later
02:18:24 <koala_man> servotron3000: you can't move between fs, only copy and delete the original
02:18:33 <Baughn> (Actually, typically you'll be deleting them right after opening them, in case your program crashes)
02:18:42 <Cale> Prelude Control.Arrow> let f :: [forall a. [a] -> Int]; f = [length]; both :: [forall a. [a] -> b] -> ([c],[d]) -> (b,b); both f = (head f) *** (head f) in both f ("abc", [1,2])
02:18:42 <Cale> (3,2)
02:18:59 <Cale> Needs -XImpredicativeTypes though
02:19:00 <Baughn> servotron3000: The move syscall is actually called "rename". There's a reason for that. ;)
02:19:08 <Feuerbach> What is the purpose of large number of empty lines at the beginning of chs files in gtk2hs?
02:19:11 <servotron3000> ah :)
02:19:24 <Cale> pozic: ^^
02:19:44 <jeffz`> bastl: you can get the binary dist of ghc from haskell.org
02:19:51 <Baughn> servotron3000: Unix files can have any number of names, but.. they all have to be in the same filesystem as the data they're linked to, and /that data/ can only be deleted or copied, not moved
02:20:42 <luqui> @seen diakopter
02:20:42 <lambdabot> diakopter is in #perl6. I don't know when diakopter last spoke.
02:21:00 <servotron3000> aha i see, i didn't know that, so that's what was confusing me
02:21:12 <Badger> Why is lambdabot in #perl6? o_O
02:21:17 <pozic> Cale: that was just a try to show that either was not needed, but still doesn't solve the original problem. Thanks, for showing that it was possible, though.
02:21:39 <jeffz`> Badger: you might ask why is lambdabot in any channel?
02:21:59 <BONUS> maybe it's learning perl?
02:22:06 <Badger> hahaha
02:22:13 <Baughn> servotron3000: Filesystems are contiguous sections of disk space. rename can work fast because it only deletes and recreates a name, but moving the file itself to another filesystem necessarily requires copying all the data; you can't say "these four hundred bytes are now part of this other filesystem". NEver mind if they are on different disks..
02:22:21 <shachaf> The Perl people want karma.
02:22:22 <shachaf> @karma-all
02:22:22 <lambdabot>  "moritz"              655
02:22:22 <lambdabot>  "pmichaud"            451
02:22:22 <lambdabot>  "lwall"               354
02:22:23 <lambdabot>  "jnthn"               348
02:22:25 <lambdabot>  "pmurias"             319
02:22:27 <lambdabot> [1341 @more lines]
02:22:37 <servotron3000> ah, isee. that makes sense.
02:23:38 <Baughn> servotron3000: For what it's worth.. that's unix. Other systems could /theoretically/ act differently, but I'm pretty sure none do; the architecture that causes this is pretty basic.
02:24:01 <Cale> shachaf: The perl people cheat by having a bot give them karma in lambdabot whenever they commit patches :)
02:24:05 <Baughn> Though some (windows) only allow one name per file
02:24:22 <servotron3000> is getCurrentDirectory basically just return "."?
02:24:31 <ivanm> Cale: this is why I think we should split lambdabot into two instances: haskell and non-haskell
02:24:39 <ivanm> servotron3000: either that or the full path
02:24:43 <shachaf> They have their own bot in there anyway.
02:24:44 <Baughn> servotron3000: It returns the current directory. You can /change/ the current directory too, so not really.
02:24:45 <ivanm> different for windows though I think
02:24:48 <Twey> And Perl needs a *lot* of patching... :-P
02:25:00 <ivanm> Twey: lol
02:25:02 <Baughn> servotron3000: However, . is bash's way to say "current directory", so basically yeah
02:25:06 <Twey> Oh look, there's Larry Wall
02:25:17 <Twey> I would think that it would make more sense to have separate karma databases for each channel
02:25:36 <Baughn> @karma conal
02:25:40 <lambdabot> conal has a karma of 4
02:25:44 <shachaf> Is Pugs even still alive?
02:25:56 <ivanm> shachaf: I believe it is
02:25:58 <Twey> Alive and kicking
02:26:05 <paolino> hi, is it any true that ContT c (State s) is leaking probably less than StateT s (Cont c) , when usinf callCC ?
02:26:11 <ivanm> Twey: in some cases, it's valid to share it
02:26:16 <ivanm> e.g. #haskell and #xmonad
02:26:26 <Twey> I don't think so
02:26:35 <Twey> Maybe #haskell and #haskell-fr
02:26:40 <shachaf> Karma is karma. Why wouldn't it be shared?
02:26:46 <Twey> But #xmonad is about XMonad, and #haskell is about Haskell
02:26:50 <ivanm> shachaf: because the perl people cheat?
02:27:06 <Twey> It's no more the same topic than ##c and #firefox
02:27:09 <ivanm> Twey: there's a fair amount of overlap
02:27:24 <ivanm> there's haskell talk in #xmonad sometimes, and xmonad talk in #haskell sometimes
02:27:33 <BONUS> ?umtl ContT r (State s) a
02:27:33 <lambdabot> (a -> s -> (r, s)) -> s -> (r, s)
02:27:45 <BONUS> ?umtl StateT s (Cont r) a
02:27:45 <lambdabot> s -> (a -> s -> r) -> r
02:27:53 <shachaf> ivanm: So that's the problem. Work on the cheating. :-)
02:28:09 <Twey> ivanm: Yes, but there *shouldn't* be
02:28:14 <shachaf> Twey: The whole concept of karma is per-person, not per-person-per-channel.
02:28:14 <BONUS> why does umtl always curry stuff like (a,s) -> r
02:28:41 <ivanm> shachaf: which is why I'm saying we should have a haskellian lambdabot and a non-haskellian lambdabot
02:28:58 <shachaf> ivanm: ?
02:28:59 <paolino> BONUS: where ?
02:29:03 <shachaf> What has that to do with cheating?
02:29:13 <ivanm> shachaf: let the pugs people have their own lambdabot
02:29:35 <Baughn> Twey: It's sort of inevitable, when half the questions in #xmonad are about the crazy configuration language. ;)
02:29:39 <BONUS> well unnewtyped StateT s (Cont r) a is s -> ((a,s) -> r) -> r
02:29:46 <Twey> Heheh
02:29:48 <BONUS> but umtl says it's s -> (a -> s -> r) -> r
02:29:56 <BONUS> it's isomorphic, but still why does it do it
02:29:57 <Baughn> Twey: And while haskell is sort of off-topic in #xmonad, xmonad is not off-topic here
02:30:42 <shachaf> ivanm: Why?
02:31:15 <Twey> Baughn: Why is that?
02:31:24 <shachaf> Karma is karma. If karma is given for helping people, say, and you help someone in #perl6, you should get the karma just the same.
02:31:29 <BONUS> what do you mean exactly by "is leaking less"?
02:31:46 <ivanm> shachaf: 1) it will increase stability from lambdabot crashing all the time (I think...), 2) we avoid all the non-haskellian quotes, karma, etc.
02:32:17 <shachaf> @faq Can Haskell be used for real-world programs?
02:32:17 <lambdabot> The answer is: Yes! Haskell can do that.
02:32:20 <Baughn> Twey: Beyond being a useful program, xmonad is also an interesting example of how to use haskell well
02:32:26 <shachaf> There you go, on-topic. :-)
02:32:37 <Baughn> Twey: (Though I'd prefer it to be programmed using FRP. Oh well. :P)
02:32:39 <Twey> shachaf: Is karma for helping people in #politics useful information for people in #haskell to know?
02:32:39 <paolino> BONUS, that the more Cont monad is inside the more big contexts are saved for each callCC
02:33:03 <paolino> (I'm asking, really)
02:33:04 <Twey> Baughn: Of course, it is, but a program is not the same as the language in which it's programmed
02:33:22 <shachaf> Twey: Yes. Karms is (supposed to be) this weird universal thing that comes back to haunt/help you in unexpected ways and places, right?
02:33:26 <Twey> Like I said, you don't go to ##c asking for help to set a bookmark in Firefox
02:33:31 <Baughn> Twey: Of course, but in practice #haskell isn't just about haskell-the-language; it's also about everything surrounding that
02:33:32 <Twey> shachaf: Well, yes
02:33:47 <Baughn> Twey: Such as how other people have used it, why they've done so, the details of their programs..
02:33:50 <shachaf> Of course! And if lambdabot was in ##c, I wouldn't ask Haskell questions there.
02:33:57 <Baughn> ..it is
02:34:02 <Baughn> Well, /a/ \bot is
02:34:46 <Twey> shachaf: But the Internet concept of ‘karma’ is a little different, from what I've seen
02:35:11 <Twey> It's used as a sort of status indicator, to show who can be trusted to give good advice
02:35:21 <paolino> it's trust
02:35:24 <shachaf> Eh, it shouldn't really be. A nice helpful interesting person is pretty universal.
02:35:48 <Baughn> I don't know. I don't think anyone ever actually /uses/ karma for that
02:35:51 <pozic> Twey: the karma system has no security. It's a silly number.
02:35:52 <Twey> shachaf: But being helpful requires knowledge of the subject base
02:35:59 <Baughn> Add to people's karma, yes, but check it? I've never seen that.
02:36:06 <Twey> pozic: Sure, but it's an indicator
02:36:19 <Twey> Maybe not a very reliable one
02:36:28 <pozic> Twey: only because nobody seems to game it.
02:36:39 <Twey> Except the Perl folks?  :-P
02:36:45 <paolino> Baughn: because it's not showed with the name, i suppose
02:40:31 <Baughn> paolino: Right. Which makes this whole discussion relatively moot.
02:40:59 * paolino googles moot
02:41:07 <Baughn> No! Don't!
02:41:24 <Cale> Heh, some of the nonsense that Google Squares is capable of generating when you ask it stupid questions is funny. It suggested a 'Genre' column for my 'web browsers' square, which I added. Apparently Mosaic is Jazz, and Opera is Classical.
02:41:48 <Cale> (Firefox is Browser)
02:41:51 <Twey> Google Squares?
02:41:57 * Twey googles Google Squares
02:41:59 <Cale> http://www.google.com/squared
02:42:10 <Cale> Squared, sorry
02:42:28 <Cale> (The tables you generate are called squares)
02:43:06 <Twey> Heh... it's got some way to go
02:43:28 <Baughn> Hm. I get "hip hop" for mosaic
02:43:38 <Baughn> While firefox' genre is.. "browser". ^^;
02:43:44 <Baughn> Opera's is,er, opera.
02:43:52 <doserj> http://en.wikipedia.org/wiki/Mosaic_(jazz_album)
02:43:54 * Cale tries adding Genre columns to other tables... cloud types... Cumulus cloud -> Avant-Garde,  Altostratus -> New Age,  Stratus -> electronica,  Stratocumulus -> Techno.
02:44:47 <Cale> Contrail -> Rock
02:44:48 <Twey> Haha
02:45:12 <joga> heh, I tried searching for "programming languages" and it gave a nice chart, then I added a 'difficulty' column and it said "no value found" for all but Forth, which it gave "Hell" :)
02:46:26 <Cale> Haskell is Rock, apparently
02:46:29 <servotron3000> hmm, does every system use . for the current directory?
02:46:39 <Baughn> Pretty much.
02:46:41 <servotron3000> i.e. is it more portable to use getCurrentDirectory instead of just saying "."
02:47:21 <paolino> @suorce getCurrentDirectory
02:47:21 <lambdabot> getCurrentDirectory not available
02:47:37 <shachaf> Hmm, you can add a Score field to most things.
02:47:55 <Cale> Hahaha... Mathematica's Genre is Poetry -> Humorous
02:49:07 <Twey> Cale: Haha :-P
02:49:38 <Twey> Hm
02:49:43 <Cale> Heh, the Score column is also amusing.
02:49:55 <Twey> I get ‘Mathematical computation, symbolic, graphs, function plot’
02:50:03 <Twey> 11?
02:50:54 <shachaf> "rotation" is apparently "science fiction
02:50:58 <shachaf> "
02:51:12 <Cale> Here are the scores of some scientists: Sir Isaac Newton: 401, Archimedes: 489, Albert Einstein: 11), Benjamin Franklin: 288, Stephen Wolfram: 2228815.
02:51:19 <shachaf> Er, "reflection", rather.
02:51:44 <Twey> Haha, Wolfram|Alpha got a score of ‘5, Informative)’
02:51:50 <Twey> Thanks /.
02:51:51 <Cale> haha
02:52:08 <shachaf> Hmm. "Google" is listed as "comedy".
02:52:11 <shachaf> Seems accurate...
02:52:15 <Twey> Hehe
02:57:10 <quicksilver> opqdonut: but unrestricted higher rank unification is undecidable, right?
02:59:03 <amckinley> hey, can someone help me figure out why this doesnt work? http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=5559
02:59:16 <otulp> A question re. Data.CompactMap and resources: I have a map of 2GB data distributed over 50k keys. Keys are of a type Coord !Int64 !Int64 and the values are lists of mostly just one fat element. Extracting the keys to a list works just fine, but trying to lookup a value results in a heap that outgrows the available memory (8GiB). The reason I'm using CompactMap is that just trying to build a normal Map would eat all memory. Does ...
02:59:18 <amckinley> im getting *** Exception: Text.ParserCombinators.Parsec.Prim.many: combinator 'many' is applied to a parser that accepts an empty string.
02:59:22 <otulp> ... anybody have a clue what I'm doing wrong, or if perhaps my expectations of Map and CompactMap performance are a tad too high?
02:59:31 <amckinley> when i call (many tokenizer)
02:59:44 <amckinley> which is *madness*, because tokenizer doesnt even operate on strings :P
03:00:32 <Berengal> amckinley: It means tokenizer can succeed without consuming any input
03:01:06 <amckinley> Berengal: is that because im calling getInput without calling setInput?
03:01:06 <Berengal> At least it thinks it can
03:01:25 <Cale> amckinley: all parsers operate on strings of some sort :P
03:01:42 <Berengal> amckinley: My guess is yes
03:02:13 <amckinley> Berengal: more interestingly, is there some other way to interact with a Stream that isnt string-based besides calling get/setInput?
03:02:25 <quicksilver> sure.
03:02:31 <quicksilver> use the combinators.
03:03:17 <amckinley> quicksilver: how? my parser isnt character-based: i did a full lexing pass that produces a list of [Lexeme]
03:03:57 <quicksilver> I understood your question.
03:04:09 <quicksilver> The majority of the combinators do not assume [Char]
03:04:27 <quicksilver> none of the combinators in ".Prim" assume [Char]
03:04:33 <Cale> otulp: hmm
03:04:40 <quicksilver> nor any of the ones in .Combinator
03:04:52 <quicksilver> they're all parameterised by an arbitrrary token typ 'tok'
03:04:59 <amckinley> quicksilver: i guess the part i dont understand is how to get access to the underlying list
03:05:50 <amckinley> i guess anyToken would wpork
03:05:53 <amckinley> *work
03:05:54 <Cale> otulp: that's interesting. How well does printing the toList of the CompactMap work?
03:06:12 <Cale> otulp: It will probably consume lots of memory at some point, but how quickly, and when?
03:06:20 <otulp> Cale: Wow. I haven't tried. That would be one large string.
03:06:38 <otulp> I'll have a go..
03:06:40 <quicksilver> amckinley: yes, anyToken for example.
03:06:53 <quicksilver> amckinley: or primTokenBlah for more complex tricks
03:07:55 <Cale> otulp: Also, it's almost a silly question, but you are compiling with -O2, right?
03:08:01 <otulp> Cale: It behaves pretty much like the lookup does. Consumes all RAM, then grinds to a halt.
03:08:19 <Cale> otulp: Does it least get as far as printing the first index?
03:08:19 <otulp> Cale: Compiled using ghc and -O2, yes.
03:08:29 <otulp> Cale: Nope. No printout.
03:08:35 <RickBarnev> what is the solution to: map length []
03:08:36 <Cale> Oh, right, when compiled, maybe it's line buffered too..
03:08:37 <RickBarnev> ?
03:08:48 <amckinley> quicksilver: thanks, that works. where are the primTokenBlah functions hanging out?
03:08:49 <Cale> RickBarnev: []
03:08:53 <Cale> > map length []
03:08:54 <lambdabot>   []
03:09:01 <RickBarnev> tnx
03:09:20 <quicksilver> amckinley: .Prim
03:09:22 <Cale> RickBarnev: If you don't have ghci, I would recommend getting that
03:09:33 <Cale> RickBarnev: it comes with ghc
03:09:33 <RickBarnev> I have
03:09:40 <RickBarnev> ok tnx
03:10:17 <Cale> ... oh well :)
03:11:04 <mmorrow> @pl \(a,b) -> f a (g b)
03:11:04 <lambdabot> uncurry ((. g) . f)
03:11:44 <mmorrow> @pl \a b -> f a (g b)
03:11:44 <lambdabot> (. g) . f
03:11:50 <mmorrow> @pl \a b c -> f a (g b (h c))
03:11:51 <lambdabot> (. ((. h) . g)) . (.) . f
03:12:15 <Cale> otulp: hmm -- and you've tried Map and it failed?
03:12:26 <mmorrow> @type \f g h -> (((. h) . g) . f)
03:12:27 <lambdabot> forall b c a b1 a1. (a1 -> b1) -> (b1 -> b -> c) -> (a -> b) -> a1 -> a -> c
03:12:39 <Cale> otulp: I've never tried CompactMap myself.
03:13:14 <otulp> Cale: Yes. Map would simply run out of memory while constructing with fromList.
03:13:19 <mmorrow> @pl \a b -> f b (g a)
03:13:19 <lambdabot> flip f . g
03:13:38 <mmorrow> @unpl (((. h) . g) . f)
03:13:38 <lambdabot> (\ d m -> g (f d) (h m))
03:13:43 <Cale> otulp: I suspect that's what's happening with CompactMap, only the construction is deferred until the first access
03:13:43 <mmorrow> forgot about @unpl
03:14:15 <mmorrow> @unpl ((((. d) . c) . b) . a)
03:14:15 <lambdabot> (\ h q -> c (b (a h)) (d q))
03:14:24 <mmorrow> @unpl (((((. e) . d) . c) . b) . a)
03:14:24 <lambdabot> (\ i u -> d (c (b (a i))) (e u))
03:14:53 <Cale> otulp: For such a large amount of data, an indexing scheme which kept the actual contents on disk or something would seem more appropriate...
03:15:00 <otulp> Cale: What's interesting is that I've successfully written the structure to disk with Binary's encodeFile. Shouldn't that mean that the full map was created?
03:15:10 <Cale> oh, well, that is interesting
03:15:52 <otulp> Cale: Hehe. Well.. This is the indexing data. :)
03:17:04 <SavMyDreams> http://savemydreams.blogspot.com/
03:17:31 <Cale> otulp: The lists are mostly one element, or always one?
03:17:51 --- mode: ChanServ set +o Cale
03:17:59 --- mode: Cale set +b *!*@dsl51B7A23A.pool.t-online.hu
03:17:59 --- kick: SavMyDreams was kicked by Cale (Cale)
03:18:04 --- mode: Cale set -o Cale
03:18:34 <Cale> Well, I would expect only mostly one, or you wouldn't be using lists...
03:20:02 <otulp> Cale: Mostly. A select few are as many as 1920 elements.
03:20:31 <otulp> All the others are one.
03:23:09 <Cale> If push comes to shove, separating the few which really need to be in lists might save some space. I'm not certain how *much* space, as I'd expect the Binary instance for lists to already be pretty compact.
03:24:27 <Cale> Apparently the representation is counted
03:24:40 <Cale> So it puts the length of the list followed by each of the elements.
03:25:40 <Cale> ah, and the instance for Int assumes 64 bits.
03:26:04 <Cale> So that'll be 8 bytes per element, to store what is usually a 1
03:26:11 <EvilTerran> Cale, ... so the first cell gets held for outputting the elements, while the spine is forced counting the length
03:26:39 <EvilTerran> not that that should be a problem if there aren't very many long lists
03:26:43 <otulp> Cale: Still.. that would be n*8*50k, which is still not much compared to the data contained in the list?
03:26:56 <Cale> ah, there are 50k keys?
03:27:03 <otulp> Yup.
03:27:36 <Cale> Yeah, that can't be the problem then, it must be the elements themselves which are the problem.
03:27:54 <Cale> In fact, if that's the case, I don't see why Map won't do.
03:28:30 <otulp> Me neither. :)
03:28:56 <Cale> So I don't think it's the associative structure itself.
03:29:05 <Cale> What is the element type of the map?
03:29:16 <Cale> [Something]...
03:30:17 <inbuninbu> what's the best way to override a default fail in a monad?
03:30:30 <Cale> Don't use fail
03:30:53 <inbuninbu> i'm using the Data.Binary.Get monad, though
03:31:02 <inbuninbu> and if there's an unexpected EOF
03:31:08 <inbuninbu> then it fails
03:31:12 <otulp> Cale: The map is Map Coord [Blk], where Coord is data Coord !Int64 !Int64, Blk is data Blk !FilePath !Int64 !Int64 (Array Int Int64) (Array Int Int64) (Array Int Int)
03:31:43 * Berengal thinks fail should've been called epicFail
03:32:00 <otulp> Cale: ...deriving Eq, Ord for Coord.
03:32:01 <Cale> inbuninbu: Yeah, it calls error in that case, since that monad doesn't really handle failure.
03:32:09 <EvilTerran> Berengal, nah, epic should be a combinator of its own
03:32:28 <Cale> inbuninbu: Though it does manage to print a message about the position at which it failed.
03:32:34 <EvilTerran> "epic fail", "epic error"...
03:32:37 <Cale> inbuninbu: Get (error (err ++ ". Failed reading at byte position " ++ show bytes))
03:32:40 <otulp> Cale: And the arrays are unboxed.
03:32:53 <inbuninbu> Cale: yes, unfortunately i've seen that error too often
03:33:02 <Berengal> EvilTerran: How does one add epicness to functions though?
03:33:06 <Cale> otulp: Wouldn't they be UArray then?
03:33:07 <Berengal> I mean, fail already has it...
03:33:24 <EvilTerran> Berengal, uhhh...
03:33:35 <inbuninbu> Cale: this is network-oriented, so of course network failure could crash a program in this instance
03:33:40 <otulp> Cale: They're A.Array, where A is Data.Array.Unboxed
03:33:40 <Berengal> > let epic = fix in epic error
03:33:42 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
03:34:05 <EvilTerran> Berengal, yeah, that's what i was thinking
03:34:05 <inbuninbu> Cale: will wrapping everything in Maybe do it?
03:34:09 <EvilTerran> although then epic fail = ""
03:34:26 <Berengal> > let epic = fix in epic fail
03:34:26 <Cale> inbuninbu: Right, so you should not use pattern matching on the left of <- in do-notation and don't explicitly call fail
03:34:27 <lambdabot>   ""
03:35:24 <Cale> inbuninbu: making use of Maybe is one way to help things, but it's not magic
03:35:33 <inbuninbu> Cale: but when i run runGet someGetAction bytestring
03:35:36 <Cale> inbuninbu: You just have to write functions which result in Maybe values.
03:35:54 <inbuninbu> if there is any EOF at any point in someGetAction, it seems to fail
03:36:39 <quicksilver> inbuninbu: Data.Binary.Get isn't really designed to be used on a bytestring which is wrong.
03:36:49 <quicksilver> inbuninbu: (if you see what I mean)
03:36:52 <Cale> inbuninbu: The Data.Binary stuff is mostly good when you have absolute control over the binary format being sent and where you are fairly certain there will be no error.
03:37:00 <quicksilver> it doesn't have any sensible way to flag error.
03:37:11 <quicksilver> You should only feed it bytestring which you know to be the right thing.
03:37:41 <quicksilver> in particular, it's not appropriate for network channels without a separate pre-validation step.
03:37:46 <quicksilver> IMO.
03:37:48 <inbuninbu> Cale,quicksilver: but then what else am i supposed to use? i need to worry about endianess
03:37:50 <Cale> (In fact, it's mostly good for reading stuff which was also written with Data.Binary, and not much else)
03:38:03 <quicksilver> inbuninbu: use it to decode the endianness by all means :)
03:38:08 <quicksilver> but validate the data first.
03:38:22 <quicksilver> Cale: no, that's not true.
03:38:35 <quicksilver> Cale: possibly you're confusing Data.Binary (the class) and Data.Binary.Get/Put
03:38:55 <quicksilver> Get/Put can be used to decode other know external formats - but only if you've somehow validated first.
03:39:07 <quicksilver> or if you can arrange for every input to be valid.
03:39:15 <Cale> Well, okay, yes.
03:39:25 <quicksilver> (possibly using Maybe does this - every input is valid, but some inputs cause 'Nothing' as the result)
03:39:30 <quicksilver> but it depends on the case.
03:39:45 <Peaker> Cale: it could be nice if Data.Binary.Get was in a MaybeT to properly represent failure
03:39:47 <inbuninbu> well my problem isn't validation; it's making sure there's enough data to parse
03:40:04 <inbuninbu> if the data isn't valid, i can throw an error at a higher level
03:40:06 <Cale> Peaker: Yeah, or was just a proper parser.
03:40:21 <inbuninbu> i just need to read/write bytestrings to the network in a failsafe way
03:40:35 <Peaker> Cale: I don't like monadic parsers, though -- backtracking is rarely necessary (everyone is context-free), especially in binary parsers
03:40:39 <Cale> You know, you can use Parsec with bytestrings now.
03:41:40 <quicksilver> inbuninbu: not enough data is one kind of invalid.
03:41:50 <quicksilver> inbuninbu: at least, that's how I intended my comments to be understood.
03:42:01 <Cale> hmm, but it seems to default to the Char8 variety of ByteStrings, so maybe you'd have to write a quick instance of Stream
03:42:04 <inbuninbu> quicksilver: ah, ok
03:42:10 <inbuninbu> well, it making a custom get monad with MaybeT an option?
03:42:22 <inbuninbu> it=is
03:42:23 <quicksilver> yes, it's an option.
03:42:36 <quicksilver> but is eof observable in Get ?
03:42:41 * quicksilver forgets the api
03:42:44 <Cale> It is...
03:43:07 <Cale> http://hackage.haskell.org/packages/archive/binary/0.5.0.1/doc/html/Data-Binary-Get.html#v%3AisEmpty
03:43:22 <quicksilver> yes, it is.
03:43:23 <quicksilver> good.
03:43:26 <Cale> see also right above that is remaining
03:43:41 <quicksilver> inbuninbu: note that MaybeT (Get a) is really just Get (Maybe a)
03:43:52 <Peaker> Cale: Char8 is its own ByteString type? I thought it was just a set of convenience functions (pack/unpack)
03:43:53 <quicksilver> inbuninbu: the different is in how the combinators treat stuff :)
03:44:15 <quicksilver> but Get (Maybe a) might be good enough.
03:44:20 <Peaker> quicksilver: MaybeT (Get a) is not worth much because the get stuff that can fail aren't in it :(
03:44:36 <quicksilver> Peaker: it's not really a different type but the api looks like it is.
03:44:38 <Peaker> unless one wraps all of the Get combinators with ones that fail properly
03:44:49 <quicksilver> Peaker: I'm not suggesting inbuninbu ever runs a failing combinator
03:44:54 <quicksilver> I'm suggesting he checks first
03:45:04 <quicksilver> which is why I was asking about remaining and isEmpty
03:45:08 <Cale> Ah, okay
03:45:23 <inbuninbu> actually, let me check, does ByteString.Lazy.hGet fail?
03:45:26 <Cale> Right, it's not different.
03:45:38 <Peaker> quicksilver: yeah, its what I do too
03:46:02 <Peaker> Cale: there's actually ByteString.{Strict,Lazy}.Char8
03:46:21 <quicksilver> inbuninbu: hGet is in IO so it throws a catchable IO exception I suspect.
03:46:36 <Cale> Peaker: right, but the .Char8 just reexports the same type as the non-Char8 version
03:46:48 <quicksilver> you don't get interlaved IO unless you call the despicable getContents or readFile, I hope.
03:46:59 <Peaker> I dislike the code duplication w.r.t ByteStrings. And the fact they're just unboxed arrays of Char, and should probably be type-polymorphic.   Type-classes shouldn't slow things down when the types are known at compile-time, but at least get rid of some code duplication
03:48:24 <quicksilver> unboxed arrays of Word8, ITYM.
03:49:02 <quicksilver> yeah, possibly it would be nice if there was a big bytestring interface that Strict/Lazy could both instance
03:49:17 <quicksilver> although personally I quite like distinguishing rather visibly between the two
03:49:22 <quicksilver> (L.hGet, S.hGet)
03:49:37 <Peaker> quicksilver: ITYM? Its what I mean? Yeah
03:49:50 <quicksilver> I Think You Mean.
03:49:53 <Peaker> yeah
03:50:22 <Cale> Unboxed and type polymorphic don't mix so well
03:50:24 <Peaker> quicksilver: hGet :: L.ByteString -- nicer, carries the strict/lazy polymorphism to callers too
03:50:43 <Peaker> Cale: Even if its the instances that are unboxed?
03:50:51 <Peaker> (and might be boxed, too)
03:51:00 <quicksilver> > length "hGet :: L.ByteString" - length "L.hGet"
03:51:01 <lambdabot>   14
03:51:05 <Peaker> I mean, the whole (UArray Word8) would be an instance
03:51:08 <quicksilver> Peaker: 14 characters longer. No deal.
03:51:23 <Peaker> quicksilver: heh, you could alias L.ByteString to LBS if you want
03:51:33 <Peaker> > length "hget :: LBS" - length "L.hGet"
03:51:34 <lambdabot>   5
03:51:46 <maltem> type LazyByteString = LazyString Word8; type StrictByteString = StrictString Word8 -- ?
03:51:57 <Peaker> not to mention "characters" is not a nice measure, and not to mention you're not likely to use the forced type everywhere, but only once somewhere
03:52:08 <Peaker> quicksilver: its likely it will shorten code, actually, because you'll just remain polymorphic
03:52:11 <Peaker> quicksilver: so its just hGet
03:52:22 <quicksilver> btu I don't *want* to be polymorphic.
03:52:26 <Cale> Peaker: well, that much works
03:52:35 <quicksilver> if I'm writing for bytestrings, I want to know if it's strict or laxy
03:52:40 <quicksilver> the semantics is very different.
03:53:38 <Peaker> quicksilver: yeah, but you can force the strict/lazy behavior from above, and allow the functions below to be more useful by allowing both. Only if it makes no sense to allow both (probably a minority of the functions) you should force the types, and then you don't need to do it by (:: ...) but just the function's type signature + inference will do it for you
03:53:51 <quicksilver> sure, I follow the argument.
03:54:01 <quicksilver> I just disagree with (probably a minority)
03:54:06 <maltem> quicksilver, fwiw, the semantics of IO and Reader are very different, too
03:54:16 <quicksilver> the only time you would ever use a bytestring in the first place is when you care deeply about the semantics.
03:54:23 <quicksilver> sorry, abotu the efficiency
03:54:37 <quicksilver> (was reading maltem's comment as I was typing, my brain stole a word)
03:54:38 <Peaker> quicksilver: ok, but even if its a majority, its still not longer if you let inference do the job, most of the time (you eventually return or take a bytestring in those functions and you typically put a top-level type signature, right?)
03:55:05 <inbuninbu> actually i think the simplest solution is to use the ByteString hGet
03:55:12 <Peaker> quicksilver: yeah, but type-classes and UArray Word8  shouldn't harm performance here?
03:55:17 <inbuninbu> if it reaches the end of the file, it doesn't throw an error
03:55:33 <inbuninbu> it just returns what it can. so if it's too short, you can check before you call runGet
03:55:55 <Peaker> @type Data.ByteString.hGet
03:55:56 <lambdabot> GHC.IOBase.Handle -> Int -> IO BSC.ByteString
03:56:46 <EvilTerran> muhahahaha
03:57:17 <otulp> Cale: Oh well. Thanks for the input. I'm going to try to store all values in an array now instead, and possibly make a map of coords to array indices. It shouldn't work, but.. perhaps?
03:57:25 <Peaker> EvilTerran: ?
03:57:54 <Peaker> hmm. I keep rewriting       traceId prefix x = trace (prefix ++ show x) x       everywhere. Is it sane to cabalize just one function in something like a traceutils package?
03:57:57 <inbuninbu> actually, hGet won't work either. you could lie in the header about the size of the payload
03:58:11 <inbuninbu> that lets anyone make it crash
03:58:20 <inbuninbu> if they really want to
03:58:43 <Peaker> inbuninbu: I think you should just write Get primitives that check the length and format and return MaybeT Get  instead of Get, calling get primitives only when they are certain that they cannot fail
03:59:01 <quicksilver> inbuninbu: that's wthe kind of thing hat I mean about checking first
03:59:06 <quicksilver> ;)
03:59:16 <quicksilver> you probably want to do saity checks anyway.
03:59:23 <inbuninbu> Peaker, quicksilver: thanks.
03:59:29 <quicksilver> If the payload advertises a 4G message you may not want to read that, in fact :)
03:59:36 <quicksilver> s/payload/header/
03:59:51 <quicksilver> damn words. Always the wrong one in the wrong place. Sometimes I can't even understand myself.
04:00:38 <Peaker> I wonder how Iteratee plays with ByteString handling of binary files?
04:04:44 <ClaudiusMaximus> if i import Prelude(), ghci lets me use (:), but hugs doesn't (and i can't figure out the syntax to import it explicitly)
04:06:12 <quicksilver> ClaudiusMaximus: import Prelude((:))
04:06:24 <quicksilver> ghc makes (:) special. A bit too special, arguably.
04:06:34 <Peaker> weird indeed. is it not a bug that GHC imports (:) and () and [] and lots of other stuff even if not requested to, from Prelude?
04:06:40 <quicksilver> > let (:) = (+) in 1:3
04:06:41 <lambdabot>   Constructor `:' should have 2 arguments, but has been given 0
04:06:47 <ClaudiusMaximus> quicksilver: ERROR "Test.hs":3 - Syntax error in import declaration (unexpected symbol ":")
04:07:07 <quicksilver> ah, it's a constructor
04:07:10 <quicksilver> I wonder what the syntax is
04:07:21 <quicksilver> import Prelude([](:)) maybe ?
04:07:39 <ClaudiusMaximus> quicksilver: ERROR "Test.hs":3 - Syntax error in import declaration (unexpected `[')
04:07:54 <Peaker> I guess that's why GHC does this, there doesn't seem to be a syntax to do this
04:07:55 <quicksilver> Peaker: I'm not sure if it's a bug relative to the standard or not. [], (:) and () are not merely symbols, they are actually syntax.
04:08:06 <Peaker> probably list syntax sugaring is unnecessary
04:08:15 <quicksilver> They're syntax which stands for symbol, obviously.
04:08:19 <quicksilver> but they're technically syntax.
04:08:21 <Peaker> 1:2:3:[] is not so bad
04:08:57 <inbuninbu> one other quick question... i was recently facing an issue where i had a monstrous (well, 30-odd line) case statement, and tried to figure out a way to make it shorter
04:08:58 <Peaker> quicksilver: () is understandable (all tuples are), but (:) and [] shouldn't probably be syntax
04:09:05 <inbuninbu> this is what i came up with:
04:09:07 <inbuninbu> caseOneLine arg = snd $ head (filter ((\a (b,c)->a==b) ) $ zip [1..100] [action1,action2,action3,action4,action5])
04:09:27 <inbuninbu> is there a better way to do this?
04:10:22 <quicksilver> Peaker: (:) probably doesn't need to be.
04:10:25 <quicksilver> Peaker: [] does.
04:10:34 <Peaker> quicksilver: Only for [Int] rather than [] Int  ?
04:10:51 <Peaker> quicksilver: I think if [Int] is so nice, then other functors should also get to wrap around the type
04:11:27 <Peaker> perhaps if : is the infix constructor, then [<symbols here> .. <and here>] should be the surrounding constructor
04:11:49 <Peaker> inbuninbu: why is your filter taking a function of two args?
04:12:01 <Peaker> ibid: did you not mean to compare with arg there, and not take a?
04:12:08 <Peaker> inbuninbu: that is
04:12:08 <inbuninbu> that should be: caseOneLine arg = snd $ head (filter ((\a (b,c)->a==b) arg) $ zip [1..100] [action1,action2,action3,action4,action5])
04:12:23 <Peaker> inbuninbu: you know Haskell is lexically scoped, right? :)
04:12:32 <Peaker> inbuninbu: you can use arg in the filter's lambda, without re-passing it into there
04:13:16 <inbuninbu> i knew i was missing something :-)
04:13:17 <Peaker> \arg xs -> snd $ head (filter (\(b,c)->arg==b) xs
04:13:20 <Peaker> @type \arg xs -> snd $ head (filter (\(b,c)->arg==b) xs
04:13:21 <lambdabot> parse error (possibly incorrect indentation)
04:13:29 <Peaker> @type \arg xs -> (snd $ head (filter (\(b,c)->arg==b) xs)
04:13:30 <lambdabot> parse error (possibly incorrect indentation)
04:13:34 <Peaker> @type (\arg xs -> (snd $ head (filter (\(b,c)->arg==b) xs))
04:13:35 <lambdabot> parse error (possibly incorrect indentation)
04:13:38 <Peaker> sorry
04:13:55 <Peaker> @type (\arg xs -> snd $ head (filter (\(b,c)->arg==b) xs))
04:13:56 <lambdabot> forall b a. (Eq a) => a -> [(a, b)] -> b
04:14:05 <Peaker> inbuninbu: you know this function is unsafe right?
04:14:09 <Peaker> @type Data.List.lookup
04:14:10 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
04:14:19 <Peaker> inbuninbu: You want to use Data.List.lookup which is safe
04:14:51 <inbuninbu> right; mostly i was wanting it to work before being safe :-)
04:16:06 <inbuninbu> but it's nice to know there's a out-of-the-box function that does it. i need to start looking at type sigs more carefully
04:16:36 <Peaker> @type \key -> fromMaybe (print "missing key, do whatever here") . Data.List.lookup key $ [(1, print 1), (2, print 2)]
04:16:37 <lambdabot> forall a. (Num a) => a -> IO ()
04:17:09 <Peaker> inbuninbu: I wouldn't use zip there, because you might "mis-align" your list to handle the cases all wrong. Use explicit tuples IMO
04:18:40 <inbuninbu> Peaker: i've got two algebraic data types actually, and derived enum on them both
04:18:54 <inbuninbu> i guess i could map an offset (there's an offset on one)
04:19:07 <inbuninbu> and then zip; it should be safe, since they are in the same order
04:19:20 <inbuninbu> just need to make sure when i update on i update the other
04:19:33 <inbuninbu> oh wait, that doesn't make sense :-/
04:20:10 <Peaker> @hoogle Eq a => (b -> a) -> [b] -> b
04:20:10 <inbuninbu> i call get methods based on the input type
04:20:10 <lambdabot> Data.Generics.Schemes everywhere :: (a -> a) -> a -> a
04:20:10 <lambdabot> Data.Generics.Schemes everywhere' :: (a -> a) -> a -> a
04:20:10 <lambdabot> Distribution.Simple.Utils equating :: Eq a => (b -> a) -> b -> b -> Bool
04:20:30 <Peaker> @hoogle Eq a => a -> (b -> a) -> [b] -> b
04:20:31 <lambdabot> Distribution.Simple.Utils equating :: Eq a => (b -> a) -> b -> b -> Bool
04:20:31 <lambdabot> Control.Parallel.Strategies parZipWith :: Strategy c -> (a -> b -> c) -> [a] -> [b] -> [c]
04:20:31 <lambdabot> Distribution.ParseUtils simpleField :: String -> (a -> Doc) -> ReadP a a -> (b -> a) -> (a -> b -> b) -> FieldDescr b
04:20:54 <Peaker> inbuninbu: zipping with some result and then running lookup deserves its own function
04:21:53 <Peaker> @type \key f xs -> Data.List.lookup key . map (f&&&id) xs
04:21:54 <lambdabot>     Couldn't match expected type `a -> [(a1, b)]'
04:21:54 <lambdabot>            against inferred type `[(c, a2)]'
04:21:54 <lambdabot>     In the second argument of `(.)', namely `map (f &&& id) xs'
04:22:12 <Peaker> @type \key f xs -> Data.List.lookup key . map (f&&&id) $ xs
04:22:13 <lambdabot> forall a a1. (Eq a) => a -> (a1 -> a) -> [a1] -> Maybe a1
04:22:34 <Peaker> @hoogle lookupBy
04:22:34 <lambdabot> No results found
04:22:47 <Peaker> inbuninbu: I think you should use that then.  I'd call it lookupBy, and then (lookupBy offset) or whatever you have there
04:22:51 <inbuninbu> Peaker: whoah, looking at strategies makes my brain hurt
04:23:01 <Peaker> inbuninbu: strategies?
04:23:24 <inbuninbu> Peaker: i don't know. i saw it from hoogle and looked
04:26:14 <Peaker> inbuninbu: anyway, do you have lookupBy now? :-)
04:26:36 <Peaker> @let lookupBy key f xs = Data.List.lookup key . map (f&&&id) $ xs
04:26:37 <lambdabot>  Defined.
04:27:20 <Peaker> @type \default key f xs -> fromMaybe default $ lookupBy key f xs
04:27:21 <lambdabot> parse error on input `default'
04:27:25 <inbuninbu> Peaker: i'm still trying to understand exactly what's going on in it, from the context of my problem. didn't recognize &&& at first, have't really tried arrows yet
04:27:26 <Peaker> @type (\default key f xs -> fromMaybe default $ lookupBy key f xs)
04:27:27 <lambdabot> parse error on input `default'
04:28:03 <ClaudiusMaximus> default is a keyword, i discovered that by accident today
04:28:14 <Peaker> what is it for?
04:28:21 <ClaudiusMaximus> defaulting types
04:28:27 <ClaudiusMaximus> i think
04:28:31 <Peaker> how?
04:28:33 <Peaker> @type \def key f xs -> (fromMaybe def $ lookupBy key f xs)
04:28:34 <lambdabot> forall a a1. (Eq a1) => a -> a1 -> (a -> a1) -> [a] -> a
04:28:48 <Peaker> inbuninbu: This is the function I think you need
04:31:23 <inbuninbu> Peaker: so... in the case of
04:31:30 <inbuninbu> case x of
04:31:35 <inbuninbu> 10 -> action10
04:31:41 <ClaudiusMaximus> Peaker: http://haskell.org/onlinereport/decls.html#sect4.3.4
04:31:44 <inbuninbu> 11 -> action11
04:32:17 <inbuninbu> a woud be, say, 11
04:33:20 <Peaker> wow, didn't know that feature existed at all
04:33:23 <Peaker> ClaudiusMaximus: interesting
04:33:38 <Peaker> though I think it is pretty much an inherently broken feature, which might be the reason its not well known
04:34:14 <dcoutts> Feuerbach: you were asking about the spaces in .chs files, you're probably looking at the .chs file generated from a .chs.pp file, try looking at the original source file.
04:34:54 <Peaker> inbuninbu: no no, if you have:   case x of 10 -> action10  11 -> action11  _ -> actionDef   then you need  lookupWithDefault actionDef x [(10, action10), (11, action11)]
04:36:03 <inbuninbu> Peaker: what is actionDef?
04:37:14 <inbuninbu> ohhh
04:37:28 <inbuninbu> Peaker: the default. i thought def meant definition
04:38:43 <ivanm> @wn def
04:38:46 <lambdabot> No match for "def".
04:38:53 <ivanm> nope, def doesn't mean anything
04:38:55 <ivanm> ;-)
04:39:57 <Feuerbach> dcoutts: oh, thanks, I thought .chs files were original.
04:47:14 <inbuninbu> Peaker: i must be missing something
04:47:20 <inbuninbu> let x = lookupByDefault (print "null") x [(10,print "ten"),(11,print "eleven")] results in an error
04:47:49 <Peaker> inbuninbu: note your use of x in both places there?
04:47:57 <inbuninbu> Peaker: yep
04:48:02 <deiga> dons: Hey, I've tested your Network.Download package and it doesn't work. It install fine, but it sprays error message when trying to use it
04:48:53 <Peaker> inbuninbu: you don't want x to be both the input, and the result, of lookupByDefault
04:49:18 <deiga> dons: <interactive>: /usr/lib/download-0.3/ghc-6.10.3/HSdownload-0.3.o: unknown symbol 'stat64'
04:50:01 <inbuninbu> shouldn't the result come from evaluating the entire expression?
04:50:35 <quicksilver> inbuninbu: your definition is recursive.
04:50:38 <quicksilver> those are the same 'x'
04:50:39 <quicksilver> as in
04:50:46 <inbuninbu> quicksilver,Peaker: thanks, duh
04:50:48 <quicksilver> > let x = 1 : x in x
04:50:49 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
04:50:54 <inbuninbu> brainfart maneuver
04:51:46 <komar_> How to force ./Setup to not touch package.conf?
04:53:58 <inbuninbu> Peaker: apparently i'm in braindead mode: let y z = lookupByDefault (print "null") z [(10,print "ten"),(11,print "eleven")] still gives me the same error
04:54:58 <inbuninbu>     Couldn't match expected type `IO () -> ()'
04:54:59 <inbuninbu>            against inferred type `[a]'
04:55:07 <Peaker> inbuninbu: how is lookupByDefault defined?  I suggest naming it lookupWithDefault, and not ByDefault
04:55:45 <inbuninbu> \def key f xs -> (fromMaybe def $ lookupBy key f xs)
04:58:54 <LeCamarade> @hoogle postgresql
04:58:55 <lambdabot> package PostgreSQL
04:58:55 <lambdabot> package haskelldb-hdbc-postgresql
04:58:55 <lambdabot> package haskelldb-hsql-postgresql
04:59:05 <LeCamarade> ?where postgresql
04:59:06 <lambdabot> I know nothing about postgresql.
04:59:18 <LeCamarade> ?where haskelldb-hdbc-postgresql
04:59:18 <lambdabot> I know nothing about haskelldb-hdbc-postgresql.
04:59:23 <LeCamarade> ?where haskelldb
04:59:23 <lambdabot> http://haskelldb.sourceforge.net/
04:59:25 <dancor> how do you add 1 day to a UTCTime
04:59:43 <dancor> i can use addDays
04:59:53 <LeCamarade> ?where hsql
04:59:53 <lambdabot> http://htoolkit.sourceforge.net
04:59:53 <dancor> ok, how do you add 8 hours to a UTCTime
05:00:09 <LeCamarade> dancor, Add it in seconds, if memory serves.
05:00:40 <inbuninbu> Peaker: monomorphism problem?
05:02:35 <LeCamarade> Is HaskellDB still alive? Or, what should I use to talk to PostgreSQL in Haskell?
05:02:52 <Saizan_> hdbc?
05:03:22 <LeCamarade> ?where hdbc
05:03:23 <lambdabot> http://quux.org/devel/hdbc
05:03:44 <LeCamarade> @karma+ Saizan_
05:03:44 <lambdabot> Saizan_'s karma raised to 4.
05:04:19 <LeCamarade> Dear Jesus, I'm surfing Gopher! :-o
05:04:27 <LeCamarade> For HDBC!
05:04:31 <LeCamarade> http://gopher.quux.org:70/devel/hdbc
05:04:52 <QtPlaty[HireMe]> I can't recall how long its been since i've used Gopher.
05:06:47 <Saizan_> just look at the hackage page.
05:11:24 <LeCamarade> Building HDBC, I get that System.Time cannot be found. Now, obviously I have it, and I have GHC 6.10. Why is this build being so insolent?
05:11:43 <LeCamarade> And I checked the code, it looks like what I'd write to use System.Time.
05:11:46 <LeCamarade> :o(
05:12:22 <dancor> LeCamarade: there is also takusen.  i have a patch out for adding support for postgres bytea
05:12:46 <LeCamarade> ?where takusen
05:12:46 <lambdabot> I know nothing about takusen.
05:13:09 <dancor> @where+ takusen http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Takusen
05:13:09 <lambdabot> Done.
05:15:22 <quicksilver> LeCamarade: it's now in old-time
05:15:29 <quicksilver> LeCamarade: it was moved in 6.10.somethingorother
05:15:44 <quicksilver> I think.
05:16:10 <LeCamarade> I've moved to Takusen.
05:16:19 <LeCamarade> Is Takusen the one that Oleg was working on?
05:16:27 <LeCamarade> The Oleg?
05:17:48 <quicksilver> yes, that's right I believe.
05:21:40 <Berengal> What's the quickest and easiest way to push pixels?
05:22:18 <quicksilver> to the screen?
05:22:21 <Berengal> Yes
05:22:32 <quicksilver> quickest is probably opengl, or some other api which ultimate binds to it.
05:22:41 <quicksilver> I've no idea what the easiest is
05:22:47 <quicksilver> (almost certainly *not* opengl)
05:23:06 <Twey> I don't know, OpenGL is pretty easy for pixel-pushing
05:23:19 <Twey> It's just the complicated stuff
05:23:46 <Berengal> I just want something like 'putPixel position color'
05:23:52 <Twey> Yeah
05:24:23 <quicksilver> Twey: I disagree.
05:24:25 <Twey> Oh, but that's within a window, right?
05:24:38 <quicksilver> Twey: you have to learn about viewports, transformations, textures, texture coordinates, pipelines, blending modes
05:24:42 <Twey> If you want to do it over the whole screen you'll need the confusingly-named X11
05:24:45 <quicksilver> Twey: that's a long pathway to just pushing a pixel :)
05:24:53 <Twey> quicksilver: What, just to push a pixel?
05:24:57 <ray> putPixel color position sounds better
05:24:58 <quicksilver> Yes.
05:25:06 <Twey> I was drawing polygons and I never knew what those things meant.
05:25:19 <quicksilver> then someone else must have written the boilerplate code for you
05:25:26 <quicksilver> or you copied it form somewhere.
05:25:29 <Twey> Come to think of it, I was using GLUT
05:25:32 <quicksilver> and polygons are easier than pixels, in opengl.
05:25:37 <Twey> Truly?  Huh.
05:25:49 <ray> opengl isn't really meant to do pixels
05:26:01 <quicksilver> it does it very well though.
05:26:08 <quicksilver> I jsut doubt it would be the 'easiest' way :)
05:26:15 <Twey> You could just do a tiny polygon.  :-P
05:26:20 <quicksilver> Berengal: you don't push pixels one at a time if you want decent performance though :)
05:26:35 <Berengal> quicksilver: I'm not looking for performance. I just want to push pixels :P
05:26:41 <Berengal> Besides, I've got a bitchin' GPU
05:27:24 <ray> opengl isn't even really meant to do 2D
05:27:47 <Twey> Silly OpenGL — current monitors are flat!
05:27:50 <Berengal> I'm thinking about implementing an L-system, I just want to make sure I can draw the results when the time comes
05:28:18 <ray> well, i guess it's meant to do 2D *projections*
05:28:31 <Twey> Heh
05:28:41 <dancor> how do i go from POSIXTime (= NominalDiffTime) to seconds?
05:28:47 <ray> opengl 2D is just an orthographic projection
05:29:40 <Saizan_> L-systems were the cairo bindings demo, iirc
05:29:44 <Twey> dancor: What library are you using?
05:29:57 <dancor> Twey: Data.Time
05:30:14 <Twey> Why not System.Time?
05:30:28 <quicksilver> because System.Time is deprecated
05:30:31 <quicksilver> and has a broken API.
05:30:37 <dancor> and is not in hoogle
05:30:46 <dancor> my keyhole into the world of haskell
05:31:05 <Twey> Oh really?  Huh.
05:31:31 <Saizan_> Berengal: http://haskell.org/gtk2hs/archives/2005/08/31/the-potential-of-pratical-haskell-2nd-edition/ and other posts
05:31:34 <quicksilver> dancor: use realToFrac
05:31:43 <quicksilver> dancor: it's a Num/Real/RealFrac instance
05:31:47 <dancor> ok
05:31:48 <Berengal> Saizan_: Nifty, thanks
05:31:48 <LeCamarade> Takusen won't load Database.PostgreSQL.Enumerator.
05:31:49 <LeCamarade> :o(
05:31:55 <Twey> Boo
05:32:03 <Twey> I just found it and someone had already answered :-P
05:32:06 <LeCamarade> God, DBs are hard, eh? Let's stick to plain text. ;o)
05:32:30 <quicksilver> dancor: if you mean "seconds since the epoch"
05:32:36 <Berengal> Cairo, huh?
05:32:41 <quicksilver> dancor: if you mean "seconds after the current hour" that's not what you want :)
05:32:57 <dancor> i do mean since epoch
05:33:05 <dancor> but it's already Fractional
05:33:22 <quicksilver> yes but you can convert it to a Double.
05:33:27 <quicksilver> or you can simply round it to an Int
05:33:30 <quicksilver> :t round
05:33:31 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
05:33:37 <quicksilver> because it is a RealFrac instance.
05:36:16 <LeCamarade> Who uses Takusen here?
05:37:01 <Berengal> round should work
05:47:41 <ksf> opengl is fine for 2d.
05:48:20 <ksf> ...look at all that glRaster stuff, or just draw a textured fullscreen quad.
05:51:22 <akamaus> I'm using Network.Browse module from http package. It's built around a custom monad BrowserAction which is a wrapper on IO. That's convenient, but how to handle exceptions there? 'try', 'catch' and the rest are in IO.
05:51:37 <Peaker> ksf: Not very convenient, it isn't
05:53:52 <ksf> akamus, there should be a liftIO somewhere... look at the connections to Monad.Trans.
05:53:55 * WorkyBob ponders... is there any documentation on when ghc garbage collects CAFs?
05:54:38 <Axman6> when it feels like it!
05:54:52 <WorkyBob> yeh... that's what I'm seeing :P
05:55:00 <WorkyBob> i.e. I've got one that seems to be collected sooner than it should be
05:55:13 <doserj> akamaus: the liftIO is called ioAction
05:55:47 <ksf> Peaker, well, at least you get free alpha composition and superb polygon support.
05:58:59 <akamaus> doserj, yes, but I cant pass (BrowserAction a) to 'try' anyway. And if I use 'browse' I'll lose state
06:00:14 <Axman6> hmm, would deleting the 6.10.2 and 6.10.1 folders under ~/.cabal/lib/PACKAGE be ok?
06:00:42 <Axman6> trying to make my .cabal dit not 2.5GB
06:00:45 <Axman6> dir*
06:03:12 <doserj> akamaus: you can set an error handler. setErrHandler :: (String -> IO ()) -> BrowserAction t ()
06:04:30 <akamaus> doserj, oh, thanks. I was looking for something like this
06:04:59 <doserj> Axman6: if you don't use 6.10.2 and 6.10.1 anymore, sure
06:05:28 <Axman6> ok, cheers
06:10:55 <akamaus> doserj, hmm, looks like setErrHandler won't prevent BrowseAction to fail, it's just a handler for error message
06:13:26 <doserj> fail in the BrowseAction monad calls fail in the IO Monad.
06:54:50 * byorgey makes lambdaberry muffins
06:55:02 * Badger eats
06:55:27 <ray> \berry -> muffins
06:55:33 <Hong_MinHee> 2
06:55:45 <EvilTerran> const muffins?
06:56:09 <byorgey> I guess that's one way to look at it
06:56:12 <Athas> What's the most common reason of stack space overflow?
06:56:20 <byorgey> the berries get erased at compile time
06:56:35 <Berengal> Athas: Too much lazyness
06:56:38 <ray> giant thunks
06:56:49 <ray> tremendous thunks
06:56:51 <Athas> I can believe that.
06:57:18 <byorgey> THUNK <--- sound of a giant thunk blowing the stack
06:57:28 <cjay> "thunks bigger than your mum"
06:57:44 <byorgey> who invented the term "thunk"?  I would like to buy that person a beer.
06:57:51 <byorgey> or a drink of their choice.
06:57:53 <duaneb> ok
06:57:56 <duaneb> I'm gonna do something fun
06:57:57 <Twey> It's actually not a thunk but a T-hunk, as I recall
06:58:03 <duaneb> I'm gonna write an MP3 decoder in haskell :D
06:58:12 <Axman6> good idea
06:58:16 <Peaker> byorgey: who would have thunk it
06:58:19 <Twey> http://en.wikipedia.org/wiki/Thunk
06:58:31 <Twey> P.Z. Ingerman
06:58:42 <Berengal> Thunking in general is hard...
06:58:54 <Twey> You're in luck: he's still alive
06:58:57 <madhadron> Berengal, Yes, the past is typically immutable
06:59:06 <opqdonut> yeah, thunk is a great term
06:59:27 <cjay> I always thaught "thunk" was a cross between "think" and "chunk"
06:59:44 <madhadron> I've got a oddball design problem I'd appreciate opinions on...
06:59:55 <madhadron> I'm writing a microscope control application (in Haskell)
06:59:56 <Berengal> I used to think it was just another name for foo
07:00:19 <madhadron> and while I've got a decent purely functional structure as a substrate for the logic for the microscope state
07:00:23 <byorgey> Twey: where did you find the fact that he is still alive?
07:00:42 <madhadron> I'm trying to figure out where to put frames coming back from the camera when it's actually hooked up to hardawre
07:00:45 <Twey> Cursory Google, verifiability low
07:00:55 <byorgey> \o/ apparently he was at U Penn when he published the original thunk paper!
07:01:06 <byorgey> clearly I go to the best school ever
07:01:48 <ray> u penn, home of the thunk
07:02:09 <madhadron> byorgey, You should start a movement to change the school mascot
07:02:37 <byorgey> madhadron: totally.  I think our current mascot is the 'quaker' or something lame like that
07:03:26 <duaneb> I've come to a realization
07:03:35 <duaneb> I've been writing a ton of lisp primitives in haskell
07:03:41 <duaneb> and writing lisp in haskell is NOT FUN.
07:04:01 <Berengal> duaneb: Then don't? Or switch to lisp...
07:04:01 <QtPlaty[HireMe]> duaneb: Which primitives?
07:04:31 <jmcarthur> duaneb: http://blog.bjrn.se/2008/10/lets-build-mp3-decoder.html
07:04:33 <duaneb> Berengal: I wasn't complaining, I was just observing
07:04:39 <duaneb> jmcarthur: no fun
07:04:41 <duaneb> that's cheating
07:04:46 <jmcarthur> heh
07:04:46 <Peaker> Implementing a dynamically-typed imperative language (mutable objects that have identities) in Haskell doesn't sound nice
07:04:50 <jmcarthur> just pointing it out
07:05:16 <duaneb> QtPlaty[HireMe]: car, cdr, cons, eq(v|ual)?, arithmetic, etc
07:05:37 <EvilTerran> Peaker, eh, shouldn't be too hard to make an interpreter with ST/IORefs
07:05:50 <EvilTerran> and Data.Dynamic :P
07:07:21 <Athas> What makes a thunk allocate on the stack, rather than the heap?
07:08:09 <Berengal> Athas: Thunks are allocated on the heap, but evaluating them uses the stack
07:08:20 <Athas> Hm.
07:08:35 <nitrofurano> how can i compile Monadius shmup (uses haskell and opengl) on Ubuntu Linux?
07:08:45 <byorgey> right, it's the evaluation of huge thunks that blows the stack, not the thunks themselves.
07:08:58 <Saizan> the stack grows as the distance from the outermost application and the first reducible expression, roughly
07:09:11 <Athas> Yeah, most of my other space leaks blew up the heap instead.
07:09:16 <Saizan> s/and/to/
07:09:30 <Peaker> EvilTerran: ST is deterministic, Lisp isn't
07:09:33 <Saizan> @wiki Stack overflow
07:09:33 <lambdabot> http://www.haskell.org/haskellwiki/Stack_overflow
07:09:38 <Saizan> have you read that?
07:09:43 <EvilTerran> > foldl f e [x,y,z] :: Expr
07:09:44 <lambdabot>   f (f (f e x) y) z
07:09:58 <Athas> No, but I will now.  Thanks.
07:10:02 <quicksilver> Peaker: lisp isn't deterministic?
07:10:12 <Berengal> Athas: You can try simple substitution.. for example, foldl (+) 0 [1..foo] reduces to 1+2+3+4+5+..., and evaluating that requires stack
07:10:18 <Peaker> quicksilver: nope, it can call undeterministic imperative functions freely
07:10:23 <madhadron> quicksilver, Nope.  McCarthy actually created a fascinating little nondeterministic operator
07:10:27 <Peaker> it needs IO, not ST
07:10:37 <quicksilver> Peaker: "undeterministic imperative functions" ?
07:10:40 <madhadron> quicksilver, Which he called 'amb' if I recall correctly.  One of his typical games
07:10:43 <quicksilver> Peaker: like what?
07:10:44 <EvilTerran> ^ long foldls can have a long way between the outermost application and first reducible expression
07:10:46 <Peaker> quicksilver: yeah, like getCPUTemperature
07:10:57 <quicksilver> Peaker: that's not part of lisp.
07:11:10 <quicksilver> lisp can contain bindings to non-deterministic library functions, sure.
07:11:31 <quicksilver> so can all useful languages - only haskell doesn't call them functions.
07:11:40 <quicksilver> but the core language lisp as generall understood is deterministic.
07:11:54 <Peaker> quicksilver: well, you can't run Lisp in ST, its not powerful enough, needs IO
07:12:01 <Berengal> quicksilver: Multivalued returns?
07:12:31 <quicksilver> madhadron: mccarthy "added" amb to lisp; he didn't create it in lisp.
07:12:35 <quicksilver> Berengal: ?
07:12:51 <Peaker> I don't get these silly features like multi-value return, lisp-2, dynamic scoping
07:12:52 <quicksilver> Peaker: the core lisp language can be easily run in ST, or indeed without ST.
07:13:01 <Berengal> quicksilver: Sort of like python generators...
07:13:01 <madhadron> quicksilver, Ah, you're really talking about the axiomatic structure as Lisp.  Sure, in that case you're absolutely right.
07:13:03 <quicksilver> just using a Data.Map for symbol looking.
07:13:11 <Berengal> Or the list monad
07:13:15 <Peaker> quicksilver: how do you separate the core from non-core? Is "equal" or "eq" not in core?
07:13:22 <madhadron> quicksilver, And a state monad's the right place for it to live.
07:13:38 <quicksilver> Peaker: they both are, and that's fine.
07:14:05 <quicksilver> I don't know how I define it, but it's pretty obvious to me what's part of the lisp language and what isn't.
07:14:08 <quicksilver> ;)
07:14:20 <quicksilver> 'eq' and 'caddr' are part of lisp.
07:14:24 <madhadron> quicksilver, Like pornography, huh?
07:14:26 <quicksilver> 'getCPUTemperature' is not.
07:14:27 <quicksilver> quite.
07:14:34 <Peaker> quicksilver: I guess if you remove all non-pure things from Lisp, and consider identities as pure attributes of values, that can work
07:14:40 <quicksilver> I don't know much about lisp but I know what I like.
07:14:47 <quicksilver> Peaker: I don't try to remove all non-pure things from lisp
07:14:47 <madhadron> Peaker, Lisp-2 and dynamic scoping were mistakes before people knew better.  Multi-value return was as well, but pattern matching and tuples took longer to be accepted.
07:14:58 <quicksilver> Peaker: I wasn't arguing about lisp being impure
07:15:01 <quicksilver> that's obviously true.
07:15:08 <quicksilver> I was arguing abot it being non-deterministic
07:15:12 <quicksilver> that's very different.
07:15:30 <quicksilver> "setq" or "set" or whatever you wish to call it is impure but perfectly deterministic.
07:15:46 <Peaker> quicksilver: yeah, core Lisp is deterministic, if you exclude amb
07:15:56 <Peaker> quicksilver: but typically a Lisp interpreter wants to be able to run the libraries and what not
07:16:02 <madhadron> quicksilver, Though...have you read Dijkstra's 'Predicate Calculus and Program Semantics'?  He works in a purely logical structure but allows nondeterminism.
07:16:21 <madhadron> Admittedly a very different approach to programming than functional
07:16:27 <madhadron> but beautiful nevertheless
07:16:40 <quicksilver> madhadron: I haven't, no. I can well believe it. I was just suprised by the characterisation here of lisp as non-determnistic.
07:16:59 <Peaker> madhadron: Some Lispers still don't know better :P
07:17:20 <madhadron> Peaker, No, they're just getting by with what they have.
07:17:20 <madhadron> brb
07:17:54 <quicksilver> Some kinds of dynamic scoping type effect are quite useful.
07:17:58 <quicksilver> But I prefer it to be explicit.
07:18:09 <quicksilver> explicitly looking up a key in a mutable environment
07:18:20 <quicksilver> (so changing the environment and then changing it back is dynamic scoping)
07:18:35 <quicksilver> dynamic scoping as the default form of symbol resolution is painful though.
07:18:45 <Peaker> madhadron: heh, me in #lisp: <Peaker> Hey, do you consider dynamic scoping, Lisp-2, and multi-return values to be mistakes in various Lisp designs?
07:18:50 <Peaker> <tcr> Peaker: No to the contrary, I value all three very much, and wouldn't want to live without
07:19:04 <quicksilver> to be fair you did look you were trolling
07:19:18 * QtPlaty[HireMe] reas the MP3 posts "It says that huffman encoding is used in zip.  I didn't think that was the case."
07:19:18 <quicksilver> ;)
07:19:26 <Peaker> quicksilver: Politely asked, though :-)
07:19:44 <quicksilver> the best trolls are polite.
07:20:05 <Berengal> Haskell has dynamic scoping...
07:20:13 <Peaker> Berengal: ghc does
07:20:16 <Peaker> Berengal: Haskell98 too?
07:20:47 <Berengal> Peaker: Dunno. "Haskell" is "some implementation" to me...
07:21:03 <Peaker> Berengal: you referring to ?implicit args right?
07:21:09 <Berengal> Yes
07:22:00 <quicksilver> implict args are pretty much deprecated.
07:22:03 <skorpan> hi.  i'm using windows and would like to make an image (pdf, png, jpg, bmp, whatever) displaying a 2d graph.  what is the easiest way to accomplish this?
07:22:18 <doserj> implicit parameters are still lexically scoped
07:22:19 <skorpan> i'm using the haskell platform if that matters
07:22:20 <quicksilver> they're not quite dynamic in the normal sense either
07:22:27 <Peaker> doserj: how so?
07:22:28 <quicksilver> they're lexical but in a funny way.
07:22:38 <quicksilver> the scoping remains a static not a dynamic property of the code.
07:23:13 <Athas> I can't figure out where my program creates (or evaluates) these large thunks.  Are there any tools available to help me?
07:23:22 <quicksilver> Athas: heap profiling.
07:24:37 <Berengal> quicksilver: Can't you do 'let ?foo = findMeAFoo ...'
07:25:35 <Peaker> madhadron: #lisp is making it very clear people don't think Lisp-2, multi-value return, etc are bad features
07:27:32 <SamB> Peaker: sure! what do you suppose (# , #) is for?
07:28:04 <SamB> the thing that makes lisp 2 a pain is that mutability
07:28:26 <opqdonut> what does lisp-2 mean?
07:28:37 <Peaker> opqdonut: a special separate namespace for function names
07:28:37 <ski> Lisp-1 vs. Lisp-2 (vs. Lisp-N) is about the number of namespaces
07:28:46 <opqdonut> ah
07:28:51 <opqdonut> yeah it sucks imo
07:28:56 <Peaker> opqdonut: (funcname argname)  funcname is looked up in a different namespace than argname :(
07:29:30 <Peaker> SamB: I think what makes it a pain is that every function in the world that deals with namespaces has to be duplicated and yet more created to be able to use function-named values as values and vice versa
07:29:56 <Peaker> complicating the model for no gain, and even less readability and newbie-friendliness
07:30:32 <idnar> quicksilver: so what's the replacement for implicit args? :P
07:30:48 <madhadron> Peaker, <shrugs> Anyone who has used both Scheme and Common Lisp knows that Lisp-1 is the only way to go
07:31:12 <madhadron> Peaker, And again, anyone who's lived in Haskell or Erlang for a while knows that pattern matching is a vastly easier approach than multi-return
07:31:19 <quicksilver> idnar: programming.
07:31:30 <ski> i would be interesting to allow any number of namespaces .. e.g. consider creating a separate namespace for a DSL (possibly also allowing sub-expressions of the host language inside that)
07:31:40 <ski> s/i would/it would/
07:31:56 <quicksilver> the main thing (the only thing?) I don't like about functions in a separate namespace is it makes them feel less first-class.
07:31:56 <Peaker> madhadron: how is pattern-matching a replacement for multi-return?  Tuple unpacking?
07:32:03 <madhadron> Peaker, Exactly
07:32:17 <Peaker> madhadron: I think the multi-return thing is mainly about implicit type-coercion of users only aware of the first N args
07:32:32 <Peaker> madhadron: they can "extend" a function without breaking its type/callers
07:32:55 <madhadron> Peaker, Yes, it's a great way to patch things
07:33:32 <Peaker> madhadron: Hmm you know what?  Could be interesting (and hellish!) to be able to write compatibility type adapters for Haskell functions
07:33:54 <madhadron> Peaker, Thus "avoid success at all costs" (:
07:34:26 <Xenox> Can some-one tell me what the show instance for a data type like: data (Num a) => Size2D a = Size  { sizeW :: {-# UNPACK #-} !a  , sizeH :: {-# UNPACK #-} !a     } should be
07:34:47 <Peaker> madhadron:  Say you converted f :: Double -> Int  to    f :: Double -> (Int, Double)     maybe you could write a pragma or such:  adapt_f :: Double -> Int  ; adapt_f = fst . f -- and have the compiler try adapters if types don't check
07:34:55 <Xenox> I supposed it should be : instance Show (Num a) => (Size2D a) where
07:34:56 <Xenox>   show (Size w) = "{" ++ show w ++ show h ++ "}".But it isn;
07:36:40 <quicksilver> Xenox: don't use constraints in data times, it doesn't really work.
07:36:44 <quicksilver> data types.
07:36:58 <lilac> i suspect we'll find at some point in the future (when dependent typing comes of age) that Haskell having separate type and value namespaces was a mistake...
07:37:10 <ski>   instance (Show a,Num a) => Show (Size2D a) where
07:37:47 <quicksilver> the derived show instance would be "Size { sizeW = " ++ show (sizeW w) ++ ", sizeH = " ++ show (sizeH w) ++ " } "
07:37:52 <quicksilver> I believe.
07:40:12 <quicksilver> but you could just derive Show :)
07:41:12 <Xenox> When i use the derive show I get: {rectLeft = 0, rectTop = 0, rectWidth = 0, rectHeight = 0}. And I think that is to much ;)
07:41:20 <Xenox> I just want {0,0,0,0}
07:41:21 <Xenox> :)
07:41:53 <ski> maybe not use `show' ?
07:42:23 <EvilTerran> Xenox, show is meant to produce valid haskell, which that wouldn't be
07:42:30 <ski> `show' is intended for producing a Haskell-readable string
07:42:48 <gwern> EvilTerran: well, he could define read and show instances which would work for that couldn't he?
07:42:59 <ski> (.. i should have said Haskell-`read'able)
07:43:07 <gwern> as long as he assumes the rectLeft,rectZTop,rectWidth,rectHeight ordering in the read function
07:43:17 <paper_cc> Xenox: a good (conforming) 'show' could only return (Size 0 0 0 0)
07:43:45 * EvilTerran is under the impression that the jury's out on whether "show" instances should only ever produce valid haskell, or if that's just how the derived instances happen to work
07:44:06 <opqdonut> well read.show should be id
07:44:33 <yaxu> http://blip.tv/file/2198920
07:44:38 <EvilTerran> most non-derived Show instances in the libraries seem to work that way, too
07:45:01 <EvilTerran> > M.singleton 23 "foo"
07:45:02 <lambdabot>   fromList [(23,"foo")]
07:45:30 <ski> > listArray (0,3) "abcd"
07:45:31 <lambdabot>   array (0,3) [(0,'a'),(1,'b'),(2,'c'),(3,'d')]
07:45:37 <Xenox> I Use show. But the derived show of my data type constructs created the readable string (using show) ->  Size {sizeW = 0, sizeH=0} for Size 0 0
07:46:03 <Xenox> And I want to send the string over the network, so I don't want all the sizeW and sizeH appearing in my readable string
07:46:38 <ski> Xenox : the suggestion was to stop using `show', instead defining your own function (not called `show') for producing the string you want
07:46:50 <EvilTerran> Xenox, if you're worried about network usage, Data.Binary would probably be a better choice than Show
07:46:52 <Axman6> or Data.Binary
07:47:15 <ski> (/me just remembered `Data.Binary' :)
07:47:15 <gwern> I always wondered how 'fromList' could work in a read function; it's obviously not being compiled & run via the GHC API or something; so is the string "fromList" just hardwired in a little parser or something?
07:47:21 <Xenox> @Ski, sorry I think I read over that. Using a self defined function would also work :)
07:47:21 <lambdabot> Unknown command, try @list
07:47:25 <Berengal> Xenox: If you want derived Read to be able to read it, you could make it print something like "(Size 0 0 0 0)"
07:47:28 <gwern> Xenox: not twitter
07:47:46 <Xenox> @gwern not twitter?
07:47:46 <lambdabot> Unknown command, try @list
07:47:51 <EvilTerran> gwern, i think the "fromList" or whatever is hard-wired, yeah
07:48:02 <Axman6> Xenox: no need for the @
07:48:04 <lilac> EvilTerran: for parameterised types, some convention is needed on how to read the individual elements. saying "must parse as haskell" solves that pretty nicely afaics
07:48:04 <ski> gwern : i believe so
07:48:06 <Jedai> gwern: I do believe it's hard wired
07:48:09 <EvilTerran> Xenox, an @ at the start of a line is interpreted as a command by lambdabot
07:48:13 <paper_cc> Xenox: username: not @username
07:48:24 <Xenox> sorry :)
07:48:25 <paper_cc> @help
07:48:25 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
07:48:38 <Xenox> I sometimes forget that :)
07:49:30 * Berengal makes his computer do as he wants. Dance puppet, dance!
07:55:18 <cads> hey, if we have f and g, a, b
07:55:27 <cads> aw crud I hate this keyboard..
07:55:55 <adekoba> what should I do if I do not have enough memory to build a package? encoding-0.5.1 keeps hitting swap.
07:56:28 <cads> we have f, g, a, b such that  foldl f a = foldr g a... what can we say about the realation between f and g, a and b?
07:58:08 <cads> if f is commutative and associative and has a zero element, I think f = g, a = b = 0
07:59:20 <sampointon> hi guys, any idea why [d| data Foo = Foo; instance Show Foo where { show _ = "Foo" } |] fails with "`show' is not a (visible) method of class `Show'"?
08:01:17 <EvilTerran> cads, do you mean foldl f a = foldr g b?
08:03:12 <dino-> adekoba: I'm not sure, have never run into that. But there may be a switch for ghc
08:04:33 <quicksilver> adekoba: you could give ghc a hard memory limit but I suspect that would just make it crash with an out of memory error.
08:04:41 <quicksilver> I think if it needs that memory it needs it :(
08:05:07 <adekoba> I'll give it a try
08:05:38 <JaffaCake> you could try GHCRTS=-c
08:06:46 <ray> i keep running out of memory when linking
08:07:05 <JaffaCake> ah, well there's not much we can do about shoddy linkers
08:07:12 <ray> i ended up passing --no-keep-memory to ld
08:07:14 <ray> which is harder than it sounds
08:07:27 <quicksilver> spray them with shodkiller
08:08:00 <dino-> ray: Now you've got me interested in hard how, in case I run into it.
08:08:22 <adekoba> JaffaCake: I got an ExitFailure 15 using that
08:08:47 <ray> had to pass -optl --no-keep-memory to ghc, which required some kind of flag to cabal's configure
08:09:20 <EvilTerran> ray, heh, sounds like the flag equivalent of Leaning Toothpick Syndrome
08:09:31 <dino-> I see. Not just a switch passed down through ghc.
08:09:38 <sampointon> what about using --ghc-options on with cabal build?
08:09:45 <ray> yeah, that's the flag
08:09:57 <mmorrow> can anyone think of a function (preferably already written ;) that would be an interesting case for a pattern match compiler?
08:10:05 <JaffaCake> adekoba: ExitFailure 15 from what?
08:10:13 <adekoba> using GHCRTS=-c
08:10:40 <adekoba> I let ghc do its stuff for about two hours and it still hadn't even reached the linking stage yet.
08:10:46 <mmorrow> so, one that has at least two args and that has some overlap in the patterns in each "column"
08:10:47 <dino-> adekoba: I'll try to build that encoding too in a minute here.
08:10:52 <adekoba> I'll deal with ld when I come to it, lol.
08:11:17 <mmorrow> (and that has more that two "rows"))
08:11:31 <adekoba> quicksilver: but setting a hard memory limit seems to be working. Still taking a while, but not hitting swap.
08:11:33 <mmorrow> @src transpose
08:11:34 <lambdabot> transpose []             = []
08:11:34 <lambdabot> transpose ([]   : xss)   = transpose xss
08:11:34 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
08:11:47 <quicksilver> mmorrow: merge of two lists, written in such a way that it has a special case for 1-elt lists.
08:11:57 <mmorrow> quicksilver: hmm, nice
08:11:59 <quicksilver> mmorrow: which isn't the only way to write it, but it does at least meet your specs :)
08:12:14 * mmorrow writes it
08:12:15 <ski> mmorrow : Berry's majority ?
08:12:21 <quicksilver> adekoba: well it will GC more and more often as it runs out of memory.
08:12:35 <quicksilver> adekoba: eventually it will peg your CPU. But let's see if it squeezes through.
08:12:41 <adekoba> quicksilver: yar. We'll see how this goes.
08:13:13 <roconnor> @hoogle (Monoid a) => (a -> a -> b) -> [a] -> [a] -> [b]
08:13:13 <lambdabot> Prelude zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
08:13:13 <lambdabot> Data.List zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
08:13:13 <lambdabot> Data.List deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
08:13:27 <cads> WHat do you guys think, if f is not associative, is it even possible to write g | foldl1 f = foldr2 g? I feel like it is not.
08:13:49 <ski> mmorrow : maybe the Gustave function ?
08:14:12 <mmorrow> ski: ?
08:14:19 <roconnor> @type foldl1
08:14:21 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
08:14:31 <quicksilver> ski++ # wise about intriguingly named obscure functions.
08:14:35 <mmorrow> heh
08:15:01 <dino-> huh, building encoding really isn't crapping out my system that bad yet.
08:15:39 <ski> mmorrow : hm, i had a link to an old hpaste with them, but it appears that has vaporized
08:15:45 <dino-> Only pulled in another maybe 200-300M ram and no swap used at all still by anything. A whole core is way way busy on it.
08:16:48 <dino-> But boy is it ever busy with those Data.Encoding.JISX* sources. :o
08:17:03 <Peaker> about the Lisp-2 thing, the constant argument I get is people who want to call their lists list, heh
08:17:07 <cads> roconnor, I use foldl/r1 in this case because I think reasoning about the initial value isn't necessary in this case... trying to work a proof but my brain's farting
08:17:10 <ski> a quick search turns up
08:17:16 <adekoba> dino-: Yes. This is a known issue. It's heavy on the template Haskell.
08:17:17 <quicksilver> it's one file in particular which is the painful one, dino.
08:17:17 <ski> Berry's majority function : <http://wiki.portal.chalmers.se/agda/agda.php?n=ReferenceManual.PatternMatching>,<http://www.nabble.com/On-Berry's-Majority-Function-td4832574.html>
08:17:50 <mmorrow> ski: hah, perfect :)
08:18:00 <dino-> What a beast!
08:18:16 <roconnor> cads: I was just checking to see if the function for foldl1 was even an operator.  It is.
08:19:48 <dino-> It's still busy but holding steady on ram. top says 284M
08:20:12 <adekoba> how much system ram do you have?
08:20:20 <dino-> adekoba: 2G
08:20:37 <Peaker> ok, very clearly Lisp guys still like their Lisp-2, dynamic scoping and multi-value returns, heh
08:21:00 <adekoba> yeah, you're probably fine. I have 512MB
08:21:13 <roconnor> what is multi-value retunrs?
08:21:16 <dino-> adekoba: Another thing, if this is a disaster for small machines, we could maybe do some binary dist of this.
08:21:29 <dino-> If you're on a Debian-based, a .deb could be made.
08:21:35 <adekoba> archlinux
08:22:09 <sampointon> roconnor: think like returning tuples, except you can't treat them as a tuple. All you can do is unpack them in some way
08:22:11 <dino-> It got through to the next JIS source, ghc up to 410M
08:22:15 <dino-> yowza
08:22:34 <roconnor> sampointon: so they are like continuations?
08:22:47 <sampointon> roconnor: no, they're basically just cartesian products
08:23:20 <roconnor> how does it differ from returning (a . b) ?
08:24:01 <conal> roconnor: i think efficiency
08:24:02 <sampointon> roconnor: efficiency I believe, but my lisp-fu is not strong
08:24:05 <dino-> would some kind of lunatic hackery like packing up the dist/ dir with the .o files and sending off work? I guess if it's the same architecture, perhaps.
08:24:08 <roconnor> ok
08:24:31 <dino-> Or sending the post linker results
08:24:56 <quicksilver> surely in a decent lisp implementation (a . b) is pretty damn efficient?
08:25:10 <quicksilver> or is it return by reference instead of by value, somehow?
08:26:04 <sampointon> quicksilver: I think CltL being 25 years old has something to do with it. I don't know how advanced fusion and deforestation was back then
08:26:31 <conal> quicksilver: maybe the goal is to return multi-results in registers and avoid consing altogether.
08:26:50 <quicksilver> that sounds like a goal for an optimising compiler
08:26:58 <conal> quicksilver: indeed
08:27:00 <quicksilver> not a justification for a new language construct
08:27:22 * quicksilver shrugs
08:27:44 <conal> i wonder what we tolerate that's analogous
08:29:27 <dino-> Got to 484M then it finished, succeeded.
08:30:25 <ski> shortening `Either',`Left',`Right' to `E',`L',`R' :
08:30:34 <ski>   gustave :: (a,E a0 a1) -> (b,E b0 b1) -> (c,E c0 c1) -> (E a (E a0 a1),E b (E b0 b1),E c (E c0 c1))
08:30:40 <sampointon> hmm, wikipedia thinks that GHC invented analysing return types and optimising wrt register use
08:30:41 <ski>   gustave (a,_   ) (_,L b0) (_,R c1) = (L    a  ,R (L b0),R (R c1))
08:30:48 <ski>   gustave (_,R a1) (b,_   ) (_,L c0) = (R (R a1),L    b  ,R (L c0))
08:30:52 <ski>   gustave (_,L a0) (_,R b1) (c,_   ) = (R (L a0),R (R b1),L    c  )
08:30:58 <ski>   gustave (_,L a0) (_,L b0) (_,L c0) = (R (L a0),R (L b0),R (L c0))
08:31:00 <ski>   gustave (_,R a1) (_,R b1) (_,R c1) = (R (R a1),R (R b1),R (R c1))
08:31:07 <Zao> I hear that hpaste is awesome.
08:31:07 <ski> mmorrow : there
08:31:52 <ski> (Zao : in this case i wanted to refer to a hpaste, but it was gone .. so i figured it might be nice if i could search for it in the logs, next time ;)
08:32:52 <ski> (specifically <http://hpaste.org/9451> .. maybe that's still available somewhere .. i don't know where to look, though)
08:34:15 <ski> roconnor : it's like returning an unboxed tuple, more or less
08:36:36 <adekoba> After setting a hard memory limit, encoding failed to build. Ghc reported an error saying the heap was exhausted.
08:36:51 <dino-> adekoba: I'll leave the build artifacts from encoding around for a while. If you have failure and want anything.
08:37:20 <mmorrow> ski: haha, that's even bettar
08:37:52 * ski wonders how that's better
08:38:00 <mmorrow> err, right ...
08:38:16 <ski> what, what ?
08:38:23 <mmorrow> (and also my parser only does single-level deep patterns)
08:38:28 * ski looks confused in the hope that mmorrow will explain
08:38:30 <dino-> I'm not really a build wizard, is it possibly valuable for me to pack up this (50M) block of files into a .tar.gz, with the dist/ intact after linking? It's Intel 32-bit.
08:38:53 <dino-> Put somewhere you can dl.
08:39:04 <mmorrow> ski: not better than Berry's since... err, maybe it is "better" (in the sense that it's a more complex case)
08:39:25 <mmorrow> ski: but since it has nested patterns i can't use that example as-is..
08:39:37 <mmorrow> ski: but Berry's is exactly what i was looking for :)
08:39:39 <adekoba> dino-: Maybe. Upload it to mediafire/rapidshare and I'll try it out.
08:39:42 <ski> (mmorrow : you could easily curry `gustave' into six separate arguments .. the original had only one, but i split that into the three above)
08:40:02 <mmorrow> ski: ah, good point
08:40:05 * mmorrow does that
08:42:06 <ski> "The Gustave function is an example of a function which is stable but not Vuillemin Sequential."
08:42:16 <quicksilver> conal: newtype, I guess.
08:42:32 <quicksilver> conal: but, I wouldn't describe newtype as an interesting or important haskell feature.
08:42:50 <dino-> adekoba: http://ui3.info/d/misc/encoding-0.5.1_prebuilt.tar.gz
08:43:00 <dino-> 9.2M
08:43:07 <mmorrow> hehe, gustave is epic
08:43:21 <quicksilver> seems to be a good way of demonstrating failure of full abstraction
08:43:25 <quicksilver> having googled around it a bit
08:44:14 <roconnor> What is Lisp-2?
08:44:24 <osfameron> twice as good as Lisp-1 !
08:44:25 <quicksilver> roconnor: where functions and values are in different namespaces
08:44:31 <quicksilver> apparently.
08:44:46 <Berengal> Isn't shadowing good enough for them?
08:44:57 <roconnor> quicksilver: that sounds like a small step in the right direction.
08:45:00 <ski> "The maj function is total: its patterns are exhaustive and disjoint. However, these patterns do not arise as the fringe of a splitting tree. Hence it is not possible to give an implementation of maj with conventional eliminators or in Coquand's pattern matching language (henceforth, Alf) which satisfies those five equations definitionally on open terms."
08:45:12 <quicksilver> it means in (f f) those are different fs
08:45:24 <quicksilver> the first f is looked up as a function, the second as a value.
08:45:35 <quicksilver> I don't like it because I want, personally, to be able to pass a function as a value.
08:45:42 * EvilTerran concurs
08:45:45 <quicksilver> in fact, I would argue that's one of things that functional programming is about.
08:46:04 <roconnor> quicksilver: oh, so the two don't get different types.
08:46:09 <roconnor> heh
08:46:12 <Berengal> quicksilver: There's always #, but I agree...
08:46:14 <roconnor> what was I thinking.
08:46:15 <quicksilver> types? it's lisp we're talking about.
08:46:26 <quicksilver> persumably you do (f 'f)
08:46:33 <quicksilver> which passes the "name" of f as a parameter.
08:46:36 <Botje> #'f even
08:46:42 <Botje> or you can do (f (function f))
08:46:46 <quicksilver> but then you don't know if the function is going to choose to use it as a function or a value.
08:47:36 <sampointon> quicksilver: well, you can't pass things directly from the function namespace as parameters. #' does that and passes the function as a value
08:47:45 * quicksilver nods
08:47:56 <quicksilver> it is primarily cosmetic.
08:47:57 <ski> quicksilver : elaborate on "choose to use it as a function or a value" ?
08:48:23 <sampointon> if you pervasively use #' and squint, common lisp is an acceptable lisp-1
08:48:30 <quicksilver> ski: having been passed a symbol, you can then use the value of that symbol-as-a-value or the value of symbol-as-a-function
08:48:31 <cads> when we say that an operator + is right associative, does that simply mean that in writing conventions,  a + b + c + d is meant to uniquely represent (((a + b) + c) + d), rather than ((a + b) + (c + d)), (a + (b + (c + d))), or any other combination?
08:48:33 <quicksilver> can't you?
08:48:34 <sampointon> for some values of 'acceptable' :)
08:48:39 <quicksilver> I do get confused between lisps
08:48:49 <ski> quicksilver : no, not in CL
08:48:56 <quicksilver> ah, ok.
08:48:59 <dmwit> cads: Yes.
08:49:07 <ski> (maybe in Emacs Lisp, i don't know)
08:49:10 <dmwit> cads: Except that right-associative is the other way. =)
08:49:12 <cads> quicksilver: it's "lithpth"
08:49:18 <quicksilver> right :)
08:49:33 <cads> dmwit, doubledamn :)
08:49:34 <dmwit> cads: If (+) is right-associative, a + b + c + d === a + (b + (c + d))
08:49:42 <dmwit> =)
08:50:03 <ski> quicksilver : in  (foo #'foo)  a closure is passed, not a symbol .. passing a symbol would be  (foo 'foo)
08:50:20 <byorgey> And if (+) is unassociative it wants nothing to do with a, b, c, and d.
08:50:30 <dmwit> cads: In ghc, (+) is infixl, so keep that in mind for the next example.
08:50:48 <dmwit> > (a + (b + (c + d)), ((a + b) + c) + d)
08:50:49 <lambdabot>   (a + (b + (c + d)),a + b + c + d)
08:51:00 <sampointon> byorgey: a reclusive operator? :)
08:51:12 <cads> working on this problem from a lisp forum where essentially our charachter gives us an f and a, and would like us to tell him if we can create a g and b such that opposite folds with f, a and g, b will resepctively yield the same result
08:51:16 <byorgey> sampointon: oh good, someone got my joke =)
08:51:35 <cads> and it occurs to me that lisp is very terrible for equational reasoning in this case
08:52:18 <cedricshock> Is there a way to safely load object code, say a function from integers to integer) into a running haskell program. I.e. something like name::String -> objectcode::String ->IO (Int -> Int)
08:52:40 <quicksilver> ski: but once I do (foo 'foo) to pass in a symbol, can I not lookup that symbol as a value/function ?
08:52:43 <sampointon> cedricshock: hs-plugins?
08:52:53 <dmwit> cedricshock: You'll want to check out the GHC API, and especially hint.
08:53:02 <EvilTerran> cedricshock, ghc-api would be the current way of doing that sort of thing
08:53:10 <dmwit> cedricshock: Don't bother with that hs-plugins mess any more, it's deprecated. ;-)
08:53:11 <sampointon> quicksilver: if it's in scope, sure
08:53:12 <ski> cads : no, `++' being right-associative implies that `a ++ b ++ c ++ d' is the same as `(a ++ (b ++ (c ++ d)))'
08:53:17 <Berengal> cads: I don't think it's possible in general. Try f = (-), a = 0
08:53:32 <quicksilver> sampointon: good, well that's what I thought I meant in the first place :)
08:53:36 <byorgey> cads: you can do it if 'f' is symmetric (i.e.  f x y == f y x)
08:53:46 <quicksilver> byorgey: commutative :)
08:53:52 <byorgey> err, right.
08:53:55 * byorgey smacks forehead.
08:53:55 <ski> quicksilver : you can look up that symbols *global* value as a ordinary/function variable, yes
08:54:02 <sampointon> symmetric works too
08:54:05 <dmwit> We were talking about this the other night.  It's sufficient for f and a to form a monoid.
08:54:13 <dmwit> Then g and b are (flip f) and a.
08:54:18 <ski> quicksilver : however, doing that is discouraged in most cases
08:54:24 <quicksilver> symmetric is normally of a relation, meaning x R y ==> y R x
08:54:37 <quicksilver> extending that to functions, a 'symmetric' function would be an involution.
08:54:41 <quicksilver> (and it would be unary)
08:54:53 <quicksilver> ski: right, I can see why.
08:55:14 <sampointon> oh, I was thinknig graphically. A commutative function has a symmetry along y = x, hence calling it symmetric
08:55:24 <quicksilver> ski: I find using lisp at all is discouraged in most cases. Probably that says something about the company I keep.
08:55:41 <quicksilver> sampointon: sure. It has an obvious intuitive justification, it's just not what the word normally means.
08:56:17 * ski finds lisps (well, scheme mostly) interesting mostly for the macro systems
08:56:25 <quicksilver> although curiously the equivalent property of a (bi)functor is normally called symmetry, not commutativity.
08:56:37 <quicksilver> ski: interesting is not the same as a good tool
08:56:46 <Peaker> knowing Haskell, I think I can only find use for C and Haskell, (perhaps Python's interactive shell, still used to that)
08:56:50 <quicksilver> ski: I find it all very intresting, or I wouldn't be partaking in this discussion.
08:57:28 <quicksilver> ski: the thing I don't like about (say) CL is that when you're trying to understand code you don't know very well
08:57:35 <quicksilver> ski: you can't tell which bits are macro and which bits aren't.
08:57:54 <quicksilver> ski: and the macro bits behave substantially differently, in that they can use their arguments without evaluating them, etc.
08:58:24 <ski> i can understand that
08:59:15 <Berengal> I like lisp. It's a bit outdated, but still better than most other languages I've tried...
08:59:40 <ski> the only response i can give is that typically, not that many different macros are used in a piece of code, so one can usually keep in head which are macros (after one has discovered/read which are)
09:00:05 <cedricshock> dmwit, etc: thanks
09:01:43 <dino-> How about that Arc Lisp?
09:02:17 <p_l> dino-: isn't it deader than dead?
09:02:51 <mmorrow> ski, quicksilver: the case tries for berry and gustave http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5570#a5570
09:03:02 <dino-> p_l: Beats me. I know that it only just kind of was available to the public recently. According to Mr Graham.
09:03:35 <p_l> dino-: and is a joke among CL community, as much as one can talk about one :P (at least among the part I met)
09:03:52 <mmorrow> ski, quicksilver: crap, the decls got out of order when i Map.toList from my Trie..
09:04:07 <quicksilver> ;)
09:04:21 <ski> mmorrow : you appear to miss a lot of parens in the `gustave' definition at the top .. is that intensional ?
09:04:41 <mmorrow> ski: oh, that's just prettyprinter suckiness
09:04:55 <ski> i see
09:05:05 * mmorrow makes a note to fix that
09:05:11 <quicksilver> I wonder, is it better to have a sucky prettyprinter or a pretty suckyprinter...
09:05:36 <mmorrow> questions for the ages
09:05:40 <ski> maybe a sucky prettyparser would be nice ?
09:19:20 <pozic> Is there a generic zip library? It should be varargs and work on any kind of container. I know of zips which have one of the two features, but not both. Otherwise, consider it to a challenge to abuse the type-system.
09:20:11 <psnively> I'm sure Oleg has already written it.
09:20:36 <roconnor> pozic: what is any kind of container?
09:20:38 <jmcarthur_work> maybe some combination of applicative and traversable or something
09:20:41 <jmcarthur_work> ?
09:21:01 <jmcarthur_work> err... foldable
09:21:17 <roconnor> like a noetherian container?
09:21:45 <Beelsebob> pozic: isn't it just liftA2, with appropriate data types
09:21:47 <jmcarthur_work> ZipList . Data.Foldable.toList -- done
09:22:03 <mmorrow> oh wow, gustave just made me realize how much it has to suck when you have patterns that have to backtrack...
09:22:06 <jmcarthur_work> well, i guess you need a fromList, also
09:22:10 <cedricshock> Ok. This is awesome: dynCompileExpr :: GhcMonad m => String -> m Dynamic
09:22:21 * mmorrow redoes his whole algo :(
09:22:22 <roconnor> jmcarthur_work: in that case you end up with a list and not the original container structure.
09:22:36 <jmcarthur_work> roconnor, right, hence the need for a fromList as well
09:22:59 <roconnor> that isn't necessarily structure preserving
09:23:17 <pozic> roconnor: Sequence/Array/List/anything user defined, which I guess would be Traversable/Foldable.
09:23:21 <jmcarthur_work> does a zip necessarily have to be structure preserving?
09:23:41 <byorgey> pozic: Stephanie Weirich and ccasin have a paper they just submitted doing such a thing in Agda.  It's surprisingly tricky.
09:23:44 <jmcarthur_work> pozic, ^^ would be a good question for you to answer
09:23:52 <byorgey> pozic: there's some hope that their approach could be translated to Haskell.
09:24:37 <byorgey> pozic: but it doesn't exist ATM.
09:24:39 <pozic> jmcarthur_work: I don't mind about that.
09:24:54 <roconnor> pozic: rose trees?
09:25:54 <jmcarthur_work> if it doesn't have to be structure preserving then applicative+foldable is probably perfect
09:26:04 <jmcarthur_work> if it does... whole new ball game
09:26:19 <roconnor> jmcarthur_work: agreed
09:26:38 <gwern> @seen dcoutts__
09:26:38 <lambdabot> dcoutts__ is in #darcs, #gentoo-haskell, #ghc, #haskell, #haskell-in-depth, #haskell-overflow and #haskell-soc. I don't know when dcoutts__ last spoke.
09:26:40 <gwern> @seen dcoutts_
09:26:40 <lambdabot> dcoutts_ is in #haskell-in-depth, #gentoo-haskell, #ghc and #haskell-overflow. I last heard dcoutts_ speak 30m 50s ago.
09:26:44 <gwern> @seen dcoutts
09:26:44 <lambdabot> I saw dcoutts leaving #haskell-soc, #haskell-in-depth, #gentoo-haskell, #darcs, #ghc, #haskell-overflow and #haskell 3h 7m 42s ago, and .
09:26:51 <gwern> he uses entirely too many nicks
09:27:01 <Deewiant> @seen dcoutts___
09:27:01 <lambdabot> I haven't seen dcoutts___.
09:27:11 * gwern doesn't know which one to leave a message for
09:27:14 <roconnor> http://en.wikipedia.org/wiki/Container_(Type_theory)
09:27:27 <quicksilver> pozic, jmcarthur_work : I wrote a zip which works on Foldatble/Travesable
09:27:36 <gwern> well, single-underscore seems to've been most recently active
09:27:39 <Deewiant> gwern: The one with one _... yeah
09:28:25 <gwern> @ask dcoutts_ while cabalizing my wikipedia bot, I noticed it's possible to declare build-depends which are unused with neither cabal-install nor cabal check complaining about the unnecessary dependencies. is this an open bug or anything?
09:28:25 <lambdabot> Consider it noted.
09:28:54 <gwern> (I copied the rss2irc ,cabal, and it needs mtl and strict-concurrency while my bot doesn't)
09:29:18 <roconnor> @hoogle fromList
09:29:18 <lambdabot> Data.HashTable fromList :: Eq key => (key -> Int32) -> [(key, val)] -> IO (HashTable key val)
09:29:19 <lambdabot> Data.IntMap fromList :: [(Key, a)] -> IntMap a
09:29:19 <lambdabot> Data.IntSet fromList :: [Int] -> IntSet
09:29:23 <roconnor> @more
09:29:27 <roconnor> @hoogle+
09:29:27 <lambdabot> Data.Map fromList :: Ord k => [(k, a)] -> Map k a
09:29:27 <lambdabot> Data.Sequence fromList :: [a] -> Seq a
09:29:27 <lambdabot> Data.Set fromList :: Ord a => [a] -> Set a
09:29:33 <roconnor> @hoogle+
09:29:34 <lambdabot> Distribution.Simple.PackageIndex fromList :: Package pkg => [pkg] -> PackageIndex pkg
09:29:34 <lambdabot> Data.IntMap fromListWith :: (a -> a -> a) -> [(Key, a)] -> IntMap a
09:29:34 <lambdabot> Data.Map fromListWith :: Ord k => (a -> a -> a) -> [(k, a)] -> Map k a
09:29:36 <roconnor> bah
09:29:54 <roconnor> quicksilver: how does that work?
09:30:50 <gwern> 'The dependency 'build-depends: base' does not specify an upper bound on the version number. Each major release of the 'base' package changes the API in various ways and most packages will need some changes to compile with it. The recommended practise is to specify an upper bound on the version of the 'base' package. This ensures your package will continue to build when a new major version of the 'base' package is released. If you are ...
09:30:56 <gwern> ... not sure what upper bound to use then use the next  major version. For example if you have tested your package with 'base' version 2 and 3 then use 'build-depends: base >= 2 && < 4'.'
09:31:00 <gwern> argh. bit already!
09:31:41 <roconnor> bit?
09:31:41 <quicksilver> roconnor: it uses the 'shape' from the traversable one
09:31:59 <gwern> yes, bit
09:32:02 <gwern> @wn bit
09:32:05 <quicksilver> roconnor: and it effectively uses toList from Foldable to souce the items on the othe
09:32:05 <lambdabot> *** "bit" wn "WordNet (r) 2.0"
09:32:05 <lambdabot> bit
09:32:05 <lambdabot>      n 1: a small quantity; "a spot of tea"; "a bit of paper" [syn: {spot}]
09:32:05 <lambdabot>      2: a small fragment of something broken off from the whole; "a
09:32:05 <lambdabot>         bit of rock caught him in the eye" [syn: {chip}, {flake},
09:32:07 <lambdabot> [59 @more lines]
09:32:11 <gwern> @more
09:32:11 <lambdabot>         {fleck}, {scrap}]
09:32:11 <lambdabot>      3: an indefinitely short time; "wait just a moment"; "it only
09:32:13 <lambdabot>         takes a minute"; "in just a bit" [syn: {moment}, {minute},
09:32:15 <lambdabot>          {second}]
09:32:17 <lambdabot>      4: an instance of some kind; "it was a nice piece of work"; "he
09:32:19 <lambdabot> [54 @more lines]
09:32:23 <cedricshock> There's a huge gap between hs-plugins and ghc-api in terms of instructiveness of documentation.
09:32:25 <gwern> -_-
09:32:30 <roconnor> gwern: keep going
09:32:43 <gwern> I didn't realize 'bit' as in 'bitten' was such a tertiary definition
09:33:04 <roconnor> quicksilver: but zip should produce the shape of the "intersection" of the two shapes.
09:33:12 <quicksilver> yes, that would be better
09:33:15 <quicksilver> but traversable can't do that.
09:33:20 <roconnor> no
09:33:29 <quicksilver> so my solution is jsut one part of the space
09:33:37 <quicksilver> it's useful for, for example, labelling a tree with labels from a list.
09:33:37 <roconnor> quicksilver: what if there isn't enough stuff in the non-traversable parameter?
09:33:42 <quicksilver> it dies.
09:33:47 <roconnor> error?
09:34:13 <roconnor> error "quicksilvers zip died here. RIP"
09:34:15 <roconnor> like that?
09:34:21 <quicksilver> yup.
09:34:23 <roconnor> ok
09:34:27 <jmcarthur_work> ew :(
09:34:36 * roconnor wonders what pozic wanted
09:35:03 <quicksilver> @go haskellwiki foldable and traversable
09:35:04 <roconnor> and why can't i find the container's project blog or wiki or whatever it was?
09:35:05 <lambdabot> http://www.haskell.org/haskellwiki/Foldable_and_Traversable
09:35:05 <lambdabot> Title: Foldable and Traversable - HaskellWiki
09:35:08 <quicksilver> roconnor: there.
09:35:32 <quicksilver> sorry, I wasn't repsonding to your last comment
09:35:39 <quicksilver> I meant 'there is quicksilver's zip'
09:39:06 <roconnor> ah
09:39:08 <roconnor> http://sneezy.cs.nott.ac.uk/containers/blog/
09:39:12 <roconnor> @where containers
09:39:12 <lambdabot> I know nothing about containers.
09:39:27 <roconnor> @where+ containers http://sneezy.cs.nott.ac.uk/containers/
09:39:27 <lambdabot> Nice!
09:40:09 <roconnor> ah it was Naperian containers not Noetherian containers
09:40:21 <roconnor> I fail at Haskell
09:42:40 <roconnor> someone needs to explain what conatiners, shapes, and positions are sometime.
09:45:33 <quicksilver> a container is what you put nuclear waste in.
09:45:39 <quicksilver> every haskell programmer knows that.
09:45:55 <roconnor> I thought that was a monad
09:47:02 <jmcarthur_work> some like to claim that all monads are containers. i am not one of those people
09:49:34 <jmcarthur_work> @djinn a -> (a -> b) -> b
09:49:34 <lambdabot> f a b = b a
09:49:51 <jmcarthur_work> @. @pl @djinn a -> (a -> b) -> b
09:49:51 <lambdabot> Plugin `compose' failed with: Unknown command: "@pl"
09:50:23 <gwern> when ANN'ing programs, do we cc haskell, or is it just haskell-cafe?
09:50:26 <ski> @. pl djinn a -> (a -> b) -> b
09:50:26 <lambdabot> f = flip id
09:50:34 <jmcarthur_work> ah, no @s
09:50:48 <ski> @@ @pl @djinn a -> (a -> b) -> b
09:50:48 <lambdabot>  f = flip id
09:50:58 <jmcarthur_work> ah! no wonder i was confused
09:51:37 <jmcarthur_work> gwern, i think most people cc haskell
09:51:46 <gwern> 'k
09:51:46 <jmcarthur_work> and -cafe, that is
09:53:46 * gwern sends the message off. fly away little birdy!
09:59:10 <gwern> oh drat! I don't even get the satisfaction of deleting 'write & release wp-archivebot' from my TODO
09:59:16 <gwern> because I forgot to add it in the first place
10:02:28 <randomguy> on Lenny stable
10:02:29 <monochrom> haha
10:02:57 <randomguy> on Lenny stable
10:03:25 <randomguy> what are you using to install it?
10:03:55 <randomguy> If perl segfaults with an "Unaligned access" error, where should I look first?
10:04:13 <paper_cc> randomguy: look in #perl
10:04:25 <randomguy> Desen: well what do they lack and what are you looking for?
10:04:45 --- mode: ChanServ set +o monochrom
10:04:51 <byorgey> randomguy: I think you're typing in the wrong channel.
10:05:25 --- mode: monochrom set +b *!*@199.80-202-137.nextgentel.com
10:05:32 --- mode: monochrom set -o monochrom
10:05:48 <monochrom> (When I'm back from lunch I'll remember to unban)
10:07:28 <byorgey> monochrom: why, was that guy in here before?
10:07:30 <lament> that's what they all say
10:07:37 * ski resists putting that into `@remember monochrom'
10:07:37 <byorgey> or was it a bot just echoing stuff from another channel?
10:08:04 <mauke> heh
10:08:18 <mauke> looks like a bot that prints to all channels it's in
10:08:25 <paper_cc> @seen randomguy
10:08:25 <lambdabot> I saw randomguy leaving #haskell 3m 35s ago, and .
10:08:32 <ski> (`@tell' would be more appropriate, i suppose)
10:08:42 <byorgey> I see.
10:09:05 * byorgey is too willing to give the benefit of the doubt, once again
10:09:20 <monochrom> Not sure "why" refers to which. why ban? because it's clearly delusional. why unban? because the banlist is finite and sometimes I judge wrong too.
10:09:59 <byorgey> I meant why ban.  I was asking under the assumption that it was just some confused guy typing in the wrong channel and not noticing it somehow, which doesn't seem like grounds for a ban
10:10:01 <SamB> also sometimes people learn!
10:10:09 <byorgey> but given that it was a bot, banning is fine =)
10:10:29 <SamB> oh, it's a bot?
10:10:41 <byorgey> so says mauke
10:10:43 <mauke> I don't know if it was a bot
10:10:52 <mauke> but it said the same lines in #perl (and was banned)
10:33:12 <rick_2047> http://pastebin.com/d7a3ba4c3 <-- i made this small program and haskell give me error
10:33:16 <rick_2047> the error is
10:33:29 <rick_2047> hello.hs:5:10:    The last statement in a 'do' construct must be an expression
10:33:33 <rick_2047> can anybody explain
10:33:41 <mauke> are you using tabs?
10:34:10 <rick_2047> mauke, how do u mean??
10:34:24 <mauke> :-(
10:34:39 <rick_2047> mauke, its vim automatic indentation
10:34:51 <mauke> what does ':set et?' say?
10:34:52 <rick_2047> mauke, is haskell white space sensitive?
10:35:14 <rick_2047> mauke, in ghci?
10:35:14 <mauke> parts of its syntax are, yes
10:35:17 <mauke> rick_2047: no, in vim
10:35:30 <rick_2047> mauke, it says nothing
10:35:37 <mauke> impossible
10:35:47 <rick_2047> but it is happening
10:35:53 <mauke> I doubt that
10:36:02 <rick_2047> no nothing
10:36:05 <rick_2047> what is it for?
10:36:16 <mauke> it tells me whether 'et' is set
10:36:30 <rick_2047> but it says nothing to me
10:36:31 <mauke> or rather, it's supposed to say either 'expandtab' or 'noexpandtab'
10:36:32 * inimino also doubts
10:36:46 <travisbrady> rick_2047: just try dedenting your code and indenting again by hand by using spaces
10:36:57 <rick_2047> travisbrady, ok
10:37:01 <mauke> my crystal ball says: PEBKAC
10:37:25 <inimino> that's not how you use vim
10:37:55 <rick_2047> travisbrady, i tried what u said but nothing
10:38:21 <rick_2047> travisbrady, also tried removing all indentation
10:38:57 <travisbrady> rick_2047: what error are you getting?
10:39:07 <rick_2047> hello.hs:5:10:
10:39:07 <rick_2047>     The last statement in a 'do' construct must be an expression
10:39:55 <travisbrady> your code works for me
10:40:04 <rick_2047> and plz anyone explain what this error is tring to say
10:40:07 <rick_2047> trying*
10:40:30 <mauke> it thinks the part after 'do' is a single statement
10:40:33 <kpreid> rick_2047: It has parsed your code such that the last item in a do block is not "foo" but "x <- foo"
10:40:34 <travisbrady> rick_2047: haskell determines structure by layout (indentation) though you can also use {}
10:40:49 <mauke> which is invalid, because you can't have a "<-" statement with nothing after it
10:40:50 <kpreid> rick_2047: and <- may not be used as the last statement in a "do"
10:40:51 <travisbrady> rick_2047: and your indentation is busted somehow
10:40:52 <Vulpyne> Everything in Haskell has to evaluate to a value. If the last thing in a do block is for example "blah <- something" that's just binding, and has no value.
10:41:37 <rick_2047> travisbrady, and it should work coz its an example from a book
10:41:48 <rick_2047> there is some problem in indentation?
10:41:57 <mauke> yes
10:42:02 <mauke> everything else looks ok
10:42:05 <travisbrady> rick_2047: the code is fine, the indentation is the problem
10:42:09 <kpreid> rick_2047: maybe you have nbsps instead of regular spaces or some such thing?
10:42:16 <kpreid> if you copied from a web page that could happen
10:42:19 <kyagrd> Can someone explain what are the differences between "forall a b. (C a, C b) => T a -> T b -> T (a,b)" and just "(C a, C b) => T a -> T b -> T (a,b)"?  I thought they were the same, but I found out that it was not the case ...
10:42:38 <kpreid> rick_2047: the important thing is that you use plain spaces and that 'args' and 'putStrLn' start in the same column
10:42:44 <mauke> kyagrd: none, except for scoped type variables maybe
10:43:00 <kpreid> rick_2047: if you have trouble with that try putting a line break immediately after the 'do'
10:43:02 <rick_2047> kpreid, but i am typing it by hand
10:43:28 <travisbrady> rick_2047: delete all the spaces in the last line before the putStrLn and then enter insert mode and hit space until the putStrLn lines up with the 'a' in args in the line above
10:43:32 <kpreid> rick_2047: like this: http://pastebin.com/m75458125
10:43:35 <kyagrd> mauke: Yeah the code I saw had scoped type variable and was using forall
10:44:03 <Peaker> kyagrd: scoped type variables use "forall" as a sort of explicit type variable declaration, and that's what scopes it
10:44:28 <rick_2047> kpreid, your thing worked
10:44:58 <rick_2047> i will have to look more into the problem afterwards though
10:45:08 <rick_2047> coz its a vim problem
10:45:34 <mauke> well, it's because expandtab is off
10:45:36 <kyagrd> Peaker: So, if I'm going to use scoped type variable, I must always use forall ... am I understanding it right?
10:45:46 <rick_2047> mauke, how do you turn it on
10:45:50 <rick_2047> set et?
10:45:56 <mauke> rick_2047: no, :set et
10:46:01 <mauke> rick_2047: :set et? is how you query it
10:46:03 <Peaker> kyagrd: I think so
10:46:17 <kyagrd> Thanks,
10:46:22 <rick_2047> mauke, it set to noexpandtab
10:46:59 * rick_2047 sets it to expandtab
10:47:13 * rick_2047 again blesses the community for help
10:47:18 * rick_2047 and back to work again
10:47:29 <skorpan> lol
10:47:32 <skorpan> oops, wrong channel
10:47:52 <sm> morning all
10:50:20 <J11> Is there a difference between (+) 4 $ (*) 7 3 and (+) 4 $ 7 * 3  ?
10:50:28 <skorpan> no
10:50:48 <kyagrd> I stick -- vim:sw=2:ts=2:expandtab:autoindent  on top of all my haskell scripts
10:51:36 --- mode: ChanServ set +o monochrom
10:51:41 --- mode: monochrom set -b *!*@199.80-202-137.nextgentel.com
10:51:45 --- mode: monochrom set -o monochrom
10:52:20 <J11> my parser thinks otherwise
10:52:38 <J11> HsInfixApp (HsApp (HsVar +) (HsLit (HsInt 4))) $ (HsApp (HsApp (HsVar *) (HsLit (HsInt 7))) (HsLit (HsInt 3)))
10:52:48 <J11> HsInfixApp (HsInfixApp (HsApp (HsVar +) (HsLit (HsInt 4))) $ (HsLit (HsInt 7))) * (HsLit (HsInt 3))
10:54:25 <inimino> well of course they must parse differently
10:55:11 <byorgey> J11: after the parse is done, you should go through and translate applications of HSVar *  into actual multiplication nodes, perhaps
10:55:34 <inimino> and unify HsInfixApp and HsApp
10:56:10 <Cope> Hello - is haskell well suited to text processing? I normally use ruby or python, but am looking for a functional language to play with prior to erlang factory, and have some text processing tasks to do.
10:57:08 <jmcarthur_work> Cope, haskell has *excellent* parsing libraries, but if you are used to regexes it may feel odd
10:57:18 <byorgey> Cope: well, it kind of depends what sort of text processing you are trying to do
10:57:39 <byorgey> Haskell is great for text processing, but it is not well suited to text processing in the *same style* as ruby or python
10:57:49 <byorgey> so it might feel awkward for a while
10:58:05 <jmcarthur_work> for example, haskell comes with no split function
10:58:23 <byorgey> jmcarthur_work: cabal install split =)
10:58:27 <J11> the second example looks like ((+) 4 $ 7) * 3 which results in 33 instead of 25 by (+) 4 $ 7 * 3
10:58:28 <dons> Any Mac users want to test the platform installer beta? http://projects.haskell.org/pipermail/haskell-platform/2009-June/000501.html
10:58:32 <jmcarthur_work> byorgey, i said "comes with"! :P
10:58:38 <Cope> I'm used to unix text processing, sed, cut, awk, etc, and python/ruby string libraries, and regexes
10:58:51 <byorgey> jmcarthur_work: well, who's going to do text processing without installing some libraries? =)
10:58:55 <jmcarthur_work> Cope, yeah, haskell's text processing libraries are very different from those
10:59:11 <Cope> i have a copy of 'real world haskell'
10:59:17 <Cope> is this is good place to start?
10:59:23 <jmcarthur_work> byorgey, right. i was just trying to convey that haskell does things differently than ruby/python
10:59:28 <jmcarthur_work> Cope, there is a chapter on parsec, i think
10:59:30 <byorgey> well, actually, Haskell does well with stream processing, a la sed, cat, awk etc.
10:59:31 <jmcarthur_work> which would be relevant
10:59:38 <travisbrady> Cope: i do a fair amount of that with Haskell, take a look at Data.ByteString and the pcre bindings
11:00:09 <monochrom> "real world haskell" is a good start!
11:00:11 <travisbrady> Cope: Parsec is awesome, but may be overkill and doesn't yet work with ByteStrings to my knowledge
11:00:23 <dons> parsec 3 does, also attoparsec
11:00:27 <dons> the latter is well optimized
11:00:46 <jmcarthur_work> and there are other parsing libraries besides parsec that i hear are good too, although i haven't tried them
11:00:51 <Cope> ok
11:01:05 <jmcarthur_work> pcre is worth looking at for something familiar i think
11:01:09 <travisbrady> Cope: i'd take a look at some of the Haskell widefinder implementations, that's a common task.  here's mine: http://github.com/travisbrady/funzone/blob/a16c6e3f21ef339d095f6f68f116f2de213a06c9/Widefinder.hs
11:01:32 <Cope> well I have close to zero idea about haskell - I know python list comprehensions are an idea from haskell, and I know about map, reduce, and lambda
11:01:36 <Cope> that's about it
11:01:39 <Cope> in python, that is
11:01:54 <Cope> I suppose ruby has some functional stuff with inject, collect, etc
11:01:58 <jmcarthur_work> Cope, dive in! there's a *ton* you can learn :)
11:02:13 <J11> Well it seems that Language.Haskell.Parser returns the same for (+) 4 $ 7 * 3 and ((+) 4 $ 7) * 3
11:02:22 <JusticeFries> dons
11:02:29 <JusticeFries> i'm not near my mac, but i'll give it a shot in a bit.
11:02:34 <dons> thanks
11:02:34 <travisbrady> Cope: Haskell is really much easier than it's made out to be, you can get a lot done with the list processing stuff
11:02:44 <dons> and faster...
11:02:58 <J11> I thought it was capable of handling infix declarations
11:03:11 <dons> http://shootout.alioth.debian.org/u64q/benchmark.php?test=all&lang=python&lang2=ghc&box=1  sooo much faster
11:03:15 <jmcarthur_work> Cope, the "functional" features of ruby/python are not good indications of what functional programming is like simply because they are not universal/general
11:03:51 <Cope> jmcarthur_work: i'd heard that
11:03:51 <dons> oh, we're not quite 1000x faster than ruby on mandelbrot, doh.http://shootout.alioth.debian.org/u64q/benchmark.php?test=all&lang=ghc&lang2=ruby&box=1
11:03:54 <dons> should work on that for the win.
11:03:58 <CosmicRay> bos, dons: I seem to remember a tweet from one of you about a new unicode library recently... can you tell me what it's called?
11:04:04 <CosmicRay> dons: heh
11:04:05 <dons> "text"
11:04:09 <Cope> so where do I start? I don't have a mathematical background, so lambda calculus is a bit scary
11:04:16 <CosmicRay> dons: we're not 1000x faster than ruby?  we most be slipping ;-)
11:04:24 <dons> right!
11:04:28 <CosmicRay> dons: what advantages does it have over utf8-string?
11:04:28 <jmcarthur_work> Cope, real world haskell is good
11:04:34 <JusticeFries> real world haskell
11:04:43 <Cope> great, well I have that book :)
11:04:52 <dons> CosmicRay: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/text
11:04:57 <JusticeFries> i've been actually grappling with whether haskell or erlang suits my research problems before i dive too far. :3
11:04:59 <CosmicRay> dons: already there
11:05:08 <jmcarthur_work> Cope, my impression is that rwh would suit a ruby/python programmer very well, too
11:06:10 <Cope> super dumb question: how does haskell differ from erlang?  I'm interested in learning 'a' functional language, but which is suited to text processing, prior to going to the erlang conference in a few weeks, so I am not clueless
11:06:30 <Cope> I'm reading the erlang book too, just so I have some diea of the langauge and terminology
11:06:48 <jmcarthur_work> Cope, erlang and haskell are almost entirely different, beside favoring recursion and immutability
11:06:52 <jmcarthur_work> *besides
11:06:58 <travisbrady> Cope: i come from Python too and the thing that's worked best for me is to pick a problem i'm familiar with and solve that.
11:07:04 <CosmicRay> Cope: I haven't used erlang myself, so take this with a large grain of salt.  but I believe it's a question of focus.  Erlang is focused around network communications, especially binary protocols and IO clustering
11:07:05 <jmcarthur_work> and they both have pattern matching, too
11:07:22 <CosmicRay> Cope: Haskell is more a general-purpose language, though you can solve a variety of problems with either, of course.
11:07:22 <thoughtpolice> really erlang is focused around fault tolerance
11:07:30 <thoughtpolice> it is only natural that things like concurrency come from that
11:07:37 <thoughtpolice> as well as immutability, since the problem is then easier
11:07:45 <Cope> I'm really tempted to have a go at solving some of the ruby quiz problems in haskell
11:08:02 <travisbrady> lots of people start with project euler stuff
11:08:13 <Cope> are you familair with ruby quiz? it's a super concept - a little challenge to solve
11:08:19 <CosmicRay> Cope: url?
11:08:20 <thoughtpolice> CosmicRay: but it does apparently work excellent for web stuff (yaws seems really cool)
11:08:38 <thoughtpolice> @go ruby quiz
11:08:39 <edwardk> grr. http://lwn.net/Articles/336039/
11:08:39 <lambdabot> http://rubyquiz.com/
11:08:39 <lambdabot> Title: Ruby Quiz
11:08:45 <Cope> http://rubyquiz.com/quiz1.html
11:08:52 <JusticeFries> yaws is pretty awesome.
11:08:52 <CosmicRay> thoughtpolice: I have used it low-level with FastCGI, and that is great.  I have not messed with toolkits in any language for a long while.,
11:09:11 <jmcarthur_work> erlang is a lot "looser" than haskell because it must be resilient with changing requirements on live systems
11:09:21 <CosmicRay> thoughtpolice: "works well for web stuff" seems to be a widely divergent concept.  A lot of folks think that Java application servers that require 2GB of ram just to initialize are great.  I don't. ;-)
11:09:32 <CosmicRay> jmcarthur_work: which, I'm not sure, is a good thing.
11:09:40 <p_l> CosmicRay: Worse, there are people who run PHP :P
11:09:42 <jmcarthur_work> CosmicRay, i think for erlang it's great
11:09:57 <CosmicRay> jmcarthur_work: I run ejabberd a couple of places.  it seems to lead to unnecessary complexity
11:10:06 <jmcarthur_work> CosmicRay, for example, you can make a process accept new types of data without even having to define a data type
11:10:15 <thoughtpolice> CosmicRay: well, in the famous yaws v. apache benchmark, apache + mtm (multithreading module I think or something?) was dying out at around 4k concurrent connections; yaws kept going up into 80,000 concurrent clients
11:10:19 <edwardk> cope: erlang has very few kinds of things you can store, you just have lists, tuples, an atoms, in haskell you have constructors which have multiple slots, in erlang you'd use a tuple and make the first entry an atom
11:10:23 <thoughtpolice> CosmicRay: I've also spent a day or so with erlyweb
11:10:27 <thoughtpolice> and it's pretty neat
11:10:43 <p_l> CosmicRay: Sometimes you have to choose - fast live update of code or slow recompiling to make sure everything is right. Both have their place
11:10:45 <jmcarthur_work> i love erlang, but for entirely different reasons than i love haskell
11:10:49 <Cope> ahh... lists tuples and atoms... I think this rings a bell from 'the little schemer'
11:10:49 <jmcarthur_work> apples and oranges
11:10:57 <p_l> jmcarthur_work: right
11:10:59 <CosmicRay> Cope: The Haskell type system is amazingly helpful and flexible.  It lends itself well to working with larger programs where correctness is important.
11:11:01 <thoughtpolice> jmcarthur_work: agreed, erlang is a lot of fun.
11:11:08 <CosmicRay> Cope: as far as I'm concerned, that works well for web apps
11:11:11 <dons> p_l: dynamic code update is done in haskell too, fwiw.
11:11:19 <dons> code update isn't erlang's killer app.
11:11:37 <p_l> dons: I didn't say that it isn't done - I was talking about amount of complexity it might require :)
11:11:43 <edwardk> cope: on top of that haskell is lazy, so it doesn't bother fleshing out a structure in memory until the result is needed. erlang builds them strictly, this results in some differences. i.e. in haskell you work with infinite lists without problem and in erlang some problems necessarily take an extra logarithmic time factor
11:14:10 <Cope> ok
11:14:10 <CosmicRay> Cope: here's what I'd say.  If you want something truly different from what you've done before, try Haskell.
11:14:10 <CosmicRay> Cope: As edwardk says, Haskell is a language in which we routinely create and process infinite lists ;-)
11:14:10 <EvilTerran> it's maths... for breakfast!
11:14:10 <Cope> :)
11:14:10 <edwardk> erlang excels in inter-process communication. since they have so few primitives its easy for them to define a universal 'on the wire' format.
11:14:10 <CosmicRay> Cope: I like to say that Haskell manipulates functions like Perl manipulates strings.
11:14:10 <mmorrow> ski, quicksilver: woohoo, gustave: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5570#a5574
11:14:10 <edwardk> haskell has a few variations on that theme, but none that really say is competitive with erlangs model in all fairness.
11:14:10 <EvilTerran> CosmicRay, it's a bit more structured than perl's string manipulation, but i guess it's similar in terms of expressivity
11:14:10 <dons> edwardk: for serializing data?
11:14:10 <edwardk> er that I could really say
11:14:10 <jmcarthur_work> in fact i'd say that 95% of my identifiers in haskell are functions and not values
11:14:10 <CosmicRay> EvilTerran: it was a loose metaphor, yes ;-)
11:14:10 <jmcarthur_work> haskell's concurrency is as good as erlangs, in my experiences...
11:14:10 <Cope> So how is haskell different from lisp? by which I mean scheme or emacs lisp, as that's all I have any exposure to?
11:14:14 <jmcarthur_work> you have channels, STM, MVars, etc.
11:14:18 <dons> statically typed, pure, parallel.
11:14:26 <dons> its the grandchild of lisp.
11:14:29 <Cope> sorry if these are dumb questions - I'm just getting my head around the domain
11:14:39 <CosmicRay> Cope: Type system including type inference, purity are the big ones.
11:14:46 <jmcarthur_work> Cope, your questions are too common to be dumb
11:14:56 <EvilTerran> mmorrow, what's with "case :4 of :10 -> ..." etc?
11:15:00 <CosmicRay> Cope: syntax, of course, too.
11:15:05 <Cope> jmcarthur_work: maybe that makes them FAQs and I sould go read a book / website!
11:15:09 <CosmicRay> Cope: what other languages have you used?
11:15:43 <jmcarthur_work> Cope, http://haskell.org/haskellwiki/Introduction
11:15:45 <Cope> CosmicRay: python, ruby, shell, basic
11:16:08 <jmcarthur_work> Cope, and http://haskell.org/haskellwiki/Comparison_of_functional_programming_languages
11:16:13 <mmorrow> EvilTerran: those are the patterns that are just vars... i should eliminate those and sub the :4 in for :10 there.
11:16:19 <EvilTerran> mmorrow, i'm guessing this is going for elegant and correct code over gratuitously optimal output?
11:16:23 <edwardk> jmcarthur: within one machine, yes. across machines there is a world of difference. i love haskell. but when you consider erlang's communication model you have to realize it works uniformly across machines.
11:16:36 <CosmicRay> Cope: ok, I used to use Python too.  I actually wound up with Haskell because I wanted something to learn that was different enough from Python, and Ruby wasn't.
11:16:41 <mmorrow> EvilTerran: oh i'm going for gratuitously optimal output
11:16:44 <mmorrow> :)
11:16:53 <jmcarthur_work> edwardk, right, but i call that distributed computation, not concurrent computation
11:16:55 <moshisushi> is there a Haskell list type with O(1) indexing?
11:16:56 <EvilTerran> aha. also good. :)
11:16:58 <mmorrow> EvilTerran: suggestions for improvement?
11:17:01 <CosmicRay> Cope: I think of Haskell as what Python ought to have evolved to.  There's actually a bit of sharing of concepts between the too (but just a bit)
11:17:05 <EvilTerran> moshisushi, well, we've got arrays
11:17:18 <jmcarthur_work> CosmicRay, really? python seems to be the exact opposite of haskell to me
11:17:28 <lament> i'm going to a doctor, can someone quickly recommend a cool paper to read?
11:17:31 <mmorrow> EvilTerran: (i think that's optimal wrt everything but the matching the var patterns like you pointed out)
11:17:33 <J11> I just saw the diference between the declarations(hsinfixapp) , now I just have to find a way to rearange them while taking precedences into account
11:17:34 <EvilTerran> moshisushi, those are in Data.Array; we also have Data.Map, which has O(log n) insert, delete, lookup, etc
11:17:50 <CosmicRay> Cope: so Python (back when I used it), had a list type.  Then it had a generator, that could simulate a list, and build it up lazily.  Haskell's list is lazy, so it can be file-backed if needed.
11:17:52 <moshisushi> EvilTerran: oh right, very good!
11:18:04 <EvilTerran> moshisushi, and, on 64-bit machines, log n < 64, so that's near enough constant time for a lot of things :)
11:18:10 <edwardk> jmcarthur: yes, but in erlang they are one in the same. its kind of like if you only have one thread per process all 'inter-thread' communication is IPC, so you get good at IPC. They've cut off their hands, so they got good and working with their toes
11:18:12 <moshisushi> EvilTerran: so Map is a redblack tree or something?
11:18:17 <jmcarthur_work> moshisushi, Sequence has log n indexing
11:18:31 <dino-> CosmicRay: I have days where I don't understand why more of the Perl programmers I know don't like Haskell. They do so much with list processing in Perl. And some things like assigning the result of a function to a list is sort of pattern matchy.
11:18:49 <EvilTerran> moshisushi, it's some kind of balanced tree structure, yeah
11:18:53 <jmcarthur_work> edwardk, i would still call erlang a massively distributed language and not just a massively concurrent language
11:19:06 <jmcarthur_work> edwardk, and as i said already, it's *excellent* for that
11:19:08 <CosmicRay> dino-: I've got a colleague that's been a Perl fan for years.  Even goes to YAPC.  He's enjoying learning Haskell, and getting somewhat frustrated with Perl in the process.
11:19:11 <moshisushi> well what i'm actually looking for is a matrix with O(1) indexing, but i guess arrays of arrays is good then
11:19:26 <dino-> CosmicRay: That's what I like to hear. That describes me.
11:19:29 <EvilTerran> moshisushi, arrays indexed by tuples is the conventional way of doing that in haskell
11:19:30 <jmcarthur_work> moshisushi, you could check the math libraries on hackage
11:19:40 <CosmicRay> dino-: if you're used to playing with dangerous refs and regexps everywhere, the greater structure of Haskell could seem foreign or constricting, I suppose.
11:19:59 <moshisushi> jmcarthur_work yep, i will
11:19:59 <EvilTerran> moshisushi, ie, Array (Int,Int) Float would be an array of Floats indexed by pairs of Ints
11:20:15 <moshisushi> EvilTerran i see!
11:20:20 <moshisushi> thanks for the help
11:20:53 <Cope> CosmicRay: right - I know about generators
11:20:56 <Cope> yield blocks etc
11:20:59 <Cope> and list comprehensions
11:21:04 <edwardk> In any event, i tend to use erlang when i need to compute a big result, and i want to throw all the hardware I have at it. I use haskell when I want to work smarter within a box.
11:21:04 <CosmicRay> exactly
11:21:20 <dino-> dangerous refs!
11:21:24 <Cope> I think python's pretty awesome :)
11:21:32 <edwardk> jmcarthur_work: the only reason i bothered to clarify was because of the running discussion with Cope =)
11:21:32 <CosmicRay> Cope: the other thing is that Python used to be the language of simple purity.
11:21:49 <CosmicRay> Cope: but they keep adding so many __blah__ methods that it no longer meets either.
11:21:55 <Cope> yeah, totally
11:21:58 <EvilTerran> mmorrow, the outermost case in the output strikes me as a similar-but-slightly-different situation, what with the distinct ":6 ->" and "_ ->" cases
11:22:04 <jmcarthur_work> a good library for distributed computation in haskell would be nice to have
11:22:13 <edwardk> python used to brag that it was the new perl... now it is.
11:22:21 <CosmicRay> Cope: the other thing is that there is a limit to how big it can scale before it starts becoming unwieldy due to dymanic typic.
11:22:32 <CosmicRay> edwardk: hah
11:22:37 <jmcarthur_work> maybe even separate things for parallelism and concurrency, like we already have for single-machine stuff
11:23:10 <CosmicRay> Cope: Haskell has type inference, which means that the compiler guesses what type you want (most of the time) based on how you use things.
11:23:14 <Berengal> jmcarthur_work: first order of business: Serializeable closures
11:23:24 <Cope> Yeah, I'm not really sure what typing is... have heard of type inference
11:23:28 <CosmicRay> Cope: So you don't have to sprinkle Int and String all over your code like you would in Java, yet you still have strong static typing.
11:23:47 <CosmicRay> Cope: so typing is what makes sure that you don't pass a string to something that wants a list of ints or something
11:23:50 <edwardk> i had a nice little toy 'hot thunk' model i was using in a toy interpreter a while back that used to send uninterpreted thunks back and forth over the network, so you could share codata as well as data
11:24:02 <jmcarthur_work> Berengal, actually, first order of business would be tighter restrictions on data types, like Int
11:24:27 <CosmicRay> Cope: in Python, you won't know if you've had the problem until you run the program.  and maybe you hit some rarely-used part of the code and realize you expected a tuple with 3 elements and got one with just 2
11:24:31 <Cope> CosmicRay: right - ok, and python has dynamic typing, i think?
11:24:34 <CosmicRay> result: crash.
11:24:36 <CosmicRay> right.
11:24:36 <edwardk> but doing that for something like ghc is kinda terrifyingly complicated =)
11:24:42 <CosmicRay> so in Haskell, this is caught at compile time
11:24:44 <Cope> CosmicRay: right, you get the same with ruby
11:24:46 <Berengal> jmcarthur_work: You mean giving them one size on all platforms and such?
11:24:47 <CosmicRay> before your program is ever run.
11:24:49 <CosmicRay> Cope: right
11:24:53 <jmcarthur_work> Berengal, yup
11:25:05 <Cope> ah, is this like ocaml?
11:25:07 <CosmicRay> Cope: so normally the static typed languages force you to tell the compiler what type everything is.
11:25:09 <CosmicRay> Cope: yes, exactly
11:25:21 <EvilTerran> well, ours is better than ocaml's ;)
11:25:29 <CosmicRay> Cope: they have very similar type system to haskell's
11:25:36 <Berengal> jmcarthur_work: Maybe I just want the serializeable closures...
11:25:46 <Cope> got you
11:25:57 <dino-> I feel that this strong-enough-to-cause-you-grief typing drives people all the way in the other extreme to things like Perl.
11:26:03 <jmcarthur_work> Berengal, that combined with the serialization would make a pure dpar :: a -> b -> b possible, aside from the possibility of network failure...
11:26:19 <dino-> With them feeling like things like Java is the pinnacle of typing. Or something.
11:26:21 <edwardk> i.e. if i send 'let repeat x = xs where xs = x : xs in repeat 1' over the network it'll send a closure that will evaluate out to 1:1:1:1... when inspected, but it'll send the graph, not the unfolded list.
11:26:24 <Cope> oh i forgot i've done a heap of OO php too
11:26:27 <dino-> s/is/are/
11:26:45 <Berengal> jmcarthur_work: Yep, it would be great to see something like that happening
11:26:46 <mauke> dino-: possibly related: http://perl.plover.com/yak/typing/
11:26:47 * EvilTerran grabs the holy water spraybottle and points it at Cope
11:26:51 <Cope> thank you!
11:26:56 <EvilTerran> ;)
11:26:58 <Cope> I needed that! the memory was hurting!
11:27:16 <edwardk> but that can't be done directly in haskell, it'd need compiler support to provide the inspection of unevaluated thunks
11:27:17 <Cope> oh... is there a unit testing library for haskell?
11:27:31 <edwardk> cope: like HUnit?
11:27:31 <CosmicRay> Cope: HUni
11:27:39 <dino-> mauke: Thanks. I was also thinking of this: http://www.pphsg.org/cdsmith/types.html
11:27:43 <CosmicRay> Cope: there is also QuickCheck, which is even cooler for some problems.
11:27:45 <jmcarthur_work> Cope, hunit, but we have something even better for pure functions
11:27:50 <edwardk> cope: there is HUnit, and a more haskelly kind of testing library folks use called quickCheck
11:27:50 <CosmicRay> Cope: It generates test cases for you automatically.
11:28:03 <Cope> CosmicRay: ex eventu?
11:28:10 <Cope> I prefer to write the test first, then make it pass
11:28:11 <jmcarthur_work> @check \x -> (x :: Int) == read (show x)
11:28:12 <edwardk> QuickCheck is disturbingly cool
11:28:13 <lambdabot>   "OK, passed 500 tests."
11:28:46 <monochrom> haha disturbingly
11:28:55 <jmcarthur_work> i also like smallcheck
11:29:01 <Cope> jmcarthur_work: ok - how do I read that line - it's very unfamiliar
11:29:05 <monochrom> Is it because it smells like SkyNet?
11:29:15 <Cale> edwardk: Yeah, I've wanted such a thing for a while. It would be really cool to store partially evaluated expressions and values to disk or over the network.
11:29:22 <jmcarthur_work> Cope, basically i just used quickcheck to verify that serialization and deserialization are inverses for Int
11:29:52 <EvilTerran> Cope, "check, for all x, that x (which must be an Int) equals read (show x)"
11:29:53 <mauke> function (Int x) { return x == x.toString().parseInt() }
11:29:56 <CosmicRay> Cope: "\x ->" creates an anonymous function that takes one parameter named x.
11:30:15 <CosmicRay> (x :: Int) means that we force it to be of type Int, since this is a case where inference can't help us
11:30:15 <Berengal> @quote firehose
11:30:16 <lambdabot> No quotes match. Do you think like you type?
11:30:27 <Cale> Cope: That if x is an Int, then showing x (turning into a string) and then reading that string (turning it back into an Int) produces x again.
11:30:32 <EvilTerran> @quote fugue
11:30:32 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
11:30:34 <Berengal> @quote fire.*hose
11:30:35 <lambdabot> byorgey says: sometimes asking #haskell for help can be like taking a drink from a fire hose
11:30:36 <jmcarthur_work> the @check is a command for lambdabot, the \x -> means i'm defining an anonymous function with parameter x, the x::Int means i'm restricting the type of x (not always necessary, but it is for quickcheck), and the rest is the test code
11:30:39 <CosmicRay> then we just say that x == read (show x) -- in other words, that converting an int to a string and then back to an int should produce the original value.
11:30:41 <monochrom> Does it help to attach typechecking information to thunks when you pass them around or store them? Like proof-carry-code except the proof just proves types.
11:30:45 <edwardk> cale: yeah, 'lazy HOT pickles' (higher order type)
11:30:55 <Cale> edwardk: :)
11:31:00 <CosmicRay> Cope: then QuickCheck comes up with the most diabolical Ints it can think of to test it with.
11:31:00 <edwardk> sounds like a band
11:31:03 <Cope> CosmicRay: ok so is that like a lambda?
11:31:03 <jmcarthur_work> Cope, quickcheck generated 500 Ints and tested them all
11:31:10 <CosmicRay> Cope: Yes, that's what we call it even.
11:31:17 <CosmicRay> Cope: sorry, forgot you used python for a sec ;-)
11:31:29 <edwardk> I'll let you know when I release the next Lazy Hot Pickles album.
11:31:34 <Cale> edwardk: another thing I think would be cool is the ability to take the current continuation of a thread and store it to disk as an executable.
11:31:34 <Berengal> Cope: We even have editors sugaring \ to lambdas
11:31:57 <EvilTerran> Cope, the \ is supposed to be reminiscent of the main stroke of a lambda
11:32:01 <Cale> edwardk: Or indeed, freeze the entire process with all its threads and store that continuation. :)
11:32:04 <edwardk> dump core? =)
11:32:44 <Cale> edwardk: But you could use this to trivially turn an interpreter into a (very bad) compiler.
11:32:51 <Berengal> fixedPoint f = newton (λx →  f x − x)
11:33:28 <CosmicRay> Cale: doesn't emacs do that?
11:33:53 <Cale> CosmicRay: I don't know enough about emacs to say...
11:33:55 <CosmicRay> I thought that I remembered that part of building emacs involved dumping core to make the binary or something
11:34:03 <JamesSanders> How does one convert a Int to Word16?
11:34:08 <Cale> fromIntegral
11:34:10 <Zao> CosmicRay: You forgot the rubber chicken bit.
11:34:17 <edwardk> cale: that was basically what a lot of old projects used to use core dumps and fixups for
11:34:24 <Cale> > fromIntegral (5 :: Int) :: Word16
11:34:25 <lambdabot>   5
11:35:36 <JamesSanders> I see
11:35:49 <Cale> edwardk: Of course, if we had your thunk saver, it would be as simple as getting the current continuation as an IO action.
11:36:10 <Cale> (then we just serialise that and save it to disk :)
11:36:28 <Berengal> I'd like that...
11:36:32 <Cale> Er, I suppose it might take a little extra wrapping :)
11:36:40 <Cale> (if you want the executable to be executable)
11:36:42 <Berengal> getCC :: IO (IO ())
11:37:12 <jmcarthur_work> Berengal, what is join getCC then?
11:37:35 <Cale> jmcarthur_work: an infinite loop
11:37:52 * Cope reads about 'laziness'
11:38:01 <mmorrow> you've gotta be able to throw something to the CC
11:38:01 <Berengal> jmcarthur_work: join getCC === getCC >>= id
11:38:04 <jmcarthur_work> > [1..] -- laziness!
11:38:06 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
11:38:08 <Cope> I think this is like a generator in python - which yields quickly
11:38:08 <mmorrow> or else hijack it
11:38:21 <jmcarthur_work> > (4, undefined) -- more laziness!
11:38:22 <lambdabot>   (4,* Exception: Prelude.undefined
11:38:23 <edwardk> cale: the biggest problem with the thunk saving is operating system resources, etc.
11:38:25 <mmorrow> cc :: IORef (IO ())
11:38:26 <Cale> Cope: Generators in python are specifically quite a lot like lazy lists
11:38:34 <CosmicRay> Zao: so THAT'S what I was missing
11:38:37 <Cale> edwardk: yeah, that's the hard part.
11:39:09 <JamesSanders> @type PortNum
11:39:10 <lambdabot> Not in scope: data constructor `PortNum'
11:39:13 <Cale> Cope: Really though, lazy evaluation is more about the overall order in which expressions are evaluated.
11:39:16 <edwardk> cale: thats why i said i got it to work in a nice little toy environment, but anything that might have to interact with IO or even interleaved IO under the hood would just probably die ;)
11:39:17 <monochrom> > let (x,y) = (4,undefined) in x  {- better laziness -}
11:39:18 <lambdabot>   4
11:39:34 * mauke eyes JamesSanders 
11:39:49 <EvilTerran> > let (x,y) = undefined in 4 -- even more laziness!
11:39:50 <lambdabot>   4
11:39:52 <Cale> edwardk: We need an operating system which is aware of the desire to do this, I think...
11:40:09 <trofi> :t pseq
11:40:10 <lambdabot> forall a b. a -> b -> b
11:40:14 <jmcarthur_work> Cope, good examples of lazy evaluation are the short circuiting && and || operators
11:40:18 <trofi> > undefined `pseq` 4
11:40:19 <lambdabot>   * Exception: Prelude.undefined
11:40:33 <edwardk> cale: a tiny little SASOS with orthogonal persistance?
11:43:01 <Cope> I think newer python uses itertools, which explicitly uses lazy iterators, not finite lists
11:43:01 <Cale> Cope: If you've used many other programming languages, you're probably used to expressions being evaluated innermost-first, which is also called strict evaluation.
11:43:01 <Cope> Cale: right
11:43:01 <JamesSanders> something odd ise happening when I use the PortNum constructor
11:43:01 <Berengal> > let fibs = 0:1:zipWith (+) fibs (tail fibs)
11:43:01 <lambdabot>   not an expression: `let fibs = 0:1:zipWith (+) fibs (tail fibs)'
11:43:01 <JamesSanders> its seems to change the port number I passed to it
11:43:01 <Cale> That is, if you have something like f (g x), you start by evaluating x, then substituting the result into the body of g, evaluating that, and then substituting the result into the body of f, and finally evaluating that.
11:43:01 <Berengal> > let fibs = 0:1:zipWith (+) fibs (tail fibs) in fibs
11:43:01 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
11:43:01 <CosmicRay> JamesSanders: Don't use it.  Use fromIntegral instead.
11:43:01 <CosmicRay> (I think fromIntegral is what you want)
11:43:01 <Cale> Cope: But you could also evaluate things outermost-first
11:43:01 <edwardk> cope: python offers a few lazy primitives, the difference here is in Haskell, almost everything is lazy, its the default rather than the exception
11:43:01 <jmcarthur_work> > map fst (map (\x -> (x, sum [1..])) [1..]) -- more laziness at work
11:43:01 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
11:43:01 <Cale> Cope: That is, f (g x) proceeds by substituting (g x) into the body of f without first evaluating it.
11:43:01 <jmcarthur_work> notice that the sum [1..] never executed because we didn't need it
11:43:01 <Cope> Cale: ah!
11:43:01 <jmcarthur_work> which is good because it wouldn't have terminated
11:43:12 <Cale> Cope: That means that f immediately gets control over things and if it never ends up needing the parameter, then the parameter doesn't get computed.
11:43:16 <edwardk> > let f x = 12 in f undefined
11:43:17 <jmcarthur_work> i guess i should explain that code
11:43:17 <lambdabot>   12
11:43:17 <mauke> JamesSanders: the cardinal rule is: DO NOT USE THE PortNum CONSTRUCTOR
11:43:26 <mauke> JamesSanders: it is evil and will make you cry
11:43:28 <JamesSanders> CosmicRay: that worked great but whats up with PortNum
11:43:29 <jmcarthur_work> edwardk's is simpler :)
11:43:37 <EvilTerran> mauke, why is it exported, then?
11:43:38 <Cale> Cope: This is called normal-order evaluation. However, there's still a little problem with that, which lazy evaluation corrects.
11:43:42 <edwardk> that works even though any attempt to access the value i passed to f would blow up on you
11:43:48 <CosmicRay> JamesSanders: it's converting it to network byte order internally, I think.  They should not have exported that constructor.
11:43:49 <Cale> Cope: Consider the program  double x = x + x
11:43:53 <JamesSanders> mauke: It has brought me much pain
11:44:03 <edwardk> and that works even if its not just some 'magic undefined' value...
11:44:09 <edwardk> > length [1..]
11:44:15 <lambdabot>   mueval-core: Prelude.read: no parse
11:44:15 <lambdabot>  mueval: ExitFailure 1
11:44:19 <edwardk> you can never finish calculating the length of an infinite list
11:44:22 <Cale> Cope: If you evaluate something like double (double 5) under strict evaluation, you get:
11:44:26 <Cale> double (double 5)
11:44:29 <Cale> -> double (5 + 5)
11:44:29 <EvilTerran> mauke, oh, wait, according to my haddocks, it isn't. never mind me.
11:44:32 <Cale> -> double 10
11:44:35 <Cale> -> 10 + 10
11:44:36 <Cale> -> 20
11:44:38 <edwardk> > let f x = 12 in f (length [1..])
11:44:39 <lambdabot>   12
11:44:55 <Cale> But under outermost-first evaluation, it goes like this:
11:44:59 <EvilTerran> ... but according to the source, it is, it's just undocumented. hm.
11:45:00 <Cale> double (double 5)
11:45:10 <edwardk> but i can pass that 'lazy computation' into f, and as long as i don't need the answer, i'll never bother to compute it, so its fine that it doesn't return
11:45:11 <Cale> -> (double 5) + (double 5)
11:45:13 <Berengal> Another example of lazyness: #haskell is a lazily evaluated haskell tutorial
11:45:14 <EvilTerran> aha: -- PortNumber is used non-abstractly in Network.BSD.  ToDo: remove this use and make the type abstract.
11:45:16 <Cale> -> (5 + 5) + (double 5)
11:45:22 <Cale> -> 10 + (double 5)
11:45:26 <Cale> -> 10 + (5 + 5)
11:45:28 <Cale> -> 10 + 10
11:45:29 <Cale> -> 20
11:45:32 <Gracenotes> Berengal: true that
11:45:44 <edwardk> Berengal: nah, if you troll us, we become strict.
11:45:50 <EvilTerran> Berengal, well, i think IRC is closer to normal order evaluation
11:45:55 <Cale> You can see that work was repeated! We evaluated double 5 twice, because it occurred twice in the body of double.
11:45:59 <EvilTerran> seeing as we do get a fair bit of duplication
11:46:03 <jmcarthur_work> yeah we repeat ourselves a lot
11:46:04 <Cale> Cope: Following that?
11:46:06 <Gracenotes> IRC may be lazy, but it is sequenced by monads
11:46:07 <Berengal> EvilTerran: I blame a crappy compiler
11:46:15 <Cale> So lazy evaluation corrects this problem.
11:46:19 <Berengal> edwardk: I've yet to see that
11:46:25 <Cope> Cale: yes, but my wife and kids are back, so need to postpone!
11:46:26 <EvilTerran> Berengal, so we need to CSE our IRC?
11:46:32 <EvilTerran> :P
11:46:36 <edwardk> jmcarthur_work: thats because we don't do eager blackholing, so many threads are evaluating the same thunk.
11:46:42 <Cale> It says that if a parameter occurs more than once in the body of a function, then work on evaluating it is shared amongst the copies.
11:46:45 <Berengal> EvilTerran: Robot 9000 bot?
11:46:46 <jmcarthur_work> haha
11:46:58 <Cale> Cope: See you around!
11:47:00 <EvilTerran> heh, that could work
11:47:14 <Cope> you will! thanks all for being so helpful and great at explaining
11:47:16 <Raevel> unw
11:47:18 * EvilTerran thought r9k stood for "repost 9000", but that works too
11:47:23 * Cope idle.s
11:47:25 <Raevel> oops
11:47:33 <edwardk> cope: always happy to help
11:48:00 <Berengal> EvilTerran: I believe it started with a bot simply called "robot 9000" that kicked people who said something said before...
11:48:02 <Cope> I'm pretty excited by the idea of haskell as python as it shold habe become
11:48:27 <pumpkin> zomg an edwardk
11:48:51 <jmcarthur_work> Cope, i still disagree with that statement, but at least you're excited ;)
11:48:56 <edwardk> heya pumpkin
11:49:21 <edwardk> how is new hampshire treating ya?
11:49:32 <jmcarthur_work> Cope, please do come back though. we like helping
11:49:34 <pumpkin> pretty well!
11:49:45 <pumpkin> I'm almost free of all responsibility for the term
11:49:48 <Berengal> jmcarthur_work: When I started haskell I saw it as very similar to python, at least somewhat in spirit
11:49:54 <monochrom> forall x. Haskell is x as it should have become.
11:50:10 <CosmicRay> hah
11:50:12 <Cale> According to google squared, Feynman diagram weighs 6.1 oz, and Strong nuclear force weighs 40 billion tons.
11:50:25 <inimino> Haskell is Haskell as it should have become?
11:50:29 <mauke> (Haskell is actually a relative of Perl; just look at the symbols!)
11:50:32 <CosmicRay> jmcarthur: python had (has?) some functional-looking bits.  map, list comprehensions, etc.
11:50:48 <CosmicRay> mauke: and of course we can define functions using nothing but symbols!
11:50:55 <CosmicRay> mauke: obviously we are the next evolution of perl.
11:51:05 <CosmicRay> GHC 6.10.3 == Perl 7? :-)
11:51:12 <dino-> Make mauke stop making me sad. Perl is way noisier.
11:51:21 <jmcarthur_work> CosmicRay, Berengal: guido wants python to be almost nothing but imperative features though. the whole point of python is to avoid what he perceives as "magic" so as to not confuse beginners
11:51:27 <mauke> dino-: you're looking at the wrong programs
11:51:33 <CosmicRay> jmcarthur_work: except he keeps adding "magic".
11:51:49 <mauke> http://mauke.ath.cx/stuff/haskell/hax.pl
11:51:54 <CosmicRay> jmcarthur_work: I mean, once a class was pretty simple.  Then you add all __foo__ and the number of foos just keeps going up.
11:52:06 <jmcarthur_work> but they aren't functional
11:52:09 <CosmicRay> so that a method call isn't just a method call anymore, and assignment isn't always assignment, and a list isn't always a list.
11:52:10 <dino-> :P  Control.Applicative, sucker! Control.Arrow!
11:52:20 <jmcarthur_work> just because he is inconsistent doesn't mean that isn't his goal
11:52:25 <CosmicRay> heh
11:52:32 <Cale> Guido is just afraid of beginners ever becoming smarter than him.
11:52:36 <jmcarthur_work> heh
11:52:38 <CosmicRay> I think he's failed on his goal, though it's still better than perl
11:52:38 <Berengal> jmcarthur_work: Yes, they're very different languages, but in my personal and very subjective opinion they both share some of the same feel: they're both fun to program in (Haskell more than python)
11:52:51 <monochrom> his goal and what he says are irrelevant. what does he end up doing?
11:53:07 <jmcarthur_work> haskell has made scripting languages completely unfun to program in, for me
11:53:11 <monochrom> just because he says he has a noble cause doesn't mean he ends up being noble.
11:53:14 <Berengal> ... as opposed to languages that aren't fun (Java, IMHO)
11:53:18 <CosmicRay> jmcarthur_work: but yes, what Berengal said.  The similarities are readily apparent.  whatespace as syntax.  list comprehensions.  type annotations not being mandatory.
11:53:29 <monochrom> and it certainly doesn't mean the world is better off.
11:53:32 <jmcarthur_work> such things are just syntax though
11:53:41 <mauke> but python's whitespace sensitivity sucks
11:53:43 <jmcarthur_work> i could make many languages look like haskell
11:53:46 <monochrom> Gosh what does it matter what he claims.
11:54:31 <dino-> jmcarthur_work: Yes. I end up trying to script a lot with Haskell too. Things like HSH help a great deal.
11:54:32 <jmcarthur_work> monochrom, i think it's pretty well summed up by his explanation for not wanting tail call optimization :\
11:54:32 <Berengal> jmcarthur_work: It's a lot less fun to program python now than it was before I started haskell, but it's still not /tedious/
11:55:02 <jmcarthur_work> Berengal, yeah. i'm using c++ at work, which by comparison makes python look amazing
11:55:25 <Berengal> And with python I actually have use for the scroll wheel...
11:55:35 <jmcarthur_work> but i would feel the same way about using python at work and looking at haskell
11:55:40 <Berengal> Which makes me feel productive
11:55:44 <jmcarthur_work> haha
11:56:48 <monochrom> I say that I have solved the P vs NP problem. I say that I conceal my solution to you. I say that I conceal it for the better good of the whole world. I say that it is my goal. Does the world suddenly become a better place now? Do you respect me in awe and gratitude now?
11:57:09 <JusticeFries> funny article on reddit about P vs NP the other day.
11:57:15 <burp> @hoogle Fractional
11:57:15 <lambdabot> Prelude class Num a => Fractional a
11:57:16 <roconnor> @bow monochrom
11:57:17 <lambdabot> Oh my GOD -- the SUN just fell into YANKEE STADIUM!!
11:57:30 <monochrom> Oh my God there is a @bow command!
11:57:32 <Cope> I remember an article by guido saying he thinks all the 'functional' tools suck and should be removed
11:57:52 <roconnor> @bow monochrom
11:57:52 <lambdabot> I didn't order any WOO-WOO ... Maybe a YUBBA ... But no WOO-WOO!
11:57:57 <monochrom> Anyway, fucking empty words and delusional visions.
11:58:11 <jmcarthur_work> monochrom, i disagree with guido for both what he says *and* what he does
11:58:19 <monochrom> OK cool.
11:58:35 <jmcarthur_work> and they haven't seemed so far apart to me, either
11:58:40 <jmcarthur_work> apparently they do to you
11:58:46 <jmcarthur_work> which is fine
11:59:27 <Berengal> Google squared says artificial intelligence was born on July 21 1951, and is still living...
12:42:37 <JamesSanders> How do I partially apply a function that takes another function as a argument?
12:43:17 <pumpkin> no differently?
12:45:24 <a_guest> in pure code: i want to read a String to some type a with the 'Read' typeclass. the 'read' function throws error if wrong, but I want the result as 'Maybe a'. How should it be solved?
12:45:41 <sm> argh my eyes.. some hackage packages really should clean up their warnings
12:45:54 <pumpkin> :t reads
12:45:55 <lambdabot> forall a. (Read a) => String -> [(a, String)]
12:45:57 <pumpkin> a_guest:
12:45:58 <sm> I'm looking at you haxml
12:46:51 <a_guest> pumpkin: ok. i shall look it up at hoogle. thank you.
12:47:38 <pumpkin> jfredett: happy about your new wig?
12:47:51 * pumpkin glares at BONUS for not giving him one too
12:47:52 <sm> and you hsx
12:49:23 <Absolute0> What's the functor equivalent to [(x,y) | x <- [0..9], y <- [0..9]] ?
12:49:43 <kpreid> the *functor* equivalent? do you mean the functional equivalent?
12:49:55 <Absolute0> using applicatives..
12:49:56 <kpreid> > liftM2 (,) [0..9] [0..9]
12:49:57 <lambdabot>   [(0,0),(0,1),(0,2),(0,3),(0,4),(0,5),(0,6),(0,7),(0,8),(0,9),(1,0),(1,1),(1...
12:50:02 <mauke> liftA2 (,)
12:50:17 <Absolute0> >:t liftA2
12:50:27 <kpreid> :t liftA2
12:50:28 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
12:50:34 <int-e> > (,) <$> [0..9] <*> [0..9]
12:50:35 <lambdabot>   [(0,0),(0,1),(0,2),(0,3),(0,4),(0,5),(0,6),(0,7),(0,8),(0,9),(1,0),(1,1),(1...
12:50:49 <Absolute0> oh right comma is an operator :)
12:50:54 <Absolute0> simple enough :)
12:51:36 <kpreid> note that you can't take sections of the tuple operator, though
12:51:39 <kpreid> > (,1)
12:51:40 <lambdabot>   <no location info>: parse error on input `1'
12:51:42 <kpreid> > (1,)
12:51:43 <lambdabot>   <no location info>: parse error on input `)'
12:51:48 <int-e> No it's not. (,), (,,), (,,,) and so on is its own family of identifiers - tuple constructors.
12:51:59 <Absolute0> :t (,)
12:52:00 <lambdabot> forall a b. a -> b -> (a, b)
12:52:06 <Absolute0> no its not?
12:52:13 <pumpkin> :t (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
12:52:14 <lambdabot> forall a b c d e f g h i j k l m n o p q r s t u v w x y z t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t52 t53 t54 t55 t56 t57 t58 t59 t60 t61 t62
12:52:14 <lambdabot> t63 t64 t65 t66 t67 t68 t69 t70 t71 t72 t73 t74 t75 t76 t77 t78 t79 t80 t81 t82 t83 t84 t85 t86 t87 t88 t89 t90 t91 t92 t93 t94 t95 t96 t97 t98 t99 t100 t101 t102 t103 t104 t105 t106 t107 t108. a ->
12:52:14 <lambdabot> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> t34 -> t35 -> t36 -> t37 -> t38
12:52:15 <lambdabot> -> t39 -> t40 -> t41 -> t42 -> t43 -> t44 -> t45 -> t46 -> t47 -> t48 -> t49 -> t50 -> t51 -> t52 -> t53 -> t54 -> t55 -> t56 -> t57 -> t58 -> t59 -> t60 -> t61 -> t62 -> t63 -> t64 -> t65 -> t66 ->
12:52:18 <lambdabot> t67 -> t68 -> t69 -> t70 -> t71 -> t72 -> t73 -> t74 -> t75 -> t76 -> t77 -> t78 -> t79 -> t80 -> t81 -> t82 -> t83 -> t84 -> t85 -> t86 -> t87 -> t88 -> t89 -> t90 -> t91 -> t92 -> t93 -> t94 ->
12:52:21 <lambdabot> [4 @more lines]
12:52:22 <int-e> if it were, you could write  1,2 to produce (1,2).
12:52:32 <pumpkin> ugh :)
12:52:43 <Absolute0> :t ((,))
12:52:44 <lambdabot> forall a b. a -> b -> (a, b)
12:53:03 <Absolute0> i guess those inner parenteces are useless.
12:53:14 <EvilTerran> Absolute0, actually, it's the outer ones that don't do anything
12:53:14 <FAARRT> Welcome piis3141 big bad fart tarts in your pants, makin me wanna get up and go to France!!!
12:53:23 --- mode: ChanServ set +o mauke
12:53:23 --- mode: mauke set +b *!*@211.117.122.232
12:53:38 <EvilTerran> Absolute0, the inner ones are the tuple constructor syntax
12:54:09 <Absolute0> Twey: yesterday defined the operator : let (x ?? y) n = ... So i was thinking (,) is defined similarly
12:54:20 <Absolute0> :t ()
12:54:21 <lambdabot> ()
12:54:23 --- mode: mauke set -o mauke
12:54:25 <Absolute0> :t (,)
12:54:27 <lambdabot> forall a b. a -> b -> (a, b)
12:54:29 <jmcarthur_work> :t ((),(),(),(),(),(),())
12:54:31 <lambdabot> ((), (), (), (), (), (), ())
12:54:31 <Absolute0> :t ((,))
12:54:33 <lambdabot> forall a b. a -> b -> (a, b)
12:54:48 <mauke> Absolute0: (,) can't be defined normally because you can use it in patterns
12:55:01 <sm> trying the haskell platform on ubuntu dapper, I get Loading package unix-2.3.2.0 ... <command line>: can't load .so/.DLL for: rt (/usr/lib/librt.so: symbol __librt_multiple_threads, version GLIBC_PRIVATE not defined in file libc.so.6 with link time reference) while cabal installing happstack-data
12:55:07 <Absolute0> (\(,\)) ? :)
12:55:14 <EvilTerran> Absolute0, see http://haskell.org/onlinereport/exps.html#tuples
12:55:43 <EvilTerran> Absolute0, also http://haskell.org/onlinereport/basic.html#basic-tuples
12:56:05 <Absolute0> thanks.
12:59:26 <Absolute0> are arrows also common like monads and functors?
13:00:13 <EvilTerran> well... you can generate an Arrow from a Monad with Kleisli, and (->) is an Arrow
13:00:35 <pumpkin> the most common use of them is just the &&& *** first second functions
13:00:43 <pumpkin> or rather, using them as functions
13:00:54 <Absolute0> :t ***
13:00:55 <lambdabot> parse error on input `***'
13:01:00 <Absolute0> :t (***)
13:01:01 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
13:01:09 * EvilTerran thinks (->)-only versions of those should be in Data.Tuple or something
13:01:13 <Absolute0> looks like kabbalah :)
13:01:13 <pumpkin> I agree
13:02:01 <byorgey> Absolute0: just ignore everything before the . , and replace all the  a's with (->) for the function-only version:
13:02:14 <byorgey> (b -> c) -> (b' -> c') -> ((b,b') -> (c,c'))
13:02:24 <EvilTerran> Absolute0, using infix type variables (an extension), you could write that as (***) :: Arrow (~>) => (b ~> c) -> (b' ~> c') -> (b,b') ~> (c,c')
13:03:40 <Absolute0> what does (a :: * -> * -> * ->) mean?
13:04:22 <kyagrd> a is a type constructor that takes two type arguments
13:04:27 <EvilTerran> that's a kind annotation
13:04:36 <EvilTerran> ?kind Int -- types proper have kind *
13:04:37 <lambdabot> *
13:04:47 <kyagrd> I mean a is a type variable that can match to the type of the type constructor that takes two type arguments
13:04:50 <EvilTerran> (by which i mean, type expressions you can give as the type of a value)
13:05:08 <Absolute0> kyagrd: did your tounge twist when saying that? :)
13:05:32 <kyagrd> Yeah it always twists toungs when I speak about kinds.
13:05:39 <EvilTerran> type expressions that, given a type of kind k, yield a type of kind k', have kind k -> k'
13:05:48 <EvilTerran> ?kind Maybe
13:05:49 <lambdabot> * -> *
13:06:00 <EvilTerran> ^ Maybe takes a type, and gives back a type
13:06:15 <Berengal> It's sort of like functions
13:06:18 <Absolute0> kind == type constructor?
13:06:35 <kyagrd> kind categorize types
13:06:36 <Berengal> Type constructors are to concrete types what functions are to concrete values
13:06:40 <Heffalump> a kind is the "type" of a type
13:06:40 <kyagrd> type categorize values
13:06:46 <EvilTerran> Absolute0, no... kinds are to types what types are to values
13:07:01 <Heffalump> so when will GHC get polymorphic kinds? :-)
13:07:04 <EvilTerran> ?kind Either
13:07:05 <lambdabot> * -> * -> *
13:07:10 <Berengal> ?kind StateT
13:07:11 <lambdabot> * -> (* -> *) -> * -> *
13:07:16 <kyagrd> As Heffalump said kind is the "type" of types so that's whey it gets toungs twisted :)
13:08:22 <Heffalump> and why isn't Omega on hackage?
13:08:31 <byorgey> Heffalump: polymorphic kinds would be neat =)
13:08:32 <EvilTerran> Heffalump, it isn't?
13:08:37 <Heffalump> apparently not :-(
13:08:39 <kyagrd> Ah, Tim Sheard isn't yet into cabal
13:08:50 * Cale wishes for gtk2hs to be on hackage.
13:09:06 * Heffalump just had a desire to try it out but it passed in the time between thinking about downloading it from hackage and thinking about downloading it from his home page
13:09:17 <EvilTerran> Heffalump, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/control-monad-omega ?
13:09:28 <Cale> EvilTerran: That's different
13:09:30 <Zao> Cale: I wish gtk2hs had builds for 6.10.2 and 6.10.3
13:09:32 <Heffalump> that seems to be some kind of monad
13:09:38 <Cale> EvilTerran: It's similar to logict
13:09:44 <Zao> Cale: As well as didn't blow up on .2 and .3 due to the finalizer business.
13:09:45 <Heffalump> Omega is a programming language
13:09:49 <EvilTerran> ... oh. which Omega are you thinking of, if not that one?
13:09:51 <Berengal> Zao: Building from source works fine (on my machine, Ubuntu)
13:09:57 <Heffalump> Zao: I thougt that was fixed
13:09:58 <EvilTerran> ohhh. nvm. :P
13:09:58 <Zao> The mailing list seems rather ambigious on whether the finalizer patch is in or not.
13:10:10 <nibro> http://web.cecs.pdx.edu/~sheard/Omega/index.html
13:10:13 <Zao> I gave it a serious shot at building from source on Windows.
13:10:22 <Berengal> Zao: And I haven't had any finalizer problems with 6.10.3 and 0.10.1
13:10:25 <kyagrd> Thank god, I am not the only user of Omega
13:10:28 <byorgey> gtk2hs 0.10 seems to be working ok for me on ghc 6.10.3.
13:10:38 <Zao> Berengal: Leksah ate all my source with it.
13:10:42 <burp> @src subtract
13:10:42 <lambdabot> subtract x y = y - x
13:10:44 <Heffalump> kyagrd: would he accept a cabalisation patch and/or someone else uploading it to hackage, do you think?
13:10:51 <burp> @src (-)
13:10:52 <lambdabot> x - y = x + negate y
13:10:55 <kyagrd> I'll ask him
13:11:01 <Berengal> Zao: ditto, so I switched to yi
13:11:03 <Heffalump> I'm not necessarily volunteering to do it
13:11:09 <Heffalump> just wondering if I should even consider it
13:11:38 <Heffalump> oh, hmm, the license may not be acceptable anyway
13:11:48 <Heffalump> well, I guess hackage can distribute it
13:12:21 <Heffalump> it seems to be BSD3 + "no selling or commercial use"
13:12:25 <byorgey> Heffalump: why wouldn't the license be acceptable?
13:12:50 <Heffalump> well, it's not very free. But I don't know what hackage's conditions are.
13:12:56 <Heffalump> if any
13:13:00 <dons> "free to distribute"
13:13:22 --- mode: ChanServ set +o mauke
13:13:23 --- mode: mauke set -b *!*@211.117.122.232
13:14:23 --- mode: mauke set -o mauke
13:14:27 <kyagrd> He has currently put Omega on google code, so, he just doesn't seem to to want to manage two copies of the repository ... that's the current status.
13:15:01 <Heffalump> oh, the licence on google code doesn't have the commercial clause eithr
13:16:02 <kyagrd> Heffalump: i don
13:16:27 <Heffalump> ah, that's wrong, the license file still has that clause
13:17:53 <kyagrd> Heffalump: I don't see in the license that it says you can't repackage it though.
13:18:06 <Heffalump> kyagrd: agreed
13:18:18 <Heffalump> I just wasn't sure about hackage's conditions, but dons has settled that.
13:25:46 <hatds> how does something like Data.Map provide an efficient insert while remaining functional?
13:26:15 <eu-prleu-peupeu> hey
13:26:15 <eu-prleu-peupeu> :D
13:26:16 <mauke> trivially
13:26:40 <mauke> how would you make it inefficient?
13:26:42 <hatds> well I'm looking at it the wrong way obviously then
13:27:04 <hatds> the old map still has to be available right?
13:27:08 <mauke> yes
13:27:36 <hatds> so a map isn't a pointer to the root of a tree then
13:27:39 <mauke> hmm?
13:27:42 <Heffalump> hatds: it is
13:27:50 <Heffalump> it keeps the old pointer around, and returns a new one
13:28:00 <hatds> okay, what's the new pointer?
13:28:08 <mauke> what
13:28:13 <Heffalump> to a new tree, that shares as many subtrees with the old one as possible
13:28:21 <Heffalump> just the spine down to the insertion point is fresh
13:28:26 <hatds> see, now there's the trick I didn't see
13:28:42 <dons> hatds: right, via sharing
13:28:42 <dons> massive amounts of sharing
13:28:42 <dons> you end up tweaking a couple of pointers, thanks to purity
13:28:42 <dons> all the other stuff can be sharedc
13:31:31 <EvilTerran> hatds, consider a simplified situation, say, making a copy of a leaf-labelled binary tree with one element (that you know the path to) changed; at each step of the path, you can share the side that you're not changing with the old copy of the tree
13:32:33 <EvilTerran> so you end up only having to allocate new cells for the nodes in the path - Data.Map uses a similar idea, as i understand it
13:32:39 <mauke> here's a rather heavily obfuscated implementation of this idea: http://cpansearch.perl.org/src/MAUKE/Data-PrioQ-SkewBinomial-0.03/lib/Data/PrioQ/SkewBinomial.pm
13:32:53 <EvilTerran> albeit with more cleverness to maintain balancing, etc
13:33:00 <Berengal> Do we have fixed point numbers?
13:33:07 <EvilTerran> yes
13:33:18 <mauke> where?
13:33:22 <EvilTerran> Data.Fixed comes with ghc
13:33:32 <EvilTerran> > pi :: Fixed E6
13:33:33 <lambdabot>   Ambiguous occurrence `Fixed'
13:33:33 <lambdabot>  It could refer to either `Data.Fixed.Fixed', ...
13:34:05 <EvilTerran> > (pi, pi) :: (Data.Fixed.Fixed Data.Fixed.E6, Data.Fixed.Fixed Data.Fixed.E12)
13:34:06 <lambdabot>   No instance for (GHC.Float.Floating
13:34:06 <lambdabot>                     (Data.Fixed.Fixed D...
13:34:12 <EvilTerran> gr
13:34:18 <EvilTerran> > (1/3, 1/3) :: (Data.Fixed.Fixed Data.Fixed.E6, Data.Fixed.Fixed Data.Fixed.E12)
13:34:19 <Berengal> @type pi
13:34:20 <lambdabot>   (0.333333,0.333333333333)
13:34:20 <lambdabot> forall a. (Floating a) => a
13:34:28 <jmcarthur_work> ... how come i've never ever seen this before
13:34:52 <EvilTerran> normally, you could just write (Fixed E6), without all those module qualifiers. not sure what's clashing exactly.
13:35:06 <roconnor> jmcarthur_work: because EvilTerran is full of lies
13:35:10 <roconnor> :)
13:35:15 <jmcarthur_work> i see it in the standard libs
13:35:22 <jmcarthur_work> i just didn't see it until now
13:35:31 <EvilTerran> roconnor, um, fnord?
13:35:49 <roconnor> Data.Fixed is from the numbers package
13:36:00 <Berengal> > 10^6 :: Data.Fixed.Fixed Data.Fixed.E6
13:36:02 <lambdabot>   1000000.000000
13:36:09 <EvilTerran> ah, apparently lambdabot has both Data.Fixed.Fixed and Data.Number.Fixed.Fixed in scope
13:36:11 <jmcarthur_work> why are E6 and E12 the only ones defined
13:36:14 <jmcarthur_work> ?
13:36:37 <roconnor> holey crap, it is in base-4.1.0.0!
13:36:42 <roconnor> good god!
13:37:13 <jmcarthur_work> no wonder
13:37:16 <EvilTerran> roconnor, i was gonna say, it's in base according to my local copy of the haddocks, and haskell.org's copy...
13:37:30 <roconnor> I refuse to believe what I see.
13:37:42 <roconnor> I claim that I'm right and the rest of the universe is wrong
13:38:00 <Berengal> Are they bignums, or do they wrap?
13:38:03 <EvilTerran> i don't think that argument works unless you're paul graham
13:38:03 * Apocalisp thinks roconnor is secretly Maceo Parker
13:38:11 <Cale> jmcarthur_work: Well E6 is units of millions.
13:38:24 <Cale> Er, millionths, I suppose.
13:38:38 <Berengal> micro
13:38:42 <Cale> yes
13:38:49 <Berengal> Or µ, as I like to call them
13:39:10 <mauke> not to be confused with μ
13:39:10 <jmcarthur_work> E6 should be called Micro then ;)
13:39:12 <Cale> and E12 would be millionths of millionths, or pico-whatever
13:39:21 <roconnor> boy, these base packages really do need to be cleaned out
13:39:21 <Cale> Micro is Fixed E6
13:39:32 <jmcarthur_work> oh that is defined?
13:39:32 <Cale> @kind Micro
13:39:33 <lambdabot> *
13:39:35 <Cale> yes
13:39:35 <Berengal> nano, no?
13:39:42 <jmcarthur_work> nice
13:39:45 <Apocalisp> µber micro
13:39:50 <Cale> Nano would be Fixed E9, but that's not defined
13:40:05 <jmcarthur_work> should be!
13:40:05 <Cale> @kind Pico
13:40:06 * Berengal has forgotten his greek :(
13:40:06 <lambdabot> *
13:40:16 <Berengal> > 10^6 :: Data.Fixed.Fixed Micro
13:40:17 <lambdabot>   No instance for (Data.Fixed.HasResolution
13:40:17 <lambdabot>                     (Data.Fixed.F...
13:40:25 <jmcarthur_work> > 10^6 Micro
13:40:27 <lambdabot>   Not in scope: data constructor `Micro'
13:40:28 <jmcarthur_work> > 10^6 :: Micro
13:40:29 <lambdabot>   1000000.000000
13:40:33 <jmcarthur_work> > 10^6 :: Pico
13:40:35 <lambdabot>   1000000.000000000000
13:40:37 <jmcarthur_work> that is awesome
13:40:42 <Berengal> 10^65 :: Micro
13:40:49 <Berengal> > 10^65 :: Micro
13:40:51 <lambdabot>   100000000000000000000000000000000000000000000000000000000000000000.000000
13:41:01 <EvilTerran> i'm guessing these are newtype-wrapped Integers
13:41:03 <jmcarthur_work> it's implemented as an Integer
13:41:04 <Cale> yes
13:41:08 <roconnor> now if only GetCPUTime used that type.
13:41:14 <jmcarthur_work> and threadDelay
13:41:17 <Cale> It really should.
13:41:29 <roconnor> yes, treadDelay is even more important
13:41:31 <sm> how do I get ghc to build static binaries, including the c libs as well ?
13:41:45 <mauke> I always end up writing a threadDelay wrapper
13:42:01 <roconnor> Cale: mark that down on HasCale's to do list
13:42:11 <Cale> Anyway, it's easy to define your own resolutions.
13:42:20 <Cale> data E9 = E9
13:42:27 <Cale> instance HasResolution E9 where
13:42:34 <Cale>   resolution = 10^9
13:42:51 <Cale> type Nano = Fixed E9
13:43:05 <Berengal> Seems nifty enoguh
13:43:08 <Berengal> enough*
13:43:14 <Cale> It's just unfortunate that we don't have dependent types :)
13:43:22 <Berengal> now to write my sin, cos and pi wrappers...
13:43:23 <jmcarthur_work> yeah, that would top it off
13:43:34 <jmcarthur_work> > pi :: Pico
13:43:36 <lambdabot>   No instance for (GHC.Float.Floating Data.Fixed.Pico)
13:43:36 <lambdabot>    arising from a use ...
13:43:44 <jmcarthur_work> :(
13:43:54 <mauke> > realToFrac pi :: Pico
13:43:55 <lambdabot>   3.141592653589
13:44:12 <jmcarthur_work> > realToFrac (pi :: CReal) :: Pico
13:44:14 <mauke> > realToFrac (pi :: CReal) :: Pico
13:44:14 <lambdabot>   * Exception: CReal.toRational
13:44:15 <lambdabot>   * Exception: CReal.toRational
13:44:18 <jmcarthur_work> :P
13:44:20 <mauke> doh ho ho
13:44:48 <Berengal> Silly people, you can't represent real numbers as rationals...
13:45:04 <jmcarthur_work> it's supposed to be an approximation here anyway :(
13:45:12 <jmcarthur_work> but realToFrac is wrong i guess
13:45:16 <duaneb> can I use cabal with other languages?
13:45:20 <duaneb> specifically ocaml? :P
13:45:27 <duaneb> I really hate OMake
13:45:27 <Berengal> @src realToFrac
13:45:28 <lambdabot> realToFrac = fromRational . toRational
13:45:32 <duaneb> it doesn't work on my NFS mount
13:45:38 <mauke> you can always scale it up, round, and scale down again
13:45:46 <jmcarthur_work> yeah...
13:45:51 <roconnor> duaneb: I'm not sure but I didn't think that cabal was a build system.  Am I wrong?
13:46:03 * roconnor hopes he is wrong
13:46:17 <Berengal> roconnor: It does have configure, build and install...
13:46:19 <Berengal> and clean
13:46:26 <Berengal> Looks like a build system to me...
13:46:29 <duaneb> roconnor: it's a build system AND a package system
13:46:41 <sm> would cabal install ... --gcc-options=-static do the trick ?
13:46:46 <roconnor> Berengal: how does it do dependencies?
13:46:47 * sm is trying to build portable linux binaries
13:46:54 <Berengal> roconnor: magic
13:47:02 <jmcarthur_work> > round ((pi :: CReal) * 10^12) `div` 10^12 :: Pico
13:47:04 <lambdabot>   No instance for (GHC.Real.Integral Data.Fixed.Pico)
13:47:04 <lambdabot>    arising from a use o...
13:47:12 <jmcarthur_work> grr
13:47:15 <roconnor> Berengal: I guess there is no magic for ocaml
13:47:18 <Berengal> I'm guessing ghc takes care of the dependencies
13:47:31 <Berengal> cabal just feeds it compilation flags...
13:47:35 <Berengal> I could be wrong
13:47:35 <jmcarthur_work> > (fromIntegral $ round ((pi :: CReal) * 10^12)) `div` 10^12 :: Pico
13:47:36 <lambdabot>   No instance for (GHC.Real.Integral Data.Fixed.Pico)
13:47:36 <lambdabot>    arising from a use o...
13:47:44 <roconnor> Berengal: so it calls ghc to get module dependencies?  Can I ask that of ghc too?
13:47:52 <EvilTerran> jmcarthur_work, may i suggest /msg lambdabot?
13:47:57 * jmcarthur_work doesn't feel like messing around with the Num hierarchy anymore
13:48:02 <jmcarthur_work> EvilTerran, sorry
13:48:16 <EvilTerran> giving up works too :P
13:48:18 <kyagrd> Does anyone know why GHCi switched to libedit from readline?
13:48:19 <mauke> > fromIntegral (round (pi * 10^12 :: CReal)) / 10^12 :: Pico
13:48:20 <lambdabot>   3.141592653590
13:48:22 <roconnor> jmcarthur_work: CReal ought to have an approx function but as I recall it doesn't.
13:48:25 <Berengal> roconnor: ghc --make does the dependency magic. You might find some flag to dump them in the manual, but I don't know of one
13:48:48 <jmcarthur_work> roconnor, it almost defeats the purpose of CReal to not having something handy like that
13:48:50 <roconnor> Berengal: does calling ghc --make really count as a build system?
13:48:51 <Berengal> kyagrd: Licencing
13:48:57 <roconnor> jmcarthur_work: I agree
13:49:06 * EvilTerran habitually makes sure things work how he expects in lambdabot via /msg before doing them in a channel
13:49:14 <mauke> kyagrd: the ghc developers hate ghci users
13:49:19 <Berengal> roconnor: Not really, it just finds dependencies (local ones)
13:49:21 <kyagrd> Berengal: But why can't GHC be GPL? GHC is a compiler
13:49:30 <EvilTerran> typo protection, mainly
13:49:36 <CosmicRay> jmcarthur_work: I have made a few handy tables about that stuff.
13:49:37 <EvilTerran> kyagrd, not everyone likes the GPL
13:49:48 <jmcarthur_work> EvilTerran, sometimes i do it in the channel because others jump in to help sometimes, but that wasn't why i was doing it this time. was just not expecting so many problems :)
13:49:57 <jmcarthur_work> CosmicRay, i think i have seen them
13:50:01 <kyagrd> You don't link go GHC, we just compile with it.  Even with GPL compilers there's no problem building commercial non-open soucre stuff
13:50:02 <Berengal> kyagrd: I don't really know. Someone wanted to integrate ghci in their projects or somesuch
13:50:05 <jmcarthur_work> or somebody else's
13:50:15 <CosmicRay> jmcarthur_work: http://book.realworldhaskell.org/read/using-typeclasses.html and scroll down until you get to the giant tables
13:50:20 <kyagrd> It really hurts for multibyte character users
13:50:34 <Berengal> kyagrd: We've switched to haskelline since then though
13:50:46 <mauke> kyagrd: 6.10.1 and 6.10.2 are relatively easy to build with readline
13:50:48 <pumpkin> in fact, we're moving to get rid of the last bit of GPL
13:50:49 <mauke> there's a patch floating around
13:50:52 <Berengal> And libedit and readline are binary compatible, so you should be able to just switch the .so's
13:51:18 <mauke> 6.10.3 just sucks in this regard
13:51:34 <roconnor> jmcarthur_work: I'd be inclined to make a fork of CReal, except that as far as I understand CReal is illegal.
13:51:36 <EvilTerran> when tying something huge and unwieldy into your project, i feel the question should be "is there a reason why we must?", not "is there a reason why we can't?"
13:51:44 <CosmicRay> mauke: another reason 6.10.3 sucks?  sigh
13:51:45 <EvilTerran> and the GPL is most definitely huge and unwieldy :P
13:51:47 <pumpkin> roconnor: why?
13:51:52 <kyagrd> Oh, is GHC 6.10.3 haskline?
13:52:25 <roconnor> I'm not aware that Augustsson ever got Lester's permission to distribute it.
13:52:46 <roconnor> maybe he has now, since Lester seemed aware that it is in use last time I talked to him.
13:52:46 <mauke> EvilTerran: the GPL doesn't affect me negatively as a user
13:56:33 <EvilTerran> mauke, i'd continue ranting, but it's off-topic, and also i want to get to bed at a reasonable time ;)
13:58:18 * EvilTerran puts "flesh out my rant against the GPL into an essay" on his list of "things to do when i have copious free time"
13:58:28 <kyagrd> haskline is better than editline (at least it is possible to type in multibypte characters) but still doesn't handel multibyte characters on the command line prompt as readline does.
13:58:57 <EvilTerran> (that'll be... say, the first thursday after never? :P)
14:01:39 <sm> I see.. ghc --make -optl-static. But during linking, I get a lot of errors like /home/ian/work/to_release/libedit2/ghc-6.10.2/libffi/build/src/dlmalloc.c:2486:0:
14:01:39 <sm>      undefined reference to `pthread_mutex_lock'
14:01:45 <Heffalump> kyagrd: I've got a rudimentary cabalisation. Would you like it?
14:02:01 * sm nudges Igloo
14:03:06 <mauke> try something with -optc-pthread -optl-lpthread ... maybe?
14:03:54 <kyagrd> Heffalump: there's actually a few things you'd want to fix ... I'll be happy to help you on that (as soon as I get done with my coursework project)
14:04:19 <sm> mauke: sounds good, but no luck
14:04:50 <Heffalump> kyagrd: like what? I just wanted to make something that would be suitable for getting the current implementation onto hackage, not fixing extra stuff :-)
14:04:57 <kyagrd> Heffalump: there's actually a few things you'd want to fix. Omega hasn't been thought out much for distribution so, it wouldn't work just cabalizing it because of directory search for library.
14:05:13 <kyagrd> For example,  LangPrelude.prg should be in the same directory you run omega.exe
14:05:35 <pumpkin> how do I wrap opaque types in the haskell ffi?
14:05:37 <Heffalump> ah, right. I should have paid more attention when I ran it :-)
14:05:56 <pumpkin> should I just pass around a Ptr ?
14:08:09 <pumpkin> seems to work
14:09:37 <kyagrd> For example,  LangPrelude.prg should be in the same directory you run omega.exe, <== actually even worse you should CD to that directory  where both omega.exe and LangPrelude is :-(
14:10:15 <sm> success! ghc --make hledger.hs -optl-static -optl-pthread
14:10:17 <sm> thanks mauke
14:10:57 <Heffalump> it seems to work if the file is in the current working directory, even if omega isn't
14:12:27 <kyagrd> Heffalump: Oh, that may be the case ... I was using it just symbolic linking both files into current directory
14:12:31 <Heffalump> which makes sense as it just does openFile
14:12:47 <Heffalump> oh well, bed calls
14:13:58 <Berengal> Man, am I brain dead tonight... I can't even remember how to rotate vectors...
14:17:07 <sinelaw> Berengal, try a plier
14:17:20 <roconnor> Berengal: 2D or 3D?
14:17:26 <Berengal> roconnor: 2D
14:17:42 <sm> ack, doesn't work on a mac, of course. ld_classic: can't locate file for: -lcrt0.o
14:17:49 <sm> well, more another day
14:17:59 * roconnor tries to think of an obtuse way of explaining it to Berengal
14:19:50 <Berengal> I did figure it out eventually... but now I foresee lots of floating point errors...
14:19:57 <twanvl> rot a (x,y) = (x cos a + y sin a,x sin a - y cos a)  -- iirc
14:20:10 <roconnor> Berengal: really?
14:20:42 <roconnor> Berengal: are you rotating by 1000000*pi and a bit?
14:20:46 <Berengal> I need 'v == head . drop 50 . iterate (rotate pi) $ v'
14:21:00 <roconnor> ooh
14:21:12 <roconnor> iterate (rotate pi)
14:21:27 <roconnor> iterate (anything floating point) - :'(
14:21:35 <mauke> (!! 50)
14:21:51 <twanvl> rotate pi (x,y) = (y,-x)
14:21:53 <Berengal> mauke: (!!) is bad :O
14:21:59 <mauke> Berengal: why?
14:22:07 <Berengal> mauke: Linked list, and irony
14:22:15 <roconnor> Berengal: head is just as bad as (!!)
14:22:18 <mauke> what
14:22:22 <Berengal> roconnor: Not on iterate...
14:22:34 <roconnor> ah right
14:22:36 <roconnor> drop not take
14:22:44 <roconnor> um
14:22:53 <roconnor> (!!) is "good" on interate too
14:22:56 <Berengal> mauke: It was an apparantly failed attempt at humor
14:23:08 <Berengal> roconnor: You and your logic...
14:23:24 <roconnor> add a GHC RULE for rotate pi
14:23:35 <Berengal> I won't always be rotating by pi...
14:24:00 <Berengal> But I want rotate (pi/3) . rotate (2* (pi/3)) == rotate pi...
14:24:20 <roconnor> Berengal: you need a new num type for rational multiples of pi
14:24:27 <aledge> quaternioonsssssss
14:24:55 <roconnor> aledge: we are in 2D so you mean co-co-complex numbers
14:25:08 <mauke> newtype TimesPi a = TimesPi a
14:25:09 <aledge> roconnor: hehe i mean what i said!
14:25:15 <aledge> roconnor: ;)
14:25:18 <mauke> .oO( mplex numbers )
14:25:22 <Berengal> roconnor: sin and cos won't work... :/
14:25:55 <roconnor> Berengal: you use unit complex numbers to represent rotors.
14:26:13 <Berengal> Someone tell me there's a nice vector package on hackage, please...
14:26:31 <roconnor> Berengal: I've been thinking of writing one.
14:26:38 <roconnor> for my definition of "nice"
14:26:56 <Berengal> I set out with something completely different in mind, and didn't figure I needed complex mathematics...
14:27:08 <roconnor> Berengal: maybe I didn't understand what you meant by "sin and cos won't work..."
14:27:30 <Berengal> roconnor: Not sure I did myself...
14:27:40 <roconnor> Berengal: the mathematics behind 2D rotations is isomorphic to the mathematics behind unit complex numbers.
14:27:40 <Berengal> I'm being exceptionally stupid right now :/
14:27:44 <aledge> rotation in 2d is a simple matrix multiplication:
14:28:09 <aledge> [cos(theta) -sin(theta) ; sin(theta) cos(theta)]
14:28:16 <Berengal> roconnor: That's why I said "complex mathematics" above :P
14:31:39 <roconnor> Berengal: anyhow, for rotations, 2D or otherwise just take the outer product any source vector with it's target vector, divide it by 2, and then you can conjugate any vector with this 2-blade you made to rotate it.
14:31:42 <roconnor> simple!
14:33:57 <roconnor> hmm
14:34:24 <roconnor> or do you take the geometric ratio of the target vector and source vector ... that would make more sense.
14:34:34 <roconnor> bah
14:34:39 * roconnor goes shopping instead
14:35:25 <Berengal> Meh, I'll just hack it and do the Right Think once my brain isn't thrashing swap...
14:36:07 <Berengal> I'm working on something completely different, and just need this bit to play around in ghci...
14:37:02 * Berengal writes 'angle :: Double'
14:42:54 * shapr boings quietly
14:43:01 <shapr> whee!
14:52:53 <bavardage> how can I write individual bits to a file?
14:53:02 <pumpkin> bits?
14:53:08 <bavardage> yop
14:53:09 <pumpkin> like, non-multiples of 8?
14:53:10 <pumpkin> :o
14:53:11 <bavardage> yop
14:53:19 <bavardage> those.. :D
14:53:25 <pumpkin> um
14:53:26 <bavardage> or am I doing it wrong :D
14:53:33 <Cale> bavardage: I'm pretty sure that most operating systems disallow files whose length is not a multiple of 8 bits.
14:53:35 <bavardage> I'm attempting a huffman encoding thing
14:53:37 <EvilTerran> er, files have to be a whole number of bytes
14:53:46 <bavardage> right, so I could pad it..
14:54:07 <EvilTerran> but you can bitpack bits into a ByteString, say
14:54:08 <luqui> bavardage, if you're doing huffman coding, you probably want to do the bit twiddling yoursel
14:54:17 <EvilTerran> and then write that out verbatim to a file
14:54:23 <bavardage> yeah how do I do this
14:54:27 <Cale> Yeah, perhaps include a symbol in your huffman encoding which indicates the end of the message, and then you can safely pad things with 0's.
14:54:27 <bavardage> the writing it verbatim
14:54:46 <bavardage> (I could just have a header saying how much padding..)
14:54:55 <Cale> bavardage: Data.ByteString will help :)
14:54:55 <bavardage> but yeah
14:55:00 <bavardage> so how do I do this :D
14:55:03 <bavardage> I'm using ByteString atm
14:55:16 <bavardage> I'll go look again
14:55:27 <Cale> Take chunks of 8 bits, and turn them into Word8's.
14:55:32 <bavardage> oh kk
14:55:42 <Cale> So you'll have some function [Bool] -> [Word8]
14:55:50 <Cale> and then you can use Data.ByteString.pack
14:55:59 <bavardage> ooh kk
14:56:10 <bavardage> and then for unpacking just read the word8s?
14:56:14 <Cale> yeah
14:56:15 <bavardage> and unmush them
14:56:16 <bavardage> kk
14:56:17 <bavardage> gotcha :D
14:56:33 <bavardage> i'm cheating somewhat on storing the encoding tree :D
14:56:42 * EvilTerran ponders a ByteString wrapper, BitString, with pack :: [Bool] -> BitString :P
14:56:48 <bavardage> :D
14:56:57 <bavardage> EvilTerran: get coding so it's ready for me tomorrow
14:56:58 <bavardage> hehehe
14:57:09 <EvilTerran> bavardage, see http://www.haskell.org/ghc/docs/latest/html/libraries/bytestring/Data-ByteString.html#26
14:58:05 <EvilTerran> you probably want writeFile or hPutStr
14:58:06 <bavardage> which bit am I looking at?
14:58:08 <bavardage> oh k
14:58:14 <dmwit> EvilTerran: UArray Bool is already like that, if you happen to know how long the list is.
14:58:16 <bavardage> yeah I think so
14:58:33 <bavardage> EvilTerran: thanks :D
14:58:36 <bavardage> Ima bed now
14:58:40 <bavardage> but tomorrow
14:58:56 <bavardage> I shall finally have a compression program all of my own :D
14:59:00 <bavardage> which will probably make things larger
14:59:03 <EvilTerran> dmwit, yeah, i was just thinking that UArrays aren't ideal for appending, splitting, etc
14:59:09 <dmwit> ah, right
14:59:18 <bavardage> o/
14:59:26 <Vq^> or a _lot_ smaller (but without a decompression program)
15:00:00 <seliopou> bavardage, http://github.com/arjunguha/misc/tree/d8576fe85f52ea6f7eafe7f72b2daac97b2af3d3/Huffman <- if you want a hs reference implementation
15:01:02 <pumpkin> for things I'd typically have living on the stack in a c function, I'd use alloca in the FFI, right?
15:01:22 <EvilTerran> i believe so
15:01:37 <EvilTerran> that's the name of the cstdlib function you use to dynamically allocate on the stack
15:02:48 <pumpkin> yeah
15:02:54 <pumpkin> not sure it's really a function
15:03:09 <pumpkin> or if it is, a well behaved one
15:03:10 <Zao> For great amusement, try _malloca on MSVC++.
15:03:31 <Zao> Allocates on the stack if below a certain size, allocates on the heap if the amount is large enough or in debug mode.
15:03:34 <EvilTerran> it's definitely not well-behaved
15:03:51 <pumpkin> I would've thought it'd just be a compiler primitive
15:04:06 <pumpkin> that tells it to add a constant to the stack
15:04:10 <pumpkin> pointer
15:04:11 <Zao> http://haskell.org/ghc/docs/latest/html/libraries/base/Foreign-Marshal-Alloc.html#v:alloca <- much nicer
15:04:11 <ray> foreign send_to_corner
15:04:31 <EvilTerran> iirc, some compilers barf if you use an alloca call inline as a parameter to a function
15:04:48 <Zao> pumpkin: Judging by the documentation on -ansi for g++, alloca is built-in if not pedantic.
15:04:58 <pumpkin> ah
15:05:02 <Zao> EvilTerran: The ones that don't are even more fun.
15:05:09 <EvilTerran> foo(x, alloca(n), y) -- n bytes allocated between x and y on the parameter stack, anyone?
15:05:14 <Zao> Err, not -ansi
15:05:33 <pumpkin> so say I have a typedef moo easymoo[1]; in c, where moo is a struct
15:05:47 <monochrom> Woah, alloca mucking with the stack, yes that's problematic.
15:05:49 <pumpkin> all the functions take easymoo
15:06:01 <pumpkin> what's a nice way to FFI to that in haskell
15:06:02 <pumpkin> ?
15:06:44 <ray> yes
15:06:47 <EvilTerran> preflex: ctype typedef moo easymoo[1]
15:06:48 <monochrom> I assume that if a function "takes" easymoo, it really takes moo*
15:06:57 <pumpkin> yeah
15:07:12 <pumpkin> but the moo struct gets put onto the stack
15:07:18 <mauke> what
15:07:22 <pumpkin> or doesn't it?
15:07:23 <monochrom> In FFI it becomes a CPtr, I assume.
15:07:25 <mauke> it's a pointer
15:07:46 <pumpkin> yeah, so what's the difference between typedef moo *easymoo and typedef moo easymoo[1] ?
15:08:00 <mauke> one is a pointer, one is an array. however!
15:08:12 <pumpkin> oh no, not however! :(
15:08:13 <mauke> a function parameter declared as an array is silently converted to a pointer
15:08:26 <monochrom> If you declare a variable "easymoo x;", there are differences.
15:08:31 <mauke> regardless of whether the array declaration uses [] or goes through a typedef
15:08:38 <pumpkin> monochrom: that's the situation I'm talking about
15:08:47 <mauke> (also, any size information is ignored in that case, which is why it's optional)
15:08:59 <monochrom> But parameter passing makes no difference.
15:09:00 <mauke> pumpkin: no, you were talking about function parameters
15:09:10 <pumpkin> oh, the function parameter bit is fine
15:09:22 <pumpkin> the question is where does that moo struct live when I just define easymoo x; in a function?
15:09:27 <monochrom> How about this explanation: If you pass an array parameter to a function, it is passed by reference not value, no copying.
15:09:57 <monochrom> Likely stack variable.
15:09:59 <EvilTerran> pumpkin, that'd be the stack, i think.
15:10:11 <pumpkin> ok, that's what I thought
15:10:19 <pumpkin> so the most appropriate replacement for that is alloca in haskell?
15:10:37 <mauke> yes
15:10:39 <EvilTerran> it's just "easymoo x" as a parameter would be the same as "moo * x" as a parameter
15:10:48 <pumpkin> yeah
15:10:55 <pumpkin> I see, thanks :)
15:11:06 <EvilTerran> and they'd be different as variables; isn't C fun!
15:11:31 * EvilTerran took about three attempts to work out what the typedef meant in the first place :P
15:11:48 <monochrom> typedef is fun too.
15:12:04 <mauke> typedefs mean the same thing as without 'typedef', but as a type
15:12:23 <EvilTerran> mauke, i know, i just don't write enough C to be used to it.
15:12:41 <mauke> int x[1];  /* x is array[1] of int */  typedef int x[1]; /* x is an alias for array[1] of int */
15:13:01 <mauke> for bonus wtf, the order of 'typedef' and 'int' doesn't matter
15:13:28 <idnar> even more fun is typedef'ing a function type
15:13:54 <idnar> typedef void (*char)(int); // can you spot the name of the typedef?
15:14:11 <idnar> a function pointer type, that is
15:14:31 <EvilTerran> idnar, casting between function pointer types is particularly odd; "(void (*) (int))foo" :D
15:14:39 <EvilTerran> idnar, i think you're redefining "char"
15:14:49 <idnar> oh, I suppose that's not actually legal
15:14:52 <mauke> idnar: that looks like a syntax error
15:15:17 <mauke> in particular '*char' looks unlikely
15:15:27 <EvilTerran> if you'd've gone for "bool", that could've been both sneaky *and* legal C89 :P
15:15:39 <idnar> anyway, make it "typedef void (*name)(int);" then it will compile
15:15:47 <mauke> and C99 in the absense of #include <stdbool.h>!
15:15:56 <idnar> that declares "name" as an alias for the type of pointers to functions taking one int param and returning void
15:16:14 <mauke> as always, hiding pointers behind typedefs sucks :-)
15:16:17 * EvilTerran couldn't remember if C99 made bool a keyword or not
15:16:22 <mauke> typedef void name(int); // clearly superior!
15:16:25 <idnar> or put differently, it declares "name" as an alias for "void (*)(int)"
15:16:28 <mauke> EvilTerran: no, only _Bool
15:16:39 <ray> c99 bools are so stupid :)
15:16:48 <idnar> Bool99
15:16:55 <EvilTerran> mauke, er, ew. yay for a lack of namespacing.
15:17:21 <mauke> _Complex double EvilTerran;
15:18:18 <monochrom> you could have tried "typedef t3(*t2)(t1);" and made us guess who are types and who are, err, types again.
15:18:43 <mauke> t2 is being defined there
15:18:50 <mauke> it comes after a *
15:18:53 <monochrom> But why am I going 321 instead of 210.
15:21:04 <ehird> newtype Mirror = Mirror (Mirror -> Bool). Challenge: Write a function mirror :: Mirror -> Bool, so that mirror (Mirror mirror) is True, and hopefully most other functions aren't (unless you specifically craft one based on its source). The less false positives the better. That is - it detects itself :-)
15:22:43 * Saizan is reminded of blind guardian
15:24:15 * EvilTerran 's brain melts at contravariant type recursion
15:24:28 * ehird pokes EvilTerran
15:24:31 <ehird> 'se dead?
15:24:37 * EvilTerran wibbles
15:24:41 <mauke> I can't even make mirror return different values :(
15:24:53 * ehird pokes EvilTerran. We must test him.
15:24:57 <mauke> C syntax is so much easier
15:25:09 <ehird> mauke: mirror f = f (const True) && f (const False). You can also nest that.
15:25:13 <ehird> Er.
15:25:16 <ehird> Mirror (const True), ofc.
15:25:38 <ehird> mauke: Also, w/ Mirror (const True), you can also do Mirror (\f -> f (Mirror (const True))).
15:25:49 <ehird> Nest ad infinitum— could be useful for "secret code" sentinels.
15:26:57 * EvilTerran wonders if it'd be instructive to write an Arbitrary instance for Mirror
15:27:05 <bratline> http://mein-erstes-mal.net/?id=2052538
15:27:45 <Axman6> urgh
15:27:53 <mauke> ehird: mirror (Mirror mirror) == False
15:27:58 <ehird> mauke: sure
15:28:02 <EvilTerran> > repeat "spam"
15:28:02 <mauke> oh, ok
15:28:03 <lambdabot>   ["spam","spam","spam","spam","spam","spam","spam","spam","spam","spam","spa...
15:28:08 <ehird> mauke: but you sure can make it give different values
15:28:11 <mauke> yes
15:28:24 <ehird> you just have to interrogate it while winking in a secret code
15:28:28 <ehird> "just"
15:28:49 <mauke> heh, it recurses in a wrong angle. my brain isn't used to this
15:29:23 <ehird> it certainly is difficult
15:29:37 <ehird> because you have no other communication channels other than asking it to interrogate another function
15:29:48 <ehird> and it can't look out to compare just to one sentinel function, as (see start of sentence)
15:30:32 <pumpkin> zomg I just used <=<
15:31:06 <trofi> :t (<=<)
15:31:08 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
15:31:23 * pumpkin is happy
15:31:35 <ray> hooray
15:31:39 <ray> let's throw you a party
15:32:38 <pumpkin> :)
15:33:48 * ehird throws pumpkin a party, and it smashes into his face
15:33:49 <ehird> sorry about that.
15:33:56 <pumpkin> :o
15:35:04 <idnar> Saizan:  o/` mirror, mirror, on the wall o/`
15:36:14 <Saizan> :)
15:39:53 <gnuvince_> Is Either defined as a monad somewhere?
15:40:02 <mauke> MonadError
15:40:23 <gnuvince_> mauke: thank you
15:47:38 <bratline0> http://mein-erstes-mal.net/?id=2052538  http://mein-erstes-mal.net/?id=2052538  http://mein-erstes-mal.net/?id=2052538  http://mein-erstes-mal.net/?id=2052538  http://mein-erstes-mal.net/?id=2052538  http://mein-erstes-mal.net/?id=2052538  http://mein-erstes-mal.net/?id=2052538  http://mein-erstes-mal.net/?id=2052538  http://mein-erstes-mal.net/?id=2052538  http://mein-erstes-mal.net/?id=2052538  http://mein-erstes-mal.net/?id=2052538  htt
15:47:48 --- mode: ChanServ set +o mauke
15:47:49 --- mode: mauke set +b *!*@p549C720F.dip.t-dialin.net
15:47:49 <ehird> htt
15:48:49 --- mode: mauke set -o mauke
15:52:35 <sheyll> pf (\(v,c) (v',c') -> compare v v')
15:53:24 <sheyll> lambdabot: pf (\(v,c) (v',c') -> compare v v')
15:53:28 <ivanm> sheyll: methinks you want @pl ...
15:53:39 <ivanm> @pl (\(v,c) (v',c') -> compare v v')
15:53:39 <lambdabot> (`ap` snd) . (. fst) . (const .) . compare . fst
15:53:46 <ivanm> compare `on` fst ...
15:53:53 <sheyll> ah yeah
15:53:56 <sheyll> omfg
15:53:58 <ivanm> @type (\(v,c) (v',c') -> compare v v')
15:53:59 <lambdabot> forall t t1 t2. (Ord t) => (t, t1) -> (t, t2) -> Ordering
15:54:02 <ivanm> @type compare `on` fst
15:54:03 <pumpkin> :t comparing fst
15:54:04 <lambdabot> forall a b. (Ord a) => (a, b) -> (a, b) -> Ordering
15:54:04 <lambdabot> forall a b. (Ord a) => (a, b) -> (a, b) -> Ordering
15:54:14 <ivanm> pumpkin: or comparing, take your pick
15:54:15 <sheyll> @type on
15:54:16 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
15:54:22 <pumpkin> why thank you :)
15:54:28 <ivanm> pumpkin: so you're the "real" pumpkin now? :p
15:54:29 <yitz> @type comparing
15:54:30 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
15:54:43 <ivanm> comparing = compare `on` IIRC
15:54:45 <pumpkin> ivanm: it depends which laptop I'm using, but yeah :)
15:54:46 <ivanm> @src comparing
15:54:46 <lambdabot> Source not found. Just try something else.
15:54:51 <aavogt> @index comparing
15:54:51 <lambdabot> bzzt
15:54:52 <ivanm> @src on
15:54:52 <lambdabot> (*) `on` f = \x y -> f x * f y
15:55:50 <ivanm> pumpkin: so you have a laptop and a colaptop?
15:55:52 <ivanm> :p
15:55:56 <pumpkin> yeah :)
15:56:11 <ivanm> are they co-located together? :p
15:56:20 <pumpkin> sometimes, but not alwatys
15:56:42 <ivanm> so why two laptops rather than laptop + desktop?
15:56:43 <luqui> :t mparing
15:56:44 <lambdabot> Not in scope: `mparing'
15:57:04 <sheyll> in what module is comparing defined?
15:57:11 <ivanm> luqui: do you mean imparing? :p
15:57:12 <luqui> Data.Ord
15:57:14 <ivanm> @hoogle comparing
15:57:14 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
15:57:14 <lambdabot> Distribution.Simple.Utils comparing :: Ord a => (b -> a) -> b -> b -> Ordering
15:57:15 <yitz> @hoogle comparing
15:57:15 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
15:57:15 <lambdabot> Distribution.Simple.Utils comparing :: Ord a => (b -> a) -> b -> b -> Ordering
15:57:18 <sheyll> thanks
15:58:37 <yitz> imparing = (undefined `on`)
15:58:43 <sheyll> @type on
15:58:44 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
15:58:49 <ivanm> yitz: lol
15:59:18 <ivanm> > let impairing = (undefined `on`) in imparing succ 1 2
15:59:19 <lambdabot>   Not in scope: `imparing'
15:59:28 <ivanm> > let imparing = (undefined `on`) in imparing succ 1 2
15:59:29 <lambdabot>   * Exception: Prelude.undefined
15:59:39 <sheyll> uhm ... in what module do I find on?
15:59:45 <ivanm> sheyll: Data.Function
15:59:50 <sheyll> thank you
16:00:21 <Berengal> > ((+) `on` snd) ((),1) ((), 2)
16:00:22 <lambdabot>   3
16:00:28 <mle> ...what does imparing accomplish?
16:00:53 <Berengal> @type on undefined
16:00:55 <lambdabot> forall b c a. (a -> b) -> a -> a -> c
16:01:05 <ivanm> mle: absolutely nothing
16:01:13 <ivanm> it was a joke
16:01:23 <mle> Heh, okay
16:01:31 <ray> welcome to #haskell
16:01:39 <yitz> mle: it impairs your program from proceeding
16:01:40 <ivanm> ray: lol
16:01:57 <ivanm> yitz: well, if the thunk ever gets evaluated...
16:02:12 <yitz> ivanm: laziness strikes again
16:02:19 <ivanm> Haskell: we can't even guarantee your program won't run!
16:08:04 <hatds> Does this make sense? I have a top level, non-recursive function "f x = rhs" defined by 1 equation.  I compile with -prof -auto-all and also insert a manual cost center like so:    f x = {#- SCC ... -#}  rhs.  GHC tells me that f is entered once but that the manual SCC is entered 2000 times
16:09:15 <sm> does ghc require, use, fall back on something else without libgmp ? I just removed it from the system and can still link my app
16:09:28 <cizra> Hi. I'm trying to write the most general possible function type signature for a function that calculates the mean of a list as a rational number.
16:09:42 <cizra> Can I have the list of the Num type? Or must it be Fractional (divisible)?
16:09:55 <cizra> Will this one work? mean :: Fractional t => [t] -> Rational
16:10:21 <mauke> anything wrong with Fractional t => [t] -> t?
16:10:43 <cizra> Hm. Rationals are infinitely precise, while floats are not.
16:11:00 <cizra> What is the Fractional class, anyway?
16:11:06 <mauke> @src Fractional
16:11:06 <lambdabot> class  (Num a) => Fractional a  where
16:11:06 <lambdabot>     (/)             :: a -> a -> a
16:11:06 <lambdabot>     recip           :: a -> a
16:11:06 <lambdabot>     fromRational    :: Rational -> a
16:11:31 <hatds> you can't convert fractionals to Rationals, so you can't define a mean with the first sig
16:11:33 <sm> if someone with a vanilla mac (no extra libs installed with fink or macports) could try http://hledger.org/binaries/hledger-0.5.1+60-osx-leopard , I'd appreciate it
16:11:59 <cizra> hatds: What types can I convert into Rationals? Integrals only?
16:11:59 <Cale> http://www.iam.ubc.ca/theses/Brzustowski/brzustowski.html -- this was a fun thesis to read :)
16:12:14 <Cale> @src RealFrac
16:12:14 <lambdabot> class  (Real a, Fractional a) => RealFrac a  where
16:12:14 <lambdabot>     properFraction                   :: (Integral b) => a -> (b,a)
16:12:14 <lambdabot>     truncate, round, ceiling, floor  :: (Integral b) => a -> b
16:12:16 <Cale> @src Real
16:12:16 <lambdabot> class  (Num a, Ord a) => Real a  where
16:12:16 <lambdabot>     toRational      ::  a -> Rational
16:12:20 <Cale> There we are :)
16:12:22 <hatds> cizra: any real type can be converted to rational
16:12:37 <Cale> "Real" is a bad name for it
16:12:42 <Cale> But there you have it :)
16:13:02 * cizra is confused. Back to the first question, what's the most generic signature? With the two Fractionals?
16:13:18 <cizra> Would I gain any benefit at all by using Rationals?
16:13:24 <cizra> (precision, namely)
16:13:53 <hatds> data InvertibleMatrix = ... is a reasonable type to belong to the Fractional class
16:13:54 <Cale> To compute the mean, you need at least Fractional. Num won't do.
16:14:02 <Cale> Rational is more specific
16:14:19 <hatds> so you can't take a mean of Martices and return a Rational
16:14:45 <Cale> Actually...
16:14:48 <cizra> Ohh. I see. So, fractional it is.
16:14:56 <Cale> InvertibleMatrix isn't a reasonable instance of Num
16:15:05 <hatds> well besides that issue :)
16:16:59 <cizra> let mean lst = sum lst / (fromIntegral (length lst)) in mean [1, 2, 3]
16:17:08 <cizra> oops
16:17:11 <cizra> P let mean lst = sum lst / (fromIntegral (length lst)) in mean [1, 2, 3]
16:17:19 <cizra> Meh. sorry for the spam
16:17:22 <cizra> > let mean lst = sum lst / (fromIntegral (length lst)) in mean [1, 2, 3]
16:17:23 <lambdabot>   2.0
16:17:43 <cizra> > let mean lst = sum lst / fromIntegral . length $ lst in mean [1, 2, 3] -- why does this one not work?
16:17:44 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a] -> b
16:18:26 <mauke> because you can't divide by a function
16:18:52 <Saizan> that's parsed as (sum lst / fromIntegral . length) $ lst
16:18:53 <cizra> Oh, so / has at least equal to . precedence here.
16:19:18 <cizra> > let mean lst = sum lst / (fromIntegral . length $ lst) in mean [1, 2, 4]
16:19:19 <lambdabot>   2.3333333333333335
16:19:36 <cizra> > let mean lst = sum lst / (fromIntegral . length $ lst) in mean [1, 2, 4] :: Rational
16:19:38 <lambdabot>   7 % 3
16:20:03 <cizra> Hmm. How does this work? Does it first calculate a float, then try to approximate a Rational to it?
16:21:07 <mauke> no, it's all rationals
16:23:43 <yitz> cizra: how about Integral a => [a] -> Ratio a
16:25:34 <yitz> > let mean lst = sum lst % fromIntegral . length $ lst in mean [1, 2, 3]
16:25:35 <lambdabot>   Couldn't match expected type `a -> b'
16:25:49 <yitz> > let mean lst = sum lst % (fromIntegral . length $ lst) in mean [1, 2, 3]
16:25:50 <lambdabot>   2 % 1
16:27:06 <FliP^2eH> mhhh
16:27:26 <FliP^2eH> liftM (Number . read) $ many1 digit
16:27:35 <FliP^2eH> How can I convert that to the "do"-notation?
16:27:44 <FliP^2eH> No spoil, hints :)
16:28:12 <ivanm> @type many1
16:28:13 <lambdabot> Not in scope: `many1'
16:28:17 <FliP^2eH> Parsec
16:28:18 <ivanm> is many1 monadic?
16:28:22 <mauke> @src liftM
16:28:22 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
16:28:24 <ziman> well, looking at the source of liftM might be a spoiler :)
16:28:36 <FliP^2eH> Not for me
16:28:40 <FliP^2eH> I don't understand that source
16:28:54 <mauke> just as keikaku
16:29:35 <FliP^2eH> And yes, many1 is monadic
16:29:48 <pumpkin> hmm, how about a function (a -> (b -> c) -> c) -> (a -> (b -> c) -> c) -> a -> a -> (b -> b -> c) -> c
16:29:59 <pumpkin> @hoogle (a -> (b -> c) -> c) -> (a -> (b -> c) -> c) -> a -> a -> (b -> b -> c) -> c
16:29:59 <lambdabot> No results found
16:30:03 <pumpkin> didn't think so
16:30:15 <mauke> @djinn (a -> (b -> c) -> c) -> (a -> (b -> c) -> c) -> a -> a -> (b -> b -> c) -> c
16:30:15 <lambdabot> f a b c _ d = b c (\ _ -> a c (\ e -> d e e))
16:30:15 <ziman> @djinn (a -> (b -> c) -> c) -> (a -> (b -> c) -> c) -> a -> a -> (b -> b -> c) -> c
16:30:15 <lambdabot> f a b c _ d = b c (\ _ -> a c (\ e -> d e e))
16:30:27 <pumpkin> not sure I want the underscores :)
16:30:42 <pumpkin> but it isn't hard to write
16:30:48 <pumpkin> was just wondering if someone had made one
16:32:46 <uweDeportivo> looking at http://www.haskell.org/haskellwiki/HXT/Practical/Weather1, don't understand getWeather. what is proc and what is -<
16:33:00 <pumpkin> evil -XArrow stuff
16:33:06 <pumpkin> Arrows
16:33:50 <uweDeportivo> thought i understood arrows  and the gentle introduction to hxt
16:33:59 <cizra> :t { mean lst = sum lst % (fromIntegral . length $ lst) } ; :t mean
16:34:00 <lambdabot> parse error on input `{'
16:34:03 <pumpkin> well, that's special arrow syntax
16:34:08 <cizra> > { mean lst = sum lst % (fromIntegral . length $ lst) } ; :t mean
16:34:09 <lambdabot>   <no location info>: parse error on input `{'
16:34:13 <uweDeportivo> but cannot find anywhere a definition of proc and -<
16:34:15 <pumpkin> it just desugars to stuff from Control.Arrow
16:34:23 <cizra> yitz: Won't go, because the list members might be floats.
16:38:46 <cizra> > drop 1 [] -- why does this work? Shouldn't it give an undefined or something?
16:38:47 <lambdabot>   []
16:39:08 <mauke> @src drop
16:39:08 <lambdabot> drop n xs     | n <= 0 =  xs
16:39:08 <lambdabot> drop _ []              =  []
16:39:08 <lambdabot> drop n (_:xs)          =  drop (n-1) xs
16:39:11 <aavogt> > tail [] -- like this?
16:39:12 <lambdabot>   * Exception: Prelude.tail: empty list
16:39:39 <cizra> yea
16:40:18 <aavogt> > iterate tail [1..10]
16:40:19 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10],[2,3,4,5,6,7,8,9,10],[3,4,5,6,7,8,9,10],[4,5,6,7,8,...
16:40:28 <aavogt> > iterate tail [1..2]
16:40:29 <lambdabot>   [[1,2],[2],[],* Exception: Prelude.tail: empty list
16:42:40 <uweDeportivo> ok, http://www.haskell.org/haskellwiki/HXT/Practical/Simple1 explains it
16:42:49 <uweDeportivo> should have started there :-)
16:43:18 <hatds> drop makes sense the way it is, I think
16:43:49 <aavogt> > ($[1..3]) $ scanr1 (.) $ repeat tail
16:43:50 <lambdabot>   Couldn't match expected type `[t] -> b'
16:44:09 <aavogt> > map ($[1..3]) $ scanr1 (.) $ repeat tail
16:44:11 <lambdabot>   [* Exception: stack overflow
16:44:20 <aavogt> > map ($[1..3]) $ scanl1 (.) $ repeat tail
16:44:21 <lambdabot>   [[2,3],[3],[],* Exception: Prelude.tail: empty list
16:45:43 <aavogt> hatds: If it was the other way, I don't think people would complain /that/ much either.
16:45:55 <hatds> I might
16:47:18 <aavogt> yeah, I like it as is too, but maybe that's just how I learned it
16:51:32 <uweDeportivo> ok, so this explains it http://www.haskell.org/arrows/syntax.html
16:57:05 <aavogt> @hoogle replicate
16:57:05 <lambdabot> Prelude replicate :: Int -> a -> [a]
16:57:05 <lambdabot> Data.ByteString replicate :: Int -> Word8 -> ByteString
16:57:05 <lambdabot> Data.List replicate :: Int -> a -> [a]
16:57:21 <aavogt> @hoogle Int -> (m a) -> m [a]
16:57:22 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
16:57:22 <lambdabot> Text.ParserCombinators.ReadP count :: Int -> ReadP a -> ReadP [a]
16:57:22 <lambdabot> Prelude drop :: Int -> [a] -> [a]
16:58:11 <aavogt> @hoogle replicateA
16:58:11 <lambdabot> No results found
16:59:49 <mreh> anyone got any projects, I need the practice
17:01:39 <bos> hm
17:01:47 <Saizan> Cabal?
17:02:08 <Saizan> there are a lot of easy and medium tickets
17:02:12 <dcoutts> lots!
17:02:26 <mreh> :D
17:02:41 <hatds> why does MArray declare both a getNumElements and a getBounds method?
17:03:01 <roconnor> @type getBounds
17:03:02 <lambdabot> Not in scope: `getBounds'
17:05:07 <roconnor> where is getNumElements?
17:05:52 <hatds> http://www.haskell.org/ghc/docs/latest/html/libraries/array/src/Data-Array-Base.html#MArray
17:07:08 <roconnor> hatds: is that exported?
17:07:11 <uzytkownik> Hello. Is it possible to set encoding for handle?
17:07:44 <roconnor> uzytkownik: not yet :(
17:07:47 <roconnor> soon
17:10:03 <hatds> roconnor: hmm, guess not.  And you can't define an instance of MArray without defining it and a few others
17:10:45 <roconnor> Can we really export only some methods of a class?
17:11:20 <hatds> yea
17:11:22 <hatds> http://www.haskell.org/ghc/docs/latest/html/libraries/array/src/Data-Array-MArray.html
17:11:32 <hatds> apparently
17:11:38 <roconnor> that seems wrong
17:11:59 <hatds> MArray feels ugly :/
17:12:07 <aavogt> @hoogle ExitException
17:12:07 <lambdabot> Control.Exception ExitException :: ExitCode -> Exception
17:12:14 <roconnor> hatds: GHC's MArray
17:12:19 <hatds> but the functionality of MArray is fine
17:13:08 <hatds> I always get type sig problems when I have functions over MArrays
17:13:16 <roconnor> so can you make instances of a class if and only if all the methods are exported?
17:13:27 <roconnor> how does this work?
17:13:49 <hatds> yea, probably class method defaults come into play in general but not in this case
17:13:52 <SubStack> I was playing with DiffArray a bit last night
17:14:03 <SubStack> nice interface, but I suspect it's very hackish underneath
17:14:06 <roconnor> Haskell's module system is so confusing
17:14:18 * roconnor checks the haskell report
17:14:45 <aavogt> SubStack: slow?
17:14:51 <hatds> I really don't mind being stuck in IO in exchange for having an unboxed array.. I just want the typeclass and type sigs to play nicely
17:15:18 <SubStack> constant time updates and access, can't complain with that
17:15:19 <roconnor> I don't see why you have type sig problems
17:15:41 <roconnor> > maxBound :: Word
17:15:42 <lambdabot>   18446744073709551615
17:15:52 <roconnor> SubStack: ya but you are limited to 18446744073709551615 entries
17:16:13 <SubStack> that's fine for what I want to do
17:16:22 <roconnor> it's easy to be constant time when your asymtotic behaviour is to crash
17:16:41 <roconnor> 18446744073709551615 is good enough for anyone.
17:17:11 <SubStack> except for the programmer that has 18446744073709551616 items
17:17:36 <olsner> but since 18446744073709551615 is good enough for anyone, such a programmer doesn't exist :)
17:18:16 <aavogt> > succ maxBound :: Word
17:18:17 <lambdabot>   * Exception: Enum.succ{Word}: tried to take `succ' of maxBound
17:18:29 <roconnor> even after looking at the Haskell 98 report, I don't understand how class exports work
17:20:12 <Berengal> roconnor: Virally
17:20:26 <roconnor> no instances are viral
17:20:32 <roconnor> classes are different ... I think
17:21:11 <Berengal> You might have to import them directly
17:21:21 <hatds> what happens when you import a class from somewhere and it's methods from two other places?
17:21:36 <roconnor> can you make instances if and only if all class methods are in scope?
17:21:39 <hatds> will it let you declare an instnace?
17:21:45 <colton> What are some applications written in haskell?
17:21:54 <roconnor> colton: darcs
17:22:18 <roconnor> colton: ghc
17:22:26 <roconnor> colton: agda 2
17:22:37 <colton> Is haskell amenable to programming windowed applications (such as a qt application)?
17:22:41 <aavogt> roconnor: I've written instances without all methods in scope
17:23:05 <Berengal> colton: gtk2hs is pretty decent. There's a qt library as well, but I haven't used it
17:23:10 <roconnor> aavogt: did you have default methods for the rest?
17:23:22 <Berengal> Also, FRP libraries
17:23:29 <Berengal> (But I haven't touched them at all yet)
17:23:36 <roconnor> aavogt: or were you able to define methods that were not in scope?
17:24:29 <aavogt> roconnor: there were some methods left undefined, ghc isn't fully haskell 98 compliant in that respect though
17:24:46 <hatds> I guess my problem with type signatures is that you can't say this:  type MyMat a = IOUArray (Int,Int) a, modifyMat :: MyMat a -> IO (MyMat a)
17:25:55 <hatds> well, you can't if you want to use the MArray interface inside modifyMat
17:26:00 <roconnor> hatds: why not?
17:26:29 <hatds> it can't deduce the MArray context from the empty context
17:26:52 <roconnor> But IOUArray is an instance of MArray, right?
17:27:03 <roconnor> granted
17:27:13 <roconnor> MArray uses multi-parameter types.
17:27:14 <hatds> no
17:27:24 <hatds> only some types are instances
17:27:34 <roconnor> so I could believe there could be some type inference issues.
17:27:52 <roconnor> But you should be able to do some type annotations to solve your problems.
17:28:12 <roconnor> Could be tricky without Scoped type variables.
17:28:30 <roconnor> should be doable, though annoying
17:28:39 <roconnor> might as well turn on scoped type variables
17:29:03 <roconnor> ah
17:29:07 <roconnor> ``If no binding is given for some class method then the corresponding default class method in the class declaration is used (if present); if such a default does not exist then the class method of this instance is bound to undefined and no compile-time error results.
17:29:49 <hatds> not what ghc tells me
17:30:00 <roconnor> what does ghc tell you?
17:30:04 <hatds> ah wait doh
17:30:18 <hatds> it just gave a warning, but compiled
17:30:27 <roconnor> what warning?
17:30:46 <hatds> No explicit method nor default method for `Data.Array.Base.getNumElements'
17:31:04 <roconnor> hatds: what new instance are you making?
17:31:15 <hatds> I was testing it out
17:31:18 <roconnor> hatds: that strikes me as a serious serious warning.
17:31:20 <roconnor> ah okay
17:31:54 <roconnor> If I would defining HasCale, I'd be inclined to make that an error
17:31:54 <hatds> but I am trying to figure out how I want to create matrices that can be row-extended
17:32:41 <roconnor> do you do that the same way you make extendable arrays ?
17:32:57 <wli> R trees
17:33:25 <hatds> by allocating more than you need at the moment? yea
17:34:51 <roconnor> I was thinking by using a BraunSeq
17:34:56 <roconnor> j/k
17:35:01 <roconnor> I don't really know how I'd do it.
17:38:59 <hatds> without being able to declare MArray instances without warnings I guess I can't just wrap an (IORef array)
17:42:13 <Berengal> Awesome, I just wrote 'do drawForward; turnLeft; drawForward; turnRight; moveForward; drawForward' and it did as I expected
17:42:43 <Cale> Berengal: Now write an L-System expander :)
17:42:53 <Berengal> Cale: That's the next step
17:43:13 <Berengal> (I already have 'withRestoringState' for the recursive steps)
18:39:56 <Philippa> y'know, it amuses me that the lack of extensible records is finally biting me hard and /it's about parsing/
18:40:31 <Cale> Interesting :)
18:40:46 <Philippa> so, I have this small-but-growing pile of related languages...
18:40:57 <Philippa> which means that often I want to specify one in terms of another
18:41:13 <Philippa> "Foo is Bar but with operator syntax and the type annotations look like /this/"
18:41:45 <Philippa> so what I want is extensible records + open recursion. Or preferably, a module system that does functors and open recursion
18:41:55 <Philippa> but the record encoding's viable enough
18:42:00 <ivanm> Philippa: what's the significance of parsing when talking about extensible records?
18:42:23 <Philippa> ivanm: that's my use case
18:42:35 <Philippa> and it's not one where you'd expect the lack of extensible records to be pissing you off
18:42:35 <ivanm> then why the emphasis?
18:42:52 <jmcarthur> dang, just when i settled down to play with some statistics, the shootout is down :(
18:43:00 <Philippa> ivanm: Cale gets it
18:43:11 <Philippa> well, at least the amusement
18:43:15 <ivanm> what do you mean by "extensible" records? able to give it more fields?
18:43:22 <Philippa> Cale: you see where I'm coming from in terms of why I want it?
18:43:32 <Cale> I think so...
18:43:34 <pumpkin> 面白い
18:43:34 <Philippa> ivanm: plus structural subtyping on them, yeah
18:44:09 <ivanm> "structural subtyping"?
18:44:45 <Philippa> ivanm: based on the fields and their names. As opposed to nominal subtyping, as practiced by langs like Java
18:45:21 <ivanm> I didn't know Java had records...
18:45:21 <Philippa> ivanm: seems to me that you're really not at all familiar with the issue or its history here?
18:45:27 <ivanm> Philippa: nope ;-)
18:45:36 <ivanm> I just use haskell, I"m not a language theoretician :p
18:46:20 <Philippa> *nod*. Your tone initially read a little "why should this bother you?", is all
18:46:49 <ivanm> more "why should this bother you, in terms of what exactly _is_ this?" :p
18:48:05 <Philippa> yeah, well. Start with the latter first and you're less likely to get LARTed :-) It's a fairly infamous issue with Haskell, in that it's something the original committee deliberately ducked the issue on because the research wasn't done and we've been stuck with a system that arguably even langs like C would be embarrassed by
18:53:21 <ivanm> Philippa: I know that much (that the current record syntax is a compromise in terms of something that no-one hates too much)
18:53:43 <Philippa> no, that's not what it is
18:54:14 <ivanm> :o then what _is_ it?
18:54:23 <Philippa> it's a legacy system - not just syntax - that's there because there's a lot of options on where to go from there
18:54:30 <Philippa> and /then/ nobody's happy they know the right way to go
18:54:35 <Philippa> so it's not that nobody hates it
18:54:41 <Philippa> it's that there's no agreement on a successor
18:54:56 <ivanm> well, s/hate/disagrees with/
18:54:58 <SamB> I still say we should just pick one at random and try it ...
18:55:00 <Philippa> tbh, I was pretty POed that someone waded in with some really big stuff against the lexically scoped labels setup
18:55:16 * Philippa for now wants some agreed sugar in place with user-supplied record systems behind it
18:55:23 <Philippa> given that the lang's powerful enough for us to do that
18:55:42 <Philippa> mostly that means an agreed-on encoding of record kinds and a few other bits and pieces
18:55:42 <ivanm> "lexically scoped labels"?
18:56:01 <Philippa> ivanm: there was a paper. If you don't know what extensible records are, this is going to take a lot of explaining...
18:56:12 <ivanm> heh, OK, I"ll look up the paper later
19:02:06 <Cale> Philippa: I think I would like something like Daan's proposal, but with rather different-looking syntax
19:02:19 <Cale> (something more lens-like)
19:02:40 <Philippa> I think I've managed to miss the preferred syntax for lenses
19:02:43 <Philippa> (which is annoying!)
19:03:13 <pumpkin> is there a type for native-word-size signed integers?
19:03:34 <Cale> Oh, to be clear, I mean lens-like in the sense of the technique for referring to fields of records, rather than the things that go along with bananas and barbed wire :)
19:04:05 <Cale> So field labels would have various operations defined on them to turn them into polymorphic functions for acting on records
19:05:13 <Cale> get 'myLabel :: {'myLabel :: t | rho} -> t
19:05:15 <hatds> if I have f x y = let n = expensivefunc x in n*y and I partially apply f to one argument, would the resulting function still recompute 'expensivefunc x' for every y?
19:05:34 <Philippa> *nod*
19:05:37 <Cale> (I'm not sure if that syntax at the type level is really the best thing either)
19:06:00 <ivanm> hatds: yup
19:06:10 <Philippa> I'm convinced it's not, but hey
19:06:15 <ivanm> it's partial application, not partial evaluation
19:06:16 <Cale> hatds: You can try it, but I think in GHC even with optimisations the answer is yes.
19:06:19 <Cale> However...
19:06:30 <Cale> f x = let n = expensivefunc x in \y -> n*y
19:06:34 <Cale> Is a different matter
19:06:59 <Philippa> (I'd really like something flexible enough to let me define my own row kinds
19:07:03 <Philippa> )
19:07:18 <Saizan_> your own row kinds?
19:07:36 <Cale> That would be nice.
19:07:37 <Philippa> er, row types even
19:07:38 <Philippa> but yeah
19:07:53 <Philippa> Saizan_: imagine you wanted, say, extensible variants /with introspection/ or something
19:08:54 <Saizan_> uhm, i don't really see it
19:08:58 <Cale> Wait, row types?
19:09:11 <Cale> Or did you really mean kinds after all? :)
19:09:20 <Philippa> it's 3am, quite possibly
19:09:20 <Saizan_> so like being able to define an ADT and declare it extensible?
19:09:55 <Philippa> Saizan_: more like... being able to define extensible record or variants yourself, including with a /different definition to the usual one/
19:10:22 <Cale> I do think there should at least be some kind of support for variants.
19:10:32 <Saizan_> ah, i see
19:10:47 <Cale> Surely if we're going to do extensible products, not doing extensible sums as well would be a shame.
19:11:02 <Philippa> Saizan_: so you could define eg a heap for some abstract machine you're writing with labelled memory locations :-)
19:11:06 <Philippa> (or even just a stack...)
19:11:41 <Philippa> (Haskell: the world's finest assembler ;-)
19:11:42 <Cale> hmm
19:11:50 <mib_lpabdoxp> Is there a Haskell syntax for specifying strings containing multiple lines?
19:11:56 <Cale> I'm not sure how the polymorphic recursion would work out there :)
19:12:18 <Saizan_> i see a problem with how you'd get the values implemented
19:12:19 <Cale> mib_lpabdoxp: \n will put a newline into a string explicitly
19:12:45 <Cale> PetRat: Usually for the sake of prettiness, I use unlines
19:12:46 <PetRat> Cale: I'm thinking of the Python triple quote syntax..
19:12:47 <Saizan_> if you can provide your own definition for extensibility, i mean
19:12:49 <Philippa> Cale: so long as you can be polymorphic in what's behind you, you ought to be okay
19:12:56 <ivanm> PetRat: or else use "hi\<next line>\bye"
19:13:00 <mike-burns> PetRat: http://www.haskell.org/haskellwiki/Poor_Man%27s_Heredoc_in_Haskell
19:13:02 <Philippa> Saizan_: yeah?
19:14:28 <PetRat> I guess I'll try unlines
19:14:30 <Cale> There are a couple quasiquoter library implementations of here-documents on Hackage
19:14:53 <Saizan_> Philippa: e.g. with row types you basically extend unification to cope with reordering of labels, and then the implementation has to deal with values accordingly
19:14:54 <ray> what are their names?
19:15:07 <Saizan_> Philippa: and it's not so easy to make that efficient i gather
19:15:12 <Cale> http://hackage.haskell.org/packages/archive/Interpolation/0.2.4/doc/html/Data-String-Interpolation.html
19:15:30 <mmorrow> , let x = [0..3] in [$here|[0..3] is $([0..3]) and $(x)|]
19:15:32 <lunabot>  "[0..3] is [0,1,2,3] and [0,1,2,3]"
19:15:49 <Saizan_> Philippa: but if you can define your own criteria for equality of extensible types how does the implementation of values catch up?
19:16:22 <dancor> i'm using decodeFile to read a value then encodeFile to write to the same file.  there is a 'file busy' error due to laziness, what's the best way to fix
19:16:24 <Cale> http://hackage.haskell.org/packages/archive/interpolatedstring-qq/0.1/doc/html/Text-InterpolatedString-QQ.html
19:16:30 <Philippa> you'd need a) concrete implementation types somewhere, b) coercions and classes
19:16:46 <Philippa> odds are eventually you'd want c) piles of rewrite rules, but that's less immediately a problem
19:17:02 <Philippa> my assembler-of-doom can cope, for example
19:17:18 <mmorrow> dancor: you might have to close and reopen the file in between?
19:17:26 <mmorrow> s/file/Handle/
19:17:28 <ray> looks like it could be useful
19:17:48 <dancor> i guess i can't use the wrappers i've been using then
19:17:55 <mmorrow> dancor: doing that with shell redirection gets you an empty file..
19:18:13 <mmorrow> cat foo.txt > foo.txt
19:18:28 <Philippa> Saizan_: to put it another way, some things we're willing to wait for :-)
19:18:42 <Saizan_> Philippa: heh, i see :)
19:19:12 <mmorrow> heh, cat is too smart for that.. but this fools it
19:19:15 <Philippa> Saizan_: if you can have a typeful assembler, you can put up with it being O(N^2) in the number of known memory locations, no?
19:19:17 <mmorrow> cat foo.txt | cat > foo.txt
19:19:20 <dancor> A="`cat foo`"; echo lol"$A" > foo
19:19:28 <dancor> i'm using a variable in haskell as well you know :)
19:19:28 <Saizan_> Philippa: it seems like a way might be for GHC to allow relational extension of the "~" equality constraint
19:20:10 <Philippa> Saizan_: I don't think you'd even need that. Just lotsa class/instance stuff
19:20:36 <Philippa> I mean, OOHaskell already has to do this stuff, no?
19:20:46 <Saizan_> yes
19:21:33 <luqui> allowing powerful said extension while maintaining decidable typechecking would be a challenge
19:21:47 <Saizan_> but i'd like something less scary than that much of type hackery :)
19:22:16 <Philippa> it's probably worth re-encoding in type functions, see how that goes
19:24:03 <dancor> my problem here makes me think it would be nice to allow ! in more places
19:24:03 <Saizan_> i wonder if that's possible
19:25:05 <luqui> dancor, you mean like strict core?
19:25:46 <dancor> luqui: idk..
19:26:05 <pumpkin_> mmorrow: do you know if there's a native-sized signed word type?
19:26:15 <luqui> dancor, see the recent paper "types are calling conventions"
19:26:21 <luqui> it's a nice read
19:26:24 <dancor> ok
19:26:57 <dancor> i want    encodeFile binFilename (!val)   to evaluate val  before running encodeFile
19:27:03 <Saizan_> dancor: i'd read the file in as a strict bytestring probably, or rnf on the result of decodeFile
19:27:15 <luqui> dancor, oh, i thought you meant on types
19:27:33 <luqui> dancor, like, encodeFile binFilename $! val
19:27:38 <Saizan_> dancor: you can write rnf val `seq` encodeFile binFilename val
19:27:44 <luqui> > const 4 $! undefined
19:27:45 <lambdabot>   * Exception: Prelude.undefined
19:30:46 <roconnor> Anyone know why functions were part of the Eval class in Haskell 1.4?
19:33:02 <Saizan_> so that you could drive topologists mad?
19:33:17 <roconnor> that's the only reason I can think of.
19:33:42 <Cale> hm?
19:35:52 <Philippa> debugging?
19:36:07 <roconnor> does it help for debugging?
19:36:08 <dancor> odd, reading file strictly works but forcing evaluation with $! or even print doesn't
19:36:27 <Philippa> potentially, as it lets you poke inside evaluation order with HOFs a little
19:36:38 <dancor> is it possible that decodeFile leaves the file open even after the decoded result is fully evaluated
19:36:38 <Cale> Forcing the evaluation of a function is useful
19:36:41 <Philippa> think of it as a bit like tracing a join in a monad
19:36:48 <roconnor> Cale: explain
19:36:59 <Saizan_> dancor: which version of bytestring? there was a bug where it didn't close the handle promptly
19:37:05 <Cale> Consider something like... well, we had an example a little while back...
19:37:08 <Philippa> right, if you'd want to do it with SOFs then why not HOFs?
19:37:09 <Cale> f x = let n = expensivefunc x in \y -> n*y
19:37:25 <roconnor> SOFs?
19:37:30 <dancor> Saizan_: 0.9.1.4
19:37:35 <Philippa> er, brainfade
19:37:38 <Philippa> FOFs
19:37:40 <Philippa> (First...)
19:37:49 <Cale> hmm...
19:37:55 <Saizan_> dancor: ah, ok
19:38:34 <Cale> Well, that's not a good example.
19:38:35 <roconnor> Philippa:  I don't want seq to apply to any functions HOF or FOF.  Only to plain data.
19:38:38 <dancor> could be Binary's fault as well
19:39:28 <roconnor> Cale: do case analysis on n before picking a function to return.
19:39:29 <Cale> I would expect that seq puts functions into WHNF.
19:39:45 <Philippa> roconnor: POD which can be the result of...
19:40:02 <roconnor> a result of anything
19:40:15 <Cale> So if you partially apply things, it will actually do the work of substituting parameters into the body.
19:40:52 <roconnor> Cale: I don't think that amounts to any work in GHC's implementation.
19:41:06 <Cale> It can result in memory being freed, I'm pretty sure.
19:41:23 <Cale> Imagine if you have a function which pattern matches on a pair, but only the first component of the pair occurs in the body
19:41:25 <roconnor> Cale: I'd like to see an example.
19:41:40 <Cale> Or a list, but only the first element of the list is used, and the remainder discarded.
19:41:45 <Saizan_> if you had something like f x = case x of .. -> \y -> ..; .. -> \y -> ..; then seq'ing (f x) would reduce that case expression
19:42:01 <roconnor> Saizan_: that I buy
19:42:28 * roconnor sighs
19:42:36 <roconnor> I can almost see that as being useful
19:42:47 <roconnor> Although I really clear practical example would still be nice.
19:42:53 <roconnor> a really clear
19:43:04 <Cale> I can only think of clear impractical examples ;)
19:43:35 <roconnor> Saizan_: does pattern matching translate into code like that?
19:43:36 <Saizan_> i can only imagine you could solve a space leak or something like that
19:43:52 <Cale> let f (x,y) z = x^2 + z in Just (f (5, somethingMemoryExpensive))
19:43:53 <roconnor> Saizan_: solving a space leak would make me happy
19:44:21 <Cale> cf. let f (x,y) z = x^2 + z in Just $! f (5, somethingMemoryExpensive)
19:44:22 <roconnor> Cale: no good.
19:44:31 <roconnor> oh
19:44:47 <roconnor> has soemthingMemoryExpensive already been evaluated, making it memory expensive?
19:44:51 <Cale> yes
19:44:54 <roconnor> hmm
19:45:23 * Saizan_ wonders what ghc does there
19:46:10 <Saizan_> i'm afraid it'll wait another parameter to do any reduction
19:46:21 <Cale> Saizan_: even if seq is applied?
19:46:23 <Philippa> it might do :-(
19:46:54 <Philippa> though I don't think it would - it'd take a further transformation in the core to enable that, wouldn't it?
19:46:56 <SamB> the best way to test would involve somehow sticking a _|_ in there, wouldn't it ...?
19:47:05 <Saizan_> Cale: yeah, but i'm just guessing, maybe f (x,y) = \z -> will work
19:47:19 <Cale> Saizan_: Yes, if not this, then surely that would have to.
19:47:53 <roconnor> you are saying that  f (x,y) = \z  and  f (x,y) z =  would behave diffently under seq in GHC?
19:48:31 <Cale> I forget what exactly it was, but there's something confusing of that sort.
19:48:45 <Cale> But I don't think it's that.
19:49:36 <Cale> Certainly, if you have a function RHS which consists of a let/in, then moving a parameter to inside of the 'in' expression can make a difference.
19:50:23 <roconnor> > let f (x,y) z = x^2 + z in isJust (Just (f undefined))
19:50:24 <lambdabot>   True
19:50:29 <roconnor> > let f (x,y) z = x^2 + z in isJust (Just $! (f undefined))
19:50:31 <lambdabot>   True
19:50:42 <roconnor> :^)
19:50:48 <Saizan_> http://haskell.org/haskellwiki/GHC:FAQ#When_can_I_rely_on_full_laziness.3F <- related
19:51:24 <Cale> Compare the performance of:
19:51:25 <Cale> let f x y = let z = product [1..x] in z + y in map (f 10000) [1,2,3,4,5]
19:51:30 <Cale> let f x = let z = product [1..x] in \y -> z + y in map (f 10000) [1,2,3,4,5]
19:51:31 <Saizan_> > let f (x,y) = \z -> x^2 + z in isJust (Just $! (f undefined))
19:51:32 <lambdabot>   * Exception: Prelude.undefined
19:51:47 <Cale> Nice.
19:51:48 <dancor> my strictness problem was actually a problem with Just a vs a in the type being read
19:51:51 <roconnor> AHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH!!!!!!!!!!!!!!!!!!!!!!!!
19:51:59 <roconnor> that's it
19:52:02 <roconnor> I'm through with GHC
19:52:03 <dancor> very tricky..
19:52:04 <Cale> hehe
19:52:23 <Cale> I think Haskell may actually be specified that way.
19:52:34 <roconnor> really?
19:52:51 <roconnor> in that case I'm through with Haskell
19:52:57 <Cale> At least as far as the semantics goes.
19:53:16 * roconnor sudo aptitude install hugs
19:53:42 <Saizan_> the report makes a distinction between \x y -> and \x -> \y -> ?
19:54:00 <Cale> Data.Maybe> let f (x,y) = \z -> x^2 + z in isJust (Just $! (f undefined))
19:54:01 <Cale> Program error: Prelude.undefined
19:54:01 <Cale> Data.Maybe> let f (x,y) z = x^2 + z in isJust (Just $! (f undefined))
19:54:01 <Cale> True
19:54:09 <Cale> It happens in hugs too :)
19:54:26 <roconnor> arrrrrrrrrgggggggghhhhhhhhhhhhh!!!
19:54:43 <dancor> isn't that what $! means
19:54:58 <Cale> dancor: Note that $! occurs in both
19:55:12 <dancor> oooooh
19:55:12 <Cale> dancor: The only difference is which side of the = the parameter occurs on.
19:55:41 <Cale> This is a very old complaint.
19:55:51 <roconnor> it is?
19:56:02 <Cale> I'm not exactly sure why nothing has been done about it.
19:56:07 <Cale> Yeah...
19:56:26 <SamB> what #?
19:56:31 <Saizan_> the "types are calling conventions" paper deals with this, i think?
19:56:48 <roconnor> Now I want to find where it says this in the haskell report
19:57:52 <ivanm> roconnor: cya, we'll miss you
19:57:53 <ivanm> ;-)
19:58:17 <hatds> since the report doesn't specify dynamic semantics, would it talk about seq?
19:58:27 <Saizan_> however when compiled functions like f should get inlined, so you won't see the difference
19:58:53 <Saizan_> it doesn't have a formal semantics, but it does specify some
19:58:59 <roconnor> Saizan_: I thought everyone here was about optimizations not changing semantics!
19:59:42 <Saizan_> heh, right :)
19:59:46 <roconnor> Cale: are you suggesting this is a bug in both GHC and Hugs?
19:59:58 <hatds> no, it's correct right?
20:00:01 <Cale> Oh, interesting, it could actually be a bug. The report seems to contradict it.
20:00:07 <hatds> where?
20:00:16 <Cale> Translation:
20:00:17 <Cale> The general binding form for functions is semantically equivalent to the equation (i.e. simple pattern binding):
20:00:17 <Cale> x = \ x1 ... xk -> case (x1, ..., xk) of
20:00:17 <Cale> (p11, ..., p1k) match1
20:00:17 <Cale> ...
20:00:18 <Cale> (pn1, ..., pnk) matchn
20:00:20 <Cale> where the xi are new identifiers.
20:00:58 <Saizan_> does it also say that \ x1 .. xk -> is the same as \ x1 -> ... \ xk -> ?
20:01:09 <roconnor> Cale:  ah, I was about to paste that
20:02:25 <Cale> Saizan_: oh, good point
20:02:53 <Cale> > let f = \(x,y) z -> x^2 + z in isJust (Just $! (f undefined))
20:02:54 <lambdabot>   True
20:02:59 <Cale> :)
20:03:03 <Cale> > let f = \(x,y) -> \z -> x^2 + z in isJust (Just $! (f undefined))
20:03:05 <lambdabot>   * Exception: Prelude.undefined
20:04:30 <Cale> Translation:
20:04:30 <Cale> The following identity holds:
20:04:30 <Cale> \ p1 ... pn -> e 	= 	\ x1 ... xn -> case (x1, ..., xn) of (p1, ..., pn) -> e
20:04:30 <Cale> where the xi are new identifiers.
20:04:35 <Cale> aha
20:04:39 <Cale> So there you have it
20:05:11 <roconnor> Cale: that doesn't say anything about if \x -> \y -> foo is the same as \x y -> foo
20:05:24 <roconnor> Cale: that is only talking about patterns in lambda bindings
20:06:01 <roconnor> or does this have some bearing on the issue at hand
20:06:05 <Cale> roconnor: It means that multiple parameter lambdas of this sort act semantically as if they take one parameter which is a tuple
20:06:30 <roconnor> Cale: I think you are misreading that.
20:06:34 <Cale> Er, hmm, perhaps
20:06:36 <Cale> Yeah.
20:07:57 <roconnor> but I see no evidence that \x y -> foo is the same as \x -> \y -> foo
20:08:24 <roconnor> It does seem that formally \x y -> foo is *one* lambda expressions
20:08:27 <roconnor> It does seem that formally \x y -> foo is *one* lambda expression
20:09:26 <hatds> does the report specify the behavior of seq?
20:09:48 <roconnor> seq _|_b = _|_
20:09:49 <roconnor> seq a b = b, if a /=_|_
20:09:56 <roconnor> that's all it says
20:10:23 <roconnor> now I wish Haskell had formal semantics
20:10:31 <roconnor> so I could say GHC and Hugs are wrong.
20:10:37 <dibblego> hpaste broek
20:10:45 <SamB> roconnor: you don't need those to do that
20:10:52 <Saizan_> @hpaste
20:10:52 <lambdabot> Haskell pastebin: http://hpaste.org/new
20:10:56 <roconnor> I think I'd argue at this point that the Haskell Report is underspecified on this issue.
20:10:59 <SamB> you can, in fact, say that hugs, GHC, *and* Haskell 98 are wrong
20:11:04 <SamB> all at the same time!
20:11:05 <Saizan_> mmorrow: ping, hpaste is broken!
20:11:35 <roconnor> SamB: I don't think H'98 actually says what these two programs are supposed to do.
20:12:32 <SamB> roconnor: well, that could be a way in which it is wrong
20:12:37 <SamB> or then again maybe it isn't!
20:12:38 <roconnor> true
20:12:54 <roconnor> It talks about _|_ for function types without really saying what the CPO is.
20:13:14 <roconnor> and how haskell functions relate to that CPO
20:20:37 <roconnor> I guess the question is, are \a b -> foo and \a -> \b -> foo different members of the type (a -> b -> c).
20:20:48 <roconnor> I think the report doesn't answer this question.
20:21:01 <SamB> I was always under the impression that those were supposed to be identical ...
20:21:42 <roconnor> one certainly is told that a lot;  however most of what we are told turns out to be false in the presence of seq.
20:23:19 <roconnor> actually what is worse is that this means that ((\a b -> foo) 5) and (\b -> let a = 5 in foo) are different in GHC.
20:23:19 <Cale> Is it really false?
20:23:31 <roconnor> is what false?
20:23:40 <Cale> "however most of what we are told turns out to be false in the presence of seq."
20:24:00 <roconnor> no it's true.  That's why I said that quote. :)
20:24:55 <roconnor> Cale: I don't think I understood you
20:25:22 <roconnor> we are often told that \a b -> foo and \a -> \b -> foo are the same, and this is false because of seq.
20:25:27 <Cale> Perhaps I misunderstood. Did you find an actual mistake in the report?
20:25:30 <Cale> ah
20:25:35 <Saizan_> well, seq is only a way to see this, you could observe the behaviour by differences in performance
20:25:58 * roconnor cannot observe preformance :P
20:26:08 <Cale> I think that perhaps it's actually for the best, given that we have seq, that (\x y -> ...) and (\x -> \y -> ...) are different
20:26:25 <Cale> It gives us the most freedom of expression in that regard.
20:26:49 <Saizan_> it also forces us to think which is best to use
20:26:58 <Saizan_> fsvo forces
20:27:15 <dibblego> what example shows their difference?
20:27:29 <Cale> > let f (x,y) z = x^2 + z in isJust (Just $! (f undefined))
20:27:30 <lambdabot>   True
20:27:31 <Cale> > let f (x,y) = \z -> x^2 + z in isJust (Just $! (f undefined))
20:27:32 <lambdabot>   * Exception: Prelude.undefined
20:27:56 <dibblego> ah of course
20:28:05 <Cale> or...
20:28:12 <Cale> > let f = \(x,y) z -> x^2 + z in isJust (Just $! (f undefined))
20:28:13 <lambdabot>   True
20:28:17 <Cale> > let f = \(x,y) -> \z -> x^2 + z in isJust (Just $! (f undefined))
20:28:18 <lambdabot>   * Exception: Prelude.undefined
20:28:27 <roconnor> I'd like to see some formal semantics for haskell ...
20:28:34 <Cale> roconnor: It used to exist...
20:28:54 <roconnor> before seq?
20:28:59 <Cale> Probably.
20:29:00 <Cale> There's one for a very early Haskell, iirc.
20:29:02 <roconnor> :)
20:29:14 <Cale> But it went out of date and wasn't maintained.
20:29:29 <Saizan_> without typeclasses?
20:29:46 <Cale> http://haskell.org/haskellwiki/Language_and_library_specification
20:29:51 <Cale> very bottom of that page
20:30:25 <roconnor> am I talking about dynamic or static semantics?
20:31:19 <Saizan_> dynamic
20:31:30 <roconnor> hmm
20:31:36 <Saizan_> static is the type system, no?
20:31:45 <roconnor> the abstract says the dynamic semantics come after the static semantics.
20:31:49 <Cale> Actually, the two cover a lot of the same ground.
20:31:51 <roconnor> this could be in either one.
20:32:03 <roconnor> but I should start with the static semantics
20:32:19 <Cale> seq is not mentioned
20:32:22 <roconnor> it might "statically" translate \a b ->  into \a -> \b ->
20:32:45 <Saizan_> uhm, that's true
20:33:10 <Saizan_> considering the target language might not have n-ary lambdas
20:33:55 <Cale> Somehow I doubt either will give a clear answer, as seq wasn't around
20:33:58 <jbauman> that's generally different from the traditional "static" semantics, isn't it?
20:34:42 <Cale> and case expressions can't force the evaluation of functions...
20:34:55 <Cale> at least, I don't think they can
20:35:16 <SamB> Cale: you can't case over a function, no!
20:35:34 <Saizan_> i guess they don't mention strict fields either?
20:35:35 <Cale> Well, you can write  case foo x of f -> ...
20:35:45 <SamB> well, sure
20:35:48 <SamB> but it doesn't DO anything
20:35:50 <Cale> Where maybe foo has two parameters
20:35:57 <Cale> right, well, we hope :)
20:39:31 <roconnor> > case const 5 of {_ -> 7}
20:39:32 <lambdabot>   7
20:39:37 <roconnor> :)
20:40:06 <roconnor> > case const 5 of {f -> 7}
20:40:07 <lambdabot>   7
20:40:10 <roconnor> > case const 5 of {f -> f 7}
20:40:12 <lambdabot>   5
20:40:21 * roconnor shakes his head
20:40:26 <roconnor> oh
20:40:36 <roconnor> I guess that case expression is translated away
20:41:27 <roconnor> > case const 5 of {f -> f 7; g -> g 8}
20:41:28 <lambdabot>   5
20:41:36 <roconnor> > case id of {f -> f 7; g -> g 8}
20:41:37 <lambdabot>   7
20:41:49 <Cale> > case undefined of f -> 1
20:41:50 <lambdabot>   1
20:42:01 <Cale> > case undefined :: Integer -> Integer of f -> 1
20:42:02 <lambdabot>   1
20:42:02 <roconnor> > case undefined of {f -> f 7; g -> g 8}
20:42:03 <lambdabot>   * Exception: Prelude.undefined
20:42:07 <rick_2047> can i do something like this --> args <- getArgs read (args !! 0)
20:42:31 <roconnor> Cale: strange
20:42:42 <gwern> rick_2047: a newline between getArgs and read?
20:42:46 <rick_2047> ya
20:42:48 <rick_2047> gwern, ya
20:42:51 <gwern> seems reasonable
20:42:52 <Cale> rick_2047: args <- fmap (head . read) getArgs
20:42:59 <Cale> er
20:43:04 <gwern> as long as your read is being forced to an appropriate type
20:43:14 <Cale> not quite reasonable, because you'd have to be reading an IO action
20:43:30 <rick_2047> Cale, ya thats what the error says
20:43:31 <gwern> Cale: don't confuse beginners with your fmap stuff!
20:43:37 <rick_2047> Cale, so how do i fix it??
20:43:41 <Cale> but you can write
20:43:45 <gwern> Cale: and he has the right idea, he just needs the right incantation of monad operators
20:43:46 <ray> don't confuse beginners with your fmap-free stuff!
20:43:47 <Cale> args <- getArgs
20:43:57 <ray> haskell is about FUNCTORS
20:43:58 <Cale> let firstArg = read (args !! 0)
20:44:03 <gwern> every beginner starts with problems getting the monads just right
20:44:07 <Cale> ... something which does something with firstArg ...
20:44:17 <gwern> lordy how many errors I ran into in the io monad
20:44:31 <rick_2047> wait wait i will give u my code
20:44:37 <rick_2047> and u tell the fix only then
20:44:41 <Cale> rick_2047: Each line of an IO do-block must evaluate to an IO action
20:45:03 <Cale> rick_2047: If you want to print the first arg for example, you could write  print firstArg  after that
20:45:32 <Cale> But firstArg itself is not going to be an IO action -- it'll be an integer, or whatever type you want to parse using read.
20:45:46 <rick_2047> Cale, my aim is to make a program which accepts two numbers from command line and add them
20:45:50 <Cale> (There's no instance of Read for IO actions)
20:45:53 <Cale> okay
20:46:04 <jbauman> rick_2047, what do you want to do with them once you add them?
20:46:15 <rick_2047> jbauman, just display them
20:46:22 <gwern> jbauman: oh nothing. so it'll compile down to a really small executable!
20:46:37 <jbauman> gwern, it still has to fail if it doesn't have enough args
20:46:42 <jbauman> that should bloat it a bit
20:46:44 <Cale> main = do [x,y] <- getArgs; print (read x + read y)
20:46:53 * gwern didn't say it'd compile down to the smallest legal ELF binary
20:47:01 <rick_2047> http://pastebin.com/m3992eef4
20:47:07 <rick_2047> this is what i did initially
20:47:24 <Cale> rick_2047: right, that last line is a number
20:47:26 <ray> hmm i don't have the smallest legal ELF binary in my goodies directory
20:47:31 <Cale> rick_2047: which is unacceptable
20:47:35 <jbauman> rick_2047, see, that doesn't actually attempt to print anything
20:47:45 <Cale> rick_2047: You want to tell it to do something with that number :)
20:47:55 <Cale> (like print it)
20:48:03 <rick_2047> Cale, ok lemme try
20:48:28 <roconnor> > case undefined :: Bool -> Bool of {f -> 7; g -> 8}
20:48:29 <lambdabot>   7
20:48:40 <roconnor> > case undefined :: Bool of {f -> 7; g -> 8}
20:48:41 <lambdabot>   7
20:48:48 <Cale> roconnor: The first pattern is irrefutable and will always match
20:48:51 <roconnor> > case undefined :: () of {f -> 7; g -> 8}
20:48:52 <lambdabot>   7
20:48:57 <roconnor> > case undefined of {f -> 7; g -> 8}
20:48:58 <lambdabot>   7
20:49:23 <roconnor> ah oops
20:49:32 <gwern> rick_2047: one of the amusing things about lazy evaluation is that it forced the great programming language shootout to revise all its benchmarks
20:49:33 <roconnor> I misunderstood a previous result
20:49:43 <rick_2047> http://pastebin.com/d6bd320ad <-- i changed it to this but still gives errors
20:49:53 * Cale has a look
20:50:10 <gwern> if you ask for only one answer, it computes you only one answer; you ask for nothing, and it does nothing
20:50:19 <Cale> rick_2047: Now you're adding print read (args !! 0)  to   read (args !! 1)
20:50:25 <Cale> rick_2047: You need some parens :)
20:50:54 <Cale> (or a $ after print)
20:50:58 <jbauman> haskell should be able to determine the location of the parens by the types :)
20:51:22 <jbauman> (as a plus, when you have bugs, that would cause really exciting bugs)
20:51:52 <rick_2047> Cale, whats wrong with adding read (args !! 0 ) to read (args !! 1) both i think are numbers??
20:51:56 <SamB> gwern: if only they'd been content to make it fair :-(
20:51:59 <gwern> jbauman: I think that's a little sufficiently smart...
20:52:28 <Cale> rick_2047: you're not doing that... it parses as  (print read (args !! 0)) + (read (args !! 1))
20:52:52 <jbauman> gwern, it just has to try every possible location and see which one typechecks
20:53:09 <gwern> ~_~ sounds exponential
20:53:11 <jbauman> avoiding exponential compile times is left as an exercise for the implementer
20:53:28 <Cale> There are two things which are wrong with that: print only takes one parameter, and even if it did take two, it produces something which isn't a number, and so can't be added to (read (args !! 1))
20:53:57 <Cale> rick_2047: Is that clear?
20:53:58 <SamB> Cale: not to mention it's nothing like what he meant!@
20:54:03 <Cale> SamB: right :)
20:54:10 <rick_2047> Cale, ya got it working
20:54:18 <gwern> I'd say you haven't shown it'll make code easier to write or more comprehensible; it sounds like as bad an idea as a compiler that works by genetic algorithms, and stops when it has a compiled binary which is 'sufficiently' correct
20:54:21 * rick_2047 blesses community again
20:54:52 <jbauman> gwern, it would have made rick_2047's code compile to what he wanted...
20:55:29 <SamB> gwern: but would it be as slow ?
20:55:53 * rick_2047 thinks most compilers presume that you know what you are doing which is seldom true for a novice
20:55:53 <jbauman> unfortunately, if you had the wrong types in your code it might accidentally compile to something you really didn't want
20:56:04 <Cale> melodia: ハスケルに興味があるの？
20:56:20 <gwern> SamB: I mean a non-correctness-preserving compiler is just a bad idea :)
20:56:40 <gwern> and a compiler that guesses what you wants and goes with the first consistent guess is non-correctness-preserving imo
20:57:36 <SamB> note that I'm just kidding around and do not think that either thing is useful
20:58:21 <jbauman> same here
20:58:48 <gwern> eh. doesn't matter. is bedtime here anyways
21:00:24 <melodia> ケール〜(ハ-∀-)、 いや、ちょっと見ようと思ってたんだけなんですよ．しかし、日本語で話していいんですか
21:01:50 <SamB> melodia: uh, abhout all I got from that is that you have a pair of parens, a forall, two commas, and a period ...
21:01:59 <SamB> er. three commas.
21:02:10 <monochrom> I wonder what's forall doing there :)
21:02:19 <BMeph> Lazy (LAY-zee) n. The characteristic of doing only one's own work. ;)
21:02:39 <Cale> いいと思うよ。
21:02:58 <SamB> melodia: oh, and of course I assume the rest is in japanese
21:03:23 <SamB> with a mixture of kanji and hiragana
21:03:28 <Cale> The forall is part of a funny Japanese-style smiley :)
21:03:45 <SamB> Cale: is that kosher with JIS ?
21:03:58 <Cale> This is all in unicode anyway...
21:04:03 <SamB> true!
21:04:24 <SamB> but I'd expect japanese styles to be based on the JIS characters
21:04:41 <Cale> Well, they seem to use it a lot, so I suspect it's fine.
21:05:44 <SamB> huh. I don't seem to have decent full-width versions of all of those kana for my terminal ...
21:06:16 <SamB> or the dashy things either
21:08:42 <SamB> in particular, the glyphs in "ケール〜ハ" all seem to take up only the left cell of a two-cell character ...
21:08:51 <Cale> odd
21:09:11 <SamB> I guess urxvt couldn't find appropriately-sized glyphs ???
21:09:29 <SamB> at least not in any of the configured fonts
21:10:27 <Cale> I use gnome-terminal (and XChat for IRC)
21:10:28 <SamB> now, "、．" are the same, but that's kind of to be expected ;-)
21:10:33 <SamB> I use x-chat too
21:10:47 <SamB> I just pasted the characters into urxvt to see what they'd look like
21:11:11 <SamB> I think it even has one of the kanji anti-aliased, which looks bad :-(
21:11:31 <SamB> this one: 思
21:13:19 <SamB> now, it couldn't very well render those characters at one-cell wide, since it's supposed to match the wcwidth function ...
21:14:08 <SamB> (though how that's supposed to work if the terminal and the libc are on opposite sides of an SSH connection, I'm not sure, since I don't think there's any standard about the widths per-se ...)
21:14:34 <SamB> (... though with JIS-derived characters there's really only one right way to do it)
21:21:55 <dancor> i'm using urxvt with -fn '8x13,xft:Biwidth'
21:22:03 <dancor> the characters all look correct to me
21:22:14 <dancor> but i wouldn't know for sure :)
21:22:26 <dancor> those katakana were biwidth anyway
21:22:40 <dancor> SamB: ^^^
21:23:08 <SamB> dancor: well, in my xchat they show up full-width
21:23:35 <ray> jis has forall
21:23:48 <dancor> i'm using xorg/urxvt/screen/ssh/screen/irssi :)
21:23:50 <SamB> and in my urxvt the glyphs might actually extend just *past* the left half-cell
21:24:49 <SamB> hmm, I'm using:
21:25:00 <SamB> URxvt.font:	-misc-fixed-medium-r-semicondensed--13-120-75-75-c-60-iso10646-1, [codeset=JISX0208]xft:Kochi Gothic:antialias=false
21:25:00 <SamB> URxvt.print-pipe:	lpr -P pam_old/urxvt
21:25:00 <SamB> URxvt.reverseVideo:	true
21:26:44 <dancor> screen-connecting from a separate   -fn '8x13,xft:Kochi Gothic'  term looks fine too
21:27:01 <bos> why are we obsessing over japanese characters in here?
21:31:22 <SamB> bos: someone left a message here which none of us could actually read
21:31:58 <SamB> at least, if somone could, they haven't bothered to translate ...
21:32:35 <bos> new API for encoding errors in Data.Text: http://pastebin.com/m4177334f
21:33:04 <bos> both hpaste.org and paste.lisp.org are hosed
21:33:18 <bos> teh internets haz runned outta paste
21:33:46 <SamB_XP> bos: codepad.org ?
21:33:55 <SamB_XP> that has not only paste, but crash!
22:04:57 <roconnor> @src const
22:04:57 <lambdabot> const x _ = x
22:11:39 <roconnor> > let f a = \z -> case a of {(x,y) -> x} in null (return $! (f undefined))
22:11:40 <lambdabot>   False
22:11:48 <roconnor> > let f a = case a of {(x,y) -> \z -> x} in null (return $! (f undefined))
22:11:49 <lambdabot>   * Exception: Prelude.undefined
22:11:59 <roconnor> Cale: this is starting to make sense to me
22:12:45 <roconnor> I think \x -> \y -> foo is only distinguishable from \x y -> foo when x and y have patterns.
22:15:40 <dmwit> ?where report
22:15:41 <lambdabot> http://www.haskell.org/onlinereport/
22:17:05 <roconnor> and they are distinguishable because in one case a case statement is stuck between the lambdas, and in the other case the case statement is put after all the lambdas.
22:17:54 * roconnor reconciles with Haskell
22:18:22 <Jebdm> What do you mean?
22:18:39 <Jebdm> roconnor: They should be equal, even with patterns
22:18:46 <roconnor> > let f (x,y) z = x in null (return $! (f undefined))
22:18:47 <lambdabot>   False
22:18:53 <roconnor> > let f (x,y) = \z -> x in null (return $! (f undefined))
22:18:54 <lambdabot>   * Exception: Prelude.undefined
22:19:10 <roconnor> > let f = \(x,y) z -> x in null (return $! (f undefined))
22:19:11 <lambdabot>   False
22:19:17 <roconnor> > let f = \(x,y) -> \z -> x in null (return $! (f undefined))
22:19:18 <lambdabot>   * Exception: Prelude.undefined
22:19:34 <akafubu> is cabal-install not part of the debian package ghc6?
22:19:57 <Jebdm> that's strange
22:20:19 <dmwit> It's not too strange.
22:20:21 <akafubu> is it? i don't know
22:20:22 <roconnor> Jebdm: it has to do with how patterns in lambda are transformed into case statements
22:20:29 <akafubu> oh, not to me
22:20:36 <dmwit> Imagine not having patterns in lambdas, and how you would convert that into a case statement.
22:20:54 <dmwit> The naive way is just different for multi-parameter lambdas and multiple single-parameter lambdas, that's all.
22:21:02 <roconnor> \(x,y) z -> x  becomes \a b -> case (a,b) of {((x,y), z) -> x}
22:21:05 <roconnor> while
22:21:05 <Jebdm> roconnor: Cleary; I just didn't expect it == I didn't think about it
22:21:28 <roconnor> \(x,y) -> \z -> x  becomes \a -> case a of {(x,y) -> \z -> x}
22:22:06 <Jebdm> I just would've expected Haskell to be extra-careful to preserve the currying semantics
22:22:38 <roconnor> haskell's semantics are a little bit strange.
22:23:01 <roconnor> > case id of {f -> f 7}
22:23:02 <lambdabot>   7
22:23:34 <akafubu> i just got through installing the package parsec47 and still, the cabal-install bootstrap.sh says it needs parsec "but isn't installed"
22:23:35 <Jebdm> huh
22:24:21 <roconnor> Jebdm: apparently you can do case analysis on functions so long as you don't use patterns in the cases.
22:24:22 <dmwit> akafubu: What does ghc-pkg list parsec say?
22:25:08 <akafubu> dmwit: /usr/lib/ghc-6.8.2/package.conf:
22:25:13 * roconnor will remember that for the next Obfuscated Haskell programming contest
22:25:20 <dmwit> akafubu: Sounds like you didn't get it installed, then. =P
22:25:25 <dmwit> akafubu: How did you install it?
22:25:42 <akafubu> dmwit: apt-get install parsec47
22:25:43 <dmwit> akafubu: Also, how did you manage to not have parsec?  Isn't it in the base distribution of GHC?
22:26:05 <akafubu> dunno, i'm new to this stuff, hoping you guys/gals know
22:26:14 <dmwit> akafubu: parsec47 doesn't sound like a Haskell thing...
22:26:21 <dmwit> Parsec is up to only version 3.0.0.
22:26:32 <Jebdm> dmwit: i don't think it is
22:26:36 <akafubu> parsec47 - retromodern hispeed shmup ...ah, a game
22:26:49 <Jebdm> it's in the "Haskell Platform", but not GHC
22:27:02 <Jebdm> AFAIK
22:27:13 <akafubu> is cabal-install going to be part of the ghc package anytime soon?
22:27:42 <Jebdm> oh, shit, i was thinking of cabal
22:27:44 <Jebdm> d'oh
22:27:50 <Jebdm> parsec is
22:28:21 <Jebdm> it's just listed in a funny place (not as specified in the Parsec docs themselves)
22:29:24 <Jebdm> Text.ParserCombinators.Parsec
22:29:32 <Jebdm> http://www.haskell.org/ghc/docs/latest/html/libraries/parsec/Text-ParserCombinators-Parsec.html
22:30:36 <akafubu> i can't even find the download site for parsec
22:30:55 <dmwit> ?hackage parsec
22:30:55 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/parsec
22:31:53 <akafubu> just found it
22:32:11 <akafubu> dmwit: thanks for the link, that would have saved 2-3 secs
22:33:34 <akafubu> to execute the .hs file, i do 'ghc Setup.hs'?
22:35:00 <dmwit> akafubu: runhaskell Setup.hs
22:35:19 <dmwit> akafubu: You need to pass the arguments "configure", "build", and "install" in three separate invocations.
22:35:30 <dmwit> akafubu: But can we make sure that there's no distro-package for this?
22:35:36 <dmwit> This *really* ought to be coming with GHC.
22:35:54 <akafubu> okay, i'll check if you give me the commands :P
22:36:05 <akafubu> btw..
22:36:07 <dmwit> If it's not there, either your installation is broken or your distribution is really weird.
22:36:09 <akafubu> $ runhaskell Setup.hs
22:36:10 <akafubu> Setup.hs: No command given (try --help)
22:36:17 <akafubu> ubuntu jaunty
22:36:24 <dmwit> akafubu: Yes, hence my next comment about configure, build, and install. ;-)
22:36:31 <akafubu> oh, right
22:36:39 <akafubu> ./configure
22:36:41 <akafubu> bash: ./configure: No such file or directory
22:36:50 <dmwit> akafubu: search for packages with the name ghc
22:36:52 <akafubu> /parsec-3.0.0$ ls
22:36:54 <akafubu> LICENSE  parsec.cabal  Setup.hi  Setup.hs  Setup.o  Text
22:37:01 <dmwit> akafubu: No, not configure; "runhaskell Setup.hs configure".
22:37:13 <akafubu> ah
22:37:20 <dmwit> akafubu: But first search for packages with the name ghc in them.
22:37:29 <akafubu> right.
22:38:39 * akafubu is waiting on updatedb..
22:38:51 <dmwit> ...
22:38:58 <dmwit> You didn't run updatedb on your own, I hope...
22:39:05 <dmwit> (Since updatedb has nothing to do with package management.)
22:40:38 <Jebdm> akafubu: just open up ghci and try ":m ﻿Text.ParserCombinators.Parsec"
22:41:17 <dmwit> We've already checked that the package definitely isn't installed.
22:41:34 <Jebdm> GHC includes it by default in a different place than Parsec docs says it should be
22:41:34 <akafubu> http://pastebin.com/m45498dbf
22:41:42 <akafubu> results from 'locate ghc'
22:41:54 <dmwit> akafubu: ?
22:42:05 <dmwit> akafubu: How about results from "apt-cache search ghc" instead?
22:42:23 <akafubu> Prelude> :m Text.ParserCombinators.Parsec
22:42:24 <akafubu> module main:Text.ParserCombinators.Parsec is not loaded
22:42:31 <akafubu> lots of results for that... one sec
22:43:35 <akafubu> dmwit: http://pastebin.com/m6cf1f785
22:44:06 <Jebdm> Huh--that's a different error message than I get.
22:44:14 <akafubu> installing libghc6-parsec-dev atm..
22:44:20 <Jebdm> What's your GHC version?
22:44:29 <akafubu> dunno
22:44:41 <akafubu> $ ghc --version
22:44:42 <Jebdm> it should say on the first line when you start GHCi
22:44:43 <akafubu> The Glorious Glasgow Haskell Compilation System, version 6.8.2
22:45:01 <akafubu> i don't recall it being gghc ;)
22:45:02 <Jebdm> Prelude Text.ParserCombinators.Parsec> :m Text.ParserCombinators.Parsecaqwe
22:45:02 <Jebdm> Could not find module `Text.ParserCombinators.Parsecaqwe':
22:45:02 <Jebdm>   Use -v to see a list of the files searched for.
22:45:15 <Jebdm> why's it different?
22:45:47 <akafubu> okay, that took care of the parsec requirement
22:46:02 <dmwit> Jebdm: Because he's in the Parsec installation directory.
22:46:19 <dmwit> Jebdm: And so it's trying to load Text/ParserCombinators/Parsec.hs
22:46:20 <Lemmih> Jebdm: Because he's standing next to the sources.
22:46:34 <Jebdm> Ah.
22:47:13 <akafubu> ah, bootstrap has all it's dependencies now
22:47:20 <dmwit> s/'//
22:47:32 <akafubu> sí, its
22:49:14 <akafubu> thank you all for your help, my sleep medicine is kicking in, and it looks like the compilation may take awhile
22:49:30 <dmwit> of cabal?
22:49:35 <akafubu> yeah
22:49:43 <dmwit> Compilation shouldn't take longer than 30s or so.
22:49:52 <akafubu> so far, 1m+
22:50:01 <akafubu> 2m+
22:50:05 * dmwit shrugs
22:50:07 <dmwit> okey-doke
22:50:10 <akafubu> :)
22:50:13 <akafubu> gn, see you all soon
22:50:14 <Jebdm> (processor speed variation, perhaps)
22:59:51 <hatds> when debugging in single stepping mode, is there a way to step out of the current function?
23:14:16 <akafubu> argh,
23:14:18 <akafubu> $ runhaskell Setup.hs configure
23:14:19 <akafubu> Configuring cabal-install-0.6.2...
23:14:21 <akafubu> Setup.hs: At least the following dependencies are missing:
23:14:22 <akafubu> Cabal ==1.6.*, HTTP >=4000.0.2 && <4001, zlib >=0.4 && <0.6
23:14:29 <akafubu> now i'm going to bed
23:14:31 <akafubu> will ask later
23:14:35 <akafubu> too tired atm
23:48:30 <pumpkin> ack, I'm confused with how to write a Read instance... I have a String -> MyType function but all this stuff looks complicated :o
23:50:13 <hatds> where are the unsafeRead/Write operations for MArrays exported from?
23:51:49 <sm> is it possible to turn off warn-incomplete-patterns on a case by case basis ?
23:52:29 <ski> pumpkin : you should have a `ReadS MyType', i.e. a `String -> [(MyType,String)]' function
23:52:43 <sm> I have a helper function whose pattern is ensured by the parent's patterns.. I don't want to be warned about it
23:52:44 <Lemmih> sm: Well, you can complete the patterns...
23:52:56 <rick_2047> is Text.ParserCombinators.Parsec library included with ghc??
23:53:05 <sm> adding a couple of useless lines seems.. well let's try
23:53:20 <rick_2047> (.text+0x329): undefined reference to `__stginit_parseczm2zi1zi0zi1_TextziParserCombinatorsziParsec_'
23:53:29 <rick_2047> i get this error when i try to import it
23:53:32 <pumpkin> ski: thanks
23:53:38 <ski> there's also
23:53:41 <pumpkin> rick_2047: --make
23:53:44 <ski> @type ext.ParserCombinators.ReadP.readP_to_S
23:53:45 <lambdabot> Couldn't find qualified module.
23:53:47 <ski> @type Text.ParserCombinators.ReadP.readP_to_S
23:53:48 <lambdabot> forall a. Text.ParserCombinators.ReadP.ReadP a -> String -> [(a, String)]
23:54:03 <ski> if you prefer writing the parser in the `ReadP' monad
23:54:12 <rick_2047> pumpkin, u mean i append --make with ghc ?
23:54:14 <pumpkin> yeah
23:54:19 <ski> (probably one could use `Parsec' or other parsing monads, as well)
23:54:29 <rick_2047> pumpkin, got it
23:54:39 <rick_2047> but why do i have do that
23:54:48 <rick_2047> does it have to link it or something?
23:54:52 <pumpkin> ski: hmm, this might be hard... I'm binding with ffi to a lib that expects a c string and just returns one thing... I guess I'm going to have to "parse" it twice
23:54:55 <pumpkin> although it's pretty simple
23:55:00 <Lemmih> sm: Statically proving completeness would be preferable, obviously.
23:55:01 <pumpkin> rick_2047: yeah
23:55:07 <rick_2047> ok
23:55:27 <sm> Lemmih: that works, alright. I've made those cases undefined, is there something better/more readable you'd use ?
23:55:42 <ski> pumpkin : what if there's no parse ? what if there's a valid parse, but with extra unused chars left at the end ?
23:55:50 <sm> error "shouldn't happen" ?
23:56:24 * sm grumbles.. a blot on my glorious code
23:56:37 <ski> pumpkin : btw, also consider that usually one'd want `read' to read a representation that's valid haskell syntax
23:56:39 <Lemmih> sm: Perhaps you could make use of a new data structure to make sure those cases can't happen.
23:56:40 <pumpkin> ski: if there's no parse, I get a return value that tells me so
23:56:56 <pumpkin> ski: it doesn't let me know if there's anything left over because it just gets a c string
23:57:03 <pumpkin> ski: it's just a number :P
23:57:06 <pumpkin> but yeah
23:57:30 <ray> NUMBERS ARE NOT VALID HASKELL
23:57:35 <ray> > 2
23:57:36 <lambdabot>   2
23:57:43 <pumpkin> :(
23:57:46 <ski> what if the string to parse contains non-numeral-characters at the end ?
23:57:48 * ray is defeated
23:58:03 <pumpkin> ski: it appears to just ignore them
23:58:09 <ski> ok
23:58:17 <pumpkin> anyway, I'll just make a pass over the string first
23:58:28 <pumpkin> and only hand gmp the numerical part
23:58:28 <ski> you still need `reads' or `readsPrec' to return the left-over chars, though
23:58:37 <pumpkin> yeah
23:59:07 <ski> (prepass with `span' or something ?)
23:59:16 <pumpkin> yeah, that seems reasonable
23:59:44 <ski> (or maybe even an accurate parser/recognizer .. the only thing it doesn't do is create the C representation .. though that seems slightly wasteful)
