00:00:07 <erikc> Cale: so you get a copy of the state i guess? since a subsequent request to update could mutate it otherwise
00:00:20 <monochrom> algebra-like syntax helps disqualify all those who flunked algebra.
00:00:34 <Cale> erikc: right, if this were Haskell, the requests would be of type s -> IO s
00:00:42 <Cale> erikc: where s is that state type
00:00:51 <ski> (erikc : each state is immutable, iiuc)
00:00:52 <shachaf> I found The Little Schemer to be a nice book to learn from (it's a strict but purely-functional "subset" of Scheme).
00:00:55 <Entroacceptor> and here I am having trouble with debian and HDBC
00:01:17 <Cale> and yes, the value of the state is immutable
00:01:25 <erikc> right
00:01:37 <solidsnack> Haskell has a parallel garbage collector these days, right?
00:01:45 <Cale> (you just return a new immutable state to set it to)
00:01:50 <kadoban> is there something like 'lines' or 'words' that splits on a given seperator? (i want to split on commas)
00:02:06 <Cale> kadoban: There's a split package on hackage with lots of things like that.
00:02:26 <Cale> http://hackage.haskell.org/package/split
00:02:28 <Twey> Should be in the prelude, really...
00:02:35 <kadoban> Cale: ah, thanks
00:02:46 <Entroacceptor> anyone using HDBC on debian?
00:02:46 <Cale> splitOn ","
00:02:53 <Entroacceptor> I can't even get cabal-install to compile
00:03:18 <Cale> kadoban: In the event that you're parsing CSV, you should use a proper CSV parser though :)
00:03:37 <Cale> http://hackage.haskell.org/package/csv
00:03:51 <ski> (is there a proper definition of CSV ?)
00:03:52 <Cale> (since that'll handle quoted strings properly)
00:04:02 <kadoban> Cale: eh, it's just for projecteuler :) nothing exciting
00:04:03 <Cale> apparently RFC 4180
00:04:06 <Cale> ah
00:07:02 <sebaseba> @quote
00:07:03 <lambdabot> JohnMeacham says: Type theory makes totally awesome material for bar room shit talk.
00:08:38 <zong_sharo> i want some combination of stm-retry and timeout: block until any tvar changed OR some time passed
00:08:58 <zong_sharo> how can i do it?
00:11:34 <Twey> sebaseba: Heh
00:12:01 <Twey> ‘Your mum is an incomplete type!’
00:25:36 <Saizan_> zong_sharo: you might just fork a thread that writes to one additional tvar at the right time, or use killThread
00:29:16 <hackagebot> bacteria 1.0 - braindead utility to compose Xinerama backgrounds (DanielWagner)
00:29:16 <hackagebot> fmlist 0.1.1 - FoldMap lists (SjoerdVisscher)
00:34:10 <sebaseba> @quote
00:34:10 <lambdabot> JamesIry says: 1970 - Guy Steele and Gerald Sussman create Scheme. Their work leads to a series of "Lambda the Ultimate" papers culminating in "Lambda the Ultimate Kitchen Utensil."
01:05:40 <sjoerd_visscher> I just announced fmlist on Haskell-cafe
01:06:03 <sjoerd_visscher> If anybody has any comments on the code I'd like to hear it!
01:06:05 <sjoerd_visscher> http://hackage.haskell.org/packages/archive/fmlist/0.1/doc/html/src/Data-FMList.html
01:06:21 <Zao> Ah. From the name I thought it was a mailing list :)
01:06:40 <sjoerd_visscher> :)
01:07:04 <Zao> I'm reluctant to open my -cafe mailbox. It has 6k unread mails :)
01:07:42 <sjoerd_visscher> Better Ctrl-A Delete it then
01:08:16 <pozic> Zao: it is quite impossible to read everything.
01:08:19 <Gracenotes> baleeted
01:10:03 <Zao> pozic: I tend to read it and most other lists with Mark Thread as Read.
01:10:16 <Zao> There's too much signal in the noise on cafe though.
01:14:29 <pozic> I am using parListChunk like let strategy = parListChunk size_of_list/numCapabilities rnf in map cheapComputation list `using` strategy. But instead of things going faster, it goes about 0.6 times slower. The length of the list is a few million, so, this is essentially an ideal case.
01:14:54 <pozic> Don't mind the lack of two parens.
01:15:05 <Saterus> sort of opinional, but i was wondering...do people prefer to install packages with cabal-install or your distribution's package manager?
01:15:13 <Zao> Saterus: cabal.
01:15:24 <pozic> Saterus: depends on the package.
01:15:37 <Zao> Relying on the distro is rather silly in most cases, as it's just about always ancient.
01:15:47 <pozic> Saterus: some packages take 30 minutes to compile, so I heard.
01:16:18 <Saterus> ok, makes sense
01:16:58 <pozic> Saterus: but for 99% of the packages and 95% of the use cases, cabal.
01:17:41 <Saterus> pozic: what would you use the package manager for? rather than cabal? (just fishing for an example or two..)
01:18:08 <Zao> On Windows, I use cabal for the packages that are non-silly enough to build. As for the icky configure-junk using ones, I either discard them in disgust or pull out my trusty msys setup.
01:19:08 <pozic> Saterus: e.g. apt has cryptographic signatures built-in.
01:19:08 <Zao> Saterus: Consider distros like ArchLinux where madmen have made AUR packages for all the hackage packages.
01:20:09 <pozic> Saterus: there is no guarantee that the package you install via cabal won't install malware.
01:20:42 <Zao> pozic: And you should trust the debian/ubuntu repositories blindly?
01:20:45 <Saterus> pozic: how does a cabal package get updated? just the package maintainer?
01:20:48 <pozic> Zao: no
01:21:04 <pozic> Zao: but for low-security requirements, it's better than Cabal.
01:32:40 <quicksilver> Zao: "anyone" can upload to hackage
01:32:52 <quicksilver> Zao: the process of becoming a debian developer is moderately arduous.
01:33:16 <Zao> quicksilver: Rooting a debian box, less so.
01:33:32 <Zao> Especially if running their own SSH builds :P
01:34:00 <quicksilver> you'd need to compromise/replace the GPG keys
01:34:06 <quicksilver> whilst that's obviously possible in principle
01:34:13 <quicksilver> there is no evidence it's ever happened.
01:34:22 <quicksilver> I maintain that bar is significantly higher.
01:45:22 <WorkyBob> Is there somewhere hiding in amongst http://www.haskell.org/ghc/docs/latest/html/libraries/index.html a computer readable version of the library hierarchy
01:45:22 <WorkyBob> (and same question re the documentation of packages on hackage)
01:46:13 <dmwit> Dunno about the HHL, but there's definitely something for Hackage.
01:46:38 <dmwit> You might even be able to discover it by poking around in the source of cabal-install...
01:47:08 <WorkyBob> kk
01:57:40 <pozic> quicksilver: I was referring to someone doing a man-in-the-middle attack when using cabal install, but the anyone can upload is another issue, yes.
01:59:53 * QtPlaty[HireMe] would like shorter function names for Monoid
02:01:14 <Peaker> ++ and zero?
02:08:18 <ziman> unicode would definitely help :)
02:22:27 <ivanm> dibblego: had much luck with that guy?
02:23:31 <root___> exit
02:23:35 <dibblego> which guy?
02:23:40 <dibblego> what do you mean?
02:25:14 <dibblego> oh the reddit guy you mean? I'm not sure how that will work out
02:25:24 <dibblego> I'm going to give it a good hard shot though
02:25:42 <hackagebot> hmatrix 0.5.2.2 - Linear algebra and numerical computations (AlbertoRuiz)
02:26:21 <dibblego> @type replicateM
02:26:22 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
02:28:37 <dancor> cabal install of happstack-data fails because of an error with /usr/lib/librt.so.  so i installed librt into ~/sw/lib/librt.a.  however (cabal install --extra-lib-dirs=/home/dancor/sw/lib) still uses the old location.  how can i force the it to use the new one?
03:11:57 <jensbarthel> hi
03:12:13 <ivanm> dibblego: yeah, the reddit guy
03:12:20 * ivanm was afk for a bit
03:12:22 <jensbarthel> i want to plot the mandelbrot set. which graphics library should i use?
03:12:45 <ivanm> jensbarthel: no idea, tbh
03:12:52 <ivanm> I'm not sure if chart can deal with such a thing
03:13:02 <ejt> jensbarthel: I've found the GD library to be simple to use
03:13:17 <ivanm> or else export it to gnuplot or something
03:13:31 <jensbarthel> @ejt: thx, i'll have a look at it
03:13:32 <lambdabot> Unknown command, try @list
03:13:39 <ivanm> lol
03:21:56 <mornfall> @pointless a x y = fst <$> b x y
03:21:57 <lambdabot> a = ((fst <$>) .) . b
03:59:23 <Reiv> Whoa.
03:59:23 <Reiv> ERROR file:.\Ass4.txt:156 - Type error in case expression
03:59:24 <Reiv> *** Term           : a
03:59:24 <Reiv> *** Type           : [Char]
03:59:24 <Reiv> *** Does not match : [Value]
03:59:34 <Reiv> What's it mean by [Value] ?
03:59:53 <QtPlaty[HireMe]> Reiv: Someone has created a type called Value
04:00:30 <QtPlaty[HireMe]> Stick the code in the pastebin?
04:00:53 <HugoDaniel> hello
04:01:37 <HugoDaniel> i know this is not haskell, its python, but it could be a (VERY) good point in favor of haskell: http://blip.tv/file/2232410
04:02:36 <Phyx> Hi, does anyone know what might cauze gmapT id <expression> to return unit?
04:02:49 <ivanm> @type gmapT
04:02:51 <lambdabot> forall a. (Data a) => (forall b. (Data b) => b -> b) -> a -> a
04:03:06 <ivanm> @hoogle Data
04:03:07 <lambdabot> Data.Generics.Basics class Typeable a => Data a
04:03:07 <lambdabot> keyword data
04:03:07 <lambdabot> package data-accessor
04:03:14 <ivanm> *shrug* no idea
04:03:32 <Phyx> it works correctly for everything else
04:03:43 <Phyx> could it be a bug in deriving Data?
04:03:52 <Phyx> > gmapT id 5
04:03:53 <lambdabot>   5
04:04:05 <Phyx> is the behaviour i'm expecting
04:04:17 <ivanm> Phyx: I would think it's because <expression> returns unit...
04:05:55 <Phyx> oh, it doesn't itseems somehow the show return ()
04:06:33 <Reiv> QtPlaty[HireMe]: http://pastebin.com/d38bc1da6
04:06:42 <Reiv> Highlighted the line(s) it's complaining about
04:07:25 <Phyx> ivanm yeah ok, found it, it's the show that was printing out "()". I'm modifying an existing library, so i didn't think to look at that
04:07:33 <ivanm> heh
04:08:03 <Cale> HugoDaniel: interesting link, I'll watch it :)
04:10:32 <Reiv> What I've been doing is implementing things so that an Error actually passes back a meaningful message
04:10:46 <Reiv> However, it seems to be hitting a snag at one point and I'm not entirely certain why.
04:16:28 <voker57__> can ghc perform some kind of auto-parallelisation of computations?
04:17:04 <Jedai> voker57__: That depends
04:17:26 <voker57__> Jedai: on what?
04:17:30 <Jedai> Normally you would have to use annotations to indicate which part it can process in parallel
04:17:48 <Jedai> See Control.Parallel.Strategies for this solution
04:18:18 <EvilTerran> or just Control.Parallel for `par`
04:18:36 <voker57__> thanks. will look
04:19:05 <Jedai> on the other hand you have Data Parallel Haskell, which provides parallel arrays on which operation are automatically done in parallel
04:20:31 <Jedai> For IO code you also have MVar (for an experience close to the classic locks) and the STM (software transactional memory) which avoid locks
04:31:46 <Reiv> Oh, I think I see.
04:31:56 <Reiv> It's recieving a 'char' when it wants a String.
04:32:19 <Reiv> The bit that puzzles me on that though is why it's recieving a char - as far as I know all I'm passing it /are/ strings? Odd...
04:32:33 <Reiv> http://pastebin.com/d38bc1da6 - or is the line doing something different to what I think it's doing?
04:50:40 <EvilTerran> Reiv, there's far too much code there for anyone to check all of it out of benevolence; what lines should we looking at?
05:01:40 <thomastc> I'm reading the GHC Commentary... and I'm impressed
05:01:57 <thomastc> it is really a great and wonderful piece of work
05:02:02 <thomastc> because I can actually understand it :D
05:20:22 <hackagebot> level-monad 0.4 - Non-Determinism Monad for Level-Wise Search (SebastianFischer)
05:34:41 <jnwhiteh> Is anyone familiar with the threading model in GHC?  Particularly I'm interested in how Network.Socket.accept doesn't block the other running forkIO threads in a simple server.
05:38:04 <dikini> as far as I understand it it spawns a separate worker thread for potentially blocking calls, don't know the exact details, but they were somewhere in the ghc commentary
05:39:37 <jnwhiteh> yeah that's what I'm trying to track down.  The paper I was reading addressed worker threads for safe FFI calls (or it may have been unsafe), but I didn't see anything regarding this.
05:41:48 <dikini> http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/Scheduler
05:41:51 <dikini> I think
05:46:40 <quicksilver> jnwhiteh: it uses select.
05:46:53 <quicksilver> jnwhiteh: for accept/read/write it has an IO manager thread which uses select
05:47:21 <quicksilver> and wakes up whicheven haskell threads are blocking on them appropriately.
05:47:39 <ceal> are expressions such as let b = [1,2,3,[4,5]] possible?
05:47:39 <jnwhiteh> so it's the library itself that is managing that, not the runtime?
05:47:53 <quicksilver> these are all lighteight threads, not OS threads, btw.
05:48:01 <quicksilver> jnwhiteh: no, it's the runtime
05:48:10 <quicksilver> although it principle it could probably just about be turned into a haskell library
05:48:16 <quicksilver> (with an FFI binding to select())
05:48:24 <quicksilver> but it's actually C code calling select() as it happens.
05:48:47 <quicksilver> ceal: that's not well-typed. [a] lists have all elements of the same type.
05:48:58 <quicksilver> ceal: of course, you can make a datatype for multi-level lists.
05:49:08 <jnwhiteh> Well my question is basically this, say you have one lwt spawned that just prints something to the screen over and over again.. and another that is accepting connections on a socket.
05:49:17 <jnwhiteh> During the course of the select() the print loop will not run, correct?
05:49:30 <quicksilver> it's a select() with zero timeout
05:49:33 <quicksilver> it shouldn't block anything
05:49:43 <jnwhiteh> okay, that makes more sense
05:49:50 <ceal> quicksilver: without the creating the datatype part is it possible? (i have just started on haskell)
05:49:52 <jnwhiteh> but assuming it was set with a timeout, the above would happen
05:50:08 <quicksilver> jnwhiteh: it would indeed. which is why it doesn't do that :)
05:50:28 <jnwhiteh> good, just want to maek sure my brain is in the right place, appreciated
05:50:38 <quicksilver> jnwhiteh: to do other nonblocking stuff, outside of the standard Handle things, requires the -threaded version of the runtime
05:50:46 <quicksilver> jnwhiteh: and that actually uses real, OS-level threads
05:50:53 <quicksilver> (so that a blocking FFI call doesn't block everything)
05:51:08 <Reiver> Whoops, hadn't realised my name was off - and so the highlight didn't work. Sorry about that, EvilTerran!
05:51:18 <quicksilver> under win32 it doesn't use select(), of course
05:51:39 <quicksilver> it uses SomeSurprisinglyLongStudlyCapsAPICallToPollPendingIOEvents()
05:51:44 <quicksilver> but that's quite similar in effect.
05:52:01 <jnwhiteh> you forgot the hungarian notation :P
05:53:05 <Reiver> And I thought I /had/ highlighted it; I failed to make it work. One moment.
05:58:22 <Reiver> Ah!
05:58:31 <Reiver> Pastie only highlights one edit's worth. Good to know.
05:58:50 <Reiver> Updated version with actual highlights, and the error written in place: http://pastebin.com/db62b03b
06:01:11 <Reiver> So, er. It's a simple enough type error; but I've no idea why it's doing what it's doing :/
06:01:26 <Reiver> The intention is for 'a' to be a variable; it's being read as a char? I think?
06:01:34 * Reiver admits he's still new at this.
06:01:45 <doserj> Reiver: what's the type of a in Errorc a?
06:02:13 <Reiver> doserj: It's meant to be a string, I think.
06:02:43 <doserj> so if cmd_semantics program (emptyMem, input, []) = Errorc a, you return a String
06:02:48 <sampointon> Reiver: put in a load more type signatures, the problem with typechecker errors is they can occur miles away from the actual mistake
06:03:00 <Reiver> Yeah, data CmdVal = OKc State | Errorc String
06:03:17 <doserj> if cmd_semantics program (emptyMem, input, []) = Okc (m,i,o), you return a Value
06:03:28 <doserj> (or [Value])
06:03:50 <Zao> How do people usually decorate their field accessors?
06:03:52 <Reiver> Ah...hah. This is a problem, yes?
06:04:11 <doserj> Reiver: yes. A function only has one return type
06:04:18 <Reiver> Right.
06:04:45 <Reiver> What it's /meant/ to do is return an Error, which holds a String.
06:05:06 <Reiver> (I may have botched the syntax entirely for this...)
06:05:42 <Reiver> What the old code did was simply return an Error: "Error -> Error", or "<code> -> Error".
06:06:16 <Reiver> I was trying to put information into the Errors, so that they held meaningful information once they'd rolled back to the output code.
06:06:58 <Reiver> I've apparently broken my type-ing in trying to do this?
06:08:03 <doserj> Reiver: well, you have to do sth with that Error in your run function
06:08:22 <Reiver> sth?
06:09:18 <doserj> something, like returning ERROR a, instead of a :)
06:10:24 * Reiver pauses, peers.
06:10:54 <Reiver> Oh. Ohohoho. Riiiight.
06:10:56 <Reiver> Oops. >_>
06:11:49 <Reiver> Same line:
06:11:50 <Reiver> *** Term           : ERROR a
06:11:50 <Reiver> *** Type           : Value
06:11:50 <Reiver> *** Does not match : [Value]
06:12:04 <Reiver> Do I want [ERROR] a, ERROR [a], or...?
06:12:47 <doserj> [ERROR a]
06:13:27 <Reiver> ...Yes, that /would/ make rather more sense wouldn't it
06:14:59 <Reiver> ...woohoo! It /worketh/
06:15:14 <Zao> Correct code has a tendency to do that.
06:16:12 <Reiver> It's a lovely feeling, isn't it? :)
06:18:14 <Reiver> Now to work out how to get those error messages more meaningful.
06:18:43 <sioraiocht> dcoutts: ping?
06:18:52 <dcoutts> sioraiocht: pong
06:19:09 <fasta> Is u' a kind of unicode '? I see it when I show a certain string.
06:26:41 <quicksilver> fasta: "show" is supposed to be 7-bit clean
06:26:53 <quicksilver> high characters get represented by \ escape sequences
06:27:09 <quicksilver> > show ['a',chr 400,chr 500]
06:27:11 <lambdabot>   "\"a\\400\\500\""
06:27:28 <quicksilver> two levels of 'show' there causing double escaping.
06:27:48 <fasta> quicksilver: I use utf-string to read the file. I thought that's where the extra u comes from.
06:35:30 <jelly12gen> hi i have an book about haskell , but i can't find any solutions in the book and on the web , the book is called "the craft of functional programming" does anyone here has it / found it ?
06:35:51 <Botje> jelly12gen: guess you'll have to solve them yourself :)
06:36:03 <Botje> if you have troubles getting something to work you can always ask this channle
06:36:35 <jelly12gen> Botje: well the trouble isnt the work / solving it's more like if the answer is right or wrong :P
06:37:00 <WorkyBob> jelly12gen: if you're really struggling, you could always email simon thompson, but you'd probably be better off emailing the haskell list
06:37:00 <ceal> that should be clear if you execute the program right??
06:37:05 <WorkyBob> haskell-beginners even
06:37:14 <WorkyBob> ceal: not at all
06:37:19 <QtPlaty[HireMe]> jelly12gen: Does it tell you what the desired output is?
06:37:23 <WorkyBob> absense of evidence is no evidence of absense
06:37:41 <Zao> Incorrect code may appear to "work".
06:37:47 <Zao> Especially if in a fun language like C++.
06:37:48 <jelly12gen> QtPlaty[HireMe]: not always , if it does it's ok but some questions are like give the definition of ..
06:37:56 <jelly12gen> Zao: exactly
06:38:09 <jelly12gen> but i couldn't think of doing things dirty in haskell
06:38:31 <Zao> reinterpret_cast<T *>(0)->f(); // now your cat is fed
06:38:35 <jelly12gen> only doing things a bit useless like using reverse two times etc.
06:38:44 <Zao> jelly12gen: coerce :: a -> b?
06:41:26 <ceal> workybob could you explain your quote?
06:41:33 <ceal> and it's relevance here?
06:41:51 <ceal> i've just started on haskell and would like to know more about it
06:41:53 <WorkyBob> ceal: running your program once and verifying the result provides an absense of evidence that your program is eronious
06:42:03 <WorkyBob> it doesn't provide evidence that your program is not eronious
06:42:19 <ceal> oh right......
06:42:42 <ceal> in that sense..........
06:44:38 <PeakerWork> ceal: you're still using ??, heh. Old habits die hard?  :-)
06:45:56 <lilac> there's something wonderfully ironic about "eronious"
06:46:08 <WorkyBob> lilac: ?
06:46:52 <ceal> not here peakerwork
06:47:11 <ceal> it was an important doubt i didn't know that fact which workybob pointed out
06:47:44 <ceal> atleast i think it was :)
06:47:55 <ceal> but yeah sometimes i do use the ??
06:48:19 <ceal> trying to correct myself now; even text msg i use only ? not ??
06:48:29 <lilac> WorkyBob: "erroneous"
06:50:00 <byorgey> also, "absence" =)
06:50:01 <WorkyBob> oh, he
06:50:03 <WorkyBob> heh*
06:50:58 <byorgey> I kind of like "eronious" though.  It's self-referential. =)
06:51:02 <WorkyBob> :)
06:51:48 <WorkyBob> I think I prefer paradoxical in the place of erroneous, then when you decide you prefer it because of the irony, it becomes correct, and hence also paradoxical
06:55:07 <ceal> how do i use elem?
06:55:17 <ceal> i have a list b = [1,2,3,4,5]
06:55:22 <byorgey> > elem 5 [1,2,3,4,5]
06:55:22 <ceal> and a = 98
06:55:22 <jelly12gen> elem 1 b
06:55:24 <lambdabot>   True
06:55:27 <WorkyBob> > 3 `elem` [1,2,3,4,5]
06:55:29 <lambdabot>   True
06:55:36 <WorkyBob> > 3 `elem` [6,7,8,9,10]
06:55:37 <lambdabot>   False
06:55:41 <ceal> i tried a 'elem' b
06:55:45 <WorkyBob> back ticks
06:55:45 <ceal> it didn't work
06:55:47 <WorkyBob> not quotes
06:55:53 <ceal> ?
06:55:56 <WorkyBob> `, not '
06:55:59 <jelly12gen> ceal: search how the quotes work
06:56:08 <thomastc> is there any way to compile a cabal package against another package that is not installed?
06:56:14 <ceal> oh ok didn't notice that...
06:56:37 <ceal> what does the ` mean?
06:56:37 <dcoutts> thomastc: you can register the other one inplace, or into a specific local package db
06:56:52 <byorgey> ceal: `backticks` turn a function into an infix operator
06:57:04 <thomastc> dcoutts: ah, the latter sounds like a good option, thanks
06:57:05 <ceal> oh ok
06:57:13 <byorgey> ceal: hence normally you would say   elem 3 [1,2,3,4,5], but with backticks you can say   3 `elem` [1,2,3,4,5]
06:57:18 <WorkyBob> ceal: similar to how parentheses turn an infix operator into a function
06:57:21 <WorkyBob> > (+) 2 5
06:57:22 <lambdabot>   7
06:57:32 <thomastc> is there any way to uninstall a cabal package? ;)
06:57:35 <ceal> ok thanks
06:57:43 <WorkyBob> thomastc: ghc-pkg unregister
06:57:46 <thomastc> apart from unregistering it and removing its files by hand
06:57:49 <dcoutts> thomastc: you'd actually do both, register inplace in a local package db. Use the --package-db= flag to configure and register --inplace
06:58:17 <dcoutts> thomastc: rm. And since you control where it gets installed to that's sufficient.
06:58:33 <ceal> just curious: is it advantageous to use infix operator than functions?
06:58:39 <Zao> Imagine the fun you could have if you could do `(`(+)`)`.
06:58:49 <Zao> ceal: It's all about readability.
06:59:11 <ceal> ok
06:59:14 <Zao> "is three an element of"  =>  3 `elem`
06:59:49 <ceal> just like operator overloading in C++
06:59:53 <ceal> good thanks
07:00:37 <hatds> this nice flexibility causes problems with some function names, like divides :: Int -> Int -> Bool,  (divides n) and (n `divides`) have different readings
07:00:56 <Axman6> ceal: using infix functions can be useful when you're doing say isLower = `elem` ['a'..'z']
07:01:24 <Axman6> which is basically the same as \x -> elem x ['a'..'z']
07:01:40 <WorkyBob> which actually, is a bug
07:01:52 <Axman6> ?
07:01:57 <Axman6> @bot
07:01:57 <lunabot>  :)
07:01:57 <lambdabot> :)
07:02:00 <BONUS> or flip elem ['a'..'z'] but its beter to use sections if you can
07:02:09 <WorkyBob> Axman6: it does more evaluation than partial application
07:02:23 * Axman6 tries to avoid flip where possible
07:02:28 <WorkyBob> it needs an extra let binding
07:02:37 <Axman6> ah :\
07:02:46 <Axman6> well, it reads fairly well
07:02:51 <Zao> BONUS: Where a section is a partial operator application, right?
07:03:00 <Zao> (+2), (4 `elem`), whatnot.
07:03:13 <WorkyBob> Zao: only a section filling the left-hand argument is partial application
07:03:24 <WorkyBob> filling in the right hand argument generates a lambda behind the scenes
07:03:30 <Zao> WorkyBob: Partial in the meaning of "not full".
07:03:52 <WorkyBob> well sure, but the point is it's not an application it makes
07:04:15 <WorkyBob> it makes a lambda, which contains an application inside it
07:04:34 <Zao> Sounds awfully lot like implementation detail.
07:04:42 <Zao> Or does the report specify those kinds of things?
07:04:44 <ceal> is it necessary to know lambda calculus to understand haskell?
07:04:50 <Zao> ceal: Not really.
07:05:01 <WorkyBob> Zao: I'm not sure if the report specifys it or not
07:05:02 <ceal> i mean in programming, debugging etc?
07:05:08 <Zao> I couldn't name a combinator even if it bit me.
07:05:09 <WorkyBob> ceal: no, not at all
07:05:19 <ceal> ok
07:05:32 <WorkyBob> in the same way as it's not necessary to know asm to learn c or python
07:05:39 <WorkyBob> it can however sometimes be useful
07:05:39 <ceal> asm?
07:05:42 <WorkyBob> assembly
07:05:48 <ceal> oh!
07:05:54 <ceal> how is it useful in c and python?
07:06:01 <ceal> i have learnt both a bit
07:06:08 <PeakerWork> I wouldn't say LC:Haskell is like ASM:C or C:Python
07:06:09 <ceal> just curious...
07:06:26 <WorkyBob> Peaker: no, it's more like LC:Haskell is like TM:c
07:06:30 <WorkyBob> but... closish
07:06:40 <PeakerWork> TM?
07:06:42 <PeakerWork> oh
07:06:44 <WorkyBob> turing machine
07:06:56 <PeakerWork> yeah, except LC:Haskell are much more similar than TM:C
07:07:16 <WorkyBob> ceal: sometimes in terms of efficiency, it's nice to know how the compiler is going to generate code for your program
07:07:28 <WorkyBob> for which knowing the lower level details is useful
07:07:37 <WorkyBob> that doesn't mean it's not possible to write useful programs without it though
07:07:46 <kynky> sometimes you need low level power, mostly its quiker to write at a higher abstraction, also knowing low level stuff, gives u understanding of how higher level stuff does its job, so you can be more aware, and make better choices
07:07:57 <ceal> well actually i am not learning haskell just for learning how to program with it
07:09:08 <Axman6> ceal: why are you learning it?
07:09:18 <ceal> i am also learning for the cipher contest and because i want to contribute to the FOSS equivalent of haskell
07:09:34 <WorkyBob> well, Haskell is FOSS
07:09:35 <Axman6> haskell is 'FOSS'
07:09:38 <WorkyBob> as are most of the compilers
07:09:44 <WorkyBob> (all?) the compilers
07:09:47 <ceal> but it's a good FOSS
07:09:49 <Axman6> afaik
07:09:54 <Axman6> what is it?
07:10:09 <Axman6> and how is haskell 'a bad FOSS'?
07:10:20 <ceal> i mean it's a well developed one isn't it
07:10:30 <WorkyBob> yes, haskell is very well developed
07:10:39 <WorkyBob> and extremely actively maintained
07:10:43 <ceal> but the one owned by SUN isn't
07:10:47 <Axman6> why not just tell us what you're wanting to do
07:10:50 <Axman6> no :S
07:10:52 <WorkyBob> sun owns a haskell compiler?
07:10:54 <kynky> owned by oracle
07:10:56 <Axman6> no
07:11:00 <ceal> no an equivalent
07:11:11 <Axman6> what are you on about >_<
07:11:11 <fasta> @quote ceal
07:11:12 <lambdabot> No quotes match. I've seen penguins that can type better than that.
07:11:16 * Axman6 is so confused
07:11:21 * WorkyBob is confused too
07:11:31 <thomastc> dcoutts: how do I get a new, empty package database for cabal?
07:11:35 <kynky> ceal, for which language ?
07:11:50 <ceal> hold on let me check
07:12:17 <dcoutts> thomastc: it's a bit hacky I'm afraid, echo [] > package.conf
07:12:31 <WorkyBob> dcoutts: that's kinda cool actually
07:13:38 <dcoutts> WorkyBob: it exposes the internal representation :-(
07:13:38 <thomastc> heh :) no wonder that is undocumented, somebody was ashamed? ;)
07:14:14 <ceal> i dont remember the name of the SUN compiler and cant find it in the net; but i have surely read about it
07:15:28 <Axman6> ceal: what is it a compiler for?
07:15:46 <ceal> i dont remember
07:16:03 <Axman6> Sun make java compilers, and C compilers...
07:16:04 <mapreduce> Are you thinking of CAL?
07:16:06 <ceal> all i know is that it supports functional programming; similar to haskell
07:16:06 <Axman6> and operating systems...
07:16:11 <ceal> CAL?
07:16:38 <mapreduce> CAL is a JVM language not entirely unrelated to Haskell.
07:16:57 <ceal> no i dont think that's the one
07:17:25 <Botje> fortress?
07:17:35 <thomastc> so there are only two package databases at any given time... the global one, and the user one... there is no way to layer a third on top of that
07:17:42 <thomastc> that's too bad
07:17:42 <ceal> yeah fortress
07:17:43 <ceal> right
07:19:04 <ceal> yup that's the one; thanks botje
07:20:17 <Axman6> " Source code can be rendered as ASCII text, in Unicode, or as a prettied image." o.O
07:20:32 <Botje> i want a pony!
07:21:17 <ceal> is haskell used in scripting like python is?
07:21:20 * mlesniak_ uses vim's :TOhtml for pretty sourcecode ...
07:21:43 <Axman6> not really
07:21:45 <re_> hi there, has someone an idea about this? http://www.haskell.org/pipermail/haskell-cafe/2009-June/063068.html
07:21:59 * The-Kenny uses htmlize.el 
07:22:43 <Axman6> re_: is that your email btw?
07:22:51 <re_> jep
07:23:09 <Axman6> re_: is it using 100% CPU?
07:23:18 <re_> no
07:23:28 <re_> its just 100 of process time
07:23:30 <Axman6> because the percentage is the amount of time spent in any one function
07:23:35 <Axman6> ok, good
07:23:39 <re_> it simply does nothing :) but waiting
07:23:54 <re_> ah ok
07:24:14 <re_> so any idea what this upcased MAIN function comes from?
07:24:36 <Axman6> i'm guessing it's the C main, but i don't know
07:24:54 <re_> hmm. ok
07:25:19 <re_> my first thought was, that this 100% is the wiating forconnection time
07:25:23 <Axman6> also
07:25:26 <Axman6> @src print
07:25:26 <lambdabot> print x = putStrLn (show x)
07:26:20 <ceal>  b = [ x *2 | x < [1..10]]
07:26:28 <re_> but if I put a putStrLn . show $ [0..1000000] after the listenon and vary the time beforfe i connect to the socket the result are the same
07:26:28 <ceal> why doesn't this work?
07:26:38 <Axman6> ceal: need <- not <
07:26:47 <ceal> ok
07:27:05 <ceal> nope is still get error
07:27:17 <ceal> parse error on input `='
07:27:21 <Axman6> > [ x *2 | x <- [1..10]]
07:27:22 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
07:27:29 <Axman6> where are you writing this?
07:27:43 <ceal> at the prompt
07:27:45 <ceal> why?
07:27:45 <Axman6> ghci?
07:27:48 <ceal> yeah
07:27:53 <Axman6> well, it makes a difference
07:27:56 <EvilTerran> ceal, what exactly are you writing?
07:28:03 <Axman6> you need to use let x = y, not just x = y
07:28:17 <ceal> i already have a name defined
07:28:26 <ceal> let me try that anyway
07:28:27 <Axman6> huh?
07:28:39 <Axman6> oh... you are very new to haskell aren't you ;)
07:28:49 <Axman6> you can't refdefine variables like that
07:28:55 <Axman6> redefine*
07:28:57 <ceal> oh
07:29:28 <ceal> but i could assign values to a previously defined name
07:29:32 <ceal> how come?
07:29:59 <Axman6> in fact, in haskell, there's no real idea of defining a variable, like in other languages. if you say b = c, then where ever you see b, you can replace it with c
07:30:14 <ceal> yeah i know that
07:30:16 <Axman6> it helps if you think of everything being a function.
07:30:20 <ceal> thanks Axman6
07:30:25 <ceal> thanks a lot
07:30:31 <Axman6> no worries
07:30:32 <sampointon> ceal: I think what you mean is name shadowing
07:30:35 <EvilTerran> ceal, you can shadow an old variable name with a new definition
07:30:46 <ceal> oh
07:30:48 <EvilTerran> but all existing references to the name continue to point to the old value
07:30:56 <sampointon> ceal: for example, try: let x = 2; let y = x + 3; let x = 20; x
07:30:59 <EvilTerran> it's just any new references to the name will refer to the new value
07:31:17 <EvilTerran> > let x = 2 in let y = x + 3 in let x = 20 in y
07:31:18 <lambdabot>   5
07:31:19 <sampointon> ceal: erm, and try printing y as well. It should come out as 5
07:31:24 <ceal> ok let me try
07:31:42 <Axman6> 5?
07:31:46 <Axman6> oh yes, heh
07:31:50 <Axman6> thought x was 5
07:31:51 <sampointon> EvilTerran: I think this is at the ghci prompt, so I was trying to explain in terms of that :)
07:32:08 <ceal> y is 5; x 20
07:32:15 <Axman6> ok, sleep time. got a comp exam tomorrow that i haven't prepared for, and most likely won't need to
07:32:24 <ceal> understood thanks
07:32:32 <ceal> best of luck axman6
07:33:50 <EvilTerran> ceal, i tend to think of a name in haskell as an identifier for a particular value, not an identifier for some kind of mutable cell like in most languages
07:35:53 <zong_sharo> Saizan_: IO, i wanna something like retryTimeout :: Int -> STM a
07:46:42 <znusgy> i'm trying to install hpodder on gentoo linux and finding that cabal-install requires a package called old-time to compile.  since i don't have cabal-install yet, i tried to install old-time manually, and it seems to have been registered, but it's not being found
07:46:50 <znusgy> is there a load path i should be checking?
07:48:57 <mux> http://www.funtim.com/the-brutal-mother-duck.html
07:49:01 <mux> woops, misfire
07:50:01 <doserj> znusgy: old-time should have been installed together with ghc(+extralibs). what ghc version do you have?
07:50:48 <doserj> and what does 'ghc-pkg list old-time' say?
07:51:46 <znusgy> The Glorious Glasgow Haskell Compilation System, version 6.8.2
07:52:17 <znusgy> /usr/lib/ghc-6.8.2/package.conf:    old-time-1.0.0.0, old-time-1.0.0.2
07:52:44 <doserj> znusgy: congrats, now you have two :)
07:53:03 <znusgy> oh :)
07:54:22 <doserj> how exactly did you try to install cabal-install, and what exactly is the error message?
07:54:28 <znusgy> this is the error i get building hpodder:
07:54:34 <znusgy> Utils.hs:41:7:    Could not find module `System.Time':      it is a member of package old-time-1.0.0.2, which is hidden
07:54:34 <znusgy>  
07:55:36 <znusgy> both hpodder and cabal-install i tried to build with gentoo ebuilds
07:56:02 <sampointon> znusgy: try from source? That looks like gentoo's packaging might be wonky
07:57:08 <znusgy> it could be, those packages are part of an unofficial "overlay"
07:57:25 <doserj> what hpodder version is in the ebuild?
07:58:06 <doserj> some older versions might not be ready for ghc-6.8.x
07:58:33 <walter_> Could anyone recommed a haskell primer book?  yaht is not completed. RealWorldHaskell is a little complex on simple concept, I think
07:58:37 <znusgy> it's hpodder 1.0.3
07:58:45 <doserj> znusgy: you need at least 1.1 :)
07:59:10 <znusgy> i see
07:59:11 <kynky> i like yaht, rwh, and the haskell wiki book
07:59:16 <znusgy> thanks!
07:59:28 <sampointon> walter_: I loved the Build Yourself A Scheme in 48 Hours (not sure if that's the exact title) tutorial, personally
07:59:54 <sampointon> walter_: not sure how good it is as a 'primer' though
08:00:25 <doserj> http://learnyouahaskell.com/ is recommended by some
08:01:02 <walter_> great! rwh, wikibook, and Build Yourself A Scheme in 48 Hours and  http://learnyouahaskell.com/
08:01:13 <walter_> thank you all.
08:01:16 <znusgy> i've actually got a copy of hpodder 1.1.5.0 too but without an ebuild
08:02:21 <znusgy> now i get this error:
08:02:27 <znusgy> Utils.hs:115:34:    Couldn't match expected type `old-time-1.0.0.0:System.Time.ClockTime'           against inferred type `ClockTime'
08:03:19 <doserj> that's probably because you have two versions of old-time installed. try to 'ghc-pkg hide' one of them
08:03:55 <doserj> i.e., 'ghc-pkg hide old-time-1.0.0.2'
08:04:28 <znusgy> i don't seem to have ghc-hide; does that not come with the compiler?
08:04:43 <doserj> ghc-pkg hide
08:04:54 <znusgy> ah, sorry!
08:05:19 <doserj> you might even want to 'ghc-pkg unregister old-time-1.0.0.2'
08:06:27 <znusgy> i think i see the problem
08:06:45 <znusgy> package HDBC-2.1.0 requires old-time-1.0.0.0
08:06:45 <znusgy>  
08:06:45 <znusgy>  
08:06:48 <znusgy> package hpodder-1.1.5 requires old-time-1.0.0.2
08:07:10 <znusgy> maybe i need a slightly older hpodder?
08:07:14 <doserj> znusgy: it doesn require it
08:07:28 <doserj> but if it is available, it will use the newer one by default
08:07:38 <doserj> which then gives conflicts
08:07:42 <Taejo> is there a haskell library to create images in "nice" formats (i.e., PPM is not sufficient)?
08:07:48 <Taejo> *PNM
08:08:25 <doserj> http://hackage.haskell.org/packages/archive/pkg-list.html#cat:graphics is full of them
08:09:53 <sampointon> Taejo: alternatively, you can postprocess the output (eg, with imagemagick) into a more acceptable format, and keep the haskell code simple
08:10:01 <hackagebot> hashed-storage 0.3.3 - Hashed file storage support code. (PetrRockai)
08:10:06 <kynky> Taejo, there is gtk and cairo
08:11:12 <znusgy> great, hpodder compiled :)
08:11:12 <znusgy>  
08:11:19 <Taejo> sampointon: that's my usual approach, but I've already had users complain
08:11:30 <znusgy> i just tried cabal-install again and got this: ghc-6.8.2: unknown package: old-time-1.0.0.2 (dependency of Cabal-1.6.0.3)
08:11:49 <sampointon> Taejo: complain at having to run the conversion manually, you mean?
08:12:40 <doserj> znusgy: try to reconfigure
08:13:08 <Taejo> sampointon: yes. note that while imagemagick or some variety of pnm2png is pretty much universal in unix, the format is fairly obscure in the Windows world (Paint doesn't like it, for starters)
08:13:16 <malosh> Hi. Is there an efficiently foldable (i.e. at least tail-rec) functional map structure, or do I have to use hash tables necessarily ?
08:13:46 <BONUS> Data.Map ?
08:13:49 <sampointon> Taejo: is bundling some converted and running it automatically on the generated files unacceptable?
08:14:09 <znusgy> doserj: i'm not sure what to reconfigure or how...
08:14:13 <sampointon> Taejo: erm, s/converted/converter/
08:14:23 <malosh> BONUS : it is a tree. I would have used an int map because my elements are ints
08:14:31 <malosh> so not tail-rec foldable
08:14:53 <doserj> znusgy: hmm, could be that you already built Cabal against old-time-1.0.0.2. if so, you will have to rebuild it
08:14:58 <Taejo> sampointon: I don't know... I just want to make the program more user friendly (I'm not selling it or anything). BTW, the program is fractal
08:15:00 <malosh> my structure is quite big and I don't like +RTS -K too much
08:15:12 <jmcarthur_work> malosh, you mean your keys are Ints?
08:15:26 <malosh> (both, in fact :-)
08:16:05 <sampointon> Taejo: ah, this brings back some memories. I wrote a grapher for complex functions in the plane, and had a very byzantine system of conversions going on :)
08:16:40 <jmcarthur_work> malosh, and why can't you use IntMap, now?
08:16:52 <jmcarthur_work> should fold fine
08:16:53 <malosh> fold is not tail-rec, the structure is a tree
08:17:06 <znusgy> with ebuilds it seems that when there's an error it deletes the build files and starts from scratch when you retry
08:17:10 <jmcarthur_work> oh you want a constant space fold
08:17:15 <malosh> yes
08:17:16 <znusgy> or do you mean that cabal may already be installed?
08:17:27 <malosh> at least something that does not use +RTS -K
08:17:42 <doserj> znusgy: I mean that "Cabal" may already be installed.
08:18:01 <jmcarthur_work> malosh, is an IntMap fold really that hard on your stack??
08:18:07 <malosh> (so in fact "constant stack space" fold)
08:18:11 <malosh> yes
08:18:13 <conal> malosh: naively, i'd expect tree-based reps to use log space.
08:18:19 <jmcarthur_work> it's only 32 or 64 deep
08:18:21 <jmcarthur_work> at max
08:18:25 <malosh> for a huge structure it does
08:19:07 <conal> malosh: maybe there's something else going on.  perhaps laziness of the value accumulation.
08:19:10 <znusgy> if so it's not in my exec path (or the name doesn't match Cabal* or cabal*); do you know where it might be?
08:19:28 <conal> malosh: which could then use *linear* space (eep)
08:19:29 <jmcarthur_work> malosh, i agree with conal, i don't think its your tree structure that's the problem
08:19:52 <malosh> I've "seq"eq every part of the code !
08:19:54 <conal> logarithms rule!
08:19:56 <doserj> znusgy: Cabal, the library. check with 'ghc-pkg list Cabal'
08:20:01 <malosh> yeah
08:20:03 <sampointon> znusgy: if I remember right, the 'cabal' executable is actually from cabal-install. Cabal itself should be installed with ghc
08:20:43 <EvilTerran> malosh, excessive strictness can be as much of a problem as excessive laziness
08:20:55 <fasta> Is there a string_replace function already somewhere? So, string_replace "hi" "ha" "hihi" => "haha"
08:21:21 <malosh> EvilTerran : okay, not when you want to debug a stack overflow. In fact, not in my case here
08:21:42 <fasta> (Incidentally, you can ask the Smalltalk environment the same question and get a function back which does this. )
08:22:12 <jmcarthur_work> malosh, what is the function that you are folding over the map?
08:22:25 <Vanadium> fasta: Regex will do something like that
08:22:38 <malosh> some trivial (\x->c) with c a constant
08:22:52 <fasta> Vanadium: Someone claimed this worked: b = subRegex (mkRegex src) a dest
08:23:06 <fasta> Vanadium: it doesn't. It only does the replacement once, at least so it seems.
08:23:16 <znusgy> doserj: you're right, the library is installed, and i guess it is part of the ghc package
08:23:24 <malosh> (I use it to compute something, then I do a union with a bigger map, after "constantying" it)
08:23:25 <fasta> Vanadium:  (http://www.brool.com/index.php/python-to-haskell-string-functions)
08:23:27 <jmcarthur_work> malosh, oh this is just some test code? if so, would you mind hpasting it?
08:23:33 <jmcarthur_work> ah
08:23:45 <doserj> znusgy: what version(s) are installed?
08:24:30 <malosh> jmcarthur_work:http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6033#a6033
08:24:36 * edwardk had one of those facepalm moments this morning. I started thinking about my tracing jit and the issues I've been having with figuring out typing of fields within stack frames and realized I should be looking at decompilers for insight into the problem, not JITs.
08:24:45 <znusgy>     Cabal-1.2.3.0, {Cabal-1.6.0.3}
08:25:23 <Taejo> > let {replace _ _ [] = []; replace xs xs' ys == if (xs `isPrefixOf` ys) then (xs' ++ drop (length xs) ys) else (replace xs xs' (tail ys))}
08:25:25 <lambdabot>   <no location info>: parse error on input `}'
08:25:26 <doserj> znusgy: ghc-pkg unregister Cabal-1.6.0.3
08:25:28 <Taejo> @let {replace _ _ [] = []; replace xs xs' ys == if (xs `isPrefixOf` ys) then (xs' ++ drop (length xs) ys) else (replace xs xs' (tail ys))}
08:25:29 <lambdabot>   Parse error
08:25:50 <fasta> Vanadium: never mind.
08:25:55 <edwardk> because decompilers have been facing this problem all along. More over, a decompiler pass (and/or retaining the information in the first place when you control the compiler!) in the first place gives me more control flow information for the jit to use later.
08:26:15 <MaciejP> Can someone tell me where I can find a tarball of the GHC 6.8.3 binary files for windows? I checked ghc/dist/6.8.3 on haskell.org but there's only the installer.
08:26:15 <Vanadium> fasta: At the very least you led me to discover that my text.regex installation appears to be disfunctional
08:26:28 <Taejo> @let {replace _ _ [] = []; replace xs xs' ys = if (xs `isPrefixOf` ys) then (xs' ++ drop (length xs) ys) else (replace xs xs' (tail ys))}
08:26:30 <lambdabot>  <local>:7:0: parse error on input `{'
08:26:38 <edwardk> after all all the code i'm jitting is already there and a flow graph can be constructed giving me more global context.
08:27:17 <edwardk> That and I get another couple of decades worth of research to read.
08:27:23 <quicksilver> fasta: there is no general replacey-type function in Data.List
08:27:33 <quicksilver> fasta: i suggested a (possibly over-general) one a year or two back
08:27:35 <znusgy> doserj: done
08:27:41 <jmcarthur_work> malosh, what's the type of this function?
08:27:44 <doserj> znusgy: then make a Setup.hs clean in the cabal-install package and try to build again
08:28:16 <fasta> quicksilver: I already wrote one (again), but with a different hat.
08:28:29 <quicksilver> fasta: http://haskell.org/pipermail/haskell-cafe/2007-July/028032.html
08:28:42 <jmcarthur_work> malosh, i'm eyeballing your (numStep+1) and (numStep-y)s
08:28:48 <malosh> jmcarthur_work : something like Finite state->Rule state->Int->(IntMap Int)->(IntMap Int)->(IntMap Int, Int)
08:28:54 <jmcarthur_work> accumulators like that should typically be strict
08:28:55 <hydo> I looked through Data.List but I didn't see anything... or perhaps I'm lacking a useful amount of imagination.  Is there a list function that will takeFirst ala takeWhile or do I need to write that myself?
08:28:57 <edwardk> the other set of control flow info i've been poking at is if i can do the last step of linking with llvm object files myself so i can retain their ssa information
08:29:15 <doserj> znusgy: or, if you are building cabal-install from an ebuild, just try again.
08:29:21 <EvilTerran> hydo, er, find?
08:29:24 <EvilTerran> ?type find
08:29:25 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
08:29:28 <malosh> jmcarthur_work : so ?
08:29:43 <jmcarthur_work> malosh, maybe try (+1) $! numStep and (+y) $! numStep instead
08:29:50 <jmcarthur_work> malosh, i'm suspecting that is your stack overflow
08:29:54 <EvilTerran> > find (>6) [3,1,4,1,5,9,2,6]
08:29:55 <lambdabot>   Just 9
08:29:55 <hydo> EvilTerran: ugh!  How did I miss that?
08:30:01 <hydo> EvilTerran: thanks!
08:30:06 <EvilTerran> ?index find
08:30:06 <lambdabot> Data.List
08:30:07 <hackagebot> hashed-storage 0.3.3.1 - Hashed file storage support code. (PetrRockai)
08:30:08 <EvilTerran> :)
08:30:16 <jmcarthur_work> err
08:30:20 <jmcarthur_work> something
08:30:39 <znusgy> doserj: now i get "ghc-6.8.2: unknown package: Cabal-1.6.0.3"
08:30:43 <edwardk> now unfortunately the run time system just needs a decompiler, a compiler, a tracer for x86-64, a jit trace compiler, a linker... and a partridge in a pair tree.
08:31:00 <doserj> znusgy: from the ebuild?
08:31:04 <jmcarthur_work> malosh, probably be nicer with BangPatterns, actually
08:31:07 <znusgy> doserj: yes
08:31:28 <doserj> znusgy: ok, install the ebuild for Cabal again :)
08:33:50 <znusgy> doserj: looks like it is indeed part of the ghc package
08:33:51 <jmcarthur_work> well, use $! if you'd rather i guess. i'm back and forth on bang patterns anyway
08:34:15 <znusgy> so i've got a long compile in store :)
08:35:00 <lpsmith> I like bangpatterns.   They are one of the nicer,  if minor, syntax improvements as of late :-)
08:35:21 <znusgy> doserj: thanks so much for the help!
08:35:58 <doserj> znusgy: Cabal-1.2.3.0 is part of ghc-6.8.2. Cabal-1.6.0.3 is not
08:36:19 <sampointon> isn't Cabal 1.6 part of 6.10?
08:36:59 <doserj> znusgy: And the ebuild for Cabal is called "cabal" :)
08:37:32 <jmcarthur_work> malosh, any luck?
08:38:11 <malosh> jmcarthur_work : no. I tried it, but I don't know what happens. I'm trying to display the trees
08:38:42 <znusgy> great, that's easier :)
08:38:57 <jmcarthur_work> malosh, it's still overflowing the stack? or it's just doing something else wrong?
08:39:09 <malosh> no, still a stack overflow
08:39:14 <jmcarthur_work> hmm
08:39:56 <jmcarthur_work> i didn't even see the fold in that function. are you sure you pasted the one you meant to?
08:40:25 <jmcarthur_work> or are you folding that over another map or something?
08:41:10 <jmcarthur_work> and are you building with optimizations?
08:42:54 <cayennext> I will be presenting Functional Programming with Bananas, Lenses etc to my collegues. I come with idea to code the notation (| |), [( )] in Haskell to show some laws. How can I define special meaning for them in Haskell?
08:44:47 <quicksilver> cayennext: you can't.
08:44:57 <lilac> cayennext: you could use a quasiquoter, i suppose
08:45:06 <quicksilver> cayennext: haskell doesn't support custom outfix / custom brackets
08:45:16 <quicksilver> you can do terrible tricks with type classes and constructors
08:45:37 <quicksilver> you can get Ii ... iI to work.
08:45:57 <quicksilver> or, yes, you can (ab)use one of the existing outfixes, like TH or QQ.
08:46:15 <lilac> if there's a unicode symbol which is appropriate, you could try that, but it'd be an infix operator
08:46:34 <quicksilver> making infixes pretend to be brackets isn't very scalable
08:46:47 <quicksilver> you can't make the precedence work right for nesting, AFAIK.
08:46:55 <lilac> figures :)
08:47:06 <cayennext> If it would be infix I should use extra parens then.
08:48:00 <znusgy> now i have cabal-install and hpodder is built, but how should i install it?
08:49:01 <doserj> znusgy: if you have cabal-install, you can simply 'cabal install hpodder'
08:49:33 <doserj> (which will download hpodder, compile it, and install the binary in ~/.cabal/bin)
08:51:19 <cayennext> I'd rather write a script works on characters and transforms  (|a,b|) into (foldr a b)
08:51:26 <lilac> cayennext: you could probably write a quasiquoter which handled function application, various forms of brackets and nothing else pretty easily
08:51:31 <EvilTerran> cayennext, i'd suggest just having functions with appropriate names, so "banana (...)" (or a better name) represents (|...|), etc
08:52:21 * EvilTerran has noted that it would be possible to add a bracketfix notation to haskell syntax without it overlapping anything existant and valid
08:53:03 <hatds> make a proposal
08:53:04 <hatds> :)
08:53:05 <quicksilver> EvilTerran: by adding a new lexical class for bracketfix operators?
08:53:40 <EvilTerran> quicksilver, by making what would be a two-ended section be a function
08:53:42 <quicksilver> EvilTerran: anything which contains either '[' or '(' and at least one other symbol-character is a left-bracket, for example.
08:53:56 <EvilTerran> they'd have to be wrapped in (...), the way i was thinking of it
08:54:12 <quicksilver> (# ... #)
08:54:16 <quicksilver> where # is metasyntax
08:54:20 <quicksilver> for 'any valid operators'
08:54:22 <quicksilver> right?
08:54:26 <EvilTerran> exactly
08:54:26 <quicksilver> valid but matching, of course.
08:54:36 <quicksilver> yeah that would work.
08:54:42 <sampointon> (^ (-) ^)?
08:54:46 <EvilTerran> not necessarily matching
08:54:57 <quicksilver> (++ x --)
08:54:59 <byorgey> matching... or inverse?
08:55:00 <EvilTerran> (< ... >)
08:55:01 <quicksilver> that would look weird
08:55:04 <quicksilver> oh, I see
08:55:06 * quicksilver ponders
08:55:13 <lilac> it conflicts with the generalized section notation where ( #1 ... #2 ) --> \ a b -> a #1 ... #2 b
08:55:22 <lilac> (which i've seen proposed by a few people)
08:55:29 <byorgey> (<++% ...  %++>)
08:55:37 <quicksilver> lilac: bracketfix is more interesting than that, though, to me.
08:55:44 <cayennext> yes, and then run a haskellgolf competition: write a program using emoticons only
08:55:51 <jmcarthur_work> (<~~ ... <~~)
08:55:55 <quicksilver> lilac: I've wanted custom brackets far more often than I've wanted generalised sections.
08:55:56 <EvilTerran> lilac, you could use (OP ... OP)s for one of them, and [OP ... OP] for the other, i guess
08:56:32 <lilac> quicksilver: it needn't conflict. you can say that only 'bracketing' characters count as bracketfix operators -- so ([{| and any other unicode brackets, but not <
08:56:48 <EvilTerran> lilac, or you could just have bracketfix, and, if people want generalized sections, they can write "(++ mid ++) before after = before ++ mid ++ after" themselves
08:57:17 <lilac> EvilTerran: that doesn't mean the same thing
08:57:30 <EvilTerran> that being the definition of a function called, say, (++ .. ++)
08:57:31 <lilac> EvilTerran: (* 3 + 4 *)
08:57:57 <EvilTerran> mm, true
08:58:06 <jmcarthur_work> great... (-# ... #-)
08:58:27 <lilac> EvilTerran: also, you'd have to write "before `(++ mid ++)` after" to use that presumably
08:59:00 <jmcarthur_work> lilac, i think the point would to use it by itself, like foldr (++ mid ++) ""
08:59:03 <EvilTerran> lilac, i was thinking more such things as foldr (++"; "++)
08:59:24 <EvilTerran> as i said, easy resolution; use []s for bracketfix instead
08:59:40 <lilac> yeah, d'oh, if you wanted to use it right away you wouldn't use a section ;-)
09:00:25 <znusgy> hmm, only problem is that it installed in /root/.cabal/bin
09:00:30 <jackall> chuj wam na imie
09:00:42 <jmcarthur_work> znusgy, cabal install --global
09:00:50 <jackall> nusgy is n=user@h-67-101-196-181.nycmny83.dynamic.covad.net * unknown
09:00:50 <jackall> znusgy on #haskell
09:00:50 <jackall> znusgy using irc.freenode.net http://freenode.net/
09:00:50 <jackall> znusgy End of /WHOIS list.
09:01:04 <znusgy> i tried disabling `user-install' in /root/.cabal/config...
09:01:33 <EvilTerran> ... drive-by whois? O.o
09:01:46 <jmcarthur_work> i'm confused
09:02:15 <doserj> znusgy: 'user-install: False' instead of '-- user-install: True' should work
09:02:18 <sampointon> culture jamming, perhaps?
09:03:00 <jmcarthur_work> looked like somebody was testing a bot
09:03:07 <jmcarthur_work> whois on the first nick it sees
09:03:32 <sampointon> jmcarthur: no, looked like a copy and paste job. Missed off the 'z' on the first line
09:03:36 <jmcarthur_work> ah
09:03:42 <jmcarthur_work> yeah i dunno then
09:03:44 <znusgy> doserj, jmcarthur: thanks so much!
09:03:53 <znusgy> hpodder is working
09:04:11 <sampointon> not ruling out a very stupid bot though
09:04:18 <hackagebot> hashed-storage 0.3.3.2 - Hashed file storage support code. (PetrRockai)
09:05:12 <znusgy> it's an awful lot of disk space just for this little program... i guess that means i should explore haskell
09:05:43 <znusgy> thanks again
09:10:38 <tux-foo> twanvl, niet-ping
09:11:25 <fasta> Is the real source code to the Codec.Image.DevIL library available somewhere? As opposed to some hsc generated file which is useless to extend?
09:13:19 <fasta> Oh, it is. It's just that Hackage doesn't show the real source code.
09:14:06 <Vanadium> @help
09:14:07 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
09:16:38 <habitue> Does anyone know of some good examples of Haskeline usage? The documentation is a bit sparse and I am looking to use stuff line tab completion etc
09:16:55 <lilac> @ceal
09:16:56 <lambdabot> somone would expect that trees 500gb hdds of expressions as if they were floppy dicks
09:17:23 <smorg> Is there a way to concatenate a list of tuples? like if i had:
09:17:27 <smorg> > zip "abc" "def"
09:17:28 <lambdabot>   [('a','d'),('b','e'),('c','f')]
09:17:47 <smorg> and wanted to turn it into ['a', b', 'c'...]
09:17:52 <sampointon> you mean, go from that back to ("abc, "def")?
09:18:18 <smorg> more like ['a', 'd', 'b', 'e', 'c', 'f']
09:18:47 <sampointon> concatMap (uncurry (++)) $ zip "abc" "def"
09:18:54 <sampointon> erm. I meant that for lambdabot >.>
09:18:57 <sampointon> > concatMap (uncurry (++)) $ zip "abc" "def"
09:18:59 <lambdabot>   Couldn't match expected type `[a]'
09:19:18 <doserj> concatMap (\(x,y) -> [x,y])
09:19:26 <smorg> oh right concatmap
09:20:46 <lpsmith> >  foldr (\(x,y) zs -> x:y:zs) [] [('a','d'),('b','e'),('c','f')]
09:20:47 <lambdabot>   "adbecf"
09:22:45 <doserj> > zip "abc" "def" >>= uncurry ((. return) . (:))
09:22:47 <lambdabot>   "adbecf"
09:23:47 <habitue> ... wow
09:23:47 <smorg> :P
09:23:49 <habitue> lol
09:24:08 <smorg> whats the \
09:25:00 <lpsmith> the \ is an anonymous function
09:25:47 <lpsmith> it's kind of looks like a greek letter lambda,  if you close your eyes and wave  your hands enough :-P
09:26:02 <jmcarthur_work> > Data.Foldable.fold . transpose . map (uncurry $ (. return) . (:)) $ [('a','d'),('b','e'),('c','f')]
09:26:03 <lambdabot>   "abcdef"
09:26:58 <byorgey> \x -> foo   is a function which takes the parameter 'x' and computes the result 'foo'
09:27:09 <byorgey> > (\x -> x + 3)  5
09:27:10 <lambdabot>   8
09:27:38 <jmcarthur_work> > uncurry (++) . unzip $ [('a','d'),('b','e'),('c','f')]
09:27:39 <lambdabot>   "abcdef"
09:28:12 <jmcarthur_work> you guys led me astray with that uncurry $ (. return) . (:) stuff!
09:28:15 <sampointon> @hoogle (a, a) -> [a]
09:28:16 <lambdabot> Data.Ix range :: Ix a => (a, a) -> [a]
09:28:16 <lambdabot> System.Random randomRs :: (Random a, RandomGen g) => (a, a) -> g -> [a]
09:28:16 <lambdabot> Prelude snd :: (a, b) -> b
09:28:22 <doserj> jmcarthur: they do different things
09:28:30 <roconnor> @src sum
09:28:31 <lambdabot> sum = foldl (+) 0
09:28:40 <smorg> ah thats cool - like shorthand for let foo in ...
09:29:00 <jmcarthur_work> oh i missed that he changed what the answer should have been
09:29:11 <jmcarthur_work> i thought "adbecf" was wrong
09:29:29 <tiedtoatree> @hoogle uncurry
09:29:29 <lambdabot> Prelude uncurry :: (a -> b -> c) -> (a, b) -> c
09:29:29 <lambdabot> Data.Tuple uncurry :: (a -> b -> c) -> (a, b) -> c
09:29:31 <roconnor> @unpl uncurry $ (. return) . (:)
09:29:31 <lambdabot> (uncurry (\ f i -> ((:)) f (return i)))
09:29:40 <roconnor> gah
09:29:44 <lpsmith> foldr and foldl are your friends :-)
09:29:46 <roconnor> unpl needs some work
09:29:46 <lpsmith> hahah
09:30:13 <sampointon> roconnor: well, it made it pointful, at least :)
09:30:15 <byorgey> I like  ((:))
09:31:30 <Vanadium> :))
09:32:21 <byorgey> sort of a double-headed, bearded smiley creature
09:32:34 <roconnor> ((:[]))
09:32:49 <byorgey> bearded monkey robot with a hat?
09:33:13 <smorg> @faq Can haskell do that?
09:33:13 <lambdabot> The answer is: Yes! Haskell can do that.
09:34:37 <lilac> @faq Can Haskell lie to me?
09:34:38 <lambdabot> The answer is: Yes! Haskell can do that.
09:35:12 <Badger> @faq can Haskell cease to exist?
09:35:12 <lambdabot> The answer is: Yes! Haskell can do that.
09:35:43 <Vanadium> @faq Can Haskell generate a task that not even Haskell can do?
09:35:43 <lambdabot> The answer is: Yes! Haskell can do that.
09:35:47 <mux> @faq can Haskell produce a crashing executable from a well-typed source code?
09:35:48 <lambdabot> The answer is: Yes! Haskell can do that.
09:35:57 <tiedtoatree> How does a function with type a_1 -> a_2 -> ... -> a_n get casted to a -> b -> c? does my question even make sense? :)
09:36:34 <sampointon> tiedtoatree: a = a_1, b = b_2, c = (a_3 -> a_4 -> ... -> a_n)
09:36:49 <sampointon> tiedtoatree: that's partial application in action, functions returning other functions
09:38:16 <lilac> @@ @unpl @pl \(f,i) -> f:[i]
09:38:17 <lambdabot>  uncurry (\ d g -> ((:)) d (return g))
09:38:33 <Badger> good grief
09:38:35 <Badger> @@
09:38:42 <lilac> @@ @type @unpl @pl \(f,i) -> f:[i]
09:38:44 <lambdabot>  forall b. (b, b) -> [b]
09:38:47 <sampointon> awesome, it's like an auto-obfuscator
09:39:08 <doserj> the uncurry (\ x y -> ...) really should be rewritten by unpl
09:39:14 <tiedtoatree> thank you! for some reason I thought it would have gone a = (a_1 -> ... -> a_{n-2}), etc..
09:39:59 <tiedtoatree> is there a way i could have tested that myself in ghci?
09:40:30 <lilac> @@ @redo @unpl @pl @undo do x <- foo; y <- bar; return (x + y)
09:40:31 <lambdabot>  (\ d -> fmap ((do { a <- foo; (+) a}) d) bar)
09:41:17 <tiedtoatree> something like "Prelude> :t (a->b->c) :: (d->e)" is obviously incorrect
09:42:58 <sampointon> @@ @unpl @pl \ f g x y -> f x $ g x y
09:42:59 <lambdabot>  (\ d e -> d >>= \ b -> e >>= \ a -> return (\ h -> b (a h)))
09:43:06 <lilac> @@ @unpl @pl @undo do x <- [1,2,3]; y <- [10,20]; return (x + y)
09:43:08 <lambdabot>  (\ d -> fmap ((([1, 2, 3]) >>= (+)) d) ([10, 20]))
09:43:11 <lilac> ^^ that's actually wrong
09:43:27 <lilac> @@ @run @unpl @pl @undo do x <- [1,2,3]; y <- [10,20]; return (x + y)
09:43:29 <lambdabot>   Couldn't match expected type `t -> a' against inferred type `[a1]'
09:43:32 <lilac> @@ @run @pl @undo do x <- [1,2,3]; y <- [10,20]; return (x + y)
09:43:34 <lambdabot>   [11,21,12,22,13,23]
09:44:15 <lpsmith> :t (undefined :: a -> b) :: c -> d -> e
09:44:16 <lambdabot> forall c d e. c -> d -> e
09:44:29 <lpsmith> :t (undefined :: a -> b -> c) :: d -> e
09:44:30 <lambdabot>     Couldn't match expected type `e' against inferred type `b -> c'
09:44:30 <lambdabot>       `e' is a rigid type variable bound by
09:44:30 <lambdabot>           an expression type signature at <interactive>:1:35
09:44:47 <lilac> it's messed up the precedence of (.) and (>>=)
09:45:07 <lilac> @@ @pl @undo do x <- [1,2,3]; y <- [10,20]; return (x + y)
09:45:08 <lambdabot>  (`fmap` [10, 20]) . (+) =<< [1, 2, 3]
09:45:37 <lpsmith> tiedtoatree:  casting isn't the right terminology,  haskell doesn't cast.   One type unifies with another (or not.)
09:46:29 <Philonous1> tiedtoatree: It becomes more clear if you remember that (->) is right-associative. i.e. a->b->c->d  = a -> (b->(c->d))
09:46:53 <lpsmith> :t const
09:46:54 <lambdabot> forall a b. a -> b -> a
09:46:59 <lpsmith> :t id
09:47:01 <lambdabot> forall a. a -> a
09:47:04 <lpsmith> :t const id
09:47:06 <lambdabot> forall a b. b -> a -> a
09:47:55 <sampointon> @unpl const id
09:47:55 <lambdabot> (\ _ b -> b)
09:48:06 <sampointon> hey, I think that's the first good one all day
09:48:14 <tiedtoatree> Philonous1: it certainly does! thanks
09:49:02 <Beelsebob> is there anywhere a machine readable index of the Hierarchical libraries?
09:49:42 <lpsmith> sampointon:  actually,  in this particular case,  you can tell exactly what the function does from it's type alone
09:49:48 <smorg> Philonous1: really Its always right associative? So thats why it never makes sense to me...
09:49:50 <lament> Beelsebob: well GHC gets it from somewhere...
09:50:05 <sampointon> lpsmith: oh, I know, I was seeing if @unpl made a mess of it
09:50:32 <lilac> is there a typeclass somewhere with something like 'typename :: TypeName a => Phantom a -> String'?
09:50:32 <Beelsebob> lament: sure -- what I'm trying to do is avoid writing a custom version of haddock
09:52:18 <lilac> Beelsebob: i think hoogle has one of those
09:53:00 <Beelsebob> lilac: yeh, I think so too, basically what I'm looking for is a way that I can get machine readable documentation reliably, without just downloading all the source code to the libraries
09:53:10 <Beelsebob> and then parsing all of it
09:53:12 <doserj> lilac: showsTypeRep . typeOf ?
09:53:34 <Phyx> odd
09:53:35 <quicksilver> Beelsebob: I think if there was a better way, hoogle would use it.
09:53:41 <Beelsebob> bugger :(
09:53:46 <quicksilver> Beelsebob: since hoogle does it by patching into haddock
09:53:50 <quicksilver> I fear that is, in fact, the best way
09:54:08 <Beelsebob> maybe the correct thing for me to do then is to patch into haddock, and use it to generate a machine readable format
09:54:23 * Beelsebob shudders at the thought of something smelly like xml
09:54:28 <Phyx-> hehehe
09:54:42 <Phyx-> xml isn't smelly if used conservatively
09:55:08 <mux> xml isn't smelly period
09:55:27 <gnuvince> mux: except when it's written on a whiteboard
09:55:29 <dschoepe> It is very smelly when used for configuration files that are expected to be edited by the user.
09:55:34 <mux> gnuvince: I'll concede that :-)
09:55:41 <Beelsebob> mux: it is very much so -- it's scheme, only with extra verbosity for no reason
09:55:49 <Phyx-> dschoepe: it's so structured you can write a gui to edit it :P
09:55:51 <mux> dschoepe: as every tool, it is quite often misused, this is not xml being smelly but people being stupid
09:56:04 <Phyx-> infact i did, wrote a program that generates a gui to edit the given xml
09:56:33 <Philippa> got a console version?
09:56:35 <smorg> > concat $ transpose ["abc", "def"]
09:56:36 <lambdabot>   "adbecf"
09:56:38 <tiedtoatree> is (a->b) -> c the same as a -> b -> c? I'm really hoping that it's not.
09:56:46 <sampointon> mux: I contend that some XML technology is inherently smelly: http://www.w3.org/TR/xqueryx/#Examples
09:56:59 <Philippa> it's not, a -> b -> c = a -> (b -> c)
09:57:46 <mux> sampointon: there's a gazillion standards revolving around XML, some that are never going to get used - I didn't even know about XQueryX, and personally I would not even qualify this as xml
09:58:01 <mux> that's totally open to interpretation of course
09:58:04 <Saizan_> Beelsebob: if you pass --hoogle to haddock it gives you a quite readable format
09:58:15 <tiedtoatree> Great! So then it makes sense to talk about parameters of a function which MUST be functions ?
09:58:31 <Philippa> yes
09:58:41 <sampointon> tiedtoatree: yeah, think about, say, the first argument of map
09:58:52 <sampointon> tiedtoatree: it makes no sense at all for that not to be a function
09:59:21 <jmcarthur_work> :t map
09:59:23 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
09:59:47 <gwern> of course, hoogle does not actually use --hoogle's output
10:00:00 <tiedtoatree> yes i agree, but if you were to ask me, function currying didn't make sense last week either :)
10:00:11 <tiedtoatree> just making sure i've got my facts straight
10:00:31 <Vanadium> What is this forall a b notation :|
10:00:59 <Zao> It's a keyword, or not, depending on extensions.
10:01:00 <Vanadium> Is that like Show a => except without the Show
10:01:06 <byorgey> Vanadium: it just indicates polymorphism.
10:01:15 <Zao> http://en.wikibooks.org/wiki/Haskell/Polymorphism
10:01:23 <byorgey> it means that any type can be substituted for a.
10:01:29 <Vanadium> I thought I got polymorphism without saying forall
10:01:36 <Beelsebob> Saizan_: passing --hoogle to haddock appears to give no output at all :/
10:01:37 <byorgey> Vanadium: yes, the forall is implicit
10:01:50 <byorgey> Vanadium: but you can also write it explicitly.  (sometimes writing it explicitly is useful).
10:02:14 <Vanadium> Mechanically useful or only useful for understanding the code?
10:02:18 <byorgey> Vanadium: (a -> b) -> [a] -> [b] is implicitly the same type as  forall a b. (a -> b) -> [a] -> [b]
10:02:31 <lpsmith> Vanadium:  using explicit foralls and {-# LANGUAGE ScopedTypeVariables #-} can be very useful.
10:02:41 * mux seconds lpsmith 
10:02:46 <byorgey> Vanadium: no, it's actually useful beyond just for understanding.
10:02:54 <mux> there are some functions you just cannot write without this
10:03:09 <byorgey> yes, for scoped type variables, or for higher-rank functions (i.e. functions which take polymorphic functions as arguments)
10:03:27 <lpsmith> :t runST
10:03:29 <lambdabot> forall a. (forall s. ST s a) -> a
10:03:43 <Phyx-> yeah, but if the function isn't higher-rank, explicitly writing it has no point
10:03:52 <mux> it is also useful for polymorphic components and existentials
10:03:57 <mux> but those are more rarely used
10:04:10 <Saizan_> Beelsebob: are you also giving the other arguments correctly?
10:04:17 <Saizan_> Beelsebob: you can try cabal haddock --hoohle
10:04:32 <Saizan_> Beelsebob: "cabal haddock --hoogle"
10:04:40 <Saizan_> Beelsebob: it should produce a $pkg.txt
10:04:47 <giulianoxt> hey. beginner here. something like :t runST  reminds me of first order logic
10:04:49 <giulianoxt> what's the relation?
10:05:04 <mux> ouch, long answer here
10:05:06 <lpsmith> hahaha,  good question.
10:05:08 <Beelsebob> ah, so it does, I was expecting a .hoo file
10:05:10 <Vanadium> I think I see, thanks for the explanation
10:05:13 <Beelsebob> thanks Saizan_
10:05:15 <Philippa> very close to isomorphism :-)
10:05:19 <mux> someone please explain the curry-howard isomorphism now :-)
10:05:19 <giulianoxt> heheh
10:05:26 <giulianoxt> a link would suffice :p
10:05:49 <Philippa> giulianoxt: you can view the types as propositions and the terms as proofs. The corresponding logic's unsound, of course - wouldn't be a turing complete language otherwise
10:06:03 <gwern> Beelsebob: no, --hoogle produces the *old* hoogle format
10:06:13 <Saizan_> Beelsebob: do you know if the .haddock files have all the interesting information or not?
10:06:26 <Philippa> tupling is conjunction, the Either type gives you disjunction, the function arrow is implication. Please don't ask about negation for now :-)
10:06:33 <gwern> Beelsebob: you have to take --hoogle's output and use the hoogle bin to mangle it into the actual binary trie .hoo file databases which hoogle >4 use for speed
10:06:44 <lpsmith> oh,  but everybody loves call/cc!
10:06:54 <Beelsebob> gwern: ah, I see
10:06:58 <Philippa> giulianoxt: that make enough sense for you? There are actually theorem provers that're also functional languages as a result
10:07:00 <Beelsebob> cheers muchly everyone
10:07:27 <giulianoxt> Philippa: Kinda. I'd seen this before, will look in to it.
10:10:08 <lpjhjdh> is there some way in smallcheck to somehow match over generated data?
10:13:11 <lpjhjdh> oh, nevermind, being foolish
10:16:48 <Phyx-> "Appeals Court Backs Prison for E-Mail Obscenity" <-- wth?
10:23:51 <izmirlibebek> hi
10:23:58 <Phyx-> hi
10:24:09 <izmirlibebek> from?
10:26:39 <hackagebot> hsx 0.5.2 - HSX (Haskell Source with XML) allows literal XML syntax to be used in Haskell source code. (NiklasBroberg)
10:27:02 <Phyx-> ...
10:40:11 <lilac> does SYB work with GADTs?
10:44:00 <dysinger_> izmirlibebek #haskell is not the best place to find people for sex http://pastie.org/516644
10:52:57 <gwern> @quote
10:52:58 <lambdabot> megeria says: i am so new to haskell that i still have the new car smell
10:53:11 <gwern> his other car is a cdr
10:53:21 <noteventime> Haha
10:53:29 <Elly> I think I have a quote!
10:53:31 <Elly> @quote Elly
10:53:32 <lambdabot> Elly says: Rule 1 of malloc is the same as rule 1 of air travel: "Attempt at all costs to keep your number of landings equal to your number of takeoffs."
10:53:33 <Elly> I do!
10:53:36 * Elly dances
10:54:13 <aempirei> wheres the newsham
10:54:22 <Phyx-> lol
10:54:29 <trofi> @flush
10:54:30 <lambdabot> Not enough privileges
10:54:31 <jmcarthur_work> @quote jmcarthur
10:54:32 <lambdabot> No quotes match. The more you drive -- the dumber you get.
10:54:34 <jmcarthur_work> aw
10:54:40 <jmcarthur_work> @quote geezusfreeek
10:54:41 <lambdabot> geezusfreeek says: i was half hoping lambdabot would lie and make something up :)
10:54:42 <gwern> @quote newsham
10:54:43 <lambdabot> newsham says: over here in america we take people with all sorts of names (except Mohammad)
10:54:43 <jmcarthur_work> @quote geezusfreeek
10:54:44 <lambdabot> geezusfreeek says: i was half hoping lambdabot would lie and make something up :)
10:54:48 <jmcarthur_work> bleh, lame quote
10:54:56 <gwern> @quote jmcarthur
10:54:57 <lambdabot> No quotes match. Maybe if you used more than just two fingers...
10:55:02 <Phyx-> @quote Phyx-
10:55:03 <lambdabot> No quotes match. :(
10:55:06 <Phyx-> lol
10:55:08 <gwern> is no quote lamer than a quote?
10:55:14 <gwern> @quote Phy
10:55:15 <lambdabot> lament says: haskell and asm are not equivalent, can you blank all your RAM and then physically damage some hardware in Haskell?
10:55:27 <gwern> @quote Phy
10:55:27 <lambdabot> lament says: haskell and asm are not equivalent, can you blank all your RAM and then physically damage some hardware in Haskell?
10:55:35 <gwern> sorry Phyx-
10:55:37 <gwern> be more witty
10:55:43 <Phyx-> hahahah
10:55:50 <Phyx-> i'll try
10:55:55 <gwern> my quotes, let me show you dem
10:55:57 <gwern> @quote gwern
10:55:57 <lambdabot> gwern says: [regarding the naming of Monoids] we will call them CuteFluffableThings, since you can put more fluff into them, but no one would remove fluff from a cute thing
10:56:16 <Phyx-> lol
10:56:33 <gwern> @quote gwern
10:56:34 <lambdabot> gwern says: actually, i define bottom to equal 1 in all my programs, so I can guarantee they will never crash
10:56:35 <lilac> @remember gwern his other car is a cdr
10:56:36 <lambdabot> Good to know.
10:58:10 <gwern> @quote gwern
10:58:11 <lambdabot> gwern says: Unfortunately Neo, no one can be *told* what the Monad is.
10:58:40 <gwern> @quote gwern
10:58:41 <lambdabot> gwern says: good news everyone! we heard you like interpreters so we used the 3rd futamura projection to interpret your compiler so you can compile while you interpret!
10:59:10 <lilac> haha
10:59:24 <lilac> i love the "good news everyone" :)
10:59:26 <Zao> I still misread that as futurama projection.
10:59:35 <gwern> @quote gwern
10:59:36 <lambdabot> gwern says: drat. what *do* all you people talk about? only one bacon and one zombie quote
10:59:45 <c_wraith> You finally have a good understanding of what monads are when you say "wait, there's so much less to that than I thought"
10:59:50 <gwern> and that's enough from me :)
10:59:55 <gwern> @quote Zeo
10:59:56 <lambdabot> No quotes match. Have you considered trying to match wits with a rutabaga?
10:59:57 <gwern> @quote Zao
10:59:58 <lambdabot> No quotes match.
11:00:08 <gwern> hm. I was sure there was a zao quote in there
11:00:09 <gwern> @quote Za
11:00:10 <lambdabot> vincenz says: strict evaluation is premature optimization
11:00:15 <gwern> @quote Za
11:00:16 <lambdabot> qwe1234 says: good lord, help me. i feel like i'm trapped in a website full of elizabots.
11:00:20 <lpsmith> is there a way to increase the precision of System.CPUTime?
11:00:22 <gwern> @quote Za
11:00:23 <lambdabot> qwe1234 says: good lord, help me. i feel like i'm trapped in a website full of elizabots.
11:00:25 <Zao> Maybe it's been flushed?
11:00:29 <gwern> nope :(
11:00:40 <lpsmith> 10 milliseconds seems pretty darn coarse
11:00:41 <Zao> Oh well, you have me live :P
11:00:46 * gwern thinks that Zao thinks @flush does something it doesn't
11:01:09 <Zao> I didn't know there was a flush command on it.
11:01:18 <jmcarthur_work> @help flush
11:01:18 <lambdabot> flush. flush state to disk
11:01:21 <Zao> More along the lines of critical failure or owner change.
11:01:50 <gwern> @quote flush
11:01:51 <lambdabot> Axman6 says: what's @flush do? saves stuff to dick?
11:02:01 <jmcarthur_work> haha
11:02:08 <gwern> that was a great typo
11:02:12 <gwern> @flush
11:03:19 <lilac> @quote
11:03:20 <lambdabot> MyCatVerbs says: Amdahl's law is mostly to be used for making people feel depressed. :)
11:03:31 <lament> @quote
11:03:32 <lambdabot> Gracenotes says: omg. Japanese schoolgirl outfits are so cute
11:03:38 <p_l> hell yeah
11:04:36 <gwern> @quote
11:04:37 <lambdabot> ValarQ says: l33t_h4x0r: could you help me port GHC to the AVR architecture? <-- l33t_h4x0r has left #haskell
11:04:55 <lilac> @quote lilac fix
11:04:56 <lambdabot> lilac says: fix f = fix where fix = f fix
11:05:00 <gwern> not even leet hackers want to work on ghc :(
11:05:22 <Phyx-> 20:03:26 < lambdabot> Gracenotes says: omg. Japanese schoolgirl outfits are so cute
11:05:25 <Phyx-> ROFL
11:05:30 <gwern> lilac: nameshadowing like that is evil
11:05:38 <Alpounet> gwern, huh ?
11:05:59 <Paczesiowa> is there name shadowing that is not evil?
11:06:18 <lilac> gwern: perhaps, but i couldn't make it a palindrome otherwise
11:06:30 <gwern> Paczesiowa: well, the nameshadowing involved in recursion, I suppose
11:06:44 <lilac> or whatever you call a palindrome-only-with-words-instead-of-letters
11:06:46 <Gracenotes> :o
11:06:59 <gwern> lilac: true, true. If I go around saying 'J'accuse tu, Pikachu!', I can hardly criticize your language
11:07:12 <Gracenotes> :3
11:07:26 <Gracenotes> (｡◕‿‿◕｡)
11:07:32 <jmcarthur_work> AH
11:07:38 <gwern> Gracenotes: no look-of-disapproval?
11:07:40 <lpsmith> Nothing wrong with name shadowing.   Better to have it than not!
11:07:56 <gwern> lpsmith: well, considering the alternative I suppose
11:07:58 <Gracenotes> look_of_pikachu
11:08:04 <monochrom> PIkachu is so 2000.
11:08:08 <Phyx-> thunder_of_pikachu
11:08:09 <c_wraith> Looks more like jigglypuff. >_>
11:08:25 <Gracenotes> pikachu has those electric pouches
11:08:28 <gwern> (being old  is terrible, except for the alternative)
11:08:29 <Phyx-> come to think of it... is pokemon still around?
11:08:35 <gwern> Gracenotes: but those are rectangles here
11:08:37 <c_wraith> Strong as ever, Phyx-
11:08:45 <Gracenotes> indeed so! Why, I was just playing Platinum the other day
11:08:50 <gwern> Phyx-: oh, of course. the latest video games on the DS have made something of a resurgence
11:08:50 <Phyx-> gwern: alternatives? dead?
11:08:54 <Gracenotes> the 4th generation of games.
11:08:55 <lilac> aww, you can't @let (｡◕‿‿◕｡)
11:08:55 <c_wraith> gwern, they render just fine for me.  set your client to utf8!
11:08:56 <monochrom> You people are so yesteryear.
11:09:06 <Gracenotes> where the first pokemon generation is red/blue/yellow
11:09:07 <gwern> c_wraith: my client utf'd your mom!
11:09:08 <Phyx-> gwern: lol
11:09:16 <Phyx-> is ash still the main character?
11:09:19 <c_wraith> my poor mom! :(
11:09:29 <gwern> Phyx-: nah, that effiminate pansy is history
11:09:36 <lilac> gwern: c_wraith's mom is latin1!
11:09:38 <Gracenotes> Phyx-: well. in the anime, he still is, among others
11:09:45 <Phyx-> what i don't get, if in every pokemon they "catch em all" wtf is he catching in the next one
11:09:47 <Gracenotes> ash never really was in the games
11:09:49 <gwern> lilac: so she's used to getting it on with every client!
11:10:00 <Gracenotes> Phyx-: new pokemon are introduced every generation
11:10:22 <gwern> apparently the pokemon world suffers from a tremendous rate of extinction. no doubt due to overhunting
11:10:25 <monochrom> That's like asking what's the next language after Haskell.
11:10:33 <Gracenotes> with now there are 493 pokemon
11:10:35 <Gracenotes> right
11:10:54 <Gracenotes> speaking of which, I just beat Fantina the other day. gym leader.
11:11:06 <Phyx-> monochrom: Iskall
11:11:16 <lilac> I find the Pokemon phenomenon bearable mostly because when I hear or read the word "Pokemon" I imagine it means "Venereal Disease"
11:11:17 <Paczesiowa> looks like everybody understood category theory and you moved on to pokemon stuff...
11:11:17 <gwern> Gracenotes: too much information
11:11:18 <monochrom> Hahaha
11:11:29 <lilac> "Gotta catch 'em all!"
11:11:35 <Gracenotes> lol
11:11:46 <mauke> I choose you, Picasso!
11:11:47 <Phyx-> i suppose i should try it
11:11:48 <Gracenotes> gwern: there is no ambiguity there!
11:11:52 <Phyx-> last one i played was yellow
11:11:57 <Alpounet> I really never though I'd read Pokemon stuffs here, guys.
11:12:03 <Gracenotes> on a game level it's just an interesting RPG, sans MMO
11:12:05 <Alpounet> :p
11:12:32 <Gracenotes> except the latest version has allowed battling other humans via wifi connections. like many other consoles.
11:12:39 <Zao> Pokeballs are polymorphic containers.
11:12:47 <Phyx-> Gracenotes: except the stupid ds supports only WEP
11:12:57 <Phyx-> Zao: hahaah
11:13:10 <Gracenotes> oh, right. Someone might hack into your game and get your moves :o
11:13:13 <Phyx-> You know... it's saying something, haskell programmers and pokemons
11:13:20 <burp> no!
11:13:32 <gwern> pokemon might be a mediocre strategy game, except they keep introducing brokenly powerful monsters
11:13:43 <Gracenotes> eh. do not associate them with my odd interests
11:13:50 <Phyx-> hahahha
11:13:55 <gwern> like with red-blue, was there anyone without a mewtwo or 2 in their party? or at least one of the legendary birds?
11:13:58 <lilac> Zao: when;re they going to introduce rank-2 pokemon?
11:14:08 <Phyx-> I wonder why nintendo hasn't introduced "pokemon hotspots"
11:14:14 <Gracenotes> gwern: that's why competitive battling has grown over the years
11:14:17 <Phyx-> come sync up to receive your free rare pokemon
11:14:23 <Gracenotes> Phyx-: ..... they do
11:14:26 <Phyx-> :O
11:14:28 <Alpounet> > [1..10] >> [1,2]
11:14:29 <lambdabot>   [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2]
11:14:29 <Gracenotes> they're called events
11:14:42 <gwern> Phyx-: well, the pokemon store in manhattan used to give random shiny pokemon, one per day
11:14:52 <Phyx-> lilac: isn't that when they evolve?
11:15:07 <Phyx-> lilac: mewtwo was RankN :P
11:15:17 <Gracenotes> well, what about when they retroactively introduce baby pokemon. I wonder if that changes the ranks.
11:15:24 <Phyx-> lol, pokemon store
11:15:36 <gwern> Phyx-: I'd say mewtwo's very name suggests the Rank2Types pragma
11:15:52 <Phyx-> hmmm, you have a point there
11:15:59 <p_l> ... I didn't expect that when I stumbled into #haskell...
11:16:23 <Phyx-> hahahah
11:16:32 <Gracenotes> no one expects [..]
11:16:42 <Gracenotes> the overused monty python reference
11:16:50 <gwern> it was one of the best skits
11:16:51 <Phyx-> it's a consequence of being lazily evaluated
11:17:53 <Gracenotes> hm. I find the continuation-type means of storing data interesting.
11:19:15 <Gracenotes> where constructors are made into continuation arguments, and the types of the constructors are functions which give the data in the constructor
11:19:42 <Gracenotes> e.g. for Either a b, forall o . (a -> o) -> (b -> o) -> o
11:20:06 <Phyx-> @type everywhere
11:20:08 <Gracenotes> for List a, forall o. (a -> List a -> o) -> o -> o
11:20:08 <lambdabot> forall a. (Data a) => (forall a1. (Data a1) => a1 -> a1) -> a -> a
11:20:48 <Saizan> Gracenotes: you should read about Ran then :)
11:21:06 <Gracenotes> yes, I've seen it before
11:21:24 <Gracenotes> except some deconstructions are Rans, apparently, and some aren't?
11:21:43 <Gracenotes> or maybe that was kan extensions.
11:21:55 <Gracenotes> left, of course
11:22:08 <mauke> Ran = Ranma ½ ?
11:23:10 <gwern> mauke: or one of akira kurosawa's most famous movies after rashomon and the seven samurai
11:26:22 <anq> Hello. What is your opinion on that "Write yourself a Scheme ..." tutorial?
11:27:17 <Phyx-> gwern: i thought it was a series
11:27:26 <byorgey> anq: it's nice as a parsec tutorial.  not so great as a Haskell tutorial, IMO.
11:28:00 <anq> byorgey, for someone who understands most foundational aspects of Haskell, would reading Parsec's code and documentation be more advisable?
11:28:00 <byorgey> but different people find different things useful, so don't just take my word for it. =)
11:28:06 <newsham> hi.
11:28:26 <Phyx-> wow, that actually worked
11:28:46 <byorgey> anq: probably.  there's good documentation for Parsec 2.
11:28:53 <copumpkin> moo
11:28:58 <anq> I find the tutorial way too presumptuous for people who don't know Haskell, and insufficiently detailed for a Parsec tutorial, to be honest, byorgey.
11:29:17 <byorgey> anq: yeah, that sounds about right. =)
11:29:39 <anq> byorgey, I'll look into that, thanks. :)
11:29:43 <byorgey> anq: the parsec documentation here is good, and includes a mini-tutorial: http://legacy.cs.uu.nl/daan/download/parsec/parsec.html
11:29:47 <byorgey> but that's for Parsec 2
11:29:59 <byorgey> Parsec 3 is out now, but there's not as much documentation.
11:30:31 <anq> Is Parsec 3 compatible with most of the older version(s)?
11:30:33 <Botje> parsec 3 hsa much the same interface
11:30:49 <Phyx-> never used parsec, only uu-parsinglib
11:30:53 <byorgey> it's similar but not "compatible".
11:30:54 <Botje> the types have changed a bit and it supports Bytestrings now, but it's still the same
11:31:02 <Philippa> anq: use 2 for now
11:31:05 <byorgey> i.e. if you write code for parsec 2 and try to upgrade, it will probably break.
11:31:18 <anq> Well, as a learning experience, Parsec 2 will do.
11:31:20 <Philippa> byorgey: that's really not the case
11:31:33 <byorgey> Philippa: oh, it's not?  I stand corrected then.
11:31:38 <Philippa> bar one renaming I'm a little irritated by and a couple of minor details most users really won't stumble into
11:31:40 <byorgey> I thought a bunch of the types changed and so forth.
11:31:43 <Phyx-> what does this warning mean? "Test.hs:34:9: Warning: orphan instance: instance Arbitrary Expr"
11:31:50 <Philippa> there are backwards-compatible synonyms
11:31:57 <byorgey> Philippa: ok, cool.  I admit I've never used 3.
11:32:06 <mauke> Phyx-: an orphan instance is an instance that is not in the same module as the class or type definition
11:32:28 <mauke> Phyx-: (it's less efficient in ghc, so it warns for it)
11:32:37 <Phyx-> ah ok
11:32:41 <monochrom> The incompatible stuff in Parsec 3 is put under new module names. The compatible stuff is put under old module names.
11:32:41 <Phyx-> thanks
11:32:49 <anq> Thanks, byorgey, Philippa. :)
11:32:59 <hatds> I thought orphan instances was more about sanity :)
11:37:28 <jmcarthur_work> yeah it's about the possibility of conflicting instances and stuff
11:37:34 <Philippa> monochrom: it's also not that huge a compatibility break once you've imported the right instances
11:50:13 <mmorrow> this is a really neat paper  http://kyagrd.dyndns.org/wiki/SparseBitmapsForPatternMatchCoverage
11:50:28 <mmorrow> ( http://hackage.haskell.org/package/sparsebit)
12:03:28 <Phyx-> so guys, does anyone know a library that goes from the Match type in haskell-src-ext to some form of lambda calculus and back?
12:11:07 <mmorrow> Phyx-: once you've got the function skeleton (w/ the 30 cases) made, it shouldn't be too bad
12:11:49 <Phyx-> mmorrow: hahaha, was hoping to avoid that :P
12:12:28 <Phyx-> a professor once told me, for almost every problem, there's a package on hackage
12:12:34 <Phyx-> guess i found an exception
12:15:23 <mmorrow> Phyx-: here's the output of some TH code that i use for this exact thing all the time:
12:15:25 <mmorrow> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2822#a2822
12:15:33 <mmorrow> (instance-function-skeleton ;)
12:16:07 <mmorrow> then i just copy-paste that into the module and start from there
12:16:41 <mmorrow> i should put this code on hackage too
12:17:38 <ray> hackety sax
12:18:51 <Phyx-> mmorrow: and after that you fill in the RHS right?
12:18:58 <mmorrow> heh, yes
12:19:02 <mmorrow> :)
12:19:26 <Phyx-> i was looking ay Yhc
12:19:38 <mmorrow> yhc-core?
12:19:44 <Phyx-> yeah
12:19:48 <Phyx-> but it doesn't contain a parser
12:20:08 <mmorrow> if you build or install yhc though, you can generate it
12:20:14 <mmorrow> from haskell code
12:20:47 <Phyx-> well, i was looking at the Yhc source, but the parsers all return a polymorphic b, so I don't know what it's parsed too
12:20:49 <mmorrow> (and yhc can parse it too, so maybe with some minimal hackery on yhc you could get something nice)
12:20:50 <Phyx-> to*
12:21:26 <mmorrow> hmm, i haven't looked at yhc's parsers
12:22:29 <Phyx-> hmm btw, that TH code is handy
12:22:41 <mmorrow> you should though be able to use haskell-src(-exts)'s parser, then translate that into yhc-core (relatively) easily though
12:23:08 <mmorrow> Phyx-: zomg that mkFunSkel function has saved me so much time
12:23:46 <Phyx-> yeah, i gotta save it. It would have saved me alot of time
12:23:48 <mmorrow> i'll put that on hackage next chance i get
12:24:00 <mmorrow> (and let you know)
12:24:00 <Phyx-> :)
12:24:10 <skorpan> i'm using "runProcess cmd args Nothing Nothing Nothing out out >>= waitForProcess", but it seems that when i do that, i can't kill the process by hitting C-c... any ideas on how to solve this?
12:25:58 <Phyx-> mmorrow: the problem with using the Exts syntax <-> lambda cal, is that haskell-src(-exts) are undocumented. so while most i can guess what they do, some i'm not sure
12:27:13 * Phyx- wonders why this library has "assert False undefined" in it
12:27:24 <Phyx-> wouldn't doing error be nicer...
12:27:59 <skorpan> why not simply "undefined"
12:28:10 <skorpan> if undefined is what they want
12:28:15 <Phyx-> i would prefer error, because then i can give a sensible error message
12:28:55 <Heffalump> anyone familiar with the threaded/non-threaded runtime differences around?
12:29:54 <mmorrow> Phyx-: what i usually do in those cases is look at the prettyprinted Show output (parsed as an expression, in this case you can even use the same lib!), and just run a bunch of test 5-line-modules through it to see what constructors various syntax maps to
12:29:59 <Zao> There's a non-threaded runtime anymore?
12:30:04 <Heffalump> yes
12:31:40 <mmorrow> Phyx-: if you want to go to lambdacalc or yhc-core, you'll only need a minimal subset of haskell-src-exts, and even a pretty manageable subset of vanilla haskell-src too
12:32:51 <mmorrow> (in this case, i might consider using just haskell-src, but then again if you ever wanted to try to reuse this code to do some other misc with real haskell code, haskell-src is a little sketchy)
12:33:00 <jmcarthur_work> the Identity monad is trivially a comonad, isn't it?
12:33:06 <Phyx-> mmorrow: yeah, we're evaluating wether to do it or not, it would be nice to be able to parse and rewrite whole haskell modules, but it's not a top priority atm
12:33:10 <Phyx-> whether*
12:34:39 <mmorrow> Phyx-: the beauty of writing code that manipulates haskell (or code that manipulates the abstract syn of whatever lang you're coding in itself) is that you can feed it right back into itself... so handy
12:35:11 <Phyx-> mmorrow: that's exactly why we wanted to do it, we wanted to check what would happen if we ran the program through it's own source
12:35:14 <Phyx-> would be a good test
12:35:24 <c_wraith> Is there a good template haskell tutorial out there that demonstrates manipulating the AST of a function?
12:36:19 <mmorrow> then you can start using the program to generate code to make it better at generating code to do stuff that you'd have no chance of doing without code generation
12:36:28 <mmorrow> (or that would just take you a realllly long time)
12:37:38 <Phyx-> lol
12:37:41 <jmcarthur_work> nevermind that was an obvious answer
12:37:59 <jmcarthur_work> i only asked because category-extras has Identity but no Comonad instance for it
12:38:10 <mmorrow> c_wraith: here's TH code that desugars list comprehension, rep by the TH AST also http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2490
12:38:10 <Phyx-> bbl, dinner time
12:38:17 <mmorrow> (and it targets to TH ast too)
12:38:23 <jmcarthur_work> edwardk, ^^
12:38:56 <mmorrow> c_wraith: here's sample output from that code: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2260
12:40:37 <mmorrow> gah, hate it when the syntax highlighter flip out when you use TH '''s and color the next 134 line blue..
12:41:39 <jmcarthur_work> oh maybe it does
12:41:42 <jmcarthur_work> could be way off
12:41:44 <mmorrow> c_wraith: (i used that spj book from the 80's, and the ghc module that desugars list-comps to learn that algo)
12:42:48 <jmcarthur_work> silly me, Identity isn't in category-extras, it's in mtl, duh. so the docs don't include instances that category-extras might have
12:47:19 <Phillemann> Is there any way to create a named pipe in Haskell?
12:47:36 <SamB> @hoogle Posix
12:47:37 <lambdabot> module System.FilePath.Posix
12:47:37 <lambdabot> module Data.Time.Clock.POSIX
12:47:37 <lambdabot> package posix-realtime
12:47:46 <SamB> @hoogle pipe
12:47:46 <lambdabot> package Pipe
12:47:46 <lambdabot> package shell-pipe
12:47:54 <SamB> hmm.
12:47:56 <mathijs> Hi all, anyone in here familiar with HJScript? While I do understand the use of a haskell representation of JS, it's very cumbersome to create javascript this way. I think the main goal of HJScript is to allow higher-level (dsl-like) stuff on top of it, but I couldn't find _any_ libraries built on top of it (as of yet). Does anyone know of a nice example?
12:48:12 <Phillemann> Is @hoogle different from haskell.org/hoogle? o_O
12:48:50 <aledge> does seem to give different results doesn't it
12:48:57 <Phillemann> Indeed.
12:52:43 <bla> Lame question warning: How do I create Word32 out of Ints/Nums? I want to putPixel using SDL and it gets color in 32bit int: 0x00rrggbb I can't do shiftL on normal function argument.
12:53:07 <ClaudiusMaximus> :t fromIntegral
12:53:08 <lambdabot> forall a b. (Integral a, Num b) => a -> b
12:54:09 <Phillemann> Ah, System.Posix.Files.createNamedPipe
12:54:22 <bla> ClaudiusMaximus, thanks, looking into  it.
12:58:51 <Dae_> Hey
12:59:54 <Dae_> Too late for people to be around?
13:00:57 <Dae_> Apparently. Guess I'll just talk to the log then.
13:02:27 <Dae_> Dear log, where oh where is there some sort of documentation for the haskell-src-exts package? Maybe a piece of code doing something with it? Google seems to have failed me in this.
13:02:45 <Dae_> Maybe there isn't any? After all, I guess it's a pretty new package...
13:02:49 <Heffalump> Dae_: The author is writing documentation at the moment
13:02:59 <Dae_> ohh, great!
13:03:07 <Heffalump> so give it a few days/weeks
13:03:16 <Dae_> Thanks Heffalump
13:03:34 * Dae_ postpones his mad preprocessor project
13:11:53 <bla> lambdabot, putStrLn "test"
13:12:02 <bla> (is it usable? Can I use it on query?)
13:12:31 <Phyx-> > putStrLn "test"
13:12:32 <lambdabot>   <IO ()>
13:12:53 <bla> > (10 :: Int) shiftL 10
13:12:54 <lambdabot>   Couldn't match expected type `t1 -> t2 -> t'
13:13:05 <bla> > (10 :: Word32) shiftL 10
13:13:06 <lambdabot>   Couldn't match expected type `t1 -> t2 -> t'
13:13:21 <bla> > ((10 :: Word32) shiftL 10) :: Word32
13:13:23 <lambdabot>   Couldn't match expected type `t -> t1 -> GHC.Word.Word32'
13:13:45 <Cale> > (10 :: Int) `shiftL` 10
13:13:46 <lambdabot>   10240
13:13:54 <bla> ` you say.
13:14:05 <bla> > shiftL 10 10
13:14:07 <lambdabot>   Add a type signature
13:14:10 <Cale> Enclosing a function name in backticks turns it into an infix operator
13:14:17 <Cale> > shiftL 10 10 :: Int
13:14:19 <lambdabot>   10240
13:14:24 <bla> Mhm.
13:14:34 <bla> Neat!
13:14:36 <bla> Thanks.
13:25:32 <Phyx-> > trace 1 ()
13:25:33 <lambdabot>   Not in scope: `trace'
13:25:53 <FliP^2eH> I wonder if I can learn Haskell and C at the same time, without getting a mind blow
13:26:00 <Phyx-> > Debug.Trace.trace 1 ()
13:26:01 <lambdabot>   Not in scope: `Debug.Trace.trace'
13:26:10 <Phyx-> @index trace
13:26:10 <lambdabot> Debug.Trace
13:26:16 <skorpan> lambdabot won't do IO i think
13:26:31 <skorpan> FliP^2eH: if you learn haskell you won't want to learn C
13:26:44 <FliP^2eH> Haskell is the opposite of C
13:26:48 <FliP^2eH> For me.
13:26:52 <Phyx-> it's prolly blocking the function because of the unsafePerformIO
13:26:53 <FliP^2eH> I like to know both extremes
13:26:57 <skorpan> i wouldn't disagree with that
13:27:00 <Zao> Nice, Data.Encoding.JISX0208 took 15 mins to build with half a gig of memory used.
13:27:01 <sbahra> skorpan, why not?
13:27:01 <FliP^2eH> > trace "Meh"
13:27:03 <lambdabot>   Not in scope: `trace'
13:27:04 <Zao> JIS must be complex.
13:27:07 <skorpan> sbahra: why not what?
13:27:15 <sbahra> <skorpan> FliP^2eH: if you learn haskell you won't want to learn C
13:27:20 <trofi> @let trace _ b = b
13:27:22 <lambdabot>  Defined.
13:27:29 <skorpan> sbahra: i was exaggerating of course, but it's sort of true as well...
13:27:33 <FliP^2eH> > trace "tehe"
13:27:35 <lambdabot>   Overlapping instances for GHC.Show.Show (t1 -> t1)
13:27:35 <lambdabot>    arising from a use of...
13:27:41 <FliP^2eH> > trace $ show "tehe"
13:27:42 <lambdabot>   Overlapping instances for GHC.Show.Show (t1 -> t1)
13:27:42 <lambdabot>    arising from a use of...
13:27:43 <FliP^2eH> :d
13:27:45 <skorpan> FliP^2eH: trace takes two arguments
13:27:54 <sbahra> skorpan, no.
13:27:55 <FliP^2eH> Not in MY world
13:28:02 <Phyx-> sbahra: yes
13:28:06 <skorpan> sbahra: no what?
13:28:11 <sbahra> No, it isn't "sort of true".
13:28:18 <roconnor> wheee: fix (1 `cons`) ++ fix (`snoc` 2)
13:28:23 <sbahra> Haskell is great but it isn't suitable for all problems out there. :-)
13:28:25 <trofi> @hoogle trace
13:28:26 <lambdabot> Debug.Trace trace :: String -> a -> a
13:28:26 <lambdabot> module Debug.Trace
13:28:26 <lambdabot> package traced
13:28:48 <FliP^2eH> Especially on all those plattforms out there where no GHC exists!
13:28:57 <FliP^2eH> Those plattforms I'll never code on anywayws
13:29:02 <skorpan> sbahra: that's what i meant with "sort of" ;P but either way, even if haskell wasn't the best tool for it, you could probably use *some* more expressive language than C to do it
13:29:29 <FliP^2eH> I love Haskell for it's Haskellness
13:29:29 <sbahra> "Expressive", I find very few iterative languages to be better than C. :-)
13:29:39 <FliP^2eH> And I like C for it's bareness
13:29:49 <FliP^2eH> Nothing happens without me knowing
13:29:49 <FliP^2eH> etc
13:29:50 <skorpan> i dislike C in its entirety (is that a word?)
13:30:00 <FliP^2eH> C is fine
13:30:23 <skorpan> i'm okay with python, C++ wouldn't *kill* me, but C... ugh.
13:30:31 <FliP^2eH> C++ is the devil
13:30:31 <Twey> C is fine as a compiler target :-P
13:30:37 <Twey> C++ is horrible
13:30:42 <FliP^2eH> It's strive for backwards compatibility
13:30:44 <FliP^2eH> It ruined it all
13:30:48 <Twey> I wouldn't force it on anyone
13:31:01 <FliP^2eH> Pure C, or D
13:31:11 <Vanadium> C++ is adorable
13:31:16 <FliP^2eH> C++ is a bad fork of evolution
13:31:30 <skorpan> what about C do you like more than C++?  just curious
13:31:33 <FliP^2eH> It's destiny is too end
13:32:00 <trofi> c++ is a great subset of c
13:32:01 <FliP^2eH> It has not been corrupted by maniacly trying to keep C supported
13:32:14 <FliP^2eH> No half assed template syntax
13:32:18 <Twey> C++ is about as adorable as a rhinocerous with crusty growths
13:32:19 <skorpan> let's not discuss the politics behind the languages, but the languages themselves
13:32:24 <FliP^2eH> Using > < for templates...
13:32:41 <FliP^2eH> And for bit shifting
13:32:43 <FliP^2eH> AND for comparing
13:32:52 <trofi> $() are better? :]
13:33:03 <FliP^2eH> D has a nice solution on that
13:33:06 <FliP^2eH> Template!()
13:33:10 <FliP^2eH> Not template<>
13:33:15 <skorpan> FliP^2eH: haskell uses . for function composition and qualification... AND probably something else ;P
13:33:32 <skorpan> oh yeah [1..2], there you have another use
13:33:35 <FliP^2eH> But Haskell's type system doesn't cause it to go bulldog
13:33:39 <jmcarthur_work> 5.6
13:33:40 <Twey> skorpan: The difference being that we recognise this as a Bad Thing and are trying to do something about it :-P
13:34:04 <skorpan> i just think bashing the syntax of a language is a low blow
13:34:13 <thoughtpolice> there's a movement to make '.' used in only one possible situation? :p
13:34:17 <FliP^2eH> Syntax is important
13:34:21 <skorpan> sure, syntax matters, but when talking about C++ vs C, syntax is the least of my concerns
13:34:43 <trofi> implicit type cast with overload is funny
13:34:43 <skorpan> i mean you say that you hate C++ but like C.. and all you can come up with is politics and some syntax
13:34:45 <jmcarthur_work> how about this? functional programming in c++ sucks
13:34:52 <skorpan> jmcarthur_work: is it any better in C?
13:35:04 <jmcarthur_work> skorpan, it's even worse in C
13:35:13 <FliP^2eH> It's a drop of personal preference in there, too
13:35:35 <FliP^2eH> Everyone's biased at some point
13:35:38 <Vanadium> I already like C++ more than C just for mandatory function declarations and slightly saner const semantics
13:35:44 <skorpan> i understand that, i was just curious
13:35:44 * thoughtpolice never really learned C++ at all, so he just sticks with C if he needs it
13:35:54 <Twey> C has a sort of minimalistic charm
13:35:59 <FliP^2eH> That's it
13:36:07 <Cale> C makes a better target language for a compiler than C++
13:36:43 <Twey> It's too low-level to actually be pleasant to program in, but its minimalism lends it a certain elegance — it's quick to pick up, and pretty uniform to use
13:36:45 <thoughtpolice> oh, and if you use clang you get blocks
13:36:48 <thoughtpolice> which are fun. :)
13:36:56 * thoughtpolice should update his build speaking of that...
13:37:02 <Phillemann> Blocks?
13:37:08 <skorpan> still, there's little C which is invalid C++
13:37:11 <thoughtpolice> AKA: closures
13:37:11 <Twey> C++ throws away all those good parts of C and retains only the bad
13:37:24 <skorpan> Twey: examples, please
13:37:32 <skorpan> i'm not debating anyone here, i just want to know what the big deal is
13:37:36 <FliP^2eH> I thought C++ does not try to ditch C
13:37:38 <Twey> skorpan: C has: pointers
13:37:44 <trofi> they reserved this and class!! :]
13:37:53 <thoughtpolice> skorpan: isn't it mostly scoping that causes different results when the same input is given to a C compiler and a C++ compiler?
13:37:54 <Twey> C++ has: pointers, references, smart pointers
13:38:06 <skorpan> thoughtpolice: i know way too little C/C++ to answer that
13:38:23 <Twey> C has: structs, unions, functions
13:38:26 <skorpan> Twey: but you said C++ retains only the bad parts about C?
13:38:35 <thoughtpolice> skorpan: I know you can for example, print out sizes of datatypes, but C++ has different scoping rules, so while both compilers will take them, they will give out different results
13:38:38 <Twey> C++ has: structs, unions, classes, templates, &c.
13:38:51 <Twey> skorpan: I was talking about characteristics, not features
13:39:11 <Twey> The characteristics it loses are minimalism and simplicity
13:39:11 <thoughtpolice> skorpan: aside from that I'm not sure of all the cases where you can have syntactically valid code for both a C and C++ compiler and get different results
13:39:23 <thoughtpolice> Phillemann: but yeah, clang's blocks are essentially just closures
13:39:33 <thoughtpolice> Phillemann: http://lists.cs.uiuc.edu/pipermail/cfe-dev/2008-August/002670.html
13:39:46 <thoughtpolice> it's been in clang HEAD for a while, apple are going to use it in snow leopard from what I hear
13:39:55 <skorpan> i just hope that i'll never have to program C or C++ for work.. so far i've only been doing python and very little java.
13:40:05 <thoughtpolice> although apparently you still somewhat have to 'manage' blocks in C
13:40:11 <FliP^2eH> C itself is easy to learn
13:40:14 <thoughtpolice> in objective-C the garbage collector takes care of that though
13:40:22 <FliP^2eH> Programming in C is an art itself
13:40:23 <bla> Good coding in C is harder.
13:40:27 <bla> Yeah.
13:40:34 <FliP^2eH> Easy to blow your own foot away
13:40:56 <FliP^2eH> int *pntr; free(pntr); // BAM
13:41:16 <Deinumite> When our C++ teacher showed us template programming I think at least 5 people ran out of the room crying.
13:41:27 <jmcarthur_work> FliP^2eH, if only most C bugs were so simple
13:41:35 <thoughtpolice> I've gotten more screwed by forgetting a 'static' decl in certain places
13:41:41 <thoughtpolice> that took me 2 hours to look at in GDB
13:41:42 <FliP^2eH> I liked segfaults :)
13:41:45 <copumpkin> it's sad the syntax of templates in c++ is so ugly, because they're quite powerful
13:41:47 <thoughtpolice> before I finally just tried adding 'static'
13:41:49 <thoughtpolice> success :)
13:41:56 <copumpkin> but they make the ugliest errors ever
13:41:57 <bla> That's obvious and easy to debug. C++ has neater way of blowing legs away. (tables of upcasted classes)
13:42:06 <Phillemann> I like it that C++ supports RAII. Explicitly calling some free function is pretty ugly.
13:42:12 <yitz> char buf[80]; /* famous last words */
13:42:31 <b_jonas> Phillemann: agreed, that's the greatest thing in C++
13:43:14 <ClaudiusMaximus> my favourite C bug was some sizeof(ptrdiff_t) issue, which lead to malloc(2 gigabytes)
13:43:26 <FliP^2eH> Nicccceeee
13:44:07 <thoughtpolice> i also think the C preprocessor is essentially the devil sometimes :(
13:44:16 <yitz> ClaudiusMaximus: that was in Roman times, and you're still waiting for it to finish
13:44:17 <thoughtpolice> it bit me once in GHC and in other software before
13:44:23 <FliP^2eH> I like it for conditional compiling, tho
13:44:31 <FliP^2eH> #ifdef __linux__
13:44:32 <Vanadium> thoughtpolice: What did it do?
13:44:37 <thoughtpolice> well, yeah, that's the problem sometimes :)
13:44:43 <Vanadium> FliP^2eH: D does that better, no?
13:44:48 <FliP^2eH> Yes, way better
13:44:57 <FliP^2eH> version (Windows) {}
13:44:59 <yitz> thoughtpolice: jhc uses m4 instead
13:45:04 <FliP^2eH> version (Linux) {}
13:45:05 <copumpkin> ugh m4
13:45:06 <Phillemann> C and C++s module mechanism (if you can call #include that way) is just too low level.
13:45:13 <thoughtpolice> Vanadium: there was code in GHC for years relating to x86_64 and Mac OS X darwin, but because GHC has actually never supported that platform, it went largely untested
13:45:26 <jmcarthur_work> it's not a module system
13:45:26 <yitz> copumpkin: hey, it's funcional
13:45:30 <jmcarthur_work> C++ has two though
13:45:36 <jmcarthur_work> namespaces and classes
13:45:38 <thoughtpolice> Vanadium: because of it, when Igloo put his unregistered x86_64/darwin binary dist up, it failed on compiling GHC again
13:45:40 <yitz> copumpkin: then again, so is unlambda
13:45:45 <copumpkin> yeah :P
13:46:56 <thoughtpolice> Vanadium: which was weird, but it's an example. you can leave pieces of code untested for quite a while when you base compilation off platform combinations
13:47:04 <thoughtpolice> especially in the case of something so platform-specific like GHC
13:47:25 <FliP^2eH> No matter how outdated C is.. no way around it on linux & friends :)
13:47:25 <Vanadium> Right
13:47:27 <thoughtpolice> Vanadium: fwiw, the function in the OS X case was 2 lines of code, and it needed another 2 cases in order to work.
13:47:46 <Vanadium> FliP^2eH: Well. C++? ;)
13:47:55 <FliP^2eH> Bash!
13:48:01 <thoughtpolice> Vanadium: similar bugs of that nature have bitten me before
13:48:20 <thoughtpolice> Vanadium: which leads me to use the CPP with a lot of care when I do use it :)
13:48:35 <Vanadium> I see :]
13:48:38 <thoughtpolice> and I try to move actual configurations that CPP might handle into my code if possible
13:49:00 <thoughtpolice> i.e. it's not hideously ugly
13:52:54 <stianhj> i'm trying to create a list of pairs [(x,y),..] such that 1 < x < y and (x+y) <= 100, but i'm kinda lost without for loops
13:53:36 <stianhj> so all the pairs of x's and y's
13:55:07 <byorgey> stianhj: do you know about list comprehensions?
13:55:52 <byorgey> > [ (x,y) | x <- [1..10], y <- [1..10], x < y ]  -- for example
13:55:53 <lambdabot>   [(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(2,3),(2,4),(2,5),(...
13:56:11 <skorpan> @hoogle String -> Char -> (String, String)
13:56:11 <lambdabot> Data.List genericSplitAt :: Integral i => i -> [b] -> ([b], [b])
13:56:20 <stianhj> byorgey: aha.. but how do i get y > x
13:56:33 <stianhj> oh wait
13:56:35 <stianhj> you did that
13:56:39 <byorgey> stianhj: yep =)
13:56:40 <stianhj> thanks, i'll try i tout
13:56:57 <byorgey> stianhj: you'll have to change it a bit of course, and add something to check (x+y) <= 100
13:57:05 <skorpan> @hoogle [a] -> a -> Int
13:57:05 <lambdabot> Data.List elemIndex :: Eq a => a -> [a] -> Maybe Int
13:57:05 <lambdabot> Data.List elemIndices :: Eq a => a -> [a] -> [Int]
13:57:05 <lambdabot> Prelude (!!) :: [a] -> Int -> a
13:57:16 <stianhj> byorgey: yeah. thanks.. but man that looks so much better than nested for-loops
13:57:24 <byorgey> stianhj: sure does! =)
13:57:26 <Twey> [(x, y) | x <- [2..100], y <- [2..100], x + y <= 100]
13:57:33 <Twey> Would be one way to do it
13:57:47 <Twey> Er, [2..99] even
13:57:49 <byorgey> that isn't quite right, stianhj asked for  x < y
13:57:55 <Twey> Huh?
13:57:59 <Twey> Ah, yes
13:58:06 <Twey> But also x + y <= 100
13:58:11 <byorgey> indeed.
13:58:20 <byorgey> I wasn't solving the problem, just illustrating list comprehensions
13:58:26 <gwern> @quote gnome
13:58:27 <lambdabot> dons says: i had a dream about it last night, where i was running kde and gnome together, and had no room on my screen for xterms
13:58:28 <Twey> Ah, okay :)
13:58:30 <gwern> @quote gnome
13:58:31 <lambdabot> DerekGlidden says: [GNOME] Development strategies are generally determined by whatever light show happens to be going on ... one of the developers will leap up and scream "I WANT IT TO LOOK JUST
13:58:31 <lambdabot> LIKE THAT" and then straight-arm his laptop against the wall in an hallucinogenic frenzy before vomiting copiously, passing out and falling face-down in the middle of the dance floor.
13:58:45 <Twey> Hahaha
13:59:06 <Twey> @quote kde
13:59:07 <lambdabot> dons says: i had a dream about it last night, where i was running kde and gnome together, and had no room on my screen for xterms
13:59:16 <Twey> boo
13:59:18 <FliP^2eH> @quote flippeh
13:59:19 <lambdabot> No quotes match. Sorry about this, I know it's a bit silly.
13:59:22 <FliP^2eH> :(
13:59:25 <Phyx-> hm, what kinda type signature is this "step :: (?first :: Bool) => Expr -> [Expr]" what does the ? mean?
13:59:26 <gwern> @quote flip
13:59:26 <bla> @quote xmonad
13:59:27 <lambdabot> goundoulf says: I've been reading a very good tutorial on haskell, because the [XMonad] config file was too obscure for me
13:59:27 <lambdabot> fishkandy says: xpika, apparently pl also doubles as the command for producing an unintelligible flip-stream :-)
13:59:34 <Twey> Phyx-: Implicit arguments
13:59:41 <gwern> @quote flipp
13:59:42 <lambdabot> DanPascu says: For God's sake, have mercy on us. I'm no mathematician, yet I find 'patch commutation' to sound reliable and trustworthy. 'Patch Flipping' sounds like a drunken monkey doing rollovers
13:59:42 <Twey> THE WORK OF THE BEAST
13:59:56 <gwern> implicit arguments, ew, where did you see that?
14:00:00 <Twey> gwern: Hahaha, nice one
14:00:12 <stianhj> byorgey: that worked great.. thanks again
14:00:17 <Phyx-> Twey: ok, thanks
14:00:24 <byorgey> stianhj: great! you're welcome.
14:00:35 <byorgey> stianhj: feel free to ask in here if you have more questions.
14:00:42 <Twey> Phyx-: It means it reads a binding called ‘first’ of type Bool from the calling scope
14:00:45 <gwern> byorgey: what is the meaning of life?
14:00:48 <gwern> why are we all here?
14:01:01 <Phyx-> gwern: to code haskell
14:01:14 <giulianoxt> 42
14:01:22 <Phyx-> Twey: ah ok, my first time seeing it :)
14:01:22 <gwern> are humans just dna's way of making more dna?
14:01:30 <Twey> > let foo :: (?x :: a) => a in let x = "Hello" in x
14:01:31 <lambdabot>   The type signature for `foo' lacks an accompanying binding
14:01:34 <Twey> Eh
14:01:45 <Phyx-> giulianoxt: no, no, more like sum $ take 42 [1..]
14:01:51 <Twey> I can't remember the syntax anyway
14:02:14 <Twey> > let foo :: (?x :: a) => a; foo = ?x in let ?x = "Hello" in foo
14:02:19 <Twey> Something like this
14:02:19 <lambdabot>   "Hello"
14:02:23 <Phyx-> Twey: hrm, that seems a prety nasty thing
14:02:24 <Twey> That's the one
14:02:29 <Twey> No kidding
14:02:35 <Twey> Dynamic scoping?  In *my* Haskell?
14:02:47 <Twey> That's why you don't see it very often :-P
14:03:13 <Phyx-> hehehe
14:03:21 <gwern> Twey: it's more likely than you think!
14:03:30 <bla> I've got x and y of type Int. How do i calculate x-y/2 ?
14:03:43 <tromp> use div
14:03:43 <byorgey> bla: what type would you like the result to be?
14:03:44 <Twey> bla: x - y `div` 2
14:03:45 <bla> Ok, I can swap / for div probably
14:03:49 <gwern> although implicit params is one ghc extension that should go away...
14:03:57 <bla> How would you convert it to /float/?
14:03:57 <gwern> wouldn't even break many packages
14:04:01 <Twey> Integer division is div
14:04:13 <Twey> If you want to use Float, you want to convert them with fromIntegral:
14:04:28 <bla> Thanks you all. ;d
14:04:29 <Twey> > (fromIntegral x - fromIntegral y) / 2
14:04:31 <lambdabot>   * Exception: not a number
14:04:35 <Twey> Oh, right
14:04:42 <bla> > let x = 10
14:04:44 <lambdabot>   not an expression: `let x = 10'
14:04:47 <Twey> > (fromIntegral 3 - fromIntegral 1) / 2
14:04:49 <lambdabot>   1.0
14:04:56 <bla> Hm. Me wonders why ghci must have those 'lets'
14:05:04 <Twey> Convenience
14:05:13 <byorgey> bla: because ghci is essentially inside a do-block
14:05:24 <byorgey> it's not the same syntax as declaring stuff in a file.
14:05:32 <Twey> let without in is do-block syntax: let x = y; foo becomes let x = y in foo
14:05:36 <bla> Oh, that makes sense.
14:05:52 * Phyx- wonders why you can't define datatypes in ghci prompt
14:06:22 <Twey> Because GHCi is essentially inside a do-block :-P
14:06:29 <Twey> It would be handy to be able to, though
14:06:42 <Phyx-> yeah
14:06:49 <bla> This is for now only one thing I find neater in ocaml - more generic and easier to use cmdline interpreter.
14:06:55 <byorgey> yeah, sounds hard to come up with the right semantics for it though.
14:09:25 <Vq^> i usually find it better to create a small playground haskell-file and load it into ghci when i want to declare symbols like that
14:10:54 <Phyx-> lates
14:11:10 <Phyx-> oops, wrong window
14:11:17 <Phyx-> luckily, didn't say anything bad
14:13:00 <bla> To apply a function to each element of list should I use map?
14:13:05 <bla> I don't need to create another list.
14:13:11 <mauke> what do you want to do with the results?
14:13:29 <bla> Draw picture with SDL - call function putting pixel
14:13:42 <mauke> functions don't put pixels, this is haskell
14:14:02 <bla> So I want to call this little thingy putting pixel. ;d
14:14:04 <mauke> I don't know SDL but this sounds like a job for mapM_
14:14:09 <mauke> an action :-)
14:14:13 <bla> Ok. ;d
14:14:20 <stianhj> mauke: putting pixels is just setting a value in a array, and sending that array to the gfx card
14:14:34 <mauke> if it's anything like IO, the functions just build and return an "action"
14:14:41 <Berengal> mapM f = sequence . map f anyway, so they're rather similar
14:14:55 <mauke> you want to combine the list of resulting actions into one action by performing them in sequence
14:15:01 <mauke> which is what mapM_ does
14:15:10 <bla> > mapM_
14:15:12 <lambdabot>   Overlapping instances for GHC.Show.Show ((a -> m b) -> [a] -> m ())
14:15:12 <lambdabot>    aris...
14:15:22 <bla> Ok, I've seen type
14:15:29 <Berengal> @type mapM_
14:15:30 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
14:15:54 <Berengal> @type forM_
14:15:55 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
14:16:01 <bla> Seems a bit harsh for first haskell program. ;d I'll try to hack my way through it.
14:16:03 <mauke> @src forM_
14:16:04 <lambdabot> forM_ = flip mapM_
14:16:13 <Phyx-> rofl
14:16:34 <Berengal> I've found I usually use forM_... 'forM_ someList $ \element -> do [...]'
14:18:18 <Berengal> > groupBy (\x y -> x + 5 > y) [1..]
14:18:20 <lambdabot>   [[1,2,3,4,5],[6,7,8,9,10],[11,12,13,14,15],[16,17,18,19,20],[21,22,23,24,25...
14:19:03 <FliP^2eH> > let apple = 3, orange = 4 in apple == orange
14:19:05 <lambdabot>   <no location info>: parse error on input `,'
14:19:08 <FliP^2eH> :(
14:19:19 <Cale> > let apple = 3; orange = 4 in apple == orange
14:19:21 <lambdabot>   False
14:19:31 <FliP^2eH> Apples aren't oranges :(
14:19:35 <mauke> > map snd . groupBy (\(x,_) (y,_) -> x + 3 > y) . zip [0..] $ "Hello, world!"
14:19:36 <lambdabot>   Couldn't match expected type `(a, b)'
14:19:44 <burp> > let apple = orange in apple == orange
14:19:45 <mauke> > map (map snd) . groupBy (\(x,_) (y,_) -> x + 3 > y) . zip [0..] $ "Hello, world!"
14:19:45 <lambdabot>   Not in scope: `orange'Not in scope: `orange'
14:19:46 <lambdabot>   ["Hel","lo,"," wo","rld","!"]
14:19:53 <burp> uh damn
14:19:59 <burp> need fruit data
14:20:02 <mauke> gentlemen: behold!
14:20:07 <mauke> it's splitN
14:20:20 <Berengal> mauke: I was just thinking that...
14:20:58 <Phyx-> ok, do implicit parameter offer any benefit at all?
14:21:09 <FliP^2eH> > data Fruit = Apple | Orange; let a = Apple; let b = Orange; a == b
14:21:11 <lambdabot>   <no location info>: parse error on input `data'
14:21:11 <FliP^2eH> :d
14:21:13 <FliP^2eH> No data :(
14:21:16 <mauke> Phyx-: yeah, they're very nice in :t
14:21:28 <Phyx-> mauke: rofl
14:21:30 <mauke> :t map ?f [1 .. 9]
14:21:31 <lambdabot> forall a b. (?f::a -> b, Num a, Enum a) => [b]
14:21:46 <mauke> you can make the compiler invent variables and tell you their types
14:21:54 <Phyx-> lol
14:22:53 <Phyx-> > let ?f = id in  map ?f [1..9]
14:22:54 <lambdabot>   [1,2,3,4,5,6,7,8,9]
14:23:32 <bla> > [ (x, y) | x <- [0..5], y <- [1..3] ]
14:23:34 <lambdabot>   [(0,1),(0,2),(0,3),(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3),(4...
14:23:40 <bla> Bettter idea for creating such list?
14:23:49 <bla> (all screen coordinates)
14:24:15 <mauke> > liftM2 (,) [0..5] [1..3]
14:24:16 <lambdabot>   [(0,1),(0,2),(0,3),(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3),(4...
14:24:20 <mauke> not necessarily better
14:24:28 <ClaudiusMaximus> :t range
14:24:29 <lambdabot> forall a. (Ix a) => (a, a) -> [a]
14:24:52 <Berengal> > range ((0,0), (10,10))
14:24:53 <lambdabot>   [(0,0),(0,1),(0,2),(0,3),(0,4),(0,5),(0,6),(0,7),(0,8),(0,9),(0,10),(1,0),(...
14:25:04 <bla> Which module is that?
14:25:10 <Berengal> Data.Array
14:25:22 <mauke> @index range
14:25:23 <lambdabot> Data.Ix, Data.Array, Data.Array.IArray, Data.Array.Unboxed, Data.Array.MArray, Data.Array.IO, Data.Array.ST, Data.Array.Storable, Data.Array.Diff
14:25:28 <bla> ;)
14:25:36 <bla> "There's always a better way"
14:25:46 <Phyx-> are they "better"
14:26:49 <Berengal> > let a <-> b = range (a,b) in (0,0) <-> (3,3)
14:26:51 <lambdabot>   [(0,0),(0,1),(0,2),(0,3),(1,0),(1,1),(1,2),(1,3),(2,0),(2,1),(2,2),(2,3),(3...
14:26:55 <Phyx-> lol, i'm serious, are those actually better than using a list comprehension?
14:27:06 <Berengal> Nah, the comprehension is fine
14:27:09 <mauke> the liftM2 (,) version is easier to read for me
14:27:30 <FliP^2eH> > ['0'..'z']
14:27:32 <lambdabot>   "0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwx...
14:27:46 <FliP^2eH> > ['1'..'0']
14:27:48 <lambdabot>   ""
14:27:50 <FliP^2eH> :d
14:27:58 <Berengal> > (,) <$> [0..3] <*> [0..5]
14:27:59 <lambdabot>   [(0,0),(0,1),(0,2),(0,3),(0,4),(0,5),(1,0),(1,1),(1,2),(1,3),(1,4),(1,5),(2...
14:28:19 <bla> o_O
14:28:27 <c_wraith> It's very applicative that way.
14:28:41 <skorpan> > range ('a', 'z')
14:28:42 <lambdabot>   "abcdefghijklmnopqrstuvwxyz"
14:28:54 <Berengal> > liftM (,) [1..3] `ap` [1..5]
14:28:55 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(1,5),(2,1),(2,2),(2,3),(2,4),(2,5),(3,1),(3,2),(3...
14:29:25 <skorpan> > let a <-> b = range (a,b) in ('a', 'a') <-> ('a', 'z')
14:29:26 <lambdabot>   [('a','a'),('a','b'),('a','c'),('a','d'),('a','e'),('a','f'),('a','g'),('a'...
14:29:28 <Berengal> I prefer liftM/<$> and ap/<*> to liftM#, but that's just me...
14:29:41 <Phyx-> a million ways to rome. lol
14:32:25 <Vq^> > concatMap (\x -> map (\y -> (x,y)) [1..3]) [1..3]
14:32:26 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
14:33:02 <mauke> > (=<<) (\x -> (=<<) (\y -> [(x,y)]) [1..3]) [1..3]
14:33:03 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
14:33:48 <Vq^> > let liftM0 = return in liftM0 (,) `ap` [1..3] `ap` [1..3]
14:33:49 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
14:34:31 * Vq^ is feeling slightly silly
14:37:09 <RayNbow> @seen conal
14:37:09 <lambdabot> I saw conal leaving #haskell, #ghc and #haskell-in-depth 3h 57m 11s ago, and .
14:54:20 <dmwit> -- a middle-infinite list ??
14:54:22 <dmwit> hahaha
14:54:43 <c_wraith> that should type check...  even if it's not useful. :)
14:55:06 <dmwit> c_wraith: http://haskell.org/pipermail/haskell-cafe/2009-June/063061.html
14:55:24 <dmwit> Seems useful enough to me... you can even run head and last on it. =)
14:56:07 <lament> hee
14:56:35 <c_wraith> oh, so something more practical than:
14:56:36 <c_wraith> > [0] ++ fix (1:) ++ [2]
14:56:38 <lambdabot>   [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
14:59:41 <jeffersonheard_h> oh boy.  you know... it's time to quit when you forget how to subtract two negative numbers...
15:00:27 <c_wraith> jeffersonheard_h: Is this some of that "new math" stuff?
15:01:07 <jeffersonheard_h> hah
15:02:35 <jeffersonheard_h> the trick, divide a series into quartiles, normalize the values in each quartile, but merely normalize their magnitudes while still preserving the sign
15:03:28 <jeffersonheard_h> it's obvously after 6 and I should get food before I forget how to count money
15:04:34 <c_wraith> wait, how does that work if some values in a particular quartile disagree with each other on sign?
15:05:00 <jeffersonheard_h> and that little rabbit hole is how I got to where I could no longer do basic math
15:05:17 <c_wraith> I just mean...  the problem is ill-defined.
15:05:19 <jeffersonheard_h> that is, the one you mention, c_wraith
15:07:12 <Phyx-> @hoogle <?> --info
15:07:12 <lambdabot> Text.Parsec.Prim (<?>) :: Monad m => ParsecT s u m a -> String -> ParsecT s u m a
15:07:13 <lambdabot>  
15:07:13 <lambdabot> The parser p ? msg behaves as parser p, but whenever the parser p fails without consuming any input, it replaces expect error messages with the expect error message msg.
15:08:01 <jeffersonheard_h> c_wraith, I mean to normalize the magnitude between the endpoints of the quartile, choosing 0 to be the endpoint closest to 0 and 1 to be the endpoint furthest from
15:08:08 <bla> http://temp.thera.be/Julia.hs  Would somebody taking a look at it and commenting it? It works; although very slow (draws a fractal)
15:08:17 <jeffersonheard_h> however, yes, that still breaks down into a singularity
15:10:05 <troutwine> My first serious(ish) Haskell program gobble memory like crazy. Could someone take a look and comment? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6043#a6043
15:10:37 <troutwine> (Note, I haven't been able to do any profiling yet. Arch's yaourt doesn't install profiling libs by default.)
15:25:07 <hackagebot> fmlist 0.2 - FoldMap lists (SjoerdVisscher)
15:34:07 <Cale> bla: I'm just taking a look at it from a performance perspective. Essentially all the time and allocation are being done in juliaEquatDo which is not surprising. I'm just having a look at the core to see if what it's doing is reasonable. One obvious thing which can be done is to not compute the magnitude, but the magnitude squared, which saves a square root.
15:34:41 <dmwit> troutwine: Without profiling, I'm going to go ahead and guess that it's laziness in the StateT monad that's killing you.
15:35:24 <bla> Cale, yeah, that's for sure. I can also check it more often and break the 'loop' if it reaches 'infinity'
15:35:27 <dmwit> troutwine: Try strictifying the update function and see what that gets you.
15:36:03 <Cale> Oh, right, yes.
15:36:16 <Alpounet> edwardk, the paper you gave yesterday is *very* interesting.
15:40:10 <troutwine> dmwit: New version availiable. I've made modifications based on suggestions in the beginner's mailing list and have imported Control.Monad.State.Strict.
15:40:17 <Cale> bla: yeah, that's definitely worthwhile. It cuts the runtime here for maxDepth 50 from 11.5s to 4.7s
15:40:26 <troutwine> dmwit: No change, if I understand the implications of importing State.Strict correctly.
15:41:28 <dmwit> troutwine: I don't think State.Strict is enough.
15:41:40 <dmwit> troutwine: But let me take a look at the updated version.
15:42:13 <dmwit> troutwine: Yeah, you need to be stricter.
15:42:15 <bla> Cale, writting it. ;d
15:42:26 <Cale> Also something to be careful about, the complex magnitude function is faster than magSquare (x :+ y) = x^2 + y^2, but magSquare (x :+ y) = x*x + y*y cuts the time down to 2.5s
15:42:37 <Cale> (for the same maxDepth = 50)
15:42:41 <dmwit> troutwine: State.Strict will just evaluate until it discovers that the constructor used is "Globals"... which is basically identical to State.Lazy for this use case.
15:43:13 <troutwine> dmwit: How so?
15:43:13 <dmwit> troutwine: One thing to try is simply putting strictness annotations in the Globals declaration.
15:43:24 <troutwine> dmwit: Also, I don't know how to be more strict, I'm afraid.
15:43:28 <dmwit> troutwine: I don't know enough about the implementation of Bloom and MinPrioHeap to understand if that's enough.
15:44:03 <dmwit> troutwine: The other solution is to use 'rnf', which will *definitely* be strict enough.
15:44:18 <dmwit> troutwine: Do you happen to know if Bloom and MinPrioHeap are NFData instances?
15:45:01 <troutwine> dmwit: I don't. In fact, before now I'd not heard of rnf.
15:45:24 <enolan> Hi. 'show BlockedOnDeadMVar' and 'show BlockedIndefinitely', are both "thread blocked indefinitely". Should I report this as a bug in GHC?
15:45:40 <dmwit> troutwine: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6043#a6045 (the "I don't know if this is enough strictness" solution, just to test)
15:45:50 <dmwit> troutwine: (You'll still want to use State.Strict with this.)
15:46:46 <byorgey> enolan: why not?  Although I'd submit it as an "enhancement" rather than a "bug".
15:47:27 <enolan> I don't really see why they don't just use deriving Show for all the exceptions...
15:48:13 <troutwine> dmwit: I'm told by ghc that I've an "Unexpected strictness annotation: !Bloom".
15:48:27 <dmwit> um
15:48:34 <dmwit> Let me check if that's the right syntax...
15:48:57 <dmwit> ah
15:49:04 <dmwit> troutwine: Parenthesize the Bloom.
15:49:09 <dmwit> !(Bloom ByteString)
15:49:16 <dmwit> similarly for MinPrioHeap.
15:50:03 <troutwine> dmwit: Still gobbling memory. (By the way, thanks for taking the time to help me.)
15:50:30 <dmwit> Yep, I suspect to do better, you have to either take a look at the implementations of Bloom and MinPrioHeap, or hope that they have NFData instances.
15:51:01 <dmwit> Real profiling would also help to make sure that these guesses are right. =)
15:51:21 <troutwine> Right. :)
15:52:22 <Cale> bla: Also, your juliaInf value seems pessimistic, though it doesn't really change the runtime all that much. juliaInf = 2 with your original program or juliaInf = 4 when testing the square of the magnitude should produce the same result.
15:54:04 <bla> Mhm.
15:58:34 <Cale> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6046#a6046
15:58:44 <Cale> There's the one with some changes that I made :)
16:02:01 <troutwine> dmwit: So, Bloom is an instance of NFData, but I don't know where to stick the rnf. Have some more time to lead me along?
16:02:08 <Cale> It can actually handle maxDepth = 100 and 640x480 resolution without getting tedious now :)
16:02:18 <dmwit> troutwine: sure
16:02:54 <dmwit> troutwine: So, you'll want something along the lines of:
16:03:58 <dmwit> modifyBloom f = modify (\s -> let modified = f (bloomF s) in rnf modified `seq` s { bloomF = modified })
16:04:41 <dmwit> The let-binding is the crucial bit here: we want the argument to rnf and the value you put into s to be syntactically identical...
16:05:39 <dmwit> troutwine: And now I've got to run.  But keep asking in here, there's some smart people hanging around. =)
16:05:47 <troutwine> Thanks.
16:15:19 <bla> Cale, thanks. ;-)
16:27:01 <vininim> Here is the buzz. ``Python 3000 puts Python back in the game... with Python 3000, which is a bigger leaper to python 2.6 than python 2.6 was to python 2.4, Python Foundation is pulling out the big guns and offering features which other languages have yet to adopt'' --britney, twitter
16:27:34 <Elly> which features are those?
16:29:03 <vininim> Features like iterators and view makes Python 3000 easiest to use.
16:29:28 <vininim> heh ok, in case you don't know I'm just paraphrasing internet explorer get the facts page =)
16:29:29 * Elly stifles a giggle
16:29:52 * byorgey stampedes to download Python 3000
16:30:18 <dmwit> A stampede of one... truly a dangerous thing.
16:30:38 <byorgey> RUMBLERUMBLERUMBLE
16:30:53 <dons> kids are funny
16:31:50 <vininim> just wait until they start asking stuff about life
16:32:23 <byorgey> "daddy... where do compilers come from?"
16:32:36 <Elly> "What's the monomorphism restriction?"
16:32:42 <byorgey> "oh, er, um... compilers?!... uh..."
16:32:46 <troutwine> britney makes weird assertions. Mostly Python 3000 renames a fair chunk of the standard library, drops support for old modules and adds very, very few new features.
16:33:04 <Elly> byorgey: stork!
16:33:15 <byorgey> "well, you see, when a programmer and a language love each other very much..."
16:34:03 <Alpounet> troutwine, britney just does some marketing, I guess :-)
16:34:18 <vininim> leave britney alone? *snap*
16:34:26 <hackagebot> haskell-src-exts 0.5.5 - Manipulating Haskell source: abstract syntax, lexer, parser, and pretty-printer (NiklasBroberg)
16:34:51 <byorgey> woot! nibro++
16:35:26 <hackagebot> hsx 0.5.5 - HSX (Haskell Source with XML) allows literal XML syntax to be used in Haskell source code. (NiklasBroberg)
16:36:05 * byorgey goes back to adding pictures of muppets to his slides for tomorrow
16:43:27 <bla> Is there any standard graphic printing haskell library?
16:43:33 <bla> Included and available by default?
16:44:03 <bla> My friend has lots of problems with compiling SDL bindings on windows.
16:44:17 <lament> i had problems with it on mac, too
16:48:19 <bla> Mhm.
16:49:20 <dons> bla: gtk/cairo? sdl?
16:49:28 <dons> opengl?
16:51:13 <bla> All of them will require installatoin of library and then compilation of bindings, won't they? On windows it sucks. SDL even works here without much hassle.
16:52:03 <bla> I thought about HGL, but this also seems external - but should directly use winapi on windows.
16:52:29 <Saizan_> the haskell-platform installer should have some of those, though
16:53:21 <erikc> you'll need to build/install glut, or write a binding to use win32 and wgl directly to hook up a windows to an opengl context
16:55:58 <Saizan_> http://hackage.haskell.org/platform/ <- it has GLUT and OpenGL included
17:16:20 <ritek> does anyone here have tried xmonad?
17:17:04 <Saizan_> some of us use it regularily
17:17:10 <ivanm> ritek: there's also #xmonad
17:18:17 <jeffersonheard_h> @hoogle Monoid a, Monoid b => a x -> b x
17:18:18 <lambdabot> Parse error:
17:18:18 <lambdabot>   --count=20 "Monoid a, Monoid b => a x -> b x"
17:18:18 <lambdabot>                      ^
17:18:49 <ritek> ivanm, thanks for the info
17:19:11 <Alpounet> @hoogle forall a. forall b. Monoid a, Monoid b => a x -> b x
17:19:11 <lambdabot> Parse error:
17:19:11 <lambdabot>   --count=20 "forall a. forall b. Monoid a, Monoid b => a x -> b x"
17:19:11 <lambdabot>                                          ^
17:19:14 <Saizan_> jeffersonheard_h: kind error
17:19:28 <Saizan_> @hoogle (Monoid a, Monoid b) => a x -> b x
17:19:29 <lambdabot> Data.Foldable toList :: Foldable t => t a -> [a]
17:19:29 <lambdabot> Language.Haskell.TH.Syntax qRunIO :: Quasi m => IO a -> m a
17:19:29 <lambdabot> Control.Monad.Trans liftIO :: MonadIO m => IO a -> m a
17:19:36 <Saizan_> syntax error too :)
17:19:37 <jeffersonheard_h> Saizan: I realized that after I typed it
17:19:39 <jeffersonheard_h> yes
17:19:58 <jeffersonheard_h> right...  that doesn't work anyway.  looking for something that if k is mzero  then Nothing else Just k
17:20:28 <jeffersonheard_h> so, f [] -> Nothing, but f xs -> Just xs
17:20:55 <jeffersonheard_h> thought something had to exist already.  I realized after I typed that hoogle out that the type sig wasn't anywhere close
17:21:33 <Botje> listToMaybe
17:21:45 <jeffersonheard_h> Botje, listToMaybe (x:xs) -> Just x
17:21:52 <Botje> oh
17:21:56 <Botje> sorry :)
17:23:42 <jeffersonheard_h> but frankly that ought to be a polymorphic function so that f [] -> mzero, f xs -> pure xs
17:24:32 <Saizan_> i guess you've to write something with guard
17:24:48 <jeffersonheard_h> f mzero -> mzero, f (m a) -> n (m a) :where m and n are both monoids
17:25:01 <jeffersonheard_h> well, you understand my pseudo-syntax
17:25:46 <jeffersonheard_h> mempty, not mzero
17:26:20 <jeffersonheard_h> or maybe I mean mzero and MonadPlus, not monoid...  argh.  fuzzy headed
17:26:35 <Saizan_> MonadPlus looks doable
17:26:59 <Saizan_> but i don't recall anything like that in the stdlibs
17:31:02 <jeffersonheard_h> hrm.  should be nothing more than f v = v >>= return
17:36:37 <Saizan_> ?type (>>= return)
17:36:38 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m a
17:40:20 <Alpounet> is sum . zipWith, e.g, optimized ?
17:41:32 <Alpounet> I mean such an operation can be done traversing the list once but it isn't the case here, isn't it ?
17:53:16 <byorgey> Alpounet: I'd imagine that would be optimized by list fusion.  However I am unclear on if/when list fusion will/has made its way into ghc.
17:53:44 <Alpounet> okay, thanks for the info, I now have a kw to search
17:53:47 <Alpounet> for
17:54:26 <byorgey> but it depends what you mean by 'optimized'.  Just because of Haskell's laziness it can certainly operate in constant memory, if the two lists being zipped are generated lazily (and if strictness analysis figures out that the sum is strict)
17:54:57 <byorgey> but if by 'optimized' you mean 'doesn't allocate an intermediate list structure', then that's exactly what stream fusion does.
17:55:04 <byorgey> sorry, I just realized I said 'list fusion' at first.
17:55:43 <byorgey> Alpounet: http://www.cse.unsw.edu.au/~dons/papers/CLS07.html
17:55:49 <Alpounet> thanks
18:02:57 <bla> Cale, temp.thera.be/JuliaGL.hs
18:03:02 <bla> Drawing engine changed.
18:04:52 <bla> Saizan_, rewritten to use gl; I'll check this on windows tomorrow (today. ;s)
18:05:11 <ivanm> @hoogle (a -> Bool) -> [a] -> [[a]]
18:05:12 <lambdabot> Distribution.Simple.Utils breaks :: (a -> Bool) -> [a] -> [[a]]
18:05:12 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
18:05:12 <lambdabot> Prelude filter :: (a -> Bool) -> [a] -> [a]
18:06:06 <ivanm> you lie... Distribution.Simple.Utils doesn't have a breaks function! (at least not in Cabal-1.6.0.3...)
18:11:07 <gwern> ivanm: just use the split package already
18:11:17 <ivanm> gwern: oh, forgot about that
18:11:21 <ivanm> dammit, yet another dep :s
18:11:39 <gwern> a tiny one...
18:11:46 <gwern> it's haskell98, and like one module
18:12:17 <gwern> I'm sure split is in the haskell platform. or will be
18:12:34 <ivanm> spoop: splitWhen doesn't do what I want anyway
18:12:43 <ivanm> gwern: and it being in the haskell platform means nothing
18:12:51 <ivanm> in terms of deps
18:12:59 <gwern> horror!
18:13:39 <gwern> I sometimes wonder why C programmers have no 'Malloc Maleficarum'. Lord knows they need it.
18:14:05 <ivanm> what's horror?
18:14:18 <aavogt> @type groupBy
18:14:19 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
18:14:53 <ivanm> I want a function that does this: breakAll even [1..10] = [[1],[2,3],[4,5],[6,7],[8,9],[10]]
18:15:04 <ivanm> splitWhen will strip all the even numbers out
18:15:27 <aavogt> > groupBy (const even) [1..10]
18:15:29 <lambdabot>   [[1,2],[3,4],[5,6],[7,8],[9,10]]
18:15:37 <aavogt> > groupBy (const odd) [1..10]
18:15:38 <lambdabot>   [[1],[2,3],[4,5],[6,7],[8,9],[10]]
18:15:46 <ivanm> aavogt: that was a simple example
18:16:14 <ivanm> in general, I want a function of type (a -> Bool) -> [a] -> [[a]], which will start a new list on every element which matches the predicate
18:16:37 * ivanm thinks he's written something like this before, but can't remember where :s
18:16:52 <aavogt> > groupBy (const $ const True) [1..10]
18:16:53 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10]]
18:16:57 <aavogt> > groupBy (const $ const False) [1..10]
18:16:58 <lambdabot>   [[1],[2],[3],[4],[5],[6],[7],[8],[9],[10]]
18:17:08 <gwern> the split package has multiple splits; I am pretty sure you can find one which does not consume delimiters...
18:17:20 <ivanm> nope, they all seem to do so
18:17:21 <aavogt> ivanm: I don't understand how my groupBy abuse is not correct
18:17:29 <ivanm> aavogt: which one?
18:17:40 <ivanm> the const odd?
18:17:57 <aavogt> @pl \f -> groupBy (const f)
18:17:58 <lambdabot> groupBy . const
18:18:07 <aavogt> ^^ that one
18:18:51 <ivanm> oh, I see what it does...
18:19:05 <ivanm> so I want breakAll p = groupBy (const . not p)
18:20:23 * aavogt wonders if there are any guarantees about the parameter order with groupBy, given the issues with nubBy being flipped in some cases
18:20:47 <ivanm> aavogt: I think they're flipping nubBy back because of groupBy
18:21:20 <ivanm> groupBy is written such that you can do groupBy (>=) to get non-increasing subsets, etc.
18:23:38 <ivanm> aavogt: yay! it works! thanks!
18:23:41 <ivanm> aavogt++
18:23:59 * ivanm never got the hang of abusing const in that fashion
18:24:11 <aavogt> @check \x -> map (:[]) x == groupBy (<) x
18:24:12 <lambdabot>   "OK, passed 500 tests."
18:24:19 <ivanm> though implicitly it's doing it in pairs or something?
18:24:28 <byorgey> ivanm: the split package can do that.
18:24:39 <ivanm> byorgey: oh? didn't see anything there that looked likely...
18:24:51 <ivanm> and I'm trying to avoid introducing extra deps
18:24:55 <byorgey> ivanm: you have to build it yourself from the combinators
18:25:00 <ivanm> ahhh
18:25:10 <byorgey> something like  split (keepDelimsL $ whenElt p) [ ... ]
18:25:16 <ivanm> breakAll p = groupBy (const (not . p)) works, so I'll just use that ;-)
18:25:37 <byorgey> no worries, I'm not offended or anything =)
18:25:40 <ivanm> heh
18:25:52 <byorgey> not... not much.  *sniff*
18:25:58 <ivanm> heh
18:26:06 * ivanm passes byorgey a tissue
18:26:37 * byorgey tears it into tiny pieces using THE SPLIT PACKAGE
18:27:05 <aavogt> @check \x -> groupBy (const $ id) x == groupBy (\y _ -> y) x
18:27:06 <lambdabot>   "Falsifiable, after 0 tests:\n[False,True]\n"
18:27:16 <aavogt> @check \x -> groupBy (const $ id) x == groupBy (\_ y -> y) x
18:27:17 <lambdabot>   "OK, passed 500 tests."
18:27:43 <EvilTerran> you don't need that $
18:28:05 <aavogt> heh, that was awkward... I just match up the types, nevermind thinking about the values
18:28:18 <EvilTerran> @check \x -> (const id) x == (\_ y -> y) x
18:28:20 <lambdabot>   No instance for (GHC.Classes.Eq (a -> a))
18:28:20 <lambdabot>    arising from a use of `GHC.Cla...
18:28:24 <EvilTerran> er...
18:28:27 <byorgey> hahaha
18:28:42 <EvilTerran> @check \x y -> (const id) x y == (\_ y -> y) x y -- moar parameters!
18:28:43 <lambdabot>   "OK, passed 500 tests."
18:28:46 <byorgey> guess you DO need the $  ;)
18:29:10 <EvilTerran> byorgey, it wasn't the $ that broke it
18:29:16 <byorgey> I know, just joking =)
18:30:37 <aavogt> @type id `id` id
18:30:38 <lambdabot> forall a. a -> a
18:30:46 <aavogt> @type id `id` id `id` id
18:30:47 <lambdabot> forall a. a -> a
18:31:08 <aavogt> @type foldr id id `id` repeat id
18:31:09 <lambdabot> forall a. a -> a
18:31:44 <aavogt> > foldr id id `id` repeat id `id` "omg"
18:31:49 <lambdabot>   mueval-core: Prelude.read: no parse
18:31:49 <lambdabot>  mueval: ExitFailure 1
18:31:55 <aavogt> :(
18:33:38 <lispy> no parse!!
18:34:20 <lispy> > foldr id id `id` repeat id `id` $ "omg"
18:34:22 <lambdabot>   <no location info>: parse error on input `$'
18:34:32 <lispy> oh, duh
18:34:36 <lispy> > foldr id id `id` repeat id $ "omg"
18:34:42 <lambdabot>   mueval-core: Prelude.read: no parse
18:34:42 <lambdabot>  mueval: ExitFailure 1
18:34:50 <lispy> hmm
18:34:55 <lispy> > foldr id id `id` repeat id ("omg")
18:34:57 <lambdabot>   Couldn't match expected type `[GHC.Types.Char] -> t'
18:35:25 <aavogt> EvilTerran: thanks, maybe lambdabot should run hlint on inputs?
18:35:54 <lispy> aavogt: how so?
18:36:02 <lispy> before evaluation?
18:36:07 <lispy> or as ?hlist foo
18:36:10 <ManateeLazyCat> Have a exist "double-linked list" package ?
18:36:59 <lispy> ManateeLazyCat: use a zipper
18:37:23 <ManateeLazyCat> I need a tree that just store data at leaves node (like B+ Tree), all operation is at leaves node, have an exist implement package?
18:37:33 <ManateeLazyCat> lispy: Thanks, i try zipper.
18:37:52 <lispy> ManateeLazyCat: http://en.wikibooks.org/wiki/Haskell/Zippers
18:38:02 <aavogt> lispy: hlist? I meant hlint, run preferably only on commands that typecheck... to turn the pedanticity / helpfulness of #haskell up to 11
18:38:13 <lispy> aavogt: I meant hlint too
18:38:18 <ManateeLazyCat> lispy: Thanks
18:38:46 <aavogt> does lambdabot run close to channel limits for spam?
18:39:24 <lispy> aavogt: do we have a channel limit here for spam?
18:40:05 <aavogt> I dunno, but it might be a concern given how many channels lambdabot is in
18:40:08 <lispy> ManateeLazyCat: http://storytotell.org/2007/08/07/list-zippers-in-haskell-and-prolog
18:40:15 <EvilTerran> aavogt, well, i'd be a proponent of adding a ?lint command
18:40:26 <EvilTerran> provided the output's not too verbose
18:40:38 <lispy> ManateeLazyCat: in particular this bit
18:40:38 <lispy> data Zipper a = Zipper [a] a [a] deriving (Show, Eq)
18:41:10 <lispy> ManateeLazyCat: that gives you a doubly linked list if you use it correctly, but it also gives you a 'cursor' so it's like having a C++ iterator into a list
18:41:37 <aavogt> @commands
18:41:38 <lambdabot> Unknown command, try @list
18:41:41 <aavogt> @list
18:41:41 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
18:41:45 <lispy> ?version
18:41:46 <lambdabot> lambdabot 4.2.2
18:41:46 <lambdabot> darcs get http://code.haskell.org/lambdabot
18:41:52 <Alpounet> g'night all
18:42:22 <ManateeLazyCat> lispy: http://hackage.haskell.org/packages/archive/liboleg/0.1.1/doc/html/src/Data-FDList.html ?
18:42:49 <lispy> ManateeLazyCat: hah, cool.  Never saw that before, but it looks good
18:43:11 <ManateeLazyCat> lispy: Which better?
18:43:15 <lispy> ManateeLazyCat: oh, I see that DList is a zipper
18:43:55 <ManateeLazyCat> lispy: FDList looks is exist implement for double-linked list.
18:44:14 <lispy> ManateeLazyCat: parse error :)
18:45:01 <lispy> I would probably just roll my own based on a zipper, but the FDList is good too...just looks big
18:46:36 <lispy> ManateeLazyCat: if you're familiar with iterators/enumerators from OO languages like C++/C#/Java then that's a large part of what zippers give you
18:46:36 <ManateeLazyCat> lispy: You know have an exist B+ Tree (Or similar like) implement? I need a tree, just store data at leaves node, then i can fast insert, delte, search in those leaves node.
18:47:11 <lispy> ManateeLazyCat: I don't know if it's a proper B+ Tree, but the first link I sent you explained how to turn a tree into a zipper
18:47:25 <ManateeLazyCat> lispy: Otherwise i will implement this tree, then use double-linked list with leaves node.
18:47:47 <lispy> ManateeLazyCat: if you don't find it on hackage, then expect to make it yourself and uploade it :)
18:48:05 <lpsmith> I'm guessing nobody here has tried to compile GHC 6.6.1 with 6.10.3...
18:48:16 <lispy> 1. Check Hackage 2. ?? 3. Profit
18:48:29 <lispy> lpsmith: I have not tried that
18:48:40 <lispy> lpsmith: Why are you using 6.6.1?
18:49:13 <lpsmith> Umm,  I did some careful performance comparisons a while ago,  and I can't repeat certain parts of my results
18:49:46 <lpsmith> So my notes say I was using 6.6.1.   But the binary distribution doesn't work for me,  so I'm trying to compile it.
18:49:52 <lispy> lpsmith: Could you just one of the old 6.6.1 releases and install it?
18:50:19 <lispy> lpsmith: well, what about getting 6.8.x and building with it?
18:50:44 <lispy> It could be that 6.10.x is just too big a leap but 6.8.x might be easier?
18:50:50 <lpsmith> I dunno
18:50:53 <lpsmith> maybe
18:51:07 <ManateeLazyCat> lispy: If use double-linked list connect all leaves node, search next leaves node efficient is always constant and don't care how deep of tree.
18:51:37 <ManateeLazyCat> lispy: Thanks for your suggestions ! :)
18:51:48 <lispy> ManateeLazyCat: good luck :)
18:51:56 <lpsmith> What I'm not understanding is... the error it gives me is
18:52:02 <lpsmith> Failed to load interface for `System.Directory.Internals'
18:54:57 <lispy> lpsmith: could it be that the interface was compiled by a version?
18:55:03 <lispy> the .hi file, iirc
18:55:08 <lispy> I need to go, good luck!
18:59:35 <lpsmith> I dunno,  it feels like it isn't looking in the right directory... surely it isn't trying find System.Directory.Internals in the 6.10 distribution
19:01:44 <aavogt> @freshname
19:01:44 <lambdabot> Habp
19:02:23 <aavogt> @karma . freshname
19:02:24 <lambdabot> . has a karma of -4
19:02:45 <aavogt> @karma compose freshname
19:02:45 <lambdabot> compose has a karma of 0
19:50:45 <byorgey> @@ @karma @freshname
19:50:45 <lambdabot>  Habt has a karma of 0
19:57:51 <heatsink> @quote
19:57:51 <lambdabot> apfelmus says: Haskell is the first programming language that really offers the possibility to specify data dependencies exactly as they are because Haskell is pure, higher order and has a powerful
19:57:51 <lambdabot> type system.
20:04:30 <heatsink> @quote
20:04:30 <lambdabot> xDie says: <xDie> > 1.1.1.1.1.1.1.1.1.1.1.1 + 2.3
20:04:56 <heatsink> > 1.1.1.1.1.1 + 2.3
20:04:57 <lambdabot>   No instance for (GHC.Real.Fractional (b -> c))
20:04:57 <lambdabot>    arising from the literal ...
20:06:28 <scutigera> @quote
20:06:29 <lambdabot> dmhouse says: Apparently, "python" is some sort of snake.
20:06:51 <shapr> heh
20:06:55 <shapr> @quote heatsink
20:06:56 <lambdabot> heatsink says: Behold the great monad called List / that yields results with a twist: / For inspection conclusive / of choices exclusive / concat them, if you get my gist.
20:07:04 <shapr> haha
20:07:07 <heatsink> :)
20:07:08 <shapr> @quote lambdabot
20:07:09 <lambdabot> lambdabot says: [in #haskell] there are a lot of weirdos on here
20:07:16 <scutigera> monads, always monads...
20:07:22 <shapr> @quote byorgey
20:07:22 <lambdabot> byorgey says: TDD replaces a type checker in Ruby in the same way that a strong drink replaces sorrows.
20:07:28 <shapr> hah!
20:07:50 <shapr> There was something I really wanted to ask byorgey, wish I could remember what it was...
20:08:15 <byorgey> ?
20:08:16 <dmwit> Ask us about hac phi!
20:08:20 <thetallguy> shapr: maybe you could ask him what you were going to ask...
20:08:27 <shapr> byorgey: hey.. what was I going to ask you?
20:08:34 <_carliros_> hi
20:08:41 <shapr> dmwit: Oh, I'm pretty sure it was something about hac phi... I just don't remember what.
20:08:45 <shapr> hiya _carliros_ !
20:08:52 <shapr> How's code treating you?
20:08:52 <byorgey> shapr: maybe you were going to ask me whether it would be ok to bring TWO unicycles?
20:09:00 <shapr> I only have one...
20:09:00 <_carliros_> i am new here
20:09:11 <dmwit> Oh! Are you bringing a unicycle?
20:09:14 <shapr> _carliros_: Awesome! You've found a fun and intelligent place to learn stuff!
20:09:28 <dmwit> I'll pump up my tire and you can show me how much better you are at it than I am. =)
20:09:32 <shapr> dmwit: Yup, my mountain unicycle, the Arctic Warfare edition.
20:09:51 <_carliros_> yes, was some difficult to get in her,
20:09:52 <shapr> I don't really do much in the way of tricks... except cycling up and down mountains.
20:09:53 <_carliros_> e
20:10:00 <ivanm> shapr: it's camoflaged I take it? :p
20:10:07 <shapr> ivanm: Well, it is black.
20:10:10 <ivanm> with missiles, etc. ? :p
20:10:14 <shapr> and it has a 3.7" tire
20:10:15 * byorgey imagines a parka-wearing, bazooka-toting, unicycle-riding shapr blasting evil polar bears
20:10:22 <dmwit> 3.7', surely
20:10:22 <ivanm> shapr: that's a funny kind of Arctic camo...
20:10:23 <_carliros_> i didn't how to be a member
20:10:29 <shapr> dmwit: 3.7 inches
20:10:36 <shapr> That's the tire size.
20:10:47 <dmwit> but...
20:10:50 <dmwit> that's tiny
20:10:50 <shapr> It's a 26 inch wheel.
20:10:55 <dmwit> oh oh oh
20:10:58 <shapr> no no, I mean.. that's the tire WIDTH.
20:11:03 <dmwit> Got it. =)
20:11:03 <ivanm> shapr: ahhhhh
20:11:20 <shapr> The rim is 65mm wide, and it has a 3.7 inch wide tire on top of that.
20:11:20 <thetallguy> fat
20:11:33 <ivanm> shapr: you mix your units up? :s
20:11:42 <ivanm> isn't that what caused the mars lander to crash? :p
20:11:45 <shapr> ivanm: Nah, I just didn't give enough context.
20:11:47 <dmwit> Trying to picture either a 3.7" wheel or a 3.7' wheel was making me boggle.
20:11:50 <shapr> hah
20:11:52 <_carliros_> aaaa, how do i go to xmonad section?
20:11:58 <shapr> _carliros_: Try /join #xmonad
20:12:00 <dmwit>  /join #xmonad
20:12:16 <shapr> _carliros_: Really, we don't talk about unicycles all the time.
20:12:25 <ivanm> shapr: "rim is 65mm wide, and it has a 3.7 inch wide tire"
20:12:28 <byorgey> shapr: doesn't the bazooka recoil knock you off the unicycle, though?
20:12:32 <aavogt> @quote unicycle
20:12:32 <lambdabot> jjuggle says: I was riding around town and this cop on patrol on a bike rode up next to me and said, "There's always a show off." I offered to teach him to ride and help set up a unicycle patrol
20:12:32 <lambdabot> squad, but he declined.
20:12:35 <ivanm> ^^ sure looks like mixing your units to me!
20:12:35 <troutwine> I've a beginner style issues (I suspect) with networking and laziness. The question is embedded in the paste: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6043#a6050
20:12:39 <troutwine> Little help?
20:12:41 <dmwit> byorgey: You lean into it.
20:12:43 <ivanm> byorgey: he's learned to compensate ;-)
20:12:46 <aavogt> @quote unicycle
20:12:46 <lambdabot> dons says: xerox: what analogy or metaphor did you use? monad-as-garbage-bin? monad-as-refrigerator? monads-as-unicycle?
20:13:09 <shapr> haha
20:13:44 <_carliros_> thanks
20:14:02 <shapr> ivanm: Oh, rim width is measured in mm, but tire width is measure in inches. But sometimes, it's measured in terms of outside circumference, as the french 600c standard is actually centimeters.
20:14:13 <ivanm> >_>
20:14:27 <ivanm> crazy people
20:14:32 <gwern> why can't the rest of the world be as sensible as programmers?
20:14:41 <gwern> we argue over real standards, like tabs v. spaces
20:14:41 <shapr> Here's a picture: http://picasaweb.google.com/shae.erisson/OakMountainUnicycling#5020679931749918482
20:15:00 <ivanm> gwern: heh, was going to use that argument to question your definition of sensibility ;-)
20:15:17 <gwern> ivanm: too late! the stench of my irony overpowers all around me!
20:15:33 <scutigera> shapr: 600c is in mm, otherwise it's a 6 meter tire :-)
20:15:35 * ivanm still doesn't get how it's an _Arctic Warfare_ unicycle if it's black...
20:15:44 <dmwit> There seems to be something missing there.
20:15:48 <shapr> scutigera: bah humbug.. PEDANT! You must fit in perfectly here.
20:15:50 <ivanm> dmwit: the seat?
20:15:53 <ivanm> the rider?
20:15:55 <dmwit> No, a pedal.
20:16:00 <shapr> ivanm: I was living by the Arctic Circle. It's dark during the winter :-P
20:16:01 <dmwit> oh wait
20:16:06 <dmwit> I just missed a joke, didn't I.
20:16:16 <ivanm> dmwit: doesn't one wheel imply one pedal? :p
20:16:23 <ivanm> shapr: heh, so night-time camo? :p
20:16:35 <shapr> Yes, that's my post-hoc explanation.
20:16:51 <scutigera> troutwine: if that's beginner code, then I'm a beginning beginner
20:16:53 <shapr> In reality, I had to special order the frame, and this guy in Iowa made it for me.
20:17:16 <ivanm> what kind of special order?
20:17:31 <dmwit> Oh, yeah, I didn't even notice the bulging forks on there.
20:17:32 <dmwit> wacky
20:17:53 * ivanm doesn't notice any kind of cutlery there
20:18:05 <Saizan_> troutwine: i don't get what laziness has to do with this?
20:18:12 <troutwine> scutigera: Thanks, I think. I like to study up before doing. :)
20:18:15 <shapr> At the time, 3.7 inch tires would not fit into any existing unicycle frame, so I had to get someone to make one for me.
20:18:16 <dmwit> ivanm: You're right, there's only one bulging fork. ;-)
20:18:21 <ivanm> dmwit: "Only one crank left." ?
20:18:25 <ivanm> (the caption)
20:18:37 <dmwit> ivanm: Yeah, and it's the crank that sits on top. ;-)
20:18:38 <ivanm> dmwit: I still don't see a single piece of cutlery...
20:18:39 <ivanm> ;-)
20:18:58 <dmwit> That's because cutlery is plural. =)
20:19:05 <ivanm> is it? :o
20:19:18 <dmwit> cutlery n 2: tableware implements for cutting and eating food
20:19:36 <ivanm> "Cutlery refers to any hand implement..." <-- looks singular to me
20:19:41 <ivanm> well, it's probably like fish
20:19:49 <aavogt> @unpl cutlery
20:19:49 <lambdabot> cutlery
20:19:53 <dmwit> maybe so
20:19:56 <shapr> ivanm: So, you showing up at Hac phi to try the unicycle?
20:19:57 <troutwine> Saizan_: Just a guess, as its the only culprit I can think of. It seems like the server is not processing every UDP packet as it comes in immediately, the client to wait and then timeout.
20:20:06 <ivanm> shapr: wrong country, I'm afraid
20:20:14 <ivanm> also wrong continent! ;-)
20:20:19 * aavogt unplural... eh?
20:20:43 <troutwine> I think. I'm not quite solid on everything yet.
20:21:00 <Saizan_> troutwine: well, IO operations like sending and receiving on a socket don't have "anything" to do with laziness
20:21:33 <troutwine> Oh, well, that's good to know.
20:21:33 <scutigera> troutwine: network code, many ways for it not to work without involving laziness.  I have discovered many of them first hand. most involve blocking reads.
20:21:50 <Saizan_> troutwine: they are completed before returning, like in imperative languages
20:22:14 <Saizan_> troutwine: also "seq (sendTo sock (key qData) addr) return ()" doesn't perform the "sendTo"
20:22:28 <troutwine> Shit, I shouldn't have left that in, actually.
20:22:40 <Saizan_> troutwine: seq is used to add strictness, but if you want to sequence two monadic operations you want >>
20:22:54 <Saizan_> troutwine: like, "sendTo sock (key qData) addr >> return ()"
20:23:18 <troutwine> Yes, I knew that was junk but... well, I don't remember exactly what I was doing or why. The correct version is as you state.
20:23:48 <troutwine> Hrm, maybe that's baked into my currently compiled server?
20:24:02 <Saizan_> it could
20:24:22 <Saizan_> also i don't get if your python program is sending a Get or not
20:24:38 <Saizan_> it constructs the message, but it doesn't sendto
20:24:49 <troutwine> Heh.
20:25:05 * troutwine smacks forehead
20:25:23 <troutwine> Thanks Saizan_.
20:25:30 <Saizan_> np
20:26:24 <troutwine> Yep, just a silly problem on the python end.
20:26:49 <Cale> I watched a really amusing talk about the Python GIL the other night. There are some insane interactions which cause multithreaded python programs to run significantly slower on multiple cores than on a single core.
20:27:40 <Cale> http://blip.tv/file/2232410
20:27:56 <Cale> (I recall someone else linked it here...)
20:28:53 <troutwine> Generally you get around that by writing an extension in C, release the GIL manually and multi-thread to your heart's contentment. Then you deal with segfaults and inexplicable memory leaks because of interactions with the python garbage collector and sloppy programming on your part...
20:29:04 <scutigera> isn't global and lock in the same sentence a bad thing ?
20:32:28 <heatsink> Yeah, but Python is not designed for multithreading.  Or speed.  Or being compiled.
20:33:10 <Saizan_> Or ... Or ...
20:33:27 <ivanm> shapr: so no, I won't be riding your unicycle
20:33:40 <scutigera> what's really cool is that if you have an UNINITIALIZED var in an if branch that only gets taken on an error condition.
20:33:58 <scutigera> you don't find out about it until you hit the error condition. ugly...
20:34:41 * gwern is sick of these pythons on this unicycle!
20:35:49 <aavogt> @quote snakes
20:35:49 <lambdabot> emertens says: screw ruby on rails, I'm using snakes on a plane
20:37:01 <shapr> too bad
20:37:07 <shapr> haha
20:37:23 <shapr> @quote
20:37:23 <lambdabot> megeria says: i am so new to haskell that i still have the new car smell
20:37:26 <scutigera> speaking of haskell what exactly does a decl like  r s -> t mean ? is r s a type, or...
20:37:37 <shapr> Looks like an mptc to me.
20:37:42 <shapr> multiparameter typeclass
20:37:46 <scutigera> shows up in monad speak, m a -> b, ...
20:37:49 <shapr> oh that
20:37:51 <shapr> That's different.
20:38:00 <byorgey> yes, that's a type
20:38:07 <shapr> and it's parameterized!
20:38:19 <byorgey> m a -> b  is the type of a function which takes a value of type 'm a' and returns a value of type 'b'.
20:38:21 <gwern> what majestic abstraction
20:38:31 <aavogt> but not a typeclass necessarily
20:38:49 <scutigera> so r s -> t is different how ?
20:38:50 <byorgey> I think maybe shapr was thinking of functional dependencies at first?  that's what I thought too
20:38:51 <shapr> scutigera: You know how a list can usually hold different things? You could make a list type, and then represent lists in a type signature with List Int or List Float or whatever.
20:38:55 <shapr> byorgey: Oh right, sorry.
20:39:08 <byorgey> scutigera: it isn't! =)
20:39:12 <byorgey> just different letters
20:39:30 <byorgey> but the particular letters that are used don't have any meaning.
20:39:39 <scutigera> so r s is the same as saying [r] ??
20:39:42 <byorgey> a -> a  is the same type as  b -> b  is the same type as  furgle -> furgle
20:39:49 <shapr> scutigera: You could make a box with data Candy a = Wrapper a and that would be just a wrapper on a type, yeah?
20:40:16 <byorgey> scutigera: r s  is the same as  [s], when  r is []
20:40:20 <shapr> Then a box with an Int inside would be "Wrapper 1" and its type would be "Candy Int"
20:40:27 <byorgey> that's kind of a bad example because of the weird list syntax though.
20:40:48 <scutigera> I do think I understand though.
20:40:51 <shapr> So if you had "Candy Int -> Double" instead of "r s -> t"
20:41:12 <shapr> It's a parameterized type variable.
20:41:40 <shapr> I dunno if I'm helping any.
20:41:48 <aavogt> you can write  ([] s)  instead of [s], which is more consistent with other parameterized types
20:42:03 <scutigera> yes, I saw that not too long ago.
20:42:18 <scutigera> I do like [s] notation better
20:42:40 <aavogt> @type []
20:42:42 <lambdabot> forall a. [a]
20:42:57 <scutigera> :type []
20:43:06 <scutigera> :t []
20:43:07 <lambdabot> forall a. [a]
20:43:09 <byorgey> scutigera: yes, no one actually writes  ([] s), but you should know that it is the same
20:43:37 <troutwine> It seems my _real_ problem, concerning the code I posted, was just overloading of the server, too many requests. For the record.
20:43:44 <scutigera> so monad stuff like m a is the same thing, it's just that m is understood to be a monad, right
20:43:46 <scutigera> ?
20:43:57 <scutigera> monad _type_
20:44:00 <aavogt> using [] as a type is sort of strange, since [] is a value of type ([] a)
20:44:19 * aavogt is likely not clarifying anything
20:44:43 <slehuito> Hi! I try to extract (e.g.) the 3rd element of a list in a "safe" manner (i.e. never have exception if list is too short), while still using (!!). The following code "xtrVal l = catch (return $ Just $ l !! 2) (\e -> return Nothing)" does not work as expected (by me, that is;-): if I ask ghci "xtrVal []", I get the following result: "Just *** Exception: Prelude.(!!): index too large". Any hint, please?
20:45:01 <aavogt> scutigera: in the whole type, you have a   Monad m => m a -> m b
20:45:41 <aavogt> without the 'Monad m =>' part, m could be any type that takes a single parameter
20:46:09 <scutigera> got it !
20:46:49 <aavogt> > take 1 . drop 3 $ [1,2]
20:46:50 <lambdabot>   []
20:46:53 <aavogt> > take 1 . drop 3 $ [1..]
20:46:54 <lambdabot>   [4]
20:47:27 <aavogt> @hoogle listToMaybe
20:47:27 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
20:47:44 <copumpkin> @let moo x = head . drop x $ [0..]
20:47:46 <lambdabot>  Defined.
20:48:02 <aavogt> > moo (-1)
20:48:04 <lambdabot>   0
20:48:46 <aavogt> head is unsafe
20:49:22 <Twey> aavogt: Yes, but here it's safe
20:49:27 <hackagebot> libxml-sax 0.1 - Bindings for the libXML2 SAX interface (JohnMillikin)
20:49:44 <Twey> [0..] is infinite, so no matter how many we drop according to x, there's always going to be at least one element left
20:49:53 <slehuito> aavogt: Thanks! In addition to my code not working, I was quite unsatisfied to be forced to jump in the IO monad to catch the potential exception!
20:50:04 <scutigera> > drop -1 [1,2]
20:50:06 <lambdabot>   Add a type signature
20:50:15 <scutigera> > drop -1 [1,2::Int]
20:50:16 <lambdabot>   No instance for (GHC.Num.Num (GHC.Types.Int -> [a] -> [a]))
20:50:17 <lambdabot>    arising from...
20:50:23 <aavogt> @type - 1
20:50:24 <lambdabot> forall a. (Num a) => a
20:50:30 <scutigera> > drop (-1) [1,2]
20:50:32 <lambdabot>   [1,2]
20:50:58 <scutigera> > drop 3 [1,2]
20:51:00 <lambdabot>   []
20:51:27 <scutigera> that - thing drives me crazy...
20:51:41 <byorgey> yes, it's quite annoying
20:51:41 <scutigera> better than ~ in ML though !
20:51:50 <byorgey> I'm not sure I agree =)
20:52:12 <aavogt> Twey: true, though in many cases a lists' infiniteness is hard to be assured of
20:52:23 <scutigera> well same problem and native printing of neg numbers is ~num. _very_ irritating.
20:53:07 <aavogt> @hoogle ~
20:53:08 <lambdabot> keyword ~
20:53:08 <lambdabot> Test.HUnit.Base (~:) :: Testable t => String -> t -> Test
20:53:08 <lambdabot> Test.HUnit.Base (~=?) :: (Eq a, Show a) => a -> a -> Test
20:54:22 <aavogt> @let (~) = error "reserved?"
20:54:22 <lambdabot>   Parse error
20:54:36 <aavogt> @let (~x) = error "reserved?"
20:54:38 <lambdabot>  Defined.
20:55:22 <aavogt> > let ~x = ~x in "shadowed?"
20:55:23 <lambdabot>   Pattern syntax in expression context: ~x
20:55:32 <aavogt> > let ~x = (~x) in "shadowed?"
20:55:34 <lambdabot>   Pattern syntax in expression context: ~x
20:55:36 <scutigera> aavogt: I was referring to use of ~ in ML as negation operator.
20:57:21 <aavogt> > x
20:57:22 <lambdabot>   Ambiguous occurrence `x'
20:57:22 <lambdabot>  It could refer to either `L.x', defined at <local...
20:59:43 <aavogt> scutigera: yes, it seems like ML would have simpler parsing rules, since they don't reuse characters as much as Haskell
21:00:17 <aavogt> I have no idea whether I defined x lazily, or (~x)
21:00:41 <aavogt> > ~x
21:00:43 <lambdabot>   Pattern syntax in expression context: ~x
21:00:46 <aavogt> > (~x)
21:00:47 <lambdabot>   Pattern syntax in expression context: ~x
21:00:58 <heatsink> > let (~) = (+) in (~x)
21:00:59 <lambdabot>   <no location info>: parse error on input `)'
21:01:51 <m3ga> arjanoosting: hi
21:01:59 <heatsink> seems like ~ isn't an infix operator
21:12:35 <hackagebot> happstack-data 0.3.1 - Happstack data manipulation libraries (MatthewElder)
21:13:01 <aavogt> heatsink: ~ is reserved for patterns where it means that the pattern match is lazy
21:13:36 <hackagebot> happstack-ixset 0.3.1 - Efficient relational queries on Haskell sets. (MatthewElder)
21:13:36 <hackagebot> happstack-server 0.3.1 - Web related tools and services. (MatthewElder)
21:14:37 <hackagebot> happstack-state 0.3.1 - Event-based distributed state. (MatthewElder)
21:14:37 <hackagebot> happstack-util 0.3.1 - Web framework (MatthewElder)
21:14:37 <hackagebot> happstack 0.3.1 - The haskell application server stack + code generation (MatthewElder)
21:18:22 <ivanm> happstack package spam! :p
21:37:18 <Gracenotes> :o
21:42:46 <hackagebot> happstack-util 0.3.2 - Web framework (MatthewElder)
21:43:40 <mae> fear my package spam
21:43:46 <hackagebot> happstack-data 0.3.2 - Happstack data manipulation libraries (MatthewElder)
21:43:46 <hackagebot> happstack-state 0.3.2 - Event-based distributed state. (MatthewElder)
21:43:46 <hackagebot> happstack-ixset 0.3.2 - Efficient relational queries on Haskell sets. (MatthewElder)
21:43:46 <hackagebot> happstack-server 0.3.2 - Web related tools and services. (MatthewElder)
21:43:46 <hackagebot> happstack 0.3.2 - The haskell application server stack + code generation (MatthewElder)
21:46:14 <thoughtpolice> woot
21:46:20 <Saizan> mae: you fixed a bug in 0.3.1 in such a short time?:)
21:46:42 <mae> Saizan: the upper bounds for 0.3.1 was not placed in happstack
21:46:46 <mae> so it could point to old dev versions
21:47:02 <Gracenotes> whar is mah haddocks! :D
21:47:06 <Gracenotes> D:
21:47:11 <mae> + 0.3.1 was in limbo for a long time so I didn't want there to be any ambiguity if people had been using ~0.3.1 from the dev repo
21:47:40 <mae> Saizan: yeah, i'm that good, fixing bugs in mere minutes!
21:48:11 <mae> but it wasn't a program bug, it was avoiding human bugs where people have different floating versions of what they call 0.3.1 making ML posts a pain in the ass :)
21:48:50 <mae> Saizan: btw, while i have you here, that TH code which automagically detects if there is a constructor for ipv6 does not work anymore with 6.10.3
21:48:53 <mae> not sure why
21:54:46 <mae> dcoutts: how does the haddock documentation building work on hackage, is it an asynchronous process?
21:55:24 <Saizan> mae: yup, a cron job or something like that
21:55:58 <Saizan> hoping the dependencies have the haddock built..
21:56:27 <mae> how often is it retried
21:56:28 <mae> hehe
21:57:03 <Saizan> that i don't know
21:57:10 <mae> k
21:57:34 <Gracenotes> I like how everyone survives gunshot wounds in Firefly
22:38:18 <aledge> I'm running into a common pattern into my code but I'm not sure how to factor it out. I'm using an association list (the type declaration is called Bindings). I'm repeatedly looking up a key. If the result is Nothing, then I do one thing (not simply return nothing), and if it's a Just, then I do something else.
22:40:33 <ivanm> aledge: the maybe function?
22:40:35 <ivanm> @type maybe
22:40:36 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
22:40:37 <ivanm> @src maybe
22:40:38 <lambdabot> maybe n _ Nothing  = n
22:40:38 <lambdabot> maybe _ f (Just x) = f x
22:40:55 <ivanm> (which is a fold over the Maybe data type)
22:41:00 <aledge> oh hm
22:41:02 <aledge> maybe
22:41:03 <aledge> hee
22:41:04 <aledge> *hehe
22:41:09 <aledge> i'll take a look at that
22:41:13 <aledge> also need to look at my code again
22:41:44 <aledge> oh i think that's probably what i want
22:41:45 <aledge> hehe
22:41:52 <aledge> thanks
22:41:58 <ivanm> no worries
22:42:12 <aledge> how do you know when you should make what you're working with an instance of monad
22:42:43 <aavogt> @type join
22:42:45 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
22:42:51 <aavogt> @type return
22:42:52 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
22:42:55 <aavogt> @type >>=
22:42:56 <lambdabot> parse error on input `>>='
22:43:00 <aavogt> @type (>>=)
22:43:01 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
22:43:44 <aavogt> aledge: if you end up with functions with the above types, you may have a Monad
22:43:54 <aledge> i see
22:44:12 <aledge> i guess that should have been an obvious answer
22:45:41 <aavogt> aledge: there are more general (less restrictive in their requirements) typeclasses, Functor and Applicative you can look for.
22:46:14 <aavogt> @where typeclassopedia
22:46:15 <lambdabot> I know nothing about typeclassopedia.
22:46:21 <aavogt> @google typeclassopedia
22:46:23 <lambdabot> http://byorgey.wordpress.com/2009/02/16/the-typeclassopedia-request-for-feedback/
22:46:23 <lambdabot> Title: The Typeclassopedia — request for feedback « blog :: Brent -> [String]
22:47:40 <aavogt> ^^ that's a good resource for understanding how such typeclasses are related
22:48:55 <aavogt> ivanm: I never saw 'maybe' as a fold before
22:49:09 <ivanm> aavogt: technically, it is
22:49:14 <ivanm> since you replace the constructors
22:49:24 <aavogt> @type flip maybe
22:49:25 <lambdabot> forall a a1. (a1 -> a) -> a -> Maybe a1 -> a
22:49:38 <ivanm> traditionally, however, most of us only consider list folds as folds
22:49:56 <ivanm> aavogt: well, flipped version might be closer to a fold, but that's a matter of definition, not what it does
22:49:59 <ivanm> it acts as a fold
22:50:12 <aavogt> though the function only takes one argument
22:50:26 <ivanm> aavogt: ummmm.... why shouldn't it?
22:50:39 <ivanm> a fold function replaces the constructors
22:50:56 <aledge> i've never thought about it that way
22:51:02 <aledge> though i guess i've only used fold over lists
22:51:14 <aavogt> foldSpecializedAsMaybe :: (a -> b -> a) -> a ->  Maybe b -> a
22:51:19 <aledge> so i think of it as reducing a structure...which is a fairly limited way of thinking about it
22:51:19 <ivanm> for lists,  "fold{r,l} f e" replaces all : with f and [] with e
22:51:31 <ivanm> aavogt: no
22:51:53 <ivanm> list folds take two params for the function, because the constructor takes two params
22:52:15 * ivanm is pretty sure he is right... ;-)
22:52:30 <aavogt> @type Data.Foldable.foldr ?f ?ini Nothing
22:52:31 <lambdabot> forall a b. (?ini::b, ?f::a -> b -> b) => b
22:52:45 <aavogt> @type Data.Foldable.foldr ?f ?ini (Just ?c)
22:52:46 <lambdabot> forall a b. (?c::a, ?ini::b, ?f::a -> b -> b) => b
22:53:05 <ivanm> aavogt: Foldable is used for "grouping" data structures AFAICT
22:53:28 <aavogt> ivanm: I see your argument though
22:53:55 <ivanm> if you define Peano numbers with "data Nat = Zero | Succ Nat", then you have fold s z Zero = z, fold s z (Succ n) = s (fold s z n)
22:54:12 <Twey> > foldl (:) [1..5] 6
22:54:14 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
22:54:25 <Twey> > foldl (:) 6 [1..5]
22:54:27 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
22:54:33 <Twey> Hmph
22:54:38 <ivanm> Twey: wrong type sig
22:54:47 <ivanm> > foldl (flip (:)) 6 [1..5]
22:54:48 <lambdabot>   No instance for (GHC.Num.Num [b])
22:54:48 <lambdabot>    arising from the literal `6' at <inter...
22:54:52 <ivanm> gah
22:54:54 <ivanm> @type foldl
22:54:56 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
22:55:18 <ivanm> @type flip (:)
22:55:19 <aavogt> > foldl (:) [6] [1..5]
22:55:20 <lambdabot> forall a. [a] -> a -> [a]
22:55:20 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
22:55:24 <Twey> 06:51:19 < ivanm> for lists,  "fold{r,l} f e" replaces all : with f and [] with e
22:55:29 <ivanm> > foldl (flip (:)) [6] [1..5]
22:55:31 <lambdabot>   [5,4,3,2,1,6]
22:55:36 <ivanm> Twey: I never said what order though ;-)
22:55:38 <aavogt> > foldr (:) [6] [1..5]
22:55:39 <lambdabot>   [1,2,3,4,5,6]
22:55:50 <Twey> Clearly it doesn't, or foldl1 (:) would be id on lists :-P
22:55:52 <ivanm> and you have to make sure the types match up
22:56:03 <ivanm> Twey: well.... shut up! :p
22:56:31 <Twey> Apart from on the empty list, of course
22:56:37 <Twey> But you get what I mean :-P
22:56:55 <ivanm> yeah
22:57:03 <ivanm> foldr is the more "traditional" fold
22:57:18 <Berengal> Twey: Well, it does, but foldl does it in a left-associative manner, which produces the type failure
22:57:40 <Berengal> 1:2:3:[] -> ((1:2):3):e
22:58:48 <aavogt> ivanm: but we have Foldable for trees too (things with N-ary constructors)
23:12:00 <aavogt> do other languages have sections as in haskell?
23:12:11 <aavogt> @type (+1)
23:12:12 <lambdabot> forall a. (Num a) => a -> a
23:12:19 <aavogt> ^^ like that
23:15:51 <dfrey> I'm interested in case-insensitive regular expressions.  It looks to me like Text.Regex.Posix only exposes a means to do case-sensitive matching.
23:17:06 <dfrey> It also looks like Text.Regex.Posix.String exposes a means to compile and execute regular expressions.
23:18:27 <dfrey> What I found surprising was that the compile and execute functions result in an IO value
23:18:48 <dfrey> Why do compile and execute have to produce an IO result when =~ does not?
23:19:10 <quicksilver> because you want to control how often the compilation happens, I suppose
23:19:16 <quicksilver> I'm only guessing, haven't looked at the api
23:19:48 <dfrey> I guess that makes sense
23:20:54 <dfrey> It's just annoying that I have to make my function impure in order to do case insensitive regular expression matching.
23:35:28 <dfrey> Actually, I think what I said about needing to convert to IO may be false.
23:35:44 <dfrey> I think I just need to figure out how to pass options to the =~ operator
23:37:25 <aavogt> @hoogle =~
23:37:25 <lambdabot> No results found
23:40:00 <Twey> dfrey: I suspect Text.Regex.Posix.compIgnoreCase and Text.Regex.mkRegexWithOpts could be found useful by you
23:44:26 <Cale> > match (makeRegexOpts compIgnoreCase execBlank "abc") "AbC" :: Bool
23:44:28 <lambdabot>   True
23:45:39 <Cale> For something which has so many contextual instances, it's surprising there isn't a newtype wrapper or something for that.
23:46:22 <dfrey> Cale: Where does makeRegexOpts come from?
23:46:43 <Cale> Text.Regex.Base.RegexLike
23:47:01 <Cale> (but it should be there if you import Text.Regex.Posix)
23:48:33 <Twey> Nope, it's not exported by Text.Regex.Posix
23:48:50 <Cale> What version are you using?
23:49:03 <Cale> Prelude Text.Regex.Posix> match (makeRegexOpts compIgnoreCase execBlank "abc") "AbC" :: Bool
23:49:03 <Cale> True
23:49:04 <Twey> 6.10.3
23:49:14 <Cale> Loading package regex-base-0.93.1 ... linking ... done.
23:49:14 <Cale> Loading package regex-posix-0.94.1 ... linking ... done.
23:49:37 <Twey> Prelude Text.Regex.Posix> match (makeRegexOpts compIgnoreCase execBlank "abc") "AbC" :: Bool
23:49:42 <Twey> <interactive>:1:0: Not in scope: `match'
23:49:46 <Cale> huh
23:49:48 <Twey> <interactive>:1:7: Not in scope: `makeRegexOpts'
23:50:00 <Cale> What version of regex-base/posix?
23:50:22 <Cale> I got mine from hackage not so long ago
23:50:24 <Twey> Hm
23:50:32 <Twey> Don't they come with GHC?
23:50:47 <Twey> I'm using the built-in one, I think
23:50:53 <Cale> I think the ones which come with GHC are a bit older, perhaps
23:51:04 <Twey> Could be
23:52:10 <dfrey> What does a type like this really mean?  "RegexMaker Regex CompOption ExecOption source"   That's the pattern expected by the =~ operator
23:52:50 <dfrey> Specifically, I don't understand what it means to have "Type1 Type2 Type3 x"
23:53:03 <Cale> RegexMaker is a typeclass
23:53:38 <Cale> Whoever designed the Regex libraries went a little overboard with the polymorphism perhaps ;)
23:55:19 <Cale> RegexMaker regex compOpt execOpt source  expresses that some type of compiled regular expressions regex can be created from some source type source (usually String) and options of appropriate types
23:55:48 <Cale> RegexMaker Regex CompOption ExecOption String  is an instance
23:56:18 <Cale> makeRegexOpts :: (RegexMaker regex compOpt execOpt source) => compOpt -> execOpt -> source -> regex
23:56:18 <TheColonial> hey guys, what's the pastie site that allows you to specify a channel to send the URL to?
23:56:50 <Cale> and so that simplifies to  makeRegexOpts :: CompOption -> ExecOption -> String -> Regex
23:56:52 <ivanm> no idea... hpaste used to, but the bot is down
23:57:13 <Cale> You can also use a ByteString for the source
23:57:26 <Cale> and there are a bunch of other regex libraries which use this interface
23:57:27 <ivanm> and AFAIK, there's only two other bots here ( lambdabot and preflex ), neither of which check on paste sites
23:57:53 <ivanm> TheColonial: ^^ I was talking to you there ;-)
23:58:03 <Cale> (Whether that is really genuinely a useful kind of polymorphism is questionable)
23:58:17 <TheColonial> ivanm: thanks. I used one recently and I can't remember that it was. None of what you mentioned rings a bell (yes, sorry for slow response!)
23:58:27 <ivanm> heh
23:58:35 <Twey> See, this would be much easier to read if we had ad-hoc extension of types :-P
23:58:53 <ivanm> AFAIK, all those paste sites use a bot to say that there's a new paste
23:59:05 <ivanm> hpaste used to have the hpaste bot to do that, but it's down
23:59:12 <ivanm> (the bot, not the site)
23:59:52 <Cale> ad-hoc extension of types?
