00:00:11 <pumpkin> well, an accurate parser is just something that checks for isDigit
00:00:17 <pumpkin> > isDigit 'a'
00:00:18 <lambdabot>   False
00:00:21 <pumpkin> yeah
00:00:30 <pumpkin> since I'm just doing integers :)
00:00:53 <ski> so no decimal points, `E'/`e', `+'/`-' maybe even stuff telling the base of the number ?
00:01:09 <pumpkin> > read "0x52" :: Integer
00:01:10 <lambdabot>   82
00:01:12 <pumpkin> crap
00:01:16 <ski> well, you need to check for `-' at the beginning at least, then ?
00:01:17 <pumpkin> I guess I can't be as simplistic as I hoped
00:01:19 <pumpkin> yeah
00:01:23 <pumpkin> > read "052" :: Integer
00:01:24 <lambdabot>   52
00:01:33 <pumpkin> I'm glad haskell is sane about that at least
00:01:40 <ricardolost84> hello
00:01:46 <ski> do you need to allow non-decimal bases for this C-type ..
00:01:56 <ski> hm, maybe you do, because of `fromInteger'
00:02:01 <pumpkin> ski: I'm just reimplementing Integer for ghc
00:02:05 <ski> oh
00:02:13 <pumpkin> ski: so I need to support 0x, + and - I guess
00:02:18 <pumpkin> > read "+5" :: Integer
00:02:19 <lambdabot>   * Exception: Prelude.read: no parse
00:02:23 <pumpkin> not even + then
00:02:42 <ski> > 1.23E45
00:02:43 <lambdabot>   1.23e45
00:02:44 <ski> > 1.23E-45
00:02:45 <lambdabot>   1.23e-45
00:02:46 <ski> > 1.23E+45
00:02:47 <lambdabot>   1.23e45
00:02:55 <pumpkin> > read "1.23E10" :: Integer
00:02:56 <lambdabot>   * Exception: Prelude.read: no parse
00:02:56 <ski> (that was the `+' i was thinking of, above)
00:02:56 <ray> <pumpkin> NOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
00:03:02 <pumpkin> ray: ?
00:03:14 <ray> that's your reaction if you had to implement that
00:03:22 <pumpkin> ski: I'm just reproducing current Integer behavior exactly so I don't need that :)
00:03:30 <ski> *nod*
00:03:59 <ski> > read "0o52" :: Integer
00:04:00 <lambdabot>   42
00:04:03 <pumpkin> ew
00:04:07 <pumpkin> dammit :P
00:04:14 <pumpkin> I was hoping they'd have left octal out
00:04:15 <ray> *life ruined*
00:04:24 <ray> octal's not any uglier than hex
00:04:30 <ray> well, it's uglier, but not to implement
00:04:30 <pumpkin> ah well, it's not that hard to implement
00:04:43 <pumpkin> GMP allows me to specify the base to read
00:04:45 <pumpkin> so it can do it for me
00:04:51 <pumpkin> I just need to figure out what to give it
00:04:56 <pumpkin> should be straightforward
00:06:19 <pumpkin> Lemmih: you did the SDL binding?
00:07:31 <ski> > 0x3.243f6a8885
00:07:32 <lambdabot>   Not in scope: `f6a8885'
00:07:38 <pumpkin> :o
00:07:46 <pumpkin> is that pi?
00:08:09 <pumpkin> > 2 / 16 + 4 / 256
00:08:10 <lambdabot>   0.140625
00:08:23 <pumpkin> :)
00:08:24 * ski never understood why there's usually no hexadecimals/binals/et.c support in programming languages
00:08:35 <pumpkin> yeah
00:08:42 <Lemmih> pumpkin: Guilty as charged.
00:09:03 <pumpkin> Lemmih: any idea if there's a way to get a "run once at startup" IO function for a library?
00:09:12 <pumpkin> in GHC if not in general
00:09:19 <ski> (it might come in handy with the `FixedFoo' types)
00:09:43 <Lemmih> pumpkin: Nope, sorry.
00:10:02 <dmwit> ski: I never thought about it, but now that you mention it, it is kind of odd that hex and octal are restricted to integer values.
00:10:29 <dmwit> ski: Of course, the motivation for them is to represent things close to the actual bit-representation in hardware.
00:10:48 <ski> mostly, yes
00:10:49 <dmwit> ski: And Floats don't necessarily store similar bit-patterns to what you would type as a hex floating point.
00:10:53 <dmwit> so...
00:11:27 <ski> but consider a type like `Int32', except 16 of the bits is for binals, and 15 for the intergral part
00:11:55 <dmwit> Hah!  You can't fool me.
00:11:57 <dmwit> oh wait
00:12:00 <dmwit> maybe you can
00:12:25 <dmwit> Yeah, non-floating point could be reasonably represented that way.
00:12:26 * ski wonders how he's supposed to fool dmwit
00:12:44 <dmwit> I was going to say that adds up to 31 bits, but Int only guarantees 29... but you said Int32. ;-)
00:13:34 <dmwit> ski: unsafeCoerce# 0x24242424{-.-}363636
00:13:35 <dmwit> ;-)
00:13:52 <dmwit> > 0x3{- does this actually work? -}6
00:13:52 <lambdabot>   Add a type signature
00:13:53 <ski> > 0x24242424{-.-}363636
00:13:54 <lambdabot>   Add a type signature
00:13:57 <dmwit> !
00:13:59 <ski> > 0x24242424{-.-}363636 :: Integer
00:13:59 <dmwit> > 0x3{- does this actually work? -}6 :: Int
00:14:00 <lambdabot>   No instance for (GHC.Num.Num (t -> GHC.Integer.Internals.Integer))
00:14:01 <lambdabot>    arisi...
00:14:01 <lambdabot>   No instance for (GHC.Num.Num (t -> GHC.Types.Int))
00:14:01 <lambdabot>    arising from the lite...
00:14:04 <dmwit> ah
00:14:06 <dmwit>  heh
00:14:11 <dmwit> > 0x3 6 :: Int
00:14:11 <lambdabot>   No instance for (GHC.Num.Num (t -> GHC.Types.Int))
00:14:12 <lambdabot>    arising from the lite...
00:14:14 <dmwit> =)
00:14:45 <ski> no C-like `foo/*...*/bar' symbol appending, here !
00:15:04 <ski> (i suppose s/symbol/token/)
00:15:28 <dmwit> Yeah, it would be nasty for the lexer to be context-free rather than regular, I guess.
00:15:40 <dmwit> (due to nested comments being allowed)
00:18:16 <sm> I don't get it.. why does ghc think this pattern is incomplete ? http://gist.github.com/124122
00:18:53 <pumpkin> sm: can non-Commodity things be placed into it?
00:19:05 <pumpkin> or does Amount have any other data constructors than Amount?
00:19:17 <sm> I don't believe so
00:19:33 <sm> is it analysing the | cases as well ?
00:19:34 <ski> sm : don't use `==' when you can match
00:19:54 <ski> (or in case you want to give up, use `otherwise'/`True' in a last guard)
00:20:13 <sm> hmm
00:20:15 <sm> ha
00:20:27 <akamaus> I'm struggling trying to figure out how to catch exceptions in the BrowserAction monad which is defined in Network.Browser. Can someone help me?
00:20:49 <ski> sm : it's almost surely not understanding that there is no other choice than `side==L = True' or `side==R = True'
00:21:34 <dmwit> akamaus: Network.Browser, eh?
00:21:39 <dmwit> akamaus: Which package is that in?
00:21:46 <akamaus> http
00:22:00 <sm> I see
00:22:06 <dmwit> ?hackage http
00:22:06 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/http
00:22:20 <dmwit> bah
00:22:26 <dmwit> You'd think lambdabot could at least check case.
00:22:38 <ski> sm : if you want to keep the `where'-clauses, use a `case' (but you can still split the `sym' matches `"AUTO"' case into a separate equation)
00:22:45 <akamaus> http://hackage.haskell.org/packages/archive/HTTP/4000.0.6/doc/html/Network-Browser.html
00:22:47 <ivanm> dmwit: well, it's just a ++
00:22:52 <sm> and your give up tip is a more readable way to silence the one I was just working on
00:22:56 <ivanm> @hackage madeUpPackageName
00:22:56 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/madeUpPackageName
00:23:29 * sm tries
00:23:48 <dmwit> akamaus: Looks like you just have to catch things in the IO monad.
00:23:48 <ski> @. hackage run text " "
00:23:49 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/
00:24:03 <dmwit> akamaus: Whoever implemented it did some strange things.
00:24:22 <akamaus> dmwit, but I'd like to preserve the state, cookies etc..
00:24:25 <dmwit> For example, BrowserAction conn a ~= StateT (BrowserState conn) IO a
00:24:40 <akamaus> dmwit, yeah, looks similar
00:24:44 <dmwit> but that's expanded out in a data declaration, and has its own Monad instance. =/
00:25:41 <akamaus> dmwit, what's about modifing it? I like the way it works with cookies
00:25:43 <dmwit> akamaus: Well, there's setErrHandler.
00:26:02 <akamaus> dmwit, setErrHandler is just for error reporting
00:26:09 <dmwit> akamaus: But it's super-odd that it's not just defined as a transformer, as that means there's no liftIO.
00:26:12 <dmwit> That seems really annoying.
00:26:23 <akamaus> dmwit, I can add it if needed
00:27:04 <dmwit> If so, perhaps you can just lift a catch into the BrowserAction monad.
00:27:06 <dmwit> :t catch
00:27:07 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
00:27:13 <akamaus> the problem is that 'try' accepts IO, not BrowserAction
00:27:26 <akamaus> and catch..
00:27:59 <dmwit> Yep, it looks like you need access to the BrowserAction constructor to do what you want.
00:27:59 <akamaus> dmwit, I cant figure out how to lift it, looks like state will be lost
00:28:06 <dmwit> Which may be hidden for a legitimate reason.
00:28:20 <dmwit> i.e. if an error occurs, maybe the cookies and browser state are not left in a consistent state or something.
00:29:13 <akamaus> dmwit, seems it's not the case, they run action several times and then give up by calling 'fail'
00:29:31 <sm> ski: I see..moving it into a case takes it out of the gaze of the pattern checker
00:29:39 <akamaus> dmwit, look in request'
00:29:45 <sm> thanks
00:30:07 <dmwit> akamaus: meh, the design of this library seems a bit... haphazard.
00:30:35 <akamaus> dmwit, I become to feel the same )
00:30:43 <akamaus> are there alternatives?
00:30:54 <dmwit> curl?
00:31:18 <ski> ( sm : rather "takes it *into* the gaze of the pattern checker", i'd say)
00:31:26 <dmwit> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/curl
00:31:38 <akamaus> hm.. should have a look at it
00:32:22 <sm> hmm
00:32:37 <akamaus> I wish hackage had some kind of rating system for packages or so..
00:33:09 <pumpkin> and a wiki!
00:33:21 <sm> well ghc's happy and more warnings await, I must not obsess
00:35:01 <sm> akamaus: and showed the package list as front page, and had intuitive urls for packages
00:36:21 <akamaus> sm, I think it's to much of them for the front page ;)
00:36:42 <sm> why does the front page have to be short ?
00:36:52 <dmwit> Yeah!
00:37:00 <dmwit> Hackage v2.0, coming right up!
00:37:08 <sm> the current front page is just an about page
00:37:30 <pumpkin> don't forget the rounded edges, sans serif fonts, and starburst "Beta" logos
00:39:38 <akamaus> sm, maybe because one should be prepared before diving into depths of libraries?
00:40:21 <sm> I just don't understand that
00:40:43 <sm> how often do you go to hackage and don't want to see the... drum roll.. *packages*
00:40:52 <maltem> The one issue that I have with Hackage is the URL of the packages list is so long :)
00:41:40 <maltem> Really hackage.haskell.org/packages should at least redirect there
00:42:13 <dmwit> Really hackage.haskell.org/curl should be the URL for the curl package.
00:42:21 <dmwit> And hackage.haskell.org should be the URL for the packages list.
00:42:26 <dmwit> This is pretty basic UI stuff.
00:42:46 <FalconNL> Hi everyone. A few days ago I started learning Template Haskell and now I've written a library that more or less allows inheriting record fields. If anyone's interested, I'd love to get some feedback before I put it on Hackage, particularly whether there's anything useful I've not yet implemented. The tutorial can be found at http://codepad.org/csslJ7IZ
00:42:47 <sm> dmwit: ah! a sane person!
00:43:02 * sm waves happily
00:43:06 <dmwit> o/
00:45:59 * maltem was about to ask dmwit what would happen if someone then released a packages package :)
00:47:03 <Cale> I just thought of something regarding unamb...
00:47:14 <pumpkin> what about it?
00:47:36 <Cale> Suppose we have x = unamb a y, and y = unamb b c
00:48:01 <Cale> and at some point we evaluate x, and 'a' succeeds in evaluating first.
00:48:33 <Cale> Then later, we evaluate y, and suddenly it needs to try evaluating b and c again
00:49:09 <Cale> But given the precondition on unamb, it shouldn't really have to. We've succeeded in computing a value, namely, that of 'a', which ought to do.
00:50:09 <Cale> So it seems like it would be nice to arrange for all the losers to somehow get information about the value which ended up winning too.
00:50:55 <pumpkin> hmm
00:51:00 <augustss> Sounds like a multiargument unamb
00:51:06 <maltem> Why would you evaluate y if you defined x at the “top”?
00:51:55 <maltem> s/would you/would you want to/
00:52:30 <Cale> maltem: Well, I'm not suggesting that the program actually looks like this. Maybe the unamb'd terms are part of some recursive algorithm, and not all of them are in scope at once.
00:52:55 <Cale> (I just want for x and y to have those expressions as values)
00:53:13 <maltem> ok
00:53:55 <Cale> By breaking the precondition, we can observe that the current library doesn't do this:
00:54:05 <Cale> Prelude Data.Unamb> let x = unamb 1 2
00:54:05 <Cale> Prelude Data.Unamb> let y = unamb 3 x
00:54:05 <Cale> Prelude Data.Unamb> x
00:54:05 <Cale> 1
00:54:05 <Cale> Prelude Data.Unamb> y
00:54:05 <Cale> 3
00:54:32 <augustss> By breaking the preconding you might lunch missiles for all we know.
00:54:39 <augustss> precondition
00:54:52 <augustss> launch!
00:55:02 <augustss> grrrr, no coffee yet :)
00:55:15 <Cale> er, actually, that was the wrong way around anyway
00:55:42 <Cale> Prelude Data.Unamb> let x = unamb 1 2
00:55:42 <Cale> Prelude Data.Unamb> let y = unamb 3 x
00:55:42 <Cale> Prelude Data.Unamb> y
00:55:42 <Cale> 3
00:55:42 <Cale> Prelude Data.Unamb> x
00:55:42 <Cale> 1
00:55:47 <Cale> better test :)
00:56:41 <sm> mzero inside a parsec parser would mean "this parser failed", is that right ?
00:56:43 <Cale> I don't expect smaller completed subcomputations necessarily to be able to inform larger ones they become part of, but that large computations which finish to inform each of their components.
00:56:49 <Cale> sm: yes
00:56:53 <sm> thx
00:57:06 <Cale> sm: It's the parser which doesn't match any string.
00:58:25 <Cale> anyway, this unamb thing seems like something to think about
00:58:39 <Cale> I fear that it's already complicated enough though ;)
01:04:54 <maltem> What monad transformer library do the cool kids use today? mlt, monads? -tf or no -tf?
01:05:28 <dmwit> tf?
01:05:54 <Cale> maltem: Well, many many things are linked to mtl, but mtl is not very cool.
01:06:00 <MyCatVerbs> t and f are close to f and d onna keyboard.
01:06:11 <MyCatVerbs> Assuming maltem types QWERTY.
01:06:20 <maltem> dmwit, apparently, type families instead of funct. dep.
01:06:31 <maltem> Cale, yeah, thus the question
01:06:42 <MyCatVerbs> Oh. Huh.
01:07:22 <dmwit> All the cool kids use category-extras. ;-)
01:07:53 <dmwit> But yeah, mtl is the only monad transformer library I know of, really.
01:08:22 <Cale> I think it would be interesting for someone to construct the mtl monads in terms of MonadPrompt. Actually, I should do that myself, as I already have the code for half of them.
01:09:50 * osfameron idly wonders whether knitting is monadic
01:11:05 <maltem> mm MonadPrompt doesn't even look uninteresting
01:11:27 <Cale> You need to look at the actual source to understand what's going on though :)
01:11:41 <Cale> http://hackage.haskell.org/packages/archive/MonadPrompt/1.0.0.1/doc/html/src/Control-Monad-Prompt.html
01:11:53 <Cale> Somehow it's not properly haddocked
01:13:47 <maltem> yeah figured that out
01:15:33 <Twey> Also, the syntax highlighter fails at LHS :)
01:17:18 <Cale> The fact that the monad laws cannot be broken with Prompt/RecPrompt is interesting.
01:17:53 <maltem> Twey, also hackage fails at printing slashes
01:18:08 <Cale> > liftP :: Prompt p r -> PromptT p m r
01:18:08 <Cale> > liftP = runPromptM prompt
01:18:10 <lambdabot>   Not in scope: type constructor or class `Prompt'Not in scope: type construc...
01:18:10 <lambdabot>   <no location info>: parse error on input `='
01:18:13 <Cale> ^^ so, so clever :)
01:20:32 * maltem went back to http://www.mail-archive.com/haskell-cafe@haskell.org/msg33040.html
01:23:01 <Cale> It's really a beautiful and underappreciated technique.
01:25:31 <hatds> if I want a symmetric difference for Data.Set do I really need to call union, intersection, and difference?  Seems like it won't be the most direct way
01:27:16 <dmwit> Just Do It
01:27:53 <dmwit> :t \a b -> a \\ b `union` b \\ a
01:27:54 <lambdabot>     Precedence parsing error
01:27:54 <lambdabot>         cannot mix `\\' [infix 5] and `\\' [infix 5] in the same infix expression
01:28:03 <dmwit> :t \a b -> (a \\ b) `union` (b \\ a)
01:28:04 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
01:34:56 <nominolo> @pl m >>= \c -> f c e
01:34:57 <lambdabot> flip f e =<< m
01:35:00 <WorkyBob> If anyone has any cunning ideas about this problem, I'd be really interested... http://noordering.wordpress.com/2009/06/05/collecting-non-memory-resources/
01:36:01 <nominolo> WorkyBob: do you know about the paper "lightweight static resources"
01:36:14 <WorkyBob> I don't *runs off to look it up*
01:38:05 <Gracenotes> D:
01:38:15 <WorkyBob> ?
01:38:17 <pumpkin> zomg Gracenotes
01:38:35 <Gracenotes> O:
01:39:34 <nominolo> WorkyBob: don't you actually want the resource management dto be done by the *compiled* program, though?
01:40:01 <WorkyBob> nominolo: no, the compiled program *is* the resource
01:40:14 <WorkyBob> it's a chunk of memory that gets shoved onto the GPU
01:40:24 <WorkyBob> and needs to be deleted when we can no longer run it
01:41:00 <nominolo> ah, but running it requires a reference to it, no?
01:41:05 <WorkyBob> exactly
01:41:21 <nominolo> so you would call it explicitly from within your haskell program
01:41:32 <WorkyBob> call what explicitly?
01:41:55 <nominolo> the compiled program (the bits in the graphics memory)
01:42:03 <WorkyBob> oh, yeh
01:42:28 <WorkyBob> the type Shader might be something like VertexArray -> NormalArray -> TexCoordArray -> IndexArray -> IO ()
01:42:43 <WorkyBob> give it a bunch of objects to render, and it produces an IO action that does the rendering
01:43:21 <voker57> how  to write type signature for Data.Map? Like :: Map (String, Int)
01:43:43 <WorkyBob> voker57: you want a map from strings onto ints?
01:43:49 <voker57> WorkyBob: yes
01:43:56 <WorkyBob> someMap :: Map String Int
01:44:04 <nominolo> WorkyBob: so, how does it happen that your shader code goes out of scope?
01:44:13 <voker57> works, thanks
01:44:46 <pumpkin> WorkyBob: can you give your compiler a buffer to compile to? if so, just give it a ByteArray# or something and let ghc take care of the rest?
01:44:55 <WorkyBob> nominolo: well for example myShader could be a constant defined in a render function, when execution leaves that function, myShader is no longer in scope, we can't run it, and the resources on the GPU should be collected
01:45:09 <pumpkin> oh, I see
01:46:10 <WorkyBob> pumpkin: unfortunately, no, the act of compiling is a matter of giving a couple of strings to opengl and getting back a single int that can be used as a reference to the GPU resource
01:46:31 <nominolo> WorkyBob: you mean a local function / variable? Hm.
01:46:41 <WorkyBob> indeed
01:47:32 <WorkyBob> or perhaps we get a Chan containing render configurations, we grab items out of it, compile the shader, use it a few times, and then throw it away
01:47:38 <WorkyBob> and move onto the next item in the chan
02:05:42 <Yakov> hey
02:51:39 <sm> hmm.. ghc manual and mail list buzz says to avoid orphan instances, but I have a lot and don't see how to get rid of them
02:52:15 <sm> without running into circular dependencies
02:55:51 <sm> I think they affect ghc only at compile time, not run time
03:03:08 <Peaker> sm: I think the idea is that the author of the class, or the author of the type, and not a 3rd party should be in charge of instances. If its a 3rd party, there's no way to have a policy that prevents instance collisions
03:03:25 <Peaker> (if the 3rd parties are not in sync with each other and the class/type authors)
03:03:48 <sm> right
03:04:44 <sm> in this case I own the type and the instances, but to avoid circular deps I have put types at the bottom in Types.hs and instances, which involve more complex interdependent code, in Type1.hs, Type2.hs ..
03:05:35 <Peaker> can't the instances be defined with the type, and just happen to call code that's somewhere else?
03:07:20 <Baughn> So I did this tiny little trivial cleanup-style change to reactive.. and ghc is now segfaulting
03:10:04 <pozic> Baughn: it's called reactive for a reason.
03:12:30 <ivanm> is there a way of removing the newline at the end of a String if there is one?
03:12:53 <Baughn> > lines "foo\n"
03:12:54 <ivanm> I could init it, but I'm not sure if I can guarantee that there will be a \n there, it just looks like there will be
03:12:54 <lambdabot>   ["foo"]
03:13:01 <Baughn> > lines "foo"
03:13:02 <lambdabot>   ["foo"]
03:13:17 <ivanm> yeah, I could do head . lines ...
03:13:23 <ivanm> looks a bit hackish to me...
03:13:26 <ivanm> *shrug* oh well
03:13:33 <MyCatVerbs> > map (unlines . lines) ["foo\nbar","foo\nbar\n"]
03:13:34 <lambdabot>   ["foo\nbar\n","foo\nbar\n"]
03:13:44 <MyCatVerbs> Oh fun.
03:13:55 <Twey> Heh
03:14:12 <Twey> > unlines $ lines "foo\r\nbar\r\n"
03:14:13 <lambdabot>   "foo\r\nbar\r\n"
03:14:41 <Gracenotes> it doesn't "see" \r's
03:14:58 <MyCatVerbs> > map (fix (\f l -> case l of { ('\n':[]) -> []; x -> x; })) ["foo\nbar\n","foo\nbar"]
03:14:59 <lambdabot>   ["foo\nbar\n","foo\nbar"]
03:15:08 <ivanm> Gracenotes: it could be OS specific
03:15:12 <MyCatVerbs> Uhhhh...?
03:15:17 <MyCatVerbs> @src lines
03:15:17 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
03:15:20 <Twey> ivanm: Nay
03:15:25 <ivanm> or else when it's read in from file, all \r\n and \r just become \r ...
03:15:29 <ivanm> Twey: hmmm...
03:15:38 * ivanm had issues with Python because of that..
03:15:42 <Twey> ivanm: The file IO functions have OS-specific behaviours
03:15:49 <Gracenotes> ivanm: it isn't
03:15:49 <ivanm> no, wait, it was to try and read in a line at a time
03:15:51 <ivanm> Twey: yeah
03:15:55 <MyCatVerbs> > map (fix (\f l -> case l of { ('\n':[]) -> "underpants"; x -> x; })) ["foo\nbar\n","foo\nbar"]
03:15:56 <lambdabot>   ["foo\nbar\n","foo\nbar"]
03:15:57 <Twey> Such that on Windows, \r\n looks like \n to Haskell
03:15:57 <lilac> yeah, newline conversion usually/traditionally happens at the point of IO
03:16:06 <MyCatVerbs> Oh, oops. Heh.
03:16:12 <Twey> But it doesn't work with sockets
03:16:16 <Peaker> ivanm, Twey: That's what text mode files are about?
03:16:22 <ivanm> so maybe lines ignores \r because it thinks its been read in properly
03:16:27 <Twey> Peaker: Aye
03:16:31 <ivanm> Peaker: "text mode files"?
03:16:35 <Twey> ivanm: *nod*
03:16:41 <Gracenotes> for IO, one should use binary file functions to avoid the OS-specific behavior
03:16:41 <lilac> ivanm: the text 'open mode' for files
03:16:45 <MyCatVerbs> > map (fix (\f l -> case l of { ('\n':[]) -> []; (a:as) -> a : f as; [] -> []; })) ["foo\nbar\n","foo\nbar"]
03:16:46 <lambdabot>   ["foo\nbar","foo\nbar"]
03:16:52 <ivanm> lilac: as opposed to binary?
03:16:52 <Peaker> ivanm: yeah, libc's text mode file open is about adapting retarded old formats kept for compatibility to a simpler format (\n only)
03:16:57 <fasta> Is there some generalized Prelude somewhere? Containing all the list functions, but which then also work for a Data.Sequence.Seq. Doing toList conversions all the time seems like a bad idea.
03:17:19 <fasta> E.g. instead of gen_sum = sum . toList
03:17:26 <ivanm> fasta: what kind of list-specific stuff are you doing on Sequence?
03:17:36 <ivanm> use its Foldable instance?
03:17:46 <lilac> ivanm: yeah, the lack of the 'b' in the open flags given to fopen(3)
03:18:15 <fasta> ivanm: yes, but I was basically asking whether the Prelude had already been ported in this sense.
03:18:27 <ivanm> fasta: I doubt it
03:20:18 <Baughn> Yeah, okay - I've traced it to Debug.Trace statements. Inserting one causes my programs to crash.
03:20:59 <fasta> Baughn: I had that recently too.
03:21:13 <MyCatVerbs> Baughn: interesting. unsafePerformIO bugged? Poke GHC's Trac?
03:21:14 <fasta> Baughn: but it turned out there was another issue also.
03:21:23 <Baughn> MyCatVerbs: Actually. Not quite.
03:21:38 <Baughn> MyCatVerbs: It appears that just touching the definition of this merge function /at all/ causes crashes
03:21:41 <Baughn> It's not just merge
03:21:43 <Baughn> *trace
03:22:25 <Baughn> ..seriously, replacing foo `unamb` bar `unamb` baz with foldr1 unamb [foo,bar,baz] makes it crash
03:22:41 <sm> Peaker: sorry to disappear.. it seems not, but I'll try again later
03:23:19 <Peaker> sm: instance Eq MyType where (==) = implementationIsElsewhere ?
03:23:23 <ivanm> Baughn: :o
03:23:36 <sm> would anyone know what is the second value returned by unit test runners ? eg runVerboseTests :: Test -> IO (Counts, Int)
03:23:48 <Baughn> @tell conal By the way, I'm pretty sure the foldr1 in unambs should be a foldl1
03:23:48 <lambdabot> Consider it noted.
03:24:34 <sm> Peaker: to import implementationIsElsewhere is difficult
03:27:56 <Peaker> sm: oh - how come your modules have such inter-dependencies? can you draw a little text graph of your types in a paste?
03:32:33 <Trollinator> say, i have a tuple that contains only types that are instances of Num, and i have a polymorphic function that works on all num types.
03:32:51 <Trollinator> is it possible to write a function that applies the function to every element of the tuple?
03:33:26 <MyCatVerbs> There's no induction on tuples, unfortunately.
03:33:27 <sm> Peaker: I've lost the one I had.. the types are at http://hledger.org/api-doc/Ledger-Types.html
03:33:29 <fasta> Trollinator: only HLists solve that problem.
03:33:37 <Trollinator> HList?
03:33:45 <fasta> @google HList oleg
03:33:49 <lambdabot> http://homepages.cwi.nl/~ralf/HList/
03:33:49 <lambdabot> Title: Strongly typed heterogeneous collections
03:34:07 <Peaker> Trollinator: you could hold them in a list of existentials, instead?
03:34:23 <Peaker> Trollinator: or apply your function before putting them in the tuple/list?
03:34:45 <sm> I will try again. It seems to preclude complex instance methods
03:35:00 <Trollinator> i'm not trying to solve any problem, i was just wondering whether it's possible in Haskell.
03:35:06 <Trollinator> (it will be in C++1x :p)
03:35:34 <Axman6> so it's moved from being called C++0x?
03:35:43 <fasta> Trollinator: it depends on what you think of as a tuple. If you think about that rather abstractly, the answer is yes, otherwise no.
03:36:12 <fasta> Trollinator: It's certainly not in H98.
03:36:15 <Axman6> , everywhere (+5) (1 :: Int, 2 :: Double)
03:36:17 <Trollinator> Axman6: it won't be done this year, so 0x doesn't really make sense (assuming you want the x to be decimal).
03:36:17 <lunabot>  luna: Could not deduce (GHC.Num.Num a)
03:36:22 <Axman6> :(
03:36:41 <Axman6> bah, it should be C++Ax
03:37:16 <Peaker> Trollinator: its possible in various ways, yeah
03:37:52 <Peaker> Trollinator: List of existentials, HList.  If you want to do something on all elements of a tuple, then you probably want a list instead
03:38:08 <Trollinator> what is an existential?
03:39:37 <fasta> Trollinator: basically a box with a tag on it saying you can only do this, this and that with this box.
03:39:53 <fasta> Trollinator: this and that being methods.
03:40:02 <Peaker> Trollinator: forall tiger. not (tiger is black)   == all tigers are not black.   not (forall tiger. tiger is black)   == not all tigers are black  ==   exists tiger. not (tiger is black)
03:40:07 <fasta> Trollinator: the longer explanation is in the user manual.
03:40:35 <Trollinator> fasta: i'll look it up.
03:40:37 <Peaker> Trollinator: so basically, if you have nested forall's on types, then they are existentials, in the context of the outer statement.  In Haskell types, it is similar.
03:40:43 <Trollinator> Peaker: i've had that in my logic class.
03:41:16 <fasta> Trollinator: it's not really intuitive (the mapping from logic to types as in Haskell).
03:41:29 <Peaker> Trollinator: if you have a function:  forall a. a -> a   then the caller gets to choose any a it wants, and the function has to be polymorphic to all a's.  If you have a function:  exists a. a -> a   then the caller needs to specify some specific a and the function need not be polymorphic to all a's
03:41:37 <Peaker> fasta: I find it intuitive :)
03:41:57 <fasta> Peaker: maybe because I always use forall, instead of exists.
03:42:10 <Peaker> fasta: Haskell doesn't have "exists", you can get its effect via nested forall's
03:42:18 <fasta> Peaker: right.
03:42:35 <Trollinator> ugh
03:42:48 <fasta> Peaker: that's what not intuitive about it.
03:42:51 <Trollinator> it sounds interesting, maybe i'll look it up later.
03:42:58 <fasta> is not*
03:43:52 <l0g0ut> Hiya, how do you pass what would be considered commandline arguments while in ghci?
03:44:33 <Axman6> you can't afaik
03:44:52 <l0g0ut> As in if I run ghci <file.hs>, and then invoke main and wanted it to act as though I compiled it and ran ./program <args...
03:45:01 <doserj> :set args ...
03:45:06 <l0g0ut> ah
03:45:40 <l0g0ut> Thanks, that works.
03:45:43 <Axman6> oh how handeh
03:46:14 <Peaker> Trollinator: anyway, you can have:   data AnyNum = forall a. Num a => AnyNum a --  Now you can put any type in AnyNum as long as its Num, when you take it out of there you get an (exists a.) though
03:49:44 <Baughn> @tell conal Could you try out the http://brage.info/~svein/reactive.patch patch? It causes RTS crashes on my computer, for no apparent reason.
03:49:45 <lambdabot> Consider it noted.
03:49:54 <Peaker> I wish I could define an instance by "redirecting all methods" to some function of the value
03:50:35 <Baughn> @tell conal (In fact, doing just about anything with that function causes crashes, which makes debugging hard)
03:50:36 <lambdabot> Consider it noted.
03:55:20 <ivanm> with kuribas' mode, can it auto-complete a function name like the standard indentation mode does in emacs (after you type in the signature)?
03:56:06 <quicksilver> I was unware of that feature but I wouldnt' ahev thought it was rleated to the indentation mode in use.
03:56:40 <ivanm> there seems to be a lot of keybindings that are related to the indentation mode (unless I'm not setting the haskell-mode-hook properly), like C-c C-= :s
03:56:56 <fasta> ivanm: auto-complete a function name? How?!
03:57:17 <ivanm> fasta: auto-insert, I should say
03:57:24 <opqdonut> fasta: he means, after you type "f :: something" and press return, it autoinserts "f "
03:57:29 <opqdonut> stub for the definition
03:57:36 <ivanm> opqdonut: well, and indent possibly
03:57:40 <opqdonut> that too
03:57:53 <fasta> opqdonut: oh, I wouldn't use that anyway.
04:04:46 * EvilRanter zerg rushes EvilTerran
04:05:05 <quicksilver> ivanm: yeah I'm not sure why C-c C-= got lost.
04:05:12 <quicksilver> ivanm: but I just use align-regexp now anyway
04:05:17 <quicksilver> so I'm glad I learn about it :)
04:05:24 <ivanm> it's in haskell-indent
04:05:51 <ivanm> and I use align-regexp as well, but haskell-indent also has C-c C-., which aligns both the :: and = when selected
04:06:03 <ivanm> so I don't have to think of the regex for it ;-)
04:07:00 <ivanm> I like aspects of kuribas' mode in terms of finding where to indent... but I'm used to the cyclic tab behaviour rather than hitting backspace, and all these code-insertion style behaviours :s
04:09:09 <Bacta> @fag can Haskell score me some Ritalin?
04:09:09 <lambdabot> The answer is: Yes! Haskell can do that.
04:10:40 <ivanm> > reverse "nilatir"
04:10:41 <lambdabot>   "ritalin"
04:10:44 <ivanm> ^^ Bacta
04:10:45 <ivanm> ;-)
04:11:08 <Bacta> ;)
04:12:19 <sioraiocht> @src unfoldr
04:12:19 <lambdabot> unfoldr f b  = case f b of
04:12:19 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
04:12:19 <lambdabot>    Nothing        -> []
04:32:38 <bastl> hi im reinstalling ghc: and get this message when installing network: Could not find module `Data.Generics': it is a member of package base-3.0.3.0, which is hidden. ghc-pkg list shows both 4.0.0 and 3.0.something. What should i do?
04:33:30 <bastl> btw it's about ghc-6.10.1
04:34:07 <ivanm> bastl: which version of network
04:34:07 <quicksilver> sounds like you're installing an old version of network?
04:34:09 <ivanm> ?
04:34:22 <bastl> latest from hackage
04:34:32 <ivanm> quicksilver: that's what I thought
04:34:38 <bastl> 2.2.0.0
04:34:39 <ivanm> bastl: how "latest"?
04:34:54 <ivanm> 2.2.1.2 is the latest
04:34:56 <bastl> oops
04:35:02 <HugoDaniel> hello
04:35:12 <bastl> used the top item from hackages (googles) search field ...
04:35:14 <ivanm> bastl: and no base hackery required
04:35:21 <bastl> not up to date obviously ...
04:37:27 <ivanm> hmmm... is it a bad thing that I've gotten so used to cabal-install's upgrade command not doing anything when I just want to find out which packages I _can_ potentially upgrade?
04:37:41 <ivanm> bastl: make that 2.2.1.3
04:37:51 <ivanm> .3 must have been released in the last day or two
04:46:02 <ivanm> "cond: Illegal token: layout-next" :s
04:46:02 <ivanm> why doesn't kuribas' mode like me? :(
04:46:02 <bastl> thanks, now i have cabal-install running and everything is ok ...
04:46:08 <ziman> i'm having a problem with this program http://codepad.org/U48GfEPK, which is supposed to read a 4G database dump from its input and split it into files, one file per each table. the problem is that it gradually eats all available memory (and does not free it even between files) and I cannot figure out where the leak is; could somebody give me a hint?
04:48:25 <mreh> must focus whilst reading documentation
04:50:35 <mreh> is there a project looking into standardising haskell again?
04:50:53 <mreh> all these different compilers with their own libraries
04:51:24 <EvilTerran> there's the "haskell platform"
04:51:29 <mreh> haskell98 is like the core standard, am I right in saying that?
04:52:32 <EvilTerran> that's a pretty good way of putting it
04:52:51 <ivanm> mreh: there's haskell' which is going to define a new standard
04:52:56 <ivanm> whenever they get around to it, that is :p
04:53:07 <EvilTerran> although the heirarchical module system extension is also considered pretty obligatory in a haskell implementation
04:53:11 <mreh> haskell prime?
04:53:18 <ivanm> mreh: yes
04:53:30 <ivanm> EvilTerran: isn't that an extension to the report?
04:53:36 <ivanm> like FFI is?
04:53:41 <EvilTerran> i don't recall
04:53:55 <EvilTerran> ... i tend to view hs' as more of a list of ideas for people who are designing languages inspired by haskell to take on board
04:54:02 <ivanm> heh
04:54:08 <EvilTerran> rather than something that's going to become a formal successor to h98
04:55:06 <mreh> which is more relevant, hs98 or the heirachical libraries
04:55:28 <ivanm> both
04:55:28 <EvilTerran> mreh, er, the heirarchical library extension is a very minimal addition to h98
04:55:59 <mreh> From the Cabal webpage: We also avoid the haskell98 package, preferring the newer hierarchical modules.
04:56:07 <mreh> now I'm confused
04:56:32 <EvilTerran> mreh, ah, that's referring to the difference between the List, Monad, etc modules defined in the h98 specification
04:56:43 <EvilTerran> and Data.List, Control.Monad, etc, as used under heirarchical modules
04:56:46 <mreh> EvilTerran, oh
04:57:01 <Saizan_> the haskell98 package is one thing, the haskell 98 standard is another
04:57:17 <mreh> so when someone says "haskell", they can mean one of several things
04:57:23 <dcoutts> mreh: where on the cabal website does it say that?
04:57:25 <mreh> just like when someone says java
04:57:26 <EvilTerran> List, Monad, etc will be in the haskell98 package, while Data.List, Control.Monad etc will be in, er, base?
04:57:37 <dcoutts> EvilTerran: right
04:57:38 <Saizan_> they usually mean haskell 98 + non-controversial extensions
04:57:53 <mreh> http://hackage.haskell.org/trac/hackage/wiki/SourceGuide, under "Language Features and packages"
04:57:59 <mreh> dcoutts: there
04:58:56 <mreh> I think it meant to say "certain packages from haskell98"
04:59:10 <dcoutts> mreh: no, it means literally the package called "haskell98"
04:59:43 <EvilTerran> mreh, in this context (and in general in haskell), "package" means "collection of modules we keep together"
04:59:47 <mreh> oh, so haskell98 isn't a language standard also,
05:00:19 <EvilTerran> mreh, the language standard is Haskell 98. the modules defined in it are in the cabal package called haskell98.
05:00:19 <mreh> I used to use java, forgive me for my ignorance
05:00:32 <mreh> EvilTerran: Ohhhhh
05:00:56 <EvilTerran> the upgraded versions of those modules, with heirarchical names (like Data.List instead of just List) are in the cabal package called "base"
05:01:08 <EvilTerran> (along with some other stuff)
05:01:21 <mreh> mmm, unnecessary complexity
05:01:34 * dcoutts clarifies the page mreh was looking at
05:02:01 <mreh> Can I have a note of thanks for pointing out the lack of clarity?
05:02:10 <dcoutts> mreh: thanks :-)
05:02:34 <EvilTerran> mreh++
05:02:43 <mreh> woop
05:02:45 <Saizan_> you should never draw connections to similary named things in CS, unless the connection is explicit :)
05:02:56 <Saizan_> s/to/between/
05:03:22 <mreh> You can't function in a world like that
05:04:52 <dcoutts> The "Haskell 98" language and the "haskell98" package are clearly closely related
05:05:34 <mreh> they are the the same string to most people!
05:05:36 <dcoutts> which is why we have to qualify when we mean the haskell98 package
05:05:43 <mreh> yes,
05:05:49 <mreh> thanks for your help
05:06:58 <mreh> is package hierachy in Haskell 98
05:08:20 <quicksilver> packages aren't really part of the langauge at all
05:08:30 <quicksilver> there are no languages features which interact with them.
05:08:38 <quicksilver> they're a tool issue.
05:08:48 <mreh> is it all done by the preprocessor?
05:09:39 <Saizan_> no
05:09:40 <mreh> that whole business of re-importing packages doesn't sit well with me, it's alright for a computer to keep track of, not a squishy human
05:09:43 <ray> we are not barbarians!
05:10:01 <quicksilver> mreh: you mean modules, I think.
05:10:06 <mreh> yes, modules
05:10:12 <quicksilver> packages are different.
05:10:15 <Saizan_> re-importing?
05:10:17 <quicksilver> modules *are* part of the language.
05:10:22 <mreh> oh :D
05:10:27 <quicksilver> modules are not really in a hierarchy.
05:10:32 <quicksilver> the *names* are hierarchical.
05:10:35 <mreh> java-packages, haskell-modules
05:10:35 <quicksilver> but that's just naming.
05:10:53 <quicksilver> Foo.Bar.Baz is not in any way related to Foo.Bar
05:10:57 <quicksilver> they're just two names
05:11:02 <quicksilver> (As far as the system is concerned)
05:11:08 <mreh> there's no scoping then
05:11:08 <WorkyBob> quicksilver: well, that depends on the compiler
05:11:28 <Saizan_> exactly, there's no import Foo.Bar.*
05:11:28 <quicksilver> mreh: there is plenty of scoping.
05:11:36 <WorkyBob> ghc for example expects to find the file for Foo.Bar.Baz one level deeper in the same heirarchy as Foo.Bar
05:11:37 <quicksilver> mreh: but not for modules.
05:11:43 <quicksilver> WorkyBob: no it doesn't.
05:11:47 <mreh> quicksilver, java packages are scoped, but haskell modules are not, that's what i meant
05:11:50 <quicksilver> WorkyBob: that's just one place it will look.
05:12:03 <WorkyBob> hmm, true that actually
05:12:03 <quicksilver> WorkyBob: if the package database tells it otherwise, it will look elsewhere.
05:12:24 <quicksilver> anyhow, I'm trying to explain language features to mreh ;)
05:12:32 <quicksilver> in *language* terms, the hierarchy is suggestive, that's all.
05:12:35 <quicksilver> really they're just names.
05:12:50 <quicksilver> similar names act as a "hint" to a human being that you might expect the modules to be related.
05:12:53 <mreh> mmhm
05:14:56 <WorkyBob> quicksilver: it's a shame really - would have been nice to somehow have a tag based system
05:15:24 <quicksilver> there is quite a lot about it that's a shame
05:15:29 <WorkyBob> yeh
05:15:30 <quicksilver> but, equally, i don't have a better proposal.
05:15:36 <WorkyBob> true true
05:15:36 <quicksilver> I don't really think re-exporting works very well.
05:15:42 <WorkyBob> no, ditto
05:15:43 <mreh> it's poo
05:15:46 <WorkyBob> especially instances/classes
05:15:48 <mreh> that's my take
05:15:51 <quicksilver> ...and on the other hand I wish you *could* re-export qualified.
05:16:03 <quicksilver> instances are global.
05:16:08 <quicksilver> any other suggestion is heresy.
05:16:10 <quicksilver> You will be burnt.
05:16:19 <WorkyBob> >.>
05:16:30 <quicksilver> mreh: nah, it's not poo.
05:16:31 * WorkyBob - creator of orphan instances everywhere
05:16:33 <WorkyBob> <.<
05:16:36 <quicksilver> mreh: it works. It's just simplistic.
05:16:52 <mreh> I dont appreciate it yet obviously
05:17:07 <quicksilver> it does its job OK
05:17:08 <mreh> I have so much to learn!
05:17:15 <quicksilver> it's just sometimes we wish there was somethign which did more.
05:17:21 <quicksilver> we have other jobs which need doing.
05:17:34 <quicksilver> If only the module system could do plumbing, and make coffee.
05:17:40 <mreh> well i am offering my services, i'm trying to get stuck into cabal
05:17:47 <quicksilver> good.
05:17:54 <quicksilver> although that's the package system not the module system ;)
05:18:15 <mreh> what?
05:18:20 <Absolute0> Is there any specialized version of minumum that will give me (value, _) from [(_,_)] where value is smallest? Or must I use fold?
05:18:25 <mreh> I thought we had slain that beast
05:18:38 <opqdonut> :t minimumBy
05:18:39 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
05:18:48 <Absolute0> spanks
05:18:50 <Absolute0> let me try that
05:18:51 <Absolute0> :)
05:18:55 <mreh> :t (>)
05:18:57 <lambdabot> forall a. (Ord a) => a -> a -> Bool
05:19:02 <mreh> Ord, Ordering?
05:19:03 <opqdonut> > minimumBy (comparing fst) [(1,"hi"),(2,"hello")]
05:19:04 <lambdabot>   (1,"hi")
05:19:15 <opqdonut> :t compare -- mreh
05:19:16 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
05:19:24 <opqdonut> ?src Ordering
05:19:24 <lambdabot> data Ordering = LT | EQ | GT
05:19:37 <otulp> Why does a using a "M.Map I64Coord Thingie" exhaust my RAM, but using "M.Map I64Coord Int and then looking up entries in M.Map Int Thingie" work OK? It seems very strange, having to split up my map into two maps, with the first's values being keys in the second.
05:20:19 <mreh> quicksilver: so there are packages in haskell, packages being groups of modules
05:20:24 <opqdonut> otulp: have you profiled memory usage?
05:20:26 <mreh> but you can only import modules
05:20:30 <opqdonut> might be a laziness issue
05:21:03 <lilac> otulp: at a complete guess, i'd say that in the first case you're either being too strict or too lazy (probably with forcing Thingie or otherwise)
05:21:31 <lilac> either that or, in your split map case, do both maps have the same size, or do you reuse Ints?
05:21:42 <otulp> I'm trying to force Thingie as much as possible.
05:22:11 <otulp> opqdonut: No, not in this case. I'll do that. (takes forever, though)
05:22:56 <otulp> lilac: You mean I'm perhaps adding all Thingies to the same entry in the Int map, by mistake?
05:22:58 <EvilTerran> mreh, yes, you only import modules, and packages are groups of modules intended to be used together
05:23:19 <EvilTerran> mreh, often, one module in a package will import other modules in the same package
05:23:29 <lilac> otulp: well, possibly. are the Ints and Thingies in 1-1 correspondence?
05:23:40 <otulp> lilac: They should be.
05:24:06 <lilac> is it possible that something is holding onto previous values of your map?
05:24:06 <mreh> EvilTerran: Does the hierachy also help to stop name clashes
05:24:15 <otulp> I mean, I'm sure. They are assigned in the same function.
05:24:23 <lilac> ok, fair enough.
05:24:51 <EvilTerran> mreh, yes, i guess that's the point of the heirarchical module system
05:25:21 <otulp> The map contents come from a list that is not used for anything else.
05:26:01 <otulp> But I'll have a look at the heap.
05:26:28 <lilac> otulp: i would guess that you have an unevaluated thunk somewhere (or rather, lots of them), and throwing darts blindly i'd guess it's holding onto partially-built versions of the map
05:26:36 <EvilTerran> mreh, note that modules in the same package needn't have any commonality in their module names
05:26:46 <lilac> otulp: can you paste the code which builds the map?
05:26:53 <quicksilver> mreh: right. but packages aren't part of the language. packages are just a tool to install/remove groups of modules.
05:27:20 <EvilTerran> mreh, for instance, Control.Monad.ST, Data.STRef, and Data.Array.ST are all in the same package
05:27:21 <otulp> lilac: I could do that. What's the paste URL?
05:27:25 <lilac> quicksilver: aren't packages also used to allow multiple modules of the same name to coexist?
05:27:29 <lilac> @where hpaste
05:27:29 <lambdabot> http://hpaste.org/
05:27:30 <quicksilver> yes.
05:27:41 <quicksilver> (does what I said contradict that? ;)
05:27:47 <mreh> so package, like a debian software package
05:27:57 <mreh> I understand
05:27:57 <quicksilver> much like, yes.
05:28:07 <lilac> quicksilver: 'packages are just ...' implies to me, 'packages are ... and nothing else'
05:28:16 <quicksilver> ;)
05:28:20 <otulp> hpaste.org seems to be having trouble.
05:28:55 <lilac> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/
05:29:12 <Absolute0> where is comparing defined?
05:29:19 <lilac> @index comparing
05:29:19 <lambdabot> bzzt
05:29:26 <Absolute0> its not in list or prelude
05:29:33 <lilac> Data.Ord
05:29:33 <doserj> Data.Ord
05:29:42 <EvilTerran> ?hoogle comparing
05:29:42 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
05:29:42 <lambdabot> Distribution.Simple.Utils comparing :: Ord a => (b -> a) -> b -> b -> Ordering
05:29:42 <mreh> quicksilver: but if multiple modules of the same name co-exist, how does the compiler know which modules need to be imported?
05:29:43 <Absolute0> thanks :)
05:30:13 <EvilTerran> Absolute0, why would it be in List? it's got nothing to do with lists :P
05:30:24 <Absolute0> right.
05:30:58 <EvilTerran> hoogle's useful for finding out that sort of thing
05:31:37 <Absolute0> will do for future reference. thanks
05:32:48 <Bacta> "Hi I accidentally my Fleshlight. Is it bad?"
05:33:03 <Peaker> @src Rational
05:33:03 <lambdabot> type Rational = Ratio Integer
05:33:13 <Absolute0> accidentally what?
05:33:14 <Absolute0> :)
05:33:19 <Absolute0> naughty man
05:33:29 <Bacta> I'm talking to their customer service representative as we speak ;)
05:33:34 <Peaker> @hoogle Ratio a -> (a, a)
05:33:35 <lambdabot> System.Random split :: RandomGen g => g -> (g, g)
05:33:35 <lambdabot> Test.QuickCheck two :: Monad m => m a -> m (a, a)
05:33:35 <lambdabot> Prelude divMod :: Integral a => a -> a -> (a, a)
05:33:35 <Bacta> Maybe they'll be able to give me an answer
05:33:44 <Peaker> @src Ratio
05:33:44 <lambdabot> data (Integral a) => Ratio a = !a :% !a
05:37:40 <otulp> lilac: Found the problem while prepraring code for pasting. The code producing the two maps was stricter than the code producing the single map.
05:39:07 <otulp> Thanks.
05:40:09 <lilac> @quote gwern optimize
05:40:09 <lambdabot> gwern says: the best way to optimize a program is to make it lazier or stricter.
05:42:05 <MyCatVerbs> The *real* best way to optimize a program is to tell dons that it's been added to the Shootout.
05:43:18 <guenni> hi, how can I get a a key press in the command line, something like getKey up?
05:44:12 <ivanm> MyCatVerbs: lol
05:44:30 <EvilTerran> guenni, i think that's OS-dependent
05:44:59 <guenni> EvilTerran: thx
05:45:02 <EvilTerran> guenni, System.Posix.Terminal or System.Win32.Console may have what you want
05:45:20 <guenni> EvilTerran: I'll check into that, thx
05:47:48 <Philonous> Given a list of MVars is there a way to wait for any of them to be filled?
05:48:22 <Peaker> :% is not exported -- how do I get the constructor components?
05:48:36 <lilac> @remember MyCatVerbs The *real* best way to optimize a program is to tell dons that it's been added to the Shootout.
05:48:36 <lambdabot> I will never forget.
05:48:54 <doserj> Peaker: denominator and numerator
05:49:12 <Peaker> doserj: no numerator&&&denominator ?
05:49:51 <doserj> Peaker: no
05:50:14 <Peaker> ok, thanks
06:01:16 <EvilTerran> Philonous, not without more concurrency or busy polling, as far as i know
06:01:25 <quicksilver> Philonous: yes.
06:01:29 <quicksilver> using 'more concurrency'
06:01:34 <quicksilver> which doesn't strike me as a bad solution ;)
06:01:56 <quicksilver> put a thread to sleep on all of them, and wait for the first wakeup.
06:09:52 <Berengal> I have a function I don't know what does... :/
06:09:54 <hatds> phooey, I've been hoisted by too much type inference:  I wrote (replicateM 1000) fst <$> action instead of replicateM 1000 $ fst <$> action and it still type checks :)
06:09:57 <Berengal> And I just wrote it
06:11:04 <hatds> hmm, or maybe it is too much overloading on monads
06:11:10 <otulp> Berengal: Try feeding the cat to it. See what happens.
06:11:31 <Berengal> otulp: It works as intended, but I have no idea why
06:12:06 <ivanm> Berengal: excellent!
06:12:23 <ivanm> Haskell: helping you unintentionally write obfuscated code that still works ;-)
06:12:23 <Berengal> http://haskell.pastebin.com/m677db849
06:13:17 <Berengal> I wonder if I've reached the point where I can actually create an ugly hack that works in haskell...
06:13:24 <Berengal> Does this mean I'm starting to become proficient?
06:14:16 <idnar> I think you have to write a compiler or monad transformer library or something for that
06:15:41 <Berengal> The worst thing is, it typechecked on my first try...
06:21:00 <emg-2> Hi. I'm looking for condensed Haskell tutorial. Any links?
06:21:09 <Berengal> @where LYAH
06:21:09 <lambdabot> www.learnyouahaskell.com
06:22:50 <ivanm> Berengal: that's _condensed_?
06:23:01 <Berengal> More so than rwh...
06:23:17 <Berengal> Perhaps there's the wikibooks, but I suspect that's because they're incomplete
06:23:43 <Berengal> (So's LYAH, so the same might apply there)
06:24:51 <Saizan_> Berengal: you tied the recursion in a quite weird way
06:25:21 <hatds> emg-2: "A Taste of Haskell" is good, it's a video on haskell.org
06:26:10 <Berengal> Saizan_: I know... Not sure if that's a good thing :/
06:26:12 <Saizan_> Berengal: more natural: http://haskell.pastebin.com/m279c0a04
06:26:23 <Berengal> For two seconds I almost wanted to do it in python...
06:27:38 <Berengal> Saizan_: Indeed. I blame lack of coffee...
06:27:56 <Saizan_> however i think you can rewrite the whole thing with many?
06:28:39 <Saizan_> many p = ((:) <$> p <*> many p) <|> return [] in parsec, i think
06:30:42 <Saizan_> so like this http://haskell.pastebin.com/m52907485
06:31:17 <Saizan_> and maybe msum [ ... ] instead of .. <|> .. <|> .. but that's debatable
06:31:44 <opqdonut> btw, why are you passing moves instead of (move moves) as an argument?
06:33:46 <Peaker> Data.Map lets you break its invariants with:
06:33:55 <Peaker> @type Data.Map.mapKeysMonotonic
06:33:58 <lambdabot> forall k1 k2 a. (k1 -> k2) -> M.Map k1 a -> M.Map k2 a
06:34:01 <Peaker> ?
06:34:06 <Peaker> No Ord requirement there at all
06:34:08 <quicksilver> yup.
06:34:14 <quicksilver> and with fromAscList, too
06:34:36 <Peaker> does it throw a pure exception or just silently break?
06:34:55 <quicksilver> it doesn't check.
06:34:57 <quicksilver> that's the whole point.
06:35:07 <quicksilver> it's fast because it doesn't check.
06:35:08 <dcoutts_> @seen Cale
06:35:08 <lambdabot> Cale is in #haskell-in-depth, #ghc, #haskell-overflow and #haskell. I last heard Cale speak 5h 12m 6s ago.
06:35:52 <Peaker> silently break it is, thanks :-)
06:36:10 <Peaker> maybe it should be called unsafeFromAscList, or unsafeMapKeysMonotonic ?
06:36:43 <opqdonut> :t fromAscList
06:36:44 <lambdabot> Not in scope: `fromAscList'
06:36:52 <opqdonut> :t Data.Map.fromAscList
06:36:53 <lambdabot> forall k a. (Eq k) => [(k, a)] -> M.Map k a
06:37:07 <opqdonut> ah, only Eq
06:37:11 <EvilTerran> ?type Data.Map.fromDistinctAscList
06:37:12 <lambdabot> forall k a. [(k, a)] -> M.Map k a
06:37:40 <Saizan_> to mark unsafe all functions with a precondition looks a bit extreme
06:37:50 <Peaker> Saizan_: if they don't check the precondition, why so?
06:38:04 <Peaker> Saizan_: I think they should at least be marked *somehow*, if not unsafe
06:38:12 <Saizan_> the point of having a precondition is to not check it, imo
06:43:40 <Peaker> Saizan_: that's ok - but then such a function should be distinguished from one you can trust the type-checker to validate for you
06:44:02 <Peaker> IMO, I should understand what I'm getting from the type-checker when calling a function, and its name is a good place to indicate as such
06:44:25 <Peaker> Maybe "unsafe" is just too broad a term, and various terms should be made up for various kinds of potential breakage, and then the specific potential breakage should be mentioned in the name
06:51:38 <quicksilver> Peaker: the point of the word 'Monotonic' is to indicate the precondition.
06:51:48 <quicksilver> Peaker: you shouldn't be using functions you haven't read the docs for.
06:52:02 <quicksilver> the Monotonic makes it fairly clear to me that the function is reqd to be monotonic.
06:52:11 <maltem> Let's see, what are the various kinds of potential breakage? 1) Lost referential transparency, 2) Segfault, 3) wrong answers?
06:52:41 <Peaker> quicksilver: sure -- but that still doesn't mean it wouldn't fail to *typecheck* if it weren't monotonic.  Stuff that isn't checked by the type-checker should be tagged in name and via pure exceptions, or when performance matters, only the former
06:53:30 <maltem> Peaker, I think the "Asc" or "DistinctAsc" qualifies as "tagged in name"
06:54:20 <Peaker> maltem: but many functions specify in their name preconditions that *are* checked in the type system. Don't you think those should be distinguished from preconditions that aren't?
06:55:06 <quicksilver> (in this particular case the type system did pick it up, as you noticed it from the lack of Ord constraint)
06:55:12 <quicksilver> that's a slightly unusual interaction though.
06:55:39 <maltem> Peaker, hmmm. what would you call it?
06:56:04 <maltem> oh I see, something with unsafe or monotonic
06:57:07 <maltem> I'm not sure, actually saying that it takes an ascending list is as good to me as saying, lo and behold, there's a precondition! It takes an ascending list!
06:57:24 <maltem> Er, sorry for my sarcasm
06:58:19 <BONUS> hmm. is it normal that haskell derived the type GHC.Prim.Any for a piece of code that doesn't even mention the primitives?
06:58:22 <maltem> Of course, there may be functions where it's less obvious
06:58:44 <maltem> BONUS, is that the same as Data.List.Any?
06:58:58 <quicksilver> no.
06:59:03 <quicksilver> It's something like exists a . a
06:59:06 <quicksilver> it's a GHC internal thing.
06:59:20 <quicksilver> there seems to be a bug which exposes it in type inference sometimes.
06:59:20 <maltem> I see
06:59:34 <quicksilver> mabye it's just something like "a" actually
06:59:37 <quicksilver> a free type variable.
06:59:51 <BONUS> yeah it's supposed to be if i infer it by hand
06:59:56 <quicksilver> BONUS: http://hackage.haskell.org/trac/ghc/ticket/2178
06:59:58 <BONUS> yeah, thought it had to be a bug
07:00:22 <Athas> My program appears to crash from stack overflow due to huge thunks somewhere, but I can't figure out how to use GHC's profiling tools to figure out where.  Any advice?
07:01:08 <hatds> could try hpaste'ing the code
07:01:26 <voker57_> @hoogle (a -> b) a
07:01:26 <lambdabot> No results found
07:01:31 <voker57_> @hoogle (a -> b) -> a
07:01:31 <lambdabot> Data.Function fix :: (a -> a) -> a
07:01:31 <lambdabot> Control.Monad.Fix fix :: (a -> a) -> a
07:01:31 <lambdabot> Data.Generics.Schemes everywhere :: (a -> a) -> a -> a
07:01:42 <Saizan> compile with -prof -auto-all -caf-all and run with -hd, you'll see the name of the biggest cost centre
07:02:18 <Saizan> err, closure, not cost centre
07:02:28 <EvilTerran> voker57_, are you looking for something in particular? that type doesn't have any values in it
07:02:50 <voker57_> @hoogle (a -> b) -> a -> b
07:02:50 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
07:02:50 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
07:02:50 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
07:03:04 <Athas> Saizan: thanks, I will do that.
07:03:07 <Athas> Also, hpaste seems to be down.
07:03:09 <voker57_> EvilTerran: forgot the last part
07:03:12 <hatds> needs to be +RTS -hd
07:04:59 <lilac> voker57_: id :: (a -> b) -> (a -> b) ;-)
07:05:17 <voker57_> lilac: no, i wanted $
07:05:34 <voker57_> the 'apply' operator
07:07:55 <hesselink> voker57_: same thing
07:08:02 <hesselink> > (+2) `id` 1
07:08:03 <lambdabot>   3
07:08:24 <hesselink> :)
07:08:53 <voker57_> map (id) [(+1)] 3
07:09:00 <voker57_> > map (id) [(+1)] 3
07:09:01 <lambdabot>   Couldn't match expected type `t1 -> t'
07:09:17 <voker57_> > map (id) [(+1)] $ 3
07:09:19 <lambdabot>   Couldn't match expected type `a -> b'
07:09:31 <voker57_> > map ($) [(+1)] 3
07:09:32 <lambdabot>   Couldn't match expected type `t1 -> t'
07:10:21 <lilac> > zipWith id (map id [(+1)]) [3]
07:10:22 <lambdabot>   [4]
07:10:30 <voker57_> > (map (id) [(+1)]) 3
07:10:32 <lambdabot>   Couldn't match expected type `t1 -> t'
07:10:33 <lilac> > zipWith id [(+1)] [3]
07:10:35 <lambdabot>   [4]
07:10:59 <lilac> voker57_: map id [(+1)] :: Num a => [a -> a]
07:11:07 <lilac> voker57_: that's not a function, so can't be applied to 3
07:11:26 <Athas> Um.
07:11:29 <voker57_> ah yes
07:11:32 <lilac> > map ($3) [(+1)]
07:11:33 <lambdabot>   [4]
07:11:35 <voker57_> > (map (id) [(+1)]) [3]
07:11:37 <lambdabot>   Couldn't match expected type `t1 -> t'
07:11:37 <EvilTerran> f `id` x = id f x = f x -- :)
07:11:49 <lilac> > map (flip id 3) [(+1)]
07:11:50 <lambdabot>   [4]
07:11:55 <voker57_> > (map ($) [(+1)]) [3]
07:11:56 <lambdabot>   Couldn't match expected type `t1 -> t'
07:12:07 <lilac> voker57_: it's still not a function, so it can't be applied to [3] either
07:12:38 <lilac> voker57_: if you want to apply a list of functions to a list of values, you'd need to use something like <*> or >>=
07:12:49 <fasta> What's the best library to use to convert any common image format to a 2d array containing the image data?
07:12:51 <lilac> or zipWith ($)
07:13:40 <byorgey> fasta: you could use the ImageMagick bindings.
07:13:48 <Athas> I can't figure out what http://80.161.87.214/vm.pdf means.  I think the ':' near the start is where I read in a big file as a list (then convert it to an array just after), but what's W32#?
07:14:20 <fasta> byorgey: what's the name on Hackage?
07:15:42 <byorgey> fasta: hsmagick, IIRC
07:15:45 <EvilTerran> ,src ''Word32
07:15:47 <lunabot>  data Word32 = W32# Word#
07:16:02 <quicksilver> Athas: constructor for a Word32
07:16:08 <Athas> Oh, hm.
07:16:10 <Athas> Interesting.
07:16:19 * shapr boings cheerfully
07:16:23 <quicksilver> I note the memory usage is constant ish
07:16:31 <quicksilver> doesn't look like a big problem there
07:16:40 <Athas> It crashes due to a stack overflow.
07:18:59 <fasta> byorgey: cabal: The pkg-config package GraphicsMagick version >=1.3.3 is required but
07:18:59 <fasta> it could not be found.
07:20:27 <dcoutts_> http://hackage.haskell.org/trac/hackage/ticket/331
07:20:36 <dcoutts_>  #331  	pkg-config error messages could be better
07:20:49 <dcoutts_> if anyone feels like improving it ^^^ :-)
07:20:51 <fasta> dcoutts_: yes, that's what I thought.
07:21:13 <Philonous> quicksilver: I thought about forking a thread for each of the MVars and writing in a common MVar. I just wasn't sure this wouldn't be overkill
07:21:55 <fasta> cabal: The pkg-config package GraphicsMagick version >=1.3.3 is required but
07:21:55 <fasta> the version installed on the system is version 1.1.11
07:22:03 <fasta> Does Ubuntu lag this much?
07:22:13 <dcoutts_> fasta: yes, that would be a better message
07:22:34 <fasta> dcoutts_: that is the actual message ;)
07:22:42 <dcoutts_> oh :-)
07:23:05 <Baughn> Philonous: Threads are /really cheap/. I didn't see the original question, but chances are that's the best way.
07:23:13 <Philonous> It seems to be a general idea in haskell: If in doubt, thow more concurrency at it.
07:23:29 <Philonous> throw*
07:24:39 <Baughn> Sure, but threads such as "forkIO $ forever $ readThingy >>= putMVar m . Thingy" are pretty easy to reason about
07:25:46 <quicksilver> Philonous: no, it's the general idea when dealing with MVars ;)
07:25:59 <WorkyBob> Philonous: works well in my experience
07:26:02 <quicksilver> Philonous: MVars are a handy primitive but to compose them well you need to be happy forking more threads.
07:26:03 <WorkyBob> concurrency is cheep in haskell
07:27:55 <Bacta> (*)(*)
07:28:16 <Philonous> quicksilver: I actually like that. It allows me to think in some sort of net, where MVars are the nodes and thrads the vertices
07:28:21 <Bacta> d
07:28:27 <Bacta> ()()
07:28:36 <quicksilver> Bacta: shush.
07:28:36 <Bacta> *|*
07:28:42 --- mode: ChanServ set +o quicksilver
07:28:45 --- mode: quicksilver set +b *!*=Administ@unaffiliated/bacta
07:31:27 --- mode: quicksilver set -b *!*=Administ@unaffiliated/bacta
07:32:12 * Baughn figures out a use for Arrow. Huh.
07:34:48 <J11> If you don't export everything from a class, what happens to the instances that will always be exported? Will this prevent the not exported methods from being imported(or being unusable until some other module exports the class)?
07:35:41 <quicksilver> you can't import functions which have not been exported.
07:35:48 <quicksilver> methods are not excepted from that.
07:36:00 <quicksilver> so, if the methods have not been exported - you can't import them.
07:36:10 <quicksilver> That's a separate issue from the class itself.
07:37:06 <Berengal> I like abstractions...
07:38:11 <J11> but suppose the class isn't exported at all: (H98 rep)For example, import M() does not bring any new names in scope from module M, but does bring in any instances visible in M
07:38:57 <Saizan> yes, it brings in the instances
07:39:05 <quicksilver> J11: I don't understand the question you are asking.
07:39:18 <quicksilver> J11: instances, classes, and methods are all different.
07:39:29 <Berengal> It does bring in the instances, but you can't use them yourself. You can pass them on to something that can though
07:39:29 --- mode: quicksilver set -o quicksilver
07:39:38 <quicksilver> you can use them.
07:39:42 <Saizan> (you might import the class methods from somewhere else, for example, and so make use of the instances defined in M)
07:39:49 <quicksilver> you might nto be able to see the methods.
07:39:59 <quicksilver> but you can easily use a class without using its methods.
07:40:07 <Saizan> that too
07:40:47 <quicksilver> mapM isn't a method.
07:40:53 <quicksilver> but mapM makes a monad (marginally) useful
07:41:00 <quicksilver> even without return and >>= being in scope.
07:41:20 <WorkyBob> you mean an applicative?
07:41:20 <WorkyBob> >.>
07:41:41 * quicksilver counts to 10 softly to avoid booting WorkyBob from the channel. <.<
07:41:44 <Berengal> quicksilver: You can't define mapM without >>= and return though (or sequence, or something else)
07:41:45 <WorkyBob> hehe
07:42:20 <quicksilver> Berengal: that's not the point.
07:42:23 <WorkyBob> Berengal: sure you can -- mapM = fmap fmap fmap sequenceA fmap where sequenceA = foldr (liftA2 (:)) (pure [])
07:42:24 <quicksilver> Berengal: the point is you can USE it.
07:42:36 <quicksilver> which is the question being addressed here.
07:42:45 <J11> so restricting the export from a class will do nothing if you only import the instances?(if you define the class yourself for example)
07:43:11 <quicksilver> J11: I still don't understand what question you're trying to ask.
07:43:21 <Berengal> quicksilver: I define that kind of useage "passing it on to something else"... I think we're in agreement appart from terminology
07:43:34 <quicksilver> If you a class isn't visible, you can't use it in signatures
07:43:45 <quicksilver> if a function isn't visible, you can't use it in expressions.
07:43:51 <quicksilver> methods are just functions, really.
07:43:58 <quicksilver> (in terms of export/import/visibility)
07:44:14 <quicksilver> instances are global and cannot be usefully controlled.
07:45:04 <Berengal> Right
07:46:28 <Philippa> there are only 10 kinds of people: but pick your own base
07:46:37 <EvilTerran> can you instantiate a class if you haven't imported its methods and aren't deriving it?
07:46:51 <Berengal> Philippa: All your base are belong to us
07:46:55 <quicksilver> Berengal: (the only time the difference between a function and a method matters is when writing instances of your own; otherwise both are just functions. Therefore there is no different between 'using it yourself' and 'passing it to something else'. "mapM f xs" and "f >>= \y -> g y" are both equally "using" a Monad instance"
07:47:19 <quicksilver> EvilTerran: you need to have at least enough methods to define an instance visible.
07:47:43 <quicksilver> EvilTerran: I suspect if you're happy to omit some methods (perhaps because of defaults) it doesn't matter if those ones are not visible.
07:47:53 <quicksilver> although I've never tried that. It would be a strange thing to try ;)
07:48:18 <Berengal> quicksilver: Right. When I said "Using it yourself" I mean using the methods directly. From the point of the user though, there really is no difference...
07:48:19 <J11> well if you get the class imported from somewhere else, and the module that has the  instances exports not all declarations of that class, thus the restriction will have no effect and all instances will be imported and methods will its methods will be usable if the other class defines them.
07:48:55 <lilac> Philippa: http://cowbirdsinlove.com/43
07:49:36 <Berengal> J11: Uh... what?
07:49:49 <quicksilver> J11: No.
07:49:58 <quicksilver> J11: having the instance visible does not make the methods visible.
07:50:07 <quicksilver> methods are just functions (as far as visibility is concerned)
07:50:17 <quicksilver> if they're not visible, then you can't use them.
07:50:39 <xdie> hi
07:50:41 <xdie> all
07:51:06 <xdie> any can helpme with join lambdabot in channel #culturalibredigital
07:51:14 <xdie> @join #culturalibredigital
07:51:14 <lambdabot> Not enough privileges
07:51:35 <quicksilver> need a LB admin for that.
07:51:39 <quicksilver> not sure if any are awake.
07:51:46 <J11> module A exports class X entirely, modlu B exports class X partially, method C imports A() and B
07:51:47 <Baughn> Or you could build your own
07:51:48 * NEEDMOAR slaps shapr 
07:51:55 <xdie> XD
07:52:08 <quicksilver> J11: and your point is?
07:52:16 <J11> * B() and A
07:52:33 <quicksilver> well not it has the whole class, from A ?
07:52:36 <quicksilver> now it has.
07:55:50 <J11> yes, but does that means every instance method from B of class x is usable?
07:57:00 <J11> even if that module does't export them?
07:57:21 <dmwit> No, not all instance methods need be exported.
07:57:24 <dmwit> Only instances.
07:57:32 <dmwit> wait
07:57:39 <EvilTerran> instance methods?
07:57:59 <dmwit> You can hide instance methods for a whole class, but not for a single data type.
07:58:02 <Baughn> "<Imp NoBound 3.2,Segmentation fault" <- Bloody nuisance
07:58:04 <lilac> J11: you can only import or export class methods, not methods of a particular instance of that class
07:58:37 <Baughn> Is it possible to make ghc print out which haskell code is executing when it segfaults?
07:59:18 <dmwit> No program may catch segfaults.
07:59:23 <dmwit> It's not allowed.
07:59:47 <p_l> dmwit: what? First time I heard of it :D
07:59:48 <Baughn> But..
08:00:01 <dmwit> err... I thought?
08:00:07 <dmwit> I've been wrong before. =P
08:00:08 * p_l happily used programs catching segfaults for a long time
08:00:26 <MyCatVerbs> > "world " ++ (fix ("atop a turtle "++))
08:00:27 <p_l> dmwit: let's say that catching segfaults is quite common for GC :>
08:00:27 <lambdabot>   "world atop a turtle atop a turtle atop a turtle atop a turtle atop a turtl...
08:01:50 <quicksilver> J11: yes, because A exports them!
08:02:09 <quicksilver> J11: this have nothing to do with classes.
08:02:26 <quicksilver> J11: it's just about functions. They are visible because A exports them it doesn't matter that B doesn't.
08:02:36 <quicksilver> j1what probblem are you trying to solve?
08:02:55 <dino-> Baughn: I don't have much experience with it, but I wonder if the debugging facilities in ghci can help with this.
08:03:19 <Baughn> dino-: no, ghci just crashes
08:03:28 <dino-> ouch
08:03:33 <Baughn> Well, I'm trying to build ghc-6.11, just in case..
08:03:51 <J11> just a theoretically question and I have to translate Haskell to a language that allows specific instance exportion
08:03:52 <p_l> dmwit: you are not allowed to trap SIGKILL
08:03:54 <dmwit> So, segfaulting isn't really that common in Haskell.
08:03:57 <dmwit> What have you done?
08:04:11 <Baughn> dmwit: Debugging Reactive.
08:04:18 <dino-> You may be back down to ugly Debug.Trace logging things to try to get close to the disaster with log messages.
08:04:27 <dmwit> mmm
08:04:37 <Baughn> dmwit: Though I'm pretty sure unsafePerformIO isn't supposed to do that
08:05:02 <quicksilver> J11: instances and methods are entirely separate.
08:05:07 <xdie> @join #culturalibredigital
08:05:07 <lambdabot> Not enough privileges
08:05:11 <xdie> @part #culturalibredigital
08:05:11 <lambdabot> Not enough privileges
08:05:21 <Baughn> dino-: Near as I can tell, by the time disaster strikes the stack is already smashed
08:05:29 <Baughn> It crashes due to trying to return to address 0x0
08:05:41 <dmwit> I wonder why @join requires privileges.
08:05:47 <dmwit> That seems like a freebie.
08:05:49 <J11> thus invoking a method defined by class x in A will use B's implementation?
08:06:05 <Baughn> dmwit: Then @leave would need to be free too
08:06:10 <dmwit> Nonsense.
08:06:13 <Baughn> dmwit: Also, some channels really dislike bots
08:06:37 <dmwit> Those channels also have ops that ban bots.
08:06:38 <quicksilver> J11: methods can only have one implementation (per instance)
08:06:42 <quicksilver> J11: and instances are global.
08:06:46 <p_l> dmwit: btw, from manual: "The signals SIGKILL and SIGSTOP cannot be caught, blocked, or ignored." (that's on Linux, but it refers to standard signals)
08:06:58 <Baughn> p_l: Eh, this is SIGSEGV though
08:07:08 <dmwit> p_l: Nice, thanks for looking that up just for my ignorance! =D
08:07:17 <dmwit> Baughn: Well, you can install signal handlers.
08:07:21 <Lemmih> Baughn: That's his point, I think.
08:07:30 <dmwit> Baughn: Maybe you could install a SIGSEGV handler yourself to... do something?
08:07:33 <J11> ok, thx
08:07:34 <dmwit> not sure what
08:08:50 <p_l> Baughn: install SIGSEGV handler then, probably with pre-allocated buffer of emergency memory so it would run outside GC areas. Not sure how to do that in Haskell (it's just my idea for emergency debugging tool ^_-)
08:09:40 <dmwit> I wonder how ghci's debugging facilities handle signal handlers.
08:10:00 <Saizan> or you could use gdb
08:16:20 <Baughn> Well, this is a ge-nu-ine heisenbug
08:16:28 <Baughn> If I insert debugging prints in race, it goes away.
08:17:09 <p_l> Baughn: Should we look for a heisenwhale?
08:17:35 <Baughn> p_l: COuld be. I expect it to be skeletal and capable of flight.
08:18:27 <p_l> Baughn: last time I met one it was capable of flight but certainly not skeletal...
08:21:17 <quicksilver> Baughn: You should definitely file a trac.
08:21:31 <quicksilver> Baughn: I'm pretty sure JaffaCake would be interested in any code which jumps to 0
08:21:38 <Baughn> quicksilver: I can't. I can't seem to narrow it down to below "half of reactive".
08:21:41 <quicksilver> unsafePerformIO along should emphaticaly not do that.
08:21:44 <quicksilver> alone.
08:21:56 <quicksilver> calling an FFI lib which stomps on the stack, sure.
08:22:03 <Baughn> Nope, no FFI here
08:22:16 <quicksilver> I assume you're not using anything which can stomp straight on memory, like pokePtr and friends?
08:22:27 <Baughn> Not to my knowledge
08:22:28 <quicksilver> any use on unsafeCoerce# ?
08:22:35 <Baughn> Nope
08:22:50 <quicksilver> I would file the trac even though you can't provide a minimal counterexample.
08:23:08 <quicksilver> for example, they may ask you for a gdb trace or something.
08:23:29 <Baughn> Unfortunately, there is none
08:23:39 <Baughn> ..well, that's not quite true
08:23:42 <Philonous> Is there a fundamental difference between using let a=b and a <- return b in a do block?
08:24:07 <Philonous> monad laws ensure they are equivalent, don't say?
08:24:07 <Baughn> Philonous: Yes
08:24:12 <Baughn> Oh. Wait, return
08:24:15 <Philonous> they*
08:24:25 <quicksilver> Philonous: if "a" is a non-trivial pattern, there is a difference.
08:24:34 <Baughn> Philonous: They are supposed to have the same semantics. There may be differences in performance
08:24:38 <Baughn> #0  0x00000000008612ab in stg_sel_ret_0_upd_info ()
08:24:38 <JaffaCake> Baughn: turn on -debug?
08:24:40 <Baughn> #1  0x0000000000000000 in ?? ()
08:24:47 <Baughn> JaffaCake: Working on it
08:24:50 <quicksilver> Philonous: if the expression "b" mentions the name "a", there may be a difference
08:24:55 <fasta> I installed GraphicsMagick 1.35, but I still get: cabal: The pkg-config package GraphicsMagick version >=1.3.3 is required but
08:24:55 <fasta> the version installed on the system is version 1.1.11
08:25:04 <quicksilver> Philonous: those things aside, they should be the same.
08:25:14 <fasta> How does cabal decide that I have 1.1.11?
08:25:26 <JaffaCake> Baughn:  http://hackage.haskell.org/trac/ghc/wiki/DebuggingGhcCrashes
08:25:55 <Baughn> Crashes just the same with 6.11
08:26:09 <Baughn> Okay. SHould I run the debug with 6.10.3 or 6.11?
08:26:27 <JaffaCake> 6.11
08:26:42 <JaffaCake> this is non-threaded, right?
08:26:45 <Philonous> Thanks
08:27:11 <quicksilver> fasta: by calling pkg-config I suspect
08:27:11 <Baughn> JaffaCake: Crashes just the same either way
08:28:34 <fasta> quicksilver: yes, pkg-config GraphicsMagick --modversion
08:28:58 <fasta> Now, I only need to figure out why pkg-config is returning the wrong value.
08:29:30 <int-e> fasta: check your PKG_CONFIG_PATH, maybe.
08:29:30 <Philonous> quicksilver: In the let a=b case a is in scope in b, wheres in a <- return b it is not? desugaring to return b >>= \a ... would at least sugest that
08:29:46 <fasta> int-e: it should be a distro installed package.
08:30:37 <fasta> Or maybe there is some cache for pkg-config.
08:31:29 <quicksilver> Philonous: right.
08:31:42 <quicksilver> Philonous: in the let case, occurrence of an a would indicate a recursive binding.
08:32:02 <quicksilver> Philonous: in the <-, occurrence of an 'a' would just be shadowing (i.e. it would be referring to som e'a' from an enclosing scope)
08:32:25 <Philonous> Makes sense. Thanks.
08:32:35 <Baughn> JaffaCake: For what it's worth, a debugging build triggers no assertions
08:32:36 <lilac> Philonous: if a is a nontrivial pattern, they're not the same
08:32:37 <quicksilver> Philonous: and if "a" is  a non-trival pattern
08:32:49 <lilac> Philonous: since the <- case uses fail but the let case will bottom out
08:32:50 <quicksilver> Philonous: then the let case will throw a pure exception on pattern match failure
08:32:59 <quicksilver> Philonous: while <- will use the monad's fail.
08:33:13 <JaffaCake> Baughn: and it's repeatable, every time?
08:33:14 <quicksilver> all these things being considered, I find a <- return b to be ugly and I avoid it ;)
08:34:19 <Baughn> JaffaCake: Yes
08:34:37 <Baughn> JaffaCake: Hm. The output is different every time, though, even with -C0
08:34:40 <JaffaCake> shouldn't be too hard to pin down then
08:34:53 <JaffaCake> hmm
08:35:00 <JaffaCake> -V0?
08:35:28 <Philonous> Why do monads even have fail? It has nothing to do with monads, does it? Isn't that what monadPlus is made for?
08:35:35 <Baughn> JaffaCake: Makes no difference. Still different every time.
08:35:45 <Peaker> Philonous: because of "do" notation potentially introducing pattern-match failures
08:36:16 <Philonous> And why can't we use exceptions in that case?
08:36:23 <ray> fail is widely reviled
08:36:33 <quicksilver> Philonous: well, the default definition of 'fail' *is* an exception.
08:36:39 <quicksilver> so arguably that is what it is.
08:36:45 <JaffaCake> Baughn: ok, could you follow through the steps on the DebuggingGhcCrashes page, and see if you can find out any more?
08:36:48 <ray> i think do blocks should only be allowed to have irrefutable patterns unless the monad in question is also a MonadZero
08:37:20 <ray> i am not sure if this introduces any problems
08:37:40 <Philonous> Well, if fail defaults to an exception, why introduce it in the first place?
08:38:06 <dmwit> ray: Most of us totally agree.
08:38:50 <dmwit> Philonous: Most of us totally agree with that, too.
08:38:52 <Baughn> JaffaCake: Working on it.
08:40:24 <lilac> quicksilver: it depends what you think Monad means. if you think it means, "customizable domain-specific sublanguages ahoy!" then fail makes sense
08:40:33 <lilac> s/quicksilver/Philonous/
08:40:43 <dino-> This reminds me of: http://www.haskell.org/haskellwiki/MonadPlus_reform_proposal
08:41:02 <lilac> if you think it means, "here's a neat thing from category theory, maybe it'll be handy" then fail makes no sense
08:41:11 <dino-> Speaking of who is this fail person anyway?
08:41:13 <quicksilver> lilac: well, moving it slightly into a better named class would not be a bad thing.
08:41:28 <quicksilver> call it MonadZero, call it MonadPlus, call it Love, call it Fate.
08:41:29 <lilac> the good news is that people who think both things can use the current design
08:41:41 <lilac> since the default for fail is exactly as if it weren't there
08:41:56 <lilac> the bad news is that Either is royally messed up by it ;-(
08:42:32 <lilac> quicksilver: yes, i'm all in favour of putting fail in a different typeclass, and requiring that for refutable patterns
08:43:01 <lilac> quicksilver: i'm also in favour of a nice syntactic sugaring for a <- return b, since in practice i do that quite often (in the Maybe monad mostly)
08:43:22 <Philippa> let a = b;
08:43:58 <Philippa> (it works differently, but the monad laws guarantee it's the same)
08:44:00 <quicksilver> lilac: I've thought I need it a couple of times, and always managed to twiddle the code around until I didn't
08:44:02 <dino-> I was thinking that too, isn't that just putting b into the monad to take it right back out? Or am I missing something from the above discussion (that I haven't read)
08:44:03 <quicksilver> not sure why.
08:44:09 <lilac> Philippa: that's not the same
08:44:14 <Botje> it's mostly handy for stuff like Just x <- ...
08:44:23 <Botje> where you don't want your program to abort :)
08:44:28 <Philonous> Well, fail is not a show stopper, so I don't really mind. It just looks like an overgeneralised special case that's dangling around for no real reason.
08:44:43 <quicksilver> > (do (x:xs) <- []; return x) :: Maybe Int
08:44:44 <lambdabot>   Couldn't match expected type `[a]'
08:44:52 * quicksilver sighs
08:44:57 <quicksilver> > (do (x:xs) <- return []; return x) :: Maybe Int
08:44:58 <lambdabot>   Nothing
08:45:11 <lilac> Philippa: and changing it so it is makes let-in-do different from normal let-in, which can only be confusing :-)
08:45:20 <quicksilver> > (do let (x:xs) = []; return x) :: Maybe Int
08:45:21 <lambdabot>   <no location info>: parse error on input `)'
08:45:28 <quicksilver> oh ffs. I'm bad at this.
08:45:36 <quicksilver> I'm sure you understand what that was supposed to do.
08:45:38 <Philippa> lilac: it's the same /given the monad laws/. You don't need return
08:45:39 * quicksilver crawls back into his cave.
08:46:15 <EvilRanter> you can actually separate out fail and >>=/return with recent ghc and -XNoImplicitPrelude
08:46:44 <ray> you can do many wonderful things with no implicit prelude
08:46:47 <lilac> Philippa: a <- return b calls fail if pattern a doesn't match b. let a = b does not.
08:47:26 <Philippa> lilac: ah, your metalanguage was unclear. I was assuming a is a variable pattern
08:47:41 <quicksilver> Philippa: something you could have avoided by reading back a few lines.
08:47:49 <ray> "in the Maybe monad mostly"
08:47:56 <Philonous> Philippa: and as I pointed out earlier with let a=b a is in scope in the expression b, whereas it is not in a <-b, so you can have recursive binds in the let case, but not in the other.
08:48:05 <dino-> lilac, quicksilver: Me too, not reading the scrollback. Apologies.
08:48:14 <ray> reading is hard
08:48:14 * EvilRanter tried it recently and managed to have (do return ()) :: Pointed f => f (); (do return (); return ()) :: Applicative f => f (); (do x <- return (); return x) :: Monad f => f (); (do Just x <- return Nothing; return ()) :: MonadFail f => f ()"
08:48:20 <Philippa> quicksilver: I had done, it still wasn't clear
08:50:30 <lilac> EvilRanter: yes, that's a nice feature. just a pity that GHC's standard prelude doesn't work that way
08:53:51 * maltem thinks of starting a Let's overwhelm Hackage with alternative packages based on that alternative typing of do-notation, Category, and something akin to NumericPrelude Movement
08:54:29 * fasta thinks the numeric-prelude stuff is pointless with a GPL license. 
08:54:36 <EvilTerran> maltem, start a hackage category called NoImplicitPrelude?
08:55:38 <maltem> EvilTerran, sounds a bit negative ;), but good otherwise, actually
08:55:57 <EvilTerran> maltem, the problem would be that everyone has their own ideas about how the monad heirarchy should be laid out, and likewise for the numeric heirarchy
08:56:08 <maltem> point
08:56:40 <maltem> So we'd need n new hackage categories.
08:57:00 <EvilTerran> we'd need typeclass heirarchy combinators, like Data.List.Split for string splitting, so people could roll their own :P
09:04:38 * dcoutts_ invites people to try the current darcs cabal-install-0.6.x branch
09:04:58 <dcoutts_> lemme know if you find wierdities or regressions
09:05:17 <dons> url?
09:05:20 <dcoutts_> http://darcs.haskell.org/cabal-branches/cabal-install-0.6/
09:06:00 <dcoutts_> main thing is that for packages that say: build-depends: >= 3 && < 5, it now picks base 4 rather than 3
09:06:14 <dcoutts_> for packages that say: build-depends: >= 3, it still picks base 3
09:06:32 <dcoutts_> at least, that's the intention :-)
09:06:33 <dons> k.
09:06:43 <fasta> dcoutts_: you can also pick a random version in that case for extra fun.
09:06:55 <dcoutts_> fasta: that would be fun :-)
09:07:09 <dcoutts_> keep people on their toes :-)
09:07:18 * fasta nods
09:07:29 <bastl> can someone have a look at http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2555 ? I try to let ghc derive (Data, Typeable) for types with 8 parameters. But it doesnt work. Im stuck ... :-(
09:07:37 <fasta> Add a few terrible error messages and you will have a party!
09:07:44 <dcoutts_> @arr!
09:07:44 <lambdabot> Drink up, me 'earties
09:07:54 <dcoutts_> lambdabot knows how to party
09:08:00 <roconnor> "for packages that say: build-depends: >= 3, it still picks base 3"  Is this specific for base?
09:08:01 <doserj> bastl: deriving Typeable is restricted to 7 paramaters, I think.
09:08:37 <Igloo> Data.Typeable only has classes up to Typeable7
09:08:48 <bastl> the report says its straighfoward to write the required stuff yourself.
09:09:34 <fasta> Loading package hsmagick-0.3 ... can't load .so/.DLL for: pthread (/usr/lib/libpthread.so: invalid ELF header) <- Is there a solution for this?
09:09:35 <bastl> ah, i wrote it myself so i dont need the deriving, right?
09:09:35 <Baughn> JaffaCake: http://hackage.haskell.org/trac/ghc/ticket/3279 <-- Well, I've submitted a bug report.
09:09:51 <doserj> bastl: yes. but you have to use instance Typeable MyType
09:10:49 <bastl> doserj: i dont think so ...
09:11:05 <fasta> It seems it is this one: http://hackage.haskell.org/trac/ghc/ticket/2615
09:11:07 <sm> dcoutts_: ah, I've just been poking around there
09:11:14 * sm will switch
09:11:29 <xdie> @join #culturalibredigital
09:11:29 <lambdabot> Not enough privileges
09:11:47 <xdie> some lambdabot admin?
09:11:52 <sm> actually, http://darcs.haskell.org/cabal-install .. is it different ?
09:12:39 <sm> this one has New development branch, version 0.7, which sounded biggest
09:12:40 <dcoutts_> sm: thanks, it should be totally reliable as your standard cabal, but lemme know if you hit quirks
09:12:57 <dcoutts_> sm: right, stick to the 0.6.x branch, that's the one that I'm about to release
09:12:58 <Baughn> conal: http://hackage.haskell.org/trac/ghc/ticket/3279 <-- And report submitted. Having fun, I guess..
09:13:11 <sm> oh, right
09:13:13 <bastl> @h listify
09:13:13 <lambdabot> Maybe you meant: hackage help hitchcock hoogle hoogle+ . ? @ v
09:13:24 <bastl> @hoogle listify
09:13:24 <lambdabot> Data.Generics.Schemes listify :: Typeable r => (r -> Bool) -> GenericQ [r]
09:13:28 <dcoutts_> sm: and so that's the one I want testing and feedback on
09:14:14 <dcoutts_> roconnor: more specifically it applies any preferences given by the user on from hackage
09:14:30 <dcoutts_> roconnor: and hackage's "preferred-versions" file says to prefer base 3
09:14:57 <dcoutts_> roconnor: see http://hackage.haskell.org/packages/archive/preferred-versions
09:15:41 <doserj> bastl, ah right, there is a generic TypeableN -> Typeable instance mechanism
09:15:50 <thomastc> hi... I'm trying to generate a list of integers, together with their prime factorizations
09:15:53 <thomastc> something like
09:16:15 <thomastc> [(1,[]), (2,[2]), (3,[3]), (4,[2,2]), ...
09:16:40 <thomastc> I have a feeling that it can be done lazily with a fold, but I don't yet see how
09:17:40 <thomastc> it needs to work in reasonable time for numbers up to 500000
09:18:01 <BONUS> well if you have a function Int -> [Int] that gives the prime factors for a certain numbers
09:18:04 <BONUS> you just do
09:18:08 <BONUS> map primeFactors [1..]
09:18:13 <thomastc> jah, of course
09:18:21 <thomastc> I have that now, but it's too slow
09:18:39 <BONUS> or rather map (\x - (x, primeFactors x)) [1..]
09:18:48 <thomastc> so I thought I could do a sieve-like thing, where instead of throwing out multiples, I add the factor to the list
09:18:51 <BONUS> then your prime factors function might be slow
09:18:54 <BONUS> ah like that
09:19:07 <thomastc> because I need it for all the numbers in that range
09:19:09 <sm> hm I've been using some version of cabal-install 0.6.0 for quite a while
09:19:24 <thomastc> yeah, my prime factors function is also slow :)
09:19:30 <sm> but getting the latest. It has been great
09:20:06 <bastl> doserj: took me hours to see that ...
09:21:41 <sm> ah, 0.6.2. All is clear
09:22:07 <conal> Baughn: unamb sure does sniff out GHC RTS bugs!
09:22:07 <lambdabot> conal: You have 3 new messages. '/msg lambdabot @messages' to read them.
09:23:48 <conal> Baughn: please say more about foldr1 vs foldl1 in unambs.  i don't know how to choose one over the other.
09:25:05 <Baughn> conal: It just occured to me, I'm not sure either
09:25:27 <conal> i forget: what's the default fixity (when no fixity is specified)?
09:25:39 <doserj> left
09:25:45 <Baughn> conal: I know why strict foldl would be the right then when producing a simple value, but a strict foldl would also not work due to the undefineds
09:25:48 <conal> and what precedence?
09:26:13 <doserj> infixl 9
09:26:24 <conal> doserj: thx.  how do you know?
09:26:51 <Baughn> conal: Also, it occurs to me that with my version of unamb, "foo `unamb` bar `unamb` baz" could throw BothBottom if both foo and bar are bottom, even if baz is not
09:26:51 <conal> Baughn: why & why?
09:27:03 <doserj> conal: http://haskell.org/onlinereport/decls.html#sect4.4.2
09:27:04 <Baughn> ..oh dear
09:27:07 <conal> Baughn: really?!
09:27:19 <Baughn> conal: No, not really. Hm.
09:27:20 <conal> doserj: thx again
09:27:54 <Baughn> conal: But the laziness is /very important/ for that "not really" to work
09:28:30 <Baughn> conal: If the (unamb foo bar) bit gets evaluated before (unamb baz) is called (eg. strictly), then exactly that could happen
09:28:46 <conal> Baughn: wow.  brittle!
09:29:04 <Baughn> conal: Not really. I'm pretty sure the semantics of haskell disallow that from actually happening
09:29:07 <conal> Baughn: haskell does not guarantee laziness.
09:29:36 <conal> Baughn: and i expect that speculative will become more & more important in the next few years.
09:29:39 <Baughn> conal: Haskell does not guarantee lazy evaluation, you mean. It does guarantee non-strict, right?
09:29:44 <conal> Baughn: speculative *evaluation*
09:29:50 <conal> Baughn: right.
09:30:03 <Baughn> conal: And this'd work fine with non-strict
09:30:13 <Baughn> But wow, the strictness analyzer has quite a job to do
09:30:20 <quicksilver> if speculative evaluation finds a bottom
09:30:27 <quicksilver> that doesn't make the program crash.
09:30:35 <quicksilver> (or make the whole expression go to _|_)
09:30:40 <quicksilver> it just puts the _|_ there.
09:30:47 <Baughn> In any case, I don't think that's the cause of my sigsegv problem. :)
09:30:51 <quicksilver> speculative / full laziness don't change the actual semantics
09:30:54 <quicksilver> just the evaluation order.
09:31:09 <Baughn> Right, but a strict foldl (using seq) would
09:31:13 <Baughn> So we can't use that..
09:31:18 <quicksilver> (BothBottom) `unamb` baz
09:31:23 <quicksilver> is not necessarily _|_
09:31:37 <quicksilver> in fact, the rules of unamb say that _|_ `unamb` baz is baz
09:31:41 <quicksilver> does it not?
09:31:48 <Baughn> If there are no bugs. :)
09:31:50 <conal> quicksilver: yes
09:32:09 <quicksilver> GHC has speculative evluation, by the way
09:32:10 <Baughn> quicksilver: What I was trying to figure out is unambs, eg. foldr1 unamb
09:32:15 <quicksilver> that's what `par` is.
09:32:17 <conal> quicksilver: it does??
09:32:26 <conal> oh -- *explicit* speculation
09:32:28 <quicksilver> if `par` discovers a bottom, it doesn't bottom out the whole expression.
09:32:41 <EvilTerran> (compare pseq)
09:32:48 <quicksilver> conal: sure, but the semantic questions are equally raised with explicit as opposed to implicit.
09:32:50 <Baughn> quicksilver: It ought to be tail-recursive for all the usual reasons, but I can't actually /make/ it tail-recursive without using seq, which would make it not work
09:33:02 <quicksilver> of `par` discovers a bottom, it just marks it and kills that spark.
09:33:11 <quicksilver> whether the actual expression depends on that bottom will be discovered later.
09:33:37 <quicksilver> there are some details do with GC'ing sparks, I recall, which make this fiddly to get right.
09:36:43 <conal> Baughn: i'm reluctant to apply that crashing reactive patch (http://brage.info/~svein/reactive.patch).  could you make a self-contained test module instead?  i'd be happy to try it on my machine.
09:37:44 <Baughn> conal: Basically, no; I have no idea how that code triggers the bug yet.
09:37:55 <Baughn> conal: I'd suggest a darcs get to spare directory.
09:38:32 <conal> Baughn: oh yeah.
09:38:51 <Baughn> conal: And this is why I prefer git. Speed. :P
09:39:10 <conal> Baughn: darcs is particularly painful over satellite
09:39:23 <Baughn> Yet you use it
09:39:39 <conal> yeah
09:40:34 <Baughn> conal: You'll want the crash.hs attached to the bug report, too
09:40:55 <conal> Baughn: oh, thx.
09:43:16 <sm> is this correct .cabal syntax ? tested-with:    GHC==6.8, GHC==6.10
09:43:28 <dcoutts_> sm: yep
09:43:50 <sm> thx
09:46:44 <Igloo> dcoutts_, sm: Aren't they supposed to be actual version numbers? e.g. 6.10.3 rather than 6.10
09:47:00 <sm> I couldn't find an example
09:47:16 <sm> but cabal configure is happy
09:47:20 <dcoutts_> Igloo: there's no semantics to the thing anyway, but yes version equality is exact
09:47:39 <sm> basically I want it showing both versions on the hackage page
09:47:44 <dcoutts_> sm: cabal doesn't care except that it's syntactically correct
09:47:54 <sm> great
09:48:15 <lilac> thomastc: you want to say something like, for each integer n, find the least factor of n, say k, then add to your list (n, k:factors of k)
09:51:49 <sm> dcoutts_: did you get patches from me earlier ?
09:57:32 <ksf> maybe unamb should be a primitive?
09:58:16 <ksf> ...all that talk about clever hacks and brittle operational semantics seem to imply it.
10:02:24 <mreh> Funny, http is not working
10:02:28 <mreh> are you reading this?
10:03:20 <mauke> mreh: no
10:03:27 <mreh> damn
10:03:51 <mreh> who maketh the patches for cabal then?
10:11:35 <mreh> David Roundy prototyped darcs in C++ and then wrote the whole thing in Haskell, that's the wrong way round.
10:11:39 <Jedai> ksf: Conal and some others would like to see unamb as a primitive in some future version of GHC which is why they're trying to make a proof of concept and see if people like it and use it
10:14:06 <sshc> how do I convert a float to an int?
10:14:16 <hatds> watching how much hackery is involved with unamb every day is making me not so inclined to use it :)
10:14:23 <sshc> is there a function similar to the floor() in C?
10:14:30 <mauke> :t floor
10:14:31 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
10:14:31 <mm_freak_> sshc: yes
10:14:33 <mm_freak_> floor =)
10:14:36 <mauke> :t round
10:14:37 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
10:28:41 <lilac> would it be better to make amb primitive and force user code to insert the unsafePerformIO if they're convinced it's safe?
10:29:13 <lilac> unless there's something wrong with unamb a b = unsafePerformIO $ amb a b
10:36:42 <hatds> let x = unamb x y, y = uamb x y
10:37:10 <Cale> conal and Baughn: did you see my comment about unamb?
10:37:17 <conal> Cale: no.
10:37:45 <Cale> Consider if we have two values x = unamb i y and y = unamb j k
10:38:22 <Cale> Due to the precondition on unamb, if we evaluate x, even if it chooses i, we should know the value of y as well.
10:39:06 <Cale> It would be interesting to find a way to somehow convey the result of the winning evaluation to all of the losers.
10:39:46 <dcoutts_> sm: did you send patches to me personally or to the cabal-devel list?
10:40:13 <sm> I did darcs send in the hackage-server repo, and they seemed to be sent to duncan@haskell.org
10:40:15 <conal> Cale: yeah -- iswym.
10:40:17 <Cale> Since the threads already are being thrown exceptions which wake them up to get them into a reset state, perhaps there.
10:40:28 <dcoutts_> sm: oh, right, great
10:40:37 <sm> good good
10:40:49 <dcoutts_> sm: I avoid email when I'm in my office (trying to be more productive) so I'll check when I get home
10:40:54 <Baughn> Cale: Hm. Yes, that's an interesting optimization.
10:40:55 <dcoutts_> sm: what are the patches for?
10:40:57 <sm> aha, smart
10:41:01 <Baughn> Cale: I'll keep it in mind for once all the bugs are out. :)
10:41:16 <dcoutts_> sm: well, if I was really smart I'd not be in #haskell ;-)
10:41:21 <sm> updating it to happstack 0.2, fixing warnings, making it base 3/4 friendly
10:41:28 <dcoutts_> sm: ok, great
10:41:29 <sm> yeah, that's what I'm thinking
10:42:00 <conal> Cale: oh, wait.  couldn't y be be _|_ /= i ?
10:42:16 <dcoutts_> sm: btw, I think TomMD said there's a problem with the state in the hackage-server, since we switched from happs to happstack, something that goes wrong during/after importing all the data.
10:42:27 <sm> ah, I would not be surprised
10:42:30 <dcoutts_> sm: have you tried importing all the old data?
10:42:32 <Baughn> conal: It could. The question is, do you ever use it when that might be the case?
10:42:41 <sm> I got a hackage server running and tried to talk to it with cabal 0.6.2.. no I didn't import
10:42:56 <Cale> conal: Technically it could, but we know that it has a value which if it was defined, ought to be the same as the value of i
10:43:00 <conal> Baughn: are you asking whether we ever use unamb when one branch is bottom ?
10:43:23 <Cale> conal: Consider the case where we unamb together a list of things
10:43:29 <dcoutts_> sm: ok, it's not too hard to try, just need the archive.tar, the 00-index.tar.gz and the upload log from the current hackage. They're all linked from the intro page.
10:43:37 <conal> Cale: yeah.  we know more than we used to: y == bottom or i .
10:43:40 <sm> good to know
10:43:52 <Baughn> conal: No, if we're ever using it when the branches have semantically different values but it's okay because one is bottom
10:44:10 <Baughn> conal: Eg. when this sort of result distribution would /hurt/
10:44:22 <dcoutts_> sm: btw, if you're thinking of working on this regularly I'll add you to the project commit group on code.h.o
10:44:50 <conal> Baughn: yes, the branches could be bottom and non-bottom, and yes that case is useful.
10:45:00 <mm_freak_> pointOfDiscussion :: a
10:45:13 <conal> Baughn: am i getting your question?
10:45:13 <Baughn> conal: That's not what I was asking
10:45:22 <conal> okay.  confused here.
10:45:24 <roconnor> Cale: I think \x y -> expr and \x -> \y -> expr are indistinguishable when there are no patterns.
10:45:33 <Baughn> conal: I mean.. the precondition for unamb is that either the two branches are equal, or one is bottom
10:45:44 <sm> thanks, right now it's a burst here and there
10:45:53 <Cale> roconnor: hmm
10:46:05 <sm> it's looking exciting though
10:46:09 <Baughn> conal: Cale suggests we could propagate the value from the one that /isn't/ bottom to the others, such that if that unamb is restarted (it'd only be useful for recursive ones) the result would be available instantly
10:46:26 <Baughn> conal: I'm not sure that would be aperformance win. But more problematically, would it cause bugs?
10:46:41 <Baughn> Eg. in that it could be the wrong result
10:47:19 <Cale> Baughn: Not if the precondition was stringently followed.
10:47:25 <Cale> At least, I don't think so.
10:47:25 <conal> Baughn: yeah.   unless i'm still confused.  take i == 1, j == _|_, k == _|_ in Cale's example
10:47:45 <Cale> Well...
10:47:58 <Cale> Okay, yeah, it does change the meaning of the thing somewhat.
10:48:19 <Baughn> The performance win would probably be minimal to negative.. probably
10:48:27 <conal> Cale:  in that 1 `somewhatNotEqual` _|_ ?
10:48:43 <corcoran> hello
10:48:55 <Cale> If we assume that you're not constructing unambs of multiple things which are always undefined, and then unambing those with semantically different values.
10:49:28 <corcoran> Haskell newbie here with question about possible GHC bug.  Anybody wanna help?
10:49:36 <Cale> corcoran: sure
10:49:39 <conal> Cale: what does "always undefined" mean?
10:49:55 <Cale> conal: I mean that it will never have a value other than _|_
10:50:16 <conal> Cale: i'm confused about "always" and "never" here.  isn't something _|_ or not?
10:50:37 <conal> can a value "sometimes" be bottom?
10:50:39 <Cale> conal: Well, these are variables and they might be instantiated differently
10:50:55 <Cale> (assuming that you call some function with different parameters)
10:51:09 <conal> Cale: oh -- you're talking about expressions, not values.
10:51:14 <Cale> yes
10:51:21 <corcoran> starting a comment with "--|" gives a parse error:       ' parse error on input `--|' '     so if you comment out something like | case = result you get a parse error if you do not leave a space between -- and |.  Is this a bug?
10:51:48 <Cale> corcoran: No, that's intentional
10:51:49 <SamB> corcoran: sorta!
10:51:54 <SamB> it's actually for haddock
10:51:59 <corcoran> ...in ghci 6.10.3 on windows.  Oh, why indentional?
10:51:59 <Cale> nope!
10:52:05 <corcoran> ah ok, thank you!
10:52:14 <Cale> It's because --| is a valid infix operator symbol
10:52:21 <SamB> oh?
10:52:23 * SamB confused
10:52:28 <Cale> > let x --| y = x^2 - y^2 in 4 --| 5
10:52:29 <lambdabot>   -9
10:52:34 <SamB> sorry, wrong info
10:52:43 <SamB> I guess -- | is for haddock ...
10:52:44 <conal> Cale: i have to reset my whole interpretation.  you're talking about *compile-time* optimization of *expressions*?  run-time is restricted to accessing *values*
10:53:00 <SamB> so how do you comment out a guard without getting haddock errors ?
10:53:30 <SamB> conal: wait, there's a difference between an expression and a value now ?
10:53:46 <Cale> conal: Well, from the value perspective, there's only one case where it looks like there's a problem, and you found it out earlier...
10:54:13 <conal> SamB: joking?
10:54:25 <Cale> conal: If i = 1, j = _|_, k = _|_ then with the existing unamb, we have that y = unamb j k = _|_ and x = unamb 1 y = 1
10:54:37 <conal> Cale: right
10:55:47 <Cale> Now, consider how this might occur. You might have three expressions i,j,k and you don't know which of them is _|_, but you do know (according to the precondition for unamb) that if they are not _|_, then they ought to all have the same value
10:56:26 <conal> Cale: in other words, they're "consistent"
10:56:36 <conal> i.e., have a common upper information bound
10:56:41 <dino-> --| makes me think of a knocked over _|_
10:58:18 <Cale> So, while there could be a problem for programs which want to later compute unamb 2 y, in order to do this, they would have to know for certain that y really is _|_ beforehand, or else they are willingly breaking the precondition for unamb
10:58:28 <bavardage> how do I make Word8s manually?
10:58:39 <bavardage> should I just make an integer and coerce it?
10:58:47 <bavardage> i.e. I have 8 bits
10:58:54 <bavardage> and I want to mush them together into a Word8
10:58:56 <Cale> bavardage: Just write integer literals as usual
10:59:05 <Cale> bavardage: oh
10:59:14 <Cale> bavardage: Well, Word8 is a proper numeric type
10:59:14 <medfly> are there other websites to paste Haskell code and make it all pretty besides hpaste.org? it seems to be having trouble.
10:59:17 <bavardage> so I could just calculate the integer value...
10:59:23 <bavardage> and do it like that?
10:59:31 <jmcarthur_work> bavardage, maybe there is something in Data.Bits to help you?
10:59:33 <Botje> medfly: some other pastebins support haskell syntax
10:59:39 <bavardage> jmcarthur_work: I'll take a look
10:59:42 <Botje> i'd try pastebin.com
10:59:43 <Cale> medfly: maybe paste.lisp.org ?
10:59:44 <conal> Cale: yep
10:59:48 <medfly> thanks
10:59:48 <Cale> Or yeah, pastebin.com
11:00:07 <bavardage> hmm doesn't mention any word8s there
11:00:17 <Cale> bavardage: The only difference should be in your type signature
11:00:18 <roconnor> @instances Bit
11:00:19 <lambdabot> Couldn't find class `Bit'. Try @instances-importing
11:00:30 <roconnor> @instances Data.Bit.Bit
11:00:30 <lambdabot> Couldn't find class `Data.Bit.Bit'. Try @instances-importing
11:00:34 <Cale> bavardage: Word8 is an instance of Num and that's all you should need
11:00:36 <bavardage> Cale: right, and just treat it like a integer?
11:00:38 <Botje> @instances Bits
11:00:38 <lambdabot> Couldn't find class `Bits'. Try @instances-importing
11:00:42 <Botje> boo!
11:00:43 <roconnor> @instances Data.Bit.Bits
11:00:44 <Cale> > 3 + 2*5 :: Word8
11:00:44 <lambdabot> Couldn't find class `Data.Bit.Bits'. Try @instances-importing
11:00:45 <lambdabot>   13
11:00:48 <bavardage> so calculate it manually by raising each bit to 2*..?
11:00:49 <Cale> bavardage: yes
11:00:51 <bavardage> kk
11:01:00 <bavardage> thanks
11:01:03 <Cale> bavardage: er, you can do it recursively too
11:01:18 <bavardage> yeah
11:01:31 <Jedai> bavardage: you can use setBit
11:02:06 <Cale> bavardage: If the least significant bit is first, then  fromBits (b:bs) = b + 2 * fromBits bs
11:02:19 <bavardage> Cale: oh thanks
11:02:41 <Cale> er, well, assuming that b is a number. If it's a Bool, then you'll want a fromEnum in there.
11:02:58 <Cale> > map fromEnum [False, True]
11:02:59 <lambdabot>   [0,1]
11:03:02 <bavardage> kk
11:03:13 <Cale> uh, oh.
11:03:16 <Cale> :t fromEnum
11:03:17 <lambdabot> forall a. (Enum a) => a -> Int
11:03:25 <Cale> Unfortunate monomorphic type
11:03:30 <jmcarthur_work> :(
11:03:42 <Cale> fromIntegral (fromEnum b)  then
11:04:17 <Cale> Did I mention how much I hate Int?
11:04:19 <roconnor> > (foldr (\(i,x) -> flip (if x then setBit else clearBit) i) 0) (zip [0..] [True,False,False,True,False,True,True])
11:04:20 <bavardage> :D
11:04:20 <lambdabot>   Add a type signature
11:04:35 <bavardage> yeah Int smells
11:04:41 <conal> SamB: maybe you were joking, but yes i do like to distinguish syntax (expressions) from semantics (values)
11:05:05 <roconnor> > (foldr (\(i,x) -> flip (if x then setBit else clearBit) i) 0) (zip [0..] [True,False,False,True,False,True,True]) :: Word8
11:05:06 <lambdabot>   105
11:05:57 <roconnor> @pl \z -> (foldr (\(i,x) -> flip (if x then setBit else clearBit) i) 0) (zip [0..] z)
11:05:57 <lambdabot> foldr (uncurry (flip (flip . flip (flip if' setBit) clearBit))) 0 . zip [0..]
11:07:00 <Jedai> > foldl' setBit 0 . getIndices id $ [True,False,False,True,False,True,True]:: Word8
11:07:01 <lambdabot>   Not in scope: `getIndices'
11:07:27 <Jedai> @hoogle Indices
11:07:27 <lambdabot> Data.Array.Base indices :: (IArray a e, Ix i) => a i e -> [i]
11:07:27 <lambdabot> Data.Array.IArray indices :: (IArray a e, Ix i) => a i e -> [i]
11:07:27 <lambdabot> Data.ByteString elemIndices :: Word8 -> ByteString -> [Int]
11:07:32 <roconnor> > foldl' setBit 0 (elemIndices True [True,False,False,True,False,True,True])
11:07:33 <lambdabot>   Add a type signature
11:07:37 <roconnor> > foldl' setBit 0 (elemIndices True [True,False,False,True,False,True,True]) :: Word8
11:07:38 <lambdabot>   105
11:07:51 <Jedai> roconnor: thanks :)
11:07:58 <roconnor> > foldl' setBit 0 (findIndices id [True,False,False,True,False,True,True]) :: Word8
11:08:00 <lambdabot>   105
11:08:36 <Jedai> So "fromBits = foldl' setBit 0 . findIndices id"
11:08:42 <SubStack> :o
11:08:53 <roconnor> > (foldl' setBit 0 . findIndices id) [True,False,False,True,False,True,True]) :: Word8
11:08:54 <lambdabot>   <no location info>: parse error on input `)'
11:08:54 <Jedai> bavardage: nice and clean solution ! :P
11:09:04 <roconnor> > (foldl' setBit 0 . findIndices id) [True,False,False,True,False,True,True] :: Word8
11:09:05 <lambdabot>   105
11:09:26 <roconnor> least significant bit first
11:09:28 <bavardage> hehe
11:09:41 <bavardage> thanks
11:10:12 <roconnor> I can't tell if which of findIndices id or elemIndices True I like better
11:10:23 <roconnor> elemIndices True is probably better
11:10:29 <roconnor> findIndices id is more fun
11:14:25 <Baughn> @type elemIndices
11:14:26 <lambdabot> forall a. (Eq a) => a -> [a] -> [Int]
11:15:59 * roconnor wonders if findIndices id is more efficent
11:18:59 <Botje> @src findIndices
11:18:59 <lambdabot> findIndices p xs = [ i | (x,i) <- zip xs [0..], p x]
11:19:08 <Botje> @src elemIndices
11:19:08 <lambdabot> elemIndices x   = findIndices (x==)
11:19:54 <Botje> so assuming ghc doesn't eliminate the x== i'd say findIndices id would be marginally more efficient
11:21:02 <roconnor> hmm
11:21:23 <roconnor> there could be a GHC rule for relacing (True==) with id
11:23:50 <roconnor> I don't see one
11:23:58 <crutex> @faq
11:23:58 <lambdabot> The answer is: Yes! Haskell can do that.
11:24:31 <roconnor> @src (==) Bool
11:24:33 <lambdabot> Source not found. I've seen penguins that can type better than that.
11:25:58 <roconnor> instance Eq Bool where
11:26:00 <roconnor>     True  == True  = True
11:26:01 <roconnor>     False == False = True
11:26:02 <roconnor>     _     == _     = False
11:26:07 <roconnor> If this were instead defined as
11:26:14 <roconnor> True == x = x
11:26:22 <roconnor> and False == x = not x
11:26:35 <roconnor> then (==) could be inline here and simplified.
11:28:44 <roconnor> > lazy 5
11:28:48 <lambdabot>   Not in scope: `lazy'
11:29:11 <Botje> roconnor: if i read this core correctly, it does get compiled away
11:29:17 <Botje> Main.lvl5 = Data.List.findIndices @ GHC.Base.Bool Main.lvl Main.lvl4
11:29:22 <Botje> with
11:29:23 <Botje> Main.lvl = \ (b_aGt :: GHC.Base.Bool) -> b_aGt
11:29:42 <Botje> (source: elemIndices True $ map ... )
11:29:50 <roconnor> oh wow
11:29:54 <crutex> @karma Cthulhon
11:29:54 <lambdabot> Cthulhon has a karma of -147
11:29:58 <roconnor> I wonder how it does that
11:30:09 <roconnor> Botje: can you dump the rules that are fired?
11:30:18 <Botje> what flag is that?
11:30:20 <roconnor> (although it might not be a rule.
11:30:21 <Botje> -ddump-rules is not it :)
11:30:40 <roconnor> there is a nice flag to dump all sorts of nice info
11:30:44 <jmcarthur_work> woah, how come that karma is so low?
11:30:45 <roconnor> letme see
11:31:36 <MyCatVerbs> Eh, use ghc-core.
11:31:57 <Botje> that seems to be cabal installable
11:32:06 <roconnor> Botje: -ddump-simpl-stats ?
11:32:24 <MyCatVerbs> Indeed it is. You'll need to have PCRE installed for it.
11:32:31 <Botje> doing that now
11:32:34 <MyCatVerbs> You get a nice colour highlight and everything. Plus, if you're really interested in just which rules fired, you probably want to see the core that they reduced to, too.
11:32:51 <Botje> 9 RuleFired 3 ==#->case
11:33:02 <Botje> that ==#->case looks interesting
11:33:37 <roconnor> hmm
11:33:50 <roconnor> ==# seem to be for comparing Ints
11:33:51 <roconnor> however
11:33:59 <roconnor> Bools are treated kinda funny in GHC IIRC
11:34:05 <roconnor> so they might really be ints
11:34:23 <SamB> @src Bool#
11:34:23 <lambdabot> Source not found. My pet ferret can type better than you!
11:35:00 <roconnor> google searching for ==#->case doesn't work
11:35:20 <Botje> MyCatVerbs: cool!
11:35:26 <SamB> roconnor: of course not
11:35:30 <Botje> the core is a lot more readable now
11:35:38 <Botje> but i don't see much extra information
11:35:38 <SamB> it's almost entirely punctuation
11:35:53 * sm wonders if vty is utf8 aware at all
11:36:35 <MyCatVerbs> Botje: AFAIK dons wrote it. :)
11:36:44 <Botje> in that case, dons++
11:37:14 <MyCatVerbs> Botje: and I can see why, given that AFAIK he was spending a fair length of time looking at output core and trying to improve it at one point.
11:37:22 <Botje> yeah
11:37:26 <Botje> there's so much cruft there
11:38:20 * Botje simplifies input code
11:39:16 <Berengal> Reading core is like a really really bad trip...
11:39:24 * Berengal has a headache now
11:39:28 <Botje> Berengal: now it's a really really bad trip .. IN COLOR!
11:40:15 <Botje> i've reduced it to f = elemIndices True $ [False, False, True]
11:40:16 <Berengal> Botje: I still don't know what my 'print $ sum [1..1000000]' program does under the hood...
11:40:34 <Botje> Berengal: dark scary voodoo magic. Every compiler has a supply.
11:41:16 * MyCatVerbs read that as "dark scary compiler voodoo. You need a supply."
11:41:48 <Berengal> Botje: Indeed. The assembly looks like it's never looping, and setting the loop conditions at the end :/
11:41:51 <Botje> roconnor: I think it's either a CaseIdentity optimization or a BetaReduction followed by Case
11:41:56 <Berengal> Then again, I never was good at reading assembly either
11:42:12 <roconnor> Botje: ah
11:42:18 <Cale> Berengal: There's a higher level approach to understanding what's going on which is usually sufficient.
11:42:45 <roconnor> Botje: I can imagine the patter match turning into nested case statements
11:42:52 <Berengal> Cale: I apparantly fail at anything below 'print $ sum [1..1000000]'
11:43:22 <Cale> Berengal: Are you referring to the stack overflows?
11:43:56 <Cale> I can explain that much at least :)
11:44:17 <Berengal> Cale: It doesn't. I restricted it to Int, which the compiler specializes
11:44:43 <Cale> Oh, well, strictness analysis also tends to fix that
11:44:54 <Berengal> I was a little surprised to see references to 'eftInt' still in the assembly. I was hoping fusion would kick in
11:45:18 <MyCatVerbs> Berengal: rather than restricting it, put a SPECIALIZE pragma in?
11:45:59 <Berengal> MyCatVerbs: GHC already has a specialize pragma firing for sum :: Int and enumFromTo :: Int
11:46:04 <Berengal> Which fires
11:46:58 <MyCatVerbs> Oh, but that isn't enough to get you the transformations of things like sum? Darn.
11:47:50 <Berengal> MyCatVerbs: sum is transformed into a specialized int sum, but it doesn't look like sum and enumFromTo fuses
11:48:04 <Berengal> Which is what I'd hoped to see
11:48:20 <MyCatVerbs> enumFromTo will be defined in terms of build, and sum in terms of foldl.
11:48:47 <MyCatVerbs> The fusion implemented in GHC AFAIK is build/foldr fusion.
11:48:49 <Berengal> I was somewhat hoping it would compile down to four instructions...
11:50:26 <pumpkin> Berengal: you should try it on uvector :)
11:50:46 <pumpkin> Berengal: I'd be willing to bet it compiles to something pretty tight there
11:52:05 <Berengal> pumpkin: Looks much tighter with foldr (+) 0 instead of sum too
11:52:16 <pumpkin> well sum isn't even foldl'
11:52:22 <pumpkin> have you tried foldl' ?
11:52:26 <Berengal> It is for ints
11:52:41 <jmcarthur_work> with -O2 it's foldl', isn't it?
11:52:45 <jmcarthur_work> well, for strict types
12:02:19 <mathijs> Hi all, someone in here once gave me a handy way to calculate the number of times a number is divisable by 2 without iterating. it was a trick with (x `xor` (x-1)) and then some more, which I forgot. does anyone know what it is?
12:03:12 <ksf> in general, ln x.
12:04:12 <mathijs> I know, but I wanted the smart bitwise trick (it only worked for division by 2)
12:04:39 <tromp> x^(x-1) + 1 gives you highest dividing power of 2
12:05:12 <tromp> usually + has lower precedence than ^, so write it as (x^(x-1))+1
12:05:19 <tromp> i meant higher
12:05:24 <duaneb> (x `xor` (x-1)) should work fine, I think
12:05:25 <mathijs> ^ = and?
12:05:43 <mathijs> I remember it was xor I think
12:05:50 <tromp> oops, still wrong
12:05:51 <duaneb> err
12:05:53 <Botje> mathijs: http://graphics.stanford.edu/~seander/bithacks.html#IntegerLogObvious
12:06:01 <duaneb> you're looking for a log
12:06:05 <Botje> that's a short list of possibilities
12:06:24 <mathijs> Botje: thanks :)
12:06:34 <tromp> shld be ((x^(x-1))+1) >> 1
12:12:10 <duaneb> mathijs: what about 0?
12:12:14 <duaneb> what do you want to do for 0?
12:12:21 <duaneb> I have a solution here that's pretty simple
12:12:29 <duaneb> not fast, but simple :P
12:12:51 <duaneb> given a simple hash function, it COULD be simple
12:12:51 <mathijs> tell me :)  I found "((x `xor` (x-1))+1) `div` 4" to work, but I don't remember the 4
12:13:46 <duaneb> but seriously
12:13:49 <duaneb> the 0 thing
12:14:00 <duaneb> theoretically, it should be infinite
12:14:44 <tromp> no, it shld be 0
12:15:00 <duaneb> > let highest :: Word -> Word; highest 0 = 0; highest n = case (lookup (n `xor` (n-1)) $ map (\n -> (2^n, n)) [0..31]) of {(Just a) -> a};
12:15:01 <lambdabot>   not an expression: `let highest :: Word -> Word; highest 0 = 0; highest n =...
12:15:09 <mathijs> 0, I don't know... it shouldn't be given as input :)
12:15:12 <tromp> this is about divisibility, and 0 is more divisible than any other number
12:15:12 <duaneb> goddamn
12:15:26 <tromp> it's the infinity of divisibility if you wish
12:15:34 <duaneb> I just said 0 :P
12:15:49 <duaneb> that won't compile, but you get the idea
12:16:19 <duaneb> > let highest :: Word -> Word; highest n = case (lookup (n `xor` (n-1)) $ map (\n -> (2^n, n)) [0..32]) of {(Just a) -> a}; in highest 1
12:16:20 <lambdabot>   0
12:16:23 <duaneb> > let highest :: Word -> Word; highest n = case (lookup (n `xor` (n-1)) $ map (\n -> (2^n, n)) [0..32]) of {(Just a) -> a}; in highest 2
12:16:24 <lambdabot>   * Exception: <interactive>:1:198-276: Non-exhaustive patterns in case
12:16:28 <duaneb> !$@$!
12:16:34 <duaneb> maybe I should test :P
12:16:51 <duaneb> oh
12:16:52 <duaneb> goddamn
12:16:54 <bob0> Hi.  I'm not sure what's wrong in these two functions: http://pastebin.com/f1ef55b95
12:17:16 <mathijs> > let fact2 = x = ((x `xor` (x-1))+1) `div` 4
12:17:17 <lambdabot>   <no location info>: parse error on input `='
12:17:23 <mathijs> > let fact2 x = ((x `xor` (x-1))+1) `div` 4
12:17:24 <lambdabot>   not an expression: `let fact2 x = ((x `xor` (x-1))+1) `div` 4'
12:17:48 <mathijs> :(
12:20:18 <Vulpyne> bob0: What is the problem?
12:21:23 <sidewinder128> Hello, Im searching options for Haskell web programming anyone have suggestions? Webservers, Web frameworks or anything. thanks.
12:21:35 <Cale> sidewinder128: There's a lot of choices on Hackage...
12:21:43 <Cale> http://hackage.haskell.org/packages/archive/pkg-list.html
12:21:57 <sm> happstack is the big one. cgi is the small one. both good
12:21:59 <Cale> I don't do much web programming myself though, so perhaps not the best person to ask...
12:22:18 <sidewinder128> Cale I checked the list but I read happs is not maintained anymore so Im not sure what could do it
12:22:22 <Botje> bob0: replace / by `div`
12:22:36 <sidewinder128> sm ok I will check happstack
12:22:42 <Cale> Really? Happs isn't being maintained?
12:22:42 <Botje> although that will sometimes be an off-by-one error
12:22:52 <Cale> Oh, perhaps because it's become happstack
12:22:57 <sm> in between you have a bunch of things but all somewhat in of decay or just sprouting
12:23:01 <bob0> Vulpyne: http://pastebin.com/fb27b04
12:23:07 <sidewinder128> Well the homepage is static from long time
12:23:11 <sidewinder128> ah ok
12:23:13 <sm> Cale, right
12:23:15 <Cale> http://happstack.com/index.html
12:23:19 <Cale> looks nice :)
12:23:27 <sidewinder128> Thanks :D
12:23:46 <Cale> Oh, that's funny, it's not actually a happs application :P
12:23:52 <sm> sidewinder128: also check out turbinado, it might be coming back to life
12:24:02 <alexsuraci> I'm a socket n00b, can anyone explain why the "
12:24:11 <alexsuraci> cd" packet never gets received here? http://paste.pocoo.org/show/Hf3Ef9V9KQgGPs9naYGp/
12:24:13 <bob0> Botje: why do I need to use `div` if ceiling can return an integer?
12:24:13 <sidewinder128> sm yes turbinado looks cool
12:24:17 <alexsuraci> I'm also a keyboard n00b apparently...
12:24:37 <Botje> bob0: ceiling isn't the problem, unlagged is
12:24:42 <p_l> alexsuraci: for a while your question looked awesome (because I have /ignore on leaves/quit) :D
12:24:46 <Botje> / requires both its arguments to be Floating
12:24:51 <Botje> eh
12:24:52 <Botje> fractional
12:25:02 <bob0> can I convert them to fractional?
12:25:05 <Botje> yes
12:25:18 <Botje> ceiling (fromIntegral unlagged / fromIntegral unlagged_marker_max)
12:25:21 <alexsuraci> p_l: haha
12:25:23 <Botje> or however the variable is named
12:25:29 <ksf> alexsuraci, because you don't loop run?
12:25:43 <alexsuraci> ksf: it's looped in "wait"
12:26:07 <ksf> ...but not for the same connection, but the next one.
12:26:24 <ksf> ...in which case it will only read the first two bytes, again.
12:26:26 <alexsuraci> oh, duh
12:26:44 <Cale> alexsuraci: Oh, seems I was too late, yes, that's it :)
12:26:50 <alexsuraci> I confused what the functions should be doing, heh
12:26:59 <alexsuraci> That makes much more sense, thanks
12:26:59 <ksf> you also might want to stick an forkIO before the run conn
12:27:08 <alexsuraci> Yeah I do in my code, I just simplified it here
12:27:33 <Cale> alexsuraci: Another thing is that your server will only accept one connection at a time. You'll probably want to forkIO the communication to the client so that you can immediately go back to waiting for new connections.
12:27:49 <alexsuraci> Cale: too late again :P
12:27:54 <Cale> yes
12:27:56 <Cale> heh
12:28:10 <alexsuraci> thanks for all the help and for not belittling me for such a dumb mistake :P
12:28:42 <gwern> man. I still can't get over how yellow vitamin b supplements make your urine
12:28:58 <ksf> if we do, oleg joins the channel and expects us to grok his code, so we usually don't do such things.
12:29:20 <gwern> er. mischan
12:29:23 <alexsuraci> While I'm here, what's the best way to get colorized output, assuming the shell is Bash? Typing in the usual flags just prints them out directly.
12:29:24 * Cale intentionally misparses
12:29:29 <Cale> gwern: So how do yellow vitamin b supplements make your urine?
12:29:34 <gwern> Cale: neon
12:29:44 <ksf> there's some vty packages on hackage
12:30:11 <ksf> terminal interfacing is generally considered to be advanced black magic.
12:30:29 <sm> vty is good, except it doesn't handle multibyte, windows or gnome terminal
12:31:01 <sm> yet
12:31:05 <alexsuraci> vty looks nice
12:31:27 <Cale> Does anyone else think it's really stupid that our terminal emulators are emulating VT100's
12:31:28 <alexsuraci> lack of gnome terminal isn't so nice though
12:31:30 <Cale> ?
12:31:37 <idnar> Cale: yes :P
12:31:42 <dzlk> I wonder what the official term is for "vitamin B neon yellow", if there is one. Lab techs have a whole controlled vocabulary for colors of urine -- "goldenrod", "straw", "burgundy", etc.
12:31:50 <sm> alexsuraci: that might be something easy to fix.. I don't have one I can debut on
12:31:51 <dzlk> Cale: as opposed to?
12:31:52 <sm> debug
12:31:53 <alexsuraci> I thought gnome-term just used a standard backend? Was it vte?
12:31:56 <idnar> Cale: it's the moral equivalent of IP over avian carrier or smoke signals
12:32:34 <Cale> dzlk: Essentially every machine now has a beautiful graphical display.
12:32:39 <bob0> GHCi is complaining that an in inferred type is not polymorphic when http://pastebin.com/f3bdf11cb is loaded
12:32:52 <bob0> the error is http://pastebin.com/f56f49fa9
12:33:03 <inetic> hi, I can use the :t command inside the ghci to chcek the type signature of a function, but can I somehow inspect types in a simmilar way? e.g. I would like to see how is the State type defined (the one inside Control.Monad.State)
12:33:08 <Cale> dzlk: The idea of having a window where you can enter commands and get output from programs interactively is great, but why should it be limited to text?
12:33:22 <dzlk> I do think it's really kind of stupid that we're emulating glass ttys but I've never made up my mind what to replace it with.
12:33:25 <ksf> ...until you log into a solaris box and have vi throw its ed at you because it doesn't know the terminal type "linux"
12:33:30 <sm> text is simple
12:33:59 <sm> or at least, it should be
12:34:18 <idnar> Cale: even if it is limited to text, VT100 is a ridiculously convoluted / arcane / limited way of interacting with a character buffer
12:34:23 <Cale> yes
12:34:46 <idnar> we don't use PostScript to write graphical applications
12:34:49 <ksf> is xterm really vt100?
12:35:19 <Baughn> No, it's xterm
12:35:23 <idnar> well, I doubt any modern terminal emulators are actually VT100/VT220/whatever compliant
12:35:28 <idnar> but that's still the basis for the whole mess
12:35:39 <Baughn> ksf: But yeah, xterm understands a superset of vt100 commands
12:35:42 <dzlk> Cale: one of the nice things about text, though, is that it's linear so you can deal with it straightforwardly as a stream. I've thought about introducing graphics into the model but I'm stuck on how to do it without having to cope with two dimensions.
12:36:14 <Cale> dzlk: Mathematica provides a decent example
12:38:45 <dzlk> in any case "curses" is aptly named.
12:39:10 <Baughn> Cale: I'd kill for a mathematica worksheet that works like a .hs file
12:40:13 <Cale> For example, in Mathematica, the value  Button["Click me", Print[10!]] displays as an actual button which when clicked will add a new cell beneath it containing 3628800.
12:41:24 <sm> it doesn't get much more concise than that
12:41:25 <Cale> There are lots of composable controls of this sort, and they're first class values.
12:42:22 <Cale> Button[ContourPlot3D[x^2 + y^2 + z^2 == 1, {x, -1, 1}, {y, -1, 1}, {z, -1, 1}], Print[10!]]
12:42:23 * Baughn would probably prefer a spreadsheet with mathematica's power. Call me a luddite, but I like functional programming.
12:42:37 <Cale> Displays as a button with a 3D plot of a sphere as its label.
12:43:02 <Cale> (not that you'd actually want to do that, just to say that you can)
12:43:41 * Badger calls Baughn a luddite.
12:44:16 <Cale> Manipulate[expr, {var,min,max}] will construct a small interface in which the value of var in expr is controlled by a slider which varies between min and max
12:44:33 <Cale> and it's not really a primitive, but something built from the other controls
12:44:51 <maltem> What does “cabal test” do, if not run the runTests hook specified in Setup.hs?
12:44:57 <sm> this seems like tangible/reactive values
12:45:04 <Cale> Yeah, it does :)
12:45:29 <sm> it irks me that mathematica has been so far ahead for so long :)
12:45:57 <bnijk> good morning
12:46:01 <bnijk> http://www.newtechusa.com/PPI/pressroom.asp#higher
12:46:28 <pumpkin> uh
12:46:31 <Cale> bnijk: heh
12:46:45 <pumpkin> that's a pretty hot monkey
12:46:50 <dzlk> See also Plan 9, Squeak.
12:47:27 <bnijk> they could master VB3, but not java
12:47:54 <bnijk> i want to see the monkeys learn haskell
12:48:00 <dzlk> Squeak's approach to UI is really interesting, but unfortunately I don't like OO.
12:48:13 <pumpkin> OoOoO
12:48:38 <Cale> The cool thing about mathematica is that the interface is still very commandline-like, while incorporating graphics and UI widgets as first class values.
12:48:55 <pumpkin> zomg Cale is in Wolfram's pocket!
12:49:01 <Cale> hehe
12:49:02 <pumpkin> he's evangelizing another language in #haskell!!
12:49:04 <pumpkin> :)
12:49:09 <Cale> I think we should steal the idea.
12:49:13 <p_l> "Test subjects with the best results were baboons and bonobo apes. Both primate species demonstrated stressful behaviors when presented with Java tools and utilities." <--- THIS QUOTE
12:49:20 <pumpkin> I think so too
12:49:29 <bnijk> @quote p_l
12:49:29 <lambdabot> <p_l> says: damn, rage caused me to use wrong operator <bremner> is glad he is not in poland, so getting killed by p_l is less likely
12:49:29 <sm> I was just thinking that.. it seems you can always express everything in text.. so the graphics appear to the side or something ?
12:49:35 <bnijk> uhh
12:49:36 <luite> hm, that would make a good gsoc project
12:49:38 <Cale> There's no really good reason that this sort of thing should be restricted to a piece of very proprietary software :)
12:50:05 <p_l> hmmm... when did I say that? Wasn't that probably some Lisp vs. Haskell flame? xD
12:50:25 <Cale> sm: The graphics are displayed in a cell in the notebook. You can copy and paste them into expressions directly, they only display as graphics.
12:50:29 <sm> I have assumed mathematica's language has some strengths that make this hard to do in haskell or elsewhere
12:50:45 <ksf> Cale, it's copy-protected by wolfram's ego field. there's no way to get past that.
12:50:54 <bnijk> ego field??
12:51:26 <Cale> For example, I can evaluate  Graphics[Disk[]] to get a black unit disk, which I then resize interactively, copy, and paste into another expression...
12:51:26 <maltem> Hmph. Looks like “cabal test” should in mere theory only behave the same as “./setup test”.
12:51:33 <pumpkin> it's 1.0 wolframs of ego
12:51:51 * bnijk jumps out the window into the perilous-pit-o'-spikes
12:52:10 <kpreid> Cale: There are other graphics-capable-command-line systems, too. The problem is that AFAIK they're all tightly tied to one platform
12:52:17 <pumpkin> the ego field is impenetrable
12:52:23 <Cale> http://cale.yi.org/share/Screenshot-Mathematica.png
12:52:27 <kpreid> So nobody is going to be writing apps in $OTHERLANGUAGE/STYLE to run in them.
12:52:33 <Cale> http://cale.yi.org/share/Screenshot-DynamicPolynomial3D.png
12:52:42 <kpreid> Cale: Okay, that's silly and cute.
12:53:03 <pumpkin> lol
12:53:11 <sm> dr scheme has first-class graphical expressions, and reactive things.. but mathematica has something extra
12:53:19 <ksf> so we'd end up with a tex and gtk clone written in haskell?
12:53:31 <pumpkin> the point is the nice composable stuff
12:54:52 <Cale> I suppose an important primitive in that system is Dynamic[expr] which displays in the frontend as the dynamically updated value of expr
12:55:12 <Cale> and there are some options to it to control how often/when it is updated
12:56:15 <Cale> And if the interactive value of expr is edited, then an assignment of the form  expr = val  is done (when possible)
12:56:20 <Cale> (mathematica is not pure)
12:56:35 <tetha> wow, this university-project does have some cool architecture. component-based code generation modules being interconnected magically according to the goal specification
12:57:08 <Cale> tetha: which project?
12:57:32 <tetha> Cale: fabric, some system to generate a middleware for varying platforms and languages
12:57:58 <Botje> tetha: that sounds suspiciously like javabeans
12:59:35 <Baughn> tetha: At runtime or compile-time?
12:59:36 <tetha> Botje: well, not entirely, it is capable of generaty very small and efficient c-backends for sensor nodes
13:00:04 <tetha> Baughn: the code generation modules are interconnected at compile time and generate some simple static code
13:01:01 <tetha> in this case, a sensor node is basically a tiny embedded system with w-lan and less memory and processing power than my mouse
13:02:01 <p_l> for wolfram and mathematica...
13:02:03 <p_l> http://www65.wolframalpha.com/input/?i=PolarPlot[(1+%2B+0.9+Cos[8+t])+(1+%2B+0.1+Cos[24+t])+(0.9+%2B+0.05+Cos[200+t])+(1+%2B+Sin[t])%2C+{t%2C+-Pi%2C+Pi}]
13:02:06 <Cale> {Slider[Dynamic[x], {1, 5}], Dynamic[Plot[Sin[x i], {i, 0, 2 Pi}]]} -- this is a list/pair of two components, the first of which displays as a slider for interactively changing the value x and the second of which is a plot of Sin[x i] for i from 0 to 2 pi. Of course, in this case x is a global mutable variable, so we might want to limit its scope. There's a DynamicModule primitive which binds dynamic variables and lim
13:02:06 <Cale> its their scope too.
13:02:57 <Cale> Perhaps a binding form of that sort would be better suited to an otherwise pure language.
13:03:20 <Cale> p_l: cute :)
13:03:49 <p_l> Cale: Found it on another channel :D
13:03:54 <Cale> p_l: I can imagine a t-shirt with that formula on it being popular :)
13:04:47 <ulrivo> Hi, I am doing my first steps with Gtk2hs. The doc for gtk2hs says that functions like onKeyPress, onExpose are deprecated. Does anybody know how to use widgetAddEvents etc?
13:09:22 <Cale> dcoutts would know for sure. I can try to help :)
13:10:37 <Cale> Er, widgetAddEvents only adds events to the list of events which the widget will receive in the first place, it doesn't attach handlers
13:11:44 <akamaus> hi, why this doesn't work:
13:11:48 <akamaus> data Browser a = Browser {unBrowser :: StateT BrowserState IO a} deriving (Monad)
13:11:54 <akamaus> even with {-# LANGUAGE GeneralizedNewtypeDeriving #-}
13:11:57 <akamaus> ?
13:12:01 <ulrivo> Cale...yes, I think so, too. I assume that I have to use something like exposeEvent or buttonPressEvent
13:12:29 <paolino> akamaus: newtype maybe
13:13:08 <Cale> ulrivo: Normally you bind handlers using  widget `on` keyPressEvent $ do ...
13:13:35 <pumpkin> I assume that isn't the same on as Data.Function ?
13:13:58 <Cale> Right.
13:14:01 <Cale> It's different :)
13:14:54 <Cale> http://haskell.org/gtk2hs/docs/current/Graphics-UI-Gtk-Gdk-EventM.html -- this module defines actions for getting information about the event
13:15:33 <Cale> http://haskell.org/gtk2hs/docs/current/Graphics-UI-Gtk-Abstract-Widget.html#7
13:15:37 <Cale> these are the events
13:16:10 <akamaus> paolino, thanks
13:16:49 <ulrivo> in Abstract.Widget I found the info that the onKeyPress etc are deprecated
13:16:56 <Cale> ulrivo: right
13:17:32 <Cale> ulrivo: It's the stuff just above that which isn't deprecated
13:17:52 <Cale> You use  keyPressEvent instead
13:18:33 <ulrivo> Cale...probaby, I start my Gtk2hs-efforts with the deprecated functions. For these functions are demos and examples. And as I understand these, there will be examples for the non-deprecated stuff...smile
13:18:53 <Cale> You can see that its type is (WidgetClass self) => Signal self (EventM EKey Bool)
13:19:05 <ulrivo> Cale...thanks for your help very much.
13:19:09 <Cale> that is, it polymorphically applies to different types of widgets
13:19:19 <Cale> and it is one of these funny signal things...
13:19:39 <Cale> http://haskell.org/gtk2hs/docs/current/System-Glib-Signals.html#v%3Aon
13:19:52 <Cale> now, on :: object -> Signal object callback -> callback -> IO (ConnectId object)
13:20:27 <pumpkin> I'm not used to seeing full word type variables
13:21:21 <ulrivo> Cale...that is a very good hint...I shall investigate in this direction further on. thank you very much indeed
13:21:26 <Cale> So if we give on a widget, let's say a Button
13:21:46 <Cale> then it will want a  Signal Button callback
13:21:58 <Cale> we can pass it  keyPressEvent  then
13:22:10 <Cale> and  callback  is then  EventM EKey Bool
13:22:14 * augustss wishes gtk2hs wasn't such a beast to compile.
13:22:38 <Cale> So we then need to give it a value of type  EventM EKey Bool
13:23:33 <Cale> EventM EKey  is a monad in which we have information about key events available to us
13:23:54 <Cale> and we can also turn IO actions into EventM EKey actions by applying liftIO to them
13:24:08 <ulrivo> Cale...wow...you are really quick
13:25:43 <Cale> data EKey
13:25:43 <Cale> A tag for key events.
13:25:43 <Cale>  Instances
13:25:43 <Cale> HasModifier EKey
13:25:43 <Cale> HasTime EKey
13:25:51 <Cale> eventModifier :: HasModifier t => EventM t [Modifier]
13:26:10 <Cale> eventKeyVal :: EventM EKey KeyVal
13:26:18 <Cale> eventTime :: HasTime t => EventM t TimeStamp
13:26:25 <Cale> Some handy actions available in that monad
13:26:53 <Cale> eventKeyName :: EventM EKey String
13:26:59 <Cale> and there are some others
13:27:04 <gwern> man. I'd like to help Vasili but between his english and doing it on -cafe and and lack of experience with cabal, it's looking foreboding
13:27:08 <Cale> (look for EKey in http://haskell.org/gtk2hs/docs/current/Graphics-UI-Gtk-Gdk-EventM.html)
13:27:09 <Nafai> I didn't realize I used some deprecated functions in my gtk2hs stuff
13:27:24 <Nafai> Looks like I need to clean some things up
13:28:36 <Cale> The nice thing about using an EventM monad is that handlers for the same type of event become somewhat composable.
13:28:45 <duaneb> is there a convenient function (or idiom) for printin a list of values?
13:28:56 <Cale> mapM_ print list
13:29:07 <Cale> Or just print list
13:29:13 <ulrivo> Cale...EventM seems to have some nice functions but I will need some time to clarify for myself :-)
13:29:17 <duaneb> no, I mean
13:29:28 <duaneb> e.g. let showList :: (Show a) => [a] -> a; showList [1,2,3,4] = "1, 2, 3, 4"
13:29:57 <Cale> intercalate ", " . map show $ [1,2,3,4]
13:29:59 <Cale> > intercalate ", " . map show $ [1,2,3,4]
13:30:00 <lambdabot>   "1, 2, 3, 4"
13:30:05 <duaneb> intercalate?
13:30:11 <duaneb> how can I memorize this sort of stuff?!!
13:30:24 <int-e> idle on #haskell
13:30:28 <bob0> what is wrong with http://pastebin.com/f17df9141?
13:30:38 <bd_> @hoogle [a] -> a -> [a]
13:30:39 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
13:30:39 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
13:30:39 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
13:30:45 <Zao> For starters, you typed the ? too close to the URL :)
13:30:50 <bd_> @hoogle [a] -> [a] -> [a]
13:30:50 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
13:30:50 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
13:30:50 <lambdabot> Data.List deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
13:30:54 <bd_> hmmph.
13:31:02 <duaneb> @hoogle (Show a) => [a] -> String
13:31:02 <lambdabot> Prelude show :: Show a => a -> String
13:31:02 <lambdabot> Text.Show show :: Show a => a -> String
13:31:02 <lambdabot> Prelude cycle :: [a] -> [a]
13:31:03 <Cale> hoogle probably would get it, if it returned enough results :)
13:31:04 <Zao> http://www.thefreedictionary.com/intercalate
13:31:17 <Zao> In chemistry, intercalate has something to do with inserting molecules between other molecules.
13:31:28 <Cale> 'interpose' might have been a nicer word to use
13:31:40 <bob0> what is wrong with http://pastebin.com/f17df9141 ?
13:31:51 <gwern> bob0: your type is wrong
13:32:18 <Cale> bob0: You didn't paste the error message to go with it...
13:32:20 <gwern> you've got it used only with Integers, not with anything that is Integral
13:32:30 <int-e> bob0: you're being bitten by the (dreaded) monomorphism restriction
13:32:32 <gwern> Cale: his sv_fps has too general a type
13:32:49 <gwern> bob0: but comment it out and ghci can infer a sig for it
13:32:53 <int-e> bob0: give a type signature for max_unlagged_markers: max_unlagged_markers :: Num a => a  and it'll work
13:33:06 <wh1t3> shouldnt there be () around show ... ?
13:33:09 <Cale> ah, yeah, the problem is max_unlagged_markers getting defaulted to Integer
13:33:19 <Cale> wh1t3: Not necessary.
13:33:38 <Cale> I would use concat rather than multiple ++'s though
13:33:42 <Zao> Or Printf.
13:33:57 <bob0> max_unlagged_markers is supposed to be an integer
13:34:06 <bob0> what is the cancat operater in haskell?
13:34:13 <Cale> concat
13:34:45 <Cale> > let fps = 60 in concat ["If sv_fps is '", show fps, "', then the maximum ping..."]
13:34:46 <lambdabot>   "If sv_fps is '60', then the maximum ping..."
13:35:39 <bob0> I don't want the function to be called with a float
13:35:45 <bob0> doesn't Num include float?
13:36:25 <int-e> bob0: oh, then you should use  fromIntegral max_unlagged_markers  instead of  max_unlagged_markers  in sv_fps as well. Or perhaps you should use Integer all the way as gwern suggested
13:37:57 <Baughn> dcoutts: Have you tried using cabal-install with ghc 6.11's shared library support?
13:38:14 <Baughn> dcoutts: By which I mean "would you like to help me debug this problem"
13:38:21 <Cale> bob0: If you delete your type signatures, you can see the inferred types in ghci
13:38:32 <Cale> bob0: (or just comment them out)
13:40:23 <bob0> Cale: the inferred type is (Integral b1, RealFrac b, Integral b) => b -> (b1, [Char]).  What is RealFrac?
13:40:32 <pumpkin> @src RealFrac
13:40:33 <lambdabot> class  (Real a, Fractional a) => RealFrac a  where
13:40:33 <lambdabot>     properFraction                   :: (Integral b) => a -> (b,a)
13:40:33 <lambdabot>     truncate, round, ceiling, floor  :: (Integral b) => a -> b
13:41:19 <Cale> bob0: ah, that's a problem because there are no types which are both Integral and RealFrac
13:41:22 <bob0> how can something be both a RealFrac and an Integral?
13:41:32 <Zao> bob0: Just have instances for both.
13:41:34 <Cale> (but the compiler doesn't know that)
13:41:46 <Zao> They may not be that horribly sensical, but it's possible.
13:41:57 <Cale> The problem is that you're applying ceiling to what ought to already be an Integral
13:42:13 <Cale> er... actually
13:42:18 <Cale> that's not it :)
13:42:32 <cj2> hey people, i got one question about Gridcontrolls in wxhaskell. Don't know how to set the domain in wxhaskell, i want rows from 0 to 100 in stead of 1 to 100. does anyone now please???
13:42:57 <pumpkin> in 1 to 100's stead?
13:43:10 <Cale> let's see..
13:43:16 <cj2> i want to change the range./domain
13:43:26 <bob0> I removed ceiling, but what's wrong with the type signature of "sv_fps :: (Integral a) => a -> (a, String)"?
13:43:37 <augustss> cj2: function composition?
13:44:04 <cj2> no it has nothing do do with functin composition... there has to be a simple function for it
13:44:08 <cj2> just dont know which one it is
13:44:16 <Cale> You're applying fromIntegral to unlagged and max_unlagged_markers, so those both have to be Integral types, then you're dividing them, so they need to be coerced to Fractional types, multiplication by 1000 is fine there, and then you take the ceiling, so you should get back to Integral
13:44:54 <Baughn> dcoutts: I figured it out; it needs to provide -shared when linking libraries if shared is true. Let's see if I can write a patch..
13:45:26 <Cale> actually, hang on
13:47:00 <Cale> Yes, the problem is the dreaded monomorphism restriction as people mentioned :)
13:47:11 <pumpkin> OH NO!
13:47:26 <pumpkin> not the dreaded monomorphism restriction!
13:47:45 <bob0> Cale: the newest is http://pastebin.com/f21229c16
13:47:49 <Cale> bob0: When you define a constant as you have with max_unlagged_markers, the Haskell 98 spec says that it must have a monomorphic type
13:47:50 <bob0> Cale: what is monomorphism?
13:47:56 <Cale> That is, not polymorphic
13:48:24 <Cale> That is, *unless* it has an explicit type signature
13:48:29 <Cale> or a function parameter
13:48:36 <Cale> (on the left of the =)
13:48:52 <Cale> adding the explicit signature:
13:48:55 <Cale> max_unlagged_markers :: (Integral a) => a
13:49:02 <Cale> will make the original code work
13:49:11 <Cale> also, just turning this stupid restriction off will work
13:49:20 <Cale> {-# LANGUAGE NoMonomorphismRestriction #-}
13:49:24 <Cale> (at the top of the file)
13:49:34 <bob0> that's interesting syntax
13:49:47 <pumpkin> it's a pragma
13:49:49 <bob0> does that involve a preprocessor?
13:49:52 <Cale> It's a sort of pragma which is available in multiple compilers.
13:50:43 <Cale> (It works in hugs and GHC at least... I think others might support it too)
13:51:02 <bob0> Thanks.  I've got it working
13:51:08 <augustss> If you run into the MR with non-functions, you have usually made a mistake.
13:51:32 <Cale> In this case, just picking a monomorphic type would also work well.
13:51:34 <SamB_XP> Cale: I believe the authors at least feel that they ought to get around to it sometime, in most cases
13:51:40 <Cale> Like, restricting it to Integer
13:53:20 <Cale> augustss: Well, that's not the case here, though it's possible there's another simple way around it.
13:53:53 <Cale> ah, yeah, adding another fromIntegral to the occurrence of max_unlagged_markers in sv_fps works
13:54:07 <Cale> (instead of any of the other changes)
13:54:32 <Cale> Then max_unlagged_markers is an Integer
13:54:45 <Cale> (numeric defaulting occurs)
13:54:48 <augustss> Cale: I think it should be Integer, not Num a.  What are fractional users?
13:55:01 <alexsuraci> Followup: I went with ansi-terminal for colored output
13:55:53 <Cale> augustss: Well, there are certainly computations in which you might want to divide by it.
13:56:31 <augustss> Sure, and then you should convert there, so you know what you're doing. :)
13:56:37 <Cale> augustss: In which case, having it be polymorphic is convenient, and Num a => a is essentially isomorphic to Integer anyway.
13:57:41 <augustss> Cale: yes, sometimes it is convenient
14:00:34 <Baughn> dcoutts: Yep, just need to add -shared to ghcArgsShared in Simple/GHC.hs in cabal. Well, that was easy.. hope it works.
14:01:56 <Cale> oh, cj2 left... I was going to try to help...
14:04:47 <Botje> phew
14:05:08 * Botje just wrestled through "clowns to the left of me, jokers to the right: dissecting data structures" by conor mcbride
14:05:17 <Botje> now to turn it into a presentation
14:05:45 <duaneb> ok
14:05:55 <duaneb> I think my program has gotten far enough that it needs error checking
14:06:01 <duaneb> err, errors
14:06:08 <duaneb> what's a good, non `error' way to do this?
14:06:52 <Botje> if there are testable chunks, quickcheck?
14:07:16 <Cale> duaneb: Maybe/Either are good for pure code.
14:07:36 <Cale> duaneb: For IO code, there's exceptions
14:08:01 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html
14:10:52 <Cale> heh, it seems that haddock has mangled the example code there
14:11:08 <Cale> By clicking view source, at least you can see it properly
14:12:32 <Cale> Er, just "Source" rather :)
14:25:14 <gwern> > (10.93 - 4.98)
14:25:15 <lambdabot>   5.949999999999999
14:25:21 <gwern> hm?
14:25:41 <gwern> that seems a little odd...
14:25:50 <augustss> does it?
14:26:22 <pumpkin> > sum $ replicate 10000 (0.01 :: Float)
14:26:23 <lambdabot>   100.00295
14:26:26 <gwern>  93 - 98 is perfectly exact
14:26:31 <gwern> no need for the 999...
14:26:43 <augustss> gwern: yes, but that's not what you used.
14:27:07 <augustss> You used multiple of 0.01, and 0.01 is not represented exactly with binary floating point numbers.
14:27:13 <pumpkin> @check \x y z -> (x + y) + z == (x + (y + z) :: Double)
14:27:14 <lambdabot>   "Falsifiable, after 15 tests:\n1.6\n3.0\n-7.0\n"
14:27:22 <Cale> 10.93 isn't exactly representable as a finite binaryfloating point number
14:27:39 <gwern> but but it's 4 freaking digits!
14:27:41 <Cale> missed a space there ;)
14:27:45 <pumpkin> lol
14:27:46 <gwern> we have gigs and gigs of ram!
14:27:49 <Cale> gwern: Think of its binary representation
14:27:52 <gwern> how can we not represent it?
14:27:56 <Cale> What is it in binary?
14:27:58 <pumpkin> gwern: you can't finitely represent 0.9 either, and that's even fewer digits
14:28:01 * gwern dunno
14:28:19 <Cale> 0.1 also isn't representable as a finite sequence of binary digits
14:28:29 <augustss> gwern: only powers of 2 have a chance to be represented exactly
14:28:36 <Cale> Let's calculate the binary representation of 0.1
14:28:39 <gwern> Cale: auugh!
14:28:41 <FunctorSalad> gwern: it's just like 1/3 in decimal
14:28:51 * gwern decides math on computers is insane, and will leave it there
14:28:53 <Cale> It's less than 1/2, so the first bit after the binary point is 0
14:28:53 <pumpkin> lol
14:29:06 <pumpkin> > 0.5 + 0.25 + 0.125 + 0.0625
14:29:07 <lambdabot>   0.9375
14:29:07 <Cale> and it's also less than 1/4, so the second bit is 0
14:29:23 <FunctorSalad> there's only a finite decimal expansion for k/n if every prime factor of n is a prime factor of the base..
14:29:31 <FunctorSalad> err, not decimal expansion
14:29:33 <Cale> and it's less than 1/8, so the third bit is 0
14:29:36 <augustss> gwern: floating point is insane, but fast
14:29:47 <Cale> but it's larger than 1/16, so the 4th bit is 1
14:29:54 <gwern> augustss: if I wanted fast and wrong, I'd be in #c!
14:30:04 <Cale> and then 1/10 - 1/16 = 3/80
14:30:09 <pumpkin> use CReal then
14:30:17 <augustss> gwern: if you want slow and correct you can use CReal :)
14:30:37 <augustss> > (10.93 - 4.98) :: CReal
14:30:39 <lambdabot>   5.95
14:30:39 <conal> "C: for when there isn't time to get it right."
14:30:39 <gwern> > ((10.93 :: CReal) - (4.98::CReal))
14:30:40 <Cale> 3/80 is larger than 1/32, so the 5th digit is 1 as well
14:30:40 <lambdabot>   5.95
14:30:54 <gwern> phew
14:30:59 <pumpkin> Cale's going to get stuck in an infinite loop at this rate
14:31:02 * gwern feels much better
14:31:03 <bavardage> :D
14:31:09 <Cale> and the result is 1/160
14:31:16 <Cale> (the remainder)
14:31:28 <SamB_XP> conal: strangely enough, CReal has nothing to do with C
14:31:29 <Cale> which is 1/16 of what we started with
14:31:51 <gwern> SamB_XP: it doesn't? then what is it?
14:31:52 <Cale> and so if we keep at this, the pattern will repeat.
14:32:04 <augustss> gwern: C=Constructive
14:32:05 <Cale> (as 16 is a power of 2)
14:32:08 <conal> SamB_XP: i was refering back to gwern's remark about #c
14:32:29 <SamB_XP> gwern: Constructive Real, I assume
14:32:37 <SamB_XP> er. I probably knew that
14:33:10 <FunctorSalad> it's weird, with CString etc...
14:33:27 <augustss> The name is not ideal
14:33:43 <pumpkin> we should throw it in with Foreign.C.Types to confuse people
14:34:03 <SamB_XP> lol
14:34:03 <pumpkin> "oh, you meant it was for the language c? I though it was just for types with a C prefix on their name!"
14:34:43 <SamB_XP> I would rotfl, but there isn't enough room ... plus the dog is already down there ...
14:36:53 <FunctorSalad> @remember <pumpkin> we should throw it [CReal] in with Foreign.C.Types to confuse people
14:36:53 <lambdabot> I will never forget.
14:37:42 <gwern> @flush
14:37:45 <FunctorSalad> noooooo
14:38:08 <FunctorSalad> or wait, maybe that just commits to disk
14:38:11 <FunctorSalad> ?
14:38:58 <Cale> yeah
14:39:05 <pumpkin> :P
14:39:08 <Cale> in case lambdabot crashes for some reason
14:39:11 <FunctorSalad> I always misunderstand that word in computing...
14:40:27 <gwern> Cale: update the darcs state/ recently?
14:40:37 <Cale> nope
14:40:51 <gwern> you should
14:40:56 <Cale> If you want, I can copy it over.
14:41:14 <gwern> an update would be good
14:41:18 <gwern> the last one was ages ago
14:41:25 <gwern> makes me antsy
14:41:34 <PetRat> http://www.mibbit.com/pb/scHly0  <- Here I've got a parser that parsers strings separated by semicolons. I would also like it to discard anything past the last semicolon without giving an error. What is a simple way to do that?
14:41:36 <Cale> It's just state...
14:41:50 <gwern> it is the sweat and tears of dozens of haskellers!
14:42:55 * Berengal has a L-System \o/
14:44:40 <Berengal> Imma render som sierpinsky triangles and dragon curves
14:46:43 <Cale> parseTest (do xs <- many (try (manyTill anyChar (char ';'))); many anyChar; return xs) "abc;def;ghi"
14:46:46 <Cale> ["abc","def"]
14:47:33 <Cale> If you'd rather the parser not eat those characters, you can leave off the many anyChar, which allows you to simplify
14:47:48 <Cale> Prelude Text.Parsec> parseTest (many (try (manyTill anyChar (char ';')))) "abc;def;ghi"
14:47:49 <Cale> ["abc","def"]
14:48:31 <Cale> The 'try' is required because you need to look ahead to determine if there's another ;
14:49:00 <PetRat> Cale: thanks, I will study this and get back to you if any questions.
14:49:03 <Cale> Without try, parsec parsers always decide what route to take based only on the next character
14:49:24 <PetRat> By the way, is this an inefficient parser because you are applying 'try' to what might be a very long string?
14:49:41 <FunctorSalad> I found that sort of parsing confusing with parsec...
14:49:50 <FunctorSalad> you might consider using a lexer
14:50:00 <FunctorSalad> (like alex)
14:50:22 <PetRat> I also realized a moment ago that I could use sepBy and then one more step to discard the last item (after checking whether a semicolon follows it.)
14:50:27 <FunctorSalad> or just Data.List.Split.splitOn ";" :)
14:50:46 <PetRat> FunctorSalad: you are so right. :)
14:51:02 <PetRat> Cale: I'm still glad you showed me how one might do it that way.
14:52:07 <Cale> Well, it's potentially inefficient, but there's no way around that.
14:52:25 <Cale> Since there's no way to check if there's another ; than to look through the remainder of the input.
14:55:44 <dmwit_> ?unmtl MaybeT (StateT s m a)
14:55:44 <lambdabot> err: `MaybeT (s -> m (a, s))' is not applied to enough arguments.
14:56:02 <dmwit_> ?unmtl MaybeT (StateT s m) a
14:56:02 <lambdabot> s -> m (Maybe a, s)
14:56:23 <dmwit_> ?unmtl StateT s (MaybeT m) a
14:56:24 <lambdabot> s -> m (Maybe (a, s))
14:59:16 <dmwit_> ?index MaybeT
14:59:16 <lambdabot> bzzt
14:59:58 <Philonous> @type liftM ($)
14:59:59 <lambdabot> forall a b (m :: * -> *). (Monad m) => m (a -> b) -> m (a -> b)
15:00:46 <dmwit_> :t liftM id -- same idea
15:00:47 <lambdabot> forall a1 (m :: * -> *). (Monad m) => m a1 -> m a1
15:01:31 <Philonous> @type liftM2 ($)
15:01:33 <lambdabot> forall a2 b (m :: * -> *). (Monad m) => m (a2 -> b) -> m a2 -> m b
15:01:40 <Philonous> That's more like it :)
15:04:12 <Philonous> But I wonder, isn't the (m:: * > *) part redundant ?
15:09:18 <Berengal> @type ap
15:09:19 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
15:13:33 <Berengal> Been coding for over a day straight, and all I've got to show for it is 250 lines...
15:13:50 <pumpkin> 250 lines can be a lot of logic
15:14:17 <jmcarthur_work> 250 lines is a very large amount of code for one day
15:14:21 <Berengal> Much of it is simple convenience functions and values for ghci
15:14:39 <pumpkin> convenience functions can make it so that your important functions take a line each :)
15:15:23 <Berengal> Not test values though
15:15:34 <jmcarthur_work> Berengal, Arbitrary :)
15:16:17 <Berengal> jmcarthur_work: Test as in foo values, not as in checking for correctness
15:30:15 <ksf> has anyone ever wished for reverse dependencies on hackage?
15:30:30 <ksf> that is, see which packages depend on some package?
15:33:00 <Berengal> I believe ghc-pkg unregister tells you if that breaks some other packages at least... not at all optimal though
15:41:42 <ksf> I'd like something for those "what a cool library, I wonder if there are examples"-moments.
15:43:08 <Botje> some example uses like perldoc's synopsis
15:43:11 <Botje> would be nice too
15:54:20 <bavardage> is there a predefined function to split a list into certain sized chunks?
15:54:56 <Botje> check Data.List.Split
15:55:02 <thoughtpolice> @hackage split
15:55:02 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/split
15:55:05 <thoughtpolice> ^^
15:55:31 <bavardage> ty
15:55:34 <bavardage> :D
16:04:33 <dcoutts> Baughn: I'm not so sure about -shared in ghcArgsShared, we use it in ghcSharedLinkArgs because it's a link-time flag.
16:04:39 <ctran> [Char] -> Int -> [[Char]]
16:06:43 <Baughn> dcoutts: Hm. It wasn't being used, though.
16:07:09 <Baughn> dcoutts: I guess it doesn't hurt when I tell cabal to use it /all/ the time, but using cabal install -v I noted a distinct lack of -shared
16:07:11 <dcoutts> Baughn: there is a bug with the interpretation of the command line with ghc --make -dynamic (which is my fault and I've got a patch for). It's supposed to be ghc --make -shared that makes it link, not ghc --make -dynamic
16:07:33 <Baughn> Ah
16:07:50 <dcoutts> Baughn: with the patch for ghc is applied, then what cabal already does just works
16:08:06 <dcoutts> -shared is exclusively a link time flag
16:10:01 <Baughn> dcoutts: I'll live with it for the moment, then. My ugly hack works. :)
16:10:40 <dcoutts> Baughn: or apply this patch for ghc http://haskell.org/~duncan/ghc/link-shared-flag-fix.dpatch
16:12:15 <int-e> dcoutts: I have a problem with using 'ar -r -s -c' instead of 'ar q': Cabal relies on being able to put object files with identical names into an .a archive. Now if there are many object files (which happens with --enable-split-objs) and those additions are spread over several command invocations, only one copy of the object file will survive. :-(
16:12:42 <dcoutts> int-e: gah!
16:13:29 <Baughn> (Solution: Use dynamic linking, don't use split-objs?)
16:13:46 <dcoutts> int-e: so there is no portable way of doing it :-(
16:14:09 <Baughn> Well, there is the "rename the files" way
16:14:14 <int-e> dcoutts: short of renaming all .o files, I guess not.
16:14:26 <Baughn> Stick the md5sum of the file in the filename?
16:14:35 <dcoutts> int-e: unless we make the archive ourselves and call ranlib :-)
16:14:48 <Baughn> That wouldn't be portable. :P
16:14:58 <dcoutts> why not? ar is a standard format
16:15:15 <Baughn> It used to be, but consider extensions such as what LLVM and ICC like to stick in them
16:15:29 <int-e> which we don't need or use.
16:15:40 <dcoutts> int-e: you're using gnu ar?
16:15:41 <dmwit_> Berengal: Don't feel bad.  Last summer, I worked out that I averaged ten lines of code per hour while on the job, and that was in a more verbose language than Haskell. =)
16:15:49 <int-e> dcoutts: yes.
16:15:51 <Baughn> int-e: And if Clang eventually supercedes gcc?
16:15:58 <int-e> Baughn: I think dynamic linking solves a different problem.
16:16:17 <Baughn> int-e: It does mean you don't have to use split-objs, at least
16:16:30 <dcoutts> int-e: the man page for gnu ar says it implements q as a synonym for r, but obviously it's wrong
16:16:36 <int-e> dcoutts: and I found that the documentation is inaccurate; -q and -r do not do the same thing.
16:16:39 <int-e> exactly.
16:17:12 <dcoutts> int-e: so we need to go look again at what solaris and mac osx ar do/need
16:17:22 <bavardage> what would have type (a -> b) -> [a] -> [b]
16:17:24 <bavardage> like map
16:17:31 <bavardage> but with a change of type
16:17:39 <bavardage> oh dammit, that is map
16:17:45 <ehird> 00:15 Baughn: int-e: And if Clang eventually supercedes gcc? ← please, don't say "if"
16:17:45 <bavardage> ByteString's map isn't like that :(
16:18:20 <int-e> dcoutts: can we get away with naming the .o files 1.o, 2.o, 3.o, ...? We build a list of object files to link anyway; renaming them shouldn't be incredibly hard.
16:19:06 <dcoutts> int-e: ok, so we only need to worry about split-objs presumably? ar -r a.o a.o adds both?
16:19:37 <int-e> dcoutts: yes, that case seems to work.
16:19:46 <dcoutts> phew!
16:20:29 <dcoutts> int-e: so for the xargs/splitobjs case we can use -q for the initial invocations and -q -s for the last
16:20:44 <int-e> dcoutts: ar -q -s  also fails. ar -q -c works; ar -r doesn't.
16:21:19 <dcoutts> int-e: sorry you've lost me, doing what?
16:22:08 <dmwit_> bavardage: If you have to change type, you need to unpack the ByteString into a list.
16:22:48 <int-e> dcoutts: I have a test script here (from a Setup build -v log) that I can use to create a .a archive with various ar options. 'ar -r -s -c' is what Cabal now uses; 'ar q' (or 'ar -q') is what it used to use; but I've tried a few other combinations as well.
16:23:06 * Cale demonstrates the inability to wrap something around the projective plane twice with crude drawings :) http://cale.yi.org/share/projective-world-pull.png
16:24:18 <int-e> dcoutts: and when I use 'ar -q -s' on all invokations, I end up with an archive with only one copy of Stream__1.o (this is HTTPbis which has two 'Stream' modules).
16:24:44 <dcoutts> int-e: that is pretty strange
16:25:08 <dcoutts> int-e: since supposedly -q makes the index anyway
16:25:21 <int-e> ar -q and then running ranlib produces a different result, so that part of the ar manpage is wrong, too. binutils version is 2.18 btw.
16:28:51 <dcoutts> int-e: so we cannot use -q and -s together, so I guess we must use -q for the whole lot and then run ar -s on it's own at the end (which is equivalent to ranlib)
16:30:40 <dcoutts> int-e: and for gnu ar we should use -q -S on the normal ones and either omit -S on the final, or run ar -s / ranlib separately
16:32:04 <int-e> -S also hurts. Meh, I don't like this. I'd declare it a GNU ar bug, except that they'll probably say that identical file names of archive members aren't supported.
16:35:13 <dcoutts> int-e: how are you using -S exactly?
16:35:40 <int-e> dcoutts: AR="/usr/bin/ar -q -S" and then $AR file.a <lots of o files> (3 times)
16:35:54 <dcoutts> and it still omits duplicates?
16:36:00 <int-e> yep.
16:36:07 <dcoutts> so only -q works with gnu ar
16:36:31 <dcoutts> int-e: check that running ar -s on the final result doesn't mess things up
16:36:48 <dcoutts> just "ar -s libHSfoo.a" on it's own
16:37:35 <int-e> dcoutts: that seems to work. odd.
16:38:50 <dcoutts> int-e: ok, so we're ok for the normal "all in one go" invocation, and for the multi-step we have to use -q for the normal bits and then a call at the end with ranlib / ar -s
16:39:03 <dcoutts> int-e: and in theory that should still be the same on all platforms
16:39:16 <dcoutts> though strictly the ar -s is redundant with gnu ar
16:39:28 <dcoutts> and possibly with solaris too, maybe only needed with osx
16:40:02 <dcoutts> int-e: we should update the ticket with your discoveries http://hackage.haskell.org/trac/hackage/ticket/318
16:41:53 <int-e> I'll add something.
16:48:40 <travisbrady> anyone know of a good explanation of Zippers other than the wikibook?
16:49:06 <skorpan> i'd like that as well.
16:54:14 <Berengal> Huh, random L-Systems can be nifty...
16:54:38 <Berengal> I wonder what happens if I change the angle...
16:54:40 <Saizan_> http://notvincenz.blogspot.com/2007/07/higher-order-zippers.html <- the first part recaps normal zippers
16:55:07 <Cale> Berengal: have you got nondeterminism in your L-System expansion?
16:55:45 <Berengal> Cale: Not yet, but it shouldn't be hard to add
16:56:06 <Berengal> Just layer on a random-monad and change a few types...
16:56:56 <Cale> http://www.haskell.org/gtk2hs/gallery/Cairo-demo/Nymphaea_Drawing
16:57:20 <Cale> That's from an L-System generator that Paolo and I wrote a while back :)
16:57:32 <Cale> You can still get it from Hackage if you have gtk2hs :)
16:57:36 <Berengal> Yeah, I saw those yesterday
16:58:14 <Berengal> I'm just doing this because I'm bored
16:59:17 <Berengal> Since you've done this already, is there an easy way to center and scale the renderings?
17:01:43 <gwern> (bleh. as ever with gitit plugins, the bloody type system just gets in the way)
17:02:09 <Cale> Hmm... I just had a parameter for the step length, and allowed the user to set the initial point and angle with the mouse
17:02:52 <Cale> It seems that the nymphaea on hackage is drastically out of date.
17:03:00 <Cale> I should work on it a bit
17:03:06 <Berengal> Ah. I'm still at the point where I'm inputting the parameters by hand in the source
17:03:13 <Berengal> Well, I've got some structures to put them in...
17:04:02 <gwern> Cale: don't look at me! I sent you all my changes to nymphaea
17:06:25 <Berengal> Not sure if I quite like the structure though... I've got one datatype 'LSys' for systems (start :: String and rules :: [(Char, String)]), one for "renderable" L-Systems, containing things like which symbol draws forward, which jumps forward, which turns etc. and one for the Cairo Render monad config...
17:06:29 <Cale> gwern: I got it from hackage :)
17:06:57 <Cale> gwern: The latest version of gtk2hs seems to have changed some things
17:17:37 <Cale> Yay, got it running again at least :)
17:17:54 <Cale> Now I just have to finish converting from the deprecated event system
17:17:56 <shapr> What are the changes with gtk2hs? I just failed to build hsclock.
17:18:22 <Cale> shapr: The way that event handlers work has drastically changed, it seems
17:18:49 <shapr> so search and replace won't fix it...
17:18:57 <shapr> Is there a description of the changes?
17:19:47 <Cale> http://haskell.org/gtk2hs/docs/current/Graphics-UI-Gtk-Gdk-EventM.html
17:19:59 <shapr> thanks
17:20:09 <Cale> and stuff in http://haskell.org/gtk2hs/docs/current/Graphics-UI-Gtk-Abstract-Widget.html
17:22:37 <Cale> Er, odd.
17:22:56 * Cale wonders where clickedEvent is
17:27:10 * Berengal stumbles upon a crooked sierpinsky triangle
17:30:47 <shapr> Ok, is there a tutorial on writing gtk2 programs with the latest version of the bindings?
17:31:38 <shapr> foozles
17:33:21 <Cale> shapr: The basic idea is that you use something like  widget `on` buttonPressEvent $ do ...
17:34:06 <Cale> and that do-block will then be in an appropriate EventM monad, in this case EventM EButton
17:34:25 <Cale> The (EventM t) monad is always a MonadIO, so you can use liftIO for IO actions
17:34:46 <Cale> But it also has extra actions for obtaining information about the event which occurred
17:35:07 <Cale> eventButton :: EventM EButton MouseButton
17:35:33 <Cale> eventCoordinates :: HasCoordinates t => EventM t (Double, Double)
17:35:55 <Cale> eventModifier :: HasModifier t => EventM t [Modifier]
17:35:58 <Cale> etc.
17:38:55 <shapr> Funny, I was just reading about how people need to see examples and compilers do not.
17:39:08 <shapr> Cale: So, um, is there an example of this working somewhere?
17:39:30 * shapr points at BONUS, thus creating bonus points.
17:41:22 <chessguy> @pl p n = r ()
17:41:23 <lambdabot> p = const (r ())
17:41:30 * Cale just uploaded a new version of nymphaea to hackage which uses it
17:42:27 <Cale> It's kind of funny to use, since almost all of your event handler is likely to be IO stuff anyway
17:43:34 <Cale>   drawingArea `on` exposeEvent $
17:43:34 <Cale>     do r <- eventRegion
17:43:34 <Cale>        -- Get the pixmap and pin and the drawing area.
17:43:34 <Cale>        liftIO $ do ...
17:43:41 <Cale> But you can always do something like that
17:44:21 <shapr> Cale: 0.2 should build?
17:44:25 <Cale> 0.3
17:44:30 <Cale> I just uploaded it
17:44:31 <shapr> oops, cabal update first :-/
17:50:06 <lindzeyn> What might cause ghci to think that some operators (that I have defined in .hs file) are not in scope?  I am using the (!#$%&*+./<=>?@\^|-~) :: a -> etc... syntax
17:50:38 <Cale> lindzeyn: Is there a similar .o file hanging around?
17:51:02 <lindzeyn> I've just been using the interpreter, so no.
17:51:09 <Cale> lindzeyn: If values are not exported from a module, and ghci loads the compiled module instead of the source, then that can happen
17:51:13 <Cale> hmm
17:51:29 <Cale> What are the operators called?
17:51:42 <Cale> You have given them definitions of course, right?
17:52:00 <lindzeyn> yes. they are +~ and -~
17:52:38 <int-e> dcoutts: if you're still awake: I'm going to test this patch: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5590#a5590
17:52:42 <roconnor> What's the Dutch word for "Monad"?
17:52:53 <bremner> goto
17:52:58 <roconnor> :D
17:53:09 <Cale> lindzeyn: Can I see the first line of each of their definitions?
17:53:20 <lindzeyn> roconnor, Djikstra didn't get around to that, so there is none. :)
17:53:21 <Cale> You should have something like x +~ y = ...
17:53:30 <shapr> @seen sw17ch
17:53:30 <lambdabot> Last time I saw sw17ch was when I left ##english, ##freebsd, ##hrg, ##logic, #arch-haskell, #concatenative, #darcs, #dreamlinux-es, #friendly-coders, #functionaljava, #gentoo-haskell, #gentoo-uy, #
17:53:30 <lambdabot> ghc, #haskell, #haskell-blah, #haskell-books, #haskell-freebsd, #haskell-in-depth, #haskell-overflow, #haskell-soc, #haskell.cz, #haskell.de, #haskell.dut, #haskell.es, #haskell.fi, #haskell.fr, #
17:53:30 <lambdabot> haskell.hr, #haskell.it, #haskell.jp, #haskell.no, #haskell.ru, #haskell.se, #haskell_ru, #jhc, #jtiger, #macosx, #macosxdev, #novalang, #perl6, #rosettacode, #scala, #scannedinavian, #unicycling, #
17:53:30 <lambdabot> xmonad and #yi 1d 20h 3m 5s ago.
17:53:33 <shapr> aww
17:53:35 <roconnor> lindzeyn: I sort of figured.
17:53:38 <shapr> Man, that was some serious spam.
17:53:43 <int-e> that's a lot of channels
17:53:55 <Cale> In German, it's apparently Monade
17:53:58 <lindzeyn>  17 >(-~) :: PitchClass -> PitchClass -> Bool
17:53:58 <lindzeyn>  18 >cs (-~) ds = cs +~ i(ds)
17:54:01 * roconnor wonders if Bart Jacobs has and Dutch papers on the subject
17:54:06 <Cale> lindzeyn: aha
17:54:13 <Cale> lindzeyn: you're defining cs there
17:54:32 <Cale> lindzeyn: you want cs -~ ds = cs +~ i ds
17:54:35 <roconnor> lindzeyn: "monade" is tempting
17:55:02 <lindzeyn> doh! Nice catch Cale.
17:55:16 <lindzeyn> roconnor, if there is a german word for it, use it.
17:55:18 <shapr> roconnor: And in french that would be ..
17:55:29 <roconnor> Bij de Pythagoreërs was de monade het eerste ding dat 'was'.
17:55:29 <Jedai> lindzeyn: you either want (-~) cs ds =... or cs -~ ds = ...
17:55:38 <lindzeyn> got it.
17:55:39 <shapr> Instead of saying you drink the kool-aid, it'd be drinking Le Monade.
17:55:41 <lindzeyn> Thanks everyone
17:55:44 <roconnor> lindzeyn: German uses "monade"
17:55:57 <Cale> 圏論 is Japanese for Category Theory
17:56:08 <Jedai> shapr: French say monade
17:56:17 <roconnor> well "Monade"
17:56:18 <lindzeyn> I'd go with monade
17:56:27 <Berengal> Cale: Looks like a box, a woman and a man
17:56:34 <Cale> モナド
17:56:35 <Berengal> Suitcase, maybe
17:56:49 <Cale> mo na do
17:57:07 <Cale> http://ja.wikipedia.org/wiki/モナド_(圏論)
17:57:07 <Jedai> shapr: and you would say "la monade", not "le"
17:57:11 * Berengal wonders if there's a unicode symbol for monad
17:57:21 <shapr> Jedai: That totally kills the joke, you realize?
17:57:33 <shapr> quel dommage :-/
17:57:45 <Cale> hehe コモナド
17:57:53 <Cale> komonado
17:57:59 <shapr> oi Time`s_Witness, como vai?
17:58:09 <shapr> er wait, wrong channel.
17:58:19 <Jedai> shapr: Yes, too but que veux-tu :)
17:58:29 <shapr> Jedai: Yeah
17:58:31 <Berengal> ꁹ
17:58:59 <Berengal> I don't know what that is, but it's the only symbol in "Yi" I my font knows how to draw...
18:00:02 <Cale> U+A079 YI SYLLABLE NBIP
18:00:11 <Berengal> Yes
18:00:37 <Cale> My font displays it, but incorrectly
18:00:47 <Cale> http://www.fileformat.info/info/unicode/char/a079/index.htm
18:02:18 <Berengal> Heh, ␍␊
18:02:43 <Berengal> ☃
18:02:55 <Cale> http://en.wikipedia.org/wiki/File:Yiwen.jpg
18:03:48 <Berengal> Looks like some sort of runic chinese...
18:04:57 <Botje> aargh! chikings!
18:26:42 <lindzeyn> Can you define unary operators in Haskell?
18:26:43 <gwern> @seen dcoutts
18:26:43 <lambdabot> dcoutts is in #darcs, #gentoo-haskell, #ghc, #haskell, #haskell-in-depth, #haskell-overflow and #haskell-soc. I last heard dcoutts speak 1h 46m 41s ago.
18:26:46 <gwern> @seen dcoutts_
18:26:46 <lambdabot> dcoutts_ is in #haskell-in-depth, #gentoo-haskell, #ghc and #haskell-overflow. I last heard dcoutts_ speak 6h 57m 41s ago.
18:26:50 <gwern> @seen dcoutts__
18:26:50 <lambdabot> dcoutts__ has changed nick to dcoutts.
18:26:50 <lambdabot> dcoutts is in #darcs, #gentoo-haskell, #ghc, #haskell, #haskell-in-depth, #haskell-overflow and #haskell-soc. I last heard dcoutts speak 1h 46m 48s ago.
18:28:00 <gwern> @ask dcoutts do you know if darcs cabal/cabal-install broke library/executable sections? I've been banging my head over why cabal refuses to install an updated gitit library (even with bumped version) when it will the executable
18:28:00 <lambdabot> Consider it noted.
18:31:07 <gwern> @tell dcoutts my suspicious are drawn to cabal inasmuch as I updated yesterday and I hadn't for quite some time; and ghc-pkg turns up no trace of my bumped version of gitit - but the executable's --help says the right thing...
18:31:07 <lambdabot> Consider it noted.
18:31:56 <BMeph> lindzeyn: Yes, you can. :)
18:32:22 <lindzeyn> Hmph, I must be using improper syntax
18:32:34 <lindzeyn> All the tuts out there only give binary examples
18:34:53 <BMeph> lindzeyn: (If you're using GHC) http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#postfix-operators
18:35:43 <BMeph> lindzeyn: If you were looking for postfix operators. I think prefix ones are easier, but that's just opinion.
18:36:09 <lindzeyn> I prefer prefix
18:37:08 <BMeph> Is there a tutorial to how to use haddock to get your packages' docs integrated into GHC's main ones?
18:42:06 <BMeph> lindzeyn: I don't believe there's a provision for making operators prefix, since that comes automatically with parens. :)
18:48:57 <sclv> a prefix operator is called a "function"
18:50:17 <lindzeyn> I want something shorthand, like:  ##[1,2,3,4,5]
18:50:41 <lindzeyn> where ## = func :: [a] -> [a]
18:51:14 <gwern> > let ($$) = map (+1) in $$[1..10]
18:51:15 <lambdabot>   <no location info>: parse error on input `$$'
18:51:15 <lindzeyn> I use func alot and it sucks having to wrap parens around
18:51:19 <Cale> Well, normal function names are prefix...
18:51:27 <gwern> drat
18:51:54 <lindzeyn> right
18:53:21 <gwern> > let ($$) = map (+1) in $$ [1..10]
18:53:22 <lambdabot>   <no location info>: parse error on input `$$'
18:53:24 <Cale> > let (!) n = product [1..n] in (5!)
18:53:25 <lambdabot>   120
18:53:37 <gwern> > let ($$) x = map (+1) x in $$ [1..10]
18:53:38 <lambdabot>   <no location info>: parse error on input `$$'
18:53:52 <gwern> -_- guess $ must be reserved like #
18:54:09 <Cale> gwern: It's an infix operator
18:54:23 <Cale> > let ($$) x = map (+1) x in ($$) [1..10]
18:54:24 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
18:54:31 <Cale> > let ($$) x = map (+1) x in ([1..10] $$)
18:54:32 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
18:55:32 <edwardk1> @seen luqui
18:55:32 <Cale> http://www.marriedtothesea.com/060509/fake-insect-id.gif
18:55:32 <lambdabot> luqui is in #haskell-blah and #haskell. I last heard luqui speak 44m 43s ago.
18:55:57 <Cale> Something tells me that BONUS would love that one :)
18:56:34 <luqui> edwardk, ping
18:57:09 <newsham> hi
20:12:31 <F> hi all. I know no haskell. what is the sanest (not quickest) way to learn haskell? I already know C.
20:13:11 <F> (i.e. specific books to choose over others? are there authors or books to avoid?)
20:13:33 <ksf> forget all of it, then head over to Learn you a Haskell, Real World Haskell, and then the Typeclassopedia
20:13:39 <ksf> ...the rest follows from there.
20:13:47 <F> are those sites or books?
20:14:08 <F> just googled. nvm.
20:14:12 <ksf> the first is a site, the second book and site, and the last a journal submission.
20:14:46 <F> I appreciate it. thanks.
20:14:51 <ksf> no bother
20:17:33 <Cale> F: and ask lots of questions here whenever you get stuck!
20:17:50 <Cale> F: There are lots of people who like to help beginners :)
20:18:27 <Cale> You should get set up with ghc and ghci, if you're not already
20:23:11 <F> Cale: ah. let me grab that.
20:23:23 <F> what do you mean by "get set up" though? its just a compiler.
20:23:35 <Cale> Well, you should install it :)
20:23:55 <F> doing so now.
20:23:58 <Cale> 6.10.3 if you can get it :)
20:24:07 <F> yessir.
20:40:02 <mmorrow> pumpkin: having the "run-once-at-startup" ability is essentially having a "top-level <-" for IO, which got shot down (for ghc at least).
20:40:24 <edwardk> mmorrow: yeah makes me sad, jhc has it at least
20:41:06 <mmorrow> edwardk: yeah, that reminds me i've meant to try that out in jhc
20:43:25 <malouin> how do I get a ByteString out of a string literal?
20:43:41 <edwardk> pack?
20:43:53 <mmorrow> pumpkin: if you can manage to hook into the module_init (or whatever the label is) that the asm does, i guess that's the only way i can think of (each module has a .long or something that's set to 1 when it's "intialized" (not sure what triggers that)
20:45:00 <malouin> edwardk: well, apparently in my world a string literal is not [Word8]
20:45:33 <malouin> Expected type: [GHC.Word.Word8] Inferred type: [Char]
20:45:46 <edwardk> malhouin: then you might want to modify your world to import the data.bytestring.char8 ;)
20:46:03 <edwardk> er Data.Bytestring.Char8 module instead
20:46:31 <mmorrow> pumpkin: here the asm that every module has http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2568#a2568
20:47:04 <mmorrow> (not sure if it's different on diff arches)
20:48:07 <edwardk> malouin: i tend to import qualified Data.ByteString.Char8 as Char8 -- and then use Char8.pack as needed
20:48:09 <malouin> edwardk: awesome, thank you!
20:48:19 <edwardk> no problem
20:51:40 <goldenpuffs> quick question: if I have a list of functions [a->b] and I want to apply function1 to value1 in a list of values [a], and function2 to value2 and so on... how would I do that?
20:52:03 <mmorrow> zipWith ($)
20:52:13 <goldenpuffs> what does the dollar do?
20:52:20 <mmorrow> @src ($)
20:52:20 <lambdabot> f $ x = f x
20:53:08 <edwardk> @type zipWith ($)
20:53:09 <lambdabot> forall b b1. [b -> b1] -> [b] -> [b1]
20:53:12 <edwardk> @type zipWith id
20:53:14 <lambdabot> forall b c. [b -> c] -> [b] -> [c]
20:53:22 <mmorrow> @type [($),id]
20:53:24 <lambdabot> forall a b. [(a -> b) -> a -> b]
20:58:02 <goldenpuffs> hm I'm not sure I understand that definition, so I would do: zipWith ($) [a->b] [a] ?
20:58:29 <mmorrow> , zipWith ($) [(*2),negate,const 42] [1..]
20:58:32 <lunabot>  [2,-2,42]
20:58:42 <mmorrow> , zipWith id [(*2),negate,const 42] [1..]
20:58:44 <lunabot>  [2,-2,42]
20:59:44 <mmorrow> and `zip' is essentially
20:59:47 <mmorrow> zipWith (,)
20:59:53 <Axman6> goldenpuffs: basically, zipWith ($) is the same as writing zipWith (\f x -> f x)
21:00:29 <Axman6> > zipWith ($) [f,g,h] [x,y,z] :: [Expr]
21:00:30 <lambdabot>   [f x,g y,h z]
21:00:44 <Axman6> > zipWith (\f x -> f x) [f,g,h] [x,y,z] :: [Expr]
21:00:45 <lambdabot>   [f x,g y,h z]
21:01:01 <mmorrow> > zipWith id [f,g,h] [x,y,z] :: [Expr]
21:01:02 <lambdabot>   [f x,g y,h z]
21:01:15 <goldenpuffs> oh that helped, thanks for the examples
21:01:43 <mmorrow> i always forget about Expr/SimpleReflect.. it's handay
21:01:57 <goldenpuffs> so ($) is just an infix operator for function application?
21:02:01 <mmorrow> exactly
21:02:10 <goldenpuffs> sweet
21:02:35 <Axman6> but it's the fixity that's the importat part
21:02:49 <mmorrow> yes, this makes it different from `id'
21:02:54 <mmorrow> s/this/which/
21:03:01 <Axman6> lets you write (f . g . h) x as f . g . h $ x
21:03:02 <mmorrow> well, both work i guess :)
21:03:23 <mmorrow> ("well, both work i guess :)" @ s/this/which/)
21:04:02 <goldenpuffs> and another (unrelated) question: when is it preferable to use parentheses and when is it better to use (.) ?
21:04:18 <mmorrow> goldenpuffs: personal style preference
21:04:51 <goldenpuffs> ok, so both work exactly the same?
21:04:56 <mmorrow> yes
21:05:11 <goldenpuffs> good to know
21:10:37 <luqui> :t ($) 42
21:10:38 <lambdabot> forall a b. (Num (a -> b)) => a -> b
21:25:51 <Cale> Is it just me, or does nubBy suddenly seem backward?
21:26:20 <Axman6> how so?
21:26:33 <kpreid> :t nubBy
21:26:34 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a]
21:26:35 <sclv> ?ty nubBy
21:26:36 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a]
21:26:57 <Axman6> > nubBy (/=) [1,2,3,5,2,5,2,35,31,6]
21:26:58 <lambdabot>   [1]
21:27:02 <Axman6> > nubBy (==) [1,2,3,5,2,5,2,35,31,6]
21:27:04 <lambdabot>   [1,2,3,5,35,31,6]
21:27:19 <Cale> In that it appears to put the arguments to the comparator in the wrong order
21:27:21 * Axman6 always thought it could be called uniq and uniqBy
21:27:40 <Cale> nubBy eq (x:xs)  =  x : nubBy eq (filter (\y -> not (eq x y)) xs)
21:27:45 <Cale> according to the report
21:27:53 <Axman6> @src nubBy
21:27:54 <lambdabot> nubBy eq []             =  []
21:27:54 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
21:28:14 <Cale> So this means that nubBy (<) [1..10] should give what?
21:28:31 <Axman6> > nubBy (<) [1..10]
21:28:32 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
21:28:38 <Axman6> > nubBy (>) [1..10]
21:28:39 <lambdabot>   [1]
21:28:45 <Cale> hmm...
21:28:56 <Cale> Maybe I'm just being silly :)
21:29:04 <Cale> yeah, that's all it is
21:29:05 <Axman6> > nubBy (<) ([1..10]++ [5..10])
21:29:06 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,10]
21:29:24 <Axman6> hmm, i find that sort of strange...
21:29:29 <kyagrd> @. hstats
21:29:29 <lambdabot> Not enough arguments to @.
21:29:30 <Cale> wait, no
21:29:37 <Axman6> oh right, that makes sense
21:29:37 <kyagrd> Oops
21:29:48 <Cale> > filter (\y -> not (1 < y)) [2..10]
21:29:49 <lambdabot>   []
21:29:52 <Cale> see?
21:29:54 <Cale> I'm not crazy
21:29:59 <Cale> It's backward.
21:30:01 <Jedai> Axman6: uniq in Unix isn't nub though
21:30:12 <Axman6> > nubBy (const even) [1..10]
21:30:13 <lambdabot>   [1,2]
21:30:22 <Axman6> > nubBy (const even) [2..10]
21:30:23 <lambdabot>   [2]
21:30:27 <Axman6> > nubBy (const even) [3..10]
21:30:28 <lambdabot>   [3,4]
21:30:34 <kyagrd> > :k 1
21:30:35 <lambdabot>   <no location info>: parse error on input `:'
21:31:43 <kyagrd> @hoogle average
21:31:44 <lambdabot> No results found
21:31:55 <inimino> Jedai: what's the difference?
21:31:58 <kyagrd> huh ...
21:32:26 <Jedai> Cale: You're supposed to use an equivalence relation for nubBy so there really is no "right" order
21:32:39 <Cale> Jedai: No, there is a right order.
21:33:31 <Cale> nubBy with non-equivalence relations is quite useful
21:33:36 <Jedai> inimino: uniq remove identical _sequential_ elements, nub remove all duplicates
21:33:54 <kyagrd> >:k 1
21:34:03 <Cale> > nubBy (\x y -> x `mod` y == 0) [2..]
21:34:04 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
21:34:04 <Axman6> :k 1
21:34:05 <lambdabot> *
21:34:11 <kyagrd> > :k 1
21:34:12 <lambdabot>   <no location info>: parse error on input `:'
21:34:28 <inimino> Jedai: true, uniq requires sorted input
21:34:51 <Axman6> Jedai: that's not true, uniq removes all duplicate entries from its input
21:34:52 <kyagrd> @type undefined
21:34:53 <lambdabot> forall a. a
21:35:02 <Twey> Axman6: No it doesn't
21:35:04 <Axman6> or does it
21:35:05 <inimino> (to act like nub that is)
21:35:06 <Axman6> hmm
21:35:20 <Twey> Axman6: Try it
21:35:27 <Cale> similarly, groupBy (<) is quite useful
21:35:28 <inimino> no
21:35:30 <inimino> sort | uniq is basically nub though
21:35:32 <Axman6> reading the man page seems to agree with you. how odd
21:35:39 <Twey> inimino: Except that the order is changed
21:35:42 <Cale> > groupBy (<) [1,2,3,4,3,1,2,3,1,2]
21:35:43 <Twey> nub doesn't change the order
21:35:43 <lambdabot>   [[1,2,3,4,3],[1,2,3],[1,2]]
21:36:00 <inimino> Twey: true
21:36:01 <Axman6> i don't like how that groupBy works
21:36:02 <Cale> > map (drop 1) . groupBy (<) $ [1,2,3,4,3,1,2,3,1,2]
21:36:03 <lambdabot>   [[2,3,4,3],[2,3],[2]]
21:36:05 <Jedai> inimino: with better complexity though
21:36:17 <Cale> I love the way that groupBy works
21:36:22 <Cale> I hope they never change it.
21:36:51 <lindzeyn> This sounds silly, but is there a way to coerce an Integer into a List in Haskell? Ex. 123456 = [1,2,3,4,5,6]
21:36:57 <Axman6> i prefer another version i've seen, which in that case would give [[1,2,3,4],[3],[1,2,3],[1,2]]
21:36:59 <Cale> Consider if my example list there had been the depths of document subheadings.
21:37:12 <lindzeyn> Or, is there a way to modify a single index of a list?
21:37:12 <Axman6> which gets all ascending groups
21:37:12 <kyagrd> lindzyen: In GHC you can do something like that
21:37:13 <Cale> groupBy automatically does the right thing to separate them into groups
21:37:22 <Jedai> lindzeyn: the simple way is "map digitToInt . show"
21:37:52 <Axman6> Cale: depends on your definition of 'the right thing'
21:38:10 <Cale> Axman6: I mean the document subheadings
21:38:11 <Jedai> lindzeyn: the efficient way is to use divMod and unfoldr
21:38:35 <Axman6> eh?
21:38:37 <kyagrd> lindzeyn: Lennart even overloaded integer numeric literals to have function types
21:38:43 <Jedai> lindzeyn: or something equivalent
21:38:55 <kyagrd> lindzeyn: no reason list cant be
21:39:03 <Cale> Axman6: Consider a document with headings like 1, 1.1, 1.2, 1.2.1, 1.2.2, 1.2.3,...
21:39:14 <Axman6> the version of groupBy i like is nice, because it can be used for a somewhat efficient implementation of mergesort
21:39:17 <Cale> Axman6: Suppose we want to turn that into a tree.
21:39:43 <lindzeyn> Thanks everyone
21:39:47 <Axman6> because it automatically groups the input into ascending groups
21:40:18 <Cale> Axman6: The current groupBy is perfect for splitting up the list at the top-level to the cases to be handled recursively
21:40:59 <Cale> You want all the stuff after 1, up to the first heading of the same depth, say 2, to be in the same group
21:41:32 <Cale> So it's groupBy ((<) `on` headingDepth)
21:41:48 <Cale> and then map (drop 1)
21:41:54 <Axman6> i guess
21:42:08 <Axman6> i'm just more interested in numbers than documents i guess :P
21:42:36 <Cale> Well, there are other numerical problems you can take on with this sort of groupBy too
21:42:52 <Cale> I think it's the most natural thing, recursively.
21:43:09 <Cale> But it would be nice to have the other one around too
21:43:34 <Axman6> yeah
21:43:53 <Axman6> someone's written a package that does that, and a few other things that they feel were broken too
21:46:20 <mmorrow> Axman6: are you referring to the "group" in the mergesort in ghc/other places (w/ an email fragment in the comment)?
21:49:15 <mmorrow> Axman6, Cale: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5595
21:49:53 <mmorrow> heh, looks like andyjgill wrote that `group' in 1996
21:52:17 <Cale> anyway, I think I should complain on the mailing list about nubBy having its parameters swapped
21:52:29 <Gracenotes> lamby!! Come back!
21:52:41 <Cale> I'm bringing it back in a moment :)
21:53:42 * mmorrow guesses that Cale will get extreme resistance, even if he is "right"
21:54:02 <Cale> mmorrow: I just want it to match the report!
21:54:08 <mmorrow> oh, it doesn't?
21:54:18 <Cale> The current behaviour in recent GHCs swapped it
21:54:25 <mmorrow> ah, in that case :)
21:54:31 <Cale> and it broke my cheesy implementation of primes :)
21:54:34 <mmorrow> hah
21:55:03 <sshc> what is a graphics API for Haskell that preferably works with Haskell?
21:55:20 <Cale> Oh, apparently it is fixed in head?
21:55:25 <mmorrow> sshc: OpenGL?
21:55:27 <Cale> wait... this message is from 2008
21:55:34 <Cale> Did they screw it up again?
21:55:38 <sshc> yes, opengl
21:55:45 <sshc> that preferably works with OpenGL
21:55:54 <mmorrow> sshc: OpenGL? :)
21:56:20 <sshc> what is HOpenGL, then?
21:56:26 <mmorrow> oh, not sure
21:56:46 <mmorrow> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/OpenGL
21:56:55 <mmorrow> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/GLUT
21:57:50 <mmorrow> sshc: (random fact: if you're planning on using forkIO with OpenGL, you need to use forkOS instead, since OpenGL uses thread-local-state)
21:57:55 * mmorrow found that out the hard way
22:02:03 <Axman6> heh
22:02:11 <mmorrow> (the "hard way" being inexplicable randomly occurring segfaults and cryptic failed assertions from the C opengl driver)
22:14:29 <luqui> what's the type theory symbol for greatest fixed point?
22:14:31 <luqui> the dual of mu?
22:14:57 <Cale> Is there a libraries trac?
22:15:05 <Cale> Or do I report bugs to the ghc trac?
22:15:33 <ski> luqui : it often seems to be called `nu'
22:15:59 <luqui> ski, thanks
22:16:22 <ski> Stream a = nu s. a * s
22:26:53 <Cale> http://hackage.haskell.org/trac/ghc/ticket/3280 :)
22:35:01 <chowmeined> how well does ghc work on solaris?
22:37:21 <Tarrant> chowmeined: I doubt you would have an issue.
22:40:04 <Beelsebob> works fine on solaris at many unis I know of
22:40:14 <kyagrd> is there a nice documentation for the chart library?
22:40:28 <kyagrd> Even the hompage API docs has broken links :-(
22:47:35 <cygnus> Library preference / stability / usefulness question: nanocurses or hscurses?
22:51:52 <kyagrd> If anynoe has pointers to examples of Chart library using error bars I would appreciate it.
22:57:39 <bos> @seen dons
22:57:40 <lambdabot> dons is in #haskell-in-depth, #gentoo-haskell, #concatenative, #arch-haskell, #darcs, #yi, #xmonad, #ghc and #haskell. I don't know when dons last spoke.
23:00:25 <mriou> I have something that sounds like a very simple question but I've been searching for an hour without finding
23:00:35 <mriou> how do you get the current time in ms
23:00:38 <mriou> ?
23:00:54 <mriou> preferably as an Int :)
23:11:58 <sm> mriou: find it ?
23:36:37 <Cale> mriou: Data.Time.Clock.getCurrentTime :: IO UTCTime
23:37:15 <Cale> mriou: Oh, I suppose that measures it in seconds
23:37:34 <Cale> oh... gone
23:40:21 <dmwit> UTCTime is supposed to have as much accuracy as your machine offers, up to picoseconds.
23:40:22 <pumpkin> you seem to have bad luck with that :)
23:40:26 <dmwit> ...I thought.
23:40:48 <Cale> oh, yes, I see
23:40:49 <dmwit> I guess I'd better check that before I claim it, huh?
23:40:59 <Cale> That DiffTime in there is arbitrary resolution
23:41:13 <dmwit> right
23:41:15 <Cale> up to 10^-12 seconds anyway
23:42:23 <Cale> If you're going to go that far, why not just use Planck time units? :)
23:42:30 <dmwit> =)
23:44:36 <Cale> Heh, measure all times as integers in Planck time units since the big bang.
23:44:49 <Cale> type Time = Nat
23:46:01 <pumpkin> lol
23:46:49 * dmwit proposes a Prelude category on Hackage.
23:46:50 <pumpkin> 1e-44 s
23:46:59 <dmwit> Prelude.Dmwit, Prelude.Cale, Prelude.Pumpkin, etc.
23:46:59 <pumpkin> that might be a little extreme
23:47:11 <pumpkin> Prelude.Chopin
23:47:14 <dmwit> =D
23:47:44 <Cale> It takes about 10^20 Planck time units for light to travel the diameter of a proton.
23:48:05 <hatds> I''d still want Time = Integer though for negative times
23:48:23 <pumpkin> http://www96.wolframalpha.com/input/?i=age+of+universe+in+planck+time
23:48:25 <Cale> To refer to times before the time at which time has meaning?
23:48:31 <hatds> yes
23:49:07 <pumpkin> wolfram alpha disappointed me
23:49:12 <pumpkin> I asked planck time since big bang
23:49:15 <pumpkin> and it hadn't a clue
23:49:22 <pumpkin> had no clue?
23:49:30 <pumpkin> hadn't a clue feels a little awkward
23:49:47 <dmwit> Expand the contraction for even more awkwardness.
23:50:03 <dmwit> How about making it a positive statement?
23:50:07 <dmwit> "It was clueless."
23:50:12 <pumpkin> :)
23:50:13 <cads> "ain't had no clue"
23:50:19 <Cale> It was without clue.
23:50:29 <pumpkin> of clues, it certainly had none
23:50:40 <cads> "di'n kno shiut"
23:50:49 <Cale> As for clues, didn't exist.
23:51:03 <pumpkin> wow, I can tell it's early saturday morning
23:51:03 <cads> I'd like to see if it knows the topological genus of random objects
23:51:20 <pumpkin> I'm such a cool kid
23:51:28 <pumpkin> waiting for my GHC to compile on a friday night
23:52:16 <sm> evening all
23:52:27 <sm> anyone interested in hacking on dons' rss2irc a little ?
23:52:30 <pumpkin> sm: it ain't evening here, you insensitive clod!
23:52:44 <dmwit> I for one welcome our new zoneless overlords.
23:52:51 <sm> good {timeofday} pumpkin
23:53:07 <sm> just a little local colour
23:53:11 <pumpkin> NOT EVERYONE HAS SOPHISTICATED IRC CLIENTS THAT PERFORM SUBSTITUTIONS, YOU INSENSITIVE CLOD
23:53:16 <pumpkin> :(
23:53:27 <dmwit> Ew, you spilled some 'u' in your color.
23:53:34 <pumpkin> remind me how shitty my nc client is
23:53:47 <pumpkin> :)
23:53:51 <Gracenotes> :d
23:53:53 <Cale> こんばんは、みんなさん！
23:53:59 <pumpkin> :o
23:54:10 <Gracenotes> ：Ｏ
23:54:18 <Cale> へ＿へ
23:54:19 <pumpkin> こんばんはってじゃない！
23:54:23 <pumpkin> lol
23:54:27 <Gracenotes> ｗｈａｔ　ｙｏｕ　ｓａｙ
23:54:29 <pumpkin> my japanese has gotten so terrible
23:54:48 * pumpkin needs to go back
23:56:36 <pumpkin> 鉛筆は赤いですよ！
23:56:42 <pumpkin> there, back to basics :P
23:56:54 <Gracenotes> ay. I never learned any of the alphabets
23:57:09 <Cale> 基地はすべて我々の物だ！
23:57:22 <pumpkin> lol
23:57:32 <Gracenotes> ¡What is this now!
23:57:39 <pumpkin> somebody set up us the bomb!
23:57:48 <Cale> "All your base are belong to us."
23:58:41 <Gracenotes> ｗｈａｔ　ｙｏｕ　ｓａｙ
23:59:00 * Cale invents an even worse literal translation: as for base, all us's thing is
23:59:15 <pumpkin> wow, that is awesomely bad
23:59:33 <pumpkin> +5 points for genitivizing us
23:59:50 <Gracenotes> genitivizing? sounds painful
23:59:58 <Cale> us's
