00:00:41 <mmorrow> FunctorSalad: hmm, that's an interesting idea. what do you suggest?
00:00:47 * ski would prefer if moonpaste omitted the trailing `#someAnchor' on non-annotations ..
00:01:14 <mmorrow> ski: yeah
00:01:49 <mmorrow> FunctorSalad: what kind of minimal set of options do you think could cover such a thing?
00:01:54 <FunctorSalad> mmorrow: hmm I don't know what the general scheme would be
00:02:20 <ski> fmap (\(x,xs) -> (nameBase x, fmap nameBase xs)) = fmap (nameBase *** fmap nameBase)
00:02:30 <mmorrow> heh
00:02:58 <mmorrow> but (***) isn't in scope ;)
00:03:00 <ski> (just noting it. you might prefer the pointful version)
00:03:14 <FunctorSalad> mmorrow: I think it would amount to contracting edges in the sense of graph theory, but I don't know how to specify *which* edges ;0
00:03:21 <FunctorSalad> s/0/)/
00:04:00 <mmorrow> FunctorSalad: yeah, that's the crux
00:04:01 <ski> do you want to collapse all full subgraphs ?
00:04:08 <mmorrow> FunctorSalad: actually doing it would be easy
00:04:21 <mmorrow> ski: hmm, how do you mean?
00:04:32 <mmorrow> err, what's the definition of "full" ?
00:04:40 <mmorrow> (all possible edges?)
00:05:08 <ski> say `G' is the graph and `S', with `i : S c-> G' is a subgraph
00:05:40 <ski> if `S' is a full graph (all possible edges present), then one could collapse the `S' part of `G' into a single node
00:05:55 <ski> and do the same for all full subgraphs of `G'
00:06:17 <ski> i was just wondering if that's what FunctorSalad had in mind
00:06:23 <FunctorSalad> aka "complete graph" ?
00:06:35 <ski> (yes, that would be the same, i think)
00:06:35 <FunctorSalad> (the subgraph)
00:06:44 <FunctorSalad> ah no wait, I see what you mean
00:06:51 * ski was probably thinking of the terminology of "full" relations
00:07:00 <mmorrow> also note that vacuum can see the constructor of everything
00:07:18 <mmorrow> so it can use that to choose to not follow a path anymore..
00:07:21 <FunctorSalad> it seems to coincede with "full subcategory"
00:07:26 <ski> mmorrow : how does it handle `(->)' ?
00:07:56 <mmorrow> ski: unpackClosure# just returns no pointers from functions
00:08:07 <FunctorSalad> ski: isn't any single-edge subgraph full then? (if there aren't multiedges)
00:08:10 <ski> FunctorSalad : no, that would not be quite the same
00:08:32 <mmorrow> ski: unpackClosure# :: a -> (Ptr InfoTable, [pointers], [literals])
00:08:56 <ski> a full subcategory has all morphisms between the objects it actually has
00:09:08 <ski> there "full" is relative to the inclusion functor
00:09:20 <FunctorSalad> yes
00:09:24 <mmorrow> (actually ==> packClosure# :: a -> (# Addr#, Array# b, ByteArray# #) )
00:09:32 <mmorrow> *unpackClo..
00:09:32 <ski> with the graphs above (and with relations), "full" is absolute to the (sub-) graph/relation
00:10:17 <FunctorSalad> ski: are you talking about the difference between set-theoretic subsets and explicit injections?
00:10:26 <ski> no
00:10:37 <FunctorSalad> then I'm not sure I understand
00:11:19 <ski> i'm just saying that "full" wrt "subgraph" above is not relative to the subgraph being a subgraph of another graph .. it is absolute to the subgraph itself
00:11:55 <FunctorSalad> ok, I understood "all possible edges" as being relative to the inclusion
00:12:31 <ski> i.e. assuming a graph consists of a set `E', a set `V', and two functions `src,tgt : E >-> V', this graph being full merely means that `E' is a product of `V' with itself, with `src' and `tgt' as the two projections
00:13:08 <ski> (iow, every possible edge exists in the graph)
00:13:31 <FunctorSalad> ok, then "aka complete graph" was accurate after all :)
00:13:36 <ski> yes
00:13:43 <ski> i thought i agreed with that :)
00:14:10 <FunctorSalad> you did, I was just correcting myself (I said it's not the same as a complete graph)
00:14:30 <ski> why wouldn't it ?
00:15:33 <ski> mmorrow : isn't `Addr#' there a pointer ?
00:15:45 <FunctorSalad> I was thinking of the "full subcategory" sense at that time :)
00:16:07 <FunctorSalad> I think it's called "induced subgraph" or something
00:16:53 <mmorrow> ski: yes, a ptr to the infotable for that closure
00:17:11 <mmorrow> (GHC.Ptr==> newtype Ptr a = Ptr Addr#)
00:17:43 <ski> <mmorrow> ski: unpackClosure# just returns no pointers from functions
00:17:47 <ski> then meant ?
00:18:09 <mmorrow> ah, so the Array is an array of Any's
00:18:21 <mmorrow> which i was refering to as "pointers"
00:18:35 <mmorrow> (pointers being not machine int/double/word/etc)
00:18:41 <mmorrow> ie haskell values
00:18:52 <ski> is it returning pointers from functions, or not ?
00:18:55 <mmorrow> which calling unpackClosure# on again lets you follow like pointers
00:19:00 <mmorrow> ski: oh, no
00:19:05 <mmorrow> , vacuum id
00:19:08 <lunabot>  [(0,[])]
00:19:18 <mmorrow> (in this vacuum, only pointers show up)
00:19:23 <ski> , vacuum (const (Just False))
00:19:25 <lunabot>  [(0,[])]
00:19:28 <mmorrow> , vacuum (0,1)
00:19:31 <lunabot>  [(0,[1,2]),(1,[]),(2,[])]
00:19:58 <mmorrow> ski: yeah, it's unfortunate that you don't get the pointers to the values functions are partially applied to
00:20:04 <ski> , let f = const (Just False) in f () `seq` vacuum f
00:20:06 <lunabot>  [(0,[])]
00:20:21 <mmorrow> , closureType (const 0)
00:20:24 <lunabot>  AP
00:20:28 <mmorrow> , closureType $! (const 0)
00:20:31 <lunabot>  PAP
00:20:37 <mmorrow> , closureType $! (const 0 1)
00:20:40 <lunabot>  Constr
00:20:44 <mmorrow> , closureType $! 1
00:20:46 <lunabot>  Constr
00:20:50 <mmorrow> , closureType $! const
00:20:53 <lunabot>  Fun
00:21:00 * ski recalls Hat(?) writing functions as something like `\x -> case x of 0 -> 1; 1 -> 1; 2 -> 2; 3 -> 6; 4 -> 24; _ -> _'
00:21:43 <mmorrow> hmm, you mean it would sample them on some set of values?
00:22:11 <ski> well, it would show the observed results from already occured actual calls
00:22:18 <mmorrow> ahhh, i see
00:22:33 <ski> (in this case `observe fac 4')
00:23:32 <ski> (well, probably baking `observe' inside the recursion here ..)
00:23:53 <pikhq> Okay, so monads finally clicked.
00:24:02 <pikhq> Whoa.
00:24:10 <mmorrow> pikhq: nice!
00:24:17 <ski>   instance Monad Click
00:24:36 <pikhq> mmorrow: And to think, I only started on Monday.
00:25:00 <SubStack> yay, somebody already implemented KMP for Data.Sequence
00:25:03 <SubStack> if a bit obscurely
00:25:36 <ski> (pikhq : monads or haskell ? :)
00:25:44 <pikhq> ski: Haskell.
00:25:50 <ski> nice
00:26:11 <pikhq> And functional programming in general, aside from cursory looks at lambda calculus and SK combinatorial calculus.
00:26:16 <dbbddbdb> What's a KMP?
00:26:22 <ski> Knuth-Morris-Pratt
00:26:35 <EnglishGent> hi again! :)
00:26:47 <SubStack> it's so nice when people have already done what you're trying to do
00:27:05 <SubStack> originality is overrated
00:27:11 <EnglishGent> and so annoying when you find out *after* doing whatever it was you were trying to do! :)
00:27:21 <SubStack> indeed!
00:27:54 * EnglishGent just recently came across hoogle - which seems a good safety-net against that sort of thing :)
00:27:58 <ski> (dbbddbdb : your nick have any relation to bddbddb ?)
00:28:11 * pikhq has come to Haskell and discovered -- there is no state.
00:28:25 <FunctorSalad> hayoo seems to have more stuff ;)
00:28:45 <lament> how dare you! the state of haskell is eternal!! We have always been at war with the land of Lisp!
00:28:52 <FunctorSalad> btw someone integrate it into haskell-mode ;)
00:28:56 <SubStack> pikhq: it's anarchy!
00:29:09 * EnglishGent likes both Lisp & Haskell!
00:29:11 <EnglishGent> eep!
00:29:14 <EnglishGent> :)
00:29:23 <pikhq> lament: stateOfHaskell = war "Lisp"
00:29:24 <pikhq> ?
00:29:31 <SubStack> pacifists underminding the war effort! Seize them!
00:29:36 <pikhq> So, you bound war with Lisp to a name. Great.
00:29:45 <pikhq> Not state, though. >:D
00:31:04 <ski> Republic of Haskell - Side effects shall receive no mercy! <http://lisperati.com/landoflisp/f057.png>
00:31:23 <ski> (<http://lisperati.com/landoflisp/> for the start of that)
00:31:32 <FunctorSalad> shouldn't we be allied with other functional languages?
00:31:47 <EnglishGent> I would think so FunctorSalad!
00:31:52 <EnglishGent> down with C++ & Java!
00:31:58 <lament> that comic is seriously the best thing ever
00:32:02 <dbbddbdb> ski: It's equal to bddbddb actually
00:32:06 <mmorrow> yeah, that comic is great
00:32:14 <SubStack> FunctorSalad: you'd think the koreas would be united too
00:32:18 <SubStack> but there you go
00:32:20 <FunctorSalad> :o
00:32:30 <mmorrow> "Then i have... no choice!"
00:32:31 <ski> dbbddbdb : as in bddbddb: BDD-Based Deductive DataBase <http://bddbddb.sourceforge.net/> ?
00:32:40 <inimino> au contraire, we should take a leaf from the Lisp handbook and bicker amonst ourselves instead
00:32:51 <lament> GHC sucks!!!!
00:32:57 <EnglishGent> well we kinda do ... how many optional language extensions are there again?
00:33:09 <inimino> NO in dosent you noob
00:33:10 <lament> EnglishGent: somehow, they're all in the same implementation
00:33:11 <SubStack> Lisp has enough problems battling the breakaway republic of Arc
00:33:16 <EnglishGent> that was one thing that put me off Haskell for a long time
00:33:21 <FunctorSalad> language extensions aren't bickering imho
00:33:25 <dbbddbdb> ski: no, but it will mean 101 in binary too if you treat b as 1 and d as 0
00:33:37 <EnglishGent> a 'finished' language shouldnt need x thousand language extensions to make it useful
00:33:46 <lament> Haskell is not finished.
00:33:53 <ivanm> and never will be
00:33:55 <EnglishGent> and as someone with a Lisp background (macros) - that's really offputting
00:34:03 <inimino> Haskell is still alive and well as a research language
00:34:04 <lament> although it's probably getting to the end of its useful lifespan
00:34:08 <FunctorSalad> EnglishGent: the number of extensions is just a matter of how finely you grain them
00:34:10 <ivanm> Haskell is (was?) a _research_ language
00:34:12 <SubStack> writing in dead languages does not interest me
00:34:18 <ivanm> lament: :o
00:34:18 <EnglishGent> the idea of 'language extensions' to Lisp is an anathema
00:34:31 <FunctorSalad> EnglishGent: #include "MyBigBagOfExtensions.h" -- problem solved ;)
00:35:14 <ski> (EnglishGent : how about hygienic macro research ?)
00:35:15 <FunctorSalad> I went the opposite direction (from glasgow-exts to single extensions) actually so I know which is which...
00:35:41 <EnglishGent> fair point ski - but anything they come up with I can add using (defmacro)
00:35:52 <EnglishGent> in fact the only thing I've yet encountered I couldnt add - would be layout!
00:36:01 <EnglishGent> (which is a shame - as I like layout)
00:36:25 <lament> EnglishGent: create a hasp!
00:36:27 <ski> (EnglishGent : but `defmacro' doesn't solve one half of the problem hygienic macros solve ..)
00:36:35 <FunctorSalad> "hasp"... I like that
00:36:43 <EnglishGent> hasp?
00:36:51 <lament> a hasp is the opposite of a liskell.
00:36:52 <ski> lament : maybe you meant `Liskell' ?
00:36:57 <ski> oh
00:37:29 <EnglishGent> ski - I know - I'm saying I could if someone came up some ultimate-hygenic macro - I could implement (def-ultimate-hygenic-macro using def-macro)
00:37:47 <ski> i'm not convinced of that
00:37:57 <FunctorSalad> granting "mercy" to side effects would kinda defeat the whole point
00:38:07 <ski> (apart from writing a new lanaguage implementaion inside your lisp system, of course)
00:38:21 <EnglishGent> we do - sort of peformUnsafeIO anyone? :|
00:38:22 <ray> a hasp is a well-typed venomous snake
00:38:22 <FunctorSalad> (like being able to reason about code more easily)
00:39:05 <EnglishGent> I *do* like seperating the two - I write Lisp in almost purely functional style anyway
00:39:05 <ski> maybe a `hasp' should have an `unsafePerformPureComputation' ?
00:39:21 * EnglishGent doesnt like icky-side effects
00:39:31 <ski> (the unsafeness being that it might not have side-effects, i suppose)
00:39:40 <FunctorSalad> EnglishGent: ok, unsafePerformIO is a big discouragement though
00:39:49 <ray> because this language assumes everything has side-effects
00:39:51 <lament> ski: may be substituted by a no-op by an optimizing compiler?
00:40:02 <hackagebot> full-sessions 0.4.181 - yet another implementation of session types which does not require annotations (KeigoImai)
00:40:07 <ski> lament : well, it's supposed to return some value, of course
00:40:22 <EnglishGent> I would like some way of tracking what *kind* of side effects something has though
00:40:23 <lament> ski: well, it's always the same value, so you can just calculate it at compile time
00:40:27 <luqui> ray, isn't FORTRAN like that?
00:40:32 <FunctorSalad> EnglishGent: and people are told that stuff can malfunction if you use unsafePerformIO (the semantics of the program may then be changed by rewrite rules etc)
00:40:35 <EnglishGent> as technically calling the random-number generator has side-effects
00:40:42 <ray> i don't know what fortran's like, i'm pretty young
00:40:46 <ski> lament : not if it depends on user input ..
00:40:47 <EnglishGent> but that feels very different to me from (say) printing something on the screen
00:41:02 <ski> (also, consider infinite values)
00:41:08 <FunctorSalad> EnglishGent: agreed; there are monads for randomness already though
00:41:47 <luqui> there is a well-defined amount that you can calculate a program at compile-time (beta normal-form), and it's actually quite a lot.
00:41:47 <ray> the standard random functions take a RandomGen
00:41:50 <lament> ski: well that's why it's unsafe :)
00:41:53 <luqui> In fact the problem is more that it's too much than not enough.
00:42:34 <EnglishGent> dont worry ray - *real* programmers can write fortran in anything ;)
00:42:48 <ski> augustss even wrote BASIC in haskell
00:42:56 <luqui> that was frightening
00:43:02 <hackagebot> full-sessions 0.4.187 - yet another implementation of session types which does not require annotations (KeigoImai)
00:43:07 <ray> the cool thing about BASIC in haskell is the line numbers
00:43:16 <EnglishGent> http://www.pbm.com/~lindahl/mel.html
00:43:24 * EnglishGent wonders what Mel would have made of Haskell :)
00:43:32 <EnglishGent> BASIC in Haskell?
00:44:58 <ray> http://hackage.haskell.org/package/BASIC (i see hackage cleaned up their URLs)
00:45:03 <hackagebot> full-sessions 0.4.189 - yet another implementation of session types which does not require annotations (KeigoImai)
00:45:06 <FunctorSalad> hehe http://lisperati.com/fringedc.html
00:48:12 <EnglishGent> btw.. a hoogle / hayoo question - is there a way to search for functions that take some parameter & return some other parameter *without* having to specify all of the parameters? e.g something like a -> ... -> z
00:48:32 <EnglishGent> would match functions of type signatures a -> b -> z, a -> b -> c ->z, etc
00:48:36 <EnglishGent> ? :)
00:48:41 <ray> you might get that searching for a -> z
00:48:44 <ski> @hoogle (a -> r -> r) -> [a] -> r
00:48:45 <lambdabot> Prelude foldr :: (a -> b -> b) -> b -> [a] -> b
00:48:45 <lambdabot> Data.List foldr :: (a -> b -> b) -> b -> [a] -> b
00:48:45 <lambdabot> Prelude foldl1 :: (a -> a -> a) -> [a] -> a
00:48:48 <Peaker> EnglishGent: Hoogle matches functions that have extra parameters
00:48:58 <EnglishGent> you dont - I tried it
00:49:05 <ski> @hoogle (a -> r -> b -> r) -> [a] -> r
00:49:06 <lambdabot> Prelude zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
00:49:06 <lambdabot> Data.List zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
00:49:06 <lambdabot> Control.Applicative liftA3 :: Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
00:49:19 <Peaker> @hoogle Time -> String
00:49:20 <lambdabot> Warning: Unknown type Time
00:49:20 <lambdabot> Distribution.Text display :: Text a => a -> String
00:49:20 <lambdabot> Prelude show :: Show a => a -> String
00:49:21 <EnglishGent> I asked hoogle to show me x -> IO z & x -> y -> IO z
00:49:32 <EnglishGent> and got different hits with the 2nd one
00:49:47 <Peaker> EnglishGent: the latter should be a subset of the former?
00:50:22 <EnglishGent> I agree Peaker - but there's no limit then is there? I could ask for w -> x -> y -> IO z
00:50:33 <luqui> hoogle is a search engine.  it uses some heuristics to determine which functions you'll probably be interested in.
00:50:33 <EnglishGent> hence my question - can I search for ... -> IO z
00:51:03 <luqui> anyway no.  fortunately most functions have few parameters.
00:51:17 <Peaker> @hoogle a -> IO b
00:51:18 <lambdabot> Control.Exception evaluate :: a -> IO a
00:51:18 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
00:51:18 <lambdabot> Control.Exception throwIO :: Exception -> IO a
00:51:29 <Peaker> EnglishGent: note "a" here matched something like Exception, too
00:51:46 <EnglishGent> ah
00:51:53 <EnglishGent> hadnt thought of that
00:52:18 * EnglishGent makes mental note - ty Peaker :)
00:53:29 <EnglishGent> I can think of all sorts of things I'd *like* to be able to do - I'd like to be able to ignore parameter order in many cases as well - in effect say 'I have values of *these* types - I want a result of *that* type - what functions might do the job?
00:53:45 <EnglishGent> so that nth :: Int -> [a] -> a
00:53:54 <EnglishGent> and elt :: [a] -> Int -> a
00:54:05 <EnglishGent> could both be found with the same search
00:54:26 * EnglishGent is thinking way too much about this! :)
00:55:06 <ski> why ?
00:55:37 <EnglishGent> why what?
00:55:41 * EnglishGent not sure!
00:56:30 <ski> (why you're thinking you're thinking too much about that)
00:56:46 <luqui> EnglishGent, parameter order is ignored, IIRC
00:57:14 <EnglishGent> becuase of the whole 'why do what someone else has done' question
00:57:27 <EnglishGent> often I know what my inputs are going to be & what I want as the output
00:57:45 <EnglishGent> and I want to know if a function already exists that will do the job, or if I'm going to have to write it
00:58:03 <luqui> i think it'd be fun to try to do a proof search on the libraries; eg. exactly what you said, but considering combinations of functions
00:58:19 <EnglishGent> after all - if one already exists I dont mind providing it with the arguments in the order it expects
00:58:35 <luqui> though i don't think it could tractably be a useful tool
00:59:00 <luqui> @hoogle [a] -> Int -> [a]
00:59:01 <lambdabot> Prelude drop :: Int -> [a] -> [a]
00:59:01 <lambdabot> Prelude take :: Int -> [a] -> [a]
00:59:01 <lambdabot> Data.List drop :: Int -> [a] -> [a]
00:59:05 <luqui> tada!
00:59:33 <EnglishGent> oh - and why I'm thinking too much about it? because I've been become borderline obsessed over the quality of the languages / development tools I have to work with
00:59:53 <EnglishGent> I'm *hoping* to do a Phd (accepted - subject only to problem of finding funding now)
01:00:06 <luqui> EnglishGent, what's your topic?
01:00:19 <EnglishGent> but I've been a professional programmer in industry for a long time -- using Java & VB (sorry about the bad language)
01:00:32 <EnglishGent> and ick! I use Lisp (& increasingly Haskell) at home
01:00:57 <luqui> taptap.  is this thing on?
01:01:32 <EnglishGent> luqui - my supervisor is interested in how humans go about acquiring expertise in subjects
01:02:04 <EnglishGent> and has a formal congnitive model (CHREST) that has been used to (for example) make empiricial predictions about people's learning profiles when learning chess
01:02:38 <SubStack> delicious predictive models
01:02:38 <EnglishGent> I'm going to wind up working on CHREST in some capacity - I'd *like* to look at extending to model people's learning when learning computer languages
01:02:45 * SubStack is working on a very generalized one of those
01:02:46 <luqui> wow.  interesting, ambitious.
01:03:15 <EnglishGent> so that we develop better ideas about what's cognitively 'natural'
01:03:36 <EnglishGent> for example - it's noticable that practically every language (including Haskell I'm afraid) gets 'case' backwards
01:03:56 <EnglishGent> studies show people prefer the default case to be at the top, with the specialisations below it
01:04:10 <ski> strange
01:04:10 <EnglishGent> i.e. you empirically get less bugs from learners if you have it work that way
01:04:31 <EnglishGent> probably becuase people think of the default first & then the exceptions ski
01:04:58 <SubStack> does that also work for elses and ifs?
01:05:03 <ski> but then you must check every exception (is reading in order), to get accuracy
01:05:05 <EnglishGent> at least - westerners do (my research buget doesnt stretch to flying people in from China, or else where)
01:05:12 <ski> (s/is/if/)
01:05:53 <EnglishGent> doesnt seem to SubStack - but then that isnt a case expression as such - we're much more explicit about it '*if* <test> *then* <result> *else* <result2>'
01:06:08 <EnglishGent> anyway ski - the interesting thing is that the effect is there
01:06:23 <EnglishGent> with luck we will be able to use said results to help improve computer languages
01:06:34 <ski> (EnglishGent : it would be interesting to get results on various groups of people, like "artists", "people with aspergers", et.c.)
01:06:34 <EnglishGent> by making them better fit the way people seem to think :)
01:06:40 <EnglishGent> agreed ski!
01:06:41 <EnglishGent> :)
01:08:02 <EnglishGent> if anyone wants to discuss this with me I'd be more than happy to do so anytime!
01:08:11 <EnglishGent> all ideas gratefully recieved! :D
01:08:18 <ski> (i suppose testing various computer professionals would be hard, since they'd already be accustomed to how `case' is usually done in current languages)
01:08:35 <EnglishGent> yeah - we're trying to find people with no preconceptions ski
01:08:43 <ski> *nod*
01:08:50 <EnglishGent> otherwise I think you'd find the results seriously distorted
01:08:56 * ski recalls an AI memo ..
01:09:06 <EnglishGent> I'm interested in getting more people into programming - ideally children
01:09:19 <EnglishGent> so I want to be able to design very friendly languages
01:09:29 <SubStack> I wish I'd heard about functional languages sooner
01:09:44 <EnglishGent> and I'd *like* to be able to keep all the goodness from the functional approach as well
01:09:58 <SubStack> I remember being completely put off by the abomination that is C++ programming on Windows
01:10:07 * FunctorSalad just read the whole comic here... http://lisperati.com/landoflisp/
01:10:10 * EnglishGent has so far taught a whole bunch of kids from about 12 - early teens Scheme as their first language
01:10:27 <EnglishGent> DrScheme has many features that make it easier to teach
01:10:36 <EnglishGent> like 'language levels' & teachpacks & so on
01:10:38 <SubStack> scheme is pretty neat
01:10:59 <EnglishGent> I agree SubStack - as I've said I like both Scheme & Haskell
01:11:01 <EnglishGent> :)
01:11:17 * SubStack learned javascript first of all things
01:11:23 * SubStack isn't very old
01:11:42 <EnglishGent> well I learned BASIC first... on a machine with 48K of Ram(!) (that was a lot of Ram!)
01:11:48 <EnglishGent> and then assembler... and then forth
01:11:51 <SubStack> quite a lot!
01:11:52 <EnglishGent> and then lisp & prolog
01:11:54 <EnglishGent> :)
01:12:07 <ski> (which machine ?)
01:12:13 <EnglishGent> ZX spectrum :)
01:12:17 <ski> ok
01:12:28 * ski played with a C64
01:12:49 <EnglishGent> it worries me that modern machines have taken a lot of the fun out of computing
01:12:59 <SubStack> I disagree
01:13:03 <EnglishGent> you could pick up one of the 8 bits & actually program it as child
01:13:14 <SubStack> computing is so much more accessible
01:13:20 <SubStack> and the tools are so much nicer
01:13:22 <EnglishGent> modern development enviroments seem to be targetted mostly at C++ / Java
01:13:33 <EnglishGent> *computing* is SubStack - but programming (in my opinion) isnt
01:13:33 <SubStack> the trick is not to use those
01:14:06 * SubStack uses vim and shells all day
01:14:09 <EnglishGent> certainly the enviroments most kids are likely to encounter are far less friendly to the beginning programmer than the ones I started on
01:14:20 <EnglishGent> and whilst DrScheme (for example) or Logo might be much nicer
01:14:26 <EnglishGent> the chances are they wont even have heard of them
01:14:31 <EnglishGent> much less used them :|
01:14:49 * EnglishGent uses Emacs
01:14:52 <SubStack> the biggest problem beginning programmers face is Windows
01:14:58 * EnglishGent declaresd holy war on SubStack ;)
01:15:02 <EnglishGent> I agree SubStack
01:15:03 <SubStack> as soon as they ditch that, it's smooth sailing
01:15:10 <SubStack> at least that was my experience
01:15:48 <EnglishGent> ok - more rl stuff to do .. see everyone a bit later :)
01:15:50 <SubStack> any crazy tool or library you hear about is only an apt-get install or a ./configure && make && sudo make install away
01:16:22 <SubStack> real life!
01:16:23 <SubStack> imagine!
01:17:22 <SubStack> real life is too non-deterministic for my tastes
01:17:35 <ivanm> SubStack: or a <insert distro's package manager here> away!
01:17:50 <SubStack> yep
01:18:13 <SubStack> but Debian's repos are the biggest ;)
01:18:49 <ivanm> SubStack: that's open to debate
01:18:59 <ivanm> depending on how you count them, it's either debian's or gentoo's
01:19:17 <ivanm> (IIRC)
01:19:27 <Cale> If you're talking about Haskell development though..
01:19:33 <Cale> Arch?
01:19:36 <ivanm> then it's arch, followed by Gentoo I think
01:19:44 <SubStack> http://en.wikipedia.org/wiki/Comparison_of_Linux_distributions#Package_management_and_installation
01:19:56 <ivanm> and Arch only has a bigger one because here for Gentoo we try to test, etc. all our packages for each version that we have
01:20:00 <SubStack> ubuntu is estimated to have the most I guess
01:20:02 <ivanm> we have some _old_ packages
01:20:10 <FunctorSalad> that lisperati comic is some serious fud :|
01:20:15 <SubStack> they must add a few
01:20:20 <ivanm> e.g. we still have ghc 6.2 available :s
01:20:30 <ski> FunctorSalad : yes, but it's fun fud :)
01:20:31 <FunctorSalad> (yes yes I know it's an "april fools joke")
01:20:58 <ivanm> SubStack: I wonder how many of them are version-specific
01:21:18 <ivanm> and how many of them are just ubuntu (i.e. not just taking debian's)
01:21:44 <ivanm> besides, number of packages for binary distros is usually inflated due to them splitting packages up (-devel, -libs, etc.)
01:22:09 <SubStack> highly likely
01:27:11 <ac> how do I turn a String in to a ByteString?
01:27:59 <ivanm> ac: pack
01:28:06 <ac> I'd expect pack to work, but that fails with can't convert Char to Word8
01:28:10 <ivanm> @hoogle String -> ByteString
01:28:11 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
01:28:11 <lambdabot> Data.ByteString.Lazy.Char8 pack :: [Char] -> ByteString
01:28:11 <lambdabot> Prelude read :: Read a => String -> a
01:28:12 <ivanm> ac: oh, yeah
01:28:23 <ivanm> I've only used the Char8 versions :s
01:29:44 <Cale> ac: Yeah, watch which modules you're importing :)  If you need one form or another of unicode encoding, there are also packages on Hackage for that.
01:31:44 <ivanm> Cale: how _do_ you use normal ByteString then if you have to do operations to/from String ?
01:32:35 <ac> I'm having a hard time understanding the types used in happstack
01:32:38 <Cale> You mean to manipulate bits of UTF-8-encoded text?
01:33:12 <ivanm> is it utf8?
01:33:25 <Cale> Well, depends on which encoding library you choose...
01:33:51 <ivanm> Cale: default bytestring... or do char8/utf8/etc. provide "interfaces" to ByteString?
01:34:06 <ivanm> i.e. they do all the [Word] <-> String stuff using different encodings for you?
01:34:27 <Cale> The Char8 versions just clip the Char values to 8 bits which is poor, but yeah, they just provide an interface to the Lazy/Strict bytestrings.
01:34:34 <Cale> yeah
01:34:42 <ivanm> ahhh
01:34:46 <ivanm> that makes more sense then
01:35:25 <ivanm> so are the actual ByteString types all the same then, just re-exported in all the other modules?
01:35:36 <ivanm> (well, are the lazy and strict ByteString types all the same)
01:41:21 <Le-Chuck_ITA> Hi there, I am looking for a biased opinion :)
01:41:51 <Le-Chuck_ITA> I am a long-term ocaml and haskell user, and want to write a filesystem. I did a prototype 4 years ago but had to re-implement ocamlfuse. I never had time to maintain it so it was a suicide
01:42:20 <Le-Chuck_ITA> Yesterday I finally decided to try with python but at end of the day it occured to me that it handles threads like MS-DOS did!
01:43:03 <Le-Chuck_ITA> Now the question is: I recall that ocaml had fake threads that did not support multiple cores, and that haskell was the winner in the realm of threads. Is it still the case?
01:44:34 <mmorrow> Le-Chuck_ITA: definitely
01:44:42 <mmorrow> more so than ever, also
01:44:49 <Le-Chuck_ITA> mmorrow: is this biased?
01:44:59 <mmorrow> Le-Chuck_ITA: have you seen the halfs code?
01:45:11 <Le-Chuck_ITA> ahem, seen but not looked at
01:45:13 <Le-Chuck_ITA> why?
01:45:15 <mmorrow> Le-Chuck_ITA: biased how?
01:45:26 <Le-Chuck_ITA> mmorrow: no I am kidding, I came here for a biased opinion
01:45:31 <Le-Chuck_ITA> I am biased in turn
01:45:45 <Le-Chuck_ITA> why do you ask me about the code
01:45:51 <fasta> OCaml doesn't have multi-core GC, but otherwise it was the same AFAIK. Then again, I am not an expert OCaml user.
01:45:54 <mmorrow> (i ask because it seems like it's relevant to the filesys stuff, although i'm not sure if it's relevant wrt parallelism)
01:46:34 <Le-Chuck_ITA> hmm, in what sense it's relevant? Being truly concurrent is important for a filesystem because it must be responsive even if one operation fails.
01:46:39 <Le-Chuck_ITA> fails=delays
01:47:01 <mmorrow> Le-Chuck_ITA: you might find this a good read http://research.microsoft.com/en-us/um/people/simonpj/papers/parallel/multicore-ghc.pdf
01:47:29 <fasta> Le-Chuck_ITA: isn't OCaml truly concurrent in the exact same way as Haskell is?
01:47:33 <koala_man> will the fs delay for any other reason than waiting for the device?
01:47:45 <Le-Chuck_ITA> fasta not quite, it does not use multiple cores :)
01:47:53 <Le-Chuck_ITA> fasta: there are also other problems.
01:48:10 <Le-Chuck_ITA> fasta: e.g. when calling ocaml from the C fuse code, you can't create threads there
01:48:13 <fasta> Le-Chuck_ITA: you are saying that there are no OS level threads in OCaml?
01:48:17 <mmorrow> Le-Chuck_ITA: not relevant in the sense that i'm not sure the extent to which the halfs code, being written some years ago, uses the concurrency features of the ghc rts, and even if it does, it may not to the extent that it might now since things have improved :)
01:48:17 <Le-Chuck_ITA> you have to create threads in ocaml
01:48:18 <hackagebot> hfann 0.2 - Haskell binding to the FANN library (OlivierBoudry)
01:48:40 <Le-Chuck_ITA> mmorrow: aha, thank you.
01:48:44 <Le-Chuck_ITA> I will check
01:48:47 <fasta> Le-Chuck_ITA: you have to do the same in Haskell. There are some combinators now, but I haven't seen a real-world speedup from them.
01:49:40 <mmorrow> Le-Chuck_ITA: i think you'd find that paper link very relevant to this too
01:49:40 <Le-Chuck_ITA> the problem with creating threads in ocaml-land is that then these threads have to call back C to do some work e.g. decoding parameters, and then .... back to ocaml. An unmanageable complexity.
01:50:02 <Cale> ivanm: oh, yes.
01:50:10 <Le-Chuck_ITA> mmorrow: but are you also implicitly stating that the hfuse bindings are not so actively maintained?
01:50:34 <mmorrow> Le-Chuck_ITA: it's possible with ghc to call out to C code, which can call back in, without blocking everything
01:50:44 <Cale> ivanm: Though the text package on Hackage provides another type.
01:50:56 <fasta> Also, why would you want to write another file system?
01:50:57 <mmorrow> Le-Chuck_ITA: i don't believe they are, although i'm not sure (?)
01:51:40 <mmorrow> err, did i     say hfuse? i meant halfs
01:51:42 <mmorrow> http://haskell.org/halfs/
01:51:47 <Le-Chuck_ITA> fasta: personal reasons :) I wrote "relfs" some years ago and still I have not found anything that addresses its goals. But relfs is unfinished, and working on it is a pain because *my* fuse bindings are completely outdated
01:51:55 <Le-Chuck_ITA> mmorrow: halfs is just a filesystem
01:52:17 <Le-Chuck_ITA> fasta: I want a filesystem that manages my data for me
01:52:40 <mmorrow> ah, i see.
01:52:42 <fasta> Le-Chuck_ITA: oh, that abstract looks sort of interesting, yes.
01:54:14 <mmorrow> Le-Chuck_ITA: oh, ok. so you're deciding whether to use haskell to write the filesystem and the bindings to FUSE?
01:54:23 <mmorrow> (emphasis on "and")
01:54:32 <Le-Chuck_ITA> no I already did that mistake with ocaml
01:54:55 <Le-Chuck_ITA> I need a prototyping language with fuse bindings which are either actively maintained or easy to maintian
01:54:59 <fasta> So, you are looking for perfect bindings in NOTC to FUSE?
01:55:02 <mmorrow> ah
01:55:10 <Le-Chuck_ITA> fasta that's the real question :)
01:55:14 <Le-Chuck_ITA> good spot
01:55:38 * SubStack made a fuse module in perl one time
01:55:48 <Le-Chuck_ITA> python was perfect because it has that good-looking CAPI and there are bindings which are a single-easy readable file
01:56:00 <mmorrow> Le-Chuck_ITA: the hfuse pkg seems to be maintained (i thought we were talking about halfs when i said unmaintained)
01:56:05 <SubStack> I'll have to check out hfuse
01:56:07 <Le-Chuck_ITA> SubStack: I tried python yesterday won't do perl today :)
01:56:23 <fasta> I don't think writing a binding to C code is that hard. The first steps are hard, because it is unfamiliar, but on Hackage there are so much examples available, that you can just bind stuff as you need API calls.
01:56:26 <mmorrow> haskell's ffi is second to none
01:56:28 <Le-Chuck_ITA> mmorrow: I am more or less sold, will do some tests
01:56:34 <mmorrow> cool
01:56:39 <mux_> Le-Chuck_ITA: you're not a man until you have written Perl bindings with XS :-)
01:56:43 <Le-Chuck_ITA> mmorrow: and ocaml's ffi is second
01:56:46 <Le-Chuck_ITA> to everything :)
01:56:48 <fasta> mmorrow: Isn't the Chicken FFI better?
01:57:05 <fasta> Anyway, I think the Haskell FFI can be improved in a lot of ways.
01:57:06 <mmorrow> fasta: perhaps, i just like making sweeping statements ;)
01:57:15 <mmorrow> fasta: i think so too
01:57:21 <fasta> It's really the lowest thing which can work, which the Haskell FFI is.
01:57:27 <Le-Chuck_ITA> mmorrow: is the haskell ffi easy if you just want to manage strings and integers?
01:57:34 <fasta> That's even in the design specs, IIRC.
01:57:39 * mmorrow googles for an overview of the chiiickeeeen ffi
01:57:43 <mmorrow> gah, sticky keys
01:57:44 <Le-Chuck_ITA> I mean: do you know by sight the ocaml one?
01:57:57 * Le-Chuck_ITA does not want to know about the sticky keys
01:58:21 <mmorrow> Le-Chuck_ITA: heh
02:00:03 * EnglishGent returns with a tea :)
02:00:27 <Le-Chuck_ITA> when I read http://hackage.haskell.org/packages/archive/HFuse/0.2.1/doc/html/System-Fuse.html how can I tell if the library is distributed with GHC?
02:00:30 <ski> (hmm .. tea)
02:00:47 * EnglishGent offers ski a tea :)
02:01:02 <EnglishGent> hi Le-Chuck_ITA :)
02:01:15 <sjanssen> Le-Chuck_ITA: it isn't
02:01:24 * ski inquires about the sort of tea
02:01:26 <Le-Chuck_ITA> Coming to IRC is a good way :)
02:01:46 <portnov> is there any `what's new in ghc's git' changelog/review?
02:01:47 <sjanssen> Le-Chuck_ITA: http://www.haskell.org/ghc/docs/latest/html/libraries/index.html has a list of libraries that are sometimes distributed with GHC
02:02:51 <mmorrow> Le-Chuck_ITA: "is the haskell ffi easy if you just want to manage strings and integers?"
02:02:55 <mmorrow> yes, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6236#a6236
02:03:13 <Le-Chuck_ITA> mmorrow: lovely
02:03:17 <Le-Chuck_ITA> I won't post the ocaml
02:03:18 <Le-Chuck_ITA> :)
02:03:22 <mmorrow> hehe
02:05:40 <mmorrow> Le-Chuck_ITA: you can also write a [Word8] to a malloced buffer then call it for kicks http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1360 ;)
02:06:50 <Le-Chuck_ITA> mmorrow: that's crazy!
02:07:03 <Le-Chuck_ITA> I suppose you can dynamic-compile haskell too, at this point
02:07:39 <mmorrow> Le-Chuck_ITA: ooh, yeah we've got one runtime assembler, but it's x86-only
02:08:02 <mmorrow> http://uebb.cs.tu-berlin.de/harpy/
02:08:20 <mmorrow> the "slightly larger tutorial" is pretty neat
02:14:19 <Le-Chuck_ITA> mmorrow: let's change topic a bit: a question I always had is that GHC is a compiler obtained by partial evaluation of the interpreter. Good.
02:14:20 <Le-Chuck_ITA> but then
02:14:29 <Le-Chuck_ITA> do we have a partial-evaluation library in haskell and if not why not?
02:14:32 <Le-Chuck_ITA> we have it in the compiler!
02:15:18 <cjs> Le-Chuck_ITA: I've extended morrow's example with a somewhat larger one that shows how to deal with pointers to structs that are passed to C code to be filled in.
02:16:22 <quicksilver> Le-Chuck_ITA: the compiler is operating at the level of source code.
02:16:24 <Le-Chuck_ITA> cjs: but save these examples! in a wiki or something
02:16:35 <Le-Chuck_ITA> I see you are very good teachers, thank you!
02:16:36 <quicksilver> Le-Chuck_ITA: that wouldn't yield a library which worked on live haskell data
02:16:43 <quicksilver> it would yield a library which worked on source code.
02:16:52 <cjs> Le-Chuck_ITA: It's already saved in my project. :-) It's production code.
02:16:57 <Le-Chuck_ITA> quicksilver: at the level of the source code, that's nice.
02:17:04 <quicksilver> Having said that I don't know how meaningful it is to describe GHC as a compiler obtained by partial evaluation of the interpreter.
02:17:15 <Le-Chuck_ITA> quicksilver: so if I want to experiment with partial evaluation I could use such a library
02:17:19 <mmorrow> hmm, well not really a completely-automated lib, but there's no reason one couldn't be written. There's template-haskell which lets you have functions which take some quoted haskell code (and possibly other arbitrary values) as args, and return more quoted haskell code that you can splice into an expression/type/module-top-level.
02:17:21 <quicksilver> GHC is a fairly conventional multipass compiler going through various backend stages
02:17:35 <quicksilver> Core / C-- / native code generation
02:17:42 <quicksilver> I think it's pretty unrelated to its interpreter
02:17:43 <mmorrow> so that could be used for partial eval, specialization, unrolling, autogen of instances given specific data, etc
02:17:46 <quicksilver> which uses a bytecode.
02:17:49 <cjs> We really do need on-the-fly compilation in yi.
02:18:29 <Le-Chuck_ITA> quicksilver: I recall it was advertised as a futamura projection, maybe things changed since then?
02:18:43 <fasta> Le-Chuck_ITA: you are probably confused with something else.
02:18:47 <Le-Chuck_ITA> hmm
02:18:51 <luqui> Le-Chuck_ITA, GHC?  no way
02:18:53 <mmorrow> Le-Chuck_ITA: i recently used TH to experiment with fully unrolling some fft code (list as input), and the fully unrolled version vs. not ended up like
02:19:03 <fasta> Le-Chuck_ITA: GHC is not a real optimizing compiler, AFAIK.
02:19:23 <mmorrow> 10,000 size-128 vectors===> original 4 seconds,  unrolled 0.8 seconds
02:19:25 <mmorrow> http://moonpatio.com/repos/hsfft/
02:19:37 <Le-Chuck_ITA> come on but there *was* an haskell compiler obtained by partial evaluation
02:19:41 <mmorrow> so i think there's a lot of potential in this kind of thing
02:20:31 <mmorrow> (http://moonpatio.com/repos/hsfft/fft_upto_128.hs  being the generated code)
02:21:06 <quicksilver> supero is related to futamura projections
02:21:11 <quicksilver> however supero is research-ware
02:21:16 <quicksilver> it's not a real usable compiler.
02:21:21 <cjs> Hm. I seem to be able to cause the GHC runtime to wedge.
02:21:27 <mmorrow> (and the non-unrolled being: http://hackage.haskell.org/packages/archive/pure-fft/0.2.0/doc/html/src/Numeric-FFT.html )
02:21:28 <cjs> It's not supposed to do that, is it?
02:22:04 <quicksilver> cjs: if you get it caught in a tight loop which doesn't allocate memory, it will
02:22:20 <quicksilver> the GC / deadlock detector / thread switcher only cuts in at memory allocations.
02:22:24 <cjs> Even with -threaded and +RTS -N15 -RTS?
02:24:05 <quicksilver> well its' slightly harder to catch all 15 threads into tight loops
02:24:09 <quicksilver> but I suppose it's possible ;)
02:24:11 <cjs> I would think that if you've got things on separate OS threads, a tight loop on one wouldn't kill it. But anyway, I'm not looping; I've got about a dozen threads waiting on channels and sockets.
02:26:49 <cjs> Basically, for each socket I've got a reader, which reads from its socket and writes to a common "read message" channel, and a writer, which reads from its individual "write message" channel and writes to the socket. A processor thread reads from the readers channel, logs the message (via sending a message down a channel to the logging thread) and that's it.
02:27:04 <cjs> I added a heartbeat thread, too, which just sends a regular message to the logger.
02:29:13 <cjs> Now, it all works fine, until I have the reader send, as well as the message itself, the channel to the writer for the socket. When I do that, the system wedges just after a writer receives a message (from yet another thread, which just sends one message as  a test, and was in the other version too). Even the heartbeat stops working, though it's nothing to do with any of the readers/writers/processor.
02:29:34 <cjs> I'm trying to figure out whether I'm doing something dumb, or this is a bug.
02:32:55 <cjs> Ah, wait, no, maybe it wedges when the connections are closed by the remote end.
02:38:30 <mmorrow> cjs: Chan apparently blocks on a `isEmptyChan' call if there's currently another thread blocked on a readChan call
02:38:46 <mmorrow> not sure if this is what's happening here, but i was surprised to learn this
02:39:05 * mmorrow has started using his own Chan variant because of this
02:39:44 <mux_> that sounds like a bug to me, given that isEmptyChan is supposed to be useful for not blocking
02:40:09 <mmorrow> yeah, and the unfortunate thing is that that behavior is an artifact of the implem
02:40:26 <mmorrow> so the only way to fix it is to reimplement Chan differently
02:40:32 <mmorrow> (as far as i can see)
02:41:14 <mmorrow> (this is my solution http://moonpatio.com/repos/vacuum/src/GHC/Vacuum/Q.hs)
02:42:59 <mmorrow> mux, cjs: here's a minimal example of this http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6239
02:43:18 <mux_> mmorrow: can you reproduce this outside GHCi?
02:43:24 * mmorrow tries
02:43:41 <mux_> AFAIK, there are some particularities to consider with GHCi and threaded code
02:44:03 <mmorrow> (although i don't see how it would be diff, since it blocks on account of the MVar structure of Chan's implem)
02:44:13 * mmorrow is trying though
02:44:22 <mux_> I've seen even weirder stuff :-P
02:44:24 <cjs> mmorrow: Hmmm!
02:44:32 <mux_> mmorrow: also, compile with -threaded
02:44:50 <cjs> mmorrow: But of course, it must, if you look at how Chans are implemented.
02:45:02 <mmorrow> the problem is that isEmptyChan does a withMVar on the same MVar readChan is blocked on!
02:45:29 <mmorrow> cjs: exactly
02:46:05 <cjs> Well, I'm not using isEmptyChan, though.
02:46:31 <cjs> In fact, I'm not even touching the extra references to the channels that I'm slinging around. It's just now that more threads have references to them.
02:46:49 <nainaide> what is "mplus"  for ?
02:47:16 <cjs> > Nothing `mplus` Nothing
02:47:17 <lambdabot>   Nothing
02:47:17 <mmorrow> mux: omg you're right.
02:47:24 <cjs> > Nothing `mplus` Just 3
02:47:25 <lambdabot>   Just 3
02:47:29 <mmorrow> mux: how does this work?
02:47:31 <mux_> mmorrow: I am?
02:47:36 <mmorrow> mux_: i think
02:47:37 <cjs> > Just 999 `mplus` Just 3
02:47:38 <lambdabot>   Just 999
02:47:47 <nainaide> Just 3 `mplus` Just 6
02:47:47 <ac> > [1, 2, 3] `mplus` [4, 5, 6]
02:47:49 <lambdabot>   [1,2,3,4,5,6]
02:47:49 <mux_> I have absolutely no idea,  but I've seen strange stuff like this before, which is why I suggested you try with GHC too
02:47:51 <opqdonut> hmm, we should have a postfix ? as the Mqybe type constructor
02:48:02 <Cale> what?
02:48:05 <opqdonut> to complement the proposed anonymous bariants
02:48:07 <mmorrow> hmm, maybe the forkIO didn't have enough time to fork and then try to read the Chan
02:48:13 * mmorrow puts in a threadDelay
02:48:27 <cjs> Has someone filed a ticket for that, by the way?
02:48:27 <nainaide> how to understand Just 999 `mplus` Just 3 ?
02:48:27 <RayNbow> > let (?) = Just in   (3?)
02:48:28 * Cale missed the beginning of the mux/mmorrow thread :)
02:48:29 <lambdabot>   Just 3
02:48:57 <RayNbow> oh wait... type constructor
02:49:20 <RayNbow> (not value constructor)
02:49:35 <mmorrow> mux_: ah, yeah the forkIO didn't have enough time the first go
02:49:37 <mmorrow> Chan: thread blocked indefinitely
02:49:44 <ac> nainaide: mplus is part of the MonadPlus class that simply has a reasonable definition for every instance of MonadPlus
02:49:51 <ac> :i mplus
02:50:13 <ac> (darn, lambdabot doesn't respond to :i)
02:50:16 <Cale> Oh, you're talking about the brokenness of Chan?
02:50:40 <luqui> nainaide, mplus on Maybe uses the leftmost "Just"
02:50:43 <Cale> You can get around the problem by using a thin-wrapper around TChan, since it doesn't have that issue.
02:50:47 <mmorrow> mux_, cjs: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6239#a6240
02:51:08 <mmorrow> Cale: or use a diff Chan implem
02:51:14 <Cale> Well, yes :)
02:51:17 <mmorrow> (if you don't want to use STM)
02:51:18 <luqui> > (Just x `mplus` Just y, Just x `mplus` Nothing, Nothing `mplus` Just x, Nothing `mplus` Nothing)
02:51:19 <lambdabot>   (Just x,Just x,Just x,Nothing)
02:51:20 <mux_> mmorrow: still sounds like a bug then, it shouldn't block whether or not the other thread has the time to run
02:51:37 <nainaide> luqui, I read the defination about mplus , but dont understand why should we have it.
02:51:43 <Cale> I think it should be considered a bug that isEmptyChan could ever block.
02:51:48 <mmorrow> mux_: check out the Chan code, in par..errr, i'll just paste the relevant 3 lines
02:52:00 <mux_> Cale: exactly
02:52:05 <Cale> (at least for any significant amount of time)
02:52:10 <luqui> nainaide, you mean why such a function is useful, or why it should be a class?
02:52:29 <nainaide> luqui, why such a function is useful?
02:52:37 <RayNbow> > getLast $ Data.Foldable.foldMap Last [Just 3, Nothing, Just 5]
02:52:39 <lambdabot>   Just 5
02:52:46 <nainaide> just 6 `mplus` just 5
02:53:01 <FliP^2eH> How could I bringt down a line like THIS:
02:53:02 <FliP^2eH> "VERSION":_ -> ctcpReply ni "VERSION" $ "Project " ++ emp projectName ++ " " ++ emp ('v':projectVersion) ++ " " ++ emp projectStage ++ ", compiled " ++ emp (__DATE__) ++ ", " ++ emp(__TIME__)
02:53:07 <FliP^2eH> to 80 characters?
02:53:08 <Cale> nainaide: It generalises a lot of operations in various monads where you want to combine possibilities from various sources.
02:53:14 <FliP^2eH> Without making it look like it's been eaten?
02:53:19 <nainaide> Just 5 `mplus` Just 6
02:53:32 <Cale> nainaide: There are at least two "flavours" of it though, so it probably should be split into two functions.
02:53:32 <luqui> nainaide, let firstJust = foldr mplus Nothing in firstJust [Nothing, Nothing, Just 2, Nothing, Just 3]
02:53:35 <luqui> er
02:53:41 <luqui> > let firstJust = foldr mplus Nothing in firstJust [Nothing, Nothing, Just 2, Nothing, Just 3]
02:53:43 <lambdabot>   Just 2
02:53:46 <ac> nainaide: it allows you to write generic code that works for many different types
02:53:47 <mux_> :t msum
02:53:47 <Cale> > [1,2,3] `mplus` [4,5]
02:53:48 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
02:53:49 <lambdabot>   [1,2,3,4,5]
02:53:50 <FliP^2eH> Or generalizing: intelligent line wrapping
02:53:54 <mmorrow> mux_, cjs, Cale: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6239#a6241
02:54:04 <mux_> > msum [Nothing, Just 1, Just 3]
02:54:06 <lambdabot>   Just 1
02:54:30 <Cale> nainaide: For parsers, it is essentially the "OR" of the two parsers you apply it to.
02:54:49 <Cale> nainaide: For Maybe computations, it just picks the first Just value that it finds.
02:54:58 <Cale> nainaide: For lists, it's concatenation.
02:55:03 <nainaide> Cale, > [1,2,3] `mplus` [4,5] is good example , but why Just "a" `mplus` Just "b" only got Just a
02:55:05 <Cale> (combining lists of possibilities)
02:55:06 <FliP^2eH> > fmap (map (+)) [Just 5, Just 9]
02:55:07 <lambdabot>   Couldn't match expected type `[a]'
02:55:09 <mmorrow> mux_, cjs, Cale: and changing that isEmptyChan to not use withMVar isn't possible given that implem i believe
02:55:21 <Cale> nainaide: Because Maybe doesn't have any more capacity to store things than that.
02:55:30 <Cale> > Nothing `mplus` (Just 5)
02:55:32 <lambdabot>   Just 5
02:55:33 <FliP^2eH> > fmap (+) [Just 5, Just 9]
02:55:35 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe t))
02:55:35 <lambdabot>    arising from a use of...
02:55:35 <FliP^2eH> :(
02:55:39 <Cale> > (Just 5) `mplus` Nothing
02:55:41 <lambdabot>   Just 5
02:55:46 <Cale> > Nothing `mplus` Nothing
02:55:47 <lambdabot>   Nothing
02:55:49 <nainaide> Cale, understood!
02:55:50 <FliP^2eH> > fmap (+5) Just 5
02:55:51 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe a))
02:55:51 <lambdabot>    arising from the lite...
02:56:06 <FliP^2eH> > fmap (+5) (Just 5)
02:56:06 <FliP^2eH> :d
02:56:07 <lambdabot>   Just 10
02:56:12 <mmorrow> mux_, cjs, Cale: in particular, the root of the problem is that Chan uses /the same MVar/ for the head and the tail
02:56:16 <Cale> nainaide: But I think that the operation for Maybe should be called melse or something.
02:56:31 <Cale> nainaide: It satisfies different laws than the version for lists.
02:56:41 <Cale> also it would be nice for lists to have an operation:
02:56:46 <Cale> melse [] ys = ys
02:56:47 <FliP^2eH> > map (fmap (+5)) [(Just 5, Just 9]
02:56:48 <lambdabot>   <no location info>: parse error on input `]'
02:56:50 <ski> Cale : yes (or `mOrElse')
02:56:53 <Cale> melse xs _ = xs
02:56:53 <mmorrow> and Chan relies on this fact too
02:56:53 <nainaide> Cale, yes.
02:57:05 <FliP^2eH> > map (fmap (+5)) [(Just 5), (Just 9)]
02:57:06 <lambdabot>   [Just 10,Just 14]
02:57:12 <FliP^2eH> Yay
02:57:20 <ski> one can imagine an `mcond', too
02:57:27 <Cale> (So you pick only from the first list unless it is empty, in which case you pick from the second)
02:57:39 <Cale> mcond?
02:57:42 <ski>   mcond :: MonadCond m => m a -> (a -> m b) -> m b -> m b
02:58:11 <Cale> hmmm
02:58:23 <ski> if the first argument "has any solutions", use the `a -> m b' branch, otherwise the other `m b' branch
02:58:25 <RayNbow> FliP^2eH, http://dpaste.com/59522/ <-- it isn't 80 chars yet, but maybe something like this?
02:58:45 <FliP^2eH> :)
02:58:48 * ski defined such a `cond' for a logic programming monad
02:58:48 <mmorrow> mux_: yeah, definitely a bug imo
02:58:53 <FliP^2eH> Thanks RayNbow
02:59:23 <Cale> ski: ah, that's like the ifte in logict
02:59:26 <FliP^2eH> It's easy splitting a line of calculations, but harder splitting a line of string assembling without loosing the meaning of it
02:59:37 <RayNbow> > intercalate ", " ["foo", "bar"]
02:59:38 <lambdabot>   "foo, bar"
02:59:46 <ski> Cale : probably, yes (i've not looked much at `LogicT')
03:00:18 <Cale> > let foo xs = ifte xs (\x -> [x,x*10]) [4,5] in (foo [1,2,3], foo [])
03:00:20 <lambdabot>   ([1,10,2,20,3,30],[4,5])
03:00:33 <ski> @type ifte
03:00:34 <lambdabot> forall (m :: * -> *) a b. (MonadLogic m) => m a -> (a -> m b) -> m b -> m b
03:00:48 * ski nods
03:02:40 <cjs> So, anyway, this isEmptyChan thing is not an issue for me, but I'm trying to figure out what's going on with the runtime wedging. Using -vs indicates that the scheduler is indeed doing nothing.It worries me that two threads that have no connection with the writers-to-sockets (heartbeat, which sends a message to the logger every 250 ms., and logger, which reads its channel and writes the messages to disk) also stop working.
03:02:58 <FliP^2eH> @hpaste
03:02:58 <FliP^2eH> :|
03:02:58 <FliP^2eH> @hpaste
03:02:59 <lambdabot> Haskell pastebin: http://hpaste.org/new
03:02:59 <lambdabot> Haskell pastebin: http://hpaste.org/new
03:02:59 <FliP^2eH> :(
03:03:00 <FliP^2eH> Oh
03:03:17 <Cale> hehe, whoa, lots of messages all at once there
03:03:17 <cjs> Hm. I suppose I should remove all references to the logger channel from other threads and see if it still goes weird.
03:03:53 <FliP^2eH> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6242#a6242
03:03:55 <FliP^2eH> What do you say?
03:04:16 <Cale> FliP^2eH: the first of the two
03:04:27 <FliP^2eH> That keeps growing my lines :(
03:04:52 <Cale> er, oops
03:05:03 <Cale> Ignore my other option, I missed the presence of the 'let'
03:05:11 <cjs> Hm. In that case, it works. So maybe it is something related to mvars.
03:05:14 <FliP^2eH> I just noticed it does not work anywas
03:05:19 <Botje> FliP^2eH: use maybe :)
03:05:21 <FliP^2eH> Because of the let
03:05:27 <Botje> maybe server id $ lookup "SERVER" c
03:05:30 * Cale is still waiting for coffee to be absorbed by his system
03:05:49 <Botje> get some caffeine chewing gum instead
03:05:54 <Botje> acts in less than a minute :)
03:06:23 <FliP^2eH> Wow, thanks Botje
03:06:30 <FliP^2eH> Didn't know that function
03:06:46 <RayNbow> :t maybe
03:06:47 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
03:06:49 <Cale> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6242#a6244
03:07:37 <Cale> It's annoying that hpaste doesn't give any ability to edit posts directly
03:08:01 <Cale> maybe is to Maybe what foldr is to lists.
03:08:32 <RayNbow> Cale: you mean when you accidentally made a typo but you already hit the submit button?
03:08:37 <Cale> Yeah
03:08:54 <Cale> Or you realise after the fact that what you posted had an error.
03:09:15 <Cale> There's no option to delete or edit.
03:10:25 <quicksilver> cjs: sounds like your logger channel is in an inconsistent state
03:10:28 <Cale> I want to see a real application which uses the Control.Concurrent.CML library
03:10:35 <quicksilver> cjs: at least, that would explain what you are describing.
03:10:54 <cjs> Indeed. If I have the processor only not have a reference to the logger channel, it works, too.
03:11:02 <cjs> Sounds like my bug, not ghc's. :-)
03:11:03 <quicksilver> cjs: logger channel in inconsistent state would make the heartbeat block on writing *and* the logger reading.
03:11:28 <Cale> I feel like I don't really understand how that library is intended to be used in practice.
03:11:31 <quicksilver> if you only ever use readChan and writeChan you are safe.
03:11:38 <quicksilver> some of the other constructs are *not* safe
03:11:42 <quicksilver> isEmptyChan, for example.
03:11:51 <cjs> Though I'm not sure what an "inconsistent state" is on the logger channel. The logger thread does use isEmptyChan, but it's the only reader.
03:12:43 <quicksilver> inconsistent state is getting the mvars in a muddle
03:12:50 <quicksilver> violating the "invariants" of Chan
03:12:51 <cjs> However, I could take that out and see if it fixes the problem. (I use isEmptyChan only to flush the log to disk if the Chan is empty, before I block on it again with readChan.
03:13:22 <cjs> quicksilver: is it possible to do that when a Chan has no dups and only one thread reading it?
03:14:51 <quicksilver> I can't remember ;)
03:15:01 <quicksilver> I can only remember noticing that some of the chan primitives were unsafe
03:15:08 <cjs> No, even if I take out the call to isEmptyChan and have the logger thread use only readChan, it wedges.
03:16:31 <cjs> Oh, wait! I'm using not regular channels, but my closable channel! Now there's a prime potential source of bugs!
03:38:23 <idnar> is fmap for Maybe defined as a separate function?
03:38:50 <opqdonut> @src Maybe fmap
03:38:50 <lambdabot> fmap _ Nothing       = Nothing
03:38:50 <lambdabot> fmap f (Just a)      = Just (f a)
03:38:55 <idnar> @hoogle (a -> b) -> (Maybe a) -> (Maybe b)
03:38:55 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
03:38:55 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
03:38:55 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
03:39:11 <opqdonut> idnar: why do you want a specialized fmap?
03:39:42 <idnar> opqdonut: what I'm actually doing it is implementing the rough equivalent in Python, and I'm trying to come up with a name for it :P
03:39:49 <opqdonut> mapMaybe
03:39:54 <opqdonut> i'd say
03:44:26 <quicksilver> in java they call it ValueFactoryWithEmbeddableDefaultWithNoSpecificSemanticsFactoryMapper
03:44:38 <idnar> hahaha
03:45:22 <ivanm> quicksilver: shouldn't it have a couple of extra "Factory"s in it?
03:45:47 <quicksilver> ivanm: only in the enterprise edition
03:45:52 <fasta> In Forth they would just call it 'or'?  ;)
03:46:14 <fasta> Well, that's a bit of an oversimplification.
03:46:37 <ivanm> oh, OK
03:46:53 <adept> hi. are there any haskell teams for the upcoming icfpc willing to take another member?
03:47:27 <ivanm> adept: yes, but not you :p
03:47:29 <ivanm> j/k
03:47:45 <adept> ivanm: :-P
03:48:03 <ivanm> I was thinking about trying out the ICFP contest... but I've been lacking enough sleep the past couple of weeks, and it's a PITA when the problem comes out at 3 in the morning :s
03:48:03 <FliP^2eH> Every once in a while, I have the strong urge to purge my whole code and rewrite it from scratch
03:48:17 <FliP^2eH> And every time I do this, the code gets better..
03:48:18 <ivanm> FliP^2eH: if only M$ had that same urge...
03:48:19 <ivanm> ;-)
03:48:30 <FliP^2eH> :)
03:49:02 <FliP^2eH> M$ should start purging, seriously. They are loosing to ubuntu
03:49:08 <adept> ivanm: on the contrary. it means that when you are up and running your buddies in other time zones already wrote half the code and went to sleep, and now you are free to point them to their mistakes :)
03:49:16 <FliP^2eH> I once liked ubuntu, but it's gotten TOO popular :(
03:49:27 <ivanm> adept: heh
03:49:56 <fasta> MS Linux, now that would be something :)
03:50:05 <ivanm> well, I don't know of anyone who's doing it, and also I don't think my parents would be too pleased with me working on a contest all weekend long (yes, I still live with my parents... since I'm not employed full time, why not?)
03:50:07 <FliP^2eH> Look at Red Flag Linux
03:50:30 <ivanm> I had enough problems with helping out dibblego give his tutorial on #bpfg on sunday night... >_>
03:50:42 <FliP^2eH> fasta: http://upload.wikimedia.org/wikipedia/en/e/eb/Redflag-large.preview.jpg
03:50:44 <FliP^2eH> Red Flag Linux
03:50:45 <FliP^2eH> :)
03:51:04 <adept> ivanm: ok, now you officially have enough excuses not to participate. Anyone else? :)
03:51:06 <fasta> FliP^2eH: is that how the Chinese skin it by default?
03:51:12 <FliP^2eH> Yes
03:51:18 <fasta> FliP^2eH: oh, I didn't know that.
03:51:24 <ivanm> adept: heh
03:51:26 <FliP^2eH> They made it to reduce piracy in their country
03:51:41 <fasta> FliP^2eH: "They" being?
03:51:41 <FliP^2eH> I think 80% of windows copies there are unlicensed :D
03:51:42 <ivanm> FliP^2eH: I thought it was just to avoid American influences...
03:51:48 <ivanm> because surely they don't care about piracy...
03:52:06 <fasta> Yes, it's a security risk to use American software.
03:52:18 <FliP^2eH> I don't know who "They" are
03:52:23 <FliP^2eH> I refer to them as the authors
03:52:38 <FliP^2eH> Officially known as "Red Flag Software"
03:52:46 <fasta> AFAIK, Red Flag Linux is a Chinese initiative and not some initiative of a company.
03:52:57 <fasta> But Wikipedia probably knows..
03:53:06 <FliP^2eH> I just find it funny :)
03:53:13 <FliP^2eH> Winlux
03:54:57 <ivanm> FliP^2eH: "They" == PRC
03:56:01 <FliP^2eH> I dislike those "I want to be like Windows" linuxes :(
03:56:23 <FliP^2eH> I fear ubuntu is going that way
03:56:50 <luqui> I think ubuntu is just getting cool
03:57:05 <fasta> I just wish hardware was documented so that the software has a chance to work properly.
03:57:29 <luqui> smooth upgrade through two releases yesterday, kept all my hacked xmonad and audio driver crap and everything
03:57:39 <luqui> I fell in love...
03:57:40 <FliP^2eH> Ubuntu makes it too hard to realize that you're actually on Linux
03:57:49 <FliP^2eH> My father kept complaining why MS Office would not install
03:57:49 <FliP^2eH> :S
03:58:24 <luqui> FliP^2eH, not enough fscking around with Xorg.conf for you?
03:58:30 <FliP^2eH> :D
03:58:42 <FliP^2eH> I'm not that into hacking
03:58:48 <FliP^2eH> I'm just using Arch Linux
04:00:07 <fasta> Ubuntu is nice, but if you use a kernel from kernel.org, my resume stops working, with no error message in sight.
04:00:39 <fasta> I always liked that it was transparant when something went wrong.
04:00:47 <fasta> "No magic"
04:01:02 <luqui> fasta, umm... i sincerely doubt your ability to get interviews is related to kernel.org...
04:01:13 <FliP^2eH> My last ubuntu was in a restart frenzy
04:01:30 <FliP^2eH> Login, trying to open any program -> instant logout
04:01:32 <ivanm> luqui: what do interviews have to do with it?
04:01:35 <FliP^2eH> As if X was crashing
04:01:42 <ivanm> oh, "resume"... *groan*
04:01:46 <luqui> sorry
04:01:52 <FliP^2eH> Mine's working :)
04:01:52 * ivanm doesn't bother with resume
04:02:10 <ivanm> my laptop takes longer (subjectively, anyway) to get to the BIOS screen than from grub to gdm
04:02:21 <fasta> With an Ubuntu kernel it does work, however.
04:02:22 <ivanm> and by "resume", I _don't_ mean a CV
04:02:23 <opqdonut> wow, that's a fast boot
04:02:30 <opqdonut> which distro?
04:02:32 <ivanm> opqdonut: as I said, it could be subjective
04:02:42 <ivanm> and the time taken to get to BIOS is _long_
04:02:44 <ivanm> opqdonut: gentoo
04:03:02 <fasta> I should disable all the useless services sometime and make a static kernel and all that. Why isn't there a program to do that?
04:03:14 <FliP^2eH> rm -rf /
04:03:23 <FliP^2eH> all static void :)
04:03:30 <fasta> FliP^2eH: that doesn't even work, btw.
04:03:41 <FliP^2eH> Worked for me. Once.
04:03:50 <fasta> Not in Ubuntu anymore.
04:03:51 <FliP^2eH> I was curious how long it would tak
04:03:52 <FliP^2eH> e
04:03:52 <ivanm> fasta: "useless services"?
04:03:57 <ivanm> you mean /etc/init.d/ stuff?
04:04:03 <ivanm> because that has nothing to do with the kernel...
04:04:13 <FliP^2eH> fasta: what did they do?
04:04:13 <fasta> ivanm: yes, but it takes time to boot.
04:04:21 <FliP^2eH> Can't even do it as root?
04:04:25 <fasta> FliP^2eH: special cased it.
04:04:33 <ivanm> in gentoo, there's an option for parallel service starting...
04:04:33 <FliP^2eH> Whyy.
04:04:40 <fasta> FliP^2eH: I think it's an upstream change, btw.
04:04:40 <ivanm> but still, you can't make it "static"
04:04:41 <FliP^2eH> They should let users do that they want
04:04:52 <idnar> ;/lastlog static
04:04:53 <fasta> ivanm: I can get rid of all the modules.
04:04:54 <idnar> oops
04:04:54 <FliP^2eH> If they WANT to rmrf/, they should be able to
04:04:55 <ivanm> FliP^2eH: what are you talking about?
04:05:02 <ivanm> fasta: modules /= services
04:05:09 <fasta> ivanm: yes, I also know that.
04:05:15 <fasta> ivanm: trust me, I know.
04:05:15 <FliP^2eH> ivanm: Ubuntu not lettings roots do "rm -rf /"
04:05:17 <idnar> ivanm: he said "and"
04:05:18 <ivanm> OK, I thought you were talking about services
04:05:24 <ivanm> FliP^2eH: yeah, stupid ubuntu...
04:05:36 <ivanm> also got rid of Ctrl-Alt-Backspace restarting X
04:05:36 <FliP^2eH> Not that someone wants to do it usually
04:05:43 <ivanm> idnar: oh...
04:05:50 <FliP^2eH> But artificial restrictions should not happen
04:06:05 <ivanm> fasta: the main advantage of having your own kernel is that it should be faster if you compile it specifically for your architecture
04:06:15 <ivanm> it's the main recommendation for what you _should_ compile manually
04:06:42 <fasta> ivanm: yes, that's why I did it, but starting services seems to take the most time on my machine.
04:06:57 <ivanm> you can't start them in parallel or something?
04:07:01 <fasta> I mean silly things like starting mysql to play music.
04:07:05 <idnar> ivanm: except most distros provide kernels for each architecture anyway
04:07:12 <fasta> That should only happen on demand.
04:07:20 <idnar> also, the distros usually apply large patchsets that aren't included upstream
04:07:27 <fasta> Even the code should be loaded in a lazy way.
04:07:32 <ivanm> idnar: really? most distros have a PIV, a Core2, etc. kernel?
04:07:42 <fasta> Now, all programs are loaded completely before they start, AFAIK.
04:07:47 <ivanm> fasta: ubuntu uses mysql to play music? :o
04:07:59 <ivanm> fasta: can't you just remove mysql from the init list?
04:08:01 <fasta> ivanm: no, but amarok does, which I don't use anymore.
04:08:08 <ivanm> mpd ftw!
04:08:26 <fasta> ivanm: sure, I can do all of that. I just didn't do it yet and it should be solved in a generic manner.
04:08:33 <fasta> ivanm: i.e. more lazy.
04:08:49 <idnar> ivanm: well, perhaps not every combination
04:09:06 <ivanm> see, if you use a distro that trusts and lets people do whatever they want...
04:09:13 <idnar> ivanm: but you're not running an 80386 kernel everywhere, anyhow
04:09:43 <ivanm> idnar: that's what I meant... I've read many times that people should compile their own kernel for their CPU
04:10:59 <bremner> If you care about the last 3% of performance, why are you on #haskell? :-)
04:11:20 <idnar> it's been a while since CPU was my performance bottleneck
04:14:08 <ivanm> bremner: have you noticed which distro I use? :p
04:14:39 <ClaudiusMaximus> @seen soupdragon
04:14:40 <lambdabot> I saw soupdragon leaving #haskell 7h 41m 2s ago, and .
04:15:44 <bremner> ivanm: gentoo?
04:15:57 <ivanm> yup
04:21:55 <bremner> ivanm: the cognitive dissonance still stands.
04:22:03 <ivanm> hmmm?
04:22:31 <ivanm> gah, I switched back to normal haskell-indent mode because among other things, kuribas' mode doesn't support "...\<newline>\..." ... but neither does the default mode! :@
04:22:52 <opqdonut> :\
04:24:13 <ivanm> I take it back... I still seem to have kuribas' mode enabled for some reason... >_>
04:24:19 <ivanm> normal mode works! \o/
04:27:43 <ray> does easy mode work?
04:33:22 <ivanm> ray: dunno, never touched it
04:35:33 <quicksilver> ivanm: \<newline>\ is one of the most hideous syntax extensions ever devised. Why would you want to use it? ;)
04:35:46 <ivanm> quicksilver: long strings that I want to wrap
04:36:14 <ivanm> (by "long" I mean that my do construct is that far to the left that I can't have the string too long before the line becomes too long)
04:36:50 * quicksilver prefers either ++, or concat[ .. , .. ]
04:36:59 <Cale> Well, that bumped a good 20 degrees off the running temperature of my machine.
04:37:13 <opqdonut> what did
04:37:35 <Cale> Removing the huge clumps of brown dust that had collected in the heatsink.
04:37:50 <opqdonut> :)
04:38:02 <luite> hm, I only get grey dust in my heatsinks
04:38:07 <ivanm> Cale: heh
04:38:13 <ivanm> did you do so whilst the computer was on?
04:38:14 <Cale> I think the dust actually cooks in there
04:38:23 <Cale> No, I shut it off.
04:38:28 <opqdonut> white noise : brown noise :: white dust : brown dust
04:38:32 <opqdonut> filtered.
04:38:35 <ivanm> luite: could be due to the location (e.g. around Mt Isa - a mining town - there's a lot of red dust)
04:38:46 <ivanm> Cale: oh, good, so you're not quite suicidial
04:39:08 <Cale> Well, it's kind of hard to access with the fan spinning
04:39:26 <ivanm> heh
04:39:31 <quicksilver> Cale: you just have to synchronise your own spinning with the fan speed
04:39:38 <ivanm> you could have put a really powerful vacuum cleaner up to the fan...
04:39:38 <quicksilver> it's a bit like docking with a space station in elite
04:39:47 <ivanm> quicksilver: "in elite"?
04:39:52 <opqdonut> ivanm: that's what i do
04:39:53 <quicksilver> a computer game
04:39:55 <opqdonut> yes
04:39:58 <ivanm> never heard of it
04:39:58 <opqdonut> ah, docking
04:40:00 <opqdonut> ah, elite
04:40:01 <quicksilver> best computer game in the history of time, in point of fact.
04:40:03 <opqdonut> those were the days
04:40:03 <Cale> quicksilver: haha
04:40:10 <opqdonut> quicksilver: true
04:40:16 <quicksilver> about 20 years ahead of its time
04:40:18 <quicksilver> or maybe 50.
04:40:34 <quicksilver> ivanm: http://en.wikipedia.org/wiki/Elite_(computer_game)
04:40:38 <opqdonut> quicksilver: which version did you play? mostly the pc version myself
04:40:49 <opqdonut> (the cruder dos version with four colours)
04:40:53 * quicksilver had an amstrad CPC version
04:41:00 <luite> ivanm: I tried that once, the fan started turning really fast, with a lot of noise. problem was that it never ran as smoothly afterward
04:41:02 <quicksilver> although, sadly, it was not as good as the beeb version.
04:41:14 <FliP^2eH> Why does Data.Map.fromList return something in the form "fromList []" and not "Map ..." ?
04:41:21 <EvilTerran> BBC Micro :D
04:41:36 <opqdonut> FliP^2eH: the Map constructor is not exposed
04:41:36 <quicksilver> FliP^2eH: because "Map" isn't a constructor
04:41:46 <quicksilver> FliP^2eH: it's designed to return somethign which is valid haskell code.
04:41:52 <FliP^2eH> hmm
04:41:53 <opqdonut> fromList is the easiest way of implementing a Show instance which is Readable
04:41:59 <opqdonut> and valid haskell code
04:42:06 <ivanm> since you are amongst the people I vaguely recall talking knowledgably about Haskell when I first started using it (and hence in my mind seem to be among the upper branches of the haskellian order), did you guys see my graph class proposal?
04:42:16 <FliP^2eH> So it's just a custom Show instance?
04:42:24 <ivanm> s/you/you all (except FliP^2eH :p)/
04:42:35 <quicksilver> FliP^2eH: yes.
04:42:36 <opqdonut> wow, me too?
04:42:41 <quicksilver> but a well behaved one
04:42:59 <ivanm> opqdonut: your nick sounds vaguely familiar as being here a while ;-)
04:43:00 <FliP^2eH> :(
04:43:09 <ivanm> FliP^2eH's doesn't ;-)
04:43:27 <FliP^2eH> Can't talk knowledgably with me
04:43:32 <opqdonut> well yeah i guess it's some three years since i first joined
04:44:01 <opqdonut> ivanm: anyway, where was this proposal?
04:44:04 <ivanm> opqdonut: hmmm... that's about 6 months more than me ;-)
04:44:09 <ivanm> opqdonut: on haskell-cafe
04:44:17 <ivanm> http://www.haskell.org/pipermail/haskell-cafe/2009-June/063402.html
04:44:24 <ivanm> since only one person responded :(
04:44:26 <opqdonut> thanks
04:44:38 <ivanm> (though at least dons thought it was worth putting on reddit/r/haskell
04:44:39 <ivanm> )
04:44:40 <opqdonut> (i'm not actually on -cafe, just read the archives now and then)
04:45:23 <ivanm> ahhh
04:47:32 <opqdonut> ivanm: looks fine, no comments
04:47:42 <opqdonut> though the exact set of methods in the interface need thinking through
04:48:01 <ivanm> yeah
04:48:05 <opqdonut> the set you gave was one solution
04:48:25 <ivanm> they're the more common "definition"-style things I could think of
04:48:48 <ivanm> obviously you might want to replace the defaults with specific tweaks for the graph type in question
04:49:03 <ivanm> but I was trying to do it in a way that would at the very least work for Data.Graph and FGL without any extensions
04:50:46 <opqdonut> yeah that's a good starting point
04:51:07 <opqdonut> and a ton of operations + defaults seems a pretty good strategy for a real-world thing like this
04:52:25 <ivanm> the way I see it, just about anything else can be added onto from there
04:54:25 <Badger> hey, is RWH down?
04:55:11 <ivanm> http://downforeveryoneorjustme.com/realworldhaskell.org
04:55:29 <Badger> weird
04:55:35 <RyanT5000> Badger: I can load .org, but not read. .org
04:55:46 <ivanm> RyanT5000: what does that mean?
04:55:59 <ivanm> I can read it...
04:56:08 <quicksilver> ivanm: I don't use any of the graph libs so I was poorly placed to comment.
04:56:08 <RyanT5000> sorry, i meant book....org
04:56:09 <RyanT5000> book.realworldhaskell.org/read/
04:56:10 <Badger> oh, wait
04:56:13 <Badger> "It's not just you! http://book.realworldhaskell.org looks down from here. "
04:56:17 <ivanm> ahhh, the book might be down
04:56:18 <MyCatVerbs> http://downforeveryoneorjustme.com/book.realworldhaskell.org <- down.
04:56:23 <ivanm> forgot that it defaults to the blog :s
04:56:28 <MyCatVerbs> Meh, read lyah instead. ;P
04:56:32 <Badger> I shall!
04:56:35 <MyCatVerbs> @where lyah
04:56:35 <lambdabot> www.learnyouahaskell.com
04:56:47 <quicksilver> ivanm: I would add the important point that instances (implementations) should indicate the complexities of the various methods.
04:56:48 <Badger> for great good, no less.
04:56:52 <MyCatVerbs> By Eris do I ever love the fact that we have that.
04:57:01 <ivanm> quicksilver: yeah, that's what I was thinking as a documentation thing
04:57:10 <quicksilver> ivanm: and you should have plenty of methods even if, in theory, some could be be reimplemented in terms of the others - because there might be a more efficient way in some reps.
04:57:18 * Badger pokes BONUS in the monads section :P
04:57:18 <ivanm> so it would be a good way to find a graph data type that suits your needs
04:57:38 <ivanm> quicksilver: which other functions would you suggest?
04:57:51 <FliP^2eH> My code is 90% IO actions :(
04:57:54 <FliP^2eH> That feels so wrong
04:57:55 <ivanm> I couldn't think of any to put there when I wrote that last night
04:58:08 <ivanm> FliP^2eH: unless there's not much computation, then it's wrong
04:58:21 <FliP^2eH> Well, it's an IRC bot
04:58:21 <ivanm> my latest project is mainly IO; but then again, most of it is reading files, etc.
04:58:22 <quicksilver> ivanm: Off hand, nothing. But I don't know much about graph algorithms.
04:58:23 <FliP^2eH> It receives lines
04:58:26 <FliP^2eH> And sends answers
04:58:27 <ivanm> quicksilver: *nod*
04:58:31 <mmorrow> ivanm: one thing i thought of immediately is that succs/preds :: ... -> [Int] is less that ideal, since i often want to take the intersection/unions of a bunch of these
04:58:32 <ivanm> FliP^2eH: sounds like IO to me
04:58:40 <FliP^2eH> Saving stuff to files, reading stuff from files
04:58:49 <ivanm> mmorrow: have it go to a Set or something then?
04:58:54 <quicksilver> ivanm: type Vertex = Int might be contentions.
04:59:02 <mmorrow> or IntSet (if we're using Ints anyways)
04:59:03 <ivanm> quicksilver: well, Data.Graph and FGL already use it
04:59:10 <ivanm> and if you have an IntMap then you have that as well
04:59:10 <quicksilver> even so.
04:59:28 <quicksilver> keeps it h98 though
04:59:41 <quicksilver> (as opposed to going multi-parameter or having a type family)
04:59:46 <Badger> FliP^2eH: does it evaluate Haskell? :)
04:59:51 <FliP^2eH> Nope
04:59:51 <ivanm> mmorrow: I thought of that... but the problem with that is that a lot of times you don't want a Set; and Data.Graph and FGL at least have partial versions that go to [Int]
04:59:52 <FliP^2eH> :(
04:59:55 <FliP^2eH> It's not lambdabot
04:59:57 <ivanm> quicksilver: that was my thinking
05:00:05 <ivanm> FliP^2eH: then it isn't worth writing
05:00:06 <ivanm> ;-)
05:00:18 <Badger> heh
05:00:23 <ivanm> quicksilver: same reason why I don't have/force a "label type"
05:00:26 <FliP^2eH> He's got a right to live!
05:01:05 <quicksilver> mmorrow: well you can hope that a function returning a [Int] might fuse with an [Int]-consumer
05:01:14 <quicksilver> mmorrow: (e.g. IntSet.fromList)
05:01:30 <quicksilver> mmorrow: there are reasons to like [Int] as an interface type.
05:01:41 <ivanm> quicksilver: yeah, it's easier to go from [] -> Set
05:01:48 <quicksilver> in particular, it supports streaming which might be relevant for large graphs
05:01:50 <ivanm> than the other way round
05:02:00 <ivanm> (since most of them already return [])
05:02:13 <mmorrow> quicksilver: yeah, i'm torn about that
05:02:23 <ivanm> Cale: you're a lover of non-traditional graph types... any thoughts?
05:02:37 <quicksilver> what an excellent epitaph that would make
05:02:48 <quicksilver> Here lies Cale Gibbard; A lover of non-traditional graph types.
05:03:22 <Cale> what?
05:03:28 <Cale> Non-traditional?
05:03:29 <mmorrow> i've been writing some graph algos recently and been trying to think about this exact thing, and the only conclusion i keep coming to is that there's just no *one* good representation/interface for *all/most* graphs that's useable
05:03:57 <ivanm> <Cale>	My favourite graph representation is using Data.Map and Data.Set to represent adjacency information.
05:04:01 <Cale> Right...
05:04:08 <Cale> That seems kind of traditional to me ;)
05:04:25 <ivanm> Cale: "non-traditional" == "there's no packaged lib on hackage for it" ;-)
05:04:29 <Cale> ah
05:04:41 <Axman6> > "non-traditional" == "there's no packaged lib on hackage for it"
05:04:41 <ivanm> mmorrow: for hard-core algorithms, no... but for things that do stuff with/on graphs like graphviz, I think something like this would be really useful
05:04:42 <lambdabot>   False
05:04:44 <Axman6> :(
05:04:54 <Cale> Okay, so I suppose that I have to look at what you guys are talking about now :)
05:05:04 <mmorrow> ivanm: oh, something that works would be immensely useful.
05:05:07 <mmorrow> totally
05:05:26 <ivanm> I think HGAL can probably be done using such a Class (though it re-creates a new canonical graph... *shrug*)
05:05:28 <mmorrow> (i just haven't been able to think of one, not to say that one doesn't exist ;)
05:05:29 <Cale> I think that if one was to implement instances for the fgl classes, you could take advantage of the algorithms from there.
05:05:49 <ivanm> Cale: the FGL classes have too many FGL thing in them, that's all
05:06:03 * ivanm pulls up the actual FGL classes so he can check what they are
05:06:51 <ivanm> nope, FGL fails... since it has Decomp stuff
05:07:00 <ivanm> apart from that, if we strip the labelled stuff then maybe they'd be alright
05:07:12 <Cale> Decomp?
05:07:21 <ivanm> match :: Node -> gr a b -> Decomp gr a b, etc.
05:07:36 <ivanm> Data.Graph can't really do decompositional stuff due to the array usage
05:07:37 <quicksilver> mmorrow: there not being one universal representation, I definitely buy.
05:07:51 <quicksilver> mmorrow: as for not being one universal interface - well there is the union of all the interfaces.
05:08:07 <quicksilver> mmorrow: with the caveats that some functions will have disastrous complexity with certain representations.
05:08:10 <quicksilver> (but that's just life)
05:08:26 <quicksilver> a common interface would enable us to say "for this task, I choose this rep, because it makes these methods fast)
05:08:34 <ivanm> as I've said, my main reason for proposing this is so that I can use it for graphviz and maybe hgal (I'm thinking about re-writing it and tweaking it, hoping to get it faster)
05:08:51 <Cale> ivanm: Oh, I never suggested using Data.Graph
05:09:04 <ivanm> Cale: then you missed the initial point of the discussion ;-)
05:09:07 <Cale> ah
05:09:09 <Cale> Using arrays is horrid.
05:09:24 <ivanm> http://www.haskell.org/pipermail/haskell-cafe/2009-June/063402.html
05:09:27 <ivanm> Cale: agreed
05:09:31 <Cale> At least use something with fast updates :)
05:09:31 <ivanm> but some people use them
05:09:40 <Cale> Or abstract over representation altogether, if you can.
05:09:46 <mmorrow> quicksilver: heh, right. i should have said "there not being one minimal shell representiation that i can shove all the various oblong graph-like beasties that i've got laying around into"
05:10:00 <ivanm> e.g. I've been using Data.Graph for one project only because I wanted to use HGAL, and HGAL uses Data.Graph
05:10:02 <Cale> (and just have totally crap performance for cases where people do something like using arrays)
05:10:17 <Cale> Yeah, we should really fix HGAL.
05:10:29 <ivanm> admittedly, I don't really do much with the graph (I do a -> Graph, find the canonical representation and then basically nub on that)
05:10:42 <mmorrow> quicksilver: so yes, i'm actually not talking about interface at all now that i think about it.
05:11:00 <ivanm> Cale: I've tried pinging jyp about it, as I know he has some unapplied patches in his repo (he told me this)... but he seems to have disappeard off the face of the planet :s
05:11:08 <ivanm> maybe the evil imperative monsters got him? :p
05:11:20 <Cale> istr that the implementation of hgal was really hard to read
05:11:26 <quicksilver> mmorrow: yup. I think agreeing on a "greatest common multiple" interface
05:11:37 <quicksilver> mmorrow: and then explaing which operations are fast/slow with which representations
05:11:50 <quicksilver> mmorrow: is a very good starting point to help people choose the right rep. for their problem.
05:11:57 <Cale> (Possibly because it's a translation of an imperative algorithm)
05:12:07 <ivanm> the only other thing I can think of to add to my class atm is a buildGraph function[s], i.e. [Vertex] -> [(Vertex,Vertex)] -> g
05:12:13 <ivanm> Cale: agreed
05:12:38 <ivanm> I tried re-writing the nauty algorithm from scratch from the paper; re-did the partitioning algorithm before I got stuck and ran out of time
05:13:08 <ivanm> Cale: can't use the "imperative algorithm" excuse... I've written the partitioning bit functionally, whereas jyp did it imperatively
05:13:42 <ivanm> Cale: but is there anything else you think should be added/changed in that class?
05:13:47 <mmorrow> Cale: gah, yeah transcribing imperative graph pseudocode into haskell is a joy!
05:13:55 <Cale> Er, which class?
05:13:59 <ivanm> mmorrow: especially 70s style pseudocode!
05:14:03 <mmorrow> weee
05:14:08 <ivanm> Cale: the one in the haskell-cafe email I linked to...
05:14:10 <ivanm> http://www.haskell.org/pipermail/haskell-cafe/2009-June/063402.html
05:14:12 <ivanm> Cale: ^^
05:14:13 <ivanm> ;-)
05:14:51 <Cale> ah, I hadn't scrolled down
05:15:13 <ivanm> heh
05:15:23 <Cale> I don't care for type Vertex = Int, myself.
05:15:33 <Cale> (In fact, I despise Int)
05:15:46 <Cale> Though I can understand why you'd want to use it.
05:15:54 <ivanm> yeah
05:16:01 <ivanm> from a user perspective, it's horrible
05:16:21 <ivanm> from a developer/usage perspective it has several benefits
05:16:33 <mmorrow> it's really the only reasonable option, if you make the decision no to use the Ord of the nodes themselves
05:16:40 <mmorrow> *to not use ...
05:16:44 <ivanm> also, if we want Data.Graph and FGL to instance it, then we kinda have to use it unless we resort to fundeps :s
05:17:22 <Cale> How about  class Graph g v | g -> v where neighbours :: g -> v -> Set v; vertices :: g -> Set v
05:17:48 <Cale> Well, might want some graph *transformations* as well ;)
05:17:56 <mmorrow> Cale: heh, i keep running into this exact problem and it's driving me crazy
05:18:03 <ivanm> Cale: yeah, that might require an extra class though
05:18:11 <mmorrow> what if you have Int node identities?
05:18:13 <Cale> Right, you'd want to keep that separate.
05:18:14 <ivanm> since your rather limited what you can safely do with Data.Graph
05:18:16 <mmorrow> then Set Int /= IntSet
05:18:42 <Cale> Is the difference beteween Set Int and IntSet really that important?
05:19:04 <ivanm> Cale: we discussed Set vs [] above ... in general, you can then do [] -> Set if you want to, and Data.Graph and FGL already do g -> []
05:19:09 <Cale> I always just imagine that eventually Set Int will be implemented via IntSet once we get the typesystem issues taken care of.
05:19:30 <ivanm> Cale: just that trivial little typesystem issue to be fixed, eh? :p
05:19:44 <ivanm> realistically, do we want to introduce fundeps to something like this?
05:19:51 <mmorrow> Cale: i feel like there has to be *some* way to do this now (i keep trying and failing to come up with something)
05:20:01 <Cale> Well, if not fundeps, then ATs :P
05:20:31 <ivanm> Cale: ATs?
05:20:40 <Cale> The problem is that although we have type families, there's no way to close a type family by providing a polymorphic case which eats the rest of the domain.
05:20:41 <mmorrow> Cale: this is actually the single biggest annoying problem i'm having with coming up with a common graph (data) definition for the various graphs i want to deal with.
05:20:41 <ivanm> though I meant more "do we really want to use any extensions?"
05:20:52 <Cale> and there ought to be
05:21:25 <mmorrow> oh wow, i just thought of something
05:21:29 <Cale> I don't see a particularly good reason to avoid using extensions. mtl uses fundeps and half of everything on hackage uses mtl
05:22:04 <ivanm> Cale, mmorrow: do you want me to go and create a code.haskell project for this, then we can go off onto -blah or something to discuss how we should do this (assuming the two of you want to help me write a version of this class that satisfies everybody? :p )
05:22:05 <mmorrow> just merge the Data.Map and Data.IntMap modules/types into a single type somehow, and make the decision transparent
05:22:06 <Cale> ivanm: ATs = associated types
05:22:12 <mmorrow> err, s/transparent/opaque/
05:22:34 <Twey> H98 is... well, eleven years old now
05:22:43 <Cale> Oh, there is a GADT solution...
05:22:44 <Twey> If you want to code to a standard, I'd go for H'...
05:22:47 <mmorrow> ivanm: sure, i'm interesting in helping.
05:22:51 <ivanm> Twey: it's not my fault that they won't finalise on H'!
05:22:58 <ivanm> mmorrow: what should we call it?
05:22:59 * Twey laughs.
05:23:05 <Cale> er, hmm
05:23:31 <mmorrow> ivanm: hmm, i nothing come to mind immediately
05:23:43 <Cale> mmorrow: I was thinking something like data family Set
05:23:57 <Cale> But hmm
05:24:12 <ivanm> Twey: does any compiler (even GHC) follow that unfinalised standard though?
05:24:26 <mmorrow> Cale: hmm, not sure about with data families, but the problem i run into when i try to do this with type families is that you can make a class instance for a type family
05:24:34 <Twey> ivanm: H' aims to only follow implemented and tested features
05:24:44 <Twey> It's basically a standardisation of a bunch of GHC extensions
05:24:45 <ivanm> does it? oh...
05:24:51 <mmorrow> which inevitable bites me in some indirect way
05:24:58 <ivanm> by "implemented and tested", do you mean "GHC already does this, so lets make it official"?
05:25:03 <Twey> Yup
05:25:35 <Twey> I don't *think* there's anything in H' that isn't already available as an extension for GHC.
05:25:39 <Twey> I could be wrong.
05:25:52 <EvilTerran> if there is, it'll be an extension in some other compiler
05:26:12 <ivanm> gah, google can't find "haskell'"... have to do "haskell prime" :@
05:26:19 <Twey> Heh, yes
05:26:27 <Cale> mmorrow: See, the problem is that the Set a case will overlap
05:26:46 <mmorrow> ahh yeah, exactly!
05:26:49 <Twey> ivanm: If you're coding to H98, you don't get most of the benefit of the language
05:27:00 <Cale> We need a way to express that a type family gets closed by a completely polymorphic case that handles all the cases not-already-defined.
05:27:06 <Twey> Like concurrency, Data.Function, &c.
05:27:12 <mmorrow> Cale: i think that actually was the stopper i ran into now that you say that.
05:27:14 <ivanm> Twey: well, the benefits of the current unofficial standard of the language
05:27:22 <Twey> You're restricted to what's in the Report, and practically speaking, nobody does that :)
05:27:36 <ivanm> Cale: so do you want to join mmorrow and myself in developing such an graph class?
05:27:49 <ivanm> Twey: heh
05:28:04 <Cale> ivanm: sure, I'll throw in my 2 cents.
05:28:10 <ivanm> I don't know why, but fundeps just look really ugly to me :s
05:28:17 * mmorrow hates fundeps
05:28:18 <ivanm> any other takers?
05:28:26 <Cale> I like fundeps actually.
05:28:34 <ivanm> Cale: any suggestions for the name (at least of the code.haskell project)?
05:28:45 <Cale> graph?
05:28:47 <Twey> Fundeps are... clever
05:28:58 <Cale> There are cases where fundeps are actually nicer than associated types
05:29:06 <ivanm> Cale: could possibly be seen as clashing with Data.Graph though :s
05:29:45 <Cale> What package is Data.Graph in?
05:29:46 <ivanm> wikipedia doens't know what ATs are :(
05:30:00 <ivanm> Cale: containers
05:30:09 <Cale> mm...
05:30:15 <mmorrow> Cale: yeah, i like putting type families outside of the class (although both are equivalent)
05:30:18 <Cale> In that case, that's kind of sad.
05:30:28 <Cale> Data.Map and Data.Set are comparatively good.
05:30:37 <Cale> We should just fix the containers package, maybe
05:30:48 <ivanm> Cale: well, it's just a wrapper around arrays (which AFAIK is the only reason containers requires arrays to build...)
05:30:58 <ivanm> Cale: hmmmmm....
05:31:11 <ivanm> so do a seperate package for now, and then push/propose that it gets merged later?
05:31:13 <FunctorSalad> what was the conclusion now?:)
05:31:17 <ivanm> similarly to extensible exceptions?
05:31:19 <Cale> The existing Data.Graph sucks. I don't know about everyone else, but I never use it myself.
05:31:30 <ivanm> Cale: I've only used it for HGAL
05:31:33 <mmorrow> yeah, Data.Graph does suck
05:31:44 <ivanm> then again, the only other time I've done graph stuff I've used FGL
05:31:45 <Cale> What sucks even more is Data.Tree
05:31:51 <ivanm> Cale: oh?
05:31:54 <ivanm> how come?
05:31:54 <mmorrow> (although the way stuff is implemented is elegant, nice, the datatype sucks)
05:32:07 <Cale> Mainly the Show instance
05:32:12 <ivanm> ahhh
05:32:12 <mmorrow> and there are more efficient ways to do a bunch of those algos in Data.Graph
05:32:15 <Cale> and the ridiculous type synonyms
05:32:19 <ivanm> mmorrow: definitely
05:32:31 <ivanm> though I"d guess that most of them are just historic artifacts
05:33:15 <ivanm> tbh, off the top of my head I can't think of a nicer way of defining a generic Tree type
05:33:20 <FunctorSalad> ridiculous synonyms? where? ;)
05:33:22 <Cale> We should have a Graph type which is actually abstract, but perhaps as a first implementation, use the map of sets approach, since at least that has decent asymptotic complexity.
05:33:31 <ivanm> FunctorSalad: Data.{Graph,Tree}
05:33:41 <mmorrow> e.g.
05:33:43 <mmorrow> scc g = dfs g (reverse (postOrd (transposeG g)))
05:33:44 <mmorrow> !!!
05:33:55 <mmorrow> this is O(n^2) and scc is an O(n) algo!
05:33:57 <ivanm> Cale: hmmmm.... I think we'd probably need to keep the array impl there for backwards compatability
05:34:12 <ivanm> mmorrow: there's a better scc algo on hackage...
05:34:13 <Cale> Yeah, another thing I hate about the fgl is the terrible terrible short-form names.
05:34:25 <ivanm> Cale: I hate the usage of 4-tuples
05:34:32 <mmorrow> ivanm: yes, i've also got an scc implem i use
05:34:41 <ivanm> Cale: records would be _much_ nicer
05:34:43 <Cale> Would it kill you to write stronglyConnectedComponents? You're only going to call it once in a blue moon anyway.
05:34:52 <mmorrow> (which was painfully transcribed from pseudocode earlier mentioned)
05:35:15 <mmorrow> Cale: yes, that would probably kill me dead
05:35:20 <mmorrow> (seriously :)
05:35:47 <Cale> There are all these things which I think if you know what they stand for, you probably wouldn't mind just implementing them yourself.
05:36:07 <mmorrow> yeah, true
05:36:07 <ivanm> Cale: would you really want to re-implement them all the time though?
05:36:24 <Cale> well, not really
05:36:30 <mmorrow> definitely just once, it at all
05:36:40 <totom> hi, does anyone use http://batterseapower.github.com/test-framework/ here ?
05:36:48 <mmorrow> but if there's a conveniently placed implem in a lib..
05:36:58 <ivanm> mmorrow, Cale: so what about GraphPrime then as a project name? :p
05:37:18 <totom> when I try to run the example I get No instance for (QuickCheck-1.2.0.0:Test.QuickCheck.Testable (Gen Prop)) arising from a use of `testProperty'
05:37:20 <Cale> But, for instance, http://hackage.haskell.org/packages/archive/fgl/5.4.2.2/doc/html/Data-Graph-Inductive-Query-DFS.html
05:37:28 <Cale> I mean, just look at that :)
05:37:29 <ivanm> http://hackage.haskell.org/packages/archive/Graphalyze/0.4/doc/html/Data-Graph-Analysis-Algorithms-Common.html ;-)
05:37:35 <ivanm> (shameless plug :p)
05:37:44 <ivanm> are my names OK? :p
05:38:18 <mmorrow> ivanm: i'm trying to think of a graphy name and i'm literally drawing a blank
05:38:21 <ivanm> 0.5 wouldn't build due to pandoc :(
05:38:45 <ivanm> mmorrow: well, if as Cale suggested we want this to replace Data.Graph, then I think graph' captures that
05:38:56 <mmorrow> ooh, i like graph'
05:39:04 <mmorrow> (w/out "prime")
05:39:17 <mmorrow> too bad cabal won't accept that.. :(
05:39:24 <ivanm> yeah
05:39:27 <ivanm> which is why I spelled it out
05:39:28 <Cale> hmm
05:39:29 <FunctorSalad> why not just "graph"?
05:39:50 <ivanm> FunctorSalad: just so people don't think it _is_ Data.Graph atm
05:40:03 <ivanm> FunctorSalad: you want to join in the fun? :p
05:40:05 <dcoutts> mmorrow: it's not just Cabal, it will not translate into rpm, dep, ebuild etc
05:40:06 <Cale> But Data.Graph isn't in a package called graph
05:40:10 <ivanm> Cale: true
05:40:10 <dcoutts> dep/deb
05:40:18 <FunctorSalad> ivanm: call it Data.Graph.Graph too. then you get free advertising from the import error.
05:40:29 <FunctorSalad> :D
05:40:29 <ivanm> FunctorSalad: what import error?
05:40:36 <mmorrow> dcoutts: zencoding to teh rescue
05:40:46 <FunctorSalad> "ambiguous import.... found in multiple packages"
05:40:49 <mmorrow> preflex zenc graph'
05:40:49 <preflex>  graphzq
05:40:52 <ivanm> FunctorSalad: ahhh
05:40:57 <mmorrow> graphzq!
05:40:59 <dcoutts> mm_freak: noooo!
05:41:01 <dcoutts> oops
05:41:02 <ivanm> mmorrow: zenc?
05:41:03 <mmorrow> heh
05:41:06 <dcoutts> mmorrow: :-)
05:41:24 <dcoutts> ivanm: the name mangling that ghc uses
05:41:29 <dcoutts> not for human consumption
05:41:30 <ivanm> ahhh
05:41:38 <FunctorSalad> I don't get it ("graphzq")
05:41:39 <mmorrow> base_GHCziIO_zdLr49pzdszdwa3_closure
05:41:45 <mmorrow> preflex: zdec base_GHCziIO_zdLr49pzdszdwa3_closure
05:41:46 <preflex>  base_GHC.IO_$Lr49p$s$wa3_closure
05:41:49 <ivanm> preflex: zenc Haskell'
05:41:50 <preflex>  Haskellzq
05:41:59 <Twey> Heheh
05:42:00 <mmorrow> preflex: zdec zZ@#$%^&*(*&^%$#@
05:42:01 <preflex>  zZ@#$%^&*(*&^%$#@
05:42:01 <ivanm> so ' -> zq ...
05:42:04 <Twey> That's the next standard
05:42:06 <mmorrow> preflex: zenc zZ@#$%^&*(*&^%$#@
05:42:06 <preflex>  zzZZz40UzhzdzvzczaztZLztzazczvzdzhz40U
05:42:11 <Twey> Haskellzq
05:42:18 <dcoutts> heh heh
05:42:30 <ivanm> so everyone OK with just "graph" as the project name?
05:42:39 <ivanm> and who wants to be part of the fun? ;-)
05:42:41 <Cale> I am
05:43:01 <FunctorSalad> I'm not particularly good with graphs
05:43:38 <ivanm> FunctorSalad: and you think _I_ am? :p
05:43:59 <Cale> It's just too bad that we won't really be able to steal ideas from Grape
05:44:02 <ivanm> it's just the normal Haskell programming: connect-the-types! ;-)
05:44:09 <ivanm> Cale: Grape? or Graph?
05:44:14 <Cale> http://www.maths.qmul.ac.uk/~leonard/grape/manual/chapters.htm
05:44:47 <Cale> Too many things there rely on easy group representations :)
05:44:53 <FunctorSalad> it seems like the difficulty is how to allow high-perfomance updates?
05:44:54 <ivanm> ooohhhh.... looks cool
05:45:02 <ivanm> FunctorSalad: I think initially we disallow updates
05:45:13 <ivanm> and have a second class for those implementations that support them
05:45:27 <FunctorSalad> ivanm: I thought that posting on -cafe had a good point that almost any graph algorithm needs mutable labels
05:45:28 <ivanm> if only so people who insist on using Data.Graph won't complain about not being able to use it ;-)
05:45:50 <ivanm> FunctorSalad: do they?  HGAL doesn't use labels...
05:46:09 <Cale> GAP is really cool. If only it had been written as an EDSL for Haskell rather than devising its own half-baked imperative programming language.
05:46:15 <ivanm> the only ones in Graphalyze I had that used labels IIRC were clustering
05:46:45 <Cale> Well, I shouldn't be too hard on it. At least functions are first class and have decent syntax.
05:46:52 <ivanm> heh
05:47:02 <Cale> In fact, their lambda is even shorter than Haskell's :)
05:47:14 <Cale> it's just infix ->
05:47:47 <adept> Cale: are you doing icfpc this year?
05:47:52 <ivanm> Cale: well, we can't use it atm because that's used elsewhere for Haskell...
05:47:59 <Cale> adept: as usual, definitely maybe
05:48:11 <adept> :)
05:48:16 <adept> Cale: solo?
05:48:35 <Cale> adept: Is there any information about the sort of project it will be this time?
05:48:57 <Cale> I think it's more fun working with a group anyway
05:49:00 <ivanm> Cale, mmorrow: so just "graph" for the project name? and what are your code.haskell user names?
05:49:07 <ivanm> Cale: no info
05:49:07 <adept> Cale: none whatsoever, if you dont count the weird starting time (16 seconds after an hour) as a hint
05:49:17 <ivanm> adept: yeah, I was wondering about that
05:49:27 <ivanm> base-16 computation? ;-)
05:49:38 <FunctorSalad> maybe we could use a zipper to emulate mutation?
05:49:42 <mmorrow> this directory from MLRISC has a ton of great graph code in it http://moonpatio.com/repos/LIBS/Language/smlnj/MLRISC/graphs/
05:49:48 <mmorrow> (too bad it's in sml....)
05:49:59 <Cale> I wonder if it'll be another big VM thing, or if it'll be a classical ICFP like last time.
05:50:21 <adept> Cale: how about joining forces?
05:50:36 <ivanm> Cale: apparently it's going to be "produce results for this"
05:50:44 <ivanm> since people were complaining about having to make runnable code
05:51:18 <mmorrow> FunctorSalad: http://www.cs.tufts.edu/~nr/pubs/zipcfg-abstract.html
05:51:25 <ivanm> mmorrow: I notice how you cunningly appropriated the new Haskell logo for your site's icon ;-)
05:51:28 <Cale> adept: Sure, if I decide to do it :)
05:51:35 <mmorrow> ivanm: indeed :)
05:52:04 <ivanm> Cale, mmorrow: so just "graph" for the project name? and what are your code.haskell user names?
05:52:21 <Cale> ivanm: Yes, and I forget.
05:52:23 <mmorrow> morrow
05:52:29 <ivanm> Cale: heh
05:52:34 <Cale> ivanm: If I have an account, it'll either be cale or cgibbard
05:52:42 * ivanm looks
05:52:49 * Cale tries to ssh
05:52:54 <Cale> cgibbard
05:52:56 <FunctorSalad> "daniels" I think
05:53:08 <ivanm> FunctorSalad: you joining in?
05:53:28 <ivanm> dcoutts: when requesting projects on code.haskell, are the members delimeted by spaces or commas?
05:53:52 <FunctorSalad> ivanm: not sure but can't hurt I guess ;)
05:54:00 <ivanm> heh
05:54:01 <Cale> Should we just start with a gobby session?
05:54:05 <ivanm> and daniels appears to be your username
05:54:09 <ivanm> Cale: "gobby"?
05:54:19 <Cale> multiplayer text editor
05:54:27 <ivanm> never heard of it, but sure
05:54:28 <adept> ivanm: just agree, you'll be hooked in seconds :)
05:54:36 <ivanm> adept: heh
05:54:44 <altmattr> hi folks, how do we fake parameterised modules in haskell?
05:55:01 <Cale> altmattr: typeclasses?
05:55:06 <FunctorSalad> "gobby" or "gobby-0.5" in debian?
05:55:13 * ivanm goes off to compile it
05:55:13 <dcoutts> ivanm: a human reads it, so I don't think it matters
05:55:15 <EvilTerran> i think you can get a very similar effect to value-parameterised modules with typeclasses
05:55:17 <Vanadium> Oh, hey, you are using gobby, awesome.
05:55:23 <ivanm> dcoutts: not automated? OK
05:55:25 <mmorrow> ooh, gobby sounds cool
05:55:25 <Cale> hmm, I'm apparently using gobby-0.4.9
05:55:30 <dschoepe_> ivanm: commas works
05:55:34 * mmorrow has to run for a bit though
05:55:39 <EvilTerran> (and a single type paramater, or more if you use MPTCs or ATs)
05:55:50 <Cale> I created a session on cale.yi.org
05:55:52 <adept> Cale: btw, there is "sobby" for starting a headless gobby server
05:55:54 <ivanm> good, because 0.5 is masked (in gentoo-speak, this means its probably very bad)
05:56:13 <ivanm> it'll take me a while... I've got four different packages to compile! :s
05:56:22 <altmattr> EvilTerran: Cheers, I will look into it
05:56:23 <Vanadium> ivanm: The 0.5 branch is still somewhat prerelease, we are only up to 0.49.something
05:56:28 <Cale> Serves you right for using gentoo ;)
05:56:31 <ivanm> Vanadium: *nod*
05:56:33 <ivanm> Cale: heh
05:56:42 <ivanm> OK, this is what I'm using for the project description:
05:57:04 <Vanadium> err, 0.4.93, sorry
05:57:05 <FunctorSalad> I installed gobby-0.5_0.4.92-2 now, so that is wrong?
05:57:29 <ivanm> "Develop a generic graph class so that graph libraries/algorithms can be used by various graph data types, possibly as a replacement for the current default implementation in Data.Graph."
05:57:33 <ivanm> Everyone happy with that?
05:57:35 <Vanadium> FunctorSalad: Yes, that branch is incompatible with sobby
05:57:35 <Cale> FunctorSalad: try connecting to cale.yi.org
05:57:47 <Cale> (port 46464)
05:57:59 <ivanm> gah, net6 failed to build! :s
05:58:05 <Vanadium> :(
05:58:12 <Cale> ivanm: Well, I think we should also provide a standard instance of the class too :)
05:58:20 <Cale> (or a few)
05:58:21 <ivanm> Cale: yeah
05:58:24 * ivanm adds that in
05:58:48 <ivanm> "*** The libgnutls-config script installed by LIBGNUTLS could not be found"
05:58:50 <ivanm> yay! :s
05:58:53 <Cale> It's really really sad that Dr. Kahl has still apparently not released his version of Data.Rel
05:59:11 <ivanm> who?
05:59:28 <Cale> A professor at McMaster university
05:59:31 <FunctorSalad> 'connection refused'. I'll install the other package
05:59:52 <idnar> what is Data.Rel?
05:59:52 <Cale> He had this beautiful fast implementation of all sorts of operations on relations (which are essentially graphs)
05:59:53 <ivanm> "Develop a generic graph class so that graph libraries/algorithms can be used by various graph data types.  This will include a default implementation, which will possibly be a replacement for the current default implementation in Data.Graph."
05:59:56 <idnar> ah
06:01:16 <Cale> oh, hmm...
06:02:17 <FunctorSalad> Cale: with 0.4.9, "No data record of requested type"
06:02:48 <Cale> FunctorSalad: huh...
06:03:10 <Cale> oh!
06:03:30 <Cale> Let me ensure everything is good with my router, perhaps.
06:03:49 <Cale> hmm, no, that's open
06:04:18 <FunctorSalad> port 6522?
06:04:24 <Cale> 46464
06:04:34 <Cale> ah, that's probably what it is :P
06:04:39 <FunctorSalad> oh, 6522 is the default with mine
06:06:14 <ivanm> FunctorSalad: if Cale won't use the default graph types, why do you think he'll use the default port number? ;-)
06:06:41 <Cale> Actually, 46464 was the default when I opened gobby, but I'd probably changed it at some point in the distant past and forgot
06:07:27 <FunctorSalad> maybe I'm not the right person for this. shouldn't abstractions be based on experience with what the abstraction is supposed to do? (supporting graph algorithms, here)
06:07:44 <ivanm> looks like I might not be able to use gobby, since net6 doesn't like my version of gnutls :s
06:07:46 <RyanT5000> Hey guys; there's a new iPhone mailing list at haskell.org; go to http://www.haskell.org/mailman/listinfo/iphone to sign up
06:07:47 <Cale> Hm?
06:08:07 <ivanm> RyanT5000: except that I don't have an iPhone, don't expect to get one and have no interest in them ;-)
06:08:28 <RyanT5000> ivanm: that's why we have the list! so i can stop spamming you about iPhone stuff :)
06:08:33 <ivanm> heh
06:08:34 <RyanT5000> (after spamming you about the list itself!)
06:08:51 <ivanm> I know that it's been annoying on -cafe how some people don't know how to strip useless stuff off old emails...
06:08:52 <Cale> ivanm: Isn't there a set of USE flags or something to fix that? ;) -fmakeitwork
06:09:30 <Cale> http://relmics.mcmaster.ca/tools/RATH/ -- hmm!
06:09:38 <ivanm> Cale: looks like I won't be able to play... there's bugs about it, but the reported patches don't work
06:09:40 <ivanm> :(
06:09:46 <FunctorSalad> ivanm: turn off net6? (which is ipv6 support I suppose)
06:10:05 * ivanm thinks it's a default option, but checks
06:10:11 <ivanm> s/option/requirement/
06:10:16 <ivanm> yup, it apparently is
06:10:30 <ivanm> obby needs it :s
06:10:39 <Cale> That link doesn't look particularly modern though.
06:10:47 <FunctorSalad> usually stuff can be compiled without it
06:10:59 <FunctorSalad> get the tarball and try to configure without ipv6?
06:11:21 <ivanm> it appears to want gnutls 1.*
06:11:26 <ivanm> but gentoo only has 2.* :s
06:12:33 <FunctorSalad> ivanm: in debian it depends on gnutls >= 2.4.0.0
06:12:42 <FunctorSalad> *2.4.0-0
06:12:43 <ivanm> I have 2.8 :s
06:12:58 <ivanm> and apparently it's a cumpolsory dep :s
06:13:10 <ivanm> since it's ipv4 as well as 6
06:13:39 <FunctorSalad> just saying it's not tls 1.*
06:14:07 <ivanm> yeah
06:15:06 <Cale> For my gobby... libgnutls.so.26 => /usr/lib/libgnutls.so.26 (0xb78a5000)
06:16:29 <ivanm> it would probably help if I patched it properly :s
06:16:49 <FunctorSalad> Cale: how do you mean "rath is not released"? the source is linked there
06:17:20 <ivanm> Cale: anyway, whilst I'm trying to get this to build, where can I find something on ATs?
06:17:28 <ivanm> wikipedia has nothing, haskell.org has nothing :s
06:17:41 <Cale> FunctorSalad: That RATH is released.
06:17:55 <FunctorSalad> ivanm: http://www.haskell.org/haskellwiki/GHC/Type_families
06:18:01 <Cale> FunctorSalad: but that is apparently not the code which I saw Dr. Kahl demo :)
06:18:35 <hackagebot> loli 2009.6.25 - loli (JinjingWang)
06:18:43 <FunctorSalad> :O
06:21:29 <fasta> ivanm: about the graphs... how much time do you have to implement it? And if you want to make something useful you just have to port the Boost Graph Library to Haskell.
06:21:57 <ivanm> Cale: nope, looks like I still can't get it to build
06:22:04 <ivanm> fasta: ummmmm..... what?
06:22:25 <Cale> fasta: What's so great about the Boost graph library?
06:22:28 <fasta> ivanm: you asked a question about graphs on the mailing list and in this channel, didn't you?
06:22:56 <fasta> Cale: it does exactly what one needs to implement non-trivial graph algorithms in an efficient way.
06:23:04 <ivanm> fasta: yeah, we're talking about an interface to graphs
06:23:10 <ivanm> so that different implementations can use the same code
06:23:17 <ivanm> _not_ for a new graph implementation ;-)
06:23:28 * ivanm thinks we have enough of those
06:23:44 <nominolo> , vacuum const
06:23:47 <lunabot>  [(0,[])]
06:23:48 <fasta> In Haskell all graph implementation suck in one way or another.
06:23:53 <fasta> implementation*
06:24:14 <fasta> The roll your own approach is still used by everyone, AFAIK.
06:24:21 <fasta> (for non-toy applications)
06:24:39 <ivanm> fasta: yes...
06:24:49 <ivanm> but not everyone should have to roll-their-own graphviz bindings, etc.
06:24:53 <ivanm> _that_ was my point
06:24:55 <Cale> Well, unless you count  Map Vertex (Set Vertex)
06:25:00 <Twey> nominolo: What is , vacuum?
06:25:01 <ivanm> I don't care which graph implementation you use ;-)
06:25:04 <fasta> The BGL is mature and all the design work has already been done.
06:25:07 <nominolo> FGL also seemed buggy at times
06:25:23 <ivanm> nominolo: in what way?
06:25:26 <Cale> fgl has a poor user interface
06:25:34 <fasta> That said, I don't really care, since my graph implementation already does everything one would ever want.
06:25:47 <nominolo> Twey: it's a bot.  and vaccum gives a points-to graph of the data structure
06:25:50 <Cale> fasta: How is it implemented?
06:25:54 <FunctorSalad> fasta: are you suggesting porting it with mutations?
06:25:56 <fasta> It would only help me when writing something for an employer.
06:26:08 <nominolo> Twey: www.youtube.com/watch?v=X4-212uMgy8
06:26:15 <Twey> Aha
06:26:31 <fasta> FunctorSalad: mutations must be supported in any serious implementation. It's nicer if a functional algorithm can be found, but this is often not the case.
06:26:41 <FunctorSalad> maybe in ST
06:26:48 <fasta> FunctorSalad: that's what I used.
06:26:54 <nominolo> ivanm: I forgot, but I know I came across some problems when I used it a while ago
06:26:55 <fasta> FunctorSalad: and IntMap
06:26:57 <FunctorSalad> fasta: did you release it?
06:26:57 <EvilTerran> , vacuum (let mu f = f (mu f) in mu (1:))
06:27:03 <fasta> FunctorSalad: no
06:27:03 <lunabot>  Killed.
06:27:20 <EvilTerran> , vacuum (let mu f = x where x = f x in mu (1:))
06:27:22 <lunabot>  [(0,[1,0]),(1,[])]
06:27:44 <Cale> , vacuum (fix (1:))
06:27:46 <lunabot>  [(0,[1,0]),(1,[])]
06:28:19 <Cale> , vacuum (S.fromList (zip [1..5] "hello"))
06:28:20 <lunabot>  luna: Not in scope: `S.fromList'
06:28:23 <Cale> , vacuum (M.fromList (zip [1..5] "hello"))
06:28:24 <lunabot>  luna: Not in scope: `M.fromList'
06:28:27 <Cale> hmm
06:28:32 <Cale> , vacuum (Map.fromList (zip [1..5] "hello"))
06:28:33 <lunabot>  luna: Not in scope: `Map.fromList'
06:28:37 * Cale guesses :)
06:28:42 <Cale> , vacuum (Data.Map.fromList (zip [1..5] "hello"))
06:28:43 <lunabot>  luna: Not in scope: `Data.Map.fromList'
06:28:50 <nominolo> Cale: IRC doesn't work to well for graphical output...
06:28:52 <EvilTerran> , fromList
06:28:52 <Cale> I suppose it's not available :)
06:28:53 <lunabot>  luna: Not in scope: `fromList'
06:28:56 <fasta> Does vacuum already work with a simple cabal install?
06:29:33 <fasta> Well, it seems to compile. That's good.
06:30:23 <Cale> It worked for me
06:30:40 <fasta> It does. Nice :)
06:30:56 <Cale> though, to get the cairo component, I suspect you need to have gtk2hs already installed, which isn't on hackage
06:31:16 <fasta> view (Data.Map.fromList (zip [1..5] "hello")) doesn't work, though
06:31:34 <fasta> Error: <stdin>:6: syntax error near line 6
06:31:34 <fasta> context:     "Bin[5]|0" -> >>>  {"2|1", <<< "'e'|2","Bin[1]|3","Bin[3]|4"}
06:31:37 <fasta> That's what I get.
06:33:01 <fasta> Oh, it does work, if it is the first thing you evaluate. So, much for functional programming.
06:33:16 <fasta> view 1 followed by the previous command does not work.
06:33:28 <ivanm> Cale: nope, looks like this isn't going to work :(
06:33:29 <ivanm> @time
06:33:31 <lambdabot> Local time for ivanm is Thu Jun 25 23:33:30
06:33:38 <ivanm> and it's getting rather late for me as well
06:33:54 <Cale> ivanm: oh well...
06:37:01 <ivanm> unless we use something like collabedit?
06:37:05 <ivanm> http://collabedit.com/display?id=31097
06:37:07 <quicksilver> fasta: vacuum is quite a long way from functional programming ;)
06:37:14 <ivanm> quicksilver: how?
06:37:24 <quicksilver> fasta: vacuum is a delicate non referentially transparent probe into the internals of the RTS
06:37:28 <ivanm> it uses an FP language to analyse the compilation results of an FP language...
06:38:01 <quicksilver> no it doesn't
06:38:09 <ivanm> :o
06:38:10 <Cale> The fact that it's generating syntax errors seems avoidable.
06:38:12 <quicksilver> it uses an undocumented unspecified non-pure language
06:38:26 <quicksilver> to directly access the non-documented internals of a particular comiler
06:38:27 <uzytkownik> @pl \p x -> poke (castPtr p) ((fromInteger . toInteger . fromEnum) x)
06:38:27 <lambdabot> (. (fromInteger . toInteger . fromEnum)) . poke . castPtr
06:38:28 <ivanm> quicksilver: isn't it programmed in Haskell?
06:38:37 <quicksilver> ivanm: no, it's programmed in GHC.
06:38:40 <Cale> ivanm: It's programmed using GHC internals.
06:38:43 <ivanm> :o
06:38:51 <quicksilver> I mean, don't get me wrong, it's very very cool.
06:39:02 <fasta> Vacuum is a very nice hack, but I don't think it's something I will actually use.
06:39:02 <quicksilver> but fasta's comment "so much for functional programming" is very much to the point
06:39:05 <ivanm> Cale: so either you guys go ahead and discuss it without me, or we use a different approach
06:39:11 <quicksilver> it is quite non-referentially transparent.
06:39:32 <ivanm> quicksilver: though it's non FP only because it needs to use the GHC internals rather than not being possible in an FP language?
06:39:57 <quicksilver> ivanm: it's accessing the internals of the implementation model
06:40:04 <quicksilver> it's checking if thunks ahve been evaluated and so on
06:40:07 <quicksilver> looking at thunk types
06:40:09 <quicksilver> comparing addresses
06:40:13 <Cale> ivanm: right. It lets you see things in a way which is not referentially transparent and exposes the mutation involved in lazy evaluation.
06:40:15 <ivanm> *nod*
06:40:33 <RyanT5000> might it be possible to implement a pretty good serialization system using the same basic stuff as vacuum?
06:40:44 <RyanT5000> also, can vacuum handle functions?
06:40:56 <Cale> RyanT5000: I wouldn't rely on it...
06:41:11 <RyanT5000> hm
06:41:21 <RyanT5000> i've always wanted serialization that works on the thunk level :-/
06:41:40 <RyanT5000> and that supported closures, etc.
06:41:43 <Axman6> hmm, haskell.org is being very slow to download the linux binaries from :\
06:41:48 <Cale> Well... it would be a great idea to do something like that, if you were doing it from inside GHC or another Haskell implementation.
06:41:53 <Axman6> 1.5KB/s
06:41:55 <MyCatVerbs> I think byorgey was working on something like that?
06:42:28 <Cale> But as long as you're just using the GHC API to inspect those runtime datastructures, I think it's probably hard to ensure that it won't just flake out on you. :)
06:42:38 <RyanT5000> ah
06:42:52 <RyanT5000> is it just not stable enough yet, or is there some more fundamental issue?
06:43:08 <RyanT5000> i just want stuff like ocaml's fancy serializable delimited continuations :P
06:44:36 <quicksilver> Somebody did do some kind of hack to read/write haskell values with maximal sharing
06:44:46 <MyCatVerbs> Oh, actually I think it was maybe Baughn?
06:44:48 <quicksilver> I can't remember if it relied on an Eq instance or whether it cheated.
06:44:57 <ivanm> anyway, I'm falling asleep here
06:44:59 <ivanm> g'night all
06:44:59 <Cale> Well, first of all, the view of things which RTClosureInspect gives you is very convoluted and probably subject to change.
06:45:04 <Cale> ivanm: g'night
06:45:18 <Cale> ivanm: We'll probably figure out a good way to work on this tomorrow :)
06:45:23 <ivanm> right ;-)
06:45:24 <Axman6> hmm, maybe it's my connection that's slow
06:45:30 <Cale> (or later today, in my case)
06:45:52 <ivanm> I've asked the guy that wrote the patch supposedly fixing the net6 problem how he applied it in the ebuild, so maybe I _will_ be able to use gobby tomorrow
06:46:03 <ivanm> Axman6: yes, maybe it's all just you... ;-)
06:47:01 <marcot> Hello, how can I use UnknownLicense in a .cabal file?  I've never got to make this work.  All I get is: Parse of field 'license' failed.
06:47:16 <dcoutts> marcot: you don't use UnknownLicense directly
06:47:23 <dcoutts> marcot: what are you really trying to do?
06:48:26 <marcot> dcoutts: The package I've done uses the MIT license.  I thought it would be better to use UnknownLicense "MIT", than OtherLicense.
06:49:10 <dcoutts> marcot: you'd just say license: MIT
06:49:21 <dcoutts> and that would become an unknown license
06:49:46 <dcoutts> though since it's known in the latest Cabal, you could upload that to hackage
06:49:58 <dcoutts> though everyone building with Cabal 1.6 will get the warning
06:51:21 <marcot> dcoutts: Nice to know about this cabal feature.  I think this should be mentioned in the Cabal users guide.  As it is now, I thought I should use only the Constructors of the License type.
06:52:19 <dcoutts> marcot: yeah, the user guide should list the valid values
06:52:28 <dcoutts> rather than referring to the type
06:52:35 <Cale> http://picturesforsadchildren.com/index.php?comicID=274 :)
06:54:11 <Cale> http://www.superpoop.com/062509/tea-party-sign-maker.jpg -- needs another "where"
06:54:51 <opqdonut> :D
07:08:31 <RyanT5000> how do you get the .tar.gz's out of cabal after you "cabal fetch" them?
07:08:37 <RyanT5000> or is that the wrong command in the first place?
07:09:58 <dcoutts> RyanT5000: see cabal unpack
07:10:06 <RyanT5000> dcoutts: ah, ok
07:16:45 <Axman6> argh, why is ghc to hude? :S
07:16:48 <Axman6> huge even
07:18:31 <Axman6> i was hoping i'd be able to install 6.10.3 on the ssh serveer at uni, but unpacked, it's about 450MB, which is most of my 600MB quota
07:23:15 <Zao> Axman6: Buy your sysadmin a cake?
07:23:34 <Axman6> heh
07:23:45 <Zao> Axman6: If it's any consolation, it's huge no matter how large your $HOME quota is.
07:23:57 <Axman6> indeed
07:24:05 <Zao> Axman6: Does the default install bundle gunk like profiling libs?
07:24:20 <Axman6> yeah, but i'd want those anyway
07:24:41 <Zao> You ought to be able to cut it in roughly half then, I'd reckon.
07:24:46 <Zao> Provided it survives it.
07:26:33 <Zao> Oh, misread you.
07:26:47 <Axman6> i could live without them though
07:27:13 <Zao> My solution until I got more space to fit my thesis work on, was to install onto the scratch area on each machine I used.
07:27:18 <totom> how do I convert a lhs file to a hs one automatically ?
07:27:33 <Zao> (all our boxen has any spare disk space after partitioning mounted free-for-all at /scratch)
07:28:00 <Zao> Quite convenient if you need to build things and not load down the home disk server, store large programs or the odd music file :)
07:29:26 * edwardk waves hello.
07:31:02 <RyanT5000> edwardk: hi
07:32:31 <edwardk> RyanT5000: its good to have a face to put with the nick. =)
07:33:31 <RyanT5000> edwardk: likewise :)
07:33:40 <RyanT5000> these meetups are a great idea
07:34:27 <edwardk> I'm trying to figure out how much I want to try to cram in to my talk for next time. I think I'll have to split it into two talks
07:35:02 <RyanT5000> haha; i'm not even going to bother trying to figure out what my talk *is* until 2 nights before, at most
07:35:31 <edwardk> One going over monoids, reducers, generators, and some palatable examples, and some subproblems in monoidal parsing, and another talking about how to actually parse that way, stable names, and other craziness.
07:35:40 <RyanT5000> since the topic is supposed to be "progress on haskell-on-iphone, or something about using haskell to make a game, or something else interesting, that occurred since the last meetup" :P
07:35:47 <edwardk> hah
07:35:59 <RyanT5000> that's cool
07:36:03 <edwardk> any plans to look deeper into HOC before then?
07:36:09 <RyanT5000> you can take the "Advanced" lecture slot, then, i guess :P
07:36:12 <RyanT5000> yeah, probably
07:36:34 <RyanT5000> we're still in the process of figuring out what things we want to build our engine out of
07:36:59 <RyanT5000> we probably don't *need* HOC, since we have a relatively small number of functions that need to be wrapped in C functions
07:37:07 <RyanT5000> but it would be nice to have it
07:37:08 <edwardk> oh, btw, the slides from my comonad talk from the previous session: http://comonad.com/haskell/Comonads_1.pdf
07:37:19 <RyanT5000> ah, cool
07:37:23 <edwardk> you had mentioned you weren't really comfortable with what comonads are
07:37:33 <edwardk> that at least helps to motivate the definitions a bit
07:37:35 <RyanT5000> yeah; i've never really read about them, only heard of them
07:37:50 <edwardk> and Control.Comonad.* in category-extras provides a ton of examples of them
07:38:02 <hackagebot> hgeometric 0.0.2.2 - A geometric library with bindings to GPC. (MarcoSilva)
07:38:04 <RyanT5000> cool; i'll take a look
07:38:51 <sm> good morning
07:39:13 <RyanT5000> good morning, sm
07:39:53 <edwardk> Been spending the last 24 hours playing with a strange form of tagless gc for a haskell-like language trying to get it to the point where i could actually use it
07:40:18 <RyanT5000> hm
07:40:24 <RyanT5000> have you thought about modularity in GCs?
07:40:39 <edwardk> modularity as in a pluggable gc framework?
07:40:44 <RyanT5000> more or less, yeah
07:40:46 <RyanT5000> it's an idea i was talking about with shapr and fare
07:41:03 <edwardk> i have, but i haven't been too happy with any attempts in that direction that folks have come up with to date
07:41:05 <RyanT5000> the idea is this: there's a root gc, but i can write a new gc in-language
07:41:41 <RyanT5000> you run things under the in-language gc, and the in-language's garbage (if any) is collected by the root gc
07:41:54 <RyanT5000> i wasn't aware of any previous attempts
07:42:16 <RyanT5000> although it does seem like a difficult problem
07:42:26 <edwardk> unfortunately different gc algorithms need fundamentally different guarantees from the RTS. If its a parallel gc or concurrent gc or has read barriers or write barriers, how it needs to handle semantic garbage, does it need pointer erasure on the stack, does it need safe points on back edges or allocations, do you need a mark bit in the header, card allocation, per page properties...
07:43:09 <edwardk> attempts that have tried to abstract away the gc tend to leave you with half-solutions that require ugly structures like LLVM's shadow stack, etc.
07:44:58 <RyanT5000> hm
07:45:06 <edwardk> heretofore i've been focused on how to execute gc primarily without any inter-core interop, with only needing communication to resolve distributed garbage, while trying to avoid read and write barriers. but you need invariants on the operation of the system as a whole to get all of those things
07:47:31 <edwardk> my current toy is slightly simpler. basically i'm just playing with a limited form of kind polymorphism, and having separate kinds for data, codata, tagless tuples and machine ints and doubles in a way that the kind info is used by the gc to know how to traverse into values of that kind and isn't erased, but the type info is erasable.
07:48:21 <deavid> just a question: round 8.5 => 8 ; round 8.6 => 9  ¿Why?   (round 8.501 => 9)
07:48:51 <RyanT5000> edwardk: interesting; what's the advantage of that?
07:49:00 <fasta> deavid: 1) there are a million ways to "round".  2) probably it is 8.4999999
07:49:05 <edwardk> so you can have a codata list of ints, which is lazy in the spine but strict in the values without needing a whole separate unboxed list type
07:49:45 <RyanT5000> what's codata?
07:49:51 <edwardk> RyanT5000: and you can get mostly strict semantics by working with data rather than codata, but still not have to deal with ml style syntax since codata bindings have no value restriction, so you don't need val and fun keywords messing everything up
07:50:39 <edwardk> codata is basically what you have in haskell, a value of type [a] in Haskell is a pointer to a thunk that will evaluate out to a cons cell or a nil cell when evaluated by a case statement, but until then is deferred.
07:50:58 <edwardk> data in this setting would be already evalauted to cons or nil, so you have no need to call the thunk to force the outermost layer.
07:51:04 <EvilTerran> codata is data defined in a corecursive way, isn't it?
07:51:09 <doserj> deavid: round is specified to be "round-to-even", to minimise bias
07:51:19 <edwardk> so a data list is by construction finite, and a codata list can be corecursive. you can have infinite lists, etc.
07:51:23 <defun> What is the benefit of using folds instead of recursions? In this link (http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6248#a6248) why is the second definition preferred by Haskell programmers, over the first one?
07:51:52 <edwardk> defunL: because we have fusion rules for folds that lets us potentially never need to build up the list in the first place
07:52:15 <defun> ?fusion rules?
07:52:15 <lambdabot> Unknown command, try @list
07:52:19 <edwardk> defun: look up the foldr/build fusion and stream fusion papers
07:52:30 <defun> will do. thanks.
07:52:43 <edwardk> basically you can rewrite a lot of functions that produce lists and consume them to never bother constructing the list in the first place
07:53:02 <osfameron> that's an optimization reason though
07:53:02 <edwardk> by replacing them with tight loops like you'd use in an imperative setting
07:53:18 <EvilTerran> defun, it's also a matter of abstraction; identifying that a recursion is, say, a foldr immediately tells you a fair bit about how it behaves
07:53:21 <osfameron> the construct is also "nicer" for some code - it's more about the intent of the code, rather than boilerplate
07:53:23 <edwardk> the other justification is in terms of thinking about catamorphisms, but i'm not so sold about that ;)
07:53:38 <edwardk> despite the contents of my blog to the contrary ;)
07:53:42 <Zrs> The argument I just read in Real World Haskell is that fold is a slightly more specific method, while recursion is a bit more general. Thus, faster/easier to understand once you get the hang of it, seen one seen 'em all.
07:53:44 <EvilTerran> defun, in that there are things we know to be true for any instance of foldr
07:54:31 <deavid> doserj: in a round to even, 0.5 should be rounded up; and haskell is rounding 2.5 down and 3.5 up
07:54:51 <deavid> it seems a loss precision problem
07:54:53 <doserj> > map round [0.5..10.5]
07:54:56 <lambdabot>   [0,2,2,4,4,6,6,8,8,10,10]
07:55:11 <doserj> round-to-even means the result is even
07:55:12 <defun> EvilTerran: so it is more about programmer convenience, and not about optimization?
07:55:12 <EvilTerran> deavid, er, 0.5 should be rounded to 0 in round-to-even
07:55:15 <edwardk> deavid: you're getting bitten by the fact that you can't store numbers very precisely with floats
07:55:17 <EvilTerran> seeing as 0 is even
07:55:32 <EvilTerran> likewise, 2.5 should be rounded down, and 3.5 up
07:55:45 <edwardk> hrmm
07:55:51 <EvilTerran> defun, well, it's both
07:55:59 <defun> oh. ok.
07:56:04 <deavid> here in spain, rounding is alwais 0-4 down, 5-9 up
07:56:14 <deavid> i've never seen that kind of rounding
07:56:22 <edwardk> oh, it does have round-to-even semantics
07:56:25 <edwardk> never noticed
07:56:30 <EvilTerran> defun, we know more about a foldr than we do a general recursion, regardless of whether "we" are writing the function, reading it, or compiling it
07:57:28 <EvilTerran> deavid, in the UK, we're generally taught to always round up .5 as well; rounding .5 to even is a bit more obscure
07:57:51 <deavid> so, what's the correct function to round that way?
07:58:00 <EvilTerran> to round .5s up?
07:58:06 <deavid> yes
07:58:12 <deavid> always .5 up
07:58:15 <EvilTerran> floor . (+1/2) ?
07:58:48 <Zao> EvilTerran: Banker's rounding is the odd-even one, isn't it?
07:59:51 <EvilTerran> Zao, yeah, "banker's rounding" is rounding [N ... N.5) down, (N.5 ... N+1) up, and N.5 to the nearest even
08:00:29 <EvilTerran> in situations when you have a lot of .5s, such as when dealing with money, it (in theory) balances out the rounding errors on average
08:01:05 <edwardk> zao: yeah, or unbiased rounding, or Dutch rounding, or Gaussian, etc.
08:01:22 <deavid> EvilTerran: but in some places, it is required that you round always .5 up (if i'm correct) for your accounts
08:01:41 <edwardk> deavid: banker's rounding is ironically not really used by banks ;)
08:01:48 * Zao prefers creative bookkeeping.
08:01:50 <deavid> :D
08:02:17 <Baughn> conal: What would you think of a Monoid instance for event that discards simultaneous occurences?
08:03:20 <edwardk> Baughn: i.e.; left biased?
08:03:23 <Baughn> Right
08:03:49 <Baughn> Using that notion of simultaneity, eg. not allowing it, the applicative and monad instances automatically come out right too
08:04:19 <Baughn> The question is, what are the monoid laws? I find references, but not the actual las
08:04:22 <Baughn> *laws
08:04:29 <edwardk> monoid laws are easy
08:04:37 <edwardk> associativity of the operation,m and a unit
08:04:51 <Baughn> Where mempty is supposed to be the unit. Right..
08:04:58 <edwardk> yeah
08:05:13 <Baughn> Well, that shouldn't be a problem
08:05:16 <edwardk> you can be associative and biased. thats easy, First and Last are both 'biased' in that sense.
08:05:34 <Baughn> But which would be preferable? Would you /want/ simultaneity, or is it just a bother to get rid of duplicates?
08:05:54 <Baughn> Hm..
08:06:00 <quicksilver> Baughn: not allowing simultaneity is really nasty though
08:06:04 <Baughn> Well, in some cases I'd definitely want to keep them. Duplicate times, different values
08:06:05 <edwardk> i think the problem is you really do have different use cases, some times you want to toss out simultaneous events, and some times you might not want to
08:06:10 <quicksilver> Baughn: simultaneity is very important.
08:06:28 <Baughn> quicksilver: Yep, I just convinced myself of that.
08:06:38 <Cale> I think the funny thing about events is that you actually do want it to be possible for multiple events (possibly even with the same data) to happen at the same time
08:06:39 <quicksilver> "fmap (+1) e" yields another event in which ever occurrence is simultaneous with one of e
08:06:42 <quicksilver> obviously.
08:07:03 <quicksilver> but, in more complex expresions you expect things like that ot happen relatively often.
08:07:45 <Baughn> My real problem is with Monad.
08:07:52 <edwardk> i see at least 3 resolutions, a monoid like combinator for combining an event of monoids that folds simultaneous events with the monoid operation. (technically only needing a semigroup), a combinator that merges events leaving simultaneous events in the stream, and a combinator that discards simultaneous events (basically using the first combinator one with the First semigroup)
08:08:02 <Baughn> The natural implementation of join produces lots of senseless duplicates if used to implement Applicative
08:08:12 <Cale> The question for me, regarding Events is what join should look like
08:08:27 <Cale> There are at least two possibilities which I think are reasonable
08:08:33 <Baughn> @src ap
08:08:34 <lambdabot> ap = liftM2 id
08:09:15 <quicksilver> Baughn: personally I think "joinE" is quite useful but I don't find "instance Monad Event" useful.
08:09:20 <quicksilver> just my limited experience.
08:09:28 <conal> Baughn: my preference is simultaneous events.
08:09:44 <Baughn> quicksilver: I'd have to agree, but if we've got joinE we've naturally also got Monad
08:09:45 <conal> Baughn: whether equal-valued or unequal-valued
08:09:53 <quicksilver> Baughn: only if it obeys the laws :P
08:10:07 <Baughn> Well. Yeah, which I don't want it to. 6^;
08:10:17 <Baughn> Specifically, <*> = ap seems a bad idea here
08:10:35 <quicksilver> I don't believe in instance Applicative Event, either.
08:10:50 * quicksilver notes that he discusses Reactive as if it were theology.
08:10:59 <edwardk> heh
08:11:10 * edwardk is still FRP agnostic ;)
08:11:17 <quicksilver> "Although the great prophet conal *did* say, "...", I feel his words were mistranslated.
08:11:18 <Baughn> I can think of several uses for the applicative instance. I'm keeping that one. :)
08:11:32 <quicksilver> Reactive (or Behaviour) makes a great Applicative instance.
08:11:33 <Cale> quicksilver: Why wouldn't you find the monad instance useful if join and fmap are?
08:11:36 <quicksilver> Event doesn't.
08:12:04 <quicksilver> Cale: Dunno. I just tried some of the combinators and none of them seemed to model anythign smenatically useful. >>=, mapM, etc.
08:12:04 <Baughn> I'm implementing Behaviour in terms of Event, though. And there's nary a Reactive to be found. ^^;
08:12:22 <quicksilver> well yes, you implement Behaviour in terms of Event, sure.
08:12:33 <quicksilver> but that doesn't meant that just because one is Applicative the other must be.
08:12:37 <quicksilver> That's a non-sequitur.
08:12:50 <Baughn> True. Well..
08:13:03 <Baughn> It's specifically the applicative instance for event that I see a use for.
08:13:12 <quicksilver> and that use is?
08:13:13 <Baughn> The applicative instance of behaviour too, yes, obviously, but also for event
08:13:18 <edwardk> although I have to admit i like the comonadic segment idea, even to the point of eliminating the cursorily more useful monoid instance, etc. for the same
08:13:19 <conal> what's the interest in eliminating simultaneous occurrences?
08:13:36 <Baughn> conal: Eh, just to get applicative and monad to agree. I think I've resolved to remove monad.
08:14:25 <conal> Baughn: there's a disagreement?
08:15:03 <Baughn> quicksilver: Hm. On further thought, those situations seem to fit better as behaviours even without any continuous phases
08:15:30 <Baughn> conal: See 2.2.4 in your paper
08:15:50 * conal sees 2.2.4 in his paper
08:16:31 <conal> Baughn: and?
08:17:16 <Baughn> conal: The useful applicative instance I see produces occurences every time either ef or ex change, but stepping monotonically through them, so at most size(ex) + size(ef) occurences
08:17:35 <Baughn> conal: Also incidentally producing only one occurence when ex and ef have simultaneous occurences
08:17:39 <conal> Baughn: that's the Reactive Applicative instance
08:18:06 <Baughn> conal: Yes, maybe I'm missing something there. I don't really see the diffference between Event and Reactive.
08:18:08 <conal> Baughn: are you trying to use a similar instance for Event?
08:18:27 <conal> Baughn: different meanings.
08:18:50 <conal> Baughn: a reactive value denotes a (step) function of time
08:19:08 <conal> so its instances will all be semantically consistent with (->)
08:19:08 <quicksilver> Baughn: yes, that's kind of the point.
08:19:16 <quicksilver> Baughn: btu the key difference is that Reactive always has a value
08:19:26 <quicksilver> whereas an event has a first occurrence
08:19:26 <conal> exactly
08:19:42 <quicksilver> the applicative instance for event you are describing forces you to do something odd before the first occurrence
08:19:53 <quicksilver> which is why it's a much better fit for Reactive.
08:20:01 <quicksilver> There is always the catchall one:
08:20:06 * conal nads repeatedly.
08:20:08 <quicksilver> Nothing `Stepper` fmap Just ev
08:20:18 <quicksilver> I.e. has value 'Nothing' until the first occurrence
08:20:19 <copumpkin> nads :O
08:20:26 <quicksilver> nads?
08:20:27 <Baughn> It leaves the first occurence of the event as the latter of the first occurences of the parameter events
08:20:32 <conal> hah
08:20:34 <copumpkin> sounds rude, ask conal :)
08:20:35 <quicksilver> Baughn: yeah, I know.
08:20:36 * conal also nods
08:20:43 <Baughn> quicksilver: That's odd?
08:20:45 <quicksilver> Baughn: but that's a bit arbitrary.
08:20:55 <copumpkin> boo
08:21:03 <Baughn> quicksilver: Seems useful enough for me
08:21:52 <Baughn> Well, it doesn't really matter anyway. I established that what I need from my Time type is Ord and Eq to work with minimal information.. which I pretty much already knew, but meh.
08:22:20 <Baughn> I don't need anything /else/, at least.
08:22:46 <Baughn> conal: Oh, and are you going to release the Data.* modules from reactive as a separate package?
08:24:29 <conal> Baughn: i'd like some to go into standard libs.
08:24:51 <conal> but i haven't had the focus/persistence to shepherd them there
08:27:06 <Baughn> conal: You know, I'm starting to get the impression that you wrote half of Hackage. Just started reading on TypeCompose, and what do I see?
08:28:26 <gnuvince> "Contributions to Hackage are measured in µConals"
08:28:57 <Zao> Baughn: Maybe he's just awesome at basking in other people's glory?
08:29:02 <Baughn> @remember gnuvince "Contributions to Hackage are measured in µConals
08:29:03 <lambdabot> Done.
08:29:14 <conal> :)
08:30:49 <copumpkin> edwardk: is there somewhere beyond your site I can read about the various recursion *morphisms, or is it your own research? (I've seen histomorphisms and catamorphisms elsewhere, but most of the other ones seem hard to find)
08:31:53 <jimmyjazz14> anyone know of an alternative to Text.JSON that isn't painful
08:34:13 <conal> in reactive, Event is the semantically problematic type (ctor) and the only one not based on TCMs.
08:34:31 <conal> the TCM discipline seems to work very well
08:34:57 <edwardk> copumpkin: well, they are sprinkled around the internet. I spent a lot of time rounding them up. The only two I'm personally responsible for are chrono and g_histo
08:35:08 <conal> ... where it's applied.
08:35:19 <edwardk> oh and Elgot coalgebras I guess
08:35:27 <copumpkin> aha :)
08:36:01 <edwardk> and i think i might be to blame for generalized generalized apomorphisms or something
08:36:20 <edwardk> and the generalizations of histo and futu to arbitrary density/codensity liftings of the cofree and free monads.
08:36:38 <edwardk> er cofree comonad and free monad
08:36:47 <|Jedai|> jimmyjazz14: what's painful exactly in Text.JSON ?
08:37:08 <fasta> edwardk: I would love to see you say that IRL to see whether you can say that with a straight face :)
08:37:47 <edwardk> fasta: =)
08:38:09 <copumpkin> edwardk: I still think we need a book on these :P
08:38:24 <copumpkin> you should take a few months off work and write us a nice book :)
08:38:45 <edwardk> copumpkin: heh those are at most a nice couple of chapters, once you spot the pattern you realize there isn't much to them
08:39:50 * Saizan_ remembers a discussion about the density comonad of F-algebras being related to folds
08:39:56 <copumpkin> edwardk: boo :)
08:40:02 <edwardk> it all comes down to hunting for a distributive law
08:40:23 <edwardk> saizan: yeah i started to write up something and then got distracted
08:40:34 <copumpkin> does robin hood fit into one of these, for redistributing wealth from the rich to the poor?
08:41:16 <jimmyjazz14> |Jedai|: It seems there is a lot of wrapping around the data one need to get at.
08:41:54 <edwardk> ah http://comonad.com/haskell/Origami.hs at least is part of the code in question
08:42:14 <jimmyjazz14> |Jedai|: just found this thread that seems to confirm my feelings http://markmail.org/message/4qqxte4clkt4nq54
08:42:36 <edwardk> and it includes a density comonad based Foldr data type, and one based on the contravariant Yoneda lemma IIRC
08:43:07 <edwardk> explicitly so i could compare them to Mealy and Moore machines
08:44:39 <copumpkin> oh, origami! I had forgotten about that :)
08:45:53 * Saizan_ gets the joke
08:46:13 <Baughn> conal: http://conal.net/blog/posts/another-angle-on-functional-future-values/ <-- I think understand this, but for one detail. Given a function future, you can always ask it when it /isn't/, but how do you find out when it is? Though I suppose that's fToS..
08:46:21 <edwardk> yeah i was surprised by the result there in that it was sufficient to use the contravariant yoneda lemma to get an efficient comonad
08:46:54 <edwardk> saizan: well, the post title was going to be something involving origami machines or something its a bit fuzzy now
08:47:10 * conal rereads the post
08:47:18 <edwardk> i just got sick and tired of writing all the instance definitions
08:47:36 <Baughn> conal: It's elegant and all, but I can't quite see how to read out the (simple) future value in the end
08:48:35 <Raevel> conal: your rss feed breaks in firefox
08:49:06 <conal> Raevel: what symptom?
08:49:22 <Kashyap> Hello lovely Haskell people :)
08:49:56 <edwardk> Kashyap: I see how it is. No love for the homely ones, eh? =)
08:51:14 <Kashyap> Question - What's Haskell's answer to inheritence? ... in terms of specialization - the oop folks talk about being able to extend functionality ... what aspect of Haskell compares to that?
08:51:30 <conal> Baughn: you want something more than tryFuture?
08:51:56 <adept> Kashyap: thet would be type classes, no?
08:52:05 <Kashyap> Even for typeclass, say, some Datatype has implemented "show: in a particular way and I want to extend it
08:52:09 <|Jedai|> jimmyjazz14: When I tried using it, it wasn't too awful, it depends on the usage pattern I guess
08:52:15 <edwardk> kashyap: you can make a typeclass that requires another typeclass
08:52:33 <Baughn> conal: Yes, I want a computable fToS. Or rather, I want to put data into events/behaviour/whatnot, and then get it out at the end without having to guess at the occurence times.
08:52:35 <edwardk> i.e. Eq a is required for Ord a, so if you have an instance of Ord you know it is also an instance of Eq
08:52:43 <Baughn> conal: I'm thinking specifically of LegacyAdapters
08:53:23 <Kashyap> hmmm ... sounds correct Edwarkd
08:53:25 <Baughn> conal: Because it seems to me that the tryFuture implementation for a legacy event would involve sleep calls
08:53:41 <conal> Baughn: i imagine different issues arise in getting time/data in vs getting out.
08:53:57 <edwardk> Kashyap: to take some type that someone else has built and build something like it. (i.e. with a different show method, while leaving Eq, Ord, Num, and other stuff along you usually use a newtype wrapper to make a new type. and use newtype deriving to automatically copy the instances from the wrapped value that you want
08:54:18 <hzap> Kashyap: seems like all the OO experts are saying "inheritance is bad" or something these days :)
08:55:01 <Raevel> that's a bit of an over statement i think
08:55:20 <hzap> that's why the :) at the end
08:55:21 <|Jedai|> hzap: Yeah... Which is pretty funny because if you remove inheritance from OO you really have nothing more than existential with typeclass
08:55:23 <conal> Baughn: oh, iswym.
08:55:24 <edwardk> Kashyap: since its such a pain in the neck to make newtype wrappers for everything you tend to get naturally driven to building up values using 'black box' inheritance rather than whitebox 'override' heavy inheritance.
08:55:53 <conal> Baughn: about sleep calls.  yeah, i think so.  and the blocking would usually happen not in the sleep but in computing the time argument to be passed to sleep.
08:56:15 <Kashyap> okay .... I think I understand now .... blackbox inheritence  would be like - "contains" kinda inheritance right?
08:56:47 <Saizan_> the main problem with inheritance is that "subclassing doesn't imply subtyping" while OOP languages' type systems assume it does
08:56:52 <Baughn> conal: Right. So this is interesting, but impractical.
08:57:01 <conal> Baughn: so i guess i was mistaken when i said that we don't have to implement fToS
08:57:15 <Baughn> conal: I'll go back to the "threaded Time implementation" idea, I guess
08:57:17 <conal> Baughn: impractical?
08:57:36 <Kashyap> about the new type thing you mentioned edwardk .... is that the regular feature of newtype or do I need to readup specially in the context of inheritence
08:57:45 <Baughn> conal: Well, unless you can implement fToS, I don't see how to implement something like adaptE sanely
08:58:04 <edwardk> yeah you tend to build up an object with other widgets since in haskell that is nicely represented by data Foo = Foo Bar Baz Quux -- or with the record accessor syntax. if you then wire up the methods for various class instances on Foo to the appropriate methods on its members, you get the 'black box' inheritance pattern so prevalent in oop circles these days
08:58:18 <Baughn> conal: It could be done as-is by probing at regular intervals, but that would either add latency, add cpu use, or more likely both
08:58:21 <conal> Baughn: i'll pick it up again at some point.
08:58:30 <edwardk> kashyap: its more of an idiom combined with a language feature (GeneralizedNewtypeDeriving)
08:58:36 <conal> Baughn: yeah.  i wouldn't make that trade-off.
08:58:53 <conal> Baughn: it would throw away the cheap low-latency nature of the architecture.
08:59:03 <conal> (of the reactive architecture)
08:59:24 <Baughn> conal: Mm. But if you can make ftoS work, I'm all for it. I'll.. think about it, I guess.
08:59:46 <conal> Baughn: k
09:00:28 <Kashyap> Edwardk: ... I'll check out GeneralizedNewtypeDeriving ... can you please explain the 21:27 comment a bit more? ...
09:00:31 <Baughn> I'm leaning towards an opaque Time type instead of TimeT, by the way. Simplifies things a bit, and I can control all the ways to construct them better that way
09:00:34 <conal> Baughn: is the "threaded Time implementation" idea something that has a precise & elegant formulation?
09:00:47 <Baughn> conal: Precise? Yes. Elegant? Not on your life.
09:01:04 <conal> Baughn: semantically precise?
09:01:08 <Baughn> It satisfies the semantics, I think pretty cheaply, but that's about all that can be said
09:01:25 <conal> Baughn: can you prove it satisfies the semantics?
09:01:45 <Baughn> conal: No, but I've never been trained to prove anything. I possibly could, given time to learn how.
09:02:59 <conal> Baughn: okay.  what i'm really trying to probe is whether it's a math-ish idea or a hack-ish idea.  i.e., is your confidence based seeing how it's correct or not seeing how it's incorrect.  something like that.
09:03:22 <conal> "I conclude that there are two ways of constructing a software design: One way is to make it so simple that there are obviously no deficiencies, and the other way is make it so complicated that there are no obvious deficiencies.  The first method is far more difficult."  (C.A.R. Hoare, The Emperor's Old Clothes, Turing Award lecture, 1980, [[http://scifac.ru.ac.za/cspt/hoare.htm| extracted]])
09:03:25 <Baughn> conal: It's based on seeing how it's correct, and trying to implement that.
09:03:41 <Baughn> It's just that the implementation turned out to be highly inelegant
09:03:46 <conal> Baughn: oh, cool.
09:05:50 <Baughn> conal: I've never been good at hacking, in the sense of perturbing a program until it appears to work. I never seem to get that far
09:05:54 <Kashyap> A thing I've been trying for some time is the formatted printing of a binary tree ... has anyone tried it out... basically draw the binary tree on a text mode screen? .... I am approaching it via breadthfirst traversal
09:05:55 <fasta> darcs.haskell.org seems severely underpowered. Downloading with 20KB/s is not my idea of fast.
09:06:12 <fasta> (just doing an http transfer, not using darcs)
09:07:05 <|Jedai|> Kashyap: Well the Rose Tree in Data.Tree has some pretty-printing functions
09:07:22 <Kashyap> Thanks Jedai ... I'll check it out
09:07:41 <Baughn> Kashyap: pstree isn't haskell, but pretty-prints a tree quite neatly too
09:07:41 <McManiaC> @pl \f x y -> f x == f y
09:07:42 <lambdabot> flip =<< (((.) . (==)) .)
09:07:47 <McManiaC> ug
09:07:49 <|Jedai|> Depending on how "pretty" you want it to be it may be easy or not (what shape are you aiming for ?)
09:07:51 <edwardk> Kashyap: i.e. newtype Screaming a = Screaming a deriving (Eq,Ord,Num); instance Show a => Show (Screaming a) where show (Screaming a) = show a ++ "!!!"
09:08:05 <edwardk> Kashyap: sorry was afk for a sec
09:08:45 <Kashyap> no problem edwardk ... thanks ... for the example
09:09:32 <edwardk> kashyap: Data.Map has pretty printers for trees in both preorder and inorder traversal in its debugging code
09:09:33 <edwardk> you can hijack the code for that
09:09:45 <Kashyap> well...when you say preorder/inorder ...... you mean, list the things in the tree in a linear fashion right?
09:09:50 <edwardk> http://www.haskell.org/ghc/docs/latest/html/libraries/containers/Data-Map.html#21
09:09:58 <jmcarthur_work> Baughn, is this idea you and conal are talking about a monad to keep events and behaviors synced properly, in a sense? i toyed with that idea but didn't stick with it because i couldn't find a way to make it easy to reason about when using it
09:10:16 <jmcarthur_work> Baughn, on the interface level, it didn't make any sense that some functions required it and some didn't
09:10:27 <edwardk> kashyap: i mean whether the tree is drawn as a hanging tree or with the nodes inline
09:10:36 <Baughn> jmcarthur_work: No, it's reactive's Time type
09:10:38 <jmcarthur_work> not sure if that gets to what it actually does, even
09:10:39 <Kashyap> oh cool...that's what I want
09:10:58 <fasta> conal: do you have some test applications for reactive to be able to judge its value/performance?
09:11:26 <conal> fasta: no
09:11:27 <Baughn> jmcarthur_work: It's.. incredibly hard to get right, really. It needs some a very /weird/ implementation, for things like 'compare t1 t2' to work before one or the other is fully defined..
09:12:04 <fasta> conal: also no private ones?
09:12:16 <Baughn> jmcarthur_work: So far it's uncovered at least three GHC bugs. ^^;
09:12:25 <jmcarthur_work> yes
09:12:51 <conal> fasta: there are QC tests and there's reactive-fieldtrip.  right now, reactive is broken pretty badly.
09:12:55 <jmcarthur_work> Baughn, while GHC bugs should be fixed, i think exploring such unfamiliar territory is evidence that something might be wrong with the approach
09:13:31 <conal> jmcarthur_work: wrong in what sense(s)?
09:14:57 <jmcarthur_work> conal, getting into areas that rely so heavily on vaguely specified primitives
09:15:14 <conal> jmcarthur_work: yeah.  that part's a real drag.
09:16:06 <quicksilver> it's certainly a shame that what conal wanted to achieve didn't appear to be implementable in haskell.
09:16:15 <quicksilver> I'm not sure what deep conclusions to draw from that.
09:16:28 <jmcarthur_work> conal, i don't particularly see anything wrong with that in principle, but i can't see an implementation as elegant if it relies on undocumented behavior
09:16:32 <conal> i've never been content to hang out in the well-tried spaces.
09:16:51 <conal> jmcarthur_work: do you mean the implementation of unamb?
09:16:53 <jmcarthur_work> or nonexistent behavior, as the case may be :\
09:16:53 <quicksilver> he certainly discovered some very interesting GHC RTS bugs whilst trying various extension tricks, though ;)
09:16:54 <Cale> I don't think it's that it's not implementable in any absolute way...
09:17:09 <SamB> well, the solution is obviously to file bugs about them being so vaguely documented
09:17:17 <quicksilver> Cale: what conal wanted wasn't achievable.
09:17:30 <Cale> quicksilver: what in particular are you talking about?
09:17:35 <quicksilver> Cale: where "what conal wanted" has some fairly precise requirements in terms of sharing
09:17:40 <quicksilver> and purity of interface
09:17:42 <jmcarthur_work> conal, well, for example, the whole thing about GHC threads not suspending until allocation. not something we should have to worry about, but nothing inherently wrong with ghc working that way either
09:17:45 <conal> jmcarthur_work: my goal is for reactive to have an elegant implementation in terms of unamb.  and somehow also get unamb's implementation on solid ground.
09:17:45 <Cale> uh, oh.
09:17:53 <jmcarthur_work> conal, that is acceptable then
09:17:55 <SamB> quicksilver: what function are we talking about now ?
09:18:06 <Cale> I took it to mean the reactive programming model.
09:18:14 <SamB> jmcarthur_work: I say there is something inherently wrong with it
09:18:25 <quicksilver> SamB: well its a tangled web, but I think Event mappend is as good a starting place as any.
09:18:50 <SamB> jmcarthur_work: and SPJ does too, seeing as he filed http://hackage.haskell.org/trac/ghc/ticket/367 himself
09:18:58 <quicksilver> SamB: basically the problems about getting Event mappend to correctly return partial information without blocking, and return correct information when it's ready
09:19:13 <gwern> http://code.google.com/p/gitit/issues/detail?id=53 <-- man, windows is so lame
09:19:14 <quicksilver> is (one way into) the starting point of why you need unamb or a similar extension mechanism.
09:19:28 <jmcarthur_work> SamB, let me word it this way. it sucks and should be considered a bug, but it's not in violation of specifications
09:19:41 <SamB> jmcarthur: oh, sure
09:20:09 <SamB> that's only because threading isn't really specced at all, though, and a technicality
09:20:21 <Cale> I have a feeling that perhaps by first defining the reactive primitives and means of combination via a GADT and implementing everything as an interpreter/compiler for that GADT, that maybe some of the problems can be tackled with less worrying about the compiler's precise implementation of everything.
09:20:39 <jmcarthur_work> i don't think that it's impossible to implement Reactive with the sharing and purity that conal wants in haskell
09:20:45 <conal> personally, i'm not too worried about these issues.  i'm doing something new.  it often takes a while to sort out implementation issues.  later they look like no big deal.  like spj's graph on type classes in his hair-shirt talk.
09:20:46 <SamB> not having a spec is NOT a valid excuse for not following what the spec would say if it existed
09:21:02 <conal> SamB: :)
09:21:08 <Zao> gwern: More like, darcs is hostile against people who try to do silly things.
09:21:32 <quicksilver> conal: well it still interests me to ask the question "why wasn't the existing haskell semantics good enough
09:21:35 <quicksilver> ?"
09:21:35 <lambdabot> Maybe you meant: . ? @ v
09:21:37 <Zao> gwern: Why do the gitit people ignore windows compat by the way?
09:21:47 <SamB> and this bug #367 could be considered as a vague spec, I guess ...
09:21:50 <Zao> gwern: Is there something fundamentally incompatible?
09:21:57 <Badger> Maybe you did!
09:21:59 <Badger> . ? @ v
09:22:01 <conal> quicksilver: me too!
09:22:38 <conal> quicksilver: as i'd like as simple/general an extension to haskell as possible.
09:22:40 <Baughn> quicksilver: I disagree that unamb is needed for implementing reactive. It'd help a lot, if it worked reliably and you don't care about performance, but it's not required.
09:22:46 <jmcarthur_work> i still see a *lot* of parallels with pure lazy evaluation, and it seems that the semantics *should* be captured by it, and yet we don't have it very easily
09:23:02 <jmcarthur_work> Baughn, that is my thoughts as well
09:23:46 <quicksilver> Baughn: that depends what you mean by "implementing reactive"
09:23:51 <deavid> there are in haskell "floating point nombers of fixed precision" (composed of  Integer Value, Int Exp)
09:23:52 <quicksilver> Baughn: (which is why I didn't say that)
09:23:52 <Cale> The mildly annoying thing about unamb is that its precondition is arbitrarily hard to verify.
09:23:53 <deavid> ??
09:24:04 <deavid> (it was a question in fact :D)
09:24:04 <quicksilver> Baughn: I said "implementing conal's ideas" or something.
09:24:12 <quicksilver> Baughn: conal's ideas had specific constraints about sharing.
09:24:17 <Cale> Is there something which would do the job and where the precondition was always obvious?
09:24:18 <quicksilver> efficiency was part of his concern.
09:24:39 <mauke> deavid: http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Fixed.html
09:24:40 <Baughn> quicksilver: Yes, I disagree that unamb is required for the sharing either. :)
09:24:41 <jmcarthur_work> quicksilver, i still don't think unamb is necessary to satisfy those concerns
09:24:47 <Cale> deavid: hmm, do you mean Float/Double?
09:25:02 <quicksilver> Baughn: I have an implementation of reactive which I believe can be made correct (although it has bugs in) and is pure haskell. But I suspect it's less efficient. (I don't know that either)
09:25:11 <gwern> Zao: it probably has to do with none of us using windows
09:25:11 <deavid> no, I'm asking about something like BCD numbers, that are based on integers
09:25:18 <conal> semantically, reactive is very similar to fran, and fran had a pretty simple implementation.
09:25:28 <Cale> deavid: ah, there is a decimal number library
09:25:30 <quicksilver> jmcarthur_work: I don't know it is. But I can't see a way to do what conal was trying to do without it or somethign similar.
09:25:31 <gwern> '"loli": Added by JinjingWang, Thu Jun 25 13:17:49 UTC 2009.' <-- o.0
09:25:36 <jmcarthur_work> quicksilver, just like oleg didn't believe lazy io was necessary to make composable IO streams (which is also what is motivating my current approach to frp)
09:25:36 <Cale> deavid: there's also fixed precision
09:25:42 <gwern> so now hackage has ponies, frowns, and lolis...
09:25:48 <quicksilver> jmcarthur_work: good analogy.
09:25:54 <jmcarthur_work> although iteratee does have a pretty bad interface right now
09:26:10 <Zao> gwern: Still, actively not bothering about a platform is weird.
09:26:11 <Cale> http://hackage.haskell.org/package/Decimal
09:26:23 <Zao> gwern: When you're using rather portable languages in the first place.
09:26:30 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Fixed.html
09:26:34 <Zao> gwern: Do you handle case ignorance then? I hear OSX is large on that.
09:26:40 <gwern> Zao: what are we going to do, shell out 300$ and blow away our linux installs just to check on a platform that none of us want to use and a number of us actively despise?
09:26:55 <conal> i don't think unamb is necessary for reactive.  i do like unamb and want to use it for a bunch of things, to make fp more modular.  like laziness does.
09:27:07 <Zao> gwern: No, but when confronted with such hurdles, pick a choice that's most probably not horribly counterproductive.
09:27:10 <gwern> Zao: and case-ignorance is darcs/git's problem, not gitit's fortunately
09:27:18 <Baughn> > ((const 2) `mappend` (const 3)) "f" -- Yaright
09:27:19 <lambdabot>   Add a type signature
09:27:28 <Baughn> ..wait, what?
09:27:37 <Cale> Zao: hmm... what platform are you talking about?
09:27:38 <gwern> Zao: how were we supposed to know the arcana of windows file systems? john was just following the WP convention of Article, Talk:Article
09:27:44 <Zao> gwern: There's nothing more _awesome_ then fighting to get something out of hackage running, and finding out that people unnecessarily use nonportable stuff.
09:28:07 <Zao> Just because they have some irrational dislike for real OSes :)
09:28:10 <Cale> Zao: oh, something with gitit and windows?
09:28:18 <C-Keen>   
09:28:32 <conal> Baughn: your 2 & 3 would have to belong to a monoid type.
09:29:01 <Baughn> conal: So there actually is a Monoid instance for functions? That's.. oh.
09:29:09 <conal> Baughn: yeah!
09:29:11 <Cale> Zao: I can imagine it's that the devs don't use Windows. If you don't have windows devs, evaluating whether something works on windows is hard.
09:29:18 <conal> Baughn: i use that instance a lot!
09:29:28 <jmcarthur_work> that instance is one of the best ones!
09:29:56 <Baughn> > show `mappend` show 2
09:29:58 <lambdabot>   Couldn't match expected type `a -> GHC.Base.String'
09:30:02 <Cale> Zao: and windows is strange enough that if you don't have people actively working on making things compatible with it, then they won't be.
09:30:03 <Baughn> > (show `mappend` show) 2
09:30:03 <mmmulani> does haskell support objects in the same fashion as scheme?
09:30:05 <lambdabot>   "22"
09:30:11 <Zao> Cale: Still, when encountering the issue, fixing it with "darcs --reserved-ok" seems overly hostile to me.
09:30:15 <Baughn> mmmulani: Does scheme support objects?
09:30:17 <conal> Baughn: *any* applicative functor gives rise to a similar monoid instance
09:30:26 <Zao> Anyway, I'm dropping this. I'm not interested in the software, and it's not really Haskell related.
09:30:27 <mmmulani> Baughn: oops, I mean structures
09:30:40 <jmcarthur_work> which allows awesome things like 1+2 :: Behavior Int
09:30:45 <Cale> Zao: what is the actual issue?
09:30:48 <gwern> Cale: go windows!
09:30:51 <Zao> Cale: http://code.google.com/p/gitit/issues/detail?id=53
09:31:22 <Twey> mmmulani: Haskell has lists, yes.  ;)
09:31:27 <Baughn> mmmulani: No.
09:31:43 <jmcarthur_work> well, if you reword that as "any applicative functor gives rise to a lot of fun type class instances"
09:31:49 * gwern begins humming america, fuck yeah! but with s/america/windows/
09:31:58 <Cale> Zao: ah, that is strange.
09:32:02 <Baughn> mmmulani: I think you can probably do the same things as R6RS records, but the interface is very different; in particular, there's little in the way of runtime reflection
09:32:14 <mmmulani> Twey: yeah, my last resort is to use tuples and helper functions
09:32:25 <Cale> Zao: (that it wouldn't accept files with :'s in them
09:32:26 <Cale> )
09:32:35 <Baughn> mmmulani: What do you want from them, exctly?
09:32:51 <Zao> Cale: I would consider it a good default to prevent trouble down the road.
09:32:57 <mmmulani> Baughn: just helper functions to access each property of a structure
09:33:04 <FunctorSalad> gwern: apparently it's a "minimum web dev DSL in Haskell"
09:33:16 <Zao> Especially as it's the path separator on OS9.
09:33:43 <Cale> (and everyone cares about OS9 compatibility, when GHC doesn't build there... ;)
09:33:54 <Baughn> mmmulani: Reader functions get autogenerated when you specify a name for a record value. Unfortunately, there are no similar writer/modifier funtions,just some syntactic sugar.
09:34:02 <jmcarthur_work> mmmulani, data Foo = Foo { foo :: Int, bar :: String } ... gives you foo :: Foo -> Int and bar :: Foo -> String
09:34:04 <Zao> Cale: Stop poking holes in my awesome arguments :)
09:34:12 <Twey> Z-encoding is the answer.
09:34:15 <gwern> OS9? more like lols9
09:34:18 <mmmulani> jmcarthur_work: sweet, that looks like what I want
09:34:25 <Twey> , zenc "Discussion:Foo"
09:34:26 <lunabot>  luna: Not in scope: `zenc'
09:34:32 <jmcarthur_work> mmmulani, and the data-accessor family of packages gives you some sugar for writing/modifying
09:34:33 <Twey> :(
09:35:04 <mauke> preflex: zenc D:F
09:35:05 <preflex>  DZCF
09:35:17 <Baughn> jmcarthur_work: Ooh. I could have used that package a week ago..
09:35:22 <Cale> I can understand the gitit devs' point of view. If it were me, I would just relax the restriction and allow : in the names. If you're using an OS where that's not allowed, get a better OS. ;)
09:35:23 <Twey> preflex: zenc Discussion:Zanzibar
09:35:24 <preflex>  DiscussionZCZZanzzibar
09:35:37 <jmcarthur_work> Baughn, some are pushing for it to go in the Platform, which would be nice
09:36:03 <Twey> Cale: I think it would be better to encode it transparently if the platform didn't support it.
09:36:07 <Baughn> jmcarthur_work: For one thing, it'd make it more likely that people would find it. :P
09:36:12 <jmcarthur_work> yes
09:36:18 <Cale> Twey: yes, if you wanted to put work into it ;)
09:36:23 <Twey> Heh
09:36:51 <jmcarthur_work> Baughn, make sure you also look at data-accessor-template and data-accessor-mtl (i think those are the right names)
09:37:01 <Cale> What if I want to put \0 in my wiki page names?!
09:37:10 <Twey> Encode it
09:37:13 <Twey> Same as anything else
09:37:17 <Cale> yeah
09:37:22 <Baughn> Can we have base64 wiki names?
09:37:40 <Twey> Encoding limitations shouldn't be visible to the user.  :)
09:37:40 <quicksilver> I think all good names include the unicode snowman
09:37:44 <Twey> Hahaha
09:38:01 <mauke> preflex: zenc ☃
09:38:01 <preflex>  z2603U
09:38:06 <quicksilver> http://unicodesnowmanforyou.com/
09:38:15 <Twey> I'm so registering ☃.com when we get Unicode domains.
09:38:26 <McManiaC> what does this mean?
09:38:26 <Cale> > encode = intercalate "x" . map (show . ord) in encode "how about encoding filenames this way?"
09:38:28 <lambdabot>   <no location info>: parse error on input `='
09:38:29 <gwern> base64 the page names, and now you're messing with the people not going through the wiki
09:38:31 <McManiaC>     Warning: Pattern match(es) are overlapped
09:38:31 <Cale> > let encode = intercalate "x" . map (show . ord) in encode "how about encoding filenames this way?"
09:38:32 <Twey> Hey, it has a cat.
09:38:32 <lambdabot>   "104x111x119x32x97x98x111x117x116x32x101x110x99x111x100x105x110x103x32x102x...
09:38:34 <McManiaC>              In a case alternative: (Just x, Just s) -> ...
09:38:36 <mauke> Twey: seems to be taken
09:38:43 <Twey> Can't be!
09:38:45 <mauke> http://xn--n3h.com/
09:38:59 <quicksilver> Twey: <snowman>.net is a CNAME for the site I just pasted.
09:39:03 <Twey> McManiaC: It means that you have two patterns that overlap on the same function
09:39:10 <Twey> So one won't be reached
09:39:21 <Cale> As long as the platform supports filenames containing lowercase x and digits 0-9, that'll work fine ;)
09:39:24 <Twey> e.g. foo _ = 3; foo x = x + 2
09:39:31 <Cale> At least until you hit the length restriction on filenames :)
09:39:45 <gwern> but we don't want base64 file names...
09:39:47 <McManiaC> Twey: can you do something like "case (f x, g y) of (Just x, Just y) -> ..." ?
09:39:52 * Baughn once wrote a file compressor that encoded the file in the filename
09:39:57 <Saizan_> Twey: that's a bith of an extreme overlapping
09:40:05 <Saizan_> Twey: i.e. complete
09:40:18 <Saizan_> McManiaC: sure
09:40:42 <Twey> quicksilver: Wow.  I wonder how much that cost.
09:40:43 <Saizan_> McManiaC: i guess you have more than one branch in that case though?
09:40:50 <McManiaC> yeh
09:41:02 <McManiaC>     Warning: Pattern match(es) are overlapped
09:41:02 <McManiaC>              In a case alternative: (Just x, Just s) -> ...
09:41:05 <McManiaC> *argh*
09:41:11 <quicksilver> well we need to see the other cases
09:41:15 <quicksilver> to explain to you how it overlaps.
09:41:22 <McManiaC> http://sprunge.us/DifA?hs
09:41:27 <mauke> McManiaC: stop pasting the same error over and over again
09:41:35 <McManiaC> sorry... i meant to paste that link :P
09:41:38 <Saizan_> McManiaC: the warning is telling you that there are some values that match at least two branches, so for those the first one will be picked
09:41:41 <quicksilver> McManiaC: you can't put the default case first.
09:41:41 <mauke> McManiaC: er. line 2.
09:41:48 <quicksilver> McManiaC: cases are tried in order
09:41:54 <quicksilver> McManiaC: that will always take the _ case
09:42:03 <Twey> Heh
09:42:06 <McManiaC> damn damn me
09:42:12 <McManiaC> *facepalm* thanks :D
09:43:20 <Taejo> anybody here know how to set the width of a page in postscript? (I'm generating PS from Haskell, so I'm hoping I'm on-topic)
09:45:21 <FunctorSalad> quicksilver: (just scrolled down from the fundamentals of unamb stuff) this book I just began reading mentions that "parallel or" (which is pretty much the same as unamb?) must be added to the minimal functional language discussed by the book, for some result about semantics to hold (something about the scott model being fully abstract)
09:46:00 <quicksilver> FunctorSalad: it's only the same as unamb if the precondition is that both branchs must give the same value (or _|_)
09:46:36 <quicksilver> not the same as a non-deterministic parallel or
09:46:53 <conal> it's easy to define parallel or via unamb
09:47:22 <FunctorSalad> what exactly does "precondition" mean here?
09:47:33 <jmcarthur_work> FunctorSalad, commute (*) x y = (x * y) `unamb` (y * x) ; por = commute (||)
09:48:09 <FunctorSalad> jmcarthur_work: yep IIRC it was that sense of por
09:49:06 <conal> FunctorSalad: what's the book you're reading (mentioning por)?
09:49:32 <FunctorSalad> the sematics of unamb is just binary supremum of the two arguments's semantics, isn't it?
09:49:50 <conal> FunctorSalad: yeah -- lub
09:50:21 <FunctorSalad> conal: Domain-Theoretic Foundations of Functional Programming, Thomas Streicher
09:50:23 <conal> FunctorSalad: i then use unamb to implement lub more generally.
09:50:27 <conal> FunctorSalad: thx.
09:50:31 <conal> @hackage lub
09:50:31 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/lub
09:55:31 <djahandarie> Hello... I have a IO (Network.HTTP.Result Response), and I want to change it into a String... how would I go about doing this?
09:56:45 * SamB wants a bookmarklet to surround the selection with <pre></pre> ...
09:57:00 <FunctorSalad_> lost connection :(
09:57:11 <FunctorSalad_> (if anyone sent something to me)
09:57:29 <djahandarie> Maybe you could help me? :P
09:57:31 <djahandarie> Hello... I have a IO (Network.HTTP.Result Response), and I want to change it into a String... how would I go about doing this?
09:57:55 <SamB> djahandarie: well, you can't actually change it into a string quite
09:58:19 <SamB> you can, however, run the action and then turn the resulting Network.HTTP.Result Response into a String
09:58:35 <djahandarie> "run the action"? How
09:58:44 <djahandarie> I'm not really good with IO stuff... or monads in general
09:59:02 <deavid> do { n <- Response }
09:59:19 <nainaide> I try to understand the define of monad sequence, anybody can help me continue?  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6249#a6249
09:59:31 <djahandarie> Okay.
09:59:40 <djahandarie> So then how would I change the n to a String?
09:59:51 <deavid> show n
10:00:07 <deavid> (but no idea, because I'm new, and never used Response methods)
10:00:31 <deavid> but show is used to translate several types to string
10:00:35 <Saizan_> nainaide: foldr f z [] = z, so ? = return []
10:00:35 <koala_man> which library do I use to parse a binary file format?
10:01:02 <Saizan_> nainaide: oh, sorry
10:01:10 <doserj> djahandarie: rspBody . fromRight, basically
10:01:35 <djahandarie> How do I get the response body?
10:01:55 <nainaide> Saizan_, why sorry?
10:02:06 <djahandarie> I'm running on a really old version of Network.HTTP, which is really pissing me off
10:02:15 <Saizan_> nainaide: what i said is wrong
10:02:59 <Saizan_> nainaide: your expansion of foldr is quite off, because you didn't consider the difference between +, an infix operator, and mcons, a prefix function
10:03:00 <nainaide> saiam, I dont understand mcons (return[]) m [] = return[] >>= \x -> m [] >>= \y -> return (return[]:m[])
10:03:42 <Saizan_> nainaide: you never have that application
10:04:02 <Saizan_> nainaide: and mcons takes 2 arguments, not 3
10:04:07 <nainaide> oh
10:04:23 <djahandarie> Okay, could someone help me with this?
10:04:25 <djahandarie> http://pastebin.com/d45a9d5e9
10:04:33 <djahandarie> I'm not entirely sure what that error is saying
10:04:50 <Saizan_> nainaide: ah, maybe you don't know that mcons (return[]) m [] is not the same as mcons (return[]) (m []) ?
10:05:11 <nainaide> yes, 2 argument,
10:05:24 <Saizan_> nainaide: f a b c == ((f a) b) c)
10:06:10 <nainaide> Saizan_, I think I gave 2 argument not three
10:06:41 <nainaide> foldr mcons (return [])   m []  )
10:06:59 <nainaide> mcons (return [])   m [] =?
10:07:04 <Saizan_> m [] is not a single argument, following haskell syntax.
10:07:19 <Saizan_> it's two distinct arguments.
10:07:49 <nainaide> I thought m [] is just a wrapped [], am I wrong?
10:08:08 <Saizan_> djahandarie: it means the surrounding code expects a result with type [t] for some t, while you've simpleHTTP (defaultGETRequest uri)
10:08:15 <mm_freak> dcoutts: yeeees!
10:08:17 <mm_freak> =)
10:08:24 <nainaide> :k []
10:08:25 <lambdabot> * -> *
10:08:27 <dcoutts> :-)
10:08:37 * dcoutts fails at irc tab completion again
10:08:40 <Saizan_> djahandarie: if you paste the code we can help
10:08:50 <Saizan_> nainaide: i think you're mixing the type and value levels
10:09:18 <Saizan_> nainaide: m [] is the function 'm' applied to an empty list
10:10:04 <Saizan_> nainaide: "m a" in sequence [m a] = .. doesn't make sense either
10:10:49 <Saizan_> nainaide: Monad m => [m a] is the type of the first argument to sequence, but its value representation is that of a list of actions
10:11:15 <Saizan_> nainaide: so you can use patterns like [], (foo:foos), etc..
10:11:35 <Saizan_> ?src []
10:11:36 <lambdabot> data [] a = [] | a : [a]
10:11:57 <nainaide> Saizan_, thanks, I still confuse , could you pls give a example of how to parse the sequence function?
10:12:16 <Saizan_> nainaide: parse?
10:12:37 <Saizan_> nainaide: you mean how to understand the definition?
10:12:37 <deech> Hi all, quick question, I have the following code: 'interact (\x -> "Got Input : " ++ x)'. The moment it is run it outputs "Got Input:" and sits there waiting for input from stdin. When I type something in it outputs it without the "Got Input :" prefix.
10:12:53 <deech> Why does it do that?
10:13:18 <Saizan_> deech: because it uses lazy IO
10:13:21 <Cale> deech: because that's how interact works
10:13:22 <nainaide> Saizan_, not parse infact , just want to understand how does the sequence work step by step?
10:13:28 <jmcarthur_work> @src interact
10:13:29 <lambdabot> interact f = do s <- getContents; putStr (f s)
10:13:48 <deech> Shouldn't it prefix all output with "Got Input
10:13:54 <deech> Shouldn't it prefix all output with "Got Input :"?
10:13:56 <Cale> deech: it does
10:14:07 <jmcarthur_work> deech, it prefixes the entire output with Got Input :
10:14:10 <Cale> It just manages to prefix it without knowing the input yet.
10:14:15 <Saizan_> nainaide: do you understand do-notation?
10:14:17 <jmcarthur_work> not each line as it sounds like you assume
10:14:32 <nainaide> Saizan_, yes, I think so
10:14:44 <deech> Oh! So I have to add a 'lines' to my function.
10:14:47 <jmcarthur_work> deech, see what happens if you do echo "foo" | yourprogram
10:15:04 <LordOfTheNoobs> deech: interact isn't (String -> String ) per line of input, but over all input received.
10:16:11 <byorgey> even if you add 'lines', it will still output "Got Input:" before receiving the input; I suggest enabling 'hSetBuffering stdout LineBuffering'
10:16:29 <jmcarthur_work> byorgey, eek, that's probably not the most educational way to go about it
10:17:44 <hackagebot> loli 2009.6.26 - A minimum web dev DSL in Haskell (JinjingWang)
10:18:35 <skorpan> wow, i join and immediately get punched in the face by loli
10:20:01 <gwern> skorpan: you're not the first to joke about loli here
10:20:06 <deavid> It's possible to define two datatypes that use the same names for the fields? :: data C = C {c1 :: Int}; data B = B { c1 :: Int}   (ghci throws me an error for that)
10:20:16 <deavid> so, it's impossible?
10:20:16 <gwern> one almost fears what other names Wang will come up with
10:20:24 <gwern> perhaps he'll write a server called shotacon
10:20:52 <gwern> Server in Haskell something something something...
10:21:26 <skorpan> gwern: you said wang...
10:21:49 <gwern> skorpan: I'm sure it's pronounced 'wong'...
10:22:59 <Saizan_> nainaide: i didn't use do-notation in the end: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6249#a6252
10:23:04 <koala_man> what's a cute library for (monadic) parsing of binary data?
10:23:06 <skorpan> hm, i wonder if loli is cool
10:23:14 <nainaide> Saizan_, Great thanks
10:23:26 <Saizan_> nainaide: that's sequence applied to a list of three actions
10:23:28 <skorpan> lack of haddock makes me a sad panda
10:23:31 <Saizan_> ?src sequence
10:23:32 <lambdabot> sequence []     = return []
10:23:32 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
10:23:32 <lambdabot> --OR
10:23:32 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
10:23:37 <FliP^2eH> I can't export variables form other modules as globals, can I?
10:23:50 <gwern> skorpan: but running haddock on upload might lead to DOS attacks oh noes
10:23:53 <FliP^2eH> I'm importing that file, but it's giving me scope errors
10:24:05 <Saizan_> nainaide: those are two alternative definitions of sequence, the first might be easier to undertand than yours ^^^^
10:24:23 <skorpan> who would ddos hackage?
10:24:26 <nainaide> Saizan_, so long explain , you are so kind!  Thank you Saizan_
10:25:07 <gwern> skorpan: the same kind of evil people who like loli, perhaps
10:25:16 <skorpan> hehe
10:26:22 <nainaide> Saizan_, I do need time to study what you write. Thank you Saizan_.
10:26:31 <Saizan_> nainaide: np :)
10:28:03 <LordOfTheNoobs> deech: main = getLine >>= (\s -> putStrLn $ "Got Input : " ++ s) >>= \_ -> main
10:29:02 <pikhq> LordOfTheNoobs: Any reason for that not being a do statement?
10:29:17 <skorpan> loli looks awesome
10:29:26 <LordOfTheNoobs> pikhq: no reason.
10:29:37 <pikhq> Alright.
10:29:43 <deavid> it's posible to define a function which can accept as its 1st arg a Char or a Int, for example?
10:29:58 <skorpan> hm...
10:30:01 <skorpan> > 'a' + 4
10:30:03 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
10:30:03 <lambdabot>    arising from the literal `4...
10:30:06 <skorpan> okay
10:30:15 <Taejo> deavid: and what will it do with that argument?
10:30:24 <pikhq> > 4 + ord 'a'
10:30:25 <lambdabot>   101
10:30:28 <skorpan> deavid: this is probably stupid but maybe: myFun :: Either Char Int -> a
10:30:28 <Taejo> > id 'a'
10:30:30 <lambdabot>   'a'
10:30:33 <Taejo> > id 4
10:30:34 <lambdabot>   4
10:30:35 <opqdonut> deavid: Either Char Int
10:30:56 <Taejo> deavid: id (:: a -> a) accepts either a char or an int as its first argument
10:30:59 <deavid> i've 2 datatypes that i mad (records) they share 3 of 4 fields. And I want some functions that could operate to both
10:31:15 <deavid> i said int and char to simplify
10:31:26 <Taejo> deavid: you could make them both instances of a typeclass
10:31:29 <LordOfTheNoobs> deavid: you could create a class and make each record type an instance
10:31:38 <monochrom> Merge them into one data type.
10:32:02 <deavid> okey :) I'll try
10:32:12 <Cale> yeah, usually there's a way to factor your types so that shared information is all in one type
10:32:46 <monochrom> data Funny = FirstCase { x :: Int } | SecondCase { x :: Int, y :: Char } | ThirdCase { y :: Char }  is pretty legal.
10:39:13 <paolino> is it possible to build executables that are statically linked against libgmp ?
10:41:57 * sm finds that cabal unpack rocks
10:47:24 * Berengal finds that python makes a pretty good link between functional programming and java
10:48:23 <jmcarthur_work> besides lambda i rarely see anything functional about python
10:48:50 <Twey> http://www.valuedlessons.com/2008/01/monads-in-python-with-nice-syntax.html
10:48:52 <gwern> (so. skorpan likes loli. how shameful)
10:49:07 <Berengal> jmcarthur_work: first class functions
10:49:26 <jmcarthur_work> but they are not particularly common in use
10:49:55 <Berengal> That's because most pythonista aren't functional programmers
10:50:19 <Twey> You can fix the language, but you can't help the user base :)
10:50:29 <Berengal> Exactly
10:51:12 <Berengal> I made a small database migration framework in python today, using jdbc
10:51:44 <Berengal> It used first class functions all over the place
10:52:07 <Berengal> But I didn't notice until I was almost done
10:53:01 * hzap is doing some python lambda stuff right now
10:53:29 <Berengal> I also developed a new type system. A type is the set of values that can pass through a given function without throwing an exception
10:53:42 <Cale> All of that code seems to be specifying which monad it's in all the time... I wonder how sequence looks.
10:54:10 <opqdonut> Cale: only the do notation requires declaring the monad I guess
10:54:38 <Twey> Yeah, the Python ‘keep it simple’ philosophy means that anything considered complicated to stupid people tends to be hidden away — but it's behind a lot of the magic
10:55:02 <Twey> Cale: Hmn.
10:55:14 <Twey> @src sequence
10:55:15 <hzap> I find I use more lambda expressions in python code than haskell :)
10:55:15 <lambdabot> sequence []     = return []
10:55:15 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
10:55:15 <lambdabot> --OR
10:55:15 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
10:55:31 <Cale> If you can't write code which is polymorphic in the monad type, there's no point in bothering to abstract over it in the first place :P
10:56:02 <Twey> hzap: That's because Haskell has decent currying and sections :-P
10:56:04 <Cale> (you might as well not even bother pointing out that anything happens to be a monad)
10:56:09 <hzap> Twey: yeah exactly
10:56:13 <Twey> Cale: *nod*
10:56:52 <hzap> Twey: and the (.) operator
10:56:54 <Twey> It looks like it should be ‘do’able (ha ha) but I admit I can't seem to compose it.
10:57:15 <Berengal> Cale: def mapM(monadType): @do(monadType);def realMapM(stuff [...]
10:57:28 <Berengal> [...] ;return realMapM
10:57:39 <Twey> I guess executing a monad is the same as running a function, there
10:57:51 <Berengal> Called like 'mapM(Maybe)(args)'
10:58:15 <deavid> I'm taking a look to the classes and instancing , but I'm lost :-S
10:58:34 <deavid> no idea about how to create a base type with the needed fields and deriving to two twpes
10:58:51 <Berengal> deavid: Classes are sets of types, and instances are proofs that the type belong in the class
10:59:08 <Cale> Berengal: ah, okay
10:59:20 <Zao> *** Exception: WriteConsole: resource exhausted (Not enough storage is available to process this command.)
10:59:21 <jmcarthur_work> deavid, type classes are not OO classes. they are more like interfaces, if anything, but even that is stretching it sometimes
10:59:28 <Zao> Has anyone else gotten that from ghci?
10:59:44 <deavid> ok, I can understand that (the first thing) (i never used interfaces)
10:59:44 <Zao> import System.Win32, :browse
10:59:49 <Twey> Zao: No o.@
10:59:51 <Berengal> Cale: Not really pretty though... I'm of the opinion that if you want to do haskell programming it should be done in Haskell
11:00:00 <Twey> Oh, it's probably Windows' fault :-P
11:00:05 <Cale> Berengal: but that means that even if you're in an appropriate @do, you still have to specify which monad it is again...
11:00:34 <Twey> The point of the @do there is just to unify the syntax, I think.
11:00:43 <Berengal> Cale: Yeah. As I said, not pretty. There are better ways to do this in python
11:00:47 <Twey> Truly, it doesn't enable any clever stuff like sequence
11:00:50 <hzap> Zao: i tried yours and got the same exception :D
11:01:17 <Berengal> Instead of Maybe, I'd use try/except, for example...
11:01:19 <Cale> As far as I'm concerned, if sequence is not easy to write, you have failed to implement the monad abstraction. :)
11:01:35 <Cale> (a sequence which works for any monad at all)
11:02:12 <Berengal> Indeed
11:02:48 <Berengal> But as for what makes a functional language... it doesn't really take much more than first class functions to earn the title in my book
11:02:50 <Twey> def sequence(lst): return map(lambda x: x(), lst)
11:03:20 <Cale> eh?
11:03:58 <mauke> sub sequence { my $x = pop; map $_->($x), @_ }
11:03:58 <Twey> The issue is that the types aren't as clearly divided as in Haskell
11:03:59 <Cale> ah, executing each of the procedures in the list?
11:04:23 <Twey> There's not a lot of difference between executing a function and running a monad — i.e. no difference between mapM and sequence
11:04:42 <Cale> er...
11:04:58 <Cale> except that now you need that to work for the list monad...
11:05:08 <Twey> I think, but it's making my head hurt :-P
11:05:09 <Cale> Is there a way to define () for lists to make that work?
11:05:14 <Twey> Yes
11:05:18 <Cale> hmm
11:05:24 <Twey> You can overload __call__()
11:05:30 <Twey> (which is what @do does)
11:05:34 <Cale> Does python have first class continuations?
11:05:46 <Twey> Kind of
11:05:50 <Berengal> Not continuations, I think...
11:06:13 <mornfall> Depends on definition of first class.
11:06:14 <mornfall> ;)
11:06:28 <Twey> Heh
11:06:36 <soupdragon> It's got that weird yeild thing, which I think is like half-assed version of reified continuations
11:06:37 <hzap> there's no call/cc kind of thing
11:06:50 <Cale> right...
11:06:52 <mauke> that sequence can't be right
11:07:06 <mornfall> soupdragon: It's probably a co-routine, not call/cc.
11:07:07 <hzap> the yield thing is like a coroutine
11:07:11 <hzap> but not a call/cc
11:07:27 <Cale> So for lists, __call__ will loop over the list yield'ing each of the elements?
11:07:39 <Cale> hmm
11:07:42 <Berengal> I'm sure you could develop a somewhat decent pattern for continuations though
11:07:55 <mornfall> Why are we talking about python, anyway? :)
11:08:07 <hzap> someone mentioned monads in python
11:08:11 <Berengal> We're exploring the reaches of functional programming
11:08:15 <mornfall> Interesting.
11:09:02 <Cale> in any case, monads are a hard abstraction to do nicely in languages without a static type system because of return
11:09:07 <mornfall> You can do monads in any language, but syntactic sugar would be sorely missed, I guess.
11:09:15 <Cale> :t return
11:09:23 <Cale> ... is lambdabot okay?
11:09:25 <edwardk> Improving garbage collection with free theorems (or at least parametricity) http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.52.1254
11:09:28 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
11:09:33 <Twey> mornfall: In BASIC?
11:09:38 <Cale> return is polymorphic in its result type
11:09:47 <Berengal> I've seen monads in assembly...
11:09:51 <hzap> you need a very powerful polymorphic type system to make this kind of types
11:09:57 <Cale> which is a hard thing for dynamically typed languages
11:10:04 <uzytkownik> Hello. Can I use MonadWriter with IO?
11:10:04 <Twey> Berengal: o.@
11:10:06 <Twey> @.o
11:10:07 <lambdabot> Not enough arguments to @.
11:10:11 <Berengal> Twey: ghc-core
11:10:25 <soupdragon> edwardk: Weird.. it doesn't cite Greg Morriset afaik
11:10:26 <mornfall> uzytkownik: I guess there's a WriterT or somesuch to be used with IO>
11:10:28 <Berengal> (Didn't understand much of it)
11:10:44 <edwardk> mornfall: and without tail calls and polymorphism life is hard ;)
11:10:47 <soupdragon> maybe I should read the actual paper before jumping t conclusions
11:10:49 <Twey> Is that really monads?  Monads are an abstraction.  If you strip away the abstraction, I don't think they're really monads any more.
11:10:59 <Twey> It's like saying you can do functions in assembly.
11:11:00 <mornfall> edwardk: Tail calls are everywhere, just not constant-space.
11:11:16 <Berengal> Twey: Abstractions are illusions anyway
11:11:17 <mornfall> edwardk: After a fashion, you can live with linear-space tailcall, most of the time.
11:11:21 <edwardk> mornfall: ok, i stand corrected. without TCO. ;)
11:11:24 <Twey> You can make a pattern that works like functions, with jumps, but they're not actually functions.
11:11:31 <Twey> Berengal: That's not really true
11:11:49 <Twey> (in programming)
11:11:54 <Berengal> Twey: They're entities only in the mind though
11:12:04 <Twey> No, they're entities in the code
11:12:08 <mornfall> Berengal: No platonic ideals?
11:12:08 <Twey> Which is much more important
11:12:15 <Twey> Haha
11:12:18 <Berengal> mornfall: They're illusions as well
11:12:18 <Twey> The form of Monad
11:12:26 <mornfall> Berengal: I have thought so.
11:12:40 <Twey> Depends if you like Wittgenstein.
11:12:54 <Berengal> Twey: Code is just text. Actually, it's just whatever bits are stored as...
11:12:56 <uzytkownik> mornfall: I meant. I have some unpure code. Unpure as speaking-by-network. I used the IO handles but I see that it might be profitable to use Writer monad. But I'm not a haskell guru so I don't know (i.e. instead of using hPutStr run a monad which may be backed by Handle or may be used by tests).
11:13:01 <Berengal> We could get very metaphysical here...
11:13:22 <edwardk> i was really impressed by that abuse of parametricity to collect more garbage. (i.e. if you're interpreting length, and you have the only reference to a list, why do you care about the elements? parametricity says they are useless)
11:13:22 <mornfall> Cale: Well, yeah, return is a problem, that would be solved by having returnIO returnFoo and returnBar in the dynamic language.
11:13:32 <Twey> Berengal: Not the point — it still has an effect on the real world
11:13:38 <Cale> mornfall: no, it's not solved
11:13:50 <mornfall> Cale: Why not?
11:13:59 <Cale> mornfall: because there's no point in calling anything a monad unless you can write code which works in any monad.
11:14:13 <edwardk> cale: agreed
11:14:16 <Berengal> Twey: Going for a different approach: Your view seems to say there's no monads in Haskell, only type classes
11:14:20 <Cale> Otherwise, why even recognise the abstraction?
11:14:24 <mornfall> Cale: Interesting stance.
11:14:34 <edwardk> the handful of lisp 'monads' i've seen have been one monad implemented without any way to share code between them
11:14:45 <Twey> Berengal: One of which typeclasses is a monad.
11:14:54 <mornfall> Cale: The abstraction may be still useful because of the common laws, eg. And way of thinking.
11:14:56 <Twey> Plus syntax, of course.
11:15:09 <mornfall> Cale: I don't think lot of my monad-using code can run in arbitrary monads.
11:15:19 <edwardk> i.e. this post in Qi which misses the point http://programmingkungfuqi.blogspot.com/2007/02/monads-in-qi.html
11:15:29 <Berengal> Twey: Disregarding the syntax for a moment, Monad is just another typeclass, no more abstract than Eq or Show
11:15:31 <Cale> mornfall: but you use things like sequence and mapM which are in Control.Monad
11:15:33 <mornfall> uzytkownik: I'm not sure I follow.
11:15:55 <Twey> Berengal: I agree
11:16:06 <Cale> mornfall: basically, the value of recognising that something is a monad in Haskell is in the fact that you get the stuff in Control.Monad, Data.Traversable, etc. for free.
11:16:13 <hackagebot> iteratee 0.2.4 - Iteratee-based I/O (JohnLato)
11:16:21 <Twey> Berengal: Why does that mean that Haskell doesn't have monads?
11:16:22 <edwardk> mornfall: monads are interesting because the laws permit the construction of general purpose combinators that make the abstraction useful
11:16:31 <mornfall> Cale, edwardk, true.
11:16:33 <Berengal> Twey: You don't program with Show though, you program with types that just so happen to have show defined on them
11:16:42 <Berengal> At least I do
11:16:49 <Twey> :t print
11:16:51 <lambdabot> forall a. (Show a) => a -> IO ()
11:17:01 <mornfall> But the languages we are talking about aren't interesting anyway, so it's pointless to try make the monads in them interesting, right? : - P
11:17:02 <Cale> Otherwise, there's absolutely no point at all in mentioning that something is a monad. It's just yet another combinator library.
11:17:36 <edwardk> Berengal: bah, existentials for the win ;) data Showable = forall a. Show a => ShowMe a
11:17:39 <mornfall> You don't get combinator libraries with python, do you?
11:17:46 <Cale> Sure, you can.
11:17:55 <Twey> Berengal: You don't program with Show, you program with showable types.  You don't program with Monad, you program with monads.
11:17:59 <hzap> although having just a Maybe "combinator library" would be useful in many languages
11:18:06 <mornfall> I mean, it's not very usual to see that.
11:18:30 <edwardk> hzap: sure but i don't want to hang around for the combinatorial explosion of libs ;)
11:18:52 <Twey> But the typeclass is unavoidable in enabling you to do that, since otherwise you can only work with one type at a time instead of all of them at once.
11:18:57 <uzytkownik> mornfall: Currently I have a generic IO monad and I'm operating on Handle. I wonder if it is possible to change it into something using Writer monad but I'm not sure if it is possible.
11:19:00 <hzap> edwardk: haha true
11:19:23 <mornfall> uzytkownik: What do you expect the Writer monad would do?
11:19:32 <Cale> Well, it's possible that people writing python libraries just don't know how to design good APIs.
11:19:44 <mornfall> uzytkownik: Writer is unrelated to IO.
11:19:46 <edwardk> MonadWriter makes me sad.
11:20:03 <byorgey> edwardk: why's that?
11:20:43 <edwardk> listen and pass aren't writing operations, they mutate stuff already written so they complicate when Writer can be put into a monad stack
11:21:04 <byorgey> oh, I didn't even know about listen and pass.
11:21:04 <Berengal> Twey: At least in my mind, Monad is an abstraction, but Show is a convenience
11:21:04 <edwardk> they really should be factored out into a different typeclass, but the MTL is too fossilized.
11:21:07 <hzap> uzytkownik: if you're operating on file Handle values, it's inherently an I/O thing
11:21:11 <byorgey> yeah
11:21:30 <byorgey> uzytkownik: you could use  WriterT w IO  instead of just IO
11:21:43 <byorgey> (where 'w' is whatever type you want to use in your Writer)
11:21:54 <byorgey> uzytkownik: then to run io actions you can wrap them in  liftIO
11:22:09 <mornfall> byorgey: I sort of suspect uzytkownik is just mis-interpreting the idea behind Writer.
11:22:13 <byorgey> and you can do 'tell' and so on as normal.
11:22:19 <uzytkownik> hzap, byorgey: I guess edwardk answered me.
11:22:39 <byorgey> he did?
11:22:46 <uzytkownik> mornfall: Not entirely - I wasn't sure about the idea
11:23:25 <byorgey> uzytkownik: if you want to *replace* IO with Writer, you can't.  If you want to *combine* them, you can do what I suggested.
11:23:26 <uzytkownik> byorgey: Yes as if listen and pass can modify the written stuff it cannot be simply send by socket
11:23:55 <uzytkownik> byorgey: I wondered if I can replace.
11:24:02 <byorgey> ok, I see =)
11:24:27 <mornfall> Oh. Do you mean that the socket code would run the "client code" in Writer and feed the result into the socket?
11:24:57 <edwardk> uzytkownik: well, i don't believe there is any law saying that listen has to actually extract the values written or that pass has to do anything ;)
11:25:42 <edwardk> uzytkownik: its there in spirit, but i haven't seen a formal requirement anywhere, you could make a writer-like class that instantiated it and just ignored pass's function and listened to mempty
11:26:06 <edwardk> then you could implement tell for your monad by writing to the socket
11:26:52 <FliP^2eH> Windows 7 Ultimate will cost $300 in retail.
11:26:56 <FliP^2eH> I'm impressed
11:26:58 <Berengal> @type tell
11:26:59 <lambdabot> forall w (m :: * -> *). (MonadWriter w m) => w -> m ()
11:27:26 <FliP^2eH> @tell type
11:27:26 <lambdabot> Consider it noted.
11:27:39 <FliP^2eH> @tell FliP^2eH Why hello.
11:27:39 <lambdabot> You can tell yourself!
11:27:43 <FliP^2eH> :(
11:27:51 <FliP^2eH> @tell lambdabot Tell THIS
11:27:51 <lambdabot> Nice try ;)
11:28:02 <Berengal> Hehe
11:28:14 <FliP^2eH> Bots are superior.
11:28:49 <Cale> :t pass
11:28:50 <lambdabot> forall (m :: * -> *) a w. (MonadWriter w m) => m (a, w -> w) -> m a
11:28:55 <FliP^2eH> @faq Can YOU, not Haskell, become self aware? Not talking about Haskell, talking about YOU! You. Not Haskell.
11:28:55 <lambdabot> The answer is: Yes! Haskell can do that.
11:29:04 <FliP^2eH> He's not as intelligent as I thought
11:29:20 <edwardk> main reason i haven't seen it anywhere i guess is that you'd need some kind of ridiculous rule like pass (return ((),mempty)) >> tell x >> fmap snd listen ~ return x
11:29:37 <edwardk> er and that doesn't even hold
11:29:45 <edwardk> because it changes what is written
11:29:50 <edwardk> heh
11:29:56 <Cale> Can't pass be implemented by simply buffering the stuff to be written?
11:30:08 <edwardk> cale: if you buffer everything forever
11:30:24 <Cale> Well, at least until the pass is done.
11:30:44 <edwardk> space leak kinda make that undesirable, because you don't know if you'll do a pass in the future
11:30:54 <edwardk> er leaks
11:31:06 <Cale> er...
11:31:11 <edwardk> or am i confused
11:31:16 <edwardk> hrmm
11:31:18 <edwardk> ah
11:31:35 <Cale> You would only have to buffer inside of any given pass
11:31:38 <edwardk> i see what you mean, if you pass a monad you run it in a buffered mode
11:31:39 <edwardk> yeah
11:32:28 <Cale> This is reminding me to work on MonadPrompt some more :)
11:32:45 <edwardk> reminds me of the P_h and P_f factorization of P_m in uu-parsinglib
11:33:41 <uzytkownik> @faq
11:33:41 <lambdabot> The answer is: Yes! Haskell can do that.
11:33:51 <Cale> (since then you could separate the choice of how to implement tell, pass and such from the actual definition of the monad)
11:34:16 <uzytkownik> @faq Can Haskell do even things that Haskell cannot do?
11:34:16 <lambdabot> The answer is: Yes! Haskell can do that.
11:35:52 <Zrs> @faq Can Haskell create a bug that even Haskell cannot solve?
11:35:52 <lambdabot> The answer is: Yes! Haskell can do that.
11:36:54 <FliP^2eH> @faq Can Haskell be the operating system of a microwave used to heat a burrito so much that even Jesus can't eat it?
11:36:54 <lambdabot> The answer is: Yes! Haskell can do that.
11:37:11 <uzytkownik> What does: class (Monoid w, MonadReader r m, MonadWriter w m, MonadState s m)  => MonadRWS r w s m | m -> r, m -> w, m -> s mean (i.e. the | part)?
11:37:15 <SamB> but, you know, jesus could wait for it to cool down
11:37:29 <FliP^2eH> He wouldn't be Jesus if he'd do that.
11:37:44 <hzap> uzytkownik: it's a "functional dependency"
11:37:54 <edwardk> uzytkownik: everything after the | are 'functional dependencies' they say given the parameter m you can figure out r w and s.
11:38:15 <edwardk> that would be more concisely written MonadRWS r w s m | m -> r w s -- but someone used the more verbose syntax.
11:39:41 <edwardk> uzytkownik: fundeps help type inference do the right thing. once i know the type of monad i'm working with i know the type of value i need to feed tell, i know the type of state i get when i get or put...
11:40:11 <hzap> edwardk: what's the RWS monad?
11:40:31 <edwardk> otherwise if i went to put 12 the type system wouldn't know that my State Int () -- was expecting an Int as the argument and could only infer i wanted to give it some Num
11:40:31 <uzytkownik> edwardk: I found article on haskell wiki. Once I know the the name I can google it :)
11:41:16 <edwardk> RWS r w s a is basically a short hand for ReaderT r (WriterT w (State s)) a -- just implemented as one big type
11:41:31 <hzap> oh thanks
11:41:57 <hzap> what's that thing good for?
11:41:59 <edwardk> since you commonly want some immutable environment, some state and some log of what you're doing, RWS is just a kitchen-sink ;)
11:42:14 <edwardk> i.e. when you are writing an interpreter or something
11:42:23 <edwardk> you can just add bits and pieces to r, w, or s as needed
11:42:24 <hzap> interesting
11:42:58 <edwardk> its not perfect because it doesn't cover exceptions,, but you need to decide what happens to w and s when you deal with exceptions anyways
11:44:13 <hzap> so you can just ErrorT on top of that and get this huge do-everything? :-)
11:44:36 <hzap> *huge do-everything monad
11:44:57 <edwardk> and if you wrap errorT around it or you wrap RWST (the transformer version of RWS) you get the semantics of whether or not you keep your log and state after an exception
11:45:28 <edwardk> and if you want one or the other but not both you need to the individual transformers
11:45:35 <edwardk> er need to use
11:46:12 <hzap> getting into some monad transformer madness here :)
11:46:53 <edwardk> heh then you can try to wrap Ran around the whole mess to see if you can make it fast) ;)
11:47:14 <hzap> and we still don't have I/O
11:47:55 <edwardk> ErrorT MyError (RWST MyEnv MyLog MyState IO) a
11:48:05 <edwardk> there, now you can pretend you're coding in C or something ;)
11:50:39 <edwardk> (Ran is my not-quite monad-transformer that tries to represent a stack of monad transformers as a right kan extension so I can in theory anyways run them faster)
11:51:56 <uzytkownik> @pl \m f -> runNntpT m >>= f
11:51:57 <lambdabot> (>>=) . runNntpT
11:52:38 <mmmulani> how do I resolve "Couldn't match expected type `Int' against inferred type `Integer'"?
11:52:47 <edwardk> @type fromIntegral
11:52:48 <lambdabot> forall a b. (Integral a, Num b) => a -> b
11:52:59 <edwardk> @type fromInteger
11:53:00 <lambdabot> forall a. (Num a) => Integer -> a
11:53:42 <edwardk> Int is an instance of Num, so you can fromInteger to get an Int from an Integer if thats what you need
11:53:51 <mmmulani> hmmmm
11:53:58 <mmmulani> I guess that would fix it
11:53:59 <edwardk> Int is also Integral so you can use that to get an Integer from an Int if you need that
11:54:09 <mmmulani> oh Int is integral
11:54:14 <edwardk> er use fromIntegral
11:54:42 <edwardk> (since Integer is an instance of Num as well)
11:54:47 <mmmulani> I can't seem to figure out why Haskell types it as an Integral though
11:55:11 <edwardk> Integral? or Integer?
11:55:51 <mmmulani> Integral
11:56:08 <hzap> Int is an Integral
11:56:27 <edwardk> not sure i get what antecedent 'it' is referring to in this case. =)
11:57:42 <mmmulani> hmmm, I use the parameter as though it is an Integer but Haskell types the parameter as though it is Integral
11:57:51 <mmmulani> how do you manually specify the type of your parameters?
11:57:58 <edwardk> > 1 :: Int
11:57:59 <lambdabot>   1
11:58:04 <edwardk> > 3 :: Integer
11:58:05 <lambdabot>   3
11:58:08 <edwardk> =)
11:58:19 <byorgey> mmmulani: can you show the code you are having trouble with?  you can paste it at hpaste.org
11:58:27 <edwardk> > 12 :: Integral a => a
11:58:28 <lambdabot>   12
11:58:37 <hzap> just remember Integral isn't actually a type
11:58:40 <byorgey> your questions don't quite make sense, for example, Integer is a type but Integral is not (it is a type class).
11:58:57 <mmmulani> ahhh
11:59:00 <edwardk> Int is an instance of Integral, and so is Integer
11:59:02 <mmmulani> sorry, I'm just learning haskell
11:59:14 <byorgey> mmmulani: no need to apologize =)
11:59:16 <edwardk> not a problem, it gets us all when we're first starting out
11:59:37 * hzap finds the haskell numerc type classes very very very confusing :-)
12:00:10 <mauke> luckily you can just use a single concrete type most of the time
12:00:14 <edwardk> hzap: heh, so do I, sadly. Mainly because they represent a compromise between a mathematical and pragmatic viewpoint that pleases neither at times ;)
12:00:21 <EnglishGent> hello :)
12:00:28 <mauke> or multiple concrete types + conversion functions
12:00:32 <byorgey> hi there EnglishGent
12:00:38 <EnglishGent> what are mauke? (curious)
12:00:41 <EnglishGent> hi byorgey :)
12:00:43 <hzap> there's something like 10 of those classes each with some minor differences
12:00:51 <mmmulani> byorgey: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6254#a6254
12:01:09 <ville> Someone killed realwordlhaskell.org or just my net acting up?
12:01:20 <byorgey> mmmulani: ok, one way to make things easier for yourself is to give your functions explicit type signatures
12:01:20 <EnglishGent> if it is then so is mine ville :|
12:01:28 <mauke> http://downforeveryoneorjustme.com/realworldhaskell.org
12:01:44 <mmmulani> byorgey: ohhh
12:01:52 <byorgey> mmmulani: for example, right above where you define 'minesAround' you could write  'minesAround :: SpotType -> BoardType -> ResultType'
12:02:07 <byorgey> where 'SpotType' and so on should be replaced by whatever types they are actually supposed to be
12:02:10 <ville> mauke: heh didn't know about that one.
12:02:23 <EnglishGent> hi copumpkin :)
12:02:29 <byorgey> mmmulani: the advantages are (1) writing the type signature first helps you figure out what you want a function to do, and
12:02:38 <byorgey> (2) the error messages you get can be more localized
12:03:07 <ville> mauke: ok it's the book.realworldhaskell.org that's down
12:03:08 <byorgey> i.e. ghc can already figure out there is a mismatch between the type you SAY a function has and the type of what you wrote, as opposed to getting an error in some place that you use the function
12:03:34 <copumpkin> what's up with the haskell-prime-private mailing list? :o
12:03:36 <copumpkin> hi EnglishGent :)
12:03:52 <mmmulani> byorgey: oh thanks
12:04:40 <byorgey> mmmulani: the reason you are getting Integer is that if you write a numeric literal like  3, it can have any numeric type, but if there is nothing to otherwise constrain it, ghc will default to using Integer
12:04:52 <byorgey> but I'm guessing it wants an Int because of !!
12:04:56 <byorgey> @type (!!)
12:04:57 <lambdabot> forall a. [a] -> Int -> a
12:05:16 <byorgey> mmmulani: you may very well just want to use Int.  but if so you need to declare it.
12:05:36 <copumpkin> does seq on an array type do nothing? it seems like it wouldn't really have much of a head or a spine to evaluate
12:06:38 <byorgey> Surely it has a constructor though.
12:06:44 <byorgey> so I'd imagine it does nothing.
12:06:50 <copumpkin> yeah
12:06:50 <byorgey> nothing useful at least.
12:06:50 <uzytkownik> @pl \w f -> catchError (runNntpT w) (runNntpT . f)
12:06:51 <lambdabot> (. (runNntpT .)) . catchError . runNntpT
12:09:18 <copumpkin> bbl :)
12:11:21 * Cale wonders if anyone has tried writing an icfp 2006 machine using harpy
12:12:47 <Elly> what's harpy?
12:12:57 <Cale> http://hackage.haskell.org/package/harpy
12:13:29 <Cale> It lets you dynamically assemble and run x86 code.
12:13:44 <thoughtpolice> harpy is pretty sweet
12:13:50 * thoughtpolice would love an x86_64 version
12:14:36 <burp> nice
12:15:02 <cizra> Hi
12:15:12 <cizra> hinotify fails to build on FreeBSD.
12:15:50 <mauke> cizra: does FreeBSD even have inotify?
12:15:52 <cizra> dunno
12:15:56 <jkramer> Bon jour
12:16:04 <cizra> But xmobar depends on hinotify.
12:16:09 <jkramer> Is there a way to catch errors in read?
12:16:12 <mauke> haha, oh wow
12:16:20 <mauke> jkramer: just use reads instead
12:16:58 <FunctorSalad_> is there some easy to use lambda calculus utility library or is it easier to roll your own?
12:17:32 <EnglishGent> btw - can someone recommend a good article on type classes & the different varieties thereof (constructor classes, multi parameter type classes, functional dependencies, etc, etc) ?
12:17:34 <FunctorSalad_> (I guess I need untyped calculus since I'm doing the typing judgments myself)
12:18:50 * EnglishGent looking for an article to chuck a friend who asked me what type-classes are all about - I know of several papers, but none of them really seem terribly newbie friendly
12:19:56 <jkramer> mauke: That's even better. :) Still, if I wanted to use read, is there a way to catch the error?
12:19:58 <ClaudiusMaximus> @where typeclassopedia
12:19:58 <lambdabot> I know nothing about typeclassopedia.
12:19:58 <lsthemes> ClaudiusMaximus: Error: "where" is not a valid command.
12:20:05 <dever> hey, so rather than do presentation on just haskell, ive decided to do a paper on eager vs. lazy evaluation, can anyone think of anything that i should cover
12:20:11 <Badger> EnglishGent: http://learnyouahaskell.com/types-and-typeclasses#typeclasses-101
12:20:12 <Badger> :)
12:20:13 <mauke> @bot
12:20:13 <lunabot>  :)
12:20:13 <lsthemes> mauke: Error: "bot" is not a valid command.
12:20:13 <lambdabot> :)
12:20:20 --- mode: ChanServ set +o mauke
12:20:21 --- kick: lsthemes was kicked by mauke (mauke)
12:20:27 <Cale> Well, typeclassopedia is more about examples :)
12:20:35 --- mode: mauke set +b *!*@m18s10.vlinux.de
12:20:49 <EnglishGent> ty Badger :)
12:20:51 <hzap> Typeclassopedia is awesome
12:20:53 <mauke> jkramer: yes, but it's evil
12:20:58 <EnglishGent> typeclassopedia?
12:21:02 <Badger> mauke: er, couldn't it be supyboy@that?
12:21:10 <Badger> I assume the owner is on the same host
12:21:35 --- mode: mauke set -o mauke
12:21:45 <hzap> EnglishGent: it's an article that explains all relationships between Functor, Monad, Arrow, Applicative, blahblahblah
12:21:54 <mauke> Badger: doesn't seem like it
12:22:03 <Badger> oh, okay
12:22:39 <mauke> jkramer: http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception-Base.html#4
12:22:51 <EnglishGent> ty hzap :)
12:23:49 <Badger> ooh
12:23:53 <Badger> that sounds interesting.
12:24:22 <cizra> Oh well. No xmobar for me, it seems.
12:24:43 <LordOfTheNoobs> EnglishGent: just tell your friend they are like java interfaces to collections of CLOS generic functions, requiring you instance all of them if you instance any of them.
12:25:11 <jkramer> mauke: Ah, so its a normal IO exception? I though it was something from deep inside the internals of haskell
12:26:23 <FliP^2eH> Is it just me or is every second .NET application just.. bad?
12:26:36 <FliP^2eH> I have not seen a SINGLE .NET app that didn't throw an unhandled error at me
12:26:45 <FliP^2eH> And there were many :(
12:27:03 <FliP^2eH> Like that framework requires you to be a bad coder
12:27:07 <jkramer> I experience the same with Java, Python and Ruby apps :)
12:27:13 <SamB> FliP^2eH: maybe you didn't notice that the ones that didn't do that were .NET apps -- only that they were bloated?
12:27:22 <jkramer> Never tried a .NET app though
12:27:23 <FliP^2eH> Probably
12:27:30 <FliP^2eH> Bloatware using .NET is very common
12:27:33 <FunctorSalad_> is there really no untyped lambda calculus utility lib on hackage?
12:27:42 <FunctorSalad_> (is it too trivial?)
12:27:43 <SamB> jkramer: it's not as annoying when it's your own bloody fault, at the command line ;-)
12:27:55 <jkramer> Hehe
12:27:56 <FliP^2eH> I believe it has to do with the rather light typing system
12:28:04 <FliP^2eH> :S
12:28:12 <jkramer> Whee, I love the beaty of Haskell oneliners \o/
12:28:20 <jkramer> main = getArgs >>= print . sum . map read
12:28:40 <SamB> FWIW, HM typing doesn't prevent that at all
12:28:53 <FliP^2eH> 1 2 3 = 6?
12:28:54 <SamB> ... though with Haskell you don't get a traceback
12:28:59 <jkramer> Right
12:29:11 <SamB> but that's not exactly a good thing :-(
12:29:24 <FliP^2eH> Not that bad
12:29:37 <jkramer> I'm rewriting some Scala examples in Haskell, just to show off to my co-workers who think Scala cool :)
12:29:38 <FliP^2eH> If you see an exception being thrown, you tend to know where it came from anyways
12:29:38 <SamB> it's just that it's not part of the execution state normally ...
12:29:42 <jkramer> http://www.scala-lang.org/node/231
12:29:42 <FliP^2eH> At least that's what I get
12:29:45 <Saizan> FunctorSalad_: utility lib?
12:29:58 <FunctorSalad_> it is bad if you're trying to find the source of some uninformative exception
12:30:01 <SamB> FliP^2eH: but you don't know what expressions lead there
12:30:12 <FunctorSalad_> maybe "error" should emit source loc by default
12:30:19 <FliP^2eH> Scala seems cool, tho
12:30:25 <FliP^2eH> Java on steroids
12:30:30 <FliP^2eH> Without VM = nice
12:30:40 <jkramer> It's still Java :(
12:30:46 <SamB> you could say that the problem is that the typesystem doesn't allow sufficient restriction of arguments ...
12:30:54 <EnglishGent> LordOfTheNoobs - my friends know what CLOS generic functions are ... but type classes arent them
12:30:58 <FunctorSalad_> Saizan: well, all the boilerplate stuff like substitution, unification, prettyprinting..
12:31:00 <jkramer> Actually you can pretty much paste normal Java code into Scala programs and it still works
12:31:07 <FunctorSalad_> (ok, unification is not that trivial)
12:31:13 <EnglishGent> I do sort of see the 'interface to a bunch of CLOS' functions concept
12:31:21 <FliP^2eH> Can't you use "__LINE__" like you could in C?
12:31:29 <FliP^2eH> Using the C preprocessor?
12:32:35 <FunctorSalad_> CPP also gives you kind polymorphism!
12:32:43 <FunctorSalad_> :]
12:34:41 <jkramer> Is there something like an "or" in pattern matching?
12:34:49 <pikhq> CPP even gives you functional programming.
12:35:03 <jkramer> Like case foo of \ 1 | 2 | 3 -> print "one of 1,2,3"
12:35:03 <mauke> jkramer: no
12:35:04 <pikhq> (note: CPP's functional programming is not Turing complete)
12:35:11 <Vq^> pikhq: functional programming in Haskell? yäy :)
12:35:16 <FliP^2eH> Guards?
12:35:20 <mauke> jkramer: case foo of n | n `elem` [1,2,3] ->
12:35:33 <jkramer> Ah, ok
12:35:35 <pikhq> Vq^: Functional programming in Haskell is, of course, much nicer. *Much* nicer.
12:35:35 <FliP^2eH> func\n | n > 0 && n < 4
12:35:41 <pikhq> Helps that it's designed with that in mind.
12:36:14 <jkramer> Maybe that was a bad example, I'm rather looking for something like case foo of \ "foo" | "bar" | "baz" -> ...
12:36:23 <jkramer> But `elem` ["foo",... should do it
12:36:30 <Vq^> pikhq: almost as nice as logic programming in the type-system
12:36:40 <pikhq> Vq^: Heheh.
12:37:35 <FliP^2eH> > case "test" of -> n | n `elem` ["test","foo","bar"] -> "Teehee!"; _ -> "Boo!"
12:37:36 <lambdabot>   <no location info>: parse error on input `->'
12:37:51 <FliP^2eH> > case "test" of n | n `elem` ["test","foo","bar"] -> "Teehee!"; _ -> "Boo!"
12:37:52 <lambdabot>   "Teehee!"
12:38:06 <FliP^2eH> Is that like.. like a guard/case hybrid?
12:38:11 <FunctorSalad_> where is the "Writer (w,a)" instance?
12:38:14 <FliP^2eH> n | func ?
12:38:18 <hzap> > case "..." of n | n `elem` ["test","foo","bar"] -> "Teehee!"; _ -> "Boo!"
12:38:19 <lambdabot>   "Boo!"
12:38:19 <FunctorSalad_> *MonadWriter
12:38:34 <pikhq> Looks like case with pattern matching to me.
12:38:57 <FunctorSalad_> MonadWriter w ((,) w), to be exact
12:39:25 <FunctorSalad_> I thought there was one
12:39:27 <hzap> i always thought you have to write | otherwise = "boo" or something
12:39:56 <FliP^2eH> case = _
12:39:59 <FliP^2eH> guards = otherwise
12:41:01 <hzap> but here you have a guard with the n `elem` stuff right? ... looks like I need to go back to the basics a bit
12:41:18 <FliP^2eH> As I said
12:41:22 <FliP^2eH> Looks like a caseguard :D
12:41:37 <FliP^2eH> I didn't know about this
12:41:40 <FliP^2eH> Looks cool to me
12:46:03 <FliP^2eH> > "\ETX02:d"
12:46:05 <lambdabot>   "\ETX02:d"
12:46:10 <FliP^2eH> aww
12:46:50 <FliP^2eH> :)
12:47:12 <mauke> no colors for you
12:47:39 <Saizan> > fun "\ETX02:d"
12:47:41 <lambdabot>   Add a type signature
12:47:44 <FliP^2eH> I always wanted to use irrsi
12:47:49 <Saizan> > fun "\ETX02:d" :: Expr
12:47:51 <lambdabot>   02:d
12:47:59 <FliP^2eH> But I always go crazy with those windows
12:48:06 <FliP^2eH> Can't find my channels back :(
12:48:38 <byorgey> hehe, yeah, irssi + better window model would be fantastic.
12:49:08 <byorgey> has anyone ever tried writing an IRC client in Haskell?  ISTR something like that from a while ago.
12:49:15 <mauke> how many channel windows do you have open?
12:49:20 <FliP^2eH> 13
12:49:22 <Zao> 51.
12:49:25 <skorpan> be cool, use emacs
12:49:35 <mauke> 13 is no problem in irssi :-)
12:49:36 <monochrom> 1
12:49:41 <FliP^2eH> byorgey: I've written one! An automatic one!
12:49:51 <FliP^2eH> Yea yea bots, everyone's got one :(
12:50:06 <gnuvince> @src split
12:50:07 <lambdabot> Source not found. :(
12:50:08 <gnuvince> @src splitAt
12:50:09 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
12:50:16 <mauke> [5:freenode2/#haskell(+Lcnt)] [4#perl 7#xmonad 8#tma 10#p5p] [mauke(+e)]
12:50:21 <skorpan> is there any nice haskell library for parsing (possibly broken) HTML? kind of like python's beautifulsoup?
12:50:28 <mauke> tagsoup?
12:50:52 * byorgey <3 tagsoup
12:50:54 <monochrom> tagsoup if you anticipate broken
12:51:04 <FliP^2eH> I'm using xchat wherever I've got linux :(
12:51:16 <monochrom> xchat is great. GUI is great.
12:51:21 <skorpan> cool, i'll check it out
12:51:30 <mauke> GUI is non-screen-able
12:52:25 <Zao> mauke: Virtual framebuffer?
12:52:33 <Beelsebob> or just using a bouncer
12:52:35 <mauke> huh?
12:52:45 <monochrom> Many great things are non-screen-able. iPod Touch is non-screen-able.
12:53:06 <Saizan> iPod Touch is great?
12:53:09 <Beelsebob> bouncers connect to IRC and give you a permanent presense mauke, while your client connects to the bouncer and reads logs etc from there
12:53:12 <skorpan> hehe
12:53:28 <Beelsebob> Saizan: fairly, yes
12:53:32 <monochrom> iPod Touch is great. I have one and I like it.
12:53:47 <Beelsebob> but I'd wait until the back-to-uni period is over
12:53:50 <Beelsebob> there'll be a new one released
12:54:06 <Beelsebob> (at the moment they're giving them away free with mac books for students)
12:54:13 <monochrom> That's what I did last back-to-uni period! :)
12:54:21 <Twey> mauke: That's arguable :)
12:54:42 <monochrom> How is "huh?" arguable?  <duck>
12:54:48 * Twey chuckles.
12:54:57 <Twey> One client, many interfaces.
12:55:07 <skorpan> deluge is one example
12:55:21 <skorpan> yi is another i guess
12:55:25 <skorpan> emacs, etc
12:55:34 <Twey> Aye
12:55:37 <FliP^2eH> I'm using SciTE :)
12:55:40 <FliP^2eH> It's awesome
12:56:12 <Twey> Applications that tie the interface too closely to the workings are bad.
12:56:48 <skorpan> that's a pretty bold statement
12:57:07 <skorpan> tying the interface too closely to the workings is bad
12:57:19 <FliP^2eH> Windows ties the interface to the workings! Linux does not!
12:57:21 <monochrom> It contains no information.
12:57:23 <FliP^2eH> Proof of concept!
12:57:51 <Twey> Unless the plural is (logically) used to mean ‘one or more’.
12:58:15 <monochrom> Windows doesn't tie the interface to the workings! Here is an example. You use Task Manager to try to kill a process. Sometimes that doesn't kill. Interface detached from workings.
12:58:27 <Twey> Or ‘all’ — that's also a valid interpretation for English
12:58:31 <Twey> monochrom: Hahaha
12:59:08 <Twey> skorpan: ‘Bad’ is meaningless on its own — there's some elided information, ‘in way...’
12:59:58 <skorpan> what irc client do you use to get those cool apostrophes?
12:59:59 <Twey> In this particular case, the elided information was ‘... in terms of modularity’ or possibly, even more specifically, ‘... in terms of screenability’
13:00:04 <Twey> skorpan: irssi
13:00:09 <Twey> They're single quotes :-P
13:00:22 <skorpan> right, but how do you insert them?
13:00:29 <FliP^2eH> ''
13:00:33 <FliP^2eH> ':D'
13:00:36 <Twey> My client doesn't supply them: my keyboard layout does (my IME, strictly)
13:00:36 <FliP^2eH> Just not as cool
13:00:49 <Twey> skorpan: Compose ' < for the left, and Compose ' > for the right
13:01:00 <skorpan> FliP^2eH: LEFT SINGLE QUOTATION MARK vs. APOSTROPHE
13:01:03 <Twey> Under SCIM and Xcompose by default, I think
13:01:09 <skorpan> they're different characters
13:01:15 <skorpan> Twey: cool
13:01:38 <skorpan> i sometimes wish i had a compose key...
13:01:46 <Twey> Why don't you have one?
13:02:04 <skorpan> my keyboard doesn't have one
13:02:33 <mauke> sounds like your keyboard has too few keys
13:02:52 <skorpan> hm, i suppose i could rebind that useless "menu" key to compose
13:02:55 <Twey> skorpan: So assign one
13:02:59 <Twey> I use caps lock
13:03:06 <skorpan> i use caps for ctrl
13:03:07 <mauke> skorpan: that's exactly what I did :-)
13:03:15 <mauke> my caps lock is escape, though
13:03:19 <Twey> So use ctrl for compose
13:03:31 <skorpan> i use ctrl for caps
13:03:36 <Twey> Haha
13:03:37 <skorpan> (i use caps daily believe it or not)
13:03:54 <Twey> Menu is a bit inconvenient
13:04:00 <Twey> Do you use your super key?
13:04:06 <skorpan> yep, for xmonad
13:04:22 <skorpan> maybe emacs can do this automagically for me
13:04:40 <skorpan> i.e. insert single quotes when i "mean" single quotes
13:04:50 <mauke> “mean”
13:04:54 <Twey> You mean ‘smart quotes’
13:05:20 <mauke> `àwesome quoteś´
13:05:33 * Twey laughs.
13:05:38 <skorpan> emacs can do this though: ç ş ļ
13:05:39 <Zao> mauke: Death to dead keys.
13:05:43 <Twey> I like that
13:05:49 <mauke> Zao: agreed
13:06:11 <Twey> And German quotes would look like ‚ţhiś’?  :-P
13:06:17 <mle> ๏͡_๏͡
13:06:26 <skorpan> is german really quoted like that?
13:06:27 <mauke> skorpan: şķo̧ŗp̧a̧ņ
13:06:33 * Twey laughs.
13:06:35 <Twey> skorpan: No
13:06:35 <skorpan> i read german for four years but don't remember that
13:06:50 <skorpan> maybe "took german" is better wording
13:06:52 <Twey> skorpan: It's quoted like ‚this’ or like „this”
13:06:55 <mauke> „German quotes”
13:07:03 <skorpan> can you guys do french quotes as well?
13:07:05 <Vanadium> German quotes are terrible and need to die
13:07:06 <mauke> and sometimes »like this«
13:07:11 <Twey> Sure: like « this »
13:07:19 <Twey> Vanadium: They're kind of ugly :-P
13:07:25 <Twey> mauke: *nod*
13:07:25 <Zao> »And swedish quotes, apparently».
13:07:30 <skorpan> Zao: nope
13:07:35 <mauke> I have an extra key just for «»¦
13:07:41 <Zao> skorpan: I blame wikipedia for misinformation.
13:07:44 <Shinka> Just want to make sure there isn't a more elegant to do it. I have to divide 2 integers and get a double. So I create a function divide :: Int -> Int -> Double. divide a b = (fromIntegral(a::Int) :: Double)/(fromIntegral(b::Int) :: Double) ? It must be the first time Haskell is more ugly than C and I wonder if there's a better way.
13:07:54 <Zao> skorpan: I had never encountered them in real life for the last 24-odd years before.
13:07:57 <skorpan> Zao: what article was that?
13:08:10 <mauke> Shinka: divide a b = fromIntegral a / fromIntegral b
13:08:20 <Zao> skorpan: English one on quotation marks.
13:08:24 <Twey> http://en.wikipedia.org/wiki/Quotation_mark,_non-English_usage#Finnish_and_Swedish
13:08:33 <Zao> skorpan: Which cited both »omg wtf» and »omg wtf«
13:08:41 <voker57__> Shinka: and add type signature for clearness
13:08:47 <Twey> They quote like ’this’, which I find weird
13:08:58 <Vanadium> »=
13:09:02 <Twey> Heh
13:09:17 <skorpan> Zao: i'm sure the author of that section had an interesting definition of the word "can"
13:09:22 <Zao> I find the angular quotes handy, as they rarely exist in text you wish to quote.
13:09:30 <FliP^2eH> ?
13:09:40 <Twey> Aye
13:09:42 <mauke> 「yes」
13:09:50 <Twey> I use them for Internet quotations on IRC
13:10:09 <pikhq> Mia kusenveturilo estas plena je angiloj.
13:10:16 <pikhq> Wrong channel.
13:10:28 <skorpan> oh, actually » can be used in literature, but is pretty rare even there
13:10:38 <pikhq> mauke: Japanese quotes, eh?
13:10:38 <Shinka> mauke: thank you, it's a little better.
13:11:01 <Zao> Natural language is generally silly anyway.
13:11:23 <skorpan> Zao: combinations of natural and formal languages is cool though
13:11:28 <skorpan> e.g. #lojban
13:11:30 <Twey> Lojban quotes like lu this li'u
13:11:31 <Twey> :)
13:11:36 <skorpan> i beat you to it
13:11:37 <Twey> Hehe
13:11:39 <Twey> Only just!
13:11:44 <mauke> Spın̈al Tap
13:11:47 <skorpan> a win is a win
13:12:08 <Twey> mauke: *shudder*
13:12:22 <pikhq> Ā̂̃̄̅̆̇̈́.'
13:12:29 <Twey> Whenever I see that from a distance, I have an overwhelming urge to pronounce it ‘spinyal’
13:12:39 <mauke> U+0100 (c4 80): LATIN CAPITAL LETTER A WITH MACRON [Ā]; U+0302 (cc 82): COMBINING CIRCUMFLEX ACCENT [̂]; U+0303 (cc 83): COMBINING TILDE [̃]; U+0304 (cc 84): COMBINING MACRON [̄]; U+0305 (cc 85): COMBINING OVERLINE [̅]; U+0306 (cc 86): COMBINING BREVE [̆]; U+0307 (cc 87): COMBINING DOT ABOVE [̇]; U+0308 (cc 88): COMBINING DIAERESIS [̈]; U+0301 (cc 81): COMBINING ACUTE ACCENT [́]
13:12:41 <skorpan> i remember hearing about a metal band called "trojan".. they wanted to be cool like motörhead etc, so on their cover it said "tröjan".. which literally means "the sweater" in swedish
13:12:48 <Twey> Hahaha
13:12:49 <Twey> Nice
13:12:51 <EnglishGent> coi Twey, pikhq :)
13:13:04 <Zao> skorpan: I don't want to know where you bought your sweater.
13:13:08 <skorpan> haha
13:13:28 <Twey> I read the one where the Motley Crue fans all started yelling ‘MERTLEY CRER!’
13:13:35 <Twey> (okay, it's impossible to render that in English)
13:13:40 <bos> gug
13:13:42 <Twey> coi .djent.
13:14:02 <skorpan> crüe wouldn't be pronounced "crer" anywhere i think, which makes it even more retarded
13:14:22 <Twey> I know, I was just trying and failing to represent /y/
13:15:35 <skorpan> what's /y/...?
13:15:46 <skorpan> i hope you didn't mean what i thought you meant
13:15:46 <Twey> German ü
13:15:55 <skorpan> oh
13:16:07 <Twey> (Finnish y)
13:16:15 <skorpan> yeah kind of
13:16:26 <skorpan> it actuall exists in turkish as well
13:16:46 <Twey> Turkish writes it ı, I think?
13:16:59 <skorpan> no, that's a different letter
13:17:00 * Twey looks it up.
13:17:06 <skorpan> ü is ü in turkish
13:17:49 <Twey> Oh, it's ü
13:17:50 <Twey> Haha
13:17:52 * Twey feels stupid.
13:17:55 <skorpan> :)
13:17:58 <Twey> (or is that stüpid?)
13:18:36 <ehird> is there a good tutorial for using syb?
13:18:39 <mauke> stüpıd
13:18:52 <Twey> Heheh
13:19:25 <mauke> today I've learned how to type a dotless i
13:19:37 <skorpan> compose?
13:19:43 <Twey> Compose . i
13:19:43 <monochrom> decompse?
13:19:45 <mauke> compose i .
13:19:46 <Twey> Ironically enough
13:19:51 <monochrom> heh
13:19:55 <mauke> .i doesn't work here
13:20:02 <skorpan> so how do you do ï with compose?
13:20:04 * Twey would expect it to render ï
13:20:07 <Twey> Compose " i
13:20:15 <skorpan> oh, right
13:21:08 <pikhq> I lık̇e movıṅg the dots in ıṡ.
13:21:15 <mauke> ï
13:21:15 <monochrom> http://www.vex.net/~trebla/symbols/select.html  may be useful to you. OK no accented letters, but most mathy symbols.
13:21:21 <pikhq> mauke: i . does.
13:21:27 <mauke> pikhq: that's what I said
13:21:34 <pikhq> Ah.
13:22:56 <Twey> I like to cross my ɨ's and dot my ṫ's.
13:23:22 <mauke> new compose key acquired: COMBINING DOT ABOVE
13:23:31 <Twey> Hehe
13:23:38 <jkramer> Hmm, what's the opposite of all again?
13:23:39 <Twey> What did you put it on?
13:23:39 <Raevel> GET EQUIPPED WITH
13:23:42 <Twey> jkramer: None?
13:23:48 <jkramer> I mean the function :)
13:23:49 <Twey> (not . all)
13:23:53 <jkramer> Hmm
13:23:57 <mauke> <compose> <backspace> <period>
13:23:59 <SamB> GET YOUR KEYBOARDS READY
13:23:59 <Twey> none = not . all
13:24:10 <Twey> Unless you meant any, which is a different kind of opposite
13:24:23 <jkramer> Wasn't there a prebuilt function in prelude?
13:24:41 <monochrom> @remember Twey I like to cross my ɨ's and dot my ṫ's.
13:24:41 <lambdabot> Done.
13:24:45 <jkramer> No, I really mean not . all, but I thought there already was such a thing
13:24:54 <monochrom> Not sure if UTF-8 works for @remember.
13:24:55 <Twey> Not to my knowledge
13:24:58 <Raevel> isnt none = not . any
13:24:59 <mauke> @flush
13:25:00 <lambdabot> Not enough privileges
13:25:05 <SamB> @quote cross my
13:25:06 <lambdabot> No quotes for this person. You untyped fool!
13:25:10 <Twey> monochrom: It should do.  lambdabot's Haskell.
13:25:11 <SamB> @quote cross.my
13:25:11 <lambdabot> Twey says: I like to cross my ɨ's and dot my ṫ's.
13:25:30 <SamB> Twey: I think lambdabot may not realize they're UTF-8
13:25:31 <jkramer> Hmm, correct Raevel :)
13:25:31 <mauke> @flush
13:25:34 <Twey> @hoogle (a -> Bool) -> [a] -> Bool
13:25:34 <lambdabot> Prelude all :: (a -> Bool) -> [a] -> Bool
13:25:34 <lambdabot> Prelude any :: (a -> Bool) -> [a] -> Bool
13:25:34 <lambdabot> Data.List all :: (a -> Bool) -> [a] -> Bool
13:25:40 <SamB> may just pass them through as if they are latin 1
13:25:46 <Twey> SamB: I'm pretty sure that's the case
13:25:56 <monochrom> We just discussed yesterday that "opposite" is ambiguous. :)
13:25:58 <Twey> It just passes them through as bytes, I think
13:26:01 <Twey> monochrom: *nod*
13:26:06 <ehird> is there a good tutorial for using syb? :\
13:26:12 <Twey> Lojban has three different kinds of ‘not’
13:26:13 <ehird> scrap your boilerplate
13:26:20 <Twey> ehird: Sorry, I looked but I didn't find one :-\
13:26:27 <Twey> I'd be interested to know if you do.
13:26:39 <SamB> monochrom: did you realize that coco-II didn't mean II?
13:26:52 <ehird> Twey: Aw... I just don't know how to use it :|
13:26:54 <ehird> *:\
13:27:19 <SamB> you could try reading papers with that in the name?
13:27:26 <ehird> heh
13:27:28 <ehird> very gentle
13:27:32 <pikhq> mauke: In my terminal, combining dot above is Ctrl-Shift-307.
13:27:35 * pikhq uses urxvt.
13:27:44 <mauke> same here, but I can't remember all unicodepoints
13:27:50 <monochrom> What is coco-II?
13:28:01 <SamB> pikhq: how do you get the yellow window to close?
13:28:08 <Twey> Haha
13:28:12 <pikhq> SamB: ... Esc?
13:28:15 <mauke> for extreme cases I have `uni{comb dot ab}, yielding ̇
13:28:21 <Twey> ȧ
13:28:22 <SamB> monochrom: some kind of Z80-based machine radio shack used to make, I think
13:28:26 <mauke> (IRC macros)++
13:28:49 <monochrom> coconut is not nut?...
13:28:56 <jkramer> isPrime n = all (\x -> mod n x /= 0) [2 .. n - 1]
13:29:12 <jkramer> Is there a way to write the (\x...) as a curried function, without mentioning x?
13:29:29 <LeoD> @pl \x -> mod n x /= 0
13:29:30 <lambdabot> (0 /=) . mod n
13:29:31 <Twey> jkramer: ((/= 0) . mod n)
13:29:36 <Twey> Heh
13:29:44 <jkramer> Whoah, cool
13:29:51 <mauke> welcome to @pl
13:29:56 <jkramer> Can ghci do that too? :)
13:30:04 <mauke> no
13:30:11 <mauke> does GOA still work?
13:30:14 <jrick> @faq Can ghci do that too?
13:30:14 <lambdabot> The answer is: Yes! Haskell can do that.
13:30:16 <Twey> Think so
13:30:26 <Twey> But you should really learn to do it yourself :-P
13:30:33 <jkramer> Hehe
13:30:37 <jkramer> Right
13:30:46 <LordOfTheNoobs> @faq Can Haskell divide by zero?
13:30:46 <lambdabot> The answer is: Yes! Haskell can do that.
13:30:50 <Twey> It's true
13:30:51 <Twey> > 1 / 0
13:30:53 <lambdabot>   Infinity
13:30:54 <pikhq> Point-free form isn't all that hard to figure out.
13:30:55 <Twey> \o/
13:30:58 <mauke>  Nullity
13:31:02 <Twey> Hahaha
13:31:26 <pikhq> > let 1 / 0 = Nullity in 1 / 0
13:31:27 <lambdabot>   Not in scope: data constructor `Nullity'
13:31:34 <pikhq> ^_^
13:33:54 <Twey> You know what would be cool and completely impractical?
13:34:02 <Twey> Being able to shadow specific patterns of a function
13:34:35 <Raevel> frozen gasoline?
13:34:39 <jkramer> @pl \n -> all ((0 /=) . mod n) [2 .. n - 1]
13:34:39 <lambdabot> ap (all . ((0 /=) .) . mod) (enumFromTo 2 . subtract 1)
13:34:42 <Twey> Heh
13:34:45 <mauke> so I'm listening to 梶浦由記 - Whispering Hills and I can't even read that
13:34:46 <jkramer> Uh
13:35:02 <jkramer> I'll stick with my version :)
13:35:13 <mauke> jkramer: you have chosen ... wisely
13:35:13 <monochrom> Japanese person name.
13:35:14 <jkramer> Still a cool feature
13:35:26 <Twey> mauke: かじうら・ゆき Kaziura Yuki
13:35:35 <Twey> jkramer: Yeah, point-free isn't always nicer :)
13:35:42 <Twey> Use it wisely, young Padawan!
13:35:46 <pikhq> Twey: s/zi/ji/
13:35:52 <Twey> s/ji/zi/
13:36:18 <pikhq> So you like kunrei-shiki.
13:36:24 <mauke> so you like godzilla
13:36:25 <Raevel> i find that any time a variable is mentioned twice, pl turns it into a big mess
13:36:38 <mauke> @pl \x -> f x x
13:36:39 <lambdabot> join f
13:36:59 <Raevel> s/any/pretty much any/
13:37:21 <Twey> pikhq: I use modified nihon-siki, if at all
13:37:35 <mauke> @pl \g h x -> f (g x) (h x)
13:37:35 <lambdabot> liftM2 f
13:38:32 <pikhq> Twey: I tend to use Hepburn if talking with someone that doesn't know Japanese, idiosyncratic nihon-siki otherwise...
13:39:28 <Twey> Hepburn confuses newbies and buggers up their pronunciation
13:39:34 <Twey> I don't do that to people :-P
13:40:17 <pikhq> Newbies should learn kana ASAP.
13:40:38 <pikhq> Only reason I don't type it is because I'm too lazy to get a nice IME working...
13:40:52 <Twey> Heh
13:42:01 <SamB> ソメタイメサ I　アチチイデンタヤ　エナベ　カナ　モデ
13:42:40 <mauke> hahaha
13:42:51 <monochrom> How do you say "Haskell is hazardous to newbies" in Japanese?
13:43:13 <pikhq> Hmm...
13:43:23 <SamB> mauke: did you figure out what I encoded in that ?
13:43:28 <pikhq> Haskell ha atarashii hito wo itamasemasu?
13:43:35 <skorpan> ハスケル初心者に有害なもの
13:43:50 <mauke> SamB: yeah. I don't speak japanese, so I pasted it into my unicode program
13:44:02 <SamB> I seriously do
13:44:12 <mauke> SO ME TA I ME SA I A TI TII DE N TA YA E NA BE KA NA MO DE
13:44:37 <SamB> mauke: what the?
13:44:44 * SamB wonders how SCIM came up with that
13:44:50 <mauke> well, that's basically what it said
13:44:56 <mauke> except with more KATAKANA LETTER in it
13:45:03 <ehird> hrmph
13:45:04 <Twey> Haskellは新人として危ないです。
13:45:08 <ehird> does anyone understand syb?
13:45:15 <Twey> Haskell ha sinzin tosite abunai desu.
13:45:21 <Taejo> ehird: the people who invented it?
13:45:27 <Twey> Idiomaticity questionable.
13:45:29 <ehird> apart from them
13:45:33 <pikhq> That, two.
13:45:40 <ehird> That, three.
13:45:41 <Twey> Heh
13:45:49 <mauke> needs more magical girl hasukeru-chan
13:47:00 * SamB wishes openfoundry would stop emailing him in ... chinese?
13:47:21 <Twey> Haha
13:47:40 <SamB> I mean, it's not quite spam, but I have no idea what any of it means, ever
13:48:18 <ehird> 21:21 monochrom: http://www.vex.net/~trebla/symbols/select.html  may be useful to you. OK no accented letters, but most mathy symbols. ← i see no forall
13:48:47 <monochrom> 2nd row, 4th column
13:49:01 <ehird> in my defense i'm ...not... blind
13:49:15 <monochrom> You can reply that email in Lobjan or something.
13:49:48 <Twey> Haha
13:49:58 <monochrom> hehe no you are not blind. I don't know how to arrange the buttons better. better means both easy to find symbols and save space.
13:50:21 <gwern> lojban! it's the language of the future - and always has been
13:50:46 <ehird> monochrom: use a circle pattern for the most common stuff, then a circle a bit outside that for less common, etc
13:50:47 <Twey> lu coi mabla .i .e'u pe'a ko gletu lo xasli .i ki'e .i fa'o li'u
13:50:55 <ehird> put related but less common symbols on the same "rung"
13:51:13 <ehird> so e.g. if "exists" was not much used, it could go behind forall
13:51:16 <ehird> (hypothetical)
13:51:26 * Twey sticks with the LaTeX IM from scim-tables
13:51:28 <ehird> after a click, recenter the circle so the mouse pointer's in the middle
13:51:29 <ehird> tada :-P
13:51:42 <mauke> total overkill: http://mauke.ath.cx/stuff/javascript/unicode.html?q=for+all
13:52:05 <Twey> mauke: Uh
13:52:11 <Twey> U+fdf2 (65010): ARABIC LIGATURE ALLAH ISOLATED FORM [ﷲ]
13:52:25 <Twey> Your algorithm is slightly too permissive :-P
13:52:33 <mauke> ARABIC LIGATURE «ALL»AH ISOLATED «FOR»M
13:52:36 <ehird> mauke: make one where you can type, like, (\lambda x \rightarrow x) and it replaces them as you go :D
13:52:56 <Twey> mauke: Yeah :-P
13:52:58 <Vanadium> lyx does that, no?
13:53:03 <monochrom> That is called SCIM.
13:53:07 <Twey> ehird: Like the SCIM LaTeX IM?  :-P
13:53:08 <Vanadium> Not that it works here.
13:53:17 <ehird> Twey: that doesn't search
13:53:27 <Twey> (λ x → x)
13:53:38 <Twey> It does, by prefix at least
13:53:53 <Twey> Gives you a pop-up list of options
13:54:00 <ehird> hmm
13:54:09 <ehird> well that doesn't let you do e.g. \rarr or other shorthand :P
13:54:17 <ehird> it'd just be a matter of ignoring spaces and stuff
13:54:18 <Twey> You can just type \ and get a big list
13:54:23 <Twey> Hmm
13:54:28 <Twey> Don't like that :)
13:54:58 <Twey> \rarr could be ↣ too
13:55:29 <ehird> meh
13:55:32 <ehird> it'd just be for writing
13:55:42 <ehird> mauke: if you don't do it you'll...you'll force me to.
13:56:35 <mauke> ehird: go ahead :-)
13:56:39 <ehird> >:(
13:56:47 <ehird> but i don't want to have the user downloading the list of every unicode char :P
13:57:21 <mauke> tell the browser vendors to make Unicode::UCD available from javascript
13:57:34 <mauke> and that list is incomplete
13:57:55 <mauke> mainly because javascript is limited to 16 bits per char
13:58:28 <ehird> eh?
13:58:31 <ehird> oh wow
13:58:34 <ehird> you actually have it there
13:58:36 <Zao> Why won't someone think of the cunieform demographic!
13:58:40 <ehird> 21:57 mauke: mainly because javascript is limited to 16 bits per char ←really?
13:58:52 <mauke> yeah
13:59:01 <mauke> you have to do surrogate pairs manually
13:59:24 <ehird> even in html?
13:59:31 <mauke> huh?
13:59:57 <Zao> Now how am I supposed to do my JavaScript Mahjong game? http://www.fileformat.info/info/unicode/block/mahjong_tiles/index.htm
13:59:58 <ehird> can you do &#over16bits;?
14:00:14 <mauke> that should work
14:00:47 <ehird> ok, now i have to make an index of this that lets me do \rarr and have it work ;-)
14:00:55 <ehird> maybe .*r.*a.*r.*r.* could work
14:01:33 <jkramer> Hmm, I'm trying to write some kind of string join with foldl, but I can't quite find out how to write it: foldl (++ " " ++) ""
14:01:50 <mauke> intercalate " "
14:01:55 <jkramer> With just (++) it works, but I'd like to have strwspaces between
14:02:23 <Twey> strwspaces?
14:02:55 <jkramer> Hrm
14:03:03 <mauke> oh wait
14:03:10 <jkramer> Why can't they just name intercalate join instead? :)
14:03:18 <ehird> :t join
14:03:19 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
14:03:20 <mauke> > unwords ["this", "is", "not", "enough", "broccolis"]
14:03:22 <lambdabot>   "this is not enough broccolis"
14:03:29 <jkramer> Oh
14:03:37 <jkramer> I even knew unwords :)
14:03:46 <mauke> YOU MUST BUILD ADDITIONAL BROCCOLIS
14:04:00 <jkramer> Hrhr
14:05:04 <Twey> jkramer: join is for monads
14:05:16 <Twey> intercalate is for lists
14:05:27 <mauke> haskell has the best library functions
14:05:31 <mauke> intercalate, nub, ...
14:05:44 <Twey> > join ["Hello", "Goodbye", "ARGHHhhh!"]
14:05:45 <LordOfTheNoobs> jkramer: foldl (\a b -> a ++ " " ++ [b]) "" "This is a test"
14:05:46 <lambdabot>   "HelloGoodbyeARGHHhhh!"
14:05:55 <LordOfTheNoobs> > foldl (\a b -> a ++ " " ++ [b]) "" "This is a test"
14:05:56 <lambdabot>   " T h i s   i s   a   t e s t"
14:07:47 <jkramer> Whee, yet another sweet one-liner
14:07:53 <jkramer> main = getArgs >>= putStrLn . unwords . map (map toUpper)
14:07:55 <LordOfTheNoobs> actually jkramer, this is closer: foldl (\a b -> if null a then [b] else a ++ " " ++ [b]) "" "This is a test"
14:08:29 <ehird> > unwords . map (map toUpper) $ "Hello world"
14:08:30 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
14:08:36 <ehird> > unwords . map (map toUpper) $ ["Hello world","foop"]
14:08:37 <lambdabot>   "HELLO WORLD FOOP"
14:08:40 <mauke> putStrLn . unwords . map (map toUpper) =<< getArgs
14:08:53 <jkramer> LordOfTheNoobs: I think I'll stick with unwords :)
14:08:56 <jkramer> Thanks though
14:09:02 <pikhq> > unwords . map (map toUpper) $ return "Hello, world"
14:09:03 <lambdabot>   "HELLO, WORLD"
14:09:20 <ehird> pikhq: Where return = []...
14:09:33 <pikhq> ehird: Yes, I know that.
14:09:53 <LordOfTheNoobs> jkramer: I thought you were just playing with foldl
14:10:50 <jkramer> Well, I was looking for a join function and I thought doing it with foldl would be funny :)
14:11:22 <mauke> > intersperse " " ["foo", "bar", "baz"]
14:11:23 <lambdabot>   ["foo"," ","bar"," ","baz"]
14:11:27 <mauke> > join $ intersperse " " ["foo", "bar", "baz"]
14:11:28 <lambdabot>   "foo bar baz"
14:13:37 <ehird> mauke: how does your search thing order?
14:14:09 <mauke> by number of unmatched words, ascending
14:14:38 <ehird> makes sense.
14:15:18 <ehird> what about when there's two?
14:15:52 <jkramer> Is there a page somewhere with good haskell exercise?
14:16:19 <Berengal> project euler?
14:16:26 <jkramer> I already found the 99 exercises (with actually only 88 exercises), but they all have the solutions on the same page which kind of ruins it for me :)
14:17:07 <jkramer> Hmm, project euler looks good
14:17:26 <mauke> ehird: it should keep the existing order then, which is by codepoint
14:17:44 <ehird> ah
14:17:51 <ehird> mauke: so first or last codepoint?
14:18:23 <Tsion> I'm attempting to write a (simple) IRCd in Haskell, but I'm having trouble with how I should model it with datas
14:18:25 <mauke> try searching for "latin letter" :-)
14:18:33 <mauke> codepoint ascending
14:18:43 <Tsion> eg. both Server and Channel have a users record, so I have to name one differently..
14:18:43 <LordOfTheNoobs> jkramer: these don't have any answers listed : http://www.claymath.org/millennium/
14:19:16 <byorgey> hehehe
14:19:17 <Berengal> Does anyone else beside me want an operator for mappend?
14:19:22 <byorgey> o/
14:19:23 <jkramer> Hrhr
14:19:27 <byorgey> Berengal: just use ++ .
14:19:44 <monochrom> Use ************ for mappend.
14:19:53 <SamB> byorgey: what are we going to use for mplus, then ?
14:19:55 <byorgey> import Prelude hiding (++); import Data.Monoid; (++) = mappend
14:19:58 <jkramer> LordOfTheNoobs: I think I'll try some of the euler problems first :D
14:20:07 <byorgey> SamB: oh, hrm
14:20:13 <Berengal> byorgey: Yeah, I'd love that, but ++ is already defined everywhere else.
14:20:22 <monochrom> Use +++<+++>+++ for mplus
14:20:36 <byorgey> actually, I heard quicksilver suggest +> the other day for mappend
14:20:45 <Berengal> It's okay for one module, but if I were to be using it all the time it'd get bothersome
14:20:48 <SamB> monochrom: you do realize that `mappend` and `mplus` are shorter than those?
14:20:50 <mauke> ⧺
14:20:51 <byorgey> which I now recall that I like more than ++ since it isn't symmetric.
14:21:18 <Berengal> +> could be nice...
14:21:19 <mauke> @let (⧺) x = mappend x
14:21:20 <byorgey> and affords <+ nicely to mean 'flip mappend'
14:21:20 <lambdabot>  Defined.
14:21:35 <monochrom> Hehe yes I deliberately made long symbols to be funny.
14:21:45 <byorgey> woah, ⧺ counts as an operator!?
14:22:06 <Heffalump> byorgey: yes, and very useful it is too
14:22:12 <SamB> > "hi" ⧺ "bye"
14:22:14 <lambdabot>   "hibye"
14:22:17 <SamB> wow
14:22:28 <SamB> I can't believe that actually works with lambdabot
14:23:02 <FliP^2eH> > unwords (replicate 6 "take") ++ " it away"
14:23:04 <lambdabot>   "take take take take take take it away"
14:23:07 <mauke> > sortBy (comparing length ⧺ compare) $ words " I can't believe that actually works with lambdabot"
14:23:08 <lambdabot>   ["I","that","with","can't","works","believe","actually","lambdabot"]
14:23:17 <FliP^2eH> Burning sun! burning light! TAKE TAKE TAKE TAKE TAKE IT AWAY!
14:23:23 <Berengal> Speaking of mappend, I totally blew my coworker's mind today with 'comparing length `mappend` compare'
14:23:37 <mauke> Berengal: not a perl programmer, I take it
14:23:39 <Saizan> SamB: vixey complained so often about it that we had make it work
14:23:48 <Berengal> mauke: Java
14:23:51 <mauke> hah
14:24:05 <Berengal> (He complained my powerSet function didn't return sorted values)
14:24:06 <SamB> Saizan: hehehe
14:24:26 <mauke> sort { length $a <=> length $b || $a cmp $b }  # typical perl code
14:24:50 <FliP^2eH> > let hisPowerLevel = 10000 in if hisPowerLevel > 9000 then "IT'S OVER NINE THOUSAAAAAAAND" else "Vegeta!"
14:24:52 <lambdabot>   "IT'S OVER NINE THOUSAAAAAAAND"
14:24:53 <SamB> @unpl (comparing length `mappend` compare)
14:24:54 <lambdabot> (mappend (comparing length) compare)
14:24:55 <FliP^2eH> Hm.
14:25:00 <Berengal> > let sortedPowerSet = sortBy (comparing length `mappend` compare) . filterM (const [True, False]) in sortedPowerSet [1,2,3]
14:25:02 <lambdabot>   [[],[1],[2],[3],[1,2],[1,3],[2,3],[1,2,3]]
14:25:10 <pikhq> Berengal: So, it compares by length, and then by normal comparison? That is pretty awesome.
14:25:11 * SamB wants to have that expanded out
14:25:20 <Heffalump> @type (compare `on` length) `mappend` compare
14:25:21 <lambdabot> forall a. (Ord a) => [a] -> [a] -> Ordering
14:25:24 <Berengal> pikhq: Yup
14:25:42 <Cale> SamB: expanded out in terms of what? The instance of mappend for functions, twice?
14:25:47 <Heffalump> it relies on lifting of Monoid through ->, which is quite subtle
14:25:55 <SamB> Cale: twice?
14:26:03 <Heffalump> SamB: two arguments
14:26:04 <Cale> SamB: two parameters
14:26:09 <Berengal> As with many other typeclasses, the function instance is the most interesting one
14:26:16 <SamB> but you only expand the definition once
14:26:21 <pikhq> Berengal: Yay.
14:26:22 <Heffalump> \x y -> compare (length x) (length y) `mappend` compare x y
14:26:34 <SamB> the rest is just substituting under lambdas
14:26:47 <Heffalump> the definition of mappend is in terms of mappend
14:27:05 <Heffalump> mappend f g = \a -> mappend (f a) (g a) = \a b -> mappend (f a b) (g a b)
14:27:14 <SamB> oh, well, I just want a @cale command
14:27:16 <Heffalump> the final mappend is the one on Ordering
14:27:21 <SamB> to do whatever's sensible in context
14:27:34 <Gracenotes> totally :O
14:27:42 <Cale> comparing length `mappend` compare  -->  (\x -> comparing length x `mappend` compare x) --> (\x -> \y -> comparing length x y `mappend` compare x y)
14:27:49 <jkramer> Does haskell cache some things automatically?
14:27:54 <Cale> twice.
14:28:05 <Cale> jkramer: the values of monomorphic constants
14:28:08 <Heffalump> jkramer: yes, values (not function calls)
14:28:13 <mauke> jkramer: not really
14:28:20 <gwern> well, I just had my first look at a Kindle. e-ink is really nice
14:28:24 <gwern> it looks really good
14:28:26 <Heffalump> Cale: and unconstrained polymorphic ones
14:28:28 <Cale> (and parameters to functions so long as they remain in scope)
14:28:32 <Gracenotes> but what about the DRM? Aren't you absolutely shocked, gwern?
14:28:36 <Gracenotes> ???!?! :O
14:28:52 <gwern> Gracenotes: oh, I am. I'm just commenting on the e-ink
14:28:56 <Gracenotes> don't you feel obligated to start an internet crusade!!
14:28:58 <mauke> ⁇⁈⁉
14:29:09 <jkramer> For example in a fibonacci function it would be clever to cache most of the call results
14:29:15 <gwern> the actual interface is clumsy, the display is unpleasantly slow, the 'mouse' nub stupid
14:29:19 <mauke> jkramer: haskell doesn't do that
14:29:28 <jkramer> Because they're called very often with the same args
14:29:30 <luite> gwern: you do need a bit more light to read than with a regular book though
14:29:39 <pikhq> Hmm. No memoïzing?
14:29:40 <luite> because the screen is less reflective
14:29:46 <Berengal> jkramer: It would be clever for the fibonacci function. It wouldn't be clever for the vast majority of other functions
14:29:46 <gwern> but e-ink has convinced me it has a lot of potential, and I'll keep a weather-eye peeled for Freer versions of the Kindle
14:29:48 <Heffalump> jkramer: you can do it explicitly quite elegantly with a Map though
14:29:52 <mauke> pikhq: not automatically
14:29:56 <gwern> luite: I was trying it in a dim living room, and it seemed quite good
14:30:03 <pikhq> Good to know.
14:30:04 <Berengal> However, there is Data.MemoTrie
14:30:20 <Cale> jkramer: right, so if you define a datastructure whose elements are the values of fib n, and make the implementation of fib look at that datastructure...
14:30:25 <mauke> fib :: [Integer]
14:30:35 <Berengal> fib n = memo go where go 0 = 0; go 1 = 1; go n = fib (n-1) + fib (n-2)
14:30:50 <monochrom> Is there a code optimization that recognizes your bubble-sort code and replaces it with a call to the library sorting function?
14:30:57 <Tsion> fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
14:31:21 <Tsion> fib = (fibs !!)
14:31:28 <Cale> > let fibs = [fib n | n <- [0..]]; fib 0 = 0; fib 1 = 1; fib n = fibs !! (n-1) + fibs !! (n-2) in fibs
14:31:30 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
14:31:32 <jkramer> Berengal: That looks nice, thanks
14:31:33 <gwern> monochrom: compile them to core and see!
14:31:38 <luite> gwern: have you held it next to a real (new) book or paper? It's quite a bit darker, contrast ratio is only about 7:1
14:31:44 <Cale> (that is slower than the clever zipWith version)
14:32:02 <Cale> (but still much faster than not-memoising)
14:32:02 <gwern> luite: mm. I assume that will improve over the next few years
14:32:07 <Berengal> jkramer: For fibs though, it's better to just generate the whole list at once
14:32:31 <gwern> luite: I'm sure by the time the price has fallen enough and non-DRM'd clones are available, the contrast will've improved
14:32:53 <luite> gwern: I don't think it's a huge issue, but I do find myself using a bit more light when reading from e-ink
14:32:57 <Gracenotes> f-fibby fib fibs
14:33:18 <pikhq> > let fibs = 0:1:zipWith (+) fibs $ tail fibs in fibs
14:33:19 <lambdabot>   Couldn't match expected type `[t]'
14:33:33 * pikhq screwedd something up there. Curses.
14:33:35 <Gracenotes> O⁔O
14:33:37 <mauke> pikhq: $
14:33:48 <pikhq> See, that'd do it.
14:33:55 <pikhq> > let fibs = 0:1:zipWith (+) fibs (tail fibs) in fibs
14:33:56 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
14:34:09 <Gracenotes> O‿O
14:34:25 <gwern> UTF. the lowest form of humor
14:34:25 <Gracenotes> u‿-
14:34:50 <Gracenotes> ⍥
14:35:04 <monochrom> Why lowest?
14:35:12 <mauke> > let fibs = 1 : map (round . (phi *) . fromInteger) fibs where phi = 0.5 + sqrt 1.25 in fibs
14:35:13 <lambdabot>   [1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,177...
14:35:16 <gwern> because it's even worse than mime or sarcasm
14:35:24 <ehird> gwern: UTF. the highest form of humour.
14:36:04 <luite> gwern: but support from publishers may be an issue. many older papers are only available as scans for example, which don't display very well
14:36:14 <Gracenotes> UTF-32, the highest-bit form of humor
14:36:31 <gwern> ehird: see? Gracenotes knows how to play the game. you can't just negate it
14:36:54 <gwern> luite: well, I'd be mostly reading torrented ebooks, which are usually txt or pdfs and not scans
14:37:20 <gwern> (but it's kind of pointless to consider, as I'm not getting one anytime soon; I was justp laying with someone else's)
14:37:31 <monochrom> Poor tormented books.
14:37:52 <jkramer> Woah, euler problem #2 just almost killed my notebook :)
14:37:52 <luite> gwern: many pirate math/cs books books are only availble in scans
14:38:24 <pikhq> > let fibs = fibs in fibs
14:38:25 <monochrom> just #2 and already killed your notebook? So like #10 will burn down your house or something?
14:38:28 <pikhq> ;p
14:38:29 <lambdabot>   mueval-core: Prelude.read: no parse
14:38:29 <lambdabot>  mueval: ExitFailure 1
14:38:31 <Berengal> > let fibs = 0:1:zipWith (+) fibs (tail fibs) in fibs !! 50
14:38:32 <lambdabot>   12586269025
14:38:44 <monochrom> #63 will devour the whole planet.
14:38:45 <Berengal> > let fibs = 0:1:zipWith (+) fibs (tail fibs) in fibs !! 20
14:38:46 <lambdabot>   6765
14:39:13 <Berengal> My machine starts to die on about the 20th fib using the naive algorithm
14:39:31 <FunctorSalad_> that's not surprising
14:39:41 <jmcarthur_work> with optimizations?
14:39:55 <jmcarthur_work> with -O2, i get up to 42 or 43 before it starts really struggling
14:39:56 <monochrom> Problems don't kill computers. Programmers do.
14:40:00 <jkramer> Hehe
14:40:02 <Berengal> How do you optimize the naive algorithm and retain its exponential complexity?
14:40:05 <jmcarthur_work> on the naive algorithm i mean
14:40:07 <FunctorSalad_> o_O
14:40:15 <Berengal> Oh, that kind of optimization...
14:40:17 <jmcarthur_work> it stays exponential with -O2
14:40:40 <monochrom> -O100 may get up to 64.
14:40:41 <jkramer> Maybe I didn't get the problem right. I should take the fibs that don't exceed 4M, not the first 4M of the series :)
14:40:52 <FunctorSalad_> btw what is the runtime of the fast algos if you take into account that the numbers become larger?
14:40:56 <Berengal> jmcarthur_work: Not neccessarily. I've seen -O2 reduce complexity to the log of the original one
14:41:00 <FunctorSalad_> O(log(n)^2)?
14:41:18 <Berengal> O(log(2^n))
14:41:35 <dons> -O2 can enable fusion, which can change complexity
14:41:47 <Berengal> dons: In this case it was CSE
14:41:57 <dons> CSE for sure can have a big impact
14:42:04 <dons> the famous Writer monad CSE, for example
14:42:07 <monochrom> So -O2 is the optimization I'm looking for that replaces bubble-sort by sane sort?
14:42:12 <Berengal> Count the number of nodes in a full binary tree by traversing it with Writer and Sum
14:42:16 <dons> monochrom: that's the one :)
14:42:25 <FunctorSalad_> Berengal: the *fast* algos
14:42:40 <mauke> > iterate (round . (phi *) . fromInteger) 1 where phi = 0.5 + sqrt 1.25
14:42:42 <lambdabot>   <no location info>: parse error on input `where'
14:42:42 <Saizan> Writer monad CSE?
14:43:13 <FliP^2eH> readFile has kept my file open for 10 hours :(
14:43:20 <FliP^2eH> I had to manually close it
14:43:23 <ehird> mauke: (x where y) isn't an expression
14:43:23 <FliP^2eH> Bad bad readFile
14:43:23 <Berengal> FunctorSalad_: Sorry, I missed a line. Thought you wanted the complexity of the one O2 optimized
14:43:29 <dons> FliP^2eH: you need to consume the data for lazy IO to trigger closing
14:43:37 <dons> FliP^2eH: otherwise use strict IO
14:43:39 <mauke> ehird: I know, but didn't that used to work in lambdabot?
14:43:40 <FliP^2eH> I should really consider it
14:43:45 <ehird> mauke: dunno
14:43:45 <FliP^2eH> ByteString or so
14:43:45 <dons> (i.e. System.IO.Strict or strict bytestrings or iteratee IO)
14:43:47 <monochrom> readFile is just hGetContents again.
14:43:58 <FliP^2eH> I thought so :)
14:44:01 <mauke> > let phi = 0.5 + sqrt 1.25 in iterate (round . (phi *) . fromInteger) 1
14:44:02 <lambdabot>   [1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,177...
14:44:02 <FliP^2eH> It's not sooo wild
14:44:06 <Saizan> > x where x = ()
14:44:07 <lambdabot>   <no location info>: parse error on input `where'
14:44:26 <Saizan> some parser in the pipeline must have changed behaviour
14:44:41 <monochrom> Floating point for fibonacci (or factorial, or lots of things) doesn't make a lot of sense.
14:45:09 <mauke> > let phi = 0.5 + sqrt 1.25 :: CReal in iterate (round . (phi *) . fromInteger) 1
14:45:10 <lambdabot>   [1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,177...
14:45:20 <Berengal> Lazy IO can be fun, but I'm ever irked by the fact that a function 'closeFile :: String -> Char' can exist
14:45:21 <Cale> er, that's strange... I apparently just quit for Excess Flood?
14:45:24 <FunctorSalad_> monochrom: agreed, you can do integer matrix mult
14:45:56 <Berengal> Cale: Left a tap open?
14:46:15 <Cale> I wasn't even touching my irc client...
14:46:37 <BONUS> Berengal: how do you do that
14:46:41 <BONUS> the String -> Char thing
14:46:57 <mauke> head
14:47:19 <Cale> Berengal: ehh?
14:47:22 <Berengal> BONUS: consider 'do foo <- readFile "foo"; last foo `seq` return foo'
14:47:22 <BONUS> but it closes a file
14:47:31 <Berengal> close = last in this case
14:47:44 <BONUS> ah hmm
14:47:51 <mauke> evaluate (length foo)
14:48:25 <Cale> Berengal: would you rather the file be held open when you're done reading it?
14:48:58 <Berengal> Cale: No, of course not. It's just The toxic spillover from IO to pure code that bugs me on a metaphysical level
14:51:06 <Berengal> Won't stop me from using lazy IO though...
14:51:29 <skorpan> HE'S DEAD PEOPLE
14:52:30 <monochrom> I am semi-closed.
14:55:54 <jkramer> Yay, solved #2
14:55:59 <jkramer> takeWhile for the win!
14:56:18 <lpsmith> jkramer:  Project Euler?
14:56:23 <jkramer> Yup
14:56:45 <lpsmith> fun stuff :)
14:58:59 <jkramer> Hmm, the prime factors of n are all numbers that n is a multiple of and that are primes, right?
14:59:43 <monochrom> Worded wrong at least.
14:59:44 <mauke> hmm, not quite
14:59:50 <mauke> it's not a set
15:00:11 <mauke> product prime_factors == n && all isPrime prime_factors
15:00:19 <monochrom> Err, I misread.
15:04:06 <jkramer> primeFactors n = [ x | x <- [ 2 .. n - 1 ], isPrime x && mod n x == 0 ]
15:04:20 <jkramer> At least the result looks correct :)
15:04:55 <mauke> primeFactors 8 == [2,2,2]
15:05:03 <jkramer> Oh
15:05:08 <jkramer> primeFactors n = nub [ x | x <- [ 2 .. n - 1 ], isPrime x && mod n x == 0 ]
15:05:10 <jkramer> :D
15:05:13 <mauke> wtf
15:05:19 <mauke> how is that going to produce [2,2,2]?
15:06:42 <jkramer> Hmm, I get [2] here even without nub
15:07:21 <sjanssen> jkramer: that's because your algorithm is wrong
15:07:28 <jkramer> NOT IT IS NOT!!
15:07:31 <jkramer> :)
15:07:45 <monochrom> Your two NOT's cancel each other.
15:07:52 <jkramer> Damn
15:07:58 <jkramer> So why is it wrong?
15:08:24 <mauke> because it doesn't produce [2,2,2]
15:08:42 <jkramer> Ah, now I get it
15:08:44 <trofi> it tries '2' only once
15:09:44 <monochrom> This is why programmers impose strange things on users. "I already have code, so make me rewrite".
15:09:50 <monochrom> s/so/don't/
15:18:51 <Warrigal> Are there any simple first-order logic wranglers in Haskell?
15:19:17 <Warrigal> (As in theorem provers, proof verifiers, and so on.)
15:19:35 <Warrigal> (Now that I think about it, I don't actually know what "wrangler" means.)
15:21:28 <jkramer> Yay
15:21:30 <jkramer> http://haskell.pastebin.com/m5fbb69c2
15:23:11 <lpsmith> jkramer:  that has to be one of the slowest prime factorization routines I've seen :-)
15:23:34 <monochrom> It is interesting that when I look at pastebin.com I ignore the coloured highlighted version. I go straight to the edit-box version, and it is so much clearer.
15:24:19 <monochrom> Bolding never works for programming languages.
15:24:21 <lpsmith> jkramer:  for starters,  you don't have to test whether or not your prime factor is prime.
15:24:40 <lpsmith> jkramer:  the smallest divisor of any number is guaranteed to be prime.
15:25:06 <lpsmith> jkramer:  thanks to the transitivity of divisibility
15:25:27 <lpsmith> If the smallest divisor of any given number wasn't prime
15:25:37 <SamB> monochrom: what I hate is how the bold fonts tend to have just slightly different height metrics
15:26:10 <SamB> once hinted, if not before ...
15:26:15 <lpsmith> lets say the divisor is d and it evenly divides n,  so d|n
15:26:29 <lpsmith> and d isn't prime, then there is a divisor call it x
15:26:32 <lpsmith> so x|d
15:26:35 <lpsmith> and d|n
15:26:41 <lpsmith> therefore x|n
15:26:49 <lpsmith> thus d isn't the smallest divisor of n
15:27:06 <lpsmith> you will speed your code up *a lot* by removing that check
15:31:45 <ehird> If I have an instance involving (Concrete → Concrete), but try and use it, I get yelled at that there's no (t1 → t2) instance. How can I make this, well, work
15:31:46 <ehird> ?
15:32:19 <lpsmith> ehird:  can you be a bit more specific?
15:33:16 <ehird> lpsmith: basically, a multi-param type class; a function in it is of the second param's type; I have an instance where the second param is ([Char] → [Char]), but when I do (f "blah") it tries to find an instance for (t1 → t2), and thus falls down.
15:33:24 <Saizan> ehird: you've to tell the typechecker those t1 and t2 are supposed to actually be Concrete
15:33:39 <ehird> Saizan: except they objectively are :)
15:33:47 <ehird> and that would defeat the point of this in particular
15:33:48 <Saizan> ehird: evidently not :)
15:34:33 <Saizan> ehird: how does the class and the expression look like?
15:34:33 <ehird> :\
15:34:36 <ehird> ah, hm
15:34:48 <ehird> if I use 'a':[] it works, but looks for ([Char] → t)
15:35:00 <ehird> which is... less than useful, as there's only one instance fitting that.
15:35:22 <Saizan> typeclasses assume an open world
15:35:37 <lpsmith> http://haskellconcrete.com/
15:35:45 <Taejo> does GHC implement tail-recursion elimination when the recursion is polymorphic?
15:35:46 <Saizan> you can infer some of the parameters from the others only if you use functional dependencies
15:35:57 <ehird> Saizan: hmm
15:36:08 <ehird> Saizan: maybe I'll try 'em
15:36:22 <ehird> aha!
15:36:26 <ehird> seems like this is what I want
15:36:27 <dons> Taejo: good question.
15:36:47 <monochrom> Not sure if you get polymorphic recursion at all.
15:37:05 <dons> in practice, what would that mean? dispatching to particular monomorphic instances?
15:38:00 <Taejo> dons: I'm reading Collecting More Garbage by Pascal Fradet, and he assumes you can determine the types of all values if you know the types of all *functions*, by traversing the stack
15:38:43 <ehird> Saizan: fundeps change nothing :'(
15:38:53 <ehird> hmm
15:38:55 <ehird> i'll figure something out
15:39:07 <copumpkin> ehird: wanna paste some code? :)
15:39:44 <ehird> i think i've figured it out :P
15:39:46 <ehird> but yeah, if i can reduce it
15:40:02 <copumpkin> what are you working on?
15:40:28 <ehird> a type-safe printf using OverloadedStrings; I'm fairly certain I can make it work
15:40:39 <copumpkin> :o
15:41:00 <copumpkin> how? using TH?
15:41:03 <ehird> nope
15:41:19 <ehird> just a bunch of crazy typeclasses, GADTs, overloaded strings, functional dependencies, etc up the wazoo
15:41:38 <copumpkin> doesn't overloadedstrings give you (fromString "myConstantString %s %d etc.") ?
15:41:42 <copumpkin> *just give you
15:41:57 <ehird> yep
15:42:22 <copumpkin> so you can change the type of the result of that based on the value of the format string? :o
15:42:42 <ehird> with restrictions.
15:42:49 <Saizan> ehird: overloaded numerical constants are often a pain for type hackery, OverloadedStrings can only do worse i imagine :)
15:43:01 <ehird> it's basically going to look at the type you call it with, and finding the only applicable instance for that.
15:43:03 <ehird> which then parses the string
15:43:08 <ehird> s/finding/find/
15:43:24 <copumpkin> oh, so still not compile-time
15:43:28 <ehird> nope, compile-time
15:43:37 <ehird> sort of
15:43:38 <ehird> I think
15:43:39 <ehird> maybe
15:43:40 <ehird> :P
15:43:49 * copumpkin raises an eyebrow
15:43:51 <ehird> i wish there was a CompileTimeOverloadedStrings though.
15:43:54 <Saizan> no, you'd still get an exception at runtime if the string is not of the right format
15:44:23 <copumpkin> [$fmt|allo allo I haz format stringz %s %d weirdo|]
15:44:27 <Saizan> i don't see the difference with Text.Printf.printf here
15:45:07 <malouin> @src const
15:45:08 <lambdabot> const x _ = x
15:45:08 <FliP^2eH> Hey, Michael Jackson died today
15:45:14 <FliP^2eH> And no news told me about it
15:45:24 <FliP^2eH> I thought we life in an age of news!
15:45:24 <megaTherion> FliP^2eH: who cares
15:45:27 <copumpkin> really? twitter is abuzz
15:45:34 <ehird> hmm
15:45:35 <dons> off topic in here
15:45:40 <ehird> i thought i could make it work but ugh
15:51:28 <Associat0r> lpsmith: nice the new haskell concrete syntax
15:52:43 <leshp_resident> word out
15:52:48 <leshp_resident> any happstackers here?
15:52:54 <leshp_resident> haskell doing web with style?
15:53:18 <tommd> leshp_resident: You could try looking in #happs if no one answers here.
15:55:38 <FunctorSalad_> is there some way to type the rule "fst (runWriter x) = runIdentity x"? ;)
15:56:14 <FunctorSalad_> I tried "forall (x :: forall m. MonadWriter w m => m a). fst (runWriter x) = runIdentity x". that typechecks but doesn't fire
15:58:57 <Saizan> FunctorSalad_: i suspect x will already have a type like Writer w a at that point
16:00:16 <FunctorSalad_> I'll try specialising x to the function actually called there
16:01:48 <FunctorSalad_> still no luck
16:04:20 <Dae> "cabal: ghc-pkg version >=0 is required but it could not be found" - huh?
16:05:05 <monochrom> haha
16:06:12 <Dae> yeah...reinstalled every haskell package I have... still no dice
16:13:11 <Dae> no help?
16:13:14 <ehird> say, what's the haskeller's tool of choice for dependently typed programming?
16:14:25 <Adamant> ehird: nobody agrees on a single one, agda, epigram, and coq are all popular
16:14:38 <Adamant> in that vein
16:14:49 <ehird> Adamant: mm— Coq seems a lot more about proofs than the actual programming to me
16:14:59 <ehird> cayenne's dependent types are the nicest & cleanest to me; which is closest?
16:17:10 <Saizan> Dae: what's your problem?
16:17:26 <Saizan> or, "what problem do you have?"
16:17:38 * Saizan wonders if the first line sounds rude in english
16:17:47 <tommd> It has a rude sound to it, yes.
16:18:11 <tommd> 'What's the issue' is a little softer.
16:18:19 <Dae> Saizan: cabal doesn't work... claims I don't have ghc-pkg installed...which I have... all done using fedoras package manager...
16:18:21 <ehird> :)
16:18:27 <Zao> Saizan: "What's your major malfunction, numbnuts?"
16:18:48 <Zao> Saizan: It's friendlier than lambdabot at least.
16:18:49 <tommd> Dae: Which version of fedora?
16:18:52 <Dae> 10
16:18:58 <hackagebot> bytestring-mmap 0.2.1 - mmap support for strict ByteStrings (DonaldStewart)
16:18:59 <tommd> @src noSuchFunction
16:18:59 <ehird> Agda looks like cayenne and haskell
16:18:59 <lambdabot> Source not found. You speak an infinite deal of nothing
16:19:02 <Saizan> Dae: how are you running cabal?
16:19:17 <Dae> via the console? cabal install hmatrix
16:19:51 <tommd> in the console, does ghc-pkg work and return something?
16:20:11 <Dae> yes
16:20:23 <Saizan> what are the paths of ghc and ghc-pkg?
16:20:37 <Dae> no clue....
16:20:46 <Dae> I'll try and search
16:21:08 <Dae> ghc: /usr/lib/ghc-6.10.1
16:21:21 <fozze> cya guys
16:21:25 <Dae> same for ghc-pkg
16:22:32 <Saizan> Dae: which ghc and which ghc-pkg should tell you the ones your shell sees
16:22:45 <Saizan> "which ghc" as a command, i mean
16:23:23 <Saizan> however you can override cabal's default search by passing --with-ghc-pkg=path/to/ghc-pkg
16:23:45 <stevan> ehird: cabal install agda and /j #agda :-)
16:23:50 <ehird> yah
16:23:52 <ehird> i'm doing so
16:23:55 <Dae> they're different.... apparently ghc is also located in /usr/local/bin/ghc...
16:24:29 <Dae> Saizan: ok, that's probably the problem... had something similar earlier where runhaskell was unable to find ghc
16:26:12 <Dae> Saizan: weird... didn't work overriding the path
16:26:12 * Saizan_ is back
16:26:19 <ehird> I wonder if ghc will ever get -XDependentType
16:26:20 <ehird> s
16:27:33 <stevan> well it already has in a sense, the question is if its the right way to go...
16:28:17 <Dae> bah! Guess I'll just format my way out of this
16:28:38 * Dae apparently has a computer filled with ghc installations
16:28:38 <Saizan_> Dae: can you cabal unpack hmatrix and then paste the output of cabal configure -v2 from inside the crated directory?
16:30:52 <Saizan_> it should tell at the start where it is searching for ghc-pkg
16:31:14 <Dae> yeah, searches for it in /usr/local/bin
16:31:21 <Dae> tried making a symbolic link to it
16:31:38 <Dae> now it complains that ghc-pkg dump fails
16:32:03 <Saizan_> ghc --version ?
16:32:23 <Saizan_> i think you mixed a ghc-pkg from one version with a newer ghc
16:33:25 <Dae> I think my ghc install is rather bunked.... I might have done a fedora package install on top of an installations from source
16:33:25 <Dae> I'll format it later. Thanks for your help though :)
16:34:22 <Saizan_> ok :)
16:34:35 <dancor> is there an inherent speed-hit in compiling cabal libraries with profiling, or does it only happen if you also compile a program that uses them with profiling
16:35:01 <Saizan_> dancor: they get compiled twice, once normally and once for profiling
16:35:02 <ehird> latter
16:35:08 <dancor> ah
16:35:40 <dons> dancor: so only if the end-executable uses profiling.
16:35:50 <dancor> cool
16:38:25 <Dae> dons: In case you're not tired of hearing it: Thanks for writing Real World Haskell. It be made of awesome
16:42:03 <dons> Dae: :)
16:46:26 <Associat0r> dons: I like it too
16:47:19 <skorpan> i like turtles
16:49:17 <FliP^2eH> Okay!"
16:49:21 <FliP^2eH> Randomize Array Elements
16:49:22 <FliP^2eH> How?
16:49:29 <FliP^2eH> :)
16:49:53 <FliP^2eH> I have no clue about randomness
16:49:58 <FliP^2eH> I only know randomRIO
16:50:22 <aavogt> @type randoms
16:50:23 <lambdabot> forall g a. (Random a, RandomGen g) => g -> [a]
16:50:48 <FliP^2eH> > randoms makeStdGen
16:50:50 <lambdabot>   Not in scope: `makeStdGen'
16:50:55 <FliP^2eH> > randoms stdGen
16:50:57 <lambdabot>   Not in scope: `stdGen'
16:50:57 <FliP^2eH> ;s
16:51:27 <FliP^2eH> > randoms mkStdGen
16:51:29 <lambdabot>   No instance for (System.Random.RandomGen
16:51:29 <lambdabot>                     (GHC.Types.Int...
16:51:32 <aavogt> > randoms $ mkStdGen 2
16:51:34 <lambdabot>   [-2493721835987381530,6819820395428238746,205764085980522181,23619431016000...
16:51:49 <FliP^2eH> take 4 $ randoms $ mkStdGen 4
16:51:53 <FliP^2eH> > take 4 $ randoms $ mkStdGen 4
16:51:54 <lambdabot>   [-258552320774346181,-5176386308431395685,-1601263715795621314,-70062784816...
16:51:58 <aavogt> > randoms <$> newStdGen
16:51:59 <FliP^2eH> > take 2 $ randoms $ mkStdGen 4
16:52:00 <lambdabot>   Add a type signature
16:52:00 <lambdabot>   [-258552320774346181,-5176386308431395685]
16:52:12 <aavogt> > (randoms <$> newStdGen) :: IO Int
16:52:13 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
16:52:20 <aavogt> > (randoms <$> newStdGen) :: IO [Int]
16:52:22 <lambdabot>   <IO [Int]>
16:52:27 <FliP^2eH> Okay, how'd I randomize array elements with it?
16:52:44 <aavogt> FliP^2eH: given a preexisting array?
16:52:47 <FliP^2eH> Yes
16:52:51 <FliP^2eH> Say string "DUDE"
16:53:10 <aavogt> > permutations "DUDE"
16:53:11 <lambdabot>   ["DUDE","UDDE","DUDE","UDDE","DDUE","DDUE","EDUD","DEUD","DUED","EUDD","UED...
16:53:18 <FliP^2eH> !
16:53:25 <FliP^2eH> Okay.
16:53:37 <FliP^2eH> > filter (/= "DUDE") $ permutations "DUDE"
16:53:38 <lambdabot>   ["UDDE","UDDE","DDUE","DDUE","EDUD","DEUD","DUED","EUDD","UEDD","UDED","EDU...
16:54:01 <aavogt> tail is probably better there
16:54:07 <FliP^2eH> > filter (/= "Supercalifragilisticexialidocious") $ permutations "Supercalifragilisticexialidocious"
16:54:09 <lambdabot>   ["uSpercalifragilisticexialidocious","puSercalifragilisticexialidocious","u...
16:54:20 <FliP^2eH> > tail $ permutations "Supercalifragilisticexialidocious"
16:54:21 <lambdabot>   ["uSpercalifragilisticexialidocious","puSercalifragilisticexialidocious","u...
16:54:27 <FliP^2eH> > last $ permutations "Supercalifragilisticexialidocious"
16:54:32 <lambdabot>   mueval-core: Prelude.read: no parse
16:54:32 <lambdabot>  mueval: ExitFailure 1
16:54:36 <FliP^2eH> Ow.
16:55:01 <aavogt> yeah, not a good option
16:55:05 <FliP^2eH> > drop 15 $ filter (/= "Supercalifragilisticexialidocious") $ permutations "Supercalifragilisticexialidocious"
16:55:07 <lambdabot>   ["ueSprcalifragilisticexialidocious","uSeprcalifragilisticexialidocious","e...
16:55:10 <FliP^2eH> :D
16:55:16 <FliP^2eH> Okay, not good
16:56:07 <FliP^2eH> > randomRIO (0,1)
16:56:09 <lambdabot>   <IO Integer>
16:56:19 <FliP^2eH> > do s <- randomRIO (0,1); s
16:56:20 <lambdabot>   No instance for (System.Random.Random (GHC.IOBase.IO b))
16:56:20 <lambdabot>    arising from a ...
16:56:24 <FliP^2eH> > do s <- randomRIO (0,1); show s
16:56:25 <lambdabot>   Couldn't match expected type `GHC.IOBase.IO b'
16:56:46 <ehird> :t show
16:56:47 <lambdabot> forall a. (Show a) => a -> String
16:56:50 <ehird> FliP^2eH: "String" != "IO String".
16:56:53 <ehird> Also, lambdabot doesn't run IO.
16:56:57 <FliP^2eH> Oh, okay
16:57:20 <FliP^2eH> Getting the length of that killer list would take a long time, also
16:57:44 <Dae> FliP^2eH: you could get a random list of integers and then use those to take random entry in the array?
16:58:01 <FliP^2eH> Need to limit it the the array bounds
16:58:10 <Dae> sure, you can do that
16:58:54 <FliP^2eH> But using it on all possible permutations of "Supercalifragilisticexpialidocious" will take a while
16:59:03 <FliP^2eH> > length $ permutations "Supercalifragilisticexialidocious"
16:59:06 <FliP^2eH> Bam.
16:59:09 <lambdabot>   mueval-core: Prelude.read: no parse
16:59:09 <lambdabot>  mueval: ExitFailure 1
17:00:31 <mle>   8683317618811886495518194401280000000
17:00:35 <FliP^2eH> > "SOME STRING" `elem` $ permutations "SOME STRING"
17:00:36 <lambdabot>   <no location info>: parse error on input `$'
17:00:41 <FliP^2eH> > "SOME STRING" `elem` (permutations "SOME STRING")
17:00:42 <lambdabot>   True
17:01:07 <FliP^2eH> > length $ permutations "SOME STRING"
17:01:12 <lambdabot>   mueval-core: Prelude.read: no parse
17:01:12 <lambdabot>  mueval: ExitFailure 1
17:01:17 <FliP^2eH> Even that goes too long
17:01:22 <Dae> FliP^2eH: you want to pick a random permutation of supercalifr...etc?
17:01:30 <FliP^2eH> Yes
17:01:55 <mle> > length $ permutations "a"
17:01:57 <lambdabot>   1
17:02:09 <FliP^2eH> > length $ permutations "aa"
17:02:10 <lambdabot>   2
17:02:11 <FliP^2eH> > length $ permutations "aaa"
17:02:12 <lambdabot>   6
17:02:14 <FliP^2eH> > length $ permutations "aaaa"
17:02:15 <lambdabot>   24
17:02:16 <FliP^2eH> ;D
17:02:37 <aavogt> > let swap ((True,x):(s,y):ys) = y : swap ((s,y):ys); swap ((False,x):(s,y):ys) = x : swap ((s,y):ys); swap x = x; in swap $ zip (randoms (mkStdGen 1)) "1234567890"
17:02:38 <lambdabot>   Occurs check: cannot construct the infinite type:
17:02:38 <lambdabot>    t = (GHC.Bool.Bool, t)
17:02:45 <codebliss> LOL.  I just came up with this.  screwYouGlobalWarming = filter isPrime $ map even [1..] -- You get it?
17:02:59 <ehird> :t randomRIO
17:03:00 <lambdabot> forall a. (Random a) => (a, a) -> IO a
17:03:06 <ehird> codebliss: No.
17:03:09 <ehird> Oh.
17:03:10 <ehird> Heh.
17:03:21 <aavogt> > let swap ((True,x):(s,y):ys) = y : swap ((s,y):ys); swap ((False,x):(s,y):ys) = x : swap ((s,y):ys); swap x = map snd x; in swap $ zip (randoms (mkStdGen 1)) "1234567890"
17:03:21 <codebliss> ehird: Infinite list of even primes.  The only one is 2.  lmfao
17:03:22 <lambdabot>   "2245577990"
17:03:26 <ehird> Right.
17:03:49 <aavogt> > let swap ((True,x):(s,y):ys) = y : swap ((s,x):ys); swap ((False,x):(s,y):ys) = x : swap ((s,y):ys); swap x = map snd x; in swap $ zip (randoms (mkStdGen 1)) "1234567890"
17:03:50 <lambdabot>   "2145376980"
17:03:55 <codebliss> ehird: Your comp will be crunching numbers forever and will yield nothing really useful haha.  Goodbye electricity!
17:04:00 <aavogt> > let swap ((True,x):(s,y):ys) = y : swap ((s,x):ys); swap ((False,x):(s,y):ys) = x : swap ((s,y):ys); swap x = map snd x; in swap $ zip (randoms (mkStdGen 2)) "1234567890"
17:04:02 <lambdabot>   "2314678905"
17:04:14 <FliP^2eH> :D
17:04:24 <aavogt> bubble-sort inspired =)
17:05:11 <aavogt> codebliss: don't you get:  "[2,
17:05:33 <codebliss> It will crunch past 2 forever
17:06:10 <aavogt> ) take 1 screwYouGlobalWarming -- laziness ftw
17:06:20 <Dae> rofl
17:06:41 <codebliss> takeWhile (>2) $ screwYouGlobalWarming
17:06:46 <int-e> @quote lecture
17:06:46 <lambdabot> Tac-Tics says: oerjan: I tried, but his zombie lectures were hard to follow
17:07:35 <aavogt> > fix show
17:07:37 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
17:07:54 <Dae> gonna head to sleep.... or try as my neighbours decided to celebrate Michael JAcksons death by playing his records as loud as their speaks can handle.....
17:07:57 <Dae> cya
17:08:25 <codebliss> XD
17:12:59 <nooga> BONUS, thx for the tutorial
17:28:16 <FunctorSalad_> uh, "celebrate"?
18:07:10 <copumpkin> ChilliX: you around?
18:07:27 <ChilliX> copumpkin: Hi!
18:08:55 <copumpkin> ChilliX: my attraction to (3) was mostly because until recently apple hadn't released the source to objc2 stuff, so we'd have been restricted to compiling on osx
18:09:35 <copumpkin> ChilliX: but it appears that they've released all the objc2 things in their gcc fork now, so it's conceivable (if unlikely and painful) that someone would compile it for another platform
18:10:43 <copumpkin> it actually looks like it's still only half there
18:11:07 <ChilliX> copumpkin: tbh, I am mostly concerned with osx anyway and not really keen on making things anymore complicated (as in more effort to implement) for the rather unlikely case that somebody wants to use ObjC with Haskell on non-osx
18:12:03 <copumpkin> ChilliX: well, the use-case I was thinking of was (cross-)compiling haskell for iphone, which could conceivably be on another platform
18:12:04 <pikhq> What if someone just wants to use ObjC? It's a nice language even if you are short Cocoa.
18:12:13 <pikhq> ... Compared to the abortion that is C++, at least.
18:12:16 <copumpkin> lol
18:12:19 <copumpkin> that's a tautology
18:12:59 <ChilliX> pikhq: well, without Cocoa ObjC loses a lot of its appeal imho
18:13:05 <copumpkin> I agree :)
18:13:09 <copumpkin> but cocoa touch?
18:13:21 <copumpkin> just because apple "forces" you to have osx to develop for iphone doesn't mean we do :P
18:13:31 <pikhq> ChilliX: It still has appeal just by merit of having an object system that doesn't make you vomit.
18:13:31 <ChilliX> pikhq: plus really, how likely is it it that somebody uses ObjC and haskell other than on a mac?
18:13:45 <ChilliX> copumpkin: well, defacto we do
18:13:48 * pikhq has been meaning to learn ObjC.
18:13:58 <copumpkin> ChilliX: why?
18:14:02 <pikhq> And I don't run a Mac.
18:14:02 <ChilliX> copumpkin: How do you want to upload apps onto the phone without xcode
18:14:12 <copumpkin> ChilliX: I've reversed the protocol for that ;)
18:14:19 <Gracenotes> pikhq: me too, but getting it working on Ubuntu was a bit of a pain
18:14:26 <ChilliX> pikhq: And you want to write a combined ObjC + Haskell app?
18:14:29 <Gracenotes> and even then you don't have version 2, which has some nice sugar
18:14:37 <pikhq> ChilliX: I may.
18:14:56 <pikhq> I certainly would like to have the option, at least.
18:15:11 <ChilliX> pikhq: then, I think we should solve the problems associated with that when you actually do decide to do that ;)
18:15:15 <copumpkin> a lot of iphone development happens outside of osx, whether apple likes it or not
18:15:22 <pikhq> Fair enough.
18:15:44 * pikhq just wishes Objective C were used instead of C++.
18:15:49 <ChilliX> copumpkin: Can you certify an app and upload it?
18:15:53 <jgg> Hi. What's wrong with this code: pan n = [x | x <- [1..n], (sort (show x)) == ['1'..x]] I keep getting "no instance of (Num Char)" whenever I use this function. I'm a newbie and don't know how to fix it.
18:16:07 <copumpkin> ChilliX: yeah, I reversed the signing mechanism used by codesign too :P
18:16:16 <ChilliX> Just to set the context, we are talking about http://hackage.haskell.org/trac/ghc/wiki/ObjectiveC
18:16:23 <pikhq> I mean, it's still C (and has all the evils attached to that), but it at least doesn't take 'not all that great, but has valid uses' and make it into the embodiment of evil.
18:16:28 <ChilliX> copumpkin: I am impressed :)
18:16:39 <copumpkin> ChilliX: but it might be a little intense to reimplement all that, but I'd like to have the option of not running on osx someday :)
18:16:48 <pikhq> ChilliX: I tracked off into a general rant against C++, and am now done. So.
18:16:52 <copumpkin> (I personally do run osx on all my computers)
18:17:32 <ChilliX> and, re context, I am only saying we should do the easier to implement route first, even if it only works on osx, given that we can always later switch to the harder more portable route
18:17:40 <copumpkin> true :)
18:17:47 <pikhq> jgg: Well, obviously, you've got a type error. ['1'..x], and x is of type Num?
18:17:55 <pikhq> That just plain won't work.
18:18:00 <ChilliX> (both give the same code, it's just a matter of how much of an ObjC compiler to re-implement in ghc)
18:18:01 <copumpkin> unless you make a Num instance for Char
18:18:09 <pikhq> Well, yes.
18:18:12 <ChilliX> pikhq: :)
18:18:30 <copumpkin> ChilliX: fair enough, I concede :)
18:18:35 <ChilliX> copumpkin: I am all for keeping options open
18:18:41 <copumpkin> I can slowly implement the various supporting mechanisms on the side, too
18:20:12 <ChilliX> But I am also for Worse is Better!
18:20:42 <pikhq> Clearly, ChilliX is a C programmer, and not a Haskell programmer.
18:20:57 <ChilliX> lol
18:21:41 <Elly> Worse is Worse!
18:21:41 <copumpkin> :)
18:21:58 <copumpkin> I just love low-level hackery (which is why I was attracted to (3) in the first place)
18:22:01 <ChilliX> Haskell as a whole these days is very much a Worse is Better project - even if that sounds surprising.
18:22:16 <ChilliX> copumpkin: Yeah, I can relate to that :)
18:22:39 <ChilliX> For example, unsafePerformIO is very much a Worse is Better feature
18:22:40 <pikhq> ChilliX: ... How so?
18:22:57 * pikhq sits around the campfire with ChilliX to hear about this
18:23:22 * copumpkin skulks in the dark woods outside the light of the campfire
18:23:48 <ChilliX> Worse is Better doesn't mean to cut arbitrary corners
18:25:38 <ChilliX> It rather means to make pragmatic compromises where not making these compromises means to not get a working implementation any time soon.
18:26:00 <ChilliX> It means having  a (dirty) backdoor in case nothing else works
18:26:15 <apsod> I hate to ask a soddy question, but I can't find any good resources describing how to use the State monad. Does anyone have any good URLs? :|
18:26:18 <ChilliX> unseafePerformIO is the ultimate dirty backdoor :)
18:26:22 <copumpkin> I want a worse is better simple dependent types (even just naturals) in haskell
18:26:22 <ChilliX> QED ;)
18:26:46 <ChilliX> copumpkin: What's wrong with type families & co?
18:26:58 * pikhq only started learning Haskell on Monday. So.
18:27:19 <Saizan_> ChilliX: no easy way to get something like row types out of them :\
18:28:19 <copumpkin> ChilliX: I'd want something where I can enforce sizes on matrix and vector operations too :) without specifying the size at compile time
18:28:26 <pikhq> Friend of mine accused me of being some freakish superlearner for grokking monads already.
18:28:37 <copumpkin> I'd like to be forced to prove they're the same dimension or whatever is needed
18:29:21 <ChilliX> copumpkin: with GADTs and TFs you can do that, can't you?
18:29:28 <soupdragon> Agda is wores dependent types :p
18:29:40 <soupdragon> since the implementation is one huge monolithic buggy thing
18:29:48 <ChilliX> copumpkin: no need to know anything statically, just using an indexed type
18:29:54 <soupdragon> the theory is not even static..
18:30:01 <SamB> soupdragon: sadly :-(
18:30:17 <copumpkin> ChilliX: really? how can I force that the inner dimensions of a matrix product be equal, without knowing the dimensions at compile time?
18:30:29 <SamB> soupdragon: you do realize that we have stricter policies re: abusing newbies here than in ##c?
18:30:30 <Saizan_> apsod: http://www.haskell.org/all_about_monads/html/statemonad.html
18:30:41 * apsod starts reading
18:30:56 <copumpkin> zomg soupdragon has been abusing newbies?
18:31:05 * copumpkin drinks the dragon's soup
18:32:03 <Saizan_> copumpkin: i think you can use existential quantification when you don't know the dimension at compile time
18:32:27 <copumpkin> hmm
18:32:35 <copumpkin> now I'm curious
18:32:38 <Saizan_> just make sure the dimensions of both matrixs are quantified together
18:33:28 <ChilliX> copumpkin: using existentials corresponds to the focus/unfocus functions sometimes used with dependent types
18:33:39 <copumpkin> hmm
18:33:52 <copumpkin> I guess I need to think harder about haskell :
18:33:53 <copumpkin> :)
18:34:00 <copumpkin> this stuff is all so fun
18:34:07 <pikhq> s/ about haskell ://
18:34:14 <pikhq> Always. True.
18:34:15 <pikhq> ;)
18:34:18 <copumpkin> :)
18:34:42 <copumpkin> so hmm
18:34:54 <copumpkin> can anyone throw together a quick example of how this would work?
18:34:59 <ivanm> copumpkin: is this the good or the evil version of you?
18:35:14 <copumpkin> I think I'm good now, but pass me a baby seal and we can see for sure
18:35:15 <soupdragon> SamB: No and I don't care.
18:35:33 <ivanm> copumpkin: heh
18:36:07 <copumpkin> soupdragon: you were abusing people? :o
18:36:13 <ChilliX> copumpkin: basically, you define data Zero; data Succ nat & and a type family defining addition on types
18:36:13 <ivanm> copumpkin: how about Serge the fashion industry seal of death from the Mr Hell Show? :p
18:36:14 <apsod> guh, I think I really need to use a monad transformer for this.
18:36:27 <soupdragon> SamB: You shouldn't have brought this up here
18:36:29 * apsod decides to just hack it and thread state around :(
18:36:51 <ChilliX> copumpkin: then you use that as a type index for your vectors and matricies where you would use value-level nats with dependent types
18:37:51 <copumpkin> ChilliX: hmm, so if I defined a matrix based on user input at runtime
18:37:52 <SamB> soupdragon: just a warning
18:37:58 <soupdragon> SamB: I don't need warningsn from you
18:38:24 <soupdragon> SamB: You can only think about one thing, Adam 5 years ago -- I don't understand how it can have affected you so much that it's all you think about
18:38:29 <ChilliX> copumpkin: the thing is that when you use dependent types in a manner that all values that you use as indicies can be equally well represented by types and functions on types, you can always index types with types instead of indexing types with values
18:39:11 <copumpkin> oh my, drama
18:39:23 <copumpkin> ChilliX: interesting
18:39:51 <ivanm> copumpkin: yeah, looks like we're getting some entertainment here for once ;-)
18:40:00 <Saizan_> copumpkin: if you get it from user input at runtime you'd have a value of type "exists m n. Matrix m n"
18:40:01 <copumpkin> #haskell-drama
18:40:06 <ChilliX> copumpkin: by using an existential you can get a non-indexed type from an indexed type
18:40:29 <copumpkin> oh, that's cool, but how can I prove that the runtime matrix is square, for example, if I wanted to square the matrix
18:40:36 <ChilliX> something like data Vec e = forall nat. IndexedVec nat e
18:40:53 <ChilliX> you use the non-indexed type when you don't know the size
18:41:24 <SamB> in a strange coincidence, I might advise ChilliX and copumpkin to talk about this in #coq and perhaps get some input from Smerdyakov ;-)
18:41:26 <Saizan_> copumpkin: you've to validate it and construct a proof, basically
18:41:32 <ChilliX> then you need focus and unfocus functions to wrap/unwrap AND a runtime check whenever you go from an non-indexed to an indexed type
18:41:39 <ChilliX> like with dependent types
18:42:01 <copumpkin> hm, interesting, I had no idea that I could do this with haskell
18:42:19 <ivanm> copumpkin: can't you do _anything_ in Haskell?
18:42:23 <copumpkin> so much still to learn :)
18:42:25 <ChilliX> copumpkin: for a matrix that a user inputs, you need a runtime check to assert squareness
18:42:33 <SamB> ivanm: in the type system?
18:42:34 <ivanm> s/anything/everything/
18:42:38 <ivanm> SamB: oh...
18:42:42 <SamB> ivanm: almost-conveniently?
18:42:52 <ivanm> @faq can you do anything you want in the type-system?  easily?
18:42:53 <lambdabot> The answer is: Yes! Haskell can do that.
18:42:56 <ivanm> \o/
18:43:16 <ChilliX> copumpkin: the main disadvantage of doing this stuff in haskell rather than in a dependently typed language is that you need more type annotations
18:43:20 <copumpkin> hmm
18:43:20 <soupdragon> SamB: You should seriously learn to use PM though, if you feel you need to take an ironic statement way out of context and put it front of ~600 users
18:43:32 <SamB> soupdragon: oh, sorry!
18:43:40 <SamB> your <irony> tags didn't come through
18:43:41 <ivanm> soupdragon: Package Management?
18:44:05 <soupdragon> SamB: Anyway it has nothing to do with this channel so you shouldn't have brought it up here
18:44:20 <Saizan_> soupdragon: you too should continue in private
18:44:23 <SamB> I suggest switching to a MIME-capable client
18:44:28 <soupdragon> Saizan, really...
18:44:39 <copumpkin> #iphone-drama
18:44:44 <Saizan_> if you want to continue, at least.
18:44:58 <copumpkin> I mean, #haskell-drama
18:45:04 <copumpkin> I have iphone on my mind :)
18:45:10 <ChilliX> copumpkin: lol
18:45:20 <SamB> was wondering why you suggested #iphone-drama
18:45:35 <ChilliX> maybe his iphone had a bad day
18:47:27 <ivanm> copumpkin: you want an iphone app to watch bold and the beautiful, do you? ;_
18:47:29 <ivanm> ;-)
18:47:55 <copumpkin> I'm rather involved in the iphone community and there's a lot going on these days :)
18:48:27 <jimmyjazz14> is this a possible type:  fn :: a -> (b -> c) -> c
18:48:44 <ivanm> why did don's say that it's _Python's_ decorate-sort-undecorate idiom in proggit? isn't it _lisp's_ idiom?
18:48:44 <SamB> copumpkin: is yours housebroken?
18:48:56 <copumpkin> SamB: it'd be rather sad if it weren't :P
18:49:04 <copumpkin> jimmyjazz14: yes, but not very interesting probably
18:49:04 <SamB> ivanm: hmm?
18:49:44 <ivanm> SamB: http://www.reddit.com/r/programming/comments/8vp7o/pythons_decoratesortundecorate_idiom_in_haskell/
18:49:48 <SamB> jimmyjazz14: the only plausible implentations involve either returning useless values, or feeding them to the passed-in function
18:50:53 <jimmyjazz14> basically my function takes a fn and some data and simply applies to the funtion fed it
18:51:30 <jimmyjazz14> in some cases some manipulation of that data will happen in the middle
18:51:56 <jimmyjazz14> I end up with the following error though
18:51:57 <jimmyjazz14>  Couldn't match expected type `b' against inferred type `[Char]'
18:51:57 <jimmyjazz14>       `b' is a rigid type variable bound by
18:51:58 <jimmyjazz14>           the type signature for
18:52:22 <SamB> ivanm: well, the blogger mentioned it as how he would do it in Python
18:52:33 <jimmyjazz14> I'm not 100% sure what that error message means
18:52:58 <mike-burns> jimmyjazz14: It might help if you hpaste some code.
18:53:00 <ivanm> SamB: but the blogger didn't say it was _Python's_ idiom
18:53:07 <ivanm> dons did, however
18:53:08 <Saizan_> jimmyjazz14: it means that the b in your signature should be [Char] in its view
18:53:21 <SamB> ivanm: can't it be both Python and Lisp's idiom?
18:53:34 <ivanm> SamB: if it was Lisp's first...
18:53:50 <SamB> that's not how idioms work
18:53:58 <ivanm> true
18:53:59 <SamB> if I steal your idiom, then it's MY idiom
18:54:02 <ivanm> heh
18:54:09 <ivanm> hang on.... are you admitting something? :p
18:54:23 <mike-burns> Idioms are more like dentists, in that "my dentist" can also be someone else's dentist.
18:54:24 <SamB> no
18:54:33 <SamB> quite
18:55:02 <SamB> unless you're so rich you get to keep your dentists on retainer ;-)
18:55:40 <ivanm> mike-burns: though where did dons get the idea that's it's Python's idiom? the blog doesn't say it, and wikipedia just says that Python adopted it from Lisp/Perl
18:56:06 <mike-burns> I don't know where he got the idea from; you'll probably have to ask him.
18:56:11 <ivanm> heh
18:56:12 <ivanm> true
18:56:20 <SamB> you know, I think I made up that idiom myself
18:56:23 <SamB> so it's not just stolen
18:56:30 <ivanm> but that was my initial point (why say it was Python's)
18:56:55 <SamB> well, if it's the typical way to say that in Python ...
18:57:04 <mike-burns> Well that was a Reddit link; you say things in the title of a Reddit post in order to get people to click on it.
18:57:10 <ivanm> *shrug* trying to get the Python fanbois to switch?
18:57:12 <SamB> ... or, at least, if that's what dons understood from the article
18:57:15 <ivanm> mike-burns: true
18:58:01 <mike-burns> Also, given the nature of LISP, everything can be an idiom in it. But in Python you nearly have to use the idiom in order to get work done.
18:59:01 <jimmyjazz14> regarding my earlier question... this is my type: (-->):: Maybe a -> (Maybe b -> c) ->  c
18:59:11 <copumpkin> jimmyjazz14: :o
18:59:17 <jimmyjazz14> (Just (JSString a)) --> fn = fn $ Just (fromJSString a)
18:59:25 <jimmyjazz14> and that is the implementation
18:59:32 <copumpkin> @djinn Maybe a -> (Maybe b -> c) ->  c
18:59:33 <lambdabot> f _ a = a Nothing
19:00:06 * SamB finds the name of jimmyjazz14's function a bit disconcerting
19:00:07 <jimmyjazz14> copumpkin: what did you just do there?
19:04:34 <Saizan_> jimmyjazz14: if you use a variable like 'b' in the type the implementation of your function can't just pick a specific type to use as b
19:04:45 <Saizan_> jimmyjazz14: it has to work for _any_ b
19:05:17 <ivanm> is this a joke? http://www.antiifcampaign.com/ ? :o
19:05:18 <Saizan_> jimmyjazz14: since the type to use for b will be decided by the caller
19:05:40 <mike-burns> ivanm: It is not.
19:05:49 <ivanm> :s
19:05:50 <mike-burns> ivanm: But it's not relevant to functional programming.
19:06:18 <ivanm> mike-burns: but still, they're sole argument so far is that you shouldn't do ifs on finding what type something is
19:06:30 <Saizan_> jimmyjazz14: in fact if you leave out the signature you can then ask ghci for :t (-->) and see which type it'll infer
19:06:42 <jimmyjazz14> Saizan_: I see
19:06:58 <mike-burns> ivanm: It's good OO to avoid ifs, in general.
19:07:21 <ivanm> is it? really? never heard of that before...
19:07:38 <ivanm> I've had to do some ifs in my OO code that I've written...
19:07:45 <ivanm> e.g. division by 0
19:07:48 <mike-burns> ivanm: I work as an OO programmer by day, and this isn't the first time ifs have come up.
19:07:52 <monochrom> hahahaha anti-if-campaign. Think of it like the US conservatives operating their own wikipedia.
19:08:04 <mike-burns> ivanm: It's a rule of thumb, not a hard-and-fast rule.
19:08:07 <dancor> neglecting-inheritance and never-using-if aren't _exactly_ the same thing
19:08:22 <ivanm> "if only someone would speak up against the evils of `if'!" ;-)
19:08:26 <Saizan_> antiif is idiotic, what they are against is ad-hoc polymorphism
19:08:37 <ivanm> Saizan_: yeah, that's what it looks like
19:08:41 <mike-burns> They're just drawing attention to the campaign by being over-the-top. Nothing new.
19:09:05 <dancor> it's an important sociological development in fanboism
19:09:16 <mike-burns> It's how Rails got so popular.
19:10:05 <ivanm> mike-burns: rails became popular due to the anti-if campaign? :o
19:10:06 <ivanm> ;-)
19:10:19 <mike-burns> ivanm: Rails because popular by being over-the-top.
19:10:44 <dancor> @quote fabricated
19:10:45 <lambdabot> No quotes match. I feel much better now.
19:11:17 <FunctorSalad_> Can't make a derived instance of `Eq Void'      (`Void' has no data constructors) <-- that doesn't make sense
19:12:16 <zebrafinch> FunctorSalad_: it has to choose arbitrarily between "(==) _ _ = True" and "(==) _ _ = False"
19:12:28 <bd_> zebrafinch: don't forget (==) _ _ = undefined
19:12:34 <bd_> which is still a complete function
19:12:41 <zebrafinch> bd_: that too
19:12:41 <FunctorSalad_> zebrafinch: no, there are zero clauses for (==)
19:12:55 <bd_> FunctorSalad_: what is (undefined :: Void) == undefined?
19:13:45 <jimmyjazz14> Saizan_: so if I do this along with my earlier function is basically not possible:  (Just a) --> fn = fn (Just a)
19:13:46 <Twey> undefined
19:14:07 <FunctorSalad_> hmm, ok. I was thinking in terms of total stuff :)
19:14:25 <bd_> FunctorSalad_: _|_ is the only member of Void after all :)
19:14:35 <Twey> Oh, you were being Socratic
19:14:40 <bd_> and the naive implementation of the Eq-deriver would produce False, so it's not obvious that it has to be strict
19:14:53 <FunctorSalad_> yeah
19:15:21 <Saizan_> jimmyjazz14: no, because the types won't match
19:15:58 <Saizan_> jimmyjazz14: a will be of type JSONSomething (i guess?) but fn will accept only Maybe String
19:16:51 <jimmyjazz14> Saizan_: so its either always generic or nothing
19:17:01 <jimmyjazz14> Saizan_: makes sense
19:17:16 <bd_> FunctorSalad_: btw - keep in mind, all three of those possibilities are total
19:17:25 <Saizan_> jimmyjazz14: yeah, unless you start using typeclasses
19:17:40 <jimmyjazz14> well actually I am using a type class here
19:17:58 <FunctorSalad_> bd_: yes. I meant I thought of "Void" as perfectly empty, then there'd only be one way
19:18:12 <bd_> What would that way be, though? :)
19:18:20 <bd_> (==) = undefined?
19:18:22 <FunctorSalad_> I'll just do "data Void = Void deriving ...." and not export the constructor ;o
19:18:39 <FunctorSalad_> bd_: it would be the empty function
19:18:51 <bd_> FunctorSalad_: so, (==) _ _ = undefined?
19:19:02 <bd_> FunctorSalad_: also, why not just explicitly define an Eq instance with the semantics you want?
19:19:09 <FunctorSalad_> a function assigns a value to every element of the domain, so there would be no assignment
19:19:38 <bd_> FunctorSalad_: but haskell puts an _|_ element in every packed datatype's domain
19:19:44 <bd_> so a value must be assigned
19:19:49 <jimmyjazz14> Saizan_: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6263#a6263 (its pretty ugly stuff)
19:19:57 <FunctorSalad_> bd_: I don't actually plan to have values of type Void, I just need the instances so upstream types can have a deriving Clause ;)
19:20:09 <bd_> FunctorSalad_: ah :)
19:20:11 <FunctorSalad_> bd_: yes, I agree with _|_ you can't just have the empty function
19:21:30 <Saizan_> jimmyjazz14: you're going to make other instances?
19:21:58 <Saizan_> jimmyjazz14: otherwise there's no point in using a typeclass
19:24:23 <Saizan_> jimmyjazz14: having to use a typeclass is quite more rare than one may think
19:26:58 <jimmyjazz14> Saizan_: hmm no I guess I probably wouldn't ever need to
19:27:32 <jimmyjazz14> I was experimenting
19:29:52 <Saizan_> jimmyjazz14: it might be useful to have a class Foo a where (-->) :: Maybe JSValue -> (Maybe a -> c) -> Maybe c
19:30:09 <Saizan_> jimmyjazz14: so that you can write different instances for differing 'a'
19:31:01 <Saizan_> (oh, c instead of Maybe c should work)
19:37:01 <jimmyjazz14> Saizan_: ok trying that out and getting an error (I get this one alot)... Illegal instance declaration for `ApplyJSValue [Char]'
19:37:30 <jimmyjazz14> ...   instance ApplyJSValue [Char] where
19:37:47 <Saizan_> oh
19:38:12 <Saizan_> you need to turn on FlexibleInstances
19:39:52 <Saizan_> {-# LANGUAGE FlexibleInstances #-} at the top of your file
19:40:25 <jimmyjazz14> hmm odd, I thought that was the whole point of typeclasses
19:40:46 <saml> i can't visit hpaste.org
19:41:21 <Saizan_> haskell98 was quite conservative, and it allows only instances of the form T a1 .. an where T is a type constructor and a1 .. an are type variables
19:41:38 <Saizan_> yours doesn't work because Char is not a type variable
19:45:13 <Saizan_> saml: broken dns maybe?
19:45:53 <saml> i suspect so. it's weird..
20:02:41 <Vanadium> Is liftM just =<< and return?
20:02:50 <saml> @type liftM
20:02:51 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
20:03:36 <altmattr> what computer will compile haskell the fastest?
20:03:41 <saml> Vanadium, they seem a bit different
20:03:42 <altmattr> what I mean is:
20:03:46 <saml> oh =<<
20:04:20 <altmattr> the slowest thing my computer does is compile haskell code - I once saw a PIII blow away a faster G4 compiling a big haskell program
20:04:37 <altmattr> time for a new computer, so I want to get one that will be best for my main work
20:04:50 <altmattr> so I really mean best bang for buck
20:04:52 <altmattr> Core?
20:04:54 <altmattr> PPC?
20:05:00 <altmattr> Xeon?
20:05:16 <saml> > liftM (+2) (return 1)
20:05:17 <lambdabot>   No instance for (GHC.Show.Show (m a1))
20:05:18 <lambdabot>    arising from a use of `M515656771...
20:05:20 <Twey> You want a Reduceron!
20:05:29 <saml> > (\x -> return (x + 2)) =<< (return 1
20:05:30 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
20:05:37 <altmattr> Sparc?
20:05:57 <aavogt> > liftM (+2) (return 1) :: [Int]
20:05:59 <lambdabot>   [3]
20:06:19 <Vanadium> Looks like I can spell liftM f as ((return . f) =<<)?
20:06:27 <aavogt> @src liftM
20:06:27 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
20:06:37 <Saizan_> Vanadium: right
20:06:38 <saml> @pl liftM f
20:06:38 <lambdabot> fmap f
20:07:26 <Saizan_> altmattr: i'd go with x86 or x86_64, disk speed also matters
20:07:31 <Vanadium> @pl \x -> ((return . x) =<<)
20:07:32 <lambdabot> fmap
20:07:34 <Vanadium> Hey >:[
20:08:12 <Saizan_> pl prefers fmap :)
20:08:29 <Vanadium> Is that pl assuming that all monads are functors?
20:08:44 <copumpkin> yup
20:09:03 <altmattr> Saizan_: I thought that might be the case.  Thankfully that is the easy option
20:09:38 <altmattr> ghc really does write lots of files during compilation?
20:10:03 <altmattr> I know you can see a few of them, but are they written and then read from or just output as a side effect?
20:10:16 <copumpkin> well, it calls gcc and things
20:10:24 <copumpkin> even if not -fvia-C
20:11:06 <altmattr> so: fast disk - fast x86 cpu - don't fret over ram?
20:11:20 <altmattr> I would imagine the answer is no, but does OS have any bearing on compilation speed?
20:12:03 <Saizan_> what matters most might be latency, rather than throughput of the disk, i'm not sure
20:12:25 <copumpkin> altmattr: in some cases, there's some alleged influence :)
20:12:36 <copumpkin> but mac os for example still doesn't have x86_64 (although we're getting closer)
20:12:58 <copumpkin> I mean, the GHC for it :) the OS itself supports it nicely
20:14:02 <Saizan_> what's the standard size of ram these days? 4GB?
20:14:11 <altmattr> copumpkin: currently on mac PPC, so I think I have the worst possible setup.  just getting the lastest ghc can be a hassle :)
20:14:15 <Twey> 1-4
20:14:28 <Twey> 2 being mean, I guess
20:14:41 <copumpkin> not many go above 4 yet
20:14:55 <copumpkin> but most recent mac pros, for example, support huge amounts of ram
20:15:12 <copumpkin> so if we can get an x86_64 we'd be able to use lots of it :)
20:15:39 <Twey> Really flashy machines are going with 8GB
20:16:14 <altmattr> copumpkin: indeed, however, the huge hole in my wallet (and consequently, pantry) would dull the joy
20:16:21 <copumpkin> :)
20:16:30 <Twey> Haha
20:16:47 <Twey> ‘I may not be able to eat... but I have MASSIVE AMOUNTS OF RAM!’
20:17:38 <altmattr> I guess it would be RAM and RAMen :)
20:17:49 <Twey> *grooooan* :-D
20:17:57 <monochrom> no food no shelter no electricity but 8GB of RAM.
20:18:16 <Twey> 8GB?  I would expect more than that if I were sacrificing my food stores for it :-P
20:18:27 <monochrom> no food no shelter no electricity but 80GB of RAM.
20:18:31 <Twey> \o/
20:18:39 <monochrom> ought to be enough for everybody
20:18:45 <Twey> Heheheh
20:19:20 <shapr> I have 16gb..
20:19:52 <shapr> 32gb of ram is just too expensive.
20:19:56 <FliP^2eH> 640k is ram is enough for anyone
20:20:10 <altmattr> oh, the kraken wakes
20:20:14 <FliP^2eH> s/is/of
20:20:40 <shapr> uh? Who's the kraken?
20:43:38 <syntaxfree2> there are cheap 16GB flash drives.
20:43:48 <syntaxfree2> I wish I could use them as RAM for some applications.
20:44:07 <syntaxfree2> I don't mind slow performance if it allows me to work with huge datasets in Stata.
20:44:16 <Twey> That's what swap's for
20:44:34 <Twey> You can use a flash drive for swap
20:44:36 <syntaxfree2> yeah. I just don't know how to redirect swap to a flash drive in OS X.
20:44:43 <Twey> It just burns it out pretty quickly
20:44:46 <Twey> Hmn
20:44:51 <Twey> No idea, in OS X.
20:44:58 <syntaxfree2> My Macbook's hard drive is always filled to the brim.
20:45:01 <Twey> I'm pretty sure it's possible, though.  I think we discussed it here before.
20:45:17 <syntaxfree2> I was stupid, buying the sucker model with a 80gb hard drive and 1Gb RAM.
20:45:31 <copumpkin> man dynamic_pager
20:45:32 <syntaxfree2> I could have had a vastly better configuration for a few hundred dollars mroe.
20:45:35 <Twey> Ack.
20:45:38 <Twey> Yeah.
20:45:40 <scutigera> shouldn't burn it out, the wear leveling is built into the drive
20:45:49 <copumpkin> or just map /private/var/vm/swapfile to some other fs
20:45:58 <syntaxfree2> (maybe we should move this discusison to #haskell-blah?)
20:46:12 <syntaxfree2> (just say "flash drive discussion I'm here" there)
20:46:22 <scutigera> I'm here for the graph thingy :-)
20:46:32 <scutigera> I'm not too late, am I ?
21:08:11 <jimmyjazz14> is there a fmap equivlent for Monads (like mapM)
21:08:18 <jimmyjazz14> @type fmapM
21:08:19 <lambdabot> Not in scope: `fmapM'
21:09:06 <copumpkin> liftM
21:09:12 <copumpkin> but it's a synonym for fmap unless someone messed up
21:09:23 <copumpkin> fmap should work on all monads :)
21:10:13 <aavogt> @type mapM
21:10:14 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
21:10:57 <aavogt> @type (sequenceA .) . fmap
21:10:59 <lambdabot> Not in scope: `sequenceA'
21:11:11 <aavogt> @type (Data.Traversable.sequenceA .) . fmap
21:11:12 <lambdabot> forall (t :: * -> *) (f :: * -> *) a a1. (Data.Traversable.Traversable t, Applicative f) => (a1 -> f a) -> t a1 -> f (t a)
21:11:20 * pikhq could've sworn that all monads were functors...
21:11:30 <copumpkin> pikhq: they are, but haskell doesn't know that
21:11:59 <jimmyjazz14> so uh say I have: Just "String"
21:12:11 <jimmyjazz14> and I want to print just the "String" part
21:12:18 <pikhq> copumpkin: Eh, well, just so long as programmers are smart enough to make their monads also instances of functor.
21:12:40 <copumpkin> yeah, or maybe haskell' will fix the built-in typeclasses!
21:12:41 <jimmyjazz14> so: fmap print (Just "String") ; does not work
21:12:45 * copumpkin crosses his fingers
21:13:09 <aavogt> > sequence (Just "String")
21:13:10 <lambdabot>   Couldn't match expected type `[m a]'
21:13:28 <copumpkin> > sequence ["String"]
21:13:30 <lambdabot>   ["S","t","r","i","n","g"]
21:13:46 <jimmyjazz14> @type sequence
21:13:47 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
21:14:01 <aavogt> > join $ maybeToList (Just "String")
21:14:02 <lambdabot>   "String"
21:14:20 <aavogt> > join $ maybeToList (Just [])
21:14:21 <lambdabot>   []
21:14:35 <jimmyjazz14> @type join
21:14:37 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
21:14:53 <aavogt> > concat $ maybeToList (Just [])
21:14:54 <lambdabot>   []
21:14:55 <hzap> when do people usually use join?
21:15:17 <copumpkin> on the (->) a monad to golf
21:15:19 <copumpkin> ;)
21:15:23 <aavogt> hzap: when the type fits?
21:15:38 <copumpkin> > join (*) 5
21:15:40 <lambdabot>   25
21:15:46 <aavogt> > join (Just $ Just Nothing)
21:15:48 <lambdabot>   Just Nothing
21:15:55 <aavogt> > join $ join (Just $ Just Nothing)
21:15:56 <lambdabot>   Nothing
21:15:57 <copumpkin> also, for lists, to help golfage instead of concat
21:16:10 <pikhq> Yeah, treating (->) as the monad it is makes my head hurt right now.
21:16:44 <hzap> I just never find a situation where join jumps out as the way to write a function
21:16:49 <aavogt> well, its all golfage to some extent...
21:17:00 <hzap> "golfage"... nice word
21:17:02 <scutigera> @def golfage
21:17:02 <lambdabot> Maybe you meant: bf let
21:17:17 <scutigera> @type golfage
21:17:19 <lambdabot> Not in scope: `golfage'
21:17:51 <aavogt> hzap: sometimes instead of =<< in pointless code, you can put join instead (and then leave out some brackets)
21:17:59 <copumpkin> > (join . join) (((*) .) . (*)) 5
21:18:01 <lambdabot>   125
21:18:19 <copumpkin> @pl \x -> x  x  x
21:18:19 <lambdabot> (line 1, column 12):
21:18:20 <lambdabot> unexpected "\SI"
21:18:20 <lambdabot> expecting variable, "(", operator or end of input
21:18:26 <aavogt> > 5 ^ 3
21:18:27 <lambdabot>   125
21:18:34 <copumpkin> whoa, what happened there
21:18:35 <scutigera> almost perl-like copumpkin...
21:22:03 <aavogt> :t ((*) >>=)
21:22:04 <lambdabot> forall a b. (Num a) => ((a -> a) -> a -> b) -> a -> b
21:22:31 <aavogt> :t (>>= (*))
21:22:32 <lambdabot> forall a. (Num a) => (a -> a) -> a -> a
21:22:51 <aavogt> > (>>= (*)) (+1) 2
21:22:53 <lambdabot>   6
21:24:44 <aavogt> hzap: I guess (>>= id) doesn't show up much when code focuses on composing stuff
21:25:23 <aavogt> > (>>= (*)) id 2
21:25:25 <lambdabot>   4
21:25:38 <hzap> aavogt: yeah, if I end up doing monadic pointless code, (<=<) is usually enough for composing
21:26:04 <aavogt> hehe, pointless
21:27:58 <Twey> :T (<=<)
21:28:03 <Twey> :t (<=<)
21:28:05 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
21:28:14 <Twey> Oh, right
21:28:30 <Twey> I always forget the bind operators other than >>= =<< >>
21:29:25 <SamB_XP_> technically >> doesn't bind
21:29:57 <SamB_XP_> and <=< is the backwards kleisli arrow
21:30:07 <SamB_XP_> aka kleisli fish
21:30:40 <Twey> Arrow?  But that's a monad
21:31:34 <copumpkin> >>> Kleisli then :P
21:31:45 <SamB_XP_> I don't know what a monad looks like, so I couldn't tell you whether it looks like a monad or not ;-)
21:32:07 <Twey> Heh
21:32:21 <SamB_XP_> but it definately looks like an arrow, and like a fish
21:32:26 <Twey> Something like ◎ I think :-P
21:32:38 <SamB_XP_> and it also definately has something to do with kleisli
21:34:50 <copumpkin> @type (\x y -> Kleisli x <<< Kleisli y)
21:34:52 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> Kleisli m a c
21:34:58 <Twey> Hmph
21:35:07 <copumpkin> @type (\x y -> runKleisli (Kleisli x <<< Kleisli y))
21:35:09 <lambdabot> forall b (m :: * -> *) b1 a. (Monad m) => (b -> m b1) -> (a -> m b) -> a -> m b1
21:35:11 <Twey> I can't find a Unicode character appropriate for representing the Monad.
21:36:00 <SamB_XP_> they are not worthy?
21:36:07 <Twey> Seems so :-P
21:48:24 <Warrigal> > mex [0]
21:48:26 <lambdabot>   1
21:49:06 <portnov> :t mex
21:49:08 <lambdabot> forall a. (Num a, Enum a) => [a] -> a
21:49:25 <Warrigal> It ought to be for integers only.
21:49:32 <Warrigal> > map mex (sequence [0..])
21:49:34 <lambdabot>   No instance for (GHC.Enum.Enum [a])
21:49:34 <lambdabot>    arising from the arithmetic sequence...
21:49:45 <Warrigal> > sequence [0..]
21:49:47 <lambdabot>   No instance for (GHC.Show.Show (m [a]))
21:49:47 <lambdabot>    arising from a use of `M84841362...
21:49:59 <aavogt> > map (mex . flip replicate ()) [1..]
21:50:00 <lambdabot>   No instance for (GHC.Num.Num ())
21:50:00 <lambdabot>    arising from a use of `L.mex' at <inter...
21:50:03 <Warrigal> > sequence (map return [0..])
21:50:05 <lambdabot>   No instance for (GHC.Show.Show (m [a]))
21:50:05 <lambdabot>    arising from a use of `M84495381...
21:50:10 <aavogt> > map (mex . flip replicate 1) [1..]
21:50:11 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
21:50:13 <Warrigal> > sequence (map return [0..]) :: [[Integer]]
21:50:16 <lambdabot>   * Exception: stack overflow
21:51:37 <copumpkin> > mapM return [0..]
21:51:39 <lambdabot>   No instance for (GHC.Show.Show (m [a]))
21:51:39 <lambdabot>    arising from a use of `M37387035...
21:51:47 <Warrigal> So, yer, see if you can figure out what mex does by using it.
21:52:44 <aavogt> > map (mex . join replicate) [1..]
21:52:45 <lambdabot>   Not in scope: `mex'
21:53:01 <Warrigal> Meh.
21:53:33 <copumpkin> :t mex
21:53:35 <lambdabot> Not in scope: `mex'
21:53:38 <Warrigal> It was head . foldr delete [0..].
21:57:31 <gracenotes> @src (\\)
21:57:31 <lambdabot> (\\) = foldl (flip delete)
21:59:00 <aavogt> @type foldr delete
21:59:01 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
21:59:36 <aavogt> > foldr delete [1..10] [1..5]
21:59:38 <lambdabot>   [6,7,8,9,10]
21:59:47 <aavogt> > foldr delete [1..10] [1..15]
21:59:48 <lambdabot>   []
22:00:06 <aavogt> gracenotes: why a left fold?
22:01:02 <Warrigal> > let mex = head . foldr delete [0..]; shuttle fwd rev n = x : shuttle (fwd++[x]) (x:rev) (n+1) where x = mex (take (div n 2) (zipWith xor fwd rev)) in shuttle [] [] 0 :: [Integer]
22:01:04 <ivanm> aavogt: because he's left-handed? :p
22:01:04 <lambdabot>   [0,0,1,0,2,1,0,2,1,0,2,1,3,2,1,3,2,4,3,0,4,3,0,4,3,0,4,1,2,3,1,2,4,1,2,4,1,...
22:01:17 <gracenotes> indeed, I am left-handed
22:01:23 <copumpkin> zomg
22:01:26 <copumpkin> so sinister
22:01:34 <gracenotes> don't I know it
22:01:40 <copumpkin> (I am too)
22:01:48 <gracenotes> but really, foldr vs. foldl doesn't affect behavior too much afaik.
22:01:58 <Warrigal> Would it affect behavior or speed in the case of mex?
22:03:16 <gracenotes> zomgz L! :o
22:05:00 <Twey> It affects behaviour if the provided function isn't commutative
22:05:27 <Twey> More importantly, foldl results in a stack overflow more often than foldr because it doesn't produce intermediate redexes
22:05:42 <Twey> In most cases foldl' is used for left-folds
22:05:54 <Twey> > foldr (:) [1..10]
22:05:55 <lambdabot>   Overlapping instances for GHC.Show.Show ([a] -> [a])
22:05:56 <lambdabot>    arising from a use ...
22:06:02 <Twey> > foldr (:) 0 [1..10]
22:06:04 <lambdabot>   No instance for (GHC.Num.Num [a])
22:06:04 <lambdabot>    arising from the literal `0' at <inter...
22:06:09 <Twey> >.<
22:06:11 <Twey> 'course
22:06:13 <Twey> > foldr (:) [] [1..10]
22:06:15 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
22:06:17 <Twey> > foldl (:) [] [1..10]
22:06:19 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
22:06:24 <Twey> Sorry, it's early :)
22:06:24 <gracenotes> (:[])
22:07:05 <Twey> That errors out because it would be []:10:9:8:7:6:5:4:3:2:1, I think.
22:07:15 <Twey> flip (:) should be equivalent to the foldr
22:07:24 <Twey> > foldl (flip (:)) [] [1..10]
22:07:26 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
22:07:34 <Twey> Oh, except it's backwards
22:07:45 <Twey> Heh
22:07:46 <pikhq> Nice implementation of reverse, though.
22:07:52 <Twey> I guess it affects it rather a lot, then.
22:08:01 <Twey> pikhq: Apart from the overflow :-P
22:08:06 <Twey> > foldl (flip (:)) [] [1..10000000]
22:08:14 <lambdabot>   mueval-core: Prelude.read: no parse
22:08:15 <lambdabot>  mueval: ExitFailure 1
22:08:36 <Twey> ... the overflow that lambdabot hides
22:09:14 <SamB_XP_> gwern: what's going on here?
22:09:32 <pikhq> > foldl' (flip (:)) [] [1..10000000]
22:09:32 <pikhq> ?
22:09:37 <lambdabot>   mueval-core: Prelude.read: no parse
22:09:37 <lambdabot>  mueval: ExitFailure 1
22:09:44 <pikhq> Hooray, overflow.
22:09:46 <aavogt> yeah gwern, I demand an explanation!
22:11:24 <gracenotes> incidentally all of the above work on my computer
22:11:40 <gracenotes> foldl vs. foldl' for flip (:) doesn't matter so much
22:11:52 <gracenotes> constructor application is, like, automatically strict
22:12:21 <gracenotes> @src foldl
22:12:21 <lambdabot> foldl f z []     = z
22:12:22 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
22:12:26 <SamB_XP_> gracenotes: say WHAT ?
22:12:35 <aavogt> > take 1 $ 1 : undefined
22:12:36 <lambdabot>   [1]
22:12:39 <SamB_XP_> , foldl (flip (:)) [] [1..10000000]
22:12:43 <lunabot>  luna: out of memory (requested 1048576 bytes)
22:12:52 <SamB_XP_> , foldl' (flip (:)) [] [1..10000000]
22:12:53 <gracenotes> foldl_reverse z [] = z
22:12:54 <gracenotes> foldl_reverse z (x:xs) = foldl_reverse (x:z) xs
22:12:54 <lunabot>  luna: out of memory (requested 1048576 bytes)
22:13:29 <aavogt> > tail $ undefined : [1]
22:13:31 <lambdabot>   [1]
22:13:33 <SamB_XP_> hmm, think that's GHC trying to reallocate the TSO?
22:13:34 <gracenotes> you see, the list in the second parameter is accumulated like a stack, as you scan the list from left to right, you'll finally reach the top of the stack at the end of the list
22:13:39 <gracenotes> effectively reversing it
22:14:23 <gracenotes> well, it took about 500 MB for me...
22:15:22 <aavogt> gracenotes: what do you mean by automatically strict?
22:16:33 <gracenotes> whenever you use a `seq` b, what GHC does (simplification) is to see if a has a constructor visible
22:17:12 <Warrigal> > seq (undefined : undefined) 3
22:17:13 <lambdabot>   3
22:17:14 <gracenotes> if it's an infinite loop, it will never produce anything
22:17:36 <gracenotes> What Warrigal did
22:18:15 <gracenotes> if you do 3 `seq` 3, for example, the 3 will have a constructor visible, possible the Int constructor, I#
22:18:19 <gracenotes> the first 3
22:18:43 <gracenotes> but it's to make sure it's not undefined or a black hole or something
22:19:41 <gracenotes> if you just apply any old function, like (+), you don't know if it'll produce a constructor; it becomes a thunk, a function with two arguments that needs to be evaluated. foldl' evaluates it by getting the number's constructor, the final result
22:20:08 <gracenotes> uh. using seq. But for (:) I believe GHC doesn't bother making a thunk of it
22:20:24 <gracenotes> so stack overflowing isn't as likely I suppose
22:21:54 <aavogt> right, so constructors are fully defined when their inputs are fully defined
22:23:48 <kniu> So I heard type-inference for rank-n types is undecidable.
22:23:50 <gracenotes> yeah, (2:) isn't a value that has a constructor; it's still a function. But as Warrigal eval'd, (undefined:undefined) is strict as far as seq is concerned, since it has a constructor with all the values
22:23:59 <SamB_XP_> kniu: yup!
22:24:06 <SamB_XP_> don't you just love undecidable things ?
22:24:22 <kniu> does that mean that a compiler can't even know which types cannot be inferred?
22:24:39 <Warrigal> @type I#
22:24:41 <lambdabot> Not in scope: data constructor `I#'
22:24:45 <Warrigal> @hoogle I#
22:24:46 <lambdabot> No results found
22:24:48 <SamB_XP_> oh, instead it just makes you tell it enough that it can figure out what to do for sure
22:24:50 * Warrigal frowns.
22:25:11 <aavogt> @index I#
22:25:11 <lambdabot> GHC.Exts
22:25:18 <kniu> SamB_XP_, in general System F omega too?
22:25:58 <SamB_XP_> it has a way to rule out the "gray area" where it would never terminate and make you guide it
22:26:03 <kniu> ah.
22:26:07 <gracenotes> kniu: iirc, type inference is undecidable but type checking isn't it
22:26:11 <kniu> that makes more sense.
22:26:12 <gracenotes> minus it
22:26:47 <SamB_XP_> so it makes you write signatures for higher-rank stuff, basically
22:27:25 <kniu> I was thinking that the typechecker could get stuck in an infinite loop and you'd never know what happened.
22:32:43 <Saizan_> kniu: nah, that's only with type families
22:33:11 <gracenotes> omg xkcd knows the prime numbers! WE HAVE SOMETHING IN COMMON!
22:34:15 <SamB_XP_> do they do something special for prime-numbered strips ?
22:35:33 <gracenotes> I believe he's saying that the sum of the reciprocals of the primes is divergent
22:36:06 <SamB_XP_> huh. really?
22:36:07 <gracenotes> ...I am not certain if this is true
22:36:10 <SamB_XP_> that's a bit strange
22:36:14 <SamB_XP_> I would not expect that
22:36:27 <SamB_XP_> but then, what do I know about primes ?
22:36:38 <gracenotes> although after all 1/n is divergent.....
22:37:27 <gracenotes> okay, here we go! http://en.wikipedia.org/wiki/Proof_that_the_sum_of_the_reciprocals_of_the_primes_diverges
22:38:52 <SamB_XP_> gracenotes: yeah, but I'd have thought the primes would grow a bit more quickly than n does ;-)
22:40:20 <twb> What does this mean?
22:40:21 <twb> Warning: orphan instance: instance ReadableDirectory TreeIO
22:42:52 <SamB_XP_> twb: it means that the instance is defined seperately from both class and type
22:43:04 <SamB_XP_> that is, in a different module from both
22:43:31 <Saizan_> it's considered bad style because it allows different modules to import different instances for the same type and class
22:44:07 <SamB_XP_> and GHC also has to pull those things in just to look for instances
22:44:07 <Saizan_> but it's also considered a necessary evil for modularity..
22:44:20 <Saizan_> (by others)
22:44:27 <SamB_XP_> I mean, has to look at their .hi files ...
22:44:45 <twb> Should I move it into the class or type's module?
22:45:06 <twb> Or, can I tell GHC "don't complain about this one case, just for now"?
22:45:51 <Saizan_> you can look at the flag reference to see if there's one to turn off that warning
22:48:56 <twb> Saizan_: well, I'd still like to get that warning for OTHER cases of it.
22:51:34 <Saizan_> twb: most flags can be put in module headers, like {-# OPTIONS_GHC .. #-}
22:52:10 <Saizan_> twb: i don't know if the flag exists in the first place, but i'm not aware of any other way, except moving the instance
22:52:16 <ivanm> I have a function f :: (a -> Maybe b) -> a -> Either a b, and another g :: a -> IO (Maybe b); how can I use them to get a -> IO (Either a b) ?
22:52:51 <ivanm> (can I?)
22:54:26 * ski . o O ( `(a -> MaybeT m b) -> (a -> EitherT a m b)' ?)
22:54:37 <ivanm> yeah, didn't think I could :s
22:56:39 <gracenotes> hm. What parts of Haskell 98 relate to laziness?
22:57:05 <gracenotes> if any o_o
22:58:34 <ivanm> gracenotes: the whole thing?
22:58:43 <ivanm> well, technically it's just "non-strict" IIRC
22:58:59 <ivanm> but most people interpret that as "lazy" (Because they're too lazy to think of another meaning/implementation :p )
22:59:21 <gracenotes> hm. it doesn't formulate this, uh, formally. but it mentions it
22:59:47 <ivanm> why doesn't it need to formulate it?  just state that it's for a non-strict language...
22:59:51 <ivanm> hence it is by definition
23:00:05 <gracenotes> mm. Well, the semantics :)
23:00:15 <gracenotes> I guess it leaves some of it up in the air
23:06:39 <twb> Doesn't "lazy" mean really "normal order" or something? ;-P
23:07:32 <|Jedai|> twb: "lazy" is an evaluation strategy, Haskell98 only require that Haskell implementation be non-strict
23:07:39 <quicksilver> lazy is normally taken to mean something about sharing too, twb
23:07:46 <quicksilver> twb: something like "normal order with maximal sharing"
23:07:46 <|Jedai|> twb: most use call-by-need
23:07:59 <|Jedai|> quicksilver: nope, it's with minimal sharing
23:08:06 <twb> quicksilver: you mean automatic memoization of everything?
23:08:14 <|Jedai|> quicksilver: at least in all definitions I saw
23:08:15 <quicksilver> no
23:08:18 <quicksilver> just named terms
23:08:34 <twb> FSVO named = bound?
23:08:35 <Saizan_> more sharing than call-by-need :)
23:08:58 <|Jedai|> quicksilver: What you're speaking about is call-by-need, the evaluation strategy used by most Haskell implementation
23:09:34 <|Jedai|> Saizan_: From everything I read it's the reverse, naive lazy evaluation don't preserve sharing
23:10:05 <Saizan_> ops, "typo" more sharing than call-by-name is what i meant
23:10:33 <|Jedai|> Saizan_: Ok then
23:11:00 <Saizan_> so yeah, i tend to confuse lazy with call-by-need, and i probably shouldn't
23:11:43 <|Jedai|> Saizan_: call-by-name is what I call naive lazy evaluation I think, it seemed to me it was established vocabulary but apparently not
23:13:00 <Saizan_> maybe lazy is a denotational term while call-by-name vs. call-by-need are operational?
23:13:27 <opqdonut> i don't think so, no
23:13:43 <opqdonut> normal order is "denotational", lazy, cbn and cbn are operational
23:14:47 <twb> I thought call by name was what make(1) does.
23:14:57 <twb> (I'm not familiar with Algol 60)
23:15:14 <opqdonut> i somehow detest the cb* when used in conjunction with lambda calculus
23:15:31 <twb> opqdonut: which lambda calculus? ;-)
23:16:34 <opqdonut> any
23:17:26 <opqdonut> yeah, anyway, call-by-need, normal-order and lazy produce the same normal forms for non-functions
23:18:02 <opqdonut> which is really all we care about
23:22:38 <twb> Sigh.
23:22:48 <twb> Why can't I just copy-and-paste type signatures from GHC's warnings
23:23:19 <twb> Always I have to piss about adding parens and removing ∀ and such
23:29:19 <ivanm> twb: what's stopping you? :p
23:30:13 * gracenotes rocks out to Dr. Horrible soundtrack
23:46:50 <hackagebot> windowslive 0.3 - Implements Windows Live Web Authentication and (JoshHoyt)
23:48:23 <cizra> Gracenotes: Why do rock out to Dr, if it has such a horrible soundtrack? (;
23:53:08 <twb> Awesome
23:53:17 <twb> So ./Setup build works iff I don't configure with --user
23:53:30 * twb kicks all of Cabal
23:56:51 <dmwit> twb: Sounds like you've got some library installed once as user and once as not-user and getting some nasty shadowing effects.
23:58:36 <kniu> dang.
23:58:56 <twb> Yeah, Debian and Cabal have HUGE fucking dll-hell fights
23:59:51 <kniu> for fun and profit, I was imagining a haskell/lisp unholy union, so I put it down in BNF.
