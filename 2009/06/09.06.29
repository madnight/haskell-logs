00:06:34 <copumpkin> well the meat of the code shouldn't be too hard to follow (from what I've seen)
00:06:56 <copumpkin> but the notion of a function will be quite different
00:08:58 <mmorrow> copumpkin: i bet it'd be pretty easy to build a pretty cool looking graph given some asm, just by using quick-and-dirty grep-like pattern matching for jumps/calls, by first slurping in all the code, putting it into a (Map Label [String]), then following all the branches to get a (Map Label [Either String Label])
00:09:09 <copumpkin> yeah :)
00:09:12 <copumpkin> basic blocks
00:09:37 <mmorrow> s/[Either String Label]/data Instr = Other String | Jumpish String Label/
00:09:37 <copumpkin> but something like IDA's autoanalysis to build logical functions will fail miseraby
00:09:58 <mmorrow> logical wrt C?
00:10:10 <copumpkin> yeah, or c++
00:10:11 <mmorrow> (probably)
00:10:22 <copumpkin> or objc, which is basically c
00:10:31 <copumpkin> they pretty much all behave the same way
00:10:49 <copumpkin> although c++ exceptions can still throw it off
00:11:25 <mmorrow> heh, i wonder what something like that would spit out as the "logical C function" structure of some ghc code that doesn't use a single call between bits of its gen code
00:11:42 <mmorrow> (between bits of gen haskell code)
00:12:24 <copumpkin> likely very little... it mainly follows functions on x86 by looking for typical return instructions, function preludes and cleanup, and by keeping track of the relative stack pointer
00:12:45 <mmorrow> maybe it would mistake some random data in an info table for a "call" instr, and explode :P
00:13:04 <copumpkin> hah, it's usually pretty good at not mistaking data for code
00:13:15 <copumpkin> it follows jumps
00:13:22 <mmorrow> do you have a copy of this prog?
00:13:44 <copumpkin> it can be found on shady sites :) or bought! I did the latter
00:13:55 <copumpkin> http://hex-rays.com/
00:13:57 <mmorrow> ooh, so you have it?
00:14:12 <mmorrow> can haz screenshot of graph of ghc-asm?
00:14:19 <copumpkin> yeah, I just didn't bother installing it on my macbook air, as booting windows in a VM is too slow
00:14:34 <mmorrow> ah, windows only :(
00:14:35 <copumpkin> I'll make you one when I go into my lab tomorrow or tuesday
00:14:41 <mmorrow> yay!
00:14:41 <copumpkin> it actually runs on linux and mac os too
00:14:48 <copumpkin> but it's a curses "gui"
00:14:54 <mmorrow> heh
00:15:00 <copumpkin> the windows one has a real GUI :)
00:15:01 <mmorrow> does it still make pretty pictures?
00:15:08 <copumpkin> not the curses one
00:15:11 <mmorrow> :(
00:15:17 <copumpkin> it's still an amazing program even without the graphs
00:15:40 <mmorrow> bettar than objdump -D ??!
00:15:44 <copumpkin> lol
00:15:45 <copumpkin> yeah
00:15:46 <mmorrow> heh
00:15:54 <copumpkin> they also make the decompiler plugin for the program: http://hex-rays.com/compare.shtml
00:16:01 <copumpkin> that's a pretty amazing product :)
00:16:31 <copumpkin> they haven't updated that page since the latest version, but the decompiler output is even nicer now
00:16:49 <mmorrow> they give an att syntax view option too?
00:17:02 <copumpkin> yeah
00:17:06 <mmorrow> phew
00:17:26 <copumpkin> the main idea behind it (the disasembler and decompiler) is that it's interactive
00:17:38 <mmorrow> ah cool
00:17:42 <copumpkin> you can rename stack variables, registers, put in comments
00:17:47 <copumpkin> and have it all propagate the way you'd expect
00:17:57 <mmorrow> all what?
00:18:05 <mmorrow> ah, didn't see your prev line
00:18:07 <copumpkin> you can also help it out, in case it doesn't detect jump tables for switch statements and things
00:18:15 <copumpkin> and it's scriptable
00:18:24 <mmorrow> oh nice, with what?
00:18:39 <copumpkin> they have their own language and recently added python built in
00:18:56 <copumpkin> but have a c++ interface for arbitrary extensions/plugins and scripting language modules
00:19:13 <copumpkin> I started writing a ruby one at one point but lost interest when they put python in by default
00:19:25 <EnglishGent> morning :)
00:19:29 <copumpkin> hi :)
00:19:39 <EnglishGent> hi copumpkin :)
00:19:45 <EnglishGent> how's things?
00:19:49 <EnglishGent> :)
00:19:53 <copumpkin> I'm procrastinating as usual
00:19:59 <copumpkin> but am quite content
00:20:05 <EnglishGent> :)
00:20:15 <copumpkin> you?
00:20:26 <EnglishGent> not too bad - just waking up
00:20:48 <EnglishGent> starting coffee #1 :)
00:21:08 <EnglishGent> have you read 'house of suns' by Alistair Reynolds btw?
00:21:12 * EnglishGent finished it recently
00:21:32 <EnglishGent> there's a character there who um.... procrasinates quite a bit
00:21:51 <EnglishGent> his motto is 'why do today, what you can do in a quarter of a million years' :)
00:22:34 <copumpkin> :)
00:22:45 <copumpkin> sounds good, I haven't read it
00:22:54 <copumpkin> this should probably be in #haskell-blah btw
00:23:01 <EnglishGent> ah ok!
00:23:07 <copumpkin> which is about everything but haskell :P
00:23:08 <EnglishGent> well I have an actual haskell question as well
00:23:18 <EnglishGent> but we can continue this chat in haskell-blah :)
00:23:21 <EnglishGent> hi cogno
00:23:44 <EnglishGent> do you know how to persuade GHC to show me the path it uses for searching for files?
00:23:54 <EnglishGent> I'm running it on debian linux
00:24:00 <copumpkin> try ghc -v maybe?
00:26:02 <EnglishGent> hmm.. that tells me something about a package config file
00:26:14 <EnglishGent> hang on... I'm going to try seeing if it will tell me more with -help
00:26:32 * EnglishGent has gotten so used to using GHC from within emacs he almost never starts it from the shell
00:26:33 <EnglishGent> :)
00:31:20 <EnglishGent> no - that doesnt help either
00:31:21 <EnglishGent> :|
00:31:48 <EnglishGent> and I've looked at the package config file... thats not really of much help
00:31:53 <Saizan> do you have an higher-level problem?
00:32:11 <EnglishGent> I'm trying to find the source to the standard prelude
00:32:22 <EnglishGent> and other standard modules
00:32:34 <Saizan> ah, the source of packages is not installed
00:32:42 <EnglishGent> I'd like to be able to study it in the hope of improving my haskell :)
00:32:42 <EnglishGent> ah!
00:33:13 <Saizan> you only have the .hi and .o files, in the locations you can find in ghc-pkg describe $pkg
00:33:31 <Saizan> if you want the source you've to download the tarball, or look at the repos of the various libraries
00:33:47 <EnglishGent> thanks Saizan :)
00:34:01 <Saizan> http://haskell.org/ghc/docs/latest/html/libraries/index.html <- the documentation here also has links to highlighted sources
00:34:28 <EnglishGent> I also want to be able to set up stuff from hackage... I'm reading Cabal docs
00:34:30 <copumpkin> there's also cabal unpack
00:34:32 <copumpkin> iirc
00:34:37 <EnglishGent> is that the correct way to do it? (Cabal)
00:34:42 <Saizan> which is what you get with "cabal haddock --hyperlink-source"
00:35:12 <Saizan> to install libs from hackage you'd want to install the cabal-install command line tool
00:35:28 * EnglishGent feels he has at least a rudimentary grasp of the language now, but still needs to learn the associated toolset (packaging, documentation generation, etc)
00:36:05 <Saizan> http://haskell.org/haskellwiki/Cabal-Install
00:36:06 <EnglishGent> also my knowledge is basically limited to the language + standard prelude... I'd like to learn more about the other modules
00:36:13 <EnglishGent> :)
00:36:29 <Axman6> ok, does anyone have a nice place to look at to show you how to host a darcs repo in a web server?
00:36:37 <EnglishGent> thanks :)
00:37:02 <Gracenotes> yeeaaaaaaahhhhhh
00:37:12 <fabulous> Axman6: er, you just make the directory public
00:37:19 <Saizan> Axman6: i think you just have to serve the directory as any other static content
00:37:44 <Axman6> ok, well how to i sync it with my local copy? i'm not very familliar with darcs
00:37:53 <Saizan> to push you use ssh
00:38:00 <Axman6> ah, isee
00:38:05 <Axman6> <space>*
00:38:49 <maltem> more precisely, you use anything you would use to get files into the www directory :)
00:39:19 <maltem> oh wait, that was darcs-push
00:40:28 <EnglishGent> actually that's another question - does anyone know of a tutorial style guide to the standard modules (Data.List, etc)
00:40:32 <EnglishGent> something like the java-trails
00:41:50 <Axman6> wow... darcs frigging hates medium sized files
00:41:55 * EnglishGent apologises for using the j-word in channel... I shall try not to use bad language in future :|
00:41:55 <magic_user> I wish to become a level one haskell mage
00:42:03 <EnglishGent> hello magic_user :)
00:42:07 <magic_user> is learn u a haskell for great good the best oen to start?
00:42:17 <Axman6> magic_user: yep
00:42:18 <magic_user> why hello fellow english high fantasy reader
00:42:26 <magic_user> and if I know really bash only
00:42:37 <magic_user> can I get along and learn to program ebay style stuff
00:42:48 <magic_user> I took some stabs at  common lisp
00:42:52 <magic_user> but got frustrated
00:43:05 <magic_user> the prefix notation is a awesome calcualtor tho
00:43:12 <EnglishGent> why did you get frustrated? (curious)
00:43:33 <magic_user> I have 3 haskell books and they put stuff like --> in there as if I am supposed to know what it means
00:43:34 * EnglishGent is interested in language design & is always interested in people's learning experiences :)
00:43:51 <Saizan> you won't get to the level of ebay only with LYAH, since you'd need to learn about HTTP/HTML/etc.. but it's a good start for haskell,
00:43:52 <magic_user> well in paul grahams ansi common lisp the exercises at end of ch2 are quite the bugger
00:43:57 <magic_user> esp #6 and 8
00:44:07 <magic_user> perhaps I overthunk them
00:44:17 <magic_user> I want to build a web service in common lisp
00:44:23 <magic_user> but have not learned enough
00:44:36 <copumpkin> lol @ the j-word
00:44:36 <magic_user> i am thinking of backing out and reading gentro intro by oturetsky perhaps
00:44:43 <EnglishGent> you might want to look at 'practical common lisp' for that (building a web server)
00:44:53 <EnglishGent> it's available free online :)
00:45:09 <mmorrow> there're some pretty cool looking scheme ones i've seen, although i've only read about them, never used them
00:45:21 <Axman6> magic_user: best to start trying to learn haskell before trying to build anything with it. firt you learn a language, then you use it, not the other way around ;)
00:45:26 <mmorrow> (web-server/thingies)
00:45:29 <magic_user> ok
00:46:02 <Zrs> By 'learn haskell' I'm sure he means 'do lots of small thingers/utilities', because you learn programming by doing.
00:46:08 <magic_user> yeah I am suspicious fo the pcl guy because I think he is now writing books not building powerful website son common lisp
00:46:13 <magic_user> which is annoying
00:46:23 <mmorrow> what's that one continuation-based scheme webserver that stores them in a table, and reifies them when a link with their key is requested?
00:46:30 <magic_user> youd think if he had what is one fo most powerful tools he would make a killer site
00:46:32 * mmorrow is drawing a blank
00:46:38 <cogno> You must read code too
00:47:00 <fabulous> oh fuck me
00:47:08 <magic_user> scheme uh hmmm there was one uh what was it, plt scheme ahd one, but there was naother by the scheme 48 or something guys that did continuations
00:47:14 * copumpkin ****s fabulous
00:47:22 <Axman6> oh my
00:47:25 <cogno> That's the merit of open source
00:47:26 <fabulous> you can stop talking now
00:47:28 <mmorrow> http://docs.plt-scheme.org/web-server/index.html
00:47:31 <fabulous> magic_user is @protontorpedo
00:47:41 <magic_user> my past is behind me
00:47:52 <magic_user> and everyone loves research
00:47:55 <copumpkin> fabulous: thanks for the permission :)
00:47:59 * Axman6 read that as protontor pedo o.O
00:48:02 <magic_user> but I will be quite rather than el booto
00:49:03 * cogno remember writing C  with the k&r as unique information souc
00:49:15 <cogno> Source
00:49:17 <Axman6> yuck
00:50:42 <magic_user> happstack looks like it has potential
00:50:43 <mmorrow> cogno: haha, me too
00:52:47 <magic_user> so once you learn haskell.................I mean......how do you feel.....must you still look a lot of lib stuff up?......I saw this haskell threads things that looked sick....like 1E7 threads or something
00:53:02 <cogno> mmorrow, hopefully i joinew s
00:53:02 <magic_user> that would surely make a powerful webserver
00:53:18 <cogno> T
00:53:27 <dmwit> magic_user: I don't know any language that makes library documentation obsolete.
00:53:39 <dmwit> If you find one, let me know; I'd be very interested in that kind of necromancy.
00:54:03 <magic_user> forth?
00:54:03 <magic_user> lol
00:54:03 <cogno> Oop limechaton an iPhone is hard on me
00:54:11 --- mode: ChanServ set +o fabulous
00:54:27 <magic_user> when I hang around the plan9 channel they say a lot about oo programmign being crap
00:54:43 <magic_user> one guy even said freebsd types know ass about c programming
00:54:46 <magic_user> kinda funny
00:54:57 <magic_user> I heard darcs had scaling problems
00:55:01 <magic_user> have they been addressed?
00:55:11 <magic_user> or is this git thing like the cats mewow
00:55:26 <magic_user> its all I can to do use svn
00:55:35 <mmorrow> @protontorpedo
00:55:35 <lambdabot> ok is haskell a type of lisp?
00:55:48 --- mode: fabulous set +b *!i=4cac0c91@gateway/web/freenode/x-932f98bffb5bd939
00:55:56 <mmorrow> @nixon
00:55:57 <lambdabot> Always remember that others may hate you but those who hate you don't win unless you hate them. And then you destroy yourself.
00:55:59 <opqdonut> :D
00:56:01 <fabulous> wow, this client sucks
00:56:22 <Zrs> @protontorpedo
00:56:22 <lambdabot> I am banned from like 6 rooms
00:56:37 --- mode: fabulous set -o fabulous
00:56:37 <opqdonut> magic_user: most scaling issues have ben cleared up, but darcs still isn't really usable on really big repos (AFAIK)
00:57:02 <cogno> mmorrow hopefully i joined sun and the net the next year
00:57:24 <cogno> That was in 1988
00:57:29 <mmorrow> cogno: heh
00:57:30 <Zrs> girl119
00:57:32 <Zrs> @girl119
00:57:33 <lambdabot> I've always found myself unequal to the intellectual pressure of programming
00:58:13 <dmwit> 3 atm: the intellectual pressure of programming
01:02:46 <Axman6> fabulous: who'd you ban?
01:03:32 <Zao> A wild guess would be magic_user.
01:03:40 <fabulous> Axman6: magic_user
01:03:49 <Axman6> oh? how come?
01:03:51 <Saizan> ?
01:04:12 <Saizan> we should jump to conclusions about trolling like that
01:04:16 <Saizan> *shouldn't
01:04:33 <Axman6> yeah.. i didn't see ay signs of trolling
01:05:00 --- mode: ChanServ set +o Saizan
01:05:14 <fabulous> <magic_user> yeah I am suspicious fo the pcl guy because I think he is now writing books not building powerful website son common lisp
01:05:22 <ben> Well it seemed to be vaguely inflammatory offtopic rambling
01:05:37 <fabulous> ^ I did here
01:05:51 --- mode: Saizan set -b *!i=4cac0c91@gateway/web/freenode/x-932f98bffb5bd939
01:06:13 <Saizan> well, that's not really in topic or a much deep analysis, but nothing really worth a ban
01:06:25 <fabulous> Saizan: I disagree
01:06:44 <Saizan> come to #haskell-ops to discuss :)
01:08:14 * copumpkin eavesdrops on #haskell-ops
01:10:54 --- mode: Saizan set -o Saizan
01:14:17 <Saizan> copumpkin: did you end up using that labelling system for ASM?
01:14:57 <copumpkin> what labelling system for asm?
01:15:01 <copumpkin> oh
01:15:22 <copumpkin> I've got it sitting around but haven't integrated it with the rest of the arm package yet :)
01:15:28 <copumpkin> I only really have a decoder so far
01:15:49 <EnglishGent> can we do that? (evesdrop?)
01:16:16 * EnglishGent thought most ops channels where by invitation only!
01:16:17 <dmwit> It's as easy as /join #haskell-ops. ;-)
01:16:25 <copumpkin> I know, but I feel awkward hanging out in there
01:16:35 <copumpkin> not sure if non-ops are welcome unless they're protesting a ban or something
01:16:54 <mornfall> copumpkin: In case they are protesting, the less welcome they are, I guess. : - P
01:17:00 <Gracenotes> x.x
01:17:46 * EnglishGent was just curious as to the case of magic_man - I dont know the individuals history obviously, but he seemed ok to me
01:17:48 * EnglishGent shrugs
01:18:00 * EnglishGent has ops in several major channels on dal-net
01:18:09 * EnglishGent shrugs again
01:18:12 <dibblego> I wish there were an infix fmap
01:18:14 <copumpkin> I feel the same way :)
01:18:20 <Saizan> dibblego: <$>
01:18:21 <mornfall> dibblego: <$>, `fmap`
01:18:21 <ivanm> isn't there?
01:18:23 * copumpkin tries to pronounce <$> but fails
01:18:24 <ivanm> thought so
01:18:28 <dibblego> er, infix flip fmap
01:18:32 <copumpkin> oh
01:18:36 <dibblego> sorry :)
01:18:44 <ivanm> copumpkin: "less than, dollar, greater than" <-- how hard is that? :p
01:18:47 <dmwit> So... define one. ;-)
01:18:48 <Saizan> >>^ to some extent..
01:19:05 <dibblego> there (<**>) but not (<$$>)
01:19:27 <mornfall> (<€>) = flip (<$>)
01:19:35 * earthy laughs
01:19:53 <EnglishGent> I wish haskell would let me end function names in '?'
01:20:02 <copumpkin> that'd be nice
01:20:07 * EnglishGent likes the scheme convention of ending predicates that way
01:20:18 <EnglishGent> odd? even? etc
01:20:20 <earthy> well, there's a predating lisp convention that ends predicats with p
01:20:24 <earthy> oddp evenp
01:20:27 <copumpkin> I partially like the naming distinction between types and values, but I'd also like to get rid of it
01:20:35 <ivanm> mornfall: no, you need the mirror image of $
01:20:49 <EnglishGent> yes I know - I suppose I could use that earthy - the ? seems more elegant
01:21:01 <copumpkin> ＄
01:21:05 <copumpkin> my dollar is extra large
01:21:26 <Saizan> no, don't end them in p.. stick with the conventions!
01:21:39 <EnglishGent> I'd like to be able to add checks to constructors (which would be sort of erasing the naming distinction)
01:22:22 <WorkyBob> Is there any way to get ghci to forget about a binding?
01:22:28 <EnglishGent> so that you could do data PlanarRightAngledTriangle = PRAT o::Real a::Real h::Real where o^2 + a^2 = h^2
01:22:43 <EnglishGent> and get an error if you tried to construct one where that condition wasnt satisfied
01:22:53 <earthy> englishgent: in haskell, it actually tends to look nicer if you don't use the suffices
01:22:57 <earthy> suffixes
01:23:06 <copumpkin> we also like short names :P
01:23:10 <earthy> e.g. if odd num then someExpr els otherExpr
01:23:11 <Saizan> that's called using "smart constructors", i.e. you define functions to build your datatypes and don't export the real constructor
01:23:36 <EnglishGent> right - I know I could do it that way Saizan - but then my 'smart constructors' cant being with a capital letter
01:23:40 <EnglishGent> like regular constructors dfo
01:23:42 <EnglishGent> do
01:23:51 <Saizan> yup, and you can't use them in patterns
01:23:52 <WorkyBob> EnglishGent: that's okay, they can't be pattern matched on too
01:23:59 <WorkyBob> so it's nice to have a distinction
01:24:19 <Saizan> it's be nice to be able to export a constructor only for pattern matching
01:24:25 <WorkyBob> smart constructors should be used with care -- only where you *really deffinately* don't want the user to know the internal structure of your type
01:24:30 <EnglishGent> well if *all* they do is a check - there's no reason why you couldnt pattern match on them as well
01:25:01 <EnglishGent> I mean in principle
01:25:06 <EnglishGent> obviously you cant in practice
01:25:06 <dsturnbull> EnglishGent: odd? even? would be .. how do you say.. turborad
01:25:16 <earthy> ah! <₴> !
01:25:25 <EnglishGent> turborad?
01:25:49 <dsturnbull> oh you're an english gentleman.. "tip top terrific" then
01:25:50 <dsturnbull> ;)
01:25:53 <dmwit> > let x <? y = x < y in 32 <? 52
01:25:54 <lambdabot>   True
01:25:58 <WorkyBob> EnglishGent: perhaps the problem is your type stores too much information
01:26:04 <WorkyBob> EnglishGent: why do you need to store the hypotenuse length in there?
01:26:16 <EnglishGent> in fact whilst we're at it... I think it should be data List a = Empty + Cons a (List a) -- not List a = Empty | Cons a (List a)
01:26:28 <WorkyBob> data PlanarRightAndleTriangle = PRAT {o :: Double, a :: Double}
01:26:29 <EnglishGent> they are mutually exclusive - it's an xor, not an inclusive or!
01:26:52 <fabulous> but xor is ^
01:26:57 <WorkyBob> h :: PlanarRightAngleTriangle -> Double
01:26:57 <WorkyBob> h (PRAT o a) = sqrt (o^2 + a^2)
01:27:00 <EnglishGent> oh! now I understand you dsturnbull :D
01:27:22 <EnglishGent> I'm thinking of mathsy notation fabulous :)
01:27:30 <EnglishGent> i.e. boolean algebra
01:28:15 <mornfall> Well, if there was a question-mark-that's-a-letter in unicode, that'd help things. :)
01:28:33 <Cale> ^ is and, v is or ;)
01:29:06 * WorkyBob usually sees ≠ for xor
01:29:14 <Zao> Cale: After having done UI code with the Marlett font, 3 is left arrow, 4 is right, 5 is up, 6 is down.
01:29:34 <Zao> Cale: The arrows on scrollbars on Windows are actually characters in a funny font :)
01:29:38 <Zao> Free scaling.
01:29:51 <Cale> Or more correctly, ∧ is 'and', ∨ is 'or' :)
01:29:59 <Cale> Zao: yeah
01:30:08 <WorkyBob> Zao: not very free -- scaling and rendering a font costs much more than scaling and rendering a path with 3 segments
01:30:09 <dmwit> Zao: That's terrible.  Why not just use real vector graphics...?
01:30:10 <mornfall> Meets and joins, joins and meets.
01:30:15 <EnglishGent> Cale - that would work as well :)
01:30:37 <Zao> dmwit: Back in the days, when you had the text engine paged in already, why not utilize it? :)
01:30:50 <EnglishGent> likewise - why is it (2,"hello") :: (Int, [Char]) & not (2, "hello") :: Int * [Char]
01:30:51 <Zao> dmwit: "you want how many K of memory to do _what_?"
01:30:53 <EnglishGent> a'la ML?
01:30:55 * dmwit splutters
01:31:00 <EnglishGent> it's a cartesian product type dammit!
01:31:03 <EnglishGent> :|
01:31:03 <Cale> Zao: I've done that too. There are some useful bits in there for those triangular arrows which turn when displaying more detail.
01:31:16 <WorkyBob> Zao: because rendering the character *still* needs you to sit and look at font hinting and weird sub-pixel AA stuff, while drawing 3 lines does noe
01:31:17 <WorkyBob> not*
01:31:24 * dmwit uses the paged-in vector-graphics library to do his font-rendering just to spite Zao
01:31:39 <copumpkin> EnglishGent: you want + instead of | for constructors too? :P
01:31:39 <mornfall> EnglishGent: type a :*: b = (a, b) maybe?
01:31:47 <mornfall> copumpkin: That was the first thing he wanted.
01:31:52 <copumpkin> oh, missed that :)
01:32:12 <mornfall> Actually, I might be quite hungry.
01:32:18 <fabulous> funrelated: http://awos.wilcox-tech.com/people/gavin.php
01:32:20 <copumpkin> type a :+: b = Either a b then
01:32:21 <EnglishGent> mornfall - I think the HList library does exactly that...
01:32:30 <Cale> EnglishGent: well, it makes *some* sense for pairs of types to correspond to types of pairs.
01:33:00 <Zao> dmwit: http://www.valvesoftware.com/publications/2007/SIGGRAPH2007_AlphaTestedMagnification.pdf
01:33:13 <Zao> dmwit: Now that's the way to represent text :)
01:33:25 <Zao> Distance fields instead of vectors.
01:33:38 <EnglishGent> true Cale - but my preference would still be for more mathsy notation :)
01:33:39 <WorkyBob> EnglishGent: one justification would be that * on types is associative -- tuples are not
01:33:47 <WorkyBob> (a,b,c) is not the same type as a * b * c
01:33:50 <dmwit> ooooh yeah
01:34:06 <WorkyBob> (of course I'd like to get rid of tuples, but *shrug*)
01:34:18 <EnglishGent> but * isnt associative in abstract mathematics either - think of multiplicative groups
01:34:40 <copumpkin> having n-tuples (implicitly) behave like nested pairs would be nice
01:34:45 <EnglishGent> and WorkyBob - wouldnt you have to allow Hetrogenous lists to do that?
01:34:57 <WorkyBob> EnglishGent: to do what?
01:34:59 <mornfall> EnglishGent: Group, if anything, is required to be associative.
01:35:02 <EnglishGent> get rid of tuples
01:35:05 <WorkyBob> no
01:35:11 <WorkyBob> just have nested pair types
01:35:18 <EnglishGent> commutative sorry mornfall
01:35:25 <WorkyBob> a * (b * (c * d)) is still a valid type in Haskell
01:35:26 * EnglishGent still hasnt even finsiehd coffee #2 :|
01:35:30 <WorkyBob> (it's not the same as a tuple though)
01:35:32 <EnglishGent> bah! see!
01:35:33 <EnglishGent> :|
01:35:47 <copumpkin> migth as well terminate it with ()
01:35:58 <WorkyBob> well a :*: (b :*: (c :*: d)) rather
01:36:13 <WorkyBob> copumpkin: yep, and then you can make :!*: strict in its right hand side, and get the same behavior as tuples
01:36:19 <WorkyBob> :)
01:36:37 <WorkyBob> (and gain lazy tuples in the mean time)
01:37:25 <Saizan> EnglishGent: it'd feel weird to have  a * b * c == (a,b,c) and not correspond to either a * (b * c) or (a * b) * c
01:37:46 <copumpkin> he retracted the associative thing I think :)
01:38:00 <EnglishGent> I did :)
01:38:25 * EnglishGent meant commutative .. i.e that I would not expect String * Int to equal Int * String
01:38:44 <EnglishGent> :)
01:39:31 <jelly12gen> hi i want to make a simple todolist editor with haskell, and i want to pass command line arguments what is the simplest way to do this ?
01:39:41 <jelly12gen> with data Flag or just patter mathcing ?
01:39:45 <EnglishGent> another one if we're on the subject of language warts (I know I'm a Haskell newbie, but I cant help having some ideas) - is it just me, or does Int vs Integer feel like a kludge to other people as well?
01:40:00 <EnglishGent> Common Lisp doesnt need it - big-ints are the default (which is what I'd prefer)
01:40:07 <mornfall> EnglishGent: The naming is a little unfortunate (but you get the idea that Integer is longer...).
01:40:26 <EnglishGent> and if you provide support for integers of limited range - why not do it Ada style & allow arbitrary numeric ranges to be defined
01:40:28 <mornfall> EnglishGent: Haskell needs native integer types for speed.
01:40:29 <Zao> I keep mistyping fromInteger as fromIntegral and vice versa.
01:40:34 <copumpkin> EnglishGent: I'm not particularly happy about it, but it's not too bad
01:40:38 <EnglishGent> so that [1..128] & [2..129] are different types
01:40:39 <Zao> mornfall: WordNN, IntNN?
01:40:56 <mornfall> Zao: Yeah.
01:41:12 <Saizan> jelly12gen: i'd use http://haskell.org/ghc/docs/latest/html/libraries/base/System-Console-GetOpt.html
01:41:13 <mornfall> Zao: Those are probably quite a bit newer than Int tho.
01:41:25 <EnglishGent> mornfall - I dont agree there a) common lisp doesnt -- as Peter Norvig demonstrates
01:41:26 <copumpkin> EnglishGent: because in general it'd be pretty hard to reason about what type an arbitrary number would be then
01:41:35 <mornfall> EnglishGent: Link?
01:41:38 <EnglishGent> and b) it's awfully kludgy that the range is machien dependent
01:41:48 <EnglishGent> um one moment mornfall - let me find it for you :)
01:42:07 <mornfall> I don't buy "we don't need it because <foo> says so" : - P
01:42:31 <copumpkin> not "says so" but "demonstrates" though :P
01:42:37 <copumpkin> which is stronger
01:42:50 <mornfall> copumpkin: That's why I want to see the demonstration part. :)
01:42:55 <mornfall> Until I see it, it's just says so.
01:42:59 <jelly12gen> Saizan: ah i will read that
01:43:29 <mornfall> (This somehow reminded me of Fermat's last theorem...)
01:43:38 <fabulous> EnglishGent: lisp doesn't have only bigints; using EQ on integers can give surprising results
01:44:31 <Saizan> having numeric ranges in types without full dependent types feels quite hacky
01:45:12 <copumpkin> it does
01:46:04 <ben> 1
01:46:15 <ben> Whoops. Fat-fingered my window switching, nevermind.
01:49:21 <EnglishGent> I cant find it right mornfall - my machine is crawling right now, I'll get back to you with it later if that's okay
01:49:50 <EnglishGent> and fabulous - I know, but bigints are the *default* - unless you provide declerations for compiler-advice you get big-ints
01:50:18 * EnglishGent also feels the eq, equalp, etc is a kludge
01:50:38 <EnglishGent> to quote the great Knuth 'premature optimisation is the root of all evil' :)
01:50:55 <copumpkin> to an extent
01:51:08 <mornfall> EnglishGent: Sure no prob.
01:51:34 <WorkyBob> is there any way to remove a binding from ghci's scope?
01:51:38 <tibbe> anyone going to icfp? what would be a good place to stay?
01:52:15 * EnglishGent wishes that lisp would ban mutable lists - mutability should be confined to symbols where it belongs
01:52:36 <EnglishGent> that's one thing Haskell gets right - I wish more languages would take note :)
01:53:44 <EnglishGent> and Saizan - I know what you mean (without full dependent types) - personally I think that sooner or later we will have a mainstream language with dependent-type support - it seems unavoidable to me
01:54:03 <EnglishGent> people dont like them becuase then compilation may not terminate... but compilation can take exponential time now anyway
01:54:39 <Peaker> why is a dependently-typed language necessary undecidable?  Can't the type-check be proven to terminate?
01:55:03 <Saizan> Integer is actually the default for haskell too, except that some functions are specialized to Ints :P
01:55:11 <mux> type checking and running a program is the same thing for a dependently typed language
01:55:12 <Peaker> @hoogle Int
01:55:13 <lambdabot> module Data.Int
01:55:13 <EnglishGent> that's why Peaker - if you add them the type-system becomes turing-complete
01:55:13 <lambdabot> Prelude data Int
01:55:13 <lambdabot> Data.Int data Int
01:55:22 <dmwit> Peaker: Coq has decidable dependent type-checking.
01:55:39 <Peaker> EnglishGent: dmwit says its not necessarily so
01:55:47 <dmwit> But it also has fairly severe restrictions on what you can write.
01:55:51 * Peaker likes broken phone communications :-)
01:56:07 <EnglishGent> really? all the type systems I know that support them are turing complete (Qi, Cayenne, etc)
01:56:18 <Saizan> Peaker: it depends on how expressive your language is, if it's turing complete than you can't prove it'll terminate
01:56:24 <dmwit> Coq is not Turing-complete, right.
01:56:24 <EvilTerran> i think the problem is that, if a language that's turing-complete at the value level can have types that depend on these values, typechecking becomes undecidable
01:56:28 <EnglishGent> I dont know about Coq - it's something I want to learn
01:56:29 <Saizan> Peaker: except by introducing arficial limits
01:56:31 <dmwit> It has a very restricted fixpoint operator.
01:56:34 <EnglishGent> but havent got around to yet
01:56:36 <Peaker> dmwit: do you think there can be novel solutions that allow unrestricting Coq somewhat while retaining decidability, by having perhaps more logic/proof power about termination?
01:56:44 <EnglishGent> mind you - it's a theorem-prover, not a general programming language
01:56:53 <Peaker> Saizan: Yeah, but why does dependent type checking have to be turing complete?
01:56:57 * EvilTerran could envisage a language where every recursion is catamorphic or anamorphic
01:57:12 <EnglishGent> EvilTerrain - have you seen Charity? :)
01:57:22 <EvilTerran> no... is that what it does?
01:57:32 <EnglishGent> yes
01:57:38 <Saizan> Peaker: because you use values of your term language into your types, so if the language is turing complete.. in fact Coq isn't
01:57:44 <Peaker> EvilTerran: I thought that dependent types type-check all in compile-time, so even if values are turing-complete at the value level, to type-check them would not require actually running the turing complete computation
01:57:50 <EnglishGent> google for 'charity programming language'
01:58:00 <EnglishGent> I'm sorry but my machine is currently thrashing like crazy
01:58:11 <dmwit> Peaker: I'm not sure I understood that question.  However, there is definitely a fair amount of work on what to do about dependently-typed languages.
01:58:12 <EnglishGent> if I try to open a web-browser I have a long wait :|
01:58:19 <Peaker> Saizan: Ah -- I had a wholly wrong concept of dependent types then, I think
01:58:20 <EvilTerran> Peaker, except surely, as it's dependently typed, you'll need to manipulate values at compile-time
01:58:43 <EnglishGent> Peaker - what were you thinking of? (curious) :)
01:58:49 <Peaker> EvilTerran: then you don't have to have the exact same language for compile-time manipulations and runtime ones
01:59:06 <EvilTerran> true
01:59:07 <Saizan> Peaker: that's the definition of dependent types actually
01:59:24 <Peaker> EnglishGent: I was thinking something that deals with proofs about code logic, that does not involve evaluating arbitrary values at compile-time
01:59:29 <Saizan> Peaker: having the values of the runtime manipulation available into types too
01:59:52 <totom> hrm, I'm trying to compile hmake and I get the following error :
01:59:57 <totom> MkConfig: user error (Command (/opt/local/bin/ghc-pkg-6.10.1 -l) failed)
02:00:15 <totom> it must be trying to use ghc-pkg -l instead of list, but I do not see where that cass is made
02:00:24 <malcolmw> totom: this error is fixed in the darcs version of hmake
02:00:25 <Peaker> Saizan, EvilTerran: I guess its not so bad to have an undecidable compile-time that you just have to "debug". As long as when you're done debugging that, you have nice guarantees about properties when you actually "release" it
02:00:27 <Saizan> Peaker: then you can think about erasing the types before runtime, so they don't cost you
02:02:06 <Saizan> totality is nice too, though
02:02:06 <Peaker> Can I have a Turing-Complete compile-time language to prove stuff powerfully, but a proven-terminating runtime-language?
02:02:10 <totom> malcolmw: :/ ok, I'm using a port system so this is going to be painful
02:02:44 <malcolmw> totom: can I send you a normal patch?  would that help?
02:03:02 <Peaker> Saizan: I think that if you consider compile-time type validation/etc to be a QA phase, and the final product of compilation to be a release, then surely you want totality proven on the product, but as much power as possible at the QA phase
02:03:02 <totom> yes, I was looking for it on the darcs tree
02:04:43 <Raevel> Any new versions of ghc coming soon? I'm compiling right now so that probably means new release tomorrow.
02:04:43 <copumpkin> woot, the team on icfp that I'm in (although it really has nothing to do with me) is #1 now!
02:04:46 <totom> malcolmw: where is the darcs repository ? http://www.haskell.org/hmake/ doesn't have a link to it
02:05:28 <malcolmw> totom: the patch you want is at http://darcs.haskell.org/nhc98/_darcs/patches/20081016151427-6871e-7c2c619f1ed51fea901aafe447fedbab3673d51f.gz
02:05:43 <Saizan> Peaker: the problem is that a turing-complete language corresponds to an unsound logic i guess, i.e. you con prove false in it
02:05:51 <ivanm> Raevel: not till september probably
02:06:01 <ivanm> IIRC, they usually announce at ICFP
02:06:05 <Saizan> Peaker: you need to check that your proof actually terminates, and that may involve computing some runtime values
02:06:11 <malcolmw> totom: unfortunately, hmake does not have a separate darcs repo from nhc98 yet.  I ought to fix that really.
02:06:22 <totom> ok
02:08:13 <Saizan> Peaker: which is a bit like what we do when using gadts, you can't use a lazy pattern match and use the refinements too
02:08:25 <totom> malcolmw: are you going to release a new version with that patch ? i.e. should I fix the port in my port system or will there be a release soon enough ?
02:10:15 <malcolmw> totom: difficult to say.  I don't know when I might get time to re-release.  Could be in the next couple of days, could be in six months time.
02:10:17 <Saizan> s/unsound/inconsistent/
02:10:29 <totom> ok :/
02:10:47 <copumpkin> whoa, someone just jumped to the top of icfp ranking (by significant margin) out of nowhere
02:11:46 <Saizan> copumpkin: and here you are idling instead of working for your team
02:12:17 <copumpkin> yup :) it's mostly one guy doing it under the name of the team
02:15:40 <copumpkin> #2 isn't so bad anyway
02:15:50 <copumpkin> still funny to see someone jump up so high out of nowhere
02:16:55 <totom> malcolmw: I should use your patch with "darcs apply", right ?
02:17:07 <totom> darcs apply patchfile yields the error "darcs failed:  Bad patch bundle!"
02:17:43 <Saizan> you might need to unzip it
02:17:47 <malcolmw> totom: hmm, unless you have a darcs repo already, the darcs bundle won't apply, because the dependency patches aren't available
02:18:20 <totom> I've done darcs get --partial http://darcs.haskell.org/nhc98
02:18:50 <totom> I've executed, I mean
02:18:50 <malcolmw> totom: oh, if you have the repo already, then the patch should already be applied
02:18:56 <totom> ok
02:19:18 <malcolmw> totom; ./configure; make hmake;
02:19:59 <malcolmw> totom: if you really want to repackage for your distro, then "make hmakeDist" should create a tarfile with just hmake files in it
02:20:15 <totom> no, I want to put the files in the work/ directory of my port system, so I guess I should checkout the 3.14 tag and apply the patch
02:20:17 <totom> oh ok
02:20:19 <totom> thanks
02:21:49 <malcolmw> totom: I'm afraid my repo may not be sufficiently well organised to have remembered to tag it for an hmake release, as opposed to a nhc98 release
02:21:59 <Raevel> ghc only took 20 minutes to compile this time :-O
02:22:21 <totom> well I'll just take HEAD then
02:22:23 <totom> thanks
02:26:33 <totom> god sh start is slow
02:26:49 <totom> (guess I need to run it to get harch)
02:32:16 <malcolmw> totom: sh start will drag in a lot of library repos for nhc98 that you probably do not need for hmake. But it also gets cpphs, which you will need.
02:32:24 <totom> malcolmw: is $CPPHS uptodate int he makefile ?
02:32:35 <totom> it tries to add cpphs/Language to the tar file, which does not exist
02:34:18 <malcolmw> totom: did sh start fail to download the cpphs repo?
02:34:22 <totom> no
02:34:46 <totom> src/cpphs/cpphs.* is ok for example
02:34:56 <totom> put Language and Text do not exist
02:35:01 <totom> but*
02:35:03 <malcolmw> totom: that is odd
02:35:27 <totom> are Language and Text byproducts of any compilation ?
02:35:43 <malcolmw> totom: no, they are the main src dirs for cpphs
02:35:53 <totom> hu
02:36:28 <totom> oh, sorry
02:36:33 <totom> sh start did yield an eror
02:36:34 <totom> error
02:36:52 <totom> http://pastebin.com/m5ad87aea
02:37:48 <malcolmw> totom: ah, you are on either windows or macos?
02:37:53 <totom> MacOS
02:37:55 <totom> Mac OS
02:38:18 <totom> (on a case-insensitive FS)
02:38:32 <malcolmw> totom:  so you need to darcs get --partial cpphs, to avoid the filesystem case-sensitivity issue.
02:40:35 <totom> you mean darcs get --partial --repo-name=src/cpphs http://www.cs.york.ac.uk/fp/darcs/cpphs, the command in the start script ? running darcs get --partial cpphs tells me I've no darcs inventory
02:41:47 <totom> darcs get --partial src/cpphs exits with the same error
02:42:02 <LeCamarade> Under what conditions does GHC do TCO for a "tail-recursive" do-action? As in, does f x = do {act1; f x} ever blow the stack, given TCO?
02:43:30 <dibblego> LeCamarade, yes, consider foldl versus foldl'
02:45:31 <totom> malcolmw: got to go, sorry, I guess I'll just make the tar file on a Linux box
02:45:53 <LeCamarade> dibblego, Um ... I follow not.
02:46:04 <LeCamarade> dibblego, I know that foldl' is strict(er).
02:48:50 <malcolmw> totom: yes sorry, I was abbreviating
02:49:10 <|Jedai|> LeCamarade: You can consider that GHC always do TCO (though it's just an effect of the evaluation strategy) but even TCO won't guarantee you no stack overflow (cf. the "foldl (+) 0" case)
02:56:38 <ivanm> @seen Cale
02:56:39 <lambdabot> Cale is in #ghc, #haskell-in-depth, #haskell-overflow and #haskell. I last heard Cale speak 1h 24m 9s ago.
03:02:18 <LeCamarade> |Jedai|, When it is an action that tails, the expansion (to >>= and return) doesn't result in a tail-call. Therefore, unless the TCO is very aggressive, it won't recognise that as a tail-call.
03:03:28 <|Jedai|> LeCamarade: That doesn't really matters in fact... It's not really the TCO that will do the trick here but the evaluation strategy
03:04:22 <LeCamarade> |Jedai|, The eval strategy ensures that all recursion can be TCO-eliminated. But does GHC do that?
03:05:04 <LeCamarade> I'll be back.
03:32:49 <fasta> Why does union from Data.Set take O(n+m) instead of something like O(min(n,m))?
03:33:15 <ivanm> wouldn't n+m -> max(n,m) ?
03:33:25 <ivanm> ummm.... forget that
03:33:35 * ivanm has no idea what he's talking about
03:33:50 <ivanm> fasta: I would guess because that's how it is defined ;-)
03:34:06 <fasta> Or: where is the log factor?
03:34:12 <ivanm> fasta: it would presumably create a new Set by adding each element from each of the other two in turn
03:34:14 <ivanm> or something
03:34:16 <ivanm> *shrug*
03:34:28 <fasta> You would almost think it is implemented as a list.
03:35:29 <fasta> Hmm, ok, so it works like a merge. No idea why that was done, though.
03:37:00 <fasta> Hmm, never mind. In some cases union is a good idea, and in some others it is not.
03:37:00 <quicksilver> fasta: O(n+m) is less than O(n log(n+m)) for some values of n,m
03:37:10 <fasta> quicksilver: yes, that's what I just realized.
03:37:16 * quicksilver nods
03:52:45 <PeakerWork> ivanm: O(n+m) is O(max(n,m)) indeed, isn't it?
03:53:09 <Twey> o.@
04:03:14 <ivanm> PeakerWork: no, because n and m are the lengths
04:04:19 <PeakerWork> ivanm: still? O() notation neglects any coefficients of lower power functions/etc
04:04:27 <ivanm> PeakerWork: they're not functions
04:04:36 <ivanm> its the number of elements
04:04:43 <fabulous> n+m <= 2*max(m,n)
04:05:08 <ivanm> so the union function has max bound "proportional" to the number of elements in the new set
04:06:54 <PeakerWork> ivanm: still?
04:07:06 <ivanm> what do you mean by "still"?
04:07:19 <fasta> It's not only O(n+m), it is Theta(n+m) if you demand the whole result.
04:18:26 <quicksilver> max(m,n) <= n+m <= 2*max(m,n)
04:18:35 <quicksilver> therefore O(m+n) === O(max(m,n,))
04:19:04 <galdor> hi guys, I have a problem with the Pcap module:
04:19:05 <galdor> Loading package pcap-0.4.3 ... linking ... <interactive>: /home/galdor/.cabal/lib/pcap-0.4.3/ghc-6.10.1/HSpcap-0.4.3.o: unknown symbol `pcap_is_swapped'
04:19:15 <galdor> does someone already get this problem ?
04:20:21 <PeakerWork> ivanm: what quicksilver said :-)  When speaking of O() constants don't matter, so O(n+m) is indeed equivalent to O(max(n,m))
04:21:06 <ivanm> hmmmm....
04:27:14 <PeakerWork> ivanm: O(n^2) = O(2*n^2) = O(999*n^2 + 800*n^(1.8) + 999999*n + ...)
04:27:29 <ivanm> yes, I know that
04:27:44 <ivanm> oh, wait, I think I get what you're saying
04:27:59 <PeakerWork> I think quicksilver's explanation is clearer than mine, though
04:28:05 <ivanm> n and m are both linear, so it doesn't really matter which you pick or that they're both there
04:28:22 <quicksilver> no, it's a bit more subtle than that.
04:28:33 <quicksilver> I don't think it's *obvious* that O(n+m) is the same as O(max(n,m))
04:28:39 <quicksilver> I certainly had to think about it for 5 minutes.
04:28:41 <ivanm> neither do I
04:28:58 <quicksilver> but in fact, n+m is certainly higher than the maximum of the two
04:29:03 <quicksilver> and it's lower than twice the maximum
04:29:03 <PeakerWork> ivanm: do you follow the:  max(m,n) <= n+m <= 2*max(m,n)   claim?
04:29:07 <quicksilver> so they are linearly bounded.
04:29:12 <ivanm> PeakerWork: yes
04:29:25 <ivanm> quicksilver: yeah, that's what I was getting that
04:36:19 <FliP^2eH> I hate StateT :(
04:36:23 <FliP^2eH> It makes this so complicated
04:37:55 <FliP^2eH> Flagged as impossible
04:38:02 <fabulous> hmm?
04:38:23 <FliP^2eH> Trying to implement Scheme into my IRC Bot as scripting language
04:38:38 <FliP^2eH> Problem is, the Scheme interpreter needs to have access to the StateT Monad
04:38:48 <FliP^2eH> To use stuff like sendLine
04:44:32 <Saizan_> so?
04:44:45 <FliP^2eH> Won't work
04:44:54 <FliP^2eH> At least it's impossible with my knownledge
04:45:10 <FliP^2eH> It'll be easy for you I suppose, but it's giving me the creeps right now
04:45:45 <FliP^2eH> I think I'll have to give the whole scripting core the type of my State...
04:46:07 <Saizan_> you have to implement the interpreter in that monad, or in a monad made by transforming that
04:46:35 <Saizan_> or just get the state, run the interpreter and put back the updated state
04:47:04 <FliP^2eH> It sounds so easy, written down.
04:47:07 <Saizan_> if you've concurrency you might want to use a mutable variable instead
04:48:02 <Saizan_> heh
04:49:07 <Saizan_> well, if you're stuck somewhere in particular you could paste some code
04:49:24 <FliP^2eH> It's 3 relevant files..
04:49:39 <Saizan_> mh, do you have a repo then?:)
04:49:58 <FliP^2eH> Nope, all still local.. I'll paste it anyways, wait a sec
04:49:59 <FliP^2eH> @hpaste
04:50:00 <lambdabot> Haskell pastebin: http://hpaste.org/new
04:55:38 <FliP^2eH> Saizan_: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6353#a6353
04:56:10 <FliP^2eH> I think we can all agree it's not the best code, but it's working. I've removed anything not relevant, to not confuse
04:57:07 <FliP^2eH> 3 files in that paste. 1st ScriptCore, 2nd Main bot file, 3rd State declaration
05:00:57 <FliP^2eH> :t printf
05:00:59 <lambdabot> forall r. (PrintfType r) => String -> r
05:01:39 <ski> FliP^2eH : i think one solution is to let `eval' return stuff in the `Bot' monad ..
05:01:48 <Saizan_> yeah
05:02:21 <ski> another might be to accumulate the output, and outside the toplevel call to `eval' you collect output and actually send it
05:02:59 <Saizan_> probably using Writer or WriterT for that
05:04:55 <ski> (yet another might be to use `MonadPrompt' .. but i'm not familiar with that one, yet)
05:05:10 <FliP^2eH> I'm confused :(
05:06:16 <Saizan_> even if Bot is a StateT s IO monad you can still use computations in other monads in it, just by running them, as in runErrorT or runWriterT or runStateT with another state type
05:06:33 <Saizan_> so you'd produce either a pure value or an IO computation out of them
05:06:50 <Saizan_> in the latter case you use liftIO just like you do for hPutStr etc..
05:09:14 <ski>   eval :: LispVal -> ErrorT LispError (StateT BotState IO) LispVal  -- hm ?
05:29:24 <couloir> Saizan_, looks like you've got a password in that paste
05:29:59 <couloir> sorry. FliP^2eH
05:30:17 <FliP^2eH> Meh?
05:30:36 <FliP^2eH> Oh who cares
05:30:48 <FliP^2eH> It's just a lame "hide my host" auth with no rights anywhere
05:30:49 <FliP^2eH> :)
05:30:54 <couloir> cool
05:31:14 <FliP^2eH> But thanks for pointing that out, maybe I'll learn my lesson next time
05:32:03 <Badger> @index Either
05:32:03 <lambdabot> Data.Either, Prelude
05:47:55 <ovnicraft> hi i am new in haskell and i am using hugs98
05:48:20 <ovnicraft> i have problems with ord, is not in prelude
05:48:29 <bastl> kosmikus: im experimenting with multirec on a large datatype (ca 200 data declarations) and get this error, when I try to generate the boilerplate code. Do you have any idea what could be wrong ?
05:48:36 <fabulous> :also Data.Char
05:49:11 <Zao> @type Data.Char.org
05:49:12 <lambdabot> Not in scope: `Data.Char.org'
05:49:14 <Zao> @type Data.Char.ord
05:49:15 <lambdabot> Char -> Int
05:49:49 <kosmikus> bastl: which error?
05:50:06 <bastl> oh sorry: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2917
05:50:21 <ovnicraft> what ord is in this version in?
05:50:26 <bastl> i copied 1:1 from ASTTHUse
05:50:42 <fabulous> ovnicraft: huh?
05:51:02 <bastl> but i dont understand anything of template haskell. just want to use zipper on Java-ASTs
05:51:06 <Zao> ovnicraft: The Report has it in Char.ord
05:51:07 <Zao> http://www.haskell.org/onlinereport/char.html
05:51:07 <fasta> ovnicraft: there is no such thing as ord, there is an Ord, though.
05:51:14 <fabulous> fasta: there is an ord
05:51:18 <fabulous> it's in Data.Char
05:51:33 <fasta> fabulous: yes, there is.
05:51:34 <kosmikus> bastl: probably a problem with the naming scheme used in the TH generation
05:51:38 <Zao> fabulous: Fancy newfangled module hierarchy :)
05:51:38 <ovnicraft> fabulous, thx
05:51:48 <kosmikus> bastl: do you have both a constructor and a datatype named Identifier in your Java AST?
05:52:25 <bastl> yes
05:52:31 <kosmikus> bastl: I can look at it in about an hour, if that's ok. It'd be helpful if you could send me the source file for the AST.
05:53:08 <bastl> that would be great.
05:53:21 <bastl> ill mail  the relevant stuff
05:53:26 <kosmikus> ok, thanks
05:53:36 <fasta> The H98 way to get ord is still import Char.
05:57:49 <Associat0r> FYI #proglangdesign #ltu
06:21:59 <kowey> any University of Edinburgh people around?
06:22:44 <kowey> specifically, any UoE people with a swipe card that can get them into the Informatics Forum? (this is for the ICFP/hackathon)
06:22:44 <ivanm> kowey: I would have been one in september if they bothered to give me any money :s
06:22:53 <kowey> ivanm: :-(
06:22:55 <ivanm> in that case, I'm definitely out ;-)
06:23:49 <kowey> the context is that we may be able to get a hackathon room this Aug/Sep  if we could get somebody that could let us in over the weekend!
06:28:45 <jelly12gen> hi , i wnt to filter an keyword from a list of strings how could i do that easily
06:28:50 <jelly12gen> s/wnt/want
06:29:20 <edwardk> are you looking for it as a substring for it to be the entire string?
06:29:25 <edwardk> er or for it
06:29:32 <jelly12gen> edwardk: a substring
06:30:04 <jelly12gen> so i thought of elem , but that just returns a bool i want to filter strings with an certain keyword
06:30:10 <edwardk> then you probably want to partition using something like 'words' and then use 'elem' on each word to check to see if its a keyword
06:30:23 <jelly12gen> hmm
06:30:30 <edwardk> oh you just want to find any substring that contains some particular keyword?
06:30:44 <jelly12gen> yeah
06:30:50 <jelly12gen> and return the string that contains that keyword
06:31:29 <edwardk> a cheesy solution is that you can of course use tails and check to see if any of the tails starts with your keyword, but you'd be better off using one of the regex engines for performance
06:31:43 <mux> :t isInfixOf
06:31:49 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
06:32:08 <dmhouse> ?src isInfixOf
06:32:08 <lambdabot> isInfixOf needle haystack = any (isPrefixOf needle) (tails haystack)
06:32:15 <mux> > filter ("foo" `isInfixOf`) ["lala","barfoobaz","plop"]
06:32:19 <lambdabot>   ["barfoobaz"]
06:32:19 <jelly12gen> that made me think i forgot to import Data.List
06:32:28 <mux> is that what you want?
06:32:32 <edwardk> that'd do it
06:32:44 <dmhouse> Complexity of O(n^lots)
06:32:50 <edwardk> heh
06:33:14 <dmhouse> O(n^3), perhaps?
06:33:16 <jelly12gen> > filter ("todo" `isInfixOf`) ["this is my todolist","another entry to the list"]
06:33:18 <lambdabot>   ["this is my todolist"]
06:33:19 <jelly12gen> ok
06:33:23 <jelly12gen> this would work thanks
06:33:43 <dmhouse> Well O(m*n^2) where n = length haystack and m = length needle
06:33:54 <edwardk> > "xxx" =~ "(xxx|yyy)" :: Bool
06:33:56 <lambdabot>   True
06:34:12 <jelly12gen> i am making my own todolist editor in haskell
06:35:15 <jelly12gen> so i have an add ,remove ,search function now :)
06:35:45 <edwardk> > let contains x y = x =~ (".*" ++ y ++ ".*") in "hello world" `contains` hello
06:35:47 <lambdabot>   Not in scope: `hello'
06:35:48 <edwardk> er
06:35:57 <edwardk> > let contains x y = x =~ (".*" ++ y ++ ".*") in "hello world" `contains` "hello"
06:35:59 <lambdabot>   No instance for (Text.Regex.Base.RegexLike.RegexContext
06:35:59 <lambdabot>                    ...
06:36:08 <edwardk> guess that needs a type annotation
06:36:12 <edwardk> > let contains x y = x =~ (".*" ++ y ++ ".*") in "hello world" `contains` hello :: Bool
06:36:13 <lambdabot>   Not in scope: `hello'
06:36:19 <edwardk> sorry for the spam
06:36:30 <edwardk> > let contains x y = x =~ (".*" ++ y ++ ".*") in "hello world" `contains` "hello" :: Bool
06:36:31 <lambdabot>   True
06:36:34 <edwardk> there =)
06:37:40 <edwardk> > let contains x y = x =~ (".*" ++ y ++ ".*") in "hello world" `contains` "hello" :: (String,String,String)
06:37:41 <lambdabot>   ("","hello world","")
06:41:40 <EvilTerran> ?type isInfixOf
06:41:41 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
06:41:45 <EvilTerran> ?src isInfixOf
06:41:45 <lambdabot> isInfixOf needle haystack = any (isPrefixOf needle) (tails haystack)
06:42:54 <EvilTerran> oh, that's already been discussed. nvm. :)
06:59:22 <kosmikus> bastl: looking at it now, I'll need to fix the TH generation algorithm somewhat
07:00:24 <bastl> i dont understand the restriction that typename = constr.name.
07:00:38 <bastl> that seldom holds for types with some alternatives.
07:01:26 <bastl> or does it refer to something else than my "original" types
07:01:28 <bastl> ?
07:09:28 <jeffersonheard> hrm.  TerraHS is refusing to build on Linux.  Is it safe to change stdcall to ccall in the FFI?
07:09:40 <jeffersonheard> since stdcall isn't supported on Linux?
07:11:52 <SamB> jeffersonheard: it isn't?
07:12:30 <SamB> jeffersonheard: what does "uname -a" say?
07:13:07 <jeffersonheard> Linux blueheron 2.6.28-11-generic #42-Ubuntu SMP Fri Apr 17 01:58:03 UTC 2009 x86_64 GNU/Linux
07:13:33 <jeffersonheard> TerraHS/TerraLib/TePoint.hs:118:0:
07:13:34 <jeffersonheard>     calling convention not supported on this architecture: stdcall
07:13:35 <jeffersonheard>     When checking declaration:
07:13:36 <LeCamarade> |Jedai|, Okay, here's a rephrase of my question.
07:13:37 <jeffersonheard>         foreign import stdcall unsafe "static  &c_tepointset_size" tepointset_size
07:13:39 <jeffersonheard>           :: TePointSetPtr -> IO Int32
07:13:50 <LeCamarade> |Jedai|, Does GHC optimise out this recursion:
07:14:13 <LeCamarade> |Jedai|, f x = (>>) act1 (f x)
07:14:14 <LeCamarade> ?
07:14:25 <|Jedai|> LeCamarade: No and yes
07:14:41 <LeCamarade> Why yes?
07:14:45 <SamB> jeffersonheard: my guess is that that you couldn't build that for x86_64 on Windows, either
07:14:54 <LeCamarade> It optimises our non-tail-calls, as well?
07:14:59 <jeffersonheard> SamB: No, you're probably right
07:15:01 <LeCamarade> s/our/out/gi
07:15:24 <jeffersonheard> SamB: but assuming that TerraLib builds at all on Linux, ccall should be correct, shouldn't it?
07:15:44 <|Jedai|> LeCamarade: There is no optimisation here, but you still won't get a blown stack from too much call to f
07:15:46 <SamB> jeffersonheard: possibly GHC should just treat stdcall as cdecl on x86_64 ...
07:16:10 <LeCamarade> |Jedai|, So there is no optimisation done?
07:16:14 <LeCamarade> Cool.
07:16:20 <Saizan> because the stack is used differently from what'd you expect from a strict language
07:16:26 <LeCamarade> But why would it not blow the stack?
07:16:32 <LeCamarade> Hmm.
07:16:42 <jeffersonheard> SamB: yeah, that makes more sense than anything.  Should I submit that to the Haskell mailing list, then?
07:16:58 <LeCamarade> Saizan, Elaborate, if you will.
07:17:00 <|Jedai|> LeCamarade: Not really, but the evaluation model is such that the first call to "f" will have disappeared when you call f for the second time
07:17:01 <SamB> jeffersonheard: I think you should just head over to #ghc and ask JaffaCake if he agrees
07:17:05 <jeffersonheard> k
07:17:15 <SamB> jeffersonheard: then if he does, report a GHC bug
07:17:24 <Saizan> the stack is generally proprotional to the distance between the outermost thunk and the first reducible expression
07:17:28 <LeCamarade> |Jedai|, Ah. Okay.
07:18:57 <Axman6> @hoogle Distribution.Text
07:18:58 <lambdabot> module Distribution.Text
07:18:58 <lambdabot> Distribution.Text class Text a
07:18:58 <lambdabot> Distribution.Extension FlexibleContexts :: Extension
07:32:21 <conal> @seen augustss
07:32:21 <lambdabot> augustss is in #haskell. I don't know when augustss last spoke.
07:45:46 <totom> has anyone installed hat lately ?
07:46:01 <totom> it says  it can't find the module Data.PackedString, which is deprecated :/
07:46:12 <fasta> totom: does the website still have red flags?
07:47:00 <totom> hm, no ? www.haskell.org/hat
07:47:06 <fasta> totom: http://www.haskell.org/hat/download.html has some text on it. That's long for that it doesn't work.
07:47:24 <totom> doh ?
07:47:39 <fasta> totom: I requested that the author placed this text, such that not more people would waste their time.
07:47:41 <totom> so what program should be used to debug some haskell code ?
07:47:49 <fasta> totom: so, either you fix it or you ignore hat :)
07:48:12 <totom> ok :p I'm using a port system so I didn't see the text, and it's not on the home page :-) so any other utilities you recommend ?
07:48:19 <fasta> totom: if you have ghc 6.10.3 you install the patches by Peter <something> and then you have something sane.
07:48:56 <fasta> totom: The debugger in 6.10.2 is not very useful.
07:49:09 * totom has spent the whole day building hat's dependencies and now it doesn't work, great ;-)
07:49:43 <totom> I have 6.10.1...
07:49:58 <totom> I guess I'll just add more unit tests
07:50:39 <ski> (fasta : Peter Gammie ?)
07:51:27 <fasta> Peter Hercek
07:51:37 <ski> ok
07:51:46 * ski just guessed
07:53:26 <fasta> I didn't test his extensions yet, but they sound to me as they fix most issues people have with the debugger.
07:57:56 * Cale still hasn't really tried the debugger properly. It does seem a bit clunky to actually use. A lot of things look like they're intended to have editor integration.
07:58:33 <SamB> Cale: it's probably a bit more stable than it was when *I* tried it ;-P
08:10:07 <deech> Hi all, I've been trying to figure out how generalized newtype deriving works by building my own monad stack and implementing 'Monad', 'MonadState', 'MonadError' functions etc. So far I have 'Monad' implemented and compiled but it doesn't seem to be working. The code is at http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6358#a6358. Any advice is appreciated.
08:10:48 <doserj> s >>= m = s >>= m is an infinite loop
08:11:12 <EvilRanter> doserj, not to mention a type error, surely?
08:11:27 <EvilRanter> oh, wait, mis-read that as s>>=m = m>>=s :P
08:12:21 <doserj> deech: you have to unwrap the s, use the >>= of the wrapped Monad, and then wrap the result
08:12:53 <EvilRanter> deech, the definition of >>= should look something like "SmallMonad s >>= m = SmallMonad (...)"
08:12:54 <deech> doserj, so to unwrap the s I have to run the runSmall function right?
08:13:06 <doserj> yes
08:13:27 <EvilRanter> deech, because you'll need to unwrap the s somehow (you can use runSmall instead of pattern-matching if you'd rather)
08:14:56 <deech> So now I have ' s >>= m = runSmall s >>=  m ' and that gives me the error '    Couldn't match expected type `SmallMonad a'
08:14:56 <deech>            against inferred type `StateT Int IO a1''
08:15:59 <doserj> deech: yes. you have to unwrap the result of m, too
08:16:43 <doserj> >>= in the wrapped monad expects sth of type a -> StateT .., whereas m is of type SmallMonad ..
08:16:47 <deech> doserj : So like 'runSmall s >>= runSmall m'?
08:16:55 <EvilRanter> close
08:17:13 <doserj> unwrap the *result* of m, not m itself :)
08:17:29 <EvilRanter> "s >>= m = SmallMonad (runSmall s >>= runSmall . m)" should do it
08:17:53 <EvilRanter> (you have to re-wrap the result of the bind before you're done, too)
08:17:55 <ski> but that's still an infinite loop, no ?
08:18:09 <doserj> ski: why should it?
08:18:10 <ski> hm, no
08:18:18 <EvilRanter> ski, no, this is the definition of >>= for SmallMonad in terms of >>= for StateT ...
08:18:43 <deech> I don't understand why I have to do the SmallMonad (...) part. Doesn't the >>= wrap the result back up into a SmallMonad? Isn't that what my return function is for?
08:19:30 <ski> deech : the `(>>=)' on the right has type `forall a b. StateT s a -> (a -> StateT s b) -> StateT s b'
08:19:54 <ski> in particular it returns something of type `StateT s b', not of type `SmallMonad b'
08:20:06 <ski> (for some particular `s' i presume)
08:20:28 <ski> the arguments to `>>=' there have to be unwrapped, and the result rewrapped
08:20:39 <EvilRanter> deech, in general, if y = x >>= f, then x :: m a, f :: a -> m b, and y :: m b, where m is the same monad throughout
08:20:59 <EvilRanter> deech, you're defining >>= for SmallMonad, so that m has to be SmallMonad for your parameters and result
08:21:16 <deech> ski: I see, then can I do something like 'runSmall s >>= return . runSmall . m'?
08:21:19 <ski> it might be simpler if you define
08:21:27 <doserj> deech: no
08:21:36 <ski>   bindSM :: SmallMonad a -> (a -> SmallMonad b) -> SmallMonad b
08:21:43 <EvilRanter> deech, and you're defining it in terms of >>= for StateT Int IO, so that m has to be StateT Int IO for the parameters and result of the use of >>= on the right-hand side
08:21:48 <ski>   bindSM s m = ..>>=..
08:22:05 <ski> and then say `(>>=) = bindSM' in the `instance Monad SmallMonad'
08:22:08 <EvilRanter> deech, the important bit is that both parameters and the result of >>= have to be in the same monad
08:22:24 <deech> EvilRanter : Ah-ah!
08:22:29 <ski> (that way it is simpler to keep the two different uses of `>>=' straight)
08:22:51 <pikhq> That's what makes monads actually *useful* for representing things like state.
08:23:03 <EvilRanter> deech, because there's only one monad mentioned in the type
08:23:06 <EvilRanter> ?type (>>=)
08:23:07 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
08:23:20 <EvilRanter> ^ they're all called "m", they've all gotta be the same
08:24:18 <dschoepe> In which ghc version was the ScopedTypeVariables pragma added?
08:24:43 <deech> Gotcha! Man .. nothing more humbling than struggling for hours with a single line of code! I think I actually get it now. Thanks!
08:27:44 <quicksilver> dschoepe: 6.6? possibly 6.4
08:28:35 <dschoepe> quicksilver: thanks. As long as it's not after 6.6, I'm happy =)
08:30:11 <roconnor> are there any hackages that would be good for making a visualizer for the statelites in the ICFP contest?
08:33:17 <doserj> language pragmas were only introduced in 6.6, i think. scoped type variables existed long before, though
08:41:29 <Meady> hey guys
08:43:13 <Axman6> o/
08:45:02 <Cale> hey
08:45:15 <lilac> hello
08:45:46 * Axman6 awaits an 8 character greeting to continue the fibonacci sequence
08:46:09 <impl> Guten Tag
08:46:49 <Axman6> argh, didn't kill a hackage upload soon enough >_<
08:47:28 * Axman6 awaits hackagebot spam :(
08:54:11 <defun> :t fmap.fmap.fmap.fmap.fmap.fmap
08:54:12 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *) (f3 :: * -> *) (f4 :: * -> *) a b (f5 :: * -> *). (Functor f, Functor f1, Functor f2, Functor f3, Functor f4, Functor f5) => (a -> b) -> f (f1 (f2 (
08:54:13 <lambdabot> f3 (f4 (f5 a))))) -> f (f1 (f2 (f3 (f4 (f5 b)))))
08:54:47 <defun> :t fmap.fmap
08:54:48 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
08:54:58 <ray> :t fmap `fmap` fmap
08:54:59 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
08:55:17 <defun> now that's cool.
08:55:48 <defun> :t fmap
08:55:50 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:55:53 <defun> :t (.)
08:55:55 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
08:56:02 <defun> :t ($)
08:56:04 <lambdabot> forall a b. (a -> b) -> a -> b
08:56:28 <ray> (.) is fmap on ((->) e), ($) is id restricted to functions
08:56:45 <Cale> (a -> b) -> f a -> f b, let f = (e ->) and you get  (a -> b) -> (e -> a) -> (e -> b)
08:58:47 <Meady> what types fit in the EQ class
08:58:57 <ziman> @instances Eq
08:58:58 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), (a, b, c, d, e), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
08:59:08 <ziman> ...and many more :)
08:59:13 <ray> pretty much anything besides functions
08:59:55 <Cale> and IO :)
09:00:29 <ray> IO doesn't exist :(
09:00:40 <Cale> Basically, things which can be reasonably compared for equality go in Eq.
09:01:18 <ray> even Void could go in Eq, right? (==) would just always diverge
09:01:47 <Cale> It could, yeah, or it could just be x == y = True
09:02:08 <Meady> WICKED I FINALLY UNDERSTAND => abit more!
09:02:14 <ray> i like diverging better
09:02:15 <Cale> Because any two elements of Void are indeed equal ;)  (they also happen to be unequal)
09:02:26 <Vq^> @check x == ()
09:02:27 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
09:02:42 <Meady> (EQ a) => Means that the rest can only take place if A is of is a type in typeclass EQ?
09:03:02 <ray> yeah, but it's capitalized Eq
09:03:05 <Cale> yeah, though you should be careful about uppercase and lowercase :)
09:03:11 <roconnor> Which team is Cale on?
09:03:23 <Cale> I'm not participating in this year's ICFPC.
09:03:29 <roconnor> huh?
09:03:34 <roconnor> why not?
09:03:54 <Cale> It didn't really interest me somehow.
09:04:02 <roconnor> oh
09:04:04 <roconnor> heh
09:04:06 <Meady> Ok wicked , now why do they () it instead of just Eq a
09:04:12 <roconnor> so much for being on Cale's team next year
09:04:23 <roconnor> Cale: the particular task or the ICFPC in general?
09:04:30 <Cale> The particular tash
09:04:31 <roconnor> which disinterested you?
09:04:33 <Cale> task*
09:04:34 <roconnor> ah
09:04:42 <roconnor> it's true
09:04:54 <ziman> @check \x -> x == ()
09:04:55 <lambdabot>   "OK, passed 500 tests."
09:05:08 <Cale> I usually wait until reading the description to decide if I'm going to participate. :)
09:05:35 <roconnor> I use the contests to learn more about haskell
09:05:38 <Meady> ok so \?
09:05:45 <roconnor> by giving me little projects to try and write
09:05:45 <Meady> \x = a function we havent names?
09:05:48 <Meady> named?*
09:06:00 <mauke> Meady: yeah, the syntax is \ PARAMETERS -> BODY
09:06:11 * EvilRanter bemoans the lack of "iterateUntil :: (a -> Bool) -> (a -> a) -> a -> [a]"
09:06:12 <Cale> Yeah...  (\x -> x^2) for instance is the function which takes x and gives the square of it
09:06:19 <EvilRanter> (or iterateWhile)
09:06:38 <Cale> and  (\x y -> x^2 + y^2)  is the function which takes two parameters, x and y, and returns the sum of their squares.
09:06:52 <EvilRanter> Meady, the \ is meant to be reminiscent of the lowercase lambda, as in lambda calculus
09:06:57 <Cale> λ
09:06:57 <Meady> so why dont we just give \x a name
09:07:00 <roconnor> I didn't learn too much this year, other than "foldr (\x xs -> x `seq` x : xs) []"
09:07:08 <Cale> Meady: x is a name for the parameter
09:07:10 <roconnor> but at least that is something
09:07:16 <Cale> Meady: \ is just a symbol
09:07:35 <Cale> (which if you want, is a name for the bit of syntax which introduces a function)
09:07:46 <mauke> Meady: because this is not asm
09:07:57 <EvilRanter> Meady, if you want a shorter way of writing (\x -> x^2), you can also write just (^2)
09:08:07 <EvilRanter> > 10^10
09:08:08 <Cale> Functions are important, in fact, more important than numbers -- if we can write numbers without having to name them, we should be able to do the same for functions.
09:08:08 <lambdabot>   10000000000
09:08:11 <mauke> we can write expressions like (x * 2 + 1) / 3 without naming each subresult
09:08:12 <jrick> Meady: yoy can also use partial functions instead of using lambdas
09:08:13 <EvilRanter> > (^10) 10
09:08:14 <lambdabot>   10000000000
09:08:18 <Meady> Right okm say we make multiple definitions of a function, is it processed by order
09:08:19 <jrick> > map (^2) (take 10 [1..])
09:08:21 <lambdabot>   [1,4,9,16,25,36,49,64,81,100]
09:08:22 <EvilRanter> jrick, do you mean sections?
09:08:24 <Meady>    1. factorial :: (Integral a) => a -> a
09:08:25 <Meady>    2. factorial 0 = 1
09:08:25 <Meady>    3. factorial n = n * factorial (n - 1)
09:08:32 <Meady> Would line 2 always be checked before 3
09:08:33 <Cale> Meady: The patterns are matched top to bottom, yeah
09:08:34 <ray> yeah, it tries to match in order
09:08:35 <mauke> Meady: yes
09:08:42 <Meady> Ahh wicked
09:08:47 <jrick> EvilRanter: are they called that? (I'm pretty new to haskell as well)
09:08:48 <mauke> Meady: that's a single definition, though; it just consists of multiple equations :-)
09:08:50 <Meady> So its sortof like Case statments in functions
09:09:00 <Meady> or overloading
09:09:04 <Meady> in C
09:09:12 <mauke> Meady: internally it's compiled to a case statement
09:09:24 <Cale> Not like overloading, but yeah, it's translated into a case expression.
09:09:24 <Meady> Yeah i imagined so
09:09:25 <mauke> (C has no overloading, and overloading isn't order dependent)
09:09:38 <Meady> hmm
09:09:47 <EvilRanter> jrick, yeah, (^2) is an operator section - a partial function is a function which doesn't have a value for every possible value of its parameter
09:09:49 <Cale> factorial n = case n of 0 -> 1; n -> n * factorial (n-1)
09:10:13 <Meady> but C does implement functions with more than one optional argument
09:10:56 <Meady> so what does _ represent, say i did , myfunc (x,_,_) = etc
09:11:19 <jrick> EvilTerran: can you give an example? I'm not quite understanding what you mean
09:11:27 <mauke> Meady: _ is a wildcard pattern
09:11:37 <Meady> OK cool
09:11:41 <mauke> Meady: it works like a variable name, but it doesn't bind what it matched
09:11:51 <EvilTerran> > 3 / 0 :: Integer -- jrick, division on integers is a partial function
09:11:52 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Integer.Internals.Integer)
09:11:53 <lambdabot>    aris...
09:11:53 <mauke> which means you can use it more than once in the same pattern
09:11:56 <Meady> ok here
09:11:59 <Meady> # ghci> let xs = [(1,3), (4,3), (2,4), (5,3), (5,6), (3,1)]
09:11:59 <Meady> # ghci> [a+b | (a,b) <- xs]
09:11:59 <Meady> # [4,7,6,8,11,4]
09:12:03 <EvilTerran> > 3 `div` 0 :: Integer -- jrick, er, wrong division :P
09:12:04 <lambdabot>   * Exception: divide by zero
09:12:18 <jrick> oh, ok
09:12:20 <EvilTerran> > head [] -- so are head and tail, on lists
09:12:21 <lambdabot>   * Exception: Prelude.head: empty list
09:12:24 <Meady> second line, how does it know to take each list from inside the list, theres nothing to tell it that the lists are inside lists :S?
09:12:41 <EvilTerran> as is anything which never returns a meaningful result because it gets stuck in an infinite loop
09:12:43 <mauke> Meady: huh? I don't see nested lists there
09:12:55 <Meady> i would've thought second line would be [a+b | [(a,b)] <- xs]
09:13:07 <Meady> well no not nested lists
09:13:18 <mauke> Meady: <- extracts elements, one at a time
09:13:29 <Meady> ahh excellent
09:13:35 <mauke> (a,b) will be matched against each item in turn
09:13:37 <Meady> so that is a , for x in list do etc
09:13:43 <mauke> yeah, basically
09:14:04 <mauke> > map (\(a,b) -> a+b) [(1,3), (4,3), (2,4), (5,3), (5,6), (3,1)]
09:14:05 <lambdabot>   [4,7,6,8,11,4]
09:14:07 <Meady> Seriously, i stopped yesterday night, and couldnt fall asleep for 4 hours, just ticking away
09:24:35 <RayNbow> http://www.haskell.org/pipermail/haskell-cafe/2009-June/063616.html <-- I wonder if this name has been chosen deliberately...
09:26:33 <lament> i beileve the answer to that is durrrr
09:27:06 <roconnor> what's the code for view core code in colour?
09:27:34 <doserj> cabal install ghc-core?
09:27:42 <quicksilver> hmm
09:28:06 <roconnor> thanks
09:28:06 <quicksilver> is it just me, or is loli an instance of "Usage of Monad where Monoid would have been good enough"?
09:28:38 <roconnor> dons had better have fixed those non-inlined right shifts for me :)
09:28:49 <quicksilver> although I don't what the type of the monad to the right of 'get "/" $ do' is
09:28:53 <quicksilver> I'm assuming that a different one
09:28:59 <quicksilver> (that one *does* need to be a Monad)
09:29:17 <opqdonut> which one doesn
09:29:22 <opqdonut> 't then
09:29:28 <opqdonut> (damn key layout)
09:29:30 <quicksilver> opqdonut: the one 'get' itself is in
09:29:41 <quicksilver> and middleware/views/layout
09:29:41 <djahandarie> loli?
09:29:44 <Meady> Level	Code	Available
09:29:45 <Meady> Credits	Title	Mark	Resources
09:29:45 <Meady> 1	CSCI1401	30	Programming in C	90	
09:29:45 <quicksilver> http://lolipaste.easymic.com/00000-lolipaste.haskell
09:29:47 <Meady> Uni results
09:29:48 <Meady> lol
09:29:54 <Meady> 90% on C programming :d
09:29:56 <Zao> Meady: Your spam is full of tabs.
09:30:00 <Meady> i know
09:30:07 <Meady> Its not spam, its uni results!
09:30:16 * Berengal introduced his first piece of Haskell at work today
09:30:24 <opqdonut> quicksilver: yeah, a handler monoid would've been cleaner
09:30:33 <djahandarie> Berengal, nice
09:30:33 <Meady> Grats Berengal, did it go well
09:30:38 <quicksilver> opqdonut: but maybe there are some reasons it must be a monad not clear in that paste
09:30:38 <opqdonut> (on a first glance)
09:30:41 <opqdonut> yeah
09:30:48 <quicksilver> or maybe he finds "do notation for monoids" more attractive ;)
09:30:59 <quicksilver> (than mappend/msum)
09:31:04 <Berengal> Meady: The program was well received, but the code was barely glanced at
09:31:12 <roconnor> ghc-core-0.4.2 depends on pcre-light-0.3.1 which failed to install.
09:31:17 <roconnor> ;(
09:31:20 <Berengal> (grep for windows, code size 10 lines)
09:31:37 <djahandarie> I still haven't found a place to use Haskell here
09:31:37 <opqdonut> quicksilver: yeah, he wants to write the monoid operation with just juxtaposition ;)
09:31:41 <opqdonut> a typical mathematician!
09:31:46 <roconnor> Base.hsc:103:18: error: pcre.h: No such file or directory
09:31:53 <roconnor> what is pcre?
09:31:59 <mauke> regex library
09:32:00 <opqdonut> perl-compatible regexps
09:32:06 <opqdonut> very nice regex library
09:32:07 <Axman6> @seen dons
09:32:08 <lambdabot> dons is in #concatenative, #arch-haskell, #ghc, #yi, #xmonad, #darcs, #haskell-in-depth and #haskell. I last heard dons speak 15h 56m 33s ago.
09:37:29 <quicksilver> although pcres have different syntax from 'real' regexps.
09:37:42 <quicksilver> In some respects I prefer the perl syntax but having to context switch regexp mode is annoying.
09:39:00 * EvilTerran finds PCRE a *lot* more consistent than posix regex
09:39:31 <EvilTerran> unbackslashed punctuation and backslashed alphanumerics are special; backslashed punctuation and unbackslashed numerics are literal
09:40:06 <EvilTerran> s/ (numerics)/alpha\1/
09:41:10 <EvilTerran> rather than an arbitrary selection of punctuation being literal on its own and magic with a backslash
09:41:40 <mauke> oh yeah, that's rule #1 of regex sanity
09:41:46 <Axman6> hooray, finally have a real website! http://random.axman6.com/blog/
09:42:00 <Axman6> and i finally own axman6.com :D
09:42:11 <Cale> Rule #1 of regex sanity is that regexes are not sane in any way.
09:42:38 <mauke> Cale: meh
09:42:43 <mauke> regexes are easy
09:42:44 <ziman> why the `6' in Axman6? :)
09:42:52 <Cale> Well, at least the classical string representations of them.
09:42:53 <Axman6> because that's my name
09:43:14 <Axman6> it's been my handle since i was like 11
09:44:08 <quicksilver> EvilTerran: yes, more consistent with itself. but not more consistent with posix.
09:44:15 <Cale> I don't mind algebraic regular expressions :)
09:44:25 <quicksilver> EvilTerran: and since I have to use other programs which use posix notation
09:44:32 <quicksilver> the constant context switches are most annoying.
09:44:39 <EvilTerran> yeah, i agree
09:44:42 <mauke> posix notation needs to die
09:44:45 <Cale> Though I often wonder why regexes don't support more operations on regular languages.
09:44:52 <EvilTerran> i'd just rather everyone used PCRE and posix regex went away forever
09:45:12 <mauke> exception: vim regexes can stay because they're so weird and cute
09:45:27 <EvilTerran> ... vim regexes *are* batshit crazy
09:45:38 <EvilTerran> and i speak of a fan of both vim and regexes
09:45:40 <Cale> The intersection of regular languages is regular, so why isn't there a convenient notation for that? It's something which is hard to do by hand, but easy for a machine to construct.
09:45:53 <mauke> \_.\{-}\%(what)\@<=
09:46:10 * jeffersonheard shrinks away from mauke
09:46:11 <steveklabnik> EvilTerran: i agree
09:46:51 <mauke> Cale: intersection is not very interesting because you'd have to make sure every match has the same length
09:46:58 <EvilTerran> Cale, vim uses "...&" to mean "match ..., then rewind to the start of it before matching the next bit", so writing "...&..." approximates intersection
09:47:16 <EvilTerran> perl itself has "(?=...)..." to similar effect
09:47:23 <mauke> yeah, lookahead is more flexible
09:47:24 <EvilTerran> i doubt either are implemented particularly efficiently, mind
09:47:25 <Zao> So that's what & means on the LHS.
09:48:11 <Cale> mauke: Er, what?
09:48:45 <Cale> mauke: Obviously, for some string to be in the intersection of two languages, it can only be one string. :P
09:48:57 <mauke> yes
09:48:58 <Cale> I don't really understand how the string's length is changing.
09:49:04 <mauke> that's hard to check and doesn't sound very useful
09:49:14 <EvilTerran> Cale, if there's no anchor at the end of the pattern, say
09:49:28 <mauke> Cale: consider ab&abc
09:49:43 <Cale> mauke: right, that intersection is empty. So what?
09:49:49 <mauke> under a strict intersection interpretation, that shouldn't match anything
09:50:04 <Cale> Right.
09:50:15 <mauke> because the two patterns match strings of a different length
09:50:22 <jeffersonheard> sed can stay.  Mainly because my favorite idiom is "find | egrep $SOMETHING | sed "s/.*/$FOO &/"| mcsh 4 +RTS -N4 -RTS
09:50:42 <mauke> jeffersonheard: no, sed can be painlessly replaced by perl
09:51:03 <gwern> so, I've been looking at this strace output for a segfaulting python program. am I correct in thinking these crazy escaped strings are some sort of C thing?
09:51:12 <Cale> mauke: Intersections of languages containing only one string are usually boring like that.
09:51:13 <EvilTerran> Cale, ^(ab&abc)$ wouldn't match anything, but (ab&abc) could match in the string "@abcd"
09:51:17 <jeffersonheard> where mcsh == "MultiCore SHell" a tiny stupid little program in Haskell that reads shell commands and forkOSes them so that there's always something running on each core
09:51:25 <Cale> EvilTerran: no, it wouldn't.
09:51:31 <mauke> Cale, so: foo.*&.*bar
09:51:39 <Cale> EvilTerran: At least, according to the way I see it...
09:51:39 <EvilTerran> Cale, um, er, why not?
09:51:49 <Cale> EvilTerran: It should be the same as  .*(ab&abc).*
09:51:53 <gwern> jeffersonheard: wouldn't it be easier to use xargs for multiple processes?
09:52:01 <Cale> EvilTerran: which still matches nothing
09:52:15 <mauke> Cale: that should find all strings that start with foo and end with bar
09:52:17 <Cale> The concatenation of the empty language with anything is still the empty language.
09:52:31 <EvilTerran> Cale, ah, i see - i don't think it works out that way in vim, seeing as & is postfix, just pretending to be infix
09:52:33 <Cale> mauke: yes.
09:52:48 <mauke> Cale: this looks very inefficient to me
09:52:51 <Axman6> @tell dons I've just setup a new website, and i was wondering if you might be able to update my info for planet haskell to get posts from http://random.axman6.com/blog/ instead of http://axman6.homeip.net/blog/
09:52:52 <lambdabot> Consider it noted.
09:52:52 <jeffersonheard> gwern: I wasn't aware that xargs would spawn multiple processes
09:53:09 <Cale> mauke: It's possible to statically construct a DFA for the intersection.
09:53:21 <gwern> jeffersonheard: sure, it's te --max-procs option
09:53:21 <mauke> Cale: only for uninteresting cases
09:53:26 <Cale> huh?
09:53:29 <gwern> usually --max-procs defaults to 1 :)
09:53:33 <Cale> No, for every single possible case.
09:53:40 <mauke> Cale: backreferences?
09:53:52 <Cale> backreferences?
09:54:00 <jeffersonheard>  never even noticed that one.  I suppose easier is realtive, since I've already solved the problem, but yes
09:54:03 <Cale> I'm talking about regular expressions here ;)
09:54:11 <EvilTerran> regexen in the wild aren't regular
09:54:18 <mauke> Cale: in the real world, most of the time we want to extract information from a match
09:54:25 <mauke> this is done with capturing groups
09:54:31 <gwern> jeffersonheard: ah, but xargs is already installed on every box you go to, unlike your custom little haskell binary
09:54:37 <gwern> reuse, reuse!
09:54:38 <Cale> mauke: yeah, that much is okay
09:55:19 <Cale> mauke: It's the context sensitive part which destroys efficiency, not intersection.
09:55:56 <mauke> then why are regexes so fast? :-)
09:56:07 <Cale> As implemented by perl, they are not.
09:56:15 <mauke> are too!
09:56:32 <Cale> They are in fact, horribly horribly slow, compared to those implemented with traditional DFAs.
09:56:55 <mauke> yeah, and those implemented with DFAs lack 70% of perl's features
09:57:24 <Cale> You pay dearly for context sensitivity.
09:57:39 <Cale> Regular expressions which don't need it should be compiled to DFAs, but are not.
09:57:55 <Cale> http://swtch.com/~rsc/regexp/regexp1.html
09:58:04 <mauke> can DFAs report which parts of a string matched which part of the regex?
09:58:49 <Cale> I suppose you may need a slightly modified style of automaton, but I don't see any difficulty with that.
09:59:06 <Cale> As long as you're matching regular languages, it should be fine.
09:59:14 <mauke> I'm not sure about that
09:59:57 <Meady> can haskell be used for higher level programs
10:00:04 <Cale> I'm pretty sure you can do it with a Mealy machine.
10:00:07 <Meady> maybe socket comms and gui sortof of things
10:00:18 <Axman6> Meady: certainly
10:00:23 <mauke> s/a(.*?)a(.*)a/[$2][$1]/
10:00:27 <Meady> I cant think of anything to make with haskell thats all
10:00:29 <Meady> Any ideas?
10:00:34 <gwern> @faq can haskell do higher level programs?
10:00:34 <lambdabot> The answer is: Yes! Haskell can do that.
10:00:36 <Meady> something simple
10:00:49 <Axman6> parallel data processing ;)
10:00:50 <Cale> Meady: when you said 'higher level programs', I thought "programs which generate other programs" and then I thought "yes".
10:01:00 <Axman6> Cale: ha
10:01:07 <Meady> oh nono i mean programs with less low level coding
10:01:22 <Axman6> haskell is a pretty high level language anyway
10:01:28 <gwern> Meady: well, the ICFP contests are great challenges
10:01:30 <Cale> Meady: Haskell is about as far from the machine as you're going to get in any case ;)
10:01:42 <sm> Meady: make a 5-room text adventure
10:02:03 <Meady> lol oooo sm
10:02:06 <EvilTerran> then make a Z-machine! :P
10:02:15 <Meady> hmm, so 5 rooms birds eye view
10:02:21 <Meady> or we talking dx 10?
10:02:21 <Meady> lol
10:02:24 <gwern> EvilTerran: we already have a z-machine
10:02:36 <EvilTerran> oh. ok.
10:02:48 <sm> just a text adventure, zork style
10:03:05 <mauke> Cale: I don't like that article
10:03:06 <EvilTerran> ?go 404 error now what
10:03:06 <Cale> mauke: Things like that should be just fine.
10:03:10 <lambdabot> https://thcnet.net/zork/index.php
10:03:10 <lambdabot> Title: ... 404 Error: Now what??? ...
10:03:13 <Cale> mauke: why?
10:03:19 <mauke> "Some might argue that this test is unfair to the backtracking implementations, since it focuses on an uncommon corner case. This argument misses the point: given a choice between an implementation with a predictable, consistent, fast running time on all inputs or one that usually runs quickly but can take years of CPU time (or more) on some inputs, the decision should be easy.
10:03:19 <EvilTerran> ^ zork, in-browser for your convenience
10:03:45 <mauke> no, this is exactly the point: you haven't demonstrated at all that your implementation works on real-world patterns
10:04:23 <mauke> so the choice is between a simple and fast and potentially useless implementation PLUS the old backtracking engine, and just the backtracking engine
10:04:24 <gwern> let's all use quicksort in accordance with the socialist lifestyle!
10:04:53 <mauke> from a maintenance point of view, we should just keep one engine, even if it has problems with certain patterns
10:05:10 <EvilTerran> gwern, er, chop everything up into itty bitty pieces and distributing it evenly? :P
10:05:18 <mauke> "... less dramatic ones do occur. Examples include using (.*) (.*) (.*) (.*) (.*) to split five space-separated fields"
10:05:26 <mauke> well, that's not what that pattern does
10:05:33 <gwern> EvilTerran: no, I was being sarcastic about mauke's view about worst-case performance
10:05:40 <Botje> it _can_ do that :)
10:05:48 <Cale> mauke: I think it's worthwhile trying to improve performance asymptotically on cases which are poorly handled.
10:05:49 <EvilTerran> mauke, i looked at that and immediately thought "those should be ([^ ])*"
10:05:50 <gwern> EvilTerran: by borrowing a North Korean propaganda phrase
10:05:51 <mauke> Botje: sort of. by accident
10:05:55 <mauke> EvilTerran: exactly :-)
10:06:27 * EvilTerran has seen some hilariously wrong regexes being spouted by people trying to be helpful, though
10:07:00 <Botje> EvilTerran: i do that on purpose if people ignore more sane approaches
10:07:07 <Meady> ok what would i look into to record key presses?
10:07:10 <Meady> in windows
10:07:17 <mauke> haha, "A recursive backtracking implementation can implement counted repetition using a loop; an NFA or DFA-based implementation must expand the repetition"
10:07:20 <Cale> Meady: getChar/getLine
10:07:34 <roconnor> is (base:GHC.Word.zdwzddmshiftR1 ww (21::base:GHC.Prim.Intzh)) making a function call to do a right shift?
10:07:37 <mauke> yeah, enjoy your horrible (some regex here){12345,21234} performance
10:07:38 <Meady> i was thinking more on a just press basis
10:07:41 <Meady> no return needed
10:07:48 <roconnor> cause that is what it looks like to me.
10:07:59 <roconnor> god damn it! dons promised me my shifts would be inlined.
10:08:29 <mauke> "Using Thompson's NFA simulation does not require such adaptation: there are no expensive regular expressions."
10:08:36 <mauke> unless they use counted repetition
10:08:52 <Botje> roconnor: uh, how would that inline?
10:09:03 <idnar> mauke: oh noes!
10:09:23 <roconnor> Botje: by replacing the call with the source of the function?
10:09:25 <Cale> mauke: It seems easy enough to introduce something into the automata to handle counted repetitions when the counts get high.
10:09:38 <Botje> perhaps shiftR is a primitive?
10:09:46 <Botje> shiftR1*
10:10:07 <roconnor> it isn't
10:10:29 <anteaterNethack> i get "invalid heap profile option: -hm" but the documention says: " -hm       Break down the live heap by the module containing    the code which produced the data."
10:10:40 <anteaterNethack> what's the problem?
10:10:40 <anteaterNethack> thanks!
10:10:40 <roconnor> Botje: it checks to see if 21 < 32 first
10:10:48 <roconnor> Every single instruction I decode!
10:11:03 <Zao> Good thing it's not something you do often.
10:11:09 <Botje> roconnor: ooh. burn :)
10:11:58 <gwern> roconnor: why not just replace 21 < 32 with True?
10:12:00 <Cale> anteaterNethack: hmm
10:12:32 <roconnor> Botje: same thing happend to me in 2006
10:12:38 <Cale> mauke: Perhaps you have a point that it would be something worthy of more careful study though.
10:12:40 <Meady> any one have any recommended ideas for drawing shapes on screen
10:12:45 <roconnor> gwern: because the call isn't being inlined.
10:12:47 <Meady> other than a co-ords system
10:12:55 <roconnor> Botje: I was promised it was fixed
10:13:08 <anteaterNethack> Cale, interestingly -h and -hT are the only options my program takes.   and -hT isn't even in the documentation page http://www.haskell.org/ghc/docs/6.8.2/html/users_guide/prof-heap.html
10:13:08 * roconnor wonders if my GHC is out of date and when it was fixed.
10:13:20 <Botje> roconnor: the Data.Word source i'm looking at has an explicit INLINE for shiftR
10:13:34 <Cale> anteaterNethack: you're using GHC 6.8.2?
10:13:37 <anteaterNethack> yes.
10:13:44 <Botje> (http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Data-Bits.html)
10:13:46 <Axman6> upgrade time
10:13:48 <anteaterNethack> current ubuntu version.
10:13:56 <gwern> arrgghhhh... the linux python version segfaults, and even the windows version errors out under wine!
10:13:56 <roconnor> Botje: which base?
10:13:59 <gwern> my system must be really fucked
10:14:15 <Axman6> how long are ubutu going to wait to upgrade ghc? 6.8.2 is ollld
10:14:20 <Meady> guys with printing on teh screen is there really only printf, or is there a way to go to a co-ord on the screen a print a character there
10:14:23 <Botje> the one that comes with 6.10.3, i guess?
10:14:23 <Cale> anteaterNethack: (that's very old, but okay)
10:14:26 <Botje> Meady: curses
10:14:34 <Cale> anteaterNethack: You compiled the program for profiling?
10:14:36 <anteaterNethack> any hints on how to upgrade to the latest ghc on ubuntu, sanely?
10:14:42 <Meady> curses isnt win32 tho is it
10:14:46 <jeffersonheard> ubuntu's packaging system seems to break cabal anyway -- I wouldn't use it if I were you
10:14:48 <anteaterNethack> cale,  ghc --make RunControl -prof -auto-all -caf-all
10:15:13 <lysgaard> Anyone want to help me understand the adhoc package in hackage? In other words build the simplest app possible using the library?
10:15:13 <Cale> anteaterNethack: I just install the generic linux binary from the GHC website
10:15:17 <anteaterNethack> ok.
10:15:18 <jeffersonheard> anteaterNethack: download the binary from the GHC website
10:15:25 <anteaterNethack> can it live alongside the ubuntu install?
10:15:34 <Cale> anteaterNethack: hmm, anyway, +RTS -hm works for me...
10:15:37 <Botje> anteaterNethack: it installs into /usr/local by default
10:15:37 <anteaterNethack> or should i remove the ubuntu package first?
10:15:43 <Botje> so you're safe
10:15:43 <anteaterNethack> ok.
10:15:45 <jeffersonheard> sort of.  I'd recommend removing the ubuntu package
10:15:48 <Cale> anteaterNethack: it can, but I would usually uninstall it anyway
10:15:55 <dhun> I am working on program that creates latex files, I have to keep track of image number and possibly other thing while writing, so I need state, I had a sloution with mapAccuL, now I changed it to use record types and to allow more state, here is a toy model that shows the change,  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6361#a6361
10:16:00 <Botje> but you'll run into ghc register nastiness
10:16:35 <dhun> so my question is, is the style ok, and can I rewrite my main program in this fashion
10:17:33 <roconnor>  can I install base 4 on GHC 6.8 ?
10:17:53 <anteaterNethack> thanks guys!
10:18:32 <Cale> Meady: there are libraries like vty which handle terminal I/O and sending special control characters (though I have no idea what that means for Windows)
10:20:22 <Botje> roconnor: fwiw, the 6.8.3 Data.Word doesn't do inlining
10:20:25 <Cale> vty seems to require the unix package, so I don't know if it even works on windows...
10:20:35 <Botje> apparently
10:20:40 <roconnor> Botje: ah
10:20:46 * roconnor downloads 6.10
10:21:04 * roconnor temporarily retracts complain for dons
10:21:15 <Botje> (http://www.haskell.org/ghc/docs/6.8.3/html/libraries/base/src/Data-Bits.html) vs the other link i pasted
10:21:41 <sm> Meady: you're right, curses won't work on windows. Nor will the easier vty lib. Unless you use cygwin. The ansi-terminal package should work, but it's slow
10:24:16 <dhun> I don't really want to start implementing that now because I am afraid my solution might look wired to others, but I can not find any more beautiful myself
10:24:37 * Cale has a look at dhun's code
10:25:09 <dhun> thank you Cale
10:25:09 <Botje> dhun: I think this will look better using the State monad
10:25:30 <Botje> dhun: also, you can update records like so: st{getF=...}
10:25:52 <dhun> so I don't need to write both, if I want to update one
10:25:56 <Botje> indeed
10:26:17 * sm notices that haskell getopt accepts just a prefix of long --options
10:27:03 <Meady> should i use for loops in haskell?
10:27:14 <Meady> or try to write them as sets
10:27:19 <dons> Meady: ?
10:27:19 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
10:27:22 <Cale> dhun: This looks like it should be easier to express once you've written a general fold for your tree type
10:27:27 <dons> Meady: example please
10:27:44 <Meady> well i have so far
10:27:47 <pikhq> Meady: I was unaware that Haskell had for loops.
10:27:51 <dhun> Cale, maybe have to think about it
10:27:51 <Meady> let boxtop = 20
10:27:51 <Meady> let boxhei = 10
10:27:51 <Meady> let boxwid = 5
10:27:51 <Meady> printBox :: Int -> Int -> Int -> Int
10:28:04 <jeffersonheard> Meady: You should think about what your data actually is and use what's appropriate.  if you've got a Set, use a Set.  If you need to compute a single value from a set, fold over it
10:28:16 <jeffersonheard> if you need to compute a new set from an old set, map over it
10:28:22 <Cale> foldTree l n = f where f Leaf = l; f (Node x y ts) = n x y (map f ts)
10:28:37 <portnov> dons, does the `plugins` package work with ghc 6.10?
10:28:44 <Cale> dhun: oh, hmm, you need state...
10:28:53 <dhun> yes I do
10:28:56 <dons> portnov: its unmaintained, though I hope to pick it back up soon
10:28:57 <Berengal> Generating 2Gb of random data takes time...
10:28:59 <opqdonut> Foldable!
10:29:10 <opqdonut> :t Data.Foldable.fold
10:29:12 <lambdabot> forall (t :: * -> *) m. (Data.Foldable.Foldable t, Monoid m) => t m -> m
10:29:16 <Cale> dhun: well, I suppose it's still usable, you just need to construct a state monad action :)
10:29:17 <dons> portnov: as a result, status is unknown. might work for you
10:29:17 <Meady> well in this case im saying do this based on how big this int it, not how big the list is
10:29:19 <dons> esp. on linux
10:29:31 <opqdonut> ah, it was Traversable that had the applicative
10:29:31 <Cale> dhun: (or more explicitly, a function)
10:29:47 <Meady> so how would i say do it for how big the int is
10:30:00 <Meady> i know list would be x -> list would go through each element
10:30:02 <Cale> Meady: if you know how to do it with a list, you can always use [1..n]
10:30:05 <portnov> it does not work for me, I thought if this is my local bug or what...
10:30:06 <jmcarthur_work> Meady, you could either use recursion or make a list [1..n]
10:30:07 <Meady> hmm
10:30:15 <Meady> ok guys
10:30:16 <dhun> if you think it will make so code significantly more readable to other I will learn about that
10:30:30 <Cale> dhun: I'll give this a shot myself :)
10:30:36 <Meady> List it is then
10:30:54 <jmcarthur_work> good decision (between lists and recursion) ;)
10:30:57 <Axman6> dons: did you get me message earlier?
10:32:07 <Meady> printLine len = [putStr '-' | a -> len] ??
10:32:19 <Meady> would that print - for every element in len?
10:32:24 <Axman6> o...
10:32:25 <Meady> putChar*
10:32:26 <Axman6> no*
10:32:39 <Meady> oh
10:32:40 <Twey> 18:27:50 < pikhq> Meady: I was unaware that Haskell had for loops.
10:32:44 <Axman6> Meady: it wouldn't actually print anything
10:32:46 <Twey> :t forM_
10:32:48 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
10:32:50 <Twey> :)
10:32:54 <mauke> Meady: it would build a list of print actions
10:33:10 <Meady> ah right ok but why would it do that, i havent used map
10:33:19 <Meady> :s
10:33:20 <Twey> <-
10:33:21 <Axman6> :t printLine xs = [putChar '-' | x <- xs]
10:33:22 <mauke> Meady: because that's what list comprehensions do
10:33:23 <lambdabot> parse error on input `='
10:33:34 <Axman6> :t let printLine xs = [putChar '-' | x <- xs] in printLine
10:33:34 <Twey> :t [putChar '-' | x <- xs]
10:33:36 <lambdabot> Not in scope: `xs'
10:33:36 <lambdabot> forall t. [t] -> [IO ()]
10:34:10 <Axman6> Meady: you have actually used, i a way
10:34:12 <Twey> :t [putChar '-' | x <- undefined]
10:34:14 <lambdabot> [IO ()]
10:34:34 <Axman6> that's the same as printLine xs = map (const (putChar '-')) xs
10:34:45 <Axman6> used map*
10:34:47 <Berengal> list comprehensions always return lists
10:34:59 <Meady> ah ok
10:35:02 <jmcarthur_work> :t \xs -> sequence_ $ putChar '-' <$ xs
10:35:04 <lambdabot> forall b. [b] -> IO ()
10:35:05 <Meady> so could someone give me an example of printing a line?
10:35:06 <Twey> You can use sequence to convert [m a] to m [a]
10:35:21 <Twey> And sequence . map = mapM
10:35:25 <Axman6> Meady: what do you mean by printing a line?
10:35:38 <Meady> well it shouldnt be so complicated to print "--------------------"
10:35:40 <mauke> :t \xs -> putStrLn (['-' | xs])
10:35:40 <jmcarthur_work> Axman6, i think he means ascii art
10:35:41 <lambdabot> Bool -> IO ()
10:35:45 <Twey> So printLine = mapM putStr
10:35:47 <mauke> :t \xs -> putStrLn (['-' | _ <- xs])
10:35:47 <Meady> - * the number of elements
10:35:48 <lambdabot> forall t. [t] -> IO ()
10:36:05 <mauke> Meady: putStrLn (replicate n '-')
10:36:10 <Twey> Or rather, for that one, printLine = mapM (const $ putStr "-")
10:36:20 <jmcarthur_work> > '-' <$ [1..20]
10:36:22 <lambdabot>   "--------------------"
10:36:23 <Meady> lol this is far to complicated lol
10:36:25 <mauke> mapM? I think not
10:36:29 <Meady> i call quit time xD lol
10:36:29 <Axman6> Meady: my advice to you is to stay away from IO for a while, until you're more confortable with haskell
10:36:34 <jmcarthur_work> > '-' <$ [1..200]
10:36:36 <lambdabot>   "--------------------------------------------------------------------------...
10:36:52 <portnov> :t sequence $ repeat (length xs) (putChar '-')
10:36:54 <lambdabot> Not in scope: `xs'
10:37:02 <Meady> > putStr (['-'] | _ <- xs])
10:37:04 <lambdabot>   <no location info>: parse error on input `|'
10:37:09 <Axman6> jmcarthur_work: that's getting uo there with j for readability >_<
10:37:14 <Meady> > putStr (['-'] | _ <- [1..20]])
10:37:15 <lambdabot>   <no location info>: parse error on input `|'
10:37:17 <mauke> Meady: the ] is wrong
10:37:20 <Meady> > putStr (['-'] | _ <- [1..20])
10:37:21 <lambdabot>   <no location info>: parse error on input `|'
10:37:24 <jmcarthur_work> Axman6, far better than all these other solutions
10:37:24 <Meady> ffs
10:37:30 <mauke> still wrong
10:37:31 <Meady> ARRRRRRRRRRRRRRRRRR
10:37:40 <jmcarthur_work> :t \xs -> putStrLn $ '-' <$ xs
10:37:41 <lambdabot> forall b. [b] -> IO ()
10:37:57 <Cale> dhun: actually, the way that you have this tree transformation/elaboration mixed up with producing the strings is making this complicated.
10:38:03 <Meady> stop printing :t's because i dont understand them
10:38:09 <Meady> not the <$
10:38:10 <Axman6> Meady: try writing programs that build up the srings you want, then print them out once
10:38:25 <Axman6> it'll be much more flexi\ble
10:38:26 <jmcarthur_work> Meady, <$ replaces all the elements of the list with whatever you put on the left
10:38:26 <mauke> Meady: putStrLn (['-' | _ <- xs])
10:38:30 <dhun> maybe it is helpful if I explain the practical problem behind it
10:38:44 <dhun> I have parse tree of mediawiki source
10:38:48 <mauke> and I don't even need those parens
10:38:48 <Cale> dhun: Why not first elaborate the tree to include the additional data you're going to involve in each node/leaf, and then *separately* print it out?
10:38:51 <jeffersonheard> Meady: try reading through Yet Another Haskell Tutorial or Learn Yourself a Haskell
10:38:58 <jeffersonheard> Meady: both are available from the Haskell website
10:39:02 <dhun> maybe
10:39:04 <jeffersonheard> and will save you a LOT of frustration
10:39:10 <jmcarthur_work> Meady, so if you have a list of 20 elements, '-' <$ xs gives you a string with 20 hyphens... then you can just putStrLn the whole thing at once
10:39:13 <dhun> but I am not changing the tree
10:39:26 <Cale> Oh, but you are?
10:39:34 <Cale> The Leaf constructor takes no parameters
10:39:38 <Meady> i think ill give it today then ill switch back to oop
10:39:46 <Cale> But the <l ... > nodes in your xml tree do.
10:39:51 <Axman6> jmcarthur_work: this isn't helpful for someone who's only been learning haskell for a day or so
10:39:58 <dhun> yes in the output
10:40:08 <jmcarthur_work> Axman6, is my explanation really so unclear?
10:40:21 <Twey> It's not unclear
10:40:23 <Meady> myPr :: String -> IO()
10:40:23 <Meady> myPr inp = putStr(inp)
10:40:26 <jmcarthur_work> Axman6, i'm not even talking about functors and stuff
10:40:26 <Cale> dhun: Right, so I'm saying, first elaborate to get the abstract XML tree you want, and only then convert it to a string in the way you want.
10:40:28 <dhun> ok so you think of modifying the tree first and writing it afterwards
10:40:28 <Axman6> jmcarthur_work: no, but the topics are too advanced imo
10:40:36 <Twey> It's a perfectly fine explanation — so long as the person is aware of the concepts involved
10:40:40 <Cale> dhun: It'll be lazy anyway, so these will happen together.
10:40:41 * Twey nods.
10:40:54 <dhun> interesting apporach
10:41:00 <dhun> I never thought of that
10:41:10 <Meady> How do i get what i've wrote to work
10:41:26 <Cale> The conversion to a string is *much* simpler then.
10:41:28 <mauke> Meady: how does it not work?
10:41:34 <Axman6> Meady: it should work fine (though the spacing is a little odd)
10:41:34 <Cale> (and really is just a plain fold)
10:41:36 <dhun> I think it might be a drastic change in the code
10:42:15 <Meady> Right ok that seems to do it
10:42:36 <Axman6> Meady: in haskell, you generally try and stay away from IO as much as possible. that way your code can be much clearer, and safer
10:42:36 <mauke> myPr = putStr  -- simpler
10:42:43 <dhun> and furthermore I have to add the state to every node
10:42:57 <Cale> Meady: however, all you've done is define another name for putStr of course :)
10:43:00 <jmcarthur_work> i don't think it should be hard to understand what <$ does. even map is more complicated than <$
10:43:33 <Cale> jmcarthur_work: I think replicate is simpler to understand here :)
10:43:36 <portnov> :t (<$)
10:43:37 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
10:43:37 <Axman6> jmcarthur_work: sure, but it's not like it's a beginners function either
10:43:47 <dhun> Cale your aproach looks to me, but this is likely because I am not experienced
10:43:54 <Cale> jmcarthur_work: To be honest, I would have to look up the type of <$ to understand what was going on :)
10:44:01 <Axman6> :t fmap . const
10:44:02 <Cale> dhun: hm?
10:44:03 <jmcarthur_work> Axman6, just because most tutorials don't introduce it soon doesn't mean it fundamentally shouldn't be introduced soon
10:44:03 <lambdabot> forall a (f :: * -> *) a1. (Functor f) => a1 -> f a -> f a1
10:44:22 <Axman6> :t fmap . flip const
10:44:23 <Cale> dhun: looks what?
10:44:24 <lambdabot> forall a (f :: * -> *) a1. (Functor f) => a1 -> f a -> f a
10:44:30 <dhun> wired
10:44:36 <Axman6> duh -_-
10:44:52 <Axman6> jmcarthur_work: yeah, i agree, but maybe not this soon ;)
10:44:54 <Cale> dhun: It seems like the obvious thing to me somehow. Don't try to do everything all at the same time.
10:45:10 <Cale> dhun: Break the program into as many simple small pieces as you can reasonably afford :)
10:45:13 <jmcarthur_work> Axman6, anyway, i agree with Cale that replicate would be a better choice
10:45:14 <Meady> still no idea with this for all
10:45:18 <Meady> maybe a web page/
10:45:24 <jmcarthur_work> i didn't think about that
10:45:41 <Meady> ok im on hoogle
10:45:47 <Cale> > replicate 20 '-'
10:45:49 <lambdabot>   "--------------------"
10:46:11 <Cale> > take 21 (cycle "-=")
10:46:12 <lambdabot>   "-=-=-=-=-=-=-=-=-=-=-"
10:47:15 <Cale> > take 40 (cycle ".,-'`'-,")
10:47:17 <lambdabot>   ".,-'`'-,.,-'`'-,.,-'`'-,.,-'`'-,.,-'`'-,"
10:47:18 <Twey> :t Int -> [a] -> [a]
10:47:20 <lambdabot> parse error on input `->'
10:47:32 <Meady> > replicate let x = 10 '-'
10:47:32 <Twey> @hoogle Int -> [a] -> [a]
10:47:33 <lambdabot> Prelude drop :: Int -> [a] -> [a]
10:47:34 <lambdabot> Prelude take :: Int -> [a] -> [a]
10:47:34 <lambdabot> Data.List drop :: Int -> [a] -> [a]
10:47:34 <lambdabot>   <no location info>: parse error on input `let'
10:47:34 <Twey> (d'oh)
10:47:34 <Axman6> jmcarthur_work: as a side note, i didn't know about what <$ did until you just used it, so now i've learnt something :)
10:47:39 <Twey> Hmn
10:47:46 <roconnor> Botje: nice.  In GHC 6.10 I have ghczmprim:GHCziPrim.uncheckedShiftRLzh
10:47:55 <Cale> > let x = 10 in replicate x '-'
10:47:57 <lambdabot>   "----------"
10:47:58 <Axman6> Meady: what's the let x = doing in there?
10:48:02 <Meady> i can kind of see why there isnt much haskell in the world lol
10:48:13 <Cale> Meady: What was that supposed to mean?
10:48:27 <opqdonut> it isn't hard, really
10:48:27 <Meady> probably alot of people quit after a few days
10:48:41 <Meady> im sure opqdonut, you been doing it for months, years, centuries?
10:48:44 <roconnor> dons++
10:48:47 <Meady> or 1day/half
10:48:48 <dhun> Cale so you mean a definition like this http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6362#a6362
10:48:50 <mauke> yeah, but not because they can't figure out function calls
10:48:51 <Axman6> Meady: once you get the hang of the syntax (like any programmig language), you'll see it's actually a very easy and nice language to use for a whole range of things
10:49:00 <Meady> hmm
10:49:03 <Cale> Meady: yeah. Some people expect relearning how to program to be easy somehow. ;)
10:49:04 <Botje> roconnor: yay!
10:49:11 <dons> roconnor: roxors!
10:49:14 <roconnor> Botje: now to race the code
10:49:20 <dons> roconnor: how long have we been talking about this ::)
10:49:30 <roconnor> dons: since 2006
10:49:50 <roconnor> dons: sorry for whining today.  My GHC is out of date
10:49:56 <Cale> dhun: well, not necessarily, though you could do it that way.
10:50:01 <roconnor> I don't want to update my system until I send my thesis to the printer
10:50:08 <Meady> im just not understanding running multiple functions inside a function definition
10:50:13 <Axman6> what've you been talking about since 2006?
10:50:14 <Berengal> I think I might be starting to like ByteString
10:50:26 <mauke> Meady: well, that depends on what you want to do with the results
10:50:29 <Cale> dhun: Why are there two sets of labels for the Nodes?
10:50:33 <Meady> print them out
10:50:37 <Meady> but i want somethingi  can use in general
10:50:48 <Cale> dhun: You have a Float and Int in the Node constructor, and then another one in the state...
10:50:49 <mauke> you can't combine two values "in general"
10:50:51 <Meady> replicate will work for my printing, but maybe ill want to do something else next time
10:50:58 <Berengal> using String I found the last char of a 2Gb large file in 1 min, 30 sec, using 3.2 Mb of mem and 25% CPU. Using LBS I found it in 30 sec, using 1 Mb of mem and 5% CPU
10:51:01 <mauke> you need something that takes two inputs and returns one output
10:51:45 <pikhq> Meady: Few days? After 4 days I grokked Haskell.
10:52:00 <jmcarthur_work> Meady, you would have to do "something else" to do anything else in any other language, too. perhaps you mean that in a particular way that i don't understand
10:52:01 <dhun> well the int is number of image, and the float is current scale of the image
10:52:03 <mauke> I think I quit learning haskell twice
10:52:04 <dhun> well the int is number of image, and the float is current scale of the images
10:52:04 <Meady> lol still not a day and a half
10:52:09 <jmcarthur_work> Meady, replicate is useful for very many things
10:52:15 <Meady> jmcarthur, not exactly
10:52:31 <deech> Hi all, I am trying to understand how the generalized newtype derivation works with monad transformers so I made a small example : http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6358#a6364.
10:52:45 <dhun> if a Node has an Int=3 it means that it includes 3 images, at shallow level
10:52:50 <Meady> Int i; for (i = 0; i < boxheight; i++) {function; another function;} would be generic
10:52:50 <Twey> What's the difference between a TVar and a TMVar?
10:53:00 <deech> I am trying to chain computations together but my code doesn't work.
10:53:13 <jmcarthur_work> Meady, where function and another function perform side effects?
10:53:20 <dhun> the node can contain more node which can in turn contain images, but thats deep level
10:53:25 <Axman6> Twey: TMVars can be empty i think
10:53:29 <Meady> nope
10:53:35 <dhun> the float is scale of the image
10:53:42 <mauke> Meady: if they don't have side effects, then that code does nothing
10:53:47 <Meady> maybe they are print statments, add statments, sockets sending messages, they woudlnt affect each other
10:53:49 <Axman6> Meady: well where to their results go then?
10:53:51 <Meady> :S
10:53:51 <Berengal> forM_ [0..boxheight - 1] $ \_ -> do {function; another function}
10:53:52 <Twey> Meady: replicateM boxheight (action >> anotherAction)
10:53:54 <jmcarthur_work> Meady, those are side effects
10:53:58 <mauke> Meady: so they're basically full of side effects
10:53:59 <Axman6> Meady: then they have side effects
10:54:13 <Meady> they are not side effects if they are intended
10:54:17 <mauke> yes, they are
10:54:18 <dhun> if a node is a table the image in included by this node and all its subnodes need to be scaled to the width of the row
10:54:22 <mauke> Meady: short answer: use >>
10:54:26 <Meady> ok thanks lol
10:54:27 <Axman6> Meady: no, they are side effects
10:54:40 <jmcarthur_work> Meady, mapM_ (function >> another function) [0..boxHeight] -- there's your for loop :)
10:54:45 <Axman6> in terms of a functional program, they produce side effects
10:54:51 <dhun> the integer in state is the number of images included so far
10:54:52 <Axman6> :t putStr
10:54:53 <Cale> dhun: My idea is basically to construct an abstract XML tree first.
10:54:53 <lambdabot> String -> IO ()
10:54:58 <roconnor> Simulation.hs:10:9: parse error on input `infix'
10:55:06 <dhun> well I am writing latex not xml
10:55:10 <roconnor> huh, why does my code no longer compile in GHC 6.10?
10:55:13 <dhun> the xml is just for the toy model
10:55:17 <Cale> dhun: Or latex, it doesn't matter :)
10:55:20 <jmcarthur_work> i rarely use it, but i think there is a forM_ that does the same thing with reverse argument order
10:55:23 <Axman6> all that type signature says is that putStr returns an IO (), that has nothing to do with the string getting printed
10:55:26 <roconnor> is infix 7 `scale` legal?
10:55:38 <Meady> maybe ill just stick with the simple boring learn you a haskell for now
10:55:38 <Meady> :s
10:55:42 <Cale> dhun: The important thing is that it exactly matches the structure of the document you will eventually produce, but consists of a Haskell datatype
10:55:42 <Axman6> roconnor: i think it might be
10:55:44 * jeffersonheard awaits hackagebot
10:55:54 <Cale> dhun: Then separately convert that structure into a string.
10:55:59 <roconnor> what's the problem.
10:56:01 <roconnor> strange
10:56:01 <Axman6> jeffersonheard: what've you uploaded?
10:56:05 <sm> jeffersonheard: has it stopped ?
10:56:06 <Cale> dhun: This lets you focus on one concern at a time :)
10:56:08 <jeffersonheard> 3.5 of Hieroglyph
10:56:11 <Berengal> jmcarthur_work: See my above forM (you also forgot a lambda in your function, and subtract 1 from boxheight, but now I'm getting pendantic)
10:56:19 <dhun> it is interisting
10:56:20 <jeffersonheard> added stylesheets
10:56:26 <pikhq> Axman6: Strictly speaking, there are no side effects. The IO monad merely contains a description of the desired side effects.
10:56:36 <Axman6> yeah
10:56:58 <Axman6> pikhq: though, that's technically implementation specific anyway right?
10:57:05 <dhun> but I think it might be more work, since I have to write write an iteration over the whole tree twice
10:57:09 <jmcarthur_work> Berengal, i was responding to: "for (i = 0; i < boxheight; i++) {function; another function;}" .. i wasn't considering what function and another function do, so a lambda would have been a guess
10:57:09 <jeffersonheard> so now you can give visuals a style with the "style" combinator, and apply a stylesheet to them using "withStylesheet"
10:57:12 <Twey> Axman6: Oh, right
10:57:14 <Cale> Meady: You're right, they're not side effects if they are intended. Values of type (IO t) in Haskell describe sets of effects which may be made to happen at some point.
10:57:25 <pikhq> Axman6: How it does is implementation specific.
10:57:26 <jmcarthur_work> oh, still subtract 1, right
10:57:29 <Cale> Meady: We have all sorts of operations for combining and chaining together effects.
10:57:34 <Twey> Thanks
10:57:46 <Cale> Meady: In the end, the main value in your compiled program is such a description of what is to occur.
10:57:49 <Berengal> @type mapM
10:57:51 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
10:57:58 <Meady> what does (a -> b) represent
10:57:59 <Berengal> @type (?a >> ?b)
10:58:01 <lambdabot> forall (m :: * -> *) a b. (?a::m a, ?b::m b, Monad m) => m b
10:58:13 <Cale> Meady: (a -> b) is the type of functions which take a value of type a and produce a value of type b
10:58:15 <pikhq> Meady: A function of type (a -> b), of course.
10:58:20 <Axman6> Meady: a function that takes something of type a and returns something of type b
10:58:23 <Meady> ahh ok
10:58:24 <Berengal> jmcarthur_work: Unless you're in the function monad, you still need a lambda :P
10:58:25 <Meady> wicked
10:58:25 <Cale> :t ord
10:58:27 <lambdabot> Char -> Int
10:58:28 <Meady> # map :: (a -> b) -> [a] -> [b]
10:58:31 <Cale> > ord 'a'
10:58:33 <lambdabot>   97
10:58:33 <Meady> that makes a bit more sense now
10:58:34 <jmcarthur_work> Berengal, i was simply ignoring such details :P
10:58:39 <Cale> > map ord "Hello"
10:58:41 <lambdabot>   [72,101,108,108,111]
10:59:02 <jmcarthur_work> i intended to emphasize the mapM_ part
10:59:13 <roconnor> ah
10:59:14 <Berengal> Yeah, mapM_/forM_ is nifty...
10:59:43 <sm> yes, hackagebot has stopped. rss2irc isn't rock solid yet :/
10:59:52 <roconnor> oh the cpp was messing up "infix 7 /\"
11:00:07 <dhun> the full source is here just for completeness http://wb2pdf.svn.sourceforge.net/viewvc/wb2pdf/trunk/src2/pa.hs?revision=22&view=markup
11:00:20 <dons> roconnor: but you installed the platform, right, so now you're up to date?
11:00:25 <sm> it missed 9 releases. I'll show the last 3 I guess
11:00:59 <roconnor> dons: what do you mean?  I haven't sent my thesis to the printer yet.  Sometime this week probably.
11:01:00 <Meady> myRev :: [Int] -> [Int]
11:01:00 <Meady> myRev a = reverse a
11:01:07 <roconnor> dons: I just installed GHC 6.10 in /tmp/
11:01:50 <dons> ah
11:02:13 <Berengal> myRev = foldl (flip (:)) []
11:02:20 <jmcarthur_work> Meady, is there a question to go with that?
11:02:31 * Berengal is probably too fond of folds
11:02:35 <hackagebot> Omega 0.1.2 - Operations on Presburger arithmetic formulae (ChristopherRodrigues)
11:02:35 <hackagebot> Boolean 0.0.0 - Generalized boolean ops (ConalElliott)
11:02:35 <hackagebot> Hieroglyph 3.5 - Purely functional 2D graphics for visualization. (JeffersonHeard)
11:02:38 <Meady> can someone give me a simple example of map with all its paremeters
11:02:42 <jmcarthur_work> myRev = reverse  -- perfectly valid, btw
11:02:44 <Meady> map (func,list)?
11:02:54 <jeffersonheard> ah ha. there it is :-)
11:02:54 <Berengal> @type map
11:02:56 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
11:02:58 <Berengal> @type map (+1)
11:02:59 <lambdabot> forall a. (Num a) => [a] -> [a]
11:03:00 <Axman6> Meady: you know what's cool? that function can be written as myRev = reverse
11:03:02 <jmcarthur_work> > map (\x -> x+1) [0..5]
11:03:03 <Berengal> @type map (+1) [1..10]
11:03:05 <lambdabot>   [1,2,3,4,5,6]
11:03:05 <lambdabot> forall a. (Num a, Enum a) => [a]
11:03:05 <dons> i'm glad hackagebot prints more stuff now
11:03:19 <Berengal> > map (+1) [1..10]
11:03:19 <Meady> lol Axman6
11:03:20 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
11:03:31 <Meady> so map (function) list?
11:03:35 <deech> I got it! The updated code is at http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6358#a6365
11:03:36 <sm> great. Consensus seemed to be to not show the url
11:03:43 <jmcarthur_work> > map id [0..5]
11:03:44 <Berengal> Meady: The parens are just for grouping
11:03:44 <lambdabot>   [0,1,2,3,4,5]
11:03:57 <Meady> myRev a = map (+10) a
11:03:58 <Meady> :d
11:04:03 <jmcarthur_work> Meady, the function needn't be in parens except for grouping. if it's just one identifier you can leave off the parens
11:04:12 <jmcarthur_work> Meady, map func list
11:04:12 <Axman6> myRev = map (+1)
11:04:14 <Axman6> >_>
11:04:22 <deech> sm : Was that aimed at me?
11:04:26 <Meady> > map +10 [1,2,3]
11:04:28 <lambdabot>   Add a type signature
11:04:30 <Berengal> Meady: The parameters can be seen from the type as well
11:04:35 <jmcarthur_work> Meady, the operator thing requires the parens
11:04:37 <sm> deech: no, at dons
11:04:38 <Meady> > map (+10) [1,2,3]
11:04:39 <Berengal> @type map ?func ?list
11:04:40 <lambdabot>   [11,12,13]
11:04:40 <lambdabot> forall a b. (?list::[a], ?func::a -> b) => [b]
11:04:52 <dons> sm: we'd maybe need a tinyurl
11:05:04 <deech> sm : Ok. Miscommunication. My bad.
11:05:21 <sm> here's an example: http://hackage.haskell.org/package/L-seed-0.2
11:05:34 <sm> I've got it showing urls in a private channel, so I'm ok :)
11:06:03 <Berengal> Does hackagebot do anything other than announce uploads?
11:06:03 <Meady> # map :: (a -> b) -> [a] -> [b]      is that why i need (+10) because (a -> b) states that this function will take in an integer apply +10 and spit it back out?
11:06:35 <sm> Berengal: no
11:06:58 <sm> it's rss2irc, which strictly mirrors a feed to irc (with various options)
11:07:00 <sm> dons: have you had a chance to apply/pull my rss2irc patches ?
11:07:14 <jmcarthur_work> Meady, yes. the (+10) has type :: Int -> Int, in this case (it's actually more general than that, but for now...), and Int -> Int unifies perfectly well with (a -> b)
11:07:14 <Berengal> Meady: (+10) is a section, which requires parens
11:07:17 <Meady> so map (+10) a, spits each element of a into the () which adds 10 and spits b back out
11:07:39 <jmcarthur_work> Meady, eh... you could envision it that way, but the parens are purely syntactical
11:07:46 <Berengal> @src map
11:07:47 <lambdabot> map _ []     = []
11:07:47 <lambdabot> map f (x:xs) = f x : map f xs
11:08:00 <Axman6> Meady: (+10) is sort of short hand for (\x -> x + 10)
11:08:21 <Meady> oki
11:08:31 <Berengal> > map (`elem` [1..10]) [-5..15]
11:08:33 <Meady> so how wouldi write it not short hand
11:08:33 <lambdabot>   [False,False,False,False,False,False,True,True,True,True,True,True,True,Tru...
11:08:43 <jmcarthur_work> Meady, (\x -> x + 10)
11:09:12 <Meady> so Barengal from [-5..15) each value is checked to see if it exists in the elem list and then spits out result, int -> int?
11:09:15 <Meady> same as +10
11:10:57 <Berengal> Meady: elem has type (Eq a) => a -> [a] -> Bool, putting a function inbetween backticks makes it an operator (like `this`), and putting that again in parens with one argument applied makes it a section. Since the argument appears after the operator, it's the second argument, so (`elem` [1..10]) has type (Num a) => a -> Bool
11:11:17 <Berengal> If you don't know what (Num a) => a means, just think of it as Int for now :)
11:11:37 <Meady> i know a needs to be in type class num
11:11:41 <Meady> so yeah int, double etc?
11:11:57 <Berengal> Yeah, everything that is a number
11:12:03 <dhun> Cale, thank you for your idea, I think they are good, and I think there is a tree in pandoc that might do the job, but I think I won't do it, at least not soon, because it requires to rewrite nearly everything
11:12:24 <Berengal> This is because number literals are overloaded, so any type of number can be written with them
11:12:45 <Cale> dhun: yeah, that is a really long program to have to rewrite :)
11:12:51 <dhun> and the problem is if I rewrite everything now, I will make other mistakes, that will cause other rewrites
11:13:02 <Berengal> > (1 ::Int, 1 :: Double, 1 :: Rational, 1 :: Word8)
11:13:04 <lambdabot>   (1,1.0,1 % 1,1)
11:13:12 <Meady> dhun: write it in python :D
11:13:13 <Meady> lol
11:13:21 <dhun> I tryed
11:13:29 <LeCamarade> How do I handle Unicode in Haskell? I mean, since functions like "show" seem to chew it up.
11:13:31 <dhun> it works bette in Haskell
11:13:47 <Berengal> LeCamarade: Char is already unicode
11:13:53 <Meady> So berengal, how does elem will only rerturn bools to the new list
11:13:55 <Meady> ?
11:14:02 <Meady> ok give me something simple to do
11:14:23 <byorgey> LeCamarade: I think the 'text' package on Haskell is supposed to be the canonical solution for this sort of thing.
11:14:25 <Meady> forget the how in that last one berengal
11:14:26 <Meady> lol
11:14:43 <Berengal> Meady: Yeah, elem only returns bools
11:14:48 <roconnor> dons: my GHC 6.10 code seem to be about 4x slower than GHC 6.8 :)
11:14:50 <Cale> Well, utf8-light is often simpler...
11:14:55 <LeCamarade> Hmm.
11:14:55 <Meady> ok Berengal could you give me a task to do
11:15:06 <byorgey> ok, didn't know about utf8-light.
11:15:16 <Berengal> Meady: Find the sum of all integers between 1 and 999 that are divisible by either 3 or 5 or both
11:15:27 <Cale> LeCamarade: The problem is that until 6.12, the standard I/O functions don't handle UTF-8 encoding.
11:15:40 <Cale> LeCamarade: Even though Char itself is adequate to store unicode characters.
11:15:41 <Meady> ok boss :D
11:16:01 <Cale> (6.12 isn't out yet, but the new I/O library is apparenltly done)
11:16:05 <Cale> apparently*
11:16:13 <Berengal> Cale: So, HEAD?
11:16:15 <LeCamarade> Cale, So, if I am talking across, say, TCP, I'll have to deal with my accented characters being gobbled?
11:16:19 <Cale> Berengal: I think so.
11:16:44 <Cale> LeCamarade: Well, you just need something to handle proper encoding of those characters before they are transmitted.
11:16:52 <Meady> Tasty two scoops of protein + water :D
11:17:02 <Meady> bannana water isnt that nice tbh lol
11:17:32 <copumpkin> :o
11:17:43 <Meady> lol
11:17:44 <Meady> :D
11:18:44 <Meady> berengal, can i add multiple conditions to sets by seperating them with ,?
11:20:49 <Berengal> No, you use &&, || and the like
11:21:16 <Meady> ahh ok
11:21:21 <Berengal> (using list comprehension, you could use , to mean &&)
11:21:31 <Meady> >
11:21:32 <Meady> [x|x -> [1..999], (x / 3) > 0]
11:21:37 <Meady> > [x|x -> [1..999], (x / 3) > 0]
11:21:38 <lambdabot>   <no location info>: parse error on input `->'
11:21:49 <Berengal> > [x|x <- [1..999], (x / 3) > 0]
11:21:51 <lambdabot>   [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0,11.0,12.0,13.0,14.0,15.0,16.0,17....
11:22:11 <lilac> > [ x | x <- [1..999], x `mod` 3 == 0]
11:22:13 <lambdabot>   [3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,78...
11:22:18 <Meady> arrow was wrong way round, thats not good
11:22:20 <Berengal> Also, / is division for floats, div is for integers
11:22:30 <Meady> > [x|x <- [1..999], (x / 3) > 0]
11:22:31 <lambdabot>   [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0,11.0,12.0,13.0,14.0,15.0,16.0,17....
11:22:33 <Berengal> Meady: Syntax is always the most boring part of learning...
11:23:08 <Meady> > [x|x <- [1..999], x 'mod' 3 == 0 ]
11:23:09 <lambdabot>   <no location info>:
11:23:09 <lambdabot>      lexical error in string/character literal at chara...
11:23:14 <lilac> Meady: it might help to think of the <- as meaning, "for each value in the thing on the right, bind it to the name on the left"
11:23:20 <Meady> > [x|x <- [1..999], x 'mod" 3 == 0 ]
11:23:21 <lambdabot>   <no location info>:
11:23:21 <lambdabot>      lexical error in string/character literal at chara...
11:23:27 <Meady> > [x|x <- [1..999], x  3 == 0 ]
11:23:29 <lambdabot>   No instance for (GHC.Enum.Enum (t -> a))
11:23:29 <lambdabot>    arising from the arithmetic seq...
11:23:34 <Cale> LeCamarade: actually http://hackage.haskell.org/package/utf8-string-0.3.5 looks nice. Just use the functions from System.IO.UTF8 and you should be fine
11:23:36 <lilac> Meady: or perhaps more simply, read "<-" as "in" or "from"
11:23:39 <Meady> ahhhh ok lilac wicked
11:23:39 <Berengal> > [x|x <- [1..999], x `mod` 3 == 0 ]
11:23:41 <lambdabot>   [3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,78...
11:23:54 <DLeo> any way to uninstall packages via cabal? it seems i have both monads-fd and mtl, which leads to conflicts
11:23:54 <Berengal> Backticks, not single quote
11:24:16 <dcoutts> DLeo: ghc-pkg hide monads-fd
11:24:25 <Meady> > [x|x <- [1..999], x `mod` 3 == 0 || x 'mod' 5 == 0]
11:24:26 <lambdabot>   <no location info>:
11:24:26 <lambdabot>      lexical error in string/character literal at chara...
11:24:26 <Berengal> DLeo: No, but you should use 'ghc-pkg hide' anyway, in case some libraries require the one you don't want
11:24:32 <dcoutts> DLeo: that doesn't uninstall obviously, just resolve the ambiguity
11:24:42 <DLeo> dcoutts, Berengal: thanks, that works :)
11:24:47 <Botje> ooh
11:24:51 <lilac> Meady: [x | x <- [1..999], x `mod` 3 == 0] means "The list of values x, where x is taken from 1..999, and x `mod` 3 == 0"
11:24:53 <Botje> ubuntu karmic has ghc 6.10
11:25:09 <Meady> yeah so wouldnt || simply add an or condition
11:25:17 <LeCamarade> Cale, Many thanks. :o)
11:25:20 <Meady> so process the number aslong as x = this or x = this
11:25:25 <Berengal> Botje: 6.12 will probably be right around the corner by then anyway, and the story continues...
11:25:39 <lilac> Meady: yep, that'd work fine. but you need `` not '' for the second `mod` too
11:25:47 <Berengal> Meady: Your use of || is correct, but you're still using single quote, not backtick
11:25:50 <Berengal> ` vs '
11:25:57 <zebrafinch> Meady: "x `mod` 3" is the same thing as "mod x 3" if you prefer the prefix notation without backticks
11:26:07 <Meady> > [x|x <- [1..999], x `mod` 3 == 0 || x `mod` 5 == 0]
11:26:09 <lambdabot>   [3,5,6,9,10,12,15,18,20,21,24,25,27,30,33,35,36,39,40,42,45,48,50,51,54,55,...
11:26:15 <Meady> sorry didnt realise i was doing that
11:26:24 <Meady> right ok, now i can use . to feed that to another function?
11:26:34 <Meady> > sum . [x|x <- [1..999], x `mod` 3 == 0 || x `mod` 5 == 0]
11:26:36 <lambdabot>   Couldn't match expected type `a -> [a1]'
11:26:39 <Meady> hmm
11:26:44 <DLeo> no need for . here
11:26:46 <Berengal> Meady: No, a list is a value. (.) only works for functions
11:26:52 <Meady> > sum [x|x <- [1..999], x `mod` 3 == 0 || x `mod` 5 == 0]
11:26:54 <lambdabot>   233168
11:27:01 <Berengal> \o/ yay!
11:27:08 <Meady> lol next one gogogo
11:27:13 <Meady> MEADY HAS HIGH MORALE!
11:27:27 <lilac> project euler?
11:27:33 <Berengal> Meady: Do you know of the fibonacci sequence?
11:27:42 <copumpkin> onoes, not the fibonacci sequence!!!
11:28:04 <Meady> yea berengal but ide prefer to do something else, spent to much time doing that in C
11:28:17 <Meady> at uni
11:28:29 <PeakerWork> @type \x -> [x | x]
11:28:30 <lambdabot> Bool -> [Bool]
11:29:00 <Berengal> Meady: Heh, well, the fib sequence in haskell is rather different from doing it in c
11:29:00 <copumpkin> Meady: but you should try it in haskell, it can be very illuminating
11:29:27 <Berengal> Next challenge, the sum of all even fibonacci numbers below 4 million
11:29:33 <Meady> i will do at some point i promise ahaha, give me something else for now tho please!:P
11:29:47 <copumpkin> fib n = if n == 0 then 0 else if n == 1 then 1 else fib (n - 1) + fib (n - 2) -- the c-like and ugliest possible way to do it
11:30:35 <Berengal> Meady: sum of all primes below 2*10^6?
11:30:44 <Meady> ok wicked
11:30:49 <Meady> on it boss
11:31:25 <Meady> lol copumpkin indeed
11:34:34 <Meady> ok wont calculating prime numbers that high take a while in haskell
11:34:48 <jmcarthur_work> not with a decent algorithm
11:34:50 <Axman6> nope
11:35:00 <lilac> @hoogle [a] -> Maybe (a, [a])
11:35:01 <lambdabot> Language.Haskell.TH.Ppr split :: Type -> (Type, [Type])
11:35:01 <lambdabot> Data.Generics.Twins gmapAccumQ :: Data d => (a -> d -> (a, q)) -> a -> d -> (a, [q])
11:35:01 <lambdabot> Data.List mapAccumL :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
11:35:02 <jmcarthur_work> doing it naively in any language would take a while
11:37:04 <Toxaris> copumpkin: why would you calculuate fib with recursion in C?
11:37:15 <Meady> Less code
11:37:17 <copumpkin> Toxaris: I wouldn't :P
11:37:21 <Meady> :p
11:37:35 <Toxaris> > let fib = fib' 1 1 where fib' x y z = if z == 0 then y else fib' (x + y) x (z - 1) in fib 7 -- one loop, somewhat C-like
11:37:37 <copumpkin> Toxaris: the c point was more about the ifs than the algorithm (which is bad anywhere, obviously)
11:37:37 <lambdabot>   21
11:37:47 * Berengal would probably use manual thunking in C... he has become too used to lazyness
11:38:26 <Berengal> Meady: My machine finds the answer in 1.3 seconds, and that's without compiling
11:40:33 <Axman6> > let fib = fib' 1 1 where fib' x y z = if z == 0 then y else fib' (x + y) x (z - 1) in fib 70
11:40:34 <lambdabot>   308061521170129
11:40:37 <Axman6> > let fib = fib' 1 1 where fib' x y z = if z == 0 then y else fib' (x + y) x (z - 1) in fib 700
11:40:38 <lambdabot>   141530751622060734789349637541611806906560581814825656065057782655897254318...
11:40:42 <Axman6> > let fib = fib' 1 1 where fib' x y z = if z == 0 then y else fib' (x + y) x (z - 1) in fib 7000
11:40:44 <lambdabot>   592904010416831024406728298679136556671772842955708564823985614978998210087...
11:40:48 <Axman6> > let fib = fib' 1 1 where fib' x y z = if z == 0 then y else fib' (x + y) x (z - 1) in fib 70000
11:40:51 <lambdabot>   987006781441921915338799646018754391046420526430223034927999846838696746574...
11:41:02 <Axman6> impressive (though not surprising really)
11:41:23 <Meady> ok calculating prime numbers noiw
11:41:36 <roconnor> It really seems like my VM is 4x slower in GHC 6.10 than 6.8.
11:41:44 <roconnor> Its a bit hard to control for variables
11:41:47 <roconnor> but still
11:42:04 <Meady> i need a way to do, 10 / [10..1]
11:42:06 <Meady> that possible
11:42:07 <Axman6> roconnor: odd, basically everything i've used has been faster in 6.10
11:42:11 <Meady> say i wanted to check if 10 was
11:42:32 <dmwit> > map (10/) [10,9..1]
11:42:34 <lambdabot>   [1.0,1.1111111111111112,1.25,1.4285714285714286,1.6666666666666667,2.0,2.5,...
11:42:37 <Axman6> if 10 eas what...
11:42:40 <Axman6> was*
11:42:45 <Meady> im testing if 10 is a prime
11:42:49 <Meady> ofc it isnt
11:42:51 <PeakerWork> > map (10%) [10,9..1]
11:42:52 <lambdabot>   [1 % 1,10 % 9,5 % 4,10 % 7,5 % 3,2 % 1,5 % 2,10 % 3,5 % 1,10 % 1]
11:43:00 <dmwit> > map (10 `mod`) [10,9..1]
11:43:02 <lambdabot>   [0,1,2,3,4,0,2,1,0,0]
11:43:10 <roconnor> Axman6: I don't get why it would slow down
11:43:26 <Axman6> roconnor: me either :)
11:43:27 <roconnor> Axman6: the shifts are even being inlined now :)
11:43:44 <Axman6> there's shifts there? o.o
11:44:07 <PeakerWork> I really like Rational. I don't use it much, but I really like it still :-)
11:44:18 <roconnor> Axman6: ?
11:44:39 <Axman6> ohh, right. forgot what was happening :P
11:44:52 <Axman6> about to go to sleep, almost 5AM
11:44:52 <roconnor> Axman6: my code does right shifts on Word32s
11:45:03 <roconnor> go to sleep
11:45:03 <PeakerWork> Rational could be represented with a map of how many times each prime appears in the fraction, with negative amount for denominator. That could make some operations pretty quick
11:45:11 <roconnor> Axman6: fix my GHC 6.10 in the morning
11:45:24 <lilac> > sum$nubBy(((0==).).mod)[2..2000000]
11:45:30 <lambdabot>   mueval-core: Prelude.read: no parse
11:45:30 <lambdabot>  mueval: ExitFailure 1
11:45:31 <Axman6> it is morning!
11:45:40 <Axman6>  won't be up until the afternoon :P
11:46:35 <tibbe> does anyone have tips how to manage to get hacking done while having a fulltime job?
11:46:55 <tibbe> i planned to hack some today but I'm to tired as usual
11:47:16 <Meady> oo i has idea
11:47:25 <Axman6> tibbe: enjoy it soo much you don't notice how tired you are!
11:47:29 <lilac> tibbe: i guess the recipe is lots of motivation and no distractions
11:48:18 <lilac> tibbe: i find when hacking on my own time, it's more important to feel like i'm making progress than to polish things
11:48:27 <tibbe> Axman6: unfortunate the brain I was  born with comes with limitations :(
11:48:29 <kniu> I just got a crazy idea.
11:48:43 <Axman6> upgrade :)
11:48:43 <tibbe> lilac: that
11:48:52 <kniu> what if you can pattern match the constructors themselves?
11:48:58 <tibbe> lilac: that's true. i've been too much of a perfectionist of late
11:48:59 <Meady> tibbe install update
11:49:05 <tibbe> Meady: heh
11:49:06 <Meady> apt-get install upgrade
11:49:13 <kniu> I mean, instead of writing (F x y) = z,
11:49:17 <Meady> any arch fans here?
11:49:22 <tibbe> work is stealing my premium hacking time
11:49:28 <Axman6> i use arch on my thinkpad
11:49:31 <kniu> have something like (f x y) = z, where f is bound to the constructor used to make z.
11:49:33 <Meady> nice
11:49:40 <kniu> I'm using arch right now.
11:49:45 <georgehorse> Installing arch now on my desktop.
11:49:53 <kniu> Question is, is that going to screw with the type system?
11:49:57 <georgehorse> Or rather, intalling things on arch.
11:49:59 <Meady> yeah i was on it a short while ago just testing latest release out
11:50:02 * jmcarthur_work uses arch on two thinkpads
11:50:08 <Meady> pacmans still a pain when it crashes
11:50:16 <jmcarthur_work> pacman crashes?
11:50:19 <Axman6> Meady: Arch is the distro to use if you want to use haskell. Dons has done a great job making sure somethig like 900 hackage packages work on arch (the rest are windows only i believe)
11:50:46 <Meady> hmm, well im switching back to it in the next few days, KDE_MOD!
11:50:48 <kniu> he doesn't do that manually, does he?
11:50:48 <lilac> kniu: what would happen if different constructors took different numbers or types of parameters?
11:51:02 <jmcarthur_work> kniu, he has a script
11:51:13 <kniu> lilac, in that case
11:51:29 <jeffersonheard> trying to implement the OGC Simple Feature spec exactly, and I'm running into a curious Parsec question
11:51:34 <Michitux> hi
11:51:36 <kniu> say z = (F foo bar); (f x) = z;
11:51:36 <jeffersonheard> I have this: point = Point <$> (string "POINT" *> between (char '(') (char ')') a_pair)
11:51:37 <Berengal> Hmm, I really should be going back to arch... Checking out ubuntu/gnome has gone on for long enough
11:51:41 <tct13> hello
11:51:42 <kniu> f would just be (F foo)
11:51:50 <jeffersonheard> which gives me a (Point (Double,Double))
11:52:03 <jeffersonheard> but what I need is a (Point (Maybe (Double,Double)))
11:52:10 <tct13> i'm trying to compile geordi eval boot and I get this error:
11:52:12 <kniu> if there aren't enough arguments to bind, then the pattern fails.
11:52:16 <tct13> Util.hs:61:79: Not in scope: `GHC.Read.readEither'
11:52:23 <kniu> Would that make sense?
11:52:26 <tct13> anyone has any idea?
11:52:39 <jeffersonheard> can anyone tell me how I'd modify that line to get a Nothing if there's no parentheses?
11:52:44 <Axman6> tct13: it's probably just read now, sounds like an old function name to me
11:52:48 <Berengal> jeffersonheard: (<|>)
11:53:00 <Meady> ok first failed attemp but making progress
11:53:00 <Meady> myPr n = [x| x <- [2..n-1] , n `mod` x > 0]
11:53:10 <Michitux> I'ld like to learn haskell and as a first step i want to get some good resource (possibly a book) for doing that, which book is recommended for doing that? the one that is mentioned in the topic?
11:53:18 <jeffersonheard> Berengal: yes, but where does it go?
11:53:25 <tct13> Axman6: can I replace it with a newer function?
11:53:32 <lilac> kniu: what would happen if i had "foo :: Maybe a -> Maybe (); foo (c a) = c ()" and tried 'foo Nothing'?
11:53:33 <Axman6> should be able to yes
11:53:39 <kniu> Michitux, everybody seems to go gaga for Real World Haskell.
11:53:44 <Berengal> between (char '(') (char ')') a_pair <|> pure Nothing
11:53:45 <Axman6> if i'm right that is ;)
11:53:47 <tct13> Axman6: the code is: Util.hs:61:79: Not in scope: `GHC.Read.readEither'
11:53:53 <tct13> sorry
11:53:58 <Berengal> *Just <$> between[...]
11:54:06 <copumpkin> lady gaga? :o
11:54:09 <tct13> GHC.Read.readEither . readFile f
11:54:14 <Meady> what is not equal to lol != doesnt give me much
11:54:15 <jeffersonheard> right
11:54:15 <Axman6> tct13: edit the file and replace readEither with read
11:54:16 <jeffersonheard> thanks
11:54:18 <jeffersonheard> that makes sense
11:54:25 <tct13> Axman6: ok
11:54:33 <jmcarthur_work> Meady, /=
11:54:33 <Axman6> and then let me know if that works
11:54:35 <kniu> lilac, the pattern fails?
11:54:44 <lilac> kniu: would you allow: "foo :: Either Int String -> Either () (); foo (c a) = c ()" (where a is either Int or String, and the compiler doesn't know which)?
11:54:48 <Axman6> wait up... tct13 how old is this package?
11:54:53 <Berengal> There might be some maybeParse HOF somewhere, but I don't know about it...
11:54:53 <tct13> Axman6: Util.hs:61:79: Not in scope: `GHC.Read.read'
11:54:59 <jmcarthur_work> Meady, meant to look like that equals sign with the line through it, best approximation we can get with ascii art ;)
11:55:07 <Axman6> get rid of the GHC.Read.
11:55:09 <tct13> Axman6: i use ghc6.10.3
11:55:13 <Berengal> Haskell + ascii art = True
11:55:15 <tct13> on fedora
11:55:17 <tct13> 11
11:55:19 <Axman6> tct13: no, the thing you're trying to compile
11:55:36 <lilac> Berengal: not in scope: data constructor `Haskell'
11:55:55 <kniu> lilac, in that case, I'd presume the compiler would just pass the constructor through unchanged.
11:55:55 <tct13> Axman6: http://www.xs4all.nl/~weegen/eelis/geordi/
11:56:01 <georgehorse> Not haskell related, but what is the KDE counterpart to Evince?
11:56:14 <kniu> lilac, hold on, I get what you're saying.
11:56:25 <Axman6> tct13: i have a feeling that the probram may be too old to work without a lot of modefications...
11:57:19 <jmcarthur_work> Meady, we also have this, though, for those who like unicode http://hackage.haskell.org/packages/archive/unicode-prelude/0.1.1/doc/html/Prelude-Unicode.html
11:57:27 <tct13> Axman6: ok, probably I need a package from 6.8 dev branch
11:57:28 <Axman6> tct13: it's using continuation based IO (i think), which is _really_ old
11:57:32 <lilac> kniu: i don't think it's impossible; it could expand to "foo x = case x of Left a -> Left (); Right a -> Right ()" but it could lead to quite a lot of code being generated
11:57:45 <Axman6> tct13: more like ghc 6.6 or even 6.4
11:57:49 <tct13> Axman6: I'll try to find ghc6.8.3 for fedora
11:58:00 <copumpkin> lol
11:58:01 <copumpkin> (∅) :: [a]
11:58:02 <Axman6> tct13: it's older than that
11:58:04 <copumpkin> might be pushing it
11:58:12 <lilac> kniu: but i've avoided the a-has-two-different-types problem by cloning the body
11:58:21 <tct13> Axman6: in the README the author says: GHC ≥ 6.8 for x86-64, but ≥ 6.8.3 for i386 (because of a vicious bug).
11:58:25 <jmcarthur_work> copumpkin, yeah, a few of them are pushing it, for sure
11:58:33 <Axman6> huh, i see
11:58:36 <Axman6> maybe it will work
11:58:37 <kniu> hm.
11:58:44 <tct13> Axman6: hmmm
11:58:47 <jmcarthur_work> (∈) :: Eq a => a -> [a] -> Bool ; (⊥) :: a -- i think are pushing it, too
11:58:48 <tct13> nope
11:58:59 <Meady> myPr n = [x| x <- [2..n-1], x `mod` n /= 0]
11:59:06 <Axman6> i'd love to help more, but i need to sleep. night all
11:59:08 <lilac> jmcarthur_work: pushing it into the land of unicode awesome
11:59:13 <tct13> Axman6: Util.hs:43:12: Ambiguous type variable `e' in the constraint: `GHC.Exception.Exception e'
11:59:16 <Meady> night askman
11:59:20 <copumpkin> jmcarthur_work: yeah, I'd reserve the first one for sets, but the latter works for me
11:59:22 <tct13> yep, sleep well Axman6
11:59:31 <jmcarthur_work> lilac, i prefer agda's way of allowing arbitrary identifiers for things like this
11:59:34 <Axman6> (it's just on 5AM here...)
11:59:38 <Berengal> You can never have enough funny symbols...
11:59:41 <jmcarthur_work> copumpkin, i think for _|_ i just don't like the mandatory parens
11:59:49 <copumpkin> oh, true
12:00:01 <copumpkin> forgot that would be necessary
12:00:04 <lilac> jmcarthur_work: makes it look more like a bottom ;-)
12:00:09 <jmcarthur_work> haha
12:00:15 <Axman6> heh
12:00:38 <jmcarthur_work> (_)(_)
12:00:43 <Meady> > 9 `mod` 10 /= 0
12:00:45 <lambdabot>   True
12:03:42 <Nafai> So did anyone do ICFP?  How'd it go?
12:04:43 <Meady> Off topic : Gf is making weirdest meal ever, sausages chopped, beans, bolognase sauce, rice, onion
12:04:44 <Meady> ;s
12:05:13 <Meady> is it possible in a set to break when the first result is not true
12:05:47 <Berengal> Meady: all . map not
12:05:50 <Meady> myPr n = [x| x <- [2..n-1], x `mod` n /= 0]
12:05:59 <Berengal> No, just all
12:06:00 <Berengal> Sorry...
12:06:04 <Meady> the first time x isnt output because the condition wasntt try i want it to break
12:06:33 <copumpkin> all . map not === not any  isn't it?
12:06:52 <Meady> else this prime method will be quit enneficient
12:07:09 <SamB> :t not any
12:07:11 <lambdabot>     Couldn't match expected type `Bool'
12:07:11 <lambdabot>            against inferred type `(a -> Bool) -> [a] -> Bool'
12:07:11 <lambdabot>     In the first argument of `not', namely `any'
12:07:15 <copumpkin> you know what I mean :P
12:07:20 <Berengal> not . any
12:07:24 <jmcarthur_work> @check \xs -> (all . map not) xs == (not . any) (xs :: [Int])
12:07:25 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
12:07:27 <SamB> :t not . any
12:07:28 <lambdabot>     Couldn't match expected type `Bool'
12:07:28 <lambdabot>            against inferred type `[a] -> Bool'
12:07:28 <lambdabot>     In the second argument of `(.)', namely `any'
12:07:31 <olsner> :t not . any ?f
12:07:32 <copumpkin> it needs a function
12:07:32 <lambdabot> forall a. (?f::a -> Bool) => [a] -> Bool
12:07:40 <jmcarthur_work> duh
12:07:44 <Berengal> (not.) needs its own function...
12:07:47 <copumpkin> there's the and function that doesn't have a function
12:07:53 <jmcarthur_work> well, i hate trying to get functions in quickcheck :\
12:08:03 <SamB> :t not ((.).) any
12:08:04 <jmcarthur_work> i always have to look up what i did the last time
12:08:05 <lambdabot>     Couldn't match expected type `Bool'
12:08:05 <lambdabot>            against inferred type `(a -> b -> c) -> a -> (a1 -> b) -> a1 -> c'
12:08:05 <lambdabot>     In the first argument of `not', namely `((.) .)'
12:08:13 <SamB> aww.
12:08:23 <olsner> :t all . (not.)
12:08:24 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
12:08:35 <Meady> ill make it a recursive function conditional then
12:08:38 <Berengal> Meady: No, you can't stop the list comprehension then, but you could do it from outside
12:08:39 <Meady> so it breaks when i want it to
12:09:29 <Berengal> Not in an aesthetic way though..
12:09:35 <copumpkin> lol @ BONUS' weird tweets
12:09:40 <Associat0r> FYI #proglangdesign #ltu ##concurrency
12:10:02 <Meady> Berengal, what about a recursive function for calculating prime, by diving n by n-1 n-2 b-3 etc till it returns mod
12:10:08 <Meady> then stop cause its not a prime
12:10:25 <copumpkin> that'll be taken care of by a sufficiently lazy function outside
12:10:35 <Berengal> Meady: Sure, recursion can work, but beware too much thunking
12:10:37 <copumpkin> and / or for example
12:10:51 <copumpkin> > and [True, False, undefined]
12:10:53 <lambdabot>   False
12:11:00 <Meady> whats thunking
12:11:01 <copumpkin> > or [True, False, undefined]
12:11:03 <lambdabot>   True
12:11:34 <Berengal> Meady: Excessive thunking is the only cause of stack overflows. In general, thunking is delaying computations until they're needed
12:11:35 <|Jedai|> Meady: it's the act of building a thunk
12:11:46 <Meady> ok
12:11:47 <Meady> lol
12:11:51 <|Jedai|> Meady: a thunk is a computation not yet evaluated
12:12:16 * Berengal loves thunks a bit too much, and often writes them manually in other languages
12:12:23 <jmcarthur_work> > foldl (+) 0 [0..999999999999]
12:12:32 <lambdabot>   mueval-core: Prelude.read: no parse
12:12:33 <lambdabot>  mueval: ExitFailure 1
12:12:39 <Berengal> > foldl (+) 0 [1..1000000]
12:12:43 <lambdabot>   * Exception: stack overflow
12:12:47 <|Jedai|> Meady: so you have excessive thunking when you build an huge thunk
12:13:02 <jmcarthur_work> that's what i was going for, but i don't know why that didn't happen to me
12:13:17 <lpsmith> > Data.List.foldl' (+) 0 [1..1000000]
12:13:19 <lambdabot>   500000500000
12:13:31 <copumpkin> don't overthunk your problem
12:13:35 <|Jedai|> Meady: Like those gentlemen said, foldl (+) 0 is a basic exemple of excessive thunking
12:13:42 <Berengal> jmcarthur_work: Annecdotal evidence tells me lambdabod gives a parse error when out of memory or time or something like that...
12:14:01 <olsner> or rather, an excessive amount of small thunks (unless the problem is the amount of lexical state the thunk needs to bring with it - in which case I guess the thunk actually would become huge)
12:14:03 <Berengal> I can't deduce the exact conditions
12:14:07 <jmcarthur_work> Berengal, yeah, but i wonder why i would have gotten that instead of the stack overflow message like you got
12:14:13 <jmcarthur_work> Berengal, i think it's time, not memory, btw
12:14:28 <Berengal> jmcarthur_work: Well, sometimes I get it immediately for some expressions
12:14:35 <jmcarthur_work> > sum [0..]
12:14:41 <lambdabot>   mueval-core: Prelude.read: no parse
12:14:41 <lambdabot>  mueval: ExitFailure 1
12:14:42 <olsner> (for context, my previous comment was a comment to Jedai's "when you build a huge thunk" btw)
12:14:48 <stroan_> Berengal: was it you who told me to write a parser in haskell a while back to learn monads?
12:15:13 <Berengal> stroan_: Possibly. I have said that a couple of times at least
12:15:43 <stroan_> Ah kay. Well just to let you know that I just finished an interpreter for a small functional language based off that recommendation :)
12:15:53 <Berengal> stroan_: Did you learn monads? :P
12:16:02 <stroan_> Yup. Monadic parser at the bottom
12:16:13 * Berengal has gained a skill: Pedagogy + 1
12:16:28 <Berengal> :)
12:16:33 <olsner> stroan_ has gained a skill: Haskell + 1
12:16:34 <olsner> :)
12:16:37 <stroan_> :)
12:16:45 <Berengal> @botsnack
12:16:46 <lambdabot> :)
12:16:46 <lunabot>  :)
12:17:09 <jmcarthur_work> @botsmack
12:17:10 <lambdabot> :)
12:17:10 <lunabot>  :)
12:17:33 * Berengal loves the smell of fresh teachings in the morning
12:17:34 <copumpkin> don't use monadic parsers if you can write applicative ones!
12:17:35 <copumpkin> :P
12:18:00 * stroan_ tears it all up and starts over :P
12:22:24 <Berengal> Monads might not be the best choice for writing parsers, but parsers are a great choice for learning monads
12:24:04 <dancor> when i had to add whitespace-preserving/absorbing to my parser, i had to make it all non-applicative
12:24:23 <dancor> (wsBeforeSomething, something) <- wsSomethingParser
12:24:34 <dancor> that's my story
12:25:12 <Berengal> (,) <$> whitespace <*> something
12:25:55 <Berengal> Don't know your specs though...
12:26:11 <olsner> @pl \f g x y -> f (g x y)
12:26:12 <lambdabot> (.) . (.)
12:26:23 <olsner> as I thought, the boobies combinator
12:26:37 <Berengal> Strictly speaking, you only need a monad parser if you're generating new parsers based on previous results...
12:29:06 <Meady> i love ARP'ing xD
12:29:43 <copumpkin> I thought there was a pretty direct relationship between applicative parsers and context-free grammars, and monadic with context-sensitive (mildly?)
12:30:19 <olsner> is there any difference in power between applicative and monadic?
12:30:36 <copumpkin> hm?
12:30:38 <Berengal> copumpkin: Intuitively that feels right. I've got no proof though
12:30:44 <Berengal> olsner: Yes, applicatives can't join
12:30:53 <olsner> ah, okay
12:31:18 <copumpkin> Berengal: it seems that the context-sensitivity would come from the join, where as you said you can generate a new parser based on parsed input (say a length field) and then "flatten" it into your main parser
12:31:27 <olsner> I hadn't heard of applicative parsers before, is there a description of them somewhere?
12:31:28 <copumpkin> but that's so hand-wavey it makes me a little queasy :P
12:31:53 <Berengal> copumpkin: Yeah, that's the intuition I get too.
12:32:17 <Berengal> olsner: Do you use <*> etc. when writing your parsers, or do you use monad syntax?
12:34:12 * copumpkin tends to use the least of Functor/Applicative/Monad he can get away with
12:34:24 <copumpkin> of course, if they were superclasses of one another I wouldn't need to do that
12:39:08 <deech> Hi all, I am having trouble implementing a Monad instance on a monad transformer stack. The code is at http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6358#a6367 and returns the error: Could not deduce (Error e)  from the context (Monad (BigAssMonad e s), ... I am not sure what this means. Any help is appreciated.
12:40:03 <dmwit> Is this for fun?
12:40:20 <dmwit> If not, why not just derive the appropriate instance?
12:40:48 <deech> dmwit: yes, actually I am trying to understand how the deriving works.
12:40:57 <dmwit> ok
12:41:02 <dmwit> Well, check out your instance constraints.
12:41:10 <dmwit> You use 'm' on the left, but not on the right.
12:41:14 <dmwit> Can you explain why?
12:42:31 <deech> dmwit: because BigAssMonad only takes two arguments.
12:42:54 <deech> Do you mean BigAssMonad (e m) (s m)?
12:43:01 <dmwit> deech: I'm trying to give you a hint.
12:43:06 <dmwit> What are your constraints really saying?
12:43:10 <dmwit> What do you want them to say?
12:43:57 <dmwit> (The constraints are saying, well, there's some type constructor 'm' out there that happens to make 'e' a MonadError... but don't bother me about what 'm' it is, I don't really care.  Is that really what you want?)
12:43:59 <deech> dmwit: I want them to say only that 'e' and 's' are ErrorT and StateT respectively.
12:44:16 <dmwit> I don't think that's what you want after all.
12:44:25 <copumpkin> so is haskell-src-exts a replacement for haskell-src ?
12:44:34 <deech> dmwit: Actually I threw the m in there to satisfy the compiler.
12:44:47 <dmwit> I think you specifically want them to be Error-ific and State-erific in the context you're using them in BigAssMonad.
12:45:36 <deech> My original instincts would have been to say (Error e, State s) => ....
12:46:23 <dmwit> (MonadError e m) says, when you're in the monad 'm', you can throw errors of type 'e'.
12:46:41 <dmwit> Similaryl, MonadState s m says, when you're in the monad 'm', you can retrieve (and set) state of type 's'.
12:46:48 <dmwit> Does that help you figure out what context you should be using there?
12:47:47 <deech> Oh so, MonadError e BigAssMonad, because I want errors to be thrown in this monad.
12:51:27 <dmwit> To be honest, I'm not sure you want any MonadError/MonadState context there at all.
12:51:38 <dmwit> Why do you think you want it?
12:51:57 <Zrs> > sort . nub $ "the quick brown fox jumped over the lazy dogs"
12:52:08 <lambdabot>   " abcdefghijklmnopqrstuvwxyz"
12:52:20 <Zrs> That makes me so happy :)
12:52:37 <burp> uh, it's really complete
12:52:39 <copumpkin> > length . sort . nub $ "the quick brown fox jumped over the lazy dogs"
12:52:41 <lambdabot>   27
12:52:45 <burp> :t nub
12:52:46 <lambdabot> forall a. (Eq a) => [a] -> [a]
12:52:52 <burp> @src nub
12:52:53 <copumpkin> I guess I didn't really need sort there :P
12:52:53 <lambdabot> nub = nubBy (==)
12:52:57 <burp> @hoogle nub
12:52:57 <lambdabot> Data.List nub :: Eq a => [a] -> [a]
12:52:58 <lambdabot> Data.List nubBy :: (a -> a -> Bool) -> [a] -> [a]
12:53:08 <dmwit> copumpkin: Oh, but it does.
12:53:09 <Berengal> sort (nub  ("the quick brown fox jumped over the lazy dogs")) \\ ['a'..'z']
12:53:17 <Berengal> > sort (nub  ("the quick brown fox jumped over the lazy dogs")) \\ ['a'..'z']
12:53:19 <lambdabot>   " "
12:53:28 <dmwit> copumpkin: ...never mind, I didn't understand your comment =P
12:53:32 <Zrs> :D And it just gets better!
12:53:32 <jmcarthur_work> > group . sort $ "the quick brown fox jumped over the lazy dogs"
12:53:34 <lambdabot>   ["        ","a","b","c","dd","eeee","f","g","hh","i","j","k","l","m","n","o...
12:53:34 <copumpkin> :)
12:53:36 <salty-horse> cartoon: http://www.simonsingh.net/images/465.jpg
12:53:47 <jmcarthur_work> > map length . group . sort $ "the quick brown fox jumped over the lazy dogs"
12:53:48 <lambdabot>   [8,1,1,1,2,4,1,1,2,1,1,1,1,1,1,4,1,1,2,1,2,2,1,1,1,1,1]
12:53:57 <Berengal> > S.toList . S.fromList $ "the quick brown fox jumped over the lazy dogs"
12:53:58 <lambdabot>   " abcdefghijklmnopqrstuvwxyz"
12:54:19 <jmcarthur_work> > map head . group . sort $ "the quick brown fox jumped over the lazy dogs"
12:54:21 <lambdabot>   " abcdefghijklmnopqrstuvwxyz"
12:54:38 <burp> anyone else? ;)
12:55:07 <Berengal> > const ['a'..'z'] "the quick brown fox jumped over the lazy dogs"
12:55:08 <lambdabot>   "abcdefghijklmnopqrstuvwxyz"
12:55:23 <dmwit> > let hasAll = (['a'..'z'] `isInfixOf`) . S.toList . S.fromList . map toLower in "The quick brown fox jumped over the lazy dogs."
12:55:24 <lambdabot>   "The quick brown fox jumped over the lazy dogs."
12:55:30 <dmwit> dur
12:55:36 <dmwit> > let hasAll = (['a'..'z'] `isInfixOf`) . S.toList . S.fromList . map toLower in hasAll "The quick brown fox jumped over the lazy dogs."
12:55:37 <lambdabot>   True
12:56:02 <Meady> how to i have a function with different amounts of arguments
12:56:06 <Meady> myPr x = myPr x (x-1)
12:56:06 <Meady> myPr x 1 = putStr "Prime Found!\n\n"
12:56:06 <Meady> myPr x y = if x `mod` y /= 0
12:56:06 <Meady> 			then myPr x (y-1)
12:56:06 <Meady> 			else putStr "Found break!\n\n"
12:56:19 <deech> dmwit: I just added 'instance (Error e) => Monad BigAssMonad (e s) ..." and the compiler accepted it. I don't know why.
12:56:22 <Berengal> Meady: You can't, all functions have to have the same number of arguments
12:56:29 <dmwit> deech: Yup, that looks a lot more sane.
12:56:35 <Berengal> Meady: The solution is to create two functions...
12:56:46 <dmwit> deech: After all, you're not using the error or state stuff in your definition of the monad functions.
12:56:49 <deech> dmwit: I don't think I had the FlexibleInstances pragma in there earlier.
12:57:07 <dmwit> deech: You don't need FlexibleInstances.
12:57:30 <jmcarthur_work> Meady, you can probably do it, but it requires at least 1 Oleg of brainpower
12:57:42 <Meady> ok ill just use 2
12:57:55 <Meady> myPrime x = myPr x (x-1)
12:57:56 <Meady> myPr x 1 = putStr "Prime Found!\n\n"
12:57:56 <Meady> myPr x y = if x `mod` y /= 0
12:57:56 <Meady> 			then myPr x (y-1)
12:57:56 <Meady> 			else putStr "Found break!\n\n"
12:57:57 <Berengal> Meady: You seem to not know how much an Oleg really is
12:57:59 <dmwit> Meady: Also, FYI, we prefer longer code segments be pasted to hpaste.
12:58:06 <Berengal> Oh, two functions...
12:58:09 <Berengal> @paste
12:58:09 <lambdabot> Haskell pastebin: http://hpaste.org/new
12:58:18 <Meady> So myPrime now calculates prime nummbers xD
12:58:38 <deech> dmwit: Why does it complain about Error e and not the State part of my monad?
12:58:46 <Berengal> Meady: Well, not exactly. It also prints them
12:59:08 <dmwit> deech: (ErrorT e) is only a Monad instance if e is an Error instance.
12:59:23 <dmwit> deech: (StateT s) does not require anything of s for it to be a Monad
12:59:56 <deech> dmwit: I get it now! I originally had (Error e, State s) => ...
13:00:19 <dmwit> But there is no State class. =P
13:00:54 <deech> dmwit: Yes that was the error I was getting. Wow, I see things a lot clearer now!
13:01:31 <dmwit> deech: Now, you should try to write your MonadState and MonadError instances for BAM. =)
13:01:41 <deech> dmwit: I'm on it!
13:01:53 <Orphi> @seen dcoutts
13:01:54 <lambdabot> dcoutts is in #darcs, #gentoo-haskell, #ghc, #haskell, #haskell-in-depth, #haskell-overflow, #haskell-soc and #haskell-iphone. I last heard dcoutts speak 1h 37m 21s ago.
13:02:20 <dcoutts> @yarr!
13:02:21 <lambdabot> Arrr!
13:02:34 <Orphi> heh, I thought hell had frozen over... Hi Duncan. ;)
13:02:40 <dcoutts> hia
13:03:06 <Orphi> so I have a package that really doesn't care what the hell version of base you have... but HackageDB demands version bounds...
13:03:47 <dcoutts> Orphi: if you use base you almost certainly care what version it is. A reasonable default is < 5
13:04:05 <Orphi> It only uses Eq, Ord, Num, etc.
13:04:14 <Orphi> doesn't even use integers.
13:04:21 <dcoutts> Orphi: then perhaps you'd prefer to depend on H98
13:04:29 <Orphi> oh, is that different?
13:04:35 <dcoutts> from base, yes.
13:04:41 <olsner> Berengal: I might have, but I've only used <*> as infix-ap and <$> as infix-fmap in a monadic parser
13:04:47 <dcoutts> it's much smaller, and by definition it's stable
13:04:47 <Orphi> ok... so which version? :-}
13:05:18 <dcoutts> Orphi: there is only 1.0.x
13:05:19 <olsner> (and a lot of do-notation when it seemed convenient)
13:05:40 <Orphi> ok... so Build-Depends: haskell98 >= 1?
13:06:01 <DaveS> What is the difference between a functional language and a declarative language?
13:06:18 <Beelsebob> a functional language *is* a declarative language
13:06:19 <dcoutts> Orphi: honestly, you can just omit the version for h98
13:06:28 <Beelsebob> not all declarative languages are functional though
13:06:33 <DaveS> Beelsebob: A purely functional language..
13:06:34 <DaveS> right?
13:06:35 <Orphi> dcoutts: wilco.
13:06:36 <Beelsebob> yep
13:06:42 <DaveS> k
13:06:50 <Beelsebob> a declarative language is any one where you specify the program simply by writing down facts
13:06:58 <Beelsebob> functional languages constrain the form of the facts
13:07:03 <Orphi> dcoutts: Also... what's the right format for Tested-With?
13:07:21 <dcoutts> Orphi: oh, hmm, that might not work actually since the haskell98 package does not export a Prelude module
13:07:29 <dcoutts> which is a bit odd really
13:07:37 <Beelsebob> so that unification is never necessary
13:07:45 <Orphi> dcoutts: WTF-O-Meter: 6.5
13:07:54 <dcoutts> Orphi: yeah :-)
13:07:57 <dcoutts> Orphi: GHC == 6.10.3
13:08:13 * Orphi adds GHC 6.10.3 to Cabal description...
13:08:49 <Orphi> dcoutts: How do I "test" whether a Cabal description works? Just ask it to build the thing and see if it does?
13:09:09 <dcoutts> Orphi: yep, also use 'cabal check'
13:09:26 <Orphi> dcoutts: Assuming you have cabal-install in the first place...
13:09:45 <dcoutts> Orphi: and if you don't you should :-)
13:09:48 <Orphi> dcoutts: Oh, BTW, did you see? cabal sdist appears to be broken on Windows. :(
13:10:11 <dcoutts> Orphi: do you mean runghc Setup.hs sdist? or actually cabal sdist ?
13:10:29 <Orphi> dcoutts: runhaskell Setup sdist fails because there is no tar.
13:10:39 <Orphi> dcoutts: cabal sdist dies with a file permission error.
13:10:43 <athos> curl-1.3.5 failed during the configure step. The exception was:
13:10:43 <athos> exit: ExitFailure 1
13:10:47 <athos> what the heck?
13:10:52 <athos> (i tried cabal install twitter)
13:11:03 <dcoutts> Orphi: ok, I'm interested in the latter since that should work.
13:11:22 <athos> ah
13:11:22 <athos> ok
13:11:25 <athos> i get it, nevermind :)
13:11:26 <dcoutts> Orphi: cabal sdist does not depend on an external tar program, which is the solution for Windows users.
13:11:32 <Orphi> dcoutts: I've been discussing it on cafe; I still think the fact that the former doesn't work should be documented more loudly.
13:12:18 <Orphi> dcoutts: It seems cabal *does* create the tarball, and dies afterwards trying to delete a temp file or something...
13:12:24 <dcoutts> Orphi: you mean it should say "use cabal.exe instead"
13:12:47 <Orphi> dcoutts: Right, yeah. (Or "especially if you're on Windows"...)
13:13:00 <dcoutts> Orphi: ok, please file a ticket with all the details http://hackage.haskell.org/trac/hackage/
13:13:17 <Orphi> dcoutts: Also... I downloaded the sources for cabal-install before realising that there's a prebuild binary. Maybe mention this sooner?
13:13:25 <dcoutts> Orphi: and a separate one about sdist if you like
13:13:34 <dcoutts> Orphi: where were you looking?
13:14:04 <Orphi> dcoutts: I simply did a Google for "cabal-install"; took be to the Cabal manual page, and then to HackageDB to download it.
13:14:10 <jeffersonheard> most sensible way to nest a function in multiple layers of applicative? as in I have a list of lists of lists and I want to apply a function to all the elements at the lowest level of the list
13:14:18 <Orphi> the Hackage page doesn't mention a binary; the README file inside does
13:14:42 <jeffersonheard> my solution which looks rather ugly is (map (map (map f))) ls
13:14:46 <athos> noh, actually i dont get it.
13:15:00 <athos> configure: error: curl libraries not found, so curl package cannot be built
13:15:02 <olsner> hmm, what's the difference between newtype Foo a = Foo { unFoo :: a } compared to defining unFoo (Foo f) = f?
13:15:24 <dcoutts> Orphi: ok, fixed the download url
13:15:36 <bd_> olsner: the former also lets you do: doFoo x = Foo { unFoo = x }
13:15:41 <athos> i definentyl have libcurl
13:16:06 <bd_> olsner: which isn't very useful, so the real reason to do it is just to define unfoo at the same time
13:16:06 <Orphi> dcoutts - fixing stuff in realtime since 2005(tm)
13:16:08 <athos> man, what typo
13:16:24 <dcoutts> Orphi: :-)
13:16:38 <olsner> bd_: yeah, but I wonder why anyone would choose *not* to use the record-syntax shorthand for defining unFoo
13:16:41 <Orphi> dcoutts: Do you have any idea how frustrating Hasklling on Windows can be sometimes?
13:16:50 <Orphi> dcoutts: It's nice to know somebody out there is fixing these things...
13:16:51 <dcoutts> Orphi: yep :-(
13:16:58 <olsner> was record-syntax for newtypes introduced in haskell "recently" or something?
13:17:23 <dcoutts> Orphi: if it makes you feel better, I bought a copy of XP recently to use in a VM to try these things first hand
13:17:43 <dcoutts> olsner: it's in h98 afaik
13:17:44 <Orphi> dcoutts: Heh, that's nice to know... (Hope you have a fast machine to run it tho!)
13:17:52 <Vq^> dcoutts: wow, the ultimate sacrifice
13:18:18 <Orphi> Vq^: The impressive thing is... They don't SELL old XP any more...
13:18:27 <olsner> dcoutts: *bought*? that's heavy
13:18:47 <Vq^> Orphi: there are other people than "They"
13:19:06 <olsner> couldn't you just get hired by MS research or something? :)
13:19:07 <Orphi> Vq^: ooo....
13:19:14 <dcoutts> there are resellers who will still sell XP
13:19:24 <Orphi> dcoutts: While stocks last ;)
13:19:29 <dcoutts> quite
13:19:52 <Orphi> dcoutts: So did sdist ever work on Windows? I mean, after you "fixed" it, I assume you tested, right?
13:20:18 <dcoutts> Orphi: yes it worked when I first implemented it, this the first time I've heard of it not working
13:20:30 <Orphi> dcoutts: Right. So it's broken at some later stage...
13:20:38 <bd_> olsner: record-syntax is sugar :)
13:20:55 * dcoutts wonders how Windows activation copes with the 1000s of XP instances running in identical VMs
13:20:56 <Orphi> dcoutts: Like I said, it *does* produce the tarball; the problem happens afterwards.
13:21:15 <olsner> bd_: yeah, I'm just trying to figure out if there is any significance to this paper using a separate explicit definition of unFoo
13:21:23 <bd_> olsner: probably not :)
13:21:27 * Orphi has a copy of Windows XP which does not *require* activation in the first place. ;)
13:21:29 <dcoutts> Orphi: if you run with -v3, that log would be useful to attach to the ticket you file
13:21:46 <Orphi> dcoutts: Noted. I'll go generate that...
13:21:57 <dcoutts> Orphi: is that a "special" copy ? :-)
13:22:18 <Orphi> dcoutts: My employer has a Microsoft Volume Licence, yes. It's perfectly legal. ;)
13:22:27 <dcoutts> ah right
13:22:28 <Orphi> (Unless I bring it home...)
13:22:38 <olsner> haskell papers are usually packed full of cleverness, how odd to suddenly find some fluff in one
13:22:45 <dmwit> athos: Do you have libcurl-dev?
13:22:51 <dmwit> athos: (i.e. the header files?)
13:23:04 <athos> err, i don't think so.
13:23:08 <athos> guess i need them? :)
13:23:50 <zebrafinch> olsner: well, I sometimes write the unwrapper by hand so the derived Show instance is less verbose, but I don't see why you'd do that in a paper.
13:24:07 <jeffersonheard> :t fmap . fmap
13:24:09 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
13:25:17 <Orphi> hang on, brb...
13:25:22 <olsner> maybe he's trying to keep the number of syntax elements used down a bit (avoiding ever to explain what record syntax is), but he seems to assume familiarity with haskell anyway... I guess it's just a random inconsequential choice :/
13:25:42 * olsner stops trying to find significance in random detail (well, tries at least...)
13:25:53 <Orphi> WTF-O-Meter: 7.1
13:26:23 <Orphi> I tried uploading a file, and Firefox still had the file locked 20 minutes later?
13:26:26 <Orphi> Truly random...
13:27:08 <gwern> @quote conals
13:27:08 <lambdabot> gnuvince says: "Contributions to Hackage are measured in µConals
13:27:27 <gwern> @forget gnuvince "Contributions to Hackage are measured in µConals
13:27:27 <lambdabot> Done.
13:27:32 <gwern> @remember gnuvince Contributions to Hackage are measured in µConals
13:27:33 <lambdabot> I will remember.
13:27:34 <Orphi> dcoutts: Sorry, could you have my that trac URL again plz?
13:27:36 <gwern> @flush
13:27:53 <dcoutts> Orphi: http://hackage.haskell.org/trac/hackage/
13:27:55 <Orphi> ...it finally happened. I talk like a lambdacat o_O
13:27:56 <olsner> said just before someone not conal uploaded hackage package 1001? :)
13:28:03 <ehird> Contributions to type systems are measured in µOlegs.
13:29:07 <Elly> ehird: hah
13:29:21 <olsner> Performance of functional languages is measured in Dons
13:29:26 <ehird> *uDonses.
13:29:32 <ehird> Cocontributions to Haskell are measured in µHarrops.
13:30:17 <olsner> I reckon, Haskell has one Don so far, if we had two Dons it'd be twice as fast
13:30:30 <Orphi> dcoutts: And it was the -v3 switch to sdist you wanted, right?
13:30:49 <dcoutts> Orphi: yep, though perhaps only the last few lines are relevant
13:30:50 <olsner> ehird: +1 clever use of co-
13:30:57 <ehird> olsner: ITYM 'ehird++' :-P
13:31:04 <ehird> does lambdabot still listen to those?
13:31:08 <Orphi> dcoutts: It's only given me a dozen lines or so, I'll just keep the lot.
13:31:13 <olsner> @karma
13:31:14 <lambdabot> You have a karma of 0
13:31:16 <olsner> olsner++
13:31:17 <olsner> @karma
13:31:18 <lambdabot> You have a karma of 0
13:31:24 <ehird> foop olsner++ doop
13:31:26 <ehird> @karma olsner
13:31:26 <lambdabot> olsner has a karma of 1
13:31:43 <olsner> ehird: yes, I think I meant ehird++
13:31:49 <copumpkin> @karma
13:31:50 <lambdabot> You have a karma of 0
13:31:58 <ehird> copumpkinco++
13:32:01 <copumpkin> > text "copumpkin++"
13:32:02 <lambdabot>   copumpkin++
13:32:03 <ehird> ... i guess that's --
13:32:05 <copumpkin> @karma
13:32:06 <lambdabot> You have a karma of 0
13:32:09 <copumpkin> :(
13:32:11 <ehird> lambdabot doesn't read its own messages :p
13:32:15 <copumpkin> , "copumpkin++"
13:32:17 <olsner> cocopumpkin-- == copumpkin++ ?
13:32:17 <lunabot>  "copumpkin++"
13:32:23 <copumpkin> @karma
13:32:24 <lambdabot> You have a karma of 1
13:32:27 <ehird> osfameron: co++
13:32:29 <ehird> = --
13:32:31 <copumpkin> :)
13:32:32 <ehird> @karma
13:32:33 <lambdabot> You have a karma of 1
13:32:41 <ehird> @. karma run text ""
13:32:42 <lambdabot> mueval-core has a karma of 0
13:32:46 <jeffersonheard> hackage never seems to build doc for packages anymore...
13:32:47 <ehird> lol
13:33:31 <byorgey> jeffersonheard: huh?
13:33:33 <Orphi> dcoutts: http://hackage.haskell.org/trac/hackage/ticket/565 submitted.
13:33:42 <byorgey> docs are built for most packages.
13:34:28 <jeffersonheard> I think the level indicated by "most" has gone down recently.  I dunno if it's hackage or if it's that we're mostly using different versions of Haddock than Hackage is
13:34:45 <byorgey> jeffersonheard: what's an example of a package where the documentation isn't built?
13:34:50 <jeffersonheard> attoparsec
13:35:03 <jeffersonheard> last updated Jan 16
13:35:09 <jeffersonheard> other of his packages do have doc
13:35:12 <byorgey> well, that didn't build at all
13:35:17 <byorgey> if you look at the build log
13:35:23 <jeffersonheard> hrm, true
13:35:45 <dcoutts> Orphi: and this happens reliably I suppose? This is happening when it tries to clean up the temp dir, I think it's an instance of a weird windows problem we've got.
13:36:16 <Orphi> dcoutts: Note that if I immediately do cabal clean, it succeeds.
13:36:40 <jeffersonheard> I guess the better thing to do, rather than complain is state that I was after binary serialization / de-serialization that looks more like Parsec than Data.Binary
13:36:48 <Orphi> dcoutts: I can't "see" anything visibly wrong that might be upsetting it, but sdist fails every time, the exact same way.
13:36:48 <dcoutts> Orphi: you mean after running cabal clean, then cabal sdist works?
13:37:05 <Orphi> dcoutts: No, sdist fails, but clean succeeds afterwards.
13:37:07 <byorgey> jeffersonheard: now we're getting somewhere ;-)
13:37:12 <dcoutts> Orphi: oh sure
13:37:24 <dcoutts> Orphi: it's highly timing dependent
13:37:25 <Orphi> dcoutts: So it's not like the files have weird permissions or something.
13:37:40 <dcoutts> Orphi: right, it's that windows thinks some program has the files open
13:38:25 <olsner> it isn't something silly like doing lazy I/O and the handle still being open when cabal attempts to delete the temp file?
13:38:49 <Orphi> olsner: That'd be my bet too...
13:39:11 <dcoutts> olsner: nope, we do not use any unbounded lazy I/O in cabal for exactly that reason
13:39:19 <olsner> d'oh
13:42:31 <kadoban> i am looking for an image processing library, and a search of hackage didn't yield much except for chalkboard (which may work but doesn't seem to handle many image types).  i just need to do fairly simple operations like load an image, crop, rotate, copy regions out to new images, possibly convert to other formats.  does anyone have any library suggestions?
13:43:26 <Orphi> hahahaha...oh GOD! >_<
13:43:34 <dmwit> libGD is pretty simple.
13:43:43 <Orphi> now it turns out you need a user account to upload to Hackage.
13:43:50 <dmwit> Gtk2Hs has some stuff, and hsMagick can do quite a lot indeed.
13:43:51 <Orphi> is anything ELSE going to stand in my way??
13:43:54 <Orphi> a power cut maybe?
13:44:01 * Twey unplugs Orphi
13:44:13 <Orphi> NOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO!! :'(
13:44:15 <jeffersonheard> what format does the Data.Binary instance of Double use?
13:44:16 <olsner> I foresee sudden unrecoverable disk failure
13:44:35 <Orphi> jeffersonheard: You don't even wanna know.
13:44:42 <Twey> It's not IEEE?
13:44:51 <Orphi> Twey: Sadly, no.
13:45:00 <olsner> it's in IEEEvil
13:45:29 <jeffersonheard> is this the infamous mantissa-pair thing?
13:45:29 <Berengal> As a String, conses and all... maybe... probably not...
13:45:30 <Orphi> It converts a Double to a Int exponent and an Integer mantissa (NOT KIDDING) and serialises those.
13:45:47 <jeffersonheard> riiiiight.  this is what my prob was the other day
13:45:52 <olsner> pretty much a Ratio then
13:45:55 <jeffersonheard> Ijust need good old-fashioned IEEE754
13:46:00 <kadoban> thanks, i'll look those up
13:46:05 <jeffersonheard> has anyone written that up?
13:46:12 <Orphi> jeffersonheard: Join the club! I recomment... unsafeCoerce o_O
13:46:17 <olsner> isn't it documented in the binary docs?
13:46:32 <jeffersonheard> olsner, no, it was encode/decodeFloat
13:46:41 <jeffersonheard> and not in the docs
13:46:42 <jeffersonheard> but the source code
13:46:44 <Orphi> if you unsafeCoerce a Double to an Int64, it will then serialise "normally".
13:46:52 <ehird> xD
13:46:54 <jeffersonheard> Orphi: thanks
13:47:20 <Orphi> beware: moving your files between different CPU types may fail catastrophically.... ;)
13:47:31 <jeffersonheard> in whatever byte order it started in, I presume; probably little-endian on most machines
13:47:34 <Orphi> YOU HAVE BEEN WARNED!
13:47:53 <Orphi> yeah, that's why the warning, really.
13:48:08 <jeffersonheard> Orphi: I'm implementing the OGC Simple Feature standard
13:48:20 <jeffersonheard> which encodes the byte order as the first byte of a WKB string
13:48:23 <jeffersonheard> so it should be okay
13:48:46 <jeffersonheard> assuming there's some way programmatically to figure out what byte order my machine is in
13:48:48 <Orphi> jeffersonheard: I think somewhere Data.Binary exposes primitives for writing wide integers with specific word orders, if you're interested...
13:48:58 <jeffersonheard> ah excellent
13:49:02 <jeffersonheard> I was just looking for that
13:49:15 <byorgey> jeffersonheard: there's also http://hackage.haskell.org/package/data-binary-ieee754
13:49:43 <jeffersonheard> oh perfect
13:49:45 <byorgey> wish I had known about that for the programming contest =P
13:49:48 <jeffersonheard> that's what I need
13:49:50 <jeffersonheard> haha
13:49:52 <dcoutts> at the time we wrote the instances for Float and Double it didn't look like it was possible to serialise to/from the ieee format on all platforms
13:50:06 <dcoutts> only on platforms that use ieee floats natively
13:50:25 <byorgey> I ended up doing violence to some ByteStrings with foreign pointers.
13:50:40 <Orphi> dcoutts: Indeed; the unsafeCoerce trick uses whatever format is native...
13:50:48 <DaveS> A little bit of the ol ultra-violence
13:50:53 <dcoutts> augustss pointed out that we could just use bit twiddling to encode into ieee format
13:50:54 * Berengal gets a disturbing image of byorgey whipping ByteStrings
13:51:05 <dons> there's the Binary instance on hackage too, of course.
13:51:09 <dons> that does portable ieee parsing
13:51:19 <Orphi> byorgey: unsafeCoerce is enough if you just want to dump a Double. ;-)
13:51:20 <olsner> DaveS: unsafeUltraViolentCoerce
13:51:33 <dcoutts> dons: we could at least add the primitives into the binary package, even if we cannot yet change the Binary class instances.
13:51:43 <dons> that's reasonable, yes.
13:51:52 <dons> certainly an FAQ
13:51:53 <Orphi> the FUN thing is the [] instance of Binary...
13:52:00 <byorgey> Orphi: at the time that just seemed wrong.  But in the end that would have been less wrong, I think.
13:52:15 <dons> dcoutts: thoughlooking at the ieee package on hackage, it is somewhat involved
13:52:26 <Orphi> byorgey: Yeah... I went down the route you're talking about too BTW. Before realising unsafeCoerce would work.
13:52:27 <dons> putDoubleHost is trivial though
13:52:28 <dcoutts> dons: yep, bit twiddling
13:52:38 <hackagebot> haskell-src-exts 1.0.1 - Manipulating Haskell source: abstract syntax, lexer, parser, and pretty-printer (NiklasBroberg)
13:52:51 <dcoutts> dons: we only need 32 and 64 though, and can implement the BE/LE versions by swapping
13:52:58 * Twey really thinks we should have getArgs in the Prelude
13:53:06 <copumpkin> aw, the icfp contest blog seems to have died
13:53:12 <dcoutts> dons: and we only need these implementations on non-ieee machines
13:53:13 <jeffersonheard> (laughs @ unsafeUltraViolentCoerce)
13:53:31 <olsner> Orphi: FUN as in forcing the potentially infinite list in order to serialize its length? :)
13:53:36 <dcoutts> dons: though we have to be careful not to do unaligned memory accesses on machines that do not like that
13:53:42 <dcoutts> dons: so all in all it's non-trivial
13:53:44 <Twey> I mean, we've got getLine in there — by what logic does getArgs deserve to be cloistered away in System.IO but not getLine?
13:53:44 <Orphi> olsner: Yes, that kind of fun.
13:53:50 <jeffersonheard> I'm using the hackage version now.   It seems to do everything I need
13:54:01 <dons> dcoutts: def. getting into the parsing combinator terriroty
13:54:07 <dcoutts> Twey: history, H98 standard
13:54:16 <Orphi> I also forget what precision it uses for the length field...
13:54:18 <dons> i imagine a binary-extras, for common, but non-trivial, binary parsers
13:54:24 <dons> like bytestring-lexing
13:54:27 <dcoutts> dons: not really, it's still a primitive
13:55:06 <dons> oh, because the host-order version is primitive?
13:55:29 <Berengal> Is it possible to encode a non-infinite list in the type system?
13:55:36 <dcoutts> dons: well, I mean it's pure functions from Word64 <-> Double
13:55:42 <copumpkin> Berengal: nested pairs with terminating () ?
13:55:42 <Berengal> Non-infinite inductive list, that is
13:55:49 <dcoutts> dons: and then the get/put is just the Word64 or 32 for Float
13:55:50 <Orphi> The true FUN would be figuring out a way to serialise potentially cyclic data structures. ;)
13:55:55 <dons> dcoutts: fair enough
13:55:57 <olsner> Orphi: same kind of fun as printf's %s does (iirc, it calculates the length to see if it's less than the given minimum field width - even when there's no minimum width given)
13:56:05 <dmhouse> Berengal: sure, add in the length?
13:56:08 <dmhouse> (As a strict parameter.)
13:56:42 <dcoutts> dons: while the code is perhaps non-trivial, everyone considers ieee floats to be primitive binary types that we should support. Certainly more exotic things can live elsewhere.
13:56:47 <Orphi> olsner: printf() is EVIL!!
13:56:58 <dcoutts> dons: also since it is so machine dependent it's better to do once correctly in the binary package.
13:56:58 <Berengal> dmhouse: Well, using infinite numbers you could possible make an infinite list as well...
13:57:32 <olsner> Orphi: length returns Int, so binary for [] would probably encode as Int64 or Int32 (of course, wrapping if the list is too long)
13:57:39 <dcoutts> dons: I guess by primitive in this context I mean atomic types and fixed width binary representations.
13:58:03 <dmhouse> Berengal: I'm fairly sure Integer can only support finite numbers.
13:58:03 <copumpkin> there could be a newtype in binary called UnsafeFloat and UnsafeDouble? :P
13:58:12 <Orphi> olsner: With a 64-bit address space, a list *can't* be bigger than an Int64 can hold. Even so... scary!
13:58:16 <dmhouse> Berengal: so can data NatFin = Z | S !NatFin
13:58:33 <olsner> Orphi: well printf's far too loosely typed, but in principle the format+args concept is good IMO
13:59:02 <Berengal> dmhouse: Yeah, I guess that's true. I was hoping for something that encoded the finiteness in the induction itself though
13:59:06 <Orphi> olsner: The number of C programs I've written which print 80 pages of garbage and BEL characters because I got printf() wrong somewhere...
13:59:23 <dmhouse> Berengal: then same trick as with NatFin: make the recursive parameter strict
13:59:37 <dmhouse> data ListFin a = Nil | Cons a !(List a)
13:59:43 <olsner> (note: I'm referring to the *haskell* printf)
14:00:28 <Meady> ok Berengal, i have a prime calculator
14:00:31 <Meady> just need to make an array for it
14:00:32 <dcoutts> dons: note, I pushed some doc changes in response to the emails from SPJ and John Lato
14:00:32 <Meady> gona do that now
14:00:43 <dcoutts> dons: for bytestring I mean
14:00:43 <Orphi> I still find it scary that printf exists in Haskell... surely there is a Better Way(tm)?
14:00:55 <poh> what do I need to do so ghc knows to search for imports in cabal installed packages
14:01:02 <Berengal> dmhouse: It's still possible to describe an infinite list, and have it typecheck, even though it'll have to be bottom
14:01:08 <Berengal> Meady: Nice
14:01:14 <dcoutts> poh: nothing, it's automatic
14:01:19 <copumpkin> Orphi: using template haskell, sure :)
14:01:23 <dmhouse> Orphi: there are ways of doing printf type safely. Although how it works is deep typeclass magic.
14:01:25 <copumpkin> or was it a quasiquoter
14:01:37 <dmhouse> Berengal: it is? Show me.
14:01:44 <copumpkin> dmhouse: not with regular format strings
14:01:53 <dcoutts> poh: ghc-pkg list shows the registered packages
14:01:57 <olsner> one way is to use TH, or you can encode the format in a data type
14:01:58 <dmhouse> Berengal: oh, if the entire list is bottom? Well, I guess...
14:02:05 <Berengal> dmhouse: infiniteList = Cons 1 infiniteList
14:02:13 <Orphi> but surely there is a better way than trying to encode formatting instructions into a stream of ASCII gibberish...
14:02:16 <copumpkin> > length $ replicate 10 undefined
14:02:18 <lambdabot>   10
14:02:23 <poh> dcoutts: thanks
14:02:24 <dmhouse> Berengal: but that will be true no matter what data representation you use
14:02:42 <mauke> Orphi: no, printf is actually pretty sweet
14:02:59 <dmhouse> copumpkin: sure? I thought I'd seen an Oleg posting or two about it
14:03:00 <Berengal> dmhouse: Yeah, so we must conclude that it's not possible?
14:03:09 <Orphi> mauke: Well, at least *I* don't have to use it. :P
14:03:26 <mauke> oh come on, it's not that complicated
14:03:27 <copumpkin> dmhouse: pretty positive you can't get a tyepsafe printf using a format string, unless you do some quasiquoting or similar
14:03:28 <Berengal> dmhouse: At least with the restrictions I put in...
14:03:45 <dmhouse> Berengal: I think defining a finite list as one on which length xs doesn't return bottom for xs != _|_ is fairly sane
14:03:45 <Berengal> A little disappointing, seeing how we can describe infinite lists so easily...
14:03:47 <olsner> hmm, maybe something like printf ("foo " :> stringArg :> ": " :> intArg) mightn't be too arduous compared to a format string
14:04:01 <copumpkin> olsner: yeah, I think I've seen something like that out there
14:04:13 <dmhouse> Berengal: how can you define infinite lists?
14:04:23 <Berengal> dmhouse: Yeah, but you don't get static checking of that fact
14:04:38 <Berengal> data InfiniteList a = Cons a (InfiniteList a)
14:04:44 <olsner> hmm, it's kind of trivial really, there must be a hundred things-like-that out there
14:05:14 <dmhouse> Berengal: well, _|_ is a member of that type, and is arguably a finite list...
14:05:19 <Berengal> olsner: We have ++ already for that kind of syntax
14:05:20 <olsner> considering Oleg has contributed to the area though, I'm not hoping I have very much to add
14:05:21 <copumpkin> Cofree Identity ?
14:05:59 <Berengal> dmhouse: _|_ is arguably not a list at all, but that argument goes for finite lists as well...
14:06:23 <jmcarthur_work> :t undefined :: [Int]
14:06:25 <lambdabot> [Int]
14:06:54 <dmhouse> Berengal: my argument is that if you claim _|_ is an infinite list in my finite list type, then I can equally claim _|_ is a finite list in your infinite list type.
14:07:08 <Berengal> dmhouse: Yeah, that's what i meant by it going both ways
14:07:30 <Berengal> Except I didn't say that, I only thought it :/
14:07:55 * Berengal wonders if it's past his bedtime
14:08:23 <olsner> Berengal: hmm, I see what you're saying... the thing is that the format defines how to convert a value into a string while ++ only concatenates strings after you've show'd the values already
14:09:14 <Berengal> olsner: Ah, so an existential Show?
14:09:34 <Berengal> (possibly Printf)
14:09:40 <roconnor> _|_ is neither an infinite list nor a finite list, although it is (in this case) a list.
14:10:48 <dmhouse> roconnor: how are you defining finite/infinite list?
14:10:49 <olsner> and other things, such as putting arbitrary show-functions (even arbitrary-ary functions, potentially) in the format description, then sending around the result of (printf format) as a function
14:11:22 <roconnor> dmhouse: finite is a list that is eventually []
14:11:33 <olsner> which is kind of like making a function (\a b c -> "foo " ++ show a ++ "..."++showSpecial 123 b etc), but not quite the same
14:11:36 <dmhouse> roconnor: Then it's infinite.
14:11:47 <roconnor> dmhouse: infinite is a list which always has a cons cell after every cell
14:11:57 <dmhouse> Then it's infinite.
14:12:01 <olsner> maybe it could be described as a difference in level of abstraction
14:12:06 <roconnor> er
14:12:09 <dons> dcoutts: yep
14:12:13 <roconnor> didn't quite get infinite defined right
14:12:29 <Berengal> an infinite list is a list that doesn't have [] in it
14:12:41 <roconnor> an infinite list starts with a cons cell and is followed by an infinite list
14:12:50 <dmhouse> Perhaps infinite is one in which the number of cons cells doesn't biject with any finite set.
14:13:05 <dmhouse> Or rather more simply, it has infinitely many conses :)
14:13:42 <olsner> so cyclic lists aren't infinite, just don't end?
14:13:52 <dmhouse> What is a cyclic list?
14:14:29 <olsner> this is where you out-define me and say it's not a list if it's cyclic? I'm thinking e.g. fix (1:)
14:14:45 <dmhouse> That has infinitely many conses.
14:15:12 <dmhouse> If it has finitely many conses, how many?
14:15:23 <roconnor> cyclic lists are infinite lists
14:15:28 <olsner> dmhouse: one?
14:15:36 <Berengal> Finite list: [] or any list which is eventually consed to []. Infinite: Any list that isn't consed to []
14:15:40 <dmhouse> olsner: but it's equal to 1 : fix (1:)
14:15:42 <roconnor> they have the same denotations as infinite lists, so they are the same
14:15:46 <Berengal> (and is not [])
14:15:48 <jmcarthur_work> olsner, can you observe that a cyclic list has only one cons in haskell?
14:16:07 <dmwit> jmcarthur_work: no
14:16:18 <jmcarthur_work> dmwit, that wasn't for you to answer :P
14:16:21 <dmwit> jmcarthur_work: Not without breaking the semantics via, eg, the GHC API.
14:16:21 <dmhouse> olsner: I think you say it only has one cons because ":" only appears once in the definition fix (1:). But it's equal to 1:1:1:1:1:..., i.e. infinite many conses.
14:16:49 <dmwit> dmhouse: ...it's also equal to let x = 1:x in x, which has only one cons.
14:16:59 <Twey> An infinite list is a list
14:16:59 <dmwit> dmhouse: I think we maybe have to define what we mean by "equal" here.
14:17:07 <dmhouse> Sure, it's also equal to cycle [1] which has "no conses".
14:17:10 <Berengal> > [1..10] < fix (1:)
14:17:11 <Cale> olsner: The only way you can tell the difference between an infinite list and a cyclic one is by observing things in memory which you are not normally allowed to access.
14:17:12 <lambdabot>   False
14:17:21 <olsner> I think the difference is in how you define "equal" as well as how you define the "number of conses"
14:17:21 <Twey> In the same way Just 3 is a Maybe
14:17:25 <Berengal> > replicate 10 1 < fix (1:)
14:17:27 <lambdabot>   True
14:17:33 <Twey> You use a list constructor, so it's a list.
14:17:44 <Twey> The fact that the other one isn't used isn't important
14:17:53 <jmcarthur_work> i'd say "equal" should mean "observably equal"
14:17:58 <copumpkin> > let (:) = (+) in 5 : 6
14:18:00 <lambdabot>   Constructor `:' should have 2 arguments, but has been given 0
14:18:05 <copumpkin> that's annoying
14:18:12 <jmcarthur_work> although, then you can't say that _any_ infinite list is equal :\
14:18:17 <Twey> copumpkin: : is capital punctuation :)
14:18:21 <Cale> olsner: The matter of whether fix (1:) is truly infinite or going to be cyclic (and use a bounded amount of memory then), depends on whether you write  fix f = f (fix f), or fix f = x where x = f x
14:18:24 <jmcarthur_work> without a special representation, anyway
14:18:30 <Berengal> jmcarthur_work: You can't
14:18:31 <copumpkin> Twey: ah, true that
14:18:31 <Twey> > let Foo = (+) in 5 `Foo` 6
14:18:33 <lambdabot>   Not in scope: data constructor `Foo'Not in scope: data constructor `Foo'
14:18:38 <Berengal> You can say they're not equal though
14:18:43 <jmcarthur_work> right
14:19:18 <Berengal> > [1..] == [1..]
14:19:23 <lambdabot>   mueval-core: Prelude.read: no parse
14:19:23 <Cale> The latter will produce a cycle in GHC, and you'll end up with a finite representation. The former is not automatically CSE'd, and you end up doing as many actual memory conses as necessary throughout the program.
14:19:24 <lambdabot>  mueval: ExitFailure 1
14:19:24 <jmcarthur_work> fail
14:19:27 <Berengal> > [1..] == [2..]
14:19:29 <lambdabot>   False
14:19:43 <olsner> well, I was thinking explicitly about the one where an infinite list of '1's is constructed by linking a single cons with itself (and yes, I'm thinking in pointers and memory here rather than in values :P)
14:20:00 <dmwit> jmcarthur_work: Nonsense, contextual equivalence is a perfectly good way of telling whether two infinite lists are equal.
14:20:03 <Twey> data InfList a = Cons a InfList; instance Eq InfList where (==) = True
14:20:15 <dmwit> Just because you can't define a function in Haskell to decide that question doesn't mean it's a bad mathematical definition. =)
14:20:19 <jmcarthur_work> dmwit, i'm talking about (==) here
14:20:36 <dmwit> jmcarthur_work: No you're not. ;-)
14:20:45 <Cale> So, it's subtle. One nice thing though is that as long as the consumer of the list only needs one element at a time and is careful to discard references to early list cells, the GC will pick up the waste rather quickly.
14:21:00 <jmcarthur_work> dmwit, "observably equal"
14:21:25 <dmwit> quite
14:21:25 <Twey> const $ const True
14:21:26 <Cale> At the level of denotational semantics, they are absolutely the same.
14:21:37 <jmcarthur_work> i guess i should have further qualified that with "from within a haskell program"
14:21:39 <dmwit> You're right, "observably equal" is very different from "not observably inequal"
14:21:52 <dmwit> I apologize.
14:22:12 * olsner recalls a similar discussion about the subtleties about equality
14:22:18 <olsner> *of
14:25:52 <FliP^2eH> @faq Can haskell revive Billy Mays?
14:25:52 <lambdabot> The answer is: Yes! Haskell can do that.
14:25:57 <FliP^2eH> Then do so ;__; :(:(
14:27:15 <jmcarthur_work> BUT WAIT, THERE'S MORE!
14:29:06 <olsner> jmcarthur: that topic died 5 minutes ago, get over it :)
14:29:23 <jmcarthur_work> </billy-mays>
14:29:31 <FliP^2eH> <billy-mays>
14:29:33 <FliP^2eH> Do not forget.
14:29:49 <jmcarthur_work> </billy-mays>
14:29:57 * FliP^2eH goes sob in some corner
14:31:18 <mmorrow> > "[1..]" == "[1..]"
14:31:20 <lambdabot>   True
14:31:23 <mmorrow> yay!
14:32:26 <olsner> jmcarthur_work: oh, I thought you were saying THERE'S MORE about "observable equality" and "observable non-inequality"
14:32:36 <olsner> and infinite lists and all that
14:33:40 <copumpkin> , vacuum (repeat 1)
14:33:44 <lunabot>  [(0,[1,0]),(1,[])]
14:33:49 <copumpkin> , vacuum (repeat 1) == vacuum (repeat 1)
14:33:51 <lunabot>  True
14:33:57 <copumpkin> yay
14:34:01 <jmcarthur_work> olsner, Infinite lists are like Billy Mays: "BUT WAIT, THERE'S MORE!"
14:34:26 <olsner> copumpkin: mind successfully blown
14:34:29 <mmorrow> if this version kept the literals around, you could do this correctly too
14:34:36 <copumpkin> :P
14:34:42 <mmorrow> , vacuum (fix (0:)) == vacuum (fix (1:))
14:34:45 <lunabot>  True
14:34:53 <mmorrow> (literals aren't kept here, just pointers)
14:34:57 <copumpkin> yup
14:35:04 <mmorrow> , vacuum (fix (0:))
14:35:07 <lunabot>  [(0,[1,0]),(1,[])]
14:35:07 <jmcarthur_work> , vacuum (cycle [1]) == vacuum (repeat 1)
14:35:09 <lunabot>  True
14:35:38 <olsner> vacuum is full of evil unsafe ghc-internal hacks, right?
14:35:48 <copumpkin> yup
14:35:52 <jmcarthur_work> absolutelty
14:35:56 <jmcarthur_work> *absolutely
14:36:33 <mmorrow> olsner: it essentially just turns the graph representation of the value in the heap into an equivalent graph representaion at the haskell-level
14:37:10 <Cale> > (\(x,y) z -> ()) undefined `seq` ()
14:37:11 <lambdabot>   ()
14:37:14 <mmorrow> what it uses to achieve that (and what exactly that rep is) are both ghc-dependent
14:37:16 <Cale> > (\(x,y) -> \z -> ()) undefined `seq` ()
14:37:17 <lambdabot>   * Exception: Prelude.undefined
14:37:36 <mmorrow> but you could imagine a language that specifies this representation in its spec
14:38:37 <mmorrow> e.g. maximal sharing between data constructors, where data constructor := [tag,[ptrs],[lits]]
14:38:41 <mornfall> How would you pack up a bunch of test data files for a haskell project? It seems tarring is not very useful, given that on win32 there's no tar.
14:39:12 <olsner> hmm, if you had reification you should be able to run arbitrary haskell code in a sandbox heap, implemented purely, and get the same results, right? (as long as you only apply it to that subset of haskell that is implemented by the sandbox)
14:39:39 <mmorrow> olsner: if i understand your question correctly, yes
14:40:33 <Cale> , let fix f = f (fix f) in vacuum (fix (0:))
14:40:36 <mornfall> Hm, Codec.Archive.Zip, maybe?
14:40:37 <olsner> reification meaning that passing foo to vacuum' actually means passing a representation of foo and everything referred to from foo
14:40:38 <mmorrow> well, yeah of course. imagine implementing an x86 simulator and running linux on that, using IntMap for the memory
14:40:40 <lunabot>  Killed.
14:41:00 <mmorrow> olsner: ah, yeah definitely.
14:41:35 <mmorrow> Cale: heh, yeah interestingly that def of fix loses all sharing
14:41:46 <Cale> right
14:41:57 <Cale> That's what I was mentioning to olsner earlier
14:42:16 <olsner> that kind of reification would incidentally be awesome for other reasons as well, probably already is included in TH though
14:42:30 <Cale> GHC doesn't take care to notice that the parameters to fix on the rhs are exactly the same as those on the lhs.
14:43:13 <Berengal> Cale: Is there some magic reason why it doesn't do this, or could it be done?
14:43:28 <mmorrow> olsner: hmm, how do you mean (wrt TH)?
14:43:33 <Cale> Berengal: it could be done, but CSE in general is not always an optimisation.
14:44:33 <Berengal> Cale: Yeah, I know... In some sense, that is a magic reason, or determining when it is an optimization is
14:44:36 <Cale> Berengal: Just because we can use extra memory to store the results of evaluating expressions we'll know we're going to need later doesn't always mean that it's worthwhile to make that trade :)
14:44:47 <mmorrow> olsner: i'd say the difference between `reify' (from TH) and vacuum (the idea in general of what vacuum does) are that they're static vs. dynamic representations of data
14:45:09 <Cale> In this case, it's certainly a good thing I think.
14:45:36 <Cale> I don't think there are any cases where the sharingless version of fix is better.
14:45:47 <Cale> (doesn't make much sense)
14:46:08 <olsner> mmorrow: I mean that you could probably use TH to get the AST or equivalent of 'foo' and could feed that to your own sandbox haskell interpreter
14:46:44 <Berengal> Cale: Sure, for fix CSE is a good thing, but as you said, not in the general case (and we like solving things for the general case)
14:47:01 <Cale> I wonder if there's ever any disadvantage to having GHC tie the sort of knot where you've just applied f to the exact same parameters as on the lhs of the =
14:47:02 <mmorrow> olsner: ah, true, but the AST is a tree of course, so you'd need to figure out the sharing yourself in that case (if you intend to use sharing that is)
14:47:23 <mmorrow> (well, the haskell representation of the AST is a tree)
14:48:36 <mmorrow> also though, vacuum can't see the values stuck inside partial applications and frozen not-yet-evaluated application nodes, since ghc's unpackClosure# primitive, which vacuum uses, doesn't provide this info
14:48:48 <Cale> ASG :O
14:48:50 <mmorrow> unfortunately
14:49:32 <Cale> This is one thing which languages like HOPS would make really simple.
14:49:43 <mmorrow> Cale: let x = f x in x ===> [(0,VAR "x"),(1,AP "f" [0])]
14:49:50 <Cale> You want sharing, draw the graph edges in yourself :)
14:50:13 <olsner> if that AST has (let x = f x in x), then the sharing is explicit in the AST, and when evaluated in the sandbox should produce the right heap graph, right?
14:50:44 <mmorrow> olsner: depends how the evaluator is implemented
14:51:00 <Meady> guys with map
14:51:04 <Meady> can i add conditional in that
14:51:11 <Meady> Berengal almost finished what you asked:p
14:51:14 <Berengal> Meady: No
14:51:15 <Meady> and its quite fast too
14:51:15 <Meady> :p
14:51:19 <Berengal> Nice
14:51:21 <Cale> Meady: what does the conditional do?
14:51:40 <Meady> map (function) list, dont map if list val = 0
14:51:58 <mauke> oh, you want to combine map and filter?
14:51:59 <Cale> Meady: you can do that either with a combination of map and filter, or you can use concatMap
14:52:03 <Meady> ahh ok
14:52:05 <Meady> filter
14:52:14 <Meady> ill have a look at it
14:52:18 <mauke> > filter even [0 ..]
14:52:20 <lambdabot>   [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,5...
14:52:25 <Cale> > concatMap (\x -> if x == 0 then [] else [x*10]) [1,0,2,0,3,0,4,0,5]
14:52:27 <lambdabot>   [10,20,30,40,50]
14:52:47 <mauke> > [x*10 | x <- [1,0,2,0,3,0,4,0,5], x /= 0]
14:52:48 <Berengal> Meady: If you just wanted to not map the value, you can do '\x -> if foo x then x else mapFunc x'
14:52:48 <lambdabot>   [10,20,30,40,50]
14:53:10 <Meady> yeah but im running atm, i dont wana tell you till its done
14:53:11 <Meady> lol
14:53:12 <Meady> :p
14:53:23 <Berengal> Hehe
14:53:27 <Meady> my method
14:53:34 <Meady> all home made
14:53:34 <Meady> :d
14:54:27 <Berengal> Home-made primes, divides the same way your mother's did
14:54:34 <Meady> lol
14:54:47 <Meady> im saying i used me noggin instead of google source
14:55:08 <Berengal> Yeah, that's kind of the point of doing exercises :)
14:55:22 <Meady> where would i apply the filter
14:55:34 <Meady> map filter? (func) [list]
14:55:44 <Berengal> before or after the map
14:55:55 <Berengal> map func . filter otherFunc (or the other way around)
14:55:56 <mauke> er, filter is just a normal function
14:56:11 <Meady> hmm
14:56:15 <mauke> you can't just throw it randomly into an expression
14:56:19 <Meady> im still not getting the process of grouping functions
14:56:32 <Berengal> Meady: Then use parenthesis for now
14:56:35 <mauke> f (g (h x))
14:56:47 <olsner> mauke: technically, you *can*, but it might not parse or type-check :)
14:56:54 <monochrom> I always use parentheses.
14:57:02 <mux> Data.Binary needs Get primitives for ieee754 floating point numbers, it seems
14:57:09 <Berengal> monochrom: And never pointless?
14:57:22 <monochrom> That's an orthogonal issue.
14:57:57 <Meady> GUESS WHAT
14:57:58 <Berengal> Not exactly. You can't transform 'map foo . filter bar' to a parenthesized expression without a point
14:57:59 <Meady> MUTHA FUCKAS
14:58:02 <Meady> hes gona and done it
14:58:04 <Meady> pastebin link?
14:58:07 <Berengal> @paste
14:58:08 <lambdabot> Haskell pastebin: http://hpaste.org/new
14:58:37 <monochrom> (map foo) . (filter bar)
14:58:48 <Meady> Here weeee gooooo
14:58:48 <Meady> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6369#a6369
14:59:02 <Meady> How would i improve it
14:59:03 <monochrom> Whatever. Believe what you want.
14:59:27 <Meady> Monochrom ?
14:59:29 <mauke> Meady: (myPrime) is the same as myPrime
14:59:40 <mauke> Meady: monochrom isn't talking to you :-)
14:59:41 <monochrom> Not to you.
14:59:56 <Meady> And thats not too slow either is it ?:P
15:00:23 <mauke> hmm, that's a weird method
15:00:40 <mauke> Meady: you don't need map at all there :-)
15:00:48 <mauke> myPrime either returns x or 0
15:00:55 <mauke> and you filter all the 0s
15:01:05 <Berengal> monochrom: That's just adding arbitrary parenthesis.
15:01:11 <mauke> so calcPrimes will consist of original elements only
15:01:27 <monochrom> Years are spent on micro-optimizing a loop over divisions rather than learning and implementing the Rabin-Miller test.
15:01:35 <mauke> Meady: you could return a Bool from myPrime and use filter directly
15:01:40 <Meady> so you dont think its good :S?
15:01:49 <mauke> hey, you asked for improvements
15:02:01 <Meady> ahaha, no but initially is it ok? and then improvements?
15:02:17 <mauke> it looks like beginner code, but otherwise fine
15:02:45 <Berengal> Meady: Does it calculate the sum of all primes below 2 million in less than a minute?
15:03:00 <Meady> lol
15:03:04 <Meady> no tested
15:03:06 <Meady> ill try it now
15:03:12 <mux> sounds like project euler
15:03:22 <Meady> is there a timing function in Haskell?
15:03:40 <sjanssen> @hackage timeit
15:03:41 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/timeit
15:03:55 <Berengal> I like to just compile and use time...
15:04:26 <Meady> gets about 20k
15:04:29 <Meady> 12k*
15:04:31 <mauke> Meady: untested, but http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6369#a6370
15:04:33 <Meady> per munute
15:04:43 <yottis> humm, playing around with arrows. looking for a way to do ((a,b),c) -> (a,(b,c)), but hoogle wasn't able to help
15:05:00 <yottis> is there a higher level function or am i trying the wrong thing?
15:05:23 <Meady> 12k per minute isnt fast, mauke thanks for source ill look into it some more
15:05:25 <SamB> @djinn ((a,b),c) -> (a,(b,c))
15:05:26 <lambdabot> f ((a, b), c) = (a, (b, c))
15:05:33 <sjanssen> @. pl djinn ((a, b), c) -> (a, (b, c))
15:05:34 <SamB> @. pl djinn ((a,b),c) -> (a,(b,c))
15:05:45 <lambdabot> f = uncurry (uncurry ((. (,)) . (.) . (,)))
15:05:45 <lambdabot> f = uncurry (uncurry ((. (,)) . (.) . (,)))
15:05:51 <opqdonut> oh please
15:06:08 <SamB> that's not pretty :-(
15:06:19 <copumpkin> I bet arrow could help
15:06:26 <olsner> it is kind of pretty, but not readable
15:06:32 <mauke> :t (fst . fst) &&& first snd
15:06:34 <lambdabot> forall a b b1. ((a, b), b1) -> (a, (b, b1))
15:06:35 <yottis> writing a point-free ~ quicksort and need to fiddle the pivot between partition (<pivot)
15:06:47 <copumpkin> yay mauke saves the day
15:06:49 <Meady> 2,000,000 primes how long should that take, on a core duo 2.0ghz
15:07:07 <yottis> awesome
15:07:29 <Berengal> Meady: Not 2,000,000 primes, but all primes < 2,000,000
15:07:50 <Meady> Mauke, its quite fast
15:07:53 <Meady> little bit faster
15:08:04 <Berengal> Anyway, with a good algorithm it shouldn't take more than a minute
15:08:21 <Berengal> > let primes = 2:3:5:[n | n <- [7,9..], all ((/=0) . mod n) (takeWhile (<= (ceiling.sqrt.fromIntegral $ n)) primes)] in take 20 primes
15:08:22 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71]
15:08:40 <copumpkin> or you could use that ridiculously concise but slow nubBy definition
15:09:00 <Berengal> or import Data.Numbers.Primes
15:09:05 <Berengal> (Or whatever that module was)
15:09:10 <Meady> ok so berengal, what next:p
15:09:22 <Berengal> Meady: Did you find the sum yet?
15:10:06 <olsner> Berengal: looks like this is it: http://hackage.haskell.org/package/primes
15:10:07 <Meady> doing that now
15:10:38 <Berengal> olsner: Yeah, that's the one
15:11:04 <olsner> I wonder if I count that as cheating if I use it for euler
15:11:30 <Berengal> olsner: I'm betting you already have your own prime algorithm
15:12:16 <monochrom> Some people may have trouble accepting that you can use a pre-made library to get primes. Afterall it's a slippery rope: what if one day there is a pre-made library for all Project Euler problems? "Hi I'm trying problem #364" "import ProjectEuler; main = solution 364"
15:12:22 <Meady> how do i print the types again
15:12:28 <Meady> @sum
15:12:29 <lambdabot> Maybe you meant: bug run src
15:12:32 <Meady> @src sum
15:12:32 <lambdabot> sum = foldl (+) 0
15:12:40 <Berengal> That one's about twice as fast as my own not-very-optimized version, which isn't really that much when it comes to fighting the exponential complexity of naive euler solutions
15:12:41 <Meady> :t sum
15:12:43 <lambdabot> forall a. (Num a) => [a] -> a
15:12:46 <olsner> I made a simple STUArray sieve, turned out to be "fast enough" for most problems I ran into (e.g. where you have an upper bound on the primes that is lower than what fits into ram)
15:12:55 * copumpkin used ONeilPrimes and various other modules from the number theory in haskell library for project euler
15:12:58 <copumpkin> very useful :)
15:13:15 <Meady> sum (filter (myPrime) [2..999])
15:13:16 <Meady> not working
15:13:26 <Berengal> Meady: You mean it hangs?
15:13:28 <mauke> Meady: what's the error?
15:13:29 <Cale> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) . takeWhile (\p -> p*p <= n) $ primes in sum (takeWhile (< 2000000) primes)
15:13:35 <lambdabot>   mueval-core: Prelude.read: no parse
15:13:35 <lambdabot>  mueval: ExitFailure 1
15:13:44 <olsner> copumpkin: Data.Numbers.Primes says it's inspired by O'Neil's paper
15:13:48 <Berengal> Meady: Here's a trick: "sum' = scanl (+) 0"
15:13:49 <copumpkin> ah :)
15:13:51 <Meady> possible incorrect indentation
15:14:17 <Cale> ah, I suppose that does take a little while :)
15:14:23 <mauke> Meady: hmm, need more context then
15:14:27 <Berengal> Cale: Couple seconds on my machine
15:14:31 <Meady> myPrime x = myPr x (x-1)
15:14:31 <Meady> myPr x 1 = True
15:14:31 <Meady> myPr x y = x `mod` y /= 0 && myPr x (y-1)
15:14:31 <Meady> sum (filter (myPrime) [2..999])
15:14:50 <Berengal> Cale: Also, it's better to sqrt n than ^2 p
15:14:56 <olsner> hmm, it seems both 'primes' and 'Numbers' expose a package called Data.Numbers.Primes
15:14:58 <mauke> Meady: er, you can't just put an expression into a file
15:15:04 <Berengal> GHC will CSE the sqrt, or you could put it in a let
15:15:16 <Cale> Berengal: provided that you have a fast sqrt for integers
15:15:20 <mauke> Meady: myResult = sum (filter myPrime [2 .. 999]) should work, though
15:15:28 <Cale> Well, I suppose the approximate one would do here.
15:15:46 <mauke> or 'main = print (sum (filter myPrime [2 .. 999]))' if you want to compile the file
15:15:55 <Berengal> Cale: I use ceiling.sqrt.fromInteger, which seems to work fine (but needs 2, 3 and 5 to get started
15:16:03 <Meady> i see
15:16:45 <Berengal> Cale: Anyway, it doesn't take many multiplications to recoup the cost of a sqrt, and the sqrt can be lifted out of the loop
15:16:51 <Meady> myPrime x = myPr x (x-1)
15:16:51 <Meady> myPr x 1 = True
15:16:51 <Meady> myPr x y = x `mod` y /= 0 && myPr x (y-1)
15:16:51 <Meady> myResult = sum (filter myPrime [2..999])
15:16:56 <Meady> Ok , all is working now
15:17:15 <Cale> Berengal: wouldn't that mean testing more primes?
15:17:39 <Berengal> Cale: I don't think you can use round or floor...
15:17:58 <Berengal> Well, perhaps, with <=
15:18:35 <Meady> Berengal, how would i use main in this, main = do myREsult?
15:18:45 <mauke> <mauke> or 'main = print (sum (filter myPrime [2 .. 999]))' if you want to compile the file
15:18:50 <Berengal> Anyway, I've found 'primes = 2:filter isPrime [3,5..]; isPrime = (==) <*> head . factorize; factorize = [..]' is faster when compiled (but much slower when interpreted)
15:18:56 <Cale> Berengal: oh, you just mean not recompute the sqrt for each prime you're checking.
15:18:58 <mauke> main = print myResult
15:19:00 <Meady> Mauke wicked
15:19:23 <mmorrow> Cale: what is HOPS? (that mentioned earlier)
15:19:30 <Berengal> Cale: Yeah, that's the point of using sqrt. it can be lifted out of the inner loop
15:19:44 <Meady> So all functions should be define outside of main, then just ran inside?
15:19:51 <mmorrow> *(that _you_ mentioned earlier)
15:20:12 <Berengal> "foreach n: foreach prime: prime*prime" vs "foreach n: sqrt n; foreach prime:"
15:20:15 <Cale> mmorrow: A functional programming language whose syntax consists of graphs, and whose semantics is defined via graph reduction directly.
15:20:27 <yottis> hmm. when will a haskell compiler be smart enough to compile a high level quicksort into the same (efficient) thing as how one would write it in an imperative language?
15:20:37 <mmorrow> Cale: oh cool, what should i google for? (no luck so far)
15:20:52 <Berengal> Meady: Yup
15:21:03 <mmorrow> oh found it
15:21:05 <mauke> Meady: yes, more or less. just like C or Java :-)
15:21:12 <Cale> http://www.cas.mcmaster.ca/~kahl/HOPS/
15:21:32 <Meady> Ok wicked
15:21:32 <Berengal> yottis: Haskell's quicksort is already about as efficient as you can get quicksort on linked lists
15:21:37 <Cale> mmorrow: Unfortunately, there's no code online.
15:21:37 <Meady> think im ready to try something with sockets yet?
15:21:42 <Meady> infact
15:21:45 <Meady> Lets collect some input:p
15:21:48 <mmorrow> Cale: awww :(
15:21:53 <mauke> sockets, no
15:21:58 <Cale> mmorrow: But maybe you can bug Dr. Kahl to publish something on the web
15:22:00 <mauke> I think you should do data structures next
15:22:02 <Meady> getStr?
15:22:04 <yottis> hmm well linked lists are a complication
15:22:07 <Meady> x <- getStr?
15:22:09 <mauke> make your own lists, trees, etc
15:22:19 <yottis> well, if one would assume something flatter
15:22:25 <mauke> Meady: getLine
15:22:31 <Meady> ah ok
15:22:43 <Meady> :t getLine
15:22:45 <lambdabot> IO String
15:22:49 <Berengal> yottis: Using STArray and ST you could get the same compiled code as imperative languages...
15:22:50 <mmorrow> "HOPS modules are stored as XML documents"
15:22:54 * mmorrow cries
15:23:02 <yottis> what i'm striving for is noticing that the sortable is thrown away after each iteration and you don't need to keep it around
15:23:19 <Cale> mmorrow: hehe
15:23:29 <Cale> mmorrow: Thankfully, I think you never have to care.
15:23:44 * Berengal has installed a permanent s/XML/sexpr/ in his brain. The world is a much brighter place since then
15:23:54 <yottis> hacing the linked list as something less linked in memory would of course be beneficial
15:24:50 <Berengal> Meady: If you want, try writing grep
15:25:13 <mmorrow> Cale: is this a work-in-progress? (will the code ever be available, or is it dead?)
15:25:29 <Cale> mmorrow: I think it's sort of sidetracked...
15:25:37 <mmorrow> ah
15:25:53 <Cale> mmorrow: From what I understand, he's been working on Data.Rel (and also not releasing code often enough ;)
15:26:09 <Cale> which is a really awesome implementation of relations and lots of operations on them
15:26:39 <Cale> and then iirc, the intention is to use that to express the fundamental algorithms for HOPS, and reimplement it. :)
15:28:43 <Berengal> Should I go to bed, or should I hack?
15:29:02 <Berengal> Eh, who am I kidding... I can hack in my sleep...
15:29:08 <Berengal> Night
15:29:55 <Cale> mmorrow: a neat thing, if I'm remembering it right, is that the evaluation mechanism is directly the pushout for graphs.
15:30:39 <Cale> er, hmm... how did that work again? :)
15:32:15 <Meady> can getLine be used directly
15:32:21 <Meady> or does it have to be assigned
15:32:31 <lpjhjdh> @hoogle Maybe a -> Bool
15:32:32 <Meady> i.e. x <- getLine then filter x
15:32:32 <lambdabot> Data.Maybe isJust :: Maybe a -> Bool
15:32:32 <lambdabot> Data.Maybe isNothing :: Maybe a -> Bool
15:32:32 <lambdabot> Data.Maybe fromJust :: Maybe a -> a
15:33:22 <Cale> Meady: x <- getLine must occur inside a do-block, and it's not quite the same as assignment, it's the notation for running getLine
15:33:35 <Meady> so say i wanted to get an array
15:33:41 <Meady> could i do say..
15:33:41 <Cale> Meady: if you try to pass getLine as a parameter to a function it won't actually be executed
15:33:47 <Meady> ahh
15:33:51 <Meady> that was my next question
15:33:55 <Meady> ok so best method of getting input?
15:34:09 <Cale> f getLine  will pass getLine itself to f, and then f could use it as many times as it wanted, when it wanted (if at all)
15:34:25 <Meady> ah
15:34:26 <Meady> ok
15:34:31 <Cale> But the type of f has to accept an IO action as a parameter :)
15:34:42 <Meady> so what about f = getLine, then base my functoins from F?
15:34:51 <mauke> Meady: no difference
15:34:58 <Cale> f = getLine  just defines the value f to be the same as the value getLine
15:35:04 <mauke> no magic
15:35:19 <Cale> So f is the same action, and still needs to be run to ask the user for a line (which that doesn't do)
15:35:31 <Meady> hmm , ok say i wanted an array of numbers show me show me
15:35:57 <mmorrow> Cale: yeah totally. i'm looking at two of his papers now. interesting
15:36:12 <mmorrow> http://www.cas.mcmaster.ca/~kahl/Publications/TR/Kahl-1997b.html
15:36:18 <mmorrow> http://www.cas.mcmaster.ca/~kahl/Publications/Conf/Kahl-1998d.html
15:36:24 <Meady> myRead = filter (/=0) getLine
15:36:28 <Meady> how would i write that
15:36:50 <Cale> Well, there are at least two problems with that :)
15:36:56 <Meady> Right ok
15:36:57 <monochrom> Please don't compare a string to a number.
15:37:00 <Cale> One is that even if you run it, getLine produces a string
15:37:07 <Meady> Ok
15:37:10 <Meady> Other
15:37:11 <Cale> The second is that getLine isn't a list, but an IO action
15:37:17 <Cale> You could write:
15:37:21 <Meady> ok
15:37:29 <Meady> [x] <- getLine?
15:37:34 <Cale> myRead = do x <- getLine; return (filter (/= '0') x)
15:37:43 <mmorrow> Cale: ah nice, so he is around then (Data.Rel)
15:38:06 <Cale> mmorrow: I haven't seen a release of his version of Data.Rel yet either
15:38:46 <Meady> i noticed ; there?
15:39:03 <mauke> yes, you did
15:39:10 <monochrom> No, you didn't.
15:39:20 <Meady> lol
15:39:22 <mauke> believe in yourself!
15:39:45 <monochrom> Question all those who don't question themselves.
15:40:02 <Gracenotes> :O :O :O
15:40:03 <Meady> Lol monochrom sounds depressed
15:40:04 <Meady> :s
15:40:12 * mauke questions himself
15:40:40 <monochrom> And you sound drunk.
15:41:17 <Cale> Meady: you could also have put a newline and lined up the second line of the do-block with the first
15:41:24 <Cale> myRead = do x <- getLine
15:41:33 <Cale>             return (filter (/= '0') x)
15:41:54 <Cale> (the x and r should line up)
15:41:55 <Meady> Lol monochrom love you too
15:50:43 <MJackscoon> Tired of Niggggers and their monkeyshines?  Recognize that the shitskin Homo Erecti are wrecking civilization?  Then discuss the politics feral Negro Beast with us at Chimpout.com!  http://www.chimpout.com/forum
15:51:29 <mmorrow> @ops
15:51:30 <lambdabot> Maybe you meant: docs oeis pl
15:51:33 <mmorrow> @where ops
15:51:34 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
15:51:34 <lambdabot> mauke
15:51:44 <mauke> oh, wtf
15:52:03 * dcoutts was slightly too late
15:52:17 <allbery_b> grrr
15:52:23 --- mode: ChanServ set +o mauke
15:52:23 <copumpkin> gotta love those guys
15:52:23 --- mode: mauke set -o mauke
15:52:26 <Peaker> @type getLine
15:52:27 <lambdabot> IO String
15:52:29 <mauke> back in business
15:52:30 <Peaker> Strict?
15:53:47 <MJackscoon> Tired of Niggggers and their monkeyshines?  Recognize that the shitskin Homo Erecti are wrecking civilization?  Then discuss the politics feral Negro Beast with us at Chimpout.com!  http://www.chimpout.com/forum
15:53:58 --- mode: ChanServ set +o mauke
15:53:59 --- mode: mauke set +b *!*@ip72-207-14-105.sd.sd.cox.net
15:54:19 <Peaker> troll or "activist"?
15:54:59 --- mode: mauke set -o mauke
15:55:02 <monochrom> I bet it will come back with a different hostmask but the same nick.
15:55:54 <mauke> as long as he keeps triggering my highlight and I'm active, he's not going to stay very long :-)
15:56:57 <mauke> wait, "Homo Erecti"? latin fail
16:01:23 <Twey> What is a ‘monkeyshine’?
16:01:29 <Twey> Do I want to know?
16:01:39 --- mode: ChanServ set +o mauke
16:01:57 <mauke> wat
16:02:16 --- mode: mauke set -o mauke
16:02:30 <Twey> Haha
16:02:34 <dons> int-e: http://hackage.haskell.org/package/isevaluated-0.3 doesn't work with new vacuum
16:02:43 <mauke> I don't know how that happened
16:03:00 <Twey> ChanServ likes to do that sometimes
16:03:42 <monochrom> A secret admirer is telling ChanServ to op you.
16:03:50 * Twey chuckles.
16:10:26 <mmorrow> hehe, this javascript is amusing:
16:10:36 <Meady> anyone here coded alot in python, and fancy giving their opinion vs haskell
16:10:40 <mmorrow> (run in browser address bar)
16:10:43 <mmorrow> javascript: me='go=function(){mk=function(tag){return(document.createElement(tag))};a=mk("textarea");a.cols=60;a.rows=20;dump=document.body;b=mk("button");b.innerHTML="!";dump.appendChild(b);dump.appendChild(mk("br"));dump.appendChild(a);dump.appendChild(mk("br"));a.clr=function(){a.value=""};a.eval=function(){a.value=eval(eval(a.value))};b.onclick=a.eval;a.value=me};go()';eval(me)
16:10:48 <mmorrow> </jspam>
16:11:33 <monochrom> So I should execute it to see what's amusing?
16:12:02 <mmorrow> it gives you a textarea and a button. clicking the button replaces the textarea text with the result of evaluating that text.
16:12:03 <monochrom> Is the space between "javascript:" and "me" important?
16:12:15 <Twey> No
16:12:16 <Badger> I just get a little ! button.
16:12:19 <ziman> it says undefined here
16:12:23 <Badger> ^ this
16:12:27 <mmorrow> it starts out by putting the code for itself as the textarea text
16:12:42 <mmorrow> (erase that unless you want clicking the button to duplicate the textarea)
16:12:49 <ziman> oh, is it a quine?
16:12:53 <copumpkin> Meady: I've coded a lot in ruby, which is pretty similar really :)
16:12:53 <mmorrow> kindof
16:13:03 <GaryWW> PinchMe
16:13:04 <monochrom> Interesting.
16:13:16 <mmorrow> it's a little buggy atm
16:13:39 <mmorrow> monochrom: instance js "interactive" editor ;)
16:13:49 <mmorrow> *instant
16:13:58 --- mode: ChanServ set +o mauke
16:13:59 --- mode: mauke set -b *!*@ip72-207-14-105.sd.sd.cox.net
16:14:14 <mmorrow> ah, one cool thing is that (in firefox) if you enter and eval a function, it replaces the text with a prettyprinted version of itself
16:14:46 <mmorrow> oh wait, it might be broken
16:14:52 <mmorrow> dah
16:14:54 <mmorrow> gah
16:14:59 --- mode: mauke set -o mauke
16:15:13 * mmorrow is trying to one-linerify this many-more-than-oneline script he has
16:15:24 <mauke> mmorrow: https://www.squarefree.com/bookmarklets/webdevel.html
16:15:41 <mmorrow> mauke: ah yeah, that stuff's good
16:16:06 * mmorrow uses the js shell and jsenv 
16:16:11 <Meady> copumpkin, which do you prefer and which one seems better for majority
16:17:24 <copumpkin> Meady: haskell and haskell :) unless of course by better you mean short-term ease
16:18:04 <Twey> Meady: I have coded a lot in Python
16:18:13 <Twey> (I still do code a fair bit in Python)
16:18:18 <Twey> It's an okay little language
16:18:24 <Twey> I prefer Lua
16:19:12 <Peaker> Twey: what stuff do you prefer Python for over Haskell?  I prefer Python's interactive shell setup (More useful stuff imported)
16:19:29 <Peaker> and I think Python's got better names for stuff in the stdlib (easier though, as stuff is more concrete)
16:19:45 <SubStack> more library bindings
16:19:59 <SubStack> haskell is coming along in that regard however
16:20:02 <Adamant> third coming of COBOL
16:20:07 <Twey> Peaker: I use it for web programming, because the Web frameworks are more mature
16:20:13 * Adamant ducks
16:20:22 <SubStack> >q >q >q >q >q
16:20:31 <Twey> (I'm aware that's a bit self-fulfilling, but hey, bread on the table)
16:21:02 <Peaker> The web is so horrible :-(
16:21:14 <SubStack> it's true
16:21:21 <Adamant> bulldoze it and start again!
16:21:23 <SubStack> scary place
16:21:51 <Adamant> we want lush greenfields
16:22:23 <Twey> Haha
16:23:15 <SubStack> nuke it from orbit
16:23:52 <Adamant> neutron or cobalt?
16:24:02 <SubStack> either way
16:24:07 <SubStack> both maybe, just to be sure
16:24:19 <Adamant> I think we want to rebuild
16:28:18 <Meady> Twey what would you pick from python and haskell
16:28:23 <Meady> for majority of tasks
16:28:27 <Twey> Haskell
16:28:45 <Meady> by far?
16:29:25 <lament> what would you pick from python and haskell for minority of tasks? :)
16:29:41 <Peaker> If I want to get something done real quick, I'd typically go for Python, because I have so much more experience with Python, and debugging tiny stuff like that in Python is easier than debugging mysterious "Occurs checks", and reliability isn't that important :-)
16:29:41 <copumpkin> (I would do the same, and have been for the past few months, even though I was a total rubyhead before, using c for things that needed to be fast)
16:30:12 <Meady> yeah
16:30:13 <copumpkin> I mean haskell, not python btw :P
16:30:29 <Meady> so haskell is definately worth getting into for general programming not just maths or low level
16:30:37 <copumpkin> yeah
16:30:48 <Peaker> for anything serious or fun (not a quick <1hr thing) I'd prefer Haskell
16:31:21 <Peaker> if I had a nice scripting Prelude set up, and some more Haskell mojo, maybe I'd prefer that over Python even for tiny tasks :-)
16:31:33 <Peaker> Python's Prelude is much nicer for scripting than Haskell's
16:31:36 <Nafai> Peaker: What kinds of things would you have in your scripting Prelude?
16:31:52 <copumpkin> a quick regex quasiquoter would be nice for scripting
16:32:06 <jcreigh> quasiquoter?
16:32:07 <Peaker> Nafai: more file access stuff, generators (consumers/producers), regexps, most of lambdabot's
16:32:25 <jmcarthur> i have a lot of background in imperative languages, but now that i know haskell i don't see how i could ever willingly go back
16:32:27 <copumpkin> jcreigh: might as well :P it could take capturing groups and make the regex return tuples of that size
16:32:41 <Peaker> Nafai: Python's "os" module and simple "open" calls are much "heavier" in Haskell, where you import modules nested 3-4 deep
16:33:05 <Peaker> Haskell's regexp stuff is really badly documented, and pretty difficult to understand how to use
16:33:09 <copumpkin> yeah
16:33:34 <Peaker> I spent *hours* trying to figure out how to use the regexps in Haskell, where it takes about 1 minute to figure out the "re" module in Python
16:33:52 <copumpkin> and ruby just has built-in syntax for it
16:34:04 <Peaker> I think that's going too far.. syntax is important to keep simple
16:34:18 <copumpkin> I agree :) but it takes no time at all to figure it out
16:34:50 <Meady> so how long after learning haskell should i get involved in monads
16:34:56 <Peaker> maybe I ought to create a Haskellwiki page about how to use regexps (I might be doing it wrong, but better than nothing)
16:35:12 <copumpkin> Meady: I'd learn monads by example, not by trying to understand them as an abstract entity, unless you're into algebra (in the non-high-school sense)
16:35:22 <copumpkin> (I know monads aren't from algebra)
16:36:13 <Meady> copumpkin, IO is one of my favourite things of programming
16:36:20 <Peaker> Meady: the IO type?
16:36:28 <copumpkin> lol
16:36:36 * georgehorse agrees with not trying to take monads abstractly at first
16:36:41 <game16> can you guys help me read some code?
16:36:47 <Peaker> game16: paste it?
16:36:49 <game16> maximum [p | x <- [100..999], y <- [100..999], let p = x*y, show p == (reverse . show) p]
16:37:08 <game16> i come from a scheme background so uhh
16:37:14 <copumpkin> taking monads abstractly is fine if you enjoy thinking about things abstractly in the first place, but most people coming from imperative languages don't seem to enjoy that
16:37:17 <game16> what does show p == (reverse.show)p
16:37:21 <game16> what does it do? or return?
16:37:31 <copumpkin> > maximum [p | x <- [100..999], y <- [100..999], let p = x*y, show p == (reverse . show) p]
16:37:32 <lpjhjdh> honestly I don't think working with monads from category theory is particularly helpful in understanding their use in haskell
16:37:35 <lambdabot>   906609
16:37:38 <purplepenguins> what do you mean guys, it's only a monoid in the category of endofunctors...
16:37:39 <hzap> game16: it checks that p as a string is the same as it backwards
16:37:48 <game16> what does show do?
16:37:50 <copumpkin> game16: ah, that's from proejct euler, I remember that number
16:37:53 <copumpkin> > show 5
16:37:54 <lambdabot>   "5"
16:37:55 <copumpkin> > show 512
16:37:57 <lambdabot>   "512"
16:37:57 <hzap> convert to string
16:38:01 <game16> oo
16:38:03 <georgehorse> copumpkin: yeah. but I think those people mostly aren't the ones who come here while working on project euler, they know what they're looking for.
16:38:05 <game16> ok danke
16:38:09 <Meady> Nono , file IO, socket IO, and mainly User IO
16:38:10 <copumpkin> georgehorse: yeah :)
16:38:46 <game16> I did it in java with so much ugly stuff, had a giant function to flip the string and a guy showed me this tiny haskell
16:38:51 <game16> and now i'm porting it to APL
16:39:19 <Peaker> game16: that's a list comprehension. List comprehensions have three kinds of clauses in them:  list traversals (e.g:  x <- [100..999]), "let" clauses ("let p = x*y"), and condition clauses (anything that doesn't have "<-" and isn't let), which are booleans and when False, stop working with the current items in the traversla
16:39:23 <bfig> can you instantiate a for all x with an arbitrary object x? is it  Ax phi  -AE-> phi[x/x] ? (in natural deduction of first order logic)
16:39:58 <Peaker> Meady: I can try to explain Monads in an intuitive way that might be different
16:40:07 <Peaker> Meady: what languages do you know?
16:40:21 <Meady> Python
16:40:35 <Meady> C
16:42:04 <Peaker> Meady: lets take C -- in C you have "statements" that are separated by ";" right?
16:42:12 <Meady> yep
16:42:24 <Peaker> Meady: Can you imagine these "statements" being values, and ";" being an operator that joins them together?
16:42:34 <Peaker> Meady: into larger and larger statements?
16:42:41 <Meady> hmm
16:42:47 <Meady> 10;20;30 = 60?
16:42:58 <Peaker> Meady: 10, 20, 30 are just ints, not statements
16:43:06 <Peaker> Meady: printf("Hello world!\n"); is a statement
16:43:20 <Meady> ahh i see, sorry i thought you ment values
16:43:21 <Meady> ok
16:43:35 <Peaker> Meady: x += 1 ; printf("%d\n", x);
16:43:41 <Meady> ok yeah
16:44:15 <Peaker> can you view  (x += 1) -- the statement (not the thing it evaluates to in C, which is the increased x) as a "statement value" and then the operator ";" as joining it with the call-printf statement?
16:45:01 <Meady> ok
16:45:14 <Peaker> Meady: now in C, ; has this hard-coded behavior of (perform this, and then perform that), right?
16:45:21 <Peaker> Meady: (if you look at it as an operator)
16:45:50 <Meady> sequential yeh
16:46:08 <Peaker> Meady: imagine C allowed you to redefine how ; joins statements together into larger statements
16:46:23 <copumpkin> backwards! :P
16:46:49 <Peaker> Meady: redefining ; as well as adding some new interesting statements you can use, allows you to define a whole new "imperative programming language"
16:47:08 <Meady> redefining it to what
16:47:13 <Peaker> Meady: instead of a language that can only join statements together sequentially, you can have a language that does more interesting stuff with the joined statements
16:48:13 <Cale> well, you also have to change your notion of what statements are at the same time...
16:48:16 <Peaker> Meady: for example -- you can define statements as little programs that yield multiple results, rather than a single result, and ";" as taking a program with multiple results, and applying the next-statement to each possible result, and then resulting in all possible results of both (cartesian product)
16:48:30 <Peaker> Cale: I'm still going for the "intuitive feel" thing :)
16:48:31 <Cale> > do x <- [1,2,3]; y <- [4,5]; z <- [6,7,8]; return (x,y,z)
16:48:33 <lambdabot>   [(1,4,6),(1,4,7),(1,4,8),(1,5,6),(1,5,7),(1,5,8),(2,4,6),(2,4,7),(2,4,8),(2...
16:48:55 <Cale> There's the list monad :)
16:48:57 <Peaker> > do { x <- [1,2] ; y <- [3,4] ; return (x,y) }
16:48:58 <lambdabot>   [(1,3),(1,4),(2,3),(2,4)]
16:49:15 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
16:49:16 <Peaker> Meady: following that?
16:49:17 <lambdabot>   ("hello","olleh","HELLO")
16:49:25 <Cale> there's a different monad, the function monad :)
16:49:45 <Peaker> I like the view of monads as "programming languages" (even though its a bit of a stretch in some monads)
16:49:49 <Meady> Peaker just trying to understand multiple resutls
16:50:05 <Peaker> Meady: Do you know non-deterministic automatons?
16:50:06 <Meady> how would it yeild multiple results
16:50:11 <Cale> Meady: so x <- [1,2] means that x is chosen from the list [1,2] in all possible ways
16:50:20 <Cale> Meady: and we collect up a list of the results
16:50:36 <Meady> okok
16:50:43 <Meady> hmmm
16:50:44 <Meady> cale
16:50:44 <Peaker> Meady: Lets say each statement executes part of the computation, at which stage it is still unsure what the right result is, so it yields all the possible results -- the next statements can continue from there, pruning/adding more possible results
16:50:49 <Cale> > do x <- [1,2,3]; y <- [1..x]; return (x,y)
16:50:50 <lambdabot>   [(1,1),(2,1),(2,2),(3,1),(3,2),(3,3)]
16:50:56 <Meady> doesnt ahtat mean x has 2 values
16:51:05 <Cale> yes
16:51:15 <Peaker> 3
16:51:26 <Cale> Well, depends which thing we're talking about :)
16:51:34 <Cale> if you're talking about x <- [1,2], then yes :)
16:51:46 <Meady> Cale, x is is chosen from the list, so 1,2, 2,1?
16:51:52 <Peaker> Meady: in C, statements are pretty dull.   They execute some side effects, and then they have a single result - and combining them just executes the side effects in order
16:52:00 <Meady> yeah
16:52:23 <Cale> Meady: You can either think of it as being that the rest of the computation is a loop over the possible values of x
16:52:29 <Cale> (first x is 1, then it is 2)
16:52:57 <Meady> yeah
16:53:01 <Cale> Or you can imagine that the world splits in two, and in one universe, x is 1, and another universe x is 2, and in the end, we collect all the results from the different universes
16:53:06 <Meady> x so is 1, do the statment, then x is 2 do it again
16:53:07 <Meady> etc
16:53:18 <Peaker> Meady: In Python, in contrast to C, statements can raise exceptions, which stops running statements after the throw, right?
16:53:32 <Meady> yeah
16:53:57 <Cale> But what really happens is that the rest of the computation is treated as a function from the value of x to a list, and there's a concatMap of that function over the list of possibilities for x
16:54:16 <Peaker> Meady: You can more formally define the "can-throw" property of statements, as saying that the statements may have a result, or may have an error.  And then say that ";" uses the right-hand statement only if the left one is success, and not an error
16:54:29 <Cale> > concatMap (\x -> do y <- [4,5,6]; return (x,y)) [1,2]
16:54:31 <Meady> ok examples guys
16:54:31 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6)]
16:54:40 <Cale> same as:
16:54:41 <Meady> ok simple examples guys
16:54:42 <Peaker> Meady: so if C had more programmable statement types and a programmable ";", you can define statements that way, and ";" to join them that way, and you could implement exceptions in C itself
16:54:42 <Meady> lol
16:54:49 <Cale> > do x <- [1,2]; y <- [4,5,6]; return (x,y)
16:54:50 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6)]
16:55:23 <Cale> concatMap f xs  is just the same as  concat (map f xs)
16:55:41 <Meady> ok im lost now
16:55:42 <Meady> ;s
16:55:44 <Peaker> Meady: You can view the exception mechanism as two things: A) Statements can suddenly have fail result type in addition to success results  B) ";" doesn't use right-side-statement if left is fail type
16:55:58 <Peaker> Meady: I'm still in the imperative language world, where you should be familiar :-)
16:56:03 <Meady> i was with you till thhe can trhow , then the left and right confused me
16:56:04 * Cale makes a fun picture...
16:56:08 <Meady> although i did read
16:56:10 <Meady> Left val
16:56:15 <Meady> Right err
16:56:16 <Peaker> Meady: ah, left/right I mean left and right side of ";"
16:56:25 <Meady> right ok
16:56:31 <Peaker> as in:  left_statement ; right_statement
16:56:58 <Peaker> Meady: so C just chains these statements one after the other.  If it instead CONDITIONALLY chained them only if left_statement is not an error result, then it would have exceptions
16:57:01 <Meady> peaker simple example
16:57:15 <Peaker> Meady: exceptions are a rather simple example
16:57:23 <Peaker> Meady: do you understand "try" "raise" "except" in Python?
16:57:53 <Meady> try and catch, can you explain it in java?
16:58:08 <Peaker> Meady: try/throw/catch in Java are pretty much the same
16:58:10 <Meady> i did try { statement } catch (exception e) { print error}
16:58:12 <Meady> yeah ok
16:58:26 <Peaker> Meady: So Java also has the ";" operator that joins statements together
16:59:03 <Cale> http://cale.yi.org/share/contn.png -- have a look at this
16:59:05 <Peaker> Meady: if you have:  f = do { g; h; i; }      and h = do { a ; throw ; c }
16:59:13 <Cale> See the yellow marked piece?
16:59:41 <Cale> We can think of that part as being a function from the value for x, to what is ultimately a list.
17:00:06 <Meady> Ok i see that picture
17:00:09 <Peaker> Meady: then if the ";" doesn't use the right-statement if the left one was a fail, then that throw will cause "c" not to run, then the whole of "h" will also become a failure, which will cause "i" not to run - and there you have it, an exception mechanism, following?
17:00:48 <Cale> Okay, so what really happens is that this function is applied to each value for x
17:00:51 <ben> Can you catch errors invoked by, well, error, somehow?
17:00:53 <Meady> ok i dont get it now
17:00:56 <Cale> and then the resulting lists are concatenated
17:00:56 <Meady> Im stuck on the picture
17:01:20 <Cale> okay, the function which the yellow region corresponds to is  \x -> do y <- [4,5]; return (x,y)
17:01:54 <Cale> (maybe ignore what that function is actually doing for the time being, the important thing is that it takes x, and produces a list which is based on that)
17:01:58 <Peaker> Cale is taking the explanation to a different place...
17:02:15 <Cale> Peaker: well, I think it's in some ways the same place...
17:02:15 <Peaker> I was going for an experimental kind of explanation :-)
17:02:33 <Peaker> (build up a generalization of ";" in their own language, without introducing too many Haskell terms)
17:03:30 <Cale> Let's try that function...
17:03:38 <Meady> ok i understand x takes a list
17:03:41 <Cale> > (\x -> do y <- [4,5]; return (x,y)) 5
17:03:43 <lambdabot>   [(5,4),(5,5)]
17:03:48 <Cale> > (\x -> do y <- [4,5]; return (x,y)) 30
17:03:49 <lambdabot>   [(30,4),(30,5)]
17:03:50 <Peaker> Meady: I was trying to get at the point that the Java ";" is different from the C ";" (for example, its ability to propagate exceptions), and that lots of language features require amending the ";" operator (and the statements you can can have).  Think how wonderful it would be if you could generalize the ";" operator and implement it yourself, instead
17:04:35 <Peaker> Meady: then you wouldn't need Java and C to be separate languages.. You could just have a single language with 2 different implementations of ";" to get both languages as embedded expressions
17:04:56 <Cale> Meady: In the case of the displayed computation, x is supposed to take the values 1, 2, and 3
17:05:02 <Cale> So...
17:05:04 <Cale> > (\x -> do y <- [4,5]; return (x,y)) 1
17:05:06 <lambdabot>   [(1,4),(1,5)]
17:05:07 <Cale> > (\x -> do y <- [4,5]; return (x,y)) 2
17:05:09 <lambdabot>   [(2,4),(2,5)]
17:05:09 <monochrom> You can refer to dons's "programmable semicolon".
17:05:09 <Meady> im still not following :S?
17:05:10 <Cale> > (\x -> do y <- [4,5]; return (x,y)) 3
17:05:12 <lambdabot>   [(3,4),(3,5)]
17:05:33 <Cale> Those are the results of applying the function represented by the yellow box to each of those values
17:05:56 <Cale> and what it does is to concatenate those results together
17:06:12 <Cale> > do x <- [1,2,3]; y <- [4,5]; return (x,y)
17:06:13 <lambdabot>   [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
17:06:27 <Cale> and you can see that they're all in one big list there
17:06:43 <Meady> ij
17:06:46 <Meady> i get that
17:07:23 <Cale> So, each line of the do-block, it's doing that over and over
17:07:23 <Meady> ok Peaker, im failing to understand the left ; right
17:08:06 <jmcarthur> it's hard for two people to explain one thing to one person with two different trains of thought :P
17:08:11 <Cale> More or less taking the result(s) of the first computation, and applying the function represented by the rest of the do-block to them
17:08:23 <Meady> pmpm
17:08:28 <Cale> Yeah, sorry if I'm in the way :)
17:08:29 <Peaker> Meady: your Java program is basically a lot of  a ; b ; c ; d ; e.    you can see those as:  a ; (b ; (c ; (d ; e))))     so a is left, and (b ; (c ; (d ; e)))) is right, and in there b is left and (c ...) is right
17:09:00 <jmcarthur> Peaker: i like the direction your experiment is going, btw
17:09:02 <monochrom> But it's beautiful fugue.
17:09:14 <jmcarthur> monochrom: :)
17:09:20 <Meady> right ok
17:09:21 <Peaker> Meady: Java has classes and stuff which kinda hinder my point, but lets try to think of a Java program as a series of statements separated by ; perhaps allowed to have subroutines that are defined in the same way
17:09:27 <ben> (Is it a ; (b ; c) or (a ; b) ; c in Haskell?)
17:09:29 <Peaker> jmcarthur: thanks
17:09:31 <Meady> so if a fails, b will never happen which means c will never etcetc
17:09:40 <mauke> ben: does it matter?
17:10:03 <Peaker> Meady: yes, all you need is a smart ";" to get exceptions to propagate and stop a computation from continuing to execute
17:10:13 <monochrom> (An associative law of >>= implies a ; (b ; c) is (a ; b) ; c in Haskell. It doesn't matter.)
17:10:15 <Peaker> Meady: that and statements that can fail, of course
17:10:34 <Meady> Peaker, why would we want to kill the running
17:10:45 <ben> mauke: I think it vaguely does relating to the amount of right-hand sides that have to be specifically ignored in case of an exception
17:10:52 <Peaker> Meady: that's what exceptions do -- they stop executing whatever happens after the "throw"
17:10:56 <Peaker> Meady: until someone catches
17:11:00 <mauke> ben: right
17:11:14 <Peaker> Meady: do you understand exceptions (throw/try/catch) well?
17:11:25 <mauke> ben: (>>) is right associative, but nothing keeps you from grouping it to the left yourself
17:11:32 <jmcarthur> Peaker: another easy one for this experiment might be possibly-null return values
17:11:34 <ben> That looks messy
17:11:49 <Peaker> jmcarthur: yeah, those are basically exceptions that have no error information
17:11:57 <Meady> not amazingly, i understand how to use them
17:11:58 <ben> Can lambdabot do the equivalent of ghci's :info?
17:12:03 <mauke> ben: no
17:12:14 <Meady> ok ive only used try catch
17:12:24 <Peaker> Meady: then you understand that if code uses "throw" then code that appears after it will not execute, right?
17:13:11 <Peaker> def f(filename): if not os.path.exists(filename): raise "File does not exist!" ; os.unlink(filename) ; ...
17:13:22 <Peaker> Meady: in this example, you don't want the unlink to run if raise occurred, right?
17:13:57 * Peaker has to go.. 
17:13:59 <Meady> right ok
17:14:09 <Meady> example
17:15:21 <jmcarthur> i am in the rare position of having the opportunity to try and teach somebody functional programming who hasn't done much programming otherwise. just for the record, she has not seemed to have had the same problems learning it as most imperative programmers have. this is more evidence of my suspicion that functional programming is not inherently difficult to understand, only foreign to seasoned imperative programmers
17:15:25 <Zrs> do x<-[1,2,3]; y<-[4,5,6]
17:15:31 <jmcarthur> .. did that truncate?
17:15:37 <Zrs> > do x<-[1,2,3]; y<-[4,5,6]
17:15:38 <lambdabot>   <no location info>:
17:15:38 <lambdabot>      The last statement in a 'do' construct must be an ...
17:15:44 <Zrs> Is she into math in a big way?
17:15:52 <jmcarthur> not especially
17:16:06 <noteventime> jmcarthur: "...seasoned imperative programmers"
17:16:13 <Meady> Peajer
17:16:15 <Meady> Peaker*
17:16:24 <jmcarthur> noteventime: ah, that is correct. thank you
17:16:48 <Zrs> The last statement must be a ...? Well ...
17:17:21 <noteventime> Meady: Having trouble with Monads?
17:18:59 <Meady> well trying to understand
17:19:01 <aavogt> Zrs: an expression?
17:19:38 <noteventime> Meady: Did you check out the Maybe instance?
17:19:57 <Meady> nope
17:19:58 <Cale> jmcarthur: Yeah.
17:20:07 <Meady> Peakers was explaining it then vanished
17:20:09 <Cale> jmcarthur: I've had the same experiences.
17:20:34 <noteventime> Meady: http://www.haskell.org/all_about_monads/html/maybemonad.html <- Check out the definition
17:20:36 <Cale> jmcarthur: In fact, I taught about monads in programming to some 11 year old kids, and they had no trouble.
17:20:45 <noteventime> Meady: Tell me if it doesn't help
17:21:02 <Meady> Had alook on cales site too
17:21:07 <Meady> just taking a random peak
17:21:30 <Meady> Cale, cheers mate, makes me feel alot better to know im 7 years older and stuggling :D
17:21:41 <noteventime> My trouble with Monads was that I thought they were applicative functors at first :p
17:21:49 <Cale> Meady: It's possibly *because* you're 7 years older that you're struggling ;)
17:22:23 <Cale> Meady: nah, but really it's not so bad... let me do things a bit more systematically.
17:22:34 <noteventime> Later I realised I had been trying to do some native kind of monads using templates in C++
17:22:36 <Cale> What are we aiming at understanding here? Monads in general?
17:22:37 <Meady> Actually feel alot shitter than i did :d
17:22:43 <noteventime> naive*
17:22:48 <Meady> dont worry cale, ill go read
17:22:49 <Meady> :s
17:22:59 <athos> > fmap (+2) (3,5)
17:23:00 <lambdabot>   (3,7)
17:23:37 <Cale> Meady: Well, I have two monad tutorials that I wrote, and another tutorial which isn't really about monads, but covers the very basics of I/O quickly.
17:23:45 <Cale> http://www.haskell.org/haskellwiki/Monads_as_Computation
17:23:54 <Cale> http://www.haskell.org/haskellwiki/Monads_as_Containers
17:23:59 <Cale> http://www.haskell.org/haskellwiki/Introduction_to_IO
17:24:07 <Meady> Already reading them now
17:24:13 <Cale> Great :)
17:24:45 <Meady> Also looking for something sharp after that comment about the 11 year olds
17:25:05 <ray> where did you find these 11 year olds?
17:25:11 <sm> go Meady, go.. but like I said, also take your time - you can't absorb haskell in a day
17:25:27 <pikhq> Takes 4 days. :P
17:25:31 <ray> they must never have been anywhere near american public schools
17:25:56 <pikhq> ray: Hey, I was quite intelligent at 11 years old and I went to American public schools.
17:26:16 <monochrom> Cale says he can teach real analysis and haskell to 3-year-old blank slates no problem. :)
17:26:31 <pikhq> ... Granted, I tended to ignore the teachers and just read the whole freaking textbook.
17:26:45 <ray> if you didn't flunk out, i don't trust you :)
17:27:13 <ray> unless you're over 40, then you might be ok
17:27:15 <pikhq> ray: I flunked a couple of courses due to my parents going through an epically nasty divorce.
17:27:27 * SamB finds most of his classes pretty boring because they mostly donseem 
17:27:33 <SamB> er ...
17:27:41 <koeien> CS?
17:27:42 <SamB> because they mostly don't seem advanced enough ...
17:27:47 <SamB> no, EE
17:28:00 <lpjhjdh> being a student of american schools I agree with you ray
17:28:16 <pikhq> For the most part, though, American schools suck.
17:28:23 <koeien> hmm, i know next to nothing about EE :/ only intro to electromagnetics
17:28:31 <pikhq> It was quite saddening to see students who read English about as well as I read Japanese.
17:28:37 <SamB> hey, I was home schooled ;-)
17:28:51 <pikhq> (I'd say my Japanese is about on par with a somewhat below-average 2nd grader)
17:28:59 <noteventime> I don't think I've ever heard anything good about American schools X-D
17:29:00 <monochrom> I learned monads when I was 155 years old. I supervised Church's thesis back then.
17:29:03 <noteventime> And I tough tour schools were bad
17:29:04 <SamB> pikhq: they have 2nd grade in japan?
17:29:20 <ray> uh, yes
17:29:27 <pikhq> SamB: Yes, they have a numerical grade system.
17:29:47 <lament> monochrom: only 155? wow, i didn't know Church was that old.
17:30:10 <Cale> The imperfect analogy is that it's like if a computer already has Windows on it, you have to blow it away and then install Linux before you can get anything done. But if it's blank, half the work is already done.
17:30:29 <SamB> Cale: that's a very imperfect analogy
17:30:39 <monochrom> gparted
17:30:45 <ray> it's imperfect because it has windows and linux in the wrong places in the sentence
17:30:47 <SamB> because installing something else over Windows is practically the only way to actually blow it away ...
17:30:55 <SamB> ray: uh ... no!
17:30:56 <monochrom> The problem with people is they can't gparted.
17:31:00 <Cale> SamB: right
17:31:09 <SamB> monochrom: no, I'm fairly certain that's not the problem
17:31:09 <pikhq> ray: You must be a product of American education.
17:31:15 <lament> what this country needs is a good 5-dollar gparted
17:31:19 <SamB> I don't know if I even *use* that
17:31:26 <ray> i spend all my time repairing the damage :)
17:31:32 <monochrom> Set up a virtual machine.
17:31:45 <monochrom> The problem with people is they can't run virtual machines.
17:32:03 <lament> the problem with people is that they don't all just get macs.
17:32:06 <SamB> monochrom: I can, but I find it a pain to get stuff into or out of them
17:32:22 <Cale> lament: and install linux on them?
17:32:27 <pikhq> Yeah, we're like crappy 8086. Don't even have virtual memory.
17:32:27 <koeien> lament: and install debian?
17:32:28 <koeien> lol
17:32:34 <lament> ...
17:32:47 <ray> linux is not funny
17:32:50 <lament> some guy yesterday tried to run fedora on my macbook
17:32:58 <SamB> lament: eh?
17:32:59 <lament> he's an official fedora missionary
17:33:01 <ray> it's a serious problem
17:33:09 <SamB> ray: okay, yeah, it is ...
17:33:15 <SamB> but Windows is *not* the solution
17:33:17 <lament> going around in an "i <3 fedora" t-shirt and trying to get people to use fedora
17:33:25 <pikhq> 19:33 [freenode] CTCP VERSION reply from ray: irssi v0.9-beta - running on Haskell Machine h1
17:33:29 <drhodes> sounds like a plant
17:33:35 <pikhq> ... Are you running a *Haskell Machine*?!?
17:33:39 <monochrom> I used to do that for OS/2 during Toronto Comdex.
17:33:51 <lament> of course, fedora couldn't recognize my wireless card so internet didn't work
17:33:54 <ray> it even uses a lambda potato as the power supply
17:33:59 <Cale> It's what I would do. Having used it 8 hours a day for a few months, I think the OS X user interface leaves quite a bit to be desired. It's possible to fix many of the issues with it using non-free software, but why, if you can just install Ubuntu or Debian? :)
17:34:13 <lament> and then i showed him how OS X already has a bash terminal and left him speechless!
17:34:36 <koeien> OSX is okay, but i don't think it is worth the money. i don't think it is particularly better than other *nixes
17:34:47 <pikhq> lament: So does Darwin. Your point?
17:34:50 <monochrom> Hahaha now he's clueless. Everyone knows OS X has terminal and bash.
17:34:52 <noteventime> OS X doesn't come with an X server, does it?
17:34:54 <Cale> They can't even give you the most basic configuration options like point to focus and multiple desktops out of the box.
17:35:04 <SamB> pikhq: Darwin can do a terminal without OS X ?
17:35:07 <pikhq> noteventime: It's on the "developer's tools" disk.
17:35:13 <noteventime> I see
17:35:21 <pikhq> SamB: Yes, Darwin is a seperate OS.
17:35:28 <Cale> Installing Quicksilver helps a bit, but it's sort of orthogonal to those issues.
17:35:38 <SamB> I thought Darwin was the low-level part of OS X
17:35:39 <lament> Cale: i'm quite convinced that point to focus is ridiculous and people who use point to focus are ridiculous too
17:35:40 <Cale> mm... linearly independent anyway :)
17:35:41 <aavogt> isn't the default shell tcsh, not bash?
17:35:42 <pikhq> It's the same until you get to the GUI.
17:35:48 <SamB> aavogt: what the HECK?
17:35:59 <pikhq> GNU/Darwin has X and Gnome xor KDE, OS X has Cocoa.
17:36:02 <ray> i'm quite convinced "multiple desktops" is ridiculous, but focus follows mouse is ok
17:36:02 <monochrom> What is point to focus?
17:36:05 <pikhq> aavogt: Not since 10.2.
17:36:11 <noteventime> pikhq: I'd have to run a separate X for XMonad, on top of that aqua thing or whatever it's called?
17:36:12 <Cale> lament: It's important if you want to be able to type in a window without bringing it to the top.
17:36:14 <SamB> pikhq: oh, I'm not TALKING about *GNU*/Darwin
17:36:17 <SamB> just Darwin
17:36:18 <Zrs> monochrom: googling about, it's the opposite of 'click to focus' apparently
17:36:26 <monochrom> I see.
17:36:28 <lament> Cale: and i don't know what you mean by multiple desktops but i'm pretty sure OS X supports it.
17:36:33 <pikhq> SamB: "Just Darwin" runs quite nicely, too.
17:36:39 <koeien> lament: yes "spaces" iirc
17:36:40 <aavogt> pikhq: I see
17:36:45 <Cale> lament: I mean virtual spaces where windows reside.
17:36:50 <lament> Cale: so Spaces?
17:36:51 <pikhq> Available on the Apple website somewhere.
17:36:56 <monochrom> I used point to focus for a few months but eventually found it too side-effectful.
17:37:02 <Cale> lament: So it's as if your desktop is n times larger than your monitor.
17:37:15 <pikhq> It doesn't have much beyond what's in a basic BSD installation, but it's certainly available.
17:37:19 <lament> Cale: yes. It's called Spaces. You can find it in your system preferences.
17:37:25 <Cale> At least when I used it, OSX did not come with anything of the sort.
17:37:54 <Cale> (I was using 10.3)
17:37:59 <pikhq> ray: Anyways, what is this that you say of a Haskell machine?
17:38:07 <pikhq> Cale: Recent feature.
17:38:10 <Cale> But it's good if they have at least that now :)
17:38:52 <Cale> The other thing which constantly annoyed me was the inability to tell the filemanager that I wanted to open all files of a given mime type with a given editor, regardless of who created them.
17:39:18 <ray> a haskell machine would be cool, but i don't think i'd like any one that actually existed, because it'd probably just be a stupid skin over unix
17:39:27 <ray> given the state of things today
17:39:30 <Cale> (Disagree with someone over what text editor you'd like to use? Too bad.)
17:39:33 <ray> but i can dream
17:39:52 <koeien> it took me a few minutes to figure out how to unmount an USB-stick
17:39:53 <lament> Cale: i'm pretty sure Get Info -> Open With -> Change All should do it.
17:40:03 <koeien> the first time i used it
17:40:04 <Cale> lament: Until the next file comes along...
17:40:11 <pikhq> koeien: ... umount...
17:40:17 <Cale> lament: I couldn't get it to work consistently and permanently
17:40:30 <pikhq> Cale: Very old Mac-ism.
17:40:35 <Cale> and it's really hard to inspect what the existing setting is
17:40:52 <pikhq> Another very old Mac-ism.
17:40:59 <SamB> stupid resource forks
17:41:01 <lament> you mean "Get Info"?
17:41:14 <Cale> lament: that didn't seem to tell the whole story
17:41:26 <mmorrow> Cale: http://moonpatio.com/images/ast-graph.small.png
17:41:51 <lament> Cale: anyway, just use bash :)
17:42:18 <Cale> lament: right, and then we come to the idiotic terminal emulator which does word wrapping by default :)
17:42:25 <mmorrow> (only have it done for AppE, VarE, ConE so far (TH AST), viewer is the opengl one i've got for vacuum (that's actually really a graphviz graph viewer/renderer in general))
17:42:37 <pikhq> Cale: Just use xterm
17:42:40 * mmorrow needs to put vacuum-gl on hackage
17:42:41 <sjanssen> lament: at that point one might as well use an operating system that doesn't relegate Unix to a ghetto
17:42:43 <dsturnbull> i don't think i've come across a terminal that doesn't wrap
17:42:49 <pikhq> (of course, at that point you may as well install Darwin)
17:42:54 <sjanssen> pikhq: s/Unix/X11/ in my previuos statement :)
17:43:09 <lament> sjanssen: I'm not sure why I would ever use X11.
17:43:18 <lament> it's by far the worst thing about Linux.
17:43:22 <lament> okay maybe not by far.
17:43:25 <koeien> heh
17:43:29 <sjanssen> it's the standard Unix graphical interface
17:43:31 <dsturnbull> xmonad takes away that pain
17:43:32 <lament> it sucks.
17:43:38 <Cale> dsturnbull: It did its own dynamic word wrapping, at word boundaries, rather than just letting characters wrap onto the next line like everything else.
17:43:38 <pikhq> Not the worst thing at all.
17:43:40 <koeien> dsturnbull: no it doesn't
17:43:43 <sjanssen> lament: cite how X11 sucks
17:43:52 <mmorrow> Cale: it should be interesting how some of the graphs look once "let" is handled (case too)
17:43:53 <lament> sjanssen: well how is it good?
17:43:56 <pikhq> The *actual implementation* of it has until recently been the single worst thing about it.
17:44:01 <Cale> mmorrow: that is quite interesting :)
17:44:07 <pikhq> Now it's 'vaguely tolerable'.
17:44:16 <sjanssen> lament: that isn't what you said, but I can rattle off all sorts of responses.  Network transparency, open source implementations
17:44:17 <dsturnbull> Cale: that does not match my test right now
17:44:19 * pikhq still wants X12.
17:44:21 <lament> sjanssen: i don't care about x11 itself too much, it's just a windowing system. It's really the software that uses it that's horrible
17:44:33 <Cale> dsturnbull: Maybe they fixed it.
17:44:43 <Cale> dsturnbull: I was using 10.3
17:44:43 <sjanssen> lament: flexibility -- the window manager isn't tied to the entire stack
17:44:53 <mmorrow> Cale: i'm not sure what do make lambdas look like.. i guess i'll follow how he does them in those diagrams in his papers
17:44:54 <lament> sjanssen: network transparency - i have never used that feature, and the only time i needed it it was too slow to be useful
17:45:04 <koeien> yah i just use VNC
17:45:05 <sjanssen> lament: okay, so please don't say X11 sucks if you can't say why
17:45:08 <mmorrow> (since i can't think of anything)
17:45:13 <pikhq> sjanssen: Now he's referring to the shitiness that is GTK.
17:45:15 <Cale> mmorrow: can you make differently coloured edges?
17:45:26 <pikhq> And possibly also Qt3.
17:45:28 <lament> sjanssen: flexibility - leads to all the windows looking different; UI inconsistency tends to be underestimated in the unix community but if you have a GUI you might as well do it right
17:45:29 <ray> i wish i could ask people not to say windows sucks if they couldn't say why :(
17:45:31 <mmorrow> Cale: oh yes (although i'll have to hack that in to the viewer, should be easy)
17:45:43 <dsturnbull> xmonad fixes that one, lament :)
17:45:47 <mmorrow> that viewer is talking directly to graphviz's C code
17:45:48 <dsturnbull> i.e. no decoration! woo
17:45:57 <koeien> dsturnbull: no that is not GTK's job
17:46:02 <koeien> but metacity / kwm / ...
17:46:12 <pikhq> lament: You might be glad to know that Qt4 doesn't do anything to add to that.
17:46:36 <Cale> ray: For me, it was the way in which I felt entirely cut off from my machine when I left my house if I'd had it booted into windows. The ability to ssh in from elsewhere and do things quickly is quite valuable.
17:46:50 <pikhq> lament: If a Qt 4.(3,4,5? Don't remember) program starts up in, say, Gnome, it renders using GTK.
17:47:00 <ray> yeah, i used to feel that way
17:47:03 <Cale> I know you can probably install cygwin and some ssh server or something.
17:47:05 <ray> i bought a VPS though
17:47:18 <Cale> Also, the way that it doesn't come with anything.
17:47:19 <dsturnbull> windows sucks until i learn powershell
17:47:22 <koeien> or use remote desktop! :)
17:47:23 <ray> that fixes that problem, and it also has a real net connection instead of a home one
17:47:28 <lament> sjanssen: it's not really that X11 sucks, it's that your point about OS X "relegating unix to a ghetto" is ridiculous. Unix has tons of advantages and X11 just isn't one of them.
17:47:38 <Cale> When you install Ubuntu on a machine, it comes with lots of useful software.
17:47:51 <lament> sjanssen: (not to mention that X11 works on OS X perfectly well)
17:47:52 <pikhq> ray: It's not so much that Windows is (inherently) terrible as it is that there's *nothing good about it*, and it's poorly implemented.
17:47:57 <ray> i kinda disagree, i use a bsd base system for my unix
17:47:57 <erikc> Cale: you can blame the american and european governments for that one
17:47:58 <lambdabot> erikc: You have 1 new message. '/msg lambdabot @messages' to read it.
17:47:58 <sjanssen> lament: Apple doesn't integrate many of its features into the Unix substrata
17:48:00 <Cale> and what isn't there is easy to install through the system
17:48:02 <koeien> when you install windows, you don't get IE :)
17:48:10 <koeien> at least win7
17:48:19 <dsturnbull> sjanssen: i don't want to configure wifi through a shitty interface
17:48:21 <Cale> With Windows, it's not even reasonable to ask Microsoft to provide something like that.
17:48:26 <dsturnbull> most of the stuff that's important is unixy
17:48:28 <lament> sjanssen: in my experience, that's also true with linux distros like fedora and ubuntu.
17:48:34 <sjanssen> lament: and they don't use the Unix standards for most of the stuff you can do through the command line
17:48:42 <lament> sjanssen: they all have a bunch of gui tools that are mostly disconnected from the "command line world"
17:48:43 <dsturnbull> you mean the linux standards?
17:48:47 <dsturnbull> l2BSD
17:49:11 <pikhq> lament: The crazy inconsistent GUI shit is getting better; thought you'd like to know.
17:49:23 <sjanssen> lament: that's only true for a very few things, and most of those are gradually liberated from the GUI anyway
17:49:25 <lament> pikhq: yay, but the gnome/kde split is still on?
17:49:33 <sjanssen> eg. NetworkManager has recently become much better about this
17:49:38 <koeien> lament: that is actually a good thing imo
17:49:39 <Cale> On Ubuntu, for the vast majority of software you might want to use, you don't have to go searching on the net for it, download some custom installer and then worry about whether it'll be possible to uninstall the software later.
17:49:45 <koeien> lament: although i hate KDE personally
17:49:51 <pikhq> Qt renders with GTK automagically, and there's at least some people trying to make GTK render with Qt automagically.
17:50:23 <Cale> You find it in the package manager, and you ask for it to be installed, and it's downloaded and installed, and all the packages are very uniform, and they all uninstall properly.
17:50:28 <ray> that argument doesn't really move me
17:50:29 <Saizan_> Cale: open source ftw :)
17:50:30 <koeien> but there are lots of usability problems with apps for linux in general
17:50:36 <Cale> and when there are updates, you get them automatically
17:50:37 <pikhq> And KDE and Gnome are (slowly) improving interoperability.
17:50:40 <ray> on the other hand, you're at the mercy of the package manager now
17:50:48 <Cale> no need to go looking on the net to see if your software has updates
17:50:54 <pikhq> (thanks, Freedesktop.org!)
17:50:54 <dsturnbull> when are you never not at their mercy?
17:50:55 <koeien> e.g., i lately got an error "Something went wrong. Please enter $COMMAND in the command line." WTF *why* don't *you* do that for me?
17:50:58 <lament> Cale: yeah, package managers are probably the most important thing that sets open source unices apart
17:50:58 <Cale> (and then repeat the process)
17:51:09 <dsturnbull> when you have the source and build tools? that's still not windows
17:51:10 <sjanssen> lament: the problems with interface consistency on Linux are greatly exaggerated.  Not many people complain about the differences between Safari, iTunes and standard Cocoa on OS X, do they?
17:51:12 <noteventime> I wonder if open source drivers will result in more interesting operating systems
17:51:38 <ray> the problems with interface consistency are actually greatle exaggerated
17:51:44 <pikhq> sjanssen: OS X is not something you should talk about as being inconsistent.
17:51:44 <lament> sjanssen: probably because there aren't any
17:51:50 <ray> the real problem is the consistency; that is, the consistent suckiness
17:51:56 <pikhq> sjanssen: *Windows* has interface inconsistency, though.
17:51:58 <Cale> ray: Being at the mercy of the package manager is something that I generally want. If I have to get a program from elsewhere, it's less than ideal. I have to do that with GHC, and it's somewhat annoying, but I'll make an exception since it's important to me.
17:51:59 <koeien> itunes on windows is horrible
17:52:04 <pikhq> At least with Linux it's generally one of two things.
17:52:06 <koeien> any windows app is again horrible
17:52:17 <koeien> all web applications are again different
17:52:26 <pikhq> On Windows, there's a standard GUI, the legacy GUI, and a crapton of custom GUIs.
17:52:27 <ray> also, most of my programs check for updates themselves
17:52:36 <pikhq> (Microsoft themselves makes a lot of custom GUIs)
17:52:42 <Cale> ray: They shouldn't have to.
17:52:45 <koeien> pikhq: yes. WMP, live messenger, ...
17:52:51 <koeien> office
17:52:51 <sjanssen> lament: was this very recently fixed?  Last I used OS X several of Apple's applications had looks entirely different from other applications
17:52:53 <Adamant> pikhq: Apple uses custom GUIs in a handful of apps
17:52:57 <ray> it seems reasonable to me
17:52:59 <dsturnbull> now you're at the mercy of the security of some random idiot developer's server, ray?
17:53:18 <lament> sjanssen: looking different is not in itself inconsistency. Looking different is inconsistency when it confuses you.
17:53:23 <wli> opensrc drivers won't automatically make for more interesting OS's because interesting OS's would need radical rewrites
17:53:33 <pikhq> Adamant: They at least look like they belong.
17:53:41 <wli> rewrites of the drivers that is
17:53:45 <Adamant> pikhq: that's highly debatable in some cases
17:53:51 <pikhq> Adamant: In Windows, *everyone* does a custom GUI, and they stand out like crazy.
17:53:52 <sjanssen> lament: so can you provide examples where differences in Linux applications are confusing?
17:53:55 <Cale> ray: I also don't see what you mean by consistent suckiness. I mean, there are problems, sure, but nothing like the problems I've experienced trying to coerce windows machines into doing the simplest of tasks.
17:54:02 <Adamant> and is debated among even fanboys
17:54:03 <noteventime> wli: Open specs then :)
17:54:07 <lament> sjanssen: (and they don't look particularly different since they all use the same gui toolkit)
17:54:18 <ray> i mean x desktops and x applications are all hideous
17:54:22 <lament> sjanssen: stuff like okay and cancel buttons being on different sides of dialogs.
17:54:27 <Cale> ray: Since when?
17:54:36 <SamB> what's that fancy CT word for Java's problem with array subclassing?
17:54:39 <ray> since the beginning of time :)
17:54:44 <Adamant> Cale has a point. they aren't as hideous anymore
17:54:48 <ray> it's not a concern for me
17:54:49 <Adamant> these days
17:54:51 <Adamant> still not great
17:54:53 <pikhq> lament: Which is now only a problem if you use KDE.
17:54:55 <Cale> ray: Essentially all of my programs use the Gnome toolkits, and they're very clean and look good.
17:55:06 <Adamant> I like GNOME
17:55:17 <Adamant> but I like Aqua more.
17:55:33 <ray> visually, it feels like living in a ghetto
17:55:38 <pikhq> KDE and Qt applications now treat GNOME as a different target for its graphics rendering, and swaps the buttons (among other things).
17:55:39 <Cale> eh?
17:55:42 <ray> that's a big reason why i only used console applications
17:55:46 <lament> pikhq: ...whoa
17:55:55 <Cale> ray: It looks quite a lot nicer than windows, but that's just my opinion :)
17:56:07 <ray> it looks about the same as windows 98, maybe
17:56:07 <Adamant> Cale: I tend to agree with you
17:56:11 <pikhq> When KDE went for "portability", they took it all the way. ;)
17:56:16 <Cale> ray: You haven't used it in a while then.
17:56:27 <Pseudonym> Conal, are you around?
17:56:27 <koeien> GTK is ugly!
17:56:33 <conal> Pseudonym: yup
17:56:35 <pikhq> They're trying their best to make KDE apps look native. Always.
17:56:40 <Pseudonym> Cool.  Looking over Data.Boolean.
17:56:40 <Adamant> modern GNOME is heavily based on System 9 and early Mac OS in terms of user interface and visuals
17:56:42 <Cale> koeien: GTK 1, perhaps :)
17:56:45 <ray> i used ubuntu a few weeks ago
17:56:53 <lament> sjanssen: most of my apps are os x native, so copy&paste shortcuts are cmd-c, cmd-v. One app I use is in Java, so the shortcuts are ctrl-c, ctrl-v. I get it wrong every time. Urrrrngh.
17:56:59 <Pseudonym> Just a suggestion, but it seems to me that implication is missing.
17:57:00 <koeien> Cale: nah, never mind, it's just a matter of opinion i guess :) (I use GNOME myself.)
17:57:12 <ray> admittedly ubuntu's color scheme skews it to seeming worse than it is
17:57:13 <Pseudonym> Implication is, in a sense, more fundamental than not.
17:57:25 <mmorrow> i don't like osx because it's owned by a single company, which e.g. locks the soundcard in a vault so they can sell you encrypted music files ==> point being they can do with it what they please
17:57:28 <sjanssen> lament: GTK and Qt are basically in agreement about keybindings, especially the basic stuff like copy and paste
17:57:28 <conal> Pseudonym: oh.  i could define implication via not & or
17:57:52 <pikhq> There's also some work in KDE to make GTK applications try to be native.
17:57:55 <lament> mmorrow: yeah,and apple is quite evil
17:57:56 <Pseudonym> (I'm also trying very hard not to suggest making Boolean a subclass of Topos.)
17:58:09 <pikhq> So, it's definitely getting better.
17:58:12 <Cale> ray: Of course, that's configurable. So are all the GL desktop effects. I usually shut them off, simply because too much eyecandy gets on my nerves, but if you're the sort who likes that kind of thing, you can make things look rather fancy.
17:58:15 <Saizan_> SamB: that you need both covariance and contravariance so they are actually invariant
17:58:16 <Adamant> mmorrow: the biggest single annoyance of OS X is having to reboot every time iTunes upgrades, and it wants to upgrade all the time
17:58:26 <conal> Pseudonym: there's also xor, iff, nand, and nor.
17:58:33 <Adamant> because of DRM garbage
17:58:35 <lament> apple is probably more evil than any other company outside ticketmaster
17:58:44 <ray> the only fancy thing i like is os x expose
17:58:48 <Pseudonym> But the thing is, it seems to me that you want a class that the List monad can be a member of.
17:58:51 <pikhq> lament: Monsanto is more evil.
17:58:52 <mmorrow> lament: it's not that they're evil or they aren't, it's that they can (and do) do what they want wrt giving you access to parts of your machine/the kernel's capabilities
17:58:54 <Cale> ray: yeah, it has that too
17:58:54 <Adamant> no, early-mid MS was much more evil
17:58:56 <lament> pikhq: oh, right
17:58:56 <Pseudonym> Because it is a boolean algebra.
17:58:59 <pikhq> You know the villains from Captain Planet?
17:59:00 <Cale> (I don't like it, myself)
17:59:02 <Adamant> but Apple is not good
17:59:05 <pikhq> THAT'S MONSANTO.
17:59:08 <ray> i *really* hate rotating cubes
17:59:28 <conal> Pseudonym: list is a boolean algebra?
17:59:30 <Cale> ray: The sliding wall is nicer, but I just turn it all off :)
17:59:36 <Pseudonym> I believe so, yes.
17:59:37 <ray> i don't get why the linux desktop had to choose the rotating cube as its mascot
17:59:37 <conal> Pseudonym: meaning de morgan properties apply?
17:59:39 <koeien> yes i switched it also off
17:59:45 <Pseudonym> Let me think about that.
17:59:46 <kacper_> what's dot's notation
17:59:51 <Cale> ray: I'm not sure that it has?
17:59:52 <Adamant> I though the cubes were cute, just probably not the best UI idea from a practical standpoint
17:59:54 <Pseudonym> De Morgan laws apply to Set on some universe.
17:59:54 <lament> monsanto is actually evil, ticketmaster and apple just got lucky and became semi-legal monopolies
17:59:58 <Adamant> Spaces is nicer.
18:00:11 <ray> rotating cubes has been the go-to effect for screenshots etc for a while
18:00:20 <Adamant> lament: Apple doesn't have a monopoly or near-monopoly on anything but MP3 players
18:00:22 <Pseudonym> But in general, Set doesn't have a computable not.
18:00:27 <lament> Adamant: iphones
18:00:29 <conal> Pseudonym: lists of bools, with fmap'd and liftA2'd operations (as any applicative functor)?
18:00:43 <Adamant> lament: big player in smartphone market but not a monopoly
18:00:46 <conal> Pseudonym: rather, lists of booleans?
18:00:46 <Pseudonym> That's Data.Set, not the category Set.
18:00:46 <ray> i actually use it as a shorthand for "fancy desktop effects, specifically on X"
18:00:48 <koeien> Adamant: the iPhone is definitely not a monopoly. Although i never would buy one due to their horrible policy
18:00:49 <mmorrow> lament: oh, i thought you were being sarcastic and implying that i was calling apple evil and you didN'T think they were. :)
18:00:52 <Adamant> tiny drop in the cellphone sea
18:00:54 <lament> Adamant: you know how the iphone app store works? You write software, and then apple chooses whether they'll allow to sell it or not
18:00:57 <Pseudonym> conal: In a MonadZero, return () is true and mzero is false.
18:01:04 <kacper_> what's dot's and pointless notation?
18:01:05 <Cale> It's a little dated now, but I really liked e16's pager.
18:01:14 <koeien> kacper_: pointfree, you mean (sometimes called pointless)
18:01:16 <erikc> and they choose whether to let you sell it AFTER you've invested the money to develop it
18:01:27 <Adamant> lament: I'm not a fan of that policy but it has nothing to do with monopoly status
18:01:27 <kacper_> yes ;)
18:01:33 <koeien> kacper_: e.g. instead of writing    f x = g (h x)   , write   f = g . h
18:01:36 <Pseudonym> Let's think about Maybe instead.
18:01:40 <ray> that stuff is ok
18:01:41 <sjanssen> Cale: which you undoubtably built from a CVS repository :).  Seriously, what's up with the E guys inability to ship anything?
18:01:50 <Pseudonym> not (Just _) = Nothing
18:01:51 <Cale> It had actual little screenshots of your desktops, you could drag windows around, or out of the pager and onto the current desktop.
18:01:54 <Pseudonym> not Nothing = Just ()
18:01:56 <Adamant> if you want to ding Apple for it being a crappy policy though feel free
18:02:00 <Adamant> I agree with you
18:02:01 <Cale> sjanssen: e16 was the stable one
18:02:04 <Pseudonym> Yes, the De Morgan laws apply to that.
18:02:10 <ray> e17 is the vaporware
18:02:12 <Pseudonym> I think.
18:02:15 <Cale> sjanssen: e17 is the one which you have to get from CVS.
18:02:24 <Cale> It's not *entirely* vapourware.
18:02:24 <pikhq> ray: The rotating cube was chosen mostly by a bunch of 1337 'tards.
18:02:24 <Adamant> shouldn't e17 be developed by now?
18:02:34 <sjanssen> Cale: I guess I got confused because e17 has been the next thing for at least 5 years
18:02:35 <pikhq> And e17 is not vapourware.
18:02:38 <Cale> You can actually run it, but it's still not released.
18:02:39 <Pseudonym> I guess that's one catch, isn't it.  In monad-land, not :: (Monad m) => m a -> m ()
18:02:40 <pikhq> *Stable* e17 is.
18:02:41 <Draconx> Cale, FvwmPager can do that, sans the little screenshots.
18:02:44 <Adamant> man, all this hate for hypercubes
18:02:45 <Pseudonym> OK, maybe this is a mad idea.
18:02:46 <pikhq> And e17 is falling behind.
18:02:47 <Pseudonym> bad
18:02:56 * jaredj hates desktop cubes too
18:02:58 <Cale> Draconx: Well, yeah, my little gnome pager does it sort of too.
18:03:02 <pikhq> All of E17's features (and more!) are in KDE 4.
18:03:10 <kacper_> koeien what the difference between point-wise and point-free notations?
18:03:10 <Cale> Draconx: but without the screenshots :)
18:03:17 <koeien> pikhq: including the bugs?
18:03:28 <pikhq> koeien: When did you last use KDE 4?
18:03:29 <koeien> kacper_: point-wise is adding "points"/variables to the left hand side.
18:03:35 <koeien> pikhq: 4.2 beta
18:03:44 <pikhq> KDE 4.0 was buggy, KDE 4.1 less so, KDE 4.2 was actually usable.
18:03:48 <Pseudonym> nm.  Meeting time.
18:03:49 <ray> expose actually gets you something though
18:03:54 <pikhq> KDE 4.3 will quite likely replace KDE 3.5.
18:03:57 <koeien> kacper_: e.g. f x = g (h x)   (pointwise)   f = g . h  (pointfree)
18:04:01 <pikhq> (about time)
18:04:08 <koeien> pikhq: KDE 4.2 crashed on me. it was a beta though.
18:04:24 <pikhq> ray: Exposé would be a much better mascot for Linux's 3D desktop effects.
18:04:28 <Cale> Expose is not so great for people who run a whole bunch of terminal windows.
18:04:37 <jaredj> ^
18:04:40 <pikhq> (yes, it has Exposé)
18:04:52 <ray> those people might benefit from one terminal window + screen
18:05:00 <jaredj> or xmonad
18:05:05 <koeien> pikhq: but in general i hate KDE apps. unusable crap, they don't think about GUI design i guess? (feel free to disagree)
18:05:05 <jaredj> tee hee
18:05:18 <Adamant> I just use Spaces instead of Expose.
18:05:32 <pikhq> koeien: Funny, seems like they do think about GUI design.
18:05:34 <Cale> Adamant: Is spaces any different from traditional multiple desktops?
18:05:36 <ray> expose would be a good mascot, but those rotating cubes took over too soon
18:05:43 <Adamant> Cale: mildly
18:05:50 <pikhq> They just don't seem to think 'versioning' too well. :P
18:05:54 <koeien> pikhq: sometimes. the last time i started kmail, things went horribly wrong
18:05:59 <jaredj> Cale: whooshy scaling makes it feel a little more physical
18:06:03 <Adamant> you hit a button, it expands to a visual of all your desktops
18:06:08 <Adamant> in minature
18:06:15 <Cale> ah, yeah, Ubuntu has that too
18:06:16 <koeien> pikhq: :) lol. better communication would have been better yes :) although also distro's were at fault
18:06:17 <SamB> koeien: that sounds more like a crash than a bad design
18:06:18 <kacper_> koeien So, function is in pointfree notation when there aren't variables in the definition/
18:06:23 <ray> i really like unix a lot more when it's separated from me by an atlantic ocean
18:06:23 <Adamant> can be any rectangular/squarish shape
18:06:25 <Cale> I thought it was a bit cheesy :)
18:06:25 <koeien> kacper_: yes.
18:06:34 <pikhq> koeien: God, distros that added 4.0.
18:06:39 <pikhq> SO DUMB.
18:06:42 <kacper_> koeien that's all?
18:06:44 <Saizan_> kacper_: the points are the variables
18:06:45 <pikhq> Do they actually test anything?
18:06:49 <Saizan_> kacper_: yep
18:06:52 <koeien> kacper_: yes. that is the only difference.
18:06:56 <Cale> I just like having a little picture of my desktops down near the bottom of my screen somewhere that I can click on.
18:07:00 <Adamant> and you can drag windows around and do things in the all desktop visual view
18:07:04 <kacper_> koeien thanks
18:07:11 <Cale> Adamant: right
18:07:15 <koeien> kacper_: sometimes pointfree notation makes it nicer / better visible what is going on, sometimes it only obscures (and then also called "pointless")
18:07:15 <kacper_> Saizan_ thanks
18:07:22 <Adamant> Cale: can GNOME do that now?
18:07:33 <Cale> yeah
18:07:38 <Adamant> when I was using it heavily it couldn't
18:07:40 <Cale> as I recall. I could check.
18:07:53 <Adamant> or at least not very well
18:07:54 <mmorrow> compiz is friggin awesome
18:07:54 <Cale> It's really the fancy windowmanager.
18:08:14 <jaredj> yeah i don't use the fancy wm and i don't get screenshots
18:08:17 <Cale> which I don't use because I don't really need anything of it myself
18:08:18 <pikhq> mmorrow: Compiz is meh.
18:08:20 <pikhq> mmorrow: Kwin is nicer.
18:08:34 <Adamant> you couldn't see the screen but you could drag around opaqe rectangles that represented windows
18:08:42 <jaredj> ^
18:08:44 <ray> the only time i used "multiple desktops" was in xmonad, and that was really just so i could have a dedicated binding to flip to opera and back
18:08:57 <mmorrow> (unfortunately the linux driver for my graphics card though is borked, compiz makes the system lock up cold every twenty minutes requiring literally holding the power button down to restart so i can't use it :(
18:09:01 <Adamant> it wasn't nearly as nice as Spaces
18:09:02 <koeien> pikhq: but i will definitely check out KDE 4.{3,4} sometime again. i'm not married to GNOME although i currently like that better
18:09:10 <mmorrow> (i have a thinkpad x301)
18:09:49 * mmorrow has 7 desktops at the moment
18:10:05 <ray> what's on them?
18:10:06 <Adamant> I have 8
18:10:08 <mmorrow> i like to occasionally have 9, and arrange them in a 2D 3x3 grid
18:10:12 * koeien only 1 active.
18:10:13 <ray> if that's not super personal information or anything
18:10:16 <Adamant> I use a 2x4 grid
18:10:23 <ray> i really don't know what people use all that stuff for
18:10:32 <Adamant> Spaces enforces a sorta-grid
18:10:46 <jaredj> do you sort by apps? - i never understood that mentality
18:10:47 * pikhq uses a tiling window manager
18:10:49 <mmorrow> ray: to organize your workspace
18:11:00 <ray> that's pretty vague
18:11:06 * purplepenguins uses xmonad
18:11:06 <ray> window names would be nicer
18:11:14 <Adamant> I dump similar apps into a window for each thing I do
18:11:15 <SamB> mmorrow: how do you use them to organize your workspace?
18:11:46 <Adamant> browser is in a window, mail and similar is in a window, IM/IRC is in a window
18:11:52 <mmorrow> e.g. i have 10 .c files open on workspace 2, 10 .hs related to A on workspace 1, 3 firefox windows with 20 tabs each on desktop 3, xchat on 7, and a few vnc sessions open on 4
18:11:53 <Adamant> music is in a window
18:12:34 <mmorrow> then i have 5 and 6 open to do something unrelated that comes up
18:12:37 <Adamant> terminals are in a window, machine monitoring is in a window
18:12:38 <mmorrow> with a clean workspace
18:12:41 <koeien> i use a system tray :)
18:12:46 <ray> i see
18:12:48 <koeien> for mail and IM
18:13:02 <ray> i guess i don't do that because i think at the level of windows, not the spaces that contain them
18:13:02 <jaredj> i use xmonad and work in support. terms and firefoxes together, and i sometimes flip to another workspace every time someone hits me up for something new
18:13:35 <kacper_> koeien what's the definition of ((.).(.)) in point-wise notation?
18:13:43 <ray> so it'd be emacs with a billion buffers for me
18:13:55 <Cale> @unpl ((.).(.))
18:13:56 <lambdabot> (\ i b c f -> i (b c f))
18:13:57 <koeien> you mean f = ((.) . (.))
18:13:59 <purplepenguins> yay emacs
18:14:13 <koeien> lambdabot can do it, but it's instructive to add points one by one
18:14:18 <koeien> and try it for yourself.
18:14:23 <mmorrow> ray: i like having multiple buffers in each of multiple instances of an editor
18:14:24 <Cale> indeed :)
18:14:26 <pikhq> Terminals?
18:14:28 <pikhq> Firefoxes?
18:14:51 <Cale> ((.).(.)) f = (.) ((.) f)
18:14:52 <pikhq> I've got one terminal with screen, and one Conkeror session with a bunch of buffers.
18:14:59 <ray> if i wanted to do that, i'd look for a way to group buffers inside my one emacs
18:15:02 <pikhq> (Conkeror is an Emacs-like interface for XULrunner)
18:15:19 <Cale> ((.).(.)) f g = (.) ((.) f) g = ((.) f) . g
18:15:46 <jaredj> i stack up terminal windows in xmonad instead of using screen
18:15:53 <dons> jaredj: that's how I handle inteerrupts.
18:15:55 <Cale> ((.).(.)) f g x = (.) ((.) f) g x = (((.) f) . g) x = (.) f (g x) = f . g x
18:15:56 <jaredj> it makes it necessary for the term to deal nicely with being resized
18:16:08 <heatsink> Adamant: Why do you need a window to listen to music?
18:16:13 <pikhq> I like my terminals to last beyond a single X session.
18:16:13 <jaredj> forces me to gnome-terminal not xterm though xterm displays faster
18:16:18 <pikhq> ... A window to listen to music?
18:16:19 <jaredj> gaaa
18:16:20 <Cale> ((.).(.)) f g x y = (.) ((.) f) g x y = (((.) f) . g) x y = (.) f (g x) y = (f . g x) y = f (g x y)
18:16:24 <ray> any decent terminal can be resized
18:16:31 <pikhq> I've got mplayer.
18:16:33 <Adamant> heatsink: because I use iTunes and it borgs a window
18:16:37 <ray> even on windows, it's browser/terminal for me
18:16:41 <ray> except the terminal is putty
18:16:44 <heatsink> ah
18:16:47 <jaredj> i know guys at work with no less than twelve workspaces, each full of terminals
18:16:58 <jaredj> before they can do something they have to find the workspace they want
18:17:11 <jaredj> click - no not that one; click
18:17:20 <mmorrow> heh
18:17:22 <jaredj> it seems to me like they waste time
18:17:25 <ray> that just sounds disorganized
18:17:32 <Adamant> you can minimize iTunes to something about the size of a minimized VLC window, but it's not very useful
18:17:41 <ray> if they were better they'd have it burned into their metaphorical flesh
18:17:43 <pikhq> If I *really* need another terminal (for another screen session, say?), C-t ! urxvt
18:18:04 <Adamant> I do that, but only when programming
18:18:30 <Adamant> well, actually I use the Emacs term
18:18:31 <pikhq> But in general, I've just got urxvt and Conkeror open.
18:18:39 <pikhq> (I like emacs in-terminal)
18:18:45 <hector> Hello! this is my first time here in #haskell, I got a few questions about a Haskell project, this is the right place isn't it?
18:18:46 <jaredj> i wish i could do my work in plan9
18:18:52 <Adamant> hector: yes
18:18:58 <pikhq> hector: Quite likely, yes.
18:19:11 <Adamant> I wish more OS'es were named after bad sci-fi movies
18:19:13 <Cale> mmorrow: You might want to be more careful about the left-to-right order of the arcs coming out of the nodes.
18:19:13 <purplepenguins> emacs-in-terminal is nice since it saves you having to configure fonts separately
18:19:14 <jaredj> what? haskell?
18:19:19 <ray> i don't use any sort of music-library type programs, because tags on stuff from the internet are ridiculous, and i'd have to go on a big tag-fixing-and-normalizing project first
18:19:27 <heatsink> Huh? I thought I was in #python
18:19:31 <Adamant> ray: Musicbranz
18:19:34 <dancor> #hasklol
18:19:35 <Cale> mmorrow: I'm not sure, does graphviz allow for that?
18:19:38 <monochrom> @hpaste
18:19:38 <jaredj> heh
18:19:39 <mmorrow> Cale: hmm, that's a good point. i'm not sure if that's controllable with graphviz though
18:19:41 <mmorrow> yeah, hmm
18:19:48 <Adamant> brainz even
18:20:01 <Adamant> zombie MP3 player
18:20:06 <jaredj> branz heh.
18:20:17 <purplepenguins> not branes, brainz
18:20:17 <lambdabot> Haskell pastebin: http://hpaste.org/new
18:20:20 <ray> i'd just trade out one set of dubious tags for another, unfortuately
18:20:30 <Adamant> not branes, bran
18:20:35 <hector> great! thanks in advance! I made a GCL (Guarded Command Language) Compiler/Interpreter using Alex, Happy and just Haskell and There are three details I need to fix so it can be ready.
18:20:38 <Cale> ray: There's something we can agree on. I just use the filesystem to organise my music, and I do it meticulously.
18:20:50 <Adamant> ray: it seems fairly decent
18:20:52 <Adamant> and accurate
18:21:02 <Adamant> better than I would do myself quite certainly
18:21:04 <ray> yeah, a filesystem on a seperate drive here
18:21:14 <Cale> hector: great!
18:21:20 <ehird> musicbrainz is highly accurate
18:21:36 <Cale> hector: You should stick around, and feel free to ask any questions you might have.
18:21:37 <Adamant> sometimes it's a little too accurate
18:21:41 <ehird> the only times i've disagreed with it, it was subjective; because both its and my tags were arguably correct :)
18:21:43 <ray> obviously you don't use windows, but xmplay's windows shell integration is helpful to me
18:21:50 <Cale> (It's probably better than all this offtopic conversation ;)
18:21:52 <Adamant> you got the music of a compilation or best-of disc and it hits up the original
18:21:54 <Adamant> alright
18:22:04 <ehird> it does?
18:22:05 * ray feels guilty
18:22:07 <Adamant> *off
18:22:13 <kacper_> koeien do U know why f x = map -1 x have a type but not evaluate?
18:22:16 <Adamant> ehird: it did that to me for several things
18:22:27 <ehird> kacper_: (-1)
18:22:37 <Adamant> because they pulled it straight from it without editing
18:22:43 <jaredj> :t map -1 x
18:22:44 <lambdabot> forall a b. (Num (Expr -> (a -> b) -> [a] -> [b]), Num ((a -> b) -> [a] -> [b])) => (a -> b) -> [a] -> [b]
18:22:50 <Adamant> for the compilation/best-of disc
18:23:01 <Adamant> or at least I assume so
18:23:01 <Cale> ray: I have a bunch of shell scripts for making systematic changes to filenames which I smash any new music with in order to get the filenames into the shape that I like.
18:23:10 <pikhq> ray: I tag and have my tagging program then organise my music in-filesystem.
18:23:13 <purplepenguins> :t map (- 1) x
18:23:14 <hector> THe first one is: Since Haskell is Lazy, my GCL Interpreter is Lazy, but my teacher don't want it to be Lazy. For example, if I make this assigment: foo <- 1 / 0 my interpreter is not gonna catch the division by cero error, unless I use foo for something:, like show foo
18:23:14 <lambdabot>     Couldn't match expected type `[a]' against inferred type `Expr'
18:23:14 <lambdabot>     In the second argument of `map', namely `x'
18:23:14 <lambdabot>     In the expression: map (- 1) x
18:23:25 <jaredj> cale, ray: quodlibet is for our type of music collector
18:23:28 <heatsink> :t map (subtract 1) x
18:23:29 * pikhq needs to go and fix some of the organisation in his files, though.
18:23:29 <lambdabot>     Couldn't match expected type `[t]' against inferred type `Expr'
18:23:30 <lambdabot>     In the second argument of `map', namely `x'
18:23:30 <lambdabot>     In the expression: map (subtract 1) x
18:23:34 <purplepenguins> hmm
18:23:37 <hector> how can I make it strict? i tried using seq but is not working
18:23:41 <kacper_> ehird I meant -1 not (-1)
18:23:48 <ehird> kacper_: you didn't though.
18:23:50 <ehird> kacper_: (-1) is a number.
18:23:53 <ehird> "map -1" = "map - 1"
18:24:11 <kacper_> ehird a = a
18:24:15 <Cale> hector: seq x y will force x to be evaluated before y is made available (it evaluates to y unless x is an error)
18:24:21 <ehird> kacper_: you are wrong
18:24:30 <ehird> "map -1" is "map - 1". "map (-1)" is "map (-1)"
18:24:38 <ehird> it's precedence issues.
18:24:46 <kacper_> ehird I know
18:24:50 <ray> (-1) isn't (subtract 1)
18:24:55 <purplepenguins> -1 means the number one less than zero, - 1 means partially applying (-) with 1
18:24:56 <ray> that function is named subtract, right?
18:25:00 <Saizan_> kacper_: map -1 x means "map - (1 x)"
18:25:02 <Cale> hector: also, I'm not sure that I agree that Haskell's laziness will automatically make your interpreter lazy :)
18:25:03 <ehird> ray: yes
18:25:04 <hector> seq does the work? I tried it and is not working :s... I tried it like this:
18:25:47 <Saizan_> kacper_: and map (-1) x == map (negate 1) x, again not what you want
18:25:58 <Cale> hector: well, if it happens to be lazy, I suppose we can have a look at why... it should be easy to avoid being lazy at that level. It's about the order in which your interpreter chooses to inspect and evaluate expressions.
18:26:19 <Saizan_> kacper_: so, you have to stick with map (\i -> i - 1) x == map (subtract 1) x
18:26:40 <kacper_> Saizan_ I know that (-1) 2 it's not 2 - 1
18:26:47 <ray> you might want bang patterns, if you can use ghc extensions in your class
18:26:52 <ehird> kacper_: "map -1" is not what you want full stop
18:26:57 <Cale> hector: Presumably when your interpreter sees x <- 1/0, it should take steps to evaluate 1/0 in order that it can add a binding for x.
18:27:25 <Saizan_> kacper_: map - 1 means that you are subtracting 1 from map
18:27:29 <Cale> hector: and regardless of Haskell's lazy evaluation, you should discover the error.
18:27:42 <hector> yes it is lazy, I tried it... this is how I'm making the evaluation of a division: evalMultDiv (Divide t f) tabla =
18:27:45 <hector>   let tv = evalMultDiv t tabla
18:27:48 <hector>       fv = evalUnary f tabla
18:27:50 <hector> 		else ((fst tv),(doMath (snd tv) (div) (snd fv)))
18:27:52 <hector>   in
18:27:55 <hector>     if ((snd fv) `seq` ((snd fv) == 0)) then error ("(Linea " ++ show (fst (fst fv)) ++ ", Columna " ++ show (snd (fst fv)) ++ "): Division por cero.\n")
18:28:04 <purplepenguins> > map ((-) 1) [10..20]
18:28:05 <lambdabot>   [-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19]
18:28:20 <Saizan_> kacper_: which doesn't make much sense, but it has a type because the typechecker can't rule out the existence of the corresponding Num instance
18:28:25 <purplepenguins> oops, right function but wrong order of arguments...
18:28:57 <Saizan_> kacper_: because you could define that instance in some other module
18:29:04 <Cale> hector: snd fv `seq` snd fv == 0 is a pointless use of seq. snd fv will already need to be evaluated if you want to test if it's 0
18:29:10 <kacper_> Saizan_ I have exercise to write type of function or tick when it hasnt' a type
18:29:32 <mmorrow> Cale: i think a solution to the graphviz-flipping-the-left-to-right-order of a binary app, is to have different edge styles for the left/right edges from an @ node
18:30:05 <kacper_> Saizan_ e.g f x = [x] : [1]
18:30:07 <mmorrow> (that's the only solution i can see actually, since a single node may be on the left and right of different @ nodes)
18:30:07 <Cale> mmorrow: hmm, that might work okay
18:30:24 <ehird> kacper_: that is not well typed.
18:30:28 <mmorrow> so distinguishing them it would have to be done with the edges i think
18:30:31 <Saizan_> kacper_: it does have a type in this case, unless in your exercises 1 is of type Int or Integer instead of Num n => n
18:30:31 <mmorrow> s/it//
18:30:50 <hector> I figured that out so I did the seq earlier when the first call of evalArithmetic is made and added to the value in the symbol table of the program... When the asignation is made... Isn't that how I'm supposed to do?
18:31:12 <monochrom> @type \x -> [x]:[1]
18:31:14 <lambdabot> forall t. (Num [t]) => t -> [[t]]
18:31:18 <monochrom> is well-typed
18:31:48 <Cale> hector: how does evalMultDiv differ from evalUnary?
18:31:51 <monochrom> I love to explode people's brain.
18:32:11 <kacper_> monochrom but I think that's for all arguments fails
18:32:17 <Cale> hector: is your AST made of half a dozen separate types?
18:32:20 <heatsink> hector, It doesn't do much good to try to make something evaluate at a particular time, by running seq "earlier" or "later".  Rather, you can use seq so that when one thing gets evaluated, other things get evaluated too.
18:32:57 <kacper_> @type \x -> map (-1) x
18:32:59 <lambdabot> forall a b. (Num (a -> b)) => [a] -> [b]
18:32:59 <ehird> monochrom: heh, true that
18:33:07 <Cale> But I don't think the problem here is really seq or not seq :)
18:33:25 <kacper_> @type \x -> x * sin .1
18:33:26 <lambdabot> forall b a. (Floating b, Num (a -> b)) => (a -> b) -> a -> b
18:33:38 <hector> that's right, the AST is separate in many datas and types... MultDiv is for left recursion, while Unary jsut goes straight down to a Factor
18:33:45 <monochrom> Omit the "forall t." part. It's a GHC extension.
18:33:59 <mmorrow> (and it's implicit)
18:34:18 <mmorrow> although you really need it for when you are doing e.g. sizeOf (undefined :: a)
18:34:47 <hector> heatsink: Is there a way of make everything strict evaluated?
18:35:04 <mmorrow> hector: not automatically
18:35:10 <SamB> hector: use ML?
18:35:22 <hector> never have, everything is in Haskell...
18:35:35 <heatsink> hector, No, and It's unclear to me that doing that would solve your problem.
18:35:35 <Cale> hector: The strictness/laziness of Haskell is not your problem here. It will have to be something in the logic of the order in which your interpreter is computing things.
18:35:42 <SamB> that was a suggested method to make everything strict
18:35:43 <mmorrow> hector: you should be able to use bangpatterns in strategic places though to get what you want though
18:36:03 <Cale> hector: Implementing an interpreter in a lazy language doesn't magically make it lazy :)
18:36:18 <mmorrow> oh, are we talking about the interpreted lang here?
18:36:25 <Cale> mmorrow: yeah
18:36:34 <Cale> mmorrow: His interpreted language is too lazy.
18:36:46 <Cale> I think we'll have to see more of the program to tell what's wrong.
18:36:50 <copumpkin> I think I was implemented in haskell
18:37:07 <Cale> Oh!
18:37:12 <heatsink> copumpkin, your parents weren't strict enough?
18:37:24 <Cale> hector: Don't use 'error' to report errors in your interpreter either...
18:37:28 <copumpkin> absolutely not, I had almost negative discipline growing up
18:37:37 <copumpkin> I mean, my parents never used seq, ever
18:37:44 <Cale> hector: You're going to want an actual value which represents failure of an expression to evaluate.
18:37:55 <erikc> copumpkin: about Macho -> ByteString, i dont think it can be done with the current ByteString -> Macho reader / Macho format, cause the read is lossy
18:38:05 <monochrom> @remember copumpkin I think I was implemented in haskell
18:38:05 <lambdabot> Nice!
18:38:06 <Cale> hector: That may have something to do with the problem.
18:38:37 <copumpkin> erikc: yeah, I was thinking about that :/
18:38:37 <monochrom> @help remember
18:38:37 <lambdabot> quote <nick>
18:38:38 <lambdabot> remember <nick> <quote>
18:38:38 <lambdabot> Quote somebody, a random person, or save a memorable quote
18:38:40 <hector> why not? I want it to finish the execution as soon as something like that happends... It is lazy beleive me, I didn't do it on purpose
18:38:54 <hector> @help
18:38:55 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
18:38:58 <monochrom> @forget copumpkin I think I was implemented in haskell
18:38:58 <lambdabot> Done.
18:39:00 <hector> help
18:39:12 <copumpkin> halp!
18:39:13 <monochrom> @remember copumpkin I think I was implemented in haskell. I mean, my parents never used seq, ever
18:39:13 <lambdabot> Nice!
18:39:13 <Cale> hector: The reporting of that error is lazy, your evaluator isn't :)
18:39:19 <copumpkin> :)
18:39:41 <hector> ok ok that's right hahaha...
18:40:00 <Cale> hector: Don't use a Haskell error to report a program error in your interpreted program. 'error' is perhaps for if something goes drastically wrong in your interpreter, not in the program that it is interpreting.
18:40:05 <mmorrow> lazyAp f x = let g = eval f in Ap g x
18:40:33 <mmorrow> strictAp f x = let g = eval f; y = eval x in Ap g y
18:40:40 <Cale> hector: That sort of error is very difficult to catch and results in the entire program, interpreter and all, dying.
18:41:20 <Cale> hector: What you probably really want is a value which expresses what went wrong with the evaluation, so that you can display a nice message to the user and allow them to continue.
18:41:32 <mmorrow> (those *Ap functions are assuming the eval model is s.t. you can only apply (evaluated) functions to args when building a closure)
18:41:54 <hector> that's exactly what I want. whenever an error is in run time the execution must finish... the errors in the previus parts of the compiler are displayed nicely
18:41:58 <dibblego> is there a canonical name for (fmap . fmap) ?
18:42:03 <mmorrow> err, i guess it's making a few more assumptions too, but that's beside the point :)
18:42:20 <Cale> hector: right.
18:42:23 <purplepenguins> :t (fmap . fmap)
18:42:24 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
18:42:30 <mmorrow> , ppDoc `fmap` fmaps 8
18:42:32 <lunabot>  fmap . (fmap . (fmap . (fmap . (fmap . (fmap . (fmap . fmap))))))
18:42:39 <Cale> hector: So, you're probably not calling error from your parser, I guess? :)
18:43:09 <mmorrow> , $(fmaps 8) (*2) (nesty $(nat 7) (:[]) 42)
18:43:11 <lunabot>  [[[[[[[[84]]]]]]]]
18:43:14 <hector> no, that code I pasted is from the interpreter... The parser and the lexer report it nicely
18:43:22 <hector> the errors*
18:43:25 <dibblego> @type fmaps
18:43:26 <lambdabot> Not in scope: `fmaps'
18:43:32 <dibblego> mmorrow, wtf?
18:43:48 <mmorrow> dibblego: haha
18:43:51 <mmorrow> dibblego: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1302
18:44:01 <dibblego> mmorrow, ta :)
18:44:08 <mmorrow> :)
18:44:44 <mmorrow> dibblego: (and `nesty' being nest from http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2166)
18:44:56 <mmorrow> , [$ty| nest |] {- had to rename it -}
18:44:59 <lunabot>  Int -> Doc -> Doc
18:45:47 <mmorrow> , $(nat 18)
18:45:49 <lunabot>  S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S Z)))))))))))))))))
18:46:29 <Meady> main = putStrLn "Hello, what is your name?"
18:46:29 <Meady>       >> getLine
18:46:29 <Meady>       >>= \name -> putStrLn ("Hello, " ++ name ++ "!")
18:46:36 <Cale> hector: Right, so similarly to how the parser and lexer probably reflected errors as values, you're going to want to do the same in the evaluator.
18:46:37 <mmorrow> without TH some things would just be too tedious to imagine doing
18:46:42 <Meady> Right guys, whats happening on that 3rd line
18:47:05 <monochrom> The third line obtains the answer from getLine and uses it.
18:47:10 <Cale> Meady: well, the result of getLine is being captured and bound to name
18:47:13 <Meady> Yeah
18:47:21 <lpjhjdh> can template haskell reflect functions?
18:47:23 <Meady> >>= is binding it?
18:47:26 <Cale> yeah
18:47:27 <aavogt> why not use 'do' notation?
18:47:41 <Cale> aavogt: That is from a tutorial which shows both
18:47:42 <hector> So, what to do about the lazy evaluation?... several examples of what I say my GCL code is being interpreted as Lazy are these: 1) main i <- 1 / 0 end --NO ERROR REPORTED, 2) main i <- 1 / 0; show i end --Division by Cero Error reported, 3) main i <- foo[52] end --NO ERROR REPORTED, 4) main i <- foo[52]; show i end --Out of bounds error reported with foo. Isn't thath like the definition of lazy evaluation?
18:47:45 <purplepenguins> sometimes it's clearer to use >>= and >> than do
18:47:55 <Cale> At some point you have to learn both :)
18:48:18 <monochrom> why not use python?  <duck>
18:48:25 <Cale> hector: All you need to do is not to use the error function.
18:48:28 <heatsink> <duck typing>
18:48:59 <Cale> hector: Construct a value which represents the error and return that. Use the Either type if it suits you.
18:49:18 <mmorrow> hector: could you hpaste some examples, it's hard to see what's happening
18:49:29 <heatsink> Well, if you had to write a tag-soup XML parser in Coq, you'd duck typing for the rest of your life.
18:49:33 <hector> hpaste?
18:49:40 <mmorrow> (examples of snippets of the eval haskell function)
18:49:42 <koeien> ?where hpaste
18:49:42 <Cale> That is,  Left "Division By Zero"   or   Right (div x y),  depending
18:49:42 <mmorrow> @paste
18:49:42 <lambdabot> http://hpaste.org/
18:49:43 <lambdabot> Haskell pastebin: http://hpaste.org/new
18:49:59 <Cale> hector: Does that make sense?
18:50:02 <monochrom> heatsink: haha nice pun
18:50:07 <heatsink> monochrom, thx
18:50:21 <mmorrow> heh
18:50:23 <Cale> Meady: come to #haskell-overflow, and I'll explain carefully :)
18:50:56 <Cale> Meady: that is, if you're still confused about the syntax there
18:51:28 <hector> yeah it kinda does. I used Either in my lexer, but because I wanned the lexical analysis to continue even when an error was found. I don't want my program to continue executing/running/being interpreted when an error is found
18:51:42 <Cale> hector: Right, but this way gives you control.
18:51:58 <Cale> hector: If the result of some other evaluation was Left foo, then there's your error.
18:52:06 <Cale> hector: You don't continue evaluating.
18:52:23 <Cale> hector: You just pass that on as your result.
18:53:02 <mmorrow> > flip runCont id (callCC (\k -> return ({- blah blah -}) >> forever ({- oh noes error-} k "error!")))
18:53:03 <lambdabot>   "error!"
18:53:10 <Cale> hector: If instead, it was Right bar, then you know that bar is the result of that evaluation and everything went fine.
18:53:39 <mmorrow> > forever Nothing
18:53:41 <lambdabot>   Nothing
18:53:58 <Cale> It's possible to use the Either String monad to arrange this automatically, but you don't necessarily have to.
18:54:10 <mmorrow> ah, i was just about to ask that
18:54:17 <mmorrow> (if we're in a monad or not already)
18:54:26 <Cale> No, looks like pure code.
18:54:36 <hector> umm ok I think I see what you are saying... I think that is gonna work great! thanks! Is there an e-mail I can write you when I try it? or do you read the Haskell-cafe frequently, I can write there?
18:55:07 <Cale> You can write me at cgibbard@gmail.com, but probably your best bet is to come here :)
18:55:28 <Cale> I'm often around, and when I'm not, my computer stays on and collects messages :)
18:55:40 <mmorrow> hector: if you're comfortable with defining (or just using) monads, you could make your own (or use some combo from the mtl) to make like easier possibly (by eliminating a bunch of nested "case"'s)
18:55:56 <monochrom> It would be cool if computer started replying on your behalf.
18:56:06 <Cale> Right, in this case, it's just Either String which you're looking for at this point.
18:56:20 <mmorrow> monochrom: it'd be even better if it called everyone "Dave"
18:56:38 <monochrom> that one is too creepy
18:56:45 <Cale> monochrom: Or if my brain ended up getting sucked in and became a permanent part of the Internet.
18:56:49 <mmorrow> Yes, it is Dave.
18:57:23 <monochrom> "Is it for the mission?"
18:57:28 <hector> Thanks for the monad advice, but I know almost nothing about monads and I'm about to finish this term in the university, so I need to get this done by the end of this week... Learning monads is my next task, but for me, not for the UNiversity...
18:57:57 <Cale> hector: Yeah, you can just think of it as a way to tidy up the case branching which you're going to have.
18:57:59 <hector> Thanks Cale, I'll write you here then..
18:58:33 <mmorrow> http://en.wikipedia.org/wiki/HAL_9000
18:58:51 <Cale> hector: The basic idea is that there is a function of type  Either String a -> (a -> Either String b) -> Either String b
18:59:34 <monochrom> In a sense lambdabot is Cale's answering machine. It can't teach you monads but it can tell you your monad has a wrong type.
18:59:39 <hector> that would be like a seq more or less right?
18:59:57 <Cale> It's not like seq, but it is a kind of sequencing.
19:00:11 <Cale> It takes something that might fail, and a function from its result to something else which might fail, and returns either a failure (the first one to occur), or a result.
19:00:42 <Cale> You might even want to write a function like that for yourself and try to use it.
19:01:20 <hector> ok ok I think i got it! I'm gonna try to make it myself...
19:01:48 <deech> Hi all, As an exercise I am trying to implement the MonadState instance of a monad transformer stack. My current code at http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6358#a6381 errors with '`BigAssMonad e m' is not applied to enough type arguments ...'. What am I doing wrong? Any help is appreciated.
19:02:06 <mmorrow> @type let whileR f = whileR . either id f in whileR
19:02:08 <lambdabot>     Occurs check: cannot construct the infinite type: a = b -> a
19:02:08 <lambdabot>     Probable cause: `either' is applied to too many arguments
19:02:08 <lambdabot>     In the second argument of `(.)', namely `either id f'
19:02:27 <mmorrow> @type let whileR f = either id (whileR f) . f in whileR
19:02:29 <lambdabot> forall a a1. (a -> Either a1 a) -> a -> a1
19:02:52 <heatsink> deech: MonadState takes two arguments: first the state, then the monad.
19:03:03 <Cale> deech: you forgot to mention the state type.
19:03:05 <mmorrow> @type let whileR f = either id (whileR f) . f in whileR (\a -> if a < 1000 then Right (a+3) else Left a) 0
19:03:06 <lambdabot> forall a. (Num a, Ord a) => a
19:03:08 <mmorrow> > let whileR f = either id (whileR f) . f in whileR (\a -> if a < 1000 then Right (a+3) else Left a) 0
19:03:10 <lambdabot>   1002
19:03:12 <hector> Thanks Cale... thanks mmorrow... Bye
19:03:15 <mmorrow> bye
19:03:19 <Cale> hector: see you
19:03:33 <Cale> deech: instance MonadState s (BigAssMonad e s) where ...
19:03:56 <heatsink> deech: The monad has kind * -> *, but you used it as the state (kind *), which is why you get that error.
19:04:13 <deech> heatsink, cale : I tried this but got a use XFlexibleInstances error
19:04:24 <Cale> Well, technically, m isn't otherwise in scope there
19:04:42 <Cale> deech: Then turn on FlexibleInstances
19:04:59 <Cale> {-# LANGUAGE FlexibleInstances #-}
19:05:19 <Cale> actually, you're going to need multiparameter type classes too
19:05:46 <Cale> {-# LANGUAGE FlexibleInstances, MultiParamTypeClasses #-}
19:06:01 <heatsink> oh, that's slightly nicer syntax than OPTIONS_GHC
19:06:13 <mmorrow> @type let decision f g h = either f g . h in fix (\k h -> decision (k f g h) (k f g h) h)
19:06:15 <lambdabot>     Occurs check: cannot construct the infinite type:
19:06:15 <lambdabot>       c = (a1 -> Either a a) -> a -> c
19:06:15 <lambdabot>     Probable cause: `decision' is applied to too many arguments
19:06:37 <mmorrow> @type let decision f g h = either f g . h in \f g -> fix (\k h -> decision (k f g h) (k f g h) h)
19:06:39 <lambdabot>     Occurs check: cannot construct the infinite type:
19:06:39 <lambdabot>       c = (a1 -> Either a a) -> a -> c
19:06:39 <lambdabot>     Probable cause: `decision' is applied to too many arguments
19:08:44 <mmorrow> @type let decision f g h = either f g . h in \f g h -> fix (\k (f,g,h) -> decision (k (f,g,f)) (k (f,g,g)) h) (f,g,h)
19:08:45 <lambdabot> forall c a. (a -> Either a a) -> (a -> Either a a) -> (a -> Either a a) -> a -> c
19:09:23 <mmorrow> hmm, i guess that has no way of finishing though
19:10:19 <deech> Cale: Wow that worked! The only reason I didn't turn it on before was that I didn't need it for the Monad instance and thought I was doing something wrong.
19:10:26 <jaredj> the optimal thing to get out of a parser is an Either, right? because catching errors is lamer than writing case bla of Left/Right
19:10:26 <jaredj> i'm trying to write an ofx file parser. ofx files have a header and a body
19:10:26 <jaredj> i have a parsec parser for the header, and the body i run through tagsoup, and then parse with tagsoup-parsec
19:10:27 <jaredj> (where the tokens are Tags instead of Chars)
19:10:53 <jaredj> argh my question is too long
19:11:09 <deech> Cale: Will there be any issues if I load these extensions whether I need them or not?
19:11:26 <mmorrow> jaredj: yeah, Either is a nice fit (for the top-level of) parsers
19:11:26 <Cale> deech: They're common extensions, it doesn't hurt to use them.
19:11:35 <hzap> jaredj: catching errors will stick you in the IO monad, so Either is better here
19:11:58 <Cale> deech: multiparameter typeclasses in general are pretty complicated, but you absolutely need them to use the mtl.
19:12:03 <mmorrow> hzap: if you use exceptions for errors that it
19:12:05 <Cale> (Control.Monad.State and friends)
19:12:16 <hzap> mmorrow: yeah that's what I mean
19:12:19 <jaredj> mmorrow: my problem is the outer parser succeeds before starting the inner parser
19:12:30 <mmorrow> jaredj: are you using parsec?
19:12:34 <jaredj> yes, twice
19:12:35 <mmorrow> ah, you are
19:12:37 <mmorrow> heh
19:12:47 <mmorrow> parsec does depth-first search
19:13:03 <mmorrow> oh wait, what's the question here
19:13:18 <jaredj> i want to say ofxFile = do { ofxHeader; ofxBody }
19:13:25 <mmorrow> (you want to somehow propogate error info from the parsec parser to the tagsoup parser?)
19:13:26 <jaredj> then if it fails it can do so properly
19:13:43 <mmorrow> oh, tagsoup-parsec
19:13:49 <deech> Cale: Cool, next time I'll do as the compiler advises :)
19:13:58 <Cale> Meady: sorry about the delay, check in #haskell-overflow again if you're around :)
19:14:03 <Saizan_> jaredj: you can work in the Either e monad, i think
19:14:03 <jaredj> but what i have to say now is ofxFile = do { ofxHeader; rest <- many1 anyChar; let ts = parseTags rest; parse ofxTags "bla" ts }
19:14:15 <mmorrow> jaredj: ok, so because parsec does depth-first search, once it commits to a particular branch, there's no turning back
19:14:24 <mmorrow> jaredj: (unless you use try that is)
19:14:27 <jaredj> sure
19:14:53 * mmorrow is trying to grok what the goal is here
19:15:05 <jaredj> my problem is that the ofxTags doesn't consume the rest of the file, it consumes the tagsoup made out of the rest of the file
19:15:33 <jaredj> ofxTags fails, but that failure doesn't turn into a Left result from ofxFile
19:15:57 <jaredj> it ends up as an error
19:16:19 <jaredj> and i can't figure out how to make ofxFile fail, when rest already consumed the whole file.
19:17:08 <mmorrow> jaredj: what's the type of `ts' ?
19:17:12 <Saizan_> jaredj: what's the type of  parse ofxTags  "bla" ts
19:17:15 <Saizan_> ?
19:17:21 <jaredj> ts is [Tag]
19:17:32 <jaredj> (parseTags does not fail)
19:17:52 <jaredj> parse ofxTags "bla" ts -> Either String MyBigOFXRecordStructure
19:18:30 <mmorrow> err, so where does the undesireable error occur here again?
19:18:33 <Saizan_> ok, so you should pattern match on that Either, and call fail if you get a Left or return if you get a Right
19:18:53 <jaredj> i think fail is what i was missing
19:19:17 <Saizan_> you just used error?
19:19:19 <mmorrow> i'm confused here. what monad are we in?
19:19:25 <mmorrow> ofxFile = do { ofxHeader; rest <- many1 anyChar; let ts = parseTags rest; parse ofxTags "bla" ts }
19:19:32 <mmorrow> many1 tells me parsec's
19:19:43 <mmorrow> but the type of parse osf... is Either String .. ?
19:19:45 <jaredj> Saizan_: tagsoup-parsec has a tParse which turns Left into error. i only just found that out
19:20:03 <jaredj> Saizan_: so i was using tParse. i tried to write a hunit test for a failed parse, but it didn't catch the error
19:20:19 <jaredj> Saizan_: so my program just quit. undesirable
19:20:24 <Saizan_> jaredj: yeah
19:20:35 <jaredj> mmorrow: ofxFile is in the Parsec monad
19:20:39 <mmorrow> ughhh, tParse turns Left into error
19:20:42 <Saizan_> jaredj: i guess tParse is there only for quick scripts or something
19:20:57 <jaredj> yes. and that's what i just discovered
19:21:12 <mmorrow> jaredj: and the type of that last stmt in the do-block is (Either String MyBigOFXRecordStructure) ?
19:21:14 <jaredj> but then i couldn't figure how to make ofxFile end up Left when i'd already parsed th ewhole file
19:21:20 <jaredj> (rest <- many1 anyToken)
19:21:27 <Saizan_> fail instead reports an error just like any parse error in parsec
19:21:35 <mmorrow>  :t parse ofxTags "bla" ts
19:21:58 <jaredj> mmorrow: yes, Either String MyBigOFXRecordStructure
19:22:12 <mmorrow> so the parsec monad is just Monad (Either String) ?
19:22:34 <mmorrow> (which is the only thing i can figure)
19:22:45 <Saizan_> jaredj: you don't really have "parse ofxTags "bla" ts" on a line by itself in that do-block, do you?
19:22:53 <Saizan_> mmorrow: no, it isn't
19:23:05 * mmorrow is confused then :)
19:23:41 <Saizan_> either that many1 is not parsec's one, or that code is not what it's being actually compiled :)
19:23:51 <jaredj> Saizan_: it's part of a let
19:24:15 <Saizan_> jaredj: ah, now i see
19:24:17 <mmorrow> ahh, ok.
19:24:45 <Saizan_> so we have "ofxFile = do { ofxHeader; rest <- many1 anyChar; let { ts = parseTags rest; parse ofxTags "bla" ts }; ... }"
19:24:48 <mmorrow> i suppose parsec doesn't have the equivalent of ReadP's `look'
19:24:57 <mmorrow> , [$ty| look |]
19:24:58 <jaredj> Saizan_: yes
19:25:00 <lunabot>  ReadP String
19:25:07 <Saizan_> uhm
19:25:17 <Saizan_> you forgot to add a binding for that, no?
19:25:24 * mmorrow would use look for this if he was using ReadP
19:25:39 <jaredj> http://patch-tag.com/r/ofx1/snapshot/current/content/pretty/Text/OFX1.hs
19:26:02 <jaredj> don't know why i didn't paste that five minutes ago...
19:26:05 <mmorrow> err, actually i wouldn't
19:26:23 <Saizan_> heh
19:27:09 <jaredj> so i'm already not going to use tParse
19:28:02 <Saizan_> ok, so you want ... let body = parse body "blah" soup; case body of Left e -> fail e; Right r -> return (parsedHeader,r)
19:28:19 <Saizan_> where the case is not in a let
19:28:48 <jaredj> that's simple enough
19:28:49 <jaredj> :d
19:29:31 <mmorrow> so i guess tParse p input = either (const (error "i bet you'll never find out who's calling error! ahahaha")) id (parse p input) ??
19:29:49 <jaredj> mmorrow: approximately, yes.
19:29:56 <mmorrow> heh
19:30:00 <jaredj> actually it's a case, but that's it.
19:31:33 <Saizan_> jaredj: ops!
19:31:40 <Saizan_> jaredj: i introduced a loop there
19:31:53 <mmorrow> heh
19:31:56 <jaredj> eh?
19:32:04 <Saizan_> you've to use "let parsedBody = ...; case parsedBody of ..."
19:32:16 <Saizan_> otherwise both body will refer to the same, making it recursive
19:32:34 <mmorrow> <Saizan_> ok, so you want ... let body = parse body "blah" soup
19:32:34 <Saizan_> but you'll get a type error in this case, actually
19:33:35 <Saizan_> jaredj: if you use the same variable on the left and right of a = you're actually making a recursive definition, not shadowing
19:34:02 <jaredj> yes
19:34:03 <jaredj> wth?
19:34:03 <jaredj> i imported Text.ParserCombinators.Parsec, but ParseError is out of scope?
19:34:21 <jaredj> i think i got that part straight -
19:34:31 <jaredj> the problem now is that Left e -> fail e makes a type error
19:34:37 <jaredj> fail wants a String, but e is a ParseError
19:34:57 <Saizan_> ah
19:34:59 <thoughtpolice> then 'show' it?
19:35:11 <Saizan_> yeah
19:35:29 <jaredj> yeh i reckon
19:36:49 <jaredj> heh :P
19:37:09 <jaredj> besides the show of the error i also get a spurious 'unexpected end of input' error before it
19:37:35 <monochrom> That is not spurious.
19:37:40 <jaredj> i reckon because that's all that's left to fail on after the main file has read everything
19:39:23 <jaredj> it's spurious because i don't want it, not because it doesn't make sense
19:40:29 <jaredj> the next challenge of course is to fail at the right place with the right message
19:40:44 <jaredj> the outer parsec has no choice but to fail at the end of the file which is not instructive
19:41:36 <jaredj> (because the tagsoup can't consume the file tokenwise, it eats the whole thing in one bite)
19:42:03 <jaredj> but the failure is now contained enough to be testable
19:42:16 <Saizan_> yeah, "stacking" is not something the common parser interfaces do well
19:44:27 <jaredj> hm. well i have a hunitfailure now :D
19:45:00 <jaredj> thanks all. now i have to learn how to use hunit properly
19:45:08 * jaredj scuttles off
19:48:23 <wmealing> I can google options but I'd rather hit real people instead of paid for blogs, can someone recommend a book/resource for FP newbies to get started in haskell ?
19:48:51 <Adamant> they'll all recommend the same thing, Real World Haskell
19:48:59 <Adamant> at least as your first book
19:49:10 * wmealing nods
19:49:22 <wmealing> i did find that, which is why I assumed it was kind of bought.
19:49:23 <wmealing> i guess not
19:49:29 <Adamant> it's from O'Reillty
19:49:37 <Adamant> they're relatively good people
19:49:43 * wmealing nods
19:49:53 <Adamant> and the guys that made it are all on this channel IIRC
19:50:08 <Adamant> and are quite to somewhat active
19:50:54 <thoughtpolice> grr
19:50:59 <Adamant> beyond that it's like Lisp or Scheme. get ready for a lot of academic and semi-academic papers
19:51:02 * thoughtpolice has no idea why blahtex is segfaulting on his macbook
19:51:52 <SamB> Adamant: the papers are way easier to read, though, and have lots more type signatures in them ;-P
19:52:34 <Adamant> SamB: why don't you tell him to get started with the Gentle Introduction To Haskell, you awful man :P
19:52:50 <Saizan_> @where LYAH
19:52:50 <lambdabot> www.learnyouahaskell.com
19:52:55 <Adamant> that's also great
19:53:06 <Adamant> well, great for some people
19:53:10 <Adamant> I liked RWH better
19:53:14 <SamB> Adamant: awful?
19:53:27 <Adamant> SamB: GITH isn't, remember
19:53:32 <SamB> easier to read than scheme/lisp papers, I mean
19:53:35 <SamB> not than RWH
19:53:46 <Adamant> oh
19:53:50 <Adamant> my mistake
19:53:50 <SamB> Adamant: yes, I remember that GITH isn't
19:53:59 <Adamant> yeah, my mistake
19:54:10 <Adamant> I'm not sure they're any different except for the age factor
19:54:14 <gwern> SamB: you know, I thought the lisp/scheme papers would be easier to read then haskell ones, until I went to read one on typed macros, and found myself stumped by figuring out, well, the types
19:54:31 <SamB> gwern: see what I mean?
19:54:39 <SamB> it's just like the documentation!
19:54:47 <Adamant> no
19:55:01 <SamB> which documentation do you suppose has more type signatures in it?
19:55:23 <Adamant> people who think types are documentation as opposed to a very useful adjunct to documentation drive me nuts
19:55:42 <SamB> the hyperspec/RnRS, or the Haskell Report?
19:55:49 <jaredj> there are papers about lisp and scheme?
19:55:49 <jaredj> i've found haskell papers quite instructive
19:55:51 <SamB> Adamant: I didn't say that
19:56:06 <Adamant> SamB: ok, I must have mishead you
19:56:14 <Adamant> "it's just like the documentation"
19:56:22 <gwern> mishead? don't you know that's unsafe?
19:56:37 <Adamant> thought that meant types were docs
19:56:41 <SamB> gwern: think he couldn't decide between misread and misheard ;-)
19:56:54 <Adamant> I wish I was that forward thinking
19:56:59 <Adamant> more like fat fingering it
19:57:05 <gwern> SamB: ah, but that'd be 'mishread'
19:57:15 <SamB> mishred?
19:57:17 <wmealing> sorry about that.. laptops need power.
19:57:22 <Adamant> MISSHRED
19:57:31 <gwern> SamB: what you get when you combine misread and misheard :)
19:57:31 <SamB> wmealing: most computers do
19:57:33 <jaredj> OH NOES
19:57:35 * Adamant rocks out on Stratocaster
19:57:48 * Adamant gets several chords wrong
19:57:51 <SamB> wmealing: I'd be interested in hearing about it if you ever find one that does not
19:57:56 <wmealing> SamB, will let you know
19:58:02 * Adamant gets a very low score in Guitar Hero
19:58:07 <Adamant> :P
19:58:21 <SamB> Adamant: perhaps if you didn't try to IRC at the same time it would help?
19:58:40 <monochrom> Adamant has four hands.
19:59:04 * gwern sets Adamant's guitar to 01011
19:59:31 <Adamant> now I just need to grow several elephant heads on my neck
19:59:39 * Adamant apologizes to #haskell Hindus
20:00:04 <monochrom> multi-threaded watering
20:00:55 <Saizan_> wmealing: if you missed it, LYAH is also good to start
20:00:59 <Saizan_> @where LYAH
20:00:59 <lambdabot> www.learnyouahaskell.com
20:01:55 <wmealing> Saizan_, thanks.
20:02:02 <wmealing> epic artwork
20:04:33 <jaredj> ping
20:24:42 <troutwine> How do I structure a module so that the internal details of a datastructure are hidden?
20:24:56 <dibblego> with the export list
20:25:03 <dibblego> which is part of the module declaration
20:25:19 <dibblego> @google abstract algebraic data types
20:25:21 <lambdabot> http://www.researchchannel.org/prog/displayseries.aspx?fID=2260
20:25:21 <lambdabot> Title: ResearchChannel - An Abstract Decision Procedure for Algebraic Data Types
20:25:26 <dibblego> @google abstract algebraic data types haskell
20:25:27 <lambdabot> http://en.wikibooks.org/wiki/Haskell/GADT
20:25:32 <dibblego> bleh
20:26:08 <troutwine> dibblego: Right. I guess I'm not being clear enough.
20:26:14 <gwern> AADT?
20:26:41 <dibblego> http://www.haskell.org/haskellwiki/Abstract_data_type
20:27:15 <dibblego> bleh that's not it either
20:27:22 * dibblego runs away
20:27:47 <troutwine> Actually, I think, the type class approach is what I'm looking for.
20:28:09 <dibblego> oh? don't you wish to hide the constructors for your data type?
20:32:41 <troutwine> Unless I'm confused (which I may very well be, it is my first multi-module Haskell program), I'll just have a fromList function associated with the type class. I won't export the constructor and everything will be shiny, no?
20:33:36 <dibblego> type-classes don't have constructors, so perhaps it might help to detail your problem a little
20:33:46 <dibblego> e.g. tell us about fromList
20:36:53 <troutwine> That was a contrived example. Here's the full deal: I'm building URLs for Amazon's Product Advertising API. I'm representing the pre-generated URL with an APARequest type. It's basically a wrapper over four list of four APA operations I'm using. Two of the lists must be empty and no lists may have more than two operations, along with a few other rules.
20:37:33 <troutwine> I'm not exporting any constructors and, instead, have a maker function that ensures the rules are followed.
20:38:05 <mmorrow> troutwine: you could alternatively build a datatype where non-well-formedness is impossible by construction
20:38:27 <troutwine> mmorrow: Do tell, please.
20:38:37 <mmorrow> so the rules are:
20:38:46 <mmorrow> four list of four APA operations I'm using. Two of the lists must be empty and no lists may have more than two operations, along with a few other rules.
20:38:47 <mmorrow> ?
20:38:51 <mmorrow> what are the others?
20:40:12 <troutwine> One operation is ItemLookup. It carries an OfferPage parameter. When I generate the URL I make OfferPage number of URLs, one per page per request. OfferPage may not be more than 400.
20:41:10 <troutwine> ItemLookup is done by ASIN. Only one ASIN per ItemLookup. Another operation BrowseNodeLookup is done by browseNode. There may be 10 browseNodes per BrowseNodeLookup.
20:41:46 <mmorrow> what about the APARequest type though?
20:41:47 <troutwine> There are a few trivial variations on those two rules, but that's it.
20:41:56 <mmorrow> (starting with that first)
20:42:18 <mmorrow> so four lists of [APAOp], right?
20:42:22 <mmorrow> "lists"
20:42:23 <troutwine> Right.
20:42:37 <mmorrow> and "Two of the lists must be empty and no lists may have more than two operations"
20:42:44 <mmorrow> " along with a few other rules."
20:42:50 <mmorrow> what are these other rules?
20:43:06 <mmorrow> (are they relevant to the "shape" of APARequest?)
20:43:33 <troutwine> Right. The other rules are the limitations on the Operations. No, they don't change the shape of the APARequest, though it is invalid if any of its Operations are.
20:43:45 <mmorrow> ah, ok
20:43:52 <troutwine> I do hope I'm making sense.
20:43:59 <mmorrow> yes you are
20:44:45 <mmorrow> ok, so wrt trying to limit operations given a particular shape of APARequest, we'll ignore that for now (you'd need "smart constructors like you're using or a GADT (or possibly class hackery))
20:44:58 <mmorrow> *..limiting operations given ...
20:45:18 <mmorrow> but wrt enforcing "Two of the lists must be empty and no lists may have more than two operations"
20:45:31 <mmorrow> that should be easy enough by building an appropriate datatype
20:45:50 * mmorrow thinks
20:46:25 <mmorrow> ok, so four lists, but two must be empty ==> we only need two lists
20:46:31 <mmorrow> (?)
20:46:41 <troutwine> mmorrow: Right.
20:47:00 <troutwine> With the stipulation that the lists may have no more than two members, of course.
20:49:00 <mmorrow> data Some = One a | Two a a; data APARequest = Req (Some APAOp) (Some APAOp)
20:49:25 <mmorrow> and if you need to distinguish *which* two lists are nonempty, out of the four, you can add some kind of selector
20:49:57 <mmorrow> (you could also do this by having a different constructor for each combo, but in this case you'd need way too many constructors for this)
20:50:43 <mmorrow> data Some = One a | Two a a; data APARequest = Req WhichTwoAreThese (Some APAOp) (Some APAOp); type WhichTwoAreThese = (Int,Int)
20:51:09 <mmorrow> (you could play the same game of "correct by construction" with WhichTwoAreThese, but that could get tedious)
20:51:23 <mmorrow> anyways, that's my 2-cents :)
20:52:21 <troutwine> mmorrow: Aha. After a bit of thought I see that this is much simpler than my current approach. Thanks.
20:53:00 <troutwine> The first, anyway. I don't understand the "WhichTwoAreThese" example.
20:53:05 <mmorrow> troutwine: no problem. just think of datatypes as legos that you can combine to make pretty much anything.
20:53:31 <mmorrow> troutwine: err, so that was just some way to say which two of the four lists these two (Some APAOp)'s are representing
20:53:41 <mmorrow> (that might make no sense in this context though, not sure)
20:54:20 <mmorrow> i.e., ([],[0],[],[3,4]) =?= ([3,4],[],[0],[])
20:55:13 <troutwine> ot it.
20:55:19 <troutwine> Got, rather.
20:55:40 <troutwine> Thanks mmorrow.
20:55:45 <mmorrow> troutwine: np
21:29:34 <jmcarthur> :t liftA2.liftA2 -- beautiful
21:29:35 <lambdabot> forall (f :: * -> *) a b c (f1 :: * -> *). (Applicative f, Applicative f1) => (a -> b -> c) -> f (f1 a) -> f (f1 b) -> f (f1 c)
21:30:14 <conal> jmcarthur: i love that one.
21:30:39 <jmcarthur> conal: yeah it only just occurred to me that the fmap stuff would also apply to the liftA* family
21:30:48 <conal> :)
21:31:33 <conal> the key is that liftAn maps arbitrary n-ary functions to n-ary fns
21:31:34 <conal> (functions)
21:31:48 <conal> and so can be composed over & over
21:31:56 <conal> like fmap, first, and second
21:32:08 <jmcarthur> yup! that was my realization
21:35:04 <bos> wowie zowie. i'm building a table to compare the Haskell text API with Python's.
21:35:10 <bos> it is really sad reading.
21:36:02 <bos> if you want to mangle text, Haskell is currently not so hot.
21:38:26 <wmealing> i'm interested when you are done.
21:38:47 <Axman6> time for a Data.Text package?
21:38:59 <bos> Axman6: it already exists, i'm figuring out what it lacks.
21:39:01 <bos> which is a lot.
21:39:05 <Axman6> ah, heh
21:39:11 <dons> bos: a table would be a good start.
21:39:22 <bos> dons: i've almost got the table built.
21:39:24 <dons> bos: what kind of stuff is missing?
21:40:16 <bos> dons: code for stripping white space, for finding substrings, for search and replace, for formatting, and various handy splitting functions
21:41:50 <Cale> bos: hmm... do we really not have acceptable equivalents to that?
21:42:04 <bos> in many cases, we don't.
21:42:22 <Axman6> isInfixOf?
21:42:32 <bos> the python string API contains 53 functions. there are haskell equivalents for about 30 of them, a few more if you squint and make unappealing pleading noises.
21:42:51 <Cale> Well, string formatting I usually handle using show and concat
21:43:05 <Cale> It's always worked nicely for me :)
21:43:07 <bos> isInfixOf is not very useful, is the thing.
21:43:13 <Cale> huh?
21:43:26 <Cale> Oh, if you want to know the position?
21:43:28 <Adamant> if you're going to go all out for text mangling
21:43:35 <Adamant> forget Python and go with the masters
21:43:36 <bos> for lots of text manipulation, you want to split on the location of a substring
21:43:47 <Adamant> the P-e-r-l word
21:44:07 <bos> python's text API is generally nicer than perl's, actually. as in, bigger and more useful.
21:44:31 <Adamant> nicer I can see, bigger and more useful would surprise me
21:45:12 <Adamant> but I could definitely be wrong
21:47:01 <georgehorse> Isn't Perl 6 getting lazy evaluation?
21:48:32 <erikc> is perl 6 actually happening?
21:49:27 <Cale> erikc: yeah, it's just taking its time doing so
21:49:40 <Cale> georgehorse: some, iirc.
21:50:00 <erikc> seems like it's gonna be DOA
21:50:07 <erikc> python and ruby will have eaten it's lunch
21:51:00 <Cale> It has a lot of cool features which they don't, but I won't presume anything about it.
21:57:45 <Adamant> erikc: that seems to be the perception for better or worse
21:58:12 <Adamant> I'm not a Perl fan but I might consider a cleaned-up Perl
21:59:01 <dons> bos: oh, you mean specifically for Data.Text ?
21:59:03 <erikc> yea, i know little about perl6, but from a politics/hype/socialuptake perspective, they seem to be in a tough spot
21:59:16 <dons> since I think these things are spread over a dozen libs
21:59:18 <Cale> Why care about any of that?
21:59:21 <bos> dons: yes
21:59:41 <Cale> Just let them focus on making something they think is cool, and if it really is cool, hopefully people will use it.
21:59:52 <bos> dons: i would like to provide a reasonably comprehensive API in the base text module
22:00:10 <dons> awesome.
22:00:32 <bos> dons: i find the explosion of tiny libraries that do one or two farty little things a bit dispiriting, so i want to get the API usable very early
22:00:59 <Cale> Actually, given the language changes, perhaps it'd be a good thing for people to have forgotten what Perl 5 was like a bit.
22:01:15 <erikc> Cale: yea, the perl name is sort of an anti-brand now
22:03:00 <Saizan> bos: btw, what's the expected overhead of using Text vs. ByteString?
22:03:47 <bos> Saizan: depends on what you're doing. i haven't done side by side measurements. if you have cycles to contribute, that would be a good place to do so.
22:05:00 <Saizan> bos: ok
22:10:33 <BMeph> Heh-heh, "the Haskell method" of development: "Does Haskell do _____?" "Hm, it should, but I don't know if anyone's coded it up. Why don't you give it a try?" "But I'm new to Haskell, I can't do all that complicated stuff!" "Just try it out, you might be surprised." "Hey, this Haskell stuff is amazing!"
22:11:23 <BMeph> ...then, another monad tutorial comes out after a few weeks. ;)
22:12:43 <Cale> BMeph: haha
22:15:17 <Saizan> so a newbie should be warned that he/she can get pregnant by asking for help in #haskell?
22:23:59 <codebliss1> Hello.  I made a function to add line numbers to my input, and I can't think of a smart fast way to add on a '\n' to each element except the last
22:24:16 <codebliss1> number :: (Show a) => [a] -> [String]
22:24:17 <codebliss1> number = zipWith (++) [show a++") " | a <- [1..]] . map show
22:25:42 <Axman6> map (++"\n")?
22:25:52 <codebliss1> That maps a \n onto the last element
22:26:04 <codebliss1> Is init slow?
22:26:17 <Saizan> why you don't want a newline to the last?
22:26:19 <codebliss1> Could tag on init . concat
22:26:25 <codebliss1> Because I don't
22:26:30 <codebliss1> =D
22:26:34 <Axman6> :\
22:26:42 <Saizan> it's customary to end a file with a newline
22:26:50 <Saizan> however there's intercalate
22:26:56 <BMeph> codebliss1: Are youfamiliar with the "intercalate" function? :)
22:26:56 <Saizan> ?type intercalate
22:26:58 <lambdabot> forall a. [a] -> [[a]] -> [a]
22:26:59 <codebliss1> Eh, never mind, I should be fine
22:27:04 <codebliss1> And yes I am, I looked at it
22:27:07 <BMeph> Saizan: Jinx!
22:27:11 <Saizan> !
22:27:43 <Saizan> > intercalate "\n" ["foo","bar"]
22:27:44 <lambdabot>   "foo\nbar"
22:27:53 <Saizan> > unlines ["foo","bar"]
22:27:55 <lambdabot>   "foo\nbar\n"
22:28:09 <codebliss1> I see..
22:28:55 <codebliss1> *Util> putStrLn $ Data.List.intercalate "\n" $ number ["This","is","a","test."]
22:29:10 <codebliss1> Good enough.  I tried that f, but I think I did single quotes instead of double, forgot to match types
22:29:11 <codebliss1> Thanks
22:29:21 <Saizan> np :)
22:29:32 <codebliss1> It's just more readable, I understand with files you should end with a newline
22:29:39 <codebliss1> This is just a repl test
22:29:46 <Saizan> uhm
22:29:52 <Saizan> but you use putStrLn
22:29:58 <codebliss1> I'm not going to
22:30:00 <codebliss1> =D
22:30:07 <Axman6> hmm, anyone know if Data.Set has any tricks to make it fast? seems to be faster than my StringSet datatype, which seems a little odd to me
22:30:50 <Saizan> Axman6: {-# UNPACK #-} maybe?
22:30:53 <codebliss1> putStrLn $ unlines $ number foo -- Adds newline onto end, this is why I asked for help on a different functionality
22:30:58 <Saizan> for the sizes
22:31:02 <Axman6> huh, mine's faster with unsorted input, interesting
22:31:22 <Axman6> yeah i'm using {-# UNPACK #-} too
22:31:33 <zloog> http://www.haskell.org/ghc/docs/latest/html/libraries/containers/src/Data-Set.html#Set  <- dont seem to be any magic there
22:31:57 <Axman6> yeah, that's what iu'm looking at too
22:32:03 <BMeph> codebliss1: Of course it adds a newline to the end; otherwise, it'd be called putStr . ;)
22:32:23 <codebliss1> BMeph: *facepalm*
22:32:39 <codebliss1> That's why there were really two linebreaks, lmfao
22:32:45 <Axman6> -_-
22:32:45 <codebliss1> *Util> putStr $ numberLn x
22:32:45 <codebliss1> 1) "This"
22:32:45 <codebliss1> 2) "is"
22:32:45 <codebliss1> 3) "a"
22:32:45 <codebliss1> 4) "test."*Util>
22:32:48 <Saizan> "but you use putStrLn" was referring to that :P
22:32:54 <BMeph> codebliss1: ...Oh, did we not mention putStr? :)
22:32:55 <zloog> Axman6: how are you representing it internaly?
22:33:06 <codebliss1> I know about the functions, I shouldn't be coding this late XD
22:33:20 <codebliss1> Err....early
22:33:36 <Axman6> zloog: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6383#a6383
22:35:34 <Saizan> Axman6: what do you use to benchmark? fromDistinctAscList seems to have some optimizations
22:35:57 <Axman6> just fromList on about 230,000 words
22:37:48 <Saizan> uhm, Data.Set has its own foldlStrict, i wonder if that matters here
22:40:48 <brian6> did ghci stop using readline recently or something?
22:41:10 <Saizan> yes
22:41:19 <Saizan> since 6.10
22:41:36 <brian6> what's it using now?
22:41:51 <Axman6> 6.10 they started using editline, and 6.10.3 uses haskeline
22:42:12 <dibblego> oh so that's why my delete key and various others won't work
22:42:26 <Axman6> i haven't had any problems
22:42:31 <Saizan> dibblego: yeah
22:42:41 <dibblego> what's the fix?
22:42:47 <brian6> Axman6: do you know if haskeline is configurable like editline and readline are with various ~/.*rc?
22:42:47 <dibblego> for 6.10.2
22:42:56 <Axman6> no idea
22:42:56 <Saizan> dibblego: install ghci-haskeline from hackage
22:43:01 <dibblego> ok ta
22:43:02 <Saizan> BMeph: it is
22:43:04 <Saizan> ops
22:43:06 <Axman6> dibblego: update to 6.10.3
22:43:07 <Saizan> brian6: ^^^
22:43:17 <brian6> Saizan: ok, cool. i need to get on that.
22:43:30 <brian6> life has really been a drag.
22:44:00 <Saizan> brian6: the haskeline trac has the documentation on the rc
22:44:16 <brian6> Saizan: thanks, reading now.
22:46:32 <brian6> oh, this is great. i can probably make michael jackson come back to life by editing ~/.haskeline.
22:46:49 <brian6> printing off ~/.haskeline, stuffing it down my pants.
23:02:55 <bos> What's in a text API? http://bit.ly/3mr1e0
23:34:50 <Axman6> > f >>= g
23:34:52 <lambdabot>   No instance for (SimpleReflect.FromExpr (m b))
23:34:52 <lambdabot>    arising from a use of `Si...
23:35:00 <Axman6> :(
23:35:10 <Axman6> @src (->) (>>=)
23:35:11 <lambdabot> f >>= k = \ r -> k (f r) r
23:38:40 <Cale> > (reverse >>= (++)) "hello"
23:38:42 <lambdabot>   "ollehhello"
23:39:32 <Berengal> > ((++) <*> reverse ) "hello"
23:39:33 <lambdabot>   "helloolleh"
