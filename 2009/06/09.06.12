00:01:21 <ivanm> so what happens if there's a Test.lhs as well? which has precedence?
00:01:23 <shachaf> Well, "runghc Setup" is quite helpful for my cabal alias. :-) (Since it works with .hs or .lhs.)
00:01:54 <shachaf> Looks like it's the .hs.
00:02:14 <shachaf> Though if you have both in the same directory, it's probably a mess anyway.
00:02:34 <ivanm> yeah ;-)
00:02:39 * ivanm was just being difficult :p
00:07:58 <asoare> hello, can someone please tell me how I can convert an Int to Double ? I read on the internet about fronIntegral, but it doesn't return a Double :-s
00:08:43 <ClaudiusMaximus> :t (fromIntegral (5::Int))::Double
00:08:45 <lambdabot> Double
00:08:49 <Cale> asoare: It *can* return a Double
00:09:05 <Cale> asoare: fromIntegral converts any integer-like type to any numeric type at all
00:09:18 <asoare> and how do I tell it to cinvert to double ?
00:09:24 <asoare> let a = fromInt 5
00:09:24 <ivanm> via voodoo magic! :p
00:09:35 <ivanm> asoare: if you use it as a Double, it will be a Double
00:09:41 <Cale> asoare: You just need a type signature somewhere in your program which forces the type to be Double
00:09:43 <ivanm> either explicitly make it a Double using ::
00:10:24 <Cale> asoare: Or, if it remains polymorphic, and you use it in a way which involves more than just integer operations, it will default to Double anyway
00:10:49 <Cale> (at least, if all goes well)
00:11:49 <Cale> (Numeric defaulting will not apply if something is polymorphic but relies on more than prelude-defined classes. I have no idea why this is.)
00:11:58 <Axman6> asoare: let a = fromIntegral 5 :: Double
00:12:25 <Cale> Or of course, with something so simple, you could just write  let a = 5 :: Double
00:13:50 <asoare> this is my code: http://pastebin.com/d7ce4838e I get this error: 292:75: Couldn't match expected type `Int' against inferred type `Double' In the first argument of `drawNodes', namely `nd'
00:14:50 <asoare> oh, never mind, it converts it to Double,  I just realized it now
00:14:53 <asoare> sorry
00:15:11 <Cale> Did you want to go the other way?
00:15:53 <asoare> the arguments of drawNodes are supposed to be Int, sorry, my mistake
00:17:17 <MC_Kejml> How am I suppposed to set a 3 ms dealy for a 1 MHZ frequency in Zilog Z8 Ecnore! ? Pls
00:17:34 <Cale> MC_Kejml: what?
00:17:50 <ivanm> sounds non-Haskelly to me...
00:18:06 <Axman6> huh?
00:18:14 <Axman6> wtf is zilog Z8 encore?
00:18:22 <MC_Kejml> It is not haskelly, but I cant find any rooms for assembler here.
00:18:28 <ivanm> I seem to recall hearing about it before...
00:18:38 <Axman6> not Z80?
00:18:40 <ivanm> MC_Kejml: so why would you think that _we'd_ know?
00:18:59 <Axman6> yeah, haskell is not very assembly like...
00:19:16 <mle> MC_Kejml: cycle-count a loop?
00:19:23 <mle> we don't do homework very well either.
00:20:20 <Axman6> mle: i have a feeling it might just ve nop; nop; nop;, or whatever the Z8(0) assembler equivilent is
00:21:06 <MC_Kejml> allright, do you have any idea how the command for it could look?
00:21:15 <Axman6> nope
00:21:19 <MC_Kejml> I´m sorry i´m going asm in youir room, but itys pretty urgent :(
00:21:24 <Axman6> i'm sure you can look it up
00:21:36 <ivanm> MC_Kejml: we don't, but google does!
00:21:43 <Axman6> hmm, is 1ms 1/1000 seconds?
00:21:50 <ivanm> yes
00:22:07 <Axman6> ok, then it's 3000 no-ops >_>
00:22:13 <ivanm> MC_Kejml: #asm
00:22:20 <MC_Kejml> thx
00:22:36 <ivanm> obviously didn't look hard enough for an assembly channel
00:22:56 <ivanm> really, do we have a "we love answering random programming questions" sign somewhere?
00:23:27 <Axman6> it's thr real world thing, you need to know asm to program in the real world
00:23:45 <ivanm> I thought we were against the real world..
00:23:56 <ivanm> oh, right, dons et al decided to write RWH... :@
00:23:56 <ivanm> ;-)
00:44:34 <ClaudiusMaximus> anyone has a tutorial/example of a mouse-driven user interface in HOpenGL?
00:45:01 <ClaudiusMaximus> the haskellwiki OpenGLTutorial2 says mouse callbacks will be covered "next time", but there is no 3
01:18:43 <hackagebot> AppleScript 0.1.5 - Call AppleScript from Haskell. (WouterSwierstra)
01:18:55 <ivanm> I'm guessing that's a Mac thing?
01:19:26 <araujo> ivanm!!!!!!!!!!!
01:19:31 <araujo> yeah, for mac
01:19:36 * araujo checks it out
01:20:20 <ivanm> you use a mac now? :o
01:20:36 <araujo> ivanm, i do, yeah
01:34:31 <dhun> after one week of learning Haskell I made tool that takes a text in wiki-markup and writes a latex file, I am really happy with the way it works, here is a pdf generated by it (its in german, but for looking at the layout it does not matter) http://upload.wikimedia.org/wikibooks/de/4/4b/Testn.pdf
01:35:25 <mux> dhun: very nice
01:35:32 <pastorn> dhun: cool :)
01:35:44 * mux remembers that he was faaaaar from being able to do that after just one week of haskell
01:36:01 <Twey> dhun: Looks good :)
01:36:04 <dhun> but my code it quite hard to read I fear
01:36:06 <Twey> Yeah, same :(
01:36:15 <mux> dhun: paste your code
01:36:36 <dhun> http://de.wikibooks.org/wiki/Benutzer:Dirk_Huenniger/haskell
01:37:05 <mux> heh, quite messy indeed ;-)
01:38:16 <Twey> Ooh, ick :-P
01:38:39 <dhun> what does ick mean?
01:39:05 <doserj> you aren't serious about allbutnl, are you? allbutnl = (map chr [0..255])\\['\n'\
01:39:12 <Twey> .a'u-nai
01:39:16 <dhun> no its not needed anymore
01:39:19 <Twey> Hehe
01:39:19 <dhun> I can take it out
01:39:49 <pastorn> dhun: allbutnl = [0x00 .. 0xff] :: [Word8]
01:39:52 <pastorn> i think
01:39:52 <mux> I was trying to make sense of your `flt' function, because it looks like identity to me, but it's not used anywhere :-)
01:40:06 <mux> your Anything data type is huge
01:40:31 <mux> anyhow, it looks like you have some cleaning to do on your own first
01:40:31 <pastorn> oh, you were using chars, sorry :/
01:40:31 <dhun> thats a problem indeed
01:40:46 <dhun> My idea is to generate a parse tree
01:40:57 <dhun> and Anything shall be a node in it
01:41:16 <mux> dhun: yeah, that's a fine idea, but there are probably a lot of simplifications to apply
01:41:26 <cizra> @src Anything
01:41:27 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
01:42:00 <pastorn> dhun: please dude! why are you using do-blocks with '{', ';', '}'??
01:42:07 <pastorn> it hurts my eyes!
01:42:28 <dhun> ok
01:42:31 <Cale> You should write a MediaWiki reader for pandoc :)
01:42:36 <mux> dhun: the igrplt functions looks like you should have just used `map' and I suspect this is the case for others
01:42:47 <dhun> ok
01:42:53 <Cale> I'm not sure if the result would be as good though
01:42:54 <dhun> what is pandoc?
01:42:55 <Berengal> This is perhaps the longest piece of haskell I've seen...
01:43:01 <mux> dhun: you realize that String is just an alias for [Char] ?
01:43:10 <Cale> (but I haven't used pandoc, only looked at it)
01:43:11 <dhun> yes
01:43:18 <dhun> I realize
01:43:21 <mux> ok
01:43:40 <mux> then if I'm not mistaken igrplt is just a specialization of map
01:43:47 <dhun> maybe
01:43:51 <dhun> looking at it
01:44:07 <Cale> Indeed it is :)
01:44:31 <Berengal> flip map, to be accurate...
01:44:32 <pastorn> dhun: exactly what is 'Evil'?
01:44:41 <mux> I suspect there are lots of other places where you use explicit recursion when you could have used Prelude functions
01:44:42 <dhun> I am E V I L
01:44:45 <dhun> :-)
01:44:45 <Cale> http://hackage.haskell.org/package/pandoc
01:44:50 <ClaudiusMaximus> @where hlint
01:44:50 <lambdabot> I know nothing about hlint.
01:45:00 <Cale> It's a converter between many document formats
01:45:29 <dhun> the parsers trys severaly braches
01:45:30 <Twey> It can't read wiki though
01:45:38 <Cale> Right.
01:45:47 <pastorn> dhun: just one suggestion, just more syntax
01:45:48 <Cale> (only Markdown style wiki)
01:45:48 <dhun> an evil means that the current branch cannot success anymore
01:46:07 <dhun> what do you mean with more syntax
01:46:15 <mux> okay, next nit: dt5 is the same as \xs -> if null xs then [] else last xs
01:46:26 <pastorn> in your declaration of Anything, you should put one instance per row (unless they're small, like C a or Evil)
01:46:36 <fasta> Pandoc is evil.
01:46:41 <Twey> Is Pandoc modular?  Can we just write new input/output modules for it?
01:46:55 <mux> my eyes hurt now, I'll leave the rest for others :-P
01:47:01 <pastorn> @paste
01:47:01 <lambdabot> Haskell pastebin: http://hpaste.org/new
01:47:04 <pastorn> anymore                                                  . Blub\0
01:47:13 <Twey> Pardon?
01:47:31 <Twey> fasta: Why is Pandoc evil?
01:47:43 <Cale> Twey: yeah
01:47:49 <fasta> I tried using it, but the original Markdown implementation in Perl (however buggy is it), is still better than the one in Pandoc.
01:48:00 <ClaudiusMaximus> @where+ hlint http://community.haskell.org/~ndm/hlint/
01:48:01 <lambdabot> Done.
01:48:25 <fasta> The difference between Pandoc and the Perl version is that the latter has users.
01:48:32 <Twey> Heh
01:48:34 <fasta> (which is why it works most of the time)
01:48:37 <Cale> Twey: You factor everything through this datatype: http://hackage.haskell.org/packages/archive/pandoc/1.2/doc/html/Text-Pandoc-Definition.html
01:48:44 <Twey> I think PHPMarkdown is the best implementation I've used so far
01:49:02 <Twey> The Python one didn't adhere to the spec right last I checked
01:49:31 <fasta> There is nothing particularly hard about writing a good implementation of Markdown in Haskell, but Pandoc isn't one.
01:49:55 <Twey> Well, should be easy to fix
01:50:18 <Twey> Cale: Hmm
01:50:35 <fasta> Easy to fix does not mean someone who can fix it, will actually do it.
01:50:37 <Twey> I think I would prefer something a bit *more* format-neutral in this case
01:50:55 <Twey> I.E. just tag the content
01:51:12 <pastorn> dhun: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5794#a5794
01:51:21 <Twey> It's then up to the writer to decide what to do with it based on the tags
01:52:05 <dhun> ok
01:52:18 <dhun> I will rewrite it that way
01:53:01 <Twey> I would be sorely tempted to nest that datatype further...
01:53:26 <Twey> And, dhun... no module should ever be that huge :-P  Break it up
01:53:33 <dhun> ok
01:54:03 <dhun> 1000 lines is large in Haskell, oho
01:54:24 <mmorrow> dhun: wow, nice pdf :)
01:54:39 <fasta> Twey: the GNU people disagree with their 13000 lines files.
01:54:48 <fasta> Twey: they call that open-source ;)
01:55:08 <Twey> For that I blame C
01:55:17 <fasta> Twey: C has nothing to do with it.
01:55:18 <mmorrow> haha, yeah gcc sources are epic
01:55:36 <fasta> Twey: they just don't want you to understand their code.
01:55:46 <Twey> C is massively verbose
01:55:48 <Twey> Everyone knows this :-P
01:55:54 <C-Keen> I am building ghc-6.10.3 from ghc-6.6.1 and I don't have cabal installed. I did sh boot, configure, make as in the readme and the process fails with gmake -C ../ghc stage=2 and the message: cabal-bin: At least the following dependencies are missing: haskeline -any
01:56:04 * mux remembers c-decl.c and frowns
01:56:19 <fasta> mmorrow: I was referring to the linker.
01:56:26 <mmorrow> fasta: hehe
01:56:27 <fasta> mmorrow: but maybe all their stuff is like that.
01:56:33 <mmorrow> fasta: i think so ;)
01:56:34 <C-Keen> now how can I provide haskeline? I have tried to bootstrap a recent cabal-install but that fails with http as array bytestring and friends are not found
01:56:57 <Twey> C-Keen: Install it?
01:57:11 <Twey> You can do it through your system's package manager
01:57:40 <C-Keen> Twey: I don't have a haskeline package available. Why is it required for building ghc and not included?
01:59:12 <C-Keen> Twey: and also: which compiler should I use? the old one or the new staged one?
01:59:42 <fasta> C-Keen: I highly doubt that that is the case.
02:00:03 <Cale> C-Keen: Is it absolutely necessary to build ghc yourself? Given that you're starting from such an old version, I suspect the answer is possibly yes, but...
02:00:31 <C-Keen> Cale: yes there is now newer package available for OpenBSD
02:01:12 <C-Keen> fasta: doubt what?
02:01:34 <fasta> I thought the intention was that GHC 6.10 should build with ghc-6.6. I think you can report a bug in that case.
02:01:59 <Cale> C-Keen: haskeline is available as a package on hackage, anyway
02:02:00 <fasta> C-Keen: I thought you were some newbie, but since you use OpenBSD, you are probably not. Ignore my comment about doubt.
02:02:26 * mmorrow chuckles
02:02:34 <Twey> Heheh
02:02:47 <C-Keen> Cale: so haskeline is used as compiled with the old compiler?
02:03:18 <Cale> C-Keen: probably, if it's complaining about not having it... though... that seems strange
02:03:37 <fasta> But haskeline being required to build GHC, seems weird.
02:03:41 <Cale> It's used for ghci, but I was pretty sure that it comes with ghc now.
02:04:03 <Cale> er, maybe it doesn't
02:04:11 <pastorn> @pl \x y -> y
02:04:11 <lambdabot> const id
02:04:19 <Cale> It's not installed here, and I have 6.10.3
02:04:31 <C-Keen> Cale: This is the whole error http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5795#a5795
02:04:32 <fasta> According to the release notes, 6.10.3 uses haskeline.
02:04:51 <Cale> yes, my ghci does, as far as I'm aware, but ghc-pkg doesn't know about it
02:05:20 <mmorrow> C-Keen: what ghc version are you trying to build with?
02:05:26 <Cale> So maybe it really does use the already-installed haskeline, which is funny
02:05:39 <Cale> http://hackage.haskell.org/packages/archive/haskeline/0.6.1.6/haskeline-0.6.1.6.tar.gz
02:05:45 <dhun> So I somehow feel that I want to publish my code as some kind of open source project, but as long as it looks like that, it does not make much sense
02:05:46 <C-Keen> mmorrow: ghc-6.6.1
02:06:39 <mmorrow> C-Keen: i've built 6.8 with 6.4, and 6.8 definitely builds 6.10, so if all else fails you can build 6.8 with 6.6 and then 6.10, but i'd be surpsrised if 6.10 didn't build with 6.6
02:06:39 <pastorn> @pl \x -> return ()
02:06:39 <lambdabot> const (return ())
02:06:50 <C-Keen> mmorrow: true
02:07:11 <Cale> dhun: Well, when you are ready to put it up, you could always put it on hackage :)
02:07:48 <dhun> I can put it up on Hackage, but I don't think it makes sense if nobody can understand my code
02:08:10 <fasta> dhun: you just write documentation.
02:08:29 <C-Keen> Cale: ghc --make Setup.hs fails with     Could not find module `Control.Exception.Extensible' for the haskeline you pasted
02:08:30 <Cale> C-Keen: do a  find | grep haskeline  from your ghc root
02:08:31 <dhun> is there something like java doc?
02:08:39 <pastorn> dhun: here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5794#a5796
02:08:42 <fasta> dhun: Haddock.
02:08:52 <fasta> dhun: what does your code do?
02:08:55 <pastorn> dhun: saving lines, saving lives :)
02:09:45 <dhun> pastorn great!!!
02:09:46 <C-Keen> Cale: there's ./libraries/haskeline
02:09:52 <C-Keen> Cale: now it gets strange
02:09:53 <Axman6> so, in the last few days, i've seen nots of need for both done = return (), and ignore x = x >> return ()
02:10:20 <Cale> C-Keen: So yeah, there definitely is a haskeline which comes with ghc itself then.
02:10:20 <Axman6> we need some kind of voting system for having things like these added to libraries
02:10:29 <dhun> its line inheritance in OOP
02:10:34 <pastorn> dhun: check this out: http://en.wikibooks.org/wiki/Haskell/More_on_datatypes
02:10:41 <fasta> dhun: line inheritance?
02:10:48 <dhun> like
02:10:53 <C-Keen> Cale: question is why is it not found?
02:11:01 <Cale> Axman6: I'd be happy if more functions which don't care about the return value of an action were polymorphic in the result type
02:11:06 <Cale> :t when
02:11:08 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
02:11:09 <C-Keen> I used autoconf-2.59 and gnu make to build it
02:11:12 <Cale> I'm looking at you, when
02:11:27 <Axman6> indeed
02:11:28 <Cale> It should be  (Monad m) => Bool -> m a -> m ()
02:11:38 * mux nods
02:11:48 <Cale> Or, better yet,  (Monad m) => Bool -> m a -> m (Maybe a)
02:11:53 <Axman6> yeah
02:12:07 <Axman6> when'?
02:12:12 <Cale> C-Keen: is there anything indicating that it was built?
02:12:17 <pastorn> dhun: you shouldn't use undefined like i did there, think of a general case to put there instead...
02:12:37 <pastorn> undefined is like null's evil twin
02:12:52 <dhun> ok
02:13:15 <C-Keen> Cale: Setup has been compiled but there is setup-config only in dist/
02:13:34 <C-Keen> Cale: there is also a file called 'unbuildable' in the haskeline root dir
02:13:35 <mux> pastorn: except that you can't test for undefined, hopefully :-)
02:13:56 <pastorn> (--> you won't (usually) get it unless you ask for it, and recovery is not something you want to do)
02:14:02 <C-Keen> So I gues something failed
02:14:26 <Axman6> i only ever use undefined when i have a function that i know its type, but haven't figured out how to implement it yet, f :: a -> b -> c; f = undefined
02:14:37 <pastorn> mux: well, can't it be handled by the Exception functions?
02:14:45 <Cale> C-Keen: maybe try the Setup.hs manually from there...
02:15:08 <pastorn> @hoogle Exception
02:15:09 <lambdabot> module Control.Exception
02:15:09 <lambdabot> Control.Exception data Exception
02:15:09 <lambdabot> Control.Exception ArithException :: ArithException -> Exception
02:15:30 <C-Keen> Cale: I cannot build it with ghc-6.6.1 as it cannot find Control.Exception.Extensible
02:15:43 <Cale> C-Keen: Ah, okay, same thing then
02:15:43 <mux> pastorn: yeah you should be able to; although only in monadic code
02:15:46 <C-Keen> Cale: Do you know where the stage1 compiler is located?
02:16:00 <mux> omg: http://www.maps.org/news-letters/v18n1/v18n1-MAPS_24.pdf
02:16:29 <C-Keen> Cale: ah found it
02:16:32 <mux> maybe we should promote LSD's usage for haskell
02:16:51 <mmorrow> mux: it would probably be for the best
02:17:14 <doserj> C-Keen: can you install http://hackage.haskell.org/cgi-bin/hackage-scripts/package/extensible-exceptions on ghc-6.6.1?
02:17:35 * mux wonders if you get to visualize the whole graph reduction mechanism of haskell with 75micrograms of LSD
02:17:51 <fasta> mux: there is a package for that already
02:18:14 <fasta> mux: the package does not include LSD, though.
02:18:52 <Twey> Hahaha
02:19:02 <dhun> is it good to use short names for function is hakell?
02:19:02 <mux> heheh
02:19:21 <dhun> in OOP you often use very long names
02:19:22 <Zao> dhun: Depends. It should at least be remotely legible.
02:19:31 <dhun> ok
02:19:52 <Twey> Especially if it's to be exported
02:19:55 <fasta> dhun: I had names which where over 50 characters, just because they did  something complicated.
02:20:03 <Axman6> dhun: it's good to use uderstandable names, verbosity is not needed for understanding, and can make it harder to understand
02:20:12 <Twey> But the longer the name, the shorter the function should be, I think :)
02:20:19 <Zao> Skim Hoogle and Hackage. That should give an indication for reasonable names.
02:20:21 <dhun> Axman6 yes that is the point
02:20:22 <Axman6> and less useful
02:20:35 <C-Keen> doserj: it is all part of the ghc package, I just don't understand why it does not get used
02:20:37 <Twey> Long-named functions are doing complicated things so they should really just be glue code over some simpler functions
02:20:55 <Cale> The most commonly used names should be the shortest, and the things with larger scopes should have longer names than things with smaller scopes.
02:20:56 <Beelsebob> What do people think of Haskell Batteries Included logo version 2... http://www.cs.kent.ac.uk/people/rpg/tatd2/logo-1.png (s/png/svg/ for vector version)
02:21:01 <Axman6> theFunctionThatTakesAStringAndPrintsItToStdOutWithANewLine is not as good as putStrLn
02:21:06 <Twey> Hahaha
02:21:08 <dhun> what I am also unhappy about it this:
02:21:08 <dhun>         (dimage i (dcaption l i (min f (imgscale l)))
02:21:08 <dhun>          (dexten l) (min f (imgscale l)))++(dirk xs (i+1) f)
02:21:19 <Zao> h . g . f x $ 3  vs.  frob . nub . meepBy x $ 3
02:21:20 <Axman6> wow, how lisp like
02:21:21 <fasta> Encoding the assumptions in the name can sometimes be helpful.
02:21:22 <dhun> there are so many braces
02:21:35 <Zao> dhun: Ever considered $ ?
02:21:43 <dhun> what is $?
02:21:47 <Axman6> dhun: many of which are not necessary
02:21:50 * Twey chuckles.
02:21:52 <Axman6> @src ($
02:21:53 <lambdabot> Source not found. :(
02:21:55 <Axman6> @src ($)
02:21:55 <lambdabot> f $ x = f x
02:22:10 <pastorn> dhun: what function is that?
02:22:16 <Axman6> lets you right (f . g . h) x as f . g . h $ x
02:22:26 <Zao> f $ a b c  === f (a b c)
02:22:36 <dhun> it creates a string from a wikilink-node in the parse tree
02:23:01 <Cale> --> dimage i (dcaption l i . min f . imgscale $ l) (dexten l) (min f . imgscale $ l) ++ dirk xs (i+1) f
02:23:09 <dhun> Axman6 looks nice
02:23:18 <Axman6> it's very handy
02:23:25 <Cale> and from there, we can see that min f . imgscale is getting repeated
02:23:50 <Twey> dhun: (dimage i . dcaption l i . min f $ imgscale l) (dexten l) (min f $ imgscale l) ++ dirk xs (i + 1) f
02:24:15 <dhun> can I avoid repeating it?
02:24:41 <Axman6> repeating what?
02:24:43 <Cale> dhun: you can give it a name in a where clause
02:24:49 <Twey> dhun: (dimage i $ dcaption l i minscale) (dexten l) minscale ++ dirk xs (i + 1) f where minscale = min f . imgscale
02:24:53 <fasta> Is there a remove all unused imports program transformation implemented somewhere?
02:24:55 <dhun> ok
02:26:47 <Cale> I have a feeling that dirk can be refactored such that it's not recursive.
02:26:59 <mmorrow> fasta: hmm, i think you'd need to somehow hook into ghc for that info, but assuming you magically had it, it could be done pretty easily with haskell-src-exts (if you can deal with its prettyprinter reformatting everything)
02:27:00 <Cale> But I don't understand well enough what it's doing in order to do it :)
02:27:29 <dhun> well dirk walks through a tree
02:27:46 <dhun> I think it is hard to do it without recusion
02:27:48 <Twey> Poor Dirk
02:27:50 <mmorrow> fasta: also, checked haskell-src-exts strips comments (unless this was changed in the most recent release or two)
02:27:51 <Twey> That sounds painful
02:27:52 <C-Keen> Cale: ah I found the reason: libiconv is missing here. Still strange that it silently skips the build if it is mandatory later: it was not easy to spot the checking whether to use -liconv... Setup: Unable to link against the iconv library. in the build output
02:28:09 <Cale> dhun: Even walks through a tree are possible to write without recursion :)
02:28:09 <pastorn> dhun: pasted again: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5794#a5797
02:28:31 <mmorrow> err, *last i checked...
02:28:40 <Cale> dhun: The idea being that you factor the recursive part out to begin with and have a very general function which you fill in with non-recursive details.
02:28:44 <fasta> mmorrow: it should simply delete the line from the source file when it doesn't use the module. haskell-src-exts is no option because of that.
02:28:55 <mmorrow> fasta: ah true
02:29:10 * mmorrow was overthinking this one
02:29:14 <dhun> pastorn you mean indentation?
02:29:28 <doserj> fasta: that doesn't handle import lists
02:29:33 <dhun> so something like visitor pattern?
02:29:49 <fasta> mmorrow: why not?
02:29:55 <Cale> dhun: Let's start with lists :)
02:29:58 <mmorrow> fasta: yeah, you'd seed some regex trickery, but it could be done
02:29:59 <fasta> doserj: why not?
02:30:04 <Cale> dhun: Consider this function:
02:30:11 <Cale> sum [] = 0
02:30:28 <Cale> sum (x:xs) = x + sum xs
02:30:28 <pastorn> dhun: that and the use of (.)
02:30:28 <Cale> and this one:
02:30:28 <Cale> product [] = 1
02:30:30 <Cale> product (x:xs) = x * product xs
02:30:32 <ejt> which ghc extension do I need to read about to learn about ::: ?
02:30:40 <fasta> mmorrow: regex and program transformations are a bad combination, that said, I do use it do global search and destroy.
02:30:53 <doserj> fasta: import M (f, g, h), when h is not used, should be transformed to import M (f, g)
02:30:54 <Cale> ejt: That looks like perhaps the name of a type constructor or data constructor
02:31:04 <ejt> ah!
02:31:13 <mmorrow> fasta: heh, regexes are excellent for search and destroy missions
02:31:13 <fasta> doserj: yes, it should, but I don't care a lot about that. I had considered that case already.
02:31:14 <Cale> dhun: It's very repetitive isn't it?
02:31:18 <dhun> yes
02:31:20 <dhun> right
02:31:23 <ejt> thx
02:31:36 <Cale> dhun: The only difference between sum and product is that 0 changed to 1 and (+) changed to (*)
02:31:43 <dhun> yes right
02:31:54 <Cale> dhun: So what if we wrote a function which took that 0 and (+) or 1 and (*) as a parameter
02:31:59 <dhun> yes
02:32:02 <Cale> but did the same thing :)
02:32:11 <dhun> you are right
02:32:21 <dhun> but somebody has cetainly done it
02:32:25 <Cale> :t foldr
02:32:26 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
02:32:29 <dhun> ok
02:32:31 <Cale> @src foldr
02:32:31 <lambdabot> foldr f z []     = z
02:32:31 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
02:32:39 <mux> that's more or less mconcat, if you omit the newtype wrapping for Sum and Product
02:32:41 <Cale> That's what it looks like :)
02:32:47 <Cale> > foldr (+) 0 [1..10]
02:32:48 <mux> oh, you were explaining folds
02:32:49 <lambdabot>   55
02:32:50 * mux bites his tongue
02:32:54 <Cale> > foldr (*) 1 [1..10]
02:32:55 <lambdabot>   3628800
02:33:19 <fasta> mux: cutting your fingers is more effective
02:33:23 <Cale> and so we get to define  sum = foldr (+) 0  and product = foldr (*) 1  once we have that
02:33:35 <mux> fasta: bust has long lasting consequences ;-)
02:33:53 <dhun> yes cool
02:33:59 <pastorn> fasta: how would you know?
02:34:01 <Cale> (which doesn't explicitly mention recursion)
02:34:03 <dhun> I can really factor out that part
02:34:06 <fasta> mux: just being helpful ;)
02:34:09 <Cale> Let's take another type, a tree
02:34:21 <Cale> data Tree a = Leaf | Branch a (Tree a) (Tree a)
02:34:48 <Cale> We can write a function which replaces the data constructors of this type with other functions/values
02:35:02 <Cale> foldTree l b Leaf = l
02:35:29 <dhun> ok
02:35:35 <Cale> foldTree l b (Branch x left right) = b x (foldTree l b left) (foldTree l b right)
02:35:52 <Axman6> foldTree :: ?
02:36:20 <Cale> foldTree :: b -> (a -> b -> b -> b) -> Tree a -> b
02:36:38 <Axman6> ah ha
02:36:55 <Cale> foldTree l b  goes through a tree and replaces each occurrence of Branch with b and each Leaf with l
02:37:31 <Cale> We can then write things like  flipTree = foldTree Leaf (\x l r -> Branch x r l)
02:37:50 <Cale> depth = foldTree 0 (\x l r -> 1 + max l r)
02:38:06 <dhun> sorry I can not understand that yes
02:38:08 <Cale> flatten = foldTree [] (\x l r -> l ++ [x] ++ r)
02:38:10 <dhun> yet
02:38:13 <Cale> okay
02:38:25 <dhun> but I got foldr
02:38:38 <Cale> http://cale.yi.org/index.php/Fold_Diagrams
02:38:46 <dhun> and I know you can do something similar for other data structures as well
02:38:47 <Cale> Just look at the top left one for foldr for now :)
02:38:57 <Cale> So that you get the idea for what foldr is doing structurally
02:39:13 <dblhelix> Cale: nice!
02:39:14 <Cale> foldr f z replaces each (:) in a list with f and the [] at the end with z
02:39:41 <Cale> > foldr f z [1,2,3,4,5]
02:39:42 <lambdabot>   f 1 (f 2 (f 3 (f 4 (f 5 z))))
02:40:14 <Cale> (that's a fancy lambdabot trick using the simplereflect package from hackage)
02:40:34 <Cale> dhun: Does that much make sense?
02:40:50 <ivanm> Cale: so it's s/:/f/g and s/[]/z/ ? :p
02:40:50 <dhun> wait
02:41:26 <Cale> ivanm: yeah :)
02:42:29 <twb> Is the hpaste maintainer around?
02:42:35 <mmorrow> twb: yes
02:42:56 <twb> Can you change  alt="save" ... value="preview", so that alt="preview"?
02:43:04 <twb> Having two buttons that say "save" is confusing.
02:43:38 <twb> (On the "new" page.)
02:43:52 <mmorrow> twb: hmm, although i didn't write the program, i'll look into it.
02:43:59 <mmorrow> twb: that sounds logical
02:44:18 <dhun> Cale yes it make sense
02:44:29 <twb> Looks like src/Pages.hs:117
02:44:43 <dhun> I can really factor out going through the list with that
02:44:48 <mmorrow> twb: ohh, ok. i see exactly what you're saying. yeah that does make more sense.
02:45:03 <Cale> dhun: right, in most cases, you don't need to do recursion directly
02:45:34 <Cale> dhun: there are many variations for different purposes -- it's really important to get familiar with the list library, because lists essentially are our loops
02:45:48 <dhun> yes
02:45:55 <mmorrow> twb: hmm, i guess it'll also have to test for `value' if alt="save" for backwards compat
02:46:05 <twb> mmorrow: if you have an email address, I can send the git patch now.
02:46:13 <mmorrow> twb: oh beautiful.
02:46:20 <twb> No testing, though :-)
02:46:23 <Cale> But yeah, we can do this with other kinds of recursive structures too -- like trees.
02:46:44 <Cale> Just replacing the node constructors with some other functions systematically
02:47:03 <hackagebot> multirec 0.4 - Generic programming for families of recursive datatypes (AndresLoeh)
02:47:30 <Cale> and no sooner do I say that, than a library dedicated to it is announced ;)
02:48:03 <hackagebot> zipper 0.3 - Generic zipper for families of recursive datatypes (AndresLoeh)
02:48:16 <Cale> Andres must be watching us :)
02:49:57 <kosmikus> Cale: heh :)
02:50:03 <kosmikus> Cale: I haven't been watching, actually
02:51:11 <mmorrow> ceiling cat?
02:51:28 <fasta> mmorrow: so, did you finish the paper already? ;)
02:52:00 <dhun> pastorn your are right about (.)
02:52:08 <mmorrow> fasta: ahh, i just 10 minutes ago finished reading through it. very interesting.
02:52:50 <mmorrow> fasta: i really like this idea in general of self-modifying stuff
02:53:49 <fasta> mmorrow: The idea is nice, but if you leave it on for a long time, and have a look at the current source code, it will be kind of difficult to understand.
02:54:01 <fasta> mmorrow: it is basically magic at that point.
02:55:10 <mmorrow> fasta: yeah, although it's output could always be a readable version of its current code/state/something..
02:55:29 <fasta> mmorrow: yes, you could give the machine points for understandability.
02:55:39 <fasta> mmorrow: so, even that in theory would not be a problem.
02:56:01 <mmorrow> fasta: i wonder if there're any implementatoins (at any level) of this stuff?
02:56:30 <fasta> mmorrow: there is nothing publically available.
02:56:37 <fasta> mmorrow: I want to build one some day.
02:56:43 <mmorrow> fasta: me too
02:56:51 <fasta> mmorrow: you do?
02:57:00 <mmorrow> yes :)
03:11:29 <uzytkownik> How to specify search path for runhaskell?
03:13:48 <ivanm> uzytkownik: which OS?
03:15:06 <uzytkownik> ivanm: GNU/Linux. However I'd prefer it to be cross-platform as it is for test running.
03:15:33 <ivanm> well, on *nix you set your PATH
03:15:46 <ivanm> in windows, you set it in some weird dialog
03:15:58 <uzytkownik> ivanm: You misunderstood me
03:16:00 <Axman6> i think he means the library search path
03:16:03 <ivanm> uzytkownik: on *nix, you basically make sure you install it properly ;-)
03:16:05 <ivanm> Axman6: ahhhh
03:16:14 * ivanm has no idea about that then.... that's a GHC thing
03:16:15 <uzytkownik> Axman6: Yes
03:16:36 <ivanm> well, GHC/package manager thing
03:17:42 <uzytkownik> ivanm: BTW. AFAIR set %PATH%=something sets PATH in windows shell. Probably there is something for PowerShell as well.
03:18:24 <RayNbow> you don't need the % when setting PATH
03:22:08 <uzytkownik> RayNbow: Ups. I haven't used Windows longer then 30 min since 2004.
03:23:51 <asoare> hey guys I have one more question regarding gtk2hs :-s http://pastebin.com/d52d04258 if you look at lines 322 and 326, I have 2 onExpose events and I would like to have just one - how do I redraw a picture on line 326 without having to use onExpose again ?
03:24:20 <dcoutts> asoare: communicate using state
03:24:32 <asoare> dcoutts: can you be more specific ?
03:24:57 <dcoutts> asoare: have your single expose handler read the info it needs from an IORef or equivalent
03:25:38 <asoare> I see
03:26:17 <asoare> oh and one more thing - something weird happens, I have 2 buttons in the main window and everytime i move the mouse over them, some faded lines are drawn on the canvas - do you know why that happens ?
03:31:39 <dhun> I looked at the dirk function in more detail now, I think I can not factor out recusion easyly
03:32:32 <fasta> dhun: recursion is not always a bad thing.
03:32:42 <fasta> dhun: where is your code?
03:33:27 <dhun> be warned the code is chatic
03:33:32 <dhun> http://de.wikibooks.org/wiki/Benutzer:Dirk_Huenniger/haskell
03:33:44 <dhun> the point is that dirk goes through a list
03:33:57 <dhun> but it gets an integer as parameter
03:34:30 <dhun> and this integer has to increase if a certain node is processed
03:34:54 <uzytkownik> Is there any good description how to set up tests in cabalized package? All I found is description of library API and the file structure.
03:40:20 <Saizan_> dhun: do you ever change f?
03:40:27 <fasta> dhun: you can still use a fold for that.
03:40:40 <dhun> when I walk through my parsetree writing the latex file, I have to keep track of the number of image already written, currently I am giving the writelatex function a parameter imagenumber and increase it accoredingly is there any better way?
03:40:46 <Saizan_> or mapM in the State Int monad, i think
03:40:50 <fasta> dhun: but I do not see exactly what part of the code you are referring to.
03:40:54 <dhun> I change f
03:41:16 <dhun> ++(dirk xs (i+(length (getimg l))) f)
03:41:32 <fasta> dhun: using ++ might make it run slow, btw.
03:41:33 <dhun> dirk ((Reserved (Str "&middot;") l):xs) i f=
03:41:54 <fasta> dhun: some compilers use difference lists to solve that particular problem.
03:42:08 <dhun> so I if I find a node of type Reserved
03:42:21 <dhun> it will have something in it which I call l
03:42:52 <dhun> and depending on l I will call dirk for the rest of the list
03:43:38 <dhun> Saizan_ here I change it (f*(tblscale (maxcolumns l)))
03:44:23 <Twey> f * tblscale (maxcolumns l)
03:44:23 <Saizan_> dhun: but you don't pass that value to the recursive call to dirk
03:44:30 <Saizan_> dhun: that's what i meant by "change"
03:44:48 <dhun> well partially right
03:44:52 <Saizan_> dhun: the 'f' value you pass to the recusive call to dirk is always the same as the one taken as parameter
03:45:29 <Saizan_> dhun: so you could avoid passing it around like that altogether
03:45:50 <dhun> I do something like dirk ((Node a):xs) f= (dirk a f*42)++(dirk xs )
03:46:21 <dhun> I do something like dirk ((Node a):xs) f= (dirk a f*42)++(dirk xs  f)
03:46:22 <dhun> so
03:46:34 <Saizan_> where?
03:46:57 <dhun> dirk ((Wikitable (Str s) l):xs) i f=...
03:47:55 <Saizan_> i don't see it
03:48:24 <Saizan_> however (dirk a f*42) is wrong, you want (dirk a (f*42))
03:48:32 <dhun> yes
03:49:06 <dhun> I call dt2
03:49:09 <dhun> and in dt2
03:49:10 <dhun> dt2 (x:xs) i f b=(dirk [x] i f)++(dt2 xs (i+(length (getimg [x]))) f b)
03:49:35 <dhun> so it is a recursion that is hidden by the call to dt2
03:50:42 <Saizan_> that doesn't really matter
03:50:47 <dhun> why
03:52:33 <pastorn> dhun: there is i function mapAccumL
03:52:36 <pastorn> :t mapAccumL
03:52:37 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
03:53:21 <Saizan_> ok, i'm wrong, it does matter :)
03:53:24 <pastorn> as you said you needed to keep track of old values
03:53:31 <Saizan_> however dst2 is the same kind of recursion
03:53:41 <Saizan_> *dt2
03:55:17 <Saizan_> wait, but dt2 doesn't take the same list as argument as the one passed to dirk, does it?
03:55:21 <hackagebot> data-reify-cse 0.0.1 - Common Sub-Expression Elimination for graphs generated by Data.Reify. (SebastiaanVisser)
03:55:37 <Saizan_> dt2 (dt (dt5 l) False
03:55:39 <dhun> not really
03:56:11 <dhun> I do something like dirk ((Node a):xs) f= (dirk a (f*42))++(dirk xs  f)
03:56:15 <dhun> it takes a
03:56:30 <dhun> where dirk takes x:xs
03:56:52 <Saizan_> that's dirk again, not dt2
03:57:36 <dhun> I don't really understand
03:57:47 <Saizan_> what?
03:58:32 <dhun> dt2 gets the list a which is not the list x:xs when called from dirk
03:58:39 <dhun> l
03:58:41 <dhun> not a
03:58:44 <Saizan_> i'm trying to abstract away the fact that in all the cases you end up calling dirk on the tail of the list
03:59:08 <dhun> yes I also tryed
03:59:16 <dhun> but I think its not easy
04:00:10 <dhun> it is right that the f I pass to (dirk xs) if the same as the one dirk got on input
04:00:39 <dhun> but this is not true for the f I pass to (dirk l)
04:01:17 <Saizan_> but we can eliminate the direct recursion to (dirk xs) while keeping the one to (dirk l) (for now at least)
04:01:20 <dhun> pastorn also for you I got something like
04:01:20 <dhun> fun  ((Node x):xs) i= (fun x i)++fun xs (i+1)
04:01:20 <dhun> fun  ((Leaf):xs) i= fun xs (i)
04:01:28 <dhun> but that i and not f
04:01:43 <Saizan_> that can be taken care of with mapAccumL
04:01:50 <dhun> maybe
04:02:18 <dhun> maybe we get solve that with respect to l
04:02:22 <dhun> maybe we get solve that with respect to f
04:02:25 <dhun> sorry
04:02:42 <dhun> and maybe we can make to code shorter that way
04:03:16 <dhun> but there is the problem of i. In which this i change in the call (dirk xs)
04:03:34 <dhun> but this is possebly orthogonal to the one with f
04:03:51 <Saizan_> mapAccumL (\i e -> case e of Node x -> (i+1, fun x i); Leaf -> (i,[]))
04:04:17 <Saizan_> do you see how "i" is handled there?
04:04:50 <Saizan_> it's actually nicer with the State monad if you don't change i most of the time
04:06:25 <dhun> I am reading on that now
04:06:30 <dhun> will take some time
04:07:53 <Saizan_> thw whole definition is:
04:08:37 <Saizan_> fun str i0 = concat (snd (mapAccumL (\i e -> case e of Node x -> (i+1, fun x i); Leaf -> (i,[])) i0 str))
04:09:21 <dhun> the example on the web are more helpful for me
04:09:32 <Saizan_> which?
04:09:43 <dhun> http://www.zvon.org/other/haskell/Outputlist/mapAccumL_f.html
04:09:58 <Saizan_> ah, ok
04:10:22 <Saizan_> i just took your fun above and translated it
04:11:02 <dhun> I don't understand it yet, but maybe I will after reading some more minutes
04:16:40 <dhun> ok, this looks fine to me
04:18:43 <dhun> this way you can factor out the problem of i
05:00:14 <dhun> Saizan_ I wrote a simplified version of the problem, now I will try to factor out the recursion
05:00:20 <dhun> http://de.wikibooks.org/wiki/Benutzer:Dirk_Huenniger/haskell2
05:01:58 <Saizan_> dhun: i see, i can help if you get stuck
05:02:57 <C-Keen> Cale: I solved my haskeline problem from this morning
05:03:04 <C-Keen> Cale: thanks for all the hints
05:03:14 <Acteum> if Tree is 'intelligently' deriving Show, shouldn't (show l) just work straight away?
05:03:44 <Acteum> or is that only with a GHC extension?
05:05:20 <Saizan_> intelligently?
05:05:41 <Saizan_> the derived show instance will use a different output format
05:06:58 <Acteum> oh yeah, you are putting the names of fields into the output string. okay.
05:11:42 <harlekin> @type (.)
05:11:43 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
05:12:04 <harlekin> @hoogle (b -> m c) -> (a -> m b) -> m a -> m c
05:12:04 <lambdabot> Control.Monad (<=<) :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c
05:12:04 <lambdabot> Control.Monad (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
05:12:04 <lambdabot> Data.Generics.Aliases extMp :: (MonadPlus m, Typeable a, Typeable b) => (a -> m a) -> (b -> m b) -> a -> m a
05:17:14 <harlekin> @hoogle (a -> f b) -> f a -> f b
05:17:14 <lambdabot> Prelude (=<<) :: Monad m => (a -> m b) -> m a -> m b
05:17:15 <lambdabot> Control.Monad (=<<) :: Monad m => (a -> m b) -> m a -> m b
05:17:15 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
05:23:24 <harlekin> @pl (\(p, fs, d, t, fn) -> (fn, (p, fs, d, t)))
05:23:24 <lambdabot> (line 1, column 9):
05:23:25 <lambdabot> unexpected ","
05:23:25 <lambdabot> expecting letter or digit, operator or ")"
05:23:25 <lambdabot> ambiguous use of a non associative operator
05:29:07 <ClaudiusMaximus> some videos made with haskell http://www.archive.org/details/ClaudiusMaximus_-_ULCIv1
05:37:19 <uzytkownik> What's wrong with it: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5803#a5803?
05:39:26 <dhun> Saizan_ I thing I factored out recursion now. But I think it the coded does not look much better now, but I am not experienced enough to tell for sure
05:39:28 <dhun> http://de.wikibooks.org/wiki/Benutzer:Dirk_Huenniger/haskell2
05:39:29 <Taejo> I have cabal-install installed user, and I'm trying to install it global, but when I do cabal install --global cabal-install, it tries to compile network-2.1.0.0, which ghc-pkg says I already have
05:40:51 <dhun> I added Node2 and Node3 to show that I have many of them in the real case
05:46:58 <ivanm> Taejo: is network installed locally or globally?
05:47:51 <Taejo> ivanm: globally, but I think I may have figured it out -- ubuntu seems to have put ghc-pkg in one place and look for it in another
05:48:32 <ivanm> silly *buntu ;-)
05:48:52 <dcoutts> Taejo: cabal just looks for ghc-pkg on the $PATH
05:49:31 <dhun> maybe someone else can tell me why it is better to factor out recursion, an if I did that correctly in the file http://de.wikibooks.org/wiki/Benutzer:Dirk_Huenniger/haskell2 in fun2
05:53:10 <ivanm> dhun: you factor out recursion into a higher-order function so that you have a function that does the recursion (i.e. an abstraction mechanism)
05:53:32 <saml> @type recurse
05:53:33 <lambdabot> Not in scope: `recurse'
05:53:42 <dhun> I did that fun2 l j f=concat (snd (mapAccumL (fun3 f) j l))
05:54:09 <Taejo> saml: there's more than one way to recurse
05:54:11 <dhun> where fun2 was recursive before
05:54:22 <fasta> dhun: some higher-level functions have more efficient implementations, and some people prefer the use of higher-level functions.
05:54:34 <saml> you build data and traverse it
05:54:39 <fasta> dhun: but fundamentally, there is no "better".
05:54:55 <dhun> ok
05:55:22 <fasta> For example, I don't use postpromorphisms.
05:55:32 <fasta> Or if I do, I am not aware of them.
05:55:32 <dhun> whatever
05:55:41 <purplepenguins> expostfactomorphisms?
05:56:00 <Taejo> once you get used to it, sum = foldl (+) 0 is easier to read than {sum [] = 0; sum (x:xs) = x + sum xs}
05:56:03 <dhun> postpromorphisms sound like an illness
05:56:10 <Philonous1> Is there a haskell equivalent to global variables? Threading global information through (IO)-functions by parameters gets pretty messy pretty soon.
05:56:28 <Taejo> oh, my explicit recursion is a foldr
05:56:57 <saml> > sum [1,2..10]
05:56:58 <lambdabot>   55
05:57:00 <purplepenguins> global variables don't make any sense in haskell
05:57:11 <Philonous1> purplepenguins: Why not?
05:57:24 <Philonous1> I'm talking about IO code, not pure functions
05:57:25 <fasta> Philonous1: you fake them with monads.
05:57:29 <purplepenguins> well, everything is a function, and there should be referential transparency
05:57:42 <purplepenguins> in the sense that deterministic calculations should always return the same value
05:58:12 <purplepenguins> if you depend on a global variable that has mutable state there is no longer that determinism
05:58:23 <fasta> purplepenguins: ?
05:58:26 <Taejo> purplepenguins: that's not entirely true: there is the | var = unsafePerformIO (newIORef foo) | style of global variables
05:58:40 <fasta> purplepenguins: determinism is something else.
05:59:04 <mauke> purplepenguins: then why are there global variables in the standard library?
05:59:23 <fasta> stdin/stdout being the most popular ones.
05:59:35 <Taejo> mauke: are those variable?
05:59:38 <uzytkownik> @hoogle evaluate
05:59:38 <lambdabot> Control.Exception evaluate :: a -> IO a
05:59:38 <lambdabot> Test.QuickCheck evaluate :: Testable a => a -> Gen Result
05:59:42 <purplepenguins> pardon me if I'm wrong...this was only how I understood haskell to work
05:59:56 <Taejo> :t stdin
05:59:57 <lambdabot> Not in scope: `stdin'
06:00:02 <fasta> Nobody knows how Haskell works, because there is no formal semantics.
06:00:07 <Taejo> :t System.IO.stdin
06:00:08 <lambdabot> GHC.IOBase.Handle
06:00:16 <asoare> hey guys, how do I write an instruction "onEnter button1 <do nothing>"
06:00:31 <Taejo> fasta: there are, however, informal semantics, which (as humans) we can understand
06:00:32 <mauke> Taejo: there's a global rng
06:00:37 <mauke> also the stuff in System.Environment
06:00:39 <gwern> asoare: $ return ()?
06:00:49 <purplepenguins> hmm
06:01:01 <fasta> Taejo: I disagree. I still don't know exactly what the contract is of unsafePerformIO.
06:01:02 <gwern> mauke: is a global rng observable?
06:01:07 <Taejo> mauke: the rng is true
06:01:12 <uzytkownik> @hoogle finally
06:01:13 <lambdabot> Control.Exception finally :: IO a -> IO b -> IO a
06:01:14 <saml> @hoogle rng
06:01:15 <lambdabot> Distribution.Extension PatternGuards :: Extension
06:01:15 <lambdabot> Language.Haskell.Extension PatternGuards :: Extension
06:01:24 <fasta> Taejo: but for the most part the semantics are clear, yes.
06:01:58 <Taejo> the contract of unsafePerformIO is mutable
06:02:10 <asoare> gwern: yup, thanks
06:02:43 <purplepenguins> so there are global variables in haskell?
06:02:50 <saml> yes
06:03:03 <saml> what are global variables?
06:03:08 <saml> IORef
06:03:24 <fasta> Taejo: what is that supposed to mean?
06:03:24 <saml> MonadState can have get and put
06:03:31 <purplepenguins> I suppose
06:03:48 <purplepenguins> though, those are monads which I have yet to fully understand
06:03:58 <saml> IO is a world. State is another world. so "variables" there are global
06:05:33 <quicksilver> depends rather if you think global is a static (lexical scope) question
06:05:36 <Philonous> saml: That's true, but the handles are lexically scoped.
06:05:39 <Saizan_> there's still a difference between an IORef and a truly global variable
06:05:42 <quicksilver> or a dynamic (program runtime) question.
06:05:57 <quicksilver> haskell has nothing which is global, in the lexical sense, and mutable.
06:06:12 <quicksilver> everything lexically global is a value and thus immutable.
06:06:29 <Philonous> quicksilver: unsafePerformIO (newIORef ... ) comed pretty close, though
06:06:44 <quicksilver> everything mutable is accessed by some special construct like readIORef, writeIORef
06:06:52 <saml> ah! id is global and it's a value!
06:06:56 <purplepenguins> :t unsafePerformIO
06:06:57 <lambdabot> Not in scope: `unsafePerformIO'
06:06:57 <quicksilver> Philonous: (even though that isn't haskell) that thing there at the top level isn't mutable.
06:07:04 <purplepenguins> hmm
06:07:08 <quicksilver> Philonous: that thing at the top level is just the *name* of the variable
06:07:11 <quicksilver> a reference to it.
06:07:16 <quicksilver> YOu don't change the name / reference.
06:07:24 <quicksilver> you change the contents (using readIORef, writeIORef)
06:07:55 <Philonous> quicksilver: That's what I meant by "pretty close"
06:08:03 <quicksilver> stdin is very similar, actually.
06:08:09 <quicksilver> stdin is global, but the global thing is just the name.
06:08:18 <quicksilver> you can't mutate stdin itself - you can't make it into a different handle.
06:08:22 <quicksilver> all you can do is use it.
06:08:27 <Philonous> I'm not sure though whether this is good practice. It looks hideous.
06:08:27 <quicksilver> it's no more mutable than "putStrLn" is mutable
06:08:33 <quicksilver> putStrLn is another top-level name.
06:08:55 <quicksilver> Philonous: it is hideous, bad practice, morally reprehensible, and should probably be legally actionable.
06:10:02 <saml> > let a = 1; a = 2 in a
06:10:04 <lambdabot>   Conflicting definitions for `a'
06:10:04 <lambdabot>  In the binding group for: a, a
06:10:12 <Philonous> (I've seen it in the standardlibs, though)
06:10:22 <quicksilver> Philonous: yes. embarassing isn't it?
06:10:35 <saml> > let a = 1 in let a = a + 1 in a
06:10:40 <lambdabot>   mueval-core: Prelude.read: no parse
06:10:40 <lambdabot>  mueval: ExitFailure 1
06:11:23 <Philonous> quicksilver: I don't know. The alternative would be to have funktions with maybe 50 parameters or more. I don't think that makes the code readable.
06:13:12 <tibbe> I'm trying to work with MutableArray# (yes, I know it's very low level) and I can't get this short function to work:
06:13:15 <saml> all functions only take 1 paremeter
06:13:17 <tibbe> new' :: Int -> a -> ST s (MutableArray# s a)
06:13:17 <tibbe> new' n@(I# n#) initial = ST (newArray# n# initial)
06:13:55 <dhun> I am German an proud of it ... "dhunparserlookaheadbreak"
06:14:11 <saml> @type \ n@(I# n#) initial -> ST (newArray# n# initial)
06:14:12 <lambdabot> Not in scope: data constructor `I#'
06:14:12 <lambdabot> Not in scope: data constructor `ST'
06:14:12 <lambdabot> Not in scope: `newArray#'
06:22:21 <FliP^2eH> Why does a Haskell file of 54 lines compile to 1.2 MEGABYTE of .EXE?
06:23:06 <ivanm> FliP^2eH: RTS
06:23:12 <ivanm> static linking
06:23:15 <ivanm> take your pic
06:23:16 <Saizan_> and libs
06:23:17 <ivanm> *pick
06:23:40 <uzytkownik> @pl \l a -> TestLabel l (TestCase a)
06:23:40 <lambdabot> (. TestCase) . TestLabel
06:23:45 <mauke> the good news is that it won't get much bigger for a 500 or 5000 line file (I think)
06:23:58 <Zao> FliP^2eH: Nice fluffy runtime, dependent libraries, pie.
06:24:02 <ivanm> mauke: depends on how many libs you use ;-)
06:24:13 <ivanm> Zao: "fluffy"? GHC uses fabric conditioner, does it? :p
06:25:09 <FliP^2eH> Using -optl -s
06:25:11 <FliP^2eH> I got it down to 600 KB
06:25:16 <FliP^2eH> Still way too much..
06:25:24 <FliP^2eH> It's jut a 54 line program!
06:25:33 <purplepenguins> way too much is subjective
06:25:39 <Zao> Golfing binary size is rather silly.
06:25:54 <Zao> Try convincing it to link stuff dynamically?
06:26:05 <Zao> You would of course have to distribute relevant libs and such.
06:26:21 <FliP^2eH> I don't use any third party libs here
06:26:44 <Zao> FliP^2eH: I'm talking about the runtime and its dependent libs.
06:27:22 <mauke> FliP^2eH: then who calls your main?
06:27:24 <Taejo_> :t liftM2 const
06:27:26 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m a1
06:27:37 <daf> ivanm: is that stripped or unstripped?
06:27:48 <ivanm> *shrug*
06:28:18 <FliP^2eH> Interestingly, another Program at about 298 lines compiles to 1.2 MB, too
06:28:23 <FliP^2eH> So it's not my code.
06:28:46 <ivanm> no, we were trying to tell you that!
06:29:43 <FliP^2eH> Oh man
06:29:53 <Heffalump> there's shared library support in the works
06:29:53 <FliP^2eH> Haskell is too fun to ditch it for the output file size
06:30:00 <FliP^2eH> I just keep using -otpl -s
06:30:02 <mauke> <mauke> the good news is that it won't get much bigger for a 500 or 5000 line file (I think)
06:30:41 <ivanm> FliP^2eH: why does binary size matter that much?
06:32:13 <Zao> FliP^2eH: You won't beat my C++ code. A single translation unit built in debug mode yielded a 250 MiB object file.
06:32:27 <Zao> QtWebkit has rather interesting binaries too :P
06:33:25 <ivanm> lol
06:35:14 <FliP^2eH> ivanm
06:35:22 <FliP^2eH> The smaller the bad, eh?
06:35:34 <ivanm> hmmm? no...
06:36:00 <ivanm> but as mauke repeated himself, haskell binaries (produced by ghc at least) all tend to be at the same size, no matter how many LoC they have
06:36:01 <FliP^2eH> better*
06:36:15 <FliP^2eH> 600 KiB is acceptable
06:37:25 * Saizan_ wonders if ditching haskell for the size of binaries produced by GHC is more or less reasonable than doing it for the record syntax
06:37:45 <ivanm> Saizan_: or because of the semantics of using (-)? :p
06:38:02 <Saizan_> ivanm: i've not seen that yet :)
06:38:02 <lilac> Zao: i wrote a 100 line C++ program which compiled (with -O2) to a 50MB binary once
06:38:05 <lilac> template fun
06:38:44 <ivanm> Saizan_: a few months back, someone complained that -5 should always be "negative 5", but that - 5 is subtract 5 or something
06:38:58 <mauke> there's a 4 line C++ program that takes forever to compile, IIRC because g++ tries to eat all your memory
06:39:01 <ivanm> after bitching about it here, he said he wasn't going to learn such a stupid languagge and left
06:39:10 <Saizan_> > - 5
06:39:14 <lambdabot>   -5
06:39:20 <Saizan_> the opposite maybe
06:39:20 <hape_> :-)
06:39:32 <dhun> oh Saizan_ you are back
06:39:40 <lilac> unary - is pretty weird
06:39:46 <FliP^2eH> As we've learned from doing Haskell, mauke, the amount of lines of code is not proportional to the power :)
06:39:51 <p_l> lilac: when they compiled first iostreams "hello, world" they've got >1.5 MB binary... and it could have been worse ;-)
06:39:52 <dhun> I rewrote it but to me it does not look better
06:39:53 <dhun> http://de.wikibooks.org/wiki/Benutzer:Dirk_Huenniger/haskell2
06:40:07 <ivanm> Saizan_: whatever it was
06:40:21 * EvilTerran would make the '-' in '-5' part of the numeric syntax, eliminate unary -, and shorten 'negate' to 'neg'
06:40:37 * lilac would vote for EvilTerran based on that manifesto
06:40:56 <mauke> I fully support the last two points. I have to think about the first one
06:41:15 <lilac> EvilTerran: presumably 3-x would still parse as 3 - x?
06:41:24 <Zao> mauke: http://www.acc.umu.se/~zao/mem2.png
06:41:25 <Saizan_> dhun: fun3 should be defined in a where clause inside fun2 and don't take 'f' as a parameter at all
06:41:43 <mauke> haha, holy shit
06:41:44 <ivanm> EvilTerran: so not have any subtraction operator?
06:42:03 <lilac> EvilTerran: i think i'd want x-3 to parse as x - 3 but x -3 to parse as x (negate 3)
06:42:05 <Zao> And yes, I ran out of swap there :)
06:42:23 <birdspider> hi, where can I apply for an haskell-wiki account ?
06:42:33 <dhun> ok
06:43:17 <Saizan_> dhun: and at that point i'd inline the definition of fun, i think
06:43:42 <mauke> Zao: http://codepad.org/CFRcj00A
06:44:31 * EvilTerran hadn't decided how x-3 would parse
06:44:42 <ivanm> EvilTerran: that's an implementation problem? :p
06:45:00 <dhun> I did http://de.wikibooks.org/wiki/Benutzer:Dirk_Huenniger/haskell2
06:45:42 <dhun> do you think it makes sense to rewrite dirk that way
06:46:36 <EvilTerran> ivanm, it's a matter for further study
06:46:44 <ivanm> heh
06:46:52 <mux> dhun: is your space bar broken? :-)
06:47:09 <dhun> why?
06:47:32 <Saizan_> dhun: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5811#a5811
06:47:40 <mux> your code is hard to read because you rarely put spaces around operators
06:47:44 <EvilTerran> it's conventional to use more spaces in your code
06:47:50 <EvilTerran> particularly around operators
06:48:00 <Zao> mauke: I believe mine generated some sequence through template instantiations at compile time.
06:48:19 <Zao> mauke: Was a bit too strict, and apparently C++ compilers don't throw away unneeded instantiations :)
06:48:45 <mauke> the beauty of this one is that it does no computation, neither at runtime nor compile time
06:48:57 <dhun> ok I will add some spaces
06:49:40 <dhun> I am used to read an write code without those space, but you are not the only people complaining about this
06:50:05 <doserj> dhun, Saizan: often I find concat more readable than long ++ expressions
06:50:10 <EvilTerran> we're not complaining, we're just advising you that we'll be better able to help you with more spaces
06:50:20 <EvilTerran> because we'll be able to read it more easily
06:50:29 <Saizan_> doserj: that's true too
06:50:55 <doserj> ", " is less visual noise than " ++ "
06:51:09 <dhun> Saizan_ your final version of fun included in the where clause is nice
06:51:12 <ivanm> doserj: though wouldn't "concat [a,b,c,...,z]" be slightly less efficient than "a ++ b ++ c ++ .. ++ z" due to the list overhead?
06:51:49 <mauke> ivanm: not if concat gets inlined
06:51:53 <doserj> ivanm: I couldn't care less :)
06:51:56 <Twey> Not anyway
06:52:03 <ivanm> mauke: *nod*
06:52:09 <EvilTerran> with a bit of typeclass hackery, you could make that "build a b c ... z End" or something ;)
06:52:19 <Twey> a ++ b ++ c requires O(a + b), no?
06:52:33 <mauke> printf "%s%s%s%s%s" a b c d e
06:52:48 <EvilTerran> printf counts as (massive) typeclass hackery ;)
06:52:52 <Twey> EvilTerran: It ends up being build a b c ... z :: [Foo] :-P
06:52:59 <dhun> Saizan_ so you think it will be good if I rewrite dirk in the way you proposed in your paste?
06:53:00 <Twey> Oleg did it
06:53:11 <Saizan_> dhun: yes, i think so
06:53:21 <EvilTerran> Twey, or that, yeah; i was taking an idea from the idiom brackets paper, which used iI ... Ii
06:53:22 <dhun> ok so i will do
06:53:32 <Twey> Aha
06:54:03 <hackagebot> HaskellForMaths 0.1 - <i>Added by DavidAmos, Fri Jun 12 13:51:20 UTC 2009.</i>
06:54:03 <hackagebot> nemesis 2009.6.13 - a rake like task management tool (JinjingWang)
06:54:12 <Saizan_> dhun: though, personally, i'd use mapM in the State Int monad, rather than mapAccumL
06:54:53 <Twey> Shame there aren't many letters that work for that
06:54:58 <Twey> Maybe cC ... ÆÉ
06:55:08 <Saizan_> or maybe not
06:55:10 <EvilTerran> Twey, iirc, that one was relying on the fact that (Applicative f => f a) and Ii (where data Ii = Ii) don't overlap
06:55:12 <dhun> ok I can learn about that too, but the point is that I just want to make the code readable to average haskell programmer
06:55:19 <mauke> oO Oo
06:55:33 <Saizan_> dhun: maybe mapAccumL is actually better in this case
06:55:41 <dhun> if I need to use the state monad for that I will learn about otherwise I will not yet
06:55:42 <Saizan_> dhun: i'd have to try :)
06:55:54 <Twey> And of course you can combine them... oA Ao
06:56:36 <mauke> E â
06:56:54 <dhun> try what?
06:56:59 <EvilTerran> Twey, or use greek/cyrillic/hebrew/etc letters
06:57:35 <ClaudiusMaximus> are there any nice 2d gui libraries based on opengl?  i want to make something like a graph editor (click to create nodes, drag and drop to create links, etc)
06:57:40 <Twey> EvilTerran: *nod*
06:58:07 <Twey> mauke: Doesn't work â the first one has to be lower-case and the last capital :)
06:58:18 <Twey> That's why it's tricky
06:58:27 <EvilTerran> Twey, well, the last can be lowercase as well
06:58:39 <mauke> oEO Oâo
06:58:45 <Twey> I suppose it's a simple wrap
06:58:56 <EvilTerran> foo = Foo, yeah
06:59:00 <mux> did someone package Oleg's type-safe TH printf on hackage?
06:59:02 <doserj> d b, q p
06:59:28 <Twey> > isUpper 'â'
06:59:30 <lambdabot>   False
06:59:34 <Twey> > isLower 'â'
06:59:35 <lambdabot>   False
06:59:41 <Twey> :(
06:59:56 <mauke> > isAlpha 'â'
06:59:57 <lambdabot>   False
07:00:07 <Twey> It's a symbol
07:00:41 <saml> THERE EXISTS
07:00:52 <saml> > '\u2203'
07:00:54 <lambdabot>   <no location info>:
07:00:54 <lambdabot>      lexical error in string/character literal at chara...
07:00:59 <Twey> That's the one, yep
07:01:13 <mauke> ââââ¶â¸ââ«âµâ·â²â¹â³â´
07:01:23 <saml> is there lower case version of that?
07:01:37 <saml> â
07:01:40 <Twey> I don't have the ELEMENT OF OPENING DOWNWARDS
07:01:46 <Twey> saml: No, it's a symbol
07:01:56 <mauke> ELEMENT OF FIRE
07:02:03 <Twey> There's É though
07:02:19 <saml> LATIN SMALL LETTER REVERSED E
07:02:38 <mauke> ÆÆªÆ¸Æ¹ÉÉÊâÉÉÉ¿ÊÊ¢á´á´á¶
07:02:43 <saml> http://unicodeforyou.appspot.com/small
07:02:47 <ClaudiusMaximus> all those boxes look alike to me
07:03:00 <mauke> > toLower 'Æ'
07:03:01 <lambdabot>   '\477'
07:03:04 <mauke> success!
07:03:24 <saml> > toLower 'â©¡'
07:03:26 <lambdabot>   '\10849'
07:03:34 <nopsled_X> data Dtype = Dtype { f :: type, f::type, ... } ...
07:03:38 <nopsled_X> whats that ?
07:03:40 <Twey> I think hex representation would be more useful
07:03:43 <nopsled_X> for declaration..
07:03:45 <Twey> nopsled_X: A record
07:03:46 <saml> nopsled_X, does it compile?
07:03:51 <nopsled_X> no
07:03:53 <saml> it should not because f conflicts
07:03:58 <Twey> f needs to be different, yeah
07:04:10 <nopsled_X> its pseudo haskell..
07:04:14 <mauke> also, type is not in scope
07:04:18 <saml> f is a global function that is similar to   f (Dtype x _ _ ..) = x
07:04:43 <nopsled_X> Hmm, ah a record of function declarations
07:05:05 <saml> let's say d :: Dtype.    f d  will return the first element of data constructed with Dtype data ctor.
07:05:23 <jeffersonheard> I've noticed that I could practically reimplment the GTK entirely using nothing but the TreeView widget...  I don't consider this a compliment.
07:05:27 <saml> i think you can set too.
07:05:48 <Saizan_> i guess 'f' and 'type' are syntactical classes there
07:05:48 <Twey> saml: That's magic, though â you don't get setter functions (alas)
07:05:59 <Twey> You can go d { f = newF }
07:06:09 <saml> ah right
07:06:18 <Twey> Which returns a Dtype identical to d except for having f equal to newF
07:06:26 <mauke> and its precedence goes up to 10!
07:06:32 <Twey> Hehe
07:06:38 <mauke> no, 11
07:06:43 <mauke> function application is at 10
07:09:29 <Twey> Does the magic even work with more complicated expressions?  â(g d) { f = 5 }â ?
07:10:41 <Saizan_> yes
07:15:07 <uzytkownik> @pl \h -> hPutStrLn h txt >> h
07:15:07 <lambdabot> (>>) =<< flip hPutStrLn txt
07:15:27 <mauke> that doesn't type
07:17:40 <Botje> :t (>>) =<< flip hPutStrLn txt
07:17:43 <lambdabot> Not in scope: `hPutStrLn'
07:17:43 <lambdabot> Not in scope: `txt'
07:17:48 <Botje> sigh :)
07:18:14 <uzytkownik> @pl \h -> hGetLine h >>= (@?="QUIT")
07:18:14 <lambdabot> ((@?= "QUIT") =<<) . hGetLine
07:18:24 <Botje> ah, i see
07:18:49 <Twey> :t (>>) =<< flip (hPutStrLn :: String -> IO ()) (txt :: String)
07:18:50 <lambdabot> Not in scope: `hPutStrLn'
07:18:51 <lambdabot> Not in scope: `txt'
07:18:53 <Twey> Aw
07:18:58 <Twey> Oh!
07:19:07 <Twey> :t (>>) =<< flip (undefined :: String -> IO ()) (undefined :: String)
07:19:08 <lambdabot>     Couldn't match expected type `b -> c' against inferred type `IO ()'
07:19:09 <lambdabot>     In the first argument of `flip', namely
07:19:09 <lambdabot>         `(undefined :: String -> IO ())'
07:19:12 <Twey> There we go
07:19:17 <mauke> you're doing it wrong
07:19:37 <Twey> Yes, I was angling for the error :-P
07:19:47 <uzytkownik>  :t (>>) =<< flip (undefined :: Handle -> String -> IO ()) (undefined :: String)
07:19:52 <mauke> that's the wrong error
07:19:55 <uzytkownik> :t (>>) =<< flip (undefined :: Handle -> String -> IO ()) (undefined :: String)
07:19:56 <lambdabot>     Not in scope: type constructor or class `Handle'
07:20:05 <uzytkownik> :t (>>) =<< flip (undefined :: Int -> String -> IO ()) (undefined :: String)
07:20:06 <lambdabot>     Couldn't match expected type `m b' against inferred type `Int'
07:20:06 <lambdabot>     In the first argument of `flip', namely
07:20:06 <lambdabot>         `(undefined :: Int -> String -> IO ())'
07:20:15 <mauke> this is the right error
07:21:12 <uzytkownik> @pl \h -> (undefined :: Int -> String -> IO ()) h txt >> h
07:21:12 <lambdabot> (line 1, column 25):
07:21:12 <lambdabot> unexpected ">"
07:21:12 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or ")"
07:21:17 <mauke> :t \h -> IO.hPutStrLn h ?txt >> h
07:21:18 <lambdabot>     Couldn't match expected type `IO b'
07:21:18 <lambdabot>            against inferred type `GHC.IOBase.Handle'
07:21:18 <lambdabot>     In the second argument of `(>>)', namely `h'
07:21:24 <MrChutney> If I'm using a library downloaded with cabal, and the library works perfectly in ghci, but a program which uses the library (even really simple ones) stop in the middle of compilation with a bunch of "undefined reference" errors, does that in itself give any clue as to what I might be doing wrong? :/
07:21:32 <MrChutney> The library I'm trying to use is hmatrix.
07:21:33 <mauke> ^ the original code is mistyped
07:21:57 <ivanm> MrChutney: do you have lapack, blas and gslib installed?
07:22:00 <uzytkownik> @pl \h -> ((hPutStrLn h txt) >> h)
07:22:00 <lambdabot> (>>) =<< flip hPutStrLn txt
07:22:02 <MrChutney> Yes.
07:22:09 <mauke> MrChutney: which symbols are undefined?
07:22:18 <doserj> MrChutney: compile with --make?
07:22:24 <dino-> MrChutney, ivanm, mauke: Could that be a linker problem?
07:22:36 <mauke> what do you mean by "linker problem"?
07:23:04 <EvilTerran> uzytkownik, that's still not well-typed
07:23:22 <EvilTerran> uzytkownik, because of "hPutStrLn h", we know "h :: Handle"
07:23:28 <uzytkownik> EvilTerran: I know. It is exactly the same
07:23:36 <EvilTerran> but because of ">> h", we know "h :: IO a"
07:24:31 <MrChutney> Sorry. Trying to copy a piece of the error as an example, but I'm having technical difficulties. One moment!
07:24:54 <dino-> mauke: Eh, I probably don't know what I'm talking about. I was thinking of a problem with hscurses where I ended up having to add extra-libraries: ncurses to the cabal file
07:24:55 <uzytkownik> EvilTerran: Kleisli (flip hPutStrLn undefined) &&& arr id >>> arr snd is correct I believe
07:25:58 <MrChutney> Oh, cool! Actually, compiling with --make worked :D
07:26:03 <MrChutney> Thanks for the support.
07:26:22 <EvilTerran> uzytkownik, that looks like (\h -> hPutStrLn h undefined >> return h) to me
07:26:32 <EvilTerran> :: Handle -> IO Handle
07:26:52 <uzytkownik> BTW. Whats for returnA is arr id is shorter? And why return and returnA instead idM and idM?
07:27:32 <uzytkownik> EvilTerran: I put it in newly-discover-to-me arrow anyway...
07:33:38 <MrChutney> Woo! My program is working perfectly, too. And no runtime errors. Haskell rocks :D
07:35:01 <Axman6> runtime errors are quite rare with haskell in my experience
07:36:29 <bremner> bugs on the other hand, exist in every non-trivial program ;-)
07:36:51 * bremner defines non-trivial appropriately
07:37:34 <Axman6> non-trivial program: a large program with bugs in it
07:37:43 <bremner> s/large//
07:37:44 <ivanm> bremner: oh, I'm sure it's possible to have bugs in non-trivial programs...
07:37:55 <ivanm> putStrLn "hlelo world!"
07:37:57 <ivanm> ;-)
07:38:02 <EvilTerran> ivanm, s/non-//?
07:38:16 <ivanm> EvilTerran: ummm, yeah :s
07:44:02 <lilac> "every program can be reduced by one instruction. every program contains at least one bug. therefore, by induction, every program can be reduced to a single instruction, which is wrong."
07:47:43 <tromp> why not reduce the single instruction as well?
07:48:33 <SamB> tromp: why stop there?
07:48:51 <SamB> why not reduce it to increasinly negative instructions?
07:49:34 <tromp> can't fathom :(
07:54:04 <FliP^2eH> :t intercalate
07:54:05 <lambdabot> forall a. [a] -> [[a]] -> [a]
07:54:20 <EvilTerran> ?src intercalate
07:54:21 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
07:55:06 <FliP^2eH> > map show [1,2,3]
07:55:07 <lambdabot>   ["1","2","3"]
07:55:10 <FliP^2eH> ...
07:55:13 <EvilTerran> ?src intersperse
07:55:13 <lambdabot> intersperse _   []     = []
07:55:13 <lambdabot> intersperse _   [x]    = [x]
07:55:13 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
07:55:26 <FliP^2eH> I was just about to ask "Any quick and dirty way to apply show to all elements of an array"
07:55:36 <FliP^2eH> When I thought "apply something to everything in a list...? MAP!!"
07:55:47 <idnar> :)
07:55:54 <FliP^2eH> Man, I start learning
07:59:11 <SamB> @src IArray
07:59:11 <lambdabot> Source not found.
07:59:13 <EvilTerran> * Ping reply from wolfe.freenode.net: 27.55 second(s)
07:59:13 <EvilTerran> >.<
07:59:46 <FliP^2eH> SamB: I'm coming from a C-style background
07:59:52 <FliP^2eH> I keep calling Lists Arrays
07:59:54 <FliP^2eH> :d
07:59:58 <FliP^2eH> I ment a List
08:00:05 <FliP^2eH> And I meant meant
08:00:20 <SamB> FliP^2eH: I figured. but that made me wonder if the IArray class has Functor as a superclass!
08:00:37 <SamB> and ... it doesn't :-(
08:00:42 <SamB> oh.
08:00:43 <FliP^2eH> ;o
08:00:44 <SamB> it can't
08:01:02 <SamB> it supports unboxed arrays, after all
08:01:27 <SamB> and those *can't* implement Functor, being only available on selected types
08:02:04 <SamB> Array, on the other hand, of course implements Functor
08:02:22 <mux> I feel like rewriting the IArray stuff to make use of ATs so that unboxed arrays are automatically used when possible, but then I realized that you might still nto want unboxed arrays even if your type supports it if you're looking for laziness
08:02:26 * SamB wonders what extension PArrays are in now
08:02:33 <FliP^2eH> Supercalifragilisticexpialidocious!
08:02:39 <SamB> mux: quite
08:02:50 <SamB> mux: you could make a strict array type that does that though
08:03:00 <mux> that's just too bad, I felt like I was having a good idea.
08:03:50 <SamB> but I have to wonder what the costs of such an implicit approach are?
08:04:07 <SamB> mux: didn't you hear me salvaging your idea just now ?
08:04:23 <mux> I did - I was still pondering it =)
08:04:37 <FliP^2eH> How can I prepare myself for Prelude.read parse exceptions?
08:04:42 <FliP^2eH> try does not work in this case
08:04:51 <SamB> FliP^2eH: use a different method
08:04:59 <FliP^2eH> Mh
08:04:59 <mux> so instead of having boxed vs unboxed array, we'd have lazy and strict arrays (which sounds more idiomatic), with automatical selection of unboxed arrays if possible in the strict case
08:05:02 <FunctorSalad> @ty readS
08:05:03 <mux> I actually like this a lot
08:05:04 <lambdabot> Not in scope: `readS'
08:05:20 <SamB> er, rather, different function
08:05:21 <mux> now, I need to leave work to actually implement this :-P
08:05:23 <SamB> read isn't a method
08:05:41 <SamB> you could call readsPrec directly, of course ...
08:06:16 <SamB> or reads
08:06:20 <SamB> :t readsPrec
08:06:21 <lambdabot> forall a. (Read a) => Int -> String -> [(a, String)]
08:06:22 <SamB> :t reads
08:06:24 <lambdabot> forall a. (Read a) => String -> [(a, String)]
08:07:02 <SamB> FliP^2eH: either way, you'll get an empty list back if the read failed
08:07:59 <FliP^2eH> :D
08:08:01 <FliP^2eH> Perfect
08:08:04 <SamB> and a non-empty list if it found one or more parses
08:08:38 <SamB> it's very unusual to see any thing but empty lists and 1-element lists from that, but could happen
08:09:17 <FliP^2eH> @src readS
08:09:17 <lambdabot> Source not found. You type like i drive.
08:09:18 <SamB> ... if someone wrote a readsPrec that could actually parse something more than one way
08:09:24 <FliP^2eH> Where is readS located?
08:09:26 <SamB> @src reads
08:09:26 <lambdabot> reads = readsPrec minPrec
08:09:37 <SamB> FliP^2eH: it's got a lowercase S, but it's in Prelude
08:09:37 <FliP^2eH> whoops
08:09:38 <FliP^2eH> Caps S
08:10:02 <SamB> FliP^2eH: FunctorSalad must have confused you ;-P
08:10:21 <SamB> notice how he was querying lambdabot about readS as well?
08:10:26 <FliP^2eH> Yep
08:10:59 <FunctorSala> I plead innocent on grounds of the type being called ReadS
08:11:16 <SamB> anyway ... I found those two functions by doing ":b Prelude" in ghci, scrolling to the names starting with "read", and looking for functions that had something like the right type ;-)
08:11:53 <SamB> FunctorSala: I guess that's a fairly reasonable excuse -- I was just trying to make FliP^2eH feel less n00by ;-)
08:12:28 * FliP^2eH is hurt slightly
08:12:34 <SamB> FliP^2eH: why?
08:12:39 <FliP^2eH> I'm a nooby!
08:12:48 <SamB> newbie, actually
08:12:53 <SamB> but we love newbies
08:13:10 <FunctorSala> we even have a prelude function named after them
08:13:12 <SamB> and we like to help them not feel like n00bs ;-)
08:13:25 <Vanadium> FunctorSala: We do?
08:13:29 <Vanadium> I mean. You do?
08:13:40 <FunctorSala> Vanadium: nub
08:13:50 <SamB> FunctorSala: *groan*
08:13:58 <FunctorSala> :D
08:14:01 <Vanadium> That does not seem to be in my prelude D:
08:14:03 <ClaudiusMaximus> @type Prelude.nub
08:14:04 <lambdabot> Not in scope: `Prelude.nub'
08:14:15 <SamB> Vanadium: oh, well, he forgot it was in Data.List
08:14:21 <FunctorSala> indeed
08:14:22 <SamB> that's *almost* Prelude
08:14:33 <SamB> and maybe more of it should be in Prelude
08:15:13 <Vanadium> Why do you not put the entire world into the Prelude?
08:15:36 <hydo> Vanadium: it would be a huge mess, for one.
08:15:39 <SamB> hmm, the Haskell' committee should take nominations for things to export from Prelude
08:15:47 <fasta> Vanadium: because everyone wants a different world.
08:16:04 <SamB> Vanadium: because then it would take forever to compile base?
08:16:09 <fasta> Creating your own world module is not weird, imho.
08:16:18 <SamB> and we'd have to put all that stuff back *into* base
08:16:31 <fasta> Otherwise you get import lists that are pages long per module.
08:16:53 * ClaudiusMaximus ... must resist Bach quip
08:17:11 <SamB> but I say it would take forever to recompile base because of my experience with JHC in the past -- it's Prelude is part of a big hairy Strongly Connected Component in the import graph
08:17:21 <SamB> this entire SCC must be compiled as one compilation unit
08:17:34 <SamB> and it takes a lot of RAM and, thus, a rather long time
08:18:43 <SamB> possibly there are also some algorithms with O(n^2) complexity (or worse) in size-of-SCC
08:19:23 <FliP^2eH> Hah
08:19:29 <FliP^2eH> My new safeRead made my bot.. safe!
08:19:36 <SamB> FliP^2eH: nice
08:19:46 <FliP^2eH> safeRead n = case reads n of
08:19:46 <FliP^2eH>                 []        -> 0
08:19:46 <FliP^2eH>                 (n, _):xs -> n
08:20:08 <SamB> FliP^2eH: you don't feel like checking if the reads parsed the entire string?
08:20:09 <FliP^2eH> When would reads return more than one-sized lists?
08:20:20 <FliP^2eH> It's not thaat important
08:20:28 <mux> > reads "1.23"
08:20:30 <lambdabot>   []
08:20:34 <mux> hmpf.
08:20:46 <FliP^2eH> reads "1"
08:20:48 <FliP^2eH> > reads "1"
08:20:50 <lambdabot>   []
08:21:05 <Axman6> :t reads
08:21:07 <lambdabot> forall a. (Read a) => String -> [(a, String)]
08:21:16 <EvilTerran> > reads "()" -- beware extended defaulting!
08:21:17 <SamB> FliP^2eH: when some readsPrec implementation offered more than one parse, basically
08:21:18 <lambdabot>   [((),"")]
08:21:24 <Axman6> > reads "1.23" :: [(Double,String)]
08:21:25 <lambdabot>   [(1.23,"")]
08:21:49 <SamB> FliP^2eH: I don't know if it ever happens outside of crazy experiments ;-)
08:21:56 <FliP^2eH> :)
08:22:03 <FliP^2eH> This is enough for an IRC bot
08:22:11 <FliP^2eH> [17:20:59] <@FliP^2eH> !rpn 40.2 5 +
08:22:11 <FliP^2eH> [17:20:59] <+LambdaZer0> Result: 45.2. Stack: None
08:22:14 <FliP^2eH> Works at least
08:22:22 <SamB> I don't think any of the code in base offers more than one parse for anything
08:22:29 <FliP^2eH> Notice how I sneakily half-stole lambdabot's nick!
08:22:49 <SamB> um, lambdabot isn't all that creative of a name anyway ;-P
08:23:19 * SamB would have expected Stack: []
08:23:42 <SamB> FliP^2eH: how do you store the stack? a list?
08:23:49 <FliP^2eH> Just a list
08:23:52 <SamB> good
08:24:00 <SamB> that's the way to do it ;-)
08:24:47 <SamB> I was just wondering if you'd accidentally created a datatype isomorphic to lists without noticing
08:25:20 <SamB> they say you end up reimplementing half of the prelude at some point along the way of learning Haskell
08:27:13 <SamB> FliP^2eH: the reason I thought you might have reimplemted lists was the way you called them "arrays" earlier ;-)
08:27:26 <FliP^2eH> ;d
08:27:28 <FliP^2eH> > last []
08:27:29 <lambdabot>   * Exception: Prelude.last: empty list
08:27:35 <FliP^2eH> Meh
08:27:59 <SamB> wasn't sure how well you'd learned what lists *are* in Haskell ;-)
08:28:07 <FliP^2eH> Monads!
08:28:39 <SamB> it's one thing to know it if asked, but it's another thing to realize that they are also just the right shape for stacks
08:29:31 <hackagebot> control-event 1.0.0.1 - Event scheduling system. (ThomasDuBuisson)
08:33:29 <FliP^2eH> > head [1]
08:33:31 <lambdabot>   1
08:33:34 <FliP^2eH> > last [1]
08:33:35 <lambdabot>   1
08:33:42 <FliP^2eH> > init [1]
08:33:43 <lambdabot>   []
08:33:59 <fasta> FliP^2eH: or you just use /msg lambdabot > head [1]
08:34:05 <SamB> FliP^2eH: maybe you'd like the "safe" library?
08:34:12 <SamB> fasta: or ghci!
08:34:31 <fasta> SamB: it's not my bandwidth or CPU time ;)
08:34:52 <fasta> SamB: and regarding the stack, a mutable array would probably be faster.
08:35:00 <SamB> I was just thinking that there isn't much advantage to using lambdabot for @eval in a qeury
08:35:08 <SamB> fasta: eww
08:35:14 <SamB> it might be faster sometimes ...
08:35:36 <SamB> ... but way more complicated to design
08:35:58 <FliP^2eH> No need, SamB
08:36:01 <FliP^2eH> :)
08:36:04 <fasta> SamB: sure, it depends on your needs.
08:36:27 <FliP^2eH> I avoid crashing by pattern matching
08:36:35 <FliP^2eH> Right [] -> privmsg to $ "You don't make sense!"
08:37:03 <quicksilver> I doubt there is a significant speed difference between a mutable array stack and a list stack.
08:37:22 <SamB> FliP^2eH: next: have it send a random BOFH excuse or insulting remark instead of the constant reply
08:37:32 <quicksilver> in each case, popping an item is changing a single pointer, and pushing an item is copying new data in and changing a pointer.
08:37:40 <FliP^2eH> SamB: Nice one!
08:37:42 <FliP^2eH> But..
08:37:42 <quicksilver> the array one has to reallocate occasionally though.
08:37:46 <FliP^2eH> I fear of using random ;<
08:37:56 <FliP^2eH> I still don't know how to get random numbers in haskell
08:38:00 <SamB> quicksilver: the non-array one has to garbage collect sometimes, too ;-)
08:38:19 <jmcarthur_work> FliP^2eH, if you use the monadrandom package it's pretty simple
08:38:25 <Philonous> @type randomIO
08:38:26 <lambdabot> forall a. (Random a) => IO a
08:38:40 <SamB> but the advantage of the non-array is that you don't need to use a monad with mutation facilities
08:38:59 <SamB> and you don't need to figure out how big to reallocate, etc.
08:47:06 <RayNbow> :t mkStdGen
08:47:07 <lambdabot> Int -> StdGen
08:47:27 <RayNbow> :t next
08:47:28 <lambdabot> forall g. (RandomGen g) => g -> (Int, g)
08:47:29 <dhun> I would like to convert a float to string avoiding scientific notation
08:47:36 <RayNbow> > next (mkStdGen 1)
08:47:37 <lambdabot>   (39336,80028 40692)
08:47:50 <dhun> so 0.0001 instead of 1e-5
08:48:21 <Axman6> @hoogle CReal
08:48:21 <lambdabot> No results found
08:48:25 <Axman6> hmmm
08:48:38 <Axman6> > 0.0001 :: CReal
08:48:39 <lambdabot>   0.0001
08:48:42 <lilac> > printf "%0.5f" 0.00001 :: String
08:48:44 <lambdabot>   "0.00001"
08:48:58 <Axman6> > showCReal 100 0.0001
08:48:58 <dhun> you can do it like in c
08:48:59 <lambdabot>   "0.0001"
08:49:26 <dhun> what does 100 mean
08:49:41 <EvilRanter> ?hoogle print.Float
08:49:41 <lambdabot> package logfloat
08:49:47 <SamB> dhun: probably "100 digits of precision"
08:49:51 <dhun> ok
08:49:51 <SamB> or 100 past the decimal
08:49:55 <SamB> or something like that
08:50:47 <Axman6> > chowCReal 100 pi
08:50:48 <lambdabot>   Not in scope: `chowCReal'
08:50:51 <Axman6> > showCReal 100 pi
08:50:52 <EvilRanter> ?hoogle Numeric.show
08:50:52 <lambdabot> package show
08:50:52 <lambdabot> Numeric showEFloat :: RealFloat a => Maybe Int -> a -> ShowS
08:50:52 <lambdabot> Numeric showFFloat :: RealFloat a => Maybe Int -> a -> ShowS
08:50:52 <lambdabot>   "3.141592653589793238462643383279502884197169399375105820974944592307816406...
08:51:00 <dhun> ok
08:51:18 <Axman6> CReals are arbitrary precission real numbers
08:51:32 <Axman6> > showCReal 100 (1/(2^256))
08:51:32 <EvilRanter> dhun, i think you want Data.Numeric.showFFloat
08:51:33 <lambdabot>   "0.000000000000000000000000000000000000000000000000000000000000000000000000...
08:51:41 <Axman6> > drop 50 $ showCReal 100 (1/(2^256))
08:51:42 <lambdabot>   "0000000000000000000000000000086361685550944446253864"
08:51:43 <EvilRanter> > Data.Numeric.showFFloat Nothing 1e-6 ""
08:51:44 <lambdabot>   Not in scope: `Data.Numeric.showFFloat'
08:51:58 <EvilRanter> > showFFloat Nothing 1e-6 ""
08:51:59 <lambdabot>   "0.000001"
08:53:11 <dhun> I think printf is ok
08:55:09 <Axman6> font news: the lovely anonymous font has just had a new version released, Anonymous Pro: http://www.ms-studio.com/FontSales/anonymouspro.html
08:55:32 <Axman6> free, works on mac, windows and linux, and is vert clear even at small sizes
08:59:54 <thomastc> :t flip
08:59:55 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
08:59:59 <thomastc> :t id
09:00:00 <lilac> > showFFloat Nothing 0.00001 ""
09:00:00 <lambdabot> forall a. a -> a
09:00:02 <lambdabot>   "0.00001"
09:00:04 <thomastc> :t flip id
09:00:06 <lambdabot> forall b c. b -> (b -> c) -> c
09:00:33 <thomastc> ... ah, get it now, nvm :)
09:17:01 <FunctorSala> Axman6: will try
09:17:16 <Axman6> the font?
09:18:24 <FunctorSala> yes
09:18:38 <FunctorSala> if I can figure out how to install one on debian..
09:18:43 <Axman6> ah good
09:18:50 <Axman6> yeah i wouldn't have a clue, sorry
09:19:33 <FunctorSala> (one can do that in kde settings, but I don't know if that installs it system-wide </ot>)
09:19:50 <jeff_s_> http://www.faqs.org/docs/Linux-mini/TT-Debian.html#ss3.4
09:20:12 <FunctorSala> yep just googled that too :)
09:20:19 <jeff_s_> <3 google
09:30:06 <\stro>     Occurs check: cannot construct the infinite type: n = Reader (State n) [n]
09:30:11 <\stro> what am I doing wrong? (:
09:30:38 <Zao> Probably mismatched types.
09:30:52 <Zao> > let f x = f [x] in f ()
09:30:54 <lambdabot>   Occurs check: cannot construct the infinite type: t = [t]
09:31:22 <frwmanners> \stro: would need to see code
09:31:28 * Zao hugs hpaste.
09:33:58 <\stro> hum
09:34:23 <FunctorSala> Axman6: the font feels kinda broad
09:34:40 <quicksilver> FunctorSala: turn your monitor at a slight angle away from you
09:34:41 <FunctorSala> maybe I just set the size larger, but it doesn't feel high
09:34:45 <quicksilver> FunctorSala: that will forshorten it.
09:34:46 <FunctorSala> :)
09:34:54 <quicksilver> FunctorSala: in fact, you are already forshortened.
09:34:59 * quicksilver hands FunctorSala a "d".
09:35:17 <FunctorSalad> quicksilver: thank you
09:35:27 <benny99> hi -- is there a short-guide about "when to use type, newtype, data or class" ?
09:35:44 <Botje> type if you're not going to define instances
09:36:01 <Botje> newtype if you're wrapping only one element
09:36:07 <Botje> * and one constructor
09:36:10 <Botje> data for everything else
09:36:17 <benny99> and classes ?
09:36:26 <FunctorSalad> Axman6: nevermind, somehow emacs defaulted to courier because it couldn't find it...
09:36:29 <MartyIX> Hi guys, I'm reading tutorial for Haskell (http://www.haskell.org/tutorial/haskell-98-tutorial.pdf), page 7, Chapter "Built-in types are not special" and I would like to ask (maybe) a silly question. If the built-in types are not special how can I define an infinite type like Integer? Thank you
09:36:32 <mauke> classes are not even in the same category
09:36:46 <Zao> benny99: Similiar to interfaces / concepts in OO languages, but without the O.
09:36:51 <quicksilver> MartyIX: data Natural = Zero | Succ (Natural)
09:36:54 <\stro> frwmanners: http://spaceboyz.net:8080/gitweb/?p=hirn.git;a=blob;f=Neuronal/Operations.hs
09:36:57 <Zao> @src Show
09:36:57 <lambdabot> class  Show a  where
09:36:58 <lambdabot>     showsPrec :: Int -> a -> ShowS
09:36:58 <lambdabot>     show      :: a   -> String
09:36:58 <lambdabot>     showList  :: [a] -> ShowS
09:37:01 <Zao> That's a class.
09:37:03 <quicksilver> MartyIX: not that this is not as convenient in practice ;)
09:37:15 <quicksilver> classes appear similar to interface and concepts
09:37:16 <benny99> Zao, Botje, thanks
09:37:18 <\stro> frwmanners: lines 81 & 99
09:37:18 <Botje> MartyIX: type Integer = [Int]
09:37:22 <quicksilver> but they are not interfaces and are not concepts
09:37:27 <quicksilver> and they should not be used as such.
09:37:31 <Botje> MartyIX: although Integer _is_ linked to libgmp in the runtime, so it's kind of special
09:37:34 <quicksilver> They are a device for overloading functions.
09:37:34 <benny99> I'll simply try to use it again
09:37:51 <Zao> Botje: Lots of work underway to decouple it.
09:37:56 <Botje> yep, i read it
09:38:01 <FunctorSalad> the number types are special, they are defined with that ghc magic-hash thing :)
09:38:09 <Zao> Scares me deeply, but it seems kind of fun.
09:38:12 <FunctorSalad> syb treats them specially too
09:38:22 <MartyIX> quicksilver: ah, I thought I could use only data constructors in type definitions
09:38:55 <MartyIX> Botje: Thank you for answer
09:39:35 <Botje> benny99: Reader (State n) a ?
09:39:43 <Botje> wrong person
09:39:50 <Botje> \stro: Reader (State n) a ?
09:39:55 <benny99> ;)
09:40:47 <Botje> \stro: what's Operation supposed to represent?
09:40:50 <\stro> Botje: just State, not the State monad
09:40:55 <\stro> Operation is a Reader
09:40:58 <Botje> oh
09:41:03 <Botje> that's very confusing :)
09:41:10 <Botje> call it OpState, instead
09:42:16 <\stro> right
09:43:20 <flice> hi
09:43:25 <flice> is there an efficient data structure to store and query possibly overlapping integer ranges? Range={ int start, int end }. Querying is always done according to a point and yields all ranges containing this point
09:43:37 <Botje> \stro: is the type for neuron_output correct?
09:43:43 <Zao> flice: T-tree.
09:43:57 <flice> Zao: thanks, going to check that out
09:43:58 <quicksilver> zao++ # I was struggling for a name.
09:44:02 <flice> Zao: any direct links?
09:44:03 <Botje> because return $ sum inputs would be :: Reader (State n) Int
09:44:06 <Botje> instead of [Int]
09:44:07 <Zao> Although I'm uncertain if it copes well with overlapping ranges.
09:44:19 <Zao> flice: Wikipedia article ought to be a good start.
09:44:53 <\stro> Botje: absolutely :-)
09:45:03 <quicksilver> hmm
09:45:09 <TomMD> Can someone do my homework for me?
09:45:12 <Botje> absolutely correct or "absolutely, that's the error" ? :)
09:45:22 <\stro> correct
09:45:26 <TomMD> I need to prove that P = NP and thus the entirty of ecommerce as we know it is insecure ;-)
09:45:28 <Zao> TomMD: Will there be pie involved?
09:45:28 <Botje> TomMD: sure, give use the assignment and your profs email addres and we'll mail it to him/her
09:45:32 <MartyIX> quicksilver: "data Natural = Zero | Succ (Natural)" I'm still confused. I read in the pdf document that on the left side of "=" is type (type constructor) we define and on the right side are data constructors and that data constructors are in different namespace than type constructors and it implies to me that it cannot work. Where is the catch?
09:46:02 <Botje> \stro: but sum :: [a] -> a
09:46:07 <Botje> and return a :: m a
09:46:15 <mux> MartyIX: Succ is the constructor, but what's after it are types
09:46:16 <\stro> Oh
09:46:23 <Botje> so return $ sum inputs = Reader (State n) a instead of [a]
09:46:27 <quicksilver> MartyIX: the parameters of constructors (if any) are types.
09:46:31 <\stro> Botje: thanks!
09:46:34 <\stro> I overlooked that
09:46:46 <\stro> now only the one on L81 remains:
09:46:55 <\stro>     Occurs check: cannot construct the infinite type:
09:46:55 <\stro>       n = Reader (OpState n) n
09:46:55 <\stro>     When generalising the type(s) for neuron_inputs, neuron_output
09:46:57 <MartyIX> mux: oh yes.. I missed it, sorry
09:47:51 <Botje> hmm
09:47:55 <mux> don't be sorry :-)
09:47:58 * Axman6 things that this is a more complete Integer replacement: data Integer = I Sign Natural; data Sign = Pos | Neg; data Natural = Zero | Succ Natural
09:48:02 <Axman6> thinks*
09:48:23 <Axman6> also, the [Int] representation is nice
09:48:41 <idnar> Axman6: what's the difference between I Pos Zero and I Neg Zero ?
09:48:42 <Axman6> or, maybe [Word]
09:48:46 <Zao> Axman6: Highly efficient.
09:48:57 <wli> [Word32] might be good for Natural
09:49:02 <Axman6> yeah
09:49:02 <Zao> idnar: Lets you encode integers where you have both positive and negative zero.
09:49:25 <idnar> Zao: yes, but what the heck kind of integers are those? :P
09:49:27 <Axman6> idnar: iee 754, hav u herd of it? :P
09:49:29 <Zao> idnar: Ones complement.
09:49:31 <Botje> \stro: try commenting out the Nothing part of neuron_inputs, does it typecheck then?
09:49:32 <Axman6> think it's 754
09:49:33 <idnar> Axman6: IEEE 754 integers? :P
09:49:36 <Axman6> ieee*
09:49:37 <Botje> << food
09:49:39 <Axman6> yes!
09:49:43 <benny99> is there some way to evade using  "-XMultiParamTypeClasses" ?
09:49:58 <Botje> don't use MPTCs in your code? :)
09:50:15 <flice> Zao: well, non-overlapping case is easy: just take any BST
09:50:24 <Alpounet> hi
09:50:26 <\stro> Botje: nope
09:50:36 <Alpounet> is there a way to get "the biggest Integer Haskell can handle" ?
09:50:47 <mauke> no such thing
09:50:48 <RayNbow> Integer or Int?
09:50:54 <Zao> Alpounet: Increment by one until you run out of memory.
09:50:55 <hatds> sometimess type families are a better fit than a multi-param typeclass
09:50:58 <benny99> Botje, hm, how to not use them for a class like "class Foo a b where foo :: a -> b" ?
09:51:03 <Zao> It'd be a local maximum, of course :P
09:51:13 <\stro> oh, I've got it...
09:51:32 <Zao> benny99: Are you sure you want a class in the first place?
09:51:38 <anq> benny99, it is a feature you must activate to make use of type-classes having more than one type parameters.
09:51:41 <Alpounet> Zao, heh.
09:51:46 <benny99> Zao, no
09:51:53 <Zao> benny99: What's your use case?
09:52:30 <anq> benny99, you should read a tutorial that explains those concepts on an introductory level.
09:52:48 <RayNbow> benny99: if you don't want to pass an extension flag to GHC, you could use a {-# LANGUAGE #-} pragma in the source file
09:53:14 <RayNbow> (if that's what you're looking for)
09:54:28 <benny99> RayNbow, thanks, but I wondered about something different
09:56:58 <walter__> In: newtype Parse a = Parse { runParse :: ParseState -> Either String (a, ParseState)}
09:57:03 <benny99> Zao, I guess my use-case is nonesense, never mind, sorry
09:57:35 <anq> benny99, do you know the Wikibook on Haskell? Or "Yet another Haskell tutorial"?
09:57:47 <\stro> Botje: got it compiled now, many thanks!
09:57:50 <walter__> Why do I have :t runparse : runParse :: Parse a -> ParseState -> Either String (a, ParseState)
09:58:21 <Saizan> what'd you expect?
09:58:38 <walter__> Where does the first "Parse a" from
09:58:49 <Axman6> walter__: you know how recoed syntax works?
09:59:02 <walter__> Yeah, just read the record syntax
09:59:17 <Axman6> data X = Foo {x :: Bar, y :: Baz}, means that x :: Foo -> Bar
09:59:32 <Axman6> uh, X -> Bar
09:59:44 <walter__> not the book doesnt talk to deep on this
10:00:27 <Axman6> so, if we have data X = Foo {t :: (a -> b)}, then t :: X -> a -> b
10:00:39 <Saizan> walter__: runParser becomes an accessor function to extract that field from the datatype
10:00:40 <Axman6> or t :: X -> (a -> b)
10:00:44 <benny99> anq, yeah - though the problem is probably, that I don't know what I want
10:00:55 <Saizan> like runParser (Parser f) = f
10:01:25 <walter__> thanks you all, Let me think for while
10:01:39 <Axman6> walter__: what the type could be read as is: runParse :: Parse a -> (ParseState -> Either String (a, ParseState))
10:01:53 <anq> benny99, the problem seems to be that you don't understand the concepts well enough to know when to apply them. Use the Wikibook on Haskell and "Yet another Haskell tutorial" to study it. The "Gentle introduction" has a way too steep approach for newcomers.
10:01:58 <Axman6> takes a Parse a, and retuens the function inside it
10:02:15 <walter__> I See! :)
10:03:13 <anq> benny99, http://darcs.haskell.org/yaht/yaht.pdf  and  http://en.wikibooks.org/wiki/Haskell  (and  http://learnyouahaskell.com/).
10:03:30 <Twey> Don't forget RWH
10:03:31 <anq> benny99, -simultaneously-
10:03:31 <benny99> anq, thanks
10:04:17 <Twey> http://book.realworldhaskell.org/
10:04:28 <benny99> thanks again
10:05:45 <benny99> I'll breathe some fresh air before, anyway
10:15:34 <walter__> Axman6, I think data X = Foo {x :: Bar, y :: Baz}, means that x :: X -> Bar not Foo->Bar, right?
10:15:53 <Axman6> yes, i corrected myself a line of two later ;)
10:16:14 <walter__> Axman6, thanks, now I think I understand
10:16:44 <Axman6> basically, record syntax saves you work by giving you accessor functions to the elements of a datatype
10:17:05 <walter__> Yeah
10:20:53 <raimo> who do I turn object-oriented design into functional?
10:21:50 <dhun> how can I do (replace "abcdefg" "cd"  "123")->"ab123efg"?
10:21:58 <raimo> s/who/how/
10:23:09 <Beelsebob1> @hoogle Eq a => [a] -> [a] -> [a] -> [a]
10:23:10 <lambdabot> Language.Haskell.TH.Syntax mkNameG_tc :: String -> String -> String -> Name
10:23:10 <lambdabot> Prelude zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
10:23:10 <lambdabot> Data.List zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
10:23:20 <Beelsebob1> @hoogle Eq a => [a] -> [a] -> b
10:23:21 <lambdabot> Data.List isInfixOf :: Eq a => [a] -> [a] -> Bool
10:23:21 <lambdabot> Data.List isPrefixOf :: Eq a => [a] -> [a] -> Bool
10:23:21 <lambdabot> Data.List isSuffixOf :: Eq a => [a] -> [a] -> Bool
10:23:33 <Beelsebob1> @hoogle range
10:23:34 <lambdabot> Data.Ix range :: Ix a => (a, a) -> [a]
10:23:34 <lambdabot> Language.Haskell.TH data Range
10:23:34 <lambdabot> Language.Haskell.TH.Syntax data Range
10:23:38 <Beelsebob1> hmm
10:27:16 <dcoutts> http://www.reddit.com/r/haskell/comments/8s1b2/rewrite_of_the_io_library_including_unicode/
10:32:08 <chromakode> hey haskellers, any suggestions for serializing trees?
10:32:19 <Axman6> Data.Binary
10:32:38 <Axman6> if they're binary trees, there's some nice properties you can use too
10:32:48 <chromakode> unfortunately, they're not :(
10:33:09 <Axman6> well, Data.Binary it is then, unless someone else has a better idea
10:33:14 <chromakode> oh, this is cool, thanks
10:33:17 <raimo> is there a map function that gives the index of the current item to the given block
10:33:20 <Twey> Data.Tree has a Show instance *shrug*
10:33:24 <Axman6> it's a very cool library :)
10:33:28 <chromakode> I was looking on Hackage, but Data.Binary isn't listed?
10:33:31 <Botje> raimo: you can trivially make that yourself by combining zip and map
10:33:36 <raimo> index and the item I meant
10:33:42 <Botje> map (\(idx, el) -> ...) $ zip [0..] list
10:33:53 <raimo> ok, thanks
10:35:24 <EvilTerran> imo, that'd look nicer as [... | (idx, el) <- zip [0..] list]
10:35:46 <chromakode> thanks Axman6, this looks good!
10:37:17 <gwern> chromakode: hackage packages != module name
10:37:30 <gwern> chromakode: the module Data.Binary is provided by the package 'binary'
10:37:41 <chromakode> gwern: http://www.google.co.uk/search?hl=en&as_sitesearch=hackage.haskell.org%2Fpackage&as_q=binary
10:37:58 <gwern> @hackage binary
10:37:59 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/binary
10:38:14 <chromakode> weird.
10:38:26 <gwern> google is not infallible
10:38:26 <EvilTerran> packages can contain several modules
10:38:29 <chromakode> thanks gwern
10:40:21 <raimo> can I somehow get rid of repetition in statement like data Superhero = BatMan Capabilities | BatWoman Capabilities | Superman Capabilities?
10:40:39 <mauke> yeah, refactor
10:40:47 <raimo> how?
10:40:52 <disgrntld> Is there anyway to print a stack trace so I can see how a recursive function is called?
10:40:52 <EvilTerran> data SuperheroName = BatMan | BatWoman | Superman
10:41:05 <lilac> raimo: "map (\(idx, el) -> ...) $ zip [0..] list" can be expressed more nicely as "zipWith (\idx el -> ...) [0..] list"
10:41:10 <EvilTerran> raimo, then, type Superhero = (SuperheroName, Capabilities)
10:41:13 <chromakode> data Capabilities = Capabilities SuperHero a
10:41:27 <chromakode> where a is your capabilities type
10:41:54 <mauke> disgrntld: AFAIK no, at least not directly
10:42:14 <mauke> the ghci debugger might be able to do something here
10:42:34 <flice> Zao: the R-Tree seems to come closely to my problem from the look of it
10:42:38 <raimo> lilac: thanks
10:43:15 <raimo> EvilTerran, chromakode: I'll try those out
10:44:03 <hatds> the choice between (A,B) and (,B) | (,B) | (,B) confronts me more than I'd like
10:44:21 <disgrntld> shucks.. I'm trying to understand: fibs = 0:1:zipWith (+) fibs (tail fibs)
10:44:21 <disgrntld> How many times is zipWith called if I say: fibs!!3
10:44:25 <lilac> flice: i have a similar problem. i use a map from the points at which the set of intervals change to the set of intervals to the right of that point
10:45:07 <EvilTerran> disgrntld, erm... a fractional number of times. lazy evaluation etc.
10:45:15 <chromakode> isn't zipwith called once for each element, since it recurses?
10:45:37 <EvilTerran> but the maximum recursion depth would be 2, in that case
10:45:48 <EvilTerran> seeing as you're asking for the 4th element, and the first two are outside the recursion
10:46:11 <chromakode> even though evaluation is lazy, doesn't it in essence get "called" twice within the semantics of haskell, barring optimizations?
10:46:13 <hatds> you don't get a growing tree of recursive zipWith calls, if that answers your question
10:46:26 <disgrntld> yes, that helps a lot hatds
10:46:38 <lilac> chromakode: it doesn't really recurse
10:46:39 <flice> lilac: that is, a key is any point that is an end to some interval?
10:46:42 <disgrntld> I have to admit, I'm still trying to parse y'alls responses to understand why
10:46:51 <lilac> flice: start or end to some interval, but yes
10:46:55 <chromakode> lilac: is it tail recursion?
10:47:01 <flice> lilac: that's what I meant
10:47:21 <Axman6> disgrntld: i just imagine that definition as a zipper that folds back and eats itself...
10:47:29 <lilac> chromakode: start with fibs = 0:1:<something>. to work out the next element, you need to know elements 0 and 1, so you don't need to call zipWith
10:47:40 <EvilTerran> disgrntld, try evaluating fibs!!2 by hand yourself
10:47:42 <flice> lilac: "to the right of that point" - to immediately right?
10:48:14 <disgrntld> ok, gonna do fibs!!2..
10:48:55 <EvilTerran> fibs!!2  -->  (0:1:zipWith (+) fibs (tail fibs)) !! 2  -->  (zipWith (+) fibs (tail fibs)) !! 0  -->  (zipWith (+) (0:1:...) (tail (0:1:...))) !! 0
10:49:01 <chromakode> lilac: but elements 0 and 1 are combined (+) via zipWith
10:49:30 <lilac> flice: suppose interval 0 is [0,2], interval 1 is [1,3] and interval 2 is [2,3]. i represent that as 0 ~> [0], 1 ~> [0,1], 2 ~> [1,2], 3 ~> []
10:50:01 <EvilTerran> -->  (zipWith (+) (0:1:...) (1:...)) !! 0  -->  ((0+1) : zipWith (+) (1:...) (...)) !! 0  -->  (0+1)  -->  1
10:50:37 <disgrntld> awesome EvilTerran, makes a lot more sense
10:50:52 <Axman6> 1:1:zipWith (+) fibs (tail fibs) -> 1:1:(1+1):... -> 1:1:(1+1):(1+(1+1)):...
10:51:21 <lilac> there's a great diagram of this somewhere
10:51:45 <flice> lilac: yes, I get it
10:51:52 <disgrntld> really?
10:52:46 <flice> lilac: the question is - what do you do in this case: the only defined interval is [0, 2], and you search for 1
11:05:45 <bike> i need to tarck a ip address plz help
11:06:11 <RayNbow> dcoutts, data Newline = LF | CRLF -- ?
11:06:36 <dcoutts> RayNbow: what are you asking exactly?
11:07:45 <RayNbow> dcoutts: well... do you know why GHC only knows those two alternatives?
11:08:02 <dcoutts> RayNbow: can you think of any others?
11:08:02 <RayNbow> (there's also the CR newline format)
11:08:06 <bike> i need to tracert a ip address.but i have only that users e mail address
11:08:09 <RayNbow> yes, CR only
11:08:24 <RayNbow> iirc, it is (was?) used on Macs
11:08:24 <dcoutts> RayNbow: and does anything still use that?
11:08:30 <RayNbow> no idea :p
11:08:52 <dcoutts> RayNbow: as far as I know it's only Mac OS prior to version X
11:08:52 <lilac> flice: when you search for n, look for the largest entry in the map which is <= n.
11:08:59 <bike> that user is onaline now
11:09:27 <lilac> flice: if you want your intervals to be treated as closed instead of semi-open, it'd be a little harder
11:09:28 <flice> lilac: so the map is some kind of BST
11:09:38 <mauke> bike: why are you asking in this channel?
11:09:39 <Axman6> bike: what does that have to do with haskell?
11:09:48 <flice> lilac: no, semi-open is fine
11:09:52 <RayNbow> dcoutts: it seems you're right :)
11:10:01 <dcoutts> RayNbow: so in practise the CR format is dead and gone. If you need to process CR files you can still do it, just read in binary and do your own translation.
11:10:36 <lilac> flice: if you assume a binary tree implementation for the map (which seems reasonable!), then sure.
11:11:41 <flice> lilac: first I thought you were talking of an unordered map. ordering is either sorted array or BST, AFAICT
11:12:46 <TomMD> Does anyone know about these IO changes wrt any Haskell Prime proposals?
11:12:49 <RayNbow> dcoutts: I wasn't aware that CR was obsolete, so I found it strange it was omitted from Newline's definition
11:12:59 <dcoutts> RayNbow: right
11:13:09 <RayNbow> personally I've never had to work with CR files
11:13:10 <flice> lilac: (and the ordering is needed to fetch the *next* key)
11:13:25 <dcoutts> RayNbow: yeah we're lucky that OSX went mostly unixy
11:13:31 <Axman6> RayNbow: yeah nothig uses jusr CR
11:13:37 <disgrntld> Is this right? http://pastebin.com/m2b6ca368
11:14:11 <dcoutts> Axman6: you'll bring down the wrath of all those militant MacOS9 users :-)
11:14:25 <Axman6> i only know of one of them
11:14:35 <Axman6> still uses os 8 as his daily machine
11:14:45 <RayNbow> @faq Can Haskell protect Axman6 from all those militant MacOS9 users?
11:14:45 <lambdabot> The answer is: Yes! Haskell can do that.
11:14:51 <dcoutts> hah hah
11:14:55 <Axman6> he's a bit of a nut, but he's been servicing macs for 28 years
11:14:56 <AllNight^> hello all :)
11:15:06 <AllNight^> hopefully simple question....
11:15:29 <AllNight^> why does '3 div 2' give me a long & incomprehensible error message?
11:15:42 <Axman6> > 3 div 2
11:15:43 <AllNight^> and how do I persuade it not to? :)
11:15:43 <lambdabot>   Add a type signature
11:15:44 <TomMD> because div is a function, not an infix operator
11:15:48 <Axman6> > 3 `div` 2
11:15:50 <dcoutts> AllNight^: to use a function infix use ``
11:15:50 <lambdabot>   1
11:15:51 <mauke> AllNight^: because you're trying to call 3 with two arguments, div and 2
11:15:52 <Cale> because it means to try to apply the function 3 to the parameters div and 2
11:15:55 <AllNight^> ah!
11:16:02 <AllNight^> ty!
11:16:04 <Cale> AllNight^: you want 3 `div` 2
11:16:12 <mauke> or div 3 2
11:16:18 <Cale> with backticks to turn it into an infix operator
11:16:26 <flice> lilac: the part that seems problematic is addition and removal of intervals. it will have a greater complexity than O(log(n)), where n is the number of intervals
11:16:35 <AllNight^> sorry - I'm so used to that being infix from other languages I forgot
11:16:47 <AllNight^> :)
11:18:02 <Axman6> i've never seen a language that lets you do that
11:18:39 <TomMD> AllNight versions 1 - 9 let you do that
11:18:58 <flice> lilac: for example, if you have a set of intervals [x1, x2], and you add another one [y1, y2], where y1<=x1 and x2<=y2, you'll need to traverse the whole tree and add this interval to each node
11:19:29 <flice> lilac: I mean that all intervals in the set are bounded by x1 from below and x2 from above
11:20:10 <Cale> AllNight^: Part of what makes the error message confusing is that with the right instances, it is possible for that code to be valid.
11:20:41 <mauke> (the result is 3)
11:21:03 <Cale> AllNight^: integer literals in Haskell are polymorphic, and writing an instance of the Num class for a given type allows them to be used as that type
11:21:09 <flice> lilac: so adding n intervals is O(n^2) in the worst case
11:21:45 <flice> lilac: and Theta(n^2)
11:21:49 <flice> lilac: and Theta(n^2) memory
11:22:29 <Cale> So, yeah, we could write a meaningful instance of Num for functions having some type of number as their result, and probably 3 would become the constant function 3
11:22:47 <snhmib> igli!?
11:23:02 <snhmib> igli come on man
11:23:17 <Cale> and in order to make your code typecheck, the instance would have to be used twice, to turn 3 into a function of two parameters :)
11:23:19 <snhmib> at least let your computer be on while you're asleep fucktard
11:23:26 <AllNight^> hmmm ... another question - I have two functions 'foo' & 'bar' both of type Int -> Int (as confirmed by :t) & two more 'isEven' and 'isOdd' both of type Int -> Bool (again as confirmed by :t)
11:23:32 <snhmib> anyone from eastern/south europe?
11:23:44 <AllNight^> but [(isEven, foo) (isOdd, bar)] isnt well typed
11:23:50 <AllNight^> which I find surprising!
11:24:02 <snhmib> what language is that?
11:24:05 <Cale> that is strange
11:24:13 <RayNbow> AllNight^: aren't you missing a comma in that list?
11:24:14 <TomMD> @type [(isEven, undefined), (isOdd, undefined)]
11:24:15 * AllNight^ would have expected it to be of type [(Int -> Bool, Int -> Int)]
11:24:16 <lambdabot> Not in scope: `isEven'
11:24:17 <lambdabot> Not in scope: `isOdd'
11:24:18 <Cale> oh!
11:24:20 <Cale> yes
11:24:23 <AllNight^> ah possibly - I am still learning
11:24:29 <TomMD> @type [(even, undefined), (odd, undefined)]
11:24:30 <Cale> You're applying a tuple to another tuple :)
11:24:31 <lambdabot> forall a a1. (Integral a) => [(a -> Bool, a1)]
11:24:37 <Axman6> snhmib: it's... haskell... what else would it be in here?
11:24:47 <TomMD> AllNight^: Did you mean to insert a comma there?
11:24:49 <snhmib> whoah
11:24:52 <conal> is there composition function for Data.Map, say compose :: Map b c -> Map a b -> Map a c ?
11:25:03 <TomMD> conal: Union?
11:25:03 <conal> i don't see one in the exports
11:25:07 <snhmib> Axman6: this isn't the channel i thought it was
11:25:11 <snhmib> Axman6: sorry :)
11:25:15 <Axman6> apparently not
11:25:15 <snhmib> ded
11:25:16 <Cale> conal: I don't think so, but I've asked for such things in the past...
11:25:18 <snhmib> heh
11:25:24 <C-Keen> @hoogle Map b c -> Map a b -> Map a c
11:25:24 <lambdabot> Control.Arrow (<<<) :: Arrow a => a c d -> a b c -> a b d
11:25:25 <lambdabot> Control.Arrow (>>>) :: Arrow a => a b c -> a c d -> a b d
11:25:25 <lambdabot> Data.Map (\\) :: Ord k => Map k a -> Map k b -> Map k a
11:25:26 <AllNight^> ah - that seems to fix it - then it talks about 'No instances for (Show (Integer -> Integer),
11:25:27 <AllNight^>                       Show (Integer -> Bool))
11:25:27 <Axman6> snhmib: how did you get here btw?
11:25:33 <conal> i guess it's close to fmap
11:25:38 <AllNight^> but I assume that's not an error :)
11:25:42 <conal> easy to constraint with fmap.
11:25:52 <snhmib> Axman6: i like to programn haskell every once in a while
11:25:55 <Axman6> it's just we seem to get a lot of people in here asking questions about stuff that's totally unrelated to haskell, and i have no idea why
11:25:55 <mauke> AllNight^: that means it doesn't know how to display functions
11:26:00 <conal> even closer: mapMaybe
11:26:05 <AllNight^> that's what I thought mauke - just checking :)
11:26:08 <conal> @type mapMaybe
11:26:09 <lambdabot> forall a b. (a -> Maybe b) -> [a] -> [b]
11:26:18 <snhmib> Axman6: like "what language is that!?"
11:26:26 <snhmib> Axman6: i'm sorry for my part in that
11:26:27 <conal> @type Data.Map.mapMaybe
11:26:28 <lambdabot> forall a b k. (Ord k) => (a -> Maybe b) -> M.Map k a -> M.Map k b
11:26:32 <Axman6> s'all good
11:26:46 <conal> kthx.
11:27:04 * AllNight^ is used to spaces being the list-element seperator (lisp hacking) :|
11:27:19 <Axman6> ew, really? spaces?
11:27:29 <Cale> Axman6: that's what lisp uses :)
11:27:32 <AllNight^> yes as in (+ 2 3 4 5)
11:27:54 * Axman6 dislikes this *thumbs down icon*
11:27:56 <snhmib> Axman6: i'm just confused about all the peolpe that like to talk about all the "-isms" and all the "-onoids" that are involved iwt functional programming :P
11:27:59 <Cale> It's kind of a natural choice. We like it for function application though :)
11:28:23 <Axman6> snhmib: i've never mentioned a single -ism or -onoid in here
11:28:32 <Axman6> and i've been here for about 14 months
11:28:33 <AllNight^> yes - I do too - but the two contexts are syntatically distinct - so why not overload it to work for both Cale? :)
11:28:36 <snhmib> you didn't :)
11:28:45 <snhmib> but my teacher's have :(
11:28:47 <Axman6> i also kknow nothing about category theory
11:29:02 <Zao> snhmib: http://comonad.com/reader/2009/recursion-schemes/
11:29:10 <AllNight^> Axman6 - I recommend 'conceptual category theory' -- very friendly textbook :)
11:29:14 <Cale> AllNight^: but they're not... sometimes you want a list element which is a function application
11:29:24 <mauke> [a b c]
11:29:32 <Axman6> i don't have time to be learning things beyond what i'm currently learning :\
11:29:43 <Cale> I suppose you could demand that be written like [(a b c)]
11:29:49 <snhmib> i like programming Haskell every now and then but the teachers @ uni can't stop talking about these catamorphisms & stuff :(
11:30:14 <Cale> snhmib: catamorphisms are a useful concept, and learning at least what they are is fun enough :)
11:30:14 <kig> monoid is a function f : G -> G -> G that's associative and has a neutral element f x e = f e x = x
11:30:21 <AllNight^> that's probably what I would choose Cale (using the brackets)
11:30:32 <mauke> AllNight^: eww
11:30:32 <snhmib> Cale: i'm not sure
11:30:39 <mauke> AllNight^: this is exactly what I did. in a joke language.
11:30:40 <snhmib> they sound so scary i never tied
11:30:44 <snhmib> *tried
11:30:47 <Cale> snhmib: You know how algebraic datatypes in Haskell are built using data constructors which take some parameters?
11:30:49 <snhmib> maybe i should :)
11:30:51 * Axman6 seconds mauke's eww
11:31:01 <AllNight^> well mauke - how often do you *want* to provide a literal list with an element derived from a function application?
11:31:03 <snhmib> Cale: yea..
11:31:07 <mauke> AllNight^: ALL THE TIME
11:31:14 <snhmib> everytging is a function :)
11:31:20 <Cale> snhmib: like  data List a = Empty | Cons a (List a)  or  data Tree a = Leaf | Branch a (Tree a) (Tree a)
11:31:28 <snhmib> even data constructors
11:31:48 <snhmib> hmm...
11:31:53 <AllNight^> really? okay... I dont really
11:32:02 <Cale> Or for the standard list type, (:) and [] are the constructors
11:32:08 * AllNight^ guesses he is thinking of Haskell lists as being like quoted lists in Lisp
11:32:14 <Cale> (we just happen to write cons infix :)
11:32:15 <snhmib> Cale: wish you told me that before i had a "funcional programming" exam :(
11:32:17 <snhmib> :)
11:32:25 <mauke> AllNight^: you can't really have expressions in quoted lists, though
11:32:26 <snhmib> *functional
11:32:31 <Cale> snhmib: I haven't yet told you what a catamorphism is though :)
11:32:32 <jeff_s_> Allnight - I'm not finding "conceptual category theory", do you know who the author is?
11:32:36 <snhmib> darn
11:32:43 <Cale> snhmib: Consider a function like sum for lists
11:32:46 <snhmib> Cale: what is it?
11:32:46 <Cale> sum [] = 0
11:32:51 <Cale> sum (x:xs) = x + sum xs
11:32:59 <Cale> Or we can look at product:
11:33:04 <Cale> product [] = 0
11:33:11 <Cale> product (x:xs) = x * product xs
11:33:17 <Cale> These are obviously very similar
11:33:18 <snhmib> like a fold
11:33:21 <Cale> yes
11:33:22 <jeff_s_> product [] = 1    <- ?
11:33:23 <RayNbow> Cale: I used those examples when I was assisting a Haskell lab course :D
11:33:26 <Cale> er, yes
11:33:28 <Cale> typo :)
11:33:31 <jeff_s_> :)
11:33:45 <Cale> So the only difference is that 0 changes to 1 and (+) becomes (*)
11:33:46 <snhmib> hehe
11:34:03 <snhmib> yea the "pluzzle" (+) changes
11:34:03 <Cale> So we might write a function which constructs this function from the parts which change
11:34:15 <AllNight^> mauke - I know - that's why I'm thinking of space as being okay... you *wouldnt* have evaluated elements in anything but a back-quoted list
11:34:25 <Cale> Moreover, look at this function:
11:34:30 <C-Keen> can I tell cabal to globally set some options for command lines?
11:34:32 <Cale> f [] = []
11:34:48 <Cale> f (x:xs) = x : f xs
11:34:50 <thoughtpolice> C-Keen: look in ~/.cabal/config
11:34:57 <AllNight^> oh and sorry - the title 'Conceptual mathematics - a first introduction to categories'  at: www.amazon.co.uk/Conceptual-Mathematics-First-Introduction-Categories
11:35:06 <mauke> AllNight^: consider [x, x + 1, x + 2]
11:35:13 <jeff_s_> Allnight thanks
11:35:19 <Cale> So if we use [] and (:) as those parts, we get what is quite obviously the identity function on lists
11:35:26 <Cale> > foldr (:) [] [1..10]
11:35:27 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
11:35:29 <dcoutts> C-Keen: and for future reference see cabal --help which reports the same info
11:35:31 <AllNight^> np - jeff_s_ - if you pm me I have it as a pdf :)
11:35:34 <Cale> > foldr (+) 0 [1..10]
11:35:35 <lambdabot>   55
11:35:38 <Cale> > foldr (*) 1 [1..10]
11:35:40 <lambdabot>   3628800
11:35:43 <snhmib> Cale: isn't that identity?
11:35:46 <Cale> yes
11:35:50 <Cale> and that's the point :)
11:35:53 <snhmib> the thing you sad before
11:35:53 <AllNight^> mauke - take 3 (map (+ x) [1..])
11:35:55 <C-Keen> thoughtpolice: thanks
11:35:57 <snhmib> *before*
11:35:59 <Cale> snhmib: yeah the function f
11:36:05 <C-Keen> dcoutts: aye
11:36:16 * snhmib confused
11:36:21 <Axman6> AllNight^: you mean (+x)? >_>
11:36:29 <Cale> snhmib: My point is that what foldr f z is doing is replacing each (:) with f and each [] with z
11:36:34 <mauke> AllNight^: executeFile me False [cf, sf, "", s', stor', show state, show (mapMaybe narrow ins), show outs]
11:36:50 <AllNight^> er.. I mean using curried + & passing it x so it becomes a function Int -> Int
11:36:53 <Cale> snhmib: So if we tell it to replace (:) with (:) and [] with [], of course we get the same list
11:37:04 * Axman6 tends to see (+x) as being a function in itself, and mentally defferentiates it from other partially applied functions like map f
11:37:16 <Cale> snhmib: This leads us to the more general idea of a catamorphism
11:37:21 <AllNight^> (sorry - as I said I'm just learning Haskell - so I'm unsure with Haskell syntax - I've done functional programming in Lisp & various bits of higher math though) :)
11:37:35 <snhmib> yea but if fold replaces each (:) with another function
11:37:37 <Cale> snhmib: A catamorphism is a function which systematically replaces the data constructors of a type with other functions
11:37:38 <snhmib> like foldr
11:37:45 <snhmib> oh crap
11:37:46 <Axman6> AllNight^: learn to hate parens, and your code will become more beautiful
11:38:00 <Cale> and foldr is an example of one :)
11:38:10 <Cale> They tend to be extremely useful functions
11:38:27 <snhmib> i wish i asked this before i had an exam on functional programming :(
11:38:37 <eck> does ghc optimize _ differently (e.g. in function definitions like: foo _ x = x), or is it purely a style thing?
11:38:55 <roconnor> Cale: did you learn anything about using seq on functions.  I'm starting to get excited about putting a HNF seq in hasCale.
11:39:05 * snhmib just tended to be scared because of all the -isms and -onoids
11:39:13 <snhmib> thanks Cale
11:39:16 <snhmib> :)
11:39:18 <Cale> snhmib: no problem
11:39:29 <gnuvince> eck: it won't trigger a warning if you compile with -Wall and don't use a variable in the function's body.
11:39:30 <AllNight^> mauke hmmm (executeFile me False `(cf sf "" s' stor' ,show state ,show (mapMaybe narrow ins) ,show outs))
11:39:31 <AllNight^> :)
11:39:32 <Cale> snhmib: The terms only sound scary, they tend to be simpler things than you'd expect :)
11:39:45 <gnuvince> eck: beyond that, I don't know if there's anything magical about it
11:39:45 <Cale> roconnor: Nothing particularly new.
11:39:49 <eck> ok;
11:39:57 <snhmib> Cale: well
11:40:09 <Cale> roconnor: and the bit of discussion we had the other day made it sound actually doable :)
11:40:11 <mauke> AllNight^: doesn't work, you need ,(show state)
11:40:27 <roconnor> Cale: but no applications yet :P
11:40:44 <snhmib> if somebody writes a "scientfic" paper called "programming with bananas etc..." i'd say it's justified being scared :P
11:40:55 <snhmib> stupid teachers
11:40:57 <Cale> snhmib: haha
11:41:09 <Cale> snhmib: yeah, that comes from the notation they used :)
11:41:30 <snhmib> it still scared me :P
11:41:32 <Cale> snhmib: they used fat brackets which looked a bit like bananas for catamorphisms
11:41:43 <Cale> and they would write the constructor replacements inside that
11:42:08 <Cale> So it looked like ((f,z)) instead of foldr f z
11:42:10 <snhmib> i wish i did'n have other courses during the functional programming one..
11:42:28 <snhmib> do you have any "good" things to read for me?
11:42:40 <AllNight^> true mauke - but I'm just trying to illustrate the idea... maybe it's just me but I dont like needing to use the comma to seperate every pair of list items - I expect most of them to be unevaluated literals -- but maybe that just comes from my previous experiences
11:42:44 <snhmib> except that banana paper :P
11:42:45 * AllNight^ shrugs :)
11:43:03 <mauke> AllNight^: actually, most of them are variables and thus evaluated
11:43:09 <Cale> well, I made these diagrams for list functions which might be somewhat enlightening http://cale.yi.org/index.php/Fold_Diagrams
11:43:10 <mauke> doh ho ho
11:43:13 <snhmib> mauke!!
11:43:20 <snhmib> your bot!
11:43:24 <mauke> you rangâ½
11:43:37 <augustss> howdy
11:43:37 <snhmib> it should say 100% awesome instead of 0% lame :((
11:43:44 <mauke> haha
11:43:47 <snhmib> if you do nickometer
11:43:59 <snhmib> Cale
11:44:02 <snhmib> thanks :)
11:44:03 <mauke> but it doesn't measure awesomeness
11:44:10 <snhmib> but i am :(
11:44:34 <snhmib> could you program in an exception for snhmib?
11:44:42 <Cale> Is there a theory of nick epicness?
11:44:50 <mauke> NO EXCEPTIONS
11:44:55 <snhmib> mauke: i'd scare the bejeebus out of the people in ##C
11:45:14 <snhmib> that would be justification enought for anyone!
11:45:17 <mauke> preflex: nickometer AllNight^
11:45:17 <preflex>  AllNight^ is 45% lame
11:45:24 <snhmib> see?
11:45:25 <mauke> that much?
11:45:25 <RayNbow> @karma Cale
11:45:26 <lambdabot> Cale has a karma of 17
11:45:28 <Cale> preflex: nickometer Cale
11:45:28 <preflex>  Cale is 0% lame
11:45:31 <snhmib> yea!
11:45:42 <snhmib> you'd be 100% awesome if it weren't for mauke
11:45:51 * AllNight^ wonders how these numbers are computed... :)
11:45:56 <snhmib> stupid mauke
11:46:04 <mauke> snhmib: I didn't invent the nickometer
11:46:06 <Cale> I think lameness and awesomeness should be measured separately :)
11:46:11 * RayNbow wonders why Cale's karma hasn't reached 600+ yet
11:46:20 <mauke> preflex: karma Cale
11:46:20 <preflex>  Cale: 4
11:46:23 <Cale> RayNbow: Because the karma database keeps getting reset
11:46:44 <RayNbow> Cale++
11:46:48 <RayNbow> @karma Cale
11:46:48 <lambdabot> Cale has a karma of 18
11:46:49 <snhmib> mauke: you're making this more complex than it eeds to be!
11:46:51 <RayNbow> apparently
11:47:00 <Cale> At one point I had a karma around 90 or so.
11:47:08 <snhmib> karma has nothing no do with it!
11:47:20 <snhmib> that'l something for earl and his name
11:47:23 <snhmib> not for irc
11:47:48 <C-Keen> @faq Can Haskell increase awesomeness?
11:47:48 <lambdabot> The answer is: Yes! Haskell can do that.
11:48:02 <Cale> I wonder what algebraic properties lameness satisfies
11:48:11 <jeff_s_> can haskell get my rabbits to stop peeing on thier hay?
11:48:12 <C-Keen> infinity
11:52:05 <ziman> @pl \x:xs -> (x,xs)
11:52:05 <lambdabot> liftM2 (,) head tail
11:52:20 <mauke> hehe
11:52:40 <RayNbow> :t head &&& tail
11:52:41 <lambdabot> forall c. [c] -> (c, [c])
11:53:19 <ziman> thanks :)
11:54:04 <AllNight^> Cale - multiplying anything by lamness yields lameness?
11:54:08 * AllNight^ random suggestion :)
11:55:27 <dirk__> I got an html symbol &#x302;  where 302 is always different an I want to write the unicode character and cabal says it Data.Text  / text
11:55:42 <dirk__> cannot install
11:57:36 <RayNbow> ziman: if you need a name for (\(x:xs) -> (x,xs)), you could call it uncons
11:59:20 <dirk__> forget what I just wrote
11:59:21 <RayNbow> (although most uncons functions I found with Hayoo! are safe and have type f a -> Maybe (a, f a) for some type constructor f)
11:59:47 <mauke> I like uncons :: [a] -> b -> (a -> [a] -> b) -> b
12:00:53 <RayNbow> mauke: does that return the 2nd argument when the first is null?
12:01:01 <mauke> yes
12:05:55 <magthe> I just posted http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5814#a5814 hopefully my intention is clear, but that code doesn't work... is it possible to achieve what I'd like to do?
12:07:09 <mauke> class Foo a v | a -> v where
12:07:10 <RayNbow> :t let uncons xs@(h:t) z f = if null xs then z else f h t     in     \xs -> uncons xs Nothing ((Just.).(,))         -- mauke? :)
12:07:11 <lambdabot> forall t. [t] -> Maybe (t, [t])
12:07:50 <mauke> > let uncons xs@(h:t) z f = if null xs then z else f h t     in uncons "" () undefined
12:07:51 <lambdabot>   * Exception: <interactive>:1:137-186: Non-exhaustive patterns in function u...
12:08:16 <RayNbow> ah wait
12:08:24 <RayNbow> pattern needs to be lazy
12:08:48 <mauke> uncons [] d _ = d; uncons (x : xs) _ f = f x xs
12:16:25 <mmorrow> mauke: yeah, that's a nice one
12:17:05 <mmorrow> @let list n _ [] = n; list _ c (x:xs) = c x xs
12:17:07 <lambdabot>  Defined.
12:17:31 * Cale sometimes wishes that foldr was called list
12:17:45 <Cale> But that is sort of asymmetric :)
12:19:38 <magthe> mauke: I needed a few pragmas to get that working (MultiParamTypeClasses, FunctionalDependencies, FlexibleInstances), since this is using functional dependencies, is there also a way to achieve it using type families?
12:19:55 <mib_ur0fwq> hi all
12:20:00 <mmorrow> @type \f -> fix (\k a -> list a (k . f a))
12:20:00 <Cale> hello
12:20:02 <lambdabot> forall t t1. (t -> t1 -> t) -> t -> [t1] -> t
12:20:20 <mauke> I haven't used type families
12:20:52 <Cale> magthe: If you want, I can take a look at it and try to translate
12:20:54 <mmorrow> @type \f -> fix (\k a -> list a (\x -> f x . k a))
12:20:55 <lambdabot> forall t1 c. (t1 -> c -> c) -> c -> [t1] -> c
12:21:10 <mmorrow> @type \f -> fix (\k a -> list a (\x -> k x . f a))
12:21:11 <lambdabot> forall c. (c -> [c] -> [c]) -> c -> [c] -> c
12:21:15 <mmorrow> grr
12:21:15 * Cale finds the link
12:21:18 <magthe> Cale: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5814#a5816
12:21:33 <mmorrow> @type \f -> fix (\k a -> list a (\x -> k (f a x))
12:21:35 <lambdabot> parse error (possibly incorrect indentation)
12:21:37 <mmorrow> @type \f -> fix (\k a -> list a (\x -> k (f a x)))
12:21:38 <lambdabot> forall t t1. (t -> t1 -> t) -> t -> [t1] -> t
12:21:47 <magthe> Cale: I tried type families myself before asking in here, but got stuck on syntax (I think :) )
12:22:07 <mmorrow> damn, you can't use (.) and be symmetric
12:22:17 <mmorrow> @type \f -> fix (\k a -> list a (\x xs -> k (f a x) xs)
12:22:19 <lambdabot> parse error (possibly incorrect indentation)
12:22:24 <mmorrow> @type \f -> fix (\k a -> list a (\x xs -> k (f a x) xs))
12:22:26 <lambdabot> forall t t1. (t -> t1 -> t) -> t -> [t1] -> t
12:22:39 <mmorrow> @type \f -> fix (\k a -> list a (\x xs -> f x (k a xs)))
12:22:39 <raimo> is there better way to format this kind of statement? http://haskell.pastebin.com/m5109ed37
12:22:41 <lambdabot> forall t t1. (t1 -> t -> t) -> t -> [t1] -> t
12:23:03 <mib_ur0fwq> if someone has had issues w/ the openlog function in System.Log.Handler.Syslog in Linux (you'll know what I'm talking about), what has been done to resolve it, if anything? Do you have to roll your own solution, similar to the what's in the guts of openlog_remote?
12:23:34 <raimo> if those anonymous blocks gets a bit larger it's hard to read and if I break it to multiple lines it looks too much like lisp
12:23:34 <Cale> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5814#a5818
12:24:32 <mmorrow> @pl map (\x -> map (\y -> SomeData x y ) x) list
12:24:33 <lambdabot> map (map =<< SomeData) list
12:24:36 <mmorrow> grr
12:24:42 <Cale> magthe: ^^
12:24:46 <sven_> hi
12:25:07 <sven_> can somebody tell me how to write a show function for a tuple with 8 integers in it?
12:25:21 <Cale> sven_: uh, there already is one, is there not?
12:25:28 <Cale> show
12:25:29 <mmorrow> raimo: well, not really, unless you want to use (=<<)
12:25:42 <Cale> sven_: Or do you want to see it written out manually?
12:25:44 <bremner> > show (1,2,3,4,5,6,7,8)
12:25:45 <lambdabot>   "(1,2,3,4,5,6,7,8)"
12:25:48 <mmorrow> @src (->) >>=
12:25:49 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
12:25:53 <mmorrow> @src (->) (>>=)
12:25:53 <lambdabot> f >>= k = \ r -> k (f r) r
12:25:59 <sven_> hmm that does not work in hugs
12:26:15 <Cale> oh, wow
12:26:22 <Cale> hugs doesn't have enough instances :)
12:26:36 <mmorrow> heh, ghc at least goes up to something-teen :P
12:27:12 <Cale> instance (Show a1, Show a2, Show a3, Show a4, Show a5, Show a6, Show a7, Show a8) => Show (a1,a2,a3,a4,a5,a6,a7,a8) where
12:28:17 <Cale>   show (x1,x2,x3,x4,x5,x6,x7,x8) = "(" ++ intercalate "," [show x1,show x2,show x3,show x4,show x5,show x6,show x7,show x8] ++ ")"
12:28:45 <Cale> oh, hugs also doesn't have intercalate
12:28:47 <mauke> intersperse ','
12:29:05 <Cale> concat (intersperse "," [...])  then
12:29:57 <mauke> my emperor, I've failed you
12:29:59 <Cale> Heh, in the September 2006 version of hugs, the banner message indicates that the copyright ends in 2005
12:30:49 <mmorrow> , 42
12:30:58 <mmorrow> heh, lunabot finally bit it
12:31:05 <mmorrow> almost 3 months!
12:31:09 <Cale> sven_: In any event, hugs is a somewhat impoverished environment, and you should see about getting ghc/ghci
12:33:47 <sven_> Cale: thank you very much, works fine
12:35:16 <mib_ur0fwq> apparently, linux sockets are not datagrams but streams, so a protocol-type exception is thrown when trying to use openlog on linux...
12:38:30 <mmorrow> , ppDoc `fmap` (let go n = do xs <- replicateM n (newName "x"); k <- newName "k"; lamE [tupP (fmap varP xs), varP k] [|$(varE k) $(listE (fmap (\x -> [|show $(varE x)|]) xs))|] in go 3)
12:38:32 <lunabot>  \(x_0, x_1, x_2) k_3 -> k_3 [show x_0, show x_1, show x_2]
12:38:48 <gnuvince> What's the function to catch errors with read?
12:39:01 <mauke> gnuvince: no
12:39:08 <mauke> use reads instead
12:39:48 <mmorrow> , $(let go n = do xs <- replicateM n (newName "x"); k <- newName "k"; lamE [varP k, tupP (fmap varP xs)] [|$(varE k) $(listE (fmap (\x -> [|show $(varE x)|]) xs))|] in go 3) (parens . hcat . punctuate comma . fmap text) (0,2,3,Nothing,(),[0..2],9,42)
12:39:50 <lunabot>  luna: Couldn't match expected type `(t, t1, t2)'
12:39:56 <mmorrow> , $(let go n = do xs <- replicateM n (newName "x"); k <- newName "k"; lamE [varP k, tupP (fmap varP xs)] [|$(varE k) $(listE (fmap (\x -> [|show $(varE x)|]) xs))|] in go 8) (parens . hcat . punctuate comma . fmap text) (0,2,3,Nothing,(),[0..2],9,42)
12:39:58 <lunabot>  (0,2,3,Nothing,(),[0,1,2],9,42)
12:40:14 <gnuvince> mauke: sorry?
12:40:16 <gnuvince> :t reads
12:40:18 <lambdabot> forall a. (Read a) => String -> [(a, String)]
12:40:46 <mmorrow> @let readM s = case reads s of (a,_):_ -> Just a; _ -> Nothing
12:40:48 <lambdabot>  Defined.
12:41:07 <centrinia> Is it possible to define a typeclass where you can list every value in an instance type?
12:41:27 <mmorrow> centrinia: what do you mean?
12:41:33 <Saizan> something like Enum?
12:41:43 <mmorrow> ah
12:41:51 <mmorrow> probably want Bounded too maybe
12:41:58 <mauke> @let values :: (Bounded a, Enum a) => [a]; values = [minBound .. maxBound]
12:41:58 <centrinia> Okay.
12:41:59 <lambdabot>  Defined.
12:41:59 <Saizan> yeah
12:42:04 <hackagebot> HaskellForMaths 0.1.1 - <i>Added by DavidAmos, Fri Jun 12 19:39:43 UTC 2009.</i>
12:42:08 <mauke> > values :: [Int]
12:42:11 <lambdabot>   [-9223372036854775808,-9223372036854775807,-9223372036854775806,-9223372036...
12:42:19 <mmorrow> > values :: [()]
12:42:21 <lambdabot>   [()]
12:42:27 <burp> :t values
12:42:29 <lambdabot> forall a. (Bounded a, Enum a) => [a]
12:42:30 <mmorrow> > values :: [Maybe Bool]
12:42:31 <lambdabot>   No instances for (GHC.Enum.Enum (Data.Maybe.Maybe GHC.Bool.Bool),
12:42:32 <lambdabot>          ...
12:42:41 <centrinia> > values :: [Bool]
12:42:42 <mmorrow> that'd be cool if that worked
12:42:42 <burp> @hoogle values
12:42:42 <lambdabot> No results found
12:42:43 <lambdabot>   [False,True]
12:43:48 <centrinia> Would it make sense to define an equality of functions: feq :: (Bounded a,Enum a) => (a -> b) -> (a -> b) -> Bool ?
12:43:53 <burp> > values :: [Integer]
12:43:54 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Integer.Internals.Integer)
12:43:54 <lambdabot>    arising...
12:44:06 <gnuvince> mauke: thanks, reads is a lot nicer than handling read's exception.  Is there any reason why it returns a list instead of a Maybe value?
12:44:08 <Cale> centrinia: sure
12:44:12 <centrinia> Cool. :)
12:44:30 <Cale> centrinia: Though for functions like Int -> Int, even though it would work, it would be quite slow :)
12:44:40 <mauke> gnuvince: to allow ambiguous values
12:44:43 <trofi> > read "hello" :: Maybe Int
12:44:44 <lambdabot>   * Exception: Prelude.read: no parse
12:45:02 <mauke> gnuvince: in theory there could be strings that have more than one interpretation
12:45:14 <centrinia> > read "-9223372036854775809" :: Maybe Int
12:45:16 <lambdabot>   * Exception: Prelude.read: no parse
12:45:20 <centrinia> > read "-9223372036854775808" :: Maybe Int
12:45:22 <lambdabot>   * Exception: Prelude.read: no parse
12:45:48 <mmorrow> > readM "-9223372036854775808" :: Maybe Int
12:45:50 <lambdabot>   Just (-9223372036854775808)
12:46:06 <gnuvince> mauke: ok
12:46:07 <centrinia> > readM "-9223372036854775809" :: Maybe Int
12:46:09 <lambdabot>   Just 9223372036854775807
12:46:16 <centrinia> Weird.
12:46:23 <koeien> centrinia: you need Eq b as well.
12:46:35 <centrinia> koeien: Thanks. I forgot. :)
12:46:35 <mmorrow> > minBound :: Int
12:46:37 <lambdabot>   -9223372036854775808
12:46:40 <koeien> but it will be pretty slow
12:47:05 <mmorrow> looks like read for Int goes via Integer...
12:47:35 <centrinia> @let feq f g = and $ zipWith (==) (map f values) (map g values)
12:47:36 <lambdabot>  Defined.
12:47:40 <mmorrow> err, or maybe not
12:48:06 <centrinia> > feq (const ( 0 :: Short)) (\x -> 0 * x)
12:48:08 <lambdabot>   Not in scope: type constructor or class `Short'
12:48:14 <centrinia> > feq (const ( 0 :: Int16)) (\x -> 0 * x)
12:48:16 <lambdabot>   Add a type signature
12:48:16 <koeien> centrinia: try Word8
12:48:29 <centrinia> > feq (const ( 0 :: Word8)) (\x -> 0 * x :: Word 8)
12:48:31 <lambdabot>   Only unit numeric type pattern is valid
12:48:37 <mauke> haha
12:48:37 <centrinia> > feq (const ( 0 :: Word8)) (\x -> 0 * x :: Word8)
12:48:39 <lambdabot>   Add a type signature
12:49:09 <koeien> that function cannot work, what is "values"?
12:49:15 <mauke> :t feq
12:49:17 <lambdabot> forall a1 a a2. (Eq a, Bounded a1, Enum a1, Bounded a2, Enum a2) => (a1 -> a) -> (a2 -> a) -> Bool
12:49:21 <centrinia> Oh.
12:49:25 <koeien> ah nvm.
12:49:45 <mmorrow> , id .==. id
12:49:48 <lunabot>  True
12:50:01 <mmorrow> , undefined .==. undefined
12:50:04 <lunabot>  True
12:50:06 <mmorrow> weeee
12:50:19 <koeien> , undefined .==. const undefined
12:50:21 <lunabot>  False
12:50:23 <mauke> , 'x' .==. ()
12:50:24 <lunabot>  luna: Couldn't match expected type `GHC.Types.Char'
12:50:27 <koeien> ah! Hask is not a category
12:51:45 <mmorrow> , Nothing .==. []
12:51:47 <lunabot>  luna: Couldn't match expected type `Data.Maybe.Maybe a'
12:52:09 <mmorrow> , let x = 1 + 1 in (x .==.) $! x
12:52:12 <lunabot>  False
12:52:26 <mmorrow> , let x = 1 + 1 in (x .==.) $ x
12:52:28 <lunabot>  True
12:54:07 <hackagebot> HaskellForMaths 0.1.2 - <i>Added by DavidAmos, Fri Jun 12 19:53:30 UTC 2009.</i>
12:55:19 <koeien> ah, that is packaged now? that was an interesting website
12:59:50 <magthe> Cale: somewhat late: thanks!
13:13:16 <jeffwheeler> I'm looking for a function to convert integers into their English representations. I'm sure somebody's done this, but Google isn't helping much. :-/
13:14:11 <jeffwheeler> That is, > f 20 == "twenty" and such
13:14:53 <Zao> jeffwheeler: Doing the Project Euler problem? :)
13:14:53 <hackagebot> uu-parsinglib 2.2.0 - New version of the Utrecht University parser combinator library (DoaitseSwierstra)
13:15:10 <jeffwheeler> Zao: No, somebody posted an interesting question on Twitter :)
13:15:21 <jeffwheeler> Zao: although . . . that could very well be their source. ;)
13:15:37 <Zao> http://projecteuler.net/index.php?section=problems&id=17
13:16:52 <jeffwheeler> Ah, they wanted the first prime, alphabetically.
13:17:35 <jeffwheeler> I suppose I can use the solution to that problem, though, to help.
13:19:01 <FunctorSalad> don't they always begin with a digit word or double digit word except 0,11,12,13?
13:19:24 <FunctorSalad> and 15
13:19:53 <FunctorSalad> ok, depends on "thousand" vs. "one thousand" etc
13:20:27 <jeffwheeler> FunctorSalad: I was thinking something along those lines
13:23:19 <FunctorSalad> jeffwheeler: my guess is it is "eight billion <something>" ;)
13:23:37 <jeffwheeler> We'll find out shortly.
13:23:47 <FunctorSalad> or billiard, with the long ladder
13:25:32 <FunctorSalad> probably also depends on whether you allow arbitrary latin number words up the ladder
13:25:39 <FunctorSalad> maybe there's one starting with a?
13:25:54 <FunctorSalad> I mean as in trillion, quadrillion, ...
13:26:14 <jeffwheeler> The solution to problem 17 doesn't do that . . . :(
13:27:07 <jeffwheeler> Doesn't look like it: http://www.unc.edu/~rowlett/units/large.html
13:29:44 <jeffwheeler> Oh noes! Problem 17's solution gives me non-exhaustive patterns.
13:29:57 <FunctorSalad> nooooooo
13:30:02 <FunctorSalad> :)
13:31:10 <jeffwheeler> Eighty-nine seems to be the first in 30 primes.
13:31:10 <FunctorSalad> you could try -Wall to find the problematic statement
13:32:28 <FunctorSalad> eight billion something would beat that...
13:32:41 <jeffwheeler> Woah, crazy linking errors. Uh oh.
13:33:37 <jeffwheeler> There I go . . .
13:36:00 <FunctorSalad> jeffwheeler: 8 888 888 888 849 (long ladder, so it is "billiard")?
13:36:11 <FunctorSalad> just a guess, didn't think it through ;)
13:36:44 <FunctorSalad> or you could optimize the latin words beyon the first group too
13:36:44 <jeffwheeler> I'm not sure . . . you can respond to @pzr, with it, though. ;)
13:37:22 <FunctorSalad> 8888888888857 <- better
13:37:28 <ehird> Is there a monad for coroutines?
13:37:32 <ehird> That'd be neat.
13:38:03 <jeffwheeler> Oh, apparently the decompose function simply doesn't handle anything >1000.
13:39:29 <jeffwheeler> For primes <= 1000, 881 is the largest.
13:39:41 <MartyIX> Is it true that all pattern bindings are evaluated as lazy patterns?
13:42:17 <Cale> MartyIX: yes
13:42:40 <Cale> MartyIX: They're treated as if they had a ~ before them
13:43:48 <Cale> MartyIX: This turns out to be usually what you mean anyway... let is not supposed to do anything to control evaluation, though in recent extensions, there's something called bang patterns which can undo that effect (basically turning let into case)
13:44:55 <MartyIX> Cale: thanks. I'm fighting with definition of pattern binding too. It seems to me that it's simply assinging of a value to a variable (it's very simply)
13:45:17 <MartyIX> Cale: ... with respect to certain rules
13:45:49 <Cale> MartyIX: Basically
13:46:00 <Cale> > let (x:xs) = [1..10] in (x,xs)
13:46:01 <lambdabot>   (1,[2,3,4,5,6,7,8,9,10])
13:47:34 <Cale> They can also be recursive though
13:47:40 <Cale> > let xs = 1 : xs in xs
13:47:41 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
13:48:05 <Cale> > let (x:xs) = 0 : 1 : zipWith (+) xs (x:xs) in x:xs
13:48:06 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
13:49:20 <MartyIX> Cale: So is there any particular situation where I need to use ~ (for lazy patterns) except if I have defined several predicates which depend on themselves (circle definition)
13:50:11 <Cale> ~ occasionally matters in parameters to functions, and nested inside pattern bindings
13:50:23 <jmcarthur_work> foo ~(x,y) = if somethingNotHavingAnthingToDoWithXOrY then x else somethingElse
13:50:40 <jmcarthur_work> or whatever
13:50:53 <jmcarthur_work> although fst would be a good way to get around that
13:51:10 <MartyIX> Cale: Thanks for examples ;-)
13:51:29 <Gracenotes> D:
13:51:31 <Cale> Yeah, lazy patterns basically give you the equivalent of extractor functions without having to give those functions names.
13:52:09 <Cale> And, just like functions which extract components of things, it's dangerous to use them if you're uncertain whether the pattern will match
13:52:17 <Cale> > let (x:xs) = [] in x
13:52:18 <lambdabot>   * Exception: <interactive>:1:137-147: Irrefutable pattern failed for patter...
13:52:24 <MartyIX> jmcarthur_work: so the advantage is here that I don't need to process (x,y)?
13:52:26 <Cale> You get a runtime exception
13:52:28 <Cale> > let (x:xs) = [] in 1
13:52:29 <lambdabot>   1
13:52:44 <Cale> But only when the bound variable is evaluated
13:54:30 <Cale> MartyIX: Right, it doesn't force whatever expression (x,y) is going to be matched against, until it can be determined that x or y is really needed.
13:54:55 <MartyIX> Cale: Is it possible that lazy patterns would be used as optimization tool? (I'm not sure how fast haskell is, but let's suppose some killer application)
13:55:10 <Cale> MartyIX: With tuples, it's especially useful, since you know that unless the thing is nonterminating or some other kind of error, you can be certain that your pattern really does match
13:55:23 <Cale> Yes, they can be important to performance.
13:55:24 <Jedai> MartyIX: an example where lazy pattern are useful "part = foldr (\x ~(xs,ys) -> (ys,x:xs)) ([],[])"
13:55:56 <Cale> > foldr (\x ~(xs,ys) -> (ys,x:xs)) ([],[]) [1..10]
13:55:57 <lambdabot>   ([2,4,6,8,10],[1,3,5,7,9])
13:56:00 <Jedai> MartyIX: part split a list in two sublist of equal size (or almost equal if the length is odd)
13:56:49 <Cale> > foldr (\x (xs,ys) -> (ys,x:xs)) ([],[]) [1..10]
13:56:50 <lambdabot>   ([2,4,6,8,10],[1,3,5,7,9])
13:56:54 <Cale> > foldr (\x (xs,ys) -> (ys,x:xs)) ([],[]) [1..]
13:56:55 <lambdabot>   * Exception: stack overflow
13:56:58 <Cale> > foldr (\x ~(xs,ys) -> (ys,x:xs)) ([],[]) [1..]
13:56:59 <lambdabot>   ([2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52...
13:57:00 <Jedai> > take 10 . fst . foldr (\x ~(xs,ys) -> (ys,x:xs)) ([],[]) $ [1..]
13:57:02 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
13:57:19 <MartyIX> Jedai: moment pls I have to decipher what is what :))
13:57:37 <Cale> The lazy pattern means that the beginning of the lists can be determined without having to go *all* the way to the end of the input list first
13:57:56 <Gracenotes> pls to use lazy pattern
13:58:06 <dirk__> I am also lazy
13:58:41 <dirk__> no doing any work a week now, but just programming in Haskell for fun
13:58:57 <Jedai> MartyIX: The version with lazy pattern works with infinite list and is a good consumer, whereas the version with the classic patter is limited to finite lists and is a bad consumer
13:58:59 <PetRat> I have a question here: http://www.mibbit.com/pb/ydk4aQ  (I'm working through the "Monad Transformers Step By Step" article found here: http://user.cs.tu-berlin.de/~magr/pub/Transformers.pdf)
13:59:54 <hape> that is interesting, i run here the haskell parallel execution example "Write your first parallel Haskell program" using "import Control.Parallel".... main = a `par` b `par` c `pseq` print (a + b + c) ... Since i am running GHC6 on Linux in a VirtualBox running on Vista, it seams it takes only one of 4 CPU's (and the calculation then last quite long...) but i think GHC is not reliable for this, it is a problem of Sun's VirtualBox...
14:00:00 <hape> http://haskell.org/haskellwiki/Haskell_in_5_steps#Write_your_first_Haskell_program
14:02:16 <Jedai> PetRat: I'm not sure I understand your question ? The Funval is a closure, it remembers the environment where it was defined, not where it is used
14:02:28 <Jedai> PetRat: As in Haskell :
14:02:50 <Jedai> > let a = 5; f () = a in (let a = 3 in f ())
14:02:52 <lambdabot>   5
14:03:29 <Jedai> PetRat: as you see, the "a" in the function is not the "a" in the environment where it was used :)
14:04:38 <Jedai> PetRat: This is generally what you wish for in a sane language, since it means you can't inadvertently alter the meaning of a function
14:06:23 <Jedai> hape: Did you compile with the -threaded option
14:06:39 <jmcarthur_work> hape, do make sure you compile with -threaded and run with +RTS -N
14:06:55 <jmcarthur_work> if it still doesn't use more than one cpu is'
14:07:03 <jmcarthur_work> *s probably virtualbox
14:07:04 <hape> jmcarthur, Jedai: i go back and check this first it was in ghci.
14:07:38 <jmcarthur_work> hape, that was the problem then. ghci is not a really reliable way to test parallel programs, in my experiences
14:07:45 <hape> ah yes
14:08:07 <MartyIX> > foldl (\x ~(xs,ys) -> (ys,x:xs)) ([],[]) [1..10]
14:08:09 <lambdabot>   Occurs check: cannot construct the infinite type: a = (t, [a])
14:08:53 <megaTherion> A way to deal with galois fields in haskell?
14:09:06 <Jedai> MartyIX: foldr, not foldl
14:09:52 <Jedai> MartyIX: If you haven't yet, you should read the article on the wiki on the folds
14:10:50 <Cale> On wikipedia? I suppose I copied it to the Haskell wiki as well, but other people have improved the wikipedia one with information about other languages :)
14:11:13 <Cale> I'm surprised about how little the text I originally wrote has changed though :)
14:11:22 <MartyIX> Jedai: Yeah I've already read it. I just wanted to try what does it changes.. :)
14:13:19 <Jedai> MartyIX: foldl always have to read to the end of the list before returning anyway but using a lazy pattern here still change something
14:14:01 <Jedai> > foldl (\~(xs,ys) x -> (ys,x:xs)) ([],[]) [1..10]
14:14:02 <lambdabot>   <no location info>: parse error on input `->'
14:14:37 <Jedai> normally with the lazy pattern, there shouldn't be any stack overflow
14:14:46 <MartyIX> Jedai: great I've understand it finally.. it's simple.
14:15:17 <Jedai> > foldl (\ ~(xs,ys) x -> (ys,x:xs)) ([],[]) [1..10]
14:15:19 <lambdabot>   ([9,7,5,3,1],[10,8,6,4,2])
14:16:25 <Jedai> > take 10 . fst . foldl (\ ~(xs,ys) x -> (ys,x:xs)) ([],[]) $ [1..10000000]
14:16:31 <lambdabot>   mueval-core: Prelude.read: no parse
14:16:31 <lambdabot>  mueval: ExitFailure 1
14:20:23 <MartyIX> Jedai: well but does really haskell use the advantage of lazy patter in this snippet: foldr (\x ~(xs,ys) -> (ys,x:xs)) ([],[]) [1..10] ?  -- you defined a lambda function that matches right away but right next it needs (in the "body" of function) the value of x, xs and ys so it needs to resolute the value, doesn't it?
14:20:49 <Cale> MartyIX: it does not immediately need the matched valeus
14:20:49 <Cale> values*
14:21:11 <Cale> MartyIX: Because it immediately returns the constructor (,) applied to the expressions ys and x:xs which will only be evaluated if needed
14:22:48 <MartyIX> Cale: oh I see
14:22:55 <jmcarthur_work> MartyIX, the function returns (<thunk>,<thunk>) at first. only when one of the thunks is evaluated will the pattern match evaluate
14:23:19 * Cale generally prefers the word 'expression' to the word 'thunk' for some reason :)
14:23:35 <jmcarthur_work> Cale, thunk reeks of operational semantics
14:23:40 <Cale> yeah
14:23:53 <jmcarthur_work> i use it only because a lot of programmers understand it
14:23:54 <Cale> Well, even more than that, an actual machine implementation
14:24:04 <chromakode> hey, how does one show the nodes of a Data.Tree?
14:24:10 <PetRat> Jedai: Thanks. I clarified my question here. http://www.mibbit.com/pb/do4Koc
14:24:13 <chromakode> I know it's in Applicative/Functor, but I'm not sure how to use them
14:24:19 <Cale> For my head, I use an operational semantics which works by repeatedly transforming expressions
14:24:33 <Cale> chromakode: show them?
14:24:46 <Cale> chromakode: There's a Show instance as well...
14:24:47 <chromakode> Cale: I'd like to map show to every value in the tree, while retaining tree structure
14:24:51 <Cale> ah
14:24:53 <Cale> fmap show
14:25:08 <chromakode> that seems to show the subtrees
14:25:13 <chromakode> it doesn't deeply map
14:25:20 <Cale> It must.
14:25:27 <Cale> It wouldn't typecheck if it didn't.
14:25:36 <jmcarthur_work> in my head, the "result" of a function is the WHNF of its RHS and the "side effects" on the LHS (where forcing thunks counts as side effects)
14:26:00 <chromakode> oh, I see Cale, sorry -- it was a Forest ([Node]), so fmap show was showing the list items!
14:26:03 <Cale> (you can't have subtrees whose nodes have a different type than the root)
14:26:12 <Cale> ah
14:26:13 <hape> jmcarthur, Jedai: now i have run the test programm again with -threaded, but it is similar, 3 of 4 cpus are sleeping.... but i can imagine, virtualbox could be a reason
14:26:20 <chromakode> Cale: thanks for the help!
14:26:23 <Cale> fmap (fmap show) then :)
14:26:27 <chromakode> yep
14:26:30 <chromakode> got it!
14:26:36 <jmcarthur_work> hape, you compiled with -threaded *and* ran with +RTS -N?
14:27:06 <hape> yes
14:27:11 <Jedai> PetRat: You're wrong, the first expression can be something else than a Abs, it may be a Var
14:27:12 <hape> time ./a +RTS -N2
14:27:28 <hape> ghc -O2 --make a.hs -threaded
14:27:56 <jmcarthur_work> hape, you might need to force recompilation if you had already compiled it without -threaded before that
14:28:11 <jmcarthur_work> -no-recomp is the outdated way to do that, i forget the new one
14:28:19 <jmcarthur_work> old should work, it will just yell at you
14:28:28 <hape> i try
14:28:36 <glguy> -fforce-recomp?
14:28:42 <jmcarthur_work> aha, that sounds right
14:29:00 <PetRat> Jedai: okay, what's confusing me is the case statement seems to be used for pattern matching. There is only one case, so that is why I assumed val1 can only be a FunVal. By the way I understand closures in Haskell---my problem is I don't understand how this  behavior "falls out" from the given code.
14:30:30 <hape> jmcarthur, glguy: -fforce-recomp    and   -no-recomp   both do their job and recompile.
14:30:37 <hape> but 3  of 4 cpus are sleeping again
14:30:58 <MartyIX> jmcarthur_work: Cale: foldr (\x ~(xs,ys) -> (ys,x:xs)) ([],[]) [1,2..]  <-- how is resoluted the number of numbers that are printed? directives?
14:31:12 <Jedai> PetRat: val1 can only be FunVal (or rather should only be FunVal), it's exp1 that may be a Abs or a Var
14:31:37 <Cale> MartyIX: How many characters you ask for
14:31:48 <hape> jmcarthur, but who nows perhaps one of the tasks takes long and the other are finished soon, then the result could be ok
14:31:48 <Jedai> MartyIX: You're not clear, do you mean in lambdabot ?
14:31:56 <Cale> MartyIX: if you try to print them all, it will just keep printing
14:32:07 <Cale> (and in fact, it'll never get to the second list)
14:32:18 <miket> haskell sucks
14:32:27 <Jedai> miket: Sure !
14:32:30 <jmcarthur_work> hape, sounds like you are building and running correctly at least
14:32:31 <Cale> miket: In what way?
14:32:34 <Jedai> miket: it does
14:32:36 <MartyIX> Jedai: yes in lambdabot. Because it stopped at number 538 and there's nothing like three dots or something
14:32:38 <miket> lol
14:32:39 <miket> that wasn't me
14:32:41 <miket> :(
14:32:45 <Cale> heh
14:32:47 <Jedai> miket: but less than anything else
14:32:48 <miket> it was a JOKER
14:33:14 <hape> jmcarthur, thank for your help - i didn't know this before :-)
14:33:33 <Jedai> MartyIX: lambdabot cut its output after a certain number of characters I believe, there's nothing magical about it
14:33:36 <PetRat> Jedai: thanks for your help with this. It's complex (at least feels complex to a noobie) so I think I will just study it some more and see what I can get.
14:33:45 <MartyIX> Cale: well If I type a command like the one above than there's no specific number I request
14:33:52 <jmcarthur_work> > [1..]
14:33:54 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
14:34:03 <jmcarthur_work> it does do three dots
14:34:20 <Vanadium> > repeat [1..]
14:34:22 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
14:34:27 <jmcarthur_work> >  foldr (\x ~(xs,ys) -> (ys,x:xs)) ([],[]) [1,2..]
14:34:29 <lambdabot>   ([2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52...
14:34:31 <MartyIX> > foldr (\x ~(xs,ys) -> (ys,x:xs)) ([],[]) [1,2..]
14:34:33 <lambdabot>   ([2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52...
14:34:33 <jmcarthur_work> even there
14:35:11 <MartyIX> jmcarthur_work: oh it's different when you write here and when you write PM to lambdabot..
14:35:12 <jmcarthur_work> lambdabot is simply asking for one character of output at a time and then stopping
14:35:15 <jmcarthur_work> yes
14:35:23 <Cale> MartyIX: The bot just does something like take 75 or something on the show of the value, and then adds some dots to the end.
14:35:23 <jmcarthur_work> lambdabot gives you more output in PMs
14:35:32 <AllNight^> hi again :)
14:35:37 <Cale> hello :)
14:35:46 <MartyIX> :)
14:35:47 <AllNight^> hi Cale :)
14:35:55 <AllNight^> hi MartyIX :)
14:36:09 <MartyIX> AllNight^: hi :)
14:36:22 <Jedai> PetRat: Look, in a concrete syntax for your language (haskell-like), you have two case for an application : "(\x -> x + 1) 3" and "f 5" where f is a variable (which contains a FunVal)
14:36:46 <AllNight^> another quick question ... I've just written 'apply x y = y x' -- is there a function like this already in the standard libs?
14:36:58 <aavogt> @type $$
14:37:01 <lambdabot> parse error on input `$$'
14:37:05 <aavogt> @type ($$)
14:37:06 <lambdabot> Doc -> Doc -> Doc
14:37:09 <mauke> AllNight^: flip id
14:37:24 <Jedai> PetRat: in the second case, the environment in f isn't the same as the environment where f is applied
14:37:28 <AllNight^> ty mauke :)
14:37:45 <PetRat> Jedai: ah... so a lambda expression does not use a closure (cannot ever) but a variable which contains a FunVal would have a closure associated with it. Okay I get it.
14:37:54 <aavogt> @hoogle ($$)
14:37:54 <lambdabot> Text.PrettyPrint.HughesPJ ($$) :: Doc -> Doc -> Doc
14:37:54 <lambdabot> Language.Haskell.TH.PprLib ($$) :: Doc -> Doc -> Doc
14:37:54 <lambdabot> Text.Parsec.Perm (<$$>) :: Stream s Identity tok => (a -> b) -> Parsec s st a -> StreamPermParser s st b
14:38:24 <AllNight^> btw... I dont suppose there's any way to automatically derive the 'most general' instance of a function satisfying some type signature?
14:38:25 <Cale> AllNight^: or flip ($)
14:38:43 <Cale> AllNight^: djinn does this, for non-recursive types
14:38:51 <mauke> @djinn a -> (a -> b) -> b
14:38:52 <lambdabot> f a b = b a
14:38:58 <AllNight^> after all given the signature 'foo :: a -> (a -> b) -> b
14:39:00 <AllNight^> ah!
14:39:01 <aavogt> hmm, I swear that I've seen '($$) = flip id'
14:39:09 <Cale> @djinn (a -> Either b c) -> (b -> Maybe d) -> (c -> d) -> d
14:39:09 <lambdabot> -- f cannot be realized.
14:39:10 <AllNight^> thanks again!
14:39:19 <Cale> @djinn (a -> Either b c) -> (b -> Maybe d) -> (c -> d) -> Maybe d
14:39:19 <lambdabot> f _ _ _ = Nothing
14:39:28 * AllNight^ was pretty sure it had to be doable :)
14:39:28 <Cale> heh, not what I was thinking of
14:39:30 <Jedai> PetRat: to do the same example I did in Haskell, you can simulate let with abstractions : "(\f -> (\a -> f 1) 5) ((\a -> (\n -> a)) 3)"
14:39:31 <jmcarthur_work> nice
14:39:39 <Vanadium> flip id is scary
14:39:44 <mauke> Cale: don't you need some start value?
14:39:45 <Jedai> > (\f -> (\a -> f 1) 5) ((\a -> (\n -> a)) 3)
14:39:47 <lambdabot>   3
14:39:51 <Cale> @djinn (a -> Either b c) -> (b -> Maybe d) -> (c -> d) -> a -> d
14:39:51 <lambdabot> -- f cannot be realized.
14:39:54 <Cale> @djinn (a -> Either b c) -> (b -> Maybe d) -> (c -> d) -> a -> Maybe d
14:39:54 <lambdabot> f a b c d =
14:39:54 <lambdabot>     case a d of
14:39:54 <lambdabot>     Left e -> b e
14:39:54 <lambdabot>     Right f -> Just (c f)
14:40:00 <Cale> Right, there we go :)
14:40:17 <AllNight^> why is it scary Vanadium? :)
14:40:21 <FunctorSalad> what is that?
14:40:27 <Cale> @djinn ((a -> r) -> r) -> (a -> ((b -> r) -> r)) -> ((b -> r) -> r)
14:40:27 <lambdabot> f a b c = a (\ d -> b d c)
14:40:28 <FunctorSalad> (the type sig)
14:40:40 <Cale> There's bind for the Cont r monad :)
14:40:48 <Cale> :t callCC
14:40:50 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
14:40:51 <Jedai> PetRat: This is an expression of your language where you can clearly see that the environment the function evaluates in and the environment where it was applied are not the same
14:41:02 * AllNight^ had a list of functions & wanted to replace it with the list of values you get when applying each function to some value :)
14:41:12 <mauke> AllNight^: sequence
14:41:22 <Cale> @djinn ((a -> ((b -> r) -> r)) -> ((a -> r) -> r)) -> ((a -> r) -> r)
14:41:22 <lambdabot> f a b = a (\ c _ -> b c) b
14:41:29 <Cale> and there's callCC :)
14:41:43 <FunctorSalad> AllNight^: map ($value)
14:41:52 <mauke> > sequence [id, (+ 1), (* 3)] 23
14:41:53 <lambdabot>   [23,24,69]
14:42:23 <FunctorSalad> Cale: that is so wrong ;)
14:42:32 <Cale> FunctorSalad: what is?
14:42:47 <FunctorSalad> Cale: these types for the cont monad
14:42:49 <miket> haskell sucks
14:42:54 <miket> you should definitely use Erlang
14:42:57 <miket> it's so much better
14:43:03 <FunctorSalad> (ethically, not factually)
14:43:06 <FunctorSalad> ;)
14:43:06 <jmcarthur_work> miket, why do you keep saying that?
14:43:07 <iago> miket?
14:43:08 <Cale> miket: For distributed applications, perhaps
14:43:09 <miket> (btw, i'm not miket, so don't take this out on him)
14:43:12 <AllNight^> :djinn b -> [b -> c] -> [c]
14:43:20 <iago> miket do you program in erlang perhaps?
14:43:20 <AllNight^> @djinn b -> [b -> c] -> [c]
14:43:20 <iago> :P
14:43:21 <lambdabot> Error: Undefined type []
14:43:27 <Cale> miket: But I think even for SMP concurrency, Haskell does a better job
14:43:41 <miket> apparently i need to learn to lock my computer
14:43:56 <AllNight^> @djinn (b -> [b -> c] -> [c])
14:43:57 <lambdabot> Error: Undefined type []
14:43:58 <iago> erlang made me remember why I love statically typed languages
14:44:17 <AllNight^> okay... why doesnt that work?
14:44:27 <mauke> AllNight^: because djinn doesn't know []
14:44:30 <jmcarthur_work> AllNight^, djinn doesn't know lists
14:45:00 <jmcarthur_work> i think erlang's dynamic type system suits it well, personally
14:45:01 <PetRat>  Jedai: okay thanks for the example. I'm going to have to study it some more, but I think I basically get what you are saying.
14:45:08 <jmcarthur_work> very rarely would i say something like that
14:45:50 <jmcarthur_work> then again, i see erlang as more for robustness than correctness
14:45:51 * mmorrow rewrites a perl script in haskell he wrote two years ago that that processes a particular csv file, and it goes from 10 minutes to 3 minutes for a 1,000,000 line input
14:46:14 <Alpounet> Haskell ftw :-)
14:46:51 <mauke> what does it do?
14:47:01 <jmcarthur_work> time to golf!
14:47:21 <Zao> mmorrow: Now submit it to the language shootout :P
14:48:31 <mmorrow> mauke: it has to strip some fields, parse/rearrange others, a misc to transform this .csv with a bunch of insurance rates into the format of this sql table so it can loaded
14:49:04 <mmorrow> the .csv comes out of some horrendous windows program
14:49:34 * AllNight^ needs sleep! gnight all :)
14:50:42 <Jedai> mmorrow: Haskell is pretty good for this kind of small script, and it's becoming increasingly useful thanks to Hackage
14:51:20 * jmcarthur_work uses haskell for a lot of scripts like this nowadays
14:51:35 <Jedai> it's quite often faster, clearer and more robust than the alternatives too :)
14:51:54 <mmorrow> Jedai: yeah, haskell is really nice for stdin->stdout filters
14:52:30 <jmcarthur_work> it is my personal opinion that even one-shot scripts should be engineered and kept around rather than hacked and thrown away
14:52:57 <jmcarthur_work> much rather it be in haskell than any "scripting" language
14:53:56 <Nafai> jmcarthur_work: I think I often end up "reinventing the wheel" a lot each time I do a throw-away script in bash or Python that it would make sense to write things for longer-term
14:54:09 <Nafai> There is probably a good portion that could be solidly re-written and re-used for a lot of things
14:55:01 <jmcarthur_work> exactly
14:55:20 <jmcarthur_work> and lo and behold, i often do go back to use my "one shot" scripts again later
14:55:26 <jmcarthur_work> or slightly modified versions of them
14:55:28 <mmorrow> mauke: the perl one used Text::CSV_XS too, so i think the regexes were the killer
14:58:48 <augustss> regexes are overused
14:59:08 * jmcarthur_work loves parsec
14:59:16 <jmcarthur_work> regexes are for golfing
14:59:22 <mauke> and correct code
14:59:41 <mauke> parsec doesn't even get look-ahead right
15:00:07 <mmorrow> ReadP/bfs++
15:00:16 <jmcarthur_work> parsec is just one of many parser libraries, although it's the only haskell one i have really used at all
15:00:17 <uzytkownik> @hoogle (a -> IO Bool) -> IO a -> IO a
15:00:18 <lambdabot> Control.Exception handle :: (Exception -> IO a) -> IO a -> IO a
15:00:18 <lambdabot> Prelude catch :: IO a -> (IOError -> IO a) -> IO a
15:00:18 <lambdabot> System.IO.Error catch :: IO a -> (IOError -> IO a) -> IO a
15:00:30 <hape> do you use the haskell mode for emacs on ghci - on my pc  time by time depending on the file it hangs when i press C-c C-l  (load file into ghci emacs buffer)  You don't encounter problems with this?
15:00:31 <uzytkownik> @hoogle (a -> IO Bool) -> (a -> IO a) -> a -> IO a
15:00:31 <lambdabot> Control.Monad (<=<) :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c
15:00:32 <lambdabot> Control.Monad (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
15:00:32 <lambdabot> Data.Generics.Aliases extMp :: (MonadPlus m, Typeable a, Typeable b) => (a -> m a) -> (b -> m b) -> a -> m a
15:00:44 <augustss> are there Applicative instances for parsec now?
15:00:45 <mauke> Haskell has destroyed my ability to write parsers
15:00:50 <jmcarthur_work> augustss, in 3
15:01:11 <jmcarthur_work> finally
15:01:27 <FunctorSala> the recessive instances issue again?
15:01:43 <FunctorSala> (which would solve such things)
15:01:46 <augustss> jmcarthur_work: it's a bit annoying to use parsec without them
15:01:53 <jmcarthur_work> augustss, yeah :(
15:02:10 <FunctorSala> yes <$> <*> is really prettier than `fmap` `ap`
15:02:22 <FunctorSala> *> and <* are great too with parsec
15:02:37 <FunctorSala> for when some parsed item doesn't contribute to the value..
15:02:59 <jmcarthur_work> oh man i didn't even think about <*
15:03:07 * jmcarthur_work hasn't used parsec3 much yet
15:03:07 <augustss> I know, I write a library like that in the 80s. :)
15:03:14 <augustss> s/write/wrote/
15:03:32 <augustss> pre-haskell
15:04:07 <mmorrow> here's my super-leet csv parser http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2724#a2724 ;)
15:04:20 <mmorrow> (the pprinting isn't quite that leet though..)
15:04:33 <mmorrow> it's the fastest haskell csv parser i know of
15:04:36 <FunctorSala> jmcarthur_work: like "Pair <$> string *> comma <*> string" :)
15:04:44 <mmorrow> and it's a *real* csv parser..
15:04:47 <FunctorSala> for data Pair = Pair String String
15:05:03 * mmorrow has meant to put it on hackage for a while now
15:05:33 <Zao> mmorrow: What about non-comma-separated CSVs?
15:05:34 <pumpkin> there's also bytestring-csv on hackage
15:05:36 <pumpkin> how does it compare?
15:05:41 <Zao> Tabs, unicode separators, whatnot.
15:05:42 <jmcarthur_work> faster than http://hackage.haskell.org/package/bytestring-csv ?
15:05:46 <jmcarthur_work> ah, beat me to it
15:05:56 <mmorrow> Zao: sep = c2w ','
15:06:20 <mmorrow> (that could easily be made a param of the parsing function)
15:07:15 <mmorrow> jmcarthur: yes
15:07:36 <mmorrow> (and it also does just do "split ','" ;)
15:07:43 <mmorrow> s/does/doesn't/
15:07:54 <jmcarthur_work> that reminds me. why are c2w and w2c not exported from a module that isn't a *.Internal? and why are there not any convenient String -> ByteString and ByteString -> String functions in the libs? :\
15:07:55 <mmorrow> which bytestring-csv does
15:08:07 <mmorrow> jmcarthur: yeah, they're definitely handay
15:08:17 <mauke> jmcarthur_work: pack?
15:08:26 <mmorrow> pack . fmap c2w
15:08:32 <mmorrow> fmap w2c . unpack
15:08:39 <mauke> no, just pack
15:08:42 <jmcarthur_work> i know, but there should be predefined functions for that
15:08:44 <mmorrow> if you use Char8..
15:08:47 <jmcarthur_work> mauke, no, mmorrow is right
15:08:49 <mauke> oh, right
15:08:49 <glguy> Data.ByteString.Char8 has the String -> ByteString
15:08:54 <mauke> I always use the Char8 variant
15:08:57 <FunctorSal> hmm one problem with qc is that for some binary operations the range of sensible arguments is way too thin.
15:09:00 <jmcarthur_work> ah
15:09:15 <glguy> better to treat strings as unicode (as intended!) and use utf8-string to convert in and out :)
15:09:18 <mmorrow> for some reason i don't like Char8 version
15:09:19 <FunctorSal> like testing a function that checks whether two substitutions are equivalent...
15:09:34 <jmcarthur_work> i've never used the Char8 version. didn't even know what it was or why it existed
15:09:36 <jmcarthur_work> now i get it
15:09:58 <augustss> there are too many bytestring variants
15:10:04 <jmcarthur_work> how does performance compare? any other pros/cons?
15:10:22 <glguy> augustss, the Char8 stuff is a different interface to the same type
15:10:23 <jmcarthur_work> besides the convenient representation, i mean
15:10:43 <jmcarthur_work> oh! that's nice then
15:10:49 <augustss> glguy: that doesn't make it any less annoying
15:11:00 <jmcarthur_work> nice-ish
15:11:06 <glguy> well... it makes it less annoying
15:11:25 <glguy> separate types would certainly be more annoying :)
15:11:29 <augustss> glguy: not if you like to write functions that work on any kind of bytestring
15:12:06 <glguy> augustss, the Data.ByteString.ByteString and Data.ByteString.Char8.ByteString are both re-exported Data.ByteSTring.Internal.ByteString
15:12:19 <jmcarthur_work> there is only strict and lazy, right?
15:12:21 <mmorrow> pumpkin: oh i didn't see your Q before.. yes ;)
15:12:28 <glguy> you mean you don't like the difference in Strict and Lazy ones?
15:12:34 * mmorrow just wanted to say "yes" again :)
15:12:46 <jmcarthur_work> would be nice if they were instances of a common type class
15:12:48 <pumpkin> very "yes"
15:13:29 <augustss> glguy: I think they should all exist, but I don't like the horrible way of switching between them etc.  It's a cry for a type class, or proper modules, or something.
15:15:14 <glguy> augustss, I agree that a type class would be nice for the various operations on lazy and strict bytestrings
15:15:23 <glguy> I had to make one up for use in the utf8 conversion code
15:15:25 <FunctorSal> why isn't there a class then?
15:15:39 <FunctorSal> surely the idea was there
15:15:53 * jmcarthur_work suddenly considers making a library to do this
15:17:43 <enolan> There's a Data.ListLike on hackage...
15:29:54 <ballard> hay guys
15:30:08 <ballard> hello?
15:30:29 <ballard> talk
15:30:35 <Vq^> hiya
15:30:36 <ballard> wtf
15:30:54 <ballard> can anyof you guys test a program i have been working on
15:31:10 <ballard> its in java so you dont have to instll or anything
15:31:21 <The-Kenny> ballard: This is #haskell.
15:31:25 <mux> yes, I'd have to install java.
15:31:30 <ballard> nsjhstech.com/beta
15:31:37 <ballard> you should have java
15:31:40 <Vq^> ballard: i would have to install Java
15:31:46 <mux> no I should not :-)
15:31:51 <Vq^> ballard: but we don't :P
15:32:05 <nlogax> 404 on that, too
15:32:09 <ballard> r u useing a irc client then
15:32:19 <ballard> i gave you the wrong link
15:32:29 <ballard> nsjhstech.com/beta1/jar
15:32:42 <ballard> nsjhstech.com/beta1.jar
15:32:51 <ballard> sorry my keyboard is actting up
15:33:12 <Vq^> ballard: you really should ask that somewhere else
15:33:22 <ballard> any idea where
15:33:30 <hackagebot> nemesis 2009.6.13.1 - a rake like task management tool (JinjingWang)
15:33:33 <Vq^> ballard: im sorry, but this isn't the optimal forum for java program testing
15:33:40 <Jedai> ballard: why exactly are you asking that on #haskell ?
15:33:45 <Vq^> ballard: i don't know
15:34:19 <ballard> i just need to know if  the program will work right on windows because i have only been testing it on mac
15:34:37 <Jedai> ballard: ask on #java if you must ask somewhere, but IRC doesn't seems a good media for this kind of demand to me...
15:35:16 <ballard> k
15:35:18 <ballard> thnx
15:35:34 <Vq^> ballard: that would require us to install Windows as well...
15:37:11 <CalJohn> Does ICFP normally charge for attendance registrations?  If so, how much?
15:37:52 <Zao> I find it interesting that random people on the internet expects people to run their applications without question.
15:40:29 <Twey> Java is too crappy to support my WM.
15:41:20 <Jedai> Zao: Well I don't think they're is that many of them (I hope so)
15:41:40 <Jedai> Zao: but that sure is a little bit surreal
15:41:49 <CalJohn> Twey: I think you're referring to a very long standing swing bug...?
15:42:01 <Twey> Yup
15:42:09 <Twey> But also that the VM segfaults when I apply the usual fix
15:42:22 <CalJohn> Twey: there is a one line hack in the JVM to make it work for icewm
15:42:41 <CalJohn> Twey: which is both depressing and useful information
15:42:43 <Twey> Not IceWM but xmonad/awesome3
15:42:51 <Twey> Different bug :)
15:43:31 <CalJohn> Twey: I think the bug we're talking about affects lots of light WMs, or am i confused
15:43:50 <Twey> I thought it only affected tiling WMs
15:44:04 <CalJohn> no, IIRC, fluxbox is hit also
15:44:08 <Twey> Something about AWT expecting the WM to be reparenting
15:44:23 <Twey> And there's an environmental fix
15:44:27 <CalJohn> i'm trying to find the bug report
15:44:28 <Twey> Or rather, workaround
15:44:36 <CalJohn> yeah, there are about three workarounds
15:44:37 <Twey> Which is to cause AWT to use the Motif backend
15:44:45 <CalJohn> http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6429775
15:44:54 <CalJohn> ^ That's what I'm talking about, at least
15:45:54 <CalJohn> the workaround being AWT_TOOLKIT=MToolkit
15:46:16 <Twey> That's the one, yeah
15:46:43 <Twey> Except that when I apply said workaround, all Swing apps segfault
15:47:22 <CalJohn> yeah, that workaround never worked for me either
15:47:31 <CalJohn> the trick is just to give up and use icewm
15:47:59 <Twey> Haha
15:48:12 <Twey> On my part, the trick is just to give up and not use Java ;)
15:48:36 <Twey> Although I guess SWT apps probably work
15:48:39 <CalJohn> there is a hack in the jvm which checks for icewm, and then makes it work.  I've asked sun to add extra hacks for other window managers, or perhaps even to support ICCCM
15:48:51 <CalJohn> the consider the bug fixed
15:48:54 <CalJohn> *they
15:49:10 <Zao> Isn't it fixed in 7?
15:49:27 <Baughn> Twey: Oh, hey..
15:49:29 <CalJohn> I haven't checked 7, IIRC they told me it was fixed in 6.  It isn't
15:49:34 <Baughn> Twey: Does that bug happen with xmonad too>
15:49:35 <Baughn> ?
15:50:30 <Twey> Baughn: Yeah
15:50:47 <Baughn> Twey: Figures. I was /wondering/ why webaom didn't work.
15:52:40 <Twey> Baughn: Try the fix â it might work.
15:52:47 <Baughn> Twey: Doesn't.
15:52:52 <Twey> Ah, okay.
15:56:17 <ehird> Is it possible to do e.g. class A; data B = Foo; then blah :: (A x) => x -> (), then blah Foo = ...?
15:56:24 <ehird> There's no type-systematical reason not to...
15:56:38 <ehird> Well, I guess pattern matching on fields could it. Hmph
16:02:33 <Twey> ehird: Is instance Foo A?
16:02:45 <ehird> Twey: instance A B, you mean. Yes.
16:02:53 <Twey> Er, yes
16:02:59 <Twey> Then yes, you can
16:03:09 <ehird> I would think it wouldn't work, as if you have (data B = Foo String), then the string isn't part of what you get as an (A x) => x.
16:03:17 <ehird> So you shouldn't be able to match on it. No?
16:03:34 <Twey> I think you can using an extension
16:03:43 <Twey> UndecidableInstances, was it?
16:04:01 <Twey> I may be completely wrong, but I seem to remember it allowing that
16:04:14 <ehird> That would be rather undesirable.
16:04:19 <Twey> It basically applies them in order of specificity
16:04:34 <ehird> Twey: what has that got to do with pattern matching?
16:04:39 <hackagebot> nemesis 2009.6.13.2 - a rake like task management tool (JinjingWang)
16:04:47 <Twey> So the concrete-type version is matched first, then the other
16:04:56 * FunctorSal is very frightened by the gtk2hs module list :-(
16:05:34 <ehird> /Users/ehird/Junk/test.hs:10:5:
16:05:35 <ehird>     Couldn't match expected type `x' against inferred type `B'
16:05:37 <ehird>       `x' is a rigid type variable bound by
16:05:39 <ehird>           the type signature for `foo' at /Users/ehird/Junk/test.hs:9:10
16:05:41 <ehird> Twey: that is with undecidable instances.
16:06:42 <FunctorSal> is it a law of nature that gui programming is necessarily painful?
16:08:06 <ehird> FunctorSal: Yes.
16:08:35 <mmorrow> jmcarthur_work, pumpkin: here's my CSV module vs. bytestring-csv on a 100,000 line file: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2724#a2726
16:08:52 <ehird> mmorrow: i parse 100,000 line csv files for breakfast
16:09:09 <mmorrow> ehird: i parse 1,000,000 line csvs for a snack ;)
16:09:26 <mmorrow> anyhow, bytestring-csv: 5.8 seconds, mine: 0.3 seconds :)
16:09:32 <ehird> oh yeah? well I parse 1,000,000 x 1,000,000 line CSV files every millisecond using a specialized FPGA.
16:09:41 <ehird> i'm going to move to an ASIC and then my own fabricator
16:09:45 <mmorrow> nu un!!
16:09:50 <mmorrow> s/un/uh/!!
16:09:51 <ehird> then I expect to be parsing about a trillion x billion CSV files every planck time
16:10:08 <ehird> maybe I could utilize Many Worlds to get everyone else to do the parsing for me.
16:10:19 <ehird> like, rent out slave universes.
16:10:22 <ehird> :)
16:10:26 <mmorrow> wow, you pulled out planck time.
16:10:29 <mmorrow> :)
16:10:40 <jmcarthur_work> mm_freak, dang very nice
16:10:58 * Baughn would just engineer a universe where CSV files always come pre-parsed
16:11:13 <Twey> FunctorSal: No, it's just that the non-painful kind is still heavily experimental :)
16:11:19 <ehird> mmorrow: i have a team of physicists working on how to harness the randomness of space in times shorter than that for CSV parsing.
16:11:30 <mm_freak> jmcarthur_work: i suppose you meant mmorrow =)
16:11:39 <ehird> we've got a prototype but it requires 5 hours of shaman magic rituals
16:11:45 <FunctorSal> Twey: FRP?
16:12:02 <Twey> I was thinking Eros :-P
16:12:30 <FunctorSal> I'm not even complaining about the IO, just the "long list is looooooong" effect
16:12:39 <FunctorSal> ;)
16:13:45 <jmcarthur_work> mm_freak, yes, sorry :$
16:13:46 <mmorrow> ehird: i don't know how you fit the physicists into a CSV, or how you can harness spacetime to parse them, but however you do it, i want in
16:13:57 <jmcarthur_work> (:$)
16:14:05 <jmcarthur_work> awesome operator
16:15:11 <mm_freak> somehow my favorite operator is still (>>=)
16:15:16 <jmcarthur_work> actually, that would be pretty awesome. type a :$ b = a b
16:15:22 <jmcarthur_work> if that is passable for ghc
16:15:28 <mm_freak> nope
16:15:31 <jmcarthur_work> :(
16:15:40 <mm_freak> operators starting with ':' are constructors
16:15:43 <Twey> Robot monkey operator
16:15:46 <jmcarthur_work> n/m then :\
16:15:46 <Twey> (:[])
16:15:48 <Twey> Can't beat it
16:16:07 <jmcarthur_work> um... that doesn't qualify as a psuedo type constructor?
16:16:21 <jmcarthur_work> type aliases start with capitals
16:16:35 <Twey> Certainly not, but we were comparing favourite operators :-P
16:17:05 <jmcarthur_work> i was talking to mm_freak about :$
16:19:35 <mm_freak> data Sad = I Sad Sad Sad | Am | Very | Sad | Life Sad | Sucks | (:/) Sad Sad
16:19:40 <mm_freak> sad = I Am Very Sad :/ Life Sucks
16:19:55 <jmcarthur_work> lol
16:20:39 <mm_freak> pointInThatType :: a
16:21:05 * jmcarthur_work is tempted to make an Arbitrary instance for that and see what happens
16:21:06 <FunctorSala> it neither has a point nor no point..
16:22:06 <uzytkownik> Should on haskell mailing list new project be announced after creation or making 0.0.1?
16:23:07 <lispy> uzytkownik: as soon as you feel ready to share with the world
16:23:59 <lispy> There is a GHC extension that allows type constructors to start with :
16:24:12 <lispy> I had a type constructor named :\/:
16:24:26 <lispy> and :/\:
16:24:40 <lispy> (still a constructor, just not a data constructor)
16:26:21 <FunctorSala> -XTypeOperators
16:26:29 <FunctorSala> ?
16:26:38 <Saizan> i'm not sure you need an extension for that
16:27:03 <Saizan> you need an extension for type variables like (~>) though
16:27:27 <ehird> In a Parsec parser, I do "foo `sepBy` bar". In foo, I want to get "all input" (which works out to everything before bar). Is there a parser for this?
16:27:28 <lispy> Saizan: data constructors starting with colon are H98, but not type constructors
16:28:18 <Saizan> ehird: (try (many anyChar)) ?
16:28:28 <ehird> Saizan: hm, why the try?
16:28:36 <ehird> also, that's a bit weird; feels like I'm doing this wrong :)
16:28:43 <ehird> ah, wait, n
16:28:44 <ehird> m
16:28:50 <jmcarthur_work> ehird, there is a function called upTil or something like that that parses many of one thing until it sees some other thing, i think
16:28:51 <Saizan> because it'll overlap with what bar parses
16:29:01 <ehird> right.
16:29:18 <ehird> jmcarthur_work: manyTill.
16:29:24 <jmcarthur_work> atsit
16:29:33 <jmcarthur_work> err, 'at'sit
16:29:38 <ehird> @hoogle many1 . oneOf
16:29:39 <lambdabot> Parse error:
16:29:39 <lambdabot>   --count=20 "many1 . oneOf"
16:29:39 <lambdabot>                    ^
16:29:42 <jmcarthur_work> that is a horrible contraction and i will never use it again
16:29:43 <ehird> meh.
16:29:47 <ehird> should have a name
16:29:52 <ehird> or at least many . oneOf
16:31:03 <ehird> :t noneOf
16:31:05 <lambdabot> Not in scope: `noneOf'
16:31:17 <ehird> should be a name for noneOf [a] too :-P
16:31:20 <ehird> notChar or sth
16:32:07 <Twey> noneOf exists
16:32:14 <Twey> And notFollowedBy
16:32:18 <lispy> ?hoogle noneOf
16:32:18 <lambdabot> Text.Parsec.Char noneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
16:32:18 <lambdabot> Text.ParserCombinators.Parsec.Char noneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
16:33:31 <ehird> I know noneOf exists
16:33:50 <lispy> that's cool, I was curious what the type was
16:37:10 <uzytkownik> lispy: Thanks
16:39:22 <ehird> @hoogle Parser a -> a -> a -> Parser a
16:39:22 <lambdabot> No results found
16:39:25 <ehird> hrm
16:39:28 <ehird> oh
16:39:30 <ehird> duh
16:41:31 <ehird> How do you load a cabal-install'd module into a ghci?
16:42:26 <pumpkin> just :m + Name.Of.Module
16:42:29 <pumpkin> it's already loaded
16:42:31 <pumpkin> sort of
16:42:46 <RayNbow> dcoutts: heh, edwardk also mentioned the CR line terminator on the reddit thread... :p
16:42:51 <The-Kenny> ehird: You have to restart ghci after you've installed a new module.
16:43:06 <ehird> The-Kenny: I did that.
16:43:10 <ehird> but it can't find parsec.
16:43:19 <ehird> -package parsec fails, to boot.
16:44:14 <pumpkin> is there an advantage to putting in a Setup.hs with the default main vs. no Setup.hs
16:44:37 <pumpkin> ?
16:44:48 <ehird> pumpkin: uh, 'runhaskell Setup.hs'?
16:44:56 <ehird> not everyone has cabal-install
16:45:06 <pumpkin> heh, that's their problem ;)
16:45:14 <pumpkin> if it's the default one, they can put it in themselves :D
16:47:21 <ehird> So, yeah, as far as I can tell ghci can't find cabal-installed modules.
16:47:46 <pumpkin> hmm, it's always worked for me
16:48:35 <ehird> :<
16:48:49 <ehird> ghc-pkg list doesn't show it; what does that mean?
16:48:52 <sm> someone here was working on an ofx parser recently.. are you around ?
16:49:30 * sm tests apple spotlight
16:51:32 <lispy> ehird: AFAIK, that means it isn't installed
16:51:46 <ehird> lispy: tell that to ~/.cabal; i have a bunch of stuff there
16:51:56 <ehird> it won't compile either now
16:52:49 <lispy> I don't have a machine to check on, but I thought that even cabal installed stuff (per user) still showed in ghc-pkg
16:53:04 <ehird> maybe i broke it when upgrading ghc a while back.
16:53:43 <Saizan> when you upgrade ghc you've to reinstall everything.
16:53:59 <Saizan> the fact that the files are still there under ~/.cabal doesn't mean much to ghc
16:54:35 <Saizan> especially since the .hi files are not compatible between different ghc versions
16:54:52 <bd_> the perils of aggressive cross-module inlining
16:55:39 <Saizan> and formats that easily change :)
17:00:37 <jeffwheeler> > do { (a+1) <- [1..5]; return a }
17:00:39 <lambdabot>   [0,1,2,3,4]
17:00:55 <jeffwheeler> How does that work?
17:01:41 <jeffwheeler> I think there might be an extension at play, because it seems to give a pattern match failure on my machine.
17:02:05 <jeffwheeler> Much more, I don't even understand how it could work . . .
17:02:20 <jeffwheeler> > do { (a+b+1) <- [1..5]; return (a, b) }
17:02:20 <Botje> jeffwheeler: n+k patterns
17:02:21 <lambdabot>   <no location info>: Parse error in pattern
17:02:35 <Botje> they're rarely used and most people here hate them.
17:02:53 <jeffwheeler> I did it by accident in my own code, and it compiled to my surprise.
17:02:56 <Botje> they were designed for stuff like fac (n+1) = (n+1) * fac n
17:03:18 <Botje> jeffwheeler: they work by binding n-1 to n in the body
17:03:21 <jeffwheeler> Oh, so it only works with +? Not *, etc.?
17:03:26 <Botje> not *
17:03:28 <Botje> not sure about -
17:03:38 <Botje> > let x-1 = 5 in x
17:03:40 <lambdabot>   x
17:03:44 <jeffwheeler> > do { (a*2) <- [1..5]; return (a) }
17:03:45 <lambdabot>   <no location info>: Parse error in pattern
17:04:02 <Botje> > let fac (x-1) = 5 in fac x
17:04:03 <lambdabot>   <no location info>: Parse error in pattern
17:04:04 <jeffwheeler> > do { (a-2) <- [1..5]; return a }
17:04:06 <lambdabot>   <no location info>: Parse error in pattern
17:04:14 <Botje> nope, only works for +
17:04:18 <jeffwheeler> Yeah . . .
17:04:20 <jeffwheeler> That's funky
17:05:49 <mm_freak> > let x-1 = 5 in 3 - 3
17:05:51 <lambdabot>   * Exception: <interactive>:1:153-159: Non-exhaustive patterns in function -
17:05:58 <mm_freak> > let x-1 = 5 in 3 - 1
17:06:00 <lambdabot>   5
17:06:42 <pumpkin> mm_freak: you like haskell and crypto, you should make a haskell implementation of the new general homomorphic encryption scheme :P
17:07:08 <gwern> n+k are a deprecated part of haskell. god willing, haskell' will get finished and kill n+k dead
17:07:40 <gwern> although come to think of it, haskell' was supposed to finish last year wasn't it...
17:08:18 <Saizan> haskell' has changed to a rolling release, no?
17:08:20 <mm_freak> pumpkin: though crypto is interesting, implementing it is extremely boring =)
17:08:39 <gwern> Saizan: rolling release would imply that something was getting done...
17:08:41 <mm_freak> ECC is interesting to implement, though
17:09:05 <Saizan> gwern: yup, they standardize extensions :)
17:10:06 <gwern> sometimes I understand why common lispers just stopped writing standards. they seem to be an invitation to holy wars and procrastination
17:13:20 <mm_freak> does anyone here write h98 code?
17:13:29 <mm_freak> i don't
17:13:36 <Saizan> Cabal hackers :)
17:13:54 <mm_freak> that's probably about it =)
17:14:01 <gwern> mm_freak: I usually do
17:14:11 <gwern> (because I don't understand most of the extensions)
17:14:52 <mm_freak> well, my code sometimes happen to be h98 and i don't use things like bang patterns
17:15:11 <mm_freak> but in most cases it ends up using extensions, especially multi-param type-classes
17:19:05 * sm finds jaredj's ofx parser.. kickass
17:25:02 <sm> ack.. how to work around http://hackage.haskell.org/trac/ghc/ticket/3121 and get readline installed on a mac ?
17:41:51 <FunctorSal> @quote haskell98
17:41:52 <lambdabot> No quotes match. Sorry.
17:41:54 <FunctorSal> @quote haskell 98
17:41:55 <lambdabot> No quotes for this person. Wrong!  You cheating scum!
17:42:02 <FunctorSal> @find haskell98
17:42:04 <lambdabot> Not in scope: type variable `haskell98'
17:42:07 <FunctorSal> sigh
17:42:16 <shepheb> @quote haskell.98
17:42:16 <lambdabot> glguy says: map became not overloaded in the great polymorphic scare of haskell 98
17:42:26 <FunctorSal> thanks shepheb
17:42:37 <shepheb> FunctorSal: you can fake a space using .
17:44:36 <FunctorSal> @quote haskell.98
17:44:36 <lambdabot> Cale says: Oleg can bend spoons with his mind, in the type system, in Haskell 98.
17:45:40 <Saizan> so the spoons are actually there in the type system?
17:47:21 <Botje> data Spoon
17:47:29 <Botje> see?!
17:47:42 <Botje> there IS no spoon (you can evaluate)
17:56:31 * pumpkin munches on solidsnack
17:56:58 <solidsnack> Snack! Snack?! Snaaaaaaaaa....
17:57:08 <pumpkin> lol
17:57:15 * pumpkin is sad that he got that
17:57:36 <solidsnack> I'm glad that everyone gets my nick, though.
17:57:48 <solidsnack> It was hard to find a funny one.
17:58:09 <solidsnack> No, brother!
17:58:18 <liquidsnack> muahahahaha
18:00:27 <solidsnack> pumpkin: So what do you think about implementing stackable streams with coroutines?
18:01:59 <pumpkin> beats me :) I'm busy moving to a new apartment
18:03:06 <Saizan> solidsnack: have you worked out the types?
18:03:57 <solidsnack> Saizan: Well, I think you need two. Something like `Box m a` and `Program m a b`.
18:04:32 <solidsnack> I've worked on streams a little bit where I was able to do many to one with those types; however, one to many is a problem.
18:04:44 <solidsnack> So I think there's a need for `yield` and all that.
18:05:22 <Saizan> many to one you mean producers vs. consumers?
18:06:07 <solidsnack> I mean, take a stream of UTF-8 chars and produce several bytes for each one.
18:06:39 <Saizan> ah, i see
18:06:55 <solidsnack> The note marked `2009-05-07T21:58:22Z` is where I got with the many-to-one approach, using return to yield the one. http://github.com/jsnx/streams/blob/9a6bc39dff5d95eebfdc173a38f60a8e353f0602/notes/Journal
18:07:23 <Saizan> i think i've seen an implementation of coroutines floating around on -cafe using a limited form of session types?
18:07:32 <solidsnack> Yes, I've seen that.
18:08:28 <solidsnack> I'm not sure what session types are about.
18:08:33 <Jedai> solidsnack: it's not exactly stream but did you look at the iteratee approach ?
18:08:42 <solidsnack> I've seen that, yeah.
18:08:46 <solidsnack> It seems too powerful.
18:08:53 <Jedai> it seems quite flexible
18:09:13 <solidsnack> That's a vague critique, I guess.
18:09:30 <solidsnack> Also, it's chunked and that annoys me (little aesthetic thing).
18:09:36 <Jedai> solidsnack: I agree that it may be too flexible for your needs (their documentation needs more examples !!! ^^)
18:09:47 <solidsnack> You should be forced to pull each new item.
18:10:09 <solidsnack> If you need more items you should explicitly ask for more, &c.
18:10:48 <Saizan> i think they assume being chunked is important for reasonable performance
18:11:18 <solidsnack> It's not of much interest to me to disparage other people's work, though.
18:11:52 <Jedai> Saizan: since their objective seems to be "excellent performance with the safest interface", it makes sense in their perspective I guess
18:12:27 <Jedai> Saizan: composability appears to be important for them too
18:13:03 <Jedai> It's interesting but the interface is pretty daunting, maybe there's a nice tutorial somewhere ?
18:13:47 <Saizan> the notes from the talk have quite a few examples
18:15:41 <Saizan> solidsnack: how'd you describe the Program monad?
18:20:43 <solidsnack> Monadic values transform an operation in the underlying monad.
18:21:01 <solidsnack> s/Monadic values/Monadic values in the Program monad/
18:22:14 <solidsnack> Saizan: You build up values in the Program monad with `next` and `return`, right now. To get coroutines I need to add `yield` and figure out something else to do with `return`.
18:22:26 <mmorrow> solidsnack: with the various "iteratees" implems, you can usually bail whenever you want
18:22:44 <solidsnack> So also with coroutines, though.
18:22:50 <mmorrow> it's like a foldl, but with a type (or something equivalent):
18:23:06 <mmorrow> foldl :: (a -> b -> Either a a) -> a -> f b -> a
18:23:24 <mmorrow> where f b is e.g. {Handle,Socket,i dunno}
18:24:02 <mmorrow> (and Left means bail)
18:24:03 <solidsnack> <_< >_>
18:24:50 <solidsnack> It seems that coroutines are actually perfect for streamable containers, now that I've thought about it for a few months.
18:25:19 <mmorrow> solidsnack: i messed around with a coroutines thing here though http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5308
18:26:11 <solidsnack> mmorrow: Thank you, I'll check that out.
18:26:49 <mmorrow> the Ref holding the continuation could probably be done another way (being held somehow in the state of the monad), but because everything is like 2*infinite type your head asplodes hearing the massive lecture the type checker spews at you when you try :)
18:27:20 * mmorrow has tried that, and his head asplode
18:27:48 <mmorrow> also, the newtypes are probably not very well named
18:28:40 <mmorrow> so i think some explanation is in order, because i have trouble figuring out wtf it's doing and i wrote it :) :
18:30:23 <mmorrow> so first at the base level it's using (1) a flattened (StateT s (Cont r) a), and (2) the monadLib `Label', which lets you snag the continuation `k' in a callCC
18:31:04 <mmorrow> , runCont id (do (a,lbl) <- labelCC; when (a < 100) (jumpCC lbl (a+1)); return a)
18:31:05 <lunabot>  luna: Not in scope: `jumpCC'
18:31:08 <mmorrow> , jump
18:31:10 <lunabot>  luna: No instance for (GHC.Show.Show (a -> MonadLib.Label m a -> m b))
18:31:14 <mmorrow> , runCont id (do (a,lbl) <- labelCC; when (a < 100) (jump lbl (a+1)); return a)
18:31:15 <lunabot>  luna: Couldn't match expected type `MonadLib.Monads.Cont a a'
18:31:27 <mmorrow> , runCont id (do (a,lbl) <- labelCC; when (a < 100) (jump (a+1) lbl); return a)
18:31:28 <lunabot>  luna: Couldn't match expected type `MonadLib.Monads.Cont a a'
18:31:31 <mmorrow> argg
18:31:43 <mmorrow> , runCont id (do (a,lbl) <- labelCC 0; when (a < 100) (jump (a+1) lbl); return a)
18:31:44 <lunabot>  100
18:32:43 <mmorrow> so then it uses an IORef, newtyped in Ref, to hold the `Lbl' of the other half of the coroutine, when one particular side's in control
18:33:41 <mmorrow> `labelCC' (call `label' in mine) is similar to C setjmp, in that it can "return more than once", each time with a diff value
18:34:21 <mmorrow> a `Gen' if an IORef (Maybe (Lbl (Mut ....)))
18:34:51 <mmorrow> and a `Mut' is a Label that you can return a
18:35:08 <mmorrow> (Maybe inn, Maybe (mirror image Mut))
18:35:27 <mmorrow> and that mirror image Mut is a Label that you can return a
18:35:43 <mmorrow> (Maybe out, Maybe (mirror image Mut))
18:35:45 <mmorrow> through
18:36:05 <mmorrow> (err, sorrt, those a Labels that you can return a *Maybe* (...) though
18:36:12 <mmorrow> *sorry
18:36:33 <mmorrow> so finally, what `create' does is
18:37:26 <mmorrow> (1) (m, (lbl::Lbl o s (Maybe (...)) ) <- label Nothing
18:37:35 <mmorrow> where that `lbl' is the contents of a Mut
18:38:12 <mmorrow> then it cases on m, which is Nothing if this is the first go-around, *but* (and this is the key)
18:39:10 <mmorrow> it's (Just (innm,mmut)) if this is happening ===> after the Nothing case already happened, that result got returned, and someone eventually yielded to this `Gen'
18:39:47 <mmorrow> and the value they yielded is `innm', and *their* mirror image `Mut' is `mmut' (Just (innm,mmut))
18:40:29 <mmorrow> so then create finally build the mirror image of *that* mirror image, and hands that to the function in the `Coro' create got passed, tying the knot
18:41:01 <mmorrow> at this point, i have no friggin idea how to modify this to not use the IORef :)
18:42:41 <mmorrow> well, no friggin idea how to modify it at all really, since the entire thing is essentially one mutually-recursive knot, and touching anything ripples through everything else
18:45:18 <mmorrow> hah
18:45:20 <mmorrow> :)
18:45:59 * mmorrow didn't solidsnack was gone :)
18:46:04 <mmorrow> *didn't know
18:46:39 <solidsnack> Dear, I missed something.
18:46:42 <solidsnack> I will read the logs.
18:47:36 <mmorrow> i should write that up anyways, because i think what that module's doing is pretty opaque even if you know what it's doing already
18:50:51 <solidsnack> I'm reading it; it is a bit dense.
18:51:24 <mmorrow> solidsnack: yeah, re-reading that over, i think i only understand it because i already understand it
18:51:46 * mmorrow will write an explanation of that module and put it somewhere
18:53:53 <mmorrow> i wish there was an easy way to draw pictures/diagrams free-hand directly to a digital image. i need to get a tablet thingy or something
18:58:02 <dmwit> A scanner or digital camera is often nearly as good as a tablet.
18:58:06 <dmwit> (For non-artists.)
18:58:08 <solrize_> @seen roconnor
18:58:08 <lambdabot> roconnor is in #haskell-blah and #haskell. I last heard roconnor speak 5h 45m 20s ago.
18:58:21 <mmorrow> dmwit: yeah, that'd be way easier too
19:00:23 <hackagebot> http-server 1 - A library fro writing Haskell web servers. (IavorDiatchki)
19:04:24 <hackagebot> pretty-show 1 - Tools for working with derived Show instances. (IavorDiatchki)
19:20:59 <malouin> function to get unique items in a list?
19:21:02 <dmwit> nub
19:21:04 <solrize_> nub
19:21:19 <FunctorSal> nub
19:21:20 <dmwit> fromList . toList -- from Data.Set
19:21:25 <dmwit> err
19:21:29 <dmwit> toList . fromList
19:22:57 <malouin> The name nub means `essence'?
19:23:25 <dmwit> right
19:23:42 <solrize_> "the nub of the matter" = common idiom
19:23:50 <malouin> huh, never heard that.
19:24:04 * FunctorSal neither
19:24:06 <solrize_> i guessed maybe english is not your native language
19:24:11 <FunctorSal> nop
19:25:37 <malouin> well it is mine, so I have no excuse.
19:27:05 <solrize_> i guess it is a britishism if that matters.  not that i'm british
19:27:39 <FunctorSal> shouldn't process be in hoogle?
19:40:21 <FunctorSal> will terminateProcess send signal 9 on linux?
19:40:39 <hydo> If anyone is doing the ICFP contest and needs more people, I'd love to help out even though my Haskell is still in the beginner stage.  I would, of course, be willing to do anything that needed to be done.  Just thought I'd throw that out there.
19:40:54 <dmwit> FunctorSal: I would guess there's separate functions for sigint and sigkill.
19:41:02 <dmwit> FunctorSal: Though I don't know off the top of my head which is which.
19:41:24 <FunctorSal> dmwit: probably in the posix.* hierarchy, but terminateProcess is os-agnostic
19:41:42 <dmwit> aha
19:42:07 <malouin> ICFP contest, eh? damn, that sounds like fun...
19:42:21 <dmwit> FunctorSal: According to the docs, "On Unix systems, terminateProcess sends the process the SIGTERM signal."
19:42:29 <dmwit> So no, not signal 9.
19:42:37 <FunctorSal>     return (kill(handle, SIGTERM) == 0);
19:42:39 <FunctorSal> right
19:42:39 <malouin> probably way out of my league though.
19:43:28 <FunctorSal> dmwit: weird. this one says SIGKILL http://hackage.haskell.org/packages/archive/process/1.0.1.1/doc/html/System-Process.html#t%3AProcessHandle
19:43:57 <dmwit> FunctorSal: It wouldn't surprise me over much if it has changed between versions. =)
19:44:25 <dmwit> Although the two pages I'm looking at have the same version number up top.
19:44:30 <dmwit> So *that* part is definitely weird.
19:44:42 <FunctorSal> dmwit: that line from the c source comes from the "cabal unpack"'ed version
19:44:53 <FunctorSal> but that is 1.0.1.1
19:44:57 <dmwit> Well, trust the source you're using.
19:45:14 <dmwit> Always trust the source over the docs, it's rule number one of software development. =)
19:45:20 <FunctorSal> ok :)
19:50:00 <FunctorSal> meh. the target process just gets zombified ;)
19:51:38 <FunctorSal> nvm, the zombies are from previous runs where I didn't terminate the child process at all
19:52:56 <jeff_s_> I have to admit, it seems lame to target MSIL, but it opens up so many possibilities for what could done with haskell http://www.cin.ufpe.br/~haskell/haskelldotnet/
19:54:01 <FunctorSal> jeff_s_: how so? don't you still need to get people to allow you to code in haskell? ;)
19:54:34 <FunctorSal> (assuming you are referring to work-related possiblities)
19:54:38 <jeff_s_> poor, poor corporate souls
19:54:49 <ray> you don't need to apologize, i'll protect you from the linux zombies
19:55:04 * jeff_s_ huddles behind ray
19:55:07 <mgsloan> I'd probably just use F# for functional on .net
19:55:13 <FunctorSal> I meant no offense :(
19:55:28 <FunctorSal> I just presumed you wouldn't go from haskell to .net for fun ;)
19:56:02 <erikc> f# is gonna be great for ppl stuck on .net
19:56:08 <ray> i wish that project weren't deader than
19:56:10 <ray> something dead
19:56:19 <ray> i'd like haskell .NET
19:56:24 <jeff_s_> Plan: code in haskell. when coworkers or whatever want your source, decompile it to c# http://www.remotesoft.com/salamander/index.html
19:56:39 <erikc> the vstudio f# integration is so good, the 2010 beta so hot
19:56:44 <jeff_s_> f# is ok, no modules though? Sheesh
19:57:22 <sclv> the dotnet bridge is awesome
19:57:26 <FunctorSal> I thought the issue was more that employers are afraid they won't find coders for haskell, not .net compatibility
19:57:26 <sclv> if you don't need superfast foreign calls, its very simple.
19:57:38 <ray> it theoretically doesn't matter if you target MSIL
19:57:51 <jeff_s_> though, do generics in .NET let you do something like haskell's fmap in f#?
19:58:10 <jmcarthur> yeah really. they don't want me using haskell at work because nobody else their knows it :\
19:58:12 <jeff_s_> When I learned about fmap, I thought about how to make it work in ocaml, and my head exploded.
19:58:45 <erikc> jeff_s_: hrm, dunno, i havent experimented much with mixing generics and f# code
19:58:56 <sclv> fmap seems easy in ocaml or f#
19:59:22 <erikc> im just loving it cause i get to leverage all the .net code out there + step between languages in the debugger + intellisense
19:59:26 <sclv> on the face of it at least
19:59:45 <dibblego> jeff_s_, no, F# does not have higher kinds
19:59:56 <jeff_s_> damn :(
20:00:09 <jeff_s_> sclv - if you can do fmap in caml, I'll give you the prize
20:01:10 <sclv> surely with functors and/or objects it should be feasible?
20:01:32 <sclv> after all ocaml modules and typeclasses have a demonstrated equivalence.
20:01:58 <jeff_s_> module SMap = Set.Make (String)
20:01:58 <jeff_s_> module IntMap = Set.Make (struct type t = int let compare = Pervasives.compare end)
20:02:38 <jeff_s_> now if I have a function g that maps strings to ints, I need a polymorphic function fmap so that I can do "fmap g someStringSet" and get a set of ints
20:02:44 <Apocalisp> Wait, seriously? F# has no way to abstract over type constructors?
20:02:59 <dibblego> seriously truly
20:03:28 <Apocalisp> That would make it kind of pointless, innit?
20:03:33 <jeff_s_> apoc - I assume you're supposed to use the object system or something. it doesn't have a module system, so no Set.Make (String)
20:03:37 <dibblego> pretty much :)
20:03:50 <dibblego> it's just a shinier C#
20:04:23 <Apocalisp> That makes me sad.
20:04:26 <sclv> the guys at cs say they've had good results using object polymorphism in place of typeclasses tho.
20:05:07 <dibblego> we've had bad results (what I expect they're calling good results) -- we just have higher standards
20:06:15 <sclv> heh. no doubt. their main constraint is the need for fast calls to existing dlls
20:12:49 <jeff_s_> what do you guys think about Clean?
20:14:30 <gwern> jeff_s_: what do you mean? it's fast, but it has next to no community, with all that implies
20:16:18 <jeff_s_> I was just looking at langauges related to Haskell and Clean was the only one that seemed mature. Just idle curiousity.
20:16:39 <chromakode> is there any way to make a "filter" strict?
20:17:22 <jeff_s_> what soft of filter? what do you mean by strict?
20:17:56 <jeff_s_> er, I thought this was the ocaml room, my bad. I probably won't be any help if that was a technical question.
20:18:04 <chromakode> ah, heh, no problem.
20:18:10 <chromakode> I'm doing some retainer profiling and see that a filter on a list is leaking space. I'm wondering if there's an easy way to make the filter strict
20:18:31 <sclv> ?src filter
20:18:32 <lambdabot> filter _ []     = []
20:18:32 <lambdabot> filter p (x:xs)
20:18:32 <lambdabot>     | p x       = x : filter p xs
20:18:32 <lambdabot>     | otherwise = filter p xs
20:18:47 <chromakode> making the result of the filter head-strict (using a bang) seems to help a lot
20:18:53 <chromakode> should I just define a filter'?
20:19:06 <sclv> chromakode: are you using -O?
20:19:11 <chromakode> sclv: -O2
20:19:21 <chromakode> with -funbox-strict-fields
20:19:41 <sclv> i'd think fusion rules would be a big help...
20:20:05 <chromakode> well, it's filtering the forest of a Data.Tree, and I know that every node will be used
20:20:08 <chromakode> so it might as well be made strict
20:20:34 <sclv> if head strictness is a help tho, it sounds like the expression containing the filter is what you're worried about, not the filter itself.
20:20:53 <chromakode> hmm. I put some cost centers in there and they didn't show the subexpressions using space
20:21:04 <chromakode> the filter itself is retaining memory
20:21:40 <chromakode> here's the line:
20:21:46 <sclv> you mean that the expression "filter pred [something]" holds onto the whole [something], i think.
20:21:52 <chromakode> !trimmedForest = filter (\(Node (Evaluated s _) _) -> maxScore - s <= scoreRange) forest
20:22:10 <chromakode> hm, I'll throw a cost center around forest
20:22:37 <sclv> this isn't an issue about the filter itself, its an issue about the filter expression not being evaluated...
20:22:56 <chromakode> well, it should be evaluated, since I put a bang before it, right?
20:23:01 <chromakode> hm.
20:23:24 <sclv> oh... i see what you mean, sorry i'm a bit slow.
20:23:43 <chromakode> nono, thanks for your time.
20:23:46 <lispy> when you put the bang in front of trimmedForest, I think that just forces the first cons
20:23:51 <sclv> the easiest thing is just to use rnf
20:23:52 <lispy> Not the list element?
20:24:25 <chromakode> lispy: exactly
20:24:29 <chromakode> okay, I'll try throwing rnf in there
20:24:34 <sclv> or to force just the filter, to do let x = filterexpression in length x `seq` x
20:24:35 <lispy> So, I wonder if the thing constructing forest is costly
20:25:04 <chromakode> lispy: it is indeed costly, but I'm looking at the retainer profiling
20:25:57 <lispy> This is not something I know much about, but it seems to me that if forcing the first cons after the filter makes a difference, then the filter is not needed to see an improvement, eg., !forest, should give you the same improvement?
20:26:24 <chromakode> just a sec, I'll try that.
20:26:36 <chromakode> nope, the rascal is still there
20:26:43 <lispy> Interesting
20:26:45 <chromakode> my hunch is it's just waiting to filter too long
20:26:50 <lispy> I wonder how GHC implements filter
20:27:06 <chromakode> rnf seems like a last ditch, but I'm trying it
20:27:30 <lispy> http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-List.html#filter
20:27:38 <lispy> sees to match what ?src gives
20:28:11 <lispy> oh, except they have rules
20:28:48 <lispy> notice how filter can get turned into a foldr
20:28:58 <lispy> chromakode: is it possible to try -O instead of -O2?
20:29:04 <chromakode> sure.
20:29:37 <chromakode> no dice.
20:29:44 <lispy> You could also try replacing filter with [ x | x <- xs, p x]
20:29:55 <chromakode> hmm, I think that'd be lazy as well
20:29:55 <chromakode> how do I use rnf?
20:30:21 <lispy> I suspect the problem is a bad optimization
20:30:34 <lispy> ?hoogle rnf
20:30:34 <lambdabot> Control.Parallel.Strategies rnf :: NFData a => Strategy a
20:30:41 <chromakode> ?hoogle using
20:30:42 <lambdabot> Control.Parallel.Strategies using :: a -> Strategy a -> a
20:30:49 <chromakode> so blah using rnf, hmm
20:32:21 <malouin> Aaahhh fmap is my new best friend!!!
20:32:56 <malouin> it is saving me from the hell I created for myself by pervasively mixing [] and Maybe
20:33:00 <lispy> > (+1) `fmap` (*2) $ 2
20:33:01 <lambdabot>   5
20:33:11 <malouin> > fmap (+1) Nothing
20:33:12 <lambdabot>   Nothing
20:33:16 <malouin> this is so awesome.
20:33:44 <dibblego> wait until you see >>= !
20:33:56 <chromakode> I'm going to implement a strict filter and try that.
20:34:29 <chromakode> oh, hm.
20:35:53 <chromakode> oho! sclv's length trick worked!
20:35:57 <lispy> filter _ xs | length xs `seq` False = undefined; ...
20:36:27 <chromakode> did sclv leave?
20:36:33 <lispy> no
20:36:42 <lispy> Well, maybe afk
20:36:52 <chromakode> ah, I see, I think my IRC client tab complete was corrupted
20:36:53 <malouin> dibblego: somehow I have not yet become one with applying >>= to good effect in the maybe monad.
20:37:06 <lispy> chromakode: I don't get how filter is a problem unless forest is also a problem
20:37:19 <malouin> dibblego: probably because most of my Maybe stuff is actually MyReaderTIO (Maybe a)
20:37:20 <chromakode> lispy: the filters are happening in a huge tree
20:37:38 <chromakode> lispy: the tree gets built up and the filters don't fully execute, leaving thunks in the tree structure until they're evaluated
20:37:45 <malouin> but when it clicks, I'm sure the experience will be transcendental.
20:38:02 <dibblego> malouin, you've been using monad transformers but are unfamiliar with >>=
20:38:03 <dibblego> ?
20:38:52 <malouin> dibblego: oh I get >>=
20:39:13 <malouin> and I understand what it does with Maybe, but I haven't used it in slick ways yet.
20:39:22 <malouin> fmap I have found slick ways of using.
20:39:22 <dibblego> mk
20:39:49 <malouin> I'm still pretty light on understanding of monad transformers.
20:40:04 <lispy> chromakode: so then also redefining filter so that it is p $! x, should help equally?
20:40:17 <chromakode> lispy: that's my hunch
20:40:21 <lispy> chromakode: if so, I wonder if that should be a library proposal
20:40:25 <chromakode> just a sec, testing.
20:40:35 <chromakode> maybe that function is lingering somewhere and we just don't know its name.
20:40:56 <lispy> ?hoogle filter'
20:40:56 <lambdabot> No results found
20:41:01 <lispy> ?hoogle filter
20:41:01 <lambdabot> Prelude filter :: (a -> Bool) -> [a] -> [a]
20:41:01 <lambdabot> Data.ByteString filter :: (Word8 -> Bool) -> ByteString -> ByteString
20:41:01 <lambdabot> Data.IntMap filter :: (a -> Bool) -> IntMap a -> IntMap a
20:41:29 <lispy> chromakode: no I think this is worthy of sending your findings (and as muh sample code as you can spare) to haskell-cafe
20:41:47 <chromakode> lispy: huh! the p $! x doesn't fully take care of the problem
20:41:52 <lispy> I bet there is a library tweak hiding here, either as filter' or filter
20:42:08 <lispy> chromakode: well hmm
20:43:00 <chromakode> perplexing.
20:43:49 <lispy> It really seems that everything that creates a thunk in a lazy way has the potential to have a strict version
20:44:10 <chromakode> yeah, that's something I've been thinking about lately
20:44:23 <chromakode> there should be a syntax annotation that tells the compiler to "make this deeply strict"
20:44:45 <lispy> bangs help in many cases
20:45:06 <chromakode> lispy: I think what's happening now is that even though we're strictly evaling the predicate, the elements of the resulting list still aren't being evaled
20:45:16 <lispy> But, what gets me is the proliferation of strict additions to the library
20:45:18 <chromakode> filter' _ []     = []
20:45:18 <chromakode> filter' p (x:xs)
20:45:18 <chromakode>     | p $! x    = x : filter p xs
20:45:18 <chromakode>     | otherwise = filter p xs
20:45:23 <chromakode> yeah
20:46:10 <chromakode> ! if I add in the length now, with this new filter', there's still a leak
20:46:18 <chromakode> but if I add in the length with the core filter, there's no leak
20:47:09 <chromakode> but the retainer is elsewhere -- ah, got it
20:47:28 <lispy> where?
20:48:47 <chromakode> oddly enough, in the part that gets the forest *below* the nodes in the current forest
20:49:16 <chromakode> this is bizarre.
20:49:53 <lispy> I need to go, good luck!
20:49:57 <chromakode> alright
20:50:00 <chromakode> thanks for the ideas! :)
20:50:09 <lispy> don't be afraid to mail the -cafe
20:50:20 <chromakode> alrighty, thanks.
20:50:21 <malouin> [Maybe a] -> [a]?
20:50:41 <chromakode> :hoogle maybeToList
20:50:46 <malouin> ok nm
20:50:53 <sclv> ?hoogle [Maybe a] -> [a]
20:50:54 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
20:50:54 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
20:50:54 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
20:50:58 <chromakode> ?hoogle catMaybes
20:50:58 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
20:51:06 <malouin> catMaybes is it, I just didn't see it.
20:51:10 <chromakode> :)
20:51:15 <malouin> thanks!
20:54:44 <chromakode> well, at least my space problems are gone now -- even though I don't understand why they were happening. thanks very much for the help, sclv.
20:56:01 <sclv> no prob :-)
21:09:51 <flice> lilac: http://en.wikipedia.org/wiki/Interval_tree
21:27:26 <Petalon> Ello. I'm wanting to generate random IQ scores as a normal distribution with a mean of 100 and a standard deviation of 15.
21:27:50 <Cale> Petalon: okay
21:28:02 <Petalon> Is there something in Haskell that will generate random numbers with a normal distribution?
21:28:34 <Axman6> @hoogle normal
21:28:34 <lambdabot> Distribution.Verbosity normal :: Verbosity
21:28:35 <lambdabot> Language.Haskell.TH NormalB :: Exp -> Body
21:28:35 <lambdabot> Language.Haskell.TH.Syntax NormalB :: Exp -> Body
21:28:36 <FunctorSala> wth... this runInteractiveProcess pipe works fine against inetutils-ping, but the handle never becomes ready against iputils-ping
21:28:44 <Cale> I'm not sure, but it shouldn't be too hard to write something which generates random numbers according to an arbitrary CDF.
21:28:44 <Axman6> @more
21:28:50 <FunctorSala> (debian nomenclature)
21:28:58 <Axman6> @hoogle+
21:28:58 <lambdabot> Language.Haskell.TH normalB :: ExpQ -> BodyQ
21:28:58 <lambdabot> Language.Haskell.TH.Lib normalB :: ExpQ -> BodyQ
21:28:58 <lambdabot> Language.Haskell.TH NormalC :: Name -> [StrictType] -> Con
21:29:01 <Axman6> @hoogle+
21:29:01 <lambdabot> Language.Haskell.TH.Syntax NormalC :: Name -> [StrictType] -> Con
21:29:01 <lambdabot> Language.Haskell.TH normalC :: Name -> [StrictTypeQ] -> ConQ
21:29:01 <lambdabot> Language.Haskell.TH.Lib normalC :: Name -> [StrictTypeQ] -> ConQ
21:29:04 <Axman6> argh
21:29:09 <Cale> eh?
21:29:26 <Cale> I don't think there's anything for it in the standard libraries...
21:29:43 <Axman6> :\
21:29:46 <Petalon> Well, I'd the CDF, then.
21:30:19 <Cale> It seems hmatrix (a binding to the GSL) has erf
21:30:28 <Cale> http://hackage.haskell.org/packages/archive/hmatrix/0.5.2.1/doc/html/Numeric-GSL-Special-Erf.html
21:31:10 <Cale> http://hackage.haskell.org/packages/archive/gsl-random/0.3.1/doc/html/GSL-Random-Dist.html#v%3AgetGaussian
21:31:13 <Cale> oh hey :)
21:32:06 <Cale> Not the most abstract wrapper around the C GSL library possible.
21:32:10 <Cale> But it's something
21:32:31 <FunctorSala> btw I think you need the inverse of the CDF
21:32:48 <Cale> FunctorSala: mm?
21:33:03 <FunctorSala> for generating random numbers, given a uniform RNG
21:33:12 <Cale> hmm...
21:33:17 <Cale> oh, right
21:33:22 <Petalon> How do I get one of those packages?
21:33:37 <Cale> Petalon: If you have cabal-install, it's just  cabal install <packagename>
21:33:52 <Cale> If you don't, then it's probably easiest to install it first
21:34:04 <Cale> http://hackage.haskell.org/packages/archive/cabal-install/0.6.2/cabal-install-0.6.2.tar.gz
21:34:44 <Cale> You'll find a bootstrap.sh in there which you can run to install it (hopefully)
21:35:01 <Cale> If you're on windows, I think there's a different package.
21:35:27 <Cale> http://www.haskell.org/cabal/release/cabal-install-0.6.2/cabal.exe
21:36:24 <FunctorSala> hmm inverse doesn't seem right either... I blame the time of day ;)
21:36:36 <byorgey> there's http://hackage.haskell.org/package/ProbabilityMonads
21:36:57 <byorgey> ah, even better, http://hackage.haskell.org/package/probability
21:41:04 <Cale> Oy, a Henning Thielemann library.
21:41:25 <Cale> Every type is called T and every class is called C
21:42:05 * Petalon successfully installs Parsec, then successfully installs Network, and hopes to successfully install cabal.
21:42:18 <Cale> hmm
21:43:39 <Cale> I should fix it and upload a probability-sane package ;)
21:43:54 <Petalon> Hmm, I'm missing "mtl -any".
21:44:06 <Cale> Petalon: Where did you get your copy of GHC?
21:44:35 <Cale> Petalon: Some distributions rip it apart into lots of smaller packages for some reason.
21:44:56 <Cale> Petalon: I usually recommend just installing the generic binary available on the GHC website.
21:45:18 <Cale> But you might also find that your distribution has a libghc6-mtl-dev package or something :)
21:45:52 <sclv_> any recommendations for a definitive approach to combining parametric polymorphism and subtyping?
21:46:07 <dmwit> When I was on Ubuntu, I always installed libghc6-*-dev, it makes lots of things easier and isn't that hard on the ol' hard drive.
21:46:24 <Cale> I just uninstall ubuntu's version.
21:46:35 <dmwit> That works, too.
21:46:35 <Cale> It's perpetually out-of-date anyway
21:46:40 <Axman6> whenever i use ubuntu... i cry
21:47:16 <dmwit> That seems silly.
21:47:22 * Petalon does what dmwit did.
21:48:21 <Cale> Ubuntu always releases a new version just before GHC does.
21:49:41 <Cale> So they're always a major version behind. Even jaunty seems to still be on 6.8.2, not even 6.8.3
21:52:20 <Petalon> Do they both have schedules for release?
21:52:25 <Cale> yeah
21:53:05 <Cale> Well, GHC's is a bit more lax
21:53:43 <Cale> But it seems to line up pretty well with a couple weeks to a month after each Ubuntu release.
21:57:31 <FunctorSala> if a handle is line-buffered and hReady returns true, is hGetLine guaranteed not to block?
22:03:00 <Cale> I would certainly *hope* that's the case
22:03:31 <dmwit> I could easily imagine it not being the case.
22:03:46 <dmwit> hReady only guarantees that "at least one item is available for input".
22:03:53 <dmwit> ...without saying what an "item" is.
22:07:32 <Cale> on my machine, it behaves properly
22:07:49 * Petalon successfully installs cabal.
22:07:58 <Cale> (that is if it's set to line buffering, hReady only returns True once there is a whole line
22:08:00 <Cale> )
22:08:07 * byorgey high-fives Petalon 
22:08:13 <byorgey> now you are home free!
22:09:11 <Petalon> cabal: Package gsl-random-0.3.1 can't be built on this system.
22:09:11 <Petalon> cabal: Error: some packages failed to install:
22:09:11 <Petalon> gsl-random-0.3.1 failed during the building phase. The exception was:
22:09:12 <Petalon> exit: ExitFailure 1
22:09:39 <Petalon> Oh no, 1 happened. We never learned in computer class what to do when 1 happens! :-P
22:09:48 <byorgey> hehe =)
22:09:56 <byorgey> is gsl-random some bindings to another library?
22:10:01 <Cale> yes
22:10:10 <byorgey> sometimes it fails cryptically if there are external dependencies you need to install first
22:10:22 <Cale> You'll certainly need the development package for GSL for it to work.
22:11:08 <Cale> Make sure you have /usr/include/gsl/gsl_randist.h
22:11:24 <byorgey> Petalon: if you're on Ubuntu, try  apt-get install libgsl0-dev, perhaps?
22:11:26 <Cale> It seems to import most of its stuff from there
22:11:51 <byorgey> and then cabal install gsl-random again
22:13:05 <Petalon> Hmm. 'ghc-pkg: dependency regex-compat-0.91 doesn't exist'
22:14:32 <FunctorSala> Cale: here too (though with ping it's a bit unlikely to catch it when not a whole line is ready ;))
22:17:05 <FunctorSala> good night
22:51:02 <mriou> does 'ghc --make' handles properly hs-boot files? I'm getting a 'module is defined in multiple files' error
23:49:01 <andresj> hello, where can i find information on implementing a (title "something here" = "Something Here") function?
23:49:45 <Axman6> a title case function?
23:50:15 <andresj> pretty much.
23:50:21 <andresj> *, Axman6.
23:50:35 <Axman6> > unwords . map (\xs -> toUpper (head xs) : (tail xs) . words $ "title case test"
23:50:36 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
23:50:44 <Axman6> > unwords . map (\xs -> toUpper (head xs) : (tail xs)) . words $ "title case test"
23:50:45 <lambdabot>   "Title Case Test"
23:50:51 <Axman6> how's that?
23:50:51 <andresj> lol
23:51:01 <andresj> thank you! :D ill check it o--- wow
23:51:07 <andresj> why didnt i think of that!
23:51:08 <andresj> lol
23:51:14 <Axman6> > unwords . map (\(x:xs) -> toUpper x : xs) . words $ "title case test"
23:51:15 <lambdabot>   "Title Case Test"
23:51:24 <Axman6> even clearer
23:51:36 <andresj> i was trying to find a function that worked similarly to scanl but instead of giving me increments itd give me the power to write a title case function
23:51:41 <andresj> but this version is much clearer :P
23:51:43 <Axman6> > unwords . map (\(x:xs) -> toUpper x : xs) . words $ "radome test garbage a g ËâÂ©Â©Â©Â¬â«Â¬ËblGibmhËÃËâhiuh"
23:51:45 <lambdabot>   "Radome Test Garbage A G \729\8710\169\169\169\172\8747\172\733blGibmh\710\...
23:51:45 <andresj> thank you very much, Axman6
23:52:08 <Axman6> > text . unwords . map (\(x:xs) -> toUpper x : xs) . words $ "radome test garbage a g ËâÂ©Â©Â©Â¬â«Â¬ËblGibmhËÃËâhiuh"
23:52:09 <lambdabot>   Radome Test Garbage A G ËâÂ©Â©Â©Â¬â«Â¬ËblGibmhËÃËâhiuh
23:54:35 <BMeph> > let headMap f = map (\(x:xs) -> f x : xs) in unwords . headMap toUpper . words $ "title case test"
23:54:37 <lambdabot>   "Title Case Test"
23:57:57 <Axman6> > text . return . map toUpper $ "ÅâÂ´Â®â \Â¨ËÃ¸ÏâÃ¥ÃâÆÂ©ËâËÂ¬â¦Ã¦Î©âÃ§ââ«ËÂµâ¤â¥"
23:57:59 <lambdabot>   mueval-core: Prelude.read: no parse
23:57:59 <lambdabot>  mueval-core: mueval-core: panic! (the ...
23:58:06 <Axman6> > text . map toUpper $ "ÅâÂ´Â®â \Â¨ËÃ¸ÏâÃ¥ÃâÆÂ©ËâËÂ¬â¦Ã¦Î©âÃ§ââ«ËÂµâ¤â¥"
23:58:08 <lambdabot>   mueval-core: Prelude.read: no parse
23:58:08 <lambdabot>  mueval-core: mueval-core: panic! (the ...
23:58:08 <mmorrow> hehehe
23:58:12 <andresj> lol
23:58:12 <Axman6> panic :O
23:58:23 <mmorrow> > error "ÅâÂ´Â®â \Â¨ËÃ¸ÏâÃ¥ÃâÆÂ©ËâËÂ¬â¦Ã¦Î©âÃ§ââ«ËÂµâ¤â¥"
23:58:24 <lambdabot>   mueval-core: Prelude.read: no parse
23:58:25 <lambdabot>  mueval-core: mueval-core: panic! (the ...
23:59:40 * BMeph chuckles at the idea of "the impossible" happening twice in a row. "I do not think this word means, what you think it means..."
