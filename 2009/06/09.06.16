00:00:22 <sjanssen> SLA?
00:00:33 <solidsnack> Service Level Agreement
00:01:27 <sjanssen> solidsnack: use Unix processes instead?
00:02:15 <solidsnack> I am not looking for a solution to my problem; but thank you. I am looking for specific information about GHC's powers of thread killing.
00:04:35 <solidsnack> So `throwTo` seems not to offer the strongest guarantess.
00:05:06 <sjanssen> actually, do pthreads even support killing?
00:05:10 <uzytkownik> dmwit: Not exactly - it looks like Control.Monad.Error.
00:05:37 <mmorrow> solidsnack: ghc can't interrupt a foreign call, because it's not in control
00:06:03 <solidsnack> Oh?
00:06:41 <solidsnack> It can make a syscall to interrupt the foreign call, though.
00:07:20 * sjanssen doesn't want to think of the nasty implications of that in 95% of C code
00:07:48 <solidsnack> Fair enough.
00:07:59 <mmorrow> http://opengroup.org/onlinepubs/007908775/xsh/pthread_cancel.html
00:08:11 <Zao> sjanssen: About as fun as "I want to kill this thread at any time"
00:09:03 * mmorrow notes with amusement that Zao's use of the word "thread" lines up perfectly with "thread" in that link
00:09:48 <solidsnack> mmorrow: Hmm.
00:09:53 <Zao> You have some oddball proportional typeface? Heresy.
00:10:04 <mmorrow> Zao: heh
00:10:23 <solidsnack> It seems that even pure Haskell threads can ignore `throwTo`, though.
00:10:49 <solidsnack> Zao: It lines up for me and I'm using monospace.
00:10:59 <mmorrow> Zao: Courier 10 Pitch 5
00:11:19 <Reiv> dmwit: No, this is our sample code I am trying to wrangle into usable form.
00:11:24 <Reiv> This is why I am wincing.
00:11:37 <sjanssen> solidsnack: not exactly ignore, but they can decide to not act on the exception
00:12:04 <mmorrow> although i think killThread is equiv to kill -9 (?)
00:12:08 <sjanssen> they can also decide to delay the exception
00:12:13 <solidsnack> Well, they might not even receive it.
00:12:23 <solidsnack> Not at the earliest possible moment.
00:12:34 <sjanssen> solidsnack: they always receive it eventually
00:12:58 <solidsnack> Well, they can apparently unblock and do something and then block and not get it in the interim.
00:12:59 <cjs> So here's an interesting little problem. I've got what are essentially the log files of a relational database, and I'm writing programs to do queries against them. Using functions that eat and generate lists is working well for me; I generate a lazy list of the records, and these functions chug away, generating a new lazy list of results, states (e.g., total of some figure to this point), etc.
00:13:18 <sjanssen> the ability to delay async exceptions in critical sections is important for correctness
00:13:28 <solidsnack> sjanssen: Hmmm.
00:13:40 <mmorrow> @src bracket
00:13:41 <lambdabot> bracket before after thing = block $ do
00:13:41 <lambdabot>     a <- before
00:13:41 <lambdabot>     r <- catch (unblock (thing a)) (\e -> do { after a; throw e })
00:13:41 <lambdabot>     after a
00:13:41 <lambdabot>     return r
00:14:11 <solidsnack> sjanssen: I think in general, yes.
00:14:20 <sjanssen> solidsnack: the exception will be delivered where the unblock section starts
00:14:22 <cjs> But I'd like to combine these in various ways, and still get type checking. E.g., f takes the list of records and returns a list that includes the records and the current total of some field. Is there some easy way that I can combine such things in arbitrary ways, while ensuring that g, which requires the total, is never used unless f has done the processing in front of it?
00:14:22 <solidsnack> However, if a computation is just being thrown away...
00:15:06 <cjs> At the moment I read, eg., [Foo] and return [(Bar,Foo)], but the potential combinations of these multiply....
00:15:15 <sjanssen> solidsnack: even if the result is ignored, there may be resources that must be cleaned up or risk a leak
00:15:32 <solidsnack> Ah, I see.
00:15:34 <PeakerWork> Baughn: I wouldn't say its a program bug -- how can a program know if something allocates or not? Its really an implementation detail
00:15:59 <solidsnack> I suppose this is because threads are all arbitrary IO computations.
00:16:41 <solidsnack> I'm thinking more about things like, find the eigenvalues of this matrix in 10 seconds or die.
00:16:43 <solidsnack> &c.
00:16:44 <mmorrow> solidsnack: they could even be throwing killThreads at the thread that's itself trying to killThread them
00:16:59 <solidsnack> Hmm.
00:17:14 <solidsnack> So I need "lesser threads".
00:17:26 <sjanssen> solidsnack: doesn't killThread implicitly unblock?
00:17:42 <sjanssen> s/solidsnack/mmorrow
00:17:49 <solidsnack> sjanssen: Read this: http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-Conc.html#killThread
00:17:55 <solidsnack> oops
00:18:13 <solidsnack> http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-Conc.html#throwTo
00:18:44 <solidsnack> sjanssen: Or do you mean it unblocks the thread calling it?
00:18:55 <sjanssen> solidsnack: the thread calling killThread
00:19:03 <solidsnack> Interesting.
00:19:55 <sjanssen> solidsnack: oh interesting, apparently I wasn't quite right
00:20:24 <sjanssen> a thread can in fact unblock and reblock without receiving the exception.  Wonder when/why that happens
00:20:54 <dirk_> is there any good library in Haskell for the following image operations convert (svg and gif) to png and replace transparent color with white, and (determine size and scale) of jpg png? Currently I am using rsvg and imageMagic, maybe it is good to keep it like this??
00:35:25 <yitz> dirk_: there is a Haskell binding to ImageMagick, if that helps.
00:37:51 <dirk_> ok I will consider ist
00:37:52 <dirk_> ok I will consider is
00:39:14 <WorkyBob> I don't think there's any haskell binding that's pure, like it should be :(
00:39:25 <WorkyBob> there's a DevIL binding somewhere too though
00:43:35 <uzytkownik> @pl \e v -> maybe (throwError e) return v
00:43:35 <lambdabot> flip maybe return . throwError
01:01:07 <uzytkownik> @hoogle Either a a -> a
01:01:07 <lambdabot> Distribution.ReadE ReadE :: String -> Either ErrorMsg a -> ReadE a
01:01:07 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
01:01:07 <lambdabot> Data.Either either :: (a -> c) -> (b -> c) -> Either a b -> c
01:01:34 <WorkyBob> A while ago I remember a discussion that pointed out a subtle difference between \x -> x + 2 and (+2), but I can't for the life of me remember what it was.  Anyone happen to know?
01:01:50 <WorkyBob> > either id id (Left "5")
01:01:51 <lambdabot>   "5"
01:03:59 <integral> @type either id id
01:04:00 <lambdabot> forall b. Either b b -> b
01:05:24 <Cale> WorkyBob: Could the example have been slightly different?
01:06:09 <Cale> hmm
01:06:15 <WorkyBob> Cale: possibly, but it was a subtle difference between a partial application and a lambda expression that seemed to mean the same thing
01:06:25 <WorkyBob> IIRC it was to do with how many times things got evaluated
01:06:40 <WorkyBob> oh... and there it is... the value wrapped in the partial application gets evaluated once
01:06:40 <Cale> (\x y -> ...) and (\x -> \y -> ...) are subtly different
01:06:50 <WorkyBob> the one in the lambda gets evaluated as many times as the lambda does
01:07:29 <WorkyBob> so it needs to be \x -> x + E and (+E) -- it should be \x -> let y = E in x + y
01:07:36 <WorkyBob> oh no, even that doesn't get it right
01:07:49 <WorkyBob> let y = E in \x -> x + y -- that should be it
01:08:40 <Cale> mm... yeah
01:09:14 <Cale> if the let occurs outside the lambda, then the values defined in it won't go out of scope each time the lambda body is evaluated
01:10:35 <Cale> But that isn't a semantic difference at least.
01:10:56 <Cale> (it can change performance drastically, but it won't change the result)
01:11:02 <WorkyBob> no, it's not
01:11:06 <WorkyBob> which is good
01:13:41 <opqdonut> Cale: doesn't ghc sometimes float lets?
01:13:45 <opqdonut> outside lambdas
01:15:10 <Cale> Yeah
01:15:12 <WorkyBob> it does
01:15:21 <WorkyBob> that's why the unsafe perform IO documentation says to turn it off
01:16:24 <Reiv> ...okay, what?
01:16:56 <Reiv> WinHugs error: ERROR file:.\Ass4.txt:139 - Syntax error in expression (unexpected `;', possibly due to bad layout)
01:17:05 <Reiv> The code I threw at it: http://pastebin.com/d3c94fb36
01:17:18 <Reiv> There isn't a ; in sight...?
01:17:57 <Zao> I've heard that Haskell source files are most comfortable being named .hs.
01:18:16 <doserj> Reiv: you have to indent the case in that line a bit more
01:18:27 <Zao> Needs more indentation.
01:18:55 <osfameron> MOAR!
01:19:20 <Reiv> Ah-hah
01:19:27 <Reiv> Hrn. This is going to be long and painful isn't it
01:19:42 <Cale> Things which are inside other things have to be indented more than them
01:19:58 <Cale> things which are at the same level are indented the same
01:21:51 <osfameron> if...then...else confuses me as the then and else are part of the if (whereas in other languages would often be indented the same as it)
01:21:59 <osfameron> I get around that in haskell by avoiding if..then..else ;-)
01:22:02 <osfameron> ternary ftw!
01:22:23 <Cale> I just indent if-then-else strangely in other languages :)
01:22:32 <Zao> unless spectacular exitFailure
01:23:21 <Reiv> 139...142...165... I'm making progress~
01:23:40 <Zao> Say that I have f :: IO Bool, would there be any neater way to do  f >>= \b unless b g   ?
01:24:00 <Zao> I had f >>= flip unless g, but that reads quite wrong.
01:24:06 <Cale> hehe
01:24:17 <Cale> yeah, I usually just use 'do' myself.
01:24:28 <Cale> do b <- f; unless b g
01:26:45 <solidsnack> I recently `:set +s` in GHCi and then typed `21`.
01:26:55 <solidsnack> It allocated hundreds of thousands of bytes.
01:26:59 <solidsnack> How did that happen?
01:27:59 <Zao> Cale: For some reason, pointless code appeals to me.
01:27:59 <Reiv> woo! It clears.
01:28:07 <Reiv> Okay. Now to work out what I'm meant to do.
01:28:36 * Reiv scratches his head. So, this is a parser for TINY. We want to implement semantics so that we get more useful errors out of it.
01:30:34 <quicksilver> solidsnack: it pulled in a bunch of standard stuff for the first time
01:30:44 <quicksilver> solidsnack: try a few more numbers and they'll probably allocate zero
01:30:45 <solidsnack> It does it every time, though.
01:30:55 * Reiv digs in to work out where one starts.
01:30:55 <quicksilver> not for me it doesn't.
01:31:01 <solidsnack> However, `21 :: Int` allocates 0.
01:31:26 <quicksilver> I find that integers allocate nothgin (after the first one)
01:31:31 <quicksilver> floats allocate though
01:31:47 <solidsnack> It only happens if I don't have an explicit type signature, actually.
01:31:58 <solidsnack> `21 :: Integer` also allocates 0.
01:32:20 <solidsnack> Maybe because I have warnings on?
01:33:55 <quicksilver> odd
01:33:56 <quicksilver> maybe
01:36:22 <cjs> Ah, quicksilver! My hero!
01:38:51 <cjs> Got a sec to ponder a type problem for me?
01:40:14 <smorg> Is haskell's type system come from context-free grammar definitions?
01:40:42 <smorg> looks BNF looks like it a bit.
01:42:01 <smorg> blah can't type.
01:42:34 <quicksilver> cjs: possibly. If you don't ask you'll never know :P
01:47:04 <cjs> Ok. I've got several different functions that process a lazy stream of records, some generating state objects (e.g., summing something), others adding information used by things further down the chain, that sort of thing. I'm wondering if there's some sort of generic but type-checked way to put arbitrary combinations of these together. Sort of having a data structure where the individual things in it are "set-like," in that a fun
01:47:04 <cjs> ction knows about a couple of things in it, but doesn't care what else is in it.
01:47:56 <cjs> In Ruby, of course, I'd just shove various objects into a hash under predefined names.
01:50:18 <quicksilver> almost certainly.
01:50:27 <quicksilver> If you can describe it, you can devise a type system to check it.
01:51:03 <quicksilver> (occasionally you're forced to come up with something a bit ugly though)
01:52:27 <quicksilver> where do the state objects go?
01:52:34 <quicksilver> into the stream or alongside it?
01:52:42 <quicksilver> a -> [b] is a nice type.
01:53:02 <cjs> Along side it.
01:53:18 <mlesniak> I have a (probably small) error in a type declaration for a function using unboxed arrays (See http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2779#a2779 ) Any obvious hints?
01:54:07 <quicksilver> mlesniak: you need to add the constraint it gives
01:54:08 <hatds> I run into this error a lot
01:54:13 <quicksilver> (MArray IOUArray a IO)
01:54:18 <hatds> IOUArray doesn't have a MArray instance for every
01:54:20 <hatds> *every a
01:54:33 <cjs> E.g., one function may be summing "foo" as stuff flows through it, and producting a new output stream of the original records plus the current sum of foo to that point. Another the same for bar. Later on, other functions may pick certain of these sums and add their own results from time to time.
01:55:08 <mlesniak> quicksilver: Hmm, thought so, but I'm not sure where (Haskell syntax problem), i.e. MArray IOUArray a IO => ... does not work, where else could I put it
01:55:22 <quicksilver> mlesniak: (Show a, MArray IOUArray a IO) =>
01:55:37 <hatds> in this situation I would comment out the signature and then paste what ghci spits back
01:55:39 <hatds> :)
01:55:41 <cjs> (It's essentially a database query engine, with the constraint that I'm making one pass through a rather large list of records.)
01:55:49 <mlesniak> quicksilver: Hmm, wonder why it didn't work when I tried it out :) Thanks
01:55:53 <mlesniak> hatds: :D
01:56:03 <mlesniak> hatds: This reduces the learning effect ;)
01:56:10 <quicksilver> possibly you need -XMultiParamTypeClasses
01:56:40 <quicksilver> cjs: "a new outputstream" ?
01:56:45 <quicksilver> is it really a new stream?
01:56:49 <mlesniak> quicksilver: Yes, ghc tells me to add -XFlexibleContexts. Will google what this is
01:56:59 <quicksilver> or is it just adding on extra data along siide the existing stream
01:57:17 <quicksilver> [Foo] -> [(Foo,Int)] for example
01:57:21 <quicksilver> where Int is the sums
01:57:29 <cjs> Quite possibly. Some of the functions might filter data, for example, or summarize it.
01:57:36 <cjs> Maybe I ought not be doing that. :-)
01:58:12 <cjs> If they just add further data alongside, I can just nest pairs, I suppose.
01:58:27 <quicksilver> that's certainly one way, yes.
01:58:28 <hatds> mlesniak: it's because your constraint is of the form MArray monotype typevariable monotype instead of all typevariables
01:59:08 <mlesniak> hatds: Hmm, do you have some source for more information on this?
01:59:43 <quicksilver> http://haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html
02:00:05 <cjs> I tried that out for a bit, and ended up with filters that produced a lot of Nothings, which seemed nice to get rid of. But perhaps that's really the way to go.
02:00:19 <quicksilver> mlesniak: (that was for you)
02:00:31 <mlesniak> quicksilver: thanks (already reading ;))
02:00:56 <hatds> ^^ ghc's user guide is best place probably, knowing why haskell wants constraints of a certain structure is a low level detail though
02:01:48 <hatds> flexible contexts will be fine, or you could go with the more general constraint that ghc can infer
02:02:30 <mlesniak> hatds: You mean the automatically infered type?
02:02:40 <hatds> yea
02:02:58 <mlesniak> hatds: Sounds good, too, thanks!
02:08:42 <MartyIX> Hi guys. Why is this code: http://pastebin.com/d3bab2441 wrong? It seems to me that there's no problem with layout. This way http://pastebin.com/d2faf908c everything works ok. I use winhugs.
02:09:17 <Bacta> @fag sex
02:09:18 <lambdabot> The answer is: Yes! Haskell can do that.
02:09:28 <Bacta> :o
02:10:23 <cjs> MartyIX: It looks ok to me. You aren't using tabs in your file, are you? What's the error you get?
02:12:17 <MartyIX> cjs: No, I don't. The error is: Syntax error in input (unexpected `(')
02:12:24 <cjs> Which line?
02:12:45 <MartyIX> on http://pastebin.com/d3bab2441 - line 2
02:13:01 <Cale> MartyIX: There are tabs in your file
02:13:10 <Cale> MartyIX: Configure your editor to replace them with spaces.
02:15:02 <MartyIX> Cale: I enabled the option to see whitespace characters and in my code really is no tab
02:15:19 <Cale> There's a tab before the = sign
02:15:23 <Cale> on the first line
02:16:17 <MartyIX> Cale: ouch, sorry, I'm blind
02:16:46 <Cale> This is why it's really best not to allow tab characters at all :)
02:17:20 <Cale> If it were up to me, they would be considered a lexical error on their own :)
02:17:45 <RayNbow> tabs are the headaches of lab course assistants :p
02:17:56 <RayNbow> (personal experience :p)
02:18:18 <quicksilver> lab administrators should configure editors to display TAB characters in bold flashing pink and green
02:18:34 <MartyIX> Cale: ten minutes of my life are lost. The lexical error would be appreciated :-D
02:18:46 <RayNbow> quicksilver: unfortunately, some people use their own laptops :p
02:19:21 <cjs> Lab administrators should configure those people's laptops the same way, then.
02:19:43 <doserj> MartyIX: ghc -fwarn-tabs
02:20:00 <MartyIX> doserj: i have winhugs
02:20:07 <RayNbow> Everytime you use tabs in Haskell, God kills a lambdakitten... Please think of the lambdakittens! :p
02:20:28 <doserj> MartyIX: read this as advertisement for ghc, then :)
02:22:18 <MartyIX> doserj: I like winhugs because I can use clipboard for results and so on. It's more comfortable for me.
02:23:00 <quicksilver> surely you can copy-paste from ghci?
02:23:03 <quicksilver> I can't imagine why not.
02:23:03 <altmattr> slightly OT - I have been reading an article from journal of functional programming and there are a few points I am certain could be enlightened by the right person.  I assume this is not the place to talk about these things, does anyone know where is?
02:23:29 <quicksilver> personally I run ghci in emacs for maximum copy-paste-abiliyt
02:23:34 <cjs> stackoverflow.com! :-)
02:24:02 <quicksilver> I thought stackoverflow.com was for people trying to write their first .NET program? :)
02:24:28 <MartyIX> quicksilver: but ghci is command-line isn't it? And you can't simply use clipboard as in windows apps - no ctrl+c
02:24:32 <cjs> Actually, altmattr, I personally feel that this is a reasonable place to talk about that sort of stuff. However, if you're looking for a message-board-type-thing, lambda-the-ultimate.org is the place to go.
02:24:42 <RayNbow> MartyIX: enable quick edit
02:24:45 <quicksilver> altmattr: well, functional programming isn't entirely off-topic here. You can always move the discussion to #haskell-overflow if it starts getting in people's way.
02:24:55 <RayNbow> so you can select/copy using the left mouse button
02:25:00 <RayNbow> and paste with the right mouse button
02:25:07 <cjs> quicksilver: http://stackoverflow.com/questions/993124/does-haskell-have-variables-closed
02:25:09 <altmattr> cheers folks
02:25:26 <altmattr> cjs: actually, I find message boards unbearable after using irc
02:25:26 <MartyIX> RayNbow: I'll try, thanks for the tip
02:26:28 <RayNbow> MartyIX, just right click on the icon of the console window and select Properties
02:26:33 <RayNbow> then enable: http://www.codeproject.com/KB/security/SelfHealing/SelfHealing30.png
02:27:41 <MartyIX> raynbow: works great :)
02:28:29 <altmattr> so, has anyone read "Practical type inference for arbitrary-rank types"
02:28:48 <RayNbow> MartyIX: I forgot to mention, after selecting text using the left button, you need to hit Enter to copy the selected text to the clipboard
02:29:56 <MartyIX> RayNbow: I found out it's similar to behaviour of powershell :)
02:33:57 <Associat0r> guys why is it that in haskell the standard is to type annotate every top-level function? while in ocaml less people do it? is it only to constrain the scope type classes? or more a style issue?
02:34:17 <cjs> So that hasktags can catalogue them. :-)
02:38:00 <altmattr> Associat0r: I think Haskell has more type-system extensions that require annotations, so there is a culture that adding them is no big deal
02:38:18 <altmattr> when you hitch your wagon to not needing them (ML) you want to show it off as much as possible
02:38:20 <altmattr> :)
02:38:46 <altmattr> plus "
02:38:56 <altmattr> "extra documentation is good"
02:39:45 <altmattr> can anyone shed light on the interaction between polymorhpic type constructors and higher rank types?
02:39:58 <sjanssen> Associat0r: it's all about self-documentation, I think
02:40:37 <altmattr> how about how GHC implements polymorphic type constructors (by which i mean a data structure containing a polymorphic function_
02:40:38 <sjanssen> altmattr: even with extensions, type annotations are rarely required
02:41:13 <ivanm> but you should put them in anyway
02:41:31 <altmattr> sjanssen: I agree, but the implementors (the community leaders) made a conscious decision that adding them is OK. I think that makes a difference
02:41:54 <ivanm> I would say that not adding them is OK
02:42:01 <ivanm> as the emphasis placed is then slightly different
02:42:16 <altmattr> the alternative line of reasoning is to say "we don't want to give up full type inference" which puts you in a  whole different frame of mind
02:42:17 <sjanssen> Associat0r: I also suspect that Haskellers write more type signatures because the syntax is nice, while the syntax in OCaml is ugly
02:42:28 <altmattr> sjanssen: too true
02:42:43 <ivanm> sjanssen: like the OCaml syntax for tuples?
02:42:45 <ivanm> *shudder*
02:42:47 <quicksilver> cjs: OK, I revise my opinion. stackoverflow is a place for people who haven't written their first .NET program to show their ignorance in public by illustrating they don't know the meanings of basic terms, whilst trying to answer a question about haskell. :P
02:43:10 <cjs> I find I often use them because I write types first, leaving the function undefined, get that to compile, muck about with it a bit, and only later actually go and write the code.
02:43:12 <altmattr> sjanssen: although I can't get textmate syntax highlighting to properly pick up multiline type decls :(
02:43:24 <cjs> I suppose I could take them out afterwards, though.
02:43:36 <cjs> quicksilver: :-)
02:43:37 <quicksilver> altmattr: parametric polymorphism as implemented by GHC is very lightweight
02:43:53 <quicksilver> altmattr: you literally just store the function - it doesn't "matter" how polymorphic it is or isn't.
02:44:02 <quicksilver> if the typechecker checks out, it will run fine.
02:44:02 <cjs> I am still seething about that answer. BTW.
02:44:26 <quicksilver> altmattr: typeclass polymorphism involves passing or bundling dictionaries (in the GHC implementation) when you do certain higher-order things.
02:44:48 <Associat0r> guys thanks for your answers
02:45:00 <altmattr> quicksilver: I am wondering about data structures where one of the parameters is a polymorphic fuction
02:45:52 <altmattr> quicksilver: Haskell98 does not allow (for example data M m = M (forall a. m a -> a -> m b) -> m b))
02:46:11 <altmattr> ignore bodgy parens
02:46:15 <altmattr> but ghc does
02:46:24 <altmattr> or does it?
02:46:30 <altmattr> gopher did I think
02:47:06 <altmattr> anyway, I read that ghc actually turns type classes into such data type decls
02:47:14 <altmattr> which is very cool
02:47:21 <sjanssen> altmattr: there is no special representation there, just a function (types are erased)
02:47:24 <quicksilver> altmattr: GHC does permit that.
02:47:27 <altmattr> but opens up a whole can of worms I am interested in exploring
02:47:40 <quicksilver> altmattr: and as I say, parametric polymorphism "isn't a problem"
02:47:46 <quicksilver> it just stores the function pointer (well, roughly)
02:47:57 <altmattr> but how does it type check it?
02:48:01 <quicksilver> it's the type checker's job to make sure the function is only ever called with appropriate arguments.
02:48:05 <altmattr> *that* is the interesting bit
02:48:18 <quicksilver> checking rank-N types isn't particularly hard.
02:48:22 <quicksilver> inferring them is.
02:48:36 <cjs> Hm. How can I pass a value construtor into a function and then pattern match with it?
02:48:42 <altmattr> quicksilver: I think inferring them is impossible
02:48:43 <quicksilver> cjs: you can't.
02:48:47 <quicksilver> altmattr: in general it is.
02:48:49 <cjs> Darn this Haskell, anyway!
02:48:55 <quicksilver> altmattr: you can infer interesting fragments.
02:49:02 <quicksilver> cjs: constructors "aren't first class"
02:49:03 <altmattr> cjs: you can with the language I am writing :)
02:49:08 <quicksilver> cjs: (is how this is often described)
02:49:17 <altmattr> cjs: well, compiler for an existing language
02:49:24 <cjs> Not very classy at all, if you ask me.
02:49:29 <altmattr> cjs: which allows that
02:49:31 <quicksilver> cjs: it occasionally makes sense to 'shadow' a data type with a second one consisting only of constructors.
02:49:34 <cjs> altmattr: What language? When will you be done? By this afternoon?
02:49:39 <quicksilver> data Foo = A .. | B ... | C ...
02:49:44 <altmattr> cjs: Bondi, 3 months, no
02:49:49 <sjanssen> cjs: you could apply it to junk arguments and case that
02:49:56 <quicksilver> data Con_Foo = Con_A | Con_B | Con_C
02:50:13 <cjs> quicksilver: Hm. Yes, I've done that before, come to think of it.
02:50:38 <sjanssen> or this, if you can get away with it: data Foo = Foo FooBar ...; data FooBar = A | B | C
02:50:59 <altmattr> quicksilver: so do you know how ghc does the polymorphic args in data types?
02:51:03 <altmattr> are these inferred?
02:51:17 <quicksilver> altmattr: in general, no.
02:51:24 <quicksilver> I can't remember which fragments of Rank-N GHC can infer
02:51:30 <quicksilver> I think it's minimal
02:51:39 <quicksilver> basically you have to annotate, for Rank-N
02:51:55 <altmattr> quicksilver: I do know of *a* way to infer these types, I think it was implemented in Hugs
02:52:17 <altmattr> but only for the polymorphic constructors, not for rank-N
02:52:36 <quicksilver> I think GHC tries slightly harder to infer some case of impredicativity.
02:55:52 <cjs> How, bondi sounds pretty cool.
02:55:58 <cjs> s/H/W/
03:07:44 <altmattr> cjs: it is cool, but it has a fair bit of work still to be done on it
03:08:44 <altmattr> cjs; Depending on exactly what you were trying to do, you will find you can get a long way with data type generic programming (like SYB) which these days works extremely well in GHC
03:09:01 <altmattr> SYB == scrap your boilerplate
03:09:09 <cjs> altmattr: Yes, I keep meaning to investigate that stuff a bit further.
03:09:22 <altmattr> cjs: you could do a lot worse
03:13:13 <altmattr> the result of my first effort with SYB was
03:13:14 <altmattr> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2781#a2781
03:13:49 <altmattr> note the comment :) I was really, really happy when that code worked.  The alternative code (not using SYB) is hundreds of lines full of bugs
03:14:59 <altmattr> btw: moonpatio won't autopost?
03:16:42 <mmorrow> altmattr: the notification bots aren't setup
03:16:59 <altmattr> mmorrow: as long as it is not just me :)
03:17:04 <mmorrow> :)
03:17:22 <altmattr> I still don't feel a native in IRC yet
03:17:26 <altmattr> it will come, I am sure
03:18:30 <cjs> When are they going to fix the inability to do infix application of pairing? I want to map (,()) on to something.
03:18:52 <ivanm> cjs: ummm, why not just ((,) ()) ?
03:19:03 <sjanssen> ivanm: because that's wrong
03:19:07 <sjanssen> flip (,) ()
03:19:09 <ivanm> can't just use `,', because does ,, mean (,,) or (,)(,) ?
03:19:14 <ivanm> sjanssen: oh, yeah
03:19:18 <ivanm> you get what I mean ;-)
03:20:27 <cjs> ASCII art faces!
03:22:28 <hatds> is there anything special about nullPtr's in Haskell's FFI?
03:23:09 <hatds> I have a bug where if I keep nullPtr's in a haskell Map then ghc's time/space profiler will give me an empty report
03:24:19 <sjanssen> hatds: perhaps you're observing sharing?
03:24:26 <hatds> hmm?
03:24:55 <sjanssen> hatds: nullPtr is a CAF, so there's probably only one ever allocated
03:25:12 <hatds> this is all inside a non-trivial program, so I should still get a report
03:25:37 <sjanssen> oh, the report is totally empty?  No text at all?
03:25:45 <hatds> correct, completely blank
03:26:23 <sjanssen> might you be dereferencing one of these nullPtrs and getting a segfault?
03:26:27 <hatds> no
03:26:39 <hatds> I'm positive the nullPtrs are never used when I do keep them
03:26:46 <hatds> and the program works as expected
03:27:12 <altmattr> is the profiler calling something that the program does not
03:27:14 <altmattr> ?
03:27:36 <hatds> calling what?
03:28:21 <altmattr> well, the profiler adds in code to instrument.  You and I don't know what it does, but perhaps that instrumenting code is calling something you don't want it to
03:28:32 <altmattr> something that is otherwise unevaluated?
03:28:35 <altmattr> or...?
03:28:53 <altmattr> i don't know.  But it seems the only way you could get the behaviour you are getting
03:28:59 <altmattr> or the only way I can think of
03:29:02 <hatds> it shouldn't do something dangerous though like messing with pointers :)
03:29:26 <hatds> hmm, I need to shrink my prorgam to a minimal test case I guess
03:31:37 <hatds> the behavior of the program is unchanged, if the profiler is doing something sneaky it is only doing it to destroy itself
03:33:53 <hackagebot> bio 0.4 - A bioinformatics library (KetilMalde)
03:38:54 <hackagebot> dephd 0.1.3 - Analyze quality of nucleotide sequences. (KetilMalde)
03:44:01 <WorkyBob> quicksilver: bugger, I suspect I may have started an argument that's rather redundant -- I should have consulted the haskell-platform guys before hand
03:44:20 <quicksilver> WorkyBob: because... ?
03:44:26 <quicksilver> they have no intention of changing their logo?
03:44:33 <WorkyBob> that was the impression I got
03:44:44 <WorkyBob> from a quick talk with SM and DC
03:45:18 <quicksilver> ah well, that's a shame.
03:45:24 <quicksilver> the current HP logo sucks.
03:45:44 <WorkyBob> I wouldn't say it sucks -- it's also got some nice simple elements to it, and is basically stylish
03:46:04 <WorkyBob> but yeh, as it's meant to be the primary distribution of Haskell, it would be nice for it to have a consistant logo with the rest of Haskell stuff
03:47:03 <temoto> Hello.
03:47:06 <temoto> . true
03:47:19 <Zao> Hello there.
03:47:32 <mmorrow> , True
03:47:36 <temoto> . show true
03:47:36 <lunabot>  True
03:47:36 <quicksilver> the batteries look entirely out of sync with the sides of the cube.
03:47:41 <mmorrow> > show True
03:47:43 <lambdabot>   "True"
03:47:46 <temoto> ah, capitalized, thanks
03:47:48 <WorkyBob> quicksilver: true
03:47:51 <quicksilver> I don't *like* the haskell logo that one, either.
03:47:54 <quicksilver> s/one/won/
03:48:01 <quicksilver> on the other hand, I like consistency.
03:48:02 <mmorrow> temoto: (not the `elem` ",>" too)
03:48:04 <quicksilver> Oh, he's gone :P
03:48:07 <mmorrow> s/not/note/
03:48:57 <temoto> Right, i forgot. Been here too far ago.
03:49:15 <WorkyBob> quicksilver: no, I don't either
03:49:21 <WorkyBob> but consistancy is good
03:49:33 <WorkyBob> also, your name is dangerous when holding down cmnd quicksilver
03:50:03 <quicksilver> WorkyBob: haha ;)
03:50:10 <quicksilver> WorkyBob: yes, I said just after you quit
03:50:17 <quicksilver> WorkyBob: "on the other hand, I like consistency"
03:50:20 <WorkyBob> yeh
03:50:32 <quicksilver> WorkyBob: So, I like the HP logo you did, and some of the slight enhancements done by others.
03:50:56 <WorkyBob> yeh, the only one I'm not keen on is the ones with gradients on the batteries
03:50:59 <quicksilver> I think the black and gold is great.
03:51:09 <hatds> aaaaaaaaaaaaaaaaaaaaah I'm stupid -- I was touching those darn nullPtrs /just as the prorgam terminates/ ... so the segfaulting was only revealed by the profiler crashing out
03:51:12 <WorkyBob> I like logos to be ultra-simple in terms of colour choice
03:51:19 <quicksilver> agreed.
03:51:25 <quicksilver> simple, prints well, minimises well.
03:51:29 <WorkyBob> yep
03:52:06 <quicksilver> @tell dcoutts I know the last thing you want is another bikeshed, but FWIW I think the black and gold variant of WorkyBob's HP logo is 1000 times better than your existing logo, and I think consistency with the official haskell logo is a virtue.
03:52:06 <lambdabot> Consider it noted.
03:52:22 <quicksilver> WorkyBob: There. I've said it. Now he can do what he wants.
03:52:42 <WorkyBob> hehe
03:52:46 <WorkyBob> fair enough indeed
03:53:00 <WorkyBob> I could do the dirty and suggest another competition
03:53:01 <WorkyBob> >.>
04:15:31 <Axman6> WorkyBob: logo?
04:19:13 <yitz> Axman6: the haskell platform logo, see active thread on the cafe
04:21:13 <Axman6> hmm, i think Beelsebob's one is nice, but a) the colours don't contrast enough to really see the batteries, and b) they will be too small to see when resized
04:21:28 <hatds> is there a way to get ghc to "make clean"?
04:22:05 <mmorrow> hatds: make what clean?
04:22:13 <quicksilver> remove .hi and .o files, I imagine.
04:22:16 <hatds> yea
04:22:17 <mmorrow> ah
04:22:26 <mmorrow> i like rm -f *.{o,hi} ;)
04:22:29 * quicksilver uses find . -name '*.hi' -or -name '*.o' | xargs rm
04:22:35 <mmorrow> ooh
04:22:53 <quicksilver> my directory structures are obviously deeper than mmorrow
04:23:23 <mmorrow> heh, i need to start using xargs (and rtfm for find)
04:23:27 * mmorrow usually does
04:23:53 <mmorrow> find . | grep -E "\.?lhs$" | hax
04:23:57 <mmorrow> oops
04:24:06 <mmorrow> find . | grep -E "\.(hi|o)$" | hax
04:24:08 <mmorrow> ;)
04:24:18 <mmorrow> a big "oops"
04:25:33 <Beelsebob1> Axman6: are you looking at the yellow/black one?
04:25:38 <Beelsebob1> or the grey/grey one?
04:25:43 <mmorrow> oh wow, xargs is easy
04:25:53 <Axman6> the grey one, i haven't nooked at the rest of the thread
04:26:08 <mmorrow> and does what i've been using vicious hackery for for years :/
04:26:11 <Beelsebob1> Axman6: take a look at the yellow/black one, both those complaints were addressed
04:26:25 <Axman6> yellow + black ++
04:26:28 <Axman6> very nice
04:26:47 <Axman6> though the yellow seems somehow dull
04:26:55 <mmorrow> quicksilver: how did those doxygen docs for that C++ proj come out?
04:27:02 <quicksilver> mmorrow: nice, in the end
04:27:07 <mmorrow> quicksilver: nice
04:27:10 <Beelsebob1> yeh, tis hard to get a sufficiently gold looking one that is still bright Axman6
04:27:13 <mmorrow> ooh, i put the linux ones up
04:27:20 <quicksilver> mmorrow: although I'm not sure the call/callee graphs entirely justify the space they take/ time they take to generate
04:27:25 <quicksilver> mmorrow: still, they're definitely cute :)
04:27:26 <mmorrow> http://moonpatio.com/docs/linux/
04:27:53 <mmorrow> quicksilver: yeah, 90% of the callee/er graphs are either trivial or massive/jumbled
04:28:07 <mmorrow> very hit-or-most-likely-miss
04:30:02 <mmorrow> quicksilver: the kernel dox took 3.7GB of space after 3+ hours of building
04:30:54 <mmorrow> the datastructure index is really nice: http://moonpatio.com/docs/linux/classes.html
04:30:56 <quicksilver> mmorrow: seems like some .c files are missing from the file index
04:31:41 <quicksilver> I think only a small fraction of the subs are being generated.
04:31:42 <mmorrow> quicksilver: hmm, at random, or entire subdirtrees? (i omitted some directories, but i think it night have followed some #includes and pulled in parts of the manyways)
04:31:52 <quicksilver> for exaple http://moonpatio.com/docs/linux/structkvm__pio__request.html
04:32:08 <quicksilver> click on any of the functions in the "referenced_by" sections
04:32:17 <quicksilver> they don't have proper docs, just a source link
04:32:45 <mmorrow> ah, hmm
04:32:59 <quicksilver> wow. I hope your server has plent fo bandwidth.
04:33:07 <quicksilver> some of these pages have a lot of data on ;)
04:33:48 * Beelsebob1 really doesn't get this insistance that sum should be strict in the Haskell report
04:33:59 <Beelsebob1> tis a weird idea that one function should be strict at random
04:34:13 <mmorrow> quicksilver: do the "referenced by" links ever point to the doc page and not the src-view page though?
04:34:36 <Cale> Beelsebob1: I think there should be a strict version of it called sum'
04:34:46 <Beelsebob1> Cale: /agree, totally
04:34:49 <mmorrow> quicksilver: heh, yeah i'm slightly worried about the bandwidth thing, i've gotta check on that..
04:34:59 <Beelsebob1> or claus' idea of generalizing functions over their ($) operator
04:35:00 <hatds> I've never needed lazy sum, but I use sum' all the time
04:35:25 <Beelsebob1> hatds: doesn't mean that we should destroy the consistancy in the language of everything being lazy unless otherwise requested
04:35:48 <hatds> Beelsebob1: yea, probably.  I'm just saying
04:35:58 <Beelsebob1> also, I have used lazy sum in the past
04:36:19 <quicksilver> I think it's a valid argument to note that the vast majority of uses want the strict form.
04:36:23 <mmorrow> Beelsebob1: true, but it's slightly annoying that the default "sum" is unusable for regular numbers
04:36:57 <mmorrow> you have to rely on the compiler figuring out that your really meant sum' for you, or else you blow your stack
04:37:13 <Beelsebob1> mmorrow: well, I think that's entirely reasonable
04:37:20 <Beelsebob1> after all, blowing your stack is an implementation detail
04:37:41 <Beelsebob1> what should matter is the semantics of sum, not the a random implementation
04:37:56 <mmorrow> Beelsebob1: then your code won't work in ghci..
04:38:00 <quicksilver> it's true that it wouldn't be quite so bad if GHC could cope better with large stacks.
04:38:14 <Beelsebob1> (after all, we seem quite happy to rely on the compiler to use the mul operator on our CPU, not repeated addition to do multiply)
04:38:32 <quicksilver> Beelsebob1: O(n) space usage is not an implementation detail though.
04:38:34 <Beelsebob1> quicksilver: quite -- if anything, this is a ghci bug
04:38:36 * mmorrow likes to write code that works in ghci and compiled code, but that's just his personal preference
04:38:39 <quicksilver> that's a semantic fact.
04:38:49 <Beelsebob1> quicksilver: sure it is -- better compilers manage it just fine
04:38:59 <Beelsebob1> e.g. if you compile with ghc, you don't get O(n) space usage
04:39:08 <Beelsebob1> so there's nothing ingrained into the semantics there
04:39:11 <quicksilver> optimisations sometimes reduce space usage.
04:39:30 <quicksilver> but the obvious naive operational semantics for it use O(n) space
04:39:30 <Beelsebob1> yeh, so it's entirely an implementation detail
04:39:35 <quicksilver> and that's not necessary
04:39:43 <Beelsebob1> well yes... so don't use the naïve operational semantics
04:39:47 <quicksilver> since there is a different algorithm which uses O(1) even until the naive semantics.
04:40:07 <Beelsebob1> quicksilver: yes, but that different algorithm is inconsistant with the semantics of the rest of the language
04:40:14 <quicksilver> no it's not.
04:40:20 <quicksilver> all we're doing is choosing what "sum" means
04:40:22 <Beelsebob1> (and we already have a method of flagging up such functions -- we add a ' to the end of their name)
04:40:27 <quicksilver> seq is part of the language, you know?
04:40:30 <quicksilver> it *is* allowed to use it.
04:40:48 <Beelsebob1> true true, maybe seq should be called seq'
04:40:54 <Beelsebob1> although then seq would be a weird function
04:40:59 <hatds> I think of ' as more general than strict
04:41:01 <mmorrow> but then what would seq be!! :)
04:41:04 <mmorrow> seq = id
04:41:06 <MartyIX> How come I cannot show list of pairs? http://pastebin.com/d6e958b0b - winhugs warns: ERROR - Cannot find "show" function for:
04:41:06 <MartyIX> *** Expression : nasobnosti [1,1,2,2]
04:41:06 <MartyIX> *** Of type    : Integer -> Integer -> [(Integer,Integer)]
04:41:07 <hatds> i.e., ' just means "a variant"
04:41:14 <mmorrow> seq' = realSeq ;)
04:41:27 <mmorrow> err, const i mean not id
04:41:35 <MyCatVerbs> mmorrow: seq = const, tyou mean, if it is to be lazy.
04:41:45 <quicksilver> MartyIX: you can show lists of pairs
04:41:54 <quicksilver> MartyIX: Integer -> Integer -> [(Integer,Integer)] is not the type of a lists of pairs
04:42:00 <mmorrow> , ""
04:42:02 <lunabot>  luna: lexical error in string/character literal at character '\DEL'
04:42:02 <Beelsebob1> the bottom line is -- functional programming is *hugely* inefficient if we implement it naïvely
04:42:06 <mmorrow> heh
04:42:08 <Beelsebob1> we have to be clever
04:42:11 <quicksilver> MartyIX: it is a function takeing two integers and returning a list of pairs.
04:42:14 <Beelsebob1> this is a point where cleverness is needed, even in ghci
04:42:20 <ClaudiusMaximus> i need to patch GLUT to not call 'error' when i press a mouse button that isn't one of the five blessed buttons. how do i go about this?
04:42:29 <quicksilver> Beelsebob1: except that ghci is, in fact, useful
04:42:30 <deeflex> Hi. Can anyone help me with this error message http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5960#a5960 ? I just switched to ghci from hugs. In hugs I didn't get this error.
04:42:34 <quicksilver> and has been so for many people for years
04:42:44 <quicksilver> so I dispute your point that this clever is really *needed*
04:42:44 <Beelsebob1> quicksilver: sure -- but that doesn't mean there are no bugs in it
04:43:03 <Beelsebob1> I would argue that crashing on a commonly used function is a fairly nasty bug
04:43:07 <hatds> laziness with Ints is probably more than 50% of the time I need strictness annotations
04:43:22 <quicksilver> deeflex: the error message tells you exactly what you ened
04:43:32 <quicksilver> deeflex: you need FlexibleContexts
04:43:38 <quicksilver> and possibly FlexibleInstances
04:43:39 <MartyIX> quicksilver: well the function takes list of integers and two other integers as parameters and returns list of integer pairs. So why I'm not able to show the result?
04:43:51 <quicksilver> MartyIX: that isn't the result, that it's trying to show.
04:43:53 <ClaudiusMaximus> so far i've downloaded the source with darcs, made some changes, now i guess i need to bump a version in the cabal file and try building it?
04:43:59 <quicksilver> MartyIX: if it was trying to show the eresult, you would not get that error.
04:44:02 * ClaudiusMaximus noob at cabal
04:44:18 <mmorrow> Beelsebob1: the problem i have with relying on the compiler to figure out where you really should have added a `seq` is that you're relying on it's optimizations to produce code that doesn't crash, rather than the programmer doing this.. so then your code could break if you were to use another compiler that does optimizations differently (or doesn't do them at all)
04:44:18 <quicksilver> MartyIX: nasobnosti takes three parameters.
04:44:27 <quicksilver> MartyIX: in  nasobnosti [1,1,2,2] you are only giving it one parameter.
04:44:40 <deeflex> quicksilver, ok sounded  more as an optional flag,
04:44:45 <Beelsebob1> mmorrow: sure, and the same is true of relying on the compiler to implement garbage collection well, etc
04:44:48 <MartyIX> quicksilver: damn, i'm dumb
04:44:53 <quicksilver> MartyIX: :)
04:45:00 <Beelsebob1> we rely on our compiler producing efficient code to make it useable on our computers, always
04:45:15 <deeflex> quicksilver, but how do I add that when compiling from emacs?
04:45:23 <mmorrow> Beelsebob1: that's a dubious analogy :)
04:45:30 <quicksilver> Beelsebob1: the idea of having a language standard is to be able to write a large number of programs which work on "any reasonable implementation"
04:45:33 <mmorrow> Beelsebob1: (the GC one)
04:45:42 <quicksilver> ghci and hugs are both reasonable implementaions of the standard IMO
04:45:51 <quicksilver> and it's sad that the standard "sum" doesn't work (FSOV work)
04:45:51 <Beelsebob1> quicksilver: yes, and this clearly isn't a reasonable implementation -- it can't run sum on integers
04:46:03 <quicksilver> I disagree.
04:46:11 <Beelsebob1> it's reasonable in 99.9% of respects
04:46:11 <quicksilver> I say it is "clearly" not a reasonable definition of sum.
04:46:17 <mmorrow> Beelsebob1: because "sum" as defined is broken for integers
04:46:21 <quicksilver> at least we agree somethign is unreasonable.
04:46:34 <quicksilver> deeflex: {-# LANGUAGE FlexibleContexts #-}
04:46:39 <quicksilver> as the first line in the file.
04:46:47 <Beelsebob1> mmorrow: no, sum as defined works fine on integers, as evidenced by the fact that a "reasonable" implementation (ghc -O) manages to use it just fine
04:47:01 <mmorrow> Beelsebob1: by rewriting your code for you
04:47:01 <deeflex> quicksilver, ok thanks
04:47:11 <Beelsebob1> mmorrow: that's the job of a compiler ;)
04:47:21 <Beelsebob1> it wouldn't be much use if it didn't rewrite my code
04:47:35 <mmorrow> Beelsebob1: should it rewrite "peek nullPtr" to "print \"OH HAI\"" ??
04:47:40 <hatds> this raises the question of whether there should be some formal dynamic semantics for haskell, I think
04:47:50 <mmorrow> Beelsebob1: (ignore that ;)
04:47:53 <Beelsebob1> mmorrow: no, it should be a reasonable implementation of the language's semantics ;)
04:47:55 <Twey> Heh
04:48:09 <quicksilver> I have a feeling that GHC does *not* optimise sum
04:48:11 <quicksilver> in any normal way
04:48:18 <quicksilver> it simply replaces it with sumInt
04:48:23 <quicksilver> by a specialisation RULE
04:48:28 <mmorrow> heh, probably right
04:48:29 <quicksilver> so, it completely ignores the definition.
04:48:42 <quicksilver> that sounds more like a work-around for a broken definition than a sufficiently smart optimiser, to me.
04:49:10 <Beelsebob1> I'm fairly confident after dons' comments that the strictness analyser sticks in extra $!s
04:50:13 <quicksilver> ok, it doesn't use the prelude defb
04:50:36 <quicksilver> it uses sum     l       = sum' l 0 where { sum' []     a = a; sum' (x:xs) a = sum' xs (a+x)}
04:50:48 <quicksilver> which is specially written so that the strictness analyser will work on it.
04:50:53 <quicksilver> which is, basically, cheating.
04:50:54 <LeCamarade> http://www.haskell.org/logos/poll.html How did you people skip over 104? :o(
04:50:58 <Beelsebob1> quicksilver: not really
04:51:03 <LeCamarade> Shoulda voted. 104!
04:51:11 <Beelsebob1> that's like claiming that the definition of foldr is cheeting
04:51:15 <Beelsebob1> because it uses a go function
04:51:23 <Beelsebob1> if it has the same semantics, it's not cheeting
04:51:39 <Beelsebob1> it's merely an optimisation
04:51:52 * quicksilver wonders if that does have the same semantics as foldl (+)
04:52:07 <Beelsebob1> good question that
04:53:59 <hatds> there'd be less tension with laziness if the numeric hierarchy was agreed to be for types that support "space efficient" operations.  A type that represents arbitrary symbolic expressions wouldn't be, for example.
04:54:36 <Beelsebob1> hatds: not sure I get what you mean
04:54:48 <Beelsebob1> you mean Num a should have the added constraint that it should be strict?
04:54:51 <Taejo> LeCamarade: 101 wins every time
04:55:00 <hatds> no
04:55:16 <quicksilver> sounds more like an efficiency bound
04:55:45 <LeCamarade> Taejo, Wow. I hadn't even noticed the voodoo therein.
04:56:26 <hatds> well, maybe, I don't know.  But the idea is that if we had different expectations about what is an instance of Num then we'd have different expectations about what a general 'sum' should be doing
04:57:28 <Beelsebob1> hatds: well, I for example have use lazy sum on types that really do benefit from lazyness
04:57:44 <hatds> what sort of types?
04:57:46 <Beelsebob1> I have actually used piano numbers there when I've known I'd only be dealing with small numbers in the comparisons
04:57:56 <Beelsebob1> but that the sums could end up pretty huge
04:57:57 <uzytkownik> If I have an data T = T { a :: A, b :: B, c :: C } and I have an t :: T, c' :: C is there any simple (i.e. syntax sugar) way of returning new T with changed c only?
04:59:49 <EvilTerran> uzytkownik, t { c = c' }
05:00:07 <uzytkownik> EvilTerran: Thanks
05:00:35 <MyCatVerbs> Beelsebob1: Peano? :D
05:00:44 <Beelsebob1> that, yes :P
05:01:40 <quicksilver> but given that there are no lazy numbers in the standard
05:01:44 <quicksilver> and plenty of strict numbers
05:01:59 <quicksilver> it does seem a strange choice to bias sum towards the non-existent, at the cost of the existent.
05:02:34 <Beelsebob1> quicksilver: again -- that's easily solved, add sum'
05:02:41 <Beelsebob1> or use an implementation that works
05:03:04 <JaffaCake> Baughn: there?
05:06:01 <burp> @pl (\x -> [x+1])
05:06:01 <lambdabot> return . (1 +)
05:06:15 <burp> hm, of course
05:20:10 <ski>   (:[]) . succ
05:22:16 <quicksilver> fear the succmonkey
05:27:32 <oal> anyone speaking DPH here?
05:29:09 <ikegami__> I realize that I need an ideal book which describe pit falls and the background of type system of Haskell; for mastering Haskell skills more
05:29:28 <ikegami__> How about "Complex points over Haskell" for the name of book?
05:29:58 <quicksilver> that sounds like a reference which might be understood by 50 people at most
05:30:08 <quicksilver> ...which might just about be the audience for that book :)
05:30:19 <ikegami__> (I have already finished reading the "Real World Haskell")
05:32:12 <oal> "Imaginary World Haskell" or "Ivory Tower Haskell" ;)
05:34:38 <WorkyBob> lol
05:35:53 <Cale> Probably just reading papers and documentation is the next step... along with actually using it of course
05:36:41 <EvilTerran> Take-over-the World Haskell
05:36:43 <Cale> oal: It seems cool, but I haven't really played around with it so much since I don't have a multiprocessor.
05:38:58 <Cale> oal: I think it's really the right sort of thing for large amounts of parallelism, at least so long as latency remains low, as in the SMP case.
05:39:21 <Cale> But as for how well it works today, I have no idea :)
05:40:44 <Cale> It would be interesting to see how it might work out for distributed computation with larger latencies -- whether the abstract description of what is parallel could be compiled into something reasonable, or if you'd need a different abstraction.
05:50:13 <Zao> Oh joy, I've provoked a new and amusing error from the RTS.
05:50:25 <Zao> "Segmentation fault/access violation in generated code"
05:50:55 <Twey> Impressive
05:50:59 <Twey> How did you do that?
05:51:14 <Zao> I'm leaning towards GLFW braindamage.
05:51:25 <MyCatVerbs> Are you using ForeignPtr?
05:51:42 <MyCatVerbs> Er, no. I mean, are you using FunPtr or something?
05:51:53 <Zao> This was with GLFW and a bare minimum idle loop, just pumping events.
05:52:07 <Zao> It most probably does inside. I don't, at least.
05:52:22 <Zao> This is just a bunch of IORefs in a single thread.
05:52:48 <WorkyBob> Zao: I've managed to get that out of GLFW before
05:52:52 <MyCatVerbs> Bug report time, then.
05:52:55 <WorkyBob> it's... not the best binding ever
05:52:56 <WorkyBob> >.>
05:53:32 <C-Keen> hm, I am trying to install Chart using cabal and it cannot resolve dependencies for gtk and cairo, how do I get these packages? I have cairo and gtk libs installed on this machine
05:54:00 <Zao> WorkyBob: At least it works, which is more than the HP GLUT does.
05:54:15 <Zao> For some definitions of "works".
05:54:32 <dcoutts> C-Keen: you need gtk2hs, the Haskell binding for gtk and cairo.
05:55:18 <C-Keen> dcoutts: ah figures, thanks
06:00:57 <RayNbow> hmm, there's no hawiki page for Unfold?
06:01:16 <WorkyBob> Zao: oh?
06:01:25 <WorkyBob> not had a problem with glut, but not tried the HP
06:06:09 <Zao> WorkyBob: I haven't been able to find or build a suitable glut DLL to accompany the Haskell GLUT package.
06:07:36 <WorkyBob> oh odd, that sounds like what happens with glew on windows
06:09:03 <Zao> WorkyBob: I've tried the stone-age 2001 original GLUT32 DLL, self-built MSVC and mingw freeglut-2.6.0, both with and without .def file hacked in.
06:09:19 <Zao> At best, I get "glutSetOption not found or so, check for freeglut?"
06:09:29 <Zao> Said function which freeglut exports.
06:09:57 <Zao> I haven't been able to find what glut version the haskell GLUT package in the HP is built against.
06:10:07 <Zao> I ended up cabal install'ing glfw instead.
06:10:09 <WorkyBob> which is odd... because the binding is *meant* to safely detect whether you have freeglut or not
06:10:32 <Zao> WorkyBob: I'm unsure whether freeglut is binary compatible with itself or not.
06:10:39 <WorkyBob> indeed
06:10:44 <Zao> It may be looking at the wrong ordinals or something.
06:10:54 <WorkyBob> and, much as freeglut is nicer than glut, no users will have the dlls -- I don't want to have to rely on it
06:10:56 <saml> > ordinal 1
06:10:57 <lambdabot>   Not in scope: `ordinal'
06:11:27 <saml> no user has glut32.dll anyways.
06:11:56 <Zao> > map ord "freeglut"
06:11:58 <lambdabot>   [102,114,101,101,103,108,117,116]
06:12:00 <WorkyBob> plenty of users have glut.dylib on OS X though ;)
06:12:08 <WorkyBob> and note, freeglut is near impossible to get on OS X
06:12:33 <Zao> WorkyBob: I've built it once. Not fun :)
06:12:53 <WorkyBob> yeh, indeed
06:14:23 * ski wonders what ordinals have to do with GL
06:14:30 <MyCatVerbs> WorkyBob: if you're targetting windows, just bundle the freeglut dlls with your app? Isn't that the normal practice these days anyway?
06:15:59 <saml> i'd create a livecd if the application is big
06:16:02 <Zao> MyCatVerbs: Which would have been fine and all, if you were able to build ones that work with GLUT-
06:16:29 <Zao> I like how the GLFW package bundle the library bits in the package.
06:16:36 <Zao> So you just have to cabal install and off you go.
06:36:56 <Reiv> Hrmnh.
06:37:17 <Reiv> Mind if I ask for a little guidance on where to /start/ on something? I think I may be having a conceptual issue.
06:37:57 <Reiv> http://pastebin.com/d20bcccd - the code I need to modify, and how I want to modify it. I'm a little stumped; by which I mean I'm not sure where to even start.
06:40:02 * Reiv blinks. Surprisingly quiet, even with teh time of day.
06:40:33 <Cale> I haven't slept, but I can take a look
06:41:20 <lilac> Reiv: i'd start by turning on -Wall to see where you have unhandled cases in pattern matches
06:42:50 <lilac> Reiv: in particular, in cases where you pattern match on Numeric and Boolean, you don't handle the case of ERROR
06:44:57 <Reiv> I don't? Ooh. Good to know.
06:45:14 <Reiv> But how would I go about changing ERROR to actually pass a state all the way back up?
06:45:26 <lilac> Reiv: another option might be to track down the places where you create ERROR and Error, and call 'error' there instead
06:45:48 <lilac> Reiv: for instance, on line 76
06:46:59 <Reiv> OK
06:47:24 * Reiv looks, eyes.
06:47:59 <Reiv> Er. What am I looking at?
06:48:19 <Reiv> You mean instead of resulting in an 'Error', you mean call a function 'error' that does a specific thingymabob?
06:48:56 <lilac> Reiv: line 76 is what happens if you try to read an identifier which hasn't been set yet, so calling 'error' there would seem to match the spec
06:49:23 <Reiv> Hmn.
06:49:26 <RyanT5000> what does a tilde mean in a pattern?  e.g.: fmap f ~(a `Stepper` e) = f a `stepper` fmap f e
06:49:31 <Reiv> What would 'error' do?
06:49:44 <lilac> Reiv: personally i'd be inclined to add a String to the Error constructor and pass it all the way up to the top, but calling 'error' directly would be fine too
06:49:54 <mux> RyanT5000: it means it's an irrefutable pattern
06:49:55 <Cale> RyanT5000: It means that the pattern always matches without checking.
06:49:56 <lilac> Reiv: 'error' basically causes your computation to bail out
06:50:24 <Cale> RyanT5000: and then if one of the variables in it is really needed, then it checks that the thing really matches (and throws an exception if it doens't after all)
06:50:30 <Cale> doesn't*
06:50:39 <Reiv> ...hmn.
06:50:52 <Reiv> That's cunning. Now to figure out what to put in the string.
06:50:56 * Reiv thinks.
06:51:00 <RyanT5000> Cale: thanks
06:51:16 <quicksilver> Cale: for a suitably week notion of needed.
06:51:18 <quicksilver> weak.
06:51:38 <lilac> quicksilver: or a suitably weak notion of 'really'? :)
06:52:28 <Cale> RyanT5000: So in this case, if the value of (f a) ends up being pattern matched by `stepper`, say, and then f pattern matches against a, then it will finally evaluate the thing which (a `Stepper` e) was matched against
06:54:39 <RyanT5000> Cale: alright, so basically it's making the match lazy - if it would have succeeded, then the result is equivalent to what you would have gotten if you hadn't put in the tilde
06:54:52 <Cale> yeah
06:55:01 <RyanT5000> Cale: sounds good; thanks
06:55:24 <RyanT5000> (reading conal's Reactive implementation is exposing me to lots of things i don't know, lol)
06:57:09 <Reiv> By, that didn't work
06:57:15 * Reiv thinks on it again.
06:57:31 <Reiv> ...oh. I suspect this was a silly mistake. Hrn.
07:05:54 <C-Keen> has anyone seen like this while installing Chart? Loading package gtk-0.10.1 ... <command line>: can't load .so/.DLL for: freetype (dlopen(libfreetype.dylib, 9): image not found)
07:06:18 <C-Keen> I have installed gtk2hs in my ~/./cabal dir
07:11:38 <hatds> hmm.. cost centers inserted by 'auto' cannot be replicated by inserting cost centers by hand?
07:20:30 <Jedai> C-Keen: that seems more like a problem of freetype than Chart or gtk2hs
07:20:45 <Jedai> What's your OS ?
07:20:57 <C-Keen> Jedai: Mac OS X
07:21:04 <C-Keen> (10.5)
07:21:49 <Jedai> sorry, I've never used a Mac except occasionally (and often with MacOS 9)
07:22:47 <Jedai> C-Keen: it seems it don't manage to find the shared lib for libfreetype, it would be interesting to check where it is
07:23:02 <Jedai> if you really have it
07:24:33 <Jedai> and maybe a run of ldconfig would help ?
07:34:40 <C-Keen> Jedai: I got two of them, both with the same versions located in /usr/X11R6/lib and /opt/local/lib (from macports)
07:37:33 <^Someone^> > 1/0
07:37:35 <lambdabot>   Infinity
07:38:33 <davidL> :t typeOf
07:38:34 <lambdabot> forall a. (Typeable a) => a -> TypeRep
07:41:55 <Philonous> Is it good practice to "emulate" global variables by Adding a readerT or StateT respectively and feeding it a record containing all the "global variables" one would have? Accessing a variable via "<accessor> global" seems pretty nifty to me because it immediately shows where the data comes from
07:43:32 <byorgey> Philonous: yes, that's a very common design pattern
07:43:55 <Philonous> Great, thanks
07:44:18 <byorgey> but you wouldn't say  "<accessor> global", you would say something like  "gets <accessor>"
07:44:28 <byorgey> but that still makes it obvious where it comes from
07:44:39 <byorgey> or "asks" instead of "gets" if you use ReaderT
07:46:29 <quicksilver> for a sufficiently complex system I prefer thinks like "getTheWidget"
07:46:39 <quicksilver> i.e. custom "primitives" for your custom monad.
07:46:52 <quicksilver> abstracts away from the precise type of the state being stored.
07:46:58 <quicksilver> but in general, yes, what byorgey said.
07:47:27 <byorgey> ah, indeed, I prefer that too
07:47:43 <wjt> one problem I have with that idiom is that I have to think of a name for the retrieved 'global' which is different to that of the accessor
07:47:53 <byorgey> even using something like data-accessor
07:47:59 <dmwit> wjt: Add an underscore. ;-)
07:48:14 <dmwit> wjt: Something predictable is great for both lubing the writing process and easing the reading process.
07:48:36 <wjt> dmwit: oh, that's what I do
07:48:40 <wjt> dmwit: but it still annoys me
07:48:44 <dmwit> yeah
07:48:58 <dmwit> Well, you could always just give it the *same* name as the accessor.
07:49:09 <tomahawk> Boum ! Boum ! Boum ! Boum ! Boum ! Boum ! Boum ! Boum ! Boum ! Boum ! Boum ! Boum ! Boum ! Boum ! Boum ! Boum ! Boum !.
07:49:11 <dmwit> Then it becomes a shadowing binding, and makes things just that much more confusing. =)
07:49:12 <tomahawk> Boum ! Boum ! Boum ! Boum ! Boum ! Boum ! Boum ! Boum ! Boum ! Boum ! Boum ! Boum ! Boum ! Boum ! Boum ! Boum ! Boum !
07:49:18 <wjt> nah, that triggers the shadowing warning, which has saved my bacon a bunch of times
07:49:38 <wjt> although I end up 'importing Prelude hiding (log)' quite a lot because of the shadowing warning :-)
07:53:22 <dino-> I think so, sorry to be obsessive
07:53:32 <dino-> mischannel
07:53:37 <quicksilver> wjt: it helps slightly to think of one as the operation which goes and gets the current value
07:53:53 <quicksilver> wjt: and the other as a name you've given to the value at a point in time
07:53:57 <dino-> Oh hey, I wanted to mention that I'm becoming obsessively obsessed with Arch.
07:54:00 <quicksilver> theWidget <- getTheWidget
07:54:14 <dino-> So much Haskell activity there.
07:54:15 <wjt> quicksilver: indeed, but that involves writing n accessors
07:54:34 <quicksilver> wjt: sure enough
07:54:40 <quicksilver> doesn't bother me much
07:54:45 <quicksilver> it's sometimes not just boilerplate anyway
07:54:58 <quicksilver> maybe 'getTheWidget' has to synchronise the Fudget first
07:55:16 <quicksilver> after, you'd never have a consistent widget if your fudgets were unsyncrhonised.
07:55:26 <quicksilver> i.e. I think of them as smart accessors, not just accessors - they might be doing housekeeping.
07:56:41 <wjt> right, but it does increase the overhead of correctness
07:58:38 <bastl> Hi im reading the source of Data.Typeable and wonder what "Key" and "KeyPr" are. Hoogle tells me nothing about that.
07:58:39 <wjt> relatedly, i used something inspired by your "monadic tunneling" article for gtk callbacks, and it works well, but the embedIO/makeCallback noise is annoying
07:58:56 <saml> @hoogle Typeable
07:58:57 <lambdabot> module Data.Typeable
07:58:57 <lambdabot> Data.Typeable class Typeable a
07:58:57 <lambdabot> Data.Typeable class Typeable1 t
07:59:41 <quicksilver> wjt: yeah. I think my idea was you'd hide that noise behind something a bit higher level
07:59:47 <quicksilver> wjt: but, I never played with it enough to be sure.
07:59:51 <quicksilver> wjt: I'm glad it works though :)
08:00:31 <saml> data KeyPr = KeyPr !Key !Key deriving( Eq )
08:00:31 <saml>    -- what is ! ?
08:00:32 <bastl> @Hoogle KeyPr
08:00:32 <lambdabot> Maybe you meant: google hoogle
08:00:52 <saml> eager eval?
08:01:01 <dmwit> yes
08:01:11 <bastl> on types?
08:01:32 <bastl> @hoogle Key
08:01:33 <lambdabot> Data.IntMap type Key = Int
08:01:33 <lambdabot> Text.XHtml.Frameset keyboard :: Html -> Html
08:01:33 <lambdabot> Text.XHtml.Strict keyboard :: Html -> Html
08:01:36 <saml> KeyPr is data constructor
08:01:57 <kpreid> saml: strictness. It means that KeyPr foo undefined = undefined
08:02:10 <saml> KeyPr 1 2 == KeyPr `seq` 1 `seq` 2?
08:02:35 <wjt> quicksilver: indeed. :) although it also gets interesting if you want your monad to be a MonadState
08:02:39 <kpreid> No, KeyPr 1 2 == let x = 1; y = 2 in x `seq` y `seq` KeyPr x y
08:03:01 <kpreid> hm
08:03:07 <kpreid> @src ($!)
08:03:07 <wjt> quicksilver: because modify is implemented in terms of 'get' and 'set', you can't actually make it atomic even if you use an MVar to tunnel your state
08:03:08 <lambdabot> f $! x = x `seq` f x
08:03:18 <kpreid> Right... So KeyPr $! 1 $! 2
08:03:47 <quicksilver> wjt: yes. you have to forbid using 'set'
08:04:03 <quicksilver> wjt: 'get' is permissible as long as the user understands it might be out of date as soon as you get it.
08:04:13 <quicksilver> better is to use modify
08:04:17 <quicksilver> or some 'with' construct.
08:04:22 <wjt> quicksilver: so you need to do something like statefully :: FooWithState a -> Foo a; statefully act = do { s <- takeMVar =<< gets state; blah <- runStateT ....; putMVar newState }
08:04:35 <wjt> quicksilver: you can't use modify because it's implemented in terms of get and set
08:04:44 <quicksilver> wjt: I meant the API of modify
08:04:49 <wjt> quicksilver: right, right
08:04:49 <quicksilver> rather than its implementation
08:05:03 <quicksilver> I always thought modify was a method so you could, in fact, override it
08:05:10 <wjt> @src modify
08:05:10 <lambdabot> Source not found. Are you on drugs?
08:05:16 <wjt> @src State modify
08:05:16 <lambdabot> Source not found. You type like i drive.
08:05:16 <quicksilver> I'm wrong.
08:05:21 <quicksilver> It's just what I thought.
08:05:28 <wjt> it's what I hoped too :)
08:05:53 <wjt> but yeah, as you suggest, I think you'd need to abstract away Gtk a bit to get rid of the noise
08:05:59 <wjt> but it does work
08:11:29 <bastl> what does appKey do?
08:11:34 <bastl> @src appKey
08:11:34 <lambdabot> Source not found. You type like i drive.
08:11:51 <Philonous> It would be good to have something like TeX for GUIs. You specify what kind of Input/Output fields you want and provide the functionality, the library takes your requests and builds widgets out of it
08:12:49 <dmwit> Philonous: Have you checked out any of the FRP-based GUI stuffs?
08:12:58 <bastl> appkey is in the very bottom of http://tinyurl.com/5l2oyh What does it do ?
08:13:26 <Philonous> dmwit: Actually not. Does that do that? Where should I start looking?
08:13:28 <Saizan> Philonous: that sounds like conal's GuiTV
08:13:39 <dmwit> http://haskell.org/haskellwiki/Phooey for example, or http://haskell.org/haskellwiki/Grapefruit or http://haskell.org/haskellwiki/GuiTV
08:13:47 <Philonous> Ah, tanks
08:15:28 <quicksilver> bastl: it's just a fiddly way of trying to generate a unique code for each type
08:15:42 <quicksilver> it's pretty horrid, to be honest.
08:18:12 <bastl> no, i dont understand, it gets two keys and produces a key. keys are to represent types (or tycons? ). It looks some kind of Hashing !?
08:20:05 <quicksilver> bastl: it's not hashing, as far as I know, it's just generating new unique IDs
08:20:14 <quicksilver> bastl: what is your interest in this code?
08:20:42 <bastl> i wrote an instance for Typeable8 and want to understand why it works :-)
08:20:48 <bastl> (it does at least)
08:21:20 <quicksilver> the generic code is just using an IORef of Ints
08:21:30 <quicksilver> and generating fresh ones when things are not already in the cache
08:21:38 <quicksilver> the GHC specific code calls 'genSym' instead.
08:22:12 <bastl> @hoogle genSym
08:22:13 <lambdabot> No results found
08:22:47 <Philonous> The problems with pull-style GUIs (idle loops or permanent recomputation) sound like they can be easily remedied with MVars. But you can't use haskell threads with GTK, or can you?
08:23:08 <bastl> no, i wont understand that.
08:23:50 <bastl> the more interesting thing is how typeOfNDefault works...
08:24:01 <bastl> @src typeOf3Default
08:24:01 <lambdabot> Source not found. I feel much better now.
08:24:13 <bastl> @hoogle typeOf3Default
08:24:14 <lambdabot> Data.Typeable typeOf3Default :: (Typeable4 t, Typeable a) => t a b c d -> TypeRep
08:24:40 <quicksilver> Philonous: yes, you can, you just have to be careful.
08:34:56 <Baughn> JaffaCake: Here
08:47:29 <Kashyap> Is there someone out there doing some project using Haskell CGI?
08:47:42 <Kashyap> preferably with dojo as well?
08:48:08 <hackagebot> pureMD5 1.0.0.0 - MD5 implementations that should become part of a ByteString Crypto package. (ThomasDuBuisson)
08:49:55 <Kashyap> Are there only 2 people chatting right now?
08:50:10 <Vq^> @users
08:50:10 <lambdabot> Maximum users seen in #haskell: 658, currently: 622 (94.5%), active: 13 (2.1%)
08:50:35 <Kashyap> oh okay
08:50:43 <Sup3rkiddo> !2b
08:51:06 <hatds> the OS already is a mvar, basically.  If your GUI program is poll based then you've intentionally broken out of that structure and into endless loop.  Using real mvars to go back seems odd
08:51:56 <Vq^> Kashyap: to answer your question, it's probably safe to assume that someone is using Haskell CGI
08:53:54 <Kashyap> oops ... my question was rather vague .. I am about to start on a project using Haskell CGI and Dojo for the browser side .... just wanted to bounce this combo off someone who's done it
08:56:11 <jimmyjazz14> Kashyap: I just started a project using happstack
08:56:12 <Kashyap> @users
08:56:13 <lambdabot> Maximum users seen in #haskell: 658, currently: 628 (95.4%), active: 14 (2.2%)
08:56:17 <quicksilver> Kashyap: I've used haskel CGI for a couple of throwaway hacks
08:56:18 <quicksilver> it's fine
08:56:24 <quicksilver> no differnet from CGI in any other language, really ;)
08:56:59 <dmwit> What, Haskell is no better than other languages for some particular task!
08:57:03 <dmwit> Hang the heretic!!
08:57:51 <Kashyap> Thanks quicksilver .... so, I've used perl to do CGI and I thought, it worked prrtty well ... and with Haskell I see huge performance gain .....
08:58:14 <Kashyap> so, why would I not use Haskell CGI for things other than quick hacks?
08:58:33 <quicksilver> dmwit: well, I meant the CGI parts were no different
08:58:37 <quicksilver> of course the other parts were good
08:58:49 <quicksilver> Kashyap: a compiled haskell app generally loads quite a bit faster than perl
08:58:51 <quicksilver> so that's good.
08:59:32 <iago> CGI...
08:59:36 <iago> uf
08:59:53 <Kashyap> right!! ... and I wanted to write some Hskell modules to create Dojo templates ..... meaning, refrain from writing javascript by hand and use Haskell for that .... similar to GWT
09:00:10 <quicksilver> ah well, that's cleverer.
09:00:25 <quicksilver> someone wrote a whole shebang for clever javascript generation
09:00:29 <quicksilver> it might have been mmorrow
09:00:35 <quicksilver> sounds like the kind of evilness he would wreak.
09:01:12 <Kashyap> Is there a way I can look for it? do I google/hoogle on mmorrow?
09:01:17 * copumpkin is back
09:01:38 <Paczesiowa> Kashyap: look on hackage for javascript
09:02:13 <Kashyap> okay ... thanks folks .... I love Haskell and I love Haskellers ... thanks ... I'll visit this channel regularly!!!!
09:02:26 <mmorrow> Kashyap: i have a darcs repo (actually, more than once since i needed to modify WebBits's parser..). one sec
09:02:40 <Kashyap> sure
09:02:40 <jmcarthur_work> Kashyap, we love you too!
09:02:48 <mmorrow> Kashyap: (i haven't touched this code in a while, but it should work)
09:03:08 <mmorrow> quicksilver: evilness++
09:03:12 <walter_> where is the constructor ":" in  comprehensive xs ys = [(x, y) | x <-xs, y <-ys], how can ghc know x is a part of xs?
09:03:26 <quicksilver> mmorrow: wreaking++
09:03:39 <kpreid> walter_: it's buried in "<-"
09:03:58 <Kashyap> should I wait mmorrow?
09:04:03 <walter_>  buried?
09:05:05 <iago> x <- xs "for each x in xs"
09:05:17 <jmcarthur_work> [(x, y) | x <-xs, y <-ys] == do x <- xs; y <- xs; return (x,y)
09:05:24 <jmcarthur_work> @undo do x <- xs; y <- xs; return (x,y)
09:05:24 <lambdabot> xs >>= \ x -> xs >>= \ y -> return (x, y)
09:05:26 <mmorrow> Kashyap: ok, here's the repo, but looking at the deps i see that it needs haskell-src-meta (and so also haskell-src-exts) before haskell-src-exts updated its entire api, so that may be a slight pain, but anyways:  http://moonpatio.com/repos/js-qq/
09:05:46 <mmorrow> i should update that package
09:05:51 <jmcarthur_work> ^^ is also the same as liftA2 (,) xs ys
09:05:59 * mmorrow puts it on the long list of things to do
09:06:09 <Kashyap> Thanks mmorrow
09:06:13 <lilac> ^^ also same as zipWith (,) xs ys
09:06:15 <mmorrow> Kashyap: no problem
09:06:20 <jmcarthur_work> lilac, :)
09:06:24 <jmcarthur_work> err
09:06:27 <jmcarthur_work> no, not right
09:06:39 <lilac> jmcarthur_work: d'oh
09:06:43 <jmcarthur_work> > liftA2 (,) [1..3] [4..6]
09:06:44 <lilac> wrong list monad ;-)
09:06:44 <walter_> iago, got it. I didnt find the explaination in Real World Haskell
09:06:44 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
09:06:49 <jmcarthur_work> > zipWith (,) [1..3] [4..6]
09:06:50 <lambdabot>   [(1,4),(2,5),(3,6)]
09:06:54 <jmcarthur_work> yup
09:07:02 <jmcarthur_work> actually ZipList isn't even a monad
09:07:06 <lilac> > liftA2 (,) (ZipList [1..3] [4..6])
09:07:08 <lambdabot>   Couldn't match expected type `[t] -> f a'
09:07:14 <lilac> > liftA2 (,) (ZipList [1..3]) (ZipList [4..6])
09:07:16 <lambdabot>   No instance for (GHC.Show.Show
09:07:16 <lambdabot>                     (Control.Applicative.Zip...
09:07:26 <jmcarthur_work> > getZipList $ liftA2 (,) (ZipList [1..3]) (ZipList [4..6])
09:07:28 <lambdabot>   [(1,4),(2,5),(3,6)]
09:07:42 <jmcarthur_work> i don't get why it has no Show instance
09:07:46 <iago> walter_, well, the real explanation is what jmcarthur saids, but you can think in it like "for each" if it helps you right now
09:08:05 <quicksilver> mmorrow: I wonder how your stuff compares to nibro's
09:08:09 <mmorrow> hmm, that reminds me.. i've got a happy JS parser someone which a crapload of reduce/reduce errors that i could probably fix now that i'm somewhat proficient with happy
09:08:17 <quicksilver> mmorrow: HJavascript which is layered on HJScript or is it the other way around.
09:08:17 <mmorrow> quicksilver: nibro's :)
09:08:26 <quicksilver> ?
09:08:28 <lilac> jmcarthur_work: not a monad, but it is at least an applicative functor :-)
09:08:35 <jmcarthur_work> yes
09:09:01 <mmorrow> quicksilver: ahh, oh yeah. i've looked at that. he's going for a GADT to use to (use it's constructors to) write type-correct (subset of) JS code
09:09:31 <walter_> iago, I see. In fact I dont understand of x <-xs, now I understand. Thanks you all
09:09:40 <quicksilver> mmorrow: yes.
09:09:48 <mmorrow> quicksilver: but there's no reason why a js QQ couldn't parse the code to (TH that evals to) his GADT
09:09:51 <mmorrow> but...
09:09:59 <mmorrow> TH doesn't have a rep for GADTs :(
09:10:10 <mmorrow> (and you can't parse to a GADT from a String)
09:10:34 <mmorrow> because that would mean you have some sort of dependent types
09:11:14 <Saizan_> you can wrap the GADT in an existential, and pattern match later
09:11:43 <mmorrow> Saizan_: hmm, i'd not considered that.. that'd be sweet if it worked
09:12:08 <mmorrow> err, but do you just unsafeCoerce stuff out... how would that work?
09:12:27 <Saizan_> no unsafeCoerce
09:12:50 <mmorrow> because the type of the the resulting function would depend on the *value* inside the box..
09:13:08 <mmorrow> Box -> JsGadt a
09:13:10 <Saizan_> parse :: String -> (forall a. YourGADT a -> r) -> r
09:13:31 <mmorrow> but we want the /result/ to be YourGADT
09:13:36 <mmorrow> (don't we?)
09:14:02 <Saizan_> you're going to do something with YourGADT sometime, i hope :)
09:14:19 <mmorrow> Saizan_: hmm
09:14:37 <Saizan_> and when you pattern match you probably get more information about 'a'
09:14:50 <mmorrow> Saizan_: yeah, i see how this could possibly work nicely
09:15:53 <mmorrow> Saizan_: thinking about it, this would totally work. :)
09:16:28 <Saizan_> if you don't like the CPS style you can use data ExtWrapper = forall a. EW (YourGADT a)
09:16:29 <mmorrow> essentially you're just using cps to never have to specify the result type
09:16:44 <mmorrow> cps++
09:16:52 <Saizan_> and parse :: String -> ExtWrapper
09:17:25 <mmorrow> ah, that could be nice too, because then you could make ExtWrapper an instance of Show
09:18:14 <jmcarthur_work> you could?
09:18:15 <mmorrow> (which is crucial for debugging/seeing stuff like this in my opinion)
09:18:36 <jmcarthur_work> oh, data ExtWrapper = forall a . Show a => EQ (YourGADT a)
09:18:36 <mmorrow> jmcarthur: import Unsafe.Coerce if that's what it comes too, but i'm not sure if you'd have to
09:19:02 <mmorrow> jmcarthur: oh, yeah assuming that everything in the cons of the GADT are showable
09:20:11 <mmorrow> http://hackage.haskell.org/packages/archive/HJavaScript/0.4.4/doc/html/Language-HJavaScript-Syntax.html#t%3AExp
09:20:50 <mmorrow> hmm, although iirc they use Show for the GADT to prettyprint..
09:20:52 <mmorrow> grrrrr
09:21:51 <jmcarthur_work> GADTs are awesome, but they sure can make things messy
09:22:03 <mmorrow> quicksilver: heh, actually (assuming that TH did have a rep for GADTs), you'd be parsing the js String to TH which evals to TH which evals to the GADT.. :)
09:22:34 <mmorrow> (the first level of TH being for the QQ, the second being to make the GADT)
09:23:34 <mmorrow> jmcarthur_work: yeah definitely
09:28:56 <quicksilver> jmcarthur_work: I view GADTs as experimental
09:28:58 <quicksilver> but that's pretty subjective
09:29:12 <quicksilver> mostly it reflects the fact that quicksilver has not yet experimented with them sufficiently.
09:29:42 <quicksilver> certainly GADT is better than Dynamic with "case typeOf t of .... "
09:34:04 <Paczesiowa> are gadts like closed type classes?
09:34:50 <quicksilver> no
09:34:59 <quicksilver> because gadts are types, and type classes are not types.
09:35:19 <quicksilver> A better question might be "Can you do some of the things with GADTs which people wanted to do with closed type classes" ?
09:35:23 <quicksilver> I think the answer to that is yes ;)
09:35:30 <hatds> like what?
09:35:46 <quicksilver> well consider a GADT "Foo a"
09:35:55 <quicksilver> that induces a property of types "a"
09:36:16 <quicksilver> being : a can occur under Foo
09:36:33 <quicksilver> but the set of a which can occur under Foo is determined inductively by the structure of the GADT
09:36:38 <quicksilver> rather than being open like a typeclass.
09:36:55 <quicksilver> a value of type "Foo a" is something like a proof that 'a' can occur under Foo
09:37:06 <quicksilver> so it's something like a proof that 'a' is a member of a closed class.
09:37:17 <quicksilver> (of course, _|_ screws this up but maybe that doesn't matter)
09:37:41 <quicksilver> you explore the proof by pattern matching.
09:37:42 <hatds> I see, so the thing that people were trying to replicate with typeclasses is through the instance structure
09:38:27 <hackagebot> hxt 8.3.1 - A collection of tools for processing XML with Haskell. (UweSchmidt)
09:39:47 <Paczesiowa> quicksilver: is there any use for gadts than cannot be translated to typeclasses?
09:45:24 <MartyIX> Is there any way how to compute the number of k-tuples if I have elements 1 to 9 and for every element I have number which says how many times it may maximally occurs. Example 1,1,2,3 (I have two elements of type 1, one element of type 2 and so on).
09:46:30 <quicksilver> Paczesiowa: everything can be translated to everything else.
09:46:41 <quicksilver> Paczesiowa: haskell can be translated to lisp, or C, or javascript.
09:46:50 <MartyIX> I don't see a way how to "construct" such tuples. So I think there must an other way how to do that
09:46:54 <quicksilver> so interesting questions have to be a bit more specific.
09:46:56 <hatds> Paczesiowa: you might want to check out the common GADT example for representing expressions of an embedded language
09:47:39 <quicksilver> hatds: in particular, GADTs let you reify a fixed set of types.
09:47:49 <Paczesiowa> hatds: I've seen them all and still prefer typeclass magic.
09:47:51 <quicksilver> hatds: in a way which is guaraneteed to be "in sync" between type and value level.
09:48:10 <Paczesiowa> quicksilver: "in sync"?
09:48:15 <quicksilver> hatds: data Foo a where FooInt :: Foo Int; FooDouble :: Foo Double; etc...
09:48:31 <hatds> > group [1,1,2,3]
09:48:33 <lambdabot>   [[1,1],[2],[3]]
09:48:36 <quicksilver> so you get symbol value constructors - which can be cased on - which reify types which they have included in their own types.
09:48:53 <hatds> > map (\xs -> (head xs, length xs) $ group [1,1,2,3]
09:48:55 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
09:49:03 <hatds> > map (\xs -> (head xs, length xs)) $ group [1,1,2,3]
09:49:05 <quicksilver> not that I'm not actually storing values.
09:49:05 <lambdabot>   [(1,2),(2,1),(3,1)]
09:49:12 <hatds> MartyIX: like that?
09:49:47 <quicksilver> This is a bit like class Typeable where typeOf :: a -> TypeRep; data TypeRep = FooInt | FooDouble; instance Typeable Double where typeOf _ = FooDouble;
09:49:57 <quicksilver> except that the GADT one is closed.
09:51:13 <MartyIX> hatds: Actually no. I ment the question as an mathematical problem. You have list of length k and you want to place numbers so that you don't exceed any number of elements you have and the question is how many different lists like this exists.
09:53:45 <lilac> MartyIX: you could figure out the different combinations of numbers of each element, then it should be trivial
09:54:48 <lilac> ... but i guess you're looking for an efficient way to do it?
09:55:16 <MartyIX> lilac: yes it should be efficient because it's kind of core for my program
09:56:33 <lilac> MartyIX: how big is k, and how large are your number-of-element limits (and the sum of them)?
09:56:56 <lilac> (just as a ballpark so we'll know how fast is 'good enough')
09:57:39 <hatds> sounds like multinomial coefficients
09:58:38 <lilac> hatds: it's more complex than that because the number of elements can be greater than k
09:58:41 <MartyIX> lilac: number of different elements is 9 and I need an efficient solution for k = 1 to k = sum of all elements I have
09:59:07 <lilac> MartyIX: how big can the per-element limits be?
10:00:20 <MartyIX> lilac: well the problem is about multisets and let's suppose 10 for every element
10:01:25 <hatds> for unordered lists this has a generating function solution I think
10:02:28 <MartyIX> lilac: I would rather to compute the result than try possibilities but I tried to think about it from different viewpoints but nothing led to a good solution
10:02:40 <lilac> MartyIX: the solution i originally suggested might just be fast enough
10:03:55 <lilac> MartyIX: start with the element limits, say [3,5,1,9], and let's assume k = 6. then you could have [3,1,0,0],[3,0,1,0],[3,0,0,1],[2,2,0,0],[2,1,1,0],...
10:04:30 <lilac> MartyIX: for each of those, working out how many such forms exist is easy (it's k! divided by the factorial of each of the groups)
10:04:47 <Philonous> I wonder, what's the motivation for Arrow? It generalizes pairwise application of functions. But why does that give rise to a whole new class?
10:04:51 <lilac> note that [3,1,0,0] has the same number as [3,0,1,0] so you can avoid recomputation there
10:06:36 <lilac> Philonous: Arrow allows for the expression of computations where the structure is fixed in some sense. conceptually it's pretty similar to Applicative
10:07:17 <Saizan_> and you can exploit that structure to perform some transformations on the computation to be run, before actually running it
10:07:40 <lilac> i think the typeclass exists as it is, principally to support proc notation
10:09:13 <jmcarthur_work> @instances Arrow
10:09:14 <lambdabot> (->), Kleisli m
10:09:28 <Philonous> Is there a paper that shows some application of Arrow?
10:09:46 <lament> paper? applications? :)
10:09:54 <lilac> @where promiscuous
10:09:55 <lambdabot> I know nothing about promiscuous.
10:10:15 <lilac> http://homepages.inf.ed.ac.uk/wadler/papers/arrows-and-idioms/arrows-and-idioms.pdf
10:10:35 <lilac> don't know if that has applications, but it has some useful background
10:10:47 <hackagebot> bindings-common 0.1.4 - Low-level library bindings, base package. (MauricioAntunes)
10:10:58 <Philonous> Thanks
10:11:17 <jmcarthur_work> Philonous, here is another application of arrows, but i'm not very familiar with it http://www.fh-wedel.de/~si/HXmlToolbox/
10:11:39 <Philonous> Thanks again
10:11:41 <MartyIX> lilac: well yes I'll try if I won't find another way. Thanks! :)
10:11:57 <lilac> MartyIX: it's an interesting problem, good luck with it!
10:12:55 <MartyIX> lilac: half a day is gone and no big progress so interesting it is :-))
10:13:23 <Alpounet> still no neural nets wizard in here ?
10:13:34 <jmcarthur_work> my opinion of arrows is that they are probably insanely useful, but are too complex to understand that usefulness for most possible applications, and are often more general than necessary anyway
10:14:17 <jmcarthur_work> it would be nice to be able to trim down some of the Arrow laws and maybe subdivide it into some smaller classes or something, if that is possible
10:14:34 <jmcarthur_work> might be easier to see the patterns in non-arrow code and make an abstraction that way
10:14:45 <jmcarthur_work> but i haven't looked into how such a thing could be done
10:15:03 <lilac> jmcarthur_work: Arrow is already pretty divided up (see ArrowChoice, etc)
10:15:08 <jmcarthur_work> we have already taken Category out of Arrow, which is a start
10:15:34 <jmcarthur_work> lilac, but those are dependent on Arrow, which means they are even _more_ complicated
10:15:45 <lilac> hehe :)
10:15:50 <jmcarthur_work> i mean make some more type classes that the existing Arrow itself would be dependent on
10:16:25 <jmcarthur_work> but still, i don't know what subdivisions to make
10:16:59 <jmcarthur_work> all i know is that arrow has a lot of laws, implying that it doesn't really apply to as many things as it might with fewer laws
10:26:26 <jmcarthur_work> maybe a type class dependent on Category that only adds the arr function
10:26:39 <jmcarthur_work> excluding first, second, (***), (&&&)
10:29:04 <pumpkin> > arr matey "shiver me timbers"
10:29:05 <lambdabot>   "shiver me timbers"
10:29:29 <lilac> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5971#a5971
10:29:38 <lilac> ^^ are Arrow and Applicative really the same thing?
10:29:57 <jmcarthur_work> :t matey
10:29:58 <lambdabot> forall a. a -> a
10:30:25 <pumpkin> lilac: Control.Arrow has pure? I thought that was removed a while ago
10:30:36 <lilac> pumpkin: i'm on 6.8.2 :-)
10:30:41 <pumpkin> ah
10:31:09 <jmcarthur_work> lilac, you can actually derive an arrow for any monad, it wouldn't surprise me if that is generalized for any applicative
10:31:13 <jmcarthur_work> they aren't the same thing though
10:31:20 <jmcarthur_work> you may have an arrow that is not applicative
10:31:22 <jmcarthur_work> oh wait
10:31:32 <jmcarthur_work> huh, interesting
10:31:36 <jmcarthur_work> i wonder if the laws all hold
10:32:23 <lilac> jmcarthur_work: it's well-known that the 'static arrow' i presented is an arrow for any applicative
10:32:51 <jmcarthur_work> well, not known by me!
10:33:45 <lilac> jmcarthur_work: i /think/ that 'newtype Arrow a => X a b = X (a () b)' is an applicative too
10:34:22 <lilac> jmcarthur_work: http://www.haskell.org/arrows/, very bottom, mentions this in passing
10:35:00 <jmcarthur_work> well, the () in there means they aren't 100% the same, really, doesn't it?
10:35:07 <lilac> yes, it does, that's quite a limitation
10:35:18 <lilac> but viewing arrows as a generalization of applicatives is probably quite useful
10:35:37 <jmcarthur_work> yeah
10:35:54 <jmcarthur_work> do all the other Arrow* classes generalize applicatives too, do you know?
10:36:03 <jmcarthur_work> perhaps some of them require monad
10:37:24 <flipflap> @src intercalate
10:37:24 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
10:38:08 <flipflap> @src intersperse
10:38:08 <lambdabot> intersperse _   []     = []
10:38:09 <lambdabot> intersperse _   [x]    = [x]
10:38:09 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
10:38:44 <lilac> jmcarthur_work: well, ArrowZero and ArrowPlus are essentially MonadPlus. AFAIK there's no FunctorPlus other than Monoid...
10:39:23 <lilac> ArrowChoice is equivalent to Monad
10:39:43 <flipflap> @src stripPrefix
10:39:43 <lambdabot> Source not found. Maybe if you used more than just two fingers...
10:39:50 <jmcarthur_work> Alternative
10:39:57 <jmcarthur_work> == MonadPlus
10:40:41 <flipflap> Why is my Debian's GHC missing stripPrefix in it's Data.List?
10:41:36 <lilac> jmcarthur_work: it looks like you could easily implement ArrowChoice for the static arrow of an Applicative, though...
10:41:50 <jmcarthur_work> yeah
10:42:02 <jmcarthur_work> err
10:42:09 <SamB> flipflap: perhaps it's rather new ?
10:42:11 <jmcarthur_work> i misread Applicative as Alternative
10:42:13 <flipflap> Meh
10:42:13 <SamB> stripPrefix, I mean
10:42:17 <flipflap> Debian 4.0 Etch
10:42:22 <flipflap> Just installed GHC here
10:42:45 <flipflap> > stripPrefix ':' ":Test"
10:42:46 <lambdabot>   Couldn't match expected type `[a]'
10:42:51 <flipflap> > stripPrefix ":" ":Test"
10:42:52 <lambdabot>   Just "Test"
10:42:55 <flipflap> > stripPrefix ":" "Test"
10:42:57 <lambdabot>   Nothing
10:44:19 <lilac> jmcarthur_work: oops, ArrowApply requires Monad, ArrowChoice does not
10:44:51 <jmcarthur_work> lilac, sorry to say, i'm only barely paying attention anyway
10:46:39 <lilac> jmcarthur_work: i don't blame you :-)
11:35:29 <Fred320> @pl \a b -> (concat $ zipWith (\x y -> [x,y]) a b)
11:35:30 <lambdabot> (join .) . zipWith ((. return) . (:))
11:35:40 <Baughn> So I ran into an interesting encryption scheme today. There /has/ to be a problem here somewhere, but I can't spot it..
11:36:21 <Baughn> Basically, you take the key, add a counter (so it works in counter-mode only), then hash the sum. Then you xor that with your plaintext.
11:36:37 <Baughn> Decryption does the exact same thing, of course. So, where's the hole?
11:37:28 <lament> is your key the length of your plaintext?
11:37:29 <Gracenotes> :o
11:37:43 <Baughn> lament: No, it's a standard block/stream cipher
11:38:26 <lament> how do you xor with key with the plaintext?
11:38:39 <Baughn> One block at a time. That's what the counter is for.
11:38:43 <Baughn> Umh.
11:38:55 <pstickne> "good enough" :)
11:39:02 * pstickne sighs
11:39:11 <Baughn> encrypt block = block `xor` hash (key + blockNum)
11:39:18 <Philonous> If your hashing algorithm is strong enough that sounds ok
11:39:34 <Baughn> I'm starting to think it should work, it just seems so unusual..
11:39:52 <Philonous> Well, it is open to a chosen plaintext attack of course
11:39:54 <lament> it sounds like the actual encryption happens in the hashing algorithm
11:40:26 <Philonous> If you know the plaintext and the encrypte text you can just xor them and retrieve the key.
11:40:28 <Fred320> Is there a built-in function that does this?
11:40:28 <Fred320> combine [] _ = []
11:40:28 <Fred320> combine _ [] = []
11:40:28 <Fred320> combine (x:xs) (y:ys) = x:y : combine xs ys
11:40:51 <Baughn> Philonous: That shouldn't work, since the key gets hashed
11:40:54 <lament> Philonous: retrieve the hash
11:41:01 <gwern> Fred320: zip?
11:41:33 <gwern> well, it's kind of like zip. hm.
11:41:42 <gwern> @hoogle (a,a) -> [a]
11:41:43 <lambdabot> Data.Ix range :: Ix a => (a, a) -> [a]
11:41:43 <lambdabot> System.Random randomRs :: (Random a, RandomGen g) => (a, a) -> g -> [a]
11:41:43 <lambdabot> Prelude snd :: (a, b) -> b
11:41:44 <Fred320> I don't think zip can make a list thats longer than the originals
11:41:52 <Philonous> Ok, i misinterpreted "add the counter", but still, the hashes are enough to decrypt
11:42:32 <gwern> Fred320: I was thinking one could zip the two lists together, since zip :: [a] -> [a] -> [(a,a)], and then turn the [(a,a)] into [a]
11:42:55 <Fred320> comb xs ys = concat $ zipWith (\x y -> [x,y]) xs ys
11:42:59 <Fred320> But that looks overly complicated
11:43:06 <gwern> @hoogle [a] -> [a] -> [a]
11:43:07 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
11:43:08 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
11:43:08 <lambdabot> Data.List deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
11:43:38 <Baughn> Philonous: Right, so you'd add a random number to the key as well, per-stream, if you reuse the key
11:43:42 <Gracenotes> comb xs ys = zip xs ys >>= \(x, y) -> [x, y]
11:43:55 <Gracenotes> yet another way to do it.
11:44:07 <Gracenotes> I'd favor the primitive recursive way though
11:44:11 * gwern waits for someone to jump in with an Applicative or Arrow one-liner
11:44:28 <Philonous> Baughn: You would have to transmit that number, so you better make sure you never use the same. Incrementing it would work
11:44:41 <Gracenotes> @pl \(x, y) -> x:y:[]
11:44:41 <lambdabot> uncurry ((. return) . (:))
11:44:52 <Gracenotes> hm
11:44:58 <Baughn> Philonous: Incrementing it wouldn't, since we increment a counter during the stream as well.
11:45:14 <Xenox> Do I look over te extra argument in Haddock to recursivly include files? I Want to generate haddock for my written library. But it can;t find the files 1 directory lower.. :S
11:45:27 <Baughn> Philonous: But generating a fully random one would. It can be encrypted with RSA, as usual for session keys.
11:45:39 <Philonous> Baughn: So? appending counter+salt never gives the same result for different input
11:46:18 <Baughn> Philonous: I mean, it'd be 'encrypt = xor (hash (blockNum + salt + key))
11:46:44 <Philonous> + being arithmetic plus or concatenation ?
11:46:48 <Baughn> arithmetic
11:47:01 <gwern> @hoogle [(a,a)] -> [a]
11:47:02 <lambdabot> Data.Ix range :: Ix a => (a, a) -> [a]
11:47:02 <lambdabot> System.Random randomRs :: (Random a, RandomGen g) => (a, a) -> g -> [a]
11:47:02 <lambdabot> Prelude snd :: (a, b) -> b
11:47:02 <Baughn> Philonous: blockNum increments during any given stream. We mustn't reuse the same hash input, so therefore the salt needs to be random
11:47:20 <Baughn> Philonous: Though if you're transporting the salt, you might as well just generate a new, random key. Hmm.
11:47:45 <Baughn> Actually, I think the salt could be transported in the clear. It doesn't need to be encrypted
11:48:00 <Philonous> Baughn: Yes, but you need to make sure you never use the same
11:48:49 <gwern> > transpose [[1..10], [11..20]]
11:48:51 <lambdabot>   [[1,11],[2,12],[3,13],[4,14],[5,15],[6,16],[7,17],[8,18],[9,19],[10,20]]
11:49:01 <gwern> hm. that's *almost* right
11:49:17 <gwern> > concat $ transpose [[1..10], [11..20]]
11:49:19 <lambdabot>   [1,11,2,12,3,13,4,14,5,15,6,16,7,17,8,18,9,19,10,20]
11:49:52 <gwern> Fred320: what do you think? you could write 'comb x y = concat $ transpose [x, y]'
11:49:53 <Baughn> Philonous: Right, which is why it's random.
11:50:38 <Philonous> Baughn: Random doesn't ensure you don't get collisions. I'd increment it and append it to the key
11:51:09 <Baughn> Philonous: Random *does* ensure you don't get collisions, with a 128-bit key
11:51:10 <Philonous> Or maybe add it to the high bits and add the counter to the low bits
11:51:37 <gwern> @check \xs ys -> (zip xs ys >>= \(x, y) -> [x, y]) == (concat $ transpose [xs, ys])
11:51:39 <lambdabot>   "Falsifiable, after 1 tests:\n[()]\n[(),(),()]\n"
11:51:55 <Fred320> @pl \xs ys -> concat $ transpose [xs, ys]
11:51:56 <lambdabot> ((join . transpose) .) . (. return) . (:)
11:52:00 <Fred320> LOL
11:52:10 <Fred320> @src return
11:52:10 <lambdabot> Source not found. Where did you learn to type?
11:52:26 <Baughn> Philonous: If you aren't okay with probabilistic proofs, you probably shouldn't be doing crypto. :/
11:52:34 <jmcarthur_work> Fred320, for this case, return x == [x]
11:52:55 <Gracenotes> the behavior of anything involving zip is changed when the lists are of different lengths. of course.
11:53:08 <jmcarthur_work> @src transpose
11:53:09 <lambdabot> transpose []             = []
11:53:09 <lambdabot> transpose ([]   : xss)   = transpose xss
11:53:09 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
11:53:22 <jmcarthur_work> surely there is a nicer definition than that!
11:53:42 <gwern> @check \xs ys -> not (null xs || null ys) ==> (zip xs ys >>= \(x, y) -> [x, y]) == (concat $ transpose [xs, ys])
11:53:44 <lambdabot>   Not in scope: `==>'
11:53:48 <gwern> blast
11:54:30 <jmcarthur_work> @check \xs ys -> if null xs || null ys then True else (zip xs ys >>= \(x, y) -> [x, y]) == (concat $ transpose [xs, ys]
11:54:31 <lambdabot>  Unbalanced parentheses
11:54:37 <Gracenotes> and transpose's behavior for lists of different lengths is.. odd
11:54:37 <gwern> @check \xs ys -> if (not (null xs || null ys)) then (zip xs ys >>= \(x, y) -> [x, y]) == (concat $ transpose [xs, ys]) else True
11:54:38 <lambdabot>   "Falsifiable, after 1 tests:\n[(),()]\n[()]\n"
11:54:42 <jmcarthur_work> @check \xs ys -> if null xs || null ys then True else (zip xs ys >>= \(x, y) -> [x, y]) == (concat $ transpose [xs, ys])
11:54:43 <lambdabot>   "Falsifiable, after 4 tests:\n[(),(),()]\n[()]\n"
11:54:47 <gwern> gr
11:54:47 <jmcarthur_work> psh
11:55:07 <Gracenotes> it skips over rows that aren't long enough.
11:55:15 <Philonous> Baughn: In fact I don't do crypto. But you are prolly right that random is ok. My point was that you'd need a salt
11:55:37 <Baughn> Indeed it does
11:55:46 <Gracenotes> @check \xs ys -> length xs /= length ys || (zip xs ys >>= \(x, y) -> [x, y]) == (concat $ transpose [xs, ys])
11:55:47 <lambdabot>   "OK, passed 500 tests."
11:56:25 <gwern> Fred320: yeah, but I don't think you're going to find a nicer solution than concat . transpose
11:56:25 <Baughn> Philonous: Though it's a bit of a cardinal rule never to encrypt two different plaintexts with the same key. I should've remembered that. :)
11:56:37 <jmcarthur_work> @pl \(x,y) -> [x,y]
11:56:37 <lambdabot> uncurry ((. return) . (:))
11:59:29 <hatds> is there a more in depth guide for "interpreting a time/allocation report" than the ghc user manual?
12:00:05 <hatds> like, understanding why something is entered "0" times but exited thousands of times?
12:00:10 <gwern> hatds: no. but may I suggest that you take notes on the process and then post the tear-stained pages up for the rest of us when you're done?
12:00:40 <hatds> :)
12:01:51 <hatds> also I've noticed that a local binding let g = \x -> ... func x   versus g x = ... func x  can have an effect on how "func" is reported in the report
12:02:24 <hatds> not to mention that the automatic cost centers seem special (I've yet been able to duplicate them with just manual cost centers)
12:03:30 <hatds> maybe the mailing lists have something on this
12:04:51 <Paczesiowa> hatds: maybe use manual cost centers annotations?
12:05:00 <Philonous> Baughn: Problem with (random) numbers is, that if they are low (smaller than the number of blocks that you are encrypting) you get blocks that are xored with the same key, opening the door to analytic attacs
12:05:07 <hatds> yea, 100% manual, no autos seems to be the way to go
12:05:21 <Philonous> Baughn: And because you need to transmit the random number an attacker would see that
12:05:39 <Baughn> Philonous: But you don't use small random numbers. YOu use 128-bit ones, at the very least.
12:07:10 <Philonous> Baughn: Ok, so it is improbable that you'd get a small number.
12:07:23 <Baughn> Philonous: No, it's impossible
12:07:33 <Baughn> Philonous: WHich is to say very, very improbable.
12:20:21 <hackagebot> haskell-src-exts 0.5.2 - Manipulating Haskell source: abstract syntax, lexer, parser, and pretty-printer (NiklasBroberg)
12:21:39 <jmcarthur_work> would there ever be a reason i _wouldn't_ want to make my IO types follow the form (MonadIO m => m a) rather than the form (IO a)? it has occurred to me many times that that would make a lot of things far cleaner
12:22:39 <jmcarthur_work> i'm thinking about making a library that wraps a lot of the standard library IO functions to have that form
12:23:05 <jmcarthur_work> liftIO all over the place just seems unnecessary
12:23:18 <jmcarthur_work> we already have stuff for mtl like that
12:29:22 <solidsnack> I'm having some trouble with ST.
12:29:23 <solidsnack> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2788#a2788
12:29:35 <solidsnack> The commented out part is the part I'm having trouble with.
12:29:53 <solidsnack> It's the "less polymorphic than expected" issue.
12:30:53 <Heffalump> it's the compiler telling you that you aren't advanced enough to handle polymorphism and should just stick to monomorphic programs ;-)
12:31:40 <Heffalump> does it work without the signature on recurse?
12:31:58 <Heffalump> the problem is probably because you aren't using scoped type variables and so the inner signature and the outer one don't share an 's'
12:32:05 <solidsnack> Heffalump: Hmm.
12:32:44 <Heffalump> oh, not just that
12:32:56 <Heffalump> you can't use DAG as a parameter to another ST computation like that
12:33:02 <solidsnack> Oh.
12:33:08 <Heffalump> because you've quantified away 's', so the 's' from DAG and the 's' in cycleFrom aren't the same
12:33:15 <solidsnack> Okay.
12:33:22 <jmcarthur_work> ah yeah, it would have to be DAG s
12:33:23 <solidsnack> So it need to be `DAG s`?
12:33:26 <Heffalump> yeah
12:34:39 <solidsnack> Thanks.
12:36:26 <MartyIX> type Edge a     = (a, a); data Vertex a   = a (Edges [Edge a])       --  is there a way how to say I want to have Vertex as a name of vertex and a list of edges from the vertex? Help please O:-)
12:37:07 <MartyIX> this definition doesn't works and I'm not quite sure why is that
12:37:13 <solidsnack> data Vertex a = Vertex a [Edge a]
12:37:20 <skorpan> what is "Edges"?
12:37:29 <skorpan> ok
12:37:41 <skorpan> you seem to have put the constructor in the wrong place
12:37:51 <MartyIX> skorpan: I thought there must be a some kind of data constructor
12:37:59 <skorpan> yeah, but the constructor is always first
12:38:00 <MartyIX> solidsnack: i'll try thank you
12:38:12 <skorpan> so data Vertex a = Edges a [Edge a] is valid
12:38:25 <solidsnack> MartyIX: No problem. Might as well make `Edge` a data definition, as well...
12:42:05 <MartyIX> solidsnack: I got it. thanks
12:44:17 <MartyIX> solidsnack: There's a lot of catches in haskell :) (tabs :D) and even though I've already gone through Prolog which is in the same group of languages as Haskell it's entirely different experience..
12:44:41 <Twey> Prolog?  Same group of languages as Haskell?  What?
12:45:20 <Twey> Apart from the different syntax, different goals, different ancestors, different type system, and different operational semantics?  :-P
12:45:29 <Twey> systems**
12:45:37 <kpreid> Twey: They've both got pattern matching!
12:45:47 <kpreid> :-)
12:45:52 <skorpan> they're both declarative (i think?)
12:45:53 <Twey> Hahahaha
12:46:04 <kpreid> Prolog has very imperative elements.
12:46:11 <Twey> skorpan: Haskell is not primarily declarative
12:47:04 <ryakubo> would someone mind telling me what the differnce is between the '<-' and '>>=' operators?
12:47:06 <skorpan> i'm not too well-wandered in this subject, but how is haskell not declarative?
12:47:13 <Twey> skorpan: It's functional
12:47:15 <ryakubo> is it an order-of-eval thing?
12:47:16 <skorpan> ryakubo: <- is syntactic sugar, not even an operator
12:47:26 <SamB> isn't it?
12:47:30 <skorpan> is it?
12:47:34 <SamB> well, it's not as declarative as can be
12:47:49 <skorpan> ryakubo: hello >>= world is the same as do { x <- hello; world x }
12:47:51 <SamB> but it's a lot more declarative-friendly than C ;-P
12:47:54 <Twey> Writing programs is about describing *how* to get a particular result, not specifying results and letting the language figure it out
12:48:06 <inimino> C is declarative
12:48:08 <Twey> Which certainly enables a lot of declarative programming styles, which is handy
12:48:33 <Twey> But it's not primarily a declarative language, although some libraries are
12:48:38 <inimino> let main() be ...
12:48:43 <jmcarthur_work> declarative is too ill defined to debate about what languages are declarative
12:49:02 <Twey> inimino: That definitely doesn't count :-P
12:49:09 <inimino> jmcarthur_work: exactly
12:49:13 <Twey> C functions are basically assignment
12:49:20 <Twey> They're even order-specific :-P
12:49:57 <Twey> jmcarthur_work: I don't know about declarative/non-declarative, but I feel we can fairly sensibly reason about what languages are more declarative than others
12:50:14 <jmcarthur_work> "They're even order-specific" ... does that mean imperative and declarative cannot both be properties of the same language?
12:50:20 <Twey> (and the same really goes for most of the other ‘styles’, like functional/imperative)
12:50:46 <ryakubo> skorpan: 't <- time >>= utcToLocalZonedTime >>= return . show' - this is what's turning my brain to mush. not really sure how to read it other than 't equals all that'.
12:50:47 <SamB> jmcarthur: no, that's talking about case branch ordering
12:50:52 <SamB> jmcarthur: I'm pretty sure
12:51:07 <Twey> jmcarthur_work: I'm not sure how you made that conclusion — I wasn't even talking about the language as a whole there, just the specific example inimino gave
12:51:13 <skorpan> ryakubo: what's right of "<-" gets evaluated first
12:51:19 <jmcarthur_work> Twey, ah i was taking it out of context then
12:51:21 <SamB> jmcarthur: "do" notation is all about sequence, so of course *that*'s ordered
12:51:51 <skorpan> ryakubo: so it will be: do { x <- time; y <- utcToLocalZonedTime x; (return . show) y }
12:52:02 <Twey> ryakubo: I prefer to use =<< for these
12:52:17 <Twey> ryakubo: t <- return . show =<< utcToLocalZonedTime =<< time
12:52:29 <ryakubo> skorpan: but is the result of time getting passed to utcToLocalZonedTime, or the other way around?
12:52:33 <olsner> t <- show <$> utcToLocalZonedTime =<< time
12:52:41 <skorpan> ryakubo: from >>= to
12:52:44 <ryakubo> Twey: ah ok
12:52:47 <skorpan> ryakubo: to =<< from
12:52:57 <ryakubo> ok cool
12:53:05 <olsner> =<< works kind of like . but with monads
12:53:23 <olsner> same "direction" at least
12:53:29 <skorpan> i'd say more like ($)
12:53:35 <skorpan> hm..
12:53:36 <jmcarthur_work> <=< is like
12:53:37 <jmcarthur_work> .
12:53:54 <jmcarthur_work> or most generally, <<<
12:55:05 <jmcarthur_work> i wish >>= and =<< didn't visually imply an ordering like they do, though
12:55:32 <jmcarthur_work> =<< especially. it's just a special function application
13:07:43 <RayNbow> @hoogle [a -> m a] -> (a -> m [a])
13:07:43 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
13:07:43 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
13:07:43 <lambdabot> Control.Monad filterM :: Monad m => (a -> m Bool) -> [a] -> m [a]
13:07:48 <RayNbow> hmm...
13:17:38 <ski> @type \fs a -> mapM ($ a) fs  -- RayNbow ?
13:17:40 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a -> m b] -> a -> m [b]
13:18:21 <mmorrow> is there any way to put a # on the RHS of a #define ?
13:21:00 <mmorrow> trigraphs!
13:21:50 * ski wouldn't have thought of that
13:22:22 <SamB> mmorrow: you're probably going to manage to produce undefined behaviour in *emacs* if you keep thinking like that
13:32:38 <hackagebot> isevaluated 0.3 - Check whether a value has been evaluated (BertramFelgenhauer)
13:41:13 <Heffalump> is there a canonical place to get Base64 encoding/decoding?
13:43:41 <hackagebot> hsx 0.5.0 - HSX (Haskell Source with XML) allows literal XML syntax to be used in Haskell source code. (NiklasBroberg)
13:50:39 <RayNbow> ski: sry, was afk
13:51:02 <RayNbow> I'm not looking for mapM actually
13:51:52 <ski> some sort of compose-and-gather-intermediate-results ?
13:51:54 <RayNbow> [a -> m a]  -- I want the output of the first function to be the input of the second function, etc.
13:51:56 <RayNbow> yes
13:52:45 * Heffalump concludes that the dataenc package is the best answer to his Base64 question
13:53:47 <ski> @type \fs a -> scanl (flip ($)) a fs
13:53:49 <Philonous> foldM
13:53:49 <lambdabot> forall b. [b -> b] -> b -> [b]
13:53:55 <Philonous> @type foldM
13:53:56 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
13:54:05 <ski> @type scanl
13:54:06 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
13:54:20 <ski> @hoogle (a -> b -> m a) -> a -> [b] -> m [a]
13:54:21 <lambdabot> Control.Monad zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
13:54:21 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
13:54:21 <lambdabot> Data.Foldable foldlM :: (Foldable t, Monad m) => (a -> b -> m a) -> a -> t b -> m a
13:55:03 <Philonous> @type fold (>>=)
13:55:05 <lambdabot> Not in scope: `fold'
13:55:08 <Philonous> @type foldl (>>=)
13:55:10 <lambdabot> forall (m :: * -> *) b. (Monad m) => m b -> [b -> m b] -> m b
13:56:19 <RayNbow> :t foldl1 (>=>)  -- this does the composition, but does not gather the intermediate results
13:56:20 <lambdabot> forall (m :: * -> *) b. (Monad m) => [b -> m b] -> b -> m b
13:56:45 <Philonous> :t (>=>)
13:56:47 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
13:57:33 <RayNbow> fish operator :p
13:58:07 <RayNbow> (or that's what byorgey called it)
13:58:19 <Philonous> @type scanl (>>=)
13:58:21 <lambdabot> forall (m :: * -> *) b. (Monad m) => m b -> [b -> m b] -> [m b]
13:59:17 <ski> @let scanM :: Monad m => (r -> a -> m r) -> r -> [a] -> m [r]; scanM f r as = liftM (r:) (case as of [] -> return []; a:as -> f r a >>= \r -> scanM f r as)
13:59:20 <lambdabot>  Defined.
13:59:53 <jmcarthur_work> :t scanM
13:59:55 <lambdabot> forall r a (m :: * -> *). (Monad m) => (r -> a -> m r) -> r -> [a] -> m [r]
14:00:04 <ski> (like i said ..)
14:00:05 <ski> @type \fs a -> scanM (flip ($)) a fs
14:00:07 <Gracenotes> @type foldM
14:00:07 <lambdabot> forall r (m :: * -> *). (Monad m) => [r -> m r] -> r -> m [r]
14:00:08 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
14:01:48 <ski> (i didn't see any immediate way to do `scanM' nicer with `foldM' ..)
14:02:27 <ville> curse all you whitespace challenged languages!
14:02:49 <Philonous> @type (foldl (>>=)) . return
14:02:50 <lambdabot> forall (m :: * -> *) b. (Monad m) => b -> [b -> m b] -> m b
14:03:02 * ski idly wonders which languages that would be
14:03:18 <ville> ski: Haskell would count as one.
14:03:33 <jmcarthur_work> challenged?
14:03:36 <jmcarthur_work> i don't see how
14:04:02 <Gracenotes> in Haskell, you don't need to indent exactly most of the time. Just need to indent... enough
14:04:10 <ville> whitespace affects how things are interpreted.
14:04:42 <RayNbow> ski: ah, thanks... :)
14:04:44 <jmcarthur_work> ville, if it annoys you enough you can revert to curly braces and semicolons, but that is not very nice looking haskell code
14:04:46 <ski> we prefer to think of it as whitespace-*enhanced*
14:05:06 <ville> and anyway dismiss me, this just from someone 4 days old in haskell.
14:05:08 <RayNbow> @let enumTo n = [0..n]
14:05:09 <lambdabot>  Defined.
14:05:26 <RayNbow> @let sequenceK' fs a = map tail $ scanM (flip ($)) a fs
14:05:27 <lambdabot>  Defined.
14:05:31 * ski starts to doubt that ville made that utterance in jest
14:05:49 <RayNbow> > sequenceK' [enumTo,enumTo] 3
14:05:51 <lambdabot>   [[0,0],[1,0],[1,1],[2,0],[2,1],[2,2],[3,0],[3,1],[3,2],[3,3]]
14:05:54 <Gracenotes> as ski said, whitespace is never an issue: you can use braces/semicolons instead of whitespace. some people prefer to...
14:05:57 <ski> @type sequenceK'
14:05:59 <lambdabot> forall a. [a -> [a]] -> a -> [[a]]
14:05:59 <Gracenotes> use braces, that is
14:06:07 <RayNbow> hmm
14:06:23 <RayNbow> that "map tail" part made it less polymorphic
14:06:25 <ville> ski: I am quite flexible when it comes to syntax. I've worked at enough of work places to have no favourite curly-positions and so forth.
14:06:37 <Gracenotes> whitespace doesn't affect how things are interpreted to the extent of two different behaviors
14:06:44 <ski> RayNbow : s/map/mapM/ ?
14:06:49 <Gracenotes> it's just a little.. strict about what's accepted...
14:07:27 <RayNbow> ski: that doesn't give the desired results
14:07:36 <ski> "that" being ?
14:07:39 <ville> ski: Just getting caught by something as innocent looking as indentation is quite new.
14:07:58 <ski> also, what is the disired results ?
14:08:04 <jmcarthur_work> ville, it's mostly just do notation that can be confusingly picky to a beginner. in my opinion, beginners shouldn't even learn do notation until much later than they usually do
14:08:11 <ski> ville : i understand
14:08:32 <jmcarthur_work> my opinion is that do notation is just a great way to make functional code look imperative
14:09:06 <RayNbow> > let seqK fs a = mapM tail $ scanM (flip ($)) a fs   in   seqK [enumTo,enumTo] 3
14:09:08 <lambdabot>   [[0,1,1,2,2,2,3,3,3,3],[0,1,1,2,2,2,3,3,3,3],[0,1,1,2,2,2,3,3,2,3],[0,1,1,2...
14:09:31 <RayNbow> ah wait
14:10:14 * ski waits
14:10:29 <ville> don't hold your breath - it'll kill you!
14:10:38 <RayNbow> :t let seqK fs a = tail <$> scanM (flip ($)) a fs   in   seqK
14:10:39 <lambdabot> forall a (f :: * -> *). (Functor f, Monad f) => [a -> f a] -> a -> f [a]
14:11:55 <Gracenotes> > iterate ((++[1]) . (1:) . (zipWith (+) <*> tail)) [1]
14:11:56 <lambdabot>   [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1]...
14:12:06 <RayNbow> > let seqK fs a = tail <$> scanM (flip ($)) a fs   in   seqK (replicate 3 enumTo) 2
14:12:07 <lambdabot>   [[0,0,0],[1,0,0],[1,1,0],[1,1,1],[2,0,0],[2,1,0],[2,1,1],[2,2,0],[2,2,1],[2...
14:12:42 <RayNbow> > [[a,b,c] | a <- [0..2], b <- [0..a], c <- [0..b]]
14:12:44 <lambdabot>   [[0,0,0],[1,0,0],[1,1,0],[1,1,1],[2,0,0],[2,1,0],[2,1,1],[2,2,0],[2,2,1],[2...
14:13:24 <RayNbow> thx ski :)
14:13:29 <RayNbow> @karma ski
14:13:29 <lambdabot> ski has a karma of 3
14:13:31 <RayNbow> ski++
14:13:36 <ski> i can release my breath, now ?
14:13:46 <RayNbow> sure :p
14:15:06 * ski still has a very vague picture of what RayNbow wanted, and why the desired results weren't achieved at first .. but he's glad it appeared to have worked out in the end
14:16:00 <RayNbow> well, your scanM was what I needed, except I didn't want the initial argument to appear in the lists
14:16:13 <RayNbow> so I had to fmap tail
14:16:35 <ski> (sorry for the above nonsense. i feel in a silly mode of thought atm, so should better go to sleep)
14:16:40 <ski> ok
14:17:18 <ski> (sometimes i think there should be `scanl0' and `scanl1' or something for the cases when you want resp. do not want initial value of state)
14:19:21 <RayNbow> someone once ran into the problem that uvector's scanlU's behaviour differed from the plain list version
14:20:39 <RayNbow> > scanl (+) [1..4]
14:20:40 <lambdabot>   Overlapping instances for GHC.Show.Show ([[t]] -> [[t]])
14:20:40 <lambdabot>    arising from a ...
14:20:49 <RayNbow> > scanl (+) 1 [1..4]
14:20:50 <lambdabot>   [1,2,4,7,11]
14:21:44 <RayNbow> uvector's scan:   scanlU (+) 1 (toU [1..4])   ~~~>   toU [1.0,2.0,4.0,7.0]
14:23:14 <Zao> http://www.hvergi.net/2009/02/the-non-determinism-monad/ <- now that's quite an eye-opener for me.
14:23:20 <Zao> I never looked at the list monad like that.
14:26:50 <Gracenotes> a set monad would arguably be better for non-determinism.. if not for the Ord thing...
14:32:55 <uzytkownik> @pl \x -> "<" ++ x ++ ">"
14:32:55 <lambdabot> ('<' :) . (++ ">")
14:35:47 <giulianoxt> hey guys
14:36:04 <giulianoxt> what's the rationale for a pattern match fail in a do expression turning into a fail?
14:36:19 <giulianoxt> just solved a really nasty bug just know about this.. using parsec
14:36:24 <giulianoxt> *now
14:38:10 <Gracenotes> giulianoxt: whatever the rationale, some people do want to see "fail" gone from the monad typeclass
14:38:31 <Gracenotes> "fail" is not meaningful for all monads..
14:40:37 <jmcarthur_work> some people propose a MonadFail type class for fail
14:41:48 <Botje> so using patterns in a do block should add a MonadFail class constraint?
14:42:04 <jmcarthur_work> under that proposal, yeah
14:42:10 <Botje> makes sense :)
14:42:52 <Gracenotes> not for newtype constructors though, obviously. can't fail.
14:43:08 <jmcarthur_work> i think i would like fail to go away and replace it with mzero. not good for reporting error messages, but you should be using an error monad for that anyway
14:43:09 <Gracenotes> and other identity-type things..
14:43:29 <jmcarthur_work> maybe have pattern match fails result in mzero
14:43:47 <jmcarthur_work> i'm just thinking out loud though
14:43:59 <jmcarthur_work> haven't followed that through to its consequences
14:44:19 <jmcarthur_work> this is all assuming a MonadZero class, anyway
14:44:27 <jmcarthur_work> would be ridiculous to require MonadPlus for that
14:44:47 <dmwit> mzero provides no way to give an error message
14:44:54 <jmcarthur_work> right
14:45:00 <jmcarthur_work> i'm not so sure that it a horrible thing
14:45:06 <dmwit> Me neither. =)
14:45:24 <jmcarthur_work> my opinion is that error messages should go through an error monad
14:45:39 <jmcarthur_work> hmm... maybe MonadZero could include fail with a default implementation
14:45:47 <jmcarthur_work> fail = const mzero
14:46:25 <Gracenotes> but anyway, it seems like your error was due to failing being *silent*
14:46:26 <dmwit> It would be nice, but it's not really possible with the current syntax.
14:46:52 <jmcarthur_work> wait, why not?
14:46:54 <Gracenotes> giulianoxt's.
14:47:08 <Gracenotes> you should probably use -Wall to be sure...
14:47:36 <ac> hm, I think things like hsql and HAppS (projects that are no longer maintained that have better alternatives) should eventually be removed from hackage
14:47:38 <jmcarthur_work> with no implicit prelude you should be able to put fail in another type class, shouldn't you?
14:47:42 <dmwit> jmcarthur_work: Would you put that default implementation in the MonadZero class or in the MonadFail class?  Think about it.
14:47:52 <jmcarthur_work> monadzero
14:47:58 <giulianoxt> Gracenotes: yeah, gonna change my makefile
14:48:05 <jmcarthur_work> there wouldn't be a monadfail class under than proposal
14:48:09 <jmcarthur_work> *that
14:48:15 <jmcarthur_work> oh
14:48:17 <jmcarthur_work> nevermind
14:48:19 <dmwit> jmcarthur_work: =)
14:48:39 <jmcarthur_work> okay, separate fail and mzero classes it is then
14:49:14 <jmcarthur_work> with a common fail instance being fail = const mzero, maybe
14:49:15 <dmwit> jmcarthur_work: You have to put default implementations in the MonadFail class, but then you don't have the necessary MonadZero constraint.
14:49:27 <jmcarthur_work> yeah
14:50:00 <Botje> fail = return $ error "pattern match failure" ?
14:50:02 <jmcarthur_work> i'm not sure that fail should always result in something semantically the same as mzero anyway
14:50:34 <dmwit> Botje: Why bother with the return?
14:50:40 <jmcarthur_work> i was about to ask that...
14:51:07 <Botje> if you don't touch the result it doesn't crash? :)
14:51:23 <dmwit> Botje: I make the same claim about the version with no return.
14:52:11 <jmcarthur_work> :t fail
14:52:13 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
14:53:02 <jmcarthur_work> :t return (error "blah blah") :: Monad m => String -> m a
14:53:04 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
14:53:05 <jmcarthur_work> win
14:53:23 <jmcarthur_work> the return just has nothing to do with the monad
14:53:29 <Botje> fair enough
14:53:59 <dmwit> jmcarthur_work: Oh, that's nasty.
14:54:03 <jmcarthur_work> :P
14:54:20 <dmwit> Also, Botje, that's nasty, if that's what you meant.
14:54:52 <jmcarthur_work> don't go dissing const
14:57:08 <Peaker> Baughn: here?
14:58:26 <Peaker> @type forkIO . evaluate
14:58:27 <lambdabot> Not in scope: `forkIO'
14:58:27 <lambdabot> Not in scope: `evaluate'
14:58:39 <Peaker> @index forkIO
14:58:40 <lambdabot> Control.Concurrent
14:58:42 <Peaker> @index evaluate
14:58:43 <lambdabot> Control.Exception, Test.QuickCheck, Debug.QuickCheck
14:58:51 <Peaker> @type Control.Concurrent.forkIO . Control.Exception.evaluate
14:58:53 <lambdabot> () -> IO GHC.Conc.ThreadId
14:59:46 <Peaker> I think GHC should expose a function that does   (forkIO . evaluate) safely -- i.e: is aware of pure computations that don't allocate, and calls them in forkOS, instead.  Maybe it can add a compile-time tag to evaluations that don't allocate, and propagate this attribute and have it be queryable by this new function
15:00:39 <jmcarthur_work> :t evaluate
15:00:41 <lambdabot> Not in scope: `evaluate'
15:00:51 <jmcarthur_work> :t Control.Exception.evaluate
15:00:53 <lambdabot> forall a. a -> IO a
15:01:05 <Peaker> I think evaluate is basically a seq inside an IO action
15:01:15 <Philonous> What would be the advantage of using forkOS instead of forkIO? Doesn't that just introduce OS-thread overhead?
15:01:33 <Peaker> Philonous: non-allocating threads in forkIO  never yield runtime
15:01:52 <Philonous> Ah right
15:01:54 <Peaker> Philonous: so they aren't actually cooperative threads, like normal threads
15:02:08 <jmcarthur_work> oh
15:02:11 <Peaker> @type \x -> x `seq` (return x)
15:02:13 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
15:02:14 <jmcarthur_work> didn't think of that
15:02:40 <jmcarthur_work> what kind of computation is large enough to put to a different that yet doesn't allocate anything?
15:02:45 <Peaker> for some odd reason, dons and Baughn both seem to agree that its OK to expose this consideration to the user, but I think the user should have a nice thread abstraction without worrying about optimization details like whether his pure expressions allocate
15:03:03 <jmcarthur_work> *different thread
15:03:11 <Peaker> jmcarthur_work: well, a computation that diverges and does some recursion with unboxed types
15:03:23 <Peaker> e.g:  f :: Int -> Int ; f x = f (x+1)
15:03:55 <jmcarthur_work> is this having to do with unamb, bychance?
15:03:58 <Peaker> but it could have a special case for some number and actually do something useful and not diverge, and just be "big" rather than infinite. But even this case is a problem
15:04:00 <Peaker> jmcarthur_work: yeah
15:04:10 <Baughn> Peaker: I don't think it's okay, I just don't think it's worth spending too much time on
15:04:18 <Baughn> Peaker: If there's a simple fix, sure, fixing it'd be nice
15:04:54 <Peaker> Baughn: well, if this thread abstraction leaks, unamb leaks too, and leaks through too many layers of abstraction suck
15:06:00 <jmcarthur_work> yeah i would certainly not expect forking a thread to give me _|_ on *any* level of abstraction
15:06:11 <Peaker> Baughn: also, about the crypto thing (saw it in the logs), I think your problem is just that the key is small enough to brute force?  If its pretty big, you're growing closer to a one-time-pad.  Also, its likely that the hash is breakable if you know some properties about the increasing value/etc
15:06:29 <Baughn> Peaker: A 128-bit key is brute-forceable?
15:06:38 <jmcarthur_work> > 2^128
15:06:40 <lambdabot>   340282366920938463463374607431768211456
15:06:43 <Peaker> Baughn: well, there almost always are shortcuts you can take
15:06:48 <idnar> Baughn: anything is possible, with enough force :)
15:06:48 <Baughn> Peaker: And yes, I'm aware of that problem, but..
15:06:53 <Peaker> Baughn: knowing the hash function, properties of plaintext, and so forth
15:07:01 <Baughn> Peaker: It's a theoretical thing. Given a perfect hash function, this should work.
15:07:11 <Peaker> Baughn: I don't believe in perfect hash functions :-P
15:07:39 <mmorrow> > 2^4096
15:07:41 <lambdabot>   104438888141315250669175271071662438257996424904738378038423348328395390797...
15:07:47 <Baughn> Peaker: Worst case, we could create a perfect hash for all 2^128 values. :3
15:07:52 <mmorrow> > (length . show) 2^4096
15:07:54 <lambdabot>   1
15:07:58 <mmorrow> > (length . show) $ 2^4096
15:08:00 <lambdabot>   1234
15:08:01 <Philonous> Baughn: Actually what you need is a good prng. A hash function + counter just happens to be one. But I guess you can get better than that
15:08:58 <Baughn> Philonous: Oh, good point. Yes, I guess it's basically the same encryption function as that PRNG-based one..
15:09:09 <Philonous> Baughn: Than what you do is create one time pads from a seed. And as long as you can't predict the pads the cypher is good
15:09:39 * Baughn nodnods
15:15:05 <Peaker> I don't think these kinds of encryptions tend to work very well
15:15:43 <Peaker> Baughn: anyway, do you think it is reasonable for unamb to sometimes be _|_ when it shouldn't be?
15:16:13 <Peaker> I think ghc should have somehow guaranteed context switches in all threads -- perhaps make sure inner loops always yield every N iterations, or so
15:16:22 <opqdonut> foundations for programming languages has some nice stuff about lub-style things when they investigate domain theoretic models for lambda calculus
15:17:09 <opqdonut> it's interesting that parallel or is not defineable in vanilla lambda calculus but adding it makes all continous (in the domain-theoretic sense) functions defineable
15:17:21 <SamB> Peaker: tell dons about your problem
15:17:35 <SamB> he was having trouble believing such problems existed
15:17:46 <Peaker> SamB: I did, dons said he thinks its reasonable for unallocating threads to not yield
15:17:56 <Baughn> Peaker: I don't think it would be reasonable, if someone can show me a reasonable program where it happens
15:18:11 <SamB> Peaker: did you explain the semantic issue ?
15:18:36 <Peaker> Baughn: a naive implementation of factorial specialized for ints would probably take a long while, even if not be _|_
15:19:01 <Peaker> SamB: what semantic issue? of forkIO not really guaranteeing a fork?
15:19:29 <SamB> Peaker: where it makes unamb return _|_ when it shouldn't?
15:20:47 <Peaker> SamB: well, that supposedly can be blamed on unamb rather than ghc
15:21:45 <dons> Peaker: i'd like to see a reasonable program where it happens :)
15:21:51 <dons> when that does happen, please file a bug report
15:22:22 <SamB> dons: isn't one already filed ?
15:25:06 <bla123> is there any practical difference between function-level programming and point-free style?
15:26:03 <monochrom> I have not heard of "function-level". What does it say?
15:26:13 <ikegami__> Sometimes, point-free style makes refactoring let be easy
15:26:47 <bla123> monochrom: i'm not sure, but to me it sounds like not allowing points
15:28:06 <bla123> by not having to deal with points, some proofs may be easier, but i want to know whether there are any practical advantages
15:29:15 <monochrom> Perhaps there is none.
15:29:27 <monochrom> I mean perhaps there is no difference.
15:29:32 <conal> i think backus used the term "function-level"
15:29:34 <conal> @where liberated
15:29:35 <lambdabot> http://www.stanford.edu/class/cs242/readings/backus.pdf
15:30:33 <conal> bla123: sometimes a practical advantage is reduced complexity, so you can get more said with less.
15:31:28 <bla123> @conal: but is there any difference to point-free style?
15:31:29 <lambdabot> Unknown command, try @list
15:32:19 <conal> bla123: yeah, i think so.  e.g., i'd call '\ g f -> g . f . g' both pointful and function-level.
15:32:46 <conal> but mostly, i mean point-free == function-level
15:33:06 <bla123> conal: ah, ok, i overlooked that case
15:33:49 <bla123> conal: so i guess the point in function-level programming is not having points ;)
15:34:40 <Philonous> It's rather ironic that after all in point-free programming you are going to have more points (.)
15:35:00 <monochrom> har har har
15:35:01 <conal> i like function-level programming for one of the same reasons i prefer functional to imperative programming: it's thinking at a higher-level.  mental leverage.
15:35:22 <SamB> Peaker: so ... has it actually happened ?
15:35:36 <Peaker> SamB: I don't know
15:35:43 <Peaker> SamB: I'm just following up on various discussions
15:39:10 <SamB> oh, it's at http://hackage.haskell.org/trac/ghc/ticket/367
15:39:47 <SamB> dons: it was reported by simonpj himself, according to trac!
15:40:07 <Gracenotes> @botsnack
15:40:08 <lambdabot> :)
15:40:08 <lunabot>  :)
15:40:38 <realtime> :)
15:40:48 <shachaf> :)
15:41:00 <monochrom> :)
15:49:22 <conal> given ghc bug #367, i wonder if there's a reliable way to run two threads and wait for one to finish first.
15:51:23 <hiredman> http://cs.ioc.ee/~tarmo/papers/essence.pdf <-- dataflow programing, what promise/deliver is good for
15:52:51 <dons> conal: have you encountered #367?
15:53:47 <dons> just make sure your threads allocate or yield, if you're paranoid :)
15:53:55 <hiredman> crap
15:54:07 <hiredman> sorry. wrong channel
15:55:13 <dons> hiredman: seems like the right channel :)
15:56:25 <hiredman> actually I was about to appologize that digging through the haskell might be too much, when I realized I had pasted it to #haskell :P
15:57:14 <Philonous>  THanks for the interesting paper anway :)
15:57:20 <conal> dons: yes.  someone recently showed me an example of unamb that went wrong due to 367.  i was able to repro it easily.
15:57:42 <dons> there's nothing to be done, other than allocate or yield.
15:58:02 <dons> so it was definitely not allocating? hence not context switch?
15:58:14 <conal> i think that was the case
15:58:47 <dons> the trick is to get ghc to put a heap check in the loop somehow. e.g. by having a boxed return from the code.
16:00:03 <conal> dons: would be great if one could do thread racing in a modular way, i.e., be able to write the computations without knowing that they're going to be raced.
16:00:16 <conal> dons: in the case of unamb, the computations are arbitrary and pure.
16:01:10 <Igloo> It would be a nice bug to fix for other reasons too
16:01:20 <Igloo> e.g. System.Timeout
16:02:43 <SamB> but ... how would you fix it?
16:02:52 <SamB> CFI?
16:05:20 <SamB> I think the timer interrupt handler needs to be able to somehow FORCE the running code to stop
16:05:51 <Peaker> there's a timer interrupt handler?
16:06:00 <Peaker> (In ghc rts?)
16:06:05 <mmorrow> <Peaker> I think ghc should have somehow guaranteed context switches in all threads -- perhaps make sure inner loops always yield every N iterations, or so
16:06:05 <SamB> I guess inserting http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/Signals
16:06:13 <SamB> er.
16:06:19 <SamB> sorry about the first 3 words
16:06:28 <mmorrow> Peaker: the only way you could do that and not kill performance would be to unroll every inner loop N times
16:06:32 <SamB> I guess inserting a breakpoint would be unspeakably evil ?
16:07:02 <Peaker> mmorrow: I think the bottleneck is less the amount of actual instructions being executed and more how many memory cache misses you're causing?
16:07:30 <mmorrow> Peaker: but say you have a three instruction loop
16:07:51 <mmorrow> and you add code to it to test every time through if it should yield
16:08:26 <Peaker> mmorrow: loops typically already have some sort of limit on them -- you could min() that limit with some count, and test outside of the loop
16:09:12 <mmorrow> Peaker: but then you'd need to know about that particular code's method of testing when it should break, and what if you want to yield before that?
16:09:29 <mmorrow> (err, and how would you "set it back up" to resume?)
16:09:46 <Peaker> hmm -- seems like there are timer handlers anyway -- I guess a timer signal handler could mess with the instruction pointer on the stack?
16:10:47 <Peaker> do signal handlers install an ordinary stack frame for the signal handler call in the arbitrary position the signal was caught at?
16:11:10 <Peaker> if so, user-level context switches can be implemented similarly to kernel schedulers -- just switch to a different stack and return? :)
16:11:14 <mmorrow> Peaker: i don't know all the things exactly that it could mess with, but since there's the gc, everything has to be set up exactly right
16:12:08 <mmorrow> Peaker: every thread has it's own stack already
16:12:19 <mmorrow> (forkIO thread)
16:12:33 <SamB> Peaker: I don't think you can switch like that
16:12:40 <Peaker> SamB: why not?
16:13:02 <SamB> Peaker: the kernel may become displeased
16:13:16 <SamB> plus, yes, the GC
16:13:23 <SamB> that's never going to work for the GC
16:13:23 <Peaker> SamB: I don't think the kernel cares. You might want to pusha/popa around the scheduler calls, though
16:13:32 <Peaker> why not? How does the GC interact with threads?
16:13:40 <SamB> it has to be able to walk their stacks
16:14:13 <SamB> and the junk a signal-delivery leaves on the stack is not something it can be expected to walk
16:14:48 <mmorrow> Peaker: thread's stacks are heap allocated, and if everything is not perfectly in order wrt the stack layout, the gc will either miss some pointers, mistake non-pointers for pointers, or who-knows-what-else, all of which most probably would end in a segfault
16:15:11 <SamB> mmorrow: the heap allocation bit is irrelevant
16:15:20 <SamB> it would have to walk them no matter where they were stored
16:15:21 <mmorrow> yes, to the second part of that
16:15:26 <Peaker> SamB: you mean, that "sleeping threads" have the signal handlers on their stacks, so its hard for the GC to ignore them? Its probably not hard at all
16:15:56 <SamB> Peaker: making assumptions wrt. the layout of such frames is best left to old versions of GDB
16:16:06 <Peaker> SamB: heh, why old?
16:16:20 <Peaker> SamB: how does it find stuff on stacks now that signal handlers aren't on them?
16:16:28 <athos> :t (>>>)
16:16:29 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
16:16:35 <SamB> well, newer versions prefer to get such information from VDSO debuginfo
16:17:19 <Peaker> VDSO?
16:17:23 <SamB> Peaker: well, it only switches threads at heap checks or (specific) primitive calls
16:17:57 <SamB> Peaker: a little ELF image the kernel maps into the process's address space
16:18:07 <Peaker> SamB: it could "only switch threads at scheduler calls" or some such?
16:18:22 <Peaker> what does that ELF image do? how can it help understanding stack layout?
16:19:27 <SamB> Peaker: it helps GDB understand the stack layout because the return address for the signal handler's frame refers to code in that ELF image
16:20:13 <SamB> so GDB looks at that ELF to try and find DWARF2 CFI (Call Frame Information)
16:20:32 <Peaker> SamB: its specifically for deciphering signal handlers?
16:20:46 <SamB> Peaker: the VDSO?
16:20:51 <SamB> not just for that
16:21:46 <SamB> it's also to allow the kernel to provide the code for performing a system call that is most appropriate for the CPU it runs on
16:22:08 <SamB> int 0x80 isn't the best way anymore
16:22:19 <Peaker> SamB: anyway - I don't see why its such a problem to allow stack/context switches to happen from inside signal handlers
16:22:42 <mmorrow> Peaker: how the GC knows about the layout of the stack is by looking at the address of the pointer on or near (i don't recall) the top of the stack, and either based on its address (e.g. ==&stg_foo) or some info in the info table that pointer points to, it can deduce the stack layou
16:22:44 <Peaker> SamB: currently - it assumes that a stack switch occurs inside a certain C function - and walks the pointers from the stack layout as it assumes it is in there?
16:22:56 <SamB> Peaker: not quite
16:23:28 <Peaker> How does the GC generally know to walk references to other values inside values, btw?
16:24:01 <SamB> Peaker: well, actually that might be close enough
16:24:04 <mmorrow> Peaker: it tests the val of the tag in the info table to see what type of closure it is
16:24:19 <mmorrow> and based on that, and maybe other info in the info table, it knows the layout
16:24:36 <mmorrow> (the info ptr is the first word of a closure)
16:24:48 <SamB> Peaker: I think the topmost Haskell stack frame is specifically layed out just like a heap object
16:25:02 <mmorrow> exactly
16:25:41 <SamB> Peaker: it is clearly impossible to arrange this for system calls
16:25:45 <SamB> er. signals
16:26:17 <Peaker> mmorrow: are data constructors also closures?
16:26:33 <Peaker> SamB: the signal can call something else to do the switch
16:26:36 <Peaker> SamB: it doesn't have to switch itself
16:26:43 <Peaker> SamB: that other thing can set whatever stack layout it wants
16:26:58 <mmorrow> Peaker: yes, the closure would be [ptrToInfoTab,rawdata0,rawdata1,...]
16:27:33 <mmorrow> and the infotab would be [CONSTR,numPtrs,litwords,p1,..,pn,litword1,..,litwordn]
16:27:37 <mmorrow> err, sorry
16:27:42 <mmorrow> and the infotab would be [CONSTR,numPtrs,litwords]
16:27:53 <SamB> Peaker: but the stack frame for the code that was interrupted by the signal delivery is *not* in the shape of a Haskell closure
16:27:59 <mmorrow> so then it know that the rawdata_i is [p1,..,pn,litword1,..,litwordn]
16:28:09 <Peaker> mmorrow: all boxed values are of this form? Whether they are evaluated already or not? Whether they are functions or data constructors, built-in or not, etc?
16:28:28 <mmorrow> Peaker: constructors are like this, but nothing else
16:28:40 <mmorrow> (and that's fully evaluated only)
16:29:11 <Peaker> SamB: unallocating functions can be compiled to register a pointer in thread-local-storage, that the signal handler uses to find their stack refs?
16:29:11 <mmorrow> Peaker: here're all the possible closure types http://hackage.haskell.org/packages/archive/vacuum/0.0.94/doc/html/GHC-Vacuum-ClosureType.html
16:29:31 <SamB> in order for the GC, or the context switch code, to walk out of the signal handler stack frame, it would additionally need to know where the Haskell code's registers had been saved
16:29:45 <Peaker> mmorrow: why is numPtrs needed?  The static-type has that information?
16:30:15 <SamB> hmm.
16:30:23 <Peaker> SamB: They could cooperate with potential signal handlers by registering their "root references" somewhere?
16:30:24 <SamB> I guess Linux does save them somewhere ...
16:30:33 <mmorrow> Peaker: i suppose in theory you could do that, but i don't know of any gc that does it that way
16:30:36 <SamB> Peaker: sounds really slow
16:30:45 <Peaker> SamB: outside of inner loops, ideally?
16:32:59 <Peaker> SamB: hmm.. more difficult but maybe possible -- build a table mapping each instruction of unallocating code - to a function that can extract its pointers
16:33:07 <loupgaroublond> hey all
16:33:22 <solidsnack> I do not really understand this trouble I'm having with ST: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2793#a2793
16:33:25 <Peaker> SamB: look up the signal's caller -- and use the table to interpret registers/stack appropriately for that position in the code
16:33:26 <loupgaroublond> are there any good simple examples of complete c2hs projects that aren't gtk2hs?
16:33:36 <SamB> Peaker: wouldn't it be more sensible to use DWARF2 CFI for that ?
16:33:51 <Peaker> SamB: CFI?
16:34:15 <Peaker> SamB: I tried reading the DWARF specs once, btw, and couldn't find any mention of how the file format actually encodes the information
16:34:15 <solidsnack> The `cycleCheck` and the enclosing `insert` disagree about the type of `dag` as far as the state variable is concerned.
16:34:27 <Peaker> SamB: one of the worst specs I've seen, I think
16:34:31 <SamB> Peaker: read DWARF 3 specs
16:34:45 <SamB> and they have that information, but it's in, like, "part 2" or something
16:34:46 <Saizan_> solidsnack: you can't reuse things involving an 's' outside of a runST
16:35:21 <SamB> the meaning and encoding of the information *are* different things, you know ;-)
16:35:23 <Saizan_> solidsnack: you've to freeze the array
16:35:34 <solidsnack> and then unfreeze?
16:35:42 <augur> haskelliers, who among you knows about formal language theory/formal grammars?
16:36:00 <Saizan_> solidsnack: if you've to modify it again, yes
16:36:04 <Peaker> SamB: yeah, its fine to separate them, but there was no part 2 that explained the encoding.  I talked to others, they were baffled as well. I could understand the output of readelf --debug-dump, but couldn't reimplement it myself, except via reverse engineering
16:36:05 <solidsnack> hmm
16:36:24 <SamB> Peaker: which spec were you reading ?
16:36:26 <solidsnack> Saizan_: There's no copy implied by thawing?
16:36:28 <Saizan_> solidsnack: or just change the result type to ST s (Either (DAG s) (DAG s)) and not run runST there?
16:36:36 <Peaker> SamB: I don't remember, it was a few years ago
16:36:43 <Saizan_> solidsnack: i think there is, actually
16:37:00 <Peaker> SamB: I did it long ago to auto-extract debug information about C functions so I can auto-FFI wrap them
16:39:16 <SamB> 7 DATA REPRESENTATION ........................................................................................................................119
16:39:43 <Peaker> SamB: I don't know, but I'm pretty sure the spec that was available at the time (or perhaps we both downloaded wrong ones?) did not have any such section
16:39:58 <Peaker> SamB: anyway I ended up parsing the result of readelf back then
16:40:17 <Peaker> SamB: anyway, what's the CFI?
16:40:33 <SamB> http://dwarfstd.org/Dwarf3.pdf
16:40:55 <Peaker> 3KB/sec :-(
16:41:16 <SamB> Peaker: it basically defines a function from "what is IP" to "where are the previous frame's registers?"
16:42:02 <Peaker> SamB: But you need the most-nested frame's registers/local variables, not the previous's?
16:43:06 * SamB runs DOSEMU and starts GDB on it
16:44:31 <SamB> arg.
16:44:55 <Gracenotes> v[]
16:47:02 <Peaker> I wonder if you take C, fix its syntax, add a module system, add type-classes and polymorphic types, but remain with strictness, manual memory management,  what kind of language it will end up as
16:47:43 <Peaker> perhaps even purity can be added without requiring GC?
16:48:20 <Peaker> I think as long as its manually memory-managed and strict, it can fill a niche that Haskell can't (Only C, C++, D and such languages are currently filling that niche)
16:50:00 <CalJohn> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2794#a2794 <- can anyone tell me why this code silently fails to write the the file ~/log?
16:50:56 <Saizan_> CalJohn: you never close the handle
16:51:08 <Saizan_> CalJohn: use withFile or hClose
16:51:14 <CalJohn> I am an idiot.
16:51:48 <Vanadium> Would not have happened in C++ :|
16:52:05 <CalJohn> Vanadium: what would have happened in C++?
16:52:06 <mauke> nor in C
16:52:43 <Vanadium> The file would have closed itself upon hitting the next closing brace.
16:53:51 <Saizan_> yeah, that's why haskell has withFile
16:53:58 <CalJohn> to be fair, hand manipulating file handles is on the dumb side of things
16:54:27 <Vanadium> Saizan_: Right :)
16:54:32 <mauke> C's stdio keeps track of all open FILEs and fcloses them for you in exit()
16:55:32 <Peaker> mauke: in Linux, what's the point of that?
16:55:45 <Vanadium> flushing userspace buffers
16:55:46 <mauke> what does linux have to do with this?
16:55:49 <Peaker> mauke: decent OS's will do that for you anyway?
16:55:52 <mauke> no
16:56:02 <mauke> the OS knows nothing about how you use your memory
16:56:03 <CalJohn> Also related - is it safe to have multiple threads write to a file without checking?
16:56:03 <inimino> the stdlib is the part of the OS that does that for you
16:56:12 <Peaker> mauke: oh, fflush the FILE*, you mena
16:56:28 <mauke> (fclose calls fflush for output handles)
16:56:59 <Cale> CalJohn: As long as you don't care about the contents of the file being written in a randomly interleaved order :P
16:57:01 <Peaker> mauke: FILE*'s kinda suck though, not having 64-bit offset seeks and other features, iirc
16:57:11 <CalJohn> Cale: I don't
16:57:23 <CalJohn> at least, not on a line-by-line basis
16:57:29 <Peaker> mauke: I prefer POSIX fd's, myself
16:57:35 <mauke> Peaker: depends on how big your longs are
16:57:41 <mauke> Peaker: also, fgetpost/fsetpos
16:57:57 <Cale> I'm pretty sure there's a chance that it's on a character-by-character basis though.
16:58:15 <Saizan_> it depends on buffering
16:58:18 <Cale> It's probably safest to have one thread which manages writing to the file and accepts things to write to it on a Chan
16:58:25 <Peaker> mauke: can you serialize the result of fgetpos safely?
16:58:46 <CalJohn> Cale: yes, i think there is too
16:58:51 <mauke> Peaker: huh?
16:59:02 <CalJohn> Cale: or a TVar containing the handle, perhaps?
16:59:10 <mauke> Peaker: what usage do you have in mind?
16:59:11 <CalJohn> Cale: so long as I hFlush
16:59:15 <Peaker> mauke: I need to store 64-bit offsets in a file
16:59:24 <Peaker> mauke: and be able to later dereference them
16:59:45 <mauke> I don't know if that's possible
17:00:06 <Cale> CalJohn: Yeah, I suppose you could have an MVar which represented permission to write to the file, and have threads take the handle from that, and put it back when they are finished writing.
17:00:28 <Peaker> mauke: FILE*'s suck :-(
17:00:44 <mauke> Peaker: at least they're not iostreams :-)
17:00:47 <shapr> Everyone in the Northeast USA should consider showing up at Hac phi in Philadelphia!
17:00:51 * shapr boings cheerfully
17:01:36 <Peaker> mauke: yeah, those suck even worse
17:01:47 <mike-burns> shapr: How useful would a total Haskell newb be at Hac Phi?
17:01:58 <byorgey> heck, everyone EVERYWHERE should consider showing up at Hac phi! =)
17:02:06 <shapr> mike-burns: Well, it'd be really useful to you if you want to learn lots about Haskell, yeah?
17:02:12 <shapr> mike-burns: So I'd say, very useful.
17:02:26 <mike-burns> Exellent.
17:02:26 <CalJohn> Cale: I could be wrong, but I think that is a semaphore
17:02:34 <shapr> mike-burns: Plusi, I'll bring my unicycle, and that's always worth something.
17:02:37 <Cale> CalJohn: pretty much.
17:02:40 <shapr> er, 'plus'
17:02:44 <shapr> sheesh, I can't type today.
17:02:44 <byorgey> mike-burns: you are MORE than welcome!  all you need is a willingness to learn and maybe a project you are interested in helping hack on, or a project of your own
17:03:04 <byorgey> mike-burns: there are already some projects listed on the wiki.
17:03:23 <CalJohn> Cale: I'm justing thinking about how you would do multi-threaded logging in haskell
17:03:24 <byorgey> mike-burns: http://haskell.org/haskellwiki/Hac_%CF%86
17:03:28 <mike-burns> Sweet, I'll check it out and probably register.
17:03:34 <mauke> http://mauke.ath.cx/stuff/c%23/stress.cs
17:04:10 <Cale> CalJohn: I would do it basically how I described with a Chan.
17:04:22 <shapr> mauke: Hey, can you license that in such a way that I can install it on the SharePoint servers at work?
17:04:28 <byorgey> mike-burns: in fact, if there is enough interest I was even thinking of trying to organize some sort of Haskell tutorial/crash course for early in the hackathon.
17:04:28 * shapr cackles evilly
17:04:37 <mauke> shapr: public domain!
17:04:41 <shapr> oooh!
17:05:11 <CalJohn> Cale: I think I will try that then
17:05:48 <mike-burns> byorgey: To be honest, I understand enough of the basics that a crash course might not be interesting to me; the stuff I have trouble with now is medium-level stuff: HUnit, quickcheck, gtk2hs, FFI, profiling.
17:05:59 <shapr> Oh, I think you'll fit in just fine then.
17:06:07 <Cale> CalJohn: sometime early on in main, create a new Chan for logging messages, and pass the readChan for that to a thread which will read messages off that chan and write them to a file, and pass the writeChan for it to the rest of the program.
17:06:08 <mike-burns> Sweet.
17:06:15 <byorgey> mike-burns: ah, ok.  well in that case, a hackathon sounds perfect for you.
17:06:30 <shapr> mike-burns: Feel free to invite any Haskell-interested people that you know!
17:06:32 <byorgey> you will level up in Haskell TWICE.
17:06:38 <shapr> ooh, two levels worth of xp!
17:07:27 <mike-burns> I'll invite anyone I can, but I don't don't any Haskellers not in this channel.
17:08:17 <CalJohn> Cale: I'm guessing that readChan will block when a Chan is empty, so it is safe to recur on it?
17:09:08 <CalJohn> Cale: or, in fact, to fold on it?
17:09:31 <Cale> yeah
17:10:01 <byorgey> http://ro-che.blogspot.com/2009/06/shootout.html   hahahahaha!!!
17:10:36 <shapr> I like the cartoon version of dons
17:10:43 <byorgey> yeah, me too =)
17:10:57 <shapr> Hey, is dons coming to hac phi?
17:11:41 <dons> not sure. i'm a bit travelled-out at the moment
17:11:47 <dons> i'll decide soon
17:11:59 <Pseudonym> Telling dons that something has been added to the shootout is the new telling Oleg that it can't be done in the type system.
17:12:09 <dons> seems so :)
17:12:16 * shapr grins
17:12:24 <shapr> dons: Wouldn't want you to burn out!
17:12:41 <Pseudonym> Wouldn't want GHC to slip behind in the shootout, more to the point.
17:13:10 <byorgey> @remember Pseudonym Telling dons that something has been added to the shootout is the new telling Oleg that it can't be done in the type system.
17:13:10 <lambdabot> I will remember.
17:14:38 <dons> home time. nytol.
17:14:42 <shapr> g'nite dons!
17:14:46 <Pseudonym> Night.
17:15:38 <islon_s> does anyone here worked with dinamic compilation in F#?
17:16:17 <Pseudonym> Does F# come with a compiler in the run-time system?
17:16:21 <Pseudonym> That'd be neat.
17:16:42 <islon_s> Microsoft.FSharp.Compiler.CodeDom.FSharpCodeProvider
17:17:09 <Pseudonym> Ah, the names of design patterns are a law unto themselves.
17:17:35 <monochrom> Heh
17:17:50 <Pseudonym> Though I'm not sure that "catamorphism" makes any more or less sense than "AbstractStreamReductionFactory".
17:18:22 <Pseudonym> AbstractTreeReducer
17:18:23 <int-e> what good is the extra laziness that  swap ~(a,b) = (b,a)  provides over  swap (a,b) = (b,a) ? I mean, I can think of examples like  fix (swap . (\(a,b) -> (1,b))), but that seems rather artificial to me.
17:18:24 <Pseudonym> That'd be it.
17:19:03 <Pseudonym> int-e: You're right that it's usually when fix is involved.
17:19:20 <islon_s> i give up, nor even google could help me
17:20:00 <solidsnack> Saizan_: So maybe I should make the DAG with an array? Then copy it in for each insert.
17:20:12 <solidsnack> The idea being, I'd probably do a bulk insert.
17:20:29 <Pseudonym> int-e: Or something like fix.
17:21:11 <Pseudonym> fix-of-a-tuple is, of course, how mutual recursion used to be implemented back in the bad old days before the G machine,.
17:21:28 <Gracenotes> odd that it could stall trying to do a strict pattern match, when there's only one possibility for what the match could be
17:21:33 <solidsnack> Saizan_: I'm sorry for dropping out earlier -- someone on #noisebridge, `aempirei`, attacked my client.
17:21:41 <Gracenotes> hm. well, actually, there is _|_... :/
17:21:49 <Pseudonym> Gracenotes: It's not that odd when you consider the semantics of reduction.
17:21:58 <Pseudonym> Think of a program as a set of rules:
17:22:05 <Pseudonym> f [] = foo
17:22:08 <Pseudonym> f (x:xs) = bar
17:22:08 <Gracenotes> Pseudonym: well, enlighten me. >_>
17:22:18 <Pseudonym> You "fire" the rule when the redex matches the left-hand side.
17:22:32 <Pseudonym> That is, you need to check that the redex conforms to the left-hand side in order to perform the reduction step.
17:22:44 <Pseudonym> Indeed, the old name for it is "conformality check".
17:23:12 <Pseudonym> Why should things be different just because it's a product type?
17:24:09 <Saizan_> solidsnack: i guess it depends on how much you care about performance, but bulk updates shouldn't be slow
17:24:22 <Saizan_> solidsnack: otherwise you'd have to be prepared in staying in ST
17:24:31 <solidsnack> Hmm.
17:24:52 <solidsnack> Think, think, think...
17:25:38 <solidsnack> So   :: Edge -> DAG s -> DAG s    is actually impossible, given my definitions.
17:26:33 <solidsnack> Well, no.
17:26:46 <solidsnack> There's  `flip const`
17:26:55 * Twey chuckles.
17:27:00 <Pseudonym> Isn't there a lazy "assoc" that's required for the arrow axioms?
17:27:08 <Pseudonym> assoc (~(a,b), c) = (a,(b,c)
17:27:09 <Pseudonym> assoc (~(a,b), c) = (a,(b,c))
17:27:16 <Peaker> I'm looking at example Iteratee code, and its so ugly, seems like it could be abstracted so much more into something nice
17:27:22 <Peaker> anyone here knows Iteratee?
17:27:34 <Pseudonym> I think it's needed because  a and b might be forgotten later.
17:27:55 <Pseudonym> http://www.indiana.edu/~iulg/qliqc/j.pdf
17:28:04 <Pseudonym> Someone's been reading sigfpe's blog.
17:31:55 <Pseudonym> I find it interesting that Haskell seems to be becoming the language of choice for theoretical hackery outside of type systems.
17:33:02 <solidsnack> I think maybe coroutines are the right abstraction for IO.
17:33:22 <Pseudonym> I think there is no one right abstraction for IO.
17:33:36 <Pseudonym> IO is an inherently ill-defined problem.
17:34:27 <Pseudonym> I can't see that coroutines are a nice fit for, for example, memory-mapped devices, a.k.a. "volatile" in C.
17:34:44 <hackagebot> haskell-src-exts 0.5.3 - Manipulating Haskell source: abstract syntax, lexer, parser, and pretty-printer (NiklasBroberg)
17:35:51 <Pseudonym> I forsee a day when a Haskell compiler is actually a bunch of packages pulled off hackage, a small amount of glue code and a RTS.
17:36:09 <Pseudonym> Maybe we should start carving off bits of GHC.
17:37:45 <hackagebot> hsx 0.5.1 - HSX (Haskell Source with XML) allows literal XML syntax to be used in Haskell source code. (NiklasBroberg)
17:39:05 <gwern> Pseudonym: IO is the redlight district, where we push off all the ill-behaved domains
17:39:21 <gwern> it's like the old joke - AI is whatever computers can't yet do
17:39:31 <Pseudonym> Sounds like a job for... Awkward Squad(tm)!
17:39:37 <ray> IO is whatever haskell can't yet do nicely
17:39:39 <Pseudonym> Dun dun dun duhhhh...
17:40:09 <Beelsebob> ray: haha, nice description
17:40:49 <gwern> consider the ST monad, or Reader/Writer. weren't these all things that upon a time would've been in IO?
17:40:50 <Peaker> I'd like to see IO split up into ErrorT and IO
17:41:01 <Peaker> is it possible to implement the IORef interface in a generic monad transformer?
17:41:16 <gwern> Maybe might once have just been exceptions - more IOy badness
17:41:26 <zloog> Is there a function that will cycle through an Enum?
17:41:27 <Pseudonym> Peaker: No, because it could be stacked on top of Nondet.
17:41:48 <Peaker> Pseudonym: I mean, with semantics similar to StateT
17:42:03 <Pseudonym> It could be implemented as a coproduct with IO, though.
17:42:04 <ray> in most languages, those things are still "in IO", so to speak
17:42:06 <Peaker> Pseudonym: I could have StateT (Map Id Value) -- but that would just force me to choose a specific Id/Value type
17:42:17 <Pseudonym> (IO :+: Store) a
17:42:20 <Peaker> ray: most languages have everything "in IO"
17:42:30 <Pseudonym> Most languages have STM in IO.
17:42:35 <Pseudonym> But we know that's a bad idea.
17:43:22 <Gracenotes> zloog: if it's a simple Enum (like, all nullary constructors), "enumFrom (fromEnum 0)" should list it from 0 to the max value
17:44:06 <Pseudonym> I kinda like Clean's solution, where you "split off" bits of the world.
17:44:16 <zloog> Gracenotes: Thanks, well what I'm looking for really is just something like the succ function that will wrap back around to the beginning once i reach the end.
17:44:26 <Gracenotes> if you have, suppose, data Color = Red | Orange | Yellow | Green | Blue | Violet deriving Enum, then [Red .. Violet] will do the trick... as will [Red ..]
17:44:38 <ray> modular succ!
17:44:41 <Gracenotes> which are forms of enumFromTo and enumFrom, respectively
17:44:50 <Gracenotes> zloog: ooh. Yes, I've wanted that too >_>
17:44:59 <zloog> Gracenotes: Sorry, i think cycle was the wrong word to use.
17:45:08 <zloog> Gracenotes: Did you have to roll your own?
17:45:10 <Pseudonym> Also derive Bounded, and do [minBound..maxBound] :: [Color]
17:45:14 <Gracenotes> what you can do is, for the above case, cycleSucc Violet = Red, cycleSucc any = succ any
17:45:20 <Gracenotes> if you want a succ that loops
17:45:38 <Gracenotes> I thought you meant, like, a list cycle
17:45:38 <ray> you could define one if you have Bounded
17:45:58 <Gracenotes> and you could define one for (Eq a, Bounded a, Enum a)
17:46:08 <Gracenotes> like ray said
17:46:26 <zloog> Gracenotes: yes, thanks. Just wondering if i was missing something in the standard libs.
17:46:35 <zloog> Gracenotes: but that will work just fine ^_^
17:46:37 <ray> just have a guard to check if it's == maxBound
17:47:03 <Gracenotes> Bounded can be automatically derived
17:48:00 * RayNbow is looking for a good name for the function shown here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5986
17:51:37 <Pseudonym> RayNbow: We don't have a good name for scanl (flip ($)) a fs either
17:51:57 <Pseudonym> Oh, hang on.
17:52:16 <Pseudonym> @hoogle (Arrow a) => [a r r] -> r -> [r]
17:52:16 <lambdabot> Control.Monad.Reader runReader :: Reader r a -> r -> a
17:52:16 <lambdabot> Control.Monad.State.Lazy execState :: State s a -> s -> s
17:52:16 <lambdabot> Control.Monad.State.Strict execState :: State s a -> s -> s
17:52:23 <Pseudonym> Nah, guess not.
17:52:30 <Pseudonym> Sorry.
17:52:34 <Pseudonym> @hoogle (Arrow a) => [a r r] -> a r [r]
17:52:35 <lambdabot> No results found
17:52:43 <Pseudonym> Would that be a better interface?
17:52:52 <ray> @arr
17:52:53 <lambdabot> Avast!
17:53:39 <RayNbow> hmm
17:55:14 <Pseudonym> Probably not for your purposes.
17:55:58 <RayNbow> Pseudonym: well, it would be more generic
17:56:43 <Pseudonym> But it'd require wrapping things in Kleisli.
17:57:53 <RayNbow> that's not really a problem... we could always make a less generic version using the generic function for convenience...
17:58:43 <RayNbow> but it would be nice if we came up with a name for f :: Arrow (~>) => [r ~> r] -> (r ~> [r])
17:59:56 <Gracenotes> the monadic scanl?
18:00:07 <Gracenotes> scanl1, that is
18:00:27 <Gracenotes> @type scanM
18:00:28 <lambdabot> forall r a (m :: * -> *). (Monad m) => (r -> a -> m r) -> r -> [a] -> m [r]
18:01:18 <RayNbow> scanM is more generic than [a -> m a] -> a -> m [a] though
18:03:00 <Gracenotes> indeedy.
18:03:31 <Gracenotes> but the arrow version is pretty generic itself
18:04:02 <RayNbow> composeAndCollectIntermediateResultsBecauseWeLoveCamelCaseNames -- let's start with a candidate that will certainly not be favored :p
18:05:21 <mike-burns> In the style of `nub' and `intercalate', should we break out the dictionary of unused English words?
18:05:56 <sjanssen> mike-burns: haha
18:05:59 <Gracenotes> accumCompose -- pretty dense
18:06:13 * sjanssen opposed intercalate
18:06:22 <Pseudonym> :t scanl (>>>) a fs
18:06:23 <lambdabot> Not in scope: `fs'
18:06:24 <Pseudonym> :t scanl (>>>)
18:06:26 <lambdabot> forall (cat :: * -> * -> *) a c. (Control.Category.Category cat) => cat a c -> [cat c c] -> [cat a c]
18:06:26 <Gracenotes> maybe we can append an "A" since it's an arrow. or is A for applicative? darn!
18:06:51 <Saizan_> for arrow we clearly have to use Arr these days
18:06:53 <Pseudonym> I guess that doesn't need a name.
18:07:06 <Pseudonym> scanl (>>>) is smaller than any name I can think of.
18:07:24 <aavogt> @type mconcat [Endo $ (+1)]
18:07:25 <lambdabot> forall a. (Num a) => Endo a
18:07:34 <Saizan_> it's not the same thing, though?
18:07:49 <Pseudonym> > scanl (>>>) [(+1),(*2)] 5
18:07:50 <lambdabot>   Couldn't match expected type `cat a c' against inferred type `[a1]'
18:07:57 <Gracenotes> burn.
18:08:04 <Pseudonym> Actually, I guess not.
18:08:18 <Pseudonym> foldl (.) id [(+1),(*2)] 5
18:08:27 <Gracenotes> I'd favor foldr for composition
18:08:28 <Pseudonym> > foldl (.) id [(+1),(*2)] 5
18:08:30 <lambdabot>   11
18:08:34 <Pseudonym> It's what you want, right?
18:08:46 <Gracenotes> but for monadic composition... quizas
18:08:46 <Pseudonym> Fine, foldr.
18:09:01 <Pseudonym> foldr (>>>) (arr id)
18:09:04 <loupgaroublond> where can i information on autoconf macros for c2hs?
18:09:18 <Pseudonym> Actually, I guess it'd be flip (>>>)
18:09:27 <aavogt> @type sequence [(+2),(*5)]
18:09:28 <lambdabot> forall a. (Num a) => a -> [a]
18:09:40 <Pseudonym> :t sequence
18:09:41 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
18:11:34 <aavogt> sequence isn't right here though
18:11:50 <aavogt> > sequence [(+1),subtract 1] 1
18:11:51 <lambdabot>   [2,0]
18:14:08 <Pseudonym> :t foldr (>>=) return
18:14:10 <lambdabot>     Occurs check: cannot construct the infinite type: b = a -> b
18:14:10 <lambdabot>     Probable cause: `>>=' is applied to too many arguments
18:14:10 <lambdabot>     In the first argument of `foldr', namely `(>>=)'
18:14:17 <Pseudonym> :t foldr (flip (>>=)) return
18:14:18 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a -> a -> m a] -> a -> m a
18:21:51 <dons> shapr: did you see amazon released the source code to the kindle?
18:22:02 <dons> might be some pdf rendering stuff we could have fun with haskell using...
18:22:23 <bd_> dons: isn't that just the source to the GPL/LGPL software they've used on it?
18:22:54 <mike-burns> Yes.
18:25:22 <BMeph> @type flip foldr (=<<)
18:25:23 <lambdabot> forall a a1 (m :: * -> *) b. (Monad m) => (a -> ((a1 -> m b) -> m a1 -> m b) -> (a1 -> m b) -> m a1 -> m b) -> [a] -> (a1 -> m b) -> m a1 -> m b
18:25:34 <BMeph> @type flip (foldr (=<<))
18:25:36 <lambdabot> forall (m :: * -> *) b. (Monad m) => [b -> m b] -> m b -> m b
18:26:15 <BMeph> @type (.flip (foldr (=<<)))
18:26:16 <lambdabot> forall c (m :: * -> *) b. (Monad m) => ((m b -> m b) -> c) -> [b -> m b] -> c
18:26:25 <BMeph> @type (flip (foldr (=<<)).)
18:26:26 <lambdabot> forall (m :: * -> *) b a. (Monad m) => (a -> [b -> m b]) -> a -> m b -> m b
18:26:45 <BMeph> Sorry for the spam, I'll take it to Querries, now.
18:27:39 <RayNbow> Pseudonym, Gracenotes, http://img189.imageshack.us/img189/5545/accumcompose.png ? :p
18:28:08 <RayNbow> (I have too much time on my hands)
18:28:28 <RayNbow> (especially if you consider this was made in Paint :p)
18:28:30 <Gracenotes> based on "[09:05:37] <Gracenotes> accumCompose -- pretty dense"?
18:28:46 <RayNbow> the filename, yes :)
18:28:46 * gwern doesn't understand that diagram at all
18:29:03 <Gracenotes> it should be able to work on any arrow, I guess?
18:29:21 <Gracenotes> hm. or maybe not.
18:30:02 <RayNbow> personally I'm interested in using it for Kleisli arrows :p
18:30:02 <Gracenotes> any arrow that has a reverse-arr, I'd guess
18:30:05 <BMeph> Is that the type for costrength? :)
18:30:07 <int-e_> > fix((<**>((:)<$>['a'..'z'])).([]:))
18:30:09 <lambdabot>   ["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s...
18:30:20 <int-e_> > fix((<**>((:)<$>['a'..'c'])).([]:))
18:30:21 <lambdabot>   ["a","b","c","aa","ba","ca","ab","bb","cb","ac","bc","cc","aaa","baa","caa"...
18:30:25 * BMeph looks it up...
18:30:25 <Gracenotes> Arrow (~>) => (b ~> c) -> (b -> c). reverse arr.
18:32:09 <RayNbow> anyway, going to get some sleep... it's 3:30 AM already
18:32:10 <Gracenotes> or maybe, Arrow (~>) => (b ~> c) -> (b -> d)
18:32:12 <RayNbow> g'night #haskell :)
18:32:22 <Gracenotes> dunno :x bye bye
18:32:29 <RayNbow> bye :)
18:36:33 <Gracenotes> int-e_: kleene! awesome
18:36:44 <Gracenotes> er.. what's the term.
18:36:51 <Gracenotes> powerset?
18:37:04 <Gracenotes> no.
18:37:21 <Gracenotes> yeah, probably the kleene of the set (not including epsilon)
18:37:36 <tompledger> Gracenotes: 'spreadsheet column headings'  ;-)
18:37:53 <Gracenotes> hehe
18:38:12 <BMeph> I thought those were in lexi-order? :)
18:38:46 <Gracenotes> I guess, although they don't sound so CS-y...
18:40:10 <Gracenotes> order's nice when it comes to enumerations though
18:40:16 <jaredj> Analogy question: Maybe : fromJust :: AnyTypeWithMultipleConstructors : ??
18:41:01 <Gracenotes> well.. the ideal function for "deconstructing" Maybes is maybe
18:41:03 <Gracenotes> @type maybe
18:41:04 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
18:41:09 <jaredj> right -
18:41:34 <jaredj> but say - data Flump a = One a | Other a
18:41:43 <jaredj> i have xs :: [Flump Int]
18:42:12 <jaredj> i want all the Others. i write [x | x <- xs, <what>]?
18:42:36 <jaredj> ooor i write [x | Other x <- xs]. that's it isn't it
18:42:50 <Gracenotes> that would work.
18:42:54 <jaredj> waitwait that wasn't what i didn't know
18:43:05 <Gracenotes> it's how lefts and rights is defined, from Data.Either
18:43:13 <jaredj> data Flump a = One a | Other a | YetOther a
18:43:21 <jaredj> i want all the Others and YetOthers
18:43:28 <jaredj> i want to say "everything but the Ones"
18:43:45 <BMeph> catOthers, mebbe? ;)
18:43:48 <int-e_> Gracenotes: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5987#a5987
18:44:20 <jaredj> (the Flump is actually Text.HTML.TagSoup.Tag and i don't want to bother listing all the constructors besides TagComment)
18:44:47 <Gracenotes> jaredj: so you want to keep the constructors?
18:44:55 * BMeph hums something that sounds almost like "filter . not"...
18:45:07 <jaredj> that sounds sane bmeph
18:45:11 <Gracenotes> if so... yeah. *looks furtively as BMeph*
18:45:25 <jaredj> i was thinking about pattern matching with list comprehensions
18:45:31 <aavogt> [x | x <- xs, case x of { One _ -> False; _ -> True }] -- probably looks better as a filter...
18:45:33 <jaredj> and realized i didn't know how to match an antipattern
18:45:39 * BMeph looks around "innocently" - he was just humming... ;p
18:45:43 <Gracenotes> make an "isTagComment" function and filter against it.
18:46:04 <thoughtpolice> filter f xs where f (One _) = False; f _ = True
18:46:08 <Gracenotes> list comprehensions are okay, but map and filter and whatnot are clearer, at least to me
18:46:08 <jmcarthur> @src catch
18:46:09 <lambdabot> catch m k = catchException m handler where handler (IOException err) = k err
18:46:28 <jmcarthur> @hoogle catch
18:46:29 <lambdabot> package catch
18:46:29 <lambdabot> Prelude catch :: IO a -> (IOError -> IO a) -> IO a
18:46:29 <lambdabot> Control.Exception catch :: IO a -> Exception -> IO a -> IO a
18:46:36 <thoughtpolice> well, it's mainly jus that there's not an easy way to say 'match this pattern, and if that doesn't work, try this pattern'
18:46:40 <jmcarthur> okay, neither of those define catch that way
18:46:48 <thoughtpolice> i believe smlnj supports 'or' patterns which solve this
18:46:54 <jmcarthur> @hoogle catchException
18:46:55 <lambdabot> No results found
18:47:05 <BMeph> Ooh, that reminds me - say, gang, what's the extra info telling the computer to get this:
18:47:05 <jaredj> thanks all
18:47:11 <BMeph> @pl \g f -> (. f) . g . f
18:47:12 <lambdabot> ap ((.) . flip (.)) . (.)
18:47:16 <BMeph> @pl  \g f x y -> g (f x) (f y)
18:47:16 <lambdabot> join . ((flip . ((.) .)) .) . (.)
18:47:34 <jaredj> (...)
18:47:54 <jmcarthur> :t \g f x y -> g (f x) (f y)
18:47:56 <lambdabot> forall t t1 t2. (t1 -> t1 -> t2) -> (t -> t1) -> t -> t -> t2
18:47:57 <BMeph> (Just FYI, this is 'on'.)
18:48:01 <jmcarthur> yeah that's what i though
18:48:03 <jmcarthur> t
18:48:20 <Gracenotes> BMeph: liftA2 (.) (flip (.)) . (.)
18:48:34 <Gracenotes> my complicated pl'd version of on :)
18:48:38 <jrockway> heh, amazon amuses me: http://www.amazon.com/gp/product/1605503460/ref=s9_intb_gw_tr01?pf_rd_m=ATVPDKIKX0DER&pf_rd_s=center-3&pf_rd_r=1JQ1J73J5SKMASYGT43C&pf_rd_t=101&pf_rd_p=470938811&pf_rd_i=507846
18:48:47 <jrockway> it thinks i want to buy that because i "may like don stewart"
18:48:49 <BMeph> Maybe I just need to get augustss in a corner and grill 'im. ;p
18:48:56 <Gracenotes> hand crafted! *pats self on back* >_>
18:49:16 <Gracenotes> I took them points and I took 'em out and shot 'em dead
18:49:49 <jaredj> i can't pattern match with a lambda can i?
18:49:59 <Gracenotes> not with treacherousness
18:50:02 <jaredj> like \(TagComment x) -> False; \ _ -> True
18:50:16 <jaredj> (but that didn't work)
18:50:26 <Gracenotes> case statement
18:50:30 <jaredj> yeh k
18:50:36 <thoughtpolice> yeah, like I said, no equivalent of or-patterns
18:53:11 <jmcarthur> hmm... it's looking like I can't make a catch with type MonadIO m => m a -> (IOError -> m a) -> m a
18:53:42 <jmcarthur> not sure how i would do that, given that the existing catch has type IO a -> (IOError -> IO a) -> IO a
18:54:20 <jmcarthur> just mentioning that here to get some verification
18:54:59 <jmcarthur> except for not knowing about the IO newtype, even the low level catch# has the same type
18:56:47 <Cale> jmcarthur: that's right... though in some MonadIOs it is possible to construct one anyway.
18:56:54 <jmcarthur> best i can do is :: MonadIO m => IO a -> (IOError -> IO a) -> m a
18:57:08 <jmcarthur> Cale: alright thanks
18:57:09 <Cale> yeah, that's the easiest thing
18:57:45 <Cale> Then, if you have a way to locally run the transformer over IO, you can go the rest of the way
18:57:53 <jmcarthur> right
19:09:02 * copumpkin feels ignored in haskell-cafe :(
19:10:26 <sjanssen> copumpkin: good!
19:11:02 <copumpkin> oh, my solution was kind of wrong anyway, but only slightly
19:11:11 <Gracenotes> being wrong builds character
19:11:24 <copumpkin> I must have an amazing character by now then
19:12:00 <monochrom> Being wrong builds character. A crackpot character.
19:12:13 <copumpkin> sounds like me :)
19:12:31 <Gracenotes> like ⿄?
19:12:41 <monochrom> hahaha
19:12:56 <Gracenotes> which is ... salt, apparently
19:13:09 <copumpkin> traditional salt?
19:13:22 <Gracenotes> have a turtle. ⿔
19:13:29 <copumpkin> it's actually the radical codepoint
19:13:41 <Gracenotes> it is
19:13:55 <copumpkin> you just browsing the CJK section of the character table?
19:14:28 <Gracenotes> indeed I am browsing
19:14:35 <copumpkin> Gracenotes: there are some awesome characters in unicode, but some even crazier ones aren't available in it
19:14:38 <Gracenotes> right before CJK section though
19:15:03 <Gracenotes> kangxi
19:15:13 <copumpkin> yeah, that's the standard set of radicals
19:15:19 <Gracenotes> "This block contains 42719 characters. Displaying it will take a long time. Do you want to continue?" :3
19:15:37 <copumpkin> if you're on mac os you can browse it without whatever software spat out that message
19:15:52 <Gracenotes> web page
19:15:56 <copumpkin> ah
19:17:17 <copumpkin> Gracenotes: if you want to see some really crazy ones, look up mojikyo
19:17:47 <copumpkin> that has all of the standard unicode ones plus some crazy ones the japanese invented ("coined")
19:20:01 <Gracenotes> woooo kanji
19:21:30 <copumpkin> they have that ridiculous three clouds over three dragons character with 84 strokes
19:25:42 <shapr> Nafai: cool article!
19:26:33 <Cale> 𒁃 (obviously not kanji)
19:29:20 <JoshRosen> I'm playing around with some code that does IO and I've run into a bit of a snag: I get the error "Couldn't match expected type `Bool' against inferred type `IO Bool'" when using an if statement.
19:29:53 <mike-burns> You should paste the code.
19:30:00 <Saizan_> do b <- boolIO; if b then .. else ..
19:30:24 <Saizan_> instead of if boolIO then .. else ..
19:30:35 <copumpkin> shapr: how is that bostonhaskell related to chug?
19:30:46 <JoshRosen> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2795#a2795
19:31:09 <tommd> BostonHaskell vs. chug: One programs, the other drinks.  Ten points if you can guess which is which.
19:31:22 <copumpkin> Cale: what character is that? I don't have any fonts with a glyph for that
19:31:23 <ikegami__> Mojikyo institute distributes their original about /a fifth million/ fonts, includes Unicode and more Kanji characters
19:31:39 <Cale> copumpkin: It's a cuneiform character
19:31:39 <copumpkin> ikegami__: yeah
19:31:51 <mike-burns> JoshRosen: Did Saizan_'s explanation make sense?
19:31:52 <copumpkin> also, if you just want the entire ext. A and ext. B CJK(V)
19:31:52 <Saizan_> in your case boolIO = (Data.Maybe.isJust `liftM` (Data.HashTable.lookup dictionary "word"))
19:32:03 <copumpkin> there's a complete (if not particularly beautiful) font called Han nom
19:32:06 <JoshRosen> mike-burns: Yes.  I tried that and it worked.
19:32:16 <copumpkin> but it's free
19:32:42 <JoshRosen> Thanks for the help.
19:32:52 <Cale> JoshRosen: The way to think of it is that a value of type (IO t) is like a program which you can run to get a value of type t, inside another IO computation.
19:33:28 <Cale> If x :: IO t then  v <- x  says to run x, naming the result v (which will have type t then)
19:34:14 <JoshRosen> So, I can think of the <- arrow as extracting the "stuff" in the IO box that results from the computation on the right hand side of the arrow?
19:34:21 <copumpkin> is there a good way (using the GHC api probably) to take a buffer containing haskell source and get an expression tree such that I can look up the type of any part of any expression in the source (assuming it typechecked)
19:34:46 <copumpkin> JoshRosen: you can think of it as "running" the IO and naming the result, more than extracting
19:37:25 <Saizan_> copumpkin: you probably want the external core of that module
19:37:42 <copumpkin> that will have undergone huge transformations by then, won't it?
19:38:43 <Saizan_> uhm, right
19:38:56 <copumpkin> so it doesn't get typechecked until it's been through the simplifier?
19:39:07 <sjanssen> anybody familiar with this Clojure ants demo I've seen on reddit?  Tried to implement it in Haskell?
19:41:03 <Saizan_> copumpkin: no, it's typechecked at the start, the result is what you have in HsSyn, afaiu
19:41:22 <copumpkin> hmm
19:43:30 <copumpkin> so I basically want something where I could feed it "a = foldl1' (+) [1..]\nb = 36 + product [1..5]" and have it give me a "syntax" tree where I can see the inferred types of everything in that expression (down to the number literals etc.)
19:44:14 <Saizan_> looks like you need to construct a module around that and use GHC.typecheckModule
19:44:47 <Saizan_> so that you can get the TypeCheckedSource out of it
19:45:03 <copumpkin> ah
19:45:14 <copumpkin> then I can query the TypeCheckedSource in that way
19:46:35 <copumpkin> it's a pity it relies on file-ness
19:46:36 <Saizan_> yeah, it should have enough type annotations included
19:46:39 <copumpkin> for the ModSummary
19:46:49 <copumpkin> ah well, it'll work :)
19:46:51 <copumpkin> thanks!
19:47:21 <copumpkin> does using the GHC API automatically add a terabyte to my statically linked executable size? :
19:47:23 <copumpkin> :P
19:47:45 <SamB> copumpkin: only when you do it on 64-bit machines
19:47:57 <copumpkin> only half a terabyte on 32-bit?
19:48:14 <SamB> no, more like 2GB
19:48:24 <copumpkin> :o
19:48:41 <Saizan_> i think scion does something similar to this
19:48:53 <copumpkin> oh yeah, scion might actually help me a lot
19:59:11 <copumpkin> I wonder how hackable darcs is
19:59:36 <helgim_> +OK ES9VO.sr3If.CHABx./lOTQ/32m.v/B8qJ./nA9zC16BxSK06oNsQ0BwQmF/Z6YbD/EDCJD1KgYzI1hyHHI/PBHnn/jkoav.03ZBW1lu9at/eK9Hp.rNDwK0o0nlu/YtWdL1jGvZq.Fxt/T.pxMVu1yS1FB03GQoT1cp.9o1IVHq6/r.We21AuzcE.xu3DU.PkMq21ouWqG0AqqHd.2L3UI0CQKH..aXk6I1Nx2SC.A8ayt.//AZc/z2Lp2/5YrGD0r7gjC0nqAS7/82rpg0Jle1.1e9sfg/p4uJ./VIq/r/8H3yH/kJACP0N4pAu0OwxQ71sQ/tJ0ELbmH/yp8oo0kR0Xa/XRjRZ1pGLnB0cQtvH1ZBHxG0
19:59:44 <copumpkin> uh
19:59:48 <Gracenotes> forsooth
20:00:35 <gwern> copumpkin: darcs isn't particularly hackable; gnarly codebase, although there's been a lot of improvement since david
20:00:46 <copumpkin> ah :/
20:01:26 <gwern> though it does depend on what you have in mind
20:01:34 <copumpkin> I think it'd be pretty major
20:01:52 <copumpkin> I don't really have a concrete plan (or any time to work on it even)
20:02:28 <gwern> what did you have in mind?
20:02:50 <gwern> I managed filestore without having to go through darcslib
20:03:09 <copumpkin> I wanted to try to add type-awareness to it, for haskell code in particular... that's pretty vague though :)
20:03:22 <jmcarthur> i've been wanting the same thing
20:03:27 <gwern> oh. that's a massive task, you're right
20:03:43 <copumpkin> but it could be pretty awesome, I think
20:03:51 <copumpkin> and its awesomeness would increase with the power of the type system
20:04:02 <gwern> it'd be an effort just to add whitespace support, to say nothing of something as complex and fragile as type-inference. I'm not even sure how that'd work
20:04:19 <gwern> I've never heard anyone praise the smalltalk VCSs which had language awareness, at least
20:04:30 <copumpkin> yeah, but they didn't have a type system
20:04:55 <copumpkin> I think that would make all the difference
20:05:09 <copumpkin> it wouldn't just be syntax-aware, but (to a degree) semantics-aware, through the type system
20:05:16 <jmcarthur> a more modest change: i've been wanting to make patches toggleable. like you can disable some but they are still in the repo, just not applied to pristine or counted as dependencies for patches you record while they are disabled
20:05:19 <gwern> types are not magic pixie dust; do you have any examples of patch commuting with types?
20:05:33 <jmcarthur> replaces much of the need for branches, for me
20:05:59 <copumpkin> not really, just some vague ideas... maybe I should try to think it through more and learn more about darcs before embarrassing myself with bullshit :)
20:06:02 <jmcarthur> and would be especially nice with a gui to just toggle entire dependency branches at a time
20:06:39 <loupgaroublond> is the nullPtr in Foreign the same as the C constant NULL?
20:06:49 <gwern> jmcarthur: this the same idea as in-repo branches?
20:07:25 <jmcarthur> gwern: not really. i think my idea is more darcs-like
20:07:38 <jmcarthur> it's about managing patches, not branches
20:08:43 <jmcarthur> and you can enable or disable entire "branches" at a time by toggling patches (and their dependencies would follow naturally)
20:08:52 <jmcarthur> not the same as "switching" branches, though
20:09:51 <sjanssen> loupgaroublond: supposed to fill the same purpose, yes
20:27:08 <hatds> loupgaroublond: yes
20:27:16 <hatds> it will compare == in C
20:27:42 <loupgaroublond> a thanks
20:28:36 <loupgaroublond> when i'm using c2hs, where to i specify which C header to import? do i just put a 'foreign import' at the beginning of the .chs file/
20:35:57 <joanne> anyone in munich??
20:36:00 <joanne> madrid??
20:36:05 <joanne> need help??
20:36:10 <joanne> visiting there soon??
20:41:09 <joanne> helloo!!1
20:42:33 <heatsink> If you have a haskell-related question, I'll try to answer it.
20:42:50 <joanne> nope..
20:43:05 <joanne> i am going to portugal for 2 to 3 months..
20:43:09 <joanne> i need help ...
20:44:10 <gwern> now now. portugal isn't that bad a place
20:44:45 <gwern> you might even enjoy it; I've heard the beaches are nice there. and they must have plenty of historical sites to see
20:45:25 <joanne> hi gwern...where u from..
20:45:32 <joanne> u from portugal..
20:45:34 <gwern> the US
20:45:56 <gwern> if I was portugal, I think I wouldn't be using phrases like 'I've heard', or 'they must have'
20:46:13 <joanne> ah..sorry..a little bit excited..
20:46:18 <joanne> nways..
20:46:31 <joanne> i tot i could probably get some online help..
20:46:41 <joanne> but...bet thats nt gonna happen..
20:46:45 <joanne> lolz
20:46:49 <aavogt> joanne: its roughly 6 AM in those cities, which is not a common time to be on irc, never mind being awake
20:47:13 <gwern> aavogt: and joanne might not want advice from the vampires who are on irc at that time
20:47:59 <aavogt> yep
20:48:15 <joanne> hahaha..thanks guys..appreciate the help...think should come onlne a little bit later then..
20:48:36 * Beelsebob is sat in antwerpen
20:48:38 <Beelsebob> awake
20:48:44 <Beelsebob> and yeh, 5:50am
20:48:58 <Beelsebob> broken sleep pattern is broken
20:49:01 <RyanT5000> so, how does one go about starting a mailing list on haskell.org?
20:49:18 <joanne> hi beelsebob..u from germany huh??
20:49:28 <Beelsebob> joanne: Antwerpen is in Belgium
20:49:51 <joanne> hahaha...ooppsss..there's goes my geography!!
20:50:00 <joanne> age n gender??
20:50:13 <joanne> gonna go to belgium as well..
20:50:34 <Beelsebob> @asl
20:50:34 <lambdabot> Plugin `tell' failed with: Prelude.head: empty list
20:50:37 <Beelsebob> awww :(
20:50:41 <Beelsebob> @vixen asl
20:50:41 <lambdabot> 19/f/California
20:50:45 <Beelsebob> there you go :P
20:50:54 <Apocalisp> @yow asl
20:50:55 <lambdabot> With YOU, I can be MYSELF ...  We don't NEED Dan Rather ...
20:51:30 <heatsink> Being from California, I find it strange that California is the sexy place to be from.
20:51:45 <joanne> m i right to say that all of you guys r american??
20:51:55 <Cale> joanne: Nope :)
20:51:55 <joanne> i mean americans??
20:52:03 <scutigera> yep
20:52:12 <joanne> okie...then any europeans??
20:52:18 <Cale> joanne: I'm Canadian, there are many people from Europe, and all over the place.
20:52:28 <joanne> hehe..no offence americans just need europenas help!!
20:52:30 <joanne> hehehhe
20:52:31 <scutigera> where in .ca
20:52:35 <Beelsebob> joanne: no, I'm not 'merican
20:52:45 <Cale> scutigera: Southern Ontario (Brantford)
20:52:46 <joanne> then??
20:52:52 <Beelsebob> british, living in belgium
20:53:08 <joanne> oohh...like i said ..gonna visit there too..
20:53:11 <scutigera> Cale: got relatives in Toronto, but go Habs !
20:54:11 <joanne> im gonna visit lisbon..madrid...munich..so i need help from that part of the country..
20:54:18 <Cale> joanne: How long have you been programming in Haskell?
20:54:25 <joanne> also going top germany and belgium..
20:54:38 <joanne> cale : just today!!!
20:54:47 <Cale> ah, cool!
20:55:16 <Cale> Be sure to ask if you have any questions about it. There are usually lots of friendly people around who like to help beginners.
20:55:49 <Cale> We have lambdabot here, which evaluates expressions and determines types, among other things
20:56:07 <Cale> > foldr (+) 0 [1..10]
20:56:09 <lambdabot>   55
20:56:14 <Cale> :t foldr
20:56:17 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
20:56:40 <joanne> cale : im lost..
20:56:54 <scutigera> [1..10]
20:56:57 <joanne> i mean ..erm..how old r u guys again???
20:57:06 <Cale> Any line which starts with a > and a space will be evaluated, and the result displayed by the bot
20:57:09 <Cale> I'm 26
20:57:18 <scutigera> > [1..10]
20:57:19 <Beelsebob> I think he's saying (rather more politely than me) can you stick on topic with Haskell programming, but if you do, people will be more than willing to help
20:57:19 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
20:57:37 <Cale> and lines prefixed with :t will result in the type being displayed
20:57:46 <Cale> :t length
20:57:48 <lambdabot> forall a. [a] -> Int
20:57:54 <Cale> > length "hello"
20:57:56 <lambdabot>   5
20:58:10 <joanne> i take it as..if i dont have any questions on haskell programming i sould gp... :(
20:58:18 <joanne> i mean go...
20:58:19 <Cale> Well, hang around
20:58:49 <scutigera> I didn't realize lambdabot was running on the list - I thought it had to enabled locally. Always nice to learn something new :-)
20:59:11 <joanne> hahaaa..no worries..
20:59:19 <monochrom> (500+ people in #haskell could not be all because they have questions... :) )
20:59:21 <joanne> gonna go now.have lunch n go to work..
20:59:22 <scutigera> how best to write doubles as binary data ?
20:59:25 <joanne> take care guys..
20:59:30 <joanne> go sacremento11
20:59:30 <Cale> see you around!
20:59:40 <joanne> erhh!! cho!!
20:59:47 <hackagebot> clock 0.1.2 - High-resolution clock and timer functions: (CetinSert)
21:00:08 <loupgaroublond> don't feed the trolls :/
21:00:15 <loupgaroublond> that was funny to watch though
21:00:22 <Cale> loupgaroublond: Apparently not a troll.
21:00:40 <Beelsebob> scutigera: Data.Binary?
21:00:43 <loupgaroublond> nigerian scammer = troll in my book :P
21:00:44 <lament> trolls don't have names like "joanne".
21:01:39 <Cale> loupgaroublond: what?
21:01:48 <monochrom> trolls don't let trolls troll #haskell
21:02:01 <scutigera> Beelsebob: in GHC or hackage ?
21:02:10 <Cale> loupgaroublond: Where was the nigerian scammer?
21:02:13 <thoughtpolice> scutigera: it's on hackage
21:02:18 <thoughtpolice> scutigera: the package is 'binary'
21:02:28 <Cale> scutigera: You could also go with storablevector
21:02:39 <thoughtpolice> scutigera: it should already have instances for reading/writing doubles so you should have no problem
21:02:43 <monochrom> I think one day I will mistake hackage for wreckage.  <duck>
21:03:02 <loupgaroublond> Cale, it's kinda like a nigerian scam, someone poses online as a girl and tries to flirt with anyone who will pay attention, they go around to different niche locations, for example a friend of mine was targetted on one dating site for orthodox jews
21:03:07 <scutigera> Well there it is, looks like what I need...
21:03:30 <loupgaroublond> if you do more than just say hello back, they'll continue the charade sending pictures, and then finding someway to get your money basically
21:03:54 <Cale> loupgaroublond: It seems far fetched to assume that a random person on IRC is such a scammer without a reason to believe that.
21:03:56 <scutigera> Well Cale was all business...
21:04:07 <scutigera> ;-)
21:04:12 <loupgaroublond> but when you're posing as an african who 'wil convert to judaism for you' with a picture of a woman wearing very american styles, you get tipped off pretty easily
21:04:19 <lament> loupgaroublond: one would expect to find such people at a dating site, not a programming channel
21:04:23 <scutigera> LOL
21:05:11 <loupgaroublond> w/e, find one line she said that had to do with programming :P
21:05:22 <Saizan_> loupgaroublond: it seems you've taken the "there are no girls on the internet" rule too literally :)
21:06:10 <loupgaroublond> that too, just 40 year old balding men who live in their mother's attic or basement :P
21:06:22 <monochrom> You don't need to establish it is a nigerian scammer if you just want to establish it is a troll.
21:06:38 <monochrom> Thank God I am not bald.
21:06:48 <monochrom> Not balding either.
21:07:14 <monochrom> Perhaps I should assume a female nick too.
21:07:19 <loupgaroublond> haha
21:07:31 <Cale> loupgaroublond: Well, they did say that they had started learning Haskell today.
21:07:34 <Saizan_> see, you're already luring us into asking you a picture..
21:08:00 <lament> monocka: I will convert to Judaism for you.
21:08:13 <scutigera> monochromette
21:08:13 <monocka> No, Christianity please.
21:08:18 <lament> sorry
21:08:21 <Cale> loupgaroublond: I think our default should be a friendly and open attitude. Not everyone knows the social norms of IRC too.
21:08:38 <Nafai> shapr: Thanks!
21:08:51 <loupgaroublond> agreed, i hope you don' think i'm being too critical
21:09:06 <loupgaroublond> i'm just a little skeptic about 'joanne', haha
21:09:39 <scutigera> can values generated in a monad be "returned" to pure code ?  e.g. random number gen, generates int in a monad, so can you return Int and not IO Int ?
21:09:39 <Cale> In fact, I never assume that someone is trolling, even when I suspect that they are, I will answer their questions properly. If nothing else, anyone else who is listening will benefit from the answers. :)
21:09:40 <loupgaroublond> if she comes back in three days with a real question, well, then either a very intelligent creative nigerian scammer, or it's legit
21:09:57 <monocka> scutigera: No.
21:09:59 <Cale> scutigera: No, but you can pass that Int to a pure function.
21:10:12 <scutigera> drat and ?
21:10:35 <lament> dealing with random numbers in haskell is the most annoying thing ever.
21:10:36 <Cale> Consider something in the IO monad like  do x <- getLine; putStrLn (reverse x)
21:10:37 <heatsink> do {x <- myMonadFunctoin; return (myPureFunction x)}
21:10:45 <Cale> reverse is a pure function
21:10:55 <lament> :t reverse
21:10:56 <lambdabot> forall a. [a] -> [a]
21:11:01 <Cale> No mention of IO :)
21:12:07 <scutigera> so the situation is different for random ? (confused)
21:12:33 <lament> random functions are not pure
21:12:33 <Cale> scutigera: Well... there are many options for writing computations that work with random numbers
21:12:56 <scutigera> I'm using the infinite list version and just doing take n
21:13:35 <monocka> Then you are not using any monad for random numbers.
21:13:51 <Cale> One, which is perhaps the first you should understand, though it is often not the nicest way, is for the function to take the state of a random number generator as a parameter, and (possibly) return the final state of that random number generator along with its result.
21:14:02 <scutigera> exactly, because I did not understand how to :-(
21:14:09 <Cale> :t randomR
21:14:11 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> (a, g)
21:14:30 <Cale> randomR takes a pair which serve as a lower and upper bound for things to generate
21:14:37 <Cale> and a generator state
21:14:55 <Cale> and it produces a (pseudo-)random value along with a new generator state
21:15:13 <Cale> Given the same input generator state, it always produces the same value
21:15:24 <Cale> So it really is a function.
21:15:41 <Cale> But how do we get one of these 'g' values to start with?
21:15:47 <Cale> :t newStdGen
21:15:49 <lambdabot> IO StdGen
21:15:57 <Cale> Well, that's typically done from IO
21:16:06 <Cale> (StdGen is an instance of RandomGen)
21:16:19 <Cale> there is also
21:16:22 <Cale> :t mkStdGen
21:16:23 <lambdabot> Int -> StdGen
21:16:41 <Cale> If you don't mind getting the same results every time your program runs
21:16:46 <Cale> (useful for testing)
21:17:08 <scutigera> yeah - that same random sequence thing confused me at first. wasn't in Kansas anymore.
21:17:24 <scutigera> as you said, very useful for testing
21:17:59 <Cale> newStdGen though will give you a hopefully random-enough initial generator
21:18:26 <Cale> (I think it's actually stupidly based on the time of day rather than the system entropy pool, but that's an implementation detail)
21:18:31 <scutigera> this is Random package, right ?
21:18:35 <Cale> yeah
21:18:41 <Cale> System.Random
21:18:49 <scutigera> yes - I usually read device urandom to get a starting seed
21:20:05 <Cale> So anyway, once you have an initial StdGen, you can pass it along to your pure functions that require a generator, and you're fine. However, the passing around of generators might begin to get a bit cumbersome.
21:20:18 <scutigera> Cale: exactly...
21:20:23 <Cale> http://hackage.haskell.org/package/MonadRandom
21:20:44 <scutigera> always with the monads :-){
21:20:47 <Cale> So there is a nice pure monad (and monad transformer) for generating random numbers.
21:21:16 <Cale> You will notice that  evalRand :: RandomGen g => Rand g a -> g -> a
21:21:28 <lament> time of day is pretty bad.
21:22:27 <Cale> So you can build up a complicated computation of type Rand g a which involves random selections, and the monad takes care of threading the generator state along (internally it's all just functions g -> (g,a) anyway)
21:22:45 <scutigera> so the update of g stays hidden. this is the kind of thing which would normally be done with lexically scoped local var and destructive update
21:22:46 <Cale> and then you use evalRand or runRand to get a result, given an initial generator
21:22:58 <Beelsebob> @hoogle Set (Set a) -> Set a
21:22:58 <lambdabot> Data.Set deleteMax :: Set a -> Set a
21:22:58 <lambdabot> Data.Set deleteMin :: Set a -> Set a
21:22:58 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
21:22:59 <Cale> scutigera: Or with parameter passing, of course.
21:23:03 <Beelsebob> hmm
21:23:04 <habitue> is there a more canonical way of doing:  zip [1..] some_list
21:23:23 <Beelsebob> hmm, there's no joinS to make up for Sets not being able to be monads?
21:23:30 <medfly> can I use (x:xs) <- [1,2,3] or just x <- [1,2,3] ? (I hope the question is clear)
21:23:54 <Cale> scutigera: It is actually just a wrapper around a very common functional idiom of passing along an extra parameter to indicate the value of something which varies over the course of an algorithm
21:23:58 <dmwit> habitue: No, but it's also not necessary as often as it is in Python.
21:24:13 <dmwit> habitue: (because we have zipWith)
21:24:15 <scutigera> Cale: right, passing "the world" as it were
21:24:18 <Cale> medfly: (x:xs) <- [1,2,3] is the wrong type, but normally you could do that if it was a list of lists.
21:24:34 <dmwit> Beelsebob: unions?
21:24:36 <dmwit> :t S.unions
21:24:37 <lambdabot> forall a. (Ord a) => [S.Set a] -> S.Set a
21:24:45 <Cale> > [(x,xs) | (x:xs) <- [[1,2,3],[4,5],[],[6,7]] ]
21:24:46 <Beelsebob> dmwit: not quite, unions . toList
21:24:46 <lambdabot>   [(1,[2,3]),(4,[5]),(6,[7])]
21:24:47 <dmwit> :t S.unions . S.toList
21:24:47 <Beelsebob> but... yeh
21:24:48 <lambdabot> forall a. (Ord a) => S.Set (S.Set a) -> S.Set a
21:24:54 <dmwit> Beelsebob: yeah =)
21:25:10 <scutigera> Cale: used Data.Binary before ?
21:25:13 <habitue> dmwit: thanks!
21:25:19 <Cale> scutigera: yes
21:25:41 <Cale> scutigera: It is more useful if you have total control over the binary format you're using than if you don't.
21:25:43 <dmwit> This joanne stuff is pretty funny.
21:25:58 <dmwit> I wondered if they realized this was a channel with a particular focus.
21:26:12 <scutigera> Cale: looks like the lib is serializing for haskell.  I need to write the binary doubles so that, e.g. I can read it back with C.
21:26:26 <dmwit> scutigera: show?
21:26:27 <scutigera> Cale: should work ?
21:26:28 <Cale> Data.Binary doesn't have any instances for Doubles
21:26:36 <dmwit> > show 1.23456
21:26:37 <lambdabot>   "1.23456"
21:26:38 <Cale> er...
21:26:47 <Cale> hang on, let me check that
21:26:53 <Cale> It's been a while since I last used it
21:27:06 <scutigera> it seems to... Binary Double
21:27:35 <Cale> Ah, it does, but it will be inconvenient for FFI
21:27:50 <Cale> Use storablevector if you want it to be readable as C double values
21:28:15 <Cale> and you should use the CDouble type
21:28:41 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Foreign-C-Types.html
21:29:51 <scutigera> ok, that sounds more appropriate. looks like I can keep everything haskelly up to the point I actually have to do the IO.
21:30:33 <Beelsebob> @hoogle (a -> b) -> Set a -> Map a b
21:30:33 <lambdabot> Data.Map adjust :: Ord k => (a -> a) -> k -> Map k a -> Map k a
21:30:38 <scutigera> there sure are a lot of different kinds of arrays...
21:30:46 <scutigera> and vectors
21:30:51 <Beelsebob> bugger, why am I hitting all the things no one has written today
21:32:25 <scutigera> Cale: about the example which ended with reverse...
21:32:35 <Cale> scutigera: mhm?
21:33:10 <scutigera> so I could have a proc which read a string (IO) converted to an Int and then returned Int as opposed to IO Int ?
21:33:30 <Cale> scutigera: No. That's impossible by design.
21:33:39 <Cale> (You don't want that.)
21:34:08 <scutigera> so reverse works because it works on _any_ type, i.e. IO a
21:34:13 <Cale> no
21:34:18 <scutigera> aaargh
21:34:23 <Cale> reverse has no idea that there's any I/O going on there
21:34:34 <Cale> It receives a list of Chars and it returns a list of Chars
21:34:47 <Cale> It doesn't know where those Chars came from or where they are going.
21:34:55 <hackagebot> clock 0.1.2.1 - High-resolution clock and timer functions: (CetinSert)
21:35:17 <Cale> Inside a do-block, if I write v <- x, and x :: IO t
21:35:19 <Cale> then v :: t
21:35:34 <Cale> It means "run the computation x and call its result v"
21:35:50 <Cale> The do-block as a whole will then have type IO s for some other type s
21:36:00 <Cale> (same as whatever its last line is)
21:36:32 <heatsink> do {x <- getLine; {- Inside the do-block, x has type "String."  I can use pure functions here. -} return x}  -- This whole do {...} block has type "IO String".  I can't access 'x' outside the block.
21:36:39 <Cale> But inside the scope of the do-block, v is an honest to goodness value of type t, and can be passed to pure function which expect one.
21:37:17 <Cale> and then the results of those pure functions can be used to do whatever output you wanted
21:37:34 <Cale> Does that make any sense?
21:37:37 <scutigera> ok...I get it.  This IO/pure split is really giving me headaches when I actually try to write code.
21:37:56 <Cale> It takes a little bit of getting used to, but it's not so bad after a while :)
21:38:42 <scutigera> well right now I just end up with beaucoups of pure computation and about 5 lines of IO to write it to a file :-) Soon in technibinary !
21:38:53 <Cale> Are you familiar with model-view-controller?
21:39:02 <scutigera> Cale: somewhat
21:39:36 <Cale> Well, if you like, the IO monad will typically be used in the implementation of the view and controller, and the model stuff will all be pure.
21:39:59 <Cale> (That explanation typically only helps certain OO programmer types, but there it is)
21:40:04 <scutigera> that actually makes sense: [ a ]
21:40:46 <Cale> (and parts of the view and controller can be pure as well, but certainly the entire model should remain pure)
21:41:20 <scutigera> typical program (for me) : generate data, proc to operate on list , lather rinse repeat, view answer (write file of some sort, or gen graph)
21:41:29 <Cale> right
21:42:07 <scutigera> then, of course, I run into something like Random, and get kind of muddled for a bit :-)
21:42:07 <Cale> So...  do x <- generateData; let y = operate x; view y
21:42:19 <Cale> Here, operate will have no notion of IO in it
21:42:22 <scutigera> Cale: precisely
21:42:46 <Cale> Right, you just have to realise that random values are again a kind of input :)
21:43:03 <scutigera> I thinke it's more of a mindset.  I'm so use to threading IO through the program writing intermediate values.
21:44:24 <scutigera> Cale: o duh.  so I could generate the original random seq in the do block and then distribute as needed.  the key was that I forgot about what <- _really_ does.
21:46:14 <scutigera> Cale: Thanks very much !
21:46:19 <Cale> scutigera: yeah, and in fact, there are functions for taking a StdGen (or other generator), and producing infinite lists from it
21:46:22 <Cale> :t randoms
21:46:24 <lambdabot> forall g a. (Random a, RandomGen g) => g -> [a]
21:46:24 <Cale> :t randomRs
21:46:26 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> [a]
21:46:31 <BMeph> So, how's this sound for a "thought of the day": "Functional Programming is based on the idea that it's better to know *that* the computer can do something, than to know exactly *how* it gets done."
21:46:40 <Cale> If that way of doing things suits you, then go ahead :)
21:46:41 <scutigera> Cale: yes what I am currently doing.
21:47:22 <scutigera> Cale: due to lack of understanding.  although I completely get infinite lists and think they're rather neat.
21:47:26 <BMeph> Although, that's also applicable to logic programming, so I guess it needs more work. :)
21:47:42 <Cale> BMeph: Or perhaps it's more about saying what is, rather than what to do.
21:47:42 <eck> dons: are you around?
21:47:50 <heatsink> BMeph, that's an accurate description of declarative programming.
21:48:18 <scutigera> what's the forall stuff ?
21:49:38 <BMeph> FP: For programmers who only bit-twiddle when they Want to bit-twiddle. Or even, "Bit-twiddle, without the bit-twaddle." ;)
21:52:16 <zeno_> whats bikesheading
21:54:29 <roconnor> zeno_: it's when someone presents a good idea, like building a bikeshed, and everyone argues about what colour it should be.
21:54:33 <roconnor> or something like that.
21:54:44 <roconnor> maybe the idea doesn't have to be good.
21:55:01 <roconnor> but the debate is over a minor/irrelevant detail
21:55:13 <travisbrady> zeno_: the idea is that people will argue forever and ever over silly things like the color of a bikeshed, but they'll generally not debate truly complex things
21:55:27 <travisbrady> http://en.wikipedia.org/wiki/Color_of_the_bikeshed
21:55:43 <roconnor> wow, there is a wiki page
21:56:13 <travisbrady> yeah, it's pretty well known from what i can tell
21:56:58 <heatsink> travisbrady, Here's a nice talk about how much people avoid complex decisions. http://ted.org/talks/dan_ariely_asks_are_we_in_control_of_our_own_decisions.html
21:57:20 <jmcarthur> man, there's a lot of IO in the standard libs...
21:57:30 * BMeph wonders if the attention given to project details has an n log n relationship with its importance...
21:57:46 <jmcarthur> no wonder nobody has bothered wrapping all the IO functions to have types MonadIO m => m a before
21:58:33 <jmcarthur> think i'm gonna give up, myself
21:58:42 <jmcarthur> tedious and boring
21:58:50 <heatsink> write a script?
21:58:55 <jmcarthur> thought about it
21:59:11 <jmcarthur> might get around to that eventually
21:59:20 <BMeph> jmcarthur: Do it in stages, have we taught you nothing here? ;p
21:59:41 <jmcarthur> heh
22:36:45 <dmwit> Man, this sucks.  When I go to bed late, I can't get up in eight hours, and when I finally go to bed on time, I wake up 4 hours later.
22:40:26 <medfly> maybe you should seek some sort of help for that insomnia.
22:43:04 <dmwit> I don't think it's actually a disorder, just that I've been bad about controlling my sleep schedule lately.
22:43:32 <dmwit> ...and I want to complain about it, even though it's my fault. ;-)
22:43:49 * Saizan_ doesn't even know if he has such a schedule anymore
22:44:10 * dmwit notes that a schedule doesn't necessarily mean "the same time every day"
22:45:19 <Saizan_> true, but it imples some planning, at least :) if not regularity
22:57:24 <lispy> jmcarthur: what are you working on?
22:59:16 <lispy> It certainly seems that it would be nice if we could have a do-over on the H98 standard
22:59:31 <lispy> We know so much more about effective type class use than we knew back then
23:06:15 <zeno_> travisbrady: thx
23:51:44 <RyanT5000> is there any incremental computation stuff done in haskell?
23:53:24 <Saizan> RyanT5000: http://hackage.haskell.org/package/Adaptive
23:53:30 <RyanT5000> huh
23:55:49 <quicksilver> doesn't CReal count as a simple kind of incremental computation?
23:58:06 <ski> how ?
