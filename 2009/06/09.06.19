00:00:12 <dfrey> Cale: I think I need to read about typeclasses and then come back and try this again.
00:00:30 <Cale> I was just going to suggest each regex library providing its own monomorphic version and not worrying so much about it :)
00:00:32 <TheColonial> ivanm: okeydokes mate, thanks for that.
00:00:45 <Cale> dfrey: Or don't use regexes, if you can avoid it.
00:01:23 <Twey> Cale: A type is defined by some core operations on it, and any type implementing those operations can be declared a subtype of that type and used wherever the original type can be used
00:01:36 <Cale> dfrey: Usually what you really want is easily expressed with a parsec parser, or else is so simple that it can be done with the list library. Regexes are a sort of awkward middle ground with bad syntax :)
00:02:04 <Twey> I.E. unification of types and typeclasses
00:02:35 <Cale> hmm
00:02:41 <Cale> How does pattern matching work?
00:02:54 <dfrey> Cale: I'm just working through an exercise.  Not trying to develop something specific.
00:02:58 <Twey> With getters
00:03:47 <Twey> Record syntax would do the trick, although it might be useful to have some sort of convention to allow positional matching
00:03:47 <Cale> Twey: Is that really different from just defining a datatype which is itself a record of the operations?
00:03:53 <Cale> Hmm...
00:04:11 <Cale> Well, more generally maybe you'll want an existential.
00:04:16 <Twey> Except that records don't allow extension
00:04:25 <Twey> Hmm
00:04:31 <Twey> How would that work?
00:06:02 <Cale> Well, okay, extending the set of operations becomes a pain, but that's generally true.
00:06:48 <Cale> (OO design generally favours extending the set of possible cases for data over extending the set of operations on them)
00:08:12 <Cale> You can sort of mimic this in Haskell... Suppose we're writing a game, and we want to describe objects which are animated in some way, and maybe have other operations (like intersection tests, etc.)
00:09:18 <Twey> The most common way of expressing seems to be to declare a paired class for every type
00:09:32 <Cale> Let's go with a simple interface of having a time step, and a way to query the location, just so I don't have to type lots.
00:09:59 <Cale> data GameObject = GObj { timeStep :: GameObject, location :: Point }
00:10:45 <Cale> accelerated x v a = GObj { location = x, timeStep = accelerated (x + v) (v + a) a }
00:12:28 <Cale> Now, that's not very general, but basically, operations which affect the state of the object will return a new GameObject, usually produced by calling the particular specialised constructor (like accelerated in our case) with new state parameters.
00:14:06 <Cale> Of course, in general, the operations will be functions.
00:14:27 <Twey> Right
00:15:17 <Cale> and so you can create lots of variations on game objects now, but adding new operations which aren't simple applications of the existing ones is lots of work
00:15:41 <Cale> (since you have to go back and extend every GameObject constructor you have)
00:16:07 <ivanm> is there a function that does init and last in the one pass?
00:16:07 <Twey> Right
00:18:00 <Cale> ivanm: I don't think it's in the library, but it's one of those things which possibly should be.
00:18:46 <Cale> (though as you're already probably aware, finding a way to avoid splitting lists like that at all is probably a better option if possible)
00:19:20 <ivanm> Cale: *nod*
00:19:28 <Twey> Data.Seq may be more appropriate
00:20:00 <ivanm> the last char of a String I'm testing for follows different rules than the bit up to it though :s
00:20:18 <Cale> Twey: But that technique I think is underappreciated. :)
00:20:57 <Cale> (the one I mentioned)
00:21:34 <Twey> Cale: But it doesn't solve the same problem, viz. if you want to add something that for all purposes behaves exactly like a GameObject but has a different underlying representation, without reimplementing every function over GameObject
00:22:02 <Cale> Twey: The idea is that GameObjects don't really have a fixed underlying representation -- apart from being bundles of the operations on them
00:22:22 <ivanm> and there's no function that does as much joins as possible, is there? i.e. turns m ( m ( m ( ... m a  ... ))) into just m a
00:22:56 <Cale> In the case of my accelerated GameObject, the underlying representation is the values of the function parameters x, v, and a
00:23:09 <ceal>  num xs = [ if x < 10 then "small" else "big"]
00:23:14 <ceal> what is wrong with this?
00:23:26 <hydo> I'm pretty sure that I'm on the right track with project euler problem 2 with - sum $ map fib [2,4..4000000]  - except that sum is overflowing the stack.  Is there a more meaty sum?  Or perhaps maybe it's so late that I'm completely off on this.
00:23:32 <ceal> it says parse error on input `='
00:24:04 <Cale> ceal: where are you typing it?
00:24:10 <ceal> ghci
00:24:16 <Cale> ceal: It's a declaration, so it should go into a file
00:24:17 <ceal> prompt
00:24:32 <Cale> ceal: But with ghci, you could also write 'let' before it
00:24:37 <ceal> isn't it a function declaration?
00:24:40 <Cale> yes
00:24:46 <Cale> ghci wants an expression
00:24:55 <bellpeace> hi
00:24:58 <ceal> oh so i just have to add a let before the whole thing?
00:25:02 <bellpeace> can anyone
00:25:11 <bellpeace> write me a program
00:25:19 <Cale> ceal: Yeah, but I recommend stashing everything in a file, and keeping an editor window open alongside ghci
00:25:28 <Cale> ceal: :r will reload the currently loaded file
00:25:30 <bellpeace> that checks list of numbers
00:25:53 * UmpaPaLumpa scratshes bellpeace's back
00:26:01 <ceal> cale: thanks that's a good idea
00:26:08 <bellpeace> it checks are they fibbonnacy numbers
00:26:25 <Cale> hydo: you've misinterpreted the problem
00:26:45 <hydo> Cale: fair enough... looking again...
00:27:10 <hydo> oooh
00:27:14 <Twey> bellpeace: fibs = 0 : 1 : zipWith (+) fibs (tail fibs); checkList = all (`elem` fibs)
00:27:15 <hydo> Indeed, I do.
00:27:17 <bellpeace> yes...
00:27:55 <Cale> > sum . takeWhile (< 4000000) . filter even $ fix ((0:) . scanl (+) 1)
00:27:57 <lambdabot>   4613732
00:28:10 <Twey> Of course that's never going to return False :-P
00:28:31 <Twey> Don't we have a cleverer elem for Ord?
00:28:41 <Cale> Yeah, you want a version of elem which assumes a sorted list.
00:28:58 <Cale> There are implementations of elemOrd hanging around in various places if you google.
00:29:06 <bellpeace> this is the solution when i use modules
00:29:26 <Twey> fibs = 0 : 1 : zipWith (+) fibs (tail fibs); checkList = all (\x -> x `elem` takeWhile (<= x) fibs)
00:29:50 <bellpeace> this is great
00:29:52 <Cale> I suppose that works
00:29:59 <bellpeace> but i have a problem
00:30:03 <Twey> It's not pretty, but it'll do :-P
00:30:22 <bellpeace> i want it to work without zipWith
00:30:25 <bellpeace> :)
00:30:29 <Twey> bellpeace: Why?
00:30:31 <bellpeace> i'm new
00:30:34 <bellpeace> with haskell
00:30:47 <Cale> bellpeace: Oh, well, any implementation of fibs will do...
00:30:52 <bellpeace> so it's better to start from scratch
00:31:11 <Cale> If you have a function  fib n  which computes the nth Fibonacci number, then  fibs = map fib [0..]
00:31:36 <Gracenotes> indeedy so
00:31:43 <Cale> It's just that the definition which Twey used is a clever memoising version.
00:32:01 <Twey> zipWith (+) fibs (tail fibs) â‰¡ [a + b | (a, b) <- zip fibs (tail fibs)]
00:32:06 <ceal> num x = [if x < 10 then "small" else "big"]
00:32:12 <ceal> i have written this in a file
00:32:21 <Gracenotes> hmm
00:32:30 <ceal> can i pass only one number to it when i call the function?
00:32:36 <Cale> yes
00:32:37 <Twey> ceal: Yes
00:32:45 <Twey> And you can only get a one-element list back.
00:32:51 <Twey> Making it a fairly silly function :-P
00:33:05 <ceal> what should the main function look like?
00:33:09 <Gracenotes> you are returning a list containing a string. [x] is a list with one element, x
00:33:18 <Gracenotes> just so's you know
00:33:19 <Cale> ceal: hm?
00:33:25 <Twey> ceal: Depends â€” what do you want it to do?
00:33:28 <bellpeace> how to make it work without zipWith
00:33:33 <bellpeace> :(
00:34:04 <ceal> ceal, twey: actually what i want to do is this: make a list which will display odd or even for a list of numbers
00:34:14 <ceal> sorry small or big
00:34:25 <ceal> depending on if it's < 10 or not
00:34:32 <Cale> bellpeace: Well, the standard recursive fib will work, if slowly.
00:34:45 <Cale> bellpeace: Or you can use the one with an accumulating parameter
00:35:09 <Cale> bellpeace: Is it homework?
00:35:19 <bellpeace> no
00:35:21 <Twey> bellpeace: notZipWithHonest f xs ys = map (\(a, b) -> f a b) $ zip xs ys; fibs = 0 : 1 : notZipWithHonest (+) fibs (tail fibs); checkList = all (\x -> x `elem` takeWhile (<= x) fibs)
00:35:36 <Cale> haha
00:35:41 <bellpeace> it's for my own research
00:35:43 <Gracenotes> srsly not
00:35:55 <bellpeace> on functional programming languages
00:35:58 <Cale> bellpeace: What do you dislike about using zipWith?
00:36:16 <bellpeace> cause it0s a built in function
00:36:27 <Gracenotes> ..
00:36:29 <Cale> It's not built in... it's a library function which you can write.
00:36:34 <Twey> Why do you object to zipWith but not the other functions I've used there, like all, elem, takeWhile, tail, and (+)?
00:36:35 <bellpeace> i want to start from scratch
00:36:39 <Gracenotes> @src zipWith
00:36:40 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
00:36:40 <lambdabot> zipWith _ _      _      = []
00:36:52 <Gracenotes> most Haskell functions can be written from scratch, and you wouldn't know the difference
00:36:58 <Axman6> indeed
00:37:01 <Twey> Of all those, only (+) is built-in
00:37:11 <Gracenotes> (except maybe the library ones are written to be more performant)
00:37:13 <Axman6> well, most built in ones (and ones which don't do IO)
00:37:13 <Twey> The others can all be written in Haskell, generally in one or two lines
00:37:14 <Cale> (and even it need not be)
00:37:17 <Lovro> Can it be written without using any built in?
00:37:20 <Twey> (naÃ¯vely)
00:37:26 <Twey> Lovro: No
00:37:31 <Lovro> :( *doh
00:37:35 <Twey> Although a version that works on Peano numbers can.
00:37:37 <Gracenotes> but, IO and the like are exceptions, of course..
00:37:41 <Cale> We could conceivably have defined Integer as an algebraic datatype
00:37:44 <Twey> It's kind of hard to implement (+), you see.
00:37:51 <Cale> It's not *that* bad :)
00:38:18 <Cale> It's just hard to write one which is really fast and which doesn't use low-level unsafe primitives :)
00:38:23 <Gracenotes> but, right, much of the arithmetic uses native ints and doubles and whatnot..
00:38:39 <Twey> Cale: But that would be using external functions again :-P
00:38:49 <Gracenotes> here are most of the primitive functions: http://www.haskell.org/ghc/docs/6.6/html/libraries/base/GHC-Prim.html
00:39:08 <Gracenotes> the ones that are closely linked to how the code compiles down
00:40:32 <Cale> http://hackage.haskell.org/packages/archive/nat/0.2/doc/html/Data-Number-Int.html
00:40:45 <Cale> (I'm not sure how good that implementation is)
00:41:08 <Cale> But it is certainly possible to do integers as an algebraic datatype. :)
00:42:18 <ceal> guys my doubt aint clear yet...
00:42:35 <ceal> here's the thing: verbatim from lyah tutorial
00:42:36 <Twey> Cale: But it's not possible to implement the conversion to built-in integers, is it?
00:42:48 <ceal> boomBangs xs = [ if x < 10 then " BOOM ! " else " BANG ! " | x <- xs , odd x ]
00:42:55 <ceal> what does this do?
00:43:01 <ceal> and how do i make it work?
00:43:41 <Cale> Twey: Well, not without using the built-in-integer (+)
00:43:44 <Gracenotes> you could define it simply in ghci. with: let boomBangs xs = [ if x < 10 then " BOOM ! " else " BANG ! " | x <- xs , odd x ]
00:44:16 <Gracenotes> and then the function is available for use. like, "boomBangs [1..20]" inputted next
00:44:23 <Twey> Cale: Aye
00:44:35 <Saizan> @let boomBangs xs = [ if x < 10 then " BOOM ! " else " BANG ! " | x <- xs , odd  x ]
00:44:37 <lambdabot>  Defined.
00:44:37 <ceal> gracenotes: thanks let me try
00:44:52 <Saizan> > boomBangs [1..20]
00:44:53 <lambdabot>   [" BOOM ! "," BOOM ! "," BOOM ! "," BOOM ! "," BOOM ! "," BANG ! "," BANG !...
00:45:06 <ceal> now what if i put this in a file?
00:45:10 <Cale> > boomBangs [2,4,6,8]
00:45:10 <ceal> how do i make that work?
00:45:12 <lambdabot>   []
00:45:17 <Cale> > boomBangs [2,4,6,8,5]
00:45:19 <lambdabot>   [" BOOM ! "]
00:45:21 <Cale> > boomBangs [2,4,6,8,5,21]
00:45:23 <lambdabot>   [" BOOM ! "," BANG ! "]
00:45:27 <Gracenotes> as a general rule, function definitions in files are "name args = body". very declarative. in ghci, you need to do "let name args = body". Or even "let name args = body in name myargs", which uses a temporary reference to the function
00:45:49 <Cale> ceal: Just stick the definition in a file and  ghci filename.hs
00:46:02 <ceal> ok
00:46:37 <ceal> how do i pass arguments in that case?
00:47:01 <Cale> Well, at the ghci prompt, you call it with some list, just like we've been doing with lambdabot
00:47:55 <ceal> so i dont need to use a main function?
00:48:07 <Cale> Not unless you want to compile an executable program
00:48:41 <Cale> (and it'll be a main action anyway, it's not a function since there are no parameters)
00:48:52 <Cale> If you want to try that
00:49:00 <Cale> main = print (boomBangs [2,4,6,8,5,21])
00:49:09 <Cale> and then
00:49:10 <ceal> can i pass arg's to it?
00:49:12 <Gracenotes> you can load files in ghci with ":l filename.hs". stuff beginning with ":" is talking directly to ghci
00:49:16 <Gracenotes> anyweh
00:49:21 <Cale> ghc --make boombangs.hs
00:49:38 <ceal> let me try it
00:49:47 <FalconNL> Does anyone have any other suggestions for a data structure for a general-purpose grid (basically a 2D map)? So far I've compared Map r (Map c a) and Map (c, r) a, with the former having equal or better big O complexity for nearly all functions. There's also quad trees, but they seem to offer little benefit and would be difficult to keep balanced.
00:50:32 <ivanm> FalconNL: an array?
00:50:44 <Cale> The advantage with the former there is if you're doing lots of operations on entire rows
00:51:00 <ivanm> or if you can have a mapping function from Coord -> CellIndex, use an IntMap rather than a Map
00:51:14 <FalconNL> ivanm: Arrays have O(n) lookup
00:51:23 <ivanm> FalconNL: wtf?
00:51:29 <ivanm> they have O(1) lookup!
00:51:31 <Cale> FalconNL: no, they have O(1) lookup. They have O(n) update.
00:51:43 <ivanm> Cale: well, depends on which array you use
00:51:45 <Twey> Lists have O(n) lookup.
00:52:24 <ivanm> but if you have a sparse grid, use an IntMap
00:52:28 <FalconNL> Cale: Yeah, they have O(1) lookup if you know the index. However, the key can be anything so it will be an array of tuples, which gives O(n) lookup
00:52:45 <ivanm> FalconNL: a 2D array?
00:52:52 <ivanm> or are you doing content -> index?
00:52:59 <ivanm> in that case, use a BiMap?
00:53:09 <Cale> FalconNL: what?
00:53:27 <ivanm> Cale: I think he's talking about Array Int (Array Int a)
00:53:43 <Cale> Rather than Array (Int, Int) a ?
00:53:43 <ivanm> or else he wants to know which cell has a particular value
00:53:47 <ivanm> Cale: yeah
00:54:00 <Cale> But even Array Int (Array Int a) has O(1) lookup
00:54:21 <Cale> and  Array (Int, Int) a  does too...
00:56:04 * Maddas resists the urge to make a pirate joke about Arr-ays
00:56:04 <FalconNL> Ok, I might have been wrong on the lookup. But still, O(n) update is worse than O(log n) for Maps
00:56:23 <Maddas> FalconNL: Will you be updating frequently compared to the number of lookups?
00:56:39 <Cale> FalconNL: right.
00:57:09 <Cale> FalconNL: well... if you're doing lots of updates, and the thing is big enough or can't be an unboxed array
00:57:10 <FalconNL> Maddas: I plan on making it general purpose for a Data.Grid library, so I'm trying to balance the different operations
00:58:03 <FalconNL> Since it's 2D, an update using nested arrays would become O(n^2), which is fairly terrible
00:58:24 <Cale> right
00:58:26 <FalconNL> no wait, O(n), but still
00:58:30 <Twey> We actually have some matrix libraries already...
00:58:36 <Cale> Well, depends what n is ;)
00:59:20 <ceal> the main function thing aint working
01:00:18 <Cale> ceal: your file should contain:
01:00:21 <Cale> main = print (boomBangs [2,4,6,8,5,21])
01:00:21 <Cale> boomBangs xs = [ if x < 10 then " BOOM ! " else " BANG ! " | x <- xs , odd  x ]
01:00:37 <Cale> and then you just  ghc --make file.hs
01:00:40 <FalconNL> Twey: I can find 1 matrix library, and it lacks a lot of the operations that Data.Map supports
01:01:01 <ceal> ok let me see
01:10:19 <samuels> hey guys what is a "lexical" ?
01:10:24 <samuels> i hear ppl using it as a noun
01:10:59 <Gracenotes> related to, uh, words
01:11:13 <Gracenotes> the order and combination of them
01:11:26 <fasta> Is there a way to use hsc2hs with ghci interactively? That is, changing some stuff in a module containing hsc2hs "instructions" and then reloading the module, will have the changes applied.
01:12:03 <samuels> Gracenotes, no piggy, they use it as a sense of a variable that's been captured by a closure or some such
01:12:44 <Gracenotes> the above is what lexical means. lexical closures are a specific use..
01:14:01 <Gracenotes> I suppose it's to distinguish them from dynamic closures. which are rarely needed.
01:16:34 <Gracenotes> "lexical" means just about words. That's what it means without giving us any context
01:16:44 <samuels> ah ok
01:17:00 <Gracenotes> if it's short for lexical closure, then that's possible, but an abuse of language :)
01:17:00 <samuels> what does "lexical" mean in the context of functional programming and closures etc
01:17:20 <Gracenotes> I mean, using it as a noun
01:17:32 <samuels> out of interest, why do they call it a "lexical" closure?
01:17:43 <Saizan> fasta: there's an option to put in the OPTIONS_GHC pragma to run a preprocessor over the file, but i guess giving the right options to hsc2hs that way is cumbersome
01:17:45 <samuels> waht does the word "lexical" mean/add
01:17:55 <Gracenotes> lexical closure is doing name lookup based on a function's position in the text. its lexical place.
01:18:06 <Gracenotes> lexical scope, which lexical closures create.
01:18:20 <Saizan> fasta: you could test the patch for "runghc Setup interactive" maybe :)
01:18:41 <Gracenotes> name lookup, usually a variable or a constant that's presumed to be in scope somewhere..
01:19:36 <Gracenotes> what's supposed to be accessible and what's not.
01:20:15 <Gracenotes> If you have an inner scope and an outer scope, all the variables in the outer scope can be accessed in the inner scope (unless, in some languages, it's hidden by one with the same name). But the opposite isn't true
01:21:01 <Gracenotes> inner scope and outer scope, with lexical scope, is determined by where the function or closure is defined. Dynamic scope relies on scope hierarchies that are more complicated, like up the call stack
01:22:21 <samuels> ah cool
01:22:22 <samuels> thakns
01:37:06 <Smorg> is there a type-combining function a la python?
01:37:09 <Smorg> > 'f':'o':'o':"bar":[]
01:37:11 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
01:37:37 <BONUS> what do you mean type combining
01:38:22 <Smorg> say you had ('a', "bcd") and wanted "abcd"
01:39:14 <BONUS> > uncurry (:) ('a', "bcd")
01:39:17 <lambdabot>   "abcd"
01:39:39 <BONUS> uncurry takes a function that takes two parameters and turns it into a function that takes a tuple
01:40:59 <Smorg> "paramater" isn't synonomous with "argument" ?
01:41:05 <BONUS> yeah it is
01:42:13 <Gracenotes> what's different from python is that going from any type to another type is not automatic
01:42:32 <Gracenotes> (Char, String) to a String would require a specific function. uncurry (:) works here, though...
01:42:52 <Gracenotes> @type uncurry (:)
01:42:53 <lambdabot> forall a. (a, [a]) -> [a]
01:44:58 <Condor920> CiAo  a TuTtI  da  Ç Ö ]\[ Ð Ö ® 920
01:45:11 <Gracenotes> :O
01:45:41 <Axman6> what the...
01:45:51 <Axman6> Condor920: you right there?
01:46:01 <ivanm> Axman6: s/right/spamming/
01:46:01 <ivanm> ;-)
01:46:19 <Condor920> ok
01:46:42 <Axman6> oh, just realised that was supposed to say something
01:50:50 <ivanm> Axman6: it was? :o
01:51:18 <Axman6> ]\[ is an n...
01:51:20 <lunabot>  luna: parse error on input `)'
01:52:01 <ivanm> oh, it was meant to be something like "hi, I'm condor920"?
01:52:54 <Axman6> i think so
01:53:08 <Axman6> but wow it was annoying
01:56:41 <bastl> hi (how) can i install gtk2hs using cabal ? i dont find the package name.
01:58:27 <Axman6> you can't
01:58:27 <Smorg> :t curry
01:58:28 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
01:59:02 <samuels> hey guys
01:59:12 <samuels> which lang do you guys prefer if forced to choose....clojure or scala?
01:59:17 <bastl> Axman6: too bad. why?
02:00:07 <Axman6> because it relies on much more than cabal can install, and it's more complex to install than what cabal is capable of (could be wrong, but i know cabal can't do it atm)
02:00:46 <ziman> samuels, scala looks quite interesting to me
02:01:22 <samuels> ziman: but very complicated...just compare the books "programming scala" and "programming clojure", the clojure one is about 200 pages, the scala one is about 700
02:01:23 <bastl> ok. thanks
02:02:29 <Smorg> scala has oo. I think clojure is a bit more haskellish and scala is more ocaml
02:03:18 <samuels> tbh i like some of things in scala too, but the size of the language and its complexities intimidate me
02:03:34 <samuels> on the other hand clojure is so simple and clean and elegant that you can learn it very easily
02:04:27 <ejt> what would you prefer scala/clojure for rather than haskell (not meant as a flame)
02:04:30 <ejt> ?
02:04:40 <Smorg> its also much newer
02:04:51 <ivanm> bastl: the reason you can't use cabal-install for gtk2hs, is that it requires c2hs, which as yet doesn't play nicely with Cabal (the packaging format, not cabal-install)
02:05:04 <ceal> can anyone tell me what is wrong?
02:05:06 <ceal> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2827#a2827
02:05:21 <samuels> ejt: jvm stuff
02:05:52 <WorkyBob> ceal: you don't need a let for a top level definition
02:06:21 <ceal> oh
02:06:24 <WorkyBob> amongst some other things, but I'll give you the pleasure of fixing them as you come across them
02:06:30 <WorkyBob> (or at least trying first)
02:06:30 <ceal> i typed this in a file...
02:06:36 <WorkyBob> yep
02:06:44 <WorkyBob> a top level definition in a file does not need let in front of it
02:06:50 <WorkyBob> just like main
02:06:52 <doserj> ceal: there is still a bug there
02:06:53 <ceal> ok
02:06:53 <WorkyBob> that's a top level definition
02:07:03 <WorkyBob> doserj: sure, but he'll get the pleasure of hunting for it
02:07:08 <doserj> :)
02:07:20 <ceal> ok :)
02:07:58 <fasta> ejt: I think Clojure has a SLIME backend. If it is fully featured, then that's a reason. I don't know the details of the language.
02:08:43 <ceal> workybob,doserj: is it that it wont work for a list?
02:09:03 <WorkyBob> ceal: yep, you need an extra function in there to get it to apply to each element in the list
02:09:08 <WorkyBob> also, where does x come from?
02:09:18 <Smorg> If i were to prefer anything to haskell it would be something that extends haskell like curry (but I heard even haskell has its own constraint system)
02:09:23 <ceal> x is the argument isn't it?
02:09:33 <ejt> fasta: I've not heard of SLIME
02:09:42 <ceal> so how do i implement the extra function?
02:10:16 <WorkyBob> ceal: the argument looks like xs to me
02:10:20 <WorkyBob> ceal: you don't need to implement it, it exists already
02:10:28 <WorkyBob> you want something that takes a function that works on items
02:10:31 <WorkyBob> and takes a list of items
02:10:35 <WorkyBob> and applies the function to each item
02:10:48 <ceal> yeah that's what i want
02:10:55 <WorkyBob> so... function that works on items... (a -> b)
02:10:55 <ceal> xs?
02:10:59 <ceal> yeah
02:11:00 <WorkyBob> list of items... [a]
02:11:09 <WorkyBob> the result of applying the function to each item [b]
02:11:15 <ceal> what's the code to do that?
02:11:18 <WorkyBob> so you want a function with type (a -> b) -> [a] -> [b]
02:11:27 <WorkyBob> @hoogle (a -> b) -> [a] -> [b]
02:11:27 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
02:11:27 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
02:11:27 <lambdabot> Control.Parallel.Strategies parMap :: Strategy b -> (a -> b) -> [a] -> [b]
02:11:36 <WorkyBob> Prelude.map looks hopeful :)
02:12:02 <samuels> ejt: it's a beautiful emacs environment for working with lisp
02:20:24 <ceal> which is the best way to learn haskell: use the prompt or ghci <file.hs>?
02:20:42 <ejt> ceal: a mix
02:20:49 <ceal> ?
02:20:56 <skorpan> it doesn't matter
02:20:58 <Axman6> ceal: by reading a tutorial...
02:20:58 <ejt> write functions in a file, then load them up and play with them interactively
02:21:16 <ceal> ok
02:21:17 <ivanm> you can't do that much solely from the prompt
02:21:45 <ejt> you'll find guards and case statements tedious to write from the prompt
02:22:04 <ceal> i have not got that far yet...
02:26:42 <Axman6> ceal: talk in here, you'll get better answers
02:28:08 <ceal> boomBangs [7..13]
02:28:08 <ceal> [" BOOM ! "," BOOM ! "," BANG ! "," BANG ! "]
02:28:15 <ceal> how come just 4 outputs?
02:28:48 <quicksilver> because that's what the definiton of boomBangs does, I presume :)
02:28:50 <Axman6> > [x | x <- [1..10], odd x]
02:28:51 <lambdabot>   [1,3,5,7,9]
02:29:03 <Axman6> see what happens there?
02:29:07 <Axman6> > [x | x <- [1..10], even x]
02:29:08 <lambdabot>   [2,4,6,8,10]
02:29:17 <Axman6> > [x | x <- [1..10], even x, x < 7]
02:29:18 <lambdabot>   [2,4,6]
02:30:05 <ceal>  let boomBangs xs = [ if x < 10 then " BOOM ! " else " BANG ! " | x <- xs , odd x ] is the definition
02:30:17 <ceal> how come just four outputs for [7..13]?
02:30:22 <ceal> shouldn'
02:30:31 <ceal> shouldn't there be five?*
02:30:40 <ceal> 7,8,9,10,11,12?
02:30:46 <Axman6> > [ x | x <- [7..13], odd x]
02:30:47 <lambdabot>   [7,9,11,13]
02:30:55 <ceal> oh
02:30:57 <ceal> ok
02:30:59 <Axman6> see? only 4 numbers are odd
02:31:06 <ceal> didn't notice that filter at the end....
02:31:12 <ivanm> heh
02:32:46 <ivanm> what function calls/runs the given command?
02:32:51 <ivanm> as in String -> IO ()
02:33:56 <Axman6> eh?
02:34:03 <hatds> do you mean what runs the IO ?
02:35:28 <Smorg> woh what kind of comprehension is that?
02:35:36 <Smorg> you can put if/else into an output funcion? crazy.
02:36:29 <Axman6> Smorg: why not?
02:37:29 <ivanm> Axman6: I need a function foo that I can do something like: foo "halt", for example
02:37:44 <Axman6> oh, run system processes?
02:37:49 <ivanm> yeah
02:38:03 <Axman6> hmm, i did know what it was called
02:38:10 <Smorg> I just wouldn't think it would know that the two strings are the things it is supposed to return.
02:38:11 <ivanm> lol
02:38:22 * ivanm might check hoogle online rather than just lambdabot's cut-down hoogle
02:39:14 <hatds> check System.Process
02:39:23 <ivanm> thanks hatds
02:40:02 <ivanm> runCommand looks like what I want
02:40:18 <hatds> also System.Cmd for simpler interface
02:41:02 <Smorg> > showLitChar 'a' "bcd"
02:41:03 <lambdabot>   "abcd"
02:41:09 <ac> what all does happstack do? Why couldn't you store your state in an IORef?
02:41:13 <skorpan> everything in System.Cmd is in System.Process as well
02:41:42 <ejt> how do I get cabal install to install profile builds ?
02:41:58 <ceal> have you guys heard of the cipher contest?
02:42:04 <ejt> nm
02:42:21 <ivanm> so which would be better if I want my haskell app (which is running from a term) to run the given shell command, printing all output, etc.?
02:43:25 <ivanm> runCommand seems to do it...
02:43:52 <ceal> anyone here heard of the cipher contest?
02:44:02 <Axman6> anyone got any experience with D?
02:44:15 <skorpan> ivanm: "system" is what suited best for me
02:44:18 <ceal> nm
02:44:46 <ceal> is haskell used in executing scripts just like python scripts are used in web applications, web servers etc?
02:45:09 <ceal> i meant are haskell scripts used like python scripts in web apps, servers etc?
02:45:15 <skorpan> you usually compile haskell i would say, but nothing is stopping you from interpretting it
02:45:28 <ivanm> except for a lack of speed...
02:45:32 <ac> ceal: are you asking if people write Haskell websites where code is compiled on the fly during a request?
02:45:36 <ac> ceal: no
02:45:43 <ivanm> since I would guess that Python's interpreter is much better than GHCI or Hugs are
02:46:05 <skorpan> are there any benchmarks which talk about interpreted python vs. interpreted haskell in terms of execution speed?
02:46:17 <ceal> i think i should reword my qn
02:46:18 <ivanm> I don't think so
02:46:30 <ac> ceal: yeah, it was pretty vague ;)
02:47:06 <ceal> ac: i certainly didn't mean compiling code on the fly
02:47:22 <ac> ceal: people definitely use Haskell to write dynamic websites. I'm working on one right now in fact
02:47:39 <ac> ceal: there are even multiple web servers and a couple frameworks
02:52:16 <ac> where does cabal save the source code when it downloads and installs a package?
02:52:22 <ac> (cabal install that is)
02:52:28 <ivanm> ~/.cabal/
02:52:30 <ivanm> somewhere in there
02:52:38 <skorpan> ~/.cabal/packages/haskell.../ something
02:53:37 <skorpan> does "mingw32_HOST_OS" mean "running on windows"?
02:53:54 <ivanm> that's my guess
02:54:02 <ivanm> or else running a windows build in wine or something...
02:54:20 <skorpan> does anyone know why System.Process.syncProcess is not exported?
02:54:43 <skorpan> it has exactly what i need
02:54:48 <ac> skorpan: yeah, finally found it
02:55:18 <ivanm> runCommand seems to "background" the process it runs :s
02:55:49 <ivanm> so if I kill the haskell app that's run, anything it ran runCommand on is still there backgrounded :s
02:55:53 <bla> parMap rwhnf fun list should use two threads on hyperthreading, single-core computer? I don't see parallel execution
02:56:57 <ceal> i have heard python scripts are what power google search
02:57:00 <Axman6> bla: did you compile with -threaded?
02:57:09 <bla> Yep. And -package parallel
02:57:12 <skorpan> ivanm: i had that _exact_ problem yesterday... use System.Process.system.
02:57:15 <ceal> is there any such applications for haskell?
02:57:20 <ivanm> skorpan: trying it
02:57:26 <Axman6> ceal: i doubt that, python's too slow for google's main work, but they are very interested in python, and making it faster
02:57:47 <ivanm> what are they calling their work?
02:57:48 <Axman6> bla: --make is usually prefered to -package btw
02:58:02 <bla> Ok, I'll try it to learn it
02:58:11 <bla> http://temp.thera.be/parJuliaGL.hs  <- here is the code btw.
02:58:24 <cloutch> hello everybody, I try to optimize a little app which parses a lot of rss feeds, should I try to use ByteString or parallelism first ?
02:58:29 <bla> I can't try it now on something more parallel than this eee-netmachine.
02:58:43 <Axman6> ceal: bytestring
02:58:49 <Axman6> cloutch, not ceal
02:59:17 <Axman6> bla: oh and are you running it with ./blah +RTS -N 2?
02:59:30 <bla> Ha. This is it probably
02:59:35 <Axman6> ;)
02:59:39 <ceal> i am actually participating in the cipher contest; which involves hacking a vulnerable image which is running several services and applications
02:59:41 <ac> ceal: Google's core algorithms are all in C++, and maybe some Java
02:59:46 <ceal> oh
03:00:36 <ceal> so i was wondering if any of those can be based on haskell
03:00:56 <cloutch> Axman6: thanks for the advice
03:01:04 <ac> ceal: you're wondering if the image they have prepared for the contest has compiled haskell code in it?
03:01:28 <Axman6> cloutch: isn't parsing basically a linear task anyway?
03:01:54 <ac> ceal: that seems very unlikely to me
03:02:35 <ivanm> skorpan: yup, system works great... thanks! :D
03:02:58 <cloutch> Axman6: I mean parsing multiple feeds at the same time
03:03:08 <Axman6> ah
03:03:19 <Axman6> in that case, parallelism sould be fun :)
03:03:29 <quicksilver> is your process CPU bound?
03:03:37 <quicksilver> as oposed to network bound, say
03:03:44 <Axman6> that's a good question
03:03:51 <skorpan> ivanm: unfortunately with "system" we don't have very much control over the process itself. we really want to use syncProcess to run a synchronous process, but this shit isn't exported for some reason. i asked about it on haskell-cafe just now.
03:04:02 <ceal> ac: that was what i was wondering thanks
03:04:12 <Axman6> though, even if it is network bound, downloading the feeds concurrently would probably speed things up
03:04:15 <cloutch> what's the best tutorials out there about parallelism ?
03:04:20 <ivanm> skorpan: heh, all I want to do it basically replace the haskell app with the shell command
03:04:31 <skorpan> ivanm: fair enough! :P
03:04:33 <ivanm> since the haskell app is basically finding the params to run the shell command with
03:04:37 <Axman6> cloutch: imo, parallelism in haskell is so easy in haskell, it doesn't need a tutorial
03:04:50 <Axman6> well, i think what you want is concurrency really
03:04:53 <osfameron> Axman6: really?
03:04:57 <Axman6> yah
03:05:00 <skorpan> ivanm: my program does the same thing.. but i want to be able to pass -q to the program to make it output the subprocess' stdout to /dev/null
03:05:02 <Axman6> it's dead simple
03:05:07 <ivanm> ahhhh
03:05:10 <skorpan> for this i need more control than "system" will give me
03:05:12 <osfameron> I had a look at one of the Control.something haddock pages, and couldn't make head or tail of it.  I need a tutorial :-)
03:05:36 <skorpan> *maybe* (system "hello > /dev/null") could work, but even if it does, it's just a hack
03:05:45 <ivanm> Axman6: well, I think a small one on the different strategies, etc. would be useful/helpful to most people doing a parallel app for the first time
03:06:01 <ivanm> skorpan: true
03:06:21 <Axman6> "main = do var <- newEmptyMVar; forkIO $ ioFunc1 var; ioFunc2 var; takeMvar var", pretty easy to see that that is racing the two threads
03:07:14 <Axman6> osfameron: basically, if you can grok forkIO, MVars and Chans, you're there
03:07:16 <cloutch> ok I'll play with control.concurrent and mvars
03:08:04 <osfameron> Axman6: er... ok... if you're only targeting people who already understand those, then maybe it doesn't need any tutorials ;-P
03:08:08 <ivanm> Axman6: oh, I thought you were talking about the strategy stuff
03:08:18 * osfameron goes off to play with something simple like Visual Basic ;-)
03:08:32 <Axman6> osfameron: they're very easy to understand
03:08:49 <ivanm> osfameron: nooo!!! don't do it!!!
03:09:00 <ivanm> (if you _have_ to use basic, use oleg's library! :p )
03:09:03 <osfameron> ivanm: hehe, VB has monads now! (well, LINQ)
03:09:10 <Axman6> like, extremely easy. i've never done any concurrent programming before i played with the haskell primitives, and no one taught me anything about them, i just figured them out
03:09:33 <ivanm> osfameron: don't you read reddit? grauenwolf didn't believe dibblego when he tried to prove that!
03:09:43 <RayNbow> VB is awesome
03:09:56 <dibblego> ivanm, he deleted all his comments :(
03:10:02 <ivanm> dibblego: :(
03:10:11 <ivanm> dibblego: why does reddit let you do that?
03:10:16 <ivanm> that's a real PITA :s
03:10:18 <osfameron> ivanm: I skim it.  But yes, LINQ is a monad, and I do vaguely remember someone proving that you could implement other monads in terms of it?  is that what you mean?
03:10:35 <dibblego> ivanm, I'm not sure why he did it -- I don't understand a lot of his behaviour
03:10:48 <Axman6> who?
03:10:56 <ivanm> osfameron: dibblego was trying to prove to him that LINQ was a monad, and he kept getting caught on trivialities in terms of implementation
03:11:13 <ivanm> dibblego: so he didn't say anything, just suddenly deleted them?
03:11:27 <ivanm> Axman6: some guy on programming.reddit
03:11:38 <dibblego> ivanm, yes -- more like I was trying to help him understand what monad means (since he insists on using the term in most inappropriate ways)
03:11:49 <ivanm> yeah
03:12:07 <ivanm> as in Monad == Haskell's weird hack to let haskell users think it's pure whilst doing IO
03:12:08 <ivanm> ?
03:12:19 <dibblego> also, I tried to teach him about LINQ
03:12:34 <dibblego> no, even more inappropriate -- he clearly has no idea what it means and uses it arbitrarily
03:12:37 <Beelsebob> tbf, the IO monad *is* that
03:12:40 <Beelsebob> but not all monads are
03:13:09 <dibblego> he started off thinking that LINQ was somehow inherently related to IEnumerable
03:13:21 <ivanm> Beelsebob: well, it lets you think about IO in a pure-ish fashion
03:13:22 <dibblego> but then I showed other monads (parser for example) which could be used with LINQ
03:13:25 <RayNbow> dibblego: do you have a link to that discussion?
03:13:28 <dibblego> then he claimed I was "hacking the compiler"
03:13:36 <dibblego> RayNbow, only my responses -- he deleted his half
03:13:48 <RayNbow> that will suffice :p
03:14:00 <dibblego> http://www.reddit.com/r/programming/comments/8ssgq/admitting_that_functional_programming_can_be/c0acdz4
03:14:25 <RayNbow> thx :)
03:15:00 <dibblego> he has an extreme aversion to learning -- I can't quite pick how to handle it -- it fascinates me a little :)
03:16:16 <RayNbow> that might be because everyone getting shown this piece of code < http://paste.pocoo.org/show/123623/ > will run away in fear :p
03:16:19 <osfameron> dibblego: grauenwolf does post some good stuff though - a lot of what I actually click through to is via him, so he's good for something :-)
03:16:35 <osfameron> I also don't *understand* LINQ, which is a shame, as I'd like to implement it in Perl...
03:16:39 <dibblego> osfameron, I've never seen it -- but that makes it even more fascinating
03:16:43 <osfameron> sigh... pesky day job getting in the way of me reading papers
03:17:00 <ivanm> osfameron: like the MSDN guy who keeps putting down everything on /r/linux/ ? :p
03:17:14 <dibblego> RayNbow, I posted a simpler example as well
03:17:34 <dibblego> http://paste.pocoo.org/show/123756/
03:17:59 <RayNbow> dibblego: it's mainly the ugly type signatures of C-style languages
03:18:26 <dibblego> RayNbow, I'd offer to write the example in Haskell, but that's likely to be met with even greater aversion
03:18:41 <dibblego> RayNbow, eventually I wrote it in Scala, which has C#-like syntax (but can abstract on type constructors)
03:19:11 <skorpan> dibblego: it seems that the comments grauenwolf made are still on http://www.reddit.com/user/grauenwolf
03:19:22 <skorpan> now it's just a matter of putting the pieces together
03:19:40 <dibblego> skorpan, I don't see them there
03:20:11 * RayNbow used to hate C-style languages since I came from VB4-6... then started to like C-style languages... and now I'm back again hating them since I got to know Haskell :p
03:20:11 <dibblego> there is probably some other site that mirrors reddit
03:20:12 <skorpan> i see them, at least i think i do
03:20:23 <hackagebot> GoogleSB 0.1 - Interface to Google Safe Browsing API (AlexOtt)
03:20:32 <skorpan> "But I undstand the purpose of your "teaching" now. You don't want anyone to actually learn this stuff, you just want to pretend you are smart by throwing around psuedo-academic terms you picked up over the years."
03:20:55 <Vq^> i used to hate C-style languages that wasn't C because i came from C
03:20:57 <dibblego> skorpan, that was his last comment, which he did not delete
03:21:05 <Vq^> now i just dislike them :o)
03:21:35 <skorpan> oh, i didn't know i could "continue the thread"
03:22:28 * RayNbow remembers the first VB code he wrote... delicious goto spaghetti :p
03:23:01 <ivanm> dibblego: http://prog21.dadgum.com/3.html? ?
03:23:12 <ac> RayNbow: with gui designer sauce on top?
03:23:27 <ivanm> gah, forget that
03:23:28 <dibblego> ivanm, that was the initiator
03:23:37 <ivanm> dibblego: "You are the one struggling. You keep making claims about how programming in general, and C#'s LINQ in particular, are based on monads yet you are utterly incapable of showing one in C#."
03:23:48 <dibblego> ivanm, :(
03:23:48 <ivanm> http://www.reddit.com/r/programming/comments/8ssgq/admitting_that_functional_programming_can_be/c0aeox1 <--- that's the link I wanted
03:23:56 <ivanm> that's the last one he did AFAICT
03:24:10 <skorpan> i remember MY first VB... i had a code snippet for opening a new window and to crash people's computers i wanted the program to open an infinite amount of windows... however, i did not know about loops back then so i *manually* copy-pasted that one line i had and had to increment a number in that code line to make it work. i did this ~900 times if i'm not mistaken.
03:24:23 <dibblego> ivanm, http://www.reddit.com/r/programming/comments/8ssgq/admitting_that_functional_programming_can_be/c0aep3k
03:24:52 <ivanm> yeah
03:25:40 <ac> skorpan: wow. I remember making programs that "crashed" in QBASIC, but you could always escape by pressing some key combo that I forgot
03:25:56 <skorpan> ac: i don't suppose it was ctrl+break was it?
03:26:00 <Vanadium> The key combo being the power key?
03:26:12 <ac> skorpan: yeah. Then I discovered assembly, and had a lot of trouble making a program that _didn't_ crash
03:26:17 <Vanadium> hah
03:26:35 <RayNbow> ac: yes, but the in VB6 and prior versions, you couldn't really access the generated code
03:26:55 <ivanm> dibblego: in the BFG email, you don't say which channel you're going to use...
03:27:03 <ivanm> oh, wait, yes you did in the previous one :s
03:27:49 <RayNbow> http://paste.pocoo.org/show/123756/ <-- dibblego, I didn't know LINQ queries also worked for non-IEnumerable/IQueryable types
03:27:58 <RayNbow> (but then again, I'm not all too familiar with C#)
03:28:27 <dibblego> RayNbow, absolutely -- IEnumerable/IQueryable are just libraries -- they are otherwise not special
03:29:13 <RayNbow> yeah, but I thought the typechecker would do a nominal typecheck for LINQ queries
03:29:15 <fasta> Uhm, those types.. who wants to use that?
03:29:52 <ac> can anyone help me out with my decision crisis here? I'm working on a web application and I can't decide if I should use happstack-state, or mysql with haskelldb
03:30:07 <ac> or neither
03:30:15 <fasta> ac: it depends on your goals.
03:30:52 <quicksilver> ac: There is no problem in the known universe to which mysql is the correct solution.
03:31:03 <fasta> Heh
03:31:15 <fasta> quicksilver: if that's not a troll...
03:31:22 <ac> fasta: minimum effort of course. I'm not going to worry too much about scalability. I'll solve that problem when I need to
03:31:32 <quicksilver> it would actually be better to advise your website users to call you up and note down on a scrap of paper what they say.
03:31:42 <ac> quicksilver: lol
03:31:43 <quicksilver> fasta: it sure is :)
03:31:55 <fasta> ac: for minimum effort, you would use one of the shiny Python web libraries.
03:31:55 <quicksilver> use a real database, or use happstack-state
03:32:12 <fasta> ac: if you want to use Haskell, cgi is the easiest.
03:32:19 <quicksilver> myself I like relational databases, but it's only really worth it if you plan to use what they're good at - complex queries
03:32:20 <Vq^> and a python database...
03:32:27 <fasta> ac: low-complexity, so not a lot of stuff can break.
03:32:43 <ac> fasta: I already know Haskell fairly well. I guess one of my other goals is being fun to develop. I don't know python, and I imagine it wouldn't be as fun writing it in python
03:33:03 <Vq^> i was fairly forgiving with RDBMS:es until i learned ZODB
03:33:34 <Vq^> not mysql thought :)
03:33:59 <fasta> ac: I am not a fan of Python myself, but they do have libraries. So, if you do it in Haskell just start with the FastCGI binding and add complexity when needed. I made a dynamic webpage with Haskell 6 years ago, or something like that.
03:34:46 <fasta> ac: in theory haskelldb is a good idea, but it's in a bit-rotted state, IIRC.
03:35:32 <fasta> The architecture of happstack is very good, so the best thing would be a combination of the safety of HaskellDb and happstack. :)
03:36:33 <ac> fasta: hrrm... what do you mean add complexity when I need it? I'll be starting out with a user data structure with a handful of stuff in it, groups, and some other data, so there's a fair amount of complexity right there
03:36:54 <ac> fasta: what do you mean by "safety of HaskellDb"?
03:37:19 <fasta> ac: In HaskellDb you cannot have SQL injection attacks.
03:37:56 <fasta> ac: I would probably look into happstack, since some people have actually already used it for commercial purposes.
03:38:05 <ac> and what shiny Python web libraries are you thinking of?
03:38:26 <fasta> ac: Django for example.
03:38:45 <ac> you have to be kind of retarded to open yourself to SQL injection attacks
03:39:09 <ac> uhg, I worked on a little project using Django a while back. I hated it
03:39:33 <ac> the dynamic types and the grossness of the ORM made me want to kill something
03:40:00 <Vq^> there are much better python web-frameworks than Django
03:40:11 <fasta> ac: I think largely the same as you w.r.t. all the dynamic OOP stuff where you cannot see easily what is calling what, or why things happen.
03:40:37 <ac> yeah, that infuriates me when the flow of execution isn't immediately obvious
03:41:11 <fasta> And you cannot easily see (in an unknown code base without documentation) what you can supply to a function to have it work.
03:41:25 <fasta> In Haskell you can just ask for the type and find the constructors for that type. Easy.
03:41:37 <ac> yeah. I'm pretty set on using Haskell
03:41:46 <Vq^> well, type-class instances hides some flow
03:42:08 <fasta> For team based development Haskell or something which has this capability is superior to Python, imho.
03:42:09 <Vq^> in fact Zope3 adapters has a lot in common with Haskell type-class instances
03:42:37 <ac> fasta: that's another goal, is producing readable code for others working on the project later
03:43:18 <fasta> ac: well, then just try happstack first, if that doesn't work, try HaskellDB and if that doesn't work, create something sane for yourself :)
03:43:26 <fasta> ac: that's the order in which I would probably go.
03:43:39 <ac> yeah, I've already started reading the happstack tutorial
03:44:19 <ac> seems to me that one side-benefit of going with happstack is that because everything's in memory, it should perform rather nicely
03:44:51 <RayNbow> dibblego: that IntFunctor example is the (int->) monad? :)
03:45:10 <RayNbow> (took me some time to decipher the C# code and get it to run)
03:46:19 <dibblego> RayNbow,
03:46:20 <dibblego> yes
03:46:57 <Cheery> hi
03:47:10 <Cheery> http://i41.tinypic.com/xn7p0o.jpg
03:47:24 <Cheery> http://i41.tinypic.com/xn7p0o.jpg
03:47:26 <Cheery> o workspace (V)
03:47:37 <Cheery> damn, not finding that pic
03:47:44 <fasta> Cheery: yes?
03:47:45 <Axman6> um...
03:47:49 <Cheery> http://i40.tinypic.com/a0wjdy.jpg
03:47:51 <Axman6> are you spamming us?
03:47:51 <Cheery> anyway
03:48:09 <Axman6> because if you are, that's not very nice
03:48:38 <Cheery> actually going to ask a thing, and messing up with irssi
03:48:39 <Vq^> an interesting insight that i got with Zope3 is that the "good" design behind the framework comes from an idea called Component Architecture (CA)
03:49:09 <Vq^> which is really a move away from OO and much closer to Haskells type-classes
03:49:12 <Cheery> anyway, I'm rendering such visualisations from lambdas
03:49:45 <Cheery> calling those lambda balls
03:50:43 <Cheery> though, if I continue that way, there will come lambda balls inside lambda balls, instead of single lambda ball with a very big shell
03:50:51 <Vq^> the idea is that the classes doesn't contain that many method of their own  (which makes them simple data-structures or data-types)
03:50:59 <Cheery> (xy -> yx)(xyz -> xz(yz))
03:51:07 <Cheery> (y -> y(abc -> ac(bc))
03:51:26 <Vq^> and the behaviour is in adapters (very like type-class instances) described in interfaces (type-classes)
03:52:01 <Cheery> is there a way to turn such expression into one that doesn't have inner lambdas like that?
03:52:05 <Vq^> and the adapters are registered so they get applied automatically
03:54:29 <Cheery> I can represent such oddity, but it becomes very large
03:56:26 <Cheery> hmm.
03:56:32 <Cheery> I guess not, and I can somehow tell why.
03:57:04 <Cheery> fortunately there aren't too many of these
03:57:32 <Cheery> probably can't reasonable show the sub-expression when it's succumbed like that.
04:07:36 <lilac> Cheery: how does your graphical notation work?
04:09:15 <EvilTerran> lilac, i'm thinking the posted screenshot is S
04:10:26 <Cheery> EvilTerran: that is correct
04:10:34 <drhodes> anyone know llvm well enough to determine if it can handle a non C-like type system, or support for typeclasses?
04:11:55 <Cheery> right now making a tool to visualize those, so you'll see more soon.
04:15:35 <Axman6> drhodes: i believe it's far more low level than that. closer to asm than C
04:24:47 <quicksilver> Cheery: in principle llvm is more like an architecture neutral assembly language
04:24:53 <quicksilver> so you ought to be able to copmile any langauage to it.
04:25:09 <quicksilver> in practice there were some specific objections to do with the global registers and stacks and so on
04:25:13 <quicksilver> which made it a poor fit for GHC
04:26:07 <ivanm> apparently, /usr/share/doc/ghc-6.10.3/libraries/terminfo/System-Console-Terminfo.html doesn't exist :s
04:26:21 <ivanm> this is after I clicked on the link from the overall ghc docs on my computer :s
04:28:20 <Cheery> http://i41.tinypic.com/2csgd9k.jpg
04:29:00 <Cheery> I improve it in a moment to support stuff inside lambda balls.
04:29:23 <Gracenotes> do you support lambda cubes? />_<
04:29:57 <Cheery> heck no, not even clue about those. It's only 125 lines of code anyway
04:30:09 <Cheery> http://paste.pocoo.org/show/123988
04:30:16 <Cheery> 125 lines of somewhat messy code right now
04:31:00 <Cheery> there's a thing that makes my hat tingle, the leftmost -function that gives a certain nice representation from a lambda.
04:40:29 <Cheery> http://i40.tinypic.com/bhzssp.jpg
04:40:56 <Cheery> the problem on the right
04:41:33 <Cheery> I did just a quick hack to get that one, but it basicly shows the problem I have.
04:42:11 <Cheery> Since there's expression inside another, I need to enclose it into a bubble, and that means small bubbles
05:29:04 <Isajha> is there some kind of literature/article or something else available dealing with this so called "impedance mismatch" of functional languages and the architecture of current computers?
05:30:37 <Isajha> i am trying to understand this problem but I have a problem with this "single example" papers; i would need something - well - more fundamental than this. thanks in advance
05:34:12 <byorgey> Isajha: perhaps you might want to take a look at Simon Peyton Jones's "Implementing Functional Languages"?  http://research.microsoft.com/en-us/um/people/simonpj/papers/pj-lester-book/
05:34:40 <byorgey> it's not quite what you're asking for but it does show some of the practical aspects of compiling functional languages to run on a modern architecture
05:35:27 <Isajha> ah thank you very much - it is hard to find something as there are way too many books and search hits available. you think this one holds the answer?
05:38:33 <byorgey> Isajha: I'm not sure if it holds the answer you're looking for, but at least it is interesting =)
05:38:55 <Isajha> it does not look alike actually
05:40:09 <EvilTerran> Cheery, what's that one on the mid-right meant to be?
05:40:33 <EvilTerran> looks like (\x. x <something>)
05:40:55 <Cheery> yep
05:41:07 <EvilTerran> but what's the <something>?
05:41:15 <Cheery> it's just a hack to represent that, I'm just wondering for a better way to represent it.
05:41:43 <EvilTerran> a free variable?
05:42:06 <Isajha> ah it perhaps does he introduces a g-machine (i.e. something like assembler code); anything else to recommend?
05:42:08 <Cheery> a lambda ball inside another.
05:48:13 <EvilTerran> Cheery, ah, so the small circle inside it represents another lambda of some description?
05:48:22 <Cheery> yep
05:49:54 <aavogt> Isajha: even the graph reduction method of evaluation in the first part of that book is not too far from machine code: it does say how you would imperatively decide to reduce the expression graph. I only read that section, AFAIU, the rest of the book presents variations on that technique that are faster.
05:50:46 <aavogt> @google the implementation of functional languages
05:50:47 <lambdabot> http://research.microsoft.com/en-us/um/people/simonpj/papers/slpj-book-1987/
05:50:47 <lambdabot> Title: The Implementation of Functional Programming Languages
05:54:24 <Isajha> this one looks good thanks
05:54:50 <aavogt> actually, I was thinking of the first book that byorgey linked to
05:57:06 <Isajha> perhaps a matter of taste^^
06:03:40 <QtPlaty[HireMe]> Why is microsoft reasurch so unreliable.
06:03:48 <ivanm> how can I turn an IO a into an IO () ?
06:03:58 <ivanm> QtPlaty[HireMe]: because of the sponsoring company?
06:05:20 <skorpan> ivanm: x >>= return ()
06:05:27 <skorpan> hm, no
06:05:29 <skorpan> >> return ()
06:05:29 <ivanm> or even just >> ?
06:05:32 <ivanm> heh
06:05:41 <ivanm> it's a pretty ugly way of doing it though :s
06:05:57 <skorpan> yeah, there was some talk on the list about adding something nicer for it iirc
06:06:20 <mux> I'm not convinced about that whole 'ignore' thing
06:06:34 <skorpan> i support the idea
06:06:42 <Cheery> QtPlaty[HireMe]: perhaps because MS is a marketing company, not research
06:07:00 <ivanm> mux: what ignore thing?
06:07:05 <skorpan> Cheery: simon peyton-jones works for microsoft research...
06:07:28 <mux> ivanm: that is how people suggested calling the (>> return ()) function
06:07:45 <ClaudiusMaximus> Cheery: you might be interested in my graphical editor for lambda calculus, e.g.: http://img87.imageshack.us/img87/6977/gulci2.png
06:07:49 <skorpan> ivanm: ignore x = x >> return ()
06:08:14 <ivanm> mux: so what aren't you convinced about? the name of the function, the inclusion of such a function or the usage of >> return () ?
06:08:31 <mux> ivanm: the inclusion of such a function
06:09:37 <ivanm> why aren't you convinced?
06:09:43 <ivanm> because it's so.... useless?
06:09:54 <ivanm> (realistically, I'm only wanting it to typecheck)
06:09:59 <Cheery> ClaudiusMaximus: yet another one. :)
06:10:13 <Cheery> http://code.google.com/p/visual-lambda/
06:10:15 <mux> I already find the equivalent parsing combinators (optional) confusing
06:10:18 <trofi> @pl \a -> a >> return ()
06:10:19 <lambdabot> (>> return ())
06:10:33 <ivanm> it's either that, or I go and manually throw an ExitCode after my putStrLn in the case I don't have to do anything
06:10:44 <Cheery> ClaudiusMaximus: how does it work?
06:11:10 <mux> err, actually, optional is different
06:11:42 <ClaudiusMaximus> Cheery: i'd not seen that one, thanks for the link
06:11:52 <mux> ivanm: I'm concerned that having an ignore function is going to be confusing some people because they won't be sure if it's strictly equivalent to foo >> return (), ie they may believe ignore will be more efficient or something
06:11:58 <Cheery> skorpan: yeah, but majority of what I hear from them is bare advertising.
06:12:42 <ivanm> mux: well, how can I be sure that sum actually does sum up all the values in the list?
06:12:55 <ivanm> or that it does so efficiently?
06:13:23 <EvilTerran> it doesn't do it efficiently anyway, seeing as it's a foldl :P
06:13:27 <Cheery> ClaudiusMaximus: I assume.. those colors have some idea behind them..
06:13:29 <Cheery> let me guess.
06:13:32 <mux> ivanm: I'm not going to answer your rhetorical question; my point here is that >> return () seems sufficiently simple to me that it doesn't really warrant a specific function. of course that's totally subjective and open to interpretation
06:13:54 <Cheery> blue-yellow is a substitution
06:13:57 <EvilTerran> mux, it's a matter of writing self-documenting code, though
06:13:58 <ivanm> mux: I would say that the only reason for defining such a thing is that if sufficient people end up defining it on their own, then why not
06:13:59 <ClaudiusMaximus> Cheery: mine works by point+click/drag mouse actions, colours have ideas too
06:14:01 <Cheery> red is an application
06:14:17 <mux> ivanm: that's an interesting criterion, sure
06:14:25 <EvilTerran> "ignore $ do ..." is more explicit about what you mean than "do ...; return ()"
06:14:27 <Cheery> ClaudiusMaximus: what about green?
06:14:31 <mux> EvilTerran: true that.
06:14:44 <saml> why is FRP hard? give me introductory tutorial
06:14:48 <ClaudiusMaximus> Cheery: yes;  green is "unspecified", ie, something that you can click on to create another lambda/application/variable
06:15:03 <mux> isn't a bit ironic to be discussing haskell on IRC while being at working and hacking Perl ?
06:15:10 <ivanm> heh
06:15:14 <ivanm> speak for yourself ;-)
06:15:17 <Vanadium> Haskell and Perl are basically the same thing anyway
06:15:17 <Cheery> I hack python
06:15:31 * ivanm is surprised at how much Haskell hacking he's done today... maybe because he was meant to be doing other stuff? :p
06:15:37 <Cheery> it'd be ironic if you were discussing haskell and writing assembly all day long.
06:15:53 <Vanadium> ... as in, ridiculously daunting to beginners
06:16:24 <mux> if only my coworkers were actually sufficiently interested in code so that I could trick them into learning haskell...
06:17:14 <Cheery> saml: FRP introduces a big language of it's own, and it's bended up from haskell, I guess those are the two things.
06:18:09 <Cheery> ClaudiusMaximus: I don't bother with editing much right now.
06:18:18 <saml> ok sorry for offtopic. i'll go to #frp and demand for easy tutorial so taht i can read it in my leisure and feel good about myself
06:18:57 <Cheery> ClaudiusMaximus: my thing is a toy, I'm going to give those lambda balls physics, then allow the user to give them weights that determine how they are applied together when they hit each other.
06:19:04 <fasta> If only :r would find the libraries where updates and so on. I don't even think :load does that...
06:19:07 <hackagebot> fmlist 0.3 - FoldMap lists (SjoerdVisscher)
06:19:13 <Badger> saml: useful stuff :)
06:19:13 <ivanm> mux: lol
06:20:13 <Cheery> ClaudiusMaximus: I draw lines in polar coordinates to get those nice curves
06:20:21 <Cheery> cool? :P
06:20:24 <ClaudiusMaximus> Cheery: sounds fun - not sure what i'm going to use mine for eventually, maybe some kind of abstract performance art / livecoding thing
06:20:59 <ClaudiusMaximus> need to add undo/delete to the editor though, at the moment it's a bit awkward (have to start over, basically)
06:40:16 <Cheery> hmm.
06:40:24 <Cheery> I wonder about a preferrable evaluation strategy.
06:41:43 <fasta> What exactly causes Loading package Foo ...  linking ... <interactive>: <file/HSFoo.o>     unknown symbol `iluInit'?
06:42:01 <Cheery> guessing could use a lazy strategy, where leftmost reduction gets done first
06:42:33 <fasta> I expect that when I compile a package on machine X, that this package can also actually be loaded on the same machine X, at the very least.
06:42:48 <Cheery> will leave lots of places for contained objects, but then.. I feel I don't bother. :)
06:43:22 <sven__> hi, can somebody give me a hint on how to convert a hexstring into an int?
06:43:41 <ClaudiusMaximus> > read "0x180" :: Int
06:43:44 <lambdabot>   384
06:44:09 <sven__> ClaudiusMaximus: doesn't work in Hugs
06:44:23 <Cheery> heh
06:44:48 <Cheery> could use such strategy in evaluating, that it evaluates only the leftmost item first
06:45:10 <Cheery> and you'd need to shake it in order to make it evaluate out of order.
06:45:25 <ivanm> @tell kuribas your mode doesn't indent multiline strings properly (i.e. using ".....\<newline>\....."
06:45:26 <lambdabot> Consider it noted.
06:45:37 <ceal> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2828#a2828
06:45:42 <ceal> what
06:45:48 <ceal> what's wrong in this?*
06:46:22 <giulianoxt> its xxs
06:46:30 <giulianoxt> instead of xss
06:46:33 <quicksilver> ceal: error seems pretty clear to me :P
06:46:39 <quicksilver> ceal: there is no variable 'xss'
06:46:44 <ceal> oh
06:46:45 <ceal> ok
06:47:19 <ceal> what's the logic behind that?
06:47:27 <ceal> is it some kind of function?
06:47:44 <ceal> xs, xxs and all that
06:48:33 <Raevel> sven__: the nth number from the right is n * 16^n in decimal
06:50:12 <Raevel> s/number/digit
06:53:18 <EvilTerran> ceal, there's a naming convention, if you're pattern-matching a list, to use "something:somethings"
06:53:51 <EvilTerran> ceal, and, by extension, if you've got (x :: a), then (xs :: [a]), (xss :: [[a]]), etc
06:54:10 <ivanm> with GetOpt, is there any way of saying that no unknown options are allowed?
06:54:22 <EvilTerran> ceal, but it's nothing but a naming convention
06:57:20 <lilac> ceal: also, you can write that comprehension as "map (filter even) xxs", if you prefer
06:58:01 <Lovro> Hi every1
06:58:02 <Lovro> fire fire
06:58:18 <Lovro> i need one small problem solved in 'bout ....hmm... 20mins
06:58:22 <Lovro> and i have no clue how to do it
06:58:58 <Lovro> i need to write a function which removes elements from list which are greater than is successor
06:59:19 <Lovro> and i am not allowed to use built in functions
06:59:25 <hatds> is there a broad overview of all the C <--> Haskell tools out there?
06:59:38 <ski> > readHex "180"  -- sven ?
06:59:40 <lambdabot>   [(384,"")]
06:59:40 <Lovro> can someone help me plz?
06:59:58 <ski> s/sven/sven__/
07:00:49 <Lovro> :( pweety plz?
07:01:43 <ski> try pasting the code you've got so far ?
07:01:50 <Alpounet> given two lists [a1, ..., an] and [b1, ..., bn], how can I get all the possible combinations : [a1, b1], ..., [a1, bn], [a2, b1], ..., [a2, bn], etc
07:02:16 <sven__> ski: thx
07:02:33 <doserj> > sequence [[a,b,c],[d,e,f,g,h]]
07:02:33 <ski> > [(x,y) | x <- [0,1,2],y <- "ab"]
07:02:35 <lambdabot>   [[a,d],[a,e],[a,f],[a,g],[a,h],[b,d],[b,e],[b,f],[b,g],[b,h],[c,d],[c,e],[c...
07:02:35 <lambdabot>   [(0,'a'),(0,'b'),(1,'a'),(1,'b'),(2,'a'),(2,'b')]
07:03:13 <Alpounet> sequence looks fine :)
07:03:35 <ski> sven__ : btw, you would usually use `case readHex foo of [(n,"")] -> ..n..; _ -> some error'
07:03:41 <Lovro> i believe that if i say this is for my firend, and not for me, makes absolutely no difference to you guys, rigt?
07:03:54 <ski> > liftM2 (,) [0,1,2] "ab"
07:03:56 <lambdabot>   [(0,'a'),(0,'b'),(1,'a'),(1,'b'),(2,'a'),(2,'b')]
07:03:57 <visof> hello
07:03:59 <ski> too, i suppose, Alpounet
07:04:10 <Alpounet> yeah, but 2 may be N for me
07:04:18 <Alpounet> that's why IMO sequence is better
07:04:19 <ski> oh .. you didn't say so :)
07:04:28 <edwardk> hrmm does max bolingbroke visit here?
07:04:33 <Alpounet> ski, yeah, I would have been able to find a generalization, but yeah sorry
07:05:07 <visof> how can i divide the string to alphabets like -> "hello" should get 'h', 'e', 'l', 'l', 'o' ?
07:05:22 <ski> > ['h','e','l','l','o']
07:05:24 <lambdabot>   "hello"
07:05:27 <ski> it's the same
07:05:32 <lilac> @src String
07:05:33 <lambdabot> type String = [Char]
07:05:33 <visof> i know
07:05:49 <ski> so, what do you want to do with the string ?
07:06:02 <visof> well, "12345" i want to get [1,2,3,4,5] ??
07:06:04 <byorgey> Lovro: is this a homework problem?
07:06:08 <visof> how can i get this
07:06:09 <visof> ?
07:06:13 <lilac> > map read "12345" :: [Int]
07:06:15 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
07:06:20 <ski> oh, you want to parse parts of strings, as numbers ?
07:06:28 <fasta> byorgey: Of course it is, nobody uses Haskell for anything else.
07:06:29 <lilac> > map digitToInt "12345"
07:06:31 <lambdabot>   [1,2,3,4,5]
07:06:36 <fasta> How did you like that one quicksilver? ;)
07:06:54 <mornfall> :)
07:09:17 <byorgey> Lovro: we are happy to help if you paste some code you are working on and have some problems with it or questions.  but we won't do your homework for you.  or your friend's homework.
07:09:49 <burp> http://paste.railsbox.eu/show/lj4k190bMbNeHNWhzuRb/ <- anyone can have a quick look? I have a problem with "Couldn't match expected type `BoxDimension a' against inferred type `(a1, b, c)'
07:09:59 <burp> I want such a data: data ParticlePosition a = Particle (a,a,a)
07:10:00 <burp> with equal a
07:10:31 <byorgey> burp: you are missing a 'Box' constructor on the argument
07:10:39 <burp> oh right
07:10:39 <fasta> burp: a BoxDimension != (,,)
07:10:55 <byorgey> values of type BoxDimension a  look like   Box (x,y,z)
07:11:08 <byorgey> so you should say  createParticle (Box (x,y,z)) = ...
07:11:08 <burp> thanks
07:11:33 <byorgey> burp: and by the way, it would be better style to just say  BoxDimension a = Box a a a
07:11:34 <burp> I'm still unsure if this is even necessary.. maybe a type is enough
07:11:34 <lilac> > groupBy (>) [4,5,3,6,7,8,2,7,9] >>= (\x -> if length x > 1 then tail x else x) -- Lovro
07:11:36 <lambdabot>   [4,3,6,7,2,7,9]
07:11:40 <byorgey> no need for the tuple
07:11:43 <burp> ok
07:11:45 <Zao> The 3-tuple is a bit superfluous.
07:11:51 <byorgey> then you can say  createParticle (Box x y z) = ...
07:11:53 <Zao> Unless you happen to have a bunch of those around already.
07:12:05 <byorgey> same goes for the ParticlePosition type.
07:12:09 <burp> in the end I need this to be with good performance
07:12:28 * lilac earns "Best use of groupBy with a non-equivalence relation while solving someone's homework" award
07:12:31 <burp> I need to handle many thousand or millions of these in a list or array
07:13:25 <byorgey> burp: well, then lose the tuples.  they just add extra allocation.
07:13:40 <burp> alright
07:14:26 <doserj> lilac: that doesn't solve Lovro's homework
07:15:08 <Zao> byorgey: Would strictness and unpacking help?
07:15:33 <lilac> doserj: it removes elements from the list which are greater than their successor, doesn't it?
07:15:40 <byorgey> it might, but it's hard to know at this point.  I'd say leave that until later, once (and if) profiling reveals that it would help
07:15:41 <lilac> (at least, for this implementation of groupBy)
07:15:44 <doserj> lilac: not all of them
07:16:22 <doserj> lilac: (and you should use groupBy (<) anyways, but it's still broken
07:16:23 <lilac> doserj: there are 2 elements in that list which are greater than their successor. namely, 5 and 8. it removes both
07:17:30 <doserj> > groupBy (>) [10,9,8,7] >>= (\x -> if length x > 1 then tail x else x)
07:17:32 <lambdabot>   [9,8,7]
07:17:55 <doserj> (forget my comment about > vs < ...
07:18:15 <Jedai> lilac: I think he said that he couldn't use builtin functions... Which globally means that we really shouldn't help since it's an extremely simple and mechanical function to write with pattern-matching and guard and if he  (or his friend) can't do it, he'll have a big problem later on
07:18:38 <lilac> Jedai: i really don't think i was helping anyway ;-/
07:19:13 <Jedai> lilac: I don't think Lovro is reading us anymore (though he still is in the channel) anyway ^^
07:20:02 <lilac> doserj: obviously the implementation of groupBy isn't right for my solution to work in this version of the Prelude ;-)
07:20:41 <Lovro> i'm here
07:20:44 <Lovro> eating, sec
07:20:44 <doserj> > groupBy (>) [1,2,3,4,5,6,3,2,6,7,10,9,8,7] >>= (\x -> if length x > 1 then [] else x) -- would work, though
07:20:46 <lambdabot>   [1,2,3,4,5,6,7]
07:20:55 <Lovro> (i was afk though)
07:21:13 <lilac> Lovro: in all seriousness, if you want help and are prepared to tell us what you've got so far, we will do what we can.
07:21:52 <Jedai> Lovro: lilac solution don't respect your requirements (though it doesn't work anyway) so I don't recommend it, give your code and we'll tell you what we can do
07:22:36 <doserj> > groupBy (>) [1,2,3,4,5,6,3,2,6,7,10,9,8,7] >>= (\x -> if length x > 1 then [last x] else x) -- erm, better
07:22:37 <lambdabot>   [1,2,3,4,5,2,6,7,7]
07:23:43 <doserj> anyways, direct recursion is very simple here
07:23:46 <lilac> > groupBy (>) [4,5,3,6,7,8,2,7,9] >>= (\x -> if length x > 1 then [last x] else x) -- Lovro
07:23:47 <lambdabot>   [4,3,6,7,7,9]
07:23:56 <lilac> s/-- Lovro//
07:24:04 <lilac> doserj: still not right, sadly :)
07:24:52 <lilac> Lovro: you're going to want to apply case analysis to the list. I suggest you will want two cases: one for if the list contains at least two elements, and another for if it does not.
07:24:55 <Lovro> hey,
07:25:05 <Lovro> sory, i was eating
07:25:18 <doserj> lilac: ah, yes. this groupBy simply can't work.
07:25:26 <Lovro> anyway, well, the situation is that we have exam from this in a bout 2 weeks, so a plan of all of us
07:25:29 <RayNbow> hmm... Problem A of ACM ICPC 2009 World Finals is hard...
07:25:34 <Lovro> is to learn it by then
07:25:49 <fasta> RayNbow: url?
07:25:52 <Lovro> but, today we need to give our assignment, which bring a few "points" (yea, bologna)
07:25:57 <lilac> RayNbow: they have world competitions now? i've only ever entered the national one
07:26:08 <Lovro> and it has been a hectic week, so none of us actually had time to do it
07:26:18 <Lovro> so..i don't think he has any code
07:26:22 <RayNbow> lilac: apparently
07:26:34 <lilac> maybe it's time to put the old team back together :)
07:26:38 <Lovro> (hectic vecause of other 5 subjects we have )
07:27:09 <Lovro> and both he and i are writing something called "final work", something like that
07:27:09 <RayNbow> lilac: http://cm.baylor.edu/resources/pdf/2009Problems.pdf <-- problem A has been translated to Dutch for a local university magazine... and I'm trying to solve it :p
07:27:15 <Lovro> i don't know how to translate it
07:27:21 <Lovro> because we are finishin 3rd year... etc
07:27:30 <Botje> it's called a bachelor thesis
07:27:32 <RayNbow> but so far I can only solve simple problems manually
07:27:33 <Lovro> anyway, thats the situation
07:27:44 <Lovro> so, if anyone would be kind anough to help him, that would be great
07:28:19 <Lovro> if it ain't a biggie :)
07:29:30 <Jedai> Lovro: Let's say we give you most of the ingredients and let you assemble them...
07:29:35 <doserj> Lovro: If you can't solve this one straight away, try a simple one first, like: remove all negative elements from a list of integers.
07:29:36 <lilac> RayNbow: sounds like a dynamic programming solution could possibly work.
07:29:55 <RayNbow> lilac: oh great... and I suck at dynamic programming :p
07:30:05 <fasta> RayNbow: it seems brute-force would work for the first one.
07:30:07 <Lovro> ok, that makes sense lilac
07:30:21 <RayNbow> fasta: those two example cases are quite easy
07:30:40 <Lovro> (but let's talk "he will want to apply case analysis .. :D, it really is for a friend)
07:30:49 <Jedai> Lovro: (:) is the "cons" constructor, you use it like that (x : xs) with x the element you want to add in front of the list xs
07:31:24 <RayNbow> fasta: but how about this example case I came up with? http://dpaste.com/57147/
07:31:33 <Jedai> Lovro: you can also use (x : xs) as a pattern in the LHS of a definition or after a case ... of to deconstruct a list
07:31:40 <Jedai> So for instance :
07:31:43 <Lovro> i had a different assignment
07:31:57 <Jedai> myFun (x : xs) = x
07:32:07 <Jedai> myFun [] = error "blabla"
07:32:23 <Jedai> ([] is the empty list)
07:32:59 <Jedai> defines a function myFun that evaluates to the first element of its parameter or to an error if this list is empty
07:33:10 <Lovro> ok, i'll pass it to him :D
07:33:17 <Lovro> that was for Jedai
07:33:45 <Jedai> now, xs is also a list, so you can have a more advanced pattern here :
07:33:58 <Jedai> myFun (x : y : xs) = ...
07:34:38 <Lovro> lol, i have such a bad connection here, actually my irc is lagging :D
07:34:49 <Jedai> here you look at the first two elements of your list at once, it'll probably be one of the case his final function will have to handle
07:35:11 <fasta> RayNbow: I slightly oversimplified the problem. Since n is unconstrained brute-forcing is not going to work.
07:35:53 <fasta> RayNbow: actually there is an error in the problem definition.
07:36:11 <fasta> RayNbow: they use n two times with two different meanings. Not very mathematical of them.
07:36:32 <Philonous> I think the "do" keyword should have been single, capitalized D: the bow-operator, with which you shoot your kleisli-arrows at the boiler plate
07:38:00 <Jedai> Lovro: Once you know that, well the solution is a straightforward recursion with a if then else to decide which element to keep
07:38:09 <fasta> RayNbow: actually, I am not sure what they mean. If they really mean the two n's are the same, trying brute-force first is not a bad first step.
07:38:42 <doserj> fasta: if they don't, what would be the point of the first n?
07:39:04 <RayNbow> fasta: the two n's are the same... it's just a description of the file format
07:39:05 <Vanadium> Is there a function that does to "foo:bar:baz" what lines does to "foo\nbar\nbaz"? Ideally with configurable ':'?
07:39:28 <Zao> Vanadium: You could probably do it with a regex or so.
07:39:30 <Lovro> ok, thank you jedai
07:39:37 <Zao> Vanadium: Char or String token?
07:39:43 <Lovro> that was a bad lag :) i didnt receive anything til now
07:39:48 <Vanadium> Char token should do
07:40:01 <Lovro> and thats what probably happening now as well,
07:40:02 <Vanadium> I did it by hand but it ended up being a whole mess of pattern matching :|
07:40:25 <Lovro> well, its hard to talk like this, and then copy everything to him,
07:40:31 <Lovro> so, thanks for your grouble jedai
07:40:51 <Zao> ByteString has a split, but I'm unsure if String has one.
07:41:28 <Lovro> *trouble
07:41:28 <Jedai> Vanadium: You have a package for that on Hackage
07:41:35 <fasta> RayNbow: yes, I see. Well, brute-force would work. Lots of ACM contest problems are about deciding whether to do something smart or not. In about 30% of the cases you just need to brute-force.
07:42:03 <Vanadium> Zao: Oh, I suppose I would be happy with using bytestrings
07:42:24 <RayNbow> fasta: but how would you actually use brute force? The intervals may have integer boundaries... but the arrival of an airplane does not have to be an integer
07:42:30 <Jedai> Vanadium: the split package on Hackage provides a wide variety of good splits for lists
07:42:37 <Vanadium> Hm. Thanks.
07:42:48 <Zao> What isn't there on Hackage? :)
07:42:54 <Jedai> Vanadium: of course, if you already have ByteString, just use their split :)
07:43:28 <fasta> RayNbow: they are specified in minutes. So, it has to be an Integer.
07:44:42 <giulianoxt> ReyNbow: Maybe multiply the interval and work only in seconds?
07:45:14 <giulianoxt> RayNbow: wouldn't have to worry about floats
07:46:29 <RayNbow> hmm...
07:50:45 <lilac> > let s = map (\x -> case x of ':' -> '\n'; '\n' -> ':'; _ -> x) in map s . lines . s $ "foo:bar:baz\nwibble"
07:50:47 <lambdabot>   ["foo","bar","baz\nwibble"]
07:51:18 <Lovro> jedai, he says he understands how to solve it from here
07:51:28 <Lovro> (and he says thanks)
07:54:05 <jeffersonheard> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6056#a6056 -- can anyone tell me why this fails to compile?
07:54:32 <dmwit> I bet GHC can.
07:54:38 <jeffersonheard> dmwit, yes
07:54:47 <jeffersonheard> however, I can't see the problem it complains about
07:54:55 <dmwit> (That was a subtle hint to post GHC's error somewhere.)
07:55:03 <jeffersonheard> oh right :P
07:55:31 <jeffersonheard> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6057#a6057 -- the error message
07:56:02 <lilac> > map (filter (/= ':')) $ groupBy (const (/= ':')) "hello:world:foo"
07:56:04 <lambdabot>   ["hello","world","foo"]
07:56:38 <lilac> > map tail $ groupBy (const (/= ':')) . (':':) $ "hello:world:foo"
07:56:40 <lambdabot>   ["hello","world","foo"]
07:56:50 <dmwit> jeffersonheard: So... have you tried changing the binding to match what it says it should?
07:57:05 <dmwit> jeffersonheard: i.e. (_, (w, h, potw, poth, channels, buffer)) <- copydata pb
07:57:27 <jeffersonheard> well, but you can see the definition of copydata explicitly doesn't return that
07:58:05 * dmwit blinks
07:58:23 <jeffersonheard> in fact, the item that it supposedly returns is never passed to copydata.  Only thing I did was put it inside an exception handler so that Hieroglyph doesn't bomb out if the pixmap for an image is corrup
07:58:27 <jeffersonheard> I changed no other code
07:59:12 <jeffersonheard> I thought maybe it had something to do with the let-binding of exceptionHandler
07:59:19 <jeffersonheard> but for the life of me I can't see it
07:59:24 <dmwit> Oh, wow. =)
07:59:35 <dmwit> hehe
07:59:41 <dmwit> Look carefully at that error message.
08:00:04 <dmwit> Think about which monads these returns and binds are in veeery carefully...
08:00:12 <jeffersonheard> oh crap.
08:00:18 <jeffersonheard> haha
08:00:20 <jeffersonheard> right
08:01:58 <Phillemann> I'm trying to read from a pipe using, for example, readFile or hGetContents, but instead of blocking those functions just return an empty string.
08:03:40 <Philonous> Phillemann: AFAIK hGetContent is lazy, so you need to force the resulting string before closing the handle (e.g. use length)
08:03:48 <mmorrow> @hoogle hWaitForInput
08:03:49 <lambdabot> System.IO hWaitForInput :: Handle -> Int -> IO Bool
08:04:16 <jeffersonheard> adding \_ -> to the beginning of the Left side of the either call fixed it
08:04:17 <jeffersonheard> hehe
08:04:48 <mmorrow> Philonous: hWaitForInput uses select() (via the rts)
08:05:33 <mmorrow> oops
08:05:39 <mmorrow> @Phillemann
08:05:40 <lambdabot> Unknown command, try @list
08:06:00 <Phillemann> select() seems a bit too much, Haskell just has to call read, which blocks by default. o_O
08:06:22 <mmorrow> well, you can always ffi import read() ;)
08:06:42 <mmorrow> but the rts IO manager uses select, so for all Handles
08:06:50 <Phillemann> Ah well...I'll go with waitforinput then. ;)
08:06:57 <Baughn> Phillemann: The problem is that there may be multiple (haskell) threads
08:06:59 <mmorrow> hWaitForInput just gives you access to that
08:07:09 <Baughn> Phillemann: hWaitForInput isn't allowed to block the /other/ ones, so it can't use read
08:07:58 <Phillemann> In fact, I'm using threads in my application to circumvent the blocking. At least I intended to.
08:09:07 <jeffersonheard> oh, and tahnks, dmwit
08:11:24 <Phillemann> Hmmm, "hWaitForInput h (-1)" returns immediately with EOF instead of blocking.
08:11:41 <eck> what does haskell call readdir?
08:11:52 <mmorrow> Phillemann: the Int is the size of input you want to wait on
08:12:13 <mmorrow> Phillemann: so i guess for a pipe you want 4096 (if linux) or something
08:12:48 <Phillemann> mmorrow: The reference says it's the number of milliseconds to wait, with -1 being (wait indefinitely)
08:12:54 <mmorrow> oh, oops
08:13:00 <mmorrow> hmm
08:14:18 <mmorrow> there should be one where you can give the number of bytes to read
08:14:34 <mmorrow> and it'll block
08:15:10 <mmorrow> i know bytestring has one for that
08:15:19 <mmorrow> @hoogle hGet
08:15:20 <lambdabot> Data.ByteString hGet :: Handle -> Int -> IO ByteString
08:15:20 <lambdabot> Data.ByteString.Char8 hGet :: Handle -> Int -> IO ByteString
08:15:20 <lambdabot> Data.ByteString.Lazy hGet :: Handle -> Int -> IO ByteString
08:16:05 <mmorrow> so i guess maybe hGet 4096 for a pipe (?)
08:16:42 <hackagebot> Hieroglyph 3.2 - Purely functional 2D graphics for visualization. (JeffersonHeard)
08:16:47 <mmorrow> (hWaitForInput was the wrong suggestion for this in hidsight ;)
08:16:54 <mmorrow> *hindsight
08:17:56 <mmorrow> i think the closest thing to hGet n for String would be replicateM n hGetChar, which sounds nasty
08:19:57 <mmorrow> Phillemann: alternatively, you can use hReady and threadDelay, but that doesn't sound very preferable (maybe)
08:20:44 <jeffersonheard> latest update to Hieroglyph includes fixing alpha channels in OpenGL, fixing blending artifacts in OpenGL, and adding a backgroundcolour :: Maybe AlphaColour to the Text primitive
08:20:46 <Phillemann> It doesn't, indeed ;)
08:21:28 <jeffersonheard> also Image primitives will print an exception message rather than bomb out if they are rendered and can't reach the path to the image
08:23:42 <mmorrow> Phillemann: are you literally opening a foo.fifo?
08:24:01 <Phillemann> mmorrow: What do you mean?
08:24:02 <mmorrow> (a la mkfifo)
08:24:05 <Phillemann> Ah, yes.
08:24:31 <mmorrow> ah, those are tricky, i'm not sure exactly how Handle/etc deal with those
08:25:07 <Phillemann> Me neither :D
08:25:30 <Phillemann> But I don't really want to use sockets or something similar here...
08:26:46 <mmorrow> i guess one option (that i *think* would work) would be to forkOS a thread that just calls (ffi-imported) read() on the fifo, and comunicates with the rest of the program via a Chan or something
08:27:03 <mmorrow> but i feel like there should be some way to do it with Handle
08:28:07 <mmorrow> (you'd need to be -threaded for that to not block the entire program too)
08:28:16 <Phillemann> Well, using the ffi would be a good exercise :>
08:29:08 <Phillemann> Does Haskell use mechanisms like select on a forkIO call if I don't use -threaded? So there really are no threads created?
08:29:11 <mmorrow> if you know C, it's super easy
08:30:09 <mmorrow> forkIO threads are only at the level of the rts, so they aren't "real" threads
08:30:19 <mmorrow> forkOS on the other hand makes a pthread
08:31:05 <Beelsebob> mmorrow: well, forkIO threads *can* be pthreads
08:31:06 <Phillemann> Hehe, pretty neat this thread emulation.
08:31:06 <mmorrow> hmm, actually if you make a blocking foreign call while -threaded i think you don't have to use forkOS
08:31:18 <Beelsebob> just forkOS is guarenteed to make one
08:31:45 <hackagebot> fmlist 0.4 - FoldMap lists (SjoerdVisscher)
08:32:04 <mmorrow> yeah, like for instance with opengl binding you need forkOS (which i found out the hard way) since they use thread-local state
08:32:29 <jmcarthur_work> forkIO threads are m green threads on n os threads, and i like them a lot better than forkOS threads :)
08:32:56 <jmcarthur_work> mmorrow, OH YUCK
08:33:21 <jmcarthur_work> mmorrow, then again, why are you using opengl in multiple threads at all?
08:33:24 <mmorrow> although you need to use +RTS -Nn -RTS, n > 1 if you want to make a blocking foreign call and not block everything else
08:33:57 <jeffersonheard> mmorrow, I was about to ask the same question
08:34:00 <jeffersonheard> GL is not thread-safe
08:34:19 <jeffersonheard> (DirectX is, however :-) )
08:34:23 <mmorrow> jmcarthur_work: i'm not going to the mainLoop, and just servicing n events every so often so i can live in the background in ghci for vacuum-gl and sit on a Chan waiting for (view :: a -> IO ()) calls
08:35:14 <Beelsebob> mmorrow: you don't necessarily need forkOS
08:35:18 <Beelsebob> just runOnBoundThread
08:36:09 <mmorrow> hmm, will that work if i want multiple windows?
08:36:23 <mmorrow> (as i understand it, you need one os thread for each window)
08:36:31 <mmorrow> since each one has its own tls
08:37:02 <mmorrow> err, s/jmcarthur_work/jeffersonheard/
08:37:17 <mmorrow> oh, oops
08:37:21 <mmorrow> @both ;)
08:37:21 <lunabot>  :)
08:37:22 <lambdabot> usage: @vote <poll> <choice>
08:37:34 <jeffersonheard> makes sense
08:38:46 <mmorrow> here's that code, although i've added a bunch to it that's not in this repo (i should update it) http://moonpatio.com/repos/vacuum-gl/
08:39:28 <mmorrow> it's also ffi'ing to graphviz so i can use it in the same address space.. which is slightly epic..
08:40:26 <mmorrow> (i needed to use pthread_create since i ended up needing to have two C functions, one that reads a FILE* and one that write to one, talk to each other, which wasn't working out to well since i was in one process ;)
08:40:43 <mmorrow> (needed to use.. at one point in some C code in there)
08:42:13 <mmorrow> before i did s/forkIO/forkOS/ i would get random inexplicable segfualt and/or failed assertion from random "intel_something()" failed assertions from driver code :/
08:44:36 <Phillemann> Hmm, ByteString.hGetContents also returns an empty string instead of blocking.
08:45:52 <mmorrow> Phillemann: does hGet block? (you might not be able to use hGetContents here since it uses unsafeInterleaveIO which might interact badly with fifos)
08:46:09 <Phillemann> I'll try.
08:46:27 <jmcarthur_work> Phillemann, if you are wanting safe, lazy io, you will need to resort to iteratees or something
08:46:58 <Phillemann> mmorrow: Nope, same problem with hGet.
08:47:21 <mmorrow> Phillemann: ewww, i dunno then. i'm sure someone does though.
08:55:28 <Lovro> hi
08:55:32 <Phillemann> This is actually harder than I though ;)
08:55:40 <Vq^> hi Lovro
08:55:40 <Lovro> Jedai, are u here?
08:56:14 <Lovro> ok, so i need a function which removes elements from list, if it is greater than his succesor
08:56:17 <Lovro> so, so far i have this
08:56:19 <Lovro> rev :: [a] -> [a]
08:56:19 <Lovro> rev [] = []
08:56:19 <Lovro> rev (x:y:xs) = if x>y then rev tail xs else xs
08:56:36 <Lovro> it won't compile
08:56:55 <ski> maybe you meant s/rev tail xs/rev (tail xs)/ ?
08:56:56 <Lovro> 3rd line, says incorrect indentation
08:57:11 <Lovro> i have no idea, its still for my friend
08:57:18 <Lovro> his reply was: "huh?"
08:57:38 <Axman6> Lovro: put brackets around tail xs
08:57:46 <Axman6> rev (tail xs)
08:57:56 <ski> there doesn't appear to be any indentation problem in those three lines you gave just above
08:57:56 <Lovro> ok, ill tell him
08:58:07 <ski> maybe you have extra spaces or tabs in the file, though ?
08:58:14 <Axman6> Lovro: is there any reason he can't ask questions for himself?
08:58:25 <ski> (or maybe the problem is before or after these three lines in the file)
08:58:32 <Lovro> he doesn't have any irc clieint -_-
08:58:39 <Axman6> Lovro: although, i don't think the code does what you want anyway
08:58:59 <Lovro> ill install mirc for him, sec
08:59:08 <Alpounet> Lovro, http://www.mibbit.com/
08:59:09 <Vq^> Lovro: there are web-based irc-klients
08:59:18 <Vq^> ah, there you go :)
08:59:24 <Axman6> i think you want rev (x:y:xs) = if x > y then rev (y:xs) else x : rev (y:xs)
09:00:00 <ski> (Axman6 : don't do all their thinking for them :)
09:00:29 <doserj> well, there is still a bit missing, so Axman6 didn't do all their thinking :)
09:00:53 <Axman6> well somtimes, giving the answers can be better than having someone battle through something they don't know what's wrong with... oh man this sentense is getting awful >_<
09:01:03 <Lovro> still not working
09:01:19 <ski> what does "not working" mean ?
09:01:27 <ski> a compile error ?
09:01:29 <Lovro> could not dedue Ord a
09:01:32 <ski> a run-time error ?
09:01:38 <Lovro> from the context ()
09:01:44 <Lovro> compiler error
09:01:45 <ski> try removing the type signature
09:01:57 <ski> then ask the system what type `rev' has
09:02:18 <ski> (by "remove" i mean "comment out")
09:02:19 <Lovro> ok, it compiled this time
09:02:23 <Lovro> but now he is testing it
09:02:28 <ski> Lovro> :t rev
09:02:28 <Lovro> (thx)
09:02:38 <EvilTerran> ... why isn't "he" in here?
09:02:46 <Lovro> we have a very slow connection here
09:02:50 <Lovro> we are far away from router
09:02:58 <EvilTerran> i see
09:03:10 <Lovro> my wifi card appears to be a bit better though
09:04:07 <Lovro> he is trying to use mibbit now
09:04:16 <Lovro> its awfully slow
09:04:26 <Lovro> hell be here in a sec
09:04:36 <Lovro> or 2 minutes :d
09:05:46 <Vq^> seems like freenode has banned mibbit :/
09:06:07 <Vq^> Lovro: but this webclient could be helpful: http://webchat.freenode.net/
09:06:39 <flipflap> How do I get the IP from a host name? Lowlevel Socket stuff?
09:06:45 <flipflap> Like C's gethostbyname
09:07:01 <EvilTerran> ?hoogle gethostbyname
09:07:02 <lambdabot> No results found
09:07:46 <Lovro> here, he came
09:07:47 <flipflap> EvilTerran: No such function in Haskell
09:07:49 <Lovro> hrvoje is his name
09:08:00 <flipflap> called that way
09:08:01 <hrvoje> hi guys
09:08:06 <ski> hello
09:08:24 <hrvoje> so, can anyone help me? :)
09:08:33 <hrvoje> i did what you told me
09:08:42 <hrvoje> and compile works
09:08:43 <hrvoje> but...
09:08:46 <flipflap> Everyone can help you, in #haskell
09:08:50 <ski> (after you've seen what type the system thinks `rev' has, you can uncommment the type signature again, including the suggested changes)
09:09:23 <hrvoje> when i write something like
09:09:44 <hrvoje> let x = rev [2,3,1,4]
09:09:51 <flipflap> :t rev
09:09:52 <lambdabot> Not in scope: `rev'
09:09:53 <hrvoje> it passes
09:10:09 <hrvoje> and then, when i try to print out x
09:10:20 <ski> hrvoje : i'm not quite sure what your current version of `rev' .. care to paste it ?
09:10:23 <ski> @hpaste
09:10:24 <lambdabot> Haskell pastebin: http://hpaste.org/new
09:10:28 <hrvoje> it tells me: non-exshaustive patterns in function rev
09:10:32 <ski> oh
09:10:34 <hrvoje> code is:
09:10:43 <ski> that's because you don't have a case for lists with exactly one element
09:10:43 <hrvoje> rev [] = []
09:10:44 <hrvoje> rev (x:y:xs) = if x>y then rev (y:xs) else x:rev (y:xs)
09:11:09 <hrvoje> aha
09:11:23 <hrvoje> and how do i make that right? :)
09:11:24 <ski> `[]' is for lists with zero elements, while `x:y:xs' matches lists with at least two elements
09:11:34 <ski> you *could* add a case
09:11:39 <ski>   rev [x] = ..x..
09:11:53 <ski> (there might be a shorter way, too depending on the problem)
09:11:53 <hrvoje> i'll try
09:13:35 <hrvoje> it works!
09:13:40 <hrvoje> thank everyone
09:13:49 <hrvoje> thanks
09:13:53 <ski> what did you add ?
09:14:03 <ski> also, did you get a working type signature ?
09:14:35 <ski> also, if you want, you could avoid mentioning `rev (y:xs)' two times in the `rev (x:y:xs) = ...' equation
09:15:31 <RayNbow> fasta: I see the brute force aspect of that ACM contest problem now... with a maximum of 8 airplanes, the planes can land at most in 8! different orders
09:15:39 <RayNbow> > product [1..8]
09:15:41 <lambdabot>   40320
09:16:13 <hrvoje> ski: zad [] = []
09:16:14 <hrvoje> zad[x] = [x]
09:16:14 <hrvoje> zad (x:y:xs) = if x>y then zad (y:xs) else x:zad (y:xs)
09:16:20 <hrvoje> here's the code
09:16:26 <hrvoje> it works
09:16:41 <RayNbow> but it's actually quite easy to find out which plane has to land first and which to land last, so you only have to check 6!=720 possible ways
09:16:43 <ski> what is it supposed to do ?
09:17:29 <hrvoje> it removes the element from a list, if taht element is greater than it's successor
09:17:45 <ski> ok
09:17:52 <flipflap> Next try
09:17:59 <flipflap> How do I resolve a hostname to an IP?
09:18:01 <hrvoje> bye
09:18:03 <flipflap> Like C's gethostbyname
09:18:46 <Axman6> Lovro: you should recommend to your friend that he make up better names for his functions
09:18:57 <Lovro> ok, he left?
09:19:03 <ski> yes
09:19:08 <Lovro> oh i see
09:19:24 <Lovro> he laughs, its a "working version"
09:19:28 <ski> (maybe `zad' is a word in Hungarian ?)
09:19:36 <Lovro> actually, we are from croatia
09:19:43 <Lovro> but "zed's dead baby"
09:19:55 <ski> er, right, i just relalized that
09:19:59 <Lovro> -_-
09:20:09 * ski always confuses `.hr' with Hungaria ..
09:20:52 <dons> ?userrrs
09:20:53 <lambdabot> Maximum users seen in #haskell: 658, currently: 605 (91.9%), active: 12 (2.0%)
09:21:11 <lilac> dons: talk to lambdabot like a pirate day?
09:21:30 <flipflap> Yarrr me hearties
09:21:31 <Lemmih> ?arr
09:21:31 <lambdabot> Yeh scurvy dog...
09:21:32 <dons> ?yarr!
09:21:32 <lambdabot> I want me grog!
09:21:52 <Axman6> @YARRR
09:21:52 <lambdabot> Unknown command, try @list
09:21:56 <Axman6> @YARR
09:21:57 <lambdabot> Unknown command, try @list
09:21:59 <Axman6> lame
09:22:05 <flipflap> ?arr
09:22:06 <lambdabot> Aye Aye Cap'n
09:22:07 <flipflap> ?arr
09:22:08 <lambdabot> I'll keel haul ya fer that!
09:27:55 <mmorrow> @nixon
09:27:56 <lambdabot> I've never canceled a subscription to a newspaper because of bad cartoons or editorials. If that were the case, I wouldn't have any newspapers or magazines to read.
09:32:13 <lilac> @@ @run "@quote"
09:32:14 <lambdabot>   "@quote"
09:32:20 <lilac> :(
09:32:42 <gwern> lambdabot output can't be lb input; that'd be a security problem :)
09:32:52 <gwern> @quote
09:32:52 <lambdabot> <dons> says: its bizarre. lisp crippled FP for 40 years
09:33:30 <lilac> @@ @run (@run fun "\"" :: Expr) (@quote) (@run fun "\"" :: Expr)
09:33:34 <lambdabot>   <no location info>:
09:33:34 <lambdabot>      lexical error in string/character literal at chara...
09:33:43 <lilac> @@ (@run fun "\"" :: Expr) (@quote) (@run fun "\"" :: Expr)
09:33:45 <lambdabot>   "
09:33:46 <lambdabot>  Tela says: ... tutorials which focus on the IO monad go to great lengths to mention how Monads basically save your life every day   "
09:33:54 <lilac> :( 'fun' is adding a newline
09:37:17 <gwern> @quote
09:37:18 <lambdabot> pumpkin says: makes the next internet hit video, 2 natural transformations, 1 functor
09:49:38 <Cheery> OK. another terrible hack.
09:54:32 <Lovro> ok, bye every1, thx for help
09:54:39 <Lovro> (hrvoje says thx too)
09:54:48 * Lovro waves
09:57:58 <Jedai> flipflap: I guess you found it by now, but what you're searching for is in the network package, in Network.BSD
09:58:03 <Jedai> @hoogle Host
09:58:04 <lambdabot> No results found
09:58:17 <Jedai> @hoogle +network Host
09:58:17 <lambdabot> Could not find file:
09:58:18 <lambdabot>     network
09:58:18 <lambdabot> Searched:
10:00:17 <Jedai> flipflap: well, the regular hoogle find it (though to be honest I directly looked into network since I was pretty sure it would be there)
10:00:38 <skorpan> hoogle sucks
10:00:47 <skorpan> hayoo sucks almost as bad
10:12:26 <bremner> @can haskell make skorpan happy?
10:12:27 <lambdabot> Maybe you meant: faq map run wn
10:12:45 <bremner> @faq can haskell make skorpan happy?
10:12:45 <lambdabot> The answer is: Yes! Haskell can do that.
10:12:57 <jmcarthur_work> @help map
10:12:57 <lambdabot> map. #haskell user map
10:13:10 <jmcarthur_work> @map
10:13:11 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
10:13:14 <jmcarthur_work> ah!
10:13:29 <jmcarthur_work> and yet the link is wrong
10:13:47 <lilac> @run rabbit run
10:13:48 <lambdabot>   Not in scope: `run'
10:13:59 <lilac> @let run = undefined
10:14:00 <lambdabot>  <local>:11:0:
10:14:00 <lambdabot>      Multiple declarations of `L.run'
10:14:00 <lambdabot>      Declared at: <local...
10:14:02 <lilac> @run rabbit run
10:14:04 <lambdabot>   wascally wabbit
10:14:41 <conal> @where+ map http://haskell.org/haskellwiki/HaskellUserLocations
10:14:41 <lambdabot> I will remember.
10:15:20 <conal> hm.  i think there's a fancy web 2.0 alternative.  frappr some some such.
10:15:52 <conal> oh.  says so on the wiki page
10:18:02 <skorpan> where can i find an up-to-date parsec tutorial?
10:18:38 <burp> realworldhaskell
10:18:45 <skorpan> ah, of course
10:18:47 <skorpan> @rwh
10:18:47 <lambdabot> Maybe you meant: rc run wn
10:18:48 <burp> http://book.realworldhaskell.org/read/using-parsec.html
10:18:52 <jmcarthur_work> yeah the frapper thing sucks though :(
10:18:52 <skorpan> thanks
10:19:08 <jmcarthur_work> *frappr
10:19:36 <jmcarthur_work> @where rwh
10:19:37 <lambdabot> is http://www.realworldhaskell.org/blog/
10:19:41 <jmcarthur_work> is how you do it
10:19:55 <skorpan> cool
10:20:25 <jmcarthur_work> does rwh cover parsec3?
10:31:16 <pmurias> i often end up writint functions like isFoo (Foo _) = True;isFoo (_) = False is there a better/more consise way of doing that?
10:31:24 <pmurias> * writing
10:32:02 <skorpan> depends on where you use it
10:33:23 <skorpan> generally no, i don't think there is a more concise way
10:33:23 <pmurias> often in conjunction with filter or a similiar function
10:33:28 <skorpan> oh, okay
10:33:29 <skorpan> then:
10:33:33 <skorpan> data A = A | B | C
10:33:51 <skorpan> suppose you have [A] and want to filter it so that you only have B constructors
10:34:06 <skorpan> then you can do [ x | x@B <- xs ]
10:34:11 <skorpan> if i'm not mistaken
10:34:21 <thoughtp1lice> should work
10:34:21 <mux> yeah you can do that
10:34:27 <skorpan> that's equivalent to "filter isB xs"
10:34:28 <thoughtp1lice> @ are allowed anywhere a pattern is allowed
10:34:45 <mux> > fail :: [a]
10:34:47 <lambdabot>   Couldn't match expected type `[a]'
10:34:58 <ClaudiusMaximus> > [ x | x@True <- [False,True] ]
10:34:59 <mux> > fail "" :: [a]
10:35:00 <lambdabot>   [True]
10:35:01 <lambdabot>   []
10:35:08 <mux> that's why it works
10:35:21 <thoughtp1lice> ORLY?
10:37:05 <mmorrow> it's funny how after a while you start associating people's nicks with the color xchat gives them
10:37:26 <mmorrow> ("thoughtp1lice" looked odd in green instead of yellow)
10:38:16 <pmurias> skorpan: i was aware of that but i want to use my own filter like function (which returns the indexes of the elements that much that criterion) and list comprehension can't do curring like (filter isB)
10:38:51 <skorpan> then i don't think there is any other way
10:38:58 * gwern narrows eyes at mmorrow. that red communist nick!
10:42:34 <thoughtpolice> mmorrow: hehe
10:45:17 <mmorrow> gwern: i'm red?! i never knew.
10:45:52 <mmorrow> i wanted to look at the xchat code to see how it chooses colors for a while now..
10:46:05 <mmorrow> i guess probably a hash function or something
10:46:20 <Philonous> IRC-clients should hash the nick to color codes so that they appear in the same color for everyone
10:46:40 <Philonous> Oh, XChat does that?
10:47:05 <gwern> Philonous: what colors would they hash to?
10:47:10 <gwern> there are many different subsets
10:47:52 <Philonous> Dunno, just create RGB values and scale them afterwards
10:47:58 <mmorrow> yeah, i wonder also if the color of a nick in xchat depends only on the chars in the nick
10:48:41 <gwern> probably not. I'm fairly sure the irssi colors have to do with order of activity
10:48:53 <Philonous> Pidgin seems to assign them randomly but saves them, so they are consistent per user
10:49:10 <gwern> hashing would be nice, but you'd never get the major irc clients to all do it
10:51:29 <thoughtpolice> this all in an effort so I can be known in IRC-land as 'the guy with the kinda blue nick with a slight green on it as well'
10:51:33 <thoughtpolice> amongst all :)
10:52:22 <joga> ms comic chat needs to be reinvented
10:52:42 <Philonous> That would lead to a new e-sport: IRC color golfing. Who can produce a given color with the shortest nick...
10:52:58 * Badger breaks out the 9 iron
10:53:12 <paper_cc> Philonous: a way to discover hash function vunerabilities?
10:53:14 * mmorrow breaks out the hash function inverter
10:53:18 <mmorrow> heh, exactly
10:54:26 <gwern> nicks aren't very long, and are pretty restircte
10:54:46 <mmorrow> yeah, brute force would be feasible
10:54:56 <mmorrow> maybe
10:55:32 <malosh> Hi. Has someone ever done a wiki engine based on the darcs API ?
10:55:56 <malosh> I've seen the project as a google SoC proposal, but no achievement
10:56:40 <sjanssen> malosh: see darcsit
10:57:16 * mmorrow just unpacked the xchat source to here http://moonpatio.com/repos/MISC/xchat-2.8.6/
10:57:23 <mmorrow> (sends .c as text/plain)
10:57:40 <mmorrow> looking for the nick coloring code..
10:57:48 <malosh> sjanssen : you mean gitit ?
10:58:07 <sbahra> -blah
10:59:13 <mmorrow> util.c looks promising
10:59:14 <sjanssen> malosh: there's a corresponding darcsit
10:59:34 <saml> mmorrow, where is util.c?
10:59:57 <saml> nevermind fiound it
11:00:56 <mmorrow> looks like there's a (actually two) hash functions in there, but no color table..
11:07:02 <mmorrow> ooh, starting at line 1923 in src/common/text.c
11:07:16 <mmorrow> (i had to get the tarball and start grepping)
11:07:16 <therp> do I remember that incorrectly or did {-# OPTIONS_GHC -packages foopackage #-} work at some point in the past?
11:07:26 <mmorrow> http://www.xchat.org/files/source/2.8/
11:07:34 <therp> s/-packages/-package/
11:10:02 <mmorrow> here's how xchat colors nicks: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6060#a6060
11:10:26 <mmorrow> (dunno that colors those numbers are assoc with though..)
11:10:38 <Jedai> therp: I have no idea :) But why would you want to do that ?
11:11:01 <therp> jedia: so that I don't have to tell ghci every time :set -package foopackage
11:11:38 <Jedai> therp: GHCi find those packages by itself normally, do you have a conflict ?
11:12:08 <Jedai> In case of a conflict, you could try the PackageImport (or something like that) extension*
11:12:37 <therp> jedai: hmm.. oh yes it does! thanks.
11:13:48 <mmorrow> @let let color_of nick = let rcolors = [19, 20, 22, 24, 25, 26, 27, 28, 29]; n = sum (fmap (max 255 . ord) nick) in rcolors !! (n `mod` length rcolors)
11:13:49 <lambdabot>   Parse error
11:13:54 <mmorrow> @let color_of nick = let rcolors = [19, 20, 22, 24, 25, 26, 27, 28, 29]; n = sum (fmap (max 255 . ord) nick) in rcolors !! (n `mod` length rcolors)
11:13:56 <lambdabot>  Defined.
11:14:06 <mmorrow> > color_of "mmorrow"
11:14:08 <lambdabot>   24
11:14:12 <mmorrow> is red i guess
11:14:31 <mmorrow> > color_of "lambdabot" -- blue
11:14:33 <lambdabot>   19
11:14:55 <jmcarthur_work> that's not how mine does is
11:15:02 <jmcarthur_work> mmorrow, is green for me
11:15:07 <mmorrow> hmm
11:15:15 <jmcarthur_work> err "mmorrow" is green for me, that is
11:15:18 <mmorrow> this is the code for xchat 2.8, maybe it changed ?
11:15:33 <jmcarthur_work> 2.8.6
11:15:41 <mmorrow> or maybe the colors assoc with those ints in rcolors are dependent on settings
11:15:46 <mmorrow> hmm
11:16:22 <mmorrow> odd, this is the code for 2.8.6
11:16:34 <mmorrow> maybe gwern's xchat is different then
11:17:02 <mmorrow> well, therp is the same color as lambdabot in mine
11:17:05 <mmorrow> testing..
11:17:11 <mmorrow> > color_of "lambdabot"
11:17:13 <lambdabot>   19
11:17:14 <mmorrow> > color_of "therp"
11:17:16 <lambdabot>   27
11:17:18 <mmorrow> gah!
11:17:22 <jmcarthur_work> lambdabot is blue for me
11:17:23 <mmorrow> this must not the the code
11:17:27 <mmorrow> yeah. blue for me too
11:17:34 <mmorrow> is therp the same color?
11:17:57 <jmcarthur_work> same blue for me
11:18:12 <mmorrow> > color_of "jmcarthur_work" == color_of "skorpan"
11:18:14 <lambdabot>   False
11:18:26 <mmorrow> dang, this must not be the right code snippet
11:18:45 <skorpan> what
11:19:03 <mmorrow> sry, just checking if i really did find the right code from xchat that colors nicks
11:19:13 <skorpan> what
11:19:18 <mmorrow> yes
11:19:23 <mmorrow> oh wait, no
11:19:32 <jmcarthur_work> am i red?
11:19:35 <mmorrow> yesh
11:19:44 <jmcarthur_work> yay, red rocks
11:19:50 <mmorrow> am i red too?
11:19:52 <skorpan> red is the best
11:19:55 <jmcarthur_work> no, you are green
11:20:00 <skorpan> you're all white and fat on my screen
11:20:06 <skorpan> fat white men
11:20:15 <mmorrow> yay
11:20:42 <jmcarthur_work> you are the same green as the "has joined #haskell" messages
11:21:13 <mmorrow> that's mux's color on mine
11:21:20 <mmorrow> > color_of "mux"
11:21:23 <lambdabot>   19
11:21:25 <mmorrow> > color_of "mmorrow"
11:21:27 <lambdabot>   24
11:21:31 <mmorrow> wtf
11:21:40 <jmcarthur_work> yes, same color as mux on mine
11:22:56 <mmorrow> oh, i'm an idiot
11:23:01 <mmorrow> i think i botched color_of
11:23:11 <skorpan> @google botching
11:23:12 <lambdabot> No Result Found.
11:23:15 <skorpan> i see
11:23:31 <mmorrow> @let colorOf nick = let rcolors = [19, 20, 22, 24, 25, 26, 27, 28, 29]; n = sum (fmap (min 255 . ord) nick) in rcolors !! (n `mod` length rcolors)
11:23:33 <lambdabot>  Defined.
11:23:36 <mmorrow> s/max/min/
11:23:38 <mmorrow> ;)
11:23:47 <mmorrow> > color_of "mux" == color_of "mmorrow"
11:23:49 <lambdabot>   False
11:23:51 <mmorrow> :(
11:23:52 <skorpan> > color_of "skorpan"
11:23:54 <lambdabot>   24
11:23:59 <mmorrow> > color_of "mmorrow"
11:24:01 <lambdabot>   24
11:24:03 <skorpan> it's you and me baby, you and me
11:24:03 <mmorrow> oh, gah!
11:24:10 <mmorrow> > colorOf "mux" == colorOf "mmorrow"
11:24:11 <skorpan> > colorOf "skorpan"
11:24:12 <lambdabot>   True
11:24:13 <lambdabot>   20
11:24:14 <mmorrow> woo
11:24:33 <mmorrow> > colorOf "jmcarthur_work" == colorOf "skorpan"
11:24:35 <lambdabot>   True
11:24:52 <mmorrow> @remember xchat colorOf nick = let rcolors = [19, 20, 22, 24, 25, 26, 27, 28, 29]; n = sum (fmap (min 255 . ord) nick) in rcolors !! (n `mod` length rcolors)
11:24:53 <lambdabot> I will never forget.
11:25:21 <troutwine> > colorOf "troutwine"
11:25:24 <lambdabot>   20
11:25:30 <mmorrow> red
11:25:40 <jmcarthur_work> > colorOf "jmcarthur_work"
11:25:42 <lambdabot>   20
11:25:44 <thoughtpolice> > colorOf "thoughtpolice"
11:25:44 <jmcarthur_work> > colorOf "jmcarthur"
11:25:45 <lambdabot>   24
11:25:46 <lambdabot>   25
11:25:55 <conal> how about using 'cycle rcolors' instead of mod ?
11:26:00 <troutwine> mmorrow: Thanks for translating.
11:26:07 <davidL> > colorOf "davidL"
11:26:09 <lambdabot>   22
11:26:26 <jmcarthur_work> yeah these look right
11:26:28 <mmorrow> conal: wouldn't that be as fast or slower though?
11:26:44 <mmorrow> conal: (more haskelly though of course ;)
11:26:46 <conal> mmorrow: slower & more elegant
11:26:49 <mmorrow> heh
11:26:50 <conal> :)
11:26:57 <jmcarthur_work> slow is beautiful!
11:27:02 <jmcarthur_work> you can't see it if it's too fast
11:27:08 <idnar> like trainwreck in slow motion
11:27:12 <conal> there could be a general rewrite rule about !!, mod, and cycle
11:27:24 <jmcarthur_work> that would be pretty awesome
11:27:29 <jmcarthur_work> and specific
11:27:31 <mmorrow> yeah, that would
11:27:35 <mmorrow> (awesome that is)
11:27:53 <mmorrow> (well, specific too)
11:27:59 <jmcarthur_work> we need a gigantic collection of specific rewrite rules
11:29:19 <idnar> or a compiler good enough that we don't need them anymore ;)
11:29:40 <jmcarthur_work> would have a be a pretty ingenious compiler
11:29:54 <mmorrow> wouldn't the compiler be doing them in that case?
11:30:13 <jmcarthur_work> mmorrow, i think the suggestion was a compiler that can infer the rewrite rules themselves
11:30:25 * ski . o O ( one rule to rewrite them all )
11:30:26 <idnar> I think mmorrow has a point
11:30:51 <jmcarthur_work> maybe i misunderstood after all though
11:31:18 <mmorrow> i didn't think of the inferring them bit, i wonder if that's possible in the general case
11:31:45 <mmorrow> (or even i wonder what the definition of "the general case" is)
11:32:49 <Taejo> @pl rawSystemExit cmd args = exitWith =<< rawSystem cmd args
11:32:50 <lambdabot> rawSystemExit = ((exitWith =<<) .) . rawSystem
11:34:42 <gwern> heck, we just need people to submit all the rewrite rules they discover
11:35:19 <jmcarthur_work> i don't suppose it is possible to create a library of rewrite rules...
11:35:21 <gwern> although come to think of it, how would rewrite rules work with hugs et al...
11:35:28 <mmorrow> > colorOf "gwern" == colorOf "lambdabot"
11:35:30 <lambdabot>   True
11:35:41 <gwern> jmcarthur_work: my understanding was that rewrite rules had to be in the module on which they act
11:35:48 <gwern> oh noes! my secret identity has been discovered!
11:35:50 <jmcarthur_work> gwern, yeah that is what i thought
11:38:45 <sjanssen> gwern: they're implicitly exported by the module they're defined in, much like instances
11:39:34 <gwern> sjanssen: hm. so one could have a RewriteModule which imports a bunch of modules like Data.List, and defines rules; then to use the rules, one could import RewriteModule?
11:40:38 <jmcarthur_work> would be cool to start a project for that or something
11:40:45 <gwern> that actually might make a sensible package. you could have Control.Rewrite and Control.Rewrite.Unsafe, and go back through the last 5 years of #haskell and grab all the suggested rewrite rules, putting the ones that break laziness etc into Unsafe
11:40:47 <jmcarthur_work> if possible
11:40:51 <sjanssen> gwern: yes
11:41:00 <gwern> although I don't see who would use it...
11:41:08 <jmcarthur_work> who wouldn't?@! :P
11:41:33 <sjanssen> gwern: OTOH, everyone that uses a module that uses the unsafe rules will also be forced to use the rules
11:42:08 <gwern> hm, but that's already an issue with instances for type classes, no? nothing stops one from putting evil things in instances
11:42:15 <gwern> to say nothing of merely unsafe definitions
11:43:10 <gwern> jmcarthur_work: well, it'd be an extra dep; it'd be an extra import in every module; you'd have to remember it in the first place; and who would bother if they didn't already know that they needed it? and if they need it, they only need a few or one rewrite rule, so wouldn't it be simpler & more reliable to just define the rule themselves?
11:44:03 <mmorrow> gwern: taking that argument to scale, wouldn't it just be simpler to define the part of Data.List you need in every module?
11:44:13 <jmcarthur_work> gwern, "it'd be an extra import in every module" ... not if what sjanssen says is true
11:44:35 <mmorrow> ah yeah, that's true too
11:44:48 <gwern> jmcarthur_work: if I have a library with modules foo bar baz, and they aren't importing any common module quux, then wouldn't there need to be three imports in foo bar baz?
11:45:03 <mmorrow> yes
11:46:04 <sjanssen> gwern: the nefarious thing about the rules is that you won't know whether you're using them
11:46:11 <gwern> (not all libraries or executables have a nice pyramidal structure, after all; even in the ideal case, you still need one dep and one import)
11:46:20 <sjanssen> at least with instances you have to use the type the instance is defined on
11:46:34 <jmcarthur_work> gwern, right, but it still holds that you wouldn't have to import it in _every_ module you might want it in
11:46:42 <sjanssen> gwern: also, I can't think of any packages filled with broken instances
11:46:48 <jmcarthur_work> in fact, unsafe rewrite rules shouldn't even exist, really
11:47:14 <mmorrow> sjanssen: i think that's no more or less nefarious than using a function imported from another module
11:47:20 <gwern> jmcarthur_work: it's easy to think of rewrite rules which are efficient and look good, but have different laziness properties
11:47:25 <gwern> that's unsafe
11:47:37 <mmorrow> let myId a = unsafePerformIO asplode `seq` a
11:47:44 <sjanssen> mmorrow: rewrite rules or instances?
11:47:51 <mmorrow> sjanssen: either
11:47:58 <sjanssen> mmorrow: the rewrite rules are silent, and can rewrite anything
11:48:00 <gwern> but it's unsafe like head is unsafe; maybe in your usage of whatever function is being rewritten, the differing strictnesses don't matter
11:48:15 <mmorrow> sjanssen: as is using unsafePerformIO
11:48:23 <gwern> we don't ban head, but use it carefully; so this is why I would segregate between safe rewrite rules and unsafe ones
11:48:28 <gwern> let the user bear the proof burden
11:48:44 <gwern> that said, I think it would really be best to just incorporate the safe rewrite rules into base
11:49:09 <sjanssen> mmorrow: once one discovers that myId is broken, you can stop using it
11:49:40 <sjanssen> mmorrow: but you can't really stop using the rewrite rules on an ala carte basis
11:49:51 <mmorrow> sjanssen: well, instances have the same situation
11:50:05 <Phillemann> Is there a reason the Reader monad has the functions "ask" and the State monad has the function "get"? It makes refactoring harder.
11:50:24 <sjanssen> mmorrow: so do we agree that rules and instances are more of a problem than functions?
11:50:49 <mmorrow> sjanssen: as long as we equate the problems of rewrite rules with those of instances, i agree :)
11:51:20 <mmorrow> but i don't think rewrite rules are more problematic than instances, just that they have slightly different problems (and some the same)
11:51:56 <sjanssen> I think one can do more easily do more broken things with rules than with instances
11:52:17 <mmorrow> if we're talking by accident, then maybe
11:52:19 <gwern> you can make compilation loop with rules
11:52:23 <gwern> that was fun
11:52:30 <sjanssen> mmorrow: intentionally true
11:52:42 <gwern> maybe you could make instances loop or error compilation with TH?
11:52:52 <mmorrow> you can do IO with TH..
11:52:56 <sjanssen> instances can't overlap, which is a saving grace
11:53:13 <jmcarthur_work> Phillemann, you mean you want class MonadReader m => MonadState m where ... ?
11:53:15 <sjanssen> it's not like you can override Eq on Int (you can with rules)
11:53:31 <mmorrow> ooh, yeah the interaction of rewrite rules that don't know about each other could *really* be problematic
11:53:37 <mmorrow> that's truue
11:54:29 <mmorrow> you could have two rules that mutually undo the other
11:54:33 <mmorrow> and loop forever
11:54:35 <mmorrow> (i think)
11:54:42 <sjanssen> yes
11:55:01 <gwern> mmorrow: oh, looping rules is easier than that
11:55:20 <mmorrow> gwern: sure, but i'm assuming that rules that know about each other are non-looping
11:55:41 <mmorrow> but rules that don't know about other groups of rules could be doom
11:55:42 <jmcarthur_work> > colorOf "hate" == colorOf "java"
11:55:44 <lambdabot>   True
11:55:47 <gwern> dons wrote a fun blog post on implementing type classes using rewrite rules; he includes an example of a looping rule, which represents a used but unimplemented type class
11:55:47 <mmorrow> heh
11:56:07 <mmorrow> gwern: ah yeah, that was a neat post
11:56:38 <mmorrow> s/non-looping/non-looping by accident/
11:56:40 <gwern> (ghc not terminating represents an error, since that was the closest I could think of)
11:58:16 <mmorrow> sjanssen: ok, i take back that rules aren't more problematic than instances
11:59:21 <jmcarthur_work> on this note, is it _ever_ safe to use rules?
11:59:34 <jmcarthur_work> guaranteed, i mean
12:00:47 <gwern> guaranteed? well, I suppose the rewrite rules already packaged are guaranteed by the full faith and credit of GHC HQ...
12:00:49 <thoughtpolice> well, rules aren't checked by the compiler or anything really
12:01:07 <thoughtpolice> as long as the types work out you can have nonsensical rules like 'f = f' which will throw the compiler for a loop
12:01:15 <mmorrow> jmcarthur_work: they don't have to be confluent, so i guess no
12:01:35 <mmorrow> so just like instance + UndecidableInstances
12:01:43 <thoughtpolice> so, you have to prove yourself that e.g. 'map f (map g xs)' indeed == 'map (f . g) xs'
12:02:03 <jmcarthur_work> i just mean... is it possible to have a set of guidelines which guarantees that your rules will never conflict with somebody else's rules?
12:02:11 <thoughtpolice> mmorrow: well, UndecidableInstances does have a limit on recursion
12:02:13 <thoughtpolice> AFAIK, rules don't
12:02:19 <thoughtpolice> so GHC will simply loop forever
12:03:06 <thoughtpolice> jmcarthur_work: you'd need to guarantee that yourself, luckily you can control at what phase rules 'fire', so you have a bit more control over when your rules happen as opposed to some other rules
12:03:14 <thoughtpolice> but again GHC really doesn't make any guarantees whatsoever
12:04:35 <thoughtpolice> jmcarthur_work: might be better to consult #ghc for questions like that :)
12:06:01 <mmorrow> thoughtpolice: true, but you can still loop other ways
12:07:14 <mmorrow> the limit's on the depth of the context-reduction stack
12:07:42 <sjanssen> jmcarthur_work: one could construct a set of guidelines to ensure termination of rules
12:07:59 <sjanssen> eg. rules in a package must only involve identifiers defined in that package
12:08:07 <sjanssen> very restrictive, but should work
12:08:37 <sjanssen> or: rules may involve any identifiers on the LHS, but only identifiers defined in the package on the RHS
12:09:45 <EvilTerran> sjanssen, surely it's more important that rules only match something involving the idents in the package on the left than on the right?
12:10:16 <EvilTerran> in the interests of preventing collisions, anyway; i don't know which'd contribute more to ensuring termination
12:11:11 <sjanssen> EvilTerran: I think that would also ensure termination
12:11:52 <mmorrow> here's a simple way to loop with UndecidableInstances http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6061#a6061
12:12:05 <EvilTerran> sjanssen, how would either guideline prevent "foo = foo"?
12:12:50 <mmorrow> EvilTerran: i'd call that a malicious rule though, rather than a benign one that when combined with another benign on becomes a looping pair
12:13:01 <sjanssen> EvilTerran: you'd also have the requirement that rules in a package are consistent by themselves
12:13:04 <sjanssen> of course
12:13:09 <mmorrow> and malicious rules are in the same boat as malicious functions in my book
12:13:26 <Taejo> anybody else wondering why this year's ICFP contest starts 16 seconds past the hour?
12:13:28 <EvilTerran> ah, of course
12:14:02 <EvilTerran> mmorrow, the "you'll get what's coming to you" boat?
12:14:17 <jmcarthur_work> does it normally start exactly on the hour?
12:14:30 * sjanssen publishes a package with {-# RULES liftM = error "liftM: segmentation fault\ntry fmap instead" #-}
12:14:33 <jmcarthur_work> i wonder if the contest has something to do with time?
12:14:49 <Taejo> jmcarthur_work: as far as I remember, it started on the hour the past two years
12:14:51 <mmorrow> EvilTerran: the "halting problem boat" ;)
12:14:52 <sjanssen> along with any other functions and use patterns he dislikes
12:15:11 <mmorrow> EvilTerran: well, actually in the malicious case, then "nothing you can do about it" boat
12:15:15 <mmorrow> s/then/the/
12:15:39 <mmorrow> @quote RULES
12:15:40 <lambdabot> monochrom says: Time flies like an arrow.  Fruit flies like a banana.  Syntax rules like a macro.
12:15:42 <mmorrow> @quote RULES
12:15:43 <lambdabot> ##C++ says: [asking about C++ rules] vincenz: how should we know what those rules mean ?
12:15:48 <mmorrow> @quote breathing
12:15:49 <lambdabot> mmorrow says: {-# RULES "HAI; CAN HAS STDIO?"  id = unsafePerformIO (system "killall -9 breathingMachine && xeyes &" >> return id)  #-}
12:16:00 <EvilTerran> either way, it's the failboat
12:16:29 <EvilTerran> ...
12:16:32 <skorpan> xeyev
12:16:35 <skorpan> oops
12:16:41 <skorpan> typo + this is not a terminal
12:16:53 <mmorrow> heh, "OH HAI, I CAN SEE U!"
12:16:55 <Jebdm> is it possible to define a data type on the fly?  i'm writing a parser for an experimental markup language, and i'm hoping to be able to define simple structured data types within the markup
12:17:06 <Jebdm> i'm guessing it's not possible without resorting to ugly things
12:17:16 <skorpan> cool i just realized xeyes is transparent
12:17:46 * mmorrow has a mini "geyes" widget on his gnome-panel
12:17:46 <sjanssen> not actually, it uses xshape to be non-rectangular
12:18:10 <skorpan> that's what i meant :)
12:18:47 <mmorrow> this is a fun one:
12:18:49 <mmorrow> while [[ true ]]; do xeyes & done
12:18:50 <EvilTerran> Jebdm, in haskell, types are (almost) entirely compile-time only, so no
12:19:11 <mmorrow> (i'm not responsible if anyone actually runs that :)
12:19:13 <Jebdm> yeah, that's what i thought
12:19:28 <Jebdm> just hoping there was a magic function stashed away somewhere
12:19:36 <EvilTerran> > unwords $ repeat "O.o o.O"
12:19:38 <lambdabot>   "O.o o.O O.o o.O O.o o.O O.o o.O O.o o.O O.o o.O O.o o.O O.o o.O O.o o.O O....
12:20:03 <Jebdm> i guess i'll just reimplement a type system
12:20:17 * mmorrow is furiously typing killall -9 xeyes ^C^C^C
12:20:26 <Jebdm> and by that, i mean be lazy and do it as nested maps
12:20:41 <skorpan> > let n = 5 in concat [replicate n "(-_", "(-_-)", replicate n "_-)"]
12:20:43 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
12:20:46 <EvilTerran> Jebdm, unfortunately, that seems to be the way that sort of thing tends to be done in haskell
12:20:55 <skorpan> > let n = 5 in concat [replicate n "(-_", ["(-_-)"], replicate n "_-)"]
12:20:57 <lambdabot>   ["(-_","(-_","(-_","(-_","(-_","(-_-)","_-)","_-)","_-)","_-)","_-)"]
12:21:03 <skorpan> > let n = 5 in concat $ concat [replicate n "(-_", ["(-_-)"], replicate n "_-)"]
12:21:05 <lambdabot>   "(-_(-_(-_(-_(-_(-_-)_-)_-)_-)_-)_-)"
12:21:14 <mmorrow> it's like that one indian baby
12:21:21 <EvilTerran> Jebdm, well, that or using ghc-api to construct a haskell module on-the-fly
12:21:33 <Jebdm> yeah, that's what i meant by "ugly" ;)
12:22:02 <Jebdm> it's not a big deal, just hoping that haskell had some sort of dynamic features somewhere that i wasn't aware of
12:22:07 <EvilTerran> Jebdm, well, that's not as ugly as "write out a .hs file, use a system call to compile it, and then dynamic link it" would be :P
12:22:30 <Jebdm> very true, very true
12:22:52 * mmorrow wants to eventually be able to generate machine code, write it directly to memory, then link in-mem
12:22:52 <Jebdm> if i was going to resort to that, i'd just switch to scheme or python or something ;)
12:23:09 <mmorrow> *that* would be elegant x2
12:23:25 <EvilTerran> mmorrow, er, i believe you can already do runtime bytecode generation in haskell
12:23:32 <mmorrow> EvilTerran: hard code
12:23:39 <Taejo> mmorrow: you mean generate machine code *from Haskell* code? otherwise, there's always harpy
12:23:50 <mmorrow> Taejo: yes, and not only on x86
12:24:11 <mmorrow> and then there's the whole linking bit..
12:25:35 <Jebdm> mmorrow: unfortunately, there seems to be very little language support for that kind of thing
12:25:37 <EvilTerran> ah
12:25:37 * EvilTerran was thinking of harpy
12:25:38 <Jebdm> even in C, it's a fugly hack
12:25:44 <sjanssen> mmorrow: there's something even more fun than xeyes: blast
12:25:52 <skorpan> as if everything in C isn't an ugly hack
12:25:59 <Twey> Haha
12:26:01 <sjanssen> (don't shoot any important windows)
12:26:18 <EvilTerran> ?remember skorpan as if everything in C isn't an ugly hack
12:26:18 <lambdabot> Done.
12:27:08 <Twey> sjanssen: I can't find this :-\  What package is it commonly distributed with?
12:28:00 <mmorrow> Jebdm: totally, which is why i'll have to write it ;)
12:28:02 <sjanssen> Twey: the package is called 'blast' in Debian
12:28:31 <skorpan> sjanssen: is it graphical?  i.e. does it show me the blast?
12:28:44 * mmorrow does $ sudo yum list *blast*
12:28:47 <mmorrow> oops
12:28:51 <mmorrow> s/list/install -y/
12:28:53 <Twey> Hmn.  I can't find it in AUR.
12:29:09 <trofi> xkill
12:29:22 <Jebdm> mmorrow: it's actually one of the features i plan to include in my dream language
12:29:25 <sjanssen> skorpan: it will set your pointer to crosshairs, the effect is obvious once you start clicking
12:29:34 <mmorrow> Jebdm: heh, me too.
12:29:42 <skorpan> Twey: i can't either
12:30:22 <Jebdm> mmorrow: unfortunately, my dream language is still a bit beyond me to implement at this point.  someday, though
12:32:01 * mmorrow 's first xblast attempt ends in
12:32:02 <mmorrow> Segmentation fault
12:32:05 <mmorrow> :)
12:32:26 <mmorrow> Jebdm: start haxxing!! :)
12:32:43 <sjanssen> mmorrow: xblast is a different package in Debian
12:32:52 <mmorrow> is blast some sort of game?
12:33:00 <mmorrow> oh, maybe i have the wrong thing
12:33:10 <sjanssen> anyway, blast creates holes in windows when you click on them
12:33:18 <skorpan> oh
12:33:21 <mmorrow> ahh, yeah i definitely have the wrong thing
12:33:23 <skorpan> i thought it would just kill them
12:33:35 <mmorrow> i understand the name though now
12:33:40 <sjanssen> the fun part is that the hole stay until the window is destroyed
12:34:15 <Jebdm> mmorrow: yeah... luckily, i have a long life ahead of me.  and a thesis, maybe i'll be able to do it for that
12:35:28 <Jebdm> well, hopefully, on both counts ;)
12:47:02 <thomastc> why does Cabal default to building in a directory named 'dist'?
12:47:30 <thomastc> wouldn't 'build' or 'obj' or whatever make more sense?
12:47:33 <Baughn> thomastc: It has to build /somewhere/, and what it builds is meant for distribution
12:47:46 <thomastc> setup-config isn't
12:48:07 <Baughn> Well, no. To be honest, I doubt they gave it much thought.
12:48:08 <thomastc> nor are the o or hi files
12:48:25 <Baughn> The .hi files are
12:48:34 <thomastc> hmm ok
12:48:48 <Baughn> ..so, apparently, are the .o files. Hm.
12:49:10 <FunctorSalad> usually it's just the cabal sdist tarball, isn't it
12:49:13 <Baughn> Cabal /both/ installs a .a and all the .o files it cotains, apparently
12:49:48 <FunctorSalad> oh, "distribution" as in local copying :)
12:52:43 <mmorrow> jeffersonheard: ping
12:56:34 <BenBlade> I JUST SAW HALEYS COMET
12:56:37 <edwardk> @seen sjoerd_visscher
12:56:38 <lambdabot> sjoerd_visscher is in #haskell and #haskell-in-depth. I don't know when sjoerd_visscher last spoke.
12:56:49 <mauke> preflex: seen sjoerd_visscher
12:56:50 <preflex>  sjoerd_visscher was last seen on #haskell 1 day, 11 hours, 49 minutes and 8 seconds ago, saying: Better Ctrl-A Delete it then
12:57:15 <edwardk> hrmm [15:35] == sjoerd_visscher [n=sjoerd@5356DCAF.cable.casema.nl] has joined #haskell
12:57:37 <edwardk> mmorrow: is preflex slipping? =)
12:57:48 <mauke> hmm?
12:58:22 <edwardk> mauke: well, scrollback found him a half hour ago, but preflex sees him a day and a half ago
12:58:34 <mauke> joins don't count
12:58:38 <edwardk> ah
12:59:35 * EvilTerran disconnects and rejoins a few times a day while AFK because of his dubious internet connection
13:00:55 <sjoerd_visscher> hi edward
13:06:58 <edwardk> heya sjoerd. i like the monoid-based list stuff you've been looking at. did you see the random comment i left on reddit about it though? the only concern i had was that a monoid instance that violates its laws can disambiguate between different representations of the same list
13:07:21 <gwern> @quote laws
13:07:22 <lambdabot> lament says: three laws of robotics: 1) don't do anything unless you ABSOLUTELY HAVE TO 2) ...other laws to be written as they become required
13:07:29 <gwern> @quote laws
13:07:29 <lambdabot> monochrom says: The Three Laws of Types. (1) Must protect programmer. (2) Must obey programmer, when not in conflict with (1). (3) Must protect computer, when not in conflict with (1) or (2).
13:07:33 <gwern> @quote laws
13:07:34 <lambdabot> monochrom says: The Three Laws of Types. (1) Must protect programmer. (2) Must obey programmer, when not in conflict with (1). (3) Must protect computer, when not in conflict with (1) or (2).
13:07:37 <gwern> hm.
13:07:42 <gwern> @quote bad.*monad
13:07:42 <lambdabot> Daveman says: Cale, what if I don't want to obey the laws?  Do they throw me in jail with the other bad monads?
13:08:14 <jmcarthur_work> edwardk, is worrying about instances that don't follow the appropriate laws really something that matters?
13:08:15 <sjoerd_visscher> edwardk, no, i haven't read reddit lately
13:08:43 <edwardk> sjoerd_visscher: the other thing is there are some other interesting combinators that fit into that type, because you can write parallel processing FMLists as well. In fact thats basically the tagless version of my 'Free Generator' in the monoids lib
13:08:47 <sjoerd_visscher> edwardk, it looks like Sebastian Fischer actualy did just that, see haskell-cafe
13:09:21 <edwardk> oh nice
13:09:45 <jmcarthur_work> heh, yeah i had read the -cafe email and i was like "what, wait, that wasn't edward!"
13:11:50 <edwardk> I have a container that works kind of like this that i define in terms of a Reducer, which is basically a monoid with optimized snoc and cons.
13:13:23 <edwardk> a (c `Reducer` m) states Monoid m, and provides unit :: c -> m, cons :: c -> m -> m, and snoc :: m -> c -> m -- the latter two can be used for more efficient foldl' and foldr traversals with the monoid
13:14:03 <edwardk> i've been using those two consume various container types, because then the container can be smart enough to pick out an optimized traversal
13:15:15 <sjoerd_visscher> how does flatten, or >>=, work in that case?
13:17:29 <edwardk> Well you have a Monoid instance for m. The free generator can cheat and use the Self monoid where m `Reducer` Self m  holds, which is just a newtype, but in practice my containers know how to map before applying a reducer.
13:18:37 <edwardk> hrmm, the version online is apparently my old tagged version. i need to upgrade the version of monoids on hackage.
13:19:01 <edwardk> http://comonad.com/haskell/monoids/dist/doc/html/monoids/src/Data-Generator-Free.html is the old tagged version. its a lot nicer just using the functional form (though, it can optimize less)
13:20:04 <Athas> Does anyone here have experience with writing literate Haskell programs?
13:21:40 <edwardk> athas: yeah, but i ultimately reverted to the other approach ;)
13:22:21 <sjoerd_visscher> I'm still not sure if FMLists can do anything interesting performance-wise besides what DLists already can.
13:22:32 <Athas> edwardk: why?  And which tools did you use?
13:22:51 <Athas> I really want to keep using Cabal and such, so Noweb appears out.  Did you just write pure LaTeX?
13:23:24 <edwardk> athas: i tried the latex approach, which is ok, but in general i find that haddock is the more accepted documentation format in the community
13:24:00 <Athas> Well, I don't see literate programming as a documentation tool anyway.
13:24:12 <edwardk> sjoerd_visscher: well, the answer i think comes down to parallelizing chunks. you could define a difference list that did it but its not natural
13:24:18 <maltem> Athas, I've found lhs to be better suited for tutorials/papers/... than for libraries
13:24:28 <edwardk> yeah
13:24:44 <edwardk> if i'm writing a paper i'll write it as a literate haskell document
13:24:52 <dons> nice experience report parallelising a ray tracer as a beginner exercise, http://www.reddit.com/r/programming/comments/8u02d/experience_writing_and_parallelizing_a_ray_tracer/
13:25:07 <maltem> lhs2tex is a good tool for literate (or not so literate) papers, btw
13:25:09 <Athas> Yes, I expect I will find it to be somewhat unwieldy for libraries, but I don't like passing such a judgement without concrete evidence, so I want to write a nontrivial program in Literate Haskell.
13:26:25 <edwardk> sjoerd_visscher: er actually i stand corrected, you can't really define a difference list that runs monoidal reductions in parallel
13:26:26 <maltem> Athas, good luck! I don't have personal experience either, but the ghc and darcs source codes include a lot of "we wanted to do this literately once upon a time" artifacts
13:26:45 <edwardk> sjoerd_visscher: so there is basically your first use case. its the same as for why i defined my Generators
13:29:22 <Athas> maltem: I suspect it is useful for programs (or libraries) that you don't expect much continual development on.
13:29:50 <Athas> In my case, I want to produce a complete replicate of my prefered window manager, but I wonder if literate programming might be useful for implementing (static) specifications too.
13:31:07 <edwardk> Heh it'd be somewhat silly for me to write a copy of my preferred window manager in Haskell, since it was written in Haskell to begin with ;)
13:31:34 <dons> we already have the perfect window manager though
13:31:40 <edwardk> =)
13:32:46 <edwardk> sjoerd_visscher: hrmm i can't seem to find the sebastian fischer post you were talking about
13:33:07 <edwardk> i found a couple of comments from him about fmlist mentioning the tree lib that he has is that what you meant?
13:34:14 <sjoerd_visscher> yes
13:34:33 <skorpan> parsec is so awesome
13:34:47 <sjoerd_visscher> he uses fmlist as a tree structure with monoids that don't follow the monoid laws
13:37:24 <edwardk> hrmm. maybe i'm being dense. i'm not seeing the violation of the monoid law yet
13:38:01 <sjoerd_visscher> http://hackage.haskell.org/packages/archive/level-monad/0.4/doc/html/src/Control-Monad-Levels.html
13:38:26 <sjoerd_visscher> Levels is not a Monoid
13:39:02 <sjoerd_visscher> mempty `mappend` a = Levels (empty : levels a), instead of Levels (levels a)
13:39:13 <edwardk> yeah
13:39:40 <edwardk> ugly but er... ok
13:40:14 <sjoerd_visscher> I think he shouldn't use FMList
13:40:19 <edwardk> i agree
13:40:36 <edwardk> borrowing the idea is fine, but the typeclass used is wrong
13:41:26 <edwardk> heck you can replace the monoid constraint with the individual method signatures for mempty and mappend, so its just a church encoding and i wouldn't cry foul either
13:42:59 <Apocalisp> @src nub
13:43:00 <lambdabot> nub = nubBy (==)
13:43:04 <Apocalisp> @src nubBy
13:43:04 <lambdabot> nubBy eq []             =  []
13:43:04 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
13:43:54 <Apocalisp> what's a faster way to do this?
13:44:18 <mauke> Set.toList . Set.fromList
13:44:24 <Apocalisp> ah yes
13:44:27 <Apocalisp> good deal
13:44:58 <mauke> map head . group . sort
13:45:15 <Apocalisp> yes, that's the one I was thinking of
13:48:39 <Heffalump> can anyone point me at a description of how the non-threaded RTS implements the IO operations that block in the thread they are run from but don't block other threads?
13:50:11 <SamB> Heffalump: doesn't it use select?
13:51:03 <Heffalump> SamB: yes, I believe so
13:51:23 <Heffalump> sorry, I wanted rather more detail, like what operations it is supposed to work for etc.
13:51:43 <Heffalump> (I have a test program that it seems to have stopped working for between ghc 6.6 and ghc 6.8)
13:55:46 <Botje> ehh
13:56:08 <Botje> can i do something about cabal install containers taking up 100% cpu and exiting with an outof memory error?
13:56:28 <byorgey> Botje: what version of ghc and what version of cabal?
13:56:46 <Heffalump> Botje: use an older version of ghc to update to a newer version of cabal
13:56:56 <Botje> ghc 6.10.3 and cabal 0.5.1, using cabal 1.4.0.1
13:57:00 <Botje> okay, i'll try that, thanks
13:57:23 <Heffalump> old cabal can't handle the way ghc 6.10 does its base packages
13:57:27 <byorgey> yeah, ISTR some Cabal bug that got fixed
13:57:35 <byorgey> oh, ok, that's it
13:57:55 <Botje> so do i install cabal or cabal-install first?
13:57:58 <Botje> ah
13:58:00 <Botje> neeevermind
13:58:53 <Heffalump> if you just set your path to an older GHC, then do cabal install cabal-install, all should work out
14:12:21 <lpsmith> Ok, I'm noticing a weird performance phenomenon
14:12:35 <lpsmith> I have two functions that compute the same thing
14:13:15 <lpsmith> If I start ghci with the default-sized heap,   they perform about the same
14:13:31 <lpsmith> although one allocates about 3 times the memory,  and is just a tad slower
14:13:57 <lpsmith> but if I increase the size of the heap to 3 GB
14:14:33 <lpsmith> the guy who allocates 1/3 the memory is almost 3 times faster
14:15:11 <lpsmith> GC isn't particularly required in either case...
14:15:28 <Jebdm> code?
14:16:55 <dons> allocating 3G stresses the machine a bit
14:17:02 <dons> try smaller. like 300M
14:17:04 <dons> -H300M
14:17:06 <dons> or -A300M
14:17:12 <dons> and look at the GC stats
14:23:14 <lpsmith> well,  I normally use :set +s... when I use a 3G heap,  they both report 0 bytes GC'ed
14:23:43 <dons> try +RTS -sstderr
14:23:46 <dons> and don't use ghci
14:25:54 <edwardk> have i ever mentioned that i have ieee 854 floating point?
14:28:45 <sjoerd_visscher> how long should you have wait to conclude that the answer is probably "no"?
14:34:41 <FunctorSalad> you "have" it?
14:37:43 <lpsmith> Yeah,  when I go up to about a 1G heap,  it only reports one GC
14:38:14 <FunctorSalad> is there any nice way to deal with binding constructs in embeddded languages?
14:38:23 <lpsmith> Maybe I'm seeing cache effects?
14:38:24 <FunctorSalad> (quantifiers here)
14:38:52 <FunctorSalad> HOAS doesn't really work for me
14:40:33 <Heffalump> FunctorSalad: why not, OOI?
14:40:58 <Heffalump> there's PHOAS (see Adam Chlipala's paper at last year's ICFP) but I don't understand it enough to explain it.
14:41:27 <Heffalump> imo HOAS is the only sane way to do binding in an embedded language, everything else is just too ugly
14:41:45 <mriou> hi, I'm looking for some good ole' Haskell advocacy resource
14:41:56 <mriou> especially around productivity, terseness, defects, etc.
14:42:05 <mriou> any good paper or study?
14:42:33 <dons> mriou: i gave a talk on the use of haskell commercially recently, http://www.galois.com/blog/2009/04/27/engineering-large-projects-in-haskell-a-decade-of-fp-at-galois/
14:43:25 <mriou> dons: do you have some cold, hard numbers in there? :)
14:43:32 <dons> yes.
14:43:40 <dons> no one has done broad studies though, for any language really.
14:43:49 <Alpounet> mriou, if you want, there is an equivalent for OCaml... which makes the advocacy of functional programmiing in general. You can find it on ocaml.janestreet.com
14:44:24 <Alpounet> it's about algebraic datatypes/pattern matching, expressivity of FP languages, etc
14:44:35 <mriou> perfect, thanks a lot, I'll check all of that
14:44:53 <dons> mriou: "Why Functional Programming Matters"
14:45:02 <dons> is the classic 1980s advocacy piece :)
14:45:14 <jmcarthur_work> and i think it's sad that it still even applies
14:45:22 <jmcarthur_work> the world really hasn't progressed
14:45:40 * Twey does the Y.F.P.M. dance
14:46:36 <FunctorSalad> Heffalump: maybe I was doing it wrong... it was various typing issues
14:47:10 <Heffalump> FunctorSalad: you can translate away the HOAS as soon as possible and use explicit binding in your internal representation
14:47:12 <FunctorSalad> do you make the type of atomary terms a parameter?
14:47:31 <FunctorSalad> like "data Term a = Inject a | FunApp String [Term a]"
14:48:04 <conal> FunctorSalad: also check out the very cool paper "de Bruijn notation as a nested datatype"
14:48:15 <FunctorSalad> FWIW I was doing simple FOL
14:48:46 <Heffalump> FunctorSalad: you can, yes
14:48:53 <conal> FunctorSalad: that paper makes programming with (a version of) FOAS manageable.
14:49:09 <Heffalump> there are various possibilities, e.g. using a GADT, using phantom types.
14:49:19 <conal> FunctorSalad: and unbound variables become a type error.
14:49:39 <FunctorSalad> another issue was what the type of a proposition with arbitrarily many binders and free vars should be
14:50:32 <FunctorSalad> you could accumulate the free vars in a type-level list, but that seems pretty complicated
14:50:41 <Heffalump> or just not represent them in the type
14:50:58 <conal> FunctorSalad: the "nested" paper gives an elegant answer to that question.
14:51:11 <FunctorSalad> conal: ok I'll look :)
14:52:06 <dibblego> RayNbow, http://www.reddit.com/r/programming/comments/8tzwu/on_linq_monads_and_the_blindness_of_power/
14:52:54 <FunctorSalad> I also found "Nominal logic, a first order theory of names and binding", but haven't read through it yet.
14:52:57 <Heffalump> conal: it doesn't seem to model free variables in the type
14:53:03 <Heffalump> just bound variables
14:53:17 <Heffalump> (it = the "nested" paper)
14:53:43 <FunctorSalad> but bound variables are free in the body of the binder, no?
14:54:12 <FunctorSalad> (so it seems you need to have a plan for free variables even if you ultimately want closed propositions)
14:54:13 <conal> Heffalump: maybe i don't understand what you mean.  i'd say it does model free variables in the type.
14:55:53 <Heffalump> conal: if it did, then wouldn't the type of abstract be much more complicated?
14:56:14 <Heffalump> since it would have to eliminate a free variable from the type as well as introducing a bound variable
14:57:57 <conal> Heffalump: hm.  i guess not.
14:58:18 <Heffalump> As far as I can see, free variables in the object term are just Haskell free variables
14:58:54 <conal> in the type 'Term v', v is the type for free variables.
14:59:12 <conal> which changes in a Lambda.
14:59:15 <Heffalump> right, but that's different from distinguishing different free variables
14:59:25 <conal> hm?
14:59:35 <conal> think of v as a sum type.
15:00:08 <conal> which it would be in a typed version.
15:00:11 <Heffalump> FunctorSalad: in the body of the binder, bound variables are just references to the relevant binder
15:00:25 <Heffalump> you can't do that without a binder so there's no plan for free variables
15:00:34 <Heffalump> at least not in the type system
15:01:08 <Heffalump> conal: I mean that (x + y) has the same type as (x + x)
15:01:38 <conal> Heffalump: oh!  you mean on whether variable *does* occur freely, not whether it *might* occur freely.
15:01:56 <conal> Heffalump: those terms might have the same type, and might not.
15:02:18 <Heffalump> no, I mean both
15:02:38 <Heffalump> it doesn't distinguish different free variables of the same type in the type of the term containing them.
15:02:56 <Heffalump> can you give an example of the types they would have if they had different types?
15:03:38 <conal> Heffalump: sure.  Term (Succ Zero) vs Term Zero
15:04:01 <conal> (many other possibilities)
15:04:39 <conal> oops -- got ctors & types mixed up there.
15:04:50 <Heffalump> oh, I see
15:04:57 <conal> i mean  Incr () vs Incr (Incr ())
15:05:16 <conal> i forget about ()
15:05:48 <conal> maybe  Incr Void vs Incr (Incr Void)
15:05:49 <Heffalump> no, I don't. Why does the match function in page 10 of that paper need an equality test if variables are identified by their type?
15:06:12 <conal> Heffalump: it doesn't work that way.  have you read the paper?  it's subtle.
15:06:51 <conal> the variables don't have different types.  the types that represent the number of allowed variables.
15:07:05 <skorpan> in parsec 3, how can i express "anything but a newline"?
15:07:45 <FunctorSalad> conal: I was about to confuse Succ and Zero as being on the type level too ;)
15:08:11 <skorpan> (aren't they?)
15:08:39 <FunctorSalad> skorpan: noneOf "\n" ?
15:08:55 <Heffalump> conal: ok, so the type doesn't encode what the free variables are, just how many there are
15:09:08 <conal> FunctorSalad: it's a clever scheme.  for instance, the variable type Incr (Incr Void) contains only the values 0 and 1.
15:09:25 <Heffalump> (no, I hadn't read the paper before so am just dipping into it now, not sure how I missed it in the past)
15:09:32 <skorpan> FunctorSalad: but that's not cross-platform like "newline" is, is it?
15:09:38 <skorpan> no, it can't be
15:09:51 <FunctorSalad> skorpan: forgot about that...
15:10:11 <skorpan> actually
15:10:15 <skorpan> newline = '\n'...
15:10:17 <skorpan> in the source :P
15:10:27 <skorpan> newline             = char '\n'             <?> "new-line"
15:10:36 <conal> FunctorSalad: so Term (Incr (Incr Void)) is statically restricted to having at most two free variables.  de Bruijn notation is tricky to manipulate.  the lovely thing in this paper is giving a systematic, algebraic foundation (maps, folds, monad).
15:10:37 <skorpan> that's kind of stupid though, isn't it?
15:11:22 <watermind> what is the paper?
15:11:35 <conal> Heffalump: (especially considering that the idea came from oege)
15:11:49 <conal> watermind: "de Bruijn notation as a nested datatype"
15:11:56 <Heffalump> it's possible I read it and forgot it, I have a memory like a sieve sometimes
15:11:59 <watermind> thanks conal
15:12:03 <conal> @go "de Bruijn notation as a nested datatype"
15:12:05 <lambdabot> http://citeseer.ist.psu.edu/287061.html
15:12:06 <conal> watermind: :)
15:12:10 <watermind> oh nice :)
15:12:21 <conal> lambdabot++
15:12:36 <conal> note the paper's third author!
15:12:43 <conal> or third & fourth.
15:13:39 <Heffalump> lol
15:13:49 <FunctorSalad> duh, that type is just "Maybe"
15:13:52 * Heffalump is reminded of Rustan Leino's name FAQ
15:17:17 <FunctorSalad> makes a lot of sense so far...
15:52:29 <mmorrow> the friggin hash function in the elf spec collides on these two inputs:
15:52:31 <mmorrow> "(,,)" "(,,,,,,,,,,,,,,)"
15:52:35 <mmorrow> grrrr
15:53:29 <skorpan> you just ruined a perfect opportunity to ",..."
15:54:22 * mmorrow gets a hash function that doesn't suck
15:55:53 <mmorrow> actually, /me just uses a trie
15:58:25 <FunctorSalad> conal: apparently the translator (from plain syntax) will have to return an existential type since you can't know how many layers of Incr there will be?
15:59:14 <uzytkownik> Is is possible to use linker script with ghc?
15:59:48 <FunctorSalad> (I haven't finished the paper yet, sorry if it is covered :))
16:00:29 <conal> FunctorSalad: do you want to allow any unbound variables in your overall term?
16:00:39 <FunctorSalad> conal: yes
16:00:50 <conal> FunctorSalad: oh.  hm.
16:01:12 <conal> FunctorSalad: i generally work with closed terms.
16:01:41 <conal> FunctorSalad: maybe you can avoid non-closed terms.
16:02:05 <FunctorSalad> hmm
16:02:09 <mmorrow> uzytkownik: ghc's linker doesn't understand linker scripts
16:02:22 <FunctorSalad> conal: what would be the type with closed terms?
16:02:39 <conal> FunctorSalad: Term Void (not sure about the choice of Void)
16:02:51 <conal> FunctorSalad: where Void has no elements.
16:04:29 <uzytkownik> mmorrow: Thanks.
16:05:04 <FunctorSalad> conal: hmm I think I confused something. the Incr nesting increases inwards... so there is no problem on the return type (outermost layer) after all?
16:05:49 <FunctorSalad> maybe I'll need a typeclass for "any number of Incr's applied to some base type V"
16:06:55 <conal> FunctorSalad: if you really want unbound variables, you could use something like 'Term String'.
16:07:24 <conal> FunctorSalad: then the bound variables would have de Bruijn indices, and the unbound variables would have names
16:07:52 <conal> using Void instead of String forbids unbound variables.
16:08:13 <FunctorSalad> conal: yes. I think I'll have to keep names for the bound variables too - for printing, but they'll have "no power" :)
16:08:48 <conal> FunctorSalad: i generate names for the bound variables: a, b, ..., z, aa, ab, ...
16:09:16 <FunctorSalad> conal: but maybe the user gave the bound variable a meaningful name
16:09:41 <conal> FunctorSalad: oh, yeah, then keep it and make sure you uniquify it before printing.
16:09:52 <FunctorSalad> yep
16:10:03 <conal> FunctorSalad: cool.  what are you up to?
16:11:44 <FunctorSalad> conal: not sure really :) some sort of proof assistant based on category theory (formulated in FOL)
16:11:58 <conal> FunctorSalad: neat.  have fun!
16:12:01 <FunctorSalad> thanks
16:12:24 <giulianoxt> hi guys. anyone knows about toy haskell interpreters for imperative languages?
16:13:17 <conal> giulianoxt: not offhand, but if i were to make one, i'd closely follow a denotational semantics for the imperative language.
16:14:26 <giulianoxt> conal: not entirely sure what you mean. I'm following some papers about these kind of interpreters using monad transformers
16:14:50 <giulianoxt> conal: seems pretty clean so far. but started getting ugly when I deal with some corner cases in the language
16:14:55 <giulianoxt> conal: like type coercion
16:15:48 <conal> giulianoxt: that's nice work.  in fact monads entered functional programming via a modular structuring technique for denotational semantics.
16:16:42 <Alpounet> Will people in here take the ICFP programming contest this year ?
16:17:49 <zeno_> Alpounet: is it irl or online?
16:18:08 <Alpounet> online
16:18:17 <Alpounet> see icfpcontest.org, IIRC
16:18:27 <conal> giulianoxt: i meant i'd define an algebraic type for programs in the imperative language and a non-algebraic type of *meanings* for thos programs, and then i'd write my functional interpreter as a recursive function from programs to meanings.
16:19:06 <zeno_> Alpounet: cool i might try it
16:19:34 <Alpounet> zeno_, it's been quite elitistic, from what I read about it
16:19:38 <Alpounet> so good luck :)
16:20:35 <giulianoxt> conal: What does the non-algebraic type looks like?
16:23:47 <zeno_> thanks, a challenge is fun
16:24:21 <Twey> zeno_: Here, outrun this tortoise...
16:24:38 <conal> giulianoxt: that question is the heart of language design.  it's the most important choice to make and is the single most revealing piece of information about a language.
16:24:56 <burp> > min 1 exp(2) > 0
16:24:58 <lambdabot>   No instance for (GHC.Num.Num (a -> a))
16:24:58 <lambdabot>    arising from the literal `1' at <...
16:25:17 <Twey> > min 1 (exp 2) > 0
16:25:19 <lambdabot>   True
16:25:26 <burp> sure .. lol
16:25:35 <Twey> (of course, because 1 > 0 and exp 2 > 0
16:25:36 <Twey> )
16:25:38 <conal> giulianoxt: e.g., it'll determine strict or non-strict semantics, pure functional vs imperative, sequential vs concurrent.
16:25:44 <hackagebot> haskell-src-exts 0.5.6 - Manipulating Haskell source: abstract syntax, lexer, parser, and pretty-printer (NiklasBroberg)
16:25:57 <giulianoxt> humm
16:27:16 <conal> is there a type-checker/inferrer complement to haskell-src-exts?
16:27:20 <conal> on hackage
16:27:25 <dibblego> is there an EBNF of haskell syntax?
16:35:50 <lispy> dibblego: hmm...did you check the report already?
16:35:57 <lispy> it may be hard to give in EBNF because of the layout rule
16:36:01 <lispy> (I could be wrong)
16:36:41 <lispy> dibblego: http://www.haskell.org/onlinereport/syntax-iso.html
17:24:54 * byorgey wrote a program which reads in a .wav file AND PLAYS IT!  \o/
17:25:24 <conal> byorgey: woot!!
17:25:54 <conal> byorgey: i love that part of getting sound and/or imagery out of code
17:26:21 <byorgey> yeah, me too!  which is why I've started playing around with livecoding.
17:26:52 <byorgey> I'll be generating real-time music in no time, just you wait!! =)
17:27:01 <conal> awesome!
17:27:43 <Alpounet> byorgey, how many LOC ?
17:27:59 <byorgey> Alpounet: 9
17:28:07 <byorgey> including two imports and one blank one =)
17:28:14 <conal> byorgey: show us, please!
17:28:33 <Alpounet> heh, which library/ies do you use ?
17:29:03 <jmcarthur> what's all the fuss about? what did byorgey do?
17:29:09 <jmcarthur> oh n/m
17:29:17 <conal> Alpounet: o ye, of little faith
17:29:21 <jmcarthur> i thought i missed it
17:29:43 <byorgey> Alpounet: right now I'm using hsc3, Rohan Drape's nice bindings to soundcollider
17:30:11 <Alpounet> ok, fine :-)
17:30:16 <Alpounet> conal, why little faith ?
17:30:27 <Alpounet> just wanted to know what's used for really low level stuffs :)
17:30:33 <byorgey> conal: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6070#a6070
17:30:44 <conal> Alpounet: you didn't believe byorgey could do it without libs
17:30:58 <byorgey> well, I probably couldn't =)
17:31:06 <Alpounet> definitely not in 9 lines !
17:31:12 <byorgey> I wouldn't want to, at any rate.
17:31:24 <Alpounet> in more, I would have believed it !
17:31:29 <byorgey> it's actually less than 9 lines, some of the lines were useless =)
17:32:15 <Alpounet> heh looks fine !
17:48:43 <jmcarthur> conal: quick question for you about FRP semantics... are there any semantically meaningful ways that you have thought of to react to events resulting from behaviors? as a running example, let's say we are working on a collision system in a game. how might i model that in Reactive?
17:48:58 <jmcarthur> hmm... maybe it's not a very quick question :)
17:49:25 <jmcarthur> i've given the question a lot of thought and i mostly end up looking for derivatives with respect to time :\
17:49:54 <jmcarthur> not that that is horrible, but i wonder if i am overanalyzing
17:54:09 <jmcarthur> conal: answers for semantic models besides reactive's is also fine
17:54:25 <jmcarthur> i'm just looking for a direction in that regard, if you know of any
17:54:42 <jmcarthur> s/direction/explored ideas/
18:03:11 <PhDP> Why only 9 level of precedence in Haskell ?
18:03:46 <PhDP> Some logical language apparently have 10, and Haskell is generally very flexible...
18:04:38 <Twey> PhDP: There are plans to add more
18:04:43 <Twey> But nine serves us fairly well
18:04:52 <Twey> It's workable, at least
18:05:04 <PhDP> oops, in fact I think there are 10 (0 to 9, 0 included)
18:05:40 <Twey> I don't think 0 can be used, though â€” it's reserved for function application
18:05:47 <PhDP> Actually it's more that I was curious, from a practical standpoint I never had any problem with what we have.
18:06:03 <Twey> Oh no
18:06:04 <Twey> I'm wrong
18:06:22 <Twey> (and I got them backwards)
18:06:37 <Twey> 0 is $, 9 is .
18:06:44 <Twey> Then function application is 10, which is the magic one
18:07:14 <jmcarthur> conal: another idea might be to have a stream of events on a regular clock, snapshot the behavior, and then do whatever tests i want to do then, which would give me my event, but it seems more like an abstraction leak than anything, to me. i shouldn't have to generate these impulses...
18:07:44 <Twey> Heh
18:07:46 <jmcarthur> and it doesn't make for a very decent declarative program
18:08:01 <Twey> I was about to say â€˜hey, that sounds kind of like Reactiveâ€™, then I realised you were talking to conal.
18:08:08 <jmcarthur> Twey: haha
18:08:25 <jmcarthur> Twey: yeah, i'm working on yet another frp library again
18:08:36 <Twey> What's up with the current ones?
18:09:08 <Twey> (I did read up, I just didn't understand your explanation :-P)
18:09:46 <jmcarthur> Twey: well, my questions are not really specific to reactive, although it may help to talk about it in the context of reactive just for concreteness
18:10:13 <jmcarthur> Twey: say i had a bunch of behaviors for objects moving around in a scene
18:10:27 <jmcarthur> Twey: i want to generate events whenever two of them collide
18:10:36 <jmcarthur> Twey: what do i do?
18:11:18 <Twey> I see
18:11:27 <jmcarthur> most of the answers i've come up with either only work for certain cases or have other ugliness
18:11:30 <Twey> You want to generate an event based on previous events
18:11:35 <jmcarthur> no
18:11:42 <Twey> But that screws up the â€˜function of timeâ€™ behaviour?
18:11:42 <jmcarthur> based on continuous signals
18:11:54 <Twey> Ah
18:11:59 <jmcarthur> are you familiar with the basic semantic model of reactive?
18:12:13 <Twey> Only vaguely, I'm afraid
18:12:26 <jmcarthur> at :: Behavior t a -> t -> a
18:12:33 <jmcarthur> occs :: Event t a -> [(t, a)]
18:12:40 <jmcarthur> those are the semantic functions
18:12:49 <jmcarthur> (not real functions, that is)
18:12:54 <Twey> Right
18:13:07 <Twey> Where t is time and a the event type?
18:13:11 <jmcarthur> yeah
18:13:35 <jmcarthur> so what i'm looking for is a semantically meaningful way to express things of the form :: Behavior t a -> Event t b
18:13:41 <conal> jmcarthur: i was afk.  back now.
18:13:53 <Twey> I see
18:13:54 <jmcarthur> conal: hi!
18:14:05 <conal> jmcarthur: yeah.  fran had 'predicate :: Behavior Bool -> Event ()' .
18:14:14 <jmcarthur> conal: i'm sure this is actually a tired subject, but i think some conversation on it couldn't hurt, especially for me :)
18:14:26 <conal> jmcarthur: np.
18:14:43 <jmcarthur> conal: i forget the term for the technique used to do that...
18:14:54 <conal> jmcarthur: interval analysis
18:14:57 <jmcarthur> that's right
18:15:00 <conal> jmcarthur: to implement it, that is.
18:15:19 <conal> jmcarthur: i wasn't able to sort out a meaning for the generalization of type 'Behavior (Maybe a) -> Event a'.  Sticky problem with limits.
18:15:36 <jmcarthur> conal: is such an abstraction meaningful in reactive? (besides in implementation)
18:15:46 <jmcarthur> just to make sure i'm not associating unrelated things
18:15:48 <conal> jmcarthur: yeah.  it's the same semantic model.
18:15:50 <jmcarthur> okay
18:16:21 <conal> jmcarthur: the original fran has single-occurrence events, which i now call "future values".  soon i changed to multi-occurrence events for more declarative programming.
18:16:25 <jmcarthur> conal: i admit, i'm already fuzzy on interval analysis even though it hasn't been that long since i read the paper
18:16:29 <conal> lots of explicit temporal recursion before then.
18:16:53 <jmcarthur> conal: by temporal recursion do you mean explicit recursing over a list of events?
18:17:02 <jmcarthur> or an equivalent
18:17:09 <conal> jmcarthur: yeah.
18:17:14 <conal> (occurrences)
18:17:23 <conal> it was messy.
18:17:28 <jmcarthur> ah, yeah, occurrences in the reactive terminology
18:17:53 <conal> yeah.  sorry about that whole event/occurrence thing.
18:18:16 <jmcarthur> well, EventStream is a lot to type if you are doing it a lot
18:19:03 <conal> yeah
18:19:25 <jmcarthur> conal: well, i apologize for forgetting my research. i'm going to read up on your interval analysis again, now
18:19:36 <mcglk> So, I'm trying out Haskell for the first time this weekend. Anyone feel up to helping an old programmer learn new tricks? :)
18:19:57 <jmcarthur> mcglk: somebody is always willing to help here :)
18:19:59 <conal> mcglk: just jump in with questions, hpastes etc
18:21:18 <conal> jmcarthur: interval analysis has some pretty cool applications.  Also fun is "interval constraints".
18:21:30 <gwern> mcglk: don't listen to them; it's longstanding #haskell policy that this is an offtopic channel and we send ninjas to the homes of anyone with real questions
18:21:42 <gwern> our reputation for being helpful is just dons; he has a strange sense of humor
18:21:50 <Twey> Hahaha
18:21:53 <mcglk> gwern: Oh, CRAP. :)
18:22:05 <jmcarthur> conal: is the _implementation_ applicable to something like reactive?
18:22:18 <gwern> mcglk: don't worry, it's not too late! you didn't actually ask a haskell question, so technically that was OT as well
18:22:27 <jmcarthur> (of interval analysis, that is)
18:22:30 <mcglk> So basically, I'm screwing around trying to learn this, and the way I'm doing it is that I decided to port TREK73 to Haskell. :)
18:22:44 <mcglk> Yes, it's incredibly geeky, but hey, I'm incredibly geeky.
18:23:12 <conal> jmcarthur: not as is.  the simple time functions would have to be replaced.  regular functions are black boxes, while interval functions are grey boxes.
18:23:20 <gwern> grey?
18:23:33 <conal> you give them an interval of input and you get an interval of output.
18:23:43 <mcglk> One of the functions in the program (it was originally BASIC) was DEF FNA(X) = X - INT(X * 2.77778e-03) * 360. Simple enough.
18:23:48 <conal> more informative than regular functions, while still extensional
18:23:49 <mcglk> So this is how I defined it:
18:23:56 <mcglk> modCircle :: Float -> Float
18:23:56 <mcglk> modCircle d = d - 360 * fullCircles
18:23:56 <mcglk>     where fullCircles = floor fracCircles
18:23:56 <mcglk>           fracCircles = (d * 0.00277778)
18:24:41 <mcglk> And I get "No instance for (Integral Float) arising from a use of `floor'" error.
18:25:01 <conal> mcglk: look at the type of floor
18:25:04 <conal> @type floor
18:25:04 <PhDP> And btw, the last stantard is pretty more than 10 years old, is a new standard in the making ? Will it be released in the near future ?
18:25:06 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
18:25:17 <conal> oh, well that's a mouthful for a newbie
18:25:21 <gwern> PhDP: haskell' is an active process, but it's very slow...
18:25:45 <mcglk> Well, okay. Should modCircle be of a different type? Or do I need to cast fracCircles?
18:25:48 <gwern> PhDP: and it'll basically just be canonizing a bunch of ghc extensions, and maybe remove a few things from haskell98 like n+k
18:26:08 <gwern> mcglk: also, you don't need the parens in fracCircles
18:26:33 <conal> jmcarthur: btw, here's a fun paper on application of interval constraints to rendering: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.12.9727
18:26:34 <gwern> > floor (5 * 0.00277778)
18:26:36 <lambdabot>   0
18:26:39 <mcglk> gwern: True, they're redundant. That was just the last experimental attempt I did trying to figure out what was causing the error specifically.
18:26:55 <jmcarthur> conal: thanks!
18:26:58 <gwern> > floor ((5.0::Float) * 0.00277778)
18:26:59 <lambdabot>   0
18:27:23 <gwern> :t ((5.0::Float) * 0.00277778)
18:27:25 <lambdabot> Float
18:27:36 <conal> jmcarthur: :)  see also "Interval Analysis For Computer Graphics": http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.56.7431
18:27:41 <Twey> :t floor $ (5.0 :: Float) * 0.00277778
18:27:43 <lambdabot> forall b. (Integral b) => b
18:27:45 <mcglk> :t (5.0 * 0.00277778)
18:27:47 <lambdabot> forall t. (Fractional t) => t
18:27:47 <conal> jmcarthur: (i'm biased toward graphics apps)
18:27:48 <gwern> (ok, now I'm confused)
18:27:55 <Twey> Float is not an Integral
18:27:59 <Twey> Thus your error
18:28:01 <jmcarthur> i love the haskell community
18:28:15 <Twey> floor returns an integral.  You'd need to cast it back again with fromIntegral.
18:28:15 <Badger> I love Twey
18:28:30 <mcglk> OH.
18:28:30 <Twey> Argh, zombie badger!
18:28:36 <Badger> Twey: When are you going to marry me?
18:28:37 <ray> if you love the haskell community so much why don't you marry it?
18:28:43 <Twey> Hahaha
18:28:47 <gwern> @vixen will you marry ray?
18:28:48 <lambdabot> let me answer that later, okay?
18:28:50 <mcglk> Of course. floor returns an integer. Got it.
18:29:13 <Twey> There's probably a version that returns the same type as was passed in, surely
18:29:44 <jmcarthur> ray: because sometimes i want to go to sleep instead of listen to #haskell talk about zygohistomorphic prepromorphisms
18:29:47 <Twey> Apparently not
18:29:48 <Twey> Odd
18:29:49 <Twey> Oh well
18:29:55 <gwern> @quote zygohisto
18:29:55 <lambdabot> EvilTerran says: [on category theory] the same place of nightmares that spawned zygohistomorphic prepromorphisms :P
18:30:03 <Twey> *grin*
18:30:05 <gwern> @quote zygohisto
18:30:06 <lambdabot> olsner says: nah, SkyNet is just a zygohistomorphic prepromorphism, nothing fancy
18:30:11 <gwern> @quote zygohisto
18:30:12 <lambdabot> olsner says: nah, SkyNet is just a zygohistomorphic prepromorphism, nothing fancy
18:30:14 <gwern> @quote zygohisto
18:30:15 <lambdabot> EvilTerran says: [on category theory] the same place of nightmares that spawned zygohistomorphic prepromorphisms :P
18:30:23 <gwern> (ok, I guess there were just 2)
18:31:23 <mcglk> So. This works, but do you have any stylistic suggestions for me?
18:31:23 <mcglk> modCircle :: Float -> Float
18:31:23 <mcglk> modCircle d = d - 360.0 * fullCircles
18:31:24 <mcglk>     where fullCircles = fromInteger (floor fracCircles)
18:31:24 <mcglk>           fracCircles = (d * 0.00277778)
18:31:36 <Twey> I feel the labels are a tad unneccessary, personally
18:31:53 <Twey> Unnecessary**
18:31:57 <mcglk> Twey: Yeah, they were. Those were just trying to break down where the error was. :)
18:32:01 <Twey> Ah :-P
18:32:14 <mcglk> (And also to make sure I understood the notation.)
18:32:17 <Twey> Then nope, that should be fine.
18:32:21 <gwern> rm the parens as I said; fracCircles itself is probably not clearer than just substituting it in
18:32:49 <Twey> modCircle d = d - 360 * fromInteger . floor $ d * 0.00277778
18:33:17 <mcglk> Ah. What does the $ mean?
18:33:30 <Alpounet> @src ($)
18:33:30 <lambdabot> f $ x = f x
18:33:36 <Twey> It's just low-precedence function application
18:33:43 <Twey> a $ b = (a) (b)
18:33:43 <mcglk> I've seen it in Real World Haskell, but haven't found the explanation.
18:33:48 <mcglk> Ah.
18:34:02 <Alpounet> it lets you remove parens
18:34:09 <mcglk> Gotcha.
18:34:32 <Twey> Oh, I buggered up the precedence, though
18:34:53 <Alpounet> like in f (foo (something*complicated/again)) => f $ foo something*complicated/again
18:35:08 <Twey> modCircle d = d - 360 * (fromInteger . floor $ d * 0.00277778)
18:35:15 <mcglk> Cool. :)
18:35:18 <Twey> You need one set :)
18:35:30 <Twey> (or a series of sections :-P)
18:35:33 <Alpounet> typically, it's useful (for readability) when one of the arguments of a function is the result of another function call
18:35:53 <Twey> Alpounet: That would need to be f . foo $ something * complicated / again
18:35:58 <mcglk> Okay. Off to experiment some more! :)
18:36:24 <Alpounet> Twey, yeah, more useful if f had >= 2 args
18:36:44 <Twey> Function application binds tightly, so yours would be f ((foo something) * complicated / again) instead of f (foo (something * complicated / again))
18:38:51 <Alpounet> oh, true
18:39:23 <zeno_> this is on the page twice : Niklas Broberg: What's in a forall? http://sequence.complete.org/hwn/20090613
18:41:32 <jmcarthur> conal: okay, so interval analysis is essentially binary search over time?
18:41:42 <jmcarthur> as it pertains to frp, of course
18:42:12 <jmcarthur> and in fran there is also a test for intervals not bounded toward the future
18:42:12 <conal> jmcarthur: yeah.  binary search & interval analysis often go together
18:42:31 <gwern> @tell byorgey in http://sequence.complete.org/hwn/20090613 you duplicated http://nibrofun.blogspot.com/2009/06/whats-in-forall.html
18:42:32 <lambdabot> Consider it noted.
18:42:39 <jmcarthur> okay, this makes intuitive sense
18:42:46 <conal> :)
18:43:16 <jmcarthur> it's perhaps a bit more cpu-unfriendly than i wanted, but i guess there probably isn't really a general solution that would get much better
18:43:21 <conal> jmcarthur: there's also affine analysis, which is more complex and converges faster
18:43:34 <jmcarthur> even imperative simulations do similar things i guess
18:43:46 <byorgey> gwern: ah, so I did. whoops.
18:43:46 <lambdabot> byorgey: You have 1 new message. '/msg lambdabot @messages' to read it.
18:44:30 <conal> jmcarthur: nice thing about IA is that it can guarantee absence of solutions (e.g., function zeros)
18:44:51 <jmcarthur> conal: but anyway, what it appears to boil down to is that most event generating behaviors will require some sort of search algorithm?
18:45:12 <conal> jmcarthur: yeah, i think so.
18:46:14 <jmcarthur> conal: okay, i think i have a lot of reading to do... interval analysis, interval constraints (applicable, or just interesting?), and affine analysis
18:46:51 <jmcarthur> conal: thanks a lot! big help
18:47:41 <conal> jmcarthur: interval analysis will be the most help.  affine is theoretically more efficient.  interval constraints is too cool not to mention.  especially if you like constraint-oriented programming.
18:47:49 <jmcarthur> conal: btw, you may not have seen it yet, but i commented on an old blog post where you mentioned an idea for comonadic frp and that you would blog about it later, but i don't think you ever did
18:48:04 <conal> jmcarthur: i replied to that comment.
18:48:11 <jmcarthur> conal: okay, thanks
18:48:30 <conal> jmcarthur: i liked hearing about your interest.  i'd almost forgotten about the idea, and it had me really fired up at the time.
18:48:38 * jmcarthur looks for it again
18:49:32 <conal> jmcarthur: what are you up to these days, and where are you?
18:49:46 <jmcarthur> conal: oh, i _do_ remember seeing those. brain fart i guess
18:49:51 <conal> heh
18:50:32 <conal> hm.  brain fart reminds me of the song "beans in my ears", which my dad played for us kids when we were little.
18:50:50 <conal> arlo guthrie maybe?
18:50:51 <jmcarthur> conal: well, i recently got married, so i had put a lot of stuff on hold. still living in huntsville, al. working for an anti-tamper business. aaaand finally getting back into the fun frp stuff
18:51:32 <conal> jmcarthur: oh, married!  enjoying it?
18:51:58 <conal> oh, pete seeger, not arlo guthrie.
18:52:00 <jmcarthur> oh yes! it's much the same as before, but with somebody else, but it's somebody else that i like a whole lot ;)
18:52:01 <conal> great song.
18:52:21 <jmcarthur> conal: perhaps we should head to -blah if this will continue?
18:52:27 <conal> jmcarthur: awesome.  congrats!  you bet.
19:13:14 <hatds> is there a way to clone a thunk?  Something like let x = y, but no sharing between x and y. I suppose it would have to be low level
19:14:47 <BMeph> Is there some handy-dandy CT term for two functions related gy a variation of a third common component?
19:15:02 <jmcarthur> hatds: sounds like your thoughts are impure
19:15:34 <hatds> jmcarthur: is it impure though?  it is referentially transparent
19:16:04 <jmcarthur> i suppose so, but why would you want to do it except for impure purposes?
19:16:05 <Alpounet> Any idea on this ? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6071#a6071
19:16:11 <hatds> effeciency
19:16:21 <BMeph> My example: fmap == ap . return == (=<<) . (return .). What's the relation between 'ap' and '=<<'?
19:16:24 <roconnor> hatds: GHC does it's utmost to not share things.  If y is the result of a function call, calling it twice will usually give you unshared results.
19:16:40 <roconnor> hatds: not that I know all that much about the issue
19:16:46 <jmcarthur> roconnor: ignoring SEE
19:16:51 <jmcarthur> CSE
19:16:53 <jmcarthur> i meant
19:16:59 <dolio> Of course it's impure. It's not even a sensible question if all you're talking about is values and denotations and such.
19:17:03 <roconnor> jmcarthur: that's my point GHC almost never does CSE.
19:17:07 <hatds> roconnor: but you can't turn a thunk into a constant function which clones the thunk
19:17:22 <roconnor> hatds: I don't think that would work.
19:17:24 <Saizan> hatds: i.e. if you've f :: () -> a, and you do let x = f (); y = f (); it should evaluate it twice.
19:17:59 <roconnor> hatds: how far do you want to unshare the thunks?  Obviously doing one thunk won't gain you much.
19:18:25 <hatds> Saizan: but the idea is you only have the value, not a function
19:18:25 <roconnor> hatds: they will just share some other thunk one level down.
19:18:29 <Saizan> but if you start with z using f () = z doesn't help
19:18:37 <hatds> that's why it would have to be very low level
19:18:43 <Saizan> yup
19:18:53 <jmcarthur> hatds: under what circumstances would this approach be more efficient?
19:18:56 <vininim> lol in this paper, `a' and `b' are use for 5 different domains. Worse to read than type checking errors
19:19:08 <hatds> say ys = really long list, but lazily generated
19:19:21 <Saizan> hatds: that's been discussed a few times here, but noone actually went to implement it :)
19:19:38 <hatds> you want xs = ys but iterating over one of the lists should happen with constant space usage
19:19:47 <roconnor> hatds: then ys =  really long list, but lazily generated; xs =  really long list, but lazily generated
19:20:23 <Saizan> the common use case is mean xs = sum xs / length xs
19:20:25 <hatds> roconnor: sorry, not sure what you are saying
19:20:31 <Saizan> if xs is long you get a space leak
19:20:50 <Saizan> and it doesn't make sense for mean to take two arguments
19:20:59 <roconnor> hatds: copy the definition of the long list twice
19:21:28 <Saizan> (in this case you can actually traverse the list only once and calculate both, but it's less high-level)
19:21:37 <hatds> that means 'ys' can't travel around by itself, it has to travel around as a function which produces ys
19:21:53 <roconnor> hatds: actually, even better is to traverse the list only once, doing both things at the same time
19:22:23 <hatds> what if it is a mapM traversal?
19:22:46 <hatds> or mapM_ more likely
19:23:04 <roconnor> hatds: hmm, you are right.  I that was dumb of me.
19:23:47 <Alpounet> g'night all
19:23:50 <hatds> I'm more curious than anything really
19:24:16 <roconnor> ya, I guess passing around a function producing the ys would work
19:24:29 <roconnor> Something like Reader () foo
19:26:08 <sm> @seen jaredj
19:26:08 <lambdabot> Last time I saw jaredj was when I left ##english, ##freebsd, ##hrg, ##logic, #arch-haskell, #concatenative, #darcs, #dreamlinux-es, #friendly-coders, #functionaljava, #gentoo-haskell, #gentoo-uy, #
19:26:08 <lambdabot> ghc, #haskell, #haskell-blah, #haskell-books, #haskell-freebsd, #haskell-in-depth, #haskell-overflow, #haskell-soc, #haskell.cz, #haskell.de, #haskell.dut, #haskell.es, #haskell.fi, #haskell.fr, #
19:26:08 <lambdabot> haskell.hr, #haskell.it, #haskell.jp, #haskell.no, #haskell.ru, #haskell.se, #haskell_ru, #jhc, #jtiger, #macosx, #macosxdev, #novalang, #perl6, #rosettacode, #scala, #scannedinavian, #unicycling, #
19:26:08 <lambdabot> xmonad and #yi 15d 21h 35m 34s ago.
19:26:21 <sm> woah
19:26:50 <Twey> sm: Spammer!  :-P
19:27:47 <hatds> the question reminds me of "no quantum xerox machine" for some reason
19:44:10 <altmattr> how did I manage this? "`fail' is not a (visible) method of class `Monad'
19:44:27 * altmattr granted it is the first time I have written a monad that needed fail :)
19:45:59 <shachaf> altmattr: Did you import hiding fail or something?
19:46:08 <shachaf> What is the context?
19:46:34 <altmattr> shachaf: well bugger me - you are right
19:46:39 <altmattr> now why did I do that?
19:47:15 * altmattr feels silly
19:51:07 <altmattr> that's why
19:51:08 <altmattr>     Couldn't match expected type `e' against inferred type `TypeError'
19:51:08 <altmattr>       `e' is a rigid type variable bound by
19:51:09 <altmattr>           the instance declaration at src/Core/TypeInference.hs:54:23
19:51:09 <altmattr>     In the first argument of `Left', namely `(TypeError s)'
19:51:09 <altmattr>     In the expression: Left (TypeError s)
19:51:10 <altmattr>     In the definition of `fail': fail s = Left (TypeError s)
19:51:32 <altmattr> I guess I need  a better solution than the old one (hide prelude's fail and write it as a normal funciton)
19:51:35 <altmattr> off ot work!
20:08:44 <hackagebot> haskeline-class 0.6 - Class interface for working with Haskeline (AntoineLatter)
20:25:44 <BMeph> I think benl mentioned something about the case of how using mapM[_] means that you can't just traverse a list once and get the same answer as if you "traversed the list twice".
20:25:50 <sm> parsec users, how would you parse "the following N non-blank lines, ignoring any that begin with ;" ?
20:28:24 <sm> I'm trying something like ls <- many nonblankline; let ls' = filter (not . (";" `isPrefixOf`)) ls; guard (not $ null ls'); return ls'
20:30:42 <sm> I think the guard is causing this "unknown parse error" that's messing me up
20:43:02 <ManateeLazyCat> Why function "insertFirst a (DoubleLinkedList (l:ls) rs) = DoubleLinkedList (l:ls:a) rs" will got error "Occurs check: cannot construct the infinite type: a = [a]" ? Thanks!
20:43:05 <ManateeLazyCat>  
20:43:11 <ManateeLazyCat> data DoubleLinkedList a = DoubleLinkedList ![a] ![a]
20:43:11 <ManateeLazyCat>  
20:43:30 <copumpkin> why strict?
20:44:08 <ManateeLazyCat> And function "insertFirst a (DoubleLinkedList (l:ls) rs) = DoubleLinkedList (reverse (a:(reverse (l:ls)))) rs" can work. Someone explain why?
20:44:25 * sm hacks and slashes to success
20:46:31 <byorgey> ManateeLazyCat: if  (l:ls) :: [a],  then  l :: a  and  ls :: [a]
20:46:39 <byorgey> so it won't work to say  (l:ls:a)
20:47:00 <byorgey> you'll have to say something like   (l:ls) ++ [a]  if that's what you want
20:47:21 <byorgey> remember, :  is ONLY for sticking a single element on the front of a list.
20:49:16 <ManateeLazyCat> byorgey: You mean when (l:ls:x) success, `l` and `ls` must be `a` and can't be `[a]`? Otherwise `:` will  failed?
20:49:52 <byorgey> ManateeLazyCat: right.
20:49:54 <Twey> (l:ls:x) = (l:(ls:(x)))
20:50:08 <ManateeLazyCat> byorgey: I see, thanks for explain! :)
20:50:13 <Twey> (:) :: a -> [a] -> [a]
20:50:45 <byorgey> ManateeLazyCat: if you want to put two lists together to make a bigger list you should use (++) instead of  (:).
20:55:54 <ManateeLazyCat> byorgey: (l:ls) ++ [a] is i want, thanks!
21:05:08 <Cale> Of course, l : (ls ++ [a]) is the same, except ever so slightly faster :)
21:06:07 <Cale> BONUS: lol, bookwarez: http://thepiratebay.org/torrent/4845954/Learn_You_a_Haskell_for_Great_Good
21:08:31 <Axman6> haha
21:10:11 <mmorrow_> hah, BONUS is bigtime now
21:15:00 <hackagebot> haskeline-class 0.6.1 - Class interface for working with Haskeline (AntoineLatter)
21:20:36 <bwr> Is there an example of how to use graphFromEdges from Data.Graph somewhere? I did a google search and didn't find anything useful.
21:21:32 <Twey> :t graphFromEdges
21:21:33 <lambdabot> forall node key. (Ord key) => [(node, key, [key])] -> (Graph, Vertex -> (node, key, [key]), key -> Maybe Vertex)
21:21:45 <bwr> yea, i've looked at the docs
21:21:54 <bwr> i don't get the (node, key [key]) part
21:22:02 <ManateeLazyCat> Cale: l : (ls ++ [a]) is faster?
21:22:02 <bwr> (node, key, [key])
21:22:36 <byorgey> ManateeLazyCat: not in any remotely significant way =)
21:22:44 <byorgey> the ++ just doesn't have to traverse the 'l'
21:22:49 <Cale> ManateeLazyCat: By one step :)
21:23:09 <Cale> ManateeLazyCat: It's what (l:ls) ++ [a] reduces to immediately :)
21:23:22 <Cale> when you apply the rule for (++)
21:24:27 <ManateeLazyCat> I see. :)
21:25:29 <Saizan> bwr: it's (label,nodeId,nodeIds of neighbours)
21:26:43 <bwr> Saizan: thanks, that helps
21:28:53 <mcglk> :type .
21:28:59 <mcglk> :t .
21:29:01 <lambdabot> parse error on input `.'
21:29:13 <mike-burns> :t (.)
21:29:14 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
21:29:24 <mcglk> Oh. Right. Thanks.
21:32:48 <mcglk> :t ($)
21:32:50 <lambdabot> forall a b. (a -> b) -> a -> b
21:35:36 <BMeph> So, did anyone ever come up with an answer to my question from earlier? (Concerning ap and =<<)
21:35:58 <mmorrow_> > let xs = zip3 (repeat ()) [0..2::Integer] (repeat [0..2]); (g, fromV, toV) = graphFromEdges xs in (g, fromV (2::Int), toV (5::Integer))
21:36:00 <lambdabot>   (array (0,2) [(0,[0,1,2]),(1,[0,1,2]),(2,[0,1,2])],((),2,[0,1,2]),Nothing)
21:36:30 <mmorrow_> (the explicit annotations for Int and Integer to be explicit that `key' and Vertex (==Int) are two different things)
21:39:18 <ManateeLazyCat> If i have list [1,2,3,4], i want write a pattern match that split two part: "[1,2,3]" "[4]", (x:xs) can't work, it split with "[1]" and "[2,3,4]", Thanks!
21:39:48 <ManateeLazyCat> How to write this pattern match code?
21:40:15 <Saizan> you can't directly
21:40:18 <Axman6> f (x:y:z:xs) = ([x,y,z],xs)
21:40:33 <mcglk> Reverse the list, take x:xs, and reverse xs?
21:41:31 <ManateeLazyCat> Axman6: No, i just give list example, not always [1,2,3,4]
21:41:41 <ManateeLazyCat> deleteFirst (DoubleLinkedList (l:_) rs)    = DoubleLinkedList l rs
21:42:04 <ManateeLazyCat> data DoubleLinkedList a = DoubleLinkedList ![a] ![a]
21:42:07 <Saizan> so you want to pattern match on the last element?
21:42:17 <ManateeLazyCat> Saizan: Yep
21:42:20 <monochrom> > (init [1,2,3,4], last [1,2,3,4])
21:42:21 <lambdabot>   ([1,2,3],4)
21:42:50 <monochrom> Don't restrict yourself to pattern matching if you do unorthodox things anyway.
21:42:57 <ManateeLazyCat> in function `deleteFirst`, i want to delete last element in first list of DoubleLinedLink
21:43:37 <Saizan> ManateeLazyCat: you can't do it with pattern matching, and getting the last element is O(n)
21:44:37 <Saizan> init and last work, but you might want to write a custom splitLast :: [a] -> ([a],a) function that traverses the list only once
21:55:11 <ManateeLazyCat> Someone compare Data.List and Data.Sequence ? Thanks!
21:59:23 <Saizan> Data.Sequence is a more complex structure, that provides O(log n) indexing, and fast access to both ends
21:59:36 <Axman6> ManateeLazyCat: Data.List and Data.Sequence are different types, so you can't use compare on them >_>
21:59:39 <Axman6> :P
22:00:44 <ManateeLazyCat> Saizan: Yep, i read it's source code. more complex. Fast access to both ends. Interested...
22:01:46 <Saizan> you can use viewl or viewr depending on if you want to pattern match on the left or right end, or first and last element in other words
22:01:59 <Saizan> and they are both constant time
22:02:07 <Saizan> iirc
22:02:34 <Saizan> yes, they do
22:04:14 * ManateeLazyCat pasted "DoubleLinkedLink" at http://paste2.org/get/274759
22:04:16 <ManateeLazyCat> Saizan: In fact, i'm write DoubleLinkedLink library for my project. Above is link, and haven't finish. Any suggestion? You recommand me use Data.Sequence replace List to implement DoubleLinkedLink?
22:06:35 <Saizan> ManateeLazyCat: where do you need fast access to the last element?
22:07:05 <ManateeLazyCat> deleteFirst (DoubleLinkedList (l:_) rs)    = DoubleLinkedList l rs
22:07:05 <ManateeLazyCat>  
22:07:34 <Saizan> ah i see
22:07:46 <ManateeLazyCat> The first list of DoubleLinkedList is reverse list, if i need delete first element, i need delete last element in first list.
22:09:12 <Gracenotes> hmmm.. zipper, huh...
22:09:14 <Saizan> i think i'd use a representation like data DoubleLinkedList a = DoubleLinkedList !(Seq a) !Int, where the Int is the index of the current element, to implement those operations
22:09:56 <vinicius> don't zippers make a lot of gc pressure
22:10:42 <Saizan> however some of them could be faster by using two Seq like you use your two lists
22:11:10 <ManateeLazyCat> In fact, PointedList is almost library that i need, except PointedList must need you give one element when it create. So i write another one.
22:11:28 <Saizan> vinicius: well, haskell programs in general generates a lot of garbage
22:11:34 <Saizan> *generate
22:11:54 <ManateeLazyCat> Saizan: Don't need index, it's unnecessary, first element of second list is indicate current focus node.
22:12:22 <Saizan> ManateeLazyCat: my representation uses only one sequence, not two
22:12:43 <ManateeLazyCat> Saizan: Clearer?
22:13:14 <Saizan> i said i'd use "data DoubleLinkedList a = DoubleLinkedList !(Seq a) !Int" above
22:13:25 <Saizan> only one sequence and an index into it
22:13:58 <ManateeLazyCat> Saizan: I want finish some `search` function for DoubleLinkedList, but now looks efficient is O(n)
22:14:05 <ManateeLazyCat> Any suggestion?
22:14:38 <Saizan> i don't understand what you mean?
22:16:06 <ManateeLazyCat> Saizan: find :: Eq a => a -> DoubleLinkedLink a -> DoubleLinkedLink a
22:16:37 <ManateeLazyCat> Saizan: If find a in DoubleLinkedLink, move focus, then use getCurrent get current node.
22:18:25 <Saizan> well, you can't do better than O(n) without keeping the list sorted
22:18:52 <Saizan> well, even if you keep it sorted, since it doesn't have fast indexing you can't do better either
22:30:17 <hackagebot> tconfig 0.5 - Simple text configuration file parser library. (AnthonySimpson)
22:30:28 <ManateeLazyCat> Saizan: Better solution is don't use List and Sequence, I use Data.Set keep element in DoubleLinkedList, and every element keep next node and previous node. Then search efficient is O(log n)
22:32:17 <jameysharp> shouldn't (map f l) be equivalent to [ f x | x <- l ], for all f and l of appropriate types? I'm getting a type error from the former but not the latter.
22:32:53 <jameysharp> I'm hoping somebody makes me feel silly in short order here.
22:34:04 <mmorrow_> > let map f xs = [f x | x <- xs] in map (*2) [0..9]
22:34:06 <lambdabot>   [0,2,4,6,8,10,12,14,16,18]
22:34:29 <mmorrow_> err, you say an error on the former?
22:34:44 <jameysharp> yeah.
22:34:45 <mmorrow_> is (l :: [a])?
22:34:55 <mmorrow_> (and f :: a -> b)
22:35:02 <jameysharp> l is [Int].
22:35:09 <jameysharp> and f is Int -> (Int, Int)
22:35:20 <Twey> jameysharp: More context please
22:35:28 <Twey> Actual error is probably enough
22:35:33 <mmorrow_> > map (\n -> (n,n::Int)) [0..9::Int]
22:35:34 <lambdabot>   [(0,0),(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9)]
22:35:39 <jameysharp> Twey: sure. I just hoped I was confused in an obvious way.
22:35:42 <Twey> But the expression you're using it in might be helpful :)
22:35:43 <mmorrow_> there must be something else happening
22:35:50 <Twey> Nope.  What you've described so far should be fine.
22:35:58 <Twey> Probably it's to do with the way you're treating the result.
22:36:16 <jameysharp> Couldn't match expected type `(Int -> (Int, Int))
22:36:18 <jameysharp>                                   -> [Int]
22:36:20 <jameysharp>                                   -> [(Int, Int)]'
22:36:20 <mmorrow> yeah, what's the enclosing context?
22:36:22 <jameysharp>            against inferred type `Map.Map L.ByteString [Int]'
22:36:23 <jameysharp>     In the expression: map check value
22:36:25 <jameysharp>     In the definition of `matches': matches = map check value
22:36:45 <Twey> Oh my
22:36:49 <jameysharp> I guess I should paste the whole thing somewhere. it's pretty small.
22:37:00 <mmorrow> @paste
22:37:01 <lambdabot> Haskell pastebin: http://hpaste.org/new
22:37:22 <Twey> You've got another map defined somewhere, I think
22:37:34 <mmorrow> it may be Data.Map.map
22:37:35 <Twey> Try writing fmap instead of map
22:37:39 <Twey> I suspect so
22:37:46 <mmorrow> (which is fmap for Map..)
22:37:56 <mmorrow> fmap++
22:38:02 <jameysharp> I want Prelude.map, and I used "import qualified Data.Map as Map" ...
22:38:03 <BMeph> Am I missing something, or is the State monad just a newtype of (,)? :)
22:38:29 <mmorrow> BMeph: you mean Writer?
22:38:57 * jameysharp waits for hpaste to accept my paste...
22:39:08 <jameysharp> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6072#a6072
22:39:09 <BMeph> mmorrow: Now, I meant what I said - State. :)
22:39:30 <mmorrow> BMeph: hmm, i suppose it's essentially that
22:39:32 <mmorrow> i like
22:39:32 <BMeph> ice, I just shot myself in the foot... *No,...
22:39:50 <mmorrow> newtype S s a = S (forall o. (a -> s -> o) -> s -> o)
22:40:11 <mmorrow> runS (S f) = f (,) -- for the regular runState
22:41:35 <mmorrow> execS (S f) = f (flip const)
22:41:41 <mmorrow> evalS (S f) = f const
22:41:51 <mmorrow> so much prettier :)
22:42:11 <mmorrow> (and fastar)
22:43:18 <BMeph> mmorrow: Plus, it helps me immediately to see why it's so tough to make (,) an instance of Arrow. :)
22:44:00 <mmorrow> what helps you see that?
22:45:06 <mmorrow> jameysharp: ohh, you're shadowing `map' with the first arg of `bump' :)
22:45:26 <mmorrow> (all the args are in scope in the where)
22:45:46 <jameysharp> argh.
22:45:50 <mmorrow> heh
22:45:50 <jameysharp> thanks. :-)
22:45:53 <mmorrow> np
22:45:57 * jameysharp turns on -Wall.
22:47:16 * BMeph puts on earmuffs and turns on -Wailing -Wall
22:47:43 <mmorrow> (ah, looks like you already knew they were in scope in the where since you used map (the param) in it..)
22:47:55 <jameysharp> you know, I thought it was really unlikely that I'd discovered a GHC bug. :-)
22:48:25 <mmorrow> BMeph: what helps you to see "why it's so tough to make (,) an instance of Arrow" ?
22:48:51 * mmorrow doesn't know what you see
22:49:00 <BMeph> mmorrow: Well, because it's a Monad! ;)
22:49:10 <mmorrow> ah, isee!
22:49:39 <mmorrow> (well, ((,)a)..)
22:52:59 <mmorrow> instance (Monoid o) => Monad ((,)o) where return = (,) mempty; (o,a) >>= k = let (no,b) = k a in (o`mappend`no,b)
22:54:33 <BMeph> Weird; I can see a way to make P (forall b. a -> (a, b)) an Arrow. Maybe my mind's just _that_ off... ;p
22:55:13 <mmorrow> hmm, would you ever be able to do anything with the `b' in that though?
22:55:56 <mmorrow> (seems like that's essentially just (a -> a), and then just go (\a -> (f a, undefined))
22:57:47 <BMeph> mmorrow: Hmm, maybe I'm missing the whole "this existential means I get to choose the type..." concept.
23:01:10 <BMeph> newtype P a b = P { unP :: Flip (,) } -- modulo type-level trickery... :)
23:02:55 <BMeph> instance Arrow P where arr f = P (\a -> (a, f a)), something like that.
23:03:33 <rossnm> I'm using GHCi on Vista. What's the best way to save my .hs functions so that I can load them in easily?
23:04:00 <BMeph> @djinn (a -> b) -> a -> (a, b)
23:04:01 <lambdabot> f a b = (b, a b)
23:04:42 <BMeph> I.e., f g a = (a, g a)
23:13:45 <mmorrow> BMeph: ah, on the outside is existential
23:14:06 <mmorrow> (and you need a data too, since ghc doesn't have first-class existentials)
23:14:22 <mmorrow> data P a = forall b . P (a -> (a, b))
23:15:40 <mmorrow> ==> exists b | a -> (a, b)
23:15:58 <mmorrow> newtype P a = P (forall b. a -> (a, b))
23:16:05 <mmorrow> ==> forall b | a -> (a, b)
23:16:39 <mmorrow> (slightly odd)
23:17:54 <mmorrow> BMeph: the inability to make Map an instance of Arrow kills it for me
23:18:06 <mmorrow> (Category too for that matter)
23:18:42 <mmorrow> it seems to me like it would be better to define it as:
23:18:50 <mmorrow> class Arrow f a b where ...
23:19:14 <mmorrow> so you can put constraints on the `a' and/or the `b' in instances..
23:19:46 <mmorrow> (or just completely redefine typeclasses...)
23:20:35 <mmorrow> i like the former option myself!
23:21:13 <mmorrow> but then you also can't have arr :: (a -> b) -> f a b
23:21:46 <mmorrow> i think this is just a limitation of something, i just don't know what
23:22:11 <BMeph> mmorrow: Restricted Arrows? ;)
23:22:43 <mmorrow> hmm
23:23:18 <dmwit> Huh, I'm surprised rossnm didn't get any answers.
23:24:14 <Axman6> what was the question?
23:24:16 <BMeph> I guess he hit a slow patch - five minutes seems a little quick to me, but, maybe I'm just not that important... ;)
23:24:24 <Axman6> i think i was going to reply, but he left
23:24:32 <BMeph>  <rossnm> I'm using GHCi on Vista. What's the best way to save my .hs functions so that I can load them in easily?
23:24:37 <dmwit> Yeah, I'm also surprised he left.
23:24:47 <Axman6> ah yes
23:24:58 <Saizan> i don't understand the question, though
23:25:07 <dmwit> "Save them in a file."
23:25:08 <Axman6> me either
23:25:19 * mmorrow didn't even see the question
23:25:24 <BMeph> I should've just said "Notepad!" and been done with it. ;)
23:26:12 <Saizan> it's weird that you mention .hs to actually mean Haskell and don't know where to put some functions, but ok :)
23:26:26 <dmwit> yeah, a little strange
23:26:31 <Axman6> yeah, my thoughts exaclt
23:26:32 <Axman6> y
23:26:51 <dmwit> must've been a troll, then ;-)
23:27:00 <mmorrow> a troll running Vista!
23:28:21 <Saizan> i stopped reading at Vista, to be honest :)
23:31:25 <erikc`> ugh, win7 just bluescreened my macbook
23:31:35 <dmwit> TROOOLL
23:31:35 <Twey> Vista We can say mean things about Saizan like this!
23:31:36 <dmwit> oh
23:31:38 <dmwit> I mean, sorry.
23:31:57 <Twey> Haha
23:38:27 * BMeph wonders what way of saving ".hs functions" would make them harder to load...
23:39:04 <dmwit> He may have been wondering about auto-loading functions or something.
23:39:08 <dmwit> dunno
23:42:43 <mmorrow> Saizan: :D
23:54:26 <Yrogirg> Hello! How do I force GHC to recompile already compiled modules, even if their source code hasn't changed?
23:55:42 <Cale> Delete the .o file
23:55:55 <Cale> or touch the source file
23:56:14 <Yrogirg> may be there are some command line arguments?
23:58:31 <Cale> -fforce-recomp
23:58:38 <Cale> apparently
23:59:45 <Yrogirg> ok, thanks
23:59:56 <ivanm> Cale: are you moving down under or something?
