00:02:44 <Twey> > (\ ~(_,_) -> ()) undefined
00:02:45 <lambdabot>   ()
00:03:44 <Axman6> Cale: would you mind giving my initial code the once over? not sure if there's something i'm missing in making it more consise: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6291#a6291
00:04:22 * ski thinks it'd be nice if those two queries yielded the same answer
00:05:28 <ski> (meaning, amongst other things, that `data (,) a b = (,) a b' is no more the intended definition of the type of pairs)
00:07:04 <Cale> Axman6: hmm... perhaps I'm misunderstanding things, but inserting into an empty tree seems a bit strange there...
00:07:14 <Axman6> how come?
00:08:02 <Cale> oh, perhaps I see how this is supposed to work
00:08:32 <Cale> yeah, okay :)
00:08:43 <Axman6> i think i've got it all ok, seems to follow the article on how they;re supposed to work. not exactly pretty, but i think it's fairly clear...
00:10:34 <Cale> Seems okay :)
00:11:25 <Axman6> excellent
00:11:28 <edwardk> woot. now am officially the top team with only 4 problems solved
00:11:40 <Axman6> i think the only other thing i really need to get out of it is an elems function
00:13:26 <roconnor> @type lookup
00:13:27 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
00:14:39 <Cale> lookup always feels like the parameters are the wrong way around to me
00:14:47 <ski> yes
00:17:47 <ski> @type \abs a -> (map snd . filter ((a ==) . fst)) abs
00:17:48 <lambdabot> forall a b. (Eq a) => [(a, b)] -> a -> [b]
00:19:13 * copumpkin starts proving his properties with unsafeCoerce ;)
00:19:15 <ski> (maybe there's a solution with `catMaybes' lurking, too ..)
00:19:21 <copumpkin> "BECAUSE I SAY SO DAMMIT" is my proof
00:19:41 <ski> GADT properties ?
00:20:23 <copumpkin> well, just playing with the http://www.opensubscriber.com/message/haskell-cafe@haskell.org/12388255.html stuff, without the GADT representation of the Nat
00:28:07 <copumpkin> ack, Eq on AnyNat is hard
00:32:37 <roconnor> darn, my score is 260.422359
00:32:44 <roconnor> just off the bottom of the board
00:32:58 <roconnor> or more likely, in a big pool of people with about that score
00:34:40 <wli> roconnor: score on what?
00:34:56 <copumpkin> no pattern matching for me!
00:35:04 <roconnor> http://icfpcontest.org/index.php
00:35:12 * Saizan_ gives copumpkin some pattern matching
00:35:30 <copumpkin> Saizan_: no can haz in Eq on AnyNat :(
00:36:09 <Saizan_> copumpkin: did you prove natEqDec?
00:36:31 <copumpkin> Saizan_: nope, I skipped it :P I'm guessing it would probably help, eh ;)
00:36:52 <copumpkin> so far I have eqNat (AnyNat n) (AnyNat m) = caseNat n (caseNat m True (const False)) undefined :P
00:37:32 <Saizan_> that's pretty similar to how natEqDec goes :)
00:37:42 <copumpkin> alright, I'll do that one first
00:38:30 <copumpkin> har har
00:38:30 <copumpkin>     Occurs check: cannot construct the infinite type:
00:38:30 <copumpkin>       x = S (forall p. (y ~ S p, Nat p) => p -> Maybe (TEq x x))
00:38:39 * copumpkin is loving the types he's been getting recently
00:38:51 <Saizan_> remember that if you state which constraint you need it's easier for the solver
00:39:01 <copumpkin> how do you mean?
00:39:05 <Saizan_> like in the style of the definition of induction
00:39:13 <Saizan_> where it gives explicit types to the two branches
00:39:18 <copumpkin> oh
00:39:21 <Saizan_> isZ and isS
00:39:29 <copumpkin> yeah, hrm
00:39:32 <Peaker> debugging occurs check sucks :-(
00:39:38 <Peaker> no specific-line information
00:39:49 <copumpkin> my problem is still the recursive bit of the nested caseNat's
00:40:24 <copumpkin> Peaker: it told me this time
00:40:45 <Peaker> copumpkin: it didn't tell me, though
00:40:50 <copumpkin> aw
00:40:58 * Peaker is trying to write an iteratee in a nicer way 
00:41:16 <Peaker> I dislike the existing iteratee.. the names and the unnecessary type-specifity they have there
00:44:13 <copumpkin> dammit, I can't pattern match
00:44:21 <copumpkin> which is preventing me from stripping off S constructors
00:44:34 <ski> something like `eqAnyNat :: AnyNat -> AnyNat -> Bool; eqAnyNat (AnyNat n) = caseNat n (\(AnyNat m) -> caseNat m True (const False)) (\n (AnyNat m) -> caseNat m (const False) (\m -> eqAnyNat (AnyNat n) (AnyNat m)))'
00:44:38 <ski> i think
00:45:01 <ski> (possibly with more type signatures ..)
00:45:36 <Peaker> yay, got it
00:45:40 <copumpkin> hmm, how can I pattern match on an AnyNat there?
00:45:55 <ski>   data AnyNat where AnyNat :: Nat n => n -> AnyNat
00:45:58 <copumpkin> yeah
00:46:07 <copumpkin> oh, you made it take one parameter
00:46:17 <copumpkin> well, you broke it up
00:46:41 <ski> possibly that doesn't matter much
00:46:55 <copumpkin> probably not, just threw me off :)
00:47:07 <ski> (i was going to use the induction first, but didn't see any non-dependent inductions, so ..)
00:47:37 <ski> (of course, it might be nicer to not have to wrap and unwrap `AnyNat' data constructors all the time)
00:50:04 <copumpkin> I think that's more or less what I have
00:50:10 <copumpkin> but I can't get yours or mine to work
00:50:15 <copumpkin> natEqDec a b = caseNat a (caseNat b (Just TEq) (const Nothing)) (\x -> caseNat b Nothing (\y -> natEqDec x y))
00:50:42 * ski tries
00:52:19 <copumpkin> I'm getting a polymorphic variable escapage error
00:52:29 <hackagebot> lui 0.0.5 - Purely FunctionaL User Interface (EyalLotem)
00:52:41 <Saizan_> copumpkin: you can't just recurse
00:52:46 <copumpkin> oh :)
00:52:58 <copumpkin> I guess it did feel a little simplisitc :P
00:53:02 <Peaker> hey, hackagebot is back
00:53:32 <Saizan_> copumpkin: the recursion is going to prove Maybe (TEq x' y') while you want to prove Maybe (TEq x y) with x ~ S x', y ~ S y'
00:53:45 <Saizan_> copumpkin: so you've to do more than recursing :P
00:53:53 <Saizan_> copumpkin: and you probably need more type annotations
00:53:54 <copumpkin> :o
00:54:03 <copumpkin> onoes, not moar typz
00:54:10 <copumpkin> :(
00:54:19 <sm> it has been here all day
00:54:23 <copumpkin> dammit, why can't that last case be as easy as the other 3
00:55:17 <copumpkin> Saizan_: what does more than recursing involve? any hints? :)
00:56:12 <Saizan_> copumpkin: well, if you have x' ~ y' the solver can prove S x' ~ S y'
00:56:57 <|Jedai|> copumpkin: You need plenty of type annotations, but I got my natEqDec to work
00:57:20 <copumpkin> aw :(
00:57:27 <Saizan_> copumpkin: so you've to bring that equivalence in scope
00:59:33 <copumpkin> I keep letting my polymorphic variable escape :(
01:02:09 <Saizan_> you have no shame!
01:02:32 <Saizan_> copumpkin: paste, maybe?
01:02:49 <edwardk> saizan: well, its parametrically polymorphic, so because its er.. so free, no one can do anything with it anyways
01:04:04 <Saizan_> heh :D
01:04:04 <copumpkin> Saizan_: don't have much beyond what I had before
01:04:19 * Saizan_ tries to make a joke on "bound variable" and fails
01:04:51 <copumpkin> it seems like I only need heavy type annotations on the last of the four nested caseNat cases
01:05:41 <Saizan_> i need them on the first, too
01:05:54 <Saizan_> i.e. the other that doesn't return Nothing
01:06:10 <copumpkin> hmm, it isn't complaining on mine, but it may be silently doing evil?
01:06:56 <Saizan_> mmh, it might
01:07:18 <ski> copumpkin : my variant loaded .. my problem was that i had written `caseNat m (const False) (...)' where i should have written `constNat m False (..)'
01:07:48 <Saizan_> what type did you give to the last branch, btw?
01:08:19 <copumpkin> I actually can't get it to typecheck anymore, so I think I just imagined it
01:08:29 <|Jedai|> ski: Note that your version doesn't prove that the equality of naturals is decidable, except by a meta-argument
01:08:54 <Saizan_> yeah, that's enough to write (==) for AnyNat though
01:09:30 <Saizan_> so maybe going via natEqDec is not the easier route if you didn't implement it already
01:09:30 <|Jedai|> ski: That's really the annoying bit in this function, to get the type inference algorithms of GHC to admit defeat !
01:09:47 <copumpkin> all I have
01:09:47 <copumpkin> natEqDec a b = caseNat a (caseNat b (Just TEq) (const Nothing)) (caseNat b Nothing ???)
01:09:59 <copumpkin> GHC 1, copumpkin 0
01:10:40 <copumpkin> too many types
01:10:44 <ski> |Jedai| : yes .. thought i didn't really consider that problem
01:10:59 <Saizan_> natEqDec a b = caseNat a (caseNat b (Just TEq) (const Nothing)) (\x' -> caseNat b Nothing ???)
01:11:05 <|Jedai|> copumpkin: The ??? is just a recursion withe natEqDec
01:11:23 <copumpkin> |Jedai|: yeah, I just couldn't get it working when I tried it :)
01:11:33 <copumpkin> or did I try calling eqAnyNat instead
01:11:39 <ski> |Jedai| : so you're suggesting using `induction' instead of `caseNat' ?
01:11:46 <|Jedai|> copumpkin: but you need to annotate it (I suggest you make it a local function) to put the relevant types in scope
01:12:07 <|Jedai|> ski: No, caseNat is the correct choice here
01:12:13 <ski> why ?
01:12:13 <Saizan_> natEqDec a b = caseNat a (caseNat b bothZ (const Nothing)) (\x' -> caseNat b Nothing (bothS x')) where bothZ :: ???; bothZ = ???; bothS :: ???; bothS x' y' = ???
01:12:40 <ski> (|Jedai| : or maybe using a non-dependent variant of `induction' would be better ?)
01:12:46 <|Jedai|> ski: but to return (Maybe (TEq x y)) you have to prove that x and y are equal when you build a TEq)
01:12:55 <copumpkin> Saizan_: aha!
01:13:03 <copumpkin> Saizan_: that looks a lot clearer :)
01:13:19 <ski> |Jedai| : i had no `x' and `y' in scope, i was defining `AnyNat -> AnyNat -> Bool' (which was what copumpkin was talking about)
01:13:35 <|Jedai|> ski: The caseNat is enough and has a simpler type than induction
01:14:04 <ski> |Jedai| : but then you have to rely on user-recursion .. i thought that was your point
01:18:43 <copumpkin> I can't see how I can stop this polymorphic variable from escaping :/
01:19:20 <thoughtpolice> use a lasso
01:20:00 <ski> (copumpkin : are you trying to define that `natEqDec', now ?)
01:20:06 <copumpkin> yeah
01:21:33 <Gracenotes> I am an eel! apparently
01:21:38 <Saizan_> copumpkin: don't make it appear in the result
01:21:57 <copumpkin> Saizan_: it seems like it has to appear in the result though?
01:22:19 <copumpkin> oh wait
01:22:24 <copumpkin> hrm
01:22:27 <ski> we really want an inequality in the types for `natEqDec' ..
01:23:33 <Saizan_> copumpkin: the only variables that should appear in the result are x and y
01:24:39 * ski wonders whether to define `natEqDec' using `caseNat' or using `induction' ..
01:24:59 <ski> (both, is probably the answer ..)
01:25:51 <EnglishGent> hi all :)
01:26:57 <ski> good afternight
01:27:36 <EnglishGent> hi ski :)
01:27:40 <copumpkin> oh I think my bothZ type signature is messing me up
01:27:46 <copumpkin> messing up my bothS that is
01:27:48 <copumpkin> hi EnglishGent :)
01:27:50 <EnglishGent> hey copumpkin :)
01:39:25 <copumpkin> well my bothZ is definitely good now
01:47:47 <copumpkin> Saizan_: is it fine to ignore the x' in the lambda?
01:47:52 <ski> Inferred type is less polymorphic than expected - Quantified type variable `p' escapes
01:48:00 <ski> then i get
01:48:06 <ski> GADT pattern match with non-rigid result type `Maybe a' - Tell GHC HQ if you'd like this to unify the context
01:48:10 <ski> sounds fun :)
01:48:11 <copumpkin> lol
01:48:36 <ski> ("then" meaning "after attempting a fix for the first error", i mean)
01:51:58 <copumpkin> now I'm getting an infinite type
01:53:16 <copumpkin>         bothS :: (y ~ S q, Nat q) => x -> q -> Maybe (TEq x y)
01:53:29 <copumpkin> it all works fine if I make bothS = undefined ;)
01:53:42 <copumpkin> but I can't prove it
01:55:32 <copumpkin> edwardk: what's your team name btw?
01:55:57 <ski> funfunfun !
01:56:04 <ski>   Context reduction stack overflow; size = 20
01:56:17 <copumpkin> ski: wow, how'd you manage that?
01:56:25 <ski> i'm not quite sure
01:56:40 <copumpkin> I get the impression I'm in a little over my head here :P
01:56:44 <copumpkin> but it's fun
01:56:55 <ski> (i added a `PatternSignatures' .. i got the stack overflow after that)
01:57:06 <copumpkin> ah
01:57:29 <copumpkin> I'd imagine with GADTs it can actually add complexity to have pattern signatures?
01:57:50 <copumpkin> or is it still just syntactic convenience?
01:58:55 <copumpkin> I got it to typecheck but I think it's invalid
01:59:00 <ski> .. ok, i get stack overflow with explicit `forall ..' as well
01:59:17 <ski> (instead of the pattern signature)
02:00:19 <copumpkin> |Jedai|: still around?
02:04:29 <copumpkin> zomg I think I got it
02:05:26 <mmorrow> , nesty $(nat 18) (:[]) 42
02:05:28 <lunabot>  [[[[[[[[[[[[[[[[[[[42]]]]]]]]]]]]]]]]]]]
02:05:31 <mmorrow> , nesty $(nat 19) (:[]) 42
02:05:33 <lunabot>  luna: Context reduction stack overflow; size = 20
02:05:43 <copumpkin>         bothS :: (x ~ S p, y ~ S q, Nat p, Nat q) => p -> q -> Maybe (TEq x y)
02:05:43 <copumpkin>         bothS x y = natEqDec (S x) (S y)
02:05:44 <mmorrow> , $(nat 19)
02:05:47 <lunabot>  S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S Z))))))))))))))))))
02:06:18 <copumpkin> does that look reasonable?
02:06:34 <copumpkin> or are the S misplaced?
02:07:28 <mmorrow> , nesty $(nat 8) Just 0
02:07:30 <lunabot>  Just (Just (Just (Just (Just (Just (Just (Just (Just 0))))))))
02:07:31 <Saizan_> copumpkin: that's non-terminating :P
02:07:40 <copumpkin> Saizan_: that's what I thought might happen
02:07:48 <copumpkin> but it's the only way I could get it to typecheck :P
02:07:53 <mmorrow> heh
02:08:06 <Saizan_> copumpkin: you've proved natEqDec x y with natEqDec x y, it's easy to prove things that way :)
02:08:14 <copumpkin> yeah, fair enough
02:08:31 <Saizan_> you've to case .. of on natEqDec x y
02:08:32 <copumpkin> bah, it's too late :P
02:08:37 <copumpkin> hmm
02:10:12 <ski> @kind forall. ()
02:10:14 <lambdabot> *
02:10:21 <copumpkin> Saizan_:
02:10:22 <copumpkin>         bothS x y = case natEqDec x y of
02:10:22 <copumpkin>                       Just TEq -> Just TEq
02:10:22 <copumpkin>                       Nothing -> Nothing
02:10:23 <copumpkin> :o
02:10:32 <copumpkin> :P
02:10:41 <Saizan_> :D
02:10:45 <ski> copumpkin : now you're doing what i was trying :)
02:10:58 <copumpkin> what's up with that??
02:11:07 <Saizan_> what?
02:11:09 <mmorrow> reminds me of
02:11:11 <ski> is there anything "up" with it ?
02:11:13 <mmorrow> @src fromDynamic
02:11:14 <lambdabot> fromDynamic (Dynamic t v) = case unsafeCoerce v of
02:11:14 <lambdabot>     r | t == typeOf r -> Just r
02:11:14 <lambdabot>       | otherwise     -> Nothing
02:11:24 <mmorrow> "if you can't win, cheat!"
02:11:33 <copumpkin> ski
02:11:37 <copumpkin> it looks like id
02:11:41 <copumpkin> but doesn't behave like it
02:11:48 <Saizan_> copumpkin: the two TEq have different types
02:11:48 <copumpkin> but I used something like that earlier
02:11:54 <copumpkin> yeah
02:12:01 <copumpkin> it's too subtle!
02:12:31 <Saizan_> you get p ~ q by pattern matching on the TEq you get by recursion
02:12:48 <Saizan_> which can be used to prove S p ~ S q by decomposition
02:12:57 <copumpkin> I think I get it
02:12:57 <Saizan_> and so x ~ y because of the context
02:13:19 <Saizan_> and with that you construct the new TEq
02:13:57 <ski> (i still wonders why my variant of it results in stack overflow ..)
02:14:39 <copumpkin> whee
02:15:22 <Saizan_> (where is it?)
02:15:29 <copumpkin> is there some way I can exploit my type family for addition to get subtraction?
02:15:52 <ski> Saizan_ : i could paste it ..
02:16:53 <copumpkin> mmorrow: is it possible to define that nat function in the same module it's used in?
02:16:56 * Saizan_ likes to see ghc break, just because :)
02:17:26 <mmorrow> , fmap (length . vacuum . (p^)) [1..]
02:17:29 <lunabot>  [6,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,1...
02:17:41 <mmorrow> copumpkin: no
02:18:00 <mmorrow> but you can put it in another one
02:18:38 <mmorrow> (you can use it in ghci though with functions from the same module it's defined in)
02:20:10 <copumpkin> ah
02:20:19 <copumpkin> alright, 5:20am, I should probably get some sleep
02:20:24 <copumpkin> my mind is full of types
02:20:38 <Gracenotes> I wouldn't sleep if I were you, you might have nightmares about them
02:21:18 <copumpkin> main = print (replicateMat 5 :: Mat Int (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S Z))))))))))))))))))))))))) (S (S (S (S Z)))))
02:21:19 <copumpkin> :P
02:21:25 <copumpkin> I really need that nat function
02:21:25 <thoughtpolice> nightmares of your code passing the typechecker and always segfaulting? :)
02:21:37 <thoughtpolice> i believe that is called 'programming in C' however
02:21:38 <mmorrow> copumpkin: dood, it's like 3 lines :)
02:21:45 <mmorrow> ^C^V
02:22:02 <Gracenotes> anyway, if you are groggy when you wake up, chances are you may confuse reality and types
02:22:03 <copumpkin> mmorrow: hrrmpf, fine :P I've just slammed all the stuff in one file so far and was too lazy to break it up
02:22:46 <Saizan_> at some point i started talking about monads when drunk
02:23:28 <Gracenotes> monads must have infiltrated your lower brain!
02:23:33 <ski> Saizan_ : <http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6293#a6294>
02:24:02 <copumpkin> I like your naming
02:24:09 <ski> ty
02:24:41 <Gracenotes> and near-homage to fictional elephant
02:24:51 <copumpkin> zomg Refl
02:25:05 * copumpkin runs back to agda
02:25:08 <FunctorSalad> "<Gracenotes> anyway, if you are groggy when you wake up, chances are you may confuse reality and types" <-- seriously.
02:25:29 <copumpkin> Gracenotes: you needz moar typez
02:25:43 <ski> (naming the data constructor `TEq' too looked ugly, so i renamed to the proper `Refl' ..)
02:27:51 * ski . o O ( "elephant" .. ? )
02:28:28 <copumpkin> ?
02:28:38 <ski> yes
02:28:58 <copumpkin> barbar? :P
02:29:10 <ski> .. oh
02:29:20 <copumpkin> not quite the elephant though
02:29:21 * ski didn't realize that
02:31:49 <edwardk> copumpkin: i decided to help shapr and darius: Wili WÃ¡chendon
02:32:05 <taruti> Is the new way of handling Handles documented somewhere?
02:32:28 <edwardk> copumpkin: but i suppose i should actually do some more work on it, since more folks have made it past 4 problems now
02:32:52 <taruti> How does a GHC.IO.Device.RawIO notify that there is some new readable data?
02:33:02 * ski . o O ( .. that might be a nice title - Handling `Handle's )
02:33:12 <taruti> and what is the "correct" way to define custom Handles?
02:34:11 <ski> taruti : where did you learn of said new `Handle's ?
02:34:35 <taruti> ski: ghc commits
02:34:57 <taruti> just wondering whether it is documented somewhere yet
02:35:11 * ski hasn't heard of it before
02:36:17 <taruti> it is in the recent 6.11 snapshots
02:36:55 <taruti> would #ghc be the right place to ask?
02:37:25 <ski> possibly
02:50:31 <cjs> So if I have a UArray, and I'm in the ST monad (runST $ do ...), how do I get an STUarray to play with?
02:52:04 <Saizan_> thaw
02:52:24 <cjs> Ah!
02:55:50 <apfelmus> Hi there, I've got a problem with cabal.
02:56:25 <apfelmus> In particular with  cabal install
02:56:27 <archduke_o_hell> well
02:56:46 <archduke_o_hell> how is haskell nicer than say python
02:56:51 <archduke_o_hell> python seems popular
02:57:03 <archduke_o_hell> I am so ignorant of computers I dont even know perl
02:57:09 <archduke_o_hell> or much programming atoll
02:57:17 <archduke_o_hell> how is haskell nicer than python or scheme?
02:58:01 <apfelmus> I've installed a depency for a package by hand
02:58:05 <qwr> archduke_o_hell: it tells you that your code sucks
02:58:15 <qwr> archduke_o_hell: (that is, checks types...)
02:58:20 <apfelmus> Now I want cabal to recognize it when installing from hackage.
02:58:54 <apfelmus> Anyone know how to do that?
02:59:26 <thoughtpolice> apfelmus: well, if you build a package by hand and it's registered with ghc-pkg, cabal install should just 'do the right thing' i would think?
02:59:51 <apfelmus> I thought so, too, but somehow that's not the case??
03:00:12 <thoughtpolice> apfelmus: so when you 'cabal install' it is downloading another version of the same package from hackage?
03:00:23 <thoughtpolice> i.e. it is ignoring the hand-built 'tweaked' one?
03:00:31 <apfelmus> Nope, it's the same.
03:00:42 <apfelmus> The packages are wx and wxcore, 0.11.1.2 each.
03:01:06 <apfelmus> wx depends on wxcore
03:01:28 <apfelmus> I installed wxcore by hand because it's got a small bug that prevented me from doing a user install.
03:01:33 <archduke_o_hell> how is haskell nicer that scheme or ML? or common lisp?
03:01:59 <Saizan_> apfelmus: mmh, cabal install probably tries to reinstall it because it picks different versions for the dependencies
03:02:02 <thoughtpolice> archduke_o_hell: re. python, much better performance (GHC has native code,) and static types go a long, long way to help prevent program errors/runtime failure
03:02:27 <thoughtpolice> Saizan_: that's what I figure
03:02:45 <apfelmus> But it's wxcore-0.11.1.2 in both cases?
03:02:52 <Saizan_> apfelmus: i often bump the minor version when i install something in that situation
03:03:12 <Saizan_> apfelmus: so that i end up with wxcore-0.11.1.3 and cabal sticks with it
03:03:41 <thoughtpolice> archduke_o_hell: also, GHC is equipped with a lot of methods for robust parallel/multicore code, making it much easier to write. immutability and purity help a lot here.
03:03:52 <apfelmus> Saizan_: Ah, ok. I'll try that.
03:03:55 <Saizan_> apfelmus: precisely because it's the same version that cabal feels free to reinstall it if it wants to use different versions for its dependencies
03:04:22 <Saizan_> apfelmus: btw, which version of cabal?
03:04:38 <apfelmus> cabal-install version 0.6.0
03:04:38 <apfelmus> using version 1.6.0.1 of the Cabal library
03:04:50 * mmorrow finally groks all the steps of elf linking
03:04:51 <Saizan_> apfelmus: 0.6.2 might solve this
03:04:59 <thoughtpolice> mmorrow: writing a linker? :)
03:05:14 <mmorrow> thoughtpolice: why of course! ;)
03:05:22 <Saizan_> apfelmus: it should also have a way to tell that you want to stick with the installed one via --constraint= but i don't remember the synta
03:05:25 <Saizan_> *syntax
03:07:26 <apfelmus> Saizan_: Ugh, installing cabal-install 0.6.2 doesn't work out of the box. Complains about HTTP 4000.
03:09:47 <Saizan_> apfelmus: weird, complains how?
03:10:33 <apfelmus> Saizan_: HTTP 4000 missing. I still have an old HTTP 3000 installed, that's probably while. I should update the dependencies in my  port  tree.
03:10:39 <apfelmus> *why
03:11:08 <Saizan_> apfelmus: it should download and install ti from hackage
03:11:29 <Saizan_> apfelmus: maybe you need to cabal update? (but it looks strange)
03:12:08 <Saizan_> apfelmus: did you run "cabal install cabal-install" ?
03:12:39 <apfelmus> Saizan_: Nope, I'm using my local package manager for cabal.
03:12:48 <apfelmus> Which is, apparently not free of hassles.
03:13:11 <Saizan_> ah, i see
03:13:41 <Saizan_> however bumping the version of wxcore should work
03:14:09 <archduke_o_hell> hmm
03:14:34 <apfelmus> Saizan_: What's the easiest way to do that? I'm not keen on recompiling it again.
03:14:47 <archduke_o_hell> so its easier to wrote parallel programs in haskell than in scheme or common lisp?
03:15:00 <archduke_o_hell> that sounds important in the mdoern multi core dasy
03:16:05 <Saizan_> apfelmus: you can ghc-pkg describe wxcore > pkginfo, edit the version in pkginfo and then ghc-pkg register pkginfo
03:18:41 <Saizan_> archduke_o_hell: yeah, the second paper here should give an idea of the oppotunities in haskell: http://research.microsoft.com/en-us/um/people/simonpj/papers/parallel/
03:20:10 <apfelmus> Saizan_: Done. Ugh, but now cabal borks completely. "wx-0.11.1.2 failed while downloading the package."
03:23:21 <Saizan_> apfelmus: that looks network related, maybe retry with higher verbosity to see the HTTP traffic
03:24:58 <archduke_o_hell> hmmmmmmmmmmmmmmmm
03:25:05 <archduke_o_hell> are parallel programs a lot faster?
03:25:14 <archduke_o_hell> do they use all N cpu
03:25:20 <archduke_o_hell> thus being 4x as fast
03:25:21 <archduke_o_hell> wow
03:25:22 <archduke_o_hell> cool stuff
03:25:31 <ski> depends on the algorithm, and how it is mapped into code
03:25:44 <archduke_o_hell> I noticed a parallel gzip for linux
03:25:51 <archduke_o_hell> supposed to be much faster
03:26:08 <bremner> archduke_o_hell: there are several parallel gzips
03:26:48 <Gracenotes> it should be able to parallelize encoding compressed huffman blocks
03:28:06 <Gracenotes> it couldn't just start in the middle of a block after all :)
03:28:11 <apfelmus> Saizan_: Weird, "GET http://hackage.haskell.org/packages/archive/wx/0.11.1.2/wx-0.11.1.2.tar.gz" and then "wx-0.11.1.2 failed while downloading the package"
03:28:12 <apfelmus> But the trick with bumping the package version worked, thanks! :)
03:29:09 <Saizan_> apfelmus: so you got it installed manually?:)
03:29:30 <apfelmus> Yep, wxcore at least. Now I'm going to download wx manually.
03:33:32 <mgsloan> anyone here working on icfp? I figured i'd give it a go. nearly done with the VM par
03:33:42 <mgsloan> just for kicks
03:33:50 <apfelmus> Saizan_: Duh, the trick with rebranding wxcore-0.11.1.2 as wxcore-0.11.1.3 didn't quite work.
03:33:51 <apfelmus> Something is amiss; requested module  wxcore-0.11.1.3:Graphics.UI.WXCore.Types differs from name found in the interface file wxcore-0.11.1.2:Graphics.UI.WXCore.Types
03:34:09 <apfelmus> Looks like I'll have to recompile it.
03:34:45 <Saizan_> apfelmus: you could compile wx using runghc Setup, instead of cabal
03:34:58 <Saizan_> apfelmus: that won't go searching on hackage
03:35:21 <Saizan_> apfelmus: you need to unregister 0.11.1.3 first
03:35:33 <Saizan_> wxcore-0.11.1.3
03:35:37 <apfelmus> Saizan_: Ah!
03:35:53 <apfelmus> Just like I did with wx-core. Of course!
03:49:36 <apfelmus> Saizan_: Wee, it works! Thanks a lot for you help :)
03:49:52 <briml> How can I count the number of reductions in ghci (in hugs there is an option to do that)?
03:50:16 <apfelmus> briml: set +s
03:50:22 <apfelmus> * :set +s
03:50:32 <briml> apfelmus: thx bro
03:50:43 <apfelmus> briml: It shows time instead of reductions, though.
03:50:50 <apfelmus> But that's usually just as good.
03:53:27 <briml> apfelmus: the resolution is only milliseconds. that's a little to low for small expressions.
03:53:40 <smorg> Hi i'm reading about typeclasses. What happens with associativity when there are two or more arrows without parenthases in the type definition? Also, why would a non higher-order function have more than one map arrow?
03:54:35 <smorg> Are just two inputs to binary operators considered functions in themselves?
03:54:59 <smorg> for ex: (==) :: (Eq a) => a -> a -> Bool
03:55:24 <apfelmus> briml: Ah, ok, I can see that this is undesirable.
03:55:28 <|Jedai|> mgsloan: mmorrow is working on it (he had the VM working long ago I think)
03:55:43 <apfelmus> briml: Unfortunately, there's not much you can do.
03:55:50 <mgsloan> yeah, he probably did.  I only found out 2 hours ago that it was going on
03:55:51 <apfelmus> briml: Except maybe scale the times up.
03:55:56 <mgsloan> and i'm done with the VM :)
03:56:01 <mgsloan> testament to haskell rather than me
03:56:38 <ski> > map ((>) 4) [1,3,5,7]  -- smorg
03:56:39 <lambdabot>   [True,True,False,False]
03:57:02 <briml> apfelmus: if I compare two expressions that both give 0.01 sec it's a bit hard to scale it :)
03:57:08 <ski> smorg : here, `(>) :: Integer -> Integer -> Bool', so `(>) 4 :: Integer -> Bool'
03:57:22 <apfelmus> briml: Yes, I mean, you can repeat it say 100 times.
03:57:29 <|Jedai|> briml: The idea is to do each a lot of times
03:57:51 <ski> > filter ((>=) 5) [5,7,1,4,2,8]
03:57:53 <lambdabot>   [5,1,4,2]
03:57:55 <|Jedai|> briml: you have some benchmark package on Hackage that could help a little bit
03:58:05 <briml> what is a good ideom to repeat an expression?
03:58:26 <ski> it is not a good idea to repeat an expression
03:58:37 <|Jedai|> briml: that depends on the expression
03:58:38 <apfelmus> Yeah, due to laziness.
03:58:55 <briml> maybe just download hugs and get it done...
03:59:25 <|Jedai|> briml: the easiest is to put it into an IO function
03:59:57 <smorg> ski: ah so if you had: blub = (foo . bar . baz) you would have blub :: (type of foo) -> (type of baz)
04:00:08 <briml> there doesn't seem to be any active development of hugs any more
04:00:19 <|Jedai|> briml: Note that the number of reduction in Hugs may not be very indicative of the performance in GHC after optimization
04:01:06 <briml> I was comparing this expression: anyFoldr p xs = foldr (||) False (map p xs)
04:01:06 <ski> smorg : no
04:01:08 <|Jedai|> smorg: No
04:01:18 <briml> with this: anyFoldl p xs = foldl (||) False (map p xs)
04:01:30 <ski>   baz :: A -> B
04:01:30 <|Jedai|> briml: we can tell you then
04:01:35 <ski>   bar :: B -> C
04:01:37 <briml> implementation of any with fold
04:01:41 <|Jedai|> briml: the foldr is better
04:01:41 <ski>   foo :: C -> D
04:01:46 <ski>   blub :: A -> D
04:01:53 <briml> I wanted to confirm it in the interpreter
04:02:09 <|Jedai|> briml: and foldr (||) False is just or
04:02:09 <briml> but I'ts difficult to see any difference
04:02:44 <|Jedai|> briml: It's very easy, you just have to use a big list input
04:02:49 <ski> smorg : so if you wish, you could say roughly `blub :: <domain of baz> -> <codomain of foo>'
04:02:55 <ski> where
04:03:11 <ski>   foo :: <domain of foo> -> <codomain of foo>
04:03:16 <ski>   et.c.
04:03:28 <smorg> aah gotcha
04:04:10 <|Jedai|> > foldr (||) False (map (>1) [1..1000000])
04:04:11 <dibblego> briml, pass an infinite list to each
04:04:11 <ski> smorg : remember that `(foo . bar . baz) bork  =  foo (bar (baz bork))'
04:04:12 <lambdabot>   True
04:04:21 <|Jedai|> > foldl (||) False (map (>1) [1..1000000])
04:04:24 <lambdabot>   * Exception: stack overflow
04:04:25 <smorg> I was thinking $
04:04:32 <ski> smorg : so usually, one reads composition chains like that from the end
04:04:39 <|Jedai|> briml: I think that's quite a difference, no ?
04:04:45 <ski> smorg : it's the same with `$'
04:05:16 <ski>   (foo . bar . baz) bork  =  foo $ bar $ baz $ bork  =  foo (bar (baz bork))
04:06:08 <|Jedai|> @src any
04:06:09 <lambdabot> any p =  or . map p
04:06:18 <briml> i'm actually more interested in the shortcut behaviour of foldr
04:06:34 <briml> sorry
04:06:43 <briml> that's what you showed
04:06:47 <|Jedai|> briml: Do you mean that you want to understand how foldr is fast ?
04:07:06 <briml> no that I already understand
04:07:17 <briml> just want to do some measurements
04:07:58 <|Jedai|> Well comparing foldl and foldr isn't really interesting, foldl is always worse
04:08:24 <|Jedai|> Comparing foldr and foldl' is a little bit more interesting
04:08:54 <briml> Jedai: yes your right. I have confirmed it now
04:13:32 <ziman> foldl isn't always worese; somebody once made up an example where foldl was appropriate
04:13:44 <ziman> i can't remember it, though
04:13:49 <|Jedai|> ziman: appropriate yes
04:14:27 <|Jedai|> ziman: but in situation where the order don't matter, foldr can't be worse than foldl (though it can be worse than foldl')
04:15:20 <|Jedai|> ziman: "reverse = foldl (flip (:)) []" is an example where foldl ain't such a bad idea, you can find even better example
04:17:29 <|Jedai|> ziman: The trick is to find a function lazy in its first argument and very expensive to evaluate
04:18:07 <|Jedai|> ziman: and you need to start the evaluation by the end of the list
04:18:40 <|Jedai|> ziman: it can happen of course, but it's still not a situation you'll see in every program
04:19:12 <|Jedai|> thus it is reasonable to tell every beginner that he should only use foldr or foldl' but never foldl
04:22:23 <ziman> i see, thanks
04:24:44 <Peaker> if you implement reverse with foldr vs. foldl, what do you lose?
04:25:29 <smorg> So in the first example the domain of (>) is (Integer -> Integer)
04:25:39 <smorg> If that were true I would think (1 3) would have a type
04:29:01 <|Jedai|> Peaker: Try it and see :)
04:29:14 <Peaker> simplicity?
04:29:28 <|Jedai|> Peaker: at least :)
04:30:35 <Peaker> foldr lets me have reverse accumulation only, which is problematic for reverse, yeah :)
04:31:12 <smorg> Peaker: If haskell were to automatically simplify everything generally it would require one hell of an automated theorem prover. So I assume the solution is that it just doesn't try.
04:31:27 <Peaker> smorg: ?
04:31:52 <Peaker> smorg: I was wondering about foldr instead of foldl for reverse
04:32:28 <smorg> oh which is generally faster.
04:32:52 <|Jedai|> Peaker: to write reverse with foldr : reverse = foldr (flip (++) . return) []
04:32:58 <|Jedai|> Peaker: it's slow
04:33:17 <Peaker> |Jedai|: I wondered if there was a clever trick to avoid the quadratic cost
04:33:32 <|Jedai|> Peaker: There may be one..
04:35:11 <|Jedai|> Peaker: this reverse is not quadratic though
04:35:24 <|Jedai|> Peaker: it's linear AFAIK
04:35:47 <|Jedai|> Peaker: but it's pretty expensive nonetheless
04:36:10 <Peaker> |Jedai|: That (++) there is O(N), and happens O(N) times
04:36:35 <|Jedai|> Peaker: No
04:36:46 <Peaker> |Jedai|: why not?
04:36:54 <ziman> (++) is O(N) where N is the length of the *left* argument, which is always a one-element list
04:37:07 <Peaker> if it was a one-element list, you'd use (:) and not (++) ?
04:37:39 <Peaker> the (++) here is between N elements on the left side, and 1 element on the right
04:37:46 <Peaker> @type flip (++) . return
04:37:47 <lambdabot> forall a. a -> [a] -> [a]
04:37:47 <ziman> hm, true
04:38:11 <Peaker> > (flip (++) . return) 1 [3,4,5]
04:38:13 <lambdabot>   [3,4,5,1]
04:38:14 <ziman> is it?
04:38:15 <|Jedai|> Peaker: You're right, it seems to be quadratic, but the times I'm seeing don't support this... o_O
04:39:06 <Peaker> @hoogle getTime
04:39:06 <lambdabot> Data.Time.LocalTime getTimeZone :: UTCTime -> IO TimeZone
04:39:13 <Peaker> @hoogle currentTime
04:39:13 <lambdabot> Data.Time.Clock getCurrentTime :: IO UTCTime
04:39:14 <lambdabot> Data.Time.LocalTime getCurrentTimeZone :: IO TimeZone
04:41:27 <|Jedai|> foldr (\x f -> f . (x:)) id
04:41:42 <|Jedai|> Peaker: That's the efficient foldr version
04:41:47 <Peaker> ah, DLists, right
04:41:52 <Peaker> the "clever trick" :-)
04:41:59 <Peaker> @hoogle UTCTime -> UTCTime -> a
04:42:00 <lambdabot> Prelude asTypeOf :: a -> a -> a
04:42:00 <lambdabot> Data.Time.Clock diffUTCTime :: UTCTime -> UTCTime -> NominalDiffTime
04:42:00 <lambdabot> Control.Parallel par :: a -> b -> b
04:42:08 <Peaker> why isn't UTCTime a Num instance?
04:42:35 <Peaker> I guess it makes no sense to add them
04:42:43 <Saizan_> ?type foldr (\x f -> f . (x:)) id
04:42:45 <lambdabot> forall a. [a] -> [a] -> [a]
04:43:01 <Saizan_> ?type \g -> foldr (\x f -> f . (g x)) id
04:43:02 <lambdabot> forall a a1. (a -> a1 -> a1) -> [a] -> a1 -> a1
04:43:10 <|Jedai|> Saizan_: Well, you have to apply the result to []
04:43:53 <Saizan_> just stressing that the "clever trick" is to implement foldl and inline it :)
04:44:46 <|Jedai|> Saizan_ : Right, though you can also see it as an use of the DList trick on the naive reverse with foldr
04:45:12 <Peaker> Saizan_: foldl in terms of foldr, you mean?
04:45:25 <Peaker> |Jedai|: The times I'm measuring do support N^2 times, btw
04:45:40 <Peaker> even worse
04:46:36 <Cale> Do it on a list of length 100000 and you'll easily see it :)
04:47:10 <Peaker> Using: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6297#a6297
04:47:35 <Peaker> Cale: well, I want to sample the O() function at several points and see how it behaves.. Seems to be even worse than O(N^2)
04:47:38 <|Jedai|> Peaker: Strange (or rather normal, my observation though showed a passage from 0.16 to 0.36 for n*2, which wasn't frankly quadratic)
04:47:46 <Peaker> which makes sense on smaller numbers due to cache locality
04:48:15 <Peaker> |Jedai|: I think for really small numbers, the function call and time measurement overheads dominate the time
04:48:38 <Cale> You can't really tell if a function is quadratic by sampling at 2 points...
04:48:57 <Peaker> Cale: you always have the N=0 -> 0 sample, theoretically
04:48:58 <|Jedai|> Cale: I sampled at more points
04:49:04 <Peaker> or not, actually :)
04:49:15 <Peaker> but very close
04:49:18 <|Jedai|> But I guess my length were too small
04:49:25 <Cale> Eh?
04:49:34 <Cale> f(0) might not be 0...
04:49:52 <|Jedai|> given that this reverse can stack overflow I restrained myself to rather modest amount
04:49:55 <Peaker> Cale: N=0 should yield very very close to 0 in here..
04:50:10 <Cale> It gives some positive constant :)
04:50:29 <Peaker> negligible compares to N=10000 or so, though
04:50:32 <Peaker> compared
04:53:43 <Peaker> btw, a friend of mine expanded on my idea of MList and we think his extension can really replace Iteratee with something simpler and more general, while getting all of the benefits. No yucky "Error String" in there, either :)
04:54:10 <Peaker> its hard to find anyone knowledgable of Iteratee in #haskell, though, which is a shame because lazy I/O is such a cheat so not in the spirit of Haskell
04:54:29 <Cale> I don't think lazy I/O is really so bad.
04:54:35 <Cale> It's really good at what it's good at.
04:55:30 <Cale> It would be better if operating systems had fewer needless limitations. (Like a fixed maximum number of open files)
04:57:34 <Peaker> Cale: its not just abuse of open files - its also the fact that coercing the complex semantics of file reading/etc (with potential errors et/al) into the simple semantics of a pure value (e.g a list) is wrong
04:57:40 <Peaker> Cale: bad error handling
04:58:07 <Peaker> Cale: also, open files can cost real resources (external sockets)
04:58:31 <Cale> Lazy I/O is good when error handling is not a concern. There are a large number of small programs where it's just not important what to do when the file isn't there, or disappears in the middle of reading, or something.
04:58:51 <Peaker> "small programs" as in trivial programs?
04:59:10 <Cale> Not necessarily trivial, but perhaps trivial in terms of the I/O they do.
04:59:18 <Peaker> would you like to be notified if your result is truncated due to errors in the input file? Better to have a bottom than an empty list in hGetContents then
04:59:33 <Peaker> but pure exceptions are also horrible
04:59:55 <Cale> only if you try to catch them :)
05:00:25 <Peaker> What disadvantages do you think the "right" way (Iteratees come close) has?
05:00:43 <Peaker> Why prefer lazy I/O to something that is just as short, performs better (according to their benchmarks) and handles errors correctly?
05:02:17 <Cale> I'm not clear on the code being just as short
05:02:38 <Cale> Or the types being as simple...
05:03:05 <Peaker> but the types are a little more complicated because they encapsulate the real semantics, rather than fake ones.   Just like we prefer IO () to ()
05:03:18 <Cale> I'm not all that familiar with the idiom, but all the code I've seen has been very olegish and hard to follow.
05:03:49 <Peaker> Cale: Well, the low-level code, perhaps.  The higher level that uses combinators is pretty simple.  And I think me and yairchu simplify on that
05:04:47 <tibbe> Peaker: I have decent knowledge of iteratee stuff
05:04:50 <Peaker> you have an Iteratee monad transformer, where your monadic operation is like in Data.Binary.Get -- e.g:  input some stuff:   do { line <- getLine ; liftIO . print $ "blah" }
05:05:07 <Peaker> tibbe: cool! I wanted to discuss a potential alternative, to see if it really has any disadvantages over iteratee
05:05:17 <Peaker> tibbe: because all I can see so far is advantages, but I might be missing something
05:05:55 <Pistahh> hi
05:06:08 <Peaker> tibbe: Have you see MList? It was my first attempt at replacing lazy I/O (Before understanding Iteratee).  Its basically a list, defined recursively like a normal list, but each list is wrapped in a monadic action
05:06:29 <tibbe> Peaker: I don't think so, could you paste a link?
05:06:31 <Peaker> The problem with MList is that you can re-access old elements, or access stuff after the file has been closed/etc.
05:06:39 <Pistahh> in the source of Codec.Archive.Zip there is a line: "toArchive = runGet getArchive" however I can absolutely nowhere find any reference for "runGet".. how can I find it?
05:07:03 <ivanm> @hoogle runGet
05:07:04 <lambdabot> No results found
05:07:17 <Peaker> tibbe: http://hackage.haskell.org/package/mlist
05:07:17 <tibbe> Peaker: I see, that can be a problem
05:08:17 <tibbe> Peaker: reading
05:08:28 <Peaker> tibbe: so my friend made a change:  MList exposes only (lower-case) constructors, but not de-constructors, so you can't pattern-match.  The only way you can "read" an MList, is by building a Consumer.  A Consumer is a monad transformer, built around the "next" primitive which reads a single element
05:08:34 * tibbe is watching the rain poar down outside
05:09:21 <tibbe> Peaker: I think what iteratee achieves is resource guarantess by inversion of control
05:09:22 <Cale> Peaker: How is that better than using strict I/O in small amounts though?
05:09:30 <ivanm> tibbe: watching rain pour up is _much_ more interesting!
05:09:38 <Peaker> tibbe: Well, here you achieve resource guarantees by wrapping the getting in a monad
05:09:44 <tibbe> any pull/stream interface suffers from harder to reason about resource usage
05:09:58 <tibbe> Peaker: I see
05:10:28 <Peaker> tibbe: you can't just get whenever you want, only in a Consumer monad which reads the whole Producer (or MList, we need to decide on a name), of course up to early terminations
05:10:31 <tibbe> Peaker: and I guess you can compose stream processors just like you compose functions on lists
05:10:45 <Peaker> tibbe: Consumers are monads just like Iteratees.  Composing MLists is possible with "append" et-al
05:11:23 <Peaker> Cale: you have higher-level consumers that you can use
05:11:26 <tibbe> Peaker: so consumers are folds and MLists are more like Java style iterators except they can only be used in the context of a Consumer?
05:11:43 <Peaker> tibbe: Yeah
05:12:00 <tibbe> Cale: I'm not sure I understood your question but iteratees are composable in ways simple strict monadic I/O isn't
05:12:18 <Peaker> tibbe: I think there's a problem in either approach, and that is that IterateeGM/ConsumerT can do IO stuff that blocks indefinitely while the producer has open files/etc
05:12:21 <tibbe> the idea is actually quite simple, it's simply inversion of control
05:12:59 <Peaker> hey yairchu, talking about MLists/Procon
05:13:04 <yairchu> yo
05:13:06 <Peaker> and /Iteratees
05:13:08 <tibbe> Peaker: hmm, I guess that's the inverse problem of lazy I/O where a consumer can never release a resource
05:13:23 <Oejet> Is there a way to concurrently install an older version of a library from Hackage?
05:13:39 <Peaker> Oejet: cabal install package-version
05:14:21 <Peaker> yairchu: I was thinking, maybe MLists are O(len left-list) for append, and producers are more like DLists (i.e: O(1) appending)
05:14:22 <tibbe> here's a question about lazy I/O: how come Java/Python etc provide close() for all iterators that allocated resources but we don't use that for lazy I/O in Haskell?
05:14:36 <Cale> tibbe: can you give an example of a way in which strict IO is not composable which this is?
05:15:23 <tibbe> Cale: I'm not 100% sure about this. But writing e.g. a parser in direct style requires explicitly keeping track of an input buffer
05:15:50 <yairchu> Peaker: maybe, cool if so
05:15:53 <tibbe> iteratees are simply stream processors and they compose as monads
05:16:04 <tibbe> (it's a state monad really)
05:16:57 <tibbe> Cale: so I guess that if you used StateT ByteString IO you could achieve the same thing except in a "pull" style
05:18:20 <tibbe> I think my main beef with lazy I/O is that it somehow led to people writing stream processors of type Lazy.ByteString -> Lazy.ByteString which can only be used with lazy I/O.
05:18:42 <tibbe> so you end up with a bunch of libraries that can only be used in programs where lazy I/O is OK (i.e. smallish programs)
05:19:43 <tibbe> in many instances those libraries could expose enough functionality so you can use them both for lazy I/O and other styles of I/O (include simple monadic I/O)
05:20:06 <tibbe> binary is a good example, gzip another
05:20:13 <Peaker> @type \act -> act >>= \x -> x `seq` return x
05:20:14 <lambdabot> forall a (m :: * -> *). (Monad m) => m a -> m a
05:20:47 <Peaker> tibbe: Data.Binary sucks :-(
05:21:00 <Peaker> Get sucks because it has no error handling. Put sucks because its a Monad when it should be a Monoid
05:21:04 <tibbe> Peaker: well, it's well implemented but doesn't suit my use cases
05:21:07 * Cale totally fails to comprehend the haddock for Data.Iteratee.Base
05:21:13 <tibbe> Peaker: and that
05:21:22 <Peaker> Cale: I think the names in Iteratee are really confusing
05:21:47 <tibbe> Cale: yes it's a bit difficult to understand, the new version of Hyena will have a simpler definition of iteratees that is hopefully easier to understand
05:21:52 <tibbe> Peaker: me too
05:21:56 <Peaker> Cale: An Iteratee is a Consumer.  A consumer is defined as either a satisfied consumer (and here's my result), or a hungry consumer (and here's a function that eats a stream input, and returns a tad-more-satisfied consumer)
05:22:02 <tibbe> Peaker: but it's hard to come up with better ones
05:22:17 <Saizan_> Pistahh: runGet is from the binary package, probably
05:22:25 <tibbe> data Person = Full | Hungry
05:22:42 <Peaker> tibbe: here's my take on Iteratee, with IMO better names: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2892#a2892
05:23:22 <|Jedai|> Cale: I agree that Iteratee is pretty hard to understand, I think we really need a good friendly tutorial for it
05:23:22 <tibbe> Peaker: Consumer might be a better name
05:23:23 <Peaker> tibbe: I was hoping that a "proper" iteratee can also be used in place of Data.Binary
05:23:24 <ivanm> tibbe: and which one are you? ;-)
05:23:49 <tibbe> Peaker: I think iteratee was appropriate in the initial fold definition, now it's generalized a bit and could use another name
05:24:09 <Peaker> tibbe: I really dislike the inelegance in the Iteratee package (yucky: Error String stuff)
05:24:09 <tibbe> ivanm: | Confused
05:24:22 <ivanm> heh
05:24:22 <Peaker> tibbe: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2892#a2892 -- I tried writing Iteratee without yuckiness such as that
05:24:23 <Pistahh> Saizan_: ah, thanks
05:24:28 <Cale> I am still not convinced that it is simple enough to be good for anything ;)
05:24:39 <tibbe> Peaker: yes, I was thinking (SomeException e) which is often the exception caught when the error occured
05:25:07 <tibbe> Peaker: the name I am pretty confident in is: data Chunk = Chunk ByteString | EOF
05:25:14 <Peaker> tibbe: I think most iteratee stuff doesn't even care about the error stuff so shouldn't have it in the type
05:25:22 <Peaker> tibbe: isn't it called Stream?
05:25:39 <tibbe> Cale: you can look at it the other way around, lazy I/O is to simple to write e.g. servers and stay sane ;)
05:25:41 <Peaker> tibbe: I have it as: data StreamInput endType messageType = Message messageType | End endType
05:26:03 <Cale> tibbe: well, yeah, I suppose I'm not comparing it with lazy I/O
05:26:22 <tibbe> Peaker: yes, but it's not a stream. a stream would be: data Stream = Chunk ByteString Stream | EOF
05:26:32 <Cale> tibbe: I'm comparing it with the sort of server which uses strict I/O properly.
05:27:07 <tibbe> Cale: what would that look like (I'm genuinely curious as I've spent lots of time hacking on hyena, an http server)
05:27:09 <Peaker> tibbe: Right, its a StreamInput, not a Stream :-)
05:27:12 <Peaker> tibbe: perhaps a StreamElement
05:27:22 <tibbe> Peaker: Chunk ;)
05:27:39 <Peaker> tibbe: maybe its not a chunk though.. you could just use Maybe Chunk or  Either endType chunkType
05:27:42 <Cale> tibbe: Well, I'm not sure how to describe it. There's lots of that sort of code lying around.
05:28:03 <Peaker> Cale: if you have strict I/O, usually your "consumer" is just a function that explicitly calls "getLine" on some file descriptor or what-not.  Its not consuming from a composable producer
05:28:12 <tibbe> Cale: I think I've looked at more or less every haskell web server out there
05:28:35 <ski> Peaker : would it be a good idea to add a constructor to `ConsumerG m msg a' with argument of type `ConsumerM m msg a' ?
05:28:36 <Cale> Peaker: It could take an IO action as a parameter if that's any better ;)
05:28:39 <tibbe> Cale: the problem comes when you want to do nested stream processing, i.e. HTTP chunk decoding
05:29:04 <tibbe> Cale: HTTP pipelining is also difficult as you might have several HTTP requests in your buffer, split at an arbitrary point
05:29:04 <Peaker> ski: To allow "peeking", you mean?
05:29:16 <Peaker> Cale: that reads how much?
05:29:18 <ski> Peaker : yes, e.g.
05:29:26 <Peaker> ski: I thought about it.. it could be nice, maybe
05:29:50 <tibbe> Cale: but if you have a nice example of a server I'm all ears
05:30:02 <Peaker> ski: I think maybe peeking can be built on top somehow
05:30:17 <Oejet> Peaker: Ah, thank you, it worked. However happs-tutorial do not detect those earlier requiered versions, so I still get this: "cabal: cannot configure happstack-helpers-0.22.1. It requires happstack-data ==0.2.*".
05:30:38 <Cale> tibbe: I'm really not familiar with http server implementations, so I don't know. Perhaps they are just super-complicated, and require something like this to do nicely.
05:30:47 <ski> Peaker : or consider a transformer that transforms `ConsumerG m a b' into `ConsumerG m b c', but sometimes, a `b' item from the first generates no `c' item in the output at all
05:31:11 <Cale> But talking about a library like this as a replacement for lazy I/O, or even normal strict I/O... doesn't really make sense.
05:31:29 <ski> (er, into `ConsumerG m a c', i suppose .. i confused myself)
05:31:30 <tibbe> Cale: well, quite complicated anyway. Parsing HTTP requests properly is hard. the length of messages is not know, you have to do nested stream processing at several levels
05:31:50 <Cale> tibbe: Why is it not just something you can do with Parsec, say?
05:32:01 <tibbe> Cale: parsec requires lazy I/O
05:33:52 <tibbe> (In addition to being way too slow)
05:33:58 <Saizan_> not with parsec-3, but it's not stackable i guess
05:34:03 <Cale> er, does it really?
05:34:40 <Saizan_> in an http server you don't want to read all the message from the network before starting to parse it
05:34:43 <tibbe> Cale: http://github.com/tibbe/hyena/blob/1296f0a5c0ce55af307c573e322ec22fbc74f9db/Hyena/Parser.hs <- simple resumable parser I use
05:34:46 * ski wonders whether the `End' constructor is really needed ..
05:34:59 <tibbe> Cale: onless it changed its input type from String
05:35:21 <Cale> tibbe: you can write an instance of Stream for any type you like...
05:35:29 <tibbe> Saizan_: with pipelined I/O it's even worse, you might read many messages
05:36:41 <tibbe> Cale: how is Stream defined?
05:36:53 <Cale> class Monad m => Stream s m t | s -> t where uncons :: s -> m (Maybe (t, s))
05:37:17 <Cale> t is the token type, s is the stream type
05:37:30 <Cale> Parsec will work on any instance of that class
05:37:41 <tibbe> Cale: hmm, I see, then you can use it
05:38:05 <tibbe> except you have the lazy I/O problem of having to force the result and manually close the stream
05:38:30 <tibbe> Cale: that's really just a normal Java style iterator interface
05:38:33 <Cale> Or you could write an instance for IO actions which read tokens.
05:39:05 <tibbe> uncons = next() in Java/Python
05:39:07 <Cale> (and use strict IO)
05:39:35 <tibbe> so it returns uncosumed parts of the stream?
05:40:30 <tibbe> Cale: but at this point you're not far from iteratees, they're more or less a fold over the parse function
05:40:45 <tibbe> well not exactly
05:40:50 <tibbe> here parsec does the reading
05:41:35 <tibbe> although parsec is not quite enough here. you need to interleave parsing and sending data to the "handler"
05:41:38 <Cale> perhaps something like  instance Stream (IO t) IO t where uncons x = catch (do t <- x; return (Just (t,x))) (\SomeException e -> return Nothing)
05:41:39 <tibbe> as in http chunk encoding
05:41:55 <Cale> Parsec is a monad transformer
05:42:01 <tibbe> so is iteratee
05:42:06 <tibbe> it's a state monad transformer
05:42:29 <tibbe> where the wrapped monad can perform side effects on every received chunk
05:42:55 <Cale> So is the idea that Iteratee is like a confusing version of Parsec then? :)
05:43:22 <tibbe> data IterateeT = IterateeT (Chunk -> m (a, ResultT m))
05:43:30 <tibbe> Cale: no, the control is inversed
05:43:58 <tibbe> data ResultT m a = Done a Chunk | Cont (IterateeT m a)
05:44:06 <tibbe> it's similar to stream fusion as well
05:44:20 <tibbe> you can see the similar to the Step type in ResultT
05:44:40 <tibbe> Cale: Iteratee is more live a event driven architecture
05:45:22 <tibbe> so at any point I can have a large number of Cont suspensions, one per connected client, and I advance those who have new data using e.g. epoll to find which ones
05:45:36 <tibbe> i.e. keep a Map FileDesc Iteratee
05:45:55 <tibbe> and have epoll :: EpollFD -> [FileDesc]
05:46:25 <tibbe> the reason the parsec performs well at all is because of the way GHC implements I/O
05:46:41 <Cale> eh?
05:47:30 <tibbe> sorry
05:47:49 <tibbe> so, Iteratees inversion of control model is easier to implement efficiently in a server
05:47:51 <Cale> What about GHC's I/O implementation is it?
05:48:02 <tibbe> as it's suitable to event driven architectures
05:48:56 <Cale> What does this epoll do?
05:48:59 <tibbe> if you look at the way e.g. read is implemented in GHC you can see they play some smart tricks to make it decently efficient
05:49:27 <tibbe> Cale: epoll is an efficient way to wait for events on lots of file descriptors
05:49:41 <Cale> More efficient than just creating threads?
05:49:43 <tibbe> it's what you use to implement fast servers on Linux (BSD had kqueue)
05:49:48 <tibbe> Cale: yes
05:49:56 <Cale> (haskell threads, not OS threads)
05:50:01 <tibbe> Cale: yes
05:50:32 <tibbe> Cale: haskell threads are implemented using select, a slower form of epoll, plus some tricks to make an event driven system into a more traditional threaded one
05:50:49 <tibbe> Cale: you can see how by looking at threadWaitRead which is called before read operations
05:51:23 <tibbe> anyway, my point was that iteratees can be implemented efficiently
06:19:21 <cjay> is there a way to show the modules in scope when using a ghci prompt without %s?
06:22:54 <Twey> cjay: :show modules according to :h
06:23:13 <FliP^2eH> :t map
06:23:14 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
06:23:33 <FliP^2eH> I now finally know what forall means, thank god..
06:26:12 <ski> then you're ready for rank-[2,n] polymorphism, polymorphic data constructors arguments, "existential data types" ?
06:29:38 <FunctorSalad> btw is there any advantage to the rank2 pragma?
06:29:42 <FunctorSalad> compare to rankn
06:30:13 <FunctorSalad> compared, even
06:30:47 <ski> iirc Hugs only supports up to rank-2 polymorphism
06:34:26 <FliP^2eH> > take 9999 [1..]
06:34:30 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
06:36:11 <dsturnbull> i wonder if that's fully lazy :)
06:36:57 <FliP^2eH> > take 10 . drop 10 $ [1..]
06:36:58 <lambdabot>   [11,12,13,14,15,16,17,18,19,20]
06:37:05 <FunctorSalad> quite a few web frameworks by now... any pointers on where to get started?
06:37:13 <FliP^2eH> > take 11 . drop 10 $ [1..]
06:37:14 <lambdabot>   [11,12,13,14,15,16,17,18,19,20,21]
06:37:39 <FliP^2eH> > "1+3+3=" ++ show $ 1+3+3
06:37:40 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
06:37:42 <FliP^2eH> :(
06:37:51 <FliP^2eH> > ("1+3+3=" ++ show $ 1+3+3)
06:37:52 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
06:37:54 <FliP^2eH> :(((
06:38:16 <Saizan_> > "1+3+3=" ++ (show $ 1+3+3)
06:38:18 <lambdabot>   "1+3+3=7"
06:38:33 <Saizan_> $ has the lowest precedence
06:52:41 <FliP^2eH> > getLine >>= (\x -> putStrLn $ "Hello, " ++ x)
06:52:42 <lambdabot>   <IO ()>
06:52:45 <FliP^2eH> :)
06:52:55 <FliP^2eH> Who needs DO?
06:53:50 <ben> People with nontrivial IO needs?
06:54:06 <FliP^2eH> Tru dat
06:55:37 <Twey> > getline >>= putStrLn . ("Hello, " ++)
06:55:39 <lambdabot>   Not in scope: `getline'
06:55:44 <Twey> Whoops
06:55:47 <Twey> > getLine >>= putStrLn . ("Hello, " ++)
06:55:49 <lambdabot>   <IO ()>
06:56:05 <FliP^2eH> Meh
06:56:07 * Beelsebob prefers to use =<< in that case
06:56:13 <Beelsebob> it keeps the whole thing going in the same direction
06:56:25 <Beelsebob> > putStrLn . ("Hello, " ++) =<< getLine
06:56:27 <lambdabot>   <IO ()>
06:56:29 <Twey> I guess it does
06:56:59 <Twey> I've become too familiar with the reader >>= writer . modifier idiom
06:57:03 <Twey> I've been blinded
06:58:11 <FliP^2eH> Now how would you write "do s1 <- getLine; s2 <- getLine; putStrLn $ s1 ++ s2" in point freE?
06:58:36 <ski>   putStrLn =<< liftM2 (++) getLine getLine
06:59:03 <Twey> putStrLn =<< join (liftM2 (++)) getLine
06:59:24 <FliP^2eH> I feel stupid again :(
06:59:35 <Beelsebob> putStrLn =<< (getLine <^(++)^> getLine)
06:59:38 <Berengal> What's your favorite one-liner to show off haskell to others?
06:59:54 <Beelsebob> fmap fmap fmap sequence fmap
06:59:55 <Beelsebob> >.>
06:59:58 <Twey> Hahaha
07:00:14 <Berengal> @type fmap fmap fmap sequence fmap
07:00:14 <Twey> I'm pretty sure Berengal said âshow off Haskell to othersâ, not âscare others off Haskellâ
07:00:16 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => (a1 -> m a) -> [a1] -> m [a]
07:00:23 <Beelsebob> Twey: :P
07:00:26 <Berengal> That's pretty clever
07:00:31 <Beelsebob> Berengal: it's mapM, but working on applicatives
07:00:39 <marred> Hi, I have some problems installing wash. Could anyone help me?
07:00:41 <Beelsebob> (assuming you write sequence right)
07:00:47 <Twey> A couple of seconds to show, several hours to explain
07:00:54 <Beelsebob> Twey: :D
07:00:54 <Berengal> Beelsebob: sequence is monad spesific, no?
07:01:00 <Berengal> No, wiat, it's not
07:01:06 <Twey> :t sequence
07:01:08 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
07:01:17 <Twey> I usually go with the good ol' qsort.
07:01:21 <Beelsebob> sequence = foldr (liftA2 (:)) (pure [])
07:01:35 <ski> @type Data.Traversable.sequenceA
07:01:36 <lambdabot> forall (t :: * -> *) (f :: * -> *) a. (Data.Traversable.Traversable t, Applicative f) => t (f a) -> f (t a)
07:01:46 <Beelsebob> yep, what ski said
07:01:53 <Berengal> I've usually got with the fibs zipWith
07:02:40 <Beelsebob> in more serious terms -- a parallel raytracer is a good start
07:02:51 <Beelsebob> but not a one liner
07:02:55 <ski> @type foldr (zipWith (:)) (repeat [])
07:02:56 <lambdabot> forall a. [[a]] -> [[a]]
07:02:57 <Twey> Haha, I was about to say
07:03:00 <Beelsebob> (unless you can gloss over the castRay function)
07:03:06 <Twey> You wrote a one-liner parallel raytracer?!?!
07:03:30 <Beelsebob> Twey: it was a *very* long line
07:03:46 <Berengal> I also like a prime-isPrime-factorize mutually recursive chain
07:04:13 <Twey> Beelsebob: *grin*
07:12:01 <Cale> marred: what problem are you having?
07:14:40 <FliP^2eH> I start liking points free
07:15:48 <FliP^2eH> "getClockTime >>= toCalendarTime >>= return . formatTime" is just way better than 3 lines
07:16:23 <Beelsebob> @type toCalendarTime
07:16:25 <lambdabot> Not in scope: `toCalendarTime'
07:16:34 <Beelsebob> why is toCalendarTime monadic?
07:16:39 <Twey> FliP^2eH: âfmap formatTime $ getClockTime >>= toCalendarTimeâ is even better :)
07:16:46 <Twey> Beelsebob: Because it uses the system's timezone
07:16:50 <Beelsebob> ah, I see
07:16:58 <Twey> +settings
07:17:10 <Beelsebob> fmap formatTime $ toColendarTime =<< getClockTime
07:17:14 <FliP^2eH> Twey, why is using fmap better?
07:17:25 <Beelsebob> FliP^2eH: saves some space
07:17:32 <Twey> Because (return .) looks nasty
07:17:34 <Beelsebob> saves you a return and a .
07:17:47 <Twey> Also, it's in a weird place in terms of flow
07:17:48 <FliP^2eH> :$
07:17:56 <Beelsebob> (return .) is code for "I used the wrong version of fmap"
07:18:02 <Twey> Heheh
07:19:00 <Cale> If you're going to fmap over it, =<< might be nicer :)
07:19:21 <Twey> Beelsebob already suggested that
07:19:25 <Twey> I'm not sure I agree
07:19:45 <Twey> The $ separates them for me, so there's no expectation of flow between the two sides
07:19:46 <Cale> It keeps the data moving right to left
07:19:51 <ski>   liftM formatTime . toCalendarTime =<< getClockTime
07:20:24 <skorpan> (.) has higher precedence than =<< right?
07:20:27 <Saizan_> ski++
07:20:29 <ski> yes
07:20:44 <Twey> Shouldn't that be âliftM formatTime =<< toCalendarTime =<< getClockTimeâ?
07:20:53 <ski> try it
07:21:00 <skorpan> :t toCalendarTime
07:21:02 <lambdabot> Not in scope: `toCalendarTime'
07:21:04 <skorpan> meh
07:21:09 <Twey> :(
07:21:14 <Twey> Where's that?  Data.Time?
07:21:20 <Saizan_> you want "return ." there, like in the original version
07:21:21 <skorpan> @index toCalendarTime
07:21:21 <lambdabot> System.Time
07:22:02 <Twey> Yeah, ski's is an error
07:22:07 <Saizan_> no
07:22:11 <Twey> So's mine, though
07:22:18 <Saizan_> yours is an error
07:22:23 <Saizan_> but ski's is correct
07:22:25 <Twey>     Couldn't match expected type `System.Locale.TimeLocale'
07:22:25 <Twey>            against inferred type `CalendarTime'
07:22:35 <Twey> For: Prelude Data.List Data.Time System.Time Control.Monad> :t liftM formatTime . toCalendarTime =<< getClockTime
07:22:38 <Saizan_> well, as far as monads go
07:22:56 <Twey> Ah, right
07:23:12 * ski hasn't actually looked at the types .. just at what FliP^2eH initially gave
07:24:34 <Saizan_> FliP^2eH: you deceived us :)
07:24:34 <Twey> formatTime wants a System.Locale.TimeLocale... hmm
07:24:39 <FliP^2eH> :)
07:24:40 <Twey> Hehe
07:26:44 <ski> @index formatTime
07:26:45 <lambdabot> bzzt
08:28:17 * SamB wonders why conditionalize isn't in the dictionary -- it's not even in the spelling dictionary
08:29:03 <monochrom> because the verb is already "condition"
08:29:31 <monochrom> Example: People are conditioned to add -ize to create verbs.
08:29:59 <monochrom> Anyway English is a scam.
08:30:53 <dsturnbull> haha
08:30:57 <Adamant> English is Borg
08:30:58 <Adamant> more like
08:32:03 <Axman6> assimilate!
08:36:45 <bremner> resistancizing is futile
08:38:28 <kaol> prepare to be assimilitacized
08:52:55 <Twey> Conditionalizingalismizingalismizing
08:53:18 <Axman6> -ification
08:58:23 <bremner> now it sounds German
09:07:30 <ski> Constantinopolitanischerdudelsackpfeifenmachergesellschaft !
09:07:43 <ski> (that's "german")
09:09:52 <conal> thoughtpolice: ping
09:09:52 <Zao> Company that makes constantinopolitan dudelsack pipes.
09:09:59 <Zao> Am I remotely correct in my translation?
09:10:04 <conal> @seen thoughtpolice
09:10:04 <lambdabot> thoughtpolice is in #haskell, #ghc, #haskell-blah and #haskell-in-depth. I last heard thoughtpolice speak 6h 5m 5s ago.
09:10:25 <conal> copumpkin: ping
09:10:40 <conal> @seen copumpkin
09:10:40 <lambdabot> copumpkin is in #haskell-iphone, #haskell, #haskell.it, #darcs, #ghc, #haskell-in-depth and #haskell-blah. I last heard copumpkin speak 6h 41m 20s ago.
09:12:07 <ski> (Zao : you'd have to ask Samuel Clemens)
09:12:52 <Zao> Bothersome language, you need to have a dictionary to tokenize compound words.
09:14:06 <ski> (Zao : though i think "gesellschaft" is "guild")
09:15:11 <ski> (and "Constantinopolitanischer" is "resident in Constantinople")
09:17:11 <maltem> it's Constantinopolitan
09:17:30 <maltem> unless there's no difference :)
09:18:40 <maltem> Gesellschaft is association, normally
09:20:31 <ski> "Constantinopolitan" would be a person resident in Constantinople, i think, while "Constantinopolitanischer" would be something related to (such as coming from) Constantinople, i think. in this case i said "resident in" because i was talking about "guild"
09:21:05 <ski> but it's quite possible "gesellschaft" in modern german is better translated to "association"
09:21:11 * maltem just came in and has got no context :)
09:21:21 <Zao> This is as information dense as a line of Haskell.
09:21:35 <Zao> 18:07 < ski> Constantinopolitanischerdudelsackpfeifenmachergesellschaft !
09:22:17 * ski was translating "gesellschaft" to (roughly) "gesällskap" in swedish, and then to "guild" .. this might be a leap in translation
09:22:49 <ski> (Zao : you should see the next three lines, then :)
09:23:31 <maltem> guild, as in medieval times, is Zunft
09:23:58 <maltem> but whatever, as I told you I'm context-free
09:25:10 <maltem> or is this just about that word?
09:25:59 <maltem> It's not legal German anyways fwiw :)
09:26:16 <ski> <ski> (that's "german")
09:26:26 <maltem> ok :)
09:27:49 <ski> (people were adding endings to make words longer, when i made that quotation)
09:34:21 <jkramer> Ahoy
09:34:38 <Heffalump> hi
09:34:55 <jkramer> Is there a function to update an element at a given index in a list and return the new list?
09:35:09 <jkramer> Like [a] -> Int -> (a -> a) -> [a]
09:36:08 <maltem> jkramer, I'd say use splitAt, replace the element by hand, and concatenate
09:36:42 <jkramer> Sure, I just thought there might be a prelude function for such a common task
09:37:19 <monochrom> Not in standard library.
09:37:24 <maltem> You'll find that you won't want to do this very often, though, due to the whole operation taking time linear in the given index
09:37:29 <monochrom> No one uses it anyway.
09:38:16 <monochrom> Use an array or Data.Sequence.
09:38:59 <copumpkin> an Array would be just as painful to update a particular list of, wouldn't it? unless it's a DiffArray or a mutable one
09:39:19 <monochrom> oops, yeah I had mutable array in mind.
09:39:49 <copumpkin> I wonder why DiffArray is so slow... it seems like a nice idea on paper
09:40:13 <monochrom> It is an unsolved mystery. Seriously.
09:40:47 <twanvl> because of MVar?
09:41:05 <monochrom> I guess no one uses DiffArray enough to bother find out. Same story with Data.HashTable.
09:42:26 <SamB> I heard it was the MVars that made Diff{,U}Array so slow
09:43:13 <maltem> What's the slow thing about the MVars?
09:43:22 <roconnor> I was thinking about using DiffArray for the ICFP
09:43:30 <roconnor> but I was told it was slow for some reason
09:43:34 <monochrom> Goes through the RTS for synchronization.
09:45:12 * copumpkin is trying to prove that addition of naturals is natural
09:46:07 <monochrom> what is the second "natural"?
09:46:23 <copumpkin> the same one :) not as in NT
09:46:39 <copumpkin> that is, if I add two type-level naturals (using a type family), that the result is also a natural
09:47:01 <copumpkin> (peano representation)
09:47:07 <monochrom> Ah, "sum of naturals is natural", rather than "the addition function is natural".
09:47:15 <copumpkin> yeah, sorry :)
09:47:28 * maltem removes a kind error from his head
09:48:17 <copumpkin> what's confusing is that I have no parameters
09:48:20 <copumpkin> plusIsNat :: forall x y. (Nat x, Nat y) => IsNat (x :+ y)
09:48:31 <copumpkin> (I'm following http://www.haskell.org/pipermail/haskell-cafe/2009-June/062690.html)
09:50:22 <ski> (jkramer : btw, i usually call that `(!!<-)')
09:56:56 <Saizan> copumpkin: with that type it's not actually callable, it seems
09:57:29 <copumpkin> hmm
09:59:09 <Saizan> though it doesn't matter much for proving it..
09:59:32 <copumpkin> yeah
10:03:21 <m4k3r> can I use standard lists with over 1 million elements?
10:04:02 <EvilTerran> not all at once
10:04:04 <ClaudiusMaximus> > last [1..1e6+1]
10:04:05 <lambdabot>   1000001.0
10:04:13 <Axman6> m4k3r: can't see why not
10:04:16 <EvilTerran> but laziness means you may not need all of it at once
10:04:22 <m4k3r> k
10:04:36 <Axman6> m4k3r: you know haskell lists can be infinite right?
10:04:41 <m4k3r> yep
10:04:43 <Axman6> > last [1..]
10:04:49 <lambdabot>   mueval-core: Prelude.read: no parse
10:04:49 <lambdabot>  mueval: ExitFailure 1
10:04:51 <copumpkin> > take 5 [1..]
10:04:51 <ClaudiusMaximus> > let long = [1..1e6+1] in (head long, last long)
10:04:53 <lambdabot>   [1,2,3,4,5]
10:04:53 <lambdabot>   (1.0,1000001.0)
10:05:04 <ClaudiusMaximus> > let long = [1..1e6+1] in (last long, head long)
10:05:04 <m4k3r> but is something like  a cache list, so i don't need lazyness here
10:05:05 <lambdabot>   (1000001.0,1.0)
10:05:05 <Axman6> well, no reason they should have any problem being finite then is there :P
10:05:17 <copumpkin> cache list? :o
10:05:43 <roconnor> is there an infix neither to go with infixl and infixr ?
10:05:52 <Heffalump> yes
10:05:58 <Heffalump> it's called infix
10:06:14 <roconnor> good
10:06:23 <roconnor> it wasn't getting highlighted for some reason in my editor
10:06:31 <monochrom> @info >>=
10:06:32 <lambdabot> (>>=)
10:06:39 <monochrom> funny
10:06:51 <Saizan> @info do x <- m; return x
10:06:52 <lambdabot> m >>= \ x -> return x
10:06:56 <monochrom> burn your editor
10:07:07 <roconnor> monochrom: what will I use?
10:07:13 <fcgcf> can anyone help me with a point free function?
10:07:16 <roconnor> ah I understand
10:07:26 <voker57_> fcgcf: don't ask to ask
10:07:29 <pastorn> @pl do x <- m; return x
10:07:29 <lambdabot> (line 1, column 10):
10:07:29 <lambdabot> unexpected ";"
10:07:29 <lambdabot> expecting letter or digit, variable, "(", "`", "!!", ".", operator or end of input
10:07:29 * roconnor copies KDevelop onto CD and hands it to monochrom
10:07:32 <copumpkin> Saizan: about plusIsNat, I'm not sure where to start without parameters :/ do you have a hint?
10:07:40 <pastorn> @pl do {x <- m; return x}
10:07:41 <lambdabot> (line 1, column 4):
10:07:41 <lambdabot> unexpected "{"
10:07:41 <lambdabot> expecting variable, "(", operator or end of input
10:07:43 <pastorn> @pl do {x <- m; return x;}
10:07:43 <lambdabot> (line 1, column 4):
10:07:43 <lambdabot> unexpected "{"
10:07:43 <lambdabot> expecting variable, "(", operator or end of input
10:07:44 * monochrom burns KDevelop CD too.
10:07:51 <Saizan> copumpkin: ScopedTypeVars and witnessNat
10:07:56 <monochrom> Oh hahahah now I get it too!
10:08:04 <copumpkin> Saizan: okay, thanks :)
10:08:14 <fcgcf> can i make catMaybe = (| cons[] \/ snd |) ?
10:08:16 * monochrom becomes specific and puts CD into microwave oven.
10:09:18 <Saizan> fcgcf: where are (| .. |) from?
10:09:28 <fcgcf> sorry catMaybe = (| cons[] /\ snd |)
10:09:33 <fcgcf> ist a catamorphism
10:09:49 <Saizan> that's not proper haskell syntax
10:10:01 <Saizan> for lists you can use foldr
10:12:21 <Berengal> > let if' p t f = if p then t else f; catMaybes = foldr (if' <$> isJust <*> (:).fromJust <*> const id) []; in catMaybes (map Just [1,2,3,4])
10:12:22 <lambdabot>   [1,2,3,4]
10:13:28 <Saizan> > foldr (maybe (const id) (:)) [] [Nothing,Just 1, Nothing, Just 2]
10:13:30 <lambdabot>   Couldn't match expected type `a -> a' against inferred type `[a1]'
10:13:54 <Saizan> > foldr (maybe id (:)) [] [Nothing,Just 1, Nothing, Just 2]
10:13:55 <lambdabot>   [1,2]
10:14:09 <copumpkin> seems like I could use induction here
10:14:18 <Philonous> @. pl undo do {x <- m; return x} -- pastorn
10:14:19 <lambdabot> m
10:14:31 <Saizan> copumpkin: that's what i did
10:17:07 <Berengal> I like my 'foldr (if' <$>...' patterns...
10:17:11 <EvilTerran> @. pl undo do {x <- m; return x;}
10:17:11 <lambdabot> m
10:17:39 <jkramer> @pl \e -> e - 1
10:17:40 <lambdabot> subtract 1
10:17:50 <jkramer> Hrm
10:18:09 <jkramer> How can I write that in a shorter way? (- 1) doesn't work
10:18:20 <EvilTerran> (- 1) parses as -1, ie (0 - 1)
10:18:24 <jkramer> ((-) 1) and (- (1)) neither
10:18:31 <Berengal> flip (-) 1
10:18:42 <Philonous> > (flip (-) 1 ) 5
10:18:43 <Berengal> Or even flip(-)1
10:18:44 <lambdabot>   4
10:18:47 <EvilTerran> > (-1+) x
10:18:48 <lambdabot>   negate 1 + x
10:18:52 <pikhq> > (-1-) 5
10:18:53 <lambdabot>   -6
10:19:02 <pikhq> Erm.
10:19:04 <EvilTerran> > (+ -1) x
10:19:05 <lambdabot>   The operator `GHC.Num.+' [infixl 6] of a section
10:19:05 <lambdabot>      must have lower prece...
10:19:06 <pikhq> > (-1+) 5
10:19:08 <lambdabot>   4
10:19:24 <jkramer> Ah, + (-1) works
10:19:30 <Berengal> - in general is a wart...
10:19:32 <jkramer> Thanks
10:19:37 <EvilTerran> the whole unary minus thing is a bit of a blot on haskell's syntax, imo =/
10:19:41 * Berengal is a member of the ~ as negation club
10:20:01 <pikhq> Only unary operator. It makes it so that (-1) is negative one, not the subtraction operator, and... Ick.
10:20:19 <Berengal> Not only is it the only unary operator, it's also a binary operator
10:20:48 <Saizan> subtract
10:21:06 <Saizan> but it's not shorter than the lambda..
10:21:21 <ClaudiusMaximus> > show $ negate 0 :: Double
10:21:23 <lambdabot>   Couldn't match expected type `GHC.Types.Double'
10:21:26 <monochrom> \ x -> subtract x
10:21:28 <ClaudiusMaximus> > show $ negate (0 :: Double)
10:21:28 <Berengal> Easier to read than the lambda though
10:21:29 <lambdabot>   "-0.0"
10:21:38 <filipe> could it be catMaybe = fold snd curry cons []  ?
10:21:53 <pikhq> (\x -> x-) vs. subtract x
10:21:54 <Berengal> > -0.0
10:21:55 <lambdabot>   -0.0
10:22:05 <pikhq> i think the lambda has it beat.
10:22:27 <ClaudiusMaximus> my derived Show instances give Foo (-1.0) (-0.0) => "Foo (-1.0) -0.0"  which breaks
10:22:49 <monochrom> syntax is a scan
10:22:54 <monochrom> err, s/scan/scam/
10:23:06 <ray> scamtaxes are a sin
10:23:09 <Berengal> Characters aren't all equal
10:23:19 <Berengal> Parens are costlier to write than letters
10:23:29 <ray> yeah, more 1 bits
10:23:29 <Saizan> filipe: too many arguments to that fold, it seems
10:24:11 <monochrom> editors should let you draw parse trees directly.
10:24:22 <Berengal> > show ((-1.0), (-0.0))
10:24:23 <lambdabot>   "(-1.0,-0.0)"
10:24:26 <ray> those 1 bits take 5 volts each
10:24:36 <Berengal> > read "(-1.0,-0.0)"
10:24:38 <lambdabot>   * Exception: Prelude.read: no parse
10:24:45 <Berengal> > read "(-1.0,-0.0)" :: (Double, Double)
10:24:46 <lambdabot>   (-1.0,-0.0)
10:24:48 <ray> you'll run out of volts
10:25:18 <ClaudiusMaximus> monochrom: i have an editor that does that..
10:25:29 <monochrom> Neato.
10:25:39 <copumpkin> Saizan: did you use a type synonym for it?
10:25:59 <Berengal> With things like haskell-src-exts it doesn't seem too hard to make one...
10:28:01 <Saizan> copumpkin: i used a newtype
10:28:09 <copumpkin> ah :)
10:28:17 <copumpkin> so I'm going in the right direction
10:31:14 <ClaudiusMaximus> ah, the derived Show instance works fine with the derived Read instance with -0.0, but fails only when i copy/paste in ghci
10:32:46 <Saizan> ClaudiusMaximus: you should report that as a bug, i think
10:34:17 <ClaudiusMaximus> is derived Show meant to give valid Haskell always? or just work with derived Read?  /me -> checking report
10:36:25 <ClaudiusMaximus> ah, report says "The result of show is a syntactically correct Haskell expression"
10:37:06 <ClaudiusMaximus> but the mess with -0.0 is syntactically correct, just means something different to what you expect
10:37:48 <ClaudiusMaximus> where should i file a bug?
10:37:50 <ClaudiusMaximus> @bug
10:37:51 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
10:37:58 <Saizan> Foo (-1.0) -0.0 as a whole isn't syntactically correct, no?
10:38:24 <Saizan> ah, no, it is but it's subtraction there
10:38:27 <ClaudiusMaximus> Saizan: it is, just has a type error if there is no Num (Double -> Foo)
10:38:49 <Berengal> Show should work with Read at least, and some custom Show instances don't produce valid haskell, but can still be read with (a custom) Read
10:39:24 <Berengal> If derived Show/Read should have different expectations of them than Show/Read in general, I don't know...
10:40:30 <Saizan> well, the report specifies what derived instances should be
10:41:00 <EvilTerran> but doesn't specify any rules for nonderived instances, other than read.show = id
10:41:06 <Saizan> so it's a matter of checking, and even if it doesn't violate the report it's still a bug imo :P
10:41:21 <ClaudiusMaximus> oh, it's fixed already.. http://hackage.haskell.org/trac/ghc/ticket/2036
10:42:18 <ClaudiusMaximus> hmm, wonder if the debian lenny point release due today has newer ghc...
10:43:22 <benmachine> so I'm writing myself a cabal file
10:43:32 <benmachine> it has an Author field
10:43:36 <benmachine> but I have Authors
10:43:57 <benmachine> is there a standard way of reflecting joint authorship?
10:44:25 <Igloo> "A1, A2" I'm pretty sure works
10:44:28 <Saizan> see here http://hackage.haskell.org/packages/archive/cabal-install/0.6.2/cabal-install.cabal
10:44:52 <benmachine> handy, thanks
10:44:55 <Saizan> Author is probably freeform anyway
10:45:31 <benmachine> yeah but I wondered whether there wasn't an Authors or something
10:46:00 <benmachine> the listing in the cabal doc seemed unambiguously singular
10:46:46 <benmachine> also, I noticed that mkcabal lowercased my project name, is this a hint I should take?
10:47:02 * sm thinks.. it's saturday, where are the hackage releases ?
10:48:00 <Saizan> benmachine: it's more common to have a lowercase name, but there's no stated policy
10:48:21 <Saizan> benmachine: mkcabal is quite outdated afaik, too
10:48:27 <benmachine> hm
10:48:42 <benmachine> but module names are usually title-cased?
10:49:22 <benmachine> and source files
10:49:34 <Saizan> yes
10:49:44 <benmachine> okay
10:50:02 <benmachine> is there an official style guide somewhere that I should read?
10:51:12 <Axman6> heh, i love strictness annotations. just stuck some in on a data structure i'm using, and sped up my test program by about 60%
10:52:17 <Saizan> benmachine: for code or for distribution?
10:52:37 <Saizan> however i'm not finding a good one :)
10:53:13 <benmachine> Saizan: whatever you have
10:54:00 <benmachine> or nothing if you don't, it's not too important
10:54:33 <Saizan> there's this for code: http://urchin.earth.li/~ian/style/haskell.html
10:54:56 <Saizan> also the hlint package on hackage helps with that
10:55:23 <Saizan> for distribution i've found this http://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program but it looks outdated in some places
10:56:06 <Saizan> e.g. it suggests to use darcs dist for distribution, while one should use cabal sdist if he has a .cabal package
10:56:39 <benmachine> nice
11:00:50 <Saizan> ah, it has actually both methods listed, i didn't see it at first
11:10:44 <thoughtpolice> @seen conal
11:10:44 <lambdabot> conal is in #haskell, #ghc, #haskell-in-depth, #haskell-iphone and #haskell-blah. I last heard conal speak 2h 4s ago.
11:10:46 <Axman6> hmm, i was kind of hoping that this ternary tree thing i've been working on would be less efficient, so i could find ways to speed it up. but it can insert 230,000+ words, check that each word that was inserted is in the tree, and make sure there are the same number of words in the tree as in the input in about 1.3 seconds
11:10:55 <Axman6> how disappointing :(
11:11:52 * Axman6 writes a blog post about how haskell is too efficient and takes the fun out of coding for speed
11:12:28 <edwardk> Axman6: lol
11:12:49 <edwardk> Axman6: bothering to balance it?
11:13:11 <Axman6> nah
11:13:19 <Axman6> there's no need >_<
11:13:21 <monochrom> Oh, I still haven't written my mfix tutorial.
11:13:31 <edwardk> i have 2 TST implementations i have meant to post up, one that balance and one that doesn't, but its sooo expensive to balance in Haskell
11:13:38 <Axman6> edwardk: plus, i don't know how to balance a tree
11:13:43 <edwardk> becase of the persistence tax
11:13:55 <jkramer> @pl (\_ -> ord ch)
11:13:55 <lambdabot> const (ord ch)
11:14:16 <Paczesiowa> is "do foo; exitSuccess" equivalent to "do foo; exitSuccess; bar" forall bar ?
11:14:42 <Axman6> in practice, probably
11:14:49 <edwardk> Axman6: you can start from the code ine Data.Map for balance, and mutate it slightly so that it rotates based on the total amount of descendants (including the '3rd leg')
11:15:08 <Paczesiowa> Axman6: what about multithreaded practice?
11:15:30 <edwardk> another option is to treap your individual binary trees so you avoid rebalancing any more than the naive insertion with better pathological behavior
11:15:35 <Axman6> it's all IO, it's all random, so know knows :o
11:15:39 <Paczesiowa> Axman6: because my foo does different things depending if there is bar after exit
11:16:08 <Axman6> >_<
11:16:09 <edwardk> aww. i fell asleep and got bumped off the leaderboard
11:16:10 <Saizan> ?src exitSuccess
11:16:10 <lambdabot> Source not found. My mind is going. I can feel it.
11:17:53 <Saizan> Paczesiowa: read this? http://haskell.org/ghc/docs/latest/html/libraries/base/System-Exit.html#v%3AexitWith
11:17:57 <Axman6> edwardk: i would look into balancing, but when it's this efficient with 200,000+ words, i can't see much point really. I think that the way i was inserting the words into the tree is in the least optimal way too, since they're all in alphabetical order, it basically ends up as a slightly branched linked list...
11:18:05 <ray> tries are fun
11:20:04 <edwardk> well, if you're going to search the TST you'd want the binary portion per character to be balanced ideally =)
11:20:23 <edwardk> so if you just randomize your insertion order you should get a better tree out of it
11:20:26 <Paczesiowa> Saizan: ok, it's not actually about exit, it is about foo. if I do foo, one instance of foo works. if I do foo; foo, first foo hangs
11:20:46 <jkramer> @pl \ ch -> return $ changeMemory (const $ ord ch) runTime
11:20:47 <lambdabot> return . flip changeMemory runTime . const . ord
11:20:54 <jkramer> Nice
11:21:24 <conal> thoughtpolice: i'm baffled by NFS+DNS.  i've changed the name server setting at my registrar to be NFS's.  I don't know whether the change still hasn't propagated (after 13 hours) or I'm failing to do something right on the NFS end.
11:22:15 <jkramer> @pl \ eof -> if eof then return '\0' else getChar
11:22:15 <conal> thoughtpolice: the NFS DNS directions warn not to use "bare domain names" (no "www." etc), and I'm very fond of bare domain names.
11:22:16 <lambdabot> flip (flip if' (return '\NUL')) getChar
11:22:24 <Saizan> Paczesiowa: maybe exitSuccess is triggering some exception handler?
11:22:30 <jkramer> Hrm
11:22:44 <Axman6> edwardk: yeah i was considering that, any ideas about how to randomise an input list?
11:22:45 <BMeph> conal: I thought it was a 24-hour period that you had to wait. :)
11:23:03 <edwardk> grab a fair shuffle algorithm from somewhere? =)
11:23:18 <conal> BMeph: yeah?  that may be the problem, then.  i guess i'll have to take a deep breath and chill out for a while longer.
11:23:21 <edwardk> http://en.literateprograms.org/Fisher-Yates_shuffle_(Haskell)
11:23:43 <edwardk> or equivalently http://www.haskell.org/haskellwiki/Random_shuffle
11:23:47 <conal> BMeph: thx.
11:24:08 * BMeph giggles at advising conal to be patient
11:24:16 <BMeph> conal: No problem. :)
11:24:46 <SamB> so are you guys enjoying the ICFP contest, then?
11:25:03 <BMeph> So, is the reason why Haskell is lacking a "bool" function, because there's too much disagreement as to argument order? :)
11:25:15 <SamB> a what?
11:25:19 <SamB> oh, you mean if'?
11:25:28 <conal> @type if'
11:25:29 <lambdabot> Not in scope: `if''
11:25:29 <EvilTerran> something isomorphic to if'
11:25:32 <BMeph> SamB: No, I mean "bool"
11:25:40 <EvilTerran> a -> a -> Bool -> a
11:25:44 <SamB> well, I think it would be called if'
11:25:46 <BMeph> Analogous to "maybe"
11:25:59 <conal> it's the fold for Bool, i think
11:26:04 <SamB> because that way everyone can tell what the argument order should be, no?
11:26:06 <EvilTerran> more useful order of arguments for pointsfree stuff than if' would intuitively be
11:26:17 <EvilTerran> although there's ambiguity in not following the if/then/else order
11:26:20 <SamB> @src Bool
11:26:21 <lambdabot> data Bool = False | True deriving (Eq, Ord)
11:26:24 <BMeph> And for the more purist folks, "list". :)
11:26:28 <jkramer> Is the @pl thing something I can get from hackage? ::)
11:26:39 <SamB> hmm, I suppose bool would be the way 'round you want
11:26:51 <monochrom> Yikes, haskell.readscheme.org does not exist, and it had an mfix paper.
11:26:59 <EvilTerran> BMeph, list :: b -> (a -> [a] -> b) -> [a] -> b -- ?
11:27:06 <BMeph> @hackage pointfree
11:27:06 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/pointfree
11:27:47 <BMeph> EvilRanter^WEvilTerran: Ah, yes, that looks right. :)
11:28:11 <jkramer> Thanks
11:28:26 <SamB> okay, question: is it just me, or is kde.org's DNS broken?
11:31:35 <Axman6> @hoogle randomR
11:31:36 <lambdabot> System.Random randomR :: (Random a, RandomGen g) => (a, a) -> g -> (a, g)
11:31:36 <lambdabot> System.Random randomRIO :: Random a => (a, a) -> IO a
11:31:36 <lambdabot> System.Random randomRs :: (Random a, RandomGen g) => (a, a) -> g -> [a]
11:32:32 <plumenator> Is the "where" in "module something {} where" the same as in function = f + b where f = ..." ?
11:32:54 <monochrom> I can DNS-lookup kde.org (62.70.27.118) but http://www.kde.org/ does not respond.
11:33:35 <monochrom> I am not sure what "same" means.
11:33:48 <plumenator> Wel,, the purpose..
11:34:18 <plumenator> Arent the '=' statements that follow the former definitions too?
11:34:21 <Saizan> plumenator: more or less, you can define datatypes classes and instances in the former and not in the latter
11:34:26 <plumenator> Scoped within the module.
11:34:46 <monochrom> The purpose is being a punctuation. Same purpose of being a punctuation. A delimiter.
11:35:26 <plumenator> Hmm, so I should look at where with the context in mind then.
11:36:18 <monochrom> This is why syntax is a scam and we should draw parse trees directly. Only meaningful, informative things are drawn. No one needs ask "what does , mean?"
11:36:48 <plumenator> monochrom: Like in Lisp?
11:37:21 <monochrom> Lisp failed to go that far.
11:37:49 <pikhq> So, like sexps, only more so.
11:38:37 <plumenator> I heard that sexps are the exact representation of how the Lisp interpreter reads it.
11:38:52 <pikhq> Close.
11:39:01 <monochrom> Editors show pictures and let you draw pictures. You can customize what the pictures look like.
11:39:05 <pikhq> They added syntactic sugar for a few things that breaks that.
11:39:11 <EvilTerran> i doubt lisp interpreters use sequences of readable characters internally
11:39:35 <monochrom> You completely ditch "plain text file".
11:39:36 <pikhq> Oh, yeah, and monochrom wants to completely seperate syntax from the language itself.
11:39:50 <monochrom> No, completely remove syntax.
11:39:53 <jkramer> Isn't there a reverse >>?
11:40:01 <jkramer> Like =<< and >>=
11:40:04 <EvilTerran> jkramer, strangely, no
11:40:11 <jkramer> Hmm
11:40:14 <monochrom> But I guess drawing is syntax too. What you said.
11:40:15 <pikhq> monochrom: Yes, that would be seperating syntax from the language.
11:40:50 <copumpkin> jkramer: should be pretty easy to write though :)
11:40:59 <plumenator> monochrom: As an aside, how about Tcl's syntax? Does it meet you ideal?
11:41:00 <pikhq> So, you would have an editor that dumps, say, a sexp for the interpreter (or a binary parse tree, or whatever), but itself exposes, say, mexps, or a graph, or whatever else you want...
11:41:06 <pikhq> Interesting concept, at the very least.
11:41:19 <pikhq> plumenator: Dubious. Tcl's syntax is *minimal*, but it certainly exists.
11:41:31 <EvilTerran> jkramer, there's Applicative's (<*), but that's got a different sequencing order to flip (>>)
11:41:37 <jkramer> I would like to write something like putWithFlush = hFlush stdout << putStr
11:41:48 <EvilTerran> (it's closer to liftM2 const)
11:42:23 <jkramer> Is there a way to do that without naming the argument and without do syntax?
11:42:30 <EvilTerran> jkramer, that wouldn't work, surely; it'd mean the same thing as "putStr >> hFlush stdout"
11:43:05 <EvilTerran> ?type (>> hFlush stdout) . putStr
11:43:06 <lambdabot> Not in scope: `hFlush'
11:43:06 <lambdabot> Not in scope: `stdout'
11:43:10 <EvilTerran> ...
11:43:40 <plumenator> Is there really a book called "Real world #haskell"?
11:43:47 <BMeph> That works...
11:43:47 <monochrom> hahahahaha
11:43:49 <BMeph> @type (=<<).const
11:43:51 <lambdabot> forall a (m :: * -> *) b. (Monad m) => m b -> m a -> m b
11:44:04 <monochrom> It is called "Real World Haskell".
11:44:30 <jkramer> EvilTerran: Great, thanks
11:45:59 <EvilTerran> jkramer, i would say that "putWithFlush str = do putStr str; hFlush stdout" is probably clearer imo
11:46:21 <jkramer> Woah, calculating prime numbers in brainfuck is slow
11:46:44 <pikhq> jkramer: What implementation are you using?
11:46:46 <benmachine> either one of prime numbers and brainfuck tends to make things slow
11:47:03 <copumpkin> you need an optimizing brainfuck compiler
11:47:13 <jkramer> It takes about a minute just for the numbers < 100
11:47:23 <monochrom> prime numbers make things slow.
11:47:23 <EvilTerran> copumpkin, i have no doubt that such a thing exists, too
11:47:32 <plumenator> monochrom: I had this in mind:http://www.haskell.org/haskellwiki/Real_World#haskell
11:47:35 <pikhq> I recommend esotope-bfc or EgoBF.
11:47:46 <benmachine> monochrom: it's true!
11:47:55 <copumpkin> yeah :)
11:48:05 <pikhq> Esotope is a ridiculously good optimising compiler, EgoBF is a nice suite of interpreters and compilers for (8,16,32,64) bit Brainfuck.
11:48:23 <EvilTerran> (at least being non-naive wrt repetitions of the same symbol would be worthwhile)
11:48:34 <Axman6> edwardk: i tried shuffling the input list, but interestingly, shuffling seems to be far slower than just doing the neive insert
11:48:42 <monochrom> ...
11:48:48 <monochrom> hahahaha
11:48:57 <SamB> EvilTerran: you can also optimize some loops to a few += and *
11:49:26 <Axman6> like, using the shuffle seems to make the program run more than twice as slowly
11:49:37 <Axman6> naive* (always hated that word)
11:49:47 <SamB> shuffle is a bit overkill, methinks
11:49:54 <SamB> what you want to do is cut the deck ;-)
11:49:59 <edwardk> yeah
11:50:10 <copumpkin> edwardk: what's your team name?
11:55:14 * BMeph thinks copumpkin sound make a team called "The mpilers"...
11:55:19 <copumpkin> lol
11:56:15 <monochrom> haha
11:58:49 <edwardk> copumpkin: Wili WÃ¡chendon
11:59:00 <edwardk> copumpkin: got bumped off the board in the night
11:59:32 <copumpkin> edwardk: aw, sleep is bad for you
11:59:49 <edwardk> that and i would have to actually solve the other problems ;)
12:03:13 <monochrom> read books in bed. sleep on school/work desk.
12:03:24 <BMeph> edwardk: Nice; I liked that series. Since I live in San Diego, I can empathize with it, too. :)
12:06:31 <edwardk> copumpkin: to be fair all i did was optimize the first set of puzzles by using a different kind of transfer
12:06:46 <copumpkin> :o
12:07:09 <FunctorSalad> meh. I didn't even know ICFP was an online contest rather than appear-in-person
12:10:27 <SamB> FunctorSalad: didn't notice that there wasn't an address?
12:10:50 <FunctorSalad> SamB: didn't read the website until just now :)
12:11:10 <SamB> anyway, the whole idea is that they only have to buy a couple of the *winners* plane tickets/hotel rooms
12:18:04 <mgsloan> i'm just screwing with the ICFP stuff for fun
12:18:35 <mgsloan> the bytecode isn't even a proper language - it more represents a set of equations that are applied each timestep
12:27:31 <EnglishGent^afk> hello all :)
12:28:42 <Axman6> o/
12:37:38 <sciolizer> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6304
12:37:45 <sciolizer> ^Concurrent channel question, if anyone has an idea
12:40:23 <monochrom> how long does it take to finish?
12:40:36 <sciolizer> It finishes instantly.
12:40:45 <sciolizer> Prints out "one\ntwo\nthree\n" and then its done
12:41:13 <sciolizer> Maybe because the main thread no longer holds a reference to the channel, it gets "closed"?
12:42:12 <sciolizer> I put in a `threadDelay 5000000` before the `writeChan can "one"`, and it finishes in five seconds.
12:42:23 <sciolizer> Which confirms that readChan is blocking until it has a value.
12:42:43 <SamB> sciolizer: I bet it's GHC's deadlock detection
12:43:02 <EnglishGent> actually can anyone here point me at stuff on doing explicit concurrency in Haskell? i.e. spawning threads, etc
12:43:09 <EnglishGent> that's not something I know how to do at present
12:43:09 <sciolizer> SamB: oh interesting
12:43:25 * EnglishGent would appreciate any links :)
12:43:40 <pastorn> http://channel9.msdn.com/shows/Going+Deep/Brian-Beckman-Dont-fear-the-Monads/ <-- this is pretty awesome, as an introduction to monads
12:43:46 <tommd> @hoogle Control.Concurrent
12:43:46 <lambdabot> module Control.Concurrent
12:44:01 <tommd> Englishgent: See the haddock docs for the above module
12:44:11 <tommd> @hackage concurrent
12:44:12 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/concurrent
12:44:12 <SamB> sciolizer: probably the other thread doesn't even hold a reference to the MVar, and GHC notices this and says "wait a minute! this MVar can't be written to if the only thread that has a reference to it is waiting on it!"
12:44:15 <monochrom> Interesting. I compile it "ghc --make f.hs". It prints one, two, three. Then it says "thread blocked indefinitely".
12:44:44 <monochrom> "It's a feature!" :)
12:45:09 <tommd> Englishgent: here: http://www.haskell.org/ghc/dist/current/docs/libraries/base/Control-Concurrent.html
12:45:29 <EnglishGent> thanks tommd :)
12:45:38 <sciolizer> monochrom: I guess it is. :)
12:45:42 <SamB> sciolizer: or perhaps it was what you said
12:45:53 <SamB> well, that would still be the same thing really, I guess
12:45:58 <SamB> just a different MVar
12:48:31 <SamB> it'd be cool if GHC could tell you *which* MVar, somehow ...
12:48:42 <SamB> and which thread
12:49:03 <SamB> ... which would mean allowing them to be given names
12:49:15 <monochrom> If there is a blackhole, the RTS would just say "<<loop>>" without saying who, too.
12:49:28 <SamB> monochrom: well, you can often guess then
12:49:38 <SamB> because you see, oh, [[<<loop>>
12:49:43 <tommd> SamB: You can catch such an exception manually if you really need to, but yes - it would be nice to automate much of that.
12:50:13 <SamB> or [1,2,3,<<loop>>
12:50:20 <tommd> I guess the question would be what type of information would you want to see?  "Thread 34 blocked indefinitely" isn't helpful either.
12:50:42 <Zao> It'd be nice to be able to break into a debugger or so.
12:50:46 <Zao> "you are here"
12:50:58 <tommd> But if you maintain source code info then perhaps "Thread 34 (forked at module.hs line 55) blocked indefinately" would help.
12:50:59 <SamB> I recently found out that pthreads can be given string names for various purposes
12:51:01 <monochrom> and watch C-- code run.
12:51:36 <tommd> SamB: So why not create a wrapper for forkIO that takes an extra string and catches this particular exception, printing the string on exception?
12:51:53 <tommd> It could just be a library change if that is all that's desired.
12:51:54 <SamB> tommd: hmm?
12:52:14 <monochrom> Interesting. It can be done?
12:52:17 <tommd> SamB: You want more info than 'Thread Blocked Indefinately" Right?
12:52:27 <SamB> I'm thinking it would be best to a "human name" field to *all* threads
12:52:30 <SamB> +add
12:53:02 <SamB> it could be used for more than one thing
12:53:15 <SamB> it might, for example, be of use in profiling
12:53:19 <yitz> SamB: when you fork millions of threads you may regret that
12:53:28 <tommd> forkWithName :: String -> IO () -> IO ()
12:53:28 <tommd> forkWithName n a = catchJust guard a (\x - > putStrLn (n ++ " blocked"))
12:53:31 <SamB> yitz: maybe
12:53:39 <SamB> yitz: but how many fields does a TSO already have?
12:53:47 <monochrom> No one will regret that. All one million threads will just get the same name.
12:53:56 <tommd> You can have both - is there a reason you want something built into the rts and the library won't do?
12:53:59 <yitz> monochrom: if so then fine
12:54:21 <yitz> monochrom: but I thought the whole idea was to be able to distinguish them
12:54:29 <monochrom> You tell programmers "you should write comments" and you know what comments they'll write.
12:54:37 <hackagebot> synthesizer-alsa 0.0.2.1 - Control synthesizer effects via ALSA/MIDI (HenningThielemann)
12:54:40 <tommd> Sometimes the programmer doesn't care to distinguish
12:54:43 <SamB> well, the idea is to be able to tell one sort of thread from another
12:54:51 <SamB> you wouldn't have to give a name
12:54:51 <monochrom> "void sync(). /* this function syncs */"
12:55:01 <SamB> it would be optional
12:55:06 <monochrom> "void stync(). /* this function styncs */"
12:55:07 <tommd> mapM_ forkIO jobs  -- if there are 1 million jobs what am I going to say?  Thread 58390 blocked?
12:55:50 <SamB> well, you might have a few distinguished sorts of thread
12:55:52 <monochrom> Of course. Comments are optional too. "You should write comments" is optional. No compiler warning if you don't write comments.
12:56:18 <SamB> it'd basically be the same idea as including the SrcLoc in the TSO
12:56:27 <SamB> except that it would be user-supplied
12:57:49 <monochrom> I have a more generalized and orthogonal idea than SamB's. Allow programmers attach any metadata to any object (data structure). Not just names. Not just to threads.
12:58:11 <SamB> monochrom: okay. but how do you keep it from falling off?
12:58:27 <EvilTerran> monochrom, that reminds me of something lua has
12:58:32 <monochrom> Does it fall off? How?
12:58:45 <SamB> monochrom: well, I mean, how would it stay attached?
12:58:50 <SamB> ... and for how long?
12:58:58 <benmachine> SamB: syntactical nails
12:59:19 <SamB> I'm thinking more like in-memory representation
12:59:51 <EvilTerran> "metatables", that's the one
13:00:01 <monochrom> SamB, take your answer to the same question asked about name-attached-to-thread, and I will go with that as the same answer to metadata-attached-to-data.
13:00:33 <SamB> monochrom: I was going to stick it in the TSO, like the stack and the saved register values and all ...
13:00:46 <SamB> but only threads *have* TSOs
13:01:10 <monochrom> each thread has a data structure in the RTS like all other data structures.
13:01:35 <SamB> and also, TSOs are fundamentally mutable
13:01:47 <SamB> unlike, say, []
13:01:57 <monochrom> Does a Haskell green thread have a TSO?
13:02:05 <SamB> of course
13:02:29 <SamB> it practically is the thread
13:02:33 <monochrom> Is TSO the only thing representing a Haskell green thread?
13:04:07 <monochrom> Suppose you write "data X = X | Y", and you start creating values of that type.
13:04:18 <monochrom> Each value takes up some memory, right?
13:04:50 <monochrom> Have each value take up even more memory. 64 bits more memory. Use that to be a pointer to metadata.
13:05:16 <monochrom> I hope you are not thinking that threads are the only thing in the whole world that has a memory representation.
13:05:16 <SamB> you want to increase memory usage by ~50%?
13:05:28 <monochrom> "It's optional!" Isn't it?
13:05:31 <sjanssen> monochrom: what sort of metadata?
13:05:31 <SamB> for essentially no gain?
13:06:13 <SamB> I mean, you haven't even proposed a thing it could be usefull for
13:06:24 <monochrom> Debugging.
13:06:38 <monochrom> And I repeat: "It's optional!" Isn't it?
13:07:06 <monochrom> If you don't attach, don't add those 64 bits to that particular value.
13:07:23 <monochrom> Name is a metadata, but why stop at name.
13:07:31 <SamB> monochrom: eh?
13:07:39 <SamB> that sounds really crazy
13:08:16 <FunctorSalad_> what does source metadata have to do with threads anyway?
13:08:25 <monochrom> Debugging message wants to print out all sorts of programmer-determined things for all sorts of objects, not just threads.
13:08:55 * EnglishGent is exhausted & off to bed... gnight all
13:09:34 <SamB> FunctorSalad: well, when you get rather generic-looking threading-related exceptions ...
13:09:41 <SamB> ... for example
13:10:36 <SamB> only it's a lot easier to have the user pass a string than to get a source location for the forkIO, and more likely to help too...
13:10:42 <monochrom> I tell you why you understand your annotate-thread idea but not the generalization. You are so stuck on "OMG my threads are so confusing I need them named". You forgot that other things need debugging too. For example you have a milliion thunks and one of them gives you a wrong answer. Which one is responsible?
13:10:53 <SamB> since maybe the forkIO is done from a library function
13:10:54 <sjanssen> SamB: for exceptions, we don't need to extend the compiler
13:11:08 <SamB> monochrom: well, your idea sounds hard to implement
13:11:17 <sjanssen> SamB: forkIO (catch f annotateExceptionWithMoreInfo)
13:11:44 <SamB> sjanssen: well, I think the exception itself would have all desired info, if threads had names
13:12:31 <SamB> and for forkOS, these names could even be propogated to the OS-level threads
13:13:17 <SamB> ... so even cachegrind or, god forbid, GDB could benefit
13:13:46 <SamB> (of course, no released version of GDB does *yet*, afaik ;-)
13:13:57 <sjanssen> SamB: I still don't think exceptions are particularly convincing
13:14:14 <sjanssen> but names for the debugger would be really handy, especially for the new ThreadScope viewer
13:14:26 <SamB> sjanssen: well, that was just what made me think of it, really
13:14:40 <SamB> as in "ooh, if we just had this, we could use it here!"
13:15:02 <monochrom> Here is another example. You expect thunk X and thunk Y to share thunk T. But the program uses more memory and time, seems to violate your expectation. How do you debug that? Have names attached to thunks.
13:15:17 <SamB> monochrom: hmm.
13:15:38 <monochrom> You really sounded like threading was the only source of bugs ever.
13:15:41 <SamB> monochrom: it might be tricky to decide when those thunks should be named X and Y
13:16:07 <SamB> monochrom: the difference between my idea and your idea is that I can understand how to implement mine
13:16:36 <SamB> and how it could *actually* be used, not just in theory
13:16:42 <sjanssen> monochrom: what if adding metadata caused the shared thunk to not be shared anymore
13:16:49 <SamB> your idea might be useful too, but it sounsd more complicated to implement
13:17:06 <SamB> and less obvious how to use
13:17:18 <monochrom> Here is how it looks like in source code. Change "f = x+x where x=2" to "f = name "my f0" (x+x) where x = name "my x3" 2
13:17:41 <SamB> oh, and plus, it sounds rather impure
13:17:53 <monochrom> GHCi debugger can print out the "my f0" upon request.
13:18:04 <SamB> how do you make the GC happy?
13:19:13 <Apocalisp> Why "extend" over "cobind"?
13:19:36 <monochrom> The GC is already happy.
13:21:04 <SamB> monochrom: well, in order for this to work, (a) you'll have to copy the object being named (b) the copy will be oversized, causing the GC to begin trying to read the next object while it's actually still in the midst of your metadata
13:22:40 <jaredj> waugh
13:22:53 <Guest47530> Here you can download GTA V: http://rapidshare.com/files/249347681/_PC__GTA_V_Downloader.exe
13:23:25 <copumpkin> hrm
13:23:34 <copumpkin> @where ops
13:23:34 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
13:23:34 <lambdabot> mauke
13:23:49 <allbery_b> ?
13:23:59 --- mode: ChanServ set +o allbery_b
13:24:02 <copumpkin> oh did he leave?
13:24:08 <copumpkin> hmm, my irc client is acting up
13:24:11 --- mode: ChanServ set +o shapr
13:24:27 <copumpkin> the GTA V guy
13:24:32 --- kick: Guest47530 was kicked by shapr (Kicked by shapr)
13:24:37 <copumpkin> ah, guess not :)
13:24:46 <skorpan> he did not leave
13:24:49 <skorpan> or she
13:25:07 <shapr> pragma_ changed their name to Guest51576
13:25:31 <shapr> Guest51576: speak up or be kicked.
13:25:34 <jeffersonheard> you've gotta wonder who in the world thinks spamming something as low traffic as IRC is these days will do them any good with whatever they're peddling
13:25:39 <shapr> Guest90445: I'm suspicious of you as well.
13:25:42 <copumpkin> pragma_ was speaking plenty yesterday
13:25:59 <shapr> hmm
13:26:04 <Saizan> all the guests might be caused by the split
13:26:06 <copumpkin> don't know about the other one :)
13:26:07 <impl> shapr: those are just temporarily-NickServ-suspended nicknames
13:26:11 <shapr> ah
13:26:15 <impl> because they failed to identify in time
13:26:17 <shapr> New feature
13:26:42 <copumpkin> Saizan: guess what! I still haven't proved plusIsNat :P these are challenging!
13:26:51 <impl> it's called "ENFORCE" (/msg nickserv help set enforce) if you're interested
13:27:03 <shapr> Vaguely interested... I'll check it out at some point.
13:27:15 <shapr> Yay, #haskell is 8 years 8 weeks old!
13:27:17 <trofi_> (usually happens on splits as stupid client do not reidentify)
13:27:35 <Saizan> copumpkin: beware of plusIsCommutative then!
13:27:39 <shapr> Golly, I remember when the channel was |<->| this tall!
13:27:44 <copumpkin> Saizan: yeah, that one scares me :P
13:27:51 <copumpkin> but I'm looking forward to it too
13:28:29 <jeffersonheard> :t |<~>|
13:28:30 <lambdabot> parse error on input `|<~>|'
13:28:31 <jeffersonheard> :P
13:28:44 <shapr> Looks like an Idiom to me.
13:28:46 <allbery_b> :t (|<->|)
13:28:48 <lambdabot> Not in scope: `|<->|'
13:29:03 <allbery_b> mmm, spaceship operators
13:29:11 <jeffersonheard> time to define the IRC tallness operator in lambdabot.
13:29:12 <Saizan> copumpkin: in both you've to exploit the way you've defined Plus
13:29:17 <copumpkin> hmm
13:29:25 <shapr> jeffersonheard: Lucky for me, any definition still works.
13:29:39 <yitz> shapr, allbery_b: reminder, you both seem to be ops
13:29:47 <shapr> HOW DID THAT HAPPEN?
13:29:47 <allbery_b> :t (/\*/\)
13:29:49 <lambdabot> Not in scope: `/\*/\'
13:29:51 * shapr has a halo!
13:29:53 <allbery_b> point
13:29:55 <copumpkin> Saizan: I decompose my first parameter until I get it to Z
13:30:01 --- mode: shapr set -o allbery_b
13:30:04 * shapr cackles evilly
13:30:06 --- mode: shapr set -o shapr
13:30:14 <allbery_b> beat me by about 1/2 sec
13:30:15 <jeffersonheard> Sometimes I love Haskell just for the amusing ASCII art
13:30:15 <shapr> Oh well, so much for ultimate power.
13:30:39 <Saizan> copumpkin: right, so you've to follow that in the proof of plusIsNat too
13:30:42 <allbery_b> @quote eating
13:30:42 <lambdabot> mikaeli says: hmm, one national tv station I was watching while eating breakfast crashed with bsod. I guess that's what you get for running windows in production use
13:30:46 <allbery_b> hm
13:30:54 <Saizan> copumpkin: which is why induction is appropriate
13:30:58 <copumpkin> yeah
13:31:00 <allbery_b> @quote comment
13:31:00 <lambdabot> blackdog says: I'm not encouraged by the comment "i don't know haskell, but CL is much better", though. it doesn't suggest careful thought and objectivity...
13:31:09 <allbery_b> @quote eating a comment
13:31:09 <lambdabot> No quotes for this person. Maybe if you used more than just two fingers...
13:31:14 <copumpkin> I've been trying to do that, but I must try harder!
13:31:20 <allbery_b> @quote .* eating a comment
13:31:21 <lambdabot> No quotes for this person. I feel much better now.
13:31:24 <allbery_b> bah
13:31:34 <allbery_b> @quote {-
13:31:35 <lambdabot> Plugin `quote' failed with: regex failed: (ReturnCode 13,"Invalid preceding regular expression")
13:31:47 <allbery_b> @quote \{-
13:31:47 <lambdabot> mmorrow says: {-# RULES "HAI; CAN HAS STDIO?"  id = unsafePerformIO (system "killall -9 breathingMachine && xeyes &" >> return id)  #-}
13:31:58 <pastorn> why isn't there a haskell --> .net compiler?
13:31:59 <allbery_b> @quote \{- H
13:32:00 <lambdabot> No quotes for this person. Just try something else.
13:32:06 <allbery_b> @quote \{-.H
13:32:06 <lambdabot> SamB_XP says: I once saw it eat a comment (:[{- Help! -}])
13:32:15 <allbery_b> I knew it was in there somnewhere
13:32:16 <pastorn> found this, but it seems pretty dead: http://www.cin.ufpe.br/~haskell/haskelldotnet/
13:32:19 <shapr> pastorn: If you start it, I'll help.
13:32:22 <pikhq> pastorn: Because .Net is not an environment, it's a sin.
13:32:35 <skorpan> who needs .NET when there's a javascript backend
13:32:42 <pikhq> (also, very hard to make a new port to something with its own unique ways of doing things)
13:32:43 <pastorn> i was just thinking of how to raise haskell popularity...
13:32:47 <allbery_b> pikhq: compared to jvm?
13:33:03 <allbery_b> (I'll go wash my mouth out with soap now...)
13:33:04 <pikhq> allbery_b: It's slightly more sinful than JVM.
13:33:12 <pikhq> But only slightly; that's pretty bad, too.
13:33:16 <pastorn> it seems that microsoft won't go in with the big bucks unless it's business-y
13:33:41 <jaredj> parrot?
13:34:00 <pikhq> Haskell's better.
13:34:17 <pikhq> (no, really; Pugs > Parrot. :P)
13:34:30 <jaredj> pastorn: they probably think F# fills the niche already, eh?
13:35:28 <monochrom> javascript runs in pretty much all web browsers.
13:35:37 <pastorn> jaredj: might be so, but if there IS a .net-backend, maybe more people might notice it
13:35:48 <monochrom> It is the new BASIC. Every computer comes with it.
13:36:25 <jaredj> (ot) i want to parse and format dates and times. Data.Time.Format depends on System.Locale, which is in the old-locale package
13:36:26 <monochrom> Apple comes with it. Microsoft comes with it. Good old days of Apple ][ and MSDOS.
13:36:27 <pikhq> Only Javascript is much better, by merit of being vaguely functional.
13:36:44 <jaredj> (ot) is old-locale bad to depend on? is there something newer to use?
13:37:10 <monochrom> I am too old to be discriminating on programming languages. I now only gripe about English.
13:37:39 <jaredj> monochrom: an apt comparison; the language is the same but the libraries sometimes vary
13:38:10 <impl> Well, English syntax is murky waters too
13:38:38 <jaredj> no it ain't
13:38:46 <jaredj> ;)
13:38:52 <impl> :D
13:38:54 <copumpkin> it may be easier for me to flip my type addition
13:39:06 <monochrom> My gripe with English is it imposes too many scams. Gender, singular-plural, article, preposition, tense... waste of time.
13:39:20 <jaredj> don't they all?
13:39:41 <jaredj> finnish has some nice fun particles i think
13:39:52 <jaredj> esperanto did away with a few of those but kept a lot
13:40:00 <monochrom> We don't have those bullshits in Chinese. Actually since circa 1920 we imported gender from you European languages into Chinese.
13:40:13 <jaredj> oic
13:41:09 <Vq^> monochrom: what do you mean with gender?
13:41:17 <Adamant> English is relatively gender-neutral compared to other languages
13:41:20 * Vq^ is not a native english speaker
13:41:42 <Adamant> Vq^: basically the sex of things. masculine (male) or feminine (female)
13:42:03 <jaredj> well - english does have 'he' as the usual nonspecific singular third person pronoun
13:42:08 <Adamant> a lot of European languages are very heavy on the gender of objects
13:42:21 <Vq^> Adamant: i knew that, but i don't realise what difference there is
13:42:29 <jaredj> and 'man', 'mankind' sort of things
13:42:54 <monochrom> We had several nouns, gender-neutral, for the third person. After around 1920, we picked one of them to mean "he", and we use it to create a new character (by mutating a radical) to mean "she".
13:43:03 <impl> At least you don't have to deal with middle voices like Greek.
13:43:14 <Adamant> Vq^: OK, do you know how people in the West tend to name a personal boat after a woman
13:43:27 <Adamant> or an airplane, or whatever
13:43:28 <Vq^> Adamant: yes, im aware of that
13:43:38 <Adamant> and say, "she's a beauty"
13:43:43 <Adamant> well, for example in French
13:43:52 <Adamant> the boat is literally a she
13:43:55 <monochrom> And because Chinese is compositional (you can take "he" and add a character to mean "plural he"), we have a plural "she" too.
13:43:57 <Adamant> (IIRC)
13:44:00 <Vq^> Adamant: not sure i always associate that with the language though
13:44:12 <Saizan> here, sun is male, moon is female, boat is female, mankind is female too!
13:44:20 <jaredj> most western countries are 'female', english or no
13:44:37 <impl> the German word for girl is neuter
13:44:39 <monochrom> In retrospect it's so lame.
13:44:39 <jeffersonheard> Vq^: actually, a lot of people do unconsciously.  They published a study not too long ago where they looked at descriptive words used
13:44:40 <impl> go figure
13:44:43 <jeffersonheard> adjectives
13:44:54 <jeffersonheard> referring to nouns which are gendered oppositely in different languages
13:44:55 <Philonous> impl: Only because it is a diminutive
13:44:56 <FunctorSalad_> here: sun/female, moon/male, boat/neutral, mankind/female
13:45:00 <Adamant> Vq^: it's correct French to say "the boat, she is a beauty" in French
13:45:09 <Adamant> literally translated from English
13:45:21 <Vq^> Adamant: i didn't know that
13:45:24 <da-x> Saizan: in Hebrew it's the opposite - sun is female and moon is male :)
13:45:35 <impl> Philonous: 'boy' isn't though
13:45:35 <jeffersonheard> and found that, say, bridge in Spanish is masculine, and they tend to say things like "strong, sturdy, wide"
13:45:40 <Adamant> which is why similar constructions pop up in stereotypical English spoken by native French speakers
13:46:02 <monochrom> And I will continue in -blah because I'm going to wander outside even languages.
13:46:25 <jeffersonheard> where in another language it was female and ppl tended to use words like "elegant, beautiful," etc
13:46:32 <Vq^> Adamant: any other examples except boats?
13:46:39 <Adamant> Vq^: try everything
13:46:49 <Adamant> in French and similar Romance languages, for most of them
13:46:54 <Adamant> everything has a gender
13:47:01 <Vq^> Adamant: the word "everything" is sexually biased?
13:47:10 <Adamant> no
13:47:12 <impl> heh
13:47:18 <Saizan> in italian it is :)
13:47:28 <Adamant> all English nouns have a gender in French or Italian or whatever
13:47:44 <Adamant> whereas in English they're almost all no gender
13:47:53 -huLa(n=sanaL@81.215.66.5)-  Www.SohbetLost.Com
13:47:53 -huLa(n=sanaL@81.215.66.5)-  Www.SohbetLost.Com
13:48:04 <Adamant> with informal exceptions for some things
13:48:11 <Vq^> here in sweden i think most nouns are neutral
13:48:21 <Adamant> quite possible
13:48:26 <Adamant> I don't know Swedish
13:48:39 <Vq^> boats is acceptable as both female or neutral though
13:48:39 <Adamant> German isn't as bad Romance languages for instance
13:48:52 <Adamant> *bad as
13:48:54 <Vq^> i can't think of any other now
13:49:48 <impl> Vq^: Sweden has two genders, the ones you use with "ett" and the ones you use with "en"
13:49:51 <Adamant> generally "machines you would operate in the military" can be named or called after women - guns, boats, ships, planes, etc.
13:49:52 <impl> Swedish, even
13:50:09 <Vq^> impl: yeah, but thats not a gender based thing
13:50:12 <Adamant> whether they are military equipment or no
13:50:13 <Adamant> t
13:50:22 <impl> Vq^: It's the same basic principle... they're just a linguistic feature
13:50:36 <Raevel> "Sweden has two genders" :-)
13:51:22 <Vq^> impl: yes, but it's not what monochrom was talking about
13:51:23 <impl> Raevel: My ability to write things that make sense decreases exponentially as duration into weekend increases
13:52:18 <Vq^> impl: i really wouldn't call that genders
13:53:26 <Vq^> impl: it's more of an artifact from the phonetic world
13:53:30 <impl> Vq^: Well, linguistically-speaking, that's what they are :P
13:53:33 <maltem> impl, grammatically they're the same, but they don't have a female/male connotation
13:53:40 <impl> Yeah
13:54:23 <Vq^> not that im defending them, it would be better to have just one of them
13:54:25 <maltem> for a German learning Swedish it feels a bit like ett is das, and en is der/die merged into one gender
13:55:16 <Saizan> so it's persons vs. objects?
13:55:27 <Saizan> *people
13:55:50 <copumpkin> if I have f :: forall x. ...; f = ... where y :: F x, is are those two x variables the same?
13:55:54 <maltem> not really, it's just that often when Swedish uses ett, German uses das, and so on
13:56:08 <Saizan> copumpkin: yes
13:56:10 <copumpkin> hmm
13:56:35 <FunctorSalad_> copumpkin: that's the effect of scoped ty vars
13:56:36 <maltem> copumpkin, with -XScopedTypeVariables yes
13:56:47 <copumpkin> yup
13:56:53 <maltem> otherwise, no
13:57:16 <copumpkin> yeah, I have scoped tyvars enabled
13:59:22 <Berengal> Without scopes type variables, type variables are scoped to a single expression, right?
13:59:31 <Gilbert> hi everyone
13:59:36 <Berengal> Except in class definitions...
14:00:26 <copumpkin> Saizan: I think I have the zero case of my induction down, but the more complicated one still eludes me :P
14:00:53 <Gilbert> why does the signature "someFunc :: (Integral a, Fractional b) => [a] -> b" work, but the signature "someFunc2 :: [Integral] -> Fractional" not work?
14:01:01 <Gilbert> (i'm new to haskell)
14:01:05 <Cale> Gilbert: because typeclasses are not types
14:01:07 <Saizan> copumpkin: what did you choose for p?
14:01:25 <Gilbert> Cale: ahh, okay... so I assume I'll be learning more about typeclasses in a later chapter
14:01:32 <Gilbert> I'm reading RWH, on chapter 3
14:01:36 <copumpkin> Saizan: PlusIsNat x, basically (where PlusIsNat is a newtype wrapping IsNat)
14:01:37 <Cale> yeah
14:01:44 <Gilbert> aite
14:01:44 <Gilbert> thx
14:02:08 <copumpkin> Saizan: I changed my Plus so that I decompose the second parameter to Plus rather than the first
14:02:15 <copumpkin> to avoid having to flip it
14:02:27 <copumpkin> in fact, I could probably avoid the newtype because of that
14:02:29 <copumpkin> hrm
14:02:34 <Saizan> you could have flipped while writing the newtype
14:02:44 <copumpkin> yeah, that's what I had first
14:02:55 <copumpkin> but I decided to avoid flipping and just change the Plus
14:03:10 <Saizan> ok, so you're recursing on y?
14:03:14 <copumpkin> yeah
14:04:14 <Saizan> the inductive step is quite trivial, actually, all the work is done by the type families solver
14:04:22 <copumpkin> hmm
14:04:52 <copumpkin> I end up with
14:04:52 <copumpkin>       Expected type: IsNat (x :+ y1)
14:04:52 <copumpkin>       Inferred type: IsNat (x :+ y)
14:05:29 <copumpkin> I'm going to get rid of the newtype
14:05:59 <jaredj> data S = S { a :: foo, b :: bar }
14:06:02 <jaredj> x :: S
14:06:16 <jaredj> what's the syntax to express x but with a change in b?
14:06:19 <Berengal> copumpkin: Type programming, are we?
14:06:41 <Berengal> jaredj: x{b=newB}
14:06:46 <copumpkin> Berengal: yeah, I've been spending most of my time wiping my splattered brains off the wall though
14:07:11 <FunctorSalad_> x{b=foobar}
14:07:17 <copumpkin> oh actually, I do need the newtype
14:07:21 <FunctorSalad_> missed Berengal's answer
14:07:34 <jaredj> Berengal: thx
14:07:43 <copumpkin> or I need currying on type constructors :P
14:07:45 <Berengal> copumpkin: Heh, I've been there, trying to make a map indexable by more than one key
14:07:47 <copumpkin> but probably just a newtype
14:08:05 <FunctorSalad_> Berengal: I wrote such a thing recently too
14:08:09 <jaredj> FunctorSalad_: thx too
14:08:18 <Berengal> FunctorSalad_: Got it working? Because I didn't
14:08:47 <FunctorSalad_> Berengal: yep. essentially, I ended up making a "Map TypeRep AnyMap"
14:08:58 <FunctorSalad_> where AnyMap is an existential wrapper for Map
14:09:20 <Berengal> How did the internals work?
14:09:56 <FunctorSalad_> you lookup the right map according to type in the outer map, then cast or unsafeCoerce the looked-up inner map
14:09:57 <Berengal> I tried making an 'IntMap value' the value map, and several 'Map foo Int' indexing it
14:10:21 <Berengal> unsafeCoerce eh?
14:10:23 <copumpkin> Saizan: just to make sure, is it okay for me to take that p Z for induction, and make p = my partially applied newtype constructor?
14:10:47 <FunctorSalad_> Berengal: well it's safe if the whole thing is opaque
14:11:05 <Berengal> I figured I'd have to use that as well, and that's when I stopped. The point was really to get it working without it
14:11:07 <FunctorSalad_> (and users don't write bogus Typeable instances ;))
14:11:13 <Saizan> copumpkin: which p Z?
14:11:34 <FunctorSalad_> Berengal: you can use cast too, but it's a pointless waste of cycles since you know which maps you put in there
14:11:36 <copumpkin> Saizan: from induction :: forall p n. Nat n => n -> p Z -> (forall x. Nat x => p x -> p (S x)) -> p n
14:12:06 <Berengal> FunctorSalad_: Also, cast uses dynamic typing, which I feel shouldn't really be neccessary
14:12:07 <copumpkin> I want p there to be PlusIsNat theOtherx
14:12:46 <Saizan> copumpkin: why theOtherx?
14:13:02 <Berengal> I got to the point where I could write' (emptyMap, nameSelector ::: numberSelector ::: Nil) = createMap (name ::: number ::: Nil)' and have it typecheck
14:13:13 <copumpkin> well, just to avoid confusion with that forall x. in the inductive step
14:13:16 <Saizan> "PlusIsNat x" is what i'd use
14:13:26 <Saizan> ah yeah
14:13:39 <Saizan> the 'x' is the one in the signature of plusIsNat
14:14:46 <copumpkin> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6305#a6305 is what I have
14:14:48 <Saizan> so for the base case you prove PlusIsNat x Z, nad for the inductive case you prove forall i. Nat i => PlusIsNat x i -> PlusIsNat x (S i)
14:15:23 <Saizan> copumpkin: you miss a type annotation to witnessNat
14:15:33 <copumpkin> oh!
14:15:37 <copumpkin> that makes perfect sense
14:15:47 <copumpkin> lol
14:15:51 <Berengal> FunctorSalad_: You wouldn't happen to have that code lying around, or even better, cabalized, would you? It's a nifty thing to have
14:15:53 <FunctorSalad_> Berengal: I suppose you could just put Eithers or existential types into a regular map as well
14:15:55 <copumpkin> that fixed it :P
14:16:55 <Saizan> copumpkin: propagation by type inference doesn't work well with type families, because they aren't injective, so you have to make the type unify in other ways
14:17:02 <copumpkin> ah
14:17:33 <FunctorSalad_> Berengal: hmm it's a quick hack right now but if there's interest maybe I should package it up
14:18:21 <FunctorSalad_> is there some established MapLike class?
14:18:24 <jaredj> i can manipulate dates and times with Data.Time
14:18:29 <jaredj> how can i get the current date and time?
14:18:37 <jaredj> is it in there and i missed it?
14:19:02 <Saizan> if F is a type family with one index F x ~ F y doesn't prove x ~ y, consider F Int = Bool; F Integer = Bool
14:19:46 <copumpkin> Saizan:         induct x = case unPlusIsNat x of IsNat -> PlusIsNat IsNat -- ?
14:19:52 <Berengal> FunctorSalad_: I've had use for one a couple of times. That, and the type families paper, is what prompted me to try to write my own
14:20:46 <Berengal> If there was one on hackage, I'd be happy
14:21:08 <FunctorSalad_> Berengal: sorry it's no fancy type-level magic, like I said, just Typeable+coercion
14:21:49 <FunctorSalad_> Berengal: OTOH, Map.lookup returns Maybe v already anyway so I don't see what static guarantees you lose by dynamic typing there
14:21:55 <Berengal> FunctorSalad_: Also, it's opaque. I don't really care that much about the implementation, as long as it gives me the functionality I want
14:21:56 <Saizan> copumpkin: yup!
14:22:32 <Berengal> FunctorSalad_: Hmm, it seems we might have a somewhat different design in mind
14:23:43 <FunctorSalad_> Berengal: a second, I'll clean it up a bit and upload it
14:24:33 <Gracenotes> :o
14:24:34 <copumpkin> now for commutativity :o
14:24:47 <Gracenotes> copumpkin: dream of types?
14:24:53 <copumpkin> Gracenotes: yeah!
14:25:17 <Berengal> FunctorSalad_: Consider the list function 'lookupBy :: (Eq b) => (a -> b) -> b -> [a] -> Maybe b' (enabling things like 'lookupBy phoneNumber number personWithPhoneNumberList'). I wanted something that is to Map what this is to ALists
14:25:30 <FunctorSalad_> Gracenotes: this waking up and confusing types with reality thing you mentioned is real, and scary
14:25:38 <FunctorSalad_> does it mean we're going insane?
14:25:45 <FunctorSalad_> or is it just the mind consolidating learned stuff
14:25:53 <Gracenotes> oh, nice. I dreamed... mainly of going on various errands for people living in pseudo-urban places for no apparent reason
14:26:42 <EnglishGent^afk> coi :)
14:26:55 <copumpkin> hmm, commutativity sounds hard to prove
14:27:01 <FunctorSalad_> Berengal: so it's not a typing issue after all?
14:27:10 <Gracenotes> FunctorSalad_: when we wake up, we try to make sense of the world. If you're really into something, like types or math or a fictional plot, we might see the world this way...
14:27:15 <EnglishGent> hi copumpkin :)
14:27:19 <copumpkin> hi EnglishGent
14:27:39 <FunctorSalad_> Berengal: I think that wouldn't work with Map unless the first arg is a monotonic function
14:27:45 <Berengal> FunctorSalad_: Well, it becomes a typing issue. It's easy to do this with alists, because they aren't indexed, but it's hard to do with Map, because it is
14:27:52 <Gracenotes> FunctorSalad_: or if an alarm clock's time is the first thing we see, we might interpret the goal as changing the time, rather than actually getting up >_>
14:28:00 <Gracenotes> in my experience anyway
14:28:27 <Gracenotes> but *usually* I know what's going on
14:28:39 <Berengal> FunctorSalad_: I had a function that was something like 'lookupBy :: Selector key map -> key -> map -> maybe value'
14:28:41 <jaredj> import Data.Time (UTCTime) seems to have imported the UTCTime type but not the UTCTime data constructor. how do i import that?
14:28:57 <FunctorSalad_> Berengal: how is Map more indexed than lists? (except for having two parameters)
14:29:06 <Berengal> FunctorSalad_: It had a six-line long context preceeding that type, and the implementation never got past 'undefined'
14:29:18 <FunctorSalad_> :)
14:29:22 <Berengal> FunctorSalad_: Map is indexed by its keys
14:29:53 <FunctorSalad_> you mean index in the usual data structure sense, not type parameters?
14:29:59 <FunctorSalad_> I'm confused
14:30:08 <Berengal> Yes, the data structure sense, not parameters
14:31:06 <Berengal> Basically, I wanted a pure database-ish structure
14:32:38 <FunctorSalad_> Berengal: ok, then we were talking about completely different things ;) I thought you meant something like sum_k Map k v
14:33:01 <FunctorSalad_> (a map where you have keys of different types)
14:35:39 <Berengal> Ah, no
14:36:22 <Berengal> What I've used for this in the past is something like (Map Foo Int, Map Bar Int, IntMap FooBarRecord)
14:36:39 <Berengal> The idea is simple, but generalizing it is beyond me...
14:43:37 <conal> my last two blog posts are about maps with polymorphic keys
14:45:02 * Berengal reads
14:45:31 <conal> i'm not satisfied with where i got.  suggestions most welcome!  it's still a sticking point for my current dsel implementation.
14:45:58 <conal> because i want polymorphic hash-consing as part of efficient, thorough CSE.
14:46:26 <shapr> I may not be able to help with your code, but I can give you a hug!
14:46:27 * shapr hugs conal
14:46:37 * conal smiles
14:49:05 <dafra> > 1+1
14:49:06 <lambdabot>   2
14:49:16 <conal> GADTs are great for typed DSELs.  then memoization leads to this problem of maps/tries being monomorphic.
14:49:23 <conal> (each map/trie, that is)
14:49:48 <copumpkin> Saizan: do I need nested induction to prove commutativity?
14:49:51 <conal> s/leads to/encounters/
14:50:08 <soupdragon> have youthought about adding memoization to the language instead of as a library?
14:50:27 <soupdragon> (like does it solve the GADT problem specifically)
14:50:54 <conal> soupdragon: i don't know if it'd help.
14:52:09 <conal> john hughes's original "lazy memo functions" paper suggested a language construct.
14:54:08 <Berengal> conal: That looks interesting
14:55:20 <conal> Berengal: i'm also hoping to avoid unsafeCoerce
14:55:25 <Berengal> However, at first glance it doesn't look like it'll help me with my map...
14:56:04 <Berengal> I'm not looking for polymorphic maps, I'm looking for a map that have several index maps pointing into it
14:56:12 <Berengal> can have*
14:56:50 <conal> Berengal: neat.  do you have some uses in mind?
14:57:53 <Berengal> conal: data Person = Person{name::String, number :: PhoneNumber, [more fields]}. 'lookupBy firstName "Bob" personMap'
14:57:57 <Berengal> That kind of thing
14:58:27 <conal> oh, wow.
14:58:38 <soupdragon> like SQL on data ?
14:58:58 <Berengal> soupdragon: Yes, it's not far from a database
14:59:11 <Berengal> Except, of course, it lacks persistance, and joins and all that other fun stuff
14:59:23 <Berengal> But I often don't need them
15:00:10 <Berengal> The last use for something like that I encountered was when I was playing around with concurrency, writing a simple chat server, and I needed to index connected clients by both ThreadId and Nick
15:01:50 <Gracenotes> @djinn-env
15:01:51 <lambdabot> data () = ()
15:01:51 <lambdabot> data Either a b = Left a | Right b
15:01:51 <lambdabot> data Maybe a = Nothing | Just a
15:01:51 <lambdabot> data Bool = False | True
15:01:51 <lambdabot> data Void
15:01:53 <lambdabot> type Not x = x -> Void
15:01:57 <lambdabot> class Eq a where (==) :: a -> a -> Bool
15:20:49 <Berengal> Is there a standard function for truncating a Fractional at some point other than 10^0?
15:22:17 <monochrom> No.
15:22:51 <Berengal> :(
15:23:33 <monochrom> Perhaps write yourself code to multiply, truncate, divide.
15:23:47 <Berengal> Yeah, that's what I'm doing
15:23:57 <Berengal> Was just hoping there was one already, so I didn't have to
15:24:17 <monochrom> Perhaps showFFloat then read back.
15:24:52 <hackagebot> cal3d 0.1 - Haskell binding to the Cal3D animation library. (GregoryWeber)
15:25:02 <monochrom> The operation makes no sense on a base-2 representation anyway.
15:25:23 <monochrom> It probably makes more sense if you use BCD.
15:25:24 <Berengal> I already have 'truncateAt power n = truncate (n* (1 / power)) * power'
15:26:32 <Berengal> I just made a simple implementation of newton, and want to truncate (or round) the answer at the epsilon I use
15:26:52 <hackagebot> cal3d-opengl 0.1 - OpenGL rendering for the Cal3D animation library (GregoryWeber)
15:27:52 <hackagebot> cal3d-examples 0.1 - Examples for the Cal3d animation library. (GregoryWeber)
15:35:14 * copumpkin tries to prove that x + 0 == 0 + x
15:35:40 <soupdragon> you might as well go for x + y == y + x
15:35:53 <copumpkin> I was going to use my + 0 case as a base case for that
15:37:07 <Berengal> soupdragon: The only proofs of x + y == y + x I've seen require a proof/axiom saying x + 0 = 0 + x
15:37:25 <soupdragon> you're right, my mistake
15:37:39 * copumpkin renamed TEq to :==
15:37:43 <copumpkin> seems more intuitive to me
15:40:51 <monochrom> <TRWBW> copumpkin: what are your axioms? Oh now I have lost interest </TRWBW>
15:40:57 <tibbe> sometimes I wish I could just click on an expression in emacs and get its inferred type
15:41:26 <copumpkin> monochrom: TRWBW? :o
15:41:47 <monochrom> A famous character in #math. I'm mimicking his typical behaviour.
15:45:31 <kniu> :t foldr
15:45:32 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
15:47:26 <Codex_> copumpkin: can't you prove that using definition on N and iteration. It involves the successor n times. Basically (N->N) -> (N -> (N->N) ). The x+0 = x is one of the property of that function.
15:48:47 <tibbe> sometimes GHC's type errors can be wildely unhelpful
15:49:17 <MyCatVerbs> Berengal: x + 0 = x and 0 + x = x can easily be proved from the Peano axioms, though.
15:49:25 <SamB> try the errors from GCC 4.3 or earlier
15:50:00 <monochrom> What is "helpful" error message?
15:50:10 <MyCatVerbs> tibbe: the ? feature is useful for this. Can't remember what the proper name of it is, but here's an example.
15:50:16 <Berengal> MyCatVerbs: Sure it can. I've also seen it "proved" by stating "(I, +, 0) is a monoid"
15:50:19 <monochrom> (I for one prefer "bashing" error messages.)
15:50:41 <SamB> monochrom: well, for a type error, it's best if it tells you what two types it couldn't match and what in the source code was causing it to try and match them
15:50:53 <MyCatVerbs> @type (?m >>= ((:[]) . toUpper))
15:50:54 <lambdabot> (?m::[Char]) => [Char]
15:50:57 <hackagebot> hack-handler-simpleserver 0.0.0 - A simplistic HTTP server handler for Hack. (MichaelSnoyman)
15:51:11 <monochrom> I think GHC already does that beautifully.
15:51:11 <tibbe> monochrom: one that is very misleading, I was applying the wrong data constructor and got a unification error
15:51:29 <SamB> monochrom: well, I'm just saying what GCC didn't do until quite recently ;-)
15:51:30 <tibbe> the infinite type ones are especially unhelpful, almost never point to the right place
15:51:46 <MyCatVerbs> tibbe: so if you take some expression in which you have some x that GHC tells you of the wrong type, just replace x with ?x and - if the rest of the expression is workable - you will get a decent idea.
15:52:04 <SamB> well, okay, GHC could do better in telling you where the error might be
15:52:33 <tibbe> MyCatVerbs: oh, what does that do?
15:53:09 <copumpkin> Codex_: yeah, trying to figure out how to phrase that in types
15:53:22 <SamB> tibbe: it uses an obsolete-except-for-figuring-out-types extension to give you a clearer idea of the type
15:53:23 <MyCatVerbs> tibbe: look at the example above. :)
15:53:55 <monochrom> "implicit parameters"
15:54:00 <tibbe> MyCatVerbs: oh, I missed it
15:54:02 <MyCatVerbs> tibbe: it's an extension. ?x starts out with the type (forall a. a), and then it infers something that will work.
15:54:20 <tibbe> I see
15:54:27 <MyCatVerbs> tibbe: and it gives you the type that x must have, along with the type that will result for the whole expresion.
15:54:32 <jaredj> i want to replace all "&" with "&amp;" in a string. is there a function for that or do i make one?
15:54:52 <MyCatVerbs> If your types are *very* messed up, then it will still not work, because there may be no type for x that will work at all. Oh well.
15:55:04 <MyCatVerbs> Poo happens.
15:55:11 <tibbe> MyCatVerbs: hah, yes, thanks
15:55:40 <jaredj> (i hoogled and could not find it)
15:55:48 <tibbe> > concatMap (\c -> if c == '&' then "&amp;" else [c]) "asdasd&*foo&&"
15:55:50 <lambdabot>   "asdasd&amp;*foo&amp;&amp;"
15:56:02 <tibbe> jaredj: ^^
15:56:13 <tibbe> jaredj: do you want proper URL escaping?
15:56:33 <MyCatVerbs> There should be something like that in the Network.URL library.
15:56:39 <tibbe> jaredj: are you using String or ByteString?
15:56:45 <MyCatVerbs> Er, URI.
15:56:58 <jaredj> tibbe: ah i was missing the concat part. no urls, this is an sgml document
15:57:09 <kniu> @src foldr
15:57:10 <lambdabot> foldr f z []     = z
15:57:10 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
15:57:17 <jaredj> &amp is the only entity i expect
15:57:20 <MyCatVerbs> Oh my bad, you want HTML character encoding, not URI encoding. Silly me.
15:57:20 <monochrom> jaredj: http://www.vex.net/~trebla/haskell/xlhs.xhtml
15:57:23 <tibbe> jaredj: ok
15:57:44 <monochrom> perhaps you just need the "escape" function at the bottom.
15:58:53 <jaredj> dang. i thought i could do it with a fold but couldn't figure out how
15:59:22 <MyCatVerbs> jaredj: you *can* do it with a fold, but only because you can write concatMap with a fold. =)
15:59:32 <dafra> @src scanl
15:59:32 <lambdabot> scanl f q ls = q : case ls of
15:59:32 <lambdabot>     []   -> []
15:59:32 <lambdabot>     x:xs -> scanl f (f q x) xs
16:00:10 <copumpkin> hmm, has anyone done a type-level number library using a binary representation (type-level list of bits)
16:00:14 <MyCatVerbs> > foldr (\c r -> if c == '&' then "&amp;" ++ rest else c : rest) "" "Bert & Ernie"
16:00:16 <lambdabot>   Not in scope: `rest'Not in scope: `rest'
16:00:22 <MyCatVerbs> > foldr (\c rest -> if c == '&' then "&amp;" ++ rest else c : rest) "" "Bert & Ernie"
16:00:23 <copumpkin> it wouldn't be very readable, but would be the most dense representation I think?
16:00:23 <lambdabot>   "Bert &amp; Ernie"
16:00:46 <monochrom> Don't bother with fold.
16:01:03 <MyCatVerbs> monochrom: indeed. List monad (or concatMap) much better.
16:01:07 <MyCatVerbs> copumpkin: I thought there was already a base 10 one on Hackage?
16:01:14 <copumpkin> yeah, I've seen the base 10 one
16:01:25 <copumpkin> I guess that'd be a lot more readable in error messages :P
16:01:32 <monochrom> Oh wait, I used foldr myself. LOL
16:01:36 <jaredj> hehe
16:02:06 <copumpkin> these unary ones are nice but not very practical
16:06:20 <soupdragon> copumpkin Coq has binary integers
16:06:42 <copumpkin> soupdragon: but it probably has a nice mechanism for displaying them too, right?
16:06:52 <copumpkin> I can't write a type-level Show instance for errors :/
16:08:26 <copumpkin> can I put typeclass constraints on type synonyms?
16:10:29 <monochrom> IIRC no or ignored.
16:10:34 <copumpkin> ah :/
16:10:52 <copumpkin> no nice extensions to do it?
16:10:53 <_roconnor> I did ulimit -m 524288, but my ghci process still take up tonnes of mem
16:10:55 <_roconnor> :(
16:11:06 <_roconnor> I don't understand how to use ulimit
16:11:26 <_roconnor> oh maybe I have to limit the virtual memeory
16:12:58 <EvilTerran> copumpkin, maybe -RankNTypes
16:13:08 <EvilTerran> but you might also need explicit foralls
16:13:12 <copumpkin> already have that enabled
16:13:20 <copumpkin> I could proably hide it using those though
16:13:43 <_roconnor> there is goes
16:13:44 <copumpkin> but I need something like type (X a, Y b) => Moo a b = ...
16:13:59 <EvilTerran> not sure how you'd put a class constraint on a parameter to a type synonym, though
16:14:11 <copumpkin> ah well
16:14:37 <copumpkin> I just wanted to write a Nat constraint on m and n here: type Mat a m n = Vec (Vec a m) n
16:16:43 <copumpkin> I can put constraints on the functions that operate on it, but it's meaningless without that Nat constraint so I thought I'd put it on the type
16:16:57 <copumpkin> (and I'm reluctant to slap an additional constructor onto it)
16:17:36 <jaredj> mmorrow, sm: http://patch-tag.com/r/ofx1-censor
16:17:42 <EvilTerran> copumpkin, wouldn't it make more sense for the definition of Vec to impose the Nat constraint?
16:17:55 <sm> ooh
16:18:02 <copumpkin> EvilTerran: good point
16:18:08 <EvilTerran> :)
16:18:17 <copumpkin> I had it on just the Cons constructor
16:18:20 <copumpkin> but this is nicer
16:18:38 <copumpkin> oh dammit
16:18:44 <sm> jaredj: what's the repo url for that ? site is down
16:18:46 <copumpkin>     No context is allowed on a GADT-style data declaration
16:18:46 <copumpkin>     (You can put a context on each contructor, though.)
16:21:20 <SamB> copumpkin: don't conntext s on ordinary data declarations do the wrong thing anyway?
16:21:36 <copumpkin> hmm, does it?
16:21:49 <sm> jaredj: ah, I see
16:22:15 <copumpkin> EvilTerran: any ideas?
16:22:56 <sm> we were just discussing anonymisation here: http://thread.gmane.org/gmane.comp.finance.ledger.general/1250
16:23:58 * EvilTerran vaguely recalls what SamB refers to
16:30:48 <_roconnor> @hoogle nf
16:30:49 <lambdabot> Control.Parallel.Strategies class NFData a
16:30:49 <lambdabot> Distribution.PackageDescription allBuildInfo :: PackageDescription -> [BuildInfo]
16:30:49 <lambdabot> Control.Exception AssertionFailed :: String -> Exception
16:31:07 <sm> jaredj: that seems to work well on my bank's ofx
16:31:30 <copumpkin> what's my best bet? to just move to a newtype?
16:33:32 <copumpkin> anyway, back to commutativity
16:38:09 <copumpkin> so I've proved x + 0 == 0 + x, but it may be overly complex
16:38:58 <SimonRC> in what way?
16:39:09 <SimonRC> or rather, where?
16:39:47 <copumpkin> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6306#a6307
16:39:57 <copumpkin> feels too complicated for something that simple
16:41:51 <SimonRC> what's "Refl?"
16:42:00 <copumpkin> data (:==) a b where
16:42:00 <copumpkin>   Refl :: (a ~ b) => (:==) a b
16:42:50 <LightX> Någon från chalmers här? :)
16:42:55 <skorpan> <-
16:43:13 <LightX> Hehe hade varit lite konstigt annars :)
16:43:23 <LightX> hm skorpan till och med :O
16:43:35 <LightX> data va?
16:43:35 <skorpan> wut
16:43:39 <skorpan> ja
16:43:42 <LightX> nice
16:43:48 <LightX> då är det till och med rätt scorpa
16:43:50 <LightX> :P
16:43:59 <shapr> hej, engelska snÃ¤lla
16:44:05 <shapr> eller #haskell.se
16:44:33 <LightX> only swedish lamers using haskell anyway ;)
16:44:44 * shapr looks at the channel users...
16:44:44 * copumpkin coughs
16:44:49 <shapr> @users #haskell
16:44:49 <lambdabot> Maximum users seen in #haskell: 658, currently: 611 (92.9%), active: 18 (2.9%)
16:45:03 <shapr> LightX: Dude, you really think there are ~700 Haskellers in Sweden?
16:45:48 <shapr> LightX: There are some excellent Haskell jobs here in Boston :-)
16:45:50 <dmhouse> Sweden's only got a population of about 750 anyway...
16:45:50 <LightX> Yeah, havent haskell been a course at chalmers for like 10 years or something?
16:45:58 <shapr> dmhouse: hah
16:46:06 <LightX> that would leave around 1000 sorry students who knows haskell ;)
16:46:22 <shapr> LightX: And it's been a course at UNSW in Australia for years too. And in universities here in the USA.
16:46:34 <LightX> so?
16:46:34 <skorpan> LightX: who are you btw?
16:46:49 <shapr> Yeah, who's your teacher? Koen?
16:46:50 <LightX> a sorry student at chalmers :)
16:46:55 <LightX> yeah..
16:47:15 <skorpan> my teacher was hughes...bitches.
16:47:19 <MyCatVerbs> LightX: I make it at the very least three or four hundred having H98 flashed at them via cs.bris.ac.uk. Not sure how long that course has been on for, though.
16:47:24 <shapr> Hughes is awesome.
16:47:27 <copumpkin> my teacher was #haskell
16:47:30 <shapr> Mine too!
16:47:34 <LightX> I think hughes was better, i had a guest lecture with him
16:47:44 <shapr> Though I was living in Boden most of the time I was learning Haskell.
16:47:46 <MyCatVerbs> My teacher was YAHT. =D
16:47:59 <LightX> boden <3
16:48:24 <LightX> Isn't it kind of lonely so far in north?
16:48:57 <shapr> I had a woman to keep me warm.
16:49:05 <shapr> But I've since moved back to the USA.
16:49:18 <shapr> I'm from Alabama, where are you from?
16:49:28 <monochrom> My teacher was me, I, and myself.
16:49:55 <LightX> Omg, that's really stong considering the lack of civilians there
16:50:17 <LightX> Cool, how long did you stay in sweden?
16:50:21 <MyCatVerbs> shapr: where's Boden?
16:50:23 <LightX> I'm from sweden
16:51:38 <shapr> LightX: Yeah, but where in Sweden? Are you from Kiruna or Stockholm? :-)
16:52:00 <LightX> I'm even more north actually
16:52:06 <LightX> around gotherburg
16:52:19 <skorpan> gothenburg is north of kiruna?
16:52:20 <shapr> MyCatVerbs: http://maps.google.com/maps?f=q&source=s_q&hl=en&geocode=&q=boden,+sweden&sll=42.391276,-71.094762&sspn=0.015911,0.03298&ie=UTF8&t=h&z=8&iwloc=A
16:52:27 <shapr> skorpan: Yeah, I was confused for a sec myself
16:52:46 <LightX> hm south ** :)
16:53:06 <shapr> MyCatVerbs: if you get directions to gothenburg, sweden from there, you'll see the distance from where I lived to where Chalmers is located.
16:53:06 * skorpan is trying to figure out who the heck LightX is
16:53:42 <shapr> LightX: So anyway, you're here to learn about Haskell, right?
16:53:45 * LightX is someone who knows skorpan
16:54:01 <LightX> naa i allready tried twice ^^
16:54:17 <araujo> Third is the victory!
16:54:30 <LightX> i actually passed but the i got failed on some bonus points i couldn't use for some reasone :E
16:54:37 <LightX> hopfully
16:54:48 <LightX> but i guess i will survive without haskell ^^
16:55:02 <MyCatVerbs> shapr: shit, that must've been cold.
16:55:23 <LightX> hehe around 20 minus at winter
16:55:35 <araujo> LightX, But Haskell cannot survive with you!
16:55:36 <LightX> and alot of mosquitos at summer ^^
16:55:43 <araujo> without*
16:55:45 <araujo> :D
16:56:00 <LightX> haha i think you where right with "with"
16:56:05 <LightX> :)
16:56:09 <araujo> haha
16:56:14 <copumpkin> damn!
16:56:15 <copumpkin>     Couldn't match expected type `S (y :+ z)'
16:56:15 <copumpkin>            against inferred type `S z :+ y'
16:56:20 <copumpkin> almost there
16:56:21 <LightX> That's why it's constantly rejecting me
16:56:37 <araujo> LightX, what is your programming background?
16:57:42 <LightX> It's at oop, and some very basic qb. But the really programming background did i actually from when i was studing haskell
16:58:09 <araujo> uh?
16:58:43 <inimino> "qb"?
16:58:49 <araujo> I mean, specifically, do you have experience with other languages?
16:58:50 <LightX> yeah, i wasn't never really so conserned about the thinking with programming and applications before i programmed in haskell
16:58:54 <LightX> quick basic
16:59:03 <inimino> oh
16:59:42 <LightX> i have experience in qb, vb, c,c# and asm
16:59:52 <araujo> ah, so, we could even say Haskell could be your first language for getting deep into programming?
16:59:53 <soupdragon> same
16:59:55 <pikhq> Basic scars programmers.
17:00:07 <jaredj> sm: did it miss anything?
17:00:20 <LightX> yeah we could say that
17:00:27 <pikhq> araujo: C and asm could be considered getting deep into programming, but it depends on how C is being used.
17:00:34 <shapr> MyCatVerbs: Yeah, got down to -44Â° on the doorstep once.
17:00:52 <araujo> pikhq, not talking about the language themselves, but about LightX's experience
17:00:56 <LightX> Naa i found haskell to be a nice language, but then it was these small problems i allways get and i have it difficult with the "thinking"
17:01:00 <pikhq> Ah.
17:01:00 <araujo> it's what I am understanding from him
17:01:03 <sm> I haven't checked carefully.. I mailed you an example
17:01:05 <MyCatVerbs> shapr: Wow, incomprehensible.
17:01:29 <shapr> MyCatVerbs: Cars wouldn't start, power lines contracted and snapped, we stuck next to the wood burning stove and stayed away from the windows.
17:01:40 <araujo> LightX, if you are used to imperative programming , the functional 'thinking' might take a while to grasp
17:01:40 <pikhq> So, it's a matter of "how much of programming does LightX grok". XD
17:02:42 <LightX> yeah, i have it alot easyer with asm and c then i have with haskell
17:03:04 <araujo> LightX, but that's very common in such a case, don't worry about it .... you just need to keep practicing and reading Haskell for a while until you really grasp the thinking, also, it'd be very helpful if you read some 'basic functional programming' theory
17:03:09 * pikhq has always found C and asm a royal bitch to do anything with
17:03:39 <pikhq> I mean, *thinking* about it is easy, but there's so much stuff you can get horribly wrong while appearning superficially correct.
17:03:47 <LightX> Yeah, i think i actully should try to read the book this time ^^
17:03:56 <araujo> LightX, lambda, currying, recursion, higher order functions ....
17:04:13 <pikhq> (manual memory management -- easy to think of, easy to do, hard to be sure you're correct about.)
17:04:29 <shapr> easy to do it incorrectly
17:04:45 <LightX> yeah higher order functions are one of the most difficult tools i've used in programming
17:04:49 <araujo> LightX, just to name a few basic concepts that could help greatly at your understanding
17:04:50 <pikhq> Well, yes.
17:05:03 <shapr> LightX: The big downside is that C# is a lot less interesting once you really understand Haskell.
17:05:15 <LightX> yeah they say so
17:05:17 <pikhq> shapr: C# was ever interesting?
17:05:18 <araujo> Well, that's because ....
17:05:28 <benmachine> I used to think C was fun
17:05:29 <shapr> pikhq: Well, no.. but Java was at one point my favorite language.
17:05:29 <araujo> Haskell is bad ... It makes you hating other languages
17:05:31 <araujo> :P
17:05:36 <benmachine> haskell taught me otherwise >_>
17:05:39 <shapr> Then I found Python, then I found Haskell.
17:05:56 <pikhq> I'm still fond of Tcl.
17:06:34 <shapr> And I'm still fond of Python. But everytime I use Python, I realize I like Haskell a lot more.
17:06:35 <araujo> I like some Tcl ideas, nevertheless, real code tends to look .. so ad-hoc to me :P
17:07:04 <pikhq> Though I'd be much happier with it if they'd stop with the pretenses *and just make functions first-class already*. :P
17:07:22 <LightX> Well i think the importent think is to not "fall in love" with one language, even if it's easy
17:07:45 <soupdragon> LightX: yes
17:07:49 <SimonRC> pikhq: the number of things I have written that are map, search, or filter is ridiculous
17:08:02 <jrick> what's the majority consensus on "ruby vs python" in here?
17:08:06 <SimonRC> and what I wouldn't give for cons and uncons operations
17:08:11 <araujo> you can fall in love ... you just need to have open-mind to accept other relationships in times of needs
17:08:12 <monochrom> Sleep with all languages. Be a whore.
17:08:14 <pikhq> It'd take one minor, *minor* change in semantics to do it (people have done it) and it'd make a lot of people happier.
17:08:22 <jrick> I know a bit of ruby, but am wondering whether python may be better
17:08:26 * araujo points he is talking absolutely about programming languages here :P
17:08:30 <LightX> araujo: That's so true :D
17:08:32 <soupdragon> LightX: A lot thing they have reached nirvana but really they just got swamped
17:08:32 <pikhq> Especially since a lot of the Tclers are also Lispers. :P
17:08:36 <SimonRC> jrick: python doesn't really like first-class functions, IIRC
17:08:39 <araujo> LightX, ;)
17:09:16 <LightX> soupdragon: well i really like the band so :)
17:09:18 <SimonRC> things like map are discouraged in favour of list comprehensions
17:09:31 <pikhq> I mean, heck, you could make lambdas work these days by just saying every statement is implicitly prepended with {*}.
17:09:47 <jrick> SimonRC: have you used ruby at all?
17:10:03 <pikhq> (making lambda be: proc lambda {arglist code} {return [list apply [$arglist $code]]})
17:10:06 <LightX> Well time to go, godnight from sweden
17:10:08 <pikhq> Erm.
17:10:12 <skorpan> godspeed!
17:10:15 <pikhq> proc lambda {arglist code} {return [list apply [list$arglist $code]]}
17:10:20 <araujo> well, I think ruby does handle higher order functions better than python
17:10:20 <copumpkin> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6308#a6309
17:10:26 <pikhq> proc lambda {arglist code} {return [list apply [list $arglist $code]]};# Third time's a charm.
17:10:34 * LightX is looking at skorpan a last time smiling :D
17:10:39 <dancor> jrick: i've only used python.  i never learned any ruby bc i think python and ruby are very similar.  ruby has non-layout (which haskell has optionally) and treats strings as lists of characters, which is more haskellish
17:10:50 <skorpan> what was that?
17:10:52 <SimonRC> jrick: I've used a smigin of Ruby
17:11:07 <araujo> dancor, they might have similar .. mm.. objectives , but they are quite different
17:11:09 <jrick> dancor: yeah, I like the ruby strings, except that they're mutable
17:11:21 <dancor> araujo: not in my view
17:11:37 <skorpan> jrick: aren't python strings as well? the only differenceb eing that monkey patching is more common in ruby?
17:11:41 <araujo> dancor, if you have never used it .....
17:11:51 <araujo> hardly you can see that
17:12:08 <jrick> skorpan: well yeah, but in comparison to a real functional language, it's just not the same
17:12:09 <shapr> skorpan: I think #haskell was *not* what he expected ;-)
17:12:13 * shapr cackles evilly
17:12:35 <skorpan> *** shintah (i=bebble@bebble.olf.sgsnet.se) has quit: "HejdÃ¥!"
17:12:35 <dancor> i stand by it
17:12:40 <skorpan> there goes another chalmerist
17:12:43 <shapr> yep
17:13:01 * pikhq tries hard not to vomit, for C# has been mentioned.
17:13:05 <skorpan> what bothers me is that LightX seems to know who i am, but i have no idea who he is
17:13:52 * shapr shrugs
17:13:58 <shapr> Clearly you're famous.
17:14:04 * araujo has heard C# is taking lot of ideas from functional languages
17:14:33 <pikhq> So's C++; your point?
17:14:42 <jrick> anyways, back to learn you a haskell
17:15:08 <pikhq> (C++0x has lambda expressions and continuations. No currying, though.)
17:15:10 <araujo> C# != C++
17:15:17 <pikhq> Yes.
17:15:33 <skorpan> C# == C++ `mappend` Java
17:15:54 <araujo> hah, some would remove C++ entirely ....
17:15:54 <pikhq> They're both complete and utter messes that can't decide what makes for a good language, so they decided to add everything.
17:16:08 <skorpan> araujo: the C++ part of C# is the name similarity ;P
17:16:16 <araujo> haha right
17:16:36 <copumpkin> anyone have any suggestions about http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6308#a6309 ? it's clearly wrong, but how wrong is my question
17:17:08 <araujo> C still seems a nice name for your new language if you want to make it mainstream in 1 year
17:17:23 <araujo> A nice addition to your name
17:17:30 <pikhq> mv Haskell' C'
17:17:38 <araujo> C-Haskell
17:17:39 <copumpkin> I think it's just because microsoft is pushing it :P
17:17:44 <araujo> Chaskell
17:17:59 <pikhq> Haskerl.
17:18:06 <araujo> it needs C
17:18:08 <SimonRC> pikhq: heh
17:18:19 <pikhq> C `mappend` Haskerl
17:18:28 <SimonRC> araujo: haven't you read about Haskerl?
17:18:39 <araujo> SimonRC, no, i have not
17:18:47 <araujo> erlang relatedÂ¿
17:18:49 <araujo> ...?
17:18:51 <SimonRC> no
17:18:58 <araujo> what is it?
17:18:59 <SimonRC> it's a Haskell-Perl cross
17:19:00 <pikhq> No, it's the unholy lovechild of Perl and Haskell.
17:19:06 <araujo> hah
17:19:14 <SimonRC> a joke one, so far
17:19:18 <araujo> perl6 is the further i have reached in that field
17:19:36 <pikhq> Pugs could easily be made into something akin to that, though.
17:20:03 <araujo> and what is it?, Haskell with sigils?
17:20:16 <SimonRC> araujo: just google it
17:20:25 <SimonRC> there were only a couple of articles on it
17:21:12 <araujo> oh, but this looks like _old_ stuff?
17:22:03 <pikhq> It predates monadic IO.
17:22:09 <pikhq> So, yes.
17:22:39 <pikhq> Erm, no.
17:22:44 <pikhq> Not long after monadic IO.
17:24:07 <araujo> mm.. seems like there never was an implementation ?
17:24:14 * araujo only finding old threads 
17:24:40 <pikhq> It was an April Fool's email.
17:25:39 <araujo> hah, i can see that even Larry participated :P
17:26:13 <Saizan> what was it about?
17:26:22 <araujo> Haskerl
17:26:25 <pikhq> Haskerl?
17:28:19 <skorpan> i'm assuming that's haskell mixed with perl
17:28:20 <sm> aweSOME!
17:28:34 * sm gets test-framework running shell tests with not very much pain at all
17:31:13 <skorpan> first i thought you meant haskell + perl = awesome...
17:48:22 <bremner> heh, me too. Actually, I would like an example of FFI calling haskell from perl
17:48:35 <sm> skorpan: well, that too
17:49:11 <sm> perl probably turned a lot of us on to haskell, when pugs manifested itself
17:50:15 <jaredj> :source mapM
17:50:20 <jaredj> @source mapM
17:50:21 <lambdabot> mapM not available
17:50:24 <jaredj> :P
17:51:24 <sm> test-framework's parallel support runs my (14) shell tests in 1/8s, vs 3 1/2s single threaded
17:51:30 <MyCatVerbs> :t mapM
17:51:31 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
17:51:47 <sm> thank you, max bolingbroke
17:53:34 <MyCatVerbs> > let { mapM f (a:as) = f a >>= (\h -> mapM f as >>= (\t -> return (h:t))); mapM f [] = return []; } in mapM ((:[]).('a',)) [1,2,3]
17:53:36 <lambdabot>   <no location info>: parse error on input `)'
17:53:42 <MyCatVerbs> Blast.
17:55:36 <MyCatVerbs> > let { mapM f (a:as) = liftM (:) (f a) (mapM f as); mapM f [] = return []; } in mapM (\c -> [c,c]) [1,2,3]
17:55:38 <lambdabot>   Couldn't match expected type `([a] -> [a]) -> a'
17:55:51 <MyCatVerbs> > let { mapM f (a:as) = liftM2 (:) (f a) (mapM f as); mapM f [] = return []; } in mapM (\c -> [c,c]) [1,2,3]
17:55:54 <lambdabot>   [[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3]]
17:58:06 <Bacta> @fag sex?
17:58:06 <lambdabot> The answer is: Yes! Haskell can do that.
17:58:38 <jmcarthur> haha
17:58:49 <Berengal> Actually funny...
17:58:56 <bremner> nice to see people celebrating gay pride week
17:59:41 <Bacta> What? They get a whole week?
18:00:40 * bremner checks wikipedia
18:00:43 <McManiaC> haskell is like sex - except i'm having it!
18:00:43 <soupdragon> so much lambda
18:00:54 <McManiaC> ;)
18:01:16 <soupdragon> except there's 700 of us at it
18:01:40 <bremner> wikipedia only knows about gay pride week in toronto. make of that what you will.
18:02:34 <McManiaC> :D
18:05:14 <copumpkin> dammit this commutativity is defeating me
18:05:24 <copumpkin> I think I'm doing it wrong
18:05:37 <tommd> > succ "copumpkin"
18:05:38 <lambdabot>   No instance for (GHC.Enum.Enum [GHC.Types.Char])
18:05:38 <lambdabot>    arising from a use of `...
18:05:45 <tommd> oops
18:05:46 <soupdragon> it seems bizarre to do this stuff in haskell
18:05:51 <tommd> > map succ "copumpkin"
18:05:52 <lambdabot>   "dpqvnqljo"
18:05:57 <copumpkin> soupdragon: instead of coq or agda you mean?
18:06:04 <soupdragon> wwell, instead of Coq
18:06:28 <copumpkin> soupdragon: well, I was curious how far I could push haskell :)
18:06:49 <soupdragon> just seems weird to 'prove' stuff in haskell since the proofs aren't trustworthy
18:07:06 <soupdragon> you might as well do it on paper and then just assume it in haskell it seems like
18:07:42 <copumpkin> well, my goal is to do safe matrix multiplication for now :)
18:07:54 <soupdragon> oh cool. where does commutativity come in that?
18:07:55 <copumpkin> I don't really care that deeply about proving everything
18:08:07 <copumpkin> it was some yak shaving along the way
18:08:26 <copumpkin> I'm pretty new to haskell and it's fun to play with types
18:08:35 <soupdragon> same
18:08:57 <Cale> soupdragon: you mean because of the presence of undefined?
18:09:08 <Cale> (that the proofs aren't trustworthy)
18:09:29 <soupdragon> Cale: pretty mch yeah, you have to go every any proof you write with a fine toothcomb - so why bother putting inot a computer at all?
18:09:55 <FunctorSalad> McManiaC: therefore, haskell is like a cake.
18:10:02 <McManiaC> haha
18:10:15 <McManiaC> ure watching 2 1/2 men arent you
18:10:17 <McManiaC> ;)
18:10:26 <Berengal> undefined proves everything
18:10:31 <FunctorSalad> huh me? I don't know what that is
18:10:35 <McManiaC> hm
18:10:36 <McManiaC> ^^
18:11:04 <Berengal> But it can also be interpreted as False
18:11:12 <Berengal> Or the prolog 'no'
18:11:58 <Cale> soupdragon: Because it still goes some way toward checking that the code is correct. Yes, you have to avoid writing undefined/nonterminating proofs, but provided you avoid that, there are still a lot of things which it ensures you get right.
18:17:48 <tommd> Any PDXers in here right now?
18:19:37 <skorpan> "This article is about the airport of Portland in Oregon"
18:23:28 <Warrigal> > "Wau" ++ (intersperse 'Z' (repeat 'z'))
18:23:30 <lambdabot>   "WauzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZz...
18:23:36 <Warrigal> > "Wau" ++ cycle "zZ"
18:23:37 <lambdabot>   "WauzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZzZz...
18:25:18 <tommd> skorpan: Is that your say of saying you googled PDX?
18:25:25 <skorpan> tommd: yep
18:25:46 <skorpan> well, i searched wikipedia
18:25:52 <tommd> I take it you aren't in the Portland / Seattle area.
18:25:59 <skorpan> i am not
18:26:43 <tommd> Damn, I need to find a way to convince 90% of Haskellers to move to Portland.
18:27:46 <Cale> I think you'll have to convince 90% of Haskellers to move to the US first. ;) After that it should not be so bad.
18:28:44 <tommd> Obviously this implies the US, but Portland is much different from the majority of the US.
18:28:55 <Cale> yeah
18:29:30 <Cale> (that's why it will be easy after you get them into the US to convince them to move there)
18:30:02 <BMeph> 503 in the chizzy? ;p
18:30:34 <tommd> yeah, I got that.   FYI, I'm asking because I recently realized that Creighton moved here and figured we should have a hackathon.
18:31:01 <Gracenotes> hm. How far away are you from the northern california border?
18:31:03 <tommd> The last one was 2006 and a number of folks have moved here since then.
18:31:13 <skorpan> worst idea ever tommd!!!
18:31:19 <skorpan> who would have a hackathon at an airport!????
18:31:22 <tommd> How far is Portland? Four hours perhaps?
18:31:37 <Gracenotes> mm. sounds like the distance between here and philly :)
18:31:37 <tommd> skorpan: Ha!  You can feel free to sit in a coffee shop down town then!
18:32:10 <skorpan> ...on the playground is where i spent most of my days...
18:32:56 <BMeph> ...'til a couple of guys, who were up to no good, started typying C in my neighborhood!
18:32:57 <tommd> oohhh, playground.   Dibs on the swing!
18:33:12 <Gracenotes> tommd: a Java programmer, eh? *eyes suspiciously*
18:33:24 <tommd> What?  I'm not a Java programmer!
18:33:50 <Gracenotes> Java programmers always go for the swing first!
18:33:58 <tommd> Oh, swing!  I got it... took me too long, but I'll use that as further evidence of my unfamilurarity with Java.
18:34:01 <skorpan> GOOD NIGHT AND GOOD LUCK
18:34:35 <Gracenotes> YES SIR
18:42:56 <troutwine> I have some business logic to enforce and it'd be nice to get the type system to do it.
18:43:03 <troutwine> The Logic: I have a data type of four lists. Each list may contain two elements but no more. At least two lists of the four must be empty.
18:43:15 <troutwine> Right now I'm maintaining this all in the functions that work on the data type, but it's a pain and error prone. Thoughts?
18:43:39 <troutwine> (The description is pretty simlified, so I don't have any code to share at the moment.)
18:45:50 <tommd> Couldn't you make an ADT to do this cleaning?
18:45:56 <tommd> errr, *cleanly*
18:46:37 <sjanssen> troutwine: can the lists that contain two elements contain less than two elements?
18:47:01 <troutwine> tommd: I'm not sure how. I'm pretty new to using Haskell for real projects.
18:47:25 <troutwine> sjanssen: Yes. They may contain no more than two, but certainly less.
18:47:32 <FunctorSalad> troutwine: not a type sys solution, but to make it less error-prone you could make the types opaque and only allow access through functions that check the constraints
18:47:51 <sjanssen> troutwine: I don't see a particularly convenient solution
18:47:57 <FunctorSalad> (I agree something more static would be nicer)
18:49:06 <tommd> troutwine: So you you declare a new module and some data type "data FourLists = FL [a] [b] [c] [d]" then only export functions on that data type (and not the FL constructor) then no one but that module can violate the rules.
18:49:54 <tommd> troutwine: Your functions might not be clean, unfortunately.  You might have an "add" function which would either silently fail (returning the original data structure) or could fail via Maybe or Either.
18:50:52 <troutwine> tommd: Ah, I see what you mean. Yes, that's pretty much my current solution. I was rather hoping for something more static, as FunctorSalad put it.
18:50:53 <tommd> Not knowing your fundamental operations, I could be wrong.  It might be that an object is only ever added when another one is removed.  So for some reason you _know_ it won't fail.
18:51:40 <desp> Hm.
18:51:53 <desp> Is it possible to call functions in other modules without importing them?
18:51:59 <desp> I thought Module.fun would be enough.
18:52:05 <sjanssen> desp: no
18:52:12 <sjanssen> (except in ghci)
18:52:13 <tommd> troutwine: Ok, so I don't have any stunning fixes for you.
18:52:18 <desp> sjanssen: aw.
18:52:24 <tommd> sjanssen: Still in college?
18:52:57 <troutwine> tommd: Thanks.
18:53:02 <sjanssen> tommd: no, but also not graduated
18:53:16 <FunctorSalad> troutwine: you could have type parameters that represent the number of empty slots left
18:53:45 <tommd> Ahh, a difficult place to be.
18:53:55 <troutwine> FunctorSalad: I'm afraid that's a bit beyond my comprehension level.
18:54:27 <Bacta> I once had sex with a Chimpanzee
18:54:31 <FunctorSalad> troutwine: btw, if you really just have two non-empty lists of two elements or less, can't you just do an exhaustive enumeration?
18:54:42 <mjk> can ghc do show chinese?
18:55:32 <sjanssen> mjk: Char supports the full Unicode range, but you have to do the encoding and decoding yourself when doing IO
18:56:38 <mjk> sjanssen: can you give a clue?
18:56:47 <FunctorSalad> troutwine: I mean, apparently there are only a handful of possible shapes of the lists
18:57:03 <sjanssen> mjk: try utf8-string, if you use a UTF-8 locale
18:57:13 <sjanssen> (most modern Unix is nowadays)
18:57:22 <mjk> ok
18:57:39 <FunctorSalad> utf8-prelude is good too
18:57:44 <FunctorSalad> (very simple to use)
18:58:16 <troutwine> FunctorSalad: Yes, for the example given. Possibly for the motivating problem, as well.
18:58:20 <tommd> Here's something that has been bothering me for a long while:   When I was first learning Haskell I swore I used some GHC extension that generated helper functions for each constructor.
18:58:20 <tommd> So if I said "data Foo = Abc | Xyz"  I would also get functions "isAbc :: Foo -> Bool" and "isXyz :: Foo -> Bool".
18:58:20 <tommd> Did I dream this?  I've not seen this since my early days and even then I'm not sure it actually happened.
18:58:41 <SamB> tommd: I think you used "derive"
18:58:45 <SamB> @hackage derive
18:58:45 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/derive
18:58:56 <sjanssen> tommd: you're probably remembering a feature of DrIFT
18:58:58 <tommd> derive does such things?
18:59:06 <SamB> http://hackage.haskell.org/packages/archive/derive/0.1.4/doc/html/Data-Derive-Is.html
18:59:27 <SamB> tommd: I think that's the derivation you were thinking of ?
18:59:40 <tommd> Ah, yep - it seems to be.  Thanks!
18:59:42 <SamB> tommd: or perhaps you were using drift
19:00:06 <tommd> Either way, it is the feature I was wanting.
19:02:03 <Taggnostr> how can I split a string in a list of 3 letters-long strings? I'm trying something like groupBy . (take 3) $ "abcxyzpqr"
19:02:49 <SamB> Taggnostr: groupBy doesn't do anything remotely like you want
19:03:21 <SamB> there really ought to be "split into groups of size n" function in Data.List...
19:03:27 <Taggnostr> I thought so, but group didn't help, and that was the other alternative that may have worked
19:03:36 <SamB> ... but I don't think there is :-(
19:04:16 <Taggnostr> what if I want to add a '-' every 3 chars?
19:05:07 <BMeph> Isn't 'chunk'  in the D.L.Utils package? :)
19:05:57 <FunctorSalad> > unfoldr (\x -> if null x then Nothing else Just (splitAt 3 x)) [1..10]
19:05:58 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10]]
19:06:01 <FunctorSalad> :)
19:06:03 <BMeph> It's "easy" enough to write, although it is annoying to has to keep pulling it from a private module. :\
19:06:13 <BMeph> to *have
19:07:12 <FunctorSalad> @let chunkify n = unfoldr (\x -> if null x then Nothing else Just (splitAt n x))
19:07:13 <lambdabot>  Defined.
19:07:37 <FunctorSalad> > intercalate "-" (chunkify 3 "fooooooooooo")
19:07:39 <lambdabot>   "foo-ooo-ooo-ooo"
19:07:55 <Cale> > map (take 3) . takeWhile (not . null) . iterate (drop 3) $ [1..10]
19:07:57 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10]]
19:08:32 <BMeph> Cale: What do you have against unfoldr (and splitAt)? :)
19:09:22 <BMeph> Dang it! We need bifunctors and 2-type monads, already! :\
19:09:31 <FunctorSalad> and restricted monads
19:10:02 <FunctorSalad> what's a 2-type monad though?
19:11:49 <Taggnostr> Prelude Data.List> let f s = if length s > 3 then (take 3 s):f (drop 3 s) else [] in f "foooooooooo"
19:11:49 <Taggnostr> ["foo","ooo","ooo"]
19:11:55 <Taggnostr> but I think it's broken
19:13:39 <ski> > splitAt 3 "foooooooooo"
19:13:40 <lambdabot>   ("foo","oooooooo")
19:13:52 <ski> > splitAt 3 "foo"
19:13:54 <lambdabot>   ("foo","")
19:13:55 <ski> > splitAt 3 "fo"
19:13:56 <lambdabot>   ("fo","")
19:14:25 <Cale> let f s = if length s > 3 then (take 3 s):f (drop 3 s) else [] in f [1..]
19:14:28 <Cale> > let f s = if length s > 3 then (take 3 s):f (drop 3 s) else [] in f [1..]
19:14:38 <lambdabot>   mueval-core: Prelude.read: no parse
19:14:38 <lambdabot>  mueval: ExitFailure 1
19:15:09 <Cale> length is bad at infinite lists
19:15:56 <ski> > unfoldr (\xs -> if null xs then Nothing else Just (splitAt 3 xs)) "foooooooooo"
19:15:57 <lambdabot>   ["foo","ooo","ooo","oo"]
19:15:59 <ski> > unfoldr (\xs -> if null xs then Nothing else Just (splitAt 3 xs)) "fooooooooooo"
19:16:01 <lambdabot>   ["foo","ooo","ooo","ooo"]
19:16:02 <ski> > unfoldr (\xs -> if null xs then Nothing else Just (splitAt 3 xs)) "foooooooooooo"
19:16:03 <lambdabot>   ["foo","ooo","ooo","ooo","o"]
19:16:21 <ski> > unfoldr (\xs -> if null xs then Nothing else Just (splitAt 3 xs)) [0..]
19:16:22 <lambdabot>   [[0,1,2],[3,4,5],[6,7,8],[9,10,11],[12,13,14],[15,16,17],[18,19,20],[21,22,...
19:16:39 <hzap> @type unfoldr
19:16:42 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
19:16:51 <FunctorSalad> ski: ?
19:17:18 <ski> > unfoldr (\n -> if n > 100 then Nothing else Just (n,2*n)) 1
19:17:20 <lambdabot>   [1,2,4,8,16,32,64]
19:18:06 <ski> FunctorSalad : i was thinking Taggnostr wanted something like that ..
19:19:42 <ski> FunctorSalad : ah ! you mean you already wrote that. sorry, didn't see that, just came in
19:20:09 <FunctorSalad> actually I thought you were trying to test some property ;0
19:20:18 <FunctorSalad> 0 -> )
19:21:19 <ski> (and i was displaying that it was handling the odd end in a reasonable way)
19:22:19 <ski> (hm, should there be a standard `lengthAtLeast' function ?)
19:23:59 <Twey> > unfoldr (\xs -> liftM (splitAt 3) $ listToMaybe xs) "foooooooooo"
19:24:01 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
19:24:05 <Twey> :(
19:26:21 <FunctorSalad> > unfoldr (\x -> guard (not(null x)) >> splitAt 3 x) "baaaaaaaaaaaaaaaaaaaaaaaarz"
19:26:22 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe (a, [a1])'
19:27:01 <FunctorSalad> :(
19:27:52 <FunctorSalad> why?
19:28:04 <FunctorSalad> WHY????
19:28:19 <Twey> Oh, right
19:29:02 <Twey> :t guard (not $ null undefined) >> splitAt 3 undefined
19:29:03 <lambdabot> forall a. (MonadPlus ((,) [a])) => ([a], [a])
19:30:05 <Twey> It would be nice to have a more generic toMaybe function
19:30:40 <FunctorSalad> > unfoldr (\(x::String) -> guard (not(null x)) >> splitAt 3 x) "baaaaaaaaaaaaaaaaaaaaaaaarz"
19:30:41 <Twey> @hoogle Monad m => (a -> b) -> m a -> Maybe a
19:30:41 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe
19:30:43 <lambdabot> Control.Monad liftM :: Monad m => (a1 -> r) -> m a1 -> m r
19:30:43 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
19:30:43 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
19:30:58 <Twey> Oops
19:30:59 <FunctorSalad> > unfoldr (\x -> guard (not(null x)) >> return (splitAt 3 x)) "baaaaaaaaaaaaaaaaaaaaaaaarz"
19:31:00 <Twey> @hoogle Monad m => (a -> b) -> m a -> Maybe b
19:31:01 <lambdabot>   ["baa","aaa","aaa","aaa","aaa","aaa","aaa","aaa","arz"]
19:31:01 <lambdabot> Control.Monad liftM :: Monad m => (a1 -> r) -> m a1 -> m r
19:31:02 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
19:31:02 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
19:31:05 <FunctorSalad> :)
19:31:56 <FunctorSalad> @type (\x -> if x == mzero then Nothing else (Just x)) -- Twey, this?
19:31:57 <lambdabot> forall (m :: * -> *) a. (MonadPlus m, Eq (m a)) => m a -> Maybe (m a)
19:32:13 <Twey> Yeah
19:32:31 <Twey> Oh, yeah, it's MonadPlus I need.  Duh.
19:32:57 <Twey> @let (y ?? n) p = if p then y else n
19:32:59 <lambdabot>  Defined.
19:33:39 <BMeph> Is there a committee that decides which functions are "too trivial" to be included in a regular (modulo) module?
19:33:46 <Twey> @let toMaybe f x = Nothing ?? Just (f x) $ x == mzero
19:33:48 <lambdabot>  Defined.
19:34:21 <Twey> > unfoldr (toMaybe (splitAt 3)) "fooooooooooo"
19:34:24 <lambdabot>   ["foo","ooo","ooo","ooo"]
19:34:26 <Twey> > unfoldr (toMaybe (splitAt 3)) "foooooooooooo"
19:34:28 <lambdabot>   ["foo","ooo","ooo","ooo","o"]
19:34:31 <Twey> \o/
19:34:32 <Twey> Much nicer.
19:37:03 <BMeph> @src on
19:37:03 <lambdabot> (*) `on` f = \x y -> f x * f y
19:50:36 <BMeph> FunctorSalad: What I call "2-type monads" are like Restricted Monads without the restriction. sigfpe wrote about 'em, but not by my name. :)
19:51:03 <edwardk> bmeph: aka indexed or parameterized monads?
19:51:11 <FunctorSalad> BMeph: restricted monads without the restrictions would just be ordinary monads, as I understand it
19:51:50 <BMeph> edwardk: Right, what are known as "Parameterized Monads" are what I mean. :)
19:52:20 <FunctorSalad> . o ( garden-variety monads )
19:52:42 <edwardk> functorsalad: http://comonad.com/haskell/category-extras/src/Control/Monad/Indexed.hs
19:52:49 <edwardk> slightly different
19:52:52 <edwardk> return :: a -> m i i a
19:53:15 <BMeph> For example, Matt Sackman (re-?)"invented" them for his Session Types.
19:53:16 <edwardk> bind :: (a -> m j k b) -> m i j a -> m i k b -- (or flip that if it makes you feel better)
19:53:31 <edwardk> reinvented. they go back to around 2002-2003 or so
19:53:58 <BMeph> edwardk: So, what's a Parameterized Kleisli look like? ;)
19:54:14 <FunctorSalad> like the first arg of bind?
19:54:40 <FunctorSalad> hmm that "return" doesn't seem to subsume restricted monadz
19:54:44 <edwardk> bmeph: its kinda boring actually =)
19:54:52 <edwardk> functorsalad: i never said it did
19:55:04 <edwardk> functorsalad: its a different animal
19:55:06 <FunctorSalad> edwardk: yeah, you didn't
19:55:51 <edwardk> indexed state, indexed writers (using category rather than monoid), indexed cont (for delimited continuations), so on and so forth
19:56:12 <edwardk> they just don't compose =(
19:56:33 <FunctorSalad> fmap :: (a -> b) -> m i j a -> m i j b?
19:56:49 <edwardk> yeah
19:57:30 <edwardk> the index is used so that get and put can change your type, the writer can concatenate functions of different types, cont can shift and reset, etc.
19:57:51 <edwardk> but its a different set of tools than the restricted set, etc. monads
20:00:19 <BMeph> It looks like something that'd make Arrows more useful. :)
20:00:34 <edwardk> when you apply it to arrows you er just get arrows ;)
20:02:32 <roconnor> @hoogle UArray
20:02:32 <lambdabot> Data.Array.Base data UArray i e
20:02:33 <lambdabot> Data.Array.Base UArray :: i -> i -> Int -> ByteArray# -> UArray i e
20:02:33 <lambdabot> Data.Array.Unboxed data UArray i e
20:02:45 <BMeph> So, pKleisli :: (b -> m j k c) -> (a -> m i j b) -> (a -> m i k c) ? :)
20:03:03 <edwardk> that works
20:03:28 <roconnor> @hoogle freeze
20:03:28 <lambdabot> Data.Array.Base freeze :: (Ix i, MArray a e m, IArray b e) => a i e -> m (b i e)
20:03:28 <lambdabot> Data.Array.MArray freeze :: (Ix i, MArray a e m, IArray b e) => a i e -> m (b i e)
20:03:28 <lambdabot> Data.Array.Base freezeSTUArray :: Ix i => STUArray s i e -> ST s (UArray i e)
20:10:21 <Axman6> is there a performance advantage to using record syntax to update elements of a datatype?
20:10:56 <copumpkin> I doubt it
20:11:41 <Axman6> yeah i thought so too
20:11:57 <roconnor> @hoogle thaw
20:11:57 <lambdabot> Data.Array.Base thaw :: (Ix i, IArray a e, MArray b e m) => a i e -> m (b i e)
20:11:57 <lambdabot> Data.Array.MArray thaw :: (Ix i, IArray a e, MArray b e m) => a i e -> m (b i e)
20:11:57 <lambdabot> Data.Array.Base thawSTUArray :: Ix i => UArray i e -> ST s (STUArray s i e)
20:12:32 <copumpkin> is there anywhere we can find out more about the icfp contest teams?
20:21:05 <vishi> main = do
20:21:05 <vishi>     h <- openBinaryFile "input" ReadMode
20:21:05 <vishi>     s <- hGet h 4
20:21:05 <vishi>     let e = decode s::Int
20:21:05 <vishi>     print e
20:21:05 <vishi> gives this exception*** Exception: too few bytes. Failed reading at byte position 8
20:21:07 <vishi> This works if i read 8 bytes through hGet (which suggests that Int is 8 bytes wide) or if I change Int to Int32. But maxBound::Int==maxBound::Int32==2147483647
20:21:10 <vishi> which suggests that Int is 4 bytes wide. Also for Float/Double i have to read 16 bytes through hGet
20:21:58 <monochrom> > maxBound :: Int
20:21:59 <lambdabot>   9223372036854775807
20:22:32 <vishi> *Main> maxBound :: Int
20:22:32 <vishi> 2147483647
20:22:32 <vishi> *Main>
20:23:03 <FunctorSalad> vishi: Data.Binary priorises portability over space-efficiency AFAIK
20:23:05 <tommd> vishi: You shouldn't assume the size of 'Int' anyway (for portability reasons)
20:23:14 <FunctorSalad> IIRC the double is even longer than 16 byte
20:23:29 <edwardk> Axman6: possibly. iirc the garbage collector has a minor hack for forwarding accessors to handle certain kinds of space leaks
20:23:30 <FunctorSalad> maybe the int contains some information about its length
20:24:12 <edwardk> so i.e. if it encounters fst (x,y) -- it simplifies it to x while collecting
20:24:19 <vishi> okk...i can use Int32 instead, but what do i do if i want 8 byte floating point numbers...use word64 somehow?
20:24:22 <FunctorSalad> Ghci> Data.ByteString.Lazy.length $ encode (1::Double)
20:24:22 <FunctorSalad> 25
20:24:44 <vishi> :)
20:24:49 * BMeph facepalms
20:25:00 <FunctorSalad> BMeph: ? :(
20:25:12 <monochrom> Please don't facepalm. High flu risk.
20:25:37 * FunctorSalad hands BMeph some disinfectant
20:25:38 <sjanssen> vishi: doing ICFP?
20:25:44 <vishi> yea
20:25:54 <FunctorSalad> (for disinjecting the hands before performing the facepalm)
20:25:55 <tommd> Just make a custom instance of Binary.
20:26:21 <FunctorSalad> vishi: there are functions like getWord32 or something in data.binary
20:26:26 <BMeph> monochrom: According to Matt Sackman (www.wellquite.org), it's better to get the flu nw, than later, since cases are relatively few and far between - sort of a "avoid the Christmas rush" argument. ;)
20:26:29 <FunctorSalad> if you want exact control
20:26:44 <vishi> FunctorSalad: ok..ill look into that...thanks
20:26:48 <BMeph> Er, get it *now, I mean.
20:27:04 <monochrom> According to me, it is better to get the flu never than now or later.
20:27:34 <monochrom> But I need to make my statement more impressive.
20:27:36 <FunctorSalad> isn't it nearly impossible to avoid exposure to the virus if it's spread?
20:27:47 <monochrom> According to me (http://www.vex.net/~trebla/), it is better to get the flu never than now or later.
20:28:03 * BMeph is impressed, if monochrom has never gotten the flu ever befoe, and can keep the record going
20:28:10 <BMeph> *before
20:28:53 <monochrom> Probably 4 years since my last flu. Maybe 8. Hard to tell cold from flu for me.
20:29:09 <copumpkin> omg an ICQ number
20:29:12 <monochrom> OK, probably 4 years since my last {flu's}U{cold's}.
20:29:16 <copumpkin> UIN, even
20:29:30 * BMeph suggests "never getting the flu" as an addition to monochrom's 'Hobbies' list. ;)
20:29:32 <Twey> BMeph: That's silly, since almost every 'flu is different â chances are you'll just get it again
20:29:35 <edwardk> hah i think i've forgotten mine
20:29:48 <copumpkin> I haven't used ICQ in years but somehow I can't forget the number
20:29:57 <copumpkin> I've forgotten all my old phone numbers
20:30:10 <monochrom> Anyway, if you can hold off until the H1N1 vaccine is out this Fall, it will be a "never" for you.
20:31:14 <monochrom> So, improved statement: Better to wait for the vaccine later than get the flu now. Think of it as letting other people test out beta software (the flu) first.
20:31:20 <Twey> @index encode
20:31:21 <lambdabot> bzzt
20:31:29 <Twey> FunctorSalad: What's that âencodeâ?
20:31:50 <copumpkin> Data.Binary ?
20:31:57 <Twey> Aha
20:32:53 <monochrom> Anyway I like how common people just quote opinion leaders without independent thinking.
20:33:23 <monochrom> "According to Sackman (url here)" Screw Sackman.
20:33:53 <BMeph> monochrom: I prefer people that quote opinion leaders to demonstrate that independent thought is occuring independently. ;p
20:34:01 <sjanssen> monochrom: common people?
20:34:28 <monochrom> "According to Famous Developer, FP is unnatural"  Screw Famous Developer.
20:34:30 <copumpkin> plebs
20:34:43 <Twey> Heheh
20:34:58 <BMeph> Chinese? Oh, wait, that would be "populous," never mind. ;)
20:35:16 <copumpkin> anyway, according to monochrom, there is not enough independent thought
20:35:25 <monochrom> haha
20:35:36 <Axman6> monochrom: they've already got a vaccine here :\
20:35:50 <Axman6> or, at least something that can rid you of H1N1
20:36:19 <monochrom> Yeah. This Fall will be even better.
20:36:39 <edwardk> most anything worth learning seems unnatural when you first get exposed to it.. otherwise you wouldn't have to learn it, you'd already know it
20:36:46 <BMeph> All New episodes - H1N1, Catch it! Er, I mean, don't. ;p
20:36:57 <monochrom> The Ontario government provides flu vaccine for free every Fall and Winter. This Fall they will include H1N1.
20:37:43 <monochrom> But I should go back to Haskell:
20:38:31 <tommd> I need a kick in the head.
20:38:42 <monochrom> I like how every time a newbie asks to do something OOP style, I suggest the most anti-OOP way. :)
20:38:43 * copumpkin kicks tommd in the head
20:38:46 <tommd> thanks
20:39:23 <monochrom> "How do I write/overload a function for two data types? They are records with similar fields."  "Merge the two data types into one."
20:39:34 <roconnor> I'm always amazed how easy I find editing my Haskell code.
20:39:45 <roconnor> I just made a "big change" to my contest VM
20:39:55 <roconnor> but I only touched 4 or 5 functions
20:40:10 <copumpkin> yay for maintainability
20:40:12 <Twey> The joys of well-designed code :-P
20:40:29 <roconnor> I replace Lazy.ST with good old State
20:40:40 <roconnor> in an attempt to make checkpointing easier
20:40:43 <monochrom> Yeah, when you're that good and the language is that good, screw OOP.
20:40:54 <Twey> The one I hate most is IO, when you suddenly realise that you actually need to pass a bunch more arguments in
20:41:17 <Twey> That usually requires rewriting a whole bunch of functions
20:41:25 <Axman6> hmm, this ternary tree library i'm writing seem to be going much better than i had expected. just finished a nice efficient Data.Binary implementation. trying to think of anything else i should before hackaging it up
20:41:44 <Twey> Axman6: Hackage now, improve later
20:41:49 <Axman6> heh
20:41:56 <FunctorSalad> Twey: I found it helps to collect such things into a record type
20:42:01 <roconnor> Twey: don't you just add more fields to a record?
20:42:40 <Twey> I have a pathological dislike of passing around a whole bunch of data that I don't actually need
20:42:45 <Twey> It feels very Java to me
20:42:55 <Twey> But I suppose you're right
20:43:01 <Twey> I should probably just be using records
20:43:43 <FunctorSalad> you just pass the pointer, don't you?
20:44:06 <FunctorSalad> I don't think gratuitous record fields would slow down functions using that record
20:45:08 <FunctorSalad> hell it should eliminate the record altogether if you just use it to bundle some args, I hope
20:45:21 <roconnor> Twey: while you are at it, use Data.Accessor
20:45:26 <roconnor> which is totally awesome
20:45:32 * roconnor tries to advertise it more
20:45:55 <Axman6> hmm, i can't think of a good description for what my package does :( it's just a fairly efficient ternary tree package for finding if a word has been inserted into the tree or not...
20:46:09 * copumpkin is failing miserably
20:46:14 <FunctorSalad> "loli" is already taken
20:47:59 <sm> roconnor: hmm, thanks for the tip, I never heard of that
20:48:10 <roconnor> it makes records way better
20:48:15 <roconnor> actually I haven't really used it
20:48:19 <roconnor> but I want to!
20:49:14 <FunctorSalad> it lets you write "set thatField 3" in State monad
20:49:22 <FunctorSalad> found that particularly useful
20:50:17 <roconnor> It lets you say, consider this State (sub record) as a State (record) which sounds totally awesome
20:50:27 <roconnor> I'm looking forward to using that
20:50:57 <copumpkin> Data.Accessor seems nice, but suffers from many Ts and Cs :P
20:51:29 <sjanssen> Axman6: something involving the word "set"
20:51:47 <copumpkin> WordSet
20:51:50 <sjanssen> Axman6: is it limited to String only?  "stringset" or "ternary-string-set"
20:51:52 <copumpkin> maybe not word
20:51:54 <Axman6> sjanssen: yeah, good idea. i'm also thinking of making a map version too
20:52:11 <Axman6> sjanssen: nope, any [Ord] will do
20:52:12 <copumpkin> TernarySet and TernaryMap? :P
20:52:26 <copumpkin> TriSet?
20:52:33 <sjanssen> list-set/map
20:52:44 <Axman6> i'm just going to call the package Ternary
20:52:56 <sjanssen> at least put the word tree in there
20:53:02 <Axman6> yeah
20:53:46 <Axman6> ok, TernaryTrees it is
20:54:16 <copumpkin> Threes ;)
20:54:22 <copumpkin> or tHrees
20:54:39 <edwardk> Data.Map.Ternary -- Data.Set.Ternary or TST or something like that
20:54:51 <Axman6> heh, i like that copumpkin
20:54:56 <sjanssen> yuck
20:55:08 <edwardk> threes is pretty horrible ;)
20:55:10 <sjanssen> 'h' puns are old, 'threes' is lame
20:55:13 <copumpkin> I agree :P
20:55:21 <Axman6> yeah maybe that's a better idea edwardk
20:55:39 <Axman6> yeah, it is pretty horrible, but still funny
20:55:45 <copumpkin> but hey, it gets the 3 and tree in a single word! epic compression
20:55:52 <FunctorSalad> "trie" sounds ridiculous in german too
20:56:16 <FunctorSalad> like someone transliterated the english "tree"
20:56:28 <FunctorSalad> that's probably not the right word
20:56:34 <FunctorSalad> trans-phonated or something ;)
20:57:18 <Axman6> FunctorSalad: it's supposed to be pronounced tree apparently
20:57:33 <Axman6> comes from the word retrieval i believe
20:58:03 <copumpkin> that's a dumb name too
20:58:40 <monochrom> haha I'll join. I hate the word too. Fails the over-the-phone test.
20:58:49 <Twey> roconnor: That's clever.  I like it.
20:59:39 <FunctorSalad> (or actually, "trie" sounds like "tree" pronounced with a german accent)
20:59:54 <edwardk> i always just mispronounce trie as 'try' so people can hear the distinction. i realize its supposed to have the punnier pronunciation, but its too hard to make yourself understood
20:59:59 <monochrom> Too bad I can't fake german accent.
21:00:23 <FunctorSalad> I mean if you read "trie" as if it was a german word
21:04:30 <kniu> type families allow a sort of "pattern matching" on types, right?
21:04:58 <sjanssen> kniu: you can write type level functions, yes
21:05:50 <kniu> can you pattern match on polymorphic types?
21:08:43 <sjanssen> kniu: it's not really pattern matching
21:08:49 <sjanssen> I'm not exactly sure what you're asking
21:08:52 <kniu> no, it is not.
21:08:53 <FunctorSalad> you can kinda-sorta do that with -XOverlappingInstances
21:09:14 <FunctorSalad> using the "most-specialised instance applies" thing
21:09:15 <Cale> You can create a datatype with a polymorphic field and create an instance for that.
21:09:33 <FunctorSalad> hmm or wait I think that still wouldn't work
21:09:41 <FunctorSalad> no idea...
21:10:29 <Cale> (If that's at all related to what you're asking :)
21:11:09 <FunctorSalad> instance Foo String ...; instance Foo a ...; -XOverlappingInstances
21:11:30 <FunctorSalad> I don't know what it would do if you try to get the instance for "forall a. a", say
21:12:33 <Cale> Yeah, when you say "pattern match on polymorphic types", I would think that would mean  type instance Foo (forall a. ...)
21:12:42 <Cale> But I'm not sure :)
21:18:19 <kniu> Just hypothesizing.
21:30:00 <Warrigal> > splitAt ':' $ words $ "8:08 + 3:59 + 2:53 + 1:47 + 1:23 + 3:51 + 0:48 + 2:20 + 1:47 + 5:22"
21:30:02 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
21:30:12 * Warrigal shrugs
21:30:28 <Axman6> :t splitAt
21:30:30 <lambdabot> forall a. Int -> [a] -> ([a], [a])
21:30:52 <Warrigal> > map (splitAt 1) $ words $ "8:08 3:59 2:53 1:47 1:23 3:51 0:48 2:20 1:47 5:22"
21:30:53 <lambdabot>   [("8",":08"),("3",":59"),("2",":53"),("1",":47"),("1",":23"),("3",":51"),("...
21:31:25 <Warrigal> @hoogle (a -> b) -> (c -> d) -> (a,c) -> (b,d)
21:31:26 <lambdabot> No results found
21:31:30 <Warrigal> No?
21:31:33 <Axman6> @hoogle a -> [a] -> ([a],[a])
21:31:34 <lambdabot> Prelude splitAt :: Int -> [a] -> ([a], [a])
21:31:34 <lambdabot> Data.List splitAt :: Int -> [a] -> ([a], [a])
21:31:34 <lambdabot> Data.List genericSplitAt :: Integral i => i -> [b] -> ([b], [b])
21:31:44 <Warrigal> @hoogle +++
21:31:44 <lambdabot> Control.Arrow (+++) :: ArrowChoice a => a b c -> a b' c' -> a (Either b b') (Either c c')
21:31:45 <lambdabot> Text.ParserCombinators.ReadP (+++) :: ReadP a -> ReadP a -> ReadP a
21:31:45 <lambdabot> Text.ParserCombinators.ReadPrec (+++) :: ReadPrec a -> ReadPrec a -> ReadPrec a
21:32:08 <Axman6> :t (***)
21:32:09 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
21:32:23 <Axman6> Warrigal: ^^
21:32:29 <Warrigal> Gracias.
21:33:12 <Warrigal> > sum . map read *** sum . map read $ unzip $ map (splitAt 1) $ words $ "8:08 3:59 2:53 1:47 1:23 3:51 0:48 2:20 1:47 5:22" :: (Int,Int)
21:33:14 <lambdabot>   (26,* Exception: Prelude.read: no parse
21:33:35 <Warrigal> > sum . map read *** sum . map (read . tail) $ unzip $ map (splitAt 1) $ words $ "8:08 3:59 2:53 1:47 1:23 3:51 0:48 2:20 1:47 5:22" :: (Int,Int)
21:33:37 <lambdabot>   (26,378)
21:33:45 <Warrigal> > 6*26+378
21:33:47 <lambdabot>   534
21:36:39 <Warrigal> > sum . map read *** sum . map (read . tail) $ unzip $ map (splitAt 1) $ words $ "5:06 8:33 6:07 3:38 4:08 2:09 1:40 3:39 7:33 5:16 8:08 5:16 2:10 1:05 3:30 3:53 2:18 5:41 3:43 3:08" :: (Int,Int)
21:36:40 <lambdabot>   (79,461)
21:37:07 <Warrigal> Hmm, I can take this even farther.
21:37:28 <Warrigal> > uncurry (+) $ (*60) . sum . map read *** sum . map (read . tail) $ unzip $ map (splitAt 1) $ words $ "5:06 8:33 6:07 3:38 4:08 2:09 1:40 3:39 7:33 5:16 8:08 5:16 2:10 1:05 3:30 3:53 2:18 5:41 3:43 3:08" :: (Int,Int)
21:37:30 <lambdabot>   No instance for (GHC.Num.Num (GHC.Types.Int, GHC.Types.Int))
21:37:30 <lambdabot>    arising fro...
21:37:35 <Warrigal> > uncurry (+) $ (*60) . sum . map read *** sum . map (read . tail) $ unzip $ map (splitAt 1) $ words $ "5:06 8:33 6:07 3:38 4:08 2:09 1:40 3:39 7:33 5:16 8:08 5:16 2:10 1:05 3:30 3:53 2:18 5:41 3:43 3:08" :: Int
21:37:37 <lambdabot>   5201
21:37:41 <Warrigal> And I'm finished.
21:39:24 * copumpkin just wrote a huge comment on reddit
21:39:27 <copumpkin> that I'm sure no one will read
21:41:10 <edwardk> copumpkin: yeah hate that. some times i'll write a two screen long dissertation on the topic with references and everything and it'll sit at 1 or get downmodded to 0 because it disagrees with the opinion of the moment and someone can come along with a lolcat or a look of disapproval and get 40 upvotes ;)
21:41:26 <copumpkin> yeah :P
21:42:07 <edwardk> I suppose I should just master comic timing and troll with pastings of à² _à²  instead.
21:42:13 <copumpkin> hah
21:42:22 <copumpkin> or join a pun tower
21:42:31 <edwardk> yeah
21:44:07 <JamesSanders> how does one go about storing a number of variable with different types together, if one does not know how many will need to be stored
21:44:31 <copumpkin> JamesSanders: you know something common about all the variables, I'd assume?
21:44:37 <copumpkin> like, they're all Show instances?
21:44:44 <JamesSanders> yeah
21:44:44 <copumpkin> or something along those lines
21:44:48 <Beelsebob> what's the common thing?
21:44:52 <copumpkin> you could write a heterogeneous list, for example
21:44:58 <Beelsebob> I doubt that's needed
21:45:21 * Beelsebob would bet there's a data type missing
21:45:27 <edwardk> data AnyFoo = forall a. Foo a => AnyFoo a -- existential containers are a good bet.
21:45:44 <Beelsebob> JamesSanders: what's the thing they all have in common?
21:45:57 <edwardk> then you can make a list of AnyFoo's and use the methods of Foo on them, even if you know nothing else about them
21:46:19 <JamesSanders> Beelsebob: like copumpkin said they're all Show instances
21:46:34 <edwardk> s/Foo/Show/ then =)
21:46:34 <Beelsebob> is that all you know about them?
21:46:34 <copumpkin> oh, is that actually what you care about?
21:46:36 <Beelsebob> what are they?
21:46:53 <edwardk> and you can then walk the list and show any item in it
21:48:05 <JamesSanders> Beelsebob: they will all eventually be serialized into a document of some type
21:48:35 <JamesSanders> so eventually they will all be written as a string to a file
21:48:36 <Beelsebob> JamesSanders: okay, so what types can go in that document?
21:48:40 <FunctorSalad> when do you use existentials and when do you just make a list of [FooDictionary]?
21:49:19 <JamesSanders> Beelsebob: Int Strings and List of Int or Strings
21:49:32 <edwardk> now the devil's advocate is that if all you can do is show them you might as well call show and rely on laziness ;)
21:49:43 <edwardk> and just have a list of strings
21:49:56 <Beelsebob> JamesSanders: data Documentable = I Int | S String | L [Documentable] -- no need for fancy pants types then
21:50:07 <Beelsebob> you have a list of things that can go in documents
21:50:09 <edwardk> but if you ever plan to add more than just a Show constraint to the existential then the existential Showable data type may be the way to go
21:50:11 <Beelsebob> not of any Showable
21:52:03 <Axman6> hooray: http://hackage.haskell.org/package/TernaryTrees-0.0.1
21:52:11 <JamesSanders> Beelsebob: oh crap that was simple, I even already knew the solution, just didn't put one and one together
21:52:26 <JamesSanders> Beelsebob: thanks!
21:52:29 <Beelsebob> no probs :)
21:52:30 <hackagebot> TernaryTrees 0.0.1 - Efficient pure ternary trees (AlexMason)
21:52:40 <Axman6> ta hackagebot
21:52:48 <copumpkin> zomg real name leakage
21:52:54 <copumpkin> 1!!!
21:53:05 <Beelsebob> haha
21:53:07 <Axman6> zomg /wi Axman6 :O
21:53:24 <copumpkin> :P
21:53:41 <Beelsebob> Axman6: is your dad Sean Connery?
21:54:05 * mmorrow spits up coffee on his keyboard
21:54:26 * Beelsebob thinks mmorrow may have got the reference
21:54:37 <mmorrow> i switch to the irc window at sean connery is the first thing i see
21:55:18 * copumpkin hints not-so-subtly about mmorrow getting a twitter account
21:55:55 * FunctorSalad doesn't get anything whatsoever
21:56:08 <FunctorSalad> but it's 7 am
21:56:23 * mmorrow cleans his keyboard
21:56:48 * mmorrow considers twittler
21:57:35 <Adamant> what up my tweeps
21:58:22 <copumpkin> :)
21:58:22 <Adamant> (shameless stolen from Doonesbury. the horror.... the horror.....)
21:59:26 <Axman6> Beelsebob: i don't get the reference :( ... but you should test out my new package :D
22:00:01 <Beelsebob> Axman6: you need to watch the Rock :)
22:00:47 * FunctorSalad doesn't even get which part of what Axman6 said prompted teh reference
22:01:03 <Beelsebob> his name
22:01:05 <Axman6> think it was my name... but not totally sure
22:01:06 <kyagrd> Howdy ~, anyone converted Word64 to/from Double?
22:01:07 <Axman6> yes
22:01:08 <Axman6> :P
22:01:29 <Axman6> kyagrd: what do you need to do that for?
22:01:42 <Axman6> you might be able to do it with Data.Binary actually
22:01:51 <lpsmith> Axman6:  everybody's been asking that question this weekend
22:02:05 <lpsmith> I've just started parroting an answer
22:02:21 <kyagrd> Oh, right I just encode it Double is already an instance of binary.
22:02:24 <Axman6> lpsmith: i don't think it came across quite how i intended it sadly :(
22:02:26 <kyagrd> Its all because of the programming contest
22:02:33 <hackagebot> gsasl 0.1 - Bindings for GNU SASL (JohnMillikin)
22:02:38 <Axman6> kyagrd: ah, i see
22:02:47 <kyagrd> Have to write a serializer/deserializer for OVM
22:02:49 <FunctorSalad> kyagrd: unsafeCoerce I think
22:03:00 <lpsmith> Supposedly it can be done through unsafeCoerce#  , and binary doesn't' support IEEE 754 doubles
22:03:11 <lpsmith> Or at least that's what I've heard
22:03:45 <FunctorSalad> I once advertised using the unboxing/magic hash, but you don't need it
22:03:46 <kyagrd> Are Haskell Double different from IEEE 754 doubles?
22:03:58 <lpsmith> Axman6:  I meant to put a wink in that statement... everybody's who is working on the ICFP contest problem has been asking this exact question ;-)
22:04:00 <sjanssen> kyagrd: no
22:04:03 <Axman6> don't beieve so, but the binary implementation might me
22:04:12 <Axman6> lpsmith: ah, i see, heh
22:04:15 <kyagrd> hmm ...
22:04:18 <FunctorSalad> Ghci> let x = 1 :: Double
22:04:18 <FunctorSalad> x :: Double
22:04:18 <FunctorSalad> Ghci> unsafeCoerce x :: Word64
22:04:18 <FunctorSalad> 4607182418800017408
22:04:18 <jmillikin> <plug>Have you tried the data-binary-ieee754 package?</plug>
22:04:27 <FunctorSalad> how do I print that in binary quickly
22:04:31 <sjanssen> kyagrd: use unsafeCoerce
22:04:46 <kyagrd> jmillikin: wow I didn't know that that was there
22:05:14 <mmorrow> unsafeCoerce :: CULong -> CDouble
22:05:21 <mmorrow> unsafeCoerce :: CDouble -> CULong
22:05:23 <mmorrow> works
22:05:29 <dibblego> I wish cabal had a field for IRC nickname
22:05:31 <FunctorSalad> why not just Double -> Word64?
22:06:00 <mmorrow> the C* types are guaranteed to be the same size as in C, but not the haskell ones (although in ghc i believe they are)
22:06:17 <mmorrow> ooh, although Int is sizeOf (undefined :: CLong)
22:06:34 <Axman6> dibblego: no reason you couldn't put one in the Author field Name Last (Nick) <email@host.com>
22:06:55 <mmorrow> FunctorSalad: using the C* types to be safe
22:07:17 <Axman6> jmillikin: sounds very handy :)
22:07:29 <mmorrow> (and because the only times i've needed to do that are when i'm interfacing with C)
22:07:43 <jmillikin> It's my first real attempt at a Haskell library, so please suggest any improvements you can think of.
22:08:00 <sjanssen> mmorrow: Int and CLong aren't always the same size, right?
22:08:16 <mmorrow> jmillikin: oh nice, i just saw that the other day. looks handay :)
22:08:35 <Axman6> jmillikin: so it converts Doubles to IEEE 754 binary format?
22:08:37 <mmorrow> sjanssen: on x86_64 they are, but on x86 you're right
22:08:47 <jmillikin> Yes, and also Floats
22:08:51 <mmorrow> (this is why i use the C types)
22:08:59 <Axman6> excellent :)
22:09:39 <jmillikin> I wouldn't use it to control a plane or anything, but I've been using it for little scripts and so far haven't encountered any bugs.
22:09:48 <Axman6> nice
22:10:07 <kyagrd> Hmm, data-binary-ieee754 package was uploaded just last week.  What a foresight for the contest!
22:10:08 <Axman6> looks like something i might have found useful this semester. we learnt all about IEEE 754
22:10:16 <FunctorSalad> a whole plane of existence?:O
22:10:25 <FunctorSalad> sorry
22:10:27 <copumpkin> mmorrow: wait, isn't that backwards? they're different sizes on x86_64 and same on x86
22:11:14 <copumpkin> int is almost always 32 bits, but long is the size of your machine word, and long long is always 64 bits
22:11:44 <mmorrow> copumpkin: long is 32bits on x86??
22:11:53 <copumpkin> yup
22:11:58 <mmorrow> bejeebus
22:12:00 <copumpkin> to the best of my knowledge :)
22:12:06 <Elly> long long is 64, though
22:12:09 <copumpkin> yeah
22:12:20 <mmorrow> gah
22:12:21 <Axman6> in C, not necessarilly
22:13:06 <copumpkin> I don't mind c too much, but the type names are ****ing ridiculous. stdint.h is the best addition to c in its history (as well as the new function declaration syntax) :P
22:13:12 <mmorrow> i never used long until i started coding on x86_64, at which time all my code that used (void*)/int interchangeably started segfaulting ;)
22:13:24 <Axman6> i thought in C, things like long long has a minimum guaranteed length, and their upper size was bounded by whatever is supposed to be larger than it
22:14:02 <mmorrow> so at least, on x86*, you know that sizeof(long)==sizeof(void*)
22:14:23 <Beelsebob> mmorrow: not true on all x86 machines
22:14:30 <mmorrow> so i guess yeah, i did know that sizeof(long)==4 in x86, but i didn't know i knew it ;)
22:14:35 <mmorrow> Beelsebob: "on x86*"
22:14:37 <Beelsebob> on macs for example I'm fairly sure long is 32 bit
22:14:39 <Beelsebob> oh hang on
22:14:40 <Beelsebob> yeh
22:14:46 <Beelsebob> >.<
22:14:56 <mmorrow> Beelsebob: isn't that running in 32bit mode though?
22:15:01 <Beelsebob> nope
22:15:01 <Elly> Axman6: yes; sizeof(short) <= sizeof(int) <= sizeof(long)
22:15:02 <Axman6> Beelsebob: 32 or 64 bit though?
22:15:07 <mmorrow> gah!
22:15:13 <Beelsebob> yeh, I just got what he meant
22:15:27 <Beelsebob> he actually meant x86, not x86 + 64 bit gadgetry
22:15:40 <copumpkin> yeah, gcc compiles 32-bit by default on leopard
22:15:48 <copumpkin> I hope they'll switch that in snow leo
22:16:04 <mmorrow> yay for CPP
22:16:04 <Beelsebob> even if you set it to compile 64 bit though, long is still 32 bit
22:16:05 <copumpkin> it's still nice to be able to run both in a single OS
22:16:14 <copumpkin> Beelsebob: not last time I tried it :o
22:17:31 <mmorrow> geez, i've gotta sort out what integral type is sizeof(void*) on all the various os/arch combos
22:17:38 <mmorrow> and CPPify it
22:17:47 <copumpkin> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6311#a6311
22:17:48 <mmorrow> (or else all my code will break)
22:20:06 <Beelsebob> copumpkin: hmm, apparently I was wrong, sizeof long does indeed switch to 8
22:20:09 <mmorrow> copumpkin: oh nice, so using -m64 on darwin is a safe bet to get standard (wrt linux) x86_64 sizes?
22:20:14 <Beelsebob> odd, wonder where I was getting that idea
22:20:38 <copumpkin> Beelsebob: well, if you use -arch x86 -arch x86_64 it'll make you a fat binary, but will run the x86 version by default
22:20:38 <mmorrow> well, actually standard wrt to friggin x86_64 abi sizes
22:20:42 <copumpkin> so that might've been it
22:20:56 <copumpkin> mmorrow: yeah, it's basically identical to linux with that
22:21:20 <copumpkin> mmorrow: at least as far as I've seen :) there may be annoying subtle differences but I have yet to encounter any
22:21:34 <mmorrow> weee :)
22:21:39 <Beelsebob> copumpkin: -arch i386 -arch x86_64 ran the 64 bit one for me
22:21:51 <copumpkin> :o
22:21:52 <copumpkin> interesting
22:21:53 <Beelsebob> LappyBob:Desktop tatd2$ gcc -arch i386 -arch x86_64 test.c
22:21:53 <Beelsebob> LappyBob:Desktop tatd2$ ./a.out
22:21:53 <Beelsebob> 8
22:22:26 <copumpkin> oh, it does default to x86_64 if it's available I think
22:22:31 <mmorrow> um, why do you have -arch twice?
22:22:39 <copumpkin> it compiles it twice :)
22:22:42 <mmorrow> ahh
22:22:42 <copumpkin> for each architecture
22:22:46 <Beelsebob> mmorrow: it creates a single binary with both architectures in
22:22:51 <copumpkin> and crams it in the same binary (the official name is "fat binary")
22:22:52 <mmorrow> oh, i see.
22:23:00 <pikhq> Oh, right; on OS X, so it does.
22:23:07 <mmorrow> and which one runs depends on your setup i take it?
22:23:11 <Beelsebob> yep
22:23:13 <copumpkin> I think I was confused with 10.4, which defaulted to i386
22:23:26 <Beelsebob> it's an idea from the 68k -> PPC transision
22:23:35 <copumpkin> mmorrow: yeah, you could potentially have x86_64, x86, ppc, ppc64, arm, and countless others in the same binary :P
22:23:39 <pikhq> -arch i386 -arch x86_64 -arch ppc -arch ppc64 ;# Magically, you've got 4 architectures.
22:23:43 <copumpkin> no guarantees about them being the same program though ;)
22:23:50 <mmorrow> heh
22:23:51 <copumpkin> you can use lipo to put completely unrelated programs together
22:23:55 <BMeph> > showBin 4607182418800017408
22:23:57 <lambdabot>   "11111111110000000000000000000000000000000000000000000000000000"
22:24:00 <mmorrow> :o
22:24:04 <mmorrow> @hoogle showBin
22:24:05 <lambdabot> No results found
22:24:11 <mmorrow> did someone define that?
22:24:14 <pikhq> copumpkin: Except that only 5 of them have an OSX API at all. ;)
22:24:14 <BMeph>  showBin = flip (showIntAtBase 2 intToDigit) ""
22:24:19 <mmorrow> ah nice
22:24:24 <pikhq> And you named those.
22:24:26 <copumpkin> pikhq: yeah :P but the macho format defines more archs
22:24:37 <copumpkin> also, I'm not sure how dyld enjoys having two different mach-o files in a fat binary with the same architecture
22:24:43 <pikhq> That's because Macho is the Mach binary format.
22:25:00 <Beelsebob> pikhq: doesn't mean I can't build a random sparc binary and lipo it in there -- it just probably won't be very interesting
22:25:51 <pikhq> You'd be better off sticking a random x86-pc-linux-gnu binary in there and making a Mach-O loader for Linux.
22:25:59 <pikhq> (Linux lets you have userspace-defined binary loaders)
22:26:03 <Beelsebob> would be shiny that
22:26:08 <Beelsebob> especially with cocotron involved
22:44:49 <dibblego> how might one write a Data.ByteString.Lazy.Internal.ByteString to a file?
22:46:06 <copumpkin> writeFile from Data.ByteString.Lazy
22:46:06 <Axman6> doesn't the ByteString package come with its own versions of the standard file writing functions?
22:46:55 <dibblego> oh indeed, wrong import thanks :)
22:47:08 <copumpkin> :)
22:48:45 <hackagebot> TernaryTrees 0.0.2 - Efficient pure ternary trees (AlexMason)
22:49:45 <hackagebot> TernaryTrees 0.0.2.1 - Efficient pure ternary trees (AlexMason)
22:49:53 <copumpkin> zomg Axman6 quit spamming! :P
22:50:01 <Axman6> bleh, seems i made up my own category for hackage, hence the double submission -_-
22:50:55 <Axman6> copumpkin: wanna give my pachge a bit of a play with?
22:51:05 <Axman6> package even
22:51:18 <copumpkin> Axman6: not now, have been procrastinating all day and should really get some work in before I sleep :(
22:51:25 * copumpkin doesn't enjoy objc :(
22:51:31 <Axman6> heh
22:51:36 <Axman6> what's wrong with objc?
22:52:52 <Axman6> gahh, how on earth do you add new lines to the a description in a .cabal file? >_<
22:52:52 <copumpkin> take the new property stuff. talk about DRY, I need to write X *var in my .h file for the instance var, @property (attrs) X *var; outside of the brackets, and @synthesize var; in the .m file :P
22:53:03 <copumpkin> Axman6: use backslashes at the end of the line
22:53:17 <Axman6> ahh, thanks. double backslash?
22:53:32 <copumpkin> single I think. think of it as escaping the newline
22:55:12 <copumpkin> am I still online?
22:55:20 <Axman6> yah
22:55:27 <copumpkin> ah, I guess so
22:58:47 <hackagebot> haskeem 0.7.4 - A small scheme interpreter (UweHollerbach)
23:06:12 <JamesSanders> I asked a similar question earlier about storing data of different types together. This time I need to create a list of types that all share a common typeclass like "seralize".
23:06:33 <Axman6> copumpkin: no dice with the new lines >_<
23:06:49 <hackagebot> TernaryTrees 0.0.2.2 - Efficient pure ternary tree Sets and Maps (AlexMason)
23:06:54 <JamesSanders> so a list will be built containing types that are all part of the Serialize type class
23:07:00 <copumpkin> oh I was wrong, http://hackage.haskell.org/packages/archive/DeepArrow/0.2/DeepArrow.cabal
23:07:39 <JamesSanders> then in the end the serialize function (depending on the type of serialization) will be mapped over the list
23:08:03 <JamesSanders> I'm not exactly sure where to start looking for an answer on this.
23:08:29 <copumpkin> JamesSanders: in general you can avoid storing lists of those things together, but if you can't, http://www.haskell.org/haskellwiki/Heterogenous_collections
23:09:02 <Axman6> copumpkin: so, put a . on each empty line to get a new line?
23:09:33 <copumpkin> Axman6: I think most of what you need to do is just indent, but if you do skip a line, stick a period in it
23:11:54 <Warrigal> > divMod 5201 60
23:11:56 <lambdabot>   (86,41)
23:20:44 <JamesSanders> copumpkin: just curious can you give an example of how you can get away with not storing those things together?
23:21:09 <JamesSanders> Existential types seems like what I am looking for, but I may be going at the problem wrong
23:21:32 <Axman6> last bit of TernaryTree spam about to appear... :(
23:21:53 <hackagebot> TernaryTrees 0.0.3.0 - Efficient pure ternary tree Sets and Maps (AlexMason)
23:22:02 <copumpkin> JamesSanders: data Showable = forall x. Show x => Showable x
23:22:11 <roconnor> @type unless
23:22:12 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
23:22:13 * Axman6 can;t believe he forget to implement getVal for his TernaryMap
23:22:25 <copumpkin> JamesSanders: I can now do [Showable 5, Showable "ohai", Showable False]
23:22:45 <copumpkin> JamesSanders: you can basically think of Showable as being a type that "hides" the type of its contents
23:23:11 <Axman6> copumpkin: http://hackage.haskell.org/package/TernaryTrees-0.0.3.0 hooray :)
23:23:34 <copumpkin> normally you'd have data (Show x) => Showable x = Showable x, but then you'd end up with Showable Int, Showable String, Showable Bool, which obviously are different types so can't live in a list together
23:23:43 <copumpkin> Axman6: yay :)
23:24:39 <Axman6> argh, forgot to put another newline thing in the list >_< oh well, next release won't have that line
23:26:59 <JamesSanders> copumpkin: well not sure I understand the syntax completely but that solution appears to work well for my needs, thanks.
23:27:26 <copumpkin> just to simplify it more
23:27:48 <copumpkin> if you have data X a = X a, you have a type that stores any other type in its constructor, right?
23:28:10 <copumpkin> you could have an X Bool, an X String, or X anything else
23:28:34 <JamesSanders> copumpkin: right
23:29:10 <copumpkin> so if I write x = X False, the type of x will be X Bool, because it necessarily "wraps" the type of what you stick in it with an X
23:29:22 <copumpkin> say you don't want it to pick it up
23:29:30 <copumpkin> you'd try data X = X a
23:29:45 <copumpkin> unfortunately that's not allowed because it doesn't know where to get the a type from
23:30:13 <copumpkin> so you just tell it that it should work for any value of a: data X = forall a. X a
23:30:34 <ski> or `data X where MkX :: a -> X', with GADT syntax
23:31:16 <JamesSanders> copumpkin: ok that makes a bit more sense
23:31:22 <copumpkin> it'd be kind of fun to get rid of the orginal ADT syntax altogether
23:31:45 <ski> it's useful as a common case, i think
23:32:00 <copumpkin> I guess the GADT syntax is a little more painful to write with the ->
23:32:10 <copumpkin> and where is 5 times longer than =
23:32:11 <copumpkin> :P
23:32:19 <ski> plus repetition of the result type
23:32:30 <copumpkin> true
23:32:56 * ski still wonders if GADT records are useful ..
23:33:06 <copumpkin> how do you mean?
23:33:19 <ski> like
23:33:25 <ski>   data Foo :: * -> *
23:33:27 <ski>     where
23:33:38 <ski>     bar :: Foo Int -> Bool
23:33:44 <ski>     baz :: Foo a -> (a,a)
23:33:51 <desp> @pl \(_, p, _, _) -> p
23:33:51 <lambdabot> (line 1, column 7):
23:33:52 <lambdabot> unexpected ","
23:33:52 <lambdabot> expecting letter or digit, operator or ")"
23:33:52 <lambdabot> ambiguous use of a non associative operator
23:34:02 <desp> What's up with that?
23:34:09 <shachaf> desp: There is no such function.
23:34:24 <shachaf> desp: @pl only knows (,).
23:34:27 <ski> a value of type `Foo x' always has a `baz' field .. in case `x' is `Int', then it also has a `bar' field (with type of content then being `Bool')
23:34:30 <desp> shachaf: ah.
23:35:24 <ski> copumpkin : compare with a hypothetical syntax for (non-GADT) record types, like
23:35:44 <ski>   data Stream a = head :: a
23:35:45 <ski>                 & tail :: Stream a
23:35:58 <ski> where you can define things like
23:36:03 <ski>   repeat :: a -> Stream a
23:36:09 <ski>   head (repeat a) = a
23:36:14 <ski>   tail (repeat a) = repeat a
23:36:14 <ski> and
23:36:27 <ski>   from :: Num a => a -> Stream a
23:36:31 <ski>   head (from a) = a
23:36:37 <ski>   tail (from a) = from (a+1)
23:37:42 <JamesSanders> are existential types common in Haskell code?
23:37:56 <ski> not that common, but they occur at times
23:38:01 <Peaker> is there any good reason, when writing a monadic library, to also include a pure copy of the code, when one can just use the Identity monad?
23:38:20 <ski> what kind of monadic library ?
23:38:43 <copumpkin> ski: ah
23:39:22 <ski> copumpkin : the record GADT was just a natural extrapolation from this .. i don't know how useful it'd be, though
23:39:46 <ski> (the above hypothetical (non-GADT) records, i think could be useful, though)
23:39:55 <copumpkin> yeah
23:40:16 <Peaker> ski: its sort of a monad transformer. Alternative for Iteratee.  yairchu is implementing something really nice here, impressive for a Haskell newbie :-)
23:40:21 <ski> (e.g. some monadic operations look much nicer, using that style of definition)
23:40:24 <Peaker> ski: I'm looking over his code, it seems real nice
23:40:40 <Peaker> http://github.com/yairchu/generator/tree/master
23:40:48 <Peaker> basically Python generators for Haskell
23:41:58 <ski>   runReader (ma >>= amb) rho = b
23:42:00 <ski>     where
23:42:04 <ski>     a = runReader ma rho
23:42:05 <ski>     b = runReader (amb a) rho
23:42:17 <ski>   runReader ask rho = rho
23:42:51 <ski>   runState (ma >>= amb) s0 = (b,s2)
23:42:53 <ski>     where
23:43:01 <ski>     (a,s1) = runState ma s0
23:43:10 <ski>     (b,s2) = runState (amb a) s1
23:43:17 <ski>   runState get s = (s,s)
23:43:29 <ski>   runState (set s) _ = ((),s)
23:43:32 <ski> et.c.
23:44:14 <adu> hi ski
23:44:35 <ski> morning adu
23:45:14 <adu> I think I have discovered a fundamental relationship between Haskell and RDF
23:46:09 <Axman6> RDF?
23:46:28 <Axman6> really delightful functions?
23:46:34 <adu> lol
23:46:41 <copumpkin> it's a knowledge representation format :P
23:46:42 <adu> Resource Description Framework
23:46:57 <ski> Repuddle Daydrudge Frenum
23:47:33 <adu> I think the datatypes in Haskell are closer to properties in RDF than in other languages
23:47:52 <adu> and that pattern matching in function definitions is almost like a Sparql query
23:48:02 <ski> (can you describe properties in RDF ?)
23:48:25 <adu> well, by analogy...
23:49:01 <adu> for example, the constructor for Rational, (:%) i think?
23:49:04 <ivanm> you wouldn't have copy/pasted a whole file of code or something, would you ski? ;-)
23:49:14 <ski> ivanm : not at all :)
23:49:25 <ski> (i wrote it in real-time)
23:49:52 <adu> (p :% q) would correspond to the RDF triples _:x hs:numerator p . _:x hs:denominator q .
23:50:36 <ski> is "_:x hs:numerator p . _:x hs:denominator q" one or more than one expression ?
23:51:05 <adu> and pattern matching (p :% q) would be like the Sparql clause "WHERE [hs:numerator p ; hs:denominator q]"
23:51:11 * ski doesn't know much about RDF
23:51:31 <ski> what is the `hs', here ?
23:51:34 <adu> ski: the thing I think is most beautiful about it is that there isn't much to know
23:51:42 <adu> ski: its a namespace prefix
23:52:05 <ski> and what is a "RDF triple" ?
23:52:18 <adu> ski: like in XML, however in XML, namespaces are used to build QNames (prefix, local-name) pairs, but in RDF they are used to build URIs by concatenation
23:53:11 <adu> ski: hs is an imaginary namespace I just invented for Haskell property names
23:54:58 <ski> so was the first RDF fragment one or several expressions (triples ?) ?
23:55:47 <adu> ski: 2 expressions... several RDF syntaxes (N3 and Turtle) use the notation (subject property object .) for a triple
23:56:19 <adu> ski: the beauty of RDF is that the triple is the only datatype
23:56:24 <ski> so what is the `_:x' subject, there ?
23:56:37 <ski> also, what corresponds to the `:%' in the haskell ?
23:57:02 <adu> ski: _:name is used to name a node so that it can be used in multiple triples without giving it a public name
23:57:27 <adu> ski: um, there is no correspondence
23:57:45 <ski> ok
23:57:51 <adu> ski: however, in RDF/XML notation, you could say that the type plays that role
23:58:07 <ski> in there `where [...]' clause, what is being matched ?
23:58:16 <adu> because in RDF/XML notation, the type of the node becomes the XML element that contains all of its sub-properties
23:58:26 <adu> ski: _:x is being matched
23:58:43 <ski> but it doesn't occur in the clause ..
23:59:00 <adu> ski: yes
23:59:23 <ski> so such a clause always matches the datum `_:x' ?
23:59:38 <ski> (s/satum/datum named/)
23:59:58 <adu> yes, the [....] notation means match the "subject" that has these property-object pairs
