00:01:20 <lispy> Does GHC still use C--?
00:01:46 <lispy> and if so, does it translate the C-- to machine code or does it use a C-- compiler?
00:04:26 <mmorrow> , error "œ∑´®†\¨ˆøπ“åß∂ƒ©˙∆˚¬…æΩ≈ç√∫˜µ≤≥"
00:04:27 <lunabot>  luna: luna: panic! (the 'impossible' happened)
00:04:43 <Axman6> > text "œ∑´®†\¨ˆøπ“åß∂ƒ©˙∆˚¬…æ"
00:04:44 <lambdabot>   mueval-core: Prelude.read: no parse
00:04:45 <lambdabot>  mueval-core: mueval-core: panic! (the ...
00:04:47 <mmorrow> , error "∆˚"
00:04:48 <lunabot>  luna:
00:04:53 <Axman6> , text "œ∑´®†\¨ˆøπ“åß∂ƒ©˙∆˚¬…æ"
00:04:54 <lunabot>  luna: luna: panic! (the 'impossible' happened)
00:05:04 <mmorrow> i wonder if it's a bug in error
00:05:08 <mmorrow> > fix error
00:05:09 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
00:05:48 <Axman6> > "œ∑ˆøπ“åß∂ƒ©˙∆˚¬…"
00:05:50 <lambdabot>   "\339\8721\710\248\960\8220\229\223\8706\402\169\729\8710\730\172\8230"
00:05:59 <Axman6> > text "œ∑ˆøπ“åß∂ƒ©˙∆˚¬…"
00:06:00 <lambdabot>   œ∑ˆøπ“åß∂ƒ©˙∆˚¬…
00:06:20 <mmorrow> an escaped umlaut:
00:06:22 <mmorrow> , error "\¨"
00:06:23 <lunabot>  luna: luna: panic! (the 'impossible' happened)
00:06:53 <Axman6> nicely spotted mmorrow
00:07:07 * mmorrow sat in /msg and started brute forcing it ;)
00:07:16 <Axman6> heh
00:07:25 <mmorrow> that's bizarre
00:07:28 <mmorrow> , "\¨"
00:07:30 <lunabot>  luna: luna: panic! (the 'impossible' happened)
00:07:46 <mmorrow> , "¨"
00:07:47 <lunabot>  "\168"
00:08:16 <mmorrow> , "\∆"
00:08:17 <lunabot>  luna: luna: panic! (the 'impossible' happened)
00:08:20 <mmorrow> heh, ok.
00:08:27 <mmorrow> and escaped anything > 127
00:08:32 <mmorrow> s/and/an/
00:08:47 <mmorrow> , text "\128"
00:08:48 <lunabot>  
00:08:51 <mmorrow> , text "\129"
00:08:52 <lunabot>  
00:08:55 <mmorrow> , text "\140"
00:08:56 <lunabot>  
00:08:58 <mmorrow> gah
00:09:07 <mmorrow> , "\ø"
00:09:08 <lunabot>  luna: luna: panic! (the 'impossible' happened)
00:09:12 <mmorrow> super
00:12:27 <mmorrow> ah, it's just some function in ghc calling panic instead of dealing with the char, not a bug per se
00:15:49 <mmorrow> what i don't understand is what the escape does to the char
00:16:17 <mmorrow> maybe the lexer doesn't check for unicode if a char's escaped?
00:20:17 <mmorrow> yeah, it's teh lexer
00:22:11 <kniu> I've been thinking.
00:22:27 <kniu> sum types have labels.
00:22:43 <kniu> record types also have labels.
00:23:21 <kniu> there's got to be a way to combine those into some sort of "cross" type.
00:25:45 <dhun> is the a standard function to replace the nth element of a list with a given one?
00:26:32 <kniu> I'd try to answer that if it were a complete sentence.
00:27:17 <dhun> maybe this   replace "abcde" 3 'X' -> "abXde"
00:29:54 <dhun> ok I will write my own one
00:31:12 <kniu> hm
00:31:27 <kniu> @hoogle [a] -> Int -> [a]
00:31:28 <lambdabot> Prelude drop :: Int -> [a] -> [a]
00:31:28 <lambdabot> Prelude take :: Int -> [a] -> [a]
00:31:28 <lambdabot> Data.List drop :: Int -> [a] -> [a]
00:31:43 <kniu> oh whoops
00:31:49 <kniu> @hoogle [a] -> Int -> a -> [a]
00:31:50 <lambdabot> Prelude enumFromThenTo :: Enum a => a -> a -> a -> [a]
00:31:50 <lambdabot> Data.IntMap findWithDefault :: a -> Key -> IntMap a -> a
00:31:50 <lambdabot> Distribution.ParseUtils IfBlock :: LineNo -> String -> [Field] -> [Field] -> Field
00:43:30 <dhun> its funny I don't seem to need this function the magic of functional programming eliminates the need for working with indexes
01:04:25 <idnar> dhun: if you're working with indices, you probably want an array anyway; creating a modified copy of a list is pretty expensive
01:07:39 <dhun> yes but I saw that I don't need indices anymore, and I am glad about it
01:07:52 <idnar> :)
01:07:55 <dhun> at least not for the problem I am working on right now
01:11:52 <dhun> how can I do multiple where clauses
01:11:53 <dhun> ?
01:11:58 <dhun> widthperrow a=if m>c then(100.0-(widthsum l))/(m-c) else 0.0
01:11:58 <dhun>     where l=(getwlist (dt3 x []) (getelist x));
01:11:58 <dhun>     where m=(maxcolumns a);
01:11:58 <dhun>     c=colswithwidth a
01:13:20 <monadic_kid> dhun: you don't need multiple where clasues
01:13:40 <monadic_kid> dhun: just have multiple bindings
01:13:49 <dhun> I think I found it
01:21:05 <Axman6> urgh.
01:21:17 <dhun> this explained it to me http://en.wikipedia.org/wiki/Haskell_(programming_language)#More_complex_examples
01:21:30 <Axman6> can't get haskeline installed in freebsd because cabal install can't find iconv
01:21:43 <Axman6> though, it seem to find that it needs to use -liconv just fine
01:23:36 <Axman6> hmm, just needed --extra-*-dirs
02:06:50 <MartyIX> if someone says just "constructor" does it mean "data constructor"?
02:07:15 <MartyIX> or "type constructor"
02:07:38 <dhun> well maybe they mean (Maybe a)
02:07:53 <dhun> Maybe a= Just a| Nothing
02:08:10 <dhun> so Just would be a data constructor
02:08:22 <dhun> an Maybe a type constructor
02:08:47 <lispy> :k Maybe
02:08:49 <lambdabot> * -> *
02:09:00 <lispy> :k Just
02:09:01 <lambdabot> Not in scope: type constructor or class `Just'
02:09:16 <lispy> :k Maybe Int
02:09:17 <MartyIX> dhun: ok, so it depends on context. I was considering if it has/has not a default meaning
02:09:18 <lambdabot> *
02:09:24 <MartyIX> dhun: thank you
02:09:51 <dhun> maybe the mean Something like
02:10:00 <lispy> I bet most people mean data constructor if they don't specify
02:10:33 <dhun> MyType a= Just a | MyConst1 MyType1 |...
02:10:45 <dhun> then the just constructor is Just a
02:11:18 <dhun> but of course you can give it an other name but Just
02:12:21 <Axman6> MartyIX: i'd usually say data constructor though
02:13:21 <MartyIX> Axman6: thanks that was my first opinion
02:21:21 <kaf_> hi
02:21:56 <kaf_> anybody here can help me with atom?
02:23:15 <kaf_> is there any way to create some action to execute a function that returns a  value
02:24:21 <kaf_> studing the documentation i think that custom actions is not the way... look action :: ([String] -> String) -> [UE] -> Atom ()
02:24:56 <kaf_> i need somtingh like return a atom ... Atom (V ---- )
02:25:23 <kaf_> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/atom
02:25:42 <pastorn> dhun: how's it going?
02:38:49 <RayNbow> of all places... I didn't expect someone commeting "I want a girl that understands when I start talking in lambda calculus" on the SankakuComplex website (warning: website not safe for work)
02:38:54 <RayNbow> *commenting
02:39:55 <MartyIX> http://www.haskell.org/tutorial/haskell-98-tutorial.pdf - I'm just reading page 28 and I'm wondering what is it absolute point from mathematics point of view. Similar formula is used for calculating the length of a line segment if I know coordinates of two points. But this formula doesn't make sense to me.
02:42:16 <RayNbow> MartyIX: you mean the definition of absPoint?
02:42:30 <MartyIX> RayNbow: yes
02:43:39 <RayNbow> well, I can't think of any use case, but it's d(O,P) where O stands for origin
02:47:20 <MartyIX> RayNbow: yeah it would make sense that it is absolute value in complex plain :)
02:49:49 <inbuninbu> question for you guys... i've looked for a parsec function to apply a parser to an arbitrary string _instead_ of input, but i can't find one. am i missing something?
02:50:37 <iago> inbuninbu, about what version of parsec are you talking
02:50:46 <inbuninbu> iago: 3
02:51:20 <inbuninbu> the concrete problem i'm facing is parsing XML. i want to use the same custom parser to apply a parser to the contents of an element
02:51:42 <iago> inbuninbu, well, you know there are xml parsers
02:51:45 <inbuninbu> the problem is that <tag></tag> can apply parser p to ""
02:52:14 <inbuninbu> but <tag/> doesn't give me the input to apply p to
02:52:38 <inbuninbu> iago: i know there are some out there, but i wanted something a little specialized
02:53:25 <iago> well, I dunno the problem, I would try to see if existing_xml_parser+some_code made what I want
02:53:26 <iago> but
02:54:17 <iago> I'm not sure if I understand your problem
02:54:28 <iago> you want to apply a parser over the content of an element
02:54:37 <iago> <tag> content </tag>
02:54:44 <iago> no?
02:55:46 <iago> uhm
02:55:54 <inbuninbu> iago: yes. but part of xml
02:56:01 <MyCatVerbs> inbuninbu: there's getInput and setInput in Parsec2's Text.ParserCombinators.Prim, or (much better idea, IMO) you could just make use of runParser inside p.
02:56:08 <iago> do you need to apply the parser to "" in <tag/> ?
02:56:22 <inbuninbu> iago: is that you may at times have <tag/>
02:56:37 <inbuninbu> iago: actually, thanks, that's a brilliant idea
02:56:44 <inbuninbu> i'll give it a whirl
02:56:57 <iago> inbuninbu, I think you want to thanks MyCatVerbs
02:57:30 <inbuninbu> ah, my eyes fool me again
02:57:39 <inbuninbu> MyCatVerbs: thanks!
02:57:57 <MyCatVerbs> Welcome. Hope it works out for you.
02:57:59 <iago> I continue to see it a bit strange but well :) if you are satisfied
03:15:25 * xi-zi http://www.demotywatory.pl/demot/3101_500.jpg
03:16:08 <MyCatVerbs> Offtopic and unfunny. I award you nil points.
03:16:23 * ivanm agrees
03:16:48 <wli> I guess since I managed to bore #haskell-blah to death the offtopic people have wandered into #haskell
03:17:46 <ivanm> wli: so you off-topiced the off-topic channel? :o
03:17:56 <wli> heh
03:19:58 <ivanm> ummm.... so ICFP contest will be starting _16 seconds_ past the hour? :s
03:20:00 <ivanm> wtf?
03:20:22 <ivanm> though I note that for me, it will be starting about 10 PM on thursday night...
03:22:14 <vegai> ah, icfp time already?
03:22:23 <vegai> time flies like an Arrow...
03:23:30 <ivanm> 26 june, 13:00:16, UTC-5
03:23:47 <ivanm> @remember vegai time flies like an Arrow...
03:23:47 <lambdabot> I will never forget.
03:30:18 <dankna> Hi, all.
03:30:36 <dankna> So I noticed that hsgnutls was broken, and thought I might try to repair it, since it's (hopefully) only a small bitrot.
03:30:42 <dankna> But it's beyond my expertise.
03:31:16 <dankna> http://nopaste.com/p/a1S6HO3Jm illustrates.
03:31:35 <dankna> I look at this and go "e... where in the code is e?"
03:32:12 <dankna> If it makes more sense to anybody else and you'd care to donate a few minutes to discuss it, it would be greatly appreciated.
03:35:19 <ivanm> dankna: no, it's your usage
03:35:32 * dankna blinks
03:35:37 <ivanm> with the new extensible exceptions stuff in base>=4, Exceptions are instances of the Exception class
03:35:50 <ivanm> basically, your catch function has to have an explicit type
03:35:54 * ivanm has had the same problem before
03:36:16 <dankna> I should mention that I didn't write this code and I only barely understand it.  I thought I might be able to fix it as a sort of community service, incidentally benefitting myself, heh.
03:36:36 <dankna> How would I add that explicit type?  I mean... it doesn't use the variable.
03:36:37 <ivanm> dankna: OK, here's how I fixed a similar problem
03:36:58 <dankna> Thanks!
03:37:06 <ivanm> take the (\_ -> ...) and make it an actual function with the explicit Exception type
03:37:23 <ivanm> in this case, IOError
03:37:31 <ivanm> though I'd question why it's unsafePerformIO'd...
03:37:52 <Cale> Or just  (\(SomeException _) -> return Nothing)
03:38:05 <Cale> generally works
03:38:11 <ivanm> Cale: :o
03:38:24 <ivanm> by "SomeException", do you mean the constructor for that exception?
03:38:28 <ivanm> or is that a generic thing?
03:38:28 <Cale> no
03:38:34 <Cale> :t SomeException
03:38:34 <ivanm> @hoogle SomeException
03:38:35 <lambdabot> No results found
03:38:35 <lambdabot> Not in scope: data constructor `SomeException'
03:38:41 <Cale> :t Control.Exception.SomeException
03:38:42 <lambdabot> forall e. (GHC.Exception.Exception e) => e -> GHC.Exception.SomeException
03:38:52 <ivanm> thought it would be that
03:38:58 <ivanm> Cale: sweet, that's a nice trick/hack
03:39:07 <Cale> That's actually the intended use
03:39:12 <ivanm> it's a bit of a PITA IMHO that catch, tryJust, etc. no longer work
03:39:13 <ivanm> Cale: ahhh
03:39:22 <ivanm> *work without tweaking
03:39:37 <ivanm> Cale: so you don't need to "lift" the exception into SomeException or something first?
03:39:52 <dankna> wow, it worked
03:39:53 <dankna> thank you both
03:39:55 <ivanm> or will the function do that since it expects SomeException?
03:40:07 <ivanm> dankna: you think Cale is in the habit of giving code snippets that _don't_ work? :o
03:40:16 <dankna> well, this is the first time I've met Cale :)
03:40:21 <Cale> hehe :)
03:40:43 <Cale> ivanm: It works because SomeException is an instance of Exception
03:40:47 <ivanm> *nod*
03:41:07 <ivanm> Cale: it's just that, the generated Exception presumably won't be of type SomeException
03:41:27 <ivanm> (this type-class hackery is hurting my brains more than usual!)
03:41:37 <Cale> Oh, SomeException is a wrapper around arbitrary exception types
03:41:46 <Cale> Take a look at the type of the constructor for SomeException
03:41:51 <Cale> :t Control.Exception.SomeException
03:41:52 <lambdabot> forall e. (GHC.Exception.Exception e) => e -> GHC.Exception.SomeException
03:41:59 <Cale> The 'e' vanishes!
03:42:09 <Cale> (It's an existential)
03:42:50 <ivanm> Cale: so it automagically gets coerced into a SomeException due to the type?
03:43:23 <Cale> So when you pattern match against (SomeException x), all that you can do with x is apply operations which are valid for instances of Exception, since you don't know what type of exception it is.
03:43:36 <ivanm> *nod*
03:43:46 <Cale> However, Exception types are required to be instances of Typeable, so you can recover :)
03:43:53 <Cale> (if need be)
03:44:04 <ivanm> heh
03:44:28 <Cale> class (Typeable e, Show e) => Exception e where
03:44:28 <Cale>   toException :: e -> SomeException
03:44:28 <Cale>   fromException :: SomeException -> Maybe e
03:44:50 <ivanm> looks like dankna wants fromException...
03:45:00 <ivanm> no, wait, duh, misread that
03:45:32 <ivanm> Cale: I take it for SomeException, toException is id, and fromException is Just ?
03:45:40 <Cale> yeah
03:46:01 <Cale> and actually, there are default implementations of toException and fromException, so you never have to implement them
03:46:05 <Cale>     toException = SomeException
03:46:05 <Cale>     fromException (SomeException e) = cast e
03:46:59 <ivanm> does Exception require anything else? or is that it?
03:47:05 <Cale> That's it.
03:47:11 <ivanm> so just have to do the Typeable instance?
03:47:15 <ivanm> @src Typeable
03:47:16 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
03:47:17 <Cale> So if I want to define a new exception type, I can just write
03:47:32 <Cale> data MyException = MyException deriving (Show, Typeable)
03:47:42 <Cale> instance Exception MyException where {- blank -}
03:48:02 <ivanm> do you need the where ?
03:48:09 <augustss> no
03:48:09 <Cale> I'm not sure actually.
03:48:10 <ivanm> seeing as how you're just using defaults?
03:48:13 <Cale> ah
03:48:29 <Cale> Right, you don't need the where.
03:48:32 <ivanm> oh, and is Typeable one of those deriving ones guaranteed by the standard, or is it a GHC-ism?
03:48:38 <Cale> GHC
03:48:40 <augustss> ghc
03:49:02 <Cale> But this exception library uses many things which are specific to GHC at the moment
03:49:08 <ivanm> *nod*
03:49:19 <ivanm> how different is it from the actual extensible-exceptions package?
03:49:44 <Cale> Is it different? I don't know.
03:49:56 <ivanm> that's what I'm asking ;-)
03:50:16 <Cale> Oh, the extensible-exceptions package is intended for GHC < 6.10
03:50:40 <Cale> It reexports Control.Exception for newer GHCs
03:50:49 <ivanm> *nod* so it _is_ the same ;-)
03:51:30 <ivanm> it would be nice if there was a way of telling what type of exception functions threw without looking at the docs... but then we'd be like java where you have "throws Foo" 10 levels deep :s
03:51:47 <dankna> there
03:51:56 <dankna> I tracked down the probable maintainer and sent off an email with the fix
03:52:08 <dankna> a little more complicated because I don't speak German; but huzzah for Babelfish
03:52:21 <iago> ivanm, I think you can see this exceptions like RuntimeExceptions
03:52:24 <dankna> the code should be self-explanatory anyway
03:52:26 <augustss> ivanm: you can actually do that, but that's not how Haskell exceptions work at the moment
03:52:40 <Vanadium> dankna: Chances are a German programmer speaks English anyway :3
03:52:44 <dankna> true enough
03:52:46 <Cale> Well, if you wanted that, you'd use Either or ErrorT or something :)
03:52:51 <dankna> I included the text bilingually anyhow
03:52:55 <ivanm> augustss: *nod*
03:52:56 <ivanm> Cale: heh
03:55:41 <Peaker> if Haskell had _ for "type-infer this part of the type", then maybe you could use "optionally checked exceptions" where you let type inference decide which exceptions are throwable in the ErrorT, or you can specify it explicitly
03:56:31 <augustss> Peaker: if you specify exactly what that part inference means that chances are Simon PJ will add it.
03:56:35 <augustss> I've asked him
03:56:46 <augustss> But I'm to lazy to write the spec.
03:57:01 <Peaker> augustss: I'm not sure I know how to write such a spec - any example specs I can look at?
03:58:02 <augustss> Peaker: I think just a detailed description of what you want would do it.  Then circulate it and people will complain. :)
03:58:49 <Peaker> augustss: so sending something to haskell cafe is enough?
03:59:00 <augustss> yeah, i think so
03:59:37 <Peaker> cool, will try to write something then
04:01:15 <augustss> There are some issues to ponder, like should yo be able to say  foo :: (_a. _a) meaning that it's a pair where both parts have the same type, but you don't say which.
04:02:04 <iago> uhc has something like that
04:04:09 <Peaker> augustss: hmm.. sounds like higher-order type-variables?
04:04:27 <Peaker> a type variable quantifying over type variable expressions, that is
04:04:48 <Peaker> I think a simple _ can be a nice addition and does not contradict future additions of such higher-order type-variables
04:05:01 <augustss> Peaker: I think it's actually much easier.  It's just another unification variable.  But as I said, I've not worked out the details.
04:06:21 <Peaker> augustss: well, I suppose the situations that require scoped type variables are ones where you can't just use a new forall'd type-variable -- but you might be able to use a type-variable that quantifies (perhaps existentially?) over existing type variables
04:06:59 <Peaker> augustss: I guess what you say is true, except its not as-universally quantified like normal Haskell type-variables?
04:07:19 <augustss> Peaker: something along those lines, yeah
04:12:09 <iago> http://www.cs.uu.nl/wiki/bin/view/Ehc/EhcUserDocumentation#3_2_Partial_type_signature
04:12:10 <iago> ??
04:13:02 <augustss> yeah, that's the idea
04:14:20 <Peaker> The question is -- can Haskell have Java-like "checked exceptions" with inference on ErrorT types?
04:15:14 <iago> throwing exceptions of different types?
04:15:15 <augustss> http://hackage.haskell.org/package/control-monad-exception
04:16:09 <Peaker> augustss: awesome, thanks :-)
04:17:43 <iago> uhm
04:17:46 <augustss> Haskell has an amazingly programmable type system.
04:18:10 <ivanm> augustss: and you would know ;-)
04:18:43 <Peaker> augustss: I still am surprised, often :-)
04:33:10 <And[y]> hi. i'm thinking about coding a predicate, to search for highly composite numbers. does some of you know a good algorithm to search for those? :)
04:34:11 <wli> If n has k factors, then it has a factor less than n^(1/k).
04:34:27 <wli> Or equal to that.
04:35:39 <And[y]> aye, that sounds good. i'm a newbie to haskell, btw, but i will try to get it done now, thanks for the hint ;)
04:35:41 <Axman6> how interesting
05:04:30 <Bacta> @fag can Haskell help me score coke?
05:04:31 <lambdabot> The answer is: Yes! Haskell can do that.
05:04:49 <ik> frequently asked guestions?
05:04:57 <Bacta> Thanks, that's all I wanted to know
05:05:11 <Bacta> I'll be alerting the local authorities
05:05:19 <ik> ok
05:05:38 <ik> To tell them they can score some coke?
05:05:44 <mauke> I'm reporting you to the AOL police for stealing images, as it is a crime
05:06:06 <Bacta> Haskell is clearly a danger to children
05:06:08 <Bacta> and uni students
05:06:18 <ik> and child uni students
05:06:29 <ik> haskell is like a perfect storm for them
05:06:53 <ivanm> mauke: hmmm?
05:06:58 <ivanm> which images were stolen?
05:07:43 <ik> ivanm: the ones with the extruded anuses
05:08:04 <ivanm> why did you bring up goatse?
05:08:17 <Bacta> Quite clearly you lot are better trolls than I am so I'll be leaving now
05:08:37 <p_l> ... lol
05:09:11 <mauke> good work, everyone
05:09:38 <ivanm> hasn't Bacta been here before for non-trolling purposes?
05:10:10 <p_l> ivanm: I'm not sure, I recall that nick with trolling (or slightly veiled trolling) purposes before, and I think not only on this channel
05:11:27 <ivanm> yup, dons has kicked him before
05:11:31 <ik> bacta has existed in #python and #nethack and #freenode
05:11:48 <ik> among others
05:11:56 <ivanm> he's changed his mask though...
05:12:13 <p_l> and runs as administrator
05:12:24 <ivanm> heh, yeah
05:31:27 <uzytkownik> @pl \f g x y -> f (g x) (g y)
05:31:27 <lambdabot> join . ((flip . ((.) .)) .) . (.)
05:33:20 <ivanm> @unpl join . ((flip . ((.) .)) .) . (.)
05:33:21 <lambdabot> (\ n -> (\ y b c f -> n (y c) (b f)) >>= \ o -> o)
05:33:26 <ivanm> heh
05:33:43 <ivanm> though it's weird to have an explicit id function...
05:38:10 <uzytkownik> I guess that could be something like epimorphism library... Or may be I spend too much time on linear algebra course...
05:39:00 <dhun> my haskell script for conveting wikis to latex has evolved, here is new pdf (in German, but only the layout matters), http://upload.wikimedia.org/wikibooks/de/f/f6/Mathematik_Stochastik.pdf
05:39:20 <dhun> now I have time to make the sources more readable
05:40:11 <mauke> Einf[Pleaseinsertintopreamble]hrung
05:40:48 <burp> nice, looks quite good
05:40:58 <Botje> uppercase ü is okay though :p
05:41:43 <Axman6> Ü
05:42:31 <Twey> ivanm: What's that about id functions?
05:42:31 <dhun> in latex source the ü correct
05:42:55 <dhun> so probably that is a problem of latex
05:44:42 <ivanm> Twey: the @unpl I did had \ o -> o
05:45:16 <dhun> the  Einf[Pleaseinsertintopreamble]hrung has disappered after runnig latex one more time
05:45:24 <ivanm> dhun: you might need to use utf8 stuff in latex
05:45:33 <dhun> it included
05:45:47 <dhun> somtimes you have to run latex more than once
05:45:52 <ivanm> dhun: \usepackage[utf8]{inputenc}
05:45:56 <ivanm> you have that?
05:45:57 <dhun> I did
05:46:01 <ivanm> hmmm....
05:46:03 <dhun> it away now
05:46:19 <ivanm> never had to run it twice that I recall just for unicode stuff...
05:46:20 <dhun> I just ran latex one more time
05:46:29 <dhun> yes but it is the toc
05:46:43 <dhun> for the toc you always need to run it twice
05:47:03 <ivanm> ahhhh, fair enough
05:47:43 <dhun> the hading of the chapter in the pdf I uploaded is correct, the only problem is in the toc
05:59:19 <wind> hello
06:00:40 <Lemmih> wind: Hi.
06:09:19 <ivanm> Lemmih: with LHC, do you see it as something that will become part of GHC or an add-on?
06:16:16 <wind> does anyone here install ghc6.10.3 on freebsd box successfully?
06:16:54 <skorpan> i have [([a], b)] and i'd like to have a function lookup' :: [([a], b)] -> a -> Maybe b
06:17:00 <skorpan> is there any such thing?
06:17:15 <skorpan> or maybe lookupWith :: (a -> Bool) -> [(a, b)] -> Maybe b
06:17:25 <skorpan> anyone?
06:17:30 <skorpan> generalized lookup?
06:18:44 <Beelsebob1> listToMaybe . filter?
06:18:59 <Beelsebob1> well, not quite
06:19:14 <Beelsebob1> but very close
06:19:53 <skorpan> :t listToMaybe
06:19:54 <lambdabot> forall a. [a] -> Maybe a
06:20:02 <skorpan> @src listToMaybe
06:20:03 <lambdabot> listToMaybe []        =  Nothing
06:20:03 <lambdabot> listToMaybe (a:_)     =  Just a
06:20:03 <Axman6> wind: no, getting the haskeline problems?
06:20:10 <iago> [ y | (xs,y) <- list, any p xs ]
06:20:34 <skorpan> damn you list comprehensions!
06:21:03 <skorpan> that would kind of work, but i just realised i want "... -> Maybe (a, b)"
06:21:08 <skorpan> hm, no i don't
06:21:40 <iago> you said that you want Maybe b
06:21:46 <iago> listToMaybe [ y | (xs,y) <- list, any p xs ]
06:22:25 <iago> another option
06:22:45 <iago> snd <$> find (any p . fst) list
06:23:12 <Axman6> wind: 6.10.2 compiles just fine
06:23:41 <Axman6> @undo [ y | (xs,y) <- list, any p xs ]
06:23:41 <lambdabot> concatMap (\ (xs, y) -> if any p xs then [y] else []) list
06:24:30 <iago> > find (any (>2) . fst) [([1,2],'a'),([3,4],'b')]
06:24:32 <lambdabot>   Just ([3,4],'b')
06:24:39 <iago> > snd <$> find (any (>2) . fst) [([1,2],'a'),([3,4],'b')]
06:24:41 <lambdabot>   Just 'b'
06:25:26 <QtPlaty[HireMe]> I'm looking for something of the type
06:25:31 <QtPlaty[HireMe]> Monoid m => (a->m b) -> [a] -> m b
06:25:58 <Saizan_> ?type foldMap
06:26:00 <lambdabot> Not in scope: `foldMap'
06:26:10 <QtPlaty[HireMe]> hoogle isn't showing me anyting usefull, is this something I'm going to need to roll myself.
06:26:19 <mauke> QtPlaty[HireMe]: kind error
06:26:23 <mux> QtPlaty[HireMe]: that can't exist, a Monoid is a type, not a type constructor
06:26:25 <mux> it has kind *
06:26:53 <QtPlaty[HireMe]> Sorry
06:26:58 <QtPlaty[HireMe]> Monoid m => (a->m) -> [a] -> m
06:27:15 <iago> like Saizan_ suggest
06:27:16 <iago> foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
06:27:28 <mauke> :t (mconcat .) . map
06:27:29 <lambdabot> forall a a1. (Monoid a) => (a1 -> a) -> [a1] -> a
06:28:32 <ziman> :t (.:)
06:28:33 <lambdabot> Not in scope: `.:'
06:36:48 <Axman6> :t (. (:))
06:36:51 <lambdabot> forall c a. (([a] -> [a]) -> c) -> a -> c
06:38:45 <DrSyzygy> Now I'm getting tempted putting together a package for automatic logic deductions using the .·. operator to denote steps.
06:41:24 <nomeata> Hi. I want to put the output of ./Setup haddock on my web page. What would be a good choice public website to pass to --html-location so that links like "Double" or "IO" will work?
06:41:56 <ivanm> nomeata: you can use the ghc docs
06:42:13 <ivanm> but what with library re-organisation, etc. you can't guarantee that they'd be stable :s
06:42:25 <nomeata> ivanm: right, but still better than dead links
06:42:26 <ivanm> (lambdabot's @doc plugin fails sometimes due to this)
06:42:30 <ivanm> nomeata: *nod*
06:42:30 <MartyIX>       zipWith                 :: (a -> a -> a) -> [a] -> [a] -> [a]
06:42:30 <MartyIX>       zipWith f [] ys         = []
06:42:30 <MartyIX>       zipWith f xs []         = []
06:42:30 <MartyIX>       zipWith f (x:xs) (y:ys) = f x y : zipWith f xs ys
06:42:39 <ivanm> alternatively, link to base, etc. on hackage
06:42:59 <And[y]> hi, i got a function isPrime and this one: factors n = filter (\x -> n `mod` x == 0 ) [1..(n-1)];
06:43:03 <MartyIX> what is wrong with the zipWith function WinHugs says that on second line is "unexpected `="
06:43:09 <And[y]> how am i supposed to combine them? =)
06:43:23 <And[y]> so i only get factors, that are non-prime, ofc ;)
06:43:45 <ivanm> forget that, base isn't on hackage
06:43:54 <michaeldever> dcoutts: hey man, is there any way I can diff HTTP ... 0.0.6 and 0.0.5
06:44:14 <michaeldever> dcoutts: sorry, diff .7 and .6 :)
06:44:27 <ivanm> michaeldever: why are you asking dcoutts?
06:44:31 <nomeata> ivanm: hmm, will not work nicely, as I can only generate correct links for one package (base or ghc-prim, for example)
06:44:38 <ivanm> http://hackage.haskell.org/package/HTTP <-- he's not listed here...
06:44:44 <ivanm> nomeata: :(
06:44:53 <dcoutts> michaeldever: sure, cabal unpack http-4000.0.6 http-4000.0.7; diff -R http-4000.0.6 http-4000.0.7
06:45:11 <michaeldever> ivanm, ah its to do with a cabal bug :)
06:45:18 <dcoutts> erm diff -R HTTP-4000.0.6 HTTP-4000.0.7
06:45:23 <ivanm> michaeldever: ahhh
06:50:00 <And[y]> nonPrimeFactors n = filter (isPrime n) (filter (\x -> n `mod` x == 0 ) [1..(n-1)]) ... does not work. hugs reports: Type bool does not match Int -> Bool :S
06:50:39 <And[y]> i know there is a NOT missing, too, but i just watend to first test the filter on filter :>
06:50:42 <RayNbow> MartyIX: are you trying to load a file in WinHugs?
06:51:15 <dibblego> And[y], I imagine that (isPrime n) is of type Bool
06:51:35 <dibblego> maybe you mean (\n -> isPrime n) or just isPrime
06:51:47 <MartyIX> RayNbow: it should reload source code every time I change it in my editor but it started to write strange errors so I loaded the source code again and it seems it's going to work..
06:52:31 <RayNbow> MartyIX: could you put your file in a pastebin?
06:52:40 <And[y]>  (\n -> isPrime n == False) ... found it allready, but thanks :)
06:52:52 <mauke> == False? ... you're fired
06:52:57 <dibblego> And[y], (not . isPrime)
06:53:03 <mux> heheh
06:53:27 <ivanm> dibblego: so what's the details for this IRC session for BFG?
06:53:35 <And[y]> factors 100
06:53:35 <And[y]> [1,2,4,5,10,20,25,50]
06:53:36 <RayNbow> mauke: you don't want to know how often I saw that ==False mistake when I was assisting lab courses :p
06:53:38 <dibblego> ivanm, none yet -- still brewing
06:53:44 <And[y]> nonPrimeFactors 100
06:53:44 <And[y]> [1,4,10,20,25,50]
06:53:52 <ivanm> dibblego: *nod*
06:53:57 <MartyIX> RayNbow: http://pastebin.com/m6ca83038
06:54:01 <byorgey> well, == False  isn't nearly as bad as  == True
06:54:08 <RayNbow> mauke: there are even 3rd year students that write code like that :p
06:54:12 <koeien> why not (... == True) == True
06:54:16 <dibblego> /= True ftw!
06:54:18 <koeien> even better!
06:54:48 <dibblego> == id False
06:54:51 <byorgey> > 3 == 3 == True == True == True
06:54:54 <lambdabot>   Precedence parsing error
06:54:54 <lambdabot>      cannot mix `GHC.Classes.==' [infix 4] and `GH...
06:55:08 <dibblego> == id (not . not) False
06:55:11 <byorgey> > (((3 == 3) == True) == True) == True
06:55:13 <lambdabot>   True
06:55:18 <RayNbow> MartyIX: are you sure that's the file you're trying to load?
06:55:20 <ivanm> looks like == doesn't associate too well...
06:55:26 <RayNbow> because it works fine here in Hugs
06:56:01 <mux> > foldr (==) True (repeat True)
06:56:07 <lambdabot>   mueval-core: Prelude.read: no parse
06:56:07 <lambdabot>  mueval: ExitFailure 1
06:56:26 <mux> heh, lambdabot timeout messages became weird at some point
06:56:36 <MartyIX> RayNbow: http://pastebin.com/m2bf272d6 - here is complete file, but it started to produce errors after I made an error in product predicate
06:56:59 <skorpan> why are there so many functions that hoogle can't find?
06:57:06 <MartyIX> RayNbow: what module should I import in order to "take" function would work?
06:57:14 <hackagebot> nntp 0.0.1 - Library to connect to an NNTP Server (MaciejPiechotka)
06:57:14 <hackagebot> L-seed 0.1 - Plant growing programming game (JoachimBreitner)
06:57:18 <mux> it doesn't index everything on hackage, I think, try hayoo
06:57:28 <mux> hayoo typically finds more stuff for me
06:57:38 <RayNbow> MartyIX: write take with a lowercase t? :p
06:58:11 <MartyIX> RayNbow: hmpf such a nuisance :(
07:01:08 <dhun> how do I call a function that takes a parsetree and returns a latex files as a string
07:01:10 <dhun> ?
07:01:30 <dhun> file
07:01:37 <byorgey> dhun: the same way you call any other function.  can you be a bit more specific?
07:01:47 <byorgey> I am not sure what you need help with.
07:01:56 <dhun> no I want to give it a name currently it is called dirk
07:02:09 <ivanm> oh, you want a _name_ for the function
07:02:10 <byorgey> ohhhhh, hehe =)
07:02:13 <ivanm> tree2tex ?
07:02:17 <koeien> tree2TeX
07:02:23 <byorgey> texify ?
07:02:24 <dhun> tree2Latex
07:02:31 <DrSyzygy> tree2LaTeX
07:02:46 <koeien> although the capitalization of TeX might get annoying
07:02:47 <RayNbow> MartyIX, your product function, what is it supposed to do?
07:02:56 <mauke> texhnolyze
07:03:07 <dhun> thats cool
07:03:20 <ivanm> mauke: heh
07:03:29 <koeien> treeToTexTransformerFunctionInstance
07:03:35 <dhun> to long
07:04:10 <ivanm> @slap koeien
07:04:11 * lambdabot secretly deletes koeien's source code
07:04:19 <ivanm> no OOP-isms, thank you very much!
07:04:23 <byorgey> functionWhichTakesAParseTreeAndConvertsItToAStringRepresentingLaTeXCode
07:04:37 <Zao> unsafeFunctionWhich...
07:04:44 <ivanm> byorgey: be more specific... what _kind_ of parse tree? :p
07:04:47 <RayNbow> you need a treeToTexTransformerFactory first :p
07:04:50 <MartyIX> RayNbow: http://pastebin.com/m361b8afd - here is newer version. It should make product of two power series. But it's not finished and I think that there will be probably much better way how to do that
07:04:52 <byorgey> oh, sorry, I meant:
07:04:53 <ivanm> Zao: why is it unsafe?
07:04:53 <Zao> Or for more amusingness, hide the unsafety in the middle.
07:05:06 <byorgey> functionWhichTakesAParseTreeFactoryAndConvertsItToAStringRepresentingLaTeXCodeFactoryFactory
07:05:08 <Zao> ivanm: It could run out of memory! Or shave your cat!
07:05:22 <ivanm> Zao: but it's not IO!
07:05:29 <koeien> ivanm: it is!
07:05:30 <DrSyzygy> ivanm: Hence the unsafe.
07:05:35 <ivanm> so it can't launch the nuclear missiles I keep in my backyard!
07:05:37 <koeien> your computer gets warmer!
07:05:38 <RayNbow> btw MartyIX, you can move the let definitions in a list comprehension
07:05:46 <Zao> koeien: Oh noes, not local warming!@
07:05:49 <ivanm> koeien: don't make me @slap you again...
07:05:49 <ivanm> ;-)
07:06:20 <dhun> ok I think I will take tree2Latex since this is the usual capitalization in Haskell
07:06:37 <DrSyzygy> LaTeX!!
07:06:40 <RayNbow> > [sum xs' | n <- [1..4], let xs = replicate n 1, let xs' = reverse xs]  -- MartyIX
07:06:41 <lambdabot>   [1,2,3,4]
07:06:42 <mauke> latex
07:06:56 <ivanm> dhun: well, I don't recall seeing "2" in function names that much...
07:07:04 <DrSyzygy> treeToLaTeX
07:07:06 <RayNbow> (example of using let in a list comprehension)
07:07:16 <mauke> ΛαΤεΧ
07:07:29 <DrSyzygy> Now you're just showing off. :-P
07:07:29 <dhun> treeToLatex
07:07:30 <MartyIX> Raynbow: it looks better now :)
07:07:49 <dhun> the point about LaTeX is that it is hard to type
07:07:59 <dhun> and you will have to type it often
07:08:08 <mauke> tab completion
07:08:08 <koeien> i like seeing "2" in function names. makes a clear mental separation between the two things that are converted
07:08:30 <ivanm> dhun: how is it hard to type?
07:08:31 <DrSyzygy> Why on earth would you work without tab completion anyway?
07:08:37 <ivanm> and presumably, you wouldn't use it that much anyway...
07:08:51 <ivanm> DrSyzygy: I don't use tab completion when writing code...
07:08:58 <mauke> ivanm: why not?
07:09:11 <dhun> I currently use gedit
07:09:31 <ivanm> mauke: because I haven't bothered working out how to get one of the 50-million emacs tab-completion packages to play nicely with my haskell setup ;-)
07:09:38 <mauke> ivanm: vim
07:09:58 <dhun> ok treeToLaTeX
07:10:07 <ivanm> mauke: or not
07:10:49 <MartyIX> RayNbow: product series1 series2  = [sum (zipWith (*) xs ys ) | n <- [1,2..], let xs = take n series1, let ys = reverse (take n series2)]  -- this should be it
07:11:13 <Zao> You should naturally define a class Latex Tree
07:11:13 <MartyIX> RayNbow: do you know about more efficient way how to do this?
07:11:20 <Zao> Well, LaTeX Tree
07:11:43 <byorgey> MartyIX: convolution product?
07:11:45 <Botje> MartyIX: looks like you need a scan of some sorts
07:12:20 <byorgey> MartyIX: there is a better way to do it, let me see if I can find you a link
07:12:28 <Botje> are you sure it's not take n (reverse series2) ?
07:13:57 <Botje> because then you get scanl1 (+) $ zipWith (*) series1 (reverse series2)
07:13:57 <MartyIX> byorgey: convolution product is something else. I need to find out product of two polynoms (but they're infinite)
07:14:08 <Botje> oh.
07:15:44 <MartyIX> Botje: the formula to compute coeficinet of the new series (that is product of two power series) is: sum_{k=0}^{n} a_k*b_{n-k
07:16:06 <MartyIX> Botje: so that I need in both cases first n elements
07:17:06 <Botje> brr, that's iffy :)
07:18:16 <MartyIX> Botje: well this is one way I know to be punctual :)
07:20:45 <dhun> I came to the conclusion that "widths" is unpronounceable
07:21:41 <byorgey> MartyIX: yeah, power series multiplication is the same as convolution, unless convolution also means something else I don't know about
07:21:55 <byorgey> MartyIX: check out http://citeseer.ist.psu.edu/101898.html
07:22:10 <byorgey> (f:fs) * (g:gs) = f*g : (f.*gs + g.*fs + (0 : fs*gs))
07:22:23 <byorgey> where x .* ys = map (*x) ys
07:22:30 <byorgey> and + denotes  zipWith (+)
07:22:38 <dev31212> hello all
07:22:48 <byorgey> hi there dev31212
07:22:52 <dev31212> hi byorgey
07:23:03 <dev31212> I am falling in love with haskell :)
07:23:13 <dev31212> Studying parsers at the moment.
07:23:21 <byorgey> dev31212: welcome to the club =)
07:23:25 <dev31212> :)
07:23:44 <dev31212> Its just so intuitive building complex things fromsmall pieces
07:24:00 <dev31212> combinatory logic is neat.
07:24:10 <MartyIX> byorgey: thanks I'm reading it
07:26:05 <byorgey> dev31212: indeed!
07:27:09 <dev31212> byorgey, yeah it is....I had a really ambitious project, but I scaled back a bit
07:27:18 <dev31212> my first proiject will be a haskell based Yahoo chat
07:27:24 <dev31212> I have a partner to work with
07:27:37 <dev31212> first, real one that is
07:28:10 <dev31212> Did a crappy on in Java once..I think this might be easier
07:32:11 <byorgey> dev31212: cool
07:39:10 <And[y]> now, if i search for highly composite numbers, and have a function factorCount, i have to find every number, that has more factors, then every number before this number.
07:39:15 <And[y]> i use this for now: hcns n = [ x | x<-[1..n], divisorCount  x > divisorCount (x-1) ]
07:39:37 <And[y]> but ofc this only checks the number before the actual number, and not all number before
07:39:59 <And[y]> how am i supposed to check it for all numbers before? =)
07:41:30 <byorgey> And[y]: you'll have to somehow keep a running maximum.
07:41:33 <MartyIX> byorgey: I give up. I don't get it. I'm not sure what the convolution is. In the document you posted (page 4) is the same formula I used.
07:41:59 <dhun> if I iterate over a tree do you call it walking through thee three I need to name a function for doing that
07:42:05 <dhun> tree
07:42:07 <dhun> !
07:42:12 <And[y]> yeah, i thought so, too, but i'm way to noobie to find a working way :D
07:42:45 <byorgey> MartyIX: yes, that formula is a convolution.  My point was that that document has more efficient code for calculating it than what you were using.
07:42:56 <byorgey> right above the formula.
07:43:26 <dhun> Ok so I will call my function walk
07:44:49 <byorgey> > let (+++) = zipWith (+); (f:fs) * (g:gs) = f*g : (map (*f) gs +++ map (*g) fs +++ (0: fs*gs))  in  [1..] * [1..]
07:44:51 <lambdabot>   Occurs check: cannot construct the infinite type: t = [t]
07:45:19 <byorgey> > let (+++) = zipWith (+); (f:fs) *** (g:gs) = f*g : (map (*f) gs +++ map (*g) fs +++ (0: fs***gs))  in  [1..] *** [1..]
07:45:21 <lambdabot>   [1,4,10,20,35,56,84,120,165,220,286,364,455,560,680,816,969,1140,1330,1540,...
07:45:34 <byorgey> then you just need to add some cases to handle empty lists.
07:45:55 <byorgey> MartyIX: does that help?
07:46:35 <byorgey> dhun: what do you mean, "iterate over a tree"?
07:46:59 <byorgey> dhun: do you mean that you want to apply a function to each element in the tree, and get a new tree as a result?
07:47:28 <MartyIX> byorgey: I understand the formula. And I'm trying to understand why it works. thanks for help ;-)
07:47:48 <byorgey> MartyIX: sure =)
07:48:22 <dhun> walk (Node [nodes]):xs = (walk nodes)++ walk( xs)
07:48:38 <mauke> toList
07:48:55 <byorgey> or 'flatten'
07:48:56 <dhun> no really
07:49:06 <byorgey> And[y]: I would suggest first doing something like   map (\x -> (divisorCount x, x)) [1..n]
07:49:12 <dhun> the part ++walk (xs) is factored out
07:49:23 <mauke> well, that line doesn't make sense anyway
07:49:29 <dhun> walknode (Node [nodes]) = (walk nodes)
07:49:43 <mauke> dhun: what if there's more than one node?
07:50:09 <byorgey> And[y]: then you can recurse through that list, keeping track of the maximum so far as a parameter, and outputting only highly composite numbers
07:50:13 <dhun> it is called like this =concat (snd (mapAccumL walknode) )
07:50:24 <dhun> walk =concat (snd (mapAccumL walknode) )
07:50:52 <dhun> ok I scripted the integer
07:50:55 <byorgey> And[y]: I think trying to keep it as a list comprehension is probably too restrictive.
07:51:15 <dhun> but it should not matter for the point at hand
07:51:41 <Gracenotes> :O
07:52:06 <marcot> Hello, I'm having a problem with lazy IO.  I'm doing a interpreter for a bytecode language, and I've done the whole interpreter without side effects, and before its execution, it reads the input with getContents, so that only what's is needed is really asked for the user.
07:52:15 <And[y]> thanks, byorgey, i am trying to understand :>
07:52:42 <marcot> And in the end it prints the output with putStr.  My problem is that it's printing all output only after it read all the input, even when the output is available before.
07:53:09 <Botje> marcot: turn off buffering for stdout
07:53:16 <Paczesiowa> marcot: flushing?
07:53:32 <byorgey> marcot: hSetBuffering NoBuffering stdout
07:53:32 <marcot> Don't know, cause the core is functional.
07:53:35 <ray> this is your os's fault
07:53:40 <marcot> I'll try this.
07:53:42 <ray> turn off buffering
07:53:46 <Botje> marcot: hSetBuffering stdout NoBuffering
07:53:55 <byorgey> oh, did I get those backwards?
07:54:07 <ray> you got it right, the author got it backwards :)
07:54:17 <mauke> ray: buffering isn't in the OS
07:54:23 <byorgey> well, in any case, I think marcot probably gets the idea and can figure it out =)
07:54:37 <marcot> It worked.
07:54:37 <marcot> =)
07:54:38 <byorgey> ray: haha
07:54:53 <ray> the order of parameters does matter in haskell
07:54:58 <ray> mauke: where is it then?
07:54:59 <byorgey> indeed, it does.
07:55:19 <mauke> ray: in your program, specifically the IO library
07:55:42 <And[y]> byorgey: i understood, that your functions stores a list like (FactorCountOfN, N), ... but now again, if want to find only the HCNs i'm stuck at nearly the same point, coz i have to check every actual number against any number before, right? :/
07:56:09 <ray> whenever i did it in C, it seemed like a unix thing
07:56:31 <mauke> no, fflush is a standard C function
07:56:39 <marcot> byorgey: the parameter other is right.
07:56:51 <Botje> ray: that's just because the C runtime sets stdout to be line buffered
07:56:57 <Botje> see man stdout :)
07:57:01 <mauke> (also, there is no flush for file descriptors)
07:57:57 <ray> i see
07:59:33 <lysgaard> Hi, i'm thinking on doing some statistics on password with haskell. The problem is that i'm having some problems getting real life passwords. Admins won't just hand out their databases =/ Anyone know of a large password database, from a real world service, not just a hypothetica wordlist.
07:59:55 <byorgey> And[y]: try writing a function with this type:  findHCNs :: [(Int, Int)] -> Int -> [Int],  where the first parameter is the list of (FactorCount, N) pairs (you understood correctly), the second parameter is the biggest factor count you have seen so far, and the output is a list of HCNs
08:00:05 <wli> I use pwgen -generated passwords.
08:00:24 <ray> have you asked them to hand out just the password column, in a scrambled order?
08:00:25 <byorgey> And[y]: the key is that findHCNs can call itself recursively and hence update the second parameter whenever it sees a bigger factor count.
08:00:42 <byorgey> And[y]: that way you don't have to compare each number against every previous number, you just carry the maximum along.
08:00:54 <byorgey> And[y]: let me know if you want more hints. =)
08:01:24 <ray> i know people do research on real life passwords somehow, bruce schneier blogged about it once
08:01:30 <lysgaard> wli: Well, you're one of the smart guys, most people use things like "killer" or "123456"
08:01:46 <koeien> my password is hunter2
08:02:02 <ray> my password is ray123
08:02:18 <lysgaard> You're joking right?
08:02:31 <And[y]> ok, byorgey, i will try :)
08:02:36 <wind> Axman6: i still got haskeline problem when building ghc6.10.3 on freebsd7.2-rel althrough i installed 6.8.3 from port
08:02:36 * wli uses pwgen
08:02:38 <ray> the trick is, nobody believes me
08:02:44 <ray> so it stays safe
08:02:48 <Philonous> Regarding my question about global variables: a combination of ReaderT and records solves this quite elegantly
08:02:53 <lysgaard> Hehe :D
08:02:56 <Twey> Heheh
08:02:57 <Axman6> wind: yeah, no idea how to fix that
08:03:25 * roconnor uses radioactive decay of Cæsium-137 to select his password
08:03:30 <wind> Axman6: how did you installed 6.10.2?
08:03:35 * Twey uses Python
08:03:45 <byorgey> lysgaard: google for 'hunter2' =)
08:03:48 <Axman6> 6.10.2 compiles fine, 6.10.3 does not
08:04:04 <ray> i use @ghc to generate my passwords
08:05:32 <lysgaard> Well, i've found this article, mentioning a large phpbb password database leak, it's just that i can't find it anywhere: http://it.slashdot.org/article.pl?sid=09/02/07/1628234
08:06:19 <roderyk> maybe someone could help me, I'm trying to encode/decode gtk2hs Pixbufs to strings (to write/read from a file). I've been going over the different documentations, the closest I can think of is using pixbufGetPixels to get a MArray (PixbufData), which seems to be an instance of Storable Array; but I can't figure out what to do next; I can't seem to freeze it. (was thinking freeze >>= print)
08:06:28 <lysgaard> byorgey: Haha, ok, now i get it. Shame i didn't know that one, now i feel stupid
08:06:45 <roconnor> > sum [0..100000] > (10 :: Natural)
08:06:48 <lambdabot>   True
08:12:50 <EvilTerran> > 2 + undefined > (1 :: Natural)
08:12:51 <lambdabot>   True
08:13:12 <EvilTerran> !
08:13:48 <EvilTerran> Natural = lazy peano numberals, then
08:14:17 <ray> numberals!
08:14:28 <EvilTerran> numbers. numerals. whatever.
08:14:46 <Axman6> i prefer numberals
08:14:49 <skorpan> which package lets me do something like "hello %s" `lol` "there" => "hello there"?
08:15:00 <Axman6> @src Natural
08:15:01 <lambdabot> Source not found. Just what do you think you're doing Dave?
08:15:05 <mauke> let lol = printf
08:15:40 <EvilTerran> skorpan, i think there's a printf module that comes with ghc
08:15:51 <skorpan> oh
08:15:52 <And[y]> byorgey: can you give me some more hints? i dunno how to recursively check out the tuples :/
08:15:55 <mauke> skorpan: can I interest you in printf-mauke?
08:16:00 <Zao> @type Text.Printf.printf
08:16:02 <lambdabot> forall r. (PrintfType r) => String -> r
08:16:10 <EvilTerran> skorpan, Text.Printf
08:16:10 <skorpan> mauke: mayhap, what is it?
08:16:25 <mauke> basically a reimplementation of Text.Printf
08:16:33 <skorpan> is it any better?
08:16:34 <mauke> without the bugs, plus some new features
08:17:06 <mauke> but if all you want is %s, import Text.Printf and be done :-)
08:17:17 <skorpan> well then, i'm off! :) thanks though
08:20:00 <MartyIX> byorgey: I understand the formula and "where does it come from" but it seems to me that the haskell line you wrote doesn't corespond to the code in the document. And I tried two polynoms [2,2,3] and [1,2,5] and your line returns wrong result.
08:20:53 <MartyIX> [2,6,21, something]  and the right result should be: [2,6,17]
08:21:09 <MartyIX> [2,6,17 something]
08:21:14 <dino-> @seen dcoutts
08:21:14 <lambdabot> dcoutts is in #darcs, #gentoo-haskell, #ghc, #haskell, #haskell-in-depth, #haskell-overflow and #haskell-soc. I last heard dcoutts speak 49m 47s ago.
08:25:24 <byorgey> MartyIX: hmm, it's possible I wrote it wrong
08:25:27 <byorgey> let me check
08:27:07 <byorgey> MartyIX: I get [2,6,17] with the code that I wrote
08:27:15 <byorgey> are you sure you copied it right?
08:27:52 <byorgey> hm, wait, it should be longer than that shouldn't it
08:28:30 <byorgey> oh, I get it, you need a version of +++ that takes the length of the *longest* list
08:29:14 <byorgey> yeah, the code in that paper is only for infinite power series, which is why
08:30:43 <uzytkownik> @pl \x y -> f x == f y
08:30:43 <lambdabot> (. f) . (==) . f
08:30:50 <byorgey> MartyIX: well, I have to go, but if you replace 'zipWith (+)' with a version of zipWith that extends the result to the longer of the two lists (i.e. extending the shorter list with 0's) then it ought to work
08:31:17 <MartyIX> byorgey: thanks :)
08:32:12 <byorgey> And[y]: findHCNs [] _ = [];  findHCNs ((fCount, n):ns) maxSoFar | fCount <= maxSoFar = ?   | fCount > maxSoFar = ?
08:32:24 <byorgey> And[y]: can you figure out what goes in the ?
08:32:32 <byorgey> they should involve recursive calls to findHCNs.
08:32:36 <Athas> @hoogle a -> b -> (a,b)
08:32:37 <lambdabot> Data.Generics.Twins gmapAccumT :: Data d => (a -> d -> (a, d)) -> a -> d -> (a, d)
08:32:37 <lambdabot> Data.ByteString mapAccumL :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
08:32:37 <lambdabot> Data.ByteString mapAccumR :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
08:32:43 <byorgey> I need to go but maybe others can help if you need more hints.
08:35:52 <Athas> Are the combinators in Text.ParserCombinators.Parsec.Combinator documented anywhere?
08:36:11 <Botje> the parsec site has a listing
08:36:49 <skorpan> when i'm using printf, i'm getting this error "No instance for (IsChar [Char])", but to me it looks like that is the *only* instance of IsChar?
08:37:24 <Botje> skorpan: there's an instance for IsChar Char
08:37:27 <Botje> not for IsChar [Char]
08:37:32 <skorpan> oh, right
08:37:48 <skorpan> hm, so how the hell should i go about doing this...
08:37:55 <Athas> Thanks.
08:37:55 <And[y]> byorgey: maxSoFar is supposed to be the maximum count of divisors, found so far (for all checked numbers) ?
08:38:05 <byorgey> And[y]: right
08:38:12 <mauke> skorpan: what are you trying to do?
08:38:47 <skorpan> mauke: (printf args fp)
08:38:52 <skorpan> args is a string, fp is a string
08:39:04 <mauke> yeah, but what's the context?
08:39:31 <And[y]> great, but well, how do i tell haskell so, now? :)
08:39:57 <skorpan> mauke: i'm writing a little program which calls the right decompressor depending on file extensions
08:40:16 <skorpan> if it's .rar, it will execute (printf "unrar x %s" "hello.rar")
08:40:19 <mauke> skorpan: no, the type context
08:40:34 <skorpan> hunpFile :: FilePath -> IO ()
08:40:36 <And[y]> findHCNs ((fCount, n):ns) maxSoFar | fCount <= maxSoFar = maxSoFar | fCount > maxSoFar = fCount
08:40:37 <skorpan> if that's what you mean?
08:40:39 <And[y]> ? =)
08:40:46 <mauke> skorpan: that doesn't contain printf
08:41:09 <skorpan> unpack cmd (printf args fp) >>= waitForProcess >>= \x -> putStrLn $ "HELLO: " ++ show x
08:41:15 <skorpan> unpack cmd args = runProcess cmd args Nothing Nothing Nothing Nothing Nothing
08:41:23 <mauke> ah
08:41:33 <mauke> did you mean [printf args fp]?
08:41:46 <skorpan> ah, yes i think so
08:41:59 <skorpan> you're awesome mauke, thanks :)
08:43:36 <byorgey> And[y]: the function needs to return a list of HCNs.
08:43:38 <And[y]> byorgey: findHCNs n = filterHCNs possibleHCNs n, where filterHCNs is findHCNs from above ..
08:43:54 <And[y]> yeah, it gives out type mismatch ;/
08:43:57 <byorgey> And[y]: no, that doesn't work, you need to do them at the same time
08:44:26 <And[y]> did i complete your function, correctly? :>
08:44:44 <byorgey> findHCNs ((fCount, n):ns) maxSoFar | fCount <= maxSoFar = findHCNs ns maxSoFar  -- n isn't a HCN, and the maxSoFar hasn't changed
08:44:48 <byorgey> there's the first case
08:44:58 <dcoutts> dino-: pong
08:45:18 <dino-> dcoutts: Hey, I submitted a patch to the list for that cabal-install --global
08:45:29 <dcoutts> dino-: great
08:45:40 <byorgey> And[y]: in the other case, n *is* a HCN, so you want to return a list which starts with n, and the rest of the list is computed by a recursive call to findHCNs, with an updated maxSoFar as a parameter
08:45:45 <eden> Hi there. I was wondering if anybody knows a way to make monads-fd play nice with mtl?
08:47:12 <dcoutts> eden: use one or the other, not both.
08:47:14 <And[y]> byorgey: so this is second case: |  fCount > maxSoFar = findHCNs ns fCount ? :>
08:47:35 <byorgey> And[y]: close!  but you just threw away n!
08:47:42 <And[y]> oh noooz :D
08:47:47 <byorgey> but you're correct in passing fCount as the second parameter to the recursive call to findHCNs
08:47:57 <And[y]> so lemme think ...
08:48:01 <dhun> I am still working on my conversion tool converting wiki to latex, which produces the pdf I already posted, but the code I wrote is an ugly mess, I tried to rewrite the function treeToLaTeX in a readble way, but I am not sure if I managed to do that especially since I am not very experienced in Haskell, it would be nice if you could give me some hints on how to go on refactoring http://de.wikibooks.org/wiki/Benutzer:Dirk_Huenniger/haskell
08:48:07 <And[y]> findHCNs (n:ns) fCount
08:48:08 <And[y]> ? =)
08:48:09 <byorgey> And[y]: remember, you are producing a list as output
08:48:11 <dcoutts> eden: since they're more or less implementations of the same stuff, and use the same module names, so you cannot use them both simultaneously.
08:48:15 <byorgey> not quite
08:48:26 <And[y]> now thats bad :D
08:49:36 <eden> dcoutts: I noticed that they seem pretty similar. Is monads-fd a complete drop-in replacement for mtl then?
08:50:24 <dcoutts> eden: I'm not absolutely sure, it might have some changes/improvements
08:50:35 <And[y]> i thought, that i would add n to list by specifying (n:ns) ... but now i dunno how to do it :D
08:50:39 <dcoutts> eden: there are several mtl replacement/improvement packages around
08:50:56 <michaeldever> silly question yet again, :D, how do I install from a local cabal file?
08:51:11 <dcoutts> michaeldever: cd the_package_dir; cabal install
08:51:36 <dcoutts> michaeldever: see also cabal install --help
08:51:37 <byorgey> And[y]: (n:ns) adds n back to the list which is input to the recursive call, but you want to add n to the list which is the *result* of the function
08:51:55 <Apocalisp> > let perms xs = [x:ps | x <- xs, ps <- perms (xs\\[x])] in perms "unrar"
08:51:56 <lambdabot>   []
08:51:58 <michaeldever> :), you'd think i'd have tried that first
08:52:07 <And[y]> byorgey: that sound reasonable ... is there something like result in haskell? :D
08:52:37 <byorgey> And[y]: whatever is on the right hand side of the = is the result.
08:52:43 <raimo> how do I catch exception when using !! operator accessing non-existing item?
08:53:12 <byorgey> And[y]: so if you just had  | fCount > maxSoFar = findHCNs ns fCount,  then the result will be whatever the result of  findHCNs ns fCount is
08:53:18 <mauke> raimo: basically, you don't
08:53:29 <byorgey> that result will be a list, and you want to add 'n' to the front of it
08:54:04 <raimo> mauke: so what's the recommended approach to check for valid index?
08:54:11 <And[y]> (n:findHCNs ns fCount) ... at least gives out no error :>
08:54:27 <eden> dcoutts: Yeah. The problem I'm really having is that whenever I cabal install some package, mtl usually gets recompiled, and then I have to ghc-pkg unregister --force mtl, to make everything work again. It's really annoying. Is there a way of avoiding the mtl recompile?
08:54:27 <byorgey> And[y]: right!!
08:54:36 <mauke> raimo: case drop n of [] -> ...; x : _ -> ...
08:54:56 <And[y]> ok, then one last dump question, plz: how do i call it with possibleHCNs now? =)
08:55:02 <And[y]> findHCNs possibleHCNs 10
08:55:05 <ClaudiusMaximus> > drop (-1) [1,2,3]
08:55:07 <lambdabot>   [1,2,3]
08:55:14 <And[y]> says non matching types again
08:55:19 <byorgey> And[y]: I'm not sure what you're asking.  What's possibleHCNs?
08:55:40 <And[y]> its the list with tuples, i wanted to provide to findHCNs
08:56:24 <And[y]> possibleHCNs n = map (\x -> (divisorCount x, x)) [1..n]
08:56:41 <byorgey> And[y]: oh, what is the type of possibleHCNs?
08:56:54 <byorgey> and what is the type of divisorCount?
08:57:30 <byorgey> note I used 'Int' in the type I gave for findHCNs but if you are using 'Integer' you should change that
08:58:14 <malouin> some way to simplify this with fmap and friends?:
08:58:14 <malouin>   let maybedbset k Nothing = return ()
08:58:14 <malouin>       maybedbset k (Just v) = dbset k v
08:58:24 <dcoutts> eden: there will be some reason that mtl is getting recompiled, when you next install something that uses mtl, use --dry-run -v and see what is getting changed which should give a hint why
08:58:41 <And[y]> possibleHCNs :: Int -> [Int] ... divisors :: Int -> [Int]
08:58:43 <MartyIX> http://pastebin.com/d1a5c4499 - how can I make it work? I just need a condition with respect to "n"
08:58:59 <And[y]> its divisorCount, thought
08:59:00 <And[y]> -t
08:59:24 <mauke> MartyIX: what's the error?
08:59:32 <And[y]> sry, im dump, here it is: divisorCount :: Int -> Int
08:59:49 <MartyIX> mauke: wrong type .. i think i see the error yet
08:59:59 <And[y]> and possibleHCNs :: Int -> [(Int,Int)] ofc :D
09:00:50 <MartyIX> mauke: http://pastebin.com/d200a2c00 - and error is:
09:00:51 <MartyIX> ERROR file:.\martyix.hs:17 - Cannot justify constraints in explicitly typed binding
09:00:51 <MartyIX> *** Expression    : derivative
09:00:51 <MartyIX> *** Type          : Num a => a -> [a] -> [a]
09:00:51 <MartyIX> *** Given context : Num a
09:00:51 <MartyIX> *** Constraints   : (Ord a, Enum a)
09:01:02 <And[y]> findHCNs(possibleHCNs(10)) Cannot find "show" function for:
09:01:02 <And[y]> ->
09:01:19 <And[y]> Expression : findHCNs (possibleHCNs 10) -> Of type    : Int -> [Int]
09:01:49 <MartyIX> mauke: so integer for first parameter?
09:02:43 <mauke> MartyIX: yeah, might be better
09:03:13 <Gracenotes> :O
09:03:21 <And[y]> 8o
09:03:26 <skorpan> i love that indentation of the signature
09:04:17 <BMeph> Hugs - ewwwww! ;p
09:05:09 <And[y]> byorgey: nvm, i got it. thank you a thousand times for your great assistance :)
09:05:29 <MartyIX> mauke: http://pastebin.com/d7b66ecc0 -- still error :(
09:05:45 <eden> dcoutts: Okay. Having tried that, all it tells me is that mtl is a new package and will be installed. Doesn't really give me a clue about how to stop it happening.
09:05:55 <mauke> MartyIX: yeah, that's because of [1,2..]
09:06:07 <dcoutts> eden: if a package needs mtl, there's not a lot you can do about that.
09:06:13 <mauke> MartyIX: try (Num a, Enum a) => ...
09:06:21 <skorpan> pro-tip: drop 1 == tail
09:06:39 <dcoutts> eden: I thought you were talking about it upgrading mtl unnecessarily. There are hundreds of packages that depend on mtl.
09:07:05 <koeien> > tail []
09:07:07 <lambdabot>   * Exception: Prelude.tail: empty list
09:07:08 <koeien> > drop 1 []
09:07:09 <MartyIX> mauke: it works now :), but why do I have to add Enum a?
09:07:10 <lambdabot>   []
09:08:04 <mauke> MartyIX: because of the [1,2..]
09:08:35 <skorpan> koeien: i stand corrected
09:09:20 <skorpan> how do i make GHC show me all warnings when compiling my program?
09:09:28 <skorpan> oh, -Wall
09:10:16 <Gracenotes> -Wailing -Wall
09:11:00 <skorpan> hehe
09:13:15 <tromp> > exp 1
09:13:16 <lambdabot>   2.718281828459045
09:18:18 <eden> dcoutts: There is another package I'm trying out (yi, I know it's alpha) which breaks when I try to use mtl instead of monads-fd, so I guess I'm stuffed.
09:18:37 <dcoutts> eden: there's no problem with having both installed at once
09:19:07 <dcoutts> eden: the only restriction is that any single program/package can only depend on one of them
09:21:24 <eden> dcoutts: Ah. So there is some way of telling my programs which one to use?
09:21:47 <dcoutts> eden: have you used the Cabal stuff yet?
09:23:00 <dcoutts> eden: all existing packages use it, eg yi, if you're writing your own package you can use it too.
09:24:09 <dcoutts> eden: if you're just doing something small and want to say use mtl rather than monads-fd, then use ghc-pkg hide --user monads-fd
09:24:27 <dcoutts> eden: and possibly ghc-pkg expose --user mtl
09:24:51 <dcoutts> that changes the defaults of what is "exposed", which is what gets used when you run ghc --make
09:25:19 <dcoutts> eden: where as for all existing packages, they already specify in their .cabal files if they use mtl or something else.
09:27:02 <eden> dcoutts: That sounds like the sort of thing I want. Let me just give a couple of things a try...
09:27:39 <dcoutts> eden: you said earlier that you were building yi, that uses Cabal of course.
09:29:48 <eden> dcoutts: hiding monads-fd lets my proram use mtl, and yi continues to work, so yeah, that seems to do the trick. I shall have to learn some more about Cabal. Thanks a lot for your time and help.
09:29:55 <Athas> How would I, in Parsec, parse an alphanumeric character sequence starting with an uppercase letter?
09:30:18 <Athas> Specifically, how do I stop upper/lower from consuming a character?
09:30:28 <mauke> uh, what?
09:30:32 <Athas> I just need them for the discrimination.
09:30:38 <ziman> (:) <$> satisfy isUpper <*> many anyChar  -- for example
09:30:49 <dcoutts> eden: so the hide/expose thing only affects when you run ghc --make. Building things with cabal are not affected by what is exposed/hidden because it specifies all deps explcitly.
09:31:27 <Athas> I suppose that's acceptable.  I just don't like satisfy too much.
09:32:26 <ziman> satisfy isUpper is also known as upper, according to parsec's doc
09:33:08 <Athas> Yeah, satisfy wasn't what made the difference.
09:33:29 <ziman> liftM2 upper alphaNum    -- cannot be shorter ;)
09:33:33 <ziman> liftM2 (:) upper alphaNum    -- cannot be shorter ;)
09:33:34 <Athas> My code originally looked like upper *> many alphaNum, I hoped I wouldn't have to use <$> myself.
09:33:44 * Badger goes to live in Athas.
09:34:11 <ziman> i'm missing many, too :\
09:34:30 <Gracenotes> -- can be shorter :O
09:34:35 <eden> dcoutts: My quick test used runghc, but I guess the same thing applies. I'd always wondered what would happen with module name collisions, and how they could be resolved. I suppose I know the answer now.
09:35:42 <dcoutts> eden: right and there are also command line flags to override the current defaults. -package foo -hide-package bar (and even -hide-all-packages which is what cabal uses, to start from a clean environment)
09:36:09 <ziman> or you can use the swine-flu operator :) upper <^(:)^> many alphaNum
09:36:13 <balazsbela> Hello. Could you please help me out
09:36:18 <balazsbela> I want to clear the screen in haskell
09:36:34 <balazsbela> In linux it works with putStr ("\ESC[2J")
09:36:45 <balazsbela> a terminal escape code, but this doesn't work under windows
09:36:58 <mauke> please stop wanting to clear the screen
09:37:00 <mauke> it's annoying
09:37:10 <balazsbela> hey, it's the first time for me :P
09:37:13 <balazsbela> and I need to do it :P
09:37:17 <mauke> why?
09:37:36 <balazsbela> because I want to port code to windows
09:37:43 <balazsbela> it's a game of life implementation
09:38:06 <The-Kenny> Use a library like curses.
09:38:14 <balazsbela> oh common
09:38:18 <balazsbela> it's for windows
09:38:23 <mauke> so?
09:38:23 <balazsbela> this can't be that hard
09:38:32 <mauke> it's windows. of course it's hard
09:38:42 <thomastc> it's for windows, of course --- mauke, get out of my head
09:39:31 <eden> dcoutts: Finding the right GHC options, due to its sheer size, has been the only downside I've encountered while learning haskell. It's kinda cool that people here are prepared to help.
09:39:32 <Zao> You're all windophobes :P
09:39:40 <balazsbela> look
09:39:44 <balazsbela> I only need one simple command
09:39:44 <thomastc> balazsbela: http://support.microsoft.com/kb/99261 might be useful?
09:40:04 <dcoutts> eden: yeah there are a lot of options, most the time you don't need more than ghc --make
09:40:11 <balazsbela> I know, but how do I call system in haskell ?
09:40:17 <Botje> System.IO
09:40:20 <mauke> @hoogle system
09:40:20 <lambdabot> System.Cmd system :: String -> IO ExitCode
09:40:20 <lambdabot> module Distribution.System
09:40:20 <lambdabot> package system-inotify
09:40:53 <MyCatVerbs> You want the System.Cmd one.
09:42:33 <Zao> Someone ought to wrap the Console API on Windows, shouldn't be horribly hard.
09:42:52 <Zao> Or use a proper more portable graphics API, of course.
09:42:59 <thomastc> like curses
09:43:10 <Zao> thomastc: Now you're just trolling.
09:43:16 <raimo> how to do function overloading in haskell? I would like to define two instances of the same function where the second one would call the first with value extracted from the second's argument
09:43:31 <thomastc> Zao: doesn't it run on windows, then?
09:43:50 <thomastc> I was being serious
09:43:59 <Zao> thomastc: There are some quite broken implementations of it.
09:44:07 <thomastc> oh, I'm wrong, my apologies
09:44:17 <thomastc> strange, though...
09:44:20 <mauke> pdcurses?
09:44:29 <Zao> The Windows console subsystem is a bit too different to provide the level of functionality a curses application expects.
09:44:48 <Zao> mauke: Needs an X server, doesn't it?
09:44:56 <mauke> whoa. really?
09:45:06 <Zao> http://gnuwin32.sourceforge.net/packages/pdcurses.htm <- that insinuates it.
09:45:09 <eden> dcoutts: Thanks a lot for your help. I guess I can get back to the hacking...
09:45:20 <dcoutts> eden: have fun! :-)
09:45:42 <Zao> Might just be a silly description though.
09:45:46 <eden> dcoutts: I'm sure I will.
09:45:58 <mauke> Zao: I thought it runs on Win32 as well as X11
09:46:25 <Zao> mauke: In any way, both the curses packages on Hackage depend on unix.
09:47:24 <Zao> If I were to do some simple graphics, I'd go for either the Haskell platform and OpenGL, or the new and shiny OpenGLraw one.
09:49:56 <raimo> how should I design my code if I would like to do something like this http://haskell.pastebin.com/m3b1d96c2 ?
09:50:18 <skorpan> @pl \a b c -> isJust $ match a b c
09:50:18 <lambdabot> ((isJust .) .) . match
09:50:28 <raimo> this isn't obviously working as I have two function with the same name with different type of parameters
09:50:28 <skorpan> hm... but why?
09:52:00 <raimo> skorpan: if you asked me then the answer is I would like to ease the use
09:56:23 <skorpan> raimo: i was talking to myself
09:57:34 <malouin> does function :: b -> (a -> b) ; function x = (\_ -> x) have a name?
09:57:51 <bd_> :t const
09:57:52 <lambdabot> forall a b. a -> b -> a
09:57:58 <bd_> yes :)
09:58:05 <malouin> great
09:58:20 <malouin> thanks bd_
10:01:33 <jeff_s_> I hate it when people write all over library books!!! GRRR!
10:04:07 <monochrom> I like it. They write funny things.
10:04:32 <raimo> hmm how can I access single data member of some struct without using pattern matching?
10:04:32 <mauke> DESU DESU DESU DESU DESU DESU DESU DESU DESU DESU DESU DESU DESU DESU
10:04:45 <monochrom> I go like "hahaha you need to explain that to yourself? hahaha dumb!"
10:04:46 <mauke> raimo: use the selector function
10:04:48 <Axman6> raimo: 'struct'? :(
10:05:11 <raimo> Axman6: what's the correct name for the thing you create with data blaa = blaa blaa?
10:05:20 <monochrom> data type.
10:05:33 <raimo> ok
10:05:43 <mauke> oh, I thought you mean records
10:06:11 <Axman6> i think he may want records anyway
10:06:33 <raimo> I actually want to achieve something like this http://haskell.pastebin.com/m3b1d96c2
10:06:40 <raimo> do you have any idea?
10:08:03 <Axman6> i don't see anything wrong with that code
10:08:16 <dhun> can one compile Haskell codes into some platform independent format?
10:08:28 <mauke> (yes, with "cat")
10:08:29 <Axman6> not that i know of
10:08:34 <Axman6> heh
10:08:52 <Axman6> and then JIT compile it with "ghc" >_>
10:09:04 <paper_cc> dhun: GHC core (with GHC), GRIN (with LHC or UHC), LLVM (with UHC)
10:09:14 <dhun> ???
10:09:15 <monochrom> "runghc myfile.hs" does some kind of JIT :)
10:09:17 <mauke> no, you use the virtual machine called runghc
10:09:29 <paper_cc> dhun: and also Yhc core
10:09:41 <MyCatVerbs> dhun: (They're being silly.) No, not practically. If you really really need that feature for some application, you're going to want to use another language.
10:09:47 <ehird> Is there any way to make a typeclass so that you can patternmatch on the constructors of members of that typeclass?
10:09:48 <ehird> (Say yes.)
10:10:02 <ehird> e.g. foo :: (A x) => x -> String; foo (Blah s) = s; foo _ = "hello"
10:10:08 <MyCatVerbs> ehird: you can get real close with view patterns.
10:10:13 <ehird> where class A x; data Baba = Blah String; instance A Baba
10:10:15 <ehird> MyCatVerbs: Oh?
10:10:30 <monochrom> Don't call people silly just because they have alternative interpretations of the question. The question is ambiguous and we all know that.
10:10:39 <dhun> the problem is that I don't have windows, but some people might want to run the Haskell program I am writing on windows
10:11:08 <mauke> dhun: then they have to get a haskell compiler
10:11:11 <MyCatVerbs> monochrom: I'm sorry, but you're talking about compiler intermediates. Not really anywhere near a practical solution at the moment.
10:11:15 <dhun> ok
10:11:19 <Gracenotes> D:
10:11:23 <dhun> at least there is a compiler
10:11:35 <mauke> how does that make it better?
10:11:46 <monochrom> I am talking about "runghc myfile.hs".
10:11:59 <MyCatVerbs> monochrom: Oh, my bad.
10:12:52 <MyCatVerbs> dhun: Some of the libraries on Hackage and many of the libraries bundled with GHC are portable across Windows and most Unixes, and work just about the same everywhere.
10:12:58 <monochrom> I hate telepathic people. They don't read. And they think they know what other people mean by their questions.
10:13:40 <dhun> ok so everything is going to work fine
10:14:23 * araujo tried to read monochrom's mind
10:14:26 <jeff_s_> mono - they DO know what other people mean!
10:14:42 <MyCatVerbs> dhun: That's just about your best bet. Whether it'll suffice depends on what you need to do. Plus, you won't be able to test it. But hey, I'm sure you'll be able to find at least one person with a Windows box who'll be happy to test your releases, though?
10:15:24 <dino-> raimo: It may help to talk about what you're trying to achieve with that code.
10:15:51 <paper_cc> raimo: what's wrong with your code? (except that the SuperheroResult type is not defined)
10:16:14 <dino-> paper_cc: It still doesn't build because of the types.
10:17:20 <monochrom> should use two different names for those two functions.
10:17:29 <paper_cc> monochrom: ah
10:17:54 <monochrom> @slap Object Obfuscation Pomposity
10:17:54 * lambdabot pokes Object Obfuscation Pomposity in the eye
10:18:58 <jeff_s_> dhun - the windows 7 RC is free to use until June of next year, and it might work in something like kqemu
10:19:35 <paper_cc> raimo: do you /really/ need identical names for those functions?
10:19:56 <dino-> Haskell doesn't have the C++ overloading style where functions of different types have the same name.
10:20:19 <dhun> ok maybe I will try
10:20:29 <ehird> 18:10 MyCatVerbs: ehird: you can get real close with view patterns. ← care to elaborate? :)
10:20:33 <dhun> but the idea of a emulator is good
10:20:47 <dhun> maybe I can compile in an emulator
10:20:55 <jeff_s_> vmware player is free but I think it's windows only
10:21:12 <dino-> VirtualBox
10:21:39 <jeff_s_> oh, cool. I didn't know about virtualbox
10:22:05 <paper_cc> jeff_s_: VMware also works on linux x86[_64]
10:22:06 <byorgey> ehird: do you really want to dispatch on *constructors* of the types in that class, or would it be enough to just dispatch on the type?
10:22:20 <byorgey> ehird: oleg has some code showing how to do type dispatch, IIRC
10:22:37 <ehird> byorgey: Constructors. Imagine a command parser, where the command set can be expanded by adding an instance; commands are like CommandName arg1 arg2.
10:22:54 <ehird> I'd like to special-case some of these commands in the base set, while still having my function be of the class type.
10:23:23 <byorgey> ehird: why do you need a class?  why not just have a data type with a constructor for each command?
10:23:28 <jeff_s_> Oh I see, vmware player is for linux too.
10:23:34 <ehird> byorgey: Because it can be extended.
10:23:39 <jmcarthur> raimo: whether you need it or not, here is how you could do it http://haskell.pastebin.com/m4eec3022
10:23:56 <byorgey> ehird: data types can be extended too.  but I guess you mean it's important that it can be extended in an open way (i.e. in another module)?
10:24:05 <ehird> byorgey: right.
10:24:39 <byorgey> ehird: maybe check out what xmonad does with Messages, I think it's similar to what you're trying to do.
10:24:45 <byorgey> ehird: let me find you a link...
10:24:49 <ehird> byorgey: thanks
10:25:14 <ehird> the basic thing is that the server is going to dispatch on these core commands with pattern matching, then outsource the processing of anything not matched to a plugin
10:25:26 <ehird> so it's quite important to be able to do it like this or at least similarly
10:25:45 <byorgey> ehird: http://haskell.org/haskellwiki/Xmonad/Guided_tour_of_the_xmonad_source/Core.hs#Messages
10:25:56 <byorgey> ehird: right, I think you can do that using this pattern
10:26:24 <ehird> byorgey: ugh, it depends on typeable
10:26:29 <byorgey> ehird: using the declarations shown in that link, you can then say things like    foo m | Constructor blah <- fromMessage m ...
10:26:40 <byorgey> ehird: well, what did you expect? =)
10:26:45 <byorgey> you're doing type dispatch.
10:26:47 <ehird> byorgey: that'd get verbose with a lot of matches
10:26:48 <ehird> hrmm
10:26:55 <ehird> byorgey: yeah, well, i'd be happier with a simpler solution too
10:27:03 <ehird> but (Command "somestring" ["a","b","c"]) sucks.
10:27:27 <byorgey> ehird: I agree re: the second.
10:27:44 <byorgey> well, that's the best solution I know of, maybe someone else can come up with something simpler
10:28:53 <paper_cc> ehird: Control.Exception (the one from 6.10) creates a whole hierachy of exception types this way
10:29:04 <ehird> paper_cc: mm
10:29:53 <paper_cc> ehird: (some machinery is in extensible-exceptions)
10:30:39 <paper_cc> ehird: (i'm wrong, extensible-exceptions just re-exports the new Control.Exception module)
10:31:28 <ehird> i might do something exception-like, but...
10:31:37 <ehird> i'd love to be able to just do "f (Constructor a) = ..."
10:32:28 <michaeldever> hey all I'm having a problem with the ActionClass of gtk2hs, could someone have a look and point me in maybe the right direction?
10:32:33 <michaeldever> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5846#a5846
10:33:14 <paper_cc> ehird: maybe you can use something like catch?
10:33:34 <ehird> paper_cc: that doesn't work, my function must be polymorphic
10:34:19 <paper_cc> ehird: that is, the Constructor part must be polymorphic? o_O
10:34:27 <ehird> paper_cc: Here's the basic idea:
10:34:57 <ehird> handle :: Command a => a -> String; handle (ConstructorFromSomeSpecificInstance s) = s; handle (AnotherOneOfThem s t) = s ++ t; handle x = giveItToAPlugin x
10:34:58 <ehird> Y'see?
10:35:19 <paper_cc> ehird: aha
10:35:26 <pusika> hi
10:35:48 * paper_cc tries to invent something of comparable elegance
10:35:54 <byorgey> ehird: I really think the solution with Typeable and an existential wrapper is not all that heavyweight.  It just adds a tiny bit of boilerplate.
10:35:59 <pchiusano> hello
10:36:16 <jeff_s_> hi
10:36:18 <ehird> byorgey: Yeah, but (Command "abc" ["def","ghi"]) is boilerplate too, and less type trickery.
10:36:22 <ehird> The point is avoiding boilerplate :-)
10:36:34 <paper_cc> ehird: TH it?
10:36:40 <byorgey> ehird: but (Command "abc" ...) is also utterly inelegant.
10:36:49 <ehird> byorgey: so is type trickery :)
10:36:51 <ehird> paper_cc: Possibly
10:36:58 <byorgey> I guess that depends on your point of view =)
10:37:13 <byorgey> michaeldever: which module is ActionClass from?
10:39:29 <paper_cc> ehird: you could write something like your proposed code if TH patterns splices were implemented
10:39:37 <ehird> harumph :)
10:39:54 <paper_cc> (well, ViewPatterns splices -_- )
10:40:05 <Saizan_> you could use quasiquoting though
10:40:10 <Saizan_> those are available in patterns
10:40:21 <Saizan_> (not sure if they apply here)
10:40:59 <Heffalump> I thought TH pattern splices are there now in a restricted form?
10:41:43 <paper_cc> Heffalump: oh?
10:42:07 <paper_cc> , [$ty|toException]
10:42:08 <lunabot>  luna: lexical error in string/character literal at end of input
10:42:13 <paper_cc> grr
10:42:20 <paper_cc> , [$ty| toException |]
10:42:25 <lunabot>  luna: Exception when trying to run compile-time code:
10:42:38 * paper_cc invents a check for base-4
10:42:47 <paper_cc> , [$ty| permutations |]
10:42:50 <Heffalump> paper_cc: hmm, perhaps it was just type splices
10:42:50 <lunabot>  forall a . [] a -> [] ([] a)
10:43:05 <paper_cc> , f $(foobar) = "blah"
10:43:06 <lunabot>  luna: parse error on input `='
10:43:26 <paper_cc> , let f $(foobar) = "blah" in f 0
10:43:27 <lunabot>  luna: Parse error in pattern
10:43:47 <mauke> how can I get http://portal.acm.org/citation.cfm?id=512931 ?
10:44:19 <jeff_s_> academic deification
10:44:36 <roconnor> mauke: set up tor to only use exit nodes ending in .edu
10:44:42 <liquidsnack> mauke: I can dcc it to you
10:44:44 <mauke> I don't have tor
10:44:52 <mauke> pumpkin: oh, nice
10:45:06 <lunarisbluemoon> Hello #haskell
10:45:45 <mauke> someone needs to grab all the acm papers and make a torrent
10:45:54 <lunarisbluemoon> I've a function iterateN which works like iterate but only returns the final answer. Its type is iterateN :: Int32 -> (a -> a) -> a -> a.
10:45:57 <pumpkin> mauke: my client claims to be sending it
10:45:59 <jeff_s_> "roconnor: mauke: set up tor to only use exit nodes ending in .edu" <------ genious. I'm not kidding either
10:46:02 <pumpkin> mauke: but I'm never sure with dcc
10:46:27 <mauke> DCC SEND from pumpkin [1.1.1.1 port 0]
10:46:30 <mauke> unlikely :-|
10:46:34 <pumpkin> lol
10:46:38 <pumpkin> I'll dropbox it
10:46:43 <lunarisbluemoon> Long story short: can I rewrite something like "iterateN n (map f) xs" to "map (iterateN n f) xs" using rewrite rules?
10:46:57 <lunarisbluemoon> I can't get it to work in GHC (6.10).
10:47:08 <pumpkin> mauke: http://files.getdropbox.com/u/361503/p41-pratt.pdf
10:47:37 <paper_cc> ehird: it seems like you can write something like  handle (fromEvent -> Just (ConstructorFromSomeSpecificInstance s)) = s
10:47:47 <roconnor> jeff_s_: that's why I'm going to be a doctor of philosophy
10:47:49 <ehird> possibl
10:47:50 <ehird> y
10:47:53 <ehird> it's more nuanced though
10:47:59 <paper_cc> ehird: where fromEvent is a fromException-like thing
10:48:00 <mauke> pumpkin: got it!
10:48:41 <pumpkin> :)
10:48:59 <zooko> Howdy, pumpkin.
10:49:03 <jeff_s_> roconnor - good luck with that
10:49:04 <pumpkin> allo zooko
10:50:35 <lunarisbluemoon> Should I try #ghc (assuming it exists xD)?
10:51:09 <pumpkin> yup
10:51:25 <jeffwheeler> Installing a library with profiling enabled won't affect its normal execution, will it?
10:51:41 <Axman6> no
10:51:44 * roconnor prepares to take his thesis draft to Kinkos
10:51:49 <jeffwheeler> Axman6: great, thanks
10:51:50 <skorpan> if it did, that would kind of ruin the point, wouldn't it?
10:52:02 <pumpkin> it actually compiles everything twice
10:52:08 <pumpkin> you get .o and .p_o
10:52:12 <ehird> yay, I came up with a nice solution
10:52:19 <jeffwheeler> skorpan: I feared it might slow stuff down somehow :P
10:53:37 <michaeldever> byorgey: ActionMenuToolbar
10:54:32 <michaeldever> ah, i think I see what i might be doing wrong
10:57:10 <michaeldever> actually, no i don't see what I'm doing wrong :)
11:08:41 <ehird> What's the best way to represent, in parsec, to represent (ab)*? That is, (b; a `sepBy` b), but optional.
11:08:59 <mauke> many (a *> b)
11:09:15 <ehird> @src (*>)
11:09:15 <lambdabot> (*>) = liftA2 (const id)
11:09:22 <ehird> @hoogle (*>)
11:09:22 <lambdabot> Control.Applicative (*>) :: Applicative f => f a -> f b -> f b
11:09:22 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
11:09:22 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
11:09:27 <ehird> mauke: OK, then. So sepBy isn't really useful?
11:09:43 <mauke> I wouldn't use it for this task
11:09:48 <ehird> Thanks.
11:09:57 <ehird> Is Text.ParserCombinators.Parsec or Text.Parsec the modern one?
11:10:14 <mauke> I only know the former, so I'd assume Text.Parsec is moderner
11:10:37 <ehird> I seem to remember someone saying Text.Parsec was the original name.
11:10:40 <MyCatVerbs> Text.ParserCombinators.Parsec is Parsec2's name.
11:10:40 <ehird> But it seems more modern :P
11:10:43 <ehird> Right
11:10:51 <ehird>     It could refer to either `Text.ParserCombinators.Parsec.<|>', imported from Text.ParserCombinators.Parsec at Network/Haver/Parser.hs:3:0-35
11:10:52 <ehird>                           or `Control.Applicative.<|>', imported from Control.Applicative at Network/Haver/Parser.hs:4:0-25
11:10:56 <ehird> That unqualified import was a mistake.
11:10:58 <ehird> :-)
11:11:41 <ehird> mauke: doesn't work; it's (foo *> char '\t')
11:11:45 <ehird> and foo is a Parser String
11:11:55 <ehird> but that expr is a Parser Char
11:12:10 <ehird> wait.
11:12:17 <ehird> many (char '\t' >> foo)
11:12:18 <ehird> duh :)
11:12:23 <pumpkin> @type [(>>), (*>)
11:12:24 <lambdabot> parse error (possibly incorrect indentation)
11:12:26 <pumpkin> @type [(>>), (*>)]
11:12:27 <mauke> should the \t come first or last?
11:12:28 <lambdabot> forall (m :: * -> *) a b. (Monad m, Applicative m) => [m a -> m b -> m b]
11:12:35 <ehird> mauke: foo, foo\tbar, foo\tbar\tbaz
11:12:37 <ehird> it's >> :P
11:12:47 <mauke> *> is >>
11:12:53 <pumpkin> hmm
11:12:56 <pumpkin> am I still online?
11:13:08 <malouin> pumpkin: I think so
11:13:14 <ehird> mauke: then (char '\t' *> foo)
11:13:16 <ehird> but might as well use >>
11:13:18 <mauke> ehird: that looks more like a(ba)*, not (ab)*
11:13:25 <ehird> ah
11:13:28 <ehird> you're right
11:13:34 <ehird> mauke: er, but isn't many 0-or-more?
11:13:37 <mauke> yes
11:13:48 <ehird> mauke: so if it's just "foo", then it should work?
11:13:54 <mauke> huh?
11:14:05 <ehird> i don't get why the first a is mandatory
11:14:25 <mauke> your examples were foo, foo\tbar, foo\tbar\tbaz
11:14:32 <malouin> So if handle :: Exception e => (e -> IO a) -> IO a -> IO a , how do I handle an exception that could be thrown by a MyReaderTIO action?
11:14:38 <mauke> all of those have a leading 'foo'
11:15:01 <ehird> mauke: terminology mixup
11:15:04 <ehird> foo is from the previous parse
11:15:17 <ehird> mauke: what I want to parse is:
11:15:23 <ehird> "", "\tblah", "\tblah\tfoo"
11:15:31 <ehird> which sounds like many (char '\t' >> stuff) to me
11:15:35 <mauke> yep
11:15:40 <mauke> everything's ok :-)
11:16:04 <ehird> yeah, now i just gotsa make it work :)
11:16:23 <ehird> ah, I see what's wrong
11:16:33 <ehird> it's saying 'expected "\t"' because I do a fail afterwards
11:16:42 <ehird> even though the fail is totally unrelated to wanting a \t
11:16:45 <ehird> wonder how I fix that
11:20:19 <malouin> is it even possible to catch IO exceptions inside a transformed IO monad?
11:20:40 <leftbench> Hi.  I'm just starting to learn the language.  I'm wondering about the encoding for the "Char" type.  Does this type represent a Unicode character, or just a standard ASCII character like in C?
11:20:59 <Zao> leftbench: Char is an unicode codepoint.
11:21:01 <ehird> leftbench: 32-bit unicode
11:21:06 <ehird> leftbench: but the standard io library does not do unicode
11:21:10 <ehird> although a new one which does just got committed
11:21:16 <ehird> for unicode IO see utf8-strings library
11:21:17 <Zao> ehird: For GHC, that is.
11:21:23 <ehird> Zao: Well, yes.
11:21:27 <ehird> Zao: Who are you, a hugs user? ;-)
11:21:29 <Zao> There's also Data.Text for conversion.
11:21:37 <monochrom> I am a gofer user.
11:21:44 <pchiusano> ehird: is it 32-bit for all haskell compilers?
11:21:49 <pchiusano> or just ghc?
11:21:56 <ehird> Haskell 98 specifies so.
11:21:58 <ehird> So, yes.
11:22:02 <Zao> pchiusano: It's big enough to hold a codepoint, I believe.
11:22:07 <Zao> So, at least 21 bits.
11:22:07 <ehird> monochrom: lame, I use Miranda; you just can't pony up the cash for it
11:22:10 <ehird> Ah.
11:22:14 <dmwit> Haskell 98 specifies that it is a codepoint.  It does not specify 32 bits.
11:22:21 <ehird> k
11:22:21 <Zao> ehird: I dislike people who mix up languages and implementations of them.
11:22:29 <monochrom> I have no money. I built my computer from sand.
11:22:33 <ehird> Zao: *weeps*
11:22:42 <ehird> monochrom: My computer is an organic machine built out of rabbits and tubes.
11:22:45 <Zao> monochrom: Your machine? http://www.neowin.net/forum/index.php?showtopic=783930&hl=
11:22:48 <ehird> It runs at 0.3 hertz.
11:22:49 <leftbench> ehird: thanks
11:22:54 <ehird> leftbench: You're welcome.
11:23:03 <monochrom> organic is overrated.
11:23:31 <ehird> monochrom: The rabbits were fairly traded.
11:24:01 * dino- is trying to imagine what it's like to clean the dust bunnies out of that system.
11:24:06 <monochrom> 1 little, 2 little, 3 little rabbits
11:24:15 <monochrom> 5 little, 8 little, 13 little rabbits
11:24:27 <ehird> monochrom: Yes. A Beowulf cluster of rabbits.
11:24:41 <ehird> (Don't forget the tubes.)
11:25:04 <monochrom> So, does Haskell use memory?  <duck>
11:25:41 * monochrom waits for someone to say "implementations use memory but the language doesn't require it!"
11:26:01 <lysgaard> I need some help with the fgl package. I want to analyze the frequency of characters following each other in a set of words. The problem is that there's some errors when i try to build even the simplest graph. Have to be some language feature i don't understand or something: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5848#a5848
11:26:56 <malouin> monochrom: I almost said that, but I thought better of it :)
11:27:03 <monochrom> hehe
11:28:17 <malouin> If Zao hates people who confuse langauge and implementation, is he confusing hatred for a behavior with hatred for a person?
11:28:35 <liquidsnack> dammit, you beat me to it :)
11:28:47 * pumpkin grrs at his irc client, no confusion there
11:29:00 <jeff_s_> roconnor - the edu exit nodes idea kind of works but isn't turning out to be practical :\
11:29:09 <Zao> malouin: Why restrict myself to one of those?
11:29:29 <pumpkin> we used to have a couple of tor exit nodes here but people were doing bad things and the college decided to shut them down to avoid more legal trouble
11:29:34 <pumpkin> :(
11:29:48 <malouin> Zao: (there exists person who mixes up languages and implementations whom you do not dislike)?
11:30:56 <jeff_s_> I've just been sad since I lost the ability to download academic papers :(
11:30:59 <monochrom> I like all and only those who don't like themselves.
11:31:21 <pumpkin> :(
11:31:29 <roconnor> jeff_s_: how is it not practical?
11:31:36 <pumpkin> monochrom: I only like myself if you like me :(
11:32:01 * pumpkin needs external validation
11:32:10 <malouin> I don’t care to belong to any club that will have me as a member
11:32:14 <ehird> So is there no way to remove parsec's "unexpected ..." when using a custom error?
11:32:35 <jeff_s_> roconnor - it's hard to find an exit node that is both edu and has bandwidth to spare and has subscriptions and their exit node has access tot heir library resources. Seems hard so far.
11:32:52 <jeff_s_> boston U didn't work out
11:33:01 <roconnor> jeff_s_: oh
11:33:07 <roconnor> times might have changes
11:33:07 <pumpkin> someone should set up a paper-specific proxy system :P
11:33:23 <pumpkin> if someone writes me one I'll run it :P
11:33:43 <roconnor> I tried it a few years ago by putting all the .edu exit nodes into my list, and I had an estimated 80% success rate
11:34:37 <roconnor> I just let tor select nodes from that list randomly
11:35:11 <jeff_s_> I have 4 edu exit nodes set up, and tor refuses to connect, saying none of the specified exit nodes are running.
11:35:20 <roconnor> :(
11:35:37 <hackagebot> hunp 0.0 - Unpacker tool with DWIM (DenizDogan)
11:36:20 <pumpkin> my hunp my hunp my hunp, my lovely lady lunp
11:36:48 <jeffwheeler> That name is terribly tough to say
11:37:03 <jeffwheeler> I don't think I can do it. It always turns into hump.
11:37:06 <skorpan> jeffwheeler: read the README, it's actually pronounced "hump" :)
11:37:18 <jeffwheeler> Oh, that works perfectly.
11:37:21 <ehird> hungp
11:37:34 <ehird> hunp is not very typeable on qwerty though.
11:37:38 <ehird> which fails for a DWIM tool :)
11:37:44 <pumpkin> why not?
11:37:54 <ehird> all clustered around the right
11:37:57 <pumpkin> I like it
11:37:59 <ehird> and a lot of dancing between rows
11:38:02 <pumpkin> typing it feels good
11:38:12 <ehird> middle, bottom, top, far-right of top
11:38:16 <ehird> all at the right sid
11:38:16 <ehird> e
11:38:24 <pumpkin> it feels a bit like playing a turn on the piano
11:38:30 <skorpan> hehe
11:39:25 <skorpan> how does this whole ANNOUNCE thing on haskell-café work?  i just send an e-mail with ANNOUNCE in the subject?
11:39:57 <pumpkin> yeah, or ANN, it seems... I don't why people can't just type out announce though
11:40:03 <malouin> tempting as it is, naming your scoped variables id is a bad idea it turns out.
11:41:35 <sm> skorpan: some say you should announce on haskell list as well
11:41:56 <mm_freak> sometimes it happens to me that i name scoped variables 'map'
11:42:26 <skorpan> sm: yeah, i have a vague resemblance of that.  so i send the e-mail to both lists?
11:42:41 <dmwit> resemblance, eh?
11:42:47 <skorpan> eh, dunno
11:42:50 <sm> yeah, or cc one.. and maybe set the reply-to to haskell-cafe
11:42:57 <skorpan> my english is getting worse by the day
11:43:19 <dmwit> "Memory" might fit that sentence a little bit better.
11:43:42 <dmwit> What are you announcing?
11:43:45 <skorpan> hunp
11:43:54 <pumpkin> ah, is that you?
11:44:02 <skorpan> yeah
11:44:04 <pumpkin> my lovely lady lunp
11:44:08 <skorpan> hehe
11:44:16 <sm> haskell unpacker, I see
11:44:19 <jeffwheeler> Garr, I hate that name.
11:44:21 <jeffwheeler> hunp
11:44:24 <jeffwheeler> hump
11:44:24 <pumpkin> lol
11:44:27 <jeffwheeler> Make it right!
11:44:37 <sm>  http://hackage.haskell.org/package/hunp-0.0 for those of you not seeing hackagebot links
11:44:39 <pumpkin> but then you'd have to umpack things
11:44:41 <pumpkin> and that sounds wrong
11:44:49 <dmwit> For what it's worth, "hunp" is an absolute dream to type on a Dvorak keyboard. =)
11:44:50 <pumpkin> get it right!
11:44:58 <pumpkin> I really enjoy it on plain ol' qwerty too
11:45:16 <jeffwheeler> It's nice on qwerty
11:45:26 <jeffwheeler> (I mistype qwerty almost every time . . .)
11:45:28 <skorpan> actually "umpack" is just about how i pronounce "unpack" ;P
11:45:39 * sm likes hump. Easier on the brain, and I like umpacking
11:45:40 <jeffwheeler> Yeah, umpack sounds just fine to me
11:45:40 <pumpkin> the umpteenth version of umpack
11:46:01 <pumpkin> unpteenth
11:46:05 <pumpkin> :D
11:46:25 * jeffwheeler searches for words with unp in them
11:46:42 <pumpkin> unp-complete? ;)
11:46:51 <pumpkin> something that's in np but isn't np-complete? :P
11:47:09 <pumpkin> or maybe just anything that isn't p-complete, whatever that would mean
11:47:16 <jeffwheeler> gunpoint
11:47:16 <skorpan> oh boy.. :)
11:47:30 <jeffwheeler> unparallelized, but that's boring
11:47:39 <pumpkin> that's something you wouldn't pronounce like gumpoing is it?
11:47:42 <pumpkin> gumpoint lol
11:47:56 <jeffwheeler> No, but they're two different syllables, so that's cheating
11:48:03 <skorpan> i would, but as we saw earlier, my english isn't the best
11:48:03 <jeffwheeler> I can't make it hun-pee
11:48:07 <Twey> jeffwheeler: Unproven
11:48:09 <pumpkin> sure you can
11:48:13 <Twey> Unprintable
11:48:13 <pumpkin> ooh, that burns
11:48:15 <Twey> Unpriestly
11:48:18 <pumpkin> unpropriate
11:48:19 <Twey> ...
11:48:19 <pumpkin> ;)
11:48:20 <pumpkin> whoops
11:48:22 <skorpan> funporn
11:48:41 <Twey> match wn substring unp
11:48:42 <Twey> :-P
11:48:51 <pumpkin> I just grep my words file
11:48:57 <jeffwheeler> I used dict.org
11:49:03 <jeffwheeler> with substring search
11:49:10 <Twey> 19:48:41 < Twey> match wn substring unp
11:49:11 <Twey> Ditto :)
11:49:12 <pumpkin> USE DA POWA OF REGEXPS
11:49:23 <pumpkin> even when you don't need it
11:49:52 <skorpan> can someone help me find the thread on cafe about how to properly announce things to the MLs?
11:50:57 <pumpkin> skorpan: just write "YO DAWGZ I HEARD YOU LIKE UNPACKIN SO I PUT A HASKELL UNPACKER IN A PACKED TARBALL SO YOU CAN UNPACK WHILE YOU UNPACK"
11:50:59 <pumpkin> maybe ?
11:51:14 <skorpan> haha
11:51:18 <jeffwheeler> From now on, it's hun-pee for me.
11:51:37 <pumpkin> skorpan: you could've called it unph
11:52:02 <skorpan> pumpkin: actually i have plans on making a DWIM packer as well and i was thinking of calling that lump... "lump it together."
11:52:33 <pumpkin> hah, jeffwheeler would go crazy if you used unp on one side and ump on the other
11:52:53 <skorpan> hm.. but lunp makes no sense!
11:53:05 * jeffwheeler makes a luna unpacker, for the hell of it
11:53:10 <jeffwheeler> Or lua.
11:53:23 <skorpan> aw man, competition :(
11:53:31 * hunp whistles
11:53:39 <hump> :P
11:53:45 * hunp glares at hump
11:53:53 * hump stares back, blankly
11:53:57 <ehird> 19:32 ehird: So is there no way to remove parsec's "unexpected ..." when using a custom error? // :/
11:54:26 * pumpkin takes a nap
11:54:52 <jeffwheeler> And I'm trying, but failing, to procrastinate via music.att.com
11:55:35 <jeffwheeler> Why is nothing tested under Linux?
11:56:25 <idnar> jeffwheeler: lye what? is that a drain cleaner?
11:56:47 <jeffwheeler> I missed something.
11:59:44 <idnar> jeffwheeler: I was just making a joke about how nobody knows what Linux is
12:00:09 <jeffwheeler> idnar: oh, hehe
12:00:30 <jeffwheeler> Yeah . . . it tells me to install something, but the link doesn't do anything. My guess was Silverlight, but it doesn't seem to be.
12:00:30 <ehird> Can a TH $(foo) thingy have a definition?
12:00:32 <ehird> a=b etc.
12:02:36 * Taejo </3 roff
12:05:22 <Taejo> @pl readMan ps = readWith parseMan ps . ('\n':)
12:05:23 <lambdabot> readMan = (. ('\n' :)) . readWith parseMan
12:05:31 <ClaudiusMaximus> is there a library that wraps over GLUT to log all input events?
12:07:09 <ClaudiusMaximus> would anyone else find such a library useful?
12:08:22 <Zao> Log how?
12:09:54 <ClaudiusMaximus> Zao: by registering all possible input event callbacks, then saving the events as they happen (with timestamps) to a log, then passing the events along to the "real" application's callbacks
12:12:12 <ClaudiusMaximus> Zao: the intent is to be able to record videos of interactive sessions; 1. GLUT generally renders "as fast as possible"  2. saving GL output to disk is very slow  3. i want a nice constant-frame-rate video file
12:13:09 <Zao> ClaudiusMaximus: Fair enough.
12:20:49 <hackagebot> historian 0.0.1 - Extract the interesting bits from shell history (MaxRabkin)
12:21:47 <Taejo> ah, we have a hackagebot now
12:23:01 <Taejo> I'm trying to install a package (that one, in fact), but when I do "cabal install", cabal starts downloading regex-base-0.93.1, which ghc-pkg says I already have installed (globally)
12:23:37 <dcoutts> Taejo: that same version?
12:23:44 <Taejo> yes
12:23:58 <dcoutts> Taejo: run with --dry -v to see what is different. It's probably using a different version of a dep.
12:25:53 <sm> could someone tell me if > start http://someurl works on windows ?
12:26:31 <dcoutts> Taejo: it normally tries to use the existing versions of stuff. You can try to constrain its choices and see if it still works or if it explains what goes wrong. There's the flag --constrain="foo == 1.0"
12:26:31 <rizzix> sm, it works
12:26:40 <sm> cool, thanks
12:26:50 <rizzix> np
12:27:28 <Taejo> dcoutts: it says "selecting historian-0.0.1 (hackage)", but I'm trying to install the version I have on my machine
12:28:21 <dcoutts> Taejo: did it say on that line that it was discarding the installed version?
12:28:52 <Taejo> dcoutts: selecting historian-0.0.1 (hackage) and discarding regex-compat-0.71, 0.71.0.1, 0.90, 0.91, regex-posix-0.71, 0.72, 0.72.0.1, 0.72.0.2, 0.72.0.3, 0.91 and 0.92
12:29:18 <Taejo> I have regex-compat 0.92 and regex-posix 0.93.1
12:29:20 <dcoutts> Taejo: wait, are you installing historian-0.0.1 directly or is that a dependency of the thing you're actually installing?
12:29:38 <Taejo> dcoutts: I'm trying to install historian directly
12:29:52 <ehird> Parser (Either MyCustomErrorType Foo)      -- there must be a better way to do this
12:29:56 <dcoutts> Taejo: ok, the (hackage) label is misleading in that case, it should say (local)
12:30:06 <Taejo> ok, thanks
12:30:35 <dcoutts> Taejo: but the reason it's excluding various versions of regex must be because historian-0.0.1 specifies some constraints on the version of the regex libs
12:31:28 <Taejo> dcoutts: the versions I have installed satisfy the constraints, and anyway, it's trying to reinstall the version I already have
12:32:04 <dcoutts> Taejo: right and that line doesn't exclude the versions you've got. Look for other lines where it mentioned regex-*
12:33:00 <dcoutts> Taejo: notice that selecting historian-0.0.1 forced it to discard pretty much all version of regex-compat and regex-posix *except* for the versions you've got installed locally
12:33:33 <dcoutts> Taejo: so it doesn't really tell us anything about why they're getting re-installed, we have to look later in the trace for that info.
12:33:38 <Taejo> dcoutts: yeah, I specified the constraints fairly tightly
12:34:08 <dcoutts> Taejo: perhaps stick the log on hpaste or something
12:34:09 <Taejo> dcoutts: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5850#a5850
12:34:13 <dcoutts> ta :-)
12:34:32 <dcoutts> regex-base-0.93.1 (reinstall) changes: mtl-1.1.0.0 -> 1.1.0.2
12:34:39 <dcoutts> Taejo: that's the crucial line ^^
12:35:05 <dcoutts> Taejo: because regex-base gets reinstalled then we also must re-install the other two regex packages that depend on regex-base
12:35:20 <Taejo> dcoutts: for some reason I have both those versions of mtl installed
12:35:54 <dcoutts> Taejo: right, and it picked the later of the two installed mtl versions and then adjusted other stuff to work
12:36:14 <dcoutts> Taejo: you could try --constraint='mtl == 1.1.0.0'
12:36:21 <Taejo> the 1.1.0.0 seems to be the one in from the ubuntu package, I don't know where the later one comes from.
12:36:28 <dcoutts> Taejo: ie cabal installl --dry -v --constraint='mtl == 1.1.0.0'
12:36:33 <Taejo> would it be safe to unregister 1.1.0.2?
12:36:55 <dcoutts> Taejo: there will probably be some things that depend on it that you'd have to rebuild
12:36:56 <sm> ghc-pkg will tell you
12:37:34 <dcoutts> Taejo: and cabal will ignore packages that have missing deps, as if they were not installed, which is convenient for re-installing broken packages
12:38:34 <Taejo> well, I've managed to get historian installed (it's weird how used to it I've gotten in the past four days)
12:38:41 <ehird> What's the TH node for an assignment?
12:38:52 <ehird> LetS?
12:46:56 <hackagebot> HaskellForMaths 0.1.3 -  (DavidAmos)
12:57:35 <bavardage> how can I find out where a stack overflow is occuring?
13:02:46 <ehird> Anyone know TH? :P
13:03:32 <bremner> ehird: no-one. It's that hard.
13:03:36 <ehird> :D
13:05:21 <byorgey> bavardage: have you tried using profiling?  that might help you see what is allocating a lot of memory
13:05:39 <byorgey> bavardage: just compile with -prof -auto-all   and then run with +RTS -p
13:05:44 <byorgey> then check out the generated .prof file
13:06:09 <byorgey> (usually a stack overflow is caused by evaluating a big thunk)
13:19:43 * byorgey mixes a pitcher of lambda-ade
13:21:59 <bavardage> how can I set the default stack size at compile time
13:22:11 <bavardage> i.e. I don't want my app to have the 8M default, but it to default to something higer
13:22:15 <bavardage> *higher
13:22:25 <bavardage> *OR*
13:22:33 <bavardage> how do I find out where the stack is all being munched
13:25:08 <byorgey> you can set the stack size with +K IIRC
13:25:16 <byorgey> i.e. +K 50M
13:25:39 <byorgey> er, sorry, that's wrong
13:26:31 <mopped> Hey, while not exactly haskell - I was wondering if anyone would mind explaining to me how if statements are defined in lambda calculus?
13:26:36 <mopped> or, a channel where I could find out :P
13:26:50 <RayNbow> mopped: do you know about Church encoding?
13:26:53 <mauke> mopped: if = id
13:26:53 <bavardage> using church encoding?
13:27:03 <dhun> is code like this ok, or should I better use lists of key/value pairs?  chartrans '%'="\\%"
13:27:03 <dhun> chartrans '{'="\\{"
13:27:03 <dhun> chartrans '}'="\\}"
13:27:17 <bavardage> \xtf . x t f :D
13:27:25 <bavardage> if you wanna be explicit
13:27:37 <bavardage> and \ is lamba, I cba to find it
13:27:38 <bremner> dhun: a case statement is another possibility
13:27:39 <mauke> true = const, false = flip const
13:27:40 <bavardage> *lambda
13:27:50 <mopped> Nope RayNbow
13:27:57 <byorgey> dhun: that code looks fine to me.
13:28:04 <dhun> ok so I keep it
13:28:05 <bavardage> mopped: wiki is useful
13:28:10 <RayNbow> http://en.wikipedia.org/wiki/Church_encoding#Church_booleans
13:28:18 <bavardage> ^that
13:28:18 <bavardage> :D
13:29:01 <bavardage> mopped: http://paste.pocoo.org/show/122918/
13:29:06 <bavardage> mopped: kinda spoilers
13:29:20 <bavardage> mopped: but that's building up lambda calc
13:29:40 <mopped> i've only got the basic knowledge anyway
13:29:43 <mopped> so it seems mightly helpful
13:29:50 <byorgey> bavardage: ah, I wasn't too far off.  Just run your program with  +RTS -Ksize
13:29:56 <byorgey> i.e. -K50M or whatever
13:29:58 <bavardage> byorgey: yeah sure
13:30:06 <bavardage> but can you set it to default to something higher
13:30:13 <bavardage> i.e. to not have to add in the +RTS args on each run
13:30:16 <bremner> dhun: here is some similar code I wrote: http://paste.debian.net/39033
13:30:23 <byorgey> oh, I see what you're asking.  I don't know.
13:30:32 <mauke> another lambda calculus prelude: http://codepad.org/v3tkkX5Q
13:30:55 <bavardage> mauke: mine is prettier :D
13:31:22 <dhun> bremner sound very familar to me its latex too
13:31:24 <mauke> bavardage: I'm not sure I agree
13:31:28 <bavardage> the C++ makes it ugly
13:31:30 <bavardage> :D
13:31:32 <mauke> true
13:31:36 <bavardage> aaand, I don't see any lambdas
13:31:45 <mauke> but my parser autogenerates numeric literals
13:31:47 <bavardage> wtf is the point in lambda calc w/o lambdas
13:31:57 <bavardage> my parser is monkey slow
13:31:58 <mopped> What I don't understand about the true = \x y -> x, false = \x y -> y, and say having a predicate function like pred C T F, i'd evalute C to true/false, and then I'd have "True (\x y -> x) (\x y -> y)"
13:32:02 <mauke> bavardage: ascii compatibility
13:32:02 <mopped> which doesnt really make sense to me
13:32:10 <bavardage> and can do about 25 fibonacci numbers before it runs out of memory :D
13:32:15 <RayNbow> Lambda calculus without lambdas is like Haskell without the Curry
13:32:16 <idnar> slash calculus
13:32:21 <Cale> mopped: what?
13:32:21 <bavardage> since the numbers are all church encoded
13:32:26 <bavardage> makes for mighty fun running
13:32:50 <mauke> mopped: why do you have pred C T F?
13:33:00 <mauke> bavardage: HELL YEAH!
13:33:02 <mopped> my bad
13:33:07 <mopped> having the if function as if C T F
13:33:14 <mopped> with C being the predicate ;x
13:33:22 <mauke> mopped: why is T = (\x y -> x)?
13:33:50 <Cale> mopped: The idea is that you're choosing a representation of true and false such that the function  if' True t e = t; if' False t e = e can be written as if' = id
13:33:57 <mopped> I'm not sure, that's what I'm reading though
13:34:02 <mauke> I doubt that
13:34:16 <mauke> the point is that C is either true or false
13:34:17 <RayNbow> :t let if' c t f = c t f   in   if'
13:34:18 <lambdabot> forall t t1 t2. (t -> t1 -> t2) -> t -> t1 -> t2
13:34:31 <Cale> mopped: That is, you can pass some value which you know to be boolean a pair of parameters, and it will act like if would.
13:34:37 <RayNbow> :t const
13:34:38 <lambdabot> forall a b. a -> b -> a
13:34:41 <RayNbow> :t flip const
13:34:42 <lambdabot> forall a b. b -> a -> a
13:35:05 <mauke> bavardage: ouch, your mapprime stuff is extremely ugly
13:35:20 <bavardage> yeah I know
13:35:26 <bavardage> :D
13:35:34 <bavardage> any idaes how to kill it?
13:35:37 <mauke> .extend( "map"     , "\\f -> foldr ((:) . f) nil" )
13:35:38 <mopped> mauke: wiki has true = \a.\b. a, is that not (\x y -> x)?
13:35:39 <bavardage> damn those Y-combinators
13:35:50 <mauke> ^ one true map
13:35:56 <monochrom> <3 recursion
13:35:56 <mauke> mopped: it is, but T is not true
13:36:25 <bavardage> mauke: so where is your Y-comb?
13:36:37 <mauke> .extend( "fix"     , "(\\rec -> rec (\\y f -> f (rec y f))) (\\f -> f f)" )
13:36:43 <mopped> @src id
13:36:43 <lambdabot> id x = x
13:36:44 <bavardage> oh I see
13:37:01 <bavardage> but you cheat
13:37:13 <bavardage> you have explicit recursion!
13:37:17 <mauke> not quite
13:37:35 <bavardage> but you use foldr in defining foldr
13:37:40 <bavardage> as in the names
13:37:52 <Cale> mopped: Do you know how foldr f z replaces each (:) in a list with f and the [] at the end with z?
13:38:19 <bremner> dhun: yeah, it is a quick and dirty translator from openoffice presenter xml to LaTeX
13:38:34 <mopped> yes
13:39:07 <mauke> bavardage: the parser turns "let VAR = EXPR in BODY" into "(\VAR -> BODY) (fix (\VAR -> EXPR))" ... or something like that
13:39:13 <bavardage> oh I see
13:39:29 <dhun> ok
13:39:45 <mauke> similarly, "if X then Y else Z" becomes "if_ X Y Z"
13:39:56 <dhun> people writing that kind of stuff seem to meet on #haskell
13:40:06 <dhun> I am going from mediawiki to latex
13:40:11 <mopped> if I have: if' True T F == id True T F == True T F, wouldn't that break as True isn't a function?
13:40:32 <mauke> mopped: why is True not a function?
13:40:46 <mopped> oh doe
13:40:49 <mopped> doh*
13:40:50 <mauke> mopped: I thought we were doing lambda calculus
13:40:52 <mopped> we are
13:40:55 <mopped> It finally clicked
13:40:59 <mopped> cheers :P
13:42:10 <Cale> mopped: More generally, we can represent values of any algebraic datatype in lambda calculus using functions which take replacements for each of the constructors and essentially apply those replacements throughout
13:42:14 <bavardage> hehe
13:42:27 <bavardage> mopped: a tip: EVERYTIHNG IS A FUNCTION
13:42:33 <Cale> So, for instance, to represent the list  [1,2,3,4,5]
13:42:37 <bremner> dhun: does pandoc not do that yet?
13:42:39 <bavardage> don't worry about things not being functions :D
13:42:40 <Cale> which is 1 : 2 : 3 : 4 : 5 : []
13:43:03 <Cale> We can use the function (\nil cons -> cons 1 (cons 2 (cons 3 (cons 4 (cons 5 nil))))))
13:43:03 <bavardage> it's usually more straightforward if you make a pair first
13:43:20 <Cale> That is, lists *are* their folds.
13:43:41 <Cale> If you want to sum the list, apply it to 0 and (+) :)
13:43:45 <mopped> folds are just using a different operator and end value?
13:43:50 <Cale> yeah
13:43:55 * byorgey still thinks Church encoding is one of the most clever things he has ever learned about.
13:44:06 <Cale> Or suppose we want to represent natural numbers
13:44:17 <dhun> bremner it says it can not http://johnmacfarlane.net/pandoc/
13:44:23 <dhun> according to what I read
13:44:24 <Cale> Well every natural number is built up from Zero and Succ
13:44:30 <ClaudiusMaximus> (repost from yesterday) some audiovisualisations of computations in lambda calculus http://www.archive.org/details/ClaudiusMaximus_-_ULCIv1
13:44:32 <Cale> So we could just take those as parameters
13:44:38 <dhun> but maybe I missunderstood something
13:44:47 <Cale> (\succ zero -> succ (succ (succ zero)))
13:44:56 <Cale> is the number 3
13:45:07 <ClaudiusMaximus> including the source code (mainly haskell)   http://ia301518.us.archive.org/3/items/ClaudiusMaximus_-_ULCIv1/ulci.tar.bz2
13:45:15 <Cale> Is that getting clearer?
13:45:37 <Cale> Every datastructure is a function from its constructors to its value in terms of those constructors.
13:45:52 <dhun> bremner maybe I should contact them in order to avoid uplicate work
13:46:08 <mopped> yeah it's definitely clearer
13:46:50 <mopped> I can understand how numbers are defined by zero and succ, and all operators -- and I understand that you define the nth number by n applications of a function f on x
13:46:55 <mopped> are the f and x trivial?
13:47:05 <bavardage> (1+) 0
13:47:13 <mauke> what
13:47:21 <mauke> f and x are parameters
13:47:23 <mopped> yeah i'm bad at expressing myself
13:47:25 <mauke> you don't know what they are
13:47:45 <bavardage> no, but to actually get the value of the number in haskell, you apply (1+) and 0 to the function
13:47:51 <bavardage> say you wanna print it for example
13:48:31 <mopped> that's my question, does it matter what they are? are "numbers" as we know it defined by (1+) and 0, but does everything else works just as fine with another f and x?
13:48:55 <bavardage> yeah
13:49:07 <bavardage> perfectly well
13:49:18 <bavardage> and you (ab)use this for other things
13:49:40 <bavardage> i.e. repeating another function
13:49:41 <byorgey> ClaudiusMaximus: those are really cool =)
13:50:12 <bavardage> like say you want (g (g (g y))) then that's just the 'number' 3 called with parameters g and y
13:50:40 <dhun> parsing mediawiki is a bit usual since there is no grammer, and you have to work very heuristically
13:50:46 <ClaudiusMaximus> byorgey: thanks :)  i'm currently designing the interactive version
13:51:32 <monochrom> "it is lambdas all the way down"
13:51:39 <byorgey> ClaudiusMaximus: cool!
13:52:03 <byorgey> ClaudiusMaximus: how did you generate the sound?
13:52:20 <byorgey> I mean, what does the sound correspond to.
13:52:39 <ClaudiusMaximus> byorgey: changes in the counts of the different kinds of nodes
13:52:53 <byorgey> ah, I see, neat
13:54:18 <sm> ClaudiusMaximus: awesome :)
13:55:36 <ClaudiusMaximus> sm: :)
13:58:16 <dhun> is this function already defined somewhere?
13:58:17 <dhun> replace::Eq a=> [a]->a->a->[a]
13:58:17 <dhun> replace s o n= map (\x -> if (x==o) then n else x) s
13:58:29 <dmwit> Nope.
13:59:09 <mauke> that's not the right parameter order :-)
13:59:29 <dmwit> yeah =P
13:59:36 <dhun> ?
13:59:50 <dmwit> replace src target = map (\x -> if x == src then target else x)
13:59:55 <mauke> replace :: Eq a => a -> a -> [a] -> [a]
14:00:13 <dhun> ok
14:00:22 <dhun> I don't see why but if say so
14:00:23 <bremner> dhun: it is a good idea to contact the author of pandoc. In any case, doesn't it have a latex output library you (we) could use?
14:00:29 <dmwit> dhun: It's just a style thing.
14:00:51 <dmwit> dhun: It's common to try to order function arguments by what order you would want to partially apply them.
14:01:19 <dhun> yes and since I am not experienced I don't see this order yet
14:01:23 <dmwit> dhun: It's often a good sign if the type ends with (type -> type) for some type (here type = [a]).
14:01:41 <dschoepe> Is there a way to list all songs in the database with libmpd?
14:02:42 <dhun> ok
14:03:08 <dmwit> dschoepe: A scan through the docs suggests that list and listAll should be relevant.
14:03:58 <dschoepe> dmwit: Yes, but they start at a specific path, yet I found no way in the API to determine the database directory
14:04:56 <dschoepe> dmwit: And list expects a Query and filter out every song that doesn't match it.
14:05:20 <dmwit> Surely there's an empty query... but I see where your question is coming from.
14:06:24 <dschoepe> dmwit: Passing it an empty list(Query = [Match Meta String]) results in an MPDError.
14:07:14 <dschoepe> and all the functions seem to compare the entire string, so Match Foo "" doesn't work either.
14:08:04 <dmwit> dschoepe: Have you tried passing the empty path to the various list functions?
14:08:25 <dmwit> dschoepe: e.g. when I use mpc ls, it is relative to the root of the database dir, not to the root of the filesystem.
14:08:30 <dschoepe> dmwit: not yet, let me try.
14:08:46 <dschoepe> Ah, it works. Thanks
14:09:17 <dschoepe> Hmm using listArtists and then mapping over the result for each artist would've worked as well, but I just saw that function now.
14:09:32 <dmwit> That seems rather roundabout. =P
14:14:48 <guenni> I'd like to write an IO function that take input a and returns an IO function that take input a that returns an IO function that takes input a ..... uhm
14:15:35 <timmaxw> i think list comprehension syntax would be better if it was reversed
14:15:46 <timmaxw> so instead of [x+1 | x <- xs], it would be [xs -> x | x+1]
14:15:54 <Botje> not really
14:16:00 <bavardage> but the current syntax follows maths more so
14:16:02 <timmaxw> that way, you first decide what you're iterating over, then what to call your variable, then what expression to use
14:16:19 <bavardage> {x, x member of reals, odd x}
14:16:32 <timmaxw> it lets you type in the order you (I) think
14:16:46 <bavardage> x such that x is a real and x is odd
14:16:53 <timmaxw> maybe both should be available
14:17:11 <Heffalump> I think it would be harder to understand with multiple <-s
14:17:29 <mauke> timmaxw: do notation goes left-to-right
14:17:29 <timmaxw> how so?
14:17:53 <timmaxw> mauke: good point. but it doesn't have to...
14:17:57 <Heffalump> figuring out the order of traversal would be tricky
14:18:05 <Heffalump> but yes, use do notation if you really care
14:18:20 <timmaxw> if it went left-to-right, then it's simple: first is outermost. right?
14:19:05 <timmaxw> anyway, it's just an idea
14:20:14 <sm> durn.. hackage upload failed due to source-repository section
14:21:26 <sm> dcoutts__: is it possibly to run through all hackage's tests, like the above, without actually uploading ? I'd like to do it before tagging a release
14:21:44 <killianek> @type map
14:21:45 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
14:26:07 * sm uploads
14:26:48 <hackagebot> hledger 0.6 - A command-line (or curses or web-based) double-entry accounting tool. (SimonMichael)
14:28:20 <sm> there we go.. now cabal installable on all (haskell) platforms, and these http://hledger.org/binaries need testers
14:29:06 <gwern> I'd test it, but a ledger program wouldn't really be useful to me
14:29:21 * gwern is a notorious miser
14:29:52 <sm> gwern: you could quantify that! :)
14:30:08 * wli seems to have a preposterous propensity to save.
14:30:14 <bremner> gwern: you could keep track of who owes you a coffee
14:30:19 <sm> there you go
14:30:34 <gwern> bremner: no one owes me a coffee. I detest it and on principle refuse to buy it in any way
14:31:03 <gwern> wli: there is no such thing as a preposterous propensity to save! merely laudable ones
14:31:06 <sm> gwern: it also tracks time, or any other commodity
14:31:58 <sm> your hours spent on various haskell projects, eg
14:32:06 * wli determined it was irrational and made efforts to deliberately reduce cash holdings at some point.
14:36:55 <sinelaw> hi, can anyone show me a cool FRP program?
14:37:03 <sinelaw> or hot
14:38:52 <dmwit> http://haskell.org/haskellwiki/FieldTrip
14:41:09 <sinelaw> yes, i saw fieldtrip
14:41:14 <sinelaw> but what about a real application?
14:41:42 <dmwit> You can be the first!
14:42:38 <sinelaw> i WILL
14:42:48 <sinelaw> as long as the Second comes in a few years :)
14:43:03 <gwern> grrr. I hate living with people; they do things like apparently accept an amazon shipment and then conveniently leave by the time I check online and see it was delivered
14:43:10 <gwern> tl;dr: people suck
14:43:26 <Botje> to summarize the summary of the summary: people are a problem
14:43:55 <gwern> your summarized summary is longer than the original summary...
14:44:39 <sinelaw> to summarize the argument over the summarized summary:
14:44:44 <sinelaw> > argh.
14:44:45 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
14:44:46 <sinelaw> > nah.
14:44:48 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
14:45:10 <sinelaw> lambdabot, stay out of this
14:45:51 <gwern> @vixen what do you have to say to sinelaw?
14:45:52 <lambdabot> i don't know, what?
14:46:00 <gwern> don't give me that you.
14:46:45 <thoughtpolice> i think she just did
14:49:06 <gwern> arggghh this is a book I've wanted since january and it's surely somewhere in this house I don't know where</suffer>
14:49:26 <dmwit> In our house, we have a standard place for packages...
14:49:41 <dmwit> You should start a tradition.
14:50:01 <gwern> there *is* a standard place!
14:50:07 <dmwit> awww
14:50:08 <gwern> double-arrgh
14:50:17 <monochrom> "standard" is pending other stupid humans' compliance.
14:50:25 <thoughtpolice> gwern: what book?
14:50:33 <gwern> thoughtpolice: _Lexicon Urthus_
14:50:59 <monochrom> You think "peano arithmetic is incomplete or inconsistent" is bad enough? Try "humans are incomplete and inconsistent".
14:51:24 <monochrom> (If there were a skynet, I wouldn't resist.)
14:51:48 <kynky> there is a skynet
14:53:12 <gwern> lies. skynet was defeated by the Invisible Pink Unicorn (peace be upon her hooves)
14:54:14 <monochrom> The Invisible Pink Unicorn hid your amazon shipment too.
14:54:32 <dmwit> All Unicorns Are Purple!
14:54:37 <dmwit> Teach the debate!
14:55:29 <gwern> there is but one unicorn, and FSM is her prophet
14:55:54 <dmwit> Granted: there is at most one Unicorn.
14:56:07 <monochrom> Uniquon
14:56:28 <monochrom> So, is Haskell finite-state?
15:08:59 <hackagebot> nemesis 2009.6.14 - a rake like task management tool (JinjingWang)
15:12:17 <dcoutts> sm: yes: you can use cabal check for most
15:12:46 <dcoutts> sm: though hackage uses a slightly later version of Cabal, so you can also use cabal upload --check the.tar.gz
15:12:58 <sm> oho, nice
15:13:08 <dcoutts> sm: "cabal check" is obviously completely local
15:13:25 <[bjoern]> I'd like to make a function that, so to speak, takes a Bounded type and returns the maxBound of it. Ideas?
15:13:34 <dcoutts> and it reports all errors rather than just the first
15:13:40 <mauke> [bjoern]: why not just use maxBound?
15:14:14 <monochrom> @type maxBound
15:14:16 <lambdabot> forall a. (Bounded a) => a
15:14:21 <monochrom> Ah I see.
15:14:32 <sm> doh, I did cabal upload --help but missed --check
15:14:39 <[bjoern]> Well I know i can do maxBound :: Int, but I don't want to hardcode the Int there
15:14:44 * sm adds to release tests
15:14:49 <mauke> then remove the :: Int
15:15:35 <[bjoern]> My problem is more with how to define the function
15:15:53 <mauke> why define a function at all?
15:17:02 <Botje> [bjoern]: mymaxbound a = maxBound `asTypeOf` a
15:17:57 <Botje> maxBound will assume the type of whatever you pass in, as long as it has a Bounded instance
15:18:21 <Botje> is that what you meant?
15:18:37 <monochrom> I wasn't sure asTypeOf is in Haskell98. :)
15:18:49 <Botje> it's in the prelude, in fact
15:18:53 <Botje> i'm as shocked as you are :)
15:19:06 <Botje> it was even in haskell 1.3
15:24:53 <[bjoern]> So if I do let mymaxbound a = maxBound `asTypeOf` a, how would I use mymaxbound?
15:25:51 <ehird> [bjoern]: mymaxbound 0
15:25:53 <ehird> or similar
15:25:55 <ehird> although that's ambiguous :-)
15:26:10 <ehird> [bjoern]: if you have a param a, (mymaxbound a)
15:26:57 <monochrom> mymaxbound False
15:27:25 <gwern> @hoogle asTypeOf
15:27:25 <lambdabot> Prelude asTypeOf :: a -> a -> a
15:27:31 <gwern> ?
15:27:34 <monochrom> Hrm you specified a function and you didn't have a plan of how to use it!
15:27:40 <[bjoern]> Okay, so mymaxbound (maxBound :: Int) would do
15:28:05 <hackagebot> nemesis 2009.6.14.1 - a rake like task management tool (JinjingWang)
15:28:32 <monochrom> Um, mymaxbound (maxBound :: Int) is better off simplified as (maxBound :: Int). I thought you swore you really had a polymorphic use.
15:28:53 <ehird> lol@[bj
15:28:54 <ehird> ...
15:28:56 <ehird> [bjoern]
15:29:23 <[bjoern]> But is there no way to pass "Int" directly? How would I call it for Int without jumping through a hoop like using maxBound in the call?
15:29:51 <ehird> [bjoern]: ... maxBound :: Int.
15:29:56 <ehird> I'm not sure you understand :)
15:30:02 <monochrom> The string ":: Int" passes Int directly.
15:31:10 <gwern> baka baka
15:31:23 <Botje> [bjoern]: you don't "pass" types, you give a whopping big hint to the type inferencer
15:31:46 <monochrom> I don't think the string "maxBound :: Int" constitutes jumping through any hoops. There are three tokens, two of them contains real information, one of them is a necessary separator. How simpler could it be?
15:31:51 <Botje> maxBound :: Int says "give me maxBound, which is of type Bounded a => a and force it to type Int"
15:32:27 <monochrom> I mean, hell, to say it in English is even more verbose, "the largest value for Int".
15:32:54 <Botje> "the largest Int" ? :)
15:33:04 <gwern> largest Int
15:33:07 <monochrom> Rule of Thumb: you can't call it "jump through hoops" if the code is shorter than the English.
15:33:44 <gwern> > (length "largest Int", length "maxBound :: Int")
15:33:45 <lambdabot>   (11,15)
15:33:55 <gwern> 4 chars! hoops I tells ya
15:34:03 <monochrom> hahaha
15:36:32 <monochrom> C is jumping through hoops because if a chef says something so simple like "take all sauages from that bag to the grill" you have to write like for (i = 0; i < bag.length; i++) ***OUT OF QUOTA
15:37:11 <[bjoern]> I am trying to make a function that operates on lists of values of some arbitrary Bounded Enumerable type; for empty lists I need need to know the min/max value of the items. So I need two parameters to the function, one that allows me to find the bounds, and the other is the list
15:37:32 <Botje> [bjoern]: no, the list already encodes the type
15:38:08 <Botje> [bjoern]: what does your function of in case of an empty list?
15:38:31 <monochrom> mymax [] = maxBound; mymax xs = maximum xs.  Try that. Seriously.
15:38:44 <[bjoern]> Say it returns a list [ succ (maxBound :: type) ]
15:38:48 <monochrom> Or perhaps mymax [] = minBound
15:38:57 <Botje> [bjoern]: you don't have to give the type explicitly
15:39:07 <Botje> haskell will infer it from the other branches of your function
15:39:15 <Botje> can you just paste what you have now in its entirety?
15:39:22 <Botje> to hpaste
15:41:09 <gwern> @hpaste
15:41:09 <lambdabot> Haskell pastebin: http://hpaste.org/new
15:44:48 <[bjoern]> The function only uses things from Bounded and Enum, if it is only ever called with the empty list then there is not enough information to find the bounds.
15:45:26 <Botje> yes, there is.
15:45:43 <Botje> let's say your function is of type Bounded a, Enum a => [a] -> [a]
15:45:49 <mopped> According to this website, one version of PLUs is (\x -> x succ)
15:45:59 <Botje> mymaxbound [] = [maxBound]
15:46:01 <mopped> can anyone explain this? i don't really understand this definition
15:46:09 <Botje> will equate the types of the input and output lists
15:46:21 <Botje> so [maxBound] :: [a]
15:46:34 <Botje> and maxBound will be forced to :: a
15:46:39 <monochrom> I hate all this denial talking.
15:47:52 <monochrom> Perhaps "x succ" is succ done x times.
15:48:32 <monochrom> Suppose you say "plus 3 4". That will be "3 succ 4". Perhaps it makes more sense to you now.
15:55:11 <mopped> well if three is defined as (\f x -> f (f (f x)), succ = (\n f x -> f (n f x)), then three succ four would be: (f (f (f x))) (\f x -> f (four f x)), f (four f (f (four f (f (four f x))), which doesnt seem to be seven?
15:58:01 <The-Kenny> 6Wie die neue Staffel von futurama!
15:58:06 <The-Kenny> Ups, sorry :S
15:59:19 <Cale> mopped: That definition of succ is wrong
15:59:32 <Cale> er...
15:59:41 <Cale> oh, no, it's okay
15:59:48 <BMeph> I think that expansion is wacky, myself.
16:00:36 <Cale> succ four = succ (\f x -> f (f (f (f x)))) = (\n f x -> f (n f x)) (\f x -> f (f (f (f x))))
16:01:06 <Cale> = (\f x -> f ((\f x -> f (f (f (f x)))) f x))
16:02:02 <Cale> = (\f x -> f (\x -> f (f (f (f x)))) x)
16:02:10 <Cale> = (\f x -> f (f (f (f (f x)))))
16:05:07 <mopped> but three succ four isnt seven right?
16:05:14 <mopped> three f (succ four) is?
16:05:22 <twanvl> > let three f x = f (f (f x)); succ n f x = f (n f x); four f x = f (f (f (f x))) in three succ four f 0 :: Expr
16:05:24 <lambdabot>   f (f (f (f (f (f (f 0))))))
16:06:18 <mopped> hmm
16:07:09 <BMeph> It helps if you choose one expansion order, and stick to it. ;)
16:07:29 <mopped> ah true
16:07:42 <mopped> three succ four, that's (three succ) four?
16:07:52 <monochrom> Yes.
16:08:03 <monochrom> And seven ate nine.
16:08:52 <BMeph> ...which is not the same thing as three (succ four). :)
16:09:01 <mopped> indeed
16:09:03 <mopped> thanks
16:09:53 <monochrom> three sucked four and seven ate nine. wow these numbers really love to have fight among themselves.
16:10:31 <uzytkownik> Hello. Is there any parsec 3 description? I'm interested in monadic running as well...
16:11:23 <Cale> http://hackage.haskell.org/package/parsec
16:11:23 <monochrom> Perhaps «Real World Haskell» has it?
16:11:39 <Cale> There are links to documentation there
16:11:48 <uzytkownik> monochrom: 2.0
16:11:56 <Cale> I'm not exactly sure what you mean by description :)
16:12:06 <Cale> The modules are documented, anyway :)
16:12:17 <monochrom> I wish I were monochrom 2.0, too.
16:12:27 <uzytkownik> Cale: If I found what I'm searching I'd not ask here
16:13:03 <monochrom> "a tutorial of parsec 3 that doesn't just treat it as parsec 2"
16:13:04 <uzytkownik> monochrom: I mean it contains only describes 2.0
16:13:21 <monochrom> I was playing silly word games, don't worry. :)
16:13:48 <uzytkownik> monochrom: Oh really? I'd guess ;) (I know)
16:15:15 <hackagebot> nemesis 2009.6.14.2 - a rake like task management tool (JinjingWang)
16:16:00 <monochrom> A task management tool that makes releases three times a day is not a competent task management tool.
16:16:33 <gwern> monochrom: oh, I'm sure the tool isn't making the releases; it's delegating that to a human
16:16:41 <gwern> delegation is the essence of task management
16:17:34 <monochrom> Anyway something is very wrong with releasing three times in four hours or less.
16:17:38 <Cale> I don't understand the purpose of the code either.
16:17:42 <Cale> Have a look at it
16:18:02 <Cale> http://hackage.haskell.org/packages/archive/nemesis/2009.6.14.1/doc/html/src/System-Nemesis.html#Task
16:18:02 <monochrom> Do you think it's a subtle kind of spamming?
16:18:07 <gwern> monochrom: maybe wang is just new to haskell/cabal and is cleaning up multitudes of mistakes
16:18:51 <gwern> Cale: a task manager is conceptually simple
16:18:52 <inimino> rake is a Ruby thing
16:19:05 <inimino> I remember despising it when I played with Rails
16:19:11 <gwern> I mean, google's task manager/todo list is basically some indented text
16:19:16 <Cale> Maybe by looking at rake, we can try to figure out what this code is supposed to be useful for.
16:19:36 <die> what does "postflight" in the haskell platform do?
16:21:06 <Cale> die_sekte: eh?
16:21:09 <Cale> postflight?
16:21:27 <die_sekte> got it in my Mac OS X haskell platform.
16:21:36 <die_sekte> fails everytime i try to install it
16:23:09 <die_sekte> hm. playing with packages can lead to interesting results.
16:23:25 <Cale> No instance of the string "postflight" occurs in the Haskell Platform source, anyway.
16:23:35 <Cale> I don't have OS X, maybe it's an OS X specific thing.
16:23:42 <die_sekte> yeah.
16:23:56 <die_sekte> anyway, I removed it. And the installer finished.
16:24:19 <die_sekte> I hope my haskell installation isn't broken
16:24:43 <Cale> I've never heard of such a thing before, it's probably fine.
16:25:04 <Cale> Maybe it was just some script which runs after the install to clean things up?
16:25:14 <die_sekte> could be.
16:25:33 <monochrom> The name "postflight" suggests some kind of routine thing to do after a human or a package arrives at the destination. Maybe unpacking.
16:26:10 <monochrom> For example, if you fly to the US, the postflight routine consists of tearing up your baggages and confiscating your laptops in order to ensure world peace.
16:26:32 <die_sekte> haven't had the pleasure yet.
16:27:26 <die_sekte> I'm currently trying to view the contents of the postflight package, but I haven't used the Package Maker in a long time.
16:27:58 <Cale> monochrom: While asking you lovely questions like "Are you now, or have you ever been a member of the Communist Party?"
16:28:37 <gwern> do they still ask that?
16:28:51 <gwern> seems kind of pointless, with what, 4 communist countries left?
16:29:07 <Cale> My friend had a stopover in LAX where she complained about them asking for her fingerprints, and they gave her a form to fill out which included that question.
16:29:37 <gwern> ah. inertia then
16:29:41 <monochrom> Like software, that form will only get more questions but never fewer.
16:30:07 <die_sekte> gwern: There a quite a lot of communist parties left, just no major except for those
16:30:13 <Gracenotes> hmmm... the Mythical Man-Month is turning out to be a fun read
16:30:16 <monochrom> By 2025 that form will contain lots of goto's, too.
16:30:26 <gwern> Gracenotes: you thought a great classic like that wouldn't be?
16:30:31 <die_sekte> Germany has the DKP. German communist party.
16:31:08 <Gracenotes> gwern: I didn't expect less!
16:31:39 <Gracenotes> modulo not knowing what to expect
16:31:49 <kacper_> how create list like this [ x | x <- list, x == (1,_) ] ?
16:32:20 <Botje> what?
16:32:23 <gwern> > filter (\(x,_) -> x == 1) [1..10]
16:32:24 <lambdabot>   No instance for (GHC.Enum.Enum (t, t1))
16:32:25 <lambdabot>    arising from the arithmetic sequ...
16:32:30 <gwern> oh woops
16:32:31 <Gracenotes> in your form, [ x | x <- list, snd x == 1 ]
16:32:52 <Cale> Add your answers to the last 17 questions. If the result is even, turn to page 3. If the result is congruent to 1 modulo 4, turn to page 5. If the result is congruent to 3 modulo 8, turn to page 6. If the result is congruent to 7 modulo 8, turn to page 7.
16:32:52 <gwern> hm. come to think of it, does enum work on tuples...
16:32:53 <Gracenotes> er, I mean, fst.
16:32:54 <Gracenotes> no snd
16:33:03 <kacper_> no
16:33:07 <gwern> > filter (\(x,_) -> x == 1) [(1,2)..]
16:33:08 <lambdabot>   No instance for (GHC.Enum.Enum (t, t1))
16:33:08 <lambdabot>    arising from the arithmetic sequ...
16:33:12 <gwern> dodm
16:33:17 <gwern> *didn't think so
16:33:28 <gwern> > filter (\(x,_) -> x == 1) [(1,2), (2,2), (3,3)] -- ok, let's try that
16:33:30 <lambdabot>   [(1,2)]
16:33:37 <Gracenotes> you could also do: [ x | x@(a, _) <- list, a == 1 ]
16:33:44 <kacper_> i have a type like type (Field, (Int,Int), [Int])
16:33:46 <Gracenotes> using an as-pattern
16:34:02 <Gracenotes> or filter ((==1) . fst)
16:34:16 <Gracenotes> There Is No Right Way To Do Something!</perl>
16:34:33 <kacper_> and i have a list of els with this type, i want to take only els like (_, (1,_),_)
16:35:40 <Gracenotes> hm... for anything more than pairs (and some pairs), you might even want to create your own datatype
16:36:10 <gwern> Gracenotes:  ==1 . fst is just a pointless rewrite of the lambda
16:36:36 <Gracenotes> pretty though
16:36:52 <gwern> well, if you can understand it
16:37:26 <kacper_> i wirote it like col field = [ x | x <- field, fst (mySnd x) == 1  ]
16:37:39 <die_sekte> well, I did figure out what postflight does. It just links up some stuff from the haskell platform directory to /usr/local/bin
16:37:45 <kacper_> where mySnd returns snd from triple
16:38:00 <Gracenotes> hm.. since list comprehensions can fail pattern matching, you could just do [ x | x@(_, (1, _), _) <- list ]
16:38:01 <die_sekte> I didn't have a /usr/local/bin, so it didn't succeed.
16:38:31 <kacper_> @?
16:38:49 <Gracenotes> @ is called an as-pattern
16:38:55 <kacper_> nce
16:38:58 <kacper_> *nice
16:39:08 <Gracenotes> x refers to the whole element, but you can pattern match extra stuff after the @
16:40:18 * Gracenotes reads Mythical Man-Month.. chapter 3  ô.ô
16:43:28 <Gracenotes> (>._.)ø
16:48:28 <uzytkownik> @hoogle mfix
16:48:28 <lambdabot> Control.Monad.Fix mfix :: MonadFix m => (a -> m a) -> m a
16:48:40 <uzytkownik> @hoogle forever
16:48:40 <lambdabot> Control.Monad forever :: Monad m => m a -> m ()
16:48:52 <dmwit> bah
16:48:58 <dmwit> forever :: Monad m => m a -> m b
16:50:48 <shu> does anyone know how to get getDirectoryContents to return a properly encoded list of filenames on windows?
16:50:55 <ehird> @hoogle base
16:50:55 <lambdabot> package base
16:50:55 <lambdabot> Text.XHtml.Frameset base :: String -> HtmlAttr
16:50:55 <lambdabot> Text.XHtml.Strict base :: String -> HtmlAttr
16:50:58 <ehird> hrm
16:51:02 <shu> i have several files with japanese names and they come up as questionmarks
16:51:04 <ehird> there's no way to show a number in a certain base?
16:51:14 <mauke> showIntAtBase
16:52:02 <ehird> mauke: doesn't appear to exist, and does that work for Integers?
16:52:39 <mauke> http://www.haskell.org/hoogle/?q=showIntAtBase
16:53:06 <ehird> Numeric? never heard of that module
16:53:08 <ehird> sounds arcane :)
16:53:27 <uzytkownik> @hoogle liftIO
16:53:27 <lambdabot> Control.Monad.Trans liftIO :: MonadIO m => IO a -> m a
16:53:39 <uzytkownik> @hoogle forkIO
16:53:39 <lambdabot> Control.Concurrent forkIO :: IO () -> IO ThreadId
16:54:29 <shu> i also can't find the call under System.Win32 to list a directory's contents
16:54:35 <shu> hm
16:54:41 <uzytkownik> What are the rules of program death? End of main thread or end of last thread?
16:54:43 <mauke> System.Directory?
16:54:50 <shu> getDirectoryContents returns question marks
16:55:04 <shu> for the files named in japanese
16:55:13 <shu> it doesn't seem to even encode them at all, even in a wrong encoding
16:55:14 <shu> just question marks
16:55:16 <ClaudiusMaximus> uzytkownik: end of main thread (so you have to explicitly wait for all children)
16:56:17 <uzytkownik> ClaudiusMaximus: Thanks. That means in test in which performance does not count I can just spawn threads
16:57:13 <dmwit> shu: This blog post may have information for you: http://snoyblog.snoyman.com/2009/06/11/filename-encoding-issues/
16:57:22 <dmwit> not sure
16:58:09 <shu> well, i can convert encodings IF the strings returned are even encoded
16:58:15 <shu> but i'm talking literally "?? ??"
16:58:30 <shu> it seems latin characters are at least encoded
16:58:33 <shu> but not things outside of latin
16:58:42 <dmwit> shu: mm
16:58:44 <dmwit> nasty
16:59:11 <dmwit> It may be reasonable to file a bug report against GHC for something like this.
16:59:22 <dmwit> In the meantime, I'm not sure what to suggest as a workaround.
16:59:31 <shu> hm
16:59:37 <die_sekte> could it be that you have simply no way of viewing those characters?
16:59:46 <shu> what do you mean by "simply no way"
16:59:53 <shu> oh
16:59:58 <shu> you mean the font has no glyphs for them?
17:00:01 <shu> thus they're coming up as ?
17:00:01 <dmwit> shu: He means your font, right.
17:00:05 <die_sekte> yep
17:00:13 <mle> that's what |od -t x1 is for.
17:00:15 <shu> well, no, because the show function doesn't display the glyphs
17:00:24 <shu> if it's outside of latin it displays a backslash escape code
17:00:29 <dmwit> exactly
17:00:32 <die_sekte> ah
17:00:35 <dmwit> > '\2000'
17:00:36 <lambdabot>   '\2000'
17:00:36 <die_sekte> didn't know that
17:00:47 <shu> but show gives back ???
17:00:48 <shu> which means
17:00:55 <shu> this failure happened probably at the syscall level
17:00:55 <die_sekte> > '–'
17:00:56 <lambdabot>   '\8211'
17:01:03 <mle> > '\101'
17:01:04 <lambdabot>   'e'
17:01:51 <dmwit> mle: Windows. ;-)
17:02:13 <shu> i don't know, i find windows 7 quite usable :P
17:02:47 <dmwit> Oh, I'm sure it is.  I wasn't trying to rap on Windows, just saying that the linux tool "od" probably isn't that relevant here. =)
17:02:53 <shu> hm, there is one thing to try
17:03:04 <shu> i could set the default locale for non-unicode apps to Japanese and see what haskell does in that case
17:03:07 <shu> brb
17:03:36 <EvilTerran> ... that could end in symbols, everywhere, thousands of them
17:04:28 <kynky> dont execute till you see the whites of their code
17:05:50 <Baughn> "The CN7 anion" <-- Hang on, shouldn't CN4 be the limit? -_-
17:06:15 <dmwit> heh
17:06:20 <dmwit> Nitrogen is special in a lot of ways.
17:06:21 <die_sekte> well, it's an anion
17:06:32 <Baughn> Ah. I also see it's highly explosive.
17:06:36 <Baughn> I should've figured.
17:06:47 <die_sekte> triple-minus
17:06:47 <Gracenotes> cutting anions makes me cry
17:07:06 <die_sekte> Gracenotes: put them in the freezer first
17:07:16 <Baughn> die_sekte: THe freezer /wasn't enough/
17:07:22 <Baughn> http://pipeline.corante.com/archives/2009/01/07/things_i_wont_work_with_azidotetrazolate_salts.php <-- Here's a reminder of why we're programmers and not chemists.
17:07:31 <dmwit> cutting anions -- subatomic emo culture represent!
17:07:55 <die_sekte> Baughn: I actually consider studying chemistry.
17:08:05 <die_sekte> Somewhere nere these nutjobs.
17:08:34 <Baughn> "The cesium salt actually did give a few crystals, which they managed to pluck from the top of the solution and get X-ray data on. A few hours later the remaining batch suddenly exploded, though, which certainly must have been food for thought." <-- Are you sure you want to?
17:08:49 <die_sekte> Sounds like fun.
17:09:15 <kynky> they told me doig alevel chemistry would mean that everything i didat gcse level would b wrong, then at degree level the a-level stuff would b wrong, so i stuck with physics
17:09:32 <die_sekte> Yeah, that's happening a lot
17:09:37 <Baughn> kynky: Where we /know/ that /everything/ is wrong
17:09:55 <Gracenotes> biology represent
17:10:05 <p_l> die_sekte: get into nanotech. If you want nice explosions, remember that working with explosives on nanoscale allows to make even more powerful ones
17:10:09 <die_sekte> Got introduced to one atom model in 8th grade, now in 12th grade learning one that's a bit more realistic
17:10:32 <Baughn> Have they gotten around to introducing quantum physics yet?
17:10:35 <kynky> biology was just a memorizing stuff, i like to figure it out
17:10:49 <die_sekte> Baughn: Somewhat
17:11:07 <mariano|syzygy> in what lib is Readline?
17:11:19 <Baughn> die_sekte: Hum. I find it highly amusing that many chemicals' stability depend on electrons reliably being in many places at the same time
17:11:37 <Gracenotes> biology is partially memorizing, but it's also much of how-things-work. There are interesting mechanisms you have to get inside of intellectually
17:12:47 <Zao> »Have you ever set up a reaction and thought "Boy, I sure hope that this doesn't work"?»
17:12:54 <die_sekte> Baughn: And I still have problems with the larger s-orbitals and the smaller p-orbitals. they tend to overlap.
17:13:00 <Baughn> Zao: ..yes.
17:13:22 <jimmyjazz14> monoids are confusing
17:13:30 <copumpkin> jimmyjazz14: how so?
17:13:31 <Baughn> Zao: FTR, it worked. Fortunately we had liquid nitrogen on hand.
17:13:33 <kynky> Gracenotes, true, but was meaning on what you needed topass the exam, (it is intresting, but i prefer the ability to find something out, than to memorize, obviously both is better, but sometimes there i a limt on my memory)
17:13:39 <die_sekte> Zao: No. Highschool-level chemistry is boring.
17:14:18 <Gracenotes> kynky: mm. Well, chemistry is half memorizing and half math, so I just find bio more interesting than it :)
17:14:51 <monochrom> Eh? Chemistry? :)
17:14:55 <marienkind> it seems that getDirectoryContents just uses the default codepage
17:14:57 <jimmyjazz14> copumpkin: just in general, I havn't been able to find an (easy) explaination for them
17:14:58 <Gracenotes> not like math isn't interesting, but not arithmetic for which it's simple to make a simple mistake..
17:15:25 <monochrom> Chemistry is hard. Let's go smoking.
17:15:38 <kynky> i did maths and further maths with mechanics, phsics and electronics, subjects really complemented each other, took out alot of memorizing more stuff
17:15:39 <copumpkin> jimmyjazz14: anything that has an associative binary operation and an identity element... addition on integers with 0 for example, but also function composition with id
17:16:25 <Gracenotes> argh. As for me, I am having much trouble thinking how logic gates work :/ anyone have a good intro?
17:16:28 <kynky> you can still get good marks in maths, even with wrong answers, because they can see your reasoning and you get marked on that too
17:16:46 <kynky> learn boolean algebra
17:16:51 <Gracenotes> the system... I must be missing something
17:16:51 <kynky> for logic gates
17:17:07 <Gracenotes> I am very much familiar with boolean algebra. But the mechanism, I am confuzzled.
17:17:23 <jimmyjazz14> copumpkin: I believe I may have skipped to many chapters ahead
17:17:24 <Gracenotes> probably the diagrams aren't helping
17:17:31 <monochrom> You mean how those little transistors end up conspiring to give the right answers?
17:17:37 <kynky> the transistor resistor stuff ? or lower level ?
17:17:47 <copumpkin> jimmyjazz14: but intuitively, it's nothing haskell-specific :)
17:17:52 <mauke> jimmyjazz14: you don't need much to get monoids
17:18:16 <Gracenotes> NOT gates, how to implement ADD and MOV from them, basic stuff. Just reading through an ebook..
17:18:42 <monochrom> OK I see. How logic gates conspire to add.
17:18:58 <monochrom> (Well, it is not like the gates know they are adding. :) )
17:19:12 <Gracenotes> also how the electric current moves and interacts with gates.
17:19:31 <Gracenotes> the unspoken meaning of the positions of terminals and wires
17:19:45 <monochrom> OK you have a mixed concern of the logic level and the physics level.
17:20:05 <BMeph> Gracenotes: Reading "From NAND to Tetris"? ;)
17:20:24 <kynky> Gracenotes, microprocesser to the rescue, hehe, but seriously, it more complex, need registers and stacks i guess, but doing a couple of instructions not too bad, but logic gets harder when adding harder insructions
17:20:54 <Gracenotes> eh. A book just entitled "/LQX[$VVHPEO\/DQJXDJHURJUDPPLQJ" .. oh god, this PDF does not like being copied from
17:20:59 <kynky> and he lower level stuff, s alot lot lot harder, the maths gets quite intense
17:21:50 <Gracenotes> BMeph: you'd recommend that?
17:22:49 <kynky> i prefer digital electronics to analog
17:22:51 <Gracenotes> the goal is to get a good grasp of assembly by the summer's end. It seems deducing the behavior of assembly at a glance is more difficult than higher level languages. *hugs haskell*
17:22:57 <rizzix> If you're intersted in really low level stuff look into transistors
17:23:06 <Gracenotes> among other numerous goals..
17:23:11 <rizzix> gates are buit from transistors
17:23:21 <Gracenotes> mm. I'
17:23:21 <mauke> wouldn't it be easier to learn assembly without looking at gates?
17:23:53 <Gracenotes> I suppose I can skip them for now
17:23:54 <kynky> programming in assembly and building a mini microprocessor from logic gates are kinda two diff things
17:24:09 <copumpkin> I learned assembly without having a clue about gates
17:24:15 <monochrom> Assembly is just imperative programming taken to the fundamentalist extent.
17:24:25 <Gracenotes> o_o
17:24:30 <kynky> masm, tasm, mpasm, all quie easy
17:25:21 <gwern> kynky: what do you think of spasm?
17:25:30 <monochrom> Haha
17:25:35 <kynky> :)
17:25:36 <mauke> sarcasm
17:25:47 <die_sekte> don't forget as
17:25:48 <monochrom> morphasm
17:27:13 <gwern> what, spasm doesn't stand for Sparc ASM? :)
17:27:36 <die_sekte> hm. sparcasm. not a bad name
17:28:18 <monochrom> Assembly is "hard" just because you have to write a long program to do a small task. It is pretty easy if you just look at what which line does, e.g., "add ax,dx" simply means ax:=ax+dx, what is there to understand?
17:28:22 <kynky> never did assembly on sparc
17:28:50 <kynky> just on x86 and pic
17:29:02 <mauke> addw %dx, %ax
17:29:41 <Gracenotes> monochrom: so an assembly program's function being hard to guess probably won't go away? :)
17:30:01 <kynky> but some really cool tricks in asm, then they brougt out optimizers :)
17:30:42 <kynky> so why bother unless doing low level stuff
17:31:07 <monochrom> You know, I don't believe in some smartass handing down an undocumented program telling me to guess what it does. The author has the burden to state what it does and prove it does that.
17:31:13 <copumpkin> > 2^42,643,801 - 1 `seq` text "wut?"
17:31:14 <lambdabot>   <no location info>: parse error on input `,'
17:31:24 <copumpkin> > (2^42643801 - 1) `seq` text "wut?"
17:31:27 <kynky> monochrom, choose not to use it ?
17:31:29 <lambdabot>   wut?
17:31:35 <copumpkin> good job gmp
17:31:39 <copumpkin> I'm impressed
17:32:07 <Gracenotes> > logBase 2 42643801
17:32:08 <lambdabot>   25.34583270079485
17:32:28 <mauke> > (2^42643801 - 1)
17:32:33 <lambdabot>   mueval-core: Prelude.read: no parse
17:32:33 <lambdabot>  mueval: ExitFailure 1
17:32:42 <copumpkin> the show instance will probably take a while
17:32:53 <dmwit> > 42643801 / 1024 / 1024
17:32:54 <lambdabot>   40.66829776763916
17:32:56 <mauke> > (2^42643801 - 1) < 0
17:33:00 <lambdabot>   False
17:33:05 <dmwit> That's a 40MB number right there. =)
17:33:55 <die_sekte> Geeky poster idea: print biiiig numbers.
17:34:20 <Gracenotes> indistinguishable from random digits at first glance \/_\/
17:35:09 <mauke> print π in base 9
17:35:27 <monochrom> π
17:35:31 <ehird> lol
17:35:32 <monochrom> That's π in base 9.
17:35:44 <mauke> preflex: calc '9 pi
17:35:44 <preflex>  3.124188124074428
17:35:52 <Gracenotes> exciting
17:36:06 <skorpan> preflex: calc '17 pi
17:36:07 <preflex>  3.26fag579ed7
17:36:10 <skorpan> fag
17:36:20 <mauke> good job
17:36:23 <Gracenotes> perhaps try base (1-i)
17:36:23 <skorpan> thank you sir
17:36:48 <monochrom> preflex: calc '36 pi
17:36:48 <preflex>  3.53i5ab8p5
17:37:05 <monochrom> I want more digits.
17:37:06 <skorpan> preflex: calc '1337 pi
17:37:06 <preflex>  Invalid number base
17:37:09 <skorpan> what!
17:37:11 <Gracenotes> d_2 * (1-i)^2 + d_1 * (1-i)^1 + d_0 * (1-i)^0 + d_-1 * (1-i)^-1 + d_-2 * (1-i)^-2 + ...
17:37:25 <Gracenotes> d_n being the nth digit..
17:37:36 <mauke> monochrom: sorry, it's only double precision
17:37:46 <monochrom> Heh ok no problem.
17:40:50 <mle> preflex: calc '36 1524989
17:40:50 <preflex>  woot
17:41:41 <die_sekte> nice
17:45:02 <mauke> preflex: zdec z4U4/wootz4Ug
17:45:02 <preflex>  4/wootg
17:45:55 <mle> what is zdec?
17:46:12 <mauke> preflex: help zdec
17:46:12 <preflex>  zdec TEXT - z-decode some text
17:48:56 <Gracenotes> preflex: zdec z2UHELLO THERE
17:48:57 <preflex>  HELLO THERE
17:48:57 <mauke> http://www.haskell.org/ghc/docs/latest/html/users_guide/ffi-ghc.html#id3064575
17:49:11 <Gracenotes> darn +c
17:50:07 <mle> well, which z encode/decode is this?
17:50:33 <mauke> is there more than one?
17:51:29 <mauke> oh, nice. I can't resolve hackage.haskell.org
17:51:43 <Gracenotes> z-encode allows you to code while meditating
17:51:57 <mle> Google proved significantly unenlightening
17:52:14 <mle> it doesn't look like .Z or .gz type stuff
17:52:19 <Gracenotes> odd, I'd guess z-encode would be the path to enlightenment
17:52:45 <dmwit> mle: z-encoding is the code GHC uses to encode symbols in letters and numbers for identifiers.
17:53:03 <mauke> mle: did you try my link?
17:53:20 <mle> Oh!
17:53:24 <copumpkin> there's a more comprehensive list in a command in the ghc source
17:53:29 <defun> on hackage I see many packages that are labeled as "library and program". How does one make code both a library and a program?
17:53:34 <mle> mauke: yeah, that explains it.  Sorry.
17:53:37 <copumpkin> also, I think that link is wrong
17:53:38 <Gracenotes> preflex: zenc this is some text, perhaps to be encoded?
17:53:39 <preflex>  thisz20Uisz20Usomez20Utextz2cUz20Uperhapsz20Utoz20Ubez20Uencodedz3fU
17:53:50 <Gracenotes> preflex: zenc z
17:53:50 <preflex>  zz
17:53:51 <copumpkin> . is zi
17:53:59 <copumpkin> preflex: zdec zd
17:53:59 <preflex>  $
17:54:40 <Axman6> periodic: zenc helloz20Uworld
17:54:45 <Axman6> uh
17:54:54 <Axman6> preflex: zenc helloz20Uworld
17:54:54 <preflex>  hellozz20Uworld
17:55:00 <mle> preflex: zdec z01UACTIONz20Udancesz01U
17:55:00 <dmwit> preflex: zdec helloz20Uworld
17:55:00 <preflex>  ACTION dances
17:55:01 <preflex>  hello world
17:55:12 <mle> Ah, it puts out an extra space, ohwel
17:56:22 <Gracenotes> My prince is dead! All is lost without him. May God unite us in heaven.
17:57:16 <mle> preflex: zdec z0dUz0aUprivmsgz20Uz23Uhaskellz20Uz3aUz01UACTIONz20Udancesz01U
17:57:16 <preflex>  
17:57:26 <mle> heh, nevermind.
17:57:46 <hackagebot> nemesis 2009.6.14.3 - a rake like task management tool (JinjingWang)
17:58:14 <mauke> preflex: zdec __stginit_mtlzm1zi1zi0zi2_ControlziMonadziReader_
17:58:14 <preflex>  __stginit_mtl-1.1.0.2_Control.Monad.Reader_
17:58:56 <Axman6> preflex: zenc zzzzzzzzzz
17:58:56 <preflex>  zzzzzzzzzzzzzzzzzzzz
17:59:20 <mauke> preflex: zenc Axman6!n=Axman6@pdpc/supporter/student/Axman6
17:59:20 <preflex>  Axman6znnzeAxman6z40UpdpczssupporterzsstudentzsAxman6
17:59:23 <dmwit> :t replicateM
17:59:24 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
17:59:33 <dmwit> :t iterateM
17:59:34 <lambdabot> Not in scope: `iterateM'
18:00:27 <dmwit> > let dup x = [x, x] in "z" >>= dup >>= dup >>= dup >>= dup >>= dup
18:00:28 <lambdabot>   "zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz"
18:00:42 <Axman6> so i take it that z encoding makes all characters s they are in the range of [0-9a-zA-
18:00:45 <Axman6> Z]
18:00:47 <Axman6> ?
18:00:53 <dmwit> yup
18:01:24 <Axman6> preflex: zenc hello there... how do you like this œ∑´®†\¨ˆøπ“åß∂ƒ©˙∆˚¬…æΩ≈ç√∫µ≤≥÷
18:01:24 <preflex>  helloz20Uthereziziziz20Uhowz20Udoz20Uyouz20Ulikez20Uthisz20Uz153Uz2211Uz0b4Uz0aeUz2020Uzrz0a8Uz2c6Uz0f8Uz3c0Uz201cUz0e5Uz0dfUz2202Uz192Uz0a9Uz2d9Uz2206Uz2daUz0acUz2026Uz0e6Uz3a9Uz2248Uz0e7Uz221aUz222bUz0b5Uz2264Uz2265Uz0f7U
18:01:36 <copumpkin> is that page on z-encoding just wrong, or is it talking about something else?
18:01:37 <Axman6> heh, didn't expect that to work
18:01:40 <Gracenotes> no need to be cruel, dear!
18:01:41 <copumpkin> or another version
18:02:05 <mauke> copumpkin: it's just wrong
18:02:09 <copumpkin> lol
18:02:09 <Axman6> preflex: zdec helloz20Uthereziziziz20Uhowz20Udoz20Uyouz20Ulikez20Uthisz20Uz153Uz2211Uz0b4Uz0aeUz2020Uzrz0a8Uz2c6Uz0f8Uz3c0Uz201cUz0e5Uz0dfUz2202Uz192Uz0a9Uz2d9Uz2206Uz2daUz0acUz2026Uz0e6Uz3a9Uz2248Uz0e7Uz221aUz222bUz0b5Uz2264Uz2265Uz0f7U
18:02:10 <preflex>  hello there... how do you like this œ∑´®†\¨ˆøπ“åß∂ƒ©˙∆˚¬…æΩ≈ç√∫µ≤≥÷
18:02:15 <Axman6> excellent
18:02:33 <dmwit> > let toNum n = replicate n(); fromNum = length; (+) = (++); (*) = (>>) in fromNum (toNum 3 + (toNum 5 * toNum 7))
18:02:34 <lambdabot>   38
18:02:48 <copumpkin> aw
18:04:42 <Gracenotes> -_-
18:07:50 <hackagebot> pretty-show 1.1 - Tools for working with derived Show instances. (IavorDiatchki)
18:09:54 <Saizan> ?hackage pretty-show
18:09:54 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/pretty-show
18:16:07 <Gracenotes> ugh. I'm tired of hearing that two languages are Turing-equivalent as a way to dismiss valid comparisons between them in language debates >:[
18:17:38 <ClaudiusMaximus> i've implemented a brainfuck interpreter in untyped lambda calculus - i wouldn't attempt implementing an untyped lambda calculus interpreter in brainfuck..
18:18:07 <die_sekte> ClaudiusMaximus: I assume you were bored.
18:18:41 <ClaudiusMaximus> was more insomnia than boredom i think
18:18:43 <die_sekte> As another challenge, implement APL in brainfuck.
18:19:23 <Axman6> heh
18:19:36 <mauke> the worst I've done is writing a brainfuck-to-OISC compiler
18:20:24 <die_sekte> Or, for the creative ones: Implement brainfuck in brainfuck.
18:21:35 <Gracenotes> or a brainfuck compiler
18:22:18 <Gracenotes> (as opposed to interpreter..)
18:22:33 <Axman6> >_<
18:22:51 <mauke> writing a brainfuck compiler in brainfuck is relatively easy, depending on your target language
18:23:06 <mauke> if you're targetting asm, the hardest part is label generation
18:25:10 <die_sekte> A brainfuck to piet compiler written in ... INTERCAL!
18:25:22 <die_sekte> I imagine developing that to be hell.
18:25:58 <Gracenotes> not if you're Cadie
18:26:48 <die_sekte> well, last time I'm checked I'm not Cadie.
18:30:35 <Saizan> die_sekte: check again!
18:31:06 <die_sekte> hm. torso: looks human. poking. feel pain. next up: legs.
18:31:43 <die_sekte> left leg: human. right leg: human.
18:32:43 <die_sekte> so far I seem to be human.
18:36:09 <ClaudiusMaximus> my bfi in lc: here it is >> http://pastebin.com/m39a886d8  expects "code$input" as a list of naturals
18:45:21 <Alpounet> would a feed-forward neural net library be worth being put on hackage or code.google.com or similar ?
18:45:40 <dmwit> Absolutely!
18:46:15 <andresj> hey, im trying to find a good Graphics library, but i cant seem to find one with enough documentation... any ideas?
18:46:36 <dmwit> It depends a bit on exactly what you want to do with your graphics.
18:46:39 <andresj> Cairo seems too imperative to me, but i could use it if there was nothing else
18:46:52 <andresj> i want to write a vector-editing application
18:47:01 <dmwit> You might like diagrams, if Cairo seems like a solution to you.
18:47:01 <andresj> in a gtk/gnome shell
18:47:14 <andresj> cairo seems awesome as a backend
18:47:29 <dmwit> ?go byorgey diagrams
18:47:31 <lambdabot> http://byorgey.wordpress.com/2008/04/30/new-haskell-diagrams-library/
18:47:31 <lambdabot> Title: New Haskell diagrams library « blog :: Brent -> [String]
18:47:47 <Alpounet> dmwit, still working on it, and would need community efforts to be improved/completed, but it could be a good start for Neural Nets in Haskell
18:48:18 <andresj> hum
18:49:03 <andresj> i'll check out Diagrams :) thank you
18:49:16 <dmwit> Is this just for fun, or can I suggest inkscape as a pretty mature vector-graphics editor?
18:50:13 <andresj> its mostly for fun, to learn :P and yes, i use inkscape for most vector-graphics editing :D
18:51:19 <roconnor> @src uncurry
18:51:19 <lambdabot> uncurry f p = f (fst p) (snd p)
18:55:42 <andresj> btw, anyone know why Diagrams chose to make the positive y-axis point downwards? I ask this specially because of the implication that positive rotations are clockwise, opposite as in traditional math.
18:56:15 <mle> framebuffer style maybe?
18:56:49 <andresj> probably, it just seems very counterintiutive, for the rotation to be reversed
18:57:31 <roconnor> rotations should just be given by passing in two unit vectors
18:57:56 <roconnor> stupid non-coordinate free interfaces
18:58:07 <roconnor> non-coordinate-free
18:59:21 <andresj> lol
19:08:49 <Axman6> andresj: it's traditional in graphics to move right and down from the top left positively, like writing i think
19:14:45 <andresj> true
19:14:56 <andresj> well i mean, in computer graphics
19:15:08 <andresj> not in eucledian space
19:15:54 * Alpounet 's artificial neural nets are smashing down his real neural nets
19:34:35 <Alpounet> g'night all
19:59:31 <kadoban> is there a standard function to remove adjacent repeats from a list?  can't seem to think of the right term to search for (ex. [1,1,2,2,2,1] -> [1,2,1])
20:00:13 <mle> nub
20:00:19 <mle> hm, not quite
20:01:09 <kadoban> oh, haha...i thought you were being rude. ya, that seems like what i want.  thanks a lot
20:01:19 <mle> Heh, well
20:01:43 <mle> > nub [1,1,2,2,2,1]
20:01:44 <lambdabot>   [1,2]
20:01:50 <mle> Not quite what you need
20:02:09 <kadoban> well, that's close enough...i don't actually need later ones left alone now that i think about it
20:03:48 <BMeph> > map head . group $ [1,1,2,2,2,1]
20:03:50 <lambdabot>   [1,2,1]
20:04:01 <mle> Oh, nice.
20:04:05 <BMeph> kadoban: Like that? :)
20:04:15 <kadoban> ah, that works.  thanks to you too :)
20:15:03 <gwern> wow. this recent unicode IO patch has the longest patch description I've ever seen
20:15:09 <gwern> 14 screens' worth
20:15:56 <dino-> gwern: That sounds extreme.
20:16:18 <gwern> to the max
20:19:08 <mriou> I'm looking for a nice way to construct a type from an array
20:19:18 <mriou> say I have Foo = Foo Int Int Int
20:19:38 <mriou> and want to build a Foo from [3,7,11]
20:20:10 <mriou> a fold doesn't seem to cut it as the returned type will change
20:20:11 <gwern> like foo (a:b:c:_) = Foo a b c ?
20:20:57 <gwern> man, it just struck me how tremendously useful foo bar baz quux etc are
20:21:01 <gwern> they're so great
20:21:07 <mriou> gwern: that's good but I was wondering is there was a way without introducing another definition
20:21:20 <gwern> another definition?
20:21:21 <mriou> he he
20:21:22 <dino-> Hm, I wonder if something could be done with Applicative
20:21:34 <gwern> well, probably, but I suspect one would need more context to know what trick to do
20:23:11 <mriou> gwern: forget it, pattern matching is good enough :) thanks!
21:06:25 * pem is away: Gone away for now
21:09:33 <mariano|syzygy> is there an example out there of using Parsec to write a lexer and then a parser on top of the lexrer?
21:10:20 <fartbooger> mariano|syzygy: Yo dawg...
21:31:22 <mle> mariano|syzygy: like two levels of Parsec?
21:31:47 <mle> or Parsec as a lexer for happy?
21:31:48 <mariano|syzygy> like the combination of lex and yacc of old
21:31:58 <mle> eh, look at alex+happy then.
21:32:00 <mariano|syzygy> two levels of Parsec, ideally
21:32:03 <mariano|syzygy> ah, ok
21:32:53 <mle> Parsec can work with lists of tokens of types other than Char.
21:33:07 <mle> Just make a parsec parser taking chars to do your lexing, that emits tokens of some type
21:33:20 <mle> then another parsec parser handling those tokens and emitting some sort of AST
21:33:46 <mle> But at that point it's usually cleaner to just use alex+happy.  Keep in mind alex doesn't really support unicode though.
21:33:49 <mariano|syzygy> that's the idea
21:34:39 <mle> with parsec it usually isn't quite so necessary to have different levels of tokens.  But it can be helpful for some cases.
21:35:43 <mariano|syzygy> with parsec is annoying to decorate everything with 'spaces'...
21:35:52 <mariano|syzygy> that's what I am trying to avoid by lexing first
21:47:10 <mmorrow> mariano|syzygy: just use alex/happy ?
21:57:42 <hackagebot> bindings-libffi 0.0.1 - Check bindings-common package for directions. (MauricioAntunes)
22:08:39 <dmwit> ?hackage bindings-common
22:08:39 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/bindings-common
22:12:04 <dmwit> hmm...
22:22:48 <hackagebot> bindings-libffi 0.0.2 - Check bindings-common package for directions. (MauricioAntunes)
22:26:42 <ivanm> OK, a new version in 25 minutes...
22:26:58 * ivanm wonders what was wrong with 0.0.1...
22:54:55 <hackagebot> yjftp 0.3.6 - CUI FTP client like 'ftp', 'ncftp' (YoshikuniJujo)
23:06:35 <mriou> huh, I have a problem that's a little too tricky for me
23:07:10 <mriou> I have a program with some global state so I have a Monad that's a transformer based on a Reader and IO
23:08:39 <mriou> in the same code I open a socket listening on an UDP port
23:09:00 <mriou> which needs to access the same global state
23:09:47 <mriou> however all the sockets code is strictly in IO
23:10:41 <mriou> how can I introduce my Monad in there?
23:11:05 <BMeph> @type lift
23:11:07 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
23:11:38 <BMeph> @type lift . print
23:11:39 <lambdabot> forall (t :: (* -> *) -> * -> *) a. (MonadTrans t, Show a) => a -> t IO ()
23:12:49 <mriou> I can lift IO in my Monad but not the other way around right?
23:14:39 <BMeph> mriou: It depends on your monad.
23:15:04 <mriou> BMeph let me publish some code
23:16:18 <mriou> http://gist.github.com/129569
23:17:35 <mriou> the handlerFn function passed to localServer has to be SockAddr -> String -> IO ()
23:18:13 <mriou> whereas I'd need SockAddr -> String -> ServerState ()
23:22:13 <mriou> Bmeph: does that make sense?
23:22:35 <mriou> sorry, BMeph
23:25:01 <mmorrow> mriou: what's the definition of GlobalData? if it's an IORef/MVar (or you put it in one) you can "tunnel" your ReaderT through the callback
23:26:08 <mriou> type GlobalData = (TVar RoutingTable, TVar RunningOpsTable, TVar KTree, Integer)
23:27:22 <mriou> mmorrow so if I put it in a IORef say, how would the "tunneling" work?
23:27:24 <mmorrow> hmm, ok since there's that Integer, you'll have to stick the whole thing in an IORef (MVar is it could be accessed concurrently)
23:29:01 <mriou> mmorrow so if I stick it in an IORef, how does that tunneling happen?
23:29:27 <mmorrow> mriou: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5862#a5862
23:30:45 <mmorrow> so that `tunnel' function takes the callback you wish was IO, and the function that wants an IO clalback, and then turns your callack into an IO one and gives that to the second arg, resulting in a ReaderT
23:31:06 <mmorrow> err, so you probably have to change that typesig to fit your situation though
23:31:24 <mmorrow> from tunnel :: (a -> ReaderT (IORef s) IO b) -> ((a -> IO b) -> IO c) -> ReaderT (IORef s) IO c
23:31:25 <mmorrow> to
23:31:52 <mmorrow> tunnel :: (SockAddr -> String -> ReaderT (IORef s) IO ()) -> ((SockAddr -> String -> IO ()) -> IO ()) -> ReaderT (IORef s) IO ()
23:32:17 <mmorrow> hmm, actually i dunno if you even need the IORef
23:32:32 <mriou> that was going to be my question :)
23:32:48 <mmorrow> yeah, drop the IORef :)
23:33:25 <mmorrow> (if it was StateT, i guess then you would)
23:34:14 <mriou> so in my case it would be  tunnel :: (SockAddr -> String -> ServerState ()) -> ((SockAddr -> String -> IO ()) -> IO ()) -> ServerState ()
23:34:26 <mriou> looks about right?
23:34:32 <mmorrow> ahh, yes
23:34:51 <mmorrow> just saw the deriving (Monad)
23:35:15 <mmorrow> so s/runReaderT/(runReaderT . runSS)/
23:35:26 <mmorrow> err, module a (.) or two
23:35:30 <mmorrow> *modulo
23:36:05 <mriou> yes, I have a runServer for that
23:36:14 <mriou> I pasted it just after the monad definition
23:36:23 <mmorrow> ah, nice
23:36:33 * mmorrow has too many windows open ;)
23:36:44 <mriou> no worries :)
23:37:11 <mriou> and IIUC I would pass (tunnel handlerFn) instead of handlerFn to the localServer function, correct?
23:37:52 <mmorrow> so you'd need to do something like:
23:38:30 <mmorrow> (\port myHandlerFn -> tunnel myHandlerFn (localServer port)) :: ServerState ()
23:38:32 <mmorrow> err
23:38:51 <mmorrow> (\port myHandlerFn -> tunnel myHandlerFn (localServer port)) :: Port -> ServerState ()
23:38:55 <mmorrow> gah
23:39:09 <mmorrow> (\port myHandlerFn -> tunnel myHandlerFn (localServer port)) :: Port -> (SockAddr -> String -> ServerState ()) -> ServerState ()
23:40:14 <mriou> I don't understand where I would use this (sorry)
23:40:32 <mmorrow> at the very top
23:41:05 <mriou> ah! got it
23:41:08 <mmorrow> :)
23:42:22 <mriou> that's nice, thanks a lot mmorrow!
23:42:33 <mmorrow> no problem :)
23:43:45 <mriou> I'll owe you a beer some day, you've answered to at least 3 or 4 of my questions :)
23:49:10 <roderyk> Is there a way I can retrieve any Modifier used when clicking on a TreeView (which normally generates a onCursorChanged callback)
23:49:31 <mmorrow> mriou: awesome :)
23:49:34 <roderyk> I'd like to differentiate between a shift+click and click on a row of the tree
23:52:35 <mmorrow> roderyk: i'm not familiar with gtk2hs, but seems like you'd need to do something like have every on* callback just stick the event in some queue, and then have another function that reads from the queue and interpretes the event stream somehow
23:53:08 <mmorrow> (or possibly there's a simpler way to do what you want with gtk2hs stuff directly)
23:54:31 <mmorrow> a Chan could be used for the queue
23:55:19 <roderyk> mmorrow: I suppose; currently onCursorChanged seems to do a lot already (which I would not like to replicate), because it tells me what row/column was selected. I suppose I could setup a queue just for set/reseting the shift-clicking and then have my onCursorChanged code check for that
23:55:22 <mmorrow> i dunno the deal with forkIO + gtk2hs though, but ideally the function reading from the Chan would be in another thread too
23:56:07 <roderyk> I like the new EventM stuff that they put into gtk2hs, which makes dealing with events more monadic, I suppose I'm just hoping someone thinks of porting all the other events over to it soon :)
23:57:14 <roderyk> mmorrow: I'm already using forkIO for other parts of the threaded app. (it's not bad, you just need to explicitly tell gtk2hs that you promise to keep all the gui stuff in a single thread and everything works fine)
23:58:04 <roderyk> alright, I suppose I should move this down my priority list... and go do something more productive (given the time frame). hehehe
