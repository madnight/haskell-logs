00:00:44 <dmwit> Whoa, a type long enough for lambdabot to wrap.
00:01:16 <idnar> regex-regex-0.72.regexRegex.Regex.Regex.RegexLike.NoReallyIts.ARegex.Regex
00:01:43 <dmwit> hehehe
00:02:01 <dmwit> regex regex regex regex regex regex mushroom mushroom!
00:14:29 <soupdragon> hi does anyone know this:
00:14:30 <soupdragon> "I frequently write Erlang code that builds a list which ends up backward, so I call lists:reverse at the very end to flip it around. This is a common idiom in functional languages. "
00:14:46 <soupdragon> in Haskell? is this common
00:14:53 <dmwit> No.
00:15:02 <die_sekte> no, reverse is slow.
00:15:03 <dmwit> I've used it maybe once or twice in two years.
00:15:08 <BONUS> very uncommon
00:15:28 <BONUS> reversing a list is very unlazy and runs in linear space and time
00:15:35 <dibblego> use foldr instead of foldl
00:15:37 <dmwit> Also, you seem to have invented a time machine that caused the beginning of your question to begin in the middle of your sentence!
00:16:14 <soupdragon> So this is basically a problem of erlang
00:16:25 <dmwit> I think the guy writing was just exaggerating.
00:16:32 <soupdragon> it doesn't happen in haskell, in lisp or ocaml you can use mutation rather than reverse
00:16:36 <soupdragon> in erlang you appear screwed
00:16:46 <solidsnack> Uhm, what?
00:16:57 <solidsnack> I use that idiom all the time in Haskell.
00:17:07 <Alpounet> Hi all.
00:17:16 <solidsnack> Built up a list recursive with `cons` and then reverse it on termination.
00:17:36 <dmwit> solidsnack: You should post such code to #haskell, we'll help straighten you out. ;-)
00:17:55 <solidsnack> dmwit: What would you do instead?
00:17:57 <dmwit> (It's not always possible, but sometimes.)
00:18:08 <Alpounet> Is there a Haskell and Neural Nets wizzard to help on finding the error on a backProp algorithm for a future Neural Net library ?
00:18:23 <Alpounet> wizard*
00:18:24 <dibblego> solidsnack, it depends on the case -- post an example
00:18:38 <solidsnack> Any case would be interesting.
00:19:35 <Cale> dibblego: Did you see http://www.rfc1149.net/inf355/2009/06/10/java-cest-mal/ ? You probably know that one well, but I thought it was amusing anyway :)
00:20:00 <dibblego> Cale, I did -- I used to have a trivia website that exploited that
00:20:35 <bnijk> |
00:20:45 <Alpounet> Caelum, you French ?
00:21:02 <Cale> Alpounet: I'm not French, but I know enough to read it, sort of :)
00:21:03 <Alpounet> Cale*
00:21:04 <dibblego> I can't read French, but the answer is "it depends on the implementation -- usually true then false"
00:21:08 <bnijk> "caelum" = "sky-blue"
00:21:12 <bnijk> or just "sky/heavens"
00:21:14 <bnijk> i don't remember
00:21:22 <bnijk> kjmmnnn
00:21:27 * bnijk finds ovid translations
00:21:29 <Alpounet> wrong completion, sorry
00:21:44 <Cale> Alpounet: I'm Canadian, so I took a bit of it in highschool.
00:21:51 <Alpounet> Heh, ok.
00:22:23 <Alpounet> Generally, people don't like French if it isn't their native language.
00:24:42 <C-Keen> is there a way to ask cabal on which platform I am building?
00:25:54 <C-Keen> (where platform should include os and architecture)
00:27:18 <bnijk> http://kotaku.com/5215836/pac+man-trashes-french-supermarket
00:29:05 <uzytkownik> @pl \g m -> insert (serverGroupName g) g m
00:29:05 <lambdabot> insert =<< serverGroupName
00:33:04 <Keal> #Keal Fan-Club for @Keal now open for business
00:33:08 <Keal> :D
00:33:22 <mmorrow> @keal
00:33:23 <lambdabot> my proof show math is broken right now
00:33:33 <mmorrow> @nixon
00:33:34 <lambdabot> You have to face the fact that whole problem is really the blacks. The key is to divise a system that reconizes this while not appearing to...
00:33:48 <mmorrow> @brain
00:33:49 <lambdabot> Uh, I think so, Brain, but we'll never get a monkey to use dental floss.
00:37:49 <mxc> wouldn't that be a pinky quote not a brain quote?
00:47:07 <Cale> @keal
00:47:08 <lambdabot> my very first computer was an 80-0840
00:47:29 <soupdragon> @keal
00:47:30 <lambdabot> last day i was in my lab i had a diagram which might have removed pi
00:48:53 <Cale> @keal
00:48:54 <lambdabot> my proof show math is broken right now
00:48:56 <Cale> @keal
00:48:57 <lambdabot> write an algorthim that generates the correct responses for a phone survey based on number of rings whether answered how quickly hung up on and the mood of the receiver
00:49:48 <uzytkownik> @hoogle mempty
00:49:48 <lambdabot> Data.Monoid mempty :: Monoid a => a
00:50:06 <Cale> > mempty :: [Integer]
00:50:08 <lambdabot>   []
00:50:43 <Cale> > mempty :: Sum Integer
00:50:45 <lambdabot>   Sum {getSum = 0}
00:50:55 <dirk_> I am trying to solve the problems appearing when I compile with -Wall
00:51:20 <dirk_> sometimes there is a non-exhaustive pattern match
00:51:22 <Cale> -Wall is really annoying... often the problems it reports are not problems.
00:51:32 <Cale> But yeah, it can catch things like that
00:51:44 <Cale> Though there are some false positives too
00:51:48 <dirk_> but I want my program to crash if such a pattern occurs
00:52:24 <dirk_> I mean it is better crash than to run on in an unexpected way
00:52:27 <uzytkownik> @pl \g m -> (M.insert (serverGroupName g) g m)
00:52:27 <lambdabot> M.insert =<< serverGroupName
00:52:27 <Cale> dirk_: You can always add a fall-through pattern with an error message
00:52:40 <dirk_> what does this mean
00:52:50 <sjanssen> dirk_: _ -> error "error message"
00:53:21 <sjanssen> dirk_: but I'd generally skip those, the compiler will automatically generate nice messages with source file and line number
00:53:29 <dirk_> I can just write it like that and everything will crash fine
00:53:47 <uzytkownik> @hoogle Monad ((->) r)
00:53:48 <lambdabot> Warning: Unknown type Monad
00:53:48 <lambdabot> Prelude undefined :: a
00:53:48 <lambdabot> Data.Array.Base arrEleBottom :: a
00:54:08 <dirk_> ok so I will just stick to what the compiler is doing and not care about -Wall anymore
00:54:11 <sjanssen> dirk_: if you don't want to be warned about non-exhaustive patterns, you can turn that flag off seperately
00:54:44 <dirk_> yes I can
00:55:04 <Jedai> dirk_: there's an interesting tool called Catch that can do some work to prove that your non-exhaustive patterns are justified in a closed module
00:55:25 <dirk_> ok
00:56:23 <Jedai> dirk_: it analyze the source code and check that the cases you didn't put in your pattern can't happen
00:56:32 <Jedai> *cannot
00:56:40 <dirk_> I see
00:56:53 <dirk_> I am not sure I try it but it is good to know
01:00:19 <yitz> uzytkownik: Control.Monad.Instances
01:00:31 <uzytkownik> yitz: Thanks
01:07:02 <ike_> Hello, I'm learning "How to writing a programming in Haskell style" by the book "Programming of Algebra", Richard Bird and Oege de Moor
01:07:37 <ike_> The book is not for Haskell, but more generally, for functional programming, though.
01:08:01 <C-Keen> hello ike_
01:08:41 <ike_> In my opinion, we need both of two kinds of books; one is like "Real World Haskell" for in practice
01:09:18 <ike_> Aha, it is typo; "Algebra of Programming", correctly
01:09:24 <C-Keen> ike_: For functional programming in haskell there is also "The Craft of Funcitonal Programming"
01:09:55 <ike_> C-Keen: Thanks, yes I have it and had read already.
01:10:49 <C-Keen> ike_: here is a more comprehensive list http://www.haskell.org/haskellwiki/Books_and_tutorials
01:12:11 <ike_> I meant, a Haskell programmer may need some categorical view for concise and clean
01:13:21 <C-Keen> ike_: I agree
01:13:51 <dcoutts> C-Keen: yes
01:14:07 <dcoutts> C-Keen: re, cabal and platform I mean
01:14:17 <C-Keen> dcoutts: nice! how :)
01:14:31 <dcoutts> C-Keen: depends what context and what you're trying to do exactly
01:14:57 <ike_> The "Algebra of Programming" is old, however, it fits to me because thinner than "Craft of Functional Programming"
01:14:57 <C-Keen> dcoutts: I want to replace droundy's franchise functions with cabal ones where appropriate
01:15:21 <dcoutts> C-Keen: ah, ok. Then in the Setup.hs use Distribution.System, check the docs
01:15:23 <ike_> easy to understand
01:15:35 <C-Keen> dcoutts: thanks for that hint!
01:16:04 <ike_> I wonder if "Algebra of Programming" was written in Haskell...
01:17:14 <ike_> and not to write such as "a function f :: B <- A" (the opposite arrow)
01:19:38 <ike_> dcoutts: Thanks to your post to reddit about "Rewrite of the IO library, including Unicode support"
01:20:05 <ike_> It is important work, especially, using Unicode for native languages
01:21:03 <dcoutts> ike_: it's all the work of JaffaCake, thank him not me :-)
01:21:52 <ike_> Thank JaffaCake
01:22:25 <JaffaCake> ike_: you're welcome ;)
01:51:56 <mxc> ?seen keal
01:51:56 <lambdabot> I saw keal leaving #haskell 1h 14m 40s ago, and .
02:21:33 <oal> anyone doing data parallel haskell here?
02:56:56 <uzytkownik> @hoogle split
02:56:56 <lambdabot> Data.ByteString split :: Word8 -> ByteString -> [ByteString]
02:56:56 <lambdabot> Data.IntMap split :: Key -> IntMap a -> (IntMap a, IntMap a)
02:56:56 <lambdabot> Data.IntSet split :: Int -> IntSet -> (IntSet, IntSet)
02:57:22 <uzytkownik> @hoogle Arrow a b -> Arrow a (b, b)
02:57:22 <lambdabot> Warning: Unknown type Arrow
02:57:22 <lambdabot> Control.Arrow (&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
02:58:30 <yitz> @go hackage split
02:58:31 <lambdabot> No Result Found.
02:59:38 <yitz> uzytkownik: http://hackage.haskell.org/package/split
03:04:49 <uzytkownik> @pl \x -> trace x x
03:04:50 <lambdabot> join trace
03:06:07 <uzytkownik> @pl \x -> trace x $ return x
03:06:08 <lambdabot> ap trace return
03:07:26 <uzytkownik> @hoogle trace
03:07:26 <lambdabot> Debug.Trace trace :: String -> a -> a
03:07:27 <lambdabot> module Debug.Trace
03:07:27 <lambdabot> package traced
03:08:02 <uzytkownik> @hoogle ap
03:08:03 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
03:08:03 <lambdabot> Control.Arrow app :: ArrowApply a => a (a b c, b) c
03:08:03 <lambdabot> Language.Haskell.TH AppE :: Exp -> Exp -> Exp
03:08:46 <uzytkownik> @pl \x -> trace (show x) $ return x
03:08:46 <lambdabot> liftM2 trace show return
03:11:22 <mmorrow> , (text . utf8enc) "\x2200"
03:11:25 <lunabot>  ∀
03:11:32 <mmorrow> , "\∀"
03:11:33 <lunabot>  luna: luna: panic! (the 'impossible' happened)
03:11:35 <ivanm> mmorrow: stop showing off!
03:11:59 <mmorrow> ivanm: :)
03:14:17 <yitz> @pl \f g x -> f (g x) x
03:14:17 <lambdabot> flip flip id . liftM2
03:14:24 <yitz> @pl \g x -> f (g x) x
03:14:24 <lambdabot> (f =<<)
03:14:42 <yitz> so why not just (=<<) for the first one?
03:14:50 <fasta> Does the GSoC heap profile viewer work already (in that I can download it and have it working in 5 minutes)?
03:15:30 <ivanm> fasta: probably takes at least 6 minutes
03:15:31 <ivanm> ;-)
03:17:52 <ivanm> @pl \ x xs -> if (x `elem` xs) then (x : delete x xs) else xs
03:17:52 <lambdabot> join . ap (ap . (if' .) . elem) (liftM2 (.) (:) delete)
03:17:52 <uzytkownik> yitz: That's not it. I'm searched something for (arr id &&& arr id)
03:18:00 <ivanm> ^^ is there a neater/better way of doing this?
03:20:53 <quicksilver> ivanm: "if x is in the list then pull it to the top" ?
03:21:01 <fasta> ivanm: you can install it in 5 minutes.
03:21:04 <ivanm> quicksilver: yup
03:21:12 <ivanm> fasta: fine, I was wrong
03:21:14 <ivanm> ;-)
03:21:15 <quicksilver> can't think of one.
03:21:19 <ivanm> quicksilver: *nod*
03:21:20 <fasta> ivanm: about to find out whether it does something useful  :)
03:21:26 <quicksilver> you could do it in one pass
03:21:32 <quicksilver> with a custom foldr
03:21:48 <quicksilver> but I normally wouldn't bother
03:21:49 <ivanm> I'm tempted to just prepend it anyway, but then I'll have to manually go and check if that dir exists before using it :s
03:21:53 <ivanm> quicksilver: *nod*
03:22:27 <fasta> ivanm: Unexpectedly, it does not: hp2any-graph: thread blocked indefinitely
03:22:33 <ivanm> heh
03:42:30 <blueflute> I'm new to haskell (just started today) and I am unable to figure out how one can access the nth element of a tuple. When I search for it I end up with results that show nth element of a list...
03:43:00 <fasta> You can't in Haskell 98.
03:43:09 <QtPlaty[HireMe]> In general you can't.
03:43:15 <blueflute> oh
03:43:34 <fasta> blueflute: if you use Template Haskell, you can, but since you started today, you can't.
03:43:40 <Vanadium> Hah
03:43:54 <ivanm> fasta: hey, I've been using Haskell for a few years now, and I _still_ can't!
03:44:01 <QtPlaty[HireMe]> fasta: What is the problem your trying to solve.
03:44:02 <ivanm> and from what I"ve heard of TH, I don't want to!
03:44:03 <ivanm> ;-)
03:44:38 <fasta> ivanm: I have the same opinion on TH, untill the API is sanely documented and is complete.
03:44:56 <ivanm> and it's proven that it can be implemented on other compilers?
03:45:02 <blueflute> I am following this tutorial: http://learnyouahaskell.com/starting-out and they have this: let triangles = [ (a,b,c) | c <- [1..10], b <- [1..10], a <- [1..10] ]
03:45:09 <blueflute> followed by let rightTriangles = [ (a,b,c) | c <- [1..10], b <- [1..c], a <- [1..b], a^2 + b^2 == c^2]
03:45:18 <blueflute> I was trying to build rightTriangles from the triangles list
03:45:33 <fasta> QtPlaty[HireMe]: I was answering a question. I don't think anyone can help with the problem I am working on.
03:45:49 <ivanm> blueflute: [ (a,b,c) | (a,b,c) <- triangles, a^2 + b^2 == c^2]
03:46:09 <ivanm> fasta: presumably, QtPlaty[HireMe] meant s/fasta/blueflute/
03:46:16 <blueflute> ahh, okay, that's just like in python.
03:46:34 <blueflute> ivanm, I don't know if he meant that, but I mistkanely did end up reading it that way ....
03:46:44 <blueflute> also thanks ivanm
03:46:48 <ivanm> no worries
03:46:50 <fasta> ivanm: yes, but it's still fun to answer :)
03:47:04 <ivanm> heh
03:48:32 <blueflute> thanks everyone, I love haskell so far. Hope to get comfortable with it in a few weeks (few = well over 52)
03:48:39 <ivanm> heh
03:48:45 <Questioner> Quickquestion, I'm having some trouble understanding what fix does in Data.Function. it seems to just crash ghci
03:48:50 <sundro1> lol
03:48:54 <Questioner> > fix id
03:49:00 <lambdabot>   mueval-core: Prelude.read: no parse
03:49:00 <lambdabot>  mueval: ExitFailure 1
03:49:16 <Questioner> > fix (+1)
03:49:21 <lambdabot>   mueval-core: Prelude.read: no parse
03:49:21 <lambdabot>  mueval: ExitFailure 1
03:49:24 <Questioner> :(
03:50:06 <doserj> > fix (1:)
03:50:07 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
03:50:31 <Questioner> lol, webchat made it a smily
03:52:24 <Questioner> ok, so it applies a function infinitely many times on itself, but why does fix (1+) crash instead of giving a stack error like i would expect
03:52:27 <fasta> Questioner: it's like asking why 1: goto 1 does not terminate.
03:53:44 <Questioner> lol, i didn't expect it to terminate
03:53:50 <Questioner> just crash with a stack error or something
03:53:54 <Questioner> and not silently crash
03:54:16 <RAndrew> there is fix point for (+1)?
03:54:38 <RAndrew> like x=x+1
03:54:53 <fasta> Questioner: define crash
03:56:15 <Questioner> fasta it just exists
03:56:23 <Questioner> exits
03:56:31 <Questioner> with no message
03:56:41 <fasta> Questioner: what does? lambdabot?
03:56:44 <quicksilver> Questioner: mueval has a timeout
03:56:57 <quicksilver> Questioner: (the error message failos to make it clear it has timed out)
03:57:24 <ivanm> fix error is a cool one... just not here ;-)
03:57:37 <Questioner> heheh
03:57:52 <Maddas> Questioner: I do get a stack overflow.
03:58:07 <RayNbow> Questioner: what version of GHC are you using?
03:58:11 <Questioner> hahahhha nice one ivanm
03:58:29 <Questioner> 6.10.1
03:58:40 <RayNbow> that one has crash bugs :p
03:58:53 <RAndrew> wait for 2 mins on fix (+1) and happend nothing, just aborted it
03:59:05 <RayNbow> > let loop = loop in loop   -- try this one in ghci 6.10.1
03:59:10 <lambdabot>   mueval-core: Prelude.read: no parse
03:59:10 <lambdabot>  mueval: ExitFailure 1
03:59:16 <RayNbow> it will exit to your prompt immediately
03:59:20 <RayNbow> (or at least under Windows)
04:00:56 <Questioner> RayNbow also just exits
04:01:08 <RAndrew> nope, nothing, no mem licks, no cpu overload, just hangs for me :)
04:01:19 <RayNbow> Questioner: upgrade to GHC 6.10.3 :)
04:01:24 <fasta> RayNbow: in 6.10.2 I get a core dump when I press C-c but that has already been fixed.
04:01:42 <Questioner> RayNbow that one has an annoying POSIX readline bug
04:02:14 <RayNbow> I'm not familiar with that one
04:03:07 <blueflute> 32.5 :: (Fractional t) => t is what I get if I try ":t 32.5"
04:03:15 <blueflute> Fractional seems to be like a baseclass for Float and Double types
04:03:28 <blueflute> am I right if I say that?
04:03:37 <QtPlaty[HireMe]> Almost.
04:04:02 <QtPlaty[HireMe]> blueflute: Fractional is a typeclass of which Float and Double are instinces.
04:04:17 <Questioner> RayNbow pasting something in ghci on any POSIX system just pastes the first letter and not the whole thing
04:04:24 <QtPlaty[HireMe]> instances
04:04:31 <Questioner> it's been fixed, but I assume they'll release it in the next version
04:04:41 * blueflute tries to look up what a typeclass is
04:06:47 <RayNbow> Questioner: ah
04:07:11 <blueflute> What I could gather from the Internets is that it is like an Abstract base class and Float and Double are derived classes that can actually be instantiated...
04:07:33 * blueflute hopes that all this will seem obvious and simple in "a few" weeks
04:07:41 <quicksilver> blueflute: that's not a bad start, but
04:07:48 <quicksilver> blueflute: it's much better to forget everything you know about classes.
04:07:57 <quicksilver> (from languages like C++ and Java)
04:08:03 <quicksilver> haskell typeclasses are something different.
04:08:14 <blueflute> quicksilver, okay, got that. I'll try to clear out my head and start from scratch
04:08:16 <quicksilver> the key point is that haskell classes are not types.
04:08:22 <quicksilver> (whereas C++ classes *are* types)
04:08:30 <blueflute> okay
04:09:10 <quicksilver> so, Int and Float are types.
04:09:18 <quicksilver> Integral and Floating are classes.
04:09:23 <quicksilver> types are members of classes.
04:09:28 <quicksilver> @instances Integral
04:09:29 <lambdabot> Int, Integer
04:09:42 <quicksilver> for example, those are the two standard instances (members) of Integral.
04:09:57 <blueflute> okay
04:15:28 <soupdragon> 11. Chuck Norris can write infinite recursion functions…and have them return.
04:19:48 <nikki93> Hey guys! It's been a while. I was 'C++ing'. :)
04:20:01 <Badger> nikki93: you're a terrible person.
04:20:06 <nikki93> :(
04:20:14 <ivanm> have you re-seen the light now?
04:20:31 <nikki93> No. Just was messing around with Haskell.
04:20:51 <Zao> Well, Haskell tends to make your C++ code either better or worse.
04:21:01 <soupdragon> lol
04:21:23 <soupdragon> Haskell has a profound effect on me, I am not sure if it's for better or worse
04:21:39 <nikki93> This year in school we have C++ and we wrote a square-root-for-perfect-squares thing, and then a recursive definition struck me.
04:21:46 <nikki93> http://codepad.org/4Jl1zlMB
04:21:52 <nikki93> Haskell's fun. :)
04:21:58 <ivanm> Zao: worse as in "see, if I was allowed to do this in Haskell it would be a _lot_ better!" ? :p
04:22:32 <Zao> ivanm: A Haskeller in C++ tends to drive his cow-orkers insane.
04:22:44 <nikki93> Zao: You must mean co-workers.
04:22:52 <ivanm> nikki93: no, he said what he meant
04:23:01 <ivanm> people using C++ are part of a herd
04:23:02 <ivanm> ;-)
04:23:08 <nikki93> ivanm: 'cow' makes sense, but 'orkers'?
04:23:20 <ivanm> nikki93: sshhhh, you're ruining my argument here!
04:23:35 <nikki93> http://www.urbandictionary.com/define.php?term=cow+orker
04:23:36 <p_l> nikki93: you haven't been to ASR, right? ;D
04:23:51 <nikki93> Have you seen my squareroot function yet? :(
04:23:57 <nikki93> I like it. :)
04:24:08 <ivanm> http://www.urbandictionary.com/define.php?term=orker
04:24:32 <nikki93> lambdabot: [1,3..]!!3
04:24:46 <ivanm> > [1,3..] !! 3
04:24:47 <lambdabot>   7
04:24:55 <soupdragon> I don't get it nikki
04:25:05 <nikki93> I could replace '2*i + 1' with that. :)
04:26:15 <nikki93> > squareroot(9,0) where squareroot(x,i) = if x > 0 then squareroot(x - ([1,3..] !! i), i + 1) else i
04:26:16 <lambdabot>   <no location info>: parse error on input `where'
04:26:21 <nikki93> > squareroot(9,0); where squareroot(x,i) = if x > 0 then squareroot(x - ([1,3..] !! i), i + 1) else i
04:26:22 <lambdabot>   <no location info>: parse error on input `;'
04:26:36 <soupdragon> > 9 - 1 - 3
04:26:38 <lambdabot>   5
04:26:40 <soupdragon> > 9 - 1 - 3 - 5
04:26:41 <nikki93> How do you get 'where' in lambda bot? I don't remember. :(
04:26:41 <lambdabot>   0
04:26:51 <soupdragon>  5 is the square root of 9?
04:26:54 <ivanm> nikki93: let foo = bar in foo 3
04:27:01 <soupdragon> > squareroot(9,0) where squareroot(x,i) = if x > 0 then squareroot(x - ([1,3..] !! i), i + 1) else i
04:27:02 <lambdabot>   <no location info>: parse error on input `where'
04:27:04 <ivanm> soupdragon: not last I checked...
04:27:13 <ivanm> soupdragon: can't use where's with lambdabot
04:27:16 <nikki93> soupdragon: The number of times you subtract is squareroot.
04:27:28 <ivanm> > let squareroot(x,i) = if x > 0 then squareroot(x - ([1,3..] !! i), i + 1) else i in squareroot(9,0)
04:27:29 <soupdragon> oh right 2 in this case
04:27:30 <nikki93> > let squareroot(x,i) = if x > 0 then squareroot(x - ([1,3..] !! i), i + 1) else i in squareroot(9,0)
04:27:30 <lambdabot>   3
04:27:31 <lambdabot>   3
04:27:41 <nikki93> Yay. :)
04:27:45 <Jedai> nikki93: where is attached to a definition, not to an expression so you would rather use let than where in lambdabot
04:27:58 <Jedai> ivanm: not completely true, look :
04:27:59 <ivanm> nikki93: using a list there is probably inefficient...
04:28:00 <nikki93> Jedai: Ok.
04:28:04 * Axman6 finds writing f(x,y) strange, there should be a space there
04:28:11 <Jedai> > let a = b where b = 5 in a
04:28:12 <lambdabot>   5
04:28:17 <nikki93> Axman6: I write spaces too usually, yeah.
04:28:17 <ivanm> Axman6: I was copy-pasting ;-)
04:28:23 <ivanm> Jedai: ahhh, OK
04:28:27 <ivanm> fair enough
04:28:28 <soupdragon> [1][2][3]
04:28:32 <soupdragon> [2][2][3]
04:28:34 <soupdragon> [3][3][3]
04:28:40 <nikki93> soupdragon: ?
04:28:41 <soupdragon> that's how it works nikki I guess
04:29:08 <soupdragon> if you sum 2*i+1 it always makes a square
04:29:26 <nikki93> soupdragon: Say I have a square, x^2. Then, (x + 1)^2 = x^2 + 2x + 1, which is x^2 plus the next odd number. That's why.
04:29:50 <nikki93> soupdragon: So the next perfect square is this one, plus 2*(squareroot of the old number) + 1.
04:30:24 <soupdragon> I can't really follow that It doesn't make sense
04:30:43 <soupdragon> 9^2 = (8+1)^2 = ?
04:31:06 <soupdragon> ok I see
04:31:24 <nikki93> 8^2 + 2*8 + 1. 2*8 + 1 is the 9th odd number.
04:31:39 <nikki93> 8^2 is the previous perfect square.
04:32:01 <soupdragon> the algorithm basically goes through 1^2 and 2^2 and 3^2 but you don't have to do any multiplication
04:34:32 <nikki93> In C++ it would be something like for (int i = 0; n > 0; ++i, n -= 2*i +1); and then i would contain the square root.
04:37:36 <Questioner> does anyone know if there's a library that converts the Match type from Language.Haskell.Exts to lamda calculus?
04:39:45 <roderyk> Does anyone know of a version of gtk2hs and Haskell Platform that are compatible/installable on Windows? last time I tried gtk2hs 0.10.0 with an older Haskell platform version, and the gtk would not install. I see both have newer releases, any chance someone tested this already?
04:40:38 <dcoutts> roderyk: I expect that the first release of the HP, which came with ghc-6.10.2, will work with the latest release of gtk2hs which had a windows installer built against ghc-6.10.2
04:40:53 <dcoutts> roderyk: but you would not be able to use the later HP release since that uses ghc-6.10.3
04:42:25 <Axman6> hmm, OT i know, but how would you write an array in C to disk, in a way it could be read back in?
04:42:28 <Zao> dcoutts: The latest gtk2hs is built against .1
04:42:52 <roderyk> dcoutts: that's what I was wondering about; thanks. I will try to see if I can get the first HP release working with the new gtk2hs - need to go find a windows laptop to test that out ;)  This would be a big boost for me, considering I would like to ask some windows user to test my app... and giving them 2 pages of compiling instructions is not pleasant :)
04:42:52 <Zao> I didn't have much luck at all building gtk2hs myself against .2 or .3.
04:43:05 <Zao> But that's probably mostly because the gtk2hs build chain is braindead.
04:43:35 <Zao> roderyk, dcoutts: Where's this fabled 6.10.2-compliant gtk2hs installer?
04:43:37 <dcoutts> Zao: are you sure? I know the download says it works with 6.10.1, but it really means .2, did they still build the windows release with .1?
04:43:46 <koala_man> Axman6: like you'd use serialization in better languages?
04:44:01 <Axman6> heh, probably
04:44:12 <Zao> dcoutts: I'm fairly sure the installer whined greatly when trying to install it against the previous platform.
04:44:19 <Axman6> just needs to be a (large) array of 64 bit words
04:44:31 <dcoutts> Zao: ho hum.
04:44:35 <Axman6> http://www.java2s.com/Code/C/File/Readandwritearrayintofile.htm seems to be a pretty good guide
04:44:43 <koala_man> Axman6: so no nesting or pointers or anything
04:44:44 <Zao> dcoutts: In any way, I do not believe that that version contains the finalizer hacks recently added to the SVN.
04:45:04 <Axman6> nope, plain old malloc'd array
04:45:13 <dcoutts> Zao: it's odd since the whole point of the Gtk2HS 0.10.1 release was that it added compatibility with ghc-6.10.2
04:45:23 <Zao> dcoutts: I see.
04:45:38 <roderyk> dcoutts, Zao: I know 0.10.0 whined against the original HP; so what I'm wondering is which HP and gtk to try... (what is this finalizer hack? and is it app-critical?)
04:45:56 <dcoutts> Zao: again, I'm surprised, since I though that was exactly the point, that it handled the change in ghc finalisers
04:46:25 <dcoutts> roderyk: well you can find out! :-) try Gtk2HS 0.10.1 with the original HP and report back
04:46:47 <Zao> dcoutts: Seems that I had misread the dates on the commits on the mailing list.
04:46:48 <roderyk> dcoutts: will do :-)  (just sometime later today...)
04:47:12 <Zao> Fixes for .2 were in around the beginning of april.
04:47:30 <Zao> It'd be nice if the critical typo on the front page was fixed though.
04:48:51 <dcoutts> Zao: I've reported it at least once, you can try again :-)
04:49:35 <CalJohn> Am I right in saying that recursive operators on lists list Data.List.filter are O(n)?  If that's true, then is cheap insertion into an ordered datastructure the main point of Data.Set?
04:49:41 <Zao> roderyk: http://sourceforge.net/mailarchive/forum.php?thread_name=37df87420905151910n280c1768v8ac99c22386af4ac%40mail.gmail.com&forum_name=gtk2hs-devel
04:49:46 <CalJohn> s/point/purpose
04:50:13 <Zao> That may be interesting for you, some lad that has built 0.10.1 against 6.10.3
04:50:44 <dcoutts> CalJohn: if you're using a list as a set, then yes Data.Set will almost always be faster
04:52:33 <CalJohn> dcoutts: well, sometimes, it seems.  if I don't care about order, then I'm guessing the union operator (++) and insert (:) are no faster with Data.Set than with Data.List
04:52:36 <roderyk> Zao: thanks, will try that out later as well.
04:52:50 <CalJohn> but time complexity isn't specified on Data.List's haddock page
04:53:10 <Zao> roderyk: The same here, but I'm trapped at work now.
04:53:41 <dcoutts> CalJohn: complexity on lazy lists is a bit subtle. eg filter is O(n) in the number of elements you consume, not the length of the list.
04:54:26 <roderyk> Zao, dcoutts: one day gtk2hs will be cabalized right? or is that just wishful thinking? :-)
04:54:38 <dcoutts> CalJohn: depending on how you associate ++ it may be faster or slower than Data.Set. Note also that ++ will not eliminate duplicates like Data.Set does.
04:54:44 <dcoutts> roderyk: one day, yes.
04:55:09 <Zao> It feels like the autotools mess it uses now has lots of embedded magic.
04:55:28 <Zao> I had to apply ample amounts of violence to it to spit out a half-decent build.
04:55:45 <CalJohn> dcoutts: I hadn't thought of that (lazy complexity).  Is Set lazy also?
04:55:58 <Zao> Too long paths to ar, can't handle spaces anywhere, unixification at the wrong times, etc.
04:56:19 <dcoutts> CalJohn: no, Set is strict, at least in as much as the Ord operations
04:56:54 <dcoutts> Zao: it does actually build on windows, what were you trying to do?
04:57:08 <wind_> can you here please recommend  any open source apps that is good for learning Haskell? thanks.
04:57:17 <Zao> dcoutts: I was trying to build gtk2hs against existing gtk libs.
04:57:33 <Zao> dcoutts: In a GHC-friendly MSYS+MinGW environment.
04:57:59 <dcoutts> Zao: sounds like what we do for the normal windows build
04:58:02 <Zao> The first hurdle is that the HP installs by default to a spaceful path [Program Files (x86)].
04:58:26 <dcoutts> Zao: just requires pkg-config to say where gtk libs are
04:58:33 <dcoutts> Zao: yes, spaces would be a problem.
04:58:49 <Zao> The second hurdle is that when it starts making ar archives, it feeds all objects at the same time to ar, which blows up due to a too long path.
04:59:27 <Zao> Yeah, the GTK libs were found with pkg-config.
04:59:47 <Zao> I might've gotten libraries unsuitable for use with this particular compiler combo or something.
04:59:59 <Zao> It has worked in the past to build configure-needing packages.
05:00:02 <dcoutts> Zao: hmm, there's logic in there to use xargs for the really long ar calls
05:00:13 <dcoutts> Zao: but perhaps that's only used for the split-objs case
05:01:00 <Zao> It may of course be me mishandling things. I'm most at home with VS.
05:01:19 <dcoutts> Zao: it's certainly a bit fragile
05:01:50 <Zao> My setup is roughly the one on http://hackage.haskell.org/trac/ghc/wiki/Building/Preparation/Windows
05:46:31 <ManateeLazyCat> Hi all, i want use binary tree in Haskell, and saw have two implement in Cabal: AvlTree, bktree, and have other implement tree? Thanks!
05:48:19 <Axman6> ManateeLazyCat: Data.Tree
05:48:31 <ManateeLazyCat> Axman6: Of course. :)
05:48:55 <doserj> Data.Tree is not a binary tree
05:49:19 <ManateeLazyCat> Yep.
05:49:20 <Axman6> it can be
05:49:35 <ManateeLazyCat> Just simple Tree... And i ask binary tree implement.
06:08:23 <quicksilver> ManateeLazyCat: well, binary tree alone is not interesting; normally you plan to use it for something.
06:08:31 <quicksilver> Data.Map and Data.Set are based on binary trees.
06:08:41 <quicksilver> IntMap and IntSet are patricia tr(i/e)es
06:08:55 <quicksilver> avltree is a general tree for whatever you want.
06:09:17 <ManateeLazyCat> quicksilver: Thanks, i see.
06:09:48 <ManateeLazyCat> quicksilver: I have install avltree.
06:10:30 <themroc> hmm how do i realize multiple putStrLn calls in one function call best?
06:10:41 <themroc> is do the only way?
06:10:53 <ManateeLazyCat> quicksilver: Data.Set is base on binary tree, interested, so the search efficient is Log (n).
06:11:30 <ManateeLazyCat> printf?
06:11:34 <ManateeLazyCat> :t printf
06:11:35 <lambdabot> forall r. (PrintfType r) => String -> r
06:11:47 <quicksilver> themroc: do is only syntactic sugar.
06:11:55 <doserj> @type mapM_ putStrLn ["Hello", "world"]
06:11:56 <quicksilver> putStrLn "hello" >> putStrLn "wolrd"
06:11:56 <lambdabot> IO ()
06:12:03 <jutaro> themrock: mapM_ putStrLn ["x","y",...]
06:12:42 <themroc> hmmm
06:12:50 <themroc> ok let me try
06:13:15 <themroc> damn ive put a club mate in the freezer and now its frozen... ice mate :p
06:13:26 <themroc> forgot to take it out soon enough hehe
06:14:01 <spookylukey> themroc: sequence_ [putStrLn "x", putStrLn "y"]
06:14:04 <Botje> icicle!
06:15:36 <themroc> i am very new to haskell, so i wonder if its not "good code" to have stuff sequential
06:16:00 <themroc> im coming from oop, so its quite some rethink i have to do
06:16:09 <Botje> themroc: try doing without IO for a while
06:16:10 <fasta> themroc: you cannot do everything in parallel.
06:16:12 <Botje> just focus on algorithms
06:16:19 <fasta> themroc: imagine going up and down at the same time.
06:16:28 <Botje> once you get out of the sequential habit, it'll go better
06:16:35 <themroc> i dont want parallel but sequental?
06:16:50 <themroc> like i call a function and the function is doing several calculations
06:16:55 <fasta> There is nothing wrong with thinking sequentially.
06:16:59 <themroc> and then printing stuff
06:17:03 <ikegami__> or think the type before writing a code (i'm joking)
06:17:30 <ManateeLazyCat> themroc: Just keep in this channel and write Haskell code everyday, then you can expoert Haskell  whatever you come from (OOP).
06:17:40 <themroc> i hve to print out some ascii art with haskell :p
06:17:45 <themroc> nice homework hehe
06:18:00 <themroc> and it gets the width as parameter
06:18:08 <ikegami__> then you have to learn about the category theory and finally you become ... (continue joking)
06:18:28 <themroc> :p
06:19:04 <themroc> but yeah i sortof begin to like haskell very much
06:19:07 <themroc> much more than prolog
06:19:33 <ikegami__> the pattern matching systems are similar
06:19:41 <themroc> yup i realized
06:19:49 <ManateeLazyCat> themroc: Haskell is a so cool language.
06:19:57 <frostegard> hey. how would i encrypt a bytestring (serialized from a simple data structure) using the crypto libraries? they don't seem to accept anything else than numbers as plaintext.
06:21:17 <fasta> frostegard: http://hackage.haskell.org/packages/archive/pkcs1/1.0.2/doc/html/Codec-Encryption-PKCS1.html
06:21:19 <ivanm> frostegard: you could do ByteString -> String -> [Int]
06:21:22 <fasta> frostegard: what's wrong with that?
06:21:23 <ivanm> but that's probably bad...
06:21:33 <themroc> btw is there a source for comparisation of c to haskell?
06:21:36 <fasta> frostegard: not that I think RSA is a particularly strong system.
06:21:46 <themroc> i still think too much of global vars etc
06:21:57 <ManateeLazyCat> themroc: Don't use global vars.
06:22:00 <ivanm> fasta: :o
06:22:01 <ivanm> why not?
06:22:16 <ManateeLazyCat> themroc: You can use IORef or Monad.
06:22:32 <ikegami__> or unsafeIO things
06:22:34 <themroc> i read some stuff abou monad but didnt understand yet
06:22:43 <ManateeLazyCat> themroc: IORef and State Monad can instead global variable.
06:22:54 <ManateeLazyCat> ikegami__: Don't use unsafeIO.
06:22:59 <frostegard> fasta: i'll check that out, thanks
06:23:05 <ManateeLazyCat> themroc: Before me too.
06:23:09 <ivanm> ManateeLazyCat: "can instead global variable"? :s
06:23:11 <ManateeLazyCat> themroc: Read again. :)
06:23:19 <ikegami__> ManateeLazyCat: sorry, I'm joking.
06:23:25 <ManateeLazyCat> ivanm: Not instead, just other style.
06:23:41 <ManateeLazyCat> ivanm: Another method that keep status.
06:23:44 <ivanm> do you mean "use .... instead of"?
06:23:52 <ivanm> @slap ikegami__
06:23:52 * lambdabot pushes ikegami__ from his chair
06:23:57 <ivanm> don't confuse the new guy!
06:24:01 <ManateeLazyCat> ivanm: I never use global variable in my Haskell code.
06:24:06 <ivanm> ManateeLazyCat: neither do I
06:24:20 <ManateeLazyCat> ivanm: Yep, i'm confused too.
06:24:25 <ivanm> heh
06:24:51 <ManateeLazyCat> ivanm: Every haskell newbie will be confused, otherwise he can't understand Haskell.
06:25:03 <ivanm> ManateeLazyCat: OK, needlessly confuse
06:25:03 <ManateeLazyCat> Confused deeper, understand deeper.
06:25:26 <ivanm> don't tell them to use unsafe, etc. now, in which case they'll be confused the wrong way
06:25:36 <ikegami__> When I was a newbee, I looked for how to make a grobal variable, neither a function has to too many arguments...
06:25:44 <ivanm> also, I probably wouldn't have told him about IORef or State now...
06:25:44 <osfameron> confusion needs to be rationed as a newbie
06:25:52 <ManateeLazyCat> ikegami__: Still have too many argument?
06:25:57 <ikegami__> no
06:26:21 <fasta> ivanm: I think it is well within the capabilities of certain governments to crack 1024 bits keys within a reasonable amount of time. Now, keys of size 100000 might be a real problem.
06:26:25 <ivanm> "here's your daily serve of confusion; no, you cannot have some more; hey, don't hit him and take his confusion away from him!"
06:26:29 <ivanm> osfameron: ^^ like that? ;-)
06:26:38 <osfameron> exactly!
06:26:48 <ivanm> fasta: I wonder which governments you're thinking of...
06:26:50 <osfameron> we need confusion monitors around to make sure that everyone plays fairly with their confusion
06:26:50 <ManateeLazyCat> Tha's true.
06:26:59 <fasta> ivanm: the RSA challenges are also witdrawn btw.
06:26:59 <ivanm> though realistically, which other public key crypto system is there?
06:27:11 <ivanm> and would you trust something like ThreeFish?
06:27:18 <ivanm> fasta: which challenges?
06:27:26 <ivanm> osfameron: confusion police?
06:27:38 <themroc> sequence works like a charm
06:27:40 <themroc> nice
06:27:40 <osfameron> ivanm: I was thinking like playground monitors ;-)
06:27:48 <ivanm> ahhhh
06:27:52 <fasta> ivanm: http://www.rsa.com/rsalabs/node.asp?id=2093
06:28:00 <fasta> withdrawn*
06:28:18 <ivanm> >_>
06:28:27 <ivanm> fasta: so how do _you_ encrypt your information?
06:28:38 <fasta> ivanm: I don't have a lot of secrets ;)
06:28:44 <ivanm> heh
06:28:55 <ivanm> would you trust threefish or something?
06:30:03 <themroc> another question: in a sequence i need to do some calculations, how can i introduce a var in that?
06:30:14 <ivanm> in the function?
06:30:18 <ivanm> depends on what you're doing
06:30:19 <themroc> test = sequence [x = 1, putStrLn ("1"), putStrLn ("3")]
06:30:25 <ivanm> no
06:30:25 <themroc> like that its not working
06:30:29 <ivanm> that's _bad_
06:30:36 <themroc> :p
06:30:39 <ivanm> why would you want to do something like that?
06:31:00 <ikegami__> 'let' or 'where' help you
06:31:07 <ivanm> themroc: separate out your computation from your interaction
06:31:20 <themroc> well i wanna build 10 strings with the parameters and then print em out
06:31:38 <themroc> ahh
06:31:39 <ivanm> themroc: construct the list of strings, then print them all
06:31:49 <themroc> so i build the strings in the where part
06:31:56 <themroc> and print em in the sequence
06:32:04 <ivanm> ummm.... something like that
06:32:39 <fasta> ivanm: in general I think the fundamental assumptions of cryptography are not true. The right for "secure communications" only exist for those with the most powerful computers or those willing to wait a long time for the encryption process.
06:32:51 <themroc> test = sequence [putStrLn (a), putStrLn (b)]
06:32:51 <themroc>   where a = "yo"
06:32:51 <themroc> 	b = "oi"
06:32:53 <themroc> yeah nice
06:32:53 <themroc> :p
06:32:56 <themroc> thx so much
06:33:10 <ivanm> themroc: try this instead:
06:33:23 <ivanm> mapM_ putStrLn [a,b]
06:33:32 <ivanm> also, you don't need brackets around function arguments
06:33:42 <ivanm> > sin 0.3
06:33:45 <lambdabot>   0.29552020666133955
06:33:51 <fasta> ivanm: none of these are facts, it's just my opinion. That said, it's easy to make your communications unreadable for 99.9<insert lots of 9s here>%
06:34:02 <ivanm> yrsh
06:34:04 <ivanm> *yeah
06:34:31 <themroc> ah right no brackets
06:35:53 <themroc> and mapM_ works with where too?
06:36:08 <fasta> themroc: where is syntax
06:36:34 <ikegami__> where is reserved word in Haskell
06:36:39 <themroc> test2 = mapM_ putStrLn [a,b]
06:36:39 <themroc> where a = "test"
06:36:39 <themroc> b = "more test"
06:36:41 <ikegami__> oh
06:36:43 <themroc> that wont work
06:36:54 <ikegami__> the 'where' is a reserved word in Haskell
06:37:47 <ikegami__> themroc: I guess it does'nt work because of the indent issue
06:38:13 <themroc> i get Syntax error in input (unexpected keyword "where")
06:38:25 <quicksilver> it will work if you get the indentation right.
06:38:31 <quicksilver> or use explicit {}
06:38:54 <quicksilver> indent the "where" at least 1 space more than 'test2'
06:39:00 <quicksilver> and indent the 'b' to match the 'a'
06:39:19 <mux> haskell had me forget how annoying it can be to track bugs in Perl code
06:39:31 <mux> I feel like crying somehow.
06:39:51 <spookylukey> themroc:  let test2 = mapM_ putStrLn [a,b] where { a = "test"; b = "more test"; }
06:39:53 <themroc> oh wow
06:40:10 <themroc> didnt know indentation is important
06:40:22 <ikegami__> aha
06:40:30 <themroc> thx
06:40:35 <spookylukey> yeah, but you can replace it with brackets and semi-colons (especially good for interactive)
06:40:43 <Zao> mux: Now now, the Perl debugger is ... interesting.
06:40:54 * Zao hugs  use strict;
06:41:02 <yitz> fasta: afaik the only real assumption of crypto is that for anyone other than the intended recipient, it would cost more money to decrypt it in time to be useful than it would cost to hire a thug with a weapon to get the information directly.
06:41:03 <mux> for me, the perl debugger amounts to `print "LALALA\n";'
06:41:21 <mux> and various use Data::Dumper; print Dumper($foo); calls too :-P
06:41:41 <osfameron> most people use the perl debugger (if they use it at all) as a not very good REPL
06:42:02 <Zao> It's a bit sad that Show tends to produce mortal-readable.
06:42:11 <Zao> I'd prefer a Dump typeclass with all the fun gory details.
06:45:18 <fasta> yitz: that's the practical interpretation. If you interpret it like that, then crypto probably works, but what people often claim is that it takes the energy of a million suns or that you need until the heath death of the universe or something like that. I don't buy into that.
06:47:21 <quicksilver> fasta: such claims assume the attack only uses brute force
06:47:21 <hcube> hi! do you know anything about when will gpugen's source be released?  (gpugen is the haskell EDSL for GPUs)
06:47:35 <fasta> quicksilver: right
06:47:36 <quicksilver> fasta: i.e. they assume there are no mathematical advances at all which reduce the search space.
06:47:47 <quicksilver> fasta: history suggests this assumption is not correct :)
06:48:06 <dino-> To me it seems like by the time it's practical to brute force something long and nasty (25+ length passphrase for your luks, say), I will have long ago not given a shit about that data.
06:48:30 <SamB> yitz: that's not an assumption ... that's the thing you're trying to ensure
06:48:44 <SamB> oh, rats
06:48:48 <SamB> he left
06:49:02 <fasta> Consumers cannot have secrets. There is just too much of a technology gap between governments and even geeks.
06:49:24 <oal> fasta, what about PGP?
06:49:42 <fasta> oal: I was talking about the practical issues now.
06:50:07 <SamB> the NSA can probably crack PGP keys if they care enough
06:50:34 <fasta> The NSA can probably, but they will just listen to what keys you type on your keyboard.
06:50:59 <SamB> they can do that remotely?
06:50:59 <fasta> Or they have some high-tech stuff to figure out what is on your screen from a mile away.
06:51:20 <dino-> SamB: For a long time, wired peripherals too. Using the RF leakage.
06:51:36 <fasta> Checking what is on your screen from a km away was likely to be possible 10 years ago with equipment under $100.
06:51:36 <SamB> or they just use exploits to steal your PGP key and then crack your passphrase
06:51:46 <fasta> Imagine what billions of $ can do per year.
06:52:01 <SamB> dino-: from how far away?
06:52:06 <fasta> Really, to even think one person can compete with that is just silly.
06:52:43 <dino-> I don't know but I want to say like 50-100 feet, something I had read recently. Somebody correct me if they know.
06:52:45 <SamB> well, they can't steal everyone's secrets can they?
06:53:03 <SamB> dino-: I think the NSA would look a bit out of place on my street ;-)
06:53:05 <Maddas> Chalk one up for wired keyboards!
06:53:20 <dino-> Like an unmarked van near your house could do this easily if you had their negative attention.
06:53:24 <fasta> Maddas: wired keyboards have the same problems.
06:53:24 <Apocalisp> Sounds like fantasy to me. Government is generally totally inept, while giving an illusion of competence.
06:53:48 <die_sekte> Apocalisp: The NSA isn't government.
06:53:56 <Maddas> fasta: Good luck separating that from our lousy, inefficient fridge :-P
06:54:06 <die_sekte> Sure, it's state, but not government.
06:54:07 <Maddas> (more realistically, I could just go into our bomb shelter :-))
06:54:23 <SamB> die_sekte: I don't understand the distinction
06:54:28 <SamB> they don't make the law, sure
06:54:37 <fasta> Maddas: given enough time you can automatically learn that too.
06:54:37 <SamB> but most parts of the government don't!
06:54:51 <fasta> Maddas: CS doesn't really have a lot of limits.
06:55:01 <gwern> http://hackage.haskell.org/packages/archive/tfp/0.2/doc/html/Types-Data-Num-Decimal-Literals.html <-- this is a very happy page
06:55:03 <Maddas> fasta: I thought you were specifically not talking about theoretical limits :-)
06:55:14 <SamB> anyway, I don't see particularly how it matters whether or not the spies that spy on us are "government" or not
06:55:19 <Maddas> (As opposed to things which are realistic to implement)
06:55:24 <die_sekte> Politicians tend to be stupid. The gov consists of politicians. The rest of the state is just horribly ineffiecent.
06:55:30 <fasta> Maddas: I switch.
06:55:47 <Maddas> fasta: That's cheating. :-)
06:55:48 <soupdragon> wow gwern dose anyone use it
06:55:48 <dino-> ah, found it, says 20m http://www.security-exchange.net/news/93/
06:55:51 <SamB> die_sekte: I don't think it matters how horribly inefficient the NSA is
06:55:57 <dino-> Maddas: And wires do not save you!
06:56:15 <Botje> lead wallpaper!
06:56:17 <SamB> it doesn't really make much difference how many billions of dollars they have to spend in order to spy on us, given that they can
06:56:25 <Maddas> Botje: Bomb shelters, I say!
06:56:26 <Maddas> fasta: In theory, surely a piece of apple pie is enough.
06:56:55 <SamB> Maddas: I don't think they can break encryption using apple pie
06:57:08 <fasta> dino-: that's non-classified information.
06:57:18 <die_sekte> Apple pie should work better than torture.
06:57:23 <Maddas> SamB: No, but measure your key presses.
06:57:24 <fasta> dino-: governments did a lot more research in these kinds of things.
06:57:25 <SamB> I don't even think they can steal your grandma's apple pie recipie unless she types it up on the computer
06:57:31 <SamB> Maddas: or that!
06:57:40 <SamB> how would an apple pie help them do that?
06:57:44 <Maddas> SamB: They clearly can!
06:57:56 * Maddas points SamB to HHGTTG :-)
06:57:58 <die_sekte> SamB: The apple pie is just distraction.
06:58:01 <Maddas> (Hitchhiker's Guide to the Galaxy)
06:58:08 <koala_man> applie pie is codename for yellow cake
06:58:08 <dino-> fasta: Which to my tin-foil-hat brain means that this is old, boring news to real spooks.
06:58:09 <SamB> Maddas: yes, I know
06:58:18 <SamB> @vera hhgttg
06:58:21 <lambdabot> No match for "hhgttg".
06:58:24 <SamB> what the HECK?
06:58:31 <fasta> dino-: what is?
06:58:39 <Maddas> Er, maybe it's hgttg or something.
06:58:48 <dino-> fasta: That page above not being classified info.
06:59:05 <fasta> dino-: right, the article is kind of boring.
06:59:19 <Maddas> dino-: You knew that tin foil hats make it worse, not better, right?
06:59:25 <dino-> heh
06:59:39 <Maddas> (http://people.csail.mit.edu/rahimi/helmet/)
07:00:20 * SamB emails in HHGTTG
07:02:53 <SamB> hmm, also HGTTG for good measure
07:06:49 <fasta> SamB: you missed a H there ;)
07:07:10 <SamB> fasta: how many Hs do you think it should have?
07:07:30 <fasta> SamB: a prefix of 2.
07:08:27 <fasta> SamB: googlefight agrees, btw.
07:08:50 <SamB> fasta: I sent BOTH in
07:09:38 <themroc> is there a list operation which replaces an element on a given position?
07:10:16 <paper_cc> themroc: well, you can build one, but maybe you should consider using arrays instead of lists
07:10:30 <quicksilver> you should quickly discard the idea of using arrays.
07:10:36 <quicksilver> however, you might use Map or IntMap.
07:10:40 <paper_cc> quicksilver: ?
07:10:49 <quicksilver> or Sequence.
07:10:56 <fasta> paper_cc: only DiffArrays would work
07:11:03 <fasta> paper_cc: and they are slow.
07:11:10 <quicksilver> paper_cc: the only way to use arrays to replace an element (efficiently) is to use mutable arrays
07:11:15 <quicksilver> which are ugly and un-haskell-like.
07:11:18 <fasta> paper_cc: normal Arrays would have the same problem.
07:11:38 <paper_cc> quicksilver: "STArrays are evil"?
07:11:43 <quicksilver> no, not evil
07:11:44 <quicksilver> just ugl.
07:11:45 <quicksilver> ugly.
07:11:59 <fasta> STArrays make Haskell sortof practical.
07:12:00 <quicksilver> You will normally find a more elegant solution using IntMap or Sequence.
07:12:09 <quicksilver> you even get sharing etc.
07:12:19 <quicksilver> fasta is trolling.
07:12:40 <quicksilver> STArrays make Haskell more practical for certain domains where it is particularly impractical without them.
07:12:44 <fasta> No, I would not have used Haskell now if it didn't have STArrays or IOArrays.
07:12:51 <quicksilver> it remains eminently practical for all kinds of other domains.
07:13:03 <fasta> I don't like reducing my machine to a pointer-machine.
07:13:07 <quicksilver> fasta: yes, but your requirements are very specific, and not representative of "typical" programming problems.
07:13:21 <fasta> quicksilver: yes, that's true, but that doesn't make me a troll.
07:13:45 <paper_cc> > splitAt 0 [1,2,3]
07:13:46 <lambdabot>   ([],[1,2,3])
07:13:58 <themroc> hmmm
07:14:03 <themroc> ok i guess i build one then
07:14:05 <quicksilver> fasta: one who is sometimes trolling need not be a troll.
07:14:08 <paper_cc> > let replaceAt n xs x = let (head, tail) = splitAt n xs in head ++ [x] ++ take 1 tail in replaceAt 2 [1,2,3,4,5,6] 100
07:14:09 <lambdabot>   [1,2,100,3]
07:14:13 <paper_cc> oops
07:14:17 <lilac> @vera h2g2
07:14:19 <quicksilver> fasta: "< fasta> STArrays make Haskell sortof practical." that was trolling.
07:14:20 <lambdabot> No match for "h2g2".
07:14:29 <paper_cc> > let replaceAt n xs x = let (head, tail) = splitAt n xs in head ++ [x] ++ drop 1 tail in replaceAt 2 [1,2,3,4,5,6] 100
07:14:29 <quicksilver> haskell without STArrays is eminently practical for many applications.
07:14:30 <lambdabot>   [1,2,100,4,5,6]
07:14:30 <fasta> quicksilver: ok, well, then I meant that I don't believe I was trolling :)
07:14:37 <quicksilver> :)
07:14:51 <fasta> quicksilver: ok, for many applications you can do with STArrays :)
07:14:55 <fasta> without*
07:15:06 <paper_cc> thermroc: replaceAt n xs x = let (head, tail) = splitAt n xs in head ++ [x] ++ drop 1 tail -- you have to check it with border cases though
07:15:49 <themroc> border cases=
07:15:49 <themroc> ?
07:16:06 <lilac> machines with a constant-time array indexing operation can achieve asymptotically faster performance for some problems than those without
07:16:27 <soupdragon> yes
07:16:39 <lilac> what's the performance bound on writes to Array?
07:16:40 <soupdragon> some algorithms even with lazyness are less efficient
07:17:21 <lilac> presumably it depends on which historical values you keep a reference to?
07:17:24 <paper_cc> thermroc: well, the special cases such as replaceAt 0 or replaceAt (length xs - 1) or replaceAt (length x + 1000)
07:20:10 <fasta> lilac: both quicksilver and me are well-aware of that.
07:22:54 <lilac> fasta: i was wondering whether Array is enough, or whether you need STArray
07:23:14 <fasta> lilac: you need DiffArray or STArray.
07:23:31 <lilac> fasta: do you have proof of that?
07:23:47 <lilac> (or is this a well-knwnw result?)
07:23:53 <lilac> *known
07:24:13 <fasta> lilac: you mean a proof of a problem which cannot be solved in a lazy language within a certain time bound, but can be solved on a RAM machine?
07:24:42 <lilac> fasta: no, the lazy language side is allowed Array
07:25:15 <lilac> essentially, i think i'm asking, is there a constant-time simulation of a RAM machine in a lazy language with Array?
07:25:17 <fasta> lilac: Array only provides fast read-only operations. You still need the fundamental write operations.
07:25:44 <lilac> as I understand things, Array is fast for writes if you do them all at once
07:26:12 <lilac> (i'm assuming that (//) performs a copy, and isn't implemented like DiffArray)
07:26:37 <fasta> lilac: suppose you have some weird hardware device which requires that you write to certain addresses in a certain order.
07:26:39 <Taejo> anybody know of a good command-line-parsing library (like getopt) for Haskell?
07:26:59 <quicksilver> there is one distribetud with the extra libs, yes
07:27:12 <quicksilver> it takes a moment to get your head around its generalisation
07:27:15 <quicksilver> but it works fine.
07:27:39 <paper_cc> quicksilver: is this parseargs?\
07:27:52 <lilac> fasta: i would consider interfacing with external hardware to be stepping outside the realms of normal algorithmic complexity analysis
07:28:15 <fasta> lilac: you can perfectly formalize that.
07:28:28 <quicksilver> System.Console.GetOpt
07:28:31 <quicksilver> is the one I meant, paper_cc
07:28:32 <lilac> fasta: sure you can. but that's not the point. you've generalized your RAM machine
07:28:35 <quicksilver> http://www.haskell.org/ghc/dist/current/docs/libraries/base/System-Console-GetOpt.html
07:28:50 <fasta> lilac: no, the RAM machine just runs two programs via co-routines.
07:29:19 <lilac> fasta: in that case i'm not required to write to certain addresses in a certain order, only to get that effect.
07:31:34 <fasta> lilac: I once wrote something on the wiki about this.
07:31:46 <Taejo> quicksilver: thanks
07:32:39 <fasta> lilac: it was basically a problem which I believe cannot be solved without DiffArrays/STArrays efficiently.
07:33:47 <lilac> fasta: it'd be interesting to see that problem :) (i think it's likely that such problems exist btw -- but i'd be interested to see a proof either way)
07:33:49 <fasta> lilac: it was basically a simplified version of this: http://www.cs.nyu.edu/cs/faculty/cole/papers/COS00.ps
07:34:30 <quicksilver> it would be quite nice to have a version of diffarray which actually performed well.
07:40:46 <Taejo> @hoogle IO a -> IO (Maybe a)
07:40:48 <lambdabot> System.Timeout timeout :: Int -> IO a -> IO (Maybe a)
07:40:48 <lambdabot> Control.Applicative optional :: Alternative f => f a -> f (Maybe a)
07:40:48 <lambdabot> Prelude Just :: a -> Maybe a
07:43:01 <jmcarthur_work> > optional [0..9]
07:43:02 <lambdabot>   [Just 0,Just 1,Just 2,Just 3,Just 4,Just 5,Just 6,Just 7,Just 8,Just 9,Noth...
07:43:18 <jmcarthur_work> woah, what?
07:43:22 * jmcarthur_work never paid attention to optional
07:43:55 <soupdragon> @src optional
07:43:55 <lambdabot> optional v = Just <$> v <|> pure Nothing
07:44:23 <jmcarthur_work> > optional [0]
07:44:25 <lambdabot>   [Just 0,Nothing]
07:44:36 <jmcarthur_work> ah, i thought it was Nothing forever for a sec
07:44:38 <soupdragon> :t optional (char 'x')
07:44:41 <lambdabot>     Couldn't match expected type `f a' against inferred type `Doc'
07:44:41 <lambdabot>     In the first argument of `optional', namely `(char 'x')'
07:44:41 <lambdabot>     In the expression: optional (char 'x')
07:44:44 <jmcarthur_work> didn't make sense to me
07:44:59 <RayNbow> > mappend [Just 0] [Nothing]
07:45:00 <lambdabot>   [Just 0,Nothing]
07:45:16 <frostegard> how would one use the single-key encryption libraries at all? i don't understand how to represent real data (ie bytestrings) using word64 and friends?
07:45:49 <frostegard> i guess i'm missing something obvious..
07:46:01 <dons> what's the problem? do you have the type definitions there?
07:46:04 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
07:46:13 <jauaor> morning
07:47:17 <frostegard> well, i would like to serialize a simple, unnested datatype to disk, encrypted
07:48:23 <dirk_> I refactored my code now and I hope it looks beautiful now, but I am also happy about hints on what to change http://de.wikibooks.org/wiki/Benutzer:Dirk_Huenniger/haskell
07:49:42 <lilac> > unwrapMonad . optional . WrapMonad $ Left "error" :: Either String (Maybe Int)
07:49:44 <lambdabot>   Right Nothing
07:49:47 <fasta> lilac: I think this would be the core of the problem: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5893#a5893
07:51:33 <lilac> fasta: nice example :)
07:59:46 <lilac> fasta: i think you need to also rule out STRef or Array or I can just build an Array of STRef
08:00:10 <fasta> lilac: oh, right, can you make that adjustment for me.
08:00:23 <lilac> fasta: which one? :)
08:00:38 <fasta> lilac: rule out STRef
08:00:55 <frostegard> has anyone got any clue? how do i encrypt this ( http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5894#a5894 ) datastructure after serialising it with data.binary? someone suggested using a rsa library, but public key encryption doesn't really suit the application
08:07:56 <roconnor> frostegard: Codec.Encryption.AES ?
08:08:27 <roconnor> ugh
08:08:36 <roconnor> I didn't realize that was so low level
08:08:42 <roconnor> only works on 128 bits of data
08:08:55 <doserj> frostegard: Data.Binary gives you something like [Word8], right?  turn that into [Word64] or whatever your favorite encryption algorithm uses, then do Code.Encryption.Modes.cbc <encryption-function> iv key data
08:09:13 <roconnor> ah
08:09:21 <roconnor> doserj: good
08:09:39 <flipflap> Main: internal error: schedule: invalid what_next field
08:09:40 <flipflap>     (GHC version 6.10.1 for i386_unknown_mingw32)
08:09:40 <flipflap>     Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug
08:09:42 <flipflap> Lol what?
08:10:17 <fasta> flipflap: first upgrade and then report a bug, even better is to try the head.
08:10:37 <Zao> There's other internal errors than "the impossible just happened"?
08:10:52 <roconnor> @quote impossible
08:10:52 <lambdabot> cjeris says: and it's amazing what some languages do to make thinking impossible, seemingly justified by the assumption that no one thinks anyway, so it's more important to make non-thinking
08:10:53 <lambdabot> programming as easy as possible.  see ColdFusion.
08:11:02 <fasta> @quote impossible
08:11:03 <lambdabot> qwe1234 says: the lisp folks have purposefully made lisp so that static analysis is impossible.
08:11:23 <fasta> @quote possible
08:11:24 <lambdabot> ghc says: panic! (the `impossible' happened, GHC version 6.4)
08:11:37 <roconnor> ha
08:14:29 <lilac> @quote <autrijus> happened
08:14:30 <lambdabot> <autrijus> says: Perl: "Easy things are easy, hard things are possible" <autrijus> Haskell: "Hard things are easy, the impossible just happened"
08:14:31 <hackagebot> protocol-buffers 1.5.0 - Parse Google Protocol Buffer specifications (ChrisKuklewicz)
08:14:31 <hackagebot> protocol-buffers-descriptor 1.5.0 - Text.DescriptorProto.Options and Google Protocol Buffer specifications (ChrisKuklewicz)
08:14:31 <hackagebot> hprotoc 1.5.0 - Parse Google Protocol Buffer specifications (ChrisKuklewicz)
08:14:44 <Zao> roderyk: The gtk2hs linked before installs quite cleanly on the current HP.
08:15:06 <roderyk> Zao: wonderful! thanks for digging that up :)
08:17:56 <Zao> roderyk: It seems healthy as well, the Hello World in the Documentation runs.
08:18:13 <Zao> (after reverting the pretty printing of quotes and <-, of course)
08:18:52 <lilac> fasta: (pedantic, but...) i'm guessing IO is ruled out too?
08:18:54 <roderyk> Zao: I'll be sure to mention any issues I may dig up with it over the next two days
08:19:38 <lilac> fasta: (there are plenty of ways to fake up mutable references within IO, even without IOVar)
08:19:39 <fasta> lilac: well, you have to use some IO, but obviously not the stuff that already gives you mutable arrays trivially.
08:19:58 <fasta> lilac: no pointer arithmetic, smashing stacks and all that.
08:20:23 <fasta> lilac: "no cheating" might be shorter
08:21:13 <lilac> fasta: might be cleaner to say you must provide f :: String -> String or [Int] -> [Int]
08:21:19 <fasta> lilac: if you would write an academic paper, you would write a grammar with all the language elements, but that's not what I plan to do.
08:22:15 <fasta> lilac: I don't really have time to discuss this in great lengths. I gave an example of a problem and then intention is quite clear. Improve the problem specification if you want.
08:22:31 <fasta> the*
08:24:03 <RayNbow> oh joy... two more spam messages have been posted on hpaste.org...
08:24:47 <Taejo> :t catch
08:24:49 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
08:25:15 <soupdragon> I don't like spam
08:26:03 <fasta> The penalty on sending spam is too low. That's why it happens.
08:27:41 <ville> Does haskell have some notion of namespaces, I've C++ background, or is the par to use prefixes for names?
08:27:48 <uzytkownik> @pl \x -> f x ++ "\r\n\r\n" ++ g x
08:27:49 <lambdabot> liftM2 (++) f (("\r\n\r\n" ++) . g)
08:28:03 <uzytkownik> @pl \x -> (f x) ++ "\r\n\r\n" ++ (g x)
08:28:04 <lambdabot> liftM2 (++) f (("\r\n\r\n" ++) . g)
08:28:04 <jeffersonheard> ville, use "import qualified" for the module
08:28:22 <quicksilver> ville: 'import' has some of the power, and some of the problems of 'using'
08:28:34 <jeffersonheard> and you can alias the fully qualified name as well with "import qualified Data.ByteString.Lazy as LazyByteString"
08:28:57 <ville> alright I'll look into the details of import.
08:29:08 <jmcarthur_work> eek, but alias it to something shorter than that! ;)
08:29:33 <jeffersonheard> hehe.  yes.  I generally use LBS and SBS
08:29:53 <jmcarthur_work> i typically only have one of those two imported into a single module, so i just say BS
08:41:44 <tromp> > ()
08:41:45 <lambdabot>   ()
08:43:12 <Phyx-> Hello, does ghc write package information in someplace other than package.conf? i edited that but it still says that it can't find a namespace, but ghc-pkg describe shows it's there
08:49:17 <Phyx-> ah, fixed it, the dependencies where wrong
08:50:11 <koeien> is there a good reason why say,   [x*y | x <- a, y <- b] doesn't work for arbitrary monads?
08:50:29 <opqdonut> no
08:50:31 <fasta> koeien: some language designers wanted to keep things simple.
08:50:45 <opqdonut> they used to be "monad comprehensions" before h98
08:51:22 <koeien> there is no {-# LANGUAGE MonadComprehensions #-} ? ;)
08:52:08 <opqdonut> nope
08:53:09 <soupdragon> I don't know why anyone writes: [x*y | x <- a, y <- b]  when you can have  do x <- a ; y <- b ; return (x*y)
08:54:03 <jmcarthur_work> i don't know why anyone writes that when you can have    liftA2 (*)
08:54:20 <soupdragon> sure in this case but I mean in general for list comprehensions
08:54:39 <jmcarthur_work> yeah, i rarely use comprehensions either
08:54:53 <jmcarthur_work> very occasionally, it's nicer than the monadic equivalent
08:55:38 <koeien> i like the resemblence to mathematical set notation
08:55:48 <koeien> it holds off the definition of x and y, which can be nicer in some cases
09:01:27 <ray> it spans multiple lines in do notation
09:01:34 <ray> very icky
09:02:12 <lilac> soupdragon: the way list comprehensions deal with guards is slightly nicer, IMO
09:03:02 <quicksilver> raxas: it doesn't span multiples lines in do notation any more or less than it does in list comp notation.
09:03:07 <quicksilver> ray: that was for you ;)
09:03:11 <dino-> You could (*) <$> a <*> b
09:03:17 <koeien> yes, in this case.
09:03:25 <Philonous1> > (*) <$> [1,2,3] <*> [4,5,6]
09:03:25 <quicksilver> both list comp + do notation can easily be single line or multiline.
09:03:27 <lambdabot>   [4,5,6,8,10,12,12,15,18]
09:05:00 <ray> the semicolon thing doesn't make it count as a one-liner
09:08:14 <jeff_s_> redundant: Haskell Obfustication Contest
09:08:16 <jeffersonheard> can you put multiple options of a case statement on one line?
09:08:19 * Gracenotes likes liftM2 (*) as well
09:08:19 <jeff_s_> sorry, had to
09:08:32 <jeffersonheard> like case foo of Just x -> ... ; Nothing -> ...
09:08:34 <EvilTerran> jeff_s_, yeah, separate them with ;
09:08:49 <Gracenotes> jeffersonheard: yes... may as well use braces to be safe, though
09:09:16 <EvilTerran> > map (\m -> case m of Just x -> "just"; Nothing -> "nowt") [Just 1, Nothing, Just 2]
09:09:17 <lambdabot>   ["just","nowt","just"]
09:10:12 <Gracenotes> another solution for Just/Nothing specifically is to use the maybe function
09:10:13 <EvilTerran> jeffersonheard, you can also have multiple guarded options on one line, "<pattern> | <guard> -> ... | <guard> -> ..."
09:10:35 <jeffersonheard> nice
09:10:36 <Gracenotes> @type maybe
09:10:38 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
09:10:50 <Gracenotes> @type fromMaybe
09:10:51 <lambdabot> forall a. a -> Maybe a -> a
09:11:04 <jeffersonheard> Gracenotes: I know.  I just used Nothing/Just as an example because it was the first thing under my fingers
09:11:16 <Gracenotes> righty
09:11:21 <jeffersonheard> thanks tho
09:12:28 <EvilTerran> Maybe makes for a nice example of pattern-matching, as it demonstrates multiple options, and both nullary and non-nullary constructors
09:13:01 <quicksilver> ray: why not?
09:13:14 <quicksilver> ray: why is semicolon different form comma in this respect?
09:13:28 <quicksilver> [ x*y | x <- A, y <- B] -- one line
09:13:48 <quicksilver> do { x <- A; y <- B; return (x*y) } -- one line
09:14:10 <quicksilver> I don't see why semicolong shouldn't "count"
09:14:26 <EvilTerran> Gracenotes, you think liftM2 (*) is nice, how about "instance (Applicative f, Num n) => Num (f n) where (*) = liftA2 (*); ..."? :D
09:14:56 <Gracenotes> okay okay, just keep it away from the childen! D:
09:15:05 <ray> well, i was comparing it to liftA2 (*)
09:15:36 <Gracenotes> *not a fan of abstract-er num instances*
09:15:38 <ray> that might be a good instance!
09:15:46 * ray hasn't thought about it but is probably a fan
09:16:11 <lilac> that instance looks to overlap with far too much stuff
09:16:23 <lilac> like "Complex Double" for instance
09:16:29 <EvilTerran> lilac, ah, true; didn't think of that
09:16:51 <EvilTerran> it's still nice in principle, imo
09:17:08 <Twey> Would be nice to be able to say instance (Applicative f, Num n) => Num (f n) = map liftA2 (instances Num n)
09:17:18 <Twey> ... or so on
09:17:27 <Gracenotes> :X
09:17:28 <lilac> you could define an Applicative instance for Complex, but it would produce the wrong Num instance here...
09:17:46 <Gracenotes> Twey: not exactly for, say, fromInteger
09:18:07 <Twey> Gracenotes: True, doesn't work perfectly
09:18:23 <Twey> (in this particular case)
09:18:26 <Twey> But you get the idea :-P
09:18:34 <Twey> It's probably possible with TH, no?
09:19:33 <EvilTerran> Twey, well, there's inevitable ambiguity, i think
09:21:05 <quicksilver> lilac: the Applicative instance for Double is "Wrong(TM)"
09:21:17 <quicksilver> lilac: it exposes too much about the internals, IMO.
09:22:33 <Twey> EvilTerran: How's that?
09:23:17 <Twey> instances :: Class -> Type -> [(funcName, func)]
09:23:20 <Twey> Something like that
09:23:23 <Twey> Seems like it should work
09:24:19 <EvilRanter> grr
09:33:21 <Taejo> :t foldr id
09:33:22 <lambdabot> forall b. b -> [b -> b] -> b
09:33:48 <Taejo> foldr ($) [(+1), (+2), (*2)] 3
09:33:51 <Taejo> > foldr ($) [(+1), (+2), (*2)] 3
09:33:53 <lambdabot>   No instance for (GHC.Num.Num [[a -> a] -> [a -> a]])
09:33:53 <lambdabot>    arising from the li...
09:34:15 <Taejo> > foldr (id) [(+1), (+2), (*2)] 3
09:34:17 <lambdabot>   No instance for (GHC.Num.Num [[a -> a] -> [a -> a]])
09:34:17 <lambdabot>    arising from the li...
09:34:28 <Taejo> > foldr (id) 3 [(+1), (+2), (*2)]
09:34:30 <lambdabot>   9
09:38:44 <doserj> > let compose = appEndo . mconcat . map Endo in compose [(+1), (+2), (*2)] 3
09:38:45 <lambdabot>   9
09:40:05 <Taejo> | compose = foldr (.) id | is shorter
09:40:38 <flipflap> How do I insert a character by it's ascii number into haskell?
09:40:48 <flipflap> I know I can insert Char 003 by using \ETX
09:40:50 <EvilTerran> or compose = flip (foldr ($))
09:40:58 <EvilTerran> > '\x03'
09:40:59 <lambdabot>   '\ETX'
09:41:07 <Cale> > '\3'
09:41:09 <lambdabot>   '\ETX'
09:41:09 <lambdabot> Cale: You have 2 new messages. '/msg lambdabot @messages' to read them.
09:41:11 <flipflap> > '\x15'
09:41:12 <lambdabot>   '\NAK'
09:41:28 <EvilTerran> \x## is hex, \## is octal
09:41:34 <Cale> decimal
09:41:36 <flipflap> Okay :)
09:41:37 <Cale> > '\9'
09:41:38 <EvilTerran> (where ## is one or more digits)
09:41:39 <lambdabot>   '\t'
09:41:42 <flipflap> No way for decimal?
09:41:45 <flipflap> Oh
09:41:47 <EvilTerran> Cale, oh, right, decimal. that makes more sense, really.
09:41:47 <flipflap> Okay
09:41:55 <Cale>  \o## is octal
09:41:55 <flipflap> > '\15'
09:41:57 <lambdabot>   '\SI'
09:42:09 * EvilTerran was getting character and numeric constants confused
09:42:28 <Cale> I think maybe you're right if it's C or something :)
09:42:39 <quicksilver> or you can do (chr 3)
09:42:45 <EvilTerran> ... yeah, that's what it was. wrong language.
09:42:45 <quicksilver> > chr 3
09:42:46 <lambdabot>   '\ETX'
09:42:49 <Cale> > toEnum 3
09:42:51 <lambdabot>   * Exception: Prelude.Enum.().toEnum: bad argument
09:42:53 <Cale> > toEnum 3 :: Char
09:42:55 <lambdabot>   '\ETX'
09:42:55 <quicksilver> haha :P
09:43:03 <quicksilver> bitten by stupid defaulting.
09:43:07 <Cale> heh
09:43:08 <LeCamarade|Away> Who has used Takusen in this channel?
09:43:14 <LeCamarade|Away> Who has used Takusen, in this channel?
09:43:19 * quicksilver wonders if there is a good reason to make () an Enum instance.
09:43:20 <Cale> Well, to be fair, it was ambiguous anyway
09:43:22 <LeCamarade|Away> (Grammar matter, yes.)
09:43:24 <quicksilver> > [()..()]
09:43:25 <lambdabot>   [()]
09:43:31 <quicksilver> I'm sure that's very useful
09:43:36 <quicksilver> the car combinator
09:43:46 <quicksilver> or is it more of a monster truck? look at those wheels.
09:43:53 <alexsuraci> > ['a'..'a']
09:43:55 <lambdabot>   "a"
09:44:02 <EvilTerran> > [minBound .. maxBound]
09:44:03 <lambdabot>   [()]
09:44:13 <alexsuraci> ha
09:44:14 <doserj> well, it is consistent. it is a datatype consisting of only nullary constructors.
09:44:20 <quicksilver> agreed.
09:44:22 <flipflap> > '\o8'
09:44:22 <LeCamarade|Away> :t succ
09:44:23 <lambdabot>   <no location info>:
09:44:23 <lambdabot>      lexical error in string/character literal at chara...
09:44:24 <lambdabot> forall a. (Enum a) => a -> a
09:44:26 <flipflap> > '\08'
09:44:27 <lambdabot>   '\b'
09:44:27 <EvilTerran> if we're going to be like that, we should have a Num instance too
09:44:31 <quicksilver> I think probably lb's extended defaulting is a curse, not a blessing.
09:44:32 <flipflap> > '\09'
09:44:33 <lambdabot>   '\t'
09:44:37 <flipflap> > '\010'
09:44:38 <lambdabot>   '\n'
09:44:40 <EvilTerran> where fromIntegral 0 = ()
09:44:42 <flipflap> > '\10'
09:44:42 <doserj> arguably, the Enum instance for Bool is not so useful, either
09:44:43 <lambdabot>   '\n'
09:44:48 <EvilTerran> er, fromInteger
09:44:50 <quicksilver> or, in particular, having () in the default list is a curse.
09:44:56 <flipflap> > '\o10'
09:44:57 <lambdabot>   '\b'
09:45:03 <flipflap> Should do GHCI instead
09:45:07 <EvilTerran> () is a special case in a lot of ways
09:45:47 <quicksilver> doserj: I've used that for auto-generated UIs.
09:46:01 <doserj> oh?
09:46:11 <quicksilver> doserj: (autogenerating the moral equivalent of a popup menu for any type with Enum + Bounded)
09:46:21 <quicksilver> Bool is quite a common type of widget.
09:46:33 <doserj> ahh
09:46:40 <quicksilver> single valued widgets are less interesting.
09:47:49 <quicksilver> @check \x -> (toEnum . fromEnum $ x == x)
09:47:50 <lambdabot>   Add a type signature
09:47:56 <quicksilver> hmm
09:48:05 <quicksilver> extended defaulting has been removed from quickcheck in LB?
09:48:11 <quicksilver> that is an excellent thing, if so
09:48:12 <EvilTerran> @check (==)
09:48:13 <lambdabot>   "OK, passed 500 tests."
09:48:15 <quicksilver> I'm sure it used to default to ()
09:48:18 <EvilTerran> apparently not.
09:48:28 <quicksilver> @check \x -> (toEnum . fromEnum $ x) == x
09:48:29 <lambdabot>   "OK, passed 500 tests."
09:48:32 <quicksilver> ah ;)
09:48:37 <quicksilver> Enum proved sound! In general!
09:51:34 <jeff_s_> riiight
09:59:03 <lilac> is it possible to compute, in general, the initial type which is a member of some type class? (and does the question even make sense?)
10:01:05 <monochrom> I think yes. Define this type: each typeclass method correspond to a data constructor.
10:08:50 <EvilTerran> although that, of course, doesn't capture any unenforced equivelences
10:09:57 <lilac> is it still computable (or even well-defined) if we allow arbitrary axioms to be stated?
10:10:36 <Cale> lilac: sort of
10:10:54 <EvilTerran> (things like the associativity of mappend, i mean)
10:10:57 <Cale> Supposing that they are equational, maybe
10:11:06 <Cale> hmm
10:11:15 <Cale> Actually, I bet it's not computable
10:11:17 <EvilTerran> probably have to be equational and rank-1
10:11:54 <Cale> The word problem for groups isn't solvable, so...
10:12:07 <lilac> that sounds enough to encode at least the monad laws
10:12:30 <lilac> it would certainly be interesting if defaulting generated and used the initial type :)
10:14:13 <lilac> actually, what would we do about typeclass members which returned something outside of the type? we can't use the method=constructor trick there
10:14:28 <EvilTerran> that'd potentially require generating multiple initial types, each constrained by multiple classes
10:14:35 * edwardk waves hello
10:14:48 * thoughtpolice waves back
10:14:57 <Cale> Pick a group presentation for which the word problem is not solvable, and consider the class which has each of the generators in the presentation as methods, as well as the identity and multiplication, and whose axioms consist of the group axioms together with the relations for the group.
10:15:48 <Cale> hmm...
10:16:30 <Cale> Perhaps we need something in addition to this, like, make it a subclass of Eq :)
10:16:55 <thomastc> is there any way to ask cabal for its configuration without parsing ~/.cabal/config?
10:17:00 <EvilTerran> might be able to fudge it to work for common special-cases (transitivity, identity elements, etc)
10:17:12 <thomastc> preferably in a machine-readable, or fairly stable, format
10:18:14 <Cale> But anyway, there already is something which at least is very close to an initial monad with specific operations in Haskell.
10:18:37 <Cale> http://hackage.haskell.org/package/MonadPrompt -- it is this :)
10:18:57 <Cale> MonadPrompt guarantees that the monad axioms are satisfied
10:19:12 <Cale> So at least in some cases, it's possible to do it :)
10:19:54 <trofi> can I ask xmonad not to intercept hotkeys for certain programs when their windows are active, but pass events directly to them?
10:20:46 <LeCamarade|Away> Slightly off-topic, but you are brethren. How do I foreground a background& process in a shell script?
10:21:05 <Cale> Something I wonder about is whether RecPromptT is possible
10:23:01 <Cale> LeCamarade|Away: hmm, I wonder if jobspecs can always be guessed :)
10:23:23 <Cale> Normally it's fg <number> where <number> is the job number
10:23:45 <LeCamarade|Away> But since fg is a shell built-in, that seems not to work.
10:23:51 <LeCamarade|Away> In a shell script, that is.
10:24:06 <thomastc> jobs gives the job number
10:24:08 <LeCamarade|Away> It said it couldn't find fg. :o(
10:24:20 <thomastc> and fg without an argument also works
10:24:30 <Cale> LeCamarade|Away: uhh... it ought to work in a shell script for the right shell :)
10:24:33 <thomastc> at least if there's only one backgrounded job
10:24:52 <LeCamarade|Away> It doesn't seem to work in a shell script ... /bin/sh, as God intended for it to be. :o)
10:25:09 <LeCamarade|Away> It should foreground the latest job.
10:25:24 <LeCamarade|Away> But this doesn't seem to work ... Oh, well. I'll leave it as it is.
10:25:53 <LeCamarade|Away> By the way, friends, Haskell looks good under this font, Liberation Mono.
10:31:00 <Botje> i'm partial to bitstream vera sans mono, myself
10:31:19 <thomastc> I like that one a lot too
10:31:27 <thomastc> Liberation looks to me like Lucida Console
10:31:57 <thomastc> which has too many serifs :)
10:32:21 <Botje> I'm actually using inconsolata atm
10:36:48 <gwern> what's the story behind the name inconsolata, I wonder
10:37:29 <Phyx-> http://blog.hamstu.com/2008/02/03/the-typography-of-code/
10:37:30 <Phyx-> :)
10:39:58 <Cale> I like Andale Mono, except that its bold variant uses slightly wider blocks than its plain variant, so some syntax highlighters create problems. I switched to Vera Sans Mono because of that.
10:40:32 <themroc> hmm i wanna use the list operation 'delete'. the help states: (defined in module List)
10:40:38 <themroc> how do i import that module?
10:40:49 <Cale> import List
10:40:52 <thomastc> import List
10:40:58 <Cale> Or if you're modern, import Data.List
10:41:00 <thomastc> could it be simpler? :)
10:41:10 <themroc> hmmmm
10:41:18 <themroc> then i have a problem :p
10:41:22 <Cale> (List is one of the original Haskell98 modules, but they've been deprecated)
10:41:49 <themroc> we have the specification to define a function called "find"
10:41:53 <themroc> which is in the module List
10:42:00 <themroc> which brings up problems :p
10:42:07 <themroc> can i define a more specific import?
10:42:12 <Zao> Yes.
10:42:21 <monochrom> import Data.List hiding (find)
10:42:43 <monochrom> But I wonder if you need anything from Data.List to begin with.
10:43:22 <monochrom> I also wonder why you need "delete" to write your "find".
10:43:28 <themroc> i need "delete"
10:43:31 <themroc> well
10:43:36 <themroc> its a couple of functions we have to do
10:43:42 <themroc> one is a specific find
10:43:53 <thomastc> oh, you have to *write* this function?
10:44:10 <themroc> its another than the original find
10:44:13 <thomastc> and it needs to be in a module List?
10:44:21 <themroc> no idea why they wanna have it called find
10:44:33 <themroc> nah i wanna use the "delete"
10:44:40 <Phyx-> to define find?
10:44:46 <themroc> to define something else
10:44:51 <Phyx-> ah ok
10:45:02 <themroc> import List (delete)
10:45:05 <themroc>  worx fine
10:45:08 <themroc> thx
10:45:08 * mmorrow loves courier 10 pitch
10:45:10 <Phyx-> Cale: yeah, i'm using Andale Mono myself atm
10:45:11 <monochrom> I bet $5 you are not supposed to use "delete" in "find".
10:45:20 <themroc> i dont use delete in find
10:45:26 <Phyx-> monochrom: os that real of haskell dollars?
10:45:29 <Phyx-> is*
10:45:29 <themroc> i use delete in a specific list merge function
10:45:48 <monochrom> You don't need "delete" for merging either.
10:45:52 <Phyx-> though i've been thinking of switching to Lucida Console
10:45:57 <Phyx-> less round
10:46:12 <themroc> the problem is, we have a very specific way of doing that stuff
10:46:18 <monochrom> I bet $5 more that you are just approaching all these exercises too destructive-update-ly.
10:46:21 <themroc> we have to use some functions etc
10:46:25 <Cale> themroc: delete is a very very uncommonly used function :)
10:46:30 <themroc> which totall sux
10:46:37 <themroc> hmm
10:46:40 <Phyx-> @type delete
10:46:42 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
10:46:52 <Phyx-> doh
10:47:05 <Cale> > delete 3 [1,1,2,3,3,3,4,5]
10:47:07 <lambdabot>   [1,1,2,3,3,4,5]
10:47:19 <themroc> i think its a nice list operation :)
10:47:22 <Cale> > delete 4 [1,1,2,3,3,3,4,5]
10:47:23 <lambdabot>   [1,1,2,3,3,3,5]
10:47:32 <Cale> It's expensive
10:47:32 <trofi> > delete 4 [4,4..]
10:47:34 <lambdabot>   [4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,...
10:47:49 <themroc> true
10:48:07 <thomastc> what a silly function :)
10:48:16 <themroc> why silly?
10:48:18 <Cale> It costs linear time in general.
10:48:22 <Phyx-> > [4,4..] // [4]
10:48:23 <lambdabot>   Couldn't match expected type `GHC.Arr.Array i e'
10:48:28 <trofi> \\
10:48:29 <thomastc> I was like, oh, that's just (filter . (/=))
10:48:30 <thomastc> but no
10:48:33 <Phyx-> > [4,4..] \\ [4]
10:48:34 <lambdabot>   [4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,...
10:48:41 <Phyx-> trofi: i always get em confused
10:48:42 <Phyx-> lol
10:48:43 <themroc> it deletes the first element in the list
10:49:05 * trofi suspects // is threated as commint in LANGUAGE CPP
10:49:18 <Phyx-> Cale: btw, you should take a look at http://www.smashingmagazine.com/2007/11/08/40-excellent-freefonts-for-professional-design
10:49:20 <dirk_> I got a program with one boolean value that constant during runtime but is to be supplied by the user, as it seems for now i need to pass that parameter through a lot of functions in order to pass it finnnally to the function that needs it is there any better way?
10:49:21 <trofi> s/typos//
10:49:22 <Phyx-> they have some nice ones
10:49:38 <monochrom> And I bet yet another $5 that if you are asked to implement "map", which roughly speaking behaves like map f [x,y,z] = [f x, f y, fz], you will think in terms of "delete x, insert f x, then delete y, insert f y, then delete z, insert f z".
10:49:58 <Cale> monochrom: hehe
10:50:03 <Phyx-> dirk_: use a reader
10:50:06 <Cale> (augh!)
10:50:29 <Phyx-> @hoogle Reader --info
10:50:29 <lambdabot> module Control.Monad.Reader
10:50:29 <lambdabot>  
10:50:29 <lambdabot> * Computation type: Computations which read values from a shared environment.
10:50:40 <Botje> monochrom: oh god, that's horrible
10:50:59 <dirk_> looking at it
10:51:34 <thomastc> monochrom: that wouldn't even typecheck, at least not as general as map
10:51:58 <jmcarthur_work> delete delete delete insert insert insert, then
10:52:25 <thomastc> heh :) who can make the uttermost horriblemostest implementation of map?
10:52:33 <Phyx-> but you no longer have the values to insert then, you should save em first!
10:52:57 <random_user> Hi, what does the '!!' operator do? Normally I'd just google this, but...
10:53:02 <dirk_> it says something about Control.Monad.State.State too,
10:53:09 <Paczesiowa> > [1..10] !! 4
10:53:11 <lambdabot>   5
10:53:25 <monochrom> list !! i = the guy at position i in the list
10:53:26 <Paczesiowa> > ['a'..'z'] !! 14
10:53:27 <lambdabot>   'o'
10:53:43 <random_user> (sheepish) thanks :)
10:53:53 <Phyx-> dirk_: that's if you want to update the computation aswell. Reader is readonly, usually since you said your value was constant i suggested that one
10:53:55 <jmcarthur_work> :t zipWith ($) . repeat
10:53:57 <lambdabot> forall b b1. (b -> b1) -> [b] -> [b1]
10:54:10 <thomastc> random_user: you could hoogle it instead ;)
10:54:32 <thomastc> @hoogle !!
10:54:32 <lambdabot> Prelude (!!) :: [a] -> Int -> a
10:54:32 <lambdabot> Data.List (!!) :: [a] -> Int -> a
10:54:49 <dirk_> yes for now reader would be enough but it is possible that I will need writabe values as well
10:54:58 <yitz> @src (!!)
10:54:58 <lambdabot> xs     !! n | n < 0 = undefined
10:54:59 <lambdabot> []     !! _         = undefined
10:54:59 <lambdabot> (x:_)  !! 0         = x
10:54:59 <lambdabot> (_:xs) !! n         = xs !! (n-1)
10:54:59 <dirk_> in future
10:55:15 <jmcarthur_work> dirk_, writing would change what you're reading?
10:55:20 <jmcarthur_work> dirk_, if so, then State
10:55:40 <thomastc> dirk_: if you define your monad with a newtype, you can easily change this later
10:55:44 <dirk_> maybe it s better to use state from the beginning
10:55:53 <jmcarthur_work> dirk_, i recommend not using state until you need it
10:55:59 <thomastc> (newtype, right folks? /me also slightly new to this)
10:56:20 <dirk_> thomastc seems to be a good idea
10:56:42 <thomastc> and then either replace it by a State monad when you need it, or use a monad transformer
10:57:28 <themroc> i really dont understand why we are given a total specific way of solving the tasks
10:57:33 <nominolo> dirk_: you can just use GeneralizedNewtypeDeriving if you use monad transformers
10:57:43 <themroc> its not hinking, its just mechanical job accomplishing ;(
10:57:56 <Paczesiowa> why State isn't MonadReader instance?
10:58:06 <And[y]> hi, does anyone know, if theres a quicksort implementation available somewhere, that uses two pivot elements on 3 lists? =)
10:58:24 <thomastc> And[y]: why would you want to?
10:58:30 <dirk_> I don't know much about monsads yet I used one when parsing with parsec
10:58:48 <Paczesiowa> wait, yes it is
10:58:56 <And[y]> ah, well, i got the same algo implemented in prolog and i wanted to compare efficiency :>
10:59:28 <Paczesiowa> dirk_: you can omit type signatures, and use runReader at the top, and later switch to runState
11:00:06 <Cale> Phyx-: thanks, by the way. I think I will download some or all of those :)
11:00:12 <Cale> Phyx-: (the fonts)
11:00:21 <Phyx-> np :)
11:02:25 * dons finds the concept of "Agda for Non-Programmers" odd
11:03:15 <Jedai> dons: That does seem a little hard to obtain...
11:03:37 <dons> maybe formal methods people don't see themselves as programmers
11:03:39 <jauaor> hi
11:03:48 <irek_j> hi
11:03:58 <Paczesiowa> dons: wouldn't they prefer coq to agda?
11:04:18 <Jedai> And[y]: You can be quite sure that Prolog would be slower than Haskell (if you don't do a gross error in the Haskell version)
11:05:20 <dons> Paczesiowa: why?
11:05:47 <Paczesiowa> dons: iirc agda only allows proofs that follow shape of your code
11:06:32 <thomastc> And[y]: http://haskell.pastebin.com/m2b4a7c32
11:06:46 <dons> right, i suppose if you're not actually doing programming, it would be a weird environment.
11:06:54 <Jedai> dons: Coq is more cleanly split between proofs and programs
11:06:56 <Paczesiowa> dons: but I started playing with coq like a week ago (I want to learn dependant types, and there are 1.5 books on coq and 0 for agda I think)
11:07:15 <irek_j> I wrote a function equalBy f x y = (f x) == (f y) to use with groupBy, Is there anything more generic I could use to define it, so I could write equalBy = functionImLookingFor (==) ? I actually wrote one but I'm wondering whether something like this exists.
11:07:17 <monochrom> dons: perhaps it means "Agda for mathematicians" which makes sense. :)
11:07:20 <dons> Paczesiowa: sure. theorem prover vs programming language with theorems
11:07:34 <Jedai> dons: they even tried to make it more like mathematics proof, adding another DSL for proofs recently
11:07:45 <yitz> irek_j: on
11:07:52 <yitz> @type on
11:07:53 <Jedai> irek_j: on
11:07:54 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
11:08:00 <yitz> @src on
11:08:00 <lambdabot> (*) `on` f = \x y -> f x * f y
11:08:09 <Jedai> irek_j: (==) `on` f
11:08:22 <irek_j> thank you so much
11:08:28 <yitz> @hoogle on
11:08:28 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
11:08:28 <lambdabot> Text.PrettyPrint.HughesPJ OneLineMode :: Mode
11:08:28 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
11:08:29 <thomastc> hey, it uses (*) as an argument name, neat :)
11:08:55 <Raevel> not with -Wall >:(
11:09:01 <yitz> it could have used ==, that would have been even more confusing
11:09:14 <Phyx-> thomastc: your code traverses xs 3 times, it's not really that efficient.. since he wanted to compare efficiency
11:09:25 <thomastc> Phyx-: true
11:09:30 <Paczesiowa> what do I have to do to make C-p work (as an up-arrow) in ghci-6.10.3 ? ( it worked in 6.10.2)
11:09:46 <And[y]> perfect, thomastc, thanks a lot :)
11:10:02 <thomastc> And[y]: note what Phyx- said above
11:10:02 <Paczesiowa> dons: do you use coq/agda at galois?
11:10:13 <thomastc> I'll make a more efficient version, just a sec
11:10:25 <And[y]> hehe, great dude =)
11:10:59 <dons> Paczesiowa: for some experiments. not in any production stuff yet.
11:11:12 <thomastc> hmm
11:12:46 <Jedai> Paczesiowa: read the haskeline documentation, you can define new shortcuts and choose between a vim or emacs style for the basic shortcut
11:12:55 <PeakerWork> GHC only thread-switches in allocations -- this causes some problems (e.g unamb may never get runtime to try other evaluate threads) -- is there any idea of how to resolve this?  Can GHC make sure thread switches always occur, even after optimizing allocations out?
11:13:22 <dons> i'd be interested to see problem that in practice
11:13:35 <SamB> dons: you haven't yey?
11:13:37 <Jedai> Paczesiowa: http://trac.haskell.org/haskeline/wiki/CustomKeyBindings
11:13:38 <SamB> er. yet?
11:13:39 <dons> since I'm not aware of a real program where starvation appears due to not allocating
11:13:51 <PeakerWork> dons: I think it happens on something as simple as:   unamb (last [1..]) 2
11:13:51 <dons> PeakerWork: the solution, obviously, is to insert a yield. do cooperative threading
11:14:04 <dons> or allocate :)
11:14:22 <PeakerWork> dons: well, unamb assumes "evaluate" is thread-friendly.  If it can't assume it, its probably not implementable in ghc
11:14:28 <PeakerWork> s/in ghc/over ghc
11:14:40 <dons> can you write a program that illustrates this?
11:14:49 <dons> or, does -threaded help?
11:14:58 <PeakerWork> dons: Do you know the "unamb" package?  Nope, -threaded did not help in that case
11:15:05 <SamB> dons: I thought you'd have seen those from the FPS stuff
11:15:31 <dons> i'm vaguely familiar with it.
11:15:53 <SamB> apparantly it happens
11:15:53 <dons> i'm surprised that code isn't allocating. is that what the Core says?
11:16:14 <SamB> more and more often the better the fusion gets
11:16:15 <PeakerWork> dons: Hmm.. I can't seem to reproduce this problem with unamb 0.2.2 here, but I'm pretty sure Baughn has encountered it
11:16:26 <dons> what makes you think it is the non-allocation issue?
11:16:33 <SamB> well, also the Data.List fusion ...
11:16:44 <dons> its hard to write non-allocating haskell code :)
11:16:47 <PeakerWork> dons: well, its probably possible to produce diverging pure expressions that do not allocate?
11:16:59 <dons> it is, but it is sooo rare.
11:17:03 <SamB> dons: yes, but it's a definate goal to be able to
11:17:17 <SamB> write non-allocating code, I mean
11:17:21 <SamB> not that actually diverges
11:17:21 <mmorrow> PeakerWork: (let f !x | x < 100 = f (x+1) | otherwise = x doesn't allocate, if you're looking for a test-case)
11:17:39 <mmorrow> it compiles to a little tight asm loop :)
11:17:47 <SamB> it might just take a long time to finish
11:17:50 <mmorrow> (at least on x86_64)
11:18:10 <PeakerWork> mmorrow: thanks
11:18:20 <opqdonut> mmorrow: probably needs a non-polymorphic type too
11:18:30 <mmorrow> opqdonut: ah yeah
11:18:35 <mmorrow> PeakerWork: (assuming Int here)
11:18:37 <SamB> dons: haven't you had that problem at galois yet?
11:18:52 <hatds> is there a reason why ghc would produce an empty time/allocation report?
11:19:13 <thomastc> And[y]: http://haskell.pastebin.com/m75f1c50
11:19:24 <SamB> hatds: ... did it ?
11:19:24 <thomastc> Phyx-: I *think* this is faster
11:19:30 <thomastc> but I'm not sure
11:19:33 <hatds> SamB: yes
11:19:43 <SamB> hatds: well, then there must be a reason
11:19:55 <hatds> I know more or less the exact change to my code which causes it
11:20:30 <PeakerWork> mmorrow: I'm looking for something that diverges, though
11:20:53 <hatds> I replace a straight call to C with one which passes a callback to C where the callback calls into C (if that made any sense).  Maybe ghc has a tough time with that for some reason?
11:20:59 <opqdonut> hatds: that happens to me some times when the run is too quick
11:21:04 <mmorrow> PeakerWork: just omit the check for (< 100) ;)
11:21:14 <mmorrow> PeakerWork: that'll lock the runtime up cold
11:21:22 <hatds> opqdonut: thanks for the suggestion, lemme try that
11:21:24 <PeakerWork> ah, I just got it to fail, despite having an extra thread that should succeed
11:22:02 <PeakerWork> @index fix
11:22:02 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
11:22:18 <PeakerWork> Where's the regular fix from?
11:22:28 <opqdonut> Control.Monad.Fix
11:22:32 <ClaudiusMaximus> Data.Function
11:22:33 <mmorrow> Data.Function
11:22:37 <hatds> still getting a blank profile report :/
11:22:48 <opqdonut> oh :/
11:22:59 <opqdonut> didn
11:23:03 <opqdonut> 't it use to be in C.M.F?
11:23:07 <PeakerWork> ah, thanks
11:23:14 <PeakerWork> opqdonut: that doesn't make much sense, though, why is fix monad-related?
11:23:24 <mmorrow> maybe thinking of mfix
11:23:31 <opqdonut> PeakerWork: made no sense to me either, that
11:23:35 <opqdonut> 's why i remember it
11:23:38 <opqdonut> damn keyboard
11:23:51 <opqdonut> Data.Function is pretty new, right?
11:24:46 <Paczesiowa> Jedai: thanks, Emacs style doesn't make C-p work, will try those custom bindings
11:24:48 <Phyx-> thomastc: yeah, that's somewhat better, i would use x: instead of ++ [x] though and foldl' instead of foldl
11:25:05 <Phyx-> foldl is rather inefficient
11:25:13 <mmorrow> opqdonut: yeah, 6.8 iirc
11:25:29 <Paczesiowa> anyway, switching readline implementation in minor release of ghc seems weird
11:25:30 <PeakerWork> f x = f (x-1) ; unamb (f 0) 2 -- never gets to try to evaluate the 2  :-(
11:25:33 <thomastc> Phyx-: and then feed the reversed string to split3?
11:25:54 <thomastc> I only omitted foldl' because I was too lazy to type an import, then forgot about it :
11:25:58 <thomastc> :)
11:26:02 <PeakerWork> dons: Any idea how to implement unamb correctly in the face of unallocating pure expressions?
11:26:36 <mmorrow> PeakerWork: maybe you need forkOS or just -threaded and forkOn
11:26:44 <mmorrow> (or maybe neither would work, not sure)
11:27:13 <opqdonut> forkOn?
11:27:20 <mmorrow> (err, forkOnIO, i forget the name)
11:27:21 <Botje> fork on .. fork off ..
11:27:28 <mmorrow> GHC.Conc
11:27:30 <Botje> these are the lessons you must learn, young grashopper
11:27:46 <mmorrow> forkOnIO :: Int -> IO () -> IO ThreadId
11:28:18 <Jedai> Paczesiowa: I would agree except that editline was pretty crummy in my experience, if there was an error it was switching to editline in the first place (though that was for license reason), switching to haskeline can only be an improvement in my opinion, especially if it leads to some interest in the library, so that we get a good alternative to readline in pure Haskell (and without license probl
11:28:43 <PeakerWork> mmorrow: well, if unamb used forkOS instead of forkIO it would probably be very slow... :(
11:28:51 <mmorrow> PeakerWork: probably
11:28:51 <PeakerWork> mmorrow: what's forkOn?
11:28:53 <thomastc> And[y]: http://haskell.pastebin.com/m284fa2ad and now I go back to other work ;)
11:29:03 <mmorrow> PeakerWork: you get to choose the core to fork on
11:29:06 <Phyx-> thomastc: the order of the elements in the list being split doesn't really matter, since quicksort goes on till it splits the lists to single elements (worse case wise), and again, since he was wanting to compare efficiency, using foldl is slow due to space leaks
11:29:55 <thomastc> Phyx-: duh... input order is arbitrary anyway *bangs head to wall*
11:30:04 <mmorrow> PeakerWork: (i'm not sure if you're guaranteed to stay on that core, or if you might get migrated..)
11:30:30 <thomastc> Phyx-: maybe it was some intuition of mine that wanted to keep the sort stable. But quicksort isn't stable either way
11:32:20 <PeakerWork> mmorrow: ah
11:32:24 <Phyx-> thomastc: :)
11:33:41 <pchiusano> is strictness analysis done by default when you compile with ghc, or does it need to be enabled?
11:34:08 <PeakerWork> mmorrow: -threaded doesn't help
11:34:13 <Phyx-> is there a version of arrow that can be used for 3-tuples ?
11:34:48 <Saizan> pchiusano: it's enabled by -O or -O2
11:35:04 <FunctorSalad> > 1 &&& 2 &&& 3 :: (Int,(Int,Int)) -- Phyx-
11:35:05 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
11:35:10 <FunctorSalad> sigh
11:35:15 <Paczesiowa> Jedai: ok, this worked: "bind: ctrl-p up "
11:35:18 <FunctorSalad> oh wait
11:35:18 <Paczesiowa> Jedai: thanks
11:35:19 <pchiusano> Saizan: ok thanks
11:35:22 <FunctorSalad> I need functions ;o
11:35:51 <FunctorSalad> > ((*1) &&& (*2) &&& (*3)) 29 :: (Int,(Int,Int))
11:35:52 <lambdabot>   (29,(58,87))
11:36:04 <Phyx-> thomastc: btw, you're missing the case for empty list, probably just forgot to paste it
11:36:11 <Phyx-> FunctorSalad: ah, ok
11:36:36 <Phyx-> @type (id &&& id &&&)
11:36:38 <lambdabot>     The operator `&&&' [infixr 3] of a section
11:36:38 <lambdabot>         must have lower precedence than that of the operand,
11:36:38 <lambdabot>           namely `&&&' [infixr 3]
11:36:41 <Phyx-> oops
11:36:51 <Phyx-> @type \f -> (id &&& id &&& f)
11:36:52 <lambdabot> forall b c'. (b -> c') -> b -> (b, (b, c'))
11:37:05 <mmorrow> PeakerWork: iirc haskell code (by that i mean literally code written out by ghc for your program) never actually runs in parallel (???)
11:37:07 <thomastc> Phyx-: where? it says "qsort3 [] = []" on line 3
11:37:14 <mmorrow> PeakerWork: so i think you're SOL :(
11:37:28 <Phyx-> thomastc: http://haskell.pastebin.com/m75f1c50 doesn't have it
11:37:52 <Phyx-> FunctorSalad: thanks
11:38:14 <thomastc> Phyx-: nope, I missed it in that one, apparently, but http://haskell.pastebin.com/m284fa2ad is ok
11:38:46 <PeakerWork> mmorrow: forkIO with -threaded won't cause actual threading between GHC written code?
11:39:19 <bd_> mmorrow: It does. Pass +RTS -N<number of OS threads>   to the actual program
11:39:32 <mmorrow> PeakerWork: it'd cause the rts to run in multiple hardware threads, but your actual haskell-level code does not
11:39:46 <Phyx-> FunctorSalad: hm but that makes (a,(a,a)) but i mean is there one that works on (a,a,a) ?
11:39:56 <bd_> mmorrow: er, it will actually run haskell code in multiple OS threads.
11:39:58 <FunctorSalad> found a comment: "So don't put all the foralls at the front! Yes, this is a bit grotesque, but heck it works and the whole arrows stuff needs reworking anyway!"
11:40:00 <mmorrow> because if it did, since ghc uses a single global heap, it'd need to use atomic instructions to allocate, which would kill performance (???)
11:40:09 <bd_> mmorrow: as long as you pass the +RTS -N<number of OS threads> option at runtime
11:40:31 <PeakerWork> mmorrow: so it has a Python-like GIL?
11:40:48 * PeakerWork goes
11:40:51 <bd_> PeakerWork: It doesn't. See my comments above :)
11:41:03 <Cale> Phyx-: the Arrow combinators only work on pairs
11:41:05 <FunctorSalad> Phyx-: not out of the box to my knowledge
11:41:10 <Phyx-> thomastc: yes that has it, but why the reverse? that nullifies all the changes you made
11:41:13 <Phyx-> and it's not needed
11:41:19 <bd_> PeakerWork: (assuming a sufficiently new GHC)
11:41:20 <FunctorSalad> though you could just cast nested to flat in a pure arrow
11:41:27 <Phyx-> FunctorSalad, Cale: ah ok, cool, i was just wondering
11:41:28 <mmorrow> bd_: but there's never two threads of haskell code simultaneously in-between safepoints (i think even when there are multiple hardware threads, but i'm 50% sure i'm right (resp. wrong))
11:42:04 <FunctorSalad> . o O ( coherence theorem )
11:42:05 <bd_> mmorrow: define safepoints. I've read the paper, it really is concurrent when in MUT at least.
11:42:07 <mmorrow> bd_: (the rts code that is part of your program however i'm not including in that)
11:42:15 <thomastc> Phyx-: I realize that now, thanks :)
11:42:34 <FunctorSalad> I wonder whether you could have a typeclass castTuple that reassociates tuples
11:43:09 <bd_> mmorrow: http://donsbot.wordpress.com/2009/03/04/playing-with-ghcs-parallel-runtime/
11:43:16 <mmorrow> bd_:  if (Hp + 12 < HpLim){ R0 = Hp; Hp += 12; .... R0 ....}
11:43:29 <bd_> mmorrow: what am I looking at there? :)
11:43:31 <thomastc> And[y]: if you're still listening: http://haskell.pastebin.com/m189ada6b
11:43:44 <mmorrow> bd_: a thread bumping the *global* heap pointer
11:44:07 <bd_> mmorrow: Are you sure that's not the per-thread nursery pointer?
11:44:10 <mmorrow> bd_: you'd need atomic asm instructions if that could run in par, which would destroy performance
11:44:20 <mmorrow> bd_: yeah, that's what i'm not sure about
11:44:23 <bd_> or, per capability rather
11:44:32 <bd_> because that would seem to be the obvious optimization
11:44:37 <mmorrow> i think you're right
11:45:00 <Phyx-> mmorrow: so does that mean that things like Writer are inheritly threadsafe?
11:45:05 <Baughn> PeakerWork: I haven't, actually.
11:45:09 <bd_> I can imagine a non-allocating loop locking things up, since it can't be preempted, and if it lands on all capabilities you'll lock up...
11:45:21 <Baughn> PeakerWork: I ran into something I /thought/ was that once, but it turned out to be a more serious unamb bug.. which isn't in 0.2.2
11:45:47 <mmorrow> Phyx-: (although i think i'm wrong about what i was just saying), no because from the point of view of you in haskell-land, you can't tell the difference
11:46:06 <Baughn> PeakerWork: Unamb fails if the loop is non-allocating and infinite, but so does everything else. I'd call that a program bug, really.
11:46:43 <Phyx-> mmorrow: ah ok
11:46:55 <mmorrow> bd_: yeah, that's what makes me not sure about what's happening (the fact that a non-allocating thread can lock up even an rts running with -threaded +RTS -N2+ -RTS)
11:47:00 <SamB> Phyx-: I believe it's generally accepted that GHC should be able to preempt even in tight loops
11:47:00 <ekename> Is there a pragma to replace length/splitAt in the prelude with the generic* versions?
11:47:15 <Cale> ekename: no, but I wish Int would die
11:47:19 <ekename> I got burned: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2772
11:47:41 <Baughn> SamB: Non-allocating loops that make progress yet don't complete very quickly are.. rare
11:47:57 <Phyx-> hmm
11:47:58 <Baughn> SamB: OTOH, it'd be nice to avoid having to check for pending events on every allocation
11:48:12 <SamB> Baughn: that too!
11:48:27 <mmorrow> bd_: that that can happen makes me think that the /heap-allocating haskell part/ of the prog is never running in parallel
11:48:34 <SamB> GHC's tying the two together is a hack, and everyone knows it
11:49:11 <mmorrow> bd_: also, i vaguely remember reading this statement somewhere recently, but i can't remember where
11:49:41 <bd_> mmorrow: It can keep running in parallel as long as it has an independent nursery and only goes and locks when it needs more space. But I've not read the code and the paper I read (years ago) glossed over allocation :)
11:50:02 <SamB> ... it's just not that easy to come up with a more appropriate hack
11:50:19 <mmorrow> bd_: but then, how can one non-allocating thread seize up the entire rts?
11:50:32 <And[y]> yes, sure thomastc, thanks again ... i allready played with your first implementation, now i will check this one :)
11:50:49 <mmorrow> it can't be pre-empted, but shouldn't the other thread(s) of haskell (not rts) control make progress?
11:51:18 <bd_> mmorrow: by never causing a gen0 GC
11:51:20 <Phyx-> And[y]: remember to remove the reverse
11:51:41 <bd_> mmorrow: in which case it need never enter the RTS, and need never switch to another user thread
11:51:44 <mmorrow> bd_: ahhh, totally. i see
11:52:03 <And[y]> yes, sure. you guys are really helpfull :)
11:52:06 <Baughn> Should it really need a separate heap for /allocation/? Couldn't an atomic increment do it?
11:52:06 <mmorrow> bd_: since then it'd have to wait for the never-finishing or allocating thread to finish..
11:52:20 <Baughn> *separate heap or lock
11:52:30 <mmorrow> Baughn: that's prohibitively expensive though
11:52:50 <Baughn> mmorrow: Atomic increments? Even on single-cpu, multi-core systems?
11:53:03 <bd_> Baughn: yes. multi-core systems can still have independent L1 caches.
11:53:07 <Baughn> mmorrow: I can see the coherency chatter being a problem on larger ones
11:53:10 <bd_> and haskell does a LOT of allocation
11:53:44 <Baughn> Well.. maybe if it allocated a larger per-thread chunk, and then satisfied allocations from that?
11:54:09 <bd_> Baughn: yes, that's having a seperate nursery heap :)
11:54:17 <mmorrow> Baughn: i ran a program with 8 pthreads all using __builting_fetch_add() (which compiles to "lock; blah blah;") to bump a single var repeatedly, then yield, and my system load went to 10 pretty fast
11:54:27 <Baughn> bd_: Except then you don't have to copy data to get it to the real heap
11:54:34 <bd_> mmorrow: of course it would, you're not sleeping
11:54:36 <Baughn> bd_: Is it GCed at the same time?
11:54:53 <mmorrow> bd_: hmm
11:55:07 <bd_> Baughn: GHC always copies at a GC. And most data is short lived, so when the GC does come, you only copy a fairly small amount into the gen1 heap.
11:55:26 <Baughn> mmorrow: Is.. that meant to be surprising?
11:55:44 <mmorrow> Baughn: beats me
11:55:45 <mmorrow> :)
11:55:45 <Baughn> bd_: Right. I wasn't sure if the nursery might be an exception or not.
11:56:13 <bd_> the nursery's just the gen0 heap, nothing more.
11:56:23 <Baughn> Mm
11:56:29 <bd_> it's called the nursery because it has baby object, most of which die young
11:56:35 <mmorrow> anyways, i think it's pretty prohibitively expensive, compared to alloc being 3 mach instructions
11:56:44 <Baughn> Hm. Does it lock the entire RTS to GC one nursery heap, though?
11:57:56 <bd_> Baughn: Why would it? No other heaps need reference the local nursery (if you hand data off to another thread you can copy it to gen1 right there), and gen1 by definition cannot reference gen0
11:58:01 <bd_> so it's nice and self-contained
11:58:16 <Baughn> bd_: It wouldn't. I was just curious.
11:58:29 <bd_> I'm not looking at the source here, just theorizing, note :)
11:58:29 <Baughn> bd_: You have to admit, there are a couple of other oddities in GHC.
11:58:33 <Baughn> ..eh
11:58:56 <bd_> although I'm almost certain I've seen it described somewhere >.>
11:59:02 <Baughn> bd_: What I'm thinking of is that it would necessarily have to lock the G1 heap to copy stuff there from the nursery
11:59:09 <Baughn> bd_: That, or use atomic increment
11:59:31 <bd_> indeed. but hopefully that should be rare
11:59:34 <Baughn> ..I think atomic increment would be faster, mind you. I can't see any situation where it's slower than a /lock/
12:00:09 <bd_> Baughn: Generally it will be just as expensive as a lock. Which is a lot (on some processors 100x)
12:00:17 <bd_> ) more expensive than a local non-atomic increment
12:00:35 <Baughn> bd_: Well, except locks sometimes block
12:00:52 <bd_> Baughn: sure, and so does lock add ... - just the blocking happens in hardware :)
12:01:03 <Baughn> It's a much shorter block. ^^;
12:01:20 <bd_> but it adds up when haskell spends a large portion of its time allocating
12:01:42 <bd_> it's the difference between one atomic increment per GC and tens of thousands of atomic increments per GC
12:01:49 <Baughn> Mm
12:01:52 <bd_> and the resulting increase in contention
12:02:33 <bd_> ah, in 2007 nursery GCs /did/ take a global lock.
12:09:42 <Baughn> "A grenade plunging from above bounced off his helmet" <-- o_O
12:09:55 <Baughn> ..also, mischan. Sorry about that.
12:26:17 <Cale> Anyone want to try figuring out how to write RecPromptT?
12:33:19 <Saizan> newtype PromptT p m a = PromptT {
12:33:34 <Saizan> newtype PromptT p m a = PromptT { unPromptT :: Prompt (Lift p m) a }
12:34:08 <Saizan> newtype RecPromptT p m a = PromptT { unPromptT :: Prompt (Lift (p (RecPromptT p m)) m) a } ?
12:34:26 <Cale> hmm, that looks plausible :)
12:34:43 <Botje> *boom*
12:35:00 * Saizan opens an umbrella
12:35:41 * Botje rains down upon #haskell as brain chunks and cranial matter
12:37:21 <Saizan> it'd make a nice comic strip for HWN :)
12:39:04 <shepheb> perhaps #haskell should adopt the umbrella as a symbol?
12:39:18 <anq> Heh.
12:40:38 <Cale> Ohoho, this appears to maybe work :)
12:40:51 * Cale has all the instances.
12:40:59 <Cale> They typecheck, so they're probably right :)
12:41:14 <Cale> (and they're almost identical to the ones for PromptT)
12:41:41 <Cale> I can't help but think that the Rec* variants are really all we need then...
12:44:47 <Cale> Well, apart from the fact that the plain version is used to define the recursive one
12:44:57 <dino-> Well, this sucks. I've been trying to build ghc 6.10.3 on DSL. Starting to look like the tools and libs I can install there are just too damn old. bleh
12:45:06 <Cale> DSL?
12:45:12 <dino-> Damn Small Linux
12:45:33 <dino-> A tiny 50M bootable thing
12:45:41 <Cale> ah
12:45:58 <Cale> and the generic one won't work?
12:46:35 <dino-> nope, won't configure
12:46:39 <dino-> Does not think the build environment is "sane"
12:47:02 <Cale> ... yeah, if that's the case, then building the source is out of the question.
12:47:16 <dino-> I was mucking with this thinking about that post by Simon Marlow about a tiny VM with Haskell things already functioning.
12:47:35 <dino-> Well, the minimum I've been able to get a Debian with X and GHC is 1.5G
12:47:45 <dino-> That'a big ass download to "try out Haskell"
12:48:36 <Cale> What's wrong with just getting GHC?...
12:49:05 <Cale> hmm...
12:49:06 <dino-> Here's the email that had come by in the HWN: http://article.gmane.org/gmane.comp.lang.haskell.glasgow.user/17046
12:49:07 <SamB> dino-: maybe talk to kaol?
12:49:48 <dino-> On a postive note, I have learned how to commune with VirtualBox and also how to whittle a Debian down to the bare-ass minimum lately. So yay me.
12:50:19 <dino-> Virtual Machine things are very liberating. You can fearlessly do insane things.
12:50:48 <Paczesiowa> what about remote ghc? tine sh wrapper that sends sources to community server running ghc, which responds with binary files?
12:50:53 <Paczesiowa> *tiny
12:51:18 <dino-> SamB: kaol?
12:51:18 <EvilTerran> Paczesiowa, you'd better be using SSL for that
12:51:39 <dino-> Paczesiowa: That's not too far of a stretch to a public *nix server that we give accounts out on.
12:51:39 <SamB> dino-: the debian maintainer for ghc6
12:52:05 <SamB> dino-: I think that's likely as soon as this alleged "SPARC project" is finished ?
12:52:10 <dino-> SamB: Ah, now there's the really good way to achieve this ease of getting started, have very up to date .deb files at all times.
12:52:18 <dino-> You service the Ubuntu people, you get a LOT of users.
12:52:19 <Paczesiowa> dino-: we?
12:52:49 <Paczesiowa> EvilTerran: why ssl? I'd think dos would be bigger problem
12:53:12 <SamB> dino-: it's a shame Haskell binaries break ABI with virtually every revision
12:53:50 <SamB> dino-: and I just meant you could talk to him about figuring out how to build a smaller Debian image with GHC in it
12:54:06 <Cale> dino-: The problem with Ubuntu is that ghc always releases major versions about a month after Ubuntu does.
12:54:29 <dino-> But if there are .deb files of more modern stuff that I can download, I would.
12:54:37 <Cale> Though I'm not sure what's going on with the latest version.
12:54:45 <Cale> Yeah.
12:54:49 <dino-> There's nothing wrong with operating outside the safe repositories if you don't break people's systems.
12:54:53 <SamB> Cale: how often does ubuntu release?
12:55:00 <Cale> SamB: every 6 months
12:55:12 <dino-> Using Debian for so long, I really don't expect everything to be in testing for me at all times, but having downloadable .debS is very nice.
12:55:22 <SamB> dino-: maybe things will improve when launchpad gets Debian PPAs ?
12:55:42 <dino-> SamB: Wait, what's ABI? What's launchpad and a PPA?
12:56:11 <sneep> Hi, I'd like to write a function that raises every element in a whole list (first argument) to the nth power (second argument)
12:56:13 <SamB> by "break ABI" I mean "you need to rebuild all dependant packages before you can use them with that new version"
12:56:27 <opqdonut> sneep: use map
12:56:30 <sneep> map round (map (**3) [1,2,3,4]) -- This works just fine in the interpreter, but putting this in a function and replacing 3 and the list by variables yields an error
12:56:38 <monochrom> An Ubuntu LiveCD is below 700MB. This is of course because compression is used. The same software installed properly is like 2-4GB. But anyway, if you modify the Ubuntu LiveCD so it has GHC, it will still be below 700MB, at least that's what you send over the Internet.
12:56:52 <sneep> http://pastebin.com/d52f820fb <-- This is my code and the error message
12:56:58 <SamB> launchpad is a service provided by canonical, the company behind ubuntu
12:57:18 <Botje> sneep: ** is of type (Floating a) => a -> a -> a
12:57:19 <EvilTerran> ?type (**) -- sneep
12:57:20 <opqdonut> sneep: you should be using ^, not **
12:57:20 <lambdabot> forall a. (Floating a) => a -> a -> a
12:57:23 <monochrom> In any case, I propose to worry less about the image size. 2-4G is small enough for me.
12:57:26 <opqdonut> sneep: ** is for floating types
12:57:27 <SamB> PPA stands for "personal package archive", and they provide automatic builds of Debian-style packages
12:57:28 <EvilTerran> ?type (^) -- sneep, you probably want this
12:57:30 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
12:57:43 <sneep> I see :o
12:57:48 <opqdonut> sneep: the problem was that you are not giving an explicit type in ghci
12:57:52 <opqdonut> so it infers Double
12:57:54 <dino-> SamB: (launchpad) Ah, I kind of ignore anything about Ubuntu that doesn't map over to actual Debian.
12:58:00 <SamB> dino-: unfortunately, so far they only build them for ubuntu
12:58:02 <monochrom> If you just worry about download and upload bandwidth, use compression, don't go for a "small linux".
12:58:04 <Cale> Also...
12:58:07 <Cale> :t (^^)
12:58:08 <opqdonut> sneep: or rather, it infers Flaoting a => a which gets defaulted to Double
12:58:09 <lambdabot> forall a b. (Fractional a, Integral b) => a -> b -> a
12:58:13 <EvilTerran> ?quote fire.hose
12:58:13 <lambdabot> byorgey says: sometimes asking #haskell for help can be like taking a drink from a fire hose
12:58:50 <Badger> hah
12:58:50 <dino-> monochrom: Ya, that would be better, <= 700M  But I still think the real problem is ease of installing GHC on the popular distros.
12:58:55 <SamB> dino-: actually, some PPAs are usuable even with Debian -- especially if the majority of the code in them is Python code
12:59:22 <SamB> I don't use Ubuntu either
12:59:47 <SamB> which is why I'm so frustrated that PPAs don't work here on Debian yet
13:00:01 <dino-> I'm even getting slowly sad at how much I have to beat Debian with a stick to make it not install crazy useless junk.
13:00:12 <dino-> Probably going to force me to Arch eventually.
13:00:38 <SamB> dino-: yeah, really
13:00:41 <sneep> Hmm, I'm still getting an error
13:00:50 <sneep> ERROR "test.hs":2 - Instance of RealFrac Integer required for definition of test
13:00:52 <SamB> what's with this ~150 MB KDE icon theme package?
13:01:05 <EvilTerran> sneep, you don't need "round" if you're using (^)
13:01:18 <sneep> Hmm, true
13:01:34 <sneep> ERROR "test.hs":2 - Instance of Floating Integer required for definition of test
13:01:48 <dino-> SamB: Now wait, what you said about ABI, what has to be built again? If I upgraded GHC, do you mean like the libs listed in ghc-pkg?
13:01:53 <sneep> (With round removed)
13:02:33 <sneep> Wait, I'm a liar
13:02:35 <sneep> Sorry
13:03:23 <sneep> Cool, thanks
13:03:28 <sneep> Working now
13:03:40 <dino-> I see, Ubuntu is trying to make it easier for people to push things up to an apt-repo without becoming an uber-deb-packeger. The PPA thing.
13:03:40 <SamB> dino-: well, yeah!
13:04:07 <SamB> dino-: well, the main feature is that it does the builds for you
13:04:16 <dino-> SamB: I just figured that was life. You let cabal-install loose on them all in a big wave of rebuilding on those dark, but hopefully infrequent days.
13:04:22 <SamB> ("well, yeah!" was re: ghc-pkg)
13:05:44 <SamB> dino-: also, every time a new .deb version of a library is built, all the dependant library .debs need rebuilding too
13:06:39 <fynn> Yo.
13:06:39 <fynn> What's the best textbook for a course that teaches algorithms and data structures to CS undergraduates, using Haskell?
13:06:58 <SamB> there seem to be a number of not-actually-installable GHC library packages in "unstable" because they haven't caught up with their dependencies yet
13:07:18 <dino-> I also don't know where and how the Haskell Platform fits into this. I haven't read much about it yet.
13:07:37 <dino-> But sounds like there's some crossover with this.
13:07:48 <SamB> dino-: well, if it allows a lot of these .debs to be built in one go, I'm all for it!
13:08:01 <edwardk> fynn: good question, i can't think of a great reference that fits all of those requirements (though some might disagree and point to something like Hudak's book)
13:08:48 <edwardk> Maybe Bird's Introduction to Functional Programming using Haskell? but its getting kind of long in the tooth
13:10:00 <monochrom> There is a specific "algorithm and data structure" book using Haskell. I forgot its name.
13:10:23 <edwardk> and it starts somewhat math-centrically rather than algorithm and data structure-centric
13:10:47 <edwardk> i love okasaki's book which includes a haskell appendix but all of the incrementally worked examples are in ML
13:11:05 <fynn> monochrom: http://www.amazon.com/Functional-Approach-Programming-Guy-Cousineau/dp/0521576814 maybe?
13:11:12 <monochrom> "Algorithms A Functional Approach"  http://www.haskell.org/haskellwiki/Image:Algorithms_A_Functional_Approach.jpg
13:11:14 <PeterMc> fynn: Can you assume that your students grok the IO Monad?
13:11:49 <FliP^2eH> > 1:2:3:[]
13:11:50 <fynn> PeterMc: no, these are freshmen for the most part. some of them do program, even extensively, but most likely not in Haskell.
13:11:51 <lambdabot>   [1,2,3]
13:11:56 <FliP^2eH> > []:1:2:3
13:11:57 <lambdabot>   No instance for (GHC.Num.Num [[a]])
13:11:58 <lambdabot>    arising from the literal `3' at <int...
13:12:08 <edwardk> point them to Learn You a Haskell ;)
13:12:37 <PeterMc> If they don't get Monads, they're going to have real trouble with stateful algorithms, aren't they?
13:13:02 <monochrom> Just pass around the "state" explicity.
13:13:13 <edwardk> Unfortunately, I honestly can't think of a solid Haskell text book that I would want to use to teach a freshman/sophomore real 'computer science' class.
13:13:14 <Botje> map and fold are a lot more natural than loops, imo
13:13:18 <bavardage> wait, these are people learning comp sci?
13:13:23 <bavardage> why can't they just learn monads?
13:13:27 <monochrom> Write in CPS so the "state" is only in parameters but never return values. :)
13:13:57 <fynn> in any case, it's much more important for the course to teach algorithms than it is for it to teach advanced / current Haskell skills
13:14:15 <bavardage> and they won't be interested enough to play around in their spare time?
13:14:21 <monochrom> Bird's intro book mentioned above would be one for both learning Haskell and learning 1st-year CS.
13:15:22 <edwardk> Bird is the best that I've actually read, but http://www.iro.umontreal.ca/~lapalme/Algorithms-functional.html looks interesting
13:15:43 <edwardk> best in the context of the current discussion that is
13:15:44 <PeterMc> fynn: If you're trying to teach things like, say, heapsort, there's a fair chance that Haskell is just going to get in the way.
13:15:53 <monochrom> Here, "1st-year CS" means induction and related proof rules for correctness, the first stab at proving running time, and a couple of very simple data structures.
13:15:56 <Athas> Does anyone have a clever idea for how to define € and £ operators?
13:17:05 <dino-> There was another algorithms with Haskell book that I liked, trying to find it now..
13:17:06 <monochrom> http://www.iro.umontreal.ca/~lapalme/Algorithms-functional.html is exactly the "algorithm and data structure book" I know of.
13:17:36 <edwardk> ah cool
13:17:49 <dino-> Yes, that one
13:17:52 <sjanssen> PeterMc: I think DiffArray solves most of those issues
13:18:33 <PeterMc> sjanssen: Does it?  Fair enough.
13:19:04 <dino-> Wow, it was expensive when I bought one and it's like double that now. :O
13:19:17 <dino-> $220
13:19:25 <edwardk> dino: which?
13:19:32 <sjanssen> PeterMc: but I do agree somewhat, a few algorithms are better in an imperative setting
13:19:36 <dino-> http://www.amazon.com/Algorithms-Functional-Programming-Approach-International/dp/0201596040/ref=sr_1_1?ie=UTF8&s=books&qid=1245097124&sr=8-1
13:19:49 <dino-> The Rabhi/Lapalme book
13:19:51 <sjanssen> heapsort and union-find come to mind
13:19:56 <edwardk> ah
13:20:12 <dino-> I treat it gently, needless to say.
13:20:22 <edwardk> ok, so that text is probably out as an option for a first year course. they'd lynch you over the fees and the fact that its out of print ;)
13:21:18 <sjanssen> OTOH, Haskell will greatly simplify the presentation of many other algorithms.  See the classic two-line quicksort and anything involving binary search trees
13:21:19 <edwardk> that said, there is still no proof that there doesn't exist an asymptotically equivalent algorithm for union find in a lazy functional setting.
13:21:39 <jmcarthur_work> sjanssen, although arguably that two-liner is not quicksort
13:21:58 <edwardk> though i highly doubt that it does exist ;)
13:22:26 <EvilTerran> there's always the insertion sort in the report
13:22:36 <sjanssen> jmcarthur_work: I find those arguments pedantic.  It's a quicksort, just not an optimal one
13:22:52 <jmcarthur_work> sjanssen, i said "arguably" ;)
13:22:54 <EvilTerran> and ghc's mergesort is a bit longer, but very cunning
13:24:25 <FliP^2eH> How can I map a function to some element of a list (matched by a predicate), but return the whole list, with only the matched elements changed?
13:24:29 <SamB> sjanssen: it's not a quicksort in spirit
13:24:45 <SamB> it's like implementing BF without using Ptr
13:25:13 <PeterMc> sjanssen: Is that flamebait?  ;)
13:25:19 <sjanssen> what's wrong with implementing BF without using Ptr?  I have a half-written zipper BF somewhere
13:26:14 <roderyk> gtk2hs question: "on drawingArea buttonPressEvent (..)"  and "on drawingArea motionNotifyEvent ..." where 'on' is from System.Glib.Signals, I get the following error:  Couldn't match expected type `Graphics.UI.Gtk.Gdk.EventM.EMotion'   against inferred type `Graphics.UI.Gtk.Gdk.EventM.EButton'
13:26:18 <gbacon> with FFI, is it possible to call through a foreign function-pointer?
13:26:24 <tromp> i have a BF written in plain lambda calculus somewherre
13:26:35 <roderyk> can I not apply both to the same window? or is there some way to cast from one to another?
13:26:44 <sjanssen> FliP^2eH: map (\x -> if predicate x then f x else x)
13:26:56 <FliP^2eH> Oh, thanks sjanssen :)
13:27:39 <jmcarthur_work> yeah zipper BF is very nice and elegant
13:28:16 <sjanssen> SamB: in general, I think the presentation of algorithms really ought to take a step or two away from the iron and teach the higher level concepts
13:28:28 <SamB> sjanssen: yeah, usually
13:28:28 <FliP^2eH> Okay better question
13:28:36 <FliP^2eH> Apply a function to every second element of a list :D
13:28:41 <SamB> but quicksort *means* something
13:28:41 <FliP^2eH> I'm puzzled
13:28:55 <SamB> FliP^2eH: every other element
13:29:14 <FliP^2eH> what!
13:29:23 <EvilTerran> FliP^2eH, well, can you write it as a direct recursion?
13:29:29 <FliP^2eH> I think I could
13:29:32 <FliP^2eH> I'll try, at least
13:29:36 <jmcarthur_work> FliP^2eH, break it up, map over one, merge them back?
13:30:19 <EvilTerran> FliP^2eH, i've quite frequently written something directly, gained enlightenment from looking at that version, then re-written it as a map or fold or whatever
13:30:52 <FunctorSalad> is that good or bad?
13:30:53 <jmcarthur_work> i prefer to think about "big steps" now. maps and folds are big steps
13:30:59 <FunctorSalad> (the more concise rewriting)
13:31:14 <jmcarthur_work> even if i have to write more functions to be able to do those big steps
13:31:21 <monochrom> It is like debating whether ocaml is "functional or not".
13:31:50 <jmcarthur_work> so i would write a function to break the list up into odds and evens, then map over the evens list, then write a function to merge the two lists back into one
13:31:50 <EvilTerran> FunctorSalad, i find the rewrite brings me closer to just saying what value i want, while the original is more micro-manage-y
13:31:54 <SamB> monochrom: hmm, how about "almost"?
13:32:33 <sjanssen> FliP^2eH: zipWith ($) [f, id] xs
13:32:46 <sjanssen> erm, zipWith ($) (cycle [f, id]) xs
13:33:18 <EvilTerran> FliP^2eH, btw, you're not allowed to use sjanssen's version unless you know how it works ;)
13:33:27 <FunctorSalad> EvilTerran: yeah, abstractions can certainly increase readability (depending on how used the reader is to them, of course), but maybe if you yourself must write it out to understand it, then maybe the abstraction isn't good for readability/maintainability?
13:33:36 <FliP^2eH> I do know how it works
13:33:44 <FliP^2eH> Not that hard, eh?
13:33:57 <EvilTerran> FunctorSalad, i can look at the abstracted version and know that it works
13:34:04 <hackagebot> hprotoc 1.5.1 - Parse Google Protocol Buffer specifications (ChrisKuklewicz)
13:34:04 <EvilTerran> FunctorSalad, i just sometimes can't work it out directly
13:34:17 <monochrom> Anyway, an aspect of quicksort is an instance of divide-and-conquer in which the "divide" is non-trivial (some kind of Dedekind cut) and the "conquer" is trivial (just concat). That aspect is faithfully reproduced in the usual Haskell version. If you, OTOH, focus on the "you have to do that in-situ" aspect, of course it is hopeless in Haskell.
13:36:21 <FunctorSalad> you must feel the pain from the signpost issues with the indices, otherwise it isn't quicksort o_O
13:36:38 <monochrom> I actually love the former view very much. In the space of applying divide-and-conquer to sorting, quicksort is one vertex (as described above), and mergesort is the antipodal vertex: "divide" is trivial (just the inverse of concat), "conquer" is non-trivial (you have to interleave by respecting <=)
13:37:37 * EvilTerran doesn't see where dedekind cuts come into it...
13:38:14 <monochrom> Insertion sort is another point in that space. "divide" is just the inverse of cons, "conquer" is insert by respecting <=.
13:38:15 <PeterMc> Athas: Not especially clever, but how's this:
13:38:41 <PeterMc> Athas: () £ gbp = gbp * 1.625
13:38:54 <olsner> so this is #haskell sorting out sorting :)
13:38:57 <monochrom> All these I learned from Douglas Smith's work.
13:39:10 <PeterMc> Athas: () € eur = eur * 1.3783
13:39:45 <PeterMc> Athas: Then you can write things like in_eur f = f () / 1.3783
13:40:31 <monochrom> "partition using a pivot" is Dedekind's cut at the pivot.
13:40:42 <PeterMc> Athas: in_eur (£ 25)  ==> 18.14
13:40:57 <monochrom> s/is/is like/  # if you are really pedantic
13:41:12 <Athas> That's not as sexy as making it some obscure combinator.
13:41:38 * EvilTerran was thinking the lower portion of a dedekind cut had to be open from above, is all
13:41:53 * glguy thinks puremd5's binary instance for md5digest might be broken
13:42:12 <FliP^2eH> everySecond :: (a -> b) -> [a] -> [b]  |  everySecond f a = map (\(n,v) -> if even n then f v else v) (zip [1..] a)
13:42:18 <FliP^2eH> Do you see any error?
13:42:20 <FunctorSalad> Athas: should be sth similar to ($)
13:42:26 <FliP^2eH> "Couldn't match expected type `b' against inferred type `a'"
13:43:01 <EvilTerran> FliP^2eH, yeah, f v :: b, v :: a, and you're using those as branches of an "if"
13:43:13 <FunctorSalad> > trace "hi" 1
13:43:15 <lambdabot>   Not in scope: `trace'
13:43:35 <FliP^2eH> What's wrong with that?
13:43:42 <PeterMc> Athas: Well, yeah, if you have a fetish for obscure combinators then obscure combinators are sexy.
13:43:51 <EvilTerran> FliP^2eH, branches of an if-expression have to be the same type
13:44:01 <EvilTerran> ie, the type of the if-expression overall
13:44:02 <FliP^2eH> Oh
13:44:03 <FliP^2eH> Okay
13:44:08 <FliP^2eH> You're right
13:44:12 <EvilTerran> ?type \x y -> if undefined then x else y
13:44:13 <lambdabot> forall t. t -> t -> t
13:44:38 <FliP^2eH> Soo
13:44:48 <FliP^2eH> How can I leave the else brache unmodifed...
13:44:57 <FliP^2eH> But yet have it the same type..?
13:45:08 <EvilTerran> change your type signature to be all "a"s?
13:45:13 <opqdonut> or use Either
13:46:03 <Jedai> FliP^2eH: f v and v can't have the same type if f :: a -> b with a /= b
13:46:07 * PeterMc suddenly remembers why he came here in the first place.
13:46:13 <EvilTerran> FliP^2eH, if you think about it, sometimes you'll be including an element of the parameter list as an element of the result list, so the lists have to be the same type
13:46:33 <FunctorSalad> PeterMc: finally solved the age-old question? ;)
13:46:44 <FliP^2eH> Same typed is a must, so yeah
13:46:46 <PeterMc> Is there anyone present who's involved in AngloHaskell 2009?
13:46:48 <FliP^2eH> Didn't think about it
13:46:51 <FliP^2eH> Fixed it :)
13:46:54 <Jedai> FliP^2eH: so you have to make the type of everySecond :: (a -> a) -> [a] -> [a]
13:46:56 <FliP^2eH> everySecond f a = map (\(n,v) -> if even n then f v else v) (zip [0..] a)
13:46:58 <monochrom> everySecond :: (a -> a) -> [a] -> [a]
13:47:08 <FliP^2eH> everySecond (toUpper) "testing"
13:47:11 <FliP^2eH> TeStInG <-
13:47:22 <opqdonut> you might want to use (zip (cycle [True,False]))
13:47:25 <opqdonut> instead of numbers
13:47:30 <monochrom> Haha
13:48:03 <FliP^2eH> Okay :)
13:48:12 <EvilTerran> opqdonut, or zipWith ($) (cycle [f,id]), as suggested above
13:48:14 <Jedai> FliP^2eH: use zipWith instead of map and zip
13:48:19 <opqdonut> EvilTerran: even nicer
13:48:33 <Jedai> EvilTerran: nice :)
13:48:38 <opqdonut> of course <*> in the zip applicative would be better
13:48:59 <EvilTerran> opqdonut, Jedai: blame sjanssen
13:49:10 <opqdonut> sjanssen?
13:49:19 <opqdonut> ah, he suggested it first?
13:49:37 <opqdonut> i prefer zipWith id to zipWith ($) personally
13:50:35 <Jedai> opqdonut: I prefer ($) since it express the fact that it's an application, even if id == ($)
13:50:48 <opqdonut> sure
13:51:03 <FliP^2eH> Occurs check: cannot construct the infinite type: a = [a]
13:51:03 <FliP^2eH>     When generalising the type(s) for `everySecond'
13:51:10 <FliP^2eH> everySecond f a = zipWith ($) (cycle [f a, id]) a
13:51:12 <FliP^2eH> ;s
13:51:17 <opqdonut> but id is both clenaer looking and carries the intent pretty well
13:51:22 <FliP^2eH> Oh wait
13:51:30 <FliP^2eH> No f a
13:51:38 <Cale> I prefer ($) for application
13:51:41 <opqdonut> it's quite natural once one is used to thinking about curried functions etc
13:51:45 <Cale> Especially in the case of zipWith
13:51:56 <PeterMc> opqdonut: I prefer ($) because my slow brain understands that version at first glance, but not the other.
13:53:23 <Jedai> opqdonut: I don't see how "id" for application carry the intent pretty well ? I would use id for identity, and ($) for application, it seems much clearer to me (though you can deplore the symbol in ($) depending on your taste).
13:53:43 <FunctorSalad> id for app seems obfuscatory imho
13:54:23 <Jedai> opqdonut: ($) is the type-restricted version of id that happens to have exactly the right type there, it seems more natural to use it rather than the more general and less precise id
13:54:42 <FunctorSalad> @type ($)
13:54:43 <lambdabot> forall a b. (a -> b) -> a -> b
13:54:44 <opqdonut> guess i jsut think of zipWith f xs ys as "pure f <$> xs <*> ys"
13:54:47 <skorpan> @type id
13:54:49 <lambdabot> forall a. a -> a
13:54:49 <FunctorSalad> oh, it is specialised indeed
13:57:19 <olsner> opqdonut: hmm, isn't that just xs <*> ys if f == id?
13:58:25 <Jedai> olsner: except that the applicative instance for [] isn't the zip one
13:59:02 <skorpan> @src Applicative []
13:59:02 <lambdabot> Source not found. I am sorry.
13:59:05 <skorpan> @src Applicative [a]
13:59:05 <lambdabot> Source not found. I've seen penguins that can type better than that.
13:59:10 <skorpan> @index Applicative
13:59:11 <lambdabot> bzzt
13:59:14 <olsner> oooh, right, you get the cartesian product-like thing with ap
13:59:20 <skorpan> i never remember how the hell this stupid bot works
13:59:30 <jmcarthur_work> list is weird anyway
13:59:30 <Jedai> skorpan: it's cartesian one, to correspond with the monad instance
13:59:33 <olsner> @src [] ap
13:59:33 <lambdabot> Source not found. Where did you learn to type?
13:59:44 <jmcarthur_work> @src [] (<*>)
13:59:45 <lambdabot> (<*>) = ap
13:59:49 <jmcarthur_work> grr
13:59:53 <olsner> @src ap
13:59:54 <lambdabot> ap = liftM2 id
14:00:09 <olsner> deep the rabbit hole goes
14:00:13 <jmcarthur_work> @src ZipList (<*>)
14:00:14 <lambdabot> Source not found.
14:00:27 <skorpan> i don't get it... (<*>) for [] is "cartesian one"?
14:00:46 <Philonous> It's >>= aka concatMap
14:00:47 <Jedai> skorpan: it makes a cartesian product before applying
14:00:51 <jmcarthur_work> Applicative for [] is for the same thing as Monad for []
14:01:02 <skorpan> when you say cartesian product in haskell i think tuples
14:01:11 <jmcarthur_work> you have to use the ZipList newtype for the zip semantics
14:01:26 <olsner> skorpan: pure (,) <$> xs <*> ys == cartesian product
14:01:26 <Philonous> Oh, never mind
14:01:56 <Jedai> skorpan: well the cartesian product in the ensemblist sense that each element of the first list is associated with each element of the second
14:01:58 <jmcarthur_work> > (,) <$> [1..3] <*> [4..6]
14:02:00 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
14:02:06 <jmcarthur_work> ^^ no pure needed for that
14:02:10 <opqdonut> olsner: indeed, that is why i like zipWith (id)
14:02:13 <jmcarthur_work> pure if you don't use <$>
14:02:24 <opqdonut> and yes, the pure was a thinko
14:03:43 <Jedai> skorpan: Do you have a better term for the concept (I'm not a native speaker so I might have missed something)
14:04:08 <jmcarthur_work> > getZipList $ (+) <$> ZipList [1..3] <*> ZipList [4..6]
14:04:10 <lambdabot>   [5,7,9]
14:07:57 <Zao> Does someone know which glut version the HP GLUT package was built against?
14:09:08 <dblazakis_> does anyone remember who was working on the data description embedded DSL-- i think it was a template haskell thing on top of Data.Binary?
14:09:26 <dblazakis_> probably 8-12 months ago, now i can't remember who or what it was
14:32:52 <syntaxfree> Are we ever getting monad comprehensions back?
14:33:47 <syntaxfree> (as an aside, do propositions in a modal second-order propositional logic form a sigma-algebra suitable for probability theory?)
14:37:14 <Cale> syntaxfree: If someone implemented monad comprehensions as a patch for GHC, it would get applied.
14:37:45 <Cale> syntaxfree: But it seems that nobody who is knowledgeable enough about GHC to do it seems to want them enough?
14:39:25 <SamB> Cale: isn't the tricky bit to do that without breaking compatability with all of the existing libraries ?
14:40:04 <Saizan_> it'd be a LANGUAGE extension, i guess
14:40:06 <Phyx-> well, since ghc is largely undocumented, doesn't really surprise me that many people don't put the time indo understanding it
14:52:24 <syntaxfree2> I'm going to the logs to see if my last message got posted, but I'm guessing it wasn't.
14:52:54 <syntaxfree2> what day is today, anyway?
14:53:22 <Lemmih> syntaxfree2: There aren't any plans to bring it back.
14:53:45 <Lemmih> syntaxfree2: Monday for a few more minutes.
14:54:49 <syntaxfree2> Why have list comprehensions at all, then? They're easily translated to monad do-notation.
14:55:13 <Lemmih> They are pretty.
14:55:17 <syntaxfree2> I guess I sound like I'm trolling and this has been argued to the ground. Nevermind :)
14:57:12 <Cale> Monad comprehensions are also pretty
14:57:22 <Cale> I think it would be really nice to have them.
14:57:37 <Cale> They would work beautifully for most MonadZero types.
14:57:41 <syntaxfree2> syntaces bring out the beauty of the underlying concepts.
14:57:42 <Cale> Particularly for logic monads.
14:58:31 <Cale> I suppose one trouble with bringing back monad comprehensions is that they need MonadZero
14:58:39 <Cale> and that was removed from Haskell 98
14:58:54 <syntaxfree2> that's why most object oriented languages use object hierarchy-function-argument order, even though there can be ambiguity in here.
14:59:15 <Cale> hm?
14:59:30 <hackagebot> bool-extras 0.3.0 - A fold function for Bool (TomLokhorst)
14:59:37 <syntaxfree2> Cale: Isn't MonadPlus a superset of of MonadZero?
14:59:44 <FunctorSalad> hackagebot: isn't that "if"?
14:59:56 <Cale> It's a superset of methods, but a subset of types
15:00:37 <syntaxfree2> Cale: take Python -- when do you use objectname.dothis and when do you use dothis(objectname)? It's very idiosyncratic.
15:00:46 <syntaxfree2> (did I spell idiosyncratic right?)
15:00:49 <Cale> yeah
15:00:58 <Cale> I think the latter is always preferable to me.
15:01:24 <Cale> At least, as far as notation goes
15:01:46 <FunctorSalad> yes. the special treatment for the first of a function's argument in OO is so arbitrary/ugly
15:01:53 <FunctorSalad> *arguments
15:02:03 <syntaxfree2> yep. then you have thingA.stuff as a namespace delimiting device.
15:03:17 <syntaxfree2> anyway, any hint on whether  propositions on "some" modal second-order logic form a sigma-algebra?
15:03:43 <syntaxfree2> "some" meaning some simple logic with the basic natural deduction apparatus.
15:05:00 <syntaxfree2> Cale: oh, I got what you meant by the MonadZero problem now.
15:06:46 <dino-> I had this come up as well when I was disappointed that mplus give you "this or that" behavior in Maybe but concat behavior in list. I was directed by people to this page: http://haskell.org/haskellwiki/MonadPlus_reform_proposal
15:07:15 <opqdonut> well catenation is "this or that" in the list monad
15:07:30 <opqdonut> as the list monad is usually seen to represent nondeterminism
15:07:41 <dino-> opqdonut: Kind of, but I ran into a situation where I wanted "" `mplus` "default string"
15:07:50 <syntaxfree2> I was hoping that the existing MonadPlus was the only possibility from cat theory.
15:08:17 <Cale> I think there should be separate MonadZero, MonadPlus, and MonadElse classes
15:08:21 * syntaxfree2 is feeling kinda hypomanic.
15:08:28 * jmcarthur_work agrees with Cale 
15:08:39 <Cale> The last of which would have an instance for lists that would only use elements from the second list when the first was empty.
15:08:54 <FunctorSalad> syntaxfree2: :D
15:09:29 <Cale> I'm not sure that MonadPlus even has a name in category theory.
15:09:40 <opqdonut> oh, i love section 3 in that wiki article
15:10:28 <Cale> I think the idea of merging it into Monad is really stupid.
15:10:35 <Cale> Also, fail needs to die.
15:10:37 <syntaxfree2> cat theory has the same kind of chilly appeal that benzodiazepines have for me.
15:10:47 <syntaxfree2> If I start thinking about it I get derailed from what I was gonna do.
15:11:25 <Cale> (or at the very least be moved into a second class)
15:11:31 <jmcarthur_work> MonadFail
15:11:35 <Cale> right
15:11:44 <syntaxfree2> MonadMonad?
15:11:56 <jmcarthur_work> fail is fail
15:12:15 <opqdonut> IMO we're seeing too fine-grained type classing with all these proposed changes
15:12:19 <jmcarthur_work> :t fix fail
15:12:20 <lambdabot> String
15:12:26 <Cale> opqdonut: I don't think so...
15:12:39 <jmcarthur_work> epic = fix
15:12:41 <Cale> opqdonut: Though something like class aliases would still be nice.
15:12:48 <opqdonut> mhmm
15:14:19 <jimmyjazz14> darcs is so slow
15:14:45 <Cale> jimmyjazz14: which version?
15:14:51 <opqdonut> is jimmy jazz a clash reference?
15:15:08 <Cale> jimmyjazz14: I haven't noticed slowness since version 1.x
15:15:22 <jimmyjazz14> 1.0.9
15:15:27 <jmcarthur_work> > let epic = fix in epic fail
15:15:29 <Cale> Time to upgrade :)
15:15:29 <lambdabot>   ""
15:15:37 <jimmyjazz14> ah
15:16:35 <jmcarthur_work> darcs2 is still noticeably slower than git, but is far better than before
15:16:51 <jimmyjazz14> ah I do need to upgrade
15:17:01 <jmcarthur_work> yeah darcs1 is ooooooooold
15:17:03 <jimmyjazz14> been waiting over an our for a pull
15:17:25 <jimmyjazz14> is version 2 backward compatible?
15:17:42 <jmcarthur_work> darcs2 can use darcs1 repos, but not the other way around
15:18:37 <jmcarthur_work> but there can be a lot of benefit in converting darcs1 repos to darcs2 repos
15:18:50 <jmcarthur_work> you may still experience some slowness with a darcs1 repo, i mean
15:18:57 <jmcarthur_work> maybe not as bad
15:23:41 <kacper_> what is the function which goes like function [[1],[2,3],[4]] returns [[[1],[2],[3]],[[1],[3],[4]]]
15:24:00 <kacper_> i remeber the type was modad m -> ...
15:24:03 <Botje> sequence
15:24:06 <kacper_> thanks
15:24:19 <EvilTerran> ... that's sequence?
15:24:36 <kacper_> yes
15:24:38 <EvilTerran> ah, of course, lists-as-nondet
15:24:40 <Botje> > sequence [[1],[2,3],[4]]
15:24:42 <lambdabot>   [[1,2,4],[1,3,4]]
15:24:43 <aavogt> > sequence "abc"
15:24:44 <lambdabot>   Couldn't match expected type `m a'
15:24:58 <aavogt> > sequence $ map (:[]) "abc"
15:24:59 <lambdabot>   ["abc"]
15:30:46 <benny99> > map (:[]) "abc"
15:30:48 <lambdabot>   ["a","b","c"]
15:33:08 <FunctorSalad_> just thought of a scheme for unfolds without the slightly clumsy Maybe/Pair stuff... http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5906#a5906
15:33:45 <FunctorSalad_> (dualisation to the rescue)
15:37:36 <olsner> FunctorSalad_: cool
15:38:34 <Cale> before I look, is it  unfoldr f p g = map f . takeWhile p . iterate g ?
15:39:00 <Cale> oh, hmm, it's different
15:39:25 <olsner> looks more like streams
15:39:58 <FunctorSalad_> it just supplies two functions to the unfolder, one to call when it would return "Just x y" and one to call if it would return Nothing
15:40:20 <Cale> yeah
15:40:27 <Cale> that's a good idea
15:41:06 <Cale> basically, using the lambda calculus version of Maybe rather than the explicit one :)
15:41:12 <FunctorSalad_> (it would scale better to larger types than nested Eithers, I suppose)
15:41:13 <RayNbow> my mind is blown :p
15:43:17 <FunctorSalad_> actually even the Maybe in unfoldr' there is superfluous ;)
15:44:47 <olsner> @ty let unfoldr' f = f (\a s -> a:unfoldr' f s) [] in unfoldr'
15:44:49 <lambdabot> forall a t a1. ((a -> t -> [a]) -> [a1] -> t -> [a]) -> t -> [a]
15:45:58 <FunctorSalad_> yep
15:46:31 <FunctorSalad_> I deliberately hid the [a]/[a1] though, so the unfold can't do anything but call the functions once
15:47:31 <olsner> yeah, that's a nice touch, possibly even useful (since it decouples the generator from the data structure it generates)
15:49:14 <RayNbow> FunctorSalad_: how is that accomplished?
15:50:40 <FunctorSalad_> RayNbow: with the local forall / Rank2Types. the generator function doesn't know anything about the "done" type, except that it has to produce a "done", and that it has two ways to produce a "done"
15:53:01 <RayNbow> FunctorSalad_: ah, I see
15:53:17 <olsner> @ty let unfoldr' f = f (\a s -> print a >> unfoldr' f s) (return ()) in unfoldr'
15:53:19 <lambdabot> forall a t b (m :: * -> *). (Monad m, Show a) => ((a -> t -> IO b) -> m () -> t -> IO b) -> t -> IO b
15:53:47 <olsner> the type would be nicer with the explicit forall and the type signature though
15:56:45 <olsner> FunctorSalad_: ah, here it is - see data Step a s = [...] here: http://www.cse.unsw.edu.au/~dons/code/streams/list/Data/Stream.hs
15:57:59 <olsner> kind of the same thing, but with an added Skip alternative
15:59:53 <FunctorSalad_> olsner: ah right. must have had that in mind ;)
16:00:42 <RayNbow> Cale, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5909#a5909 <-- is this correct?
16:01:02 <FunctorSalad_> generally it seems that there's a bit of a judgment call to make, when to use "data" and when to make "anonymous" data with this higher-order encoding...
16:02:01 <olsner> really, it's a constructor call -> pattern match that's being folded by tailcalling directly into the right pattern matching case
16:04:11 <lpjhjdh> so I'm trying to use smallcheck to do some stuff with the typed lambda calculus using de bruijn indicies and I'm not sure how to generate ASTs properly (with correct indicies)
16:07:09 <olsner> FunctorSalad_: I think you can also see it as just church encoding conses :P
16:21:26 <soupdragon> lpjhjdh: You should read the paper by the epigram team
16:21:35 <soupdragon> @go I am not a number I am a free variable
16:21:39 <lambdabot> http://www.cs.st-andrews.ac.uk/~james/RESEARCH/notanum.pdf
16:21:39 <lambdabot> Title: I am not a number: I am a free variable
16:21:53 <soupdragon> it's nothing to do with quickcheck though
16:23:02 <syntaxfree2> @go I am not a computer scientist I am a Haskell groupie
16:23:03 <lambdabot> No Result Found.
16:32:28 <Philippa> is there a good library for prettyprinting with highlighting? Alternatively, what programs should I consider cannibalising to write one? (hscolour?)
16:32:51 <Philippa> output to multiple formats is good - HTML and something I can display at the terminal'll do for now
16:33:09 <Alpounet> HsColour does
16:33:17 <Alpounet> there's a -tty output option
16:33:26 <Alpounet> (as well as latex, css, html, ...)
16:33:37 <Philippa> I didn't say prettyprinting Haskell :-)
16:34:01 <thoughtpolice> Philippa: ansi-wl-pprint maybe?
16:34:05 <thoughtpolice> @hackage ansi-wl-pprint
16:34:06 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/ansi-wl-pprint
16:34:20 <thoughtpolice> it doesn't have HTML support I don't think however...
16:38:03 <Philippa> hmm. This sounds suspiciously like I've just accidentally volunteered myself to write a library, doesn't it?
16:38:34 <Philippa> ansi-wl-prettyprint looks good but over-specialised
16:42:29 <lpjhjdh> soupdragon: thanks
16:44:04 <syntaxfree2> there are wordpress plugins that support syntax coloring for some languages, I recall.
16:44:24 <syntaxfree2> Myself, I used SubEthaEdit's HTML export back when I used to blog about Haskell.
16:45:47 <Alpounet> Philippa, that'd be interesting
16:46:28 <Philippa> syntaxfree2: I need a prettyprinting lib, these're new languages I'm writing implementations and tools for
16:46:37 <syntaxfree2> methinks HTML is pretty much the de facto standard for displaying rich text by now.
16:47:07 <Philippa> depends what you're doing - not on the terminal, not if you need sufficiently mathematical rendering, etc
16:47:08 <syntaxfree2> Philippa: do you really need a general prettyprinting implementation that you'll only then specialize to HTML?
16:47:24 <Philippa> yes
16:47:36 <Philippa> because it's not the only thing I'll specialise to
16:48:08 <syntaxfree2> I use a CGI script that calls latex and returns a GIF, and a wordpress plugin that allows [tex] equation [/tex] syntax.
16:48:17 <Philippa> I'd want to insert a semantic vs style separation into that lib too - named markup vs specific colours
16:48:24 <syntaxfree2> maybe I should say calls TeX, not LaTeX.
16:48:46 <Philippa> yeah. I mean: I might well need to prettyprint to LaTeX for eventual PDF output sometime too
16:48:49 <syntaxfree2> I'm pretty sure it's TeX-based (as opposed to an alternate compiler of TeX-ish equations like Mathematica)
16:48:53 <Philippa> say, if I write a paper about my system
16:49:07 <syntaxfree2> PDF is a concern. But then again, literate Haskell,.
16:49:20 <Philippa> ...I'm. Not. Prettyprinting. Haskell.
16:49:41 <syntaxfree2> yeah, sorry. forgot that.
16:50:05 <syntaxfree2> (I find the comma-period is the most expressive two-symbol combination that can be in the languages I know)
16:50:37 <aavogt> @type (,) .
16:50:37 <syntaxfree2> it's an implicit ellipsis, collapsing self-evident conclusions.
16:50:38 <lambdabot> parse error (possibly incorrect indentation)
16:50:47 <aavogt> @type (,) (.)
16:50:48 <lambdabot> forall b c a b1. b1 -> ((b -> c) -> (a -> b) -> a -> c, b1)
16:50:56 <Philippa> prettyprinting's kinda neglected compared to parsing, anyway. Oh well. I guess I have a project now
16:51:00 <syntaxfree2> I meant human languages.
16:51:04 <aavogt> =)
16:51:45 <syntaxfree2> Philippa: there's two different statements in what you said. Maybe three.
16:52:03 <syntaxfree2> 1) There's less work being done in prettyprinting than in parsing for a given language.
16:52:30 <syntaxfree2> 2) The prettyprinting/parsing ratio of work being done is lower than the ratio of usefulness.
16:52:45 <syntaxfree2> 3) The ratio of work being done is lower than the marginal ratio of usefulness.
16:54:32 <Philippa> well, put it this way: people (myself included) are ending up in a position of having to roll their own not due to matters of taste or efficiency but because it's outright not doable with existing libs. cf parsing, where (incremental parsing aside) any nut Parsec can't crack is v.v.nutty indeed and PolyParse offers many options
16:54:43 <syntaxfree2> (number 3 might sound contrived, but it's the optimality condition in many convex optimization problems)
16:55:14 <Philippa> duplication of work being generally bad, and generalisation usually being a cheap task in haskell
16:55:15 <syntaxfree2> Philippa: you mean number 2, except for the wider scope of making new languages.
16:55:41 <Philippa> though that's a big caveat, as haskell's a common choice of metalanguage
16:55:41 <syntaxfree2> well, now it seems that you mean 3, re: duplication of work.
16:56:18 <syntaxfree2> What do you estimate is the Haskell/Lisp ratio in metalanguage-of-choice?
16:56:35 <syntaxfree2> for Lisp <-["Common Lisp", "Scheme"]
16:59:23 <FunctorSalad_> Philippa: have you checked out ansi-wl-pprint?
16:59:42 <uzytkownik> @hoogle Arrow a => b -> a (Maybe b) b
16:59:43 <lambdabot> No results found
16:59:47 <ClaudiusMaximus> what does it mean when my GLUT-using Haskell program crashes with: unmarshalMouseButton: illegal value 5
17:00:17 <ClaudiusMaximus> (given that that name occurs nowhere in my source)
17:00:28 <Philippa> syntaxfree2: no idea, I don't know enough to gauge lisp or scheme use in industry
17:00:41 <Philippa> FunctorSalad_: am looking at it. It's not what I want, but it may be the best starting point
17:01:20 <uzytkownik> @pl \x -> arr $ fromMaybe x
17:01:20 <lambdabot> arr . fromMaybe
17:01:40 <syntaxfree2> Philippa: industry is probably not doing "new languages".
17:02:20 <Philippa> syntaxfree2: there're multiple known cases of it happening with haskell
17:02:44 <syntaxfree2> Philippa: multiple known cases = a handful.
17:02:54 <Philippa> = more than 'not doing'
17:03:13 <Philippa> and bluespec is fairly major
17:03:42 <syntaxfree2> from what I've seen, people either use Matlab or write the more time-critical stuff in C++.
17:04:14 <Philippa> that may be most common...
17:04:27 <Philippa> (actually, these days anything XML outweighs it by a large factor)
17:04:32 <syntaxfree2> there are huge insurance systems built on Excel spreadsheets calling custom Matlab libraries.
17:06:07 <syntaxfree2> Cashflows and suchlike being modeled in Excel and Monte Carlo simulations being done in Matlab, with results reporting back to Excel-as-a-GUI.
17:06:26 <Philippa> sure. That's just one corner, though
17:06:56 <syntaxfree2> I guess. I'm young and have been on the financial side of things for the two years of my career.
17:11:15 <syntaxfree2> our work with Monte Carlo approaches to cashflow valuation is actually somewhat innovative. Not in any theoretical sense, just because "industry" relies on very unstable numbers like IRRs and MIRRs.
17:12:08 <syntaxfree2> we're finishing a valuation project for the would-be olympic village in Rio does get the 2016 olympics.
17:12:13 <syntaxfree2> man I'm way off-topic, sorry.
17:14:33 * syntaxfree blushes
17:30:08 <FunctorSalad_> "Cannot match a monotype with (...)" in a function definition in a let expression... which extension do I need to turn on again?
17:31:06 <hatds> possibly NoMonoPatBinds, but if it's not that I don't know
17:32:56 <FunctorSalad_> here is the evil type ;) http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5911#a5911
17:33:19 <FunctorSalad_> hatds: tried that. I always try that extension when I get such errors, but it never worked yet =)
17:34:25 <ac> I think I've asked this before, but does it work to have cabal packages installed both in ~/.ghc and in /usr/local/lib/ghc..?
17:34:39 <dcoutts> ac: yes
17:36:11 <ac> is there an underlying cause to the error "Could not find module Foo.Bar it is a member of package old-bar which is hidden"?
17:37:09 <dino-> ac: That could be that you need to put old-bar in your build-depends: in the .cabal file of your project.
17:37:41 <ac> trying to cabal install haskelldb-hsql at the moment, and the module is System.Time
17:37:59 <dcoutts> ac: the reason is that cabal hides all packages except for those listed in the package's .cabal file
17:38:07 <ac> I get this problem with a lot of hackage packages, which makes me think I'm doing something wrong
17:38:45 <dcoutts> ac: no, it's that those packages have incorrectly specified dependencies, most likely it's because they've not been updated since ghc-6.6 era
17:39:04 <dcoutts> ac: http://haskell.org/cabal/FAQ.html#hidden-packages-b
17:39:07 <dino-> That one does say build failure for 6.10 and 6.8  oof
17:39:31 <dcoutts> ac: don't bother with hsql, use hdbc
17:39:45 <dcoutts> hsql has been unmaintained for ages
17:40:30 <ac> ahthanks
17:40:31 <dino-> I did have hsql working (not haskelldb-hsql) in recent months. Specifically to get mysql support.
17:40:34 <ac> that's what I'm doing wrong
17:40:34 <dcoutts> oh, actually I tell a lie, there's a 1.7.1 out, so perhaps not completely unmaintained
17:40:56 <dcoutts> haskelldb is certainly not maintained
17:41:05 <dino-> yes
17:41:42 <dcoutts> ac: still, I'd recommend hdbc over hsql these days
17:42:14 <ac> installing it now
17:47:14 <ac> I imagine there is a nice way to define schemas in Haskell code...
18:02:10 * Cale haddocks MonadPrompt
18:03:24 <Gracenotes> Behold: the Monad Proxy!
18:03:33 <Gracenotes> D:
18:06:18 <Cale> I also added RecPromptT...
18:07:18 <Cale> runRecPromptT :: forall p r b m. (r -> b) -> (forall a. p (RecPromptT p m) a -> (a -> b) -> b) -> (forall a. m a -> (a -> b) -> b) -> RecPromptT p m r -> b
18:07:28 <Cale> wheeeeeeee
18:08:25 <FunctorSalad_> obvious, isn't it? ;)
18:08:47 <FunctorSalad_> maybe if I knew what MonadPrompt was in the first place
18:10:46 <ac> hrm, why isn't haskelldb maintained anymore? Isn't the higher level interface nice?
18:12:23 <Cale> FunctorSalad_: I will upload a new version of it in a moment which adds this. :)
18:13:59 <Cale> ac: Is it not?
18:14:41 <ac> Cale: dcoutts was just saying halkelldb is certainly not maintained
18:14:48 <Cale> hmm
18:15:02 <Cale> But there was a new version uploaded in February to hackage at least.
18:16:43 <dino-> The haskelldb-hdbc is, but not the haskelldb-hsql* ones, I think, it looks like
18:18:42 <ac> I see, that makes sense. hsql and hdbc are basically the same thing, right?
18:19:05 <dino-> I think same goal with different implementations.
18:19:22 <dino-> I didn't realize this at first either, that there are haskelldb- things built against both of them up there.
18:19:39 <dino-> But all the hsql has gone feral
18:19:58 <ac> yay, I can still use haskelldb. It looks cool
18:20:32 <dino-> You know, I never did, I just slogged it out with long evil SQL strings. I should have tried it.
18:21:21 <Linuz2009> what's this place?
18:23:41 <Linuz2009> anybody go to yandere channel?
18:24:08 <Alpounet> Linuz2009, http://www.haskell.org/
18:24:30 <Linuz2009> cool
18:32:25 <jaredj_> anyone know how different SGML DTDs and XML DTDs are?
18:33:27 <jaredj_> i'm writing an OFX parser. OFX is an SGML application
18:33:43 <jaredj_> and i want to construct arbitrary OFX documents so i can quickcheck my parser
18:36:42 <hackagebot> MonadPrompt 1.0.0.2 - MonadPrompt, implementation & examples (CaleGibbard)
18:38:02 <Cale> http://cale.yi.org/MonadPrompt/Control-Monad-Prompt.html
18:38:13 <Cale> new haddocks :)
18:40:26 <ac> dino-: what project was this that required slogging out evil SQL strings?
18:41:10 <dino-> ac: At my format job I was getting some hsql involved in a task, with mysql.
18:41:51 <ac> I'm starting a website project :-|
18:41:56 <dino-> jaredj_: Huh, is that very old OFX? I could have sworn it was XML like forever.
18:42:27 <dino-> ac: er s/format/former/
18:43:14 <dino-> ac: We had these nutty 5 table left joins that never made sense to me.
18:43:35 <dino-> I wasn't having fun there.
18:51:21 <roconnor> > 1- 93.56/102.52
18:51:22 <lambdabot>   8.739758095981265e-2
18:51:41 <Cale> oh, whoops, I killed the link that I pasted right after :)
18:53:13 <roconnor> > 1- 93.56/(102.52-5)
18:53:14 <lambdabot>   4.060705496308448e-2
18:54:59 <roconnor> > 1- 93.61/(102.52-5)
18:55:00 <lambdabot>   4.009433962264153e-2
18:55:03 * roconnor sighs
18:55:08 <roconnor> currency conversions ...
18:55:10 <Cale> There we go.
18:55:46 <roconnor> maybe I should just keep my euro account forever
19:07:49 <hackagebot> clock 0.1 - bindings to time.h: clock_gettime and clock_getres (CetinSert)
19:25:25 <Alpounet> if anyone interested, feedback is wanted about our little feed forward neural nets library : http://mestan.fr/haskell/nn/html/
19:25:37 <Alpounet> in particular, there seems to be a problem in backProp, if any wizard in here...
19:46:35 <ryant5000_> Is anyone here who as worked on the Reactive joinE/joinMaybes issue?
19:46:43 <ryant5000_> (or any other Reactive issues)
19:47:22 <ryant5000_> i'm interested in contributing fixes to these issues, but I'd like to know what work people have already put in
19:57:00 <hackagebot> clock 0.1.1 - low-level binding to time.h: clock_gettime and clock_getres (CetinSert)
19:58:57 <Alpounet> http://web.archive.org/web/19971221221216/http://haskell.org/ haha fun
19:58:57 <conal> ryant5000_: Baughn has been looking into joinE
19:59:34 <ryant5000_> conal: ah, cool; perhaps i can get a hold of him
19:59:49 <ryant5000_> conal: i think i'll also send an email to the Reactive mailing list
20:00:08 <conal> ryant5000_: good idea.  i think Baughn is in norway.
20:00:22 <conal> @localtime Baughn
20:00:24 <lambdabot> Local time for Baughn is Tue Jun 16 05:00:22 2009
20:01:03 <ryant5000_> ah, ok
20:05:50 <ryant5000_> how can i go about reducing the size of ghc-produced binaries?
20:06:25 <ryant5000_> is there any way to skim things out of the GHC runtime?
20:06:26 <conal> ryant5000_: i saw something recently about shared libraries and a dramatic reduction in binary size.
20:06:42 <ryant5000_> hm, that could be useful
20:07:13 <conal> ryant5000_: dcoutts would know.  probably also Igloo.
20:07:26 <conal> ryant5000_: both in england
20:07:48 <ryant5000_> conal: ah, yeah; so i guess i'm going to be switching to something of a nocturnal schedule :P
20:07:52 <conal> so probably not awake right now.
20:08:17 <conal> ryant5000_: luckily for you & me, functional programming is finally catching on in the US.  used to be pretty barren over here.
20:08:38 <ryant5000_> yeah, that's true
20:08:46 <ryant5000_> although MIT just switched to python for its intro classes :(
20:08:59 <Alpounet> that's actually why I switched to nocturnal schedule
20:09:01 <Alpounet> :p
20:09:19 <conal> ryant5000_: oh yeah.  i read a note by gerald sussman to that effect.  from scheme to python. :(
20:09:31 <ryant5000_> yeah... :-/
20:09:38 <Alpounet> Python for a FP course ?
20:09:49 <ryant5000_> maybe if they hadn't been using scheme, it wouldn't have been so painful to use FP, lol
20:09:57 <ryant5000_> Alpounet: no, just for entry-level CS courses
20:10:03 <Alpounet> oh ok.
20:13:16 <conal> i had a lot of fun in scheme.  it was my working language for TBAG, which was the immediate predecessor of Fran/FRP.
20:14:25 <ryant5000_> yeah, i dunno, though; i had plenty of experience with Scheme before i experienced my "conversion" to FP, which was effectuated by Haskell
20:14:31 <lament> sussman's post is very reasoned
20:14:36 <lament> (and perhaps seasoned)
20:14:52 <ryant5000_> lament: yeah, that's also true
20:15:13 <conal> ryant5000_: do you mean you programmed Scheme imperatively?
20:15:25 <ryant5000_> no, i mean i programmed it functionally, but hated it
20:15:50 <ryant5000_> of course, i was also young and inexperienced :P
20:16:12 <ryant5000_> but it seems like there are a lot of dumb hurdles that Scheme puts in the way of the young and inexperienced
20:18:07 <ryant5000_> also, i fundamentally disagree with Sussman's "software as incomprehensible" approach
20:18:39 <ryant5000_> i don't disagree with the proposition that software engineering today *does in fact* work that way
20:18:47 <conal> could be a self-fulfilling prophecy.  if one believes it, it becomes true.
20:19:00 <ryant5000_> but i don't think that fact means that it should be *taught* that way
20:19:01 <ryant5000_> exactly
20:19:24 <ryant5000_> if we teach all our students not to understand their own code, it's hard to see how code quality will eventually improve
20:19:38 <inimino> I'm not sure he was holding it up as a shining example of the way things ought to be.
20:19:58 <ryant5000_> inimino: well, then we get into the theory/practice debate in university education
20:20:22 <ryant5000_> should they be preparing students to be effective practitioners or enlightened thinkers?
20:20:38 <inimino> I also don't think he was saying students should not understand their own code
20:21:04 <inimino> well, that's more the debate of university education vs vocational training
20:21:21 <conal> if someone believes theory & practice are at odds, i doubt i'd like their theory or practice.
20:21:51 <ryant5000_> inimino: are you sure he wasn't saying that?  compare: "6.001 had been conceived to teach engineers how to take small parts that they understood entirely and use simple techniques to compose them into larger things that do what you want." with "Nowadays you muck around with incomprehensible or nonexistent man pages for software you don’t know who wrote. You have to do basic science on your libraries to see how they work, trying 
20:22:32 <ryant5000_> that's from http://www.wisdomandwonder.com/link/2110/why-mit-switched-from-scheme-to-python, which is quoting or paraphrasing sussman; maybe i can find a better link
20:22:38 <inimino> ryant5000_: that doesn't sound to me like the writing style of someone who approves of what he describes
20:22:51 <inimino> yeah, there's a better transcription somewhere
20:23:13 <ryant5000_> yeah, sorry; i took it to be a direct quotation at first
20:24:00 <conal> hm.  strikes me that sussman's description also fits Haskell's embracing of IO.
20:24:18 <conal> s/Haskell/the Haskell community/
20:24:38 <inimino> a difference of degree at least
20:25:46 <conal> IO gets a job done expediently, and doesn't have a crisp semantics (understood entirely) in the sense of the functional part of haskell
20:25:52 <ryant5000_> http://blog.snowtide.com/2009/03/24/why-mit-now-uses-python-instead-of-scheme-for-its-undergraduate-cs-program -- perhaps better
20:27:06 <ryant5000_> still just a from-memory transcription, though
20:27:15 <ryant5000_> conal: don't we need some kind of "sin bin" though?
20:27:39 <ryant5000_> otherwise, we'd need a complete semantics of the real world in order to perform arbitrary tasks, no?
20:28:02 <ryant5000_> i suppose you could limit haskell to only interacting with the real world in predefined ways
20:28:17 <conal> ryant5000_: i don't think so.  of course it's nice to have a way out of programming functionally when we don't understand how to think within the paradigm.
20:28:36 <Alpounet> g'night guys
20:28:38 <inimino> like 'interact'? :)
20:29:45 <conal> the idea that we need IO is also a self-fulfilling prophecy.  creative exploration of purely functional I/O & OSs dropped dramatically after it was discovered how to program imperatively in haskell.
20:30:17 <ryant5000_> hm
20:30:38 <ryant5000_> do you think something like FRP could be a complete replacement?
20:30:53 <conal> ryant5000_: yes.  something like FRP.
20:31:13 <ryant5000_> i could imagine hooking up your entire program or OS to a sink that describes exactly what to send to various hardware devices
20:31:29 <ryant5000_> *that acts on a description of what
20:32:31 <conal> ryant5000_: whenever we program imperatively (IO), we can ask: "that doing serves the implementation of what being?"
20:33:07 <ryant5000_> right; imperative/declarative
20:33:19 <ryant5000_> what do you think about exceptions in haskell? i've always seen them as rather ill-fitting
20:33:41 <conal> in haskell or in functional haskell?
20:34:06 <ryant5000_> well, either
20:34:20 <ryant5000_> but particularly in functional, i suppose
20:34:41 <conal> functional haskell doesn't really contain a semantics of exceptions.
20:35:23 <conal> though it does have functional counterparts, particularly Maybe & Either
20:35:36 <ryant5000_> hm; i guess not, if you just consider throw and error to be indistinguishable from bottom
20:35:46 <ryant5000_> i've really grappled with how to represent errors in Haskell, though
20:35:54 <ryant5000_> Maybe and Either don't seem like very good choices
20:36:04 <Cale> The possibility for nontermination is something which I'm usually able to live with. Some people think that we should have another separation there.
20:36:17 <Cale> Maybe and Either are good choices.
20:36:28 <conal> good & bad both
20:36:37 <ryant5000_> Maybe and Either have a lot of syntactic overhead
20:36:46 <jmcarthur> they are monads
20:36:49 <Cale> Well...
20:36:53 <qwr> they annotate errors with type
20:37:03 <ryant5000_> right, but what about when i want an error-prone function that *isn't* monadic?
20:37:16 <jmcarthur> then don't use it like a monad ;)
20:37:47 <ryant5000_> jmcarthur: how do you mean? with >>= and such?
20:38:01 <ryant5000_> oh, you mean just use Either and Maybe alone
20:38:08 <Cale> > let dict = [(0,1),(1,2),(2,3)] in do x <- lookup 0 dict; y <- lookup x dict; return y
20:38:11 <lambdabot>   Just 2
20:38:27 <Cale> > let dict = [(0,1),(1,2),(2,3)] in do x <- lookup 0 dict; y <- lookup x dict; z <- lookup y dict; return z
20:38:29 <lambdabot>   Just 3
20:38:37 <jmcarthur> ryant5000_: the point is, if you don't want to type to be annotated, then you aren't really looking for safe error handling
20:38:41 <Cale> > let dict = [(0,1),(1,2),(2,3)] in do x <- lookup 0 dict; y <- lookup x dict; z <- lookup y dict; w <- lookup z dict; return w
20:38:43 <lambdabot>   Nothing
20:38:50 <jmcarthur> not with haskell's type system, anyway
20:39:05 <ryant5000_> jmcarthur: i want the type annotated, i just don't want to do a bunch of pattern matching, and i don't want to thread a monad through everything
20:39:22 <Cale> ryant5000_: "thread a monad through"?
20:39:28 <Cale> ryant5000_: You mean the Maybe monad?
20:39:31 <jmcarthur> eh, monads aren't that hard to "thread around" once you're used to it
20:39:33 <ryant5000_> Cale: yeah
20:39:38 <jmcarthur> that's what they are for, after all
20:39:43 <Cale> ryant5000_: You only use the Maybe monad if it's convenient.
20:39:48 <conal> ryant5000_: the Monad interface is often overkill.  Applicative is a little gentler.
20:39:57 <ryant5000_> jmcarthur: i know
20:40:04 <Cale> ryant5000_: It's really just some syntax around a common operation on Maybes
20:40:14 <conal> ryant5000_: Applicative helps a bit but doesn't address your basic grip.
20:40:15 <Cale> It's not magic.
20:40:30 <ryant5000_> ok, so suppose i have a Num b => Map a b,
20:40:37 <jmcarthur> ryant5000_: you just don't like combinators, i suppose?
20:40:52 <ryant5000_> jmcarthur: i don't like syntactic overhead, however conceived
20:40:57 <ryant5000_> and i want to add the results of two lookups
20:41:14 <ryant5000_> now, if i had Num b => (a -> b), it would be very clean
20:41:30 <ryant5000_> but with partial maps, i need to handle the not-present case
20:41:39 <jmcarthur> ryant5000_: that would actually be a valid instance for Num if Num didn't have some extra crap
20:41:47 <Cale> liftM2 (+) (M.lookup x myMap) (M.lookup y myMap)
20:42:03 <conal> we've chosen to wire _|_ into the meanings of all (most) types.  we could do the same with errors (as distinct from _|_) if we wanted to.  we just don't want to.
20:42:19 <conal> errors complicate things.  so does _|_.
20:42:43 <ryant5000_> yeah, i'm certainly not proposing lifting every type over all the possible errors
20:43:13 <ryant5000_> i'd just like a non-invasive way of transforming (a -> b) -> b into (Map a b) -> Maybe b
20:43:46 <ryant5000_> Cale: that is certainly a cleaner transformation than i was imagining, but does that scale? can i do something with O(1) code changes for any arbitrary function?
20:43:53 <Cale> ryant5000_: I suppose the thing is that how to deal with the failure is not encoded by values of the first type there.
20:43:56 <conal> ryant5000_: i meant my remarks as encouragement to you to imagine possibilities other than what haskell gives you.  the choices we've made have value but aren't inevitable.
20:44:14 <Cale> ryant5000_: And there really is more than one way to do it.
20:44:15 <jmcarthur> ryant5000_: most lifting functions can be used that cleanly, really
20:44:45 <ryant5000_> Cale: well, does (a -> b) *have* any failure cases?
20:44:47 <conal> horray Applicative!  (s/liftM2/liftA2)
20:44:53 <Cale> ryant5000_: apart from _|_, no
20:44:56 <jmcarthur> another way to write it: (+) <$> lookup x myMap <*> lookup y myMap
20:45:06 <ryant5000_> Cale: it seems like representing "can't fail at all" is a pretty useful thing to do
20:45:19 <Cale> ryant5000_: right.
20:45:35 <jmcarthur> ryant5000_: that would be total programming, which is what i would love to see more of
20:45:41 <aavogt> @type (/0)
20:45:42 <lambdabot> forall a. (Fractional a) => a -> a
20:45:48 <ryant5000_> jmcarthur: yeah, that would be cool :)
20:45:52 <Cale> ryant5000_: But the thing is that because we have that, it becomes extra work suddenly when we do have failure, rather than being something that we're encoding all the time.
20:46:11 <scutigera> showEFloat (Just 6) x appears to be slow and inefficient in the extreme.  is it true, or is it just me ?
20:46:13 <jmcarthur> Cale: no different than our current situation with Maybe and Either
20:46:21 <Cale> I think it's a little similar to the situation with map and mapM
20:46:32 <ryant5000_> Cale: well, that makes sense, but it doesn't have to be *so much* work - at least it's not obvious to me why it does need to be
20:46:48 <Cale> Some people have thought it would be nice if you could take map and get mapM for free, since it's really not that hard a transformation to make by hand.
20:46:50 <Cale> But!
20:46:57 <jmcarthur> Cale: you can use cmap in category-extras to generalize map and mapM :)
20:47:02 <Cale> mapM has more information in it
20:47:14 <Cale> In that it encodes the order in which effects occur.
20:47:19 <ryant5000_> in particular, i don't see any particular reason why you can't write a function ((a->b) -> c) -> ((Map a b) -> Maybe c)
20:47:19 <jmcarthur> Cale: i've done it. requires a newtype though :(
20:47:28 <Cale> jmcarthur: as it should...
20:47:42 <ryant5000_> Cale: yeah, that's true about mapM; i can see how that would need to be applied in every case
20:48:02 <Cale> > mapM (\x -> [x,x+1]) [1,2,3]
20:48:03 <jmcarthur> ryant5000_: right, you _can_ write that function
20:48:04 <lambdabot>   [[1,2,3],[1,2,4],[1,3,3],[1,3,4],[2,2,3],[2,2,4],[2,3,3],[2,3,4]]
20:48:06 <Cale> > map (\x -> [x,x+1]) [1,2,3]
20:48:08 <lambdabot>   [[1,2],[2,3],[3,4]]
20:48:11 <ryant5000_> jmcarthur: oh, really?
20:48:16 <Cale> Indistinguishable by type ;)
20:48:17 <jmcarthur> wait, lemme check myself
20:48:26 <jmcarthur> i misread it the first time
20:48:43 <ryant5000_> ah, that's too bad :(
20:48:51 <Cale> Of course, you can get map from mapM, that's uncontroversial
20:49:01 <Cale> But the other way around is what's impossible.
20:49:14 <Cale> (and of course you can get both from something even more general)
20:49:24 <jmcarthur> Discipline can do it, but that's because the type for map is more general than it appears
20:49:26 <ryant5000_> Cale: right, because someone could write mapMPermute, which runs the monad in a bizarre order
20:49:37 <Cale> Disciple does it by forcing you to encode order *all the time*
20:49:41 <jmcarthur> right
20:49:43 <ryant5000_> Cale: the fact that there's one "obvious" order doesn't make it the only order
20:49:49 <Cale> yeah
20:49:58 <jmcarthur> disciple, heh, right, not discipline :P
20:50:21 <Cale> So, transformations/refactorings on higher order functions which are valid in Haskell become invalid in Disciple
20:50:49 <ryant5000_> Cale: i don't see how, though, my ((a->b)->c) -> Map a b -> Maybe c combinator has the same issue
20:50:51 <Cale> (and other functions)
20:51:10 <ryant5000_> i don't see how it adds data
20:51:41 <Cale> Well, it is certainly more subtle.
20:51:50 <ryant5000_> it certainly forces a bunch of computation to determine whether the Maybe is Just or Nothing
20:52:14 <Cale> If we had first class continuations in Haskell, you could do it trivially.
20:52:29 <ryant5000_> right, a lot of lispy stuff was occurring to me when i was thinking about it
20:52:47 <jmcarthur> what do you mean "first class" continuations?
20:52:52 <jmcarthur> i'm not very lispy
20:53:04 <scutigera> why isn't their first class continuations in Haskell ?? I was surprised when I saw there wasn't - seems like a natural.
20:53:07 <Cale> jmcarthur: I mean callCC outside of a monad.
20:53:28 <Cale> :t callCC
20:53:30 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
20:53:31 <ryant5000_> is there a (theoretical) reason we don't have taht?
20:53:37 <Cale> ((a -> b) -> a) -> a
20:53:39 <soupdragon> ryant5000: yes
20:53:40 <jmcarthur> what sort of type extension would be necessary to do that?
20:53:51 <Cale> It really messes up referential transparency about as hard as you can.
20:54:04 <jmcarthur> ah, no reasonable type extension
20:54:06 <Cale> Like, you can encode arbitrary effects, more or less.
20:54:19 <ryant5000_> Cale: ah, well, that's good enough to convince me that we shouldn't have it :P
20:54:44 <ryant5000_> but is it the only conceivable way to do the Map thing i was talking about?
20:54:47 <jmcarthur> :t runCont
20:54:49 <lambdabot> forall r a. Cont r a -> (a -> r) -> r
20:55:16 <monochrom> "first-class" means the language has a construct to let you obtain one, then pass it around, store it or bind it to a variable, and "use" it.
20:56:15 <scutigera> a la scheme
21:00:22 <ryant5000_> maybe there's a way, a la ST, to create 'bounded' first-class continuations that allow the construction of (only) referentially-transparent functions, but with non-referentially-transparent implementations?
21:00:45 <soupdragon> ryant5000: I think it's cont monad
21:00:52 <Cale> It would look something like convert f m = callCC $ \k -> Just (f (\key -> findWithDefault (k Nothing) key m))
21:01:08 <Cale> However, evaluation order really screws with this
21:01:44 <ryant5000_> Cale: yeah, you'd have to make the (k Nothing) really be a thunk reachable from the result thunk
21:02:33 <ryant5000_> soupdragon: i think that would require altering the original function; (for the record, my goal is to write a function with type ((a -> b) -> c) -> Map a b -> Maybe c, with the obvious semantics)
21:03:03 <soupdragon> I was answering:  <ryant5000_> maybe there's a way, a la ST, to create 'bounded' first-class continuations that allow the construction of (only) referentially-transparent functions, but with non-referentially-transparent implementations?
21:03:09 <Cale> ryant5000_: The trouble is, the function you pass in has no notion of what it means for that (a -> b) function to not produce a result of type b
21:03:35 <ryant5000_> soupdragon: right, but the Cont monad doesn't do what i want, nor does it require any fancy magic the way ST does
21:03:37 <Cale> ryant5000_: and you don't know, a-priori, which values of type a it might try to look at
21:03:49 <ryant5000_> soupdragon: my statement wasn't very clear, but i was trying to get at the "encapsulated magic" thing
21:05:08 <Cale> The only way to know for which values a function of type (a -> b) -> c calls its parameter function on is to actually apply it and see, unfortunately.
21:05:08 <ryant5000_> Cale: yeah, that makes sense; but couldn't it basically mean "if forcing the result requires forcing the result of that function with an "illegal" argument, then the overall result is Nothing"?
21:05:21 <ryant5000_> yeah, that's what i was interested in doing :)
21:05:30 <Cale> and in fact, some of those might be deferred indefinitely
21:05:55 <jmcarthur> @djinn ((a -> b) -> c) -> (a -> Maybe b) -> Maybe c
21:05:55 <lambdabot> f _ _ = Nothing
21:05:55 <Cale> That is, the function might return a constructor immediately, which contains as one of its parameters an expression which contains a call to f
21:06:04 <Cale> which... is really hard to deal with
21:06:05 <jmcarthur> dangit djinn
21:06:21 <jmcarthur> well, there's your function :)
21:06:23 <ryant5000_> Cale: oooh, i see
21:06:39 <dmwit> jmcarthur: That doesn't look like an implementable type.
21:06:46 <jmcarthur> dmwit: exactly
21:06:51 <ryant5000_> Cale: i can see how that might be arbitrarily difficult to determine
21:07:02 <dmwit> (Other than the boring implementation given above, of course.)
21:07:03 <jmcarthur> that's what you would need to implement ryant5000_'s function
21:07:12 <dmwit> Oh, I haven't been paying attention.
21:07:18 * dmwit reads back
21:07:19 <ryant5000_> Cale: so there really *is* some reason to impose an order of execution on it
21:07:45 <ryant5000_> dmwit: i wanted a syntactically-cheap way of adding error handling to an error-oblivious function
21:07:52 <Cale> ryant5000_: Yeah. You need to know up front if things are going to fail, so that you can decide if you've failed or not.
21:08:07 <jmcarthur> dmwit: he was after ((a -> b) -> c) -> Map a b -> Maybe c
21:08:22 <ryant5000_> Cale: right; that makes sense
21:08:39 <ryant5000_> Cale: obviously that'll require some kind of invasion into the source of the original function
21:09:00 <jmcarthur> i yelled at djinn just because i was hoping it would give an error instead of giving a trivial implementation ;)
21:09:21 <dmwit> jmcarthur: Would ((a -> b) -> c) -> Map a b -> (a -> Maybe c) suffice...?
21:09:31 <dmwit> Or I should maybe ask ryant5000_.
21:09:37 <dmwit> Since that function is much easier to write.
21:09:54 <jmcarthur> that isn't really the same thing, i think
21:10:00 <dmwit> No, it's not.
21:10:07 <ryant5000_> dmwit: i'm not sure what that would do
21:10:29 <ryant5000_> dmwit: Cale's satisfied me that what i want is impossible, though :P
21:10:36 * dmwit nods
21:10:51 <Cale> (at least, without imposing a particular evaluation order on everything)
21:10:58 <ryant5000_> though i still wonder if there's some less-general way of doing it
21:11:40 <jmcarthur> ((a -> Maybe b) -> c) -> Map a b -> Maybe c    would work fine, of course
21:11:48 <dmwit> If there's a sensible default value of type 'b', then ((a -> b) -> c) -> Map a b -> c -- seems plausible
21:11:49 <ryant5000_> jmcarthur: yeah, of course
21:12:11 <ryant5000_> yeah; those all make sense
21:12:22 <jmcarthur> MonadZero b, or something
21:12:23 <ryant5000_> i was just interested in getting free error handling :P
21:12:27 <jmcarthur> or Monoid?
21:12:28 <dmwit> errorfy f m = f (\a -> fromMaybe default_ (lookup a m))
21:12:33 <jmcarthur> something with a default value
21:12:37 <ryant5000_> Cale: maybe if we add an NFData constraint, it becomes possible :P
21:12:38 <dmwit> exactly
21:12:56 <jmcarthur> not MonadZero b, that was stupid
21:14:08 <jmcarthur> but i think the point is that the 'b' must carry the information for failure, whatever it is
21:14:53 <ryant5000_> jmcarthur: yeah, and that data must be gathered up before a value is returned
21:15:09 <Cale> yeah, you could explicitly request that there be a way to turn continuations into values of type b, but that would again be ridiculous ;)
21:15:46 <ryant5000_> Cale: yeah :P
21:16:00 <jmcarthur> now, one could just use _|_ and be done with it ;)
21:16:06 <ryant5000_> actually, if we returned throwDyn (SomeTypeNobodyElseUses) for missing values
21:16:14 <ryant5000_> and then called rnf on the result
21:16:34 <ryant5000_> and caught SomeTypeNobodyElseUses, returning Nothing
21:16:35 <Cale> Oh, you could unsafePerformIO and catch ;)
21:16:55 <jmcarthur> that hurts my heart
21:16:56 <ryant5000_> right! :P
21:17:13 <ryant5000_> well, i'm interested only in whether the *idea* is pure, not the implementation, lol
21:17:25 <ryant5000_> and i think with RNF it is, although there are still some weirdnesses
21:17:39 * BMeph mutters something about "unsafePerformArcaneChickenSacrificeRitual"...
21:17:58 <Cale> Well, you really only need local continuations.
21:18:12 <Cale> But you need the strict evaluation, or it doesn't work
21:18:17 <ryant5000_> e.g.: (f x) is different from (f x) + (f y) * 0, if y doesn't exist
21:18:18 <ryant5000_> yeah
21:18:52 <ryant5000_> and that means that we're now able to observe previously-unobservable differences between the input function
21:19:00 <monochrom> unsafePlugAndPray
21:19:05 <ryant5000_> haha
21:19:14 <ryant5000_> @localtime Beelsebob1
21:19:18 <Cale> ryant5000_: good point there too
21:19:36 <ryant5000_> (am i misusing localtime?)
21:19:50 <Cale> @localtime Cale
21:19:52 <lambdabot> Local time for Cale is Tue Jun 16 00:19:51
21:20:03 <Cale> Maybe he just doesn't respond to CTCP TIMEs
21:20:27 <ryant5000_> fair enough
21:21:50 <ryant5000_> is there anything else reasonable that can be done to lessen the invasiveness of error handling in Haskell?
21:22:28 <ryant5000_> i suppose the strictness issue with my Map example is more or less insurmountable
21:22:50 <ryant5000_> but perhaps source-level (TH) stuff could be useful?
21:23:13 <Cale> hmm
21:23:16 <jmcarthur> i think the invasiveness is a good thing, honestly. if not for that, our code would just be silent about such things
21:23:17 <Cale> Perhaps
21:23:45 <jmcarthur> silence is uncertainty, and hard to reason about
21:23:45 <Cale> Yeah, there's an extent to which saying "*hey* this can fail!" is a good thing :)
21:23:56 <ryant5000_> jmcarthur: well, i think that invasiveness is necessary *sometimes*; and *some* invasiveness is important
21:24:10 <ryant5000_> e.g.: i don't think C++'s "anything can throw anything" approach is really awesome
21:24:46 <ryant5000_> but there *is* a serious issue about when you write a bunch of code, and then figure out that your inner-most function actually has an error mode
21:24:56 <ryant5000_> you don't necessarily want to have to refactor everything that calls it
21:25:02 <ryant5000_> (though, again, it might be unavoidable)
21:25:07 <inimino> (ahem, Java)
21:25:11 <ryant5000_> inimino: yeah :P
21:25:30 <jmcarthur> ryant5000_: if you did that, then the inner function wasn't exposing the error properly in the first place
21:25:32 <ryant5000_> basically, what i'm saying is this: I want to reduce the computational complexity of the algorithm that runs in the programmer's brain
21:25:59 <ryant5000_> jmcarthur: that's certainly true
21:26:08 <monochrom> "then figure out it has an error mode" sounds like a fatal oversight. why cover up rather than tear down and re-design.
21:26:31 <jmcarthur> and if you write a whole bunch of outer code before ever calling that inner function, presumably you end up with a foo :: a -> b and have a bar :: Maybe a, so it's just a simple matter of foo <$> bar, anyway
21:26:41 <ryant5000_> well, i'd like it if there were a good way of making the teardown/redesign as easy as possible
21:27:09 <ryant5000_> jmcarthur: yeah, i suppose if it's just using a bunch of Applicative stuff, that's not really so bad
21:27:20 <jmcarthur> why tear down and redesign at all?
21:27:29 <jmcarthur> if you wrote the majority of the code as is, you're usually done
21:27:44 <jmcarthur> that's the beauty of the approach we have
21:27:48 <ryant5000_> jmcarthur: i was responding to monochrom
21:27:52 <jmcarthur> ah
21:28:00 <monochrom> I know there is a good way of making the teardown very easy. rm *.
21:28:04 <ryant5000_> haha
21:28:06 <ryant5000_> perfect :P
21:28:42 <monochrom> And I know there is a good way of making the redesign very easy. Write programs with proofs of correctness in mind.
21:28:48 <inimino> nothing under 1000 LOC is worth saving
21:28:49 <ryant5000_> jmcarthur: i think once i get a lot more skilled with Applicative, these issues may resolve themselves
21:29:09 <monochrom> Use either Bird's method or Agda's method.
21:29:46 <ryant5000_> monochrom: are those languages?
21:29:53 <monochrom> No. Methods.
21:30:13 <monochrom> Bird is a person and his book describes one method.
21:30:26 <ryant5000_> ah
21:30:32 <monochrom> Agda is a language but it also suggests a method, and you can adopt that method without that language.
21:31:48 <jmcarthur> inimino: nothing _over_ 1000 LOC is worth saving, you mean ;)
21:31:57 <monochrom> If you can also see through imperative programming (rather than religiously loathe it like most people here do) and see that the mutable-state fraction of it is really functional programming again, you can adopt imperative programming methods too, such as preconditions and posconditions.
21:32:16 <BMeph> Nothing over 1000 LOC is worth using. ;p
21:33:21 <jmcarthur> quite so. imperative programming is really just a particular subset of functional programming, and it can be seen the other way too
21:33:40 <Pseudonym> It's a corollary of them having equivalent power.
21:35:43 <jmcarthur> i think a lot of the problem with combinators is a lot of new haskell programmers try to understand what they do rather than what they represent
21:36:06 <jmcarthur> it's hard, coming from an imperative language, to only look at a type and a name
21:36:37 <jmcarthur> (a -> b) -> f a -> f b... sure, great, but what does it _do_???
21:37:02 <jmcarthur> and yet the whole point is that we don't care most of the time
21:37:19 <jmcarthur> provided that certain laws are followed, of course
21:37:33 <monochrom> (That is not what I saw. I saw in the imperative world, people look at the man page, it has just the name, the type, and a lousy summary.)
21:38:18 <monochrom> (lousy summary means it is a 500-word essay expounding on the name)
21:38:54 <jmcarthur> man pages are for utilities that aren't really polymorphic in the same sense as most haskell combinators
21:39:22 <monochrom> (simplified example, probably distorted but you get my idea: "void sync(void). This function syncs." )
21:39:56 <jmcarthur> things like that are *exactly* why imperative programmers insist on looking at implementation :P
21:40:36 <monochrom> They are control freaks to begin with.
21:40:40 <jmcarthur> it's hard to adjust to a world where you can trust most of the documentation
21:41:14 <monochrom> Like why should it matter what control flow order you're using. Let the computer figure out a good order already.
21:41:35 <jmcarthur> "but... what's HAPPENING?"
21:42:00 <monochrom> Exactly. A control freak's perpetual question and purpose of existence.
21:43:14 <monochrom> This is why callbacks, "inversion of control", dynamic dispatch... are such big deals to them, i.e., they need more blog posts on such big deals than we need blog posts on monads.
21:44:01 <Pseudonym> We have blog posts on re-introducing mutable state, though.
21:44:56 <Pseudonym> Or on re-implementing existing C libraries in Haskell.
21:46:24 <jmcarthur> usually just to prove to the skeptics that it can be done, from what i've seen
21:47:16 <jmcarthur> sometimes it is revolutionary, but then it's usually due to a discovery in type safety and imperative programming, not due to suddenly being able to do imperative programming in a functional language
21:49:04 <BMeph> monochrom: But, what's it doing to the stack frames? ;p
22:05:35 <fumbles> so i'm trying to install dtwitzen right...
22:05:59 <fumbles> did runhaskell Setup.lhs configure --user --prefix=$HOME
22:06:21 <fumbles> and i get a warning...no 'build-type' specified
22:12:23 <dmwit> fumbles: neat!
22:12:36 <dmwit> fumbles: That sounds like an error in the .cabal file.
22:12:36 <fumbles> um..it failed :(
22:12:45 <dmwit> fumbles: Check if the .cabal file has a build-type: line in it.
22:12:57 <dmwit> If not, you can maybe figure out what it ought to be from cabal's documentation.
22:13:17 <fumbles>  Buildable:False Build-Depends:	base, filepath, directory, unix, process,
22:13:29 <fumbles> those bastards...failed this .cabal file..
22:14:19 <fumbles> shouldn't buildable be True...
22:15:00 <dmwit> Maybe not!
22:15:21 <dmwit> But you should maybe wait around for somebody more knowledgeable about cabal than I.
22:15:34 <dmwit> You might also like to try to contact the author, who should know more.
22:15:38 <dmwit> ?seen dcoutts
22:15:38 <lambdabot> dcoutts is in #darcs, #gentoo-haskell, #ghc, #haskell, #haskell-in-depth, #haskell-overflow and #haskell-soc. I last heard dcoutts speak 4h 33m 56s ago.
22:15:50 <dmwit> (That's the author of most of Cabal.)
22:15:59 <dmwit> err... I think
22:16:07 <fumbles> ahh ic
22:16:16 <fumbles> Kohei Ozaki
22:16:20 <fumbles> author^
22:16:35 <fumbles> @stats
22:16:35 <lambdabot> Unknown command, try @list
22:16:41 <fumbles> @irc
22:16:41 <lambdabot> Not enough privileges
22:16:43 <dmwit> I've never heard the name, so I can't tell you a nick here, unfortunately.
22:16:50 <fumbles> @list
22:16:50 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
22:17:37 <fumbles> I'll just idle in here :)
22:17:42 <fumbles> dmwit: thank you
23:18:00 <ryant5000> how would I go about starting a mailing list on haskell.org?
23:36:24 <dirk_> what does the operator !! mean?
23:37:20 <mauke> @src (!!)
23:37:21 <lambdabot> xs     !! n | n < 0 = undefined
23:37:21 <lambdabot> []     !! _         = undefined
23:37:21 <lambdabot> (x:_)  !! 0         = x
23:37:21 <lambdabot> (_:xs) !! n         = xs !! (n-1)
23:37:28 <dirk_> ok
23:37:40 <mauke> > "abcde" !! 2
23:37:42 <lambdabot>   'c'
23:37:44 <dirk_> ok
23:37:54 <dirk_> so it is selection by index
23:38:14 <dirk_> yes it is
23:38:20 <dmwit> right
23:39:28 <blueflute> @src (*)
23:39:28 <lambdabot> Source not found. You type like i drive.
23:39:40 <Nafai> So apparently !! is an O(n) operation
23:39:56 <dmwit> yes
23:40:08 <dmwit> blueflute: It's a class function; it's implemented differently for each instance.
23:40:16 <mauke> the way lists are constructed it can't be faster
23:40:19 <dmwit> blueflute: For the most common instances, it's a built-in.
23:41:27 <dirk_> so is is not good to represent the identity matrix by [[1,0],[0,1]] an calculate based on that
23:41:30 <Nafai> Is there a data structure for which the equivalent operation is O(1)?
23:41:34 <blueflute> dmwit, okay. I'm new to haskell. Just started yesterday. Was just curious as to what the bot would say to that...
23:41:44 <mauke> Nafai: arrays
23:42:07 <mauke> see also Data.Sequence
23:43:20 <dmwit> dirk_: It's doable.  But there are better ways.
23:43:30 <dmwit> dirk_: I think there's even a matrix library or two on Hackage.
23:43:35 <dirk_> ok
23:46:24 <uzytkownik> Hello. Does anyone have an idea how to simplify it: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5913#a5913 ?
23:48:22 <dmwit> Looks like a MaybeT of some kind to me.
23:48:30 <dmwit> not totally sure, though
23:48:46 <dmwit> oh
23:48:49 <fumbles> anybody good at cabal?
23:48:49 <dmwit> more like an EitherT
23:49:39 <dmwit> :t flip maybe Just
23:49:40 <lambdabot> forall a. Maybe a -> Maybe a -> Maybe a
23:50:05 <dmwit> :t mplus
23:50:06 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
23:50:13 <dmwit> :t mplus :: Maybe a -> Maybe a -> Maybe a
23:50:14 <lambdabot> forall a. Maybe a -> Maybe a -> Maybe a
23:50:33 <dmwit> maybe v Just m = m `mplus` v
23:50:45 <dirk_> to me it looks a bit like the Maybe Monad, but I don't know how to incorporate different error messages
23:51:47 <dmwit> dirk_: Right, that's why I suggested using the Either monad (transformer), which can incorporate error messages.
23:53:30 <dmwit> Then those just become a sequence of actions like (do { g <- currentGroup s; n'' <- currentArticleNo s n'; a' <- eLookup blah blah; return (f a n) }
23:53:35 <dmwit> )
23:53:50 <Reiv> Urk.
23:53:57 <Reiv> Is there any way to infer or automatically set the indentation for a Haskell program?
23:54:28 * Reiv was doing coursework, and got the next chunk of sample code - and it was given in a pdf format that doesn't preserve indentation when you copy+paste to a text editor. >.<
23:55:07 <solidsnack> Does GHC have a way to unconditionally kill a thread?
23:56:12 <dmwit> Reiv: Nope, that would involve (in general) Knowing What You Mean. =)
23:56:14 <Jedai> Reiv: nope, but you can always use something like haskell-mode for emacs that will make much easier the reindentation
23:56:16 <solidsnack> Reiv: Since identation has semantic significance, you can't strip it out and expect the semantics to be recovered.
23:56:37 <dmwit> solidsnack: killThread?
23:56:53 <Reiv> Urk. I see.
23:56:57 * Reiv ponders doing this by hand, winces.
23:57:14 <solidsnack> dmwit: It's not unconditional.
23:57:23 <dmwit> Reiv: Surely the sample code is also provided separately.
23:57:28 <dmwit> Any sane assignment would do so.
23:57:29 <solidsnack> Like if it's in foreign code, the thread lives.
23:57:38 <dmwit> solidsnack: Oh, you want to kill an OS thread?
23:58:03 <solidsnack> I see your point.
23:58:27 <sjanssen> solidsnack: it doesn't really make sense to kill a thread in FFI
23:58:46 <solidsnack> sjanssen: I'm interested in it for SLAs, actually.
23:58:51 <solidsnack> Take this long or die.
23:59:30 <solidsnack> In that situation, I expect foreign calls to be terminated (and I expect to deal with the consequences).
