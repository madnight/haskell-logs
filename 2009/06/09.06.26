00:00:07 <ToRA> qq, anyone know in general if it's better in general to make lots of calls to putStrLn with small Strings, or to make one big string and pass that to putStrLn?  (I have a Seq String and want to print it one string per line)
00:00:08 <kniu> turns out that I added so much syntax, the entire thing's 50 lines long.
00:00:30 <kniu> ToRA, one big string.
00:00:46 <dmwit> ToRA: It probably doesn't matter much.
00:00:55 <kniu> calling putStrLn lots of times just looks like boilerplate.
00:00:57 <dmwit> ToRA: If that turns out to be a bottleneck, you'll want to switch over to ByteString anyway.
00:01:10 <kniu> oh, for performance?
00:01:17 <kniu> nvm then.
00:01:22 <dmwit> kniu: Why?  How is mapM_ putStrLn any more boilerplate than putStr . unlines?
00:01:39 <kniu> I thought he was manually writing those out.
00:01:50 <ToRA> no, I'm deciding between dmwit's two options
00:01:54 <kniu> k.
00:01:59 <ToRA> though the latter needs a . toList at the end
00:02:16 <dmwit> ToRA: Choose whichever suits you better and revisit it when it becomes an issue.
00:02:59 <ToRA> dmwit: nod
00:05:59 <shu> i can't get cabal on windows to read ghc-pkg dump --global
00:06:07 <shu> it only shows that ghc is installed, nothing else (like ghc-prim, etc)
01:26:50 <Cale> 'Twas ICFP Contest Eve and all through the channel, not a creature was stirring, not even O'Caml.
01:27:34 <twb> I don't even have the energy to write a response to that
01:32:11 <dmead> it's tomorrow?
01:32:19 <dmead> :o
01:32:22 <dmead> yippie
01:47:19 <dmead> fold and map make me feel like a god
01:47:27 <dmead> just thought you guys should know that
01:48:28 <Cale> :)
01:50:53 <Saizan_> the contest started?
01:51:28 <ToRA> Cale: eve? the contest starts tonight... ;)
01:51:48 <Saizan_> this evening :P
01:52:18 <Cale> Well, if it's bedtime for you now, then when you wake up, it will be starting :)
01:55:27 <osfameron> "tonight" in which timezone ?
01:55:53 <ivanm> osfameron: 1300 at -5
01:55:55 <ivanm> IIRC
01:56:01 <ivanm> well, 13:00:16
01:56:36 <osfameron> ah, so actually tonight in UTC+0
01:57:00 <osfameron> I was kinda assuming it would follow the timezone of the host city, but wanted to double check :-)
01:57:14 <osfameron> though most likely I'll look at the problem description, panic, and give up, as per usual
01:59:36 <dibblego> @type ifM
01:59:38 <lambdabot> Not in scope: `ifM'
02:00:53 <ivanm> osfameron: well, it'll be 4 AM for me :s
02:01:04 <ivanm> so I won't be looking at the description for a while :s
02:01:22 <osfameron> you're not going to wake up early especially?!
02:01:23 <osfameron> ;-P
02:01:26 * da-x wonders why 'm (a, w)' in WriterT { runWriterT :: m (a, w) } and not '(m a, w)'
02:01:26 <ivanm> nope
02:02:02 <ivanm> osfameron: I'm a bit under the weather atm, partially at least due to my _lack_ of sleep over the past couple of weeks :s
02:02:32 <Axman6> plus he has swine flu
02:02:48 <ivanm> nope
02:03:02 <Axman6> i forgot to tell you, sorry :(
02:03:19 <ivanm> oh...
02:03:24 <ivanm> how did you give it to me?
02:05:27 <ToRA> da-x: if it was ((m a), w) then nothing in the w log could depend on the execution of the inner monad, which wouldn't be very useful
02:05:54 <quicksilver> ToRA: good way of answering it. I was trying to put that into words and failed ;)
02:06:16 <doserj> well, it could be useful, but it would simply be Writer w (m a)
02:24:43 <ivanm> Cale: looks like gobby is building! \o/
02:24:53 <Cale> excellent
02:25:32 <ivanm> noooo!!! I got net6 patched, and now obby won't work! :s
02:26:15 <ivanm> @slap non-haskell software
02:26:16 * lambdabot is overcome by a sudden desire to hurt non-haskell software
02:26:52 <ivanm> yay, another patch :s
02:29:32 <bastl> hi i want to define a product of type constructors: data (f :x: g) t = ... but ghc doesnt parse ":x:". I have number of language pragmas, but it doesnt work. Any hints?
02:29:58 <ivanm> the anti-for campagin: http://weblogs.asp.net/podwysocki/archive/2009/06/26/the-anti-for-campaign.aspx
02:30:06 <bastl> (im trying to reproduce sec.2 of the multirec paper)
02:30:10 <Cale> bastl: x is not a symbol character and so cannot occur in an infix operator
02:30:12 <ivanm> bastl: what are you wanting to do there sorry?
02:30:18 <Cale> bastl: try :*:
02:30:47 <bastl> Cale: http://hackage.haskell.org/packages/archive/multirec/0.4/doc/html/src/Generics-MultiRec-Base.html
02:31:17 <ivanm> bastl: no :x: there...
02:31:24 <bastl> oh, right :-)
02:31:41 <bastl> thanks
02:32:36 <bastl> and guess what: vim's syntax highlighting didnt recognize :+:, but recognizes :*:  :-) )
02:32:48 <ivanm> heh
02:34:21 <Cale> odd
02:35:13 <ivanm> Cale: yay, it built! \o/
02:35:21 <Cale> :)
02:38:10 <ivanm> yay, it has haskell support! \o/
02:38:45 <Cale> cale.yi.org 46464
02:39:01 <naren> hello?
02:39:10 <Cale> hello
02:43:34 <Cale> naren: New here?
02:43:55 <naren> yea, I am trying to think how to frame this question i want to ask
02:44:10 <Cale> ah, no problem :)
02:44:58 <EvilTerran> ?hpaste
02:44:58 <lambdabot> Haskell pastebin: http://hpaste.org/new
02:45:21 <EvilTerran> naren, if it'd help to give us a code snippet or error message, you can paste it in there and give us the link
02:46:48 <naren> well, the problem is I have a simple machine learning program. And the idea is you train it with a list of training data and then you can use it to classify new input. But, each time I want to classify an input it evaluates the monad representing the learned machine. Which is too slow. I want to make it so that the trained monad is only evaluated once.
02:47:58 <naren> I have no idea how I can do that.
02:48:11 <Saizan_> that's quite weird behavior actually
02:48:27 <Cale> Well...
02:48:29 <Saizan_> how did you organize your code? can you paste some snippets?
02:48:43 <naren> i can paste the whole thing if you wish
02:48:47 <Cale> Results of functions are not automatically cached, but constants are.
02:49:16 <naren> the interface I have has two functions train and classify. Train retuns the monad and classify runs evalState
02:49:21 <ivanm> maybe use State or something ?
02:49:28 <ivanm> oh, you already do... :s
02:50:00 <naren> but the thing is everytime classify is called the whole monad runs since evalState is called
02:50:03 <Cale> naren: State computations are really functions... so what they produce for a given input state is not stored anywhere automatically.
02:50:10 <naren> right...
02:51:19 <ivanm> you might want to have some saved cache type for learning behaviour
02:51:28 <ivanm> then learn :: Cache -> Data -> Cache
02:51:50 <naren> So wrap the monad around another data type?
02:52:09 <ivanm> depends on how you write it ;-)
02:52:32 * ivanm usually writes his code in such a fashion that it's probably a poor-man's-state done manually
02:53:02 <naren> [aside] can you tell me what Strict State does differently from Lazy State?
02:53:27 <ivanm> dunno for sure, but I would guess that Strict fully evaluates its params all the time
02:53:28 <Axman6> probably applies seq to all operations
02:53:36 <ivanm> well, by "fully" I meant what Axman6 said
02:53:43 <Saizan_> naren: maybe you should evalState only once? and then use the returned state to classify?
02:53:48 <EvilTerran> as i understand it, the difference would be demonstrated by "do put undefined; get"
02:53:57 <Saizan_> EvilTerran: no
02:54:03 <naren> the thing is I don't want to expose the state outside the module
02:54:06 <EvilTerran> no?
02:54:13 <Saizan_> strict state is only strict in the tuple holding the state
02:54:17 <EvilTerran> ohhh
02:54:19 <EvilTerran> nvm
02:55:01 <Saizan_> naren: you can expose only the type but not the constructors
02:55:18 <naren> Type of the state you mean?
02:55:27 <naren> Actually, that's not a bad idea
02:55:44 <naren> That would work, because classifying on the computed state would be instant
02:56:11 <Saizan_> yes, type of the state
02:56:45 <naren> This is only the second time I have written code using a monad, so I am still a bit hazy on its "intended use". Right now I just use them as a way to carry state around a data type. But, it does drastically clean up the code.
02:59:38 <yairchu> cabal question: is there an equivalent of a "cabal remove"? I installed Iteratee and now I have the problem of "Could not find module `Control.Monad.Trans': it was found in multiple packages: transformers-0.1.4.0 mtl-1.1.0.2"
02:59:55 <naren> Alright, so I'll get into a little bit of detail so you can tell me if my design makes sense. The structure is I have a StateT representing a collection of nodes which operates on an internal State monad that represents each Node. Now, classification happens such that I run evalStateT and then run evalState to get the value. Which seems a bit wierd because I don't really do anything with the monad returned by evalStateT
03:00:07 <dcoutts> yairchu: ghc-pkg hide transformers
03:00:28 <yairchu> dcoutts: thanks! it works!
03:00:29 <dcoutts> yairchu: doesn't uninstall, just removed the ambiguity
03:07:09 <Saizan_> naren: so classification only uses the internal state to do its work?
03:13:15 <naren> clasification uses the state in StateT which contains an array of
03:13:16 <naren> State monads representing the different nodes.
03:23:35 <Saizan_> that's quite peculiar..
03:24:05 <Saizan_> you should store the states rather than the "state monads" ..
03:24:11 <Saizan_> but he left.
03:40:30 <bastl> is there a way in ghci to jump to a specific line using ":e" ?
03:41:30 <ivanm> in the file?
03:41:43 <bastl> yes
03:41:47 <ivanm> not unless you use a ghci-aware editor like emacs or something
03:41:49 <ehamberg> ghci can't know the switches your $EDITOR wants to be able to do that.
03:41:53 <ivanm> and even then, I don't think you can do it in emacs
03:43:10 <ehamberg> i guess you have to use :e <file> <args>
03:43:17 <bastl> im using vim. so there is no environemnt variable in ghci that saves the line of last error, so that :e can run "vim $file +$line" ? that's a pity
03:43:24 <ehamberg> :e foo.hs +10 works with EDITOR=vim
03:43:32 <bastl> ah
03:43:43 <bastl> and how do i refer to the "current" file then?
03:43:50 <ehamberg> that i don't know :/
03:43:54 <bastl> :e +12 edits file "+17"
03:43:56 <bastl> hm.
03:44:59 <ehamberg> :set editor vim +17
03:45:00 <ehamberg> :e
03:45:01 <ehamberg> ;-)
04:03:55 <taruti> What is the correct way to have windows-specific #ifdefs in Haskell code?
04:08:26 <doserj> taruti: mingw32_HOST_OS
04:14:19 <hackagebot> hsx 0.5.6 - HSX (Haskell Source with XML) allows literal XML syntax to be used in Haskell source code. (NiklasBroberg)
04:28:09 <Guest38878> my pussy for free http://www.insanezone.ro/konvar-15860.html
04:28:13 <Guest38878> WOW
04:28:14 <Guest38878> :X
04:28:24 <ivanm> *sigh*
04:28:30 <Guest38878> http://www.insanezone.ro/konvar-15860.html
04:28:32 <Guest38878> http://www.insanezone.ro/konvar-15860.htmlhttp://www.insanezone.ro/konvar-15860.htmlhttp://www.insanezone.ro/konvar-15860.html
04:28:34 <ivanm> Guest38878: we don't care
04:38:05 <Vanadium> Excuse the offtopic: <ivanm> "*** The libgnutls-config script installed by LIBGNUTLS could not be found" <- I just got word that this has been fixed in the repository and will likely be released together with some other, Windows-specific issue after the weekend.
04:43:40 <ivanm> Vanadium: heh, just managed to finally work out how to patch it
05:23:53 <mopped> In lambda calculus, 0 is f x, 1 is f (f x), etc, but how do you express negative numbers?
05:25:00 <doserj> Int = (Nat,Bool), for example
05:26:17 <EvilTerran> mopped, that's only one possible representation of several; there's many ways of representing anything
05:26:41 <mopped> oh
05:27:06 <EvilTerran> but doserj's is the most obvious for Int
05:29:48 <EvilTerran> Either Nat Nat would work, too
05:30:35 <EvilTerran> (in fact, Either Nat Nat = Nat + Nat = 2 * Nat = (Bool, Nat), so those're equivalent)
05:35:36 <quicksilver> I'm not sure they're any "more" equivalent than any two representations.
05:35:42 <quicksilver> they would be concretely different.
05:35:54 <EvilTerran> true
05:36:00 <quicksilver> they both have the problem of two zeroes ;)
05:36:19 <quicksilver> you probably want to conventionally add one to the negative ones
05:36:35 <EvilTerran> what, make (0,False) or (Left 0) be (-1) instead of 0?
05:36:44 <quicksilver> yes
05:36:56 <quicksilver> if you worry about such things, anyway.
05:39:55 <Philonous> diagonlize: phi :: (Nat,Bool) -> Nat; phi x | x>=0 = 2x ; otherwise = 2x+1
05:40:08 <Philonous> Oops, ignore the first part
05:40:56 <quicksilver> yes, you could just represent Z in N, of course ;)
05:42:12 <gwern> hm. ICFP starts today in a few hours
05:42:22 <Vanadium> Oooh.
05:44:19 * doserj nitpicks. icfpc starts today, icfp starts in august...
05:44:30 <ivanm> gwern: 5:17 by my reckoning
05:45:08 <ivanm> doserj: well, if you take the initials of "ICFP Contest", doesn't it become "IC" ? :p
05:45:34 * tibbe___ tears his hair out trying to solve a typing knot
05:45:46 <ivanm> you typed your fingers into a knot?
05:45:53 <tibbe> heh no
05:46:16 <tibbe> monad transformers, CPS transform and control/shift stuff in the same function is making my head axplode
05:46:20 <tibbe> explode*
05:46:54 <ivanm> shouldn't that be asplode?
05:46:56 <ivanm> ;-)
05:47:07 <Vanadium> What is a lightning round? Like the regular contest, except less time?
05:47:23 <gwern> Vanadium: yes
05:47:28 <ivanm> Vanadium: 24hrs to do a subset
05:47:29 <gwern> 24 hours from start to finish
05:47:34 <Vanadium> Ah
05:51:15 <sebas__> hey guys, I have some strange problems trying to install the BerkeleyDBXML bindings on ubuntu but the seem to be missing the native c libraries
05:51:25 <sebas__> s/the/they/
05:51:48 <sebas__> the db and dbxml libraries are just installed in /usr/local/lib, a default place
05:52:04 <sebas__> any idea how to interpret cabal's "* Missing C libraries: dbxml, xml2"  message
05:52:05 <sebas__> ?
05:52:16 <ivanm> sebas__: install those libraries?
05:52:30 <Cale> ivanm: apparently they are installed?
05:52:36 <sebas__> these libraries are just there in /usr/local/lib
05:52:46 <ivanm> that's not the default place AFAIK...
05:52:50 <Cale> sebas__: Do you have the -dev versions of the packages?
05:52:59 <Cale> sebas__: You need the include files installed as well.
05:53:28 <sebas__> those are also in /usr/local/include/  and /usr/local/include/dbxml
05:53:32 <ivanm> sebas__: do you have to tell cabal where to find those libs?
05:53:49 <Cale> Perhaps it's not looking under local...
05:54:08 <sebas__> i tried with --extra-include-dirs and --extra-lib-dirs
05:54:11 <sebas__> no change
05:56:13 <sebas__> when i run cabal -v it shows some more information but no clue why cabal thinks these libraries are missing
05:57:08 <quicksilver> sebas__: I think you should use the ubuntu packages.
05:57:14 <quicksilver> and not install things in /usr/local
05:58:06 <sebas__> quicksilver: I'll give that a try
06:01:41 <bastl> :r
06:01:44 <bastl> oops
06:02:33 <sebas__> Shame, there seems to be no dbxml within the ubuntu server repo.
06:08:08 <tibbe> is it possible to define a "join" for the following data type:
06:08:08 <tibbe> data ResultT m a = DoneT a !Stream
06:08:09 <tibbe>                  | ContT (Stream -> m (ResultT m a)) (Maybe Error)
06:08:33 <tibbe> i.e. join :: Monad m => m (ResultT m a) -> ResultT m a
06:08:50 <ivanm> hmmm....
06:09:22 <ivanm> tibbe: how would such a join behave?
06:09:36 <ivanm> and how would it be different from just using <- or something?
06:09:44 <tibbe> I guess the only option would be to delay the effect m inside the Cont
06:11:03 <tibbe> join m _ = ContT (join m)
06:11:33 <ivanm> tibbe: you said it only takes one param...
06:11:47 <ivanm> m (ReusltT ...) -> ResultT ...
06:11:53 <tibbe> ah yes
06:11:59 <tibbe> forget about the _
06:12:10 <tibbe> I got confused by the (Maybe Error) part
06:12:45 <ivanm> also, that type is: join :: (Stream -> m (...)) -> ResultT m a
06:15:34 <tibbe> hmm, I think I found another solution to my problem than using a join
06:19:25 <dcoutts> sebas__: do you actually have those libs installed?
06:19:25 <lambdabot> dcoutts: You have 1 new message. '/msg lambdabot @messages' to read it.
06:20:25 <dcoutts> sebas__: I mean, Cabal thinks they are missing, do you think they are missing too? or do you think they are installed? or perhaps you're not sure what those libs are
06:32:41 <sebas__> dcoutts: all the libXXX.so ands libXXX.a are actually available in /usr/local/lib/
06:32:55 <sebas__> but now I am trying to install them in /usr/lib
06:33:08 <dcoutts> sebas__: ah ok, then it should work to just pass --extra-lib-dirs=/usr/local/lib
06:34:00 <dcoutts> sebas__: lemme know if that doesn't work
06:34:46 <sebas__> sure, thanks
06:39:10 <sebas__> dcoutts: still failing, maybe I just type in the wrong things:
06:39:11 <sebas__> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=6266
06:41:39 <dcoutts> sebas__: I think if you run with -v3 it says what error it found when trying to use the lib
06:42:44 <sebas__> that helps!
06:43:03 <sebas__> lots and lots of more info
06:43:07 <sebas__> like    /usr/bin/ld: cannot find -lxml2
06:43:14 <sebas__> that's somethings
06:43:16 <sebas__> -s
06:44:40 <dcoutts> sebas__: anything similar about the dbxml ?
06:47:27 <sebas__> dcoutts: after creating a libxml2.so symlink yo libxml2.so.2 everythings seems to install properly
06:47:34 <sebas__> no claims about dbxml
06:47:48 <sebas__> but dbxml probably just needed xml2
06:48:10 <dcoutts> sebas__: that's plausible
06:49:00 <dcoutts> sebas__: so now you've got everything in the standard locations, there should be no need to use --extra-lib-dirs or --extra-include-dirs
06:49:49 <sebas__> I only used --extra-include-dirs=/usr/lib/dbxml
06:51:25 <sebas__> Now I seem to have the same problem with libcurl for the Haskell Curl package.
06:52:40 <sebas__> no, problem is not the same. Only of the same category.
06:53:12 <sebas__> but there seems to be some missing links between my ubuntu system and cabal
06:54:04 <dcoutts> sebas__: cabal doesn't do anything unusual, it's just calling gcc to link stuff
06:54:17 <dcoutts> so if cabal cannot find things it's because gcc also cannot
06:54:55 <dcoutts> sebas__: are you sure --extra-include-dirs=/usr/lib/dbxml is correct?
06:55:19 <dcoutts> does that dir under /usr/lib really contain public header files? that's not at all standard
06:55:41 <Zao> Doesn't python do nasty things like that too?
06:55:51 <dcoutts> it's ok for private header files
06:56:13 <dcoutts> eg ghc keeps private header files in /usr/lib/ghc-x.y/include/
06:57:05 <Zao> Talking about "standard" in unix file system layouts is a bit silly in general.
06:57:23 <dcoutts> and there should be no need to specify --extra-include-dirs=/usr/include/dbxml because if that's the correct setup the headers would be specified as "dbxml/DbXml.hpp"
06:57:37 <dcoutts> Zao: there's the FSH and common practise
06:57:55 <dcoutts> like header under $prefix/include, libs under $prefix/lib
06:58:20 <syntaxfree2> de jure standards are not real standards. de facto standards are generally not universal enough to deserve the name "standard".
06:58:33 <syntaxfree2> "Standard" is a value judgement. I much prefer "protocol".
06:59:05 <dcoutts> the FSH is a reasonably well defined standard, though it's not exactly the same as common unix practise
07:00:04 <syntaxfree2> the word "protocol" implies two parts that are signataries/participants in it.
07:00:29 <syntaxfree2> the word "standard" means there's something above the participants by which they must abide.
07:00:48 <Igloo> dcoutts: DYM FHS?
07:00:48 <syntaxfree2> "Standards" are fodder for holy wars.
07:00:59 <dcoutts> Igloo: I probably do
07:02:09 <syntaxfree2> The Standard Meter in Paris is a standard. TCP/IP is not a standard, let alone SSH, let alone FSH.
07:03:17 * dcoutts thinks syntaxfree2's standard of standard is rather high
07:03:21 <syntaxfree2> sorry, I think  I went a bit Sheldon here.
07:03:31 <mux> there is no standard meter in Paris, you meant standard kilogram
07:04:08 <SheldonCooper> isn't the cesium thing held in Paris?
07:04:20 <SheldonCooper> if I am wrong, I stand corrected.
07:04:28 <doserj> the standard meter in paris hasn't been a standard since almost 50 years ago
07:04:47 <mux> I guess you're referring to the second which is defined as some number of vibrations of a cesium atom
07:04:49 <Cale> There's still a standard kilogram
07:04:59 <mux> the meter is defined through the speed of light these days
07:05:02 <Vanadium> It keeps changing in weight, though :'(
07:05:09 <mux> only the kilogram relies on an artifact, and that's a hot topic
07:05:30 <Cale> I think it should be the ampere instead.
07:05:33 <SheldonCooper> yes, there are Metric Standards 2.0. I read too many pop science books as a children in the 80s, so I might confuse them all.
07:06:57 <SheldonCooper> mux: the speed of light? really? but the numbeer of vibrations in an atom is potentially measurable, while an infinitesimal fraction of the velocity of light (from whence the meter would be extracted) is probably not.
07:07:45 <mux> the number of vibrations of an atom (cesium) is used to defined time (the second), not length
07:07:47 <burp> you don't need to measure speed of light to define it
07:07:58 <mux> SheldonCooper: the speed of light is well-known
07:08:00 <SheldonCooper> high school physics loosely defines the acceleration of gravity as 10, so 1kgf = 10N
07:08:10 <burp> you need length for "speed"
07:08:12 <SheldonCooper> (10 ms^-2 I meant)
07:08:17 <burp> and it's just defined via speed of light ;)
07:09:18 <SheldonCooper> mux: Yes. But are experiments confirming the time between two positions of a light-thing feasible?
07:10:06 <mux> SheldonCooper: to some extent yes
07:10:19 <mux> they use laser interferometers
07:10:27 <SheldonCooper> water is pretty common in the world. 1kg = weight(1L water) is pretty good for me. I don't know why Metric Standards would move away from feasible measurements.
07:10:39 <SheldonCooper> mux: oh boy, I'm such a gamma nerd.
07:10:52 <mux> SheldonCooper: because this is a very, very vague definition
07:10:58 <SheldonCooper> (as in Brave New World's chastes)
07:11:13 <SheldonCooper> I'm a mere economist, and I shall return to my modest craft right now.
07:11:16 <opqdonut> SheldonCooper: reflecting the beam will let one measure the time delay exactly
07:11:17 <mux> your definition depends on the atmospheric pressure, the temperature, the measure of a volume, and  god knows what else :-)
07:11:20 <SheldonCooper> (Deadlines to fulfill!)
07:11:40 <opqdonut> just keep moving the mirror further until one gets a nice multiple of the time the meter is defined on
07:11:42 <mux> but note that there are still no "pure" definition of a kilogram
07:11:47 <opqdonut> indeed.
07:11:49 <opqdonut> that
07:11:51 <opqdonut> 's a problem
07:11:54 <mux> which is why there's still this stupid chunk of metal in Paris
07:11:55 <SheldonCooper> mux: you are right..
07:12:00 <SheldonCooper> re: temperature and pressure.
07:12:09 <opqdonut> the best they've come up is a rough amoung of carbon atoms
07:12:10 <SheldonCooper> My whole rant on standards versus protocols stands independently of the new information I've acquired in the last minutes.
07:12:26 <SheldonCooper> the metric standards are standards. everything else is protocol.
07:12:49 <Cale> Perhaps the kilogram should be defined in terms of Planck masses.
07:13:18 <mux> SheldonCooper: according to wikipedia, they can measure the meter via the speed of light definition at 2.5e-11 precision
07:13:26 <Vanadium> Perhaps the unix filesystem layout should be defined in terms of metric units.
07:13:51 <mux> Cale: one goal of the definition they're looking for is that it should be measurable
07:14:08 <SheldonCooper> I shall return now to my modest craft.
07:14:34 <mux> Cale: future discovery on the higgs boson might give us a nice way to define weight, since this particle is supposed to be the one giving mass to everything
07:14:36 <Cale> mux: Yeah, but if it's defined in terms of Planck masses, you can always produce better approximations to it.
07:15:22 <syntaxfree> Cale: yay for assymptotics!
07:15:24 <bastl> I'm working at a chair for software-engineering. We have a long tradition in thinking abstractly about OO-Software, especially "Good Design" (Design Patterns e.g.). Is there any work on "good design" or things like "software-engineering-processes/methods" for functional programming? the only source i know of is the wiki, esp. category "Idioms", but is that all?
07:15:28 <syntaxfree> the best thing since alcohol.
07:15:54 <syntaxfree> bastl: I'm working at a chair with arms, but that's vastly worse than the one I used to occupy.
07:15:56 <Cale> bastl: Well, I'm not sure what to point you at, but functional programming in some sense is such a collection of methods.
07:16:21 <syntaxfree> They didn't let me keep it because this is an open plan now and it would stand out from the decoration.
07:16:23 <bastl> you still have design decisions, and im looking for guidelines ...
07:16:31 <syntaxfree> OH. I see what you mean.
07:16:40 * syntaxfree shuts the frak up.
07:16:44 <quicksilver> bastl: I think it's true that there is less literature about the engineering side of functional programming.
07:16:54 <quicksilver> I've seen bits an pieces in interesting papers
07:17:06 <quicksilver> but I can't point you at a book or guide for "writing large functional programs well"
07:17:11 <bastl> quicksilver: but is there any? i dont even know the keywords to google ...
07:17:20 <basvandijk> Hello, I'm writing a binding for libftdi and I have a short question: What's the best way to handle exceptions in foreign calls?
07:17:23 <Cale> bastl: I would perhaps start with SICP.
07:17:27 <basvandijk> See: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6267#a6267   Suppose I want to write a high level wrapper around 'c_ftdi_usb_open_desc'.
07:17:37 <basvandijk> This functions returns 0 when all is fine and a negative number encoding the error.
07:17:44 <quicksilver> bastl: http://www.google.com/search?q=functional+programming+engineering
07:17:47 <basvandijk> Should I return a 'IO (Maybe String)' where 'Nothing' means no errors and 'Just errStr' encodes the error. Or should I use Exceptions?
07:17:48 <Cale> bastl: It's a good deal broader than just FP, but it covers the basic notions well.
07:17:57 <quicksilver> bastl: gives you some promising starting points.
07:18:24 <bastl> CAle: looks good.
07:18:27 <Cale> basvandijk: Depends on how the error will usually be treated.
07:18:27 <syntaxfree> @go managing large functional programming projects
07:18:28 <lambdabot> No Result Found.
07:18:42 <Cale> er...
07:18:50 <basvandijk> Cale: I think they usually will be ignored
07:19:01 <Cale> basvandijk: oh, Nothing is usually reserved for the error case.
07:19:09 <Cale> and Just x for success
07:19:21 <mux> Either String () would be less confusing
07:19:27 <mux> for the reasons outlined by Cale
07:19:27 <Cale> Yeah.
07:19:35 <basvandijk> mux: right
07:19:38 <Cale> Or just throw an exception.
07:19:43 <bastl> quicksilver: ok, "engineering" is much better that "design" or similar.... I was to restricted to OO-terminology ...
07:19:46 <basvandijk> But what about using Exceptions?
07:19:47 <mux> although, if you say that most of the time it is going to be ignored, exceptions are fine
07:19:49 <Cale> IO has exceptions, I don't think it hurts to use them :)
07:19:55 * mux nods
07:20:07 <Cale> Create a good new exception type, and throw exceptions of that type properly.
07:20:12 * mux feels so smart because he agrees with Cale ;-)‡
07:20:29 <basvandijk> Cale: Ok thanks
07:20:48 <Cale> data MyException = ... deriving (Eq, Ord, Show, Typeable)
07:21:03 <Cale> instance Exception MyException
07:21:19 <Cale> and then you just use throwIO to throw it :)
07:22:38 <Cale> bastl: Here's the general idea of functional programming: solve problems by designing languages in which they can be expressed together with code that projects those expressions of the problem to code for solving it.
07:23:12 <bastl> cale: sorry, that's to cheap.
07:23:23 <bastl> and the same holds for OO.
07:23:44 <bastl> im thinking of things like extendability, robustness and the like
07:24:00 <Cale> Well, if you can do that well, you get extensibility and robustness. :)
07:24:06 <wunki> can someone tell me how the thing above/below the line in a division is called in english? Below: divider?
07:24:16 <bastl> how do I "Program against Interfaces" in Haskell?
07:24:16 <quicksilver> numerator/denominator, wunki
07:24:33 <wunki> quicksilver: thank you!
07:24:40 <bastl> typeclasses/families/modules hiding? qualified ??
07:24:40 <Cale> Because small changes in the problem turn into hopefully-small changes in the value which represents it.
07:24:53 <Cale> and then the code which solves that problem doesn't need to change.
07:25:06 <bastl> Cale: that's true for theoreticians
07:25:13 <bastl> I recently learned about hte "Zipper"
07:25:32 <Cale> what about it?
07:26:00 <bastl> I learned it's folklore, but theres noone who collects this kind of folklore.
07:26:13 <Cale> Hm? There are papers about it.
07:26:16 <bastl> (similar to gamma et al. with their design patterns)
07:26:30 <opqdonut> gamma?
07:26:37 <bastl> Erich Gamma
07:26:38 <Cale> You are looking for a paper by Huet.
07:26:43 <bastl> i read it
07:26:48 <Cale> http://www.st.cs.uni-saarland.de/edu/seminare/2005/advanced-fp/docs/huet-zipper.pdf
07:26:50 <bastl> zippers were there before.
07:27:05 <bastl> let me state it this way:
07:27:06 <Cale> So, it's not folklore, that's published :)
07:27:26 <bastl> it's one example :-)
07:27:29 <Cale> There's plenty which really *is* folklore :)
07:27:45 <bastl> so where's the book that collects it?
07:27:49 <Cale> But it tends not to stay folklore forever.
07:27:53 <bastl> its only category:idions in the wiki
07:27:57 <Cale> Various journals.
07:28:30 <Cale> J. Functional Programming seems to collect quite a lot
07:28:35 <ccasin> bastl: http://www.amazon.com/Purely-Functional-Structures-Chris-Okasaki/dp/0521663504 is a good start
07:28:48 <Cale> More and more, people are starting to use the web instead.
07:28:56 <Cale> Which is a good thing, I think.
07:29:05 <doserj> Cale: bastl is looking for software engineering books, not computer science articles. that's a big difference.
07:29:24 <quicksilver> there are plenty of computer science articles about software engineering.
07:29:27 <Cale> A book is not *so* different from a bunch of articles :)
07:29:33 <quicksilver> the CS dept where I used to work had an SE group.
07:29:49 <bastl> doserj: that's my point.
07:29:56 <Cale> You can make your own book if you have enough URLs.
07:29:57 <fasta> Is there a strict Data.Map somewhere?
07:30:16 <Cale> fasta: there are strict operations on Data.Map, and it is already structurally strict
07:30:42 <Cale> (because of the need to count vertices for balancing)
07:30:52 <quicksilver> and it's strict on keys to the extent required for comparison.
07:31:00 <Cale> yes, and that :)
07:31:36 <quicksilver> IIRC there are a couple of holes in the API where it fails to provide a strict version of some of the value-modifiers, though.
07:31:56 <Cale> Yeah, it should definitely provide more strict variants of operations.
07:32:13 <bastl> weekend and sunshine is calling. cu
07:32:15 <fasta> I have a function which causes out of memory, while it should never ever allocate that much to begin with. It basically just parses some files and puts it in a Data.Map. I think it just doesn't do that strictly enough, but I didn't use all the profiling flags yet.
07:32:56 <Cale> fasta: what computation is being done on the files to generate the elements?
07:33:00 <quicksilver> it's probably putting half-parsed values into the value part of the map
07:33:12 <quicksilver> hanging on to lots of crap you dont' want it to hang on to.
07:33:14 <Cale> yeah, it could be doing that
07:33:14 <quicksilver> although this is guesswork.
07:33:27 <Cale> It could also be that you're underestimating the size of the data :)
07:33:56 <Cale> (String is worse than many people expect)
07:35:10 <Zao> 12 bytes per character or so?
07:36:09 <fasta> Cale: Yes, I was underestimating the size of the data.
07:36:23 <Cale> Zao: seems about right.
07:36:35 <Cale> maybe worse still ;)
07:37:00 <fasta> So, is there an XML parsing library which does not use String?
07:39:45 <quicksilver> it's more than 12.
07:40:06 <quicksilver> 16? 20?
07:40:30 <quicksilver> cons-cell indirection, cons-cell constructor, char indirection, char data.
07:40:35 <quicksilver> 16 by that count.
07:40:49 <Vanadium> Is that 32 on x86-64?
07:40:50 <Cale> fasta: Good question. I've never needed to parse very large XML documents.
07:40:56 <quicksilver> and 24 on x86-64
07:40:59 <Vanadium> Ah
07:41:08 <Cale> (There is an argument for not using XML if your data is so large though...)
07:41:12 <quicksilver> you need 8 bytes for the pointers, but the data cells remain 4 bytes, I think.
07:41:22 <Cale> Maybe this hexpat library?
07:41:51 <Cale> http://hackage.haskell.org/package/hexpat
07:42:14 <Cale> http://hackage.haskell.org/package/hexpat-pickle
07:42:43 <doserj> http://hackage.haskell.org/package/libxml
07:43:27 <quicksilver> ah yes, thats the galois one.
07:43:28 <Cale> That looks kind of even worse ;)
07:43:37 <quicksilver> that suggests it will be fast and efficient and totally undocumented :)
07:43:49 <Cale> heh
07:43:54 <Cale> It's all in IO
07:44:02 <Cale> (the libxml one)
07:44:13 <quicksilver> I think it has to be.
07:44:20 <quicksilver> ISTR libxml has state
07:44:23 <Cale> probably
07:44:39 <quicksilver> you'd need to protect everythign with mutexes if you wanted it to pretend to be pure.
07:44:56 <quicksilver> and unsafePerformIO'd code in threads turns out to be a not well trodden path
07:45:01 <quicksilver> as two recent GHC bugs attest.
07:45:17 <Cale> The binding to expat seems to present a pure interface at least, with a proper XML tree datatype
07:45:59 <Cale> and it supports ByteString
07:46:57 <Cale> XML is such a horrible thing.
07:47:09 <quicksilver> meh, it's not that bad.
07:47:25 <Vq^> Cale: you're probably not using enough of it
07:47:28 <quicksilver> if used well, it's a convenient inherently extensible format.
07:47:35 <mux> Cale: are you the reincarnation of erik naggum?
07:47:44 <mux> XML clearly is not that bad
07:47:44 <quicksilver> I was recently asked to help out on someone's website
07:47:48 <Cale> mux: I have about the same views as he did.
07:47:50 <quicksilver> and they were using XML + XSL
07:47:57 <quicksilver> it was a really nice set up.
07:48:02 * mux gets tempted to hit Cale violently with a pointy S-exp :-)
07:48:13 <Vanadium> XSL is scary, but the good kind of scary
07:48:13 <quicksilver> The XML was a pretty good semantic description of the page content (intended to be human editable)
07:48:14 <mux> XML + XSLT is way nice for many thigns
07:48:23 <quicksilver> and the XSL turned it into HTML, applying constant styling.
07:48:27 <quicksilver> erm, consistent.
07:48:41 <quicksilver> it really did strike me that for that purpose, it can be nice if used well.
07:48:45 <Cale> For the things people use it for, S-expressions are essentially always nicer than XML.
07:48:54 <mux> quicksilver: we've been using that at a previous company I've been working, and we used it to output HTML or WML for mobile phones or ...
07:49:10 <quicksilver> Cale: personally I quite like labelled close tags.
07:49:20 <quicksilver> Cale: I think that's just about the only important distinction ;)
07:49:27 <Cale> and attributes?
07:49:33 <mux> Cale: where are the standards for describing the structure of a document with S-exp? such as DTD/XSD/RelaxNG for XML
07:49:34 <quicksilver> take em or leave em
07:49:39 <quicksilver> they don't bother me much.
07:49:51 <mux> plus labelled close tags makes for better error reporting
07:50:07 <Cale> mux: You mean checking that a tree has a given structure?
07:50:22 <quicksilver> Cale: no, he means producing a better error message if there is the wrong number of )
07:50:37 <mux> quicksilver: I think Cale was referring to my previous sentence about DTD etc
07:50:44 <quicksilver> oh :) yes.
07:50:45 <mux> Cale: and a bit more than that, but yes
07:51:00 <mux> RelaxNG allows to check much more than just the structure
07:51:07 <quicksilver> Cale: It would probably have been equally nice in s-expressions, yes.
07:51:26 <Cale> That is a subset of what you can do with programs that manipulate trees.
07:51:33 <quicksilver> Cale: but there is no standard C library for manipulating S-expressions, and no standard declaration "transformation" language for S-expressions.
07:51:41 <quicksilver> s/declaration/declarative/
07:51:46 <quicksilver> damn words.
07:51:59 <nainaide> A little confuse, please help , thanks    http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6268#a6268
07:52:01 <mux> Cale: the point is not about being able to do it, the point is to have a well-established standard that allows you to do it whatever environment you're working with, in a language neutral  fashion
07:52:02 <Cale> Okay, let's go with scheme then ;)
07:52:03 <gwern> I sometimes wonder whether optional closing tags would be a happy medium
07:52:20 <quicksilver> Cale: I can't imagine preferring scheme to XSL.
07:52:28 <Cale> I can
07:52:41 <Cale> scheme is a much nicer programming language than XSL.
07:52:48 <mux> not surprising
07:52:49 <Cale> nainaide: looking...
07:52:52 <mux> XSL is not a programming language
07:52:55 <doserj> nainaide: filterM p xs has type m [a]. ys has type [a].
07:52:59 <quicksilver> Cale: having to define or let-bind all the constructs in my minilanguage to somehow 'pervert' my input into a program which produces the output.
07:53:02 <quicksilver> Cale: exactly.
07:53:05 <quicksilver> Cale: and I don't want a programming language.
07:53:12 <Cale> :t (:)
07:53:12 <mux> (the fact that it allows open recursion is merely a side-effect)
07:53:15 <lambdabot> forall a. a -> [a] -> [a]
07:53:16 <quicksilver> Cale: I want a simplistic query/transform language.
07:53:17 <Cale> nainaide: ^
07:53:36 <quicksilver> which enables me to convert my input (be it s-exp or XML) into the output in a simple wa.
07:53:36 <nainaide> Cale, doserj , thanks
07:53:48 <mux> to sum things up, I often like to say that the advantage of XML is the standards, and that the drawback of XML is the standards
07:53:49 <Cale> quicksilver: Well, okay, you can define a library in scheme for composing queries or transformations then.
07:54:07 <quicksilver> probably, yes.
07:54:08 <mux> Cale: we don't want a library, we want a language-neutral standard :-P
07:54:08 <Cale> You can even make that library widely available ;)
07:54:17 <quicksilver> Or I can use XPath and XSL, which actually exist.
07:54:21 <quicksilver> Are declarative.
07:54:22 * mux nods
07:54:25 <quicksilver> And not too verbose.
07:54:26 <mux> or XQuery
07:54:40 <Cale> I disagree on the 'not too verbose' point.
07:54:54 <Cale> anything in XML is absolutely *horrible* to type
07:55:03 <mux> XML was never intended to be typed
07:55:18 <mux> anyone using XML in this fashion (such as for user editable configuration files) needs to be shot down
07:55:24 <mux> this is because of those guys that some people hate XML.
07:55:47 <Cale> From my perspective, programmers are users too.
07:55:52 <loget> Where can I learn web development in haskell?
07:56:16 <quicksilver> On the contrary, this website I was working on was definitely intended to be maintained by hand, in a text editor.
07:56:23 <Cale> If things are horrible for users, they're going to be just as bad for programmers. The only difference is that programmers might have a fighting chance to write some program to make it easier for them.
07:56:30 <nainaide> Cale, does <- means unwrap monad in do notation
07:56:43 <loget> Qhere can I learn about web development in haskell?
07:56:46 <loget> where*
07:56:48 <Cale> nainaide: v <- x means "run the computation x, and call its result v"
07:56:49 <quicksilver> anyhow I guess we're being noisy and off-topic.
07:56:52 <mux> XML makes most sense when used for having two pieces of code communicate
07:56:56 * mux nods
07:57:03 <Cale> nainaide: if x :: m a, then v :: a
07:57:05 * mux will silently go in week-end
07:57:20 <quicksilver> loget: http://www.haskell.org/haskellwiki/Practical_web_programming_in_Haskell
07:57:23 <quicksilver> is a starting point.
07:58:28 <gwern> mux: you can't leave for the weekend! the icfp is starting in 3 hours!
07:58:39 <Cale> quicksilver: Just as libraries have been developed for manipulating XML, if web standards had been designed in terms of S-expressions, there would be standard libraries (and probably simpler, more comprehensible ones at that) for manipulating S-expressions.
07:59:15 <Vanadium> Just use json :>
07:59:33 <Cale> (not that there aren't such libraries already)
07:59:40 <quicksilver> Cale: yes, that's true.
07:59:48 <Cale> http://hackage.haskell.org/packages/archive/sexpr/0.2.1/doc/html/Codec-Sexpr.html
07:59:59 <quicksilver> Cale: but they weren't, and there aren't, and XML isn't as bad as its detractors maintain.
08:00:02 <jimmyjazz14> does the unicode lambda sign work in haskell source code?
08:00:09 <nainaide> Cale, where can I find the defination of <- if there is ? thanks
08:00:12 <gwern> jimmyjazz14: not without an extension. maybe
08:00:12 <quicksilver> jimmyjazz14: it does with -XUnicodeSyntax in GHC.
08:00:17 <quicksilver> it's not a standard thing.
08:00:26 <quicksilver> nainaide: it's part of the syntax of the language.
08:00:30 <gwern> quicksilver: which lambda does that support, anyway?
08:00:32 <Cale> nainaide: do { v <- x; <stmts> } = x >>= (\v -> do { <stmts> })
08:00:37 <quicksilver> gwern: I don't know :)
08:00:43 <fasta> XML is documented and badly implemented. S-expressions are not documented.
08:01:00 <Cale> nainaide: That rule is one of the ones used to translate away the do-notation in terms of >>=
08:01:03 <nainaide> Cale, wonderful!
08:01:03 <fasta> I think that's all there is to say on the subject.
08:02:03 <Cale> Eh? Not documented?
08:02:05 <loget> This is why XML is awesome: http://www.w3.org/TR/xqueryx/#Examples
08:02:16 <Cale> http://people.csail.mit.edu/rivest/Sexp.txt
08:02:32 <loget> Just imagine, soon we will all be writing code like that
08:02:41 <Cale> loget: :)
08:02:52 <quicksilver> Cale:
08:02:57 <quicksilver> ah, of course, IMAP uses them.
08:03:08 <quicksilver> I was talking about that only today but I'd already forgotten about it.
08:03:26 <loget> Cale, in the link, look  at the code in xqueryx
08:03:33 <Cale> loget: Yes, I've seen that :)
08:03:35 <loget> lol
08:03:40 <jimmyjazz14> doesn't appear the unicode lambda actually works in place of normal lambdas
08:03:55 <mmorrow> jimmyjazz14: because it's a letter, not a symbol
08:04:10 <Cale> It's awesome in a sort of "AAAH! MY EYES ARE BLEEDING!" sort of way.
08:04:15 <jimmyjazz14> ah
08:04:18 <gwern> jimmyjazz14: there's more than one unicode lambda
08:04:24 <Zao> jimmyjazz14: Even with the shiny UnicodeSyntax extensions?
08:04:28 <gwern> there's the greek letter, the math lambda, etc.
08:04:50 <Cale> I think the Greek letter Œª should not work.
08:04:56 <jimmyjazz14> let me try some other lambda's
08:05:17 <gwern> Cale: it would make life a little hard for our greek hackers, yes...
08:05:41 <portnov> http://hackage.haskell.org/trac/haskell-prime/wiki/UnicodeInHaskellSource
08:05:43 <Zao> let foldŒª = foldl
08:05:49 <Vanadium> gwern: If foreign hackers deem it fit to write their code not only in foreign languages but also foreign encodings, I am all for making their life as hard as possible
08:05:54 <portnov> I don't see lambda there...
08:06:15 <Cale> Vanadium: What foreign encoding?
08:06:22 <quicksilver> Vanadium: do you count UTF8 as a foreign encoding?
08:06:28 <gwern> Vanadium: now that I think of it, they should write in ascii and be grateful for being allowed to use our computer technology!
08:06:35 <Cale> We should maybe make (ùúÜx -> x^2) work though. :)
08:06:42 <Vanadium> non-ascii
08:06:52 <Cale> non-ascii?
08:07:05 <Vanadium> ie non-common-subset-of-utf8-and-iso-8859-x
08:07:18 <quicksilver> Vanadium: but you can't write most foreign languages in ascii!
08:07:31 <Vanadium> quicksilver: I am not trying to, I am trying to write code here!
08:07:36 <gwern> quicksilver: they should have thought of that before deciding to use a foreign language!
08:07:42 <pikhq> ... You guys don't do Unicode? Come on, you're behind Tcl! :P
08:07:44 <gwern> no one's fault but their own
08:07:44 <quicksilver> why should they not be allowed to use variable names in their own language?
08:07:45 <Cale> UTF-8 is *the* encoding. ;)
08:07:57 <Cale> > maxBound :: Char
08:07:59 <lambdabot>   '\1114111'
08:08:12 <Zao> Cale: UTF-* :)
08:08:32 <Cale> Indeed, it's important to support the others too.
08:08:38 <jimmyjazz14> hmm maybe I can just get emacs to sugar up my syntax a little
08:08:39 <Vanadium> quicksilver: Because that is inconsiderate to programmers of other nationalities and also looks like shit surrounded by keywords and library names in English
08:08:48 <loget> it's pretty easy to write a function ot convert ascii to utf-8 and back
08:08:51 <Cale> But non-UTF encodings are dead :)
08:08:57 <Zao> Cale: You have to support the poor souls that save files as "unicode" in notepad.
08:09:09 <Cale> loget: but how about the other way? ;)
08:09:09 <mux> ascii to utf-8 sure isn't hard, the function is called id :-)
08:09:13 <fasta> Cale: that's one kind of S-Expressions. Other people have a slightly different understanding of what it is. They should have started with a specification, not make up one years and years after they were in wide use. Still, you have to admit that XML in many ways is documented more formally than this simple text file.
08:09:14 <Zao> (which is UTF-16LE I believe)
08:09:31 <Zao> mux: If by ASCII you mean 7-bit clean.
08:09:44 <loget> just do this:
08:09:44 <loget> ascii 'a' = 'a'
08:09:44 <mux> or latin1
08:09:49 <loget> but in utf-8 of course
08:09:52 <Zao> mux: No.
08:09:54 <loget> the first one
08:10:01 <loget> and just do that for every char
08:10:04 <Zao> mux: 0x8F in latin-1 is not 0x8F in UTF-8.
08:10:13 <Zao> 0x8F is U+008F.
08:10:23 <mux> yes, my bad, I totally foobar'ed
08:10:32 <pikhq> Zao: ASCII is 7-bit clean (and, in fact, a 7-bit encoding). Latin-1 is not ASCII.
08:10:35 <mux> anyways, ascii being what it is, ascii -> utf8 is id
08:10:46 <Zao> pikhq: Never trust anyone saying "ascii" to actually mean ascii.
08:10:48 * mux nods at pikhq 
08:11:12 <Vanadium> pikhq o/
08:11:15 <loget> ASCII Is the future of web communication
08:11:18 <Cale> fasta: I'm not saying that S-expressions could not be better documented/standardised than they are.
08:11:27 <Peaker> loget: heh, are you sarcastic? :-)
08:11:31 <pikhq> Mmm, well, a lot of people seem to think Latin-1 or *shudder* the Windows codepages are ASCII.
08:11:44 <Zao> 1252 represent, yo!
08:11:49 <loget> no, ascii is easier than all these complicated characters
08:11:57 <loget> who speaks chinese? not me
08:12:04 <Cale> fasta: Just that if you want a standard, there is a standard. :)
08:12:10 <quicksilver> Vanadium: that strikes me as a ridiculous point of view, by the way. Most of the world does not speak english.
08:12:28 <quicksilver> Vanadium: it's not to hard to learn a couple of dozen keywords, which is all haskell has.
08:12:30 <Zao> loget: When the chinese rule the world, you'll regret that.
08:12:43 <quicksilver> but after that you should be able to name variables on your own langauge if you choose ot.
08:12:49 <quicksilver> So I'm pleased that GHC supports it.
08:13:06 <quicksilver> I would not want learning english to be required to use haskell.
08:13:14 <pikhq> Zao: Oh, he thinks *that's* bad? Imagine if we did s/China/North Korea/.
08:13:16 <pikhq> ;p
08:13:19 <quicksilver> (although I don't deny that learning english is a smart career move)
08:13:24 <loget> They wont if we don't support unicode. They wont be able to talk to eachother
08:13:38 <loget> to plan the world domination stuff
08:13:53 <pikhq> The North Koreans don't have computers.
08:13:57 <pikhq> ;)
08:14:09 <Cale> ÁöÜ„Åï„Çì„ÄÅÊó•Êú¨Ë™û„ÅßË©±„Åó„Åæ„Åó„Çá„ÅÜÔºÅ
08:15:29 <ehird> Can lambdabot start parsing <<loop>> instead of the stupid mueval error?
08:15:52 <Cale> ehird: good question
08:15:59 <ehird> 16:13 quicksilver: I would not want learning english to be required to use haskell.       -- rote name-learning doesn't really help...
08:16:02 <ehird> Cale: :-)
08:16:45 <pikhq> Cale: :)
08:20:26 <Cale> Heh, supporting a Japanese-like grammar for Haskell would be especially interesting.
08:23:40 <Cale> Â∫èÊõ≤„ÇíËº∏ÂÖ•„Åô„Çã
08:40:25 <Valodim> Cale: wouldn't that basically mean changing everything to postfix notation, and add predicates to the end?
08:40:46 <Cale> Something like that :)
08:47:31 <roconnor> I need to buy 72 hours worth of food
08:47:51 <tibbe__> who's going to ICFP this year?
08:53:09 <Axman6> > foldl (zipWith (+)) [0,0..] [[150,200,45,57,95,2,45,32,15,10,5,2,2,4],[12,20,45,37,10,5,2,2,10,95,2,45,32,7],[32,15,10,5,2,23,24,15,20,45,57,95,0,45]]
08:53:10 <roconnor> tibbe: where is it again?
08:53:11 <lambdabot>   [194,235,100,99,107,30,71,49,45,150,64,142,34,56]
08:53:19 <tibbe> roconnor: Edinbrough
08:53:37 <roconnor> I don't think I'll make it
08:53:47 <gwern> u r noob lol
08:53:54 <gwern> gtg
08:54:29 <roconnor> Axman6: I think gwern just called you a noob
08:54:44 <Badger> :o
08:54:48 <Axman6> > foldl1' (\x (l,h) -> (min l x, max l h) . foldl (zipWith (+)) [0,0..] [[150,200,45,57,95,2,45,32,15,10,5,2,2,4],[12,20,45,37,10,5,2,2,10,95,2,45,32,7],[32,15,10,5,2,23,24,15,20,45,57,95,0,45]]
08:54:50 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
08:55:00 <Axman6> > foldl1' (\x (l,h) -> (min l x, max l h)) . foldl (zipWith (+)) [0,0..] [[150,200,45,57,95,2,45,32,15,10,5,2,2,4],[12,20,45,37,10,5,2,2,10,95,2,45,32,7],[32,15,10,5,2,23,24,15,20,45,57,95,0,45]]
08:55:02 <lambdabot>   Occurs check: cannot construct the infinite type: t = (t, t1)
08:55:11 <Axman6> > foldl1' (\(l,h) x -> (min l x, max l h)) . foldl (zipWith (+)) [0,0..] [[150,200,45,57,95,2,45,32,15,10,5,2,2,4],[12,20,45,37,10,5,2,2,10,95,2,45,32,7],[32,15,10,5,2,23,24,15,20,45,57,95,0,45]]
08:55:12 <lambdabot>   Occurs check: cannot construct the infinite type: t = (t, t1)
08:55:15 <Axman6> bleh
08:57:15 <Axman6> > (\(y:ys) -> foldl' (\(l,h) x -> (min l x, max l h)) (y,y) ys) . foldl (zipWith (+)) [0,0..] [[150,200,45,57,95,2,45,32,15,10,5,2,2,4],[12,20,45,37,10,5,2,2,10,95,2,45,32,7],[32,15,10,5,2,23,24,15,20,45,57,95,0,45]]
08:57:16 <lambdabot>   Couldn't match expected type `a -> [b]'
08:59:51 <fasta> Is there really no way to just rnf a Data.Map?
09:00:11 <fasta> The heap profiles don't really help anything.
09:00:48 <mmorrow> what do you mean no way to rnf a Data.Map?
09:01:08 <quicksilver> it's not an instance of NFData and you can't write one because the constructors aren't exported.
09:01:13 <quicksilver> I imagine he means.
09:01:15 <mmorrow> :o
09:01:22 <mmorrow> i could've sworn it was
09:01:25 <quicksilver> you can "rnf" the result of toList
09:01:33 <quicksilver> for a linear cost
09:01:39 <quicksilver> (but rnf will always be linear cost anyway)
09:01:59 <mmorrow> hmm, this is why i have a modified Int{Map,Set}..
09:02:10 * copumpkin votes (not sure where yet) to move rnf/NFData to prelude, and to change Data.Map to support it :P
09:02:12 <mmorrow> (for non-sucky instances of things)
09:03:09 <fasta> A lazy language without deep force kind of sucks, doesn't it?
09:03:14 <quicksilver> If you're trying to fix the data.map problem possibly a better solution is to allow you to provide a "Strategy v" when constructing a new map.
09:03:34 <quicksilver> then you can choose exactly how much forcing you want on values.
09:03:44 <mmorrow> hmm, vacuum is essentially a "deepSeq" forall a.. maybe a version that just returns () would be useful for stuff like this
09:04:24 <quicksilver> fasta: in a sense the reason there isn't is that it only makes sense for certain data types - e.g. not functions or some higher-order types.
09:04:29 <quicksilver> fasta: still, I agree with you.
09:04:51 <mmorrow> but functions can still be thunks
09:04:57 <mmorrow> not yet evaluated to a function
09:05:35 <mmorrow> , closureType $! (foldr (.) id (replicate 42 show))
09:05:40 <lunabot>  PAP
09:05:54 <mmorrow> i guess the seq was enough there..
09:06:01 <mmorrow> err
09:06:13 <mmorrow> no, that should be a FUN
09:06:23 <mmorrow> if it really was fully eval (i think)
09:06:46 <quicksilver> mmorrow: yes, but depending what you think the *semantics* of deepseq is supposed to be, that's not the point
09:06:46 <mmorrow> hmm
09:07:03 <quicksilver> mmorrow: I can hide arbitrary not yet evaluated things behind a lambda
09:07:07 <quicksilver> (e.g. behind \() -> )
09:07:18 <mmorrow> well sure, because that's a FUN
09:07:24 <quicksilver> and complex functional encodings of problems something do use functions as part of their internal structure
09:07:33 <quicksilver> that's supposed to be semantically irrelevant
09:07:36 <quicksilver> just an implementation decision
09:07:44 <quicksilver> ...but deepSeq simply doens't work, on such things.
09:08:22 <quicksilver> "() -> a" and "a" are isomorphic types, denotationally, but deepSeq simply can't work on the first.
09:08:27 <mmorrow> i'm not sure though, because everyone would agree that (1+1) isn't fully evaluated, but (foo . bar) is?
09:08:35 <quicksilver> nope.
09:08:40 <quicksilver> it's not that simple in practice.
09:08:46 <quicksilver> consider a deeply nested, complex ADT
09:08:52 <quicksilver> which happens to use some function types in some parts of the structure
09:09:00 <quicksilver> but it's still modelling something perfectly concrete
09:09:07 <quicksilver> using funciton types there was just an implementation choice.
09:09:18 <quicksilver> but it becomes an issue that deepSeq gets stuck there.
09:09:28 <mmorrow> sure, but in my mind deepSeq means "eliminate all non-evaluated thunks, and evaluate them to their terminal value"
09:09:39 <mmorrow> where the "terminal value" for functions is a FUN
09:09:42 <quicksilver> you think like a man who understands GHC internals.
09:09:47 <quicksilver> I couldn't care less about GHC internals.
09:09:53 <quicksilver> I care about denotations and semantics.
09:09:58 <pikhq> Think like a C coder!
09:10:05 <fasta> Currently, I do mapM parse stuff and then call fromList on that result basically. I can remove the intermediate list, which might help.
09:10:13 <mmorrow> but a lazy language has the concept of THUNK in its semantics, no?
09:10:22 <quicksilver> consider DLists used for string concatenation, for example.
09:10:35 <quicksilver> that's a good case of a perfectly concrete data structure
09:10:41 <mmorrow> sure
09:10:46 <quicksilver> (all I'm ever going to do with them is append them and eventually apply to "")
09:10:52 <fasta> But at this moment, I am just working around implementation weaknesses, exactly what  a high-level language should not have.
09:10:55 <quicksilver> but one that deepSeq is useless on.
09:11:13 <quicksilver> whereas if I'd been using Seq Char
09:11:26 <quicksilver> which is formally isomorphic and even has similar complexities for quitea lot of operations
09:11:29 <quicksilver> it would work fine.
09:11:31 <mmorrow> well, it'd evaluate all the frozen applications of (.) at least i'd think
09:12:13 <quicksilver> I've always wondered that, actually.
09:12:18 <mmorrow> hmm
09:12:18 <quicksilver> But it's not the point I'm making right now ;)
09:12:21 <nainaide> Cale,  in "do { v <- x; <stmts> } = x >>= (\v -> do { <stmts> })" , I think "x" should be "m a" , but
09:12:28 <nainaide> :t "<;"
09:12:29 <lambdabot> [Char]
09:12:37 <nainaide> :t "<-"
09:12:39 <lambdabot> [Char]
09:12:48 <Cale> nainaide: "<-" is a two-character string
09:12:51 <quicksilver> nainaide: you are just checking the types of strings there.
09:12:59 <quicksilver> nainaide: <- is not an operator, it doesn't have a type.
09:13:01 <pikhq> :t <-
09:13:02 <quicksilver> it's special syntax.
09:13:03 <lambdabot> parse error on input `<-'
09:13:04 <Cale> nainaide: <- is a piece of syntax. It is built-in, and not a function or value.
09:13:10 <quicksilver> :t (>>=)
09:13:11 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
09:13:17 <quicksilver> >>= has a type, though.
09:13:28 <Cale> Right, (>>=) is a function
09:13:30 <nainaide> quicksilver, Cale , got it
09:13:56 <nainaide> <- is polymorphism ?
09:14:06 <Cale> <- is a piece of punctuation
09:14:17 * mmorrow reboots after a kernel upgrade
09:14:22 <Cale> It's part of the syntax of do-expressions
09:14:34 <Cale> You can perhaps think of it as a keyword, if you like.
09:14:53 <Cale> But it's like asking what's the type of ,
09:15:05 <Cale> [1,2,3,4]
09:15:07 <trofi> :t (,)
09:15:08 <lambdabot> forall a b. a -> b -> (a, b)
09:15:17 <Cale> That's a different comma ;)
09:15:32 <trofi> i know :]
09:15:32 <nainaide> Cale, I undertand. thank you
09:15:36 <Cale> [1,2,3,4] is special syntax for 1:(2:(3:(4:[])))
09:15:54 <quicksilver> Cale: if you look carefully, the tail is slightly longer and the body of the comma is about 10 microns fatter?
09:16:02 <Cale> Just like  do v <- x; f v is special syntax for x >>= \v -> f v
09:16:25 <nainaide> I see.
09:16:55 <Cale> >>= is a function which will be defined differently for each monad
09:17:32 <Cale> For the list monad, for instance, it essentially does a concatMap of the function it gets on the right, over the list it takes on the left.
09:17:43 <Cale> > [1,2,3] >>= \x -> [x,10*x]
09:17:45 <lambdabot>   [1,10,2,20,3,30]
09:18:02 <Cale> > do x <- [1,2,3]; [x,10*x]
09:18:04 <lambdabot>   [1,10,2,20,3,30]
09:18:42 <hackagebot> loli 2009.6.27 - A minimum web dev DSL in Haskell (JinjingWang)
09:19:10 <Cale> nainaide: does that make things any clearer?
09:19:21 <Cale> > concatMap (\x -> [x,10*x]) [1,2,3]
09:19:23 <lambdabot>   [1,10,2,20,3,30]
09:19:34 <nainaide> yes, clear. thank you, :)
09:20:17 <trofi> > [ x | x <- [1..], x > 5 ] -- list comprehensions have '<-' too!
09:20:18 <lambdabot>   [6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,...
09:20:33 <Cale> > do x <- [1,2,3]; y <- [4,5]; return (x,y)
09:20:35 <lambdabot>   [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
09:20:45 <Cale> > [(x,y) | x <- [1,2,3], y <- [4,5]]
09:20:47 <lambdabot>   [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
09:21:06 <Cale> List comprehensions and the monad instance for lists are closely related.
09:21:56 <Cale> The reason why it's nice that lists are a monad, same as the reason it's nice that anything is a monad, is that you get all the functions in Control.Monad for free.
09:22:03 <Cale> > sequence [[1,2,3],[4,5],[6,7,8]]
09:22:05 <lambdabot>   [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2...
09:22:18 <nainaide> Cale, I was confused just by <- in  [(x,y) | x <- [1,2,3], y <- [4,5]] compare to <- in do notaion,
09:22:27 <Cale> > replicateM 5 [0,1]
09:22:28 <lambdabot>   [[0,0,0,0,0],[0,0,0,0,1],[0,0,0,1,0],[0,0,0,1,1],[0,0,1,0,0],[0,0,1,0,1],[0...
09:22:29 <nainaide> I thout <- was  a func
09:22:37 <Cale> right, <- is not a function
09:22:43 <nainaide> I have thought <- was a func
09:23:21 <trofi> > case 1 of 1; _ -> "eh"
09:23:23 <lambdabot>   <no location info>: parse error on input `;'
09:23:29 <trofi> > case 1 of 1 in _ -> "eh"
09:23:30 <lambdabot>   <no location info>: parse error on input `in'
09:23:31 <nainaide> so, confused on types of <-, now understan
09:23:32 <Cale> > filterM (const [True,False]) [1,2,3]
09:23:33 <lambdabot>   [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
09:23:45 <Cale> neat tricks you can do with the stuff in Control.Monad :)
09:24:02 <Badger> @src filterM
09:24:03 <lambdabot> Source not found. Maybe you made a typo?
09:24:57 <Cale> filterM p [] = return []; filterM p (x:xs) = do b <- p x; ys <- filterM p xs; return (if b then (x:ys) else ys)
09:26:06 <Badger> whythankyou
09:26:41 <Cale> Basically, it's just like filter, except that instead of the condition being a function from the values in the list to Bool, it's a function to m Bool instead.
09:26:53 <Cale> In the case of the list monad, that's [Bool]
09:27:24 <Cale> and all the possible options for the truth of the condition that the function returns will be tried
09:27:29 <Cale> (which is just what the list monad does)
09:27:53 <Cale> const [True, False]  says  "regardless of the value, take the item or drop it"
09:28:24 <Cale> So  filterM (const [True, False])  says  "for each value in the list, regardless of what it is, take it or drop it"
09:28:30 <Cale> (in all possible ways)
09:28:52 <Cale> > filterM (const [True, False]) [1,2,3]
09:28:53 <lambdabot>   [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
09:29:03 <Cale> So we get all ways of selecting elements from [1,2,3]
09:29:15 <Cale> If we wanted, we could have it apply only to even elements...
09:29:32 <Cale> > filterM (\x -> if even x then [True, False] else [True]) [1,2,3]
09:29:34 <lambdabot>   [[1,2,3],[1,3]]
09:29:38 <Cale> > filterM (\x -> if even x then [True, False] else [True]) [1,2,3,4]
09:29:40 <lambdabot>   [[1,2,3,4],[1,2,3],[1,3,4],[1,3]]
09:34:52 <Cale> If instead, for instance, we used a monad of probability distributions, then the parameter to filterM would tell the probability of keeping or losing the element, and you'd get a probability distribution of the possible lists. :)
09:35:18 <Cale> In the IO monad, the condition might just ask the user if they wanted to keep the element or not
09:35:40 <Cale> and the result would be an IO action which asked the user about each element of the list
09:37:58 <BONUS> i love the filterM, foldM, etc. functions cause they really take advantage of the different semantics of each monad to achieve something different
09:38:07 <jmcarthur_work> me too
09:38:53 <jmcarthur_work> i underuse them though
09:39:14 <mmorrow> gah, i always forget that i have to build the driver for my wireless card too whenever i get a new kernel
09:39:36 <mmorrow> since fedora doesn't have it included with its kernels
09:39:38 <BONUS> yeah me too sometimes, a they're more useful than people think
09:39:49 <BONUS> also i like unfoldM
09:39:52 <Paczesiowa> what solutions to expression problem are there in haskell (besides data types a la carte and Oleg's polymorphic variants encoding) ?
09:39:57 <jmcarthur_work> @hoogle unfoldM
09:39:58 <lambdabot> No results found
09:40:16 <BONUS> it's not in hackage, i usually write it up myself
09:40:25 <jmcarthur_work> we need a package for these things
09:40:58 <BONUS> b -> (b -> m (Maybe (a,b))) -> b -> m [a]
09:41:05 <BONUS> a package for all the various M functions would be cool
09:41:15 <BONUS> like takeWhileM, dropWhileM, etc.
09:41:23 <BONUS> untilM
09:41:24 <jmcarthur_work> yes
09:41:58 <jmcarthur_work> i wish these could somehow be derived automatically from their pure counterparts
09:42:03 <quicksilver> there is more than one way to do those though.
09:42:23 <BONUS> that's true, but it seems to me like one way always stands out kind of
09:42:24 <quicksilver> depending if the condition is monadic, if the condition gets the last "value" as a parameter,e tc.
09:42:37 <Cale> Paczesiowa: hmm
09:42:40 <quicksilver> (a -> Bool), (a -> m Bool) and plain (m Bool)
09:42:59 * mmorrow finds that he wants whenM more than just when
09:43:13 <mmorrow> :: (a -> m Bool) -> m () -> m ()
09:43:35 <BONUS> whenM could work in two monads though i think
09:43:44 <mmorrow> true
09:43:54 <mux> :: (a -> m Bool) -> m b -> m () would be even better imho
09:43:54 <mmorrow> err, could it?
09:44:03 <Cale> Paczesiowa: Well, there are the two solutions at the ends of the spectrum which might be considered problematic: plain algebraic datatypes and records of functions.
09:44:10 <mmorrow> mux: yeah good point
09:44:34 <Cale> Paczesiowa: Not sure if they can be considered "solutions" as such, but they're always something to consider.
09:44:45 <BONUS> like (a -> n Bool) -> m () -> n (m ())
09:44:55 <BONUS> Monad m, Monad n =>
09:44:55 <tibbe> @pl \s -> m >>= n s
09:44:56 <lambdabot> (m >>=) . n
09:44:57 <Cale> (existential types would be lumped in with the records-of-functions approach, I suppose)
09:45:13 <Cale> (and GADTs are lumped in at the other side)
09:45:27 <mux> don't you mean polymorphic components?
09:45:43 <Cale> who me?
09:45:45 <tibbe> @pl \s' -> runIterateeT iter s >>= \r -> check (n - len) k r s'
09:45:45 <lambdabot> (runIterateeT iter s >>=) . flip (check (n - len) k)
09:45:52 <mux> yeah, for the records of functions case
09:46:03 <Cale> They might be monomorphic.
09:46:49 <mux> I mean that records containing polymorphic functions don't need existential types but polymorphic components iirc
09:47:09 <Cale> well, yeah
09:47:17 <Cale> but that's if you need polymorphic functions
09:49:31 <mmorrow> BONUS: but if the condition in the whenM is in another monad, you'd do you get at it?
09:49:47 <mmorrow> :: (a -> IO Bool) -> Maybe b -> Maybe () -- ?
09:50:07 <mmorrow> you'd need
09:50:22 <mmorrow> :: (a -> m Bool) -> n b -> m (n ())
09:50:25 <burp> can lambdabot un-listcomprehend to list monad?
09:50:45 <quicksilver> it can do something like that
09:50:54 <Cale> @undo [(x,y) | x <- [1,2,3], y <- [4,5]]
09:50:55 <lambdabot> concatMap (\ x -> concatMap (\ y -> [(x, y)]) [4, 5]) [1, 2, 3]
09:51:01 <burp> thanks
09:51:06 <Axman6> burp: @undo works... as Cale just showed -_-
09:51:06 <mmorrow> that's the naive desugaring though
09:51:13 <quicksilver> @. pl undo [(x,y) | x <- [1,2,3], y <- [4,5]]
09:51:13 <lambdabot> ([4, 5] >>=) . flip flip [] . ((:) .) . (,) =<< [1, 2, 3]
09:51:16 <mmorrow> burp: it's not actually done like that
09:51:26 <Cale> huh?
09:51:30 <quicksilver> well, in a sense it is, mmorrow.
09:51:31 <pikhq> flip flip? It's a veritable flipbook.
09:51:32 <pikhq> :)
09:51:35 <Cale> Isn't that the *actual* desugaring?
09:51:47 <quicksilver> that's the actual front-end desugaring as far as I know.
09:52:02 <quicksilver> it gets hit pretty hard by the optimiser thereafter though.
09:52:09 <mmorrow> here's the "classic" desugaring: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2260
09:52:22 <djahandarie> Man, sugar and curry... I wonder how that'd taste
09:52:44 <mmorrow> (here's the code that did that, here on TH, http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2490)
09:53:02 <mmorrow> apparently there's also a build/foldr method for list-comp desugaring, but i don't know how it works
09:53:18 <quicksilver> the one cale showed is the build/foldr version.
09:53:26 <quicksilver> concatMap inlines into build/foldr
09:53:28 <quicksilver> which fuses
09:53:29 <Cale> It seems kind of pointless for the desugaring to be so explicit...
09:53:31 <Cale> yeah
09:53:35 <quicksilver> or that's how I've always understood it.
09:53:41 <mmorrow> i took that algo from ghc's desugarer :)
09:54:05 <mmorrow> it conditionally uses that one or build/foldr apparently, based on what i don't know
09:54:05 <Cale> given that the concatMap thing should *also* be optimised properly
09:54:23 <Cale> Maybe it doesn't optimise properly and that's why they need the cheesy desugaring.
09:54:33 <mmorrow> Cale: sure, but this is the code that actually optimizes it too
09:54:49 * mmorrow tries to remember which module that's in..
09:55:04 <mmorrow> it's interesting.. lots of comments
09:55:34 <quicksilver> I had heard the story that the whole build/foldr fusion technique was specifically tuned with the precise objecting of making sure list comps compiled fairly well.
09:55:38 <tibbe> @pl \k s -> sr0 s >>= check k
09:55:38 <lambdabot> flip ((>>=) . sr0) . check
09:55:44 <mmorrow> ah, perfect
09:55:45 <quicksilver> maybe that was wrong.
09:55:46 <mmorrow> http://moonpatio.com/docs/ghc/src/DsListComp.html
09:56:12 <mmorrow> "List comprehensions may be desugared in one of two ways: ``ordinary'' (as you would expect if you read SLPJ's book) and ``with foldr/build turned on'' (if you read Gill {\em et al.}'s paper on the subject)."
09:56:28 <mmorrow> (i followed the SLPJ book and this module)
09:56:33 <Cale> It's nice how that desugaring makes the continuation so explicit though.
09:56:44 <burp> prest p = [ a | a <- [1..p-1], ([ i | i <- [1..p-1], a^i `mod` p == 1] !! 0) == p-1 ]
09:56:50 <burp> where p is prime
09:56:53 <quicksilver> the implicitation lower down in those comments, mmorrow, is that the SLPJ way is used when the fusion rules aren't in place
09:56:58 <mmorrow> i love looking at the patterns in code generated by code
09:57:07 <quicksilver> whilst the concatMap one can be used if the fusion rules are there
09:57:08 <burp> problem here is !! 0
09:57:16 <mmorrow> quicksilver: interesting.
09:57:20 <burp> because when you specify no prime there mustn't exist an element
09:57:23 <quicksilver> which suggests, to me, that the SLPJ code has been left there so that with optimisation off, things aren't totally pants.
09:57:29 <quicksilver> but I may have over-inferred.
09:57:37 <mmorrow> quicksilver: but does that module simply insert the code "concatMap ..." as the output of desugaring?
09:57:44 <burp> I'd like to have this piece "nicer"
09:57:46 * mmorrow looks
09:58:04 <Cale> prest p = [ a | a <- [1..p-1], (u:_) <- [ i | i <- [1..p-1], a^i `mod` p == 1], u == p-1]
09:58:24 <Cale> er
09:58:25 <Cale> no
09:58:39 <Cale> hmm :)
09:58:54 <mmorrow> hmm, looks like this is the literal (top-level of) output syntax for the foldr/build method:
09:58:58 <mmorrow>     mkFoldrExpr x_ty b_ty (mkLams [x, b] core_expr) (Var n_id) core_list1
09:58:58 <Cale> maybe we should just wrap it in another list
09:59:05 <Cale> prest p = [ a | a <- [1..p-1], (u:_) <- [[ i | i <- [1..p-1], a^i `mod` p == 1]], u == p-1]
09:59:13 <Cale> I think that works ;)
09:59:18 <quicksilver> mmorrow: it doesn't really. But in a sense that is a detail.
09:59:27 <quicksilver> mmorrow: if you wrote it with concatMap you should end up in the same place
09:59:31 <quicksilver> (assumign concatMap inlines properly)
09:59:34 <doserj> prest p = [ a | a <- [1..p-1], let (u:_) = [ i | i <- [1..p-1], a^i `mod` p == 1], u == p-1]
09:59:40 <Cale> let is bad
09:59:52 <Cale> because it'll bottom out on the [] case
10:00:05 <burp> yup true
10:00:08 <Paczesiowa> Cale: I don't get it, haven't you just described regular functional and OO approaches (that don't work)?
10:00:13 <Cale> I'm taking advantage of what happens when a list comprehension pattern fails to match
10:00:19 <mmorrow> quicksilver: yeah, assuming concatMap... turns into something more efficient
10:00:37 <doserj> Cale: oh, right
10:00:41 <Cale> Paczesiowa: Well, they are solutions. They're just not ideal solutions.
10:00:46 <mmorrow> hmm, i wonder what concatMap gets transformed to..
10:01:08 * mmorrow re-installs dons' ghc-core prog
10:01:13 <nainaide> is  [[1,2,3]] a monad list?
10:01:17 <quicksilver> mmorrow: foldr ((++) . f) []
10:01:24 <mauke> nainaide: what is a monad list?
10:01:25 <Cale> nainaide: A monad list?
10:01:34 <quicksilver> mmorrow: (which is in the right form for build/foldr fusion)
10:01:34 <Cale> nainaide: Lists collectively form a monad
10:01:40 <Cale> (a single monad)
10:01:45 <mmorrow> quicksilver: ahh, i see. so all set up and waiting for a `build'
10:01:48 <nainaide> a list instance of Monad
10:01:52 <quicksilver> mmorrow: right.
10:02:11 <Cale> nainaide: List (or, [] at the type level) is an instance of Monad
10:02:21 <quicksilver> mmorrow: along a similar vein, concat itself gets expanded out to "concat" forall xs. concat xs = build (\c n -> foldr (\x y -> foldr c y x) n xs)
10:02:25 <Cale> nainaide: Monads are type constructors
10:02:37 <Cale> (together with implementations of return and bind)
10:02:48 <mmorrow> quicksilver: interesting
10:03:00 <Cale> So, [1,2,3] isn't a monad, but it is a value in the list monad.
10:03:02 <Paczesiowa> Cale: are we talking about the same expression problem? how can (even not ideal) solution be a solution at all if it doesn't allow for extension in both ways?
10:03:09 <nainaide> just dont understand why sequence [1,2,3] got errors, while sequence[[1,2,3]] works
10:03:25 <mauke> nainaide: because sequence takes a list of lists
10:03:37 <nainaide> :t sequence
10:03:39 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
10:03:51 <nainaide> [m a] is a list of list?
10:04:01 <mauke> well, it takes a list of 'm a' where m is a monad
10:04:10 <mauke> lists fit that pattern
10:04:28 <Cale> nainaide: sequence takes a list of computations in some monad, and produces a computation of lists.
10:04:31 <mauke> [[] a], so to speak
10:04:35 <mauke> which is the same as [[a]]
10:04:39 <Cale> nainaide: in the list monad's case
10:04:50 <Cale> [m a] = [[a]]
10:05:14 <Cale> Paczesiowa: Well, I suppose it does depend on what you mean by 'allow for'
10:05:15 <nainaide> Cale, yes, this what I want to confirm
10:06:16 <burp>  (u:_) <- [[ i | i <- [1..p-1], a^i `mod` p == 1]] <- doesn't this put the whole list in the outer list into u?
10:06:24 <burp> how can you compre u with an integer then?
10:06:42 <burp> ah "<-" list monad
10:07:12 * mmorrow runs ghc-core on his generated fft code
10:07:22 <mmorrow> this should be interesting (lot's of case-of-case)
10:07:23 <Cale> burp: yeah, it means "pick an element from this one element list and match it against (u:_)
10:07:24 <Cale> "
10:07:38 <tibbe> mmorrow: fft?
10:07:49 <mmorrow> tibbe: fast fourier transform
10:07:55 <tibbe> mmorrow: ah
10:08:04 <mmorrow> tibbe: http://moonpatio.com/repos/hsfft/
10:08:21 <mmorrow> tibbe: the generated sample being http://moonpatio.com/repos/hsfft/fft_upto_128.hs
10:08:41 <mmorrow> (4.2 seconds to 0.8 seconds for 10,000 length-128 vectors)
10:08:55 <mmorrow> (original vs. fully-unrolled)
10:09:03 <tibbe> mmorrow: woa, lots of code
10:09:07 <mmorrow> heh
10:09:13 <tibbe> mmorrow: you're experimenting with loop unrolling?
10:09:32 <Cale> Paczesiowa: But a solution more along the lines of what you're looking for is possibly offered by the various generics libraries.
10:09:33 <mmorrow> beyond 256, compilation takes forever, so i've gotta figure out a nice way to control unrolling with options
10:09:36 <mmorrow> tibbe: yes
10:09:50 <tibbe> nice
10:10:08 * tibbe is hacking on iteratee stuff
10:10:26 <mmorrow> tibbe: nice. congrats on releasing hyena btw :)
10:10:31 <tibbe> mmorrow: thanks
10:10:42 <tibbe> mmorrow: I didn't plan to release that old version but so many people asked :)
10:10:50 <tibbe> mmorrow: I got some nice bug fixes for free
10:11:01 <mmorrow> :)
10:11:18 <tibbe> mmorrow: I'm almost done with my internal refactoring but some parts are seriously challenging thinking wise
10:11:30 <tibbe> probably because it's oleg stuff ;)
10:11:36 <mmorrow> tibbe: hehe, yeah totally
10:11:53 <tibbe> I literally have one difficult function to write left
10:12:04 <tibbe> it implements http chunked encoding
10:12:18 <mmorrow> ooh, fun (maybe) ;)
10:12:20 <tibbe> but there's a monad transformer and CPS transforms involved
10:12:25 <tibbe> which makes my head hurt
10:12:29 <mmorrow> epic more likely
10:12:32 <mmorrow> heh
10:13:11 <tibbe> with 2 helper functions it's literary 33 lines of code
10:13:25 <tibbe> only in haskell is it difficult to write something that's only 33 lines
10:13:33 <tibbe> on the other hand those 33 lines pack quite a punch
10:13:54 <tibbe> I will have pipelining, chunked encoding, keep-alive connections and other goodies
10:16:06 <mmorrow> ooh, sweet.
10:17:21 <Apocalisp> tibbe: You should try writing those 33 lines in Java. That will hurt your head.
10:17:46 <Apocalisp> (rhetorical "should")
10:18:38 <burp> http://paste.railsbox.eu/show/zHhl5pqv2wc78nFbk8Ct/ <- why does prest return (wrong result) [3,19,28] and prest2 (correct result) [3,11,12,13,17,21,22,24]
10:20:18 <Cale> burp: probably prest2 is using Integer
10:20:33 <Cale> Int is only machine ints, and is limited in size
10:21:00 <burp> hm, I don't see why it should reach integer limit
10:21:15 <burp> 30^30 should be maximum
10:21:18 <Cale> a^i `mod` p isn't really a great algorithm for what it computes, since you could instead do reduction mod p during the exponentiation, and keep the numbers small
10:21:35 <Cale> > 30^30 :: Integer
10:21:37 <lambdabot>   205891132094649000000000000000000000000000000
10:21:40 <Cale> > 30^30 :: Int
10:21:42 <lambdabot>   2565992168703393792
10:21:44 <burp> uh
10:21:47 <burp> true
10:21:55 <tibbe> Apocalisp: yes most likely
10:22:09 <tibbe> Apocalisp: using iteratees it possible to while staying sane
10:22:27 <tibbe> Apocalisp: since the result composes nicely
10:22:46 <Cale> Things like this are why I absolutely hate Int
10:22:47 <Apocalisp> I have to look at iteratees more closely
10:23:15 <Cale> Int should never be the default for anything.
10:23:33 <quicksilver> Cale: or, it could at least generate overflow exceptions somehow
10:23:46 <burp> forgot how small Int is
10:23:50 <quicksilver> Cale: it's not as if the underlying CPUs we all use don't have flags for integer overflow.
10:23:58 <Cale> yeah
10:24:11 <quicksilver> but for some reason it's verboten for any computer language to give access to those
10:24:38 <quicksilver> I always find it boggling that C - which some people prefer because it's close to the asm - doesn't have the tools needed to build an efficient 64 bit type out of a 32bit one.
10:24:42 <quicksilver> even though the CPU does.
10:24:54 <quicksilver> (the CPU = just about every CPU design ever)
10:25:44 <burp> o0.. you use "verboten" in english?
10:25:55 <jmcarthur_work> > 30^30 + 1 :: Integer
10:25:56 <lambdabot>   205891132094649000000000000000000000000000001
10:26:14 <jmcarthur_work> > 32^32 :: Integer
10:26:15 <lambdabot>   1461501637330902918203684832716283019655932542976
10:26:22 <jmcarthur_work> > 32^32 + 1:: Integer
10:26:23 <lambdabot>   1461501637330902918203684832716283019655932542977
10:26:42 <pikhq> burp: Yes; it's quite normal in English.
10:27:15 <quicksilver> burp: it's a moderately common loan word yes.
10:27:29 <Cale> fsvo normal.
10:28:27 <pikhq> "Verboten" is not verboten.
10:29:04 <Twey> burp: It's more common in technical circles than elsewhere.
10:29:09 <burp> ok ;)
10:39:04 <hackagebot> ip6addr 0.1 - Command line tool that filters parsed IPv6 Addresses against RFC 4291 (MichelBoucey)
10:46:42 <tibbe> @pl joinIM (runIterateeT iter s1 >>= checkIfDone liftShift)
10:46:42 <lambdabot> joinIM (checkIfDone liftShift =<< runIterateeT iter s1)
10:46:46 <mmorrow> does anyone see an obvious simplification of this? also, how immediately clear is it what the point is of these datatypes? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6274
10:47:57 <mmorrow> (the point being to have ==> let T = "a graph of blocks, which either contains some base structure (which is fixed), or they contain a T")
10:50:02 <mmorrow> (i think this is the minimal presentation of this, but i have a slight feeling there might be a simplification)
10:51:53 <mmorrow> * " which either contains some base structure ..." ===> "where each block either contains..."
10:52:44 <tibbe> :t Control.Monad.join
10:52:46 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
10:53:12 <mnislaih> any teams for the ICFP contest looking for members ?
11:00:49 <jmcarthur_work> aaaand icfpcontest.org goes down
11:00:56 <tommd> I just noticed
11:02:42 <roconnor> quick someone post a mirror
11:02:50 <Cale> Heh, it would be funny if someone had decided to download the contest materials for themselves and immediately DOS the server.
11:03:35 <mnislaih> mirror anyone ?
11:03:44 <Cale> I'm getting through now...
11:03:52 <jmcarthur_work> did anybody even get a chance to see it?
11:03:53 <jmcarthur_work> ah
11:04:07 <mnislaih> someone grab the task and mirror it somewhere
11:04:19 <mnislaih> jmcarthur_work: I didn'
11:04:44 <Cale> er, except the specs link is a 404
11:05:03 <lpsmith> lol, fun stuff
11:05:09 <doserj> there are some links posted in #icfp-contest
11:05:10 <roconnor> oh I have to pick a team first
11:05:53 <roconnor> damn it, other teams are ahead of me
11:07:35 * mnislaih is looking for a team
11:09:08 * pikhq will do that next year. Learning Haskell now.
11:09:27 * twanvl is thinking about working alone
11:09:29 <pikhq> And I may do next year's in Tcl just to be contrary. :P
11:10:21 <roconnor> maybe I should go solo again this year
11:10:49 * maltem thinks about inquiring if I may hand in ICFP contest code instead of those 7 worksheets
11:15:07 <BONUS> http://syntaxi.net/mark/6bacfbdadfce77fbaa1e147bfe00e07d.pdf
11:15:15 <BONUS> the icfp task, if anyone's interested
11:15:36 <sjanssen> does it look fun this year?
11:15:51 <BONUS> can't tell yet hmm
11:15:58 <BONUS> looks more fun than last year's
11:16:08 <jmcarthur_work> build a vm and write some binaries for it with some math
11:16:56 <elliottt> conal: when you've got a second, i have a reactive question for you
11:20:43 <lpsmith> I'm still getting 404 for the ICFP programming contest specs
11:21:23 <sjanssen> lpsmith: take BONUS's liink
11:21:23 <tehgeekmeister> has anyone used ghc on prgmr.com?
11:22:01 <tehgeekmeister> i couldn't get it to run on slicehost, so i'm hesitant to start up another account elsewhere without knowing ghc runs there.
11:23:37 <byorgey> jmcarthur_work: no, it doesn't involve writing binaries for the VM.  the binaries that run on the VM are provided.
11:23:50 <sm> tehgeekmeister: I use ghc on slicehost all the time, why ever not ?
11:23:52 <byorgey> we have to write programs that interact with the provided binaries running on the VM.
11:23:53 <jmcarthur_work> oh i just skimmed it
11:23:59 <jmcarthur_work> i see
11:26:21 <roconnor> is Double the double precision floating point they talk about?
11:26:48 <sjanssen> roconnor: yes
11:27:11 <roconnor> I thought intel does extra precision in the registers?
11:27:21 <roconnor> or something crazy like that
11:27:45 <quicksilver> the x87 FPU has 80-bit floats
11:27:56 <quicksilver> modern compilers tend to avoid the x87 stuff
11:28:04 <quicksilver> (although GHC still uses it for ia32 code)
11:28:23 <quicksilver> they truncate to 64bit on memory store, though.
11:28:26 <sjanssen> roconnor: use -fnoexcess-precision
11:28:35 <sjanssen> or whatever it is
11:28:42 <roconnor> ok
11:28:50 <sjanssen> (excess precision might be off by default)
11:28:56 <quicksilver> on x86-64, GHC generates mmx2 code anyway
11:29:01 <quicksilver> and those registers are 64 bit.
11:29:13 <roconnor> I don't have a 64 bit CPU
11:29:29 * roconnor darcs inits
11:30:02 <tehgeekmeister> sm: i couldn't get it to do anything, even simple arithmetic; which os/kernel/xen version are you on, do you know?
11:30:23 <tehgeekmeister> sm: i would prefer to use them, and if i know what does work then i could just request an instance with those specs
11:30:46 <sm> tehgeekmeister: 2.6.18-xen #1 SMP Tue Feb 12 06:40:50 UTC 2008 x86_64 GNU/Linux, ubuntu intrepid
11:31:05 <tehgeekmeister> sm: gracias
11:31:16 <sm> does ghci work ?
11:31:36 <tehgeekmeister> sm: no
11:31:56 <sm> what happens ?
11:32:01 <tehgeekmeister> sm: this was a while ago i tried it, but then i contacted slicehost support to see if they could check to see if it was working now, they tried, and it didn't
11:32:37 <tehgeekmeister> sm: unfortunately it's been long enough i don't remember the exact error, it tries to access some memory it doesn't have rights to and crashes.
11:32:58 <tehgeekmeister> sm: when i traced it down then it was the result of xen not respecting a compiler flag that ghc itself is compiled with
11:33:04 <sm> weird
11:33:11 <tehgeekmeister> but for the life of me i can't remember which flag
11:33:14 <sm> maybe worth trying again with latest haskell platform
11:33:22 <tehgeekmeister> good idea
11:34:49 <sm> or more precisely, with latest ghc 6.10.3 binaries, I believe that's what I use
11:35:06 <sm> unless I'm confused. Good luck
11:39:02 * gwern looks at the icfp problem
11:39:09 <gwern> oh god it involves calculus
11:39:12 <gwern> WHY
11:39:30 <lpsmith> hah,  I'm a bit rusty on calculus,  but I liked it back in the day
11:40:02 <soupdragon> @go ICFP
11:40:04 <lambdabot> http://www.icfpconference.org/
11:40:04 <lambdabot> Title: The ACM SIGPLAN International Conference on Functional Programming (ICFP)
11:40:13 <lpsmith> I still remember almost all of Calc I and II, but only the first half of Calc III
11:40:27 <soupdragon> I got an A in calculus :P
11:40:29 <soupdragon> (today)
11:40:36 <soupdragon> I just got results
11:40:39 <gwern> soupdragon: you really want the icfpcontest.org url
11:40:42 <soupdragon> it's like the only class I passed :P
11:40:50 <soupdragon> I'm trying to find it
11:46:04 <Toxaris> whats the icfp contest discussion channel?
11:46:09 <maltem> Thinking of vacation...
11:46:11 <maltem> :(
11:47:16 <burp> how would you efficiently check a list for at least one occurance of an item?
11:47:27 <tommd> elem
11:47:28 <mauke> elem
11:47:37 <burp> thanks :D
11:47:37 <soupdragon> gwern bloody hell! There's no way I'm going to even attempt that
11:47:43 <mauke> burp: how would you do it inefficiently?
11:47:54 <tommd> elem `seq` elem
11:47:55 <kmatlage> Toxaris: #icfp-contest
11:48:00 <burp> length $ filter (==elem)
11:48:02 <burp> kind of this one ;)
11:48:03 <bavardage> mauke: check everything three times just to make sure :D
11:48:06 <Toxaris> kmatlage: thanks!
11:48:13 <mauke> burp: ah, I see
11:48:17 <gwern> mauke: randomly check the nth place for the item; after a few million tries, assume that every place has been checked :)
11:48:29 <Twey> element `elemIndices` list >= 1
11:48:30 <Twey> :-P
11:48:33 <Twey> gwern: Hahaha
11:48:34 <Twey> Nice
11:48:37 <gwern> soupdragon: actually, the virtual machine itself looks pretty brutal, to say nothing of the calculus
11:49:03 <mauke> > genericLength (filter (== 999) [0 ..]) > (0 :: Natural)
11:49:04 <lambdabot>   True
11:49:20 <soupdragon> ICFP is always about VMs istn't it
11:49:30 <burp> mauke, that#s what I wanted to do ;)
11:49:30 <ikegami__> hehe
11:50:16 <mmorrow> lpsmith: this is interesting, i've always associated that cps-state monad with a flattened StateT Cont + the foralled result, and then read it's iso to ContT Reader.. so checking this:
11:50:20 <mmorrow> @unmtl StateT s (Cont o) a
11:50:20 <lambdabot> s -> (a -> s -> o) -> o
11:50:25 <mmorrow> @unmtl ContT o (Reader r) a
11:50:26 <lambdabot> (a -> r -> o) -> r -> o
11:50:37 <mmorrow> interesting
11:51:26 <yakov> hey
11:52:59 <maltem> I always thought an adjacency list was a list of edges, i.e. a list of pairs of nodes... Turns out there's another meaning of adjacency list?
11:53:49 <maltem> Namely, for each node, a list of successors
11:53:51 <mmorrow> maltem: it's a list of (a,[a])
11:53:53 <mmorrow> yeah
11:54:10 <maltem> oh ok
11:56:53 <mmorrow> @type foldl' (\m (a,b) -> M.insertWith' S.union a (S.singleton b) m) mempty
11:56:55 <lambdabot> forall t a. (Ord a, Ord t) => [(t, a)] -> M.Map t (S.Set a)
11:57:24 <mmorrow> @type M.toList . fmap S.toList . foldl' (\m (a,b) -> M.insertWith' S.union a (S.singleton b) m) mempty
11:57:26 <lambdabot> forall k a. (Ord a, Ord k) => [(k, a)] -> [(k, [a])]
11:58:37 <mmorrow> this one's really handy:
11:59:14 <lpsmith> mmorrow:  yes,  the forall'ed result is quite a tradeoff...   most of the standard control operators don't work!  :-)
11:59:27 <mmorrow> @type flip M.foldWithKey mempty (\i a m -> foldl' (\m p -> M.insertWith' mappend p (S.singleton i,mempty) m) (M.insertWith' mappend i (mempty,a) m) (S.toList a))
11:59:28 <lambdabot> forall k. (Ord k) => M.Map k (S.Set k) -> M.Map k (S.Set k, S.Set k)
11:59:54 <mmorrow> lpsmith: heh, yeah i tried for a while once to get callCC for cps-state, ending in the inevitable
12:00:21 <mmorrow> (that being, graph -> Map node (preds,succs))
12:00:59 <BONUS> hehe how do you guys like my edwardk techno-babble in the comment here http://www.b-list.org/weblog/2009/jun/26/fun-little-bug/
12:01:37 <Cale> haha
12:01:51 <mmorrow> lpsmith: i've also tried briefly to retain to ability to return results incrementally, and yeah that totally makes sense that the forall'ed result disallows this since you need mapCont for it
12:02:05 <BONUS> it's because the blog post said that haskell guys shouldn't talk until our documentation stops looking like star trek babble
12:03:09 <mmorrow> BONUS: haha, "the whole ship apart!"
12:04:00 <BONUS> damnit when is edwardk gonna write a book
12:04:16 <opqdonut> ?
12:04:44 <sm> BONUS: good job :)
12:04:52 <BONUS> we're kind of always asking edwardk to write a book about CT and how it pertains to haskell
12:04:55 <BONUS> haha
12:05:27 <hackagebot> ArrayRef 0.1.3.1 - Unboxed references, dynamic arrays and more (GwernBranwen)
12:08:51 <Cale> I wonder if the connection between CT and Haskell could really fill a book... I suppose so.
12:09:20 <Cale> Seems like the web is more appropriate for that sort of thing though :)
12:09:27 <BONUS> hmm yeah maybe
12:09:45 <Cale> If you already know CT and you already know Haskell, it's not so bad :)
12:09:49 <lpsmith> mmorrow:  I believe that to be the case, but why isn't there another clever way to return results incrementally out of a CPS monad without using mapCont?
12:10:32 <BONUS> i am yet to find time to read that CT book, hehe. so much interesting stuff to do
12:10:50 <Cale> Did I give you Awodey's book?
12:10:55 <BONUS> yup
12:11:17 <BONUS> gonna give it a read once i finish lyah
12:11:23 <lpsmith> see,  I know Haskell, but I don't know much CT
12:11:50 <BONUS> do universities usually do CT classes?
12:12:03 <lpsmith> Depends on the uni
12:12:07 <Cale> BONUS: At the graduate level, usually.
12:12:22 <Cale> It's a bit uncommon in undergrad, I think.
12:12:44 <BONUS> ah. gonna snoop around and see if they do have classes here i'll just show up
12:12:52 <Cale> Though, actually, there was a fair bit of category theory spread throughout the courses I took
12:12:57 <lpsmith> And there are some subjects in math that are rarely taught,  but everybody is expected to know
12:13:11 <lpsmith> I've been told by a few people that calculus on manifolds is one such subject
12:13:11 <BONUS> like which
12:13:15 <BONUS> oh
12:13:16 <BONUS> haha
12:13:17 <Cale> Yeah, the basics of category theory are one of those
12:13:29 <hackagebot> hslogger-template 1.0.0 - Automatic generation of hslogger functions (BrianLewis)
12:13:30 <Cale> also, basic order theory
12:13:33 <mmorrow> lpsmith: ah, i've also recently gotten an mfix of cps-state that works:
12:13:36 <opqdonut> yes, calculus on manifolds irks me too
12:13:38 <mmorrow> instance MonadFix (S s) where
12:13:38 <mmorrow>   mfix f = S (\k s -> let (a,s') = unS (f a) (,) s in k a s')
12:13:44 <Cale> lattices start showing up, and you're just expected to pick it up :)
12:13:48 <opqdonut> luckily we have a course on differential geometry coming up
12:13:56 <Cale> http://cale.yi.org/share/Category%20Theory%20-%20S.%20Awodey%20(Clarendon,%202006)%20WW.pdf
12:14:02 <opqdonut> penrose's road to reality is a good summary on the subject also
12:14:07 <Cale> for lpsmith :)
12:14:51 <Cale> The nice thing about that book is that it is reasonably self-contained.
12:15:24 <lpsmith> cale:  that links 404'd
12:15:29 <Cale> oh?
12:15:29 <Cale> hmm
12:15:30 <mmorrow> (and for the transformer version):
12:15:31 <mmorrow> mfix f = S (\k s -> uncurry k =<< mfix (\ ~(a,_) -> unS (f a) (\a s -> return (a,s)) s))
12:15:50 <Cale> lpsmith: did you copy/paste the whole link?
12:15:51 <mmorrow> (without the lazy ~(a,_), you get <<loop>>)
12:16:09 <Cale> lpsmith: there's an ( in it, which throws XChat off here...
12:16:25 <BONUS> yeah, some programs stop parsing urls at parens
12:16:31 <BONUS> which they probably shouldn't
12:16:59 <lpsmith> bonus, cale:  yeah,  xchat cut me off at the parens by just clicking on it
12:18:24 <burp> and is there something in a standard library that searches for the first occurance of an element in a list and returns the position?
12:18:33 <mmorrow> @type find
12:18:35 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
12:18:37 <mmorrow> oh, pos
12:18:42 <mmorrow> @type elemIndex
12:18:44 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe Int
12:18:56 <burp> @hoogle elemIndex
12:18:57 <lambdabot> Data.ByteString elemIndex :: Word8 -> ByteString -> Maybe Int
12:18:57 <lambdabot> Data.List elemIndex :: Eq a => a -> [a] -> Maybe Int
12:18:57 <lambdabot> Data.ByteString.Char8 elemIndex :: Char -> ByteString -> Maybe Int
12:19:01 <burp> thanks ;)
12:19:03 <mmorrow> np
12:19:30 <Cale> good exercise: use find to implement elemIndex
12:19:51 <mmorrow> (although calling it more than once on the same list is in the worst case more expensive than writing your own explicit traversal)
12:20:32 <lpsmith> mmorrow:  I'm thinking there is something wrong with your mfix definition... I'll have to look at it
12:20:36 <mmorrow> well, actually it's in any case more expensive..
12:20:44 <mmorrow> lpsmith: yeah, i'm not sure about it
12:20:53 <mmorrow> (about either one that is)
12:20:59 <mmorrow> i can't think of a use for it :)
12:21:03 <mmorrow> (to test it)
12:21:03 <lpsmith> There is reason to  believe that there isn't an mfix on continuation-based monads
12:21:20 <mmorrow> lpsmith: reading that sentence prompted me to give my defs :)
12:21:57 <mmorrow> well, i'm not sure what e.g. this means (wrt "works")
12:21:59 <mmorrow> ghci> runS (mfix (\a -> modify (++[a]))) [()]
12:21:59 <mmorrow> ((),[(),()])
12:22:27 <mmorrow> oh wait, that doesn't say anything
12:22:29 <mmorrow> hmm
12:22:37 <Cale> seems right...
12:22:51 <uzytkownik> What's wrong with "instance (Error e, MonadError e m) => MonadError e (NntpT m) where"? I try to chain monads...
12:23:11 <mmorrow> the `a' is what's fed-back though, so does only modifying the state count as showing that "it works" ?
12:23:27 * mmorrow tries to think of ways to test this mfix
12:23:43 <Cale> mmorrow: eh? It's the result of modify which is fed back...
12:23:51 <mmorrow> ah, right
12:24:05 <Cale> which is, of course, ()
12:24:09 <mmorrow> mfix f = S (\k s -> let (a,s') = unS (f a) (,) s in k a s')
12:24:15 <mmorrow> ah yeah, true. ok.
12:24:26 * mmorrow is confusing himself here
12:24:48 <lpsmith> mmorrow:  have you read Levent Erkok's Ph.D. thesis?
12:24:55 <mmorrow> lpsmith: i haven't
12:25:01 <Cale> runState (mfix (\a -> modify (++a) >> get)) [()]
12:25:13 <Cale> more interesting :)
12:25:13 <roconnor> @instances monadFix
12:25:14 <lambdabot> Couldn't find class `monadFix'. Try @instances-importing
12:25:17 <lpsmith> It's not easy going,  I need to spend more time with it,  but it's worth taking a look at if you are interested in mfix :-)
12:25:19 <roconnor> @instances MonadFix
12:25:20 <lambdabot> ((->) r), Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
12:25:46 <burp> @src elemIndex
12:25:46 <lambdabot> elemIndex x     = findIndex (x==)
12:25:53 <mmorrow> just found it
12:25:54 <burp> @src findIndex
12:25:55 <mmorrow> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.15.1543
12:25:55 <lambdabot> findIndex p     = listToMaybe . findIndices p
12:26:25 <lpsmith> Actually,  I have an mfix-like construct I call "mfixish" that works with fully delimited continuations.
12:26:34 <lpsmith> but not the MTL's continuations
12:27:13 <Cale> lpsmith: what's its type?
12:27:25 <mmorrow> hmm, i think mfix for that S does "work", but how it relates to "mfix on cont-based monads" i'm not sure
12:27:54 <mmorrow> (because that mfix on S is the direct translation of mfix for State)
12:28:30 <mmorrow> wait, does State even have an mfix instance in mtl?
12:28:34 <Cale> yes
12:28:41 <mmorrow> ah, ok good :)
12:28:48 <Cale> Does Cont?
12:28:53 <mmorrow> no iirc
12:29:06 <Cale> yeah, seems not
12:29:16 <mmorrow> well, i'd assume not since lpsmith says it's believed non-existent ;)
12:29:24 <Cale> hmm
12:29:31 <Cale> I would have guessed that it does exist.
12:29:42 <Cale> but it would have been a guess ;)
12:31:14 <mmorrow> the problem is there's nowhere to get the arg to the function passed to mfix from
12:31:27 <lpsmith> cale:  its type?  lemme check,  something like mfixish :: a -> Cont a b -> Cont a b
12:31:48 <mmorrow> @type let mfix f = join (Cont (\k -> runCont (f undefined) k))
12:31:50 <lambdabot> on the commandline:
12:31:50 <lambdabot>     Warning: -fno-th is deprecated: use -XNoTemplateHaskell or pragma {-# LANGUAGE NoTemplateHaskell#-} instead
12:31:50 <lambdabot> <no location info>:
12:31:53 <mmorrow> @type let mfix f = join (Cont (\k -> runCont (f undefined) k)) in mfix
12:31:54 <lpsmith> err,  mfixish :: (a -> Cont a b) -> Cont a b
12:31:54 <lambdabot> forall a r a1. (a -> Cont r (Cont r a1)) -> Cont r a1
12:31:58 <mmorrow> goo
12:32:16 <mmorrow> @type let mfix f = (Cont (\k -> runCont (f undefined) k)) in mfix
12:32:18 <lambdabot> forall a r a1. (a -> Cont r a1) -> Cont r a1
12:32:56 <Cale> oh, I see why it might be hard.
12:33:23 <Cale> mfix sort of has the wrong type ;)
12:34:07 <mmorrow> @type let mfix f = Cont (\k -> let a = flip runCont k (Cont (\k -> runCont (f a) k)) in a) in mfix
12:34:09 <lambdabot> forall r a. (r -> Cont r a) -> Cont r a
12:34:10 <mmorrow> !!
12:34:18 <mmorrow> (???)
12:34:35 <Cale> that is the wrong type for mfix
12:34:41 <mmorrow> grr
12:34:43 <mmorrow> heh
12:34:48 <lpsmith> mmorrow:  yeah, I think that's my definition for mfixish
12:35:01 <lpsmith> or something close
12:35:15 <mmorrow> hmm
12:35:16 <lpsmith> It might work for normal continuations
12:35:35 <lpsmith> but if you put CorecQW,  the mfixish contruct doesn't work without moving to fully delimited continuations
12:36:17 <lpsmith> :t \f -> Cont (\k -> let a = runCont (f a) k  in a)
12:36:18 <lambdabot> forall a r. (r -> Cont r a) -> Cont r a
12:36:21 <lpsmith> that's my definition
12:37:24 <roconnor> @hoogle <$>
12:37:24 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
12:37:31 <lpsmith> hmm, you might be able to rewrite my runCorecQ and friends using mfixish
12:37:42 <mmorrow> lpsmith: here's an "amusing" paste thread on a delimited continuations "implem" ;) http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1341
12:38:17 <mmorrow> (that is only typesafe because if you manage to sneak one through, you get an exception rather than a segfault ;)
12:40:29 <lpsmith> heh, continuations still make my head hurt ;-)
12:41:01 <Cale> With  data Cont a = Cont { runCont :: forall r. (a -> r) -> r }, I think it would be doable.
12:41:49 <lpsmith> what would be doable,  making people's heads hurt?
12:41:56 <Cale> because then you have a way to get back the 'a' for the next iteration
12:42:32 <mmorrow> Cale: oh?
12:42:37 <lpsmith> or you mean, defining an mfix?
12:42:41 * mmorrow wants to see this
12:42:53 <Cale> I'll give it a shot
12:42:55 <mmorrow> lpsmith: heh
12:43:25 <lpsmith> I have my doubts... but I'm a skeptical kind of guy :-)
12:45:26 <mmorrow> lpsmith: oh nice, that mfix thesis looks interesting
12:46:30 * Heffalump wonders if anyone has used mfix for anything
12:46:57 <lpsmith> Heffalump:  I have
12:47:28 <Cale> well, this looks a bit cheesy...
12:47:30 <Cale> mfix :: (a -> Cont a) -> Cont a
12:47:30 <Cale> mfix f = x where x = f (runCont x id)
12:47:36 <Cale> but it typechecks, anyway
12:47:41 <lpsmith> hmm
12:48:12 <lpsmith> doesn't mmorrow's definitions typecheck?
12:48:25 <Cale> lpsmith: which?
12:48:34 <lpsmith> the mfix ones above
12:48:44 <lpsmith> I suppose we should start an hpaste for all this
12:48:45 <Cale> lpsmith: they all had an r in the wrong place
12:48:49 <lpsmith> oh
12:48:50 <mmorrow> for S or Cont?
12:48:53 <lpsmith> S
12:48:56 <mmorrow> yeah, the Cont ones did
12:48:59 <mmorrow> oh, S works
12:49:03 <lpsmith> hmm
12:49:05 <Cale> S is what?
12:49:07 <Cale> State?
12:49:09 <lpsmith> yeah
12:49:18 <lpsmith> mmorrows CPS'ed state monad
12:49:18 <Cale> mfix for State is easy enough
12:49:24 <Cale> ah
12:50:56 <Cale> The difference between that Cont and the mtl one is that from my Cont, you can get back v from return v
12:51:02 <mmorrow> Cale, lpsmith: here are the two S's http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2885#a2885
12:51:27 <Cale> (polymorphically)
12:51:34 <mmorrow> (the second could be s/IO/(MonadFix m)=>m/, but that's the code i already have laying around
12:52:03 <Cale> Whereas recovering 5 from (return 5) in Cont Bool is tricky :)
12:52:50 <Cale> (and involves using properties of Integer)
12:53:03 <mmorrow> you can just use id
12:53:29 <mmorrow> oh, wait
12:53:30 <Cale> @let x :: Cont Bool Integer; x = return 5
12:53:32 <lambdabot>  Defined.
12:53:40 <Cale> > runCont x id
12:53:41 <mmorrow> what type are we working with here
12:53:42 <lambdabot>   Ambiguous occurrence `x'
12:53:42 <lambdabot>  It could refer to either `L.x', defined at <local...
12:53:46 <Cale> oh, boo
12:53:49 <Cale> @undef
12:53:56 <Cale> @let foo :: Cont Bool Integer; foo = return 5
12:53:58 <lambdabot>  Defined.
12:54:00 <Cale> > runCont x id
12:54:02 <lambdabot>   Couldn't match expected type `Control.Monad.Cont.Cont r a'
12:54:03 <Cale> > runCont foo id
12:54:05 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
12:54:07 <Cale> right
12:54:13 <Cale> there's the error I'm looking for :)
12:54:26 <mmorrow> i thought we we're doing C a = (forall o. (a -> o) -> o)
12:54:29 <Cale> > runCont foo (== 5)
12:54:31 <lambdabot>   True
12:54:46 <mmorrow> *then* you could use id ;)
12:54:55 <Cale> mmorrow: yeah, I'm saying that's the difference between the Cont I wrote mfix for and the mtl one
12:55:08 <mmorrow> ah
12:55:28 <mmorrow> ahh, i see you that comment how
12:55:36 <mmorrow> s/how/now/
12:57:26 <Cale> With the mtl Cont, you can't just runCont with id to recover in order to apply f again
12:58:28 <mmorrow> yeah, without fixing the return type that is
12:58:31 <Heffalump> lpsmith: what?
12:59:14 <Cale> Yeah, so we could have  mfix :: (a -> Cont a a) -> Cont a a
13:01:28 <mmorrow> newtype a :-> b = F (a,a->b); newtype Cont o a = C ((a :-> o) -> o); ... ;)
13:01:38 <lpsmith> Heffalump:  queues, for one :-)
13:01:54 <lpsmith> Heffalump:  IIRC,  lava and/or hawk use mfix
13:02:34 <lpsmith> mmorrow:  well,  your mfix passes a simple smoke test.
13:02:41 <mmorrow> yay!
13:02:56 * lpsmith goes off to read "Value Recursion in Monadic Computations" a bit more...
13:03:05 <mmorrow> i wonder how to verify them either way?
13:03:47 <mmorrow> i feel like the fact that State* has mfix ==> S has mfix
13:05:33 <mmorrow> err, that should've been
13:06:06 <mmorrow> newtype a :-> b = F (a,(a->b)->b); newtype Cont o a = C (a :-> o); ... ;)
13:06:26 <mmorrow> (making the (:->) intermediate somewhat pointless)
13:08:24 <lpsmith> hmm,  I should try your mfix on my queue transformer.... that likes to break things
13:09:03 <mmorrow> cool
13:13:55 <Paczesiowa> :i put
13:14:06 <lpsmith> mmorrow: so do you think the forall is necessary here?
13:14:09 <Paczesiowa> @where put
13:14:09 <lambdabot> I know nothing about put.
13:14:25 <lpsmith> :t Control.Monad.State.put
13:14:26 <lambdabot> forall s (m :: * -> *). (MonadState s m) => s -> m ()
13:14:48 <mmorrow> lpsmith: necessary for mfix?
13:14:56 <lpsmith> mmorrow: yes
13:15:14 <mmorrow> i think so, since then it's indistinguishable from State from the outside
13:15:21 <mmorrow> (State.Strict that is)
13:15:50 <mmorrow> i'm not sure about without the forall though
13:16:25 <lpsmith> heh, this conversation exposed a bug in my paper!
13:17:31 <Zao> lpsmith: Before or after publication?
13:17:53 <lpsmith> Before
13:18:11 <lpsmith> I have a draft online though if you would like to take a look:
13:18:17 <lpsmith> http://blog.melding-monads.com
13:23:24 <thoughtpolice> lpsmith: woot! go nearlyfreespeech!
13:23:27 <thoughtpolice> :)
13:23:38 <lpsmith> lol
13:23:39 <copumpkin> yeah! nearlyfreespeech ftw!
13:23:42 <TomMD> Nearly free speech?
13:23:51 <mmorrow> , let (!) = readSTRef; (.=) = writeSTRef; ref = newSTRef in runST (mdo x <- ref 0; k <- ref (do n <- ((!)x); if n > 100000 then return n else (x.=(n+3)) >> join ((!)k)); join ((!)k))
13:23:53 <lunabot>  100002
13:23:57 <copumpkin> a great webhost that doesn't feel like it's out to screw you
13:23:59 <lpsmith> I like them because they have a scrupulously honest business model
13:24:07 <lpsmith> I don't like them because they don't offer SSL
13:24:11 <copumpkin> yeah, no stock photography on the front page is already a big plus for me
13:25:33 <lpsmith> And they have ghc on their servers,  so they are usable for haskell-based webhosting ;-)
13:25:40 <mmorrow> oh nice
13:25:44 <jmcarthur_work> oh?
13:25:55 * mmorrow had to bootstrap from 6.4->6.8->6.10
13:26:02 <TomMD> Why?
13:26:04 <mmorrow> 6.4 gotten via yum
13:26:13 <mmorrow> incompatible libc with the bindist
13:26:18 <TomMD> Fedora 8?
13:26:27 <mmorrow> CentOS4
13:26:33 <TomMD> ahh
13:26:35 <mmorrow> (or 5, can't recall)
13:26:51 * copumpkin wants to write a haskell "selfstate" package
13:26:57 <copumpkin> for the lulz
13:27:15 <lpsmith> they have ghc 6.8.3 now,  if you were referring to nearlyfreespeech.net, mmorrow
13:27:42 <mmorrow> lpsmith: to this other hosted account i have
13:27:46 <lpsmith> ahh
13:28:57 <roconnor> @instances Ix
13:28:58 <lambdabot> Couldn't find class `Ix'. Try @instances-importing
13:29:27 <TomMD> where's the happs tutorial these days?  The Haskell.org wiki ones are old and http://happstutorial.com/ is down.
13:30:15 <Zao> happstack?
13:30:35 <Zao> Hrm, probably that one.
13:30:37 <lpsmith> happstutorial was up as of a few days ago
13:30:46 <TomMD> yes, happstack tutorial.  The happstack site links to the tutorial above.
13:31:30 <Berengal> Is there a tutorial for hsp as well?
13:32:20 <Berengal> TomMD: cabal install happs-tutorial
13:33:06 <TomMD> Berengal: Yeah, I'm actually doing that - thanks.
13:33:06 <lpsmith> maybe the happstutorial issue is a temporary problem, I hope.  I know it was up earlier this week
13:33:33 <Berengal> It's meant to be run locally anyway, or at least have the files so you can look at them
13:33:36 <lpsmith> although the happstutorial is a little light on the tutorial part in some respects
13:34:02 <Berengal> Yeah, I'd like something a little more "hello world"-ish
13:34:16 <TomMD> Wow! All the happs-tutorial deps are completely unversioned.
13:34:40 <Berengal> It was a small pain to install :(
13:34:48 <Berengal> I even had to edit the source at one point
13:35:02 <TomMD> Did you send patches to Creighton?
13:35:13 <Berengal> Nope
13:36:33 <Berengal> I only edited the ones I got from cabal, not darcs, and I wasn't about to get the latest development version just in case it wasn't fixed there. I'm lazy like that
13:36:48 <Berengal> Was just a single constraint missing in a context anyway
13:50:24 <lpsmith> heh
13:50:39 <lpsmith> mmorrow:  your mfix doesn't work with my queue transformer
13:50:51 <mmorrow> :(
13:51:03 <lpsmith> but I'm not surprised in the least.    My queue transformer is a demanding beast
13:51:07 <mmorrow> which mfix? the StateT one or the plain State
13:51:16 <mmorrow> (or both?)
13:51:25 <lpsmith> the first one in your hpaste
13:51:28 <mmorrow> dang
13:51:32 <copumpkin> @hoogle IO Filepath
13:51:32 <mmorrow> what happened?
13:51:33 <lambdabot> Did you mean: :: IO FilePath /count=20
13:51:33 <lambdabot> System.Process.Internals withFilePathException :: FilePath -> IO a -> IO a
13:51:37 <lpsmith> no termination
13:51:43 <copumpkin> @hoogle IO FilePath
13:51:43 <lambdabot> Did you mean: :: IO FilePath /count=20
13:51:43 <lambdabot> System.Process.Internals withFilePathException :: FilePath -> IO a -> IO a
13:51:45 <mmorrow> (and does this mean that mfix for State is broken?)
13:51:45 <giulianoxt> hi there.
13:51:47 <copumpkin> hrm
13:51:48 <giulianoxt> does haskell have a function like c++"s cin>>, wich can handle multiple numbers in one line, for instance?
13:51:49 <lpsmith> or rather, an infinite nonproductive loop
13:51:58 <copumpkin> how do I get the path of the currently running executable?
13:52:02 <lpsmith> Not necessarily
13:52:10 <mmorrow> lpsmith: hmm, that *might* be fixed by a ~ on the (a,s') match
13:52:21 <mmorrow> lpsmith: i had to do that for the IO one
13:52:26 <mauke> copumpkin: I don't think you can do that portably
13:52:27 <mmorrow> (just a thought)
13:52:29 <lpsmith> because there are other examples of perfectly legitimate mfixes
13:52:31 <lpsmith> that don't work
13:52:36 <mmorrow> oh, hmm
13:52:44 <copumpkin> mauke: :( well, *nix is good enough for me
13:52:48 * mmorrow has to finish your paper
13:52:49 <Cale> giulianoxt: you usually convert the numbers or other things into strings which you then concatenate using concat
13:53:03 <lpsmith> actually the mfixes that do work are the exception
13:53:04 <mauke> giulianoxt: why do you need that?
13:53:18 <lpsmith> I really should figure out what's the key difference between those that work and those that don't
13:53:22 <mauke> copumpkin: impossible on generic unix
13:53:25 <giulianoxt> mauke: part of a homework description :)
13:53:25 <mmorrow> lpsmith: does making the match ~(a,s') do anything?
13:53:30 <Cale> > concat ["Here is a number: ", show 56, ", and here is another: ", show 27, "."]
13:53:31 <lambdabot>   "Here is a number: 56, and here is another: 27."
13:53:39 <mauke> Cale: how does that help with reading input?
13:53:44 <giulianoxt> Cale: not sure i'm following. I'm talking about input
13:53:46 <Cale> oh, c*in*
13:53:47 <lpsmith> gimme one sec
13:53:50 <copumpkin> mauke: :(
13:53:51 <Cale> hehe
13:53:51 <mauke> and >>
13:53:52 <Cale> read
13:53:54 <lpsmith> no
13:54:00 <copumpkin> how about just argv[0]?
13:54:05 <lpsmith> it shouldn't anyway,   let is by default lazy
13:54:05 <mauke> giulianoxt: what's the input spec?
13:54:19 <Cale> Get a line of input and then usually chop it into bits which you apply read to
13:54:22 <mauke> copumpkin: ghc hates you and doesn't provide you with access to argv[0]
13:54:34 <copumpkin> aw, /me goes and sobs in the corner
13:54:38 <mauke> copumpkin: http://haskell.org/ghc/docs/latest/html/libraries/base/System-Environment.html#v%3AgetProgName
13:54:39 <monochrom> I should write a tutorial on mfix. It is greatly misunderstood.
13:54:40 <giulianoxt> mauke: It's a little more complicated. I'm actually doing an interpreter for pascal. I have to provide a read function wich does that
13:54:45 <lpsmith> mauke:  you can get the full command line args through one of the GHC-specific packages
13:54:46 <Cale> > map read . words $ "43 2 6 80 102" :: [Integer]
13:54:48 <lambdabot>   [43,2,6,80,102]
13:54:49 <lpsmith> GHC.Env maybe
13:54:52 <copumpkin> mauke: why string and not filepath??
13:54:58 <mauke> copumpkin: filepath is string
13:55:01 <copumpkin> I know
13:55:06 <mauke> copumpkin: also, because it's not a filename
13:55:10 <copumpkin> oh
13:55:17 <copumpkin> there's talk of making filepath not a string
13:55:37 <mauke> yeah, good luck with that
13:55:38 <mmorrow> lpsmith: are we talking about CorecQT here?
13:56:07 <mauke> giulianoxt: hmm, build it yourself using hGetChar
13:57:07 <giulianoxt> mauke: Yeah, I will. just wanted to see if I wasn't reinplementing something
13:57:15 <giulianoxt> mauke: thanks!
13:57:26 <Cale> giulianoxt: Which does "that"?
13:57:40 <Cale> hGetChar seems a little extreme doesn't it?
13:57:45 <lpsmith> mmorrow: yes
13:57:54 <giulianoxt> something like read(a, b, c) should read three variables
13:57:57 <giulianoxt> ignoring spaces, etc.
13:58:05 <ehird> guerby: impossible.
13:58:13 <mmorrow> lpsmith: cool, /me plays with it
13:58:17 <ehird> well, you could do it with TH.
13:58:19 <ehird> but ew.
13:58:20 <lpsmith> although I messed up the runCorecQT a bit
13:58:23 <Cale> giulianoxt: what if it's ambiguous where one thing ends and the other begins?
13:58:24 <ehird> oh
13:58:26 <ehird> it's for an interpreter
13:58:26 <lpsmith> end_point should be
13:58:33 <ehird> right?
13:58:34 <lpsmith> endpoint _ = return (return [])
13:58:44 <lpsmith> not endpoint _ = return []
13:59:12 <giulianoxt> Cale: I just need it for integers. won't be a problem I guess
13:59:16 <copumpkin> @hoogle unlink
13:59:17 <lambdabot> System.Posix.Internals c_unlink :: CString -> IO CInt
13:59:26 <mauke> return . return . fail . return $ minBound
13:59:29 <Cale> giulianoxt: If there's no spaces, it'll always be ambiguous for integers.
14:00:06 <giulianoxt> Cale: how? If I call, for instance. read(a, b), and there's only one integer in the input
14:00:08 <copumpkin> which function in System.Posix calls c_unlink?
14:00:09 <giulianoxt> Cale: it should block
14:00:14 <Cale> 437289 could be 4372 8 9 or 437 28 9 or 437 2 89
14:01:04 <copumpkin> ah, removeLink
14:01:07 <mauke> Cale: it's 437289
14:01:12 <giulianoxt> Cale: ah, i see. I'm assuming they need to be separated by whitespace
14:01:24 <giulianoxt> Cale: wich will be ignored
14:01:33 <Cale> giulianoxt: aha, okay :)
14:01:34 <copumpkin> @seen erikc
14:01:34 <lambdabot> I saw erikc leaving #haskell 1d 14h 49m 58s ago, and .
14:01:52 <copumpkin> @ask erikc have you considered a Macho -> ByteString function in your macho package? :D
14:01:52 <lambdabot> Consider it noted.
14:03:10 <Cale> giulianoxt: You might want to write a function which reads input up to the next bit of whitespace. Converting to an integer is handled okay with 'read' or 'reads' after that.
14:04:42 <giulianoxt> Cale: seems nice. I'll try :)
14:04:57 <mauke> hGetWhile :: Handle -> (Char -> Bool) -> IO String
14:05:49 <mauke> hGetWhile isDigit >>= readIO
14:06:15 <giulianoxt> @hoogle hGetWhile
14:06:15 <lambdabot> No results found
14:06:18 <roconnor> > Data.ByteString.Lazy.length $ encode (0 ::Double)
14:06:20 <lambdabot>   Not in scope: `Data.ByteString.Lazy.length'Not in scope: `encode'
14:06:25 <giulianoxt> ah, it's a tip for the function? thanks
14:06:37 <roconnor> Data.ByteString.Lazy.length $ encode (0 ::Double) is not 8 :(
14:06:41 <roconnor> it is 13.
14:06:59 <roconnor> what's up with that?
14:07:10 <Heffalump> I thought it was more than 13
14:07:23 <Heffalump> it uses the portable representation, i.e. encodeFloat
14:07:29 <Heffalump> @type encodeFloat
14:07:30 <lambdabot> forall a. (RealFloat a) => Integer -> Int -> a
14:07:35 <Heffalump> well, the opposite
14:07:37 <Heffalump> @type decodeFloat
14:07:39 <lambdabot> forall a. (RealFloat a) => a -> (Integer, Int)
14:07:55 <roconnor> ;(
14:08:06 <Heffalump> it's quite a frequent gripe
14:08:31 <roconnor> do we have anything to decode 64-big IEEE 764 doubles?
14:08:51 <roconnor> unsafeCoerce?
14:08:55 <Heffalump> unsafeCoerce#
14:09:10 <roconnor> that's sad
14:09:27 <Heffalump> I wrote an implementation that does it manually
14:09:30 <Heffalump> but I forgot where I put it
14:09:39 <Heffalump> and anyway you really want the fast path, i.e. the unsafeCoerce
14:09:53 <Heffalump> actually I think I know where it is if you want it
14:10:04 <kmatlage> 754 doubles roconner, for what it's worth. :)
14:10:05 <kmatlage> that was a typo in the spec, it's fixed in the new version
14:11:08 <roconnor> ok
14:11:14 <sjanssen> roconnor: I use Ptrs and peek
14:14:09 <Heffalump> roconnor: do you want this implementation?
14:14:26 <copumpkin> how long does the icfp context last?
14:14:30 <copumpkin> contest :P
14:14:32 <Heffalump> 72 hours
14:14:47 <roconnor> Heffalump: nah, I'll just unsafeCoerce
14:15:31 <Heffalump> I think you have to unsafeCoerce the unboxed value, though I could be wrong
14:16:07 <Heffalump> unsafeCoerce# that is
14:16:20 <roconnor> oh
14:16:26 <roconnor> what is Unsafe.Coerce.unsafeCoerce then?
14:17:01 <Heffalump> I can't remember why that didn't work. It's possible it's only correct for coercing to something that actually has the type you want but has lost it somehow
14:17:31 <roconnor> bah
14:17:41 <Saizan> using Storable seems nicer
14:23:59 <roconnor> Saizan: storable seems tied to IO.
14:24:05 <roconnor> am I wrong?
14:24:37 <Saizan> no, you aren't
14:27:25 <roconnor> Actually I have no idea how to use Foreign Storable
14:27:38 <roconnor> can we do memory mapping or something?
14:29:39 <mauke> are you trying to get the bytes of a double?
14:30:20 <copumpkin> dammit why is it so hard to find the documentation for record syntax on google
14:31:11 <thoughtpolice> r-r-r-record
14:31:27 <mauke> because it's in the report, not google :-)
14:33:00 <roconnor> mauke: trying to turn bytes into a double
14:33:18 <copumpkin> mauke: :( you're full of bad news today!
14:34:58 <mauke> how are the bytes stored?
14:35:57 <lpsmith> mmorrow:  you know what,  I bet your mfix would work if we were using delimited continuations
14:36:50 <lpsmith> maybe
14:37:10 <RayNbow> hmm, most functions in Data.Set require an Ord instance... but what if you need a set for a certain type but you don't want to make that type an instance of Ord?
14:37:29 <copumpkin> can I access nested records in patterns?
14:37:33 <mauke> then you're screwed
14:37:36 <Toxaris> how to get a Word64 into a double?
14:37:41 <copumpkin> lol
14:37:43 <copumpkin> unsafeCoerce#
14:37:49 <Toxaris> copumpkin: really?
14:37:55 <mauke> Toxaris: do you want to convert the number or reinterpret the bytes?
14:38:02 <Toxaris> mauke: reinterpret the bytes
14:39:03 <thoughtpolice> RayNbow: yeah, you're screwed
14:39:10 * RayNbow just stumbled upon http://haskell.org/pipermail/libraries/2007-April/007411.html
14:39:11 <thoughtpolice> because Set uses a binary tree underneath
14:39:18 <twanvl> RayNbow: define newtype Wrapper = Wrapper MyDataType, and define an Ord instance for that
14:39:39 <mauke> with w64 $ \pw -> alloca $ \pd -> copyBytes pd (castPtr pw) (sizeOf w64) >> peek pd
14:39:40 <RayNbow> thoughtpolice: well, the thing is... I can make it an artificial instance of Ord
14:39:47 <mauke> Toxaris: ^ looks like it could work
14:40:13 <a_guest> I want to use vim to insert a template comment in top of module. Do anyone know how this should be done?
14:40:42 <RayNbow> twanvl: hmm, and perhaps also make some wrapper functions for a few functions in Data.Set?
14:40:45 <mauke> a_guest: yeah, with autocommands
14:40:55 <mmorrow_> lpsmith: would first-class continuations be enough? (a la smlnj's callcc)
14:40:58 <RayNbow> (otherwise the calling code needs to do a lot of (un)wrapping)
14:41:08 <Toxaris> mauke: thanks. I am seriously considering switching to C for the rest of my life in this moment
14:41:30 <Toxaris> mauke: but I will not do it, of course
14:41:33 <shapr> That would be masochistic.
14:41:40 <pikhq> May your life be filled with segmentation faults, core dumped.
14:41:43 <mauke> word64 w64; double d; memcpy(&d, &w64, sizeof w64); return d;  // same thing
14:42:32 <mmorrow_> why use memcpy?
14:42:50 <a_guest> mauke: how do I let vim insert top comment, manually?
14:42:53 <Toxaris> why not  d = (double)w64
14:42:56 <mmorrow_> yeah
14:43:07 <mauke> Toxaris: because that converts the number, it doesn't reinterpret the bytes
14:43:19 <mmorrow_> oh, i see what we're doing
14:43:45 <mmorrow_> d = *(double*)(&w64); // ?
14:43:51 <mauke> a_guest: what do you mean?
14:44:05 <magthe> is there some way to find out what version of GHC I'm running, from the inside?  (without executing 'ghc --version' and parsing the result)
14:44:21 <mauke> mmorrow_: I'm not sure that's required to work
14:44:32 <mmorrow_> mauke: :(
14:44:32 <lpsmith> mmorrow_  you can implement delimited continuations (i.e. shift and reset) via call/cc and set!
14:44:33 <mauke> alignment might bite you
14:44:35 <Toxaris> mauke: I see
14:44:52 <thoughtpolice> magthe: http://haskell.org/ghc/docs/latest/html/libraries/base/System-Info.html
14:44:53 <mmorrow_> lpsmith: ah yeah, true
14:44:57 <lpsmith> mmorrow_  you can also implement shift and reset in haskell
14:45:01 <a_guest> mauke: autocmd in vim sets a template comment on every new haskell file (?), but I want a command to insert when I want.
14:45:13 <mauke> a_guest: ah, ok
14:45:28 <mauke> a_guest: so define a command or mapping to do it
14:45:34 <mmorrow_> lpsmith: in a monad though..
14:45:51 <magthe> thoughtpolice: ah, thanks, I already found GHC.Paths, which solved another problem for me... but the compiler version number was rather well hidden :)
14:45:54 <mmorrow_> smlnj callcc is super amusing
14:45:58 <lpsmith> http://okmij.org/ftp/Haskell/ShiftResetGenuine.hs
14:46:01 <lpsmith> Yes, even in a monad
14:46:05 <a_guest> ok. I shall take a look in the vim help. thank you
14:46:12 <lpsmith> you can backport that to murthy types
14:46:14 <mmorrow_> but i mean, in haskell you don't have first-class continuations
14:46:31 <monochrom> <3 callcc
14:46:32 <mmorrow_> so no callcc without a monad
14:46:36 <mmorrow_> :(
14:46:49 <lpsmith> well,  you have an implicit delimiter at the "top" of the monad, but no further
14:46:50 <mmorrow_> but not a huge loss :)
14:47:17 <magthe> thoughtpolice: it doesn't quite return what I expected... on GHC 6.10.3 I get "Version {versionBranch = [6,10], versionTags = []}", the '3' seems to be missing :(
14:48:16 <mmorrow_> lpsmith: this is cool: a preemptive scheduler with smlnj's callcc http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1352
14:49:00 <lpsmith> hmm
14:49:26 <mmorrow_> it's neat how smlnj does signals too, the signal handler gets passed a (unit cont), which it then can either throw () to to resume, or whatever
14:50:46 <mmorrow_> the (a cont) you get back from callcc in smlnj is /real/ in the scheme sense
14:50:47 <lpsmith> what makes it atomic?
14:51:01 <mmorrow_> lpsmith: i'm not sure tbh
14:51:06 <lpsmith> I've done semi-preemptive threads using continuations...
14:51:59 <lpsmith> Technically cooperative threading, but such that you could almost ignore it
14:52:02 <monochrom> God makes it atomic.
14:52:03 <mmorrow_> lpsmith: ah, in that paper they say:
14:52:44 <mmorrow_> "...must be accessed atomically. to ensure this we use a simple scheme to mark the beginning and end of critical sections.."
14:53:07 * mmorrow_ had to type that out since the ps has non-selectable text, grrr
14:53:25 <monochrom> That is why I ditched postscript too.
14:53:38 <lpsmith> Chez Scheme has engines,  which eventually cause the current computation to be returned as a continuation at some non-deterministic point in its execution
14:53:47 <monochrom> Unsearhable, unselectable.
14:54:07 <mmorrow_> smlnj is neat how it has no runtime stack
14:54:33 <mmorrow_> a cont is essentially just the registers saved into a record
14:54:46 <lpsmith> it has a stack,  just that every frame is heap-allocated
14:55:01 <lpsmith> it's actually not a very good implementation approach in general
14:55:50 <lpsmith> It makes continuation capture cheap,  at the expense of procedure call and return much more expensive
14:55:53 <mmorrow_> but the control isn't a stack
14:55:55 <lpsmith> and the latter ismore common
14:55:58 <mmorrow_> it's an inverted tree
14:56:10 <mmorrow_> since you can grab the cc
14:56:16 <mmorrow_> hmm
14:56:54 <lpsmith> of course,  basically using a heap-allocated linked list as a stack :-)
14:57:02 <lpsmith> persistent stack, that is
14:57:26 <lpsmith> You can still do call/cc pretty cheaply without an honest stack, but it's harder
14:57:38 <mmorrow_> smlnj apparently has a scheme to use callee saved regs as much as possible for saving stuff too, although i'm not totally clear on the exact details
14:57:40 <lpsmith> err, with an honest, non-persistent stack, but it's harder
14:57:55 <mmorrow_> lpsmith: "heap allocated linked list" exactly!
14:58:24 <lpsmith> Ikarus and Chez use an actual stack stack
14:58:34 <lpsmith> but still support call/cc efficiently
14:58:34 <mmorrow_> err, but it can be non-list shaped i believe
14:58:51 <lpsmith> hmm
14:58:51 <mmorrow_> i think in general it'd look like an inverted tree
14:59:07 <mmorrow_> because you can stick continuation in data structures and stuff
14:59:16 <lpsmith> of course
14:59:35 <mmorrow_> hmm, how do they do call
14:59:43 <mmorrow_> cc with a stack?
14:59:51 <mmorrow_> (copy a chunk on each callcc call?)
15:00:19 <lpsmith> it's a segmented stack,  using a lazy-copy technique
15:00:33 <mmorrow_> hmm, cool. i'll have to read about that.
15:00:51 <lpsmith> no copying actually happens until the continuation is reinstated
15:01:45 <mmorrow_> what happens if the function whose frame the continuation is allocated in returns?
15:02:16 <mmorrow_> (or however that would be said, ie is the stack contiguous?)
15:02:30 <lpsmith> I'm a little fuzzy on the nitty-gritty details, to be honest :-D
15:02:35 <lpsmith> no
15:02:39 <lpsmith> well, yes
15:02:50 <lpsmith> Parts of it are contiguous
15:02:51 * mmorrow_ invokes the googlemachine
15:03:11 <lpsmith> but the runtimes malloc a new stack segment on overflow
15:08:29 <Gracenotes> > any (uncurry (<)) . tail . zip (map (\n -> n * log n + n * log (log n)) [2..]) . map fromIntegral $ nubBy (((/=1).).gcd) [2..]
15:08:35 <lambdabot>   mueval-core: Prelude.read: no parse
15:08:35 <lambdabot>  mueval: ExitFailure 1
15:10:39 <lpsmith> mmorrow:  so what all have you tried your mfix on?
15:11:57 <mmorrow> lpsmith: not really anything yet, that is unless Data.Binary actually uses mfix somewhere (explanation: the thing that originally prompted me to write it for "S" was that i was replacing the Get monad in a personal Data.Binary mod, and Get had an mfix instance)
15:12:30 <mmorrow> Get is just
15:12:42 <mmorrow> Get a = (S -> (a, S))
15:12:59 <mmorrow> where S is i don't recall exactly
15:14:14 <mmorrow> lpsmith: (replacing Get with CpsState makes it a /lot/ faster (on my machine and for the stuff that i do with binary at least))
15:15:13 <mmorrow> i'm pretty sure it'd be strictly faster in general
15:15:49 <lpsmith> hmm
15:15:54 <lpsmith> well, that's something
15:16:03 <lpsmith> I wonder what Binary uses mfix for...
15:16:03 <magthe> anyone who can explain what's going on here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6282
15:16:18 <mmorrow> lpsmith: me too
15:16:41 <mmorrow> lpsmith: (or if whoever wrote Get just felt like making a MonadFix instance that day)
15:20:41 <mmorrow> lpsmith: hmm, without access to the state in Get, i can't think of anything useful to do with mfix off the top of my head
15:21:01 <lpsmith> well, I wonder if that's not a common performance bug in hackage libraries... I replaced a lazy state monad in HPDF with a ST monad and made it a *lot* faster too
15:21:59 <mmorrow> lpsmith: yeah totally. it seems lazy state is only worth it if you *actually need it*, and if not it's just a performance drain
15:22:16 <mmorrow> (like, if you're doing stuff like  (put undefined >> ..))
15:22:43 <lpsmith> OIC,  binary doesn't use mfix,  only provides one
15:22:48 <mmorrow> exactly
15:23:29 <lpsmith> hmm,  well,  your change isn't a drop-in replacement,  but the fact that you did provide any kind of mfix is very interesting...
15:23:44 <lpsmith> I don't know what it means yet :-)
15:24:02 <mmorrow> i'm interested to find some useful non-contrived application of mfix for State
15:24:06 <Saizan> mmorrow: there are use cases where it's way faster, even without "needing" it
15:24:07 <mmorrow> lpsmith: me neither
15:24:20 <mmorrow> Saizan: example?
15:24:44 <mmorrow> Saizan: (you mean State.Lazy is way faster in an instance where essential use is made of the laziness?)
15:25:15 <Saizan> mmorrow: where no essential use is made
15:25:27 <mmorrow> err, yes that's what i meant to say
15:25:32 <Saizan> mmorrow: in fact it's a variation of your benchmark
15:25:42 <mmorrow> Saizan: is it pathological?
15:25:51 <mmorrow> (i'm very interested if not :)
15:25:56 <Saizan> mmorrow: http://lhc-compiler.blogspot.com/2009/05/constructor-specialization-and-laziness.html
15:26:07 <Saizan> i don't really know :)
15:26:44 <byorgey> anyone know how to take 64 bits corresponding to an IEEE float, and stuff it into a Double?
15:26:54 <byorgey> like, say I have a [Word8]
15:26:57 <dons> peek?
15:27:02 <dons> via C?
15:27:18 <Saizan> ICFP has something to do with floats?
15:27:22 <Zao> I've only done it the reverse way, and that was via with and peekArray
15:27:26 <lpsmith> byorgey: somebody said unsafeCoerce# eariler,  but I can't say yea or nay on that
15:27:35 <byorgey> well, I have to read in double values in binary format
15:27:36 <mmorrow> hmm, it's using a bang in that modified replicateM' though. i wonder what that means.
15:27:40 <lpsmith> I'm just parroting what I heard
15:27:41 <byorgey> unless there's a better way to do that
15:28:02 <mmorrow> oh wait. that's just using the bang to be strict! :)
15:28:17 <byorgey> lpsmith: unsafeCoerce# from what? a Word64 ?
15:28:40 <mmorrow> err, wait. i'm not sure what's going on there.
15:28:48 <Saizan> mmorrow: but if you use a strict version of state you get slower
15:29:21 <Saizan> mmorrow: i think it's giving the exact amount of strictness you want for that case, rather than strictifying everything
15:29:42 <dons> unpack the D# constructor, and peek bits
15:29:45 <dons> into ieee format
15:29:47 <dons> or from it.
15:30:38 <roconnor> Ack!
15:30:44 <roconnor> There is no Data.Arrray.ST.Lazy?
15:30:50 <dons> nope
15:30:54 <roconnor> ;(
15:31:04 <roconnor> modular programming is so hard
15:31:37 <roconnor> Can I turn an ST into a LazyST?
15:31:56 <dons> hey, can't people use strtod ?
15:31:57 <roconnor> oh
15:31:59 <roconnor> lazyToStrictST
15:31:59 <dons> i.e. from bytestring-lexing
15:32:11 <roconnor> strictToLazyST
15:32:18 <dons> http://hackage.haskell.org/package/bytestring-lexing
15:32:35 <dons> byorgey: ^^ parse Doubles from bytestrings
15:33:47 <byorgey> dons: parse in what sense?
15:33:56 <Zao> dons: That's text to Double though, isn't it?
15:34:02 <byorgey> does it parse bytestrings like "3.0839487"?  that's not what I need.
15:34:06 <Zao> I thought byorgey had them in nice binary blobs.
15:34:11 <byorgey> yup
15:34:30 <uzytkownik> @undo do {(a, v) <- runStringOutput; (a', v') <- f a; return (a', v `mappend` v')}
15:34:31 <lambdabot> runStringOutput >>= \ (a, v) -> f a >>= \ (a', v') -> return (a', v `mappend` v')
15:35:20 <byorgey> dons: where is D# defined?
15:36:24 <roconnor> :hoogle repeatM
15:36:29 <roconnor> @hoogle repeatM
15:36:29 <lambdabot> No results found
15:36:43 <byorgey> hmm, I found it, in GHC.Prim, but I still don't get it =P
15:36:49 <byorgey> what does 'peek' have to do with anything?
15:36:51 <byorgey> @hoogle peek
15:36:52 <lambdabot> Foreign.Storable peek :: Storable a => Ptr a -> IO a
15:36:52 <lambdabot> Foreign.Marshal.Array peekArray :: Storable a => Int -> Ptr a -> IO [a]
15:36:52 <lambdabot> Foreign.Marshal.Array peekArray0 :: (Storable a, Eq a) => a -> Ptr a -> IO [a]
15:37:07 <byorgey> I don't have any Ptrs anywhere.
15:37:37 <roconnor> how come we don't get to have repeatM
15:37:43 <roconnor> let repeatM x = mapM (const x) (repeat ())
15:38:07 <roconnor> hmm
15:38:14 <roconnor> I guess I should use sequence
15:38:38 <roconnor> let repeatM f = sequence (repeat f)
15:38:49 <roconnor> take 5 $ Control.Monad.ST.Lazy.runST $ repeatM $  ... works just fine!
15:42:23 <dons> byorgey: can't you just grab the head of the bytestring, withForeignPtr it, and parse the Double straight off?
15:42:31 <dons> i.e. call peek on the Ptr inside the bytestring.
15:43:53 * roconnor is using unsafeCoerce
15:44:00 <roconnor> not that I can tell if it works or not.
15:44:03 <mmorrow> Saizan: interesting! without the sucky replicateM, the lazy state version only needs 1 generation 2 collection, whereas the strict version needs 6
15:44:17 <dons> well, if you're parsing with strict bytestrings, then you can call  toForeignPtr.withForeignPtr. peek :: IO Double, basically
15:44:48 <byorgey> dons: aha, thanks!  I didn't know about withForeignPtr and kin.
15:44:49 <mmorrow> Saizan: i think this is because the strict one doesn't return any of the list until the end, whereas the lazy one does so incrementally
15:45:03 <dons> byorgey: yeah, strict bytestring->foreign ptr -> ptr
15:45:07 <byorgey> roconnor: how exactly are you using unsafeCoerce?
15:45:16 <dons> then peek to read off raw Double (assuming it is in ieee fmt)
15:45:20 <roconnor> unsafeCoerce :: Word32 -> Double
15:45:22 <mmorrow> Saizan: hmm, so by that logic the strict one should be faster if it's returning an atomic type
15:45:26 * mmorrow experiments
15:45:56 <dons> roconnor: roxors
15:46:09 <mauke> before you go peeking at random pointers, have you considered alignment?
15:46:13 <roconnor> byorgey: my initial memory for the first problem doesn't seem that unreasonable
15:46:25 <byorgey> roconnor: shouldn't it be Word64?
15:46:32 <uzytkownik> @undo do {a <- runHandleOutput m h; runHandleOutput (f a) h}
15:46:33 <roconnor> right, it is Word64
15:46:33 <lambdabot> runHandleOutput m h >>= \ a -> runHandleOutput (f a) h
15:46:40 <Paczesiowa> roconnor: isn't Word32 lifted?
15:46:41 <roconnor> my mistake
15:46:44 <dons> roconnor: sounds totally unsafe ...
15:46:44 <byorgey> ok, cool
15:46:54 <dons> a C function might be safer.
15:46:57 <byorgey> maybe I will try both and see if I get the same thing.
15:47:05 <roconnor> dons: when Data.Binary parses IEEE format, I'll switch. :)
15:47:39 <dons> roconnor: oh, i'm not advocating Data.Binary, but yes, damn, if only it had a IEEE parser
15:47:49 <Saizan> 7http://hackage.haskell.org/package/data-binary-ieee754 <-
15:47:54 <Gracenotes> D:
15:47:59 <roconnor> dons: preferably one optimized to "id"
15:48:04 <Gracenotes> 7http is such an interesting protocol
15:48:09 * Berengal is reading about regular expression patterns
15:48:52 <Gracenotes> hm.. I forgot, how do you convert a regular expression into a regular grammar
15:49:05 <roconnor> Saizan: that seems promising
15:49:14 <Gracenotes> er. with the same language O_O
15:49:27 <Saizan> roconnor: not really optimized
15:50:33 <Berengal> 'filterFives :: [Int] -> [Int]; filterFives [(5|notFive)*) = notFive' O_o
15:50:49 * Twey suspects that someone, somewhere, has developed a regex for regexes
15:51:01 <Gracenotes> I'm afraid not, Twey
15:51:08 <sjanssen> roconnor: in my VM, I used the 'mmap' package from Hackage and Ptrs.  Everything seems to work well
15:51:09 <Gracenotes> it is unpossible!
15:51:53 <uzytkownik> @pl \x = HandleOutputT $ liftIO $ flip hPutStrLn x
15:51:53 <lambdabot> (line 1, column 4):
15:51:53 <lambdabot> unexpected "="
15:51:53 <lambdabot> expecting operator, pattern or "->"
15:51:53 <Berengal> This is crazy stuff. I'm not sure if it's good crazy or bad crazy yet
15:52:00 <uzytkownik> @pl \x -> HandleOutputT $ liftIO $ flip hPutStrLn x
15:52:00 <lambdabot> HandleOutputT . liftIO . flip hPutStrLn
15:52:07 <Twey> Gracenotes: How can it be unpossible?  :(
15:53:03 <Gracenotes> regex cannot deal too well with recursive structures in text, the kinds you need to specify regex
15:53:08 <Twey> Oh, it's recursive
15:53:09 <Twey> Yeah
15:53:12 <Twey> I just tried to write it :-P
15:53:17 <Twey> I forgot about that.
15:53:41 <Gracenotes> regex can be described by context-free grammars, and context-free grammars can be described by regex
15:54:01 <Gracenotes> matched anyway
15:56:03 <FunctorSalad> context-free are strictly powerfuller than regexes
15:56:53 <SamB> "more powerful"
15:57:05 <mauke> powererfull
15:57:24 * SamB snickers
15:57:33 <FunctorSalad> I thought it had a nice sound to it
15:58:55 <Twey> Hehe
16:03:01 <hackagebot> email-validate 0.2.4 - Validating an email address string against RFC 5322 (GeorgePollard)
16:05:03 <hackagebot> email-validate 0.2.5 - Validating an email address string against RFC 5322 (GeorgePollard)
16:06:19 <byorgey> dons: when I call toForeignPtr, I get a ForeignPtr and a length and offset.  am I correct in assuming that I need to add the offset to the pointer?
16:07:55 <crlr> hi everybody
16:08:44 <int-e> byorgey: yes.
16:09:14 <crlr> is there a room for vim-haskell?
16:09:33 <TomMD> That sounds like a bot question.
16:12:01 <byorgey> int-e: thanks.
16:25:24 <mmorrow> Saizan: ok, i've figured out exactly what's happening there. so because the cps-state doesn't return any results until the end, clearly a benchmark involving the incremental consumption of a list would go in favor of the lazy state (that is, with a strict replicateM'), but if ew change the bench to replicateM_ and only care about the state, the cps version version takes 0.07s and 1MB max mem, lazy 0.20s 39M mem.
16:25:55 <mmorrow> so the moral of the story was that that benchmark wasn't very well chosen by me for a strict state monad :)
16:26:36 <Saizan> it also shows that transforming to a strict monad is not a silver bullet
16:26:39 <mmorrow> (because of the list, if you can get the lazy state to not blow the stack, it'll be faster by default since the `last' function can incrementally consume the list)
16:26:48 <mmorrow> Saizan: yes, i agree.
16:27:30 <mmorrow> Saizan: it's very appropriate for returning results lazily, even more so than i thought at first.
16:27:50 <Saizan> lazily?
16:27:53 <mmorrow> *but* clearly replicateM is too lazy here to be useful
16:28:08 <mmorrow> Saizan: s/lazly/incrementally/
16:28:13 <Saizan> ah, the lazy state monad is
16:28:17 <mmorrow> yes
16:28:49 * mmorrow uses Lemmih's replicateM' from now on
16:28:54 <Saizan> fortunately lemmih seems to imply that LHC could transform the replicateM into replicateM' automatically when needed
16:29:28 <mmorrow> i'm just going to replace replicateM by replicateM' in all my code, personally
16:30:29 <Saizan> do you think there are no cases where you'd want the lazier one?
16:30:38 <mmorrow> hmm, this probably goes for sequence as well
16:31:20 <mmorrow> Saizan: i can't think of any time i've ever wanted the laziness in replicateM, but then again i don't ever really use laziness to stick undefined's in stuff so i'm not sure if that's common
16:32:14 <mmorrow> (replicateM' seems especially nice for (how i use) Data.Binary too)
16:32:17 <copumpkin> zomg netflix prize!
16:32:48 <Saizan> well, there are many cases where more strictness can hurt, even if it doesn't lead to non-termination, however i guess you know your code better than i do :)
16:33:22 * Saizan just hopes he won't need to think so much about that when a sufficiently smart compiler comes out
16:33:52 <mmorrow> Saizan: i'm not so sure, because i actually never use lazy State to begin with, so i guess i always am implicitly using that replicateM' anyways ??
16:34:09 * mmorrow doesn't know if that's true.. thinks for a second
16:34:42 <mmorrow> well i guess it would have to be, since regular replicateM works for strict state, but not lazy state in that example
16:35:12 <Saizan> no, replicateM' is different from replicateM in strict state
16:35:17 <mmorrow> (so i guess there's no point in replacing replicateM with ', unless you're using a lazy state)
16:35:30 <mmorrow> Saizan: hmm, i suppose you're right
16:35:51 <mmorrow> ah yeah, so the bang is forcing the lazy state's result, which in turn is forcing its state
16:36:10 <Saizan> strict state only forces the tuple
16:36:14 <mmorrow> making it strict, but at the same time, still allowing incremental results?
16:36:27 <mmorrow> Saizan: ah, yeah i should mention i changed that to
16:36:36 <mmorrow> (get >>= \(!m,!n) ->
16:36:37 <Saizan> well, it also depends on which version of strict state we're talking about
16:36:42 <mmorrow> Saizan: that's true
16:36:51 <mmorrow> (i mean the cps one)
16:37:01 <Saizan> (unboxed?)
16:37:14 <mmorrow> newtype S s a = S {unS :: forall o. (a -> s -> o) -> s -> o}
16:38:13 <hackagebot> HStringTemplate 0.5.1.3 - StringTemplate implementation in Haskell. (SterlingClover)
16:38:50 <Saizan> mmh, that's probably equivalent to deforested Control.Monad.State.Strict
16:39:22 <mmorrow> yeah, with the intermediate tuples in (>>=) elim
16:41:38 <Saizan> however a monad can never turn return _|_ into _|_, so replicateM n (return _|_) == list of bottoms /= bottom == replicateM' n (return _|_)
16:42:31 <Saizan> assuming the last equivalence holds..
16:43:06 <mmorrow> hmm
16:46:58 <mmorrow> Saizan: hmm, so in lemmih's version, the State.Lazy is actually being turned into State.Strict, but even stricter than that (since replicateM' is forcing the result as well)
16:47:38 <mmorrow> (since replicateM' is implicitly rnf'ing the State.Lazy's state)
16:48:03 <mmorrow> (in this case)
16:48:29 <Saizan> > let repM' 0 _ = return []; repM' n m = do !i <- m; is <- replicateM (n-1) m; return (i:is) in runState (replicateM 2 (return undefined)) () :: ((),())
16:48:31 <lambdabot>   <no location info>: Illegal bang-pattern (use -XBangPatterns)
16:48:48 <mmorrow> lunabot has them, but hash s/mtl/monadLib/..
16:48:58 <Saizan> , let repM' 0 _ = return []; repM' n m = do !i <- m; is <- replicateM (n-1) m; return (i:is) in runState (replicateM 2 (return undefined)) () :: ((),())
16:48:59 <lunabot>  luna: Couldn't match expected type `()' against inferred type `m [a]'
16:49:07 <Saizan> , let repM' 0 _ = return []; repM' n m = do !i <- m; is <- replicateM (n-1) m; return (i:is) in runState (replicateM 2 (return undefined)) () :: ([()],())
16:49:09 <lunabot>  luna: Couldn't match expected type `()' against inferred type `m [a]'
16:49:12 <mmorrow> hehe
16:49:15 <Saizan> gah
16:49:40 <Saizan> , [$ty| runState |]
16:49:44 <lunabot>  forall a b . b -> State b a -> (a, b)
16:49:54 <Saizan> oh, it's the right way around!
16:50:00 <mmorrow> :)
16:50:08 <Saizan> , let repM' 0 _ = return []; repM' n m = do !i <- m; is <- replicateM (n-1) m; return (i:is) in runState () (replicateM 2 (return undefined)) :: ([()],())
16:50:09 <lunabot>  luna: Prelude.undefined
16:50:22 <Saizan> lol, i used replicateM
16:50:28 <mmorrow> heh
16:50:56 <Saizan> , let repM' 0 _ = return []; repM' n m = do !i <- m; is <- replicateM (n-1) m; return (i:is) in length . fst $ (runState () (replicateM 2 (return undefined)) :: ([()],()))
16:50:58 <lunabot>  2
16:51:09 <Saizan> , let repM' 0 _ = return []; repM' n m = do !i <- m; is <- replicateM (n-1) m; return (i:is) in length . fst $ (runState () (repM' 2 (return undefined)) :: ([()],()))
16:51:10 <lunabot>  luna: Prelude.undefined
16:51:31 <Saizan> your printing is too strict :P
16:51:37 <mmorrow> umm, what changed?
16:51:57 <mmorrow> ah, maybe it's because i have to fromDynamic it after evalDynamic
16:52:31 <mmorrow> , (fromJust . fromDynamic . eval) "[undefined]" :: [Int]
16:52:34 <lunabot>  luna: Ambiguous type variable `a' in the constraint:
16:52:42 <mmorrow> , (fromJust . fromDynamic . eval) "[undefined::Int]" :: [Int]
16:52:45 <lunabot>  luna: Prelude.undefined
16:53:06 <mmorrow> , case ((fromJust . fromDynamic . eval) "[undefined::Int]" :: [Int]) of [_] -> ()
16:53:09 <lunabot>  ()
16:53:17 <mmorrow> um
16:53:36 <jaredj_> mmorrow: s/^,/>/
16:53:40 <kyagrd> Is programming contest already open?
16:53:42 <mmorrow> , take 1 ((fromJust . fromDynamic . eval) "[2,undefined::Int]" :: [Int])
16:53:43 <jaredj_> oops nm
16:53:45 <lunabot>  [2]
16:53:53 <mmorrow> i guess it's not fromDynamic
16:54:13 <mmorrow> Saizan: maybe lazy state isn't the default in monadLib?
16:54:48 <jaredj_> i have a type that i've imported that has a Show instance. But I don't like it. Can I override it with my own?
16:55:13 <mmorrow> jaredj_: no, although it'd be nice if you could
16:56:15 <Saizan> mmorrow: you experience the same without using state at all, why should it matter?
16:56:32 <mmorrow> Saizan: what?
16:56:50 <mmorrow> oh you mean that you get undefined in
16:56:57 <mmorrow> , let repM' 0 _ = return []; repM' n m = do !i <- m; is <- replicateM (n-1) m; return (i:is) in length . fst $ (runState () (repM' 2 (return undefined)) :: ([()],()))
16:56:58 <lunabot>  luna: Prelude.undefined
16:56:59 <mmorrow> ?
16:57:07 <Saizan> , [undefined]
16:57:09 <lunabot>  luna: Prelude.undefined
16:57:11 <Saizan> >, [undefined]
16:57:15 <Saizan> > [undefined]
16:57:17 <lambdabot>   [* Exception: Prelude.undefined
16:57:21 <Saizan> see?
16:57:36 <mmorrow> hmm, i'm trying to think what is causing that
16:57:47 <mmorrow> oh
16:57:56 <mmorrow> maybe because
16:58:00 <mmorrow> err, i dunno
16:58:05 * mmorrow looks at the code
16:58:39 <mmorrow> , show [undefined]
16:58:41 <lunabot>  luna: Prelude.undefined
16:58:50 <mmorrow> wut
16:58:53 <roconnor> LazyST++
16:59:00 * roconnor hugs LazyST
16:59:04 <mmorrow> , (toDynamic (undefined::Int))
16:59:06 <lunabot>  luna: Not in scope: `toDynamic'
16:59:09 <mmorrow> , (toDyn (undefined::Int))
16:59:11 <lunabot>  <<Int>>
16:59:29 <mmorrow> , show (fromDynamic (toDyn (undefined::Int)) :: Maybe Int)
16:59:31 <lunabot>  luna: Prelude.undefined
17:00:05 <mmorrow> , (fromDynamic (toDyn (show::Int->String) <<$>> toDyn (undefined::Int)) :: Maybe String)
17:00:09 <lunabot>  luna: Prelude.undefined
17:00:19 <mmorrow> maybe it's Dynamic doing it?
17:00:31 <roconnor> @type lookup
17:00:32 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
17:00:55 <mmorrow> (since lunabot uses the `eval' for strings coming over the network as is in scope in it)
17:01:05 <mmorrow> , [$ty| eval |]
17:01:08 <lunabot>  String -> Dynamic
17:02:04 <roconnor> my satellite seems to be working!
17:02:12 <Saizan> yay!
17:02:17 <roconnor> it is very slowly spiralling away
17:02:44 <roconnor> It'll spiral away faster if I complie this.
17:02:59 <edwardk> gratz roconnor
17:03:08 <roconnor> it's all thanks to unsafeCoerce
17:03:10 <inimino> nice :)
17:03:20 <hackagebot> showdown 0.1 - A simple gtk based Russian Roulette game. (AnthonySimpson)
17:03:30 <Saizan> > length (fromJust . fromDynamic $ eval "[undefined :: ()]" :: [()])
17:03:32 <lambdabot>   Not in scope: `eval'
17:03:37 <Saizan> , length (fromJust . fromDynamic $ eval "[undefined :: ()]" :: [()])
17:03:40 <lunabot>  1
17:04:00 <Saizan> mmorrow: it looks like it happens later
17:04:24 <mmorrow> Saizan: oh, i see what you're after. so the state would only be rnf'ed if the result you're forcing /depends/ on the full evaluation of the state
17:04:33 <mmorrow> which in the fib case, it does
17:08:00 <mmorrow> Saizan: ahh, in the eval driver prog (which is in a sep proc than the bot), it tries to take 2048 from the resulting string, after fromDynamic, so it hits the undefined and crashes with that result, which the bot then reads as the result of the evaluated expression over the pipe
17:08:02 <jberryman> I know this has been asked before, but what exactly is (->) ?
17:08:11 <mmorrow> a -> b
17:08:15 <mmorrow> (->) a b
17:08:34 <Twey> A type constructor taking two arguments and yielding a function from the first to the second
17:08:56 <mmorrow> Saizan: so i guess it should mapM_ putChar or something
17:08:56 <Saizan> mmorrow: yeah, we had it the same in mueval
17:09:04 <inimino> yielding the type of a function from the first to the second
17:10:18 <Saizan> mmorrow: i've written some weird code to get the * Exception .. output and not loop indefinitely for fix error in mueval if you want to look :)
17:10:38 <mmorrow> Saizan: ahh, i was wondering about that
17:10:45 <mmorrow> i love fix error's output :)
17:11:00 <mmorrow> i'll check that out
17:14:38 <jberryman> so (->) is a type constructor with no data constructors? could I define that myself?
17:15:00 <Saizan> the data constructor is \x -> if you want..
17:15:09 <mmorrow> > let repM' 0 _ = return []; repM' n m = do i <- m; is <- replicateM (n-1) m; return (i `seq` i:is) in length . fst $ (runState (repM' 2 (return undefined)) () :: ([()],()))
17:15:11 <lambdabot>   * Exception: Prelude.undefined
17:15:27 <mmorrow> are you saying that should work?
17:16:05 <Saizan> that's what i'm expecting from repM'
17:16:10 <mmorrow> ah
17:16:12 <Saizan> even in lazy state
17:16:28 <Saizan> which is different from replicateM, even in strict state, i think
17:16:31 <jberryman> Saizan: thanks.
17:16:31 <mmorrow> > let repM 0 _ = return []; repM n m = do i <- m; is <- replicateM (n-1) m; return (i:is) in length . fst $ (runState (repM 2 (return undefined)) () :: ([()],()))
17:16:32 <lambdabot>   2
17:16:40 <mmorrow> > let repM 0 _ = return []; repM n m = do i <- m; is <- replicateM (n-1) m; return (i:is) in length . fst $ (runState (repM 2000000 (return undefined)) () :: ([()],()))
17:16:43 <lambdabot>   2000000
17:16:44 <conal> "A variable is to data flow what GOTO is to control flow.  Just as GOTO allows control to go anywhere, a variable allows data to go anywhere." Arch D Robinson, http://neoparaiso.com/logo/variables-considered-harmful.html
17:16:55 <mmorrow> > let repM 0 _ = return []; repM n m = do i <- m; is <- replicateM (n-1) m; return (i:is) in length . fst $ (runState (repM 2000000000 (return undefined)) () :: ([()],()))
17:17:04 <lambdabot>   mueval-core: Prelude.read: no parse
17:17:05 <lambdabot>  mueval: ExitFailure 1
17:17:18 <mmorrow> does replicateM do something extra to make it extra-super lazy?
17:17:20 <jmcarthur> conal: what are your thoughts on that?
17:17:30 <mmorrow> oh wait
17:17:32 <mmorrow> n/m
17:17:46 <Saizan> jberryman: A -> B is the type of functions from A to B, you couldn't define it in normal haskell, since functions are so fundamental
17:17:49 <conal> jmcarthur: i'm wondering if a variable is perhaps more like COMEFROM
17:18:00 <jmcarthur> i'm not even sure if it's talking about variables or if it's really talking about state
17:18:05 <Saizan> jberryman: i mean, you don't have haskell without functions :)
17:18:17 <jmcarthur> conal: what do you mean? (i know what comefrom is)
17:18:23 <conal> jmcarthur: i think he means vary-able
17:18:27 <conal> jmcarthur: i.e., state
17:18:37 <jmcarthur> i suspected, but i wasn't sure
17:18:55 <jmcarthur> i see stuff about time dependent variables a suppose
17:19:13 <jmcarthur> of course, that is kind of what frp is, too, but in a less direct way
17:19:23 <conal> or a more direct way
17:19:31 <conal> in that the time-varying thing is first class
17:19:47 <roconnor> sjanssen: to get get a target distance of 4.2164e7  for 1001?
17:19:50 <conal> instead of an indirect by-product (a trace) of execution
17:20:48 <Saizan> mmh, that phrase applies without mutation too
17:20:49 <jmcarthur> well, it describes time-dependent values in a time-independent way
17:20:57 <jmcarthur> s/it/frp/
17:21:08 <sjanssen> roconnor: yes
17:21:30 <Saizan> once you've a variable referring to something you can use it anywhere, contrast this with pointfree style where the flow is more regulated and "evident"
17:22:10 <jmcarthur> Saizan: yes, that was the other interpretation i was fighting with in my head
17:22:18 <jmcarthur> of the article, that is
17:22:25 <roconnor> w00t unsafeCoerce
17:23:03 <conal> Saizan: jmcarthur: oh.  iswym.  i'll have to read that (short) paper and find out.
17:23:15 <jmcarthur> i've had bananas, lenses, envelopes, and barbed wire on my brain today
17:23:43 <jmcarthur> wondering how far i can take it
17:23:57 <FunctorSalad> roconnor: it beats 'cast' performance-wise if you know it can't go wrong ;)
17:24:06 <periodic> Hrm, I'm confused by this.  foldr and foldl are giving me different results.
17:24:24 <jmcarthur> periodic: hpaste?
17:25:18 <Twey> periodic: They do tend to do that.  :)
17:25:48 <jmcarthur> yes, they are different things
17:26:15 <periodic> I've sort of got a list of data objects with times and values, and I'm computing a total and storing the highest time seen.
17:26:16 <Twey> @src foldl
17:26:17 <lambdabot> foldl f z []     = z
17:26:17 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
17:26:17 <Twey> @src foldr
17:26:18 <lambdabot> foldr f z []     = z
17:26:18 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
17:26:22 <periodic> Only foldr gives me 0 for the highest time.
17:26:31 <periodic> I'll do an hpaste.  Let me beautify a sec.
17:27:11 <conal> jmcarthur: Saizan: i quickly read that short paper, and i don't know which sense of "variable" the author means.  they both apply, since he's discussing IFP (a variant of Backus's FP), which is both purely functional and point-free.
17:27:55 <thoughtpolice> roconnor: everybody loves unsafeCoerce# :)
17:28:08 <roconnor> no #
17:28:09 <jmcarthur> conal: if he means both then he certainly is to be commended ;)
17:28:10 <thoughtpolice> well, you love it when you feel like being evil
17:28:11 <roconnor> for me :)
17:28:13 <thoughtpolice> really evil
17:28:32 <thoughtpolice> an evil feeling that has dawned on me once or twice :)
17:29:46 <pikhq> unsafeCoerce seems to me a lot like playing with hand grenades...
17:29:50 <Saizan> all the cool kids use unsafeCoerce
17:30:00 <jmcarthur> all the dead kids use unsafeCoerce
17:30:09 * pikhq is imagining someone implementing their own malloc on top of mmap.
17:30:13 <jmcarthur> s/use/used/
17:30:23 <thoughtpolice> i'm not dead yet!
17:30:35 <Saizan> you've been lucky!
17:30:36 <thoughtpolice> and with no shrapnel injuries
17:30:42 <thoughtpolice> *super* lucky, it seems :)
17:30:44 <jmcarthur> YET
17:30:58 <pikhq> There are old Haskell coders and bold Haskell coders but no old, bold Haskell coders.
17:31:03 <pikhq> :P
17:31:09 <thoughtpolice> unsafeCoerce (1 :: Int) :: Integer --bahahahah
17:31:14 <thoughtpolice> *boom*
17:31:27 <jmcarthur> the old ones are bold. they wear the hair shirts
17:31:49 <jmcarthur> all haskell coders are bold!
17:31:58 <thoughtpolice> are there also 'kinda-fake toupe' shirts?
17:32:10 <pikhq> unsafeCoerce (IO Int) :: State String String
17:32:12 <thoughtpolice> well, I suppose 'obviously' or 'nonobviously' fake would be better :)
17:32:25 <pikhq> (boom!)
17:32:44 * thoughtpolice thought it was pretty cute you could express unsafeCoerce# with unsafePerformIO
17:32:51 <thoughtpolice> as far as GHC is concerned, at least
17:33:03 <mmorrow> does anyone know in what sense fortran77 functions can have /multiple entry-points/?
17:33:22 <pikhq> mmorrow: ... Wwwhaaa?
17:33:32 <thoughtpolice> jhc it doesn't quite work out the same way, due to somewhat ridiculous inlining/optimizations etc
17:33:32 <mmorrow> i can't seem to find any description of this, but i just read about it wrt control-flow graphs
17:33:34 <jmcarthur> conal: what did you mean by comparing variables to comefrom?
17:33:42 <pikhq> I think my brain broke.
17:33:53 <pikhq> My brain didn't break when learning Haskell, but Fortran did it.
17:34:05 <thoughtpolice> mmorrow: http://docs.hp.com/cgi-bin/doc3k/B3150190022.12120/31
17:34:07 <mmorrow> pikhq: heh, yeah i can't seem to imagine what this means
17:34:07 <thoughtpolice> ?
17:34:09 <Freidenker> Somebody has an idea how to make Cairo work with Gtk2hs on Windows. I don't know much about windows, but I used the windows installer from Gtk2hs, I clearly see libcairo-2.dll in gtk2hs\0.10.1\bin. I also tried to install Gtk+, Glade, and Cairo individually but I still get a "Could not find module "Graphics.Rendering.Cairo". The same example works fine on Linux.
17:34:12 * mmorrow looks
17:34:25 <wli> I'm not good enough at F77.
17:34:37 <mmorrow> thoughtpolice: beautiful, thanks.
17:34:50 <periodic> Twey: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6284#a6284
17:34:52 <mmorrow> thoughtpolice: your google skillz are without equal ;)
17:34:55 <thoughtpolice> mmorrow: np. looks crazy however :)
17:34:57 <jmcarthur> my grandpa knows and loves fortran. i wonder what he would think of haskell
17:35:11 <periodic> Twey: nm! I"m an idiot.
17:35:25 <thoughtpolice> mmorrow: ;) protip - 'multiple entry points fortran 77' + 'feeling lucky' = win
17:35:42 <Saizan> Freidenker: that's an haskell error
17:35:45 <periodic> Twey: I was thinking of them both from left-to-right
17:36:05 <Saizan> Freidenker: maybe the cairo version you installed on windows differs from the one you use on linux?
17:36:16 <Saizan> Freidenker: you can check with ghc-pkg list cairo
17:37:01 <mmorrow> haha, this is sweet. so a fortran function can have any number of alternate entrypoints sprinkled arbitrarily at random points inside of it
17:37:10 <thoughtpolice> jmcarthur: i actually met a kid the other day (friend of my suitemate) who codes stuff in fortran because his degree is in nuclear physics engineering or some crazy stuff like that
17:37:30 <mmorrow> thoughtpolice: heh, i was scanning the fortran77 manual's TOC
17:37:38 <mmorrow> = loss
17:38:04 <Freidenker> Saizan: Well it's the Cairo version Gtk2Hs gave so it should work, I'm not sure how to see which version of Cairo they have on Windows but I can check on Linux, yet it's just a simple example...
17:38:11 <thoughtpolice> jmcarthur: he asked me if I was a programmer and said "yes", and then he said "i write lots of stuff in fortran for my homework/degree"
17:38:14 <thoughtpolice> and I was like
17:38:15 <thoughtpolice> "wat"
17:38:43 <jmcarthur> thoughtpolice: my understanding is that there is still a lot of fortran in my area. lots of NASA and stuff here
17:39:00 <pikhq> I *honestly* thought that such a crazy feature would never, ever be used outside of INTERCAL.
17:39:02 <jmcarthur> huntsville, al
17:39:12 <pikhq> And even then, I don't think anyone's done it.
17:39:14 <thoughtpolice> jmcarthur: i'm a houstonian, so there are lots of NASA-related things around here
17:39:16 <Saizan> Freidenker: in a command prompt on windows "ghc-pkg list cairo" should work the same as in linux
17:39:31 <jmcarthur> heh, yeah, houston has a ton
17:39:36 <pikhq> "Fortran: the language crazier than INTERCAL."
17:39:46 <jmcarthur> you mean FORTRAN
17:39:50 <Saizan> Freidenker: "ghc-pkg describe cairo" tells you the modules cairo exports too
17:39:56 <jmcarthur> because it has the coolest name ever
17:40:11 <pikhq> Why was that *ever* considered a good idea?
17:40:25 <pikhq> I think that's crazier than longjmp!
17:40:36 <thoughtpolice> jmcarthur: it would be pretty awesome to work around that kind of stuff, but I fear my mind would be blown every day so many times that after a while I wouldn't know who I was
17:40:48 <jmcarthur> it happens
17:40:57 <Saizan> i guess that splitting things in subprocedures was so painful that it made sense
17:41:20 <thoughtpolice> jmcarthur: so instead I'm sticking to uni. people + connections to try and find jobs. here's to hoping!
17:41:37 <Freidenker> It returns C:/Program Files/Haskell Platform/2009.2.0/ghc-6.10.2\package.conf:
17:41:41 <Freidenker> Nothign else
17:41:44 <Freidenker> (on windows)
17:42:47 <jmcarthur> i kind of wish i knew fortran just for the leetpoints
17:43:39 <p_l> mmorrow: I suspect ENTRY is related to some obscure linking issues on some old machine
17:43:41 <Saizan> Freidenker: that means the cairo package is not installed
17:44:12 <Saizan> Freidenker: maybe they have more than one ghc on windows and gtk2hs was installed for the other one?
17:44:23 <thoughtpolice> jmcarthur: cobol if only for leetpoints through sustaining massive amounts of brain/eye damage and surviving (hopefully)
17:44:24 <roconnor> ugh, I think using ST might be a mistake
17:44:29 <roconnor> hard to rollback
17:44:37 <thoughtpolice> i would then cash in my leetpoints for a roflcopter.
17:44:42 <mmorrow> nice, also in fortran77 there is two kinds of RETURN stmts. the first is the regular one, but the socond gives you the ability to return to an arbitrary location in the calling function, the label of which need not be known statically and can even be based on a value that function got passed as an arg
17:44:56 <mmorrow> continuations++
17:44:56 <jmcarthur> thoughtpolice: nice pair of lollerskates is enough for me
17:45:09 <Freidenker> Damn... I'll try to install it, again, but Cairo seems to be very hard to install for a non-computer-scientist.
17:45:18 <pikhq> mmorrow: AAAAAGH.
17:45:22 <mmorrow> p_l: hmm
17:45:23 <jmcarthur> mmorrow: WTF
17:45:24 <p_l> thoughtpolice: I sometimes wonder if PHP isn't more damaging than COBOL ;-)
17:45:37 <mmorrow> fortran rulz!
17:45:44 <pikhq> jmp %eax
17:45:46 <pikhq> Really.
17:45:49 <Freidenker> Thank you for your time Saizan
17:45:50 <pikhq> AAAAAGH!
17:46:07 <pikhq> p_l: COBOL at least has an excuse to exist.
17:46:17 <pikhq> It was an extension to the very first programming language.
17:46:18 <FunctorSalad> I didn't even know you could install gtk on windows at all
17:46:26 <p_l> pikhq: nah, small, register starved x86. try having 224 registers in a window :D
17:46:34 <pikhq> (well, extension to an extension)
17:46:39 <thoughtpolice> p_l: ADD 20 YEARS TO COBOL GIVING PHP ?
17:46:46 <Saizan> Freidenker: i don't remember many complications, but it's been a while since i've used windows, it might also be a problem of mismatching users
17:46:57 <p_l> thoughtpolice: haha
17:47:01 <FunctorSalad> on linux it's easy, Freidenker ;)
17:47:10 <Freidenker> If I can't male Gtk/Cairo/Haskell works on windows I'm screwed, I won't be able to use Haskell for my thesis, it's that simple ;(
17:47:16 <Freidenker> I'm on linux
17:47:22 <Freidenker> My supervisors aren't
17:47:47 <p_l> Freidenker: hey, at least you have working bindings that don't require X Server :P
17:47:49 <FunctorSalad> I see.
17:47:55 <FunctorSalad> what are you doing with cairo?
17:48:29 <Freidenker> Drawing rather complex plot and trees (phylogenetic trees, I'm a theoretical biologist)
17:49:10 <Twey> Freidenker: It's included with recent versions of GTK+
17:49:32 <Twey> Just use the installer from http://www.gtk.org/download-windows.html
17:49:47 <FunctorSalad> Freidenker: maybe use opengl? random thought
17:49:55 <FunctorSalad> (I haven't actually used HOpenGl on windows)
17:50:17 <Twey> Full bundle here: http://ftp.gnome.org/pub/gnome/binaries/win32/gtk+/2.16/gtk+-bundle_2.16.2-20090601_win32.zip
17:50:38 <Twey> For the Haskell libraries you want, Cabal is probably the easiest way to go
17:51:01 <Saizan> Twey: the gtk2hs bundle for windows contains the C dlls too
17:51:02 <Freidenker> I've installed the bundle, and I have the nice little libcairo-2.dll, but it doesn't seem to work (or I don't know where to put it).
17:51:43 <Freidenker> But anyway Cairo's dll is already in gtk2hs\0.10.1\bin ...
17:51:45 <Saizan> Twey: and the problem is on the haskell side of things, apparently ghc-pkg doesn't see the cairo haskell package as installed
17:52:30 <Saizan> Freidenker: do any other of the gtk2hs packages got installed?
17:52:51 <Freidenker> No.
17:53:38 <Freidenker> I'm going to try to reinstall everything.
17:53:44 <Saizan> does the ghc version match the version for which the bundle is built?
17:54:30 <Freidenker> Yes.
17:54:48 <Freidenker> Anyway I'm trying to reinstall everything and I'll see
17:55:07 <Freidenker> Thanks for the help
17:55:21 <Twey> Saizan: Ah, I see :-\
17:55:24 <conal> copumpkin: thx much for the nearlyfreespeech.net recommendation.  i'd forgotten about them, and i like their philosophy!
17:55:29 <Twey> There's always Cygwin.
17:56:29 * mmorrow realizes what it would mean for functions to have multiple entrypoints and *only* one exit
17:56:53 <thoughtpolice> conal: nearlyfreespeech.net is awesome
17:56:55 <Twey> C-style switch?
17:57:11 <mmorrow> no, it'd be the complete opposite of functions as we know them
17:57:15 <conal> :)
17:57:38 <mmorrow> all paths of control in the function would eventually lead to the same point
17:57:43 <pikhq> ... The inverse of the function.
17:57:46 <thoughtpolice> conal: been using them for a while now - always online, very good web interface (none of that ridiculous cpanel shit that I can't understand,) awesome tech. support, really flexible. it is, as they would say on the internet, 'made of win'
17:57:50 <thoughtpolice> :)
17:58:00 <thoughtpolice> conal: oh, and cheap as dirt
17:58:01 <SamB> mmorrow: you'd be surprised how often that happens in assembly code ;-)
17:58:02 <thoughtpolice> that is a huge plus
17:58:15 <conal> thoughtpolice: wonderful.  i've been looking at 1and1.com and hostgator.com .  inexpensive, but i get annoyed with all the quirky details.
17:58:21 <mmorrow> SamB: there also would be no definable entrypoint
17:58:54 <conal> thoughtpolice: does nearlyfreespeech have emacs?  hostgator doesn't.  if i have to edit on the web server, i'd much rather use emacs than vi.
17:59:10 <thoughtpolice> conal: I put like $55 on my NFS account several months ago when I got my site (something like early march,) and I currently have 45.85 USD
17:59:20 <conal> thoughtpolice: :)
17:59:27 <thoughtpolice> conal: I actually haven't checked; I'll SSH in right quick and see
17:59:46 <Twey> conal: Hooray for TRAMP
17:59:59 <conal> Twey: TRAMP?
18:00:08 <thoughtpolice> conal: yes, they do - emacs 22.3.1
18:00:11 <Twey> conal: emacs' remote-editing interface
18:00:24 <conal> Twey: oh, yeah!
18:00:30 <Twey> You don't need to have emacs on the server: you can edit the file via SSH or FTP
18:00:31 <conal> thoughtpolice: awesome.  thanks!
18:00:45 <thoughtpolice> conal: oh and one more thing on the price note - that is my current costs over the past 3 months or so
18:00:59 <thoughtpolice> conal: along with both 1) registrar protection and 2) emails for my domain
18:00:59 <conal> Twey: oh, i see.  very cool.  i'm on satellite, and the per-keystroke latency drives me bonkers!
18:01:05 <Twey> (it's more efficient that way, too, since you don't have to send every keystroke to the server)
18:01:07 <thoughtpolice> so, as I said, it's cheap as dirt :)
18:01:08 <Twey> Right :-D
18:01:13 <thoughtpolice> email is .01c USD per day
18:01:21 <thoughtpolice> privacy on the registrar is .02c USD per day
18:01:23 <thoughtpolice> quite reasonable
18:01:25 <Twey> Satellite Internet?  Where are you, the South Pole?  :-P
18:01:33 <thoughtpolice> I will only spend about 9$ on that this entire year :)
18:01:49 <conal> thoughtpolice: two hundredths of one cent per day?
18:01:59 <Twey> Oh, you actually did mean 0.02¬¢
18:02:03 <Twey> Haha
18:02:07 <thoughtpolice> er, yeah
18:02:09 <mmorrow> {entry(int y); z = x + y;} {entry(char *s, double d); z = strlen(s) + (long)d;} int z; int x = 42; print(z); halt();
18:02:16 <Twey> That's pretty cool
18:02:30 <Twey> I thought it was an error too, initially
18:02:31 <thoughtpolice> conal: :P 2 cents per day for registrar privacy, 1 cent per day for email
18:02:33 <conal> Twey: i live in the woods, away from civilization.  no dsl or cable here.  :(  everything else about living here is great.
18:02:36 <mmorrow> err, i couldn't call print or halt like that
18:02:36 <Twey> thoughtpolice: Oh
18:02:39 <Twey> That's not so cool
18:02:41 <conal> thoughtpolice: oh, okay.
18:02:57 <Twey> conal: Nice
18:03:06 <thoughtpolice> so yeah, only like $9 for an entire year.
18:03:14 * Twey plans to move to a Finnish forest some day
18:03:17 <conal> Twey: yeah.  it's beautiful here.
18:03:17 <thoughtpolice> conal: but I seriously have 0 complaints about NFS
18:03:19 <mmorrow> bah, you couldn't even program remotely like anything you've ever programmed like
18:03:22 <conal> Twey: nice :)
18:03:34 <Twey> Client suits me better than this one :)
18:03:37 <Twey> Er, climate
18:03:47 <Twey> Damn you, brain-farts.
18:04:19 <conal> gerard huet told me that when he was implementing higher-order unification for his phd, he used a 300 baud terminal about 100 km from the computer.
18:04:22 <Twey> Oh right
18:04:37 <Twey> conal: Hahaha :-D
18:04:46 <pikhq> conal: Oh, you too are on satellite?
18:04:47 <conal> Twey: yeah!
18:04:48 <pikhq> Fun.
18:04:56 <conal> pikhq: yup.
18:04:58 <shapr> Twey: I've been there, it's cold.
18:05:04 <Twey> conal: How fast is your satellite Internet?
18:05:07 <Twey> shapr: I know :)
18:05:44 <conal> gerard was my external thesis committee member, and when he came for my defense (on higher-order unification (HOU) for dependent types), he gave me a print-out from his early HOU days.  :)
18:06:06 <mmorrow> SamB: hmm, actually one thing that would be pretty much this exactly would be a computer completely driven by async interrupts, each of which trigger some path of execution, all of which converge to the same single instruction
18:06:11 <noteventime> I'm having trouble with the Binary instance of IntMap, it's not known to have issues, is it?
18:06:11 <Twey> I think slow Internet is a boon in some ways.
18:06:19 <conal> Twey: theoretically 512Kbps down & 100Kbps up.  the latency is what kills me.
18:06:22 <Twey> Harder to get distracted, but you can still look things up if you need to.
18:06:23 <conal> Twey: yeah?
18:06:23 <noteventime> Err, the other way around :p
18:06:24 <shapr> Because it's faster to write your own sourcecode?
18:06:29 <Twey> shapr: Hahaha
18:06:31 <FunctorSalad> mmorrow: you mean programs, not literally "relations with at most one element from the right set appearing", right?
18:06:37 <shapr> Twey: Your answer makes more sense actually.
18:07:01 <Twey> I have this horrible tendency to continue finding new things to do instead of actually doing any of them.
18:07:12 <mmorrow> FunctorSalad: what it would mean if instead of one entry/multiple exits, "functions" instead had multiple entries/one exit
18:07:22 <Twey> Cofunctions!
18:07:23 <mmorrow> and *only* one exit
18:07:34 * SamB plots to sever Twey's internet connection
18:07:42 <Twey> SamB: Haha
18:07:45 <Twey> Noo!
18:08:03 <FunctorSalad> yeah was just disambiguating functions as in programs vs. functions as in certain relations
18:08:03 <SamB> Twey: you best start downloading documentation and potential dependencies, buddy!
18:08:07 <FunctorSalad> (a pure/mathematical function to the one-element set isn't very interesting :))
18:08:14 <thoughtpolice> Twey: true that
18:08:15 * Twey laughs.
18:08:21 <Saizan> noteventime: there should be a thread on -cafe on that
18:08:33 <thoughtpolice> Twey: much harder to get distracted by things when they load slow ahell :)
18:08:59 <Twey> thoughtpolice: *nod*
18:09:05 <FunctorSalad> my connection is currently such that the package loss is continually one notch before being enough to disconnect me from irc... (it's only coming through in waves)
18:09:08 <thoughtpolice> Twey: I was thinking of rewriting this for Mac OS X - http://thomer.com/lockout/
18:09:17 <thoughtpolice> Twey: because apparently nobody has done it yet, and it looks like a good idea
18:09:34 <Twey> Oh, awesome.  Arch now includes Haskell docs for all their packages.
18:09:51 <noteventime> Saizan: About memory issues while decoding, right?
18:10:32 <pikhq> mmorrow: I think I'm going to call that a noitcnuf.
18:10:53 <Saizan> noteventime: right
18:11:19 <Saizan> noteventime: i'm a bit surprised they aren't fixed by now
18:11:22 <noteventime> I keep getting "Too few bytes" whenever I try to decode :|
18:11:32 <conal> thoughtpolice: on the NFS faq, "You can run CGI lisp, perl, python, ruby, and tcl scripts by putting them in your web space and giving them a .cgi extension".  can they do haskell?
18:11:34 <Twey> thoughtpolice: Wow
18:11:38 <noteventime> I guess I'd better check my types
18:11:39 <Twey> A virtual chastity belt
18:12:01 <noteventime> The weird thing is, I different positions each time
18:12:03 <thoughtpolice> conal: yep!
18:12:04 <Saizan> noteventime: ah, that sounds different, like you were trying to decode it back with the wrong types, yeah
18:12:11 <thoughtpolice> conal: http://example.nfshost.com/versions.php
18:12:19 <thoughtpolice> conal: they have GHC 6.8.3 up right now
18:12:28 <conal> thoughtpolice: wowzers.  :)
18:12:30 <noteventime> Saizan: But why do I get different positions each time?
18:14:00 <thoughtpolice> conal: it's awesome, yes. :) I was thinking of putting in a report to have them upgrade to GHC 6.10, but I'm not sure if 6.10 is available for FreeBSD (their server OS)
18:14:56 <thoughtpolice> conal: but regardless, for such cheap hosting, CGI options like that are fantastic indeed :)
18:15:56 <Saizan> noteventime: decoding from the same bytestring?
18:16:04 <jmcarthur> thoughtpolice: afaik, 6.8.3 is the latest GHC available for the BSDs
18:16:05 <conal> thoughtpolice: and how
18:16:23 <conal> NFS looks way better than the options i was looking into
18:16:31 <Saizan> noteventime: it's not like you're using hGetContents and hClose the Handle too?
18:16:46 <thoughtpolice> conal: told ya! 0 complaints from me!
18:16:57 <thoughtpolice> conal: although lpsmith earlier did bring up that they don't do SSL apparently
18:17:07 <Saizan> thoughtpolice: fastcgi or only plain cgi?
18:17:11 <conal> thoughtpolice: i just noticed the no-ssl in the faq
18:17:11 <thoughtpolice> (for incoming site connections, afaics)
18:17:16 <noteventime> Saizan: It was a type error :)
18:17:23 <jmcarthur> one downside to NFS is lack of SSL and lack of persistent processes like FastCGI
18:17:40 <Saizan> jmcarthur: ah!
18:17:46 <kbateman> I've got 8 Word8's.  How do I make a Double from them?
18:18:03 <thoughtpolice> jmcarthur: that's what I thought (re: ghc versions)
18:18:04 <conal> jmcarthur: good to know
18:18:25 <thoughtpolice> jmcarthur: can ghc 6.10 simply not build on BSD? or are you not aware?
18:18:35 <kbateman> I'm working on icfp2009.
18:18:40 <Saizan> kbateman: the popular thing seems to be bitshifting them into a Word64 and then using unsafeCoerce
18:18:46 <jmcarthur> thoughtpolice: it's not in ports or pkgsrc, is all i know
18:18:53 <thoughtpolice> jmcarthur: fair enough :)
18:18:57 <jmcarthur> thoughtpolice: and even 6.8.3 doesn't build on dragonfly
18:19:18 <thoughtpolice> jmcarthur: really? :/
18:19:21 <jmcarthur> yeah
18:19:32 <thoughtpolice> I was going to go through the task of porting GHC onto dragonfly since I think it's a really cool system
18:19:38 <jmcarthur> i just started looking into the BSDs and i find the haskell situation a bit frustrating
18:19:39 <thoughtpolice> a while back, anyway
18:19:43 <Saizan> kbateman: otherwise you can use Foreing.Marshal.Array.newArray and peek
18:19:47 <kbateman> Saizan: Through an unboxed array?
18:19:48 <jaredj> i was thinking haskell + plan 9
18:19:48 <jmcarthur> can't say i haven't thought about it myself
18:19:52 <thoughtpolice> jmcarthur: yes, SPJ sent out an email along those lines
18:19:59 <thoughtpolice> that GHC HQ needs more BSD hackers
18:20:27 <jmcarthur> dragonfly's goal of making clustering as easy as SMP sounds awesome too, if it's even realistic
18:20:35 <Saizan> kbateman: no, using Data.Bits
18:20:36 <jmcarthur> and it would be great to have GHC working on that
18:20:45 <jaredj> giggity
18:20:46 <thoughtpolice> jmcarthur: for sure!
18:21:13 <jaredj> is there a random monad?
18:21:23 <jmcarthur> @hackage MonadRandom
18:21:23 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/MonadRandom
18:21:25 <kbateman> Saizan: oh, you mean for a Word64 to a Double?
18:21:26 <thoughtpolice> jmcarthur: I would be interested in getting GHC working on Dragonfly, but I am already still battling GHC HEAD to get it to work on OS X 64-bit, and after that I have plans to try and get a copy of HEAD on my linux/ppc64 box
18:21:30 <jaredj> schweet
18:21:47 <jmcarthur> thoughtpolice: i have not even looked into what would be necessary
18:21:50 <FunctorSalad> jaredj: monte-carlo
18:21:53 <jmcarthur> and i'm a newb to the BSDs as it is
18:22:00 <saml> join #haskell-blah
18:22:28 <Saizan> kbateman: no, from [Word8] to Word64, you use fromIntegral on the Word8s, shift them of the right amount and "or" them together
18:22:42 <thoughtpolice> jmcarthur: well, if you would ever like to give it a shot let me know and I'd be interesting in helping. :) dragonfly is a really cool operating system
18:22:46 <Saizan> kbateman: though the Foreing approach might be better
18:22:58 <thoughtpolice> jmcarthur: I've used it on and off since the DFBSD 1.2 release
18:22:59 <kbateman> I can handle converting words, it's just the Word -> Double transition I'm having trouble with.
18:23:05 <thoughtpolice> which, was, to say the least, very painful :)
18:23:24 <Saizan> kbateman: once you've Word64 you can use unsafeCoerce
18:23:25 <kbateman> I'm thinking the most kosher way to do it is through Foreigh.Ptr.castPtr
18:23:27 <jmcarthur> thoughtpolice: sweet. i will let you know if i decide to look more into it
18:24:13 <Saizan> kbateman: yeah, that'd be the Foreign route :)
18:24:36 <Saizan> kbateman: and you can use newArray to avoid the bit fiddling too
18:25:10 <EvilTerran> ah, a brief visit to the metal to shuffle some bytes
18:26:04 <shapr> And then back into the world of plastic!
18:26:22 <Gracenotes> hm. the biggest area for any given perimeter is probably a circle, right?
18:26:47 <shapr> Assuming it's not a fractal...
18:27:19 <FunctorSalad> that would seem to hurt rather than help
18:27:44 <FunctorSalad> (or make the area outright undefined ;))
18:29:19 <FunctorSalad> I'm curious how you'd go about proving that the circle is the solution :)
18:30:04 <FunctorSalad> it'd involve measure theory I suppose
18:30:55 <jaredj> how do i do something six times in a monad?
18:31:03 <jaredj> and get six values?
18:31:14 <Gracenotes> replicateM, I'd wager
18:31:19 <jaredj> thx
18:31:24 <kbateman> Saizan: So, then it's import Foreign.Marshal.Array, mallocArray, 8x pokeArray, castPtr, readArray.  The array get's GC'd?
18:31:36 * roconnor wishes energy was conserved
18:31:59 * kbateman can't believe he just used a grocer's apostrophe
18:32:06 <mmorrow> roconnor: it is, just not how we'd like it to be ;)
18:32:29 <Gracenotes> FunctorSalad: hm... you might be able to show that the area/perimeter ratio for regular convex polygons increases for more sies
18:32:34 <Gracenotes> sides
18:32:39 <mmorrow> kbateman: if you mallocArray, you have to free it
18:33:03 <mmorrow> kbateman: malloc* in foreign is (in ghc) C malloc()
18:33:26 <mmorrow> (and free is C free())
18:33:30 <Gracenotes> FunctorSalad: at least it might be a simpler proof than proving it for any closed curve
18:33:32 <PhDP> Good news ! Cairo works (maybe) on Windows
18:33:51 <Gracenotes> and by that logic, a circle is probably as good as you can go, although that's just intuition
18:34:06 <FunctorSalad> Gracenotes: but a priori you have a huge set of candidates (all measurable sets). maybe there's some simple argument to exclude all the "exotic" sets
18:34:47 <Freidenker> But ! I still can't compile the example from http://darcs.haskell.org/gtk2hs/docs/tutorial/Tutorial_Port/app1.xhtml (which works fine in Linux). I now get a "not in scope 'eventSent'. Why do I get only this error on windows ?
18:35:10 <kbateman> mmorrow: where is freeArray?  I vaguely remember that FFI has finalizers on data allocated like this
18:35:35 <FunctorSalad> Gracenotes: I guess you can exclude disconnected sets by a "merge them and the ratio will improve" argument
18:35:59 <mmorrow> kbateman: all mallocArray does is  mallocArray n = mallocBytes (sizeOf (undefined::a)) :: (Storable a) => Ptr a
18:36:11 <mmorrow> kbateman: so you just use free
18:36:14 <Gracenotes> FunctorSalad: well, looks like there is an answer: http://en.wikipedia.org/wiki/Isoperimetric_inequality
18:36:20 <mmorrow> err, oops
18:36:29 <mmorrow> mallocArray n = mallocBytes (n * sizeOf (undefined::a)) :: (Storable a) => Ptr a
18:36:45 <Gracenotes> apparently the Greeks had an inkling about it :)
18:37:02 <mmorrow> and mallocBytes (in ghc) is a thin wrapper over foreign import ccall unsafe "malloc" :: CSize -> IO (Ptr a)
18:37:23 <mmorrow> * foreign import ccall unsafe "malloc" c_malloc :: CSize -> IO (Ptr a)
18:37:24 <Gracenotes> but the first proof appeared later
18:37:45 <kbateman> Index to the rescue.  Foreign.Marshal.Alloc.free
18:37:55 <mmorrow> @hoogle free
18:37:56 <lambdabot> Foreign.Marshal.Alloc free :: Ptr a -> IO ()
18:37:56 <lambdabot> package free-theorems
18:37:56 <lambdabot> Distribution.System FreeBSD :: OS
18:38:18 <kraaaj> hello room
18:39:06 <mmorrow> > fix (error . ("OH HAI"++))
18:39:10 <lambdabot>   "* Exception: OH HAI* Exception: OH HAI* Exception: OH HAI* Exception: OH H...
18:39:15 <mmorrow> aww, too late :(
18:40:04 <Saizan> kbateman: withArray word8s (\ptr -> peek (castPtr ptr) :: IO Double)
18:40:31 <mmorrow> does that use alloca, or bracket malloc free?
18:40:36 <Saizan> kbateman: that frees the array too
18:40:46 <Twey> :t bracket
18:40:48 <lambdabot> Not in scope: `bracket'
18:40:51 <mmorrow> @src bracket
18:40:52 <lambdabot> bracket before after thing = block $ do
18:40:52 <lambdabot>     a <- before
18:40:52 <lambdabot>     r <- catch (unblock (thing a)) (\e -> do { after a; throw e })
18:40:52 <lambdabot>     after a
18:40:52 <lambdabot>     return r
18:40:54 <kbateman> withArray ftw!
18:41:01 <Twey> Huh.  Why's it not in :t?
18:41:14 <Saizan> mmorrow: allocaArray, apparently
18:41:26 <marceau> #mozilla
18:41:39 <Twey> marmolak: #emacs
18:41:43 <mmorrow> #zillamoo
18:42:03 <Twey> Hehe
18:42:46 <mmorrow> that's like a milk-producing reptile from the galapogos islands iirc
18:44:59 <jaredj> haskell coding style document?
18:44:59 <Twey> But does it give you yak butter for your tea?
18:45:11 <jaredj> bah lmgtfy
18:45:18 <Twey> o.@
18:45:28 <Twey> Heh
18:46:15 <Twey> http://urchin.earth.li/~ian/style/haskell.html
18:49:40 <kbateman> bs2double s = unsafePerformIO $ withArray (B.unpack s) (peek . castPtr)
18:50:06 <kbateman> but it will only work if your machine is little-endian
18:51:37 <Saizan> kbateman: you could avoid a copy (or two) by using Data.ByteString.Internal and getting its internal pointer
18:52:00 <Saizan> but that depends on how much you care :)
18:52:35 <kbateman> I am through with sullying myself with these mere low-level details. :)
18:52:46 <inimino> hehe
18:53:08 <kbateman> All I know is that bs2double (B.pack  B.pack [0,0,0,0,0,0,0xf0,0x3f]) = 1.0
18:53:10 <inimino> it won't even materially affect performance
18:54:08 <kbateman> Actually, I don't think that using the ByteString ptr will work because the alignment can be wrong.
19:00:39 <desp> Is it possible to define symbolic unary prefix operators?
19:03:24 <the_unamker> why haskell over common lisp?
19:03:31 <the_unamker> or smalltalk 80?
19:06:19 <iago> the_unamker, Haskell is better
19:07:00 * Twey chuckles.
19:07:05 <pikhq> ... The fnuck?
19:07:24 * pikhq goes to pass around some infinite lists
19:07:53 <idnar> smalltalk 69!
19:11:14 <jaredj> i have some functions in a map
19:11:15 <FunctorSalad> the type system!:D
19:11:15 <FunctorSalad> and no mercy for side effects!:D
19:11:31 <jaredj> i want to look up a function and return id if there wasn't anything in the map
19:11:49 <jaredj> i can't figure out what Data.Maybe function i want to use
19:13:02 <FunctorSalad> jaredj: fromMaybe id (lookup foo myMap)
19:13:28 <jaredj> aha thx
19:13:56 <conal> thoughtpolice: still there?
19:14:05 <jaredj> now if the functions are monadic -
19:14:11 <jaredj> fromMaybe return (lookup foo myMap)?
19:14:45 <conal> copumpkin: ping
19:14:48 <copumpkin> hi :)
19:14:55 <conal> copumpkin: i'm signing up for nearlyfreespeech.net, and i haven't yet found and IP address to use for directing my domain name (registered elsewhere) to NFS.
19:15:17 <conal> (found an)
19:15:17 <copumpkin> oh, they tell you in the control panel iirc
19:15:22 <copumpkin> but I use them as my domain registrar too
19:15:33 <conal> oh, i'll keep looking.  thx.
19:16:15 <conal> copumpkin: is the "control panel" the thingy with "member home", "profile", "accounts", etc?
19:16:24 <copumpkin> yeah
19:16:31 <conal> thx
19:17:12 <Twey> :t fromMaybe
19:17:14 <lambdabot> forall a. a -> Maybe a -> a
19:17:14 <Twey> :t maybe
19:17:15 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
19:17:35 * FunctorSalad can't think of a domain name, so he doesn't have a domain
19:17:35 <Twey> Ah, right, map of functions.
19:17:51 <copumpkin> I took pumpkinpat.ch
19:17:55 <Twey> FunctorSalad: functorsalad.com seems free
19:17:57 <mmorrow> haha
19:18:03 <mmorrow> copumpkin: nice
19:18:06 <copumpkin> :)
19:18:06 <Twey> Yeah :-D
19:18:31 <FunctorSalad> Twey: but it's not perfect
19:18:31 <FunctorSalad> ;)
19:18:38 <Twey> Eh
19:18:41 <Twey> Domains are cheap :)
19:19:30 <FunctorSalad> Twey: but distributing your new email address to everyone isn't
19:20:02 <copumpkin> is there a good type-family-based type-level peano library?
19:20:20 <FunctorSalad> it must be really witty, but not pretentious
19:20:28 <FunctorSalad> I usually end up hating my chosen nickname after some months
19:21:25 <pikhq> ... Months?
19:21:28 <pikhq> I've used this nick since I was 8.
19:22:13 <FunctorSalad> pikhq: I choose a new one for every place, and they all suck
19:22:13 <FunctorSalad> ;)
19:22:13 * mmorrow notes that emacs.vi is still available
19:22:27 <FunctorSalad> cool
19:23:14 <mmorrow> , $(nat 12)
19:23:17 <lunabot>  S (S (S (S (S (S (S (S (S (S (S (S Z)))))))))))
19:23:25 <mmorrow> , toInt $(nat 12)
19:23:28 <lunabot>  12
19:23:38 <mmorrow> , nest $(nat 12) (:[]) 42
19:23:41 <lunabot>  luna: Couldn't match expected type `GHC.Types.Int'
19:23:48 <mmorrow> , [$ty| nest |]
19:23:50 <lunabot>  Int -> Doc -> Doc
19:23:55 <mmorrow> um
19:24:04 <mmorrow> , [$ty| nested |]
19:24:07 <lunabot>  luna: Exception when trying to run compile-time code:
19:24:12 <mmorrow> bah, i forgot!
19:24:19 <pikhq> FunctorSalad: Lame.
19:25:12 <mmorrow> ahh
19:25:16 <mmorrow> , nesty $(nat 12) (:[]) 42
19:25:18 <FunctorSalad> pikhq: why of course
19:25:19 <lunabot>  [[[[[[[[[[[[[42]]]]]]]]]]]]]
19:25:39 <mmorrow> , nesty (S (S (S (S (S (S (S (S (S (S (S (S Z)))))))))))) (:[]) 42
19:25:40 <Twey> What's nat?
19:25:41 <lunabot>  luna: Ambiguous occurrence `S'
19:25:46 <mmorrow> sigh
19:26:21 <Twey> , [$ty| nat |]
19:26:24 <lunabot>  Int -> ExpQ
19:26:30 <mmorrow> Twey: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2166
19:26:38 <Twey> Ah!  Right.
19:27:09 <mmorrow> it just uses TH to avoid tediously typing out (S (S (....)), but it doesn't rely on TH
19:27:16 <mmorrow> (nest doesn't rely on TH, that is)
19:27:26 <FunctorSalad> @type LamE
19:27:27 <lambdabot> Not in scope: data constructor `LamE'
19:27:31 <mmorrow> , src 'LamE
19:27:34 <lunabot>  data Exp = ... | LamE ([Pat]) Exp | ...
19:27:34 <lunabot>  infixl 9
19:28:05 <mmorrow> , ppDoc <$> (do x <- newName "x"; lamE [varP x] (varE x))
19:28:07 <lunabot>  \x_0 -> x_0
19:28:16 <mmorrow> , $(do x <- newName "x"; lamE [varP x] (varE x)) 42
19:28:18 <lunabot>  42
19:28:43 <mmorrow> , $(do x <- newName "x"; lamE [varP x] (tupE (replicate 10 (varE x)))) 42
19:28:45 <lunabot>  (42,42,42,42,42,42,42,42,42,42)
19:29:41 <mmorrow> , $(do x <- newName "x"; lamE [varP x] (let f e = tupE (replicate 10 e) in (f . f) (varE x))) 42
19:29:42 <lunabot>  ((42,42,42,42,42,42,42,42,42,42),(42,42,42,42,42,42,42,42,42,42),(42,42,4...
19:29:48 <mmorrow> TH++
19:30:25 <mmorrow> , $(do x <- newName "x"; lamE [varP x] (let f e = tupE (replicate 2 e) in foldr (.) id (replicate 4 f) (varE x))) 42
19:30:27 <lunabot>  ((((42,42),(42,42)),((42,42),(42,42))),(((42,42),(42,42)),((42,42),(42,42...
19:31:07 <mmorrow> a purfect binary tuple tree
19:32:47 <jmillikin> In c2hs, is it possible to replace a prefix rather than just remove it?
19:33:27 <jmillikin> I'm working with a C library, and some of its enumerations conflict with existing Haskell type names. Unfortunately, the prefixes are weird, so I'd like to change them in the generated .hs file.
19:33:46 <mmorrow> jmelesky: iirc you can specify a prefix so you don't have to keep typing it, but i'm not sure what you mean by remove it
19:33:55 <mmorrow> ah, hmm
19:34:13 <mmorrow> jmillikin: i don't know
19:34:39 <jmillikin> For example, if the C has an enumeration PFXSYS_OK, I'd like to have the generated file be SystemOk
19:34:47 <jmillikin> **generated constructor, I mean
19:36:43 <mmorrow> jmillikin: hmm, if not possible, you could probably get it with some minor hacking, if you're willing to go there
19:37:35 <mmorrow> hmm, you might have a choice of which stage to hack to get this though
19:37:48 <jmillikin> I'll try, but you might not be happy with the result. I'm still very new to Haskell.
19:37:58 <mmorrow> jmillikin: best way to learn! ;)
19:38:46 <mmorrow> jmillikin: (this also sounds like a potentially useful feature)
19:39:22 <jaredj> i wrote a program that replaces sensitive financial data in OFX files with random letters and numbers, keeping the structure, so that the file can be shared.
19:39:54 <mmorrow> jaredj: hah, nice. i've wanted to do that with csv's of stuff before
19:39:55 <nainaide> help please:  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6287#a6287
19:39:55 <jaredj> should i call the hackage entry: (a) ofx1-anonymizer, (b) ofx1anon, (c) ofx1-anon, (d) partridge?
19:40:11 <nainaide> -- the prog works until add this line
19:40:22 <mmorrow> jaredj: "censor"
19:40:23 <nainaide> -- the prog works until add last line
19:40:41 <mmorrow> (is my 2-cents :)
19:41:15 <jaredj> mmorrow: excellent!
19:41:23 <mmorrow> jaredj: that sounds like a useful thing though that might be nice to make a generic (wrt file/data it operates on) interface to
19:41:36 <jaredj> well - ofx1 is an SGML application
19:41:52 <mmorrow> what's the core function like?
19:41:53 <jaredj> ah you're dreaming big i see
19:41:57 <mmorrow> :: String -> String ?
19:42:02 <mmorrow> heh, always ;)
19:42:13 <mmorrow> err, StdGen -> String -> String
19:42:16 <jaredj> euh yeah that's what it works out to
19:42:17 <mmorrow> or something?
19:42:35 * mmorrow would use that function all teh time
19:42:56 <inimino> is it still true that cabal is not included in debian?
19:43:26 <jaredj> anonymize :: [Tag] -> StdGen -> [Tag]
19:43:27 <Apocalisp> why is there no codo notation?
19:43:37 <jaredj> (from Text.HTML.TagSoup)
19:43:41 <inimino> i.e. after installing GHC through the packaging system you then have to install cabal manually?
19:43:45 <inimino> or am I missing something?
19:43:58 <mmorrow> jaredj: ah, tagsoup is nice
19:44:20 <jaredj> inimino: i haven't got any *cabal* packages, just ghc, and i've got cabal
19:44:35 <jaredj> oh wait i built cabal myself
19:44:40 <inimino> hm
19:44:53 <jaredj> jaredj@harpster:~$ which cabal
19:44:55 <jaredj> /home/jaredj/.cabal/bin/cabal
19:45:40 <inimino> yeah, ok
19:46:57 <mmorrow> nainaide: it works for me. are there tabs in your version?
19:47:08 <mmorrow> nainaide: (if not, then i don't know what's going wrong)
19:49:00 <nainaide> mmorrow, did you get the output from "putStrLn (concat dirs)" or just got the result from "mapM_ putStrLn dirs"
19:50:16 <nainaide> I tried but get nothing neither from "putStrLn (concat dirs)" nor "mapM_ putStrLn dirs"
19:51:36 * jmelesky wakes up
19:52:17 <jmelesky> ah. faulty tab-completion. i was not summoned.
19:53:21 <jmelesky> anyone else in here working on the icfp contest?
19:53:38 <jaredj> mkcabal? ... seriously?
19:53:39 <jaredj> argh
19:54:08 <jaredj> jmelesky: someone said they were about an hour ago
19:54:20 <jaredj> unfortunately i can't scroll back to see
19:55:04 <jmelesky> jaredj: hm. yeah, looks like there was some Word8/Word64/Double stuff going on
19:55:36 <jmelesky> i'm working in SML, not Haskell, and am having to manually unpack the doubles myself. good fun.
19:57:04 <sjanssen> jmelesky: SML doesn't have an unsafeCoerce backdoor like Haskell?
19:57:15 <sjanssen> or access to pointers?
19:58:57 <jmelesky> sjanssen: it may well do, but if so, i can't find documentation for it. the Basis library has some pack types, but they're optional, and apparently not implemented in sml/nj
19:59:36 <jmelesky> if nothing else, it's a good kata
20:01:06 <jaredj> what base do i need to depend on in my .cabal file?
20:01:19 <jaredj> >4? <5?
20:01:37 <copumpkin> Occurs check: cannot construct the infinite type: p = (->) (p x)
20:02:39 <Saizan> jaredj: an upper bound is preferred yes, the only way to know for sure if you also work with base-3 is to test
20:03:21 <Saizan> so, either base == 4.* or base >= 3 && < 5
20:03:58 <Saizan> don't use >4, because that excludes base-4.0.0.0, and includes base-4.0.0.1 which doesn't make sense
20:04:48 <inimino> so...
20:04:58 <jaredj> Saizan: cool thx
20:05:41 <inimino> ./bootstrap.sh in cabal-install says: "'parsec' is required but it is not installed"
20:05:53 <inimino> however 'ghc-pkg list' says: "parsec-3.0.0"
20:06:01 <inimino> in other news, Haskell support in Debian continues to suck
20:06:14 <Saizan> heh, it checks for parsec-2
20:06:36 <Saizan> however what it really needs is network
20:06:57 <Saizan> so you should be able to comment out the parsec check in the script
20:07:04 <Saizan> and still get it to work
20:07:07 <inimino> Saizan: well I already installed network by hand
20:07:11 <inimino> ok, I'll try that
20:07:52 <inimino> looks like it's making progress now :-)
20:09:14 <jaredj> requiring haskell98: old and busted or current?
20:09:19 <copumpkin> Nat n => (forall x. Nat x => a -> p x -> p (S x)) -> Vec a n -> p n
20:09:24 <jaredj> i.e. the haskell98 package
20:09:42 <FunctorSalad> <edwardk> Haskell 98 is the windows 98 of standards ;)
20:09:52 <inimino> ouch
20:09:55 <shapr> @quote edwardk
20:09:55 <lambdabot> edwardk says: ah the "scrap your boilerplate and replace it with mine" approach
20:10:08 <inimino> @quote 98
20:10:08 <lambdabot> dons says: C++: creating blub programmers since 1985
20:10:08 <Saizan> there's a difference between the haskell98 package and the haskell 98 standard
20:10:41 <inimino> @quote 98
20:10:41 <lambdabot> dons says: C++: creating blub programmers since 1985
20:11:41 <inimino> aww
20:13:16 <copumpkin> I don't quite understand what the type fold :: Nat n => (forall x. Nat x => a -> p x -> p (S x)) -> Vec a n -> p n means on http://www.opensubscriber.com/message/haskell-cafe@haskell.org/12388255.html
20:13:26 <jaredj> http://patch-tag.com/r/ofx1-censor/pullrepo
20:13:34 <jaredj> mmorrow ^
20:13:46 <copumpkin> it's similar to the induction type, where if you prove a statement for p x, you prove it for p (S x)
20:13:59 <copumpkin> but I don't understand how it all fits with the sized list thing
20:15:08 <Saizan> copumpkin: it looks like it lacks an argument for the empty list to me
20:15:09 <jaredj> do you haddock an executable?
20:15:20 <copumpkin> Saizan: that's what I was thinking
20:15:23 <jaredj> or just give it a usage message?
20:15:38 <copumpkin> Saizan: but the author sounds like he wrote those functions, so I'd think he'd have noticed if it was missing something
20:15:45 <Saizan> fold :: Nat n => p Z -> (forall x. Nat x => a -> p x -> p (S x)) -> Vec a n -> p n
20:16:06 <copumpkin> why in that order/
20:16:07 <Saizan> copumpkin: sometimes you retype instead of copypasting and make these silly errors :P
20:16:23 <copumpkin> oh, I did
20:16:31 <copumpkin> I suck
20:16:39 <Saizan> "you" as in "someone"
20:16:48 <Saizan> not you specifically
20:17:09 <Saizan> since the type of fold is like that in the email too
20:18:07 <copumpkin> oh yeah, I misread it the second time
20:18:12 <FunctorSalad> it's a fold like any other :) (except that it gives the second handler the extra information that the parameter can only be a nat)
20:18:27 <FunctorSalad> the handlers mirrors the constructors of the type
20:18:39 <copumpkin> Saizan: why did you put the types in that order though?
20:18:46 <FunctorSalad> (they specify the target F-algebra, if you want to put it like that)
20:18:50 <copumpkin> oh, just as the more traditional Nil | Cons order?
20:18:58 <Saizan> copumpkin: yeah
20:19:17 <Saizan> it's the same order as in foldr
20:19:28 <copumpkin> :t foldr
20:19:29 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
20:19:33 <Saizan> ops
20:19:39 <copumpkin> I've wondered about that
20:20:02 <Saizan> uhm i thought i was sufficiently awake and yet i'm not :)
20:20:08 <shapr> WAKE UP!
20:20:27 <copumpkin> :)
20:20:32 <copumpkin> now I need to figure out how to implement it
20:20:35 <copumpkin> this type stuff is so fun
20:21:04 <Saizan> how does your Vec look like btw?
20:21:11 <copumpkin> data Vec a n where
20:21:11 <copumpkin>   Nil :: Vec a Z
20:21:11 <copumpkin>   Cons :: a -> Vec a n -> Vec a (S n)
20:21:25 <copumpkin> is that ok?
20:21:30 <Saizan> yeah
20:21:34 <copumpkin> it feels like agda
20:21:56 <copumpkin> oh, I could probably put a Nat constraint on the n
20:22:23 <Saizan> mh, that might be required, yeah
20:22:40 <copumpkin> I just put it on the Cons
20:22:54 <copumpkin> might save me trouble later on, but for now it doesn't help me implement fold
20:23:07 <FunctorSalad> folds for gadts are a bit tricky
20:23:24 <FunctorSalad> (the return type must be parameterised if you want full generality)
20:23:34 * copumpkin isn't sure what that means :)
20:23:45 <inimino> cabal is installed, thanks Saizan
20:24:03 * Saizan tries
20:24:09 <Saizan> inimino: np
20:24:19 <FunctorSalad> copumpkin: well, you already had it right in the sig above... the fold returns a "p n", not just a "p"
20:24:42 <copumpkin> ah, that wasn't really me :)
20:24:46 <FunctorSalad> copumpkin: if it was just a p, you couldn't write the identity function as a fold, for example
20:25:16 <copumpkin> would it make sense to talk about a foldl too?
20:25:24 <FunctorSalad> (I hope I'm not missing sth here)
20:25:37 <copumpkin> oh I think I get how this is supposed to work
20:25:40 <copumpkin> (fold)
20:26:07 <jimmyjazz14> just curious why are compiled haskell binaries on the somewhat larger size?
20:26:24 <Saizan> it's not really that different from inductP
20:26:24 <copumpkin> they're mostly statically linked
20:26:33 <copumpkin> and not stripped
20:26:36 <copumpkin> Saizan: yeah
20:26:58 <copumpkin> or just induction
20:27:04 <copumpkin> since I'm not using the GADT he mentioned
20:27:04 <FunctorSalad> sure, producing a return type from each vec and proving a proposition about each vec are analogous by curry-howard
20:34:20 <copumpkin> hmm
20:37:07 <Saizan> copumpkin: you can implement fold without putting the Nat n => context into the Cons constructor
20:37:20 <copumpkin> yeah, I just figured that might help later on
20:37:50 <Saizan> it makes lengthIsNat more meaningful :)
20:38:09 <copumpkin> so one basic thing I need to understand
20:38:18 <copumpkin> what's the point of witnessNat?
20:39:14 <Saizan> constructing a value of the correct type, because we can't apply functions to types directly in haskell
20:41:06 <Saizan> but one could just use (undefined :: n), i think
20:41:12 <copumpkin> hmm
20:41:23 <copumpkin> so why is it so complicated?
20:41:45 <Saizan> its definition?
20:41:51 <copumpkin> yup, of witnessNat
20:41:59 <roconnor> bah
20:42:03 <roconnor> stupid unlazy inits!
20:42:13 <roconnor> @src inits
20:42:13 <lambdabot> inits []     =  [[]]
20:42:13 <lambdabot> inits (x:xs) =  [[]] ++ map (x:) (inits xs)
20:42:55 <Saizan> copumpkin: the mess comes out of having to wrap and unwrap in the Identity functor, i think
20:43:07 <copumpkin> hmm
20:43:24 <Saizan> copumpkin: because induction expects something of the form "p n", while we want just "n"
20:43:42 <copumpkin> ah
20:44:14 <copumpkin> ah, I think I see
20:44:29 <Saizan> btw instead of (undefined `asTypeOf` theWitness) one could just use theWitness, making it even more circular :)
20:44:51 <copumpkin> lol
20:45:19 <copumpkin> witnessNat = unI $ induction witnessNat (I Z) (I . S . unI)
20:45:20 <copumpkin> does that work?
20:45:52 <Saizan> no, because witnessNat is generalized
20:46:01 <Saizan> since you provide a signature
20:46:09 <Saizan> while theWitness is not
20:46:39 <copumpkin> ah
20:47:21 <Saizan> once you're inside the definition of witnessNat that 'n' is a fixed type, and theWitness is monomorphic due to the MR, so it all works out
20:50:52 <Saizan> with ScopedTypeVars "witnessNat :: forall n. Nat n => n; witnessNat = unI $ induction (witnessNat :: n) (I Z) (I . S . unI)" should work
20:51:49 <roconnor> w00t, got 67.77239729332393 points in my personal simulation
20:52:18 <FunctorSalad> w00t!
20:53:09 <|Jedai|> roconnor: You're doing ICFP ?
20:54:31 <roconnor> Yep
20:55:32 * copumpkin wants easy agda-like holes
20:55:52 <copumpkin> undefined works but I want to be able to see its inferred type
20:55:53 <asdfsdf> http://www.my-first-time-naked.net/?id=9378357
20:55:59 <copumpkin> @where ops
20:55:59 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
20:55:59 <lambdabot> mauke
20:56:34 --- mode: ChanServ set +o dibblego
20:56:37 --- kick: asdfsdf was kicked by dibblego (dibblego)
20:56:43 --- mode: dibblego set -o dibblego
20:58:55 <copumpkin> I still admire the ingenuity of whoever came up with that scheme, but damn it's annoying
21:02:29 * Saizan wonders if there's a way to write closed type functions on Nat n
21:02:43 <copumpkin> fold z f xs = induction witnessNat z undefined -- :D
21:02:46 <copumpkin> ;)
21:02:54 * copumpkin feels lame
21:03:14 <copumpkin> so I should probably break it down to xs as Nil and xs as Cons
21:03:50 <copumpkin> right?
21:05:49 <SubStack> aha, finger trees
21:05:55 <copumpkin> ?
21:07:08 <Saizan> copumpkin: yeah, i use caseNat rathen than induction
21:07:17 <copumpkin> oh
21:07:23 <copumpkin> that might be easier actually, I didn't think of it
21:07:35 <copumpkin> hrm
21:07:38 <copumpkin> this is so mind-bending :P
21:10:18 <copumpkin> I'm trying to think about it as wanting to do vec2List and calling fold with [] and (:)
21:10:23 <copumpkin> will that mess me up?
21:10:59 <copumpkin> the type of the second parameter of fold is confusing
21:12:37 <Saizan> copumpkin: you can't directly call fold with [] and (:)
21:12:50 <Saizan> because [a] doesn't match p n
21:12:55 <copumpkin> yeah
21:12:59 <copumpkin> hrm
21:13:02 <Saizan> you'd have to wrap it in K
21:13:20 <Saizan> so that K [a] n matches p n but still produces only a list
21:14:26 <copumpkin> ah
21:14:35 <copumpkin> makes sense
21:14:45 <copumpkin> I was thinking of const, but that's effectively the same thing at the type level?
21:14:53 <Saizan> yeah
21:16:19 <Saizan> vec2List = fold (K []) (\x (K xs) -> K (x:xs))
21:16:40 <jmillikin> @pl f c = g c >>= return . toEnum . fromIntegral
21:16:40 <lambdabot> f = ((toEnum . fromIntegral) `fmap`) . g
21:16:40 <copumpkin> Saizan: with unK, right?
21:17:54 <Saizan> right
21:22:18 <copumpkin> Saizan: would it be easier for me to explicitly put the value of the length in the Cons constructor?
21:22:38 <copumpkin> Cons :: Nat n => a -> n -> Vec a n -> Vec a (S n)
21:22:43 <copumpkin> or something like that
21:23:05 <copumpkin> feels uglier if it isn't ridiculous
21:24:16 <Saizan> that's more like agda
21:24:28 <pragma_> :(
21:24:34 <Saizan> however i don't know if it helps much
21:24:36 <pragma_> I am sad that I cannot understand what that means.
21:24:43 * BMeph is reminded of slava pestov and Factor's BOA Constructors...
21:24:55 <copumpkin> the type errors I'm getting now are really clearing out my sinuses
21:25:07 <Saizan> copumpkin: hpaste?
21:25:15 <|Jedai|> copumpkin: The fold can be written normally, you know
21:25:27 <|Jedai|> copumpkin: like a normal foldr
21:25:28 <copumpkin> I just got rid of a nasty pile of crap I had written
21:25:37 <Saizan> yeah, if you have Nat n => in the cons the fold just looks like foldr
21:25:44 <copumpkin> yeah, I do
21:25:45 <copumpkin> hrm
21:25:46 <|Jedai|> > fold :: Nat n => (forall x. Nat x => a -> p x -> p (S x)) -> p Z -> Vec a n -> p n
21:25:46 <|Jedai|> > fold f z Nil = z
21:25:46 <|Jedai|> > fold f z (Cons x xs) = f x (fold f z xs)
21:25:48 <Saizan> *Cons
21:25:49 <lambdabot>   <no location info>: parse error on input `='
21:25:49 <lambdabot>   Not in scope: type constructor or class `Nat'Not in scope: type constructor...
21:25:49 <lambdabot>   <no location info>: parse error on input `='
21:26:11 <copumpkin> |Jedai|: well, that's simple :) I'll with that for now, but it should be possible to write with induction, right?
21:26:24 <|Jedai|> Probably, or caseNat
21:28:36 <Saizan> with induction you probably need to use another 'p' instead of the 'p' in the signature for it
21:28:44 <copumpkin> ah
21:28:54 <|Jedai|> mySum :: (Num x, Nat n) => Vec x n -> x
21:28:54 <|Jedai|> mySum = unK . fold (\n (K m) -> K (n+m)) (K 0)
21:29:19 <copumpkin> don't steal all my fun! :P
21:29:22 <Saizan> in that you've to transform the property on Vec's into a property of Nat
21:29:25 <copumpkin> (but thanks :))
21:29:44 <Saizan> (and back in the end)
21:30:17 <copumpkin> how can I get the length of a Vec without folding const . (+1) over it?
21:31:28 <Saizan> as an Int?
21:32:06 <Saizan> with natToInteger on the 'n'
21:32:22 <copumpkin> oh, yeah
21:32:31 <mmorrow> jaredj: nice! :)
21:41:35 <pragma_> I'm learning me a Haskell for greater make benefit mankind.
21:42:24 * copumpkin is learning him a dependent haskell for greater make benefit copumpkin
21:42:45 <copumpkin> but am trying hard to avoid head asplosion
21:43:23 <pikhq> I'm learning Haskell for make benefit selfkind greater.
21:55:07 <Zrs> I'm learning Haskell for the greater make benefit mankind... But then I watched Eagle Eye, and now I'm fucking scared T_T
21:59:19 <Gracenotes> I learn Haskell to makefile benefit phony
21:59:50 <impl> oh hai Gracenotes
22:00:21 <Gracenotes> hello thar
22:00:43 <hackagebot> HsOpenSSL 0.6.2 - (Incomplete) OpenSSL binding for Haskell (MasatakeDaimon)
22:02:06 <m4k3r> mmh.. is there a way to put two elements into a listcomp for each iteration? Or I should use recursion?
22:02:55 <Twey> > [(x, x + 1) | x <- [1..5]]
22:02:57 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6)]
22:03:07 <Twey> > [(x, y) | x <- [1..5], y <- [1..5]]
22:03:08 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(1,5),(2,1),(2,2),(2,3),(2,4),(2,5),(3,1),(3,2),(3...
22:03:17 <m4k3r> nope, like [1,1,2,2,3,3]
22:03:22 <Twey> That latter is an extension, I think
22:03:23 <Twey> Oh
22:03:31 <Twey> Then no, but you can yield a list and concat them
22:03:46 <Twey> > concat [[x, x] | x <- [1..5]]
22:03:48 <lambdabot>   [1,1,2,2,3,3,4,4,5,5]
22:04:08 <impl> Gracenotes: Is this the language of the gods?
22:04:10 <Gracenotes> I wouldn't use a list comprehension...
22:04:10 <ski> > [x | x <- [1..5] , _ <- [(),()]]
22:04:12 <lambdabot>   [1,1,2,2,3,3,4,4,5,5]
22:04:13 <shachaf> Or you can use do-notation.
22:04:20 <copumpkin> > do x <- [1..5]; [x, x]
22:04:21 <lambdabot>   [1,1,2,2,3,3,4,4,5,5]
22:04:22 <shachaf> > do { x <- [1..5]; [x,x] }
22:04:23 <lambdabot>   [1,1,2,2,3,3,4,4,5,5]
22:04:36 <pikhq> Or you can use monad operators, and make noobs hate you.
22:04:36 <ski> works fine with list comprehension, as well
22:05:02 <pikhq> > [1..5] =>> \x -> [x,x]
22:05:03 <lambdabot>   Not in scope: `=>>'
22:05:03 <Twey> The monad instance works, too, of course (as with any list comprehension)
22:05:12 <pikhq> Erm. Totally mistyped.
22:05:13 <copumpkin> @undo > do x <- [1..5]; [x, x]
22:05:13 <ski> (pikhq : comonad ?)
22:05:13 <lambdabot> (> [1 .. 5] >>= \ x -> [x, x])
22:05:16 <pikhq> > [1..5] >>= \x -> [x,x]
22:05:18 <lambdabot>   [1,1,2,2,3,3,4,4,5,5]
22:05:20 <Twey> > [1..5] >>= \x -> [x, x]
22:05:21 <Twey> :)
22:05:24 <lambdabot>   [1,1,2,2,3,3,4,4,5,5]
22:05:26 <Twey> > [1..5] >>= replicate 2
22:05:27 <lambdabot>   [1,1,2,2,3,3,4,4,5,5]
22:05:32 <shachaf> @pl \x -> [x,x]
22:05:32 <lambdabot> ap (:) return
22:05:33 <Gracenotes> O_O
22:05:36 <pikhq> ski: I haven't the foggiest clue what a comonad is.
22:05:45 <Gracenotes> impl: a language, I'd wager
22:05:45 <impl> Gracenotes: My eyes are like forty times that size right now
22:05:45 <Twey> It's like a monad, but backwards.
22:05:48 <copumpkin> it's a monad bacwards!
22:05:48 <copumpkin> lol
22:05:52 <Twey> Haha
22:05:52 <copumpkin> damn you Twey
22:05:54 <Twey> :-P
22:05:56 <copumpkin> :)
22:06:11 <Gracenotes> impl: Haskell is the best list-frequency-modifying language out there!
22:06:31 <ski> m4k3r : so use my list comprehension solution above, or a monadic solution ..
22:06:50 <impl> Gracenotes: Well, see, I have this problem. Which is that usually I look through a language and I find all these flaws and I say 'blah screw this, not worth using' or at least 'if I use this, this is going to bug me'
22:06:58 <impl> Gracenotes: And I can't find those problems with Haskell :(
22:07:04 <Twey> Wait a second
22:07:11 <Twey> Ohh.
22:07:17 <Twey> I see.
22:07:36 <Twey> ski's LC solution confused me for a moment until I realised what was going on.  :-P
22:07:55 <impl> Twey: can you explain it? :<
22:07:56 <m4k3r> I have something like factor n = [n, x/n | x <-[2..n], n `mod` x == 0]
22:08:02 <Gracenotes> impl: it is a nice language
22:08:17 <m4k3r> oh *[1..sqrt n]
22:08:19 <Twey> impl: It's the same as [(x, y) | x <- [1..5], y <- [1..5]]
22:08:22 <copumpkin> > do x <- [1..5]; y <- [1,2]; return x
22:08:24 <lambdabot>   [1,1,2,2,3,3,4,4,5,5]
22:08:24 <Gracenotes> 1 is not a factor? :o
22:08:39 <Twey> Except we don't care about the last list, so its elements are just unit, and not included in the result
22:08:43 <Gracenotes> m4k3r: you might want to use divMod
22:08:52 <Twey> It's actually kind of hackish :-P  But cool for all that
22:08:52 <impl> Twey: I see
22:09:01 <m4k3r> Gracenotes: yep
22:09:21 <ski> > let factor n = [m | x <-[2..n], n `mod` x == 0 , m <- [n, x `div` n]] in factor 12
22:09:23 <lambdabot>   [12,0,12,0,12,0,12,0,12,1]
22:09:28 <Twey> o.@
22:09:34 <Gracenotes> it gives you both n `mod` x and n `div` x. I do find list comprehensions somewhat verbose though..
22:09:35 <Twey> What possible number is 1 not a factor of?
22:09:56 <pikhq> Twey: sqrt(i).
22:09:58 <pikhq> Erm.
22:10:02 <pikhq> sqrt(-1)
22:10:02 <Twey> Real number.  > 0.  :-P
22:10:08 <pikhq> (you didn't say "real"!)
22:10:09 <ski> Twey : `1' is a factor of every number
22:10:11 <m4k3r> ski: ok, thx.
22:10:13 <Twey> ski: Right
22:10:20 <copumpkin> including imaginary or complex
22:10:30 <Twey> Didn't know that
22:10:30 <pikhq> Oh, right.
22:10:31 <Twey> pikhq: Hah!
22:10:32 <pikhq> Hmm.
22:10:34 <ski> (and, dually, every number is a factor of `0')
22:10:39 <|Jedai|> copumpkin: How did you write the type family Plus ?
22:10:42 <Twey> Didn't know that, either.
22:10:49 * Twey learns.
22:10:55 <copumpkin> |Jedai|: took a break, haven't done it yet :)
22:11:03 <|Jedai|> copumpkin: My solution wants undecidable instances :(
22:11:07 * pikhq defines an axiomatic system wherein 1 is not a factor in anything.
22:11:09 <copumpkin> hmm, let me try it now
22:11:16 * pikhq notes that that would be the single most useless thing ever.
22:11:33 <Twey> Oh, I don't know
22:11:35 <copumpkin> well, 1 is just the multiplicative identity
22:11:47 <copumpkin> so I guess if you define it not to be, it isn't :P
22:12:20 <ski> (define it not to be what ?)
22:12:29 <copumpkin> not to be the mulitplicative identity :P
22:12:57 * Twey defines two to be the additive identity, and seventeen to be the multiplicative
22:13:02 * Twey watches the universe explode
22:13:37 <impl> IT'S ELEVENTY-FIFTEEN OCLOCK!
22:13:44 <Twey> spoja loi spoja be loi spoja, as Lindar would say
22:13:46 <ski> (definitions "just" give names to entities, in some sense .. if you don't give the name "one" to the multiplicative identity, then it still keeps whatever properties it already had)
22:13:49 <Gracenotes> where
22:14:14 <pikhq> Twey: In other words:
22:14:47 <pikhq> let x+0 = (succ . succ x); x*1 = (x+17)
22:15:01 <pikhq> ?
22:15:03 <Twey> Not quite
22:15:22 <pikhq> (that's got to break something.)
22:15:40 <Twey> let x + 2 = x; x * 17 = x
22:16:03 <Twey> So x + 0 = x - 2, I guess
22:16:19 <Twey> And x * 1 = ... I have no idea
22:16:26 <Twey> x/17?
22:16:29 <heatsink> Twey: http://www.smbc-comics.com/index.php?db=comics&id=807
22:16:53 <Gracenotes> lol
22:16:55 <Twey> Hahaha
22:17:22 <Axman6> heh
22:18:48 <pikhq> > let x+2=x;x*17=x in 10*17+2
22:18:49 <lambdabot>   10
22:19:19 <FunctorSalad> heatsink: nice
22:19:27 <impl> > let x+2=x;x*17=x in 10*34+4
22:19:28 <lambdabot>   * Exception: <interactive>:1:169-173: Non-exhaustive patterns in function +
22:19:41 <impl> :(
22:19:59 <pikhq> Sorry, but you're shadowing the definition of + and * there.
22:20:02 <Axman6> so i'm reading this article about ternary trees http://www.pcplus.co.uk/node/3074/ and i'm wondering what happens when you have say two words that have the same beginning, say pro and professional. is the end of word character also counted as a comparable character?
22:20:04 <Twey> Yup
22:20:42 * Axman6 goes off to implement a ternary tree in haskell and play with it
22:20:47 <jmillikin> Is there any combinator (???) such that (a -> b -> c) ??? (c -> d) -> (a -> b -> d)?
22:21:14 <Gracenotes> it's called (.)
22:21:22 <mwc> you know what would be a great wiki page? C++ for Haskell Programmers. THere's a ton of Haskell for Foo guides out there, but there needs to be one to find your way back ;)
22:21:24 <Gracenotes> ... or is it
22:21:26 <Axman6> (f .) . g i think
22:21:30 <jmillikin> (.) only works when both functions take two parameters, right?
22:21:30 <mwc> jmillikin: lambdabot's pl is a great way to find out:
22:21:45 <Axman6> jmillikin: all functions only take one parameter
22:22:01 <Axman6> :t (?f .) . g?
22:22:03 <lambdabot> parse error (possibly incorrect indentation)
22:22:04 <jmillikin> @pl f x y z = g x y z >>= return . toEnum . fromIntegral
22:22:04 <lambdabot> f = flip flip (return . toEnum . fromIntegral) . ((flip . ((>>=) .)) .) . g
22:22:05 <Twey> Axman6: It's actually explained in the article
22:22:07 <Axman6> :t (?f .) . ?g
22:22:09 <lambdabot> forall b c a a1. (?g::a1 -> a -> b, ?f::b -> c) => a1 -> a -> c
22:22:12 <Twey> Axman6: It's the meaning of the symbol √∏
22:22:15 <jmillikin> oh dear
22:22:57 <Cale> jmillikin: (.) composes two functions of one parameter.
22:23:02 <Cale> :t (.)
22:23:02 <copumpkin> |Jedai|: I think I have it, but am not sure
22:23:03 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
22:23:04 <Axman6> Twey: i'll keep reading i guess, thanks
22:23:04 <mwc> @pl f g h = \a b -> g (f a b)
22:23:05 <lambdabot> f = fix ((const .) . flip ((.) . (.)))
22:23:10 <Gracenotes> TYPES EVERYWHERE O_O
22:23:21 <Gracenotes> right, composition of two-parameter functions requires (.)-sectioning tricks
22:23:22 <copumpkin> |Jedai|: type instance (:+) (S x) y = S (x :+ y)
22:23:40 <Twey> Two-parameter functions are a myth :-P
22:23:43 <copumpkin> maybe a Nat constraint would be good
22:23:47 <Twey> But yes
22:23:58 <Twey> Gracenotes: fmap is often more readable than a .-section
22:24:09 <|Jedai|> copumpkin: Right.... Maybe I shouldn't try working on that during the night
22:24:13 <Gracenotes> I an suspicious of your claim
22:24:14 <Twey> E.G. fmap foo . bar instead of (foo .) . bar
22:24:21 <mwc> Point-free style is great for pipeline style stuff where there's a nice linear data flow. With curried functions/multivariable functions, it's no longer "linear"
22:24:27 <Twey> Makes a lot more sense to me
22:24:28 <mwc> the data flow is "Y" shaped
22:24:50 <Twey> Well... intuitively
22:25:04 <Gracenotes> right... similarly, stack-based languages don't require so many combinators for one parameter functions :)
22:25:17 <pragma_> Why does an impure function's type begin with IO?
22:25:20 <Twey> You can force it into a pipeline, which is what happens when you try to write it in point-free
22:25:33 <Twey> It just ends up looking nasty
22:25:36 <mwc> pragma_: it doesn't think of putStrLn :: String -> IO ()
22:25:38 <pikhq> flip ((.) . (.))?
22:25:44 <pikhq> MY BRAIN HURTS!
22:25:54 <Twey> pragma_: It doesn't ‚Äî there's no such thing as an impure function.  :-P
22:25:57 <Gracenotes> pikhq: what, aren't you turned on?
22:26:19 <pikhq> Gracenotes: WE'RE GOING TO HAVE TO OPERATE!
22:26:32 <mwc> pragma_: putStrLn "foo", the function applied to a string, is an IO "action" that you can perform in another IO action to get a ()
22:26:35 <pikhq> </python,monty>
22:26:53 <mwc> somethinking like IO (String -> ()) is an IO action that you perform to get a (pure) function from String to ()
22:27:04 <Twey> :: String -> IO () means it's a function that returns an IO ().  That's just a value that you can manipulate like any other value, representing a specific impure action or sequence thereof (but it's still pure)
22:27:19 <Axman6> :t let boobies = ((.) . (.)) in flip boobies
22:27:21 <lambdabot> forall b c a a1. (a -> a1 -> b) -> (b -> c) -> a -> a1 -> c
22:27:31 <pikhq> pragma_: Something you must realise when using Haskell. There is no state.
22:27:52 <mwc> Well, there is, but even the "implicit" state in a monad is explicit ;)
22:27:54 <Twey> main :: IO (), so we use main to pass one of these sequences of actions out to the real, impure world, where they're duly executed in sequence.
22:29:18 <Gracenotes> but there is still the question of why IO is special for actions that have side effects
22:29:43 <Twey> Gracenotes: What do you mean?  I just explained that it isn't special
22:29:46 <inimino> IO isn't special, the interpreter is
22:29:52 * Twey nods.
22:29:53 <mwc> type IO = ST RealWorld
22:29:55 <Gracenotes> this article covers some of what makes IO special, in terms of how it deals with state: http://www.haskell.org/haskellwiki/IO_inside
22:29:58 <mwc> RealWorld is special ;)
22:30:04 <Twey> IO () just happens to be the type we return.
22:30:12 <Twey> RealWorld isn't special, either.
22:30:12 <copumpkin> RealWorld is boring as hell :P
22:30:24 <copumpkin> it's never used
22:30:33 <pragma_> "The environment in which ghci operates in is called the 'IO monad'."
22:30:44 <Twey> One too many ‚Äòin‚Äôs
22:30:59 <pragma_> s/operates in/operates/
22:31:13 <Gracenotes> mwc: true enough. low-level Haskell interfaces with RealWorld#, but IO is *the* datatype for accessing those effectful things
22:31:42 <inimino> it's values of type RealWorld that are interesting :-)
22:32:00 <mwc> inimino: and Haskell helpfully doesn't give you any way to manipulate them ;)
22:32:27 <mwc> it's just a phantom type
22:32:40 <inimino> hehe, yes
22:33:14 <Gracenotes> well. you might be able to manipulate it with http://www.haskell.org/ghc/docs/6.6/html/libraries/base/GHC-Prim.html#20 depending GHC-fu
22:33:20 <Gracenotes> depending on :)
22:33:43 <mwc> Is there a good way to get started with Isabelle and proof assistants in general besides the giant tutorial? Or rather, is the 300 page tutorial the smallest reasonable presentation?
22:34:05 <copumpkin> Gracenotes: doubt it ;)
22:35:09 <Gracenotes> copumpkin: so how is RealWorld never used? :X
22:35:26 <jmillikin> Here's a description of what I'm trying to do: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2888
22:35:37 <Gracenotes> is IO not provably sequenceable? WHAT SHALL WE DO NOW?!?!?!
22:35:44 <Cale> I really don't like the RealWorld explanation of IO.
22:35:50 <edwardk> copumpkin: only in #haskell is the RealWorld boring. Elsewhere people find the kind of abstraction that says the RealWorld doesn't exist a little boring. ;)
22:36:28 <mwc> Cale: you prefer the continuation-based presentation maybe?
22:36:37 <Gracenotes> there is always concurrency to consider...
22:36:55 <Cale> mwc: Some sort of representation which explicitly renders the primitive effects as values.
22:37:13 <copumpkin> Gracenotes: well, its only point is to be a specific kind of State thread parameter
22:37:18 <Cale> (and then represents the means of combining those in one way or another)
22:37:27 <copumpkin> Gracenotes: it has no values and doesn't exist outside of the type system as far as I now
22:37:27 <mwc> Cale: so you lean towards a state-based interpretation?
22:37:28 <copumpkin> know
22:37:35 <Gracenotes> now know
22:37:36 <Cale> mwc: No state.
22:37:44 <copumpkin> my k is sticy
22:37:45 <copumpkin> lol
22:37:54 <mwc> "explicity rendered the primitive effects as values"
22:37:55 <Gracenotes> all of my keys are sticky... wait, no...
22:37:58 <Cale> mwc: IO actions are simply inert descriptions of what to do.
22:38:04 <mwc> Ahh
22:38:05 <mwc> okay
22:38:06 <Gracenotes> really though, sucky Dell keyboard
22:38:10 <mwc> I see what you're getting at
22:38:11 <mwc> yes
22:38:36 <mwc> that's more or less how I think of it as well
22:39:13 <Gracenotes> perhaps we could say that IO represents impure actions
22:39:15 <copumpkin> yay
22:39:16 <copumpkin> main = print (Cons 3 (Cons 5 Nil))
22:39:23 <copumpkin> gives me [3,5]
22:39:23 <Cale> A GADT does not-a-terrible-job of describing it, though you have to take equality on IO actions not to be the structural equality on that type then
22:39:35 <Cale> data IO where
22:39:40 <Cale>   ReturnIO :: a -> IO a
22:39:46 * Gracenotes mails copumpkin a card, "Congratulations on your Show instance!"
22:39:47 <Cale>   BindIO :: IO a -> (a -> IO b) -> IO b
22:39:53 <copumpkin> Gracenotes: thanks! :D
22:39:53 <Cale>   PutChar :: Char -> IO ()
22:39:58 <Cale>   GetChar :: IO Char
22:40:09 <Cale>   ForkIO :: IO () -> IO ThreadId
22:40:13 <Cale>   ... etc ...
22:40:25 <copumpkin> Gracenotes: considering it comes from a function Nat n => (forall x. Nat x => a -> p x -> p (S x)) -> p Z -> Vec a n -> p n :P
22:40:36 <mwc> hmm, that's good... but the definition of a gadt is closed. I sense there's a monad-gadt duality I need to ponder
22:40:59 <Cale> Well FFI creates a bit of a problem.
22:41:02 <Gracenotes> hat is a p?
22:41:03 <Gracenotes> what
22:41:26 <Cale> But if you ignore FFI, then it's fine. There are only a finite number of primitives which could conceivably all be known.
22:41:34 <copumpkin> Gracenotes: anything
22:41:56 <Cale> actually, there may be a way to include FFI as well, using some sort of primitive description of the FFI call
22:42:05 <Gracenotes> copumpkin: no instances?
22:42:19 <pikhq> I didn't get how "IO" worked at all until I fully grokked monads.
22:42:25 <copumpkin> Gracenotes: how do you mean?
22:42:26 <Cale> hmm
22:42:53 <pikhq> By which point do x <- [1..];return $ (+2) x didn't seem all that odd to me.
22:43:11 <Gracenotes> copumpkin: so a 'p a' has no accessible functions. like, p could be data Const x = Const
22:43:17 <Gracenotes> and it would still work
22:43:18 <copumpkin> Gracenotes: sure
22:43:27 <copumpkin> in fact, that's more or less how I've been using it so far :)
22:43:28 <Cale> pikhq: Of course, that's not IO ;)
22:43:52 <pikhq> Cale: Yes, of course. That's a different monad.
22:44:05 <Cale> I think the important thing is not so much that IO is a monad as that it's just some datatype which represents stuff to be done.
22:44:06 <Gracenotes> copumpkin: ah... I see, you have a ranky-polymorphic function as the first parameter
22:44:20 <Cale> and that the runtime system knows how to interpret that datatype
22:44:37 <pikhq> That's sufficient to do basic I/O, yes.
22:44:38 <copumpkin> how can I output an IsNat defined as
22:44:39 <copumpkin> data IsNat n where
22:44:39 <copumpkin>   IsNat :: Nat n => IsNat n
22:44:42 <copumpkin> ?
22:44:42 <Cale> The fact that it's a monad is nice because we get the stuff in Control.Monad for free
22:44:49 <pikhq> Not sufficient to actually grok the language, though.
22:44:50 <Gracenotes> copumpkin: and I take it Z and S are zero/succ
22:44:50 <Cale> but other than that, it's not essential at all
22:44:54 <copumpkin> Gracenotes: yeah
22:45:01 <Gracenotes> oh. makes more sense
22:45:15 <Cale> Understanding the specialisation of >>= to IO is important to know how to work with it, of course.
22:45:19 <Gracenotes> what's the a parameter for?
22:45:27 <copumpkin> Gracenotes: which parameter?
22:45:28 <Cale> (because we put so much reliance on that means of combination)
22:45:37 <mwc> I think of IO monad as describing the application of effects in a way that's similar enough to a real monad that we can use the same reasoning about sequencing/application, at least na√Øvely
22:45:55 <Gracenotes> (forall x. Nat x => a -> p x -> p (S x))
22:45:57 <Cale> It is a real monad, as far as I'm concerned.
22:46:13 <copumpkin> Gracenotes: you mean the a?
22:46:25 <Gracenotes> oh yeah.. forgot +c takes out bold
22:46:30 <pikhq> Seems to satisfy the monad laws.
22:46:44 <pikhq> Just because it's a one-way monad doesn't make it less of a monad. :P
22:46:54 <Cale> Actually, an interesting approach would be to design IO as a Prompt monad.
22:47:09 <Cale> Then you could write other interpreters for it.
22:47:28 <Cale> and the property that it's a monad would be guaranteed
22:47:44 <mwc> pikhq: actually, I believe I read once long ago that it doesn't satisfy the monad laws
22:47:50 <mwc> pikhq: there's some corner case
22:47:56 <Gracenotes> copumpkin: arrrrrrfirmative
22:48:01 <Cale> If there's some problem about the monad laws, it probably involves seq
22:48:02 <copumpkin> ?
22:48:08 <Gracenotes> what is a
22:48:11 <Gracenotes> o_O
22:48:15 <Cale> Everyone ignores seq when evaluating whether laws hold anyway
22:48:16 <Gracenotes> and why does the function need it
22:48:17 <copumpkin> Gracenotes: oh, it's the thing you're folding over!
22:48:25 <pikhq> mwc: ... So, it breaks something. Which means I hate it.
22:48:31 <pikhq> Just like I hate ListT.
22:48:36 <copumpkin> or rather
22:48:39 <copumpkin> the current value
22:48:40 <Cale> IO doesn't really break the monad laws
22:49:02 <mwc> The place where it "break" the monad laws is a place where you're trying to do something nonsensical anyways
22:49:28 <Gracenotes> copumpkin: hmm... what's your definition of Z and S? I assume it can hold some information
22:49:53 <copumpkin> Gracenotes: I'm actually just building on someone's email from haskell-cafe
22:49:56 <copumpkin> but it's:
22:49:56 <copumpkin> data Z = Z
22:49:56 <copumpkin> newtype S n = S n
22:50:09 <Gracenotes> that's some exciting stuff
22:51:09 <Gracenotes> whoa. oishasan is a word.. and so is isha o_O
22:51:22 <Cale> The only way in which you could ever decide that it's not a monad is by using seq to tease apart subtle differences in definedness of IO values.
22:51:50 <copumpkin> Gracenotes: doctor?
22:51:58 <Gracenotes> yes
22:52:05 <copumpkin> why are you surprised?
22:52:07 <Cale> Prelude> (undefined >>= return :: IO ()) `seq` ()
22:52:07 <Cale> ()
22:52:07 <Cale> Prelude> (undefined :: IO ()) `seq` ()
22:52:07 <Cale> *** Exception: Prelude.undefined
22:52:17 <copumpkin> and where did that come from? we were talking about peanos
22:52:18 <copumpkin> :P
22:52:19 <Cale> there it is, seemingly breaking the monad laws
22:52:33 <mwc> brilliant.
22:52:34 <mwc> that's the one
22:52:36 <Cale> But I think that this distinction is much too fine to care about.
22:52:37 <Gracenotes> copumpkin: I love improvising on peonos!
22:52:44 <Gracenotes> peanos
22:52:49 <Gracenotes> .. >_>
22:53:05 <inimino> pianos?
22:53:11 <Cale> The problem is with seq, not with IO
22:54:45 <Cale> Without seq, there's no way to observe a difference between undefined and undefined >>= return
22:54:59 <Gracenotes> Cale: do you know just what GHC-seq does? Doesn't it just look for a constructor?
22:55:14 <pikhq> Clearly that's a bug in `seq`.
22:55:17 <Cale> It evaluates until it finds the topmost constructor, or a lambda.
22:55:31 <mwc> Cale: you tipped my memory, there's something about that in the report
22:55:44 <Gracenotes> ah, lambda. hm.
22:55:49 <Cale> seq does something which is otherwise impossible for datatypes whose constructors are not exposed
22:55:56 <Cale> (especially for functions)
22:56:04 <Gracenotes> > (\x -> undefined) undefined `seq` ()
22:56:05 <lambdabot>   * Exception: Prelude.undefined
22:56:12 <Gracenotes> > (\x -> undefined) `seq` ()
22:56:14 <lambdabot>   ()
22:56:14 <Cale> normally, you couldn't tell the difference between  undefined  and  const undefined  (of the same type)
22:56:21 * copumpkin is bending his mind in ways he never thought possible
22:56:44 <Gracenotes> Cale: mm, or (\x -> undefined) as, er, defined above
22:56:47 <Cale> yeah
22:56:49 <Gracenotes> == const
22:57:15 <Cale> case expressions normally wouldn't do anything to functions like that
22:57:15 <mwc> Gracenotes: that's the example in the report
22:57:27 <Cale> > case undefined of f -> 0
22:57:29 <lambdabot>   0
22:57:45 <Cale> because there's nothing but irrefutable patterns
22:57:48 <Gracenotes> Cale: and does weak head normal form behave in the same way? I forget exactly what it does.
22:58:14 <Cale> Yeah, seq x y evaluates x into weak head normal form before the result of y is made available
22:58:31 <pikhq> Cale: So, IO is still a monad. However, seq does much to break monad semantics.
22:58:36 <Cale> yeah
22:58:47 <Gracenotes> I guess head normal form treats (\x. _|_) as _|_ then
22:58:53 <Cale> Or rather, you can make arguments about semantics which you couldn't make without it.
22:59:03 <Cale> and often it destroys the nice view of things
22:59:09 <mwc> Does seq x y imply that in y, one can pattern match on x without any further computation?
22:59:12 <Cale> Gracenotes: yeah
22:59:13 <mwc> I think yes
22:59:23 <pikhq> I'm calling it about as sane as unsafeCoerce.
22:59:27 <Cale> Head normal form will require evaluation under lambdas
22:59:33 <sjanssen> pikhq: I wouldn't say "much", rather "seq breaks monad semantics in ways that most people don't care about"
22:59:40 <Cale> mwc: well...
22:59:48 <pikhq> sjanssen: Eh.
22:59:51 <Gracenotes> Cale: ah... so how about (\x. f _|_), for a function f
22:59:55 <Cale> mwc: For technical reasons, not quite.
23:00:09 <sciolizer> @index hSelect
23:00:10 <lambdabot> bzzt
23:00:10 <sjanssen> I don't think I've ever encountered code where this was a problem, for example
23:00:14 <Gracenotes> well. assuming f _|_ is _|_
23:00:19 <Cale> mwc: It means that before you can pattern match on y, you must be able to pattern match on x without further evaluation.
23:00:52 <mwc> Cale: right, I glossed over that subtlety, but that's what I meant
23:00:56 <Cale> It's valid for seq x y to cause y to be evaluated first, and then evaluate x before making the result of evaluating y available.
23:01:02 <mwc> Oh
23:01:03 <mwc> hmm
23:01:19 <mwc> Yeah, of course, that would just "create" the suspension for y
23:01:36 <sjanssen> mwc: all that Haskell '98 says is: seq _|_ y = _|_; seq x y = y
23:01:43 <Cale> right
23:01:43 <sjanssen> mwc: anything else is implementation detail
23:01:53 <Gracenotes> Haskell 98 seems to leave a lot open :)
23:02:05 <Gracenotes> semantics particularly...
23:02:39 <sciolizer> Hi. What's the best way to do multiplexing IO in Haskell?
23:02:53 <mauke> threads?
23:03:01 <sciolizer> mauke: it's fast?
23:03:05 <mauke> yes
23:03:24 <mauke> a few hundred threads here, a few hundred threads there ...
23:03:39 <mwc> sciolizer: ghc implements IO threads as "green" threads, like Erlang's BEAM.
23:03:42 <Cale> sciolizer: What do you mean by
23:03:46 <Cale> er...
23:03:48 <sjanssen> Gracenotes: it's mostly operational semantics that are left open, denotational semantics are more specified
23:03:52 <Cale> sciolizer: What do you mean by multiplexing?
23:04:03 <maxote> mwc, what means "green" threads?
23:04:10 <sciolizer> Cale: like select()
23:04:11 <Twey> Like Erlang's BEAM, but faster.
23:04:13 <copumpkin> maxote: lightweight
23:04:18 <Twey> And more lightweight.
23:04:24 <Cale> sciolizer: Oh, just forkIO a few threads.
23:04:28 <copumpkin> maxote: they're only a couple dozen bytes each
23:04:30 <mwc> maxote: the context and switching is done in user space, rather than being mapped onto OS/Kernel level threads. So one OS threads executes multiple "green" threads
23:04:31 <sjanssen> mwc: what's the history on that?  Are we sure Erlang's BEAM is like GHC's RTS? :)
23:04:33 <maxote> and what's non-green threads?
23:04:41 <copumpkin> maxote: OS threads
23:04:45 <Twey> maxote: Heavy-weight OS threads.
23:04:57 <copumpkin> mac os 10.6 will have green threads at the OS level too
23:04:59 <Cale> All the basic IO primitives, apart from FFI calls (which you can't really help much anyway), are implemented with nonblocking IO
23:05:00 <maxote> why the green color?
23:05:09 <copumpkin> maxote: because we're environmentally friendly here
23:05:13 <Cale> (and blocking is simulated)
23:05:14 <Twey> A program can happily use several hundred thousand green threads on a modern system, but only a few hundred OS threads, reasonably
23:05:41 <mgsloan>  what do OS threads do that green threads cannot?
23:05:51 <sciolizer> It just sounds too easy. :)
23:05:55 <mwc> mgsloan: it generally matters when you do FFI
23:06:02 <copumpkin> Saizan: still awake?
23:06:04 <mwc> mgsloan: if your lib uses thread local storage for instance
23:06:21 <mwc> mgsloan: then you need to use forkOS to tell GHC's RTS to always run that thread on a specific OS thread
23:06:23 <mauke> mgsloan: do stuff in parallel
23:06:34 <mwc> mgsloan: ie, on its own thread.
23:06:36 <mgsloan> ahh
23:06:43 <mgsloan> gotcha, thanks
23:06:46 <mwc> mauke: I don't htink that's true is it? GHC's RTS uses M-N threading
23:06:50 <Twey> The runtime can promote a green thread to an OS thread if it makes sense, though.
23:07:07 <copumpkin> lengthIsNat Nil = IsNat :: IsNat n
23:07:08 <copumpkin> lengthIsNat (Cons _ _) = IsNat :: IsNat n
23:07:14 <Twey> (or run a bunch of green threads in a separate OS thread)
23:07:16 <copumpkin> for some reason I can't avoid making two cases there :)
23:07:41 <Twey> copumpkin: lengthIsNat _ = IsNat :: IsNat n
23:07:41 <Twey> ?
23:07:46 <maxote> can a green thread be migrated to OS thread?
23:07:49 <copumpkin> Twey: nope, doesn't like it :P
23:07:52 <maxote> and viceversa?
23:07:59 <Twey> What's this crazy stuff you're doing?
23:08:01 <copumpkin> Twey: I'm going to try it with fold now
23:08:02 <Twey> maxote: Yes
23:08:10 <Axman6> maxote: i can;t see why you'd want to really
23:08:12 <Twey> There's not much reason to do the vice versa, though
23:08:22 <Cale> maxote: The way things work is that M Haskell threads (what people have been calling green threads) are scheduled for execution on N real OS threads.
23:08:22 <copumpkin> Twey: the lightweight dependent types in haskell thing that ryan ingram sent out a while back on -cafe
23:08:28 <mwc> maxote: yes. Generally, the RTS can be told to use N OS threads to run the user-level green threads. a Given green thread can run on multiple OS threads in its lifetime
23:08:53 <Cale> maxote: Ordinarily, the runtime will have no qualms about moving the execution of Haskell threads between different OS threads.
23:09:00 <Cale> But forkOS prevents that.
23:09:02 <mwc> maxote: an OS thread can't be migrated to a green thread, since the former is a kernel-level abstraction and a green thread is in userspace
23:10:02 <mwc> The RTS might decide to stop using some OS threads and consolidate the green threads onto fewer OS threads I suppose. I don't know if that's implemented
23:10:55 <maxote> mwc, i think an OS thread can be migrated to a green thread, it's simple, create a simple empty green thread, copy the content of OS thread to green thread, and destroy controllately the OS thread.
23:11:04 <copumpkin> Twey: oh actually, I can't use fold :/
23:11:10 <copumpkin> cause I'm trying to show it's a Nat
23:12:09 <mwc> maxote: that's not quite how the RTS works. The RTS maintains a list of green threads. Each OS thread in use by the RTS will find a green thread to run, run it, and then when it blocks or a timeout occurs, stop it and find another to run. So the green threads are "mapped" onto the OS level threads temporarily
23:12:10 <sjanssen> http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/Scheduler
23:12:17 <sjanssen> ^^^ how GHC actually works
23:12:59 <mwc> Basically, OS threads run green threads. Different beasts entirely, so one can't be turned into the other. a green thread might be promoted to run on its own OS thread though
23:13:11 <jimmyjazz14> I seem to be having some issue with order of evaluation.  I am taking contents from a file and tranforming the text from that file then wrapping that text in a template...
23:13:32 <jimmyjazz14> ...but it appears my text is not tranformed until after it is wrapped
23:14:15 <jimmyjazz14> I'm a little stumped on what is going on
23:14:18 <dibblego> @type \a b -> mappend <$> a <*> b -- is this in the standard library?
23:14:20 <lambdabot> forall a (f :: * -> *). (Monoid a, Applicative f) => f a -> f a -> f a
23:14:46 <Cale> jimmyjazz14: why is the order of evaluation important here?
23:14:50 <mauke> liftA2 mappend
23:14:55 <Cale> jimmyjazz14: Expressions are evaluated outermost-first
23:15:11 <Cale> So if you write f (g x), it's f which evaluates first.
23:15:34 <Cale> (and references to g x are substituted into the body of f)
23:15:58 <mwc> sjanssen: hmm, that seems to suggest that green threads don't have an OS thread affinity, which is desirable for caching. Or are the improvements too slight to matter?
23:16:14 <mwc> Oh, wait, there's a stub affinity section at the bottom...
23:16:25 <jimmyjazz14> Cale: Its important because the tranformation function does not work with the wrapped text
23:16:46 <copumpkin> I think I'm starting to get the hang of this crazy type stuff
23:16:49 <Cale> mwc: I think it tries to keep them on the same OS thread if possible, but won't mind switching them if it can't.
23:16:59 <copumpkin> I just used a case statement that didn't do anything but appease the typechecker
23:17:10 <sjanssen> mwc: there is some affinity, but they're not strictly locked to OS threads (except for bound FFI threads)
23:17:17 <Cale> jimmyjazz14: er, can you hpaste your code?
23:17:24 <mwc> Cale, sjanssen: that's what I'd expect
23:17:28 <Cale> jimmyjazz14: I have a feeling it's not an issue about evaluation order.
23:17:44 <Cale> jimmyjazz14: Evaluation order normally can't affect the result of a program, only its performance.
23:18:56 <copumpkin> now I need to do natEqDec :: forall x y. (Nat x, Nat y) => x -> y -> Maybe (TEq x y)
23:18:59 <Cale> (which is a consequence of purity)
23:19:45 <nainaide> In "do { guard (age r < limit); return r }", if once "an age >= limit," then the do block will be  "mzero >> return r ==mzero" , am I right?
23:20:04 <Cale> yes
23:20:34 * mauke immediately thinks of broken instances where this is false
23:20:49 <copumpkin> mauke: ?
23:20:51 <nainaide> Cale, Thanks.
23:21:03 <Cale> > do x <- [1..10]; guard (even x); return x
23:21:04 <lambdabot>   [2,4,6,8,10]
23:21:34 <jimmyjazz14> Cale: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6288#a6288
23:21:40 <sjanssen> mwc: note there is an "Affinity and migration" section, but nobody has bothered to write it
23:21:43 <Cale> > do x <- [1..10]; (do guard (even x); return x)
23:21:43 <jimmyjazz14> sorry the code is a bit ugly
23:21:44 <lambdabot>   [2,4,6,8,10]
23:21:47 <mauke> to make the above not yield mzero, you could write bad instances for MonadPlus, Monad or Ord
23:22:01 <copumpkin> oh, I thought you were talking about my thing :)
23:22:25 <Cale> jimmyjazz14: btw, last line of  doesBlogExist can just be  return exists
23:22:44 <ski> (mauke : oh, i thought you had a specific bad instance in mind ..)
23:22:50 <mwc> well, I suppose I'd better go to bed then
23:23:02 <mauke> (realname) is the same as realname
23:23:13 <sjanssen> jimmyjazz14: what bad behavior are you observing?
23:23:17 <jimmyjazz14> Cale ah yeah I guess it could
23:23:31 <mauke> entryPath looks suspicious
23:23:47 <jimmyjazz14> so in runBlog' getEntry should return some html
23:23:54 <Cale> okay
23:24:03 <mauke> openFile/hGetContents is readFile
23:24:04 <jimmyjazz14> then applyBlogTemplate should wrap it in a template
23:24:14 <Cale> sure
23:24:22 <nainaide> > do x <- [1..10]; (do guard (even x); return x; return x; return x)
23:24:23 <lambdabot>   [2,4,6,8,10]
23:24:38 <jimmyjazz14> getEntry takes restructuredText at one point and converts it to html
23:24:41 <ski> > do x <- [1..10]; (do guard (even x); return x; return x; mzero)
23:24:43 <lambdabot>   []
23:24:49 <mauke> do { b <- openBlog rq; return b } is the same as openBlog rq
23:24:59 <jimmyjazz14> the issue seems to be that, that convertion is not happening before applyBlogTemplate
23:25:09 <jimmyjazz14> (it appears to happen after)
23:25:13 <Axman6> anyone know where i can get a large english word list?
23:25:13 <Cale> eh?
23:25:32 <impl> Axman6: /usr/share/dict/words
23:25:36 <sjanssen> jimmyjazz14: so what is the resulting value of runBlog'?
23:25:36 <nainaide> guard only "guard" on function follow it ?
23:25:41 <Cale> jimmyjazz14: I'm not sure what you mean by 'before' and 'after' -- which value is it that's not the value you'd expect?
23:25:45 <nainaide> guard only "guard" one function follow it ?
23:25:58 <Cale> nainaide: hmm... I'm not sure what you mean
23:26:15 <nainaide>  > do x <- [1..10]; (do guard (even x); return x; return x; return x)
23:26:17 <ski> nainaide : no, `guard' guards the whole "monadic thread" executing it
23:26:34 <nainaide> why only one   [2,4,6,8,10] ?
23:26:34 <Cale> nainaide: return in the middle of a do-block is always pointless.
23:26:45 <ski> (i'm not sure "monadic thread" is a useful way to phrase it ..)
23:26:48 <Axman6> thanks impl
23:26:58 <Cale> nainaide: return x is a computation which does nothing, and whose result is x
23:27:21 <Cale> nainaide: So the first two return x's there do nothing, and their results are ignored.
23:27:41 <Cale> (because you have no <- to capture them, and you'd just be getting x as the result anyway)
23:28:13 <jimmyjazz14> Cale I may need to rehash this code a bit
23:28:21 <impl> yup
23:28:21 <Cale> > do x <- [1..10]; (do guard (even x); [x,x,x])
23:28:23 <lambdabot>   [2,2,2,4,4,4,6,6,6,8,8,8,10,10,10]
23:28:31 <Cale> perhaps you meant to write that?
23:28:35 <Cale> jimmyjazz14: hmmm
23:29:19 <Cale> jimmyjazz14: applyTemplate will be applied to the value of a when Just a is the thing which applyBlogTemplate is applied to
23:29:38 <jimmyjazz14> basically the readRST function in openBlog seems to be getting content that is already wrapped in my template
23:29:41 <nainaide> Cale, According to the defination of guard, it measn mzero >>= f ==mzero, where f = return x, here
23:29:43 <Axman6> huh, seems this ternary tree implementation i wrote is more efficient than i was expecting. can insert all 234936 words in that file less than 5 seconds
23:29:54 <Cale> nainaide: yes...
23:30:32 <nainaide> So I dount if in do blocks, it likes  mzero >>== return x, returnx, returnx
23:30:50 <Cale> jimmyjazz14: huh
23:30:59 <nainaide> I mean in "do x <- [1..10]; (do guard (even x); return x; return x; return x)"
23:31:03 <Cale> jimmyjazz14: readRST is being passed the contents of the file
23:31:08 <mauke> why is there a return in runBlog'?
23:31:20 <Cale> jimmyjazz14: so look at the file on disk and make sure that it really contains what you expect.
23:31:29 <mauke> you're just 'join'ing it anyway in runBlog
23:31:43 <Cale> mauke: good point
23:32:01 <nainaide> So I was thought the last two return x was ignored
23:32:09 <jimmyjazz14> Cale I expect it is something simple
23:32:13 <Cale> nainaide: no, it's the *first* two
23:32:30 <Cale> > do x <- [1..10]; return x; return (x*10)
23:32:31 <lambdabot>   [10,20,30,40,50,60,70,80,90,100]
23:32:56 <ski> > do x <- [0..3]; y <- return x; return (x*10,y)
23:32:57 <lambdabot>   [(0,0),(10,1),(20,2),(30,3)]
23:33:08 <nainaide> Cale, why
23:33:25 <Cale> nainaide: because (return v) is always a computation which does nothing and returns v
23:33:26 <SubStack> because "return" is a bad name
23:33:37 <Cale> It is not magic like the return in other imperative languages.
23:33:39 <ski> because `return x' is the action that does nothing, then returns `x' resulting *value* (of the action itself)
23:33:52 <Cale> I think return is a good name
23:34:03 <Cale> You just can't expect it to mean what it means in C ;)
23:34:10 <ski> there is no magic "return from the \"current\" function" in haskell
23:34:18 <copumpkin> hmm
23:34:24 <SubStack> if it had a different name (like pure), there'd be less surprise
23:34:27 <Cale> The return in many imperative languages does a funny thing where it calls the continuation of the enclosing function with that value.
23:34:33 <copumpkin> in http://www.opensubscriber.com/message/haskell-cafe@haskell.org/12388255.html , is there a way of making a myReplicate that takes an explicit length parameter?
23:34:42 <Gracenotes> hrm, looks like C Strachey's gone all Baader-Meinhof on me!
23:34:51 <Cale> Which I think is a funny thing to expect it to do, unless you've been trained to think that it should do that.
23:34:55 <Axman6> hmm, how is interact supposed to work?
23:35:12 <sjanssen> copumpkin: you mean it takes 'n' as a parameter?
23:35:22 <SubStack> the more I learn, the less I expect
23:35:23 <Axman6> it exits after i enter just one line
23:35:26 <ski> @src interact
23:35:27 <lambdabot> interact f = do s <- getContents; putStr (f s)
23:35:27 <copumpkin> sjanssen: yeah, or AnyNat, or whatever it needs to take :P
23:35:34 <mauke> Axman6: what's your function?
23:35:38 <copumpkin> sjanssen: or is that going beyond what's possible?
23:35:39 <Cale> It's like every procedure/function in C is wrapped in call/cc :)
23:35:39 <nainaide> still a little confuse, since  `return x' is the action that does nothing, why does the last one "return" something?
23:35:43 <Axman6> interact (show . (`isElem` tree))
23:35:54 <Cale> and return is the only way of accessing that continuation :)
23:35:55 <copumpkin> :t replicate
23:35:56 <lambdabot> forall a. Int -> a -> [a]
23:36:06 <Axman6> i thought it was supposed to continue running the function
23:36:06 <copumpkin> so maybe: replicateVec :: AnyNat -> a -> Vec a n
23:36:15 <Cale> nainaide: the result of a do-block is the result of the last computation in it.
23:36:19 <copumpkin> but then I have no way of ensuring that the n == AnyNat's secret value
23:36:24 <Axman6> oh well, i'll write my own. not too hard
23:36:26 <ski> (Cale : also, cf. `break',`continue' ..)
23:36:27 <copumpkin> hrmm
23:36:27 <Cale> nainaide: each of the computations is run
23:36:29 <nainaide> Cale, understand!
23:36:34 <sjanssen> copumpkin: it can be done if you make myReplicate a class method
23:36:36 <mauke> Axman6: maybe it already determined that there is no match
23:36:48 <copumpkin> sjanssen: of Nat?
23:36:51 <nainaide> Thanks you all
23:36:59 <sjanssen> copumpkin: or of its own class
23:37:04 <copumpkin> hm
23:37:23 <mauke> Axman6: what's there to continue?
23:38:04 <Axman6> what i wanted was interact f = do line <- getLine; putStrLn (f line); interact f
23:38:24 <mauke> interact (unlines . map f . lines)
23:38:32 <copumpkin> sjanssen: what would you call the class?
23:38:48 <sjanssen> copumpkin: Replicate?
23:38:56 <ski> interact (perLine f)
23:39:12 <Gracenotes> interact f = do { s <- getContents; putStr (f s) } -- from the horse's mouth (GHC's, anyway)
23:39:16 <copumpkin> sjanssen: hmm, I don't understand what the class buys me :(
23:40:36 <m4k3r> what's wrong with round (sqrt n)  T___T ? I get these errors  http://codepad.org/IuFYkT4P :\
23:41:05 <Cale> m4k3r: the problem is that you're also using n as if it is integer-like
23:41:27 <mauke> m4k3r: n is not a floating point number
23:41:28 <Cale> m4k3r: and there's no possible type which both supports sqrt and mod
23:41:32 <ski> @type fromIntegral
23:41:34 <lambdabot> forall a b. (Integral a, Num b) => a -> b
23:41:35 <Axman6> whoot, got it working. now i have a little dictionary app :)
23:41:38 <m4k3r> Cale: n should be only an integer
23:41:50 <ski> `sqrt' doesn't work on integers
23:41:52 <Cale> m4k3r: so yeah, like people are suggesting, apply fromIntegral before sqrt to convert it
23:42:03 <Axman6> :t sqrt
23:42:04 <lambdabot> forall a. (Floating a) => a -> a
23:42:13 <Cale> round (sqrt (fromIntegral n))
23:42:16 <Axman6> :instances Floating
23:42:25 <Axman6> @instances Floating
23:42:26 <lambdabot> Double, Float
23:42:40 <jimmyjazz14> Cale: turns out it was a bug in my applyTemplate function, thanks for the help though, who know how long I would have gone down that rabbit trail
23:42:47 <Axman6> m4k3r: what do you need the square root for anyway?
23:42:49 <Cale> jimmyjazz14: okay :)
23:42:59 <sjanssen> copumpkin: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6289#a6289
23:43:03 <ski> (Axman6 : possibly factoring ..)
23:43:18 <m4k3r> oh, sorry, i've tried with ::Float 'couse i'm not familiar with fromIntegral
23:43:29 <sjanssen> copumpkin: and I don't think the class is necessarily required if one makes a Nat GADT
23:43:47 <ski> `foo :: Float' doesn't result in a `Float' unless `foo' already is (or could be) a `Float'
23:43:51 <copumpkin> sjanssen: oh, I see
23:44:05 <Axman6> well if it's say to test if x < sqrt y, then you can always test x*x < y (something i've used a lot when playing with writing programa that find prime numbers... inefficiently..)
23:44:07 <Gracenotes> m4k3r: Haskell's Num classes take some getting used to since, unlike many other languages, you can't coerce an int into a double, for example
23:44:12 <Cale> m4k3r: fromIntegral will convert any integer-like type into any numeric type at all
23:44:19 <ski> type ascriptions only constrain types of expression. they do no coercion
23:44:26 <Gracenotes> you have to use explicit functions..
23:44:54 <m4k3r> k, thx
23:44:57 <Cale> I think it's a good thing in the end... though it's possible that fromIntegral's name is a little long. ;)
23:45:14 <SubStack> agree
23:45:40 <SubStack> it should be a single unicode character
23:45:41 <mauke> m4k3r: x <- [2 ..], x*x <= n, ...
23:45:41 <Cale> Numeric coercion is really something that you don't want to put in the wrong place though. It's an easy source of bugs when you get it wrong, so I like that it's explicit.
23:45:48 <SubStack> ‚òÉ perhaps
23:46:02 <Cale> mauke: unfortunately, that won't know to stop ;)
23:46:02 <mauke> m4k3r: wait, no. you'd have to use takeWhile. never mind
23:46:09 <m4k3r> mauke: ^^
23:47:04 <ski> a nondeterminism monad where solutions are always ordered might be interesting
23:47:20 <sjanssen> copumpkin: and annotation http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6289#a6290
23:47:23 <ski> (though in Haskell, it's probably the same problem as with `Set')
23:47:28 <Cale> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) . takeWhile (\p -> p^2 <= n) $ primes in primes
23:47:29 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
23:47:41 <Cale> I really like that version of primes ;)
23:47:50 <copumpkin> sjanssen: my problem is that I sort of need the AnyNat type from that email, I think
23:48:16 <copumpkin> but I'm not sure it's possible to use that one
23:48:26 <copumpkin> (in a meaningful way, anyway)
23:49:17 * ski wonders whether having the pattern `(x,y)' being the same as the pattern `~(x,y)' would have any bad effects
23:49:18 <Cale> I think it's quite readable, for something which is so mutually recursive :)
23:49:31 <Axman6> Cale: p*p would be a little faster than p^2 right?
23:49:33 <sjanssen> copumpkin: the definition of myReplicate in the mail isn't suitable?
23:49:36 <Cale> yeah
23:49:38 <Axman6> @src (^)
23:49:39 <lambdabot> x ^ 0            =  1
23:49:39 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
23:49:39 <lambdabot>   where f _ 0 y = y
23:49:39 <lambdabot>         f x n y = g x n
23:49:39 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
23:49:41 <lambdabot>                       | otherwise = f x (n-1) (x*y)
23:49:43 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
23:49:46 <Axman6> heh
23:49:53 <Twey> Woah
23:49:55 <dons> yow
23:49:57 <ski> > p ^ 2 :: Expr
23:49:58 <lambdabot>   p * p
23:50:04 <copumpkin> sjanssen: I was just experimenting and seeing what was possible and what wasn't :) I don't really have any use for this at this point
23:50:07 <Axman6> : p ^ 11 :: Expr
23:50:10 <Axman6> > p ^ 11 :: Expr
23:50:12 <lambdabot>   p * p * (p * p) * (p * p * (p * p)) * (p * p * p)
23:50:27 <Cale> It decides that p^2 = p*p over and over again at runtime, which I suppose is bad :)
23:50:31 <ski> it would be nice if the sharing there was shown ..
23:50:33 <Axman6> > p ^ 16 :: Expr
23:50:34 <sjanssen> copumpkin: oh, the problem with anyNat is that it must necessarily expose the type of the wrapped existential in its result
23:50:35 <lambdabot>   p * p * (p * p) * (p * p * (p * p)) * (p * p * (p * p) * (p * p * (p * p)))
23:50:38 <Cale> ski: it would
23:50:50 <sjanssen> copumpkin: myReplicate :: AnyNat -> List a ???
23:50:55 <Cale> vacuum >>= simpleReflect
23:51:12 <copumpkin> sjanssen: yeah, that was what bothered me :P I'd be enforcing the quality in the = side of things rather than the ::
23:51:19 <Axman6> :t vacuum
23:51:20 <lambdabot> Not in scope: `vacuum'
23:51:22 <Axman6> :(
23:51:42 <copumpkin> sjanssen: I really just want to be able to call replicate (mkNat 5) 5 and have it do the right thing :P but that's getting awfully dependent I guess
23:51:46 <ski> , [$ty|vacuum|]
23:51:46 <Twey> , [$ty| vacuum |]
23:51:49 <lunabot>  forall a . a -> [] ((Int, [] Int))
23:51:49 <lunabot>  forall a . a -> [] ((Int, [] Int))
23:51:58 <Twey> :)
23:52:00 <ski> :)
23:52:05 <sjanssen> copumpkin: I don't think that's possible
23:52:13 <Axman6> hmm, anyone think that a ternary tree implementation would be useful on hackage? seems to be fairly fast
23:52:28 <copumpkin> sjanssen:  yeah :/
23:52:31 <Cale> Axman6: do you really have to ask? :)
23:52:48 <Cale> Axman6: go for it :)
23:52:51 <Axman6> well, it might be a little too basic for hackage :P
23:52:59 <Twey> Nah
23:53:02 <Cale> Hackage needs more basic packages.
23:53:08 <Twey> There are ridiculously basic things on hackage
23:53:10 <Twey> Better to have it than not
23:53:20 <Axman6> i don't think anyone has even touched my AVar package, but i think a lot of people would think it's a waste of time
23:53:33 <sjanssen> AVar?
23:53:37 <Twey> If nobody uses it then nobody uses it
23:53:43 <Twey> It's not like you're going to fill hackage up :-P
23:53:56 <edwardk> not bad, for messing around, so far tied with the bottom of the leaderboard on the icfp09
23:54:13 <edwardk> maybe should have spent more time coding and less time watching anime
23:54:20 <copumpkin> lol
23:54:22 <Twey> Haha
23:54:23 <Cale> edwardk: hehe, what are you watching?
23:54:31 <Axman6> sjanssen: an idea i had for some safeish mutable variables, that work as forkedIO'd functions, that protect themselves from all exceptions if possible
23:54:32 <edwardk> Hajime no Ippo
23:54:44 <edwardk> (Ran out of Kenichi)
23:54:56 <ski> > (\(_,_) -> ()) undefined
23:54:58 <lambdabot>   * Exception: Prelude.undefined
23:55:02 <Axman6> they're functional variables (but using Chan's for communication and modifcation etc)
23:56:30 <Axman6> , vacuum (p^10)
23:56:33 <lunabot>  [(0,[1,2,2,2]),(1,[3,4,5,6]),(2,[]),(3,[]),(4,[]),(5,[]),(6,[7,8]),(7,[])...
