00:24:31 <dibblego> @src dropWhile
00:24:31 <lambdabot> Source not found. :(
00:24:36 <ClaudiusMaximus> @check (\x -> unlines (lines x) == x)
00:24:37 <lambdabot>   "Falsifiable, after 1 tests:\n\"\\658972\\64216\"\n"
00:26:52 <ClaudiusMaximus> @check (\x -> all ((< 256) . ord) x || unlines (lines x) == x)
00:26:53 <lambdabot>   "Falsifiable, after 0 tests:\n\"\\221350\"\n"
00:27:55 <ClaudiusMaximus> @check (\x -> not (all ((< 256) . ord) x) || unlines (lines x) == x)
00:27:56 <lambdabot>   "OK, passed 500 tests."
00:31:57 <Beelsebob> I expect your initial condition there probably accounts for 59% of strings QC is generating
00:32:01 <Beelsebob> (40% of them being empty)
00:36:03 <ClaudiusMaximus> i'm wondering if it's safe to assume   unlines . lines = id  for strings i get inside   interact (\s -> ...)
00:36:34 <Beelsebob> no
00:36:39 <Beelsebob> the reverse is true
00:36:41 <Beelsebob> but not that way
00:36:53 <Beelsebob> > (unlines . lines) "5\n\n6"
00:36:55 <lambdabot>   "5\n\n6\n"
00:37:01 <Beelsebob> wait...
00:37:07 <Beelsebob> maybe it is
00:37:09 <ClaudiusMaximus> ah, trailing newline
00:37:20 <Beelsebob> well, yeh, I thought it would be worse
00:37:27 <Beelsebob> I expected it to delete the blank line
00:37:39 <Beelsebob> > lines "5\n\n6"
00:37:41 <lambdabot>   ["5","","6"]
00:37:43 <Beelsebob> interesting
00:37:50 <ClaudiusMaximus> > words "a b      c "
00:37:51 <lambdabot>   ["a","b","c"]
00:38:07 <Beelsebob> oh well, I guess it is... other than the trailing newline
00:38:26 * Beelsebob wonders...
00:38:36 <Beelsebob> > (lines . unlines) ["5","6"]
00:38:38 <lambdabot>   ["5","6"]
00:38:55 <Beelsebob> okay, so that bins the final newline and is id
00:39:11 <ClaudiusMaximus> > lines ""
00:39:12 <lambdabot>   []
00:39:22 <ClaudiusMaximus> > unlines []
00:39:23 <lambdabot>   ""
00:39:31 <Beelsebob> heh
00:39:33 <Beelsebob> annoying
00:39:40 <luqui> > lines "x\n"
00:39:41 <lambdabot>   ["x"]
00:40:01 <Beelsebob> so it's not so much that it adds a trailing newline – it's that it doesn't detect only one elemnt left
00:40:09 <Beelsebob> which I guess makes sense
00:40:13 <Beelsebob> it couldn't be lazy without it
00:40:17 <Beelsebob> and would be near useless
00:44:16 <ClaudiusMaximus> @src lines
00:44:17 <lambdabot> Source not found. Just what do you think you're doing Dave?
00:48:20 <ski> @check \ss -> (lines . unlines) ss == id ss
00:48:22 <lambdabot>   "Falsifiable, after 398 tests:\n[\"\\1105281\\800718\\1021131\\228503\\4654...
00:48:41 <ski> @scheck \ss -> (lines . unlines) ss == id ss
00:48:44 <lambdabot>   "Falsifiable, after 366 tests:\n[\"\\240664\\800786\\197244\\160928\\757345...
00:48:54 <Twey> What is happening there?
00:49:01 <Twey> @src unlines
00:49:01 <lambdabot> unlines = concatMap (++ "\n")
00:49:04 <Twey> Ahhh
00:49:05 <Twey> Of course
00:49:11 <halberd> trailing newline
00:49:17 <Twey> unlines . lines is identity, but lines . unlines is not
00:49:28 <Twey> Since one of the strings in the list may itself have a newline in
00:49:30 <ski> @scheck \s -> (unlines . lines) s == id s
00:49:32 <lambdabot>   "Falsifiable, after 0 tests:\n\"\\952912\\242651\"\n"
00:49:40 <Twey> Which will be broken up when it gets to lines
00:49:41 <Twey> Huh.
00:49:48 <Twey> Ah, right
00:50:04 <ski> > lines "\952912\242651"
00:50:06 <lambdabot>   ["\952912\242651"]
00:50:12 <ski> > unlines (lines "\952912\242651")
00:50:13 <lambdabot>   "\952912\242651\n"
00:51:00 <ski> > lines "a\nb\n\nc"
00:51:02 <lambdabot>   ["a","b","","c"]
00:51:29 <ski> > words "a b  c"
00:51:30 <lambdabot>   ["a","b","c"]
00:51:42 <ski> interesting
00:52:22 <halberd> lines "a\n" is the same as lines "a"
00:52:30 <ski> one might expect `lines . unlines = id' or `words . unwords = id', but not the other directions
00:52:34 <halberd> so it's not 1-1 so can't be inverted
00:53:03 <ski> would it be tolerable if `lines "a\n"' was `["a",""]' ?
00:53:40 <ski> hm
00:53:42 <halberd> the Unix convention is that every file has a trailing newline
00:53:53 <halberd> so it would not be good if that counted as an extra blank line at end of file
00:54:42 <ski> actually, i suppose one might only expect `lines . unlines = id' on lists of strings not containing any newlines
00:57:50 <ski> hm, what's the conditional testing operation named again ?
00:58:06 <ski> @check \x -> x == False ==> x == False
00:58:08 <lambdabot>   Not in scope: `==>'Precedence parsing error
00:58:08 <lambdabot>      cannot mix `GHC.Classes.==...
00:58:29 <Gracenotes> unfortunate..
00:58:39 <ski> .. oh
00:58:43 <ski> @index ==>
00:58:44 <lambdabot> Test.QuickCheck, Debug.QuickCheck
00:58:56 <ski> @check \x -> x == False Test.QuickCheck.==> x == False
00:58:58 <lambdabot>   Not in scope: `Test.QuickCheck.==>'Precedence parsing error
00:58:58 <lambdabot>      cannot mix...
00:59:13 <ski> *sigh*
00:59:14 <Gracenotes> parens
00:59:18 <ski> @check \x -> (x == False) Test.QuickCheck.==> (x == False)
00:59:20 <lambdabot>   Not in scope: `Test.QuickCheck.==>'
00:59:29 <ski> @check \x -> (x == False) Debug.QuickCheck.==> (x == False)
00:59:31 <lambdabot>   Not in scope: `Debug.QuickCheck.==>'
01:00:01 <Gracenotes> suspect, @check is
01:01:22 <ski> i was going to try
01:01:23 <ski> @check \ss -> all (all ('\n' /=)) ss =>> (lines . unlines) ss == id ss
01:01:25 <lambdabot>   Not in scope: `=>>'
01:01:40 <ski> (fsvo `=>>', such as `==>')
01:02:33 <cads> why is it that it's extra fun to have discussions on a programming language other than the one featured in the topic
01:02:53 <ski> which one ? :)
01:03:26 <Tarrant> Hey I'm just playing around with "Learn you some haskell". I have this block of code http://codepad.org/JOVMoWvR and it just doesn't seem to want to work. I'm sure it is something very moronic that I'm missing.
01:03:54 <cads> ski, was talking about erlang in jruby
01:04:09 <ski> Tarrant : first, try indenting all the `|' lines at least one whitespace
01:04:21 <ziman> Tarrant, i guess it's the indentation in the `where' block
01:04:27 <cads> real web services oriented stuff, revolving around twitter and hypothetical poker servers that host thousands of concurrent games and such
01:04:53 <ski> yes, the definitions after the `where' must line up their starting characters
01:05:10 <cads> mostly bsing about what we think about it, what we've heard and some details of how it works
01:05:13 <halberd> Tarrant: you need to show sum
01:05:18 <cads> ever do that ski?
01:05:59 <cads> note, I don't think any of us were erlang programmers :)
01:06:04 <ski> cads : talked about one language in a channel for another ? or implemented web-y things ?
01:06:13 <cads> the former
01:07:14 <ski> Tarrant : also, i would factor out the `xs ++ "+" ++ ys ++ ":" ++ sum' part. DRY (Don't Repeat Yourself)
01:07:53 <ski> cads : sure
01:08:40 <cads> for example with erlang, the channel seems to be pretty quiet for some reason
01:09:05 <ski> Tarrant : note that if you factor out this part, then you don't need to factor out the `xs',`ys',`sum' part .. unless you think that improves readability for you
01:09:53 <Tarrant> ski: Thanks. This was really just an elaborate test for using multiple 'where's
01:09:57 <ski> (cads : i think that is partly related to there not being that many members of it)
01:10:16 <Tarrant> Once I change vim to use tabstop=4 spaces and reindented everything it started working.
01:11:02 <ski> Tarrant : you had no multiple `where's in the pasted code. (however you had (or attempted to have) multiple *definitions* inside a *single* `where'-clause)
01:12:01 <Tarrant> ski: Yes thats what I mean... :) As I said new here.
01:12:22 <ski> yw :)
01:13:26 <Ping_Pong> Google Wave to "redefine" E-mail communication...  Will this killer attempt succeed ??    people who aren't ware of Google wave ..check out at my blog for more details http://www.techfancy.co.cc
01:13:51 <ski> Tarrant : fyi, the brackets in the definitions of `xs' and `ys' are extraneous
01:14:16 * ski raises left eyebrow
01:14:47 * Ralith wonders if anyone has reported 117.195.204.105 for spam
01:14:57 <cads> google wave will be the shit
01:15:10 <Ralith> IRC will be the shit
01:15:11 <Ralith> oh wait
01:15:12 <Ralith> it already is
01:15:21 <Ralith> glad that's resolved
01:15:26 <cads> irc will still be here.
01:16:06 <cads> wave will be better than shit like facebook
01:16:31 <cads> have you guys seen the demo?
01:16:37 <Ralith> that's not saying much
01:16:38 <Tarrant> cads: Facebook had its place until they allowed these ridiculus spam applications in.
01:18:13 * ski mentions The speed, size and dependability of programming languages <http://gmarceau.qc.ca/blog/2009/05/speed-size-and-dependability-of.html> while we're OT
01:18:35 <Ralith> now that's actually an interesting topic
01:18:52 <Ralith> amusing misnomer of a url, too
01:19:06 <ski> how ?
01:19:10 <copumpkin> not sure where he got the dependability from
01:19:57 <Ralith> ski: "Speed, size, and dependability of .html"
01:20:04 <ski> (copumpkin : afaiu, how "wide" the appropriate diagram was)
01:20:31 <copumpkin> well, our diagram is particularly wide because one of our benchmarks just fails
01:20:37 <copumpkin> due to the lack of a regex package
01:21:14 <copumpkin> pulling dependability out of that seems particularly far-fetched :) but hey, it's a benchmark I guess
01:21:24 * ski was imagining failing benchmarks would just be missing data-points
01:21:47 <copumpkin> I dunno, we have one line going way far off to the right
01:22:13 <copumpkin> and the only benchmark where we aren't within a few x of gcc is the one we fail
01:23:19 <brian6> if one function f :: StateT S IO () is 'forever' watching something and updating S, can some forkIO'd thread share S, like get the current state with 'get'?
01:25:18 <sjanssen> ski: what is that crap?
01:25:32 <sjanssen> looks like a bunch of sophistry about shapes
01:25:43 <quicksilver> brian6: not automagically, no.
01:25:44 <lambdabot> quicksilver: You have 1 new message. '/msg lambdabot @messages' to read it.
01:25:50 <quicksilver> brian6: you will want to use an MVar
01:25:59 <sjanssen> (note, I haven't actually read the post yet)
01:26:22 <brian6> quicksilver: ok. so i have to come up with my own communication stuff, like Chan, etc.
01:26:22 <quicksilver> if you're feeling really clever, you can write a special MonadState instance for a custom monad where "get" calls readMVar, and put calls writeMVar
01:26:37 <quicksilver> and modify is guaranteed to be atomic.
01:26:44 <quicksilver> @messages
01:26:44 <lambdabot> ivanm said 1d 19h 29m 59s ago: after playing with kuribas' indentation mode, I recall using it once and discarding it because I keep expecting tab to indent no matter where in the line I am (and
01:26:44 <lambdabot> backspace doesn't unindent the same amount as tab indents either) :s
01:27:47 <quicksilver> @tell ivanm Backspace does unindent the same amount as tab indents.
01:27:47 <lambdabot> Consider it noted.
01:28:17 <quicksilver> @tell ivanm and tab not working anywhere in the line should be easy to fix - and seems much less important than haskell-mode getting it completely wrong :P
01:28:17 <lambdabot> Consider it noted.
01:31:43 <ski> (sjanssen : just something that might be interesting to discuss ..)
01:33:32 <quicksilver> I think sophistry is a little unfair
01:33:48 <quicksilver> it's an attempt at high level qualitive analysis, which is always a bit dodgy
01:34:10 <quicksilver> but the star charts are certainly an interesting way to visualise it.
01:49:38 <cads> wow
01:49:45 <cads> I've been hanging our here about a year
01:50:32 <cads> and compared to what I knew about computation a year ago, and the papers I could read, and the code in any language that I could understand, the difference is truly amazing
01:50:37 * QtPlaty[HireMe] gives cads a paper.
01:50:47 <cads> why thankyous good kindsir
01:50:53 * Twey gives cads a piece of paper
01:50:56 <Twey> Your turn to write :-P
01:51:05 <Berengal> cads: Autodidact?
01:51:39 <cads> just passionate about a few things
01:52:08 <cads> it's real fun to think about languages and theory
01:52:28 <cads> twey, I might have an idea in mind
01:53:49 <Baughn> Peaker: Well, I am now
02:07:32 <mmorrow> @seen sw17ch
02:07:33 <lambdabot> I saw sw17ch leaving #haskell 6d 5h 11m 43s ago, and .
02:07:40 <mmorrow> @preflex sw17ch
02:07:41 <lambdabot> Unknown command, try @list
02:07:43 <mmorrow> @preflex seen sw17ch
02:07:44 <lambdabot> Unknown command, try @list
02:07:50 <mmorrow> preflex: seen sw17ch
02:07:51 <preflex>  sw17ch was last seen on #haskell 26 days, 8 hours, 25 minutes and 52 seconds ago, saying: sweet! atom-0.0.3 is out.
02:08:16 <mmorrow> @tell i love libtask :)
02:08:17 <lambdabot> Consider it noted.
02:08:47 <mmorrow> (which is this: http://swtch.com/libtask/)
02:15:30 <jaj> mmorrow: don't you have to say "@tell sw17ch" ?
02:16:05 <mmorrow> haha
02:16:09 <mmorrow> jaj: thanks
02:16:14 <jaj> :)
02:16:24 <mmorrow> @tell sw17ch i love libtask :)
02:16:24 <lambdabot> Consider it noted.
02:29:05 <cads> Lor' luv a duck! Hey man, can we rock an' roll ter da stawer an' get some beers, I'm rarfer thirs'y if winnie da pooh know what I mean. Lets get some food along da way, chips an' gravy a cheezburger, I'm fuckin' starved. And lets cuff an' choke some  chicken feed . Know what I mean?
02:29:49 <cads> cockney rhyming slang is the shizzle!
02:30:15 <cads> http://www.cockneyrhymingslang.co.uk/rabbit translator
02:30:31 <tux-foo> cads, is it haskell based?
02:31:41 <tux-foo> cads, ah, that is what you meant with slang.
02:34:01 <tux-foo> \msg memoserv
02:39:07 <cads> tux-foo, it has to be a simple set of varying substitution rules
02:39:35 <cads> sometimes it replaces each s with debby laboos
02:40:02 <cads> so translator turns into trandebby labooslator
02:42:12 <ski> (tux-foo has quit)
03:03:58 <Peaker> Baughn: hey?
03:04:10 * Baughn pokes Peaker with a stick
03:04:27 <Peaker> Baughn: how's the unamb/joinE stuff doing?
03:04:38 <Peaker> Baughn: Do you know what bugs still remain in there?
03:04:41 <Baughn> Oh, it's not. Got another exam in two days, so I'm focusing on that right now.
03:04:52 <Baughn> Near as I can tell, unamb is now bugless
03:04:59 <Baughn> joinE is not, nor apparently is mappend
03:05:13 <Beelsebob> IIRC mappend's bug is caused by joinE's bug
03:05:15 <Beelsebob> via snapshot
03:05:32 <Beelsebob> or maybe it's the other way round
03:05:37 <Beelsebob> either way, they're connected
03:06:37 <Baughn> Right
03:06:43 <Peaker> Beelsebob: does anyone need joinE?  Do Reactive values need it for a monad instance?
03:06:55 <Baughn> Peaker: joinE is used for the Monad instance
03:06:57 <Beelsebob> hell yes!
03:07:08 <Baughn> And yes, it's incredibly useful. Or it would be, anyway
03:07:08 <Beelsebob> join is one of the more useful things you need to do
03:07:23 <Peaker> ah, any idea why it is broken?
03:07:27 <Beelsebob> join on behaviors would be super-useful too, but is near impossible to write right
03:07:27 <Peaker> what part of it is broken?
03:07:30 <Beelsebob> Peaker: lazyness
03:07:33 <Baughn> None. It's also incredibly involved.
03:07:38 <Beelsebob> it's very hard to get it to make enough progress
03:07:42 <Baughn> Well, "lazyness" is a good guess. :)
03:08:02 <Beelsebob> last time I went through it I came to the same conclusion as Conal...
03:08:03 <quicksilver> I don't think the Event monad instance is useful.
03:08:11 <quicksilver> but, I do think joinE is useful.
03:08:13 <Beelsebob> that the MaxBound type is not right
03:08:16 <quicksilver> you need to to define filterE
03:08:29 <quicksilver> it's the only way to get an event that has fewer occurrences than the one you put in...
03:08:32 <Baughn> Never mind filterE, joinE is useful on its own
03:08:35 <Beelsebob> quicksilver: because the monad instance doesn't agree with the applicative one?
03:08:56 <quicksilver> Beelsebob: >>= just doesn't seem to be useful, for events. To me.
03:09:15 * Beelsebob tries to remember where he found that useful
03:09:21 <quicksilver> although return, ap and join are all independently useful
03:09:24 <Beelsebob> maybe it only was behaviors that I found it useful
03:09:31 <quicksilver> hell yeah.
03:09:32 <Beelsebob> (and not implemented)
03:09:37 <quicksilver> behaviours are *definitely* monads
03:09:37 <Beelsebob> (because it's bloody hard)
03:09:43 <quicksilver> reactives too.
03:09:50 <quicksilver> in an obvious natural way
03:09:57 <Beelsebob> hmm?
03:09:57 <quicksilver> (which may indeed be impossible to implement :P)
03:10:09 <quicksilver> it's just that events don't seem right, to me.
03:10:12 <luqui> quicksilver, that is a wish, or do you have evidence? :-)
03:10:13 <Beelsebob> the issue with implementing it is that you lose the ability to find the constant parts
03:10:16 <quicksilver> still, doesn't make joinE any less important.
03:10:23 <Beelsebob> and hence lose all your efficiency
03:12:05 <Peaker> quicksilver: you can get less events than you put in, as join multiplies the amounts, it can be multiplied by 0 :-)
03:12:19 <quicksilver> Peaker: that's exactly what I said.
03:12:33 <quicksilver> Peaker: join is the *only* way to get an event with fewer occurrences than you put in.
03:12:34 <Peaker> quicksilver: I thought you said only filterE can get a lesser event
03:12:34 <Beelsebob> Peaker: he said without joinE you can't get fewer events than you put in
03:12:47 <quicksilver> that's why it's so important.
03:12:49 <Beelsebob> no, he said filterE relied on joinE
03:12:58 <Beelsebob> because joinE is the only way of taking away events
03:12:59 <Peaker> oh, didn't know filterE was on top of joinE
03:13:13 <quicksilver> fmap and <*> always give you occurrences based on incoming events
03:13:25 <quicksilver> so joinE is really really importasnt.
03:13:39 <quicksilver> Yeah, if you think about filterE for a while it's obvious that the sensible way to implement it is using joineE
03:13:51 <quicksilver> of course, you could inline + specialise and implement it directly.
03:16:47 <Peaker> what does   blah <*> mempty   get?
03:17:17 <quicksilver> oh, that's a good point.
03:17:31 <quicksilver> <*> does let you trim initial segments.
03:19:40 <Peaker> quicksilver: How does Deus/whatsitsname compare to Reactive?
03:20:04 <quicksilver> Deus/Reactive ;)
03:20:17 <LeCamarade> @tell conal I'd like to talk to you about the weird behaviour I get with threads. I didn't manage to get you to reply last week, before I had to go away.
03:20:17 <lambdabot> Consider it noted.
03:20:24 <defun> hi. out of sheer curiosity, why didn't cabal use haskell as a package description format, and instead made their own?
03:20:34 <quicksilver> its mappend is not guaranteed deterministic for nearly simultaneous events
03:20:41 <quicksilver> (futures, rather)
03:20:57 <quicksilver> and it doesn't share as aggressively as reactive is intended to
03:21:03 <quicksilver> however it does work, including joinE/filterE
03:21:25 <quicksilver> the stars demo I uploaded shows most of the working bits working.
03:21:28 <dcoutts> defun: using a fully featured language to describe a package makes it much harder to translate into other languages. Using a deliberately less expressive language makes that feasible.
03:21:55 <defun> I see.
03:22:33 <Baughn> As it is, it's feasible to, f.ex., automatically translate cabal packages to Arch packages
03:22:37 <Gracenotes> :>
03:25:25 <defun> dcoutts: however, it would have been feasible, correct?
03:25:34 <dcoutts> defun: it'd be possible to use a Haskell data structure to represent the same info, but that gains little over a text representation of the same
03:26:03 <Baughn> defun: Translating to other languages would /not/ have been possible
03:26:03 <dcoutts> defun: the key point is that the description language be inexpressive.
03:26:15 <Baughn> Seeing as most of the package description formats are not, in fact, turing-complete
03:26:26 <defun> I see. Makes sense.
03:27:03 <dcoutts> defun: think how hard it'd be for an IDE to edit a package description if it's general purpose code
03:27:17 <Baughn> We have an IDE?
03:27:31 <dcoutts> Baughn: we've got half a dozen :-)
03:27:55 <quicksilver> Baughn: well, that's not strictly fair. For example, using haskell code as a description, the specification could have been that it defines top-level values which evaluate to the various fields.  A translator could just 'run' that code and then output that to the alternative package description.
03:28:11 <quicksilver> Baughn: that would effectively 'freeze' any dynamism present in the haskell language description.
03:28:17 <quicksilver> This is not a criticism of the decision however.
03:28:23 <quicksilver> It's merely unproductive pedantry.
03:28:33 <dcoutts> quicksilver: right, but that was my point, it doesn't gain much over just storing the output of that program
03:28:40 <dcoutts> quicksilver: and it allows editing
03:28:42 <quicksilver> agreed.
03:29:04 <dcoutts> quicksilver: it'd allow redundancy in the data to be shared in the generator
03:29:06 <Baughn> And besides, people /would/ stick code in there that depends on the current state of the system
03:29:15 <Baughn> Even if they have to use unsafePerformIO
03:29:42 <dcoutts> Baughn: heh, yeah. You should look at Setup.hs scripts some time. I've found the worst code in there.
03:30:07 * RayNbow feels odd after having sent his first email to the Haskell cafe mailing list...
03:30:16 <Baughn> dcoutts: I have some idea why. I've been trying, unsuccessfully, to make cabal test do anything useful for unamb for a while now.
03:30:48 <dcoutts> Baughn: yep, the api was never designed
03:31:09 <Baughn> ..you're not going to say "for that", are you?
03:32:07 <dcoutts> Baughn: nope
03:32:28 <Baughn> I thought so.
03:32:45 <Baughn> *not, I suppose. Bloody english language.
03:32:52 <dcoutts> I mean there's a definite lack of design in the API exposed to Setup.hs scripts
03:33:02 * Baughn snorts
03:33:18 <Baughn> All I really want to do is have it build the library.. build an executable... and run it.
03:33:46 <mmorrow> i think haskell data (already evaluated a la output of Show) is win win. most of all because you can Read it in.
03:33:58 <Baughn> Say. How come, if you have executables in the same package as a library, it'll build any files the executables depend on twice?
03:34:04 <mmorrow> and prettyprint it with (eg) haskell-src-exts
03:34:44 * mmorrow use hstidy (which is just main = prettyPrint . parse) constantly
03:35:07 <mmorrow> hstidy -e < package.conf | HsColour -tty | less -r
03:35:12 <dcoutts> Baughn: because you cannot yet say that the exe depends on the lib
03:35:33 <dcoutts> Baughn: but blackh and I finished the changes to let you do that yesterday
03:35:46 <Baughn> That's good timing. :)
03:35:52 <dcoutts> Baughn: in general you might be using different options, so we cannot share them
03:36:01 <dcoutts> Baughn: eg different cpp options
03:36:01 <Baughn> Shouldn't it figure.. ah
03:36:19 <Baughn> dcoutts: It can't check if that happens to not be the case?
03:36:39 <dcoutts> also, we cannot share between a lib and an exe anyway because they use different package names in the compiled code
03:37:11 <dcoutts> the right solution is not ad-hoc sharing I think, but explicit sharing
03:37:24 <dcoutts> that also allows one to share the options rather than duplicating them
03:38:30 <Baughn> So, how will that work? build-depends: foo in foo.cabal?
03:43:57 <byorgey> dcoutts++ blackh++
03:50:22 <mmorrow> unix pipes are pure friggin genius
03:51:00 <defun> if, however, cabal /was/ designed to use haskell as a pkg description language, how would the devs implement a way of 'loading/reading' the description? Through ghci? Could, theoretically, the pkgs descriptions be pre-compiled and loaded by GHCI/Cabal? Or am I way off?
03:52:23 * Baughn deletes 111GB of logfiles. I was wondering why /home was full...
03:54:53 <Baughn> defun: You could in theory compile to bytecode and distribute that, but I don't think ghci's bytecode is designed to be serializable
03:55:09 <Baughn> defun: Meanwhile, actual executable code would be inherently machine-specific
03:55:13 <mmorrow> http://www.cs.dartmouth.edu/~doug/
03:56:07 <mmorrow> defun: read
03:56:21 <defun> on it.
03:56:25 <defun> thanks.
03:56:29 <mmorrow> @type read
03:56:31 <lambdabot> forall a. (Read a) => String -> a
04:05:18 <mjrosenb> hrmm, i would like to use haskell somplace rather unorthodox
04:05:26 <mjrosenb> i don't think that this is going to work
04:16:56 <osfameron> erlang factory http://www.erlang-factory.com/conference/London2009 looks nice... but it's *expensive*
04:17:03 <osfameron> .summon a grassroots FP conference!
04:23:37 * mjrosenb wants haskell merch that probably does not exist
04:29:00 <Baughn> > (33*1024*1024) * (8 * 2 + 8 + 8 + 8 + 8)
04:29:01 <lambdabot>   1660944384
04:29:25 <Baughn> ..well, that explains it. This has to be among the least efficient memory formats I've ever seen.
04:29:43 * Baughn just saw a 66MB WAV file eat all his memory
04:29:57 <Beelsebob> haha
04:30:30 <quicksilver> NOM.WAV
04:31:30 <mjrosenb> Baughn: did you attempt to load the raw data in as a list of bytes?
04:31:41 <Baughn> mjrosenb: Worse. I used the WAVE package.
04:32:02 <Baughn> mjrosenb: It loads samples as lists of Int, one element per channel.
04:32:16 <Baughn> The entire file is, of course, a list of samples.
04:32:21 <mjrosenb> oic
04:32:29 <quicksilver> that's probably OK if you manage to produce + consume that list lazily
04:32:30 <mjrosenb> sexy-fun time
04:32:40 <quicksilver> it's not OK if you are doing global analysis on it ;)
04:32:43 <mjrosenb> it'll have your g.c. crying out in pain
04:32:55 <Baughn> Fortunately I managed to press C-\ fast enough
04:32:57 <quicksilver> the GC is surprisingly good at that
04:33:05 <quicksilver> given a modern CPU with a large cache
04:35:22 <mxc> hi everyone..  question about newtype vs data performance..  specfically, declaring something like:
04:36:00 <mxc> newtype T = Int vs data T = T {-# UNPACK #-} !Int
04:36:17 <Baughn> newtype T = T Int, I hope.
04:36:55 <Baughn> mxc: Okay, so what's the question?
04:36:58 <mxc> actually, i guess newtype T Int# would be the fastest
04:37:23 <Baughn> I wouldn't bet on it. Overruling the optimizer that way can lead to terrible performance.
04:39:26 <mmorrow> this is good: http://www.cs.dartmouth.edu/~doug/components.txt
04:39:44 <mmorrow> (from 1968)
04:40:03 <mmorrow> (creator of unix pipes)
04:41:23 <quicksilver> mxc: Int itself is already unpacked
04:41:37 <quicksilver> mxc: so, AFAIK, there is no performance difference between Int and Int#
04:41:41 <mxc> ty
04:41:47 <quicksilver> it's just the latter is a GHC primitive
04:41:54 <quicksilver> I would use the newtype not the data.
04:42:02 <quicksilver> the newtype is guaranteed zero-overhead
04:42:05 <quicksilver> the data just probably is.
04:42:15 <quicksilver> they have slightly different semantics, too.
04:43:16 <Athas> My Haskell program runs out of stack space when I run it, where should I start in figuring out why?
04:43:33 <Athas> The main loop is tail-recursive.
04:43:44 <quicksilver> are you compiling with optimisation?
04:43:58 <Athas> With -O, yes.
04:44:05 <ziman> maybe you're building a large thunk elsewhere
04:44:42 <Athas> I considered that, but almost all my functions are strict in their arguments (via BangPatterns).
04:44:49 <Athas> So I can't really see where it would be built.
04:44:52 <mjrosenb> i've found that 'tail recursive' does not always mean that it doesn't use alot of stack space
04:45:12 <mjrosenb> since laziness can make assumptions go to hell
04:45:26 <quicksilver> well it may use zero stack space, building a large thunk
04:45:33 <quicksilver> but that thunk takes stack space when you later force it :)
04:46:41 <byorgey> Athas: note that bang patterns only force things to weak head normal form.
04:46:52 <byorgey> So depending what it is you are "forcing" it may not get forced very far.
04:47:11 <byorgey> Athas: if you paste your code somewhere (e.g. hpaste.org) we could take a look at it
04:47:31 <cads> I'm tired of programming in ascii, I would buy a special keyboard to type a programming language where special symbols are used predominantly
04:47:49 <Athas> It's 223 lines, though, but pretty simple:  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5468#a5468
04:47:54 <cads> there apl
04:47:57 * byorgey thinks we should have !! for forcing via deepSeq
04:47:57 <quicksilver> @go optimus maximus keyboard
04:48:01 <lambdabot> http://www.artlebedev.com/everything/optimus/
04:48:01 <lambdabot> Title: Optimus Maximus keyboard
04:48:01 <cads> there's*
04:48:01 <Athas> It's a simplistic implementation of the virtual machine from ICFP 2006.
04:48:03 * byorgey humbly proposes the name "
04:48:08 <quicksilver> cads: that one?
04:48:09 <byorgey> "WhizBang patterns"
04:48:13 <Athas> You will also note that I went a bit overboard with the exclamation marks out of desperation.
04:48:14 <cads> quicksilver: had that in mind :)
04:48:21 <quicksilver> byorgey: deepSeq is generally a mistake
04:48:29 <byorgey> quicksilver: oh?
04:48:33 <quicksilver> byorgey: it costs O(n)
04:48:42 <quicksilver> byorgey: you don't want to do that without thinking about it carefully :)
04:48:47 <cads> can I get rich typing apl code?
04:48:50 <quicksilver> it least seq is O(1) at worst.
04:48:56 <byorgey> quicksilver: hmm, true =)
04:49:01 <cads> if so I will buy that keyboard.
04:49:07 <ziman> cads, edwardk has a vim plugin that replaces -> with → and so on, i use it and i like it much :)
04:49:36 <byorgey> cads: try programming in Agda =)
04:49:44 <cads> wow
04:49:46 <ziman> but i'd welcome a keyboard with a mathpad, definitely :)
04:49:47 <cads> absolutely!
04:49:48 <quicksilver> Athas: and yet, you don't have ! in any of the places that matter :)
04:50:01 <quicksilver> Athas: your big record MachineState has all lazy fields.
04:50:04 <cads> byorgey: why didn't I think of that, you're the man!
04:50:06 <Athas> quicksilver: actually, I do!  At least, the program rapidly ran out of heap space on many inputs beforehand.
04:50:22 <Athas> What's the notation for strict fields?
04:50:33 <Athas> I only just realised that 'seq' isn't the only strictness-controlling function today.
04:50:42 <Baughn> data Foo = Foo !Int Double -- the Int is strict, the Double isn't
04:50:56 <quicksilver> "const $!" is not useful, as far as I can see.
04:51:15 <byorgey> Athas: being strict in a MachineState argument is useless.  it will only evaluate it far enough to find out that, sure enough, it really is a MachineState, and not _|_
04:51:21 <byorgey> but it won't actually evaluate any of the fields.
04:52:37 <Athas> Most (all) of the $!'s were inserted out of desperation.  I will try your suggestion, thanks.
04:53:27 <byorgey> if you make all the MachineState fields strict (and you can also remove all the bang patterns matching on MachineState arguments in various functions) it should improve.
04:54:05 <byorgey> although the Map may still be a problem, depending on how it is used.
04:54:18 <quicksilver> if you update values in the map, make sure you do that strictly
04:56:13 <Athas> How do I make the map strict?  I can't figure out the syntax.
04:56:19 <quicksilver> you can't.
04:56:28 <quicksilver> you can't change someone else's data type.
04:56:36 <quicksilver> if you update the values in the map, make sure you do that strictly.
04:56:47 <quicksilver> Oh, the whole map?
04:56:53 <Baughn> (Or else use rnf)
04:56:55 <quicksilver> { ... myMap :: !(Map Foo Bar) ... }
04:56:58 <quicksilver> if that's what you meant.
04:57:26 * quicksilver doubts that adding a O(size of map) rnf operation to every update is a good idea.
04:57:41 <maltem> I'd call that “be strict in the map”
04:57:47 <quicksilver> except, perhaps, as an experiment to see if it makes the stack overflow goes away.
04:57:49 <Athas> Of course, parentheses!  I kept getting errors about "Unexpected strictness annotation" by merely prepending the exclamation mark.
04:58:00 <Baughn> rnf is a bit of a sledgehammer, though. With Map, it's useful to know that it's already strict in its keys (at least to the point that compare is strict), so rwhnf'ing the map will probably force that well enough
04:58:03 <Athas> What a mark of shame that a Lisp hacker gets the parentheses wrong.
04:58:06 <Berengal> I thought Map was strict in everything but the values already
04:58:12 <Baughn> THen you just have to make sure the values you insert are evaluated. Or not, if you like.
04:58:34 <Baughn> Berengal: It calls compare on the keys. That's not exactly being strict, except usually.
04:58:45 <quicksilver> Berengal: it's strict in the shape. It's strict in the keys to the extent required to build/maintain the shape.
04:59:01 <Berengal> Prelude Data.Map> :info Map
04:59:01 <Berengal> data Map k a = Data.Map.Tip
04:59:01 <Berengal>   | Data.Map.Bin !Data.Map.Size !k a !(Map k a) !(Map k a)
04:59:22 <quicksilver> oh :)
04:59:25 <quicksilver> well tehre you go.
04:59:32 <Baughn> Mm. I was wondering if rwhnf would suffice to force its shape. Apparently yes.
04:59:34 <quicksilver> Berengal++ # checking the source, not guessin.
05:00:07 <Baughn> ..should it really be this hard to get it right?
05:01:57 <Baughn> quicksilver: Say, how about an rnf variant that checks isEvaluated before recursing?
05:02:26 <mmorrow> "Much of the work will be in creating generators of routines rather than in making the routines themselves."'
05:02:56 <Berengal> mmorrow: What's that from?
05:05:56 <mmorrow> http://www.cs.dartmouth.edu/~doug/components.txt
05:06:16 <mmorrow> it's good
05:06:23 <mmorrow> (i'm just finishing)
05:06:25 * Berengal goes off to read
05:06:57 <Baughn> quicksilver: Hm. Actually, I think I can implement that without needing a class.
05:07:00 <mmorrow> Berengal: (note the date of publication)
05:07:06 <Baughn> ..actually, I could do the same with rnf. Hm.
05:10:21 <Berengal> mmorrow: I did
05:13:00 <mauke> <ew73> alas, poor compiler.  I knew it well, RMS.  Twas a executable of infinite recursion...
05:13:36 <Athas> Damn, still stack overflow.  I suspect I am still not strict enough...
05:18:30 <hackagebot> ghc-mtl 1.0.1.0
05:45:34 <kynes> I have a question about QuickCheck
05:45:50 <kynes> let me first paste the code
05:46:10 <kynes> http://pastebin.com/d2584d675
05:47:08 <kynes> here I call "minsert" to generate an instance of the abstract data type QuadTree
05:47:08 <kynes> minsert calls the "insert" function that's exported by QuadTree
05:47:12 <kynes> I can see the underlying QuadTree by using "verboseCheck"
05:47:38 <hackagebot> time 1.1.3
05:47:47 <kynes> but since it's implementation dependant, I just want to see "insert(..., insert(...) )
05:47:55 <kynes> style strings..
05:48:18 <kynes> I mean I want to see the a,b,c,d values generated together with the insert function applied
05:48:29 <kynes> before a QuadTree is formed by calling "insert"
05:48:33 <kynes> how can I do this?
05:48:38 <hackagebot> ghc-mtl 1.1.0.2
05:48:38 <hackagebot> terminfo 0.3.1
05:49:07 <kynes> I tried using "trace" in minsert but it just gives a list of "insert (....)" strings.. not in expression form
05:52:21 <Athas> I feel I am missing something.  The following program still exhausts the stack and I suspect that large thunks are the cause.  I am still highly inexperienced with strictness optimisation of Haskell programs, so I have little clue where to go from here, or even whether what I have done is correct.  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5469#a5469
05:52:50 <LeCamarade> ?seen conal
05:52:50 <lambdabot> I saw conal leaving #haskell, #ghc and #haskell-in-depth 8h 1m 58s ago, and .
05:52:58 <LeCamarade> ?seen dons
05:52:59 <lambdabot> dons is in #haskell-in-depth, #concatenative, #arch-haskell, #darcs, #yi, #xmonad, #ghc and #haskell. I last heard dons speak 8h 22m 15s ago.
05:57:45 <burp> is there any numerical multidimensional root finding for haskell?
06:06:43 <Gons01> ONLINE Strategy GAME >> http://href.hu/x/95rh >OR< http://www.hackthat.net/df/ddos/74576/index.hack ! NO DOWNLOAD NEEDED !
06:09:34 <aavogt> > 27 ** (1/3) -- burp ?
06:09:35 <lambdabot>   3.0
06:10:30 <burp> aavogt?
06:12:59 <aavogt> burp: so roots of general functions, not like square roots?
06:13:25 <burp> yes
06:13:38 <burp> thats why I mentioned multidimensional ;)
06:14:19 <burp> sadly hmatrix only has an interface for multidimensional minimization
06:14:23 <burp> which could be used for root finding
06:14:36 <burp> but it doesn't work very well in some cases
06:14:42 <burp> http://hackage.haskell.org/packages/archive/hmatrix/0.5.1.1/doc/html/Numeric-GSL-Minimization.html
06:24:48 <hackagebot> bindings 0.1.1
06:40:52 <hackagebot> bindings-libusb 0.0.1
06:58:34 <nominolo> @seen Baughn
06:58:34 <lambdabot> Baughn is in #ghc, #haskell-in-depth and #haskell. I last heard Baughn speak 1h 51m 28s ago.
07:00:55 <Baughn> nominolo: Yes?
07:01:33 <nominolo> Baughn: you asked about scion.  I'm rearranging some stuff, but then it'll make it to Hackage.
07:01:46 <Baughn> Ah.
07:01:58 <nominolo> I could really use some Vim hackers, though
07:02:12 <Baughn> I tried to use its emacs mode, with little success, but I imagine the main axis of effort has been towards the haskell API
07:02:39 <nominolo> Baughn: well, I'm kind of busy with other stuff
07:02:53 <nominolo> Baughn: and testing those things is difficult
07:02:58 <Baughn> nominolo: I'll figure I have a look at it eventually, but I'm kind of busy with reactive too
07:03:06 <nominolo> there're so many configurations of Emacs out there...
07:03:12 <Baughn> :)
07:03:30 <Baughn> Emacs could really have benefited from a more modern architecture. Oh well.
07:04:54 <trofi^w> i'd like emacs worked slightly faster
07:05:09 <nominolo> it's slow?
07:05:14 <nominolo> you mean startup?
07:05:30 <trofi^w> nope, overall work
07:05:34 <Baughn> Some modules can freeze it for seconds at a time - tramp, say
07:05:37 <trofi^w> syntax highlight, search
07:05:48 <Baughn> ..but those are usually instant
07:05:50 <nominolo> no problems over here
07:05:56 <trofi^w> it starts awfully slow, but i do it ince a week :]
07:06:08 <Baughn> Well, maybe trofi's on an old computer?
07:06:12 <nominolo> takes 5sec or so
07:06:26 <trofi^w> model name      : AMD Athlon(tm) 64 X2 Dual Core Processor 4000+
07:06:42 <Baughn> ..then I've got no clue. It shouldn't be slow.
07:07:00 <trofi^w> it isn't slow in general
07:07:03 <nominolo> mine is 3 years old (Core1Duo 1.83)
07:07:11 <trofi^w> but sometimes ...
07:15:15 <stepnem> nominolo: plenty of Vim hackers in #vim, don't see you there...? :)
07:16:02 <nominolo> stepnem: that's because I use Emacs.  But I wanted to get the basics working for Scion
07:16:41 <stepnem> nominolo: right, my remark was meant as a suggestion that you might want to ask at #vim
07:16:58 <nominolo> stepnem: so it's not a priority for me, but I wanted to get the tricky stuff out of the way, so that Vim users can tailor the UI to their preferences
07:17:15 <stepnem> ah, I see
07:20:59 <Reiv> What on earth?
07:21:17 <Gabbie> Not on Earth, but the Moon!
07:21:24 <Reiv> http://pastebin.com/d608b32f gives the error ERROR file:.\parser.txt:59 - Syntax error in expression (unexpected `}', possibly due to bad layout)
07:21:24 <Reiv> Parsing>
07:22:31 <mauke> is that stuff at the bottom part of the file?
07:24:18 <rick_2047> hey people a problem here, i just installed hugs98 from arch linux pakage manager pacman and tried the examples provided with it but none of them are working
07:24:29 <rick_2047> it says cannot load this or that module
07:24:42 <mauke> like what
07:25:03 <rick_2047> mauke, wait i will provide a paste bin
07:25:47 <mac_wooster> Has anyone tried a parser for Verilog?
07:26:41 <rick_2047> mauke, http://pastebin.com/d2c317501
07:26:45 <rick_2047> here is what i tried
07:26:51 <rick_2047> u can see the error
07:26:58 <rick_2047> its a demo file provided with hugs
07:27:15 <mauke> no idea what AnsiInteract is
07:27:40 <rick_2047> its there in the include dir so it must b a standard lib i think
07:28:12 <mauke> it isn't
07:28:26 <rick_2047> ok
07:28:46 <rick_2047> i loaded another and thats working
07:28:50 <nibro> Reiv: you need to properly indent the lines at the end
07:28:50 <rick_2047> might b my faults
07:28:51 <mauke> sorry, I don't use hugs myself
07:29:04 <thoughtpolice> rick_2047: most people use GHCi
07:29:08 <rick_2047> i am using it as i am struggling to install ghc
07:29:34 <rick_2047> thoughtpolice, i tried to do the porting thing
07:29:41 <rick_2047> but couldn't figure it out
07:29:53 <nominolo> rick_2047: what platform are you on?
07:30:07 <rick_2047> archlinux
07:30:12 <rick_2047> i know there is a binary
07:30:19 <rick_2047> but i like to install from source
07:30:28 <mauke> so get the binary first, then recompile the source
07:30:44 <nominolo> rick_2047: well, you need the binary to compile it ;)
07:30:47 <rick_2047> that sounds obscure but if its the only resolve
07:31:00 <mauke> how did you install gcc?
07:31:16 <nominolo> rick_2047: there used to be C-files to bootstrap from, but that's currently defunct
07:31:40 <rick_2047> mauke, it came preinstalled with arch
07:31:45 <rick_2047> mauke, but i got ur anology
07:32:05 <CSWookie_> rick_2047: Why do you like to compile from source?
07:32:21 <rick_2047> CSWookie_, i dont know
07:32:30 <rick_2047> CSWookie_, so i can run into problems i think
07:32:42 <CSWookie_> rick_2047: Work for work's sake is the bad.
07:32:49 <rick_2047> works for me but
07:32:56 <rick_2047> also there is this bandwidth difference
07:33:12 <rick_2047> the source is 1/10 the size of binary
07:33:16 <rick_2047> and i pay for bandwidth
07:33:48 <CSWookie_> rick_2047: That's arguably a good reason.  I think if I were you I'd look for a better provider, though./
07:34:04 <rick_2047> CSWookie_, where i am this is the best
07:34:25 <rick_2047> but as this is the start of the month and i have fresh 1gb with me so i think i can afford ghc
07:36:30 <rick_2047> is hugs out of dev??
07:38:53 <rick_2047> the haskell mailing list is small
07:39:09 <Axman6> rick_2047: it's software... it's probably always going to be under development
07:39:44 <rick_2047> Axman6, ya and hugs seems to b out of dev
07:40:01 <Axman6> out of dev?
07:40:39 <rick_2047> Axman6, out of development
07:40:49 <rick_2047> Axman6, sorry i am new to the community
07:40:53 <Axman6> i understand the words, not what you mean by them
07:41:01 <mauke> Axman6: it's dead, jim
07:41:16 <Axman6> also, if you want a haskell mailing list, use haskell-cafe
07:41:31 <rick_2047> but it has like 500 users only
07:41:49 <Axman6> and like 200 messages a day
07:42:00 <rick_2047> wow
07:42:06 <rick_2047> how do u people manage that
07:42:17 <Axman6> i don't
07:42:42 <rick_2047> no i mean how does a community of 60 people post 200 msgs a day??
07:42:59 <mauke> 500 == 60?
07:43:20 <rick_2047> sorry i mean even for 500 people its big
07:43:32 <rick_2047> ruby has like thousand and there are less posts per day
07:43:44 <CSWookie_> Haskell is mainly an academic language, no?
07:43:50 <Axman6> yeah but ruby users are..
07:43:54 <rick_2047> i tried ruby for a year and it seems a dead community
07:43:56 * Axman6 stops himself
07:44:13 <rick_2047> Axman6, the word u are looking for is...
07:44:31 <Axman6> CSWookie_: sort of. it's not that it's not very useful in the real world, just that most people using it are doing research with it
07:45:14 <Berengal> Does hobbyist programming count as academic?
07:45:22 <CSWookie_> Axman6: That's what I mean. I wasn't trying to be pejorative, but the academic community is more chatty than professional ones.  I mean, ideas are their primary output.
07:45:23 <Axman6> i wouldn't
07:45:34 <Axman6> yeah
07:46:01 <rick_2047> so this hobbiest would have his first taste of academia
07:46:12 <rick_2047> Berengal, u doing hobby work on haskell
07:46:37 <Berengal> rick_2047: Yeah
07:46:54 <rick_2047> Berengal, what kind of work can b done
07:46:56 <Berengal> At least, I don't do any research, and I don't do it at work. To me that counts as hobbyist
07:47:13 <rick_2047> Berengal, dont tell me its only about research analysis or math
07:47:33 <rick_2047> Berengal, i wanna do some fun stuff like network things and graphics
07:47:42 <rick_2047> Berengal, ok graphics is far fetched
07:47:48 <Berengal> rick_2047: Heh, not at all. I use it as my main language outside of work
07:47:52 <Axman6> that's what research is all about
07:48:18 <Axman6> anyway, haskell has some great libraries for netwokring and graphics
07:48:47 <mauke> netwok ring? is that like token ring?
07:49:27 <Berengal> I thought about creating an l-system implementation...
07:49:34 <rick_2047> but on the surface its code will look like a math formal proof
07:49:55 <Berengal> rick_2047: Depends on what you mean by proof
07:50:17 <gwern> mauke: no, it's a networked wok; so you can turn it on before you get home
07:50:19 <rick_2047> i am not sure fully as i have seen very little code
07:50:27 <gwern> and stirfry some delicious lambdas on arrival!
07:50:52 <Axman6> how efficient are Chan's are sending messages between threads? is there any more efficient communication method?
07:51:14 <Axman6> @ser map
07:51:15 <lambdabot> Maybe you meant: arr let seen src users vera
07:51:19 <Axman6> @src map
07:51:19 <lambdabot> map _ []     = []
07:51:20 <lambdabot> map f (x:xs) = f x : map f xs
07:51:28 <Axman6> rick_2047: look like a proof to you?
07:51:36 <gwern> Axman6: Chans are known to be slow in some respects
07:51:55 <gwern> so I guess if you know you need performance, mvars would be faster?
07:52:15 <rick_2047> Axman6, not totally
07:52:26 <Axman6> well, Chans are just a bunch of MVars, but yeah. though you lose some async stuff
07:52:42 <rick_2047> Axman6, but it does look like a function definition
07:52:51 <Berengal> @type map
07:52:54 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
07:52:54 <rick_2047> Axman6, ok sratch my last statement
07:52:59 <Berengal> That look like a proof?
07:52:59 <Axman6> rick_2047: that's lucky, because it happens to be one :P
07:53:19 <rick_2047> Axman6, i made a fool of myself on my first day in the community
07:53:30 <Axman6> heh
07:53:34 <Axman6> nah you didn't
07:53:35 <rick_2047> someone might as well post this on bash.org
07:54:29 <rick_2047> Axman6, its fun watching haskell funtions redused step by step
07:54:43 <rick_2047> ghc is taking forever to download
07:54:44 <Axman6> @hoogle reduce
07:54:45 <lambdabot> No results found
07:54:51 <gwern> Berengal: it looks like a theorem to me! but I'm not seeing any proof
07:54:52 <rick_2047> my network speed is slow
07:54:53 <Axman6> @hoogle simplify
07:54:54 <lambdabot> No results found
07:54:57 <Axman6> bleh
07:55:09 <rick_2047> Axman6, what are u looking for
07:55:34 <Acteum> sounds like he is looking for foldl
07:55:35 <gwern> yeah. map/reduce is map/fold in haskell
07:55:37 <Berengal> gwern: How high is your abstraction level? ;)
07:55:45 <Axman6> there's a function which can take a mathematical expression and reduce it by one step. when you iterate it, it's pretty cool
07:55:52 <gwern> Berengal: high as a rocket!
07:56:00 <Acteum> @type foldl
07:56:01 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
07:56:06 <gwern> Axman6: so... some sort of eval or fixpoint?
07:56:14 <Axman6> it's part of the simple reflect package i think
07:56:27 <rick_2047> thats strange its written haskell is of lisp family
07:56:36 <seliopou> gwern, not exactly map/fold
07:56:37 <rick_2047> but nothing like lisp is there in the looks
07:56:46 <rick_2047> expt for the functional approach
07:56:50 <Axman6> it is reduce!
07:56:56 <gwern> rick_2047: no, lisp is a simply typed lambda; haskell is a polymorphic lambda
07:57:02 <Berengal> rick_2047: They're both functional languages, but that's where the similarities end for the most part
07:57:02 <gwern> rick_2047: different places on the lambda cube
07:57:02 <Axman6> > reduce (1 + 2 + 3)
07:57:04 <lambdabot>   3 + 3
07:57:06 <mapreduce> lisp is untyped.
07:57:15 <lilac> rick_2047: arguably, your 'haskell programs look like formal math proofs' formalizes into the Curry-Howard isomorphism
07:57:15 <seliopou> there was actually a paper about the types of map/reduce in a haskell implementation
07:57:25 <Axman6> > reduce (1 + 2*(4^5) + 3)
07:57:26 <lambdabot>   1 + 2 * (16 * (4 * 4) * 4) + 3
07:57:33 <ziman> > fix reduce
07:57:38 <lambdabot>   mueval-core: Prelude.read: no parse
07:57:39 <lambdabot>  mueval: ExitFailure 1
07:57:52 <rick_2047> u people do have some prety bots up
07:58:15 <seliopou> Oh, sorry thought you were talking about MapReduce
07:58:17 <seliopou> :P
07:58:24 <ziman> :t reduce
07:58:25 <lambdabot> Expr -> Expr
07:58:27 <Axman6> > iterate reduce (3^7)
07:58:29 <lambdabot>   [3 * 3 * (3 * 3) * (3 * 3 * 3),9 * (3 * 3) * (3 * 3 * 3),9 * 9 * (3 * 3 * 3...
07:58:37 <lilac> > iterate reduce (1 + 5 * (6 - 9) * 3 / 7)
07:58:37 <Axman6> > iterate reduce (3^5)
07:58:38 <lambdabot>   [1 + 5 * (6 - 9) * 3 / 7,1 + 5 * (-3) * 3 / 7,1 + (-15) * 3 / 7,1 + (-45) /...
07:58:39 <lambdabot>   [3 * 3 * (3 * 3) * 3,9 * (3 * 3) * 3,9 * 9 * 3,81 * 3,243,243,243,243,243,2...
07:59:04 <rick_2047> lilac, what is it that u say Curry Howard isomorphism
07:59:08 <seliopou> > reverse $ iterate reduce (3^5)
07:59:14 <lambdabot>   mueval-core: Prelude.read: no parse
07:59:15 <lambdabot>  mueval: ExitFailure 1
07:59:24 <rick_2047> lilac, some kind of proof or math reasoning thing?
07:59:25 <seliopou> eek
07:59:40 <int-e> reduce is an approximation; in reality, the two (3*3) subexpressions are shared.
07:59:40 <seliopou> oh right, silly me
07:59:46 <Axman6> seliopou: reverse in infinite lists is rather fun...
07:59:46 <Berengal> rick_2047: It's how computer programs are all mathematical proofs
08:00:02 <rick_2047> Berengal, oh i didnt knew that
08:00:04 <Axman6> > x^5
08:00:08 <lambdabot>   x * x * (x * x) * x
08:00:08 <Berengal> http://en.wikipedia.org/wiki/Curry_Howard_isomorphism
08:00:12 <Axman6> > x^8
08:00:13 <seliopou> > reverse $ (take 10) $ iterate reduce (3^5)
08:00:13 <lambdabot>   x * x * (x * x) * (x * x * (x * x))
08:00:14 <lambdabot>   [243,243,243,243,243,243,81 * 3,9 * 9 * 3,9 * (3 * 3) * 3,3 * 3 * (3 * 3) *...
08:01:01 <int-e> > iterate reduce (let x = 3; y = x*x in y*y*x)
08:01:03 <lambdabot>   [3 * 3 * (3 * 3) * 3,9 * (3 * 3) * 3,9 * 9 * 3,81 * 3,243,243,243,243,243,2...
08:02:16 <rick_2047> where are most of the haskell projects hosted??
08:02:28 <Berengal> @where hackage
08:02:29 <lambdabot> http://hackage.haskell.org/
08:02:38 <rick_2047> Berengal, kewl name
08:02:39 <gwern> {code,darcs}.haskell.org for the repos, hackage for the release tarballs
08:02:41 <burp> how would you transform [[[1,2],[4,5]],[[7,8],[9,10]]] this into [[1,2],[4,5],[7,8],[9,10]]?
08:02:53 <Axman6> concat?
08:03:01 <Axman6> > concat [[[1,2],[4,5]],[[7,8],[9,10]]]
08:03:03 <lambdabot>   [[1,2],[4,5],[7,8],[9,10]]
08:03:04 <burp> uh lol
08:03:06 <burp> thanks =)
08:03:15 <gwern> @hoogle [[a]] -> [a]
08:03:15 <lambdabot> Prelude concat :: [[a]] -> [a]
08:03:15 <lambdabot> Data.List concat :: [[a]] -> [a]
08:03:15 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
08:03:20 <Axman6> > concat .  concat $ [[[1,2],[4,5]],[[7,8],[9,10]]]
08:03:21 <lambdabot>   [1,2,4,5,7,8,9,10]
08:04:31 <rick_2047> a net split
08:04:35 <rick_2047> run run
08:05:24 <rick_2047> and they are back
08:05:36 <burp> @src concat
08:05:37 <lambdabot> concat = foldr (++) []
08:14:04 <rick_2047> why does only a number has a defined succsessor
08:14:40 <ziman> > succ 'foo
08:14:41 <lambdabot>   <no location info>:
08:14:41 <lambdabot>      lexical error in string/character literal at chara...
08:14:42 <rick_2047> i mean a chars like 'c' can have a defined successor
08:14:42 <ziman> kua
08:14:45 <ziman> > succ 'f'
08:14:47 <lambdabot>   'g'
08:15:10 <rick_2047> so there is  diff b/w "a" and 'a'
08:15:16 <shachaf> @faq Can non-numbers have a defined successor?
08:15:17 <lambdabot> The answer is: Yes! Haskell can do that.
08:15:25 <shachaf> Yes, the same as in C.
08:15:44 <rick_2047> shachaf, oh thanks
08:16:05 <rick_2047> and i take it that the successor is the ansi equivalant of the succssor
08:16:35 <yaxu> is it possible to get a version of the haskell platform with a ghci that has readline?
08:17:47 <stepnem> > succ LT
08:17:48 <lambdabot>   EQ
08:17:56 <stepnem> :p
08:18:10 <rick_2047> stepnem, how did that happen
08:18:22 <stepnem> > succ EQ
08:18:23 <Berengal> @type LT
08:18:24 <lambdabot>   GT
08:18:25 <lambdabot> Ordering
08:18:49 <Berengal> > succ False
08:18:51 <lambdabot>   True
08:18:51 <rick_2047> stepnem, can u please explain what u just illustrated??
08:18:53 <stepnem> rick_2047: it's basically -1,0,1, afaik
08:18:54 <Peaker> > succ True
08:18:56 <lambdabot>   * Exception: Prelude.Enum.Bool.succ: bad argument
08:19:12 <Berengal> @type succ
08:19:14 <lambdabot> forall a. (Enum a) => a -> a
08:19:44 <rick_2047> stepnem, but what are these GT LT and EQ??
08:19:56 <stepnem> rick_2047: like aliases for constants -1,0,1
08:20:12 <rick_2047> why would there b an alias
08:20:12 <stepnem> resulting from comparison
08:20:15 <Peaker> IMO There should be:  class Enum a where pred, succ :: a -> Maybe a ; class (Enum a, Bounded a) => CyclicEnum a where cyclicPred, cyclicSucc :: a -> a
08:20:17 <nibro> @src Ordering
08:20:18 <lambdabot> data Ordering = LT | EQ | GT
08:20:18 <Berengal> rick_2047: LT, EQ and GT are Orderings
08:20:35 <nibro> @type compare
08:20:35 <Peaker> perhaps with default implementations using the Eq instance and maxBound/minBound
08:20:36 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
08:20:42 <rick_2047> Berengal, so basically i have to study more to figure it out
08:20:44 <rick_2047> thanks
08:20:46 <Peaker> @type \x -> if x == maxBound then minBound else succ x
08:20:48 <lambdabot> forall a. (Bounded a, Eq a, Enum a) => a -> a
08:20:48 <nibro> > compare 1 2
08:20:49 <lambdabot>   LT
08:20:54 <Peaker> @src Enum
08:20:54 <lambdabot> class  Enum a   where
08:20:54 <lambdabot>     succ                     :: a -> a
08:20:54 <lambdabot>     pred                     :: a -> a
08:20:54 <lambdabot>     toEnum                   :: Int -> a
08:20:54 <lambdabot>     fromEnum                 :: a -> Int
08:20:56 <nibro> > compare 2 2
08:20:56 <lambdabot> [3 @more lines]
08:20:56 <Berengal> rick_2047: They're just a type, like Bool
08:20:58 <lambdabot>   EQ
08:21:12 <Peaker> I thought Enum was a subclass of Eq
08:21:27 <Peaker> I guess that the CyclicEnum makes even more sense then, because it doesn't require an Eq instance
08:21:49 <Berengal> Peaker: newtype Incrementer = Incrementer (Int -> Int) ?
08:22:10 <Berengal> Peaker: You could imagine an Enum instance for that, couldn't you?
08:24:15 <quicksilver> Berengal: sure, but I can imagine an Eq instance on it too
08:24:25 <quicksilver> Berengal: (if we assume they do indeed work as advertised)
08:24:45 <quicksilver> Berengal: Incrementer f == Incrementer g = (f 0) == (g 0)
08:26:05 <stepnem> > map fromEnum [LT,EQ,GT]
08:26:07 <lambdabot>   [0,1,2]
08:26:10 <Berengal> quicksilver: Nobody advertised anything. They're... encryption algorithms, yeah <_< >_>
08:27:53 <stepnem> > map fromEnum [True,False]
08:27:54 <lambdabot>   [1,0]
08:28:14 <mauke> lambda calculus agrees: 0 is false!
08:28:26 <stepnem> :D
08:30:53 <yaxu> haskeline is driving me crazy :/ I'm too used to kill ring and transliteration
08:31:47 <mauke> yeah, I'm still on 6.10.2 (with readline)
08:44:07 <rick_2047> is a list anything different from and array in other languages??
08:45:33 <bremner_> Yes
08:45:50 <rick_2047> bremner_, how??
08:45:55 <mauke> it's a list
08:45:55 <RayNbow> rick_2047: a list in Haskell is more like a linked list
08:46:13 <gwern> rick_2047: resizable, for example; and it has different complexities for its operations
08:46:14 <bremner_> Random access is expensive
08:46:23 <rick_2047> RayNbow, just like a dynamic array we have in python or ruby
08:46:33 <mauke> no
08:46:45 <mauke> array indexing is not O(n)
08:47:15 <rick_2047> i am talking of proper definitions
08:47:33 <rick_2047> i mean an array is a collection of like typed data
08:47:49 <rick_2047> and arrays in new languages are dynamically sized
08:48:04 <rick_2047> so lists is more like arrays to my mind
08:48:06 <mauke> so is a list, a set, and a bag
08:48:22 <mauke> and dictionaries, depending on the language
08:48:28 <rick_2047> mauke, i dont get ur point
08:48:46 <quicksilver> a haskell list is not exactly like anything in python or ruby
08:48:47 <rick_2047> mauke, dictionaries as in hashtables??
08:48:52 <bremner_> rick_2047: Well, we care about performance
08:48:58 <quicksilver> it's a linked list - but its immutable
08:48:58 <mauke> dictionaries as in associative arrays
08:49:09 <quicksilver> so you can't insert things in teh middle
08:49:09 <rick_2047> mauke, o
08:49:13 <quicksilver> on the other hand, you can share tails.
08:49:22 <rick_2047> bremner_, so is it good or bad than other languages??
08:49:37 <bremner_> Mu
08:49:43 <mauke> linked lists in haskell are pretty much like linked lists on other languages
08:49:48 <mauke> er, in
08:50:12 <wli> Singly-linked.
08:50:14 <stepnem> rick_2047: it's not about Haskell vs other languages, it's about the data structure itself -- you can have linked lists in C or whatever
08:50:53 <rick_2047> stepnem, i am not compairing things i was just confused if there was something special
08:50:58 <stepnem> rick_2047: see for example http://en.wikipedia.org/wiki/Linked_list
08:50:59 <rick_2047> and it turns out there is
08:51:16 <rick_2047> array is an array and a linked list is a linked list
08:51:23 <mauke> surprise: not every data structure is an array
08:51:25 <rick_2047> so there is a diff
08:52:56 <rick_2047> so does haskell has array??
08:53:04 <mauke> yes
08:53:08 <rick_2047> its typed so i think it must have arrays
08:53:13 <mauke> what
08:53:51 <RayNbow> types are not really relevant
08:57:29 <lilac> @remember RayNbow types are not really relevant
08:57:30 <lambdabot> It is forever etched in my memory.
08:57:48 <stepnem> hehe
08:58:04 <RayNbow> lilac: oh great :p
08:58:24 <RayNbow> now I need to get a new identity :p
09:04:17 <lilac> RayNbow: from now on, wherever you go you need to say "i was quoted out of context! really! here are the logs!"
09:06:10 <quicksilver> However, I was there. I can tell you that RayNbow's logs are forged.
09:06:22 <quicksilver> in reality, he is a wrongthinking untyper
09:06:27 <quicksilver> doubleplusungood
09:06:47 <monochrom> Haha "untyper"
09:07:41 <quicksilver> no doubt the Ministry of Types will take care of it.
09:07:57 <SamB_XP_> or the Ministry of Ducks
09:08:07 <monochrom> Text.ParserCombinators.Newspeak
09:08:10 <mauke> no quack!
09:08:14 <Ferdirand> hehe
09:08:43 <monochrom> "un :: Adjective -> Adjective"
09:11:26 <doserj> good::Adjective, plus::Adjective -> Adjective, double::(Adjective->Adjective)->Adjective->Adjective, double p = p.p ?
09:12:35 <aavogt> @type join (.)
09:12:36 <lambdabot> forall b. (b -> b) -> b -> b
09:13:07 <RayNbow> quicksilver: I'll just use the logs from tunes.org ;)
09:13:08 <monochrom> No, it is really double (plus (un good))
09:13:37 <monochrom> Err perhaps it's OK the other way too.
09:13:41 <LeCamarade> Comrades, what could inspire a deadlock in a compiled binary, one that doesn't show up while running under runhaskell?
09:13:47 <LeCamarade> With GHC?
09:13:59 <lilac> bad luck?
09:14:09 <LeCamarade> conal was going to give me some help, last time, but we both ran out of time.
09:14:13 <LeCamarade> lilac, :o)
09:14:21 <MiniCow> quicksilver: Surely haskell lists are rather like python lists.
09:14:24 <LeCamarade> Correct. Here's a cookie!
09:14:52 <quicksilver> MiniCow: no idea.
09:15:08 <LeCamarade> MiniCow, They aren't.
09:15:26 <LeCamarade> Except in the sense that arrays can encode all list operations.
09:15:48 <monochrom> Perhaps runhaskell interleaves all threads on one CPU, compiled code uses more CPUs.
09:15:51 <MiniCow> LeCamarade: wasn't talking about arrays though
09:16:01 <LeCamarade> Ah, lists.
09:16:10 <LeCamarade> Cool. :o)
09:16:22 <LeCamarade> monochrom, Enlighten me further.
09:16:26 <MiniCow> They did steal list comprehensions after all
09:16:43 <LeCamarade> So my problem is that my code tacitly assumes a single CPU?
09:17:28 <monochrom> runhaskell is slower than compiled code.
09:17:59 <MiniCow> Real question, has anybody ever used GHC to create C code that they've compiled on another target?
09:18:58 <frwmanners> LeCamarade: is there a (minimal) example anywhere?
09:19:46 <LeCamarade> frwmanners, Not really, as I don't know even where the deadlock happens.
09:20:03 <monochrom> I should start a business of debugging haskell.
09:20:11 <LeCamarade> It's a sizeable program.
09:20:35 <LeCamarade> I now run it in runhaskell, so that it doesn't have to die. (It's a production system.)
09:22:46 <quicksilver> runhaskell is interpreted, but uses the threaded RTS
09:22:58 <quicksilver> did you use -threaded to compile it, when you compiled it?
09:24:08 <LeCamarade> quicksilver, Isn't that the default?
09:24:25 * LeCamarade goes to take system down for debugging seance.
09:29:42 <Saizan_> no, -threaded is not the default
09:30:33 <quicksilver> LeCamarade: no, it is not.
09:32:03 <LeCamarade> So, if I use -threaded, am I supposed to see a difference in behaviour between runhaskell and native that should affect this here Heisenbug?
09:35:14 <quicksilver> LeCamarade: threads are non-deterministic.
09:35:38 <quicksilver> LeCamarade: if you have not, a priori, proved beyond reasonable doubt that every single possible interleaving yields the same observational behaviour
09:36:06 <quicksilver> LeCamarade: then you can reasonable expect anything from changing RTS parameters to your cat walking over the wifi antenna to change the behaviour of your program.
09:36:24 <quicksilver> obviously, the key to good thread programming is to write programs which have good properties in all possible interleavings.
09:36:29 <LeCamarade> Well, I thought I had some rather evidential proof in the behaviour of the program under runhaskell.
09:36:41 <quicksilver> that just proves the behaviour of *one* interleaving
09:36:43 <LeCamarade> I use MVar and Chan rather carefully.
09:36:47 <LeCamarade> Hmm.
09:36:51 <quicksilver> your evidence in the other form shows the behaviour of another interleaving.
09:36:58 <LeCamarade> I'll have to unpack the entire deck, then.
09:37:12 <quicksilver> the difference between the two does not necessarily mean a bug in GHC or the RTS.
09:37:21 <quicksilver> non-determinism is what threads are all about
09:37:38 <LeCamarade> No, it doesn't, since different behaviour under threading is no bug.
09:38:22 <LeCamarade> I think quantum behaviour is caused by God's (other) programs affecting our own multithreading universe.
09:38:42 <LeCamarade> nodnedterm-ismn
09:38:54 <LeCamarade> :o)
09:41:21 <burp> I wish mathematica had haskell as it's language
09:41:40 <burp> right now it's just horrible
09:43:15 <lilac> burp: fortunately, haskell has haskell as its language, so all is not lost :)
09:43:51 <roconnor> > deriv (\x -> sin (cos x)) x
09:43:52 <lambdabot>   1 * negate (sin x) * cos (cos x)
09:44:06 <burp> it's missing some good mathematics libraries
09:44:28 <lilac> burp: i'm always surprised by how much is on hackage :)
09:44:35 <roconnor> > atan (3**pi) :: CReal
09:44:37 <lambdabot>   1.5391054723734566017302838717307598287741
09:45:59 <lilac> > 20 + pi - exp 1 ** pi :: CReal
09:46:01 <lambdabot>   0.0009000208105242327335570153309555039311
09:46:17 <burp> should that demonstrate it's math capabilities? ;)
09:47:11 <burp> hmatrix is a good gsl binding
09:47:15 <burp> but sadly it's not complete
09:47:41 <ziman> > 20 + pi - exp 1 ** pi :: Float
09:47:42 <lambdabot>   8.983612e-4
09:47:52 <ziman> > 20 + pi - exp 1 ** pi :: Double
09:47:53 <lambdabot>   9.000208105298668e-4
09:48:59 <lilac> @@ @oeis @run take 18 . intercalate " " . drop 2 $ (:[]) <$> show (20 + pi - exp 1 ** pi :: CReal)
09:49:01 <lambdabot>  Number of pairs (x,y) of divisors of n with x<y such that also x+y is a divi...
09:49:01 <lambdabot>  [0,0,0,0,0,1,0,0,0,0,0,3,0,0,0,0,0,2,0,1,0,0,0,5,0,0,0,0,0,4,0,0,0,0,0,6,0,0...
09:49:13 <roconnor> > (cos (10^100), cos (10^100)::CReal)
09:49:15 <lambdabot>   (-0.9994551172253643,-0.9280819050746553434561946437769559281832)
09:49:24 <roconnor> > (sin (10^100), sin (10^100)::CReal)
09:49:25 <lambdabot>   (3.30071000245921e-2,-0.3723761236612766882620866955531642957197)
09:58:14 <JamesSanders> my lambdabot keeps saying Terminated
09:58:23 <JamesSanders> any idea why?
09:58:27 <JamesSanders> > 1+1
09:58:28 <lambdabot>   2
09:58:38 <JamesSanders> yeah mine just says Terminated
09:58:46 <lilac> @@ @oeis @run intercalate " " $ show <$> take 8 (randoms (mkStdGen 42) <^mod^> [1..])
09:58:48 <lambdabot>  Number of distinct differences between consecutive divisors (ordered by incr...
09:58:48 <lambdabot>  [0,0,1,0,1,0,1,0,2,1,1,0,1,1,2,0,1,0,1,0,3,1,1,0,2,1,3,1,1,1,1,0,3,1,3,0,1,1...
09:58:49 <atsampson> Skynet has finally taken over?
09:59:16 <Saizan_> JamesSanders: have you installed mueval?
09:59:18 <lilac> JamesSanders: i get that on mine too. i think it's timing out
09:59:26 <lilac> *sometimes* it works
09:59:42 <JamesSanders> Saizan_: no I will try that
10:01:28 <JamesSanders> Saizan_: I installed it with cabal and restarted my lambdabot but it still doesn't work
10:06:34 <sdfds> Quick question: I'm installing GHC from source....does anyone have a rough estimate on how long that will take?
10:06:47 <mauke> a few hours
10:07:02 <mholub> Hi, does haskell libs have analog of String#gsub from ruby? This function takes string (self), regexp, and block (anonymous function), and replaces all matches in string with value function applied to match returns?
10:07:16 <sdfds> Hmm...Leksah isn't worth that. (: I'll use emacs...
10:10:00 <psygnisfive> is it accurate to say that haskell has functional overloading?
10:10:23 <Saizan_> i've never read that term before
10:10:49 <psygnisfive> at least in so far as the monad domain requires that functions like be defined variously for different monads?
10:11:08 <psygnisfive> functions line bind*
10:11:21 <psygnisfive> apparently irc doesnt like the tubes thing.
10:11:32 <psygnisfive> like**
10:11:37 <psygnisfive> god, i cant type D:
10:11:51 <Saizan_> well, haskell does have overloading via typeclasses
10:12:06 <Saizan_> it's the "functional" part that i'm not sure what should mean
10:12:09 <Zao> type classes are kind of like pure virtual interfaces
10:12:18 <psygnisfive> oh sorry, i meant to say function overloading.
10:12:21 <Zao> *pure in the OO sense)
10:12:29 <psygnisfive> i cant type today, Saizan_, cant you tell? :P
10:12:41 <Zao> As for overloading regular functions, no. A function has a single signature.
10:12:50 <psygnisfive> right, ok.
10:13:28 <Zao> It could of course use type classes to restrict what kind of types it accepts.
10:13:45 <psygnisfive> im just curious because im going to be experimenting with a proglang design and i want it to be functional(ish) on the one hand, but OO on the other, and im trying to see if its possible to achieve method calls in the manner of function overloading
10:13:51 <Zao> f :: (Num a) => a -> a -> b
10:13:58 <JamesSanders> my lambdabot still says nothing but Terminated when I use >
10:14:08 <Zao> f takes any type a, as long as it's in Num.
10:14:26 <psygnisfive> e.g. instead of defining a method on a class, you just define a postfix function that's MyClass -> whatever
10:14:29 <Saizan_> JamesSanders: what happens when you use mueval by itself?
10:14:53 <Zao> psygnisfive: You could probably fake virtual functions by doing your own vtable and such.
10:15:02 <JamesSanders> Saizan_: nothin
10:15:04 <psygnisfive> oh if only i knew what a vtable was!
10:15:21 <psygnisfive> :p
10:15:35 <allbery_b> essentially a dictionary mapping from a class to the real function
10:15:37 <EvilTerran> google knows!
10:15:42 <Saizan_> JamesSanders: no output?
10:15:50 <JamesSanders> correct
10:15:58 <psygnisfive> allbery_b: oh, like, a lookup table?
10:16:03 <allbery_b> kinda like typeclasses are implemented with a dictionary from type instances to implementations
10:16:05 <Saizan_> JamesSanders: try mueval -e '()'
10:16:29 <psygnisfive> i see. well, i suppose i could do that, sure
10:16:32 <JamesSanders> still no output
10:16:50 <JamesSanders> must be something wrong with my install of mueval
10:16:55 <EvilTerran> JamesSanders, what about the exit code?
10:17:25 <JamesSanders> EvilTerran: 0
10:17:34 <EvilTerran> huh
10:18:36 <allbery_b> there have been previous OO Haskell variants; see http://haskell.org/haskellwiki/O%27Haskell
10:18:58 <psygnisfive> allbery_b: yeah but OO haskell has been done, so wheres the fun of designing a language?! :p
10:19:35 <defun> i don't have a ghci on this laptop, but I am drafting a program on it. I need to know if function names like this are allowed: func+name or func++name? Or does ghc read this as function func plus function name?
10:20:09 <allbery_b> defun: can't mix alphanumeric and operator characters. one exception: you can use ' in names
10:20:10 <EvilTerran> defun, names have to either be all alphanumeric starting with a letter, or all symbols
10:20:17 <EvilTerran> this isn't scala
10:20:26 <defun> i see. thanks.
10:20:27 <leimy_> nope
10:20:28 <leimy_> :-)
10:20:34 <Badger> heh
10:21:12 * EvilTerran read about the treatment of methods called foo_= in the scala spec and it made him want to scream and run away
10:22:40 <defun> assuming I define a function 'f', and I want to say that functions 'x' and 'y' are synonyms for 'f', can I say: x, y = f or do I have to do x=f y=f?
10:22:58 <EvilTerran> defun, the latter
10:23:03 <mauke> (x, y) = (f, f)
10:23:08 <defun> thanks
10:23:10 <nominolo> defun: x = f; y = f
10:23:26 <mauke> x : y : _ = repeat f
10:23:29 <nominolo> mauke: that could lead to problems with polymorphism
10:23:43 <nominolo> nested variables are monomporphic by default
10:23:51 <EvilTerran> > let [x,y] = repeat () in (x,y)
10:23:52 <lambdabot>   (* Exception: <interactive>:1:137-153: Irrefutable pattern failed for patte...
10:24:26 <nominolo> > :t let (x, y) = id in x
10:24:28 <lambdabot>   <no location info>: parse error on input `:'
10:24:35 <nominolo> > :t let (x, y) = (id, id) in x
10:24:36 <lambdabot>   <no location info>: parse error on input `:'
10:24:45 <nominolo> :t let (x, y) = (id, id) in x
10:24:46 <lambdabot> forall a. a -> a
10:25:00 <nominolo> :t let (x, y) = (id, id) in (x 3, x 'a')
10:25:02 <lambdabot>     No instance for (Num Char)
10:25:02 <lambdabot>       arising from the literal `3' at <interactive>:1:28
10:25:02 <lambdabot>     Possible fix: add an instance declaration for (Num Char)
10:25:22 <nominolo> :t let x = id in (x 3, x 'a')
10:25:23 <lambdabot> forall t. (Num t) => (t, Char)
10:25:29 <nominolo> mauke: ^^
10:25:43 <nominolo> :t let (x :: forall a.a, y) = (id, id) in (x 3, x 'a')
10:25:45 <lambdabot>     Couldn't match expected type `forall a. a'
10:25:45 <lambdabot>            against inferred type `a -> a'
10:25:45 <lambdabot>     In the expression: id
10:25:51 <nominolo> :t let (x :: forall a.a->a, y) = (id, id) in (x 3, x 'a')
10:25:52 <lambdabot>     Couldn't match expected type `forall a. a -> a'
10:25:53 <lambdabot>            against inferred type `a -> a'
10:25:53 <lambdabot>     In the expression: id
10:26:15 <nominolo> hmm..
10:26:57 <nominolo> :t let (x :: forall a.a->a, y) = (id :: forall a. a -> a, id) in (x 3, x 'a')
10:26:57 <lilac> > let (a, b) = join (,) c in [a, b]
10:26:58 <lambdabot>     Couldn't match expected type `forall a. a -> a'
10:26:58 <lambdabot>            against inferred type `a -> a'
10:26:58 <lambdabot>     In the expression: id :: forall a. a -> a
10:26:59 <lambdabot>   [c,c]
10:28:41 <Peaker> what's the difference between forall a. a -> a   and a -> a ?
10:28:43 <walter__> Is possible to compile a haskell executable file for windows under linux enviroment?
10:29:51 <hackagebot> hack-frontend-happstack 2009.6.2
10:30:20 <lilac> Peaker: depends on which GHC extensions you have enabled.
10:30:59 <lilac> Peaker: if you have type operators and forall isn't a keyword then in "forall a . a -> a" , forall is a type variable of kind * -> *
10:32:20 <Saizan_> Peaker: the difference is between forall a. T (a -> a) and T (forall a. a -> a)
10:32:55 <Peaker> lilac: heh
10:33:19 <lilac> > let f :: (forall a. a -> a) -> Int; f = 0 in f id
10:33:21 <lambdabot>   Cannot match a monotype with `(forall a. a -> a) -> GHC.Types.Int'
10:33:22 <Peaker> Saizan_: is there an explicit qualifier you could use on  a -> a   to mean the former?
10:33:31 <lilac> Peaker: it depends on context, basically
10:33:43 <lilac> Peaker: in a contravariant position they mean different things
10:33:49 <lilac> Peaker: and if the context also uses a
10:34:07 <Saizan_> Peaker: 'a' is a free variable there
10:34:30 <lilac> > let f :: (a -> a) -> Int; f g = 0 in f (+1)
10:34:31 <lambdabot>   0
10:34:34 <lilac> > let f :: (forall a. a -> a) -> Int; f g = 0 in f (+1)
10:34:35 <lambdabot>   Could not deduce (GHC.Num.Num a) from the context ()
10:34:36 <lambdabot>    arising from the li...
10:41:19 <leimy_> @users
10:41:19 <lambdabot> Maximum users seen in #haskell: 658, currently: 617 (93.8%), active: 21 (3.4%)
10:57:33 <tharis20> what means $ symbol in haskell?
10:57:52 <mauke> @src ($)
10:57:52 <lambdabot> f $ x = f x
10:57:55 <Lemmih> Application.
10:58:20 <wy_> helo
10:58:46 <centrinia> The ($) function is just a specialization of the id function. ;)
10:58:50 <wy_> how can I find somebody pinged me?
10:58:58 <tharis20> sorry, I missed the answers
10:59:12 <wy_> I guess a long time ago in this channel. huh
10:59:18 <centrinia> > map (+1) `id` [1,2,42]
10:59:19 <lambdabot>   [2,3,43]
10:59:20 <QP> it's used often as a way of writing some expressions without using brackets all over the place
10:59:37 <nibro> tharis20: $ is right-associative application
10:59:59 <nibro> tharis20: you can write 'f $ g x' instead of 'f (g x)'
11:00:42 <tharis20> nibro, ok, thank you ;)
11:00:42 <Cale> The important thing being not that it's right-associative, but that it has very low precedence.
11:00:51 <centrinia> > (* 2) `id` (+3) 4
11:00:52 <lambdabot>   14
11:01:06 <centrinia> Doesn't `id` have the same precedence?
11:01:14 <nich> > map (+1) $ [1,3..9]
11:01:15 <lambdabot>   [2,4,6,8,10]
11:01:17 <nich> :D
11:01:31 <nibro> Cale: the important part being that it isn't left-associative as it should be, eh? ;-)
11:01:55 <centrinia> > map (+1) `id` [1,3..9]
11:01:56 <lambdabot>   [2,4,6,8,10]
11:02:12 <Cale> Well, yeah, it *ought* to be left associative, and since we can always avoid using it in a right-associative way for now, I think we should, so that changing it becomes easier.
11:02:45 <QP> my code was brackets soup until i started using it...
11:03:39 <centrinia> Why didn't they just define ($) = id ?
11:03:43 <centrinia> > ($) 1
11:03:45 <lambdabot>   No instance for (GHC.Num.Num (a -> b))
11:03:45 <lambdabot>    arising from the literal `1' at <...
11:04:19 <seliopou> centrinia, application would still be left-associative
11:05:00 <centrinia> Use infixr on ($)
11:05:44 <QP> what does 'f' even mean if f is a one argument function? x 'f' = f x?
11:06:03 <lament> character.
11:06:13 <QP> ``
11:06:19 <QP> sorry
11:06:38 <QP> x `f` = f x ?
11:07:33 <opqdonut> yeah
11:07:36 <nibro> QP: yes
11:07:42 <QP> makes sense
11:07:57 <lament> > let f x = x + 42 in 5 `f`
11:07:59 <QP> cool, never seen that before
11:07:59 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
11:08:18 <nibro> > let f x = x + 42 in (5 `f`)
11:08:19 <lambdabot>   47
11:08:20 <opqdonut> > let f x = x + 42 in (5 `f`)
11:08:21 <opqdonut> yeh
11:08:21 <lambdabot>   47
11:08:31 <opqdonut> requires the parentheses unfortunately
11:08:45 <QP> woo, the #haskell echo!
11:09:02 <lament> hehe
11:20:50 <skorpan> who should i put in the "author" field in my bibtex file when referring to the xmonad homepage?
11:23:07 <voker57> xmonad author?
11:23:41 <portero> A question. Is it sensible to use the State monad when doing event processing? I have "event sinks" that can absort events. I want to transform a tree data structure representing the state of the user interface given a user input event. Any ideas?
11:25:41 <skorpan> voker57: who is/are that=
11:25:43 <skorpan> ?
11:31:36 <gwern> dons: I'd note that I don't think 2 years would make all that much difference for sml/nj. maybe for haskell, since we actively target the shootout, but not sml/nj
11:32:31 <dons> well, more that our compiler has gotten significantly better at multicore in the last 2 years.
11:32:40 <dons> and we got some new optimizations
11:34:29 <skorpan> dons: are you and sjanssen suitable authors to put in my bibtex file if referring to the xmonad homepage?
11:36:52 <saynte> has anyone here used the llvm bindings from hackage?
11:45:09 <sjanssen> skorpan: are you referring to the text on the homepage or to xmonad itself?
11:45:52 <skorpan> sjanssen: i guess the homepage, since i have to refer to *something* and i haven't been able to find anything suitable for a master thesis bibliography entry
11:46:00 <skorpan> but please, if you have a better idea, i'm all for it
11:46:22 <a_guest> If I define a typeclass in a module, must this be exported to be able to use? If I define instance of a typeclass in a module, must this be exported to be able to use? How is this done?
11:46:22 <sjanssen> skorpan: oh, do you know about the demo summary from the Haskell Workshop?
11:46:29 <sjanssen> published by ACM and everything
11:46:44 <skorpan> sjanssen: i have seen a video demo presented by don, from some conference
11:47:20 <skorpan> a_guest: iirc, "module MyModule (Class(instances here)) where"
11:47:52 <sjanssen> a_guest: instances are implicitly exported
11:48:21 <sjanssen> hmm, ACM changed their website and search sucks now
11:48:49 <a_guest> skorpan and sjanssen answers seems inconsistent.
11:48:59 <skorpan> don't listen to me, i know nothing
11:49:00 <sjanssen> skorpan: http://portal.acm.org/citation.cfm?id=1291201.1291218&coll=ACM&dl=ACM&CFID=37427164&CFTOKEN=66422795
11:49:27 <skorpan> sjanssen: ah, thanks a lot!  very appreciated.
11:51:06 <skorpan> sjanssen: the bibtex entry says your name is "spencer sjanssen", but looking at your whois information, this is incorrect, right?
11:51:38 <a_guest> I still wonder how I in a module exports typeclasses and -instances-
11:51:47 <sjanssen> skorpan: huh, how did that happen.  You're right
11:52:19 <sjanssen> a_guest: instances are always implicitly exported
11:52:28 <skorpan> (i guess i could have just read the damn pdf too)
11:52:36 <sjanssen> a_guest: classes are exported with "ClassName(..)" to export all methods
11:52:48 <mauke> Dons Stewart and Spencer Sjanssen!
11:53:10 <skorpan> hehe
11:53:24 <skorpan> i also noticed that a paper on yi has used this incorrect bibtex entry :)
11:53:30 <skorpan> "S. Sjanssen"
11:53:39 <a_guest> sjanssen: thank you. That maked it clear for me.
11:53:59 <sjanssen> I wonder how we can make corrections?
11:54:09 <mauke> I guess the easiest fix would be for spencer to change his real name
11:57:45 <JamesSanders> I'm trying to run lambdabot and get  Module `Control.Arrow' does not export `pure'L.hs:3:29: Module  `Control.Arrow' does not export `pure
11:57:56 <JamesSanders> when I run haskell code
11:58:02 <sjanssen> JamesSanders: you probably need to upgrade GHC
11:58:07 <JamesSanders> ah
11:58:27 <sjanssen> or kick whomever added non-backwards compatible imports
11:58:42 <JamesSanders> heh
11:58:53 <mauke> or remove that line from L.hs
11:59:16 <mauke> which IIRC is hidden somewhere in your ~
12:00:01 <JamesSanders> yikes after upgrading it says all my cabal packages need to be reinstalled!
12:01:17 <sjanssen> JamesSanders: yep
12:05:16 <defun> :t >=1
12:05:17 <lambdabot> parse error on input `>='
12:05:24 <defun> :t >=
12:05:26 <lambdabot> parse error on input `>='
12:05:34 <defun> :t ==
12:05:36 <lambdabot> parse error on input `=='
12:05:39 <defun> ?
12:06:08 <sjanssen> @type (==) -- operators must be wrapped in parens if not applied to both their arguments
12:06:10 <lambdabot> forall a. (Eq a) => a -> a -> Bool
12:06:44 <defun> ah.
12:06:45 <defun> thanks.
12:07:24 <sjanssen> @type (>= 1) -- syntax for applying the second argument only
12:07:26 <lambdabot> forall a. (Num a, Ord a) => a -> Bool
12:07:31 <mauke> :t ?x >= ?y
12:07:32 <lambdabot> forall a. (?x::a, ?y::a, Ord a) => Bool
12:14:00 <CSWookie_> How good is haskell's networking libraries?  Particularly in the area of chat protocols?  (/me spuspects he may have asked this before)
12:14:28 <CSWookie_>  /good is/good are/
12:14:36 <JamesSanders> is there an easy way to reinstall all my Cabal packages
12:14:37 <JamesSanders> ?
12:33:03 <Heffalump> dcoutts: ping?
12:37:02 <vininim> :t split
12:37:03 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
12:40:46 <vininim> :t (permutations $ take 10 $ enumFromThen 1 2 , permutations $ take 10 $ enumFromThen 1.0 3.0 )
12:40:47 <lambdabot> forall a a1. (Num a, Enum a, Fractional a1, Enum a1) => ([[a]], [[a1]])
12:42:12 <vininim> does lambdabot runs with -XRankNTypes?
12:43:18 <mauke> > undefined :: [forall a. a]
12:43:19 <lambdabot>   No instance for (GHC.Show.Show (forall a. a))
12:43:19 <lambdabot>    arising from a use of `M56...
12:44:38 <dcoutts> Heffalump: pong
12:45:25 <Heffalump> are you aware of any preconditions in the window size for zlib compression/decompression?
12:45:41 <Heffalump> it seems like zlib insists on decompress window size being strictly greater than the compress window size
12:46:01 <Heffalump> which sort of makes sense except I don't understand why it needs to be strictly greater than and that doesn't agree with what the zlib source says
12:46:22 <Heffalump> (I've been writing qc properties)
12:46:30 <kowey> is the planet Haskell admin here by any chance?
12:46:48 <Heffalump> I think the admin is only accessible by email, though I could be wrong
12:46:59 <mux> dcoutts: just got a reply from ross; he doesn't provide the source code but suggests setting build-type to custom, he says otherwise some build tools will ignore the Setup.hs file
12:48:26 <vininim> is this the famous monomorphism restriction? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5475#a5475
12:48:29 <kowey> oh ok, thanks... I was just hoping to remind somebody about getting the darcs SoC blog (mornfall) on
12:48:32 <kowey> squeaky wheel
12:48:45 <vininim> althought I thought the compiler would be explicit about it
12:48:47 <dcoutts> mux: yes, that's essential
12:49:13 <dcoutts> Heffalump: I didn't know of that requirement. I've not actually used non-default window sizes
12:49:36 <Heffalump> I was just testing with randomised parameters to see what happened.
12:49:48 <dcoutts> Heffalump: nice
12:50:35 <Heffalump> are you ok with quickcheck-related instances (Arbitrary/Show) going with the types? They'll be orphaned otherwise.
12:51:31 <hackagebot> bsd-sysctl 1.0.4
12:58:23 <osfameron> what's the best way to traverse a hand-rolled tree datatype?  Should I be making it an instance of Data.Traversable ?
12:58:33 <mux> dcoutts: too bad ross didn't send the source code regardless
12:58:38 <roconnor> osfameron: yes!
12:58:43 <skorpan> osfameron: i'd say that sounds very reasonable :)
12:59:05 <osfameron> ok ;-)
12:59:10 * osfameron reads docs
13:02:41 <osfameron> hmmm, I don't understand the example for Data.Traversable with its <$> and <*>... I think I need to read some other docs first
13:04:27 <roconnor> <$> is infix map
13:04:31 <roconnor> <*> is infix ap
13:04:57 <roconnor> thus f <$> a <*> b  is liftM2 f a b
13:05:07 <tromp> > ()
13:05:09 <lambdabot>   ()
13:05:20 <roconnor> :type ()
13:05:24 <roconnor> @type ()
13:05:26 <lambdabot> ()
13:05:26 <tromp> > fix error
13:05:28 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
13:06:15 <tromp> @type error
13:06:16 <lambdabot> forall a. [Char] -> a
13:06:19 <osfameron> is there a tutorial/article on writine instances of Traversable?
13:06:37 <osfameron> aha, there is something on haskellwiki
13:06:44 <tromp> @type fix
13:06:45 <lambdabot> forall a. (a -> a) -> a
13:07:54 <roconnor> osfameron: http://www.cs.nott.ac.uk/~ctm/IdiomLite.pdf
13:08:04 <osfameron> ta
13:08:25 <roconnor> http://www.cs.nott.ac.uk/~ctm/Holes.pdf comes up in google, but I have never read it.
13:08:27 <roconnor> reading it onw
13:08:28 <roconnor> now
13:09:20 <osfameron> though I suspect that a) I may only need Foldable for now, and b) I am too tired and stupid to understand that paper now ;-)
13:09:48 <twadleigh> Is there a name for the general version of the "ShowS" trick?
13:10:09 <roconnor> twadleigh: generalized beyond strings you mean?
13:10:14 <twadleigh> That is, for using ([a]->[a]) as a data structure with O(1) append?
13:10:38 <roconnor> twadleigh: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/dlist
13:10:44 <vininim>  A pattern type signature cannot bind scoped type variables `a'
13:10:45 <vininim>       unless the pattern has a rigid type context
13:10:53 <twadleigh> roconnor: Thanks!
13:10:55 <vininim> lol
13:11:06 <vininim> maybe I should just stop trying to reuse
13:11:23 <roconnor> vininim: try disabling the monomorphism restriction
13:11:56 <osfameron> ooo!  I think I undersand the docs for Data.Foldable!
13:15:40 <vininim> roconnor: slightly different error
13:15:59 <vininim> (from the paste that is, not scopedtype try)
13:17:15 <roconnor> vininim: what paste?
13:17:27 <roconnor> oh
13:17:30 <roconnor> you didn't paste the code
13:18:11 <vininim> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5475#a5475a
13:18:59 <roconnor> vininim: that doesn't seem like a scary type error
13:19:34 <roconnor> oh I see
13:19:36 <roconnor> you want
13:19:53 <roconnor> (forall a . [a] -> [[a]]) ->  ([Residue] -> Matrix Double) -> ([DSSP] -> Matrix Double) -> [Chain] -> [(Matrix Double, Matrix Double)]
13:20:05 <roconnor> that requires rank2 polymorphism
13:20:27 <CSWookie_> roconnor: And a power level over 9000
13:20:32 <roconnor> yes
13:21:10 * roconnor tries to think if there is a H98 way of doing the same thing
13:22:55 <vininim> oh, thanks, didn't know the existential should only apply to the function
13:23:20 <roconnor> vininim: do you need some class constraints in that function signature as well?
13:23:33 <roconnor> vininim: what sorts of functions do you expect to be able to pass
13:23:53 <roconnor> I can't think of very many usefull functions of type (forall a. [a] -> [[a]])
13:24:14 <roconnor> there are couple.
13:24:21 <mgsloan> tails?
13:24:28 <roconnor> ah
13:24:29 <roconnor> yes
13:24:32 <roconnor> maybe there are several
13:24:39 <roconnor> @hoogle [a] -> [[a]]
13:24:39 <lambdabot> Data.List inits :: [a] -> [[a]]
13:24:39 <lambdabot> Data.List tails :: [a] -> [[a]]
13:24:39 <lambdabot> Data.List groupBy :: (a -> a -> Bool) -> [a] -> [[a]]
13:25:25 <roconnor> vininim: if you only want to pass in inits or tails and such, then you are fine
13:25:52 <vininim> roconnor: I will mostly use  window k ls = if (length w) == k then (w : window k cont) else [] where {w = take k ls;cont = tail ls}
13:26:07 <roconnor> vininim: what is the type of that?
13:26:38 <vininim> window :: Int -> [a] -> [[a]]
13:27:18 <Absolute0> can't backwards function composition achieve the same thing that monads do?
13:27:22 <roconnor> vininim: looks good
13:27:26 <roconnor> hm
13:27:29 <byorgey> heh, I see 'cont' and I immediately start thinking about continuations =)
13:27:33 <roconnor> I guess there are more functions that I thought.
13:29:11 <byorgey> Absolute0: no.
13:29:12 <roconnor> vininim: there is a Haskell 98 way of doing this, but it isn't nearly as nice as using rank2 polymorphism
13:29:30 <byorgey> assuming by 'backwards function composition' you mean like  f >>> g = g . f ?
13:29:58 <Absolute0> byorgey: (return f) >>= father >>= father >>= mother is the same as (father.father.mother) f
13:30:03 <roconnor> vininim: well, assuming that res and dssp have the same length.
13:30:32 <byorgey> Absolute0: no it isn't.
13:30:46 <Absolute0> byorgey: what's the difference?
13:30:48 <byorgey> return f >>= father  is the same as  father f,  because of the 'return'.
13:30:48 <roconnor> vininim: if not, then I don't see a nice H98 way of doing this (other than making two parameters w, which is very not nice))
13:31:14 <byorgey> in some sense the return guarantees that 'return f' has no 'effects' so you aren't using the monadicity of >>=, if you will.
13:31:21 <vininim> they do (because I filter the input that is... damn biologists :) )
13:31:24 <byorgey> but you have no such guarantee about the result of father.
13:31:40 <roconnor> vininim: btw Control.Monad.join is also called concat.
13:31:43 <roconnor> @type concat
13:31:45 <lambdabot> forall a. [[a]] -> [a]
13:32:29 <roconnor> oh, res and dssp do have the same length
13:32:33 <byorgey> Absolute0: here's a simple example:
13:33:15 <roconnor> @type (&&&)
13:33:16 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
13:33:31 <byorgey> wait, never mind.  your two examples don't even type check.
13:33:38 <vininim> roconnor: not guaranteed by the program
13:33:39 <byorgey> that is, if one of them typechecks, then the other doesn't.
13:33:57 <Absolute0> byorgey: i got the former from http://www.haskell.org/all_about_monads
13:34:42 <byorgey> right.
13:34:45 <blsecres> is there a way to globally set the -L flag to ghc or --extra-lib-dirs to cabal?
13:35:08 <byorgey> Absolute0: in  (return f) >>= father >>= father,  father has type  a -> m b.
13:35:28 <roconnor> vininim: ah crap you are right.
13:35:36 <byorgey> so  father . father doesn't make sense, since the domain and codomain types can't match -- one has an 'm' and the other doesn't.
13:35:46 <Absolute0> byorgey: oh its sort of extracting the monad and then placing it back in?
13:36:04 <byorgey> Absolute0: yes, that's one way to think about how >>= works
13:36:05 <roconnor> vininim: I made an annotation, but ignore it.  It won't even type check.  (horray type checker for spotting broken code)
13:36:05 <dcoutts> blsecres: yep, in the ~/.cabal/config file
13:36:20 <Absolute0> byorgey: isn't that what functors are all about?
13:36:22 <byorgey> although don't rely too heavily on that intuition, it breaks down at some point =)
13:36:27 <roconnor> vininim:        res = concatMap getRes chains
13:36:47 <byorgey> Absolute0: sort of, but functors are much more general and much weaker.
13:36:58 <roconnor> vininim: or res = getRes =<< chains, if you want to be a bit more obtuse.
13:37:03 <byorgey> Absolute0: in particular, every monad is a functor.
13:37:30 <Peaker> Absolute0: Functors can take it out into a pure function and put it back in. But Functors can't take it into a monadic function that sequences the original action with the result action
13:37:33 <blsecres> dcoutts: hmm, seems I've already got that set.  guess it's ghc --make that needs the -L flag
13:38:08 <dcoutts> blsecres: you uncommented the extra-lib-dirs line right?
13:38:12 <Peaker> Absolute0: Taking the value out into an (a->b) function and putting it back in is easier than taking it into an  (a -> m b) function and then "sequencing" the (m a) and (m b) together
13:38:15 <vininim> roconnor: oh, that ones is nice
13:38:21 <vininim> -s
13:38:33 <roconnor> vininim: to bad it is totally broken
13:38:36 <Peaker> Absolute0: Functors don't need to know to sequence at all, whereas here we have an (m a) and (m b) and the result (m b) has the "effects" of both
13:38:44 <Absolute0> using simple OOP seems more elegant :-P
13:39:02 <Absolute0> monads/functors seem to simply solve OOP in FP
13:39:13 <mauke> how do they solve OOP?
13:39:21 <Absolute0> change state
13:39:26 <mauke> what state?
13:39:32 <Absolute0> to boxed items
13:39:43 <mauke> I'm thinking of Maybe here
13:39:51 <mauke> not very stateful
13:40:06 <byorgey> Absolute0: monads and functors are way more general.  they really have very little to do with OOP.
13:40:43 <Absolute0> to me it seems like they provide manipulation on blackboxes through abstractions which objects really are..
13:41:06 <jmcarthur_work> data OOPish = forall a . Num a => OOPish a -- better approximation of OOP-like ideas
13:41:20 <Peaker> Absolute0: "OOP" isn't very well-defined.  Functors and Monads are generalized interfaces that lots of code can use and be far more general than "OOP" code typically is
13:41:32 <jmcarthur_work> basically, you know what it can do, but not what it is, in OOP
13:41:44 <mauke> Absolute0: ok, how do you implement [] and Cont, OO style?
13:41:52 <jmcarthur_work> and you can have collections of things that are not the same types in OOP
13:41:53 <byorgey> Absolute0: in some sense, programming is all about manipulating black boxes through abstractions.  everything is an abstraction on some level.  OOP is just one particular type of abstraction, that isn't the solution to everything.
13:41:54 <Peaker> Absolute0: All polymorphic Haskell types work on "black boxes", not just Monads, and "information hiding" or "encapsulation" isn't really an OOP-only concept
13:42:17 <byorgey> what Peaker said.
13:42:42 <Absolute0> Peaker: well functors in particular seem like adding simple object methods..
13:42:49 <jmcarthur_work> Absolute0, Functors are closer to C++ templates, especially if you look at STL containers as examples
13:42:53 <Absolute0> just getting started with monads :)
13:43:00 <Peaker> Absolute0: Functors are nothing like "simple object methods"
13:43:10 <byorgey> Absolute0: you are correct to notice that the important thing about functors and monads is the interface they provide, for dealing with common patterns in an abstracted way.
13:43:27 <Absolute0> Peaker: better: object method factories.
13:43:32 <jmcarthur_work> Absolute0, what is the object if you are looking at a functor? what are its methods?
13:43:39 <Peaker> Absolute0: how so?
13:44:12 <Absolute0> fmap (+1) Just 5 = Maybe.addOne
13:44:27 <Absolute0> fmap (*2) Just 5 = Maybe.twice
13:44:28 <Absolute0> etc..
13:44:32 <byorgey> Absolute0: a humble observation: it seems like you are trying very hard to connect these new things you are learning with things you already know.  while that's not bad per se, I might recommend just trying to learn about functors, monads, etc. more on their own terms, and only later try to make connections back.
13:44:48 <byorgey> at this point I think you are just bound to confuse yourself.
13:44:54 <vininim> Absolute0: how is that oop and not macro?
13:44:55 <Absolute0> probably :)
13:45:08 <jmcarthur_work> Absolute0, that doesn't seem quite right. what would Maybe.addOne do with a Maybe String?
13:45:09 <mauke> Absolute0: functions are functors
13:45:17 <Peaker> Absolute0: No, your methods are aware of the operation, and fmap isn't
13:45:33 <Absolute0> anyways is there a more practical use of Monads beside the popular IO Monad?
13:45:41 <vininim> xD
13:45:44 <byorgey> there are lots!
13:45:44 <jmcarthur_work> Absolute0, monads are useful everywhere! :)
13:45:46 <Absolute0> something used in nothing to do with IO
13:45:50 <Peaker> Absolute0: "more practical"?  What do you mean?
13:45:52 <Absolute0> like simple algorithms
13:45:54 <jmcarthur_work> @instances Monad
13:45:54 <mux> dcoutts: yay, the haddock docs are finally generated as expected :)
13:45:55 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
13:45:58 <Peaker> Absolute0: Monads are used everywhere
13:46:28 <mauke> Absolute0: functions are monads
13:46:53 <jmcarthur_work> :t join (*)
13:46:55 <lambdabot> forall a. (Num a) => a -> a
13:47:00 <jmcarthur_work> join (*) 4
13:47:01 <mauke> the Maybe monad provides simple exception handling
13:47:05 <jmcarthur_work> > join (*) 4
13:47:06 <lambdabot>   16
13:47:16 <mauke> the ST monad gives you local mutable variables
13:47:45 <hackagebot> authenticate 0.0.1
13:47:56 <jmcarthur_work> :t runReader -- a wrapper for the function monad to make its functionality explicit
13:47:58 <lambdabot> forall r a. Reader r a -> r -> a
13:48:00 <Peaker> @let liftedTuple = liftM2 (,)
13:48:01 <lambdabot>  Defined.
13:48:05 <Peaker> > liftedTuple [1,2,3] [4,5,6]
13:48:07 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
13:48:10 <Peaker> > liftedTuple (Just 5) (Just 6)
13:48:11 <lambdabot>   Just (5,6)
13:48:20 <Peaker> @type liftedTuple
13:48:21 <lambdabot> forall (m :: * -> *) a1 a2. (Monad m) => m a1 -> m a2 -> m (a1, a2)
13:48:26 <jmcarthur_work> :t runState -- a monad that allows you to read and update the "state" of a variable
13:48:28 <lambdabot> forall s a. State s a -> s -> (a, s)
13:48:38 <mauke> > liftedTuple (+1) (*2) 21
13:48:39 <lambdabot>   (22,42)
13:48:44 <Peaker> Absolute0: note liftedTuple -- its a general function that can work on any monad, not just Maybe or List or IO
13:48:45 <hackagebot> hack-middleware-jsonp 0.0.1
13:48:49 <jmcarthur_work> list is also a monad
13:49:09 <Absolute0> Maybe another weeek of googling will help :)
13:49:22 <jmcarthur_work> > [1,2,3] >>= return . (+1)
13:49:24 <lambdabot>   [2,3,4]
13:49:24 <Peaker> maybe liftA2/liftM2 should be called fmap2?
13:49:25 <Absolute0> just got functors yesterday..
13:49:26 <dcoutts> mux: so you'd been using build-type: Simple all along?
13:49:29 <jmcarthur_work> (same as fmap, there)
13:49:38 <mux> dcoutts: yup, pretty stupid heh.
13:49:45 <hackagebot> hack-handler-cgi 0.0.1
13:49:47 <dcoutts> mux: and thus your custom Setup.hs was being ignored. Ok, glad we worked it out.
13:50:27 <mux> dcoutts: too bad we didn't get to the sources of the build bot though
13:50:48 <dcoutts> mux: people have suggested before that we should look at the Setup.hs in that case and see if it looks like it's really that simple and warn if not.
13:50:56 <dcoutts> mux: aye, did he say why?
13:51:00 <jmcarthur_work> @hoogle [a] -> Maybe a
13:51:01 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
13:51:01 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
13:51:01 <lambdabot> Prelude head :: [a] -> a
13:51:09 <mux> dcoutts: nope, he didn't mention anything about that
13:55:46 <Peaker> > listToMaybe [1..3]
13:55:47 <lambdabot>   Just 1
13:55:53 <Peaker> I think listToMaybe should have been called head, and head discarded :P
13:57:48 <Absolute0> quit
13:58:21 <mreh> can anyone tell me why cabal is using a library that isn't listed as a dependancy when I'm installing something from hackage
13:58:34 <osfameron> Peaker: it would make lots of simple things more verbose though?
13:58:35 <mreh> could it be a secondary dependancy?
13:59:17 <dcoutts> mreh: what do you mean exactly? that it's downloading several packages and you're wondering why a particular one is an indirect dependency?
13:59:48 <mreh> dcoutts: one of the dependancies causes a bug, but I can't determine which one to use to solve the problem
13:59:52 <Peaker> osfameron: Possibly, but that would only be a catalyzator for the solution of the next problem
14:00:05 <mreh> Loading package unix-2.3.2.0 ... <command line>: can't load .so/.DLL for: rt (/usr/lib/librt.so: symbol __librt_multiple_threads, version GLIBC_PRIVATE not defined in file libc.so.6 with link time reference)
14:00:05 <mreh> cabal: Error: some packages failed to install:
14:00:08 <osfameron> Peaker: heh, I guess so ;-)
14:00:25 <dcoutts> mreh: cabal install --dry-run  will give you the list to be installed, one of them will depend on the failing one
14:00:29 <Peaker> osfameron: Each solution brings with it new problems -- if you throw it away because of those, you're stuck with old problems. I prefer new problems in a research language :)
14:00:49 <dcoutts> mreh: you don't want to be re-installing the unix package anyway
14:01:05 <Peaker> osfameron: its possible that nobody's seeing those new problem solutions because they've abandoned that path already (e.g abandoning purity because of not having IObind and IOreturn)
14:01:47 <mreh> yi-0.6.0 <- that's the only package it is listing to be installed, and unix isn't even down as a dependancy
14:02:05 <osfameron> Peaker: I'm coming at haskell from a very different place... so I'm glad of the simple functions I can get my head around while I'm learning... but I take your point for development/new ideas
14:04:10 <mreh> dcoutts: is there a reason why a dependancy isn't listed in hackag?e
14:04:46 <dcoutts> mreh: yeah, there's some weirdity with conditional deps in the current way hackage displays deps
14:04:47 <mreh> oh, unix-compact, that exports bits of unix
14:05:26 <mreh> dcoutts: why shouldn't i reinstall unix?
14:05:29 <mreh> the package
14:06:22 <dcoutts> mreh: there's no need and it's got the potential to mess things up
14:06:53 <mreh> dcoutts: nothing wrong with having two versions and forcing the installer to use one?
14:07:15 <dcoutts> mreh: oh, adding an extra version is ok, replacing one is a bit dodgy
14:08:19 <olsner> is there any nice typeclass which is 0 for numbers and an empty list for lists?
14:08:34 <roconnor> olsner: almost monoid
14:08:42 <roconnor> > mempty :: [a]
14:08:43 <lambdabot>   []
14:08:48 <olsner> yeah, definitely monoidy
14:08:53 <conal> mempty :: Sum a
14:08:54 <lambdabot> conal: You have 1 new message. '/msg lambdabot @messages' to read it.
14:08:54 <roconnor> > mempty :: (Sum Int)
14:08:55 <lambdabot>   Sum {getSum = 0}
14:09:03 <roconnor> > mempty :: (Sum Double)
14:09:04 <lambdabot>   Sum {getSum = 0.0}
14:09:25 <olsner> hmm, I could use Sum (or Max, which I assume also exists as a monoid)
14:09:25 <roconnor> > mempty :: (Product Int)
14:09:27 <lambdabot>   Product {getProduct = 1}
14:09:54 <roconnor> I'm not sure there is a Max instance of monoid, but you could write one.
14:10:03 <olsner> > mempty :: (Max Int)
14:10:04 <lambdabot>   Not in scope: type constructor or class `Max'
14:10:08 <olsner> > mempty :: (Maximum Int)
14:10:10 <lambdabot>   Not in scope: type constructor or class `Maximum'
14:10:27 <roconnor> 0 really isn't the identity for Int
14:10:34 <roconnor> under max
14:10:38 <olsner> yeah, I just realized that
14:10:44 <Berengal> > minBound :: Int
14:10:46 <lambdabot>   -9223372036854775808
14:10:50 <Berengal> There it is
14:11:14 <roconnor> olsner: If you want natural numbers, you have a second reason for making your own newtype
14:11:22 <olsner> minBound is also wrong though, I wouldn't say Max has a defined value on an empty "list"
14:11:37 <Berengal> olsner: minBound isn't wrong
14:11:59 <roconnor> > maximum [] :: Int
14:12:01 <lambdabot>   * Exception: Prelude.maximum: empty list
14:12:12 <roconnor> Berengal: prelude agrees with olsner
14:12:19 <olsner> something like, data Max a = EmptyMax | Max a
14:12:19 <roconnor> so they are both wrong! :D
14:12:23 <Berengal> roconnor: maximum isn't mconcat for Max
14:12:38 <Berengal> @src maximum
14:12:38 <olsner> with an error for getMax EmptyMax
14:12:39 <lambdabot> maximum [] = undefined
14:12:39 <lambdabot> maximum xs = foldl1 max xs
14:13:06 <roconnor> I guess the problem is that maximum doesn't want to  have a Bounded constraint.
14:13:28 <Berengal> roconnor: Indeed. Max requires such
14:14:08 <roconnor> newType Max a = Max {getMax :: a}
14:14:17 <Berengal> instance (Bounded a, Ord a) => Monoid (Max a) where mempty = minBound; mappend = max
14:14:33 <Berengal> Monoid laws hold for that one
14:14:39 <roconnor> ship it!
14:15:20 <roconnor> newtype Natural = Natural Integer
14:15:22 <roconnor> hmm
14:15:30 <roconnor> Berengal: Natural isn't an instance of Bounded.
14:15:32 <roconnor> :(
14:15:44 <mreh> installing yi on ghc 6.10 doesn't work
14:15:59 <Berengal> roconnor: I know, but it does have minBound
14:16:05 <roconnor> bah, we need to redo the whole Ord hierarchy anyways
14:16:22 <Berengal> BoundedBelow, BoundedAbove?
14:16:33 <roconnor> I would call it SemiLattice
14:16:56 <roconnor> possibly UpperSemiLattice and LowerSemiLattice, but I don' think I'd do that.
14:17:23 <roconnor> I could be convinced
14:17:54 <roconnor> but I think UpperSemiLattice and LowerSemiLattice are really the same structure, so there isn't a need for two of them.
14:18:09 <Berengal> Would be nice to have more than one, for structures that have several bounds
14:18:20 <Berengal> But there's nowhere to stop...
14:18:35 <roconnor> I certainly would have Lattice
14:19:07 <roconnor> class (SemiLattice a, SemiLattice (Dual a) => Lattice a)
14:19:11 <olsner> how do you get more than two bounds?
14:19:19 <roconnor> something like that using type families
14:19:25 <Berengal> olsner: More than one dimention
14:19:31 <Berengal> e.g. (Int, Int)
14:19:33 <roconnor> obviously what I wrote isn't legal, but I think you could do something nice with type families.
14:19:51 <mreh> is the darcs repo more likely to be up to date than hackage>
14:20:18 <Berengal> roconnor: With Dual a being a newtype with bounds inverted?
14:20:19 <roconnor> class (PartialOrd a) => SemiLattice a
14:21:02 <roconnor> Berengal: I'm not sure, I haven't really worked it out.  If it cannot work out, I'd just drop the Dual restriction.
14:21:50 <roconnor> or if we want to stay Haskell 98, then I'd just do class (SemiLattice a) => Lattice a
14:22:13 <roconnor> newtype Dual a = Dual a
14:22:26 <roconnor> instance (Lattice a) => Lattice (Dual a)
14:22:55 <roconnor> but I suspect there is something nifty that can be done with associated type families
14:23:12 <Berengal> Yeah, quite possibly... type families seem nice
14:23:22 <skorpan> i always think "lettuce" when i read "lattice"
14:23:33 <roconnor> mmm
14:23:36 <roconnor> semilettuce
14:23:38 <roconnor> :P
14:25:43 <mreh> is there a better tool than wget for downloading lots of source files
14:25:54 <ik> A tarball
14:26:06 <ik> + wget
14:26:07 <mreh> im getting them all from a darcs repo
14:26:22 <pejo> mreh, why not use darcs?
14:26:27 <mreh> good question
14:26:49 <Heffalump> rsync if the other end supports it
14:46:41 <mholub_> Can anyone build little haskell source under linux and send me a static-linked binary? Please.. I am under OSX and have no quick access to linux machine with ghc
14:57:09 <tim____> Hey - would anyone mind giving a n00b a  bit of advice on a weird (but presumably basic) type system error?
14:57:37 <skorpan> tim____: just ask!
14:58:06 <tim____> heh, thanks :-) so i've got a couple of really basic functions defined like this: http://gist.github.com/121834
14:58:24 <tim____> and hugs complains that "Inferred type is not general enough"
14:58:45 <edwardk> @remember Chris Okasaki: It happened around midnight, when I was quite exhausted already. I typed ":r", read the first line of the message "My brain just exploded." and said, "Yeah, tell me about it...". And then I jumped off the chair, having realized what I've been talking with.
14:58:46 <lambdabot> Done.
14:58:55 <skorpan> tim____: it's probably complaining about the Double
14:58:59 <tim____> my question is why? presumably it's to do with how perm and comb call factorial - but since they all take an Integral as args and return an Integral, where's the problem?
14:59:16 <tim____> aah
14:59:18 <skorpan> tim____: change the type signature to "perm :: (Integral a, Fractional b) => a -> a -> b"
14:59:26 <skorpan> not sure if that will work, but that's what i'd try
14:59:28 <tim____> aha!
14:59:29 <tim____> thanks
14:59:36 <tim____> not sure how that Double crept in there tbh
14:59:47 <skorpan> come back if that doesn't work (which it probably won't) :)
15:00:25 <byorgey> no, I think the Double is fine
15:00:38 <byorgey> tim____: the problem is that you are trying to divide things which are Integral.
15:00:47 <skorpan> oh, right, uhm...
15:00:49 <skorpan> that was silly
15:00:49 <tim____> aah yes
15:00:52 <tim____> that makes sense :-)
15:00:53 <byorgey> division (/) only works on Fractional things.  so you must explicitly convert them first.
15:00:59 <byorgey> Haskell doesn't have implicit conversion.
15:01:03 <tim____> so can i coerce an Integral to a Fractional?
15:01:04 <byorgey> @quote fromIntegral
15:01:05 <lambdabot> lilac says: <drdozer> gha! I'm drowning in the haskell number hierarchy again <lilac> drdozer: magic 8-ball says 'add calls to fromIntegral'
15:01:10 <byorgey> @quote fromIntegral
15:01:10 <lambdabot> lilac says: <drdozer> gha! I'm drowning in the haskell number hierarchy again <lilac> drdozer: magic 8-ball says 'add calls to fromIntegral'
15:01:19 <byorgey> hmm, there was another quote...
15:01:24 <skorpan> > (fromIntegral 1) :: Fractional
15:01:24 <lambdabot>   Class `GHC.Real.Fractional' used as a type
15:01:26 <skorpan> meh
15:01:27 <byorgey> anyway, yes, with fromIntegrel =)
15:01:32 <skorpan> > (fromIntegral 1) :: Double
15:01:33 <lambdabot>   1.0
15:01:34 <byorgey> fromIntegral*
15:01:38 <tim____> aah
15:01:40 <tim____> fantastic
15:01:42 <tim____> thanks all :-)
15:01:46 <byorgey> sure =)
15:02:00 <skorpan> is there any way to use fromIntegral to coerce it into any Fractional a?
15:02:06 <skorpan> instead of the narrow-minded Double
15:02:13 <byorgey> :type fromIntegral
15:02:21 <byorgey> @type fromIntegral
15:02:21 <skorpan> > (fromIntegral 1) :: (Fractional a)
15:02:22 <lambdabot> forall a b. (Integral a, Num b) => a -> b
15:02:23 <lambdabot>   Class `GHC.Real.Fractional' used as a type
15:02:31 <edwardk> @type fromIntegral
15:02:33 <lambdabot> forall a b. (Integral a, Num b) => a -> b
15:02:40 <byorgey> skorpan: anything which is Fractional is also in Num, so that should work fine.
15:03:13 <byorgey> skorpan: i.e. you can assign fromIntegral the (more specific) type signature  (Integral a, Fractional b) => a -> b
15:04:07 <Peaker> @hoogle (\\)
15:04:07 <lambdabot> Data.IntMap (\\) :: IntMap a -> IntMap b -> IntMap a
15:04:07 <lambdabot> Data.IntSet (\\) :: IntSet -> IntSet -> IntSet
15:04:07 <lambdabot> Data.List (\\) :: Eq a => [a] -> [a] -> [a]
15:04:22 <mholub> Sorry for repeating... please help me - compile little haskell program for tomorrow test, i don't ask you to run it, only compile and send me binary
15:04:37 <mholub> (on linux machine)
15:04:38 <Peaker> mholub: just install ghc
15:05:01 <skorpan> byorgey: what do you mean?
15:05:27 <mholub> Peaker, I am on osx, and my second machine with ubuntu has only 6.8.2, compiling 6.10.* on it will take hours
15:05:33 <byorgey> skorpan: I mean the answer to your question (about using fromIntegral to convert to any Fractional) is yes.  what do *you* mean? =)
15:05:41 <Peaker> mholub: you don't need to compile 6.10.* on it, just install from binaries
15:05:52 <edwardk> skorpan: you are misusing Fractional, its a typeclass, not a type
15:05:53 <Peaker> mholub: it takes 2 minutes after the download
15:05:55 <mholub> Peaker, do you know repository with 6.10 for ubuntu?
15:06:08 <skorpan> edwardk: yeah, i know :)  so is it possible to do what i want?
15:06:09 <edwardk> > (fromIntegral 1) :: (Fractional a => a)
15:06:10 <lambdabot>   1.0
15:06:13 <skorpan> ah!
15:06:15 <byorgey> skorpan: note you can't actually convert a number into a value of type  (Fractional a) => a, that doesn't make sense
15:06:23 <Peaker> mholub: http://www.haskell.org/ghc/download_ghc_6_10_3.html -- download the Linux 32/64 binaries for your system, and just ./configure --prefix=/usr/local && sudo make install
15:06:25 <byorgey> that is a value of EVERY Fractional type
15:06:25 <skorpan> byorgey: but edwardk just did? :P
15:06:36 <byorgey> skorpan: that got defaulted to Double.
15:06:41 <skorpan> oh
15:06:45 <byorgey> it's cheating =)
15:06:52 <edwardk> the constraint should be that 'a' is an instance of Fractional, not that your type is 'Fractional a'
15:06:54 <skorpan> hehe
15:07:01 <skorpan> edwardk: yup, i understand :) thanks
15:07:06 <Peaker> is there a destructive-write fold on mutable arrays?
15:07:08 <skorpan> oops, gotta go!
15:07:32 <mholub> Peaker: thanks, don't notice binary package on haskell.org
15:07:42 <mholub> *didn't*
15:07:46 <Peaker> mholub: http://www.haskell.org/ghc/download_ghc_6_10_3.html#binaries
15:07:51 <edwardk> peaker: hrmm, never tripped over one
15:08:09 <edwardk> you want a fold or a map or what?
15:08:18 <Peaker> edwardk: a fold
15:08:34 <byorgey> 'destructive-write fold' doesn't make sense.  do you mean something like a mapAccum* ?
15:08:45 <edwardk> by destructive write you mean, foldr-like traversal and replace the values as you go?
15:09:17 <Peaker> edwardk: ya
15:09:26 <Peaker> not sure I want that, just wondering :)
15:10:48 <edwardk> the signature would look something like: MArray arr a m => (a -> b -> (a,b)) -> b -> arr i a -> m b -- kinda ugly
15:11:17 <edwardk> and once you've gone that far you might as well allow the map action itself to be monadic, etc.
15:12:48 <edwardk> i think too many variants suggest themselves for it to come anywhere near a standard library ;)
15:13:51 <byorgey> and then edwardk would start hitting it up with parazygohistomorphisms and it would all be downhill from there. ;)
15:14:11 <Saizan_> well, you can put it in the split package
15:14:14 <edwardk> bah, no point in parazygo
15:14:23 <byorgey> haha, touche =)
15:15:57 <edwardk> =)
15:18:15 * edwardk has been tortured by a desire to write a horrible xmonad plugin all day for chrome style tabs, just so I can call it chromulent. After all, it embiggens the prose.
15:18:41 <byorgey> hah!
15:19:04 <byorgey> you totally should.
15:19:17 <edwardk> that said, even as a standalone window manager, it'd be a pretty spiffy toy
15:19:43 <inimino> hey edwardk how's your parsing stuff going?
15:19:44 * byorgey doesn't know how 'chrome-style tabs' work
15:19:44 <sjanssen> what makes the tabs chrome style?
15:19:53 <sjanssen> just the trapezoidal shape?
15:20:13 <edwardk> sjanssen: they replace the title bar, and you can rip them off and dock them
15:20:26 <sjanssen> edwardk: xmonad doesn't have title bars
15:20:53 <byorgey> edwardk: coming to Hac phi?
15:20:53 <edwardk> sjanssen: thats why i said it'd be a horrible xmonad plugin, perhaps better as a standalone app.
15:21:04 <edwardk> byorgey: where is it located?
15:21:11 <byorgey> edwardk: Philly!
15:21:20 <edwardk> byorgey: hrmm, when?
15:21:23 <byorgey> the same place I am located =)
15:21:27 <byorgey> July 24-26
15:21:40 <byorgey> http://haskell.org/haskellwiki/Hac_%CF%86
15:21:50 <edwardk> might be tight i have a wedding to attend that same week
15:21:59 <byorgey> ah, gotcha
15:22:01 <edwardk> but i'll see if i can make it down there and maybe drag shapr
15:22:18 <byorgey> yes! please do. =)
15:24:42 <edwardk> added to my calendar
15:25:22 <byorgey> awesome, hope you can make it =)
15:26:23 <edwardk> i have a ton of vacation time I might as well take some of it
15:26:59 <byorgey> yup.  otherwise it just accrues to The Man.
15:27:21 <edwardk> inimino: they are coming along slowly. i've been kind of sucked into other things these last couple of weeks. i'm hoping to find some time to package stuff up into a coherent whole in the next couple of weeks.
15:28:36 <edwardk> inimino: the biggest problem i've run into is that i need to refactor the monoid library's notion of a reducer to allow for seminearring reducers, so i can define the notion of a 'module over an applicative' in a manner analogous to a 'module over a seminearring'
15:28:41 <Peaker> @hoogle runSTArray
15:28:41 <lambdabot> Data.Array.ST runSTArray :: Ix i => ST s (STArray s i e) -> Array i e
15:28:58 <Peaker> @hoogle runST
15:28:59 <lambdabot> Control.Monad.ST runST :: ST s a -> a
15:28:59 <lambdabot> Control.Monad.ST.Lazy runST :: ST s a -> a
15:28:59 <lambdabot> Data.Array.ST runSTArray :: Ix i => ST s (STArray s i e) -> Array i e
15:29:08 <Peaker> oh
15:29:20 <edwardk> because i'm finding thats a nice way to think about how certain kinds of applicatives interact.
15:29:50 <inimino> edwardk: I'll look forward to reading what you have
15:30:28 <edwardk> inimino: heh, well, each iteration there is less and less there ;)
15:30:43 <inimino> I've got a parser generator and now I need to make it handle arbitrary edits without reparsing the whole document
15:30:46 <inimino> that's a good sign of progress :-)
15:30:59 <edwardk> inimino: ah thats basically the approach i've been going for
15:31:18 <inimino> a well-designed library is the tip of the iceberg of code that had to be written and deleted to get to that point
15:31:21 <edwardk> the monoidal parsing stuff is proving to be hard to demonstrate any sort of win for on a sufficiently complicated grammar though
15:31:54 <inimino> ah, that's interesting
15:32:10 <edwardk> my best bet so far is to work with LALR grammars with error annotations that have some side conditions on them and run the parser as if it was GLR, that seems competitive
15:32:24 <Peaker> @type iterate
15:32:26 <lambdabot> forall a. (a -> a) -> a -> [a]
15:32:28 <Peaker> yairchu: ^^
15:32:43 <inimino> ok
15:32:44 <Peaker> @hoogle (a -> a) -> a -> [a]
15:32:45 <lambdabot> Prelude iterate :: (a -> a) -> a -> [a]
15:32:45 <lambdabot> Data.List iterate :: (a -> a) -> a -> [a]
15:32:45 <lambdabot> Data.Generics.Schemes everywhere :: (a -> a) -> a -> a
15:33:37 <thoughtpolice> woot
15:33:49 * thoughtpolice just got done adding support for module/function annotations to hint
15:33:53 <edwardk> i've also been playing with a funny kind of packrat parser where i 'light off' sparks on k columns of rules, and pursue the follow-sets of the rules i started. you can use the same worst-case asymptotics  of a packrat parser and then divide out the # of chunks if you're careful
15:33:59 <edwardk> but the constants are ridiculous
15:34:46 <edwardk> that should give O(ng/k) time parsing for a PEG but with a huge constant
15:35:09 <edwardk> n byte string, g grammar complexity, on k nodes.
15:35:27 <edwardk> er k cpus/cores/what have you
15:35:43 <inimino> edwardk: that's interesting
15:36:17 <inimino> the line I'm persuing is starting with a PEG and then analyzing it and optimizing things away where possible
15:36:37 <aledge> hey d00ds
15:37:03 <inimino> but yeah... large constant factors especially with memory
15:37:14 <edwardk> inimino: the LALR with some global restart conditions is pretty competitive though, since you can run it like a normal parser, you just need some information about the fact that i.e. when you see a < in an xml file its usually something interesting
15:37:43 <aledge> wrong, because xml files are never interseting
15:37:51 <Peaker> @djinn ((a -> b) -> Maybe a -> Maybe b)
15:37:52 <lambdabot> f a b =
15:37:52 <lambdabot>     case b of
15:37:52 <lambdabot>     Nothing -> Nothing
15:37:52 <lambdabot>     Just c -> Just (a c)
15:37:57 <aledge> jk
15:38:10 <inimino> edwardk: alright, I'll look into that
15:38:15 <edwardk> i mean in that case, running in parallel you still have to parse as if you could be in the middle of a CDATA, DOCTYPE or <!-- --> section
15:38:31 <edwardk> but thats where i've been going as my main 'fallback' parallel parser
15:38:43 <inimino> yeah
15:39:20 <edwardk> i got a 4x speedup on 8 cores in a quick test that i didn't optimize very well, so i'm hopeful there.
15:39:31 <Peaker> @djinn-add Not a = (a -> Void)
15:39:32 <lambdabot> Cannot parse command
15:39:42 <Peaker> @djinn-add type Not a = a -> Void
15:39:55 <Peaker> @djinn (a -> Not a)
15:39:56 <lambdabot> -- f cannot be realized.
15:40:02 <Peaker> @djinn (a -> Not (Not a))
15:40:02 <lambdabot> f a b = b a
15:40:10 <edwardk> and its not like parsing xml is an uncommon task these days, unfortunately ;)
15:40:15 <inimino> edwardk: you could also make some assumptions about likely parser states at the beginning of a chunck, and then reparse if they fail to hold
15:41:21 <edwardk> inimino: yeah, though i've been trying to deal with the parse 'online' to avoid retraversing the chunk. in the xml case i figure i can accrete a bytestring of the contents of the chunk, and fold them together into a bytestring for the cdata section if it turns out i'm in that case
15:41:59 <inimino> ok
15:42:08 <edwardk> that said my current approach is probably lazy enough that its effectively doing what you said ;)
15:42:43 <inimino> ah :-)
15:42:50 <inimino> how much of this do you think you can automatically generate from a grammar?
15:42:59 <edwardk> i'm hoping basically all of it
15:43:09 <inimino> ok, cool
15:43:14 <edwardk> my current version rederives sharing from the grammar using terrible hacks
15:43:25 <edwardk> StableNames, etc.
15:43:43 <inimino> heh
15:43:45 <inimino> oh, yeah, yuck
15:43:47 <edwardk> but it means you can just use nice applicative combinators as long as the resulting tree is finite
15:44:00 <kpreid> rederiving sharing? that reminds me of that FPF paper on LtU
15:44:06 <edwardk> and all my builtin combinators are careful to get proper sharing
15:44:25 <edwardk> FPF?
15:44:35 <kpreid> http://lambda-the-ultimate.org/node/3331 (link to pdf)
15:45:16 <kpreid> http://www.lexifi.com/downloads/frankau.pdf section 5.1 talks about rederiving sharing and has 3 citations about it
15:45:18 <edwardk> i based my approach on the debug.traced stuff that lennart was monkeying around with. andy gill had a -very- similar DSL with rederived sharing info as well
15:45:43 <inimino> bbiab
15:46:19 <edwardk> kpreid: hrmm they appear to just be hash consing, which is a bit easier
15:47:00 <kpreid> well, they mention other techniques (I haven't followed those refs)
15:47:34 <MyCatVerbs> Is cabal-install not included in the ghc base install for some reason?
15:47:37 <edwardk> in the case of my stuff, andy's and lennart's, it works for arbitrary functions, etc. by spotting shared use of the same thunk by giving the thunks stable names
15:47:48 <edwardk> that way you avoid needing to use horrible 'fix' like combinators in the DSL.
15:48:30 <edwardk> and you can just code fairly naturally using let and where clauses, etc
15:49:29 <edwardk> many p = ps where ps = (:) <$> p <*> ps <|> pure [] -- is a little unnatural because you need the worker/wrapper to force sharing, but its not a hard style to use
15:51:07 <edwardk> MyCatVerbs: correct. though that looks like its changing and iirc there was a distribution of ghc with it rolled in (care of dons?) but i don't recall what happened with it
15:52:00 <Peaker> is there an R DSL in Haskell?
15:52:17 <edwardk> peaker: as in for use with the stats package r?
15:52:39 <Peaker> edwardk: A reimplementation of the R language as a DSL -- I'd find it easier to learn that way
15:52:46 <Peaker> edwardk: Giving Haskell types to stuff :)
15:53:05 <edwardk> peaker: ah not that i know, though, there is a DSL for bayes using gibbs sampling by Hal Daume called hbc. ;)
15:53:24 <Peaker> I don't know what bayes, gibbs, or Hal Daume are :)
15:53:25 <MyCatVerbs> edwardk: oh, the batteries-included thing? Yeah, I'll be glad to see it in the base install instead of that.
15:53:29 <edwardk> sadly too many projects are called hbc, so it doesn't really stand out
15:53:34 <Peaker> was just wondering if I could learn R quick by reading the types of its DSL :)
15:53:41 <Peaker> tla's suck
15:53:57 <MyCatVerbs> edwardk: IMHO it makes no sense to put all the work that dons dcoutts and everybody have into Cabal and then not have cabal install in the base so that it Just Works. :/
15:54:09 <edwardk> peaker: speaking as a guy who used R every day for a couple of years, i doubt it an really be learned quickly to any depth ;)
15:54:21 <MyCatVerbs> I mean. Hackage rocks. Let's have it usable right away. ^_^
15:54:24 <dcoutts> MyCatVerbs: the platform is the base install
15:54:26 <pastorn> does anyone know where the paper about the "real" prime sieve is? the one that's all fast and stuff :)
15:54:39 <edwardk> peaker: and statistics is basically a cesspool of TLAs unfortunately.
15:54:47 <dcoutts> MyCatVerbs: well, currently we say it's in beta, from ghc-6.12 onwards it is the base install
15:55:03 <edwardk> pastorn: like a sieve of atkin or on wheel sieve  techniques?
15:55:32 <sjanssen> so I'm making a Text.PrettyPrint.HughesPJ version of 99 bottles of beer on the wall, and I'm trying to tackle capital letters at the beginning of sentences.  Is it possible to write a function capital :: Doc -> Doc?
15:55:44 <pastorn> edwardk: probably with a wheel
15:55:58 <pastorn> there was a cool pdf, but i lost it when i reinstalled ubuntu
15:55:59 <Botje> pastorn: i think it's on the functional pearls section of haskell.org
15:56:07 <pastorn> Botje: cool, thanks
15:56:22 <edwardk> well, you might look up the sieve of atkin on wikipedia there is a link from there to a fast c implementation of it, that uses a wheel sieve mod 60 iirc
15:58:31 <edwardk> peaker: bayes using gibbs sampling (BUGS) is a nice way to train complicated statistical models that don't have the nice closed forms that a frequentist statistician likes. hbc is a BUGS compiler that compiles the model to yield a program that can run over big data sets and detect fitting/overfitting/lack of convergence of the model, etc.
15:59:38 <Peaker> edwardk: I don't know enough statistic to understand that, I guess
15:59:41 <edwardk> BUGS is a nice tool when you know the general 'shape' of the model, but you have no idea how to generate a pretty closed form to derive all the values of the posterior distribution's hyperparameters as you see elements.
15:59:48 <pastorn> Botje: the one there was from 97, i remember this one being quite newer
16:01:11 <edwardk> i.e. you think that that you have a normal distribution. and that its mean and standard deviation are distributed according to some other distributions that you have a good reason to suspect, etc. so you just want to see how good of a fit that model is and if you can train it without starting from calculus all over again for each model variant
16:01:40 <pastorn> or maybe not... you might look up the sieve of atkin on wikipedia there is a link from there to a fast c implementation 0xB aleator
16:01:47 <pastorn> whoops
16:01:50 <jimmyjazz14> I'm trying to install haskell-language-exts and keep getting this error:  Test/Runner.hs:5:7: Could not find module `Language.Haskell.Exts'
16:01:52 <pastorn> http://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf
16:02:23 <edwardk> with a traditional tool like R, you're basically stuck starting from first principles, with BUGS you basically get a nice way to specify that in a couple of lines and can start checking to see if the model is plausible.
16:03:01 <edwardk> look up winBUGS, openBUGS and Hal Daume's hbc to get a feel for the difference
16:03:20 <mreh> has anyone used the fp plugin for eclipse?
16:03:49 <jimmyjazz14> actually I'm trying to install haskell-src-exts
16:03:53 <edwardk> it has the benefit that it works well in the face of partially missing data, and all sorts of crazy cases
16:04:02 <edwardk> gah, gotta run
16:04:37 <jimmyjazz14> when I try to install it with cabal is complains that: happy version >=1.17 is required but it could not be found
16:04:53 <sclv_> you should install happy then
16:04:59 <jimmyjazz14> but I know I installed happy >1.17
16:05:16 <sclv_> cabal installs things by default in ~/.cabal/bin/
16:05:22 <dcoutts> jimmyjazz14: it's probably not on your $PATH
16:05:22 <sclv_> you might need to move it to the right place
16:05:49 <sclv_> (by things I of course only mean binaries)
16:07:01 <dcoutts> and/or tell cabal to symlink binaries somewhere useful in future, or adjust your $PATH
16:07:10 <jimmyjazz14> hmm okay
16:07:16 <dcoutts> see the symlink-bindir setting in the ~/.cabal/config file
16:07:25 <pastorn> where is the function 'fix' in GHC 6.8.2?
16:07:27 <jimmyjazz14> thanks
16:07:32 * pastorn can't find it
16:07:33 <sclv_> ?hoogle fix
16:07:33 <lambdabot> Data.Function fix :: (a -> a) -> a
16:07:33 <lambdabot> Control.Monad.Fix fix :: (a -> a) -> a
16:07:33 <lambdabot> module Control.Monad.Fix
16:07:50 <pastorn> heh, MonadFix
16:07:52 <pastorn> cool :)
16:08:01 <sclv_> ^^ teach a man to hoogle, and he can find anything
16:08:16 <sjanssen> are there any packages on hackage for converting numbers to their English words?
16:11:57 <olsner> can IntSets be used for lazily generated infinite lists?
16:12:08 <sclv_> no
16:12:24 <olsner> not even when you know the list is ascending and distinct?
16:13:02 <sclv_> i don't think so.
16:13:19 <olsner> hmm, I probably want to work on the original lists anyway
16:14:40 <Saizan_> you might want to use an immutable infinite trie, IntSet's spine depends on the actual elements present, iirc
16:17:29 <aavogt> sjanssen: I've done this for printing words http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5477#a5477 a while ago, maybe it would be useful?
16:17:52 <aavogt> it could definitely be cleaned up
16:18:25 <sjanssen> aavogt: what I really want is something on Hackage, so my program looks small and self-contained
16:18:38 <sjanssen> aavogt: making a nicer version of http://www.reddit.com/r/haskell/comments/8ovah/
16:20:51 <MyCatVerbs> dcoutts: ah, fair enough. I will be looking forward to that. :)
16:25:33 <aavogt> hmm, I suppose printing numbers in English (or other languages for that matter) could be useful on Hackage
16:26:06 * wli is stoked.
16:26:55 <defun> i can't seem to find any documentation that describes how one would make a module that re-exports other modules. i.e. if I import module 'a' I would also like to *automatically* import modules 'b' and 'c'... can it be done? Even a hackish way is fine...
16:28:09 <aavogt> defun: I look at other libraries for such features. module Foo (module Foo.Bar,module Foo.Baz) where import .... works IIRC
16:28:12 <mauke> module A (module B, module C) where
16:28:57 <defun> mauke: thanks! :)
16:29:29 <mreh> is there anyone I can help with their haskell? I'm bored for the next few weeks
16:33:53 <Twey> mreh: Write a monad tutorial :-P
16:34:05 <Peaker> mreh: maybe you could debug my lui toolkit?
16:34:44 <aavogt> mreh: could you help me write a  liftBox :: (C x, C y) => (x -> y) -> Box -> Box
16:35:04 <aavogt> where Box is existential and requires the C constraint
16:35:33 <aavogt> also, the y type depends on the x type
16:35:41 <mreh> aavogt, what's a box?
16:35:43 <Twey> Peaker: What's a LUI?
16:35:47 <mreh> haha
16:35:50 <Twey> Heh
16:36:06 <aavogt> data Box = forall a. C a => Box a
16:36:53 <Peaker> Twey: my GUI toolkit that I started working on
16:37:14 <Twey> Peaker: What does the L stand for?
16:37:16 <aavogt> @quote hype
16:37:17 <lambdabot> jcreigh says: I've found learning Haskell makes me feel vastly inferior to Haskell coders. ("Oh,", they say, "That's just a fold over the hyper-monad fluxbox list. Here's the one-line replacement
16:37:17 <lambdabot> for your entire program.")
16:37:27 <Twey> Hahahaha
16:37:31 <Peaker> Twey: Something silly, might as well say nothing :)
16:37:45 <Twey> Peaker: Aw :<
16:38:01 <Twey> I thought it was going to be some revolutionary new approach to UI design
16:38:13 <Peaker> I totally sympethize with jcreigh - though after about a year here, I can make most of the folds over hyper-monads myself :)
16:38:19 <Twey> Haha, aye
16:38:32 <Peaker> Twey: Its very very different to Gtk/Qt, and I think it has a bit of revolution in it :)_
16:38:46 * Berengal contemplates the nature of a hyper-monad
16:38:47 <Twey> Oh good :-P
16:39:10 <Peaker> Twey: Its a purely functional widget-set where each widget edits a part of a model functionally, via a Data.Accessor
16:39:10 <Twey> Berengal: It's obviously just a monad with more than one type parameter.
16:39:22 <Peaker> Twey: parameterized-monads? :P
16:39:22 <Twey> Peaker: Cool!
16:40:03 <Berengal> I read something about those not long ago...
16:40:29 <Peaker> Twey: the semantic model of a Widget is:  Widget model = model -> (Image, Size, Map Event model)    where Image is an "infinite mapping from coordinates to colors", so (Image, Size) gives you a bounded image
16:41:00 <Twey> Interesting
16:41:23 <Peaker> Twey: actually the map is   Map EventGroup (Documentation, Event -> model) -- so you get "reflection" about what operations the widget supports to show the user, and each event generates a new "edited" model.
16:41:25 <Twey> What about scaling widgets, though?
16:41:31 <Berengal> So, what does the L stand for?
16:41:48 <Berengal> Loleelay?
16:41:54 <Twey> Hehehe
16:41:56 <Twey> Lola
16:41:57 <Berengal> Loveable?
16:42:06 <Berengal> Linguistic?
16:42:11 <Peaker> Berengal: My name is Lotem, nickname Lotex.  So Lotex's User Interface, where the idea was that another dude joins called Simon, and it can be added to the end yielding LUIS - which happens to be the name of a 3rd dude also might work on it later :)
16:42:12 <Berengal> Lazy?
16:42:28 <Berengal> Haha
16:42:46 <Peaker> Twey: Image  can be scaled -- its an "infinite map from coordinate to color" with supposed infinite resolution
16:44:50 <Peaker> Twey: Now, this model has a bunch of very nice properties.  A) simplicity: its clear how the widget can affect the world - by returning new models.  B) transactional: The widget returns a whole new model, so if it edits text and a cursor at the same time, its automatically transactioned.  C) the widget gets a data-accessor to the model to access what it needs, so it can edit text inside a real model, and cursor buried in some GUIState corner of the model
16:45:32 <Peaker> Transactioned, as opposed to Gtk/etc where the text and cursor are destructively updated separately - and that causes problems, if you want to version everything, for example, including the cursor
16:46:12 <Peaker> Twey: also, I think I have a pretty simple/composeable model of focus/layout handling instead of the complicated/messy ones in Gtk+/Qt
16:47:31 <Peaker> basically, the keyboard focus isn't a global thing.  Each widget is aware if it has the focus (from its ancestors) or not. Focus "flows" down children from the root.   Grids have child widgets in a grid and pass on focus to one of them. Box is a Grid with hsize or vsize of 1
16:48:12 <Peaker> there's a Focus Delegation Widget  that can wrap around a Grid, or Text Edit, or whatever, which can take the focus to itself, or pass it on to a child, so by wrapping stuff in a focus delegator, you make the thing itself selectable
16:48:50 <Twey> Peaker: It can be scaled, but if (0, 0) yields black and (5, 5) yields blue, then those basically represent an abstract sort of pixel — if ‘scaled’ they'll end up either non-central (if you just increase the bound) or pixellated (if you increase the area to which each ‘pixel’ applies)
16:49:07 <Peaker> Twey: you're assuming a particular implementation
16:49:30 <Twey> It's a map, right?
16:50:06 <Twey> You'd need to pass in the bound to make it scaleable
16:50:11 <Twey> And have it be a function
16:50:25 <Peaker> Twey: its a continuous map
16:50:39 <Peaker> Twey: mathematically-speaking. In implementation/representation, its not necessarily a map at all
16:51:01 <Twey> But it still needs to know its own bounds to render itself at an appropriate resolution
16:51:23 <Peaker> Twey: well,   Image represents a continuous/infinite-resolution image, only when you actually render it, it is "sampled"
16:51:37 <Peaker> you scale it before "rendering it"
16:52:41 <Peaker> Twey: http://lukepalmer.wordpress.com/2008/07/18/semantic-design/  explains the idea nicely
16:53:47 <defun> In System.Process, what scenario would make rawProcess more desirable to use than runProcess, or vice versa. These two functions seem to do the same thing...
16:54:22 <Twey> Peaker: So it's not actually coördinate-based at all?
16:54:52 <mmorrow> defun: i'm not sure off-hand, but you can always view-source in the haddock docs
16:54:55 <Peaker> Twey: coordinates are passed as arguments in the implementation
16:55:24 <defun> ah. I am still getting used to the awesomeness of haddock. thanks.
16:56:30 <Peaker> Twey: I represent Image as something like:  SDL.Surface -> Position -> BoundingRect -> IO () -- because I don't need to currently support scaling.  This supports moving by simply applying a function to the Position argument before passing it on.  To support scaling I can just add a Scale argument and apply on that too
16:57:30 <vininim>  %GC time      63.7%  (63.5% elapsed)
16:57:34 <vininim> heh
16:58:13 <Peaker> vininim: doing a lot of mutating?
16:58:31 <newsham> http://gmarceau.qc.ca/blog/2009/05/speed-size-and-dependability-of.html
16:58:56 <newsham> "The shape of the Haskell star, specifically the way that it bends up, suggest to me that writing high-performance programs in Haskell is a bit of a black art, and that some of the benchmarks submissions could be improved if someone got around to it. It also suggests that the tweaks introduced to boost the performance occupy a lot of code space. (I hope someone from the Haskell community will be able to confirm whether this is the case)"
16:59:55 <vininim> Peaker: yeah, kind of
17:00:05 <Peaker> vininim: well, stop that :)
17:00:36 <vininim> but, most of the mutation is inside packedmatrix inplace mutation
17:01:06 <Peaker> Haskell performance is indeed a "black art" -- it takes quite a while before understanding the various techniques required to get fast Haskell.  So much so that I think I would downplay Haskell performance claims, as they are even misleading.  Not "nearly as fast as C", but just "Much faster than Python/et al"
17:01:31 <Peaker> it can be nearly as fast as C, for specific programs or if you are a black arts master
17:01:45 <Cale> I don't know about it being a black art.
17:02:04 <aavogt> doesn't writing the benchmark C take skill too?
17:02:08 <vininim> I dont have goats :/
17:02:11 <Cale> It's just that lazy evaluation is sufficiently different to strict evaluation that your existing knowledge about how to make strict programs perform well doesn't apply.
17:02:38 <Cale> So it's just something that you have to learn.
17:04:52 <Peaker> Cale: C encourages programs that perform well by correlating pretty well programs that are fast with programs that are short/easy
17:05:12 <Cale> Usually short programs are the fast ones in Haskell too.
17:05:15 <vininim> well, even with the overhead it's way better than octave for what I'm doing. =P
17:05:30 <Peaker> Cale: Knowing enough C to write correct programs and a bit of CS is enough to get fast-executing C.  Knowing enough Haskell to write denotationally correct Haskell programs and a bit of CS is not enough to write fast-performing Haskell programs
17:05:42 <Cale> I disagree on that first point.
17:05:58 <Peaker> Cale: how come?
17:05:59 * Twey ponders the possibility of ever knowing enough C to write correct programs
17:06:20 <Cale> Because I realise that it actually took me a long time to learn how to write good-performing imperative programs.
17:06:28 <Peaker> Twey: if you use a subset of C in very strict ways -- its possible
17:06:32 <vininim> it would be better if we just didn't get in the way of the compiler and enhance it =P
17:06:42 <Twey> But not Turing-complete :-P
17:06:50 <Cale> A number of years at least.
17:06:55 <Twey> vininim: *nods*
17:06:57 <Peaker> Cale: well, much of CS focuses on well-performing imperative algorithms -- so knowing some CS covers that..
17:06:59 <A1kmm> Hi, has anyone here managed to get ghc parallel Haskell to work for them and get a program to speed up? I have even tried writing a very simple, trivially parallelisable test program and parallel Haskell slows it down.
17:07:15 <Cale> It took me about the same amount of time to learn how to write programs which perform well in Haskell.
17:07:49 <Cale> A1kmm: I don't have a multiprocessor, but I can take a look and see if I can guess at why it's slower.
17:07:57 <vininim> I hope it's less than 10 years (perfomance tunning 3 hours per day)
17:08:03 <Cale> A1kmm: You might be creating too many sparks.
17:08:03 <Peaker> Twey: well, the subset being used is indeed not turing complete most of the time. When you do recurse or loop over things that are difficult to show as simply finite, you are far more careful and use a different subset of C, could say a different language, that is turing complete
17:08:10 <A1kmm> Cale: I started with:
17:08:16 <A1kmm> import Numeric.GSL.Special.Psi (psi)
17:08:17 <A1kmm> digammas = [1..100000000]
17:08:19 <A1kmm> result = sum digammas
17:08:21 <A1kmm> main = putStrLn $ ((showString "Result = ") . (shows result)) ""
17:08:32 <A1kmm> changed this to:
17:08:37 <A1kmm> import Numeric.GSL.Special.Psi (psi)
17:08:38 <A1kmm> import Control.Parallel.Strategies
17:08:40 <A1kmm> digammas = map psi [1..100000000]
17:08:42 <A1kmm> result = sum (parBuffer 10000 rnf digammas)
17:08:43 <A1kmm> main = putStrLn $ ((showString "Result = ") . (shows result)) ""
17:08:54 <Peaker> Cale: what example of a badly performing C program do you mean?  In Haskell, there are tons of ways to make a program perform badly, in C, I think there are less so - and the ones that do - are explicit (explicitly copying stuff shows to the programmer that its expensive)
17:09:14 <Peaker> Cale: C has far more transparent operational semantics on imperative computers, much easier to grok what's cheap and what's expensive
17:09:32 <A1kmm> and timings are: first program: 30.202s
17:09:35 <Cale> Peaker: There are a lot of ways to choose the wrong datastructure or the wrong algorithm.
17:09:37 <newsham> peaker: you know people who know enough C to write correct code? :)
17:09:42 <newsham> please have them send resume!
17:09:50 <A1kmm> second program without -threaded: 56.136s
17:09:51 * Twey laughs.
17:09:55 <Peaker> Cale: that's CS more than C, though
17:10:09 <A1kmm> second program with -threaded and -N1: 6m24.522s
17:10:20 <vininim> woah
17:10:23 <Peaker> newsham: You don't need to know "enough" C, you need to limit yourself to a strict subset of C and rigourously enforce it by conventions
17:10:38 <Cale> Peaker: The choices we make about datastructures and algorithms have to be different according to the evaluation model.
17:11:00 <Peaker> newsham: I've worked in a C shop where non-trivial modules were bug-less to the best of our knowledge, and we had far far more extensive testing than any other place I know
17:11:18 <Peaker> newsham: and by "bugless" I mean - the very extensive testing found almost nothing to begin with
17:11:23 <Cale> Peaker: I'm not really contrasting C and Haskell, I'm contrasting strict/imperative or strict/functional programming with lazy/functional.
17:11:23 <Peaker> newsham: (after the code reviews)
17:11:43 <A1kmm> Cale: with -N10 -g10 on a 22 CPU shared memory system: 7m50s
17:11:47 <newsham> [14:05] < Peaker> Cale: Knowing enough C to write correct programs and a bit of  CS is enough to get fast-executing C.
17:12:17 <Peaker> Cale: the thing is - the lazy/functional model maps less directly to our current hardware - its less transparent what the costs of operations are
17:12:25 <Cale> A1kmm: Why are you using parBuffer?
17:12:51 <Peaker> Cale: so given today's Von neumann imperative computers -- there's a bias for strict/imperative in terms of transparent operational semantics
17:13:00 <newsham> "reasoning about time and space of lazy programs is not always easy."
17:13:03 <A1kmm> So the map is evaluated ahead in parallel - is there a better approach?
17:13:05 <Cale> A1kmm: How about something like parListChunk ?
17:13:26 <newsham> anyway, I just wanted to bring that somewhat interesting blog to channel's attention
17:13:35 <Peaker> newsham: if we used total languages -- it could mean we switch to strict evaluation - and maybe that would make things easier
17:13:49 <Cale> Peaker: But it's still not hard to have a good model in your head which approximates the actual behaviour.
17:14:04 <Cale> Peaker: Graph reduction is a reasonably good mental model, to start with.
17:14:53 <A1kmm> Cale: I'm trying to sum over a big list... I think that would force the whole list to be kept in memory.
17:14:55 <Peaker> Cale: I find it really difficult to reason in my head about how graph reduction is going to behave in a large program.  I only have 1 year of Haskell-toying experience, barely any real work, though
17:16:03 <Cale> Peaker: Yeah, it takes some time before it really gets ingrained into the way you picture things.
17:16:54 <newsham> peaker: you're implying that the only reason to use lazy evaluation is because it increased convergence
17:17:01 <newsham> but do you really believe that?
17:17:08 <Cale> A1kmm: hmm, I suppose that's true, the contents of that list actually probably can't all fit in memory at once.
17:17:52 <vininim> How does one make cabal install profiling versions of a library?
17:18:26 <Peaker> newsham: I think it increases code-reuse in some (relatively rare, possibly) cases
17:18:43 <Cale> A1kmm: I imagine that the problem is that the work necessary to compute one element of the list is dwarfed by the scheduling cost of a spark.
17:19:52 * EvilTerran 's main reason for liking lazy evaluation is that infinite or partial data structures allow some very snazzy idioms
17:20:08 <newsham> *shrug* theres lots of reasons why lazy evaluation is attractive...
17:20:25 <Peaker> newsham: what are they?
17:20:29 <A1kmm> Cale: I guess there is a need for somehow combining chunking with only working to a certain distance ahead
17:20:45 <EvilTerran> i guess my reason follows from the increased convergence
17:20:46 <Peaker> EvilTerran: I like most the (take k . sort) example
17:20:47 <newsham> it provides a clean way to separate out parts of the code that are usually intertwined.
17:21:12 <newsham> in some cases it offers increased performance
17:21:38 <EvilTerran> maximising convergence of your evaluation strategy maximises the choice of correct, terminating code within a given syntax
17:22:03 <Peaker> newsham: yeah, though maybe lazy shouldn't be a default, I'm not sure
17:22:04 <newsham> et: peaker's argument that is if your languae is total, the convergence is the same
17:22:09 <EvilTerran> so allowing as many "snazzy idioms" as possible
17:22:16 <newsham> peaker: perhaps not..  I'm not gonna argue that because I dont know
17:22:44 <Cale> Peaker: If lazy isn't default, then you tend to get libraries with lots of strict functions which are less composable.
17:23:06 <EvilTerran> newsham, well, yeah... if my language is total, though, surely evaluation order is irrelevant to semantics
17:23:06 <Cale> (That is, strict, even though it would not hurt for them to be lazy)
17:24:17 <newsham> excellent troll, btw.  ;-)
17:24:24 <Peaker> Cale: Yeah, I guess lazy is the better default. The trade-off between composability and transparent operational semantics is problematic here. Maybe a smart code editor could make some of these operational semantics more apparent
17:24:43 <Peaker> EvilTerran: still affects operational semantics, though
17:25:14 <Cale> Peaker: Imagining that things are as composable in a lazy language as they are in a strict one is also probably one of the big things that leads to inefficient beginner imperative code (I'm willing to bet)
17:25:19 <EvilTerran> i mean, any expression would be arbitrarily strict (in every situation it's passed a _|_, ie never, it returns a _|_), *and* arbitrarily non-strict (it never returns a _|_)
17:25:19 <Peaker> I guess totality is a little over-rated, because a program that finishes after the universe dies is not that great
17:25:22 <Cale> er
17:25:33 <Cale> Swap strict and lazy in that sentence :)
17:26:24 <Peaker> Cale: Yeah, my first thoughts when introduced to laziness idioms in Haskell were: "I sometimes did that in imperative languages when I didn't care about performance, now it performs well too, cool!" :)
17:26:25 <Cale> Quite often, to get good performance out of strict code, you more or less have to tear library functions open and write them by hand.
17:26:56 <Cale> Imperative programmers do this so often that they don't even see it anymore.
17:27:17 <shapr> Yup
17:27:45 <Peaker> Cale: yeah, every piece of code could be said to be parameterized over a variety of things (functionality, programming language, strictness, ...) and thus we have a huge cartesian product body of code, when often there is a lot of code for the same functionality (due to various parameters being changed).  laziness eliminates one parameter from the cartesian product
17:28:39 <Peaker> I think having explicit file access in addition to a volatile memory store, rather than just one big persistent single-level store adds another parameter to this cartesian product (programs that work well over files, vs ones that are optimized to work "in memory")
17:29:08 <shapr> Personally, I think your point is strongly in favor of open source.
17:29:16 <shapr> And in favor of small simple naive functions that are easy to understand.
17:29:19 <Peaker> shapr: I agree
17:29:40 <shapr> Because I believe that source code should be tuned for ease of tearing apart.
17:29:57 <shapr> Thus, tuned for ease of understanding.
17:30:06 <Peaker> shapr: yeah, naive functions, sophisticated optimizers
17:30:12 <shapr> Exactly
17:30:13 <Cale> shapr: But it's also something that we should avoid the necessity of doing, as much as possible.
17:30:28 <shapr> I'm not convinced of that.
17:30:40 <Peaker> even better to be able to use rewrite rules to explain how the naive version becomes the sophisticated one, rather than just write the sophisticated one
17:31:15 <Peaker> shapr: if we can compose naive functions together, rather than duplicate them a bit differently, of course we should do that?
17:31:15 <Philippa> rewrite rules are far from the best possible way to do that
17:31:20 <Philippa> but yeah, they beat no tools at all
17:31:23 <shapr> I think that change will always be necessary, so it's best to make changes easy, as long as ability to understanding does not decrease.
17:31:30 <Peaker> Philippa: what are better ways to do that?
17:31:44 <Cale> Complicated programs are only made possible by abstractions that work. Abstractions are not doing their job if you have to get the source code and copy paste (or worse yet, write over again), then modify things a bit to get decent performance in your individual case.
17:32:03 <Cale> Higher order functions are one way to save a lot of trouble here, laziness goes a bit further.
17:32:08 <shapr> Yeah
17:32:08 <Philippa> Peaker: well, a best possible way would allow me to specify to do certain things in a given position, where they can't just be applied generally
17:32:14 <Peaker> shapr: I think the software world should mainly focus on eliminating parameters from this horrible cartesian product.  We now have so many in there.
17:32:22 <shapr> I can see the point of avoiding the necessity of tearing things apart.
17:32:36 <Peaker> Philippa: location-specific rewrite rules?
17:32:43 <shapr> But on the other hand, you can't future proof code except by making it easy to understand and modify for future needs.
17:33:00 <Philippa> it's also likely to be more capable of introspection than rewrite rules are
17:33:09 <shapr> What if memristors or quantum computing completely changes the face of computing?
17:33:26 <Peaker> Philippa: Runtime-applied rewrite rules?
17:33:28 <shapr> One reason UNIX beat VMS was that UNIX was easy to understand and port.
17:34:02 <Cale> A1kmm: what happens if you turn that parameter to parBuffer way way down, like to, say, your number of processors
17:34:08 <inimino> I think editor support for rewriting will help
17:34:18 <A1kmm> Cale: let me try that.
17:34:41 <Peaker> shapr: I don't see how the face of computing can be changed so badly that even extremely declarative programs (e.g FRP ones) would be affected.. they seem to me to be completely implementation-agnostic
17:34:47 <inimino> if you can see the naive code, the rules that optimize it, and the optimized code, along with assurances that they all give the same result, that would be worth a lot
17:34:47 <Peaker> inimino: yes!
17:35:00 <shapr> The extreme case of my point is that a language should not require libraries, you should be able to just make what you need without much trouble.
17:35:03 <Peaker> inimino: I think that's another strong point for a smart code editor
17:35:04 <Cale> A1kmm: at least then not as many sparks will be created
17:35:15 <Philippa> Peaker: no. Look, it's a damn huge research space, stop trying to get me to commit to an answer. Yours aren't the best possible either
17:35:15 <shapr> Peaker: Er, tried to build GHC on ARM?
17:35:27 <Cale> A1kmm: but the scheduling costs still might be too high, so you might really have to chunk things first.
17:35:47 <inimino> Peaker: yes, me too.
17:35:47 <Peaker> Philippa: I was trying to get you to clarify what you meant by "capable of introspection" -- doesn't it imply they're applied at runtime?
17:35:54 <shapr> g'day Pseudonym
17:35:55 <Philippa> Peaker: no, it doesn't
17:36:14 <Philippa> it just means that they can examine what they're looking at /including semantic properties determinable at compile-time/
17:36:16 <Peaker> Philippa: ah, so you mean the ability of the rewrite rule to dig deeper into the expressions?
17:36:22 <shapr> Peaker: FRP programs may be implementation agnostic, but GHC is not.
17:36:28 <Philippa> *argh*
17:37:29 <Peaker> shapr: yeah, but if you eliminate all of the possible factors from the cartesian product, you may end up with a body of user-level software that should survive any computing implementation revolution -- the systems-software would have to change, of course
17:37:32 <vininim> also, from the profiling info: not a good idea to use read inside a parser.
17:37:48 <Philippa> Peaker: there is more to rewriting than syntax, FFS
17:38:09 <Philippa> especially to rewriting /to achieve semantic aims/
17:38:49 <Peaker> Philippa: maybe you can work on your anger problem? Note I did just ask questions, not state any fact
17:39:26 <Cale> I wonder if it would be reasonable to introduce a standard system for expressing rewrite rules in Haskell programs, that is, one which could have a hope of being compiler-independent.
17:39:33 <Philippa> Peaker: not an appropriate response
17:39:46 <Cale> I suppose that if you want it to interact with things like inlining, the answer is no.
17:39:49 <Peaker> Philippa: Ok
17:40:17 <Peaker> shapr: I think if you eliminate the stuff from the product, you end up with a very small body of software that can do everything most desktops are used for.. (e.g: The STEPS project to write a desktop from ground up in 20KLOC)
17:40:52 <shapr> Of course, if that were true, perhaps microkernels would rule the world.
17:41:07 <Peaker> Philippa: what kind of semantic properties can you get at compile-time? Type information?
17:41:39 <shapr> I take the dominance of monolitich kernels (Linux) over microkernels (HURD) as a point in favor of Cale's side of the discussion.
17:41:42 <Philippa> Peaker: that's a starting point, yes
17:41:44 <Peaker> shapr: kernels are another unnecessary parameter in the cartesian product, IMO :)  Code inside kernel very different to user-code, but that isn't necessarily so, if you just use language-level protections instead
17:42:15 <Philippa> Peaker: congratulations, you just made the RTS the new kernel
17:42:27 <Peaker> Philippa: indeed, and its a much smaller one. Drivers are just libraries
17:42:31 <Cale> Yeah, I wonder why microkernels have failed. Has there ever been a microkernel which offered higher-order primitives?
17:42:53 <Peaker> Philippa: lack of memory separation may have very desirable properties, decreasing unnecessary copying and cache flushes
17:43:07 <p_l> Cale: Microkernels probably failed due to Mach :>
17:43:07 <shapr> Peaker: I'd want to see a running example before I'd believe that.
17:43:10 <Philippa> Peaker: you still need to write the RTS in something
17:43:32 <p_l> Peaker: Bell Labs' Inferno, Microsoft's Singularity
17:43:41 <p_l> damn, that was for shapr
17:44:11 <inimino> microkernels probably failed because of Linux
17:44:13 <p_l> shapr: those two use managed VM in place of normal memory separation
17:44:17 <Peaker> Philippa: Some of the RTS may need to use a lower-level language, and some of the libraries that it uses would have to be duplicated for it - so I still have a parameter in the cartesian product, but hopefully it applies to much less code (only the generic libraries the RTS code uses have to be duplicated differently)
17:45:00 <p_l> inimino: not really - there exist few successful micro/nanokernel systems, two of them having connection with Mach. Original Mach gave a very bad name to microkernels
17:45:21 <p_l> and L4/Linux actually managed to beat linux in terms of performance on Arm
17:45:43 <inimino> p_l: partly tongue-in-cheek
17:45:59 <inimino> p_l: I think they failed by a historical accident, of which Linux is certainly a part... it's just too hard to turn everything on its head at this point
17:46:08 <p_l> inimino: Mach truly sucked :P
17:46:10 <Peaker> I think the correct transition to language-level protections, though, may be after we have dependent types
17:46:43 <inimino> Peaker: so you're a fan of Oberon?
17:46:51 <Peaker> inimino: what's that?
17:46:58 <p_l> inimino: there are two (known to me), Mach-based systems that managed to get far enough. Both had decided to run their servers inside kernel mode, afaik
17:47:43 <inimino> it's an OS written in Modula-3 IIRC
17:47:51 <p_l> one was OSF/1, at least DEC's version. The other one is OS X
17:47:56 <p_l> inimino: it's written in Oberon :)
17:48:05 <inimino> oh, ok
17:48:07 <A1kmm> cale: 7m34.100s with 10 processors, and a look-ahead of 10.
17:48:10 <sclv_> I was about to say...
17:48:15 <Peaker> inimino: sounds like it could be nice, but there are tons of things that need to be right as well
17:48:15 <inimino> it's been a while since I read those papers, sorry ;-)
17:48:23 <p_l> inimino: and for some reason doesn't have preemptive scheduler
17:49:12 <inimino> well it was written in some ridiculously small number of lines of code
17:50:33 <sw17ch> can some one tell me why these view patterns overlap?
17:50:33 <lambdabot> sw17ch: You have 1 new message. '/msg lambdabot @messages' to read it.
17:50:34 <sw17ch> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5478#a5478
17:52:00 <sw17ch> it's my first foray into view patterns and i don't see why they overlap
17:55:29 <sw17ch> ah: http://hackage.haskell.org/trac/ghc/ticket/2395
17:57:19 <vininim> um, (atto)parsec might not be the best choice for parsing
17:57:42 <vininim> also, nifty parsecing:
17:58:34 <vininim> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5479#a5479
17:59:24 <shapr> Oberon is really nifty.
18:01:28 <mmorrow> sw17ch!
18:01:28 <lambdabot> mmorrow: You have 1 new message. '/msg lambdabot @messages' to read it.
18:01:35 <sw17ch> mmorrow!
18:01:43 <mmorrow> sw17ch: :)
18:33:46 <keseldude> > let (+) x y = succ . sum $ [x,y] in 2 + 2
18:33:51 <lambdabot>   mueval-core: Prelude.read: no parse
18:33:51 <lambdabot>  mueval: ExitFailure 1
18:35:11 <mmorrow> > let (+) x y = succ . sum $ [x,y] in 2 + 2
18:35:14 <lambdabot>   5
18:35:19 <mmorrow> weird
18:37:36 <psygnisfive> why weird?
18:38:25 <sm> evening all
18:38:43 <mmorrow> it failed for unknown reasons when keseldude tried
18:38:50 <mmorrow> evening
18:39:42 <psygnisfive> oh, so it did
18:39:59 <psygnisfive> magic!
18:40:53 <aavogt> quite the referentially transparent lambdabot
18:43:20 <jbauman> > let (+) x y = succ . sum $ [x,y] in 2 + 2
18:43:23 <lambdabot>   5
18:43:41 <vininim> >   let (+) x y = succ . sum $ [x,y] in 2 + 2
18:43:43 <lambdabot>   5
19:03:30 <gwern> aavogt: every evaluated expression in lambdabot is in a race condition
19:03:47 <gwern> so it's not surprising that the same eval can have different results at different times
19:05:12 <Twey> gwern: *wince*
19:05:45 <gwern> in an irc channel of infallible angels, that needn't be the case. but alas, we are only men and mortals
19:06:27 <gwern> (specifcally, the expressions are racing to be evaluated before either the watchdog thread or process kill mueval)
19:06:56 <kpreid> and the watchdog says "no parse"?
19:07:21 <gwern> the internals are a bit odd. I could see that being an error message
19:17:15 <aconbere> anyone know anything about using edgeflags in hopengl?
19:17:32 <sclv_> gwern: or before a netsplit hoses the reply :-)
19:20:53 <joaopizani> Good evening everyone. I'd llike some advice on using the Data.Graph module
19:21:23 <joaopizani> I've read the official haddock for the module, and haven't found a way to have a label on the graph's edges
19:21:43 <joaopizani> Do you know of some way to label the edges of a Data.Graph?
19:24:17 <joaopizani> I'm working on a project that involves the manipulation and visualization of finite automata, regular expressions and context-free grammars
19:25:01 <joaopizani> My plan is to use the Haskell GraphViz binding for the visualization part, but the toGraphviz function requires a Data.Graph as input
19:25:31 <joaopizani> and I want to have the input symbols displayed above the arrows
19:33:02 <aavogt> > fix (+1)
19:33:07 <lambdabot>   mueval-core: Prelude.read: no parse
19:33:07 <lambdabot>  mueval: ExitFailure 1
19:33:46 <aavogt> gwern: so it seems. I consider that a terrible error message
19:34:06 * gwern shrugs
19:34:17 <Gracenotes> that usually means a stack overflow
19:34:23 <gwern> mueval has bigger fish to fry; I'd like to run on windows, for example
19:34:29 <Gracenotes> could also be an overflow issue
19:34:40 <Gracenotes> like, as in heap
19:35:06 <gwern> Gracenotes:  as in, the expression has heap big problem?
19:41:29 <ctran> how close can haskell get to C for this problem? http://www.codechef.com/problems/FCTRL/
19:43:29 <ctran> any help?
19:43:33 <dmwit> ?tell joaopizani I don't know of a way to use Data.Graph for edge-labelled graphs, unfortunately.  However, with the GraphViz module you can build the graph description yourself, in which case edge-labellings are Totally Plausible.
19:43:33 <lambdabot> Consider it noted.
19:43:48 <dmwit> Why would you want to be close to C?
19:44:02 <ctran> just learning to write better haskell
19:44:18 <dmwit> Good Haskell is not close to C; it's not even close to good C.
19:44:44 <monochrom> What is "close"?
19:44:49 <ctran> anything I can do to improve http://gist.github.com/121948
19:45:45 <inimino> why wouldn't you want to be close to C?
19:45:48 <ctran> close in term of speed/efficiency
19:45:52 <inimino> assuming he meant performance
19:46:02 <dmwit> Oh, for performance.
19:46:12 <dmwit> I thought he meant code that looked like C.
19:46:17 <ctran> sorry i should have been more clearer
19:46:58 <MyCatVerbs> You can write code that looks roughly like Pascal, without excessive difficulty.
19:47:35 <MyCatVerbs> C is harder, because writing a DSL that gives you lvalues is awkward, but I think it's been done. Can't remember who did it, though.
19:48:31 <dmwit> > iterate (`div` 5) 625
19:48:31 <dibblego> are ap and (<*>) for ((->) t) the same function with arguments flipped about?
19:48:36 <lambdabot>   mueval-core: Prelude.read: no parse
19:48:36 <lambdabot>  mueval: ExitFailure 1
19:48:38 <dibblego> er, ep and (>>=)
19:48:42 <dibblego> er, ap and (>>=)
19:48:49 <dmwit> no parse?
19:48:56 <dmwit> dibblego: ap and (>>=) are not the same
19:48:58 <Gracenotes> ap is (=<<) . flip
19:49:08 <Gracenotes> (=<<) is ap . flip
19:49:08 <dibblego> not the same for the general case
19:49:13 <Gracenotes> for (->)
19:49:14 <dmwit> :t ap
19:49:19 <dibblego> Gracenotes, just checking, thanks
19:49:26 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
19:50:10 <dmwit> ctran: You might like "iterate (`div` 5)".
19:50:27 <Gracenotes> > ((,) =<< length) "hello"
19:50:31 <Gracenotes> > ((,) <*> length) "hello"
19:50:33 <lambdabot>   mueval-core: Prelude.read: no parse
19:50:33 <lambdabot>  mueval: ExitFailure 1
19:50:37 <Gracenotes> lols.
19:50:37 <lambdabot>   mueval-core: Prelude.read: no parse
19:50:37 <lambdabot>  mueval: ExitFailure 1
19:50:59 <Gracenotes> (5,")
19:51:06 <dmwit> ctran: print = putStrLn . show
19:51:09 <BMeph> MyCatVerbs: Our resident maker-of-interpreters-of-other-lamguages, of course - augustss. :)
19:51:11 <Gracenotes> ahem. (5, "hello") and ("hello", 5)
19:51:30 <MyCatVerbs> BMeph: ah! I knew it was somebody who frequents here, but couldn't quite remember. Thank you.
19:51:31 <dmwit> :t maybe (putStrLn "error") (print . fst)
19:51:40 <Gracenotes> >:[
19:51:43 <lambdabot> forall a b. (Show a) => Maybe (a, b) -> IO ()
19:52:10 <dmwit> :t \fcntrl -> maybe (putStrLn "error") (print . fcntrl . fst)
19:52:17 <lambdabot> forall c a b. (Show c) => (a -> c) -> Maybe (a, b) -> IO ()
19:52:41 <dmwit> ctran: You have way too much code. ;-)
19:53:18 <dmwit> :t \f -> interact (unlines . f . lines)
19:53:19 <ctran> dmwit: sorry :-)
19:53:25 <lambdabot> ([String] -> [String]) -> IO ()
19:53:57 <ctran> dmwit: it will get shorter in a year, I hope
19:54:02 <dmwit> :t \fcntrl -> interact (unlines . map (show . fcntrl . read) . lines)
19:54:03 <BMeph> showIntAtBase 5, maybe? :)
19:54:11 <lambdabot> forall b c. (Show c, Read b) => (b -> c) -> IO ()
19:56:52 <dmwit> ctran: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5480#a5480
19:57:13 <dmwit> Oops, didn't notice the "tail" right before C.lines in your paste.
19:57:19 <dmwit> whatever
19:57:35 <ctran> no problem
19:57:56 <dmwit> It shouldn't be hard to adapt to ByteString if you actually find out that the IO is a performance bottleneck.
19:58:23 <ctran> wow, your version is the exact reason I want to learn haskell
19:58:56 <centrinia> > (\b x -> snd $ until ((==0) . fst) (\(a,b) -> id *** (:b) $ (a `divMod` b)) (x,[])) 10 12341
19:59:02 <lambdabot>   mueval-core: Prelude.read: no parse
19:59:02 <lambdabot>  mueval: ExitFailure 1
19:59:09 <gwern> hm, takeWhile >0 . drop 1 looks suspicious to me
19:59:23 <dmwit> centrinia: \bot seems to have acid reflux for now
19:59:32 <dmwit> gwern: Nonsense, they operate on two different ends of the list.
19:59:58 <dmwit> gwern: The alternative is
20:00:08 <dmwit> sum . takeWhile (>0) . iterate (`div` 5) . (`div` 5)
20:00:13 <dmwit> which is even more suspicious.
20:03:20 <ctran> dmwit: is there a function to turn Int -> ByteString ?
20:03:36 <dmwit> oh, uh... dunno
20:03:45 <dmwit> I'd be awful surprised if the answer was no.
20:03:49 <dmwit> ?hoogle Int -> ByteString
20:03:50 <lambdabot> Data.ByteString.Internal unsafeCreate :: Int -> (Ptr Word8 -> IO ()) -> ByteString
20:03:50 <lambdabot> Data.ByteString replicate :: Int -> Word8 -> ByteString
20:03:50 <lambdabot> Data.ByteString.Char8 replicate :: Int -> Char -> ByteString
20:03:57 <dmwit> ?hoogle+
20:03:57 <lambdabot> Data.ByteString drop :: Int -> ByteString -> ByteString
20:03:57 <lambdabot> Data.ByteString take :: Int -> ByteString -> ByteString
20:03:57 <lambdabot> Data.ByteString.Char8 drop :: Int -> ByteString -> ByteString
20:04:01 <dmwit> bleh
20:04:44 <dmwit> I sure don't see one.
20:05:07 <dmwit> pack . show ;-)
20:07:57 <mgsloan> ?hoogle Integer -> ByteString
20:07:57 <lambdabot> Data.ByteString unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
20:07:58 <lambdabot> Data.ByteString.Lazy unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
20:07:58 <lambdabot> Data.ByteString.Char8 unfoldr :: (a -> Maybe (Char, a)) -> a -> ByteString
20:08:10 <mgsloan> hrmm
20:08:56 <ctran> thanks everyone, i have enough ideas to play with for now
20:51:01 <Reiv> Hrm
20:51:19 <Reiv> http://pastebin.com/dfd19651 - I've got brackets working. Now I need to get identifiers (variables) readable.
20:51:26 <Reiv> My problem here is that they're fairly arbitary. :/
20:59:20 <Reiv> So I'm just a little unsure how to implement it...
21:01:20 <jaredj> do { openTag "CHECKNUM"; TagText checkNumber <- anyToken; return checkNumber }
21:01:27 <jaredj> is there a way to do that with >>=?
21:01:39 <jaredj> (particularly: the pattern match)
21:02:06 <jaredj> without a lambda?
21:02:08 <BMeph> jaredj: "You're soaking in it." ;p
21:03:27 <Twey> jaredj: If you create a deconstructing function, sure
21:03:52 <jaredj> like \TagText x -> x
21:04:02 <Twey> That's a lambda
21:04:10 <jaredj> yes
21:04:19 <Twey> openTag "CHECKNUM" >> anyToken >>= return . deTagText
21:04:30 <Twey> where deTagText (TagText x) = x
21:06:36 <jaredj> yes - i wasn't sure if you could get around making one of those
21:06:57 <jaredj> i should have asked if there was a simpler way to do that do-construct
21:07:25 <jaredj> BMeph: i had to everything2 your quote ;P
21:15:37 <MyCatVerbs> comonad.com is edwardk, right?
21:16:17 <MyCatVerbs> Oh right yes, he prints his name on the blog posts. Hah, I probably should not have missed that. :)
21:17:30 <Reiv> Huh.
21:17:41 <Reiv> Hi, MCV!
21:18:07 <MyCatVerbs> Greetings, Reiver. Nice to see a few nightstar denizens around.
21:18:20 <Reiv> Oh, aye.
21:18:33 <Reiv> #Code is a wonderful resource, but sometimes you just can't beat the source. ;)
21:18:51 <MyCatVerbs> I'm vaguely surprised that McMartin doesn't idle in here too.
21:18:54 * p_l looks outside, sees light
21:19:18 * copumpkin looks outside, sees darkness
21:19:26 <copumpkin> can darkness be seen?
21:19:34 <p_l> nope
21:19:52 <p_l> well, not physically, I guess. Languages don't care
21:20:41 <monochrom> can non-termination be observed? :)
21:21:35 <MyCatVerbs> Reiv: I guess not. On the flip side, you get a lot more newbie questions in here, and answering those is pretty decent karma. :)
21:21:37 <psygnisfive> monochrom: by a hyperturing machine, sure!
21:21:50 <monochrom> hehe
21:21:58 <MyCatVerbs> Can that machine's failure to terminate be observed?
21:22:15 <monochrom> I wonder if darkness is analogous to non-termination.
21:22:19 <psygnisfive> i dont know if hyperturing machines have those same constraints
21:22:21 <mmorrow_> what's the definition of "observe" (in the CS sense)?
21:22:27 <psygnisfive> monochrom: what? no. what?
21:22:33 <MyCatVerbs> Actually, non-termination is easy. You know that scene with Arnold and the minigun, where he shoots up an entire parking lot and deliberately kills no-one? Yeah, that.
21:22:46 <monochrom> hahahahaha
21:22:57 <psygnisfive> how would darkness be analogous to non-termination?
21:22:58 <mmorrow_> MyCatVerbs: but only TERMINATors can do that
21:23:21 <monochrom> That's what "I wonder if" means. I don't know.
21:23:30 <MyCatVerbs> mmorrow_: Oh, it's a bugger to pull off, sure. But watching it isn't challenging.
21:23:35 <psygnisfive> .. no. its not analogous at all.
21:23:40 <hackagebot> urlencoded 0.2.0.0
21:23:40 <psygnisfive> darkness is analogous to an empty list.
21:23:47 * mmorrow_ googles the CS definition of "observe"
21:23:48 <psygnisfive> or the emptiness of the list.
21:23:54 <monochrom> Hey I can take advantage of people failing to read and succeeding in getting fully surprised!
21:24:02 <monochrom> I wonder if P=NP.
21:24:08 <monochrom> I wonder if P/=NP
21:24:26 <MyCatVerbs> monochrom: I hope not, and I hope not, respectively.
21:24:27 <psygnisfive> i suspect P=NP.
21:24:43 <monochrom> I wonder if Haskell is untyped.
21:24:52 <psygnisfive> well, actually, maybe not
21:24:57 <psygnisfive> travelling salesman is i think NP
21:25:11 <psygnisfive> and i dont think theres any conceivable deterministic way to computer travelling salesman
21:25:12 <MyCatVerbs> On the one hand, P=NP breaks pretty much all reasonable crypto you could come up with. On the other hand, P/=NP means that lots of useful problems can't be completely solved. :/
21:25:15 <psygnisfive> but i could be wrong!
21:25:18 <mmorrow_> so is (the general case of) graph coloring
21:25:33 <psygnisfive> can someone explain the state monad to be?
21:25:46 <mmorrow_> traveling salesman is one of the NP poster-boys
21:25:47 <dmwit> Yes!
21:25:48 <psygnisfive> i mean, i dont understand monads in general but thats ok
21:25:54 <dmwit> ?go you could have invented monads
21:25:55 <lambdabot> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
21:25:55 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ...
21:26:03 <dmwit> also
21:26:25 <dmwit> ?where all about monads
21:26:26 <lambdabot> I know nothing about all.
21:26:28 <psygnisfive> see, i figure that like
21:26:30 <dmwit> http://www.haskell.org/all_about_monads/html/index.html
21:26:41 <psygnisfive> you can sythesize state
21:26:53 <MyCatVerbs> Isn't even 3-colouring NP-complete?
21:26:59 <monochrom> Anyway, I use "observe" in the physics sense. I don't think there is a widely adopted CS sense.
21:27:09 <psygnisfive> by passing around a hash of varname-varvalue pairs that gets mapped in each iteration
21:27:12 <psygnisfive> you know what i mean?
21:27:39 <dmwit> psygnisfive: Yep.  The idea of the State monad is to pass those things for you.
21:27:46 <dmwit> psygnisfive: Also, typically, instead of a hash, we use a record.
21:27:52 <mmorrow_> hmm, it look like "observe" isn't formally defined (wrt CS), it's just in various "you know, like looking" ways (?)
21:27:53 <dmwit> So no hashing, just access the data you want.
21:27:55 <psygnisfive> well see dmwit, problem i see with that is that
21:28:04 <mmorrow_> *it's just used in ...
21:28:05 <psygnisfive> thats effectively precisely what reassignable variables are.
21:28:14 <dmwit> mmorrow_: Well, there's barbs as in the pi-calculus.
21:28:23 <dmwit> mmorrow_: And there's contextual equivalence for functional calculi.
21:28:25 <mmorrow_> dmwit: what is that?
21:28:35 <psygnisfive> actually, reassignable variables are also i guess like nested lets
21:28:40 <mmorrow_> i'm looking for the definition of "observe"
21:28:42 <dmwit> mmorrow_: A barb is a process offering to send on a named channel, where the name is free.
21:28:45 <psygnisfive> or lambdas
21:29:03 <dmwit> mmorrow_: So "observation" involves what channels with free names are offering to send.
21:29:04 <psygnisfive> let x = 5 in (let x = x*x in x)
21:29:13 <mmorrow_> i don't see how terms can be used without definitions, so i feel like it has to be defined somewhere
21:29:15 <psygnisfive> i dont know if that precisely will work in haskell, but you can convert it down to lambdas and get the same
21:29:32 <dmwit> mmorrow_: Similarly, for typed calculi, observation involves putting the thing you're observing into arbitrary contexts.
21:29:44 <dmwit> mmorrow: Terms that converge or diverge together in all contexts are observationally equivalent.
21:29:54 <copumpkin> psygnisfive: that's how people often implement tight loops
21:30:01 <psygnisfive> tight loops?
21:30:23 <monochrom> let x = 0:x in x
21:30:33 <monochrom> In general, let x = ...x... in x
21:30:43 <copumpkin> oh, I was talking about low-level unboxage
21:30:44 <psygnisfive> i dont follow but ok :D
21:30:46 <dmwit> > let x = 5 in let y = x * x in y
21:30:49 <monochrom> oops
21:30:50 <lambdabot>   25
21:30:57 <dmwit> > let x = 5 in let x = x * x in x -- diverges
21:31:02 <lambdabot>   mueval-core: Prelude.read: no parse
21:31:02 <lambdabot>  mueval: ExitFailure 1
21:31:41 <dmwit> > do { x <- ask; x <- return (x * x); return x } 5
21:31:44 <lambdabot>   <no location info>: parse error on input `5'
21:31:49 <dmwit> > do { x <- ask; x <- return (x * x); return x } $ 5
21:31:51 <lambdabot>   25
21:32:14 <dmwit> psygnisfive: We can do imperative stuff just fine in this language. ;-)
21:32:38 <psygnisfive> dmwit: well, im just more curious about why multiple assignment variables are right out.
21:32:44 <MyCatVerbs> Indeed. We have a pretty good term algebra over imperative things. :)
21:32:48 <psygnisfive> i mean, granted, i think think i use them in functional code, but still!
21:33:06 <monochrom> shadowing
21:33:16 <MyCatVerbs> > do { a <- "aaa"; a <- "bbb"; return a; }
21:33:18 <lambdabot>   "bbbbbbbbb"
21:33:20 <dmwit> psygnisfive: Multiple-assignment variables are right out because we want referential transparency to hold.
21:33:42 <MyCatVerbs> Multiple assignment in any given do-block works just fine, inasmuch as it just results in name shadowing.
21:33:46 <dmwit> If you have multiple-assignment, then there is a period between the two assignments when calls will return strange things.
21:33:48 <monochrom> lexical scope. you search from inside out for the variable you need.
21:34:04 <MyCatVerbs> > do { a <- "aaa"; a <- a:"b"; return a; }
21:34:09 <lambdabot>   "ababab"
21:34:11 <psygnisfive> dmwit: and it does hold. multiple assignments would just be alternate notation for lets.
21:34:16 <dmwit> To be more specific: calls between the two assignments and calls after the two assignments will not return the same thing.
21:34:29 <psygnisfive> i mean
21:34:32 <MyCatVerbs> It's merely discouraged, because most people find name shadowing confusing.
21:34:33 <copumpkin> psygnisfive: we already get that
21:34:59 <copumpkin> psygnisfive: it's what MyCatVerbs just did
21:35:03 <psygnisfive> so theres no referential transparency issue.
21:35:06 <MyCatVerbs> i.e. I do, and everybody dumbs down their code for the sake of poor stupid ol' me. :)
21:35:24 <monochrom> do-notation is de-sugared to lots of lambda's. It will make sense there.
21:35:25 <MyCatVerbs> psygnisfive: yes and no. If it was implemented in terms of mutable variables then yes there would be.
21:35:26 <psygnisfive> not that i have any clue what the hell happened to that "bbbbbbbbb" example but
21:35:30 * copumpkin secretly resents MyCatVerbs' stupidity
21:35:35 <copumpkin> oh crap, I just wrote that "out loud"
21:35:41 <MyCatVerbs> psygnisfive: how it's actually implemented is more like SSA.
21:35:56 <timmaxw> psygnisfive: i think it has to do with how the List monad works.
21:35:57 * Twey adds extra shadowing to every function just to befuddle MyCatVerbs
21:36:12 <dmwit> psygnisfive: Conceptually, we want to be able to reason about declarations.  The order of the code shouldn't matter so much.
21:36:16 <psygnisfive> oh, is that mapping each "a" to "bbb"?
21:36:17 <psygnisfive> i see.
21:36:18 <dmwit> psygnisfive: Allowing multiple assignment threatens that.
21:36:19 <monochrom> > let 2+2=5 in 2+2
21:36:23 <lambdabot>   5
21:36:35 <monochrom> (The most famous example of shadowing.)
21:36:37 <psygnisfive> dmwit: but order = nesting, in a letted thing.
21:36:43 <MyCatVerbs> When I replaced (a) with (a:"b") in that example above, really it was making a new binding with the same name as a.
21:36:43 <psygnisfive> i suppose just like it does in do {}
21:36:44 <dmwit> psygnisfive: As it is, pattern-matching introduces a small threat to this, but we tolerate it because all the clauses are guaranteed to be right next to each other.
21:36:54 <timmaxw> > let True=False in True
21:36:58 <lambdabot>   True
21:37:00 <dmwit> psygnisfive: Sure, and if you want nested multiple assignment, we provide it with "where".
21:37:03 <ray> > let 2+2=5 in 3+3
21:37:09 <lambdabot>   mueval-core: Prelude.read: no parse
21:37:09 <lambdabot>  mueval: ExitFailure 1
21:37:13 <ray> non-exhaustive patterns!
21:37:22 <ray> or not that, but related
21:37:26 <MyCatVerbs> ray: n+k patterns are evil. :)
21:37:32 <timmaxw> Why did "let 2+2=5" work?
21:37:35 <MyCatVerbs> ray: and/or unclean.
21:37:40 <ray> where's the n+k pattern
21:37:41 <copumpkin> it redefined (+)
21:37:46 <ray> STOP SPLITTING FREENODE
21:37:47 <copumpkin> ugh
21:37:54 <monochrom> It is non-exhaustive pattern, not n+k pattern.
21:38:05 <MyCatVerbs> > do { a <- "aaa"; a <- ord a : []; return (a+1); }
21:38:05 <dmwit> timmaxw: let (+) = \a b -> case (a, b) of (2, 2) -> 5 in 3 + 3
21:38:10 <lambdabot>   [98,98,98]
21:38:15 <timmaxw> yes, clever
21:38:20 <ray> non-exhaustive doesn't seem like quite the right way to put it since it's in a let
21:38:22 <MyCatVerbs> Hee. The old and new bindings don't even have to have the same type.
21:38:23 <psygnisfive> ray: its not just freenode splitting, interestingly
21:38:31 <psygnisfive> my chat clients are dying too
21:38:40 <dmwit> ray: What does let have to do with it?
21:38:49 <dmwit> > let 2+2 = 5; 3+3 = 7 in 3+3
21:38:53 <timmaxw> why are functional dependencies necessary in multiparameter type classes?
21:38:55 <lambdabot>   7
21:39:01 <ray> that's what
21:39:05 <monochrom> "let" doesn't change anything.
21:39:07 <dmwit> timmaxw: They're not.
21:39:27 <dmwit> timmaxw: They're useful because they help pin down instances for inference, but they're definitely not necessary.
21:39:34 <timmaxw> so the "Mult" example with matrices and vectors that I see in every tutorial on them, doesn't actually need them?
21:39:57 <monochrom> I mean, it's "let" and it's still non-exhaustive pattern. You could have defined your + with exhaustive patterns, under "let".
21:39:59 <dmwit> No; with type-annotations sprinkled around, those same examples would work without the functional dependencies.
21:40:01 <mmorrow> whoa, everyone just split, returned, and then 20 lines of conversation all appeared in one big scroll
21:40:07 <ray> > let (+) = const in 2+2
21:40:10 <psygnisfive> ok i need to be off to do some coding. :P
21:40:12 <MyCatVerbs> timmaxw: All that happens if you don't have them is that you wind up needing more type declarations in funny places.
21:40:13 <lambdabot>   mueval-core: Prelude.read: no parse
21:40:13 <lambdabot>  mueval: ExitFailure 1
21:40:16 <psygnisfive> afk.
21:40:17 * mmorrow was starting to think he was disconnected
21:40:47 <timmaxw> suppose that we define class Mult a b c where (*) :: a -> b -> c
21:41:03 <timmaxw> and define an instance where (*) :: Matrix -> Matrix -> Matrix
21:41:09 <lament> mmorrow: it's not you, it's the rest of the universe.
21:41:17 <mmorrow> lament: i knew it!
21:41:22 <timmaxw> shouldn't the compiler be able to tell that if m1,m2::Matrix, then (m1*m2)::Matrix?
21:41:29 <dmwit> timmaxw: nope
21:41:33 <timmaxw> why not?
21:41:40 <dmwit> timmaxw: Nothing is stopping you from declaring an instance later for  Mult Matrix Matrix Vector.
21:41:53 <timmaxw> why can't the compiler look for that?
21:41:56 <dmwit> timmaxw: Nothing, that is, except functional dependencies. =)
21:42:04 <dmwit> timmaxw: separate compilation
21:42:11 <dmwit> timmaxw: The instance might be in another file.
21:42:51 <timmaxw> doesn't the compiler detect duplicate instances even if they are in separate files? or no?
21:43:09 <monochrom> > let { 0+n=n; (m+1)+n = succ(m+n) } in 2+2  {- this one will cause a flame war -}
21:43:15 <lambdabot>   mueval-core: Prelude.read: no parse
21:43:15 <lambdabot>  mueval: ExitFailure 1
21:43:21 <ray> what if it's linked in at runtime
21:43:22 <monochrom> Hrm!
21:44:26 <dmwit> timmaxw: It does detect multiple instances, yes.
21:44:46 <timmaxw> dmwit: but the instance might be in another file...
21:44:52 <dmwit> Yes, I know.
21:44:59 <dmwit> I'm not totally sure what's going on here.
21:45:03 <monochrom> It works in GHC.
21:45:06 <dmwit> (I knew at one point...)
21:45:06 <ray> your head a splode
21:46:32 <mmorrow> squirting brain goo all over the room like a loose fire hose
21:48:08 <dmwit> timmaxw: Aha, I got it.
21:48:16 <dmwit> ...I lied.
21:48:54 <dmwit> No, I do have it.
21:49:02 <dmwit> timmaxw: Constraints can only mention  type variables.
21:49:13 <dmwit> timmaxw: So (Mult Matrix Matrix c) is not a valid constraint.
21:49:55 <timmaxw> dmwit: ah... but i'm not sure how functional dependencies solves that... let me think on it a bit
21:49:56 <dmwit> bah, FlexibleContexts is for exactly that
21:50:31 <dmwit> Well, functional dependencies let us say, "when we know a and b, then we know c", so we don't need a constraint that looks like that.
21:50:44 <dmwit> We know a and b, so conceptually we should know c.
21:50:48 <timmaxw> dmwit: suppose we define Mult with a functional dependency
21:51:01 <timmaxw> dmwit: then what would the constraint look like on (m1*m2) where m1,m2::Matrix?
21:51:50 <dmwit> It would likely either complain (if there were no instance for Matrix Matrix c), or simply choose the type c (if there is an instance Matrix Matrix c).
21:52:12 <dmwit> But I am so unsure of this.
21:52:28 <dmwit> I am a type-system newbie myself. =P
21:52:35 <timmaxw> dmwit: But if there's an instance (Mult Matrix Matrix Matrix) and Mult is defined with a functional dependency, then it chooses the type Matrix. I think.
21:52:44 <dmwit> right
21:53:01 <dmwit> If you substitute "Matrix" for "c" in the sentence above, that's exactly what I predict.
21:53:28 <dmwit> But more importantly, if you then try to add an instance Matrix Matrix Int, it will complain loudly.
21:53:33 <timmaxw> dmwit: It chooses Matrix by searching through the known instances of Mult and looking for one of the form (Mult Matrix Matrix <something>)
21:53:41 <dmwit> I... think so.
21:53:52 <timmaxw> dmwit: why does it need the functional dependency to make that decision?
21:54:02 <bogner> is there magic involved in turning [a] into tring, when inferring types?
21:54:14 <bogner> s/tring/String/
21:54:14 <dmwit> timmaxw: That is the bit I don't know.
21:54:26 <dmwit> bogner: type String = [Char]
21:54:30 <rick_2047> ls
21:55:20 <dmwit> bogner: Other than the usual unification, no magic, I think.
21:55:29 <bogner> dmwit: I realize that, but if I create data Foo = Foo String, I end up getting issues with couldn't match expected type [b] against inferred type Foo
21:55:39 <bogner> when trying to use concatMap
21:55:52 <dibblego> bogner, data and type do different things
21:55:53 <dmwit> bogner: But Foo doesn't unify with [b].
21:56:11 <bogner> how can I make it unify with [b]?
21:56:18 <timmaxw> bogner: if you want Foo and String to be the same thing, you need "type Foo = String"
21:56:31 <dibblego> data Foo = Foo { foo :: String } -- the use Foo and foo to wrap/unwrap
21:56:55 <bogner> timmaxw, dibblego: then it doesn't have a distinct identity, so I can't make useful instances of classes
21:57:00 <monochrom> (There is no Matrix.)
21:57:10 <bogner> dibblego: that might do it
21:57:13 <dibblego> bogner, sure you can, instance Monoid Foo where ...
21:57:31 <bogner> dibblego: I meant in the type Foo = String case
21:57:36 <dmwit> dibblego: I think he was complaining about your earlier "type" suggestion, not your later "data" suggestion. =)
21:57:47 <bogner> dmwit: thanks for clearing that up
21:57:51 <dibblego> I didn't suggest type
21:57:59 <dmwit> bogner: Also, if you're using this *only* to trick the type-system into thinking there's two types when really there's only String, then may I suggest newtype?
21:58:32 <bogner> dmwit: using newtype didn't seem to fix the unifying thing, perhaps I'm misunderstanding how to use it?
21:58:34 <dmwit> bogner: You use it exactly the same way, but save one indirection on each use.
21:58:43 <dmwit> bogner: (i.e. exactly the same way as data)
21:58:44 <dibblego> bogner, replace data with newtype
21:59:12 <monochrom> newtype Foo = FooConstructor String
21:59:20 <dmwit> bogner: Yes, you still have to manually wrap and unwrap it.
21:59:41 <dmwit> bogner: The only difference is that wrapping and unwrapping get optimized away for newtypes, but not for data types.
21:59:42 <bogner> dmwit: how do I unwrap it, then?
21:59:49 <bogner> for a newtype
21:59:57 <monochrom> pattern-matching
21:59:59 <dmwit> newtype Foo = Foo { unFoo :: String } -- exact same way
22:00:01 <dibblego> newtype Foo = Fo o { foo :: String }
22:00:04 <dmwit> Pattern-matching works, too.
22:00:07 <monochrom> f (FooConstructor s) = s
22:00:25 <bogner> oh, cool, I didn't realize that record syntax would work there
22:00:28 <bogner> awesome
22:00:32 <bogner> thanks guys
22:00:34 <dibblego> foo :: Foo -> String
22:00:40 <dibblego> Foo :: String -> Foo
22:01:10 <timmaxw> regarding the difference between newtype and data: it looks to me like the only difference between newtype and data-with-one-constructor is in the way they are implemented at runtime
22:01:13 <timmaxw> right?
22:01:16 <dmwit> newtype X = X X -- try it at home, kids!
22:01:30 <dibblego> timmaxw, bottoms matter
22:02:08 <timmaxw> dibblego: good point.
22:02:40 <dmwit> (Constructor undefined) -- actually undefined for newtype, a wrapped-up undefined for data
22:03:09 <leimy_> I need to convert Word16 to Int or Int64
22:03:10 <cads> eexcellent, I can  (defmacro λ ....)
22:03:18 <leimy_> what's the easy way to do that?
22:03:18 <dmwit> :t fromIntegral
22:03:27 <lambdabot> forall a b. (Integral a, Num b) => a -> b
22:03:39 <leimy_> clever
22:03:41 <leimy_> :-)
22:03:44 <dmwit> =)
22:03:50 <leimy_> I don't know why I always forget that :-)
22:03:54 <cads> ,(λ [x] (* x x))
22:03:58 <lunabot>  luna: Not in scope: `ۧ
22:04:18 <timmaxw> dibblego, dmwit: is that behavior particularly useful?
22:04:27 <dmwit> timmaxw: Nope, just something to watch out for.
22:05:09 <timmaxw> dmwit: then why does newtype exist at all? why not just say that the compiler "should" optimize instances of data with a single declaration?
22:05:31 <dmwit> Because they behave differently.
22:05:37 <leimy_> Data.Binary is telling me: too few bytes. Failed reading at byte position 20
22:05:46 <leimy_> but I'm telling it to read 19 bytes :-)
22:05:47 <dmwit> You can't optimize them just because you *think* people are going to use them in a way that doesn't break the optimization.
22:05:48 <leimy_> so I'm confused :-)
22:06:07 <timmaxw> dmwit: are there any differences other than the behavior around _/_ and the runtime implementation?
22:06:19 <dmwit> Nope.
22:06:24 <dmwit> But _ is a useful value at runtime.
22:06:26 <dmwit> We use it all the time.
22:06:41 <timmaxw> and the behavior around _/_ is "something to watch out for"?
22:06:49 <dmwit> You bet!
22:06:58 <dmwit> It won't be a problem until you forget to watch for it. ;-)
22:07:42 <dmwit> Try "newtype X = X X deriving Show" and then type "undefined :: X" in a ghci terminal.
22:07:50 <dmwit> Predict what it will do and see if you're right. =)
22:08:24 <timmaxw> why was newtype originally put into the Haskell 98 report then? why not just include a suggestion that compilers optimize data? i don't see how adding a new behavior that acts a tiny bit differently is worth the added language complexity (and confusion to newbies)
22:08:57 <MyCatVerbs> @where lyah
22:08:58 <lambdabot> www.learnyouahaskell.com
22:09:25 <dmwit> timmaxw: ...
22:09:30 <timmaxw> dmwit: i wouldn't expect it to accept "newtype X = X X" at all
22:09:35 <timmaxw> dmwit: that's what i would *predict*
22:09:38 <dmwit> timmaxw: You *can't* optimize data in general.
22:10:04 <thoughtpolice> timmaxw: because then you have to treat that optimization as a standard
22:10:28 <thoughtpolice> because then code may depend on such functionality as specified by the report
22:10:45 <thoughtpolice> it's the same reason they didn't totally kill the monomorphism restriction
22:10:55 <dmwit> Detecting when somebody is using data as newtype (i.e. finding "undefined"s in the code) is undecidable.
22:10:57 <thoughtpolice> they didn't want the potential performance problems to be held at the mercy of every implementation
22:11:05 <timmaxw> dmwit: oh, i think i see it. if "newtype X = X Foo", then there's one possible variation at runtime: "X". If "data X = X Foo", then there are two possible variations: "X" and "_/_". This means that more space has to be used for the "data" declaration. Am I right?
22:11:22 <dmwit> timmaxw: Exactly.
22:11:28 <timmaxw> also, ghci won't let me run "newtype X = X X"
22:11:40 <dmwit> timmaxw: Yeah, you've got to put newtype declarations in a file.
22:11:42 <timmaxw> or any "newtype" declarations at the interactive prompt
22:11:59 <dmwit> That's why I said to try newtype X = X X deriving Show, *then* go to ghci. ;-)
22:12:44 <timmaxw> thoughtpolice: why? it's trivial to implement and it doesn't make a huge performance impact either way. compilers can easily include it or not include it. isn't that like saying that common subexpression elimination has to either be part of the standard or not available at all?
22:13:01 <timmaxw> thoughtpolice: (that is, if it weren't for the _/_ thing)
22:13:28 <dmwit> It's not trivial to implement, it can make a huge performance difference, and it's not at all like saying something must be available or not available.
22:14:21 <dmwit> Strictness analysis is a field with lots of papers and  a load of very difficult work.
22:14:27 <timmaxw> dmwit: i see.
22:14:30 <dmwit> So that's the trivial to implement thing.
22:14:46 <dmwit> Wrapping and unwrapping a single constructor can really matter, especially for arithmetic or so.
22:14:49 <dmwit> So that's the performance thing.
22:15:14 <dmwit> (Imagine following a pointer, doing arithmetic, and then allocating a new pointer every time you wanted to add. yuck)
22:15:30 <dmwit> As for the standard, it doesn't come out either way.
22:15:34 <amckinley> hey, i need some help writing a line-oriented parsec parser. im trying to parse dns zone files (see http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5483)
22:15:53 <dmwit> That lowers the bar for standards-compliant compilers (a good thing), and lets serious compilers do the optimization if it can (also a good thing).
22:16:20 <amckinley> i dont want to use lexeme parsers because whitespace is meaningful in a couple complicated ways, and im having trouble doing things without them
22:16:55 <timmaxw> dmwit: it adds a little complexity to the language and makes it easier for non-optimizing compilers not to have horrible performance
22:17:15 <dmwit> Right.
22:17:24 <dmwit> A relatively benign trade-off, really.
22:18:02 <dmwit> It also gives the programmer a  little control for times when the optimizer fails.
22:18:10 <dmwit> For people who care about optimization, this matters, too.
22:18:13 <amckinley> what i feel like i *should* do is produce a bunch of substrings that correspond to the record boundaries, then pass those strings off to more specific parsers for each record type
22:18:20 <amckinley> which isnt very parsec-y
22:18:42 <rick_2047> cant i have an or ( || ) condition in a predicate??
22:18:50 <dmwit> rick_2047: Sure you can.
22:19:01 <dmwit> amckinley: That's perfectly parsecy.
22:19:13 <timmaxw> dmwit: we could talk about this for a while but unfortunately i have to sign off. goodnight, and this has been an interesting discussion.
22:19:30 <dmwit> amckinley: In fact, it's very much like having a lexer stage (where lexemes are records).
22:20:02 <amckinley> dmwit: how could i do something like that? my understanding is that once ive consumed a character, i cant consume it again without invoking parse a second time
22:20:17 <dmwit> amckinley: Right... but then you *have* the character. ;-)
22:21:08 <sclv> amckinley: also you can simply not use lexeme parsers and parse whitespace explicitly.
22:21:09 <dmwit> amckinley: One simple way is to have your first-stage parser return a [String], where each element is a record.
22:21:23 <amckinley> dmwit: so is that the way to do it? make a pass over the file to break it up, then make another pass with another set of parsers?
22:21:32 <amckinley> er, thats a yes^^ :)
22:21:47 <dmwit> amckinley: It's certainly not the only way.  But if that way seems natural to you, it's also certainly not a bad way.
22:23:08 <amckinley> dmwit: it definitely feels natural, but im using this project (partly) as an excuse to learn haskell and parsec, so if theres a preferred way of doing it, id rather jump through the hoops of learning it :)
22:23:57 <dmwit> I see nothing wrong with this way.
22:24:05 <sclv> also lookAhead is perfectly fine in moderation
22:24:16 <sclv> (i.e. for determining if the next character is a paren)
22:24:22 <amckinley> sclv: that was my next question :)
22:24:22 <dmwit> sclv means try, not lookAhead. ;-)
22:24:35 <sclv> dmwit: no. I mean lookAhead too.
22:25:07 <sclv> you can write parsers without it, but sometimes I find it more elegant looking if ever so slightly less efficient to use it.
22:36:07 <amckinley> sclv: dmwit: so here's a first crack at the lexer stage; i havent tested it yet, but could you (and anyone else) critique my style? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5484
22:37:27 <sclv> amckinley: return an Either instead?
22:38:24 <sclv> or better yet do (parens nlSepList <|> plainList) where those are the two styles..
22:38:37 <sclv> and thus skip the lexer stage.
22:39:18 <sclv> if parsec hits the first paren it knows its in the first style, and can parse the rest, then throw away the end, and if it hits anything else, then it'll try in the second style.
22:40:06 <amckinley> sclv: its actually hard to say whether or not you could legitimately put content on the same line as the closing paren
22:40:32 <sclv> amckinley: its easy to write the parser either way tho...
22:40:39 <amckinley> the RFC describes the parens as an "ignore newlines between these delimiters" thing
22:40:48 <sclv> there's sepBy and sepEndBy...
22:41:13 <sclv> ah! i see what you mean...
22:41:17 <amckinley> sclv: ive been totally brainlocking on how to use either one of those combinators :P
22:41:54 <sclv> so you really want a restOfLine function that will read the rest of the line, or read downward, tossing out parens as it goes.
22:42:01 <sclv> but you also need to know how to ignore comments.
22:42:23 <amckinley> sclv: exactly
22:43:25 <sclv> restOfLine =parens textWithoutComments <
22:43:34 <sclv> <|>  manyTill (char '\n')
22:44:33 <amckinley> textWithoutComments seems like a hard thing to write
22:45:07 <notsmack> any decent mp3 decoding bindings?
22:45:08 <sclv> where textWithoutComments = fmap (intercalate " ") $ many lineWithoutComments
22:45:52 <amckinley> touche :)
22:46:02 <sclv> where lineWithoutComments = manyTill anyChar (char '\n' <|> (char ';' >> manyTill anyChar (char '\n')))
22:47:17 <sclv> I always end up refactoring my parsec parsers quite a bit as I go along, but even more so when I was learning -- its easy to knock something out that works then clean it up later and try to feel out the logic hidden in the grammar.
22:47:52 <dmwit> notsmack: Well, there's that "Let's write an mp3 decoder" paper somebody wrote for their master's.
22:48:16 <dmwit> http://blog.bjrn.se/2008/10/lets-build-mp3-decoder.html
22:48:28 <notsmack> dmwit, hadn't seen, i'll take a look
22:48:48 <dmwit> notsmack: I should maybe ask why you want that, though.
22:48:50 <amckinley> sclv: im going to try some of this out, back in a minute
22:49:15 <dmwit> notsmack: Oh, never mind, you did ask for bindings. =P
22:49:18 <notsmack> dmwit, just want to knock a quick music player together
22:49:21 <dmwit> notsmack: Have you checked the audio libraries on Hackage?
22:49:41 <notsmack> yeah, looked through them a bit
22:49:54 * dmwit wonders briefly if there is a binding to the mpd stuffs
22:50:21 <dmwit> Of course there is!
22:50:40 <walter_> Which Lib quite handful to creat HTML file?
22:51:21 <notsmack> dmwit, mpd doesn't really suit my needs;  i was about to look at rhythmbox or totem via dbus bindings next
22:51:35 <dmwit> notsmack: What are your needs?
22:52:03 <Cale> walter_: The one called 'html' is probably reasonable, though I haven't really used Haskell to generate much html myself.
22:52:25 <dmwit> walter_: WASH has a beautiful DSL for HTML construction.
22:52:26 <notsmack> dmwit, well, i want to be able to play a file, not mess with IDs from mpd's music database
22:52:55 <dmwit> walter_: There's also html, xhtml, and xml packages on Hackage (by those names, even).
22:53:08 <Cale> Hey, is WASH not on Hackage?
22:53:19 <dmwit> I wonder if WASH even builds with recent GHCs.
22:53:25 * Cale doesn't see it there
22:53:33 <walter_> yeah, so many lib on html xhtml
22:54:23 <dmwit> WASH actually generates correct strict XHTML (guaranteed by the type system!), with a small patch to change the declaration from transitional to strict.
22:54:25 <walter_> dev-haskell/wash is in the Gentoo portage overlay
22:54:46 <walter_> I will try wash
22:56:33 <walter_> Wash is not in Hoogle
22:56:39 <dmwit> nope =/
22:56:45 <dmwit> But the docs are good.
22:57:00 <walter_> dmwit, that's great
22:57:24 <dmwit> http://www.informatik.uni-freiburg.de/~thiemann/WASH/#washhtml
22:57:33 <MyCatVerbs> dmwit: off the cuff, is there any library you'd specifically recommend for HTML 4.01?
22:57:41 <MyCatVerbs> Er, 4.01 Strict, even.
22:58:05 <dmwit> I've only ever used the one. =P
22:59:25 <Jedai> MyCatVerbs: I would probably use xhtml (it only produce XHTML 1.0 Transitional, Strict or Frameset though)
22:59:49 <walter_> dmwit, thanks!
23:01:11 <MyCatVerbs> Jedai: I personally prefer 4.01 to xhtml for a couple of bad ideological reasons.
23:01:46 <inimino> there aren't many reasons to prefer XHTML at this point
23:02:40 <Jedai> MyCatVerbs: Wash seems to have a good generator for HTML4.01, they use types to guarantee a valid output
23:02:51 <dmwit> Oh, is it 4.01?
23:02:57 <dmwit> I thought it was XHTML.
23:03:12 <dmwit> In any case, I remember validating it as "Strict" for whatever it was. =P
23:03:35 <Jedai> MyCatVerbs: I never used it though, and the webpage explain that it was thoroughly tested on the 2001 release of Hugs...
23:03:49 <dmwit> Yeah, it's a bit old.
23:03:58 <Jedai> dmwit: the link you sent say it's 4.01 anyway
23:04:14 <dmwit> I trust its docs much more than my memory.
23:05:25 <MyCatVerbs> Jedai: oh! I thought dmwit meant it did xhtml only.
23:05:36 <dmwit> That's what I meant, but I was wrong.
23:05:37 <MyCatVerbs> Sorry, my bad. Checking the website for WASH, yes it does 4.01 as well.
23:08:33 <walter_> I got an error while install WASH, it said "Current maximum heap size is 299999232 bytes (286 MB);
23:08:33 <walter_> use `+RTS -M<size>' to increase it.
23:08:33 <walter_> "
23:08:57 <dmwit> Wow.
23:09:17 <dmwit> Could you paste the whole output?
23:09:18 <dmwit> ?hpaste
23:09:18 <lambdabot> Haskell pastebin: http://hpaste.org/new
23:09:44 <walter_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5487#a5487
23:11:40 <dmwit> walter_: Is it easy to have a look at the file that failed compilation?
23:11:47 <dmwit> I'd be interested in seeing what makes GHC die.
23:12:49 <walter_> dmwit, a moment, let me try
23:13:32 <Jedai> dmwit: I think it's a problem with the build system somehow... the heap size isn't supposed to be limited by default
23:14:41 <Axman6> anyone got any suggestons for interesting some papers to read, possibly about haskell and/or concurrency/parallelism, or techniques for making it faster... or just papers you think are fascinating
23:15:10 <MyCatVerbs> Axman6: if you look up the implementation docs for GHC, there's the spineless-tagless-G-machine paper.
23:15:22 <MyCatVerbs> Somewhere or other on haskell.org.
23:15:24 <Axman6> heh, that sounds fun
23:15:39 <MyCatVerbs> If you're looking for more entertainment than theory, look up the cocaine auction protocol.
23:15:46 <Axman6> http://portal.acm.org/citation.cfm?id=289439 ?
23:15:50 <MyCatVerbs> Possibly the most exciting infosec paper I've read yet.
23:16:18 <dmwit> How about that "bidirectionality for free" paper?
23:16:21 <MyCatVerbs> Sounds like the right title. Guess I got the author wrong.
23:17:11 <mauke> "naturally"
23:29:07 <notsmack> anybody used the DBus bindings?
23:29:31 * notsmack is trying to figure out how to listen for a signal
23:31:30 <dmwit> notsmack: Not sure, but maybe addFilter?
23:32:31 <walter_> dmwit, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5489#a5489   the only log I got while install wash
23:33:18 <dmwit> walter_: Dunno.  Try upping the heap size, I guess?
23:33:18 <amckinley> sclv: still around?
23:34:37 <walter_> yep
23:34:38 <cads> hehehe
23:34:40 <cads> hahaha
23:34:42 <cads> HAAAAHAHAHAHA!!!!
23:35:34 <cads> we can define tuples as sets!
23:35:34 <cads> as in the following example : {{a} {a b} {a b c} {a b c d} {a b c d e}}
23:35:46 <cads> which is equivalent to (a b c d e)
23:36:04 <dmwit> I'm with you so far.
23:36:32 <cads> then we can write functions parameterized on tuple types of varying rank
23:36:40 <MyCatVerbs> cads: but tuples are more like bags than sets? Sets enforce singularity.
23:36:57 <dmwit> cads: But we can already do that, with lists.
23:37:07 <dmwit> cads: (Remember, all the elements of the set have to have the same type.)
23:37:11 <MyCatVerbs> Er, wrong term, but anyways. Sets enforce that each element is in there at most once.
23:37:11 <cads> no!
23:37:24 <cads> that's not the definition of sets!
23:37:35 <dmwit> cads: Are we talking about Haskell, or not?
23:38:04 <cads> aw that crushes me... I though they'd be mathematical sets
23:38:10 <cads> not... unordered lists
23:38:28 <dmwit> MyCatVerbs: The standard trick is to wrap things in more and more set brackets until they're unique.
23:38:32 <cads> ah well
23:39:19 <cads> dmwit: it's my long running pie in the sky dream to be able to write a function that can take a tuple of arbitrary size and type
23:39:45 <dmwit> cads: But how would you represent the sets you're using to encode tuples above?
23:40:09 <dmwit> cads: If you use Data.Set, then each of the elements has the same type, and so you might as well just use an (ordered) list of elements.
23:40:24 <dmwit> cads: Also, have you seen HList?
23:40:50 <cads> ah
23:40:53 <cads> nice
23:40:55 <cads> okay
23:41:06 <dmwit> (a, b, c, d) is encoded as (a, (b, (c, (d, ())))), with some major type-hackery to make it convenient
23:41:18 <dmwit> cads: (Hence my comment above about using lists. ;-)
23:42:25 * dmwit realizes that there are really two threads of conversation happening here, and they are mildly confusing.
23:42:52 <cads> ok yeah, we got to do something like  foldl1 . [curry, curry, curry]
23:42:53 <dmwit> (a, b, c, d) is encoded that way in HList.  There, I hope I've disambiguated.
23:43:05 <dmwit> cads: doesn't type-check
23:43:26 <dmwit> cads: Curry is being used at different types there, you'll get an occurs-check errror.
23:43:37 <dmwit> > foldl1 (.) [curry, curry, curry]
23:43:38 <cads> oh right
23:43:42 <lambdabot>   mueval-core: Prelude.read: no parse
23:43:43 <lambdabot>  mueval: ExitFailure 1
23:44:16 <dmwit> :t foldl1 (.)
23:44:22 <lambdabot> forall b. [b -> b] -> b -> b
23:44:25 <dmwit> :t foldr (.) id
23:44:26 <cads> well, I think the HList is exactly what I'd need for anything I'd use 'dynamic tuple functions' for
23:44:32 <lambdabot> forall a. [a -> a] -> a -> a
23:44:58 <cads> but then there's the problem of how you actually write a function that uses values inside an hlist, but i'd like to see what kind of interface it gives for that
23:45:08 <dmwit> http://okmij.org/ftp/Haskell/types.html
23:46:37 <walter_> since I can not install WASH, will try HStringTemplate instead
23:46:50 <rob__> Hi all, I have a quick question: is it possible to instantiate a type constructor in a type class?
23:47:02 <dmwit> walter_: Smart move. =P
23:47:14 <dmwit> rob__: Only if the kinds match.
23:47:21 <walter_> dmwit, :)
23:47:52 <walter_> Someome's advice:    http://blog.uncommons.org/2008/12/03/generating-html-with-haskell/
23:48:16 <rob__> dmwit: how can i find out if they match?
23:49:12 <dmwit> rob__: You can use :k in ghci to find the kind of a type constructor (even if partially applied).
23:49:30 <dmwit> rob__: As for what kind it has to be for the instance... that you can usually do by inspection of the instance.
23:49:41 <rob__> dmwit: thanks I'll try that
23:49:46 <dmwit> rob__: (You can mostly find the kind of a type constructor by inspection, too. =)
23:49:53 <dmwit> rob__: Can I ask what this is about?
23:49:59 <ray> haskell kinds are pretty simplistic
23:50:02 <dmwit> rob__: If you give us more details, we can help you more.
23:50:31 <vininim_> :t liftM2
23:50:38 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
23:50:47 <ray> :k ReaderT
23:50:53 <vininim_> :t liftM2 (,,)
23:50:54 <lambdabot> * -> (* -> *) -> * -> *
23:51:02 <lambdabot> forall a1 a2 c (m :: * -> *). (Monad m) => m a1 -> m a2 -> m (c -> (a1, a2, c))
23:52:04 <rob__> dmwit: sure I'm trying to write yet another ray tracer as an exercise and I defined some objects as type constructors in a datatype and I made a type class to define common functions for them
23:52:40 <dmwit> Are you sure what you're talking about are actually type constructors and not value constructors?
23:53:02 <dmwit> (This is a common mistake, sorry if this is totally obvious to you.)
23:54:00 <dmwit> :k Monad m => m a
23:54:07 <lambdabot> *
23:54:10 <dmwit> lambdabot++
23:54:33 <ray> :k Monad m => m
23:54:40 <lambdabot>     `m' is not applied to enough type arguments
23:54:40 <lambdabot>     Expected kind `*', but `m' has kind `* -> *'
23:54:48 <ray> it told me, sorta
23:57:20 <rob__> dmwit: oh good catch, I got those confused
23:58:18 <ray> if so, then you probably want a function, not a class
