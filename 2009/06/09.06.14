00:00:50 <mmorrow> oh nice, if you can forkIO then this could work out nicely. essentially i was thinking of using the function that reads from the Chan to be the dispatch the "real" callbacks, and the callbacks you give to gtk would just be dummy ones that simply enqueue the event and return
00:01:59 <mmorrow> then you'd be able to register callbacks with this function (somehow), and these callbacks can be triggered by *any* combination of events, not just mouse/key/whatever events only
00:04:06 <mmorrow> (granted, this wouldn't be trivial to design/work the details out for)
00:04:28 <roderyk> mmorrow: ah, I see. will think this over later - it sounds nice, but not sure if I should take the time sink at the moment ;)
00:04:51 <mmorrow> yeah, it'd be a tangent for sure
00:07:24 <roderyk> mmorrow: thanks for the input; you stirred up a few good points, def. will end up thinking over the design later ;)
00:08:36 <roderyk> (since this is starting to become a rather big gui app, might just be worth implementing a custom callback framework - instead of struggling against gtk limits everytime I want to do something non-trivial)
00:09:40 <ski> (mriou : of course you should be aware that that will take the "current" environment at the point of invoking `tunnel' and pass as the environment to the callback)
00:10:31 <mriou> ski: that's what I was coming to realize....
00:11:04 <mriou> so I guess the IORef is necessary after all
00:11:57 <ski> maybe (depends on what you want ..)
00:12:16 <ski> but then you'll need to keep it in sync at appropriate places
00:13:06 <ski> (hm, or if you have it as `ReaderT (IORef ..) ..', then maybe that'll be often enough, anyway)
00:13:53 <mriou> I have it as ReaderT (TVar ...)
00:14:02 <ski> ok
00:14:44 <mriou> ski: I think I'll find a way but thanks for pointing it out though
00:14:55 <ski> np
00:16:19 <hackagebot> pgm 0.1.1 - Pure Haskell implementation of PGM image format (FrederickRoss)
00:25:01 <mmorrow> ski: you mentioned delimited continuations the other day. what exactly do these require? does smlnj have what you'd need? also i've looked at this briefly a while ago, but don't know the details (although now that i remembered about it i'm going to have another look)  http://okmij.org/ftp/Computation/Continuations.html#caml-shift
00:26:16 <mmorrow> ski: this sounds interesting about the oleg thing "The new version of the delimcc library supports serialization of captured continuations. The new version implements abort as a primitive, which makes it essentially as efficient as raise."
00:26:19 <dhun> in imperative programming you often have to care about how often you call a function, an you can often increase speed by caching value in local variable, does Haskell automatically do such optimizations?
00:27:09 <mmorrow> dhun: not in the case that i think you have in mind. "let" though would do that for you though
00:28:01 <mmorrow> like,  ((1 + 1) + (1 + 1) /= let x = 1 + 1 in x + x) wrt compiled code
00:29:06 <mmorrow> (although maybe that'd be constant folded? but in the general case ghc won't elimiate the common subexpressions i don't think)
00:30:06 <dhun> no it was mainly about a function that is only called with the same constant parameters all the time
00:31:06 <mmorrow> dhun: in that case you'd want to use `let' for sure
00:31:21 <dhun> ok will read about let now
00:31:44 <mmorrow> , let x = length [0.10000000] in x + x + (x * x)
00:31:46 <lunabot>  3
00:32:17 <dhun> ok
00:32:22 <mmorrow> , length [0.10000000] + length [0..100000000] + (length [0..100000000] * length [0..100000000])
00:32:28 <lunabot>  Killed.
00:32:44 <dhun> ok
00:33:13 <dhun> why didn't the second call work?
00:33:20 <mle> .?
00:33:28 <ski> mmorrow : you can implement delimited continuations given a (undelimited) continuations, plus one state cell
00:33:28 <mle> , length [0.100]
00:33:28 <mmorrow> it would've worked, but the bots limit you to a few seconds
00:33:30 <lunabot>  1
00:33:36 <mle> , length [0.100000]
00:33:37 <lunabot>  1
00:33:51 <ski> mmorrow : you can implement monadic reflection (see Andrzej Filinski) with delimited continuations
00:33:51 <mle> need two dots.
00:34:18 <ski> mmorrow : see "Representing Monads" and "Representing Layered Monads" (iirc)
00:34:56 * wli represents Jacobian elliptic functions.
00:35:27 <mmorrow> ski: ah, nice. i'm planning on having the equivalent of (the primitive that implements) IO/STRef, so that + callCC should do it (?)
00:35:53 <mmorrow> ski: cool, i'll check those out
00:36:24 <ski> mmorrow : the reason i mentioned it was that using a primitive efficient implementation of delimited continuations, i believe/hope one could make user-defined monads of a similar order of efficiency as "normal" primitive effects (consider e.g. exceptions)
00:36:53 <mmorrow> ski: hmm, interesting.
00:37:05 <ski> (it might be that a primitive implementation of delimited continuations could be more efficient than one using undelimited ones + state ..)
00:39:29 <mmorrow> ski: ah, i see. i'll look into what exactly a primitive implementation would need to implement/do.
00:39:40 <ski> (in any case, i believe it achieves similar asymptotic efficiency as explicitly CPS-encoding monads, in cases like e.g. exceptions : instead of every `(>>=)' operation having to check whether there's an exception, the monadic type is "interpreted"/inspected only by those operations that actually need to .. such as exception handlers)
00:40:45 <ski> something to look into, anyway
00:41:38 <mmorrow> ski: ah, re: exceptions. so my intial design is that two of the registers are CC and EC, which are the current and exception continuations respectively, and there's a byecode: INVOKE (reg1::a) (reg1::Cont a). so RET r := INVOKE r CC, and THROW r := INVOKE r EC (although RET and THROW are their own byecodes for efficiency)
00:41:39 <ski> (you could talk with edwardk about his CPS-encoding with `CoDensity', et.c.)
00:42:11 <mmorrow> (and CALLCC reg := reg <- CC)
00:42:39 <mmorrow> (and CALLEC reg := reg <- EC)
00:43:31 <ski> (heh, `EE' makes me think of "escaping continuation" a la `call/ec'/`call-with-escaping-continuation' in some Schemes)
00:43:34 <mmorrow> err, also RET/THROW do  CC <- NEXT(CC)   (and same for EC)
00:45:02 <ski> `NEXT' ?
00:45:23 <ski> (sorry s/`EE'/`EC'/)
00:45:25 <mmorrow> struct cont {... struct cont *next; ...}
00:46:10 <ski> so `RET/THROW' unwinds one frame ?
00:46:44 <mmorrow> yes, essentially, but you can capture the CC/EC too, so unwinding here doesn't necessarily entail destroying
00:47:00 <ski> (yes)
00:47:46 <ski> so `RET r' wasn't the same as `INVOKE r CC' ?
00:47:58 <mmorrow> oh no, it is yes
00:48:00 <ski> or was `RET r' and `RET' two different instructions ?
00:48:22 <mmorrow> ah, 'r' is just the register argument to the bytecode (the val to throw to CC)
00:48:26 <ski> or what did you mean by
00:48:28 <ski> <mmorrow> err, also RET/THROW do  CC <- NEXT(CC)   (and same for EC)
00:48:29 <ski> ?
00:48:55 <mmorrow> ah, oh you're right. yes, RET/THROW isn't just INVOKE r CC/EC
00:49:13 <mmorrow> RET is INVOKE + CC <- NEXT(CC)
00:49:27 <ski> oh, ok
00:50:00 <mmorrow> so i guess doing (INVOKE r CC) would be a way to loop
00:50:17 <mmorrow> err, or something
00:51:07 <ski> i suppose for user implementing exceptions using monadic reflection via delimited continuations, there wouldn't be dedicated register for the escaping continuation (as far as the VM knows), but hopefully otherwise, it'd be more or less similar
00:52:36 <ski> (and similar for the user implemeting `Parsec'-parsing, et.c. via delimited continuations)
00:53:00 <mmorrow> interesting
00:53:08 <mmorrow> be back in a bit
00:53:22 * ski has to leave in a few minutes
00:56:22 <ski> the idea with monadic reflection is the user implements a (computable) monad, more or less like in Haskell today, then using monadic reflection (a) one would avoid most of the "interpretative overhead" by using delimited continuations (better if the latter have primitive efficient implementation); and (b) the possibility of using a "reflected" (/ side-effectful) syntax for the effects in the monad
00:56:46 <ski> the (b) part wouldn't have to be coupled with the (a) part, if one doesn't want to, afaics
00:58:54 <ski> Andrzej Filinski's publications <http://www.diku.dk/hjemmesider/ansatte/andrzej/papers/>, "Recursion from Iteration" Andrzej Filinski <http://www.diku.dk/hjemmesider/ansatte/andrzej/papers/RM.ps.gz>, "Representing Layered Monads" Andrzej Filinski <http://www.diku.dk/hjemmesider/ansatte/andrzej/papers/CE.ps.gz>
00:58:59 <ski> mmorrow : there ^
00:59:54 <mle> preflex: calc '36 1553062132
00:59:54 <preflex>  ponies
01:00:05 <ski> (several other of the papers there are also interesting, e.g. "Abstracting Control" and "Representing Control: A Study of the CPS Transformation" on CPS and shift/reset but the two above were the ones i was thinking about)
01:00:29 <ski> (mmorrow : sorry, the link for the latter paper above should have been : "Representing Layered Monads" Andrzej Filinski <http://www.diku.dk/hjemmesider/ansatte/andrzej/papers/RLM.ps.gz>)
01:00:33 * ski leaves
01:09:05 <mmorrow> ski: nice, thanks
01:26:00 <ivanm> gah, kuribas' emacs mode doesn't indent using a case inside an if statement properly :@
01:27:58 <opqdonut> how come getting indenting right is so hard
01:28:13 <opqdonut> hmm, or rather, indenting if
01:28:31 <Axman6> i don't think that haskell's indenting rules are very easy to program, but are fairly easy to understand for a human
01:28:42 <opqdonut> mhmm
01:28:58 <ivanm> bugger, and now it won't let me keep coding because it thinks the indentation is buggered :@
01:32:25 <KarlsFriend> Hi everyone
01:32:50 <KarlsFriend> I just startet leysrning haskell and i am havin some trouble with an exercise
01:33:21 <KarlsFriend> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2748#a2748 doesnt compile
01:33:28 <KarlsFriend> and i don tget why. can anysone help?
01:34:26 <ivanm> what error does it give?
01:34:39 * ivanm guesses the --sum <- readsum line
01:34:42 <KarlsFriend> Readsum.hs:16:16:
01:34:43 <KarlsFriend>     Ambiguous type variable `a' in the constraint:
01:34:43 <KarlsFriend>       `Read a' arising from a use of `read' at Readsum.hs:16:16-23
01:34:43 <KarlsFriend>     Probable fix: add a type signature that fixes these type variable(s)
01:34:43 <KarlsFriend> Failed, modules loaded: none.
01:34:54 <habitue> yeah no type annotation on your read
01:35:14 <habitue> you have to do read add :: Int
01:35:39 <KarlsFriend> don't know what that means. i am using the "yet anotzher haskell tutorial" and i did not get to that point apparently
01:36:06 <KarlsFriend> they always just do "var <- read" and it works
01:36:17 <KarlsFriend> um wait
01:36:29 <habitue> read doesn't know what type you want to read from the string
01:37:03 * wli doesn't seem to be able to do much writing about them on account of lack of mastery of diagramming. :(
01:37:23 <KarlsFriend> ok i will try that. thanks
01:38:40 <KarlsFriend> got another error now
01:38:42 <KarlsFriend>     Could not deduce (Read int) from the context ()
01:38:42 <KarlsFriend>       arising from a use of `read' at Readsum.hs:16:16-23
01:38:42 <KarlsFriend>     Possible fix:
01:38:42 <KarlsFriend>       add (Read int) to the context of an expression type signature
01:38:42 <KarlsFriend>     In the expression: read add :: int
01:38:43 <KarlsFriend>     In the definition of `addNum': addNum = read add :: int
01:38:45 <KarlsFriend>     In the expression:
01:38:47 <KarlsFriend>         do putStrLn "Enter a number or 0 to exit"
01:38:49 <KarlsFriend>            add <- getLine
01:38:51 <KarlsFriend>            let addNum = ...
01:38:53 <KarlsFriend>            return 1
01:40:31 <dibblego> KarlsFriend, please use a pastebin such as hpaste.org
01:41:13 <KarlsFriend> k, next time.
01:43:15 <habitue> capitalize Int
01:44:13 <KarlsFriend> thx habitue, that worked!
01:46:08 <Reiv> What is the type of (+) ?
01:46:15 <idnar> @type (+)
01:46:16 <lambdabot> forall a. (Num a) => a -> a -> a
01:57:50 <KarlsFriend> ok i am havin syntax problems againt. can anyone take look? It's jsut 21 Lines http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2750#a2750
02:01:16 <habitue> you can't ++ num and readnums, since num isn't a list
02:01:27 <habitue> use : instead, like
02:01:35 <habitue> num : readnums
02:02:03 <KarlsFriend> thx. would "[num]++ readnums" work too?
02:02:16 <habitue> yeah it would, but it's more typing :P
02:03:28 <KarlsFriend> now something else is wrong
02:03:29 <KarlsFriend> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2751#a2751
02:05:21 <voker57_> Just (replicate 21 Line)
02:05:46 <habitue> return $ num : readnums
02:06:08 <habitue> do that instead, it is trying to return just num by itself
02:06:24 <KarlsFriend> what does $ do?
02:06:38 <voker57_> @type ($)
02:06:39 <habitue> its just function application, but it has the lowest precedence possible
02:06:39 <lambdabot> forall a b. (a -> b) -> a -> b
02:06:57 <habitue> so everything on the right side gets evaluated before it is applied
02:07:32 <habitue> it's the same as doing:  return ( num : readnums )
02:07:53 <KarlsFriend> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2751#a2752
02:07:56 <KarlsFriend> still not working
02:08:24 <KarlsFriend> haskells syntax is pretty hard
02:09:24 <habitue> that's the same paste as before
02:09:31 <MartyIX> Is it possible to change a value in an array without "incremental update" (i.e. creating new matrix in fact)?
02:09:54 <habitue> Karlsfriend: what is the new error you are getting?
02:10:47 <KarlsFriend> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2753#a2753
02:12:20 <KarlsFriend> i guess im am just going to skip that one and go right to the next chapter. i dont get all that type stuff
02:12:26 <voker57_> KarlsFriend: readlines is monad
02:12:36 <voker57_> you need to evaluate it first
02:13:10 <KarlsFriend> whats a monad and how do i evaluate things?
02:13:34 <voker57_> KarlsFriend: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2751#a2754
02:14:14 <voker57_> monad is non-deterministic function (afaik)
02:14:30 <voker57_> so you need to evaluate it using <- operator
02:14:36 <KarlsFriend> so i have to store the value somewhere first, before i return it
02:15:06 <voker57_> yes
02:15:20 <voker57_> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2751#a2755 <- fixed indentation
02:16:04 <KarlsFriend> yeah it compiles! finally
02:16:12 <QtPlaty[1ireMe]> voker57_: Monad isn't a function, its a typeclass
02:16:23 <eu-prleu-peupeu> helo
02:16:27 <QtPlaty[1ireMe]> hi
02:17:02 <voker57_> QtPlaty[1ireMe]: how is Monad function called then?
02:17:13 <voker57_> which needs evaluation
02:17:25 <voker57_> (i'm rusty with terms)
02:19:07 <integral> it depends on the monad.  Some monads like IO can't be evaluated, for example.
02:24:26 <KarlsFriend> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2756#a2756   another syntax error
02:24:38 <KarlsFriend> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2756#a2756
02:25:46 <mmorrow> > runState (do s <- get; put (s+2); return (s+1)) 0
02:25:48 <lambdabot>   (1,2)
02:26:16 <mmorrow> > runState (do modify (+1); return ()) 0
02:26:17 <lambdabot>   ((),1)
02:26:20 <mmorrow> > runState (do modify (+1)) 0
02:26:22 <lambdabot>   ((),1)
02:26:41 <mmorrow> > runState (replicateM 10 (do s <- get; put (s+2); return (s+1))) 0
02:26:43 <lambdabot>   ([1,3,5,7,9,11,13,15,17,19],20)
02:27:41 <mmorrow> > runState (replicateM 10 (do (m,n) <- get; put (n,m+n); return m)) (0,1)
02:27:42 <lambdabot>   ([0,1,1,2,3,5,8,13,21,34],(55,89))
02:28:58 <mmorrow> , runST (do x <- newSTRef 0; writeSTRef x 42; readSTRef x)
02:29:00 <lunabot>  42
02:29:17 <voker57_> KarlsFriend: you have indentation problem
02:29:28 <voker57_> at line 13
02:30:01 <habitue> karld: putStrLn ("Their factorials are " ++ show (map (fac nums)))
02:30:57 <habitue> KarlsFriend: just do: show (map fac nums)
02:31:19 <habitue> map takes two arguments, with the parens you are only passing it one
02:31:21 <KarlsFriend> voker57_ but the indentation is th same as thelines before
02:31:49 <Alpounet> Can anyone tell me what's the name of the program for generating html files from haskell source code files, with syntax highlighting etc ?
02:31:58 <mlesniak> Alpounet: haddock?
02:32:13 <Alpounet> isn't that for documentation ?
02:32:15 <mlesniak> Alpounet: oh sorry, thats for documentation
02:33:26 <Alpounet> ?go hscolor
02:33:27 <lambdabot> No Result Found.
02:34:58 <Alpounet> oh, it's hscolour
02:34:58 <KarlsFriend> thx, i will now put a ";" after each statement. i dont get that identation thing
02:35:26 <voker57_> KarlsFriend:  no, it's one level more
02:35:34 <voker57_> i can see that at hpaste
02:36:16 <KarlsFriend> thx, now i got it. there was a tab all the time!
02:52:54 * dcoutts starts writing some nice new code
02:53:07 <Alpounet> i.e ?
02:53:31 <dcoutts> a compact data structure for the index of a tarball
02:53:45 <dcoutts> which we'll use to serve the contents of tarballs in the new hackage server
02:53:57 <dcoutts> ie mapping FilePath -> (Offset, Length)
02:54:14 <dcoutts> but as compact as possible, since we're going to hold all the indexes in memory
02:55:06 <dcoutts> in particular we can take advantage of the fact that filenames share prefixes a lot
02:55:07 <mmorrow> dcoutts: ooh, interesting.. that could be useful in general for an in-memory-db-thing
02:55:26 <dcoutts> mmorrow: this is pretty specialised
02:55:39 <dcoutts> and it's read-only
02:55:42 <mmorrow> ah.
02:55:47 <mmorrow> ah
02:55:49 <dcoutts> I mean construct all in one go, then do lookups
02:55:59 <dcoutts> which means we can use dense arrays
02:56:17 <mmorrow> oh i see, nice
02:57:08 <mmorrow> oh wait, i was just picturing i don't really know what i was picturing
02:57:49 <mmorrow> i'll see it when you write it :)
02:58:06 <dcoutts> :-)
02:58:24 <dcoutts> my plan is to map filepath components to integers, then use an integer trie
02:58:55 <dcoutts> eg split up "foo-1.0/Data/Foo.hs" into ["foo-1.0", "Data", "Foo.hs"]
02:59:23 <dcoutts> map those to integer ids ["foo-1.0", "Data", "Foo.hs"] -> [TokId 0, TokId 1, TokId 2]
02:59:45 <dcoutts> and lookup [0,1,2] in an int trie
02:59:51 <dcoutts> giving us back another int :-)
03:00:11 <dcoutts> which we use to lookup the tar entry's offset and length within the tar file
03:00:13 <opqdonut> why the integer mapping?
03:00:51 <dcoutts> opqdonut: it means we can use a compact trie, it also gives us sharing so that we only keep "foo-1.0" once
03:01:04 <dcoutts> even though every file is under the "foo-1.0" directory
03:01:06 <opqdonut> ah yes, read the backlog now
03:01:31 <dcoutts> the trie can be represented in an int array
03:03:04 <mmorrow> dcoutts: ooh, interesting. i did something very similar to that for looking up the package name of a qualified module (this is all somewhat gratuitous, but that's besides the point ;) in a rewrite of lunabot that i recently did
03:03:45 <mmorrow> "Foo.A.B.C" ==> ["Foo","A","B","C"] ==> (Map String Int, Trie Int PackageName)
03:04:41 <mmorrow> dcoutts: (somewhat cluttered atm code) http://moonpatio.com/repos/lunabot/PackageConf.hs
03:06:28 <mmorrow> (modulesToInfo :: PkgConf -> [String] -> [((String,[Int]),[String])] being the top-level wrapper (iirc))
03:07:19 <mmorrow> yeah, modulesToInfo
03:07:56 <mmorrow> although an int array instead of an IntMap sounds nice if the index is immutable
03:08:48 <dcoutts> mmorrow: ah, interesting
03:09:58 <maxote> hi guys, can Agda gives me the answers of x * y = 15 being x,y natural?
03:12:34 <walter_> What does "glob pattern" mean , please?
03:13:01 <opqdonut> unix filename globbing
03:13:02 <Nereid_> walter_: a pattern that matches strings, where * matches any string, etc
03:13:05 <Nereid_> typically for filenames
03:13:06 <opqdonut> stuff like "report*.txt"
03:14:38 <Alpounet> dcoutts, quite interesting
03:15:05 <walter_> Nereid, I am reading the "haskell real world" one topic is "Translating a glob pattern into a regular express"
03:15:45 <walter_> what doesnt it want to do?
03:16:16 <walter_> http://book.realworldhaskell.org/read/efficient-file-processing-regular-expressions-and-file-name-matching.html#glob.translate
03:16:27 <Nereid_> well that describes what glob patterns are
03:16:30 <mmorrow> walter_: ls *.{c,h}
03:18:18 <lowlycoder> are there bindings for opencv?
03:18:26 <lowlycoder> i'm a newb and would prefer to not write my own
03:18:27 <mmorrow> (hmm, although it looks like it doesn't do braces)
03:18:40 <mmorrow> lowlycoder: i'd look on hackage
03:19:10 <lowlycoder> neither opencv nor llvm
03:19:15 <lowlycoder> i thought haskell was productio ntime; psst
03:19:26 <mmorrow> um there're llvm binding
03:19:35 <mmorrow> have you looked on hackage??
03:20:07 <walter_> mmorrow, thanks, I got it.
03:21:21 <Nereid_> lowlycoder: there don't seem to be bindings for opencv
03:21:30 <Nereid_> llvm is there though
03:21:57 <Nereid_> @hackage LLVM
03:21:58 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/LLVM
03:22:11 <Nereid_> err
03:22:21 <Nereid_> llvm, lowercase
03:22:41 <Nereid_> need a new hackage :-)
03:23:28 <lowlycoder> 404 Not Found
03:23:28 <lowlycoder> The requested resource was not found: no such package 'LLVM'
03:23:40 <Lemmih> @hackage llvm
03:23:41 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/llvm
03:23:55 <lowlycoder> whao
03:23:56 <lowlycoder> it is there
03:24:00 <lowlycoder> thanks
03:24:30 <pmurias> hi
03:24:54 <Nereid_> bye
03:25:25 <pmurias> are there any debuggers for haskell that work with ghc 6.8.2 or later?
03:32:05 <thoughtpolice> pmurias: ghci has a debugger built in
03:32:42 <pmurias> why was the hat tracer abandoned?
03:33:09 <thoughtpolice> not sure - a lost interest in maintence followed by lots of bitrot?
03:33:45 <pmurias> the usual things ;)
03:45:08 <dhun> I got the following function is the style ok,
03:45:09 <dhun> numberOfColumnsWithDefinedWidth :: [Float]->Int
03:45:09 <dhun> numberOfColumnsWithDefinedWidth a=ncols a 0
03:45:09 <dhun>     where
03:45:09 <dhun>         nlcols (x:xs) acu=
03:45:09 <dhun>             if (x>=0)
03:45:11 <dhun>             then nlcols xs (acu+1)
03:45:13 <dhun>             else nlcols xs acu
03:45:15 <dhun>         nlcols [] acu=acu
03:45:21 <dhun> ?
03:45:22 <opqdonut> please, don't paste it here
03:45:24 <opqdonut> @paste
03:45:24 <lambdabot> Haskell pastebin: http://hpaste.org/new
03:45:28 <opqdonut> in the future :)
03:45:47 <opqdonut> ?src count
03:45:48 <lambdabot> Source not found. Just try something else.
03:45:51 <opqdonut> :t count
03:45:52 <lambdabot> Not in scope: `count'
03:45:56 <opqdonut> gah
03:45:57 <EvilTerran> dhun, well, i'd put more spaces around operators
03:46:03 <dhun> yes
03:46:13 <EvilTerran> and maybe use a guard instead of the if/then/else
03:46:18 <opqdonut> dhun: i'd use a fold or somthing instead of writing ncols out
03:46:23 <dhun> no I was thinking about having to factor out rercursin
03:46:27 <EvilTerran> but otherwise, as a direct implementation, it looks fine
03:46:28 <opqdonut> length . filter
03:46:38 <dhun> ok
03:46:38 <EvilTerran> yeah, length . filter (>=0)
03:46:45 <EvilTerran> ?type length.filter (>=0)
03:46:46 <lambdabot> forall a. (Num a, Ord a) => [a] -> Int
03:47:03 <dhun> I see
03:55:41 <dhun> there is an other function, where I am unsure about the style http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5867#a5867
03:57:58 <dhun> so I keep it like that
03:58:49 <opqdonut> dhun: zipWith max xs ys
03:58:51 <opqdonut> is the same
03:59:06 <opqdonut> oh, not quite
03:59:15 <opqdonut> different behavious when the lists aren't of equal length
03:59:38 <dhun> I was just looking that up
03:59:54 <opqdonut> yeah that's pretty good style
04:00:19 <opqdonut> you might want to factor the recursion you use there into "zipWithWithDefault" or something, but not necessarily
04:00:37 <dhun> ok I will keep it the way it is
04:08:17 <dhun> can I make that shorter       getList=fst (mapAccuL (\x y->(getpairmax x y,0)))
04:08:58 <beli> hi there, i am searching for a w32 package of haskell...there are some, but which are most popular?
04:09:17 <EvilTerran> ?type mapAccumL
04:09:18 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
04:09:25 <die_sekte> beli: http://hackage.haskell.org/platform/
04:09:34 <die_sekte> de-facto standard package
04:09:49 <beli> die_sekte: thanks a lot
04:10:15 <EvilTerran> dhun, looks like foldl getpairmax to me
04:10:22 <dhun> ok
04:10:29 <beli> i have some knowledge of sml already...where are the main differences to haskell?
04:10:36 <dhun> EvilTerran you are right
04:11:10 <EvilTerran> beli, we have typeclasses, lazy evaluation, and constrained side-effects, sml has parameterised modules, strict evaluation, and unconstrained side-effects
04:12:26 <beli> EvilTerran: ok, i will read on that, thanks
04:13:04 <beli> i am going to use haskell for solving euler project problems
04:14:49 <maxote> is there any tool of finding automatically artificial theorems from the computer starting from lemmas?
04:15:17 <horms> coq?
04:15:34 <maxote> horms, i discussed coq 1 minute ago, and it can't
04:15:46 <horms> sorry, i wasn't listening :-(
04:15:49 <altmattr> maxote: then no
04:15:53 <flux> maxote, I've read a story about such a piece software, but I don't remember its name nor if it's available :)
04:16:09 <flux> also I think there was a chance that the article was written by a crackpot, so..
04:17:20 <flux> however the article went that it did find some already-known and some new theorems, but eventually it just continued finding 'useless' theorems
04:17:52 <altmattr> coq is still the best 'automatic' theorem prover around
04:18:06 <altmattr> so if coq can't do it, you can be pretty sure it can't be done (yet)
04:18:23 <sioraiocht> altmattr: lol wut?
04:18:34 <flux> got the coq book on my bookshelf but I haven't brought myself to study it through, yet :/ <- busy, lazy, etc
04:18:45 <maxote> altmattr, not a theorem prover, it a theorem finder (and uses theorem prover to check them)
04:19:20 <sioraiocht> altmattr: there are things that coq can't express as a limitation of its logic
04:19:27 <sioraiocht> altmattr: and what about isabelle?
04:19:54 <altmattr> sioraiocht: indeed, the experience people around me have is that in practice, the two are as good as each other
04:20:11 <altmattr> sioraiocht: I was going to mention isabelle and then just ....
04:27:17 <maxote> when Haskell enumeration is used, [(x,y) | x <- [0..], y <- [0..], x*y==15] never finish, but when a new artificial theorem is found by the theorem finder as x<=15, y<=15, it [(x,y) | x <- [0..15], y <- [0..15], x*y==15] can finish and answer [(1,15),(3,5),(5,3),(15,1)] at a finite time of computation (except the time of the theorem finder that will be stoped when the computation of the main thread is finished).
04:35:45 <beli> basic question: how do i access the positions of an integer? or do i have to make a list from the integer?
04:35:46 <maxote> i believe that such theorem finder can use Genetic Algorithms to find the logic expressions of the open world
04:36:33 <maxote>  /Genetic Algorithms/Genetic Programming/   sorry
04:37:10 <beli> fot the sum of a list i would use sth. like foldr (+) 0 [1,4,6,123]...but howto sum over an integer?
04:37:44 <dibblego> beli, what do you mean sum over an integer?
04:38:00 <die_sekte> do you mean the digit sum?
04:38:04 <beli> dibblego: let n = 123634  and i want to calculate 1+2+3+6+3+4
04:38:13 <die_sekte> ah, digit sum
04:38:33 <beli> i could use sth. like modulo and sum it....but isnt there a native way to access digits?
04:38:34 <dibblego> beli, how would you think it can be achieved?
04:38:43 <dibblego> @type intToDigit
04:38:45 <lambdabot> Int -> Char
04:39:04 <beli> dibblego: ah, type conversion...ok thanks
04:39:20 <dibblego> I don't think that's what you want -- but what else could you mean by "a native way to access digits"?
04:39:54 <dibblego> you might like to know about the unfoldr function and create Int -> [Int]
04:39:58 <maxote> even such logic expressions (maybe shorter strings) can be artificial theorems validated by the theorem prover
04:40:05 <harlekin> Is there some language flag I have to enable to use type families? For now I only get a parse error when having type family Get f p in my code.
04:40:51 <wli> let f 0 = 0 ; f n | n < 10 = n | otherwise = let (q, r) = n `divMod` 10 in r + f q
04:42:32 <beli> wli: that was my idea with modulo operation, but i thought there might be something haskell native ;)
04:44:07 <wli> beli: Not sure what would be "more native."
04:44:37 <beli> wli: sth. like n[4]
04:44:46 <beli> wli: like with lists and stuff
04:45:26 <Alpounet> backprop algorithm left to write, heh.
04:46:01 <beli> ah found what i was searching for: show n ...converts to string
04:46:27 <wli> beli: There's unfoldr but you just fold back again. Better to just write out the recursion explicitly.
04:47:04 <maxote> in a near future, many mathematicians will ask, who invented this new theorem? many will say, it was invented by the grid of computers.
04:47:26 <idnar> maxote: in soviet russia, theorems invent you!
04:48:30 <mauke> beli: numbers are not stored in decimal
04:48:55 <maxote> isabelle and coq are good candidates to be computed in parallel, each other will abort inmediately the another when each other is finished.
04:49:00 <beli> mauke: explain please
04:49:22 <mauke> numbers don't have digits. the string representation of a number has digits.
04:50:12 <yitz> > let digits = map (`mod` 10) . takeWhile (> 0) . iterate (`div` 10) in sum . digits $ 2357 -- <== beli
04:50:13 <lambdabot>   17
04:50:28 <liyang> maxote: regarding #agda, yes, if you implement a factorisation algorithm.
04:51:01 <beli> yitz: i know there are many solutions to sum it that way...but i thought maybe haskell has some internal function or notation for it....thats all ;)
04:51:42 <dibblego> beli, what is the difference between an "internal function" and the digits function given?
04:52:00 <opqdonut> he meant something in the Prelude probably
04:52:11 <yitz> beli: That's the classic haskell way to do it - composing higher-level functions, avoiding writing out recursion by hand when possible.
04:53:21 <ivanm> dibblego: were you meaning to have the BFG IRC session tonight, or next sunday?
04:53:30 <dibblego> ivanm, next Sunday
04:53:37 <ivanm> ahhhh
04:53:50 <RayNbow> hmm, is the MonadPlus instance for Omega broken?
04:53:54 <ivanm> I thought tonight for some reason, and found it weird that no-one was saying anything definite :s
04:55:04 <harlekin> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2757#a2757 Why are definition 3 and 4 conflicting? Can't I check for type equality in type functions?
04:55:29 <maxote> artificial theorems can be strings in polish notation, and maybe shorter! (am i remembering to Kolmogorov?) xD
04:55:52 <ivanm> harlekin: you can't have an instance inside the type definition AFAIK
04:56:04 <ivanm> even the first one doesn't make sense...
04:56:23 <harlekin> ivanm, why not?
04:56:36 <ivanm> because you have "family" in there
04:56:37 <RayNbow> hmm... hpaste.org is receiving spam?
04:56:47 <ivanm> you can't have a non-capitalised term there
04:56:51 <ivanm> RayNbow: :o
04:57:19 <RayNbow> http://hpaste.org/ <-- 5870, 5851, and 5847 are spam
04:58:00 <harlekin> ivanm, so `type family Get i is' is wrong in general? Or what do you mean?
04:58:09 <ivanm> yes, it's wrong
04:58:18 <ivanm> it's not valid haskell
04:58:34 <harlekin> How's it any different from the haskell wiki? "type family F a :: *
04:58:36 <harlekin> "?
04:58:40 <ivanm> RayNbow: yay, we're popular now? :s
04:58:45 <harlekin> http://www.haskell.org/haskellwiki/GHC/Indexed_types
04:59:17 <ivanm> harlekin: I take it back, I didn't know about that extension
04:59:28 <RayNbow> ivanm: but don't we have to avoid success at all cost?
04:59:34 <harlekin> ivanm, ok. (: You got me worried. ^^
04:59:35 <wli> Well, you could always do sum . unfoldr (\n -> if n == 0 then Nothing else Just . uncurry (flip (,)) $ divMod n 10)
04:59:35 <ivanm> RayNbow: true
05:00:11 <maxote> and i will need a learning's map (ala Kohonen?) to localizate the environments of the found artificial theorems too.
05:00:27 <maxote> it will be a multidimensional map
05:02:33 <RayNbow> ivanm: do you know who maintains hpaste.org?
05:02:50 <ivanm> mauke maybe?
05:03:08 * ivanm seems to recall that the nick starts with an 'm'...
05:03:45 <RayNbow> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hpaste <-- I'm not sure whether the author of hpaste also maintains the site
05:03:53 <wli> Hmm. I don't like the digits affair.
05:04:16 <die_sekte> is the maintainer of the Mac OS X package of the haskell platform on here?
05:04:38 <ivanm> RayNbow: IIRC, it's been rewritten since then
05:04:41 <ivanm> note the date ;-)
05:04:51 <RayNbow> ah, right
05:04:55 <themroc> wow :) lots of people here
05:04:58 <themroc> hello to *
05:06:15 <yitz> wli: what don't you like?
05:06:52 <yitz> die_sekte: try #ghc
05:07:00 <die_sekte> yitz: thx
05:07:05 <themroc> what is the best tutorial for haskell?
05:07:09 <wli> Separating out the div and mod operations. It's purely aesthetic and subjective.
05:07:23 <themroc> im doing http://learnyouahaskell.com/ and its pretty good i think
05:07:43 <yitz> wli: divMod does that internally anyway
05:07:50 <die_sekte> real world haskell is also quite good
05:08:02 <die_sekte> (and available online!)
05:09:13 <wli> Shouldn't divmod use built-in CPU division operations producing both quotients and remainders and thereby only issue a single division instruction?
05:09:14 <yitz> themroc: there's also the wikibook - more terse, gets into more advanced topics, but well written.
05:09:43 <yitz> themroc: between those 3 - you're doing great!
05:09:55 <themroc> i started to learn haskell yesterday for university stuff, so i think im still on the total basic understanding level :p
05:10:14 <yitz> themroc: sounds good :)
05:11:53 <idnar> @src divMod
05:11:54 <lambdabot> Source not found. My mind is going. I can feel it.
05:12:04 <idnar> heh
05:12:15 <yitz> wli: I suppose it should. Though in most cases that's really not important.
05:12:27 <themroc> you guys help total newbies for homeworks? like giving hints for the right approach?
05:12:37 <themroc> or is it more like rtfm
05:13:12 <Saizan> no rtfm
05:13:12 * wli has some strange aesthetic sense demanding it, likely unshared by many.
05:13:21 <Saizan> you can ask if you get stuck on something
05:13:27 <die_sekte> thedward: depends on the obviousness of the question
05:13:57 <themroc> ok
05:14:11 <themroc> i will try to do it on my own first :p
05:14:11 <die_sekte> I think #haskell is the most newbie-friendly channel of all those that I know
05:14:26 <themroc> some c chans just hate newbies
05:14:46 <ivanm> hlint++
05:15:04 <Saizan> http://haskell.org/haskellwiki/Homework_help <- here's the "policy" of the channel :)
05:15:37 <ivanm> we have a policy? :o
05:16:21 <die_sekte> I was shocked about that too
05:16:31 <ivanm> Saizan: isn't this a better policy? :p http://haskell.org/haskellwiki/Humor/Homework
05:17:08 <yitz> wli: functionally, functions that return a pair are uglier than functions that do just one thing
05:17:42 <RayNbow> I once saw a student in #haskell asking for help for a Haskell lab course I was assisting :p
05:17:50 <ivanm> RayNbow: heh
05:17:54 <ivanm> did you help him? :p
05:17:58 <yitz> wli: what would be beautiful is if the compiler would detect the use of both div and mod in the same expression, and optimize it to use the single instruction
05:17:59 <die_sekte> 1$ per line of haskell would be quite cheap ...
05:18:20 <ivanm> die_sekte: I think that needs to be updated to take into account inflation
05:18:40 <wli> It can probably do so in some very limited situations.
05:18:51 <yitz> RayNbow: #haskell users are explicitly warned about that on the homework help page
05:19:01 <RayNbow> ivanm: I first asked whether he was a TU Delft student :p
05:19:09 <ivanm> heh
05:19:21 <ivanm> see, I don't have that problem because Haskell isn't taught here :(
05:19:40 <RayNbow> that sucks
05:19:52 <Alpounet> neither here :/
05:20:10 <RayNbow> although in Delft, the Haskell course is quite limited
05:20:49 <tomh> didnt knew they had haskell on tudelft
05:21:07 * pem is away: Gone away for now
05:21:17 <RayNbow> tomh: currently it's a first year course
05:21:36 <tomh> required or optional?
05:21:56 <RayNbow> the lab course assignments cover recursion, list functions and comprehensions, some I/O and an assignment on binary search trees
05:21:58 <RayNbow> required
05:22:08 <harlekin> Is there a good reason noone has uploaded a library containing providing the statically types printf and scanf functinality as described in the Paper "Fun with type functions"?
05:22:13 <tomh> ok
05:22:43 * RayNbow is probably one of the few students in Delft that really loves Haskell :p
05:22:44 <tomh> how much ects is the course?
05:23:08 * beli is off...thanks for all the help so far
05:23:20 <RayNbow> tomh: don't know, let me look it up :)
05:23:48 * RayNbow took the old version of the Haskell course from the old program :p
05:24:25 <RayNbow> tomh: 4 ects, but the course also includes a basic intro to C
05:24:41 <tomh> ok
05:25:41 <themroc> hmmmm ... let a = 1 ... that should work in the hugs bash?
05:25:53 <themroc> i get ERROR - Syntax error in expression (unexpected end of input)
05:26:04 <RayNbow> themroc: "let a = 1" only works in ghci
05:26:13 <tomh> ok
05:26:29 <tomh> we dont have C in any course here i think
05:26:40 <mauke> heh, "the hugs bash"
05:26:45 <themroc> well
05:26:50 <themroc> winhugs im using :p
05:27:03 <RayNbow> tomh: where's "here"? :)
05:27:15 <themroc> but isnt "let" fundamental?
05:27:26 <tomh> the university in holland where the teachers hate you if you dont love haskell :P
05:27:56 <elbar> must be a good uni then =)
05:28:15 <tomh> yeah can't complain :)
05:29:45 <Valodim> around here for projects it's mostly "of course you can use any language you like for your assignments.. and if it's java, there won't even be any problems with it"
05:30:08 <tomh> here the language requirements are strict
05:30:08 <RayNbow> themroc: the syntax is "let ... in ..."
05:30:25 <tomh> its usually either haskell or java
05:30:39 <tomh> there are rarely assignments where you can pick
05:32:13 <RayNbow> themroc: the "let ..." syntax only appears in do-blocks and list comprehensions
05:42:55 <mxc> good morning/day/evening #haskell
05:43:16 <mxc> have a question if anyone is around on sunday..
05:45:00 <RayNbow> mxc: just ask :)
05:45:14 <mxc> working on it, its a fair bit fo typing :)
05:46:20 <mxc> i'm working on implementing a protocol in haskell.  in this protocol, there is a large universe of key-value field types and a smaller number of message types where each message consists of a subset of the universe of fields..  trying to figure out the cleanest representation.
05:46:22 <mxc> my initial thinking is to have a data Field = F1 String | F2 Int | F3 Date....  and then each message type would be a record consisting of the desired fields
05:47:05 <mxc> but, giving the way records work in haskell, the name collisions would be terrible and there are too many fields per message to really use tuples or just data constructors with a lot of arguments (i know you can, but it feels unclean)
05:47:59 <mxc> alternatively, could define a module for each message type and use overlapping names (since each message is its own module) but that means anything using this protocol would need somehting liek 50 extra qualified imports
05:48:52 <mxc> i'm wondering if there is a better way, perhaps with some of the more advanced typing that I'm not too familiar with htat might be a better solution
05:49:30 <mxc> I realize that i could represent messages as a key/value map, but I'd like to use the type system to enforce well-formedness of messages
05:51:54 <Axman6> mxc: maybe a class?
05:52:03 <themroc> can i have nested if statements in haskell?
05:52:09 <Axman6> yes
05:52:24 <Axman6> well, i think so
05:52:47 <voker57_> why not
05:53:00 <harlekin> > if True then if True then putStrLn "yes!" else putStrLn "inner noes!" else putStrLn "outer noes!"
05:53:01 <lambdabot>   <IO ()>
05:53:11 <harlekin> Well. O: Forgot about that IO stuff. ^^
05:53:11 <Axman6> > (\x -> if x > 5 then if x < 10 then "medium" else "large" else "small) 7~
05:53:11 <mxc> themroc - for some reason, i always have trouble with if statements, I just use case (val) of True -> ... ; False ->
05:53:12 <lambdabot>   <no location info>:
05:53:12 <lambdabot>      lexical error in string/character literal at end o...
05:53:13 <Axman6> > (\x -> if x > 5 then if x < 10 then "medium" else "large" else "small) 7
05:53:14 <lambdabot>   <no location info>:
05:53:14 <lambdabot>      lexical error in string/character literal at end o...
05:53:41 <themroc> i thought of case, but the decissions are not bound to one variable
05:53:51 <mxc> huh?
05:54:22 <mxc> case (a) of True -> (case (b) of True -> ... ; False -> ...) ; False -> ...
05:54:30 <themroc> hmmm
05:54:43 <themroc> i have a function with 4 parameters
05:54:59 <themroc> first it should check if two of the parameters are equal
05:55:16 <themroc> if not it should check if another function with some of the parameter succeedes
05:55:38 <walter_> In  return True :: Logger Bool  , what does the True :: Logger Bool mean? Convert True to Logger Bool?
05:55:54 <themroc> but maybe my thinking is totally wrong :p
05:56:05 <redocdam> I am writing a Gentzen prover in Haskell, up till now I have just stored sequents in lists but I am considering using Data.Set or something to quicker check if items occur in two sets(checking for axioms). How can I still iterate through the sets and perform pattern matching on the items then?
05:56:28 <Botje> walter_: return :: a -> m a, for any monad m
05:56:37 <mxc> \a b c d -> case (a == b) of True -> bothTrue ; False -> (case (f2 c d) of True -> f2Suceeded; False -> f2AlsoFailed)
05:56:39 <Botje> Logger is such a monad, so return :: a -> Logger a
05:56:41 <mxc> something like that
05:57:06 <mxc> themroc but in your actual code, you can use layout to make it much much more readable
05:57:24 <Botje> the explicit type annotation is probebly for "locking" the inferred type to Logger a
05:57:27 <mxc> themroc > because of laziness, you can do much better
05:57:45 <walter_> Botje, So return just wrap True with Logger Bool?
05:58:36 <mxc> \a b c d -> (case ((a == b), (f2 c d)) of (True, _) -> firstVal; (_, f2Result) -> f2Result)
05:58:41 <themroc> hmm ic
05:58:43 <Botje> return takes a True and injects it into the Logger monad, yes
05:58:54 <themroc> yeah its my 2nd haskell day, im not quite into the stuff
05:58:58 <mxc> becuase of laziness, the f2 c d is never called if the first case matches
05:58:58 <themroc> too much oop so far
05:58:59 <themroc> :p
05:59:01 <walter_> Botje, Thank you.
05:59:14 <mxc> themroc - give it time, eventually you'll blow your mind
05:59:31 <mxc> and i'm still very much a beginner
05:59:32 <yitz> redocdam: Data.Set.toList
06:00:19 <themroc> what exactly means the -> in your example mxc?
06:00:38 <mxc> http://en.wikibooks.org/wiki/Haskell/Control_structures
06:00:40 <redocdam> yitz: Yes, it seems that is the best route
06:00:43 <yitz> walter_: type annotations do not convert a value from one type to another - you can only do that by applying an explicit conversion function.
06:00:47 <themroc> ok thx
06:01:38 <mxc> themroc > this book is excellent: http://book.realworldhaskell.org/
06:01:44 <yitz> walter_: rather, they let the type-checker know what type that thing was to begin with, in cases that polymorphism makes it unclear what you meant.
06:01:54 <mxc> themroc > peruse a bit online, but you should buy it, the authors are regulars here and always very veyr helpful
06:02:25 <walter_> yitz, undertand. so Why put ::Logger Bool  here
06:02:49 <walter_> just to tell return the wrap type?
06:04:02 <themroc> thanks mxc
06:04:03 <yitz> walter_: right. "return" is polymorphic, it could be any monad
06:04:37 <yitz> walter_: you could mean [True], Just True, etc.
06:05:06 <yitz> walter_: usually, the type checker can work out from the overall context what you meant. it's very smart. but occasionally, you need to help it.
06:07:21 <walter_> yitz, thank you!
06:07:37 <Baughn> walter_: Without extensions (or with most extensions), the type-checker will /always/ find the correct type if that's possible at all
06:07:54 <Baughn> So if it's complaining about ambiguity, that's because there genuinely isn't enough information in the program for it.
06:13:27 <themroc> hmm somebody could take a look at http://pastebin.com/d7658902d ?
06:15:13 <themroc> hmmm, sorry, nevermind, lets read thru the tutorial first
06:16:53 <die_sekte> themroc: what do you want to accomplish?
06:17:46 <themroc> get a list of highly composite numbers
06:18:19 <themroc> http://en.wikipedia.org/wiki/Highly_composite_number
06:18:38 <die_sekte> ah
06:19:10 <wli> Define "highly composite."
06:19:27 <themroc> look at the wiki
06:19:40 <themroc> im fighting how to call a function properly :p
06:20:06 <die_sekte> f arg1 arg2 ... argN
06:20:17 <themroc> in the pastebin i posted i wanna call next again
06:20:36 <themroc> i try with "next (min+1) teiler max max add (list min)" but it doesnt work
06:20:46 <wli> oh boy that's going to be tough
06:21:09 <themroc> i did in c, its quite short
06:21:12 <themroc> not efficient but works
06:21:19 <themroc> so i try to adapt from that :p
06:21:47 <die_sekte> I think you will need two steps: (a) produce a list of pairs, containing each number and the number of its divisors
06:22:19 <themroc> and then kill the wrong ones out
06:22:33 <die_sekte> (b) filter this list of pairs, eliminating any number which has fewer divisors then a preceding one
06:22:43 <themroc> i thought of another:
06:22:45 <die_sekte> adapting c into haskell usually ends bad
06:23:00 <themroc> i have a recursive function
06:23:05 <themroc> which gets 4 parameters:
06:23:14 <die_sekte> you could probably do that in a single fold
06:23:37 <themroc> last number, amount of composites of that number, maximum limit, and a list of found numbers
06:23:50 <themroc> and the function first checks if the max is reached
06:23:55 <themroc> which results in the return of the list
06:24:20 <die_sekte> just use an infinite list
06:24:23 <themroc> if not, it checks if the amount of composited of the next number is bigger then last
06:24:51 <die_sekte> I have to eat cake now, will be back soon
06:24:53 <themroc> if yes, add to list and call itself again, if not, call itself without the number again
06:52:41 <Axman6> "The Church-Turing Thesis: Story and Recent Progress" sounds like a very haskellish google tech talk...
06:53:14 <die_sekte> themroc: amazingly, this works: http://pastebin.com/m9942e63
06:53:22 <Botje> pffrt. I'd rather hear about the Turing-Lovecraft theorem
06:55:16 <Axman6> Botje: theorem snob :P
06:55:20 * pem is back.
06:55:40 <MyCatVerbs> Axman6: theorem cultist. Ia! Ia!
06:56:05 <Botje> http://www.nesfa.org/reviews/Olson/AtrocityArchives.html # for those who have never heard of the turing-lovecraft theorem :)
06:58:20 <die_sekte> calculating highly composite numbers takes a looong time. I must have done something wrong
07:00:16 <Berengal> die_sekte: Yes, you need to properly factorize numbers, not just try dividing every number between 1 and n...
07:00:36 <gwern> the number of these nemesis uploads is getting a bit excessive...
07:01:19 <gwern> '2009.6.12, 2009.6.13, 2009.6.13.1, 2009.6.13.2, 2009.6.14, 2009.6.14.1, 2009.6.14.2, 2009.6.14.3'
07:01:34 <gwern> in just 2 days there've been 8 uploads?
07:01:46 <die_sekte> Berengal: I'm not sure if I understand you. Getting the numbers and the number of their divisors is quite fast.
07:02:21 <Berengal> die_sekte: No, it's not
07:02:42 <Berengal> Try finding the number of divisors in 4294967296
07:02:53 <die_sekte> Yeah, I was wrong
07:03:02 <gwern> @quote fire
07:03:03 <lambdabot> byorgey says: sometimes asking #haskell for help can be like taking a drink from a fire hose
07:03:06 <gwern> @quote fire
07:03:07 <lambdabot> bootslack says: Once, around the time of the discovery of fire, there was a large population of people that thought mastering fire would be too difficult so they didn't. The rest of us killed them,
07:03:07 <lambdabot> cooked them and ate them.
07:03:11 <gwern> @quote fire
07:03:12 <lambdabot> wli says: brb kitchen fire
07:03:16 <gwern> @quote fire
07:03:16 <lambdabot> byorgey says: sometimes asking #haskell for help can be like taking a drink from a fire hose
07:03:24 <gwern> @quote burn.*fire
07:03:24 <lambdabot> sjanssen says: in our sub-culture, it ["considered harmful"] means [not "not always good" but] "burn it with fire"
07:03:29 <themroc> hmm dibblego
07:03:31 <themroc> oops
07:03:33 <themroc> die_sekte
07:03:34 <gwern> @quote reckoned
07:03:34 <lambdabot> quicksilver says: after all, anyone who insists on talking about himself in the third person is clearly someone to be reckoned with.
07:03:38 <gwern> @flush
07:03:50 <themroc> it takes a long time in general
07:03:56 <themroc> my final solution looks like this:
07:04:27 <themroc> http://pastebin.com/m4e0bd398
07:05:52 <themroc> i dont really understand your code die_sekte :p
07:06:09 <die_sekte> themroc: Yeah, I have a hard time doing that myself
07:06:30 <Berengal> What is it you are trying to do?
07:06:34 <die_sekte> num_divisors and num_list should be quite easy
07:06:40 <themroc> btw how do i use a bash argument with getArgs?
07:06:50 <die_sekte> Berengal: Getting a list of highly composite numbers
07:07:06 <themroc> i tried convert it to integer
07:07:42 <Berengal> die_sekte: Just highly composite?
07:07:57 <die_sekte> number_less_than is a list of numbers which are smaller than x and their number of divisors
07:08:01 <die_sekte> Berengal: yeah
07:08:52 <Berengal> Why not just create a few lists with randoms and zipWith (*) ?
07:09:28 <die_sekte> I'm not sure if I understand you
07:09:32 <die_sekte> randoms?
07:09:38 <Berengal> @type randoms
07:09:41 <lambdabot> forall g a. (Random a, RandomGen g) => g -> [a]
07:10:08 <die_sekte> I know about randoms, but I don't know how they could help me
07:10:20 <idnar> why isn't that g -> ([a], g)?
07:10:30 <Botje> it's an infinite list :)
07:10:33 <Berengal> idnar: The list is infinite
07:10:37 <idnar> oh, right
07:10:42 <idnar> duh
07:10:55 <Berengal> die_sekte: Create a few lists of random numbers, then just multiply them
07:11:05 <themroc> hmmm
07:11:06 <Berengal> using zipWith
07:11:11 <themroc> its http://en.wikipedia.org/wiki/Highly_composite_number
07:11:33 <themroc> so it always depends on the predecessor
07:12:39 <Berengal> Ah
07:13:28 <die_sekte> have to go. Haskell is way more fun than Shakespeare. :(
07:13:55 <Axman6> damn right it is
07:16:24 <MyCatVerbs> die_sekte_away: Haskell doesn't contain random dick jokes buried in Elizabethan prose, though.
07:17:35 <Baughn> MyCatVerbs: Buried? Shakespeare's jokes?
07:17:40 <Baughn> Surely thou jest
07:18:01 <Baughn> Well, I suppose they might be a little harder to understand today
07:18:15 <opqdonut> Baughn: shouldn't that be jesteth ;)
07:18:29 <Baughn> opqdonut: Ah.. no. At least "thou" is a real word. ^^;
07:19:01 <shapr> Yeah, it's the singular form of "you"
07:19:06 <Baughn> People keep forgetting, though, Shakespeare wrote comedies intended for a low-class audience. And somehow we've ended up putting him on a pedestal..
07:19:21 <shapr> A very bawdy pedestal for those in the know... but still...
07:19:28 <uzytkownik> @hoogle (a -> Bool) -> [a] -> ([a], [a])
07:19:29 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
07:19:29 <lambdabot> Prelude span :: (a -> Bool) -> [a] -> ([a], [a])
07:19:29 <lambdabot> Data.List break :: (a -> Bool) -> [a] -> ([a], [a])
07:19:45 <shapr> It's true, Harlequin Romance is a poor ripoff of Shakespeare.
07:19:46 <MyCatVerbs> Baughn: they're "buried" at least to the extent that people seem to not notice them. :/
07:20:41 <Baughn> MyCatVerbs: Mm. Sometimes I suspect those who claim his works are high culture haven't actually read them.
07:20:47 <skorpan> dons: do you have some sort of automatic hackage->arch cronjob or something? or do you manually add each of them?
07:20:54 <shapr> Baughn: Or maybe they truly understand the human condition.
07:21:01 <Baughn> skorpan: He's got an automaton, yep
07:21:08 <shapr> It's all about bodies slapping together, right?
07:21:21 <Baughn> shapr: Nah. These days we use fire-lances.
07:21:22 <shapr> Wait, how is this about Haskell?
07:21:33 <skorpan> Baughn: cool, so i can blindly count on it adding any new packages in a few days?
07:21:41 <Baughn> skorpan: Pretty much, yep
07:21:52 <Baughn> skorpan: Unless it somehow breaks the script, I suppose..
07:21:57 <skorpan> coolio
07:22:43 <harlekin> I am toying around with type families. Can anyone tell me why this is rejected? I want to express type equality for i in line 9, but apparently it isn't interpreted as intended. http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2759#a2759
07:23:45 <uzytkownik> @pl \x -> return ()
07:23:45 <lambdabot> const (return ())
07:24:10 <skorpan> hmph... what do you do when neither hoogle nor hayoo will find "runProcess" for you?
07:24:40 <uzytkownik> @hoggle runProcess
07:24:41 <lambdabot> System.Process runProcess :: FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> Maybe Handle -> Maybe Handle -> Maybe Handle -> IO ProcessHandle
07:25:01 <skorpan> but i want to know the order of those handles
07:25:04 <skorpan> which is stderr, stdout, etc.
07:25:13 <uzytkownik> skorpan: Check in docs
07:25:31 <uzytkownik> skorpan: http://www.haskell.org/ghc/docs/latest/html/libraries/
07:25:36 <skorpan> thanks
07:26:36 * FunctorSalad beefed up fold-th to support mutually recursive types and specialised recursive positions =)
07:27:38 <FunctorSalad> now I'm wondering what the right folds for mutually recursive families involving higher kinds is
07:27:46 <FunctorSalad> *the right idea of fold
07:28:06 <themroc> hmm if i wanna make my program "runhugs compatible", do i have to take care for the output myself?
07:28:08 <uzytkownik> I have a function of type Type -> IO () and second of type Type -> IO (). How to join them?
07:28:16 <uzytkownik> In pointless way ;)
07:28:24 <FunctorSalad> > liftM2 (>>)
07:28:26 <lambdabot>   Overlapping instances for GHC.Show.Show
07:28:26 <lambdabot>                              (m1 (m...
07:28:30 <FunctorSalad> @type liftM2 (>>)
07:28:31 <lambdabot> forall (m :: * -> *) a b (m1 :: * -> *). (Monad m, Monad m1) => m1 (m a) -> m1 (m b) -> m1 (m b)
07:28:58 <FunctorSalad> id by join you mean "execute one action after the other"
07:29:05 <Baughn> uzytkownik: What do you want to do, exactly? Provide the same input to both, then run them both?
07:29:41 <uzytkownik> Baughn: Yes. I'm tring to make monoid tests.
07:30:23 <Baughn> @pl \a -> f a >> f a
07:30:24 <lambdabot> liftM2 (>>) f f
07:30:30 <Baughn> There you go, then.
07:30:36 <FunctorSalad> *cough*
07:30:38 <Baughn> Actually, suppose the second should be g, but..
07:30:58 <uzytkownik> @pl \a -> f a >> g a
07:30:58 <lambdabot> liftM2 (>>) f g
07:33:08 <iago> @pl (==) 4 . (const 5)
07:33:09 <lambdabot> (4 ==) . const 5
07:41:20 <FunctorSalad> what's the name for this pattern? "f a b c = go c where go = .... recurse on go ..."?
07:42:03 <FunctorSalad> and is there any way to do it for mutually recursive functions without quadratic amount of code (replicating all the go clauses)? ;)
07:43:40 <MyCatVerbs> FunctorSalad: f a b c = fix (\g c -> ...) ?
07:44:18 <FunctorSalad> MyCatVerbs: I mean you have mutually recursive top-level f's
07:45:13 <MyCatVerbs> You mean go recurses on f, rather than f recursing on go?
07:45:18 <FunctorSalad> the only way I can see is "f1 ... = go1 where { go1 = ... ; go2 = ... };   f2 ... = { go2 where go1 = ...; go2 = ... }
07:46:18 <FunctorSalad> the where clauses there are identical for f1 and f2
07:46:37 <FunctorSalad> the point of the gos is that some args don't change during the recursion
07:47:07 <anq> Hah, that is actually legal, 'type :<->: a b = Bijection (->) a b'. Nice.
07:47:29 <FunctorSalad> :)
07:47:38 <MyCatVerbs> Put go1 and go2 at top level.
07:48:05 <FunctorSalad> but then they can't have free vars which are bound by the fs
07:48:31 <MyCatVerbs> Put a version of go1 that takes the formerly free vars as args at toplevel.
07:49:17 <FunctorSalad> I think that would amount to not having the gos at all and just letting the fs call each other
07:52:00 <MyCatVerbs> > let { f1 x y = go1 where { go1 = x:go2 ; go2 = y:go1; }; f2 x y z = intersperse z go1 where { go1 = x:go2; go2 = y:go1; }; } in (take 10 $ f1 'a' 'b',take 10 $ f2 'c' 'd') -- is this an example?
07:52:02 <lambdabot>   Couldn't match expected type `[a]'
07:52:05 <MyCatVerbs> Blast.
07:53:29 <MyCatVerbs> > let { f1 x y = go1 where { go1 = x:go2 ; go2 = y:go1; }; f2 x y z = intersperse z go1 where { go1 = x:go2; go2 = y:go1; }; } in (take 10 $ f1 'a' 'b',take 10 $ f2 'c' 'd' 'x') -- is this an example?
07:53:31 <lambdabot>   ("ababababab","cxdxcxdxcx")
07:54:09 <themroc> hmmm im not able to manage to use an argument from getArgs
07:54:36 <FunctorSalad> MyCatVerbs: yes
07:54:37 <themroc> i know it is there and i just want to convert it to integer in order to call a function with it
07:54:58 <dschoepe> Can anyone confirm that `listAllInfo' from libmpd mixes up the song information and corresponding file paths?
07:55:06 <MyCatVerbs> FunctorSalad: well, in that case, f2 depends on f1 directly.
07:55:20 <FunctorSalad> themroc: "do { int <- read . head `fmap` getArgs; .... }"
07:55:46 <FunctorSalad> (will crash if there are no args or the first one doesn't parse)
07:56:33 <MyCatVerbs> FunctorSalad: infact, in that case, f1 is the function that I would write. f1 there lifts go1 and go2 out, now any other function that uses go1 with free parameters x and y can be written in terms of f1 x y. ^^
07:56:46 <FunctorSalad> MyCatVerbs: logically the gos are unnecessary, it's just for what I assume to be an peformance gain (telling ghc that some args don't change during recursion)
07:57:21 <themroc> let me try FunctorSalad, thx
07:58:04 <FunctorSalad> themroc: I think you need parens around the "read.head"
07:58:24 <FunctorSalad> and you must use the int somehow so the type can be inferred
07:58:47 <themroc> hmm i have a function go :: Int -> [Int]
07:58:55 <FunctorSalad> MyCatVerbs: I'd paste my example if it wasn't a nasty TH dump ;)
07:59:13 <themroc> if it gets called in the main function, do i need to take care for the output too?
08:01:23 <themroc> sorry to ask FunctorSalad i dont understand where the number is put to in your expression
08:01:30 <themroc> and i never used {} so far :p
08:01:46 <MyCatVerbs> FunctorSalad: eep.
08:02:17 <FunctorSalad> MyCatVerbs: cleaned up a bit http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5874#a5874
08:02:57 <FunctorSalad> MyCatVerbs: the pattern binds in the gos lack parens, but that's how TH prints it :)
08:05:09 <FunctorSalad> themroc: the {} after the do don't have any semantic meaning, they just let you write the do block in a single line
08:05:48 <FunctorSalad> (like on irc)
08:06:45 <FunctorSalad> > let doubleM = do { x <- read; return (2*x) } in doubleM [1,2,3]
08:06:46 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
08:06:47 <lambdabot>    arising from the literal `1...
08:06:58 <FunctorSalad> > let doubleM = do { x <- read; return (2*x) } in doubleM ["1","2","3"]
08:06:59 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
08:07:21 <themroc> ah ok FunctorSalad
08:07:28 <FunctorSalad> > let doubleM y = do { x <- read `fmap` y; return (2*x) } in doubleM ["1","2","3"]
08:07:29 <lambdabot>   [2,4,6]
08:07:48 <FunctorSalad> themroc: used the list monad in place of IO there since lambdabot doesn't allow IO
08:08:08 <themroc> we have to use main :: IO()
08:08:11 <themroc>  and getArgs
08:08:14 <FunctorSalad> in your case "y" would be "getArgs"
08:08:28 <FunctorSalad> err, the head of getArgs
08:08:36 <themroc> ok let me try
08:09:12 <FunctorSalad> MyCatVerbs: it seems I can't define foldB in terms of foldA there
08:09:36 <themroc> main :: IO()
08:09:36 <themroc> main = do { x <- (read . head) `fmap` getArgs; go x }
08:09:43 <themroc> that would be wrong i guess
08:10:43 <FunctorSalad> try "print (go x)"
08:11:08 <themroc> oh yeah :))
08:11:18 <themroc> compiling works hehe
08:11:31 <mauke> :t readIO
08:11:32 <lambdabot> forall a. (Read a) => String -> IO a
08:11:43 <mauke> a :_ <- getArgs; x <- readIO a; print (go x)
08:11:46 <mauke> doh ho ho
08:11:59 <themroc> x must be integer
08:14:20 <kynes> I suspect something, is it correct: checking string equality in Haskell is slow?
08:14:36 <mauke> define "slow"
08:14:43 <kynes> slower than python
08:15:01 <mauke> depends
08:15:19 <mauke> it probably is slower for normal sized strings of type [Char]
08:15:35 <Axman6> but for infinite strings, it's way faster!
08:15:57 <themroc> works like a charm FunctorSalad :)
08:16:01 <kynes> I'm generating the strings for randomly created data
08:16:31 <kynes> I'm checking a bunch of abstract data type implementations without Eq defined
08:16:40 <kynes> so I needed to use their show outputs
08:16:47 <kynes> I know, it's stupid in real life
08:16:55 <kynes> but these are just a bunch of codes to be checked
08:18:01 <koeien> that the output of show is the same, does not mean that the datastructures are equal, or the other way around
08:18:05 <kynes> oh, it also can be that checking equality with default Eq (deriving Eq, I mean) is faster
08:18:15 <kynes> koeien, yes yes I know
08:18:30 <kynes> koeien, but I'm not checking equality of implementation
08:18:40 <kynes> koeien, I'm checking equality of interface
08:19:01 <kynes> koeien, I mean I'm just checking the effects
08:19:25 <koeien> i'm not sure what you're doing, i was just pointing out the obvious ;)
08:22:14 <kynes> koeien, sure :) thank you for reminding
08:23:44 <dhun> widthOfcolumn,  widthOfColumn are different function, and haskell has no way waring you
08:24:23 <koeien> dhun: :( yes
08:24:41 <koeien> except that you didn't define all possible patterns (if you have -Wall)
08:24:48 <dhun> ok
08:24:52 <ehird> @hoogle [a] -> Int -> a -> [a]
08:24:52 <lambdabot> Prelude enumFromThenTo :: Enum a => a -> a -> a -> [a]
08:24:52 <lambdabot> Data.IntMap findWithDefault :: a -> Key -> IntMap a -> a
08:24:52 <lambdabot> Distribution.ParseUtils IfBlock :: LineNo -> String -> [Field] -> [Field] -> Field
08:24:53 <dhun> thats interesting
08:28:45 <dhun> is it a good idea to rework the code so that -Wall runs without Warnings?
08:29:06 <trofi> why not?
08:29:24 <trofi> let compiler be your friend
08:29:26 <dhun> it seems to be quite a bit of work
08:29:28 <Axman6> can't hurt
08:29:39 <Axman6> probably means you're not writing nice code then ;)
08:30:18 <trofi> there is some nasty warnings like name scope hiding
08:30:33 <ehird> does anyone else do (foo $ A { b }) even though (foo A { b }) is valid because it looks wrong? :-)
08:30:49 <mauke> foo A{ b }
08:30:54 <ehird> ew
08:30:58 <mauke> YES
08:31:00 <Axman6> yeah, i prefer mauke's
08:31:42 <Axman6> it's clearer that the stuff in the {...}'s is connected to the A
08:36:17 <ksf> dons, is the software of rwh available?
08:38:50 <uzytkownik> @hoogle Socket -> IO SockAddr
08:38:50 <lambdabot> Warning: Unknown type Socket
08:38:50 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
08:38:50 <lambdabot> Foreign.Marshal.Utils with :: Storable a => a -> (Ptr a -> IO b) -> IO b
08:47:41 <opqdonut> shouldn't "catch (evaluate $ div 1 0) something" run something
08:47:54 <opqdonut> i just get a divide by zero exception
08:48:22 <ksf> that's an error, not an IO exception iirc
08:48:38 <Saizan> opqdonut: are you using Control.Exception.catch ?
08:48:46 <opqdonut> no, Prelude
08:48:55 <Saizan> that's your problem :)
08:49:17 <opqdonut> ah yes
08:49:48 <Berengal> Is there something like tryGetLine in the libs, or do I have to use timeout myself?
08:50:56 <dhun> Saizan I re-factored the real code according to you ideas, it is still not really nice but I applied it to the functions treeToImages and treeToLatex
08:51:05 <dhun> http://de.wikibooks.org/wiki/Benutzer:Dirk_Huenniger/haskell
08:57:58 <Saizan> dhun: i'd align all the "=" for nodeToLatex to the same column
08:58:27 <Saizan> dhun: and i'd use indentation instead of { ; }
09:00:51 <Berengal> { ; } gives me flashbacks to a time where I did most of my programming is horrible type systems...
09:01:43 <dhun> putting the equal signs to the same column is ok
09:02:46 <dhun> identation is a bit diffcult I think, I don't have so many columns in my editor and if I indent the rows get longer
09:09:25 <dhun> but maybe I can just use a smaller font:-)
09:10:12 <Saizan> you can split the lines anywhere you like
09:10:24 <Saizan> and use less spaces for indentation
09:10:28 <Saizan> 2 is enough
09:14:32 <Berengal> 1 is enough, no?
09:14:44 <Berengal> I mean, technically...
09:16:01 <skorpan> should be, afaik
09:16:09 <dhun> yes I could do with two spaces
09:16:39 <codebliss> @pf \a b -> (a^2) + (b^2)
09:16:40 <lambdabot> Maybe you meant: bf pl
09:16:56 <Berengal> Haskell does have a tendency to march off to the right if you're not careful...
09:17:02 <skorpan> @pl \a b -> (a^2) + (b^2)
09:17:02 <lambdabot> (. (^ 2)) . (+) . (^ 2)
09:17:07 <codebliss> YES thanks
09:17:11 <codebliss> He'll get a laugh lol
09:17:14 <skorpan> hm.. that can be done with "on" or something i think
09:17:29 <skorpan> there is some function you want here, maybe it's "on"
09:17:34 <skorpan> can't remember the name
09:17:36 <skorpan> @src on
09:17:37 <lambdabot> (*) `on` f = \x y -> f x * f y
09:17:40 <skorpan> yes, it's on
09:17:58 <skorpan> maybe not though
09:17:59 <Berengal> (+) `on` (^2)
09:18:11 <skorpan> > (+) `on` (^2) $ 2 2
09:18:12 <lambdabot>   Precedence parsing error
09:18:12 <lambdabot>      cannot mix `Data.Function.on' [infixl 0] and ...
09:18:17 <Berengal> > ((+) `on` (^2)) 2 3
09:18:18 <lambdabot>   13
09:18:46 * pem is away: Gone away for now
09:19:12 <Berengal> Maybe it's just me, but I prefer prefix functions... with that in mind, I'd like it if the arguments to on were flipped
09:19:28 <Berengal> so 'on (^2) (+)'
09:19:43 <opqdonut> that would make "on x" more useful?
09:19:49 <Berengal> sortBy (on fst compare)
09:19:53 <codebliss> @src on
09:19:54 <lambdabot> (*) `on` f = \x y -> f x * f y
09:19:54 <opqdonut> mhmm
09:20:01 <mauke> comparing fst
09:20:03 <codebliss> Where is on?
09:20:12 <Berengal> Data.Function
09:20:29 <codebliss> Berengal: Thanks!
09:20:44 <Berengal> opqdonut: Can't make it less useful...
09:21:20 <Berengal> Well, it could, actually...
09:21:52 <Berengal> But at least it would read better
09:25:13 <FunctorSal> is there a way to thwart the TH pretty printer from wasting all the space on a type variable quantifier and then printing the rest all in a few columns...?
09:25:34 <FunctorSal> I tried these "ribbon" settings but they don't seem to do anything
09:41:55 <dsfsf> hello can some 1 help me
09:42:13 <mauke> unknown
09:42:46 <dsfsf> i wish to know where Procedural Language is being used ?
09:42:53 <mauke> huh?
09:43:10 <dsfsf> i need a exmaple of where Procedural Language: is being used
09:43:33 <mauke> in GORILLA.BAS
09:43:41 <dsfsf> whats that?
09:44:33 <mauke> http://en.wikipedia.org/wiki/Gorillas_(computer_game)
09:44:38 <dsfsf> thank you
09:48:11 <roconnor> @pl \(a,b) -> (b,a)
09:48:11 <lambdabot> uncurry (flip (,))
09:58:43 <ksf> roconnor, divMod, unfold?
09:59:54 <FliP^2eH> !hpaste
09:59:58 <FliP^2eH> ?hpaste
09:59:59 <lambdabot> Haskell pastebin: http://hpaste.org/new
10:00:13 <FliP^2eH> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5877#a5877
10:00:25 <FliP^2eH> Why do I keep getting "Overlapping pattern" for line...
10:00:31 <FliP^2eH> 4?
10:00:43 <FliP^2eH> It should not overlap
10:01:11 <dmwit> It overlaps with the _ case.
10:01:13 <FliP^2eH> The _ should just capture anything not captured by the first one. This is the only pattern that complains, many others with the same layout work without warning
10:01:19 <int-e> FliP^2eH: 'myNick' binds a new variable
10:01:27 <dmwit> Both myNick and _ capture everything.
10:01:46 <FliP^2eH> Meh, why?
10:01:56 <int-e> FliP^2eH: it does not compare the result of userNick ... with the previously defined myNick variable. You have to use == for that.
10:01:57 <dmwit> FliP^2eH: Note that myNick is binding a *new* variable that shadows the old "myNick".
10:02:00 <FliP^2eH> I thought it'd run the action and return a clean veriable
10:02:05 <FliP^2eH> Ohhh
10:02:08 <ksf> FliP^2eH, because it's a variable name, not a constructor. you want to use an if.
10:02:16 <FliP^2eH> Now I got it
10:02:24 <FliP^2eH> Yeah right, pattern variables
10:02:27 <FliP^2eH> Didn't think about it
10:02:42 <FliP^2eH> I'm thinking in C dimensions again :)
10:02:43 <FliP^2eH> Thanks!
10:04:49 <FliP^2eH> Erm erm
10:04:53 <FliP^2eH> Just a quick reminder
10:05:05 <FliP^2eH> I've got a list of not-yet-ran actions
10:05:11 <FliP^2eH> How do I run them all? :)
10:05:30 <FliP^2eH> [putStrLn "", putStrLn ""] like that
10:05:37 <dmwit> :t sequence
10:05:38 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
10:05:40 <FliP^2eH> :)
10:05:41 <dmwit> :t sequence_
10:05:42 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
10:05:44 <Lemmih> FliP^2eH: sequence_
10:06:13 <FliP^2eH> Thank youuu
10:06:25 * Lemmih is too slow.
10:08:05 * shapr is slower!
10:11:40 <FliP^2eH> leandrom_
10:11:44 <FliP^2eH> Whoops
10:11:45 <FliP^2eH> Lemmih
10:11:53 <FliP^2eH> But yours was the rigth one to use
10:13:22 <Lemmih> FliP^2eH: dmwit managed to get it right the second time around.
10:13:32 <FliP^2eH> oh.
10:15:12 <Lemmih> Just when I grok one dissertation, another smacks me in the head. I am doomed to perpetual groklessness.
10:16:17 <FliP^2eH> Hmm
10:16:42 <FliP^2eH> Can't I just dump values to a text file using Show and then read them back 1:1 using read?
10:16:53 <FliP^2eH> Would that work for normal algebraic data types?
10:17:08 <Philonous> FliP^2eH: If you derive show and read: yes
10:17:13 <opqdonut> works for stuff you have Show for
10:17:14 <FliP^2eH> Awesome
10:17:35 <FliP^2eH> No need to write overcomplicated serializers
10:17:37 <opqdonut> you might want to have a look at some of the more proper serialization libs
10:18:05 <Philonous> > (read . show $ (2,3)) :: (Int,Int)
10:18:07 <lambdabot>   (2,3)
10:18:47 <FliP^2eH> > (read . show $ [(2,3)]) :: [(Int,Int)]
10:18:49 <lambdabot>   [(2,3)]
10:19:55 <Philonous> But that only works for vanilla haskell 98 data types
10:20:03 <opqdonut> data.binary
10:26:50 <lollan> yop
10:27:30 <shapr> salut
10:27:44 <lollan> salut shapr
10:41:13 <uzytkownik> Is there any tool to desugar monads?
10:41:21 <uzytkownik> I.e. do notation?
10:41:32 <mauke> yeah, @undo
10:41:41 <Beelsebob1> @undo do {x <- f 5; y <- g x; return x y}
10:41:41 <lambdabot> f 5 >>= \ x -> g x >>= \ y -> return x y
10:42:09 <C-Keen> oh nice
10:42:22 <uzytkownik> @undo do { h <- server_handle =<< getState; liftIO (hPutStr h s) }
10:42:23 <lambdabot> server_handle =<< getState >>= \ h -> liftIO (hPutStr h s)
10:42:44 <flipflap> :t div
10:42:45 <lambdabot> forall a. (Integral a) => a -> a -> a
10:42:57 <uzytkownik> @undo \s -> do { h <- server_handle =<< getState; liftIO (hPutStr h s) }
10:42:57 <lambdabot> \ s -> server_handle =<< getState >>= \ h -> liftIO (hPutStr h s)
10:43:47 <uzytkownik> @pl \s -> (\h -> liftIO (hPutStr h s)) << server_handle =<< getState
10:43:47 <lambdabot> (getState >>=) . (<< server_handle) . (liftIO .) . flip hPutStr
10:44:41 <MartyIX> Does anybody know an algorithm how to find next permutation as to the next permutation represent minimal bigger number (compounded from ciphers of first permutation). For example: [1,2,3,4] next permutation is [1,2,4,3], next one is: [1,3,4,]. I think I could do that if I would interchange two neighbour elements (starting at the end of list) and if first one is smaller than the second one then interchange them and sort all elements from the secon
10:48:38 <kacper_> how to add my type to Eq class?
10:49:12 <mauke> instance Eq YourType where ...
10:50:52 <uzytkownik> @undo \s -> do { h <- server_handle `fmap` getState; liftIO (hPutStr h s >> hFlush h) }
10:50:53 <lambdabot> \ s -> server_handle `fmap` getState >>= \ h -> liftIO (hPutStr h s >> hFlush h)
10:52:04 <dmwit> kacper_: add "deriving Eq" to the end of the data declaration
10:52:57 <dmwit> ?. pl undo \s -> do { h <- server_handle `fmap` getState; liftIO (hPutStr h s >> hFlush h) }
10:52:58 <lambdabot> (server_handle `fmap` getState >>=) . (liftIO .) . (`ap` hFlush) . ((>>) .) . flip hPutStr
10:53:05 <dmwit> oh yeah, much better
10:57:21 <kacper_> dmwit: thanks
10:57:42 <uzytkownik> How to display a diff for last commit?
10:59:06 <dmwit> uzytkownik: That depends on which revision control system you're using.
10:59:16 <uzytkownik> dmwit: Ups. darcs
10:59:39 <dmwit> darcs diff, then?
10:59:59 <dmwit> darcs help diff for more information.
11:00:36 <uzytkownik> dmwit: It gives changes since last commit. And when I tried to experiment with -n it gives me "darcs failed:  Pattern not specified in get_first_match."
11:01:25 <dmwit> My scan of the help file suggests --from-patch and --to-patch may be relevant.
11:02:21 <uzytkownik> dmwit: that was it.
11:28:10 <roconnor> @src Flip
11:28:10 <lambdabot> Source not found. Where did you learn to type?
11:38:16 <newsham> ?vixen where did you learn how to type?
11:38:17 <lambdabot> why don't you guess?
11:47:51 <flipflap> Man
11:47:55 <flipflap> Haskell starts to be fun now
11:48:06 <flipflap> Like.. really fun
11:48:18 <smtms> flipflap, was it no fun before?
11:48:23 <flipflap> Frustrating
11:48:38 <Twey> Heh
11:48:50 <Twey> Did you just get proficient enough to start actually programming?  :-P
11:48:53 <jmcarthur> kinda cool -> frustrating -> really fun -> eye opening
11:48:59 <monochrom> Everything fun begins as frustrating.
11:49:10 <flipflap> Twey: jup
11:49:18 * Twey nods.
11:49:24 <flipflap> My program keeps growing
11:49:24 <Twey> Welcome, brother :-P
11:49:29 <flipflap> 360 lines of code now
11:49:38 <flipflap> Once you figure out the type errors, it's all fun and games
11:49:39 <Twey> Hope you've organised it nicely!  :-P
11:49:49 <flipflap> I didn't split it up that much yet
11:49:59 <flipflap> Only methods that really differ in topics
11:50:05 <flipflap> like Save.hs for saving state
11:50:42 <monochrom> Swimming is frustrating and fun too.
11:50:49 <flipflap> Swimming is just fun
11:51:09 <monochrom> Swimming was frustrating to me. I couldn't get myself to float.
11:51:17 <flipflap> Just eat a lot of bacon
11:51:23 <monochrom> haha
11:51:27 <flipflap> swimming :: Maybe Fun
11:51:30 <flipflap> swimming = Just Fun
11:52:29 <byorgey> data Fun = Fun | Okay | CanWePleaseGoNow  ?
11:54:28 <newsham> [08:49] < flipflap> My program keeps growing
11:54:36 <newsham> you're not done until there's nothing left to take out
11:54:46 <flipflap> :)
11:55:23 <flipflap> I could nopaste the source
11:55:28 <flipflap> And you tell me what to remove!
11:55:44 <newsham> that's your job, not mine. :)
11:55:55 <flipflap> Well
11:56:02 <flipflap> I'm not great enough to decide alone :(
11:56:09 <flipflap> And figure out what could be written smarter
11:56:11 <flipflap> And sexier
11:56:22 <flipflap> I heavily rely on pattern matching already
12:05:18 <Botje> @quote shan
12:05:18 <lambdabot> shapr says: [on Oleg:]  And ccshan and he would argue furiously for a minute or two and then SPJ would say "Why don't you send an email to the Haskell list about that so we can have time to understand
12:05:18 <lambdabot>  what you just said?"
12:06:08 <Twey> Heh
12:37:02 <flipflap> How can I avoid import cycles?
12:37:19 <Beelsebob1> structure your code well :)
12:37:20 <flipflap> I've got User.hs and State.hs, User.hs needs parts of State.hs and State.hs needs parts of User.hs..
12:37:48 <Beelsebob1> if you have two modules that genuinely depend on each other then you either have too few or too many modules
12:37:58 <Beelsebob1> the too few case is that you have a common data structure that needs seperated out
12:38:10 <Saizan> you can move those parts to a third module that both User and State import
12:38:13 <Beelsebob1> the too many case is that both modules are really doing the same sort of job, and you need to admit it
12:41:38 <jauaor> hi
12:42:36 <flipflap> Okay, fixed it by moving those parts to a third file
12:43:31 <flipflap> Now let's say I've got a list of datas, and I want to search for a specific element, and only one
12:43:57 <Botje> Data.List.find
12:44:05 <flipflap> [(Point 50 50), (Point 30, 30)], Looking for point with X of 50 should then return Element 0
12:45:33 <Beelsebob1> > listToMaybe . filter ((==50) . fst) $ [(50,50),(30,30)]
12:45:35 <lambdabot>   Just (50,50)
12:45:56 <Saizan> ?ty findIndex
12:45:57 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe Int
12:49:29 <raimo> how can I compose my cellTo function in a case like this http://haskell.pastebin.com/m31767fd5 ?
12:50:26 <raimo> and is there a way to express the same thing without repeating cellTo?
12:50:39 <Botje> what's the role of the [[a]] in the type?
12:51:03 <Saizan> raimo: can you express what you want in a pointful style?
12:51:48 <raimo> Botje: it's a two-dimensional array
12:51:59 <Botje> raimo: why does cellTo need the [[a]] ?
12:52:15 <Botje> if cellTo :: Direction -> (Int, Int) -> (Int, Int) you could compose cellTo like you showed
12:52:51 <Botje> cellAt (cellTo N . cellTo E $ (5,5)) board
12:54:00 <raimo> hmm okay, dropping the array does the trick
12:54:28 <raimo> what about is there a way to write it without repetition?
12:54:45 <Botje> without repetition of what?
12:55:16 <mariano|syzygy> can anyone point to a simple example where I can see happy and alex cooperating to produce a parser which gives locations of syntax/lexical errors?
12:57:05 <raimo> Botje: without repeating the cellTo part
12:57:13 <Botje> well, no
12:57:28 <raimo> ok and thanks for your help
12:57:35 <Botje> you could use a fold, i guess
12:57:40 <Botje> but that would just clutter it up
12:58:38 <Botje> foldr1 (flip cellTo) [N, E]
12:58:46 <Botje> hmm
12:58:52 <Botje> nope, that's a type error
12:59:25 <Botje> foldr (\f d -> cellTo d . f) id [N, E]
12:59:43 <Botje> but writing cellTo N . cellTo E is a lot clearer :)
13:21:21 <harlekin> I am toying around with type families and I have an error I cannot solve. http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2759#a2759 I expected ghc to understand the type equality given in line 9, but apparently it does not.
13:22:31 <harlekin> Is this a bug or can't I match for type equality in that way (or at all)?
13:22:38 <BMeph> harlekin: So *YOU* don't know what you want, but you expect the computer to figure it out? Sounds like a risky proposition... :)
13:23:06 <harlekin> I know what I want. But I don't know how to tell ghc that.
13:23:49 <harlekin> In line 9 I expect i to be equal in i and in Cons i is. But ghc apparently doesn't respect that.
13:24:15 <FunctorSal> harlekin: apparently tyFams don't support OverlappingInstances
13:24:17 <Lemonator> A lot of folks don't like not being able to use the same field names for different data types.
13:24:37 <Lemonator> Why don't you just put record accessors in type classes, then?
13:24:43 <FunctorSal> harlekin: I think oleg found some workaround ;)
13:24:55 <Lemonator> To me, that seems like a fitting workaround.
13:24:59 <harlekin> FunctorSal, which is? (:
13:25:33 <FunctorSal> harlekin: http://hackage.haskell.org/package/type-equality-check
13:25:41 <FunctorSal> don't know if this fits your situation though
13:26:02 <harlekin> FunctorSal, I'll take a look at it. Thank you.
13:26:03 <dmwit> Lemonator: It's been proposed.  Perhaps we'll see it in Haskell2 some day in the future.
13:26:32 <Lemonator> oh, very well then.
13:27:19 <harlekin> FunctorSal, I think it is not. It uses fun deps and not type families.
13:27:22 <dmwit> Lemonator: What I gather is that the difficulty in implementing it involves how deep-seated record update syntax is in GHC.
13:29:11 <dmwit> Lemonator: In the meantime, if you want that, you may be able to do something yourself with functional references and a custom class hierarchy.
13:29:44 <harlekin> Can I perform lookup on a finite set of types using type functions?
13:30:47 <dmwit> harlekin: Would you consider "f 1 = 'a'; f 2 = 'b'; f 17 = 'c'" to be lookup?
13:31:05 <dmwit> If so, you should be able to do lookup with, err...
13:31:08 * dmwit forgets the right name
13:31:18 <int-e> type families?
13:31:34 <harlekin> dmwit, nope. I cannot qualify over int. I'd like to qualify over a type.
13:31:37 * int-e wonders
13:31:53 <dmwit> int-e: I don't think that's the one.
13:32:23 <dmwit> harlekin: No, all I meant was: would you consider that "lookup" for values, or does your meaning of "lookup" involve an actual lookup table structure available somewhere in memory?
13:32:45 <dmwit> harlekin: i.e. would some analogous type function satisfy your needs?
13:32:55 <harlekin> I'd like to construct a set of types and be able to tell if a type is in this set or it it isn't.
13:33:15 <dmwit> aha
13:33:28 <dmwit> No, I do not believe you can do that.
13:33:34 <harlekin> Pitty. ):
13:33:59 <dmwit> You can think of a "class" as a set of types.
13:34:17 <dmwit> Since all values are statically-typed, you know statically whether it is in that class.
13:34:24 <dmwit> But that may not be what you need, I don't know.
13:35:31 <Lemonator> wait a minute
13:36:15 <Lemonator> doesn't "(SomeClass a) => ... " mean that you're seeing whether a is an instance of SomeClass,
13:36:23 <Lemonator> that is, whether a is an element of a set?
13:36:49 <dmwit> Sort of, yes, that's why I suggested it.
13:37:04 <Lemonator> <dmwit> No, I do not believe you can do that.
13:37:07 <Lemonator> then what's this?
13:37:07 <dmwit> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5879#a5879 (@Lemonator and harlekin)
13:37:56 <harlekin> How's that related to type families?
13:37:57 <dmwit> Lemonator: I guess he assumed he meant "at run-time".
13:38:03 <dmwit> harlekin: It isn't.
13:38:17 <dmwit> Lemonator: Since there's no concept of run-time types here, that's obviously straight out.
13:38:41 <Lemonator> oh
13:39:22 <dmwit> harlekin: ...it isn't related to type families, per se, but it is related to your question.
13:39:27 <Lemonator> perhaps there is some way to "force" type checking at run time.
13:39:40 <harlekin> dmwit, could you then please explain it? I don't see how it is.
13:39:50 <dmwit> harlekin: You asked how to tell if a type was in a particular set.
13:40:02 <dmwit> harlekin: I'm giving you a way to tell that: create a class which has instances for each member of the set.
13:40:13 <dmwit> (And no instances for things that are not members of the set.)
13:40:18 <Lemonator> Kind of like how sometimes macro expansions in Lisp have to occur at run time due to a shortage of info during compile time.
13:40:35 <dmwit> Lemonator: Yep, it's called dependent typing, and there's lots of research about it.
13:40:40 <harlekin> But I cannot change the set using a function. For instance I cannot create a paramterized monad using a class.
13:40:45 <dmwit> Lemonator: You might like Coq or Agda as a language for that stuff. =)
13:41:04 <jimmyjazz14> Anyone using Leksah, is there a way to use emacs style keys in it?
13:41:12 <dmwit> harlekin: correct
13:41:33 <dmwit> harlekin: err... the first part, at least, is correct
13:41:45 <dmwit> harlekin: Although you could change the input to the lookup. =)
13:42:07 <dmwit> i.e. rather than (x `elem` function mySet), use (inverseFunction f `elem` mySet).
13:42:39 <harlekin> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2759#a2759 So is this not possible in general or will it be possible at some point in ghc?
13:42:51 <harlekin> Since there doesn't seem to be another way to achieve that.
13:43:49 <harlekin> I don't see a good reason why the compiler shouldn't be able to distinguish between the instance in line 9 and line 10. But then again I don't have the theoretical background.
13:44:20 <dmwit> harlekin: But (Get Foo (Cons Foo is)) matches both of those.
13:44:42 <dmwit> harlekin: i.e. we can bind "i" to Foo in the first one, and both "i" and "j" to Foo in the second one.
13:44:56 <The_Journey> why are functional languages like haskell are so unreadable
13:45:02 <harlekin> dmwit, it should use the first one as in pattern matching. (:
13:45:09 <harlekin> dmwit, it there a way to work around that?
13:45:12 <Botje> The_Journey: reads fine to me. perhaps you need better glasses? :)
13:45:20 <monochrom> Functional languages like haskell are very readable.
13:45:24 <harlekin> Maybe have an additional constraint like i ~ i and i !~ j?
13:45:27 <dmwit> harlekin: You may be interested in GADTs, which allow you to test type equality.
13:45:38 <dmwit> ...though I don't remember how.
13:46:13 <Lemonator> I think what harlekin wants is type-level functions.
13:46:15 <die_sekte> The_Journey: To beginners, Haskell looks unreadable because it packs a lot of imformation into small spaces
13:46:21 <harlekin> Lemonator, yeah.
13:46:29 <Lemonator> a full, complete implementation of them.
13:46:31 <The_Journey> idk I read the tutorial for haskell and theres a line like (++) :: [a] -> [a] -> [a]
13:46:40 <dmwit> Lemonator: No, type-level functions are not enough.  He already has those via type family/type instance.
13:46:41 <The_Journey> so cryptic
13:46:45 <jimmyjazz14> The_Journey: the more you learn haskell the more readable it feels, it just different
13:46:46 <The_Journey> more than C
13:46:51 <Botje> The_Journey: the rest of the tutorial explains how to read it
13:46:54 <die_sekte> The_Journey: Well, that's a type signature
13:47:01 <Botje> make an effort, it pays off :)
13:47:23 <jimmyjazz14> Type signatures make haskell code more readable actually
13:47:32 <jimmyjazz14> at least I have felt that way in my experience
13:47:39 <monochrom> I think this one is just being bitter for the sake of being bitter.
13:47:54 <Lemonator> well, let's see
13:48:29 <Lemonator> in the example he gave above, the type checker fails because of "conflicting declarations".
13:48:39 <dmwit> yep
13:48:42 <The_Journey> is haskell the next Lisp?
13:48:48 <Lemonator> if it were a function, though,
13:48:54 <Lemonator> wait a minute.
13:49:01 <Lemonator> you can't define that as a function, either.
13:49:11 <dmwit> Lemonator: exactly =)
13:49:19 <dmwit> Lemonator: You need an equality comparison.
13:49:24 <Lemonator> having two 'i's in the same pattern makes the pattern matcher crap out.
13:49:35 <Lemonator> Maybe harlekin is just writing the families wrong.
13:49:44 <dmwit> No, those are valid families.
13:49:46 <harlekin> I hope I am. (:
13:49:48 <dmwit> These are not pattern matches.
13:50:14 <die_sekte> The_Journey: Lisp is still alive. Haskell is ... something else
13:50:19 <Lemonator> alright, so the solution would be to define a "type-level function" that compares types and checks whether they're equal.
13:50:26 <dmwit> Yes.
13:50:40 <Lemonator> then "call" that in the family declarations.
13:50:43 <harlekin> Is this possible?
13:50:45 <dmwit> No.
13:51:00 <Lemonator> should be, if type-families and instances really are type-level functions.
13:51:01 <The_Journey> lol I wouldnt consider Lisp alive, but seems like Haskell is even more cryptic than Lisp
13:51:16 <dmwit> Lemonator: Nonsense.  You can't even do that for arbitrary *values* in Haskell.
13:51:21 <dmwit> let alone types
13:51:30 <Lemonator> not for arbitrary values, but values of the same type.
13:51:44 <dmwit> No, not even for arbitrary values of the same type.
13:51:48 <Lemonator> whuh
13:51:56 <dmwit> > id == \x -> x
13:51:58 <lambdabot>   No instance for (GHC.Classes.Eq (a -> a))
13:51:58 <lambdabot>    arising from a use of `GHC.Cla...
13:52:06 <die_sekte> The_Journey: Arc, a dialect of Lisp had a release recently. And about the cryptic part: depends.
13:52:14 <dmwit> Lemonator: You have to provide a primitive equality-tester for each type you want to compare that way!
13:52:25 <Lemonator> let's ignore function types.
13:52:32 <dmwit> Lemonator: The same thing is true at the type level.  You have to provide a primitive equality-tester for each kind you want to compare.
13:52:41 <dmwit> Lemonator: There are plenty of non-function types which don't have an Eq instance.
13:53:11 <harlekin> How is type checking working if ghc doesn't know that Type1 /= Type2 and Type1 == Type1?
13:53:57 <dmwit> Actually, what unification does is try to *enforce* that type1 == type2.
13:54:07 <Lemonator> oh boy.
13:54:14 <dmwit> It doesn't always succeed, but at the beginning, it may not be obvious (syntactically) that type1 == type2.
13:54:37 <dmwit> For example, (a -> b) /= (c -> d -> e), but they unify. (with b = d -> e).
13:54:50 <Lemonator> I always thought every algebraic data type that is defined in terms of other algebraic data types can "derive" Eq
13:55:10 <dmwit> Lemonator: Only if those other algebraic data types happen to themselves have an Eq instance.
13:55:13 <Lemonator> It would be a pretty obvious procedure.
13:55:25 <dmwit> Lemonator: And remember, you don't always have control over the definition of a data type.
13:56:48 <Lemonator> well, let's think for a second there.
13:57:04 <Lemonator> What keeps us from comparing arbitrary types of kind * ?
13:57:35 <mmorrow> Lemonator: what do you want to compare by?
13:57:42 <Lemonator> name, perhaps.
13:57:53 <mmorrow> unsafeCoerce + reallyUnsafePreEquality# ?
13:57:58 <And[y]> hi, how can i get the first param in main() as integer and call a function with it?
13:57:58 <And[y]>   args <- getArgs
13:57:58 <And[y]>   n <- getArgs >>= readIO.head
13:58:03 <Lemonator> I tend to think of types as their own "algebraic data type"
13:58:04 <Lemonator> like
13:58:05 <And[y]> go n
13:58:06 <mmorrow> Lemonator: Lemonator: there are no names in the machine code
13:58:08 <And[y]> does not work ;/
13:58:10 <dmwit> mmorrow: He wants to compare types, not values.
13:58:19 <mmorrow> Lemonator: Lemonator: there are no types in the machine code
13:58:28 <And[y]> i have import, too, and main = do, so thats not the problem
13:58:29 <Lemonator> data Kind = Int | Float | Whatever | ...
13:58:31 <dmwit> mmorrow: You might want to read a bit of backlog. ;-)
13:58:34 <mmorrow> err/Lemonator x2/Lemonator x1/
13:58:47 <monochrom> Yeah I was wondering about the double nick.
13:59:12 <mmorrow> dmwit: so he wants to do it at compile time?
13:59:30 <dmwit> And[y]: I'm guessing it's choosing the wrong Read instance.
13:59:38 <dmwit> mmorrow: yep
13:59:55 <Lemonator> data Type = Int | Float | Whatever | ...
14:00:03 <dmwit> mmorrow: Top-level goal is to have a type family representation of a set of types, and look up membership of another type in that set.
14:00:05 <Lemonator> not Kind; that'd be crazy.
14:00:11 <mmorrow> so hack ghc's typechecker :)
14:00:33 <dmwit> I suggested GADTs as the way to go (rather than type families), but I think I was maybe ignored.
14:01:06 <harlekin> dmwit, I'll definitely look into that. You wasn't ignored.
14:01:08 <mmorrow> dmwit: what would be the outcome if a type wasn't a member? when is this happening and at what level?
14:01:19 <dmwit> data Eq a b where Refl :: Eq a a -- something like this, maybe?  I can't really remember
14:01:20 <harlekin> dmwit, I just don't know that much about GADTs yet. But they are not extensible, are they?
14:01:27 <jauaor> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5883#a5883
14:01:31 <mmorrow> (outcome := type error, or your compile-time executing function returning False?)
14:01:36 <jauaor> filter implementation in a language i am writing
14:01:43 <jauaor> suggestions, comments welcome
14:01:44 <jauaor> :P
14:01:44 <dmwit> mmorrow: dunno, ask harlekin
14:02:00 <harlekin> mmorrow, if it is in the set, the type function returns TypeA, TypeB otherwise.
14:02:04 <mmorrow> oh, i thought we're talking about Lemonator
14:02:06 <dmwit> harlekin: No, gadts are indeed closed, unlike type families.
14:02:36 <dmwit> err... "Yes, gadts are indeed closed, unlike type families" is what I meant.
14:02:40 <dmwit> heh
14:03:11 <mmorrow> you can combine classes and GADTs to kinda maybe get this
14:03:32 <mmorrow> data IsAShow a where AShow :: (Show a) => IsAShow a
14:04:00 <mmorrow> foo :: IsAShow a -> a -> String; foo IsAShow a = show a
14:04:09 <mmorrow> (i think you wouldn't need the context)
14:04:15 <dmwit> Or plain old existential types, even.
14:04:27 <dmwit> oh
14:04:31 <mmorrow> but then you'd have to put a value in there
14:04:35 <dmwit> Yeah, that's nicer...
14:05:14 <dmwit> It sure doesn't seem better than the plain, old, trusty class mechanism, though.
14:05:26 <dmwit> foo :: Show a => a -> String -- the type declaration even looks nearly identical
14:05:31 <dmwit> foo = show
14:05:57 <mmorrow> it starts to get more useful when you have something like
14:06:44 <mmorrow> data Is a where AShow :: (Read a, Show a, ......., Foo a) => Is a
14:06:53 <mmorrow> s/AShow/A/
14:07:20 <mmorrow> and even more so when the gadt has more than one type param
14:08:28 * dmwit nods
14:08:43 <dmwit> Still, multi-param type classes can do that, no?
14:09:01 <dmwit> class Is a; instance (Read a, Show a, ..., Foo a) => Is a
14:09:21 <dmwit> Though I guess the closed vs. open thing is nice here.
14:09:24 <mmorrow> well, they can do the class part of that, but not the part that's:
14:09:26 <mmorrow> exactly
14:09:28 <mmorrow> that too
14:09:43 * dmwit nods
14:10:54 <dmwit> harlekin: If you really, absolutely need this kind of thing, and expect to be doing it with some regularity, I might just suggest upgrading your language to Coq or Agda or something.
14:11:22 <harlekin> Na, I don't need this desperately. I just thought it could have a nice effect if it was working. (:
14:12:14 <BONUS> http://www.haskell.org/pipermail/cvs-libraries/2009-June/010890.html
14:12:16 <BONUS> interesting
14:12:29 <dmwit> Yeah!
14:12:32 <dmwit> I'm really excited.
14:12:35 <mmorrow> so the other useful thing is
14:12:51 <dmwit> I've apologized for the state of ghci's Unicode support one time too many!
14:13:06 <BONUS> yeah haha
14:13:29 * dmwit has only apologized once
14:14:23 <mmorrow> data Foo a b where One :: Foo Int (Tree Double); Two (Map String [()]);   foo :: Foo a b -> (a -> b); foo One n = ... :: Tree Double; foo Two m :: [()]
14:14:40 <mmorrow> * foo Two m = .. :: [()]
14:15:30 <uzytkownik> BONUS, mmorrow: Why iconv on *nix platform only? Isn't it ported to Windows?
14:15:31 <mmorrow> err, Two (Map String Blah) [()]
14:15:59 <mmorrow> uzytkownik: i don't know much about windows
14:17:00 <uzytkownik> mmorrow: Neither do I but I'm certain that it is ported. It is required by some GTK+ stuff which is ported.
14:18:27 <mmorrow> (that should've been:  data Foo a b where One :: Foo Int (Tree Double); Two :: Foo (Map String Blah) [()])
14:19:23 <mmorrow> so almost like closed type classes when used like that
14:19:43 <mmorrow> (where you have a `foo' function that implements the (a -> b) for every (Foo a b))
14:20:41 <mmorrow> (where the corresponding (open) class would be class Foo a b where foo :: a -> b)
14:21:30 <mmorrow> so an "instance" is just a pair of a constructor of the GADT and a case of the `foo' function
14:22:31 <Lemonator> harlekin, dmwit, mmorrow, check it:
14:22:32 <Lemonator> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2759#a2763
14:23:15 <mmorrow> Lemonator: ooh, nice
14:23:28 <dmwit> Lemonator: Yes, for any finite set of types, that's possible.
14:23:47 <dmwit> Note that the number of comparisons needed  is O(n^2), where n is the number of types in your finite set.
14:23:51 <dmwit> nasty
14:23:56 <Lemonator> yeah, that's just plain stupid.
14:24:40 <Lemonator> the set of types of kind * are all comparable with each other, since they're analogous to no-parameter data constructors of the same type.
14:24:46 <dmwit> I was going to suggest it, but the amount of boilerplate just seemed to high for it to be better than the half-assed approach that doesn't use type families at all and sometimes gets it wrong.
14:24:55 <Lemonator> or, rather, no-parameter type constructors of the same kind.
14:25:03 <Lemonator> therefore, "derive Eq" should be possible.
14:25:19 <dmwit> s/to high/too high/
14:25:58 <Lemonator> writing "type instance" and "type family" is indeed way too much boilerplate.
14:30:17 <Lemonator> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2759#a2764
14:30:23 <Lemonator> de-boilerplated version.
14:30:58 <Cale> The kind signatures would be mandatory.
14:31:09 <dmwit> It's still got O(n^2) boilerplate.
14:31:12 <Cale> Because they syntactically look like pattern bindings
14:31:20 <Lemonator> well then
14:31:38 <Lemonator> -XForTypesDeriveEq
14:31:47 <dmwit> =)
14:31:59 <Lemonator> that'd make stuff a LOT easier.
14:32:44 <dmwit> And now it is time to ask how to derive Eq for type families.
14:32:51 <dmwit> Since, after all, they are just functions on types.
14:33:22 <dmwit> (By now I'm just teasing you. ;-)
14:33:32 <Lemonator> oy, that's a pickle.
14:35:24 <Lemonator> dmwit, functions on types have a different kind than "normal" types.
14:35:39 <Lemonator> simply deriving Eq for * would be sufficient.
14:35:51 <Lemonator> that shouldn't be hard at all.
14:35:53 * dmwit nods
14:44:18 <mariano|syzygy> where is fst3?
14:44:26 <mmorrow> Lemonator: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2759#a2765
14:44:39 <mmorrow> mariano|syzygy: in the gopher prelude :(
14:45:01 <mariano|syzygy> heh
14:47:15 <Lemonator> mmorrow, what does ~ do?
14:48:22 <mariano|syzygy> what language is that?
14:49:09 <mmorrow> Lemonator: not much :)
14:49:19 <Lemonator> huh?
14:49:26 <Lemonator> I've never seen that operator before.
14:49:47 <mmorrow> mariano|syzygy: oops, s/gopher/gofer/
14:49:50 <mmorrow> http://hackage.haskell.org/package/gofer-prelude
14:50:20 <mmorrow> Lemonator: ohh, you said "~" (i read "it do")
14:50:29 <mariano|syzygy> Ithought it had made it into haskell :/
14:50:30 <mmorrow> it says the two types are equal
14:50:44 <Lemonator> Haskell has that, or did you just make it up?
14:51:15 <mmorrow> @type 42 :: (a ~ Int) => a
14:51:17 <lambdabot> Int
14:51:38 <Lemonator> :headslap:
14:51:50 <mmorrow> @type 42 :: (a ~ b, b ~ c, c ~ Int) => a
14:51:52 <lambdabot> Int
14:52:03 <Tsion> Is that ever useful?
14:52:15 <mmorrow> when you start having type family instances it is
14:52:54 <mmorrow> (Foo (Baz a) Goo b ~ Zomg c a b) => c
14:53:13 <mariano|syzygy> it means equality, or that the two types can be unified?
14:53:22 <mmorrow> that they can be unified
15:00:55 <kcr> someone from poland?
15:01:44 <jimmyjazz14> BONUS: is it just me or are Monoids missing from learn you a haskell?
15:01:56 <BONUS> jimmyjazz14: one monoid chapter coming up! :D
15:01:59 <dmwit> Blah, I totally forgot about ~.
15:02:01 <dmwit> mmorrow++
15:02:12 <BONUS> srsly though, they're literally the next chapter
15:02:16 <BONUS> but i have to finish it
15:02:16 <ehird> BONUS: now THATs quick writing
15:02:17 <ehird> ;)
15:02:20 <ehird> *THAT'
15:02:20 <ehird> s
15:02:21 <BONUS> SOOO many exams :[
15:02:22 <ehird> aww
15:02:24 <ehird> you typed too quick
15:02:38 <alexsuraci> How would I go about starting a timer in the IO monad, and when I stop it it tells me the elapsed time in ms precision?
15:02:41 <jimmyjazz14> BONUS: can't wait to read it
15:02:45 <alexsuraci> Not seeing anything similar to that on hackage
15:02:51 <BONUS> haha thanks
15:02:54 <BONUS> can't wait to write it
15:03:02 <BONUS> definitely more fun than studying discrete maths
15:03:04 <jimmyjazz14> I read that entire last chapter just to get to the section on Monoids
15:03:05 <alexsuraci> Preferrably it would return a reference of some sort so I could pass the "timer" around and stop it
15:03:08 <kcr> someone from poland?
15:03:18 <ehird> kcr: what do you want?
15:03:28 <dmwit> alexsuraci: getCurrentTime?
15:03:42 <alexsuraci> dmwit: I don't think that's as precise as I need it
15:03:43 <dmwit> diffTime should help, too.
15:03:52 <dmwit> alexsuraci: You need more precise than picoseconds??
15:03:54 <alexsuraci> The documentation seems to imply it's only down to seconds, not sure
15:03:58 <kcr> i'm searching polish guy coz i have to descripe hard thing
15:04:05 <wli> BONUS: Download generatingfunctionology
15:04:07 * alexsuraci does a double take
15:04:14 <alexsuraci> dmwit: time package, right?
15:04:16 <BONUS> what's that
15:04:23 <dmwit> alexsuraci: Yep, Data.Time.
15:04:52 <alexsuraci> UTCTime: This is the simplest representation of UTC. It consists of the day number, and a time offset from midnight. Note that if a day has a leap second added to it, it will have 86401 seconds.
15:05:00 <alexsuraci> That sounds like seconds to me, or does it vary?
15:05:00 <dmwit> alexsuraci: yes...
15:05:03 <dmwit> alexsuraci: no
15:05:05 <dmwit> alexsuraci: Not seconds.
15:05:16 <dmwit> alexsuraci: It's stored in units of seconds, not in precision of seconds.
15:05:25 <dmwit> See the docs for NominalDiffTime. =)
15:05:32 <alexsuraci> hmm, alright, thanks
15:05:48 <dmwit> (And the docs for DiffTime, for that matter.)
15:06:16 <alexsuraci> Thank you, checking it out
15:06:23 <BONUS> ah it's a book i see
15:06:25 <BONUS> downloading it now
15:07:41 <uweDeportivo> have a small question about do notation: I have an expression expr of type IO [Double]  and I do {x <- expr; return x}. Can I use do notation to bind x to [Double] instead of IO Double  ? It's doing IO Double right now because List is a monad, right ? thanks
15:08:11 <alexsuraci> dmwit: Good enough for me, thanks for clearing that up.
15:08:23 <dmwit> uweDeportivo: No, it's IO Double because IO is a monad.
15:08:23 <BONUS> what do you mean hmm. when you do x <- expr, you're binding expr to x
15:08:50 <BONUS> yeah, you can't just mix and match monads like that. you can stack them though >:)
15:08:58 <dmwit> uweDeportivo: And, yes, (x :: [Double]), but the entire do expression has type (IO [Double]), and no, you cannot make the entire do expression have type [Double].
15:09:22 <kcr> how to optimal do thing like: in type [[Int]] find first element which is list more than 1 item and generete as many list of lists as this elem have items, e.g. myFunc [[1],[2],[3,4,],[5]] = [[[1],[2],[3],[5]],[[1],[2],[4],[5]]]
15:09:40 <dmwit> uweDeportivo: The standard trick is, rather than getting values *out* of monadic types, to put the functions acting on them *into* the monadic type.
15:10:01 <dmwit> uweDeportivo: So if you have a function (f :: [Double] -> Int), you can use (liftM f :: IO [Double] -> IO Int).
15:10:32 <uweDeportivo> got it, thanks
15:11:13 <uweDeportivo> what i actual had was do {x <- expr; y <- (foo x); etc....}
15:11:18 <dmwit> > sequence [[1], [2], [3,4], [5]]
15:11:20 <lambdabot>   [[1,2,3,5],[1,2,4,5]]
15:11:27 <dmwit> kcr: ?
15:11:32 <uweDeportivo> foo takes a [Double] argument
15:11:47 <BONUS> yeah
15:11:53 <BONUS> or you can do
15:11:57 <uweDeportivo> and ghc was complaining Couldn't match expected type `[Double]'
15:11:57 <uweDeportivo>            against inferred type `IO Double'
15:11:58 <dmwit> uweDeportivo: Yep, so if (expr :: IO [Double]), that should be fine.
15:12:18 <uweDeportivo> well, it wasn't
15:12:18 <dmwit> uweDeportivo: Sounds like you had (expr :: [Double]) by accident. =)
15:12:32 <dmwit> uweDeportivo: If so, you can use let-binding for that:
15:12:35 <uweDeportivo> hm, maybe, i'll check
15:12:47 <dmwit> do { let { x = expr }; y <- foo x; etc... }
15:12:49 <BONUS> x <- expr; y <- return (foo x) is the same as y <-liftM foo expr
15:13:42 <uweDeportivo> cool, thanks guys
15:13:55 <dmwit> or
15:14:03 <dmwit> do { y <- foo x; etc... } where x = expr
15:14:13 * kcr slaps kcr around a bit with a large trout
15:14:20 <dmwit> Though in that case, none of the things bound earlier in the do-block will be in scope in expr.
15:14:45 <mariano|syzygy> the type system supported b ghc evolves way too fast
15:14:47 <mariano|syzygy> :/
15:16:01 <kcr> dmwit: sequence is good but i want to do it for only first element not for all
15:16:32 * dmwit nods
15:16:53 <dmwit> There is no easy way, then.  Just hack it together with filter, take, drop, etc.
15:17:14 <dmwit> > break ((>1) . length) [[1], [2], [3,4], [5]] -- here's a start
15:17:15 <lambdabot>   ([[1],[2]],[[3,4],[5]])
15:17:35 <kcr> take and length seems to be good
15:19:33 <kcr> hmm
15:19:41 <kcr> i dont understand it
15:19:55 <kcr> here's a start? what do u mean?
15:20:13 <dmwit> I just meant that "break" might be useful.
15:21:36 <uweDeportivo> using let worked, expression was :: [Double], thanks
15:23:36 <HaskelNew> hi everyone!
15:23:49 <BONUS> hi!!!!!
15:23:55 <HaskelNew> Ok, so lemme explain myself :)
15:23:58 <Lemonator> Guess you're...
15:24:02 <Lemonator> New to Haskell.
15:24:05 <HaskelNew> My name is Lovro :)
15:24:08 <HaskelNew> i come from Croatia
15:24:19 <HaskelNew> and i'm new to haskell!
15:24:22 <HaskelNew> yippe
15:24:36 <HaskelNew> i am a computer science student
15:24:39 <HaskelNew> 3rd year
15:25:00 <HaskelNew> have some knowledge of c#, pascal, c, c++, perl etc..
15:25:08 <BONUS> cool
15:25:10 <BONUS> haskell is nice
15:25:11 <HaskelNew> and on one of our subjects
15:25:14 <HaskelNew> on college
15:25:21 <HaskelNew> we know have to learn haskell
15:25:32 <BONUS> a bit off topic, where in croatia do you live
15:25:37 <HaskelNew> Zagreb :)
15:25:47 <HaskelNew> now* not know.. in the previous sentence
15:26:08 <BONUS> ah, zagreb is lovely.
15:26:14 <dmwit> Well, howdy, and welcome to #haskell.
15:26:15 <HaskelNew> hh, ever been here?
15:26:23 <HaskelNew> thank you  dmwit
15:26:53 <BONUS> anyway if you need help feel free to ask me in private or email me :) cause i speak croatian
15:26:53 <HaskelNew> anyway, i'm totally new to function programming
15:27:19 <HaskelNew> You are Croatian or you just speak? :)
15:27:32 <BONUS> just speak :)
15:27:50 <HaskelNew> Ok then :) phew, cause it might have happened that you are my professor or smth
15:28:00 <BONUS> haha
15:28:01 <anq> Haha.
15:28:07 <HaskelNew> and my name would suddenly change from Lovro :)
15:28:12 <HaskelNew> "prank caller prank caller"
15:28:21 <BONUS> hehe
15:28:33 <HaskelNew> anyway..
15:28:42 <HaskelNew> today is the first day i tried learning about haskell
15:28:51 <HaskelNew> in the morning though
15:29:02 <mariano|syzygy> first lesson: it is spelt with two Ls :-)
15:29:03 <HaskelNew> and, it was a bad morning,
15:29:17 <HaskelNew> thank you! :) i always seem to forget that one
15:29:24 <HaskelNew> google warned me a couple o times allready
15:29:45 <dmwit> (I don't think your professor would mind the kind of help we're willing to give here, anyway.)
15:30:00 <BONUS> best place to start: http://haskell.org/haskellwiki/Tutorials
15:30:03 <HaskelNew> i'm sure he wouldn't , but i'm not sure he would like the questions i'm about to ask
15:30:19 <ziman> i don't think asking questions itself on #haskell would be disapproved of by the teachers ... unless you ask for ready solutions :)
15:30:29 <BONUS> yeah
15:30:34 <dmwit> Sometimes we do homeworks for big tall moneys.
15:30:47 <HaskelNew> hh, no :) i won't be asking for solutions :)
15:30:55 <HaskelNew> but nice to know ;)
15:31:12 <HaskelNew> anyway, i think i kind of got on the wrong foot with this one
15:31:20 <HaskelNew> my first reaction was: "omg thats ugly"
15:31:24 <HaskelNew> (sory to everyone)
15:31:45 <HaskelNew> it's probably (most definetly) because i'm used to imperative languages
15:31:54 <BONUS> you get used to it yeah
15:32:07 <BONUS> once you do, you usually find it very beautiful and concise
15:32:17 <HaskelNew> i hope, i love logic,
15:32:25 <HaskelNew> love beautiful and concise :)
15:32:30 <HaskelNew> love strongly typed etc
15:33:46 <HaskelNew> hm, ok, so lets start with lambda (bonus, kako oni kazu racun? ) :D
15:33:59 <BONUS> lamda calculus
15:34:00 <BONUS> hehe
15:34:04 <HaskelNew> lambda calculus ok :)
15:34:05 <dmwit> hehehe, from Homework_help on the wiki: "Even if someone perchance does do it for you, the solution may not help you; some just like the mental challenge of producing a technically correct but unhelpful answer."
15:34:33 <mariano|syzygy> and, moreover, you willcome across people who will give you wrong answers
15:34:42 <HaskelNew> i'm really not asking for help with homework,
15:34:46 <dmwit> The lambda calculus is like the assembly language of functional programming.
15:34:55 <dmwit> HaskelNew: I know, I'm just amusing myself.
15:35:01 <HaskelNew> :) ok,
15:35:29 <HaskelNew> so, heres how our professor (actually the one that dit lecture on haskell isnt a professor, he is an assistant)
15:35:31 <BONUS> i personally enjoy giving code that uses CPS or fmap fmap fmap and stuff like that when people ask for ready made homework solutions hehe
15:35:41 <dmwit> =)
15:35:50 <HaskelNew> (i'm sure it would be funny if i understood what it ment )
15:36:06 * HaskelNew loves geek jokes
15:36:11 <dmwit> > fmap fmap fmap (+1) ([3], [5])
15:36:12 <lambdabot>   ([3],[6])
15:36:21 <stulli> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5886#a5886
15:36:30 <stulli> how do i @undo this?
15:36:53 <burp> lol
15:36:54 <dmwit> stulli: That doesn't look syntactically correct.
15:36:57 <dmwit> stulli: Does it parse?
15:37:10 <stulli> Yes it does
15:37:14 <dmwit> wow
15:37:27 <dmwit> There must be a special case for `infixFunctions`.
15:37:41 <dmwit> welp:
15:38:02 <HaskelNew> so, here is how our assistant explained lambda functions : LambdaX.X+1)5 -> (beta reduction) 6
15:38:03 <stulli> I tried to @undo the whole thing with lambdabot but he gave me the wrong answer...
15:38:07 <dmwit> ?undo do { content <- readFile "input"; do { initState <- ask; lift . putStrLn $ show $ process initState `runReaderT` content }; return () }
15:38:07 <lambdabot> readFile "input" >>= \ content -> ask >>= \ initState -> lift . putStrLn $ show $ process initState `runReaderT` content >> return ()
15:38:23 <HaskelNew> :s
15:38:26 * dmwit checks if that's wrong
15:38:40 <Lemonator> we should call patterns "destructors".
15:38:46 <Lemonator> It sounds more badass.
15:38:50 <dmwit> stulli: Looks right to me.
15:39:04 <dmwit> oh
15:39:06 <stulli> dmwit, That doesnt compile for me
15:39:06 <dmwit> ($) is the issue
15:39:22 <dmwit> stulli: Parenthesize the expression that uses ($) and you'll be fine.
15:39:36 <stulli> aah, thanks!
15:39:56 <HaskelNew> what does that code do?
15:40:15 <Igloo> dmwit: There isn't a special case, it's the "parse error" case
15:40:29 <dmwit> HaskelNew: (\x. x+1) is a function that takes an argument, names it "x", and then returns the expression "x+1".
15:40:46 <HaskelNew> oh yea, i know that one
15:40:52 <HaskelNew> i thought about your code
15:40:59 <dmwit> HaskelNew: So a better explanation would be (\x. x+1) 5 -> (beta reduction) 5+1 -> (prim-op evaluation of +) 6
15:41:06 <HaskelNew> the question was different when it was about this piece of code
15:41:27 <HaskelNew> the question about this was , that what is so different or new about it?
15:41:46 <dmwit> HaskelNew: Nothing is new about that.
15:41:55 <dmwit> HaskelNew: What's new is that "x" can itself be bound to a function.
15:41:59 <dmwit> HaskelNew: as in:
15:42:00 <HaskelNew> is it not the same as int increaseByOne(int n) {return n+1}
15:42:25 <dmwit> (\f. \x. f x x) (\x. \y. x + y) 5 1
15:42:38 <dmwit> HaskelNew: i.e. functions are themselves data that can be passed around
15:42:54 <BONUS> isn't that inner do block equivalent to putStrLn . show $ process content
15:42:57 <dmwit> oops, that would evaluate to "error"
15:43:03 <dmwit> (\f. \x. f x x) (\x. \y. x + y) 5 -- instead
15:43:15 <HaskelNew> ok i'm lost :)
15:43:33 <dmwit> HaskelNew: Okay, consider this expression:
15:43:37 <mike-burns> HaskelNew: The difference is that increaseByOne is a named function, but \x->x+1 is not.
15:43:43 <dmwit> (\f. \x. f x x) -- only this part
15:43:47 <HaskelNew> ok,
15:44:09 <dmwit> HaskelNew: Inside the body of the lambda, "f" is being applied to two arguments.  This means that "f" is a function of at least two arguments!
15:44:10 <HaskelNew> (when i say i'm new, i really really meen new)
15:44:30 <dmwit> That is the crux of the interest.
15:44:41 <dmwit> All the rest of the expression above were just to give an example of how it might be used.
15:44:50 <dmwit> HaskelNew: Another great example is "map" in Haskell:
15:44:51 <dmwit> :t map
15:44:52 <HaskelNew> is "\" used for "lambda"?
15:44:52 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
15:45:03 <dmwit> HaskelNew: Yeah, that's what I'm using for lambda.
15:45:08 <dmwit> It's easier to type. =)
15:45:26 <HaskelNew> ok :)
15:45:36 <HaskelNew> wait lemme think on that for a sec
15:45:46 <dmwit> So, the type signature for "map" says that it takes a transformation function, and applies that function to all the values in a list.
15:45:51 <dmwit> Okay, I'll stop for a bit. =P
15:48:45 <HaskelNew> so in above example... f is a name of function? which takes function x (which does soemthing)?
15:49:24 <dmwit> In (\f. \x. f x x), f is the name of a function whose first two arguments have the same type.
15:49:43 <dmwit> We don't know anything about the type of "x" other than that it has to match the argument type of "f".
15:49:52 <dmwit> Maybe "x" is a function, and maybe not.
15:49:54 <skorpan> someone in this channel told me once that functions always have exactly one argument
15:50:20 <HaskelNew> are we talking about \x. or one of two x's in the back?
15:50:22 <dmwit> What's interesting is the type of the expression (\f. \x. f x x) itself, which is a function type whose first argument is definitely another function.
15:50:39 <dmwit> HaskelNew: err... they're the same x
15:50:54 <HaskelNew> ok but once as function and once as variable?
15:51:08 <dmwit> HaskelNew: Hm, I think I see where the confusion is.
15:51:13 <HaskelNew> whats the difference between \x. and x?
15:51:29 <dmwit> So, the expression "f x x" stands for the application of "f" to "x", and the application of the result to "x" again.
15:51:37 <dmwit> i.e. (f x x) === ((f x) x)
15:51:38 <HaskelNew> ok,
15:51:47 <HaskelNew> check
15:51:57 <monochrom> "\x." declares formal parameter "x"
15:52:13 <HaskelNew> formal in what way?
15:53:13 <HaskelNew> ok, i understood you so far dmwit :)
15:53:27 <dmwit> Let me respond to the "formal in what way" question.
15:53:32 <dmwit> Compare this:
15:53:33 <HaskelNew> ok, sry
15:53:40 <dmwit> int f(int x) { return x + 1 };
15:53:41 <dmwit> to this:
15:53:48 <litb> hello the crowd
15:53:48 <dmwit> y = f(x);
15:53:59 <dmwit> In both of these, "x" is a parameter.
15:53:59 <monochrom> As in "formal parameter". I am serious. The phrase "formal parameter" is a specific jargon in parsing programming languages, and could have nothing to do with the English meanings of "formal".
15:54:18 <dmwit> The phrase "formal parameter", however, only refers to the former; the latter is some other kind of parameter.
15:54:23 <dmwit> (I don't remember the name.)
15:54:23 <Philonous> HaskelNew: If I may add my 2 cent: The idea is to write down function definitions without havng to come up with a name of the function.So \x . x +x is the function that takes one argument (named x), adds it to itself and returns that as a result. \f \x . f x is a function that takes one argument, f, and returns a function that takes one argument, x applies f to x and returns that result
15:54:32 <monochrom> actual parameter
15:54:39 <dmwit> right
15:55:07 <litb> some people say parameter and argument. others say formal parameter, actual parameter
15:55:13 * dmwit doesn't agree with Philonous
15:55:17 <monochrom> "simple group" is neither English simple nor English group.
15:55:26 <dmwit> For me, the point is to be able to use functions as data, not to be able to use functions without names.
15:55:28 <Tsion> skorpan: That is true. Consider (+) :: (Num a) => a -> a -> a. It could be written as a -> (a -> a) because (+) is a function that takes one argument and returns a function that takes one argument.
15:55:31 <litb> but i think calling both just "parameter" serves for confusions
15:55:43 <monochrom> Oh, the fun begins when I say "formal argument" and "actual argument" :)
15:55:51 <litb> lol
15:56:04 <skorpan> Tsion: yeah, i know, i was just being an asshole :)
15:56:41 <dmwit> HaskelNew: So at this point, it's probably good to stop and take an assessment: what is the state of your confusion? =)
15:56:52 <HaskelNew> hehe
15:57:02 <HaskelNew> trying to read everything atm :D
15:57:33 <HaskelNew> and cursing for learning all of this in croatian, so that once i get into english spoken chat room, i sound double as noob as i am
15:57:44 <HaskelNew> which is alotta noob
15:58:08 <dmwit> Nobody minds. =)
15:58:17 <HaskelNew> yea, cool :)
15:58:54 <BMeph> I knew a girl inschool, named Alotta Noob... ;p
15:59:04 <monochrom> ...
15:59:08 <litb> oO
15:59:25 <HaskelNew> lol
16:00:22 <BMeph> ...well, not really. Her real name was Carlotta Fagina. But I digress... ;p
16:00:34 <HaskelNew> ok, so if i understood correctly, basically, formal meens its actually "a function of x" meaning, it uses x to calculate its value, whereas, actual, means - this formal X is incremented by 1.. so its actuall..
16:01:03 <HaskelNew> maybe i didnt understand that too weel
16:01:07 <HaskelNew> no
16:01:10 <HaskelNew> describe :)
16:01:13 <HaskelNew> i think i understood
16:01:24 <dmwit> Formal parameters are the parameters in the function definition; actual parameters are the parameters in the function application.
16:01:39 <HaskelNew> :) yea, thats what i was going for
16:01:43 <skorpan> (parameters vs. arguments in some languages)
16:01:51 <HaskelNew> ok
16:01:54 <HaskelNew> i understand
16:02:00 <dmwit> (\f {- formal -}. \x {- formal -}. f x {- actual -} x {- actual -}) (+) {- actual -}
16:02:28 <HaskelNew> + is a parameter?
16:02:48 <dmwit> hmm, I maybe shouldn't have fudged that, it may only introduce more confusion.
16:02:59 <dmwit> Imagine for now that (+) is a function of two arguments that returns their sum.
16:03:11 <HaskelNew> yea, (thats totally new :D)
16:03:30 <dmwit> Let's do this instead:
16:03:33 <dmwit> define for now
16:03:39 <dmwit> add = \m. \n. m + n
16:03:50 <HaskelNew> gr8, i understand that
16:03:58 <dmwit> Then I would write as above, but: "(\f. \x. f x x) add {- actual -}"
16:04:06 <dmwit> Is that better? =)
16:04:14 <hackagebot> yjftp 0.3.6.1 - CUI FTP client like 'ftp', 'ncftp' (YoshikuniJujo)
16:04:49 <dmwit> So beta reduction would take that to "(\x. add x x)" -- that is, a function which doubles its argument -- and demonstrates that we can pass functions to other functions.
16:05:18 <HaskelNew> ok, so the snippet would add 2 numbers, than give their cube?
16:05:25 <HaskelNew> ^2
16:05:28 <HaskelNew> square
16:05:29 <HaskelNew> ?
16:05:33 <dmwit> hmm?
16:05:34 <HaskelNew> cube is ^4 ?
16:05:39 <dmwit> cube is ^3
16:05:47 <HaskelNew> ok,
16:05:50 <dmwit> There is no multiplication here.
16:05:58 <dmwit> So I'm not sure where this "square" business is coming from.
16:06:02 <HaskelNew> ok,
16:06:06 <HaskelNew> let me read it again
16:07:29 <dmwit> Remember, "add x x" stands for "(add x) x", not "add (x x)".
16:08:04 <HaskelNew> but how can add take only one argument? when we have defined it with \m \n?
16:08:19 <dmwit> Aha!  This is one of the key insights. =)
16:08:25 <dmwit> All functions are functions of one argument.
16:08:45 <dmwit> (\m. \n. m + n) 3 -beta-> (\n. 3 + n)
16:09:03 <HaskelNew> ok so he would take them one by one
16:09:07 <dmwit> i.e. we have applied a two-argument function to only one argument, yielding another function that takes the remaining argument
16:09:11 <dmwit> exactly
16:09:32 <HaskelNew> so, what would the compiler actually do
16:09:37 <dmwit> Actually, this is not a requirement of functional programming languages; many languages do not have "partial application" like this.
16:09:46 <dmwit> But it's easy to recover partial application using lambdas. =)
16:10:00 <dmwit> HaskelNew: It would actually build what's called a "closure".
16:10:09 <dmwit> HaskelNew: It's a combination of the original function and an environment.
16:10:28 <HaskelNew> as in stdin?
16:10:33 <dmwit> no
16:10:42 <HaskelNew> :) ok then nvm.
16:10:56 <HaskelNew> maybe i should start with tutorial
16:10:57 <dmwit> "environment" here only includes expressions that are being supplied as arguments
16:11:12 <dmwit> But this is kind of unimportant to understanding how to use the language.
16:11:18 <dmwit> The implementating of the language itself should come much later.
16:11:20 <HaskelNew> since, i was actually only looking for a reason to even look at it
16:11:42 <HaskelNew> passing functions as arguments seems like a good one
16:12:12 <dmwit> Philippa suggests that I tell you that, from an efficiency standpoint, compilers can actually be quite smart about this kind of thing, so that at least saturated function calls are just as efficient as you would hope.
16:12:22 <jaredj> sm, check your email eh
16:12:26 <dmwit> (Where "saturated" is the opposite of "partially applied".)
16:12:36 <m3ga> is there a guide/tutorial for relative newbies to convert code from Control.OldException to Control.Exception?
16:12:45 <dschoepe> HaskelNew: Also (enforced) purity is an nice feature that you don't find in most languages.
16:13:11 <HaskelNew> what does that meen in practice dsc?
16:13:38 <jaredj> HaskelNew: whatever code that you write that's pure is way easier to test, for one thing
16:13:42 <skorpan> it means that your code is easier to test
16:14:03 <dschoepe> HaskelNew: Also you have a clear separation between pure and side-effect-ish code.
16:14:04 <HaskelNew> i;ve herd that one, but never actually understood howcome?
16:14:18 <dschoepe> that reduces bugs greatly in my experience.
16:14:22 <skorpan> this is a result of the fact that pure functions can never modify how other functions will "execute"
16:14:24 <HaskelNew> i love side effects, actually i fint that quite encumbering.
16:14:40 <jaredj> HaskelNew: you have to set the world up properly before you start the test of your impure function
16:14:43 <BONUS> basically when you have a function, it depends only on the parameters passed to it
16:14:55 <BONUS> you don't have to worry about some state in some other object affecting your function
16:14:59 <HaskelNew> well, you can do that in any language
16:14:59 <BONUS> or some global variable
16:15:20 <HaskelNew> the choice is on you weather your function will use some global variable or not
16:15:29 <BONUS> well you can but in haskell you must. you don't have to think about side effects and what state your program is at any given mooment
16:15:34 <BONUS> you just think about values
16:15:39 <jaredj> HaskelNew: think about I/O too
16:15:50 <BONUS> at first people find purity restricting, but then when they get used to it, they find it liberating
16:15:55 <BONUS> because you don't have to think about so much stuff
16:15:58 <skorpan> BONUS++
16:15:58 <dschoepe> HaskelNew: Yes, but other languages make it harder to get by without some form of state. In haskell "state-free" programming feels natural.
16:16:05 <BONUS> :]
16:16:19 <HaskelNew> how is that accomplished dschopepe?
16:16:40 <HaskelNew> i would rip my hair out if i had to write every function i've ever written to not use any global variable
16:16:48 <HaskelNew> actually, i don't know how i would solve some problems
16:16:55 <dmwit> I think the main point is that, with libraries (or other code that you haven't personally read and vetted), it is nevertheless announced in a precise, verifiable way whether or not there are side effects.
16:17:03 <dschoepe> HaskelNew: The first thing is that you can pass functions as arguments and the type system is extremly powerful.
16:17:38 <dschoepe> Therefore Haskell programs are a lot more composable.
16:17:44 <Philippa> one way of looking at it is that you can always do stateful programmiing, just more explicitly
16:17:58 <Philippa> you see precisely what forms of state are involved
16:18:10 <HaskelNew> well, isnt the one way of loooking that you can also do state-less programming in c#?:)
16:18:31 <HaskelNew> so , for example
16:18:36 <HaskelNew> lets say that you ahve a timer
16:18:42 <HaskelNew> (there are timers in haskell right?)
16:18:45 <dschoepe> Of course, but syntax for say lambda expressions or passing functions around tends to be very noisy in other languages.
16:18:45 <dmwit> sure
16:18:57 <HaskelNew> and, you want it to count seconds, for how long does your program last
16:19:00 <dschoepe> So you are more inclined to just use stateful code.
16:19:24 <jaredj> HaskelNew: now you deploy your program and it takes ten times as long as you thought possible. will it still work?
16:19:34 <jaredj> (i mean, to run)
16:19:48 <sm> jaredj: thanks!
16:19:48 <dmwit> whew, there's an awful lot of answers here before HaskelNew has even asked his question.
16:20:01 <monochrom> Too many chefs.
16:20:05 <jaredj> sm: np :) i'm far from being general enough but it's a fun start
16:20:13 <jaredj> bork bork
16:20:23 <HaskelNew> i dont understand the question jaredj
16:20:31 <sm> this one doesn't allow newlines at all, eh ? My bank uses them sometimes but not always
16:20:43 <jaredj> badly phrased. i defer to the other chefs. let the record be stricken :)
16:21:01 <HaskelNew> so, back to the question,
16:21:02 <monochrom> So why don't I join in too?
16:21:05 <jaredj> sm: old bank used them always, new one never. :P
16:21:15 * jaredj eating
16:21:31 <HaskelNew> so, lets say i want functionality of simple second counter in program
16:21:43 <sm> fyi the problem I had accessing your repo was 404 for http://dingoskidneys.com/~jaredj/pokerglory/
16:21:51 <HaskelNew> how would you do it?
16:21:57 <HaskelNew> without using global variables
16:22:04 <dmwit> HaskelNew: You do it the same way as in normal programming, BUT
16:22:07 <Philonous> HaskelNew: A programm that can't communicate with the outside world - and thereby perform statefull operations - would be useless indeed.
16:22:30 <dmwit> The difference is that your function "startTimer" has type "IO ()", which states explicitly that it does some IO.
16:22:46 <dmwit> And "endTimer" has type "IO Time", which says not only that it does some IO, but also that it returns a Time.
16:23:10 <dmwit> So you can still do all the things you're used to... you just have to announce to the world exactly what you're doing.
16:23:21 <HaskelNew> aah,
16:23:24 <HaskelNew> ok
16:23:30 <dmwit> This is great for libraries, because if you see a function that doesn't return an "IO" type, you *know* that it doesn't do any IO!
16:23:33 <monochrom> Someone who has never swum wonders: how could anyone do anything without standing on firm ground, how could you even walk forward?  Someone who has never used pure functional programming wonders: how could you do things without global state?  Oh, and someone who has never done imperative programming wonders: who could you live without referential transparency? :)
16:23:42 <Axman6> Philonous: not totally true
16:24:11 <dschoepe> Axman6: Well it'd create heat, but apart from that?
16:24:11 <HaskelNew> actually, dmwits explanation is great
16:24:15 <HaskelNew> that would indeed be usefull
16:24:16 <Philonous> Axman6: The only useful programme that I can think of that doesn't involve any kind of IO would be a benchmark
16:24:35 <Axman6> Philonous: me too :P
16:24:43 <Gracenotes> :D
16:24:45 <Axman6> and running down my battery
16:24:49 <HaskelNew> :)
16:25:38 <HaskelNew> ok, but i'll still have to stick with passing functions as arguments :)
16:26:21 <HaskelNew> so, lets say that you would have start timer
16:26:23 <dschoepe> Axman6: Hmm, and perhaps proving that something with some property exists(with infinite elements to check).
16:26:23 <HaskelNew> which is IO
16:26:45 <HaskelNew> what if you wanted that function to do something else as well
16:26:53 <HaskelNew> you need an integer out of it
16:26:54 <shachaf> Philonous: Depends on your definition of "programme". :-)
16:27:06 <shachaf> You could consider f :: String -> String to be one.
16:27:08 <dmwit> HaskelNew: This is starting to get a bit advanced.
16:27:18 <HaskelNew> ok
16:27:24 <dmwit> HaskelNew: But, for the sake of answering you as honestly as possible: "IO" is a type constructor.
16:27:30 <dmwit> HaskelNew: It takes another type as an argument.
16:27:36 <HaskelNew> ok
16:27:41 <HaskelNew> i understand that
16:27:47 <HaskelNew> thats great
16:27:49 <dmwit> HaskelNew: So if you want to do some IO, then return an Integer, then that means your action would have to have type "IO Integer".
16:27:55 <shachaf> HaskelNew: You're coming to Haskell from an IO/imperative perspective. Perhaps what you want to do is focus as far away from that as you can. :-)
16:28:01 <dmwit> HaskelNew: "IO" all by itself is nonsensical as a type. =)
16:28:08 <monochrom> It has to be always "IO something" anyway.
16:28:13 <shachaf> Since that's what makes Haskell unique/interesting in contrast to your previous experience.
16:28:23 <HaskelNew> i know shachaf, but its the onlyu perspective i have
16:28:24 <Baughn> "type T Int = Double" <-- If this was valid syntax, what would it be called?
16:28:25 <shachaf> (I am making a bunch of assumptions here, I'm sure.)
16:28:37 <dmwit> Baughn: Type families do that.
16:28:41 <Baughn> Ah
16:28:51 <dmwit> type family T
16:28:56 <dibblego> HaskelNew, you have the null perspective as well -- trust me, use it to your benefit
16:28:57 <dmwit> type instance T Int = Double -- the actual syntax
16:29:22 <dschoepe> The "math perspective" is also useful. :)
16:29:26 <Axman6> HaskelNew: using ghci can be a good wai of 'avoiding' using IO
16:29:29 <HaskelNew> dibblego , null perspective? :)
16:29:38 <dibblego> HaskelNew, the one you were born with
16:29:41 <dmwit> Axman6++
16:29:50 <Baughn> dmwit: Can I use classes too? Like "type instance Binary a => T a = Foo"?
16:29:56 <HaskelNew> nah, i was born objectly oriented :)
16:30:11 <HaskelNew> j/k
16:30:14 <Axman6> HaskelNew: poor thing :(
16:30:18 <dmwit> Baughn: I don't believe so.
16:31:16 <HaskelNew> so, is it possible to write whole programs in haskell? with gui and everything?
16:31:21 <mike-burns> Yup
16:31:22 <dschoepe> Sure
16:31:22 <dmwit> You bet!
16:31:25 <HaskelNew> ok this sounded dumb
16:31:26 <HaskelNew> i meen, like
16:31:41 * HaskelNew *doh
16:31:49 <dmwit> ?faq Can I write whole programs in Haskell?
16:31:50 <lambdabot> The answer is: Yes! Haskell can do that.
16:31:55 <HaskelNew> :D
16:32:02 <HaskelNew> lol, ok
16:32:31 <HaskelNew> i ment like, with user input, guis, writing to screen, perhaps some graphics?
16:32:34 <Vanadium> ??faq Can I, specifically, write whole programs in Haskell?
16:32:35 <Axman6> HaskelNew: leksah is an IDE written in haskell for writing haskell (it's not particularly finished atm, but it works)
16:32:45 <dmwit> HaskelNew: Yes.  We can do all of that.
16:32:51 <dschoepe> HaskelNew: There's even a fps written in haskell(frag).
16:33:01 <HaskelNew> :) oh i gotta see that one
16:33:03 <Axman6> there's OpenGL bindings for doing 3D graphics too
16:33:16 <dmwit> HaskelNew: gtk2hs is a binding to Gtk2, if you happen to know that GUI kit.  There's OpenGL and wxWidgets bindings, too.
16:33:34 <dschoepe> And interesting concepts to a more functional design of guis(frp, e.g. grapefruit)
16:33:38 <Philonous> HaskelNew: Haskell is a great imperative language.
16:34:04 <HaskelNew> ok :) thank you people
16:34:09 <dmwit> HaskelNew: There's a language standard for binding to C libraries, so anything C can do, Haskell can do, too. =)
16:34:31 <dmwit> ?where hackage
16:34:31 <lambdabot> http://hackage.haskell.org/
16:34:52 <dmwit> Check that out to see some of Haskell's libraries.
16:34:58 <shachaf> HaskelNew: Cross-language comparisons may also help to make this idea more vivid. How eager I was, when learning French, to learn how to talk about baseball. I very much wanted to know how you say "pitcher", "catcher", "fly ball", "out", and so on. To be sure, such terms do exist in French, and it's fine to learn them, but it seems to me in retrospect to have been a misguided obsession for someone whose chief motivation was sheer fluency. In learning a f
16:35:13 <Axman6> HaskelNew: also, imo, haskell doesn parallelism and concurrenct better than pretty much any other language out there (though erlang beats if for distributed concurrency)
16:35:22 <dmwit> shachaf: cut off around "In learning a "
16:35:37 <HaskelNew> shachaf, thats a very vivid example :)
16:35:50 <Baughn> Axman6: Erlang doesn't /have/ to beat it, though. We've already got most of the pieces to implement its kind of concurrency..
16:36:02 <Axman6> indeed
16:36:13 <Baughn> About the only real problem is hot-swapping code
16:36:15 <shachaf> Er, http://books.google.com/books?id=o8jzWF7rD6oC&pg=PA568&dq=%22cross-language+comparisons+may+also+help+to+make+this+idea+more+vivid%22
16:36:28 <Axman6> Baughn: it's an area i'm very interested in, and would live to make a nice distributed concurrent library for funsies
16:36:36 <shachaf> (I was rather late with this anyway. :-) )
16:36:43 <shachaf> But it seems like that's what you should do.
16:36:50 <Philonous> Oh, so are there primitives for Oz-style distributed concurrency, too?
16:36:52 <shachaf> It depends on why you're learning Haskell, of course. :-)
16:37:01 <Baughn> Philonous: Not yet.
16:37:17 <Vanadium> Can I get in on this?
16:37:24 <dmwit> No!
16:37:26 <dmwit> Well... okay.
16:37:32 <Axman6> but be nice!
16:37:46 <jaredj> sm: did you say anything? my /away may not have worked right
16:37:57 <Vanadium> I am learning haskell, or trying to, because it seems to do lots of things way more elegantly than the languages I am used to. And I am having a lot of fun so far. But I still have no idea how to actually apply haskell to construct applications. :)
16:38:32 <sm> hi.. just that your pokerglory repo link gives a 404
16:38:35 <shachaf> Vanadium: main = putStrLn "Hello, world"
16:38:40 <shachaf> Or what do you mean by applications?
16:38:51 * Axman6 's next job is writing a parallel prine number finder in haskell
16:38:59 <Vanadium> Right now I am at most in the "writing C in any language" spot where I can do some basic file IO at most, but I still need to figure out how to build proper abstractions, I guess
16:39:02 <sm> I've just been studying your latest to see why it rejects my ofx
16:39:29 <Axman6> i don't think i've ever done file IO in haskell
16:39:41 <Axman6> actually, i'm not sure i've ever fine any file IO at all :o
16:39:52 <HaskelNew> lol
16:40:06 <Axman6> never had any use for files :P
16:40:48 <dschoepe> Vanadium: If you are confident reading other people's code, you could start with looking at some small- to medium-sized projects and see how they are designed.
16:40:48 <Philonous> You store your data in a token of a ring-network?
16:40:51 <sm> I should figure out your test setup
16:40:59 <Axman6> hmm, actually, it would be useful for this prime number thing, if i could keep a list of prime numbers serialised
16:41:07 <dmwit> Vanadium: I suggest xmonad; it's a beautiful read.
16:41:08 <Philippa> Vanadium: Building abstractions is a piece of cake :-) Parameterise using functions, hide using module boundaries
16:41:17 <jaredj> sm: runhaskell Tests.hs
16:41:20 <Philippa> Vanadium: it's learning /what/ abstractions that takes a while
16:41:23 <Vanadium> Hm
16:41:24 <Axman6> dmwit: really?
16:41:30 <dmwit> Axman6: really
16:41:38 <Axman6> what's so nice about it?
16:41:44 <jaredj> sm: the only tests so far involve reading the header, before the SGML starts
16:41:50 <dmwit> Axman6: They've got this tiny layer of X monad over all this beautifully pure code.
16:42:03 <dschoepe> It's very readable and thoroughly commented
16:42:07 <jaredj> sm: i couldn't figure out how to write a QuickCheck test for the body that doesn't look like a stylized copy of the DTD
16:42:13 <dmwit> The comments help a lot, too, yeah.
16:42:17 <Axman6> ah, i was just thinking it'd be full of IO, this does sound interesting
16:42:23 <jaredj> instance Arbitrary OFXDocument where arbitrary = ..........
16:42:25 <sm> thanks.. could not find Text.Parsec.Prim.. is that another parsec version ? I think I have 2.1 installed
16:42:27 <jaredj> ....
16:42:45 <jaredj> sm: i thought i had gotten rid of all that, sigh.
16:42:46 <dschoepe> Axman6: Well the most important stuff is kept completely pure(the StackSet module).
16:42:54 <jaredj> sm: i thought i wanted parsec 3 because it had the highest version number
16:42:59 <sm> aha
16:43:04 <jaredj> sm: then found out Text.HTML.TagSoup wanted Parsec 2
16:43:06 <dschoepe> Also most layouts are specified in a pure fashion
16:43:13 <Philippa> jaredj: parsec 3's effectively in alpha still
16:43:15 <sm> yes, 2 seems to be still mainstream
16:43:16 <jaredj> Text.OFX1 has the Parsec 3 beaten out of it - maybe Tests.hs doesn't
16:43:19 <Axman6> jaredj: yeah most people use parsec 2
16:43:24 <jaredj> Philippa: so i found :)
16:43:56 <jaredj> i just sorta thought, "Text.ParserCombinators.Parsec, Text.Parsec - that latter one's shorter. nice"
16:44:07 <HaskelNew> ok, thank you everyone for answering my questions, especially you Dmwit! hvala :)
16:44:09 <HaskelNew> good night
16:44:18 <jaredj> night
16:44:22 <dmwit> g'night, and have fun =)
16:44:37 <jaredj> hvala: finnish?
16:44:45 <dmwit> croatian
16:44:53 <sm> finnish ? I've hardly sstarted ?
16:45:13 <dmwit> hehe
16:45:20 <dmwit> The doubled-up 's' really makes that joke. =)
16:45:20 <jaredj> oh. *facepalm* heh
16:45:25 * sm cracks up.. somebody help me
16:46:29 <sm> the brain will do strange things to get out of staring at unfamiliar code...
16:46:41 <Axman6> hmm, is there an MUArray instance for Int64?
16:49:51 <heatsink> A bit off topic: I've seen some programming languages with dependent types and others with linear types, but none with both.  Are any with both?
16:50:26 <commande1> :2
16:50:35 <commande1> help
16:50:47 <Axman6> ...
16:50:51 <Zao> Hello there, confused soul.
16:50:55 <commande1> Hi
16:50:59 <heatsink> Should I call emergency?
16:51:11 <Axman6> you need to readjust your lambda commande1
16:51:16 <commande1> No, I just forgot to how to use irssi
16:51:17 <hatds> Axman6: you mean an MArray instance for IOUArray Iny64?
16:51:21 <Axman6> or get out of the house quickly
16:51:28 <commande1> But actually I got one haskell question...
16:51:55 <Gracenotes> halp!
16:52:11 <Axman6> hatds: well, one that can store unboxed Int64's
16:52:32 <Axman6> @src Int64
16:52:32 <lambdabot> data Int64 = I64# Int64#
16:52:40 <thoughtpolice> heatsink: ATS?
16:52:42 <Axman6> hmm
16:52:45 <hatds> Axman6: IOUArray is unboxed
16:52:49 <Axman6> anyway, i eed to get breakfast
16:52:53 <Gracenotes> btw do u know that http://arcanux.org/lambdacats/flavor.jpg
16:53:06 <Philippa> heatsink: I doubt it, I know edwardk played with it a while back but generally it's the sort of thing where you're expected to embed the linear language in the dependent one
16:53:11 <thoughtpolice> heatsink: it allows dependent and linear typing, although depending on your definition of 'dependent' it might not exactly qualify, but it gets pretty quite
16:53:43 <hatds> there is no MUArray typeclass afaik -- what counts as "unboxable" is implicitly defined by whether there is an MArray instance for the corresponding unboxed array type
16:54:23 <jaredj> so i'm making Text.OFX1. following "how to make a haskell package." in the quickcheck section there's a test function used to turn a property function into something. what is that function? i can't find it
16:54:24 <commande1> Why ghci prints error when sees something like this: "data Point a = Pt a a" but ghc doesnt? (this is from gentle introduction to haskell)
16:54:38 <jaredj> oh wait, that's what hoogle's for
16:54:43 <jaredj> @hoogle test
16:54:43 <lambdabot> Test.HUnit.Base test :: Testable t => t -> Test
16:54:43 <lambdabot> Test.HUnit.Base data Test
16:54:43 <lambdabot> Test.QuickCheck class Testable a
16:54:53 <heatsink> thoughtpolice: I've seen ATS.  I should go back and see what kind of dependent types it has.  If it's like it's predecessor DML...
16:54:59 <jaredj> those are not it
16:55:08 <jaredj> i don't think
16:55:20 <jaredj> do you use HUnit and QuickCheck in combination?
16:55:52 <sm> jaredj: yes I'd guess that is turning a qc prop into a hunit test
16:56:08 <sm> then you run the lot with a hunit test runner
16:56:29 <jaredj> mmkay. so i'm missing an import and a cabal dependency
16:56:40 <sm> such as the one built in to hunit. test-framework is a more fancy one
16:58:20 <jaredj> also the document shows an instance Arbitrary which has a coarbitrary function. ghc complains at me for following that example
16:58:32 <jaredj> do i make an instance CoArbitrary instead? in addition?
16:59:23 <heatsink> Philippa: How would one embed linear types in a language with only intuitionistic types?  I thought there was no way to prohibit multiple variable uses.
16:59:35 <Philippa> heatsink: the hard way - write an interpreter
16:59:41 <heatsink> ah
16:59:43 <jaredj> sm: is it true that the only way to decently test this thing would be to duplicate the spec?
16:59:50 <jaredj> in the tests?
16:59:52 <Philippa> and/or "compiler" back into the host lang
17:00:17 <Philippa> "here's your function and here's proof it came from a compiler for a linearly-typed lang"
17:01:49 <sm> jaredj: possibly. I'm not experienced with quickcheck at all. What came to mind for me was to collect a number of test ofx files it should parse
17:02:24 <sm> expressing the spec with tests sounds like a more complete solution
17:07:37 <heatsink> Philippa: What is the usage model for such a setup?  From my limited experience, I would think the extra layer of abstraction makes it hard to do object language debugging or execution.
17:08:22 <m3ga> hi all, is there a guide/tutorial for relative newbies to convert code from Control.OldException to Control.Exception?
17:08:41 <jaredj> sm: probably saner.
17:09:00 <jaredj> to have test files. but you'd have to anonymize them of course
17:09:44 <heatsink> commande1: GHCI doesn't allow data types to be declared in the interpreter, only in files.
17:09:55 <jaredj> it's a heady feeling writing parsers and tests nearly straight from the spec - but annoying retyping the spec
17:10:31 <Saizan> use a script
17:10:34 <Philippa> heatsink: at the moment it does somewhat, yes. Of course, the hope is that you don't need to do much debugging because you had a type system that admits proofs of correctness
17:10:42 <sm> if it means you don't have to waste time tracking down parse errors for the rest of time, I'm all for it!
17:10:52 <jaredj> true enough...
17:11:00 <dmwit> Saizan: Sadly, there is no formal way to go from informal to formal.
17:11:03 * sm can't figure out why this $% TagClose STMTRN is unexpected.. looks just fine
17:11:08 <jaredj> right?
17:11:12 <jaredj> that's where i got
17:11:24 <Saizan> dmwit: a script is jist an hak, nothing formal :P
17:11:34 <Saizan> *just an hack
17:11:41 <Philippa> heatsink: if you're smart enough, you can instrument one of your executable forms to hell and back (IOW, lots and lots and lots of debugging info)
17:11:44 <sm> jaredj: you're having this trouble too ?
17:11:54 <jaredj> yes.
17:11:59 <sm> hm!
17:12:06 <jaredj> and the line number in the tag soup isn't helping me :(
17:12:09 <sm> then I feel less stupid :)
17:12:12 <jaredj> :)
17:13:35 <Philippa> heatsink: if you like, think of it as using a /debugging/ interpreter?
17:16:29 <heatsink> Philippa: I was acutally thinking of debugging the type-system proofs of correctness.  Your error messages would not be "Your program has this type error," but rather, "Your interpreter (with input program) has this type error."
17:16:31 <hackagebot> yjftp 0.3.6.2 - CUI FTP client like 'ftp', 'ncftp' (YoshikuniJujo)
17:16:40 <BMeph> Is there some class, "Consable", defined by cons:: forall a (c :: * -> *) . (Consable c) => a -> c a -> c a ? :)
17:17:01 <dmwit> BMeph: Check out Edison.
17:17:06 <heatsink> But maybe the interpreter can be made more 'transparent' than I think.
17:17:23 * BMeph checks it out...
17:18:00 <Philippa> heatsink: nope, the interpreter's one call and only accepts well-typed programs
17:18:24 <dmwit> BMeph: I don't know if it's in there, but it seems like the most likely library to have something like that. =)
17:18:49 <Philippa> worst case is it happens with a type-checker - you'd have to make terms keep track of uses in their types
17:19:02 <BMeph> dmwit: Sounds reasonable - thanks for the caveat. :)
17:19:03 <Philippa> (host-level types, that is)
17:19:23 <sm> jaredj: I think those maybeP's are messing it up
17:19:29 <jaredj> oh eh
17:20:46 <jaredj> option instead, perhaps? i don't know why there's a maybeP in Text.HTML.TagSoup.Parsec when there's an option in Text.ParserCombinators.Parsec.Combinators or whatnot
17:21:32 <hackagebot> procrastinating-structure 1.0 - Pure structures that can be incrementally created (JakeMcArthur)
17:21:54 <heatsink> Philippa;  Huh.  Well, I don't have enough experience to really see how it would work then.
17:22:53 <sm> me neither
17:23:01 <FunctorSalad_> jmcarthur / haskellbot: hehehe
17:23:07 <FunctorSalad_> * hackagebot
17:24:00 <jmcarthur> great place to truncate it there
17:24:15 <jaredj> sm: maybeP (wholeTag "SIC") did not work as a substitute
17:24:16 <sm> wait a sec, optional "discards the result of p.". That's odd
17:24:19 <jmcarthur> just for the record, i understand that it's an abomination ;)
17:24:30 <Philippa> heatsink: yeah. Honestly, dealing with heap monads is probably nicer a lot of the time
17:24:31 <jmcarthur> but it's also kind of cool
17:25:54 <Saizan> Philippa: do you have an example of an heap monad?
17:26:14 <sm> jmcarthur: I was just thinking oh! must be a good idea, I should probably be using that then
17:26:21 <jaredj> sm: yes. option gives it to you. note also that option only returns Nothing if the parser fails without consuming anything...?
17:26:34 <jmcarthur> sm: haha
17:26:43 <sm> after all, if it's on hackage...
17:26:46 <heatsink> Philippa: This came up because I'm building a compiler intermediate representation.  I want to embed side effect information into imperative programs (hence dependent and linear types) and use that to guide automatic parallelization, instead of what comes out of pointer analysis and dependence analysis.
17:27:04 <jaredj> jmcarthur, sm: what? my scrollback's borked
17:27:25 <sm> jaredj: no worries, unrelated comment
17:27:27 <jmcarthur> i think some fun things can come out of it. and i'm thinking about using it for an reactive implementation i have in mind
17:27:31 <jaredj> oh ok
17:29:10 <dmwit> ?hackage procrastinating-structure
17:29:11 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/procrastinating-structure
17:29:48 <dmwit> huh
17:29:54 <dmwit> That actually sounds kind of fun.
17:30:07 <dmwit> Dunno why you call it an abomination. =)
17:30:09 <Philippa> heatsink: okay, That's Different. Talk to edwardk about it a little?
17:30:22 <heatsink> heh
17:30:31 <jmcarthur> dmwit: only because it opens you up for pain if you don't get your laziness correct
17:30:49 <dmwit> =)
17:30:50 <heatsink> Philippa: I'll keep an eye out for him, thanks.
17:30:55 <jmcarthur> for example, see the example in the docs for the Data.PVar.Queue module
17:31:06 <SamB> kaol: huh ... I got a "Binary: Int64 truncated to fit in 32 bit Int" panic
17:31:08 <jmcarthur> if you forget to finalize the queue before you sum everything in it, boom
17:31:27 <jmcarthur> or if you read too much from it, boom
17:32:29 <cakoose> What's the GHC equivalent of a ".a" or ".so" library?  I'd like to package up some code as a library to be used by another program.
17:32:51 <dmwit> Packages do that.
17:33:03 <dmwit> Check out ghc-pkg register.
17:33:10 <dmwit> But most people use cabal instead.
17:33:18 <cakoose> dmwit, Would I have to install the package somehow?  Is there a way that I can just have a file?
17:33:31 <jaredj> sm: the line number in the tag soup appears to be the tag number
17:33:45 <sm> oh really
17:33:57 <sm> I thought it was the line number after the header
17:34:03 <dmwit> cakoose: I don't know much about it.
17:34:11 <dmwit> cakoose: This question might get more answers in #ghc, actually.
17:34:17 <cakoose> dmwit, ok thanks
17:34:35 <jaredj> sm: my ofx file has only 11 lines and it's breaking on "tagsoup", line 50
17:34:41 <sm> aha
17:34:48 <jaredj> sm: correction, it appears only TagOpens and TagCloses count toward that
17:35:14 <jaredj> er, wait, "unexpected end of input"
17:35:30 <jaredj> maybe i rejiggered it, the failure changed, and i wasn't paying attention
17:35:38 <sm> I got it to stop complaining by using option Nothing ... and option "" ..., then got a read error.. maybe \n breaking the LEDGERBAL parser ?
17:36:13 <sm> time for me to stop and cheer you on :)
17:36:59 <jaredj> i used optionMaybe
17:37:15 <jaredj> tried to switch back and now it won't compile...?
17:37:38 <kaol> SamB: rm your old .hi and .o files
17:37:43 <jaredj> ah ok nm
17:38:29 <SamB> kaol: oh, that does work
17:39:20 <SamB> maybe the error message should suggest trying that?
17:39:54 <monochrom> No, I oppose it. It would be too much second-guessing.
17:40:21 <jaredj> how do you do a one-liner case statement?
17:40:34 <jaredj> or a one-liner guard?
17:40:37 <FunctorSalad_> @pl (\x -> x >>= (\y -> y >>= (\z -> z >>= (\a -> f x y z a))))
17:40:38 <lambdabot> ap (>>=) (ap (>>=) . (ap (>>=) .) . f)
17:40:41 <monochrom> machine code could mismatch hardware for several distinct reasons. Here is another: x86 machine code on Sparc.
17:40:41 <heatsink> jaredj: case b of {True -> 0; False -> 0}
17:40:43 <FunctorSalad_> ugh
17:40:48 <jaredj> thx
17:41:03 <monochrom> Err nevermind.
17:41:09 <SamB> monochrom: machine code mismatch hardware ?
17:41:11 <chessguy> > case True of { True -> 0; False -> 1; }
17:41:13 <lambdabot>   0
17:41:37 <SamB> it was apparantly just an old .hi file from before I upgraded to GHC 6.10.3 ...
17:42:00 <SamB> -2
17:42:26 <FunctorSalad_> @ty join (?f <$> ?x <*> ?y <*> ?z <*> a)
17:42:27 <lambdabot>     Couldn't match expected type `m a' against inferred type `Expr'
17:42:27 <lambdabot>     In the second argument of `(<*>)', namely `a'
17:42:27 <lambdabot>     In the first argument of `join', namely
17:42:40 <FunctorSalad_> @ty join (?ff <$> ?x <*> ?y <*> ?z <*> a)
17:42:41 <lambdabot>     Couldn't match expected type `m a' against inferred type `Expr'
17:42:41 <lambdabot>     In the second argument of `(<*>)', namely `a'
17:42:41 <lambdabot>     In the first argument of `join', namely
17:42:58 <FunctorSalad_> @ty join (?ff <$> ?x <*> ?y <*> ?z <*> ?z10)
17:42:59 <lambdabot> forall a a1 a2 a3 (m :: * -> *) a4. (?ff::a -> a1 -> a2 -> a3 -> m a4, ?x::m a, Applicative m, ?y::m a1, ?z::m a2, ?z10::m a3, Monad m) => m a4
17:43:12 <chessguy> hey SamB , you gonna give the ICFP contest a shot this year?
17:43:22 <SamB> chessguy: I dunno
17:43:23 <FunctorSalad_> apparently that's the nicest way to write "n-ary bind"
17:43:31 <SamB> is there any hype yet?
17:43:38 <chessguy> nah
17:44:07 <SamB> I'm not sure why I should bother with a teaser-less contest!
17:44:39 <Caelum> what is "haskell-on-steroids" ?
17:44:40 <chessguy> yeah, endo was brilliant in that regard
17:44:42 <SamB> speaking of which, does anyone know what happened for last year's ?
17:44:53 <SamB> chessguy: sand wasn't too bad either!
17:45:02 <chessguy> SamB:  i think everyone working on it fell asleep halfway through...
17:45:34 <SamB> chessguy: that would explain why the link from icfpcontest.org is broken!
17:45:49 <thoughtpolice> i've never done an ICFP contest...
17:45:57 <thoughtpolice> might be fun to try :)
17:45:59 <ray> the broken link is this year's teaser
17:46:17 <ray> the contest is "find last year's contest"
17:46:35 <SamB> I'm not sure if that joke is still funny or not
17:47:19 <ray> write a device driver for a hypothetical USB time portal
17:48:07 <monochrom> write a program to find last year's contest?
17:48:59 <SamB> monochrom: for use as a bio-weapon?
17:49:47 <ray> it was a mars rover, there's no life on mars
17:50:00 <jaredj> sm: the way to number the tags follows
17:50:05 <SamB> I meant since it seems to be sleep-inducing ...
17:50:13 <jaredj> sm: c <- readFile "theOFXFile"
17:50:20 <chessguy> sez you, ray
17:50:39 <SamB> wait, aren't you supposed to fall asleep about 1/3 of the way into the contest?
17:50:41 <monochrom> mars rover isn't a bio-weapon anyway
17:51:05 <chessguy> SamB:  just after you change languages for the 4th time
17:51:36 <heatsink> monochrom: http://en.wikipedia.org/wiki/Forward-contamination
17:51:37 <jaredj> sm: let z = parseTags c in zip (scanl (\ n x -> case x of {TagOpen _ _ -> n + 1; TagClose _ -> n + 1; otherwise -> n}) 1 z) z
17:52:01 <jaredj> this can obviously be a big list
17:52:52 <sm> nice, that should help with debugging/error messages
17:55:18 <jaredj> sm: oops, it's off by one: the number goes up _after_ a TagOpen or TagClose, not _on_ one
17:58:32 <jaredj> readline has a binding ^O to do this command in the history, then show the next one, so you can go through a sequence of commands in history without breaking your up-arrow key
17:58:42 <jaredj> does editline have that and it's just not bound to a key?
17:59:41 <hackagebot> procrastinating-structure 1.0.1 - Pure structures that can be incrementally created (JakeMcArthur)
18:00:12 <couloir> a copy of RWH exists in the local bookstore. should i buy it? y/n:
18:00:38 <monochrom> So you can break your ^O key?
18:01:02 <monochrom> If you will read it, you should buy it.
18:01:20 <jmcarthur> both copies in the closest bookstore near me sold quick
18:01:24 <jmcarthur> i must find these people
18:02:17 <Cale> http://www.rfc1149.net/inf355/2009/06/10/java-cest-mal/ -- haha, have people seen this?
18:03:48 <monochrom> Who is behind rfc1149.net and does it exploit vulnerabilities in my browsers?
18:04:26 <Saizan> i guess it's funnier if you can read french :)
18:04:39 <dino-> Cale: IIRC you have to use the Object.equals() method for this stuff
18:04:55 <monochrom> Does "java-cest-mal" mean "Java c'est malicious"?
18:04:56 <Cale> dino-: yeah
18:05:09 <mike-burns> http://translate.google.com/translate?prev=hp&hl=en&js=n&u=http%3A%2F%2Fwww.rfc1149.net%2Finf355%2F2009%2F06%2F10%2Fjava-cest-mal%2F&sl=auto&tl=en&history_state0=
18:05:21 <mike-burns> "Java is wrong"
18:05:27 <gwern> monochrom: not really. mal just means bad; it doesn't necessarily had the connotation of malicious
18:05:32 <gwern> *have
18:05:46 <dino-> This is kind of Java 101, learn about equality, refs and copy construction, etc.
18:06:00 <gwern> 'if you understand why, you can explain in the comments'
18:06:13 <gwern> man, what sort of arse makes his readers answer the question?
18:06:31 <Cale> gwern: heh
18:06:36 <heatsink> Oh.  Integer is compared by reference, rather than by value.
18:06:53 <heatsink> erm, identity rather than equality.
18:06:54 <SamB> gwern: hmm?
18:07:49 <gwern> hm, the first comment thinks that Integer objects are different and the comparison is by pointer, if I follow him. sounds reasonable
18:07:51 <couloir> that example is like bignums and fixnums in scheme, i think
18:08:26 <monochrom> It is like eq, equal, and a couple others in Lisp.
18:08:43 <gwern> 1'Cest a, mais uniquement pour 128, pour 127 la comparaison renvoie un rsultat vrai. Cest du  lautoboxing des entiers hors du domaine 8 bits signs, qui cr de nouvelles instances alors que ceux tenant dans 8 bits signs utilisent toujours la mme instance. Je trouve cela monstrueusement contraire au POLA (Principle of Least Astonishment).' <-- oh you're kidding
18:09:07 <Saizan> ah, the very weird thing is that for 127 you get the right answer because of caching of instances
18:09:13 <gwern> that is such a stupid gotcha. as if I didn't hate java enough
18:09:19 <couloir> yeah, like fixnums
18:09:55 <monochrom> Well, I am pretty astonished that Lisp has one more equality than Java.
18:11:18 <SamB> I think they all make sense sometimes
18:13:55 <dino-> mutability is icky, eh?
18:14:11 <sm> jaredj: any luck ?
18:14:49 <SamB> dino-: yeah!
18:15:09 <SamB> dino-: but I think two of them might even make sense in Haskell-ish settings
18:15:21 <sm> I have hacked hledger convert to call your parser for .ofx files
18:16:11 <mib_95hegrh0> !register
18:16:41 --- mode: ChanServ set +o monochrom
18:16:42 <mib_95hegrh0> wtk
18:16:54 <Axman6> ...
18:17:04 --- mode: monochrom set -o monochrom
18:26:22 <Apocalisp> What's the difference between free and cofree?
19:08:57 <sm> my last desperate attempt to convert decimal to double fails! what's up with that: fromDecimal d = read $ show $ (decimalMantissa d / (10 ^ decimalPlaces d))
19:09:14 <sm> No instance for (Fractional Integer) arising from /
19:10:04 <monochrom> @type decimalMantissa
19:10:05 <lambdabot> Not in scope: `decimalMantissa'
19:10:57 <sm> got to disconnect.. thanks anyway. Next time
19:11:08 * sm glares at Decimal
19:11:48 <monochrom> Will programmers learn the meaning of "insufficient data for a meaningful answer"? Even "insufficient data for a meaningful question"?
19:14:01 <dmwit> Surely that problem should be no more than a fromInteger away from being usable, if it's usable at all.
19:26:35 <mmorrow> , let x = toRational(pi::Double)::Rational in fromRational x :: Double == (pi::Double)
19:26:37 <lunabot>  luna: parse error on input `Double'
19:26:49 <mmorrow> , let x = toRational(pi::Double)::Rational in fromRational x == (pi::Double)
19:26:51 <lunabot>  True
19:28:31 * mmorrow wonders if that got rewrite-RULEd away
19:30:58 <ManateeLazyCat> Hi all, I need `Tree` data structure, any suggestion?
19:31:35 <aavogt> ManateeLazyCat: Data.Tree in base?
19:32:43 <ManateeLazyCat> aavogt: Yep, i know, i found have others Tree implement in Cabal.
19:33:56 <ManateeLazyCat> Any suggestion about other Tree implement?
19:34:07 <ManateeLazyCat> Just ask. :)
19:34:40 <dmwit> ManateeLazyCat: Please try to rephrase your question.
19:35:14 <jaredj> @seen sm
19:35:15 <lambdabot> I saw sm leaving #friendly-coders, #ghc, #haskell-in-depth, #haskell and #darcs 24m 3s ago, and .
19:35:43 <Saizan> it really depends on what kind of tree you need, there are many variations
19:37:30 <ManateeLazyCat> I need search `parent level` node, then search leaf in next branch that at `same leavel`.
19:45:05 <ManateeLazyCat> If i need fast search in Tree, have a better Tree implement?
19:49:32 <Saizan> so you need a binary search tree? there are some AVL implementations on hackage
19:49:43 <jaredj> style question:
19:49:55 <jaredj> longFunctionName = do blablabla
19:49:59 <jaredj>               blablabla
19:50:12 <jaredj> or longFunctionName = do
19:50:14 <jaredj>     blablabla
19:50:15 <jaredj> ?
19:53:38 <ManateeLazyCat> Saizan: I think i need binary tree, because all node in tree just have `two` sub-tree or leaf
19:54:38 <Saizan> jaredj: snd
20:18:40 <eck> can anyone point me to projects on hackage using hunit? i'm trying to figure out how people use it and integrate it with their code
20:23:06 <dino-> eck: I used HUnit in photoname. Basically as a tool to simulate a user running the program from the shell, not unit testing as such. But it's integrated with Setup.lhs in that project with a common testsuite/ dir approach so `runhaskell Setup.lhs test` works.
20:23:26 <dino-> http://hackage.haskell.org/package/photoname
20:30:39 <dino-> eck: If you're thinking about where to put the unit test functions (properties?), I've been thinking lately about sticking them right in the same module with the code they test, exporting them, and hiding them from haddock with the prune directive. As opposed to duplicating the source tree in testsuite/
20:31:17 <dibblego> why not hide them from haddock by not annotating their type?
20:31:39 <dino-> dibblego: I tried that the other day, it gave me a the name of the function with no other information.
20:31:45 <dino-> Weird, eh?
20:31:59 <dino-> I mean, present in the Haddock generated docs.
20:32:16 <dino-> I thought what you just said too, that it would ignore non-typed.
20:32:50 <dino-> Maybe because it's exported, compels old haddock to do something.
20:48:50 <herpy> hello?
20:50:05 <QtPlaty[HireMe]> Hi
20:50:29 <herpy> I'm trying to get SDL bindings going in windows, but having no luck
20:50:44 <herpy> hitting the SDL_main undefined reference
20:50:47 <erikc> last time i got it working it was painful
20:50:55 <herpy> seems other people have had the problem, but I've seen no solutions
20:51:08 <erikc> i had to have a C program with SDL_main to wrap the haskell program
20:51:33 <erikc> i dunno if that's still the case
20:51:44 <herpy> sounds like a big pain in the ass
20:52:03 <erikc> yes, and once i did that i didnt really know how to use cabal to build my program anymore so i went back to make
20:52:24 <herpy> so is everyone giving up on SDL and going to another framework or what?
20:53:07 <erikc> depends what you are doing i guess, i just use glut/opengl and xinput bindings so i can use a xbox360 controller
20:53:37 <erikc> ive never particularly liked SDL
20:54:12 <herpy> glut actually built, so I was tempted to go that way
20:57:05 <herpy> is mingw and msys still needed to built glut?
20:57:46 <erikc> yes
20:58:34 <erikc> ive given up on windows and just switched to f# or c++ using directx
20:59:25 <erikc> i cant take the halfbaked pseudo unix stuff like cygwin and msys anymore, they just arent first class on the platform
21:00:59 <thoughtpolice> the SDL_main issue seems particularly annoying and it bites a lot of people
21:01:07 <herpy> yeah, so far haskell support on windows seems pretty lacking
21:01:34 <thoughtpolice> i'm also not convinced it isn't stupid to have in the first place, but someone can correct me there if they have valid reasoning
21:02:17 <thoughtpolice> herpy: I normally just aim for glut/glfw. the SDL bindings are too annoying
21:02:51 <thoughtpolice> also, GHC support (or lack thereof) on windows from what I understand isn't that hot
21:03:00 <thoughtpolice> but there don't seem to be many people willing to help out with it...
21:04:41 <thoughtpolice> so it seems like a fairly damning situation, yes. need more windows hackers == much better windows support.
21:05:41 <herpy> that seems odd with all of the popularity the language seems to be having
21:05:59 <erikc> thoughtpolice: SDL_main provides the dubious benefit of not needing to differentiate between main() and WinMain(), way too annoyance caused for that hehe
21:06:17 <herpy> is the popularity really more 'shallow' and people are just taking a passing look at it?
21:06:29 <thoughtpolice> herpy: it seems through an informal poll (by 'informal' i mean with 0 statistics whatsoever,) most haskellers are linux/osx users, etc.
21:07:04 <herpy> trendwhores ;)
21:07:49 <thoughtpolice> so, the state of windows support seems a bit worse off.
21:07:50 <erikc> GHC on windows is great until you need to interoperate with C libs (or packages that need C libs), cause those C libs tend to be unix libs
21:07:54 <thoughtpolice> not as many people actively using it
21:07:57 <thoughtpolice> not as many people filing bugs
21:07:58 <thoughtpolice> etc. etc.
21:08:04 <mmorrow> herpy: i think it's more that not many people are particularly interested in hacking low-level windows code
21:08:32 <erikc> and GHC sits on top of gcc/msys so you are stuck with a decaying toolchain (msys hasnt been refreshed in forever, install is a total mess, 64-bit systems barely supported)
21:08:33 <mmorrow> and windows not being posix hurts too
21:08:43 * thoughtpolice remembers his days of writing stuff using the NT API and going through ntoskrnl.exe disassemblies
21:09:58 <herpy> I haven't looked at win7, but I'm guessing it isn't any better
21:10:19 <thoughtpolice> erikc: there is a ticket about getting GHC to compile under VS - most of that would probably go into RTS work, but there are a lot of GCC extensions used in the code, particularly global reg vars for specifying which registers the RTS keeps track of for garbage collection/function arguments, etc
21:10:57 <thoughtpolice> and i'm not sure there is an analog available for that in VS
21:11:04 <erikc> herpy: nope, im running win7 and using vs2010 for f#, win7 is same as vista
21:11:31 <erikc> thoughtpolice: afaik there are no global reg vars for vc++
21:11:36 <thoughtpolice> for that matter, like I was mentioning earlier it's not available in clang yet either apparently
21:11:43 <thoughtpolice> which means llvm/clang is out of the picture for the moment too
21:11:56 <thoughtpolice> although apparently getting llvm on windows is a tremendous bitch right now anyway
21:12:03 <thoughtpolice> they apparently are working on switching to CMake though
21:12:22 <thoughtpolice> actually I'm not totally sure if global reg vars are possible in clang, at least not easily
21:12:50 <thoughtpolice> the LLVM IR has intrinsics to specify some variable (like a parameter) should be in a register, but you have almost no further control than that considering, well, you're dealing with LLVM IR and not actual instructions
21:13:01 <herpy> would cross compiling to windows be any better?
21:13:31 <thoughtpolice> erikc: so FTM it seems as though GCC is the only viable option
21:13:41 <thoughtpolice> seriously - wasn't mingw with gcc 4 promised like, you know
21:13:48 <thoughtpolice> *years* ago?
21:13:51 <thoughtpolice> when it like, came out?
21:14:43 <thoughtpolice> i heard the reasoning that gcc 4.0 as a branch was 'too buggy to have a reliable port,' but come on, that was like 2005. it's 09 and we've basically got GCC 4.4 breathing down our backs with neat things like FDO
21:14:48 <erikc> thoughtpolice: yea, there's a real divide between linux/mac and windows when it comes to C development, it's a huge pain point for everyone
21:15:43 <herpy> should I be using glfw or glfw-ogl?
21:15:50 <erikc> yea, and c++0x support
21:15:56 <thoughtpolice> personally I do hope clang crushes all competition in the end because A) faster, B) error messages are reasonable without causing a major cascade of errors because you forgot ';', and C) because it is modular, LLVM is attractive, and has a better license
21:16:04 <thoughtpolice> although C should probably be 'C, D and E' :p
21:16:25 <erikc> hehe
21:16:48 <thoughtpolice> so, there are a lot of reasons I hope clang will destroy everything else in terms of high quality compiler implementations
21:18:30 <thoughtpolice> for C, anyway. once their GNU C compatability is complete or at least 'basically done' (including global/local reg vars please god,) I hope to switch as soon as possible
21:19:24 <erikc> herpy: not sure, i only used OpenGL package, although if i were to use it today i'd use OpenGLRaw cause i'd spend less time mentally translating between C and Haskell
21:20:12 <erikc> thoughtpolice: it annoys me to no end that microsoft has decided to ignore C99 too
21:21:15 <erikc> although i guess it's a moot point since C++ wont track C99's features
21:21:19 <erikc> what a mess :)
21:22:19 <herpy> it just seems like the same problem everywhere else
21:22:40 <herpy> everyone thinking their own way is vastly superior instead of having something that helps everyone
21:23:06 <herpy> look at all the linux distros now
21:24:36 <erikc> yea :/, it's all platform wars
21:25:52 <herpy> they are doing it with everything, almost make me thing open source just means more division
21:26:07 <herpy> even filesystems
21:29:39 <thoughtpolice> herpy: same with the whole mono debacle going on or whatever
21:30:02 <erikc> there's a mono debacle?
21:30:05 <thoughtpolice> i really like free software and all, but I hate when people turn into blind savages when they are confronted with something their God did not decree was good
21:30:11 <thoughtpolice> or something
21:30:17 <thoughtpolice> erikc: well, there has been
21:30:21 <mkfort> whats the problem with multiple linux distros and file systems?
21:30:21 <thoughtpolice> pretty much since the project started
21:30:28 <erikc> ah
21:31:03 <mkfort> I like choice, there's no problem using jfs or anything else instead of ext3 if it suits your needs
21:31:23 <mkfort> what I love about linux is that I can set my mom and girlfriend up with ubuntu and its great for them and I can use arch and its great for me
21:31:50 <thoughtpolice> i like linux because it runs on my ps3, which dramatically increases my level of wisardry as far as my friends are concerned
21:32:04 <thoughtpolice> it's how i get all the ladies too, fwiw
21:32:21 <mkfort> thoughtpolice: can you access the graphics stuff from ps3 linux yet or is it still sort of crippled?
21:32:38 <herpy> I just mean choice is good, but every guy that gets mad at some higher dev gets mad and creates a fork
21:32:48 <Pseudonym> I like linux because it proves I'm a nerd.
21:32:49 <vininim> one pps cripled for DRM and the nvidia card not acessible too
21:32:56 <herpy> a few hundred flavors of linux is too many
21:33:10 <Pseudonym> herpy: Too many for what, though?
21:33:12 <thoughtpolice> yeah, like vininim said, there is one SPE that is reserved
21:33:16 <thoughtpolice> for the system or whatever
21:33:17 <vininim> *spe
21:33:19 <vininim> heh
21:33:19 <mkfort> not really, there are a few major players and then there are niches for people that want them
21:33:25 <Pseudonym> Right.
21:33:27 <thoughtpolice> however, you can directly access the graphics card on the ps3 still
21:33:43 <Pseudonym> Essentially, you can assume that a linux distro is one of the top half-dozen or so.
21:33:44 <thoughtpolice> mkfort: there is a hypervisor API which is apart of the mainline kernel which allows you to call into the XMB hypervisor
21:33:53 <thoughtpolice> mkfort: some of these APIs relate to the GPU
21:33:57 <thoughtpolice> many are undocumented
21:33:59 <QtPlaty[HireMe]> The flavours are cross compatable, which is more then you can say for unix polifiration.
21:34:04 <Pseudonym> And LSB is a safe assumption.
21:34:09 <vininim> I thought the hypervisor protectd acess to it
21:34:16 <thoughtpolice> mkfort: but lots of work on the matter of getting to the graphics card has been done pretty much just by examining kernel source
21:34:24 <vininim> but I read that a long time ago, people were still trying to hack with some sucess
21:34:27 <mkfort> well thats cool, although I still have a hard time trusting sony after the whole rootkit debacle
21:34:47 <mkfort> thoughtpolice: thats cool if you can get at the graphics, which is sort of the point
21:34:56 <Pseudonym> mkfort: Different branches.  Sony's left hand doesn't know who their right hand is doing.
21:35:06 <mkfort> Pseudonym: very true
21:35:48 <mkfort> although honestly I'm pretty excited to go out and get the wii motion plus
21:35:50 <Pseudonym> What's disturbing about mega-corporatism is that the decision to rootkit every PC in the world probably wasn't made at a high level.
21:35:58 <thoughtpolice> mkfort: http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=blob;f=arch/powerpc/include/asm/lv1call.h;h=81713acf752997787b2ab58b7316debf10aec178;hb=HEAD
21:36:05 <thoughtpolice> mkfort: also, http://wiki.ps2dev.org/ps3:hypervisor
21:36:18 <mkfort> all my console gaming is on the wii, I like to play stupid games with other people, my gf and I play tetris party constantly
21:36:20 <thoughtpolice> ^^ that has a list of documented APIs and some undocumented APIs that people figured out through reversing
21:36:39 <thoughtpolice> mkfort: someone also had some code on the ps2 dev forums (iirc) that showed how you can directly access the framebuffer, etc.
21:36:43 <mkfort> even my mom plays tons of wii tennis
21:37:33 <herpy> the one thing I hate about the wii - everyone wants to play wii bowling
21:37:47 <mkfort> the only sad thing about the wii is that the game it comes with is the best for it still, although I think the motion plus is really going to change that, they say that the new tiger woods is the best golf game ever on any system
21:38:25 <mkfort> herpy: yeah, bowling and tennis are still pretty much the best, I mean there are other good games but not that use the 'motion controls' which everyone quickly learned was overhyped, the motion plus attachment should live up to the hype
21:39:03 <mkfort> only problem then is that it costs $80 to get a fully outfitten controller with a nunchuck, motion plus, and possibly a classic controller
21:39:16 <mkfort> other thing I really enjoy is the virtual console though
21:39:22 <erikc> hacking the ps3 gpu at this point is sorta pointless, your average gaming PC has a lot more horsepower than the PS3 anyway
21:39:42 <erikc> i guess i should say, usable horsepower
21:40:02 <thoughtpolice> well, you can utilize all but n-1 SPE's on a linux box running on the ps3
21:40:10 <thoughtpolice> keep in mind however the cell is quite an exotic architecture
21:40:16 <thoughtpolice> it will not fit a lot of applications very well
21:40:43 <erikc> i worked on compilers for it, and dev on it, i know it (sadly) too well
21:41:05 <thoughtpolice> i mean, didn't the ps3 pretty much dominate folding@home as soon as it was released?
21:41:10 <mkfort> looks like its fun to hack, I just don't think I'd play that many actual games on it
21:41:14 <herpy> what is the benefit of opengl raw?
21:41:45 <thoughtpolice> the stats I remembered seeing said that about 22,000 ps3's did nearly 90% or something of folding@home computation, while the other ~2million PCs (of various sorts) took up the other 10%
21:41:54 <thoughtpolice> which is pretty damn impressive
21:41:55 <erikc> herpy: it maps 1 to 1 to the c library
21:42:35 <erikc> yes, but very specialized kernel loops just number crunching
21:43:13 <thoughtpolice> in any case if you really want that sort of horsepower for whatever you're doing, you might also be in a position to get a commercial license for development of ps3 apps that don't need to run on linux (like folding@home)
21:43:31 <herpy> but using opengl raw, I'd have to do my own (or wrap win32 and wx) windowing and input?
21:43:33 <thoughtpolice> but i don't know anything about that area, or how much something like that would cost
21:43:40 <erikc> 20k / devkit
21:44:15 <erikc> or was it 15k, i think they announced a lowering at this year's gdc
21:44:26 <thoughtpolice> erikc: which allows you to write apps that run on e.g. XMB?
21:44:31 <erikc> yea
21:44:43 <thoughtpolice> neat
21:44:52 <thoughtpolice> the wii devkit is like, ridiculously cheap from what I've heard
21:45:06 <erikc> you need a publishing deal and a real business plan though
21:45:24 <erikc> my guess is @home was a publicity headline grab
21:45:35 <thoughtpolice> i didn't think they would just sell it to any college student with a few grand lying around :p
21:45:55 <erikc> herpy: yes
21:46:28 <herpy> we were in talks to get a wii kit and they limit it a lot
21:46:46 <herpy> mainly to 'only allow quality' games
21:46:57 * erikc chuckles
21:46:59 <thoughtpolice> IOWs: go to hell?
21:47:18 <herpy> you hear about that bob's game guy?
21:47:22 <thoughtpolice> yeah
21:47:26 <herpy> some college guy, they could care less
21:47:56 <herpy> we did lots of mobile games and worked as an independent branch of a larger publishing company, so that is the only reason we had a chance
21:48:06 <thoughtpolice> it's also not like I expected them to have those things we call 'emotions' etc. either
21:48:10 <thoughtpolice> :p
21:48:43 * thoughtpolice should probably get an actual job writing software sometime soon if possible
21:49:27 <thoughtpolice> sitting in a computer lab at uni. is waaaay too boring, even if quiet and a place to write code
21:54:22 <erikc> quiet is nice :)
21:54:58 <erikc> a high priority for my next job would be a private office, which seems to be a vanishing luxury
21:55:31 <thoughtpolice> erikc: :( cubicles?
21:56:19 <erikc> cubicles and open plans (a.k.a. desk in the middle of a big open room) are the norm
22:03:37 <dmwit> :t findIndex
22:03:38 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe Int
22:05:02 <dmwit> > let excel = [1..] >>= flip replicateM ['a'..'z'] in findIndex (=="aqp") excel
22:05:03 <lambdabot>   Just 1133
22:14:25 <herpy> if haskell says to do 8 spaces, why is all the code I copy in not 8?
22:14:40 <dmwit> Haskell never says to do 8 spaces.
22:14:59 <herpy> really? I was reading some thing that say that was the layout rule
22:14:59 <dmwit> Haskell says tabs are equivalent to enough spaces to fill up to the next multiple of 8, nothing more, and nothing less.
22:15:13 <herpy> oh, ok
22:15:38 <herpy> so code with 4 space indents is okay?
22:15:43 <dmwit> Absolutely.
22:15:44 <sjanssen> herpy: yes
22:15:54 <dmwit> It's not only okay, it's quite common.
22:16:20 <sjanssen> herpy: the rules only specify that certain lines must be indented more than others, not how much
22:16:24 <sjanssen> so even one space works
22:16:25 <herpy> that explains why I couldn't get autoformatting :)
22:16:58 <herpy> so you guys actually type those spaces for indents?
22:17:38 <herpy> a stupid question, I know, but just seeing
22:17:57 <dmwit> Definitely not.
22:18:15 <jmcarthur> text editors can be configured to give multiple spaces instead of tabs
22:18:20 <dmwit> Any editor worth being called that has a way to set the size of a tabstop and whether it inserts literal tabs or spaces.
22:18:36 <herpy> oh, so you set tabs to insert 4 spaces for example?
22:18:40 <dmwit> right
22:18:49 <herpy> okay, the tabs are 8 spaces was messing me up
22:18:51 <dmwit> And, here, I set lines to preserve the indentation of the previous one.
22:19:10 <dmwit> So only when indentation changes are extra keypresses needed. =)
22:19:34 <herpy> so is 3 or 4 spaces more common?
22:20:04 <jmcarthur> i tend to use 2 or 4 when i'm not trying to line up with something above
22:20:07 <Cale> I set my tab key to 2 spaces, but I use all sorts of different indents to make things line up
22:20:14 <dmwit> I use four.  I can't say I've read enough of other people's code to say which is more common.
22:20:46 <jmcarthur> 2 for do notation, 4 for where clauses, typically
22:20:50 <dmwit> I also think we should be using elastic tabstops so this "lining things up" could finally be done in a nice way. =)
22:20:51 <jmcarthur> but it's just personal preference
22:21:53 <Cale> I think the editors should just understand Haskell's indentation rule properly
22:22:18 <dmwit> But the things I want to line up have nothing to do with the indentation rule.
22:22:29 <dmwit> Like = signs in multi-line definitions or where clauses, or <- in do blocks.
22:22:55 <dmwit> And if we had a nice way of doing those, the indentation rule would be an easy layer on top of them...
22:23:04 <Cale> Any edit which causes a 'let', 'of', 'do', or 'where' to move by some amount, should cause the entire block which it is attached to move by that amount, recursively
22:23:10 <dmwit> I even have a plan, if only I could get somebody to pay me to just code whatever I felt like. =P
22:23:32 <dmwit> Cale: totally
22:24:37 <Cale> (including if I put my cursor right before a 'do', and hit enter)
22:24:45 <dmwit> (But I also note that there are other ways to do that than understanding Haskell's indentation rule.)
22:25:00 <Cale> I don't think there's any true substitute.
22:25:06 <dmwit> I do.
22:25:09 <Cale> Without getting the user to insert special characters
22:25:22 <jmcarthur> i think text formatted programming languages are the problem!
22:25:32 <jmcarthur> text file, i mean
22:25:39 <dmwit> hehe, now we're opening a *real* can of worms =)
22:25:53 <jmcarthur> of course, it's easy to complain about the problem without proposing a solution ;)
22:28:40 <herpy> neat, it looks like I can use OpenGL.Raw with glfw
22:28:49 <herpy> I found an example using glut
22:41:31 <herpy> any idea why this code isn't running? http://aedion.de/haskell/SmoothRaw.hs
22:41:37 <herpy> I get error on 52:4
22:41:49 <herpy> "The last statement ina  'do' construct must be an expression"
22:41:54 <dmwit> > let exact ns n = case compare n 0 of { LT -> []; EQ -> [[]]; GT -> ns >>= map (n:) . exact ns . (n-) } in exact 1505 [215, 275, 335, 355, 420, 580]
22:41:55 <lambdabot>   No instance for (GHC.Num.Num [[t]])
22:41:55 <lambdabot>    arising from the literal `1505' at <...
22:42:52 <dmwit> herpy: Which line is 52?
22:43:18 <herpy> yeah
22:43:22 <herpy> oh, sorry
22:43:33 <herpy> let wf = fromIntegra w
22:43:43 <herpy> after glLoadIdentity
22:44:38 <dmwit> Are you sure you pasted exactly the file you're trying to compile?
22:44:57 <herpy> that isn't my file, an example I found
22:45:39 <herpy> you think spaces or something could do it?
22:46:02 <dmwit> The file looks fine to me.  I would bet your paster broke it or something.
22:46:46 <herpy> doing it again with view source, I get even more errors
22:46:49 <dmwit> > let exact ns n = case compare n 0 of { LT -> []; EQ -> [[]]; GT -> ns >>= \m -> map (m:) (exact ns (n-m)) } in exact 1505 [215, 275, 335, 355, 420, 580]
22:46:50 <lambdabot>   No instance for (GHC.Num.Num [[t]])
22:46:51 <lambdabot>    arising from the literal `1505' at <...
22:47:06 <dmwit> herpy: Can't you just use wget or something to get the exact file?
22:47:27 <dmwit> ...or your browser's own "save file" function.
22:47:43 <dmwit> > let exact ns n = case compare n 0 of { LT -> []; EQ -> [[]]; GT -> ns >>= \m -> map (m:) (exact ns (n-m)) } in exact [215, 275, 335, 355, 420, 580] 1505
22:47:45 <lambdabot>   [[215,215,215,215,215,215,215],[215,355,355,580],[215,355,580,355],[215,580...
22:47:49 <dmwit> ultra win
22:48:13 <dmwit> Oh, man, not an ultra win, it does permutations...
22:53:28 <dmwit> > let exact ns n = case (compare n 0, ns) of { (EQ,_) -> [[]]; (GT,m:ms) -> map (m:) (exact (m:ms) (n-m)) ++ exact ms n; _ -> [] } in exact [215, 275, 335, 355, 420, 580] 1505
22:53:30 <lambdabot>   [[215,215,215,215,215,215,215],[215,355,355,580]]
22:53:34 <dmwit> Much better.
22:55:03 <jeff_s_> lambdabot: Happy to oblige.
22:55:06 <jeff_s_> Now how cool would that be?
22:55:32 <herpy> ok, different error now
22:55:35 <herpy> SmoothRaw.hs:48:9:     Couldn't match expected type `OpenGL-2.2.1.1:Graphics.Rendering.OpenGL.GL.CoordTrans.Size'            against inferred type `Size'
22:55:37 <dmwit> jeff_s_: You seem to be mumbling to yourself.
22:57:10 <dmwit> herpy: What happens if you change the import line from "Size(..)" to "Size(Size)"?
22:57:11 <herpy> looks like maybe I need to cabal ogl
22:57:20 <mib_c7mju5cv> hi
22:58:13 <mib_c7mju5cv> i need a bit of help with haskell; am a newbie to functional programming
22:58:29 <dmwit> mib_c7mju5cv: Just go ahead and ask your question, it's easier on everybody.
22:59:05 <mib_c7mju5cv> i have installed ghc compiler 6.10.3 on ubuntu 8.04
22:59:24 <mib_c7mju5cv> i downloaded it from the site the tar.bz2 file
22:59:39 <mib_c7mju5cv> and followed the instructions in the folder
23:00:08 <mib_c7mju5cv> when i try to compile the file by "ghc try.hs"
23:00:19 <mib_c7mju5cv> i get an error "cannot find -lgmp"
23:00:27 <mib_c7mju5cv> what on earth is that??
23:00:33 <dmwit> You need to install libgmp-dev.
23:00:47 <dmwit> I don't know if that's the exact package name on Ubuntu, but it should be something very similar to that.
23:00:49 <mib_c7mju5cv> how big is it??
23:00:59 <dmwit> Ask your package manager.
23:01:00 <dmwit> =)
23:01:15 <mib_c7mju5cv> ok
23:02:20 <mib_c7mju5cv> is the package libgmp-ocaml-dev enough??
23:02:29 <herpy> reshape (Size w h) = do
23:02:53 <dmwit> mib_c7mju5cv: No, I don't think that one is the right one.
23:03:04 <herpy> so put Size(Size) in there?
23:03:05 <dmwit> And one question mark suffices to mark questions. =)
23:03:12 <dmwit> herpy: No, in the import line.
23:03:30 <m3ga> mib_c7mju5cv: apt-cache search libgmp
23:03:39 <m3ga> the one you want is libgmp3-dev
23:03:48 <dmwit> herpy: I'm talking about the line with the literal characters "Size(..)", even the ".." are literally there.
23:03:54 <Lemonator> Hell yeah, FINALLY
23:03:59 <Lemonator> Type reconstruction.
23:04:06 <herpy> dmwit: gives the same thing
23:04:17 <dmwit> herpy: Okay, then you can revert it.  That's a very strange error.
23:05:14 <herpy> odd that the cabal install names don't match up to import names
23:05:26 <dmwit> eh?
23:05:38 <mib_c7mju5cv> dmwit:lidgmp3-dev will suffice??
23:05:58 <dmwit> That should work, yes.
23:06:07 <mib_c7mju5cv> ok let me give it a shot
23:06:10 <herpy> like ogl vs opengl
23:06:41 <bnijk> how do i do > fix (:) "blah" again
23:07:00 <herpy> oh, bad example
23:07:08 <dmwit> > fix ("blah":)
23:07:09 <lambdabot>   ["blah","blah","blah","blah","blah","blah","blah","blah","blah","blah","bla...
23:07:20 <dmwit> > fix ("blah " ++)
23:07:21 <lambdabot>   "blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah...
23:07:38 <bnijk> ah ok
23:07:46 <dmwit> > cycle "blah " -- better memory stats
23:07:47 <lambdabot>   "blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah...
23:07:54 <dmwit> > repeat "blah" -- same idea
23:07:55 <lambdabot>   ["blah","blah","blah","blah","blah","blah","blah","blah","blah","blah","bla...
23:07:59 <mib_c7mju5cv> dmwit:any suggestions on good haskell tutorials?? i am a complete newbie to the world of functional programming
23:08:06 <dmwit> ?where gentle
23:08:06 <lambdabot> http://www.haskell.org/tutorial/
23:08:06 <bnijk> > cycle "\"\""
23:08:08 <dmwit> ?where LYAH
23:08:08 <lambdabot>   "\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"...
23:08:08 <lambdabot> www.learnyouahaskell.com
23:08:13 <dmwit> ?where YAHT
23:08:13 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
23:08:16 <bnijk> > cycle ";) "
23:08:17 <dmwit> ?where RWH
23:08:17 <lambdabot> is http://www.realworldhaskell.org/blog/
23:08:18 <lambdabot>   ";) ;) ;) ;) ;) ;) ;) ;) ;) ;) ;) ;) ;) ;) ;) ;) ;) ;) ;) ;) ;) ;) ;) ;) ;)...
23:08:30 <dmwit> mib_c7mju5cv: Those are the four most popular ones.
23:08:35 <bnijk> > cycle ">8O "
23:08:36 <lambdabot>   ">8O >8O >8O >8O >8O >8O >8O >8O >8O >8O >8O >8O >8O >8O >8O >8O >8O >8O >8...
23:08:45 <bnijk> > cycle ">8D "
23:08:46 <thoughtpolice> > "wh" ++ (cycle 'e')
23:08:46 <lambdabot>   ">8D >8D >8D >8D >8D >8D >8D >8D >8D >8D >8D >8D >8D >8D >8D >8D >8D >8D >8...
23:08:47 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
23:08:49 <mib_c7mju5cv> are they good enough for beginners??
23:08:52 <herpy> >cycle cycle 1 2
23:09:14 <dmwit> > "wh" ++ repeat 'e'
23:09:16 <lambdabot>   "wheeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee...
23:09:24 <thoughtpolice> > "wh" ++ (cycle "e")
23:09:26 <lambdabot>   "wheeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee...
23:09:46 <bnijk> > "shiiii" + cycle "t"
23:09:46 <mib_c7mju5cv> after compiling the haskell source code, how do i run it??
23:09:47 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
23:09:47 <lambdabot>    arising from a use of `GH...
23:09:53 <bnijk> > "shiiii" ++ cycle 't'
23:09:54 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
23:09:57 <bnijk> > "shiiii" ++ cycle "t"
23:09:59 <lambdabot>   "shiiiitttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttt...
23:10:00 <bnijk> idiot bot
23:10:55 <bnijk> @let lambdabotWhatDoYouThinkAboutDons x = (take 6 cycle x) ++ "gaaaayyyyyyy"
23:10:56 <lambdabot>  Couldn't match expected type `[a]'
23:11:01 <Ycros> yeah, it should correct your errors for you.
23:11:03 <bnijk> oh boy
23:11:13 <bnijk> where do i even begin with this
23:11:31 <bnijk> nah, actually, i'll just give up
23:11:32 <mib_c7mju5cv> which file do i run in order to see the output after i compile the source file??
23:11:32 <bnijk> completely
23:11:42 <bnijk> the file you compiled the source to
23:11:58 <bnijk> or you mean compile it as .o
23:12:01 <bnijk> er .hi
23:12:16 <dmwit> .o was right
23:12:19 <dmwit> .hi, too
23:12:24 <mib_c7mju5cv> i have both
23:12:26 <mib_c7mju5cv> .hi and .o
23:12:36 <mib_c7mju5cv> which is the executable?
23:12:50 <dmwit> mib_c7mju5cv: If you actually have a "main", it will be placed in a file with the same name as the module.
23:13:04 <dqd> Default executable is the a.out file.
23:13:06 <dmwit> mib_c7mju5cv: If you have not named the module, it will probably be placed in a.out or something equally stupid.
23:13:24 <dqd> (You can specify the executable by -o flag.
23:13:25 <dqd> )
23:13:30 <bnijk> now let's say i want to do
23:13:31 <bnijk> > foldr (:) fix ("sykomp sucks":)
23:13:32 <lambdabot>   Couldn't match expected type `[a]'
23:13:39 <bnijk> why doesn't that work
23:13:57 <mib_c7mju5cv> dmwit: i did not understand what you said??
23:14:08 <dmwit> bnijk: Because ("sykomp sucks":) is not a list?
23:14:11 <mib_c7mju5cv> what do you mean by "have a main"?
23:14:11 <bnijk> > foldr (++) 1 fix ("sykomp sucks":)
23:14:12 <lambdabot>   Couldn't match expected type `[[a]]'
23:14:23 <mib_c7mju5cv> dmwit:a main in the code?
23:14:29 <bnijk> > fix ("sykopomp sucks":)
23:14:30 <lambdabot>   ["sykopomp sucks","sykopomp sucks","sykopomp sucks","sykopomp sucks","sykop...
23:14:30 <mib_c7mju5cv> this is the code i am trying to compile
23:14:35 <bnijk> is that not a list
23:14:37 <dmwit> mib_c7mju5cv: Don't paste here!
23:14:38 <bnijk> or a list of lists!
23:14:51 <dmwit> bnijk: Try parenthesizing your function application.
23:14:52 <mib_c7mju5cv> ok
23:14:56 <dmwit> ?hpaste
23:14:56 <lambdabot> Haskell pastebin: http://hpaste.org/new
23:15:01 <dmwit> mib_c7mju5cv: ^^
23:15:03 <bnijk> > foldr (++) 1 (fix ("sykomp sucks":))
23:15:04 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
23:15:05 <lambdabot>    arising from the literal ...
23:15:16 <dmwit> bnijk: 1 is not a list, either.
23:15:20 <bnijk> > foldr (++) (fix ("sykopomp sucks":))
23:15:21 <lambdabot>   Overlapping instances for GHC.Show.Show
23:15:21 <lambdabot>                              ([[[GH...
23:15:26 <bnijk> mmnnn
23:15:30 <bnijk> my memory isn't quite working
23:15:39 <bnijk> aka my haskell ability
23:15:48 <dmwit> bnijk: Anyway, why not just use "concat"?
23:15:56 <mib_c7mju5cv> dmwit:here's the link to it
23:15:57 <bnijk> > concat (fix ("sykopomp sucks":))
23:15:58 <lambdabot>   "sykopomp suckssykopomp suckssykopomp suckssykopomp suckssykopomp suckssyko...
23:16:01 <bnijk> > concat (fix ("sykopomp sucks ":))
23:16:03 <lambdabot>   "sykopomp sucks sykopomp sucks sykopomp sucks sykopomp sucks sykopomp sucks...
23:16:18 <mib_c7mju5cv> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5890#a5890
23:16:23 <bnijk> there we go
23:16:39 <dmwit> mib_c7mju5cv: So, did you check for the a.out file that two of us suggested to you?
23:17:15 <mib_c7mju5cv> yes it didn't run
23:17:20 <mib_c7mju5cv> let me try again once more
23:17:24 <bnijk> how do i run a function against two concurring items of two separate lists
23:17:26 <bnijk> iterating through both
23:17:32 <bnijk> a double for loop!
23:17:35 <mib_c7mju5cv> yeah it did now  thanks
23:18:01 <mib_c7mju5cv> any advice for a beginner??
23:18:01 <dmwit> bnijk: map (map f) xss?
23:18:06 <bnijk> xss?
23:18:19 <dmwit> Two 's's to denote two layers of list. =)
23:18:24 <dmwit> Oh, two separate lists.
23:18:29 <dmwit> :t zipWith
23:18:31 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
23:18:33 <bnijk> oh ok
23:18:34 <bnijk> hanks
23:18:39 <bnijk> whch one of those is the function
23:18:49 <bnijk> to be appled between them
23:18:54 <bnijk> stupid 'i' key
23:20:33 <mib_c7mju5cv> thanks dmwit for your help
23:20:46 <mib_c7mju5cv> thanks a lot
23:21:22 <herpy> cabal is a neat tool, but it seems tons of the packages have problems or exceptions
23:23:43 <bnijk> > zipWith (*) [1..100] [100..1]
23:23:45 <lambdabot>   []
23:23:45 <bnijk> ^?
23:23:58 <bnijk> porqueeee
23:24:32 <dmwit> > [100..1]
23:24:33 <lambdabot>   []
23:24:36 <dmwit> > [100,99..1]
23:24:37 <bnijk> no kidding
23:24:38 <lambdabot>   [100,99,98,97,96,95,94,93,92,91,90,89,88,87,86,85,84,83,82,81,80,79,78,77,7...
23:24:47 <bnijk> > zipWith (*) [1..100] [100,99..1]
23:24:48 <lambdabot>   [100,198,294,388,480,570,658,744,828,910,990,1068,1144,1218,1290,1360,1428,...
23:24:59 <bnijk> how do i make him make a graph out of that
23:25:07 <dmwit> right
23:25:17 <bnijk> i bet it's pretty
23:25:33 <bnijk> irssi has monospace font so it's feasible
23:25:56 <Cale> but... lambdabot will only give you one line of output here
23:26:03 <bnijk> in privmsg
23:26:07 <Cale> ah
23:26:15 <bnijk> well
23:26:17 <dmwit> > expr "a\nb"
23:26:18 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
23:26:21 <dmwit> > expr "a\nb" :: Expr
23:26:22 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
23:26:29 <dmwit> :t expr
23:26:30 <lambdabot> Expr -> Expr
23:26:32 <dmwit> oh
23:26:33 <dmwit> :t fun
23:26:34 <lambdabot> forall a. (SimpleReflect.FromExpr a) => String -> a
23:26:41 <dmwit> > fun "a\nb" :: Expr
23:26:42 <bnijk> > zip [1..100] (zipWith (*) [1..100] [100,99..1])
23:26:42 <lambdabot>   a
23:26:42 <lambdabot>  b
23:26:43 <lambdabot>   [(1,100),(2,198),(3,294),(4,388),(5,480),(6,570),(7,658),(8,744),(9,828),(1...
23:26:47 <Cale> oh, interesting
23:26:47 <dmwit> Cale: Lies!
23:26:50 <bnijk> now i take that...
23:26:55 <bnijk> anddd
23:27:12 <bnijk> > max (zipWith (*) [1..100] [100,99..1])
23:27:13 <lambdabot>   Overlapping instances for GHC.Show.Show ([a] -> [a])
23:27:13 <lambdabot>    arising from a use ...
23:27:27 <Cale> > var "a\nb"
23:27:28 <bnijk> mmnn
23:27:29 <lambdabot>   Ambiguous occurrence `var'
23:27:29 <lambdabot>  It could refer to either `Data.Number.Symbolic....
23:27:33 <dmwit> bnijk: maximum
23:27:38 <bnijk> > maximum (zipWith (*) [1..100] [100,99..1])
23:27:38 <Cale> > fun "a\nb\nc\nd"
23:27:39 <lambdabot>   2550
23:27:40 <lambdabot>   Add a type signature
23:27:42 <Cale> > fun "a\nb\nc\nd" :: Expr
23:27:44 <lambdabot>   a
23:27:44 <lambdabot>  b
23:27:44 <lambdabot>  c
23:27:44 <lambdabot>  d
23:27:45 <bnijk> > maximum (zipWith (*) [1..100] [100,99..1]) - 100
23:27:46 <lambdabot>   2450
23:27:50 <Cale> Okay, that's a problem :)
23:28:05 <bnijk> the tricky part is
23:28:09 <bnijk> turning it into a graph o.o
23:28:14 <Cale> I wonder why it doesn't cut it off...
23:28:38 <dmwit> Cale: I think there has to be special-purpose code in lambdabot to make that work. =)
23:28:44 <bnijk> i can have it iterate through each line and find all members of the tuple in range of that line
23:28:46 <dmwit> multi-line replies, that is
23:28:47 <bnijk> is that the fastest way?
23:30:24 <Cale> bnijk: If you're making an ascii-art graph, I bet that transpose would be handy
23:30:55 <dmwit> > ['a'..'z']
23:30:56 <bnijk> @type transpose
23:30:57 <lambdabot>   "abcdefghijklmnopqrstuvwxyz"
23:30:57 <lambdabot> forall a. [[a]] -> [[a]]
23:31:01 <dmwit> > ['a'..]
23:31:02 <lambdabot>   "abcdefghijklmnopqrstuvwxyz{|}~\DEL\128\129\130\131\132\133\134\135\136\137...
23:31:11 <bnijk> [
23:31:17 <bnijk> > ['A'..'z']
23:31:18 <lambdabot>   "ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz"
23:31:24 <bnijk> oh look
23:31:28 <bnijk> there's a lttle smiley face in the middle
23:31:33 <Cale> > transpose ["abc","def","ghi"]
23:31:34 <dmwit> > fun (['a'..'\136'] ++ "\nit still gets ellipsized, eh?")
23:31:35 <lambdabot>   ["adg","beh","cfi"]
23:31:36 <lambdabot>   Add a type signature
23:31:39 <dmwit> > fun (['a'..'\136'] ++ "\nit still gets ellipsized, eh?") :: Expr
23:31:41 <lambdabot>   abcdefghijklmnopqrstuvwxyz{|}~
23:31:41 <lambdabot>  it still gets ellipsized, eh?
23:31:46 <dmwit> whoops
23:31:47 <dmwit> heh
23:31:58 <dmwit> Wait... what?
23:32:03 <dmwit> I don't... oh!
23:32:11 <dmwit> oh oh
23:32:14 <bnijk> > take 30 (reverse (take 26 ['A'..'z']))
23:32:15 <lambdabot>   "ZYXWVUTSRQPONMLKJIHGFEDCBA"
23:32:15 <dmwit> > cycle ['a'..'z']
23:32:16 <lambdabot>   "abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuv...
23:32:19 <bnijk> bah
23:32:34 <bnijk> > take 30 (reverse (take 30 ['A'..'z']))
23:32:35 <lambdabot>   "^]\\[ZYXWVUTSRQPONMLKJIHGFEDCBA"
23:32:38 <dmwit> > fun ("abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqr\nhow about now?") :: Expr
23:32:40 <lambdabot>   abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqr
23:32:40 <lambdabot>  how...
23:32:43 <dmwit> hah!
23:32:50 <bnijk> > take 30 (reverse (take 32 ['A'..'z']))
23:32:51 <lambdabot>   "`_^]\\[ZYXWVUTSRQPONMLKJIHGFEDC"
23:32:54 <dmwit> Cale: So it is relatively safe, anyway... can't flood more than 80 lines or so. =P
23:32:56 <bnijk> > take 3 (reverse (take 32 ['A'..'z']))
23:32:57 <lambdabot>   "`_^"
23:33:01 <bnijk> :)
23:33:06 * bnijk pets lambdabot
23:33:18 <dmwit> > ['`'..'^'] -- way easier
23:33:20 <lambdabot>   ""
23:33:28 <bnijk> i like my way better, honestly
23:33:28 <dmwit> uh
23:33:40 <dmwit> oh
23:33:42 <bnijk> shows more effort!
23:33:43 <Cale> > fun (cycle ['a'..'z']) :: Expr
23:33:45 <lambdabot>   abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvw...
23:33:49 <dmwit> > ['^'..'`'] -- way easier
23:33:50 <lambdabot>   "^_`"
23:34:11 <bnijk> yours is backwards!
23:34:12 <bnijk> tsk, tsk
23:34:20 <dmwit> No, yours is.
23:34:26 <bnijk> no, yours is!
23:34:50 <bnijk> then glguy comes in and says
23:34:51 <dmwit> I'm sorry, but my impeccable grammar and punctuation simply seal the deal on this one.  Yours is, in fact, the backwards one.
23:34:56 <bnijk> "it's all a matter of perspective, children"
23:35:00 <glguy> ?
23:35:05 <bnijk> ???
23:35:16 <bnijk> settle our dispute
23:35:29 <bnijk> which is backwards, `_^ or ^_`
23:35:42 <Cale> 
23:35:47 <bnijk> oh boy Cale
23:36:21 <bnijk> that's just way off
23:37:24 <Cale> 
23:37:32 <bnijk> wtf is that
23:37:43 <Cale> What?
23:38:24 <dmwit> That's the first time I've seen boxes in urxvt.
23:38:44 <Cale> Unicode font coverage support fail?
23:38:48 <dmwit> That's pretty impressive.
23:38:57 <nlogax> TOP ARC ANTICLOCKWISE ARROW WITH PLUS
23:39:00 <glguy> shows up in terminal.app with the default font
23:39:02 * dmwit wonders briefly what font he would need, remembers the morass that is fonts in Linux, and wanders off
23:39:13 <Cale> (it looks a bit like an eye if you don't look too close)
23:39:50 <Cale> _
23:39:58 <bnijk> that one i like
23:40:19 <bnijk> J_r;;::___;;[g-__
23:40:29 <Cale> hm?
23:40:47 * bnijk scratches his head
23:40:53 <dmwit> 
23:41:02 <Cale> hehe, snowman :)
23:41:27 <bnijk> or a lamp depending on who you ask
23:41:39 <dmwit> If you ask the spec, it's a snowman. ;-)
23:41:49 * bnijk makes his font bigger
23:41:58 <bnijk> oh that is a snowman
23:42:06 <bnijk> unicode++
23:42:17 <Cale> 
23:42:27 <bnijk> how are you entering those characters?
23:42:32 <bnijk> scim or something?
23:42:36 <Cale> Yeah, scim
23:42:46 <Cale> and gucharmap for the really strange ones
23:42:49 <dmwit> Starcraft input method?
23:42:57 <Cale> hehe
23:43:07 <bnijk> nope
23:43:07 <dmwit> Zerg rush kekeke!
23:43:10 <bnijk> =-o
23:43:23 <dmwit> err... zerg*ling* rush, of course
23:43:35 <bnijk> what FONTS are unicode
23:43:52 <dmwit> ?go things every developer should know about unicode
23:43:52 <lambdabot> http://www.joelonsoftware.com/articles/Unicode.html
23:43:53 <lambdabot> Title: The Absolute Minimum Every Software Developer Absolutely, Positively Must Know A ...
23:43:53 <Cale> I have Japanese input support (not Korean though).
23:43:59 <bnijk> 
23:44:17 <Cale> I suppose I could install Korean input support, but I don't know any Korean.
23:44:27 <bnijk> 
23:44:27 <dmwit> bnijk: The question is meaningless.
23:44:36 <Cale> bnijk: Runes!
23:45:07 <bnijk> 
23:45:07 <Cale> 
23:45:15 <bnijk> it's a table full of pancakes
23:45:20 <bnijk> in a grid...
23:45:24 <Cale> hehe
23:45:38 * Cale wonders who else has a font with  Linear B characters :)
23:46:00 <Cale>   Wheeled Chariot!
23:46:11 <bnijk> 
23:46:47 <bnijk>  that fish from that video game where you end up trying to blow up an asteroid!
23:47:06 <bnijk> i think it started with "d"
23:47:17 <bnijk> which cleary makes this pe
23:47:27 <bnijk>  a housefly
23:47:51 <Cale> 
23:51:31 <QtPlaty[HireMe]> @type (~=)
23:51:33 <lambdabot> Not in scope: `~='
23:51:45 <QtPlaty[HireMe]> @type (=~)
23:51:46 <lambdabot> forall source1 source target. (regex-base-0.72.0.2:Text.Regex.Base.RegexLike.RegexMaker Regex CompOption ExecOption source, regex-base-0.72.0.2:Text.Regex.Base.RegexLike.RegexContext Regex source1
23:51:46 <lambdabot> target) => source1 -> source -> target
