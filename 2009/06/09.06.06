00:00:06 <pumpkin> couldn't think of a better word
00:00:08 <pumpkin> so I made one up
00:01:11 * Gracenotes is now watching Ponyo on the Cliff by the Sea
00:01:26 <Gracenotes> sort of, uh, Little Mermaid. Except Japanese and with toddlers.
00:01:41 <Cale> base <topic marker> all/entirely we <genitive marker> thing <declarative particle>
00:02:07 <Gracenotes> and without the musical
00:02:13 <Millz|CERN> did you guys know that IT guys at cern dont even know haskell? ;o thats an outrage
00:02:20 <pumpkin> terrible!
00:03:14 <Millz|CERN> indeedo
00:03:30 <Millz|CERN> if they'd run haskell on lhc it wouldnt have broken
00:03:31 <ski> (Gracenotes : not Mizuno's "Princess Mermaid", then ?)
00:03:31 <Millz|CERN> !
00:03:38 <Cale> I ACCIDENTALLY ALL YOUR BASE
00:04:01 <pumpkin> zomg (xzibit meme)
00:04:27 <Gracenotes> ski: uh... don't think so :3
00:04:38 * ski grins
00:04:50 <Cale> Millz|CERN: They could even have used the LHC compiler.
00:05:06 <Millz|CERN> Large Haskell Compiler??
00:05:14 <pumpkin> lemmih's haskell compiler
00:05:19 <Gracenotes> How is anime formed?
00:05:22 <Gracenotes> How cels become shadded?
00:05:27 <Millz|CERN> ah
00:05:30 <Millz|CERN> never heard of it
00:05:37 <pumpkin> you need to do way instain fullmetal alchemist
00:05:43 <Millz|CERN> Gracenotes, you dont want to know...
00:05:50 <p_l> Gracenotes: no longer done this way, now it's digital and quite often with procedural stuff and 3D
00:05:52 <Cale> http://lhc.seize.it/
00:05:54 <pumpkin> who kill thier mothers because these mother cant frigth back?
00:06:09 <Gracenotes> p_l: yeah :)
00:06:20 <Gracenotes> even south park uses 3D rendering
00:06:37 <p_l> Gracenotes: Though, look at Hoshi no Koe.
00:06:47 <pumpkin> it was in the news this mroing, two brothers in ar who had used 錬金術 on their 母!
00:06:51 <Millz|CERN> pumpkin, is the code faster than with ghc?
00:06:57 <pumpkin> Millz|CERN: it plans to be
00:07:01 <Millz|CERN> lol
00:07:06 <Millz|CERN> gud
00:07:31 <p_l> Gracenotes: author (yes, singular) got a distinctive CG style and seems to have used rather frame-by-frame animation (though completely on his Mac, not analog)
00:09:11 * pumpkin is punishing gmp's integers
00:09:47 <pumpkin> and GHC's
00:10:33 <hatds> is it possible to import constructors unqualified without importing the type unqualified?
00:10:48 <dons> bos: pong.
00:12:10 <Cale> hatds: I think it might be possible using more than one import
00:12:41 <Cale> hatds: But why? Qualified imports in types usually look terrible :)
00:12:45 <kyagrd> Cale: oh when has been nubBy been broken?? that's scarey I just saw your post
00:13:00 <Cale> kyagrd: I'm pretty sure it wasn't broken in 6.8
00:13:32 <hatds> doesn't look like you can say import Mod(constructor)
00:14:03 <dmwit> hatds: Oh, does import Mod(Type(Constructor)) import both Type and Constructor?
00:14:36 <Cale> dmwit: I'm afraid it does.
00:14:50 * dmwit doesn't know any other way to import constructors
00:14:51 <pumpkin> hac phi needs some hardcore optimization projects
00:14:52 <sm> hmm, cabal-install no longer needs Setup.hs ?
00:15:00 <dmwit> pumpkin: Bring one!
00:15:01 <dmwit> =D
00:15:02 <kyagrd> Cale: In Hugs it's still right. What an odd.
00:15:13 <hatds> dmwit: yes
00:15:26 <pumpkin> dmwit: I'm tempted to, but I'm not sure which, and I don't know whether many people will want to work on stuff like that
00:15:41 <Cale> kyagrd: Someone must have messed with it, and didn't think to check that the behaviour was the same for an asymmetric relation :)
00:16:11 <Cale> kyagrd: after all, people usually expect that it'll get used with equivalence relations, but it's much more useful than that.
00:17:11 <cads> > foldl (\ (a1, a2) (b1, b2) -> (b1 + a1 * (1 - b2), a2)) (0,0)
00:17:12 <lambdabot>   Overlapping instances for GHC.Show.Show ([(t1, t1)] -> (t1, t))
00:17:12 <lambdabot>    arising ...
00:17:27 <hatds> the reason I want to qualify types is that I have a feature matrix situation, and having a module of functions that look like   f :: Backend.Type -> Frontend.Type  is clearer, but the constructor names are clear from context
00:19:23 <cads> > foldl (\ (a1, a2) (b1, b2) -> (b1 + a1 * (1 - b2), a2)) (0,0) [(1 ,1), (0.5, 1), (0.1, 1), (0.3, 3)]
00:19:24 <lambdabot>   (9.999999999999998e-2,0)
00:19:44 <cads> > foldr (\ (a1, a2) (b1, b2) -> (b1 + a1 * (1 - b2), a2)) (0,0) [(1 ,1), (0.5, 1), (0.1, 1), (0.3, 3)]
00:19:45 <lambdabot>   (9.999999999999998e-2,1.0)
00:20:27 <kyagrd> > [1..] :: Integer
00:20:28 <lambdabot>   Couldn't match expected type `GHC.Integer.Internals.Integer'
00:20:36 <kyagrd> > [1..] :: [Integer]
00:20:38 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
00:20:52 <kyagrd> > [1,-1..] :: [Integer]
00:20:53 <lambdabot>   [1,-1,-3,-5,-7,-9,-11,-13,-15,-17,-19,-21,-23,-25,-27,-29,-31,-33,-35,-37,-...
00:21:28 <pumpkin> , length . show $ 123456789 ^ 54321
00:21:31 <lunabot>  439540
00:21:41 <kyagrd> > filter (0>) [1,-1..] :: [Integer]
00:21:42 <lambdabot>   [-1,-3,-5,-7,-9,-11,-13,-15,-17,-19,-21,-23,-25,-27,-29,-31,-33,-35,-37,-39...
00:21:43 <pumpkin> mmorrow: what machine does lunabot run on?
00:21:52 <kyagrd> > filter (<0) [1,-1..] :: [Integer]
00:21:53 <lambdabot>   [-1,-3,-5,-7,-9,-11,-13,-15,-17,-19,-21,-23,-25,-27,-29,-31,-33,-35,-37,-39...
00:22:01 <kyagrd> > filter (>0) [1,-1..] :: [Integer]
00:22:06 <lambdabot>   mueval-core: Prelude.read: no parse
00:22:06 <lambdabot>  mueval: ExitFailure 1
00:22:15 <mmorrow> pumpkin: what do you mean by what machine? (the arch or the url/location?)
00:22:24 <pumpkin> mmorrow: I mean, what is its POWA
00:22:30 <pumpkin> that was a pretty fast response
00:22:35 <mmorrow> heh
00:22:37 <kyagrd> > :t forkIO
00:22:38 <lambdabot>   <no location info>: parse error on input `:'
00:22:41 <mmorrow> um, i'll check
00:22:44 <kyagrd> > @type forkIO
00:22:45 <lambdabot>   <no location info>: parse error on input `@'
00:22:48 <pumpkin> not important, was just curious :P
00:22:52 <kyagrd> @type forkIO
00:22:53 <lambdabot> Not in scope: `forkIO'
00:23:01 <kyagrd> @type Control.Concurrent.forkIO
00:23:03 <lambdabot> IO () -> IO GHC.Conc.ThreadId
00:23:05 <mmorrow> pumpkin: it has 8 cores, not sure about mem off the top of my head
00:23:10 <pumpkin> ah ok
00:23:16 <mmorrow> pumpkin: (it's a hosted box though, so in a vm surely)
00:23:21 <pumpkin> ah
00:23:54 <kyagrd> > print "hello, world"
00:23:55 <lambdabot>   <IO ()>
00:24:08 <cads> hey you guys, is it possible to find g and  a such that   foldr g a = foldl f (0,0)    where f = (\ (a1, a2) (b1, b2) -> (b1 + a1 * (1 - b2), a2))? Here, f is neither associative nor commutative
00:24:39 <mmorrow> pumpkin: hehe,
00:24:46 <mmorrow> Mem:          8192       1109       7082          0          0          0
00:24:51 <pumpkin> nice :)
00:24:58 <mmorrow> can that be right? (it's a Xeon, can they have > 4GB??)
00:25:15 <pumpkin> yeah, my mac pro's xeon supports way more mem than that
00:25:17 <cads> and if that is impossible, would it be possible to find h, g, and a such that  h (fold g a v) = fold f (0,0) v
00:25:19 <pumpkin> depends on the xeon though
00:25:26 <mmorrow> , maxBound :: Int
00:25:27 <lunabot>  2147483647
00:25:34 <pumpkin> oh, you're on a 32-bit OS?
00:25:34 <mmorrow> , maxBound :: Word
00:25:36 <lunabot>  4294967295
00:25:38 <mmorrow> yeah
00:25:43 <MyCatVerbs> > maxBound :: Word
00:25:43 <kyagrd> @type System.IO.Unsafe.unsafePerformIO
00:25:43 <mmorrow> which is why i'm confused
00:25:44 <lambdabot>   18446744073709551615
00:25:44 <lambdabot> forall a. IO a -> a
00:25:44 <pumpkin> must be using PAE then
00:25:50 <mmorrow> hmm
00:25:58 <kyagrd> @type unsafePerformIO
00:25:59 <lambdabot> Not in scope: `unsafePerformIO'
00:26:00 <pumpkin> it's a linux?
00:26:04 <mmorrow> pumpkin: http://hpaste.org/cpu.txt
00:26:09 <mmorrow> pumpkin: yeah, centos
00:26:23 <kyagrd> > System.IO.Unsafe.unsafePerformIO (print "hello world")
00:26:24 <lambdabot>   Not in scope: `System.IO.Unsafe.unsafePerformIO'
00:26:25 <MyCatVerbs> Technically there's nothing stopping you from building a machine where sizeof(int)==4 and sizeof(void*)==8. It's entirely allowed by the C standard.
00:26:40 <pumpkin> sizeof(int) is usually 4 isn't it? even on 64-bit machines?
00:26:44 <pumpkin> it's long that changes, I thought
00:26:47 <mmorrow> yeah
00:27:09 <kyagrd> Alas, I can do unsafePerformIO with lambdabot :)
00:27:11 <pumpkin> but yeah, the worst bit of c, I think, is the ****ing numeric types
00:27:15 <kyagrd> Alas, I can't do unsafePerformIO with lambdabot :)
00:27:19 <Twey> kyagrd: Oh?
00:27:20 <Twey> Oh
00:27:21 <Twey> Haha
00:27:22 <mmorrow> pumpkin: ah, did you see my comment on running initialization code?
00:27:27 <Twey> That's less interesting :-P
00:27:36 <pumpkin> mmorrow: yeah, but my damn client cut it off... what was the URL for the code?
00:27:40 <mmorrow> pumpkin: (you'd need to mess with ghc's codegen ;), but ,,)
00:27:46 <mmorrow> pumpkin: one sec
00:27:52 <MyCatVerbs> pumpkin: nnnn... no, I think it's usually set at 8 too anyway.
00:28:04 <pumpkin> MyCatVerbs: not on my machine, but as you said the standard allows it :)
00:28:05 <mmorrow> pumpkin: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2568
00:28:25 <pumpkin> mmorrow: well, I'm pulling GMP out of GHC and wanted to set GMP's allocation functions without having to check a "runonce" thingy with every function call
00:28:27 <MyCatVerbs> pumpkin: AFAIK people set sizeof(int)==sizeof(void*) just because so much faulty-ass C code assumes that. :/
00:28:42 <mmorrow> pumpkin: so it looks like the first jump into a module sets off a chain of jumps that recursively init all its dep modules
00:28:45 <pumpkin> mmorrow: interesting
00:29:06 <mmorrow> pumpkin: so all you'd need to do is add a single call in there to your init code
00:29:13 <pumpkin> I could be sneaky and set up an ffi export that does that, but then I'd need to find a way to rename the default one
00:29:26 <pumpkin> and jump into it
00:29:28 <kyagrd> > head (filter (<0) [1,..]) :: Integer
00:29:29 <lambdabot>   <no location info>: parse error on input `..'
00:29:38 <kyagrd> > head (filter (<0) [1..]) :: Integer
00:29:42 <lambdabot>   mueval-core: Prelude.read: no parse
00:29:43 <lambdabot>  mueval: ExitFailure 1
00:29:49 <pumpkin> gmp is pretty fast!
00:29:52 <mmorrow> yeah, i was trying to think of a way to do it without needing to tweak ghc's asm output, but i came up with no ideas
00:30:03 <mmorrow> pumpkin: yeah, lightning
00:30:15 <pumpkin> I'm coming to appreciate it as I'm nearing half an hour on integer-simple for that calculation I just gave lunabot
00:30:25 <mmorrow> hehh
00:31:57 <pumpkin> mmorrow: I guess since I'm playing with GHC, I could add in some sort of facility to have a "call me on startup" function
00:32:03 <kyagrd> > nubBy (<) [1,2]
00:32:04 <lambdabot>   [1,2]
00:32:19 <pumpkin> mmorrow: and maybe a "on shutdown do this" function too
00:32:21 <mmorrow> pumpkin: totally, that could be interesting
00:32:32 <pumpkin> since many libraries need initialization
00:33:06 <mmorrow> pumpkin: just be careful how you phrase what you're doing ;) on account of the "top-level <-" uproar :)
00:33:17 <pumpkin> lol, I haven't heard of that
00:33:38 <pumpkin> people don't like the idea?
00:33:50 <mmorrow> i'm trying to find the haskell-cafe thread for you now..
00:33:58 <pumpkin> it seems like it should be possible as part of the FFI interface as that's the only kind of case in which it's useful
00:34:13 <pumpkin> as it's rare for haskell libraries to have global state
00:35:03 <mmorrow> pumpkin: heh, i think it started in this month http://www.haskell.org/pipermail/haskell-cafe/2008-August/
00:35:13 <kyagrd> > read "1e10" :: Integer
00:35:14 <lambdabot>   10000000000
00:35:27 <kyagrd> > read ("1e"++show 10) :: Integer
00:35:28 <lambdabot>   10000000000
00:35:31 <pumpkin> mmorrow: found it, thanks
00:35:40 <kyagrd> > read ("1e"++show(10^10)) :: Integer
00:35:45 <lambdabot>   mueval-core: Prelude.read: no parse
00:35:45 <lambdabot>  mueval: ExitFailure 1
00:35:57 <kyagrd> > read ("1e"++show(2^10)) :: Integer
00:35:59 <lambdabot>   100000000000000000000000000000000000000000000000000000000000000000000000000...
00:36:13 <pumpkin> mmorrow: can only find two mentions of it though
00:36:16 <pumpkin> http://www.haskell.org/pipermail/haskell-cafe/2008-August/046437.html
00:36:26 <pumpkin> oh, there's more further down
00:36:29 <mmorrow> heh
00:37:23 <mmorrow> pumpkin: it continues into the next month as well
00:37:26 <pumpkin> ack
00:37:31 <kyagrd> > even (read ("1e"++show(2^10)))
00:37:33 <lambdabot>   True
00:37:41 <kyagrd> > even (read ("1e"++show(3^10)))
00:37:42 <lambdabot>   True
00:37:45 <kyagrd> > even (read ("1e"++show(4^10)))
00:37:46 <lambdabot>   True
00:37:50 <kyagrd> > even (read ("1e"++show(5^10)))
00:37:53 <lambdabot>   True
00:37:58 <kyagrd> > even (read ("1e"++show(6^10)))
00:38:03 <lambdabot>   mueval-core: Prelude.read: no parse
00:38:03 <lambdabot>  mueval: ExitFailure 1
00:38:39 <Axman6> > 6^10
00:38:40 <lambdabot>   60466176
00:38:48 <Axman6> > 5^10
00:38:49 <lambdabot>   9765625
00:38:50 <pumpkin> mmorrow: what's ACIO?
00:39:38 <mmorrow> pumpkin: i don't know/recall really
00:39:48 <sm> dear lazyweb.. how would you refactor this rss2irc code ? I want to give help an explicit type signature. http://gist.github.com/124760
00:40:15 <sm> currently it seems to have two types depending on context, I'm surprised it compiles
00:41:25 <dmwit> :t exitWith
00:41:27 <lambdabot> Not in scope: `exitWith'
00:41:35 <dmwit> :t System.Environment.exitWith
00:41:36 <lambdabot> Not in scope: `System.Environment.exitWith'
00:41:57 <dmwit> Anyway, exitWith :: Something -> IO a
00:42:06 <dmwit> It never returns, so you can assign it any type you like.
00:42:18 <mmorrow> pumpkin: this looks like the (a?) first mention of it http://www.haskell.org//pipermail/haskell-cafe/2004-November/007680.html
00:42:34 <dmwit> sm: Couldn't you have just loaded that in ghci and asked for the type of help?
00:42:45 <ski> @hoogle exitWith
00:42:46 <lambdabot> System.Exit exitWith :: ExitCode -> IO a
00:42:54 <sm> sure, I can see that type
00:43:17 <sm> but you see how help is used twice ? it's a different type in each case. I can't add an explicit signature
00:43:24 <sm> why does this work ?
00:43:53 <ski>   help :: IO a
00:43:56 <ski> should work
00:44:21 <sm> aha! right you are
00:44:25 <dmwit> sm: Why can't you add an explicit signature?
00:45:04 <sm> so it has a single type, it's just not fully specified
00:45:14 <sm> neat
00:45:16 <Axman6> > return undefined
00:45:17 <lambdabot>   No instance for (GHC.Show.Show (m a))
00:45:18 <lambdabot>    arising from a use of `M8863138728...
00:45:24 <Axman6> :t return undefined
00:45:25 <lambdabot> forall a (m :: * -> *). (Monad m) => m a
00:47:07 <ski> @type System.Exit.exitWith System.Exit.ExitSuccess
00:47:09 <lambdabot> forall a. IO a
00:47:11 <pumpkin> mmorrow: I see
00:47:25 <pumpkin> mmorrow: wow, integer-simple is still chugging away at that calculation :) maybe I should've tried something smaller
00:47:41 <mmorrow> heh
00:48:07 <mmorrow> (what's the calculation? is it one where gmp would be using a fourier transform?)
00:48:16 <pumpkin> yeah
00:48:20 <pumpkin> it's what I gave lunabot before
00:48:26 <pumpkin> length . show $ 123456789^54321
00:48:26 <mmorrow> oh, i missed that
00:48:29 <mmorrow> ah
00:48:40 <sm> next question: seconds = 10 ^ 6 gives: Warning: Defaulting the following constraint(s) to type `Integer' `Integral t' arising from a use of `^' ...  and I haven't been able to silence it by adding :: Int or ::Integer . What's this all about ?
00:48:50 <pumpkin> so it should involve several very large multiplications
00:48:55 <pumpkin> which are quadratic in integer-simple
00:49:09 <dmwit> :t (^)
00:49:10 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
00:49:21 <dmwit> sm: The (6) there has unknown type.
00:49:48 <pumpkin> how many multiplications will ^54321 result in I wonder
00:49:51 <pumpkin> @src (^)
00:49:52 <lambdabot> x ^ 0            =  1
00:49:52 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
00:49:52 <lambdabot>   where f _ 0 y = y
00:49:52 <lambdabot>         f x n y = g x n
00:49:52 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
00:49:54 <lambdabot>                       | otherwise = f x (n-1) (x*y)
00:49:56 <pumpkin> should be 15 + something
00:49:56 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
00:50:08 <dmwit> > logBase 2 54321
00:50:10 <lambdabot>   15.729222418074684
00:50:23 <sm> right.. how would I get it to no warn me, by changing the code ?
00:50:29 <pumpkin> won't be just 16 though
00:50:41 <dmwit> sm: 10 ^ (6 :: Integer)?
00:51:43 <sm> right
00:51:58 <sm> hmm
00:52:14 <sm> when I just added ::Integer it applied to the whole expression ?
00:52:26 <dmwit> right
00:52:32 <Cale> sm: type annotations extend to the largest expression they can
00:53:17 <dmwit> > x ^ 54321
00:53:19 <lambdabot>   x * x * (x * x) * (x * x * (x * x)) * (x * x * (x * x) * (x * x * (x * x)))...
00:53:22 <dmwit> hmm
00:54:05 <sm> ah, I never understood that. great
00:54:33 <roderyk> I'm writing an app where it looks more and more like I should be heading slowly towards an EDSL, because I have a graphical app for tagging layers / groups with different kinds of metadata and then a set of scripts (I don't mind if these are in haskell for v 0.1) for running experiments on the data. The scripts are numerous in variety, but I think I can keep it sane by keeping them typed (accept specific input and output; chain together as necessary).
00:54:33 <roderyk> I'm leaning towards a generic method of tagging the metadata as a tree/map - Map StringKey Val, but I don't want to explicitly write out all the possibilites of Val as an algabraic data structure. Instead I would prefer a generic 'a' (but this of course won't typecheck - Map doesn't allow storing both Double and [Double] in the same instance)
00:54:58 <roderyk> any ideas on which direction I should be moving in... (maybe I'm simply trying to do too much at once :))
00:55:12 <Cale> roderyk: What *operations* are important for you?
00:55:26 <dmwit> > let count 0 = 0; count n | n > 0 = count' (n-1) where count' 0 = 0; count' n = count'' n; count'' n | even n = 1 + count'' (n `quot` 2) | otherwise = 1 + count' (n-1) in count 54321
00:55:28 <lambdabot>   21
00:55:32 <dmwit> pumpkin: 21!
00:55:34 <Cale> If you have a value and all you know is that it's of some type, there is precisely nothing you can actually do with it.
00:55:56 <pumpkin> dmwit: excellent! 21 multiplications have taken 50 minutes so far :D
00:55:57 <Cale> That is, there are no operations on values of type  (exists a. a)
00:56:27 * dmwit is sure there's a less brain-dead way to calculate that but doesn't care to waste cycles on it
00:56:32 <roderyk> lots of things  of the sort of: take (x,y,z) groups from [list]; do math/analysis operations; plot result (maybe graphical result, print to file, modify original data)
00:57:04 <Cale> So if you want to be able to store many different sorts of values, what is it that they all have in common which will make them useful once you extract them from the datastructure given that you no longer know what type they are?
00:57:55 <sm> hmm, sometimes I'd really like an ide that reliably explains any word in the code. Like "get"
00:58:11 <roderyk> Cale: well, that's my point. Each specific script knows what "interesting" thing to extract from the same data; you mark up the data once but each script uses it differently
00:58:38 <dmwit> sm: "get" is a monad action that returns the current state of a MonadState instance
00:58:44 <pumpkin> mmorrow: I'm jealous that your xeon seems to have the monitor cpuid bit set
00:58:45 <roderyk> eg. if data is a bezier curve, one script may be interested in its curvature while another in what max/min (x,y) pixel it uses
00:58:52 <dmwit> sm: (P.S. that IDE would require an interface to #haskell ;-)
00:58:58 <sm> thanks :)
00:58:59 <pumpkin> mmorrow: that feature is the bane of my frankenmac pro
00:59:01 <sm> not a bad idea
00:59:14 <mmorrow> pumpkin: what does that do?
00:59:43 <Cale> roderyk: But what if the thing which expects to be looking at a Bezier curve gets something entirely different?
01:00:06 <sm> dmwit: course you are just as unaware of this code's namespace as emacs.. are you sure that's the get I'm looking at ?
01:00:17 <Cale> roderyk: There are a few solutions to this problem...
01:00:19 <pumpkin> mmorrow: some sort of power management thing I think... haven't really looked into it much... apparently it can be turned off and somehow it gets turned off on my CPU just in time for mac os to panic on startup when it looks for it
01:00:39 <mmorrow> pumpkin: ooh, yay
01:00:40 <Cale> roderyk: There is Data.Dynamic which is ugly and heavy-handed, but rather flexible.
01:00:41 <sm> http://joyful.com/darcsweb/darcsweb.cgi?r=rss2irc;a=headblob;f=/Main.hs line 162
01:00:57 <roderyk> Cale: well for now we can assume the stringKey is specific to datatype (and we just die/ignore serious issues)
01:01:27 <Cale> (In that you can take any Typeable type and stuff it in your Map and later extract the value as a Maybe, and if we try to extract it at the wrong type, we get Nothing
01:01:29 <Cale> )
01:01:48 <roderyk> Cale: it's more about tagging up the document will sorts of meta-data once; then running lots of separate analysis scripts on it (we assume the scripts are responsible with figuring out if the data is what it wants to use; throws error or something otherwise0
01:02:03 <dmwit> sm: No, I'm not sure; and that link doesn't link to Main.hs for me.
01:02:31 <dmwit> Actually it does, but my terminal's URL grabber bites.
01:02:38 <dmwit> so scratch that
01:02:44 <sm> not to worry. I see it's defined 10 lines below :-) Still, I'm interested in tools
01:02:50 <jeffwheelerPhone> sm: the definition is just a few lines lower, no?
01:03:05 <jeffwheelerPhone> Ah, nevermind me.
01:03:09 <sm> thx
01:03:12 <dmwit> Right, tools would be nice.
01:03:24 <sm> leksah would know, wouldn't it ?
01:03:28 <dmwit> Maybe.
01:04:07 <sm> still cabal uninstallable for me :/
01:04:08 <jeffwheelerPhone> If you used Hasktags with Yi, that might get you the solution.
01:04:12 <sm> what's up with that
01:04:16 * Cale wonders if lambdabot has Data.Dynamic in scope...
01:04:27 <Cale> > toDynamic 5
01:04:28 <lambdabot>   Not in scope: `toDynamic'
01:04:40 <Cale> > toDyn 5
01:04:41 <lambdabot>   <<Integer>>
01:04:44 <Cale> aha, good
01:04:45 <sm> jeffwheelerPhone: not hasktags with emacs ?
01:04:58 <Cale> > [toDyn 5, toDyn "hello", toDyn [1,2,3]]
01:04:59 <lambdabot>   [<<Integer>>,<<[Char]>>,<<[Integer]>>]
01:05:18 <Cale> > map fromDynamic [toDyn 5, toDyn "hello", toDyn [1,2,3]] :: [Maybe Integer]
01:05:19 <lambdabot>   [Just 5,Nothing,Nothing]
01:05:21 <kyagrd> @type toDyn
01:05:21 <lambdabot> forall a. (Typeable a) => a -> Dynamic
01:05:23 <Cale> > map fromDynamic [toDyn 5, toDyn "hello", toDyn [1,2,3]] :: [Maybe String]
01:05:24 <lambdabot>   [Nothing,Just "hello",Nothing]
01:05:26 <sm> never mind, ignore me.. I do use hasktags and know it works for local code
01:05:29 <jeffwheelerPhone> sm: I suppose that'd probably work just as well.
01:05:36 <Cale> > map fromDynamic [toDyn 5, toDyn "hello", toDyn [1,2,3]] :: [Maybe [Integer]]
01:05:37 <lambdabot>   [Nothing,Nothing,Just [1,2,3]]
01:06:02 <jeffwheelerPhone> Sorry, I'm oblivously very slow at typing on my phone. ;)
01:06:04 <sm> and M-x haskell-hoogle works for things hoogle knows about
01:06:10 <sm> heh
01:06:18 <jeffwheelerPhone> * obviously
01:06:18 <kyagrd> If you want more static type hacking you can also use HList
01:06:28 <roderyk> Cale: will look at Data.Typeable, Dynamic, and Generic.... maybe it's time to finally get around to reading syb as well, eh?
01:06:36 <Cale> kyagrd: Well, in this case we need a multi-typed Map
01:07:09 <roderyk> Cale: thanks for the input, will skim the apis and see if it sounds like the best approach for a prototype :)
01:07:09 <Cale> roderyk: Generic is... probably not relevant to this specific thing, though the problem vaguely sounds like it might be useful
01:07:19 <Cale> roderyk: Another solution is completely different
01:07:24 <roderyk> Cale: yes?
01:07:35 <jeffwheelerPhone> sm: On the bright side, those issues should be over in about 5 hours.
01:08:02 <Cale> roderyk: It's essentially the OO-solution. Decide the operations you want to have on this metadata, and fix that up front. Rather than storing values of different types, store records consisting of the operations.
01:08:14 <sm> oh goody, which issues ?
01:08:51 <Cale> and use the fact that functions capture the values (of any type!) of variables which occur in their definitions.
01:09:18 <jeffwheelerPhone> sm: phone typing, via the Pre
01:09:54 <roderyk> Cale: that might be difficult; I'll think about it, but that's how I've been doing it and I keep hitting the wall that essentially the number of kinds of meta-data are smaller than the possible operations (which will grow at much faster rate than the data)
01:10:08 <sm> Pre ?
01:10:17 <Cale> roderyk: okay, then that sounds like the algebraic type way is better
01:10:21 <sm> new toys from apple ?
01:11:38 <Cale> roderyk: Remember that every function which includes a fall-through case for data which is tagged with the wrong data constructor will not necessarily have to be updated if you add a case to the datatype
01:11:52 <Gracenotes> :#
01:12:39 <Cale> another possibility is just constructing multiple Maps, one for each type of meta-data you're collecting
01:13:25 <Cale> (possibly all collected together into one record which you thread through the algorithm which is meant to collect it)
01:14:10 <roderyk> Cale: right, I'm going to see if I can map out all the possibilities over a cup of tea. Thanks for the insights :)
01:15:04 <Cale> roderyk: It's a rare case where you really don't know all the possible types for the program you're writing.
01:15:22 <Cale> It happens with libraries, but not so much for applications.
01:16:13 <roderyk> Cale: I think the issue stems from the variable combination of primitives available. Given a small set of primitives, each actual operation may require a different tuple/list of them
01:16:26 <roderyk> this is why started converting it multiple maps
01:17:32 <roderyk> so I started adding group primitives like 'GroupList :: [Primitive], GroupTuple (Primitive, Primitive)', etc
01:18:21 <roderyk> so I figured it might be easier to just provide a generic Map key val, and have each operation figure out if it has all necessary data to continue
01:19:36 <ziman> what's the preferred way to work with a mysql database from haskell (which lib to use)?
01:19:46 <hatds> even when you "know" the types for your program, you don't really know until it's actually done.  There are many isomorphic and nearly isomorphic ways of nesting types, and there are decisions to be made on whether two related types should be wholly separate or alternatives of a unified type
01:20:32 <mux> mmm, a type-safe printf via TH - Oleg strikes again
01:39:41 <pltonik> hello all. could someone explain to me how 'flip id' works? both from a technical and conceptual level? i must be missing something obvious but 'flip id' makes no sense to me nor do i understand what it does. i found it's use in the System.Console.GetOpt second example
01:40:00 <dmwit> id :: (a -> b) -> (a -> b)
01:40:03 <mauke> pltonik: every function takes exactly one argument
01:40:03 <pltonik> i know what the individual functions do
01:40:10 <dmwit> flip id :: a -> (a -> b) -> b
01:40:30 <pltonik> yup and thats where i get stuck
01:40:49 <dmwit> So flip id takes an argument and a function, then applies that function to the argument.
01:41:04 <dmwit> flip id argument f = id f argument = f argument
01:42:19 <Cale> It might help to realise that (a -> b) -> (a -> b) is the same as (a -> b) -> a -> b
01:42:26 <pltonik> why does 'flip id arg f = id f arg'? flip requires a function which takes two arguments but here you are passing a function which takes one argument plus f
01:42:27 <Cale> since -> associates to the right
01:42:42 <Cale> > id reverse "hello"
01:42:42 <lambdabot>   "olleh"
01:42:53 <mauke> pltonik: every function takes exactly one argument
01:43:01 <mauke> pltonik: there are no functions with two arguments
01:43:07 <Cale> pltonik: As you can see, you can think of id as a two parameter function which takes a function and an argument and applies the function to that argument.
01:43:07 <Twey> (((flip id) argument) f) = ((id f) argument) = (f argument)
01:43:20 <dmwit> pltonik: flip takes a function of one argument that returns another function.
01:43:26 <Cale> flip ($) would have been clearer though
01:43:37 <dmwit> pltonik: id can play the role of a function that takes one argument and returns another function, provided that argument is itself a function.
01:43:43 <pltonik> mauke: indeed, but i still have trouble looking at it that way or to put it in other words it doesnt make it any clearer for me.
01:43:48 <dmwit> pltonik: So id can be a valid argument to flip. =)
01:44:11 <Cale> pltonik: I think the two-parameter way is easier to think about in this cas
01:44:14 <Cale> case*
01:44:20 <Cale> id f x = f x
01:44:36 <Cale> and flip g x y = g y x
01:45:00 <pltonik> oh man, i need to digest this. give me a sec guys, but thanks for the input thusfar :).
01:45:09 <Twey> Hehe
01:45:10 <Cale> so flip id x f = id f x = f x
01:45:18 <Twey> Hooray for the brain-bendingness of n-ary functions
01:45:59 <FunctorSalad> I wonder why they're less intuitive to us than tuples
01:46:25 <Twey> ‘flip id f x’ can also be written as ‘($ x) f’
01:46:33 <Twey> FunctorSalad: Speak for yourself
01:46:48 <dmwit> FunctorSalad: Tuples aren't usually n-ary.  Perhaps you should ask why they're less intuitive than lists.
01:46:48 <Twey> It took me ages to puzzle out the point of tuples when I first encountered them
01:46:59 <mauke> dmwit: what
01:47:10 <pltonik> ohhhhhh there it is, the proverbial lightbulb
01:47:35 * dmwit pauses to consider whether what he just said really makes sense
01:47:45 <pltonik> lol no no it does
01:47:53 <FunctorSalad> dmwit: I meant as args... so lists would correspond to variadics functions
01:48:02 <pltonik> it was staring at me the whole time, but yea, went right over my head
01:48:26 * mauke stares at pltonik the whole time
01:48:32 <ray> dmwit: i don't think it makes sense
01:48:41 <ray> :)
01:48:52 <dmwit> Yeah, I guess not.
01:49:05 <ray> better luck next time
01:49:14 <FunctorSalad> Twey: really? ;)
01:49:41 <FunctorSalad> granted, the point in haskell maybe
01:49:42 <pltonik> mauke: umm are you implying that you're over my head? ...how'd u get there?
01:50:02 <mauke> WEEED
01:50:32 <Twey> Hahahaha
01:50:33 <pltonik> come down... lol
01:51:58 <sm> success.. rss2irc now supports atom feeds
02:14:51 <pltonik> grr i'm doing my head in again looking at this flip id thing... i get it using Cale's two-parameter approach but looking at the type signitures puts me in an endless cycle - and the more i stir the muddier it gets
02:18:45 <pltonik> dmwit: when you say flip takes a function of one argument and returns another function do you mean: flip :: (a->b)->(c->b->a->c)?
02:18:51 <ray> :t flip
02:18:52 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
02:19:05 <mauke> flip :: (a -> b -> c) -> (b -> a -> c)
02:19:24 <pltonik> mauke: but then it takes a function of two arguments not one?
02:19:26 <dmwit> pltonik: What I actually said was that flip takes a function of one argument that returns another function.
02:19:27 <mauke> > let other_function = flip (-) in other_function 3 5
02:19:28 <lambdabot>   2
02:19:42 <mauke> flip :: (a -> (b -> c)) -> (b -> (a -> c))
02:19:45 <dmwit> pltonik: i.e. flips first argument is a (a function that takes one argument and returns another function)
02:20:08 <pltonik> dmwit: ahhhhhh
02:20:39 <pltonik> another meal to digest...
02:29:51 <pltonik> bah, i was hoping to figure out how id fits into that type signiture for filp but i just cant. help?
02:30:05 <dmwit> pltonik: id :: a -> a
02:30:11 <dmwit> pltonik: However, "a" is a type variable.
02:30:17 <dmwit> pltonik: So you can put any type you like there.
02:30:18 <dmwit> So!
02:30:19 <dmwit> :t flip
02:30:21 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
02:30:22 <mauke> flip takes (a -> (b -> c))
02:30:33 <dmwit> pltonik: Let's rename some variables.
02:30:40 <pltonik> yes, lets lol
02:30:49 <dmwit> flip :: (b -> c -> d) -> (c -> b -> d)
02:30:50 <mauke> can't I just set a = b -> c?
02:30:54 <pltonik> im getting royally brainwashed
02:31:05 <dmwit> pltonik: Okay?
02:31:10 <pltonik> ok
02:31:29 <dmwit> pltonik: So, we need to match (a) with (b -> c -> d).
02:31:41 <pltonik> still with yo
02:31:42 <dmwit> sorry
02:31:43 <pltonik> *you
02:31:44 <dmwit> That's not right.
02:31:50 <dmwit> We need to match (a -> a) with (b -> c -> d).
02:32:00 <pltonik> yea i know what you meant
02:32:11 <dmwit> Now, we can notice that (b -> c -> d) = (b -> (c -> d)).
02:32:25 <pltonik> mkay
02:32:26 <dmwit> So (a -> a) = (b -> (c -> d)) means both (a = b) and (a = c -> d).
02:32:33 <dmwit> i.e. b = c -> d.
02:32:42 <dmwit> Substituting, we end up with
02:32:47 <dmwit> id :: (c -> d) -> (c -> d)
02:32:49 <dmwit> and
02:33:15 <dmwit> flip :: ((c -> d) -> (c -> d)) -> (c -> (c -> d) -> d)
02:34:13 <Twey> i.e. id :: (c -> d) -> c -> d, and flip :: ((c -> d) -> c -> d) -> c -> (c -> d) -> d
02:34:18 <dmwit> pltonik: And, in fact, this is exactly the algorithm the type-checker uses; it's called unification.  When you have an equation for an arrow type, you reduce it into two equations, one for each side of the arrow.
02:34:42 <dmwit> pltonik: That was the step where we went from (a -> a = b -> c -> d) to (a = b and a = c -> d).
02:36:04 <pltonik> that looks like it does simple algebra to solve for the 'unknown'
02:36:14 <dmwit> Pretty much, yup!
02:36:20 <mauke> only stupider
02:36:23 <pltonik> lol
02:36:38 <pltonik> at the moment i'd say only im stupider
02:37:09 <mauke> we've all been there
02:37:51 <hackagebot> geniconvert 0.17.1
02:39:13 <mauke> 'flip id' is the concentrated essence of currying/polymorphism
02:39:36 <Twey> Hehe
02:39:40 <ivanm> mauke: concentrated into only 7 chars!
02:39:42 <ivanm> ;-)
02:39:52 <pltonik> yea i hate being a newbie again. back where i'm from - 'imperative land' - i was king in my little town. here - 'functional land' - i just dont know who i am anymore lol.
02:39:56 <mauke> I'd say once you really get it, you've mastered currying
02:39:58 <Twey> Slash Haskell's specific approach to function application :-P
02:40:06 <pltonik> mauke: it sure is concentrated!
02:40:46 <mauke> more concentrated awesome/brain damage: fmap fix return
02:41:18 <ivanm> Twey: "Slash Haskell"?
02:41:24 <ivanm> what is it slashed with?
02:41:36 <ivanm> mauke: that's less concentrated, is it not?
02:41:42 <Twey> Common Lisp.  It's a very hot fanfic.
02:42:02 <ivanm> ahhh
02:42:15 <dmwit> :t fix const
02:42:16 <lambdabot>     Occurs check: cannot construct the infinite type: a = b -> a
02:42:16 <lambdabot>     Probable cause: `const' is applied to too few arguments
02:42:16 <lambdabot>     In the first argument of `fix', namely `const'
02:42:23 <dmwit> :t fix . const
02:42:24 <lambdabot> forall a. a -> a
02:42:25 <mauke> this one requires type classes (constructor classes at that), the Y combinator, functors, monads, the ((->) e) instance, currying (+ at the type level, see previous point)
02:42:28 <dmwit> uh huh
02:42:44 <Twey> mauke: Bloody hell.
02:42:54 <Twey> That's beyond me.
02:42:57 <Twey> :(
02:43:01 <mauke> doh ho ho
02:43:05 <dmwit> Twey: You can get it.  It's a fun puzzle. =)
02:43:18 <dmwit> Twey: When you figure it out the first time, you'll be delighted.
02:43:19 <pltonik> dmwit: there still seems to be a step missing after getting to that final signiture for flip and id - to me at least. i mean what the hell does that signiture imply?
02:43:24 <dmwit> After that it's just disgust. ;-)
02:43:28 <mauke> @quote fmap.fix.return
02:43:28 <lambdabot> mauke says: fmap fix return is the e^(i*pi)+1 of haskell
02:43:32 <ivanm> AFAICT, it does nothing.... maybe I'm not using fancy enough examples?
02:43:40 <dmwit> ivanm: exactly right
02:43:56 <ivanm> dmwit: identity monad?
02:43:57 <pltonik> dmwit: besides, how do you go from that signiture to the simplicity of 'flip id x f = f x'?
02:44:00 <dmwit> pltonik: "imply"?
02:44:09 <dmwit> ivanm: No, ((->) e) monad (surprise!).
02:44:17 <dmwit> ivanm: It ends up being the identity function, though.
02:44:23 <ivanm> dmwit: duh
02:44:43 <dmwit> pltonik: Oh, the signature is not how you get that equation.
02:44:51 <dmwit> pltonik: You get that equation from the definition of flip.
02:44:53 <dmwit> ?src flip
02:44:53 <lambdabot> flip f x y = f y x
02:45:14 <mauke> flip id x y == id y x == y x
02:45:18 <dmwit> flip id x f = id f x = (id f) x = f x
02:45:46 <ivanm> heh
02:45:49 <ivanm> @quote stereo
02:45:49 <lambdabot> omnId says: geez, how many metastereo quotes are going to be @remembered?  >_>
02:46:04 <Gracenotes> @quote metastereo
02:46:04 <lambdabot> omnId says: geez, how many metastereo quotes are going to be @remembered?  >_>
02:46:09 <Gracenotes> apparently, 1?
02:46:26 <Gracenotes> anyway. glorious stereo.
02:46:33 <pltonik> hmm maybe i dont know what im asking for here. i was hoping to trace the signiture along with the function currying etc. to see ...mmm something lol. god, this is not the best thing to do right before sleep.
02:46:33 <EvilTerran> @quote fugue
02:46:33 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
02:46:42 <ivanm> EvilTerran: lol
02:47:06 <Gracenotes> better
02:47:09 <EvilTerran> in this case, the question being "geez, how many metastereo quotes are going to be @remembered?"
02:47:10 <EvilTerran> :D
02:47:20 <mauke> @djinn flip :: ((c -> d) -> c -> d) -> c -> (c -> d) -> d
02:47:20 <lambdabot> Cannot parse command
02:47:23 <mauke> @djinn ((c -> d) -> c -> d) -> c -> (c -> d) -> d
02:47:23 <lambdabot> f a b c = a c b
02:47:37 <pltonik> i'll keep my questions to myself untill they make sense lol
02:47:49 <mauke> so you can recover the definition from the type
02:48:23 <pltonik> oh there we go i think thats what i was after.
02:48:50 <dmwit> pltonik: Ask mauke how to come up with those definitions. ;-)
02:49:04 <mauke> I'm an experienced perl programmer.
02:49:10 <pltonik> mauke: how to come up with those definitions. (smily face) lol
02:49:30 <dmwit> That's a real rabbit-hole, that one is.  Full of parametric polymorphism, logical relations, and some very beautiful mathematics.
02:49:41 <dmwit> Or maybe I'm thinking of ?free.
02:49:53 <dmwit> Both are harder than they seem like they should be, anyway. =)
02:50:18 <mauke> wait, do you mean what @djinn just did?
02:50:46 <dmwit> Yeah, it's proof search, isn't it?
02:51:34 <dmwit> With some heuristics about what are "good" proofs.
02:51:56 <EvilTerran> curry-howard correspondence!
02:52:39 <pltonik> mauke: ok i don't see which parts of that signiture 'map' to which f a b or c... in the words of an annoying red head "please explain?"
02:53:09 <mauke> how about we write this function uncurried
02:53:20 <mauke> flip' :: ((c -> d, c) -> d, c, c -> d) -> d
02:53:39 <mauke> hrml, that makes more sense in my head
02:53:55 <dmwit> Oh, this should be fun.
02:54:03 <pltonik> lol, silence you!
02:54:09 <EvilTerran> pltonik, there, @djinn invented an 'f' such that it had the given type
02:54:14 <dmwit> You're going to explain flip id using uncurry ($)?
02:54:22 <dmwit> That sounds like a losing proposition. =P
02:54:53 <mauke> anyway, flip' takes a 3-tuple consisting of: some function, a 'c', and a function from 'c' to 'd'
02:54:56 <mauke> it also returns a 'd'
02:54:59 * EvilTerran finds flip id pretty straightforward
02:55:25 <mauke> that first function argument is another function. it takes a function from 'c' to 'd' and a 'c', and returns a 'd'
02:56:03 <pltonik> ahh its getting closer to finish now
02:56:14 <mauke> we can easily write code of that type: simply call that first function, passing it our 3rd and 2nd argument
02:56:38 <mauke> because c = c and c -> d = c -> d
02:56:44 <Gracenotes> "flip id" *is* the same as "flip ($)" after all
02:56:55 <mauke> flip' (a, b, c) = a (c, b)
02:57:13 <mauke> the real flip works the same way, but instead of using tuples for parameter lists, it's all curried
02:57:41 <mauke> I still read a -> b -> c -> d as "a function taking a,b,c and returning d"
02:58:26 <EvilTerran> but it helps to also be able to read it as, say, "a function taking a, and returning a function taking b, and returning a function taking c, and returning d". or whatever.
02:59:25 <mauke> you simply have to know that 'a -> b -> c -> d' is the same as 'a -> (b -> c -> d)' or 'a -> (b -> (c -> d))'
02:59:56 <mauke> map is a good example, actually
02:59:57 <Gracenotes> EvilTerran: but, there are so many simpler ways of saying it
03:00:06 <mauke> map :: (a -> b) -> [a] -> [b]
03:00:07 <Twey> I read it as ‘a function from a to be to c to d’
03:00:19 <Twey> Which I think captures the essence nicely
03:00:23 <EvilTerran> Gracenotes, yeah, it just can help to expend it out mentally as an intermediate step when thinking about partial application
03:00:32 <mauke> you can read that as "map takes a function from a to b and a list of a's, and returns a list of b's"
03:00:44 <EvilTerran> map :: (a -> b) -> ([a] -> [b])
03:01:06 <mauke> but it's equally valid to think of it as "map takes a function from a to b, and returns a function from a list of a's to a list of b's"
03:01:22 <pltonik> mauke: they how i usually read things but flip id escape(d/s) me somehow
03:01:25 <mauke> so it becomes a function transformer/lifter
03:01:35 <luqui> i like to phrase my functions as transformations of functions whenever it makes sense
03:01:46 <luqui> i.e. i prefer the latter interpretation, though I flip back and forth when i'm working
03:02:05 <mauke> flip id is special because id looks like it only takes one argument
03:02:13 <pltonik> it suuuuuuure does
03:02:22 <mauke> but every function does that
03:02:39 <mauke> a two-arg function is really just a function (of 1 arg) that returns another function
03:02:46 <mauke> and that's all 'flip' requires
03:03:05 <mauke> so... if the input to 'id' is a function, then so is its output
03:03:18 <mauke> and in that case, 'id' becomes a two-arg function
03:03:21 <EvilTerran> the same function!
03:03:21 <pltonik> ((c -> d) -> c -> d) -> c -> (c -> d) -> d makes sense now, forgot that the final -> d is the output of the function lol. yea... its that bad at the moment.
03:03:45 <Gracenotes> as I said, it's the same as "flip ($)". $ is specific in that it applies to function application, but it's also function identity. (c -> d) -> c -> d
03:03:46 <Twey> IOW, when the last argument to a function is polymorphic, you should imagine a trail of potential arguments stretching off into the distance :-P
03:04:03 <mauke> Twey: no, the result
03:04:10 <Twey> Er, last argument to a function... you know what I mean :-P
03:04:12 <Gracenotes> so flip id, or flip ($), is flipped function application
03:04:15 <Gracenotes> sorta
03:04:18 <Twey> Last type in amongst the arrows.
03:04:37 <mauke> yes, that's the result type :-)
03:04:53 <pltonik> see flip ($) poses absolutely no problems for me
03:05:05 <mauke> ($) :: (a -> b) -> (a -> b)
03:05:06 <mauke> ($) = id
03:05:06 <Twey> mauke: Except it may not be a ‘result’ per se, since it can take more arguments
03:05:19 <mauke> Twey: yes, that's what functions do :-)
03:05:27 <mauke> there's a horrible application of this: see printf
03:05:37 <Twey> That's why dividing the arrows up into ‘arg1 -> arg2 -> arg3 -> result’ is confusing
03:05:56 <mauke> ... where result = x -> y -> z
03:06:05 <pltonik> Twey: so whats the better way? i might've missed it if you already said it
03:06:16 <mauke> > ""++ printf "foo"
03:06:17 <lambdabot>   "foo"
03:06:19 <mauke> > ""++ printf "foo %s" "bar"
03:06:20 <lambdabot>   "foo bar"
03:06:23 <mauke> > ""++ printf "foo %s %d" "bar" 42
03:06:25 <lambdabot>   "foo bar 42"
03:07:14 <Twey> pltonik: Like I said, it's better to imagine a final polymorphic type as being a long chain of potential arguments
03:07:37 <dmwit> Hey guys, check out this bug in GHC's floating point:
03:07:42 <dmwit> > exp pi - pi -- 20
03:07:43 <lambdabot>   19.999099979189474
03:07:45 <Twey> As in, recognising that in ‘a -> b’, b may not necessarily be a single value
03:07:45 <dmwit> haha!
03:07:48 * dmwit loves xkcd
03:08:01 <Gracenotes> dmwit: an odd value for sure :3
03:08:05 <Twey> Hehe, dmwit
03:08:51 <Gracenotes> > drop 750 $ showCReal 1000 pi
03:08:52 <lambdabot>   "60518707211349999998372978049951059731732816096318595024459455346908302642...
03:09:07 <Axman6> > exp pi - pi :: CReal
03:09:09 <lambdabot>   19.9990999791894757672664429846690444960689
03:09:30 <Twey> > exp pi - pi :: Float
03:09:31 <lambdabot>   19.999104
03:09:33 <Twey> Huh.
03:09:37 <dmwit> gah
03:09:39 <Gracenotes> aka the http://en.wikipedia.org/wiki/Feynman_point in pi
03:09:47 <Twey> Is CReal the longest we've got?
03:09:48 <Gracenotes> as seem above, at the 762nd position
03:10:01 <Gracenotes> *seen
03:10:05 <dmwit> Gracenotes: hehe, another favorite math joke of mine
03:11:46 <pltonik> Twey: i get what you're saying there. don't quite get how to apply it in real life though or to the current filp id example. maybe i should sleep on it lol.
03:11:48 <dmwit> > drop 763 $ showCReal 1000 pi
03:11:50 <lambdabot>   "99999983729780499510597317328160963185950244594553469083026425223082533446...
03:12:17 <Twey> @oeis [5, 44, 762, 762, 762, 762, 1722776, 36356642, 564665206]
03:12:18 <lambdabot>  Sequence not found.
03:14:12 <Axman6> @oeis 5 44 662 762
03:14:13 <lambdabot>  Sequence not found.
03:14:21 <Axman6> @oeis 5 44 762
03:14:22 <lambdabot>  a(n) is the starting position of the first occurrence of a string of n 9's i...
03:14:22 <lambdabot>  [5,44,762,762,762,762,1722776,36356642,564665206]
03:15:34 <Gracenotes> huh. :/
03:15:48 <Gracenotes> and all because we have 10 fingers
03:15:56 <Twey> Hehe, truly
03:16:12 <dmwit> So, according to Wikipedia, it's quite surprising that 6 copies of any digit appears that early.
03:16:12 <Twey> I wonder how that comes out if pi is written in base e...
03:16:31 <dmwit> Twey: What are the digits in base e?
03:16:45 <Twey> I haven't the foggiest
03:16:49 <ray> 0, 1, 2, and e :)
03:16:59 <mauke> preflex: calc '3 pi
03:16:59 <preflex>  10.010211012222010211002111110221
03:16:59 <dmwit> Nonsense, 10 isn't a digit.
03:17:06 <Twey> Quite
03:17:23 <ray> non-integer bases are already nonsense
03:17:27 <ray> what are you complaining about
03:17:30 <Twey> Hehe
03:17:30 <dmwit> heh
03:17:46 <dmwit> The digits are 0 and e/2. =)
03:17:59 <mauke> preflex: calc '9 pi
03:17:59 <preflex>  3.124188124074428
03:18:00 <Gracenotes> I suppose it's d_1 * e^1 + d_0 * e^0 + d_-1 * e^-1  + d_-2 * e^-2 + ...
03:18:10 <ray> presumably
03:18:12 <Gracenotes> and we would notate it like d_1 d_0 . d_-1 d_-2
03:18:18 <Gracenotes> like any other number system :/
03:18:31 <dmwit> Gracenotes: Sure, but what are the values we can use for d_1?
03:18:35 <mauke> preflex: calc '11 pi
03:18:35 <preflex>  3.16150702865a48
03:18:43 <mauke> doesn't look familiar
03:19:00 <Gracenotes> well, there is a base phi number system: http://en.wikipedia.org/wiki/Base_phi
03:19:15 <Gracenotes> except I think it depends on certain properties of phi that transcendentals may or may not have. don't recall.
03:19:52 <dmwit> Ah, I see.
03:20:06 <dmwit> You use the integer digits up to the base, then exclude certain sequences of them.
03:20:12 <dmwit> That seems... a little arbitrary.
03:20:13 <Axman6> preflex: calc '16 pi
03:20:14 <preflex>  3.243f6a8885a3
03:20:29 <Gracenotes> a number's representation in base e might be computable, but I'm not sure if said computation will terminate...
03:20:33 <Axman6> preflex: calc '2 pi
03:20:34 <preflex>  11.001001000011111101101010100010001000010110100011
03:20:38 <Axman6> preflex: calc '1 pi
03:20:39 <preflex>  Invalid number base
03:20:41 <Axman6> >_>
03:20:47 <Axman6> preflex: calc '1.5 pi
03:20:47 <preflex>  Too many operands
03:21:11 <dmwit> preflex: calc 3.6a2
03:21:11 <preflex>  Lexical error
03:21:16 <dmwit> booo
03:21:19 <mauke> preflex: calc '2.5
03:21:19 <preflex>  0.1
03:21:22 <Axman6> preflex: calc '64 pi
03:21:23 <preflex>  Invalid number base
03:21:26 <Axman6> :\
03:21:29 <Axman6> preflex: calc '20 pi
03:21:30 <preflex>  3.2gceg9gbhj9
03:21:33 <Axman6> preflex: calc '30 pi
03:21:34 <preflex>  3.47d01ee07r
03:21:35 <dmwit> preflex: calc '16 3.6a2
03:21:36 <preflex>  Lexical error
03:21:36 <Axman6> preflex: calc '40 pi
03:21:37 <preflex>  Invalid number base
03:21:42 <Axman6> preflex: calc '32 pi
03:21:42 <preflex>  3.4gvml245k
03:21:44 <dmwit> Axman6: up to 36, most likely
03:21:45 <Axman6> preflex: calc '33 pi
03:21:45 <preflex>  3.4m6dn4ow9
03:21:51 <Axman6> preflex: calc '37 pi
03:21:51 <preflex>  Invalid number base
03:21:54 <dmwit> Axman6: (i.e. 0-9a-z)
03:21:55 <Axman6> preflex: calc '36 pi
03:21:55 <preflex>  3.53i5ab8p5
03:22:02 <Axman6> ah, right, makes sense
03:22:14 <mauke> preflex: calc 16'3.6a2
03:22:14 <preflex>  3.41455078125
03:22:16 <Axman6> sorry for the spam btw
03:22:31 <voker57_> (+4) works fine, but with (-4) it thinks that i meant negative number, how to work around?
03:22:41 <mauke> voker57_: (subtract 4)
03:22:52 <ivanm> is there a function I can use to see if the beginning of a String is a specified String?
03:22:58 <mauke> ivanm: isPrefixOf
03:23:03 <dmwit> Oh!
03:23:26 <dmwit> 3.6a2 isn't something comparable to 3.6e2 from Haskell (i.e. exponential notation), it's just plain old hex digits.
03:23:29 * dmwit feels silly
03:23:29 <ivanm> mauke: I knew there was something like that, couldn't think of it
03:23:31 <ivanm> thanks!
03:23:46 <ivanm> @hoogle let me down :(
03:23:46 <lambdabot> Parse error:
03:23:46 <lambdabot>   --count=20 "let me down :("
03:23:46 <lambdabot>                          ^
03:23:50 <ivanm> @slap lambdabot
03:23:51 * lambdabot secretly deletes lambdabot's source code
03:24:15 <Axman6> oh no@!
03:24:19 <Axman6> don't do it!
03:24:21 <Gracenotes> D:
03:24:32 <Axman6> D`:
03:26:17 * Twey pulls lambdabot back from the brink
03:29:54 <ray> dmwit: the fun part is that e is a hex digit
03:30:41 <ray> welcome to fun city
03:43:33 <Sarajevo> Join to #webcam . It's a sex channel where you can meet nice ladies. Help me to make it bigger. White pussy, black pussy, yellow pussy - we are not racists. Every pussy is welcome.
03:44:44 * Twey frowns.
03:44:50 <Twey> I know that chap
03:45:27 <Twey> I've seen them around somewhere *wracks brains*
03:46:44 <ivanm> didn't he get bombed a few years back?
03:46:57 <Twey> Ha, ha :-P
03:47:02 <Twey> On IRC, you silly bear.
03:47:09 <ivanm> though I'm interested in how such a channel became created on Freenode...
03:47:11 <ivanm> Twey: :D
03:47:36 * Twey laughs.
03:47:41 <Twey> 11:47:23 [FreeNode] *** #webcam 3 18+ only, webcam shows, no kids, no pervs.
03:47:45 <Gracenotes> there are 4 people in it
03:47:52 <Gracenotes> ... now 5
03:47:58 <Twey> Hey, it's growing.
03:48:05 <Gracenotes> now 4
03:48:08 <ivanm> people believe him? :o
03:48:21 <Gracenotes> the topic is "18+ only, webcam shows, no kids, no pervs." ..
03:48:29 <Twey> I know :-D
03:48:36 <Gracenotes> oh well. Way to kickstart a channel
03:49:00 <ivanm> Gracenotes: which IIRC is against the Freenode requirements
03:49:17 <Gracenotes> hm. well, there are "legal" 18+ channels on freenode
03:49:18 <ivanm> isn't freenode meant to be about software, organisations, etc.?
03:49:23 <ivanm> not porn?
03:49:34 <ivanm> Gracenotes: and how do you know such things? :p
03:49:54 <Gracenotes> except the one I know of is a double-hash channel
03:50:34 <Twey> ivanm: Maybe it's open-source porn!
03:50:40 <ivanm> heh
03:50:53 <pltonik> guys thanks for all your help i think it all finally sank in. learned a lot from something so small - haskell is a beast. cheers!
03:50:55 <ivanm> you can tweak the images freely, as long as you share your tweaks?
03:51:02 <Twey> pltonik: Hehe, you're welcome :)
03:51:06 <Twey> ivanm: Hahaha
03:51:31 <Twey> I think in a porn context that means the models are available to all :-P
03:53:05 <dmwit> porn is made in inkscape... with the SVG available
03:53:08 <dmwit> maybe that is open source
03:53:42 <Twey> Hehe
03:53:58 <ivanm> or the gimp?
03:54:04 <dmwit> DGS actually has an interesting manifesto somewhere about what the GPL means for images used in an open-source web server.
03:54:12 <dmwit> I can't seem to find it now, though.
03:54:23 <Zao> ivanm: Watch you, you'll start an open source porn holy war.
03:54:30 <dmwit> err... also, DGS=dragongoserver.net (that abbrevation is probably not known here =)
03:54:46 <ivanm> heh
03:57:23 <pltonik> me thinks 'open-sauce' is a more accurate term
03:57:46 <pltonik> i shall leave you with that.
03:57:57 <pltonik> thanks again guys/gals. laterz.
03:58:14 <Axman6> hmm, anyone know much about nuclear... well stuff... wondering how safe http://www.dealextreme.com/details.dx/sku.8922 would be
03:58:32 * Axman6 is asking here because it's full of intelligent people
04:00:40 <ivanm> probably pretty safe
04:00:59 <ivanm> tritium is what they use to make glow-in-the-dark bits on watches, etc.
04:01:06 <Axman6> yeah
04:01:14 <Axman6> reading up on it on wikipedia
04:01:19 <Axman6> seems safe enough
04:18:38 <inbuninbu_> question... i'm having trouble understanding something about transformers
04:19:02 <inbuninbu_> who is cooler, optimus prime or megatron :-)
04:19:15 <inbuninbu_> seriously though... MaybeT
04:19:50 <inbuninbu_> i've got type MaybeGet = MaybeT Get a
04:20:33 <inbuninbu_> and a function of that type. my problem is that i want to return a Nothing
04:20:59 <inbuninbu_> but if i try to return a Maybe value, it thinks i'm in the Get monad
04:21:28 <inbuninbu_> any suggestions as to what i'm not understanding?
04:22:23 <Saizan_> you should use mzero
04:22:33 <RayNbow> @unmtl MaybeT m a
04:22:33 <lambdabot> m (Maybe a)
04:22:35 <Saizan_> or MaybeT (return Nothing)
04:22:59 <Saizan_> assuming i've inferred correctly what you meant by return a Nothing :)
04:25:40 <inbuninbu_> Saizan_: thanks!
04:37:26 <bakesz> hi guys!is there a function which gives True if the argument is False and gives False if the argument is True?thank you.(sorry for my english)
04:38:12 <ski> > not False
04:38:13 <lambdabot>   True
04:38:14 <ski> > not True
04:38:16 <lambdabot>   False
04:38:38 <ski> @type not
04:38:39 <lambdabot> Bool -> Bool
04:38:53 <Axman6> bakesz: nothing wrong with your english that i could see (except for the lack of spaces after punctuation)
04:39:37 <bakesz> thank you guys
04:41:21 * sm tries adding links to the bot
04:41:58 <sm> dcoutts__: it would be cool if the hackage feed set the author field
04:43:15 <ivanm> which version of base came with 6.6.1?
04:44:36 <ivanm> because I'm trying to help someone using 6.8.2 where a library with both base<3 and base>=3 deps is complaining that base<3 can't be found :s
04:47:11 <the_edge> ivanm: if you are the one that has 6.6.1, you could use "ghc-pkg list" to see what version of base you have
04:47:27 <ivanm> the_edge: I don't ;-)
04:47:53 <ivanm> I'm trying to fix some deps up for an installer
04:48:03 <the_edge> ivanm: oh :(
04:48:40 <ivanm> this user has 6.8.2, but cabal-the-library is complaining that base<3 not being found; I wanted to know about 6.6.1 in case I could force usage of base-3
04:52:16 <ivanm> different topic: is there a monadic form of concatMap?
04:52:38 <mauke> type signature?
04:53:06 <ivanm> (a -> m [b]) -> m [a] -> m [b]
04:53:11 <ivanm> hoogle doesn't recognise it :s
04:53:28 <mauke> :t mapM
04:53:29 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
04:53:40 <ivanm> or even (a -> m [b]) -> [a] -> m [b]
04:53:57 <the_edge> ivanm: I downloaded ghc-6.6.1 and looking through the sources I saw that base was version 2.1.1 in the file ghc-6.6.1/libraries/base/base.cabal
04:54:07 <ivanm> *nod*
04:54:09 <ivanm> thanks the_edge
04:54:10 <mauke> :t (liftM concat .) . mapM
04:54:11 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => (a1 -> m [a]) -> [a1] -> m [a]
04:54:29 <ivanm> but it turns out the deps he needed for hedgewars were different than what we'd though, so I can just delete all that \o/
04:55:34 <ivanm> thanks mauke
05:02:14 <dcoutts> sm: we can do that in the new code easily :-)
05:03:56 <sm> quite right :)
05:05:05 <sm> to switch over, I think you said it needs user management and something else ?
05:05:50 <dcoutts> sm: yes, two things, user authentication management, ie which people are allowed to update which things, and the ability to add accounts
05:06:02 <dcoutts> sm: and upload and serving doc tarballs
05:06:19 <dcoutts> sm: I had a design for a component that could serve the content of .tar files
05:07:09 <dcoutts> sm: the idea then is that we can browse the content of uploaded packages, but also use that to serve haddock docs, while keeping it easier to manage on the server by keeping the docs in one .tar file
05:08:20 <sm> I see.. but I guess strictly speaking you could cut over now ? since the old one doesn't have user management either
05:08:21 <dcoutts> sm: so the main part of that is a memory-efficient data structure to map string file paths to (offset,length) pairs
05:08:42 <dcoutts> sm: well, it's using apache htpasswd and you can add users to that
05:08:58 <dcoutts> sm: currently there's no live way to adjust the set of users :-) only import
05:09:56 <sm> just trying to understand if there's a showstopper that prevents deploying this right away.. once it's live it will get more hacking
05:10:15 <dcoutts> sm: well not serving docs would be a regression
05:10:25 <sm> oh I see
05:10:26 <dcoutts> sm: and not being able to add new users wouldn't be great :-)
05:10:34 <sm> gotcha
05:10:50 <dcoutts> and for a real deployment we'd also need to think about backups
05:11:14 <sm> and check out happstack's memory use
05:11:37 <dcoutts> yep, though from previous testing that seemed ok
05:11:41 <sm> great
05:12:05 <dcoutts> slightly too much to run it on code.h.o, but that box has hardly any memory, so it's not surprising
05:19:38 <ivanm> dcoutts: how old is said box?
05:22:26 <sm> while using a regexpr function in ghci: "ghc: unable to load package `syb'"
05:22:31 <sm> weird
05:23:04 <ivanm> :/
05:23:19 <ivanm> sm: maybe you tried upgrading syb, but your version of ghc has it internally and it thus interferes?
05:23:35 <ivanm> or else run "ghc-pkg check" to see if anything needs to be rebuilt
05:24:00 <sm> I've never heard of syb.. I know that regexpr installed fine and has been working in other ways
05:25:57 <ivanm> syb == scrap your boilerplate
05:25:59 <sm> oh there's more.. previous to that it says Loading package syb ... linking ... <interactive>: /usr/local/lib/download-0.3/ghc-6.10.2/HSdownload-0.3.o: unknown symbol `stat64'
05:26:01 <sm> aha
05:26:19 <ivanm> 6.10 seems to come with 0.1.0.1
05:26:21 <sm> but I'm using 6.10.3, hmm
05:26:34 <ivanm> sm: what does "ghc-pkg list syb" say?
05:26:51 <sm> one sec
05:26:58 <sm> 0.1.0.1
05:27:26 <ivanm> OK, that's what ghc comes with
05:27:31 <sm> I reintalled regexpr.. all well now
05:27:50 <sm> thanks
05:28:21 <ivanm> no worries
05:34:23 <_JFT_> Is there a way, when installing a cabal package, that its documentation is added to the index of GHC package documentation so that a single html page display the full package hierarchy of what is locally installed?
05:35:25 <ivanm> _JFT_: I don't think so...
05:35:34 <ivanm> which is a pity, because I would really like something like that
05:35:36 <Axman6> not that i know of, but it;s something i've wanted
05:35:43 <ivanm> though first of all, user/global stuff would clash
05:36:04 <_JFT_> ivanm: thanks that's what I was afraid of :(
05:36:23 <ivanm> though having a central index would be better than editing the ghc index
05:37:24 <_JFT_> ivanm: true
05:37:58 <Saizan_> http://hackage.haskell.org/trac/hackage/ticket/516 <- there's a ticket for anyone that'd like to work on it
05:39:22 <ivanm> AFAICT, the biggest problem is telling which non-base modules are provided with ghc
05:39:54 <ivanm> I know that recently, I've had to remember to look at my ghc docs for Cabal's haddock docs, since I don't have an external one installed
05:41:25 <_JFT_> I have never installed lambdabot locally but couldn't it do it?
05:41:38 <_JFT_> isn't there some functionality option for that?
05:41:52 <ivanm> _JFT_: for what?
05:42:10 <_JFT_> providing a centralize search index for the locally installed package
05:42:16 <hackagebot> released: LambdaHack 0.1.20090606  http://hackage.haskell.org/cgi-bin/hackage-scripts/package/LambdaHack-0.1.20090606
05:42:29 <ivanm> nah, IIRC lambdabot uses ghc's only
05:43:18 <_JFT_> ivanm: ah, I thought there might have been directive to add extraneous documentation paths
05:43:34 <ivanm> *shrug* could be
05:43:57 <ivanm> but in general, IIRC most of lambdabot's info is manually inputted :s
05:45:15 <sm> yay.. regexpr is good
05:45:35 <shapr> ivanm: I think debian's ghc docs do show the full hierarchy of what's installed.
05:45:39 <sm> regexps in haskell, made simple
05:45:58 <_JFT_> ivanm: I don't get why it is a problem to tell which non-base modules are provided with GHC. Why not fuse everything? (I am sure this is a dumb question but eh :P)
05:46:09 <sm> it just needs some more mnemonic function names
05:46:15 <ivanm> shapr: :o
05:46:50 <ivanm> _JFT_: well, if you have a central index, you need to know which libs are provided by ghc so you can find them
05:47:29 <Saizan_> ivanm: you can always ask ghc-pkg for that
05:47:35 <Saizan_> the problems are others
05:47:50 <Saizan_> like described in the ticket i've given above
05:48:10 <ivanm> yeah
05:48:33 <dcoutts> ivanm: code.h.o is a cheap virtual machine, it's not old
05:49:13 <ivanm> ahhh
05:49:32 <Saizan_> dcoutts: btw, what do you think about "cabal haddock --hoogle" generating both the html and hoogle formats, instead of only the latter?
05:50:02 <ivanm> Saizan_: since otherwise, why use "haddock" there?
05:50:05 <_JFT_> Saizan_: I am not sure I fully understand the problem there (could be language related as English is not my main language :P )
05:50:13 <dcoutts> Saizan_: do you think it's not important to be able to make just the hoogle index?
05:50:25 <Saizan_> ivanm: it's still haddock that generates the hoogle index
05:50:49 <_JFT_> actually I mentionned index but it is the hiearchy of package that I am really after...
05:50:50 <dcoutts> Saizan_: I mean, do we need a way to only make the hoogle index
05:51:19 <ivanm> Saizan_: oh
05:51:29 <dcoutts> _JFT_: http://hackage.haskell.org/trac/hackage/ticket/516
05:51:55 <_JFT_> dcoutts: Thanks, yes that's the one that Saizan_ linked earlier
05:52:00 <Saizan_> dcoutts: i don't know how/where that command is used in practice, a end-user would probably need both if it asks for hoogle
05:52:42 <Saizan_> dcoutts: also, we should add the location of the html docs in the hoogle index, so that --info can link to them
05:53:01 <dcoutts> Saizan_: sounds reasonable
05:53:19 <dcoutts> Saizan_: make sure that's recorded somewhere. Are you thinking of working on this issue?
05:54:04 <Saizan_> dcoutts: yup, though it's a bit sad that we've to run haddock twice from scratch to get both output formats
05:54:11 <dcoutts> Saizan_: also, it's not clear to me what the bigger picture is, how do I go about installing hoogle and maintaining an overall db that I can use from say the hoogle command line client?
05:54:22 <dcoutts> Saizan_: I mean, how does cabal fit into the overall process/workflow
05:56:17 <Saizan_> dcoutts: yeah, that's not obvious, i think cabal should maintain its own hoogle index and update it on every successful install
05:56:29 <Saizan_> s/install/install with docs/
05:56:44 <_JFT_> I guess I am going to suggest something dumb (I am not versed in dynamic html page generation) but instead of generating and index couldn't we just have a "smart" index page which search local documentation directory and merge them into a unified hierarchy when loadin the page?
05:57:00 <dcoutts> Saizan_: does the existing hoogle command line have a central per-user db?
05:57:33 <Saizan_> dcoutts: per-installation, not per user
05:57:52 <dcoutts> Saizan_: and the installation can be per-user I suppose
05:58:10 <Saizan_> dcoutts: yes
05:58:18 <Saizan_> dcoutts: the db is installed as one of the data-files
05:58:38 <dcoutts> Saizan_: ok, and is that the one we should be updating?
05:58:57 <Saizan_> dcoutts: it's shipped in the tarball though, so it doesn't necessarily reflect your own installation
05:59:43 <Saizan_> dcoutts: which is another problem, ghc doesn't ship the hoogle index for its libs, and you don't have the source to generate it either
05:59:51 <dcoutts> Saizan_: or perhaps we should just install the .hoogle text file along side the .haddock file and let the command line client re-generate its central binary index
06:00:24 <Saizan_> dcoutts: so let hoogle deal with ghc-pkg to find them?
06:00:39 <dcoutts> Saizan_: though it does ship the .haddock files. I wonder if we can't get haddock/hoogle to generate what it needs from the .haddock files
06:00:47 <dcoutts> Saizan_: exactly
06:02:00 <Saizan_> dcoutts: currently we can't, maybe we can hack haddock to that point :)
06:02:07 <dcoutts> Saizan_: right
06:02:09 <sm> darn, I'm getting unknown symbol stat64 when it loads syb again
06:03:22 <Saizan_> dcoutts: i wonder if we've to worry about portability over the haskell compiler or not? since haddock works only with ghc
06:03:47 <dcoutts> Saizan_: well hoogle depends on haddock already
06:04:48 <_JFT_> if I understand your conversation you intend to use a locally install hoogle?
06:05:19 <Saizan_> dcoutts: in future Cabal could export an api to find the installed package config for any compiler
06:05:38 <Saizan_> _JFT_: yes, we were mainly talking about the hoogle index
06:05:42 <dcoutts> Saizan_: it does already
06:05:51 <ivanm> I suppose since he's no longer a student, ndm isn't working on the next version of hoogle for GSoC?
06:06:39 <dcoutts> Saizan_: though admittedly it's not as convenient as it could be
06:06:41 <Saizan_> _JFT_: using a dynamic page for the haddock index might work locally, though it'd be a problem if you want to serve the page online
06:06:44 <_JFT_> Doh I didn't know it could be ran that way... So much thing to learn. I more I learn the more I realize I know nothing!
06:07:26 <_JFT_> Saizan_: yes but if people want to have their local installation hierarchy that should be ok
06:07:28 <Saizan_> though i'm not sure if js can look at your filesystem locally?
06:07:45 <_JFT_> Saizan_: depending on the engine yes
06:08:15 <_JFT_> Saizan_: I am by no mean a JS expert but I know for exemple that OS X widgets can
06:08:28 <Saizan_> _JFT_: then we'd have the problem of how fast it'd be
06:08:39 <dcoutts> _JFT_: seems to me it'd be pretty straightforward to get cabal-install to maintain a haddock contents html page
06:09:00 <_JFT_> Saizan_: hence why I just just meant the hierarchical content and not the fully flattend index
06:09:15 <dcoutts> we just call haddock after installing a bunch of packages, passing it all the .haddock files for all installed packages
06:09:24 <_JFT_> dcoutts: that would do most of the trick with a merge of the GHC doc content
06:09:37 <Peaker> Hey, are there any symbolic math solver libraries?
06:09:43 <Saizan_> _JFT_: you can include the GHC doc content too
06:09:46 <dcoutts> _JFT_: no need to merge anything
06:10:01 <Saizan_> we do have the .haddock of those libs
06:10:24 <Saizan_> what should we do for multiple versions of the same library though?
06:10:27 <_JFT_> Saizan_, dcoutts : ah... I need to learn more about haddock, cabal and hoogle....
06:10:42 <dcoutts> Saizan_: probably just pick latest of each
06:10:44 <_JFT_> Saizan_: with a dynamic page I would say a pull down?
06:10:54 <_JFT_> Saizan_: defaulting on the latest
06:11:15 <_JFT_> Saizan_: (and yes I am a bit idealistic here :) )
06:11:25 <dcoutts> who wants to implement this now? I can give guidance, I reckon it'd take an hour or so
06:12:15 <_JFT_> dcoutts: I would be willing but given my state of knowledge it would be many many hours not just one :P
06:12:39 <Saizan_> i think i could afford it :)
06:13:11 <dcoutts> Saizan_: you mean you want to do it now? lemme point out the appropriate place to put it
06:13:13 <Saizan_> but, why do we maintain the index for haddock and instead we plan on hoogle maintaining its own ?
06:13:23 <Saizan_> dcoutts: ok
06:13:44 <Saizan_> i guess haddock doesn't have its own index
06:13:47 <dcoutts> Saizan_: -> #haskell-in-depth ?
06:15:02 <Taejo> in the non-empty list thread on haskell-cafe, Conor says `data NE x = x :> Maybe (NE x)` is Applicative in four different ways. What are they? I can only think of two (one analogous to [], the other to ZipList)
06:17:32 <Peaker> any Haskell library that can do polynomial equation multiplication and solving?
06:18:56 <ivanm> Peaker: the one you're about to write? :p
06:19:03 <Peaker> ivanm, :-(
06:19:09 <ivanm> Peaker: IIRC, the Haskell Road has something on this...
06:19:20 <ivanm> but only for binary polynomials :s
06:20:06 <Peaker> you mean, up to x^2?
06:20:45 <ivanm> no, as in x \in {0,1}
06:21:02 <bremner_> Peaker: There is a project to write a symbolic algebra package in haskell
06:21:51 <bremner_> I forget the name
06:24:00 <bremner_> Technically that answers your question:-)
06:24:15 <ivanm> docon or something?
06:26:29 <sm> oh man, this is bad.. I've installed fresh 6.10.3 binaries and still getting unknown symbol 'stat64'
06:26:42 <sm> I broke it somehow.. what could it be
06:26:46 <ivanm> sure it's not your regex library that has the problem?
06:27:08 <sm> pretty sure.. I get it now when loading the download package
06:27:26 <sm> when ghci loads/links it
06:27:58 <_JFT_> sm: which OS?
06:28:33 <sm> ubuntu intrepid, x86 64
06:30:20 <Peaker> bremner_, heh
06:30:32 <_JFT_> sm: did you upgraded from a 32 bit installation? Or did you installed fresh a 64?
06:30:33 <uzytkownik> Hello. How to link to module without cabal? I have a short test 'script' I'd like to compile but ld complains about references to network.
06:30:50 <sm> not sure
06:31:00 <inbuninbu_> question: what is generally considered the best way to use monad transfomers? i've seen at least two ways. one using newtype with newtype deriving, and the other using a simple type alias
06:31:09 <_JFT_> uzytkownik: the package need to be registered using ghc-pkg
06:31:17 <_JFT_> uzytkownik: cabal does this for you
06:32:01 <_JFT_> uzytkownik: (if I understdood you questions correctly that is!)
06:32:01 <uzytkownik> _JFT_: Without cabal. A 10-lines script to test something is not worth writing cabal IMHO
06:32:28 <_JFT_> uzytkownik: no no I meant that the module you are referring too should have registered if it was instaled with cabal
06:32:29 <dcoutts> uzytkownik: ghc --make
06:32:42 <_JFT_> uzytkownik: if you are compiling or running you don't need cabal
06:33:03 <_JFT_> uzytkownik: unless you are missing that dependency...
06:33:11 <uzytkownik> dcoutts: Thanks
06:33:29 <ski> @type \f -> join . liftM (liftM join . sequence . map f)
06:33:29 <_JFT_> uzytkownik: sorry I misunderstood your  question :(
06:33:30 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => (a1 -> m [a]) -> m [a1] -> m [a]
06:33:32 <ski> @type \f -> liftM join . sequence . map f
06:33:34 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => (a1 -> m [a]) -> [a1] -> m [a]
06:35:47 <malosh> Hi. Does someone know if it is possible to create an MArray instance with a specialized Ix type (i.e. I want (Int,Int) to make points in an image) ?
06:36:12 <_JFT_> sm: might be that you have a 32 bit solib leftover in your system...
06:36:26 <MyCatVerbs> malosh: huh? There's already an Ix instance for (Int,Int).
06:36:30 <malosh> The idea is to use an MArray instance to manipulate a C Array over which I have no control
06:37:12 <MyCatVerbs> malosh: sounds doable. You'll need to use Foreign.Storable.
06:37:24 <malosh> Yes but the compiler won't let me declare an instance MArray MyArray Int IO... in which I impose the index type
06:37:59 <malosh> I still will have to use newArray (a,b) :: IO (Image (Int,Int) Color)
06:39:00 <MyCatVerbs> Yes, that's because of how the variables in the MArray declaration work out.
06:39:24 <MyCatVerbs> You don't need to create a specialised version for (Int,Int) specifically anyway.
06:39:49 <MyCatVerbs> You can use anything with an Ix instance using the (index) method.
06:40:05 <malosh> In fact I think I do : I need to match against (x,y) when I want to manipulate my C pointers
06:40:30 <malosh> (I did not choose how the C array is layed out)
06:40:50 <MyCatVerbs> Oh, you mean your data is laid out as an array of pointers to row data, rather than one giant contiguous array?
06:41:11 <malosh> (or at least it could be :-)
06:41:36 <MyCatVerbs> In that case, you can't make a MArray instance, no.
06:41:48 <MyCatVerbs> (Not by any method I can think of, anyway.)
06:41:54 <malosh> ok, thanks
06:42:20 <MyCatVerbs> But even in C, for *image* data you'll almost certainly be using a contiguous array, won't you?
06:43:00 <MyCatVerbs> Oh, no, libpng does the array-of-pointers-to-row-data thing. *grumbles*
06:43:03 <malosh> yes, in fact I'll have a big contiguous array, but then I need to control precisely how the Ix class agences the indexes
06:43:42 <malosh> because I'd like to write things like colors like writeArray a ix (r,g,b)
06:43:51 <uzytkownik> What's wrong with such program http://haskell.pastebin.com/m28036ed4? It seems to hang instead of printing first line of response (I try to learn socket API so please don't redirect me to HTTP libraries unless for example code). It should work judging on the output of telnet 80 google.com.
06:43:55 <Athas> The following program crashes with a stack overflow for some inputs, supposedly due to evaluation of a large thunk:  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5603#a5603 - the only data I am able to extract with the profiling tools that it apparently allocates a lot of Word32s right before it crashes.
06:43:58 <malosh> and the three color planes are separated in the lib I'm using
06:44:12 <Athas> But I store essentially everything in IOUArray, aren't those strict?
06:44:30 * MyCatVerbs flips a coin to pick whose problem to look at first.
06:45:17 <MyCatVerbs> uzytkownik: put (hFlush h) in between lines 9 and 10, please, and tell me if that fixes it.
06:45:34 <MyCatVerbs> (Of course my coins are all biased to go for the easy problem first.)
06:46:24 <uzytkownik> MyCatVerbs: Thanks. Too much with unbuffered streams ;)
06:46:35 <MyCatVerbs> uzytkownik: telnet sends (at least one) packet every time you hit the enter key. Handle IO is buffered up to some arbitrary block size unless you use hSetBuffering to set it to something else.
06:47:00 <uzytkownik> MyCatVerbs: I know. I forgot :(
06:47:01 <MyCatVerbs> (hSetBuffering LineBuffering) is most commonly the right one to use for telnet-friendly protocols. :)
06:47:06 <MyCatVerbs> No worries.
06:47:51 <_JFT_> uzytkownik: Not sure what you are trying to do but if you are connecting to http port this might interested you: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/curl
06:47:51 <MyCatVerbs> Athas: oh dear. Where is the (force) function defined, please?
06:48:07 <MyCatVerbs> Athas: also, your (seqforce) function is a no-op.
06:48:16 <Athas> Yeah, those were acts of desperation.
06:48:22 <Athas> force is from Control.Parallel.Strategies.
06:48:32 <Athas> It's a deprecated shortcut function.
06:48:43 <MyCatVerbs> IOUArrays are indeed strict in their elements.
06:49:03 <uzytkownik> _JFT_: As I wrote. I'm learning Socket and I'm not interesting in HTTP libraries as I'm not intending to implement those RFCs ;). Connecting to google is me hello world for networking
06:49:28 <Athas> MyCatVerbs: since reading/writing them is an IO action, shouldn't they effectively be strict in their indexes too?
06:49:35 <_JFT_> uzytkownik: sorry I had missed that part :P (trying to follow too many chanels :P )
06:50:48 <MyCatVerbs> Athas: yyyy, should be, yeah.
06:54:50 <uzytkownik> Is it working by accident or is it ok? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5604#a5604 . Judging on hGetContents docs (http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html#v%3AhGetContents) it should throw error as handle is in semi-closed state. But it seems to work for sockets. Is it an accident or is it intended (and useful for me) behavior? In what portions data is read (set by hSetBuffering?)?
06:55:20 <Athas> The program consists of a main loop modifying a state of the MachineState type.  The storage and register fields are only accessed via IO actions, idBucket and counter are only modified in functions that are called very rarely (I determined that much from profiling) and so can't be big thunks, and the finger field is inspected on every iteration of the loop to determine whether to continue.
06:55:30 <Athas> I simply can't see where long-lived thunks could be created.
06:55:53 <Athas> Unless the State monad does something behind the scenes (but I presumably use the strict version).
06:56:18 <MyCatVerbs> Athas: er, the State monad is not strict. (AFAIK making it so breaks the monad laws, I think.)
06:56:35 <hackagebot> released: tar 0.3.1.0  http://hackage.haskell.org/cgi-bin/hackage-scripts/package/tar-0.3.1.0
06:56:35 <hackagebot> released: htar 0.3.1  http://hackage.haskell.org/cgi-bin/hackage-scripts/package/htar-0.3.1
06:56:47 <Athas> Well, it's a state monad transformer wrapping the IO monad I use in my program.
06:56:49 <MyCatVerbs> Oh, that's not right. Making State strict in its state is fine, making any monad strict in its return value isn't.
06:57:03 <MyCatVerbs> My bad.
06:57:11 <Saizan_> Athas: do you use strict fields in your state type?
06:57:13 <Jedai> MyCatVerbs: There's a strict and a lazy version of the State monad in mtl
06:57:24 <Saizan_> Athas: also, maybe you want Control.Monad.Strict
06:57:36 <Saizan_> which is not strict in the state, mind.
06:57:49 <Saizan_> it's strict in the tuple holding the state and the returned value
06:58:10 <MyCatVerbs> Athas: the easiest way to track down a stack overflow in a big pile of unknown code is to load the thing in GHCi, set -fbreak-on-exception and then :trace main.
06:58:26 <Athas> Oooh, that sounds promising.
06:58:33 <Athas> I didn't know about that arg.
06:59:03 <MyCatVerbs> It's quite handy, even if it is kind of... spiky.
06:59:17 <Athas> Saizan_: what do you mean by Control.Monad.Strict?  Do you mean Control.Monad.State.Strict?
06:59:24 <MyCatVerbs> I would recommend keeping this http://www.haskell.org/~simonmar/papers/ghci-debug.pdf at hand if you're ever using GHCi's debugger.
07:00:22 <Athas> Does ghci interpret the code or compile it first?
07:00:39 <MyCatVerbs> Yes.
07:00:43 <Axman6> heh
07:01:20 <_JFT_> Athas: compile to bytecode first I think
07:01:21 <MyCatVerbs> It will load the object code for compiled modules, or if there's no .hi and .o then it'll compile your sources to byte-code and interpret it.
07:02:22 <MyCatVerbs> The byte-code interpreter isn't *ridiculously* slow, but it's still something like a ten to one disadvantage against compiling to machine code even with the optimizer turned off.
07:03:02 <Saizan_> Athas: yes, sorry
07:03:05 <MyCatVerbs> Usually, of course, you don't care, since most of the time when you want to use GHCi in the first place you are limited by your ability to write useful code rather than your machine's capacity to run it. :)
07:06:36 <ivanm> MyCatVerbs: by that, do you mean "you're writing your code and only using ghci to test it", or "people who use ghci can't write good code anyway"?
07:06:37 <ivanm> ;-)
07:08:15 <MyCatVerbs> ivanm: for values of "you" that consist entirely of "me", when you are *writing* code in GHCi, it's to test out random (probably bad) ideas. =)
07:08:32 <MyCatVerbs> ivanm: otherwise, I'd be writing it in vim instead. :)
07:08:38 <ivanm> heh
07:08:50 <ivanm> so you don't load code in ghci? you just write code directly to it?
07:10:45 <MyCatVerbs> ivanm: often as not, aye. Normally when I'm writing code in GHCi, I'm flipping between it and vim, writing things in GHCi and then putting them into vim.
07:10:57 <MyCatVerbs> ivanm: probably not really a very good workflow, but oh well.
07:11:20 <ivanm> see, whereas I write it in emacs and keep hitting C-c C-l to load the file into ghci to check I got types right, it works as expected, etc.
07:11:52 <FunctorSalad> Protip for your wrists: bind it to a simpler shortcut ;)
07:12:00 <sm> darnit.. what is a good way to do something in between iterate and fold.. I want to apply a list of string replacements, one after another
07:12:03 <MyCatVerbs> Or I'll spend a half an hour or so writing something, then turf through the GHCi history to find all my definitions. :)
07:12:11 <ivanm> FunctorSalad: doesn't hurt my wrists at all...
07:12:17 <ivanm> my fingers, however, are a different story ;-)
07:12:33 <FunctorSalad> ;)
07:12:34 <MyCatVerbs> FunctorSalad: not if you put capslock and control in the correct places, and your hands are on home row anyway.
07:12:44 <ivanm> MyCatVerbs: lol, that's the worst... not wanting to re-load the file because I'd lose everything I've defined in ghci :s
07:12:53 <ivanm> (usually when I'm debugging)
07:13:03 <ivanm> MyCatVerbs: yeah, I have that but keep forgetting to use caps for ctrl :s
07:13:04 <FunctorSalad> MyCatVerbs: that particular one is ok then, I was thinking emacs-style shortcuts in general though...
07:13:14 <ivanm> then again, I typically move my hands a fair amount when I type
07:13:21 <FunctorSalad> (I just use viper mode)
07:13:39 <ivanm> I have bigger problems with my xmonad keybindings (trying to hit mod4, etc.)
07:13:41 <MyCatVerbs> FunctorSalad: yeah, I think I really ought to.
07:14:00 <MyCatVerbs> Switch from vim to emacs+viper mode, I mean.
07:14:19 <Athas> Which parameters should I pass to GHC when compiling my program so that ghci can trace it properly?
07:14:22 <Athas> I get an empty history.
07:14:37 <sm> interesting.. ivanm: whereas I have sp auto-recompiling in an emacs window, and watch for errors there as I save
07:14:48 <MyCatVerbs> I did wonder about trying switching to Yi at one point, just because I could hack on it relatively easy, but it turns out I'm just too damn lazy.
07:15:02 <ivanm> sm: using flymake?
07:15:10 <sm> using sp (searchpath.org0
07:15:14 <sm> )
07:15:24 <sm> Athas: I think none, but you must first tell ghci to start tracking, then later look at the history
07:15:27 <sm> it's in the docs
07:15:39 <ivanm> no cabal?
07:15:40 <ivanm> fail
07:16:15 <sm> cabal doesn't do this particular very useful thing
07:16:24 <ivanm> sm: I meant cabal to build it
07:16:36 <roderyk> gkt2hs question - I have a model of Layers which are tuples of (Bitmap, [Vectors]). Would it be appropriate to use PixBuf as the Bitmap (for later pixel fideling), while still doing all the rendering via Cairo? For example, I need to select a rectangle of the pixbuf and copy into a new pixbuf - I don't see the relevant api calls for this kind of operation (assume I already know the rectangle positions).
07:16:41 <sm> sp calls ghc
07:16:44 <ivanm> you really shouldn't use --make to build apps you download
07:16:51 <MyCatVerbs> s/easy/easily/, noticed that waaaaay too make.
07:17:09 <Gracenotes> hm. I forget, is there a list function to set a certain element?
07:17:10 <MyCatVerbs> s/make/late/, what the Hell is wrong with me? Aaaaaagh!
07:17:11 <ivanm> MyCatVerbs: s/make/late/ ?
07:17:12 <ivanm> heh
07:17:14 <Gracenotes> at a given position
07:17:19 <ivanm> Gracenotes: I doubt it
07:17:24 <mauke> Gracenotes: no, closest match is splitAt
07:17:35 <ivanm> yeah, I was about to suggest that
07:17:46 <ivanm> Gracenotes: if you do that a lot, then you're using the wrong data structure
07:17:46 <Gracenotes> oh, that's not a bad idea. Oh well. I suppose this is a limitation of using Haskell as a shell-script-like-thing :)
07:17:53 <Gracenotes> I may as well use arrays
07:17:58 <ivanm> or else use a zipper
07:18:04 <mauke> Gracenotes: Data.Sequence
07:18:24 <Gracenotes> eek. I just need to take a list of links and sort them according to suffixes, and then do some additional shuffling based on position
07:18:31 <ivanm> mauke: dammit, stop beating me!  I was typing in to suggest Sequence, when I saw your message! :@
07:18:33 <Gracenotes> I'll use an array
07:18:47 * ivanm thinks mauke is getting Gracenotes' messages faster than he is... >_>
07:18:52 <sm> anyway.. so anyone know how I can apply a sequence of mutator functions to a value ? this must be easy
07:19:10 <mauke> Data.Sequence is the greatest data structure known the man
07:19:10 <ivanm> sm: "mutator functions"?
07:19:18 <sm> like a string replacement
07:19:20 <ivanm> mauke: generalise it: finger trees!
07:19:26 <sm> I want to fold, but with a unary operator
07:19:28 <ivanm> sm: you mean a whole bunch of a -> a ?
07:19:32 <sm> right
07:19:39 <mauke> :t foldr (.) id
07:19:40 <lambdabot> forall a. [a -> a] -> a -> a
07:19:47 <sm> thank you
07:19:48 <ivanm> mauke: _again_ you beat me!
07:19:53 <mauke> doh ho ho
07:19:53 <ivanm> @slap mauke
07:19:54 * lambdabot beats up mauke
07:20:05 * ivanm goes off to sulk
07:20:07 <Athas> sm: it really looks like ghci can't trace compiled code.  The documentation seems to assume that everything is running interpreted.
07:20:11 <iago> [a -> a] ?
07:20:28 <ivanm> well, actually, I'm going off to undergo a brief period of unconsciousness with occasional halucinations
07:20:37 <ivanm> iago: a list of functions
07:20:41 <sm> Athas: hmm. perhaps you're right
07:20:41 <bremner> ivanm: drinking?
07:20:45 <ivanm> bremner: sleep
07:20:50 <ivanm> @time
07:20:51 <lambdabot> Local time for ivanm is Sun Jun  7 00:20:51
07:20:59 <mauke> stop living in the future
07:21:10 <iago> ouch, sure :P
07:21:11 <FunctorSalad> @time
07:21:11 <lambdabot> Local time for FunctorSalad is ∞
07:21:15 <ivanm> heh
07:21:18 <bremner> ivanm: that sounds asian
07:21:18 <ivanm> FunctorSalad: :o
07:21:23 <mauke> @time preflex
07:21:24 <lambdabot> Local time for preflex is 2009-06-06 14:23WHERE IS SARAH CONNOR?
07:21:27 <Twey> 15:19:10 < mauke> Data.Sequence is the greatest data structure known the man
07:21:29 <ivanm> bremner: or not...
07:21:37 * ivanm comes from a Land Down Under
07:21:40 <Twey> mauke: Blasphemy!  DList is the One True Data-Structure!
07:21:48 <Twey> Heh, ivanm
07:21:58 <bremner> ivanm: dontcha know, its all australasia now... :-)
07:22:01 <FunctorSalad> it's a bit lonely here at the end of time though
07:22:08 <ivanm> @slap bremner
07:22:08 * lambdabot beats up bremner
07:22:28 <mauke> FunctorSalad: oh yeah, I've been there
07:22:33 <mauke> Spekkio is nice, though
07:22:33 <bremner> fine, I won't visit you next time I'm in Tokyo
07:22:48 <FunctorSalad> mauke: really, what does he do all day? ;)
07:22:52 <ivanm> FunctorSalad: were you a victim of the Forever War or something?
07:23:01 <ivanm> bremner: well, it'd be a bit hard for you to do so...
07:23:11 <ivanm> you'd need another 10 hour flight or so...
07:24:54 <_JFT_> how do you do those "emote" again?
07:25:11 <mauke> it's called an ACTION
07:25:20 <_JFT_> mauke: Thanks :)
07:25:22 <p_l> _JFT_: /me <text>
07:25:32 * _JFT_ DOH!
07:25:45 <Twey> Or: /ctcp <channel> ACTION foos
07:25:46 <Twey> :-P
07:25:47 <MyCatVerbs> /ctcp target ACTION commits murder.
07:25:58 * Twey chuckles.
07:26:16 <MyCatVerbs> Or privmsg target :^Aaction flails wildly.^A
07:26:39 <FunctorSalad> mp3bot dances \o/
07:26:43 <MyCatVerbs> But I don't think that very many people other than me use netcat for an IRC client very often. :)
07:26:52 <Twey> I use telnet sometimes
07:27:04 <Twey> We weren't allowed to install clients back in college
07:27:14 <MyCatVerbs> Twey: use netcat instead. Telnet isn't really all that well designed for it. ;)
07:27:19 <Twey> And Mibbit hadn't been invented yet :-P
07:27:20 <joga> responding to ping is a pita
07:27:30 <Twey> MyCatVerbs: We wouldn't have been allowed to install that, either, I'm afraid :)
07:28:02 <MyCatVerbs> joga: I actually have a short Haskell program sitting around that acts pretty much identically to netcat, except that it sends PONG on my behalf. :)
07:28:11 <joga> :)
07:28:17 <Twey> MyCatVerbs: Psht
07:28:22 <Twey> Don't do that
07:28:36 <Twey> Write an auto-PONG-responder and run it through netcat -e
07:28:50 <Twey> Modularity FTW
07:28:54 <MyCatVerbs> When I'm actually using netcat though, I just send PINGs myself so that the server doesn't bother to PING me. Less typing.
07:29:17 <Twey> Smart
07:29:45 <mathijs> I have a question about the typesystem. As an example let's look at the XHTML library. it defines HtmlElement and all for all xhtml elements there are functions to create them. All elements are the same type and can become nested in any way. So it's possible to create invalid XHTML documents. what would be the way to mandate valid documents? can this be done using types? or would it be better suited inside the (<<) function (add child)?
07:30:31 <Botje> phantom types could solve that
07:30:45 <mathijs> phantom types?
07:31:03 <Botje> check the "phantom types and subtyping" paper on haskell.org
07:31:12 <Botje> you can adapt that scheme for HTML elements
07:32:00 <mathijs> I was thinking along the lines of having a type for all different elements (and making them instances of some overall xhtml-tag typeclass) but that doesn't really solve anything :)
07:32:12 <mathijs> Botje: ok thanks, I'll have a look
07:32:30 <Berengal> Phantom types sort of do that
07:33:34 <Botje> mathijs: with phantom types you get HtmlElement Html, for example
07:34:06 <Botje> and addChildren is something like ValidChild b a => HtmlElement a -> HtmlElement b -> HtmlElement a
07:34:28 <Botje> and then you make instances like ValidChild Body Html, etc
07:35:35 <mathijs> hmm that sounds about right indeed. so in that way you can really mandate hierarchical stuff in the typesystem itself instead of hiding the constructors & stuff and mandating the use of functions to alter the document?
07:50:31 <nikki93> can u pls rite a programme for me
07:51:41 <Axman6> ...
07:51:47 <Twey> ...
07:51:51 <skorpan> ???
07:52:28 <earthy> nikki93: right a computerprogram? possibly, depending on language
07:52:28 * Twey tries to write a shrugging emoticon in three characters, but fails
07:52:42 <Axman6> > fix (const ())
07:52:44 <lambdabot>   ()
07:52:46 <skorpan> ^0^
07:52:53 <Axman6> > fix (flip const ())
07:52:59 <lambdabot>   mueval-core: Prelude.read: no parse
07:52:59 <lambdabot>  mueval: ExitFailure 1
07:53:02 <Twey> skorpan: Happyface.  And/or hunchback.
07:54:10 <skorpan> Twey: good try though
07:54:42 <Gracenotes> big mouth
07:55:43 <Twey> True
08:09:05 <roconnor> the haskell haskell interpreter is pretty nice
08:09:11 <roconnor> at least in theory
08:09:15 * roconnor hasn't run it
08:20:20 * SamB wonders if specifying a HostName in an ssh_config(5) section will cause the section(s) corresponding to *that* name to be considered
08:20:51 <david48> Hi dear channel. Anyone happens to know which package should I install on (K)ubuntu in order to have the haskell platform configure not stop on "checking for library containing glEnd... no"
08:21:36 <Botje> SamB: a quick experiment says no
08:21:58 <SamB> david48: the OpenGL development package?
08:22:15 <SamB> might be mesa.*-dev
08:23:13 <SamB> ... wierd ... is apt written in Java now ???
08:23:21 <david48> samB: I've installed opengl-dev, glut3-dev, mesa-common-dev
08:24:23 <david48> samB: also  x11proto-dl-dev, libgl1-mesa-dev   ( I have no idea if any of them is needed, I just installed them hoping that configure would pass )
08:24:28 <SamB> david48: hold on, I'll tell you what I've got that has that ...
08:25:51 <david48> Checking the log, it says cannot find -lopengl32. Probably I need more than just the dev package.
08:26:44 <SamB> huh ...
08:27:08 <SamB> I have a symlink called libopengl32.so, but it points at a non-existant filename ...
08:28:23 <david48> trying to find which package provides libopengl32...
08:28:53 <roconnor> > let a --> b = a + b in 5 --> 6
08:28:55 <lambdabot>   11
08:29:16 <roconnor> > let a |-> b = a + b in 5 |-> 6
08:29:17 <lambdabot>   11
08:29:54 <SamB> david48: well, I'll tell you what package the symlink came from here ...
08:30:02 <SamB> oh, it didn't come from a package ?
08:30:06 <SamB> ... ???
08:31:01 <SamB> david48: well, I would have a /usr/lib/libGL.so from package "libgl1-mesa-dev"
08:31:25 <SamB> except my nvidia-glx-legacy-96xx package has diverted it to a different location
08:32:02 <david48> samB: installed that one. I've got libGL and libGLU in /usr/lib
08:32:16 <david48> samB: libGLcore too
08:32:19 <Twey> > let f a | a == 1 = 2 in f 1
08:32:20 <lambdabot>   2
08:32:28 <SamB> well, just create libopengl32.so as a symlink to libGL.so, I guess
08:32:31 <Twey> > let f a | -a == 1 = 2 in f (-1)
08:32:32 <lambdabot>   2
08:32:32 <SamB> that's what it is here
08:32:35 <Twey> > let f a |-a == 1 = 2 in f (-1)
08:32:36 <lambdabot>   <no location info>: Parse error in pattern
08:32:54 <SamB> assuming you're running a 32-bit userspace
08:33:06 <Twey> Significant whitespace already exists for operators
08:33:39 <david48> samB: I do.
08:34:06 <roconnor> @fixity ++
08:34:07 <lambdabot> Unknown command, try @list
08:34:33 <mauke> preflex: seen deeflex
08:34:33 <preflex>  Sorry, I haven't seen deeflex
08:35:08 <deeflex> hmm.
08:35:09 <deeflex> =)
08:35:14 <bremner> Peaker: DoCon was indeed the package I was thinking of
08:35:31 <bremner> http://haskell.org/docon/
08:41:27 <david48> Well there's no package in the jaunty repositories that give a libopengl32.* so I guess I'll have to try with a symlink.
08:43:15 <david48> ... and that was all there is to it. Still, it's kind of dirty that I have to make a symlink for the haskell platform to configure on (K)ubuntu.
08:47:21 <defun> hi. can anyone point to a link that would allow to load a .hs file or haskell binary or haskell bytecode from a hypothetical haskell program, extract some arbitrary values, and save them to a tree or a list or some other misc. data structure/container, for the time that the program is running. I would prefer if I could use GHC directly, instead of parsec. Thanks.
08:48:04 <Zao> The GHC API might be decent enough.
08:48:14 <Zao> ghci and lambdabot uses it, don't they?
08:48:57 <defun> zao: any tutorials/documentation I can look at?
08:49:15 <defun> i can't find ghc api on hackage...
08:49:59 <pumpkin> it comes with ghc :P
08:50:10 <Zao> defun: The GHC wiki probably has a fair bit on it, as well as the GHC docs.
08:50:24 <Zao> As it's built-in and not generic, I doubt it'd be on Hackage.
08:50:31 <defun> ah. thanks.
08:50:48 <Zao> I can't offer any links, as I'm currently on a less-than-VT100 terminal :)
08:50:58 <Zao> #ghc may have insights.
09:06:24 <nikki93> C++ classes suck.
09:06:43 <sm> blinding insight! printf adapts to the IO monad
09:07:09 <sm> no more putStrLn $ printf
09:08:14 <deeflex> I have a data type defined in one file..and wish to create an instance of that type in another file but I keep getting  Syntax error in input (unexpected `='). Yes I have imported the file/module.
09:08:57 <deeflex> new haskell coder <- :D
09:09:01 <Botje> can you show the two files?
09:10:26 <deeflex> yes sure
09:11:04 <MyCatVerbs> @where hpaste
09:11:04 <lambdabot> http://hpaste.org/
09:12:22 <deeflex> in module A : data Distance = DistElement { from :: String, to :: String, dist :: Float } deriving (Show,Eq) . In module B: module B where import A     {code ....element = DistElement "a" "b" 1.0..more code.}
09:13:32 <MyCatVerbs> Please just hpaste the whole files. Much easier to work that way.
09:14:05 <deeflex> OK
09:14:54 <deeflex> But I don't see why the rest of the code is relevant
09:15:14 <mauke> so we can reproduce the problem
09:15:31 <mauke> if you can remove the rest of the code while preserving the error, even better
09:25:14 <roconnor> @seen luqui
09:25:14 <lambdabot> I saw luqui leaving #haskell-blah and #haskell 6h 22m 2s ago, and .
09:26:12 <roconnor> @tell luqui I am not a number, I am a free variable: http://www.e-pig.org/downloads/notanum.pdf
09:26:12 <lambdabot> Consider it noted.
09:26:56 <shazam> what type system extension would allow (\(x:;forall y. y -> y) -> (y 1, y True)) (\z -> z) ?
09:27:09 <deeflex> MyCatVerbs, mauke : here it goes. There's a lot of other probs too, but first is line 51 http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5605#a5605
09:27:20 <opqdonut> shazam: rank-2 (or rank-n) polymorphism
09:27:26 <mauke> and pattern signatures
09:27:28 <opqdonut> that too
09:28:14 <mauke> deeflex: that code doesn't make any sense
09:28:29 <mauke> deeflex: is selectionlist supposed to be a function parameter?
09:28:32 <Botje> deeflex: uh. what's that loop fi di vi ei i doing there?
09:29:05 <mauke> deeflex: line 47, 48: vi and ei look unused
09:29:26 <deeflex> please..there's a lot of things wrong..I know. But right now it's that highlighted line, I doubt the other things affect the way I create a new instance of Distance.
09:29:36 <mauke> deeflex: no, stop
09:29:47 <mauke> you need to fix the first problem first
09:30:04 <mauke> you can't just start in the middle with no understanding what's going on
09:30:53 <MyCatVerbs> First things first, fix your indentation.
09:31:06 <mauke> deeflex: why do you think there's anything wrong with the way you use DistElement?
09:31:10 <MyCatVerbs> Things that are supposed to line up need to actually line up.
09:32:54 <shazam> does rank 2 also allow (\ (x:: forall y. y -> (forall z. z -> z)) -> (x 1 True, x True 1)) ?
09:33:00 <deeflex> mauke, well that's where hugs tells me there's an error, but yes I agree it might have something to do with something missing in the above lines too.
09:33:13 <mauke> deeflex: I thought the error was about the =
09:33:26 <Botje> deeflex: lines 49 and 50 should be on the same line
09:34:06 <deeflex> omg
09:34:14 <Botje> deeflex: that or the body of your function is screwed up
09:34:27 <deeflex> omg...nevermind I got it lol
09:34:30 <deeflex> =)
09:45:34 <SuperDuper> hello, can anyone give me an example of a tree with such data Tree a = Node ( Tree(a,a) ) | Leaf a definition? i can't bite the pair inside
09:46:03 <roconnor> SuperDuper: Leaf 0
09:46:17 <roconnor> SuperDuper: Node (Leaf (0,1))
09:46:35 <Zao> Tree Chainsaw
09:46:44 <roconnor> SuperDuper: Node (Node (Leaf ((0,1),(2,3))))
09:47:02 <McManiaC> foo.hs:10:4: `print' is not a (visible) method of class `Fraction'
09:47:05 <roconnor> SuperDuper: Leaf (6,"Hello World", id)
09:47:06 <McManiaC> what does that mean?
09:47:23 <McManiaC> this code:  http://sprunge.us/VVXe
09:47:53 <roconnor> McManiaC: you are tying to make a instance of Fraction with a method named print
09:47:53 <mauke> McManiaC: instance Frac Fraction
09:48:13 <MyCatVerbs> McManiaC: it is complaining that you put the definition of (print) inside the Fraction instance for Frac, but (print) isn't a part of the Fraction class.
09:48:56 <MyCatVerbs> McManiaC: if you just move the print line out of that instance definition then that error will go away. Yay!
09:49:05 <McManiaC> ah i got it
09:49:05 <McManiaC> okay
09:49:07 <McManiaC> :)
10:15:10 <deeflex> ok I have a list of [(someObject,Float)...] . I need to select the element from the list with the smallest Float-value. How can I do this?
10:15:31 <iago> minimumBy?
10:16:10 <iago> > [('a',1.0), ('b',0.5)]
10:16:12 <lambdabot>   [('a',1.0),('b',0.5)]
10:16:20 <iago> :t minimumBy
10:16:21 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
10:16:24 <iago> :t on
10:16:26 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
10:16:37 <iago> > minimumBy (compare `on` snd) [('a',1.0), ('b',0.5)]
10:16:39 <lambdabot>   ('b',0.5)
10:16:39 <MyCatVerbs> :t comparing
10:16:40 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
10:17:07 <MyCatVerbs> > minimumBy (comparing snd) [('a',1.0),('b',0.5)]
10:17:08 <lambdabot>   ('b',0.5)
10:18:03 <deeflex> iago, perhaps so..not familiar with the libs yet. I'll check it out :)
10:18:27 <deeflex> MyCatVerbs, ok thanks
10:18:51 <MyCatVerbs> Thank iago, not me. I forgot that minimumBy even existed. :3
10:19:18 <Axman6> heh
10:25:31 <deeflex> iago, when I try that in Hugs I get "ERROR - Improperly terminated character constant"
10:26:08 <deeflex> minimumBy (compare 'on' snd) [('a',1.0),('b',0.5)] that is
10:26:20 <mauke> `on`
10:26:46 <iago> I'm not sure if currently hugs provide Data.Function
10:26:47 <iago> anyway
10:26:59 <iago> (to get on function)
10:27:08 <deeflex> mauke,  That returns "ERROR Undefined variable "on" "
10:27:11 <deeflex> iago, ok
10:27:22 <MyCatVerbs> import Data.Function
10:27:40 <Axman6> @src on
10:27:40 <MyCatVerbs> Or :m Data.Function at the prompt.
10:27:41 <lambdabot> (*) `on` f = \x y -> f x * f y
10:28:06 <mauke> he said hugs
10:28:09 <mauke> isn't it :also there?
10:28:29 <deeflex> MyCatVerbs, can't find such a module
10:28:39 <mauke> > minimumBy (comparing snd) [('a',1.0),('b',0.5)]
10:28:40 <lambdabot>   ('b',0.5)
10:29:22 <ski> @src comparing
10:29:23 <lambdabot> Source not found. Maybe you made a typo?
10:29:31 <iago> provides hugs Data.Ord?
10:32:38 <deeflex> iago, nope nothing works
10:33:36 <iago> deech, or you define them yourself
10:33:39 <iago> or you use ghc
10:33:40 <iago> :P
10:34:53 <iago> > minimumBy (\x y -> compare (snd x) (snd y)) [('a',1.0),('b',0.5)]
10:34:55 <lambdabot>   ('b',0.5)
10:38:43 <voker57__> does anyone know a function that takes list of Maybes?
10:38:52 <voker57__> can't seem to find anything in hoogle
10:39:17 <deeflex> iago, hehe well that's for two elements..but I got more than that =)
10:39:17 <gwern> voker57__: and what would it do with this list?
10:39:17 <mauke> id
10:39:22 <gwern> head
10:39:37 <voker57__> hehe
10:39:56 <iago> > minimumBy (\x y -> compare (snd x) (snd y)) [('a',1.0),('b',0.5),('c',0.7),('d',0.2)]
10:39:58 <lambdabot>   ('d',0.2)
10:40:04 <EvilTerran> voker57__, there's catMaybes, sequence, msum...
10:40:21 <gwern> @hoogle [Maybe a]
10:40:21 <lambdabot> Prelude Nothing :: Maybe a
10:40:21 <lambdabot> Data.Maybe Nothing :: Maybe a
10:40:21 <lambdabot> Control.Applicative optional :: Alternative f => f a -> f (Maybe a)
10:40:34 <voker57__> ok
10:40:41 <iago> >let l = [('a',1.0),('b',0.5),('c',0.7),('d',0.2)]
10:40:49 <EvilTerran> > (sequence [Just 1, Just 2, Just 3], sequence $ [Just undefined, Nothing] ++ undefined)
10:40:50 <lambdabot>   (Just [1,2,3],Nothing)
10:41:09 <EvilTerran> > catMaybes [Just 1, Nothing, Just 2]
10:41:10 <lambdabot>   [1,2]
10:41:22 <EvilTerran> > msum [Nothing, Just 1, Nothing, Just 2]
10:41:23 <lambdabot>   Just 1
10:41:56 <deeflex> iago, fantastic! :)
10:42:32 <iago> deeflex, don't you know that it will works for any list?
10:43:28 <deeflex> iago, nope ..gotta learn them lambda expressions ;)
10:43:44 <ski>   comparing f = compare `on` f
10:43:46 <ski> @src on
10:43:46 <lambdabot> (*) `on` f = \x y -> f x * f y
10:44:08 <ski> deeflex : if you put those two into a module, you can use `comparing' from above directly
10:44:58 <iago> for sure is better than write (\x y -> compare (snd x) (snd y))
10:44:58 <ski> (i.e. `minimumBy (comparing snd) theList' or whatever)
10:45:08 <deeflex> ski, ok cool
10:45:14 <deeflex> lot of helpful ppl here tonight :)
10:45:19 <iago> but at least
10:45:25 <iago> now you know how you could write it
10:45:27 <iago> without libs
10:45:27 <iago> :P
10:45:32 <deeflex> hehe
10:45:51 <ski> (i.e. invent (parts of) the libs :)
10:50:00 <gwern> @seen dcoutts
10:50:01 <lambdabot> dcoutts is in #haskell-soc, #haskell-in-depth, #gentoo-haskell, #darcs, #ghc, #haskell-overflow and #haskell. I last heard dcoutts speak 15m 1s ago.
10:50:24 <gwern> dcoutts: any thoughts on my gitit issue?
10:53:19 <dcoutts> gwern: that was something with registering right?
10:53:24 <gwern> yes
10:53:39 <dcoutts> gwern: lemme try and reproduce it, gitit repo?
10:54:06 <gwern> dcoutts: although it's not just registering; no gitit-0.6.1.1 directory shows up in my ~/bin/lib either
10:54:23 <gwern> http://github.com/jgm/gitit/tree/master
10:54:35 <dcoutts> gwern: oh, is there a tarball?
10:54:42 * dcoutts doesn't have git
10:54:48 <gwern> dcoutts: hackage; I've only tested with gitit head tho
10:54:53 <dcoutts> gwern: ok
10:55:18 <dcoutts> gwern: and this is using Cabal head, using runghc Setup configure; build; install right?
10:55:25 <gwern> and also cabal-install head
10:55:47 <dcoutts> gwern: ok, so both via runghc and via cabal-install fail?
10:55:50 <gwern> yes
10:55:53 <dcoutts> 'k
10:59:42 <dcoutts> gwern: ok, running now, I'll let you know when it finishes (has to build happs etc)
11:00:05 <gwern> yeah. I'm cabal-installing the hackage version, but still am in happs
11:02:12 <conal> Beelsebob: ping
11:03:14 <Saizan> is there a portable way to get a fresh new temp directory?
11:03:52 <Saizan> one that you can use to generate some files, move them somewhere else and delete
11:03:57 <roconnor> @hoogle tempName
11:03:57 <lambdabot> No results found
11:04:04 <roconnor> @hoogle temp
11:04:04 <lambdabot> package template
11:04:04 <lambdabot> package template-haskell
11:04:04 <lambdabot> Distribution.Extension TemplateHaskell :: Extension
11:04:27 <mathijs> Hi all, I just learned a bit about phantom types. I did a first practice at http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2574#a2574 - representing valid html documents where validation is handled in the type system.  Can anyone please have a look and see if I understood the concept correctly?
11:05:09 <FunctorSalad> Saizan: there's some function to generate fresh filenames, but I don't know about getting the equivalent to /tmp
11:05:14 <sm> does the download package not cabal install on a mac ? it's complaining about missing libio.h
11:06:22 <sm> portability: posix. hmm
11:06:26 <mathijs> and furthermore: doesn't this become very verbose if more types are needed?  And how about other validation stuff like a Html document not allowing 2 head sections? Is it possible to handle that in the typesystem as well or would it be a lot clearer just to use runtime validation?
11:07:25 <dcoutts> sm: email the author
11:07:26 <Saizan> FunctorSalad: do you know where is that?
11:07:30 <sm> will do
11:07:56 <EvilTerran> makeGUID?
11:07:59 <EvilTerran> :P
11:08:09 <FunctorSalad> Saizan: http://haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html#v:openTempFile
11:08:12 <cads> hey, what's a book that lifts up through functional programming techniques, through advanced topics like monads, and up into straight category theory?
11:08:37 <EvilTerran> i don't think you'll find that in one book
11:09:17 <Saizan> FunctorSalad: an, it also creates the file, thanks anyway
11:09:21 <cads> that would be nice though
11:09:35 <gwern> dcoutts: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5606#a5606
11:09:44 <gwern> dcoutts: installed just fine, but ghc-pkg doesn't find it
11:09:54 <gwern> dcoutts: so I think the commonality here is cabal
11:10:13 <dcoutts> gwern: the files got installed ok?
11:10:21 <cads> maybe not pure category theory, but perhaps categorical programming theory
11:10:30 <gwern> dcoutts: the command was cabal install gitit-0.5.3 if it matters
11:10:37 <gwern> dcoutts: well, I don't see any error in the output...
11:11:46 <cads> I know lots of papers on functional programming for will start out with examples in haskell, create an algebraic model from there, and finally show us what that means with category theory
11:12:13 <Cale> mathijs: That seems reasonable, except that you'll end up with O(n^2) instances :)
11:13:04 <dcoutts> gwern: so gitit-0.5.3 doesn't have any library, so it's not registered.
11:13:11 <dcoutts> gwern: does the darcs version have a lib?
11:13:19 <gwern> dcoutts: alright, but what about head? it has library/executable syntax
11:13:30 <dcoutts> gwern: got a tarball of that?
11:13:31 <gwern> and head installed as a library before
11:13:36 <gwern> dcoutts: no not really
11:13:45 * dcoutts doesn't have git
11:13:46 <Cale> cads: Did I already give you Awodey's book? It's really just a book on category theory, but it touches on areas relevant to programming anyway.
11:13:46 <gwern> (what sort of distro doesn't have git packaged?)
11:14:37 <cads> Cale: lol, got an extra copy lying around?
11:14:58 <dcoutts> gwern: ok, do you have a log at -v3 for register ?
11:15:12 <Cale> Infinitely many, actually.
11:16:24 <FunctorSalad> unfold: BookStash -> (AwodeysBook,BookStash)
11:17:22 <idnar> copy :: AwodeysBook -> (AwodeysBook,AwodeysBook)
11:17:23 <dcoutts> gwern: turns out github makes tarballs
11:17:45 <gwern> oh wait. I think I just figured it out
11:17:56 <Cale> Yeah, the category for digital information has that nice diagonal map :)
11:18:26 <cads> :)
11:18:29 <idnar> I guess that's id &&& id or some nonsense
11:18:38 <Cale> :t id &&& id
11:18:39 <lambdabot> forall b. b -> (b, b)
11:18:41 <Cale> mhm
11:19:04 <idnar> I always get confused reading those arrow types in prefix form
11:19:55 <idnar> also, I feel a bit silly using arrow operators on absolutely nothing but (->)
11:21:21 <pumpkin> join (&&&) id ;)
11:21:45 <pumpkin> just to be even more gratuitous
11:21:47 <idnar> that's longer though
11:21:53 <idnar> otherwise I would have used it ;)
11:21:54 <pumpkin> it's not about length, it's about repetition!
11:21:54 <pumpkin> :P
11:21:58 <pumpkin> hrrmpf
11:21:58 <mauke> join (,)
11:22:07 <idnar> @type join (,)
11:22:08 <pumpkin> zomg, but it haz no arroz
11:22:08 <lambdabot> forall a. a -> (a, a)
11:22:11 <idnar> oh duh
11:22:12 <bavardage> dcoutts: it makes tarballs?
11:22:15 <idnar> now I just feel stupid
11:22:24 <Gracenotes> pumpkin: omg is this normal????
11:22:28 <bavardage> dcoutts: you can specify what to tar up etc?
11:22:37 <idnar> I accidentally your arrow, is this bad??
11:22:37 <dcoutts> bavardage: yep, just hit the download button
11:22:44 <bavardage> oh nice
11:24:41 <gwern> dcoutts: I feel sheepish now; turns out that the plugins flag enables gitit-as-a-library, and I had switched it in cabal to true so I couldn't forget, but somehow it got flipped back to false, and I didn't realize that a consequence of plugins=false was not just that the executable wouldn't run with my plugins, but also that no library would be built at all
11:25:02 <dcoutts> gwern: phew! :-)
11:25:21 * gwern feels a little irate. I spent at least 2 hours yesterday on this
11:25:57 <dcoutts> gwern: mm, disabling the lib does seem a bit odd, I wonder if we should warn or fail
11:26:24 <dcoutts> gwern: optionally installing a lib is quite odd, it means other things cannot properly depend on it
11:26:33 <gwern> well, if the flag sets the library's buildable to false, then presumably the developer has a reason for it
11:26:53 <gwern> but maybe if buildable is being set by a flag, a message?
11:26:57 <dcoutts> gwern: right, but it's at least as bad as optionally exposing a module
11:29:49 * cads is searching for neural net packages that use physically based neuronal models
11:29:57 <dever> hey all, i have a predefined list bugs, containing type Bug, which has a field called fixed
11:30:37 <dever> this is a silly question, but I forget :D how do I change the value of fixed in a Bug at a certain index
11:30:59 <mauke> too complicated
11:31:32 <opqdonut> there's no nice way to change a list at an index
11:31:42 <opqdonut> mainly because it's an expensive operation
11:32:39 * pumpkin eats opqdonut
11:32:48 <mauke> \i f xs -> let (p, x : q) = splitAt i xs in p ++ f x : q
11:32:52 * sbahra shows off to pumpkin 
11:32:53 <BMeph> dever: Thank you! 'Cause I get to tell you: "UR DOIN IT RONG!" ;p
11:33:54 <Gracenotes> or, for arrays, \i f xs -> xs // [(i, f (xs ! i))]
11:34:09 <dever> you've lost me BMeph :D
11:34:19 <dever> ah nevermind, I'll figure a way around it :D
11:34:51 <Gracenotes> except the entire array is copied >_> the tail end is left alone in the list version
11:35:01 <pumpkin> unless you have a DiffArray
11:35:24 <opqdonut> pumpkin: ?
11:35:27 <Gracenotes> well. DiffArrays have their own p0rblems.
11:35:35 <Gracenotes> porklems, if you will
11:35:37 <pumpkin> opqdonut: sry, wuz hungry
11:35:41 <opqdonut> ok, np
11:35:47 <BMeph> dever: Just check out mauke's and Gracenotes' stuff. Basically, if you're looking for random-access, a list is not the proper structure.
11:36:45 <Gracenotes> if changes are infrequent but accessed very much so, a plain ol' Array or UArray could do
11:36:59 <pumpkin> if it's sparse, use an IntMap
11:37:02 <Gracenotes> I mean, lots of accesses
11:37:10 <BMeph>  I blame Haskell for making lists too freaking easy to use; it makes it too uncomfortable to think to use other data structures, and encourages data structure/algorithm "impedance mismatcch". :\
11:37:32 <dever> ah, but it's for a listStore, which store lists, and its for a demo app for beginners :D, that might be too complex :D
11:38:07 <joeally> arghh typeclasses make me wanna kill my self
11:38:20 <Gracenotes> BMeph: and whatnot with deforestation. *gazes at GHC dreamily*
11:38:24 <joeally> I have a function
11:38:31 <joeally> sflush s you tab pls
11:38:31 <joeally> 	|length tab == 3 = if scount s (you++tab) < 3 then 0 else 2*(2/(52-total))*(1/(51-total))
11:38:31 <joeally> 	|length tab == 4 = if scount s (you++tab) < 4 then 0 else 1/(52-total)
11:38:31 <joeally> 	|otherwise = 0
11:38:31 <joeally> 	where total = length tab + 2*pls
11:38:34 <BMeph> joeally: And a cheery good afternoon to you, too! ;)
11:38:38 <joeally> lol
11:38:48 <joeally> hello anyway
11:39:02 <Gracenotes> hm. Pretty printing library time? :)
11:39:24 <joeally> Possible fix: add an instance declaration for (Fractional Int)
11:39:28 <joeally> what does this mean
11:40:26 <Gracenotes> the error is due to the fact that '/' is meant for non-integer division. with Floats and Doubles and the like
11:41:06 <BMeph> joeally: That's an easy one - length <list> returns an Int, but '/' needs two Fractional arguments. It's complaining that Int is not a Fractional type. :)
11:41:43 <Cale> joeally: The numeric typeclass hierarchy takes some getting used to.
11:42:23 <joeally> oh
11:42:37 <joeally> BMeph
11:42:54 <joeally> how can i convert the values to fractional
11:42:59 <BMeph> Are there any PLs out there where dependent typing isn't a big PITA? :(
11:43:03 <hatds> fromIntegral, usually
11:43:09 <joeally> when i did that
11:43:15 <BMeph> joeally: hatds got it. :)
11:43:17 <joeally> it complained that i inffered int
11:43:44 <BMeph> joeally: Try "total = fromIntegral (... )" :)
11:43:53 <joeally> ok
11:43:56 <joeally> thanks
11:44:32 * BMeph gives joeally a cyber-"Thumbs Up" :)
11:44:40 <joeally> thanks
11:44:44 <joeally> thumbs up
11:44:49 <joeally> it compiled
11:45:01 <BMeph> Usually a good sign. ;)
11:45:12 <joeally> types and typeclasses really confuse me
11:45:46 <joeally> thankyou
11:46:06 <BMeph> joeally: It helps if you pretend that Haskell grew up in an Alternate Universe where OOP was never invented. ;)
11:46:07 <joeally> the function worked
11:46:14 <gio123> is here anybody from germany?
11:46:18 <ray> bmeph: it did
11:46:37 <joeally> I'm just used to working in dynamically typed languages
11:48:01 <ray> probably used to speaking them too
11:48:49 <BMeph> joeally: Yeah, "dynamically-typed" systems are reasonably good in cases where what you're doing isn't too different from what's been done already. When you want to do things that need careful thought about the types, all that dynamicity tends to bite you on the butt. It's an nteresting CS dilemma. :)
11:50:06 <gio123> is here anybody from germany?
11:50:11 <joeally> BMeph: I like haskell but i get a type error every time i compile
11:50:40 <joeally> occasionally i feel like giving up on it
11:50:40 <mauke> gio123: yes
11:50:47 <BMeph> ray: Actually, I think of this universe as one where OOP was strangled in the crib and replaced with a cuckoo paradigm. -- Whoa, that's a heady mix of metaphors. :)
11:51:24 <gio123> mauke: may i pm?
11:53:26 <hatds> when learning haskell, typeclasses are less confusing if you don't try to puzzle out typeclass design patterns right away.  The more important part is usually "what built types have what useful instances?"
11:53:38 <hatds> *built in types
11:55:50 <erikc> does anyone know of a language which is statically typed with type inference, but uses a lisp/smalltalk-style image paradigm (it'd have to treat run-time code changes as a transaction that is rejected if the program no longer type checks)
11:57:00 <hatds> haskell in N years maybe? :)
11:57:27 <p_l> erikc: very very early haskell systems? (heard one of the first implementations was running inside CL)
11:57:50 <BMeph> I wonder if augustss knows... :)
11:58:03 <augustss> huh? what?
11:58:17 <dever> ahh, I can just work off the listContained with in the listStore, and I can dynamically change that
11:58:20 <dever> huzzah
11:58:30 <dever> -1 for me, for looking at old documentation
11:59:15 <augustss> erikc, p_l, BMeph: the Yale Haskell system was written in List (T to be exact), and had many of the typical List system features.
11:59:38 <augustss> It's probably the the best interactive Haskell there has been.
11:59:50 <augustss> s/List/Lisp/
11:59:56 <joeally> can you have 2 where clauses in one function?
12:00:20 <erikc> interesting, will check it out
12:00:30 <augustss> joeally: no, but you can define more than one thing in a where clause
12:00:36 <joeally> okay
12:00:52 <joeally> augustss:  how would you do that?
12:01:04 <hatds> wait, where only scopes over one function equation right?
12:01:12 <augustss> f x = y where y = x+z; z = x+2
12:01:20 <joeally> thanks
12:01:35 <augustss> hatds: yes
12:01:50 <augustss> so you can have one where per clause
12:01:53 <hatds> ok but that's not what he was asking yea
12:01:55 <hatds> :)
12:02:08 <augustss> i'm not totally sure what he was asking :)
12:03:03 <ski> joeally : you can have nested `where'-clauses, though ..
12:03:06 <BMeph> joeally: Could you (h)paste something, just so we can ge sure what you're looking for? :)
12:03:10 <skorpan> he asked whether you can have two where clauses in one function :P
12:03:23 <joeally> No its fine
12:03:30 <Hunner> Your monad can have two where clauses in one function.
12:03:31 <joeally> Augussts helped
12:03:41 <joeally> BMeph: but thanks anyway
12:03:44 <skorpan> Hunner?
12:03:50 <augustss> I answered the question I thought he should be asking ;)
12:03:52 <Hunner> Nothing.
12:04:03 <BMeph> I think I use two where clauses to define my prime factorization function.
12:04:15 <joeally> oh
12:05:13 <BMeph> Hmm, looks like I refactored the thing to use just one, now. Silly fussy me. ;p
12:06:35 <ski> > let rember_up_to_last a0 = set where set as0 = loop as0 where loop [] = as0; loop (a:as) | a0 == a = set as | otherwise = loop as in rember_up_to_last 'c' "abcegcbda"  -- nested `where'-clauses
12:06:37 <lambdabot>   "bda"
12:07:13 <Cale> joeally: Just to be clear, the ; in augustss' example can also be replaced by a newline and appropriate indentation :)
12:07:35 <joeally> Cale:yes i figured but thanks anyway
12:07:54 <joeally> anyone know a good algorithm for finding the mode
12:08:07 <joeally> of a list
12:08:29 <gwern> augustss: so... haskell is not good for implementing interactive haskell?
12:08:45 <augustss> gwern: Who said that?
12:08:50 <augustss> Not me.
12:09:04 <gwern> augustss: you just said that the best interactive haskell system was not written in haskell
12:09:06 <Cale> joeally: group . sort is a good start, perhaps.
12:09:18 <joeally> okay
12:09:19 <joeally> thanks
12:09:26 <augustss> gwern: yeah, but that doesn't imply that Haskell isn't good for it
12:09:30 <BMeph> joeally: ...never mind, I forget, Cale's here. ;)
12:09:50 <augustss> gwern: Yale Haskell was written in the days when there were no Haskell compilers at all, really
12:09:50 <gwern> augustss: dunno, sounds like that was a long time ago, and there've been many haskell implementations since then
12:09:58 <Cale> joeally: Then map a function like (\xs -> (length xs, xs)) over that, and use maximumBy
12:10:24 <augustss> gwern: A sucky user interface cannot be blamed on the implementation language.
12:10:28 * ski . o O ( graph length )
12:10:36 <Cale> > maximumBy (comparing fst) . map (length &&& id) . group . sort $ "abracadabra"
12:10:37 <lambdabot>   (5,"aaaaa")
12:10:38 <gwern> that certainly seems to me to suggest that the 2 commonalities of the later implementations - not being so hot interactively and being written in haskell - are linked
12:10:50 <Cale> > head . snd . maximumBy (comparing fst) . map (length &&& id) . group . sort $ "abracadabra"
12:10:51 <lambdabot>   'a'
12:11:12 <gwern> and having looked at ghci's source quite a bit, it strikes me as rather ugly, and I wonder how much of the contortions are due to haskell
12:13:02 <augustss> gwern: I don't see why the ghc machinery couldn't be used for a nice interactive system.  All the hooks are there, AFAIK.
12:13:13 <gwern> beware the turing tarpit...
12:14:19 <Cale> joeally: Note that while you could use maximumBy (comparing length), it would recompute the lengths of the lists on each comparison, which would be inefficient
12:14:41 <augustss> gwern: I've not tried Leksah much, but it seems like a pretty cool IDE.
12:15:01 <Gracenotes> Cale: but -- CSE! WooOOooOOooOOooooOO *creepy ghost sounds*
12:15:37 <Gracenotes> (okay, not quite CSE)
12:15:41 <augustss> Gracenotes: that would be some kind of dynamic CSE, ghc doesn't even do much of static cse
12:15:59 <Gracenotes> yeah
12:19:58 <skorpan> FITT
12:20:02 <skorpan> oops wrong channel
12:22:54 <roconnor> Forum for International Trade Training?
12:24:50 <skorpan> no, a swedish cuss word
12:24:56 <skorpan> at least part of it
12:38:28 <voker57__> how to get current UNIX time?
12:38:57 <voker57__> or any other format of date/time
12:39:38 <Cale> :t Data.Time.Clock.getCurrentTime
12:39:39 <lambdabot> IO time-1.1.3:Data.Time.Clock.UTC.UTCTime
12:45:02 <voker57__> and any way to get it in nanoseconds? or measure intervals in them?
12:45:16 <voker57__> or msecs either
12:45:46 <Cale> voker57__: That time is potentially as precise as picoseconds.
12:46:05 <idnar> "time-1.1.3:Data.Time.Clock.UTC.UTCTime" is valid syntax?
12:46:31 <voker57__> Cale: picoseconds are ok too
13:03:02 * shapr boings very quietly
13:03:13 <shapr> it's oh so quiet...
13:04:02 <sm> *hello shapr*
13:04:03 <shapr> it's oh so still...
13:04:05 <shapr> hiya sm!
13:04:06 <shapr> How's code?
13:04:09 <sm> *shh!*
13:04:12 <shapr> oh, sorry
13:04:13 <sm> good thanks!
13:04:17 <sm> *good*
13:04:33 * shapr whispers unintelligibly
13:04:37 <sm> *fixed up rss2irc this morning. how's yourself ?*
13:04:52 <shapr> Writin C# for work, not so thrilling.
13:05:08 <sm> urgh.. php work here
13:05:09 <shapr> I think Yaquishael is having connection problems.
13:05:24 <sm> I'm grateful for it, but it's a mental battle
13:05:39 <shapr> I've been playing with the gtk2hs cairo bindings a bit, but not done anything useful.
13:06:16 --- mode: ChanServ set +o mauke
13:06:17 --- mode: mauke set +b Yaquishael!*@*
13:07:17 --- mode: mauke set -o mauke
13:13:26 <lysgaard> I want to: "map ( - 0.02) [0.01, 0.04]" how?
13:13:42 <mauke> subtract 0.02
13:14:02 <lysgaard> Kidding, is that the problem?
13:14:11 <skorpan> it is
13:14:16 <skorpan> :t (-)
13:14:17 <lambdabot> forall a. (Num a) => a -> a -> a
13:14:25 <skorpan> as you can see, it is a binary operator
13:15:03 <lysgaard> Yup, and what's the problem with that, shouldn't currying make it happen?
13:15:13 <mauke> - is evil magic
13:15:20 <mauke> that is, it's also a unary operator
13:15:33 <lysgaard> Ah, like negate?
13:15:37 <mauke> exactly
13:15:40 <mauke> > map (subtract 0.02) [0.01, 0.04]
13:15:41 <lambdabot>   [-1.0e-2,2.0e-2]
13:15:41 <lysgaard> Evil!
13:16:17 <lysgaard> >:t subtract
13:16:36 <johnbs> does anyone have a copy of Johnsson's "Analysing heap contents in a graph reduction intermediate language" paper?  google hasn't been able to find it for me :/
13:16:40 <lysgaard> How do i use lambdabot?
13:16:52 <mauke> :t subtract
13:16:53 <lambdabot> forall a. (Num a) => a -> a -> a
13:17:04 <lysgaard> :t subtract
13:17:05 <lambdabot> forall a. (Num a) => a -> a -> a
13:17:13 <EvilTerran> lysgaard, well, you can talk to her in private message or in any channel she's in
13:17:18 <EvilTerran> @help
13:17:18 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
13:17:20 <lysgaard> just enter an parsable expresion
13:17:22 <EvilTerran> is a good place to start
13:17:42 <lysgaard> list
13:17:48 <lysgaard> help list
13:17:51 <byorgey> @list
13:17:51 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
13:18:00 <lysgaard> @help
13:18:00 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
13:18:03 <lysgaard> ah
13:18:10 <lysgaard> @list
13:18:10 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
13:18:38 <EvilTerran>  ? and @ work interchangably - i guess if one may be more convenient than the other, depending on your keyboard layour
13:30:16 <Boxo> @pl \a b -> a+b
13:30:16 <lambdabot> (+)
13:30:24 <Boxo> @pl map
13:30:24 <lambdabot> map
13:38:00 <augustss> @pl pl
13:38:01 <lambdabot> pl
13:47:12 <Athas> What's the Main.CAF cost centre?
13:50:32 <hatds> top level things in module Main that only need to be evaluated once
13:53:07 <Athas> Yes, I see.  Apparently my stack overflow comes from there.  Ah well, I'll compile with -caf-all and see if I get some more descriptive information...
13:54:01 <Athas> Oh my.
13:54:12 <hackagebot> Added by UweHollerbach, Sat Jun  6 20:52:03 UTC 2009.: A small scheme interpreter  http://hackage.haskell.org/cgi-bin/hackage-scripts/package/haskeem-0.7.0
13:55:15 <Athas> Yes!  I have narrowed it down!
13:55:38 <byorgey> woah, hackagebot gives summaries now!
13:56:05 <byorgey> I wonder who added that, I should like to give them some karma points
13:56:07 <sm> sure does, I've been fixing it up this morning
13:56:14 <byorgey> sm++
13:56:21 <sm> why thank you :)
13:56:32 <ehird> Does the prelude have rationals?
13:56:59 <byorgey> ehird: depends what you mean by 'the prelude', but Data.Ratio comes in the base package
13:57:18 <ehird> thanks
13:57:22 <byorgey> > 1 / 3 :: Rational
13:57:23 <lambdabot>   1 % 3
13:57:39 <Athas> It appears that Data.Array.MArray.getElems is a very dangerous function.
13:58:06 <hatds> ?
13:58:15 <Athas> Uses large amounts of stack space.
13:58:27 <Athas> Or maybe my use of it was naive.
13:58:32 <Jedai> :t Data.Array.MArray.getElems
13:58:33 <lambdabot> forall (a :: * -> * -> *) i e (m :: * -> *). (Data.Array.Base.MArray a e m, Ix i) => a i e -> m [e]
13:58:40 <hatds> it will construct the list all at once
13:58:46 <hatds> I think
13:58:53 <Athas> Perhaps it is newListArray that is dangerous.
13:58:55 <hatds> (well otherwise it'd be unsafe ;P)
13:59:17 <Jedai> Athas: Well, you're right, getElems is not very nice
13:59:43 <Athas> My program died when trying to juggle multi-megabyte arrays.
14:00:02 <Jedai> Athas: since it has to construct the whole list in memory, in contrasts of elems for the persistent arrays
14:00:23 <ehird> byorgey: how can I convert a Rational to another numeric type?
14:00:24 <Jedai> Athas: you can easily inverse the logic though, probably
14:00:35 <Jedai> Athas: what were you trying to do ?
14:00:37 <Athas> Jedai: I could live with that, but my program crashed with a stack overflow, not heap space exhaustion.
14:00:41 <Athas> Copy an array.
14:00:48 <byorgey> @type fromRational
14:00:50 <lambdabot> forall a. (Fractional a) => Rational -> a
14:00:53 <ehird> ah, thanks
14:00:56 <hatds> freeze/thaw will copy
14:01:03 <uzytkownik> Is there any flip3 or something like that [(a -> b -> c -> d) -> c -> a -> b -> d]?
14:01:40 <Jedai> uzytkownik: no, you can write it yourself if you really need it
14:01:52 <Athas> I do a mapArray with the identity function now.
14:01:54 <Athas> Seems to work nicely.
14:01:59 <uzytkownik> Jedai: Thanks
14:02:02 <Jedai> uzytkownik: but beware the fact that sometimes pointfree becomes pointless
14:02:35 <ehird> byorgey: so what would I use to detect if a rational is an integer or not?
14:02:38 <ehird> (??? . fromRational)?
14:02:49 <Jedai> Athas: it should, anyway "getElems >>= newListArray bounds" isn't a good solution at all !
14:03:15 <uzytkownik> Jedai: Do you refere to (.) :: (b -> c) -> (a -> b) -> a -> c?
14:03:18 <Jedai> ehird: (==1) . denominator
14:03:24 <ehird> ah, thanks
14:03:39 <hatds> better check the convention on the sign
14:03:43 <hatds> ?
14:04:22 <augustss> @pl \ f x1 x2 -> x1 >>= \ y1 -> x2 >>= \ y2 -> f y1 y2
14:04:23 <lambdabot> flip ((.) . (>>=)) . flip ((.) . (>>=))
14:04:28 <augustss> Yuck
14:04:32 <Jedai> uzytkownik: pointfree programming is a style that try to avoid points (arguments) in its expression, it prefer to use combination of function with operator (such as (.), function composition)
14:04:51 <byorgey> > denominator (-1 / 3)
14:04:53 <lambdabot>   3
14:04:53 <augustss> Is there two argument bind hidden away in a library somewhere?
14:04:57 <byorgey> > denominator (1 / -3)
14:04:59 <lambdabot>   Precedence parsing error
14:04:59 <lambdabot>      cannot mix `GHC.Real./' [infixl 7] and prefix...
14:05:05 <byorgey> > denominator (1 / (-3))
14:05:06 <lambdabot>   3
14:05:17 <byorgey> as I thought, the denominator is always positive.
14:05:28 <Jedai> uzytkownik: flip is one the tools that allows to do pointfree programming by replacing "(\x y -> f y x)" by "flip f"
14:06:04 <uzytkownik> Jedai: Thanks. So basically pointfree programs uses points ;)
14:06:35 <Jedai> uzytkownik: but while pointfree programming is considered elegant by a large part of the Haskell programmers, it can easily be pushed beyond its usefulness and in pointless territory
14:06:52 <Jedai> uzytkownik: yes, pointfree programming use a lot of points !!
14:07:37 <ClaudiusMaximus> @djinn (a -> b -> c -> d) -> c -> a -> b -> d
14:07:38 <lambdabot> f a b c d = a c d b
14:07:45 <Jedai> uzytkownik: lambdabot has a command @pl to transform a lambda expression into a pointfree expression, the result is sometimes comic
14:08:05 <BMeph> uzy: Try flip . (flip .)
14:08:20 <BMeph> @ty flip . (flip .)
14:08:21 <lambdabot> forall a a1 b c. (a -> a1 -> b -> c) -> b -> a -> a1 -> c
14:08:36 <BMeph> Good, got that right. :)
14:09:37 <ehird> @hoogle Double -> Integer
14:09:37 <lambdabot> Prelude floatRadix :: RealFloat a => a -> Integer
14:09:37 <lambdabot> Prelude ceiling :: (RealFrac a, Integral b) => a -> b
14:09:37 <lambdabot> Prelude floor :: (RealFrac a, Integral b) => a -> b
14:09:59 <malouin> is there an curry ((a, b, c) -> d) -> a -> b -> c -> d?
14:10:39 <aavogt> @type curry . curry
14:10:40 <lambdabot> forall a b b1 c. (((a, b), b1) -> c) -> a -> b -> b1 -> c
14:10:48 <pumpkin> @hoogle curry3
14:10:49 <lambdabot> No results found
14:10:50 <pumpkin> :(
14:11:09 <aavogt> @type curry . curry . curry
14:11:10 <lambdabot> forall a b b1 b2 c. ((((a, b), b1), b2) -> c) -> a -> b -> b1 -> b2 -> c
14:11:28 <aavogt> what's bad about nested tuples?
14:12:22 <ehird> byorgey: ehm, is there an easy way to get an Integer out of a known-denominator-1 Rational?
14:12:27 <ehird> as opposed to going through Fractional
14:12:47 <Jedai> ehird: numerator obviouly
14:13:03 <ehird> oh, god
14:13:05 <ehird> I'm stupid
14:13:05 <ehird> >_<
14:13:13 <Jedai> ehird: tired I suspect ;)
14:13:14 <aavogt> or pattern match the Ratio constructor
14:13:19 <ehird> Jedai: headache :<
14:13:25 <ehird> aavogt: is that OK?
14:13:48 <Jedai> aavogt: not a very good idea, I'm not sure its possible
14:14:13 <aavogt> hmm, the constructor is GHC.Real.:%
14:14:34 <aavogt> which appears hidden
14:14:41 <Jedai> aavogt: Yep, Ratio is abstract (ok, you can find it in the entrail of GHC...)
14:14:43 <aavogt> ehird: it won't work either
14:15:45 <malouin> Ok, here's a better question...
14:15:47 <malouin> http://hpaste.org/view?id=5611#a5611
14:15:51 <malouin> how do I get rid of mkHandler
14:17:02 <Jedai> ehird: You can also use properFraction and check the reminder is 0
14:17:09 <ehird> :t properFraction
14:17:10 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> (b, a)
14:17:16 <ehird> Could work.
14:17:30 <ehird> malouin: write it like this:
14:17:42 <ehird> handlers = [Handler [GET] [""]] handleDefault, Handler [GET] ["foo"] handlePost]]
14:18:21 <malouin> ehird: ok, that's one way, but Handler is dupicated
14:18:33 <johnbs> unzip3 . zipWith3
14:18:45 <ehird> malouin: erm
14:18:48 <ehird> nothing you can do then
14:19:08 <aavogt> malouin: or define uncurry3 elsewhere, I'm sure anybody reading it can guess what it does
14:19:20 <malouin> ok.
14:19:39 <aavogt> erm, curry3
14:20:28 <BMeph> Just curious, but why do you want to get rid of it? It looks like it's where it ought to be. ;)
14:23:26 <malouin> BMeph: good point
14:23:41 * aavogt made an incorrect correction there :(
14:24:17 <malouin> aavogt: well, I asked about curry earlier when I really needed uncurry
14:24:35 * malouin confused matters
14:24:56 <ehird> xs@(x:xs') -- any better names for these?
14:25:23 <aavogt> ehird: what's so bad about head and tail?
14:25:28 <ehird> True.
14:26:26 <aavogt> > (\xs@(x:xs') -> "and you might need lazy pattern matching too") []
14:26:26 <byorgey> ehird: I often use  xxs@(x:xs)
14:26:27 <lambdabot>   "* Exception: <interactive>:1:134-194: Non-exhaustive patterns in lambda
14:26:55 <aavogt> > (\xs@ ~(x:xs') -> "") []
14:26:55 <lambdabot>   ""
14:27:56 <Nereid_> @pl \x y -> map (x:) y
14:27:56 <lambdabot> map . (:)
14:28:01 <Nereid_> heh
14:28:45 <aavogt> @type map . flip (:)
14:28:45 <lambdabot> forall a. [a] -> [a] -> [[a]]
14:30:39 <Nereid_> @pl \a b -> zipWith (\x y -> map (x:) y) a b
14:30:39 <lambdabot> zipWith (map . (:))
14:30:53 <Nereid_> so nothing better I guess
14:41:05 <mmorrow> @type let f <!> a = join (f <*> a); infixr 1 <!> in \f a b c d -> f <$> a <*> b <*> c <!> d
14:41:07 <lambdabot> forall a a1 a2 a3 (m :: * -> *) a4. (Applicative m, Monad m) => (a -> a1 -> a2 -> a3 -> m a4) -> m a -> m a1 -> m a2 -> m a3 -> m a4
14:41:19 <mmorrow> @type let f <!> a = join (f <*> a); infixr 1 <!> in \f a b -> f <$> a <!> b
14:41:21 <lambdabot> forall a a1 (m :: * -> *) a2. (Applicative m, Monad m) => (a -> a1 -> m a2) -> m a -> m a1 -> m a2
14:42:11 <mmorrow> augustss: that (<!>) seems nice for bindN
14:42:45 <pumpkin> :o
14:42:59 <augustss> mmorrow: that would do :)
14:43:27 <augustss> I've wanted bindN several times now, I'm surprised nobody else has complained
14:43:58 <mmorrow> i always just accept defeat and use do .. :/
14:44:01 <mmorrow> but no more!
14:44:19 <augustss> I define bind2 :)
14:44:22 <mmorrow> heh
14:44:25 <aavogt> @type \f y -> join (f `ap` y)
14:44:26 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => m (a -> m a1) -> m a -> m a1
14:44:42 <ehird> @hoogle (Eq a) => a -> a -> b -> b -> b
14:44:42 <lambdabot> Data.Generics.Basics gfoldl :: Data a => c (a -> b) -> a -> c b -> g -> c g -> a -> c a
14:44:42 <lambdabot> Control.Exception catchJust :: Exception -> Maybe b -> IO a -> b -> IO a -> IO a
14:44:42 <lambdabot> Control.Exception bracket :: IO a -> a -> IO b -> a -> IO c -> IO c
14:45:55 <BMeph> I keep getting stuck with describing the relationship between 'ap' and 'flip bind'. :)
14:49:24 <hackagebot> Added by BjornBuckwalter, Sat Jun  6 21:48:34 UTC 2009.: Type-level (low cardinality) integers.  http://hackage.haskell.org/cgi-bin/hackage-scripts/package/numtype-1.0
14:49:24 <hackagebot> Added by BjornBuckwalter, Sat Jun  6 21:49:09 UTC 2009.: Statically checked physical dimensions.  http://hackage.haskell.org/cgi-bin/hackage-scripts/package/dimensional-0.8
14:49:26 <augustss> :t ap
14:49:27 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
14:49:33 <augustss> :t flip bind
14:49:34 <lambdabot> Not in scope: `bind'
14:49:47 <augustss> :t flip (>>=)
14:49:48 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> m a -> m b
14:50:02 <augustss> random permutations of letters
14:50:53 <BMeph> augustss: :)
14:51:26 <BMeph> For some reason, it reminds me of the strength property, but not quite. :)
14:59:54 <dever> hey all I'm having a problem with an event handler in gtk2hs... can anyone take a look at it, and maybe point me in the right direction???
14:59:57 <dever> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5613#a5613
15:00:41 <dever> this is the error im getting: Couldn't match expected type `Control.Monad.Reader.ReaderT
15:00:44 <dever>                                     (GHC.Ptr.Ptr Graphics.UI.Gtk.Gdk.EventM.EExpose) IO a'
15:00:47 <dever>            against inferred type `IO Bool'
15:00:50 <dever> oops
15:05:03 <dever> no? :(
15:07:47 <dmwit> dever: Still around?
15:08:42 <timmaxw> what's the best way to annotate tree structures or other data types with arbitrary data?
15:08:46 <timmaxw> i basically know of two approaches:
15:08:58 <timmaxw> one is to annotate using a map from paths into the data structure -> annotation data
15:09:10 <timmaxw> the other is to make the data structure type parametric on the annotations
15:09:12 <timmaxw> thoughts?
15:09:36 <timmaxw> for example, with data Expr = Add Expr Expr | Mul Expr Expr | Constant Int
15:09:57 <timmaxw> the first approach would be data Annotation a = Annotation (Map [Int] a)
15:10:07 <dever> dmwit, yep still here mate
15:10:14 <timmaxw> and the second would be data Expr a = Add a (Expr a) (Expr a) | Mul a (Expr a) (Expr a) | Constant a Int
15:10:19 <timmaxw> has anybody here done either one before?
15:10:25 <dmwit> dever: You have to lift all your IO actions into the ReaderT IO monad.
15:10:47 <dmwit> dever: e.g. liftIO $ widgetGetStyle drawingArea
15:10:59 <dmwit> dever: Or, just
15:11:12 <dmwit> on drawingArea exposeEvent . liftIO $ drawingAreaExpose drawingArea window
15:11:20 <dmwit> (if you don't plan on using the Event at all)
15:12:04 <dever> ah, ok, I shall go have a look at that, thanks dmwit!
15:12:37 <mmorrow> timmaxw: if you have a way to bind vars in your Expr type, you can have a (Map Id info) (but that only lets you annotate expressions bound to vars..)
15:13:17 <mmorrow> Let Id Exp Exp
15:13:30 <mmorrow> Let [(Id,Exp)] Exp
15:13:45 <dmwit> Having separate annotations seems awfully delicate.
15:13:56 <dmwit> I would prefer having annotations right in the data type, I think.
15:14:10 <timmaxw> i prefer that solution too
15:14:20 <timmaxw> i suppose you might even make them recursive:
15:14:37 <timmaxw> type ExprWithSourcePos a = Expr (SourcePos, a)
15:14:54 <timmaxw> (is it legal to construct parametric types with 'type'?)
15:15:04 <dmwit> you bet
15:15:41 <mmorrow> newtype MuExp a = MuExp (Exp (Either a (MuExp a)))
15:16:30 <timmaxw> 'an expression either annotated with a value or another expression'?
15:16:37 <ClaudiusMaximus> is it allowed to mix  "> haskell" with "\\begin{code}\nhaskell\n\\end{code}" in .lhs files?
15:16:59 <mmorrow> (also, if you have your data separate in a Map, and store the /keys/ in the datatype and not the data itself, then you don't have to traverse the Exp to map over the data)
15:17:19 <aavogt> ClaudiusMaximus: it could work, the haskell 98 report doesn't recomend it
15:17:21 <timmaxw> true. but then you need a key generator
15:17:25 <timmaxw> also, you could do both
15:17:28 <mmorrow> State Int a
15:17:34 <timmaxw> (Expr Int) with Map Int a
15:17:39 <mmorrow> totally
15:18:00 <timmaxw> what's the purpose of your MuExp?
15:18:01 <mmorrow> data Env a = Env {uniq :: Int, infoEnv :: IntMap a}
15:18:19 <mmorrow> type M info a = State (Env info) a
15:18:20 <timmaxw> a bit of a pain to pass around
15:18:49 <timmaxw> (!) :: Env a -> Int -> a
15:18:51 <mmorrow> yeah it is, but considering the alternatives it's bearable (imo)
15:19:06 <timmaxw> (<<) :: Env a -> a -> (Int, Env a)
15:19:09 <timmaxw> for insertion
15:19:39 <timmaxw> i think i like annotated trees better... anyway, i'm going to find out how well they work first-hand
15:19:39 <dmwit> Yeah, I use (<<) for insertion all the time.
15:19:46 <dmwit> Oh, god, I'm so immature.
15:20:11 <dever> hey dmwit, I tried that, but its now yielding another error im not sure about? could you take a look please?? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5613#a5614
15:20:49 <ClaudiusMaximus> here's the really weird error i get sometimes when mixing > with \begin{code} :  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5615#a5615
15:21:08 <mmorrow> timmaxw: oh, the MuExp was just messing around :)
15:21:45 <mmorrow> timmaxw: (but i'm sure there's a few cool things you could do with it)
15:21:59 <mmorrow> ((i haven't a clue off the top of my head though ;))
15:22:17 <dmwit> dever: You don't draw on drawing areas.
15:22:33 <dmwit> dever: You draw on DrawWindow's, which you can get from a drawing area.
15:22:38 <dmwit> It's confusing, I know.
15:22:40 <mmorrow> , let ntimes n = foldr (.) id . replicate n in ntimes 8 (braces . parens . brackets) (int 42)
15:22:43 <lunabot>  {([{([{([{([{([{([{([{([42])}])}])}])}])}])}])}])}
15:22:48 <dever> :0
15:22:58 <timmaxw> well, here's a problem with annotated trees:
15:23:01 <timmaxw> it's hard to derive Show
15:23:09 <timmaxw> unless you require the annotations to be Show-able
15:23:13 <dever> thanks dmwit, it is fairly confusing lol, my first attempt a graphicy stuff with gtk2hs
15:23:21 <dever> well drawing stuff
15:23:31 <dmwit> dever: See drawingAreaGetDrawWindow in Graphics.UI.Gtk,Misc.DrawingArea
15:23:36 <dmwit> s/,/./
15:23:37 <mmorrow> you should be able to derive Show though, and it'll only work for when the annotation type is an inst of Show
15:23:54 <mmorrow> (or do you mean something else?)
15:24:08 <timmaxw> i was assuming the compiler would complain because it couldn't prove the annotation was showable
15:24:26 <timmaxw> do you mean it will produce the equivalent of instance (Show a) => Show (Expr a)?
15:24:28 <dino-> dmwit: Would you then get a gc using that DrawWindow?
15:24:31 <mmorrow> timmaxw: ah, it'll just stick a (Show a) constraint o
15:24:34 <mmorrow> timmaxw: exactly
15:24:37 <timmaxw> awesome :D
15:25:01 <dmwit> dino-: Dunno, I've only ever done Cairo drawing, never Gtk drawing.
15:25:24 <dmwit> dino-: But presumably yes.
15:25:45 <mmorrow> timmaxw: (also, you could make your (Exp a) and instance of Functor and be able to fmap over all the `a's nicely)
15:26:01 <timmaxw> i wonder if that's derivable
15:26:07 <timmaxw> i bet not yet
15:26:30 <dever> ah dmwit, I see call the exposeEvent on the DrawWindow?
15:27:20 <dmwit> I suppose that's possible.e
15:27:40 <dmwit> There should be nothing wrong with handling expose events on its ancestors, either, though.
15:28:52 <dever> well then I am absolutely lost with this :D
15:29:07 <dever> someone should write a book on graphics with gtk2hs :D
15:29:19 <timmaxw> oh sweet, somebody gave GHC the ability to derive Functor back in February
15:29:29 <dmwit> The tutorials for Gtk2 are good, and easily translated into gtk2hs.
15:29:51 <dever> yeah, Im trying to translate gtk-demo to gtk2hs atm
15:30:37 <dmwit> You've got to be a little bit careful with gtk2hs' own tutorials, though; it's undergone some fairly major changes recently.
15:33:43 <dever> yeah I know that too, I was planning on updating the tutorials too. It all changed midway through doing the file manager! Perfect timing for changes... two/three weeks before I had to demo it!
15:40:29 <ClaudiusMaximus> > let primitive = 0 in primitive
15:40:30 <lambdabot>   0
15:40:40 <ClaudiusMaximus> hmm, hugs spits out an error at that
15:40:48 <ClaudiusMaximus> ERROR - Syntax error in expression (unexpected keyword "primitive")
15:40:55 <timmaxw> > let {a=1:b; b=1:a} in a
15:40:57 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
15:41:03 <timmaxw> wow, it's sort of smart
15:41:31 <mauke> > let a = 1 : a in a
15:41:32 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
15:41:45 <mauke> > repeat 1
15:41:46 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
15:41:58 <timmaxw> > let {a=1:b; b=2:c; c=3:a} in a
15:41:59 <lambdabot>   [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,...
15:42:10 <mauke> > cycle [1,2,3]
15:42:11 <lambdabot>   [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,...
15:42:14 <timmaxw> oh snap
15:42:15 <ClaudiusMaximus> can't seem to find where keyword "primitive" is defined in the report, doesn't help that with my browser settings the majority of the text is white on white
15:42:23 <pjdell> anyone that could help me figure out a good way to do port forwarding on a netowrk with a qwest modem and a linksys router?
15:42:30 <mauke> ClaudiusMaximus: it's probably a hugs extension
15:42:41 <mauke> pjdell: how is that a haskell question?
15:42:57 <twanvl> ClaudiusMaximus: are you running "hugs -98"?
15:43:08 <ClaudiusMaximus> twanvl: no
15:43:16 <timmaxw> >[1..]
15:43:26 <timmaxw> > [1..]
15:43:27 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
15:43:40 <timmaxw> > [100..]
15:43:42 <lambdabot>   [100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,11...
15:43:50 <ClaudiusMaximus> twanvl: same effect with hugs, hugs +98, hugs -98
15:44:20 <timmaxw> maybe it's a layout issue
15:44:41 <timmaxw> try 'let {primitive = 1} in primitive'
15:44:56 <ClaudiusMaximus> i just noticed it because my syntax highlighter turned 'primitive' bold dark blue
15:45:10 <mmorrow> , fix ((h::Expr->Expr) . (g::Expr->Expr) . f)
15:45:13 <lunabot>  h (g (f (h (g (f (h (g (f (h (g (f (h (g (f (h (g (f (h (g (f (h (g (f (h...
15:45:34 <uzytkownik> How to search and replace a longer string in Haskell? For example replace te with hy in test?
15:46:18 <timmaxw> 'primitive' does not appear as a keyword in the Haskell 98 report
15:47:12 <Botje> uzytkownik: what do you have so far?
15:47:24 <uzytkownik> Botje: Ie?
15:47:58 <uzytkownik> Botje: I need basicly a replace function
15:48:03 <Botje> so write it ?
15:48:08 <Botje> you could use Text.Regex
15:48:19 <Botje> or Data.List.Split
15:48:38 <ClaudiusMaximus> :t isPrefixOf
15:48:39 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
15:48:51 <ClaudiusMaximus> might be useful for rolling your own
15:49:09 <mmorrow> @let f <!> a = join (f <*> a)
15:49:11 <lambdabot>  Defined.
15:49:22 <mmorrow> oh crap
15:49:55 <mmorrow> @undefine
15:50:03 <mmorrow> > (<!>)
15:50:05 <lambdabot>   Not in scope: `<!>'
15:50:17 <mmorrow> @let f <!> a = join (f <*> a); infixr 1 <!>
15:50:18 <lambdabot>  Defined.
15:50:24 <Botje> :t (<!>)
15:50:25 <lambdabot> forall (m :: * -> *) a a1. (Applicative m, Monad m) => m (a -> m a1) -> m a -> m a1
15:50:34 <uzytkownik> Botje: It's rather basic function so is in standard. I'll look on Data.List.Split
15:50:43 <mmorrow> @type \f a b c d -> f <$> a <*> b <*> c <!> d
15:50:45 <lambdabot> forall a a1 a2 a3 (m :: * -> *) a11. (Applicative m, Monad m) => (a -> a1 -> a2 -> a3 -> m a11) -> m a -> m a1 -> m a2 -> m a3 -> m a11
15:50:53 <mmorrow> @type \f a b -> f <$> a <!> b
15:50:54 <lambdabot> forall a a1 (m :: * -> *) a11. (Applicative m, Monad m) => (a -> a1 -> m a11) -> m a -> m a1 -> m a11
15:54:28 <mmorrow> @type let f <@> a = join (f <*> a) =<< a in (<@>)
15:54:29 <lambdabot> forall a b. (a -> a -> a -> a -> b) -> (a -> a) -> a -> b
15:54:42 <mmorrow> @type let f <@> a = join (f <*> a) `ap` a in (<@>)
15:54:43 <lambdabot> forall (m :: * -> *) a b. (Monad m, Applicative m) => m (a -> m (a -> b)) -> m a -> m b
15:54:56 <mmorrow> @type let f <@> a = join (f <*> a) <*> a in (<@>)
15:54:57 <lambdabot> forall (f :: * -> *) a b. (Monad f, Applicative f) => f (a -> f (a -> b)) -> f a -> f b
15:56:04 <mmorrow> @type let f <@> a = join (f =<< a) <*> a in (<@>)
15:56:05 <lambdabot> forall a (f :: * -> *) b. (Applicative f, Monad f) => (a -> f (f (a -> b))) -> f a -> f b
15:58:11 <mike-burns> Are there any known bugs with gtk2hs's IconView? The docs on it are slim (in any language), but I keep getting "Gtk-CRITICAL **: gtk_icon_view_set_model: assertion `column_type == GDK_TYPE_PIXBUF' failed"
16:03:37 <CSWookie> Could someone tell me what the following type signature means?  I understand part of it, but not all.
16:03:40 <CSWookie> merge :: (Ord t) => [t] -> [t] -> [t]
16:04:10 <mauke> merge takes two lists (of some type t) and returns a list of t
16:04:11 <pumpkin> it takes two lists of values with an odering defined on them, and returns another list of the same type of element
16:04:14 <mauke> t also must be comparable
16:04:51 <CSWookie> Could you break that down for me?
16:05:31 <CSWookie> => is yields, so I get that, but I don't know what -> means.
16:05:39 <pumpkin> not yields, it's a constraint on the type
16:05:41 <Tsion> (Ord t) => means that in the type signature, t represents a type that can be compared or ordered
16:05:52 <pumpkin> [t] -> [t] -> [t] is more general than Ord t => before that
16:06:06 <pumpkin> that means for any type t, the function works like that
16:06:26 <pumpkin> whereas the Ord t restricts that only to types that have an Ord instance
16:06:28 <dino-> It helps sometimes to read -> as 'to'. Function from list of t to list of t to list of t
16:06:42 <CSWookie> so [t] -> [t] -> [t] means list of type t?
16:06:49 <pumpkin> [t] is list of type t
16:06:50 <dmwit> No, [t] means list of type t.
16:07:04 <dmwit> (->) is the function type constructor.
16:07:29 <dmwit> [t] -> [t] is a function from a list of ts to a list of ts.
16:07:41 <mozzyb> Hi - I am trying to learn haskell and I have now got myself into some monad troubles. I am doing the yaht and I am trying to make the askForNumbers thing. The problem seems to be that after getting user input and storing it in a list, the list becomes of the type IO [Integer]. What I want to do is use a pure function on this, but I can't as it is tagged IO. Can someone show me how to use f.eks. map (*) over a IO [Integer] ? I just don't reall
16:07:55 <dmwit> [t] -> [t] -> [t] = [t] -> ([t] -> [t]) is a function from a list of ts to another function, which itself takes a list of ts and yields a list of ts.
16:07:58 <CSWookie> Hmm.  I think I didn't write what I meant to write.
16:08:03 <pumpkin> mozzyb: use liftM or fmap
16:08:18 <pumpkin> mozzyb: to lift your map f into the IO
16:08:36 <mozzyb> pumpkin: ah.. I'll try that.
16:09:07 <dmwit> mozzyb: Has "do" notation been introduced yet?
16:09:18 <dmwit> mozzyb: If so, one common way to do this is to write
16:09:20 <mmorrow> BMeph: yeah, ap and (=<<) are can't-quite-put-your-finger-on-it similar
16:09:29 <pumpkin> :t ap
16:09:31 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
16:09:32 <pumpkin> :t (=<<)
16:09:33 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
16:09:40 <dmwit> do { xs <- askForNumbers; someMonadicActionOnAListOfNumbers xs }
16:09:44 <dmwit> or
16:09:53 <mauke> :t [ap, (=<<)]
16:09:54 <lambdabot> forall a b. [(a -> a -> b) -> (a -> a) -> a -> b]
16:09:57 <dmwit> do { xs <- askForNumbers; someMonadicBlah (map (*3) xs) }
16:09:58 <dmwit> or whatever
16:10:17 <mmorrow> @let f =<*< a = join (liftM (=<< a) f)
16:10:18 <lambdabot>  Defined.
16:10:28 <mmorrow> @type (=<*<)
16:10:30 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => m (a -> m a1) -> m a -> m a1
16:10:41 <jmillikin> Can a Hackage package be renamed? I uploaded a parser for IEEE 754 values some time ago, and now I've added serialization to it, so I'd like to change the name to be a bit more appropriate.
16:10:55 <mozzyb> dmwit: I am using do. But Havn't really understood it yet. what I am trying to do is map (*) l where the l is of type IO [Integer]
16:10:57 <jmillikin> that is, from ieee754-parser to data-binary-ieee754
16:11:12 <mmorrow> mauke: ah nice, they coincide with reader
16:11:27 <dmwit> mozzyb: You can do so by retrieving the list using (<-), as I showed above.
16:11:38 <mmorrow> mauke: that's interesting
16:12:29 <mauke> > ap (-) sqrt 3
16:12:30 <lambdabot>   1.2679491924311228
16:12:35 <mauke> > (=<<) (-) sqrt 3
16:12:37 <lambdabot>   -1.2679491924311228
16:12:37 <dmwit> mozzyb: The short story is that you can never escape IO once you're in it.  You can only drag more and more things into IO.
16:12:48 <mmorrow> ah
16:12:53 <mmorrow> tricksy
16:12:59 <dmwit> mozzyb: When you want to do pure calculations, you convert them from pure calculations to IO calculations, then use them inside of IO.
16:13:06 <skorpan> is that application of (=<<) in the (->) monad?
16:14:10 <mozzyb> dmwit: ah. ok. I'll try some more and shout out if I still don't get it. Thanks
16:14:11 <mmorrow> @type ap (=<<)
16:14:13 <lambdabot> forall a (m :: * -> *) b. (Monad m) => ((a -> m b) -> m a) -> (a -> m b) -> m b
16:14:15 <mmorrow> @type (=<<) ap
16:14:16 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (m a -> m (a -> b)) -> m a -> m b
16:16:37 <mozzyb> dmwit: I'm stupid :P I thought I had already tried something, and I hadn't... or I had a misspelling or something last time. No problem no more :D
16:17:51 <dmwit> Great!
16:18:29 <inetic> arrr, google is quite useless when one wants to search for something like this: "haskell the @ operator". could you guys please point me somewhere where the @ operator is explained?
16:19:00 <mauke> @ is not an operator
16:19:17 <opqdonut> var@pattern does a pattern match but binds the whole pattern to var also
16:19:39 <opqdonut> > let y@(x:xs) = [1,2,3] in (y,x,xs)
16:19:40 <lambdabot>   ([1,2,3],1,[2,3])
16:19:42 <opqdonut> get it?
16:19:50 <CSWookie> http://pastebin.com/d5346821a <--  I put this together based on some help from some guys in this channel, but I think my changes might have broken something.  I don't understand why it has the type signature it does.
16:19:53 <mike-burns> inetic: For the future you may want http://haskell.org/hoogle/
16:20:17 <inetic> aha, I think I get it, many thanks
16:20:37 <Botje> CSWookie: you have to stick the y and x back on
16:20:46 <Botje> (lines 3 and 4, resp.)
16:20:57 <mauke> Botje: huh?
16:21:03 <Botje> oh
16:21:05 <Botje> OH
16:21:09 <Botje> didn't see the @
16:21:11 <Botje> nevermind :)
16:21:11 <opqdonut> can't find anything wrong with that
16:21:24 <Botje> but it /is/ confusing :)
16:21:28 <mauke> well, merge [] [] will fail
16:21:36 <CSWookie> Well, I don't know haskell idiom.
16:21:37 <inetic> mike-burns, that page seems to be a great source of info, thanks
16:21:50 <dmwit> CSWookie: Looks good to me; what were you expecting and what did you get instead?
16:21:59 <CSWookie> mauke: Should there be a merge _ _ clause?
16:22:15 <yav> hi.  has anyone had any luck building the network package on windows?
16:22:15 <lambdabot> yav: You have 1 new message. '/msg lambdabot @messages' to read it.
16:22:19 <mauke> CSWookie: no, the last two cases should be merge [] ys = ys; merge xs _ = xs
16:22:20 <Tsion> CSWookie: It has that type signature because it takes two lists and returns a list. It has (Ord t) because the (>) function takes two Ord types
16:22:21 <dmwit> CSWookie: I would replace the last two clauses with just merge xs ys = xs ++ ys.
16:22:40 <CSWookie> dmwit: I don't expect anything so far, I'm just trying to understand the resulting type signature.
16:22:44 <mauke> or that, but that may copy xs unnecessarily
16:25:58 <CSWookie> So, what does [t] -> [t] -> [t] mean, again?
16:26:11 <pumpkin> a function that takes two lists of t and returns one list of t
16:26:21 <CSWookie> Oh.
16:26:33 <pumpkin> or more strictly a function that takes a list of t, returns a function that takes a list of t and returns a list of t
16:26:39 <CSWookie> That's what I expect...  But it seems bizarre tpo use that notiation.
16:26:43 <pumpkin> [t] -> ([t] -> [t])
16:27:27 <Tsion> CSWookie: It's bizarre because of currying. You can partially apply the function by calling it with one argument instead of two.
16:27:31 <CSWookie> pumpkin: Why does my function return a function?
16:27:42 <pumpkin> Tsion just said why :)
16:28:01 <mauke> f x y is ((f x) y)
16:28:10 <CSWookie> Does that apply to all functions, or did I inadvertently do something to kick in currying?
16:28:22 <Tsion> CSWookie: This applies to all functions.
16:28:23 <mauke> you defined your function as 'f x y = ...'
16:28:40 <mauke> that's equivalent to 'f = \x -> y -> ...'
16:28:43 <mauke> er, \y
16:28:48 <dmwit> You could define it as
16:28:52 <pumpkin> you could easily make a function f :: ([t], [t]) -> [t]
16:28:53 <dmwit> f(x, y) = ...
16:29:00 <pumpkin> but that' be unnecesarily limiting
16:29:01 <dmwit> as in other functions that will remain nameless.
16:29:02 <pumpkin> damn :)
16:29:12 <mauke> why no space after f?
16:29:16 <dmwit> err... s/functions/languages/
16:29:20 <dmwit> mauke: Why not?
16:29:45 <mauke> for consistency
16:29:48 <dmwit> mauke: Also, it's to make the confusion between Haskell and other languages all the more complete, I guess. =)
16:32:28 <malouin> for n lists of m elements, concat runs in n, right?
16:32:49 <CSWookie> Hmm.  When I try to pass the result to takeWhile, I get an error about how it can't match expected [a] to inferred [t].
16:33:07 <CSWookie> Do I need to explicitly declare my type signature to involved [a]?
16:33:14 <pumpkin> malouin: nope
16:33:20 <mauke> CSWookie: what's the real error?
16:33:30 <dmwit> malouin: concat runs in O(n), where n is the number of elements of the resulting list you demand.
16:34:05 <malouin> interesting.
16:35:06 <malouin> if ShowS allows constant time joining of strings, couldn't concat run in O(n) where n is the number of elements in the argument list?
16:35:35 <depill> Hi, can anyone help me with some very basic haskell?  I need to take a list and turn it into tuple. Example listToTuple [1,2,3,4,5] = (1,(2,(3,4)))   I've done this: let listToTuple [] = ()  ;     let listToTuple (x:xs) = (x: listToTuple xs)     But when I try to run listToTuple [1,2,3,4,5] I get an exception stating "Non-exhaustive patterns in function listTotuple"
16:35:46 <pumpkin> depill: can't be done
16:36:10 <Botje> malouin: it's not constant time, but each string is only traversed once instead of n times (for n calls to ++)
16:36:31 <depill> pumpkin: why is that?
16:36:43 <pumpkin> depill: the number of elements in the input list determine the type of the return value
16:36:50 <malouin> Botje: ok.
16:36:58 <depill> k thanks
16:37:08 <pumpkin> depill: also, if you wanted something like that maybe you'd wnat to make it more homogeneous, with (1,(2,(3,(4,(5, ()))))
16:37:17 <pumpkin> depill: you can do that in template haskell
16:37:25 <CSWookie> mauke: It's an 8-line trace.  Is that short enough to paste here, or do you want me to pastebin?
16:37:35 <depill> pumpkin: Thanks alot
16:37:36 <mauke> CSWookie: pastebin
16:38:05 <pumpkin> depill: you could sort of fool it :P
16:38:19 <pumpkin> depill: but it wouldn't buy you anything over a list
16:38:57 <CSWookie> mauke: http://pastebin.com/d363432e1
16:39:34 <mike-burns> CSWookie: Try this: takeWhile (<1000) (merge [0, 3 ..] [0, 5 ..])
16:39:34 <mauke> CSWookie: the inferred type is [t] -> [t] -> [t], not just [t]
16:39:34 <Botje> CSWookie: that code gives four arguments to takeWhile
16:39:35 <ulfdoz> Sie ist  nicht mehr die Jngste.
16:39:41 <ulfdoz> ewin, sorry.
16:40:52 <CSWookie> Botje: Oh, I thought order of operations would handle it.
16:41:22 <Botje> CSWookie: "order of operations" ?
16:41:42 <Botje> haskell can't know for sure you don't mean "pass merge as an argument to takeWhile"
16:42:43 <CSWookie> Botje: Fair enough.
16:52:51 <CSWookie> Is there a function in the stdlib to uniqify a list?
16:52:57 <mike-burns> nub
16:53:00 <Tsion> CSWookie: nub
16:53:03 <CSWookie> nub?
16:53:12 <CSWookie> What does that mean?
16:53:14 <Tsion> It's an odd name. :P
16:53:19 <aavogt> @type nub
16:53:20 <lambdabot> forall a. (Eq a) => [a] -> [a]
16:53:28 <mike-burns> It's Old English.
16:53:39 <Tsion> > nub [1,1,2,5,4,5,5,7,8]
16:53:41 <lambdabot>   [1,2,5,4,7,8]
16:54:00 <CSWookie> I know what the nub of something is, I don't see how it applies here.  Oh well.
16:54:15 <mike-burns> nib, n: The essence; the core, e.g. "the nub of a story"
16:54:20 <mike-burns> I guess they ran out of words.
16:54:31 <mauke> niiiiiiiiiiiiiiib
16:54:32 <ac> So I've been thinking about making a web based IM style program using Haskell. Is this a bad idea? Any obvious libraries I should use?
16:54:32 <CSWookie> uniq wasn't good enough?
16:54:40 <Tsion> I think uniq would have worked well.
16:54:53 <mike-burns> uniq would have been the perfect name.
16:55:09 <ac> (IM meaning instant messaging)
16:55:09 <mauke> uniq only removes adjacent duplicates
16:55:42 <inimino> posix:uniq, but the word could have been repurposed slightly
16:57:25 <CSWookie> Hmm.
16:57:33 <CSWookie> nub isn't abailable to me.
16:57:41 <Tsion> CSWookie: import Data.List
17:00:38 <CSWookie> Yay!  I've solved problem 1 in Project Euler!
17:00:59 <CSWookie> Well, technically, I supposed you guys solved it.
17:00:59 <hackagebot> Added by JohnMillikin, Sun Jun  7 00:00:02 UTC 2009.: Parser/Serializer for IEEE-754 floating-point values  http://hackage.haskell.org/cgi-bin/hackage-scripts/package/data-binary-ieee754-0.2
17:01:09 <mauke> > sum $ filter (\n -> n `mod` 3 == 0 || n `mod` 5 == 0) [1 .. 999]
17:01:10 <lambdabot>   233168
17:01:42 <BMeph> BOO-yah! ;p
17:02:22 <jmillikin> Once I upload a package with a new name, which obsoletes an old package, who do I contact to have the old one removed?
17:03:04 <jmillikin> I can't find any information on package renaming online, aside from that I have to ask somebody to do so.
17:04:47 <Saizan> jmillikin: ross paterson is the hackagedb maintainer, cabal-devel@ is also appropriate
17:06:52 <jmillikin> This cabal-devel <http://www.haskell.org/pipermail/cabal-devel/>? It appears to be concerned mainly with the development of cabal itself, not administrative tasks in hackage.
17:07:43 <dever> another stupid question here, i have a list of ActionEntry, and I want to set its field actionEntryCallback action, after I initialize it, to a function that takes in the action, how do i apply that to the list?
17:08:26 <jmillikin> Will just wait for Mr. Paterson to show up in IRC, I guess.
17:08:27 <pumpkin> SET!??!?!
17:08:51 <Saizan> jmillikin: he doesn't, you've to mail him :)
17:08:57 <dmwit> pumpkin: SPIKE!!!1!
17:09:39 <Saizan> dever: map (\a -> a { actionEntryCallBack = foo }) actionentrylist
17:11:52 <skorpan> hm, is there any pointless version of that function?
17:11:59 <skorpan> @pl \a -> a { lol = loller }
17:11:59 <lambdabot> (line 1, column 9):
17:11:59 <lambdabot> unexpected "{"
17:11:59 <lambdabot> expecting variable, "(", operator or end of input
17:12:09 <Saizan> skorpan: no
17:12:12 <pumpkin> nope, unless you write a function that does it
17:12:36 <Saizan> which is kind of a tautology :)
17:12:42 <pumpkin> :P
17:12:52 * pumpkin hrrmpf
17:12:53 <skorpan> there is no function unless there is a function
17:12:56 <inimino> actually the function exists even before you write it
17:13:04 <lament> ommmm
17:13:13 <thoughtpolice> hi pumpkin
17:13:15 * pumpkin mumbles something about trees and forests
17:13:31 <pumpkin> ...that doesn't involve graph theory
17:13:33 <pumpkin> thoughtpolice: ohai
17:15:58 <mozzyb> \x -> x ’a’
17:16:07 <mozzyb> sorry.. wrong terminal :P
17:16:20 <malouin> I'm trying to make an exception type that will allow me to suggest an HTTP status code, but I'm running into problems with 'Typeable', which I don't understand...
17:16:24 <malouin> http://hpaste.org/view?id=5619#a5619
17:16:45 <thoughtpolice> pumpkin: 01:02 < pumpkin> omg thoughtpolice
17:16:50 <Saizan> what's the error?
17:17:06 <pumpkin> thoughtpolice: that was me being surprised at seeing you!
17:17:08 <pumpkin> and happy!
17:17:13 <thoughtpolice> :>
17:17:25 <malouin> Saizan: well, the code in the pastebin gives 'Not in scope: type constructor or class `Typeable''
17:17:36 <malouin> But if I import Data.Typeable, more errors.
17:18:01 <Saizan> malouin: you do have to import Data.Typeable, annotate the paste with the other errors
17:18:19 <Saizan> malouin: you probably need {-# LANGUAGE DeriveDataTypeable #-} at the top of the file
17:18:58 <malouin> Saizan: errors pasted.
17:19:41 <malouin> Saizan: ok, that fixed it! although... magic...
17:19:47 <Saizan> malouin: yeah, the ability to derive instances for the Typeable class is an extension to the Haskell 98 standard
17:20:04 <Saizan> malouin: so you've to tell GHC that you do want to use such an extension
17:20:17 <malouin> Ok, that makes sense.
17:20:37 <malouin> If I did not want to use the extension, presumably I would have to figure out how to make my exception a Typeable instance by hand?
17:21:06 <Saizan> malouin: yes, but that's strongly discouraged
17:21:26 <malouin> sounds good, I didn't want to anyway :)
17:21:28 <Saizan> malouin: a bad Typeable instance can subvert the type system
17:21:32 <malouin> eew
17:21:56 <Saizan> because of cast, essentially
17:21:56 <malouin> Incidentally, the docs at http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html#1 seemed to me to suggest that what I attempted to do would work.
17:21:58 <Saizan> ?type cast
17:21:59 <lambdabot> forall a b. (Typeable a, Typeable b) => a -> Maybe b
17:23:01 <malouin> A note there about {-# LANGUAGE DeriveDataTypeable #-} might be helpful, since apparently it is impossible to make exceptions otherwise?
17:24:20 <Saizan> malouin: it might, yeah, the place to report such things is on the libraries@ list, or you might directly send a darcs patch
17:25:39 <malouin> ok, awesome.
17:25:49 <malouin> I'll see if I can put something together.
17:40:31 <dever> i cant remember who responded to my last question abut setting the field of a type, but it was with map, here's what I have map (\action -> action ActionEntry {actionEntryCallback  = activateAction action}) actions
17:40:48 <dever> but that doesn't work either :§
17:41:54 <Saizan> you've to leave out the ActionEntry constructor
17:42:06 <dever> ah yes, just got it there
17:42:20 <xoclipse> what's the best way to get the current UTC time in microseconds?
17:42:24 <xoclipse> Data.Time or System.Time?
17:42:29 <dever> im too tired for this :D
17:42:55 <dever> I get warnings about the attribute not being set when I initialise the list, is that alright?
17:43:58 <aavogt> dever: ok if you are /sure/ that you won't want to acces those unset attributes
17:44:37 <dever> well, I set them just after I initialise the list, the unset attribute needs to reference itself
17:44:57 <dever> sorry, it needs to reference the element it belongs to
17:45:02 <dmwit> It can do that, you know.
17:45:14 <yav> dever: you should avoid having uninitialized fields
17:45:16 <dmwit> foo = ActionEntry { field = someFunction foo }
17:45:18 <Bacta> @fag Can I use Haskell to write Crysis 2?
17:45:19 <lambdabot> The answer is: Yes! Haskell can do that.
17:45:48 <aavogt> @f is this short enough?
17:45:48 <lambdabot> Maybe you meant: fact fact-cons fact-delete fact-set fact-snoc fact-update faq farber flush foldoc forget fortune fptools free freshname ft . ? @ bf v
17:46:02 <dmwit> ?fa q
17:46:02 <lambdabot> Maybe you meant: fact fact-cons fact-delete fact-set fact-snoc fact-update faq farber ft
17:46:10 <dever> yav: yup, but it's an element in a list, i.e. un named
17:46:18 <dmwit> Oh, come on, ?faq is the closest one.
17:46:22 <dmwit> dever: No problem!
17:46:24 <dmwit> :t fix
17:46:25 <lambdabot> forall a. (a -> a) -> a
17:46:28 <aavogt> @fap ?
17:46:28 <lambdabot> Maybe you meant: faq map
17:46:57 <dmwit> fix (\foo -> ActionEntry { field = someFunction foo, otherFields = initializedHereToo })
17:47:51 <dever> :i fix
17:47:56 <dmwit> But yes, this is why it is a warning and not an error: so that you can ignore it if you are confident nothing will go wrong.
17:48:01 <dmwit> \bot doesn't have :i
17:48:10 <dmwit> And ?info doesn't do what you might hope. =)
17:48:12 <yav> dever: sorry if i am repeating what has been said.  elements of lists can be named too.
17:48:15 <aavogt> @index fix
17:48:15 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
17:48:16 <dmwit> ?index fix
17:48:17 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
17:48:36 <dmwit> Data.Function isn't in that list, but it should be.
17:48:59 <dmwit> (for GHC >= 6.10)
17:49:56 <dever> grr, anyone know how to scroll up on a mac in irssi?
17:51:15 <yav> btw, has anyone that has managed to successfully build/use the network package on windows appeared on the channel?
17:52:42 <EvilTerran> yav, doesn't that come with ghc?
17:53:10 <kniu> In type theory literature,
17:53:23 <yav> EvilTerran: the one that comes with GHC has a bug where it crashes with a pattern match failure when you try to do host lookup
17:53:27 <kniu> what's the difference between the |- character and the _____ dividing line?
17:53:38 <dmwit> dever: Uh, page up doesn't work?
17:53:40 * dmwit shrugs
17:53:50 <kniu> Aren't they both "assuming this, then that"?
17:54:21 <EvilTerran> kniu, i've seen them used interchangably in some contexts
17:54:21 <dmwit> kniu: Usually one is used in defining a relation, and the other is used in defining an inference rule.
17:54:37 <yav> kniu: |- separates assumptions from conclusions, ____ separates steps in a proof
17:54:57 <dmwit> For values of "usually" that should be very carefully examined.
17:55:43 <kniu> I'm still kind of confused, but ok.
17:56:27 <yav> kniu: i've been there :-)  one way to see the difference would be to try to write a proof of something just using |-
18:02:42 <theunixgeek> It's been an hour since I started building GHC. How long should it take?
18:03:32 <yav> theunixgeek: it depends on your machine and how you are building it but it usually takes a while
18:03:42 <theunixgeek> yav: I'm installing it via macports on OS X
18:03:57 <theunixgeek> I'll just wait
18:03:59 <theunixgeek> thanks for the tip
18:06:55 <gwern> @quote CReal
18:06:55 <lambdabot> <pumpkin> says: we should throw it [CReal] in with Foreign.C.Types to confuse people
18:07:04 <gwern> @quote tell.*dons
18:07:04 <lambdabot> MyCatVerbs says: The *real* best way to optimize a program is to tell dons that it's been added to the Shootout.
18:07:12 <roconnor> @quote narrow
18:07:12 <lambdabot> <roconnor> says: I have a proof that Ultrafinitism is inconsistent, but the universe is too narrow to contain it.
18:07:15 <gwern> @quote quantitative
18:07:16 <lambdabot> No quotes match.
18:07:24 <gwern> @quote quantitative
18:07:24 <lambdabot> No quotes match. Wrong!  You cheating scum!
18:07:28 <pumpkin> someone needs to stop quoting people with <> around their nicks :P
18:07:36 <gwern> roconnor: what is ultrafinitism?
18:07:44 <gwern> @quote Frankau
18:07:44 <lambdabot> No quotes match. I've seen penguins that can type better than that.
18:07:51 <gwern> @remember SimonFrankau The points-free approach, while elegant, can make code unreadable, especially if it is written by quantitative analysts moonlighting as functional programmers.
18:07:51 <lambdabot> Done.
18:08:03 <gwern> @quote bacon
18:08:04 <lambdabot> gwern says: drat. what *do* all you people talk about? only one bacon and one zombie quote
18:08:13 <roconnor> gwern: the belief that very large numbers don't really exist.
18:08:17 <pumpkin> @quote zombie
18:08:18 <lambdabot> Tac-Tics says: oerjan: I tried, but his zombie lectures were hard to follow
18:09:15 <roconnor> @forget <roconnor> I have a proof that Ultrafinitism is inconsistent, but the universe is too narrow to contain it.
18:09:15 <lambdabot> Done.
18:09:24 <roconnor> @remember roconnor I have a proof that Ultrafinitism is inconsistent, but the universe is too narrow to contain it.
18:09:24 <lambdabot> Done.
18:09:28 <roconnor> @quote narrow
18:09:28 <lambdabot> roconnor says: I have a proof that Ultrafinitism is inconsistent, but the universe is too narrow to contain it.
18:13:47 <gwern> roconnor: exist... in what sense?
18:14:17 <gwern> @quote port.*GHC
18:14:17 <lambdabot> mwc says: I'm thinking we should file a bug report and require ghc to produce executables that sound like famous classical pieces
18:14:22 <gwern> @quote port.*GHC
18:14:22 <lambdabot> mwc says: I'm thinking we should file a bug report and require ghc to produce executables that sound like famous classical pieces
18:14:39 <gwern> @remember ValarQ l33t_h4x0r: could you help me port GHC to the AVR architecture? <-- l33t_h4x0r has left #haskell
18:14:39 <lambdabot> Done.
18:14:51 <gwern> @quote proggit
18:14:51 <lambdabot> quicksilver says: well if you can get proggit to help with your interview, then perhaps you can get proggit to help with the job when you get it. So it's not cheating, it's just an indication of one
18:14:51 <lambdabot> of your skill sets.
18:14:59 <gwern> @quote SharePoint
18:15:00 <lambdabot> shapr says: I haven't tried F#, everytime I get the urge to do something fun with .NET I have SharePoint flashbacks and buy more hardware instead.
18:15:01 <idnar> @flush
18:15:02 <lambdabot> Not enough privileges
18:15:15 <gwern> @quote emoticon
18:15:15 <lambdabot> No quotes match. :(
18:15:26 <gwern> @remember gwern bleh. haskell is messing me up. I wondered what operator =) is, before I realized it was a syntax error, before I realized it was an emoticon
18:15:27 <lambdabot> Good to know.
18:15:32 <gwern> @flush
18:17:29 <Badger> @quote
18:17:29 <lambdabot> Peaker says: It depends how much of the door you want to model. In a ray tracer, it would be quite different than in an alarm system
18:19:42 <roconnor> gwern: in any sense I guess
18:19:46 <roconnor> er
18:20:18 <gwern> it's always hard when people say things like 'infinities don't exist', since they're probably using a different definition of exist than you are
18:20:26 <roconnor> gwern: you know how you and I believe that (10^10^10^10^10) is a number
18:20:31 <roconnor> they don't
18:20:40 <gwern> what do they believe that is?
18:20:47 <roconnor> nonsense I guess
18:20:48 <dmwit> abstract nonsense
18:20:53 <pumpkin> whoa, ^ is infixr
18:21:06 <roconnor> gwern: well, maybe more like what we think of as bottom
18:21:12 <dmwit> pumpkin: infixl would be silly
18:21:22 <dmwit> pumpkin: You can get (a^b)^c by a ^ b * c
18:21:32 <pumpkin> true dat
18:21:50 <MyCatVerbs> :i (^)
18:21:52 <gwern> roconnor: hm. so any manipulation of 10^... is bottom? 10^.. divided by 10^10^10 is bottom?
18:21:56 <pumpkin> :i does nothing
18:22:02 <MyCatVerbs> Of course.
18:22:09 <Badger> :t (^)
18:22:09 <pumpkin> @info does nothing either
18:22:10 <lambdabot> does nothing either
18:22:10 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
18:22:19 <dmwit> ?info do { x <- foo; return y }
18:22:20 <lambdabot> foo >>= \ x -> return y
18:22:20 <MyCatVerbs> Oh. (^) binds tighter than (*).
18:22:22 <dmwit> pumpkin: You liar!
18:22:23 <roconnor> gwen, well I'm not sure about that.  possibly
18:22:25 <dmwit> It does something.
18:22:38 <pumpkin> @info does something
18:22:39 <lambdabot> does something
18:22:40 <roconnor> dmwit: isn't that like saying (->) being infixr is silly?
18:22:59 <dmwit> Nah.
18:23:14 <dmwit> ;-)
18:23:23 <roconnor> dmwit: you are so unfair
18:23:33 <roconnor> your a curry bigot
18:23:36 <dmwit> hehehe
18:23:38 <roconnor> you're
18:23:48 <gwern> roconnor: oh hey, there's a wp article on ultrafinitism
18:24:15 <roconnor> I try to be an ultrafinitist, but it is hard.
18:24:34 <roconnor> especially without a formal theory to go with it.
18:24:37 <dolio> And silly.
18:24:38 <dmwit> Oh man, I just realized: that heckler in Math 53h was an ultrafinitist!
18:24:55 <dmwit> Boy did the lecturer get flustered.
18:25:00 <roconnor> dolio: i'm not sure it is silly.
18:25:27 <roconnor> dolio: it's like programming in constructive logic, only your programs never run out of memory.
18:25:29 <gwern> roconnor: hm. it seems to suggest that the criteria is physically realizable; but deciding whether a physical arrangement 'means' a number is as hard, philosophically, as deciding what characterizes conscious physical arrangements imo
18:25:55 <roconnor> gwern: I think it depends also depends on the representation
18:26:12 <dmwit> So, this is Kolmogorov complexity applied to philosophy?
18:26:26 <gwern> that's the issue. even 10^10^10^10^10^10^10 has a hysical representation - I just gave it
18:26:29 <roconnor> for example, there are exponentially fewer peano natural numbers than binary natural numbers.
18:26:32 <dmwit> There is no number bigger than what can actually be represented (in any chosen representation) using the resources available in the universe?
18:27:04 <pumpkin> so you can't count all the chess games?
18:27:07 <pumpkin> or all the go games?
18:27:07 <idnar> dmwit: how could you conceive of a specific number that cannot be represented?
18:27:09 <roconnor> I say, if I cannot normalize the value in Coq, then it doesn't exist :P
18:27:09 * dmwit writes down, "This is the smallest number not representable in any other way."
18:27:11 <bremner> I've heard Doron Zeilberger say things like that
18:27:16 <gwern> dmwit: well, isn't there a trivial notation where '1 = <whatever number you just thought was too big for me to represent>'?
18:27:21 <idnar> dmwit: as soon as you describe it, you have represented it
18:27:45 <dmwit> idnar: Correct.  So if you can describe it, it's not the upper bound.
18:28:09 <dmwit> gwern: Yes, but you have to define your notation. ;-)
18:28:14 <idnar> dmwit: well, it seems pointless to hypothesize whether numbers that you cannot describe exist or not
18:28:17 <roconnor> The problem is that if I'm not an ultrafinitist, then I think I have a formal proof of the Riemann Hypothesis in Coq.
18:28:34 <gwern> roconnor: ?
18:28:35 <inhahe> i'm some kind of ultraconstructivist in math, but as far as big numbers goes, it seems to depend on what one means by a numebr.  for example in the wiki article it says that they don't bleieve in the floor of e^e^e^79. well, if you define it as floor(e^e^e^79), then the number exists by definition. if oyu define it as a decimal sequence, then it depends on whether an algorithm for that suffices
18:28:58 <gwern> dmwit: *my* notation? why don't you translate your natural number-based notation into my new notation? seems just as fair to me
18:29:10 <dmwit> gwern: Totally.
18:29:12 <inhahe> i think it's irrelevant how big the universe is -- only wether a number has actually been represented or not
18:29:15 <dmwit> gwern: Either notation has to be described.
18:29:26 <roconnor> gwern: I "wrote" a Coq tactic to search all proofs in PA whose code is less than 10^10^10^10^10^10^10 for a proof of RH.
18:29:27 <dmwit> gwern: It just turns out that mathematicians have already described *my* notation for me.
18:29:43 <pumpkin> roconnor is the master of Coq
18:29:45 <gwern> roconnor: did it ever terminate?
18:29:51 <roconnor> gwern: not yet
18:29:55 <roconnor> it's still going
18:29:58 <gwern> pumpkin: your bad jokes will cock this discussion up
18:30:05 <pumpkin> onoes :(
18:30:06 <roconnor> but none the less, I think I'm the first.
18:30:28 <roconnor> pumpkin: the jokes don't phase me anymore.
18:30:36 <pumpkin> :)
18:30:36 <roconnor> It's been 7 years
18:30:39 <pumpkin> I bet
18:30:39 * dmwit high-fives roconnor
18:30:43 <pumpkin> imagine working at inria
18:30:45 <gwern> roconnor: 'faze'
18:30:48 <Adamant> I'll avoid the obvious chicken choking jokes.
18:30:54 <dmwit> Level Up!  +1 to maturity
18:30:58 <MyCatVerbs> roconnor: faze, faze! FAAAZE!
18:31:15 * pumpkin resisted the temptation to correct faze, knowing well that one of the 587 other people would've done it
18:31:16 <roconnor> oh
18:31:20 <roconnor> pumpkin: the jokes don't faze me anymore.
18:31:22 <roconnor> ya
18:31:23 <dolio> They get pretty old after looking at about 3 articles on Coq on reddit.
18:31:24 <dmwit> ?wn faze
18:31:26 <roconnor> that looks way better
18:31:33 <pumpkin> faze is like taze
18:31:39 <pumpkin> or laze
18:31:40 <lambdabot> Error: thread killed
18:31:42 <Berengal> phase is like star trek
18:31:51 <dolio> Since those are the only comments that ever get posted there, since no one knows enough to comment on the actual content of the articles, typically. :)
18:31:52 <dmwit> roconnor: Unless you wanted to say that the jokes don't cause you to spontaneously shift throw walls and stuff, which I guess is also true.
18:32:00 <dmwit> s/throw/through/
18:32:04 <roconnor> :)
18:32:07 <pumpkin> I was unfazed as I tazed Berengal while I lazed on the hammock
18:32:09 <inhahe> i thnik a hand-held fazer would be awesome
18:32:36 <gwern> dolio: no kidding. I wince when I see coq articles - I have to resist the temptation since I don't know coq at all
18:32:38 <dmwit> I'll take a tasp over a fazer any day.
18:32:38 <Berengal> phasers are also fazers, when set to stun
18:32:43 <roconnor> gwern: or does my proof not count until Coq finishes type checking?
18:33:07 <gwern> roconnor: was there a proof of fermat's last theorem before wile finished his proof?
18:33:10 <idnar> dmwit: muphry's law strikes again!
18:33:18 <dmwit> =)
18:33:24 <idnar> roconnor: how do you know it'll succeed?
18:33:29 <roconnor> gwern: depends on if you are an ultrafinisist or not. :)
18:33:35 <Berengal> Bah, I'm being smug on the internet again :(
18:33:45 * pumpkin desmugs Berengal
18:33:45 <Berengal> Haskell makes it hard not to be...
18:34:13 * Badger phases pumpkin 
18:34:14 <gwern> roconnor: mm. I'd identify that as a platonic/construcitvist argument, but I suppose ultrafinitists are a subset of constructivists...
18:34:37 <malouin> Is there some way to clean up catch (catch f (\onetypeofe -> ...)) (\anothertypeofe -> ...)?
18:34:51 <dever> can anyone tell me why this is returning [[ActionEntry]] opposed to [ActionEntry], I can't for the life of me figure it out :) http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5621#a5621
18:34:53 <roconnor> idnar: let me try a different tact
18:34:55 <roconnor> tack
18:35:11 <roconnor> idnar gwern: I did run it to completion, and it worked.
18:35:35 <roconnor> I ran it on a super fast secret computer and started it going in the 1980s
18:35:45 <pumpkin> is it a cray? :o
18:35:47 <roconnor> here you go
18:35:50 <gwern> roconnor: remember me when you're rich!
18:35:53 <roconnor> you  can try it yourself too
18:36:09 <dmwit> dever: I figured it out.
18:36:17 <aavogt> dever: you're using the list monad and return is (:[])
18:36:19 <dmwit> dever: GHC is balking at the 1024-line columns.
18:36:26 <idnar> roconnor:
18:36:26 <roconnor> hmm
18:36:29 <idnar> er
18:36:29 <dmwit> err... 1024-column lines
18:36:31 <roconnor> maybe that argument doesn't work
18:36:36 <idnar> roconnor: so you found the proof, but you don't know what it is? or you just can't communicate it to someone else?
18:36:49 <dolio> Don't tactics find proofs?
18:36:55 <Berengal> dever: 'do' does not do what you think it does
18:36:58 <dolio> Are they proofs themselves?
18:37:13 <roconnor> idnar: ah good point.  I suppose if did a search I could have written down what the result was.
18:37:22 <dmwit> dever: But yeah, you probably don't want a do-block at all; just "let actions = [...] in map (\action -> ...) actions"
18:37:26 <dolio> An algorithm to check all proofs less than 10^10... isn't a proof. The thing it finds (if it does) is.
18:37:35 <dever> that could be it
18:37:55 <gwern> roconnor: I was thinking 'well, what was the haskell output?' :)
18:38:03 <dmwit> dever: In particular, even if you take the return out (which will then cause it to type-check), you won't have initialized the callback fields.
18:38:22 <idnar> that suggests the question: "does a non-constructive proof of the existence of a proof of X count as a proof of X?"
18:38:27 <roconnor> dolio: it's a bit strange.  It seems proof checking should be polynomial in the size of the proof, but that certainly isn't how Coq and the like work.
18:38:38 <gwern> dever: of course, if we have a proof that the search will find the desired proof of x, then I guess by transivity we then have a proof of x
18:38:46 <roconnor> Freek thinks that proof checking should be linear in the size of the proof.
18:38:53 <dmwit> ...and you'd have a big ol' list of copies of the action entries.
18:39:02 <pumpkin> roconnor: seems like it should depend on how expressive your proof language is shouldn't it?
18:39:12 <roconnor> Coq is very expressive.
18:39:13 <pumpkin> roconnor: as said by someone who knows nothing about the topic (me)
18:39:17 <idnar> I feel like Goedel is about to jump out from behind the wall and scream at me
18:39:28 <dolio> roconnor: I don't really know coq at all, so I may be wrong.
18:39:34 <roconnor> but not expressive enough to evaluate itself :P
18:39:37 <gwern> idnar: godel doesn't scream. he stares at you mournfully and refuses to eat
18:39:42 <gwern> idnar: because you are trying to poison him
18:40:05 <roconnor> dolio: I think your comments are on the mark
18:40:22 <idnar> gwern: well, I suppose it's more like going around a corner and tripping over Goedel's dead body
18:40:29 <roconnor> I guess the result is that Coq "proofs" are not really proofs.
18:40:34 <roconnor> or not always proofs
18:40:50 <dolio> Agda has some kind of "ring solver" thing in the standard library, apparently, which you can use in lieu of writing down your arithmetic proofs manually, which seems similar to coq's machinery.
18:40:51 <roconnor> which is odd for a proofs system...
18:41:09 <roconnor> dolio: this problem goes beyond the tactic language.
18:41:23 <roconnor> dolio: I can easily write ackermann in Agda, etc
18:41:54 <roconnor> and program a proof term to search up to Ackerman(some number) without using the tactic language at all.
18:42:15 <roconnor> thus making a compressed proof.
18:42:32 <dolio> Sure. Agda doesn't hae a tactic language.
18:42:48 <roconnor> dolio: oh the ring solver is in Agda?
18:42:51 <roconnor> that's cool
18:42:52 <dolio> Right.
18:42:55 <dolio> Yeah. :)
18:43:30 <roconnor> anyhow, there is something about proofs and proof objects and size and type checking and maybe ultrafinitism that I don't really fulling get yet.
18:43:38 <roconnor> fully
18:47:26 <dolio> Man, I can't remember where I saw an example of its use.
18:49:00 <dolio> Oh, I remember. In Data.Nat.DivMod
18:49:32 <wli> What representation is used by Data.Nat?
18:50:30 <dolio> "solve 1 (λ x → x := x :+ con 0) refl _" presumably computes a proof of x == x + 0 for use in their proof of something else.
18:50:36 <dolio> It uses Peano numbers.
18:51:07 <wli> Suckage.
18:52:27 <dolio> There's Data.Digit, though.
18:53:06 <dolio> Also, you can use some pragmas to optimize Nat in agda to be internally represented as, I suspect, Haskell's Integer.
18:53:24 <wli> I'd use [Word32] or something.
18:53:27 <dolio> While still allowing you to do proofs using the Peano representation.
18:53:36 <wli> (wrapped somehow)
18:53:42 <dolio> There is no Word32. :)
18:53:58 <pumpkin> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Word.html#t%3AWord32
18:54:14 * pumpkin stares at his spoon
18:54:20 <dolio> That's not an Agda library.
18:54:31 <pumpkin> oh :)
18:54:41 <pumpkin> that'll teach me to jump in without context again, /me zips his mouth
18:54:48 <dmwit> pumpkin: I think you mistook this #agda channel for #haskell again.
18:54:54 <gwern> he needs a long spoon who would sup with the Devil.
18:54:55 <idnar> heh
18:54:56 <pumpkin> oh no!
18:55:13 <dolio> Data.Digit has "Digit : Nat -> Set", where "Digit b" is the type of base-b numbers.
18:55:43 <pumpkin> how far does it go? 62?
18:55:59 <pumpkin> or does it not care about actually showing it?
18:56:32 <dolio> It's represented as lists (maybe a custom type) of 'Fin b's.
18:56:43 <dolio> Fin b being the finite set of size b.
18:57:21 <dolio> Is there fancy showing of Fins? I can't remember.
18:58:23 <dolio> Looks like no.
18:58:47 <dolio> I may be wrong, too. It looks like "Digit" is just an alias for "Fin".
18:59:24 <dolio> And some fanciness for going between digits and chars.
18:59:40 <dolio> And digit lists and Nats.
19:01:48 <dolio> One could probably flesh it out to do digit-list-based arithmetic if he wanted.
19:02:49 <dolio> But then, why bother when it'd probably be slower than special-cased Nat? :)
19:04:56 * dmwit asks for succ 0 in base 0
19:05:35 <roconnor> dmwit: concat (repeat [])
19:05:39 <dolio> Fin 0 is the empty set, so I'm not sure you can even represent 0.
19:06:03 <dolio> Assuming 0 is represented by "fzero :: []".
19:06:24 <dmwit> roconnor: Coq has those pesky termination guarantees that get in the way of having infinite inductive lists.
19:07:00 <roconnor> dmwit: right, you cannot define concat as such
19:07:10 <roconnor> but in Agda you can :P
19:07:16 <dmwit> I would think repeat would be the one giving you trouble.
19:07:20 <dolio> repeat is the problem.
19:07:26 <roconnor> repeat is productive
19:07:32 <dmwit> Also: oh yeah, we're talking about Agda, not Coq.
19:07:40 <idnar> coqda
19:07:45 <roconnor> Agda 2 might have codata
19:07:48 <dolio> Well, concat is bad for codata, repeat is bad for data.
19:07:59 <roconnor> oh right
19:08:04 <roconnor> concat works fine on data
19:09:28 <roconnor> @seen luqui
19:09:28 <lambdabot> I saw luqui leaving #haskell-blah and #haskell 16h 6m 16s ago, and .
19:16:07 <smorg> If i have something like: [ y | x <- [1..10], let y = 2*x, y >= 10 ] which == [10,12,14,16,18,20] what is the function of y? Replacing the first predicate with let y = x yields [10]. If y is acting as a variable of type list, it doesn't make sense that you would be able to both test y (as a list) against an integer with y >= 10, and multiply the whole list x by 2 and assign it to y.
19:17:23 <smorg> is haskell taking every element of an input list and checking its properties against a set of constraints?
19:17:27 <dolio> y has type Integer (or whatever).
19:17:56 <dmwit> smorg: Neither x nor y are lists there.
19:18:27 <dmwit> smorg: For any given (x,y) pair, x is an element of [1..10].
19:18:50 <dolio> x is the element you're selecting from [1..10], and y is a name for 2*x.
19:19:24 <dmwit> > [ x | x <- [1..10] ]
19:19:26 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
19:19:39 <dolio> You're removing the cases for which y < 10, and the resulting list contains the ys such that the guard is satisfied.
19:19:45 <dmwit> > [ 3 | x <- [1..10] ]
19:19:47 <lambdabot>   [3,3,3,3,3,3,3,3,3,3]
19:20:32 <smorg> ooh i see. This seems like it would take some serious artificial intelligence to solve complicated constraint problems like that
19:20:53 <dmwit> Yep, we don't do constraint solving in list comprehensions.
19:21:02 <dmwit> However, we have a constraint-solver monad, if you want that. =)
19:21:05 <lament> @faq Can haskell solve complicated constraint problems using some serious artificial intelligence?
19:21:05 <lambdabot> The answer is: Yes! Haskell can do that.
19:21:30 <lament> this one comes up all the time
19:21:47 <smorg> wow :D
19:23:41 <MyCatVerbs> @faq Can Haskell design arcane neurosurgical procedures to rewire a burnt-out hacker's nervous system so that it can manipulate him into taking part in a grand human-consciousness processing experiment? While aforementioned hacker is spaced out on lysergic, mescaline, psychobilin, valium, vaseline...
19:23:41 <lambdabot> The answer is: Yes! Haskell can do that.
19:23:44 <Fragsworth> what are the best online references for haskell?
19:23:54 <pumpkin> vaseline?
19:23:55 <Fragsworth> references and tutorials
19:24:07 <gwern> MyCatVerbs: vaseline?
19:24:17 <Axman6> Fragsworth: learn you a haskell for great good, real world haskell,... um
19:24:22 <dmwit> ?where hhl
19:24:22 <lambdabot> I know nothing about hhl.
19:24:29 <dmwit> http://www.haskell.org/ghc/docs/latest/html/libraries/
19:24:32 <dmwit> ?where hoogle
19:24:32 <lambdabot> http://haskell.org/hoogle
19:24:34 <Axman6> @where lyah
19:24:34 <MyCatVerbs> http://www.haskell.org/ghc/docs/latest/html/libraries/
19:24:35 <lambdabot> www.learnyouahaskell.com
19:24:39 <lament> learn you a real world haskell for great good!!!
19:24:50 <MyCatVerbs> ^-- HHL.
19:24:53 <dmwit> ?where report
19:24:53 <lambdabot> http://www.haskell.org/onlinereport/
19:25:06 <Tarrant> Learn you a haskell is really awesome. Thats the tutorial I've been using.
19:25:08 <dmwit> The ones I listed are references; the ones other people listed are mostly tutorials.
19:25:10 <lament> hhl is the ultimate page of awesome
19:25:17 <aavogt> MyCatVerbs: psilocybin?
19:25:22 <smorg> > [ (3, 4) | x <- [0..5], y <- [0..5] ]
19:25:23 <lambdabot>   [(3,4),(3,4),(3,4),(3,4),(3,4),(3,4),(3,4),(3,4),(3,4),(3,4),(3,4),(3,4),(3...
19:25:24 <dmwit> ?where gentle (The Gentle Intro is my favorite tutorial)
19:25:25 <lambdabot> http://www.haskell.org/tutorial/
19:25:54 <MyCatVerbs> aavogt: yeah, I fail. Still not as hardcore as mainlining petroleum jelly, though.
19:25:57 <dmwit> ?where+ hhl http://www.haskell.org/ghc/docs/latest/html/libraries/
19:25:58 <lambdabot> Done.
19:26:23 <MyCatVerbs> Oh, should we link to the 6.10.3 HHL instead of latest?
19:26:34 <MyCatVerbs> Latest gets a bit unstable around release times.
19:26:36 <dmwit> I think latest is fine.
19:26:48 <dmwit> It never needs to be updated in lambdabot.
19:27:01 <dmwit> And given \bot's capability for remembering updates, I'd say that's a darn good thing.
19:27:12 <dolio> Mainlining pretrolium jelly?
19:27:12 <MyCatVerbs> I suppose.
19:27:17 <dolio> That sounds like it'd just kill you.
19:27:18 <dmwit> (I personally have added hhl to the where database at least three times now.)
19:27:36 <MyCatVerbs> dolio: Probably. Hardcore, isn't it? :)
19:27:43 <dolio> Totally.
19:28:38 <Axman6> Fragsworth: oh and #haskell is probably one of the best haskell learning resources there is around
19:28:45 <gwern> @flush
19:29:41 <Eiler> > [ y | x <- [1..10], let y = 2*x, y >= 10 ]
19:29:42 <lambdabot>   [10,12,14,16,18,20]
19:29:52 <dmwit> gwern: thanks =)
19:29:54 <lament> #haskell is full of these ridiculously smart people whose main entertainment in life is explaining complicated stuff to people hundreds times less intelligent than them
19:30:15 <dmwit> s/less intelligent than them//
19:30:23 <dmwit> We just explain it hundreds of times. ;-)
19:30:26 <Axman6> like Cale and his woncderful fold explanations
19:30:34 <smorg> Fragsworth: I'm working through a few different books which all seem quite good: http://book.realworldhaskell.org/read/ http://learnyouahaskell.com/ http://en.wikibooks.org/wiki/Haskell and http://www.cs.utah.edu/~hal/docs/daume02yaht.pdf
19:30:37 <MyCatVerbs> lament: I'm not so sure about the "hundreds of times less intelligent than them" bit. Considering the quantity of people who migrate from the latter set to the former, it seems unlikely.
19:30:42 <smorg> I'll probably solidify which I like best as I go along
19:31:08 <lament> MyCatVerbs: being around smart people makes one smarter
19:32:12 <MyCatVerbs> lament: that warrants two responses. 1) Being around intelligent people certainly doesn't make one any more intelligent.
19:32:26 <lament> MyCatVerbs: i disagree!
19:32:55 <Jedai> lament: I think that depends on what you do around these people
19:33:02 <lament> MyCatVerbs: do you think intelligence is hereditary or random?
19:33:11 <Jedai> lament: and what you call intelligence of course...
19:33:15 <MyCatVerbs> lament: 2) yes, but only if one tries real hard to catch up. "Smart" is a function of how people use their brains' capacity for reasoning, not just the capacity itself.
19:33:18 <lament> MyCatVerbs: evidence seems to be against both those theories
19:33:22 <Berengal> I believe intelligence is very much based on knowledge, myself...
19:33:59 <smorg> I have craptons of knowledge... it doesn't make up for the ADHD, trust me :b
19:34:04 <MyCatVerbs> lament: I suspect that it's hereditary and dietary, and varies with general health.
19:34:09 <Berengal> I don't see myself as very smart, but I've always had a good memory, which has lead others to believe I am
19:34:13 <lament> you may believe it's based on knowledge, but i KNOW it's based on belief!
19:34:20 <idnar> hahaha
19:34:27 <BMeph> lament: My personal definition of genius is making complicated subjects understood easily. You could likely guess my opinion of bureaucracies from that. ;)
19:34:35 <lament> BMeph: :)
19:34:39 <Jedai> intelligence is probably a product of gene, environment and effort
19:34:57 <gwern> if we absorb and emit intelligence osmotically, then we will be pulled down to the average. and as this is IRC, it *is* 'pulled down'
19:35:00 <Axman6> effort pfft
19:35:11 <lament> Jedai: and environment is basically being around smart people
19:35:35 <Jedai> lament: sure it helps, if you make the effort of learning from these people
19:35:35 <smorg> Jedai: I agree. If you aren't curious, you could be very smart but utterly useless. Like trying to teach a Dog how to do math. The dog just doesn't care, even if it had the capacity.
19:35:55 <aavogt> @wn osmosis
19:35:55 <lament> plenty of very smart people don't care about math
19:36:10 <lambdabot> Error: thread killed
19:36:17 <MyCatVerbs> gwern: Not necessarily! Electronic communication has the wonderful property that it's very very easy to pick who you're going to talk to.
19:36:27 <smorg> or [insert any discipline which requires reasoning]
19:36:45 * gwern shnubs MyCatVerbs 
19:36:52 <Jedai> lament: it depends on what you call smarts
19:36:58 <Berengal> lament: Presumably because they have no use for it, and recognize that. If that's not the case then I'd say it isn't very intelligence of them
19:37:31 <aavogt> @wn diffusion
19:37:46 <lambdabot> Error: thread killed
19:38:07 <lament> speaking of math, does anyone know how would one describe the state of a lava lamp at a given moment?
19:38:12 <lament> (not a haskell question)
19:38:28 <gwern> lament: as a bunch of baryonic particles in 4D
19:38:42 <roconnor> a bundle of vibrating strings
19:38:43 <MyCatVerbs> gwern: easier than that, even. The people whom you are snubbing do not even have to know that they are being snubbed by you!
19:39:15 <lament> by "describe" i meant "model mathematically without particles"
19:39:20 <smorg> Is there some huge mathematical significance to fold that I just haven't run across yet? Everyones always talking about folds.
19:39:53 <lament> smorg: mathematical, not really
19:40:03 <BMeph> Groovy! ;p
19:40:14 <lament> smorg: but do read bananas, lenses, envelopes, and barbed wire
19:41:03 <travisbrady> smorg: might be worth checking this out www.cs.nott.ac.uk/~gmh/fold.pdf
19:41:28 <lament> smorg: also, http://foldl.com/
19:41:53 <pumpkin> don't forget foldr.com
19:42:19 <lament> pumpkin: foldr is much harder to click
19:42:25 <smorg> found http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.41.125&rep=rep1&type=pdf
19:42:40 <lament> yeah, that one
19:42:42 <aavogt> hmm, foldM.com taken
19:42:43 <Berengal> If I ever write a paper, I'm going to try my best to name it something like "Bases, who do they really belong to? How over 9000 barrel rolls performed for great good did not go alone, but took this. Also, the real subject matter."
19:43:45 <pumpkin> so if we could distinguish between data and codata in haskell, it would make sense to say that fold operates on data and scan operates on codata?
19:43:46 <lament> Berengal: i'd love to be a professor of anatomy and write a paper "How is babby formed"?
19:43:50 <pumpkin> (just reading sigfpe's post on that)
19:44:41 <mauke> http://lambda-the-ultimate.org/node/1760
19:45:38 <lament> mauke: hah
19:46:05 <smorg> Reminds me of building natural numbers in peano arithmatic
19:49:01 <roconnor> pumpkin: if we could distinguish between data and codata, where would poor data Domain = Domain (Domain -> Domain) go?
19:49:04 <roconnor> ;(
19:49:10 <pumpkin> :o
19:49:24 <pumpkin> beats me, all I know is what sigfpe's blog post told me :)
19:49:29 <mauke> off to the lambda cave!
19:49:33 <dmwit> lament: Just get vimperator; then clicking on either foldl.com's or foldr.com's link is as easy as hitting 'f' on your keyboard. =)
19:49:55 <Badger> mauke: but lambdaman, what can we do?
19:50:37 <smorg> Actually i was expecting some kind of javascript fork bomb when hitting '...'
19:50:42 <edwardk> pumpkin: note in your tweet you computed for an U.S. butts. In international units the result should be somewhat smaller. Or will more fit because the units are smaller...
19:50:47 <dmwit> Using this technique, and holding down 'f', I have managed to determine that \infty = 211+()
19:50:56 <dmwit> not sure what an instance Num () would look like, though.
19:51:24 <edwardk> er i guess that took a turn towards #haskell-blah.
19:51:34 <pumpkin> edwardk: just a little ;)
19:51:46 <pumpkin> edwardk: I'd respond to that, but people would think I'm an ***hole
19:51:52 <mauke> instance Num () where fromInteger _ = (); _ + _ = (); _ - _ = (); _ * _ = ()
19:52:55 <edwardk> Bah, you're just the one doing the measuring ;)
19:53:28 <edwardk> mauke: heh i have instances for the monoid and multiplicative instances for () in that vein ;)
19:53:34 <pumpkin> lol
19:53:42 <edwardk> er instances for the ... classes
19:54:41 <Axman6> @quote syntax error
19:54:42 <lambdabot> No quotes for this person. My brain just exploded
19:54:48 <Axman6> @quote syntax
19:54:48 <lambdabot> ghc says: Illegal binding of built-in syntax
19:54:51 <Axman6> @quote syntax
19:54:51 <lambdabot> monochrom says: Time flies like an arrow.  Fruit flies like a banana.  Syntax rules like a macro.
19:55:03 <Axman6> bleh
19:55:30 <Axman6> i was looking for "gwern: bleh. haskell is messing me up. I wondered what operator =) is, before I realized it was a syntax error, before I realized it was an emoticon" which i think is classic
19:55:48 <gwern> @quote emoticon
19:55:49 <lambdabot> gwern says: bleh. haskell is messing me up. I wondered what operator =) is, before I realized it was a syntax error, before I realized it was an emoticon
19:56:10 * gwern helps
19:56:22 <Axman6> heh
19:57:56 <dmwit> ?quote syntax.error
19:57:57 <lambdabot> gwern says: bleh. haskell is messing me up. I wondered what operator =) is, before I realized it was a syntax error, before I realized it was an emoticon
19:57:58 * dmwit too
19:58:10 <Axman6> i knew there was some syntax for spaces
19:58:31 <dmwit> it's pcre
19:59:40 <Axman6> ah right
19:59:59 <Axman6> surely ' ' matches a space?
20:00:41 <gwern> @quote syntax' 'error
20:00:41 <lambdabot> No quotes for this person. Where did you learn to type?
20:00:52 <gwern> guess not
20:01:01 <mauke> @quote a((.+)+)+[bc](?!)
20:01:01 <lambdabot> Plugin `quote' failed with: regex failed: (ReturnCode 13,"Invalid preceding regular expression")
20:01:04 * pumpkin has been coding haskell for almost 7 months!
20:01:11 <pumpkin> time flies
20:01:48 <roconnor> me has been coding haskell for almost 7 years
20:02:25 <Berengal> I've been at it for about 11 months... although with some serious time off in the middle somewhere
20:02:40 <performance> what is /lib/libtinfo.so.5 ?
20:03:02 <dmwit> ?quote gwern syntax error
20:03:03 <lambdabot> gwern says: bleh. haskell is messing me up. I wondered what operator =) is, before I realized it was a syntax error, before I realized it was an emoticon
20:03:11 <Berengal> Also, I just found a paper on L-Systems and music. Music was the reason I wrote an L-System implementation in the first place...
20:03:27 <gwern> pumpkin: but do fruit flies like banana?
20:03:30 * Berengal goes off to read
20:03:31 <dmwit> Axman6: ?quote has a slightly strange syntax; if it sees a space, it assumes everything before it is a nick, and everything after is a re.
20:03:46 <performance> Berengal: so you can generate music like plants?
20:03:47 <pumpkin> gwern: not sure :) it's funny, banana is my nick on another network :P
20:03:51 <performance> like pictures of plants
20:03:55 <pumpkin> gwern: I'd be inclined to say yes though
20:04:05 * mauke generates pictures of music
20:04:05 <Berengal> performance: plant music
20:04:08 <Berengal> Also, fractals
20:04:09 <brian6> how to understand what is the first version of ghc to contain the fix for http://hackage.haskell.org/trac/ghc/ticket/2594 ?
20:04:25 * gwern wonders if pumpkin knows the allusion and is playing along, or is just playing it straight
20:04:26 <Berengal> mauke: That was the overarching reason
20:04:39 <pumpkin> gwern: I don't!
20:04:48 <performance> Berengal: link please? i would like to read that paper too and if you want a scape goat to try your program , im here
20:04:50 <gwern> but can I believe you?
20:05:10 <pumpkin> gwern: nothing I can say will affect the situation
20:05:25 <gwern> a suspiciously meta statement!
20:05:29 <Berengal> performance: http://www.modularbrains.net/support/SteliosManousakis-Musical_L-systems.pdf
20:06:08 <pumpkin> DmdAnal
20:06:21 <pumpkin> that makes three Anals in ghc that I know of
20:06:32 <performance> Berengal: i read a lot about LM systems and  fractals, chaos theory turtle graphics :) but this was a while back.
20:06:41 <dmwit> brian6: Since the bug is closed before the release of 6.10, it's probably at least safe there.
20:07:05 <performance> but i never used any of that for anything, expect toplay with logo
20:07:13 <dmwit> brian6: But that's just a guess.  The bug is certainly sufficiently vague. =P
20:07:25 <brian6> dmwit: yeah, ok. thanks. wish the tracker showed that a little more clearly.
20:08:04 <Berengal> performance: The idea just struck me the other day. I'd been thinking about computer generated music a few weeks back, but all of a sudden I got this vision of fractals and music at the same time, so I decided to go check it out
20:08:23 <performance> did you use Haskore?
20:08:53 <Berengal> performance: Nah, I haven't gotten to the music part yet. I'm probably going to check it out once I've fine-tuned the graphics bit and added non-determinism
20:09:20 <performance> you should probably join haskell-art if you havent already
20:10:10 <Berengal> I was just about to say I'm no musician or artist in any other way yet. I barely even know what a chord is...
20:11:19 <roconnor> anyone here a font geek?
20:11:35 * pumpkin , sort of
20:12:00 <roconnor> pumpkin: do I need a san-serif font for the title on the cover of my book?
20:12:41 <performance> if for a moment you keep the whole fractal/generator part aside, i am at a loss to find a relation between a fern and any music
20:12:44 <performance> structure
20:13:38 <pumpkin> roconnor: people usually use sans-serif for titles, but it depends on whether you want a distinctive style on it
20:14:30 <Axman6> roconnor: use comic sans
20:14:35 <pumpkin> lol
20:14:40 <pumpkin> everyone's favorite :)
20:14:41 <roconnor> :)
20:14:43 <Axman6> or papyrus
20:14:44 <performance> which parameter of the strucutre of music follows which pattern of the structure of a fern?
20:14:54 <performance> but not wingdings
20:15:19 <mauke> IMPACT
20:15:27 <mauke> the image macro font
20:15:38 <roconnor> pumpkin: you can see my existing font at http://r6.ca/thesis.pdf
20:15:51 <roconnor> (I have a higher resolution background image elsewhere)
20:16:25 <Axman6> i'd go with sans there
20:16:32 <roconnor> ya
20:16:36 <roconnor> I'm coming around to that
20:17:01 <RyanT5000> what font is that? it has an interesting ampersand
20:17:54 <Berengal> performance: Well, take the dragon curve for example. It starts simple at one end, grows bigger and more complex until the middle, then smaller and simpler again until you've reached the end. Music can also follow a similar pattern, starting with a simple structure, then using only that structure to build bigger more complex structures
20:18:09 <Berengal> Then simplifying down again at the end
20:18:09 <roconnor> DejaVuSeriv
20:18:11 <roconnor> Serif
20:18:18 <lament> the arch design
20:18:20 <RyanT5000> ah, i see
20:28:47 <performance> most popular music is like that already, and is also kind of built one simple structures which repeat often
20:32:47 <roconnor> ugh, fonts are so ugly
20:32:56 <roconnor> at least DejaVuSans isn't terrible.
20:34:14 * roconnor is tempted to use bold semi-condensed for the subtitle
20:35:10 <pumpkin> roconnor: even the serif doesn't look bad, but I think a sans would look better
20:35:29 <Axman6> me too
20:41:55 <roconnor> pumpkin: http://img198.imageshack.us/img198/8722/coversans.png
21:04:12 <hackagebot> Added by RohanDrape, Sun Jun  7 04:01:57 UTC 2009.: Haskell Open Sound Control  http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hosc-0.7
21:04:32 <pumpkin> roconnor: looks better, I think
21:04:46 <mmorrow> , fft (fmap ((:+0) . fromIntegral) [0..2^14-1])
21:04:48 <lunabot>  [1.34209536e8 :+ 0.0,(-8192.000000011176) :+ 4.27228291999282e7,(-8192.0)...
21:05:37 <pumpkin> , ft (map ((:+0) . romIntegral) [0..2^14-1])
21:05:38 <lunabot>  luna: Not in scope: `ft'
21:05:41 <pumpkin> :(
21:05:48 <pumpkin> CPE
21:06:42 <wli> Discrete FFT's could be interesting, e.g. in GF(257).
21:07:03 <pumpkin> http://www.apfloat.org/ntt.html !
21:08:21 <mmorrow> , let x >< y = let f = fft . fmap (:+0); g = fmap (\(a:+_)->a) . ifft in g (zipWith (*) (f x) (f y)) in [1..4] >< [7..10]
21:08:23 <lunabot>  [86.0,80.0,86.0,88.0]
21:09:09 <mmorrow> , let x >< y = let f = fft . fmap (:+0); g = fmap (\(a:+_)->a) . ifft in g (zipWith (*) (f x) (f y)) in let a = [0.20,0.30,0.30,0.20] in a >< a
21:09:10 <lunabot>  [0.25,0.26,0.25,0.24]
21:09:13 <hackagebot> Added by RohanDrape, Sun Jun  7 04:08:34 UTC 2009.: Haskell SuperCollider  http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hsc3-0.7
21:09:21 <pumpkin> > product [7..10]
21:09:23 <lambdabot>   5040
21:09:37 <pumpkin> ah
21:10:10 <pumpkin> that's meaningless
21:10:45 <pumpkin> (my multiplication)
21:11:18 <hackagebot> Added by RohanDrape, Sun Jun  7 04:10:34 UTC 2009.: Haskell Meapsoft Parser  http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hmeap-0.7
21:15:20 <pumpkin> , fft ([1..4] :: [Complex Double])
21:15:22 <lunabot>  luna: No instance for (GHC.Enum.Enum
21:15:29 <pumpkin> oh :(
21:15:53 <pumpkin> if they're going to make a shitty instance of Enum for Double, they may as well make one for Complex too
21:16:01 <mmorrow> heh
21:16:19 * mmorrow refuses to use the Double Enum out of principle :)
21:16:25 <pumpkin> , fft (map fromIntegral [1..4])
21:16:27 <lunabot>  [10.0 :+ 0.0,(-2.0000000000000004) :+ 1.9999999999999996,(-2.0) :+ 0.0,(-...
21:17:02 <pumpkin> , map (^2) . fft . map fromIntegral $ [1..4]
21:17:04 <lunabot>  [100.0 :+ 0.0,3.552713678800501e-15 :+ (-8.0),4.0 :+ (-0.0),(-4.440892098...
21:17:10 <pumpkin> , ifft . map (^2) . fft . map fromIntegral $ [1..4]
21:17:12 <lunabot>  [26.0 :+ (-2.220446049250313e-16),20.0 :+ (-2.6107046212364704e-15),26.0 ...
21:17:25 <mmorrow> here's a frequency spectrum of a .wav computed with lunabot's fft http://moonpatio.com/images/swinglow.png
21:17:28 * wli is completely falling down on trying to implement CPO-STV.
21:17:39 <pumpkin> swing low, sweet chariot
21:18:01 <mmorrow> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1902
21:18:28 <pumpkin> , map realPart . ifft . map (^2) . fft . map fromIntegral $ [1, 2, 1, 1]
21:18:30 <lunabot>  [6.0,6.0,7.0,6.0]
21:18:44 <mmorrow> ahhh, realPart... i was trying to remember that..
21:20:19 <hackagebot> Added by RohanDrape, Sun Jun  7 04:19:49 UTC 2009.: Haskell data flow library for audio processing  http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hdf-0.7
21:24:04 <Axman6> how nice, hackagebot gives useful info now
21:24:26 <Axman6> , typ fft
21:24:27 <lunabot>  luna: Couldn't match expected type `GHC.Base.String'
21:24:35 <Axman6> , typ "fft"
21:24:38 <lunabot>  "[Data.Complex.Complex GHC.Types.Double]\n-> [Data.Complex.Complex GHC.Ty...
21:24:59 <Axman6> , text . typ "fft"
21:25:01 <lunabot>  luna: Couldn't match expected type `a -> GHC.Base.String'
21:25:05 <pumpkin> , typ "typ"
21:25:08 <lunabot>  "GHC.Base.String -> GHC.Base.String"
21:25:10 <Axman6> , text . typ $ "fft"
21:25:13 <lunabot>  [Data.Complex.Complex GHC.Types.Double]
21:25:13 <lunabot>  -> [Data.Complex.Complex GHC.Types.Double]
21:26:21 <hackagebot> Added by RohanDrape, Sun Jun  7 04:25:25 UTC 2009.: haskell supercollider graph drawing  http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hsc3-dot-0.7
21:27:34 <pumpkin> wow, this is really annoying, I can't ctrl+c out of the ghc testsuite
21:28:02 <pumpkin> a kill did it :)
21:29:21 <hackagebot> Added by RohanDrape, Sun Jun  7 04:28:55 UTC 2009.: Unsafe Haskell SuperCollider  http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hsc3-unsafe-0.7
21:30:53 <mmorrow> Axman6: http://hackage.haskell.org/packages/archive/pure-fft/0.2.0/doc/html/src/Numeric-FFT.html#fft
21:31:55 <pumpkin> I love how elegant the dft function is
21:32:12 <pumpkin> minus the !! :P
21:38:02 <malouin> 0607043428:~/src$ ls
21:38:02 <malouin> darcs  targz
21:38:22 <malouin> luckily the the alphabet and UNIX are consonant-voice sensitive, otherwise these would be the same directory.
21:43:24 <hackagebot> Added by RohanDrape, Sun Jun  7 04:42:19 UTC 2009.: Haskell SuperCollider SoundFile  http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hsc3-sf-0.7
21:45:15 <BMeph> malouin: Which alphabet - English? 'Cause there's no "T" in Hawaiian (I remember that from a TV special hosted by...Mr. T). :)
21:46:04 * wli could probably use someone turkey walking me through CPO-STV implementation.
21:50:26 <hackagebot> Added by RohanDrape, Sun Jun  7 04:49:49 UTC 2009.: Haskell Music Theory  http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hmt-0.1
21:54:53 <mmorrow> pumpkin: ah yeah, i forgot about that (!!) hiding in there... it could be eliminated surely (although the motivation is low since it's slow anyways :)
21:56:19 <mmorrow> hmm, actually i'm not sure if you could eliminate (in the sense that any way you cut it you'll be doing the same thing.. now that i look more closely)
21:56:37 <mmorrow> oh wait
21:57:25 <mmorrow> yeah, it can go, that used to be in the fft too, but got replaced with the `go' in that one
21:57:58 <mmorrow> good thing fft only calls dft with lists of length 2 :)
21:59:56 <dmwit> You know what's a little bit frustrating?  Bits of development where you spend a really long time doing something that are totally invisible in the front-end.
22:02:12 <pumpkin> instead of feeling like your work won't be appreciated, feel smug that you know something they don't ;)
22:02:41 <pumpkin> (that's BS, I know the feeling)
22:07:07 <malouin> BMeph: ASCII / latin
22:08:06 <malouin> ;)
22:13:34 <licksjp> Hello
22:15:15 <BMeph> Hello, licksjp. Just soaking in the hask-tosphere, or do you have a specific concern? ;)
22:18:02 <licksjp> I have installed haskell in my fedora10
22:18:23 <licksjp> I don't find the hugs
22:18:31 <licksjp> where is it?
22:19:23 <licksjp> I installed yum
22:22:11 <Tarrant> licksjp: Take a look for ghc
22:24:54 <licksjp> Does talk type command lose?
22:26:08 <Tarrant> licksjp: ?
22:26:55 <licksjp> Does talk type command  lose in huskell?
22:27:24 <licksjp> Tarrant,ghc is only compiller
22:28:26 <inimino> licksjp: try ghci
22:29:02 <licksjp> oh
22:29:34 <licksjp> inimino,  see the talk line screen
22:29:44 <licksjp> inimino, ty
22:49:39 <hackagebot> Added by BryanOSullivan, Sun Jun  7 05:48:55 UTC 2009.: An efficient packed Unicode text type  http://hackage.haskell.org/cgi-bin/hackage-scripts/package/text-0.3
23:08:36 <licksjp> See you,again
23:12:39 <Twey> Hm... I could have sworn there used to be a #haskell-jp
23:12:56 <inimino> "talk line screen" was clear enough ;-)
23:13:01 <Twey> Hehe
23:13:47 <Twey> That's actually a pretty good kenning
23:13:50 <inimino> "does Haskell have an REPL?" "No, even better..."
23:13:55 <Twey> We should use that name officially
23:13:56 <Twey> Yeah :-D
23:13:59 <Twey> We have a TLS!
23:14:26 <inimino> ^.^
23:15:16 <Twey> Hm
23:15:28 <Twey> Why are there no Hackage docs navigable from http://hackage.haskell.org/cgi-bin/hackage-scripts/package/text-0.3?
23:16:18 <Ycros> usually it means the build failed... but usually there's also a log file. Maybe it didn't get built?
23:16:52 <Ycros> Twey: see how when you go to 0.2 is says "built by: ghc-6.10"
23:17:55 <Ycros> Twey: seeing as it was uploaded not too long ago, the docs probably haven't been built yet
23:18:03 <Twey> Ah
23:18:13 <bos> Better Unicode support in the text package: http://bit.ly/9E6sa
23:18:36 <bos> I only uploaded it a few minutes ago
23:18:55 <Ycros> Twey: you can generate your own docs, if you run "cabal haddock"
23:20:02 <Ycros> or maybe cabal install with --enable-documentation
23:23:15 <Twey> bos: *nods*
23:32:25 <dmwit> > '\0xdf'
23:32:27 <lambdabot>   <no location info>:
23:32:27 <lambdabot>      lexical error in string/character literal at chara...
23:32:31 <dmwit> > 0xdf
23:32:32 <lambdabot>   223
23:32:34 <dmwit> > '\223'
23:32:35 <lambdabot>   '\223'
23:32:54 <dmwit> Oh, I get it.
23:34:12 <idnar> > '\xdf'
23:34:14 <lambdabot>   '\223'
23:34:34 <idnar> > '\0223'
23:34:35 <lambdabot>   '\223'
23:34:57 <idnar> > ord '\223'
23:34:58 <lambdabot>   223
23:35:00 <idnar> wtf
23:35:20 <idnar> isn't that an octal number everywhere else?
23:35:27 <dmwit> > 0o223
23:35:29 <lambdabot>   147
23:35:32 <dmwit> > '\0o223'
23:35:33 <lambdabot>   <no location info>:
23:35:33 <lambdabot>      lexical error in string/character literal at chara...
23:35:37 <dmwit> > '\o223'
23:35:39 <lambdabot>   '\147'
23:35:49 <dmwit> idnar: ...no. =)
23:36:02 <idnar> by "everywhere else" I mean "other programming languages"
23:36:10 <dmwit> Oh, well, then yes.
23:36:11 <idnar> oh well, I always use hex escapes anyway
23:36:20 <idnar> (I mean, octal? wtf)
23:48:14 <jimmyjazz14> question about monads, I am using a function that does returns (IO Bool) and I was going to use it in a if/else statement but if takes Bool
23:48:41 <dmwit> do notation time!
23:48:57 <dmwit> do { x <- thingWithAnIOBool; if x then trueThing else falseThing }
23:49:17 <jimmyjazz14> ah yes
23:49:34 <BMeph> do { x <- thingWithAnIOBool; return $ if x then trueThing else falseThing }
23:49:37 <jimmyjazz14> its there a way around having to unpack to x like that?
23:49:42 <jimmyjazz14> *is
23:49:46 <dmwit> Nope! =)
23:50:27 <jimmyjazz14> ah, just seems like a little more code then would normally seem needed, but not a big deal
23:54:14 <jimmyjazz14> I get `The last statement in a 'do' construct must be an expression` when using if/else
23:54:33 <Twey> fmap (trueThing ?? falseThing) thingWithAnIOBool
23:54:42 <dmwit> jimmyjazz14: I'm guessing indentation.
23:54:44 <dmwit> ?hpaste
23:54:44 <lambdabot> Haskell pastebin: http://hpaste.org/new
23:54:46 <idnar> @type (??)
23:54:48 <lambdabot> Not in scope: `??'
23:54:53 <idnar> wut?
23:54:57 <Twey> If you have ‘(y ?? n) p = if p then y else n’
23:55:01 <Twey> idnar: Not built-in :(
23:55:06 <idnar> ah
23:55:31 <idnar> like C's ?: except backwards
23:55:49 <idnar> I suppose you can't exactly do p (y ?? n) = ...
23:55:51 <jimmyjazz14> dmwit: indentation was the problem, damn whitespace
23:56:14 <Twey> idnar: The point is that it's backwards.
23:56:23 <idnar> that too
23:56:25 <Twey> p (y ?? n) would be if'
23:56:35 <idnar> I was just getting sidetracked
23:56:42 <Twey> You never want to curry on the no-branch; you want to curry on the predicate
23:57:39 <jimmyjazz14> should I switch to Hugs while I am learning haskell? GHC error messages throw me off a lot and I had heard Hugs was better about that.
23:57:46 <dmwit> nah
23:58:00 <dmwit> Just take your time.
23:58:09 <dmwit> They're readable enough with a little practice.
