00:00:32 * ski wonders if it would be better to take this to #haskell-overflow ..
00:00:37 <adu> sure
00:11:43 <kniu> so I'm trying to use parsec 3.0.0
00:12:11 <kniu> how come I need to "add an instance declaration for (Stream s1 m1 Char)"?
00:14:36 <ivanm> because there isn't one, but you're wanting there to be one?
00:15:44 <sjanssen> kniu: parsec 3 is considerably different from previous versions -- it generalizes the parsed type from lists to any Stream
00:16:13 <kniu> huh.
00:16:26 <sjanssen> kniu: when you get this error, it essentially means you haven't been explicit enough in deciding what types you're working with
00:16:43 <kniu> alrighty them.
00:17:03 <kniu> where's the documentation for this "Stream" class so I can make an instance?
00:17:27 <kniu> googling turns up nothing.
00:17:35 <sjanssen> you probably don't want to make an instance
00:17:53 <sjanssen> you just need to arrange your code so that GHC knows you're using the list instance specifically
00:18:20 <kniu> I don't understand.
00:18:22 <kniu> how do I do that?
00:18:59 <sjanssen> I can't say without seeing some code
00:21:23 <Peaker> I wish tuples were OK as sections: (blah,)
00:23:00 <ski> seconded
00:24:05 <Axman6> ((,) blah)? :\
00:24:32 <ivanm> Axman6: uglier if you want (,blah): (flip (,) blah)
00:24:41 <Axman6> yeah :(
00:25:11 * sjanssen wants list sections
00:25:22 <ivanm> sjanssen: oh? example?
00:25:50 <sjanssen> [,2,,,5,6,] 1 3 4 7 == [1 .. 7]
00:26:00 <ivanm> hmmmmm.....
00:26:02 <copumpkin> that'd be crazy
00:26:34 <ivanm> sjanssen: for matching as well, or just as a function?
00:26:42 <ivanm> i.e. [,2,] == [_,2,_]
00:26:55 <sjanssen> as a function, it doesn't really make sense as a pattern
00:27:04 <ivanm> *nod*
00:27:18 <ski> (case lookup k env of Nothing -> ; Just n -> foo n) (error "lookup failed")
00:28:03 <Peaker> @src foldl
00:28:04 <lambdabot> foldl f z []     = z
00:28:04 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
00:28:05 <Peaker> @src foldl'
00:28:05 <lambdabot> foldl' f a []     = a
00:28:06 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
00:28:11 <Peaker> why is foldl' not defined in terms of foldl?
00:28:23 <sjanssen> Couldn't match expected type `a -> t' against the inferred type `Maybe a1'
00:28:30 <sjanssen> Peaker: it can't be
00:28:31 <ski> Peaker : how ?
00:28:39 <copumpkin> f $! ?
00:28:44 <sjanssen> nope
00:28:47 <copumpkin> oh wrong way
00:29:47 <Peaker> oh, I see
00:30:27 <sjanssen> foldl could be defined in terms of foldl', but that's a bit silly
00:30:36 <Axman6> how?
00:30:43 <sjanssen> and, of course, all of them can be expressed in terms of foldr
00:31:17 <sjanssen> Axman6: data MakeLazy a = MakeLazy a; foldl = foldl' stuffWrappingAndUnwrappingMakeLazy
00:33:47 <sjanssen> foldl f z xs = unMakeLazy $ foldl' (\(MakeLazy y) x -> MakeLazy (f y x)) (MakeLazy z) xs
00:33:54 <Peaker> can foldl be expressed *directly* via foldr? (e.g without wrapping the foldr result with extra code)
00:35:09 <sjanssen> Peaker: foldl f z xs = foldr (\x xs y -> xs (f y x)) id xs z
00:35:32 <Peaker> apply-to-z there is "extra code" after foldr :-)
00:35:36 <sjanssen> I don't think your "directly" distinction is particularly meaningful
00:37:11 <sjanssen> foldl f z xs = flip ($) z $ foldr (\x xs y -> xs (f y x)) id xs -- now stuff is before foldr, happy?
01:07:59 <Peaker> feedback would be appreciated on   http://wiki.github.com/yairchu/generator
01:10:11 <copumpkin> whoa
01:10:26 <copumpkin> who's yairchu?
01:10:35 <copumpkin> :P
01:11:53 <ivanm> Peaker's company IIRC...
01:11:57 <ivanm> Peaker: what does it generate?
01:12:08 * Axman6 thought it was a pokémon
01:12:09 <Peaker> my friend, not company :-)  I brought him to Haskell a few months ago
01:12:37 <copumpkin> Peaker: if I just use a regular take on the toList, it'll still run all the IO, right?
01:12:39 <Peaker> and we talked a lot about MList/etc, and he misinterpreted my explanation of Iteratee to create this variant of MList, which is nicer, IMO :-)
01:12:45 <Peaker> copumpkin: yeah
01:12:52 <copumpkin> looks cool :)
01:13:09 <Peaker> copumpkin: its not lazy I/O, effects are quarantined as they should be :-)
01:13:10 <copumpkin> not sure that counts as good feedback :P
01:13:20 <copumpkin> yeah :)
01:13:50 <Peaker> I think Haskell still has some basics that are badly covered by the stdlib, and if this thing takes off, I think one less area will remain a problem
01:14:19 * Axman6 doesn't like all the lifts
01:14:34 <Peaker> Axman6: maybe we should get syntactic sugar for monad transformers then?
01:14:59 <Axman6> and i can't see how the stuff bring printed is supposed to be related to the stuff being yielded
01:15:00 <Peaker> or every IO action in Haskell' should become polymorphic to MonadIO?
01:15:16 <Peaker> Axman6: the idea is that you can have arbitrary effects inter-twined between your yields of values
01:15:22 <Peaker> Axman6: you can read from a socket before yielding the next value
01:15:24 <Axman6> i see
01:16:29 * Axman6 thinks you should all go out and test his new TernaryTree package for bug^H^H^Hawesomeness
01:22:15 <Peaker> ok, I can't figure out a nice way to consume multiple producers at the same time.. I wonder how Iteratee handles this problem
01:22:28 <Peaker> (interlacing producers)
01:26:36 <ivanm> @seen Cale
01:26:37 <lambdabot> Cale is in #ghc, #haskell-in-depth, #haskell-overflow and #haskell. I last heard Cale speak 4h 13m 54s ago.
01:34:08 <Peaker> cool!  figured out how to do multiple consumers.. Needs a lot of auto-lifters
01:34:59 <Peaker> http://github.com/Peaker/generator/blob/1af4b6eb759f980b43ecc5ad173c2efc17417129/testProducers.hs
01:35:32 <nainaide> [1,3,4] >>= replicate 2
01:35:45 <nainaide>  replicate 2 [1,3,4]
01:36:21 <nainaide> What difference between  [1,3,4] >>= replicate 2 and replicate 2 [1,3,4], please?
01:37:23 <nainaide> > [1,3,4] >>= replicate 2
01:37:25 <lambdabot>   [1,1,3,3,4,4]
01:37:33 <Peaker> > replicate 2 [1,3,4]
01:37:33 <nainaide> >  replicate 2 [1,3,4]
01:37:36 <lambdabot>   [[1,3,4],[1,3,4]]
01:37:36 <lambdabot>   [[1,3,4],[1,3,4]]
01:38:00 <nainaide> I had thought the result should be same
01:39:24 <Peaker> nainaide: replicate 2 [1,3,4] just replicates that value twice, which happens to be a list.  [1,3,4] >>= replicate 2    runs replicate 2 on each value of [1,3,4] and concats the results
01:40:50 <yitz> > concatMap (replicate 2) [1,3,4]
01:40:51 <lambdabot>   [1,1,3,3,4,4]
01:41:20 <nainaide> yeah, it is clear, concatMap do that
01:41:55 <nainaide> that is what List Monad does
01:42:07 <yitz> Peaker: there's not going to be one way, it depends on exactly how you want them to interlace/interact
01:42:46 <Peaker> yitz: I wanted something like this: http://github.com/Peaker/generator/blob/1af4b6eb759f980b43ecc5ad173c2efc17417129/testProducers.hs
01:50:49 <Peaker> what was that alternate monad transformer library without N^2 lifter explosion?
02:07:14 <nainaide> a silly question: how to print out [1..10] ?
02:08:38 <aaafff1> @nainaide in the interpreter or not in the interpreter?
02:08:39 <lambdabot> Unknown command, try @list
02:08:57 <aaafff1> nainaide: in the interpreter or not in the interpreter?
02:09:05 <yairchu> nainaide: putrStrLn "out [1..10]"
02:09:22 <nainaide> yairchu, out, got it. thanks
02:09:50 <nainaide> > putStrLn "out [1..10]"
02:09:52 <lambdabot>   <IO ()>
02:09:57 <nainaide> :)
02:10:08 <yairchu> > [1..10]
02:10:10 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
02:10:23 <nainaide> aaafff1, In the interpreter
02:10:39 <nainaide> > putStrLn [1..10]
02:10:41 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
02:10:41 <lambdabot>    arising from the literal `1...
02:10:56 <aaafff1> [1..10] doesn't do it?
02:11:08 <nainaide> aaafff1,  so how
02:11:19 <aaafff1> [1..10]
02:11:22 <aaafff1> should print
02:11:29 <aaafff1> [1,2,3,4,5,6,7,8,9,10]
02:11:48 <Beelsebob> nainaide: putStrLn accepts a string
02:11:51 <Beelsebob> not a list of numbers
02:11:52 <maltem> Yeah see, they asked for printing out [1..10], not [1,2,3,4,5,6,7,8,9,10]
02:12:00 <nainaide> :t putStrLn
02:12:01 <lambdabot> String -> IO ()
02:12:04 <Beelsebob> print accepts anything showable
02:12:08 <Beelsebob> @type print
02:12:09 <lambdabot> forall a. (Show a) => a -> IO ()
02:12:11 <nainaide> :t print
02:12:12 <lambdabot> forall a. (Show a) => a -> IO ()
02:12:19 <Beelsebob> @src print
02:12:19 <lambdabot> print x = putStrLn (show x)
02:13:14 <nainaide> Got it, I spend  a week in understand Monad , meanwhile forget all preivous learned. :)
02:13:30 <Beelsebob> hehe
02:13:43 <Beelsebob> have you learned all the dependancies for monads?
02:13:49 <Beelsebob> like functors
02:13:51 <Beelsebob> and applicatives
02:13:57 <Beelsebob> ?
02:14:53 <nainaide> Beelsebob, yes, I lost in the <real world in haskell >  but find the way from "all about monad" wiki
02:15:18 <Beelsebob> :)
02:28:13 <yitz> Peaker: sorry, had to answer an important call
02:28:56 <yitz> Peaker: why would you want that? Python generators are so awkward compared to Haskell laziness
02:29:20 <Peaker> yitz: Haskell laziness is good only for pure values
02:29:32 <Peaker> yitz: Python generators are nice for explicit ordering of lazy effects
02:29:32 <Twey> Not really
02:29:41 <Peaker> Twey: why not? Lazy I/O sucks
02:29:52 <Twey> Only in certain cases
02:29:57 <yitz> Peaker: no, but it is indeed inherently more subtle.
02:30:55 <yitz> Peaker: I agree, What scenario are you thinking of?
02:31:14 <Peaker> yitz: code that handles server requests or abstracts socket protocols, or whatever
02:31:24 <Peaker> Twey: Non-trivial cases, you mean? :-)
02:31:50 <yitz> Peaker: Generators are nice for Python where laziness doesn't really exist at all without them.
02:32:15 <yitz> Peaker: STM
02:32:36 <Twey> Peaker: Well, if you count half of GNU as trivial :-P
02:33:06 <yitz> For Haskell they're pretty ugly though.
02:33:26 <lament> yitz: python generators are quite nice compared to haskell strictness
02:33:36 <Peaker> yitz: generators are also nice for lazy effects
02:33:50 <Peaker> yitz: That's why Iteratee exists (and now we want to create ConsumerT/ProducerT)
02:33:52 <yitz> Peaker: they are usable for it but not nice
02:33:57 <Peaker> Twey: Yeah, half of GNU is trivial
02:34:11 <Peaker> yitz: why not nice?
02:34:15 <yitz> Peaker: Iteratee is just fancy ListTDoneRight I think
02:34:26 <Peaker> yitz: No, its not like ListT
02:34:32 <yitz> s/fancy/obfuscated/
02:34:42 <Peaker> yitz: Iteratee has no backtracking/etc
02:34:44 <Twey> Peaker: Well-designed software is trivial
02:34:53 <Twey> Trivial composition of trivial parts
02:35:02 <Peaker> Twey: Lazy I/O has serious issues with resource leaks, performance, error handling
02:35:10 <Peaker> Twey: it is *deceptively* trivial
02:35:21 <yitz> Peaker: neither does ListT unless you introduce a StateT. And you can layer State on top of Iteratee, same thing.
02:35:24 <Vq^> Peaker: isn't that just an implementation issue?
02:35:26 <Twey> Only if looked at as a whole does it become complicated
02:36:15 <Peaker> yitz: I don't think you Iteratee is like ListT.. Its a reversal-of-control, where the producer has control and the consumer can only take one element at a time, rather than the other way around
02:36:36 <Peaker> Twey: Lazy I/O is not a solution -- its a "cheat" or workaround, sticking effects into pure values that cannot even reflect errors in them properly
02:37:42 <Twey> The values can't — the point of lazy IO is that you don't care about error-handling in the functions that work with the values
02:38:03 <yitz> Twey: lazy IO was a simple hack from the early days. in very simple cases it works, but it's not really the right solution.
02:38:06 <Twey> The generating function can handle errors, close the stream, or whatever
02:39:39 <Twey> yitz: So what's your solution to Peaker's problem?
02:40:32 <Peaker> Twey: when do you realistically not care about error handling?
02:40:48 <Peaker> Twey: even "half of GNU" cares about error handling
02:41:02 <Peaker> Twey: a "cat" that just silently swallows errors is not one I'd like to use!
02:41:09 <Twey> Peaker: You don't not care about error handling — you simply don't care about error handling further up the stack
02:41:28 <Twey> The generating function can handle them if it's able; if not, it just stops providing items
02:41:31 <Peaker> Twey: but there's no end-all way to handle errors
02:41:36 <yitz> For that kind of scenario you'd use STM, or Chans. For other things, lazy Bytestrings. There's currently no general solution.
02:41:38 <Twey> (and maybe logs them or whatever)
02:41:44 <Peaker> Twey: Stopping to provide items == Silently swallowing the error
02:42:02 <Peaker> yitz: that's what yairchu and me are trying to solve (And Iteratee too)
02:42:04 * Twey shrugs.
02:42:19 <Twey> You could also give the items an error-capable type
02:42:25 <yitz> Peaker: Python generators won't do it.
02:42:41 <Peaker> yitz: why not?
02:42:52 <yitz> Unless you improve them in a major way.
02:43:02 <Twey> data Item = Line String | ErrorOnFire
02:43:05 <Peaker> yitz: we do improve them (add type-safety/etc)
02:43:23 <yitz> Peaker: how do write itertools.chain in Python?
02:43:30 <Peaker> Twey: then you run into composability issues. Solve them and you end much closer to Iteratee, except without proper resource management
02:43:33 <yitz> s/do/do you/
02:43:51 <Peaker> yitz: def chain(*is): for i in is: for x in i: yield x
02:44:30 <yitz> Peaker: right. you can't compose them - you have to iterate over them explicitly every time.
02:44:56 <yitz> Peaker: in practice, that always creates a huge mess when you work with them seriously.
02:45:19 <Peaker> yitz: nah, chain *is* the compositor
02:45:30 <Peaker> yitz: also, Haskell provides more freedom with such values
02:46:23 <yitz> Peaker: so that's the thing. Haskell laziness is really fundamentally more powerful than Python generators. You have to harness that.
02:47:08 <Peaker> yitz: Example code
02:47:19 <Peaker> yitz: I haven't seen an example that won't look nice with Iteratee/Consumer/Producer
02:47:31 <Peaker> (I think Iteratee may have a problem interlacing effects and consumptions, I'm not sure)
02:48:21 <FunctorSalad> is there any difference between "iteratee" and "consumer"?
02:49:34 <Saizan_> Peaker: have you pasted some of the code?
02:49:54 * Saizan_ joined in the middle of the conversation
02:50:09 <Peaker> Saizan_: yeah
02:50:25 <Peaker> FunctorSalad: yeah, different from yairchu's/mine consumerT
02:50:28 <Peaker> Saizan_: http://github.com/yairchu/generator/tree/master
02:50:38 <Peaker> Saizan_: particularly http://github.com/yairchu/generator/blob/0a46150d5adb5177657ce6f9956bc05f2d014228/testProducers.hs
02:52:55 <Saizan_> Peaker: can i generate a new stream incrementally by consuming another?
02:53:55 <yairchu> why not? :)
02:53:57 <Peaker> Saizan_: there're currently 2 ways to build a new stream:  via explicit cons operations/imap/etc, or via ProducerT monad actions
02:54:17 <Peaker> Saizan_:  one way to do it: imap :: Monad m => (a -> m b) -> Producer a m -> Producer b m
02:54:54 <Peaker> Saizan_: another way would be to use ProducerT where your inner monad is a ConsumerT of another consumer (I think, haven't tried this yet :-)
02:55:21 <Peaker> yairchu: btw: it should probably be   Producer m a -> Producer m b
02:55:26 <Peaker> (common convention)
02:55:47 <Peaker> yairchu: do you think the ProducerT with ConsumerT inside would work?
02:56:20 <yairchu> maybe I should check.. :)
02:57:37 <zebrafinch> how does {-# SPECIALIZE #-} interact with newtypes?
02:58:01 <Peaker> I'll check :)
03:00:43 <Saizan_> don't you end up peforming side effects twice with that definition of ProducerT?
03:01:20 <edmoore> Hi everyone, I've come on here because I wanted to have a crack at Project Euler and several people have told me that it is an excellent excuse to learn Haskell too. Any other Eulereans around?
03:01:37 <Peaker> Saizan_: ProducerT is still broken there, yeah. We could use your help :-)
03:02:05 <Peaker> Saizan_: It doesn't always execute it twice, only in some cases
03:02:18 <Saizan_> Peaker: uhm, i see
03:02:46 <Axman6> edmoore: i've done a fair few problems there :)
03:02:52 <Saizan_> you've to nest it in the "proper" way to trigger the duplication
03:03:06 <edmoore> Axman6: cool - in Haskell?
03:03:09 <Axman6> yep
03:03:12 <Axman6> all in haskell
03:03:23 <Axman6> many of the problems are well suited to haskell
03:03:50 <Saizan_> Peaker: testGenerators.hs has an example of this?
03:04:10 <Saizan_> *testProducers.hs
03:04:15 <edmoore> So I hear.
03:04:19 <edmoore> I may dive in then
03:04:41 <Axman6> well, dive into haskell first, then use PE to get familliar with the language
03:04:59 <Peaker> Saizan_: example of producerT using a consumer?
03:05:34 <edmoore> Probably jsut a googleable question, but since I'm here I may aswell ask: Do you have a prefered tutorial? My Programming experience is limited to c/c++, matlab and that's about it. I sort of get the functional paradign, I *think*, but I won't know if that's the case until I get my teeth sunk in.
03:06:03 <Saizan_> Peaker: of duplicating side-effects because of the bug in ProducerT
03:06:22 <edmoore> I'm an engineering student so I have little formal background in compsci, so apologies if these are a little too basic.
03:06:29 <Axman6> edmoore: it's not really a paradigm...
03:06:31 <Peaker> Saizan_: Oh, yairchu has an example I think
03:06:47 <Peaker> Saizan_: I'm not sure whether ProducerT is right or whether Producer itself should be ProducerT instead
03:06:56 <Axman6> edmoore: best place to start is probable learn you a haskell for great good:
03:06:59 <Axman6> @where lyah
03:07:00 <lambdabot> www.learnyouahaskell.com
03:07:03 <Axman6> ^^^
03:08:15 <edmoore> ha, what an awesome looking tutorial
03:08:18 <edmoore> thanks
03:08:37 <McManiaC> http://book.realworldhaskell.org/read/
03:08:41 <Axman6> wow, i just managed to make my ternary tree Data.Binary instance heaps more efficient (space wise). and exactly the same code works for both my TernarySet and TernaryMap types :D
03:08:43 <McManiaC> thats where ive learned it
03:09:04 <McManiaC> but lyah if great too
03:09:30 <edmoore> McManiaC: I'll try that too
03:09:32 <edmoore> tyvm
03:09:37 <Axman6> i recommend lyah over rwh, i think rwh needs some work for be more beginner friendly. BONUS has done a great job with lyah
03:09:40 <Axman6> BONUS++
03:09:59 <edmoore> i'll try lyah first
03:10:06 <McManiaC> edmoore: just dont try to do *everything* there
03:10:14 <m4k3r> i'm reading those books ^^, but i love BONUS's one
03:10:20 <McManiaC> those jason parsers etc are kinda strange
03:10:26 <Axman6> yeah
03:10:40 <Axman6> i didn't like the json stuff, or the binary file thingo
03:10:40 <m4k3r> oh, * BONUS'
03:10:47 <McManiaC> jup
03:11:07 <Axman6> haven't really touched the book since there
03:11:15 <McManiaC> that "barcode scanner" was really strange too
03:11:15 <McManiaC> ^^
03:11:22 <Axman6> yeah
03:11:34 <McManiaC> but the basics and the monad part is great
03:12:57 <Axman6> well i'm quite impressed with myself. i've managed to make a Data.Binary instance that takes a datatype data StringMap a = SNode !Char !(Maybe a) !StringMap !StringMap !StringMap | SEnd and compresses it down to 2 bytes per SNode and one byte for the SEnd (and often no bytes at all for SEnd)
03:14:31 <yairchu> Peaker, Saizan_: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6316#a6316
03:21:49 <mopped> > zipWith (+) [1,2,3] [2,3]
03:21:50 <lambdabot>   [3,5]
03:23:50 <mopped> Can somebody explain to me how fibs = 0 : 1 : zipWith (+) fibs (tail fibs) works? I understand that it adds the nth item to the nth+1 item (obviously) but im not sure how the recursion keeps on going
03:23:59 <Saizan_> yairchu: how do i run it?
03:24:16 <yairchu> Saizan_: execute $ imap print intProducer
03:24:31 <Gracenotes> @src zipWith
03:24:32 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
03:24:32 <lambdabot> zipWith _ _      _      = []
03:25:57 <mopped> hmm
03:26:01 <Saizan_> yairchu: i get http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6316#a6317
03:26:19 <Saizan_> > let ones = 1 : ones in ones
03:26:21 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
03:26:30 <yairchu> Saizan_: instead of having the prints interleaved. that's the problem
03:26:30 <Saizan_> mopped: do you understand how that works? ^^
03:26:41 <mopped> yes
03:26:52 <mopped> I guess it's the fibs AND tail fibs that is throwing me
03:27:26 <Gracenotes> both (fibs) and (tail fibs) are working from the same list: values in Haskell are evaluated by need, and the part of the list that's already evaluated is stored for subsequent usage, wherever
03:27:47 <maltem> mopped: When you print out fibs, the first thing it notices is that the first two values are 0 and 1, so those are printed right away. Next, you notice that fibs starts with 0:1:..., whereas (tail fibs) starts with 1:..., so clearly the first element of (zipWith (+) fibs (tail fibs)) is 0+1 = 1.
03:28:28 <maltem> so now you have 0 : 1 : 1 : ...
03:28:59 <Axman6> that fibs example is actually quite hard to explain on IRC
03:29:01 <Saizan_> denotationally you could expand the definition of fibs on the spot, operationally the thunks form a cyclic graph in memory
03:29:09 <maltem> Axman6, yes, I'm noticing that
03:29:19 <maltem> It would be better to write each step out
03:29:27 <Axman6> indeed
03:29:30 <maltem> But that's too much work to do on IRC :)
03:30:06 <mopped> so I have 0 : 1 : 1 : .., does zipWith just move ahead and do 1+1, so 0 : 1 : 1 : 2, and then it steps again so 1 + 2, so 0:1:1:2:3: etc?
03:30:19 <Axman6> basically
03:30:37 <mopped> but wont zipWith be called again when invoking fibs and (tail fibs) at each step?
03:30:53 <Axman6> mopped: the important part to notice is that the definition is calling itself, and the only way that can happen is with laziness
03:30:57 <Saizan_> no zipWith is called only once
03:31:07 <Gracenotes> mopped: when zipWith steps, you'll note it separates a list into (x:xs), so it's not like it has to look through the whole list: the recursive call is zipWith f xs ys.
03:31:08 <Saizan_> it just recurses on the whole list
03:31:12 <Axman6> it's fibs that gets called many times
03:31:17 <Axman6> well, sort of
03:31:52 <Saizan_> you don't really call "fibs" many times, you continue on the sublists
03:31:59 <Gracenotes> and combine that with the fact that both arguments for zipWith are the same list, but one is looked through one step ahead of the other
03:32:16 <Gracenotes> here's another example of recursing at different points on the same list...
03:32:20 <Gracenotes> > let halve xs = go xs xs where go (x:xs) (_:_:zs) = first (x:) (go xs zs) ; go xs _ = ([], xs) in halve [1..20]
03:32:22 <lambdabot>   ([1,2,3,4,5,6,7,8,9,10],[11,12,13,14,15,16,17,18,19,20])
03:32:47 <mopped> so instead of thinking of it like 0 : 1 : zipWith (+) (0 : 1 : zipWith (+) (..)) (1:zipWith (+) (..), think of it just recurring on itself?
03:33:08 <Axman6> yeah
03:33:09 <mopped> it just looks at the list its in, rather than creating a sort of new one..
03:33:21 <Saizan_> yup
03:33:27 <mopped> ah, i understand, thanks
03:34:02 <Saizan_> you'll get to the same result eventually, but by sharing the results its obviously more efficient
03:34:36 <Saizan_> s/results/tails/
03:34:38 <Axman6> mopped: it's not a function that is easy to visualise, that's for sure :P
03:34:59 <Saizan_> you need to imagine a graph, and that's also why it's hard on IRC
03:35:19 <mopped> I think the scanl definition (was it scanl?) of fibs is harder
03:35:25 <mopped> I don't really have a clue whats going on there
03:35:26 <Gracenotes> yeah, in real life I'm sure you wave your hands in the air (:?)
03:35:46 <Axman6> :t scanl
03:35:48 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
03:36:23 <Gracenotes> this one? facs = scanl (*) 1 [1..]
03:36:34 <Gracenotes> oh, wrong function ^_^
03:36:57 <Saizan_> Gracenotes: you use a whiteboard!
03:37:03 <mopped> > fix (scanl (+) 0 . (1:))
03:37:04 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
03:37:20 <mopped> *whoosh*
03:37:36 <Gracenotes> fix is sugar for fibs = scanl (+) 0 . (:1) $ fibs
03:38:06 <Gracenotes> er, 1:
03:38:24 <Gracenotes> so, fibs = scanl (+) 0 (1:fibs). might be more readable. still odd
03:40:24 <Gracenotes> the scanl (+) part just means that you add the current accumulator with the current item in the input list, producing the next item in the result list, which also becomes the accumulator ...
03:41:30 <Gracenotes> so on the next step, you add the next item in the input list with the accumulator, and that becomes the next item in the result list and also the next accumulator. so it's like adding together two adjacent elements.
03:41:51 <Gracenotes> it's just how scanl works. Now the mindfucky part is that the input list and the result list are the same thing.
03:48:13 <Saizan_> yairchu: this example is more worrying :) http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6316#a6319
03:48:21 <Saizan_> yairchu: note the duplicate printings
03:49:45 <yairchu> Saizan_: you are right. btw it would be less confusing if you used unique prints :)
03:50:06 <Saizan_> yairchu: heh, too lazy for that :)
03:51:57 <yairchu> Saizan_: do you think it's fixable? :)
03:52:56 <Saizan_> yairchu: the difference between (a >> b) >> c and a >> (b >> c) is fixable with a ContT layer, the duplication i don't know
03:53:53 <yairchu> Saizan_: if the difference would be solved in a way that is consistent with the current a >> (b >> c) then it should also fix the duplication I think..
03:54:31 <Saizan_> ContT reassociates to the right, yeah
03:55:11 <yairchu> working on understanding ContT.. :)
03:57:59 <hackagebot> TernaryTrees 0.0.4.0 - Efficient pure ternary tree Sets and Maps (AlexMason)
03:59:17 <Saizan_> yairchu: it seems to work http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6316#a6320 , it also prints the "int producer is done!"
03:59:51 <yairchu> wow. that easy eh?
03:59:56 <yairchu> brilliant :)
04:00:07 <Saizan_> yeah :)
04:00:10 <yairchu> wowowow
04:00:23 <yairchu> thanks!
04:00:46 <Saizan_> i'm not positive on it solving the duplication problem once and for all, i should investigate better why that happens
04:00:53 <Saizan_> s/better/more/
04:02:58 <Saizan_> btw, you'd want something like newtype Codensity m a = C { unC :: forall r. ContT r m a }, so you don't have to expose 'r' through ProducerT
04:03:13 <Saizan_> (the name comes from CT, but don't be scared :)
04:06:07 * juhp_ had forgotten about the icfp contest...
04:07:25 <yairchu> Saizan_: I'll parse your suggestion after I better understand ContT :)
04:10:02 <yairchu> Cont's >>= original implementation:m >>= k  = ContT $ \c -> runContT m (\a -> runContT (k a) c)". do you find "Cont m >>= k = Cont $ flip (runCont . k) m" simpler
04:10:11 <PeakerWork> yairchu: hey
04:10:19 <yairchu> PeakerWork: hey
04:10:33 <yairchu> oops
04:10:36 <jkramer> Ahoy
04:11:44 <jkramer> I'm looking for a simple embeddable language for Haskell
04:11:45 <PeakerWork> Saizan_: Implementing it on top of ContT is easier, but maybe it would be nicer to implement it as a simpler-than-contT monad that can only do what we need here.. then again, maybe that's just code duplication
04:11:59 <yairchu> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6321#a6321
04:12:08 <jkramer> Do you have any suggestions? The only thing I found at hackage is LUA
04:12:15 <PeakerWork> @pl  ContT $ \c -> runContT m (\a -> runContT (k a) c)
04:12:16 <lambdabot> ContT (runContT m . flip (runContT . k))
04:13:14 <Saizan_> yairchu: your two don't look the same
04:13:22 <yairchu> yeah, oops
04:13:24 <yairchu> sorry
04:13:27 <yairchu> pasted ContT's
04:13:40 <yairchu> in hpaste or in channel?
04:14:05 <yairchu> @pl Cont $ \c -> runCont m $ \a -> runCont (k a) c
04:14:06 <lambdabot> Cont (runCont m . flip (runCont . k))
04:14:26 <Saizan_> in hpaste
04:14:30 <yairchu> oh
04:14:32 <yairchu> my bad
04:15:00 <yairchu> doh
04:15:12 <yairchu> should have checked its type and I could see I'm wrong..
04:15:25 <Saizan_> yeah
04:15:46 <PeakerWork> yairchu: I think PL itself isn't better unless its much shorter. But its better pedagogically because often it makes a lot of generalizations/refactorings visible
04:17:02 <jkramer> So, no ideas for embedded languages for Haskell?
04:18:06 <hackagebot> showdown 0.5 - A simple gtk based Russian Roulette game. (AnthonySimpson)
04:18:23 <jkramer> Hrhr, great game concept
04:21:55 <yairchu> in "\c -> runCont m $ \a -> runCont (k a) c" the "\c -> ... c" part is redundant. is it considered better style "not to curry"?
04:23:56 <Saizan_> jkramer: you want to embed some other language in haskell?
04:24:37 <int-e> yairchu: it's not.
04:24:40 <Saizan_> yairchu: it's not really redundant
04:25:02 <Saizan_> yairchu: i.e. that's not equivalent to "runCont m $ \a -> runCont (k a)"
04:25:35 <yairchu> @pl \a -> blah a
04:25:35 <lambdabot> blah
04:25:46 <int-e> yai@pl \a -> \b -> (blah a)
04:25:49 <Saizan_> you're not considering that $ nestes
04:25:50 <int-e> @pl \a -> \b -> (blah a)
04:25:51 <lambdabot> const . blah
04:25:58 <dibblego> @pl \a -> blah $ bloo a
04:25:59 <lambdabot> blah . bloo
04:26:22 <yairchu> Saizan_: thanks
04:26:26 <jkramer> Saizan_: Well, not directly into Haskell, I want to run scripts in another language from haskell and interact with variables, data structures in that other language
04:27:15 <jkramer> The goal is to write a MUD engine where rooms etc. are coded in a simple scripting language
04:27:57 <dsturnbull> why not write them in haskell? :)
04:28:01 <Saizan_> jkramer: we often use haskell as that simple scripting language too
04:28:26 <dsturnbull> imo, MUD languages are usually pretty simple - and pretty bad
04:29:15 <jkramer> A pretty simple and pretty bad language would be fine :)
04:29:18 <Saizan_> jkramer: one would probably create a MUD Embedded Domain Specific Language (EDSL) for that
04:29:34 <Saizan_> so that it's very simple to write MUD specific things
04:29:43 <jkramer> Yup, I tried that but it's a bit too complex for me as a beginner
04:30:07 <Saizan_> it's also very simple to write an interpreter for a full language
04:30:39 <jkramer> I wrote a parser with parsec, but running the parsed script and sharing stuff from it with the mud engine is too much for me
04:39:50 <Saizan_> uhm, maybe you should consider some tutorial on writing an interpreter
04:41:08 <jkramer> Do you know a good one? :)
04:41:55 <Saizan_> heh, i was looking for it
04:42:28 <Saizan_> http://lambda-the-ultimate.org/node/1830 <- this lists three, but i'm not sure about the quality
04:43:23 <Saizan_> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.17.268 <- this is also nice
04:43:27 <jkramer> I already read the one about scheme in 24h, but it didn't help much
04:44:02 <jkramer> I think writing an interpreter for another functional language in a functional language is something completely different from writing an imperative scripting language
04:45:03 <Twey> Not really
04:45:13 <Saizan_> and imperative language is a functional language with a monad :P
04:45:19 <Twey> Just consider ; to be >> in IO
04:45:31 <Twey> And you're set
04:45:41 <maxote> Saizan_, lazy or eagy?
04:45:42 <jkramer> Hehe
04:45:54 <Saizan_> and add a mutable heap to the environment for mutable variables
04:46:24 <Saizan_> mutable from the pov of the interpreted language, in haskell you can use IntMap to represent it
04:47:19 <Saizan_> maxote: both, you just have to define the monad appropiately
04:47:24 <Saizan_> afaiu
04:47:38 <jkramer> Mutable variables are not a big problem, I solved that by managing a Map in another Thread and accessing objects only with transactions
04:48:45 <jkramer> This way I can safely access them from all player threads
04:49:34 <yitz> jkramer: a simple functional MUD scripting language would be great!
04:49:53 <jkramer> Like a "scheme in 24h"? :)
04:50:41 <yitz> Or maybe something more Haskell-like
04:50:42 <jkramer> I had a look at Atomo, which looks pretty cool, but I couldn't even compile it
04:50:51 <jkramer> -> Atomo :)
04:51:18 <jkramer> Atomo is like Haskell combined with a little OOP
04:51:35 <jkramer> http://github.com/vito/atomo/tree/master
04:52:21 <yitz> jkramer: hmm, googling atomo sends me to articles in Spanish about nuclear particles :)
04:52:34 <jkramer> Hehe
04:52:49 <jkramer> Use the link above or google for "atomo language"
04:53:25 <jkramer> It's very unknown I guess
04:53:41 <jkramer> Can't find anything baout it beside the github page too
04:54:51 <Saizan_> the modular interpreters paper is nice since it shows how each feature you add to your language maps to a precise extension of your interpreter
04:56:38 <yitz> jkramer: yeah, besides that github README, it's nothing but "fisica nuclear".
04:58:16 <jkramer> yitz: The code examples look nice though
05:01:18 <Gracenotes> sooo.
05:08:02 <olsner> Saizan_: hmm, that seems to have been written before haskell had type classes
05:08:27 <ivanm> olsner: you mean Haskell didn't have classes at some stage? :o
05:08:36 <ivanm> I'm guessing this is 1.0 era or something?
05:08:57 <olsner> that'd be 1995, whatever era that is (pre-historic?)
05:09:20 <ivanm> sure sounds like it ;-)
05:10:31 <olsner> sounds like haskell had some kind of type classes then, but apparently "constructor classes" was something new then (e.g. how you can have class Functor f where f is a type constructor rather than a full type)
05:13:09 <Saizan_> olsner: it uses monads, so it should have constructor classes
05:14:33 <olsner> it = the paper? yeah, it's written in gofer to be able to use them
05:14:39 <Saizan_> ah, yeah
05:14:44 <Saizan_> i didn't recall that
05:26:27 <skorpan> can you guys spell lol
05:26:35 <skorpan> or do you need unicode for that
05:26:38 <skorpan> her her her
05:26:59 <ivanm> @slap skorpan
05:27:00 <lambdabot> stop telling me what to do
05:27:10 <skorpan> yeah, no one puts baby in the corner
05:44:59 <cjay> any opengl experts? should one always run the GLUT mainLoop with forkOS?
05:45:15 <cjay> instead of forkIO
05:49:44 <cjay> and renderString has weird color problems, it doesn't use the color I set before
05:50:23 <cjay> in simple example programs it does use the color, but not in my more complicated program
05:51:47 <Axman6> jauaor: yes, you need to use forkOS. OpenGL uses thread local sotrage
05:51:50 <edmoore> Axman6: am very much enjoying this tutorial, thank you
05:51:51 <Axman6> storage*
05:52:30 <Axman6> edmoore: glad to hear it :) make sure you let BONUS know, and if you have any questions, don't hesitate to ask in here
05:52:44 <edmoore> thanks, I will do
05:55:49 <cjay> Axman6: do I have to register all the opengl-callbacks from within that new thread? the timer callback stopped working after I switched to forkOS
05:56:15 <cjay> display callback still works though
05:56:18 <Axman6> maybe, i'm not sure. only recieting what i've heard others say :\
05:56:28 <cjay> hmm
05:59:31 <cjay> yeah, timer callback works when registered from within that thread
05:59:52 <cjay> but still the weird color problem when rendering text
05:59:53 <cjay> :\
06:01:01 <kacper_> how to check priority of operator?
06:01:23 <Axman6> :info (==)
06:01:26 <Axman6> i thik
06:02:21 <Axman6> n*
06:02:51 <kacper_> what?
06:04:20 <kacper_> Axman6
06:04:38 <Axman6> in ghci, use :info infixfunchere
06:05:05 <kacper_> thanks, lamdabot works for it?
06:05:17 <Axman6> no
06:05:33 <Axman6> :i (==)
06:06:30 <Berengal> How to break my java-programming friends' mind: derive f x = (f (x + epsilon) - f x) / epsilon where epsilon = 0.00001
06:09:22 <cjay> pushing all the opengl stuff into a seperate thread causes a lot of other problems. the window decorations aren't redrawn, and I get a spinnig cursor (os x)
06:10:44 <EvilTerran> Berengal, how does that break minds? it's dead simple...
06:10:50 <tnks> Hi, I was thinking of making a home-brew E-mail client to meet some personal requirements.
06:11:01 <tnks> thought I'd try making it in Haskell.
06:11:08 <Berengal> EvilTerran: Exactly why it breaks the minds of these java programmers
06:11:32 <tnks> but I'm not sure about one piece: an indexer for a full-text search.
06:13:25 <tnks> is sphinx the best option?
06:14:45 <dsturnbull> the amount of data you'd be dealing with is insignificant in roll-your-own terms
06:15:53 <dsturnbull> i use it (from a different language) and it's nice, though
06:20:40 <olsner> cjay: maybe you can push the rest of the program into a separate thread instead?
06:23:39 * tibbe__ 's head explodes
06:23:41 <cjay> olsner: maybe, but it's more convenient that way, I'm writing a visualization for a existing program and that way I only have to change two lines in the main.hs. funnily enough it already workd when I used forkIO, I thought a seperate thread might somehow solve the color problem, but it doesn't
06:43:59 <kacper_> is f x = [x] : [1] have a type? ghci says yes
06:44:24 <kacper_> but can't evaluate it
06:44:39 <opqdonut> :t let f x = [x] : [1] in f
06:44:42 <kacper_> *evaluate expresion not type ;)
06:44:42 <lambdabot> forall t. (Num [t]) => t -> [[t]]
06:44:48 <Botje> kacper_: that looks like a weird type.
06:44:53 <opqdonut> ah
06:45:02 <opqdonut> the 1 is polymorphic over Num
06:45:08 <Botje> kacper_: (:) is of type a -> [a] -> [a]
06:45:12 <opqdonut> there'd need to be a num instance of type [something]
06:45:25 <Axman6> @instances Num
06:45:27 <lambdabot> Double, Float, Int, Integer
06:45:34 <Axman6> no [a] there
06:45:39 <Botje> kacper_: perhaps you meant ++?
06:45:41 <Botje> :t (++)
06:45:42 <lambdabot> forall a. [a] -> [a] -> [a]
06:45:49 <kacper_> Botje no
06:45:55 <kacper_> i meant (:)
06:45:59 <Botje> :t (:)
06:46:01 <lambdabot> forall a. a -> [a] -> [a]
06:46:09 <Botje> look at the type
06:46:15 <kacper_> i know
06:46:53 <byorgey> forall t. (Num [t]) => t -> [[t]]  says that  [t]  must be a number, which is absurd.
06:47:07 <byorgey> however you COULD define an instance of Num for [t] which is why ghci allows it.
06:47:16 <kacper_> byorgey that's good notice
06:47:27 <byorgey> but as soon as you try to evaluate it, ghci finds that there currently ISN'T such an instance, which is why it fails.
06:50:07 <smorg> > (\a -> init (a : head a)) [0..10]
06:50:10 <lambdabot>   Occurs check: cannot construct the infinite type: a = [[a]]
06:50:50 <smorg> > (\a -> init (a : head a : [])) [0..10]
06:50:52 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
06:51:56 <opqdonut> smorg: whatare you trying to do?
06:52:47 <opqdonut> init (a ++ head a) === a
06:52:49 <smorg> send the first element to the last element.
06:52:50 <opqdonut> so probably not that
06:52:55 <smorg> I guess init should be tail
06:53:11 <opqdonut> and your parentheses are wrong
06:53:22 <smorg> even though (head a : []) should be of type [a]
06:53:23 <opqdonut> (\a -> init a ++ [head a]) [1..10]
06:53:35 <opqdonut> > (\a -> init a ++ [head a]) [1..10]
06:53:37 <lambdabot>   [1,2,3,4,5,6,7,8,9,1]
06:53:41 <opqdonut> oops
06:53:45 <opqdonut> > (\a -> tail a ++ [head a]) [1..10]
06:53:46 <lambdabot>   [2,3,4,5,6,7,8,9,10,1]
06:53:46 <opqdonut> yeah, tail
06:53:49 <smorg> there we go
06:53:54 <smorg> initeresting, forgot about ++
06:53:59 <opqdonut> there was a function in the prelude for that iirc
06:54:16 <opqdonut> nah, guess not
06:54:25 <smorg> I'm trying to come up with interesting ways of doing reverse :)
06:59:39 <smorg> I assume (iterate (\a -> tail a ++ [head a]) [1..10]) is faster than (iterate (\a -> init $ last a : a) [1..10])
07:00:47 <Saizan_> it's lazier, at least
07:01:09 <Saizan_> well, each step is
07:01:43 <Saizan_> if you're going for performance you can't really beat the foldl definition, though
07:02:37 <olsner> > (\xs -> zipWith (++) (tails xs) (init $ inits xs)) $ [1,2,3,4]
07:02:39 <lambdabot>   [[1,2,3,4],[2,3,4,1],[3,4,1,2],[4,1,2,3]]
07:09:25 <Gracenotes> the foldl way uses like a temporary stack. it is arguably awesome
07:09:49 <olsner> "arguably awesome" :D
07:10:51 <Gracenotes> also pretty straightforward. You take the first element and put it at the bottom of a list. you take the second element and stack it up on top of the other list. third element, on top of second element. Until you have a last element on top of it all, and the list is reversed
07:17:36 <Berengal> Whew, I just finished reading my backlog of cafe mails...
07:19:32 <Saizan_> you read all of cafe?
07:20:19 <Berengal> Not every email ever
07:20:30 <Berengal> Only the ones I'd missed in the last couple of weeks
07:21:55 <hackagebot> test-framework 0.2.4 - Framework for running and organising tests, with HUnit and QuickCheck support (MaxBolingbroke)
07:22:56 <hackagebot> test-framework-hunit 0.2.4 - HUnit support for the test-framework package. (MaxBolingbroke)
07:22:56 <hackagebot> test-framework-quickcheck 0.2.4 - QuickCheck support for the test-framework package. (MaxBolingbroke)
07:23:47 <ray> mailing lists are scary
07:23:56 <hackagebot> test-framework-quickcheck2 0.2.4 - QuickCheck2 support for the test-framework package. (MaxBolingbroke)
07:24:29 <ray> i once signed up for a few and thoroughly ruined email for myself for the next year and a bit
07:25:04 <Berengal> Mailing lists are why filters were invented
07:25:30 <Raevel> i cannot stand mailing lists
07:26:41 <Saizan_> yeah, filters ftw
07:27:15 <bavardage> filters?
07:27:27 <EvilTerran> filter (not.junk) emails
07:27:34 * Twey chuckles.
07:28:21 <Saizan_> bavardage: e.g. i never have mailing list emails in my inbox, each mailing list has a dedicated folder with all its messages
07:28:28 <bavardage> oh kk
07:28:40 <bavardage> that would make it much nicer
07:28:57 <Berengal> It does. It's essential
07:29:29 <maltem> Wait. You have haskell-cafe in your inbox every day?
07:29:41 <maltem> Wow :)
07:30:38 <Gracenotes> .. oh rly >_<
07:30:53 <Gracenotes> anyway, I have yet to grasp the power of dancing links
07:31:10 <Saizan_> dancing links?
07:31:23 <Gracenotes> I believe understanding how dancing links work is a step closer to satori
07:31:26 <Berengal> Dancing links is an awesome algorithm...
07:31:32 <Gracenotes> Knuth's efficient implementation of Algorithm X
07:31:36 <maltem> dancing links?
07:31:55 <Gracenotes> which can solve problems like sudoku, knight's walk, and 8 queens efficiently
07:32:10 <acidjnk> hello
07:32:23 <Berengal> I wrote a c implementation that could solve the 16-number sudoku in about a second
07:32:25 <Gracenotes> can it solve knight's walk? I'm pretty sure...
07:32:58 <Gracenotes> Berengal: 96*96?
07:33:20 <Berengal> Gracenotes: No, regular, but with only 16 numbers filled
07:33:27 <acidjnk> I've always been able to absorb books about Java & OO at a high speed, and I am financially successful with that sort of thing. In "Programming in Haskell" I just reached page 75 after several years of hard work. Should I just give it up? Maybe it's just the wrong thing for me.
07:33:34 <Gracenotes> oh, no, that's 12*12
07:33:42 <Berengal> I think only one of them has been found that's solveable, except it has two solutions...
07:34:00 <olsner> Gracenotes: 16x16?
07:34:26 <Gracenotes> olsner: well, if one has 16 numbers instead of 9, that's (sqrt(16)*3)^2
07:34:42 <maltem> acidjnk, depends. Is it fun? ;)
07:34:47 <acidjnk> Like, it's possible for some people to have a very strong weakness that seems closely related to one of their strengths.
07:35:21 <acidjnk> No, not very much, maltem.
07:35:24 <Berengal> acidjnk: How long have you been trying to learn, and what's the most recent thing you've had trouble grasping? If you don't mind me asking :)
07:35:28 <Gracenotes> @where lyah
07:35:29 <lambdabot> www.learnyouahaskell.com
07:35:47 <Gracenotes> ^ this is a good intro, not huge learning slope
07:35:53 <olsner> Gracenotes: isn't '3' there actually sqrt(|numbers|), i.e. the 16-number one is (sqrt(16)*sqrt(16)) squared?
07:35:58 <jkramer> Does anyone know a good example for a simple programming (imperative/object oriented) language built with parsec?
07:36:11 <acidjnk> Since about 2007, Berangal. I had a 10 year background in SML, but never was very good at it.
07:36:39 <maltem> acidjnk, then you're missing the best reason to continue. But, trying other literature is always an idea
07:37:31 <acidjnk> My most recent problems: I started chapter 8 and don't know the used keywords: newtype, infixr, instance
07:38:00 <Cale> acidjnk: You know about 'data'?
07:38:07 <acidjnk> no
07:38:17 <Gracenotes> olsner: I mean, if you had a sodoku where there were 16 symbols (1-16), then each box would be 4x4, and three boxes up and down would be 12x12. But, offtopic, anyway..
07:38:25 <Berengal> acidjnk: Shopping around for different tutorials is probably a good idea. I never found one that was good enough, I read about six different ones, and spent much time fumbling around in the interpreter
07:38:26 <maltem> That book must present things in a very strange order :)
07:38:41 <Cale> ah, okay, 'data' is used to introduce new datatypes with given constructors and fields
07:39:09 <acidjnk> That book is already the result of a long search. I started so many tutorials.
07:39:30 <Cale> newtype is like data, except that there must be exactly one constructor and one field, and the semantics are just slightly different, so that the compiler can implement the datatype at runtime with the same representation as the original.
07:39:32 <Berengal> acidjnk: Have you tried solving Project Euler problems?
07:39:33 <acidjnk> I need exercises, for example. Otherwise I just read and nod, I am good at that.
07:39:41 <Berengal> Also, #haskell is a lazily evaluated tutorial ;)
07:40:07 <acidjnk> thanks Cale
07:40:16 <Berengal> (Cale is an instance of DeepSeq :P )
07:40:20 <acidjnk> Not sure about Euler problems. Not recently, no.
07:40:29 <Cale> Berengal: haha
07:41:13 <Cale> acidjnk: infix, infixl and infixr are keywords which set the infix associativity and precedence for infix operators
07:41:31 <Berengal> PE problems are great for learning new languages, at least for me. I always start trying to do some problems there, even before I finish learning the syntax
07:41:51 <Cale> infixl 6 +
07:42:03 <Cale> infixr 8 ^
07:42:12 <Cale> to give a couple examples :)
07:43:13 <Cale> that says that + is left associative with fixity 6, and ^ is right associative with fixity 8 (which means it grabs parameters more strongly than +)
07:43:41 <pragma_> What do you think of "Real World Haskell"?
07:43:49 <acidjnk> Thanks Cale, Berengal
07:44:18 <acidjnk> "Real World Haskell" is next on the list, but at the current rate I won't be done with "Programming in Haskell" before 2014.
07:44:20 <Cale> instance is a keyword associated with typeclasses -- it's what lets you define the methods of an existing typeclass for a new datatype
07:46:06 <Philonous> Is there a paper describing the basics of FRP?
07:46:41 <dsturnbull> yep: http://www.cs.nott.ac.uk/~nhn/FoPAD2007/Talks/nhn-FoPAD2007.pdf
07:46:57 <dsturnbull> wait sorry, that's the wrong url
07:47:13 <Saizan_> acidjnk: you should try with a bit of parallelism :)
07:47:13 <acidjnk> I think money-wise I don't have to learn anything that I consider tough. In 15 years the industry will need just as many programmers as now, and the great masses are not that much smarter than I am. There is no working teaching concept for a real-world functional or otherwise improved style.
07:47:26 <acidjnk> And when they find such a teaching concept, I will benefit from it as well.
07:47:27 <Taejo_> @pl \x -> any (x `isPrefixOf`) blockStarts
07:47:28 <lambdabot> flip any blockStarts . isPrefixOf
07:47:30 <dsturnbull> Philonous: http://haskell.cs.yale.edu/yale/papers/haskell-workshop03/yampa-arcade.pdf
07:47:39 <Philonous> Cale: What does infix (without the l or r) mean? It has to be either left or right associative, doesn't it?
07:47:48 <Philonous> dsturnbull: Thanks
07:47:51 <Cale> non-associative
07:47:57 <EvilTerran> Philonous, it means you can't use it associatively
07:47:59 <opqdonut> Philonous: that means it can't be used associatively
07:48:04 <EvilTerran> > True == False == False
07:48:05 <lambdabot>   Precedence parsing error
07:48:05 <lambdabot>      cannot mix `GHC.Classes.==' [infix 4] and `GH...
07:48:14 <opqdonut> yes, for example
07:48:27 <Philonous> Ah, so it gives an error.
07:48:31 <EvilTerran> (although == on Bool is, perhaps surprisingly, associative)
07:48:51 <idnar> EvilTerran: left or right?
07:48:53 <Twey> But probably not what you want to do, in the general case
07:48:58 <Twey> idnar: Both
07:49:01 <EvilTerran> @check \x y z -> ((x == y) == z) == (x == (y == z))
07:49:03 <lambdabot>   "OK, passed 500 tests."
07:49:18 <opqdonut> hehe
07:49:20 <idnar> Twey: well, I mean, grammatically
07:49:28 <EvilTerran> idnar, i mean in the maths sense, not in the grammatical sense
07:49:36 <EvilTerran> in the haskell grammar, it's not associative
07:49:40 <idnar> EvilTerran: oh
07:49:53 <idnar> yes, duh
07:49:58 <idnar> your example up there was on Bool
07:49:59 <Twey> Hehe
07:50:04 * Twey nods.
07:50:08 <Twey> If you mix types it gets complicated
07:50:10 <idnar> although I think that quickcheck example was using ()
07:50:12 <EvilTerran> @scheck \x y z -> ((x == y) == z) == (x == (y == z))
07:50:13 <lambdabot>   "OK, passed 500 tests."
07:50:15 <idnar> oh, I suppose not
07:50:15 <Twey> idnar: No
07:50:26 <Twey> Those brackets are just for precedence overriding
07:50:32 <idnar> since (==) returns Bool
07:50:44 <EvilTerran> hm, no scheck...
07:51:23 <Twey> When you mix types, though, it can't be associative
07:51:48 <Twey> For example, A == A == True is a type error if it's right-associative
07:51:57 <EvilTerran> indeed
07:52:16 <Twey> The decision would have to be arbitrary
07:52:28 <RayNbow> EvilTerran, which type does QC use when checking (\x y z -> ((x == y) == z) == (x == (y == z)))? :p
07:52:30 <Axman6> (and a silly function even if it's not >_>)
07:52:31 <RayNbow> () ?
07:52:33 <noteventime> It's not possible to hide instances when importing, is it?
07:52:36 <EvilTerran> and people might expect "foo == bar == baz" to mean "foo == bar && bar == baz"
07:52:46 <Twey> And would probably introduce a bunch of errors that would far outweigh the benefit of saving a pair of brackets
07:52:51 <EvilTerran> RayNbow, Bool everywhere, because of the return type of (==)
07:52:54 <Twey> EvilTerran: *nod*
07:52:58 <RayNbow> ah right
07:53:02 <Twey> Or even foo == bar && foo == baz
07:53:13 <acidjnk> thanks again, bye
07:53:17 <Twey> 'bye, acidjnk
07:53:33 <EvilTerran> Twey, or either, implementation-dependent, seeing as the report implies (==) should be an equivalence relation
07:56:03 <hackagebot> showdown 0.5.1 - A simple gtk based Russian Roulette game. (AnthonySimpson)
07:57:08 <Gracenotes> @type on (&&) . (==)
07:57:09 <lambdabot> forall a. (Eq a) => a -> a -> a -> Bool
07:58:33 <maltem> I wasn't aware that Gtk allows you to shoot yourself in the head
07:59:23 <Saizan_> it's written in C.
08:00:00 <Beelsebob> maltem: it allows an impressive amount of head shooting
08:00:09 <Twey> What's written in C?
08:00:11 <Beelsebob> most notably, driving the event loop is *really* hard
08:00:18 <Beelsebob> (if you want to do anything at all at the same time)
08:00:18 <Twey> noteventime: No, alas
08:00:27 <Twey> Oh
08:00:29 <Twey> GTK.  :-P
08:00:44 <noteventime> Twey: Ok, I thought I'd read that somewhere
08:00:54 <Gracenotes> I thought C was best for foot-shooting
08:01:00 <noteventime> :p Somewhat annoying since I have something that's almost Maybe
08:01:41 <Twey> noteventime: Maybe it's Maybe?  :-P
08:02:17 <noteventime> Twey: It's maybe, but with "Nothing == +infty"
08:03:14 <EvilTerran> noteventime, ah, while the usual Maybe has Nothing ~~ -inf
08:03:40 <Gracenotes> indeed so
08:03:40 <EvilTerran> > Nothing < Just (undefined :: Int)
08:03:41 <lambdabot>   True
08:04:05 <hackagebot> showdown 0.5.2 - A simple gtk based Russian Roulette game. (AnthonySimpson)
08:04:12 <noteventime> EvilTerran: Indeed
08:04:38 * EvilTerran considers "data WithInf a = NegInf | NotInf a | PosInf deriving (Eq, Ord, ...)"
08:04:53 <noteventime> EvilTerran: That's what we have now, but without NegInf :)
08:05:27 <noteventime> data SingleExtended a = Finite a | Infinite deriving (Eq, Ord)
08:05:43 <noteventime> But I had to redefine Applicative
08:06:33 <Gracenotes> maybe if there was a type family...
08:06:33 <PeakerWork> @type MaybeT
08:06:34 <lambdabot> Not in scope: data constructor `MaybeT'
08:06:38 <PeakerWork> @type Control.Monad.Maybe.MaybeT
08:06:39 <Gracenotes> or something
08:06:40 <lambdabot> Couldn't find qualified module.
08:06:48 <EvilTerran> , src ''MaybeT
08:06:51 <lunabot>  luna: Not in scope: type constructor or class `MaybeT'
08:06:52 <Gracenotes> there is no standard maybet I believe
08:08:37 <noteventime> Gracenotes: There's a package on Hackage, I believe
08:09:14 <Gracenotes> however not base or mtl
08:37:16 <sierinjs> hello, i'm making right now a bot in python, but i heard your channel members have made some lambada bot.. i hope some of bot's developers are here, and i have a question - what commands do i need to send to server, to exit gently? (and do i have to quit all rooms?)
08:38:26 <EvilTerran> sierinjs, are you using an IRC library, or handling the protocol from scratch?
08:38:57 <sierinjs> EvilTerran: scratch
08:39:26 <Twey> @index bracket
08:39:26 <lambdabot> Control.Exception, Distribution.Compat.Exception, Graphics.HGL.Draw.Monad, Graphics.HGL.Draw, Graphics.HGL.Core, Graphics.HGL
08:39:33 <Botje> sierinjs: you're doing it wrong :)
08:39:42 <Saizan> sierinjs: http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot <- look for QUIT here
08:39:45 <Botje> odds are there's some really good IRC libraries for python that you can use
08:39:47 <Twey> @src bracket
08:39:48 <lambdabot> bracket before after thing = block $ do
08:39:48 <lambdabot>     a <- before
08:39:48 <lambdabot>     r <- catch (unblock (thing a)) (\e -> do { after a; throw e })
08:39:48 <lambdabot>     after a
08:39:48 <lambdabot>     return r
08:40:26 <Saizan> it appears that it's "QUIT :quit message\r\n"
08:40:27 <Twey> sierinjs: No, you don't have to leave your rooms; send a simple ‘QUIT :message’ to the server, where ‘message’ is your desired quit message
08:40:36 <EvilTerran> sierinjs, i forget the details, but i imagine it says in the RFCs (http://www.faqs.org/rfcs/rfc1459.html etc)
08:40:37 <Badger> @src block
08:40:38 <lambdabot> Source not found. You type like i drive.
08:40:47 <Badger> @index block
08:40:47 <lambdabot> Control.Exception
08:40:51 <Twey> But Botje's right: you shouldn't be handling raw IRC protocol in a bot
08:41:17 <Twey> For Python, try twisted's IRC library
08:41:20 <Twey> It's quite good
08:42:00 * mmorrow starts the timer on compiling the first of his two 7000 lines generated files
08:42:51 <mmorrow> i really hope these finish..
08:43:08 <sierinjs> Twey: mjah, but after i come back to server it say's my nick is already in use... but it's cetrainly not
08:43:18 <sierinjs> hmm
08:44:39 <Twey> @index forkIO
08:44:40 <lambdabot> Control.Concurrent
08:46:07 <conal> @seen thoughtpolice
08:46:07 <lambdabot> thoughtpolice is in #haskell, #ghc, #haskell-blah and #haskell-in-depth. I last heard thoughtpolice speak 21h 35m 22s ago.
08:46:22 <thoughtpolice> conal: hi
08:46:32 <thoughtpolice> conal: sorry, i was very busy yesterday :)
08:47:47 <koda> hi, could you point me to some safe optimization flags for haskell programs?
08:47:53 <koda> (besides -O2)
08:48:06 <conal> thoughtpolice: oh.  np. :)  i'm having a heck of a time with NFS.  haven't been able to get DNS working.  my test domain (lambdapix.com) is still getting routed to my old server, although i've changed the dns server and waited 36hrs.
08:48:43 <Heffalump> conal: DNS records typically have a 7d TTL if you didn't reduce that in advance
08:48:54 <conal> thoughtpolice: i've read various NFS faq warnings against using bare domain names (no "www" etc), and i do like using bare domain names.
08:48:59 <conal> Heffalump: "TTL"?
08:49:07 <thoughtpolice> time to live
08:49:10 <Heffalump> time to live, i.e. time that downstream servers are allowed to cache them
08:49:17 <mmorrow> not bad, the first just finished
08:49:34 <conal> oh, wow.  so it can take 7 days for my dns changes to propagate?
08:49:39 <Botje> conal: lambdapix.com maps to 208.94.116.56, 208.94.117.88, 208.94.116.9 here
08:49:41 <thoughtpolice> yeah, I didn't get a new domain name
08:49:43 <Heffalump> Botje: same here
08:49:47 <Botje> and the TTL is 1hour
08:49:50 <thoughtpolice> I bought my domain name when I went with NFS
08:50:02 <Heffalump> conal: it can take whatever the TTL on the old records is, and 7 days would be a good guess for the default
08:50:06 <Heffalump> 1H is very short
08:50:21 <conal> Botje: oh, hey.  that sounds right.  how did you get those #s?
08:50:22 <Botje> and that seems to map to NFS servers
08:50:28 <idnar> Heffalump: 1 day is more common, in my experience
08:50:29 <Botje> conal: just dig lambdapix.com
08:50:30 <conal> Botje: and what do you see on lambdapix.com?
08:50:41 <Botje> NFS place-holder page for lambdapix.com
08:50:44 <conal> Botje: ?? "dig"?
08:50:47 <Botje> yes
08:50:54 <Botje> it comes with BIND
08:51:03 <Botje> it does DNS requests and gives you a lot of information
08:51:08 <Heffalump> hpaste the output of "dig -t ANY lambdapix.com"
08:51:24 <Heffalump> assuming you have or can get dig
08:51:24 <Botje> odds are your home connection is behind some caching the dns server that still uses the old records
08:51:43 <conal> strange.  i'm seeing different content at lambdapix.com.  i'll try clearing my browser cache.
08:51:52 <conal> Botje: is bind a linux util?
08:52:00 <Heffalump> it's the standard DNS server
08:52:04 <Botje> yeah
08:52:06 <Heffalump> probably works on MacOS as well as Linux
08:52:14 <Botje> but dig is often packaged separately
08:52:18 <Twey> I think it even runs on Windows
08:52:22 <Botje> check if you can install a package named bind-utils or bind-tools
08:52:32 <Heffalump> or bind9-utils or bind9-tools
08:52:45 <Botje> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6323#a6323
08:52:53 <Botje> (eww, fugly urls)
08:52:57 <Berengal> Ubuntu has dig pre-installed, at least on my box
08:53:10 <monochrom> Yes dig is pre-installed.
08:53:50 <Botje> .oO(why did hpaste scrunch up my paste like that?
08:53:58 <monochrom> package.ubuntu.org allows you to search "which package contains a file named xyz?"
08:54:34 <monochrom> oops, packages.ubuntu.com
08:54:35 <EvilTerran> monochrom, that sounds handy, considering all the "could not find file xyzzy.foo" errors i get when trying to make stuff work on linux
08:54:47 <Botje> monochrom: so does dpkg -S :)
08:54:51 <Botje> (for installed packages)
08:55:09 <monochrom> The point is not-yet-installed packages.
08:55:21 <Botje> yeah, i just realised that, sorry :)
08:56:15 <conal> wow.  i get very different results from dig: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6324#a6324
08:56:33 <Heffalump> ok, 86400, so one day
08:56:34 <Botje> conal: 192.168.1.1 seems to cache your dns results
08:56:36 <Heffalump> that's not too bad
08:56:47 <Heffalump> oh, good point.
08:56:51 <Botje> is that a wire{d,less} router? those tend to have sucky dns servers
08:56:59 <Botje> try resetting its cache or rebooting it
08:57:02 <Heffalump> also, the 86400 should be reducing by now
08:57:05 <conal> Botje: it's a wireless router.
08:57:14 <Heffalump> reboot time :-)
08:57:16 <conal> Botje: i'll do that.  thanks!
08:57:32 <Botje> another way to get the "real" dns results is dig +trace lambdapix.com
08:57:39 <Botje> then dig visits every dns server manually
08:57:50 <Botje> and you should get the correct result too
09:07:03 <jad4> oh I just found out about qtHaskell
09:07:45 <monochrom> Hmm, some version of emacs haskell-mode doesn't know that mdo is like do and needs special indentation.
09:07:53 <conal> i've rebooted my router and my (satellite) modem, and dig *still* shows me the old 1and1.com info instead of the new nearlyfreespeech info.
09:07:55 <Cale> jad4: How is it? I think it's received a lot less attention than Gtk2Hs somehow.
09:08:13 <jad4> Cale, I only found out it exists so far :)
09:08:19 <Cale> ah :)
09:08:26 <conal> i wonder if my ISP could be hanging onto the old dns info.
09:09:04 <jad4> Cale, I heard the linspire guys had started using haskell and were thinking about creating haskell qt bindings
09:09:16 * Cale feels like developing applications for MonadPrompt and FingerTree... there seem to be some wonderful abstractions on Hackage which have seen too little actual use.
09:10:00 <jad4> Cale, but then apparently that got nowhere (the linspire haskell team) and never heard anything about it again
09:10:10 <jad4> so was surprised to see bindings for qt exist
09:11:09 <Cale> Being a C++ library, I imagine that QT is somewhat more difficult to construct bindings for.
09:11:36 <pastorn> Cale: can't wx use QT as a backend?
09:11:42 <pikhq> Being a well-designed library, though, helps a lot.
09:11:49 <Ycros> Cale: that, and Qt actually being superset of C++
09:12:01 <sclv> the haskell guys left linspire as i recall and now are set up as seereason, but the website doesn't really have anything at the moment.
09:12:40 <pastorn> sclv: do you know what they're working on or is everything hush-hush?
09:13:04 <AVbd> wx couldn't use Qt before
09:13:20 <pastorn> AVbd: ??
09:13:30 <pastorn> elaborate, please :)
09:13:48 <AVbd> I haven't looked at it for a long time
09:13:49 <sclv> http://74.125.47.132/search?q=cache:ysQpe3I4gskJ:seereason.com/publications/ChalmersJobFair.pdf+%22SeeReason+Partners%22&cd=4&hl=en&ct=clnk&gl=us&client=safari
09:13:58 <AVbd> but wx didn't want to support Qt
09:14:11 <AVbd> because it was already quite cross-platform and complicated
09:14:11 <sclv> dunno anything since then.
09:14:28 <sclv> they hang out here pretty frequently
09:15:00 <jad4> pastorn, nope wx uses gtk in *nix
09:16:13 <Saizan> sclv: which are the nicks of the other two?
09:16:24 <sclv> all in the link i gave
09:16:28 <jad4> and what would be the point of having a Qt backend for wx
09:16:47 <jad4> both wx and Qt are cross platform
09:16:57 <Cale> I threw together a full-featured priority search queue using fingertrees in about an hour the other day, but I made a small mistake which resulted in the operation to get the minimum priority key being O(log n) time instead of O(1). Once I fix that, I'll put it on hackage :)
09:17:28 <Cale> Finger trees are really cool though.
09:18:09 <Saizan> oh, i see
09:18:43 <pastorn> Cale: i saw Koen Claessens presentation of finger trees a few months back
09:19:07 <pastorn> though i hadn't slept the night before, so i snored through most of his presentation :/
09:19:30 <pastorn> could you please inlighten me as to why finger trees are better than BSTs?
09:19:45 <Cale> Okay
09:20:26 <pastorn> i vaguely remember something about them being similar to 2-4-trees
09:20:34 <Cale> Well, there are two components to it: one is that finger trees are an example of monoidally indexed trees, which may actually be a new concept
09:20:59 <Cale> the second is that their shape is such that access to both ends is kept constant time
09:21:23 <pastorn> Cale: so lookups are O(n)?
09:21:26 <Cale> no
09:21:33 <Cale> O(log n) :)
09:21:49 <pastorn> yeah, trees
09:21:50 <Cale> Actually log of the distance to the nearer end, often.
09:21:53 <pastorn> (*doh*)
09:22:04 <Cale> Monoidally indexed trees are such a natural and obviously good thing that I'm quite surprised if they are a new idea.
09:22:07 <pastorn> that's a nice improvement
09:22:36 <pastorn> "Monoidally" as in Monoid?
09:22:39 <Cale> yeah
09:22:51 <Cale> The idea is that if you have a tree type which you're using to store elements at the leaves, what goes in the branch nodes?
09:23:06 <Zao> Cats.
09:23:07 <Cale> Well, typically some information about the elements at the leaves in that subtree.
09:23:21 <pastorn> Zao: and firemens ladders
09:23:37 <Cale> You'll need a way to combine that information when you combine subtrees.
09:23:54 <Cale> and you'll want empty subtrees not to change the result, so there should be an identity for that combination
09:24:16 <Cale> and you'll want to be able to rebalance subtrees without changing the end result, so you want the operation to be associative
09:24:22 <pastorn> Cale: how often do you merge subtrees?
09:24:29 <pastorn> not a lot, i would think...
09:24:51 <pastorn> so that aspect doesn't seem all too impressive...
09:24:52 <Cale> Well... isn't that just based on the depth of the tree?
09:25:10 <Saizan> you've to do that any time you insert or delete something
09:25:11 <Cale> The idea is to generalise the notion of a binary search tree.
09:25:23 <Cale> (this first idea is)
09:25:35 <Cale> So instead of just storing the sizes of the subtrees
09:25:48 <Cale> You might store, say, information about what the minimal element is in the subtree
09:26:05 <pastorn> okay, so more metadata in the branches
09:26:06 <Cale> Or, any number of other bits of relevant information to finding the elements you're interested in
09:26:06 <nainaide> Any idea the ? mark to use "randomR (1,100) ?" in ghci?
09:26:36 <|Jedai|> nainaide: a random generator
09:26:37 <Cale> and because of the reasoning I just described, that information *must* be a monoid if we're going to have the tree work out.
09:26:38 <ski> Cale : would that be stored in each sub-tree, then ? or only in the root ?
09:26:44 <nainaide> > randomR (1, 100) StdGen 99
09:26:45 <lambdabot>   Not in scope: data constructor `StdGen'
09:26:51 <Cale> At every branch node
09:26:54 <ski> s/stored/cached/
09:26:54 <|Jedai|> ski: each subtree
09:26:56 <ski> ok
09:26:56 <Saizan> nainaide: (mkStdGen 99)
09:27:27 <nainaide> >randomR (1,100) (mkStdGen 99)
09:27:39 <pastorn> Cale: seems cool! i'll have to read the implementation source later :)
09:27:44 <Saizan> > randomR (1,100) (mkStdGen 99)
09:27:45 <lambdabot>   (70,4001400 40692)
09:27:49 <Cale> Okay, but that's just one half of it
09:27:53 <pastorn> so what's in the branches in the haskell fingertree library
09:27:59 <nainaide> Cale, Cool
09:28:20 <pastorn> nainaide: g <- newStdGen
09:28:34 <pastorn> randomR (0,10) g
09:28:38 <Cale> In fact, that part is more general than finger trees, and really is something which should have been realised a lot earlier in the history of computer science.
09:28:54 <Cale> (but I think perhaps it really is new (?))
09:29:07 <nainaide> pastorn, yes, work well
09:29:10 <|Jedai|> pastorn: in the fingertree package, you can put any monoid you want in the branch
09:29:27 <pastorn> |Jedai|: cool
09:29:41 <|Jedai|> pastorn: Data.Sequence use an additive monoid (size)
09:29:47 <pastorn> but do i HAVE to dicede?
09:30:00 <pastorn> isn't there a good all around solution hard coded?
09:30:03 <Cale> Yeah, it's generalised over instances of Monoid which have an additional operation for measuring the elements that you're storing at the leaves of the tree
09:30:14 <BMeph> Mmm...cotrees! ;)
09:30:41 <Cale> pastorn: The point is that you usually decide what information is relevant to get the operations you want to be fast.
09:31:02 <|Jedai|> pastorn: That wouldn't make sense... The interesting part of fingertree is exactly that you can make it do exactly what you want by choosing the right monoid
09:31:16 <Cale> pastorn: The information you'll want to store for simple sequences (as in Data.Sequence) is different from the information you'll store to get a priority queue
09:31:42 <|Jedai|> pastorn: for instance you could do a rope-like fingertree that always tell you if the parens are correctly nested in the string
09:32:05 <Cale> You can also store many different types of information at once to make lots of operations fast -- it's easy enough to get a priority queue with fast access to the minimal element and log time searching to see if particular elements are there.
09:32:15 <|Jedai|> pastorn: or if it match a given regexp
09:33:22 <tibbe> @seen bos
09:33:23 <lambdabot> bos is in #ghc, #haskell and #haskell-in-depth. I don't know when bos last spoke.
09:33:29 <pastorn> seems like the 'mkFingerTree' should take 8 gazillion arguments to make it all work
09:33:33 <Cale> The finger tree library gives you concatenation for free, as well as a generic splitting operation which splits the sequence recursively at the first point where a predicate becomes true.
09:33:46 <|Jedai|> pastorn: No, that's why it's interesting
09:33:50 <Cale> No, because you just write an instance of Monoid and Measurable
09:33:57 <Cale> and then it makes use of those
09:34:25 <Saizan> what do you store to make something like Data.Map ? the minimum and maximum elements?
09:34:30 <pastorn> |Jedai|: but say that i have a [Ord a] as a monoid for storing hightest and lowest elements in this subtree
09:34:39 <Cale> Saizan: yeah, that would do nicely
09:34:51 <deech> Hi all, is there some way to see the code generated by the 'deriving' keyword'?
09:34:52 <Cale> In fact, you can get away with just the minimum element
09:34:57 <pastorn> then, when i insert, i'll need a function to run on each [Ord a] whenerver i reach a branch
09:35:15 <Cale> deech: Not in any nice form, but there's a specification for it in the Report
09:35:23 <Cale> http://haskell.org/onlinereport/derived.html
09:35:33 <Cale> brb
09:36:00 <pastorn> deech: what are you deriving and how complicated is your datatype?
09:36:29 <deech> pastorn
09:36:38 <pastorn> deech: yes?
09:36:50 <|Jedai|> pastorn: I'm not sure what you mean by [Ord a] but as long as the "tag" metadata type is an instance of Monoid and Measurable you're fine
09:37:07 <pastorn> @info Measurable
09:37:07 <lambdabot> Measurable
09:37:11 <pastorn> cool
09:37:18 <nainaide> > randomR (1,100) (mkStdGen 99)
09:37:20 <lambdabot>   (70,4001400 40692)
09:37:21 <|Jedai|> pastorn: informative, isn't it ?
09:37:35 <nainaide> in   (70,4001400 40692), what is 4001400 40692 mean?
09:37:42 <deech> pastorn: "Real World Haskell" uses deriving (Monad, MonadError SomeErrorType)
09:37:54 <deech> and I want to see what these macros expand to.
09:38:06 <Berengal> pastorn: That's using GeneralizedNewtypeDeriving
09:38:15 <pastorn> |Jedai|: could you give me the functions and typesignatures (unless they're too big)
09:38:22 <|Jedai|> class (Data.Monoid.Monoid v) => Measured v a | a -> v where
09:38:22 <|Jedai|>   measure :: a -> v
09:38:43 <|Jedai|> nainaide: it's the generator state
09:39:00 <pastorn> deech: oh, newtype deriving :)
09:39:06 <|Jedai|> nainaide: don't worry about it, it doesn't really have to make sense
09:39:12 <deech> pastorn: Yup. Is that different?
09:39:14 <nainaide> |Jedai|, so the two int to describe the state?
09:39:22 <|Jedai|> deech: It is
09:39:31 <|Jedai|> nainaide: Yes
09:39:33 <nainaide> |Jedai|, that's fine
09:40:01 <Berengal> deech: with -XGeneralizedNewtypeDeriving, a newtype can derive any class the wrapped type is already an instance of
09:40:09 <pastorn> all that does is to add a lot of MonadT constructors in front of your datatype, and makes your 'runMyMonadT' to add the correct run-functions in the correct order
09:40:22 <|Jedai|> deech: NewtypeDeriving just use the same code as the original instance (on the base type of the newtype) and adds the proper constructor/destructor
09:40:35 <pastorn> deech: exercise:
09:41:07 <pastorn> write a big-ass monad that's Error, Writer, State and IO using transformers
09:41:17 <pastorn> and then write the correct runfunction
09:41:20 <Cale> I'm back...
09:41:30 <Raevel> i'm batman
09:41:35 <pastorn> THEN write the same monad using GeneralizedNewtypeDeriving
09:41:36 <Axman6> MuthafookenTT
09:41:36 <Cale> Another cool thing about finger trees is that accesses to both ends are constant time.
09:41:48 <skorpan> you already said that
09:42:09 <Axman6> Cale: yeah i've been meaning to take another look at finger trees
09:42:22 <Cale> So if you do the obvious thing to create a Set datastructure, for instance, then adding elements which are larger than everything already in the set or smaller than everything in the set will be constant time.
09:42:36 <deech> pastorn: ok I'll give it a shot
09:42:51 <Cale> (as opposed to log time)
09:42:52 <pastorn> skorpan: you lurker
09:43:10 <skorpan> lurking == not speaking though
09:43:22 <Berengal> No, lurker == zerg
09:43:57 <pastorn> i'm going out for a beer. Will downloed the fingertree source and get raving headaches over the Measure-thingamojigg later, when drunk :D
09:44:06 <Cale> heh
09:44:25 <pastorn> (it seems kinda weird)
09:44:38 <Cale> Measurable is just how you get elements of the monoid for the leaves of the tree
09:45:04 <Cale> So, for instance, if you're storing the sizes of subtrees for a sequence type, it'll just be the constant 1 function
09:45:30 <Cale> Or if you're storing the minimum element, it'll be the identity function at that point
09:45:35 <fracture> is there any sort of curses-esque library for haskell programs on windows?
09:46:36 <fracture> or is there a way to use nanocurses or whatever with cygwin?  (that'd be just as good)
09:55:56 <Cale> fracture: I'd help if only I knew anything about windows ;)
09:56:35 <Cale> fracture: It seems to me that if cygwin has a curses library, then there's a possibility you could get the existing curses binding to work.
09:58:12 <fracture> *nod*
09:58:21 <fracture> googling around right now... sounds like it's possible, but haven't figured it out yhet
10:02:31 <deech> pastorn: How's this? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6326#a6326
10:07:19 <skorpan> does it compile?
10:08:35 <hackagebot> TernaryTrees 0.1.0.0 - Efficient pure ternary tree Sets and Maps (AlexMason)
10:08:48 <Beelsebob> 0.1?
10:08:52 <Beelsebob> I see a hackagebot bug
10:12:07 <Axman6> Beelsebob: nope, that's the version number
10:15:17 <Beelsebob> oh, it was 0.0.1 before
10:15:20 <Beelsebob> or 4 even
10:17:48 <Axman6> Beelsebob: major interface change == minor version update
10:20:43 * Beelsebob nods
10:36:04 <Twey> @index unsafePerformIO
10:36:04 <lambdabot> System.IO.Unsafe, Foreign
10:40:46 <hackagebot> xhb 0.3.2009.6.28 - X Haskell Bindings (AntoineLatter)
10:50:21 <jad4> ... I kept reading that as "X Haskell" Bindings instead of X "Haskell Bindings"
10:53:55 <depill> can anyone tell me why I get the error message "Could not find module 'Graphics.UI.Gtk.Glade'"  when trying to run a sample GTK program?  I have installed Glade3 and also gtk2hs
10:54:18 <Twey> It suggests you haven't installed Gtk2Hs
10:54:48 <jeff____> or you built gtk2hs before you had libglade installed
10:55:15 <depill> hmm ok thanks, I'll try to uninstall and install again
10:55:16 <depill> cheers
10:55:20 <jeffersonheard> Glade is a separate module; it is enabled if found, but gtk2hs will build just fine without it.  look at your ./configure script
10:55:24 <jeffersonheard> cheers
10:56:01 <SamB> yeah, libglade headers are kind of important to have installed when building gtk2hs if you want glade-loading support
11:04:53 <hackagebot> fingertree-psqueue 0.1 - Implementation of priority search queues as finger trees. (CaleGibbard)
11:07:18 <conal> i'd appreciate some more suggestions on my web/dns situation here.  i've switched my router to use OpenDNS instead my ISP's DNS, and sure enough, now dig show me the right dns info.  And yet, curl and firefox are still somehow showing me the info on the old server, not the new server.  i've updated the old server page, and i'm seeing the new data for the old location.
11:08:05 <Meady> Hey guys just needing a little help with this code
11:08:17 <Meady>    1. boomBangs xs = [ if x < 10 then "BOOM!" else "BANG!" | x <- xs, odd x]
11:08:37 <Cale> Meady: sure thing, what do you need to know?
11:08:37 <Meady> Why cant i feed that boomBangs 20, why does it have to be an array of numbers i.e. [10..20]
11:08:51 <Meady> I started the language today from Python, C and Java
11:08:53 <Cale> It must be a list because x <- xs expects xs to be a list
11:09:11 <Meady> I see, but what is stating it needs to be a list?
11:09:20 <opqdonut> the "x <-" part
11:09:22 <Cale> The definition of list comprehension syntax.
11:09:42 <Cale> (that's just how the syntax works -- it demands that you use lists)
11:09:42 <opqdonut> just like in python [... for x in xs] requires xs to be a sequence
11:09:58 <Meady> yeah i definately get it , i just dont get why it isnt clear
11:10:07 <Cale> hmm...
11:10:13 <Meady> x <- 20 wouldnt seem much different
11:10:25 <ziman> you can regard that as "pulling" each x from xs, one after another
11:10:30 <Cale> > [(x,y,z) | x <- [1,2,3], y <- [4,5], z <- [6,7,8]]
11:10:30 <conal> Meady: you could instead say boomBangs n = [ if x < 10 then "BOOM!" else "BANG!" | x <- [1..n], odd x]
11:10:31 <lambdabot>   [(1,4,6),(1,4,7),(1,4,8),(1,5,6),(1,5,7),(1,5,8),(2,4,6),(2,4,7),(2,4,8),(2...
11:10:46 <conal> Meady: then boomBangs would want a numeric argument.
11:10:46 <Cale> Meady: you could say x <- [20] if you want...
11:10:52 <ziman> pulling an x from a number (e.g. x <- 20) does not make much sense to me
11:10:55 <hackagebot> showdown 0.5.3 - A simple gtk based Russian Roulette game. (AnthonySimpson)
11:11:01 <Meady> yeah i get you but why the [] is what im asking :S, maybe im missing something
11:11:15 <Cale> Meady: [20] is a list with one element. 20 is just a number
11:11:26 <conal> > [ if x < 5 then "BOOM!" else "BANG!" | x <- [1..10], odd x]
11:11:27 <lambdabot>   ["BOOM!","BOOM!","BANG!","BANG!","BANG!"]
11:11:50 <Cale> a list is not a number (without additional instances that aren't in the libraries)
11:11:52 <Meady> Yeah, i understand the difference in types, its a list containing a number as apposed to a number, but i dont get why it wouldnt work with just a number
11:12:05 <Cale> Because there's nothing to select from a number
11:12:11 <Cale> A number is not a collection.
11:12:24 <Cale> (unless you go out of your way to define it as such)
11:12:28 <conal> Meady: it'd be like saying [... for x in 20] in python
11:12:47 <Cale> >>> [x for x in 20]
11:12:47 <Cale> Traceback (most recent call last):
11:12:47 <Cale>   File "<stdin>", line 1, in <module>
11:12:47 <Cale> TypeError: 'int' object is not iterable
11:12:52 <Meady> Yeah
11:13:11 <Meady> So <- will always require a list instead of a specific value
11:13:13 <conal> ">>>" does python evaluation?!
11:13:28 <Cale> conal: I just pasted the output from my python interpreter
11:13:43 <conal> Cale: oh!! i didn't read carefully
11:14:18 <conal> Meady: yeah, a list instead of a non-list
11:14:22 <Cale> Meady: right. If you see x <- xs then if x :: t, then xs :: [t]
11:14:40 <conal> in the golden days, comprehensions were much more general.
11:14:41 <Meady> ahhh that makes sense
11:14:42 <Cale> (in a list comprehension, at least)
11:15:05 <Meady> right that makes sense Cale
11:15:06 <Twey> If I want to throwTo an IOError, how would I do that?
11:15:25 <Cale> It used to be that comprehensions would work in any monad. We still have do-notation for that, but it would still be nice to get it back.
11:15:27 <Twey> IOError doesn't seem to be a GHC.Exception.Exception, or have the relevant classes to convert it to one
11:15:42 <conal> with the recent SQL-ish additions, we're drifting further from the simple generality of monad comprehensions :(
11:16:01 <Cale> In do-notation, if you have x <- xs and x :: t, then xs :: m t, where m is some monad.
11:16:17 <Cale> (possibly the list monad, in which case it does effectively the same thing as in list comprehensions)
11:16:29 <Cale> > do x <- [1,2,3]; y <- [4,5]; return (x,y)
11:16:30 <lambdabot>   [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
11:17:34 <conal> does anyone have ideas on how my domain names are getting resolved to the old server, while 'dig' (now) shows only the new info?
11:17:49 <Meady> so say i wanted x to equal a number not in a list
11:17:59 <Meady> x = 10 wont work i know but what would be equiv?
11:18:06 <Cale> let x = 10
11:18:20 <Cale> > [y | x <- [1..10]; let y = x^2]
11:18:22 <lambdabot>   <no location info>: parse error on input `;'
11:18:26 <Twey> conal: Caching?
11:18:26 <Cale> > [y | x <- [1..10], let y = x^2]
11:18:28 <lambdabot>   [1,4,9,16,25,36,49,64,81,100]
11:18:29 <conal> e.g., running 'curl lambdapix.com' gives new info from the old server when run on my computer but new info from the new server when run elsewhere.
11:18:36 <Axman6> hmm, i remember hearing about a datatype a while ago, that i thought was a finger tree, but apparetly it's not. it had a type something like data Thing a = End | Blah [a] a [a] (Thing a)
11:18:49 <Cale> > [y | x <- [1..10], let y = x^2, even (x + y)]
11:18:50 <lambdabot>   [1,4,9,16,25,36,49,64,81,100]
11:18:56 <Meady> Anyone got any haskell programs they could show me, just want to see some finished proucts that people have worked on
11:19:02 <Cale> heh, of course :P
11:19:06 <opqdonut> Meady: darcs
11:19:10 <Cale> Meady: hmm, sure
11:19:10 <opqdonut> is one of the biggest
11:19:12 <conal> Twey: i thought caching at first.  so i cleared firefox's cache *and* tweaked the content at the old location.  i'm seeing new content from the old server.  odd!
11:19:19 <opqdonut> (a version control system)
11:19:24 <Cale> Meady: What sort of program would you like to look at?
11:19:42 <Cale> http://hackage.haskell.org/packages/archive/pkg-list.html
11:19:44 <Meady> Anything that you applied alot of effort to, maybe even a gui?
11:19:48 <conal> more oddness: curl give me *old* info from the old server for much longer than firefox does.  maybe curl has its own cache.
11:20:08 <Cale> all of those packages have source available
11:20:11 <monochrom> conal: your computer's /etc/resolv.conf may still point to old dns.
11:20:13 <Axman6> @hackage TernaryTrees
11:20:14 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/TernaryTrees
11:20:23 <Twey> conal: Do you have some sort of cache further up the line?
11:20:29 <Twey> My ISP does DNS caching
11:20:52 <Twey> Try switching to (or from) OpenDNS and trying
11:21:02 <Axman6> monochrom: my latest (simple) project is http://hackage.haskell.org/cgi-bin/hackage-scripts/package/TernaryTrees which you could download and take a look at. not saying it's particularly nice code, but it does its job well
11:21:05 <conal> Twey: i think my ISP does also, and hangs onto it for a really long time.  so i tweaked my router settings to use OpenDNS.
11:21:19 <conal> Twey: since then, dig shows me the new info instead of the old info.
11:21:22 <Axman6> uh, not monochrom, Meady
11:21:36 <Twey> Ah good :)
11:21:36 <conal> and yet somehow curl and firefox are pulling up new data from the old server.  :/
11:21:40 <Twey> Hm
11:21:43 <Twey> o.@
11:21:59 <conal> /etc/resolv.conf shows the two OpenDNS nameservers and nothing else.
11:23:03 <Cale> conal: What's the dns? Perhaps I can check what it looks like from here?
11:23:04 <monochrom> I don't know what is curl doing. I can guess firefox needs restart.
11:24:03 <Cale> In firefox, make sure to hold shift when you press refresh to ensure you don't get cached data.
11:24:04 <thoughtpolice> Meady: xmonad!
11:24:17 <conal> Cale: yeah.  i've done super-refresh a few times.
11:24:18 <thoughtpolice> Meady: awesomely small and stable, and I love it as my window manager on my ubuntu system
11:24:20 <conal> Cale: thanks.  i don't understand the question "What's the dns?"  the url is lambdapix.com
11:24:21 <Axman6> Xmonad is awesomeness
11:24:48 <mauke> resolves to 208.94.116.56 208.94.116.9 208.94.117.88
11:24:51 <monochrom> Cale means what is in /etc/resolv.conf so he can reproduce it.
11:24:53 <Cale> conal: that's what I was looking for :)
11:25:05 <Cale> "NFS place-holder page for lambdapix.com."
11:25:11 <Cale> cale@zaphod:~$ host lambdapix.com
11:25:11 <Cale> lambdapix.com has address 208.94.116.56
11:25:11 <Cale> lambdapix.com has address 208.94.117.88
11:25:11 <Cale> lambdapix.com has address 208.94.116.9
11:25:19 <conal> those three IPs are for nearlyfreespeech, as desired.
11:25:28 <opqdonut> lambdapix?
11:25:31 <conal> and that's what dig tells me as well.
11:25:58 <conal> but curl & firefox are *still* getting data from the old host.
11:26:04 <Cale> hmm
11:26:11 <conal> and even see updated versions of that data.
11:26:18 <mauke> well, I know firefox has its own dns cache
11:26:36 <conal> mauke: yow!  i didn't know that.  would explain my problem!
11:26:43 <Cale> It is also possible that the DNS server that you're using has a cache which takes longer than usual to update DNS bindings.
11:26:44 <conal> maybe curl does also.
11:27:23 <Cale> DNS bindings can take an excruciatingly long time to propagate somehow.
11:27:32 <opqdonut> indeed
11:28:29 <conal> i'll look for how to flush firefox's dns cache.
11:28:40 <monochrom> by restarting firefox
11:28:41 <Cale> There seem to be a lot of caches which ignore TTL.
11:29:05 <Axman6> argh, i'm never going to remember what this data structure is called :(
11:29:20 <Cale> (which is frustrating for everyone who has a dynamic IP)
11:29:29 <Cale> Axman6: what is it?
11:29:45 <Axman6> "hmm, i remember hearing about a datatype a while ago, that i thought was a finger tree, but apparetly it's not. it had a type something like data Thing a = End | Blah [a] a [a] (Thing a)"
11:30:14 <Cale> hmm
11:30:22 <conal> i also have the opera browser, so i tried lambdapix.com in it.  also shows me the old server, though i've never visited lambdapix.com in opera.  okay.  i guess there's a really persistent cache somewhere, and i haven't found it yet.
11:30:30 <conal> (dns cache)
11:31:10 <Axman6> i can't remember much else about it, except that it was supposed to hold things in order, and the article had a ascii art representation of how it worked
11:31:28 <Cale> conal: Try doing  host lambdapix.com  from the commandline.
11:31:49 <Cale> conal: That'll tell you what the servers configured in resolv.conf think it's bound to.
11:32:12 <Cale> Axman6: maybe some sort of zipper?
11:32:28 <Axman6> could be, that sounds very familiar
11:34:10 <conal> Cale: i'm getting the three new IP addresses.
11:34:23 <Cale> well, that is odd :)
11:34:34 <Axman6> maybe not :(
11:35:10 <conal> wow.  i'm really impressed with how much i don't know--and others do--about internet mechanics
11:35:45 <thoughtpolice> conal: i know the feeling. :)
11:36:26 <Meady> so with haskell, you declare a function
11:36:32 <Meady> define it, then create instances of it?
11:36:59 <mauke> Meady: no, you define it. the end.
11:37:04 <Meady> I.e myFunc :: String -> String
11:37:06 <Cale> Meady: if by "create instances", you mean apply it to some parameters, then yes
11:37:07 <Axman6> you were doing fine up to the instances part ;)
11:37:24 <Meady> myFunc instance = function here?
11:37:25 <Twey> @index newIORef
11:37:26 <lambdabot> Data.IORef
11:37:33 <mauke> Meady: that's a definition
11:37:47 <Axman6> Meady: oh, i think you mean you implement it, often using pattern matching, so it looks like you're making multiple definitios
11:37:49 <Twey> Is there any reason to use an IORef over an MVar?
11:37:51 <Axman6> n*
11:38:19 <Cale> Twey: IORefs never block
11:38:20 <Axman6> Twey: they're designed for slightly different purposes
11:38:50 <Cale> (and there's no concept of an empty IORef)
11:39:06 <Meady> Anyone got a site that explains it from an OOP view for people switching?
11:39:23 <Twey> Cale: Aha
11:39:25 <Twey> Thanks
11:39:29 <opqdonut> Meady: there is no "OOP view" to haskell :)
11:39:34 <mauke> Meady: I don't get it
11:39:35 <opqdonut> just start learning like it's your first language
11:39:42 <mauke> Meady: what languages do you know?
11:40:23 <Meady> I know
11:41:10 <Meady> Im saying, ive used python damn its code execution, i quit because multithreading isnt really multithreading, C/C++ (wrote a nice Ws2_32 wrapper), and JAVA, it would be nice to see equivilents
11:41:27 <Meady> printf("helloworld"); = putStr "helloworld"
11:41:47 <mauke> String myFunc(String instance) {}  // function definition
11:41:54 <nibro> Meady: the whole point of learning Haskell is to *not* think in an object oriented way
11:42:24 <nibro> Meady: it may be a steeper climb initially, but in the long run you will be better off without such a comparison
11:42:30 <Twey> Meady: Haskell is completely different to all those languages.
11:42:35 <Meady> I know
11:42:40 <Meady> Precedural and functional
11:42:42 <Twey> Comparison is not really helpful
11:42:46 <Meady> im saying, it would make the switch easier
11:42:53 <Twey> Python's probably the closest you'll get
11:43:05 <Meady> OK well ill go play again, and see where i get
11:43:05 <Twey> It's like asking for the plank view of a doughnut :-P
11:43:07 <Cale> Well, comparison is possibly helpful, but first you have to relearn how to program :)
11:43:07 <impl> I don't think this community really cares terribly about making the switch 'easier' in that regard
11:43:16 <nibro> Meady: it would make the switch *seem* easier, but you would actually have a harder time actually learning Haskell
11:43:18 <impl> It's not, um, productive
11:44:03 <Axman6> Meady: you want nice multithreading? then haskell is definitely the language for you. parllelism nd concurrency in haskell are beautiful and damn easy
11:44:07 <monochrom> Comparison makes sense after learning, not before.
11:44:19 <maltem> The right time to compare is when you already understand both concepts, and wonder what is better
11:44:28 <mauke> argh, smort quotes
11:44:41 <Cale> It is actually possible to encode OO concepts in Haskell quite nicely.
11:44:51 <Cale> But it's not the first thing you leap at doing.
11:44:51 <monochrom> I set up a blank virtual machine in my mind to Haskell. I merged it into my main machine after learning.
11:45:15 <Axman6> fibs n | n < 2 = 1; fibs n = a `par` b `par` a+b where a = fibs (n-1); b = fibs (n-2)
11:45:15 <Twey> mauke: No, ‘smart’ quotes are those ones that word processors insert against your will, often in weird places like code listings or instead of apostrophes
11:45:28 <Twey> Ours are just quotes :-P
11:45:37 <maltem> indeed.
11:45:39 <mauke> maltem's aren't quotes
11:45:50 <maltem> mauke, what are they?
11:45:51 <mauke> they're some sort of meta-ctrl-S and -T
11:46:09 <Twey> They're double quotation marks
11:46:15 <mauke> in what encoding?
11:46:17 <Twey> UTF-8
11:46:19 <mauke> no
11:46:21 <Twey> Yup
11:46:25 <maltem> AltGr+b, AltGr+n (where AltGr is ISO-Level3-Shift)
11:46:40 <maltem> mauke, oh, did the encoding fool you?
11:47:01 <Cale> Meady: If you have any specific questions about how to write something, I can perhaps help.
11:47:30 <mauke> Twey: why are you talking back to me?
11:47:36 <sm> JinjingWang's MPS lib is used in eg hack to write thing.function.function , for a more OO/ruby-like experience
11:47:41 <mauke> maltem: what encoding?
11:47:42 <EnglishGent^afk> hello :)
11:47:48 <Twey> mauke: Because it is UTF-8, honest x.x
11:47:53 <mauke> Twey: no, it isn't
11:47:54 <sm> I'm finding it phenomenally confusing, but the jury's still out
11:48:14 <impl> mauke: Yeah it is
11:48:18 <maltem> ...
11:48:19 <Cale> Meady: One thing which it might help to know how to do, even if you don't usually end up writing things this way, is that you can transform a piece of code which makes use of a mutable variable into one which doesn't by making that variable into a function parameter.
11:48:31 <mauke> Twey, impl: dude. I know I'm right, so why do you think it's UTF-8?
11:48:44 <impl> mauke: Because ... my client displays UTF-8 characters and doesn't do any recoding
11:48:47 <impl> and those characters showed up
11:48:52 <Twey> mauke: Do you see “these”?
11:48:53 <Cale> Meady: In Haskell, the only way in which variables vary is that you call a function with different parameters.
11:48:57 <mauke> Twey: yes
11:49:05 <mauke> impl: your client is irssi
11:49:08 <Twey> But you didn't see maltem's.
11:49:09 <mauke> case dismissed
11:49:13 <mauke> Twey: yes
11:49:16 <impl> mauke: I have the terminal set up properly
11:49:24 <impl> I can even see Mandarin characters
11:49:39 <Cale> Meady: and the only things which a function's result depends on are its parameters, and the only thing which it influences is its result
11:49:44 <monochrom> http://www.vex.net/~trebla/weblog/intuitive.html debunks learning by "transition". By definition "new" means incomparable to "old".
11:49:52 <Twey> mauke: Do you see “these”?
11:50:14 <mauke> Twey: yes
11:50:41 <Twey> I copy-pasted maltem's
11:50:45 <mauke> maltem sent 0x93 and 0x94. eight-bit encoding, single byte. definitely not UTF-8
11:50:49 <Cale> Meady: Making use of that information can help to figure out how to structure things -- if a function's result relies on something, make it a parameter to the function. If a function is meant to affect something, make that part of the result (possibly returning a tuple, if you must)
11:50:57 <monochrom> ‘prefered single quote’ “prefered double quote”
11:51:03 <mauke> Twey: so what is your client decoding here?
11:51:11 <Twey> My client does no recoding
11:51:17 <Twey> (in this channel)
11:51:19 <Twey> My terminal does only UTF-8
11:51:51 <monochrom> copy-paste does not preserve encoding.
11:52:08 <mauke> Twey: what does 「/set recode_autodetect_utf8」 say?
11:52:09 <inimino> maltem's are clearly not UTF-8
11:52:20 <Twey> mauke: OFF
11:52:28 <mauke> Twey: and 「/set recode_fallback」?
11:52:41 <Twey> mauke: CP1252
11:52:48 <mauke> ah, some windows codepage
11:52:49 <Twey> Interesting
11:52:50 <|Jedai|> Twey: I agree with mauke : my client is correctly set to use utf-8 and maltem's quotation mark weren't utf8
11:53:04 <Twey> Okay then
11:53:13 * Twey unsets that: it's confusing
11:53:30 <maltem> huh, by checking the logs, turns out my quotes were indeed different
11:53:32 <monochrom> Some software may be “lenient” and try to forgive wrong things.
11:53:59 <monochrom> try to guess what is intended, too.
11:54:45 <monochrom> It's like compiler error mesage saying "type mismatch, perhaps you forgot to save the file?"
11:55:21 <sm> you know what would be kind of useful ? an ide that indicates what monad you're in at each point in the code
11:55:22 <Twey> Hahaha
11:55:38 <mauke> ((->) e)
11:55:40 <mauke> EVERYWHERE
11:55:43 <Twey> sm: haskell-mode can do that (deduce the type of an expression)
11:55:46 <Twey> mauke: Hehe
11:55:51 <ray> only for do blocks, i hope
11:56:02 <|Jedai|> Twey: You don't always know
11:56:15 <|Jedai|> oops, that was for sm
11:56:35 <sm> I definitely don't know right now
11:57:00 <maltem> mauke: Funny, turns out that xchat's default is "IRC (Latin1/Unicode hybrid)"
11:57:16 <opqdonut> at least i'm mostly in the "Monad m => m" monad ;)
11:57:17 <mauke> that's fine, but there are no smart quotes in Latin1
11:57:24 <EnglishGent> how can I set / view the path ghc uses to look for source files? (using GHC on Debian Linux)
11:57:34 <Twey> maltem: o.@
11:57:40 <Twey> maltem: What the heck is that?
11:57:59 <opqdonut> Twey: heuristic
11:58:02 <maltem> Twey, must be some kind of "industry standard" :P
11:58:05 * Twey shudders.
11:58:12 <opqdonut> latin1 and utf-8 being the most common charsets people use on irc
11:58:22 <Twey> For decoding that makes sense
11:58:24 <opqdonut> irssi has heuristic decoding too
11:58:27 <Twey> For encoding, not so much
11:59:07 <monochrom> "Latin1/Unicode hybrid" means unpredictably choose between Latin1 and UTF-8.
11:59:24 <monochrom> OK it's predictable but evil.
11:59:38 <burp> it means: read both, write latin0
11:59:41 <burp> latin1
11:59:42 <mauke> I'm fine with that
12:00:07 <maltem> mauke, what about “this”?
12:00:08 <monochrom> If you mix Latin1 and UTF-8 in the same stream, it's ambiguous.
12:00:12 <mauke> maltem: looks fine
12:00:43 <maltem> Neato.
12:04:08 <tibbe__> what would be a good name for a stream processor monad (that processes a stream of ByteString chunks)?
12:04:17 <delusion42> Can someone explain to me how unsafePerformIO can be used to provide "globals"?  New hpaste up, id 6328
12:04:32 <mauke> wow
12:04:34 <tibbe__> delusion42: try posting a direct link
12:04:45 <delusion42> In particular, I don't understand how the use of tidtoname doesn't result in a new empty hash table being created whenever 'tidtoname' is evaluated
12:04:50 <delusion42> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6328
12:04:54 <jpcooper> hello
12:05:01 <tibbe__> delusion42: if that's what you really want you can use: unsafePerformIO (newIORef foo)
12:05:09 <jpcooper> is there a way in which I can make a map where two different types of key point to the same thing?
12:05:44 <delusion42> tibbe__:  yeah, i realize it's ugly, i'm just attempting to understand why the hash table in that example isn't created anew each time
12:05:49 <tommd> jpcooper: Have two maps?
12:06:06 <maltem> jpcooper, Map (Either k l) a ? Or (Map k a, Map l a) ?
12:06:08 <jpcooper> yeah thanks tommd I obviously didn't think of this
12:06:18 <tibbe__> delusion42: dunno unfortunately
12:06:24 <jpcooper> clearly there's no reason why I wouldn't want two maps
12:07:10 <jpcooper> maltem, I thought I might use Either and define my own Eq instance. I was wondering whether there was a quicker way to do this
12:08:06 <delusion42> tibbe: said another way, let's say I have myFoo =  unsafePerformIO (newIORef foo) at the toplevel.  whenever i refer to myFoo in other functions, why isn't there a new IORef created each time? :) it seems I can use it like a "global variable" but I would think the newIORef would occur each time.
12:08:34 <tibbe> delusion42: it would
12:08:45 <tibbe> delusion42: the NOINLINE is a hack to try to avoid that
12:08:57 <tibbe> delusion42: I guess I should say that it could
12:08:57 <jpcooper> oh apparently Eq is defined for either
12:09:08 <LeoD> @hoogle a -> Bool -> [a]
12:09:09 <lambdabot> Control.Exception assert :: Bool -> a -> a
12:09:09 <lambdabot> Prelude enumFromThen :: Enum a => a -> a -> [a]
12:09:09 <lambdabot> Prelude enumFromTo :: Enum a => a -> a -> [a]
12:09:13 <delusion42> tibbe: ahh, ok. presumably NOINLINE is attempting to force sharing?
12:09:19 <tibbe> delusion42: yes
12:09:33 <delusion42> tibbe: ok, that makes sense. thanks for your help =)
12:09:48 <tibbe> delusion42: no problem
12:09:55 <delusion42> tibbe: any idea if that's a truly reliable way to do it?
12:10:30 <tibbe> delusion42: unfortunately not, I've seen some proposals for top level mutable state but my recommendation atm would be don't do it
12:11:11 <delusion42> tibbe: so in other words, this approach may work for ghc 6.x, etc., but it's really relying on exactly what the pragma implementation is at present.
12:14:07 * pragma_ raises an eyebrow.
12:14:38 <tibbe> delusion42: I'm not 100% sure, I know people use it from time to time but it indeed relies on the pragma enforcing sharing
12:14:59 <tibbe> delusion42: I'm not that familiar with the exact guarantees the pragma gives
12:15:11 <delusion42> tibbe: yeah, just found the HaskellWiki page about it and it says pretty much that.  "works now, but is implementation dependent, don't rely on it"
12:15:15 <Cale> Every use of unsafePerformIO is a hack which needs to take into consideration the particulars of the compiler.
12:15:25 <Cale> (well, essentially every use, anyway)
12:15:43 <tibbe> Cale: even when used to promise that a FFI imported function is pure?
12:15:49 <delusion42> Cale: yeah, i'm not actually advocating this approach or anything, but I'm working on some code that uses it heavily so I needed to ensure that I understood it ;)
12:15:55 <Cale> Well, even there to some extent.
12:16:21 <Cale> Though if it's really pure, you can hope that it doesn't matter :)
12:16:30 <tibbe> :)
12:17:17 <Cale> unsafePerformIO can be viewed as a way to extend the operational semantics of evaluation without having to directly modify the compiler though, and when used in that way, it's definitely something you want to be careful about
12:18:38 <acidjnk> hello
12:18:43 <jpcooper> @pl (getConnection <$>) . lookup (Right sessionID)
12:18:44 <lambdabot> (getConnection <$>) . lookup (Right sessionID)
12:19:16 <Cale> delusion42: To be honest, if I had to maintain code which used top-level mutable variables a lot, I would really consider refactoring everything to remove them.
12:19:40 <acidjnk> "newtype Parser a              =  P (String -> [(a,String)])" is that like in Java interface Parser<a> { List<Pair<a,String>> parse(String s); } ?
12:19:41 <Cale> (even if it meant that my functions would all take a bunch of extra parameters)
12:19:54 <mauke> acidjnk: no
12:19:58 <delusion42> Cale: yeah, i've considered it, but it'd be a *lot* of work; it's used for a logging mechanism that is incredibly pervasive. I'll keep thinking about it.
12:20:02 <Beelsebob> jpcooper: I'd probaly put it as (fmap getConnection) . lookup . Right $ sessionID
12:20:12 <Cale> acidjnk: uh, well, it's a little bit like that, I suppose...
12:20:28 <jpcooper> thanks Beelsebob
12:20:46 <jpcooper> Beelsebob, I didn't think that I could have the . after the lookup because it takes two arguments
12:21:07 <mauke> acidjnk: it's a bit like template<typename a> struct Parser { List< Pair<a, String> > P(String); }; in C++, though
12:21:36 <Beelsebob> jpcooper: you can -- it just results in a function instead of a simple value
12:21:42 <jpcooper> right
12:21:58 <maltem> acidjnk, it's not like an interface. Type classes are more like Java interfaces
12:22:21 <mauke> wait, that was wrong :-(
12:22:30 <Cale> acidjnk: It says that for any type a, the values of type Parser a consist of the data constructor P applied to a value of type String -> [(a,String)] (which you can later extract via pattern matching)
12:22:40 <mauke> List< Pair<a, String> > (&P)(String); maybe
12:23:28 <Cale> Comparing it to Java is probably harder than just trying to understand what it means directly...
12:24:41 <Cale> So a parser, more or less, *is* a function which takes a String, and constructs from it a list of pairs, each consisting of a result, and the remaining (unconsumed) portion of the string.
12:25:24 <jpcooper> @pl fmap getConnection . lookup (Right sessionID)
12:25:25 <lambdabot> fmap getConnection . lookup (Right sessionID)
12:25:45 <acidjnk> Can you show me a simple instance of such a parser, like one that simply returns the argument String?
12:25:50 <jpcooper> @pl getBySessionID sessionID = fmap getConnection . lookup (Right sessionID)
12:25:50 <lambdabot> getBySessionID = (fmap getConnection .) . lookup . Right
12:25:59 <Cale> P (\s -> [(s,"")])
12:26:26 <Cale> That parser always succeeds and eats the entire input string, returning it as the result, with the empty string remaining.
12:26:50 <Cale> How about a parser which eats a single character?
12:27:10 <Cale> P (\s -> case s of [] -> []; (x:xs) -> [(x,xs)])
12:27:20 <Beelsebob> jpcooper: if you have f x = a . b . c . d . e $ x, you can always just drop the x from left and right hand sidez
12:27:22 <Beelsebob> sides*
12:27:33 <jpcooper> sure
12:27:40 <Cale> Here, if the input string s is empty, the parser returns an empty list to signal failure.
12:27:52 <acidjnk> lol, my client just made weird smilies
12:27:57 <Cale> heh
12:28:12 <Beelsebob> acidjnk: what does it do with a robot monkey?
12:28:14 <Beelsebob> (:[])
12:28:14 <acidjnk> but I can reconstruct it
12:28:30 <Cale> If you'd like, I can repaste it :)
12:28:35 <acidjnk> no
12:28:44 <Cale> anyway
12:28:47 <Cale> if the string was not empty
12:28:54 <acidjnk> I'm still on the first example anyway. let myParser = P(\s->[(s,"")]). Why can't I say then "myParser 7"?
12:28:56 <Cale> then it succeeds, giving the first character as the result
12:29:05 <Cale> and the remainder of the string as the remainder
12:29:09 <acidjnk> I mean myParser "7"
12:29:21 <mauke> acidjnk: because it's not a function
12:29:23 <Cale> because myParser :: Parser String
12:29:27 <mauke> at the type level, I mean
12:29:44 <mauke> it's a wrapped function and you have to unwrap it first
12:29:58 <Cale> acidjnk: So, we need a function to apply parsers. It will be easy to write because of our choice of representation of parsers
12:30:12 <Cale> parse :: Parser a -> String -> [(a,String)]
12:30:18 <Cale> parse (P f) s = f s
12:30:39 <Cale> It just unwraps the function contained in the parser, and applies it.
12:31:00 <Cale> The reason we do this wrapping is usually so that we can write separate instances of typeclasses for parsers
12:31:09 <Cale> (especially Monad)
12:31:46 <acidjnk> One other thing, GHCi does not allow pasting at 700 MHz. It works well on my modern CPU.
12:31:49 <acidjnk> Can I fix that somehow?
12:32:01 <Cale> I don't understand your question?
12:32:44 <acidjnk> nvm, one thing at a time
12:33:13 <hackagebot> L-seed 0.2 - Plant growing programming game (JoachimBreitner)
12:33:18 <Cale> The clock speed of your processor shouldn't have anything to do with whether GHCi allows you to paste text, but actually, GHCi has no notion of the clipboard.
12:33:31 <acidjnk> What is f?
12:33:41 <Cale> f is the function inside the Parser value.
12:34:02 <Cale> (P f) is a pattern which matches a parser
12:34:14 <monochrom> Too much to learn.
12:34:19 <Cale> and f is the function which P was applied to when the parser was constructed
12:35:08 <Cale> So in the case of our  eatEverything = P (\s -> [(s,"")])
12:35:19 <Cale> parse eatEverything "hello"
12:35:29 <Cale> --> parse (P (\s -> [(s,"")])) "hello"
12:35:51 <Cale> --> (\s -> [(s,"")]) "hello"  -- f = (\s -> [(s,"")]), s = "hello"
12:36:07 <Cale> --> [("hello", "")]
12:36:22 <Cale> follow that
12:36:23 <Cale> ?
12:36:32 <acidjnk> You can keep talking if you want, but I am still baffled by the first example which just returns the String :-)
12:36:42 <Cale> That's what I'm showing...
12:37:01 <Cale> I applied that parser to a given string to show how it works.
12:38:00 <acidjnk> I never found parsers hard ... until now :-)
12:38:07 <acidjnk> In Java it's a lot of code, but totally easy.
12:38:19 <Cale> This isn't so complicated, once you understand the notation.
12:38:39 <Cale> Do you know how lambdas work? That's certainly essential.
12:38:51 <shachaf> Hmm, how is XHB different from XHSB?
12:38:55 <acidjnk> like \x->x*x?
12:38:57 <Cale> yeah
12:39:01 <PeakerWork> acidjnk: note that much much shorter code is allowed to  have more "difficulty" per character.. You can read it 10x more slowly, and if its 20x shorter, still save time :)
12:39:04 <acidjnk> yes, basically
12:39:13 <Cale> I suppose it's also important to understand pattern matching.
12:39:21 <monochrom> This one is both easier and less code. You will find that backtracking is trivial.
12:39:31 <Cale> data Foo = A Int | B String | C (Int -> String)
12:39:34 <acidjnk> I know those two, but this book introduced many new things at ones.
12:39:46 <Cale> f :: Foo -> String
12:39:53 <Cale> f (A n) = show n
12:39:58 <Cale> f (B s) = s
12:40:05 <Cale> f (C g) = g 0
12:40:12 <Cale> does that code make sense to you?
12:40:32 <acidjnk> No, I don't know data.
12:40:35 <Cale> okay
12:40:41 <Cale> So that's what we should attack first :)
12:40:56 <Cale> (newtype is very much like data)
12:41:07 <skorpan> just totally different somehow
12:41:14 <monochrom> ...
12:41:41 <Cale> So a data declaration consists of:
12:41:52 <Cale> the keyword 'data', followed by
12:42:06 <Cale> the name of a type, possibly with some type variables for parameters
12:42:15 <Cale> followed by '='
12:42:29 <Cale> followed by a |-separated list of cases
12:43:01 <Cale> Where each case consists of: The name of a data constructor, followed by a sequence of types (separated with whitespace)
12:43:18 <Cale> That's a lot to take in, but let's have a look at some examples
12:43:34 <Cale> data Colour = Red | Orange | Yellow | Green | Blue | Violet
12:43:40 <burp> > exp(10^54)
12:43:41 <adept> say, what is the best way to force evaluation of Data.Map?
12:43:42 <lambdabot>   Infinity
12:43:44 <burp> :(
12:43:45 <Cale> This is a simple enumeration of possibilities
12:44:03 <Cale> So it defines 6 new values with those names, and they all have type Colour
12:44:04 <dmhouse> ?type exp
12:44:06 <lambdabot> forall a. (Floating a) => a -> a
12:44:10 <Cale> and every Colour value is one of those
12:44:21 <acidjnk> So the data constructors here take no argument?
12:44:23 <PeakerWork> adept: I don't know if WHNF or HNF in Data.Map is different. If its not, seq and $! and the others should work
12:44:24 <Cale> right
12:44:34 <Cale> We could also do something like:
12:44:48 <Cale> data Person = P String Integer
12:44:58 <Cale> And then we have values like:
12:45:02 <Cale> P "Cale" 26
12:45:06 <Cale>  :: Person
12:45:21 <Cale> and we can write functions like:
12:45:33 <Cale> birthday (P name age) = P name (age + 1)
12:45:45 <Cale> birthday :: Person -> Person
12:45:51 <monochrom> Why would anyone compute exp(10^54) in double-precision float and be unhappy.
12:46:06 <Cale> acidjnk: is that okay?
12:46:13 <acidjnk> wait, let me play with Person a little
12:46:17 <Cale> okay :)
12:46:17 <monochrom> Programmers do not learn "you get what you ask for" neough.
12:47:23 <Meady> Guys out of curiosity, any of you switch from OOP and find it worthwhile?
12:47:34 <Cale> Meady: Yes.
12:47:35 <acidjnk> not me :-)
12:47:43 <acidjnk> But I keep learning it anyway.
12:47:52 <Meady> Cale, are there many jobs in industry for Haskell programming?
12:48:02 <Cale> Meady: OOP has its place, but as a general purpose sledgehammer for everything, I think it's not so good.
12:48:30 <Cale> Meady: There are enough, if you're looking :)
12:48:46 <Meady> I see, so is socket programming in haskell nice?
12:48:59 <acidjnk> Why can't I say: myperson = P "kai" 7 ... birthday myperson?
12:49:11 <Cale> acidjnk: you can
12:49:16 <Philonous> Meady: I found that you can have most of what OOP offers in haskell and many of it is more concise
12:49:16 <skorpan> was that "chi"?
12:49:25 <Cale> acidjnk: though be careful about where you write those two things :)
12:49:30 <skorpan> never mind
12:49:38 <Cale> acidjnk: The first one is a declaration, and it belongs in a source file
12:49:44 <acidjnk> I tried it directly as an expression
12:49:50 <Cale> acidjnk: The second is an expression and it belongs on the ghci commandline
12:49:52 <acidjnk> after loading the source
12:49:59 <Cale> ah, you can try
12:50:04 <Cale> let myperson = P "kai" 7
12:50:06 <Cale> at ghci
12:50:18 * dysfunctor blunders in.
12:50:23 <acidjnk> I get: "No instance for (Show Person)"
12:50:33 <Cale> ghci normally doesn't want declarations, but you can prefix definitions of constants or functions with 'let' if you don't mind writing them all on one line :)
12:50:36 <Cale> ah!
12:50:36 <Axman6> need to add deriving Show
12:50:57 <Cale> acidjnk: yeah, we didn't tell the compiler to derive a way to turn Person values into strings
12:51:01 <Axman6> data Person = ... deriving (Show, Eq) (etc)
12:51:10 <acidjnk> Ok, so it does work, I just didn't tell it how to do toString
12:51:23 <Axman6> show, not toString
12:51:28 <Axman6> :t show
12:51:29 <lambdabot> forall a. (Show a) => a -> String
12:51:32 <FunctorSalad_> greetings, dysfunctor :)
12:51:37 <Cale> yeah, if you add   deriving (Show)   to the end of the data declaration, it'll work :)
12:51:41 <Axman6> wow, it's almost 6AM
12:51:50 <FunctorSalad_> no wai
12:52:03 <Axman6> holidays: fuck yeah!
12:52:05 * dysfunctor Spends a moment trying to figure out how to use Pidgin for IRC.
12:52:18 <Cale> The reason it doesn't do it automatically is in case you want to write your own instance of Show to specify how the values get displayed.
12:52:19 <Axman6> dysfunctor: why :(
12:52:22 <Axman6> use a real client
12:52:40 <dysfunctor> I'm just using the one bundled with Ubuntu.  It seems to do the trick.
12:52:56 <dysfunctor> Anyway, I was coming in because I wanted to pick somebody's brain.
12:53:02 <Cale> dysfunctor: You might try XChat, which also is in the ubuntu repos :)
12:53:11 <dysfunctor> Thanks, Cale.
12:53:14 <Philonous> What's wrong with pidgin?
12:53:14 <Cale> dysfunctor: But feel free to hang around and ask questions :)
12:53:30 <acidjnk> let x = birthday myperson assigns a new person with one age older than myperson to x?
12:53:38 <FunctorSalad_> he doesn't have to ask. he takes the brains containing the answers.
12:53:47 <dysfunctor> My question is: What's the best way to read a floating point binary from a file?
12:53:47 <acidjnk> So Person is very much like a class in Java.
12:53:56 <Cale> acidjnk: yeah, it defines x as the person one year older than myperson (who has the same name)
12:54:01 <Axman6> acidjnk: kind of
12:54:01 <dysfunctor> (In Haskell, of course.)
12:54:15 <Cale> acidjnk: (Just carefully avoiding the word 'assign to')
12:54:16 <Meady> [x*2 | x <- [1..10]] This means that x is values 1-10, and each value is * 2 right?
12:54:30 <Cale> Meady: right
12:54:36 <Cale> > [x*2 | x <- [1..10]]
12:54:36 <Axman6> dysfunctor: could try the data-binary-ieee743 package
12:54:37 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
12:54:41 <dysfunctor> I've found a library for serialising and deserialising data for consumption by other Haskell programs, but nothing that will just grab a binary from a file and shove it in a CDouble.
12:54:43 <Cale> > [(x,x*2) | x <- [1..10]]
12:54:45 <lambdabot>   [(1,2),(2,4),(3,6),(4,8),(5,10),(6,12),(7,14),(8,16),(9,18),(10,20)]
12:54:55 <dysfunctor> Axman6: Ah, yes.  That sounds like exactly what I need.  THanks!
12:55:08 <Axman6> Meady: that's the best new commer's explanation of it i've ever heard :)
12:55:13 <pikhq> > do x <- [1..10];return (x*2)
12:55:15 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
12:55:24 <Axman6> lots of people have a lot of trouble with the x is all the values
12:55:26 <Axman6> part
12:55:29 <acidjnk> Wow, I did incredibly complicated things like "getage (P name age) = age". What a day.
12:55:30 <Meady> So we would make that a function by doing myFunc :: int -> int? and then myFunc instance = [code i mentioned above]?
12:55:36 <Cale> acidjnk: :)
12:55:56 <Cale> acidjnk: so if you're happy with that...
12:56:05 <acidjnk> Ok, you can continue now, I got that "data" thing. :-)
12:56:29 <Cale> Okay, do you get the type parameters part? I didn't give an example of that, but our Parser type is.
12:56:34 <Axman6> Meady: what do you want the function to do?
12:56:59 <acidjnk> What are the type parameters there?
12:57:25 <Cale> acidjnk: For   data Parser a = P (String -> [(a,String)])
12:57:26 <Meady> Well im just on learnyouahaskell at the moment, just trying to understand assignment
12:57:28 <Cale> the type parameter is a
12:57:35 <Meady> I cant shake the OOP from my head
12:57:43 <Cale> acidjnk: This just means that, for instance:
12:57:49 <acidjnk> It's probably like parser<A> in Java.
12:57:58 <Cale> data Parser Int = P (String -> [(Int, String)])
12:58:00 <Cale> and so on
12:58:07 <Philonous> acidjnk: Btw. you can let the compiler figure out the getter functions for you
12:58:19 <Cale> (though you can't actually write it that way)
12:58:37 <Axman6> Meady: well, haskell is very mathematical, so try and think of functions as mathematical functions, and assignment the same way (ie, x can't be 7, and then later be reassigned to 10)
12:58:43 <acidjnk> Yes, it's like a type parameter in other languages.
12:58:51 <Cale> Yeah, I suppose I could show the record syntax, but let's try to get to what it was that acidjnk was originally trying to understand :)
12:59:00 <Cale> acidjnk: right :)
12:59:16 <Cale> acidjnk: Actually it was a bunch of Haskell guys who added that feature to Java, iirc.
12:59:40 <monochrom> Phil Wadler did it.
12:59:46 <Cale> right, right :)
12:59:49 <acidjnk> It's horribly complicated in Java. Never understood the full spec.
13:00:02 <Cale> Yeah, Java is not the best platform for such a feature to exist in.
13:00:21 <acidjnk> There are lots of bugs regarding generics as well.
13:00:25 <Cale> The interactions with subtyping are complicated.
13:00:26 <Axman6> i think it works fairly well i java
13:00:28 <Philonous> Cale: It was just meant for him to get a taste of it. First things first!
13:00:41 <acidjnk> You can get all compilers < 1.6 throw an AssertionError at compile time given the wrong source code.
13:01:09 <acidjnk> Like class C<A> { A a;} ... new C<Integer>().a++;
13:01:28 <acidjnk> Lots of such bugs when 2 or more 1.5-features are mixed :-)
13:01:33 <Cale> :)
13:01:52 <acidjnk> Ok, on to newtype?
13:01:54 <Axman6> but a hasn't been assigned...
13:02:07 <acidjnk> It's null implicitly, Axman6.
13:02:13 <Cale> newtype is exactly like data except that you're only allowed one case, and only one field
13:02:22 <monochrom> Haskell doesn't have subtype (subclass) so type parameter is straightforward.
13:02:38 <Cale> (and there are some very subtle differences in the pattern matching semantics)
13:02:39 <pikhq> Meady: If you just want a function that returns [x*2 | x <- [1..10]]? Yeah, that's not a function, just a variable of type [Int].
13:02:58 <Cale> The reason for it is to allow the compiler to implement a value of the newtype using a value of the original type
13:03:08 <Cale> But in all other ways, it's like data, just a little more efficient.
13:03:19 <FunctorSalad_> btw, we had the issue of "OO interfaces vs. typeclasses" several times...
13:03:29 <nlogax> Meady: where does "instance" come from? that would just be an argument. myFunc a = a * 2 for an awesome double up function
13:03:40 <Cale> So you can imagine, if you like, that
13:03:51 <acidjnk> Ok thanks, I think I fully understood the parser definition then.
13:03:54 <Cale> data Parser a = P (String -> [(a,String)])
13:03:57 <FunctorSalad_> isn't one important difference that with typeclasses you get arbitrary variance? (co/contra/none)
13:03:59 <nlogax> Meady: and if you're in ghci, you can just play around and do :t someFunction to see its type
13:04:02 <Cale> if you prefer :)
13:04:34 <Cale> acidjnk: So a value of type Parser Integer, for instance, looks like P f where f is a function of type String -> [(Integer, String)]
13:05:01 <Cale> acidjnk: and we can write functions which take a parser as a parameter and pattern match using P
13:05:04 <Meady> Sorry nlogax, i keep saying instance, where you declare a function and give ie a var
13:05:05 <Meady> i.e.
13:05:24 <Meady> myFunc :: string->string, then myFunc a (i sortof see that as an instance of that function myFunc
13:05:34 <monochrom> I can't think of a good use of mfix for the State monad.
13:05:42 <nlogax> Meady: oh, i was just worried you were confusing it with something else :)
13:05:43 <mauke> Meady: that's just a function definition
13:05:53 <PeakerWork> type-classes are more space-efficient than OO interfaces, too
13:05:59 <PeakerWork> (at least, OO's single-dispatch interfaces)
13:05:59 <nlogax> Meady: the first snippet is just a type signature (should be String btw)
13:06:11 <Meady> I know, i was typing fast, i just cant shake OOP from my head
13:06:13 <Cale> monochrom: Maybe some stateful construction of a circular datastructure?
13:06:17 <Meady> making a class then creating mutiple instances :S
13:06:17 <Axman6> Meady: i think the word implementation is much more appropriate than instance
13:06:31 <mauke> Meady: in what OOP language do you have to create instances of methods before you can use them?
13:06:43 <acidjnk> Hm. The concepts are not hard. My problem most of the time is when people / books use many new syntactic things I don't know.
13:06:46 <monochrom> Cale: The problem is fix itself is already very successful at that.
13:06:51 <Cale> acidjnk: yeah...
13:06:59 <FunctorSalad_> maybe Meady just means closures with "instances of functions"? (but I just joined)
13:06:59 <Cale> monochrom: hmm :)
13:07:13 <Cale> monochrom: But you might get some use out of the mdo syntax...
13:07:53 <acidjnk> dibblego uses this example:
13:07:54 <acidjnk> data Parser a = P {
13:07:54 <acidjnk>   parse :: String -> Maybe (String, a)
13:07:54 <acidjnk> }
13:07:55 <Cale> acidjnk: So does that definition of parse make sense now?
13:07:55 <Meady> I probably do lol im trying to forget OOP because i keep relating to it :S
13:07:56 <Cale> ah
13:08:02 <monochrom> Perhaps mfix for State is not supposed to be interesting. Rather, mfix for StateT is a necessity.
13:08:06 <maltem> Meady, when in #haskell, try and say “value” or something when you are tempted to say “instance“. Just to remove confusion, “instance” being a keyword
13:08:23 <Cale> acidjnk: Okay, so his parsers can fail, but they're not nondeterministic -- they can have at most one possible parse
13:08:30 <monochrom> Yeah set up a blank virtual machine in your mind to learn haskell.
13:08:32 <acidjnk> So here he just named the parameter of the constructor "parse", and he used Maybe instead of the convention of an empty list for nothing and a singleton for something.
13:08:34 <nlogax> Meady: have you read the "syntax in functions" chapter in LYAH ?
13:08:34 <Cale> acidjnk:  data Maybe a = Nothing | Just a
13:08:42 <Cale> acidjnk: right
13:08:48 <Meady> im literally just going through the start of learnyouahaskell
13:08:53 <Cale> acidjnk: Maybe is like lists restricted to length at most 1
13:09:16 <FunctorSalad_> closures are kinda similar to (immutable) instances of some object
13:09:25 <FunctorSalad_> (kinda.)
13:09:34 <Meady> Any other sites that may clear my head up give me links im open for suggestion lol
13:09:41 <acidjnk> The book probably tries to simplify it by using a singleton for Just and an empty list for Nothing.
13:09:41 <Cale> Meady: If you want, I can explain some techniques at some point for doing OOP-like things in Haskell, but you should learn all the basics of Haskell first :)
13:09:50 <Axman6> there's a haskell for C devs tutorial somewhere
13:10:17 <Meady> Ahh that would be awsome, i shall google it, and yeah Cale would be nice friend, everyone here is quite helpful
13:10:29 <LeoD> @pl \x -> (x, [])
13:10:30 <lambdabot> flip (,) []
13:10:33 <acidjnk> yes, thanks again Cale
13:10:46 <flipflap> What's better for handling exception? try or catch?
13:10:54 <acidjnk> You really get me through the hours when dibblego is asleep.
13:10:56 <Cale> acidjnk: It's worth noting, before you go, that data types can be recursive
13:11:13 <Meady> http://www.haskell.org/~pairwise/intro/intro.html
13:11:21 <Cale> For example, suppose we want a binary tree having nodes that are labelled with values of type a
13:11:34 <Cale> data Tree a = Leaf | Branch a (Tree a) (Tree a)
13:12:02 <Cale> So a value of type (Tree a) is either a Leaf (empty tree), or it is a Branch with a value of type a, and two subtrees.
13:12:13 <Cale> and we can construct a tree like
13:12:38 <Cale> Branch 1 (Branch 0 Leaf Leaf) (Branch 2 Leaf Leaf)
13:12:47 <Cale>   1
13:12:51 <Cale>  / \
13:12:56 <Cale> 0   2
13:13:27 <Cale> and write functions on trees which pattern match on the structure:
13:13:31 <Cale> size Leaf = 0
13:13:40 <Cale> size (Branch x l r) = 1 + size l + size r
13:13:56 <Cale> (compare that with the equivalent Java code!)
13:14:13 <Philonous> Data types a somewhat like grammars of formal languages
13:14:13 <acidjnk> Ok, that is not hard now that I got the syntax, thanks!
13:14:47 <Meady> Anyone worked with sockets in haskell?
13:15:05 <Axman6> Meady: i believe they're very easy in haskell, but i may be wrong
13:15:51 <Philonous> With concrete types being terminal symbols and parametrised types being the nonterminal ones
13:15:53 <Cale> Meady: If you're just looking to write simple internet clients, there's a nice tutorial which shows how to write an IRC bot lying around
13:16:25 <Axman6> Meady: http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
13:16:32 <Axman6> what Cale was referring to
13:16:34 <troutwine> Meady: I, personally, recommend the IRC bot tutorial, if you're already familiar with sockets in general.
13:16:51 <Cale> There's a nice high-level interface to sockets which lets you avoid most of the nonsense which you'd normally not care about.
13:16:56 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/network/Network.html
13:17:19 <Axman6> i'm impressed. nearlyfreespeech,.net has ghc installed and usable for websites (6.8.3 only, but better than nothing)
13:18:03 <BMeph> I'd love to see GHC on the BeOS reboot, Haiku. That sounds fun. :)
13:18:20 <Cale> BeOS was so cool. I hope Haiku does well.
13:18:51 <BMeph> Cale: For a pre-alpha project, it's already very well put together. :)
13:19:19 <Cale> Have you tried it? Is it at all usable?
13:20:27 * Cale looks at screenshots. This looks quite a bit better than last time I peeked at it :)
13:20:39 <BMeph> flipflap: try and catch work similarly to how they're used in imperative ones. (With various caveats on the use of "use".) :)
13:21:55 <BMeph> Cale: I only noticed the slashdot acticle, and read the links from that. I haven't tried to run it myself - yet. I may, though, if I get some free time next weekend. :)
13:22:18 <ehird> 21:17 Axman6: i'm impressed. nearlyfreespeech,.net has ghc installed and usable for websites (6.8.3 only, but better than nothing)
13:22:20 <ehird> Only CGI.
13:22:35 <Axman6> still
13:22:52 <Axman6> means i can use (the already installed) darcs
13:22:55 <ehird> CGI with a really old ghc version... I'm so excited... :p
13:22:58 <Axman6> and finally figure out how to use it
13:23:58 <Meady> Anyone made any nice GUI apps with any Haskell libs?
13:24:35 <Axman6> there's leksah, a haskell IDE written in haskell. it was pretty buggy last time i saw it
13:25:23 <PeakerWork> lleksah would be a more senseful name... :)
13:26:22 <Philonous> Axman6: Someone should get 6.10 into the ports  *cough*
13:26:35 <Axman6> yes ideed
13:26:49 <troutwine> Meady: Rich web clients, yes.
13:27:53 <Cale> Meady: I've done a small Gtk2Hs app called nymphaea that generates L-system fractals.
13:28:24 <Axman6> to be honest, i don't find gui's to be at all interesting
13:28:37 <Cale> Meady: A nice strategy is to use glade to construct a GUI layout, which you can then use gtk2hs to load.
13:29:35 <Cale> I think GUIs are very interesting, but I don't often write them for my own programs.
13:29:59 <PeakerWork> gtk2hs is a monster :-(
13:30:06 <Cale> A bit of one, yes. :)
13:31:06 <dmhouse> Yeah, an L-system generator without a GUI would be quite boring..
13:31:42 <Meady> foo bar = bar * 10 + 4
13:31:42 <Meady> in this are we saying call function foo with the argument as bar?
13:31:56 <Meady> so foo 10 = 104?
13:32:01 <Cale> yeah
13:32:05 <Axman6> i wrote a cellular automata program in erlang that put each generation in a new PNG...
13:32:11 <dmhouse> Meady: we define a function foo, which takes an argument called bar, and returns bar*10 + 4
13:32:17 <Cale> Meady: you're defining the function foo in terms of the result when it is applied to bar
13:33:20 <ac> how do I get lambdabot to show the source for a specific instance?
13:33:27 <Meady> ok makes sense, so its saying here everything is hard coded on compile, what if the input isnt ready until say user input
13:33:58 <mauke> Meady: er, huh?
13:33:59 <Cale> Meady: Well, the function foo does not care where it gets the number from.
13:34:05 <Meady> I see
13:34:23 <mauke> that sounds like you've never seen function parameters before
13:34:36 <Cale> Meady: It has nothing at all to do with input or output, only that it receives a number when it is applied, and it results in a number.
13:34:39 <dmhouse> It's exactly comparable to doing something like int foo(int bar) { return 10*bar + 4; } in C, if you're familiar with that.
13:34:47 <PeakerWork> @src MonadTrans
13:34:47 <lambdabot> Source not found. You speak an infinite deal of nothing
13:34:49 <Meady> Nono i have, im trying to forget C and go into Haskell
13:35:04 <Meady> Yeah dmhouse makes perfect sense
13:35:09 <ac> :src fmap ((,) a)
13:35:24 <ac> @src fmap ((,) a)
13:35:25 <lambdabot> Source not found. I feel much better now.
13:35:44 <Cale> fmap f (x,y) = (x,f y)
13:35:59 <Cale> @src (,) fmap
13:35:59 <lambdabot> fmap f (x,y) = (x, f y)
13:36:34 <ac> huh. Why isn't it: fmap f (x, y) = (f x, y) -- ?
13:36:58 <Cale> Because the type system won't let it be that.
13:37:03 <Igloo> Because it's   Functor ((,) a)
13:37:24 <ac> it could be Functor (,a)
13:37:28 <Cale> We don't have type-level lambda, so the instance which applies it to the first parameter is inexpressible.
13:37:40 <Cale> and (,a) isn't valid.
13:37:44 <ehird> Which SUCKS.
13:37:51 <ehird> S u c k s
13:37:56 <copumpkin> a type-level lambda would be nice to have :)
13:37:58 <Cale> I think it's important for type inference to work.
13:38:09 <ehird> copumpkin: and type-alias currying
13:38:12 <copumpkin> seems like it wouldn't be too hard
13:38:16 <copumpkin> I dunno though
13:38:16 <ehird> even though that lets you do freaky stuff
13:38:19 <dmhouse> ac: no, it couldn't. Type-level sections aren't possible, so you'd need something like /\ x -> (,) x a
13:38:33 <tommd> Why does leksah have such a specific Cabal version requirement?
13:38:38 <dmhouse> Type-level lambda makes inference undecideable, IIRC.
13:38:51 <tommd> It doesn't seem to be necessary - just annoying
13:38:55 <ac> dmhouse: but that's using a type level lambda
13:39:06 <dmhouse> ac, yes, precisely my point.
13:39:18 <ac> dmhouse: ok. my question was more interesting than I realized
13:39:20 <Igloo> tommd: What is it?
13:39:25 <dmhouse> (,a) needs type-level lambda. (a,) doesn't because you can beta-reduce that to (,) a
13:39:35 <FunctorSalad_> dmhouse: how is it stronger than newtype?
13:39:40 <dmhouse> Partial application is okay.
13:39:44 <FunctorSalad_> (typelevel lamda)
13:40:17 <ac> hm, you can't section (,) anyway
13:40:24 <tommd> Igloo: Leksah requires a specific version of Cabal to install
13:40:28 <dmhouse> FunctorSalad_: I'm speaking from mostly ignorance, I'm not an expert in these matters, just saying what I recall. But perhaps that newtype is tagged?
13:40:41 <Igloo> tommd: Do you mean an exact version, Cabal == x?
13:40:42 <FunctorSalad_> dmhouse: yeah, I'm not sure either
13:40:47 <copumpkin> dmhouse: why? it seems like any type-level lambda can be desugared to a type synonym or newtype
13:40:51 <tommd> Igloo: But it's unneeded, I removed the restriction and installed with a slightly newer version.
13:41:02 <copumpkin> dmhouse: oh that's what FunctorSalad_ just said, whoops :P
13:41:02 <tommd> Igloo: yes, something like 1.6.0.1
13:41:13 <ziman> FunctorSalad_, http://kyberia.sk/id/4432031/
13:41:16 <Cale> Yeah, newtype defines a new type tag. You can do it with newtype in Haskell presently with no problem.
13:41:37 <dmhouse> copumpkin: you need sugar at the value level too (with newtype) because of the tagging
13:41:54 <copumpkin> how about using type synonyms instead of newtype?
13:42:10 <monochrom> not good for instancing a typeclass
13:42:12 <dmhouse> Type synonyms aren't allowed in instance heads either.
13:42:26 <ac> yeah I've run in to that problem
13:42:31 <FunctorSalad_> ziman: I see. how did you find that so quickly? ;)
13:42:34 <monochrom> Haskell 7 will solve all those problems and run faster.
13:42:45 <copumpkin> lol
13:42:46 <ac> monochrom: are you serious?
13:42:51 <monochrom> No.
13:42:53 <copumpkin> TypeSynonymInstances ?
13:43:07 <Cale> newtype Flip f x y = Flip (f y x); instance Functor (Flip (,) y) where fmap f (Flip (x,y)) = Flip (f x, y)
13:43:13 <ehird> i wonder if Haskell' will start a trend.
13:43:21 <ehird> H'^7
13:43:25 <ehird> Haskell'''''''
13:43:28 <ehird> We could be as cool as Scheme.
13:43:38 <copumpkin> I thought haskell' was a temporary name
13:43:39 <dmhouse> Isn't it about bloody time haskell-prime was released? What's holding it up?
13:43:48 <monochrom> After Haskell' is Haskell( . Look at your ASCII table.
13:44:01 <ehird> copumpkin: stfu :(
13:44:06 <copumpkin> dmhouse: last I looked they hadn't decided on whether to redo the typeclasses in prelude... I'm hoping they decide in favor of doing it :P
13:44:08 <ehird> monochrom: I can't wait for Haskell\255
13:44:08 <Cale> Oh no! That looks too much like HaskellC!
13:44:56 <ac> Obviously it'd be Haskell''
13:44:57 <skorpan> Haskell#... IO only haskell
13:45:00 <Elly> where does Caleskell come in?
13:45:23 <dmhouse> Haskell# -- where nothing is boxed?
13:45:29 <ziman> FunctorSalad_, i keep a private archive of #haskell and #haskell-blah excerpts that i find interesting and i just grepped for "type lambda" there :)
13:45:40 <Cale> Haskell\1114111
13:45:43 <FunctorSalad_> will haskell' be an upgrade or a seperate lang?
13:45:46 <idnar> H45k311
13:45:56 <copumpkin> idnar: the version for hackers?
13:46:03 <idnar> or maybe just Haskel1
13:46:04 <Cale> FunctorSalad_: Haskell' is a formalisation of what already exists.
13:46:06 <dmhouse> Can we have goto for haskell'? :)
13:46:12 <idnar> each successive version can change one more letter into a digit
13:46:13 <Cale> I am not excited about it.
13:46:25 <Raynes> Goto in Haskell? Heresy. o_o
13:46:27 <copumpkin> Cale: in the list of proposed changes, there was an undecided reworking of the prelude, though!
13:46:28 <dmhouse> Cale: it'd be nice to have a new language version after 11 years
13:46:35 <Cale> copumpkin: hmm
13:46:40 <idnar> Raynes: we already have the Cont monad
13:46:43 <copumpkin> I was also surprised to see that there's a private mailing list about it
13:46:47 <dmhouse> The pace of work on haskell' is pretty slow.
13:47:04 <copumpkin> seems kind of odd to need a private mailing list on something like this
13:47:14 <Cale> See, I think that we should not be afraid to break compatibility with the standard in our implementations (so long as implementations which follow the standard still exist)
13:47:18 <dmhouse> It's private? I'm certainly subscribed...
13:47:18 <monochrom> I want unsafeCallCC
13:47:27 <copumpkin> maybe something that doesn't accept external postings, but something that we can't even read? :o
13:47:29 <Cale> and then we should only standardise things which have been tried.
13:47:45 <dmhouse> Cale: that is the general approach to haskell', isn't it?
13:47:45 <PeakerWork> dmhouse: we already have goto
13:47:54 <PeakerWork> (callCC yeah)
13:47:56 <Cale> There's another viewpoint which says that we should standardise things first, and then implement them.
13:47:58 <dmhouse> Nothing's accepted that hasn't already been implemented?
13:47:59 <copumpkin> dmhouse: http://www.haskell.org/mailman/private/haskell-prime-private/2008-March/000535.html ?
13:48:06 <ac> I imagine Haskell' will have an even higher learning curve :-P
13:48:10 <dmhouse> copumpkin: okay, I'm not on -private
13:48:16 <Cale> But we seem to be stuck in a bit of a rut with regard to certain things, like the Prelude.
13:48:32 <Cale> Where we're trying to have our standard cake and eat it too, so nothing can be changed ever.
13:48:32 <copumpkin> http://hackage.haskell.org/trac/haskell-prime/wiki/Prelude is still in the undecided category
13:48:44 <Cale> This is clearly unacceptable.
13:49:04 <dmhouse> haskell-prime was meant to be a "relatively conservative" iteration.
13:49:21 <Cale> I think we should change the Prelude without standardisation first. If Haskell' wants a new Prelude then it can wait.
13:49:22 <dmhouse> The latest information on the wiki is an update from March 08 saying the committee is picking up momentum again and things are getting decided.
13:49:23 <copumpkin> I still think a "conservative" restructuring of the prelude could be hugely beneficial
13:49:31 <idnar> Cale: "so long as implementations which follow the standard still exist" -- does that actually happen, though?
13:49:36 <Cale> idnar: Sure.
13:49:38 <idnar> Cale: eg. are old GHC implementations maintained?
13:49:52 <Cale> idnar: Current GHC implementations have a Haskell 98 mode.
13:50:02 <maltem> “conservative” can mean anything
13:50:06 <idnar> Cale: well, I guess the things I'm thinking of are not actually standardised per se
13:50:15 <idnar> Cale: I'm thinking of stuff like the exception changes
13:50:16 <dmhouse> I think it's important to bring the standard up to date with the implementations, though. Otherwise there's no point of having a standard any way.
13:50:25 <Cale> dmhouse: right
13:50:35 <Cale> dmhouse: Haskell98 is all-but-irrelevant
13:50:54 <dmhouse> At the pace we're currently working at, we'll finally have standardised the state of Haskell compilers in 2002 by about 2015.
13:50:58 <Cale> to some extent, we don't really need a standard all that much
13:51:12 <dmhouse> Well, that's mostly because GHC is so dominant.
13:51:13 <dsturnbull> *cough* lisp
13:51:21 <copumpkin> I tend to write ghcskell more than I write haskell :P
13:51:22 <Cale> The Haskell community still seems too small to support more than one first-rate compiler project.
13:51:38 <FunctorSalad_> is the issue funding?
13:51:49 <Cale> and the smaller compilers are experimental anyway, so nobody's all that concerned that they're completely adherent to any given standard.
13:51:55 <dmhouse> Cale: the problem is that you then require anyone who's interested in language design to be a GHC hacker.
13:51:58 <idnar> Cale: surely that makes it even more of a problem when that single compiler project breaks backwards compatibility?
13:52:05 <mornfall> Well, the Haskell situation is still immensely better than Ruby or Python situation, at least as it seems to me.
13:52:12 <Cale> dmhouse: do you?
13:52:15 <mornfall> (Or Perl situation.)
13:52:23 <Meady> Could someone explain doubleIt :: Num a => a -> a
13:52:23 <Meady> I understand doubleIt returns type a and but whats it doing first?
13:52:35 <mornfall> Meady: Hard to tell. ;)
13:52:37 <Berengal> Meady: Doubles it
13:52:39 <Heffalump> I think the funding from MS distorts the Haskell compiler "market" somewhat
13:52:41 <maltem> mornfall, Haskell is in the lucky situation that it at least started out with a standard, as opposed to those others :)
13:52:42 <Berengal> Is my guess...
13:52:43 <mornfall> From name, I guess it'll double the value.
13:52:46 <Cale> Meady: it takes some type of number and produces that same type of number
13:52:46 <Heffalump> I wonder where Haskell would be without it
13:52:50 <dmhouse> Cale: as in, if GHC defines the language, then if you want to help design the language, you need to help design GHC.
13:52:52 <mauke> Meady: 'Num a =>' is a type constraint
13:52:58 <monochrom> "doubleIt" probably multiplies a number by 2.
13:52:59 <Heffalump> (substantially worse, no doubt, but probably with more competing implementations)
13:53:03 <mauke> Meady: it means the type a must support certain operations
13:53:19 <idnar> Meady: the 'Num a =>' part says that 'a' isn't just any old type 'a', but that it has an instance of Num a, which means the operations in the Num typeclass can be used with it
13:53:30 <idnar> (the functions? the methods? what do you call 'em?)
13:53:45 <Cale> dmhouse: well, you can also design another compiler (like people are doing), and it can be Haskell too, just maybe not the same Haskell.
13:53:47 <Berengal> ghc's -e option has grown on me. I find myself using it in shell scripts more and more...
13:53:53 <mornfall> Heffalump: Well, there's still (almost?) half a dozen implementations. Maybe half of them are fairly usable, too.
13:53:53 <monochrom> methods
13:54:06 * Heffalump never uses any of them
13:54:11 <Cale> dmhouse: Or you can say things on the mailing list and hope that GHC hackers hear you, which is basically what we have now anyway.
13:54:13 <Heffalump> Hugs very occasionally perhaps
13:54:15 <mornfall> Heffalump: We use hugs for teaching.
13:54:16 <FunctorSalad_> I suppose there are many people who'd like to work on haskell infrastructure if they didn't have to do something else for a living
13:54:29 <idnar> mornfall: there's at least 4 Python implementations...
13:54:39 <copumpkin> and several ruby implementations too
13:54:48 <copumpkin> one of them is trying to standardize all of them (but it isn't the main one)
13:54:59 <mornfall> Aren't those just hacked-up versions of the original implementation?
13:55:01 <ac> FunctorSalad_: I am one of those people. Problem is I'm not smart enough yet
13:55:02 <mornfall> In most cases, anyway.
13:55:04 <copumpkin> and the standard is in the form of a test suite, strangely enough
13:55:10 <ac> FunctorSalad_: (to work on the Haskell infrastructure)
13:55:12 <idnar> mornfall: do you mean Python, or Ruby?
13:55:18 <mornfall> idnar: Either. :)
13:55:22 <copumpkin> mornfall: definitely not the ruby ones
13:55:23 <Berengal> copumpkin: Not too strange, considering the language
13:55:25 <copumpkin> I'm not familiar with the python
13:55:25 <Cale> It's possibly unfortunate, but the existing situation is that most Haskell code in existence requires GHC.
13:55:32 <idnar> mornfall: none of the Python implementations I'm thinking of are based on the original in any significant way
13:55:39 <idnar> mornfall: they're all written in different languages, for example
13:55:48 <mornfall> Interesting.
13:55:50 <Cale> and so even if we have a standard, it's as if we don't.
13:55:58 <copumpkin> mornfall: one of them has a lightweight C++ RTS and reimplements most of the language in ruby itself, another one runs on .net, another on jvm, and another one is its own VM that replaces the current mainstream version
13:56:05 <zebrafinch> idnar: unladen-swallow is a fork of cpython, but IronPython/Jython/PyPy aren't
13:56:10 <idnar> mornfall: the original Python (also known as CPython) is written in C; IronPython is written in C# and runs on .NET, Jython is written in Java and runs on the JVM, and PyPy is written in Python
13:56:22 <mornfall> idnar: Interesting.
13:56:24 <idnar> zebrafinch: I wasn't really counting unladen-swallow
13:56:55 <monochrom> It's the same with Java.
13:56:56 <idnar> mornfall: unfortunately, odds are that any significantly-sized Python project will only run on CPython
13:57:02 <mornfall> idnar: I knew about different targets, but didn't think of those being completely from-scratch implementations.
13:57:07 <idnar> mornfall: because the dependent libraries are missing on the other implementations
13:57:35 <Berengal> Java is different. It has several compilers, and several runtime systems, all of which theoretically are interchangeable
13:57:40 <mornfall> But now that you say it, it makes sense. I guess part of the CPython stdlib is actually written in C. (How unfortunate.)
13:57:56 <pikhq> Berengal: And in practice, *most* of them are interchangeable.
13:58:03 <idnar> mornfall: a /lot/ of third-party CPython extension modules are also written in C
13:58:05 <SamB> mornfall: so is some of Prelude -- your point being?
13:58:14 <Berengal> pikhq: It's quite nifty, really...
13:58:25 <Cale> Well, we certainly don't want to end up where Perl ended up, with one implementation of something so hideously complicated that nobody could even write a parser to parse the same language. But I don't think we'll end up going there anyway.
13:58:29 <mornfall> SamB: Prelude is a tiny fraction of the stdlib.
13:58:35 <idnar> mornfall: those are the ones wrapping existing C libraries and such, of course
13:58:41 <Berengal> Also, you could consider things like jythonc java compilers, or at least a compiler targeting the jvm
13:58:47 <pikhq> Cale: Fun fact: there are no Perl parsers.
13:58:49 <pikhq> None at all.
13:58:51 <SamB> and let's not forget the Posix.* stuff
13:58:57 <SimonRC> Cale: no, we'll do it with typesystems instead
13:59:00 <idnar> the situation in Haskell-land isn't quite the same, but I imagine you also have a lot of Haskell code that won't run on anything except GHC, because it needs GHC features
13:59:06 <pikhq> The official Perl implementation only parses a subset of Perl.
13:59:12 <copumpkin> SamB: that's just FFI-ing to posix calls isn't it?
13:59:21 <SimonRC> ;-)
13:59:23 <pikhq> (in order to parse Perl, you need to solve the halting problem.)
13:59:25 <SamB> okay, Python *is* worse about it
13:59:28 <idnar> on the other hand, Haskell has a standard and /native/ FFI system
13:59:31 <mauke> pikhq: what doesn't it parse?
13:59:32 <monochrom> Haskellers are much better at specifying than Perlers.
13:59:35 <SamB> if you call that worse
13:59:40 <Cale> SimonRC: Well, our typesystem extensions are complicated, but they have the nice property of being specified by academic papers, at least to a fair extent.
13:59:47 <SimonRC> yeah
13:59:48 <mornfall> Anyway, gotta run, the tea place is closing. ;)
13:59:49 <idnar> Python has ctypes, but that's hardly universal
13:59:52 <mornfall> Bbiab, maybe.
13:59:55 <SamB> Cale: yeah right
14:00:02 <dsturnbull> i'd argue that the standard is actually whatever GHC does
14:00:04 <Cale> SamB: fundeps aside ;)
14:00:17 <SamB> Cale: what about newtype deriving?
14:00:29 <Berengal> I think it's about time we got a new standard, just to get it up to spec
14:00:35 <Berengal> H98 is way outdated
14:00:39 <SamB> and a lot of those specs are for simplified versions ...
14:00:40 <Cale> Hmm, is that one really so complicated?
14:00:57 <Cale> Oh, I suppose the rules for when it's okay to derive instances are somewhat complicated.
14:01:08 <SamB> Cale: well, no. which is why it's currently a big flaming gap in type-safety...
14:01:13 <Cale> eh?
14:01:20 <monochrom> ?
14:01:30 <Cale> What do you mean by that?
14:01:39 <SamB> Cale: there's a ticket about it!
14:01:44 <Cale> Which one?
14:01:55 <pikhq> mauke: Actually, Perl doesn't parse Perl at all. It *executes* Perl, but does not determine its structure.
14:02:01 * Cale looks...
14:02:04 <pikhq> (since Perl is impossible to parse)
14:02:08 <mauke> pikhq: no, it isn't
14:02:15 <SamB> pikhq: it parses it
14:02:19 <mauke> it can't execute Perl without determining its structure
14:02:21 <SamB> it just doesn't do it as soon as you'd like
14:02:23 <pikhq> http://www.perlmonks.org/?node_id=663393
14:02:36 <SamB> because, of course, it can't
14:02:47 <mauke> pikhq: boring
14:02:48 <Berengal> SamB: It depends on what you mean by "parse"
14:03:26 <idnar> pikhq: it just parses it lazily
14:03:30 <monochrom> Larry used fusion laws to merge parsing and executing.
14:03:44 <idnar> pikhq: that should be old hat for Haskellers, surely? ;)
14:03:47 <Cale> SamB: oh, you're talking about the interaction with TypeFamilies?
14:04:00 <mauke> parts of the program are executed before other parts are parsed
14:04:04 <mauke> see also: lisp
14:04:05 <Cale> SamB: I don't know if I'd consider it a bug in newtype-deriving...
14:04:18 <SamB> Cale: well, it sure seems to be
14:04:19 <monochrom> See? Larry knew all our tricks. :)
14:04:21 <idnar> saying that it doesn't parse Perl is like saying that "fibs = 1 : 1 : zipWith (+) fibs (tail fibs)" doesn't calculate fibonacci numbers
14:04:33 <mauke> pikhq: by the same argument there are no lisp parsers
14:04:34 <SamB> they don't pay attention to the structure of the method types at all!
14:04:45 <mauke> because lisp can't be parsed
14:04:58 <SamB> Cale: http://hackage.haskell.org/trac/ghc/ticket/1496
14:05:06 <Cale> yeah, I'm looking at that
14:05:08 <pikhq> And indeed, there aren't. :P
14:05:20 <SamB> mauke: do you mean because of the reader macros?
14:05:25 <mauke> SamB: yeah
14:05:27 <SamB> or the plain-old macros?
14:05:27 <Berengal> You can put lisp code into a syntax tree though
14:05:34 <idnar> mauke: perhaps a better way to phrase that is: "there are no static lisp parsers"
14:05:35 <mauke> Berengal: not without running half of it
14:05:47 <Berengal> Module reader macros...
14:05:51 <Berengal> modulo*
14:05:59 <mauke> so there are no static perl parsers
14:06:07 <mauke> that doesn't mean perl can't be parsed
14:06:12 <SamB> can CL code add reader macros within the files to which they must apply?
14:06:33 <Cale> SamB: The bug appears to me to be in the type equality conditions for newtypes.
14:06:47 <SamB> Cale: it's in newtype deriving
14:06:48 <Cale> COMP seems to be wrong.
14:06:55 <SamB> COMP ?
14:07:01 <SamB> what the heck is that?
14:07:01 <Cale> yes, look at the ticket
14:07:14 <SamB> have they added to it lately???
14:07:15 <Cale> It derives Z Moo ~ Z Int
14:07:42 <Cale> If that is so, then there should have been an error for two of the same newtype instance being defined.
14:08:28 <Cale> The thing about using newtype deriving to generate a segfault is only possible because of that flaw in type equality checking.
14:08:54 <Cale> (at least, I think that's what it is)
14:09:08 <SamB> I still think newtype deriving should have to actually generate code before throwing it all away ...
14:09:58 <Cale> If this derivation is correct, the unsoundness of the type system due to ~ being wrong is a bigger deal, I think...
14:10:25 <Cale> It's not newtype deriving's fault -- it's newtype + TypeFamilies' fault
14:11:08 <SamB> Cale: would it have happened if newtype deriving was formally specified?
14:11:10 <ski> (Cale : which flaw ?)
14:11:15 <Cale> SamB: the same thing
14:11:25 <SamB> what same thing?
14:11:28 <Cale> SamB: because it's not newtype deriving's spec which is wrong
14:11:44 <SamB> Cale: I still think it might have helped if newtype deriving had had a spec!
14:11:53 <Cale> It's the interaction between newtype itself and the rules of FC(X)
14:12:02 <SamB> seriously?
14:12:03 <Cale> deriving has nothing to do with it
14:12:16 <SamB> hmm.
14:12:18 <SamB> oh, right.
14:12:21 <Cale> (except exhibiting the failure more spectacularly)
14:12:32 <SamB> FC(X) might be unsound either way ...
14:12:49 <ski> (are you discussing that ticket i see above ?)
14:12:54 <Cale> yes
14:13:06 <Cale> FC(X) is okay, but from what I understand it doesn't have any concept of newtypes(?)
14:13:20 <Cale> ah, it does
14:13:28 <Cale> but they're not like Haskell's newtypes
14:13:44 <acidjnk_> When I have: data Parser a = P { parse :: String -> Maybe (String, a) } value :: a -> Parser a value a = P (\s -> Just (s, a))  and then do: parse (value 7) "input" - what is happening there?
14:13:44 <ski> how ?
14:13:51 <Cale> they're type lambdas
14:13:56 <Cale> (in FC(X))
14:14:03 <SamB> most IRs don't have newtypes like Haskell's newtypes
14:14:06 <mauke> acidjnk_: which part is unclear?
14:14:18 <acidjnk_> The last, parse (value 7) "input"
14:14:40 <mauke> acidjnk_: value 7 = P (\s -> Just (s, 7))
14:14:43 <Cale> So, basically, they have too weak a notion of equality.
14:14:55 <Cale> (they're identified with the types that they newtype)
14:15:15 <Cale> and since that's the equality which ~ currently represents, it gets things horribly wrong
14:15:18 <mauke> acidjnk_: parse (P (\s -> Just (s, 7))) "input" = (\s -> Just (s, 7)) "input" = Just ("input", 7)
14:15:22 <SamB> Cale: well ... that wouldn't have to be an issue
14:15:45 <Cale> right, it's just a bug in how FC(X) is being reflected in GHC's implementation.
14:15:46 <SamB> the type system in the IR isn't necessarily supposed to prevent you from all possible harm
14:16:13 <acidjnk_> a is a type parameter. Why can it be 7 and not something like Int?
14:16:19 <SamB> it's just supposed to help catch where the compiler goes insane
14:16:20 <Cale> But yeah, it has nothing to do with newtype deriving being dangerous. The mistake was already made :)
14:16:36 <PeakerWork> why is newtype deriving a problem?
14:16:39 <mauke> acidjnk_: there are three 'a's there. which one do you mean?
14:17:04 <Cale> PeakerWork: Once this bug in type equality exhibits itself, newtype deriving can be used to generate a segfault.
14:17:06 <acidjnk_> Oh. Let me think about that for a while.
14:17:17 <SamB> Peaker: because GHC doesn't ensure that there's actually a way to write the code you'd have to write to derive the instances yourself
14:17:24 <Cale> It's really not that...
14:17:29 <mauke> acidjnk_: you might want to give them different names :-)
14:17:35 <SamB> Cale: oh, really?
14:17:37 * ski think of `newtypes' as morally being `type' synonyms, where the type is abstract because the synonym equality has been hidden
14:17:39 <PeakerWork> SamB: if there's an instance for the inner type, all instances of the newtype would just unpack/pack the newtype?
14:17:40 * Berengal wonders where Java is in the lambda cube
14:18:00 <Cale> It's that GHC thinks that Double is the same type as (Int, Int), under certain conditions.
14:18:22 <SamB> Cale: say ... WHAT???
14:18:36 <Cale> The bug in ~ makes the type system unsound.
14:18:38 <SamB> Cale: when does it think that?
14:19:02 <Berengal> newtype seems like a good and practical idea in theory, but they also complicate the theory in practice
14:19:16 <SamB> Cale: well, okay, maybe there are *two* bugs
14:19:26 <ski> ah .. i see
14:19:41 <Cale> SamB: Really there's only one. If the first bug wasn't there, then newtype deriving would be safe.
14:19:55 <ski> the problem is that the type function `Z' there isn't really a function
14:19:56 <SamB> Cale: um
14:20:01 <Cale> SamB: It thinks that because  newtype Moo = Moo Int, then  Moo ~ Int
14:20:13 <Cale> and since Z Int ~ Double, and Z Moo ~ (Int, Int)
14:20:23 <SamB> it's NOT considered good form for programs that typecheck at the Haskell level to give you IR type errors
14:20:37 <Cale> and because of some axioms which let you derive Z Int ~ Z Moo
14:20:47 <Cale> you end up with Double ~ (Int, Int)
14:21:09 <acidjnk_> That is a good question, got me. I'll stop for today. bye
14:21:10 <SamB> Cale: doesn't that only come into it after your code has already been typechecked?
14:21:14 <acidjnk_> thanks
14:21:25 <Cale> SamB: No, it's a typechecker bug.
14:21:29 <ski> `Z' should not be allowed to be defined differently for `Int' and `Moo', unless the system can prove `not (Int ~ Moo)' (which it can't, in this case)
14:21:55 <SamB> the way I see it, the typechecker doesn't know anything about FC(X), but still shouldn't let these cases through
14:21:57 <Cale> SamB: newtype is supposed to introduce a new, *distinct* type, and ~ doesn't see it as different, because someone got confused
14:22:20 <ski> it's like trying to define `f(1/2) = 3' and then also `f(3/6) = 5'
14:22:22 <acidjnk_> Hm, after "FC" this client shows a waving girl with black hair.
14:22:30 <acidjnk_> I really have to turn this stuff off.
14:22:33 <Cale> ski: right.
14:22:35 <idnar> acidjnk_: haha awesome
14:22:39 <SamB> (X) = waving girl?
14:22:40 <SamB> okay
14:22:44 <Cale> If ~ is going to consider Int and Moo to be the same type
14:22:59 <Cale> then it certainly should not allow two different type instance declarations for them
14:23:03 <SimonRC> acidjnk_: MSN messenger?
14:23:10 <SamB> I honestl cant see how a parenthesized capital X can be considered to mean that ...
14:23:13 <acidjnk_> Trillian
14:23:27 <acidjnk_> It's the only thing that can do with 8 MB RAM for 3 IRC connections, AIM plus ICQ.
14:23:28 <Cale> The other option, which is probably more sensible, is for ~ to consider Int and Moo as distinct, which solves the problem as well
14:23:40 <SamB> Cale: so ... this is a bug in a paper?
14:24:02 <Cale> SamB: A bug in the way in which a paper has been interpreted in GHC's implementation.
14:24:15 <Cale> SamB: Basically, the newtype in that paper is different from Haskell's newtype.
14:24:24 <SamB> sounds like a bug in the paper to me
14:24:28 <Cale> (but GHC is acting like it's the same newtype)
14:24:28 <ski> Cale : how about neither considering `Int',`Moo' equal nor distinct (unless more information is exported about them ..) ?
14:24:41 <SamB> considering what I believe the point of the paper was
14:25:12 <Cale> ski: well, that's also possible, though I think it should be possible to determine that Moo is not the same as Int from  newtype Moo = Moo Int
14:25:25 <Cale> SamB: That may be so :)
14:25:51 <SamB> Cale: still, I think that it shouldn't be a problem (for anyone but the compiler developers) if the Haskell typechecker typechecked Haskell properly ;-P
14:26:06 <Cale> That's the problem!
14:26:12 <ski> Cale : i was thinking the point of (in some contexts) having `Int ~ Moo' is that you could do O(0) conversions between them (especially nested)
14:26:18 <SamB> what does any of that have to do with FC(X)?
14:26:18 <Cale> ~ is part of the Haskell typesystem now
14:26:23 <SamB> ... oh.
14:26:31 <SamB> ah
14:26:33 <SamB> there we go
14:26:47 <Cale> (It's part of the TypeFamilies extension)
14:27:06 <SamB> so the FC(X) typesystem is now leaking up into the Haskell typesystem?
14:27:35 <Cale> ski: well, that's true, but it sort of goes against the whole spirit of newtype in Haskell...
14:27:42 <ski> so imo, the problem is how the type families apparently work, atm
14:27:49 <ski> Cale : how so ?
14:28:16 <Cale> ski: Well, we commonly newtype things to write separate instances for them
14:28:38 <ski> yes .. and i'm not sure that's really good practice
14:28:46 <ski> (though i don't have any better suggestion)
14:29:07 <Cale> The main reason that newtypes exist is 1) to ensure that things are not confused with the original type, and 2) to allow separate instances to be written without overhead.
14:29:23 <Cale> For ~ to resolve them as the same type goes against both.
14:29:40 <SamB> ski: the only other thing that comes to mind is to have to specifically pass our instance dictionaries around or risk the compiler picking them at random, like in Coq
14:30:10 <Cale> Basically, the way that ~ is treating newtype right now is how it ought to be treating 'type'
14:30:11 <ski> Cale : i only think it goes against 2)
14:30:20 <Cale> ski: It goes against 1 as well.
14:30:26 <ski> why ?
14:30:38 <Cale> ski: because it allows you to apply code which was meant for Int to Moo values.
14:30:55 <ski> not necessarily
14:30:57 <SamB> Cale: you've signed your soul over to haskell.org, yeah?
14:30:59 <Cale> (without mentioning the data constructor)
14:31:05 <Cale> SamB: eh?
14:31:09 <ski> only in contexts where `Int ~ Moo' is visible
14:31:30 <Cale> ski: You could have (t ~ Moo) somewhere and t ends up being Int
14:31:32 <SamB> er ... I mean, you've agreed to have all your haskell community participation licensed under a BSD2-style license?
14:31:47 <Cale> SamB: yes
14:32:15 <ski> Cale : i don't see a problem
14:32:15 <Cale> SamB: well, the simple permissive license
14:32:20 <SamB> Cale: good, because I'm quoting you in this ticket ;-P
14:32:28 <Cale> ski: It seems pretty serious to me.
14:32:33 <SamB> Cale: yeah, those are the words I was looking for
14:32:46 <Cale> ski: If I have a value of type Moo, then under no circumstances do I want it treated as an Int
14:32:47 <PeakerWork> Saizan: you here?
14:33:05 <Cale> ski: It's a value of a *new* type.
14:33:05 <PeakerWork> we cleaned up the generators code some more...   http://github.com/yairchu/generator/blob/3e5d761468a106ff71992c16252ec538efaf7242/testProducers.hs  <-- Some examples
14:33:17 <ski> Cale : imo, the 1) point is about making sure `Moo' and `Int' are not confused, *expect* in contexts where `Moo ~ Int' is known
14:33:18 <PeakerWork> That is an alternative to Iteratee/lazy I/O   that we think is nicer than either of these
14:33:51 <ski> Cale : this is how abstract type synonyms in ML, and how restricted type synonyms in Hugs work
14:33:55 <Cale> ski: But at present, it's known because the newtype declaration is in scope.
14:34:04 <Cale> ski: Isn't that a problem?
14:34:12 <ski> yes, if that is the case
14:34:16 <Cale> newtype declarations should enforce type inequality!
14:34:24 * ski doesn't know the details of how `~' is handled
14:34:25 <SamB> ChilliX is Manuel, right?
14:35:07 <Cale> ski: Well, my definition of Moo is the one from the ticket, if that wasn't clear :)
14:35:19 <ski> (yes, that was clear)
14:35:53 <ski> my (limited) understanding of `~' is that it would bring a similar expressivity as abstract type synonym and restricted type synonyms
14:36:21 <ski> i.e. if and only if you have `Moo ~ Int' in scope, would the type system be able to replace one with the other
14:36:24 <Cale> ~ is supposed to be type equality
14:36:34 <ski> otherwise it would be forced to assume they *might* be different
14:36:40 <ski> (yes)
14:36:46 <Cale> A context with (Moo ~ Int) should render the value unusable.
14:36:53 <ski> and usually, `Moo ~ Int' would *not* be in scope
14:36:54 <Cale> (because that condition should be outright false)
14:37:07 <SamB> so why don't they call it ≡_\hbox{type} or whatever?
14:37:10 <Cale> In fact, probably a good idea just to make it a type error.
14:37:29 <Cale> SamB: because that's not a character on your keyboard
14:37:44 <SamB> Cale: \equiv isn't that hard to type
14:37:52 <Cale> It looks like hell though ;)
14:37:57 <ski> but there would be some mechanism of *explicitly* bringing `Moo ~ Int' into scope, when needed
14:38:04 <SamB> Cale: and ?
14:38:21 <SamB> they could use a decent IM
14:38:25 <Cale> SamB: ~ is easy to type (for most people), and you can learn that it means type equality?
14:38:42 <Cale> Though, I wonder why they couldn't just have used =
14:38:45 <ski> (and it should be possible for the definer of `Moo' not to export that mechanism from the module, and thereby preventing any other part of the program from using `Moo ~ Int' on its own accord)
14:38:45 <SamB> well apparantly they get a bit handwavy with such a weak-looking symbol
14:39:05 <ski> (Cale : agreed, `=' would look nicer)
14:39:07 <SamB> Cale: because = is what they use in their function definitions
14:39:13 <Cale> SamB: eh?
14:39:26 <Cale> SamB: but it doesn't appear in the same syntactic context does it?
14:39:38 <SamB> now you sound like a Perl programmer or something
14:39:40 <Cale> It'll always appear inside a class context, on the right hand of a ::
14:39:51 <Cale> It's not a value
14:40:08 <SamB> Cale: oh, I meant the functions that might operate on abstract syntax trees containing it
14:41:03 <Cale> oh
14:41:19 <Cale> well, presumably by the time it gets that far, it'll look different :)
14:41:31 <ski> Cale : see : 7.3.5 Restricted type synonyms <http://cvs.haskell.org/Hugs/pages/hugsman/exts.html#sect7.3.5> for a better explanation of what restricted type synonyms do
14:41:31 <Cale> I'm just talking about the concrete syntax :)
14:41:40 <SamB> concrete syntax?
14:41:46 <SamB> they don't use those in papers, usually
14:41:51 <SamB> ;-P
14:42:08 <Cale> ski: While I agree that maybe we should have that, it should not use the keyword newtype
14:42:15 <Cale> ski: 'type' would be fine.
14:42:39 <SamB> oh, and remember that I've worked on JHC/LHC, so I'm used to compilers spitting out core full of unicode ;-)
14:43:22 <Cale> SamB: oh, I also wasn't talking about the paper
14:43:27 <Cale> I was talking about Haskell syntax.
14:43:32 <Cale> I don't know what they used in the paper.
14:43:35 <SamB> oh
14:43:43 <SamB> they use that in the Haskell type ?
14:43:48 <ski> (imo `newtype' is semantically the same as a `restricted type synonym', where the only operations that are allowed to access the internal equality is the constructor (and possible selector) (both being O(0) operations))
14:43:51 <SamB> the one they actually use in GHC?
14:44:09 <Cale> ski: hmm, adopting hugs' syntax, perhaps you're right
14:44:10 <SamB> ski: O(0)?
14:44:18 <SamB> what the?
14:44:26 <Cale> ski: er, hmm
14:44:33 <SamB> hmm.
14:44:36 <ski> Moo _|_ = _|_
14:44:39 <SamB> I guess that means something
14:44:39 <Cale> ski: actually I still like type there, because of the way it reads with 'in'
14:44:54 <monochrom> O(0) means 0 Overhead.
14:44:56 <Cale> ski: it's a type synonym in those functions, and a newtype elsewhere
14:45:16 <SamB> I just don't think I've ever seen it mentioned before
14:45:29 <SamB> or thought about the possibility of O(0)
14:45:31 <ski> Cale : it's a type synonym in those functions, and an (abstract) type, elsewhere :)
14:45:42 <Cale> ski: right
14:46:03 <ski> the abstractness is just that the type equality is not available
14:46:03 <monochrom> Just think of O(f(n)). Then let f(n)=0.
14:47:52 <ski> SamB : consider using such a restricted type synonym to implement an operation `foo :: (Stack a -> Tree (Stack a)) -> ([a] -> Tree [a]); foo = id'
14:47:53 <PeakerWork> 0 code takes O(0) to run :)
14:48:08 <ski> (just as a random example)
14:48:15 <monochrom> :)
14:48:29 <monochrom> Indeed newtype adds 0 code and 0 memory requirement.
14:48:37 <ski> (that's what i mean by this allowing "nested" conversions in O(0))
14:48:39 <monochrom> (of its own)
14:49:06 <SamB> I guess f(n) = O(0) just means that ∃b. lim_{m,n→∞} m*f(n) < b
14:50:07 <SamB> ... but does that mean that it still has no overhead ever, or just that the overhead is negligible in the long run?
14:51:14 <ski> (SamB : quite possibly the term `O(0)' is, strictly speaking, improper .. i'm not sure of a better term, though)
14:51:37 <SamB> ski: I think it's fine by Knuth's definition
14:51:44 <monochrom> "free as in beer"
14:51:53 <SamB> which is presumably more-or-less the same as everyone else's
14:52:08 <SamB> perhaps some of them are less-defined than others
14:52:08 <monochrom> "newtype is free (as in beer, not as in algebra)"  XD
14:52:09 <PeakerWork> Anyone interested in a Python-generator-like alternative to Iteratee? I wanna get some feedback on the example page: http://github.com/yairchu/generator/blob/352b308695c49c175a7014f12b27251eb14d74cb/testProducers.hs
14:52:32 <SamB> PeakerWork: as long as that doesn't mean all my code has to be in IO
14:53:00 <PeakerWork> SamB: Producer Identity a      is basically equivalent to a pure list
14:53:11 <PeakerWork> SamB: Producer IO a  is a list that requires IO actions to consume
14:53:50 <Cale> SamB: Well, it means that for sufficiently large n, f(n) is less than or equal to (some constant multiple of) 0.
14:53:55 <PeakerWork> SamB: ConsumerT a Identity b   is a pure consumer of a producer of a's that generates a b
14:54:18 <PeakerWork> SamB: ConsumerT a IO b   is a consumer that's allowed to do IO between consumptions of "a"
14:54:23 <Cale> Given that f(n) is positive for all n, that means that f(n) being in O(0) gives us that for all sufficiently large n, f(n) = 0.
14:54:33 * ski would have used a new datatype, instead of a `Maybe' ..
14:54:38 <PeakerWork> SamB: A consumer must have the same monad type in order to consume from a producer, and then their actions are interlaced
14:54:40 <Cale> er, non-negative, I should say
14:54:45 <PeakerWork> ski: where?
14:55:14 <SamB> hmm, you know what's kind of lame about github?
14:55:20 <PeakerWork> SamB: what?
14:55:28 <SamB> ... you have to use the web interface to create a repository before you can push to it
14:55:53 <PeakerWork> SamB: there's also a convenience ProducerT which is basically a continuation-based wrapper monad around Producer, so you can use:  blah = produce $ do { yield 1 ; execute actions ; yield 2 ; ... }  -- e.g Python generators
14:56:16 <PeakerWork> SamB: Yeah, web interfaces should have a programmatic alternative
14:56:31 <PeakerWork> but that's a problem in general with the web, and not with github in particular
14:56:49 <ski>   newtype List  link a = MkL {unL :: link (ListCell link a)}
14:56:58 <SamB> I like how with launchpad, I can just bzr push to a branch who's name I just made up, as long as I use the name of an existing project as the middle component ...
14:57:00 <ski>   data ListCell link a = Nil
14:57:06 <ski>                        | Cons a (List link a)
14:57:18 <PeakerWork> SamB: I used to like bzr. git is much better...
14:57:21 <SamB> (and ~myusername as the first component)
14:57:23 <PeakerWork> SamB: have you switched to git?
14:57:33 <ski> PeakerWork : `List link a' corresponds to your `Producer a link'
14:57:33 <SamB> I use them both
14:58:06 <SamB> the time may come when I use them both at the same time
14:58:07 <ski> (PeakerWork : this is a just style question, though)
14:58:22 <PeakerWork> ski: Oh, that Maybe.  Yeah, I had explicit constructors
14:58:29 <PeakerWork> ski: then yairchu reimplemented my thing with Maybe
14:58:34 <PeakerWork> ski: we should change that - its not exposed anyway
14:58:51 <PeakerWork> ski: The idea is that you cannot de-compose a Producer into the underlying actions, so that you cannot accidentally re-run the same action twice, etc
14:59:06 <ski> i see
14:59:10 <SamB> I may eventually be able to use them together to access SVN repositories losslessly from git
15:00:06 <PeakerWork> ski: only a ConsumerT can decompose it, and then it runs the "whole thing" until the consumer terminates
15:00:25 <PeakerWork> (and ConsumerT is basically a StateT on the Producer/list so it cannot re-use the same one twice
15:00:31 <PeakerWork> )
15:00:44 <ski> (PeakerWork : btw, that `List' and `ListCell' type is generally useful (i'ved used it for lists linked with logic variables) ..)
15:02:24 <ski> (with `link' being any one of `Identity',`Maybe',`LogVar ref', `ref' being for the moment `IORef' or `STRef s')
15:02:32 <SamB> Peaker: one thing I don't like about git is that you can't send your commits themselves in emails like you can with bzr
15:03:13 <SamB> well, I mean, it's physically possible, but there is no tool support for it
15:03:20 <PeakerWork> SamB: I haven't tried it, but doesn't git bundle/et al do that?
15:03:41 <PeakerWork> SamB: you build a "git push" of the commits you want and send that?
15:03:44 <SamB> oh, well, if you want to send a tarball
15:04:42 <SamB> but "bzr send" works a bit more nicely and includes a summary diff, *which it checks for accuracy*
15:05:11 <PeakerWork> What's wrong with a tarball?
15:05:13 <yairchu> PeakerWork: implementing Maybe equivalents loses all the ready made utilities for Maybe
15:05:36 <SamB> PeakerWork: well, it's a bit clunkier than just including a short stream of gibberish in the email body
15:06:09 <SamB> especially if that stream is prefaced with a diff that will be checked for accuracy when applying
15:06:18 <ski> yairchu : true .. are you using those anywhere ?
15:06:34 <PeakerWork> yairchu: data [] a = Maybe (a, [a]) ?
15:06:42 <yairchu> ski: I use MaybeT
15:07:14 <PeakerWork> data Tree a = Either (a, (Tree a), (Tree a)) (Node a) ?
15:07:24 <yairchu> PeakerWork: how about newtype [] a = [] (Maybe (a, [a]))
15:07:50 <ski> yairchu : in  ConsumerT'  ?
15:07:52 <PeakerWork> yairchu: yeah, I forgot the [] on the RHS, and when using maybe/either you can use newtype everywhere.. but that's harder to use...
15:08:09 <yairchu> ski: in implementation of "next"
15:08:18 <PeakerWork> yairchu: code that uses:  f [] = 0 ; f (x:xs) = x+f xs       is a bit nicer than:   f Nothing = 0 ; f (x, xs) = x+f xs
15:08:31 <ski>   next :: Monad m => ConsumerT v m (Maybe v)
15:08:33 <SamB> PeakerWork: the other thing I don't like is git-svn's antisocial attitude
15:08:48 <PeakerWork> SamB: I haven't used git-svn.. who still uses svn? :-)
15:08:52 <yairchu> PeakerWork: that's just syntax you are talking about.
15:09:08 <SamB> PeakerWork: well, what if you want to contribute to a project that does?
15:09:16 <PeakerWork> yairchu: Yeah, ADT's in Haskell can be seen as syntactic sugar for type sums (Either) and products (,)
15:09:36 <PeakerWork> SamB: and you want to have private git branches at home?
15:10:30 <SamB> Peaker: well, that's all git-svn offers, unfortunately :-(
15:10:35 <SamB> that's my complaint
15:11:20 <SamB> the manual basically says not to share your git-svn branches at all
15:14:02 <PeakerWork> yairchu: but still important sugar, as combining Eithers/Maybes is more confusing/less informative than having explicit constructor names.. You can also write de-constructors to Maybe/Either and then get the maybe/either functions
15:14:03 <SamB> Peaker: mostly because committing to svn through git-svn and re-cloning the SVN repo will give you a different commit from the one you committed
15:14:37 <PeakerWork> SamB: how would branch sharing works? svn doesn't even have a "standard way" of branching, afaik?
15:14:57 <SamB> Peaker: yeah, that *can* be an issue
15:15:12 <SamB> but one that I've almost only ever seen with the PuTTY repository
15:15:24 <kynky> thought the prob with svn was with the merging, not branching, and git was built for merging afaik
15:15:26 <SamB> most of them use one of a few simple layouts
15:15:59 <SamB> kynky: well, there is, actually, the issue of SVN giving you just a big tree and not governing how you use it to represent branches and tags
15:17:42 <SamB> PeakerWork: well, both git-svn and bzr-svn are fairly simple to use to import branches and tags from SVN, though bzr-svn's way is a bit more automatic in the usual case ...
15:18:23 <PeakerWork> svn UI is annoying because you have to use it from the top project dir
15:18:41 <PeakerWork> also because it doesn't have a concept of a branch, all subdirs are equal
15:19:54 <SamB> PeakerWork: however, if you do two bzr-svn imports of the same repository, you will get the same branches (assuming that they both used the same branch layout, anyway, but it seems like 99% of repositories use the same layout anyway)
15:21:00 <SamB> and if you do some bzr commits and then push them back to SVN, then do a pull from SVN in another bzr copy of the same branch, you will *still* get the same commits back
15:21:32 <SamB> even if you did bzr merges!
15:22:40 <SamB> though I do wish they had a decent bzrk, which could show you all the branches in a shared repository at once ...
15:24:50 <PeakerWork> SamB: bzr doesn't have a concept of a repository, which really limits the kind of UI things you can do
15:24:59 <PeakerWork> a UI concept of a repository, that is
15:25:09 <PeakerWork> the repository is only exposed in "bzr init-repo"
15:25:40 <PeakerWork> in git its really nice that you can treat any branch/tag as a "ref", and you have all of the "last-known remote refs" too..
15:25:57 <SamB> PeakerWork: yeah ...
15:26:38 <PeakerWork> git reset --hard to move branch refs anywhere you want is really lacking in bzr, as well as sharing the directory (though maybe "bzr switch" could do that, its not the main idiom)
15:27:16 <SamB> well, yeah, bzr switch isn't too bad
15:27:56 <SamB> but what I've really been missing is an equivalent for "git checkout -b newbranch"
15:28:52 <SamB> on the other hand, being able to start an SVN branch before you have SVN write access is really quite cool ;-)
15:30:34 <PeakerWork> SamB: its quite uncool that svn is still stuck in the middle ages.. :-Z
15:31:42 <SamB> Peaker: well, a lot of projects that use SVN might otherwise not have used any version control
15:31:53 <SamB> so it's really not that negative of a thing
15:32:32 <SamB> and did you know that GDB is still stuck in CVS?
15:32:34 <copumpkin> it's just not as positive as it could be :P
15:32:37 <PeakerWork> Is "svn" really easier than "bzr"?
15:32:49 <SamB> I will refuse commit access if they offer it to me, I think
15:32:56 <PeakerWork> I think if someone wrote a nice UI for "git" it could truncate its learning curve from about a month to a couple of days
15:33:13 <PeakerWork> why are they "stuck"? There are history convertors
15:33:24 <SamB> that's not the issue
15:33:25 <PeakerWork> also, history is usually not that important to be able to look up except for merges
15:33:32 <SamB> I'll find you the thread
15:34:18 <SamB> I recently asked what is keeping them from switching to some DVC or other
15:36:19 <PeakerWork> it can't be anything reasonable
15:36:30 <SamB> actually, it is rather
15:36:53 <SamB> it's not that they wouldn't like to ...
15:40:02 <SamB> hmm, the message-id of the first message in the thread is <87r5xgqk0k.wl%naesten@gmail.com>
15:43:59 <SamB> PeakerWork: http://www.nabble.com/What-is-keeping-GDB-in-CVS---td24114594.html
15:44:08 <PeakerWork> @type withForeignPtr
15:44:09 <lambdabot> Not in scope: `withForeignPtr'
15:44:15 <PeakerWork> @hoogle withForeignPtr
15:44:15 <lambdabot> Foreign.ForeignPtr withForeignPtr :: ForeignPtr a -> (Ptr a -> IO b) -> IO b
15:44:22 <PeakerWork> @type Foreign.ForeignPtr.withForeignPtr
15:44:24 <lambdabot> forall a b. GHC.ForeignPtr.ForeignPtr a -> (GHC.Ptr.Ptr a -> IO b) -> IO b
15:44:31 <PeakerWork> @let result = (.) ; arg = flip (.)
15:44:32 <lambdabot>  Defined.
15:44:50 <Nafai> PeakerWork: I don't think the "UI" for git is necessarily hard, it is just that it is different from CVS/SVN and not what people are used to.  Once you get used to the core git concepts (index, blob, tree, commit, etc), most of git usage is straight-forward to me
15:45:10 <SubStack> I remember installing some module that improves upon conditionals but can't remember the name of it
15:45:15 <SubStack> something like AndOr
15:45:17 <PeakerWork> @type (result . result) liftIO . (result . arg . result) liftIO $ Foreign.ForeignPtr.withForeignPtr
15:45:18 <lambdabot> forall (m :: * -> *) a a1. (MonadIO m) => GHC.ForeignPtr.ForeignPtr a1 -> (GHC.Ptr.Ptr a1 -> IO a) -> m a
15:45:32 <SamB> Nafai: hmm, I think it might help that you don't have to be a computer scientist to understand most of what SVN stores
15:45:56 <PeakerWork> Nafai: I think that the git staging area is for example a completely unnecessary device that only hinders the learning curve..  It can be useful as a plugin for people who don't like typing in filenames at "commit".
15:46:05 <PeakerWork> Nafai: then, server errors really suck too
15:46:18 <Nafai> PeakerWork: I guess, I like the staging area now that I'm used to it
15:46:28 <PeakerWork> @type (result . arg . result) liftIO $ Foreign.ForeignPtr.withForeignPtr
15:46:30 <lambdabot> forall a a1. GHC.ForeignPtr.ForeignPtr a1 -> (GHC.Ptr.Ptr a1 -> IO a) -> IO a
15:46:50 <SamB> the staging area can be nice when I'm using git on locally
15:46:53 <PeakerWork> Nafai: but its an extra obstacle to using git when you're a newbie.. that's hard for a not-so-good reason
15:47:17 <PeakerWork> Nafai: there's also the weirdness of "git checkout" and "git reset" commands in their duality of behavior (branch commands VS file commands)
15:47:21 <SamB> but it's a bit tiresome when I'm using it on a machine I'm accessing over SSH with -X not allowed by the ssh server
15:47:36 <NEEDMOAR> If you were writing a lexer using ParsecToken, but the target language had two different symbols for doing one line comments, what would you do? Since commentLine works just for one kind comment, apprently.
15:47:42 <PeakerWork> Nafai: also, "git reset --hard" and "git checkout <files>" should really not be irreversible
15:47:55 <PeakerWork> Nafai: a bunch of UI obstacles for newbies that "bzr" for example doesn't have
15:48:04 <PeakerWork> Nafai: so its not just "different" it also has extra unnecessary obstacles for users
15:48:33 <SamB> Peaker: and can you believe how long it took me to figure out how to follow rebased remotes when I don't have any local commits to rebase onto the new remote heads?
15:48:42 <Nafai> I suppose
15:49:08 <SamB> the bzr equivalent is way easier-to-find
15:49:17 <Nafai> So far of the DVCS's, git has been the only one that has made sense to me
15:49:21 <SamB> and it's harder to merge by mistake
15:49:37 <SamB> the model makes sense to me as well
15:49:47 <Nafai> For some reason, bzr is just not attractive to me at all
15:49:48 <SamB> it's the commands that drive me bonkers
15:49:52 <PeakerWork> SamB: "or come up with a clever way to fake CVS-style modules" <-- have they not heard of "git submodules"?
15:50:07 <SamB> PeakerWork: have *you* not heard of them?
15:50:08 <PeakerWork> Nafai: it was attractive to me when I was a Python fan
15:50:20 <PeakerWork> Nafai: because it has a nice Python API I can control
15:50:46 <Nafai> Admittedly, that is attractive about bzr and hg, considering also that there isn't an established libgit in use
15:50:50 <SamB> Peaker: what I've heard did not sound like a recommendation!
15:50:57 <PeakerWork> SamB: the bzr equivalent of rebase?
15:51:11 <Nafai> The bzr people don't like the idea of rebase
15:51:14 <PeakerWork> SamB: bzr doesn't have one.. but "git rebase" that is used on public branches is really a problem.. git could support that but doesn't
15:52:13 <SamB> PeakerWork: no, the bzr thing you do instead of 'git reset x86/foobranch' when x86/foobranch got rebased after Linus tagged a new rc kernel
15:52:20 <SimonRC> -!- SimonRC [n=sc@fof.durge.org] is away ["bed, etc"]
15:52:27 <SamB> er. 'git reset --merge x86/foobranch'
15:52:48 <PeakerWork> SamB: doesn't sound like they have good reasons to keep it in CVS. just lazy cowards :-)
15:52:57 <SamB> PeakerWork: or, say, when you want to discard some local changes and just pull from upstream
15:53:22 <SamB> PeakerWork: have you *used* submodules?
15:53:25 * roconnor <3 imagPart (log v2 - log v1)
15:53:29 <SamB> or read all the little caveats about 'em?
15:53:56 <Nafai> submodules don't quite work the way one would expect
15:54:10 <Nafai> At least if you expect them to be anything similar to svn:external
15:54:25 <SamB> I haven't used them myself, but the caveats looked really scary
15:54:37 <PeakerWork> SamB: I use them all the time, yeah
15:54:41 <SamB> especially when you'd be doing the majority of your development inside those submodules
15:54:43 <PeakerWork> SamB: They're nice
15:54:52 <SamB> PeakerWork: do you share them?
15:54:55 <PeakerWork> SamB: Yeah
15:55:06 <PeakerWork> SamB: they aren't perfect, but still nice :)
15:55:20 <Nafai> Have you guys looked at the new git subtree stuff?  I don't know much about it
15:55:34 <SamB> there were all kinds of scary warnings about making sure you have that revision in the repository that the submodules refer to before you push a commit that updates a submodule
15:55:51 <PeakerWork> Nafai: is that like submodules?
15:56:11 <PeakerWork> SamB: well, if you forget, you can just re-commit, why scary?
15:56:29 <PeakerWork> SamB: you do have to remember to commit sub-module, and then re-commit parent module
15:56:43 <Nafai> PeakerWork: Yeah, look here: http://github.com/apenwarr/git-subtree/blob/c8a98d4f8730d85a6f693d5dbcd4c1309d97f7c8/git-subtree.txt
15:57:04 <SamB> PeakerWork: that also seems like it would be a major pain if you didn't actually have commit access to the repositories referred to by the submodules
15:58:11 <idnar> SamB: isn't that bzr pull --overwrite?
15:58:23 <SamB> idnar: yeah! way more intuitive than in git, see?
15:58:38 <PeakerWork> SamB: "commit access"?
15:58:40 <idnar> SamB: they both make absolutely no sense
15:58:55 <SamB> idnar: hmm
15:59:05 <SamB> I don't see how
15:59:20 <SamB> PeakerWork: write access, whatever
15:59:22 <idnar> SamB: bzr pull --overwrite isn't a "pull" at all
15:59:30 <PeakerWork> SamB: its DVCS, how can you not have access?
15:59:50 <PeakerWork> SamB: if you don't have access, then conceptually you have a problem to change the pointer to the submodule, which is a valid way to look at it
15:59:57 <SamB> PeakerWork: don't these submodule repositories get referrerd to by absolute URL?
16:00:01 <idnar> SamB: and don't even get me started on "reset"
16:00:06 <PeakerWork> I think bzr UI names of stuff are nicer/simpler and more to the point than git. And it also doesn't have silly unnecessary mechanisms like the "staging area"
16:00:17 <PeakerWork> The "staging area" complicates git in various ways for so little benefit
16:00:20 <idnar> PeakerWork: are you referring to "git add"?
16:00:38 <PeakerWork> idnar: that adds to the staging area ya
16:00:44 <SamB> git has about 100x as much rope as you need to hang yourself
16:00:56 <idnar> PeakerWork: but, see, everything else has that too; except they only have it for file adds and removes :P
16:02:02 * sm pulls a darcs patch and wonders what those people are talking about
16:02:20 <PeakerWork> idnar: yeah, need to think about that :-)
16:02:23 <SamB> sm: how much git and bzr both suck
16:02:35 <kynky> lots of things moving to git
16:02:53 <idnar> PeakerWork: and don't get me wrong, I think git is freaking terrible
16:03:08 <PeakerWork> idnar: why is it terrible? I think git is great :-)
16:03:09 <idnar> PeakerWork: but that doesn't mean everything else is totally awesome :P
16:03:15 <idnar> I think the main issue I have with git is that practically every time I see a git command line, it's using some git command I've never heard of
16:03:19 <PeakerWork> idnar: I just dislike the staging area and much of git's UI
16:03:23 <idnar> that's way too many commands :P
16:03:31 <SamB> I like git's model, mostly, and I like the view gitk affords of a repository
16:03:42 <kynky> the ui to git, is a seperate thing to git
16:03:43 <PeakerWork> idnar: The UI sucks indeed, but its really much simpler than I thought it was - I got the same complexity impression from the commands initially
16:03:43 <Nafai> I *like* the staging area and things like git add -p
16:03:46 <idnar> also, the learning curve for git is too high
16:03:48 <SamB> and a few of the commands are convenient ...
16:03:50 <kynky> stacks
16:03:51 <mike-burns> PeakerWork: You can use 'git commit -a' to ignore the staging area.
16:03:56 <SamB> but there is way too much crazy shit
16:03:58 <impl> how about hg?
16:04:15 <PeakerWork> idnar: The learning curve is also because of the bad UI. But the underlying model of git is *great*. much nicer than bzr's/etc. And I really liked bzr's before I knew git
16:04:27 <Cale> I think darcs has about as close to the perfect UI for a version control system as you can get.
16:04:30 <idnar> PeakerWork: if we're talking about underlying model, everything besides darcs is broken :P
16:04:31 <SamB> Peaker: bzr could have a nice model
16:04:43 <SamB> Peaker: but I wouldn't know, because they won't tell me what it is
16:04:49 <PeakerWork> mike-burns: I can't ignore it completely when I want to script git. e.g: I want to write a "make sure git status shows clean slate so I can remember the revno to uniquely identify the working tree exactly, for build/testing purposes"
16:04:52 <Raynes> I learned to use Git in like a day. >_> But Darcs is much easier, I was using it in 20 minutes.
16:04:58 <SamB> I put up a launchpad answers question and everything!
16:05:00 <idnar> PeakerWork: launchpad is a pretty powerful weapon on the bzr side, though
16:05:11 <PeakerWork> idnar: I disagree, git is more correct than darcs IMO.
16:05:21 <PeakerWork> idnar: github >> launchpad
16:05:24 <idnar> PeakerWork: well, when I say "broken", what I actually mean is "doesn't do what I want"
16:05:32 <PeakerWork> idnar: launchpad was/is a pain, github is a joy
16:05:41 <idnar> PeakerWork: github's UI is like git's
16:05:47 <SamB> PeakerWork: does git have "darcs add" yet?
16:05:52 <Nafai> idnar: But git has an underlying model that mere humans can understand
16:05:52 <idnar> PeakerWork: which isn't surprising, but isn't exactly an enticement either
16:06:02 <Cale> Darcs doesn't really require effort to learn. You type darcs, and it tells you the list of mostly obvious commands, and then you use them.
16:06:04 <Nafai> SamB: What does darcs add do?
16:06:04 <idnar> Nafai: I guess I'm inhuman, then
16:06:05 <PeakerWork> idnar: github's UI is really simple
16:06:09 <SamB> PeakerWork: launchpad is great
16:06:16 <idnar> Nafai: you don't have to understand the underlying model to use the tool
16:06:20 <SamB> you only need to use the web UI to delete branches
16:06:25 <PeakerWork> SamB: I remember spending 20 minutes(!!) browsing through launchpad's hundreds of links to find the "new project" link
16:06:28 <Cale> Nafai: It adds the file to version control.
16:06:33 <Nafai> SamB: Eh, launchpad is highly disorganized
16:06:36 <SamB> Nafai: er, I mean "darcs record"
16:06:41 <inimino> SamB: do you know the history of bzr?
16:06:44 <PeakerWork> SamB: With github I was up and running in 3 minutes. It has about 20-30 links altogether
16:06:55 <idnar> SamB: are you talking about interactive cherrypicking?
16:06:56 <SamB> inimino: some kind of bloody war with the arch nutcases?
16:07:16 <PeakerWork> SamB: worse yet, when I wanted another project in launchpad, it took me tons of time to re-find that link. It was just not organized in a memorable fashion.  Maybe it improved, but it sucked
16:07:22 <idnar> PeakerWork: surprise! it's on the front page
16:07:27 <SamB> PeakerWork: no, no, you don't want to use the web UI
16:07:32 <PeakerWork> SamB: also, the lack of shared-repo support in launchpad meant that for every branch - I had to upload my entire history!
16:07:41 <inimino> SamB: with Tom Lord, I take no position on who is or isn't a nutcase
16:07:43 <idnar> PeakerWork: you can do stacking on launchpad now
16:08:09 <inimino> SamB: anyway, if you want to know the theory or model behind it, you probably want to go look at the arch stuff
16:08:09 <SamB> I wish launchpad could stack you on something closish to what you push from automatically
16:08:12 <idnar> anyway, launchpad is also not that great, but the integration is really alluring for me
16:08:18 <SamB> inimino: no way
16:08:28 <SamB> the model is totally unrecognizable
16:08:35 <idnar> inimino: bzr shares no ancestry with arch
16:08:41 <PeakerWork> idnar: it looks much better now, but github.com is still a much nicer / more minimalist design
16:08:44 <idnar> inimino: as far as I can tell
16:08:53 <idnar> PeakerWork: github doesn't have the functionality, afaict
16:08:58 <inimino> idnar: that's news to me
16:08:58 <SamB> idnar: well, they were trying to reimplement it in baz
16:09:00 <PeakerWork> idnar: what functionality is it missing?
16:09:17 <idnar> PeakerWork: but I guess maybe I just can't tell, it's not like I'm ever going to take the time to learn enough git to know for sure :P
16:09:43 <inimino> anyway, I just use git
16:09:48 <SamB> personally, I use repo.or.cz more than I use github
16:09:52 <PeakerWork> idnar: if you want, I can explain git to you in 20 minutes..
16:10:00 <Nafai> For now, for me, git is my vcs of choice
16:10:05 <PeakerWork> idnar: I think various tutorials/etc just don't explain it well. Maybe I ought to write one
16:10:16 <SamB> PeakerWork: 20 minutes will get you over the repository model, sure
16:10:18 <idnar> PeakerWork: I doubt that'll help
16:10:25 <SamB> but the actual usage will take more like 20 hours
16:10:31 <Nafai> Unfortunately, I need to still have svn, cvs, hg, darcs, bzr to track random projects
16:10:42 <idnar> PeakerWork: the problem is the UI, not my comprehension
16:10:55 <dsturnbull> you can track projects with cvs? :p
16:11:11 <Nafai> PeakerWork: John Wiegley's tutorial is fairly good, but some of it is low level.  It is what helped things click for me.
16:11:14 <idnar> PeakerWork: it doesn't help that git users seem to be really bad at explaining stuff, though
16:11:15 <Nafai> dsturnbull: :P :)
16:11:18 <PeakerWork> SamB: For example, I think you could explain that     HEAD :: IORef (IORef Revision)  :-)   git reset   is    modify . modify       and git checkout is modify
16:11:40 <idnar> PeakerWork: the last time somebody wanted me to look at their git project, it took them 30 minutes to explain to me how to get a copy of the source code onto my local machine
16:11:53 <PeakerWork> Nafai: HEAD is a double-ptr. checkout moves the double ptr,  reset dereferences one pointer and moves the inner ptr.  That could help click things for me and I found this explanation nowhere :)
16:11:55 <SamB> PeakerWork: but you forgot what they do to the index
16:12:00 <Nafai> idnar: Uh.... git clone foo?
16:12:07 <idnar> PeakerWork: so I wouldn't be surprised if none of the existing tutorials are any good :P (I don't read tutorials much)
16:12:07 <dsturnbull> that person fails at typing "git clone git://github.com/username/project.git" to you
16:12:11 <PeakerWork> SamB: Which is why I'd rather ignore the staging area/index
16:12:12 <idnar> Nafai: that's what he started with
16:12:18 <idnar> Nafai: it gave me some error
16:12:22 <SamB> idnar: what the HECK?
16:12:23 <PeakerWork> its an unnecessary complication
16:12:37 <SamB> idnar: ... you weren't trying to check out *dulwich*, were you?
16:12:41 <dsturnbull> maybe unnecessary for your purposes, i use the index all the time
16:12:41 <idnar> then he gave me a different URL, which worked, except I just got a .git directory with no working tree, or something
16:12:43 <Nafai> PeakerWork: Makes sense :)
16:12:48 <idnar> I don't remember what happened after that :P
16:13:16 <idnar> I think there was some issue of version incompatibility along the way
16:13:18 <SamB> idnar: oh, he probably didn't know how to use git himself
16:13:43 <idnar> but of course, git's lovely UI doesn't tell you anything
16:13:45 <PeakerWork> idnar: git has a repo, it contains a history graph and a bunch of pointers to that graph, and the HEAD double-ptr.   Then you understand commit, reset, checkout, fetch, merge, push -- and I think you understand git, the rest is peanuts
16:14:11 <PeakerWork> idnar: You really really ought to learn git.  Its an invaluable tool with great speed and more power than the other DVCS's
16:14:21 <SamB> one thing I love about bzr is that I can usually blame the errors I get when using it on the programmers ;-)
16:14:26 <idnar> you go "git clone git://lulz.com/does/not/work" and it doesn't say "could not find lulz.com", it'll say something like "no heads in local repository!"
16:14:53 <PeakerWork> lulz.com[0: 75.126.236.132]: errno=Connection refused
16:15:16 <idnar> PeakerWork: well, there's no compelling reason for me to learn git :P
16:15:25 <idnar> PeakerWork: especially since it'll be more work than every other VCS I've learned combined
16:15:35 <Nafai> idnar: What's your vcs of choice at the moment?
16:15:36 <SamB> PeakerWork: that's probably true
16:15:40 <idnar> PeakerWork: the problem isn't understanding how it works, it's just memorizing all the incomprehensible command names
16:15:43 <SubStack> strictness is pesky
16:15:49 <idnar> Nafai: darcs, when VCS is the only concern
16:15:59 <idnar> Nafai: and bzr when community / integration is a concern, because of launchpad
16:16:08 <SamB> idnar: assuming you don't use arch, anyway
16:16:25 <idnar> PeakerWork: they might as well have used 32-bit SHA digests to name the commands, for all the mnemonic sense they make to me
16:16:34 <mike-burns> Complaining about the "incomprehensible command names" smacks of OO programmers complaining about Haskell's incomprehensible function names and whatnot.
16:16:44 <SamB> idnar: come on
16:16:54 <PeakerWork> idnar: its really easy to memoize the commands -- once you use them you remember them
16:16:55 <SamB> at least most of them are pronouncable
16:17:02 <idnar> mike-burns: I'm not trying to put that forward as a criticism of git
16:17:03 <SamB> and shorter than 8 chars, too
16:17:25 <SubStack> heh, nice use of "memoize" as a stand-in for "memorize"
16:17:25 <SamB> mike-burns: but too often they *are* incomprehensible
16:17:27 <idnar> mike-burns: but it does mean that it's difficult to justify the effort
16:17:52 <idnar> naming is a pretty subjective issue
16:17:52 <PeakerWork> idnar: checkout, reset, merge, pull, push -- are these incomprehensible?
16:18:09 <SamB> what's incomprehensible is what they do, typically
16:18:10 <idnar> PeakerWork: "incomprehensible" isn't quite the right word
16:18:15 <SubStack> coming from perl, I rather like the terse function names
16:18:22 <idnar> PeakerWork: what I mean is that what I expect them to do, and what they do, are completely and utterly different
16:18:27 <Nafai> For me the effort was justified when I saw the practical experience and productivity that the git experts I know had
16:18:30 <idnar> PeakerWork: that's even worse than random illegible names, I guess
16:18:32 <Nafai> It was quite compelling
16:18:41 <SamB> idnar: worse, sometimes they're only half-utterly different
16:19:01 <idnar> PeakerWork: but for example, git reset does like 3 completely different things
16:19:33 <SamB> that's what happens when you let kernel programmers design a VCS
16:19:39 <Nafai> I'm of the opinion that git has a solid core
16:19:42 <SamB> they give you a lovely low-level model
16:19:44 <Nafai> And solid core concepts
16:19:46 <SamB> but a horrible UI
16:19:55 <Nafai> There's nothing to stop UI improvement in the future
16:20:03 <idnar> anyway, I'm seriously attached to darcs's model
16:20:07 <Nafai> And, in fact, to me, that seems to be highly more likely with git than with other vcs's
16:20:18 <Nafai> So it is worth sticking around, because it will only get easier
16:20:23 <mike-burns> grb is a solid improvement over low-level git.
16:20:33 <idnar> if git's UI improved, it would perhaps not be terribly painful to use, but I still wouldn't have any reason to choose it over darcs
16:20:52 <Nafai> I haven't looked at grb
16:20:53 * Nafai googles
16:20:53 <SamB> idnar: I really want some hybrid of that with a DAG-based history model
16:21:16 <mike-burns> grb doesn't cover everything, just branching.
16:21:18 <blackh> idnar: Is there a way to get a list of non-boring local files that haven't been 'darcs add'ed?  That's the only that drives me completely nuts about it.
16:21:27 <idnar> and the popularity of stgit / mq / quilt suggests that I'm not the only one that likes the darcs model
16:21:44 <idnar> blackh: "darcs whatsnew --look-for-adds | grep '^a'" perhaps?
16:21:44 <SamB> where you can have darcs-style patches over top of a git-style history, and then you can freeze those patches into the history one-by-one
16:21:57 <PeakerWork> idnar: yeah, git reset and git checkout have dual behavior.  I also hate[d] the UI. I got used to it. I no longer worry about the UI, it now feels natural after I'm used to it (while I'm still clear that it sucks, because I remember my newbie times :-)
16:22:12 <PeakerWork> idnar: Don't let the UI discourage you -- its a tool you don't want to miss out on. Really
16:22:24 <PeakerWork> its not "yet another DVCS", its different
16:22:24 <SamB> idnar: too bad those don't give you anything like the darcs model
16:22:32 <idnar> PeakerWork: it's yet another tree-based DVCS
16:22:44 <idnar> SamB: it's closer to the darcs model than anything else
16:22:49 <sm> idnar, blackh: just darcs wh -l
16:23:01 <idnar> sm: well, I was trying to answer the question precisely :P
16:23:05 <SamB> idnar: It leaves me filled with hate
16:23:08 <blackh> sm, idnar: You have just improved my life!
16:23:12 <SamB> whereas darcs ... doesn't
16:23:21 <idnar> blackh: you can also pass -l / --look-for-adds to darcs record, fwiw
16:23:25 <SamB> I think that's related to an important difference
16:23:25 <PeakerWork> The darcs model is wrong, IMO -- because it is too hard-coded to a certain diff strategy, and will inevitably have many false negatives and false positives in its patch-dependency identification.  "git" allows doing everything that "darcs" does but you can select your diff strategy at the cherry pick time
16:23:28 <sm> idnar: it only lists adds afaik
16:23:43 <idnar> SamB: sure, if darcs is a Porsche, quilt is a tricycle
16:23:51 <Nafai> I know this is very cliche, but after being used to git, using darcs I'm impressed with how amazingly slow common operations are :)
16:24:00 <SamB> PeakerWork: except git doesn't have a clue what you've just done in cherry-picking something ...
16:24:17 <idnar> PeakerWork: yes, in theory tree-based and patch-based are isomorphic
16:24:31 <idnar> PeakerWork: but in practice, implementing the operations I routinely perform with darcs in a tree-based VCS is completely insane
16:24:32 <PeakerWork> SamB: why not? It has all the metadata
16:24:38 <idnar> PeakerWork: and, hey, nobody has actually implemented it
16:24:46 <SamB> Peaker: it's not really metadata
16:24:47 <PeakerWork> idnar: what operations are those?
16:24:53 <idnar> PeakerWork: "cherrypicking"
16:25:27 <roconnor> hooray, elliptical intercept!
16:25:29 <SamB> hmm
16:25:31 <idnar> PeakerWork: that's actually the main thing about darcs; "cherrypicking" isn't a special case, it's the /only/ case
16:25:32 <SamB> I know what I want
16:25:35 <PeakerWork> SamB: If you look at the revision graph -- the nodes are revisions/trees, and the edges are patches.  darcs has patches, and no trees.  git has both patches and trees in its UI.  And both are useful concepts
16:25:37 <SamB> I want a cherry-tree VCS
16:25:39 <roconnor> other than it was semi-done by hand
16:25:39 <idnar> patches just flow around
16:25:44 <PeakerWork> idnar: but everyone has cherry picking
16:25:45 <roconnor> I need to automate that
16:25:51 <SamB> with darcs-style "cherries" at the ends of git-style "branches"
16:26:00 <idnar> PeakerWork: hardly
16:26:09 <idnar> PeakerWork: everyone has "give me a diff and apply it"
16:26:11 <SamB> except unlike a real cherry tree, you can freeze the cherries into the branches ;-)
16:26:18 <PeakerWork> idnar: if you have truly independent patches, you can also put them in separate branches, which is similar to what darcs does, and then merge whatever branch you want
16:26:35 <SamB> PeakerWork: that's painful
16:26:44 <idnar> PeakerWork: with darcs, it's implicit
16:26:46 <PeakerWork> SamB: wh?
16:26:48 <PeakerWork> SamB: why?
16:27:03 <idnar> PeakerWork: I don't have to manually separate everything out into the most-independent branches, and then merge N branches together to get the combination I want
16:27:14 <PeakerWork> SamB: git checkout -b my_branch ; git commit -a -m"My little change here" ; git checkout master   -- if you don't have this aliased :-)
16:27:19 <SamB> then you have to back out of that to actually commit anything, assuming you don't want it to be an octopus' daughter
16:27:38 <PeakerWork> idnar: you have to manually separate the most-independent patches, and then merge N patches, instead?
16:27:48 <idnar> PeakerWork: why do I have to manually separate them?
16:27:58 <PeakerWork> idnar: each commit is a manual separation
16:27:59 <idnar> PeakerWork: if they're independent, I can push / pull them independently, even if I recorded them all in the same branch
16:28:04 <SamB> PeakerWork: I tell you, the cherry tree model is sound!
16:28:08 <PeakerWork> idnar: how can dependency be computed?
16:28:09 <idnar> PeakerWork: I can also combine and separate at will
16:28:26 <idnar> PeakerWork: dependency is textual
16:28:33 <idnar> PeakerWork: although you can manually specify additional dependencies
16:28:35 <SamB> Peaker: well, darcs doesn't try to compute dependancy decently
16:28:50 <PeakerWork> idnar: dependency computation will be wrong, false positives and false negatives.  Sometimes people let auto-merges (supposedly independent) occur before pushing to our company's mainstream -- it breaks everyone's compilations/builds
16:28:55 <SamB> ... probably because that's harder than the halting problem
16:28:56 <idnar> well, it's only textual because all of the existing patch types are textual
16:29:12 <PeakerWork> idnar: exactly! and darcs has committed to poor textual diffs
16:29:17 <idnar> PeakerWork: how has it committed?
16:29:30 <SamB> idnar: all the ones you've committed in the past are like that
16:29:30 <PeakerWork> idnar: the entire repo is based on it, you can't decide to use a different patch strategy for the next patch
16:29:36 <idnar> PeakerWork: sure you can
16:29:45 <g36q>  /quit
16:29:50 <PeakerWork> idnar: how? The entire repo is built on top of these patches
16:29:51 <sm> darcs folk regularly talk about introducting smarter patch types
16:29:56 <idnar> PeakerWork: it won't be retroactive, of course
16:29:56 <PeakerWork> idnar: change a strategy and all your dependencies are wrong
16:29:58 <sm> all it needs is more developers
16:30:06 <SamB> sm: ... right
16:30:07 <idnar> PeakerWork: darcs already supports and makes use of multiple patch types
16:30:15 <SamB> that's seriously scalable
16:30:25 <PeakerWork> idnar: how does it deal with changing the dependencies of patches?
16:30:39 <idnar> PeakerWork: I'm not sure what you mean by "changing"
16:30:52 <PeakerWork> idnar: The revision model has no such problem, and you can cherry pick patches by looking at graph edges rather than nodes, and later, the mergers will see that edges already exist..
16:31:07 <idnar> PeakerWork: look, here's the thing
16:31:11 <troutwine> If I'm in the IO monad and I'd like to pass a function two arguments from two different IO operations can this be done cleanly without dropping into do notation?
16:31:12 <PeakerWork> idnar: If you use a different kind of text patch - then dependencies are all different too
16:31:13 <SamB> PeakerWork: what mergeres actually *see* that?
16:31:27 <PeakerWork> troutwine: liftM2 (,) getLine getLine
16:31:29 <idnar> PeakerWork: let's say I have 5 patches (call them P1 through P5), represented as a sequence of commits on a branch
16:31:42 <troutwine> PeakerWork: Beautiful. Thank you.
16:31:53 <idnar> PeakerWork: for simplicity, let's assume they're all independent
16:32:16 <PeakerWork> idnar: ok
16:32:36 <idnar> PeakerWork: with darcs, I can pull P2 and P4 into another branch (call it B), pull P1 and P5 into branch C, and then later pull from branches B and C into branch D
16:33:00 <idnar> I can even go on to pull P3 into D, and now I'll have that whole side branch merged
16:33:22 <idnar> in any other VCS, cherry picking all of those patches individually will be a completely different experience from just merging the whole branch, or a prefix thereof
16:33:30 <idnar> and it'll mostly be a complete mess
16:33:35 <PeakerWork> idnar: "different experience"?
16:33:37 <PeakerWork> let me try that
16:33:45 <idnar> because the tree-based merge algorithms can't "skip over" the holes in the merge sequence
16:34:11 <idnar> if you cherry pick P2 and P4, and then try to merge the whole thing, you'll get P1+P2+P3+P4+P5 when you actually need P1+P3+P5
16:36:11 <PeakerWork> idnar: I just tried this out, and it all worked perfectly in git
16:36:51 <dschoepe> troutwine: another possibility with Control.Applicative: (,) <$> getLine <*> getLine.
16:37:10 <copumpkin> which icfp teams are using haskell?
16:37:14 <copumpkin> is there a list somewhere?
16:37:20 <idnar> PeakerWork: well, in the simple case, I guess 3-way merge of P1+P2+P3+P4+P5 on top of P2+P4 doesn't make any difference
16:37:27 <mornfall> PeakerWork: "git can do everything darcs can" and so can turing machine.
16:37:39 <PeakerWork> mornfall: With the same UI ease, too
16:37:39 <dons> http://icfpcontest.org/scoreboard.php
16:37:47 <mornfall> PeakerWork: No.
16:37:47 <idnar> PeakerWork: but if you scatter some other patches around, I'm pretty sure things break down quickly
16:37:51 <copumpkin> dons: yeah, but it doesn't say what language they're using
16:37:53 <PeakerWork> mornfall: give me an example then
16:37:53 * dons tries to remember who "Side Effects May Include... " was
16:38:05 <PeakerWork> idnar: show me an example that would break down, I don't think it will
16:38:06 <idnar> PeakerWork: same UI ease?!
16:38:16 <copumpkin> I'm guessing purely functional infrastructure is haskell?
16:38:32 <dons> we won't know till later what languages they nominated, i think
16:38:32 <PeakerWork> idnar: The learning curve sucks - but the difficulty is LEARNING the UI, not using it.  Once you know the horrible UI -- its just as easy :-)
16:38:36 <idnar> PeakerWork: darcs pull prompts me with a sequence of patches
16:38:42 <copumpkin> ah ok
16:38:43 <idnar> PeakerWork: where's the interactive patch selection UI in git?
16:38:44 <mornfall> PeakerWork: Well, given that even trivial operations in git take me tens of minutes to figure, I probably can't give you an example.
16:39:08 <PeakerWork> idnar: git cherry-pick <refname>    or you could use an interactive gui (I believe gitk can do that)
16:39:15 <mornfall> And usually involve poking one of my friends that use git, often with disappointing results.
16:39:23 <idnar> PeakerWork: okay, I want to pull 50 patches
16:39:31 <PeakerWork> mornfall: take tens of minutes to figure -- because you don't yet know git. git has a crappy learning curve..
16:39:44 <idnar> PeakerWork: out of, say, 60 patches in a branch that aren't present in my local one
16:39:51 <mornfall> PeakerWork: Well, I know how git works internally. The commandline is whole another story.
16:39:55 <PeakerWork> idnar: then git cherry-pick the 50 patches
16:39:55 <SamB> Peaker: most VCSes call that thing a UI
16:39:57 <idnar> PeakerWork: a) how do I get a list of the patches that are missing?
16:40:02 <SamB> not a "learning curve"
16:40:03 <dsturnbull> i really don't see how it's possible for some people to know git, and some people claim that it's only possible to use git if you ask people who know git
16:40:06 <PeakerWork> idnar: all branches are present on your "local one" in git
16:40:08 <dsturnbull> isn't that a little recursive?
16:40:10 <idnar> PeakerWork: b) running git cherry-pick on 50 patches is hardly "easy"
16:40:16 <idnar> PeakerWork: by "local" I mean "the one I'm working on right now"
16:40:29 <idnar> PeakerWork: call them branch A and branch B, whatever :P
16:40:39 <SamB> there's supposed to be something called "git cherry"
16:41:10 * sm shakes his fist on general principles
16:41:13 <PeakerWork> idnar: I just used "git merge" after having cherry picked some of the revisions, it just "filled in the holes" for me
16:41:27 <mornfall> SamB: That must be an urban legend, given that git is an old bitch. *hides*
16:41:32 <PeakerWork> idnar: maybe you should give git a chance, cherry-picking seems to do all that you like about darcs
16:41:45 <idnar> PeakerWork: if it takes me all day to do the cherry-picking, that hardly helps
16:41:55 <PeakerWork> idnar: if you just need an interactive "do you want to cherry-pick this?" prompt, you can write a bash script in about 3 minutes
16:41:56 <SamB> PeakerWork: well, it always seems to get confused when GDB CVS is cherry-picked from git branches ...
16:42:10 <monochrom> "just git it"
16:42:12 <idnar> PeakerWork: how do I get a list of the patches that are present in branch A, but missing in branch B?
16:42:14 <PeakerWork> SamB: CVS is confused? Or who?
16:42:26 <SamB> PeakerWork: git gets confused when you try to do merges
16:42:43 <PeakerWork> SamB: where/when? I haven't encountered any of that, and I work with git pretty intensively
16:42:49 <mornfall> Of course it does. Merging partially cherry-picked branches is near to impossible with git's algorithm.
16:42:55 <PeakerWork> (We do keep our features in separate branches, so we don't need to cherry pick a lot though()
16:42:55 <SamB> though maybe part of that is because of how much changing tends to happen during the process of getting the patches into GDB CVS ...
16:43:19 <PeakerWork> mornfall: it does so perfectly in my test cases
16:43:21 <SamB> but I still think it does a pretty moronic job of the merging
16:43:32 <SamB> it tries to do just one 3-way merge on each file
16:43:37 <SamB> that seems kinda stupid
16:43:45 <idnar> PeakerWork: I think http://zooko.com/badmerge/simple.html is an example of where darcs-merge does the right thing, but 3-way merge doesn't
16:43:51 <mornfall> SamB: Well, it's sensible, because it works with the easy cases.
16:44:22 <PeakerWork> idnar: I asked #bzr once why they do 3-way merges and not that style of merge.. they said it confused users to no end when the merge used all of the intermediate history information
16:44:35 <SamB> mornfall: well, I mean, sure that might be a good first attempt, but it then just gives up if it hits a conflict that way
16:44:44 <idnar> PeakerWork: I don't really care if that's true or not :P
16:44:46 <SamB> instead of trying to bring in more of the history
16:44:55 <idnar> PeakerWork: I'm a VCS user, not a VCS developer
16:45:16 <mornfall> SamB: You could go on and on improving the heuristic. It would still be a heuristic.
16:45:34 <mornfall> Darcs at least gives you an algorithm.
16:45:47 <SamB> mornfall: well, being willing to compose a number of 3-way merges would be pretty handy
16:45:55 <PeakerWork> idnar: http://www.kernel.org/pub/software/scm/git/docs/git-merge.html   see -s option
16:46:03 <mornfall> SamB: And often would lead to embarassingly bad merges.
16:46:22 <idnar> PeakerWork: nobody has implemented "darcsmerge" for git, because it would be nearly impossible
16:46:40 <mornfall> idnar: Well, if anything, it will be also incorrect, due to git data model.
16:46:44 <idnar> I don't see how you could reconstruct the patch DAG from a git tree in any reasonable amount of time
16:46:46 <PeakerWork> idnar: at worst, you need metadata about equivalence of commits
16:46:48 <idnar> if it's even possible at all
16:46:55 <dons> idnar: i wonder if you could by pulling code out of darcs.
16:46:56 <idnar> git doesn't have patch identity
16:47:09 <PeakerWork> idnar: it does manage to avoid re-merging stuff I cherry-picked, how does it do that?
16:47:12 <idnar> so you can't tell that different representations of the same patch are, in fact, the same patch
16:47:26 <idnar> PeakerWork: if you're using 3-way merge, it probably doesn't avoid it
16:47:35 <mornfall> dons: No. What idnar says. And even if it would have, it edits patches incompatibly to commute.
16:47:38 * SamB agrees with idnar 
16:47:42 <PeakerWork> idnar: but it did avoid it, I see in the log history
16:47:58 <mornfall> dons: I.e. there's no way to retrofit darcs history on existing git history.
16:48:00 <dons> rohan drape writes massive amounts of haskell
16:48:06 * dons builds a dozen hsc-* libs
16:48:12 <mornfall> dons: You could, in theory, restrict git to only allow darcs-compatible histories though.
16:48:13 <dons> mornfall: makes sense.
16:48:23 * SamB does not think that PeakerWork can have done merges from disparate-enough branches of large-enough projects with enough developers to actually have encountered the issues ...
16:48:36 <PeakerWork> idnar: I think the keep independent-patches independent idea of darcs nice, but wrong/impossible because LOGICAL dependencies are Godel-type impossible to detect, it will always be flawed with false negatives, and probably false positives too
16:48:54 <idnar> PeakerWork: that's missing the point
16:48:54 <PeakerWork> SamB: we're using git on a relatively large project here (though Cathedral style)
16:49:06 <idnar> PeakerWork: darcs and git both operate on a textual level
16:49:11 <SamB> Peaker: how far apart do your branches drift?
16:49:12 <mornfall> PeakerWork: Well, we live with turing machines even though termination is undecidable.
16:49:40 <idnar> PeakerWork: the fact that you can't represent semantic operations perfectly on a textual level doesn't mean that the tools are useless, it just means they're imperfect
16:49:50 <SamB> PeakerWork: git has nothing *but* false positives there
16:49:54 <mornfall> PeakerWork: You will always have buggy programs, and that doesn't stop you from writing programs, either.
16:49:59 <PeakerWork> idnar: git does not operate "on a textual level" in the same way that darcs does..  specific commands in git operate textually or however you tell them to.  The repository itself does not have to be tied to anything textual or patch-related
16:50:12 <SamB> it'd be nice to be able to have false negatives for recent work and false positives everywhere else
16:50:12 <idnar> PeakerWork: some day, when we're using semantic editors, we'll have VCSs that represent diffs semantically, but that's still completely orthogonal
16:50:19 <idnar> PeakerWork: if you don't record the information, you can't use it later
16:50:26 <PeakerWork> SamB: given that you just rebase or merge the stuff from anywhere to anywhere, the dependencies in git are simply ignored, so its not false anything
16:50:29 <idnar> PeakerWork: whether that information is tetxual or semantic
16:50:46 <SamB> PeakerWork: ewwwwwwww
16:50:58 <SamB> bad Peaker! no rebase!
16:51:03 <PeakerWork> SamB: rebase is nice :-)
16:51:03 <SamB> SIT!
16:51:06 <idnar> the presence of operations like "git rebase" is a /problem/, not a /feature/ :P
16:51:14 <Nafai> Bah
16:51:16 <Nafai> rebase is useful
16:51:20 <SamB> idnar: it's handy sometimes
16:51:22 <Nafai> When used in the right context
16:51:25 <idnar> SamB, Nafai: oh, certainly
16:51:26 <PeakerWork> SamB: dependencies are re-computed by the merge that you're doing NOW with an algorithm you choose NOW, not one pre-determined for the repository
16:51:30 <SamB> but if you say "just rebase", you've got a problem ;-)
16:51:31 <mike-burns> When you need to rebase, it's nice to have it.
16:51:34 <PeakerWork> idnar: why?
16:51:37 <PeakerWork> idnar: git rebase is great
16:51:44 <idnar> bashing the window of your car in with a sledgehammer is also really useful if you locked the keys inside and don't have a spare set
16:51:46 <mornfall> PeakerWork: Yeah, which means the merges are irreproducible. Sad.
16:51:48 <PeakerWork> idnar: bzr effectively has it too, with "bzr uncommit"
16:51:53 <SamB> Peaker: but does not belong in the same sentance as "just"
16:51:53 <idnar> that doesn't mean it's something I want to do, if I can help it
16:52:09 <PeakerWork> mornfall: you have the entire diff, as well as git itself and its strategies
16:52:14 <mornfall> Last thing I need is VCS with operations that I cannot repeat.
16:52:31 <PeakerWork> idnar: Why wouldn't you? it makes histories simple and fast-forwards stuff
16:52:47 <idnar> PeakerWork: it makes them "simple" by destroying them
16:52:57 <idnar> PeakerWork: and invalidating anything that was based on that history
16:53:04 <mornfall> PeakerWork: Why do you need histories simple? (Or do you admit, that the many-branch model is not so great as you claimed a while back?)
16:53:05 <SamB> we, like Linus, want histories that are at least mostly true
16:53:20 <PeakerWork> idnar: it doesn't "destroy" anything
16:53:28 <monochrom> revisionist history
16:53:30 <SamB> PeakerWork: Linus disagrees
16:53:33 <PeakerWork> idnar: The idea is to use rebase on private histories
16:53:36 <idnar> PeakerWork: git rebase effectively produces an entirely new branch that has absolutely nothing to do with the old one
16:53:48 <SamB> PeakerWork: even so, you're supposed to be careful with it
16:53:55 <PeakerWork> mornfall: The many-branch  model is great partially BECAUSE we can keep histories simple
16:53:58 <idnar> that's not a sledgehammer you want to swing around wildly
16:54:08 <idnar> PeakerWork: here's another darcs feature I rely on regularly
16:54:22 <idnar> PeakerWork: if two people perform the same merge in different branches, the result is equivalent
16:54:27 <PeakerWork> idnar: It can and should be related to the previous branch (I think this feature is missing from rebase, and if it had it, you could rebase everything public too)
16:54:35 <idnar> PeakerWork: that is, both branches are now /the same branch/
16:54:35 <mornfall> PeakerWork: So that you have to throw away flexibility of cherrypicking older features to get manageable history?
16:54:55 <PeakerWork> idnar: If 2 users perform the same merge differently -- you might want to choose the "better" one?
16:55:12 <idnar> PeakerWork: you can't perform the same merge differently, because there's only one merge "strategy" in darcs :P
16:55:32 <PeakerWork> mornfall: no, the simple history lets you represent "features" as little branches that hang off a dynamic point in history by rebasing them
16:55:34 <idnar> PeakerWork: if you have to record another patch to resolve conflicts, then it's no longer the same merge
16:55:52 <mornfall> I guess overall I'm still unconvinced. Together with the learning "curve" (I actually don't think it's connected at all, not to mention smooth) that makes git a good theoretical study material, but not much else.
16:55:56 <saml> hey, can I search hackage so that it'll return every project that depends on x?
16:56:00 <PeakerWork> mornfall: though representing them as a little tail off any arbitrary revision is ok too, because you can always ignore the exact revision and just look at the graph edges rather than nodes
16:56:10 <dsturnbull> except for all the actual users, mornfall?
16:56:23 <PeakerWork> idnar: if there are no conflicts, then its true of git as well
16:56:26 <dsturnbull> i mean, try conciling what you just said with the practical aspect of hundreds of thousnds of users
16:56:39 <kynky> it was something linus knocked up in bash scripts, guess it could be ported to haskell :)
16:56:47 <idnar> PeakerWork: won't the different merges have different IDs and whatever?
16:56:52 <PeakerWork> idnar: that 2 merges of 2 users will generate the exact same commit, or if based on different commits, will merge cleanly later
16:56:54 <mornfall> dsturnbull: People love inferior solutions.
16:57:17 <kynky> peole are like sheep, they use stuff other ppl are using
16:57:20 <PeakerWork> mornfall: I tried darcs and git, and I greatly prefer git.  so do the ghc team
16:58:01 <idnar> dsturnbull: there are countless software packages that I won't touch with a ten-foot pole, that are used by millions of other people
16:58:09 <PeakerWork> mornfall: if you give git a few weeks to conquer its horrible learning curve, you'll probably find that at least from a purely technical standpoint, it has much over darcs -- and that alone justifies learning it
16:58:12 <dsturnbull> people use inferior solutions by default, then migrate en masse to superior solutions
16:58:12 <idnar> dsturnbull: I can only conclude that what's good for the masses is not good for me
16:58:15 <mornfall> PeakerWork: If all your work is on little branches, where does the thing they hang off comes from?
16:58:21 <SamB> PeakerWork: how come they have not yet switched, then?
16:58:24 <mornfall> s/comes/come/
16:58:25 <idnar> dsturnbull: by the same token, what's good for me is probably not good for the masses
16:58:28 <dsturnbull> the masses still use svn, idnar
16:58:35 <kynky> the same way haskell has a learning curve, and when you get used to that then.... :)
16:58:35 <PeakerWork> mornfall: its just revisions on master or whatever wider branch
16:58:49 <mornfall> PeakerWork: But you are working on branches. What *is* master?
16:58:50 <dsturnbull> the actual question is, are you going to isolate yourself because of your stubborn opinion?
16:58:52 <idnar> dsturnbull: but at the end of the day, it comes down to what works best for /me/
16:58:54 <PeakerWork> mornfall: but the idea is that if those branches are private, you can keep moving them to be on a new master, which makes sure they don't diverge too far
16:59:04 <SamB> kynky: but Haskell looks nice on this side of the learning curve
16:59:04 <dsturnbull> no, it's what works best for a /team/
16:59:10 <PeakerWork> mornfall: usually you have a mainline
16:59:30 <mornfall> PeakerWork: Ah, right. So feature branches *are* thrown away.
16:59:42 <dsturnbull> and if you're just doodling your own personal projects, why so passionate about distributed source control?
16:59:46 <idnar> dsturnbull: okay, what works best for "us"
16:59:47 <PeakerWork> mornfall: Sure, when I merge a feature branch, I usually throw it away afterwards. Why wouldn't I?
17:00:03 <dsturnbull> what works best for "us" has already been decided
17:00:06 <PeakerWork> mornfall: note that "throwing away a branch" merely means deleting a pointer.  I still can find all of the refs in history
17:00:07 <idnar> dsturnbull: hey, PeakerWork is the one who started evangelizing
17:00:07 <kynky> the nature or distributed SCM is that many others use it, so in one way if its a project used used y you, then use what you want, butwhen you expect many other ppl to work on it, using something that fits thhat criteria is best
17:00:17 <mornfall> PeakerWork: Well, if you needed it before to make cherry-picking feasible, how can you cherry-pick when it's gone?
17:00:21 <idnar> dsturnbull: I'm not telling anyone to use darcs, I'm just explaining why I don't want to use git :P
17:00:32 <pastorn> deech: that seems ok, but where's the big-ass run function as well as the GeneralizedNewtypeDeriving-version?
17:00:39 <idnar> dsturnbull: if I join some existing project that's already using git, then obviously I'll use git
17:00:41 <PeakerWork> mornfall: you don't need the branch ptr to cherry pick, only the revisions themselves, which are still in the history
17:00:42 <dsturnbull> but your arguments aren't really valid if you put your practicality hat on
17:00:45 <dsturnbull> not knowing git is a liability
17:00:55 <PeakerWork> mornfall: the branch merely provides a convenient way of pointing at those revisions. but so does "git log", etc
17:01:00 <dsturnbull> you don't have to like it :)
17:01:08 <idnar> dsturnbull: but until then, I have no reason to expend significant effort in learning git's UI when I don't have any reason to use it
17:01:12 <mornfall> PeakerWork: Nevermind. We are running in circles.
17:01:18 <kynky> :)
17:01:32 <kynky> if it aint broke ...
17:01:33 <mornfall> dsturnbull: I don't know git and don't intend to know. I have better things to spend time on.
17:01:37 <idnar> dsturnbull: it's like memorising the dictionary of a language you have no intention of speaking
17:01:56 <PeakerWork> mornfall: Your loss..
17:02:01 <mornfall> PeakerWork: Yeah, sure.
17:02:02 <kynky> advice doesnt have to be taken
17:02:22 <mike-burns> Refusing to know something seems odd.
17:02:45 <mornfall> mike-burns: It's about wasting time, not knowing something.
17:02:52 <PeakerWork> idnar: about the learning curve.. how did you decide to pass that of Haskell?  It takes quite a bit of effort and time to pass enough of Haskell's learning curve to even understand the benefits, IMO
17:02:53 <dsturnbull> git's prevalence means that you're probably going to need to use it
17:03:02 <mornfall> mike-burns: There are thousands of things more interesting that git UI to learn about.
17:03:10 <dsturnbull> wasting time is coming across a git project and saying 'fuck it' and walking away
17:03:14 <idnar> PeakerWork: I didn't really have that problem
17:03:17 <kynky> i refuse to learn lots due to time constraints
17:03:18 <PeakerWork> idnar: why not?
17:03:23 <mike-burns> mornfall: I agree; I'm only commenting on refusing to know it, not putting it off.
17:03:32 <idnar> PeakerWork: I've not run into any significant difficulties learning Haskell
17:03:49 <idnar> PeakerWork: and the end goal is something I can go "ooh, that's awesome" about
17:03:55 <PeakerWork> idnar: Monads, Monad Transformers, etc, all seems natural and reasonable solutions to the problems at hand when you first heard of them?
17:04:28 <PeakerWork> idnar: I agree its awesome, but only after knowing them you understand that they're awesome. Before, you think: "All this complexity/mind boggling stuff for what I could do this easily in this other language?"
17:04:35 <mornfall> dsturnbull: If the project is interesting, it will change the balance. If no, git doesn't matter. I so far don't know any sufficiently interesting git-based projects.
17:04:40 <kynky> the romans refused to use arabic number system, more fool them
17:04:43 <idnar> PeakerWork: I've never thought that about Haskell, thoug h:P
17:04:59 <PeakerWork> idnar: btw, have you seen yairchu/my Python generator stuff?
17:05:02 <idnar> PeakerWork: I go "what the heck is a Monad?", and then I find out, and I go "ooh, that's awesome"
17:05:20 <idnar> PeakerWork: I guess I've gone far enough that I'm beginning to learn all about Haskell's awkward parts
17:05:31 <SamB> idnar: I personally took a while to admit I knew what one was ;-P
17:06:04 <idnar> PeakerWork: but I can say with certainty that learning Haskell has (so far) been far more pleasant than learning any other language I know
17:06:14 <dsturnbull> mornfall: ghc?
17:06:29 <kynky> haskell seems succint
17:06:32 <idnar> PeakerWork: I suspect my experience is quite atypical, but there you have it
17:06:36 <kynky> succinct*
17:06:45 <PeakerWork> idnar: Feedback on http://github.com/yairchu/generator/blob/990819a2fdd3cfc579ae860bf3cd48bf39bf82b5/testProducers.hs  would be appreciated, btw :-)
17:06:52 <sclv> if you've needed a more complex monad than io in another language, then you welcome it when you come to haskell.
17:07:03 <sclv> and if you haven't needed one, you really have and haven't realized it...
17:07:12 <PeakerWork> sclv: the latter case is far more common
17:07:19 <idnar> PeakerWork: not sure I'm qualified to give feedback on something like that, yet, but I'll try take a look sometime soon
17:07:24 <SamB> PeakerWork: indeed
17:07:38 <mornfall> dsturnbull: What's the current status?
17:07:45 <PeakerWork> idnar: even feedback as a Pythoneer more than a Haskeleer
17:07:51 <sclv> was helping a colleague get some configuration stuff working in java and started mumbling about awful singletons and how i wanted the reader monad...
17:07:52 <mornfall> dsturnbull: And also, GHC is nothing I would significantly contribute to, at this time.
17:08:10 <mornfall> dsturnbull: I have some fixes that need to be done, but that is likely to be one or two patches.
17:08:16 <idnar> PeakerWork: I'm not much of a fan of Python-the-language :P
17:08:17 <SamB> ghc is git-based since when?
17:08:33 <kynky> i prefer ruby to python :)
17:08:39 <PeakerWork> idnar: what associates you with Python?
17:08:43 <sclv> ghc said they were planning to be.. but i think they decided that given the darcs work underway they would hold off on a switch
17:08:48 <dsturnbull> august 2008?
17:09:03 <dsturnbull> maybe they changed their minds
17:09:05 <idnar> PeakerWork: uhm, Twisted and pragmatism, I guess
17:09:08 <mornfall> dsturnbull: august 2008? I guess that's why all current work is in darcs?
17:09:10 <SamB> dsturnbull: is that for sure?
17:09:14 <sclv> it's still a possibility as far as i know.
17:09:29 <sclv> but the current word is that they're going to wait and see on the darcs improvements.
17:09:31 <idnar> PeakerWork: the language itself isn't really awesome, but there are some awesome libraries and frameworks out there
17:09:33 <dsturnbull> ah well
17:09:35 <SamB> I haven't been going to the meetings, so I wouldn't know
17:09:45 <SamB> dsturnbull: have you been going to the meetings?
17:09:50 <kynky> you could say cpan is awesome
17:10:08 <mornfall> Well, there's one thing about darcs and haskell. Dogfood.
17:10:21 <mornfall> And it works both ways.
17:10:24 <PeakerWork> idnar: Knowing Haskell changed my opinion of Twisted for the worse.. (If you generalize Deferred into an IO Monad, you realize it really is a thread, just with coarse locking :-).. What pragmatic stuff are you missing in Haskell?
17:10:25 <dsturnbull> that's not a very affectionate way to refer to darcs
17:10:26 <dsturnbull> ;D
17:10:39 <SamB> dsturnbull: it means we use what we make
17:10:47 <idnar> PeakerWork: uhm, I didn't quite mean it that way
17:10:49 <dsturnbull> i know what it means
17:11:01 <BMeph> When you see "In the (State s) monad, return ==State . (,)", and you think about it for two-to-five seconds and say, "okay, that's cute", then you know that you've "learned" Monads. :)
17:11:05 <idnar> PeakerWork: I meant it more in the "everybody I know knows Python, but not Haskell" sense
17:11:14 <PeakerWork> idnar: ah
17:11:45 <idnar> PeakerWork: I think the biggest practical issue I have with Haskell at the moment is implementation stability
17:11:51 <mornfall> Haha, good one. Python is to Haskell what Git is to Darcs.
17:11:58 <idnar> PeakerWork: it seems like there's very little commitment to backwards compatibility
17:12:04 <kynky> mornfall, dont agree
17:12:10 <kniu> how do I see what precedence an operator has?
17:12:24 <PeakerWork> mornfall: or the other way around? :-)
17:12:31 <mike-burns> kniu: :info in ghci
17:12:31 <pragma_> kniu: :info (op)
17:12:37 <kniu> thanks.
17:12:43 <EvilTerran> kniu, :info in ghci
17:12:44 <mornfall> In terms of user bases and pragmatism, at very least. That's fairly undisputable.
17:12:45 <EvilTerran> (or just :i)
17:12:50 <BMeph> kniu: Only, without the parens. :)
17:13:01 <mornfall> (You are not allowed to disagree.)
17:13:16 <PeakerWork> mornfall: Haskell is *growing* in popularity :-)
17:13:18 <pragma_> You need the parens for infix operators such as +
17:13:32 <mike-burns> Huh, you don't need parens for :info.
17:13:34 <mornfall> PeakerWork: And python moreso.
17:13:57 <PeakerWork> mornfall: percentage-wise, I'm not sure that's true
17:14:04 <idnar> PeakerWork: I've just about given up on Haskell as my long term "next language" because of that, unfortunately
17:14:06 <mike-burns> I suspect that Haskell is growing faster than Python.
17:14:25 <copumpkin> I converted one person from "haskell sucks" to "wow, I'm going to need to look into this more deeply, that's cool" today
17:14:27 <PeakerWork> idnar: yeah, that's indeed a problem, and a blessing :)
17:14:34 <dsturnbull> i'd be surprised if python is growing faster than the population growth rate
17:14:35 <mike-burns> idnar: You're giving up because Haskell is growing in popularity?
17:14:35 <PeakerWork> copumpkin: cool :-)
17:14:37 <pragma_> oh, you don't need the parens.
17:14:40 <dsturnbull> guido is putting his foot in it regularly
17:14:41 <sclv> idnar: i totally disagree about compatibility and commitment
17:14:41 * pragma_ blinks.
17:14:41 <dons> throw some STM or threads at 'em
17:14:42 <PeakerWork> copumpkin: I've converted like 10 people here, I think
17:14:45 <idnar> mike-burns: no, because of the backwards compatibility issue
17:14:49 <mike-burns> idnar: Ah.
17:14:53 <copumpkin> PeakerWork: nice!
17:15:01 <SamB> idnar: I totally disagree as well
17:15:01 <copumpkin> someone should maintain a haskvangelism counter site :P
17:15:03 <idnar> mike-burns: eg. the exception changes
17:15:08 <sclv> haskell unlike python has a standard
17:15:09 <kynky> i think haskll is elegant, wouldnt say darcs is most  elegant, git was made primarily for merging to solve a problem in a way , not done b4, bash scripts were used as linus was most competant in them, python to me is ugly, and darcs from my perspective a bit ugly
17:15:14 * Pseudonym hasn't managed to convert anyone yet
17:15:15 <PeakerWork> copumpkin: yairchu went from skeptical to implementing variants of continuation monad transformers in a couple of months :-)
17:15:16 <SamB> there is far too much commitment to backwards compatability in all the wrong ways :-(
17:15:17 <copumpkin> to keep track of how many conversions people have made, and haskell acnestry
17:15:26 <copumpkin> ancestry
17:15:27 <sclv> the exception changes are trivial to fix, including just by importing the old-exception compat layer
17:15:28 <BMeph> pragma_: Thank you. ;)
17:15:37 <PeakerWork> copumpkin: other friends are studying it deeply, reading RWH, etc.  Other friends just get lectures from me about cool Haskell stuff sometimes
17:15:48 <idnar> sclv: hmm, I wasn't aware of a compat layer
17:15:51 <copumpkin> :D
17:15:52 <idnar> sclv: can you mix the two at all?
17:15:58 <dsturnbull> hmm RWH
17:16:11 <sclv> the core of haskell is very solid and simple. the in-flux stuff is a bit in-flux, but ppl work very hard to keep a compat layer
17:16:12 <PeakerWork> SamB: its funny they're willing to break Base/Control.Exception/etc, but not have Monad subclass Applicative...
17:16:16 <dsturnbull> i found the last half quite rushed, preferred huttons'
17:16:18 <sclv> at least as much as python or the other big ones
17:16:31 <PeakerWork> sclv: Nah, Python is far more backwards compatible
17:16:36 <sclv> idnar: as far as i know the compat layer is built on top of the other layer, but i dunno
17:16:37 <monochrom> Haskell ancestry is like vampire ancestry.
17:16:45 <PeakerWork> sclv: generally, large stuff that compiled with ghc 6.8 don't compile with ghc 6.10 cleanly
17:16:54 <kynky> i like yaht,haskell wiki books, rwh and those 26 haskell 1.5h vid lectures for learning, as well as practice
17:17:06 <Badger> lyah :)
17:17:07 <PeakerWork> kynky: where are the videos?
17:17:09 <idnar> sclv: the problem is that "it's easy to fix" doesn't really cut it in the long run
17:17:13 <sclv> ah, i suppose. but python just introduced big breaking changes lately with py3k, no?
17:17:18 <monochrom> Anyway I got bit by lots of people in comp.lang.functional
17:17:30 <idnar> sclv: py3k is the reason why I'm looking for a new language
17:17:41 <dons> PeakerWork: based on what?
17:17:46 <idnar> sclv: if I have to port all my python code to a new language, I want it to be Haskell or Erlang or something, not Python 3
17:17:49 <PeakerWork> sclv: the Haskell98 standard is pretty worthless. Virtually everyone that's doing interesting stuff is using extensions
17:17:51 <SamB> monochrom: is that how you became a functional programmer, then?
17:17:56 <dons> PeakerWork: all our production stuff moved *very* cleanly from 6.8 to 6.10
17:17:57 <PeakerWork> dons: that's just my experience
17:18:11 <SamB> sclv: nobody seems to be using python3k
17:18:11 <dons> millions of dollars worth of code, I suppose. can't get more practical than that.
17:18:12 <PeakerWork> dons: conal's libraries are one example
17:18:13 <sclv> PeakerWork: and the extensions that people use are generally pretty standard too
17:18:20 <idnar> dons: well, that's encouraging
17:18:22 <mornfall> dons: Well, your production stuff is probably not very representative of random opensource projects.
17:18:29 <dons> right.
17:18:36 <sclv> type families which are *marked* as experimental, aside.
17:18:38 <dons> random open source project vs stuff already chosen for production use
17:18:41 <monochrom> SamB: No.
17:18:43 <Pseudonym> I would have thought that open source projects would be easier to migrate.
17:18:46 <kynky> PeakerWork, http://video.s-inf.de/#FP.2005-SS-Giesl.(COt).HD_Videoaufzeichnung
17:18:48 <dons> this is why we have the Haskell Platform, kids
17:18:49 <PeakerWork> sclv: well, type family stuff broke a lot
17:18:50 <mornfall> Pseudonym: Why?
17:18:52 <sclv> our stuff moved super cleanly from 6.8 to 6.10 too, for what its worth
17:18:52 <kynky> the fp lectures
17:18:54 <idnar> I mean, I'm not trying to make out that every random crummy Python lib out there does nice smooth backwards-compatible changes
17:18:59 <PeakerWork> kynky: what language is that?
17:19:02 <SamB> monochrom: then how does that relate to your "vampire history" thing
17:19:03 <mornfall> dons: Yes, the platform is awesome.
17:19:04 <PeakerWork> kynky: the videos aren't English?
17:19:04 <SamB> ?
17:19:08 <idnar> but the major dependencies I use (like Twisted) have pretty strict backwards-compatibility policies
17:19:13 <dons> sclv: yeah, i think 6.10.x was the smoothest yet, thanks to cabal-install and the base-3 hacks
17:19:14 <sclv> the hardest part was upgrading happs to happstack
17:19:16 <kynky> all haskell, they are in english, i watched them
17:19:23 <idnar> I guess while I'm on the subject, what's the Haskell equivalent of deprecation warnings?
17:19:24 <dons> we did a lot to check that hackage kept building
17:19:28 <monochrom> It was my Haskell ancestry.
17:19:31 <sclv> oh, and some irritating stuff with gtk2hs, so we just stopped using that mainly.
17:19:32 <dons> and remember > 5% broke in the update to 6.10.x
17:19:41 <dons> < 5%
17:19:41 * pragma_ is confused why "Real World Haskell" introduces inefficient thunking functions, and then has optimized non-thunking replacements such as foldl vs foldl'
17:19:48 <dons> pragma_: ??
17:19:49 <sclv> idnar: the deprecation pragma
17:20:17 <dons> pragma_: prob. because its teaching you what you need to know when reading others code :)
17:20:20 <idnar> sclv: ah, a pragma
17:20:28 * PeakerWork gotta go
17:20:34 <kynky> PeakerWork, http://lambda-the-ultimate.org/node/1303
17:20:34 <sm>   kynky, which of those are the haskell-related ones ?
17:20:37 <idnar> sclv: I guess somehow I've never seen that mentioned before
17:20:42 <kynky> sm ^^^
17:20:46 <sm> ah, thx
17:21:11 <kynky> really good, got the hq ones
17:21:16 <sclv> i guess i can't convince you, but the changes that have been introduced since 6.6 have been relatively minute. in general, in a statically typed language, things will break more than in a dynamic one, but the upside is that rather than bugs, you're more likely to get easy to fix type errors.
17:21:32 <idnar> #haskell is a pretty big plus in Haskell's favour, I have to say
17:21:34 <sclv> (i.e. in a dynamic one, you just pack more optional params in or overload, or soforth)
17:21:35 <mornfall> dons: Anyway, do you think it would be possible to deprecate bytestring-mmap in favour of mmap? I could probably fix things in mmap if you point out something that's wrong with it (compared to bytestring-mmap, eg.)...
17:21:43 <Pseudonym> idnar: Truly.
17:21:46 <dons> I like bytestring-mmap
17:21:50 <kynky> haskell is the future
17:21:51 <Pseudonym> #haskell hasn't jumped the shark.
17:21:52 <idnar> I can't think of any other programming language I use where I could have a conversation like this on IRC
17:21:54 <mornfall> dons: I guess you do... :)
17:22:03 <dons> what's wrong with it?
17:22:33 <mornfall> dons: Well, it's sort-of redundant.
17:22:44 <dons> but it was the first!
17:22:52 <mornfall> Was it?
17:22:54 * dons hasn't used any mmap lib other than bytestring-mmap
17:22:57 <SamB> pragma_: well ... why is foldl in Prelude but not foldl'?
17:23:15 <mornfall> Hm, mmap is from feb 2008 or so.
17:23:17 <dons> it'll be deprecated once mmap capabilities are in System.IO.*
17:23:51 <dons> do you love Gracjan or me more? come on.
17:23:53 <dons> ;)
17:23:59 * SamB finds it rather annoying the way things keep getting split out of or merged into base
17:24:09 <dons> they have different interfaces, anyway
17:24:12 <mornfall> I have no idea who Gracjan is. But his package can do writable mmap and can do it on windows.
17:24:19 <SamB> dons: even worse!
17:24:23 <sclv> the general trend is to pull things out, right?
17:24:29 <mornfall> And I have fixed the bugs in POSIX implementation now.
17:24:34 <dons> that's interesting.
17:24:40 <sclv> so there's lots of evolution at the moment to a more long-term stable infrastructure
17:25:12 <mornfall> The other obvious option is to port the mmap stuff to bytestring-mmap and then scrap mmap and replace it with the result.
17:25:25 <mornfall> Although that seems to be more work.
17:25:27 <dons> well, if it really matters. sure. prob. not a big deal.
17:25:45 <idnar> PeakerWork: sooooo, uhm, are you familiar with Twisted's Producer / Consumer abstraction?
17:25:58 <mornfall> Well, the proliferation of various things doing the same thing on hackage is not-so-nice.
17:26:06 <idnar> PeakerWork: I'm just wondering if I should be comparing your thing to that, at all
17:26:27 <idnar> mornfall: man, have you /seen/ CPAN or PyPI? :P
17:26:37 <mornfall> idnar: Of course. Are we trying to emulate them?
17:27:04 <mornfall> I have come to expect more of Haskell.
17:27:05 <mornfall> :)
17:27:08 <monochrom> I love dons. Who in Hell is Gracjan?
17:27:09 <idnar> mornfall: oh, not at all; I'm just saying... :)
17:27:37 <mornfall> monochrom: Some Polish guy, guessing from name.
17:27:47 <dons> that's better.
17:27:54 <idnar> I have no clue how to pronounce "Gracjan"
17:28:01 <idnar> so I guess "dons" wins
17:28:06 <mornfall> Maybe some other Slavic name.
17:28:46 <mornfall> You probably can't prononunce my name either. Do you love me not?
17:29:44 <monochrom> Graçan
17:30:07 <mornfall> monochrom: For a split second, I have thought you are him.
17:31:02 <monochrom> mfix is greatly misunderstood. It does not recurse on monadic actions.
17:31:21 <mornfall> :t mfix
17:31:22 <dibblego> @type (fmap concat .) . mapM
17:31:22 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
17:31:24 <lambdabot> forall a (f :: * -> *) a1. (Functor f, Monad f) => (a1 -> f [a]) -> [a1] -> f [a]
17:35:01 <mornfall> Awww. Prelude.Unicode is sooo cute.
17:35:21 <monochrom> Where Where?
17:35:33 <dons> its purrty
17:35:41 <monochrom> Is it on Hackage?
17:35:42 <mornfall> mansour: Hackage.
17:35:48 <monochrom> Haha OK.
17:35:53 <mornfall> Err.
17:35:55 <mornfall> mansour: Sorry mistab.
17:36:22 <monochrom> "unicode-prelude"
17:36:32 <mornfall> (One'd wish there was a codepoint for unary minus...)
17:37:25 <mornfall> I hate unary minus with burning passion.
17:38:12 <monochrom> type :× a b = (a, b)   :×)
17:38:26 <mauke> >:3
17:38:54 <idnar> haha
17:39:04 <mornfall> The mandatory colon spoils it.
17:39:16 <monochrom> This is so cute.
17:39:58 <mornfall> ∈ has a sorta wrong type tho
17:40:18 <idnar> what's the type?
17:40:35 <monochrom> (∈) :: Eq a => a -> [a] -> Bool
17:40:58 <monochrom> It does the same thing as Data.List.elem
17:41:00 <idnar> what's wrong with that?
17:41:01 <monochrom> @type elem
17:41:03 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
17:41:09 <monochrom> So it's alright.
17:41:15 <mornfall> There should be a typeclass for it. *g*
17:41:21 <idnar> haha
17:41:36 <mornfall> I want to do it with sets.
17:41:40 <kniu> so I got a whole bunch of algebraic data types.
17:41:56 <kniu> and I'm too lazy to type in "deriving (Show, Eq)" for every one of them.
17:42:12 <kniu> is there a way to just say,
17:42:33 <kniu> "for every data declaration in this module, derive these classes."
17:42:38 <monochrom> No.
17:42:52 <kniu> oy.
17:43:00 <mornfall> There's likely a regular expression for it, though.
17:43:13 <mike-burns> kniu: If in vim, record a macro; if in emacs, do the similar thing there.
17:43:27 <mornfall> If in notepad, bang head against wall.
17:43:31 <mauke> data X a = X (((((a)))))
17:43:55 <mornfall> mauke: Sleep deprivation?
17:44:13 <mornfall> (A very ... vibrant ADT tho...)
17:44:38 <mauke> not regexable
17:45:53 <mornfall> mauke: In theory. In practice, no-one seems to care.
17:47:49 <mornfall> mauke: Also, you just need to find end of the thing. And I suspect that = is not legal within ADT definition, so that could suffice.
17:48:40 <mornfall> Although, who knows. It may as well be non-regexpable. So is XML. :)
17:49:13 <monochrom> Right, you do not need a full parser to find where to insert "deriving Show".
17:53:49 <RyanT5000> so, is there a generic way of building datastructures like DiffArray?
17:53:55 <RyanT5000> or at least a tutorial
17:54:48 <sclv> what do you mean by "like diffarray?"
17:54:59 <jmcarthur> you mean pure with an impure implementation?
17:55:06 <RyanT5000> yes
17:55:23 <jmcarthur> looking into ST and, more likely what you want, unsafePerformIO :\
17:55:23 <RyanT5000> specifically, datastructures that rely on the assumption that you're usually reading from the most recently updated copy
17:55:36 <jmcarthur> ah, more specific
17:55:41 <jmcarthur> still, unsafePerformIO and some magic
17:55:44 <jmcarthur> probably the way to go
17:55:52 <RyanT5000> jmcarthur: what i'd really like is a nice, clean, generic way of taking ST stuff and turning it into pure-looking datastructures
17:56:13 <RyanT5000> although i can't think of a way to make it *provably* pure, i can think of some ways it could be made safer
17:56:47 <copumpkin> if you avoid STtoIO and things like that
17:56:51 <copumpkin> it kind of has to be pure doesn't it?
17:57:30 <RyanT5000> copumpkin: can you avoid STtoIO and still get something like a DiffArray?
17:57:45 <RyanT5000> like, suppose i wanted to write a DiffHashMap
17:57:55 <RyanT5000> as far as i can tell, i'd have to just implement it myself
17:58:00 <RyanT5000> i could probably get some traction out of ST
17:58:10 <RyanT5000> but i'd need to do all the hard thinking about unsafePerformIO over again
17:58:18 <RyanT5000> which the DiffArray implementer already figured out
17:58:26 <copumpkin> as long as you make sure your interface is pure, it's safe to do things like that
17:58:39 <RyanT5000> "make sure your interface is pure" sounds easier said than done
17:59:49 <wagle> @yow
17:59:50 <lambdabot> Well, here I am in AMERICA..  I LIKE it.  I HATE it.  I LIKE it.  I
17:59:50 <lambdabot> HATE it.  I LIKE it.  I HATE it.  I LIKE it.  I HATE it.  I LIKE ...
17:59:50 <lambdabot> EMOTIONS are SWEEPING over me!!
18:00:13 <RyanT5000> lol
18:01:37 <mornfall> RyanT5000: You could base your HashMap on DiffArray.
18:01:49 <mornfall> Afterall, hashmap is just a fancy way to use array slots.
18:02:26 <copumpkin> pity DiffArray is unnaturally slow
18:02:30 <copumpkin> why do you need a hashmap?
18:02:40 <RyanT5000> i don't know what i need; this is just an idea right now
18:02:42 <mornfall> Everyone needs a hashmap! Or two.
18:02:45 <copumpkin> lol
18:02:52 <mornfall> You could try Data.Map.
18:02:55 <mornfall> It's pretty fast.
18:02:55 <RyanT5000> mornfall: that's true; but what if i wanted something more complex, e.g. something that would be easy to implement using STRefs
18:02:58 <copumpkin> supposedly we need card counting to do hashtables efficiently
18:02:59 <mornfall> It's faster than bytestring-trie, eg.
18:03:25 <copumpkin> RyanT5000: it would be nice to have a DiffArray and Hashtable that live in ST
18:03:29 <RyanT5000> i don't have any particular need right now; i'm just trying to learn about the DiffArray pattern, and see whether it can be abstracted into a library
18:03:39 <mornfall> RyanT5000: Then you are probably on your own. I also think that DiffAnything is bounded to be slow.
18:03:48 <mornfall> RyanT5000: Memory writes don't come cheap.
18:03:55 <copumpkin> hmm
18:03:57 <copumpkin> ohai mxweas
18:04:39 <mxweas> copumpkin: hai
18:04:41 <mxweas> brb
18:04:47 <mornfall> RyanT5000: And unsafePerformIO costs a premium.
18:04:57 <copumpkin> mornfall: really?
18:05:04 <RyanT5000> mornfall: huh
18:05:07 <copumpkin> there's also inlinePerformIO
18:05:10 <copumpkin> from bytestring
18:05:15 <copumpkin> but it's a pretty negligible cost
18:05:17 <mornfall> copumpkin: About .6 seconds for 80k unsafePerformIO's, IIRC.
18:05:31 <copumpkin> unsafePerformIO isn't really doing any magic
18:05:42 <copumpkin> it's just pulling the value out
18:06:05 <mornfall> It probably needs to go out of StgRun in the RTS into something running IO and then back.
18:06:45 <copumpkin> http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-IOBase.html#unsafePerformIO
18:06:55 <copumpkin> it boils down to unsafeDupablePerformIO (IO m) = lazy (case m realWorld# of (# _, r #) -> r)
18:07:03 <idnar> copumpkin: won't counting cards get you kicked out of the casino?
18:07:14 <copumpkin> idnar: or worse!
18:07:29 <RyanT5000> hm
18:07:35 <mornfall> Well, either way, I spent half a day callgrinding darcs figuring why my indexing was slow, and it turned out that extracting modification time from getFileStatus result involves unsafePerformIO.
18:07:57 <copumpkin> maybe inlinePerformIO will be better?
18:07:57 <mxweas> copumpkin: what's the co for?
18:08:03 <mornfall> Replacing the getFileStatus with something that produces an ADT improved the performance significantly.
18:08:05 <copumpkin> mxweas: it's my alternate nick
18:08:11 <mornfall> (Instead of mucking around with IO.)
18:08:11 <mxweas> nifty
18:08:49 <mornfall> copumpkin: What happens in the realWorld#?
18:08:55 <RyanT5000> so, the issues with unsafePerformIO's performance, i think, illustrates that it would be nice to have a library that abstracts these concerns
18:11:01 <mornfall> RyanT5000: What would you like for an interface?
18:11:08 <copumpkin> mornfall: it does absolutely nothing afair
18:11:56 <mornfall> copumpkin: Well, something definitely causes a C call in the RTS. I could see it on profiles (unfortunately, I have the callgrind output, but not the binaries anymore...)
18:13:20 <RyanT5000> i'm not sure; i was thinking about something like: (a -> ST s (ST s (), b)) -> a -> b
18:13:31 <copumpkin> :o
18:13:49 <shapr> Is there a haskell lib that can marshal iee754 directly?
18:13:49 <RyanT5000> in other words: a function that results in an ST action, whose result is an "undo" ST action and a result
18:14:17 <mornfall> RyanT5000: That's going to be expensive no matter what. IMO.
18:14:30 <mornfall> RyanT5000: While that may be useful, I don't expect to be useful for performance code.
18:14:36 <mornfall> +it
18:14:50 <idnar> copumpkin: what about the noduplicate?
18:15:06 <copumpkin> that is probably slow :P
18:15:06 <RyanT5000> mornfall: hm; surely it must be better than constantly duplicating something large, though, right?
18:15:11 <copumpkin> but inlinePerformIO should avoid that I think
18:15:33 <mornfall> RyanT5000: Hard to tell. Depends on how large.
18:15:36 <copumpkin> you don't want to duplicate a write to a socket, but duplicating a memory write isn't that bad
18:15:45 <RyanT5000> yeah
18:16:01 <RyanT5000> well, with DiffArray, it would be pretty bad if you had to duplicate a 40 MB array just to change one value
18:16:10 <mornfall> RyanT5000: Also, tree-ish (as opposed to array-ish) structures often don't need full rewrite.
18:16:13 <RyanT5000> of course, maybe that means you should be using monadic code :P
18:16:24 <RyanT5000> mornfall: right; usually just log(n) rewrite, right?
18:16:34 <mornfall> Yeah, I'd expect it so.
18:16:40 <mornfall> I guess Data.Map guarantees something like that, even.
18:17:13 <mornfall> Also, this only makes sense for code with roughly balanced updates and reads.
18:17:37 <RyanT5000> yeah
18:18:05 <idnar> @type inlinePerformIO
18:18:06 <lambdabot> Not in scope: `inlinePerformIO'
18:18:07 <mornfall> Which sounds fairly rare in functional setting to me.
18:18:24 <RyanT5000> yeah
18:19:05 <RyanT5000> so, in light of all of that, what kind of interface would you suggest for a fluid sim?
18:19:27 <RyanT5000> suppose you have this: particles falling towards or moving on a heightmap
18:19:35 <RyanT5000> so, the heightmap is a giant array
18:19:54 <RyanT5000> where each point is just the height at the corresponding point in space
18:20:20 <copumpkin> an STArray maybe?
18:20:26 <copumpkin> although you probably want to draw it too
18:20:32 <mornfall> The particles modify the respective heights, I presume?
18:20:33 <copumpkin> so just an IOArray or something?
18:20:56 <RyanT5000> mornfall: no, the particles don't modify the height; they just sit around on top of it
18:21:05 <mornfall> RyanT5000: What changes the height, then?
18:21:07 <RyanT5000> copumpkin: well, i'd like it if the interface were pure :(
18:21:13 <RyanT5000> mornfall: nothing does; it's just the ground
18:21:29 <mornfall> RyanT5000: So what are you trying to keep track of? The individual particle coordinates?
18:21:30 <RyanT5000> it's the particles that need to be updated every frame
18:21:32 <RyanT5000> yeah
18:21:35 <copumpkin> RyanT5000: so is the heighmap static?
18:21:42 <RyanT5000> yeah, heightmap is static; just an array
18:21:45 <mornfall> RyanT5000: What are the operations on particles?
18:22:07 <RyanT5000> hm... basically, you can spawn particles, destroy particles, exert external forces on them, and let them move around on their own
18:22:12 <RyanT5000> there's basically a massive "update" func
18:22:20 <RyanT5000> which steps all the particles forward a frame (or a sub-frame)
18:22:21 <mornfall> RyanT5000: Does the update handle all particles
18:22:22 <mornfall> ?
18:22:25 <mornfall> Right.
18:22:29 <copumpkin> RyanT5000: maybe a function that lives in ST that calls another function with its current state and asks that function for what to do next?
18:22:32 <mornfall> So you update the full list every frame anyway.
18:22:32 <RyanT5000> mornfall: yeah
18:22:36 <copumpkin> it unsafeFreezes the thing before calling its inner function
18:22:43 <RyanT5000> mornfall: yeah
18:22:44 <mornfall> Basically just a map.
18:22:55 <mornfall> Over a list (in some better representation than a consed list).
18:23:01 <RyanT5000> yeah; it probably needs to be stored in a quadtree for lookups later
18:23:05 <RyanT5000> oh yeah, i forgot about that
18:23:13 <RyanT5000> i need to be able to render it, and query for the "nearby particles"
18:23:56 <RyanT5000> so there's some positional lookup stuff, too
18:24:09 <mornfall> Well, it may still make sense to just tear the structure apart every frame and build it up again.
18:24:48 <mornfall> I guess that particle action is wholly determined by the previous frame, and not affected by other particles' actions between last and current frame.
18:25:30 <copumpkin> you're folding your state through input
18:25:38 <copumpkin> I guess
18:25:46 <mornfall> GC will probably scavenge the previous-to-last frame's data, so it'll basically end up flipping between two memory locations for the state array.
18:26:05 <mornfall> Which ain't so bad. Something you'd probably hand-code in imperative setting, too.
18:27:12 <mornfall> RyanT5000: How does your renderer work?
18:27:40 <RyanT5000> haha, it isn't built yet :P
18:28:04 <mornfall> For proximity queries, there are some data structures, although not sure how well they lend themselves to functional buildup.
18:28:20 <Zrs> If a function returns: Right t  how do I 'de-monad' it to get t alone, without using pattern matching?
18:28:28 <RyanT5000> mornfall: actually, i don't think they'll be too bad
18:28:55 <mornfall> RyanT5000: Well, ideally you'd build them in a single go, which sounds unlikely.
18:29:10 <RyanT5000> mornfall: well, there's going to be some locality
18:29:25 <mike-burns> Zrs: Maybe `either' is what you want.
18:29:27 <mike-burns> :t either
18:29:29 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
18:29:34 <RyanT5000> so we don't have to *totally* throw away all our information every frame
18:29:42 <mornfall> But if your playfield is big enough, you are in for some serious cache-thrashing either way.
18:29:52 <RyanT5000> hm
18:30:01 <mornfall> Functional or not.
18:30:01 <RyanT5000> might need to just make it imperative, then
18:30:15 <mornfall> I don't expect that to help significantly.
18:30:36 <RyanT5000> mornfall: well, then it doesn't really matter, does it :P
18:30:47 <mornfall> Yeah, I was just pointing that out. :)
18:31:27 <mornfall> How big are we talking, anyway?
18:31:38 <RyanT5000> mornfall: well, we're on the iPhone, so not *that* big
18:31:52 <mornfall> Fluid dynamics on iPhone? Interesting. :)
18:32:09 <RyanT5000> yeah :P
18:32:10 <RyanT5000> it's for a game
18:32:14 <RyanT5000> it doesn't have to be realistic
18:32:27 <mornfall> Anyway, is say a dozen bytes per particle a no-go?
18:32:38 <RyanT5000> hmm
18:32:43 <RyanT5000> probably not
18:32:49 <dibblego> is there a function to seq the spine of a list?
18:32:53 <RyanT5000> anyway, you've triggered Plug Time
18:32:58 <RyanT5000> in which i plug my company and its game
18:33:01 <RyanT5000> and ask people to work for me :)
18:33:10 <copumpkin> dibblego: length maybe?
18:33:11 <RyanT5000> i'm the president of iPwn Studios, which is the first Haskell-based game studio
18:33:16 <RyanT5000> (to my knowledge, anyhow)
18:33:28 <dibblego> copumpkin, I thought there would be a more specific function
18:33:28 <dsturnbull> what's going on with your website btw ryan?
18:33:28 <RyanT5000> we're writing a game for the iPhone, provisionally entitled BloodKnight
18:33:38 <copumpkin> dibblego: don't think there is
18:33:42 <mornfall> You could probably keep a small list of nearest neighbours for every particle to get those neighbours.
18:33:59 <RyanT5000> it's an action-rpg, and the fluid sim will replace the mana system that most games have
18:34:13 <RyanT5000> mornfall: yeah, that makes sense
18:34:16 <mornfall> That won't change often and will let you find reasonably close particles reasonably quickly.
18:34:17 <RyanT5000> dsturnbull: there's nothing there yet :(
18:34:22 <RyanT5000> dsturnbull: we're working on it :P
18:35:01 <mornfall> RyanT5000: I guess there ain't no opengl on the iPhone, duh?
18:35:18 <dsturnbull> OpenGL ES
18:35:19 <RyanT5000> mornfall: there is! OpenGL ES 1.1
18:35:24 <mornfall> Oh wow.
18:35:46 <Zrs> There's Haskell on the iphone?
18:35:59 <RyanT5000> Zrs: iPwn developed it in-house; we're working on getting it up on code.haskell.org
18:36:21 <Zrs> An interpreter or a compiler? o.O
18:36:28 <copumpkin> compiler
18:36:32 <Zrs> I thought, judging by the girth of GHC, that it's a pretty non-trivial task.
18:36:35 <mornfall> Hm, the iPwn name wasn't a joke. Hmh.
18:36:36 <RyanT5000> Zrs: a ghc-mod
18:36:48 <RyanT5000> mornfall: nope :)
18:37:02 <Zrs> Yeah, the name is pretty gnarly but good job on the compiler :D
18:37:02 <RyanT5000> mornfall: i'll admit it's a somewhat funny name, but i think it's memorable
18:37:10 <RyanT5000> Zrs: thanks :)
18:37:31 <mornfall> I'd expect the thing to use the C output of GHC and then invoke some crosscompiling powah on the result.
18:37:33 <RyanT5000> when we're rich and have money to burn on marketing consultancies, i'll have them make up a new name :P
18:37:45 <RyanT5000> mornfall: yeah, that's more-or-less what's going on
18:37:56 <RyanT5000> mornfall: we had to screw around with the RTS as well
18:38:03 <mornfall> RyanT5000: Unsurprisingly.
18:38:06 <RyanT5000> mornfall: yup
18:38:33 <RyanT5000> so, yeah; it's going to be BSD3 as soon as we manage to get the darcs set up and such
18:38:36 <Zrs> Huh. GHC can convert Haskell to C code?
18:38:50 <RyanT5000> Zrs: yup :)
18:38:58 <copumpkin> "c code"
18:39:12 <copumpkin> let's just say gcc accepts it and spits out asm :P
18:39:15 <mornfall> For some value of C. And some value of code, too.
18:39:38 <mornfall> copumpkin: And the asm sometimes even does what GHC expected it to do.
18:39:38 <RyanT5000> haha
18:40:17 <mornfall> There's still no cminusminus frontend in gcc (I guess there won't ever be, either?)
18:40:52 <dibblego> copumpkin, that didn't seem to work
18:41:11 <copumpkin> dibblego: hmm? it definitely needs to traverse the spine to determine the length of the list :/
18:41:29 <dibblego> copumpkin, yes, but I then need to evaluate the value returned from length
18:41:34 <copumpkin> yeah
18:41:45 <copumpkin> that's true of anything though
18:41:52 <dibblego> printing it works
18:41:55 <copumpkin> you could do length xs `seq` somethingIdefinitelyNeed
18:42:08 <dibblego> yeah I could
18:42:18 <pikhq> Well, I'd imagine that GHC on the iPhone wouldn't be *too* hard. At least, the ABI has something to do with something already implemented, and ARM is a rather well-known CPU...
18:42:19 <copumpkin> not particularly pretty though :)
18:42:36 <RyanT5000> pikhq: yeah, it wasn't terrible :)
18:44:16 <mornfall> RyanT5000: (You forgot to mention in your plug when you are hiring and for how much...)
18:44:47 <copumpkin> lol
18:44:54 <copumpkin> do you have a physical location, by the way?
18:45:02 <RyanT5000> we don't have a physical office yet
18:45:14 <RyanT5000> we started business about 4 weeks ago
18:45:25 <RyanT5000> and a lot of our people are overseas anyhow
18:45:37 <mornfall> Over which sea (and which direction)?
18:46:00 <RyanT5000> well, the guy who did most of the iPhone port is blackh from this chatroom
18:46:03 <RyanT5000> and he's  in NZ
18:46:23 <RyanT5000> me and the other co-founder are in Boston, MA
18:46:33 <RyanT5000> as is most of our art team
18:46:34 <mornfall> We have an office in Boston, supposedly.
18:46:40 <mornfall> Or somewhere.
18:46:40 <RyanT5000> who's "we"?
18:46:44 <mornfall> Red Hat.
18:46:47 <RyanT5000> ah, cool
18:46:52 <RyanT5000> i know a guy who worked at red hat
18:47:01 <RyanT5000> someone else from my year at law school
18:47:11 <mornfall> You have a law school?
18:47:37 <RyanT5000> i just graduated from law school
18:47:57 <mornfall> That's amazing.
18:48:29 <RyanT5000> mornfall: how come?
18:48:47 <dibblego> @type \b -> let k = foldl' (const . const $ ()) () in k b `seq` b
18:48:49 <lambdabot> forall b. [b] -> [b]
18:49:52 <mornfall> RyanT5000: I find it fascinating that people survive law school, and with functioning brain, too.
18:50:28 <RyanT5000> mornfall: haha; well, it certainly does change you :)
18:50:40 <mornfall> Well, I can't even grasp the concept. :)
18:50:46 <RyanT5000> mornfall: it's very interesting to spend 3 years arguing with people all the time :P
18:51:14 <mornfall> RyanT5000: Well, if that's all, then I see no difference to contributing to linux kernel, eg.
18:51:23 <RyanT5000> mornfall: lol
18:51:36 <RyanT5000> i bet that's not really *that* dissimilar
18:51:57 <pikhq> mornfall: Yeah, I heard Red Hat had an office there.
18:52:04 <copumpkin> RyanT5000: how old are you? you're pretty young aren't you?
18:52:14 <pikhq> (... at the Red Hat conference in the area last year...)
18:52:15 <bos> the difference between law school and linux kernel hacking is that if you're a successful hacker, you turn into an insider and your stuff gets in more easily. if you're a successful lawyer, you just get in more arguments and charge more.
18:52:16 <RyanT5000> yeah, i'm kinda young :P
18:52:25 <RyanT5000> i'm 22
18:52:29 <copumpkin> hah
18:52:39 <copumpkin> crazy :P
18:52:54 <mgsloan> haskell games? sounds fun ::)
18:52:57 <bos> of course, kernel hackers love to argue more than they love to code.
18:53:07 <RyanT5000> mgsloan: yep; and risky, lol
18:53:17 <mgsloan> true, true.  I suppose it's quite an investment?
18:53:39 <RyanT5000> mgsloan: yeah, definitely
18:53:41 <mornfall> mgsloan: Well, depends on how long you can pull it off on your iPhone and free time of curious #haskellers. ;)
18:54:07 <RyanT5000> mgsloan: it'll probably take most of my savings :P
18:54:17 <mornfall> Now, that's courage.
18:54:21 <mgsloan> :) well kudos for doing something awesome with it
18:54:25 <bos> 22 is a good age to take nutty risks.
18:54:30 <pikhq> RyanT5000: I wish you luck.
18:54:33 <RyanT5000> thanks :)
18:54:43 <mornfall> (More grimly, you'll probably need it.)
18:54:56 <RyanT5000> mornfall: yeah, i know i will :)
18:55:05 <pikhq> Don't know that from experience, but I'd certainly imagine so.
18:55:19 <mgsloan> thing that bugs me with iphone dev is the draconian appstore
18:55:29 <mornfall> Crap. Dusk.
18:55:33 <RyanT5000> mgsloan: yeah; there will be a lot of ass-kissing involved
18:55:41 <mornfall> I mean. Dawn.
18:55:44 <mornfall> I need to sleep.
18:55:46 <mornfall> Really.
18:55:51 <pikhq> Never.
18:55:51 <RyanT5000> mornfall: haha, i know how that is :)
18:55:52 <mike-burns> BloodKnight, as RyanT5000 explained it at the Boston Haskell meetup, sounds like a unique, fun game that people will buy if you market it right.
18:55:53 <pikhq> Sleep is highly overrated.
18:56:16 <RyanT5000> mike-burns: thanks! :) i'm glad someone else agrees
18:56:59 <mgsloan> are you significantly involving physics?  I think the future of these sort of games is 2d gameplay on 3d hardware, with awesome physics
18:57:01 <mgsloan> I dunno if any of you have seen Gish, but it's awesome
18:57:27 <mornfall> mike-burns: The only problem is that, that the same holds of a jumping rope sans the rope. : - |
18:57:35 <mornfall> -,
18:58:00 <mike-burns> mornfall: Are you commenting on how making money as a startup is almost entirely marketing?
18:58:01 <RyanT5000> mgsloan: the only physics we're planning on so far is the fluid sim
18:58:19 <RyanT5000> mgsloan: yeah, i played through all of Gish
18:58:19 <mornfall> mike-burns: s/as a startup/. : - P
18:58:25 <mike-burns> Fair enough.
18:58:26 <mornfall> s,/,//,
18:58:40 <mgsloan> ahh.  well some physics is better than none :)
18:58:45 <RyanT5000> i certainly agree that marketing is key
18:58:54 <mornfall> It's very unfortunate.
18:59:03 <mornfall> It correlates strongly with the sheep-nature of people.
18:59:18 <RyanT5000> mornfall: well, people can only base their decisions on their knowledge
18:59:19 <mike-burns> ... which correlates strongly with the high sales of the iPhone.
18:59:26 <mornfall> mike-burns: Bingo.
18:59:26 <mgsloan> whenever I've started working on haskell games, the first thing I run into is the fact we don't have any consistent, widely used 2d or 3d math lib
18:59:28 <RyanT5000> mornfall: so you have to make sure you convince them that you thing is worth having :)
18:59:39 <mgsloan> everyone reimplements a lightweight vector for their particular library
19:00:07 <RyanT5000> mgsloan: yeah; i can't imagine that will add *too* much to the total workload
19:00:14 <copumpkin> mgsloan: hmatrix?
19:00:23 <RyanT5000> mgsloan: the bulk of the time will probably end up being spent on polishing stuff anyhow
19:00:29 <mgsloan> ahh, well that's good
19:00:34 <mgsloan> that's the way to make a good game
19:00:40 <mornfall> RyanT5000: Spit and polish. Yeah.
19:00:46 <RyanT5000> mornfall: yep; Blizzard-style
19:00:48 <roconnor> @src drop
19:00:48 <lambdabot> drop n xs     | n <= 0 =  xs
19:00:49 <lambdabot> drop _ []              =  []
19:00:49 <lambdabot> drop n (_:xs)          =  drop (n-1) xs
19:00:51 <RyanT5000> keep going until it's good
19:00:55 <mike-burns> RyanT5000: I had meant to ask: what kinds of positions will you be looking for? QA? Art?
19:00:57 <RyanT5000> (not that we have their kind of bankroll :P)
19:01:00 <mornfall> Ah. Blizzard has done some really good stuff.
19:01:14 <mgsloan> copumpkin - well, I mean, does the opengl bindings use hmatrix?
19:01:14 <RyanT5000> mike-burns: well, we're primarily looking for programming and art right now
19:01:28 <copumpkin> mgsloan: not a clue, but you could :P
19:01:28 <RyanT5000> mike-burns: we'll ramp up QA once we have a bit of something to test
19:01:33 <dsturnbull> the drop implementation looks a bit like befunge
19:01:34 <mgsloan> true :)
19:01:41 <RyanT5000> mgsloan: no, they don't
19:02:04 <roconnor> ugh, drop 300000 gives me a stack overflow
19:02:14 <mgsloan> if I wasn't currently interning at adobe I'd be down for some game dev :)
19:02:25 <copumpkin> roconnor: on compiled code with -O ?
19:02:39 <roconnor> oh
19:02:41 <roconnor> hmm
19:03:17 <kniu> @src chainl
19:03:17 <lambdabot> Source not found. I am sorry.
19:03:25 <kniu> hurm.
19:04:01 <roconnor> copumpkin: my modules are compiled -O2
19:04:04 <roconnor> I'm using ghci
19:04:24 <dsturnbull> what are you dropping _from_?
19:05:06 <RyanT5000> mgsloan: well, if you want to do some part-time stuff, we'll probably have something we can carve off
19:05:12 <roconnor> dsturnbull: my list of steps in my simulation
19:05:29 <roconnor> so I grab the 300000th element
19:05:33 <roconnor> which depends on the previous
19:05:39 <roconnor> which depends on the previous
19:05:41 <roconnor> etc.
19:05:50 <copumpkin> you aren't going to write it 299999 times?
19:05:51 <copumpkin> :(
19:06:07 <roconnor> I need a strict drop :)
19:06:37 <dsturnbull> drop doesn't overflow for me
19:06:49 <dsturnbull> oh you said ghci?
19:06:55 <roconnor> yep
19:06:57 <copumpkin> roconnor: so you want to evaluate each thing before dropping it?
19:07:07 <roconnor> copumpkin: probably
19:07:13 <copumpkin> it's probably overflowing because of the huge thunk buildup
19:07:14 <roconnor> they need to be evaluated eventually
19:07:59 <Meady> hey guys
19:08:00 <copumpkin> so just copy that source and x `seq` it :P
19:08:42 <Meady> anyone know a site with haskell videos?
19:09:15 <tommd> youtube
19:09:24 <Meady> there is like 2 on there
19:09:24 <tommd> it did have some anyway
19:09:26 <tommd> ok
19:09:27 <copumpkin> there are a few on infoq
19:09:31 <copumpkin> http://www.infoq.com/presentations/Strongly-Typed-DSEL-Lennart-Augustsson
19:09:38 <Meady> nice
19:09:48 <Meady> tyvm
19:09:49 <tommd> Meady: http://www.haskell.org/haskellwiki/Video_presentations
19:09:51 <tommd> did you see that?
19:10:08 <roconnor> copumpkin: what do you mean copy that source?
19:10:21 <mike-burns> http://video.s-inf.de/#FP.2005-SS-Giesl.(COt).HD_Videoaufzeichnung - from earlier
19:10:27 <mike-burns> Meady: ^
19:10:28 <copumpkin> roconnor: copy the output of @src drop and write a drop' that seqs each element?
19:10:28 <Meady> wicked
19:10:46 <roconnor> @src drop
19:10:46 <lambdabot> drop n xs     | n <= 0 =  xs
19:10:46 <lambdabot> drop _ []              =  []
19:10:46 <lambdabot> drop n (_:xs)          =  drop (n-1) xs
19:11:52 <roconnor> hmm
19:11:55 <roconnor> let drop' n (x:xs) = n `seq` (length (show x)) `seq` drop (n-1) xs
19:11:58 <roconnor> that didn't help
19:12:26 <Meady> what should i use to stream flv's
19:12:34 <Meady> vlc do the job?
19:12:48 <Meady> guess ill just use web player
19:13:16 <copumpkin> roconnor: why not just rnf x `seq` drop (n - 1) xs ? I don't think you need to seq the n, since you're doing arithmetic on it?
19:13:35 <copumpkin> roconnor: or do you not have an NFData instance for your elements?
19:13:43 <roconnor> cause that would require me to know about rnf
19:14:00 <roconnor> I have no idea if I have NFData
19:14:00 <copumpkin> you can use Data.Derive to derive you an instance automagically in TH
19:14:04 <roconnor> it doesn't matter
19:14:11 <copumpkin> ok
19:14:12 <roconnor> lenght (show x) should be just as good
19:15:48 <copumpkin> roconnor: I guess... although length really just forces the spine of the list :P but I don't know how your show instance works :)
19:16:07 <copumpkin> I guess in most cases that's equivalent to forcing the whole thing
19:16:13 <roconnor> it's a basic tuple of doubles and stuff
19:16:18 <copumpkin> ah
19:16:25 <roconnor> oh wait
19:16:26 <roconnor> is it?
19:16:33 <roconnor> hmm
19:16:33 <copumpkin> beats me :P
19:16:36 <roconnor> oh yes it is
19:16:45 <copumpkin> hrm
19:17:09 <copumpkin> to be safer, you could do rnf (show x), since there's definitely NFData on strings
19:17:19 <copumpkin> but it's pretty unlikely that it'd make a difference
19:17:55 <copumpkin> do you have a subset of your code you could paste?
19:18:32 <roconnor> not really
19:18:47 <roconnor> I guess I should try to invent an easy example
19:19:03 <copumpkin> an iterate (+1) 0 should work as an easy example to test on
19:19:14 <copumpkin> > iterate (+1) 0
19:19:15 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
19:19:16 <roconnor> > drop 30000 (fix (\x -> 1:(map (+1) x)
19:19:18 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
19:19:26 <copumpkin> > drop 30000 $ iterate (+1) 0
19:19:28 <lambdabot>   [30000,30001,30002,30003,30004,30005,30006,30007,30008,30009,30010,30011,30...
19:19:32 <copumpkin> > drop 300000 $ iterate (+1) 0
19:19:34 <lambdabot>   [* Exception: stack overflow
19:19:38 <copumpkin> there we go
19:21:10 <Saizan> > let force [] = []; force (x:xs) = x `seq` x : force xs in drop 300000 . force $ iterate (+1) 0
19:21:12 <lambdabot>   [300000,300001,300002,300003,300004,300005,300006,300007,300008,300009,3000...
19:21:21 <copumpkin> > drop' 300000 $ iterate (+1) 0
19:21:24 <lambdabot>   [* Exception: stack overflow
19:21:28 <copumpkin> boo, mine fails :)
19:21:46 * copumpkin hides the dagger from Saizan
19:22:30 <copumpkin> I guess the force approach is nicer than making a new drop
19:22:36 <Saizan> > let force = foldr (\x xs -> x `seq` x : xs) [] in drop 300000 . force $ iterate (+1) 0
19:22:37 <lambdabot>   [300000,300001,300002,300003,300004,300005,300006,300007,300008,300009,3000...
19:22:48 <Saizan> that should fuse!
19:22:55 <copumpkin> :)
19:23:12 <lpsmith> Saizan++
19:23:16 * Saizan wears a chainmail to protect himself from the dagger
19:23:18 <copumpkin> Saizan++
19:23:21 <copumpkin> hah
19:23:28 <copumpkin> chainmail is heavy! I've tried it on
19:24:11 <Saizan> hah, i wonder if it's heavier than kevlar or not
19:24:19 <copumpkin> I'm sure it is :P
19:24:22 <roconnor> Saizan: that's pretty nice
19:24:28 <Meady> 1.3mb/s sure seems slow with 500mb files
19:24:44 <lpsmith> I had  a friend that had his own shirt of chainmail.    He wore it around some for exercise :-P
19:25:09 <mmorrow_> , drop 3000000 $ iterate (+1) 0
19:25:12 <lunabot>  Stack space overflow: current size 8388608 bytes.
19:25:12 <lunabot>  Use `+RTS -Ksize' to increase it.
19:25:16 <mmorrow_> , let iterate' f a = let !b = f a in b : iterate' f b in drop 3000000 $ iterate' (+1) 0
19:25:20 <lunabot>  [3000001,3000002,3000003,3000004,3000005,3000006,3000007,3000008,3000009,...
19:25:42 <copumpkin> big droppage there
19:26:03 <Saizan> roconnor: if you've tuples seq won't be enough though unless you build them like x `seq` y `seq` (x,y)
19:26:17 <mmorrow_> bang patterns work like a charm for tuples
19:26:33 <mmorrow_> (wrt compactness of notation)
19:26:34 <copumpkin> I tried a bang pattern on lambdabot but it didn't like them
19:27:11 <mmorrow_> someone should turn those on, having to write out `seq` is tedious
19:27:15 * roconnor mumbles about the monomorphism restriction
19:27:28 <lpsmith> roconnor:  why?  :-)
19:27:51 <roconnor> lpsmith: because force has type [()] -> [()] in ghci
19:28:08 <mmorrow_> make it @unpl'ed
19:28:30 <lpsmith> heh,  yeah.   Monomorphism can be obnoxious.
19:28:45 <mmorrow> yeah, especially in ghci
19:28:50 <copumpkin> I think they decided to turn it off in haskell'
19:29:04 <Saizan> mh
19:29:08 <lpsmith> I find monomorphism restriction useful in ghci,  moreso than the languages
19:29:12 <roconnor> I should turn it off in ghci
19:29:25 <lpsmith> 'cause I often use ghci as a glorified calculator
19:29:32 <mmorrow> the annoying bit in ghci with it is you have to give everything fully pointful defs
19:29:51 <mmorrow> just so it won't default to ()
19:29:51 <lpsmith> And polymorphism is often cumbersome if you want to keep computations around for later
19:29:56 <Saizan> lpsmith: that's defaulting, not MR, no?
19:29:58 <Cale> I turn it off in ghci, and then it bites me when I go to compile my code ;)
19:30:06 <Saizan> lpsmith: ah, true
19:30:19 <Cale> (but at least then I know that it's the MR :)
19:30:26 <mmorrow> Cale: yeah, that's why i hesitate to turn it off in ghci
19:31:04 <Cale> If something compiles in ghci and not by ghc, then at that point I can usually assume that I have to turn the MR off.
19:31:17 <lpsmith> But yeah, I never really want MR on in the source file
19:31:35 <lpsmith> but the command line is a tossup.  I try not to write many definitions on the command line,  and instead use :r a lot
19:31:38 <Cale> Yeah, neither do I, but I'm not sure that's doable in general...
19:31:44 <Cale> it would be nice if there was a .ghc ;)
19:32:04 <lpsmith> {-# OPTIONS_GHC  ;-) #-}
19:32:07 <Cale> (of course, that would create code portability issues)
19:32:08 <Cale> yeah
19:32:13 <lpsmith> much better than a .ghc file
19:32:13 <Cale> {-# LANGUAGE ... #-}
19:32:20 <lpsmith> even better
19:32:30 <mmorrow> alias ghc='ghc -XNo..'
19:32:33 <Cale> But NoMonomorphismRestriction is such an annoyance to type in every file
19:32:41 <mmorrow> yeah, so are bangpatterns
19:32:53 <lpsmith> yesish
19:33:01 <Cale> They could have at least shortened it to NoMR
19:33:04 <mmorrow> NoMonomkowoijdjwoiepokpodkwpokodos, ThatThisSomethingElseOhHai, ....
19:33:14 <drhodes> define macro NoMR
19:33:25 <lpsmith> Decent tool support can alleviate that
19:33:40 <lpsmith> It's the best approach for code for public consumption,  methinks
19:33:48 <mmorrow> on this topic, System.Directory names are keyboard crushers as well
19:33:53 <lpsmith> heh
19:33:59 <copumpkin> I like how most LANGUAGE types aren't abbreviated
19:34:03 <copumpkin> but you have EmptyDataDecls
19:34:10 <copumpkin> really feels consistent :P
19:34:29 <mmorrow> pwd = getTheCurrentDirectoryAndReturnIt -- i've typed this line 4 too many times
19:34:39 <Saizan> EmptyDataDecls is sooo common too.
19:34:46 <Cale> mmorrow: haha
19:35:12 <copumpkin> Saizan: you mocking me now? :P
19:35:36 <lpsmith> I'm not advocating for heavyweight verbiage,   just that LANGUAGE and OPTIONS_GHC are better approaches than aliases and the like.
19:35:37 <Saizan> copumpkin: no, more like the choice of shortening it :)
19:35:44 <Cale> I think we should start randomly prefixing names in the libraries with 'enterprise'
19:35:51 <copumpkin> lol
19:35:56 <lpsmith> I tend to put trivial bash scripts in my ~/bin before aliases anyway
19:36:05 <copumpkin> http://www.rubyenterpriseedition.com/
19:36:05 <Cale> enterpriseGetTheCurrentDirectoryAndReturnItNow
19:36:55 <nooga> copumpkin: O_o
19:37:00 <Cale> Also, the 'do' keyword is too short. We should change it to 'implementation phase'
19:37:20 * mmorrow wonders what mdo becomes
19:37:59 <copumpkin> oh that one is serious
19:38:03 <copumpkin> what I meant was: http://github.com/tenderlove/enterprise/tree/master
19:38:11 <copumpkin> check out the readme :)
19:40:22 <Cale> "This gem will cost you eleventy billion dollars payable to me, now."
19:40:46 <copumpkin> having someone to pay is often a requirement for many enterprises :P
19:44:49 <lpsmith> That would be eleventy billion dollars.... traditional british billions that is ;-)
19:45:09 <Cale> http://imgur.com/gDQr3.jpg -- haha
19:48:55 <Meady> myCheckzero :: Int -> Bool
19:48:55 <Meady> myCheckzero val =
19:48:55 <Meady> 	if val > 0
19:48:55 <Meady> 		then True
19:48:55 <Meady> 		else False
19:48:59 <Meady> Its aliveee!
19:49:00 <Meady> lol
19:50:43 <Apocalisp> So... comonoids huh?
19:50:51 <Meady> lol?
19:51:14 <Cale> Meady: myCheckzero val = val > 0
19:51:20 <monochrom> What Cale says.
19:51:26 <mmorrow> = (> 0)
19:51:27 <Meady> Ahh i see
19:51:34 <Meady> didnt realise it would automatically return
19:51:35 <Cale> Or yeah, you could use an operator section
19:51:37 <Cale> (> 0)
19:51:59 <Cale> > (> 0) 5
19:52:01 <lambdabot>   True
19:52:04 <Cale> > (> 0) (-12)
19:52:06 <lambdabot>   False
19:53:09 <Zrs> Do you end up regretting being that brief when you come back to your code a month later?
19:53:18 <Meady> myStringcheck :: String -> Bool
19:53:18 <Meady> myStringcheck str = str == "black"
19:53:19 <copumpkin> what's a comonoid?
19:53:27 <copumpkin> Dual (Endo ?
19:53:32 <copumpkin> or just Dual I guess
19:53:37 <Meady> Ok guys give me something simple to make
19:53:38 <Meady> just to test
19:53:44 <Meady> then ill write and you show me better way lol
19:54:17 <Meady> anyone?
19:54:44 <copumpkin> Meady: write a run-length encoder for a list... if I give it [1,1,1,3,3,2,6,] it should return [(3, 1), (2, 3), (1, 2), (1, 6)]
19:54:59 <copumpkin> so Eq a => [a] -> [(Int, a)]
19:55:19 <Meady> ok let me have a crack at it
19:55:30 <copumpkin> and then write a decoder for it
19:55:32 <monochrom> If I write "if ... then True else False" in code, one month later I will regret being that dumb.
19:55:59 <Zrs> lol
19:56:08 <pikhq> Better than
19:56:18 <pikhq> Better than "if ... then False else True".
19:56:27 <monochrom> Heh
19:56:28 <mmorrow> flip then !
19:56:40 <copumpkin> or if (... == True) == True then True else False
19:56:46 <Cale> if not (...) then False else True
19:57:18 <monochrom> It is not about length. It is about having internalized logic vs faking an understanding of logic.
19:57:53 <mmorrow> @pl flip (flip then else) False True
19:57:54 <lambdabot> (line 1, column 12):
19:57:54 <lambdabot> unexpected reserved word "then"
19:57:54 <lambdabot> expecting variable, "(", operator or ")"
19:57:55 <pikhq> if not . not . not . not . not (...) then False else True
19:58:16 <lpsmith> nice problem copumpkin,   I can think of two approaches,  one that isn't as elegant but probably slightly faster.
19:58:27 <shachaf> monochrom: Sometimes redundancies like that make perfect sense when you write them -- they're just a cumbersome way of thinking of things.
19:58:46 <monochrom> Yes. The first thought is barely a lucid thought.
19:59:15 <monochrom> The first thought usually over-complicates, errs, and misses the point.
19:59:28 <copumpkin> lpsmith: I picked it because I fit both the encoder and decoder into a tweet with a title too :P it can be pretty golfed
19:59:40 <monochrom> There is a school of programmers who think code should record their stream of consciousness faithfully.
19:59:44 <lpsmith> nice ;-)
20:00:04 <monochrom> And you know how streams of consciousness are actually incoherent and just wrong.
20:00:05 <copumpkin> lpsmith: but I didn't really consider speed :)
20:00:15 <kniu> parsec uses chainl1 to handle all left recursive grammars, aye?
20:00:24 <Meady> copumpkin, can i use myIntcount :: [int] -> ([int],[int]) then yeh?
20:00:34 <copumpkin> hm?
20:00:38 <Meady> for what you've asked
20:00:47 <kniu> what if the operator I supply to it doesn't take two elements of the same type, though?
20:00:51 <Meady> single list to a multi dimensional list
20:00:54 <shachaf> monochrom: Is there a real difference between turning "if ... then True else False" into "..." and seeing that something makes sense to, say, look at as a monad?
20:01:00 <copumpkin> Meady: why do you need that?
20:01:10 <Meady> to output the list you wanted
20:01:23 <lispy> if ... then True else False == ...
20:01:28 <monochrom> Probably not.
20:01:38 <lispy> (I probably didn't get the question)
20:01:57 <Meady> [(1,1),(1,1)] isnt that [(int,int)]
20:01:58 <Meady> hm
20:02:00 <Saizan> kniu: there's generally a way to refactor your grammar to not need left recursion
20:02:18 <copumpkin> Meady: the type I want is actually Eq a => [a] -> [(Int, a)]
20:02:19 <shachaf> In either case you see after the fact that there is a simpler way to look at the code, but that doesn't make the first way "faking an understanding", I think.
20:02:37 <lpsmith> meady:  you could use that type to start,  but you might find the [(Int,Int)] is more direct
20:02:51 <copumpkin> :t unzip
20:02:53 <lambdabot> forall a b. [(a, b)] -> ([a], [b])
20:03:02 <lpsmith> :t zip
20:03:04 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
20:03:07 <copumpkin> :t uncurry zip
20:03:09 <lambdabot> forall a b. ([a], [b]) -> [(a, b)]
20:04:00 <monochrom> It does. At least, you understand more after, than you understood before.
20:04:18 <kniu> Saizan, I know there is, but that might be a lot of effort, where using some functions might ease the work.
20:04:21 <Meady> hmm copumpkin im kinda stuck
20:04:32 <Meady> how do i go through each element
20:04:33 <copumpkin> Meady: a handy function might be group
20:04:37 <copumpkin> :)
20:04:40 <Meady> ok ill have a look
20:04:43 <lispy> :t map
20:04:44 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
20:04:45 <Saizan> kniu: yeah, i guess :)
20:04:55 <copumpkin> :t group
20:04:57 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
20:05:02 <kniu> thing is, that second argument to chainl1 is kind of restrictive to me.
20:05:09 <kniu> say I got a production:
20:05:22 <kniu> X ::= X ':' Y
20:05:48 <Meady> ok copumpkin can we strart with something simpler
20:05:49 <kniu> how would I apply chainl or chainr to solve that?
20:06:08 <copumpkin> Meady: I can walk you through it a little if you want
20:06:16 <Meady> Ok sure
20:06:21 <Zrs> copumpkin that's a pretty fun problem you proposed :D
20:06:21 <copumpkin> > group [1,1,1,3,3,2,6]
20:06:23 <lambdabot>   [[1,1,1],[3,3],[2],[6]]
20:06:30 <copumpkin> Zrs: :)
20:06:38 <copumpkin> Meady: you see what that's doing?
20:06:43 <kniu> uh, X ::= X ':' Y | '*'
20:06:45 <Zrs> oh what, 'group' does THAT? Bah I was mucking about with span
20:06:57 <Meady> Yeah i do its putting them into their own list inside a list
20:07:09 <copumpkin> yeah, consecutive runs of equal elements
20:07:12 <copumpkin> which is what the problem needs!
20:07:22 <lispy> > group [1,1,2,1,3,4]
20:07:22 <copumpkin> so what do you want to do to each run now?
20:07:23 <lambdabot>   [[1,1],[2],[1],[3],[4]]
20:07:26 <shapr> @seen ddarius
20:07:27 <lambdabot> I saw ddarius leaving #haskell, #haskell-blah and #haskell-overflow 5m 12d 21h 37m 6s ago, and .
20:07:34 <copumpkin> shapr: do you know where he went? I miss him
20:07:36 <Meady> but how would i count the number of consecutive elements per list
20:07:42 <shapr> copumpkin: I assume he's doing military stuff.
20:07:47 <copumpkin> Meady: how do you count the number of elements in a list in general?
20:08:12 <Meady> go through each one and add to counter
20:08:14 <copumpkin> shapr: aw
20:08:29 <copumpkin> Meady: there's a built-in function for that... can you think of its type? if you can, then you can @hoogle it
20:08:32 <Meady> so we would say [1,1,1] for each element +1 to count
20:08:47 <Zrs> My take on run length encoding, if someone can suggest how I can do better: http://paste.pocoo.org/show/125666/
20:08:47 <SubStack> > map length $ group [1,1,2,1,3,4]
20:08:48 <lambdabot>   [2,1,1,1,1]
20:09:10 <mmorrow> , fst . last $ readP_to_S (chainl (munch isDigit) (char ':' >> return (\a b -> "("++a++":"++b++")")) "0") "1:2:3:4:5"
20:09:12 <lunabot>  "((((1:2):3):4):5)"
20:09:24 <mmorrow> (with ReadP)
20:09:27 <copumpkin> Meady: that's true :) I tend to avoid explicit recursion if I can, but that might make it clearer to you
20:09:56 <shachaf> > (map (length &&& head) . group) $ [1,1,2,1,3,4]
20:09:57 <lambdabot>   [(2,1),(1,2),(1,1),(1,3),(1,4)]
20:10:25 <Zrs> zip (map length $ group [1,1,2,1,3]) (map head $ group [1,1,2,1,3])
20:10:26 <copumpkin> shachaf: that's the one I had :)
20:10:40 <copumpkin> minus the extra parentheses, that is
20:10:47 <Meady> could you first explain Eq a => [a] -> [[a]] might help abit
20:10:58 <Meady> tahes in a, puts a into a list, and then puts at inside a list of a list
20:11:05 <Meady> takes*
20:11:13 <copumpkin> Meady: ignoring the Eq for a moment, that's saying that it takes a list of a given type, and produces a list of lists of that type
20:11:31 <Meady> ok that makes sense
20:11:40 <copumpkin> the Eq a happens because you can't ask for == on all types
20:11:49 <Meady> ok that doesnt
20:11:51 <copumpkin> and since group needs to check equality on successive elements
20:12:06 <Meady> ok i dont get that atall
20:12:21 <copumpkin> Meady: well group is checking each element of the list to see if it's equal to the previous element
20:12:29 <copumpkin> so it needs to use ==
20:12:34 <Meady> ok that makes sense
20:12:56 <copumpkin> and the Eq typeclass provides (==)
20:13:04 <Meady> lost again
20:13:12 <Meady> Sorry im really trying to grasp it
20:14:39 <copumpkin> a typeclass is just a statement saying "I satisfy certain requirements"
20:14:43 <SubStack> Meady: you've probably already grasped it enough to write programs
20:14:55 <SubStack> going back later and filling in the gaps is the way I like to learn
20:14:58 <copumpkin> in this case, Eq is a statement saying "I know how to run (==)"
20:15:18 <Meady> isnt a typeclass functions that can be ran on a type?
20:15:26 <Meady> Num is a typeclass of int?
20:15:32 <copumpkin> @src Num
20:15:32 <lambdabot> class  (Eq a, Show a) => Num a  where
20:15:32 <lambdabot>     (+), (-), (*)           :: a -> a -> a
20:15:32 <lambdabot>     negate, abs, signum     :: a -> a
20:15:32 <lambdabot>     fromInteger             :: Integer -> a
20:15:50 <copumpkin> anything that is an instance of Num needs to provide those methods
20:15:59 <Meady> hmm
20:16:00 <monochrom> I guess you can say that. But it doesn't seem to help you.
20:16:09 <monochrom> Stop saying. Start doing.
20:16:16 <Zrs> Hhahah, this language is awesome. The solution shachaf posted melts my brain.
20:16:19 <SubStack> monochrom: indeed!
20:16:21 <Meady> cant do it if i dont get it
20:16:30 * SubStack learned all about monads by playing with hopengl
20:16:37 <Meady> I can however jog on if you like
20:16:40 <monochrom> can't get it if you don't get it
20:16:45 <monochrom> err
20:16:49 <monochrom> can't get it if you don't do it
20:16:51 <copumpkin> :)
20:16:51 <shachaf> Zrs: (&&&) is just (a -> b) -> (a -> c) -> a -> (b,c)
20:17:14 <copumpkin> Zrs: don't look at its real type, it's just distracting :P
20:17:21 <Meady> and so it starts :D
20:17:26 <shachaf> (This is not the most efficient solution, though.)
20:17:31 <shachaf> If you care about that sort of thing. :-)
20:17:43 <copumpkin> shachaf: unless your measurement of efficiency is programmer keypresses :P
20:17:51 <SubStack> Zrs: http://en.wikibooks.org/wiki/Haskell/Understanding_arrows is a good read, the first party anyways
20:18:02 <SubStack> robots! factories! Lots to like.
20:18:07 <copumpkin> I wouldn't go there yet if you're just starting :P
20:18:09 <Zrs> Oh. Woah. So it takes two functions, and you curry it so you get a function that takes a and puts it into... That's messed up.
20:18:16 <Zrs> Who thought this thing up?!
20:18:27 <copumpkin> Zrs: yeah :P there's another handy one called (***)
20:18:33 <SubStack> s/party/part/
20:18:40 <copumpkin> > ((+1) (***) (*5)) (5, 6)
20:18:42 <lambdabot>   Couldn't match expected type `b' -> c''
20:18:43 <Meady> im just thinking lol i should get length of each list inside the list and then * it
20:18:48 <copumpkin> whoops :P
20:18:48 <shachaf> SubStack: Is it? If it's anything like the Wikibooks discussion on monads (space suits, right?) I'd be suspicious of it.
20:18:59 <copumpkin> > ((+1) * (*5)) (5, 6)
20:19:00 <lambdabot>   <no location info>: lexical error at character '\SI'
20:19:20 <copumpkin> dammit, what did my client send there? it happens to me all the time now
20:19:35 <SubStack> shachaf: I think the pictures are pretty well done at least
20:19:48 <SubStack> I haven't read the wikibooks on monads
20:20:36 <Zrs> What bugs me is I hoogled &&&, and the 'documentation' there just confused me. Reading the raw type signature is what made me understand it. Heh. Crazy language.
20:20:48 <copumpkin> :t (&&&)
20:20:50 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
20:20:51 <copumpkin> that helped you? :P
20:21:09 <copumpkin> :t (&&&) :: (a -> b) -> (a -> c) -> a -> (b,c)
20:21:11 <lambdabot> forall a b c. (a -> b) -> (a -> c) -> a -> (b, c)
20:21:31 <Zrs> Blarg, what? Oh, durr, shachaf wrote that not lambdabot.
20:21:38 <shachaf> Lying to people about types is the point of this channel. :-)
20:21:44 <Meady> copumpkin does it need to be recursive?
20:21:46 <Tsion> What's the default instance of Arrow? I mean, what type would it be using when you do something like (+1) &&& (*8) $ 3 ?
20:21:51 <Tsion> I don't really get how it does that
20:21:54 <copumpkin> Tsion: (->)
20:21:55 <monochrom> Woah?! Lying about types? Heresy! Blasphemy!
20:22:01 <shachaf> There is no "default".
20:22:03 <copumpkin> Zrs: that's what I meant about staying away from the arrows stuff :)
20:22:06 <Meady> func (func[int])?
20:22:11 <shachaf> (+1) is the (->) Arrow already.
20:22:21 <shachaf> @instances Arrow
20:22:21 <lambdabot> (->), Kleisli m
20:22:29 <copumpkin> Meady: it does need to be, but you don't need to write your own recursion
20:22:34 <monochrom> There is no default and there is no first cause. Some people are uncomfortable with that.
20:22:48 <Tsion> first cause?
20:22:51 <Meady> ok copumpkin, sortof lost where to go now then if i dont know the functions name
20:23:14 <copumpkin> Meady: @hoogle can be helpful if you can imagine the type of the function you'd like
20:23:21 <Zrs> copumpkin, it seems pretty handy thogh. I guess in a b c a is a function that takes two parameters... I'm not sure how it manages to have a type signature totally atypical to what I've seen so far :p
20:23:42 <shachaf> Zrs: Arrow abstracts (->).
20:23:45 <copumpkin> Zrs: well, in the type I coerced it to, a = (->)
20:23:48 <mmorrow> > let rle = list [] (fix (\k n a -> list [] (\x xs -> if a==x then k (n+1) a xs else (a,n) : k 1 x xs)) 1) in rle [1,1,2,1,3,4]
20:23:50 <lambdabot>   [(1,2),(2,1),(1,1),(3,1)]
20:24:09 <SamB> monads are like space suits: don't use them, and you can try to breathe hard vacuum ;-P
20:24:09 <shachaf> One instance is (->), so a b c becomes (->) b c = b -> c
20:24:14 <mmorrow>  @let list n _ [] = n; list _ c (x:xs) = c x xs
20:24:21 <monochrom> hahaha SamB
20:24:34 <Meady> ok i have no clue
20:24:34 <Meady> :S
20:24:35 <Elly> SamB: Monads are like space suits: Without them, walking is a lot more fun?
20:24:57 <SamB> well, I mean, if you want to do IO without them, you'll end up killing yourself
20:25:20 <SamB> (likewise, you are lost without the MMU ;-P)
20:25:28 <Meady> its just e1 => e2, i have no idea what it means
20:25:37 <Meady> e1 is equal to or more than e2 ?
20:25:38 <Meady> lol
20:26:05 <monochrom> monads are like space suits: they are built by composing layers
20:26:14 <mmorrow> > runState (do (m,n) <- get; set (n,m+n); return m) (0,1)
20:26:16 <lambdabot>   Not in scope: `set'
20:26:21 <mmorrow> > runState (do (m,n) <- get; put (n,m+n); return m) (0,1)
20:26:23 <lambdabot>   (0,(1,1))
20:26:23 <copumpkin> brb
20:26:35 <mmorrow> > runState (replicateM (do (m,n) <- get; put (n,m+n); return m)) (0,1)
20:26:37 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
20:26:37 <monochrom> monads are like space suits: all advanced civilizations must learn and build them
20:26:40 <mmorrow> > runState (replicateM 10 (do (m,n) <- get; put (n,m+n); return m)) (0,1)
20:26:42 <lambdabot>   ([0,1,1,2,3,5,8,13,21,34],(55,89))
20:26:49 <Meady> well to find out many values are in an list wouldnt it be [int] -> int
20:27:18 <monochrom> monads are like space suits: they work
20:27:30 <Zrs> Out of curiosity - if I learn enough haskell, will I be able to write software faster and better than in other languages?
20:27:38 <Tsion> Meady: [a] -> Int
20:27:43 <monochrom> Yes I think so.
20:27:44 <Meady> why a?
20:27:50 <Axman6> monochrom: until you start playing with needles
20:27:52 <Nafai> Zrs: Many people think so
20:27:54 <Tsion> Meady: because you can count the length of any list, not just a list of ints
20:28:11 <Meady> yeah but in my case its integers, so 'a' means any type?
20:28:15 <Tsion> yep
20:28:23 <shachaf> "Have Monad, Will Travel"
20:28:34 <Meady> so im looking for length
20:28:41 <Meady> in my case right?
20:28:46 <Tsion> Meady: Well, it could be any letter (or a word)
20:28:52 <Tsion> it's just a type variable
20:28:55 <Meady> yeah
20:29:13 <Meady> im trying to cound the number of 1's in say [1,1,1], so it would be length ide use
20:29:32 <Nafai> Are there any good emacs stats packages
20:29:38 <monochrom> [a]->Int means it's happy to accept your [Int] or [Bool] or ...
20:29:43 <Meady> yeah
20:30:08 <Meady> Eq a => [a] -> [(Int, a)]
20:30:08 <Meady> i understand past the first >, but what does the => mean
20:30:13 <Axman6> or [[[Either [a] [[b]]]]]!
20:30:19 <Tsion> Meady: length will just count all the elements of the list. if you want to count only the elements that == a certain thing, it will be a bit more complex (but still pretty easy)
20:30:55 <monochrom> => doesn't mean anything alone. delimiter.
20:31:04 <Tsion> Meady: Eq a => just means that in the following type, a can be any type that is an instance of the Eq typeclass
20:31:25 <monochrom> The "Eq a" before that means you're using == somewhere.
20:31:39 <Meady> ok
20:32:18 <Axman6> @src Eq
20:32:19 <lambdabot> class  Eq a  where
20:32:19 <lambdabot>     (==), (/=)   :: a -> a -> Bool
20:32:30 <monochrom> Not all types support ==. Those who do are called "they're instances of Eq".
20:32:36 <Meady> hah
20:33:13 <monochrom> This is our story for operator overloading as well as "some types support these operators/functions but others don't"
20:35:37 <copumpkin> > uncurry (++) . ((++ " am") *** (++ " ***")) $ ("I", "testing")
20:35:38 <lambdabot>   "I amtesting ***"
20:35:39 <copumpkin> hrm
20:35:46 <copumpkin> yay
20:35:56 <copumpkin> my client stopped messing up my ***
20:36:25 <monochrom> Your client did mess previously?
20:37:04 <copumpkin> yeah, it was taking *x* and _x_ as being signs of emphasis, and boldifying the former and underlining the latter
20:37:13 <monochrom> Hahahaha
20:37:21 <copumpkin> really annoying in haskell :P
20:37:34 <copumpkin> and somehow it did something weird to outgoing *** too
20:38:14 <monochrom> It's unbelievable how 20-year-old ASCII Usenet conventions refuse to die.
20:39:42 <shapr> Is there a haskell lib that can parse and write iee754 directly?
20:39:56 <copumpkin> someone was talking about having written one the other day
20:40:02 <shapr> Data.Binary writes out the mantissa, sign and exponent bits separately, yeah?
20:40:13 <shapr> copumpkin: Any idea what?
20:40:16 <copumpkin> he offered it to roconnor iirc, but roconnor used unsafeCoerce
20:40:20 <copumpkin> I don't think it was released
20:40:26 <shapr> hiya darius__
20:40:27 <copumpkin> they're calling it significand these days
20:40:28 <Pseudonym> Has anyone proposed to Haskell' that we standardise on IEEE-754?
20:40:32 <copumpkin> it's ddarius!!
20:40:32 <darius__> hiya
20:40:36 <Pseudonym> I don't think that H98 does.
20:40:44 <shapr> copumpkin: No, it's Darius Bacon, the famous programmer.
20:40:52 <copumpkin> oh :)
20:40:57 <darius__> nope, not the real darius :)
20:40:59 <copumpkin> I read one too many ds :P
20:41:03 <copumpkin> darius__: it's darius!!!
20:41:09 <darius__> right
20:41:09 <copumpkin> :)
20:41:10 <monochrom> Right, Haskell98 has "isIEEE?????" and it could be false.
20:41:18 <shapr> Yes, author of many nifty tools and toys, especially EVOART!
20:41:20 <copumpkin> (sorry about that)
20:41:30 <SamB_XP_> shapr: you mean the one they keep claiming shakespear ripped code off of?
20:41:40 <shapr> er?
20:41:41 <darius__> heh
20:42:08 <Pseudonym> SamB: But he hid secrets in the whitespace.
20:42:11 <Pseudonym> Which proves it.
20:47:12 <desp> How can I access +infinity of type Double?
20:47:29 <Axman6> > 1/0 :: Double
20:47:31 <lambdabot>   Infinity
20:47:40 <Axman6> > (-1)/0 :: Double
20:47:41 <lambdabot>   -Infinity
20:47:43 <desp> Thanks.
20:48:26 <mmorrow> , 0/0
20:48:28 <lunabot>  NaN
20:48:47 <Meady> right ok, so copumpkin ide use group and then length
20:48:52 <Meady> now how would i combine them
20:48:57 <mmorrow> (.)
20:49:05 <mmorrow> (not literally)
20:49:07 <copumpkin> well, you want to ask for length of each group
20:49:22 <Meady> Ok so ide feed the result of group to another function?
20:49:30 <mmorrow> exactly
20:49:46 <mmorrow> > map (*2) [0..]
20:49:47 <lambdabot>   [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,5...
20:49:49 <mmorrow> > fmap (*2) [0..]
20:49:51 <lambdabot>   [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,5...
20:50:01 <mmorrow> > fmap (*2) (Just 2)
20:50:02 <lambdabot>   Just 4
20:50:05 <mmorrow> > map (*2) (Just 2)
20:50:06 <lambdabot>   Couldn't match expected type `[a]'
20:50:20 <mmorrow> > fmap length (Just [0..4])
20:50:22 <lambdabot>   Just 5
20:54:36 * Saizan wonders if we can implement MetaML with QQs
20:55:05 <shachaf> @let map = fmap
20:55:06 <lambdabot>  Defined.
20:55:15 <shachaf> > map (*2) (Just 5)
20:55:16 <lambdabot>   Ambiguous occurrence `map'
20:55:16 <lambdabot>  It could refer to either `GHC.Base.map', import...
20:55:17 <shachaf> Bah.
20:55:21 <shachaf> @undefine
20:55:34 <mmorrow> Saizan: ooh, try it
20:55:41 <Meady> ok guys so say i said myIntcount li = group li, how would i then use that
20:55:43 * mmorrow doesn't know what MetaML is though
20:56:49 <mmorrow> > (fmap (splitAt 1) . group) [1,1,2,3,2,2,3,2]
20:56:51 <lambdabot>   [([1],[1]),([2],[]),([3],[]),([2],[2]),([3],[]),([2],[])]
20:57:08 <copumpkin> lol
20:57:46 <copumpkin> sounds meta :)
20:59:50 <mmorrow> tastes meta too
21:00:16 * mmorrow had no idea what that's supposed to mean
21:00:20 <mmorrow> has
21:00:40 <copumpkin> just being stupid :P
21:01:26 <Saizan> well, i guess it does what TH does, but with a decent syntax
21:02:01 <Saizan> and higher order patterns to represent scoping
21:02:39 <mmorrow> Saizan: ahhh yeah, is MetaML the thing with ~ and multiple levels of quotes?
21:02:43 <Zrs> Real world Haskell is a great book, I just wish it had a lot more exercises :\
21:03:12 <mmorrow> i think i was reading about it in relation to TH/related, either in something of oleg's or some paper
21:03:26 <Saizan> mmorrow: yeah, < > to quite and ~ to escape
21:03:31 <mmorrow> ah yeah, exactly
21:04:17 <Saizan> oleg wrote about CSE-ing the generated code via a monad
21:06:11 <Meady> @src fmap
21:06:12 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
21:06:23 <mmorrow> @src Functor
21:06:24 <lambdabot> class  Functor f  where
21:06:24 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
21:06:33 <Meady> ah ty
21:06:45 <Meady> Hmm
21:06:50 <Saizan> you can stick with map for now
21:06:57 <mmorrow> @type [fmap,(<$>),liftM]
21:06:58 <lambdabot> forall a b (f :: * -> *). (Functor f, Monad f) => [(a -> b) -> f a -> f b]
21:07:04 <Meady> im trying to write this still, know what i need to use, still stuck tho :s
21:07:15 <copumpkin> @type [fmap, (<$>), liftM, map]
21:07:17 <lambdabot> forall a b. [(a -> b) -> [a] -> [b]]
21:07:18 <Meady> i need to do a group then get length of each sublist
21:07:34 <Meady> copumpkin could you help explain it?
21:07:39 <SamB_XP_> @type [fmap, (<$>), liftM, map, (.)]
21:07:41 <lambdabot>     Couldn't match expected type `[a]' against inferred type `a1 -> a'
21:07:41 <lambdabot>     In the expression: (.)
21:07:41 <lambdabot>     In the expression: [fmap, (<$>), liftM, map, ....]
21:07:47 <SamB_XP_> aww
21:07:56 <mmorrow> Meady: do you want the solution?
21:08:00 <copumpkin> Meady: so say you have a list of numbers and you want to multiply them all by two, what do you do?
21:08:08 <copumpkin> > map (*2) [1..5]
21:08:10 <lambdabot>   [2,4,6,8,10]
21:08:14 <Meady> Why would i want to do that?
21:08:25 <copumpkin> because it's the same idea
21:08:39 <copumpkin> now you have a list of lists, and you want to get the length of all of them
21:08:45 <copumpkin> putting the result into a newl ist
21:08:53 <mmorrow> say you have a list of files, and you want to cd into each one's directory and run a shell command..
21:09:12 <mmorrow> or a list of db tables, and you want to run a query on each
21:09:37 <mmorrow> or a list of tree and you want to collapse each before your collapse the list of results into a single value
21:09:46 <Meady> hmm i know how do that in python
21:09:47 <Meady> :S
21:09:53 <mmorrow> map
21:09:56 <Meady> ok
21:09:56 <Meady> ok
21:10:01 <Meady> @src map
21:10:02 <lambdabot> map _ []     = []
21:10:02 <lambdabot> map f (x:xs) = f x : map f xs
21:10:03 <mmorrow> [f](M,M_)
21:10:12 <copumpkin> Meady: so what map does is to build a new list from the list you give it, by applying the same function to each element
21:10:20 <copumpkin> in your case, what function do you want to apply?
21:10:21 <Meady> ahh i see
21:10:28 <Meady> length
21:10:37 <copumpkin> yup
21:10:48 <Meady> right, sorry im so slow guys, my bad
21:10:57 <Cale> > map length . words $ "here are a bunch of words to find the lengths of"
21:10:59 <lambdabot>   [4,3,1,5,2,5,2,4,3,7,2]
21:11:11 <Meady> awsome how you can type commands in here
21:11:15 <copumpkin> Meady: not slow, this stuff can be hard to pick up if you're not used to it
21:11:31 <Meady> Been coding it for a while then guys?
21:11:35 <Cale> Lists, together with higher-order functions like map are our loops
21:11:37 <BMeph> Meady: Haskell makes everyone feel slow.
21:11:48 <BMeph> Meady: (Well, all except the arrogant. ;)
21:11:50 <Meady> map length [1,1,1,1,1]
21:11:52 <copumpkin> lol
21:11:58 <Meady> how do you run code in to bot
21:11:59 <Meady> lol
21:12:01 <copumpkin> Meady: that won't work
21:12:05 <mmorrow> > 42
21:12:06 <copumpkin> you need to put > in front of it
21:12:06 <lambdabot>   42
21:12:07 <Cale> put "> " at the start
21:12:07 <Zrs> Are there any websites with small haskell problems for teaching purposes? I'm scared of diving into a larger project I want to do since there's so much I don't know.
21:12:08 <mmorrow> , 43
21:12:10 <lunabot>  43
21:12:12 <Meady> > map
21:12:14 <lambdabot>   Overlapping instances for GHC.Show.Show ((a -> b) -> [a] -> [b])
21:12:14 <lambdabot>    arising...
21:12:17 <mmorrow> @type map
21:12:18 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
21:12:23 <mmorrow> @nixon
21:12:24 <lambdabot> Any change is resisted because bureaucrats have a vested interest in the chaos in which they exist.
21:12:26 <copumpkin> Meady: that's trying to show you the function
21:12:28 <Cale> > map length [[1,2,3],[4,5],[6,7,8]]
21:12:30 <lambdabot>   [3,2,3]
21:12:31 <aavogt> I get confused by words and unwords. How do you remember which one to use (other than the type errors)?
21:12:36 <BMeph> @go Intermediate Haskell
21:12:41 <lambdabot> http://dibblego.wordpress.com/2008/09/18/20-intermediate-haskell-exercises/
21:12:41 <lambdabot> Title: 20 Intermediate Haskell Exercises « λ Tony’s Blog λ
21:12:47 <Meady> oooo, interesting Cale
21:12:49 <BMeph> Zrs: ^^
21:12:49 <Zrs> BMeph: woop woop woop
21:12:52 <Cale> aavogt: I just always remember that words gives me the words in a string.
21:12:56 <shachaf> > fmap fmap fmap (+1) [[1,2,3],[4,5,6]]
21:12:58 <lambdabot>   [[2,3,4],[5,6,7]]
21:13:01 <mmorrow> aavogt: i think of them as describing what they'll produce
21:13:36 <Meady> so map length group [list]?
21:13:45 <mmorrow> + a dot
21:13:52 <copumpkin> Meady: or more parentheses
21:13:53 <mmorrow> (and a $, or parens)
21:13:55 <Cale> Meady: probably you want some parens or a . and $
21:14:11 <Cale> > map length . group $ mississippi"
21:14:12 <lambdabot>   <no location info>:
21:14:12 <lambdabot>      lexical error in string/character literal at end o...
21:14:14 <Cale> > map length . group $ "mississippi"
21:14:16 <lambdabot>   [1,1,2,1,2,1,2,1]
21:14:26 <Cale> > map length (group "mississippi")
21:14:28 <lambdabot>   [1,1,2,1,2,1,2,1]
21:14:29 <mmorrow> > (map length . group) "mississippi"
21:14:30 <Meady> whats the . doing
21:14:35 <Cale> Composing functions
21:14:37 <lambdabot>   [1,1,2,1,2,1,2,1]
21:14:39 <Meady> ah
21:14:40 <copumpkin> @src (.)
21:14:41 <Cale> (f . g) x = f (g x)
21:14:43 <lambdabot> (f . g) x = f (g x)
21:14:50 * Cale is faster than lambdabot ;)
21:14:50 <copumpkin> faster than a speeding bot!
21:14:52 <copumpkin> :P
21:14:53 <Meady> > map length group "ttteest
21:14:55 <lambdabot>   <no location info>:
21:14:55 <lambdabot>      lexical error in string/character literal at end o...
21:14:56 <Meady> > map length group "ttteest"
21:14:58 <lambdabot>   Couldn't match expected type `[[a]]'
21:15:03 <Meady> right i see
21:15:10 <copumpkin> > map length (group "ttteest")
21:15:12 <Cale> Meady: that's applying map to three parameters, which isn't what you want
21:15:12 <lambdabot>   [3,2,1,1]
21:15:25 <Cale> (since it takes at most two)
21:15:36 <mmorrow> , foldr (++) [] [[1,2],[3]]
21:15:37 <lunabot>  [1,2,3]
21:15:51 <mmorrow> , foldr (.) id (replicate 4 (*2)) 2
21:15:53 <lunabot>  32
21:15:58 <Meady> > map length . (group "ttteest")
21:15:59 <copumpkin> lol
21:16:09 <Meady> > map length (group "ttteest")
21:16:10 <lambdabot>   Couldn't match expected type `a -> [[a1]]'
21:16:11 <lambdabot>   [3,2,1,1]
21:16:18 <mmorrow> @type (map length . group)
21:16:20 <lambdabot> forall a. (Eq a) => [a] -> [Int]
21:16:35 <Meady> > ok so i hae the second values i want
21:16:37 <lambdabot>   Not in scope: `ok'Not in scope: `so'Not in scope: `hae'Not in scope: `the'N...
21:16:40 <Meady> now i need to do that for each element
21:17:04 <mmorrow> @type (\f g a -> (f a, g a))
21:17:05 <lambdabot> forall t t1 t2. (t -> t1) -> (t -> t2) -> t -> (t1, t2)
21:17:26 <mmorrow> @type (&&&) :: (a -> b) -> (a -> c) -> a -> (b, c)
21:17:28 <lambdabot> forall a b c. (a -> b) -> (a -> c) -> a -> (b, c)
21:17:40 <Meady> ok could you go through it
21:17:49 <mmorrow> @type (head &&& length)
21:17:51 <lambdabot> forall c. [c] -> (c, Int)
21:17:53 <aavogt> thanks Cale, mmorrow.
21:18:00 <Meady> this is making no sense morrow
21:18:02 <Meady> lol
21:18:06 <Meady> head is first element right?
21:18:09 <mmorrow> yes
21:18:11 <Meady> can i do head+1?
21:18:12 <Cale> probably just use lambda...
21:18:13 <Meady> head+2
21:18:13 <aavogt> will probably still get them mixed up though :)
21:18:26 <mmorrow> yeah, lambda would be more straightforward here
21:18:30 <Meady> head inc maybe
21:18:53 <Cale> > map (\xs -> (head xs, length xs)) . group $ "mississippi"
21:18:54 <lambdabot>   [('m',1),('i',1),('s',2),('i',1),('s',2),('i',1),('p',2),('i',1)]
21:19:00 <Cale> > map (\xs -> (head xs, length xs)) . group . sort $ "mississippi"
21:19:02 <lambdabot>   [('i',4),('m',1),('p',2),('s',4)]
21:19:03 <Meady> god i suck so bad at this
21:19:11 <Meady> hmm
21:19:13 <mmorrow> aavogt: it's like once you turn the wrong way at an intersection once, you're forever screwed because you'll always second guess yourself and turn the wrong way :)
21:19:24 <Meady> You just told me cale:s
21:19:36 <Cale> Oh, I didn't know what the actual goal was :)
21:19:43 <copumpkin> also, cale's is backwards!! :P
21:19:48 <copumpkin> I asked for them in the opposite order ;)
21:19:49 <Meady> my word
21:19:57 <mmorrow> @type map (head &&& length) . group
21:19:58 <Meady> lol
21:19:59 <lambdabot> forall a. (Eq a) => [a] -> [(a, Int)]
21:20:09 <Meady> ok copumpkin can we try something easier now
21:20:17 <mmorrow> sometimes just seeing the solution is the best thing
21:20:31 <copumpkin> how about the decoder for it? :)
21:20:35 <mmorrow> heh
21:20:53 <aavogt> @type uncurry replicate
21:20:55 <lambdabot> forall b. (Int, b) -> [b]
21:21:06 <copumpkin> :P
21:21:12 <Meady>  map (\xs -> (head xs, length xs)) . group $ "mississippi" ok this solution, how do we know what xs is, and im still not fully getting .group $
21:21:27 <mmorrow> @src ($)
21:21:28 <lambdabot> f $ x = f x
21:21:34 <mmorrow> it just saves parenthesis
21:21:48 <mmorrow> and gives you a way to refer to application by name
21:21:49 <Meady> Copumpkin bit much something real simple, and go from there ahah
21:22:04 <mmorrow> , zipWith ($) [(*2), negate, id] [1..]
21:22:06 <lunabot>  [2,-2,3]
21:22:28 <BMeph> @type uncurry replicate . flip
21:22:29 <lambdabot>     Couldn't match expected type `(Int, b)'
21:22:29 <lambdabot>            against inferred type `b1 -> a -> c'
21:22:29 <lambdabot>     In the second argument of `(.)', namely `flip'
21:22:31 <Meady> > putStr "wooooo"
21:22:33 <lambdabot>   <IO ()>
21:22:36 <BMeph> @type uncurry (replicate . flip)
21:22:38 <lambdabot>     Couldn't match expected type `Int'
21:22:38 <lambdabot>            against inferred type `b -> a -> c'
21:22:38 <lambdabot>     In the second argument of `(.)', namely `flip'
21:22:43 <Meady> God, cant even get that working
21:22:57 <BMeph> @type uncurry (flip replicate)
21:22:58 <lambdabot> forall a. (a, Int) -> [a]
21:23:43 <Meady> ok maybe reversing a list would be a good start
21:23:49 <mmorrow> @type concatMap (replicate . uncurry (flip (,)))
21:23:50 <lambdabot>     Couldn't match expected type `Int' against inferred type `(b, a)'
21:23:50 <lambdabot>     In the second argument of `(.)', namely `uncurry (flip (,))'
21:23:50 <lambdabot>     In the first argument of `concatMap', namely
21:24:01 <Meady> infact
21:24:02 <mmorrow> @type concatMap (uncurry replicate . uncurry (flip (,)))
21:24:04 <aavogt> > [('i',4),('m',1),('p',2),('s',4)] >>= uncurry (flip replicate)
21:24:04 <lambdabot> forall a. [(a, Int)] -> [a]
21:24:04 <Meady> thats just reverse isnt it
21:24:05 <Meady> :s
21:24:05 <lambdabot>   "iiiimppssss"
21:25:13 <BMeph> > [('m',1),('i',1),('s',2),('i',1),('s',2),('i',1),('p',2),('i',1)] >>= uncurry (flip replicate)
21:25:14 <lambdabot>   "mississippi"
21:25:33 <aavogt> @check True
21:25:34 <lambdabot>   "OK, passed 500 tests."
21:25:46 <BMeph> > fix error
21:25:47 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
21:25:49 <aavogt> @check not False
21:25:50 <lambdabot>   "OK, passed 500 tests."
21:25:55 <mmorrow> @type concat . uncurry (zipWith (flip replicate)) . unzip
21:25:57 <lambdabot> forall a. [(a, Int)] -> [a]
21:27:10 <copumpkin> how does one go about officiall proposing a LANGUAGE extension?
21:27:30 <copumpkin> I suppose having (most of) an implementation handy would help it get in?
21:27:53 <mmorrow> copumpkin: i think by writing a specification and implementing it
21:28:16 * copumpkin is still really attracted to http://blog.omega-prime.co.uk/?p=61
21:29:11 <Meady> ok with map say i want [x,x] output
21:29:18 <Meady> how do i do it simple
21:29:26 <copumpkin> > map (\x -> [x, x]) [1..5]
21:29:28 <lambdabot>   [[1,1],[2,2],[3,3],[4,4],[5,5]]
21:29:36 <Meady> still not understanding that
21:29:42 <Meady> ffs im terribad
21:29:45 <mmorrow> f x = [x, x]
21:29:50 <mmorrow> f = \x -> [x, x]
21:29:52 <aavogt> @where lyah
21:29:53 <lambdabot> www.learnyouahaskell.com
21:29:53 <mmorrow> are the same
21:29:54 <copumpkin> the \ is an unnamed (lambda) function
21:29:56 <Meady> what is \x?
21:30:00 <Meady> Im on is now aavogt
21:30:01 <copumpkin> introduces
21:30:06 <mmorrow> , (\x -> x + 1) 1
21:30:08 <lunabot>  2
21:30:17 <mmorrow> , (\x y -> x + y + 1) 1 99
21:30:18 <lunabot>  101
21:30:25 <aavogt> that's a good one
21:30:26 <Meady> whats the \ for :S?
21:30:28 <copumpkin> \x -> x + 1 means an unnamed function that takes one argument, called x, and adds 1 to it
21:30:30 <mmorrow> , (\x (y,_) -> x + y + 1) 1 (99, "zomg")
21:30:32 <lunabot>  101
21:30:34 <copumpkin> Meady: it's a poor man's lambda :P
21:30:48 <Meady> i see
21:30:49 <copumpkin> I believe GHC will also accept the unicode lambda
21:30:55 <copumpkin> but most people don't bother typing it
21:31:21 <Meady> lol another few hours, then its back to oop if i cant grasp it, guess its not made for everyone
21:31:30 <Saizan> copumpkin: the aliases or the associated classes?
21:31:45 <dsturnbull> might bind capslock to lambda
21:31:54 <copumpkin> Saizan: both, I think the two of them together will help fix two of my main complaints about haskell :P
21:32:09 <aavogt> RECORDS
21:32:18 <copumpkin> records are icky but aren't that bad
21:32:34 <copumpkin> at least not to me
21:32:52 <copumpkin> the aliases will ease the transition to a meaningful numerical class hierarchy, like in his example
21:33:02 <Saizan> copumpkin: there's something on the GHC trac about the latter ones
21:33:14 <copumpkin> and the associated contexts will not only allow restricted monads, but restricted things like Array
21:33:23 <copumpkin> so I could for example make UArr an instance of it
21:33:27 <copumpkin> despite the UA constraint
21:33:46 <Meady> Do many people pickup haskell and then drop it due to difficulty?
21:34:00 <copumpkin> Meady: probably :)
21:34:07 * Tsion kept at it due to difficulty.
21:34:11 <Tsion> :)
21:34:13 <copumpkin> Meady: but it really isn't that difficult, you just need to keep pushing in
21:34:23 <copumpkin> Tsion: same here, I love feeling boggled
21:34:30 <Cale> Meady: Stick with it. :) It took me maybe about 2 months before I really felt like I could really use Haskell, and maybe a year before I was comfortable with it. Now we have better tutorials, and admittedly at the time I was studying mathematics more than Haskell, but I still think it takes a lot of time for the way of doing things to sink in.
21:34:52 <Cale> (Just like it probably took a long time to learn to program in the first language you learned)
21:35:17 <Meady> hmm its just it took me 2 months to grasp using C++ classes and java abstract inheritence encapsulation etc
21:35:32 <copumpkin> Saizan: I still think the two of them together would do great things :) but they probably could be separated into two extensions
21:35:32 <Meady> going to take a while to stop thinking like that i guess
21:35:58 <copumpkin> Meady: yeah :) and after two months you should get a decent amount of haskell
21:36:05 <Cale> Of course, the real general ideas behind those things are still useful, just not the syntax, and not so directly.
21:36:07 <copumpkin> there will still be things that will blow you away
21:36:17 <Meady> Lol i mean after 4 months, i was writing asynchronous sockets in C
21:36:23 <pragma_> after "two months" of doing precisely what?
21:36:30 <Cale> Abstraction and encapsulation of state is still a useful concept, but we do it differently. :)
21:36:59 <Cale> Meady: I'm sure you could manage that kind of progress here too :)
21:37:10 <Saizan> copumpkin: yeah, they look orthogonal to me
21:37:30 <Meady> Well my university teacher tells us constantly when writing C how great haskell is, and how he has his little circle of functional programming friends
21:37:46 <copumpkin> Saizan: so we'd do what he said about giving a separate kind to constraints for the second one?
21:38:00 <Cale> Meady: Once you know how to do basic I/O, and the most basic things about threads, writing a small server or network client should not be hard :)
21:38:29 <Cale> (and you might not need threads for the client)
21:38:43 <dsturnbull> t.hs:3:37: Pattern syntax in expression context: λx -> x `mod` 2
21:38:44 <dsturnbull> fail
21:39:00 <copumpkin> > (λx -> x `mod` 2) 5
21:39:02 <Saizan> copumpkin: i don't think we need new kinds, you just have to check that the type parameters of the class are of the right kind, no?
21:39:02 <lambdabot>   Pattern syntax in expression context: λx -> x `mod` 2
21:39:05 <copumpkin> , (λx -> x `mod` 2) 5
21:39:07 <lunabot>  luna: Pattern syntax in expression context: ۸ -> x `mod` 2
21:39:33 <Cale> ۸ U+06F8 EXTENDED ARABIC-INDIC DIGIT EIGHT
21:39:38 <Cale> wtf?
21:40:06 <aavogt> so by definition, you cannot change the environment in a Reader (ex. with local), and have that change escape?
21:40:12 <Saizan> copumpkin: i.e. class C (a1 :: k1) (a2 :: k2) .. suffices
21:40:13 <copumpkin> Saizan: I guess, but it might be nice to be able to pass around constraints?
21:40:25 <Cale> aavogt: right
21:40:36 <Cale> aavogt: Just like you can't change the parameter to a function, except locally
21:41:04 <Cale> Well, I could have made that more clear :P
21:41:26 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
21:41:27 <lambdabot>   ("hello","olleh","HELLO")
21:41:40 <Saizan> copumpkin: "pass around" looks like a more extreme extension, at which level?
21:41:43 <Cale> There is an example of the function monad, which is an unravelled version of Reader
21:42:26 <Cale> Basically, all it does is pass that 'environment' parameter down to each of the functions.
21:43:16 <Cale> You can locally compose the functions with another function to make them behave as if the environment was different...
21:43:24 <Cale> > (do x <- id; y <- reverse . const "goodbye"; z <- map toUpper; return (x,y,z)) "hello"
21:43:25 <lambdabot>   ("hello","eybdoog","HELLO")
21:43:32 <copumpkin> Saizan: I guess it would be pretty extreme :P trying to think what kind of case it might make sense to do such a thing in, even. type OrdType = SomeTypeThatAcceptsAConstraint Int Float Ord -- the kind would be * -> * -> % -> *
21:43:35 <copumpkin> or something :P
21:43:39 <Cale> but other than that, there's no state :)
21:43:48 <copumpkin> Saizan: not a clue what that would be for though
21:44:22 <copumpkin> it feels like almost "first-class typeclasses" but not really
21:45:02 <Meady> > "I LIKE " ++ reverse "DESSERTS"
21:45:03 <lambdabot>   "I LIKE STRESSED"
21:45:07 <Meady> lol
21:45:21 <Meady> > "I LIKE " ++ reverse "STRESSED"
21:45:23 <lambdabot>   "I LIKE DESSERTS"
21:45:45 <Saizan> copumpkin: it seems to drift in the land of parametrized modules
21:45:50 <copumpkin> probably :)
21:45:52 <aavogt> > map toLower "I LEIK"
21:45:54 <lambdabot>   "i leik"
21:46:02 <Saizan> which wouldn't be bad :)
21:46:09 <copumpkin> I'd very much like those too :P
21:46:20 <Meady> > "Is it weird DESSERTS spells " ++ reverse "DESSERTS" ++ " backwards?"
21:46:21 <lambdabot>   "Is it weird DESSERTS spells STRESSED backwards?"
21:46:23 <copumpkin> but I'll settle for the two extensions BSP is proposing in that blog post in the mean time :)
21:46:52 <aavogt> copumpkin: then implement them?
21:46:57 <aavogt> =)
21:47:16 <copumpkin> aavogt: when I get some time, if someone hasn't done it first, I might just do that... :)
21:47:37 <copumpkin> I haven't played with GHC at that level
21:48:26 * aavogt and ghc are not that level either
21:48:26 <Saizan> we need to form a coalition of programmers to try various approaches in the design space of modules in practice, like they did for gofer and constructor classes
21:49:12 <Saizan> (well, for gofer maybe they just knew what to do, i don't know)
21:49:14 <dmwit> > let question = ap (printf "Is it weird %s spells %s backwards?") reverse in question "STRESSED"
21:49:15 <lambdabot>   Add a type signature
21:49:19 <dmwit> > let question = ap (printf "Is it weird %s spells %s backwards?") reverse in question "STRESSED" :: String
21:49:21 <lambdabot>   "Is it weird STRESSED spells DESSERTS backwards?"
21:50:13 <Pseudonym> Is that a Zippy quote?
21:50:24 <dmwit> heh, I don't think so
21:52:26 <Meady> ok guys give me a simple problem to solve
21:52:40 <copumpkin> whee, my team just made it to #2 on icfp contest
21:52:45 <copumpkin> and I had nothing to do with it :P
21:52:48 <aavogt> > let question = ap (printf "Is it weird %s spells %s backwards?") reverse in question "CASE" :: String
21:52:50 <lambdabot>   "Is it weird CASE spells ESAC backwards?"
21:52:53 <mgsloan> lol nice!
21:53:12 <Gracenotes> printf types are odd
21:53:18 <mgsloan> I had a play with the icfp stuff.  All i did was write a bit of haskell that pretty printed the obf files
21:53:25 <mgsloan> pretty printed with latex ;)
21:53:35 <Gracenotes> typeclassy :\
21:53:36 <copumpkin> too much latex is unsafe
21:53:38 <Pseudonym> @let question = ap (printf "Is it weird %s spells %s backwards?") (reverse :: String -> String)
21:53:40 <lambdabot>  Defined.
21:53:43 <Pseudonym> @question "EVIL"
21:53:44 <lambdabot> Unknown command, try @list
21:53:48 <Pseudonym> > question "EVIL"
21:53:49 <lambdabot>   Add a type signature
21:53:50 <mgsloan> especially around satellites
21:53:56 <Gracenotes> ::String
21:53:57 <Pseudonym> > question "EVIL" :: String
21:53:59 <lambdabot>   "Is it weird EVIL spells LIVE backwards?"
21:54:03 <Pseudonym> OK
21:54:20 <Pseudonym> > question "A MAN A PLAN A CANAL PANAMA" :: String
21:54:20 <copumpkin> > question "dog" :: String
21:54:22 <lambdabot>   "Is it weird A MAN A PLAN A CANAL PANAMA spells AMANAP LANAC A NALP A NAM A...
21:54:22 <lambdabot>   "Is it weird dog spells god backwards?"
21:55:06 <aavogt> Meady: find such phrases / words given a dictionary (ex /usr/share/cracklib, or whatever it's called)
21:55:14 <dmwit> ?undefine
21:55:19 <Gracenotes> > question "stressed" :: String
21:55:21 <lambdabot>   Not in scope: `question'
21:55:23 <dmwit> @let question = ap (printf "Is it weird %s spells %s backwards?")reverse ::  String -> String
21:55:24 <lambdabot>  Defined.
21:55:29 <dmwit> > question "stressed"
21:55:30 <Gracenotes> aw shucks, you
21:55:31 <lambdabot>   "Is it weird stressed spells desserts backwards?"
21:55:40 <dmwit> You people and your type signatures.
21:56:27 <Pseudonym> You know what that did, though.
21:56:33 <Gracenotes> > question "deliver"
21:56:34 <Pseudonym> It added another rule.
21:56:35 <lambdabot>   "Is it weird deliver spells reviled backwards?"
21:56:44 <dmwit> Pseudonym: I ?undefined, first.
21:56:48 <Pseudonym> Oh, right.
21:56:55 <Pseudonym> Could have done it that way, though.
21:57:03 <Gracenotes> the mechanics of @undefined are weird
21:57:09 <dmwit> I don't think you can.
21:57:16 <dfrey> Why is it that I can do "import System.Posix.Files", but when I go to http://www.haskell.org/ghc/dist/current/docs/libraries/  it's not listed?
21:57:16 <Gracenotes> -d
21:57:16 <dmwit> ?let question s = s
21:57:17 <lambdabot>  <local>:2:0:
21:57:17 <lambdabot>      Multiple declarations of `L.question'
21:57:17 <lambdabot>      Declared at: <l...
21:57:22 <dmwit> see?
21:57:26 <Pseudonym> > question "bolton"
21:57:28 <lambdabot>   "Is it weird bolton spells notlob backwards?"
21:57:29 <Pseudonym> Right.
21:58:01 <Gracenotes> nametag
21:58:11 <dmwit> dfrey: Perhaps you installed an additional package. ;-)
21:58:36 <dfrey> dmwit: I guess that would explain it.
21:58:38 <dmwit> dfrey: (In this case, the "unix" package.)
21:58:41 <Gracenotes> hm... http://www.haskell.org/ghc/docs/latest/html/libraries/unix/System-Posix-Files.html
21:58:57 <Gracenotes> it seems it is built-in, but only for unix, I'd guess
21:59:07 <dfrey> I guess it's part of a unix library or something
21:59:14 <dmwit> dfrey: Or your distro's package for GHC includes the unix (Haskell) package, or...
21:59:23 <Gracenotes> it is in the GHC source tree
21:59:43 <Meady> so . means we are passing the result rhough
21:59:44 <Gracenotes> ghc/libraries/unix/System/Posix/Files.hsc
22:00:00 <Meady> last.init would return last element -1
22:00:01 <Meady> ?
22:00:27 <aavogt> > last . init $ []
22:00:28 <lambdabot>   * Exception: Prelude.init: empty list
22:00:43 <Gracenotes> assuming there are >= 2 elements
22:01:52 <aavogt> > last . init $ cycle "hah, another corner case!"
22:01:58 <lambdabot>   mueval-core: Prelude.read: no parse
22:01:58 <lambdabot>  mueval: ExitFailure 1
22:02:04 <Meady> so does the . parse the value accross to the next function
22:02:07 <Gracenotes> that returns the second-to-last element
22:02:08 <Meady> result* not value
22:02:12 <Gracenotes> ...when it reaches it
22:02:23 <Gracenotes> @src (.)
22:02:23 <lambdabot> (f . g) x = f (g x)
22:02:55 <Meady> ok so whats the $ for?
22:02:57 <aavogt> Gracenotes: interesting interpretation
22:03:02 <Meady> in laymen terms
22:03:09 <Gracenotes> (.) is function composition, like in math. You see a lot of (.)-chaining, like 'map (head &&& length) . group . sort'
22:03:31 <Meady> what would that output
22:03:33 <Meady> hmm
22:03:49 <Meady> so map would parse result to group which would parse result to sort?
22:04:43 <jmcarthur> Meady: a b c $ d e f $ g h i  ==  (a b c) ((d e f) (g h i))  --  that is, $ is function application with a different precedence
22:04:50 <aavogt> @wn parse
22:04:51 <lambdabot> *** "parse" wn "WordNet (r) 2.0"
22:04:51 <lambdabot> parse
22:04:51 <lambdabot>      v : analyze syntactically by assigning a constituent structure
22:04:51 <lambdabot>          to (a sentence)
22:05:27 <jmcarthur> Meady: so, last . init $ []  ==  (last . init) []
22:05:30 <Gracenotes> Meady: well, the results would be available from sort, and then from group, and then once map is done with them the computation is done
22:06:11 <aavogt> @quote evaluation order
22:06:12 <lambdabot> No quotes for this person. Where did you learn to type?
22:06:16 <Gracenotes> (as a side note.. due to Haskell's lazy nature, you can get the next element of a list without having the rest of the list prepared)
22:06:35 <aavogt> @quote evaluation
22:06:35 <lambdabot> malig says: quantum mechanics actually strikes me as less wierd than lazy evaluation sometimes. at least it disallows time travel
22:06:45 <Gracenotes> > map (head &&& length) . group . sort $ "mississippi"
22:06:46 <lambdabot>   [('i',4),('m',1),('p',2),('s',4)]
22:08:08 <Gracenotes> that this does, procedurally, is sort it into "iiiimppssss", group it into ["iiii","m","pp","ssss"], and analyze each element to get both a representative element (head) and the number of elements...
22:08:31 <copumpkin> > map (head &&& length) . group . sort $ "myyyyy precioussssssssssssss"
22:08:32 <lambdabot>   [(' ',1),('c',1),('e',1),('i',1),('m',1),('o',1),('p',1),('r',1),('s',14),(...
22:08:38 <Meady> so . parses the value and $ groups the functions?
22:08:40 <Gracenotes> although it's all entwined to to laziness. But getting off-topic >_>
22:08:57 <Gracenotes> Meady: what do you mean by parses...
22:09:21 <Meady> well, reverse [1,2,3] . group, would pass 3,2,1 to group?
22:09:31 <copumpkin> that's backwards
22:09:54 <Meady> huh
22:10:21 <copumpkin> function composition happens from right to left
22:10:35 <copumpkin> > (*5) . (+4) $ 6
22:10:36 <Meady> God im a nob, makes sense
22:10:37 <lambdabot>   50
22:10:46 <Tsion> (f . g) x = f (g x)
22:10:54 <Meady> yeah that makes sense
22:10:56 <copumpkin> there is a reverse function composition operator, but you probably don't want it now
22:11:02 <Meady> nope
22:11:07 <Gracenotes> not to mention, (.) composes functions that are not fully applied, so even (group . reverse [1,2,3]) doesn't work, but (group . reverse $ [1,2,3]) does
22:11:09 <Meady> Right that starts to make alot of sense
22:11:14 <Meady> probably why i didnt understand earlier
22:11:37 <Meady> so im still not getting $ it would seem
22:11:45 <aavogt> @hoogle (a -> b) -> (b -> c) -> (a -> c)
22:11:46 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
22:11:46 <lambdabot> Data.Function (.) :: (b -> c) -> (a -> b) -> a -> c
22:11:46 <lambdabot> Control.Parallel.Strategies (-|) :: (a -> b) -> Strategy b -> (b -> c) -> a -> c
22:11:48 <Gracenotes> the above is equivalent to (group (reverse [1,2,3]))
22:11:58 <Tsion> f $ x = f x
22:12:09 <Tsion> $ is mainly used to avoid parens
22:12:27 <aavogt> copumpkin: where can I buy this reverse composition?
22:12:36 <Gracenotes> >>> that way
22:12:36 <copumpkin> in Control.Category
22:12:38 <copumpkin> :P
22:13:19 <Meady> gracenotes can i do it that way with the brackets instead of$?
22:13:33 <aavogt> @hoogle (a -> b) -> (a -> c) -> a -> (b,c)
22:13:33 <lambdabot> No results found
22:13:52 <aavogt> @hoogle (>>>)
22:13:53 <lambdabot> Control.Arrow (>>>) :: Arrow a => a b c -> a c d -> a b d
22:14:21 <Gracenotes> Meady: sure, you don't really need $.
22:14:47 <Meady> makes alot more sense understanding execution with ()()(()()( as apposed to $$$$$$
22:14:57 <Meady> but its still right to left with that approach right
22:14:58 <Gracenotes> suppose you want to show a number and take the length. well, "length show 400" won't work, because length only takes one argument. What you want is "length (show 400)"
22:15:01 <Saizan> group . reverse $ [1,2,3] == (group . reverse) [1,2,3]
22:15:06 <aavogt> hmm, so hoogle doesn't generalize things like that? (since even the old >>> worked like flip (.))
22:15:26 <copumpkin> aavogt: I don't think hoogle is smart enough to make sense of the type signature for it
22:15:32 <Gracenotes> Meady: but if you don't want the parens in "length (show 400)", you can just do "length $ show 400"
22:15:32 <Meady> Ok gracenotes, 400 would be parsed to show, which would output?
22:15:35 <Meady> > show 400
22:15:36 <lambdabot>   "400"
22:15:46 <Meady> which would then be processed by length
22:15:48 <Meady> to give 3?
22:15:54 <Gracenotes> yes, correct
22:16:13 <Meady> ok awsome
22:16:22 <aavogt> it seems that hoogle can't replace #haskell yet
22:16:29 <Meady> so will most placees push for me to use $ or ()?
22:16:52 <Gracenotes> f $ x just means f x. But if x is more than one word, you might prefer it instead of f (x), like if x is "a b c"
22:17:34 <Meady> yeah
22:17:37 <Gracenotes> well, 'idiomatic' Haskell (commonly found in the wild, so to speak) uses a fair amount of ($) and (.), but you don't need it or anything
22:17:51 <Meady> Gracenotes thanks for that
22:19:56 <Meady> so lets assume i want a multi dimensional array maade with map
22:20:18 <Meady> map (reverse[1..20])
22:20:24 <Meady> how would i add the other dimension
22:21:42 <aavogt> > map (reverse [1..20])
22:21:44 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[t]'
22:22:04 <Meady> > map reverse[1..20]
22:22:05 <lambdabot>   No instance for (GHC.Enum.Enum [a])
22:22:05 <lambdabot>    arising from the arithmetic sequence...
22:22:45 <aavogt> > map reverse $ map (:[]) [1..20]
22:22:47 <lambdabot>   [[1],[2],[3],[4],[5],[6],[7],[8],[9],[10],[11],[12],[13],[14],[15],[16],[17...
22:23:14 <aavogt> @type (:[])
22:23:16 <lambdabot> forall a. a -> [a]
22:23:25 <aavogt> @type map reverse
22:23:27 <lambdabot> forall a. [[a]] -> [[a]]
22:23:33 <copumpkin> do you guys think it would be too awkward to petition Henning Thielemann to stop using his C/T scheme? I've seen so many nice libraries that I'd like to use but it's so off-putting reading his documentation (and it tends to force every class/type into a module of its own, which causes enormous project)
22:23:54 <Tsion> heh, the type for (:[]) is almost the implementation ;)
22:24:00 <Tsion> \a -> [a]
22:24:19 <Meady> hmm
22:24:35 <Meady> > map reverse [1..20]
22:24:37 <lambdabot>   No instance for (GHC.Enum.Enum [a])
22:24:37 <lambdabot>    arising from the arithmetic sequence...
22:25:13 <copumpkin> > map reverse (repeat [1..5])
22:25:14 <lambdabot>   [[5,4,3,2,1],[5,4,3,2,1],[5,4,3,2,1],[5,4,3,2,1],[5,4,3,2,1],[5,4,3,2,1],[5...
22:25:34 <aavogt> copumpkin: at least with Data.Accessor, he uses a type synonym for T
22:25:36 <dmwit> > repeat [1..5] >>= reverse
22:25:37 <lambdabot>   [5,4,3,2,1,5,4,3,2,1,5,4,3,2,1,5,4,3,2,1,5,4,3,2,1,5,4,3,2,1,5,4,3,2,1,5,4,...
22:26:04 <copumpkin> aavogt: oh, so he's moving away from the purest form of his pseudomodules?
22:30:15 <aavogt> I dunno, he is definitely aware that his naming conventions are not that popular (yet?....)
22:30:31 <copumpkin> well, granted, they're most painful because haddock won't display qualified names
22:31:11 <Saizan> copumpkin: i'd sign that petition
22:31:17 <copumpkin> but still... if he insists on using that everywhere, he should stop making all those fun packages and write a patch to haddock to display qualified names
22:31:31 <copumpkin> I'd still prefer if he took a more standard approach though
22:32:04 <copumpkin> the numeric prelude looks pretty cool
22:32:11 <copumpkin> (unfortunately it's GPL, but that's another issue)
22:35:55 <Saizan> i guess you ca rewrite it with saner names and release under BSD without being accused of code stealing then?:)
22:36:18 <copumpkin> I'm assuming you missed the n't there :P
22:37:04 <Saizan> i meant only an "n"
22:37:16 <copumpkin> oh, I don't think I'm allowed to do that, am I?
22:37:25 <Saizan> i wouldn't know
22:37:51 <copumpkin> I can make changes to it, but they would be a derivative work and I'd be forced to release it under gpl
22:40:16 <Meady> i understand using | to apply changes to lists but what does it actually do by definition
22:40:38 <Meady> > [x*2 | x <- [10..20]]
22:40:40 <lambdabot>   [20,22,24,26,28,30,32,34,36,38,40]
22:41:11 <aavogt> Meady: | is not a function, it is part of the list comprehension syntax in that case
22:41:22 <aavogt> > map (*2) [10..20]
22:41:24 <lambdabot>   [20,22,24,26,28,30,32,34,36,38,40]
22:41:42 <Meady> yeah i know aavogt, but what im saying is, its process right to left there but here..
22:41:47 <Meady>    1. boomBangs xs = [ if x < 10 then "BOOM!" else "BANG!" | x <- xs, odd x]
22:42:03 <Meady> x doesnt have a value, so going from right to left wouldnt make sense?
22:42:22 <Meady> x only has a val after xs give it one AFTER odd x if we are giong right to left
22:42:24 <aavogt> it is supposed to look like mathematical notation for sets
22:42:44 <Meady> Could you explain a bit simpler
22:42:48 <Meady> please ofc
22:42:57 <copumpkin> http://en.wikipedia.org/wiki/Set_builder_notation
22:43:27 <copumpkin> obviously not exactly :P
22:44:45 <Saizan> Meady: the scope goes from left to right after |, but what's in scope there is also in scope before the |
22:45:23 <Saizan> Meady: so, if the part before | was at the end the scope would be all left to right
22:45:32 <Meady> ahh Saizan, so x will be assigned then passed to odd x
22:45:39 <Meady> then go left to the |
22:46:45 <Saizan> yeah
22:47:58 <Saizan> there's a simple translation in terms of concatMap and guard
22:48:36 <Saizan> http://www.haskell.org/onlinereport/exps.html#list-comprehensions
22:49:18 <Axman6> Meady: it only goes to the left of the | if the predicates (in this case odd) is true though
22:49:24 <Axman6> so it's like filter
22:51:16 <kniu> I can't figure anymore.
22:51:23 <kniu> @hpaste
22:51:23 <lambdabot> Haskell pastebin: http://hpaste.org/new
22:52:03 <Meady> i see axman, so if odd was false, it wouldnt even get the the next | stage, this seems quite interesting
22:52:21 <Axman6> Meady: do you know anything about sets in maths?
22:52:39 <aavogt> > [ 5 | _ <- [1..10], False ]
22:52:40 <lambdabot>   []
22:52:47 <Axman6> like {x| x ∈ R, x < 10}
22:53:03 <Meady> Only got a C in maths unfourtunately, i was so interested in visual basic, i spent my time making pong instead of doing gcse:s
22:53:04 <copumpkin> not sure haskell could represent that set though :P
22:53:42 <roconnor> @check \a b -> (log a - log b) = log (a/b)
22:53:42 <lambdabot>   Parse error at "=" (column 25)
22:53:44 <Axman6> that says that that is the the set of all real numbers which are less than 10. it basically translates to something like [x | x <- [-infinity..infinity], x < 10]
22:53:48 <roconnor> @check \a b -> (log a - log b) == log (a/b)
22:53:50 <lambdabot>   "Falsifiable, after 1 tests:\n-1.0\n1.5\n"
22:54:07 <Axman6> Meady: you an aussie?
22:54:28 <Axman6> no...
22:54:33 <copumpkin> @check \a b -> (log a - log b) == log (a/(b :: CReal))
22:54:35 <lambdabot>   No instance for (Test.QuickCheck.Arbitrary Data.Number.CReal.CReal)
22:54:35 <lambdabot>    aris...
22:54:39 <copumpkin> aw
22:54:40 <Axman6> huh, thought gcse was a victoria thing. guess not
22:55:22 <Meady> Axman6 what would make you think that? the GCSE?
22:55:43 <Axman6> yeah. couldn't remember where i'd heard of it before
22:55:59 <Meady> English, that would almost make me assume your american, but ill go with canadian
22:56:03 * Axman6 is getting ready to release a new website :O
22:56:18 <Meady> A website on what?
22:56:23 <Axman6> how about australian ;)
22:56:24 <Meady> http://bluevapour.pynguins.com
22:56:36 <Meady> http://bluevapour.pynguins.com/news
22:56:37 <Meady> Sorry lol
22:56:44 <Meady> Lol
22:56:47 <Axman6> my blog. moving it to proper hosting, bought a domain name, setting up wordpress at the moment
22:57:00 <Meady> Yeah i have a server
22:57:02 <Meady> pynguins
22:57:05 <roconnor> > log (exp (0:+1))
22:57:06 <lambdabot>   0.0 :+ 1.0
22:57:12 <roconnor> > log (exp (0:+4))
22:57:13 <lambdabot>   0.0 :+ (-2.2831853071795862)
22:57:19 <Meady> but yeah that /news is the php script i wrote, just a simple SQL retrieval really
22:58:02 <Pseudonym> > log 4
22:58:04 <lambdabot>   1.3862943611198906
22:58:16 <yernab> Hi, quick question: anyone know a predefined function to do cube roots?
22:58:27 <Axman6> @hoogle root
22:58:28 <shachaf> (**(1/3))
22:58:28 <lambdabot> Data.Tree rootLabel :: Tree a -> a
22:58:42 <Axman6> ah good work shachaf, totally forgot about that
22:59:01 <yernab> Cool, thanks guys
22:59:23 <Meady> axman whats the url to your blog
22:59:34 <Axman6> you'll find out when i announce it ;)
22:59:40 <Axman6> still getting it ready
22:59:52 <Meady> give me a pm sneak preview:p
23:00:52 <Axman6> :P
23:01:09 <Axman6> the blog'll be ready soon, just reformatting all the posts from my last blog
23:01:30 <Meady> fine fine :s
23:32:21 <Zrs> @src (!!)
23:32:21 <lambdabot> xs     !! n | n < 0 = undefined
23:32:21 <lambdabot> []     !! _         = undefined
23:32:21 <lambdabot> (x:_)  !! 0         = x
23:32:21 <lambdabot> (_:xs) !! n         = xs !! (n-1)
23:32:57 <Zrs> @src (++)
23:32:57 <Zao> > let omg = "wtf" in omg!!1
23:32:57 <lambdabot> []     ++ ys = ys
23:32:57 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
23:32:57 <lambdabot> -- OR
23:32:57 <lambdabot> xs ++ ys = foldr (:) ys xs
23:32:59 <lambdabot>   't'
23:33:39 <Zrs> So is everything in Haskell defined in terms of Haskell?
23:33:51 <Zao> It's turtles all the way down.
23:33:57 <BMeph> Zrs: Everything possible - so, no. ;)
23:34:16 <QtPlaty[HireMe]> Zrs: No there are primiatives that are not defined in terms of Haskell.
23:34:28 <Zao> At the bottom you have implementation gunk like primops, unboxed stuff and magic.
23:34:44 <QtPlaty[HireMe]> And lambda
23:34:44 <copumpkin> they could be defined in haskell too if we really tried, but it's not worth it :P
23:36:00 <QtPlaty[HireMe]> copumpkin: Could Haskell's lambda be defined in haskell?
23:36:07 <copumpkin> how do you mean?
23:37:25 <QtPlaty[HireMe]> If you had a haskell without a primitive lamda would it be possable to construct one?
23:37:42 <Zao> You have to make a distinction between the language itself and the supporting libraries.
23:37:49 <Zao> Like the Prelude, Data.List etc.
23:37:54 <copumpkin> well, that part of GHC is already in haskell
23:38:24 <copumpkin> the RTS mostly deals with thunks and memory management
23:39:00 <copumpkin> QtPlaty[HireMe]: now, you couldn't define a lambda as a library. it's built into the compiler, but the compiler is written in haskell :P
23:39:39 <QtPlaty[HireMe]> Ok
23:47:20 <Zrs> Are there any decompilers for Haskell?
23:47:51 <Saizan> no
23:51:15 <Zao> As most implementations mangle its output beyond recognition, I can't see how you could reconstruct much at all.
23:51:45 <Zao> Heck, it's hard to tell what's going on if you just look at the C-- code.
23:53:33 <Zao> Let alone after the GHC evil mangler has done its dirty deed on the resulting annotated assembler.
23:53:37 <Zao> *assembly code
23:53:47 <Zao> It thankfully doesn't affect the assembler.. yet :)
23:55:53 <copumpkin> Zrs: I'd be interested to see what hex-rays could do with it
23:55:56 <copumpkin> I doubt much :)
23:56:09 <copumpkin> it makes assumptions about function boundaries
23:56:17 <copumpkin> which are probably monstrously violated by ghc's output
23:56:46 <Zrs> Once I write a useful program I'll definitely dig through it with a debugger, I'm really curious to see what GHC does :D
23:57:11 <Zrs> The code is so different from C that the assembler must be... Tricky to follow :)
23:57:57 <Berengal> There's closures, and the routines that call them
