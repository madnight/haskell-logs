00:01:02 <RyanT5000> i'm trying to figure out exactly what FRP provides; it seems like the push/pull debate is pretty related to incremental computation
00:02:41 <RyanT5000> well, the question of push versus pull seems to be all about how efficiently (and particularly *when*) we're recomputing various parts of the circuit
00:03:14 <RyanT5000> though i suppose it's more about space-efficiency in FRP and more about time-efficiency in incremental computation
00:04:34 <Cale> It's sort of a funny thing to talk about around FRP, because it's purely about the operational semantics, which FRP is supposed to help you avoid worrying about :)
00:05:01 <Cale> Of course, it can only do that by picking something which will be suitably efficient :)
00:05:03 <RyanT5000> well, i'm thinking about FRP implementation right now
00:07:42 <RyanT5000> i'm still trying to wrap my mind around the semantics of FRP
00:08:12 <RyanT5000> i'm still not able to formulate a concise description of what services it provides
00:25:35 <couloir> is there a simple way to get my values out of Either?
00:27:19 <Raevel> couloir: case either of Left x -> x; Right x -> x
00:28:07 <couloir> thanks :)
00:31:20 <ski> @type either id id
00:31:21 <lambdabot> forall b. Either b b -> b
00:31:25 <ski> @type id ||| id
00:31:27 <lambdabot> forall c. Either c c -> c
00:31:48 <ski> (couloir : ^ mayhaps you like any of those better ?)
00:35:23 <couloir> still not sure whether i'm doing this right, lol
00:36:02 <couloir> RWH p. 98, q. 4, if anyone would like to help!
00:37:59 * ski is too lazy atm to hunt down that page and question ..
00:38:24 <couloir> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2798#a2798
00:40:13 <couloir> worked ok when i was using error(.), but confusing results upon various attempts at using Either... the book says it should show something like Right 33 or Left "error message"
00:40:54 <ski> use pattern-matching instead of  null xs  and  head xs == '-'
00:41:29 <ski>   asInt2 ""      = error "no value!"
00:41:42 <ski>   asInt2 ('-':_) = error "negative sign!"
00:41:54 <couloir> trying to avoid the use of error
00:42:03 <ski>   asInt2  xs     = foldl step 0 xs
00:42:07 <ski>     where
00:42:08 <ski>     ...
00:42:18 <couloir> asInt2 ""  = error "no value!"
00:42:20 <ski> hm, oh, right
00:42:37 <ski> i just imagined there being an `error', there :)
00:42:48 <ski> try using `Left' instead of `error'
00:43:14 <ski> (assuming an `ErrorMessage' is just a `String')
00:43:49 <ski> `Left' will then convert an `ErrorMessage' (a `String' (?)), into an `Either ErrorMessage Int', which is of the correct return type
00:43:50 <couloir> yeah, i'll try that
00:43:57 <couloir> ok
00:44:01 <couloir> so Left is a constructor
00:44:06 <ski> you'll need to use `Right' somewhere for returning the `Int' case
00:44:08 <ski> yes
00:44:11 <couloir> gotcha
00:44:12 <ski> @type Left
00:44:14 <lambdabot> forall a b. a -> Either a b
00:45:10 <ski> you don't appear to use `p' at all
00:45:17 <ski>   x == '.' || x == ','
00:45:20 <ski> can be written as
00:45:26 <ski>   x `elem` ".,"
00:46:16 <ski> also, you'll need to pattern-match on the `acc' argument to `step'
00:46:26 <couloir> yeah wasn't using the predicate
00:46:29 <ski> it's of type 'Either ErrorMessage Int'
00:46:31 <couloir> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2799#a2799 <- update
00:46:52 <ski> (couloir : next time, annotate the original paste with modifications, ok ?)
00:46:58 <couloir> sure
00:48:01 <ski> since you want to possibly get errors inside the folding, i don't think you want the `Right' around the call to `foldl' .. since that call itself will return something wrapped in `Right' (or `Left', in case of error)
00:49:16 <ski> also, i think it's nicer if you don't repeat `acc * 10 + digitToInt x' two times
00:49:59 <ski> add something like `where nextAcc = acc * 10 + digitToInt x' after the guards, and then use the `nextAcc' in those two places instead
00:50:14 <couloir> indeed
00:51:47 <RyanT5000> is the special Yampa arrow syntax built into GHC these days?
00:51:50 <ski> and if you want to replace those two remaining `error' calls with `Left', you'll still need to pattern-match on `acc' (or use `foldM' with the `Either e' monad .. or do your own recursion instead of using `foldl')
00:52:24 <ski> RyanT5000 : there is *a* arrow syntax in GHC .. not sure if it's "the special Yampa arrow syntax"
00:52:34 <couloir> yeah, i'm a bit confused on how to pattern match when it's not a list
00:52:44 <RyanT5000> ski: is it the one with the <- ... -< ?
00:52:49 <ski> yes
00:52:58 <RyanT5000> alright, that's the one :)
00:53:09 <ski> couloir : well, a value of type `Either ErrorMessage Int' can be of two forms :
00:53:16 <ski>   Left  someErrorMessage
00:53:23 <ski>   Right someInt
00:53:34 <ski> so, you currently have
00:53:42 <ski>   step acc x = ...
00:53:52 <ski> (you have guards as well, but lets ignore that for the moment)
00:54:01 <couloir> yes
00:54:26 <ski> so, this `acc' thing will be either of the `Left ...' form, meaning an earlier check fired so we've already run into an error
00:54:29 <couloir> step (Left acc) x = ... ; step (Right acc) x = ... ?
00:54:55 <ski> or it will be of the `Right ...' form, where we have the proper result from the earlier stage
00:54:58 <ski> yes
00:55:05 <couloir> haha k
00:55:17 <couloir> i was attempting step (ErrorMessage acc) x = ... ; and so on
00:55:21 <ski> only i wouldn't call it `Left acc' .. rather `Left errMsg' or something like that
00:55:41 <couloir> but now i see the relationship between lists and other types
00:55:46 <couloir> pattern matching uses the cons
00:55:47 <ski> then you can go on adding the guards as before to the latter equation with `Right'
00:55:52 <ski> yes
00:55:59 <ski> > 1 : [2,3,4]
00:56:01 <lambdabot>   [1,2,3,4]
00:56:25 <ski> the `[2,3,4]' is just syntactic sugar for `2 : 3 : 4 : []', which really is `2 : (3 : (4 : []))'
00:56:32 <couloir> indeed
00:57:01 <couloir> familiar w/ prolog pattern matching and lisp lists, but haskell is more fun :)
00:57:27 <ski> yes, in Prolog it'd be something like
00:57:42 <ski>   step(left(ErrMsg),X,Result) :- ...
00:57:49 <ski>   step(right(Acc),X,Result) :- ...
00:57:54 <Saterus> anybody familiar with the haskell regex packages around?
00:58:10 <couloir> yeah, using predicate instead of type system
00:58:23 <ski> rather using predicates instead of functions
00:58:34 <couloir> gotcha, cause cons is a function
00:58:52 <ski> but the matching is very similar (though it's generalized in Prolog, with two-way matching)
00:59:15 <couloir> i must say i like this RWH book
00:59:40 <couloir> map succ authors
01:00:34 <ski> (i'm not sure what you meant by "cause cons is a function" ..)
01:02:05 <couloir> i made a wild guess that ('-':_) was analogous
01:02:52 <ski> it would be analogous to a  [0'-|_]  pattern in Prolog, yes
01:04:18 <couloir> ski, thanks for the help
01:04:24 <couloir> much appreciated!
01:04:45 <ski> (clarification : what is done with functions in Haskell is usually done with predicates in Prolog - adding an auxilary "result" argument, if need be. Prolog doesn't really have functions, *except* what it calls "functors", like the `left' and `right' above .. these are very similar to data constructors in Haskell, and work similarly)
01:05:38 <couloir> ah
01:05:45 <couloir> similar to is?
01:06:07 <Jedai> Saterus: well ask away, we'll see if we have the answer
01:06:37 <ski> (and the `[Head|Tail]' syntax in Prolog is syntactic sugar for `.(Head,Tail)', i.e. the "functor" (read "data constructor") named `.', applied to two arguments `Head' and `Tail' .. similar to `head : tail' (or `(:) head tail', if you will) in Haskell)
01:08:03 <ski> (couloir : (is)/2 in Prolog is a very different beast .. it is basically a "functional" mini-language for expressing arithmetic, with a few built-in functions .. the (is)/2 predicate (at least conceptually) interprets this language)
01:09:35 <Saterus> i'm trying to do some fairly simple regex stuff and am having a terrible time with it. i'm trying to get the match function to give me what was matched inside the first regex subgroup, but it will only give me the entire match.
01:10:04 <wli> Prolog is pretty spiffy. If I understood any of the Prolog implementations I'd do PTTP (Prolog Technology Theorem Prover) semantics.
01:10:09 <couloir> i see... the prolog equivalent of a function is a predicate which takes the prospective result in addition to the other arguments and is true if the expression is satisfied
01:10:43 <ski> wli : the latter meaning ?
01:11:05 <ski> (i.e. "PTTP semantics")
01:11:09 <wli> Iterative deepening (or, naively, breadth-first search) instead of depth-first search.
01:11:11 <Saterus> "sometext (i-want-this-group) morestuff" => \1 is what i'm after
01:11:59 <Saterus> i've spent an hour or so looking over the haskell regex stuff and it may be powerful, but so far it's been over my head and i've got little to show for it.
01:14:08 <dmwit> Saterus: The relevant functions are polymorphic in their return type.
01:14:14 <dmwit> One of the return types returns match groups.
01:14:37 <dmwit> Give me a sec to look at the docs and I'll try to say more specific things.
01:16:00 <Saterus> yeah, i've read all about how the stuff is polymorphic and i'm sure there's something in there that does what i want.
01:16:11 <dmwit> :t (=~)
01:16:13 <lambdabot> forall source1 source target. (regex-base-0.72.0.2:Text.Regex.Base.RegexLike.RegexMaker Regex CompOption ExecOption source, regex-base-0.72.0.2:Text.Regex.Base.RegexLike.RegexContext Regex source1
01:16:13 <lambdabot> target) => source1 -> source -> target
01:16:24 <Cale> What is it that you'd like to do?
01:17:25 <dmwit> Saterus: There's an instance for (AllTextSubmatches (Array Int) b) that sounds relevant.
01:17:36 <ski> (.. that's one mouthful of a type signature :)
01:17:51 <Saterus> "source_text_to_be_matched" =~ "myregex(the_group_i'm_interested_in)more_regex" and i want the group's match
01:18:02 <Saterus> in any other language, you'd just use \1
01:18:07 <dmwit> :t ("abc" =~ "def(ghi)jkl") ! 1
01:18:08 <lambdabot> forall i e. (regex-base-0.72.0.2:Text.Regex.Base.RegexLike.RegexContext Regex [Char] (Array i e), Num i, Ix i) => e
01:18:21 <dmwit> actually
01:18:22 <Saterus> yeah, i've played around with that a bit. havent gotten anything working...
01:18:23 <dmwit> :t ("abc" =~ "def(ghi)jkl") ! 0
01:18:24 <lambdabot> forall i e. (regex-base-0.72.0.2:Text.Regex.Base.RegexLike.RegexContext Regex [Char] (Array i e), Num i, Ix i) => e
01:19:11 <dmwit> ?index (=~)
01:19:12 <lambdabot> bzzt
01:22:21 <ac> what's the deal with their being a "safe" package and a "Safe" package, and they collide
01:22:30 <RayNbow> g'morning #haskell :)
01:22:57 <ac> it's the middle of the night, you insensitive clod
01:22:57 <hackagebot> serial 0.2.2 - POSIX serial port wrapper (FrederickRoss)
01:23:36 <RayNbow> ac: it's 10:22 AM where I live :p
01:28:07 <Cale> > "43271894abcde" =~ "([0-9]*)([a-z]*)" :: [[String]]
01:28:08 <lambdabot>   [["43271894abcde","43271894","abcde"],["","",""]]
01:28:18 <Cale> > "43271894abcde" =~ "([0-9]+)([a-z]+)" :: [[String]]
01:28:20 <lambdabot>   [["43271894abcde","43271894","abcde"]]
01:28:40 <Saterus> the only function i've got working is "match". i call "match regex text" and it gives me the entire match, which is reasonable since that's what its supposed to do. i can't figure out how to get either =~ or the subgroup specific methods to work.
01:28:41 <Cale> Saterus: ^^ that example may help
01:28:54 <Cale> Saterus: Which version are you using though?
01:29:15 <Saterus> Text.Regex.Posix
01:29:34 <Cale> What about the version of regex-base?
01:29:59 <Cale> If it's 0.7x.* then the interface will be like the one lambdabot has, I think.
01:30:37 <Saterus> the way i understood was that you had to use one of the backends. that base didnt actually give you anything by itself.
01:30:44 <Cale> But with the newer version 0.93.1, there are some functions to indicate more directly what you want instead of leaving it all up to the type
01:30:51 <Saterus> and posix is in the 0.94 on hackage
01:30:59 <Cale> right, but it requires regex-base
01:31:16 <Cale> (and key parts of it are in that package)
01:31:48 <Cale> (in particular, the "UI" for how you're using the regex stuff, rather than the backend stuff of how matching is carried out)
01:32:08 <Cale> Prelude Text.Regex.Posix> getAllTextSubmatches ("43271894abcde" =~ "([0-9]*)([a-z]*)") :: [String]
01:32:08 <Cale> ["43271894abcde","43271894","abcde"]
01:32:10 <Saterus> yeah, ive got base and posix imported
01:32:22 <Cale> That's using the new version
01:32:25 <Saterus> hmm
01:32:28 <Cale> 0.93.1
01:32:51 <Cale> With the older version that comes with GHC, getAllTextSubmatches doesn't exist.
01:33:04 <Cale> (and the one on lambdabot... I could update it)
01:33:36 <Cale> If you see a line like  Loading package regex-base-0.93.1 ... linking ... done.
01:33:44 <Cale> then you should be good to use the new interface :)
01:34:19 <Saterus> yeah, both cabal and ghci are indicating that i have 0.93.1
01:34:37 <Cale> > getAllTextSubmatches ("43271894abcde" =~ "([0-9]*)([a-z]*)") :: [String]
01:34:38 <lambdabot>   Could not find module `Text.Regex.Posix':
01:34:38 <lambdabot>    it is a member of the hidden p...
01:34:42 <Cale> ah :)
01:36:06 <RayNbow> Cale, are you good at naming functions?
01:36:06 <Cale> Saterus: oh, also, since ghc comes with an older regex-posix and regex-base you can tell it you don't want to use those by hiding them
01:36:25 <Cale> ghc-pkg hide regex-base-0.72.0.2
01:36:31 <Cale> ghc-pkg hide regex-posix-0.72.0.3
01:36:52 <Cale> (this is if you're using 6.10.3)
01:36:59 <Cale> > getAllTextSubmatches ("43271894abcde" =~ "([0-9]*)([a-z]*)") :: [String]
01:37:12 <lambdabot>   ["43271894abcde","43271894","abcde"]
01:37:22 <Cale> huh, I wonder what happened to lambdabot just there
01:37:32 <Cale> I didn't kill it :)
01:37:41 <Cale> Oh well, whatever, it's back :)
01:37:57 <Cale> RayNbow: I can try :)
01:38:31 <Saterus> Cale: ghci, cabal, and ghc-pkg all agree that i have 0.93.1 installed for both Base and Posix.
01:38:45 <Cale> Saterus: and no older versions are visible?
01:38:48 <Saterus> nope
01:38:52 <RayNbow> Cale: last night (about 7-8 hours ago) we were trying to find a name for http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5986#a5986 (somewhat graphically: http://img189.imageshack.us/img189/5545/accumcompose.png )
01:38:53 <Cale> okay, good :)
01:39:00 <RayNbow> Gracenotes came up with the name accumCompose
01:40:19 <RayNbow> (in that image I should actually have used squiggly arrows, so the type would read as [a ~> a] -> (a ~> [a]))
01:40:30 <dmwit> :t scanl
01:40:31 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
01:40:43 <dmwit> :t scanl (.)
01:40:45 <lambdabot> forall c a. (a -> c) -> [a -> a] -> [a -> c]
01:41:00 <dmwit> > scanl (.) id [f, g, h] x
01:41:02 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr -> t'
01:41:03 <dmwit> uh
01:41:10 <RayNbow> from the logs: <Pseudonym> RayNbow: We don't have a good name for scanl (flip ($)) a fs either
01:41:13 <Cale> :t flip runContT return . sequence . map ContT
01:41:14 <lambdabot> forall a (m :: * -> *). (Monad m) => [(a -> m [a]) -> m [a]] -> m [a]
01:41:16 <dmwit> :t scanl ($)
01:41:17 <lambdabot>     Occurs check: cannot construct the infinite type: b = b1 -> b
01:41:17 <lambdabot>     Probable cause: `$' is applied to too many arguments
01:41:17 <lambdabot>     In the first argument of `scanl', namely `($)'
01:41:20 <dmwit> bleh
01:41:27 <ski> @type scanl (flip ($))
01:41:29 <lambdabot> forall b. b -> [b -> b] -> [b]
01:41:33 <Cale> m = (->) r  and you have your function :)
01:41:42 <Cale> (I think)
01:41:52 <dmwit> > scanl (flip ($)) x [f, g, h]
01:41:54 <lambdabot>   [x,f x,g (f x),h (g (f x))]
01:41:55 <ski> @type scanM (flip ($))
01:41:56 <lambdabot> forall r (m :: * -> *). (Monad m) => r -> [r -> m r] -> m [r]
01:42:12 <Cale> er..
01:42:34 <Cale> oh, no, I've done something strange :)
01:42:43 <Saterus> Cale: thanks for the pointers. I finally got it matching my subgroup.
01:42:52 <ski> @type map ContT
01:42:54 <lambdabot> forall a (m :: * -> *) r. [(a -> m r) -> m r] -> [ContT r m a]
01:43:00 <RayNbow> @unmtl ContT
01:43:00 <lambdabot> err: `ContT' is not applied to enough arguments, giving `/\A B C. (C -> B A) -> B A'
01:43:11 <RayNbow> @kind ContT
01:43:11 <ski> @unmtl ContT o m a
01:43:12 <lambdabot> * -> (* -> *) -> * -> *
01:43:13 <lambdabot> (a -> m o) -> m o
01:43:16 <dmwit> RayNbow: It's like it outputs evaluation steps of a pipeline; I'd want the name to reflect that somehow...
01:43:27 <dmwit> Maybe just "pipeline". =)
01:43:29 <ski> (Cale : i *was* wondering .. :)
01:43:37 <Cale> I think I misread what was going on without thinking about it enough :)
01:44:38 <Cale> :t runCont . sequence . map Cont
01:44:39 <lambdabot> forall a r. [(a -> r) -> r] -> ([a] -> r) -> r
01:44:48 <RayNbow> dmwit: the word pipeline did pop in my head, but I thought it didn't capture the existence of intermediate output
01:44:58 <Cale> was the thing I was thinking of, but I'm not sure why I thought of it
01:45:34 <ac> are there any editors out there or vim scripts that understands haskell code well enough for good code navigation?
01:46:12 <ac> so for exmalpe I could hit ctrl+] on a function name and it would take me to the definition
01:46:27 <tux-foo> twanvl, ping
01:46:42 <RayNbow> http://projects.haskell.org/haskellmode-vim/ <-- ac?
01:46:52 <RayNbow> although I haven't tried it
01:48:07 <doserj> ac: there is hasktags, which can generate ctags and etags files
01:48:57 <RayNbow> > [(a,b,c) | a <- [0..5], b <- [0..a], c <- [0..b]]  -- btw, trying to generalize this brought me to finding a function :: [a -> m a] -> (a -> m [a])
01:48:59 <lambdabot>   [(0,0,0),(1,0,0),(1,1,0),(1,1,1),(2,0,0),(2,1,0),(2,1,1),(2,2,0),(2,2,1),(2...
01:49:46 <Cale> I like sequenceK as a name
01:51:03 <ski> it doesn't seem very related to `sequence', imo
01:54:05 <hackagebot> fractal 0.0 - Draw Newton, Julia and Mandelbrot fractals (MaxRabkin)
01:55:35 <ac> RayNbow: ooh, that looks good. Just installed it. A tag creation function is included in that vba, but I can't figure out how to run it
01:58:34 <Cale> ski: It seems very much like sequence to me.
01:58:39 <ac> although I use vim a lot, I don't really know any advanced vim stuff. The function is mapped as <LocalLeader>ct, but I don't know what <LocalLeader> is
01:58:53 <dmwit> often \
01:58:57 <dmwit> or `
01:59:12 <Cale> sequenceK []     x = return []
01:59:12 <Cale> sequenceK (f:fs) x = do y <- f x
01:59:12 <Cale>                         ys <- sequenceK fs y
01:59:12 <Cale>                         return (y:ys)
01:59:22 <Cale> Delete the extra parameter, and you have sequence
01:59:28 <ac> dmwit: so how do I run it?
01:59:40 <ac> ":\ct" is a syntax error
01:59:41 <dmwit> `ct or \ct
01:59:44 <dmwit> no :
01:59:49 <dmwit> Just in command mode. =)
01:59:54 <ac> none of the other options do anything
02:00:12 <ac> (without :)
02:00:21 <Cale> sequenceK . map const = const . sequence
02:00:31 <dmwit> ac: Time to try :help LocalLeader, then. ;-)
02:00:38 <ac> already did that
02:01:46 <ski> @src sequence
02:01:47 <lambdabot> sequence []     = return []
02:01:47 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
02:01:47 <lambdabot> --OR
02:01:47 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
02:02:24 <ski> the threading of the extra parameter in `sequenceK' is unlike what happens in `sequence' .. i don't think it's very similar
02:02:33 <Cale> Well, it's a generalisation
02:03:07 <ski> it's more like a cross of a `scanl' and a `compose', imo
02:03:31 <ac> dmwit: ah, it's "_", but ct isn't defined for some reason
02:03:41 <Cale> Each of the actions being sequenced has become a Kleisli arrow, and is able to pass its result to the next Kleisli arrow in the sequence.
02:04:20 <ski> you mean  a -> m a  ~=  a -> m (a,())  ~=  StateT a m ()  ?
02:05:02 <RayNbow> http://i296.photobucket.com/albums/mm178/ShinNoNoir85/accumCompose.png
02:05:13 <RayNbow> ^ I've updated the image a bit :p
02:05:29 <RayNbow> squiggly arrows and some subscripts :p
02:13:43 <augur> RayNbow: whats this do?
02:14:23 <RayNbow> augur: the function in the image?
02:14:33 <augur> yeah, whatever it is that you're describing in the image
02:16:04 <RayNbow> augur: it's basically composing a list of functions
02:16:17 <augur> i see
02:16:19 <RayNbow> but the intermediate output of each function is collected
02:16:37 <RayNbow> if you leave out the branching
02:16:37 <augur> interesting
02:16:39 <RayNbow> you'd have:
02:17:49 <augur> shouldnt it be :: forall a. forall b. [a -> b] -> a -> [b]?
02:17:55 <augur> no, it shouldnt.
02:17:57 <augur> sorry. :D
02:18:03 <augur> getting ahead of myself.
02:18:15 <augur> so what inspired this function?
02:18:32 <Cale> augur: make sure you see http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5986#a5986
02:18:58 <RayNbow> I've also added a few IRC snippets to that paste
02:19:07 <ski> <RayNbow> > [(a,b,c) | a <- [0..5], b <- [0..a], c <- [0..b]]  -- btw, trying to generalize this brought me to finding a function :: [a -> m a] -> (a -> m [a])
02:19:33 <augur> cale: wat
02:19:42 <Cale> augur: That's what we're actually talking about
02:19:48 <augur> oh ok.
02:20:29 <pozic> How can I obtain the unparsed text in Parsec? I have some parser foo = do string "hi";newline; unparsed_stuff <- somefunctionhere;return unparsed_stuff and when I apply it to input "hi\nfoobarbaz" it should return "foobarbaz".
02:22:35 <ac> I don't think I have complete haddock docs for the standard libraries
02:22:43 <Cale> pozic: I think it's  fmap stateInput getParserState, if there's nothing nicer
02:22:55 <Cale> ah,  getInput
02:23:12 <doserj> unparsed_stuff <- lookAhead (many anyToken) :)
02:23:16 <ac> haskellmode isn't showing docs or finding imports for things like "random"
02:23:31 <ac> bet is for "getArgs"
02:23:52 <Cale> ac: Does haskell-mode parse haddock now?
02:25:29 <mlesniak> Is there a specific function to change the nth element of a list (i.e. (!!) for lists)? Data.List does not seem to have such a thing.
02:26:08 <ac> Cale: it must be if it's opening docs and finding names in modules for some things, right?
02:26:10 <RayNbow> mlesniak: are you sure you want that?
02:26:29 <mlesniak> RayNbow: The lists I need this for a typically smaller than 10 ;-)
02:26:46 <Cale> ac: I haven't used it in a really long time now
02:27:15 <mlesniak> RayNbow: Of course, I can write this by myself, I was just wondering why no such thing exists (even with a big warning sign about performance)
02:27:27 <RayNbow> mlesniak: how about using Data.Sequence?
02:27:42 <RayNbow> http://hackage.haskell.org/packages/archive/containers/0.2.0.1/doc/html/Data-Sequence.html#v%3Aupdate
02:27:56 <Cale> mlesniak: I don't think there is one in the standard libraries, but in cases where I've needed it, I usually write applyAt
02:28:16 <mlesniak> RayNbow, Cale: Thanks
02:28:23 <Cale> I suspect Data.Sequence may actually be a little slower for such small lists.
02:28:31 <Cale> (but maybe not)
02:28:38 * ski . o O ( `(!!<-) :: Integral i => [a] -> i -> (a -> a) -> [a]' ? )
02:29:34 * RayNbow blinks at ski
02:29:37 <RayNbow> thought bubbles? :p
02:30:00 <Cale> I think I might prefer the second and third parameters flipped
02:30:01 <ski> something like that, yes
02:30:55 <ski>   (xss !!<- j) $ \xs ->
02:31:01 <ski>   (xs !!<- i) $ \x  ->
02:31:02 <ski>   foo (i,j) x
02:31:20 <ski> that's the reason for the argument order
02:31:23 <Cale> Ah, that is an interesting use
02:31:26 <ac> sweet!: ghc Main.hs -e :ctag
02:31:31 <ac> hasktags is not necessary at all
02:32:06 <Cale> I suppose any one of the parameters might be nicest last.
02:32:15 <ac> don't need haskellmode for that at all
02:32:34 <ski> for the "tail-nesting", we want the function argument last
02:34:00 <Cale> Putting the index last makes it easy to produce a list of variations of a list where the function has been applied at different places. Putting the list last makes it easy to apply the same point-transformation on many lists.
02:36:56 <ac> I wish ghc's tag file generation would follow imports in to libraries
02:42:30 <ac> I guess ghci uses hasktags
02:52:18 <ski> @type unfoldr
02:52:20 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
02:55:01 <ski> @type curry . unfoldr $ \(fs,a) -> case fs of [] -> Nothing; f:fs -> Just (a,(fs,f a))
02:55:03 <lambdabot> forall b. [b -> b] -> b -> [b]
02:57:10 <RayNbow> ski: have you seen FunctorSalad's unfold function?
02:57:17 <ski> > (curry . unfoldr $ \(fs,a) -> case fs of [] -> Nothing; f:fs -> Just (a,(fs,f a))) (map (*) [1..6]) 1
02:57:18 <lambdabot>   [1,1,2,6,24,120]
02:57:34 <ski> RayNbow : no .. where ?
02:57:40 <RayNbow> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5906#a5906
02:58:02 <Boxo> > heh :: (Bounded a) => a; heh = maxBound :: a
02:58:03 <lambdabot>   <no location info>: parse error on input `;'
02:58:22 <Boxo> I don't understand the error I get when I try to do the above...
02:58:43 <opqdonut> which error?
02:59:01 <Boxo> "could not deduce (Bounded a1) from the context ()"
02:59:39 <RyanT5000> is there a way to make "Setup configure" enable "-auto-all"?
03:00:01 <pozic> Cale: thanks
03:00:03 <Boxo> What is this a1 anyway, that's not mentioned in any type signature?
03:00:13 <ski> RayNbow : that seems just a Church-encoded `Maybe' version of `unfoldr' ..
03:01:13 <doserj> Boxo: try it without the ::a at the end
03:01:14 <RayNbow> ski: that was also Cale's remark
03:01:29 <doserj> Boxo: that a is different than the a in the type-signature...
03:01:32 <ski> Boxo : try removing the `:: a' ?
03:01:43 <opqdonut> yeah, you'd need -XScopedTypeVariables (or whatever it was called)
03:01:45 <opqdonut> to make it work like that
03:01:46 <Boxo> hey, it works. Thanks.
03:01:55 <ski> (or add a `forall a. ' to the type signature .. oh well)
03:03:23 * ski still thinks that choice is weird
03:03:27 <enriq> hello I try to ¨cabal install yi¨ on windows, ghc 6.10.3... It fails because unix-2.3.2.0 fails to install... any clue?
03:04:22 <voker57_> is yi supported on windows?
03:04:52 <enriq> why not?
03:05:05 <voker57_> because it requires 'unix' package?
03:07:10 <enriq> ah you´re right looks like no
03:09:14 <enriq> each day windows pushes me out further :)
03:16:32 <fasta> voker57_: cygwin is Unix on Windows for some very bad value of Unix.
03:23:38 <Baughn> fasta: Now, now. Windows is posix-compatibl (*snirk*), remember?
03:23:54 <fasta> Baughn: yes, if you install some extra stuff.
03:24:06 <Baughn> fasta: Which doesn't interoperate with the rest of the OS
03:24:20 <giulianoxt> fasta: like what?
03:27:21 <couloir> (easy) error message that i can't figure out... if anyone can give a tip: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5997#a5998
03:28:01 <couloir> line 48 is takeWhileFoldr _ [] = []
03:28:26 <opqdonut> couloir: acc : [x] is the problem
03:28:32 <opqdonut> you probably wanted to say acc ++ [x]
03:28:39 <augustss> one of the problems
03:28:45 <opqdonut> but i recommend collecting the list in reverse order, x:acc
03:28:50 <dibblego> foldr step ([], False) xs :: ([a], Bool)
03:28:53 <Baughn> acc ++ [x] would be a problem in itself
03:29:23 <doserj> '== True' is another problem :)
03:30:05 <couloir> the problems are undoubtably numerous
03:30:14 <augustss> what is the function supposed to do anyway?
03:30:24 <couloir> takeWhile a predicate is true
03:30:39 <augustss> but that's what takeWhile does
03:30:45 <Baughn> @src takeWhile
03:30:45 <lambdabot> takeWhile _ []                 =  []
03:30:45 <lambdabot> takeWhile p (x:xs) | p x       =  x : takeWhile p xs
03:30:45 <lambdabot>                    | otherwise =  []
03:30:48 <couloir> i think that's the point of the exercise
03:31:03 <Baughn> Exercise? ..oops
03:31:06 <augustss> Ah, you're supposed to write takeWhile in terms of foldr?
03:31:33 <Baughn> That would be a bit odd, since foldr can'T abort in the middle
03:31:47 <Baughn> unfoldr'd be bette
03:31:50 <Baughn> r
03:31:55 <couloir> i am attempting to use a sentinel to tell it to just keep on goin' without accumulating
03:32:17 <Baughn> couloir: Yes, it's certainly /possible/
03:32:18 <Baughn> Just.. odd
03:32:36 <augustss> Baughn: foldr can abort in the middle
03:32:43 <couloir> any ways of getting foldr to abort?
03:33:07 <augustss> couloir: yes, ignore the accumulated value passed in
03:33:18 <augustss> to f
03:33:23 <couloir> will do
03:33:40 <pozic> When I use getInput and them trace to show the unparsed string, and then copy that into a Haskell literal string and parse that with parser p it gets parsed. However, when I place p directly after getInput, it doesn't. It might be the case that some different character representations are being lost in the show/copy paste action. How can I see what getInput really returns?
03:33:51 <pozic> s/them/then
03:34:01 <Baughn> @type foldr
03:34:03 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
03:34:16 <Baughn> Oh. Doh. Laziness.
03:34:29 <Baughn> I have a love-hate relationship with that thing
03:37:52 <augustss> couloir: if it's any help: the solution is really simple
03:38:37 <quicksilver> pozic: use 'show' on it.
03:38:54 <quicksilver> pozic: 'show' for String produces a non-ambiguous 7-bit clean representation.
03:40:59 <couloir> augustss: yeah, i suppose that's why RWH wants me to use foldr :)
03:41:23 <pozic> quicksilver: I did, and copied that from the Emacs buffer to another buffer containing a Haskell source file where I defined myString = "<copied value>"
03:41:50 <pozic> quicksilver: applying the parser on that works, but not on the original input. Kind of puzzling.
03:42:22 <quicksilver> @hoogle trace
03:42:22 <lambdabot> Debug.Trace trace :: String -> a -> a
03:42:22 <lambdabot> module Debug.Trace
03:42:22 <lambdabot> package traced
03:42:35 <quicksilver> pozic: did you really call show? trace takes a string directly so you aren't forced to
03:42:38 <quicksilver> that's why I asked.
03:43:57 <augustss> couloir: foldr f replaces each : if the original list by f.  Just think about what you want to happen instead of :
03:43:59 <pozic> quicksilver: I didn't do the first time. It was a good suggestion.
03:44:11 <pozic> quicksilver: but I was talking about the second time.
03:44:14 <quicksilver> ah.
03:44:26 <quicksilver> I agree that is puzzling
03:45:01 <couloir> augustss: pullEjectLever
03:45:31 <pozic> quicksilver: In fact, it shows something which is kind of weird: for trace ("foo:\n" ++ show fullInput) it shows fromList foo: "some string".
03:45:51 <pozic> quicksilver: foo should come first, but it doesn't.
03:46:19 <couloir> augustss: that is a helpful way of thinking of it, thanks :)
03:50:12 <quicksilver> pozic: the foo is coming first?
03:50:20 <quicksilver> pozic: or do you mean, relative to the fromList?
03:50:32 <quicksilver> because you didn't show me enough code to decide where the fromList comes from
03:52:09 <pozic> quicksilver: I am trying to isolate the problem further. I already figured out where the fromList comes from, however (it computes a Map).
03:57:29 <couloir> augustss: i feel as if this should work, but still get occurs check error: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5997#a6000
03:58:09 <doserj> couloir: think about that otherwise case again
03:58:55 <doserj> and why do you have takeWhileFoldr p [xs] ?
03:59:12 <couloir> good question
03:59:20 <fasta> couloir: x and x:acc do not have the same type. This is completely ignoring any other semantics.
04:00:09 <couloir> fasta, how about [x] and x:acc?
04:00:20 <fasta> couloir: now you are just guessing.
04:00:55 <fasta> couloir: you should figure it out for yourself. That's much more instructive.
04:02:23 <couloir> the error remains with [x], and i really have no idea where the issue is
04:03:38 <doserj> couloir: also, think about the argument order of the folding function
04:08:43 <enriq> I try to install Yi. It complains that it does not find alex, I [cabal install] alex (as the yi wiki suggests), but still [cabal install yi] complains. Any suggestion?
04:09:22 <enriq> I guess ~/.cabal/share is not scaned for alex?
04:09:58 <doserj> alex is a binary. so ~/.cabal/bin should be in your path
04:10:28 <enriq> doserj: right, thanks
04:13:30 <enriq> doserj: it´s in the path now but still complains
04:18:25 <enriq> hmmm ¨alex¨ is found in the path but ¨sudo alex¨ would not find it... a path pb it seems
04:20:14 <Jedai> enriq: I would rather suggest putting a symbolic link to ~/.cabal/bin/alex in your /usr/local/bin, you can even automatize it (look at the config in ~/.cabal)
04:24:28 <sioraiocht> when using the monoid class, `mappend` is rather wordy, is there a standard infix operator to substitute?
04:25:09 <byorgey> sioraiocht: ++
04:25:17 <sioraiocht> byorgey: thanks =)
04:26:16 <couloir> doserj: figured it out. thanks for the help
04:26:27 <byorgey> the point being, of course, that if you import Prelude hiding (++) and redeclare (++) to be mappend, any existing uses of ++ will continue to work correctly.
04:26:34 <lilac> Do any monads other than (->) have an extract :: m (m a -> a), such that: extract >>= \ex -> mx >>= return . (ex . f)  ==  mx >>= f
04:27:05 <lilac> "(->) b" rather :)
04:30:06 <quicksilver> sioraiocht: I'm in favour of +>
04:30:13 <quicksilver> sioraiocht: keep meaning to make it a libraries proposal.
04:30:32 <sioraiocht> quicksilver: can I ask why?
04:30:34 <byorgey> lilac: hmm, I can see how to implement  extract  for the state monad, not sure if it would satisfy that law.
04:30:55 <quicksilver> sioraiocht: because monoids in general are not commutative (in particular, neither [a] nor a -> a, are)
04:31:02 <quicksilver> sioraiocht: so I prefer an asymmetric symbol.
04:31:10 <sioraiocht> bair enough =)
04:31:13 <sioraiocht> *fair
04:31:15 <quicksilver> sioraiocht: frees you up to have <+ as flip mappend, which is very logical.
04:31:23 <sioraiocht> quicksilver: agreed
04:31:27 <byorgey> hmm, I like that too.
04:39:57 <thetallguy> Anyone familiar with how to avoid the 'too many hs_exit()s' warning when exiting a GLUT program?
04:40:41 <thetallguy> The standard exit on escape in the examples throws it: keyboardMouse (Char '\27') Down _ _ = exitWith ExitSuccess
04:49:51 <mola89> hi
04:49:55 <mola89> hello to all
04:51:17 <trez> hi
04:54:44 <enriq> anyone knows how to set yi to gtk?
04:56:10 <voker57_> startFrontEnd = Yi.UI.Gtk.start
04:56:50 <chidinma> Hi, I am trying to install utf8-string-0.3.5 on ubuntu jaunty
04:56:58 <chidinma> sudo runhaskell ./Setup.lhs configure
04:56:58 <chidinma> Configuring utf8-string-0.3.5...
04:57:03 <chidinma> sudo runhaskell ./Setup.lhs install
04:57:03 <chidinma> Installing: /usr/local/lib/utf8-string-0.3.5/ghc-6.8.2
04:57:04 <chidinma> Setup.lhs: Error: Could not find module: Codec.Binary.UTF8.String with any suffix: ["hi"]
04:57:39 <enriq> voker57_: k thanks
04:57:47 <lilac> byorgey: the 'obvious' implementation for State isn't the same; it applies the state transformation from the left-hand side of >>= only
04:57:52 <enriq> Jedai: thanks for the suggestion
04:58:11 <byorgey_> ok, yeah, I figured something like that would go wrong
04:58:27 <lilac> byorgey: ... the 'obvious' implementation being  extract = State $ \s -> (\(State f) -> fst (f s), s)
04:58:57 <byorgey> right, that's what I had in mind
05:00:00 <mmorrow> @type State (\s -> (\(State f) -> (fst (f s), s)))
05:00:01 <lambdabot>     The lambda expression `\ (State f) -> ...' has one argument,
05:00:01 <lambdabot>     but its type `(a, s)' has none
05:00:01 <lambdabot>     In the expression: (\ (State f) -> (fst (f s), s))
05:00:20 <mmorrow> oh
05:00:32 <mmorrow> @type State (\s -> (\(State f) -> fst (f s), s))
05:00:33 <lambdabot> forall s t. State s (State s t -> t)
05:00:45 <mmorrow> thought you missed a paren there..
05:03:23 <mmorrow> @let loeb = fix (\k f a -> fmap ($ k f a) a)
05:03:25 <lambdabot>  Defined.
05:03:35 <mmorrow> @type loeb (State (\s -> (\(State f) -> fst (f s), s)))
05:03:37 <lambdabot> forall (f :: * -> *) b. (Functor f) => f (f b -> b) -> f b
05:03:55 <mmorrow> um
05:04:20 <mmorrow> @type let x = (State (\s -> (\(State f) -> fst (f s), s))) in loeb x
05:04:22 <lambdabot> forall (f :: * -> *) b. (Functor f) => f (f b -> b) -> f b
05:04:27 <mmorrow> oo
05:04:39 <byorgey> @type loeb
05:04:40 <lilac> @type let x = (State (\s -> (\(State f) -> fst (f s), s))) in loeb x x
05:04:41 <lambdabot> forall t (f :: * -> *) b. (Functor f) => t -> f (f b -> b) -> f b
05:04:42 <lambdabot> forall s b. State s b
05:04:51 <mmorrow> ah
05:04:52 <mmorrow> :)
05:05:08 <byorgey> there is something strange about that definition of loeb... =)
05:05:12 <mmorrow> i botched loeb
05:05:30 <mmorrow> @let loeb' = fix (\k a -> fmap ($ k a) a)
05:05:32 <lambdabot>  Defined.
05:05:38 <mmorrow> @type loeb'
05:05:40 <lambdabot> forall (f :: * -> *) b. (Functor f) => f (f b -> b) -> f b
05:05:45 <byorgey> ah, much better =)
05:05:47 <mmorrow> @type loeb' (State (\s -> (\(State f) -> fst (f s), s)))
05:05:48 <lambdabot> forall s b. State s b
05:06:53 <helgim_> +OK ES9VO.sr3If.CHABx./lOTQ/32m.v/B8qJ./nA9zC16BxSK06oNsQ0BwQmF/Z6YbD/EDCJD1KgYzI1hyHHI/PBHnn/jkoav.03ZBW1lu9at/eK9Hp.rNDwK0o0nlu/YtWdL1O9AoJ/iqJOc.
05:07:54 <byorgey> um. is that suppose to be some kind of IRC exploit?
05:08:09 <burp> fish encryption plugin
05:08:34 <burp> I guess
05:09:50 <Raevel> remember the good old days when you could crash peoples mirc by sending them a malformed dcc?
05:10:02 <medfly> you still can for some :-/
05:11:41 <helgim_> Oh fantastic. sorry about that
05:11:48 <helgim_> "can someone give me an example of a function with type sig: (a -> Bool) -> [a] -> (a, [a]) ?" :)
05:12:13 <lilac> undefined
05:12:19 <lilac> did you want a total function? :)
05:12:38 <lilac> @hoogle (a -> Bool) -> [a] -> (a, [a])
05:12:39 <lambdabot> No results found
05:12:40 <helgim_> I'm only not sure how I can extract an 'a' from a list, to return a pair with that element extract, plus the full list
05:12:54 <turingtest> helgim_: What if the input list is empty ??
05:12:55 <lilac> helgim_: there is no total function of that type
05:13:48 <helgim_> Ah, so I'll have to use a function (or two, or three) to achieve that result?
05:13:52 <lilac> helgim_: but you might like \f xs -> (fromJust $ find f xs, filter (not . f) xs)
05:14:17 <byorgey> "plus the full list"? you mean with or without the found element?
05:14:30 <doserj> f = (head . filter p) &&& id ?
05:14:33 <lilac> helgim_: the point is, there is no function which cannot fail which has that type. the possibility of failure is inherent because if the list is empty, we cannot construct the first element of the pair
05:15:12 <helgim_> +OK YL3gV/rF517.k6FHy/FlAaf02GEY4/H4RLz0FTITZ/CAtwt/jpoLg.z.2hy1lad7N1h59mk08Y4ds0xT4fX/5LMGh08TSE50m/0S819OOD608S1O31tJWDd1iV/LT0FH5LW.mD8ET1gPR.k0ZsB0R1Yhmxz1kyPEX/SOcnh09JZw/1qGj58/
05:15:52 <helgim_> bleh. I'll go disable that plugin
05:16:48 <flipflap> Why is it called "IOException" on Windows and "Exception" on Linux?
05:16:50 <flipflap> ;S
05:17:09 <mmorrow> there are both
05:17:15 <lilac> helgim_: alternatively, you might want: remove f [] = error "No match"; remove f (x:xs) | f x = (x, xs) | otherwise = let (y, ys) = remove f xs in (y, x:ys)
05:17:19 <mmorrow> @hoogle catch
05:17:20 <lambdabot> package catch
05:17:20 <lambdabot> Prelude catch :: IO a -> (IOError -> IO a) -> IO a
05:17:20 <lambdabot> Control.Exception catch :: IO a -> Exception -> IO a -> IO a
05:17:51 <mmorrow> @type catch :: IO a -> (IOException -> IO a) -> IO a
05:17:53 <lambdabot>     Not in scope: type constructor or class `IOException'
05:18:02 <mmorrow> @type catch :: IO a -> (SomeException -> IO a) -> IO a
05:18:03 <lambdabot>     Not in scope: type constructor or class `SomeException'
05:18:33 <lilac> helgim_: or \f -> filter f &&& filter (not . f), but that's (a -> Bool) -> [a] -> ([a], [a])
05:19:50 <helgim_> +p lilac: Ah okay. I'll dig through that and see whether I can't comprehend that that's doing or not. Thank you
05:31:34 <yowgi> hello! I have a question about fft. I don't understand why (ifft . fft) [a,b,c,d] gives me [a,d,c,b]. i.e. I only get the original list by keeping the head and reversing the tail. Why is that?
05:32:00 <LeCamarade> ?where catch
05:32:00 <lambdabot> http://community.haskell.org/~ndm/catch/
05:32:09 <turingtest> yowgi: Perhaps I should ask: what is fft ?
05:32:38 <yowgi> Numeric.FFT.fft - Fast Fourier Transform
05:33:42 <Lord_Duffler> hey
05:38:59 <ac> the happstack tutorial is slightly out of date :-[. simpleHTTP' doesn't seem to exist anymore, and simpleHTTP has a slightly different type signature
05:39:30 <ac> (second argument is now a list)
05:39:47 <oal> happstack is forked
05:40:35 <ac> you mean the HAppS vs happstack fork, or has there been another?
05:42:07 <byorgey> hey Lord_Duffler
05:42:38 <mmorrow> , fft [0..2^14-1]
05:42:40 <lunabot>  luna: No instance for (GHC.Enum.Enum
05:42:48 <mmorrow> , fft (fmap fromIntegral [0..2^14-1])
05:42:53 <lunabot>  [1.34209536e8 :+ 0.0,(-8192.000000011176) :+ 4.27228291999282e7,(-8192.0)...
05:44:02 <mmorrow> yowgi: yeah, i'm not sure what is usually done to re-arrange the array/vector/list in ifft. i think it's usually done manually?
05:45:32 <yowgi> ok thanks
05:45:46 <yowgi> i thought i had misunderstood something
05:45:59 <yowgi> i can work with (h:reverse t)
05:46:18 <CalJohn> I'm wanting to install parsec 3 through cabal, but even thought cabal seems to know that there is a v3 available, it only wants to download v2.1.  Why is that?
05:46:41 <Lord_Duffler> is -fvia-c now officially considered bad style?
05:47:04 <Lord_Duffler> CalJohn: old version of ghc maybe?
05:47:27 <CalJohn> Lord_Duffler: no, it was because cabal defaults to installing v2, v3 has to be asked for explictly
05:47:48 <mmorrow> yowgi: that's a good point though. there should be a function included that does the rearranging for you (whether that be in ifft itself or in a helper function). i'll add that.
05:47:57 <Lord_Duffler> it's just... I have this program which causes a seg fault when compiled with the -fvia-c option
05:48:31 <mmorrow> Lord_Duffler: are you FFI'ing to C libs in your code?
05:48:58 <mmorrow> Lord_Duffler: because if the segfault is ghc's fault then that's a serious bug
05:49:43 <mmorrow> (but if it's some C code's fault, then ...)
05:50:37 <Lord_Duffler> mmorrow: no, the file causing the problem is doing low level array operations though, but it's all haskell, and it crashes even when not using any "unsafe"
05:51:10 <mmorrow> Lord_Duffler: ah, which pkg are the arrays from?
05:51:54 <mmorrow> Lord_Duffler: (if uvector, iirc there are some functions which don't bounds check which aren't labeled unsafe)
05:52:31 <Lord_Duffler> STArray
05:53:01 <mmorrow> hmm, i'm not sure whether those bounds check
05:53:13 <fasta> mmorrow: they do.
05:53:38 <fasta> You need to use unsafe<something> to get rid of those.
05:53:40 <mmorrow> Lord_Duffler: do you have a small test-case showing a segfault
05:53:57 <mmorrow> (?)
05:54:11 <Lord_Duffler> actually..no, trying to make on though
05:54:21 * fasta thinks the problem lies somewhere else :)
05:54:22 <Lord_Duffler> *one
05:54:29 <Lord_Duffler> ohh great...
05:54:34 <Lord_Duffler> nevermind, not a ghc fault
05:54:43 <Lord_Duffler> it's gcc hating fast math apparently
05:54:46 <mmorrow> heh
05:54:47 * fasta loves being right
05:54:55 <Lord_Duffler> on windows only
05:56:01 <pozic> quicksilver: the problem was somewhere else. Thanks.
05:58:21 <Lord_Duffler> on another note.... if I wanted to do stuff like automaticly turning a call like "transpose(x) * y" into "tMatrixMult x y", I could do it with template haskell, no?
05:59:09 <Lord_Duffler> (x and y are matrices,  transpose, * and tMatrixMult are all custom functions, but I doubt it matters greatly)
06:00:03 <fasta> Lord_Duffler: in theory yes, in practice doing simple things in TH is not easy.
06:00:25 <fasta> Lord_Duffler: RULES might also work.
06:00:41 <mmorrow> hmm, yeah RULES might be nice for this
06:00:45 <doserj> I don't see how to do this with TH at all
06:00:52 <Lord_Duffler> tried rules, but the time ghc gets to them, the code is so rewritten that they never get fired
06:00:59 <mmorrow> Lord_Duffler: for TH you'd need to have something like a function:
06:01:06 <fasta> I never liked the RULES system.
06:01:19 <mmorrow> myTranformExpQ :: ExpQ -> ExpQ
06:01:27 <mmorrow> and then call it like
06:01:42 <mmorrow> $(myTransformExpQ [|transpose x * y|])
06:01:57 <Lord_Duffler> ohh...
06:02:13 <Lord_Duffler> seemed like such an elegant and simple thing to do. Guess not
06:02:23 <mmorrow> (but myTransformExpQQq wouuld need to be in a different module than the splice)
06:02:37 <mmorrow> s/Qq//
06:02:42 <fasta> Lord_Duffler: you can add a preprocessor too (which might parse the code and do the transformation)
06:03:03 <mmorrow> yeah, haskell-src-exts would be nice for that
06:03:05 <fasta> Lord_Duffler: you would only use that when you actually care about performance obviously.
06:03:07 <quicksilver> well I'm pretty sure this is exatly what rules are for.
06:03:28 <quicksilver> so if RULES really can't do it, that's probably an enhancement request.
06:03:37 <fasta> Yes, I think it is too. Still, doesn't change that I don't like the RULES system :)
06:03:54 <Lord_Duffler> quicksilver: I have rules like {-# RULES  "transposeRule" forall x y . matMult (transpose x) y = (tmatMult x y) #-} but no dice
06:04:16 <Lord_Duffler> mmorrow: ok, I'll take a look at that :)
06:04:43 <Lord_Duffler> fasta: I'm cursed with wanting to do numerics in haskell. I always care about performance
06:05:38 <fasta> Lord_Duffler: Haskell and numerics is not a  very good combination, currently, but that will probably change in about 5 years.
06:05:52 <mmorrow> Lord_Duffler: i've been experimenting with generating unrolled ffts (of fixed size, and just for lists so far)... the non-unrolled version takes 4 seconds on 10,000 size-64 lists, the fully unrolled version takes 0.8  seconds on the same load
06:06:06 <mmorrow> *huge* gain
06:06:12 <fasta> Lord_Duffler: but that doesn't mean that given enough effort you can't make it work fast.
06:06:27 <mmorrow> i think generating code is where it's at if you're doing it all in haskell
06:06:49 <Lord_Duffler> fasta: ohh, it's fast, I'd just like to end up with something that was nice enough to share with the world
06:07:15 <quicksilver> mmorrow: I heard you liked code generating code so I put a code generator in your code generator so you can....
06:07:27 <mmorrow> Lord_Duffler: here's that fft codegen code (uses TH, but it could just as well use haskell-src-exts or any haskell AST) http://moonpatio.com/repos/hsfft/
06:08:02 <mmorrow> quicksilver: just what i've always wanted!
06:08:33 <Lord_Duffler> mmorrow: awesome :)
06:09:16 <quicksilver> mmorrow: I have a vague idea for a database query engine which generates haskell (source) code and gets GHC to compile it with -O2 and possibly some custom rules.
06:09:43 <quicksilver> mmorrow: it sidesteps the probably of having separate domain types and native types, for one thing.
06:10:26 <mmorrow> Lord_Duffler: here's the generated code for ffts for powers of two upto 128 (just uploaded this file) http://moonpatio.com/repos/hsfft/fft_upto_128.hs
06:11:56 <mmorrow> quicksilver: totally. (so you mean somewhat similar to how haskelldb generates haskell modules for db definitions?) (but beyond that)
06:11:57 <saml> that's not how you write haskell. it's difficult to read for humans
06:12:03 <Lord_Duffler> mmorrow: nice and easy to read
06:12:07 <mmorrow> heh
06:12:22 <fasta> A right way to use rnf is simply let !_ = rnf big_value; big_value = [1..100000] in big_value, right?
06:13:21 <Lord_Duffler> saml: just proves you can do anything with haskell, even code obfuscation
06:13:27 <mmorrow> fasta: yeah, that or rnf x `seq` x
06:13:54 <mmorrow> bang patterns are prettier than seq though
06:14:21 <saml> @type rnf
06:14:23 <lambdabot> forall a. (NFData a) => a -> Done
06:14:29 <saml> > rnf 1
06:14:31 <lambdabot>   ()
06:14:39 <mmorrow> err yeah, so the "main" in that file just prints out "()" and is meant to be run like
06:14:43 <mmorrow> $ time ./foo
06:14:56 <mmorrow> (was just for the benchmark)
06:15:05 <quicksilver> mmorrow: the basis of a database query is often a chunk of code which is basically a predicate over bytes (an actual database row)
06:15:12 <quicksilver> mmorrow: that code is executed millions of times
06:15:38 <quicksilver> mmorrow: you really don't want the overhead of any kind of 'interpretation' there. But, in actual fact, many real DBs are doing some kind of execution of interpreted code at that point.
06:16:01 <mmorrow> quicksilver: hmm, wait are we talking about interfacing to an sql db engine, or doing it all in haskell?
06:16:05 <quicksilver> mmorrow: potential speed increase for having generated good quality native code which works direct on the bytes is high.
06:16:09 <quicksilver> mmorrow: doing it all in haskell.
06:16:14 <mmorrow> ahhh, cool.
06:17:19 <Lord_Duffler> quicksilver: making a piece of code to do the translation from sql to a similar haskell syntax should be relatively simple, shouldn't it?
06:17:30 <quicksilver> yes.
06:17:47 <quicksilver> but there is an optimisation step in between ;)
06:17:57 <quicksilver> you don't actually want to use a naive set of joins + restricts.
06:18:16 <mmorrow> the join optimizer would be the crux for sure
06:18:33 <mmorrow> err, restricts too
06:18:46 <mmorrow> and then there's indexing..
06:19:38 <mmorrow> quicksilver: what kind of (physical) db are you picturing?
06:20:20 <quicksilver> mmorrow: not sure how to answer that question.
06:20:41 <quicksilver> mmorrow: files which store variable length records, b*-tree indices, that sort of thing
06:20:41 <mmorrow> because my question is unclear?
06:20:47 <mmorrow> ah, ok sure.
06:20:57 <quicksilver> because my brain is unclear, probably ;)
06:21:16 <mmorrow> :)
06:21:49 <fasta> I don't understand why "modern" software always has to be slower than their 10+ year older counter-part, in this case konsole vs Emacs search.
06:21:50 <mmorrow> no totally, that's what i though you meant, but then wasn't sure
06:22:01 * Lord_Duffler was once told that anything with monads could be handled by van emde boas trees....
06:23:02 <Lord_Duffler> probably not the best choice for dbs though
06:23:21 <fasta> Lord_Duffler: What is the connection between the two? AFAIK, there isn't any. I do perfectly well know what problem the van emde boas trees solve.
06:23:46 <quicksilver> fasta: [pointless anecdote] I dug up an LCIII out of the attic; that's a 25mhz 68030 based Mac from the mid 90s.
06:24:12 <quicksilver> fasta: it booted fine, having been in an attic for 10 years, loaded the entire OS in about 6 seconds, and loaded a word processor with a (long) document in a further 1 second
06:24:15 <quicksilver> isn't progress great?
06:24:29 <fasta> quicksilver: progress is fantastic!
06:25:02 <fasta> quicksilver: my 286 bomberman game was about as much fun as on the XBox 360 :)
06:36:16 <Lord_Duffler> fasta: sorry, I had gotten it wrong. The dynamic word problem, for a group free monoid, can be solved using a fixed number of van emde boas trees
06:37:36 <Lord_Duffler> anyway, I'll try stop speaking rubish, and find some decent documentation for haskell-src-exts
06:39:16 <dschoepe> Is there a chance there will be some "normal-function"-version of if in the Prelude some day, like the if' that lambdabot uses?
06:40:14 <quicksilver> there is a chance
06:40:16 <doserj> not in the Prelude, but maybe in Data.Bool
06:40:31 <quicksilver> it doesn't have that many supporters though
06:40:41 <quicksilver> it's certainly never seemed important to me
06:41:20 <quicksilver> I think of 'if' as being shorthand for 'case' rather than an annoyingly non-first-class function.
06:41:26 <doserj> it is essential for writing pointless code :)
06:41:29 <mmorrow> Lord_Duffler: here're some nice quick utils that use haskell-src-exts that are useful in general http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5512#a5512
06:41:38 <quicksilver> if p then a else b is just slightly shortened version of case p of True -> a; False -> b;
06:41:43 <dschoepe> It isn't that important to me either, just would help pointfree-ing code
06:41:59 <mmorrow> Lord_Duffler: (the pExp in the first paste is bad though, the second paste has a better one)
06:43:15 <mmorrow> Lord_Duffler: and :info in ghci is great for stuff like this (with big datatypes)
06:43:33 <Lord_Duffler> thanks :)
06:44:59 <mmorrow> np
06:51:33 <CalJohn> dschoepe: cond would be nice though, I sometimes think, but I am a novice
06:52:48 <mmorrow> CalJohn: the name `cond' isn't taken of course :)
06:56:57 <quicksilver> somebody (Was it vixey?) recommends cond [ pred1 --> result1, pred2 --> result 2, .... , otherwise --> resultdefault ]
06:57:04 <quicksilver> where --> is just a renamed (,)
06:57:15 <quicksilver> and cond :: [(Bool,a)] -> a
06:57:28 <opqdonut> :t otherwise
06:57:29 <lambdabot> Bool
06:57:33 <opqdonut> ah, it really is True
06:57:44 <quicksilver> yes.
06:58:07 <quicksilver> cond has the nice property of indenting cleanly even in rather dumb editors :)
06:58:22 <quicksilver> whereas chained ifs look odd
06:58:23 <CalJohn> I was just thinking, cond would be cond :: [(Bool, a)]
06:58:47 <CalJohn> (-> a)
07:00:36 <mmorrow> @type snd . head . take 1 . filter fst
07:00:38 <lambdabot> forall b. [(Bool, b)] -> b
07:00:53 <doserj> @Å§ype  fromJust . lookup True
07:00:54 <lambdabot> forall a. [(Bool, a)] -> a
07:01:02 <mmorrow> weee
07:01:05 <burp> :D
07:01:47 <mmorrow> or Prelude only
07:02:04 <mmorrow> @type maybe (error "zomg") id . lookup True
07:02:06 <lambdabot> forall a. [(Bool, a)] -> a
07:03:31 <doserj> mmorrow: head . take 1 is ... interesting ...
07:03:59 <mmorrow> heh
07:04:05 <Twey> Haha
07:04:24 * mmorrow didn't even realize until you just said that
07:05:51 <mmorrow> @pl \a -> either (flip first a . (:)) (flip second a . (:))
07:05:52 <lambdabot> ap (either . (. (:)) . flip first) ((. (:)) . flip second)
07:06:15 <mmorrow> @type foldl' (\a -> either (flip first a . (:)) (flip second a . (:))) ([],[])
07:06:16 <lambdabot> forall a a1. [Either a a1] -> ([a], [a1])
07:06:31 <mmorrow> @type (reverse *** reverse) . foldl' (\a -> either (flip first a . (:)) (flip second a . (:))) ([],[])
07:06:33 <lambdabot> forall a a1. [Either a a1] -> ([a], [a1])
07:06:50 <mmorrow> @let paritionEithers' = (reverse *** reverse) . foldl' (\a -> either (flip first a . (:)) (flip second a . (:))) ([],[])
07:06:52 <lambdabot>  Defined.
07:07:25 <mmorrow> i guess that's as succinct as it can get.. (?)
07:07:29 <lilac> ugh. i'd prefer a cond which was total...
07:07:56 <mmorrow> lilac: just drop the fromJust/head
07:08:09 <lilac> mmorrow: that just seems to move the problem elsewhere
07:08:11 <mmorrow> (case isn't total of course)
07:08:20 <lilac> sure, but 'if' is
07:09:00 <mmorrow> hmm, i guess then you'd need to add an arg to cond for the default case
07:09:06 <lilac> fwiw, i tend to just use 'let x | c1 = ... | c2 = ... | otherwise = ...
07:09:18 <mmorrow> @type \a -> maybe a id . lookup True
07:09:20 <lambdabot> forall a. a -> [(Bool, a)] -> a
07:09:25 <CalJohn> What is the average level of education of people in this channel?  Degree?  Or above that?
07:09:36 <CalJohn> (Or below?)
07:09:48 <lilac> @users
07:09:49 <lambdabot> Maximum users seen in #haskell: 658, currently: 607 (92.2%), active: 15 (2.5%)
07:10:11 <lilac> CalJohn: you're not likely to get a statistically significant answer to that from the people here who aren't lurking
07:10:57 <CalJohn> lilac: well, then for typical non-lurker?  I'm just interesting in which ballpark
07:12:23 <Twey> I think it's mostly degree
07:12:48 <Twey> There are a few PhDs, and then there are a few high-school drop-outs, like me :-P
07:13:13 <Twey> Oh, and some folks aren't degree age yet
07:13:19 <defun> :t (,)
07:13:21 <lambdabot> forall a b. a -> b -> (a, b)
07:13:42 <earthy> what is 'degree level'?
07:13:57 <fasta> CalJohn: there is also at least one professor, if that kind of thing turns you on. ;)
07:13:58 <earthy> anything above bachelor's?
07:14:26 <CalJohn> earthy: i meant people in possession of a bachelors, i think Twey means people currently working on a bachelors
07:14:32 <lilac> how do you take the average of a collection of qualifications anyway? :)
07:14:39 <earthy> that's exactly why I asked. :)
07:15:20 <copumpkin> add up the average age at which people attain the qualifications, divide by the number of people, and see what qualification is most commonly being worked on at the resulting mean age?
07:15:22 <lilac> i would hazard a guess that more than half the non-lurkers have at least started an undergrad degree
07:15:22 <CalJohn> lilac: :)  I was just interested to work out if you guys are really good, or if I am really shit
07:15:53 <earthy> caljohn: could well be both :P
07:16:03 <mmorrow> copumpkin: just make sure you use foldl' for that...
07:16:10 <CalJohn> earthy: it could
07:16:12 <lilac> CalJohn: the amount of time spent learning is probably a better measure than qualifications
07:16:17 * copumpkin foldrs mmorrow
07:16:24 * mmorrow stack overflows
07:16:32 <copumpkin> oh no!
07:16:35 <earthy> anyway, I think most non-lurkers on here have a couple of years of haskell under their belts
07:16:36 * lilac foldl's mmorrow
07:16:46 <earthy> those that answer questions at least
07:16:50 * mmorrow evaluates to 239999999999999333333333388888888888881
07:17:03 <CalJohn> lilac: yeah, agreed, but time spent is hard to quantify
07:17:16 <lilac> mmorrow: looks like you got approximated?
07:17:27 <copumpkin> mmorrow isn't round enough
07:17:36 <mmorrow> oh noes!
07:17:45 <fasta> mmorrow: you forgot the unit!
07:17:46 <quicksilver> I'm sure there are quite a few phds among the non-lurkers
07:18:03 <mmorrow> fasta: furlongs
07:18:26 <copumpkin> the unit is faggot per butt
07:18:33 <earthy> quicksilver: having a few years of haskell under your belt tended to almost qualify you for a PhD in CS. :)
07:18:42 <CalJohn> for what it's worth, I am a highschool dropout, but am also working on a bachelors
07:18:47 <earthy> it being a research language and all :)
07:18:55 <lilac> mmorrow: can we measure the rate of mmorrow in furlongs per fortnight then?
07:19:18 <lilac> CalJohn: which age range is high school?
07:19:30 <mmorrow> lilac: you'd need to use fromIntegral everywhere for that though, could get ugly..
07:19:36 <mopped> I think I was admitted to university because I've done a (small) amount of haskell -- the interviewer seemed to like it, and I fluffed other stuff :P
07:19:42 <CalJohn> lilac: 13-18
07:19:55 <CalJohn> mopped: the same for me but with common lisp
07:20:25 <mopped> My interviewer uses LISP for his research, so he liked that I've done a bit of FP I guess
07:20:35 <quicksilver> mopped: if I ran a university, I'd admit you for knowing haskell
07:20:40 <quicksilver> however, for some reason, I don't.
07:20:47 <lilac> mmorrow: import Prelude () and define your own heterogenous numerical operators
07:21:04 <tomh> what was the syntax again for deriving when you are not doing it when declaring the data type again?
07:21:17 <lilac> I would attend the Univeristy of Quicksilver
07:21:21 <Twey> quicksilver: Possibly it's because you admit people for knowing Haskell :-P
07:21:22 <mopped> My university teaches ML instead of Haskell :(
07:21:27 <fasta> mopped: that seems like a bad reason, then again, everyone should be able to enter university. It doesn't mean that they all should be able to stay, but nothing wrong with them being able to enter.
07:21:35 <CalJohn> my university teaches haskell and prolog (with java, obviously)
07:21:41 <fasta> Atleast ML means something [/troll] :)
07:21:59 <lilac> tomh: StandaloneDeriving? i thought it was 'deriving <normal instance head>' but i might be misrecalling
07:22:07 <SamB> fasta: what does it mean -- ugly ?
07:22:44 <fasta> SamB: I am not sure whether you actually want an answer.
07:22:51 <mopped> It probably is fasta -- I'm expecting to get stomped by my peers for fluking entry
07:22:54 <tomh> ah standalone deriving yeah thanks
07:23:01 <SamB> fasta: it depends on how amusing your answer would be
07:23:01 <Axman6> so far i've done haskell, java anc C at uni, and i'll be doing Ada next semester, possibly with prolog thrown in too
07:23:09 <Axman6> and*
07:23:12 <fasta> SamB: it's not. So, then no :)
07:24:11 <fasta> Is it a bug if the factor between optimized and non-optimized code in GHC is > 20?
07:24:34 <lilac> fasta: sounds like a feature :)
07:24:38 <opqdonut> noot really
07:24:42 <fasta> I thought it used to be around 10 or something like that. The non-optimized code is really, really slow.
07:24:56 <fasta> The optimized code is not blazingly fast or anything like that.
07:25:01 <opqdonut> fasta: you probably need some strictness annotations
07:25:08 <opqdonut> for the unoptimized version to be reasonable
07:25:20 <copumpkin> you should be able to make the unoptimized one as slow as you want compared to the optimized one
07:25:31 <fasta> In fact the factor is 41.25.
07:26:10 <earthy> fasta: I wouldn't be surprised if the factor isn't constant
07:26:19 <earthy> i.e. if the factor is dependent on input size
07:26:36 <mmorrow> fasta: i don't think i've ever compiled code with less than -O2 when i've had the choice
07:26:45 <fasta> earthy: ? Per program and input the factor of course differs.
07:26:52 * mmorrow always ignores the warning hackage gives too
07:27:05 <fasta> earthy: but in my limited experience it used to be about 10, not 40.
07:27:15 <quicksilver> it is unusual for the optimiser to change time complexity per se; but it can change the space complexity, which changes the time complexity automatically.
07:27:31 * earthy nods
07:27:35 <CalJohn> mmorrow: but -O2 takes so long.  perhaps your machine is much faster than mind, but waiting >30 secs for a compile to too long, imo
07:27:35 <opqdonut> indeed
07:27:38 <earthy> that was exactly what I was hinting at
07:27:43 <CalJohn> s/imo/for me
07:27:54 <earthy> reducing memory churn is Very Important
07:28:06 <mmorrow> CalJohn: depends though. if you run that code a certain number of times, you'll make it up
07:28:42 <CalJohn> mmorrow: normally, I'm just wanting to see the output of the type checker and run the tests
07:29:17 <mmorrow> CalJohn: i like ghci nice for that
07:29:21 <mmorrow> s/nice//
07:30:00 * mmorrow is always sitting in ghci while writing code, constantly using :t with various concoctions
07:30:16 <CalJohn> mmorrow: that's a point actually, and it's only C-c C-l away
07:31:01 <mmorrow> ghci is nice too to spit use to print out various boilerplate code stretches (by whatever means)
07:31:15 <hatds> I often profile without optimizations to check for major misconceptions I might have about my code
07:32:17 <earthy> I had a *major* major misconception recently
07:32:17 * mmorrow 's rule of thumb is that if it doesn't work in ghci (:= w/out optims) it's borken, but that's his personal opinion
07:32:38 <earthy> mmorrow: you're not dealing with large amounts of data then ;)
07:32:56 <mmorrow> earthy: what's large amounts of data?
07:33:03 <earthy> graphs of 1.7M nodes
07:33:03 <quicksilver> bytestring code sometimes *relies on* fusion to get feasible performance
07:33:08 <quicksilver> and you never get fusion in ghci
07:33:11 <earthy> quicksilver: exactly
07:33:46 <earthy> and that graph is external to the problem at hand, which goes over on the order of 20G of input
07:33:55 <mmorrow> earthy: i'd bet money that all of my code will finish in ghci, if it finishes at all
07:34:03 <mmorrow> no matter the data size
07:34:26 <hatds> isn't that automatically true barring memory problems?
07:34:32 <earthy> hatds: no
07:34:37 <mmorrow> earthy: why?
07:34:51 <hatds> if it terminates, running in ghci can only make it take longer?
07:35:10 <earthy> the strictness properties may differ
07:35:23 <mmorrow> hatds: you can blow your stack in ghci and not in compiled code if your code relies on the strictness analyzer to work
07:35:29 <hatds> earthy: due to what?
07:35:48 <earthy> due to ghci being more lazy
07:35:50 <hatds> okay memory and stack problems then
07:35:51 <mmorrow> but if you write code that doesn't rely on the strictness analyzer of ghc..
07:36:00 <earthy> hatds: yup, then it should
07:36:18 <earthy> ofcourse, if you run over multiple gigs of data, memory and stack become issues. ;)
07:36:32 <mmorrow> stack though never needs to be an issue
07:36:46 <hatds> I think the major benefit of writing code that doesn't rely on optimizations is that the dynamic semantics are easier to understand
07:37:44 <hatds> well, obviously I guess :)
07:37:58 <earthy> ah, yes
07:38:43 <earthy> so, what would be better: given a file with 1 million nodes in a graph, written down as paths from a root
07:38:50 <earthy> one node, i.e. path, per line
07:39:37 <mmorrow> i'd use an assoc list rep for the file, with a distinguished root node on line 1 or something (if you want a root node at aall)
07:39:56 <mmorrow> 0\n1:453454,343,223,3\n......
07:40:00 <earthy> would you: fold 1 function that parses the node and directly adds it to a graph, i.e. roughly fold a function of  line -> graph -> graph
07:40:31 <hackagebot> tabular 0.2.2.0 - Two-dimensional data tables with rendering functions (EricKow)
07:40:40 <earthy> or: parse all lines, generating a list of adjacency tuples, and generate a graph from that?
07:40:44 <mmorrow> hmm, what is the concrete graph datastructure?
07:40:54 <earthy> Data.Graph.Inductive.PatriciaTree
07:41:01 <mmorrow> ooh nice, so IntMap
07:41:04 <mmorrow> speedy
07:41:21 <mmorrow> so IntMap IntSet?
07:41:29 <earthy> more or less yeah
07:41:41 * mmorrow sees what he would do
07:42:24 <fasta> earthy: for 1.7M nodes I would run as hard as I can away from fgl.
07:42:32 <hatds> the first one seems like it use less peak memory
07:42:47 <earthy> hatds: seems is the right choice of words. :)
07:43:03 <earthy> fasta: it actually works, and in reasonable amounts of memory no less
07:43:09 <fasta> earthy: what kind of performance?
07:43:21 <earthy> I read all 1.7M nodes in about 120s.
07:43:32 <fasta> earthy: right, that's what I expected.
07:43:39 <fasta> earthy: you can get it down to 6 seconds.
07:43:54 <earthy> fasta: prabably. how? :)
07:43:56 <fasta> earthy: if you use a sane data structure.
07:44:04 <fasta> earthy: something without the log n factor.
07:44:05 <quicksilver> mmorrow: stack is always an issue unless you depend on yoru implementation doing TCO
07:44:15 <quicksilver> mmorrow: (even ghci does TCO)
07:44:40 <earthy> fasta: and is there such a beast on hackage?
07:44:59 <fasta> earthy: no
07:45:07 <earthy> exactly. :)
07:45:34 <earthy> plus, I needed to do a few simple analyses on the graph
07:45:47 <fasta> earthy: oh, I thought it was an actual application.
07:45:52 <earthy> oh, it is
07:46:07 <earthy> it most definitely is
07:46:14 <fasta> earthy: for the stuff I had to do, I really didn't want to wait 20 times longer than necessary.
07:46:43 <earthy> but the trick is that the nodes are identified by strings, and need to be
07:46:57 <earthy> so I'm not going to do better than log n anyway
07:48:01 <earthy> at least, not initially
07:48:08 <earthy> once I have the nodes, I can improve
07:48:33 * quicksilver finds log n structures to work feasibly in practice as long as the initial log-n part is inside the cache
07:48:45 <quicksilver> especially if you're on the kind of computer where cache miss is slow
07:48:51 <earthy> hm. won't fit.
07:49:03 <earthy> but yeah
07:49:06 <quicksilver> traversal through a 6-deep index which fits in the cache followed by one slow cache miss
07:49:16 <quicksilver> is not much worse than directly accessing the one slow cache miss
07:49:18 <quicksilver> IYSWIM.
07:49:32 * earthy sees
07:49:35 <quicksilver> the constant fact on the log n part is very small if it's all in the cache.
07:49:56 <quicksilver> bit less true on the newset generation of motherboards because FSB speeds are on the way up, again.
07:50:09 <earthy> still holds though
07:50:24 <earthy> mostly
07:50:34 * mmorrow is writing out a file with a randomgen graph with 1048576 nodes, each of which have between 1 and 8 neighbors
07:50:48 <copumpkin> sounds slow
07:50:52 <mmorrow> 39M, not bad
07:51:00 <jmcarthur_work> has anybody ever written anything up about being nice to the cache when writing Haskell for GHC?
07:51:00 <earthy> mmorrow: that's about the size, yeah
07:51:17 <earthy> jmcarthur: ISTR Alexey Rodrigues did some investigation into it
07:51:48 <quicksilver> jmcarthur_work: GHC makes some effort to keep the nursery cache-friendly
07:51:51 <CalJohn> fasta: Data.HashTable has constant time for most operations (I assume), why wouldn't you use that for that situation?
07:51:59 <quicksilver> jmcarthur_work: so minor collections fit in the cache
07:52:12 <quicksilver> CalJohn: Data.HT has a constant factor of about a fortnight, though
07:52:15 <fasta> CalJohn: 1) Hashtable implementation in Haskell is bad 2) Hashtables in general have no such thing has constant time.
07:52:19 <fasta> as*
07:52:22 <quicksilver> CalJohn: in practice it's terrible.
07:52:37 <quicksilver> hashtables have "probabilistic constant time"
07:52:45 <quicksilver> that can be good enough if you know something about your data set
07:52:49 <quicksilver> most people know something about their data set :)
07:53:01 <mmorrow> hmm, it's annoying that you can't reproduce an StdGen since the constructor's hidden..
07:53:04 <CalJohn> yeah, I'm aware that hashtables don't _actually_ achieve constant time, but why is Data.HashTable so bad?
07:53:13 <quicksilver> not sure, btu it is ;)
07:53:37 <jmcarthur_work> CalJohn, one bad mark against Data.HashTable is all the IO stuff
07:53:55 <quicksilver> mmorrow: you can "read" it
07:53:57 <mmorrow> (it's 19M) http://moonpatio.com/repos/g0.txt.gz
07:54:00 <jmcarthur_work> CalJohn, plus, our implementation is simply not very fast
07:54:05 <mmorrow> quicksilver: ooh nice
07:54:09 <Axman6> CalJohn: i've never heard of hashtables being recommended in haskell, and many times it's been put down by people who certainly know what they're talking about
07:54:10 <copumpkin> CalJohn: issues with the garbage collector, among others
07:54:13 <jmcarthur_work> CalJohn, and most of us don't care enough to fix it :\
07:54:19 <quicksilver> > [mkStdGen 42, read . show $ mkStdGen 42]
07:54:20 <lambdabot>   [43 1,43 1]
07:54:25 <quicksilver> mmorrow: tada.
07:54:36 <copumpkin> the problem is (as far as I can understand) that the mutable arrays that hold the
07:54:38 <mmorrow> beautiful, me pastes the three lines needed to reproduce that graph
07:54:59 <copumpkin> buckets of hashtables need to be scanned entirely every time you modify one bucket
07:55:03 <jmcarthur_work> CalJohn, i recently wrote about this on reddit, btw: http://www.reddit.com/r/programming/comments/8rnrr/c_versus_c/c0a8bgv
07:55:16 <CalJohn> Axman6: yeah, I agree, hashtables would not be nice in haskell
07:55:40 <hatds> could just use the C heap then or something, no?
07:55:45 <Axman6> well they're not just not nice in haskell, they aren't very good in haskell
07:56:01 <jmcarthur_work> oh i didn't even mention the GC stuff in that comment
07:56:03 <copumpkin> hatds: it could, but then we'd need to keep track of memory ourselves and that'd be a pain
07:56:09 <copumpkin> but I'm sure it can be done :)
07:56:11 <jmcarthur_work> presumably something like that could be addressed somehow though
07:56:28 <hatds> if it's in IO anyway it is a pain :)
07:56:32 <lilac> you could probably implement a pretty good ST hashtable
07:56:42 <Axman6> aye
07:56:46 <jmcarthur_work> that is what i would like to see
07:56:47 <CalJohn> jmcarthur_work: interesting, thanks
07:56:59 <lilac> perhaps even with freeze-to-immutable-hashtable functionality
07:57:13 <jmcarthur_work> exactly
07:58:13 <mmorrow> ok, here's the code to gen the graph i've got http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2811#a2811
07:58:28 * mmorrow now tries to build an IntMap IntSet
07:59:28 <copumpkin> mmorrow: please please please make a nice graphing library :D
07:59:39 <earthy> that's unordered, right?
07:59:39 <copumpkin> mmorrow: why not a UArray Int IntSet?
07:59:49 <jmcarthur_work> huh that's lame that you can read a StdGen but you can't just construct one directly
08:00:17 * earthy will actually build an implementation of UArray Int (IntSet,IntSet)
08:00:31 <copumpkin> earthy: for in-edges and out-edges?
08:00:37 <earthy> (as I need ordered graphs)
08:00:42 <copumpkin> directed?
08:00:45 <earthy> directed, sorry
08:00:50 <EvilTerran> jmcarthur_work, something wrong with using mkStdGen?
08:00:52 <earthy> it's 5pm
08:00:56 <copumpkin> :)
08:00:58 <earthy> I should be going home ;)
08:01:14 <earthy> but yeah, I need a *fast* fast graph lib as well
08:01:23 <earthy> that is also compact to store
08:01:35 <copumpkin> yeah, I'd like to see a new graph lib
08:01:38 <jmcarthur_work> EvilTerran, "<mmorrow> hmm, it's annoying that you can't reproduce an StdGen since the constructor's hidden.."
08:01:42 <earthy> actually fgl isn't bad
08:01:48 <jmcarthur_work> i haven't used Random in a while, so i forgot about mkStdGen
08:02:00 <fasta> earthy: did you read the paper of fgl?
08:02:01 <copumpkin> earthy: maybe the UArray version seems like a good one to "freeze" to, but it'd be a pain to modify
08:02:11 <copumpkin> I read the fgl paper
08:02:11 <earthy> copumpkin: exactly
08:02:14 <earthy> fasta: I did
08:02:14 <fasta> earthy: if you compare it to a single threaded C version, it is bad.
08:02:32 <fasta> fgl solves a problem almost nobody is interested in, imho.
08:02:33 <copumpkin> I just wish fgl felt maintained :P
08:02:39 <Athas> Can anyone write a Unicode bottom character?
08:02:46 <Athas> I can't find the damn thing.
08:03:05 <copumpkin> â¥
08:03:11 <copumpkin> not quite though
08:03:31 <Athas> I just got â¥, I think that's better.
08:03:35 <Athas> I wonder why Unicode has both.
08:03:35 <mmorrow> it's annoying hat regular Word8 ByteStrings don't have readInt
08:03:49 * mmorrow copies the code from Char8 and makes his own
08:03:56 <mmorrow> sigh
08:03:59 <copumpkin> mmorrow: why not just use a Char8?
08:04:02 <quicksilver> mmorrow: I'll tell you a secret
08:04:02 <earthy> â¥
08:04:06 <quicksilver> mmorrow: the types aren't actually differnt
08:04:11 <earthy> that should be it, right?
08:04:15 <earthy> u+22a5
08:04:15 <quicksilver> mmorrow: Bytestring is the same type as Bytestring.Char8
08:04:20 <quicksilver> mmorrow: but don't tell anyone
08:04:36 <jmcarthur_work> WHY CAN'T I TELL ANYONE?
08:04:50 <idnar> jmcarthur_work: tell anyone what?
08:05:05 <idnar> *efg*
08:05:11 <jmcarthur_work> idnar, i'm cutting into a conversation, rudely
08:05:37 <idnar> jmcarthur_work: what conversation? nobody was having a conversation about Bytestring being Char8, that wouldn't be allowed
08:06:06 <jmcarthur_work> i am unafraid of taboo subjects
08:06:13 <EvilTerran> unsafeCoerce?
08:06:23 <idnar> unsafeConverse
08:09:44 <quicksilver> unsafeDoubleThink
08:11:46 <Axman6> unsafeDoublePlusUnthink
08:12:23 <opqdonut> unsafeDoubleThunk
08:12:35 <opqdonut> that would've been a good name for unamb ;)
08:12:46 <Floor_Feline> unsafeFaceCrime u_o
08:13:54 <defun> :t (<$)
08:13:56 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
08:14:28 <defun> Hey can anyone explain what the (<$) function from Control.Applicative does?
08:14:46 <opqdonut> @src (<$)
08:14:46 <lambdabot> (<$) = (<$>) . const
08:14:55 <Badger> @src (<$>)
08:14:56 <lambdabot> f <$> a = fmap f a
08:15:09 <defun> @src const
08:15:09 <lambdabot> const x _ = x
08:15:17 <defun> thanks.
08:15:23 <opqdonut> so "x (<$) f === fmap (const x) f"
08:15:49 <opqdonut> it replaces the value inside the functor but keeps the "metadata" the same
08:16:06 <defun> thanks.
08:16:25 <opqdonut> > 1 <$ [1,2,3]
08:16:26 <lambdabot>   Not in scope: `<$ï¿½'
08:16:30 <opqdonut> ah
08:16:40 <opqdonut> > 1 Control.Applicative.<$ [1,2,3]
08:16:41 <lambdabot>   Not in scope: `Control.Applicative.<$ï¿½'
08:16:53 <opqdonut> > 1 Control.Applicative.<$ [1,2,3]
08:16:54 <lambdabot>   [1,1,1]
08:17:04 <opqdonut> there was a nbsp instead of a normal space there :D
08:17:10 <opqdonut> > 1 Control.Applicative.<$ Nothing
08:17:11 <lambdabot>   Nothing
08:17:17 <Floor_Feline> shame, ghc, shame
08:17:34 <defun> > 5 Control.Applicative.<$ [1,2,3]
08:17:36 <lambdabot>   [5,5,5]
08:17:42 <defun> thats cool.
08:18:16 <lilac> > let (ï¿½) = (<$>) in (*2)ï¿½(+1)ï¿½[1,2,3]
08:18:18 <lambdabot>   Couldn't match expected type `a -> a' against inferred type `[a1]'
08:18:41 <EvilTerran> iirc, the default fixity is infixl
08:19:01 <lilac> > let infixr 3 ï¿½; (ï¿½) = (<$>) in (*2)ï¿½(+1)ï¿½[1,2,3]
08:19:02 <lambdabot>   [4,6,8]
08:19:05 <jmcarthur_work> > 1 <$ [1,2,3]
08:19:06 <lambdabot>   [1,1,1]
08:19:16 <jmcarthur_work> > 1 <$Â [1,2,3]
08:19:18 <lambdabot>   [1,1,1]
08:19:25 <jmcarthur_work> okay...
08:20:00 <lilac> @let infixl 4 ï¿½; (ï¿½) = (<$>)
08:20:02 <lambdabot>  Defined.
08:20:03 <jmcarthur_work> oh nbsp, missed that
08:20:41 <lilac> > sum$(*2)ï¿½(+1)ï¿½[1,2,3]
08:20:43 <lambdabot>   18
08:22:25 <lilac> crouching lambdabot, hidden fmap
08:22:57 <mmorrow> earthy: i got into it and made a repo (which includes some .csv parsing code i have that's pretty fast, which i've been meaning to put up somewhere anyways), http://moonpatio.com/repos/read-graph/
08:23:52 <mmorrow> earthy: it's been running in my ghc for a few minutes on that file (i'm doing rnf g `seq` ()), who knows how long it'll take, but the memory's constant (well, other than the IntMap IntSet it's building) ..
08:23:57 <mmorrow> s/ghc/ghci/
08:24:46 <mmorrow> here's a benchmark of that csv code vs. bytestring-csv: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2724#a2726
08:24:49 <mmorrow> ;)
08:25:35 <mmorrow> omg it just finished building the IntMap IntSet
08:25:45 <mmorrow> (in ghci)
08:27:19 <mmorrow> ghci is 897m resident
08:28:43 <MartyIX> Is this lambda abstraction: \x -> \y -> x + y equivalent to: \x y -> x + y  ? I tried to input a few numbers and both returns the same results. Is there any difference in general?
08:29:09 <Saizan> they are semantically the same
08:29:43 <lilac> aren't they operationally the same too?
08:29:47 <Floor_Feline> aww. Haskell thinks ideographic space is whitespace
08:30:04 <lilac> > isSpace 'ï¿½'
08:30:06 <lambdabot>   False
08:30:11 <MartyIX> Saizan: thank you!
08:30:49 <Saizan> lilac: the first is more likely to be really implemented as a function of one argument producing another one, instead of as a function of two arguments
08:31:32 <lilac> Saizan: i was hoping they'd both be implemented as (+)
08:31:34 <Floor_Feline> > isSpace 'ã'
08:31:36 <lambdabot>   True
08:31:45 <Floor_Feline> hm. interesting.
08:32:01 <Floor_Feline> contradicts a few grammars ;)
08:33:24 <quicksilver> Saizan: I don't think that's true.
08:33:36 <Saizan> lilac: they'd probably be both inlined in this case
08:33:48 <quicksilver> Saizan: I think there is no difference between \x -> \y -> and \x y -> in abstract syntax.
08:33:57 <quicksilver> \x y -> is "just" a shorthand.
08:34:18 <Saizan> quicksilver: the difference is observable when patterns are involved
08:34:22 <lilac> if it were \x -> let k = f x in \y -> ... then there's clearly a difference
08:34:26 <mmorrow> (let f x = \y -> .. in ) and
08:34:27 <mmorrow> yeah
08:34:41 <mmorrow> i dunno about the lambda caseeee though
08:34:50 <Saizan> > let f = \(x,_) y -> () in f undefined `seq` ()
08:34:52 <lambdabot>   ()
08:35:01 <Saizan> > let f = \(x,_) -> \y -> () in f undefined `seq` ()
08:35:02 <lambdabot>   * Exception: Prelude.undefined
08:35:06 <mmorrow> interesting
08:35:30 <quicksilver> that's weird.
08:35:31 <mmorrow> very interesting
08:35:43 <quicksilver> I think that's a bug in haskell 98 :P
08:35:53 <quicksilver> (or a bug in GHC, if haskell98 does not mandate that behaviour)
08:36:03 <lilac> so the case is desugared out before the lambdas are split, i guess?
08:36:40 <mmorrow> i believe this is just a result of how ghc deals with function application
08:36:48 <lilac> \p1 p2 ... -> x ==> \a b ... -> case (a, b, ...) of (p1, p2, ...) -> x
08:36:50 <lilac> ?
08:36:55 <mmorrow> arity isn't deducible from type alone
08:37:11 <mmorrow> (f x = \y -> ..) ==> arity=1
08:37:17 <mmorrow> (f x y =  ..) ==> arity=2
08:37:23 <doserj> lilac: that's what the report says, yes
08:37:29 <Saizan> btw, the paper "types are calling conventions" deals with the lowlevel representation of functions, using a type system with explicit multi-arg functions
08:37:44 <quicksilver> yes I read the abstract of that one
08:37:48 <mmorrow> Saizan: ooh yeah, that's an interesting paper
08:37:52 <quicksilver> but I didn't expect those concernes to filter into haskell semantics :)
08:38:19 <mmorrow> Saizan's example there is the first example i've seen of that happening
08:38:42 <Saizan> yeah, it being denotationally observable is quite weird
08:39:05 <quicksilver> mmorrow: I don't think of arity as being a semantic concept.
08:39:13 <mmorrow> quicksilver: yeah, it's definitely not
08:39:16 <quicksilver> well, to the extent that I do, I assume it is observable in the type :)
08:39:21 <Saizan> however you need to be aware of the behaviour if you care about performance, i guess
08:39:33 <mmorrow> quicksilver: yeah, that's a better way to put it
08:39:40 <quicksilver> obviously I knew about \x -> let blah = blah in \y ->
08:39:52 <pozic> How do I compute map expensive [a,b] in parallel?
08:39:52 <quicksilver> but that seems a natural enough hack to layer sharing
08:40:04 <Floor_Feline> pmap, perhaps
08:40:12 <Floor_Feline> or is that parmap
08:40:16 <mmorrow> pozic: have you looked at the dph stuff?
08:40:18 <opqdonut> pozic: have a look at Control.Parallel
08:40:20 <Saizan> parMap
08:40:29 <opqdonut> mmorrow: dph probably isn't appropriate
08:40:35 <opqdonut> as it's not that mature yet
08:40:42 <opqdonut> @src parMap
08:40:43 <lambdabot> Source not found. :(
08:40:45 <Floor_Feline> parMap :: Strategy b -> (a -> b) -> [a] -> [b]
08:40:48 <pozic> Saizan: parMap returns a (). It's not of the right type.
08:40:52 <mmorrow> yeah, i tried it out the other day and had a mini epic with the example
08:41:05 <Saizan> pozic: it looks like it returns [b] to me
08:41:15 <opqdonut> yeah it returns [b]
08:41:28 <opqdonut> are you thinking of mapM_?
08:41:29 <Saizan> Strategy b = b -> ()
08:41:33 <pozic> Saizan: type Strategy a = a -> Done
08:41:38 <Saizan> yeah
08:41:46 <quicksilver> pozic: yes, but the return value of the parMap is [b]
08:41:47 <pozic> Saizan: oh, I see.
08:41:48 <quicksilver> which is what you want.
08:41:55 <Saizan> pozic: the Strategy argument is only to specify to which extent you want to force the results
08:42:00 <quicksilver> the strategy just tells it how far to evaluate the bs
08:42:11 <opqdonut> pozic: you probably want to use either the rwhnf or rnf strategy
08:42:15 <quicksilver> as in, parMap rwhnf expensive [a,b]
08:42:17 <opqdonut> both defined in Control.Parallel.Strategies
08:42:27 <Floor_Feline> you can also use pars for just pairs or triples, if you like
08:42:38 <Floor_Feline> if it's just [a,b], as you said?
08:43:07 <opqdonut> Floor_Feline: might still need a strategy
08:43:09 <Floor_Feline> @type parPair
08:43:11 <lambdabot> forall a b. Strategy a -> Strategy b -> (a, b) -> Done
08:43:11 <opqdonut> btw, what's NFData short for?
08:43:12 <Floor_Feline> @type parTriple
08:43:14 <lambdabot> forall a b c. Strategy a -> Strategy b -> Strategy c -> (a, b, c) -> Done
08:43:18 <Floor_Feline> hmmmm... odd types
08:43:41 <opqdonut> Floor_Feline: you `pseq` that with what you really want
08:43:47 <Saizan> opqdonut: Normal Form Data?
08:44:03 <opqdonut> Saizan: ah
08:44:28 <pozic> And if I have a long list where every computation is kind of cheap?
08:44:43 <opqdonut> Floor_Feline: or something like "(a,b) `using` parPair rnf rwhnf" of course
08:44:47 <quicksilver> then you probably want one of the chunked stragegies
08:44:48 <Philonous> I wonder: In a typed equation Theory, what is "Gamma yields M = N : A" supposed to mean? M = N and N:A or (M=N) : A
08:44:51 <quicksilver> which are a bit tricky to tune
08:44:56 <Floor_Feline> ioc.
08:45:13 <opqdonut> Philonous: i'd guess "(M=N) and M:A and N:A"
08:45:16 <opqdonut> as it usually does
08:45:16 <Floor_Feline> what the heck is rwhnf. seq?
08:45:33 <opqdonut> Floor_Feline: yeah
08:45:39 <opqdonut> the "normal" haskell strategy
08:45:46 <opqdonut> evaluate to first top-level constructor
08:45:49 <pozic> quicksilver: why isn't there one which just uses the number of cores available, instead of taking an argument of how big the chunks have to be?
08:45:59 <Floor_Feline> ah, makes sense
08:46:12 <pozic> quicksilver: size of list / number of cores should be the size of the chunks.
08:46:13 <Philonous> opqdonut: That's what I thought, thanks.
08:46:13 <byorgey> *r*whnf?
08:46:30 <opqdonut> Philonous: don't take my word for it tho :P
08:46:43 <Philonous> opqdonut: Better than nothing
08:46:48 <opqdonut> byorgey: for some reason all the strategies have an r prefix
08:46:57 <Saizan> reduce :)
08:47:02 <byorgey> ah, I see =)
08:47:07 <opqdonut> ah
08:48:07 <oal> well, btw
08:48:25 <oal> how can you _get_ the number of cores you are currently running on?
08:49:42 <pozic> Ok.. this is unexpected: bad option -N4: only -N1 is supported with profiling
08:49:44 <dons> oal: numCapabilities
08:49:52 <dons> pozic: that's correct.
08:50:03 <dons> profiling ticks aren't SMP capable yet
08:50:11 <oal> dons, ok, thank you
08:50:50 <lilac> oal: or you could forkIO a number of threads, have them all waiting in readMVar, then writeMVar, then takeMVar, and see how many get unblocked ;-)
08:50:54 <lilac> *ducks*
08:50:57 <pozic> dons: so is that: internal error: profiling is currently broken with multi-threaded GC
08:52:42 <dons> pozic: check with JaffaCake
08:53:05 <dons> multicore profiling with a multicore GC is a pretty new thing anywhere :)
08:53:22 <oal> lilac, I am rather a GpH type. Just parMap'ing in peace ;)
08:55:40 <pozic> How can I get the number of available OS threads? I.e. the value of N<x>?
08:56:09 <Saizan> numCapabilities
08:56:13 <oal> I just tested numCapabilites
08:56:21 <oal> that's exactly it
08:58:20 <roconnor> I wish it was easier to search through haskell logs
09:00:31 <smorg> A type like (a -> b -> c) means (a -> (b -> c)) ?
09:00:31 <pozic> And what exactly can I do with a Strategy [a] value?
09:00:41 <dons> time to read the strategies paper!
09:00:48 <dons> actually, SPJ wrote a good tutorial on this stuff.
09:01:19 <dons> A Tutorial on Parallel and Concurrent Programming in Haskell " http://research.microsoft.com/en-us/um/people/simonpj/papers/parallel/index.htm
09:01:54 <jmcarthur_work> smorg, yes
09:01:59 <Sam__> doesn't STM present a large overhead when using a lot of cores?
09:02:12 <dons> compared to?
09:02:54 <dons> this has a good comparison of the costs/benefits of STM vs explicit locking in a parallel setting, http://www.haskell.org/~simonmar/bib/concurrent-data-08_abstract.html
09:03:21 <Sam__> ty
09:03:25 <pozic> dons: I don't see Strategy [a] being mentioned in that paper.
09:03:52 <smorg> jmcarthur: Ah that makes this MUCH less confusing.
09:03:59 <dons> pozic: the tutorial gives a tutorial on using strategies
09:04:46 <Baughn> Is it possible to supply a default implementation for a type-class that is used if no instances are found? I mean, without overlapping instances?
09:04:52 <hackagebot> fractal 0.0.1 - Draw Newton, Julia and Mandelbrot fractals (MaxRabkin)
09:05:17 <davidL> roconnor: wget them all and use grep
09:05:26 <roconnor>  but there are so many
09:05:39 <pozic> dons: I understand how to use the parMap function with a strategy, I just don't see what one can do with a Stategy [a] value which is the return type of parListChunk. I would have expected it to just return the input list with some function applied to it (at least that's what I want), but faster.
09:05:51 <pozic> Strategy*
09:06:09 <Saizan> ?type parListChunk
09:06:10 <lambdabot> forall a. Int -> Strategy a -> [a] -> Done
09:06:41 <pozic> Well, in fact, I could call it with seq, I suppose.
09:06:54 <pozic> But that's hardly elegant.
09:07:18 <dons> that's on of the standard ways to apply strategies
09:07:41 <dons> check the strategies paper "Algorithm + Strategy = Parallelism"
09:09:53 <hackagebot> llvm 0.6.6.0 - Bindings to the LLVM compiler toolkit. (LennartAugustsson)
09:11:37 <pozic> dons: I think I understand (without reading the paper) that it's just tagging a list for parallel evaluation in chunks.
09:12:11 <Saizan> pozic: yourlist `using` parListChunk n rnf
09:13:39 <pozic> Saizan: oh, that's more elegant, but probably does the same as I was already doing. Thanks.
09:14:29 <pozic> Saizan: would that be map foo list `using` strategy or map foo (list `using` strategy)?
09:20:38 <roconnor> what is the haskell proposal's reddit
09:20:46 <roconnor> or rather where is it
09:22:11 <doserj> http://www.reddit.com/r/haskell_proposals/
09:22:44 <roconnor> Thanks
09:32:35 <dmwit> http://blog.plover.com/prog/haskell/logo.html
09:36:27 <Baughn> What was the "proper" name for a scan? Hylomorphism or something..
09:36:45 <MartyIX> I'm studying pattern-matching semantics and I'm thinking if it is important for me to know if pattern matching led to failure or divergence. Is it?
09:37:10 <monochrom> It is important.
09:37:16 <Floor_Feline> lol. I accidentally entered a URL into ghci
09:37:20 <Floor_Feline> it told me: cannot mix `(://)' [infixl 9] and `(.)' [infixr 9] in the same infix expression
09:37:25 <monochrom> haha
09:37:48 <Floor_Feline> <interactive>:1:4: Not in scope: data constructor `://'  .. <interactive>:1:18: Not in scope: `com'
09:38:19 <kpreid> data HierarchicalURL = Scheme :// AuthorityAndPath
09:38:44 <MartyIX> monochrom: so what is the advantage if I know pattern-matching led to divergence?
09:39:23 <monochrom> The advantage is that your mental model is closer to reality.
09:39:53 <monochrom> (Gosh, what is the advantage if you know more?)
09:40:27 <Baughn> kpreid: The '//' is necessary? Really?
09:40:27 <Floor_Feline> failure is just when there is no more divergence...
09:40:40 <kpreid> Baughn: No. That's why I said 'Hierarchical'
09:41:05 <kpreid> see rfc 3986 URI Generic Syntax for details
09:41:08 <Baughn> kpreid: Far too many people seem to think it should be there, though. "file:///foo" makes me puke. :/
09:41:21 <kpreid> Actually, it's correct...
09:41:30 <Baughn> THen we need to change the standard
09:41:38 <kpreid> *IF* you use a leading // THEN you should use it in the authority-and-path format, says that scheme
09:41:42 <kpreid> s/scheme/RFC/
09:42:24 <Baughn> Fine. How is "file:///home/svein" "authority-and-path"?
09:42:28 <kpreid> the // is used in file: for provision for network-accessible file systems...
09:42:37 <monochrom> You think "//" is redundant for files because you think everyone uses a unix pathname convention.
09:42:52 <Floor_Feline> incidentally, Firefox does use "/" for file urls in windows..
09:42:57 <kpreid> see section 3.10 in http://tools.ietf.org/html/rfc1738
09:43:04 <copumpkin> what about the shitty old mac os scheme with colons
09:43:13 <kpreid> I'm not saying it's a good idea, I'm saying that's what the standard is.
09:45:32 <hatds> I have make file with both kinds of separators, and neither instance can be switched to the other
09:45:41 <hatds> it's annoying
09:46:10 <MartyIX> monocrhom: you can create a system that would be pretty complex but it's not useful.. :) My guess is that it's good in debugging. Anything what else?
09:46:15 <MartyIX> *Anything else
09:48:51 <Synth-c> anybody here ever tried implementing type-logical or categorial grammars in haskell?
09:49:02 <monochrom> I don't know what you're talking about. Haskell pattern matching can fail. Call that complex but it is useful because it is what dons is already using. What does it matter what "I" "can" "create"?
09:51:15 <MartyIX> monochrom: never mind.
09:51:29 <MartyIX> maybe a really silly question :)
09:59:39 <CalJohn> Can someone recommend me a good place to learn Monad Transformers, other than RWH
10:00:10 <Twey> Why not RWH?
10:00:43 <Saizan> CalJohn: this paper is quite nice http://web.cecs.pdx.edu/~mpj/pubs/modinterp.html
10:00:52 <master_of_master> hi, how can I fill a list with Integers from stdin until EOF?
10:01:00 <Saizan> CalJohn: especially if you've ever toyed with interpreters
10:01:50 <CalJohn> Twey: I find the RWH chapter hard, and it relies heavily on example I don't get the implication of
10:01:53 <Saizan> master_of_master: do input <- getContents; let ints = map read (lines input) :: [Integer] ...
10:02:26 <CalJohn> *examples
10:02:46 <Saizan> master_of_master: that assuming you've a number per line
10:03:09 <CalJohn> Saizan: I haven't done anything relating to interpretters before, but thanks
10:04:35 <master_of_master> Saizan: no, there are two numbers per line
10:05:11 <Saizan> master_of_master: then you need something else instead of lines to split your input
10:05:29 <Saizan> > lines "123\n13\n123"
10:05:31 <lambdabot>   ["123","13","123"]
10:05:37 <Saizan> > lines "123 456\n13\n123"
10:05:39 <lambdabot>   ["123 456","13","123"]
10:05:57 <Saizan> > words "123 456\n13\n123"
10:05:58 <lambdabot>   ["123","456","13","123"]
10:06:39 <Cale> hmm... class Mapping t where {type Domain t; type Codomain t; (!) :: t -> Domain t -> Codomain t}
10:13:04 <Synth-c> anybody here ever tried implementing type-logical or categorial grammars in haskell?
10:13:53 <Saizan> what are those?
10:16:56 <Cale> Hmm... that doesn't seem to work very well if I want genericIndex as an instance for [a]
10:17:15 <Cale> Perhaps using fundeps really is a better plan
10:17:58 <Cale> Or maybe I just don't know where to put this class context...
10:18:23 <Saizan> type Codomain [a] = forall b. Integral b => b ?
10:18:42 <Cale> Well, type Codomain [a] = a
10:19:43 <Cale> But we really want  type Domain a = exists b. Integral b *> b  or something
10:19:57 <Saizan> oh,sorry, i was thinking of genericLength
10:20:01 <Saizan> ?type genericIndex
10:20:03 <lambdabot> forall b a. (Integral a) => [b] -> a -> b
10:20:34 <Cale> instance (Integral t) => Mapping [a] where type Domain [a] = t; ...
10:20:42 <Cale> Doesn't work since t is not in scope apparently
10:21:05 <RayNbow> @faq Can I use Haskell to build an AC?
10:21:05 <lambdabot> The answer is: Yes! Haskell can do that.
10:24:22 <Saizan> ?type let foo :: [b] -> (forall a. Integral a => a) -> b; foo xs i = genericIndex xs i in foo
10:24:23 <lambdabot> forall b. [b] -> (forall a. (Integral a) => a) -> b
10:24:28 <Cale> class Mapping t dom cod | t -> dom, t -> cod where
10:24:28 <Cale>   (!) :: t -> dom -> cod
10:24:33 <Saizan> forall should work
10:25:07 <Cale> seems to work out better since I can explicitly mention the type variable and apply conditions to it (given UndecidableInstances)
10:25:26 <Cale> Saizan: That's a higher rank type...
10:25:40 <Cale> Saizan: it would means that you *must* pass a polymorphic number
10:25:46 <Cale> mean*
10:25:57 <Saizan> oh, right
10:26:32 <Cale> instance (Integral t) => Mapping [a] t a where
10:26:32 <Cale>   xs ! n = genericIndex xs n
10:28:44 <Cale> instance (Ord a) => Mapping (Set a) a Bool where
10:28:44 <Cale>   s ! x = S.member x s
10:29:30 <Philonous> @type S.member
10:29:32 <lambdabot> forall a. (Ord a) => a -> S.Set a -> Bool
10:29:36 <Saizan> oh, wait, instance Integral (Domain [a]) => Mapping [a] where ... should work
10:29:48 <Cale> Saizan: I tried that too
10:30:19 <jimmyjazz14> can lambdabot import modules?
10:31:48 <Cale> oh, hmm
10:31:55 <Vanadium> What does _|_ mean?
10:31:56 <Cale> Clearly I did not try it enough :P
10:31:57 <lpsmith> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6006#a6006
10:32:06 <Cale> Maybe it was that I didn't have some other extensions on at the type
10:32:09 <Cale> time*
10:32:21 <lpsmith> If anybody knows how to get something out of that monad without cheating too badly, I'm all ears :-)
10:32:38 <Cale> Vanadium: It's a value which represents nontermination or failure.
10:32:51 <RayNbow> > let loop = loop in loop
10:32:57 <lambdabot>   mueval-core: Prelude.read: no parse
10:32:57 <lambdabot>  mueval: ExitFailure 1
10:33:02 <RayNbow> kaboom :p
10:33:37 <Cale> Vanadium: (We bunch together everything which fails to produce a constructor and call it _|_)
10:33:47 <Vanadium> I see
10:34:07 <Vanadium> Trying to figure out what seq means in terms of stuff I already believe to understand
10:36:25 <Philonous> Vanadium: btw. _|_ is pronounced "bottom" and is the only value that is member of any type.
10:36:26 <Cale> When it evaluates seq x y, it evaluates x prior to returning the result of evaluating y.
10:36:43 <Cale> For specific types, you can write seq using case
10:36:49 <Vanadium> Cale: Is it possible to express that within-- ah
10:36:52 <Cale> For example, if it's Maybe
10:37:09 <Cale> seq x y = case x of Nothing -> y; Just _ -> y
10:37:10 <Philonous> s/any/every
10:37:25 <Baughn> Cale: And hope the compiler doesn't outsmart you?
10:37:43 <Cale> Baughn: right... well, it ought not to outsmart me too much :)
10:38:38 <Cale> If there's a case which pattern matches, you must evaluate the scrutinee into WHNF before allowing the result to be consumed, even if you can tell what the result is.
10:38:51 <Cale> Because if x is _|_ then the case expression is _|_ too
10:38:59 <Vanadium> WHNF?
10:39:06 <Vanadium> Aaah, I need to get more theory into my head.
10:39:07 <Cale> Weak Head Normal Form
10:39:27 <Cale> It basically just means "up to determining the top-level constructor"
10:39:45 <Cale> and "stop if you hit a lambda"
10:40:04 <Baughn> As opposed to head normal form, which is..?
10:40:28 <Philonous> Baughn: There a no redexes left, even no inner ones
10:40:37 <Baughn> Philonous: That sounds more like normal form
10:40:56 <Philonous> True
10:41:01 <Cale> Baughn: Which means you continue inside the body of the lambda, if you hit a lambda
10:41:08 <Cale> For example...
10:41:21 <Cale> (\x -> (\y -> y + 1) x)
10:41:27 <Cale> is in WHNF, but not in HNF
10:41:42 <Cale> Philonous: no, that's... not right
10:41:47 <Baughn> HNF sounds really hard to evaluate, then
10:41:51 <Cale> Philonous: That's normal form
10:42:28 <Jedai> Cale: what would be the HNF of (\x -> (\y -> y + 1) x), I thought it was already in HNF
10:42:30 <Cale> Baughn: It's easy if you're thinking about it from the perspective of manipulating expressions
10:42:34 <Jedai> ??
10:42:40 <Cale> (\x -> x + 1)
10:42:49 <Baughn> Cale: As opposed to the perspective of implementing it in a compiler. :P
10:42:58 <Jedai> Cale: oh right, sorry
10:43:02 <Cale> Baughn: Inside a compiler, you can do it with continuations :)
10:43:41 <Cale> Baughn: When you're evaluating and hit a lambda which is not sufficiently applied, you pass the current continuation for the unknown parameters
10:44:14 <MyCatVerbs> Cale: WHNF is outermost constructor, NF is everything, what's HNF?
10:44:45 <Baughn> Cale: Ah, but GHC doesn't use continuations
10:45:18 <Cale> Baughn: yeah. So it's not impossible, just hard in the context of GHC
10:45:19 <MyCatVerbs> Oh. HNF is already-reduced.
10:46:08 <Cale> MyCatVerbs: HNF means a similar thing to WHNF except that it works inside a lambda as well.
10:46:35 * lpsmith is wondering how to implement callCC on a continuation monad that doesn't expose the type of it's final result.
10:46:51 <jmcarthur_work> lpsmith, using forall?
10:46:57 <lpsmith> yupp
10:47:07 <lpsmith> http://hpaste.org/view?id=6006#a6006
10:47:21 <jmcarthur_work> i think i saw one once, but i have no idea how to do it myself without sitting and thinking for a while
10:47:29 <jmcarthur_work> i may be remembering wrong anyway
10:48:06 <lpsmith> well, I haven't thought about it terribly deeply yet
10:48:14 <jmcarthur_work> i believe the actual implementation should be about the same
10:48:44 <lpsmith> It seems as though it can be done;   only problem is that the way I made it work,  by using two forall's,  prevents one from leaving the monad...
10:49:10 <jmcarthur_work> oh i didn't notice the two foralls
10:49:15 <jmcarthur_work> only saw one, i mean
10:49:48 <lpsmith> Talking about the hypothetical implementation you may or may not have seen?
10:49:59 <jmcarthur_work> no, yours
10:50:02 <lpsmith> oh
10:50:03 <lpsmith> lol
10:50:08 <jmcarthur_work> i just didn't look closely enough ;)
10:50:16 <EvilTerran> ... is the topic of conversation in any way related to the way STRefs are trapped?
10:50:43 <jmcarthur_work> yeah i'm not so sure that forall r. (forall s. (a -> m s)) -> m r is going to be very friendly to you
10:51:01 <EvilTerran> ?type runST
10:51:02 <lambdabot> forall a. (forall s. ST s a) -> a
10:51:02 <jmcarthur_work> EvilTerran, higher ranked callCC
10:51:14 <EvilTerran> ah
10:51:44 <lpsmith> actually, I don't need a higher ranked callCC,   but I'll take that as well :-P
10:53:27 <jmcarthur_work> i think, without really checking myself, that (forall r. (a -> m r) -> m r) is all that you will be able to do
10:53:37 <lpsmith> Yeah, the two foralls are very friendly,  until you actually want to leave the monad.
10:53:48 <lpsmith> You can run (fib 20) for example,  and it works
10:53:59 <lpsmith> but I used "error" to print out what it did
10:54:04 <jmcarthur_work> ha
10:54:25 <jmcarthur_work> obviously you should throw and catch an exception with unsafePerformIO :P
10:54:46 <Baughn> Am I a bad person for actually considering that a possible solution?
10:54:52 * Baughn has been doing too much FRP
10:54:59 <jmcarthur_work> Baughn, yucky!
10:55:17 <jmcarthur_work> Baughn, of course, this may be why my approaches to FRP have been taking longer to manifest themselves
10:55:27 <jmcarthur_work> i'm not doing that kind of stuff!
10:55:50 <jmcarthur_work> it's why i found the unamb stuff unacceptable, too
10:55:51 <lpsmith> yeah,  the problem is that the (forall r. (a -> m r) -> m r)  gives me a type error with regard to callCC
10:56:03 <jmcarthur_work> relies too much on undocumented behaviors of GHC
10:56:11 <jmcarthur_work> and that clearly has had actual consequences, now
10:56:31 <jmcarthur_work> so now i can rub it in peoples' faces (but i cry with those people, too)
10:56:40 <Baughn> jmcarthur_work: Sure. That's why I'm doing a version that /doesn't/ rely on undefined behaviour.
10:56:45 <lpsmith> EvilTerran:  this problem might actually have something to do with the phantom types in ST
10:56:45 <Baughn> Still uses uPIO, though
10:57:12 <lpsmith> Or at least,  the solution might be.  I dunno.  Sigh.
10:57:33 <jmcarthur_work> lpsmith, could it be that the MonadCont type class gives callCC the wrong type?
10:57:51 <jmcarthur_work> that is, it should be more general than it is?
10:58:01 <lpsmith> I thought I tried that.  Let me try again
10:59:47 <jmcarthur_work> Baughn, of course, i have been convinced that the unamb stuff is theoretically sound. it just isn't very well implementable in GHC right now :(
11:00:30 <jmcarthur_work> i still was/am disturbed by the idea of requiring massive multithreading to use FRP style though
11:02:08 <Baughn> Implementing improving numbers is the only real problem, there
11:02:25 <Baughn> It's relatively simple.. I can't figure out a non-threaded way, though
11:02:47 <lpsmith> callCC :: ((a -> (forall b. Cont b)) -> Cont a) -> Cont a
11:02:56 <lpsmith> doesn't work,  with the single forall
11:03:37 <lpsmith> Probably for reasons analogous to why ST needs a phantom type
11:04:20 <wy_> hello
11:04:33 <sjoerd_visscher> Hi all, cabal install pcre-light fails. It's missing pcre.h
11:04:50 <sjoerd_visscher> anybody any idea what that might be?
11:04:50 <Baughn> sjoerd_visscher: It's a binding to libpcre. You need to install libpcre-dev.
11:04:57 <wy_> What do you guys think about Clojure. I looked at it yesterday and it seems to be interesting
11:05:34 <lpsmith> Baughn:  If sjoerd is using Debian or debian derived distribution :-)
11:05:47 <lpsmith> But that was my initial guess as well
11:05:56 <sjoerd_visscher> I'm on MacOSX
11:06:43 <Baughn> sjoerd_visscher: You need the pcre development headers, one way or another.
11:06:43 <lpsmith> Have you tried fink?
11:06:55 <Baughn> sjoerd_visscher: There would be several possible ways to install them.. one's fink, yes
11:07:32 <jmcarthur_work> is (a -> forall b. Cont b) the same as (forall b . a -> Cont b)?
11:07:42 <lpsmith> Baughn, what's your preferred solution?
11:07:52 <lpsmith> jmcarthur_work:   it should be
11:08:02 <lpsmith> They logically imply each other
11:08:07 <jmcarthur_work> it was an honest question, not a suggestion, btw
11:08:14 <jmcarthur_work> that's what i thought
11:08:16 <Baughn> lpsmith: I'm not sure yet. Ask me in a week.
11:08:16 <mauke> jmcarthur_work: I don't think so
11:08:21 <mauke> oh wait, Cont
11:09:37 <lpsmith> mauke:  you should be able to move (forall a.   ... -> ... a ...) to  (... -> forall a.  ... a ...) and back
11:09:46 <lpsmith> For arbitrary ...
11:09:50 <lpsmith> But maybe I'm wrong
11:10:14 <lpsmith> (Just as long as "a" doesn't appear on the left of the arrow.   Then you can't do that)
11:10:56 <sjoerd_visscher> I've never used fink, but sudo port install pcre did the trick. Thanks!
11:12:56 <lpsmith> sjoerd_visscher:  yeah, I tended to use portage myself.   I haven't used a mac in a little while though.
11:14:47 <Apocalisp> How would you QuickCheck something like a query language interpreter? Generate arbitrary data and then run arbitrary queries over the data? Trying to get a clue on how to define whether a query result is correct.
11:15:56 <lpsmith> jmcaurthur:  apparently,  I was wrong.  You can't move the forall around like that.
11:17:26 <SamB> Apocalisp: find some identities in the query language ?
11:18:50 <jmcarthur_work> :t id :: a -> (forall b . b)
11:18:52 <lambdabot>     Couldn't match expected type `forall b. b'
11:18:52 <lambdabot>            against inferred type `a'
11:18:52 <lambdabot>       `a' is a rigid type variable bound by
11:19:22 <jmcarthur_work> why did i do that
11:19:24 <lpsmith> right,  but you obviously can't do that,  because "a" appears in the l.h.s. of the thing
11:19:51 <lpsmith> The question is,  why *can't* you do that if A doesn't appear?   My curry-howard intuition is failing me.
11:22:55 <jmcarthur_work> :t (undefined :: forall a . a -> (forall b . b)) :: forall a b . a -> b
11:22:57 <lambdabot> forall a b. a -> b
11:23:49 <jmcarthur_work> :t (undefined :: forall a b . a -> b) :: forall a . a -> (forall b . b)
11:23:51 <lambdabot> forall a b. a -> b
11:23:51 <lpsmith> :t (undefined :: forall a b . a -> b) :: forall a . a -> (forall b . b)
11:23:53 <lambdabot> forall a b. a -> b
11:23:59 <jmcarthur_work> unifies both ways
11:24:22 <lpsmith> :t (undefined :: forall a b . a -> m b) :: forall a . a -> (forall b . m b)
11:24:24 <lambdabot> Not in scope: type variable `m'
11:24:24 <lambdabot> Not in scope: type variable `m'
11:24:52 <lpsmith> :t (undefined :: forall a b . a -> [b]) :: forall a . a -> (forall b . [b])
11:24:53 <lambdabot>     Inferred type is less polymorphic than expected
11:24:54 <lambdabot>       Quantified type variable `b' escapes
11:24:54 <lambdabot>     In the expression:
11:25:42 <jmcarthur_work> :t (undefined :: forall a m b . a -> m b) :: forall a m . a -> (forall b . m b)
11:25:43 <lambdabot>     Inferred type is less polymorphic than expected
11:25:43 <lambdabot>       Quantified type variable `b' escapes
11:25:43 <lambdabot>     In the expression:
11:26:01 <lpsmith> :t (undefined :: forall a . a -> (forall b . [b])) :: forall a b . a -> [b]
11:26:02 <lambdabot> forall a b. a -> [b]
11:26:07 <lpsmith> hmm
11:26:10 <jmcarthur_work> oh that's more interesting
11:26:36 <jmcarthur_work> :t (undefined :: forall a m . a -> (forall b . m b)) :: forall a m b . a -> m b
11:26:37 <lambdabot> forall a (m :: * -> *) b. a -> m b
11:26:52 <lpsmith> hehe,  I was in the process of typing the same thing
11:26:54 <lpsmith> very interesting
11:27:22 <lpsmith> What's the curry-howard intuition of [] or m :: * -> *
11:27:28 <lpsmith> A modal operator?
11:27:44 <lpsmith> I'll admit my logic is a little weak in some respects.
11:27:57 <lpsmith> Something beyond first-order logic/
11:27:58 <lpsmith> ?
11:28:09 <lpsmith> higher order logic?
11:28:22 <jmcarthur_work> beyond me
11:32:05 <Saizan> yes, abstracting over variables of kind * -> * means you're in third order logic
11:32:20 <Saizan> (propositional)
11:34:06 <lpsmith> Saizan:  but we don't need to abstract over such variables
11:34:39 <lpsmith> :t (undefined :: forall a . a -> (forall b . [b])) :: forall a b . a -> [b]
11:34:41 <lambdabot> forall a b. a -> [b]
11:34:52 <lpsmith> is that still basically a third order theorem then?
11:35:26 <lpsmith> :t (undefined :: forall a b . a -> [b]) :: forall a. a -> (forall b. [b])
11:35:27 <lambdabot>     Inferred type is less polymorphic than expected
11:35:28 <lambdabot>       Quantified type variable `b' escapes
11:35:28 <lambdabot>     In the expression:
11:35:30 <lpsmith> while that isn't?
11:38:21 <lpsmith> (I mean,  don't get me wrong,  my understanding of logic past first order is not good.)
11:43:52 <Apocalisp> SamB: Ah, I see what you mean. Thanks, that's a good start.
11:51:19 <SamB> Apocalisp: and if you can't find any, maybe you need a better query language ;-P
12:09:16 <master_of_master> hi, I'd like to know how I could make http://pastebin.com/d75d3de83 faster, nicer or more efficient. (I'm new to haskell...)
12:09:54 <burp> use $ instead of so many brackets for example
12:10:24 <burp> "(words (head b))" could be written as "words $ heads b" etc. etc.
12:10:46 <lpsmith> burp: ehh.   That's not that important
12:10:55 <skorpan> @src (!!)
12:10:55 <lambdabot> xs     !! n | n < 0 = undefined
12:10:55 <lambdabot> []     !! _         = undefined
12:10:55 <lambdabot> (x:_)  !! 0         = x
12:10:55 <lambdabot> (_:xs) !! n         = xs !! (n-1)
12:11:10 <burp> lpsmith: he asked for it
12:11:38 <Ge0rge> Good evening. I am wondering: should I expect ghc --make to work with hs-boot files?
12:11:50 <lpsmith> master_of_master:   a really small thing is that you can do is get rid of mul
12:11:56 <Crusty84> Does domeone know a good tutotial on how to decode bits strings (encoded using Data.Bits .|. )??
12:12:12 <lpsmith> if you want to use it prefix you can always write it as (*)
12:12:14 <skorpan> master_of_master: i would probably write that program so that it generates the complete output before actually outputting it
12:12:54 <master_of_master> skorpan: that's a good idea, but I don't know how
12:12:57 <lpsmith> burp:  I meant using ($) to get rid of parens.   It can be nice now and then, but using ($) isn't that big a deal :-)
12:13:10 <lpsmith> It is important to help master_of_master :-)
12:13:24 <skorpan> master_of_master: you'll figure it out.. one other thing is to use pattern matching e.g. (x:xs) instead of (head something) and (tail something)
12:13:56 <burp> he wanted it nicer too :p .. in aspect of visual beauty ;)
12:14:17 <burp> but never mind
12:14:22 <skorpan> burp: i think most parens disappear once he starts using (*) instead of mul and (x:xs) instead of head/tail
12:14:59 <bremner> head considered harmful
12:15:03 <skorpan> master_of_master: another nice thing to know is that whenever you write "putStrLn (show xyz)" you can instead write just "print xyz"
12:15:21 <skorpan> master_of_master: i.e. "print = putStrLn . show"
12:15:23 <skorpan> @src print
12:15:24 <lambdabot> print x = putStrLn (show x)
12:16:03 <conal> master_of_master: you can get all of the imperative code out of the heart of your code.  and use interact.
12:16:08 <conal> @type interact
12:16:09 <lambdabot> (String -> String) -> IO ()
12:16:34 <conal> master_of_master: then you'll get more of a feel for functional programming.
12:17:05 <skorpan> i think the really big thing in this case is to rewrite the program to generate the complete output before outputting it, that should teach you a lot
12:17:16 <skorpan> i.e. getting rid of the IO monad
12:17:21 <conal> exactly
12:17:40 <Baughn> For a syntactic rather than dynamic definition of "before"
12:17:44 <sjoerd_visscher> @src interact
12:17:45 <lambdabot> interact f = do s <- getContents; putStr (f s)
12:18:13 <conal> master_of_master: the essence of functional programming is modularity/composition.  break up your program into functions that can be composed.
12:18:34 <skorpan> master_of_master: "one function does one thing", etc. in your case "doit" does two things!
12:18:49 <conal> it does even more than two things
12:18:57 <master_of_master> skorpan: that could be fixed
12:19:13 <skorpan> conal: what more does it do?
12:19:27 <conal> skorpan: what do you have so far?
12:19:30 <Baughn> The essence of functional reactive programming, meanwhile, is fighting with GHC
12:19:40 <conal> Baughn: heh
12:19:45 <Baughn> conal: I'm not sure, but I /think/ I can get improving values working with /no/ threads
12:19:47 <skorpan> conal: well, multiplying and printing basically
12:19:58 <Baughn> conal: Albeit a bit weirdly
12:20:02 <conal> skorpan: it also reads
12:20:15 <conal> i.e., parses
12:20:53 <skorpan> conal: but you wouldn't define a function "helper = read" and then use helper... i mean things that the function does that can be put into other functions.
12:20:59 <conal> i see: get input stream, parse, add, print
12:21:18 <conal> skorpan: i wouldn't either.
12:22:14 <conal> the input/output part can become interact, leaving parse & process (add)
12:22:43 <conal> @where why_fp
12:22:43 <lambdabot> I know nothing about why_fp.
12:22:48 <conal> @where why_matters
12:22:49 <lambdabot> I know nothing about why_matters.
12:22:53 <skorpan> @where why fp matters
12:22:54 <conal> hm.
12:22:54 <lambdabot> I know nothing about why.
12:22:59 <skorpan> @where why
12:23:00 <lambdabot> I know nothing about why.
12:23:04 <skorpan> oh, that was silly
12:23:10 <Baughn> @faq Does FP matter?
12:23:10 <lambdabot> The answer is: Yes! Haskell can do that.
12:23:18 <skorpan> fail
12:23:20 <conal> @where+ why_fp http://www.cs.chalmers.se/~rjmh/Papers/whyfp.html
12:23:21 <lambdabot> Done.
12:23:38 <conal> master_of_master: check out that paper ("Why Functional Programming Matters")
12:25:02 <sjoerd_visscher> in ghci, how should you break out of interact?
12:25:20 <voker57_> try ctrl+d
12:25:50 <conal> master_of_master: do you understand what i mean about separating your code into I/O, parsing, and processing?
12:26:14 <master_of_master> conal: I understand that, and I'm improving my code
12:26:30 <lpsmith> sjoerd_visscher:  ^C not working?
12:26:32 <conal> cool
12:26:33 <sjoerd_visscher> ctrld doesn't seem to work
12:26:40 <lpsmith> oh
12:26:41 <lpsmith> :q
12:27:13 <lpsmith> ^D works for me too
12:27:29 <sjoerd_visscher> ^C works, but the next time you run interact it says *** Exception: <stdin>: hGetContents: illegal operation (handle is closed)
12:27:30 <monochrom> OS-dependent.
12:27:40 <sjoerd_visscher> Mac here
12:27:46 <saml> I'm a PC
12:27:49 <mauke> nothing works here
12:28:02 <mauke> except for ^Z, which suspends ghci
12:28:03 <System_X> Does Haskell allow for standby? .. I am writting a do funcion in which I would like my program to pause for 15 seconds midway through exicution. Is there a function which allows for this or must I create one?
12:28:04 <monochrom> ^C really kills something abruptly, not a normal ending.
12:29:08 <voker57_> System_X: threadDelay
12:30:17 <jmcarthur_work> master_of_master, i have a one-liner for it if you want it, but if you would rather try to work through it yourself more i can hold it back
12:31:16 <lpsmith> jmcarthur_work:  lol,  I don't have a one-liner,  but it comes close.
12:31:24 <jmcarthur_work> master_of_master, it goes against what conal is saying a bit, but it wouldn't be hard to distinguish the stages either
12:31:52 <hackagebot> storable-tuple 0.0.1 - Storable instance for pairs and triples (HenningThielemann)
12:31:57 <apsod> :w
12:32:02 <Saizan> System_X: see threadDelay
12:32:15 * apsod slinks away quietly
12:35:07 <master_of_master> jmcarthur_work: thanks for your work, but I'd like to try it on my own. Maybe later
12:35:31 <jmcarthur_work> master_of_master, sure thing
12:40:05 <jmcarthur_work> master_of_master, don't look yet, but here's my solution for you to look at later http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6009#a6009
12:40:25 <jmcarthur_work> i made a version that is separated into stages for that paste, too
12:40:38 <master_of_master> jmcarthur_work: thanks for the link, I'll keep my browser closed :)
12:42:48 <apsod> jmcarthur_work: What's foldll? Hoogle doesn't turn up anything.
12:43:00 <jmcarthur_work> :t foldl1
12:43:02 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
12:43:10 <apsod> oh, I just have a broken font <3
12:43:14 <jmcarthur_work> it assumes the list isn't empty
12:43:20 <jmcarthur_work> ah heh
12:43:53 <lpsmith> jmcarthur_work: basically the same as mine;   though why not use "product" instead of "foldl1" and the $ seems a bit gratuitous
12:44:02 <lpsmith> but yes, very nice
12:44:08 <jmcarthur_work> lpsmith, because i forgot about product ;)
12:44:11 <lpsmith> more nicely presented
12:44:27 <jmcarthur_work> and i just use $ pretty much wherever i can, really
12:44:40 <apsod> heh
12:44:50 <lpsmith> Well, knowing about foldl is important... so it might have pedagogical benefit ;-)
12:45:18 <Administrador> j python
12:45:22 <lpsmith> Yuck.  I use $ once in a while,  but I usually prefer parens
12:45:33 <jmcarthur_work> lpsmith, there, fixed both of those for you :P http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6009#a6010
12:45:59 <lpsmith> you didn't test it.  :-P
12:46:03 <lpsmith> I can see a bug
12:46:35 <monochrom> I never use $ to just write "f $ x". You have to force me to write "map ($ x) [f,g,h]" if you want me to use $ .
12:46:43 <jmcarthur_work> woops
12:46:55 <jmcarthur_work> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6009#a6012
12:46:58 <lpsmith> lol :-)
12:47:09 <jmcarthur_work> monochrom, i don't do that either, that's horrible
12:47:11 <monochrom> I hate $. $ is the root of all evils.
12:47:17 <conal> jmcarthur_work: and drop the other foldl1 (*)
12:47:26 <jmcarthur_work> gah you guys are picky
12:47:33 <conal> :)
12:47:54 <jmcarthur_work> there. just hit refresh because i'm not pasting any more links
12:48:13 <conal> jmcarthur_work: now *that's* some functional programming!
12:49:00 <conal> jmcarthur_work: that's exactly the style i'd like master_of_master to master
12:49:19 <master_of_master> ok, now I think I've seperated IO, split, mul. But how can I force haskell to print a list of Integers line by line?
12:49:19 <jmcarthur_work> conal, ;)
12:49:20 <monochrom> ....  hahaha
12:49:37 <lpsmith> :t mapM_ print
12:49:39 <lambdabot> forall a. (Show a) => [a] -> IO ()
12:49:56 <conal> but don't!
12:50:04 <jmcarthur_work> master_of_master, i take it you aren't using interact
12:50:28 <conal> master_of_master: you can use just a single putStrLn
12:50:34 <monochrom> interact (unlines . map show . \_ -> [1,2,3])  prints a list of integers.
12:50:54 <conal> master_of_master: or interact.  make your IO code be tiny!
12:51:06 <monochrom> replace \_ -> [1,2,3] by your favourite parsing and calculation stages.
12:51:13 <jmcarthur_work> monochrom, you prefer \_ -> to const?
12:51:32 <monochrom> No.
12:51:53 <jmcarthur_work> just checking. some people do, but i haven't managed to get a why yet
12:52:05 <jmcarthur_work> i'm merely curious
12:52:56 <monochrom> Two neural paths were competing in my brain. One path says const, the other says \_ ->. One of them happened to be faster for once. No reason.
12:52:57 <conal> master_of_master: imperative programming (IO in Haskell) thwarts composability and reasoning, so isolate is as much as possible.  e.g., a single call to interact.
12:53:06 <FliP^2eH> How do I convert an Integer (Not Int) to Double?
12:53:35 <Cale> FliP^2eH: fromIntegral
12:53:45 <FliP^2eH> Thanks :)
12:53:46 <conal> monochrom: thread racing, with semantically equivalent results.  feel free to use Data.Unamb
12:53:59 <conal> ;)
12:54:03 <Cale> FliP^2eH: No matter what integer-like type you pick, and no matter what kind of number you want, the answer is always fromIntegral ;)
12:54:25 <Cale> FliP^2eH: the other major conversion to know is realToFrac
12:54:32 <Cale> :t fromIntegral
12:54:32 <monochrom> I think I have been using that all the time, before it was written too.
12:54:34 <lambdabot> forall a b. (Integral a, Num b) => a -> b
12:54:39 <Cale> :t realToFrac
12:54:40 <lambdabot> forall a b. (Real a, Fractional b) => a -> b
12:54:43 <jmcarthur_work> heh, const x `unamb` (\_ -> x)
12:54:52 <conal> :)
12:54:53 <monochrom> My brain has a time machine and it exploits technologies in the future.
12:55:05 <FliP^2eH> @hoogle round
12:55:06 <lambdabot> Prelude round :: (RealFrac a, Integral b) => a -> b
12:55:06 <lambdabot> Text.XHtml.Transitional background :: String -> HtmlAttr
12:55:06 <lambdabot> package HipmunkPlayground
12:55:34 <conal> @hackage HipmunkPlayground
12:55:34 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HipmunkPlayground
12:56:01 <monochrom> For example I set up a virtual machine in my brain to learn each programming language I learned. Most of them were before there were virtual machines like VMWare.
12:56:15 <jmcarthur_work> unfortunate how imperative hipmunk is :(
12:56:29 <conal> jmcarthur_work: yeah.  yuck.
12:57:00 <conal> HipmunkPlayground build fail http://hackage.haskell.org/packages/archive/HipmunkPlayground/0.2/logs/failure/ghc-6.8
12:57:47 <FliP^2eH> How do I round with decimals?
12:57:55 <FliP^2eH> 4.2244353 -> 4.22
12:57:57 <FliP^2eH> Not 4.
12:58:52 <Zao> Multiply by 100, round, divide by 100? :)
12:58:55 <gnuvince> @src (^)
12:58:56 <lambdabot> x ^ 0            =  1
12:58:56 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
12:58:56 <lambdabot>   where f _ 0 y = y
12:58:56 <lambdabot>         f x n y = g x n
12:58:56 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
12:58:58 <lambdabot>                       | otherwise = f x (n-1) (x*y)
12:58:59 <Cale> > (/ 10^2) . fromIntegral . round . (* 10^2) $ 4.2244353
12:59:00 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
12:59:02 <lambdabot>   4.22
12:59:23 <Gracenotes> this is odd -- http://hackage.haskell.org/packages/archive/astar/0.2.1/doc/html/Data-Graph-AStar.html
12:59:26 <Gracenotes> haddock messed up
12:59:31 <skorpan> hm, wouldn't such a function be nice to have in Prelude?
12:59:34 <Cale> Gracenotes: right
12:59:44 <Gracenotes> do you know what the bug is?
12:59:58 <Cale> Gracenotes: actually, I wonder if I uploaded it again if it would be right
13:00:20 <Gracenotes> mm. it looks right in the source
13:00:33 <jmcarthur_work> Gracenotes, wait, i don't see what bug you are talking about
13:00:35 <FliP^2eH> :t round
13:00:36 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
13:00:45 <EvilTerran> :t truncate
13:00:46 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
13:00:56 <Gracenotes> jmcarthur_work: look at the type signature in the source
13:01:45 <Cale> Gracenotes: http://cale.yi.org/AStar/dist/doc/html/astar/Data-Graph-AStar.html -- newer version of haddock
13:02:10 <jmcarthur_work> oh the parens
13:02:10 <Cale> er, older, actually :)
13:02:20 <skorpan> yi.org?
13:02:31 <Cale> It's a free subdomain provider.
13:02:35 <Gracenotes> hm.
13:02:43 <jmcarthur_work> i wonder if it is just because they are on separate lines
13:02:57 <jmcarthur_work> i didn't even notice. seems unambiguous to be, divided up that way
13:02:58 <Cale> jmcarthur_work: It's a bug in haddock
13:03:01 <jmcarthur_work> *to me
13:03:06 <Cale> It's not intentional
13:03:09 <jmcarthur_work> ah
13:03:12 <skorpan> what's the problem?  i can't see it.
13:03:27 <Cale> Missing parens which should be there
13:03:30 <jmcarthur_work> it is still wrong though
13:03:38 <skorpan> oh
13:05:19 <Gracenotes> interesting. MultiSet a is just a Map a Int
13:05:29 <Gracenotes> wonder what a MultiMap would be :)
13:05:35 <yitz> For the first time in a long time, I fired up my WinXP bootcamp partition, to download HP.
13:05:47 <yitz> I found that the haddocks are weird.
13:06:05 <EvilTerran> Gracenotes, Map a (Set b)?
13:06:09 <yitz> The entries on the index page are sometimes fully qualified, sometimes unqualified.
13:06:13 <siki> Hi everyone.
13:06:17 <Gracenotes> heh. maybe :x.
13:06:21 <yitz> Anyone else see that?
13:06:35 <EvilTerran> and then you could have a MultiMultiMap, Map a (Map b Int) :P
13:06:37 <yitz> hi siki
13:06:55 <siki> What's the cleanest, nicest easiest way to execute a function like "transpose :: [[a]] -> [[a]]" on an [IO [Double]]?
13:07:06 <FliP^2eH> :t (/)
13:07:07 <lambdabot> forall a. (Fractional a) => a -> a -> a
13:07:12 <Baughn> siki: sequence?
13:07:15 <mauke> siki: that depends on what you want to do
13:07:29 <jmcarthur_work> MultiMap might be Map a (MultiSet b)
13:07:30 <Cale> :t fmap transpose . sequence
13:07:32 <lambdabot> forall a (f :: * -> *). (Functor f, Monad f) => [f [a]] -> f [[a]]
13:08:38 <Zao> Is that the magical . or the regular one?
13:08:47 <siki> liftM transpose (sequence ...) would work as well, right?
13:08:50 <Zao> Nvm, missed the fmap there.
13:09:11 <RayNbow> Gracenotes: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5986#a5994 (since you weren't around this morning)
13:09:15 <conal> siki: same.  since liftM == fmap
13:09:25 <skorpan> what magical (.)?
13:09:26 <Cale> siki: that's basically what I wrote -- liftM is the same as fmap, only it just works for monads.
13:09:27 <siki> ok thanks a lot. I'm a noob
13:09:31 <yitz> Zao: you're thinking of (transpose .) . sequence
13:09:36 <jmcarthur_work> skorpan, in Caleskell, (.) = fmap
13:09:50 <conal> or (fmap.fmap) transpose sequence  (SEC-style)
13:10:16 <Gracenotes> I don't like (.) = fmap terribly much >_>
13:10:23 <skorpan> i don't even get it
13:10:32 <skorpan> is (.) = fmap for Functor (->) or something?
13:10:35 <Gracenotes> at least for idiomatic Haskell
13:10:37 <monochrom> Yes.
13:10:37 <skorpan> or the other way around rather
13:10:39 <Gracenotes> yeah, tis
13:10:41 <jmcarthur_work> @src ((->) a) fmap
13:10:42 <EvilTerran> skorpan, well, Functor ((->) e)
13:10:43 <lambdabot> Source not found. Do you think like you type?
13:10:50 <skorpan> EvilTerran: ah, well
13:10:53 <mauke> @src (->) fmap
13:10:54 <lambdabot> fmap = (.)
13:10:57 <EvilTerran> skorpan, the trick, i find, is to consider the simularity between (a -> b) and (a `Map` b)
13:10:59 <Gracenotes> @src (->) fmap
13:10:59 <lambdabot> fmap = (.)
13:11:01 <Gracenotes> oh nos
13:11:07 <yitz> or fmap . fmap transpose $ sequence
13:11:08 <conal> or use result = (.), in analogy with first and second
13:12:06 <EvilTerran> skorpan, and considering Functor etc instances for (Map k), and how to translate them into instances for ((->) k)
13:12:11 <conal> what i like about (fmap.fmap) or (result.fmap) is that it exactly says to how aim transpose at sequence.
13:12:11 <jmcarthur_work> conal, i find myself worried about strictness properties of SECs, but that may just be because i haven't reasoned that out yet
13:12:20 <jmcarthur_work> conal, but i know that second and fmap are not the same
13:12:29 <conal> and it generalizes nicely to Deep Arrows
13:13:39 <conal> jmcarthur_work: yeah.  fmap & second are slightly different SECs on pairings
13:14:12 <conal> jmcarthur_work: and the SEC idea is independent from Functor.
13:14:15 <jmcarthur_work> i just get afraid that i will go with which word sounds right rather than which function is correct
13:15:09 <jmcarthur_work> yeah i know it's not the same as Functor, but they are related, right? it's not mere coincidence that many SECs involve fmap, i suspect
13:15:34 <conal> jmcarthur_work: i think it is just a coincidence.
13:16:02 <Heffalump> @seen CosmicRay
13:16:02 <lambdabot> I saw CosmicRay leaving #haskell-blah, #haskell-overflow and #haskell 5m 1d 21h 28m 27s ago, and .
13:16:38 <jmcarthur_work> are SECs about more than zeroing in on things that are nested deeply into structures (where i include functions as structures, also)?
13:17:11 <conal> jmcarthur_work: zeroing in, in order to apply a function ("editor")
13:17:31 <jmcarthur_work> right. that sounds very much like fmap in my head
13:17:37 <jmcarthur_work> just more general
13:18:02 <conal> jmcarthur_work: yeah.  it always works for functors.  and works beyond fmap as well.
13:18:17 <conal> jmcarthur_work: also, there are some related/dual combinators in the Eros paper.
13:18:26 <conal> @where eros
13:18:26 <lambdabot> http://conal.net/papers/Eros
13:19:06 <conal> for when the function (editor) is buried rather than the argument.
13:19:07 <skorpan> ramazotti
13:19:11 <defun> hey what is munching in the context of parsers?
13:19:23 <jmcarthur_work> huh, i will definitely have to look for that
13:19:28 <mauke> om nom nom
13:19:31 <conal> defun: like "maximal munching"?
13:19:36 <defun> yes.
13:20:07 <Cale> defun: Maximal munching refers to the idea that the parser will consume the largest possible amount of the input
13:20:53 <Baughn> Cale: Oh. Same thing as conspicuous consumption, then?
13:20:55 <Cale> (subject to the condition that the parse succeeds)
13:20:56 <defun> Cale: what would that achieve?
13:21:10 <Cale> defun: It resolves ambiguities
13:21:17 <Baughn> defun: Imagine an integer parser
13:21:31 <Baughn> defun: Given "123", it could parse either to 1, 12 or 123. WHich would you prefer?
13:21:41 <skorpan> 1
13:21:44 <Cale> heh
13:21:46 <defun> 123
13:21:50 <skorpan> why 123?
13:21:55 <skorpan> i'd definitely choose 1
13:22:01 * Baughn prefers 12
13:22:11 <defun> why not?
13:22:19 <skorpan> yeah, that was a horrible example
13:22:28 <skorpan> (not really though)
13:22:33 <skorpan> </troll>
13:22:37 <Baughn> It's an example of where maximal munching is /obviously/ the right thing
13:22:56 <Cale> Well, maybe some other parser wants to consume an integer right after this one, not separated by any spaces
13:23:08 <FunctorSalad> "munch" by itself just means "consume", doesn't it?
13:23:12 <FunctorSalad> with parsers.
13:23:14 <monochrom> I think since you are just trying to explain "what is munching", you don't have to defend or attack maximum munching.
13:23:31 <defun> thanks, it's clear now.
13:23:37 <lpsmith> so what do type constructors that have kind :: * -> * correspond to in logic via the Curry-Howard isomorphism?
13:23:43 <Cale> I'm just trying to explain why it might be ambiguous in the first place
13:24:04 <Cale> lpsmith: logical operators
13:24:16 <Cale> lpsmith: like modal operators
13:24:19 <Zao> How's Omg.Wtf parsed. Does the parse depend on whether Omg is a module or not?
13:25:07 <quicksilver> @hoogle numCapabilities
13:25:07 <lambdabot> No results found
13:25:08 <jmcarthur_work> > let relax = (+1) in Just.relax 0
13:25:09 <lambdabot>   Not in scope: `Just.relax'
13:25:27 <dino-> Zao: there could be an Omg.hs (module Omg) and also an Omg/Wtf.hs (module Omg.Wtf). Should not affect each other, if that's what you're asking.
13:25:29 <quicksilver> bah.
13:25:37 <quicksilver> numCapabilities :: Int
13:25:40 <quicksilver> that's the wrong type!
13:25:45 <FunctorSalad> I read that as "How's Omg. "Wtf" parsed!"
13:25:46 <quicksilver> bad GHC *thwap*
13:25:58 <monochrom> But Omg could be a data constructor too.
13:26:16 <quicksilver> that wouldn't change the parse
13:26:22 <quicksilver> Omg.Wtf is a module identifier
13:26:25 <jmcarthur_work> it parses as qualification, if lambdabot is to be believed
13:26:33 <quicksilver> if you wanted function composition you need a space around the .
13:26:36 <quicksilver> Omg . Wtf
13:26:42 <jmcarthur_work> > let relax = (+1) in Just.relax $ 0
13:26:44 <lambdabot>   Not in scope: `Just.relax'
13:27:07 <quicksilver> "." with an uppercase identifier on the left is always module syntax.
13:27:59 <Zao> I knew there were some reason one ought to use spaces around the period for composing ctors, but I thought it was due to the meaning of a non-spaced parse changing depending on which modules were around.
13:28:49 <quicksilver> GHC avoids cases where parsing depends on the wider symbol table
13:29:46 <Zao> How about standardness?
13:30:18 <FunctorSalad> haskell-mode encourages you do use a space anway :)
13:30:33 <FunctorSalad> (otherwise it won't turn the dot into a pretty unicode character)
13:30:43 <hape> .... currently reading the haskellwiki for "Haskell Mode for Emacs" -  - -that is funny!!  "inf-haskell.el: the best thing since the breadknife"   :-)
13:30:50 <Zao> Silly Emacs. Too smart for its own best :)
13:31:44 <FunctorSalad> Zao: nah, it's the correct behaviour. I meant turning it into \circ â
13:32:05 <skorpan> â
13:32:23 <skorpan> (that's \circ)
13:32:34 <FunctorSalad> not with my scim skorpan
13:32:51 <skorpan> according to tex-input-mode in emacs that's circ
13:33:26 <FunctorSalad> tex-input method would be great for haskell if it didn't make entering comments nearly impossible ;) I once modified it but I lost it.
13:33:26 <monochrom> Clearly â
13:33:57 <quicksilver> Zao: hierarchical modules aren't in the standard.
13:34:25 <skorpan> describe-char tells me the smaller circle is "RING OPERATOR" and the big one from my \circ was white circle or something
13:34:35 <skorpan> i wonder if this is a bug in tex-input-mode
13:34:46 <skorpan> or if \circ in fact should be the big one
13:34:46 <Zao> quicksilver: Ah. Explains all the top-level List etc.
13:34:56 <quicksilver> right.
13:35:33 <monochrom> If you enter \circ into a LaTeX document, you clearly see a small circle, not a big circle.
13:36:37 <skorpan> i'm still unsure whether this is a bug or not
13:36:51 <skorpan> i don't suppose it's different in LaTeX compared to TeX?
13:36:59 <sbahra> \Circ?
13:36:59 <monochrom> No difference.
13:37:04 <sbahra> Random guess.
13:37:12 <skorpan> \Circ doesn't exist
13:37:16 <sbahra> \bigcirc
13:37:27 <skorpan> â¯
13:37:39 <skorpan>   name: LARGE CIRCLE
13:37:41 <sbahra> or \bigcirc.
13:37:43 <skorpan> this is weird
13:37:46 <FunctorSalad> that's big.
13:38:56 <skorpan> i'm still a bit suspicious... maybe it's the font in standard LaTeX documents that make \circ look smaller than in monospaced fonts?
13:39:49 <FunctorSalad> LaTeX doesn't render operators via unicode, does it?
13:39:54 <monochrom> No.
13:40:26 <Raevel> knuthicode
13:41:12 <hackagebot> fmlist 0.1 - FoldMap lists (SjoerdVisscher)
13:42:04 <conal> @hackage fmlist
13:42:05 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/fmlist
13:42:57 <FunctorSalad> what's the difference to Data.Seq in purpose?
13:43:07 <FunctorSalad> meh or Data.Sequence.Seq
13:43:23 <sbahra> FunctorSalad: XeLaTeX
13:43:36 <copumpkin> mmm I love xelatex
13:43:38 <skorpan> fwiw i asked emacs-devel about it
13:44:21 <FunctorSalad> should have gone all the way with the name... XeTaLaTeX
13:44:36 <FunctorSalad> :)
13:44:39 <lpsmith> :t (undefined :: forall b. Int -> (Bool, b)) :: Int -> forall b. (Bool, b)
13:44:40 <lambdabot>     Inferred type is less polymorphic than expected
13:44:41 <lambdabot>       Quantified type variable `b' escapes
13:44:41 <lambdabot>     In the expression:
13:45:18 <jmcarthur_work> oh nice to see the foldmap list stuff get put up
13:46:20 <Jedai> fmlist description : "but other operations might have favorable performance characteristics as well. These wild claims are still completely unverified though. "
13:46:26 <lpsmith> Ok,  unless I'm really going crazy,   forall x.  P -> Q /\ R(x)   ==>  P -> Q /\ forall x. R(x)      is a theorem of first order classical logic.
13:46:30 <Jedai> I like the description...
13:46:35 <jmcarthur_work> heh, yeah
13:46:51 <lpsmith> is it not a theorem of intuitionistic logic?
13:47:04 <jmcarthur_work> the library was probably made more for the mental exercise than the benefits
13:47:12 <jmcarthur_work> but i would like to play with it too
13:47:20 <lpsmith> I'm making some kind of very elementary mistake here.
13:47:34 <lpsmith> And it's frustrating me.
13:48:00 <jmcarthur_work> lpsmith, sorry for posing the question then!
13:48:20 <jmcarthur_work> why the Q/\ ?
13:48:36 <lpsmith> jmcarthur_work:   no,  I'm glad you asked it :-)
13:48:38 <lpsmith> err
13:48:42 <lpsmith> well,  I meant to wrote
13:49:03 <jmcarthur_work> lpsmith, well, if you figure it out i would love to know myself
13:49:09 <Jedai> :t (undefined :: Int -> (Bool, forall b . b)) :: forall b . Int -> (Bool, b)
13:49:11 <lambdabot>     Couldn't match expected type `b'
13:49:11 <lambdabot>            against inferred type `forall b1. b1'
13:49:11 <lambdabot>       `b' is a rigid type variable bound by
13:49:18 <lpsmith> forall x.   P -> Q /\ R(x)     ==>    P -> forall x.  Q /\ R(x)
13:49:44 <jmcarthur_work> but why that and not...
13:49:56 <jmcarthur_work> forall x.   P -> R(x)     ==>    P -> forall x.  R(x)
13:50:09 <lpsmith> oh, that's a theorem
13:50:14 <lpsmith> and that typechecks
13:50:21 <lpsmith> so that doesn't worry me :)
13:51:23 <monochrom> â§ makes me unsure. (âx.Qâ§R(x)) â Qâ§âx.R(x)  how to do this? constructively?
13:51:41 <jmcarthur_work> :t (undefined :: forall b . Int -> [b]) :: Int -> (forall b . [b])
13:51:43 <lambdabot>     Inferred type is less polymorphic than expected
13:51:43 <lambdabot>       Quantified type variable `b' escapes
13:51:43 <lambdabot>     In the expression:
13:52:25 <jmcarthur_work> fails to type check perfectly well without the Q/\
13:52:43 <lpsmith> monochrom:  that's a bidirectional theorem,   forall is basically and,  so it works both ways.
13:52:58 <lpsmith> intuitionalistically
13:53:00 <lpsmith> even
13:54:23 <lpsmith> what's bothering me is this:
13:54:46 <jmcarthur_work> maybe it would be instructive to try to prove it in Coq or something?
13:54:56 <FunctorSalad> monochrom: intro H; destruct H as [H1 H2]; split; exact H1; intro x; exact (H2 x)
13:54:58 <lpsmith> :t (undefined :: forall b . (Int ->  (Bool, b))) :: (Int -> forall b. (Bool,b))
13:54:59 <lambdabot>     Inferred type is less polymorphic than expected
13:54:59 <lambdabot>       Quantified type variable `b' escapes
13:54:59 <lambdabot>     In the expression:
13:55:02 <lpsmith> yeah, you are probably right
13:55:33 <lpsmith> I suppose I should consider breaking out a theorem prover.
13:55:52 <lpsmith> I need to get better at using them anyways
13:56:38 <lpsmith> but clearly,  I'm making a simple mistake,  or something I think I understand I don't
13:57:06 <FunctorSalad> I usually give up when trying to apply equalities inside expressions using dependent types ;)
13:57:32 <lpsmith> lol
14:13:54 <MartyIX> And tomorrow is the exam from Haskell.. Wish me luck :o)
14:14:08 <monochrom> I wish you logic.
14:14:43 <monochrom> cold, hard, machine, calculating logic.
14:14:45 * Botje gives MartyIX a brass lambda.
14:14:48 <Botje> may it serve you well.
14:17:34 <lpsmith> :t (\x -> (undefined :: forall b . (Int ->  (Bool, b))) x) :: (Int -> forall b. (Bool,b))
14:17:36 <lambdabot> forall b. Int -> (Bool, b)
14:17:50 <lpsmith> heh
14:18:01 <lpsmith> I eta convert,  and it works.   And converts the type back into the first
14:18:07 <lpsmith> weird
14:18:19 <lpsmith> I'm not going crazy then.  :-)
14:18:25 <lpsmith> But interesting.
14:21:48 <jmcarthur_work> wha_?
14:26:04 <lpsmith> your guess is as good as mine.  But at least one little mystery is half-solved.
14:26:07 <jmcarthur_work> lpsmith, perhaps this problem is worth going to the mailing list?
14:27:35 <lpsmith> lol,  quite possibly.  I'm curious how NHC/YHC/UHC handles this
14:28:10 <MartyIX> Botje: monochrom: thanks :-))
14:32:24 <bastl> hi. I get a stack overflow error in ghci. Is there any option to increase the stack? (and I dont know how and dont want to change the code, it's not mine...)
14:32:43 <lpsmith> jmcarthur_work:  yeah,  eta conversion gets our original test expressions to typecheck as well
14:32:52 <Cale> bastl: there is...
14:33:08 <bastl> Ok, thanks
14:33:12 <Cale> ghc +RTS --help
14:33:17 <bastl> ah :-)
14:33:20 <Cale> ghc +RTS -K<size>
14:33:59 <Cale> for example, ghc +RTS -K5m will set a 5 megabyte stack :)
14:34:48 <Cale> (this is actually a parameter that you pass to the program, not at compile time to ghc)
14:35:14 <Cale> (unless GHC had a stack overflow ;)
14:35:25 <jmcarthur_work> lpsmith, wtf?!
14:35:49 <bastl> 5m dont suffice ... hmm
14:36:01 <bastl> can i set it inside a ghci session?
14:36:05 <jmcarthur_work> lpsmith, i know such transformations can affect how the code is run, the GC, etc., but what does it have to do with the types??
14:36:25 <Botje> bastl: it might pay off to compile it instead of running inside ghci
14:36:27 <lpsmith> lol,  obviously it's a limitation of the higher-ranked inference algorithm
14:36:42 <Botje> huge difference between interpreted and compiled code
14:36:45 <lpsmith> Which cannot automatically be inferred in every case
14:37:28 <lpsmith> but... I'm suprised it can't infer this one.   Then again, I've never written a first-order theorem prover,  let alone inferencer.
14:38:57 <lpsmith> it kinda makes sense to me,  why eta conversion might make this work.
14:42:55 <lpsmith> Well,  that detour was a distraction from what I was really trying to do...  actually the monad as is probably sufficient for what I want to do.
14:43:28 <lpsmith> I'm now 70% confident that I have a proof that mapCont cannot be expressed in terms of callCC,  return, and (>>=)
14:44:14 <FunctorSalad> @type mapCont
14:44:15 <lambdabot> forall r a. (r -> r) -> Cont r a -> Cont r a
14:46:07 <lpsmith> http://hpaste.org/view?id=6006#a6006  <-  and that basically is the proof.
14:46:40 <lpsmith> So I don't care too much that I can't use it for anything too useful.   I never intended to use it in a real program
14:49:25 <bastl> i have a very dumb question: In my Ghci some keys behave strange. e.g. <Del>,<POS1>,<END> dont work etc. Can i enable that somehow (i know its using "readline" and i can use Ctrl-A and Ctrl-E, Ctrl-R etc,  but still ...
14:51:55 <siki> anyone out there?
14:52:05 <jmcarthur_work> always
14:52:15 <siki> great!
14:52:24 <jmcarthur_work> ?users
14:52:25 <lambdabot> Maximum users seen in #haskell: 658, currently: 617 (93.8%), active: 16 (2.6%)
14:52:50 <giulianoxt> cool
14:52:51 <siki> is there a built in function for mapping a pure function over a list wrapped in a monad?
14:53:18 <opqdonut> liftM (map f)
14:53:27 <opqdonut> :t liftM
14:53:28 <jmcarthur_work> siki, like f :: (a -> b) -> m [a] -> m [b]?
14:53:29 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
14:53:33 <opqdonut> :t liftM . map
14:53:34 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> b) -> m [a] -> m [b]
14:53:55 <conal> :t fmap . map
14:53:56 <lambdabot> forall (f :: * -> *) a b. (Functor f) => (a -> b) -> f [a] -> f [b]
14:53:57 <jmcarthur_work> :t fmap . fmap -- generally
14:53:59 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
14:54:01 <jmcarthur_work> beat me
14:54:03 <conal> yeah
14:54:09 <conal> yours was more general.
14:54:19 <opqdonut> jmcarthur_work: fmap fmap fmap
14:54:23 <jmcarthur_work> yours maybe more clear
14:54:27 <opqdonut> :t fmap fmap fmap
14:54:28 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
14:54:34 <opqdonut> ;)
14:54:36 <jmcarthur_work> and that more obscure
14:54:55 <conal> and no more general.  and doesn't generalize to arrows.
14:55:17 <jmcarthur_work> :t fmap Control.Category.. fmap
14:55:19 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
14:55:19 <conal> siki: the monad part is unnecessarily specific.  functor is all you need.
14:55:33 <jmcarthur_work> oh i didn't lift that properly
14:55:35 <jmcarthur_work> whatever
14:55:43 <jmcarthur_work> not even sure if i can
14:55:58 <conal> well, fmap is a function.
14:56:10 <jmcarthur_work> i guess so, but that wasn't the kind of lifting my mind was using
14:56:11 <siki> Thanks everyone
14:56:14 <jmcarthur_work> but my mind was wrong
14:56:33 <conal> hooray for wrong-thinking
14:57:06 <siki> Here's another one for you to battle out: can memoization be done for a monadic function?
14:57:17 <lpsmith> bastl:  which version of ghci are you using?
14:57:17 <jmcarthur_work> siki, generally, no
14:57:39 <siki> that sucks :(
14:57:46 <jmcarthur_work> siki, not without changing semantics, anyway
14:57:52 <BONUS> studying for my discrete maths test atm, a thought just popped up in my head: permutations form a monoid. has anyone ever expressed permutations in haskell?
14:57:58 <lpsmith> Depending on the version, you are using either GNU readline, BSD editline,  or Haskeline, which is a native haskell solution.
14:58:00 <conal> siki: though yes for some monads.  do you have one in mind?
14:58:09 <FunctorSalad> opqdonut: I think fmap fmap fmap is just (fmap . fmap)
14:58:13 <Cale> siki: well... it depends on what you mean by that. Do you want effects to occur again?
14:58:16 <FunctorSalad> maybe you want (fmap.fmap.fmap)
14:58:21 <conal> siki: actually yes for all monads, but it might not mean what you expect
14:58:21 <jmcarthur_work> FunctorSalad, i think opqdonut knew that ;)
14:58:48 <Peaker> I think you can implement memoize that also lifts a monadic action into StateT, or allow memoizing only if a MonadState context exists
14:59:33 <opqdonut> FunctorSalad: yeh, the types force the first fmap to be in the reader functor
14:59:34 <siki> for example: the usual example given for memoization is the fibonacci function. how could this be memoized if the function "fib" is wrapped in a monad?
14:59:47 <Peaker> e.g:  memoize :: (Ord k, Monad m) => (k -> m a) -> k -> StateT (MemoTable k a) a
14:59:50 <jmcarthur_work> siki, arguably, fib shouldn't be wrapped in a monad ;)
14:59:54 <Peaker> oops:
14:59:59 <monochrom> permutations form a group. that gives you monoid. this is just repeating the previous pointless discussion "why no one has written Group typeclass and instances yet".
15:00:02 <BONUS> what if it's Identity
15:00:02 <conal> siki: first, i'd wonder why you' want to.
15:00:03 <Peaker> memoize :: (Ord k, Monad m) => (k -> m a) -> k -> StateT (MemoTable k a) m a
15:00:19 <Cale> siki: It depends on what you mean again. Which monad?
15:00:31 <FunctorSalad> why is that discussion pointless?
15:00:56 <Cale> siki: Supposing that you mean the IO monad, are the effects associated with computing the nth element supposed to occur repeatedly?
15:01:05 <BONUS> monochrom: i didn't know that discussion was active. i was mostly thinking about a concrete implementation of permutations. i represented them as data Permutation = Permutation { getPerm :: [Int] }
15:01:05 <jmcarthur_work> siki, memoization is most reliable if what you are memoizing is referentially transparent. monads are for abstracting effects. should this memoization also avoid applying those effects again?
15:01:10 <RayNbow> FunctorSalad: do you plan on putting your recent unfold function on hawiki?
15:01:11 <siki> as for the why: I want to write a function that uses random numbers and memoize that
15:01:13 <Peaker> lets say you want to memoize IO actions that do remote-socket interaction to read values
15:01:18 <monochrom> Because the participants talk the talk but not walk the walk.
15:01:44 <hackagebot> haskell-src-exts 0.5.4 - Manipulating Haskell source: abstract syntax, lexer, parser, and pretty-printer (NiklasBroberg)
15:01:58 <FunctorSalad> RayNbow: :o didn't think it was surprising enough for that
15:02:19 <FunctorSalad> monochrom: the walk wouldn't exactly be hard ;D
15:02:23 <jmcarthur_work> siki, say i memoized a random number generator. what should happen the second time i use it?
15:02:24 <siki> for example: let's say you modify the fibonacci function by adding a random number at every step.
15:02:24 <RayNbow> FunctorSalad: ah, but would you mind if someone put it on the wiki?
15:02:28 <FunctorSalad> so it makes sense to wonder why there isn't one already
15:02:33 <jmcarthur_work> siki, should it give me the same number as before or a different one?
15:02:33 <RayNbow> (there's no page on Unfolds yet)
15:02:45 <FunctorSalad> RayNbow: no I don't mind :)
15:03:07 <Twey> siki: It can't be memoised â that's the whole point of a monad
15:03:21 <jmcarthur_work> siki, if there is a portion of code that you want to memoize, it sounds like you need to remove that portion from your monadic code and make it pure
15:03:25 <Twey> Executing a monad means performing the computation it represents
15:03:43 <Twey> You can execute it first, of course, and thereby return a pure function, which can be memoised
15:04:05 <siki> jmcarthur_work: the number at "n" should always give you the same number (otherwise the whole memoization is pointles) but at n+1 it should use the number at n and do something with it including maybe adding another random value
15:04:18 <FunctorSalad> monochrom: maybe there needs to be a package named "mathematical-groups" instead of it being buried in one of the several packages that have groups though
15:04:18 <Twey> (e.g. use the monad to get a seed and use that to seed a pure pseudo-random computation)
15:04:25 <Twey> But the values will then be the same each time, of course
15:04:34 <jmcarthur_work> siki, sounds like you actually want an infinite list or something of that nature then
15:04:59 <siki> jmcarthur_work: something like that
15:05:39 <jmcarthur_work> :t randomsIO
15:05:41 <lambdabot> Not in scope: `randomsIO'
15:05:52 <jmcarthur_work> eh i forget it
15:06:18 <jmcarthur_work> @hoogle randoms
15:06:18 <lambdabot> System.Random randoms :: (Random a, RandomGen g) => g -> [a]
15:06:38 <siki> Twey: the problem with that is that random number generation always needs to be monadic (at least the way I understand it), since to generate the next number you need the previous state.
15:07:09 <jmcarthur_work> :t randoms =<< getStdGen
15:07:10 <lambdabot>     Couldn't match expected type `[a]'
15:07:11 <lambdabot>            against inferred type `IO StdGen'
15:07:11 <lambdabot>     In the second argument of `(=<<)', namely `getStdGen'
15:07:17 <jmcarthur_work> :t randoms =<< getStdGen :: [Int]
15:07:19 <lambdabot>     Couldn't match expected type `[a]'
15:07:19 <lambdabot>            against inferred type `IO StdGen'
15:07:19 <lambdabot>     In the second argument of `(=<<)', namely `getStdGen'
15:07:21 <jmcarthur_work> :t randoms =<< getStdGen :: IO [Int]
15:07:22 <jmcarthur_work> ugh
15:07:23 <lambdabot>     Couldn't match expected type `IO [Int]' against inferred type `[a]'
15:07:23 <lambdabot>     In the first argument of `(=<<)', namely `randoms'
15:07:23 <lambdabot>     In the expression: randoms =<< getStdGen :: IO [Int]
15:07:28 <Twey> siki: That doesn't require monads
15:07:37 <Botje> jmcarthur_work: return . randoms
15:07:39 <Twey> It just requires passing in the old state to the new function
15:07:53 <Twey> There are several functions (like randoms) that do this behind the scenes for you
15:07:53 <jmcarthur_work> ugh thank you. i was originally going to do more stuff on the left but then removed it
15:08:00 <jmcarthur_work> :t randoms <$> getStdGen :: IO [Int]
15:08:01 <lambdabot> IO [Int]
15:08:18 <FunctorSalad> won't that fail to update the seed?
15:08:23 <jmcarthur_work> then with the result from that you can do a scanl or something to use the numbers
15:08:32 <Twey> randoms might use State internally; we don't know and it doesn't matter, because State is pure
15:08:48 <Twey> (monads are not necessarily impure, and the ones that are pure generally provide exits)
15:08:48 <sampointon> hi #haskell
15:09:30 <FunctorSalad> Twey: sure is will see that the seed gets updated between the list elements... I mean if you do another randoms<$>getStdGen
15:09:40 <FunctorSalad> s/is/it/
15:09:59 * sampointon missed the question, but suspects that MonadRandom is the answer
15:10:15 <jmcarthur_work> sampointon, actually the question was about memoizing monadic functions
15:10:19 <Twey> FunctorSalad: I'm not sure what your question is
15:10:31 <Cale> newStdGen is better
15:10:32 <Twey> getStdGen will not get a new seed, it will get the global one
15:10:35 <Twey> Right
15:10:38 <sampointon> jmcarthur_work: ah, the miracle of context :)
15:10:44 <Twey> newStdGen is what you use if you want a new one
15:10:49 <Cale> getStdGen is a stupid thing anyway. I don't really understand why it exists.
15:11:11 <skorpan> monochrom: after discussion and further investigation, it seems that the tex input mode is indeed wrong: \circ should be RING OPERATOR.
15:11:16 <FunctorSalad> Twey: it will get the global one, but won't let you update it after you used it
15:11:23 <monochrom> Good.
15:11:31 <Cale> There should only be newStdGen, and it should create a StdGen using the system entropy pool instead of the current time.
15:12:56 * Twey nods.
15:13:01 <Cale> I wonder what the motivation to include getStdGen was... "let's introduce this unnecessary piece of global mutable state into the Haskell spec!"?
15:13:12 <Twey> FunctorSalad: But that's about getStdGen, not randoms
15:13:21 <Twey> randoms is pure: it takes a seed and gives you a list
15:13:42 <monochrom> @type getStdGen
15:13:43 <lambdabot> IO StdGen
15:13:53 <Twey> The (get|new)StdGen ones are the only functions doing any getting or setting
15:14:11 <monochrom> The motivation is to let beginners write random code in IO right away.
15:14:27 <Cale> monochrom: Still, it would have been easier just to have newStdGen, wouldn't it?
15:14:27 <jmcarthur_work> :t randomIO
15:14:29 <lambdabot> forall a. (Random a) => IO a
15:14:29 <Twey> But you can s/getStdGen/newStdGen/ just about anywhere
15:14:36 <jmcarthur_work> *that's* the one for beginners
15:14:37 <FunctorSalad> Twey: the other pure random functions return the next seed
15:14:42 <FunctorSalad> @type randomR
15:14:42 <Twey> It's a really odd situation that actually *requires* getStdGen
15:14:43 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> (a, g)
15:15:04 <sampointon> the whole System.Random interface is a bit grungy though
15:15:13 <monochrom> Oh, right, the motivation is to let beginners get the current random state and save it for later use.
15:15:25 <jmcarthur_work> sampointon, yeah, MonadRandom or some other state monad is far superior
15:15:32 <jmcarthur_work> sampointon, a supply comonad would also be nice
15:15:35 <monochrom> The whole motivation is to mimick imperative languages random libraries.
15:18:18 <nibro> what do I need to do to get the haddock documentation up on the package page on hackage?
15:18:24 <jmcarthur_work> sampointon, something based on http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Comonad-Supply.html , but not exactly. i don't think that interface is ideal
15:18:34 <Cale> nibro: wait
15:19:04 <Cale> nibro: When packages are first uploaded, the docs haven't been generated yet. If you just wait, supposing that they successfully build, the docs will appear.
15:19:37 <nibro> Cale: thanks - for how long should I wait?
15:19:56 <jmcarthur_work> particularly, i don't understand why there are *two* split functions for Supply
15:19:59 <sampointon> jmcarthur_work: hmm, I never quite got the hang of comonads, but this could be a good way to try to understand them; I found myself needing something like that a little while ago
15:20:00 <Cale> I'm not sure how often the script runs...
15:20:14 <FunctorSalad> nibro: if it doesn't succeed, it will have a "build error" entry
15:20:20 <Cale> But if you come back tomorrow and they're still not there, check the build error, yeah.
15:20:34 <nibro> Cale, FunctorSalad: alright, thanks, I'll just be patient then :)
15:20:35 <jmcarthur_work> sampointon, another nice comonad to try is a reader
15:21:29 <jmcarthur_work> http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Comonad-Reader.html
15:24:44 <roconnor> I hate concensus building.
15:25:03 <edwardk> roconnor: I disagree ;)
15:25:13 <roconnor> why can't I be dictator
15:25:20 <edwardk> roconnor: because you elected me, remember?
15:25:22 <roconnor> edwardk: :)
15:25:25 <Cale> roconnor: what would you dictate?
15:25:25 <roconnor> oh right
15:25:41 <roconnor> edwardk: you are in charge of selecting if swap should be strict or lazy by default.
15:25:46 <Baughn> It occurs to me that if I'm writing "unIO = unsafePerformIO", I may be overusing this..
15:25:55 <roconnor> edwardk: now go to it! :D
15:25:58 * Cale goes with lazy
15:25:59 <edwardk> <- malevolent dictator for life of haskell, per unanimous vote on #haskell-blah last week some time.
15:26:01 <edwardk> lazy
15:26:12 <edwardk> strictness will be inferred as needed, there is no space leak to fix
15:26:45 <jmcarthur_work> Baughn, ahh!@
15:27:11 <Cale> Baughn: wait until you get to defining  io = unsafePerformIO, then worry.
15:27:31 <Baughn> Cale: I.. already did
15:27:34 <roconnor> edwardk: bar2 xs = foldl' ((swap  .) . f) (0, 0) xs  doesn't seem to have strictness infered.
15:27:38 <Cale> haha
15:27:46 * jmcarthur_work secretly redefines io = error behind Baughn's back
15:27:52 <roconnor> edwardk: although I'm also in the lazy-swap camp
15:28:10 <jmcarthur_work> well, something that type checks at least
15:28:13 <Baughn> FTR, there are eleven occurences of unsafePerformIO in.. 27 lines of code.
15:28:21 <jmcarthur_work> Baughn, ... wrong
15:28:31 <Baughn> jmcarthur_work: It's not my fault!
15:28:31 <roconnor> where f (x, y) z = let !t = x+z in (t, y)
15:28:32 <Botje> write C already!
15:28:46 <Baughn> Trying to implement FRP in C might be a bad idea
15:28:49 <jmcarthur_work> yeah really. do it in c and write a ffi binding
15:28:53 <jmcarthur_work> :P
15:29:05 <Cale> 11 signs that what you're implementing would be better off implemented as a compiler primitive
15:29:07 <Baughn> I almost wish I could. ;_;
15:29:12 <edwardk> (swap .) . f ~ fmap swap . f -- i have no reason to believe that fmap swap . f should be strict.
15:29:16 <Baughn> Cale: Agreed
15:29:32 <roconnor> edwardk: where f (x, y) z = let !t = x+z in (t, y)
15:30:39 <edwardk> roconnor: but what is the cost of that lack of strictness, just one thunk that quickly evaluates itself on demand, no?
15:31:13 <roconnor> edwardk: ya, and on and on and on.
15:31:22 <roconnor> I never should have sumbitted a library proposal
15:31:41 <roconnor> I should leave the process to the politicians
15:32:08 <monochrom> We will re-elect roconnor to be the politician.
15:32:10 <roconnor> and emperors such as edwardk
15:32:18 <Cale> It's so annoying that whenever someone recommends something useful, someone else recommends this small change to it, and then nothing gets done.
15:32:40 <edwardk> anyways i'm wholeheartedly behind the existence of swap, and somewhat meh about the inclusion of swap'. though, if it was there i'd use it.
15:33:08 <Peaker> swap = snd &&& fst ?
15:33:13 <edwardk> peaker: yeah
15:33:24 <Peaker> @type uncurry (flip (,))
15:33:26 <lambdabot> forall b a. (a, b) -> (b, a)
15:34:03 <monochrom> Opinions are annoying.
15:34:09 <edwardk> cale: bikeshedding is easy and fun
15:34:35 <roconnor> if only haskell had strict tuples, then there would be no choice :)
15:34:42 <edwardk> ack, wait, emperor? but what happens when i need new clothes. erm, i'd better start working out again.
15:35:04 <roconnor> edwardk: no one will say anything.
15:35:13 <edwardk> ah thats true. its the internet.
15:35:19 <erikc> o, wow, there's a name for bikeshedding, i deal with that every day
15:35:24 <Cale> Oh, by the way, something I noticed were missing from System.IO are hWithEcho and hWithBuffering
15:36:03 <Cale> It's handy to be able to write pressAKey = hWithEcho stdin False . hWithBuffering stdin NoBuffering $ getChar
15:36:15 <monochrom> I can hook the emperor up with spammers who will advertise new clothes and new medicine.
15:36:24 <Cale> rather than 6 lines of mess
15:36:59 <edwardk> monochrom: I hear they can enlarge my penis as well.
15:37:17 <monochrom> Yeah. "Take the blue pill" they say.
15:37:54 <edwardk> erm, poor Neo, didn't he take the red one?
15:38:30 <monochrom> I am waiting for dons to say again "blue pill or red pill" regarding learning haskell. Perhaps he will never say that again. But when he says it, I can add "take the blue pill to enlarge... I saw that in an email".
15:39:26 <edwardk> "one pill makes you larger, ..." -- as this drifts to #Haskell-Blah
15:41:27 <edwardk> hrmm. is there a good tool for graphing module dependencies?
15:41:34 <Cale> Haha, yeah, it would have made for an interesting dilemma in the movie. "You can either take the red pill, and find out the true nature of the world in which you've been existing, or you can take the blue pill, which will give you increased sexual performance. It's up to you."
15:41:46 <monochrom> hehehe
15:42:55 <edwardk> clearly in that case you should choose the iconoclastic solution of potentially overdosing by taking both
15:46:10 <yitz> I'm sorry I got involved in the discussion about swap
15:46:37 <SamB> edwardk: you'd probably find out that you were living in a virtual world in which your sexual activity fueled your evil overlords
15:46:39 <yitz> Truth is, I don't have any problem with writing \(a,b)->(b,a)
15:47:28 <monochrom> The Prelude grows to encompass all functions implementable in 5 tokens.
15:47:31 <edwardk> roconnor: just submit a patch to libraries@ with both and a two week discussion period. and by the time someone realizes there was a bikeshed to paint it'll be over with.
15:48:00 <roconnor> edwardk: then what?
15:48:03 <SamB> monochrom: that's actually 13, I think
15:48:12 <edwardk> yitz: personally i like having the extra combinators around, they give you some standard names to tie RULES to, etc.
15:48:16 <monochrom> There will then be a new module Prelude.Twitter to encompass all functions implementable in 140 tokens.
15:48:22 <roconnor> yitz: oh I don't blame you or anyone else.
15:48:23 <sampointon> edwardk: no luck, bikesheds are copenhagen-interpretation quantum. As soon as you notice possible bikesheddage, so does the rest of the universe
15:48:59 <roconnor> yitz: I really don't know how to demonstrate which version of swap is superior.
15:49:01 <sampointon> edwardk: and thanks to the superposition principle, every possible opinion gets voiced at the same time
15:49:05 <yitz> edwardk: so write swap=... next to your rule
15:49:14 <SamB> yitz: that does not work!
15:49:28 <roconnor> yitz: which is why I hesitated 2 years before making this proposal.  Because this is a question that has no answer.
15:49:31 <yitz> SamB: why?
15:49:47 <SamB> GHC doesn't have time to prove undecidable things in looking for likely RULES
15:49:48 <yitz> oh
15:49:49 <edwardk> yitz: then i can only fuse swaps i wrote
15:50:09 <yitz> edwardk: yeah. ok. you want to fuse what someone else wrote?
15:50:33 <SamB> yitz: or maybe what he wrote in another package
15:51:16 <roconnor> yitz: actually 3 months ago I was in the strict-swap camp :)
15:51:19 <yitz> and on and on. now let's paint the fusion bikeshed.
15:51:25 <edwardk> well, lets think about it, realistically there is a Data.Tuple, if you're importing it, i'm going to bet you want to do something with tuples. what can you do? about the only thing left unmentioned in the epically large list of 4 functions imported from that module is swap ;)
15:51:42 <roconnor> and I would have proposed a strict swap, and there would be people taking the lazy side now.
15:51:54 <yitz> edwardk: there are a lot of things, but most of them are in Control.Arrow
15:52:38 <edwardk> yitz: sure. in fact i use a swap myself over in control.category.braided ;)
15:52:50 <edwardk> http://hackage.haskell.org/packages/archive/category-extras/latest/doc/html/Control-Category-Braided.html ;)
15:53:30 <edwardk> the argument for lazy swap for me is that swap . swap = id should hold and i can get that for lazy swap
15:53:56 <yitz> how about swap = if unsafePerformIO $ randomRIO (False, True) then swap' else swap''
15:54:15 <monochrom> That's too slow.
15:54:30 <yitz> edwardk: actually swap .! swap = id should hold
15:55:39 <yitz> edwardk: in category HaskDoneRight
15:55:40 <roconnor> > case undefined of { (_,_) -> "Hi edwardk" }
15:55:41 <lambdabot>   "* Exception: Prelude.undefined
15:55:53 <roconnor> > case (swap . swap) undefined of { (_,_) -> "Hi edwardk" }
15:55:54 <lambdabot>   "Hi edwardk"
15:56:15 <roconnor> edwardk: what you write is an argument for strict swap
15:56:20 <edwardk> @hoogle (.!)
15:56:20 <lambdabot> No results found
15:56:30 <roconnor> edwardk: actually it is an argument for strict a-lot-of-things
15:56:46 <edwardk> hrmm
15:56:50 <edwardk> touche
15:57:23 <roconnor> I have no problem with swap . swap not being equal to id because this sort of rule breaks all the time.
15:57:24 <yitz> edwardk: f .! g = f `seq` g `seq` (f . g)
15:57:50 <roconnor> @let  f .! g = f `seq` g `seq` (f . g)
15:57:51 <lambdabot>  Defined.
15:57:56 <Gracenotes> ...how do you get a function in head normal form? :/
15:57:57 <roconnor> > case (swap .! swap) undefined of { (_,_) -> "Hi edwardk" }
15:57:58 <lambdabot>   "Hi edwardk"
15:58:15 <roconnor> Gracenotes: redefine the haskell standard
15:58:18 <edwardk> yitz: i was mostly teasing given that the definition of a function that folks were debating about including was being given in terms of another function ;)
15:58:41 <edwardk> hrmm
15:58:58 <roconnor> Gracenotes: Cale and I were talking about that topic a few days ago
15:59:13 <monochrom> I think we can't get a function in head normal form.
15:59:27 <roconnor> monochrom: were you there with Cale and I?
15:59:32 <monochrom> No.
15:59:36 <conal> hnf or whnf?
15:59:52 <conal> (normalize under lambdas or not)
16:00:01 <edwardk> ok, what about fst . swap = snd and snd . swap = fst
16:00:03 <Gracenotes> monochrom: well. If head normal form means just a constructor (don't recall), partial application may be enough to get one constructor
16:00:03 <roconnor> monochrom: I suggested an elegant implement of seqHNF using callcc
16:00:09 <edwardk> hrmm
16:00:58 <monochrom> Eww.
16:01:37 <yitz> edwardk: it works with strict swap and .!
16:01:41 <edwardk> fst . swap = snd fails with strict swap and is a nice property to preserve
16:01:45 <Gracenotes> hm... blah 0 list = []; blah n list = replicate n ():list
16:01:57 <Gracenotes> calling it with the first parameter is enough to get the constructor name...
16:02:09 <Gracenotes> er. maybe ++
16:02:09 <roconnor> monochrom: basically seqHNF (f :: a -> b) x would evaluate internally (callCC (\k -> f (k ())) >> continue_on_with x)
16:02:14 <Peaker> conal: I was wondering the other day if the functionality you get from SECs (e.g first, second) can be joined up with getters (e.g fst, snd) so they are composed together, without limiting their type as Data.Accessors do..
16:02:16 <Cale> conal: Yeah, I figured out that if seq was to reduce things to HNF instead of WHNF, there wouldn't be semantic problems with it.
16:02:27 <Peaker> Cale: how come?
16:02:27 <roconnor> monochrom: so you just evaluate f with a continuation for the parameter
16:02:46 <Gracenotes> what is precisely the difference between HNF and WHNF? I think I knew once >_<
16:02:47 <edwardk> yitz: the bulk of the world uses . not .! by virtue of it being visually unobtrusive and smack dab in the prelude. i find RULES I can express involving (.) a lot more satisfying than ones I couldn't even add involving an operator I don't have ;)
16:02:57 <Cale> Gracenotes: whether it evaluates under a lambda
16:03:01 <conal> Gracenotes: all lambdas are in whnf
16:03:08 <conal> though not all functions.
16:03:08 <roconnor> Gracenotes: HNF will normalize stuff inside the body of a lambda expression
16:03:11 <Gracenotes> meaning...?
16:03:26 <yitz> edwardk: true. which is why Hask is not a category for the bulk of the world, so those properties don't really help much anyway.
16:03:30 <roconnor> Gracenotes: meaning case statements inside lambdas may be evaluated
16:03:32 <Cale> (\x -> (\y -> x + y) 5)  is in whnf
16:03:35 <Gracenotes> for example, a case where HNF != WHNF?
16:03:41 <Cale> but it's not in hnf
16:04:00 <Cale> To put it in hnf, you should evaluate inside the lambda to get
16:04:05 <conal> Gracenotes: a lambda is in hnf only if its body is in hnf.
16:04:06 <Cale> (\x -> x + 5)
16:04:17 <Gracenotes> so it's not to do with lambdas so much as application
16:04:37 <edwardk> yitz: personally i'm fond of having nice little laws to appeal to, and given a choice between two approaches, one of which has a nice easy to express law, i'm inclined to paint the bikeshed magenta. ;)
16:04:45 <jimmyjazz14> http://www.reddit.com/r/programming/comments/8tdyr/writing_apps_for_the_iphone_in_scheme  pretty interesting anything like this possible in the haskell world
16:04:52 <roconnor> Cale: I don't know if I'd go quite that far.  I'd return something more like (\x -> x + let y = 5 in y)
16:05:06 <roconnor> Cale: oh wait + is strict in both arguments.
16:05:07 <Gracenotes> if there are no outstanding applications
16:05:12 <roconnor> Cale: you are right
16:05:41 * roconnor wonders if Cale's example breaks my callCC implementation
16:05:44 <Gracenotes> ... at least for Ints >_>
16:05:52 <Cale> I don't think it does, does it?
16:06:06 <Peaker> Can Data.Accessors be less limiting in their type, and allow an accessor to the first element of a tuple that can change the first element's type (and thus the tuple's type)?
16:06:08 <roconnor> Cale: It sort of depends on how + is implemented I guess
16:06:13 <roconnor> it might be fine
16:06:26 <Cale> You just apply the inner lambda, which works out, and then (+) gets called and tries to evaluate the continuation, and then you're done.
16:06:54 <roconnor> Cale: but it might evaluate x first and jump about before normalizing the second parameter (which might be undefined)
16:07:13 <Cale> That is true.
16:07:21 <Cale> er...
16:07:30 <Cale> If it evaluates x, it's done.
16:07:52 <edwardk> peaker: No idea, I can't read the documentation of that module through all the Ts and Cs ;)
16:07:58 <roconnor> Cale: (\x -> (\y -> x + y) undefined) `seqHNF` foo should be undefined.
16:08:18 <Cale> edwardk: Another Thielemann masterpiece? :)
16:08:19 <Peaker> edwardk: Heh, what do you mean?
16:08:24 <edwardk> cale: alas
16:08:29 <edwardk> http://hackage.haskell.org/packages/archive/data-accessor/0.2.0.2/doc/html/Data-Accessor-Basic.html#t%3AT
16:08:37 <Cale> roconnor: hmm...
16:08:56 <Peaker> edwardk: well, the concept of SECs is really nice because you get composability and the full power of type-changing.  Lens/func-refs/accessors are nice because you get composability of a getter/setter pair, but it seems the setter is restricted to not changing the types at all
16:09:03 <edwardk> henning got his hands on the code for Data.Accessor it seems and its been polymorphed into a barely haddockable mess
16:09:10 <Gracenotes> ah, undefined. How would we participate in semantics questions without it!!
16:09:27 <Gracenotes> (rhetorical)
16:09:29 <Cale> edwardk: Someone with lots of free time should get all of Henning's packages and upload packagename-sane versions with sane type and class names.
16:09:53 <edwardk> peaker: yeah, i was mostly being facetious. the problem with the more general signature is that you may start needing explicit signatures on accessor use sites to disambiguate
16:10:14 <Cale> There's lots of good code there, it just uses horrifying conventions.
16:10:16 <Peaker> edwardk: I think you're a couple of steps ahead of me.. I'm not sure what the type would look like at all
16:10:27 <roconnor> SEC?
16:10:38 <Peaker> roconnor: conal's picked that name: semantic-editor-combinators
16:10:43 <Peaker> @where semenatic editor combinators
16:10:44 <lambdabot> I know nothing about semenatic.
16:10:44 <roconnor> oh
16:10:53 <Peaker> @where semantic editor combinators
16:10:53 <lambdabot> I know nothing about semantic.
16:10:56 <Peaker> @go semantic editor combinators
16:10:58 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
16:10:58 <lambdabot> Title: Conal Elliott Â» Semantic editor combinators
16:11:05 <Cale> I keep thinking Securities and Exchange Commission
16:11:16 <yitz> I think they're kind of a twisted CSE
16:11:22 <conal> @where SEC
16:11:23 <lambdabot> I know nothing about sec.
16:11:27 <conal> @where+ SEC http://conal.net/blog/posts/semantic-editor-combinators/
16:11:28 <lambdabot> Okay.
16:11:30 <Cale> @go SEC
16:11:32 <lambdabot> http://www.sec.gov/
16:11:32 <lambdabot> Title: U.S. Securities and Exchange Commission (Home Page)
16:11:32 <Peaker> roconnor: stuff like first, second, result=(.), arg=flip (.), ... that you can compose together with (.) to manipulate a value "deep inside" another value
16:11:33 <edwardk> i like semantic editor combinators, basically all they tell me to do is what i've been doing all along. just throw another fmap or flip fmap on there and call it a day ;)
16:11:59 <roconnor> Peaker: yep I know what you are talking about now
16:12:14 <Gracenotes> who else is gonna regular them lambdas
16:12:17 <Peaker> I'd even go and say SECs are just a Haskell "design pattern", but then I'd have to duck :)
16:12:25 <Gracenotes> regulate even
16:12:25 <yitz> is ~> an SEC?
16:12:45 <lpjhjdh> is there a reason drawnFrom is only defined in lazysmallcheck and not smallcheck?
16:12:45 <roconnor> Peaker, it's okay.  Haskell has "design patters" and they are still failures of the language. :)
16:12:46 <Peaker> yitz: I guess it is
16:12:47 <edwardk> result = fmap; element = fmap; argument = flip fmap; fmap fmap fmap and you're all set.
16:12:48 <conal> yitz: it's a composition of two SECs
16:12:57 <yitz> conal: ok
16:12:58 <Peaker> roconnor: Are SECs failures of the language?
16:12:59 <roconnor> Peaker, Haskell is missing generic programming
16:13:08 <Gracenotes> as I say, design patterns begins where a language's built-in abstractions end
16:13:27 <Gracenotes> all languages have them
16:13:27 <roconnor> Peaker, if SECs really need generic programming, then yes.
16:13:31 <Gracenotes> but the less the better :P
16:13:46 <Peaker> roconnor: I am not sure they do
16:13:57 <roconnor> oh
16:14:30 <Peaker> roconnor: I am not completely sure what "generic programming" is lacking in Haskell though.. I dislike type-unsafe syntactic-level code generators for those purposes
16:14:58 <edwardk> i do appreciate conal giving a name to the whole idiom though
16:15:31 <lpjhjdh> aren't there type-safe macros around that make use of dependant types?
16:15:40 <Peaker> edwardk: so, anyway, how do you give a type to a (getter,SEC) tuple?
16:15:49 <conal> what i haven't written much about is how much more generally applicable SECs are than just applying to functions.
16:15:54 <roconnor> Peaker: there are several ways of implementing generic programming.  The basic problem is that we cannot reflect upon the structure of our Algebraic Data Types to generate functionality uniformly.  I know how I might do it in Epigram or Agda.
16:16:17 <conal> as in the "tangible functional programming" paper is about
16:16:21 <conal> (s/is about//)
16:16:33 <roconnor> Peaker: I also dislike type-unsafe stuff, which is why I dismiss all the generic programing libs in Haskell :)
16:16:45 <Peaker> roconnor: I often get the feeling that ADT's are over-used, and that open type sums are more useful than closed ones pretty often, and when you do need a closed sum, you can often reuse an existing ADT and get all of its functions/instances for free
16:16:49 <yitz> roconnor: SYSYB
16:16:59 <edwardk> peaker: the problem is basically that you want your accessor to change between two types in a directed fashion, so you wind up with various kinded versions of the combinators or MPTCs sans fundeps and intractable instance heads
16:17:10 <roconnor> yitz: Does that exist?  If so I haven't read it.
16:17:14 <hackagebot> bitarray 0.0.1 - Mutable and immutable bit arrays (BalazsKomuves)
16:17:18 <conal> yitz: :)
16:17:24 <Peaker> roconnor: e.g: I dislike people defining an ADT to describe some of their data structure which boils down to some tree. I'd rather have a single ADT describing a tree with parametric branch/leaf data types, and everyone using those
16:17:24 <roconnor> Peaker: perhaps
16:17:30 <edwardk> @quote boilerplate
16:17:31 <lambdabot> edwardk says: ah the "scrap your boilerplate and replace it with mine" approach
16:18:11 <Peaker> edwardk: that's a little bit difficult for me to follow, I think I lack some terminology. Can you illustrate part of that with an example?
16:18:54 <copumpkin> edwardk: I hunger for more *morphism writings on comonad.com :P
16:19:58 <edwardk> alright lets take a model of a non-changeable accessor, something like type Accessor r a = (a -> r -> r, r -> a) -- which accesses a field of type a in an term of type r.
16:20:36 <yitz> edwardk: does your fusion rule argument also apply to lazy vs. strict sum?
16:20:55 <yitz> edwardk: if so, then that's a proof that it's wrong
16:21:42 <Peaker> edwardk: following so far :)
16:22:19 <edwardk> you could change that a bit to get something like type FancyAccessor r a = (a -> r a -> r a, r a -> a) -- or FancyAccessor r b = forall a. (a -> r b -> r a, r b -> b)
16:22:37 <edwardk> but the problem is you probably want to have more than one accessor for 'r'
16:22:41 <edwardk> and thats where things get ugly
16:23:01 <Peaker> the first FancyAccessor still seems to limit the type of set?
16:23:45 <edwardk> you'd need a type parameter for each accessor, which distinct methods or you'd need a ternary typeclass with MPTCs that indicated that setting a certain field to type a on a value or type b yields a value of type c.
16:23:51 <edwardk> and the whole mess is intractable
16:24:22 <edwardk> yitz: hrmm
16:24:23 <Peaker> type-system-- ? :(
16:24:58 <Peaker> edwardk: has anyone tried?
16:25:16 <edwardk> i think the problem is just not really nicely definable
16:25:26 <Saizan> why a value of another types as result of setting?
16:25:37 <edwardk> accessors as they stand have an easily understood type and are pretty useful
16:25:41 <Peaker> > first show (1, 2)
16:25:43 <lambdabot>   ("1",2)
16:25:49 <edwardk> saizan: he wanted setters to be able to change the type ala fmap
16:26:07 <dancor> what is the difference between Control. and Data.
16:26:15 <dancor> Control tends to define classes and Data data?
16:26:32 <Peaker> I think ideally the stdlib would not have (first,fst) it should just have an accessor, and then there'd be a much smaller namespace of stuff to remember, and stuff might also compose to be more general by default
16:26:49 <Gracenotes> hm. is it possible for a primitive to be _|_?
16:26:57 <yitz> dancor: the distinction is not very clear
16:27:01 <Peaker> dancor: Data is usually data-structures,  Control is random other stuff? :-)
16:27:24 <Gracenotes> having an (I# i), but where attempting to evaluate i yields some blackhole or something
16:27:53 <Saizan> no, an unboxed value has no bottom
16:28:18 <Saizan> that's kind of the point of it
16:28:41 <Gracenotes> hm. just bits then.
16:28:44 <dancor> is it reasonable to assume that any programming language consists of "statements" with whitespace intercalated
16:28:49 <copumpkin> edwardk: could you write a "quick" call to g_histo that typechecks by any chance? :D
16:28:51 <dons> it can loop though
16:28:53 <edwardk> yitz: inr = swap . inl -- does seem right the right law to me
16:29:02 <dons> unboxed things can still diverge
16:29:05 <sampointon> dancor: what kind of 'programming language' do we mean here?
16:29:15 <Gracenotes> dancor: er. maybe most imperative ones
16:29:19 <dancor> sampointon: from php to haskell
16:29:28 <sampointon> dancor: so no esoteric ones then? :)
16:29:28 <Gracenotes> Unlambda is a programming language that has no statements and no whitespace
16:29:29 <yitz> edwardk: inl? inr?
16:29:36 <edwardk> inl = Left; inr = Right
16:30:00 <sampointon> dancor: okay, so I guess Python doesn't quite fulfil that definition, because whitespace is an integral part of some statements
16:30:04 <dancor> sampointon: my question another way: what are some of the least-esoteric langs that don't fit
16:30:18 <dancor> sampointon: maybe, tho haskell layout would be the sme way
16:30:30 <yitz> dancor: there is a programming language called 99
16:30:38 <sampointon> dancor: less so, because it's option in Haskell. Python gives you no choice about it
16:30:45 <dancor> sampointon: i think layout still works, there are just constraints on the whitespace
16:30:47 <edwardk> yitz: (swap . Left) x = swap (Left x) = Right x -- I don't see the rule breaking down. symmetry is preserved even though that pattern match is strict
16:30:57 <Botje> perl is whitespace sensitive too ($foo =~ /bar/ vs $foo = ~ /bar/)
16:31:00 <Gracenotes> dancor: imperative languages have statements. some other types don't so much
16:31:01 <yitz> dancor: where the empty program prints out the words to the song "99 Bottles of Beer on the Wall".
16:31:13 <dancor> nice
16:31:37 <dancor> i think if the language AST is [Statement] i can still say that has "" whitespace intercalate
16:31:42 <dancor> d
16:32:01 <Gracenotes> or [Expression], or [Declaration]. depends.
16:32:02 <dancor> so i'm ok with whitespaceless and layout i think
16:32:43 <dancor> right, i would have to decide those count as types of top-level statements
16:33:25 <Gracenotes> dancor: here's BNF for 11 languages or so. http://www.cui.unige.ch/db-research/Enseignement/analyseinfo/BNFweb.html
16:33:36 <Gracenotes> including declarative database ones, probably not so useful
16:34:02 <yitz> edwardk: I've lost you, I thought we were talking about products, not sums
16:34:34 <edwardk> yitz: you asked if my argument extended to sums and if so that it was flawed.
16:34:39 <Gracenotes> context-free grammar, syntax good place to start modeling, er, syntax.
16:34:51 <edwardk> er and stated that if so
16:34:54 <yitz>  edwardk ah. :) no I meant Data.List.sum
16:35:02 <edwardk> hah
16:35:14 <edwardk> ok, i was trying to figure out what you meant.
16:35:36 <yitz> the other bikeshed currently active
16:36:53 <edwardk> i hadn't seen that traffic. there, i acknowledge the need to fight against space leaks and what have you since its clearly recursive internally, so there are clear pragmatics at work on either side of the debate
16:47:20 * copumpkin stares at edwardk
16:47:49 * edwardk is stared at and skims backwards
16:48:14 <edwardk> copumpkin: ah
16:49:34 <edwardk> copumpkin: the answer there is to simplify the signature a bit to make it tractable. ;) and just use a functor f and a Cofree comonad of another functor that we know we have a nice distributive law for over f rather than pay attention to all the ComonadCofree typeclass noise
16:49:35 * copumpkin unstares
16:49:52 <copumpkin> edwardk: I tried that but got stuck with the FixF stuff
16:50:11 <edwardk> pulling it up
16:50:11 <copumpkin> I was just working with the non-g_ one
16:51:10 <edwardk> ok, histo is pretty straightforward as well
16:51:18 <copumpkin> not for little ol' me
16:51:18 <edwardk> FixF is just Mu
16:51:53 <edwardk> so histo looks like histo :: Functor f => (f (Cofree f a) -> a) -> Mu f -> a
16:52:22 <edwardk> so lets think about what it means a bit before we apply it
16:52:48 <copumpkin> alright :)
16:53:05 <copumpkin> it took me a while to even get something for the GAlgebra
16:53:10 <edwardk> do you have an intuition for the cofree comonad?
16:53:18 <copumpkin> only vaguely
16:53:58 <copumpkin> I explored the Cofree definition and mostly get the (,) vs. Either thing
16:53:58 <edwardk> basically just take Mu and instead of wrapping In (f (In (f ...))) -- add an extra argument at each 'In'
16:54:36 <copumpkin> ah yeah
16:54:54 <edwardk> so if we replace the definition of Cofree with the prettier: data f :> a = (f :> a) :> a -- we can make (f :>) into a comonad
16:55:26 <edwardk> the cofree comonad definition in category extras is slightly obfuscated to allow you to use bicata and stuff over it
16:55:44 <Phyx-> Hello, I have a quick question, If there a function in SYB that applies a transformation only on the first level? (so apply a transformation but not recursively). so given a type Expr, it would only transform any occurances of Expr inside Expr but not recursively and not the toplevel expr
16:55:54 <edwardk> and to allow me to treat cofree comonads as coideal comonads
16:56:01 <copumpkin> ack
16:56:10 <copumpkin> by the way, what does Biff stand for?
16:56:17 <edwardk> bifunctor functor functor ;)
16:56:32 <copumpkin> lol
16:57:19 <edwardk> in the next rev those are being relegated to some obscure side package like 'functor-combinators'
16:57:26 <copumpkin> ah
16:57:44 <copumpkin> so what's a coideal comonad? (I have no idea what ideal even means)
16:57:46 <edwardk> since they scare the hell out of folks and are only useful if you want to make a typeclass style derivative class that works pretty well
16:58:07 <edwardk> ok, well. lets look at the type of a free monad for a second, then we'll talk about ideal monads and dualize the notion
16:58:10 <Saizan> Phyx-: that sounds like gmapT
16:58:13 <copumpkin> yeah, I was getting confused by the partially applied Biff
16:58:58 <edwardk> a free monad looks like data Free f a = Return a | Free (f (Free f a)) -- right?
16:59:10 <Phyx-> Saizan: ah, ofcourse. I was thinking of gmapQ myself, but the type wasn't what i needed, gmapT was the one i needed, cool thanks
16:59:36 <Phyx-> @hoogle Binary
16:59:36 <edwardk> or equivalently newtype Free f a = Free (Either a (f (Free f a)))
16:59:37 <lambdabot> package binary
16:59:37 <lambdabot> package binary-search
16:59:37 <lambdabot> package binary-strict
16:59:46 <copumpkin> edwardk: alright yeah
17:00:30 <edwardk> an 'ideal' monad is any monad which has the form F a = a + F' a -- where the 'a +' represents 'what you get when you call 'return'
17:00:41 <copumpkin> hrm
17:00:57 <copumpkin> doesn't seem ideal for my comprehension ;) what's it ideal for? :P
17:00:58 <edwardk> ideal monads have a 'separated' return value, and some potentially really ugly other stuff.
17:01:01 <edwardk> Maybe is ideal.
17:01:20 <edwardk> Just a | Nothing -- so F' in this case just is a void functor
17:01:50 <edwardk> 'Either a' is 'ideal' -- F' is just the constant functor for some value of type a.
17:01:59 <copumpkin> the + being | in type notation?
17:02:02 <edwardk> yeah
17:02:07 <copumpkin> ah, so the sum type stuf
17:02:14 <edwardk> + in that standing for 'Either' or 'sum'
17:02:31 <copumpkin> ok
17:02:35 <Alpounet> So, considering your point, List isn't ?
17:03:26 <edwardk> good question, i never bothered to work that out. but 'return a' = Cons a Nil -- doesn't look like the list functor meets the requirements as implemented.
17:03:39 <edwardk> you might be able to make a slightly different list-like functor that was ideal though
17:04:12 <edwardk> the reason ideal monads are interesting is that they have a well defined coproduct.
17:04:26 <edwardk> so if you have any two ideal monads you can 'layer them' in a well defined way
17:04:34 <Alpounet> edwardk, are there that much interesting consequences on working on an "ideal monad" ?
17:04:52 <Alpounet> s/on/in/
17:06:07 <edwardk> Alpounet: a monad coproduct isn't defined in general but the ideal monad coproduct is. which gives you a way to mix uniformly a class of monads
17:06:55 <Alpounet> ok... any good link dealing with such issues (I won't bother you about this all night long) ?
17:06:59 <edwardk> the other thing is its a bit easier to define the monad instance for them. you know how return works
17:07:43 <edwardk> the only thing you need to know is how to comvert something like f' (Either a (f' a)) -> f' a -- for your particular 'binding' half
17:07:49 <edwardk> http://comonad.com/haskell/category-extras/src/Control/Functor/Internal/Ideal.hs
17:08:08 <edwardk> Alpounet: i think uustalu and ghani did a talk on the topic once that might have some slides still online as well
17:08:32 <edwardk> http://www.numdam.org/numdam-bin/fitem?id=ITA_2004__38_4_321_0 seems to be a paper on the topic
17:08:53 <copumpkin> edwardk: you need to write a book on this stuff, starting from the very beginning ;)
17:08:56 <jmcarthur> i wish it didn't take so much study to learn this stuff :\
17:09:17 <edwardk> ah here is the paper http://www.cs.ioc.ee/~tarmo/papers/fics03-tia.ps.gz
17:09:36 <Alpounet> edwardk, thank you ! It should keep me busy for now :-)
17:09:53 <edwardk> they came up after ghani wrote an article on coproducts of monads and lamented that there wasn't any such general encoding as i recall
17:10:01 <Alpounet> and copumpkin is right, please write a book ! :)
17:10:05 <edwardk> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.8.3581
17:10:26 <jmcarthur> i hypothesize that composing types to create new types is superior to creating new ADTs manually, but i know that the best way to do that is with things like TypeCompose and category-extras... things that i need to learn more about
17:10:39 <copumpkin> jmcarthur: I also like the idea more
17:10:42 <edwardk> i would start with that ghani and luth paper, and then read the one by ghani and uustalu.
17:11:18 <jmcarthur> no, you must write a book yourself or we will not learn :P
17:11:33 <edwardk> anyways i added ideal monads to category-extras and 'invented' their categorical dual by the ever so complicated process of just dualizing everything
17:11:47 <copumpkin> edwardk: book book book
17:11:48 <copumpkin> ;)
17:12:05 <edwardk> since ideal monads have a 'general' coproduct construction, coideal comonads have a 'general' product construction
17:12:12 <copumpkin> it must have pretty pictures that don't involve arrows or greek letters
17:12:37 <jmcarthur> yes, they must involve yarn and kittens instead
17:13:10 <copumpkin> and cofree list monsters
17:13:20 <copumpkin> -list
17:13:27 <Saizan> so coideal comonads are those of the form F a = a * F' a ?
17:13:35 <edwardk> yeah
17:14:13 <edwardk> where all you need to make a comonad out of it is to know how to 'coidealize :: w a -> w (a, w a)'
17:14:39 <edwardk> whereas for an ideal monad you need 'idealize :: m (Either a (m a)) -> m a'
17:15:04 <christophergreen> Botje: that seems to be a very liberal interpretation of the word 'whitespace'
17:15:11 <edwardk> Free f can be made into an ideal monad, and Cofree f can be made into a coideal comonad.
17:15:21 <copumpkin> hmm
17:15:33 <edwardk> a nice consequence of this is that the products of cofree comonads are well defined.
17:15:34 <cwg> ...
17:15:44 <cwg> and that was a long time ago... sorry
17:15:48 <edwardk> and the coproducts of free monads
17:16:59 <Alpounet> 'kay
17:17:19 <Alpounet> I do miss some background to understand the consequences, but I'll look seriously at the paper and your source.
17:17:22 <edwardk> and with that i'm being dragged away mid explanation by my wife to watch 'So you think you can dance' ;)
17:17:50 <copumpkin> edwardk: but histo!!! :(
17:17:51 <copumpkin> :P
17:17:54 <copumpkin> have fun :)
17:17:59 <Alpounet> Don't hesitate to write a *book* about all these category-related stuffs in Haskell
17:18:12 <copumpkin> yeah, I think we need a book on category-extras
17:18:21 <copumpkin> cause its documentation is a little lacking
17:18:23 <edwardk> if someone wants to flesh out the definition of MonadIdeal (m :+ n) and ComonadCoideal (m :* n) in http://comonad.com/haskell/category-extras/src/Control/Functor/Internal/Ideal.hs -- it would probably cement the concepts ;)
17:18:31 <edwardk> the types are all there
17:18:38 <Alpounet> Real World Category-extras
17:18:41 <edwardk> you just need to figure out the layering
17:19:10 <edwardk> I figure its more like 'Category theory for the Unemployed Computer Scientist'
17:19:27 <copumpkin> lol
17:19:32 <Alpounet> heh
17:19:37 <edwardk> afk
17:19:38 <copumpkin> I'm "employed"!
17:19:49 <edwardk> no you're 'enrolled' ;)
17:19:57 <copumpkin> but they pay me!! :(
17:20:04 <edwardk> peanuts
17:20:07 <copumpkin> lol
17:20:10 <copumpkin> can't argue there
17:22:58 <dancor> what do they call it when you start at the circus
17:23:13 <dancor> consigned
17:26:20 <SamB> dancor: I don't understand ... what does nsigned mean ?
17:27:35 <Peaker> Languages like C++/etc use lots of tricks in their compiler implementation of exception throwing and catching to have cheap exceptions.  Can something like EitherT IO compile down to code that uses similar performance tricks?
17:29:00 <SamB> Peaker: I'd swear you were trying to give me a headache
17:29:16 <Peaker> SamB: heh, why?
17:29:58 <SamB> trying to think of how the heck a compiler could turn something so nice and simple into something so awfully hairy and complicated
17:31:11 <SamB> note that I've been hacking GDB a bit lately, and trying to follow the mailing list
17:34:25 <Peaker> SamB: Well, any idea? :-)
17:34:54 <SamB> Peaker: well, it depends on how many aspirins you are willing to throw at it, probably
17:34:57 <Peaker> SamB: How do modern C++ compilers implement try/catch/throw?  Use a register to remember where to jump to for catching stuff, and compare the exception type?
17:34:59 <copumpkin> is Either a bifunctor?
17:35:07 <SamB> or rather, how many SPJ is willing to need
17:35:17 <Peaker> copumpkin: sure, why not?
17:35:34 <copumpkin> because I'm a newbie and am just probing into this unknown territory :)
17:35:37 <monochrom> When you catch exceptions, there is some "stack unwinding" to do.
17:36:06 <copumpkin> great though
17:37:07 <copumpkin> lol
17:37:07 <copumpkin> class (PFunctor p r t, QFunctor p s t) => Bifunctor p r s t | p r -> s t, p s -> r t, p t -> r s where	
17:37:16 <copumpkin> instance Bifunctor Either Hask Hask Hask
17:37:47 <Tsion> Is there a better way to get the last 10 elements of a list than "reverse . take 10 . reverse"?
17:38:04 <Peaker> copumpkin: what other categories except Hask exist?
17:38:14 <Botje> drop (length list - 10) list?
17:38:26 <monochrom> Perhaps drop (length xs - 10) xs
17:38:31 <Tsion> That's better?
17:38:36 <copumpkin> Peaker: he doesn't provide any built-in instances as far as I can tell, but would allow it
17:38:56 <monochrom> reading the list twice is still faster than reversing twice.
17:38:59 <jimmyjazz14> I installed a bunch of dependencies with Cabal but when I run runhaskell Setup.hs configure it does not see them
17:39:03 <dancor> i think it's cool to make  reversify f = reverse . f . reverse
17:39:23 <Gracenotes> linked lists are not made for this sort of treatment >-,
17:39:57 <Gracenotes> hm. Maybe one could make an indexed (finite) list, where the number attached to a cell is the distance from []
17:40:16 <Gracenotes> but this is probably a one-time operation or somethin', so, nvm.
17:40:22 <copumpkin> I like the new list that appeared on hackage today
17:41:08 <dancor> i know but a lot of times i don't care about perf
17:41:12 <dancor> i always care about coolness
17:41:41 <Peaker> copumpkin: I think I'm less of an expert on the subject than you are, but I see Bifunctor as simply a functor of two type variables instead of one, and having fmap on either, and I think Either should support that. I suppose any extra restrictions they have in there should probably not make it impossible for Either to be a Bifunctor, like Maybe can be a Functor despite not always having a value
17:42:20 <copumpkin> Peaker: I beg to differ, I'm a negative expert :) but yeah, bifunctor makes sense to me now
17:46:44 <Alpounet> > let last_ten (x:xs) | length xs <= 10 = xs |Â length xs >= 10 = last_ten xs | otherwise = [] in last_ten [1..11]
17:46:45 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
17:47:41 <Alpounet> well... the otherwise should be removed and we should add an empty list pattern
17:48:08 <Tsion> Alpounet: Won't that be even worse, going over the remaining list for the length each element?
17:49:48 <Alpounet> Tsion, yep, there must be some trickier way
17:49:50 <roconnor> @src uncurry
17:49:50 <lambdabot> uncurry f p = f (fst p) (snd p)
17:50:06 <roconnor> maybe swap should be lazy because uncurry is.
17:50:16 <copumpkin> that isn't the real source for it is it?
17:50:25 <roconnor> I don't know
17:50:31 <copumpkin> I always assumed it was using ~
17:50:46 <Alpounet> @src (~)
17:50:47 <lambdabot> Source not found. My mind is going. I can feel it.
17:50:54 <roconnor> uncurry          :: (a -> b -> c) -> ((a, b) -> c)
17:50:56 <roconnor> uncurry f p      =  f (fst p) (snd p)
17:50:58 <roconnor> from the prelude
17:51:20 <copumpkin> weird
17:51:35 <copumpkin> Alpounet: I meant uncurry f ~(a, b) = f a b
17:51:46 <Alpounet> oh :)
17:54:50 <jimmyjazz14> I am trying to build lambdabot and keep getting this error: Could not find module `Control.OldException'
17:55:14 <jimmyjazz14> ...it is a member of the hidden package `base'
17:56:06 <Saizan> someone forgot a base >= 4 somewhere in the cabal file
17:57:49 <Peaker> Can mmap be used as a backend-store for Haskell values?
17:57:57 <Peaker> or just bytestrings?
17:58:23 <jimmyjazz14> Saizan: thanks I added it myself and that worked
18:00:48 <copumpkin> Peaker: how do you mean?
18:01:00 <copumpkin> to replace its megablock allocation or whatever it's called?
18:01:07 <copumpkin> ultrahyperblock
18:02:30 <Peaker> copumpkin: Well, I guess if my value accessors are in IO, I can "transparently" read/update the file, too
18:02:56 <Peaker> copumpkin: basically, I want a nice infrastructure that allows me to almost ignore the fact my refs/values are being backed into a persistent file rather than volatile memory
18:03:33 <Peaker> copumpkin: I can write an instance of a MonadRef class for FileIORefs that depends on a Binary instance and serializes/deserializes from a file offset or such
18:07:09 <jimmyjazz14> I'm messing around with making a lambdabot plugin and I keep getting: Not in scope: `plugin' when it tries to build my plugin, I listed it in Modules.hs, was I suppose to list it somewhere else as well?
18:19:12 <Lemonator> how's Haskell' coming along?
18:19:53 <bos> does anyone know how to attach does to #{enum} elements processed by hsc2hs?
18:19:59 <bos> er, docs, not does
18:22:26 <juhp> where does missingpy live these days?
18:24:08 <bos> you'd have to ask CosmicRay on #haskell
18:24:31 <shapr> Er, wait, isn't this #haskell?
18:25:57 <bos> durr, uh, my brain was in the wrong channel
18:26:30 * shapr pokes bos with a LAMBDA!
18:26:38 * shapr speaks to bos with a West Brit accent...
18:28:17 <shapr> hiya danopia
18:28:30 <danopia> hi shapr
18:28:35 <shapr> How's code?
18:28:49 <juhp> I used good-ol'fashioned email :)
18:28:57 <shapr> whoa, old skool
18:29:08 <juhp> yeah! ;)
18:42:14 <jimmyjazz14> can someone explain what's up with the $(plugin "Hello") syntax in lambdabot plugins?
18:42:19 <copumpkin> mmm conal is starting the haskell iphone movement, nice
18:45:30 <Axman6> i'm not sure what you'd do with haskell on an iPhone
18:46:21 <copumpkin> program with it?
18:46:25 <bremner> Axman6: its a programming language, and the iphone is a computer.  I don't understand the question
18:46:25 <copumpkin> just like you'd do with objc? :P
18:46:50 <jimmyjazz14> it would be kinda cool to be able to make iPhone apps with Haskell
18:47:11 <conal> copumpkin: :)  and thanks for adding your entry.
18:47:18 <Axman6> well, there are no decent Xocoa bindings for haskell (if that results from this effort, i'll be quite happy), and it has no terminal, so i can't see any way in which you could use it
18:47:18 <jimmyjazz14> although I don't have an iPhone so it wouldn't be that cool
18:47:27 <Axman6> Cocoa*
18:47:36 <copumpkin> conal: I'd love to help, not much time for it, but I do know the platform pretty well :)
18:47:58 <conal> copumpkin: awesome.  i know squat about it!
18:48:26 <conal> copumpkin: what's "GHC cross-compiling to ARM Mach-O"?  do you have a tweaked GHC?
18:48:31 <copumpkin> I've never actually made a real app for it though
18:48:44 <copumpkin> conal: it's what I want, or did I misinterpret the column?
18:49:05 <conal> copumpkin: oh!  my goof.
18:49:15 <bremner> Axman6: my iPhone has a terminal
18:49:20 <copumpkin> mine does too :)
18:49:28 <bremner> Axman6: no idea how it got there
18:49:31 <conal> copumpkin: what's Mach-O?
18:49:34 <Axman6> but that's because you two broke teh rules!
18:49:43 <Axman6> bremner: jail borken?
18:49:44 <copumpkin> conal: the object format that mac os uses (as opposed to ELF)
18:49:51 <copumpkin> bremner: I put it there ;)
18:49:59 <conal> copumpkin: oh -- got it.
18:50:27 <copumpkin> Axman6: damn right
18:50:43 * Axman6 does not think jail breaking is cool
18:51:04 <copumpkin> Axman6: I'd be happy to debate it, given my rather well known (maybe outside this circle) position on it :P
18:51:14 <SamB> Axman6: why not ?
18:51:17 <bremner> Axman6: oh, why not? although this gets a bit offtopic
18:51:27 <SamB> isn't it just a computer?
18:51:51 <copumpkin> SamB: SteveJ has not put his royal seal of approval on anything jailbroken though :(
18:52:07 <bremner> copumpkin: no but Woz has :-)
18:52:14 <Axman6> bremner: so?
18:52:17 <copumpkin> bremner: I know, maybe better than you :P
18:52:22 <SamB> copumpkin: of course not -- it wouldn't be jailed if he did, would it?
18:52:47 <SamB> or at least they would call the sanctioned procedure "pardoning" or such ;-)
18:52:51 <copumpkin> lol yeah
18:53:23 <bremner> Axman6: err, not sure what "so" is in response too. Offtopic?
18:53:38 <copumpkin> #haskell-iphone
18:53:54 <Axman6> the woz being ok with jail breaking. he has absolutely nothing to do with the iPhone
18:53:55 <copumpkin> :P
18:54:59 <gwern> well, the woz would. he hasn't gone all corporate like jobs
18:55:18 <copumpkin> he actually promised us iphones, but flaked on us
18:55:34 <Axman6> jobs has always been 'all corporate', that's why Apple are doing so well
18:55:54 <gwern> except when it wasn't doing well, I suppose
18:56:12 <copumpkin> maybe this belongs in -blah :)
18:56:15 <bremner> Axman6: ah, ok, should I have added two smileys?
18:56:25 <gwern> @quote
18:56:26 <lambdabot> emertens says: screw ruby on rails, I'm using snakes on a plane
18:56:33 <Axman6> heh
18:56:49 * SamB loves that one
18:57:47 <gwern> @quote
18:57:48 <lambdabot> dons says: <dons> and you can just zoom in until you see the locations at full res. huh. so this is how I track my enemies
18:58:55 <jimmyjazz14> has anyone succesfully written a lambdabot plugin?
19:01:04 <gwern> @forget dons <dons> and you can just zoom in until you see the locations at full res. huh. so this is how I track my enemies
19:01:05 <lambdabot> Done.
19:01:20 <gwern> @remember dons and you can just zoom in until you see the locations at full res. huh. so this is how I track my enemies
19:01:21 <lambdabot> It is forever etched in my memory.
19:01:25 <gwern> @flush
19:01:49 <gwern> jimmyjazz14: there are legends that in the dawn of the world, the great Haskell demiurges wrote lb plugins like @quote or @seen
19:02:13 <gwern> jimmyjazz14: but can a plugin be encompassed by the descended mere mortals of this degenerate age? surely not
19:02:56 <lpsmith> So,  does anyone know of a good reference to direct-style (e.g. using implicit continuations via callCC or shift and reset)  versus writing explicitly in the continuation passing style?
19:03:05 <gwern> @quote
19:03:06 <lambdabot> sethk says: it's certainly true that you can clobber the stack in C without even getting out of bed in the morning
19:03:37 * edwardk is back.
19:03:39 <lpsmith> Intro type material;  I'm familiar with the concepts,  but somehow I skipped over the introductory papers and whatnot.
19:03:49 <gwern> edwardk: you were gone?
19:03:51 * BMeph enjoyed the "Ninjas on a Plane" paper... ;)
19:04:00 <gwern> ?
19:05:02 <edwardk> gwern: was explaining histo by a somewhat circuitous path through cofree comonads and got interrupted
19:05:16 <copumpkin> yay edwardk
19:06:42 <edwardk> copumpkin: re: Either as a bifunctor, yeah
19:06:47 <aavogt> @pl do { x <- open; result <- f x; close x; return result }
19:06:47 <lambdabot> (line 1, column 4):
19:06:47 <lambdabot> unexpected "{"
19:06:47 <lambdabot> expecting variable, "(", operator or end of input
19:07:33 <edwardk> as as for non-Hask categories thats what Control.Category.* are for
19:07:45 <gwern> aavogt: wouldn't the pointless version of that be just the same?
19:08:08 <gwern> also, pl expects a foo = bar form
19:08:39 <aavogt> gwern: I was expecting some magic involving join and (*>, <*), or something...
19:08:54 <gwern> aavogt: you probably should look at undo
19:09:12 <aavogt> undo?
19:09:27 <aavogt> @undo do { x <- open; result <- f x; close x; return result }
19:09:28 <lambdabot> open >>= \ x -> f x >>= \ result -> close x >> return result
19:09:48 <gwern> that closer to what you were hoping for?
19:09:50 <BMeph> gwern: www.cs.bris.ac.uk/Publications/pub_master.jsp?id=2000745
19:10:30 <aavogt> gwern: I wonder if it is possible to avoid naming the x and result
19:10:39 <aavogt> @type <*
19:10:40 <lambdabot> parse error on input `<*'
19:10:43 <gwern> the x? probably
19:10:44 <aavogt> @type (<*)
19:10:46 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
19:10:56 <gwern> @pl foo x =  f x >>= \ result -> close x >> return result
19:10:56 <lambdabot> foo = liftM2 (>>=) f ((. return) . (>>) . close)
19:11:08 <gwern> aavogt: you just need to work on subexpressions
19:11:22 <Alpounet> @quote syntaxfree
19:11:22 <lambdabot> syntaxfree says: Functional programming has finally arrived to the masses. Its name is not Lisp, ML or Haskell: it's Visual Basic
19:11:34 <gwern> now we can rewrite as 'open >>= liftM2 (>>=)...'
19:12:10 <gwern> I think, anyway
19:12:21 <aavogt> @src (<*)
19:12:21 <lambdabot> (<*) = liftA2 const
19:13:34 <Twey> > pl \result -> close x >> return result
19:13:35 <lambdabot>   <no location info>: parse error on input `\'
19:13:44 <Twey> Oops
19:13:46 <Twey> @pl \result -> close x >> return result
19:13:46 <lambdabot> (close x >>) . return
19:14:06 <Twey> @pl \x -> f x >>= (close x >>) . return
19:14:07 <lambdabot> liftM2 (>>=) f ((. return) . (>>) . close)
19:14:15 <Twey> There you have it
19:14:27 <Twey> Personally I prefer the do version
19:15:15 <Twey> doi aavogt
19:16:16 <aavogt> @type liftA2 (<*) ?f (const $ return ())
19:16:18 <lambdabot> forall a b (m :: * -> *). (Applicative m, ?f::b -> m a, Monad m) => b -> m a
19:17:10 <Twey> Yuck, ?f
19:17:12 <aavogt> @type ?open >>= liftA2 (<*) ?f close
19:17:13 <lambdabot> Not in scope: `close'
19:17:17 <aavogt> @type ?open >>= liftA2 (<*) ?f ?close
19:17:19 <lambdabot> forall (m :: * -> *) a b b1. (?open::m a, Applicative m, ?f::a -> m b, ?close::a -> m b1, Monad m) => m b
19:18:12 <aavogt> Twey: but implicit parameters are explicit in the type!
19:18:30 <Twey> Yes, but dynamic scoping is still hideous
19:19:00 <Alpounet> @pl \x -> x < 0.1
19:19:00 <lambdabot> (< 0 . 1)
19:19:04 <Alpounet> huh ?
19:19:18 <Twey> It's *better* if the function *tells* me it's looking into my personal scope and plucking out potentially-unrelated variables for use in its algorithm
19:19:23 <Twey> It's still not *good*
19:19:27 <aavogt> @type \x -> x < 0.1
19:19:28 <lambdabot> forall a. (Fractional a, Ord a) => a -> Bool
19:20:00 <Twey> IMO, it effectively breaks purity, too
19:20:00 <Alpounet> @type (< 0 . 1)
19:20:01 <lambdabot> forall b c a. (Num (b -> c), Num (a -> b), Ord (a -> c)) => (a -> c) -> Bool
19:20:14 <aavogt> Alpounet: odd
19:20:20 <Alpounet> heh :-)
19:21:00 <Twey> Haha
19:21:01 <Twey> lambdabot bug
19:21:26 <Saizan> ghci, if it's a bug
19:21:27 <Twey> 0.1 /= 0 . 1
19:21:35 <Twey> No, it's @pl's fault
19:21:44 <Alpounet> yep
19:21:45 <aavogt> @type 0.1
19:21:46 <Twey> It interpreted . as compose
19:21:46 <lambdabot> forall t. (Fractional t) => t
19:21:53 <Twey> Instead of decimal point
19:21:57 <Saizan> ah, ok, didn't read enough scollback
19:21:58 <Alpounet> @type (< 0.1)
19:22:00 <lambdabot> forall a. (Fractional a, Ord a) => a -> Bool
19:22:00 <Alpounet> is fine
19:23:04 <Twey> *And* produced an invalid section
19:23:06 <Twey> Hmm
19:23:20 <Twey> More likely, then, that it interpreted it correctly but just output dodgily
19:24:34 <aavogt> getScreens = openDisplay "" >>= liftA2 (<*) (fmap (zipWith const [0..]) . getScreenInfo) closeDisplay
19:25:23 <aavogt> prettier than the do option
19:25:35 <Twey> If you say so.
19:25:49 <aavogt> =)
19:26:13 <BMeph> "Beauty is in the Eye of the Beer-holder." ;p
19:27:55 <Twey> Heheh
19:30:15 <aavogt> @src liftA2
19:30:16 <lambdabot> liftA2 f a b = f <$> a <*> b
19:32:24 <aavogt> is there a discussion why arbitrary expresions can't be made `infixed`?
19:34:25 <heatsink> I'm sure there was one.  I think it's a matter of ambiguous and awkward syntax; for example, would you have `infix `nested` opeators`, or `let complicated = expressions appear inside quotes`?
19:34:48 <heatsink> I mean `let complicated = expressions appear in quotes`
19:36:10 <aavogt> infixr 4 `let complicated = expressions appear in quotes` -- and this?
19:36:13 <Alpounet> g'night all
19:36:46 <copumpkin> edwardk: any time for histo? :)
19:37:18 <aavogt> copumpkin: what's histo?
19:37:32 <Twey> aavogt: I thought I saw something on the Haskell' issue list, but I can't find it now
19:37:52 <copumpkin> histo :: RunComonadCofree f w => GAlgebra f w a -> FixF f -> a	
19:37:59 <copumpkin> aavogt: clear now? :P
19:38:35 <edwardk> copumpkin: fiddling with a printer of all things IRL, but am willing to continue, say, right after
19:39:05 <copumpkin> edwardk: thanks, not urgent though if you'd rather just relax with your printer :)
19:39:11 <edwardk> copumpkin: bah, histo :: Functor f => (f (Cofree f a) -> a) -> Mu f -> a -- is much clearer than that crap I wrote in category-extras
19:39:41 <edwardk> no, no, no, definitely prefer categories to printers, but its easier to read papers when they are printed ;)
19:40:24 <copumpkin> :)
19:40:30 <copumpkin> kindle dx ftw
19:45:38 <vininim> Is there a intersectBy-like function but (a -> a -> Bool) -> [a] -> [a] -> [(a,a)]
19:45:59 <vininim> @hoogle (a -> a -> Bool) -> [a] -> [a] -> [(a,a)]
19:46:00 <lambdabot> Data.Generics.Twins gmapAccumQr :: Data d => (r' -> r -> r) -> r -> (a -> d -> (a, r')) -> a -> d -> (a, r)
19:46:00 <lambdabot> Data.Generics.Twins gmapAccumQl :: Data d => (r -> r' -> r) -> r -> (a -> d -> (a, r')) -> a -> d -> (a, r)
19:49:39 <byorgey> vininim: not that I know of.  you can just use a list comprehension though.
19:50:07 <heatsink> edwardk: Are you working on a programming language with dependent and linear types?
19:50:10 <byorgey> > [ (x,y) | x <- [1..5], y <- [3,6..18], y `mod` x == 0 ]
19:50:11 <lambdabot>   [(1,3),(1,6),(1,9),(1,12),(1,15),(1,18),(2,6),(2,12),(2,18),(3,3),(3,6),(3,...
19:50:51 <edwardk> heatsink: i was for a while, but the type annotations became horrific
19:51:19 <Pseudonym> Suffix arrays are seriously cool.
19:51:27 <copumpkin> what's a suffix array? :o
19:51:33 <edwardk> heatsink: and s/linear/substructural/ since i was targeting substructural types in general
19:51:51 <heatsink> edwardk: I didn't know it was possible to target substructural types in general.
19:52:00 <edwardk> copumpkin: store abracadabra and every suffix of abracadabra efficiently.
19:52:37 <edwardk> heatsink: i was using display logic as the basis for the type system, you can show most substructural types can be expressed as modalities that satisfy the display property
19:52:51 <edwardk> copumpkin: suffix tries are the obvious representation.
19:53:06 <edwardk> copumpkin: it isn't obvious but a suffix trie can be constructed in linear time.
19:53:30 <vininim> byorgey: that wouldn't stream fuse though =P
19:53:35 <heatsink> Huh, interesting.
19:53:36 <Pseudonym> And there's a theorem that any algorithm which works on suffix tries also works on a flattened form (i.e. suffix arrays).
19:53:36 <edwardk> an equivalent but slightly smaller structure (also with a linear time construction available) is a suffix array.
19:53:48 <copumpkin> ah
19:53:50 <edwardk> http://en.wikipedia.org/wiki/Suffix_array
19:54:19 <Pseudonym> It's something of an optimal data structure for any problem that involves search-like operations on strings.
19:54:39 <edwardk> its used for the burrows wheeler transform, myers and manber had an O(n log n) construction, but there is a really slick algorithm by karkkainen and sanders that is among my favorite algorithms of all time
19:54:55 <Pseudonym> edwardk: I've met Simpon Puglisi.
19:54:55 * copumpkin still wants a dawg in haskell :P
19:55:01 <edwardk> which can construct a suffix array in linear time, in a way that is not even remotely related to the suffix trie constructions
19:55:28 <edwardk> copumpkin: I'll stick to Cats. Less maintenance.
19:55:32 <copumpkin> :P
19:56:16 <heatsink> edwardk: I thought I might learn from your experience, but it sounds more distant from what I'm doing than I thought at first.
19:56:24 <edwardk> copumpkin: Simple linear work suffix array construction http://www.cs.helsinki.fi/u/tpkarkka/publications/jacm05-revised.pdf has one of the nicest algorithms though.
19:56:30 <Pseudonym> The neat thing about a suffix array is that the original string is "there" in some sense.
19:56:32 <edwardk> heatsink: what are you doing?
19:56:53 <Pseudonym> The BWT being an obvious example.
19:56:53 <edwardk> heatsink: ah i'm betting you found my old linguist list entry (re the substructural types thing)
19:57:02 <heatsink> edwardk: What was the motivation for the type system?  Like, was it for programming in, or writing proofs...
19:57:09 <heatsink> edwardk, Actually, referred by Phillipa
19:58:08 <edwardk> heatsink: programming in, with dependent types for proving correctness of code, ala ATS with substructural type annotations to allow reuse or constrain consumption
19:58:27 <heatsink> edwardk, I'm building a compiler optimization infrastructure.  The linear and dependent types are to embed side effect information for use by optimization passes.
19:59:17 <copumpkin> heatsink: !
19:59:28 <copumpkin> heatsink: sounds fun, any information out there on it?
19:59:56 <heatsink> edwardk, intending to reformulate automatic parallelization (Fortran loop stuff) in a way that doesn't depend on pointer and dependence analysis, and then extend it
19:59:59 <edwardk> nowadays what i've been looking into is moving more and more of my compiler passes into a tracing jit, it seems to let me target where the code actually matters a lot better and i can "magically" pick out the execution paths that are being used because I've seen actual traces
20:00:11 <edwardk> that took me pretty far afield from the substructural types
20:01:05 <heatsink> copumpkin, Not at present.  I'm still building the infrastructure, and still learning basics as I go -_-
20:01:11 <copumpkin> ah
20:01:24 <edwardk> for correctness i started to drift away from dependent types because i wanted something someone would be willing to use, so I found myself looking seriously at systems like dana xu's static contract checking
20:02:02 <edwardk> mainly because you can express annotations that you may not be able to verify and then incrementally work your way into satisfying these stronger but erasable types.
20:02:05 <Pseudonym> While we're talking compiler optimisation, does anyone know if anyone has investigated equality saturation for lambda calculus-like languages?
20:02:39 <edwardk> Pseudonym: as in the paper that hit LTU a few months back?
20:02:58 * Pseudonym checks
20:03:11 <Pseudonym> Yeah, that.
20:03:38 <edwardk> I was curious about it myself but I haven't seen anyone tackling it
20:04:03 <Pseudonym> I guess one of the problems for lazy languages is that the normal form automatically does CSE.
20:04:16 <Pseudonym> Which we know is sometimes inappropriate.
20:04:27 <copumpkin> edwardk: do you have any common examples of histomorphisms?
20:04:38 <edwardk> mostly i was interested in retaining the equality saturation as information for my jit
20:05:00 <edwardk> copumpkin: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.60.9336 has several iirc
20:05:32 <copumpkin> ah, I started looking at that, but forgot about it... I'll keep reading :)
20:05:47 <edwardk> i have a nice module i was writing up with an example of each foomorphism that i was planning on blogging but it might be at work, lemme check
20:07:36 <heatsink> edwardk, that's an interesting direction too.  In my observation, dynamic instrumentation and contracts don't apply well to concurrency, unless they're supplemented with some kind of speculation.  But I've been focusing in a different direction, so I could have easily missed something.
20:08:28 <edwardk> well, what i was doing for concurrency was tracking an extra set of attributes to identify thread/process/task locality of each value so i could implicitly add cilk style fork/join points and do work stealing between tasks
20:11:40 <heatsink> were these attributes generated statically?
20:11:50 <edwardk> heatsink: yeah
20:12:47 <edwardk> heatsink: the mechanism i was using to propagate the family of modalities i needed for the substructural annotations was the same mechanism i needed to propagate those other attributes
20:12:59 <edwardk> they are just another set of implicit modalities to infer
20:14:06 <edwardk> and you can constrain them to be satisfied so you can require those traits to be satisfied one way or another when needed. basically you need unification with constraint handling rules but thats a pretty well explored area
20:16:01 <heatsink> Is this described somewhere?  I'd like to see how locality is identified
20:16:39 <edwardk> never did get around to publishing it, my advisor became the dean of the college and i moved on to industry and shelved it for the most part
20:20:34 <heatsink> so much knowledge goes unpublished.
20:21:07 <heatsink> I hope you don't mind if I quiz you some more
20:22:58 <edwardk> i'll happily answer based on what I can recall
20:25:03 <copumpkin> edwardk: I remember you mentioning that only a few of these crazy categorical recursion schemes were actually useful in optimization... could you remind me which ones and why?
20:30:04 <heatsink> Thx. So what were the locality annotations?  Something like chapel's locales?
20:30:06 <edwardk> copumpkin: in general cata/ana/hylo are useful because they are easily understood and have an obvious purpose. para is handy because it just you 'have your result and your original structure too', zygo models the fact that some times you need a helper. histo is interesting it can give you the result of every reduction you've applied on every sub problem.
20:31:22 <edwardk> heatsink in my case it was more like crossing an explicit fork/join point forced the use of the wider locality modality. i don't care what location it is, merely if you might be accessing the value from more than one work deque
20:33:43 <heatsink> That sounds like a synchronization constraint.  It doesn't sound like it would help with locality though.
20:34:59 <edwardk> heatsink: well, if i am working within one core i don't have to worry about barrier synchronization with anyone else. i can allocate it in a local heap that i can safely pause and copy collect without asking anyone, so on and so forth
20:35:07 <defun> :t (::)
20:35:09 <lambdabot> parse error on input `::'
20:35:22 <defun> :t (->)
20:35:23 <lambdabot> parse error on input `->'
20:36:30 <heatsink> edwardk, ah, I see.  So it's purely a "local" versus "global" distinction.  Do you have something like region types to divide up the heap?
20:36:34 <edwardk> so by locality i mean locality of reference
20:36:47 <emy> can anyone recommend me a pagination code?
20:36:47 <Twey> defun: The former is built-in syntax, and the latter is a type constructor
20:36:57 <emy> or anyway to split a large database
20:37:10 <Twey> Therefore, neither have types
20:37:18 <emy> sorr.y..my first time using gogloom..not sure where to ask ><
20:37:20 <Twey> emy: Er... LIMIT clause?  What does this have to do with Haskell?
20:37:26 <copumpkin> edwardk: I assume the sliding window measures on a stream I mentioned originally are representable as dynamorphisms as well as generalized histomorphisms?
20:37:36 <emy> lol...it was just the biggest group in programming
20:37:41 <heatsink> Yeah.  I'm coming more from the scientific computing angle, where locality gets more complex.  You may for example want a "map over all pairs (x, y)
20:37:53 <Twey> emy: We are users and developers of the programming language Haskell
20:37:53 <emy> anyone who can help? T_______T
20:38:02 <heatsink> Yeah.  I'm coming more from the scientific computing angle, where locality gets more complex.  You may for example want a "map over all pairs (x, y)  \in S \times S" operation, which has more a complicated data reuse pattern
20:38:06 <Twey> You should ask in the channel for the programming language you are using.
20:38:07 <emy> I'm just so confused....
20:38:20 <emy> what is haskell?
20:38:27 <copumpkin> emy: #sql maybe? or a rails channel?
20:38:37 <edwardk> well, there are progressively wider ranges of scope, but thats the idea. each worker has a local region and some tricky semantics to allow local copy collection of all unshared data.
20:38:39 <copumpkin> emy: a language unlike any you've ever encountered :P
20:39:17 <emy> hahaa...*wiki*
20:39:21 <heatsink> turn baaack before its too laaaate
20:39:28 <edwardk> heatsink: i've spent a lot of time in those circles as well. this is a different beast.
20:39:48 <edwardk> Lets move this to #haskell-in-depth
20:39:57 <heatsink> ok
20:40:03 <heatsink> \join #haskell-in-depth
20:40:09 <heatsink> wrong slash
20:40:13 <emy> haha I regret I asked now
20:40:55 <Twey> emy: :)  Haskell is a lazily-evaluated, purely functional programming language.
20:41:14 <emy> Thanks twey and copumpkin!
20:41:26 <copumpkin> emy: you should stay and get your mind blown by the awesomeness of haskell :)
20:41:38 * Twey chuckles.
20:41:42 <emy> do ya'll have experience with php?
20:41:57 <emy> I am working on a database website built upon php and mysql
20:42:14 <importantshock> emy: ##php would be a better channel to ask on.
20:42:32 <emy> and really need help with paging...
20:42:41 <emy> I tried....but there's like..nobody there
20:42:57 <Twey> emy: Most of us do, but have repressed the experience, and prefer not to be reminded.  :-P
20:43:12 <emy> LMAO!!!!!!!!!!!
20:43:16 <emy> I know what u mean
20:43:26 <emy> but it's too late to switch since most of the website is already done
20:43:36 <emy> I just need some code to split up the data T________T
20:43:44 <emy> can I incorporate haskell into php?
20:43:46 <emy> hahaha.........
20:43:47 <Twey> Hard luck
20:43:50 <Twey> Alas, no
20:43:58 <Twey> Not in any way worth the effort, anyway :-P
20:44:05 <copumpkin> you can write haskell code outside of the php blocks ;)
20:44:06 <Twey> Like I said earlier, use LIMIT queries.
20:44:10 <copumpkin> but then it'll just show up in your output
20:44:14 <Axman6> you could write the websire i haskell though
20:44:32 <emy> ohh...limit queries.....thanks twey..I'll look that up
20:44:52 <Twey> SELECT ... LIMIT <lower_limit>, <upper_limit>
20:45:09 <Twey> Getting it into pages from there is just arithmetic.
20:45:10 <emy> would you say that's a diff method compared to pagination?
20:45:18 <emy> I mean....
20:45:24 <Twey> Define âpaginationâ
20:45:39 <emy> wow I rpolyl sound so retarded, I meant like.....the other way I encountered
20:46:04 <Twey> And what might that be?
20:46:05 <emy> I'm following this tutorial from yahoo. Its first step is using index
20:46:28 <emy> here's a link to it: http://www.percona.com/ppc2009/PPC2009_mysql_pagination.pdf
20:46:38 <emy> I'm like...on 2nd step and already lost
20:46:43 <Twey> You can do the same thing using your own indices, yes
20:46:47 <emy> so I really wish someone can give me some direction ><
20:47:03 <emy> may Iask where I set the limit?
20:47:21 <Axman6> keep asking in ##php
20:47:48 <Twey> emy: If that's so, I suggest you find yourself a MySQL tutorial before proceeding any further with the site
20:47:55 <Twey> #mysql would be more appropriate
20:48:35 <Axman6> that too
20:48:46 <Twey> And no to your earlier question: it's the same basic principle, but using a developer-defined index rather than the underlying order of the table.
20:49:09 <mmorrow> select peoplez, sum(walrus_sunglasses) from zomg group by peoplez order by peoplez descending limit 132, 409
20:49:28 <copumpkin> lol
20:49:45 <mmorrow> copumpkin: oh hai
20:49:45 <emy> php is overflowed?
20:49:47 <copumpkin> mmorrow is on something good
20:49:52 <mmorrow> heh
20:50:04 <copumpkin> hi!
20:50:04 <Twey> Heh
20:50:07 <copumpkin> heh
20:50:38 <emy> ah..I guess I'll just go to mysql chat
20:50:47 <emy> thanks for your help!!!
20:51:01 <Axman6> crazy kid
20:54:17 <eck> i'm going to use sqlite with a haskell app i'm writing; does anyone have any suggestions of which sqlite library to use? i'm kind of overwhelemed with the choice i have on hackage
20:56:25 <Axman6> which ever one you like the interface of most
20:56:59 <Axman6> take some time to check out the haddock stuff on hackage, and see what you like best
21:01:38 <BMeph> Hmm...a K interpreter in Haskell...subversive! ;)
21:03:09 <dumael> BMeph: where?
21:12:06 <BMeph> dumael: In mah haid! ;p
21:13:59 <dumael> ah.
21:19:46 <QtPlaty[HireMe]> Is there a channel for language design and implementation?
21:21:14 <copumpkin> #oasis iirc
21:21:33 <Saizan> or #haskell-in-depth apparently :)
21:22:35 <dumael> QtPlaty[HireMe]: lambda-the-ultimate.org is also an interesting read for language design.
21:24:50 <scutigera> I'll second lambda-the-ultimate, many interesting tidbits on that site.
21:25:40 <Twey> LtU is often interesting
21:25:55 <scutigera> copumpkin: how goes uvector hacking ?  I have not had to make use of them cause lists are fast enough so farr :-)
21:26:30 <Saizan> @farr
21:26:31 <lambdabot> Maybe you meant: arr yarr
21:26:39 <copumpkin> scutigera: temporarily on backburner, will probably get to it soon :)
21:27:01 <scutigera> copumpkin: know how that goes !
21:29:32 <scutigera> so anybody have a simple example of why lazy is so nice.  I don't believe I've run into a situation where I _needed_ it.
21:30:07 <sjanssen> scutigera: the Turing tarpit says you never need it
21:30:33 <sjanssen> but there are loads of places where it is convenient
21:30:46 <sjanssen> need to number the elements in a list? zip [0 ..] xs
21:31:28 <sjanssen> want to efficiently find the k minima of a list? take k (sort xs)
21:31:51 <copumpkin> take k (sort xs) isn't very lazy is it?
21:32:01 <copumpkin> unless sort is a quadratic sort?
21:32:24 <Saizan> bottom-up mergesort iirc
21:32:26 <sjanssen> scutigera: laziness allows us to more easily compose smaller programs into large ones that still work
21:32:40 <sjanssen> copumpkin: as Saizan notes, the mergesort GHC uses works
21:32:53 <Gracenotes> well, then it's just O(n*k)...
21:33:00 <Gracenotes> prolly.
21:33:03 <copumpkin> hrm
21:33:04 <scutigera> sjanssen: seems like function'ness does that nicely especially in the pure incarnation.
21:33:09 * copumpkin wonders how I would test that
21:33:25 <roconnor> it allows us to separate generators from consumers.
21:33:29 <Gracenotes> for insertion sort at least (I think it might be deletion sort here)
21:33:44 <scutigera> mergesort is n log n, right ?
21:34:01 <sjanssen> copumpkin: for Data.List.sort I think it's O(n + k log n)
21:34:17 <copumpkin> ah
21:34:27 <Gracenotes> it wouldn't be so nice for bubblesort
21:34:44 <copumpkin> so it's lazy in the sense that it doesn't do all the work, but typical laziness tests with undefined would fail, right?
21:34:48 <scutigera> rconnor: aka streams ?
21:35:04 <sjanssen> copumpkin: any comparison sort can't be that lazy
21:35:17 <copumpkin> yeah :P
21:35:28 <Gracenotes> I sorted a list in O(log n)! Go me!!
21:35:47 <Saizan> in the type system?
21:35:49 <Gracenotes> I used my parapsychological powers
21:36:01 <scutigera> all you need is an oracle
21:36:35 <monochrom> @why_fp
21:36:36 <lambdabot> Unknown command, try @list
21:36:38 * inimino isn't sure that's enough
21:36:43 <sjanssen> scutigera: purity is just one piece of the composability puzzle
21:36:44 <monochrom> @where why_fp
21:36:44 <lambdabot> http://www.cs.chalmers.se/~rjmh/Papers/whyfp.html
21:37:01 <Gracenotes> is that the old paper?
21:37:07 <monochrom> That is an article on how laziness helps you re-factor your program.
21:37:13 <scutigera> oh yeah , forgot about whyfp, time to read it again.
21:37:30 <scutigera> I have been wondering in the deserts of strict functional
21:37:39 <scutigera> wandering..
21:38:28 <Gracenotes> laziness is rarely problematic, and is often helpful
21:38:45 <monochrom> A short summary is you can write producer and consumer separately.
21:39:03 <scutigera> hmmmm.. very early in learning haskell you will see "use foldl'", it's not lazy !
21:39:03 <monochrom> > take 10 . repeat 0
21:39:05 <lambdabot>   Couldn't match expected type `a -> [a1]'
21:39:13 <Gracenotes> can't think of a situation it would be a huge problem off the top of my head, except maybe when you run into limits for how many functions can be in a row without being evaluated
21:39:37 <Gracenotes> well. using foldl' has to do with these limits :)
21:39:41 <roconnor> scutigera: for example.
21:40:08 <scutigera> yes - I have met the stack space exceeded fail :-(
21:40:23 <Gracenotes> laziness can also prompt its own style of dynamic programming :)
21:40:49 * roconnor blames the flat cpo structure of integers for newbie's stack problems.
21:40:55 <monochrom> http://www.haskell.org/haskellwiki/Dynamic_programming_example
21:41:28 <Saizan> scutigera: that's also because many will tend to use accumulators instead of restructuring the program to take advantage of laziness (not that there aren't uses for accumulators/tail recursion, especially if you're collapsing a big structure to a simple value)
21:41:36 <scutigera> I heart haskell wiki, lot's of good stuff therein
21:42:13 <scutigera> "flat cpo" ?
21:42:33 <Gracenotes> > let lev s t = f s' t' where s'=length s; t'=length t; f i j = d !! (i*(t'+1)+j); d = liftM2 u [0..s'] [0..t']; u i j |i==0 = j|j==0 = i|otherwise = minimum[f (i-1) j + 1,f i (j-1) + 1,f (i-1) (j-1) + (fromEnum $ s!!(i-1)/=t!!(j-1))] in lev "this is a levenshtein distance using lists" "that are only evaluated as necessary"
21:42:34 <lambdabot>   31
21:43:22 <Gracenotes> d is an index of all intersections of characters in strings s and t -- a matrix represented as a list with an indexing system called f
21:43:57 * Gracenotes likes his lev :x
21:44:26 <Saizan> scutigera: that evaluating an integer leads directly to the full concrete value, instead of having subparts that you can delay further like a list
21:44:50 * Reiv curses.
21:44:57 <Reiv> I feel like I've missed some fundamental bit of education.
21:45:18 <Reiv> I'm still stuck on this damned error refactoring problem. :/
21:45:22 <sjanssen> roconnor: what does the acronym stand for?
21:45:34 <scutigera> Saizan: that would be the flat cpo, right ?
21:45:59 <Saizan> scutigera: afaiu, at least :)
21:46:27 <roconnor> sjanssen: cpo?  complete partial order
21:46:31 <sjanssen> is CPO a protocol droid?
21:46:46 <roconnor> hmm
21:46:47 <scutigera> not C3PO...
21:47:13 <scutigera> complete partial order - oxymoron award winner
21:47:45 <scutigera> http://en.wikipedia.org/wiki/Complete_partial_order
21:48:41 <Saizan> "Every set S can be turned into a cpo by adding a least element â¥ and introducing a flat order with â¥ â¤ s and s â¤ s for every s â S and no other order relations." <- and that's what the domain of Integer (or Int etc..) looks like
21:49:12 <sjanssen> scutigera: a simpler way of describing roconnor's point is that (+) on Int is strict on both its arguments
21:49:46 <scutigera> sjanssen: hey, I get that explanation :-)
21:49:49 <roconnor> sjanssen: that's true, but it is more than that.  It is impossible for (+) not to be strict by the cpo of Int.
21:50:08 <sjanssen> scutigera: an alternative is: data Nat = Zero | Succ Nat
21:50:18 <scutigera> how can int's be cpo, no least element, or is least element -inf ?
21:50:45 <roconnor> > (10 :: Natural) <= sum [1..]
21:50:56 <lambdabot>   mueval-core: Prelude.read: no parse
21:50:56 <lambdabot>  mueval: ExitFailure 1
21:51:01 <roconnor> :(
21:51:09 <roconnor> > (10 :: Nat) <= sum [1..]
21:51:12 <lambdabot>   Not in scope: type constructor or class `Nat'
21:51:32 <Saizan> scutigera: the order we're talking about is the one of definedness
21:52:00 <roconnor> > (10 :: Nat) <= foldr (+) 0 [1..]
21:52:02 <lambdabot>   Not in scope: type constructor or class `Nat'
21:52:05 <roconnor> > (10 :: Natural) <= foldr (+) 0 [1..]
21:52:07 <lambdabot>   True
21:52:16 <roconnor> stupid sum
21:52:18 <disgrntld> I'm trying to improve the speed of http://pastebin.com/m5dc9fb1c , http://pastebin.com/m2989d85 is what I came up with. Is it any faster?
21:52:31 <scutigera> well naturals, I understand, but ints ....
21:52:46 <Saizan> scutigera: so, e.g. for tuples of integers: undefined < (undefined,undefined) < (1,undefined) < (1,2)
21:53:21 <Saizan> while between (1,2) and (3,4) there's no relation
21:53:56 <disgrntld> I'm having trouble testing it with large enough data sets to tell the difference with linux's "time" and I don't know how to use the profiler.
21:54:07 <scutigera> disgrntld: whenever I see "speed" and "haskell" I also see "strictness annotation"
21:54:19 <scutigera> Saizan: lost me...
21:54:58 <sjanssen> disgrntld: that should do half as many comparison operations, yes
21:55:12 <disgrntld> cool, thanks sjanssen
21:55:20 <disgrntld> @scutigera, will do
21:55:21 <lambdabot> Unknown command, try @list
21:55:50 <Saizan> there isn't really any strictness to add there, i think?
21:56:24 <sjanssen> disgrntld: whether it is faster or not is hard to say.  It may depend on the type you're sorting -- reducing comparisons is a big win for String, but a smaller win for Int
21:56:54 <sjanssen> Saizan: you might want a strict binding for 'parted'
21:57:29 <disgrntld> sjanssen: ok, I was more wondering if there was some kind of trick going on with the two list comprehensions... I dunno.... working together or something
21:58:27 <disgrntld> ..just seemed like a naive way to do it, and this is from a Haskell tutorial
21:58:34 <sjanssen> disgrntld: by the way, your part function is identical to Data.List.partition
21:58:56 <Saizan> sjanssen: i think that'll give a stack overflow, potentially
21:59:01 <disgrntld> yea.. I kinda copied it <.<
21:59:19 <scutigera> hmmm..back to that lazy thing again :-)
21:59:38 <sjanssen> Saizan: you're right
22:00:11 <sjanssen> IIRC, the old quicksort used a partition that reversed the order of the outputs
22:01:00 <disgrntld> Can someone explain how the strictness annotations speed things up?
22:01:07 <ceal> can you please explain what this code is??
22:01:10 <ceal> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2819#a2819
22:01:21 <Twey> disgrntld: They don't speed things up, but they do reduce memory footprint
22:01:39 <ceal> i am new to haskell: just started learning now
22:01:56 <sjanssen> disgrntld: they won't do anything in this code.  Strictness annotations are used to make certain bits of evaluation happen before other bits of evaluation
22:01:58 <disgrntld> Twey: why? doesn't the compiler just figure out the same thing?
22:02:06 <scutigera> ceal: have you run the code yet ?
22:02:13 <ceal> nope
22:02:22 <ceal> want to understand how it works
22:02:23 <sjanssen> disgrntld: this can often reduce memory footprint, or allow the compiler to remove intermediate "boxes"
22:02:34 <ceal> what does the second line mean??
22:02:35 <Twey> For a lazy function (*), a * b * c * d creates a thunk (a * (b * (c * d))), evaluated when it's needed, but if the function is made strict, all the computation will be done up front, yielding a single value e
22:02:36 <disgrntld> sjanssen: hrmm.. is this related to "currying"?
22:02:40 <sjanssen> disgrntld: the compiler often can infer this, it is called "strictness analysis"
22:02:48 <ceal> the one with the fibgen...
22:02:50 <Twey> disgrntld: Because that might not be appropriate
22:03:15 <Twey> If the value is an infinite list, for example, automatically adding strictness would make your program go into an infinite loop when that list is created
22:03:25 <disgrntld> that's exactly the next question I had
22:03:27 <disgrntld> cool
22:03:43 <Twey> Less seriously, it might cause work to be done that was unnecessary, thus decreasing performance
22:04:00 <disgrntld> like: fibs = 0:1:zipWith fibs (tail fibs)?
22:04:15 <Twey> That's an infinite list, yes
22:04:16 <disgrntld> I learned that one yesterday XD
22:04:25 <scutigera> ceal: do you understand the recursion in fibgen ?
22:04:26 <Twey> Er, well
22:04:35 <Twey> It would be if you added the necessary (+) function :)
22:04:41 <disgrntld> :P
22:04:45 <disgrntld> whoops!
22:04:46 <ceal> no
22:04:53 <Twey> fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
22:04:59 <ceal> one thing
22:05:10 <disgrntld> what you said makes sense to me though, thanks!
22:05:11 <ceal> what does the first line defining fibGen mean??
22:05:23 <ceal> i understand the definition of fib
22:05:25 <sjanssen> ceal: "fibGen :: Int -> Int -> Int -> Int
22:05:26 <Twey> fibGen :: Int -> Int -> Int -> Int â this one?
22:05:27 <scutigera> in scheme , lazy, well streams really, are simply thunks to be evaluated later.  is this still a valid paradigm for lazy in haskell ?
22:05:33 <ceal> yeah that line
22:05:39 <Twey> It means that fibGen is a function from Int to Int to Int to Int
22:05:42 <sjanssen> ceal: that means it is a function that takes three Ints and returns an Int
22:05:59 <ceal> oh ok
22:05:59 <Twey> One way of thinking of it is as a single function that takes three Ints as arguments and returns an Int
22:06:14 <ceal> so the last one signifies the return type??
22:06:25 <ceal> and all others arguements rt??
22:06:29 <Twey> More accurately, it is a function that takes one Int and returns a function that takes one Int and returns a function that takes one Int and returns an Int
22:06:52 <ceal> :(
22:07:11 <ceal> wait that means there's recursion in it??
22:07:11 <sjanssen> ceal: roughly, yes.  It is a bit more complicated than that (this is called currying), but you probably don't need to tackle that yet
22:07:33 <sjanssen> ceal: the type doesn't mean it has recursion, but the definition below it does
22:07:35 <ceal> but it's right at the start of this tutorial; currying!!
22:07:40 <Twey> Er, it is recursive, but that's not reflected in the type
22:08:06 <Reiv> http://pastebin.com/d5ad3ac3 - So, I need to modify the Error part of things to return the state of the TINY machine. I'm a little stuck on where to start with this, alas. :/
22:09:10 <ceal> twey, sjanssen is this the right place to start learning haskell??
22:09:32 <Twey> Er, yes, but you'll need some sort of informational material too
22:09:46 <Twey> We'll be happy to answer questions, but we can't really teach you the whole language :-P
22:09:55 <ceal> oh no i didn't mean the channel
22:10:01 <Twey> I recommend Real World Haskell, http://book.realworldhaskell.org/
22:10:02 <ceal> i meant the part i am in
22:10:11 <ceal> is this one good??
22:10:19 <sjanssen> ceal: which is it?
22:10:23 <Twey> I don't know, what are you using?
22:10:27 <ceal> hold on....
22:10:41 <Tsion> http://learnyouahaskell,com is really good
22:10:51 <Tsion> Err
22:10:51 <Twey> If you can stand it, maybe :-P
22:10:53 <ceal> http://www.haskell.org/~pairwise/intro/intro.html is what i am using
22:10:56 <Tsion> http://learnyouahaskell.com *
22:10:59 <Tsion> had a comma
22:11:09 <Twey> ceal: That's kind of old
22:11:10 <scutigera> ceal : Haskell: The craft of functional programming, Simon Thompson
22:11:13 <aledge> Is there a way to make an existential type an instance of Eq?
22:11:21 <Tsion> Twey: Why couldn't you stand it?
22:11:53 <Twey> Using RWH will give you a better introduction to the modern libraries and techniques we use in... well, the real world
22:12:03 <sjanssen> ceal: this one seems sort of random.  LYAH is the short fun one, RWH is the long comprehensive one
22:12:11 <sjanssen> @where lyah
22:12:12 <Twey> Tsion: For the same reason I couldn't stand Why's Poignant Guide :-P
22:12:12 <lambdabot> www.learnyouahaskell.com
22:12:14 <sjanssen> @where rwh
22:12:15 <lambdabot> is http://www.realworldhaskell.org/blog/
22:12:26 <Tsion> Twey: I couldn't stand Why's Poignant Guide either.
22:12:26 <Twey> Too many elephants, not enough hard info
22:12:32 <Tsion> I'm fine with LYAH though
22:12:41 <scutigera> IMO, RHW not the best learning text.
22:12:50 <Twey> LYAH was designed to be the WPG of Haskell, as I recall
22:12:52 <Tsion> RHW seems really dry
22:12:55 <Twey> So I guess BONUS failed :-P
22:12:55 <scutigera> I mean RWH
22:12:57 <Saizan_> aledge: it depends on the typeclass constraints you have in it, Eq and Typeable are enough
22:13:07 <ceal> so which do you think is best to try as the initiation into haskell
22:13:10 <Tsion> Twey: He failed in the best way possible IMO :P
22:13:24 <Twey> Well, whatever works for you :)
22:13:27 <aledge> so say I have data Input = forall a. (Eq a) =>  Leaf a
22:13:28 <ceal> i have never tried functional programming as detailed as in haskell
22:13:32 <Twey> I like âdryâ
22:13:48 <sjanssen> ceal: start with LYAH, if the cutesy stuff gets on your nerves move on to RWH
22:13:50 <Twey> âDryâ means it cuts through the crap and gets the information across in an efficient manner
22:13:51 <aledge> basically i'm going to have a heterogeneous list
22:14:02 <ceal> ok
22:14:05 <aledge> i want to compare elements, and if they're different types then that is 'false'
22:14:06 <Twey> Less time-wasting :-P
22:14:11 <ceal> ok lyah it is
22:14:13 <scutigera> Reiv: still here ?
22:14:20 <ceal> thanks twey and sjanssen
22:14:31 <Saizan_> aledge: you need Typeable a too, to be able to tell if they are the same type or not
22:14:55 <aledge> Saizan_: will I be able to just do 'deriving Eq'
22:15:16 <Saizan_> aledge: no, you'd have to write the instance yourself
22:15:20 <Tsion> Twey: I always get distracted by the comments things on RWH :/
22:15:33 <aledge> Saizan_: hm ok anything special there? or just compare types and then the expected?
22:16:02 <Saizan_> aledge: instance Eq Input where Leaf x == Leaf y = cast x of Nothing -> False; Just x' -> x' == y
22:16:22 <Saizan_> forgot a case
22:16:26 <Twey> Tsion: Don't read them, then :-P
22:16:31 <Twey> They're conveniently collapsed
22:16:36 <Saizan_> aledge: instance Eq Input where Leaf x == Leaf y = case cast x of Nothing -> False; Just x' -> x' == y
22:16:38 <Tsion> Twey: Yeah, I try to do that :P
22:16:38 <Twey> Disable Javascript and they vanish entirely
22:16:45 <aledge> Saizan_: alright I'll give that a shot
22:16:49 <aledge> Saizan_: thanks
22:17:15 <Saizan_> aledge: np, see the documentation on Data.Typeable too
22:17:18 <ceal> oh neat lyah is by BONUS huh??
22:17:32 <Twey> Yeah
22:18:09 <djahandarie> I liked Learn You a Haskell
22:18:12 <Tsion> BONUS seems to me to be a more sane, more funny version of _why :P
22:18:37 <djahandarie> But that just kind of has to do with how I am
22:18:48 <djahandarie> I never learn anything unless it looks appealing to me
22:19:10 <djahandarie> But if it does look appealing to me I can sift through the most dry stuff ever
22:19:16 <djahandarie> So I dunno actually
22:19:44 <Tsion> Once I grasp something, I usually never forget it, but Haskell is a little harder to grasp than most languages
22:20:26 <sjanssen> Tsion: the dead-tree version of the book has no comment things :)
22:20:32 <ceal> is the concept of lists and stuff from python there??
22:20:52 <sjanssen> > [1, 2, 3] -- Haskell has lists.  Similar, but not the same
22:20:53 <lambdabot>   [1,2,3]
22:20:54 <aledge> Saizan_: ah I see now, perfect.
22:21:12 <ceal> ok
22:21:39 <emy> helllo
22:21:45 <emy> ahhhhhhh I need help..anhyone?!
22:21:49 <Saizan_> aledge: honestly i always feel like cheating when using Typeable, but it works :)
22:21:59 <aledge> Saizan_: is it poor style?
22:22:09 <emy> when I tried to join the mysql page, it says error u need to be identified?~
22:22:13 <emy> wth??!?
22:22:25 <emy> how do I become identified on gogloom?
22:22:31 <ceal> emy: i think you need a registered nickname
22:22:33 <aledge> Saizan_: I'm writing a matcher, and I want to be able to match heterogeneous lists
22:22:44 <ceal> that happened yesterday to me too
22:22:57 <emy> oh well...I have a general question
22:23:12 <emy> where should I put a paging php code?
22:23:24 <emy> like...I have the view.php ...index.php...etc
22:23:30 <emy> sorry I am a n0000000000b
22:23:31 <Saizan_> aledge: well, it's a bit like downcasting in OO languages, but in this case you aren't downcasting to a fixed set of types, so it's ok
22:23:38 <inimino> emy: this channel is about Haskell
22:23:38 <sjanssen> emy: you're in the wrong channel.  This is for the Haskell programming language
22:23:40 <inimino> not PHP and not general freenode support
22:23:43 <sjanssen> emy: try #php or something
22:23:48 <aledge> Saizan_: hehe downcasting...so dirty.
22:24:11 <sjanssen> Saizan_: oh jeez, don't repeat that too many times
22:24:24 <emy> aw I thought u guys would all have experience with php alraedy
22:24:27 <sjanssen> (despite how true it is)
22:24:31 <emy> since php nobody is answering ...
22:24:43 <Saizan_> sjanssen: what? downcasting? :)
22:24:43 <emy> this is like the only chat room with human
22:25:00 <emy> I am trying to follow this tutorial: http://www.tonymarston.net/php-mysql/pagination.html
22:25:02 <sjanssen> Saizan_: associating Typeable with downcasting.  It will just embarass us
22:25:09 <emy> can someone tell me where I should put all those sep codes?!
22:25:14 <dirk_> I did a new testrun of my mediawiki to latex converter written in haskell, it 62 MByte 1005 Pages, its German  and its about medicine so some pictures are not for the fainthearted still here it is http://upload.wikimedia.org/wikibooks/de/a/ac/MedizinischeMikrobiologie.pdf
22:25:28 <luqui> emy, um, please do not spam #haskell with php help.
22:25:38 <inimino> emy: it's a channel, not a chat room, and you are in the wrong one.
22:25:46 <emy> O___O channel?!
22:25:55 <sjanssen> emy: you've been told several times, this is the wrong channel.  Go to #php.  I don't want to be rude, but you're not getting another warning
22:25:57 <emy> it's my first time using gogloom...i thought these are chat rooms?!
22:26:16 <emy> I just type in #php?
22:26:26 <luqui> emy, "/join #php"
22:26:28 <ceal> emy:/join #php
22:26:29 <QtPlaty[HireMe]> /join #php
22:26:44 <luqui> ECHO Echo echo echo
22:26:50 <emy> uh..not working
22:26:55 <Saizan_> or maybe /join #irchelp ?
22:27:10 <emy> I only get  overflow
22:27:11 <emy> wth...
22:27:21 <luqui> php is a registered users only channel
22:27:22 <emy> this is seriously the only room with ppl talking
22:27:36 <emy> oh gee that's why
22:27:43 <QtPlaty[HireMe]> emy: What are you using?
22:27:57 <Cale> luqui: That's a lie, isn't it?
22:27:59 <emy> how do I even register
22:28:04 <Cale> oh, er...
22:28:12 <Cale> registered in that sense, okay :)
22:28:31 <luqui> Cale, what sense did you think?
22:28:33 <Cale> emy: /msg chanserv help register
22:28:36 <emy> I'm using..online chat....
22:28:46 <Cale> luqui: That it had its own system of registration.
22:28:47 <shachaf> Cale: s/chan/nick/
22:28:50 <Saizan_>  /msg nickserv help register
22:28:57 <Cale> right
22:29:01 <emy> chanserv or nickserv?!
22:29:05 <Cale> nickserv
22:29:05 <Saizan_> nickserv
22:29:15 <ceal> nickserv
22:30:16 <mrsolo_>    #php is full
22:30:42 <shachaf> mrsolo_: ?
22:30:56 <ceal> can channels ever be full??
22:31:07 <mrsolo_> yea
22:31:14 <emy> how come my email says it's not a valid one?
22:31:27 <luqui> it has fewer people than #haskell
22:31:28 <ceal> emy: ??
22:31:39 <emy> I'm trying to register
22:31:44 <emy> it says my email is not valid...
22:31:59 <ceal> emy: maybe cos it isn't...
22:32:01 <Vq^> luqui: the channel operators can set a limit iirc
22:32:03 <emy>  I just type in /msg nickserv <pasS> <email>
22:32:13 <emy> right?!!
22:32:14 <ceal> emy: yeah that's it
22:32:18 <augur> #php is not full
22:32:25 <emy> I tried like all my email all sas not valid
22:32:27 <augur> there is no #php. there is, however, ##php which is not full at all.
22:32:33 <emy> and believe me I know what my freaking email is
22:32:37 <shachaf> emy: #help might be a more appropriate channel for these questions, by the way.
22:32:46 <emy> #help
22:32:49 <emy> oh wait
22:32:54 <ceal> emy: yeah shachaf is right
22:33:05 <luqui> going to #freenode may be more productive, emy
22:33:13 <luqui> that's where they talk about stuff like this
22:33:31 <emy> .......how did I join another room again
22:33:37 <shachaf> emy: You want /msg NickServ REGISTER <password> <email-address>
22:33:46 <ceal> emy: channel not room
22:34:07 <Saizan_> emy: /join #help
22:34:09 <emy> arrrrg same error
22:34:09 <luqui> that's what you get in a channel full of mathematicians... pedantry
22:34:22 <ceal> emy: try what shachaf sent you
22:34:32 <mrsolo> ah ya in php now.. damn nickserv protected channel
22:34:49 <ceal> emy: /msg NickServ REGISTER <pass> <email>
22:35:04 <emy> I tried T_T oh well
22:35:05 <luqui> without the angle brackets.  just plaintext...
22:35:08 <emy> thanks for ur help
22:35:12 <luqui> emy,
22:35:16 <luqui> try to join #freenode
22:35:25 <luqui> boo
22:35:46 <mrsolo>  boo? over his head
22:35:59 <Saizan_> now on #freenode :)
22:36:12 <Gracenotes> @src (>=>)
22:36:13 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
22:36:18 <Gracenotes> indeed it is sir lambdabot!
22:37:13 * wagle imagines a surlambdabot..
22:38:06 <Gracenotes> the :: surly type
22:41:01 <ceal> how do i compile a .hs file??
22:41:25 <dhun> ghc --mkae file.hs
22:41:30 <dhun> ghc --make file.hs
22:42:04 <ceal> is it possible from the prompt Prelude???
22:42:22 <dhun> not really I think
22:42:30 <ceal> ok
22:42:34 <dhun> you can load it I think
22:42:40 <shachaf> ceal: You can :load files from ghci, but not "compile" them as such.
22:42:51 <Saizan_> from ghci prompt you can run a command in a shell using the :! command
22:42:58 <Saizan_> like :! ghc --make file.hs
22:43:30 <ceal> how do i define main??
22:43:49 <ceal> i have a function defined double
22:44:06 <ceal> doubleMe actually
22:44:40 <Saizan_> a compiled program runs "main" that you just define like any other function, but it has to be of type IO a
22:44:56 <dirk_> main =putStrLn (show doubleMe 2 );
22:45:01 <dirk_> main =putStrLn (show doubleMe 2 )
22:45:06 <ceal> ok
22:45:07 <Gracenotes> this is a valid main function: main = print (anything that can be shown)
22:45:25 <ceal> what is the putStrLn function do??
22:45:26 <Gracenotes> numbers can be shown... so can lists, strings, etc.
22:45:33 <ceal> just redirecct the op to the screen??
22:45:52 <luqui> dirk_, that is passing 2 arguments to show, "doubleMe" and "2"
22:45:54 <Saizan_> dirk_: (show doubleMe 2) doesn't actually work
22:46:04 <dirk_> main =putStrLn (show (doubleMe 2) )
22:46:24 <ceal> what is the show??
22:46:25 <Gracenotes> ceal: putStrLn prints a String to the screen. It has to be specifically of type String -- a list of characters..
22:46:39 <ceal> like printf in C huh??
22:46:50 <luqui> ceal, show converts a value into a string representation of that value
22:46:55 <sjanssen> ceal: more like puts
22:47:21 <luqui> > show 42
22:47:23 <lambdabot>   "42"
22:47:48 <mrsolo>  well emy is in php now
22:47:52 <mrsolo> getting flamed
22:47:57 * luqui watches
22:48:01 <dirk_> > (show 23)++" nothing is as it seems"
22:48:02 <lambdabot>   "23 nothing is as it seems"
22:48:26 <wagle> main returns a value in the IO monad, which might seem odd if you are used to the ghci read-eval-print loop...
22:48:41 <Vq^> mrsolo: thats the reward i guess :)
22:49:30 <wagle> but there's a logic to it, that people here are giving you examples of
22:51:39 <ceal> in lyah, the tutorial shows the function doubleMe called from the prompt
22:51:45 <ceal> as doubleMe 9
22:51:56 <ceal> how does that happen??
22:52:06 <ceal> i get an error: not in scope
22:52:24 <Twey> You have to define it first
22:52:28 <Twey> let doubleMe = (*2)
22:53:03 <Saizan_> or define it in a .hs file and then :load it
22:53:18 <Saizan_> @where LYAH
22:53:18 <lambdabot> www.learnyouahaskell.com
22:54:29 <Saizan_> like the ":l baby" line there
22:54:42 <ceal> yeah
22:54:53 <ceal> was pasting the code...
22:55:02 <ceal> they just type it and then doubleME 9
22:55:09 <ceal> and the output is shown
22:55:15 <ceal> how does that work??
22:55:24 <ceal> i get an error: not within scope
22:55:47 <Cale> ceal: Was that a typo?
22:56:03 <Cale> ceal: Didn't you say it was doubleMe ?
22:56:13 <ceal> yeah sorry typo
22:56:15 <ceal> my bad
22:56:29 <ceal> didn't notice...
22:56:52 <ceal> so in the tutorial, they type :1 baby
22:57:12 <ceal> i think "one" and not the letter 'l'
22:57:32 <ceal> and then execute the function doubleMe 9
22:57:36 <ceal> and output 18?
22:57:46 <ceal> how do they get that??
22:57:55 <ceal> i get an error: scope issue
22:57:57 <Saizan_> that's the letter l
22:58:09 <Saizan_> if you used a one you should have gotten an error message.
22:58:27 <ceal> it looked more like 1; i did get an error...
22:58:39 <luqui> it's the letter
22:58:39 <ceal> so it's :l??
22:58:42 <ceal> ok
22:58:43 <luqui> for :load
22:58:48 <Saizan_> it's best to not ignore errors :)
22:59:08 <ceal> that's y i asked on how to "compile"
22:59:18 <ceal> still will keep that in mind about errors
23:00:12 <luqui> you can ignore invisibul errors
23:00:27 <Saizan_> pasting what you're trying to do together with the related error makes easier for us to help
23:00:42 <Saizan_> +it
23:00:54 <luqui> paste = hpaste.org, in case that hadn't come up
23:00:58 <luqui> don't paste directly in the channel
23:01:04 <ceal> that was what i was doing....
23:01:13 <Twey> Orhttp://moonpatio.com:8080/fastcgi/hpaste.fcgi/
23:01:18 <ceal> until :l baby was already stated
23:01:29 <ceal> yeah i was doing that....
23:02:58 <ceal> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2819#a2819
23:03:05 <Saizan_> ceal: btw, compiling and loading at the interpreter prompt are understood to be different things
23:03:07 <ceal> error make any sense??
23:03:20 <Saizan_> ceal: the first means producing a native executable
23:03:32 <ceal> and other is like in python right??
23:03:39 <kadoban> the online docs for Data.List say it exports "permutations", but ghci disagrees.  is it possible my libraries are out of date or something? i figured the base libraries were fairly static
23:03:51 <Saizan_> ceal: yeah
23:03:57 <ceal> ok
23:04:24 <ceal> i think i'll stick to compiling rather than intrepreting
23:04:52 <Saizan_> ceal: for that error i think you've to delete try.hi
23:05:01 <Saizan_> ceal: that ghc should have produced when compiling
23:05:12 <ceal> ok let me try that
23:05:34 <luqui> ceal, that will destroy your workflow.  edit, reload, test is a great cycle; learn and use well
23:05:56 <Saizan_> kadoban: permutations is quite recent, iirc
23:05:57 <mmorrow> kadoban: permutations appeared in Data.List in 6.10.*
23:06:08 <luqui> it means you can test your functions one at a time, making sure they work before composing them into your final program
23:06:11 <kadoban> ahh, that would do it.  thanks both
23:07:47 <mmorrow> kadoban: (if you want to snag it: http://www.haskell.org/ghc/dist/current/docs/libraries/base/src/Data-List.html#permutations)
23:08:22 <kadoban> i think i'll try to upgrade instead...been meaning to get the latest version for a while anyway. thanks though
23:08:34 <ceal> ok guess that is a good idea: using the intrepreter
23:08:59 <ceal> once a module is loaded how to do "unload" it??
23:09:34 <ceal> how do i got back to the original prompt from *Main>
23:09:53 <Twey> You don't, but you can load a new file
23:09:55 <hackagebot> hyena 0.1 - Simple web application server (JohanTibell)
23:09:57 <ceal> got it
23:09:58 <mmorrow> :set prompt "Prelude>"
23:09:58 <ceal> thanks
23:09:59 <mmorrow> ;)
23:10:06 <Twey> Haha
23:10:11 <ceal> :)
23:10:12 <mmorrow> hehe, mauke suggested:
23:10:17 <mmorrow> :set prompt "C:\>"
23:10:26 <ceal> thanks mmorrow
23:10:32 <ceal> hey is that a dos command??
23:10:38 <ceal> cos i am using terminal
23:10:39 <mmorrow> oh yesh
23:10:53 <ceal> linux that is....
23:11:11 <mmorrow> let DIR = System.Cmd.system "ls -l"
23:11:17 <mmorrow> oops
23:11:20 <mmorrow> let dIR = System.Cmd.system "ls -l"
23:11:27 <mmorrow> that ruins
23:11:28 <mmorrow> it
23:11:32 <dmwit> What's that wiki page that talks about all the things you need to make a Haskell package?  (darcs, ghc, cabal, quickcheck, ...)
23:11:43 <karlw> Is Wadler and Bird a good Haskell text?
23:11:44 <Twey> let dir = System.Cmd.system "ls -l"
23:11:52 <Twey> You could make a whole shell :-P
23:12:14 <dmwit> karlw: A lot of people liked RWH.
23:12:16 <dmwit> ?where RWH
23:12:16 <lambdabot> is http://www.realworldhaskell.org/blog/
23:12:43 <karlw> I'm a SICP refugee.
23:12:46 <mmorrow> Twey: let id' = System.Cmd.system "ghci" `seq` undefined
23:12:54 <dmwit> found it:
23:12:59 <dmwit> ?wiki how to write a haskell program
23:12:59 <lambdabot> http://www.haskell.org/haskellwiki/how_to_write_a_haskell_program
23:13:08 <Gracenotes> with more magic
23:13:14 <dmwit> With a capital Haskell. =P
23:13:22 <mmorrow> aww, doesn't work
23:14:26 <mmorrow> err, right of course that doesn't work
23:16:05 <ceal> since haskell doesn't have the variable concept, how can we store user input in case needed later on??
23:16:35 <dmwit> We can bind names to values, we just can't change those values.
23:16:37 <mmorrow> ceal: you take your state around with you
23:16:46 <dmwit> So, for user input, you bind a name to the value of the input.
23:17:30 <ceal> how??
23:17:52 <ceal> how do you bind a name to the value??
23:18:00 <ceal> and how do you get an input??
23:18:21 <Saizan_> e.g. do line <- getLine; putStrLn line
23:18:39 <ceal> ok
23:18:44 <dmwit> One question mark is enough to mark questions, by the way.
23:18:50 <Twey> That's an argument :-P
23:18:52 <luqui> lol
23:19:02 <ceal> sorry just used to the double ? that's all
23:19:22 <Twey> Why would one become used to something as weird as that?  o.@
23:19:35 <luqui> don't you think it makes your question sound more urgent??
23:19:43 <ceal> yes that's the point
23:19:49 <Twey> It's not like you get accustomed to it by reading it in books :-P
23:19:55 <dmwit> But those questions were not urgent.
23:19:58 <ceal> people around me just dont answer questions
23:20:03 <Twey> luqui: I rather think it sounds insane
23:20:19 <ceal> so when i text message them, they reply faster if i put the double ?
23:20:21 <Twey> As if the question were prefixed with âOMG!!  I'M ABOUT TO GO OUT OF MY MIND!!â
23:20:31 <ceal> that's how i got used to it
23:20:37 <Twey> ceal: IRC is not SMS :-P
23:20:53 <karlw> I'm a math undergraduate. I took a Scheme course with SICP and I'm familiar with basic abstract algebra concepts. Given this background, would anyone suggest a good text or good projects to improve my Haskell and FP?
23:21:07 <ceal> text meaning everything: IM, sms etc
23:21:17 <ceal> few other channels that's the only thing that works
23:21:23 <adu> karlw: TH
23:21:23 <ceal> most other channels
23:21:30 <Twey> (personally I'd just be tempted to ignore a message ending in ?? anyway)
23:21:49 <karlw> adu: What's TH?
23:21:49 <ceal> guys sorry will stick to one ? ok from now on
23:22:00 <adu> karlw: Template Haskell
23:22:12 <adu> it will blow your mind
23:22:46 <Saizan_> for one coming from scheme template haskell shouldn't be so enlighting
23:22:51 <Twey> Probablyâ yeah
23:22:52 <Twey> :)
23:23:03 <dmwit> karlw: Check out the Gentle Introduction if you don't know Haskell syntax or Haskell's class mechanism.
23:23:10 <dmwit> karlw: From there, Project Euler is a fun way to practice.
23:23:25 <adu> karlw: oh, ya, learn about types first
23:23:38 <dmwit> karlw: Building an interpreter for some small language (say, the lambda calculus, or scheme) is a fun and relatively easy thing to do, too.
23:23:50 <adu> karlw: after 10 years learning about types, then you can move on to type classes :)
23:23:54 <Twey> By âimproveâ I understand that karlw is already proficient with Haskell
23:24:27 <erikc> karlw: if you are interested in type theory, check out Types and Programming Languages, if you are interested in more SICP-type stuff, check out http://www.info.ucl.ac.be/~pvr/book.html
23:24:35 <dmwit> karlw: There are always more generalizations to wrap your head around in Haskell, too: monads, monad transformers, arrows, applicative functors, ...
23:24:47 <Twey> ... zygohistomorphic prepromorphisms...
23:24:54 <dmwit> =)
23:24:58 <hydo> product $ map (\y -> read y :: Int ) $ map (\z -> [z] ) x   Is there is a much more elegant way to combine the two maps?
23:24:58 <karlw> Yes, I'm looking for good exercises, basically.
23:25:49 <karlw> Type classes are just definitions of algebraic structures.
23:25:54 <Twey> hydo: product $ map (read . (:[])) x
23:26:07 <Twey> product $ map (read . return) x
23:26:29 <Twey> Assuming product :: [Int] -> a
23:26:33 <ceal> in haskell, the lists can store only similar datatypes just like arrays in C??
23:26:47 <ceal> sorry abt the double ?
23:26:53 <ceal> wont happen again
23:27:09 <Twey> Otherwise, product $ map ((read :: String -> Int) . return) x
23:27:16 <Saizan_> hydo: map digitToInt
23:27:19 <ceal> so lists can store similar datatype like arrays in C?
23:27:23 <Twey> Or possibly a where
23:27:30 <Twey> Oh, there's always that, too
23:27:41 <Twey> ceal: The can?
23:27:44 <Twey> They**
23:28:05 <Twey> Haskell lists are homogenous: all elements must be of the same type
23:28:10 <ceal> ok
23:28:15 <hydo> Thanks, Twey and Saizan_
23:28:28 <Twey> Heterogenous lists are available in the HList package, but you almost certainly don't need them.
23:28:48 <Twey> They're useful for implementing OO and some other weird stuff.
23:28:48 <ceal> twey: thanks for the info
23:28:56 <ceal> :)
23:29:08 <shachaf> ceal: However, they can store much more complex types than C arrays (for example, [Either Int Char]).
23:29:18 * Twey nods.
23:29:29 <karlw> I thought about writing DOCTOR in Haskell.
23:29:37 <ceal> shachaf: didn't get you
23:29:40 <Twey> Or even [Either (Maybe Int) Char]!
23:29:55 <Twey> Oh, you're not that far along yet
23:30:06 <Twey> They're type constructors, ceal
23:30:13 <ceal> oh
23:30:16 <ceal> what do they do??
23:30:22 <ceal> sorry what do they do?
23:30:24 <Twey> Kind of like... C++ templates or Java generics
23:30:36 <Twey> You can pass a type to be used in the implementation
23:30:50 <ceal> can you gimme an example?
23:30:55 <shachaf> @ty [Left (Just 'a'), Right (Right Nothing)]
23:30:56 <lambdabot> forall a a1. [Either (Maybe Char) (Either a1 (Maybe a))]
23:31:09 <Twey> data Tree a = Leaf a | Branch (Tree a) (Tree a)
23:31:36 <shachaf> ceal: Lists are an example for that matter.
23:31:37 <Twey> So, for example, a Tree Int will have Leaf Ints
23:31:49 <shachaf> (Though I suppose C does have pointers to pointers.)
23:31:51 <karlw> Does lambdabot have Djinn?
23:31:54 <Twey> But a Tree String will have Leaf Strings
23:31:58 <Twey> karlw: Yes
23:31:59 <ceal> ok
23:32:00 <Twey> @djinn
23:32:00 <lambdabot> Cannot parse command
23:32:27 <Twey> ceal: And data Either l r = Left l | Right r
23:33:17 <ceal> hmmm
23:33:30 <ceal> ok truth is it made no sense....
23:33:38 <Twey> Oh, and data Maybe a = Just a | Nothing :)
23:33:39 <karlw> @djinn f ? a -> a
23:33:40 <lambdabot> Cannot parse command
23:33:50 <ceal> except the for all a a1 code
23:34:08 <shachaf> @djinn a -> a
23:34:08 <lambdabot> f a = a
23:35:06 <karlw> @djinn (a -> b) -> a -> c
23:35:06 <lambdabot> -- f cannot be realized.
23:35:26 <shachaf> ceal: Well, does "data D = A" make sense?
23:35:41 <ceal> no
23:35:57 <shachaf> Maybe you should read about data then. :-)
23:36:01 <Kashyap> I was just reading Paul Graham's article "beating the averages" - I talks highly of macros - What's the equivalent in Haskell? ... higher order functions? .. is there a good article on this
23:36:10 <karlw> I agree with Wadler on SICP
23:36:13 <shachaf> Kashyap: Well, there's Template Haskell.
23:36:23 <shachaf> And there's Liskell for approximately an exact equivalent.
23:36:25 <ceal> shachaf: yeah i will check it out
23:36:28 <shachaf> (That didn't make much sense...)
23:36:52 <Cale> Kashyap: We tend not to use macros as heavily as the lisp folks. They're not *quite* as transparent to write, because Haskell's syntax is comparatively complicated.
23:36:56 <shachaf> Kashyap: But in general, there are things like laziness that replace many of the things macros do.
23:37:04 <Beelsebob> ceal: what are you trying to store in your list?
23:37:09 <shachaf> For instance, you can write if as a function.
23:37:09 <Kashyap> Thanks Shachaf ... I'll check out Template Haskell and Liskell
23:37:36 <Cale> and yeah, when we can, we tend to favour using laziness and runtime domain specific languages, over things which expand into code at compile time
23:37:37 <ceal> Beelsebob: learning how to use lists
23:37:48 <shachaf> if' True x y = x; if' False x y = y
23:38:11 <ceal> Beelsebob: just started
23:38:15 <ceal> on lists
23:38:21 <shachaf> This actually has an advantage over a LISP macro: Being a regular function, you can pass it as an argument to other functions.
23:38:25 <shachaf> Which you couldn't do with LISP.
23:38:52 <Cale> There are some things which you still can't do without macros -- particularly, defining new binding forms -- but for the simpler things plain functions usually do, because of laziness.
23:38:59 <karlw> Kashyap: Functions in Haskell are first class and you can use them like Lisp functions.
23:39:01 <Kashyap> cool, thats what I want to hear ... I mean, I'm still in the euphoria of Learning Haskell ....
23:39:02 <shachaf> > zipWith3 if' [True, False, True] "abc" "def"
23:39:04 <lambdabot>   "aec"
23:39:35 <Beelsebob> ceal: then for now I would accept that you can only store one type in your list, and temporarily think of it as a limitation, and when you learn about defining your own data types suddenly realise why it isn't :)
23:39:59 <ceal> ok
23:40:03 <ceal> that made sense
23:40:06 <Kashyap> sachaf - the zipWith example ... is that in the context of Mocros?
23:40:15 <ceal> is it possible to have 1 based indexing for the lists??
23:40:17 <shachaf> Well, in the context of lazy functions.
23:40:30 <ceal> sorry is it possible to have 1 based indexing for lists?
23:40:30 <shachaf> In LISP, you couldn't do that with if, because it would be either strict or a macro.
23:40:36 <karlw> Kashyap: Consider ``map (\x -> x * x) [1..10]'' and ``$ (\x -> x + 1) 3''
23:40:37 <Beelsebob> ceal: well, lists are just that -- linked lists, so indexing them is not so efficient
23:40:38 <mauke> ceal: sure, just define your own indexing operator
23:40:43 <Cale> Kashyap: It's an example of something which you can do with if' because it is a function which you could not do if it was a macro.
23:40:50 <mauke> ceal: but in general you don't index lists all that often
23:40:53 <Beelsebob> but... you can always define your own indexing operator
23:41:14 <Kashyap> okay .. got it
23:41:21 <ceal> ok just curious cos it's not possible in most others like C and C++
23:41:35 <mauke> ceal: it's perfectly possible in C and C++
23:41:40 <Cale> ceal: Lists don't really have indices.
23:41:58 <Cale> ceal: They're built up from (:) and [], and there are no actual numbers in their definition
23:42:00 <mauke> you just can't define your own operators in C, so it looks like a function
23:42:08 <Beelsebob> > let index1 1 (x:xs) = x; index1 n (x:xs) = index1 (n-1) xs; index1 _ _ = error "splode" in index1 5 [1,2,3,4,5,6,7,8]
23:42:09 <lambdabot>   5
23:42:11 <mauke> list_index(x, i)
23:42:15 <Cale> (in fact, indexing on lists is usually a bad idea, if it can be avoided)
23:42:27 <shachaf> Arrays don't have indices in C either. :-) As such.
23:42:32 <Cale> right
23:42:51 <mauke> but they look like they do
23:42:55 <Twey> Heh, weird
23:42:58 <Cale> (though one could claim that memory locations have numbers)
23:42:59 <ceal> ok so will keep it in mind not to define my own indexes
23:43:03 <ceal> :)
23:43:16 <karlw> Kashyap: err ``(\x -> x + 1) 3''
23:43:31 <Beelsebob> it's not so much that you shouldn't ceal -- it's that you're very unlikely to need to
23:43:37 <Twey> It actually makes more sense to index linked lists than it does to index arrays, yet arrays are more commonly (and efficiently) indexed
23:43:48 <Cale> ceal: If you can think of a way to phrase your algorithm so that it's not necessary to identify what the indices are, that's usually better.
23:44:00 <shachaf> Kashyap: It is somewhat amusing that he talks about "Blub" and LISP being at the "top", and yet here is something that you can't really do in LISP without reimplementing a big part of Haskell in it (take that, Greenspun!).
23:44:02 <Cale> (at least with lists)
23:44:32 <shachaf> Goes to show you that everyone thinks they're at the "practical" top. :-)
23:44:42 <Cale> Lisp 2's are so annoying to actually use.
23:45:01 <Twey> Heh
23:45:08 <Twey> I think he just proves his own article
23:45:22 <Twey> Cale: I like them
23:45:34 <Twey> In the same way I like C and DOS
23:45:41 <Cale> I can't stand having functions and other values in separate namespaces.
23:45:57 <Twey> In practice they seem a bit impractical, but having multiple working namespaces just feels so good.
23:46:14 <karlw> Common Lisp is okay, but can get annoying.
23:46:27 <Cale> It's like the language explicitly punishes functional programming.
23:46:31 <Twey> Hahaha
23:46:36 <Twey> I don't agree
23:46:48 <Twey> By putting functions in their own special namespace it promotes them
23:46:53 <shachaf> Twey: Does typing #' feel good?
23:46:58 <Twey> *Everything else* is a second-class citizen!
23:46:59 <Zao> > let x = repeat 42 in x !! (genericLength x - 1)
23:47:01 <lambdabot>   * Exception: stack overflow
23:47:09 <Twey> shachaf: A little :-P
23:47:10 <Zao> See, list indexing is harmful :P
23:47:25 <Twey> Zao: Haha :-P
23:47:27 <Cale> Twey: except in that case, functions should by default take only functions as parameters :)
23:47:38 <Zao> I wonder, would a clever compiler be able to optimize that to 42? :)
23:47:44 <Twey> It's a point you've got there
23:47:52 <Twey> Zao: I don't see why not
23:47:56 <monochrom> I am a clever compiler.
23:48:04 <Twey> It would have to be a pretty clever compiler, though.
23:48:04 <karlw> A simplified dialect of Haskell would work better than Scheme for an introductory course.
23:48:14 <Twey> I still like Scheme for teaching
23:48:29 <Twey> Not having to explain syntax has great benefits
23:48:33 <Cale> Has anyone looked at Clojure? I must say that it really is a good deal more interesting than it looked at first glance.
23:48:37 <Twey> Maybe Liskell :-P
23:48:46 <Twey> Cale: I've only got to the first-glance stage
23:48:54 <shachaf> @quote sufficiently.smart
23:48:54 <lambdabot> No quotes match. Are you on drugs?
23:48:55 <shachaf> Aw.
23:49:08 <Twey> Cale: What's interesting about it?
23:49:38 <karlw> Introductory courses don't have enough math.
23:49:55 * adu <3 math
23:50:03 <Cale> Well, it's fairly principled in terms of its treatment of mutable things -- perhaps not *quite* so principled as Haskell, but all its basic datastructures are immutable persistent structures like Haskell's.
23:50:15 <Cale> and it has a good story about concurrency
23:50:19 <Twey> Right
23:50:29 <Cale> (which results from that)
23:50:32 <Twey> But what does it have that Haskell doesn't?
23:50:56 <Cale> hmm :)
23:51:05 <erikc> it has Java as a platform
23:51:09 <Cale> Well, it runs on the JVM, yes.
23:51:16 <lament> that's really exciting....
23:51:19 <Twey> âIt's like Haskell, but not quite so good and it runs on the JVMâ is not a great selling point :-P
23:51:20 <lament> *yawn*
23:51:29 <erikc> what does F# have that Haskell doesnt? .NET
23:51:39 <Cale> Twey: it has good interactive dynamic reloading of code
23:51:41 <Zao> erikc: Abysmal syntax :P
23:51:45 * shachaf would be more inclined to look into Scala than Clojure if he had to use the JVM (at the moment).
23:51:48 <lament> erikc: workflows!!
23:51:48 <Twey> Cale: Oho!  That's interesting.
23:51:58 <karlw> I may use Haskell when I take numerical analysis.
23:52:01 <erikc> that is, tons of existing code (and platform interop) already coded and accessible without FFI hassles
23:52:13 <lament> shachaf: i lost interest in scala when i read it has for loops but no break :(
23:52:18 <Twey> erikc: That doesn't make it interesting
23:52:24 <Twey> Useful, yes; interesting, no :-P
23:52:36 <erikc> Twey: ok, agreed :)
23:52:44 <Twey> Also, the existing code you could access would all be imperative-style
23:52:54 <erikc> but it is a big commercial uptake bullet point
23:52:56 <Cale> Twey: It has a concurrency mechanism called agents, which we might want to try stealing.
23:52:59 <Twey> Aye
23:53:13 <Twey> Cale: That sounds kind of like actors
23:53:26 <Cale> Sounds like, but there are significant differences.
23:54:34 <Cale> Agents are mutable bits of state which rather than sending messages to them, you sent functions of that state to them, which are treated as asynchronous requests to update.
23:54:38 <karlw> Twey: Teach with typed lazy scheme with classes.
23:54:55 <Cale> Those are queued up, and applied as time permits.
23:55:12 <shachaf> karlw: Why not typed lazy lambda calculus? :-)
23:55:22 <shachaf> With a slightly Haskelly syntax?
23:55:25 <Cale> But the current value of the state is always accessible (it just might not reflect every function/action that's been sent)
23:56:04 <shachaf> lament: Scala 2.8 will have break, apparently.
23:56:28 <Cale> A thread can also decide to send a request and wait for it to complete if it wants, in order to synchronise, but that's less common.
23:56:37 <Twey> karlw: I prefer not to teach types
23:56:41 <karlw> Simplified Haskell syntax is probably better for freshmen than sexps.
23:56:44 <Twey> Or at least not until later
23:56:52 <Cale> (it still gets queued up, but the thread blocks until that request is answered)
23:57:04 <Twey> Types are useful for *real* work.  When learning theory, they're just a hurdle.
23:57:15 <Twey> (unless it's type theory, of course :-P)
23:57:21 <erikc> Cale: how is the accessible state synchronized with mutations?
23:57:44 <shachaf> You can write the Y combinator without types. :-)
23:58:02 <Twey> Sexps help the students to break the program down into a series of operations with arguments, and ensure that they'll think that way about other languages, too, in the future
23:58:04 <lament> shachaf: well... that only goes to show.
23:58:10 <Cale> erikc: By design it's asynchronous, though if one thread sends multiple requests to update, they will happen in the order that thread sent them.
23:58:21 <lament> shachaf: first they talk a lot about how useless break is and how they don't really need it anyway; then they add it.
23:58:24 <Cale> erikc: Though there's that waiting mechanism I just mentioned
23:58:51 <Cale> erikc: Where you can send a request which gets put in the queue, and then block until that request is handled.
23:59:27 <erikc> ah
23:59:32 <karlw> I guess Haskell syntax could be too algebra-like.
23:59:37 <shachaf> lament: Still looks, from my perspective, like an interesting language.
