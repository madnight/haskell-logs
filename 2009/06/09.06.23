00:00:12 <Reiver> Nnope, now that I fixed that error, back to the Eq error again.
00:00:23 <Reiver> Looks like I really do need to leave it untyped, for all the horrors that entails.
00:00:57 <soupdragon> Reiver: what horrors?
00:01:05 <Axman6> you've written the function type signature right?
00:01:31 <Axman6> if you havem commend it out, then reload the file in ghci, and run :type <funcname>
00:01:31 <Reiver> http://pastebin.com/d9330cdd - this si my latest attempt.
00:02:03 <Axman6> oh, you need to use l `elem` ls, not l elem ls
00:02:16 <Axman6> backticks are used to make a function infix
00:02:44 <Reiver> yep
00:02:52 <Reiver> And then I did that and got... the Eq errors. :P
00:03:04 <Axman6> and then you need to remove the type signature, or fix it
00:03:06 <dibblego> listadd :: (Eq a) => a -> [a] -> [a]
00:03:21 <dibblego> (removing the type signature does not make it untyped)
00:03:21 <Reiver> http://pastebin.com/d1f831151 Like so.
00:03:29 <Reiver> ... oh, I need to change the type signature?
00:03:33 <dibblego> yes
00:03:39 <Axman6> yes
00:03:44 <dibblego> or leave it absent so it is inferred
00:03:46 <Axman6> that's what we've been saying ;)
00:04:08 <Reiver> Oh. I thought that was saying that the thing was kabroken.
00:04:41 <Axman6> no, it means that your type signature is not correct
00:04:57 <Reiver> Ah.
00:05:03 <Reiver> What's the => do? I've not seen it before.
00:05:09 <dibblego> type-class constraint
00:05:52 <Axman6> that type says something like "for all types a that are instances of the Eq class, take an a, and a list of a's, and return a list of a's
00:05:59 <Axman6> @instances Eq
00:06:00 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), (a, b, c, d, e), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
00:06:18 <Axman6> hmm, that was more confusing than necessary :\
00:06:44 <Axman6> :t (==)
00:06:45 <lambdabot> forall a. (Eq a) => a -> a -> Bool
00:07:22 <Reiver> Huh. Good to know.
00:07:25 <Zao> > (42 == 42, "omg" == "wtf")
00:07:26 <lambdabot>   (True,False)
00:08:03 <Axman6> Reiver: what the type signature for (==) says is that it can take two things of the same type, and return a Bool, only if the a's implement the methods in the Eq class
00:08:08 <Cale> ClaudiusMaximus: http://en.wikipedia.org/wiki/Coxeter_group is somewhat inspiring, but it doesn't have a ready-made solution.
00:08:14 <Axman6> and those methods are == and /=
00:08:22 <Axman6> @src Num
00:08:23 <lambdabot> class  (Eq a, Show a) => Num a  where
00:08:23 <lambdabot>     (+), (-), (*)           :: a -> a -> a
00:08:23 <lambdabot>     negate, abs, signum     :: a -> a
00:08:23 <lambdabot>     fromInteger             :: Integer -> a
00:08:24 <Reiver> Aaah. Okay, that helps.
00:08:28 <Axman6> :t (+)
00:08:29 <lambdabot> forall a. (Num a) => a -> a -> a
00:08:44 <Reiver> Now I need to figure out how to make that thing do the rest of it, ho yez.
00:08:52 <Reiver> (Say, is lambdabot written in haskell?)
00:08:55 <Reiver> (Just curious.)
00:08:56 <Axman6> so, (+) takes two Nums, and returns a Num
00:09:01 <Axman6> it is indeed
00:09:09 <Axman6> you can install it from hackage if you want
00:09:31 * Reiver makes a note to look into it later, 'cuz he's been thinking about writing a new servicebot for the network he helps run.
00:09:50 <Reiver> (Oh sure, I'm sure I could get a readymade one, but it'd be a fun project.)
00:09:56 <Axman6> there's a tutorial on the wiki about writing an IRC bot. it
00:10:01 <Axman6> it's _really_ simple
00:10:44 <Axman6> http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
00:10:45 <Reiver> Given my experiences in trying to implement a parser for TINY, I'd believe it - pretty straightforward.
00:11:06 <Reiver> (Well, until I ran into problems with my freakin' memory handler, but that's because my brain is falling apart at the sight of the code at the moment)
00:11:42 <Axman6> memory handler?
00:11:49 <Axman6> i take it this wasn't haskell...
00:12:14 <Cale> ClaudiusMaximus: If you were only interested in the *number* of elements then just figuring out a way to classify would be good enough. :)  It also tells you the (somewhat intuitive) fact that the group is completely determined by the order of the product of each pair of generating reflections.
00:13:12 <m3ga> @seen arjanoosting
00:13:12 <lambdabot> arjanoosting is in #haskell.dut and #haskell. I don't know when arjanoosting last spoke.
00:15:02 <ClaudiusMaximus> Cale: i did some further hacking, it takes about 20 seconds to generate the 1998 elements for an 999-gon
00:15:32 <ClaudiusMaximus> Cale: code is basically this, now:
00:15:34 <ClaudiusMaximus> closure gs = closure' gs gs gs
00:15:34 <ClaudiusMaximus> closure' gs ms ns = let new = (deleteFirstsBy (~=~) . nubBy (~=~) . liftM2 (^^*^^) gs $ ns) ms in if null new then ms else closure' gs (ms ++ new) new
00:15:36 <Cale> oh, only 2 dimensions? :)
00:16:01 <ClaudiusMaximus> Cale: so far, start small
00:17:25 <Cale> Well, in 2D, you'll always have a dihedral group... you just have to determine what the angle is and you're set :)
00:19:58 <Cale> ClaudiusMaximus: Do you have redundancy in your initial set of reflections? How are you representing these things? :)
00:21:00 <ivanm> can someone @flush lambdabot if they haven't already?  I just got the same @messages I did yesterday :s
00:22:01 <Cale> @flush
00:22:13 <Cale> ivanm: Sometimes that happens if it crashes and comes back
00:22:36 <ivanm> Cale: yeah, it's happened to me before
00:22:44 <ivanm> I once had the same messages 3 or 4 days in a row :s
00:22:58 <ivanm> Cale: is there any way of knowing who/what crashed lambdabot?
00:23:26 <Cale> Sometimes, though it's usually mysterious. :)
00:24:18 <ivanm> heh
00:24:33 <ivanm> on another matter, is this iPwn of ryant5000's for real?
00:24:41 <ivanm> it just sounds like s stupid name, that's all...
00:25:07 <ivanm> *a
00:29:43 <ClaudiusMaximus> Cale: no redundancy - i'm generating the initial set of reflections from a description of the shape (eg: cube would be (4,3) ), represented as square matrices
00:33:16 <Cale> ClaudiusMaximus: So 4 edges per face, three faces at a vertex?
00:33:35 <cjs> I'm constantly doing stuff like do { x <- runBlah ; case x of ... }. Is there any way to get rid of the x?
00:33:51 <Cale> cjs: Not really...
00:33:56 <Cale> cjs: In special cases, you can.
00:34:04 <cjs> What sort of special cases?
00:34:31 <Cale> Like, if it's maybe, then you can just use maybe and >>=
00:34:40 <cjs> I feel as if I must not be doing something quite right, actually, given how often I do this....
00:34:45 <Cale> You need a function which does that case selection
00:34:46 <ivanm> or an fmap or something
00:34:52 * ivanm doesn't like case statements either
00:34:59 <Cale> But it's not something I consider wrong or a problem :)
00:35:02 <cjs> Ah, yes, It's actually an Either.
00:35:37 <Cale> There's  runBlah >>= either (\leftVal -> ...) (\rightVal -> ...)
00:35:54 <ClaudiusMaximus> Cale: yep
00:35:55 <Cale> But I'm not sure that that's any clearer
00:36:05 <cjs> Hm. No, not really.
00:36:16 <cjs> At least not in my particular case.
00:36:46 <Cale> It does eliminate the extra variable, but at the cost of not having as pretty syntax for the case selection
00:51:57 <ivanm> yay, the new haskell-src-exts has buildable haddock docs! \o/
00:52:42 <hackagebot> llvm 0.6.7.0 - Bindings to the LLVM compiler toolkit. (LennartAugustsson)
01:08:46 <vininim> TestSVD: out of memory (requested 22035824640 bytes)
01:08:48 <vininim> lol
01:12:51 <philipp_> why does cabal link both binaries specified in *.cabal against libML64i3 although only one of them depends on it? (requrires mathlink) http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6179#a6179
01:31:44 <nainaide> If I defined a mail address type, should I define its form  explicitly in "data" or just define a string, and use another function to check if it is in right form?
01:33:34 <quicksilver> defining as much as you can in 'data' is generally nice
01:33:35 <Cale> Depends on how much you want ensured at compile time. It might be convenient to know the user name separately from the domain.
01:33:47 <quicksilver> get the type system to do as much work as you (usefully) can.
01:34:43 <Alpounet> I'd do something like : data MailAddress = MailAddress { name :: String , host :: String, country :: String } or without record stuffs, and then you'd write a function taking a String like "foo@bar.com" and then parse it to get separately the name, the host and the country... of course this function would check if the mail address is valid.
01:37:14 <nainaide> understand, thank you.
01:37:51 <nainaide> quicksilver, defining as much as you can in 'data' is generally nice?
01:38:07 <quicksilver> nainaide: I mean, give as much structure as you can in the type
01:38:14 <quicksilver> within the limits of what is practical.
01:38:27 <quicksilver> You probably don't want to list all possible top level domains in a type, for example
01:38:35 <quicksilver> that's hard work for little payoff
01:38:44 <nainaide> so quicksilver agree Alpounet's advice?
01:38:44 <quicksilver> but certainly separating local-part from domain seems worth it.
01:38:56 <quicksilver> I don't think I'd separate country.
01:39:02 <quicksilver> "com" isn't a country.
01:39:07 <Alpounet> quicksilver, yeah, this one is optional
01:39:12 <quicksilver> but broadly yes.
01:39:35 <Alpounet> but separating what's before "@" and what's after is pretty good.
01:40:06 <nainaide> I agree
02:10:47 <plumenator> How do you generate a divBy4 function from a divBy2 function using partial application?
02:11:03 <plumenator> let divby2 = (/2)
02:11:07 <Botje> use the compose operator?
02:11:23 <plumenator> I am not familiar with it.
02:11:29 <Botje> :t (.)
02:11:30 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
02:11:41 <Botje> f . g = \x -> f (g x)
02:12:37 <plumenator> Botje: so isn't there a simple way like leaving out the formal arguments? :-)
02:12:47 <nlogax> yes, by using that
02:12:59 <ivanm> divBy2 . divBy2
02:13:11 <ivanm> @pl divBy2 . divBy2
02:13:12 <lambdabot> divBy2 . divBy2
02:13:18 <plumenator> I meant like (/2)
02:13:19 * Reiver ponders
02:13:22 <ivanm> dammit, I thought it would ap them or something
02:13:31 <ivanm> plumenator: (/2) . (/2)
02:13:37 <ivanm> @type (/2) . (/2)
02:13:38 <lambdabot> forall a. (Fractional a) => a -> a
02:13:46 <ivanm> > (/2) . (/2) $ 28
02:13:47 <lambdabot>   7.0
02:13:56 <ivanm> or just use (/4)
02:14:02 <ivanm> which IMHO makes more sense...
02:14:39 <plumenator> I thought this would work: divBy4 = (/2) (/2)
02:14:47 <Reiver> Is there a way to get a function to set variables without input?
02:14:54 <ivanm> plumenator: no
02:14:56 * Reiver , er, will explain better he thinks.
02:14:58 <ivanm> @type (/2) (/2)
02:14:59 <lambdabot> forall a. (Fractional (a -> a), Fractional a) => a -> a
02:15:14 <ivanm> plumenator: yours divides (/2) by 2
02:15:19 <ivanm> which really doesn't make sense
02:15:28 <Zao> Functions from a to a are quite much not Fractional.
02:15:38 <Zao> Unless someone invents an instance for that :)
02:15:55 <Reiver> I have a datatype called memory, it stores the memory for a parser: type Memory = ([Ide],Ide -> MemVal)
02:16:09 <plumenator> ivanm: wht does Fractional (a->a) mean? Does it mean ANYTHING?
02:16:14 <ivanm> Zao: you can do so
02:16:24 <Reiver> I then have a function that I want to be able to use to initialise that type to being ([],Unbound).
02:16:36 <ivanm> cnum or something?
02:16:51 <Reiver> My current attempt was 'emptyMem ([stack],ide) = ([],Unbound)', but this means it demands a pair of arguements to run. Oops.
02:16:52 <ivanm> plumenator: it means that there's a function a -> a that is an instance of fractional
02:16:56 <Botje> plumenator: no, that applies the function (/2) to the argument (/2)
02:17:10 <ivanm> Botje: as I said ;-)
02:17:13 <Reiver> Is there a better way to do zis?
02:17:16 <Botje> so you did, sorry :)
02:17:34 <plumenator> ivanm: Okay, so ghc is just playing dumb then. :-)
02:17:40 <ivanm> no it's not
02:17:43 <ivanm> _you_ are ;-)
02:17:50 <doserj> Reiver: what's wrong with emptyMem = ([],Unbound)?
02:17:51 <plumenator> hehe
02:18:04 <Reiver> doserj: It gives a type error.
02:18:27 <doserj> Reiver: then you are using it wrong
02:18:41 <Reiver> I so very am, yes. :)
02:18:49 <Reiver> The error in question, which I'm still deciphering: http://pastebin.com/d69f36af0
02:18:51 <Nereid_> what is Unbound?
02:19:12 <Reiver> A text string, but one that's recognised elsewhere.
02:19:29 <ivanm> what produced that error? hugs?
02:19:37 <Reiver> aye
02:19:52 <ivanm> then I have no idea what it means ;-)
02:20:11 <Reiver> Okie dokie. :)
02:20:17 * Reiver will plug away at it till it makes sense.
02:21:01 <doserj> Reiver: that error msg is with emptyMem (_,_) = ([],Unbound), right?
02:21:15 <Reiver> Right
02:21:39 <Reiver> (This is a parser for TINY, if that helps [Which I doubt~])
02:21:40 <Zao> What odd toolchain is that error from? Hugs?
02:21:51 <doserj> Reiver: what is the msg with emptyMem = ([],Unbound)? in particular, what is the type of Unbound?
02:21:54 <Reiver> Zao: I'm using hugs
02:22:04 <Nereid_> Unbound is a string, apparently
02:22:18 <Nereid_> and it needs to be an Ide -> MemVal
02:22:30 <Nereid_> Ide is just [Char] right?
02:22:40 <Reiver> yep
02:22:53 <Nereid_> and Unbound is an Ide
02:23:00 <Nereid_> there's your problem
02:23:06 <Reiver> Uhuh
02:23:41 <Nereid_> the type of ([], Unbound) might be ([Ide], Ide), whereas you're trying to put that in an ([Ide], Ide -> MemVal)
02:23:49 <Nereid_> thus the explosion
02:26:33 <Nereid_> bye
02:27:09 <Nereid_> er sorry, it's even worse
02:27:46 <Nereid_> you're trying to fit an ([Ide], Ide) -> ([Ide], Ide) into a ([Ide], Ide -> MemVal)
02:27:54 <Nereid_> it seems
02:28:25 <Nereid_> er
02:28:27 <Nereid_> sorry
02:28:32 <Nereid_> I keep screwing it up
02:28:34 <Nereid_> so I'm leaving :)
02:31:12 <Nereid_> @pl \x -> (x / 2) / 2
02:31:13 <lambdabot> (/ 2) . (/ 2)
02:32:20 * Reiver laughs
02:32:27 <Reiver> Nereid: Thanks for the, uh, attempt anyhow
02:35:10 <hydo> Reiver:  That's more than an attempt... it actually works.  or am I missing something fundamental and thus should have kept my mouth shut??
02:35:14 <hydo> s/??/?
02:36:55 <Reiver> hydo: Nerid is accurate in the statement. Hrn.
02:36:57 <Reiver> Sec
02:37:32 <hydo> Reiver: Ack!  Disregard... I should have scrolled up.
02:37:39 <hydo> or shaddap... one or the other.
02:37:47 <hydo> Probably both.
02:38:08 <Reiver> Please don't. :)
02:38:18 <Reiver> http://pastebin.com/d3af06dc - this is what I'm working on, anyway, with the types in question highlighted.
02:38:33 <Reiver> (EmptyMem is on 129)
02:38:34 <themroc> is it possible to specifically control the behavior of Show in an own type?
02:38:54 <themroc> like i need integer values and one integer value should return the string "+Inf"
02:39:04 <dibblego> themroc, yes, instance Show YourType where ...
02:39:13 <themroc> ahh
02:39:57 <themroc> where do i put this=
02:40:44 <themroc> my type looks lke this now: "type Distance = Int"
02:40:55 <ivanm> then you can't make a custom instance
02:41:15 <ivanm> you can only make instances for data and newtype declarations
02:41:51 <themroc> so for type its not possible?
02:42:03 <ivanm> no
02:42:07 <ivanm> since it's just an alias
02:42:25 <themroc> hmmm i guess we are bound to use type
02:42:45 <themroc> im quite stuck in this and dont know where to look really
02:42:55 <dibblego> newtype Distance = D Int
02:43:36 <themroc> so maybe i should just use newtype then
02:43:44 <doserj> Reiver: maybe 'emptMem = ([],const Unbound)' helps
02:44:53 <Reiver> ... hm
02:46:49 <Botje> themroc: there's a language extension to allow instances for type aliases
02:47:01 <Botje> but i doubt that's what your teacher wants you to use :)
02:47:06 <themroc> yeah right
02:47:10 <EvilTerran> Botje, but they overlap with instances for the aliased type, too
02:47:10 <themroc> im just quite confused
02:47:21 <themroc> we have to define a type which gives a distance between nodes
02:47:23 <quicksilver> themroc: overloading show in this way is a bad idea anyway.
02:47:25 <themroc> and it should behave like this:
02:47:38 <quicksilver> but it's not impossible that it's what your teacher wants you to do.
02:47:41 <themroc> Main> initialD graph 1
02:47:41 <themroc> [(1,0),(2,+inf),(3,+inf),(4,+inf),(5,+inf),(6,+inf)]
02:47:53 <themroc> the 2nd of the tuple represents Distance
02:47:56 <themroc> which can be number
02:47:57 <themroc> or +inf
02:48:07 <themroc> but i dont understand ... strings must be in "" right?
02:48:21 <EvilTerran> yes
02:48:21 <quicksilver> strings must be in "" but that's not a string.
02:48:28 <quicksilver> it's your custom type.
02:48:48 <themroc> hell EvilTerran :p
02:48:52 <zebrafinch> Is anyone familiar with the inf-haskell Emacs mode?  For some reason it's sending ":cd ~/.cabal/" before each :load, which makes it not find local modules.
02:48:55 <themroc> hello*
02:48:59 <EvilTerran> hi
02:49:25 <ivanm> zebrafinch: there's a bug in the latest stable version
02:49:26 <themroc> ive been sneaking into type declaration all over yesterday but couldnt find any information which suits that problem
02:49:30 <quicksilver> zebrafinch: it's an annoying bug. YOu can either turn off the behaviour
02:49:38 <ivanm> zebrafinch: (setq inferior-haskell-find-project-root nil)
02:49:44 <quicksilver> zebrafinch: or you can work around it by touchign a file called "myproj.cabal"
02:49:49 <themroc> i would have defined a type with 2 fields, one integer and one boolean which tells if its infinity or not
02:50:03 <EvilTerran> themroc, you can do better than that
02:50:04 <themroc> but that +inf screwes this i guess
02:50:07 <EvilTerran> Maybe Int?
02:50:20 <EvilTerran> ?src Maybe
02:50:20 <lambdabot> data Maybe a = Nothing | Just a
02:50:44 <koeien> i would define my own type
02:50:50 <koeien> instead of using Maybe
02:50:55 <EvilTerran> yeah, i would too, thinking about it
02:50:58 <themroc> "type Distance = Int" is my first approach
02:51:28 <quicksilver> we went through this with themroc yesterday.
02:51:31 <quicksilver> we had exactly this discussion.
02:51:51 <themroc> and ive been looking thru tutorials for some hours yesterday :(
02:51:53 <EvilTerran> data Distance = Int Int | PlusInf deriving (Eq, Ord) -- would give you "Int 23 :: Distance" and "PlusInf :: Distance", with Int x < PlusInf for all x
02:52:08 <quicksilver> We talked about Maybe Int, we talked about (Int,Bool) and we talked about data IntWithInf = JustAnInt Int | PlusInf
02:52:28 <quicksilver> themroc: so, after we talked about the three options yesterday, and discussed their pros and cons, where does that leave you?
02:52:28 <zebrafinch> ivanm, quicksilver: thanks, working now :)
02:52:34 <ivanm> no worries
02:53:07 <quicksilver> themroc: which actual part is giving you trouble right now? Which solution did you adopt so far?
02:53:16 <themroc> quicksilver: sorry for my noobstyle, the thing i dont understand was the +Inf without "", i thought that show gives always strings in "" back
02:53:54 <themroc> i thought that even an own type has to fit into existing conventions
02:54:17 <quicksilver> themroc: well, it does ;)
02:54:18 <themroc> which is int, real, bool, char/String
02:54:23 <quicksilver> and the convention is that "" denotes a string
02:54:29 <quicksilver> since your new type is *not* a string
02:54:34 <quicksilver> then it follows that convention
02:54:40 <quicksilver> by not using "" ;)
02:55:12 <themroc> so i can define a type without problem which can have the value of [0,1..] and Inf+ ?
02:55:34 <quicksilver> themroc: data IntWithInf = JustANormalInt Int | PlusInfinity
02:55:37 <quicksilver> for example.
02:55:59 <quicksilver> you can't use the exact form Int+ because that's not haskell syntax
02:56:16 <quicksilver> haskell constructors are either all symbol chars, or all alphanumeric, never a mixture.
02:56:18 <themroc> i also thought that + is haskell syntax
02:56:31 <themroc> and means add automatically
02:56:47 <quicksilver> + on its own is a standard function, yes
02:56:55 <quicksilver> (not quite the same thing as syntax, though)
02:57:16 <xenoblitz> Hi people I was using gtk2hs some time ago when it was still 0.9.x and now recently updated to the latest version 0.10.1 (with ghc 6.10.3) ... whilst recompiling a program I wrote using the new version I am getting errors that the Event data type cannot be found... does anyone know what happened to it as I can't find any info online about it :S
02:57:33 <themroc> ok
02:57:46 <themroc> and JustANormalInt and PlusInfinity are the states of the type?
02:58:03 <themroc> or of the data
02:58:32 <themroc> ( i really dont want to let you do my homework, i do pretty well but that little detail screwes my head)
02:58:33 <xenoblitz> themroc: they are what are called type constructors... they create your data type (IntWithInf)
02:59:29 <themroc> ok let me read the manaul for data first then
02:59:37 <xenoblitz> PS: I am basically asking... what happened to Graphics.UI.Gtk.Event?
02:59:58 <Lemmih> xenoblitz: Ask dcoutts.
03:00:25 <quicksilver> themroc: they're called constructors, but states of the type is a good way to think of it.
03:00:59 <xenoblitz> Lemmih: will do thanks :)
03:04:56 <themroc> quicksilver:
03:05:03 <themroc> [11:55:57] <quicksilver> you can't use the exact form Int+ because that's not haskell syntax
03:05:14 <themroc> so +Inf is not possible?
03:06:18 <quicksilver> not as haskell syntax, no.
03:06:28 <quicksilver> Constructors must either be alphanumeric, or symbolic, never a mixture.
03:06:35 <quicksilver> if they're symbolic, the first char must be :
03:06:44 <quicksilver> if they're alphanumeric, the first char must be capital.
03:07:18 <themroc> so this doesnt work at all:
03:07:18 <themroc> Main> initialD graph 1
03:07:19 <themroc> [(1,0),(2,+inf),(3,+inf),(4,+inf),(5,+inf),(6,+inf)]
03:07:28 <quicksilver> it works, but it requires a "bad" Show instance.
03:07:46 <quicksilver> That is, it requires a Show instance which doesn't produce haskell syntax.
03:07:58 <quicksilver> You can do that if you like, and perhaps that's what your teacher wants you to do.
03:08:02 <themroc> so i guess im bound on a bad show instance
03:08:02 <quicksilver> but it's bad practice.
03:08:36 <quicksilver> "Show" is intended (a) to produce code readable by Read and (b) to produce code which can be copy/pasted into a haskell program.
03:08:48 <quicksilver> some people think (a) is enough but myself I think (b) is important too.
03:09:33 <themroc> ic
03:14:08 <themroc> would data Either be helpful in any way?
03:14:10 <Baughn> quicksilver: Well.. it might be interesting to make haskell syntax extendable using Read instances
03:14:26 <Baughn> themroc: I got here a bit late. For what, exactly?
03:14:51 <themroc> pm
03:15:50 <quicksilver> themroc: sure. You could use Either instead of the custom type I showed.
03:15:56 <quicksilver> But there is no good reason to do so.
03:16:12 <quicksilver> instead of data IntWithInf = JustAnInt Int | PlusInf
03:16:16 <quicksilver> you can use Either Int ()
03:16:25 <quicksilver> [ where () stands for plus infinity ]
03:16:29 <quicksilver> or you can use Maybe Int
03:16:37 <quicksilver> [ where Nothign stands for plus infinity ]
03:16:52 <quicksilver> but I see no reason to prefer either of those choices to defining a custom type.
03:17:09 <quicksilver> In particularly, you wont' be able to define a Show instance for them which seems to be one of your key requirements.
03:18:06 <themroc> ok
03:19:02 <Nereid_> using Maybe Int might make sense semantically though; if two nodes are connected by a path of length n, then the distance is Just n; otherwise, if there's no path, then it's Nothing
03:19:06 <Baughn> themroc: I see I and mercury have the same exact solution.
03:19:07 <Nereid_> (I'm making some assumptions)
03:19:17 <Baughn> themroc: ..you probably want to listen
03:19:30 <themroc> im listening
03:19:30 <Baughn> Nereid_: Welll, it's isomorphic, but Maybe already has a Show instance
03:19:57 <Baughn> Since it's supposed to specifically print +inf, not Nothing, it needs to be a new instance
03:19:58 <Nereid_> if you really need your own Show instance then you have no choice but to define a new type though
03:20:05 <Baughn> Right
03:20:22 <Baughn> What you /could/ do is newtype Maybe
03:20:40 <Baughn> Then you'd get the Functor, Applicative and Monad instance for free
03:20:54 <Baughn> Hmm. Though I'm not sure how much sense they'd make..
03:20:56 <quicksilver> the main reason to reuse a type as opposed to defining a new one is to reuse the things already defined over it.
03:21:03 <Baughn> +inf does have a mathematical meaning, where Nothing doesn't
03:21:08 <quicksilver> I doubt those apply here, although you never know.
03:21:16 <quicksilver> Baughn: liftA2 (+) does kind of the right thing
03:21:20 <quicksilver> almost by mistake ;)
03:21:37 <Baughn> quicksilver: Yes, so I see. ^^;
03:21:42 <themroc> btw im overwhelmed by all your help
03:21:44 <quicksilver> whether liftA2 (-) is the right thing, though, depends what you think you want.
03:21:44 <themroc> thx #haskell
03:21:56 <Baughn> quicksilver: liftA2 (-) is not the right thing, even without negative infinity
03:21:58 <Nereid_> however, if you use Maybe
03:22:01 <Nereid_> you'll get the wrong ordering
03:22:05 <Baughn> inf - inf is NaN, not inf
03:22:10 <Nereid_> (since Nothing < Just x for all x)
03:22:24 <themroc> i have only one function which takes the type as parameter and calculates with it
03:23:13 <Baughn> "#haskell: Where a simple question about graphs leads into a philosophical discussion on the nature of math"
03:23:27 <quicksilver> Baughn: no, it depends what you think you want.
03:23:49 <quicksilver> Baughn: if these are path lengths, then subtracting two path lengths, where one doesn't exist, Nothing is the best answer.
03:24:00 <Nereid_> is it?
03:24:08 <ivanm> Baughn: there was a question on graphs?
03:24:11 <quicksilver> ok, I'll weaken that.
03:24:14 <Baughn> ivanm: Yes
03:24:14 <quicksilver> It might be a sensible answer.
03:24:17 * ivanm missed that...
03:24:31 <Baughn> ivanm: Sort of. It was buried, but the homework question was about graphs, originally.
03:24:50 <Nereid_> what does subtracting path lengths even mean, in terms of graphs
03:24:50 <Nereid_> :p
03:24:52 <ivanm> ahhh, k
03:25:15 <themroc> so the prefered way to solve this would be newtype Maybe?
03:25:25 <Nereid_> I don't think so
03:25:40 <Nereid_> you get the wrong ordering on it if you do that
03:25:41 <Baughn> Nereid_: Hm. It only makes sense when the shorter path is actually the same path (just part of it) as the longer one..?
03:25:55 <Baughn> themroc: No, I don't think so. Too much confusion.
03:25:58 <Baughn> themroc: Write a new type.
03:26:49 <Baughn> Nereid_: Well, subtracting /lengths/ always makes sense, but it's a question of /why/ you're doing that
03:26:53 <themroc> a new type isnt newtype i guess then
03:27:05 <Baughn> themroc: Can be. But in this case I mean an ADT, so data.
03:27:12 <themroc> ok
03:27:30 <quicksilver> Nereid_: if there is a shortest path from A to B of length n, and a shortest path from A to C of length m, then there cannot be a path from B to C of length less than |m-n|
03:27:30 <Nereid_> <quicksilver> whether liftA2 (-) is the right thing, though, depends what you think you want. <- I think it is the right thing; a subtraction involving infinity wouldn't make sense if it resulted in a finite number
03:27:38 <Nereid_> thus, the only alternative is infinity
03:27:44 <quicksilver> Nereid_: subtracting path lengths can indeed make sense.
03:28:06 <Baughn> themroc: newtype creates a type wrapping an existing type, but it doesn't allow the new type to carry more information than the original one
03:28:20 <themroc> ic Baughn
03:28:25 <Nereid_> themroc: so use a Data
03:28:27 <Baughn> themroc: You want it to carry more information, specifically a "+inf" case, so newtype can't be it
03:28:29 <themroc> ok
03:28:49 <Baughn> themroc: 'data AddInf a = NotInf a | Inf" or so
03:28:53 <Dae> what was the reason for not using Maybe for this again?
03:28:55 <Baughn> See what I did there?
03:29:10 <Baughn> Dae: Needs custom Show instance. Also, other instances for Maybe are also wrong.
03:29:15 <Baughn> Dae: This is basically a numeric type
03:29:16 <Nereid_> Dae: confusing, no custom show instance, and ordering is wrong
03:29:28 <Dae> I see
03:30:24 <Baughn> themroc: Then you'll want to instance Num, Ord, Bounded, Eq, etc.
03:30:42 <themroc> makes sense
03:30:58 <Nereid_> Baughn: he'd want negative infinity before instancing Num
03:30:59 <Baughn> themroc: Most of those can be derived. Of course, that requires constraints that the "a" in the data statement is actually of those classes too
03:31:03 <EvilTerran> Baughn, Bounded?
03:31:06 <Baughn> Nereid_: undefined is handy
03:31:10 <Nereid_> EvilTerran: by infinity
03:31:18 <Nereid_> Baughn: or that
03:31:19 <Baughn> minBound = undefined
03:31:25 <EvilTerran> at oune end, yes
03:31:29 <Baughn> Well, minBound = minBound :: a
03:31:43 <EvilTerran> ah, of course
03:31:47 <Baughn> ...minBound = NotInf minBound
03:31:59 <themroc> puh i see i still have to learn alot about haskell
03:32:07 <themroc> i dont really understand half of what youre saying :p
03:32:09 <EvilTerran> Ord and Eq can be derived
03:32:23 <Baughn> In this case, the Ord deriver does the Right Thing
03:32:34 <EvilTerran> you'd have to write Num manually to cover the semantics of Inf
03:32:37 <Dae> It's Haskell, there's always more to learn
03:32:40 <Baughn> It depends on the order of clauses in the data statement, so.. Inf after NotInf, NegInf before it. :)
03:32:43 <quicksilver> themroc: they are talking around your question in more detail than is necessary to actually do what you're trying to do ;)
03:32:57 <themroc> i try to follow :)
03:33:05 <themroc> data Distance = NormalInt Int | Inf
03:33:05 <themroc> 	deriving (Ord, Eq)
03:33:05 <Baughn> themroc: Oh yeah. Constraints..
03:33:13 <themroc> that compiles fine so far :p
03:33:19 <Baughn> themroc: instance Num a => Num (AddInf a) where ...
03:33:31 <Baughn> themroc: And so on for others that can't be derived
03:33:38 <EvilTerran> or "instance Num Distance where ..." in this case
03:33:52 <Baughn> Or where the derivation does the wrong thing. You can derive Show, but that doesn't give you the exact syntax you want.
03:34:25 <Baughn> EvilTerran: True. Personally, I'd prefer to have type Distance = AddInf Integer or some such.
03:34:35 <hackagebot> Stream 0.3.2 - A library for manipulating infinite lists. (WouterSwierstra)
03:35:11 <Dae> randombot is random?
03:35:38 <Baughn> randombot would be. hackagebot serves the latest news.
03:35:52 <xenoblitz> people I can't seem to contact dcoutts... does anyone here have any idea how Graphics.Ui.Gtk.Event was replaced so I can re-write my code accordingly?
03:35:57 <Dae> ohh, nice
03:38:09 <xenoblitz> why is it that I only hear crickets chirping? :P
03:38:11 <boml> Hi, I want to take the minimum of a list of pairs (x,y). Per default the x has priority when comparing. How can I flip that behaviour so that y is the most significant member. The solution I have now is: flipPair $ minimum (map flipPair x)
03:38:13 <EvilTerran> ?hackage
03:38:14 <lambdabot> http://hackage.haskell.org
03:38:35 <EvilTerran> Dae, hackagebot announces uploads to hackage ^
03:38:50 <boml> maybe clearer: flipPair $ minimum (map flipPair xs)
03:39:06 <EvilTerran> boml, that's fine, you can also use minimumBy
03:39:15 <Baughn> boml: You can't, as such. You could define your own Pair type with flipped polarity.
03:39:18 <Dae> EvilTerran: yeah, figured from Baughn's comment. Just don't remember it doing that last time I was here
03:39:38 <EvilTerran> minimumBy (comparing `on` snd) would compare only the second element
03:39:55 <EvilTerran> er, "compare `on` snd" or "comparing snd", rather
03:40:03 <Nereid_> comparing flipPair
03:40:23 <EvilTerran> and writing flipPair instead of snd would get you the behaviour you've got now
03:40:29 <boml> EvilTerran: I need to be able to sort (2,3) and (1,3)
03:41:29 <boml> I was thinking of something using the standard flip function
03:41:39 <EvilTerran> > let swap ~(x,y) = (y,x) in minimumBy (comparing swap) [(3,1),(1,4),(1,5),(9,2),(6,5)]
03:41:40 <lambdabot>   (3,1)
03:42:07 <EvilTerran> boml, well, swap = uncurry (flip (,))
03:42:25 <EvilTerran> > let swap ~(x,y) = (y,x) in sortBy (comparing swap) [(3,1),(1,4),(1,5),(9,2),(6,5)] -- more illustrative
03:42:26 <lambdabot>   [(3,1),(9,2),(1,4),(1,5),(6,5)]
03:42:40 <Nereid_> what does the ~ do? I've never seen that syntax
03:42:52 <EvilTerran> Nereid_, that's just me being overzealously lazy
03:43:08 <Zao> "this pattern will match, don't bother being strict"
03:43:11 <Zao> Or something along those lines.
03:43:13 <Nereid_> oh
03:43:22 <quicksilver> xenoblitz: you could either email him, or send him a message with lambdabot
03:43:29 <quicksilver> xenoblitz: or post to the -cafe
03:43:33 <Nereid_> I see now :)
03:43:43 <EvilTerran> Nereid_, it means that the pattern (x,y) matches without actually being checked, and is only checked when one of the variables in it is evaluated
03:44:26 <xenoblitz> quicksilver: thanks :) I think I managed to find it @ Graphics.UI.Gtk.Gdk.Events but I am unsure... will use it for now :) thanks though (ps how do you write a message via lambdabot? thanks)
03:44:38 <Baughn> Nereid_: As a side-effect, it means later pattern-matches will never match
03:44:47 <quicksilver> @tell xenoblitz if I sent you a message like this, LB would tell you next time it saw you speak.
03:44:47 <lambdabot> Consider it noted.
03:44:55 <Baughn> Nereid_: If they would, and the lazy one wouldn't, you get bottom instead
03:44:56 <EvilTerran> Nereid_, the only practical effect here is that swap _|_ = (_|_, _|_), instead of swap _|_ = _|_ if i'd left the ~ out
03:45:11 <Nereid_> hmm
03:45:15 <xenoblitz> so right after this?
03:45:16 <lambdabot> xenoblitz: You have 1 new message. '/msg lambdabot @messages' to read it.
03:45:22 <xenoblitz> quicksilver: thanks :)
03:46:07 <boml> EvilTerran: thx
03:46:29 <EvilTerran> Nereid_, without the ~, evaluation of "swap p" would evaluate p until it reduced to some (x,y) before committing to that branch of the "swap" definition
03:46:50 <EvilTerran> (there's only one branch here, but this is for consistency with multi-line definitions)
03:46:54 <xenoblitz> EvilTerran: so its a way to render pattern matching lazy
03:47:00 <xenoblitz> ?
03:47:08 <EvilTerran> pretty much, yeah
03:47:24 <quicksilver> it matters for certain kinds of very tight recursion
03:47:25 <Nereid_> I don't understand bottom too well, what's the difference between _|_ and (_|_, _|_) ?
03:47:27 <xenoblitz> EvilTerran: lemme guess so that makes it possible to use fixed point evaluation?
03:47:39 <quicksilver> I can never produce a good enough example on spec
03:47:55 <EvilTerran> > case undefined of (x,y) -> "ok!"
03:47:56 <lambdabot>   "* Exception: Prelude.undefined
03:47:58 <Baughn> Nereid_: "case (a,b) -> 2" will evaluate to 2 on (_
03:48:04 <EvilTerran> > case (undefined, undefined) of (x,y) -> "ok!"
03:48:05 <lambdabot>   "ok!"
03:48:06 <Baughn> Nereid_: Er, (bottom,bottom), but bottom on bottom
03:48:15 <EvilTerran> Nereid_, ^ there's the difference
03:48:21 * Baughn nods happily
03:48:36 <EvilTerran> > case undefined of ~(x,y) -> "ok!" -- and, with the irrefutable pattern
03:48:37 <lambdabot>   "ok!"
03:48:43 <Nereid_> ok
03:48:44 <Nereid_> :)
03:48:51 <Nereid_> makes more sense now
03:48:59 <Baughn> > case undefined of ~(x,y) -> (y,x)
03:49:01 <lambdabot>   (* Exception: Prelude.undefined
03:49:12 <Baughn> See the opening paranthesis there
03:49:21 <Nereid_> ahh
03:49:29 <EvilTerran> xenoblitz, in some circumstances, yes, the extra laziness you get from using an irrefutable pattern can make a fixed-point work that would otherwise diverge
03:49:32 <Baughn> It did in fact return (_|_,_|_) before failing
03:50:08 <Baughn> EvilTerran: But it must be said, if you're depending on that, your program is likely to have Subtle Bugs (tm)
03:50:17 * Baughn has seen enough of that lately
03:50:25 <EvilTerran> true
03:50:44 <Baughn> ..at least they're deterministic.
03:52:49 <Nereid_> what's the use of fixed points? D:
03:53:07 <Botje> generating fibonacci numbers
03:53:07 <quicksilver> Nereid_: what's the use of recursion?
03:53:20 <Baughn> Nereid_: Do you understand what a fixed point is?
03:53:23 <Nereid_> I don't see the connection
03:53:27 <Nereid_> Baughn: I think so.
03:53:34 <Nereid_> fix f = f (fix f)
03:53:35 <Botje> Nereid_: look up the Y combinator
03:53:36 <Nereid_> that thing right?
03:53:36 <Nereid_> :c
03:53:37 <quicksilver> Nereid_: fixed points are precisely the same thing as recursion.
03:53:52 <quicksilver> Nereid_: with "fix" you can implement recursion; with recursion you can implement fix.
03:53:55 <Baughn> Nereid_: No, that's fix. It's /a/ fixed point function, but not a general one
03:54:17 <Nereid_> ok, I don't understand it then
03:54:31 <Baughn> Nereid_: "Through repeated application of this function, the value converges to a fixed point". Or diverges, possibly.
03:54:55 <Baughn> That's another. Fix's implementation is a bit weird even for math..
03:55:45 <xenoblitz> its a bit harder to use fixed points than recursion if you ask me... at least I find it confusing sometimes when reading Haskell code
03:56:29 <Baughn> Well, they're kind of the same thing..
03:56:36 <quicksilver> very likely.
03:56:46 <quicksilver> just as a lambda is a way to use a function without giving it a name
03:56:56 <quicksilver> fix is a way to use a (recursive) function without giving it a name.
03:56:58 <Baughn> When calculating the fixed point, you stop applying your function once the value stops changing
03:57:08 <quicksilver> (or indeed a recursive value).
03:57:13 <xenoblitz> yes you reach "the" fixed point
03:57:21 <Baughn> *A* fixed point
03:57:32 <quicksilver> as such, I never use fix explicitly.
03:57:41 <quicksilver> I'm happy to give my recursive values names.
03:57:44 <quicksilver> but that's what it's for.
03:57:53 <xenoblitz> its usually used in let ... in ... or at least those are the examples I've seen
03:58:41 <Zao> @type flip fix Nothing $ \f x -> f Nothing >> return ()
03:58:42 <lambdabot> forall (m :: * -> *). (Monad m) => m ()
03:59:04 <Zao> The first time I saw one of those beasts in geordi I was quite confused.
03:59:11 <Zao> Especially as it was a screenful.
03:59:17 <xenoblitz> Zao: I AM confused xD
03:59:46 <quicksilver> xenoblitz: do you understand "let a = 1:a in a" ?
03:59:50 <quicksilver> > let a = 1:a in a
03:59:50 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
03:59:51 <Zao> xenoblitz: f in that case refers to the lambda function it's a parameter of.
04:00:08 <Zao> Which lets it call itself recursively. Which hurts my head.
04:00:29 <xenoblitz> quicksilver: yes that I somehow understand
04:00:29 <xenoblitz> zao: and mine lol
04:00:30 <giulianoxt> hey guys. I'm having some trouble implementing lexical scoping for an interpreter
04:00:46 <giulianoxt> is there any well known techinique for this?
04:00:47 <quicksilver> xenoblitz: ok, well "fix (1:)" is just a way ot writing that without naming a.
04:00:59 <quicksilver> xenoblitz: or "fix (\a -> 1:a)" if you prefer.
04:01:18 <giulianoxt> seems like any idea we have end up being dynamic scoping after all
04:01:52 <xenoblitz> quicksilver: so fix is like map, a higher-order function for fixed points
04:02:31 <quicksilver> xenoblitz: yes.
04:02:37 <xenoblitz> quicksilver: if you know of a good tutorial on fixed point calculations (for newbies) let me know :)
04:03:03 <quicksilver> the purpose of a tutorial is to teach an interesting lesson.
04:03:08 <quicksilver> I'm not sure what interesting lesson there is about fix.
04:03:29 <Taejo> xenoblitz: I agree with quicksilver. fix seems a bit odd for a while and then you get it
04:03:29 <quicksilver> "If our language didn't have recursion, we could use fix to write recursive functions in an ugly hard-to-read way"
04:03:36 <quicksilver> "But my language does have recursion!"
04:03:42 <quicksilver> "OK, use it then. and forget about fix"
04:04:19 <xenoblitz> quicksilver, Taejo: so you can almost always convert fixed point into a normal recursion provided by Haskell
04:04:27 <quicksilver> not "almost" always.
04:04:28 <xenoblitz> or always?
04:04:31 <xenoblitz> ok
04:04:31 <Taejo> xenoblitz: always
04:04:32 <quicksilver> absolutely always.
04:04:54 <xenoblitz> is it possible you might need ~ then sometimes in those cases to ensure laziness?
04:05:00 <Taejo> xenoblitz: fix is an ordinary haskell function
04:05:03 <Taejo> @src fix
04:05:04 <lambdabot> fix f = let x = f x in x
04:05:49 <xenoblitz> Taejo: that's the problem... how to effectively read that and understand it
04:06:21 <Taejo> xenoblitz: what I mean is that you don't need it, cause if you did you could just write out the definition
04:06:31 <quicksilver> Fix is of great theoretical importance.
04:06:33 <xenoblitz> oh ok :)
04:06:42 <quicksilver> It describes how we can give an elementary semantics to recursive functions.
04:06:55 <Nereid_> ok, what practical use does fix have over recursion?
04:06:58 <quicksilver> I' not convinced it's of great practical importance to oyur everyday programmer.
04:07:01 <quicksilver> Nereid_: absolutely none.
04:07:02 <Nereid_> lol
04:07:04 <Baughn> Those semantics are 'elementary' only in the nightmares of language theorists. >_<
04:07:10 <Taejo> but you might find "fix f = f (fix f)" a simpler definition to understand (it has the same value, but computes it less efficiently)
04:07:27 <quicksilver> unless you count avoiding naming the value that you're defining.
04:07:41 <quicksilver> but even then you generally don't really avoid naming it because it reappears as a lambda parameter.
04:08:08 <Zao> quicksilver: \_ x -> ...  :)
04:08:32 <quicksilver> Zao: fixes of that form aren't terribly interesting. That's a "recursion" which doesn't actually call itself.
04:08:40 <quicksilver> most people don't call that recursion.
04:08:58 <Zao> Narrowminded people don't.
04:09:01 <quicksilver> let f = 3; -- Would you describe 'f' as a recursive value that doesn't happen to actually call itself?
04:09:43 <Baughn> Yes!
04:10:12 <Zao> > let f = if False then f else 3 in f
04:10:13 <lambdabot>   3
04:10:17 <Zao> Is that a recursive value? :)
04:12:00 <RayNbow> @hoogle (a -> a -> Maybe Ordering) -> [a] -> [[a]]
04:12:00 <lambdabot> No results found
04:13:09 <Nereid_> I wonder what could you do with a partial order and a list to result in a list of lists
04:13:55 <Nereid_> perhaps a list of all chains
04:13:58 <RayNbow> returning all possible topological sorts?
04:14:16 <Nereid_> or that
04:15:04 <Nereid_> I hadn't thought of a partial order as a directed graph before.
04:16:22 <quicksilver> Nereid_: normally you think of the "skeleton" of it as a directed graph
04:16:32 <quicksilver> i.e. you remove edges which can be deduced by transitivity.
04:16:38 <Nereid_> ok
04:16:43 <quicksilver> (and often reflexivity because they're just noise)
04:16:52 <quicksilver> I can't remember the technical name for this diagram.
04:17:07 <quicksilver> http://en.wikipedia.org/wiki/Hasse_diagram
04:23:13 <Nereid_> @pl \x y -> f (g x y)
04:23:14 <lambdabot> (f .) . g
04:23:23 <Nereid_> clear as mud
04:23:24 <Nereid_> :p
04:24:30 <Boxo> @pl \x y z -> f (g x y z)
04:24:30 <lambdabot> ((f .) .) . g
04:24:46 <quicksilver> Nereid_: some people have recommended calling that .:
04:24:53 <quicksilver> personally I avoid non-unary compositions.
04:25:08 <quicksilver> that is, I don't try to do with combinators. I just write them out in pointful style.
04:25:26 <Nereid_> yeah I did that too
04:27:01 <Nereid_> at least when you get to something like ((((f.).).).).g there's a pattern
04:36:23 <Baughn> @type ((((f.).).).).g
04:36:25 <lambdabot>     Ambiguous type variable `b' in the constraints:
04:36:25 <lambdabot>       `Show b' arising from a use of `f' at <interactive>:1:4
04:36:25 <lambdabot>       `SimpleReflect.FromExpr b'
04:36:30 <Baughn> @type \f g -> ((((f.).).).).g
04:36:32 <lambdabot> forall b c a a1 a2 a3 a4. (b -> c) -> (a4 -> a3 -> a2 -> a1 -> a -> b) -> a4 -> a3 -> a2 -> a1 -> a -> c
04:37:14 <Baughn> ..there is a pattern there, but...
04:40:24 <Nereid_> ok, now that I've written my chains function I can go to bed
04:40:32 <Nereid_> chains :: (Ord a) => (a -> a -> Maybe Ordering) -> [a] -> [[a]]
04:40:32 <Nereid_> chains o xs = [] : concat (map (\x -> map (x:) $ chains o (filter ((== Just LT) . o x) xs)) xs)
04:40:44 <Nereid_> yuck
04:42:07 <dibblego> concat (map f x) == concatMap f x
04:42:17 <Nereid_> ok
04:42:29 <dibblego> you may consider do notation
04:42:39 <Nereid_> I might but I don't want to think about it
04:43:27 <dibblego> concatMap (\z -> map (f z) x) k  follows a pattern
04:46:31 <quicksilver> concats + filters = looks like a good candidate for list comprehension
04:48:44 <plumenator> Say I have a function f :: a -> b -> c. How do I partially apply only b and c?
04:49:13 <RayNbow> you mean f :: a -> b -> c -> d ?
04:49:26 <plumenator> RayNbow: Sorry, yes.
04:50:26 <RayNbow> I'd use (\a -> f a b c)
04:50:56 <mux_> there are no implementable functions with this type though
04:51:16 <plumenator> Makes sense, I was hoping for a shortcut like f a b for skipping c.
04:51:22 <dibblego> @pl (a -> b -> c -> d) -> b -> c -> a -> d
04:51:23 <lambdabot> (line 1, column 4):
04:51:23 <lambdabot> unexpected ">"
04:51:23 <lambdabot> expecting variable, "(", operator or ")"
04:51:31 <BONUS> you can do some flipping
04:51:34 <dibblego> wtf?
04:51:37 <BONUS> but making a lambda is much clearer
04:51:39 <quicksilver> BONUS: that's a "longcut" :)
04:51:42 <BONUS> yeah haha
04:52:02 <RayNbow> dibblego: @pl wants a Haskell expression, not a type :p
04:52:09 <dibblego> oh yeah
04:52:11 <BONUS> flip ((flip f) b) c
04:52:14 <BONUS> something like that
04:52:17 <dibblego> @djinn (a -> b -> c -> d) -> b -> c -> a -> d
04:52:18 <lambdabot> f a b c d = a d b c
04:52:30 <RayNbow> @. pl djinn (a -> b -> c -> d) -> b -> c -> a -> d
04:52:31 <lambdabot> f = (flip .) . flip
04:52:34 <dibblego> @pl \a b c d -> b -> c -> a -> d
04:52:38 <lambdabot> (line 1, column 15):
04:52:38 <lambdabot> unexpected ">" or "-"
04:52:38 <lambdabot> expecting variable, "(", operator or end of input
04:52:55 <Baughn> @djinn a -> b
04:52:56 <lambdabot> -- f cannot be realized.
04:53:04 <Baughn> ..well, I never.
04:53:14 <plumenator> BONUS: I got this question while I was reading ur tutorial. :-) And while discussion flip too. :-D
04:53:30 <labo> @pl (\a -> f a b c)
04:53:30 <lambdabot> flip (flip f b) c
04:54:14 <plumenator> Btw, wht does @pl do? Expand lambdas?
04:54:25 <Baughn> plumenator: No, it's pointless
04:54:30 <quicksilver> it removes explicit arguments
04:54:36 <quicksilver> by a series of rewrite rules.
04:54:48 <quicksilver> and accidentally does some other incidental rewriting on the way ;)
04:54:48 <sioraiocht> is there no default definition of Monoid Int?
04:54:51 <Baughn> @pl foo a b c = (a,c,1+c,b)
04:54:52 <lambdabot> foo = flip . (`ap` (1 +)) . (,,,)
04:54:55 <quicksilver> sioraiocht: no.
04:54:59 <sioraiocht> okay!
04:55:03 <sioraiocht> thanks :)
04:55:09 <mux_> sioraiocht: a monoid is a type _and_ an associative binary operation with an identity
04:55:14 <quicksilver> > Sum 3 `mappend` Sum 4
04:55:15 <lambdabot>   Sum {getSum = 7}
04:55:16 <mux_> Int by itself cannot be a monoid
04:55:17 <Baughn> sioraiocht: For future reference, :info in ghci will tell you
04:55:34 <quicksilver> mux_: you could use that argument to suggest that no instances at all should exist.
04:56:02 <Baughn> sioraiocht: There are at least two possible monoids over int - sum and product. Which happen to be realized as Sum and Product. :)
04:56:02 <quicksilver> mux_: any instance involves more information than the type - they're all arbitrary choices.
04:56:05 <mux_> quicksilver: right, there are no instances of types by themselves :-P
04:56:10 <quicksilver> but there are.
04:56:23 <quicksilver> the typeclass/instance system is about making arbitrary global choices
04:56:30 <quicksilver> that is the purpose of the system.
04:56:33 <mux_> there are instances of types along with a mconcat function
04:56:35 <sioraiocht> quicksilver: ah, thanks =)
04:56:40 <sioraiocht> as, thanks Baughn
04:56:45 <Baughn> > Sum 2 `mappend` Sum 4
04:56:46 <sioraiocht> *also
04:56:47 <lambdabot>   Sum {getSum = 6}
04:57:07 <mux_> well, in any case, my point was that talking about Int being an instance of monoid without mentioning what the operation would be makes no sense, at least to me
04:57:58 <quicksilver> why does talking about [a] being an instance of Monoid make any more sense?
04:58:02 <quicksilver> and yet it is.
04:58:35 <mux_> it does not make any sense, it's my point, but saying [a] is an instance of monoid with (++) as mconcat does make sense
04:58:59 <quicksilver> that's just giving more information, though.
04:59:14 <mux_> that's giving enough information to properly define a Monoid instance
04:59:19 <quicksilver> Given the question "Is [a] an instance of Monoid (in the stanard libraries)?"
04:59:24 <quicksilver> the answer is Yes, it is.
04:59:36 <quicksilver> if the question begins "Is Int an instance..."
04:59:40 <quicksilver> the answer is No, it is not.
04:59:43 <quicksilver> why is that?
04:59:53 <quicksilver> just because for some reason the [a] one is a bit more obvious
04:59:53 <RayNbow> [a] <--> free monoid?
05:00:01 <quicksilver> and it's not so obvious what the instance for Int should be
05:00:06 <mux_> that's a byproduct of haskell's syntax that makes you write instance Foo where...
05:00:10 <quicksilver> but that's somewhat subjective.
05:00:19 <mux_> yes, the [a] is obvious whereas Int could have several potentially useful instances
05:00:19 <quicksilver> I don't think it's a syntax point at all.
05:00:29 <quicksilver> it's a semantic point, and an important one.
05:00:36 <quicksilver> instances are a global property of types.
05:00:49 <quicksilver> [a] is a Monoid instance in haskell; Int is not.
05:00:58 <quicksilver> (there are multiple ways to make [a] a Monoid, but we chose one)
05:01:17 <mux_> I stand by what I said, it still makes no sense to me to talk about an Int instance without further details
05:01:34 <quicksilver>  < sioraiocht> is there no default definition of Monoid Int?
05:01:41 <quicksilver> that's a perfectly sensible question.
05:01:48 <quicksilver> The question is about the default or standard libraries.
05:02:00 <quicksilver> In the default or standard libraries, there is a Monoid instance for [a] but not for Int.
05:02:04 <BONUS> there are many (valid) ways to make [a] a monoid, just like there are many valid ways to make Int a monoid
05:02:14 <quicksilver> precisely.
05:02:22 <quicksilver> But we chose one for [a] and actually *made* it a Monoid.
05:02:26 <quicksilver> we didn't choose one for Int.
05:02:28 <BONUS> yeah
05:02:34 <quicksilver> That's almost arbitrary.
05:02:37 <mux_> I admit this question makes sense, I had skipped the "default" bit
05:02:40 <quicksilver> although, of course, there are/were reasons for it.
05:02:44 <mux_> which changes everything
05:03:13 <sioraiocht> yes mux_, I understand what a monoid is the general sense
05:06:05 <flip^eh> Any way to hardcode my umlauts, not by using \228 fr  and stuff..
05:06:14 <flip^eh> Can I save the file as unicode like I can in D?
05:06:31 <sioraiocht> flip^eh: yes
05:06:36 <mux_> I think you can with the UnicodeSyntax extension
05:06:37 <flip^eh> :)
05:07:16 <quicksilver> no, unicodesyntax is needed for, well, unicodesyntax.
05:07:26 <quicksilver> just using UTF8 source files requires no special flag.
05:07:37 <mux_> it didn't work in the past
05:07:38 <quicksilver> GHC has supported UTF8 source since, erm, 6.6? 6.4?
05:08:00 <quicksilver> UnicodeSyntax is funky stuff like \rightarrow for -> and \lambda for \
05:08:01 <flip^eh> It does not work here, tho
05:08:02 <mux_> I've tried using unicode characters for operators and got errors
05:08:09 <mux_> quicksilver: aah.
05:08:10 <flip^eh> Main.hs:204:94:
05:08:10 <flip^eh>     lexical error in string/character literal (UTF-8 decoding error)
05:08:21 <quicksilver> flip^eh: then you failed to save it in UTF8 ;)
05:08:36 <flip^eh> I just save it using the SciTE editor
05:08:51 <quicksilver> choose UTF8 as the format.
05:08:54 <quicksilver> or something.
05:08:57 <quicksilver> I have never heard of this editor.
05:08:58 <flip^eh> Okay, I'll try
05:09:03 <quicksilver> But what you need to do, is save it in UTF8.
05:09:07 <flip^eh> Scintilla based
05:09:15 <goroii> Hi. i will learn haskell
05:09:32 <quicksilver> mux_: depends which character class they are in.
05:09:41 <flip^eh> Works
05:09:50 <quicksilver> mux_: some character classes GHC thinks of as letters, so they can go in normal identifiers
05:09:57 <mux_> cool.
05:10:03 <quicksilver> mux_: some it thinks of as symbols so they can go in operators.
05:10:14 <goroii> so i want to make web application. is there good framework for web application on haskell?
05:12:26 <quicksilver> goroii: there are a few, I haven't used any of them
05:12:31 <quicksilver> happstack, turbinado, wash.
05:13:52 <goroii> yeah i note happstack. its most hot library?
05:15:19 <quicksilver> goroii: I dunno really. I don't hear much conversation about any of them here, but I doubt that's particularly significant.
05:15:27 <quicksilver> I'm sure some people are using them.
05:18:02 <goroii> hmm haskeller will not make web application? but for research work?
05:18:50 <quicksilver> I know that haskellers do make web applications.
05:18:57 <quicksilver> otherwise these frameworks would not exist.
05:19:10 <quicksilver> I'm just saying, I don't hear them discussed here very often so I can't gauge which is hot.
05:20:01 <goroii> ic
05:29:57 <Zao> Can I write the following more elegantly?
05:30:00 <Zao> > fmap (fmap (*3)) [Just 42, Nothing, Just 3]
05:30:02 <lambdabot>   [Just 126,Nothing,Just 9]
05:30:13 <quicksilver> (fmap.fmap) (*3) ?
05:30:21 <dibblego> @pl fmap `fmap` fmap
05:30:21 <lambdabot> fmap `fmap` fmap
05:30:22 <quicksilver> I slightly prefer (fmap.fmap)
05:30:30 <quicksilver> since my mind knows that is a 2-deep fmap.
05:30:55 <quicksilver> > (fmap.fmap.fmap) (+1) [[[1,2,3],[4]]]
05:30:57 <lambdabot>   [[[2,3,4],[5]]]
05:30:59 <quicksilver> and it generalise to n-deep
05:31:18 <Zao> Ah. I had something similiar in mind but couldn't quite connect the dots.
05:40:23 <fasta> With GetOpt I create a structure Foo, where some values are required, so the Foo structure has some Maybe members, and there is some test to check that all the Maybe members are in fact Just <something>, which then sends this structure to the rest of the application. The only clean solution I see it to create a new structure which is exactly isomorphic to the original structure, but with Maybe a replaced by a, but this is also not that ideal, because of the red
05:40:24 <fasta> undancy. I can also just add an extra list of accessors, which have the fromJust already in them, but I am not really happy with any of the solutions. Anything else?
05:41:46 <Zao> You could use TH to get rid of some of the repetition, but it'd probably be quite overkill.
05:42:03 <EvilTerran> fasta, well, where you have "data Foo = ... (Maybe Bar) ... (Maybe Baz)"
05:42:14 <EvilTerran> you could write "data Foo f = ... (f Bar) ... (f Baz) ..."
05:42:19 <EvilTerran> and then use Foo Maybe and Foo Id
05:43:01 <fasta> That would get rid of the fromJust, but you still need the fromId (or whatever it is called).
05:43:14 <fasta> EvilTerran: I do agree that it is a slightly better solution.
05:43:35 * EvilTerran attempts to channel Oleg
05:44:14 <quicksilver> I thought about that problem before fasta. I could have sworn I came up with an answer I was happy with but I don't recall what it was :(
05:44:40 <EvilTerran> ...well, you could then write crafty accessors so that they're getBar :: FunctorOrWhatever f => Foo f -> f Bar
05:44:41 <fasta> I mean logically it is just adding an assumption.
05:45:27 <fasta> I really love the verified objects they have in Qi.
05:45:47 <EvilTerran> or, if you're willing to indulge in fundeps or type families, you could make it "Foo Maybe -> Maybe Bar" but also "Foo Id -> Bar"
05:48:04 <quicksilver> You could have a type "data CommandLineOption", you could have an interpretation function "interpret :: ComandLineOption -> (Foo -> Foo)", you could have a verify function "checkRequiredElts :: [CommandLineOption] -> Maybe ErrorMessage" and once it verifies correctly you apply the Foo->Foos to a 'default' Foo.
05:48:24 <quicksilver> the 'default' Foo has 'error "this really can't happen"' in those fields which are required and don't have default values
05:48:45 <quicksilver> but you know that won't happen, because your checker checks the commandlineoptions for validity before applying them to the default Foo.
05:48:51 <quicksilver> I don't think that's lightweight though :P
05:49:40 <fasta> quicksilver: calling error is not an option. I think I will just keep my current solution, which is the fromJust approach.
05:49:56 <quicksilver> you appreciate that that calling error will never really happy
05:50:03 <quicksilver> it's just there as a fallback.
05:50:05 <quicksilver> happen.
05:50:23 <quicksilver> checkRequiredElts checks that the commandlineoptions have the right form that the error field can' tbe there.
05:50:39 <fasta> quicksilver: but how can you check whether all the elements are ok, if one of the elements contains error?
05:50:56 <fasta> quicksilver: oh, well, you can with unsafePerformIO, I guess.
05:51:09 <EvilTerran> fasta, bear in mind fromJust can also call error
05:51:17 <fasta> EvilTerran: not in the way that I do it now.
05:51:26 <quicksilver> fasta: you check over "data CommandLineOption"
05:51:36 <quicksilver> to make sure all the required fields are there.
05:51:37 <fasta> EvilTerran: since I first verify they are all "Just" values.
05:51:49 <quicksilver> this is not really all that different form your two types suggestion
05:51:52 <quicksilver> it still requires two types
05:51:57 <quicksilver> it's just instead of two versions of Foo
05:52:07 <quicksilver> it has one version of Foo, and one concrete rep of the command line options.
05:52:20 <fasta> quicksilver: right
05:52:22 <quicksilver> You parse the command line options to the concrete rep, check it for validy, and only then "interpret" it into Foo.
05:55:19 <quicksilver> I quite like the model of a concrete representation plus an interpretation function as a general programming pattern.
05:55:27 <quicksilver> since functions are not inspectable
05:55:36 <bastl> Hmmm, I would like to "address" specific subterms in a complex expression. Im thinking of something like Regexes. Is there something like that or similar already?
05:56:51 <EvilTerran> bastl, are you using an algebraic data type for terms?
05:57:08 <bastl> yes
05:57:41 <EvilTerran> what sort of addresses would you want?
05:58:07 <quicksilver> bastl: that is what Zippers are for.
05:58:24 * EvilTerran was thinking some sort of concretized path through a Zipper would suit
05:58:58 <bastl> suppose a parse-tree for some java class.
05:59:16 <plumenator> Is there a way to write functions with more than two arguments in infix form?
05:59:22 <bastl> i want the first method that looks like "void doit()"
06:00:26 <fasta> Zippers can work, but make sure you can switch easily to a mutable representation later, since it's not unlikely that some day you might have to do that.
06:00:40 <EvilTerran> plumenator, yes
06:01:37 <EvilTerran> > let (f >-> g) x = g (f x) in ((+1) >-> (*2)) 2
06:01:38 <lambdabot>   6
06:01:42 <fasta> The problem with zippers and most functional concepts is that they are quite limited. E.g. foldr expresses only one particular kind of loop. 'while' is strictly more powerful. So, a simple change in a while loop, might require a different recursion pattern in Haskell. It's the same with zippers vs mutable data structures.
06:01:49 <EvilTerran> plumenator, there's the 3-ary function >-> being defined and used infix
06:02:35 <fasta> OTOH, that they are limited can also be perceived as their strength.
06:03:16 <quicksilver> I find they're particular good for heterogenous structures
06:03:23 <quicksilver> like ADTs as opposed to containers
06:03:40 <quicksilver> because the tyep of the zipper constructor tells you what "kind of thing" your cursor is pointing at
06:03:48 <quicksilver> much more convenient than the mutable situation IMO.
06:03:59 <plumenator> EvilTerran: I had simpler things in mind, like a function that adds 3 numbers? ( Is is even meaningful to have such an infix operator?)
06:04:25 <EvilTerran> plumenator, well, you could write (x +++ y) z = x + y + z, say, if you really wanted...
06:04:38 * Botje wants smalltalk-style selectors
06:05:15 <EvilTerran> plumenator, but you can't really have mixfix directly in haskell (as in C's "p ? t : f" notation)
06:05:40 <quicksilver> you kind of can.
06:05:43 <zebrafinch> > let (p ? t) f = if p then t else f; max a b = (a > b) ? a $ b in max 1 2
06:05:44 <lambdabot>   2
06:05:51 <quicksilver> if you're prepared to dance a delicate precedence dance
06:05:53 <EvilTerran> quicksilver, kind of, yes, but not directly
06:05:59 <quicksilver> and create intermediate types + possibly classes
06:06:03 <plumenator> EvilTerran: Yeah, I figured teh +++ function from your previous example, but how do I use it?
06:06:08 <quicksilver> it's not a particularly pleasant dance
06:06:15 <EvilTerran> plumenator, the same way you define it
06:06:28 <saml> > let (x +++ y) z = x + y + z in 1 +++ 2 3
06:06:30 <lambdabot>   Add a type signature
06:06:31 <plumenator> with the parantheses?
06:06:33 <EvilTerran> > let (x +++ y) z = x + y + z in (a +++ b) c
06:06:34 <lambdabot>   a + b + c
06:06:41 <EvilTerran> plumenator, yes, you'd need the parentheses
06:06:46 <EvilTerran> $ would work too
06:06:51 <plumenator> Okay, thanks!
06:06:57 <EvilTerran> > let (x +++ y) z = x + y + z in a +++ b $ c
06:06:58 <lambdabot>   a + b + c
06:07:09 <saml> > sum [a,b,c]
06:07:11 <lambdabot>   0 + a + b + c
06:10:57 <jeffersonheard> so... weird little bug I can't seem to shake: I have a GLDrawingArea nested inside a toplevel Graphics.UI.Gtk.Window and whenever I resize it, the GL area doesn't actually resize.
06:11:11 <jeffersonheard> as in the widget itself, not the drawing
06:28:55 <jeffersonheard> Is it possible to pseudo-reliably open a handle with unsafePerformIO?  I'm after doing something sneaky with my code without changing the interface
06:29:22 <jeffersonheard> a debug-version of a module vs. a production version sort of a thing
06:29:59 <jeffersonheard> and I want to open a handle to the debug file as part of the main data structure
06:30:00 <sioraiocht> how can I define my own show instance for a UArray and keep ghc from yelling aboutthe standard one?
06:30:16 <jeffersonheard> sioraiocht: hide the prelude
06:30:28 <jeffersonheard> oh wait
06:30:31 <jeffersonheard> no that won't work
06:30:34 <jeffersonheard> pardon me, I'm tired
06:30:36 <sioraiocht> nope.. =p
06:30:49 <ejt> sioraiocht: I think you'll have to use a wrapper type
06:30:56 <ejt> and define an instance for that
06:31:03 <sioraiocht> ejt: that is...very irritating
06:31:05 <sioraiocht> but okay
06:31:26 <jeffersonheard> sioraocht: you *could* use a "type" rather than a "newtype" and define -XTypeInstances
06:31:34 <jeffersonheard> or something like that
06:31:40 <sioraiocht> jeffersonheard: thanks
06:31:41 <ejt> it's not to much extra to write: show array   -->  show (MyArray array)
06:31:41 <jeffersonheard> to allow aliases to have their own instances
06:32:14 <jeffersonheard> and then you'll just have to do show (a::MyAlias)
06:32:19 <sioraiocht> ejt: if arrays were a top-level type, maybe
06:33:09 <sioraiocht> they are quite nested as it is, itwould be a lot of pattern matching
06:33:17 <ejt> ah
06:34:13 <quicksilver> jeffersonheard is wrong.
06:34:25 <quicksilver> TypeInstances does not allow type aliases to have their own instances.
06:34:36 <quicksilver> it merely allows you to use an alias in an instance if you want.
06:34:52 <quicksilver> it will still overlap with any other instance for that type (aliases ignored)
06:34:58 <jeffersonheard> really?
06:35:01 <quicksilver> really.
06:35:08 <quicksilver> type aliases are meaningless
06:35:16 <quicksilver> they are removed very early on in the type checker
06:35:21 <quicksilver> they are really nothing more than a shorthand.
06:35:23 <sioraiocht> quicksilver: so I need to use newtype?
06:35:29 <quicksilver> yes.
06:35:30 <jeffersonheard> Hrm.  I suppose I'd always tried it with instances that didn't overlap.  Just assumed
06:35:37 <quicksilver> although, overriding Show is broken anyway.
06:35:45 <quicksilver> just define 'pretty print' if show isn't waht you want.
06:35:45 <sioraiocht> quicksilver: it doesn't incur any penality anyway, right?
06:35:58 <sioraiocht> quicksilver: what do you mean?
06:36:11 <quicksilver> jeffersonheard: In respect of your earlier question, I don't anticipate any problems with an unsafePerformIO'd handle opening
06:36:19 <quicksilver> jeffersonheard: what were you worrying might go wrong?
06:36:31 <quicksilver> sioraiocht: the 'Show' class is for the purpose of producing valid haskell syntax.
06:36:51 <quicksilver> you should seldom implement Show in any other way than what the built-in deriving would give.
06:36:55 <sioraiocht> I just want my sequence type to show a string as a string =p
06:36:58 <jeffersonheard> quicksilver: that I might manage to write to the handle before it opened.
06:37:12 <quicksilver> jeffersonheard: trying to write to it would force it
06:37:17 <quicksilver> jeffersonheard: (which would open it)
06:37:19 <quicksilver> I think that's fine.
06:37:24 <jeffersonheard> thought so.
06:37:46 <jeffersonheard> I suppose I seriously need more coffee today
06:37:59 <quicksilver> I'd be more worried about it getting opened twice.
06:38:10 <quicksilver> You'd need to understand how to turn off the inlining in the right way, I think.
06:42:46 <jeffersonheard> hrm...  a {-# GHC_OPTIONS -fno-pre-inlining -O0 #-} at the top of the module might work?
06:43:37 <EvilTerran> jeffersonheard, strategically placed {-# NOINLINE #-} would be less of a sledgehammer
06:44:01 <jeffersonheard> This is meant for debugging only, though, so I'm not terribly concerned about sledgehammer-application in this module
06:44:19 <jeffersonheard> but I take your point
07:15:26 <ryant5000> where is the log of this chatroom?
07:15:50 <EvilTerran> ryant5000, in the /topic
07:16:47 <SamB> EvilTerran: nonsense
07:16:54 <SamB> it won't fit in the /topic!
07:17:28 <EvilTerran> SamB, sure, the channel wouldn't, but its logarithm should be small enough
07:18:47 <SamB> EvilTerran: *groan*
07:19:00 <EvilTerran> :D
07:19:04 <hzap> Couldn't match expected type Float against inferred type String in function: log
07:19:05 <Twey> Hahahaha
07:19:15 <SamB> lol
07:22:55 <quicksilver> are bad puns considered pure enough for #haskell?
07:24:27 <hzap> quicksilver: maybe we need a BadPun monad?
07:32:28 <ryant5000> EvilTerran: so it is :) my client seems to truncate the /topic unless you tell it not to
07:35:45 <hackagebot> esotericbot 0.0.6 - Esotericbot is a sophisticated, lightweight IRC bot. (JohnnyMorrice)
07:35:45 <hackagebot> zlib 0.5.2.0 - Compression and decompression in the gzip and zlib formats (DuncanCoutts)
07:37:02 <jeffersonheard> instance BadPun Groaner where audienceReaction pun = "Arrrrrghhhhhhh"
07:39:45 <MyCatVerbs> jeffersonheard: if you compile that with -Wall, I think you should get a warning about the unused parameter not being called _. :)
07:40:48 * jeffersonheard tries to think of how to make the warning into a pun...
07:47:33 <sioraiocht> @src concat
07:47:33 <lambdabot> concat = foldr (++) []
07:48:26 <mapreduce> @type foldl
07:48:29 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
07:48:48 <mapreduce> What's the more general function than foldl; that works on any monad?
07:49:47 <BONUS> you can either do Data.Foldable.foldl
07:49:52 <BONUS> which works on any Foldable instance
07:49:55 <BONUS> or you have foldM
07:50:00 <BONUS> depends on what kind of behavior you want
07:50:01 <mapreduce> :t foldM
07:50:02 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
07:50:07 <mapreduce> Thanks.
07:56:27 <quicksilver> if a Foldable is also a monoid then "fold" gives a possible definition of "join" which might make it into a monad.
07:56:39 <quicksilver> you still need to work out what 'return' should be though.
08:01:11 <bastl> hmm, just read the Zippers tutorial from wikibooks. I think thats what I want. Is there something that derives Zippers for arbitrary datastructures? zipping looks verymuch like boilerplate code ...
08:01:27 <EvilTerran> ?where derive
08:01:27 <lambdabot> http://www.cs.york.ac.uk/fp/darcs/derive
08:01:34 <EvilTerran> may do it
08:02:28 <quicksilver> it doesn't.
08:02:44 <quicksilver> It's quite hard to derive a zipper for an arbitrary structure
08:02:54 <quicksilver> in practice you want to name the constructors in a sensbile way.
08:03:21 <jmcarthur_work> bastl, http://www.cs.nott.ac.uk/~ctm/diff.pdf describes a general method, but it may be a bit mathy for a beginner (i'm making assumptions about your skill level)
08:03:59 <BONUS> the zipper article from wikibooks is good but i prefer the one on the haskell.org wiki
08:04:26 <BONUS> also i like that it uses the spine from the list to store the paths not taken instead of implementing its own list
08:04:45 <jmcarthur_work> the wikibooks article does describe it in somewhat simpler terms: http://en.wikibooks.org/wiki/Haskell/Zippers#Differentiation_of_data_types
08:05:06 <BONUS> http://www.haskell.org/haskellwiki/Zipper
08:05:22 <BONUS> oh wait it doesnt hmm
08:05:54 <BONUS> yeah anyway i like representing a zipper as (substructure, [info about paths not taken])
08:09:01 <bastl> i want to point to substructures of syntax trees, for languages like java. i dont want to write the zpper my self !?
08:09:48 <bastl> zipper*
08:10:29 <jmcarthur_work> that would be a tough zipper to write
08:10:45 <jmcarthur_work> i really don't know of any tools to automatically create a zipper from a data structure though
08:11:11 <quicksilver> I have a zipper for a simple ADT lying around somewhere
08:11:19 <quicksilver> it was on the old hpaste, may it rest in peace
08:11:45 <BONUS> making a zipper for a data structure is really not that much work
08:12:54 <hackagebot> persistent-map 0.1.0 - A thread-safe interface for finite map types with optional persistency support. (PeterRobinson)
08:12:56 <quicksilver> bastl: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6183#a6183
08:13:13 <quicksilver> a recursive ADT (FunctionalTexture) and its corresponding zipper/context
08:13:20 <quicksilver> plus the functions for moving around and stuff
08:13:40 <bastl> thanks ill have a look at it.
08:13:43 <quicksilver> and for a bonus, the zipper for the colour maps inside it
08:14:12 <bastl> but my abstract syntax for java has 1177 lines of data declarations ... :-/
08:14:56 <EvilTerran> yay java
08:14:57 <EvilTerran> (!)
08:16:15 <cjs> Ah, my quote of the day: "Use (set! x ...) for (let ((x ...)) ...) only if there is at least one (lambda ... between it and the (let ...), or if the new value for x is a function that refers to x." (The Seventeenth Commandment from _The Seasoned Schemer_.)
08:18:35 <EvilTerran> ... what
08:18:57 <EvilTerran> is there a justification for this?
08:19:40 <cjs> Don't even ask for my Java quote....
08:20:21 * Woof asks for cjs' Java quote
08:21:09 <cjs> "Saying that Java is good because it works on all platforms is like saying  anal sex is good because it works on all genders."
08:21:18 <Woof> Haha
08:21:19 * hzap trying to understand the Seasoned Schemer quote
08:21:20 <confounds> cjs: LOL
08:21:28 <EvilTerran> > fix $ ("(read "++).(++")").show
08:21:29 <lambdabot>   "(read \"(read \\\"(read \\\\\\\"(read \\\\\\\\\\\\\\\"(read \\\\\\\\\\\\\\...
08:21:48 <cjs> hzap: I'm trying to understand it, too. I've gotten as far as, "set! is a bad, bad thing!" :-)
08:22:05 <quicksilver> bastl: Ah. 1177 lines of data declarations. Hmm.
08:22:19 <hzap> first, is it saying "use set! for a let-bound variable when <blahblahblah>"?
08:22:20 <quicksilver> bastl: yes you might consider some automated derivation then but it won't be easy.
08:22:57 <bastl> i wonder whether this is a generic (as in syb) problem !?
08:23:01 <EvilTerran> he does specifically say "Use (set!) ONLY IF ...", so "never use (set!)" would imply his rule
08:23:10 <hzap> lol
08:23:13 <quicksilver> syb would solve some of your problems
08:23:17 <quicksilver> but not all of them.
08:23:24 <quicksilver> syb isn't sufficient to generate zippers, AFAIK.
08:23:43 <EvilTerran> (ah, the tricksy formal logic interpretation of "only if" :D)
08:24:10 <hzap> EvilTerran: guess that's why we stay with purely functional Haskell :)
08:24:25 <EvilTerran> ... of course, "never use scheme" would also imply his rule. or any other rule with the context "when using scheme..."
08:25:34 <hzap> so (let ((x 1))   (set! x 2) (lambda ...)) is allowed by that rule?
08:26:49 <cjs> This really is a serious rule.
08:27:34 <hzap> nvm, i guess it meant (let ((x 10))  (lambda (blah) (set! x blah)))
08:27:39 <hzap> makes a bit more sense
08:28:12 <cjs> This is from Chapter 15, BTW, which is entitled, "The Difference Between Men and Boys..."
08:28:21 <hzap> lol...
08:29:24 <hzap> I think I've made sense of the clause before the 'or' in that rule...
08:29:44 <cjs> Q: "What is the value of '(set! x (quote gone))'? A: It doesn't have a value, but the effect is as if we had just written '(_define_ x (quote gone))'.
08:29:53 <cjs> Aiiee!
08:30:00 <quicksilver> if it occurs after a reasonable number of subjunctions or negations, it's essentially impossible to work out what "or" means in english.
08:30:45 <EvilTerran> cjs, ah, the old needless effect/value duality that plagues imperative programmers...
08:31:30 <cjs> "Why I program in Haskell," or, "Give me problems with arbitrary-rank polymorphisms any day."
08:31:38 * EvilTerran wonders why that's (quote gone) instead of 'gone
08:31:57 <hzap> probably because his code is wrapped in single quotes
08:32:12 <fasta> Exporting less from a module, makes the whole system go faster, right?
08:32:30 <abuiles> Hi, does someone know why when using opengl and wanting to render a rect if I have the polygonMode in ( Point, Fill) it doesn't fill the rectangle instead I have to change the order to polygonMode (Fill,Point) ? in cpp the first option works but, in Haskell I have to change the order..
08:32:33 <EvilTerran> hzap, i was gonna guess that using any syntactic sugar at all just isn't hardcore enough for Real Men :P
08:33:01 <burp> @hoogle fold
08:33:01 <lambdabot> Data.Foldable fold :: (Foldable t, Monoid m) => t m -> m
08:33:01 <lambdabot> Data.IntMap fold :: (a -> b -> b) -> b -> IntMap a -> b
08:33:01 <lambdabot> Data.IntSet fold :: (Int -> b -> b) -> b -> IntSet -> b
08:33:02 <Baughn> abuiles: Use ltrace, check what the actual Gl calls are
08:33:16 <hzap> EvilTerran: do real hask-men use do notation?
08:33:57 <cjs> Sure. It looks so similar to >> and >>= notation, if you line things up correctly, that it makes little difference. :-)
08:34:06 <fasta> hzap: not in public.
08:34:34 <ejt> does anyone know if the llvm bindings support structures ?
08:34:43 <hzap> ? (still learning how to use this irc thing)
08:34:55 <cjs> Actually, I think that real Haskell programmers use applicative notation, at the very least, right?
08:35:11 <fasta> hzap: it was a joke.
08:35:30 <Peaker> Applicative notation with a bit of join calls sprinkled in, when monadic behavior is necessary :-)
08:35:52 <abuiles> Baughn: thanks.
08:37:13 <EvilTerran> hzap, my "real men" comment was poking fun at the book. calling it "The Seasoned Schemer", having "commandments" in it, and having a chapter called "The Difference Between Men and Boys" seems to be being excessively grand for its subject matter
08:37:18 <cjs> EvilTerran: Yes, WRT effects and values, it does seem to me that working in pure languages can be rather ineffective.
08:37:30 <Zooix> Hi everybody, I've got an error when I try this: http://nopaste.com/p/aaJpQf2nz
08:37:53 <cjs> EvilTerran: Actually, it's rather too bad. _The Little Schemer_ was great. It was where I really learned to love recursion. And the rules were not quite like that one....
08:37:53 <Zooix> the error is located at the '<-'
08:38:04 <EvilTerran> cjs, i'm not sure i follow wrt effects and values there
08:38:05 <bastl> jmcarthur_work: was that paper published somewhere?
08:38:13 * hzap is currently being massively baffled by silly type bugs at work
08:38:32 <Zooix> can somebody help me please
08:38:46 <EvilTerran> Zooix, if you're going to be using <-, they need to be in a do-block
08:38:54 <EvilTerran> and the lines need to be indented consistently
08:39:00 <Zooix> EvilTerran, thanks
08:39:27 <fasta> EvilTerran: all these nerds need to have something they can be happy about. Don't take that away from them ;)
08:39:54 <EvilTerran> fasta, er, what?
08:40:08 <fasta> EvilTerran: Re: seems to be being excessively grand for its subject matter
08:40:13 <EvilTerran> ahh
08:40:29 <jmcarthur_work> bastl, not sure
08:40:30 <Zooix> EvilTerran, I get this time an error cause the last line must be an expression
08:40:59 <EvilTerran> Zooix, well, another problem might be that "tirer n-1 c+1" will be parsing as "(tirer n)-(1 c)+1"
08:41:01 <hzap> Zooix: can you re-paste the code with indentation fixed?
08:41:11 <Zooix> yes
08:41:18 <EvilTerran> Zooix, as function application always binds tighter than any infix operator
08:41:33 <Zooix> do I have to use the $ for exemple ?
08:41:42 <EvilTerran> you can use parentheses...
08:41:47 <hzap> i think that issue would cause a type error, not the one Zooix is getting
08:41:56 <Peaker> Zooix: you never "have" to use ($) like that, you can always use () and start with that if you're more comfortable with it
08:42:01 <EvilTerran> Zooix, i suspect you meant "tirer (n-1) (c+1)", judging by the spacing you used
08:42:41 <Twey> tirer n-1 c+1  (tirer n) + (1 c) + 1
08:42:52 <Twey> Er, -
08:43:12 <EvilTerran> Twey, i beat you to it while you were looking up , methinks ;P
08:43:42 <Twey> Haha
08:43:51 <Twey> I didn't look it up :-P
08:43:57 <Zooix> Here it is: -- Monte Carlo haskell
08:43:57 <Zooix> import IO
08:43:57 <Zooix> import Random
08:43:57 <Zooix> rand = (randomRIO (1 :: Int, 100) / 100)
08:43:57 <Zooix> tirer n c = do
08:43:57 <Twey> I was just clarifying.
08:43:59 <Zooix>     
08:44:01 <Zooix>     x <- rand
08:44:03 <Zooix>     y <- rand
08:44:05 <Zooix> 	
08:44:06 <Twey> Zooix: hpaste?
08:44:07 <Zooix>     if (x*x + y*y ) <= 1
08:44:09 <Zooix>     then tirer n-1 c+1
08:44:11 <Zooix>     else tirer n-1 c
08:44:13 <Zooix> start = tirer 200 0
08:44:14 <EvilTerran> Zooix, please use a pastebin!
08:44:15 <Zooix> oh sorry
08:44:17 <Zooix> http://nopaste.com/p/aXYBoIi3I
08:44:32 <hzap> you need to indent "then" and "else" to the right more
08:44:33 <Zooix> sorry I tought I had the url in paste
08:44:47 <EvilTerran> ah, easy mistake to make
08:45:08 <hzap> I sort of expected that was the issue
08:45:30 <Zooix> Thanks
08:45:40 <hzap> yeah and then add the parens as they were saying
08:45:43 <Zooix> Now I've a problem with my rand function
08:46:11 <Twey>     if (x*x + y*y ) <= 1  you don't need the brackets here, though.
08:46:36 <Twey> Comparison operators bind more tightly than arithmetic operators, by convention in just about every language with a concept of operator precedence.  :-P
08:46:44 <Twey> Er, vice versa even
08:46:52 <Peaker> even
08:47:10 <Zooix> Twey, thanks but I've now a problem with my rand function :D
08:47:16 <pikhq> Most languages with operator precedence have programmers use parens in cases like that just so you don't have to recall the precedence, anyways. :P
08:47:16 <Twey> Zooix: So you said
08:47:20 <Twey> What is it?  :-P
08:47:32 <bastl> Is "JFP 7 (5): 549554, September 1997" (Functional Pearl: The Zipper) a review or original work by G. Huet? the author talks about G.Huet in 3rd person singular ...
08:47:36 <Twey> pikhq: I disagree :-P  I find it fairly obvious
08:47:44 <Zooix> I want to get a DOuble between 0 and 1
08:47:58 <Twey> 2 - 1 < 3 can only be interpreted one way, after all
08:48:07 <Twey> (sanely  maybe not in PHP :-P)
08:48:21 <Twey> Zooix: Right  and what's the problem you're having?
08:48:29 * EvilTerran gets to thinking about type-based operator precedence parsing
08:48:31 <EvilTerran> >:)
08:48:34 <fasta> bastl: Huet just wrote it down. Zippers were folklore before that.
08:48:35 <pikhq> Twey: I'm just saying that that's the typical convention. ... Though with just arithmetic like that, it really isn't needed.
08:48:35 <Peaker> pikhq: nah -- it wouldn't type check in any other way
08:48:59 <Peaker> EvilTerran: syntax is a lower layer than typing/semantics, and I hope it stays that way :)
08:49:02 <Twey> EvilTerran: Nice.  :-P
08:49:05 <Zooix> No instance for (Fractional (IO Int) )
08:49:22 <hzap> rand = randomRIO (0, 1) :: IO Double
08:49:30 <Peaker> Zooix: IO Int is an imperative program that produces an Int, its not an Int, and an Int is not fractional
08:49:31 <EvilTerran> Peaker, eh, i figure we can make them mutually referential without too many problems if we're clever ;)
08:49:33 <hzap> something like that
08:49:45 <bastl> So that paper is from Huet? Then it has a strange style of self reference ...
08:49:55 <pikhq> Peaker: You and your 'booleans are not integers'. :P
08:50:01 <bastl> im confused ...
08:50:01 <Zooix> ok
08:50:03 <Peaker> EvilTerran: then syntax/semantics are no longer separate layers - yikes.  I like to think of syntax as a temporary hack until we have good code editors anyway
08:50:22 <bastl> Peaker: :-)
08:50:32 <pikhq> Methinks Peaker would like Lisp, then.
08:50:55 <Peaker> pikhq: I don't like Lisp very much because it is untyped, and it also uses syntax - even if a pretty poor one :)
08:51:17 <Twey> Zooix: You can actually just change the Int to Double in your current function
08:51:29 <SamB> Peaker: there will always be syntax
08:51:34 <Twey> It would be better style to give it a top-level type signature, though  that way you don't need to perform inline annotations
08:51:35 <fasta> Peaker: syntax a temporary hack? So, you want some kind of graphical programming?
08:51:36 <Peaker> pikhq: I want syntax to be a purely-presentational feature of a language, and I want to be able to choose between alternate presentation syntaxes at the press of a button
08:51:51 <fasta> Peaker: that's still syntax, though.
08:51:53 <SamB> perhaps in the future it will be a bit higher-level, however
08:52:06 <Peaker> fasta: I am not sure what UI would be best, maybe not flow-chart'ish, but probably a bit more "graphical" than current text syntax
08:52:15 <SamB> Peaker: you mean you don't want syntax to be a merely textual thing, yes?
08:52:18 <Peaker> fasta: yeah, there'd still be syntax, but it would become a purely presentational, rather than an encoding tool
08:52:31 <SamB> Peaker: some sort of tree in most cases, I hope?
08:52:40 <Peaker> SamB: No no, I mean I want syntax encoding to be something used to present information to the user on screen - but not the way the program is stored or edited
08:52:43 <bastl> presentation = decode ?
08:52:47 <Twey> Peaker: Lisps don't have to be untyped :)
08:52:48 <Peaker> SamB: most probably a graph, not a tree
08:52:50 <SamB> Peaker: how do you want to store them?
08:52:58 <SamB> that sounds awfully confusing
08:53:14 <Twey> Liskell is pretty much a Lisp
08:53:17 <Peaker> SamB: I don't think it matters that much, but preferrably an extensible format that can allow adding features to the language later -- encoding future things like optimization hints, etc
08:53:27 <SamB> personally, I often wish syntax were a BIT more abstract
08:53:29 <bastl> "re"presentation of code = encoding ...
08:53:29 <Twey> And CL supports type annotations, albeit mostly for performance reasons
08:53:34 <fasta> Liskell is a good idea, although Qi seems to be a better idea.
08:53:38 <bastl> Peaker: its the same.
08:53:52 <SamB> but by that, I mean trees, rather than sequences of ASCII characters
08:54:02 <hzap> speaking of untypedness, I rally wish I'm actually using a static typed language at work right now
08:54:02 <Twey> I don't care about syntax in my languages, too much.
08:54:16 <Peaker> SamB: Its not confusing because it can look very much like an editor looks today -- its just that the editor *presents* syntax to the user, but actually has more accessible information about the program's graph -- e.g: Rename changes just one attribute in the backend, as names are documentation only, and are not used by the mechanism to encode the inter-references in the graph
08:54:38 <fasta> I just love it when ghc and ghci disagree on the output they give of a certain program...
08:54:50 <Peaker> bastl: yeah - you have to encode the code on screen to show it -- but it doesn't have to be the same way the code is encoded in the back-end (i.e: on disk, and in the editor's internal representation)
08:54:53 <Twey> fasta: Defaulting FTW
08:55:00 <SamB> Peaker: wouldn't trees vs. graphs mean completely different languages?
08:55:12 <fasta> Twey: I don't think it's that.
08:55:21 <SamB> I don't know how to *write* programs in graphs
08:55:22 <Peaker> SamB: I don't know of any language whose abstract syntax is really a tree -- they all are graphs encoded to a tree via namespaces+names
08:55:23 <fasta> Twey: the compiled version should then complain.
08:55:35 <bastl> another way to represent = another syntax, but still syntax.
08:55:35 <Peaker> SamB: you already write programs as graphs -- you form graphs by connecting nodes via names
08:55:38 <SamB> Peaker: those names are important, you know
08:55:48 <Peaker> SamB: yeah, they are scoped comments - the greatest type of comment there is
08:56:09 <Twey> fasta: Not necessarily  GHCi does different defaulting to GHC
08:56:14 <Peaker> SamB: and indeed such comments should be encouraged - but changing such a comment should not break the program or even threaten to break it under any circumstance. It should not affect anything, its a comment
08:56:19 <fasta> Twey: example?
08:56:30 <fasta> Twey: and side-note: that's insane :)
08:56:42 <Twey> Highly
08:56:45 <fasta> I know about the extended defaulting rules.
08:56:52 <Twey> Ah, okay then :)
08:57:04 <fasta> But once a program compiles in ghc, its behaviour in ghci should be equal.
08:57:09 <SamB> Twey: it's just a LANGUAGE flag isn't it?
08:57:25 <Peaker> SamB: currently names are both scoped comments AND graph encoding -- their latter use is an operational one, and so it might break programs to improve their documentation.  This mechanism makes it very difficult to dereference graph links (have to grep through sources!) and difficult for the editor to follow
08:57:28 <fasta> Well, that's at least a rule, I would expect that should hold.
08:57:53 <SamB> hmm. how do you set different LANGUAGE flags for the REPL vs. files ?
08:58:21 <SamB> Peaker: how does your idea work with libraries ?
08:58:22 <Twey> fasta: Not necessarily  see for example Control.Concurrent.Chan
08:58:44 <Twey> In GHC newChan :: IO (Chan a), and in GHCi it yields a Chan GHC.Prim.Any
08:58:50 <Twey> SamB: Could be
08:59:20 <Peaker> SamB: you can probably only have valid code graph objects if you have the libraries installed. If not, a broken link can probably be used until a library installed and the link is resolved
08:59:41 <Peaker> SamB: basically you move the linking stage to the editing phase, rather than after compilation
08:59:58 <SamB> that makes me even more confused about your idea than before :-(
09:00:03 <Peaker> SamB: why?
09:00:12 <SamB> dunno
09:00:17 <SamB> do you have a blog for this?
09:00:28 <Peaker> Nope
09:00:36 <fasta> Twey: yes, the Any type is evil and a major bug, imho.
09:01:20 <Peaker> SamB: you have a database (e.g cabal) of installed libraries -- when you edit stuff you can have links into this cabal database.  If you download code - its links are probably serialized into some name/text-form, and when you install/edit the code, it tries to deserialize the text links into real ones. If it can't its basically a linkage failure - same as if you try to compile&link with a missing library
09:01:28 <SamB> fasta: yeah, that's evil. what is it again though?
09:01:52 <fasta> SamB: it's the default type for everything, I believe, until it gets replaced by the actual type.
09:02:07 <hackagebot> hack-handler-hyena 2009.6.23 - Hyena hack handler (JinjingWang)
09:02:27 <fasta> SamB: searching Trac should give you a better answer.
09:02:27 <SamB> fasta: what the ?
09:02:43 <SamB> so it's something used in the default-resolution code?
09:03:06 <fasta> SamB: no, it's just like you have data Foo = Foo Int; default_foo = Foo 0
09:03:27 <fasta> SamB: but the 0 in the default_foo is never replaced by anything, so the user sees it.
09:03:40 <SamB> fasta: hmm ?
09:04:26 <fasta> SamB: http://www.mail-archive.com/glasgow-haskell-bugs@haskell.org/msg20761.html
09:12:15 <ellisbben> Anyone know of a function with signature (Monad m) => (a -> m [a]) -> a -> m ()?
09:12:31 <Peaker> @hoogle (Monad m) => (a -> m [a]) -> a -> m ()
09:12:32 <lambdabot> No results found
09:12:39 <ellisbben> ah, thank you
09:12:47 <Peaker> ellisbben: what do you want it to do?
09:13:00 <Peaker> apply and then sequence?
09:13:24 <ellisbben> apply the first argument to the second, then apply itself to each element in the returned list
09:13:29 <ellisbben> easily written on its own
09:13:53 <Peaker> but then you get an infinite tree of applications?
09:14:11 <ellisbben> Peaker: unless you are guaranteed to get empty lists after a while
09:14:37 <Peaker> ellisbben: so you want to continue applying hoping the tree is finite?
09:15:19 <ellisbben> Peaker: yes.  if it isn't, I've got worse problems than my program not terminating.
09:15:33 <Peaker> What is this for?
09:16:12 <Peaker> @type let func f x = f x >>= mapM (func f) in func
09:16:12 <ellisbben> I have an analysis of a bunch of C structs containing structs and enums and whatnot
09:16:13 <lambdabot>     Occurs check: cannot construct the infinite type: b = [b]
09:16:14 <lambdabot>       Expected type: m b
09:16:14 <lambdabot>       Inferred type: m [b]
09:16:37 <ellisbben> I want to insert all the structs and enums used by a given list of structs into a map
09:17:10 <jmcarthur_work> so this is some sort of a tree unfold?
09:17:46 <Peaker> @type let func f x = f x >>= \xs -> sequence (concatMap (func f) xs) in func
09:17:48 <lambdabot> forall a a1. (a -> [[a]]) -> a -> [[a1]]
09:17:52 <Peaker> oops
09:18:01 <jmcarthur_work> ellisbben, could these work for you? http://www.haskell.org/ghc/dist/current/docs/libraries/containers/Data-Tree.html#3
09:18:22 <ellisbben> In a way.  The whole thing has to refer to two maps with typedef and anonymous struct tags in order to do the analysis
09:18:36 <doserj> @type let func f x = f x >>= mapM_ (func f) in func
09:18:37 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m [a]) -> a -> m ()
09:19:22 <ellisbben> doserj: that's exactly it
09:19:35 <ellisbben> I think... :)
09:20:15 <jmcarthur_work> would that ever terminate? i'm having trouble reasoning about it
09:20:52 <jmcarthur_work> hmm, i guess it could
09:21:26 <doserj> > let func f x = f x >>= mapM_ (func f) in func (const []) 1
09:21:27 <lambdabot>   []
09:21:31 <doserj> > let func f x = f x >>= mapM_ (func f) in func (const [[]]) 1
09:21:32 <lambdabot>   [()]
09:22:16 <ellisbben> well, I just wrote it in non-HOF style and what I have refactors to doserj's solution
09:22:42 <doserj> ellisbben: it really is Peaker's solution, actually :)
09:22:54 <doserj> he just forgot the _
09:23:01 <Peaker> heh
09:23:04 <Peaker> HOF?
09:23:10 <ellisbben> higher order function
09:23:28 <ellisbben> peaker++
09:23:30 <ellisbben> doserj++
09:25:13 <ellisbben> I love that function signatures tend to carry so much information about what the function does
09:25:31 <ellisbben> ... assuming that none of the arguments are ignored
09:26:48 <Peaker> very polymorphic functions typically have only one or very few sensible things they might do
09:26:56 <Peaker> (where "sensible" includes not ignoring the arguments)
09:27:31 <quicksilver> hmm
09:27:40 <quicksilver> well typically they can't ignore the arguments either.
09:27:47 <ellisbben> right.  maybe you could get different traversal orders or something out of the same type signature, assuming "sensibility"
09:27:52 <quicksilver> neglecting _|_, which we normally do in this kind of discussion.
09:28:06 <doserj> (a->a)->[a]->[a] has infinitely many non-trivial inhabitants, though
09:28:12 <quicksilver> yes.
09:28:29 <quicksilver> or...
09:28:31 <quicksilver> hmm
09:28:45 <quicksilver> yes, but a very well structured family of such.
09:28:55 <quicksilver> a structure we call \blackboardbold{N}
09:29:02 <doserj> :)
09:29:32 <doserj> actually, it has some more
09:29:47 <ellisbben> but there's a reduction in the number of inhabitants if you assume that the function is as high order as possible and not `arbitrary'
09:30:21 <ellisbben> for example, it doesn't contain some predicate embedded in it if that predicate could instead be passed in as an argument
09:30:53 <ellisbben> wait
09:30:55 <doserj> (a->a)->a->a already has N. these can be composed with the non-trivial functions [a]->[a]
09:31:19 <ellisbben> I'm mistaken because you can't stick in a predicate on some arbitrary type
09:32:59 <quicksilver> doserj: Hmm. member of ([a]->[a]) is choice of permutation Sn for each n?
09:33:09 <burp> someone got a fast implementation for binomial coefficients?
09:34:01 <doserj> quicksilver: what about concat . replicate n?
09:34:26 <doserj> (if we only count total functions)
09:34:47 <ellisbben> hmmm...
09:34:48 <quicksilver> doserj: Oh, it can choose to change the size of the list, too. Good point.
09:35:00 <quicksilver> doserj: (of course we only count total functions. We're logicians)
09:35:27 <quicksilver> it's quite a complex structure isn't it.
09:35:30 <ellisbben> [a]->[a] is like all countable tuples of functions a->[a]...
09:35:42 <ellisbben> if you assume no reordering.
09:36:10 <ellisbben> there's probably some more wrinkles on top of that
09:38:25 <doserj> quicksilver: I have no idea how the structure looks like :)
09:39:55 <doserj> if you only allow finite lists, then you also have the ability to dispatch to different functions based on the length of the list...
09:40:48 <quicksilver> Yes, I think we do only allow finite lists, if we're being logicians.
09:41:09 <quicksilver> that was the N-indexed part of my eaqrlier suggestion.
09:41:25 <Peaker> but none of these things would be very sensible for a "general" function :-)
09:41:56 <doserj> in the sense that repeating information is not sensible, yes
09:43:54 <burp> @hoogle binomial
09:43:54 <lambdabot> No results found
09:56:28 <hackagebot> hack-handler-hyena 2009.6.23.1 - Hyena hack handler (JinjingWang)
09:58:13 <QtPlaty[HireMe]> :hoogle (a->b,c->d) -> (a,c) -> (b,d)
09:58:39 <QtPlaty[HireMe]> @hoogle (a->b,c->d) -> (a,c) -> (b,d)
09:58:39 <lambdabot> No results found
10:00:27 <ziman> :t uncurry (***)
10:00:28 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => (a b c, a b' c') -> a (b, b') (c, c')
10:00:30 <hackagebot> hack-frontend-happstack 2009.6.24 - hack-frontend-happstack (JinjingWang)
10:01:12 <ziman> @djinn (a->b,c->d) -> (a,c) -> (b,d)
10:01:13 <lambdabot> f (a, b) (c, d) = (a c, b d)
10:04:09 * QtPlaty[HireMe] nods to ziman "It was so trival I expected it to be in the prelude or something"
10:05:33 <hackagebot> curry-frontend 0.2 - Compile the functional logic language Curry to several intermediate formats (HolgerSiegel)
10:07:04 <Baughn> conal: You may already know this, but the post suggests not, so - When the threaded rts starts evaluating some thunk, it black-holes the thunk until it's complete. Most of the time other threads will block on the hole, but there's a tiny chance of a race condition where they both end up evaluating it. This is supposed to be safe, since it's pure.
10:07:23 <Baughn> conal: And of course that's incredibly ghc-specific
10:07:33 <ziman> QtPlaty[HireMe], indeed, even more generalized :)
10:08:07 <conal> Baughn: thanks.  i had only a vague awareness about that policy.
10:08:29 <conal> Baughn: do you think unamb is similarly safe, since  pure in spite of unsafePerformIO?
10:08:37 <conal> i mean in spite of IO
10:08:53 <Baughn> conal: Yes. If two threads end up evaluating the uPIO thunk, they'll both get the same result.
10:08:56 <Baughn> Should be fine.
10:09:32 <conal> Baughn: hooray for pure semantics.
10:10:04 <Baughn> conal: Beyond that post, any gotchas I should watch out for if I try implementing futures the way you specify in http://conal.net/blog/posts/another-angle-on-functional-future-values/ ?
10:10:54 <conal> Baughn: not that i know of.  i haven't tried.
10:12:03 <conal> Baughn: i'm intrigued with the general idea of taking lazy evaluation further, i.e., ways to use what's essentially unsafePerformIO in pure ways, as lazy evaluation does.  monotonicity seems to be the key principle.
10:12:48 <conal> i.e., one can safely side-effect as long as information grows, and as long as the side-effecting happens automatically when missing information is sought.
10:13:01 <jmcarthur_work> conal, i did that with my unsafeInterleaveIO version
10:13:05 <jmcarthur_work> it worked great
10:13:28 <jmcarthur_work> unfortunately the majority of my work was lost and i have been sidetracked from it by some alternative semantics ideas
10:13:38 <jmcarthur_work> i still have some old version of it sitting at home
10:13:39 <SamB> conal: that's not always safe :-(
10:13:56 <SamB> conal: sometimes you run out of RAM and the OOM killer kills you
10:13:58 <jmcarthur_work> and yes, it wasn't always safe, as SamB says
10:14:04 <SamB> and/or the user
10:14:06 <conal> SamB: the interesting question to me is when it *is* safe.
10:14:17 <conal> SamB: OOM killer?
10:14:19 <jmcarthur_work> i had specified a lot of preconditions to get it to work for me
10:14:25 <conal> jmcarthur_work: cool!
10:14:26 <jmcarthur_work> but they were rather operational in nature
10:14:31 <SamB> of course, that applies equally well to pure code
10:14:48 <conal> pure lazy functional programming is built on this trick of monotonic side-effects.
10:14:50 <SamB> conal: the thing in the Linux kernel that kills things when you're basically out of memory
10:14:57 <conal> but it's been trapped so far.
10:15:01 <conal> SamB: oh.
10:15:54 <SamB> of course, it goes by virtual memory ...
10:15:55 <conal> SamB: the exhaustion problem you mention applies to pure functional programming, right?  or are you saying it's a new danger introduced by expanding safe/monotonic side-effecting as i'm suggesting?
10:16:15 <SamB> conal: yeah, it does apply to pure code too
10:16:17 <jmcarthur_work> conal, you may recall when i was talking about it at the time. my fully expanded Event type was implemented as [Maybe (t, a)]
10:16:24 <conal> SamB: oh, okay.
10:16:40 <jmcarthur_work> it was discrete steps in time along the list, reliant on a polling action to populate it
10:16:53 <jmcarthur_work> for that reason, it was pretty limited
10:16:53 <SamB> it would be nice to be able to come up with some techniques for avoiding it by un-computing things or something like that ;-)
10:17:05 <jmcarthur_work> worked well for the game i was writing alongside it at the time, though
10:17:06 <Baughn> jmcarthur_work: Hm. How did it decide how small the steps should be?
10:17:17 <conal> jmcarthur_work: and it didn't allow the efficient short-cutting side-effects that laziness does, right?
10:17:44 <jmcarthur_work> Baughn, it was dependent on the frequency that the state of the entire system was checked at the top level. yes, pretty inelegant
10:17:56 <conal> i've also done FRP in a pure way with non-occurrence streams.  it put me in a terrible trade-off.
10:18:14 <jmcarthur_work> conal, i didn't run into any problems with short cutting, really, but maybe you have a particular kind of short cut in mind that i forgot about
10:18:23 <conal> low-latency became very costly.  and just due to implementation reasons, not theoretical ones.
10:18:26 <jmcarthur_work> like an empty list would represent an event stream that would never have any more events
10:19:19 <conal> jmcarthur_work: by short-cutting, i mean that the implementation doesn't have to traverse old partial information before getting to the latest/best approximation.
10:19:27 <jmcarthur_work> the code for this was the clearest FRP implementation i have seen yet, despite its inelegance from a high level
10:19:47 <jmcarthur_work> conal, no old information was stored unnecessarily
10:20:02 <jmcarthur_work> since the top level just polled the state, old states were thrown away at the same time
10:20:02 <conal> jmcarthur_work: oh. because you use side-effects?
10:20:39 <conal> jmcarthur_work: i kind of remember that implementation.  would be nice to see the theory worked out.
10:20:57 <jmcarthur_work> yeah, i didn't have any formal approach to proving that it was even pure, though
10:21:21 <dons> conal: is there a web page somewhere that lists apps built in an FRP style?
10:21:22 <conal> jmcarthur_work: which could be really interesting work!
10:21:35 <conal> dons: i don't know of one.
10:21:47 <dons> I bet that would help adoption :)
10:21:57 <dons> guis, games, aggregators, ...
10:22:08 <conal> dons: we might not be ready for adoption :(
10:22:21 <jmcarthur_work> conal, yeah. it was a fun implementation. what actually got me away from it was the comparison of lazy IO, which is what i was using, with iteratee, with promises of purity and deterministic behavior and efficiency
10:22:32 <dons> conal: there are too many things written in it already though!
10:22:33 <jmcarthur_work> so i am currently looking into an iteratee-based approach to frp
10:22:39 <dons> lets not wait another decade ;)
10:22:44 <conal> dons: are there?
10:22:50 <conal> :)
10:23:04 <dons> sure. hackage is full of things that have 'reactive' in the name...
10:23:15 <jmcarthur_work> i agree, i think frp is not production- or even really evangelism-ready
10:23:25 <ehird> Who administrates lambdabot these days?
10:23:33 <dons> but people are writing FRP things. too late, jmcarthur_work
10:23:44 <jmcarthur_work> the ideas are, but not the implementations, whether it be the libraries or the applications using them
10:23:51 <jmcarthur_work> practical things?
10:24:20 <dons> we've done little scripts at work for aggregators et al
10:24:22 <gwern> ehird: Cale, I think. but it actually runs on lispy's server. or something
10:24:30 <dons> so yeah, just another tool in the mix.
10:24:37 <ehird> Cale: lispy: who do I have to bribe to get lambdabot in a channel? :-)
10:24:40 * dons is puzzled why FRP is always "not quite there"
10:24:48 * conal too
10:24:52 <gwern> ehird: well, you could bribe me
10:25:09 <ehird> gwern: ok, here's some money signs: $$$$$
10:25:16 <dons> its like saying "monads aren't production ready"
10:25:18 <SamB> conal: maybe it's undecidable, like types extensional equality?
10:25:21 <SamB> +with
10:25:29 <gwern> sorry, I only accept USDs, since $ were inflated by zimbabwe
10:25:33 <conal> SamB: maybe what's undecidable?
10:25:38 <SamB> conal: dunno!
10:25:41 <ehird> gwern: USD USD USD USD USD USD
10:25:42 <conal> heh
10:25:47 <SamB> I can't decide
10:25:55 * gwern pockets them. excellent. what channel did you want lb in?
10:26:18 <ehird> gwern: #esoteric :-)
10:26:25 <jmcarthur_work> lol
10:26:45 <lament> one step closer to turing #esoteric into a #haskell clone!
10:26:52 <ehird> lament: i do what i can
10:27:00 <lament> first lambdabot - then 600 users!
10:27:10 <ehird> then - the world!
10:27:28 <djahandarie> Man, why is lambdabot so complicated compared to the sample IRC bot building guide
10:27:32 <djahandarie> T_T
10:27:37 <dons> djahandarie: it does a /lot/ of things
10:27:45 <jmcarthur_work> in-page search on hackage for "reactive" only shows me libraries
10:28:10 <hzap> it's LAMBDA, the ultimate IRC bot!
10:28:21 <dons> djahandarie: its extensible at runtime, supports multiple channels, multiple servers, multiple user, multiple protocols, state persistance, multithreading etc
10:28:24 <FunctorSalad> @bot
10:28:24 <lambdabot> :)
10:28:24 <lunabot>  :)
10:28:25 <jmcarthur_work> i know there are some apps written using FRP libraries or ideas, but they are at least not tagged that way
10:29:27 <jmcarthur_work> anyway, i could evangelize FRP saying you can do this or that, but then somebody will ask what library they should use and i'll have nothing to say but listing the drawbacks for each one. not very evangelistic
10:30:07 <Raevel> extensible at run time? oh swell
10:31:20 <djahandarie> dons, maybe I'll be able to appreciate that one day... when I can actually understand it. -_-
10:31:35 <conal> here's my plan for evangelizing FRP: (a) finally get it right, (b) use it myself to make cool things and share it without others who are eager for it, (c) let people read & see the cool stuff and then come asking.
10:32:02 <jmcarthur_work> my plan as well
10:32:13 <conal> i got tired of pushing cool ideas at Sun and at Microsoft.
10:32:37 <conal> more fun for me when someone pulls
10:32:47 <Berengal> You forgot inflamatory blog posts. Can't conquer the world without them...
10:32:55 <astroeggy> hi! this is my first time using irc
10:33:40 <astroeggy> are there supposed to be threads like in a forum?
10:33:49 <conal> Berengal: heh.  yeah.  i enjoy writing inflamatory blog posts from time to time.
10:33:55 <astroeggy> or does everyone just talk?
10:34:27 <jmcarthur_work> astroeggy, if you are trying to speak to specific people, it is common to prefix your message with their name
10:34:35 <Berengal> astroeggy: Everyone just talks, but each room typically has a common theme
10:34:54 <Berengal> This one, for example, is about Haskell
10:35:00 <jmcarthur_work> astroeggy, and if you want to go off topic, you can either /join #haskell-blah or /msg <nick> the person you are talking to
10:35:16 <astroeggy> thank you!
10:36:08 <astroeggy> I am just trying to learn haskell, and thought I would apply it to web development
10:36:15 * Berengal got a small step closer to introducing haskell at work today
10:36:28 * sm pokes hackagebot 
10:36:34 <Peaker> I wrote a little XML processor in Haskell at work already :-)
10:36:55 * jmcarthur_work continues his quest to introduce haskell where he works
10:36:57 <djahandarie> Berengal, wait... do you ever go on the xkcd boards?
10:37:02 <Berengal> Peaker: Heh, I might write a sexpr -> xml converter
10:37:05 <Berengal> djahandarie: Yes
10:37:17 <djahandarie> Berengal, heh, I've seen you before. :P
10:37:18 <hzap> i write haskell scripts at work, it's pretty fun :D
10:37:40 * thoughtpolice continues to hope he will just find a job where he could use haskell :)
10:37:57 <Elly> mmm, haskell job
10:38:04 <Berengal> djahandarie: Nice, I have a proper persona now
10:38:34 <jmcarthur_work> so many willing haskellers. it's surprising how few startups there are based on haskell apps
10:38:46 <djahandarie> Berengal, well, I just put two and two together. :P
10:39:44 <djahandarie> I don't think there could be many Berengal's that code Haskell.
10:39:49 <Baughn> "Clock t -> RPC (Query t) (Response t) -> StateT (Either (WaitState t) t) IO ()" <--- ...this signature just keeps growing. >_<
10:40:16 <Berengal> djahandarie: I don't think there's many Berengal's at all...
10:40:24 <opqdonut> Berengal: nothing a few type aliases won't solve
10:40:27 <opqdonut> for example for the result monad
10:40:47 <uzytkownik> @hoogle liftA
10:40:47 <lambdabot> Control.Applicative liftA :: Applicative f => (a -> b) -> f a -> f b
10:40:47 <lambdabot> Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
10:40:47 <lambdabot> Control.Applicative liftA3 :: Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
10:40:57 <Peaker> I think there are a few basic things Haskell's stdlibs still don't cover quite properly.  e.g: Iteratee is rather new (and not well known) and lazy I/O is completely unacceptable
10:41:14 <FunctorSalad> yep, a type alias for your central monad also helps with refactoring
10:41:19 <Peaker> There are still too few "obvious answers" to common problems, IMO
10:42:03 <Berengal> Never heard of Iteratee before...
10:42:15 <FunctorSalad> sounds intimidating
10:42:27 <SamB> I heard it once before
10:42:31 <Berengal> lazy IO is a can of worms though
10:42:41 <Peaker> Iteratee/Enumerator should probably be named Consumer/Producer
10:42:42 <Baughn> Peaker: Also, the ADT syntax is still kind of awful, and we could use a caseM. Or, more likely, an extension of lambda to produce first-class case values.
10:42:44 <SamB> it does sound a bit intimidating
10:42:51 <FunctorSalad> because at first you think "iterator" byt you know it's going to be nowhere near as simple as that ;)
10:42:56 <FunctorSalad> *but
10:43:16 <SamB> Peaker: ah, yes, those sound a lot less scary *and* more meaningful
10:43:21 <Baughn> Peaker: ..in ways simpler than "let f (Left a) = ..; f (Right b) = .. in f"
10:44:00 <jmcarthur_work> something like (\Nothing -> ...; Just x -> ...) would be great
10:44:00 <gwern> jmcarthur_work: I think it's because all our ingenuity goes into types and functions, and we're left with little idea as to what actially to do with it all
10:44:03 <Baughn> There's also the problem that, yes, it /does/ take longer to get proficient at haskell than other languages
10:44:04 <Peaker> Baughn: having patterns be first-class values?
10:44:06 <FunctorSalad> Baughn: you mean folds?
10:44:28 <FunctorSalad> Baughn: there's th-fold. actually I wrote an extension for it but the author didn't answer yet ;)
10:44:31 <Baughn> FunctorSalad: No, I mean I find myself wanting to write "case (gets foo) of ..."
10:44:42 <Baughn> FunctorSalad: Which is basically caseM, which doesn't exist
10:44:54 <hzap> i think he's talking about the "lambda case" syntax idea floating around?
10:45:05 <FunctorSalad> Baughn: that's just like "gets foo >= foldFoo ..."
10:45:07 <FunctorSalad> isn't it?
10:45:49 <hzap> FunctorSalad: it's when you have do { x <- gets foo; case x of blahblahblah }
10:45:54 <Baughn> FunctorSalad: No, it's "gets foo >>= \x -> case x of ..."
10:46:12 <FunctorSalad> oh right, the fold has recursion built in, case doesn't...
10:46:32 <Baughn> FunctorSalad: A decent lambda pattern extension would let me shorten that to "gets foo >>= \pattern -> ..; \pattern -> ..." or some such
10:47:03 <Berengal> I don't think there's too much to save there...
10:47:20 <hzap> avoids 1 needless name invention
10:47:42 <Baughn> Note that the pattern may have an arbitrary number of parameters
10:47:53 <Peaker> Baughn: oh you mean caseM blah of   translating to (blah >>= \x -> case x of ...)  ?
10:47:56 <Berengal> hzap: At the expense of extending the langauge
10:48:03 <FunctorSalad> couldn't you just make caseM a function?
10:48:11 <Peaker> Baughn: I don't find myself pattern-matching a lot, I use folds instead. If you do that, then its easy to apply the fold via fmap or such
10:48:46 <Berengal> FunctorSalad: No.
10:48:49 <Baughn> Peaker: Well, with that pattern I'd be able to say "liftM3 (\p a t -> ..."; \p a t -> ...)" to get my caseM in a nicer manner
10:49:13 <FunctorSalad> caseM_Maybe :: Monad m =>   (Nothing -> m r) -> (Just a -> m r) -> m (Maybe a) -> m r
10:49:25 <Peaker> Baughn: case gets foo of [] -> return Nothing ; (x:xs) -> return (Just x)       to:   foldr (Just . const) Nothing `fmap` gets foo
10:49:46 <Baughn> FunctorSalad: That's the point. At the moment I can't make caseM a function. With a pattern extension, I could use liftMn on the pattern.
10:49:47 <FunctorSalad> liftM3 (caseM_Maybe (... clauses ...)) f2 f3
10:50:29 <Peaker> Baughn: I don't think its that important -- it also makes execution order less apparent
10:51:24 <FunctorSalad> Peaker: I'm lately into folds too, but it's kinda hard to get the type right for GADTs :)
10:52:34 <Peaker> FunctorSalad: haven't had a chance to use GADTs
10:53:32 <FunctorSalad> btw that type above should have been: "caseM_Maybe :: Monad m => m r -> (a -> m r) -> m (Maybe a) -> m r"
10:54:56 <conal> GADTs are so sweet!
10:54:58 <FunctorSalad> silly me
10:55:12 <conal> they enable statically-typed language encodings
10:55:21 <FunctorSalad> ('Nothing's not even a type. The idea was that that clause is responsible for handling the "Nothing" case)
10:57:05 <jmcarthur_work> conal, yes, GADTs rock!
10:57:34 <FunctorSalad> it's a pity they are made a bit impractical by lack of 'deriving' or TH support
10:57:46 <conal> FunctorSalad: yeah.  that part is a drag
10:58:12 <conal> work-in-progress, i hope
10:58:13 <jmcarthur_work> conal, speaking of GADTs, have you given MonadPrompt a good look yet? i spent a few minutes with it on Hammurabi last night and it feels really nice knowing that i can interpret the side effects of the game however i want from the top level
10:58:17 <jmcarthur_work> very testable and stuff
10:58:21 <jmcarthur_work> and pure!
10:58:27 <xian> Is there some way to make ghci print types with "explicit forall" enabled?
10:58:36 <FunctorSalad> conal: idea... make a regularly-typed "shadow" of the gadt and implement Show,Eq,Ord and so on by converting to that shadow first?
10:58:47 <conal> jmcarthur_work: no i haven't probed MonadPrompt
10:58:55 <Saizan> xian: :set -fglasgow-exts works
10:59:10 <jmcarthur_work> conal, it doesn't help get rid of IO at all, but it does feel a lot nicer than having IO at the bottom of a transformer stack
10:59:28 <xian> Saizan: Great, thanks.
10:59:42 <jmcarthur_work> and it's a great example of using GADTs well
11:00:15 * conal looks at MonadPrompt haddoc docs
11:00:34 <Berengal> Anyone here have any experience with happstack?
11:00:55 <hackagebot> buster 2.5 - Almost but not quite entirely unlike FRP (JeffersonHeard)
11:01:03 <Berengal> I just want to know how decent it is
11:01:12 <jmcarthur_work> Berengal, i use it off and on, nothing production yet
11:01:21 <jmcarthur_work> Berengal, i love it, but it still has a little work to do
11:01:33 <Berengal> jmcarthur_work: I can live with that...
11:01:42 <jmcarthur_work> Berengal, i would recommend it
11:02:06 <Berengal> Great :)
11:02:11 <jmcarthur_work> Berengal, and the nice thing is that it's modular, so if you don't like a particular component of it you don't have to use it
11:02:31 <jmcarthur_work> some people don't like State for example, or maybe they don't like Server. you can switch it out as you please
11:02:50 <Berengal> jmcarthur_work: Yeah, I noticed that as well. We all like modularity
11:03:31 <Berengal> I don't really have any experience doing web development. Figured I might as well learn it in haskell
11:04:27 <jmcarthur_work> Berengal, if you want to learn how it work it might be better to try FastCGI or something
11:04:32 <jmcarthur_work> *works
11:05:21 <humasect> making html (or any L!) from pure hs is fun
11:06:11 <jmcarthur_work> haskell has some excellent *ML generation libraries
11:06:25 <jmcarthur_work> my latest kick is HSP
11:06:29 <Berengal> jmcarthur_work: I already know the basics of it. I tend to pick up those things pretty fast, and usually well before I even start thinking about learning it for myself. I'm weird like that
11:06:30 <jeff___> what is ghc 6.10.3's "base" version?
11:06:55 <sm> 4.1.0.0 I'm guessing
11:10:10 <sm> yes, it is 4.1.0.0
11:10:58 <hackagebot> buster 2.51 - Almost but not quite entirely unlike FRP (JeffersonHeard)
11:11:34 <jeff___> the new hackage requirement that we specify the base version required is somewhat annoying
11:11:44 <jeff___> I used 4.0.0.0 and that didn't work
11:11:53 <conal> I've been thinking lately that different attitudes & beliefs about Haskell IO may come from different conceptions about what software is for.  My guess: some folks view software as about getting machines to do things, and others view machines as being there to help us look at ideas.  The first camp would see imperative programming as inescapable, since their goal is to perform side-effects.
11:11:57 <sm> cabal upload --check -v3 seems to be useful
11:12:00 <conal> The latter camp would see side-effects as incidental.  No more important in software (the description ideas) than pencils & paper are to a theory of numbers or telescopes are to a theory of how planets move in space.
11:12:00 <jmcarthur_work> i think it's typical to just say 4 instead of 4.x.x.x
11:12:37 <conal> open question: do you relate to one or the other of these camps?
11:12:39 <jmcarthur_work> conal, that sounds about right to me
11:12:52 <astroeggy> jmcarthur_work: I was looking at happstack and I did not understand a lot of the haskell elements such as monads and functors. Are there other frameworks recommended for also learning haskell while trying to do web development?
11:12:58 <jeff___> jmcarthur_work: but i thought you had to specify <=, I tried >, and that doesn't work
11:13:05 <conal> dons made a remark a few weeks ago that got me thinking along these lines.
11:13:06 <jmcarthur_work> i personally thing i relate to either camp in different situations
11:13:07 <jmcarthur_work> *think
11:13:39 <jmcarthur_work> astroeggy, happstack is probably one of the hardest libraries to learn for a beginner, sadly :(
11:13:52 <Berengal> conal: I agree. I'd like to think I belong to the camp that uses haskell to help me with ideas that just so happens to paint pretty pictures on the screen
11:13:55 <Beelsebob> conal: I think I relate to both camps
11:14:03 <SamB> conal: I view computers as useful for both
11:14:07 <Beelsebob> but not in independant ways
11:14:08 <jmcarthur_work> astroeggy, i think going with FastCGI is probably best because it can teach you how to use monad transformers well and stuff
11:14:08 <conal> i don't remember quite what dons said, but what i took away was that he sees haskell programming as being about driving imperative APIs.
11:14:12 <inimino> conal: I'm not sure that's a real distinction
11:14:25 <SamB> together, even!
11:14:25 <conal> inimino: as a personal statement?
11:14:36 <jmcarthur_work> conal, yeah, inimino sums up what i'm thinking
11:14:57 <Beelsebob> I think I agree with both inimino and jmcarthur
11:15:02 <jmcarthur_work> conal, in my mind, models are tools, and tools are used to get things done
11:15:08 <Beelsebob> I don't think the distinction works for me
11:15:21 <conal> Beelsebob: thanks.  a clear personal statement.
11:15:24 <humasect> the mind being the best tool of the bunch.
11:15:25 <yitz> conal: isn't that the underlying difference between the Turing-vonNeumann and Church-Curry formulation of foundations?
11:15:31 <yitz> formulations
11:15:40 <jmcarthur_work> a good model is extremely important for the tool to be useful, but doesn't make it not a tool
11:16:05 <conal> yitz: perhaps so.
11:16:29 <jmcarthur_work> a wrench doesn't do anything by itself. in that sense it is declarative. but it does have certain "side effects" which i rely on
11:16:40 <jmcarthur_work> that is only one way to look at it, of course
11:16:44 <conal> does anyone else here personally relate to one of these two goals much more strongly than another?  i do.
11:16:54 <jmcarthur_work> you could view the entire world as declarative, then there truly are no side effects
11:17:03 <inimino> I don't see them as seperate goals
11:17:11 <jmcarthur_work> but i think it is useful to classify things as side effects sometimes because it puts them out of scope
11:17:15 <gwern> oh noes, someone is invoking the parmendian 4-D block universe!
11:17:18 <yitz> conal: controllers are useless without information processing. Information processors are useless without being connected to the real world via a controller.
11:17:21 <Beelsebob> conal: I certainly relate to one more stongly than the other, but not as strongly as I suspect you do
11:17:29 <Berengal> I think of Haskell programming as doing stuff by describing what things are. That's about as useful a perspective as I can reason myself to.
11:17:52 <Beelsebob> yeh, what Berengal said
11:17:54 <gwern> but in a block universe how do we describe causality and computation, oh noes
11:18:24 <jmcarthur_work> to carry my wrench metaphor further... i can describe the wrench, but i can't create a wrench by only explaining how it is meant to be used
11:18:32 <jmcarthur_work> by its side effects, that is
11:18:34 * gwern has a sudden urge to go read some Dennett
11:18:43 <inimino> conal: you can't have a machine that helps you work with ideas if that machine doesn't do anything, and you can't have a machine do something you want without having it work with some ideas
11:18:49 <Baughn> In addition to the /read/ accessors for ADTs, has anyone done a TH hack that produces modification accessors?
11:18:56 <gwern> (or maybe judea pearl, now that I think about it)
11:18:56 <Berengal> jmcarthur_work: I think I could.
11:19:18 <jmcarthur_work> Berengal, a computer couldn't
11:19:20 <Berengal> jmcarthur_work: In the end though, we both do the same thing. The difference is just in our perspective
11:19:30 <jmcarthur_work> Berengal, exactly. i'm really trying to get at that
11:19:46 <yitz> gwern: how about nietzsche?
11:19:48 <jmcarthur_work> you can view the same problem in many distinct ways, depending on which is most convenient
11:19:58 <gwern> no, nietzsche is too fluxy
11:20:02 <yitz> gwern: or sartre?
11:20:16 * gwern is not in a light-hearted-enough mood for sartre
11:20:28 <jeff___> conal: I think that side-effects are a useful abstraction where the semantics of what is being modeled includes them.  for example, in a classically built computer, the laws of thermodynamics dictate that every computation *must* have a side effect
11:20:47 <yitz> gwern: well, ok, some heavy moliere
11:21:01 <gwern> maybe camus. 'a man is in an irc channel; you watch him gesture dumbly with his functions. You wonder why he is alive.'
11:21:42 <jeff___> whcih is some amount of energy loss.  To obscure that fact when one is modeling that effect would obscure the semantics.  There are other non-reversible processes out there to be modeled, and where we are specifically getting at the meaning of those processes, side effects are important
11:21:43 <jeff___> but
11:21:49 <conal> i've been wondering what's behind repeated insistence i run into, even here, that imperative programming is an inevitable part of our language, not just implementation.  i supsec that (monstly unconscious) leanings one way or another as i've described plays a role.
11:22:04 <hackagebot> hskeleton 0.1.1 - Skeleton for new Haskell programs (RobinGreen)
11:22:22 <conal> i was hoping for some help clarifying these orientations.
11:22:33 <conal> certainly not arguments about whether the distinction is valid.
11:22:50 <Berengal> conal: I personally don't think it's part of our language. It's part of our worldly implementation, but not the platonic ideal
11:22:52 <conal> since all new ideas start out as unpopular.
11:23:14 <jeff___> conal: I see the distinction as valid, and I think side effects largely are a shortcut that we resort to when we don't want to think to closely about the meaning of the problem at hand
11:23:25 <yitz> conal: I think if those leanings interfere, in eaither direction, the results will suffer.
11:23:32 <conal> jeff___: me too.
11:23:42 <yitz> jeff___: agreed
11:23:42 <Beelsebob> jeff___: I'm not entirely sure that's true... I suspect it's more to do with efficiency concerns
11:24:07 <Beelsebob> I don't think I resort to being imperative when I can't describe something
11:24:16 <Beelsebob> but instead when I don't think the computer can understand me
11:24:22 <conal> Beelsebob: yeah.  efficiency has often been an excuse for operational orientation.
11:24:23 <jeff___> Beelsebob: I also think a lot of programmers use the "efficiency" sledgehammer to exact all kinds of horrible punishment on themselves and their successors
11:24:26 <Berengal> jeff___: side-effects can be nice sometimes, to model certain problems. They should always be explicit though
11:24:54 <jeff___> berengal: exactly what I meant by saying that some problems' meaning (i.e. nonreversible processes) are naturally side-effectful
11:25:01 <jeff___> and these should be modeled that way to be clearest
11:25:35 <Berengal> From time to other I use imperative programming, e.g. State, when the problem I'm working on fits that paradigm well.
11:25:38 <conal> i hear people say things like "at the end of the day, the point is to get some side-effects", and it's never rung true for me.
11:25:46 <Berengal> It's very nice to get out of that paradigm with runState though
11:26:24 <jeff___> heh.  for me, at the end of the day, the point is that the computer and I are on the same wavelength about whatever problem I've been working on
11:26:27 <conal> Berengal: yeah.  that's state in the service of math/meaning.
11:26:53 <conal> jeff___: which is how i understand the goal of communication (generalizing from computer)
11:26:54 <yitz> conal: that's not the whole point at the end of the day. however, there are a lot of really nice things to learn about how information processors interact with the real world.
11:26:59 <inimino> conal: but isn't that true, for any program that you're actually going to run?
11:27:14 <conal> inimino: is it for you?
11:27:28 <Berengal> conal: Isn't this the classical distinction between software engineering and computer science?
11:27:37 <conal> Berengal: i don't know.
11:27:40 <Peaker> Why do the effects that I want have to be "side" effects? :-)
11:27:42 <inimino> conal: the point of /running/ a program is the side effects, of course
11:27:44 <inimino> otherwise why run it?
11:27:46 <inimino> conal: that may not be the reason why I'm writing it
11:27:46 <yitz> Berengal: if it is, it shouldn't be.
11:28:20 <Beelsebob> inimino: I suspect conal doesn't think of running a program
11:28:25 <Beelsebob> instead, looking at its value
11:28:29 <Berengal> yitz: Yeah, I'm not too fond of it myself
11:28:41 <conal> Beelsebob: right.
11:29:06 <inimino> Beelsebob: perhaps, but then you've just moved the side effects up into the interpreter/UI/OS/whatever
11:29:09 <Peaker> An implementation can map some ideas to some effects.  I think another way to state conal's camps above, is whether the ideas are what's important and what you're focusing on, or the effects they're mapped to
11:29:12 <conal> Beelsebob: for me, running just happens to be useful.  learning a denotation is my goal.
11:29:39 <conal> inimino: just as lazy functional programming moves side-effects into the RTS.
11:29:41 <Peaker> One guy wrote in Haskell-cafe, I think it was,  that a program's evaluation/execution is just one non-special view out of many possible views of the program
11:29:44 <Beelsebob> inimino: only because the computer hardware we happen to be using has an imperative undertone to it -- you wouldn't say you were "running a wrench" wile you look at it
11:29:48 <conal> so as to elevate our ability to describe/denote
11:30:09 <hackagebot> zeroth 2009.6.23 - ZeroTH - remove unnecessary TH dependencies (RobinGreen)
11:30:31 <yitz> conal: I like learning denotations, and also learning about how they map into an effect
11:30:42 <inimino> if you're writing for pedagogical purposes, then running the program is merely an interesting option
11:30:44 <Peaker> inimino: the running of the program yields effects that help understand the program.  The effects are only an intermediate entity that help understand something else - and not an end-goal
11:30:44 <ehird> zeroth depending on th?
11:30:45 <conal> i think these philosophical differences (which i don't believe are disagreements) are behind many of the disconnects we have on #haskell
11:30:46 <ehird> OH THE IRONY!
11:31:08 <sayyestolife> hey
11:31:30 <conal> Peaker: yes.  that description fits one of the camps i mentioned.
11:31:37 <jmcarthur_work> i think it's merely a matter of nounifying or verbifying things, something we do in natural languages all the time
11:31:38 <conal> Peaker: while inimino's statements fit the other.
11:31:46 <jmcarthur_work> conal likes nouns
11:31:57 <conal> :)
11:32:01 <ehird> nouning unweirds language.
11:32:05 <Berengal> At the end of the day though, we're all just writing code.
11:32:06 <sayyestolife> Is it possible to do a "stepper" function which starts at 10 then counts down to 0 and counts up again, with only a single input parameter?
11:32:11 <ehird> nouning unweirds communicating, even.
11:32:17 <conal> and, while people often argue about these things, i think the arguments are mainly confusions of preferences with beliefs.
11:32:31 <Berengal> conal: Yes, very much agreed
11:32:38 * jmcarthur_work also agrees
11:33:00 <Peaker> Berengal: I usually write my code at the beginning of the day
11:33:00 <gwern> sayyestolife: sure
11:33:19 <gwern> sayyestolife: the obvious way is with an auxiliary fucntion
11:33:20 <yitz> sayyestolife: homework?
11:33:21 <conal> personally, i weary of the arguments.  as if there were some underlying exclusive truth, rather than multiple perspectives, each a useful sub-view of a larger reality.
11:33:35 <Baughn> sayyestolife: There's no limit to the complexity of any one parameter
11:33:40 <sayyestolife> yitz, yep, I got a solution but it requires several parameters
11:33:47 <sayyestolife> Baughn hmm okay
11:33:52 <yitz> sayyestolife: paste your solution so far
11:33:54 <sayyestolife> gwern okay
11:33:55 <yitz> @hpaste
11:33:56 <lambdabot> Haskell pastebin: http://hpaste.org/new
11:33:58 <sayyestolife> it's in C# :)
11:34:11 <yitz> sayyestolife: ok, we'll forgive you :)
11:34:14 <gwern> oh no, it's *worse* than homework!
11:34:19 <jmcarthur_work> i think the biggest disconnect for me is that with an imperative mindset, you eventually can base your operational reasoning on some observable phenomenon of reality. with a declarative mindset, you eventually have to say "enough" and do something imperatively. for example...
11:34:21 <Berengal> > let foo n = [n..0] ++ [1..n] in foo 10
11:34:22 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
11:34:35 <Berengal> :/
11:34:41 <sayyestolife> eh uh, it doesn't work, give me a sec to rewrite it :)
11:34:45 <Berengal> > let foo n = [n, n-1..0] ++ [1..n] in foo 10
11:34:46 <lambdabot>   [10,9,8,7,6,5,4,3,2,1,0,1,2,3,4,5,6,7,8,9,10]
11:34:56 <jmcarthur_work> with a declarative animation library, eventually something uses the state of the animation to render a frame
11:35:10 <jmcarthur_work> how do you express this "capturing" of the state of the animation?
11:35:20 <conal> jmcarthur_work: i do think that perspective you just gave can as well be turned on its head.
11:35:34 <jmcarthur_work> agreed. i think it's two sides of the same coin
11:35:35 <conal> jmcarthur_work: to get an additional POV
11:35:50 <Baughn> jmcarthur_work: Can't we rewrite reality to fit?
11:36:25 <conal> when i look at pure FP, i see hidden doing put in the service of being (imperative serving functional).
11:36:33 <yitz> > let foo n = map abs [-n..n] in foo 10
11:36:35 <lambdabot>   [10,9,8,7,6,5,4,3,2,1,0,1,2,3,4,5,6,7,8,9,10]
11:36:48 <jmcarthur_work> what if i was writing a library for declarative animation. what kind of declarative api would allow me to do this?
11:36:59 <jmcarthur_work> not saying it is impossible, but there is a lot of thinking required
11:37:00 <monochrom> A stepper function that counts down from 10 to 0, then up from 0 to 10? So it's answer is 10 again at the end of the day? That's easy. And I have an optimized version for you: f = 10.
11:37:00 <conal> i personally like to think of the IO that haskell programs now perform as being doings that we haven't yet seen how to put in the service of being.
11:37:06 <ehird> jmcarthur_work: [farame,frame,frame,....]?
11:37:09 <ehird> *...
11:37:10 <jmcarthur_work> thinking which is not required in the imperative mindset
11:37:25 <jmcarthur_work> ehird, okay, then what steps over the elements of that list rendering the frames?
11:37:32 <ehird> jmcarthur_work: magic.
11:37:47 <jmcarthur_work> ehird, but that's the part i'm implementing. it can't be magic
11:38:03 <Baughn> yitz: But that's cheating, you're encoding the state of the stepper in the sign bit
11:38:24 <ehird> Baughn: for values of cheating equal to cute
11:38:25 <sayyestolife> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6186#a6186
11:38:29 <yitz> conal: IO is definitely a big step towards being from what came before, but I agree that it has a ways to go
11:38:43 <sayyestolife> atm it requires 2 extra parameters :/
11:39:02 <Baughn> ehird: I don't know about "cute". It's the sort of code I'd expect to see in C, where reuse of /presumably/ unused values is common.
11:39:37 <ehird> actually, I think yitz's use is fairly benign
11:39:42 <conal> jmcarthur_work: try on this idea: your imperative rendering is part of the implementation of function call in a purely functional framework.
11:39:42 <ehird> we throw away the sign bit anyway
11:40:04 <ehird> sayyestolife: erm you do want to write it in haskell right?
11:40:06 <ehird> not C#
11:40:26 <Baughn> ehird: Sure, but it's sort of like benign cancer. Fine for now, but you never know where it leads. ;)
11:40:30 <sayyestolife> ehird nope, it's an assignment (if I'm breaking any channel rules by discussing homework feel free to stop me)
11:40:34 <conal> jmcarthur_work: and so might get to go into the RTS (with stack-frame munging) instead of the language.
11:40:40 <jmcarthur_work> conal, right, but it's still imperative. my whole point is that you can't write of imperative completely. even though users of the library don't have to think about that stuff, the library developers do
11:40:42 <ehird> sayyestolife: This channel is about the Haskell programming language.
11:40:47 <ehird> C# is... not Haskell.
11:40:50 <Berengal> yitz: I was just thinking that I even think of IO values as /values/, not actions. The only action in my programs is '$ ./foo'
11:40:55 <jmcarthur_work> that may be a different language, sure
11:40:59 <yitz> Baughn: why is that cheating more than encoding it in the other bits?
11:41:16 <conal> jmcarthur_work: oh, you mean somewhere there has to be imperative stuff like stack frame munging and de-thunking?
11:41:25 <Baughn> yitz: For one thing, your function breaks when supplied with a negative value.
11:41:27 <sayyestolife> I know :), I started by asking a general question and then got told to post my code (even if it was i C#) so I did
11:41:33 <Baughn> yitz: It's /supposed/ to count down to -infinity
11:41:43 <ehird> sayyestolife: OK, but the end result is meant to be Haskell, right?
11:41:45 <jmcarthur_work> conal, well, on current computers
11:41:53 <sayyestolife> ehird nope, but nevermind I solved it I think
11:41:58 <jmcarthur_work> who knows about alternative designs
11:42:02 <ehird> Then I'm not sure why it's appropriate for #haskell...
11:42:23 <jmcarthur_work> it's an operational detail, i know, but sometimes i really want to tweak a rendering algorithm
11:42:34 <conal> jmcarthur_work: i could go either way on that one.  personally, i think of current computers as running on a purely functional substrate.  but it's really off the point i was wanting to explore.
11:43:07 <sayyestolife> ehird perhaps not
11:43:12 <monochrom> There are lots of things unexplanable about the human mind.
11:43:19 <jmcarthur_work> conal, my point is that the declarative abstraction has to end somewhere, and sometimes you want that to end in a different place than it actually does
11:43:21 <conal> jmcarthur_work: by the way, i do prefer to think of & describe rendering functionally.
11:43:23 <jmcarthur_work> that's when you get imperative code
11:43:28 <yitz> Berengal: it would be nice, but the way things are now it's hard to work the IO system at its best with that approach.
11:43:33 <ehird> monochrom: unexplainable? You mean "unexplained"
11:43:40 <ehird> They're atoms.
11:43:42 <jmcarthur_work> it's a flaw, i think, but perhaps an unavoidable one
11:43:45 <Baughn> conal: If you mean physics, that isn't purely functional per se; closer to prolog, really
11:43:46 <conal> jmcarthur_work: and the imperative abstraction has to end somewhere also, doesn't it?
11:43:47 <yitz> Baughn: who says? that wasn't part of the spec
11:43:57 <jmcarthur_work> conal, sure, but i was speaking in a hypothetical situation where the rendering code is where that division was
11:44:06 <monochrom> How do you know what I mean?
11:44:08 <conal> Baughn: yeah.  i'm simplifying to newtonian for now.
11:44:12 <Baughn> yitz: It's important to be able to invent missing bits of the spec out of thin air.
11:44:21 <jmcarthur_work> conal, yes, but that line could even be beyond the computer hardware
11:44:23 <yitz> Baughn: yep
11:44:30 <monochrom> Anyway, here is an example. A person doing C# asking in #haskell. That is unexplanable.
11:44:37 <jmcarthur_work> the computer is an imperative thing built in a declarative world
11:44:44 <ehird> monochrom: Heh
11:44:48 <conal> jmcarthur_work: yeah
11:45:06 <Berengal> yitz: It's a matter of perspective... and a healthy dose of double standards
11:45:12 <yitz> hehe
11:45:12 <Baughn> jmcarthur_work: Constraint-solving. The only declarations involved were the big bang and laws, which I don't think are very interesting /now/
11:45:18 <monochrom> Some other examples are grouped under "cognitive dissonance".
11:45:40 <jmcarthur_work> Baughn, that is assuming the presence of the big bang and the presence of "laws" ;)
11:46:10 <ehird> monochrom: That doesn't mean they're unexplainable about the mind, it just means we're not very rational.
11:46:13 <jmcarthur_work> for all we know the universe is entirely nondeterministic and we are living in a particular period which appears to have patterns ;)
11:46:14 <Baughn> jmcarthur_work: The presence of /some/ boundary condition at t=0 seems required for the implementation of time. As for the laws.. er, what other choice is there?
11:46:34 <jmcarthur_work> i'm getting off topic, is all
11:46:57 <Baughn> jmcarthur_work: And the universe we see if far more complex than I'd expect if it were random. The presence of sirius has no bearing on life on earth.
11:47:29 <yitz> Baughn: until it goes supernova
11:47:30 <ehird> 19:46 jmcarthur_work: for all we know the universe is entirely nondeterministic and we are living in a particular period which appears to have patterns ;)  fun idea
11:47:37 <jmcarthur_work> Baughn, if the universe is infinitely large, there is a 100% probability of exactly our portion of the universe existing somewhere
11:47:50 <jmcarthur_work> assuming it is random, i mean
11:48:29 <Baughn> jmcarthur_work: Yes, but there'd be a much /larger/ chance of living in a portion that is just like ours out to, say, ten light-hours and then just noise
11:48:40 <Gracenotes> oh noes!
11:49:01 <Baughn> Two to the power of a number large enough to make the googleplex look like zero
11:49:05 <Berengal> Baughn: It's a good thing we don't live there then. The night sky wouldn't be as pretty
11:49:09 <Baughn> *googolplex, doh
11:49:13 <jmcarthur_work> Baughn, you can't have larger than 100%. there is a 100% chance that there are an infinite number of *variations* of our known universe, under this model
11:49:17 <Gracenotes> heh
11:49:34 <jmcarthur_work> we could be having this conversation somewhere else in the universe right now
11:49:47 <Gracenotes> any monotonous function could make googleplex look like zero .. eventually ..
11:49:52 <Baughn> jmcarthur_work: I'm not talking about the probability, I'm talking about the ratios of one given state to another
11:50:09 <jmcarthur_work> Baughn, but we can't reason about *which* of those states we are in
11:50:44 <jmcarthur_work> even under classical assumptions, the probability of a planet supporting life like ours is pretty slim. and the probably that my "self" would take the form of what we believe to be the highest form of intelligence on this planet is even slimmer
11:50:46 <Baughn> jmcarthur_work: Sure we can. Importantly, there are a lot more where every part of the near universe except that required for us to live is noise, than otherwise.
11:50:50 <yitz> conal: for a long time, we were way off to an imperative-think extreme, for various historical reasons. so that now it's hard to know how much functional-think is reasonable and how much is extreme in the other direction. We're still exploring that.
11:50:58 * Berengal lets all this philosophy and talk of infinity wash the java ejb grime off of him
11:51:01 <jmcarthur_work> i think ratios and probabilities are pretty meaningless in an infinite universe
11:51:08 <ehird> there's a copy of us where we're not having this debate
11:51:09 <ehird> :)
11:51:25 <Baughn> jmcarthur_work: Instead, what we see is a universe that looks like our local state evolved from older ones
11:51:34 <yitz> > infinity `seq` 42
11:51:36 <lambdabot>   42
11:52:02 <jmcarthur_work> Baughn, but does that affect the theory whatsoever?
11:52:15 <conal> yitz: i like that piece about where we are & why.  thx.
11:52:24 <Baughn> jmcarthur_work: Well, yes, since we don't see what you'd expect if the universe were random
11:52:32 <jmcarthur_work> do your observations really mean you can conclude that we don't suddenly turn into "white noise" within the next second?
11:52:43 <jmcarthur_work> heck, your memories could be false, as well
11:52:56 <Baughn> It means I can assign a ridiculously low probability to it
11:53:04 <jmcarthur_work> sure
11:53:19 <conal> hm.  ridiculously improbable things are bound to happen.
11:53:19 <yitz> conal: the frp project is a really important step in that exploration imho. wherever it leads, we are going to know a lot more.
11:53:20 <jmcarthur_work> this is way off topic
11:53:21 <Baughn> Which is the only thing I can /ever/ do for /anything/, so I'm not sure what you're asking
11:53:28 <ehird> conal: by what logic?
11:53:30 <SamB> jmcarthur: personally, I'd just say "wait and see"
11:53:31 <Baughn> conal: No, ridiculously improbable things never do, in fact, happen
11:53:31 <conal> yitz: :) !
11:53:34 <pikhq> jmcarthur_work: Clearly, we are all merely figments of the universe's imagination.
11:53:37 <SamB> except that would take me more than one second
11:54:03 <Baughn> conal: Of course, "never" just means "a nearly infinite amount of time, on average"
11:54:18 <monochrom> Use the haskell probability monad to prove your claims. It's a better use of that monad than finance contract whatever.
11:54:26 <conal> everything that happens is infinitely improbable if you look at enough detail about it.
11:54:43 <jmcarthur_work> that's exactly what i was trying to get at
11:54:45 <SamB> anyway, it's not worthwhile taking such possibilities into consideration, since there is no way to prepare for such an eventuality ;-)
11:54:55 <jmcarthur_work> right
11:54:55 <conal> jmcarthur_work: i thought so.
11:54:57 <Baughn> conal: Only if the total state of the universe is aleph-0 or higher
11:55:07 <Baughn> *in size
11:55:26 <conal> Baughn: you mean if the number of possible universe states, right?
11:55:42 <Baughn> conal: No, I mean the size of the actual current state
11:55:59 <Baughn> conal: Although, I'm a bit doubtful about the definition of "chance" here
11:56:20 <jmcarthur_work> is state even a meaningful thing to talk about in a possibly declarative universe? ;)
11:56:35 <Baughn> conal: The universe's state space might grow as time passes (though according to our laws it doesn't), but if it started out finite it'll never actually become infinite
11:56:39 <yitz> Baughn: that is an old debate, the greek thought about it
11:56:42 <yitz> greeks
11:56:55 <yitz> ancient greeks. aristotle and friends.
11:56:55 <Baughn> jmcarthur_work: Sure. Then it's just "state at time <now>", which is what I meant anyhow. :P
11:57:02 <conal> jmcarthur_work: i also like your idea of local anomalies that give rise to order -- including the anomaly of intelligence to see the order and mistakenly conclude that the order is at all normal
11:57:05 <Baughn> yitz: Yep, and they got it horribly wrong too. :P
11:57:14 <yitz> Baughn: how do you know?
11:57:40 <yitz> Baughn: (aristotle claimed it's infinite)
11:57:50 <Baughn> yitz: Bayes' theorem. Everything I've ever read about their thoughts has turned out to, under close examination, be wrong; therefore chances are the rest of their thoughts are too.
11:57:53 <jmcarthur_work> conal, a nice way to put it!
11:58:03 <yitz> Baughn: ah, good thinking.
11:58:13 <conal> Baughn: i do tend to think of there being infinitely many -- even uncountably many -- possible states.  if finite, we drop from infinitely improbably to incredibly unlikely.
11:58:14 <Baughn> yitz: That's not to say they weren't important, but much like Newton, their ideas were merely preliminary.
11:58:19 <hackagebot> zeroth 2009.6.23.2 - ZeroTH - remove unnecessary TH dependencies (RobinGreen)
11:58:19 <conal> jmcarthur_work: :)
11:58:19 <monochrom> Good Greeks! The Greeks thought of Aleph-0?
11:58:30 <yitz> monochrom: not exactly
11:58:40 <Baughn> conal: Not much of a drop at all. Infinitely improbable events happen every time you pick a number from a finite continuum.
11:58:40 <ehird> isn't this a very -blah topic?
11:58:41 <conal> i like that juxtaposition of zeroth and Aleph-0.
11:59:01 <conal> Baughn: "finite continuum"??
11:59:03 <monochrom> Yeah I even tried to mention haskell...
11:59:13 <Baughn> conal: Like, "0 through 1 on R"
11:59:14 <conal> Baughn: measure?  cardinality?
11:59:25 <jmcarthur_work> is 0 through 1 really finite?
11:59:30 <conal> Baughn: finite measure, infinite cardinality.
11:59:31 <monochrom> hahahahaha
11:59:44 <conal> Baughn: now you're saying what i was saying, iiuc.
11:59:47 <monochrom> (Are you trying to do a zeno thing?)
11:59:49 <jmcarthur_work> heh
12:00:24 <Baughn> conal: Sure, but the thing is that the most recent laws of physics point towards a quantized universe
12:00:28 <yitz> this is beyond #haskell-blah. we need #haskell-aleph-0.
12:00:34 <jmcarthur_work> actually, it's highly probable that the number i pick has fewer than 1000000000000000000000000000000000000 decimal digits when written out
12:00:37 <Baughn> conal: Though IIRC there was some contradicting data from Hubble..
12:00:39 <monochrom> hahaha
12:01:05 <conal> Baughn: which, as i said, is fine.  doesn't matter much.
12:01:09 <monochrom> Next year we'll say "this is beyond #haskell-aleph-0, we need..."
12:01:35 <pikhq> jmcarthur_work: Yes. That's because human RNGs are inherently weighted. :P
12:01:37 <conal> whether the state space has infinite cardinality or just huge.
12:01:42 <jmcarthur_work> pikhq, ;)
12:01:44 <monochrom> And then we'll fight over whether it's #haskell-aleph-1 or #haskell-c.
12:02:02 <ehird> #haskell-x-equals-aleph-x
12:02:17 <Baughn> conal: Well, since thermodynamics claims the state space is conserved, then if it's already finite it also can't grow and infinite life is impossible
12:02:30 <yitz> #haskell-fix-aleph
12:02:40 <conal> jmcarthur_work: there's a story related to your idea of anomalous locally ordered pockets in a disordered universe.
12:02:53 <jmcarthur_work> Baughn, these laws we observe could only be localized
12:03:02 <jmcarthur_work> eh, i'm sort of repeating myself now
12:03:05 <Baughn> jmcarthur_work: Then there'd be deeper laws that are global
12:03:14 <jmcarthur_work> that's an assumption
12:03:19 <Baughn> jmcarthur_work: But the problem is, thermodynamics works for a /huge/ number of possible laws
12:03:22 <hackagebot> xformat 0.1 - Extensible, type-safe formatting with scanf- and printf-like functions (SeanLeather)
12:03:43 <jmcarthur_work> for a huge number of possible _locally observable_ laws
12:03:45 <Baughn> jmcarthur_work: ..no, it's not an assumption. *Something* happens. Even if it's just "random stuff happens", that's still a law.
12:03:56 <jmcarthur_work> random is a law?
12:03:58 <skorpan> oooo more printf
12:04:07 <jmcarthur_work> conal, oh?
12:04:11 <conal> jmcarthur_work: people in our culture tend to believe that the past is at least somewhat useful in predicting the present & future.  but i don't think there's any evidence that isn't circular.
12:04:11 <monochrom> global_law = unsafePerformIO (randomIO >>= newIORef)
12:04:18 <Berengal> Law of the universe #1: "Stuff happens. Maybe"
12:04:38 <conal> jmcarthur_work: in other words the correlation has always held in the past.
12:05:00 <voker57> is there an easy way to get docs on installed packages (like on hackage) on localhost?
12:05:08 <monochrom> Law of the universe #0: "The universe exists. Maybe"
12:05:14 <Berengal> voker57: cabal haddock
12:05:22 <conal> jmcarthur_work: another culture could have the very opposite belief and point to overwhelming evidence as well.
12:05:28 <Baughn> monochrom: Why is there just a universe instead of nothing?
12:05:35 <jmcarthur_work> conal, all our inferences rely on an initial assumption of causality, anyway
12:05:37 <Beelsebob> monochrom: type Universe = Maybe Universe?
12:05:40 <voker57> Berengal: that's only for one package, and it requires unpacked sources and .cabal
12:05:57 <conal> jmcarthur_work: yes, which i personally don't buy.
12:06:06 <Berengal> voker57: Sounds like you've got yourself a project :)
12:06:07 <voker57> can write a script, probably, but this is not too convenient...
12:06:18 <monochrom> I don't know.
12:06:19 <deavid> hello, I'm starting to learn Haskell this week
12:06:32 <jmcarthur_work> i don't buy it on a mathematical level. i see causality as an assumption of science which mathematicians needn't be bothered by
12:06:37 <conal> deavid: cool!  welcome.
12:06:38 <monochrom> If you find out, you can write a law #-1.
12:06:49 <voker57> Berengal: i think i'll cowardly write a script to fetch docs for latest version from hackage
12:06:52 <Baughn> deavid: ..don't worry about the philosophy, we went a little berserk there for a while.
12:06:57 <jmcarthur_work> but i still see science, with is assumptions, as a practically immensely useful concept
12:07:12 <deavid> I'm a bit confused about how to solve several problems in functional programing
12:07:32 <deech> Hi all, I am trying to use HXT to gather up text from all nodes with a certain name, and return it in a tuple with another node. So given 3 child nodes called "kid" containing "a", "b" and "c", and 1 child node called "name" containing "A", I want to return ("A", [a,b,c]). My current code at http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6187#a6187 returns ("A","a")("B","b")("C",)
12:07:35 <Berengal> deavid: We all are at times :)
12:07:39 <Baughn> jmcarthur_work: Actually, modern physics does not entirely care about causality..
12:07:47 <wli> I'd regard mathematics as science, and causality an issue of empirical science.
12:07:50 <deech> That's ("C","c")
12:07:53 <Baughn> jmcarthur_work: The basic laws are time-agnostic, and then there are things like the post-selection "paradox"
12:07:57 <conal> jmcarthur_work: my personal beef with causality is mainly with the idea of "the" cause of an effect.  often implicit in the question "why".  i'm nearly always dissatisfied with "why" questions.  they can go so many different ways.
12:08:03 <jmcarthur_work> wli, okay i can run with that definition
12:08:09 <deavid> I was taking a look to the "Secret Santa" example, and is a bit weird that, it is nessesary to calculate all posibilities to, after that, choose one of them.
12:08:38 <Berengal> conal: This is why it's science, not mathematics
12:08:42 <deavid> I'm wondering if functional programming can do all things that imperative ones do
12:09:04 <Berengal> @faq Can haskell do everything imperative languages can?
12:09:04 <lambdabot> The answer is: Yes! Haskell can do that.
12:09:16 <monochrom> I think deavid precisely wants to join our imperative discussion. :)
12:09:19 <jmcarthur_work> deavid, it's proven that is the case, on a computational level
12:09:26 <conal> Berengal: it's more than just science.  it's reductionism.  it's seeing the universe as splittable instead of intrinsically whole.
12:09:34 <deavid> I find several problems very simpler in python than haskell (the Secret Santa is one of these)
12:09:48 <jmcarthur_work> deavid, at worst, an imperative algorithm can be implemented with an extra log n factor, but usually this is avoided
12:09:58 <conal> deavid: there can be many reasons why you find those programs simpler in phython.
12:10:12 <Berengal> deavid: Functional programming is very different at first. It takes some time to rewrite your brain
12:10:16 <conal> deavid: some intrinsic to the problems and some more about your previous experience
12:10:24 <deavid> Berengal: I' trying to.
12:10:36 <Berengal> jmcarthur_work: I thought lazyness could take care of that extra log n for you?
12:10:38 <deavid> I ve written several small pieces of code to try it
12:10:38 <conal> deavid: hanging out here will probably help
12:11:01 <jmcarthur_work> Berengal, consider emulating pointers with an IntMap. laziness won't help you there
12:11:17 <conal> that's my recollection also.
12:11:20 <jmcarthur_work> Berengal, it is hypothesized that laziness may be able to get around that restriction
12:11:24 <jmcarthur_work> Berengal, but not proven
12:11:38 <conal> does anyone remember that paper about *laziness* eliminating the theoretical overhead of pure functional programming, relative to imperative?
12:11:39 <jmcarthur_work> the original proof is about strict functional programming
12:11:47 <Berengal> jmcarthur_work: Ah, right. No proof yet... I knew there was something there...
12:12:02 <conal> jmcarthur_work: yeah.  and there was a follow-up paper about laziness, iirc
12:12:11 * jmcarthur_work hasn't read that
12:12:12 <jmcarthur_work> brb
12:12:23 <Berengal> conal: I have that paper around somewhere...
12:13:35 <Berengal> As far as I gathered, it only proved that lazyness removed the log n on one algorithm, not all...
12:13:37 <conal> Berengal: cool.  please let me/us know if you find it.
12:14:06 <conal> maybe it was just showing that the other paper's proof is limited to strict functional languages.
12:14:16 <conal> leaving the question open for lazy languages
12:14:38 <deech> Any help is appreciated.
12:15:06 <ehird> erm haskell by equivalence of the lambda calculus has the same time complexities as a turing machine no?
12:15:09 <Berengal> @go More haste, less speed: lazy versus eager evaluation
12:15:15 <lambdabot> http://portal.acm.org/citation.cfm?id=969871
12:15:15 <lambdabot> Title: More haste, less speed: lazy versus eager evaluation
12:16:09 <jmcarthur_work> ehird, i think it only means that the same computations can be carried out in finite time
12:16:12 <conal> Berengal: yeah.  that's the one i was trying to remember.  thanks!
12:16:15 <jmcarthur_work> not necessarily in the same complexity
12:16:32 <hackagebot> zeroth 2009.6.23.3 - ZeroTH - remove unnecessary TH dependencies (RobinGreen)
12:16:38 <ehird> well i've yet to find a problem where imperative languages are inherently faster :p
12:17:10 <deavid> there are some couple of things that are more friendly to imperative ones
12:17:18 <deavid> (and faster)
12:17:23 <Berengal> I usually find functional programs faster than imperative ones: They're much faster to write
12:17:24 <jmcarthur_work> ehird, modify a cyclic list
12:17:33 <ehird> jmcarthur_work: define modify
12:17:34 <conal> in practice, it's a pretty complicated question.  sometimes imperative solutions are slower because of paranoia around copying data to avoid accidental mutation.
12:17:57 <deavid> Berengal: and whay about Python vs Functional languages? :
12:18:00 <conal> or slower because programmers and compilers can't understand the code's properties crisply enough to do aggressive optimizations.
12:18:04 <deavid> I find Python very fast to write
12:18:14 <jmcarthur_work> ehird, change any of the values in the list such that continuing around the cycle will lead to the same observations each time
12:18:27 <Berengal> deavid: I prefer Haskell to python, even though python is my favorite imperative language
12:18:30 <conal> deavid: mostly depends on your experience.  as with any tool.
12:18:33 <ehird> deavid: Because you are used to it.
12:18:39 <Berengal> Well, I tend to write mostly functional in python these days
12:18:57 <deavid> so, that why I'm asking; i want to hear opinions from some other people used to haskell
12:19:15 <Peaker> I have written probably more than 200,000 or 300,000 lines of Python code, and probably less than 20,000 Haskell lines.  So I still write much faster in Python, but greatly prefer Haskell
12:19:16 <ehird> jmcarthur_work: change? define change
12:19:22 <jmcarthur_work> deavid, i have never hit a practical limitation in functional programming
12:19:24 <hzap> deavid: i find Haskell pretty fast to write too, comparable to python
12:19:43 <deavid> that's good :-)
12:19:44 <jmcarthur_work> ehird, it doesn't have to be a mutation, but it needs to be constant time as a mutation could do
12:19:53 <Peaker> Some stuff I already write much faster in Haskell.  But zero-to-working-implementation is still faster in Python for me.  Just a matter of experience
12:19:58 <ehird> jmcarthur_work: your problem is trying to apply terms like changing to a functional language
12:19:58 <Berengal> My python loc/h is way higher than my haskell loc/h, but my haskell loc/prog is much much lower
12:20:03 <deavid> there are easy database examples for haskell ?
12:20:04 <jmcarthur_work> ehird, make a copy then
12:20:05 <ehird> if you give me a well-define problem instead...
12:20:11 <jmcarthur_work> the same problem applies
12:20:22 <deavid> i'm interested in the DB related programs
12:20:32 <tibbe_> Warning: This package indirectly depends on multiple versions of the same
12:20:33 <tibbe_> package. This is highly likely to cause a compile failure.
12:20:33 <tibbe_> package network-bytestring-0.1.2.1 requires network-2.2.1.1
12:20:33 <tibbe_> package hyena-0.1 requires network-2.2.1.3
12:20:58 <ehird> deavid: what in particular?
12:20:59 <tibbe_> why can't cabal just pick a high enough version number?
12:21:02 <ehird> interfacing with a db?
12:21:12 <skorpan> tibbe_: because versions may be incompatible with one another
12:21:16 <sjanssen> tibbe_: rebuild network-bytestring against a newer version of network
12:21:17 <jmcarthur_work> i want a mutation such that cycle [1,2,3,4] can be created using cycle [1,2,0,4], but you may use an alternative data structure if you wish
12:21:18 <ehird> deavid: http://hackage.haskell.org/packages/archive/pkg-list.html#cat:database
12:21:19 <monochrom> The Takusan library is easy DB programming for Haskell.
12:21:22 <deavid> ehird: yes, querying the database, update some data, cursors... etc.
12:21:24 <ehird> deavid: a whole bonanza of database things
12:21:25 <tibbe_> sjanssen: this is on hackage
12:21:25 <jmcarthur_work> ehird, ^^
12:21:27 <Saizan> tibbe_: are you using runghc Setup or cabal?
12:21:32 <tibbe_> sjanssen: so I can't rebuild
12:21:51 <ehird> jmcarthur_work: you said "mutation" again
12:22:11 <tibbe_> skorpan: but my dependencies specify that (taking the union) network >= 2.2.1.3 will work
12:22:13 <monochrom> mutation is graph rewriting
12:22:17 <zloog> deavid: RHW has a database chapter that should be enough to get started on
12:22:28 <ehird> monochrom: then e should have said that
12:22:34 <jmcarthur_work> ehird, we often use words like "modify" to define creating slightly different versions of a pure structure. it's a common idiom. you are being nit picky
12:22:34 <hzap> deavid: haskell code using a DB probably looks very similar to a python version
12:22:41 <monochrom> who is e?
12:22:44 <ehird> jmcarthur_work: because this whole discussion is about semantics of such things
12:22:53 <ehird> monochrom: e, eir. Spivak pronouns.
12:23:00 <monochrom> I see. He.
12:23:13 <ehird> i prefer to stay gender-neutral (when i remember).
12:23:27 <hzap> deavid: the code that does the SQL, at least
12:23:37 <monochrom> except e is also 2.71828... so I can't be sure ever.
12:23:38 <sjanssen> tibbe_: I don't think Hackage uses cabal-install's smart dependency satisfier
12:24:01 <Saizan> tibbe_, sjanssen: yeah, the log says "setup configure"
12:24:04 <tibbe_> sjanssen: eek, what am I supposed to do? my dependencies are correctly specified
12:24:20 <conal> ehird: maybe you're using "mutate" in a narrower sense than jmcarthur_work.  it does have other meanings.
12:24:20 <tibbe_> Saizan: it's being built by hackage
12:24:35 <Peaker> conal: Intuition tells me that laziness does not remove the constant overhead in the general case.  At least if you allow for O(1) array mutation by index (which is a bit problematic, IMO)
12:24:38 <conal> ehird: e.g., genetic mutations are functional.
12:24:57 <tibbe_> sjanssen: having to match the indirect dependency versions in a package doesn't sound scalable
12:24:58 <ehird> conal: well, yes; but using the terminology "mutate" in terms of an algorithm specification is inherently biased towards imperativeness
12:25:07 <Saizan> tibbe_: you're supposed to do nothing.
12:25:21 <Saizan> tibbe_: the build failure is known to not be accurate.
12:25:29 <tibbe_> Saizan: but my package is missing documentation because of it :(
12:25:32 <sjanssen> tibbe_: you might be able to ask dcoutts to rebuild the network-bytestring package on hackage
12:25:36 <conal> ehird: if jmcarthur_work didn't mean it that way, then it's not inherent.
12:25:40 <Peaker> conal: but if you recognize that the O(1) array item access is non-sense in the theoretical sense, and that its actually O(logN) I think there's no overhead constant at all
12:25:42 <tibbe_> sjanssen: yes
12:25:45 <tibbe_> @seen dcoutts
12:25:46 <lambdabot> dcoutts is in #haskell-soc, #haskell-iphone, #haskell-in-depth, #gentoo-haskell, #darcs, #ghc, #haskell-overflow and #haskell. I last heard dcoutts speak 4h 29m 24s ago.
12:25:47 <sjanssen> tibbe_: I'd say that building every package on hackage is what is not scalable
12:25:57 <conal> oh -- "inherent" and genetic mutations.  i just got the joke.
12:26:09 <ehird> conal: it wasn't a joke, I had two separate clauses
12:26:10 <Saizan> tibbe_: you might also help with hackage-server so that build reports and documentations can be uploaded, instead of generated on the server
12:26:11 <tibbe_> sjanssen: perhaps
12:26:18 <ehird> but i can't figure out how to interpret his sentence genetically
12:26:38 <tibbe_> Saizan: I'm busy working on hyena and a new event notification library for GHC ;)
12:26:45 <jmcarthur_work> ehird, let's just start with a fresh one then
12:26:50 <jmcarthur_work> i have a doubly linked list
12:27:07 <jmcarthur_work> i want to create a new doubly linked list that is the same as the old one with one element changed
12:27:14 <ehird> data LL a = Nil | LL a (LL a) (LL a).
12:27:15 <monochrom> why doubly linked list. stupidest data structure ever.
12:27:26 <Peaker> monochrom: Why?
12:27:43 <Peaker> monochrom: it allows O(1) insertion, removal of any item, and iterating in both directions in cheapest O()
12:27:43 <ehird> jmcarthur_work: ok; how is this element identified? how is the element transformed?
12:27:50 <Berengal> jmcarthur_work: And where the old list can be discarded/reused, I suspect?
12:27:54 <monochrom> State a real world problem rather than one of those stupid shootout problems "you must use a doubly linked list for no reason".
12:28:09 <Peaker> monochrom: this comes at the expense of sharing tails, but sharing tails is not always desirable
12:28:50 <jmcarthur_work> ehird, Berengal: i said a new one to be precise, but it must be able to compete with an imperative version in which mutation is legal
12:28:53 <sjanssen> jmcarthur_work: in Haskell, you'd just use a zipper instead of a doubly linked list
12:28:59 <jmcarthur_work> Berengal, it is not important that the old one stick around
12:29:00 <ehird> 20:27 ehird: jmcarthur_work: ok; how is this element identified? how is the element transformed?
12:29:07 <monochrom> Peaker: what sjanssen says, for example.
12:29:29 <Peaker> monochrom: It doesn't give you the same complexities and constant factors
12:29:35 <monochrom> Some people really know how to rig a performance debate.
12:29:58 <ehird> monochrom: yeah, totally
12:30:07 <ehird> of course certain data structures will be slower
12:30:18 <ehird> but you can always use a more appropriate one for a functional language
12:31:01 <Peaker> I agree there are reasonable alternatives for doubly-linked lists.. But I strongly disagree with monochrom that they're useless..  I think that they are very useful data structures for efficient imperative implementations of some things
12:31:07 <monochrom> Peaker: I know. But consider this other way to carry out the debate. We open with "I have a persistent FIFO queue."
12:31:52 <jmcarthur_work> sjanssen, the pure zipper breaks if it's a doubly linked *and* cyclic
12:31:55 <jmcarthur_work> list
12:31:59 <Peaker> monochrom: Even doubly-linked lists having really nice constants is a nice useful property of them
12:32:32 <Peaker> They're also pretty good with cache locality (But I guess every truly O(1) operation almost must be)
12:33:30 <Peaker> They're very useful in C code, as they're also pretty easy to implement in a general manner (ala Linux Kernel's list macros)
12:34:10 <Peaker> monochrom: another nice property is that they let you bury the data structure's costs into the elements, and not require any additional memory when the lists grow/shrink
12:34:42 <Peaker> IMO, doubly-linked lists must be one of the more useful data structures out there ;-)  Even if not the nicest from a denotational point of view
12:38:04 <monochrom> Peaker, we all love doubly linked lists in imperative languages. It is inappropriate to impose "how do you do *that*!" on functional languages and conclude "therefore slower".
12:38:26 <Peaker> monochrom: I agree..
12:38:26 <habitue> Hey could someone tell me why my newtype at http://gist.github.com/134778 is unable to be auto-derived as a monad?
12:38:47 <soupdragon> the fact is that imperative languages are more expressive.. ?
12:38:48 <Peaker> monochrom: my rant is just about: <monochrom> why doubly linked list. stupidest data structure ever.
12:39:22 <Peaker> soupdragon: IMO: Lower-level imperative languages are more expressive about operational semantics, and less-so about denotational ones.  And high-level functional languages are the opposite
12:39:37 <jmcarthur_work> is there a reasonable zipper for http://upload.wikimedia.org/wikipedia/commons/f/fe/Btree.svg ?
12:39:37 <monochrom> It's to be dramatic. :)
12:39:41 <ehird> soupdragon: for definitions of fact that are equal to incorrectness
12:40:20 <soupdragon> jmcarthur_work:  I'd doubt it a bit, those red lines throw a spanner in the works
12:40:29 <Peaker> C makes it easy to reason about operational semantics.  Haskell makes it easy to reason about denotational semantics
12:40:32 <soupdragon> lines coming from red boxes*
12:40:52 <Peaker> I still await a language that makes it easy to reason about both (Probably involving heavy dependent types)
12:41:08 <soupdragon> I don't think that relates to expressivity though
12:41:14 <monochrom> The fact is that imperative languages are more comfortable to control freaks. It's written all over the definition of "imperative": you give hand-holding orders.
12:41:27 <jmcarthur_work> I still await a language with heavy dependent types that makes it easy to reason about.
12:41:50 <soupdragon> resoning about programs is never going to be easy
12:42:21 <jmcarthur_work> reasoning about programs is going to be measured in computational complexity
12:42:40 <soupdragon> what do you mean?
12:43:02 <monochrom> Programming is never going to be easy.
12:43:26 <monochrom> I have found for myself that reasoning about programs is the same effort as programming.
12:43:41 <jmcarthur_work> soupdragon, how many branches of logic must be covered to come up with a provable implementation for a specification
12:43:46 <monochrom> The same effort and the same result.
12:43:59 <jmcarthur_work> err, s/ of logic//
12:44:45 <conal> @where liberated
12:44:45 <lambdabot> http://www.stanford.edu/class/cs242/readings/backus.pdf
12:45:09 <monochrom> My experience differs from what most people claim. I think it is because I write programs by Intelligent Design; other people use Natural Selection.
12:45:38 <jmcarthur_work> especially as we make our languages closer and closer to specifications, compilers will have to do more and more work to check and optimize them practically
12:46:08 <Peaker> monochrom: self-proclaimed Intelligence! :-)
12:46:26 <jmcarthur_work> and it will eventually twist around such that we view the compiler as doing much of the programming
12:46:31 <jmcarthur_work> the "tedious part" of programming
12:46:35 <conal> "X is never going to be Y" :p
12:46:57 <copumpkin> 'never' is never going to be 'possibly'!
12:47:06 <soupdragon> conal: Should we never say "X is never going to be Y"?
12:47:34 <conal> "They are ill discoverers that think there is no land, when they can see nothing but sea." - Francis Bacon
12:47:39 <Peaker> soupdragon: you should only say so if you have proof, not based on past experience/intuition/etc without at least an unsureness disclaimer
12:48:03 <conal> not merely proof by lack of imagination
12:48:56 <ehird> 20:48 lambdabot:  "Falsifiable, after 164 tests:\n[\"\\44389\\596659\\562239\\498043\\591429\...
12:48:58 <ehird> -- what's the case here?
12:54:17 <djahandarie> Is there anything like dropWhile but the opposite? Like... dropUntil?
12:54:47 <djahandarie> Oh wait
12:54:51 * djahandarie hits self
12:54:53 <monochrom> I don't know "opposite".
12:55:20 * tibbe wishes there were some more interesting workshops on the Friday of ICFP week
12:56:19 <uzytkownik> How to understend RWS monad?
12:56:34 <monochrom> I once overheard two students discussing homework for a logic course. "The opposite of "everyone" is "no one", right?" He was right, but the negation of "everyone" is still "someone doesn't". The word "opposite" has too many meanings, or no meaning.
12:57:27 <uzytkownik> @hoogle: dropWhile
12:57:27 <lambdabot> Maybe you meant: hoogle hoogle+
12:57:28 <skorpan> monochrom: it could also be ambiguous, so it has three meanings
12:58:07 <uzytkownik> djahandarie: AFAIU you you mean dropWhile . not
12:58:27 <monochrom> three is too many.
12:58:38 <Igloo> tibbe: Come along to CUFP, and see if you can get tips on enlightening Google? Or failing that, it's a day to see the town!
12:58:55 <tibbe> Igloo: :)
12:59:02 <skorpan> hm, you could say that "is the opposite of" is not symmetric
12:59:08 <tibbe> Igloo: sounds good
12:59:35 <tibbe> Igloo: but I won't be attending ICFP per say but only fly down Wednesday night and stay to Sunday
12:59:47 <idnar> skorpan: I'd just say that it's imprecise :P
12:59:48 <djahandarie> uzytkownik, I wanted takeWhile
12:59:52 <tibbe> Igloo: so only 3 days of activities
13:00:01 <djahandarie> I just fail at searching stuff
13:00:01 * Heffalump wonders about the hackathon situation
13:00:02 <djahandarie> :P
13:00:04 <skorpan> idnar: even if it were precise, it wouldn't be symmetric
13:00:10 * skorpan is trying hard
13:00:14 <conal> monochrom: maybe it's that "opposite" isn't compositional.
13:00:16 <Igloo> Heffalump: I'll be at the Hackathon on the 6th/7th
13:00:16 <ehird> What should I use for regexps?
13:00:23 <Igloo> Heffalump: Even if that just means me in my hotel room  :-)
13:00:28 <idnar> skorpan: that would only be true if you made it precise in a way that doesn't make it symmetric :P
13:00:41 <conal> or that it is, but not as simplistically.
13:00:46 <Heffalump> why would you stay in Edinburgh for those days?
13:01:01 <monochrom> Generally, any time you see an involution you can call it "opposite". It is like category theory. You can use it in many ways.
13:01:06 <Igloo> Because I wanted to get everything booked
13:01:08 <uzytkownik> djahandarie: :) I based on your 'Like... dropUntil?' dropWhile . not does more or less the drop until.
13:01:15 <Heffalump> you can still cancel it though
13:01:23 <tibbe> Igloo: hackathon?
13:01:34 <skorpan> idnar: using that reasoning i can say that everything is imprecise
13:01:34 <Berengal> So I'm going through the cafe, and there's this post about how to create a list, ["a", "b", "c", "aa", "ab", "ac, "ba" ...]. I came up with 'foo = map (:[]) ['a'..'z'] ++ ((:) <$> ['a'..'z'] <*> foo)', but I can't figure out the big-O for getting element n...
13:01:38 <Igloo> Yes, but if I have to buy a late train ticket then it probably won't actually save much
13:01:48 <tibbe> Igloo: do you know if I would need to pick one of the three DEFUN lectures in the morning, one of the three in the evening, etc?
13:01:57 <jmcarthur_work> maybe it's simply that opposite does not necessarily imply inverse
13:02:06 <Igloo> tibbe: I don't know. DEFUN was new last year, and I wasn't there
13:02:06 <jmcarthur_work> night is not the inverse of day
13:02:21 <jmcarthur_work> well, not under any operations that are commonly used
13:02:25 <tibbe> Igloo: I could use more exact schedules for things :) For example, does the Haskell symposium run the whole day?
13:02:31 <Igloo> Yes
13:02:37 <jmcarthur_work> hmm, maybe i worded that wrong too
13:02:44 <idnar> skorpan: I don't see the problem :P
13:02:47 <tibbe> Igloo: good to know, then I can't attend DEFUN that day
13:02:48 <skorpan> idnar: hehe
13:03:05 <Igloo> tibbe: DEFUN that day will probably be non-Haskell stuff
13:03:15 <tibbe> Igloo: makes sense
13:03:42 <ehird> regex-{base,compat,dfa,parsec,pcre,posix,tdfa,tre}, regexpr  which is best?
13:03:43 <Igloo> Unfortunately the other day overlaps with HIW, but you can't have everything
13:03:50 <tibbe> Igloo: so symposium on thursday and defun on saturday then
13:04:10 <Heffalump> tibbe: yes, you need to pick one, but in practice people can switch without it causing much problem
13:04:23 <Cale> There used to be separate takeUntil/dropUntil, iirc. They were not quite the same as negating the parameter to takeWhile/dropWhile, in that they would take/drop one more element than that.
13:04:48 <tibbe> Igloo: is the implementors workshop also a full day thing?
13:05:00 <Heffalump> oh, so no DEFUN talks at all if you want to go to the Haskell workshops
13:05:13 * Heffalump hadn't twigged that
13:05:18 <tibbe> Heffalump: I think I prefer the workshops though
13:05:22 <Igloo> Heffalump: Yeah  :-(
13:05:52 <tibbe> Igloo: would you say the implementors workshop would be useful to me even if I don't have my own Haskell compiler? (i.e. useful to the curious)
13:06:11 <Heffalump> it's about libraries too, right?
13:06:21 <Igloo> tibbe: I'd suggest waiting until programmes are up, and see what looks most interesting
13:07:07 <tibbe> Igloo: ok, hope that's early enough to get a cheap flight
13:07:07 <Igloo> Having never been to a DEFUN or a HIW, it's hard to say which I think would most interest you  :-)
13:07:36 <Igloo> tibbe: Hmm? You need the same flights regardless of which you go to
13:07:58 <bavardage> http://gist.github.com/134801 any suggestions as to what I'm doing wrong?
13:08:05 <bavardage> (as in it works, but how can it work better :P)
13:08:18 <Cale> --   takeUntil p xs  returns the list of elements upto and including the
13:08:18 <Cale> --                   first element of xs which satisfies p
13:08:18 <Cale> takeUntil           :: (a -> Bool) -> [a] -> [a]
13:08:18 <Cale> takeUntil p []       = []
13:08:18 <Cale> takeUntil p (x:xs)
13:08:18 <Cale>     | p x         = [x]
13:08:22 <Cale>     | otherwise   = x : takeUntil p xs
13:08:35 <ehird> bavardage:
13:08:45 <Cale> Yep, I was right :)  (that was in an old Prelude)
13:08:46 <tibbe> Igloo: I guess it wont affect my decision to go or not
13:08:53 <bavardage> ehird: o/
13:08:54 <ehird> bavardage: sieve (p : xs) = p : sieve [x | x <- xs, x `mod` p > 0]
13:09:04 <tibbe> Igloo: let me revise that to say: before the early registration deadline
13:09:05 <ehird> aka,
13:09:21 <bavardage> ooh kk
13:09:22 <ehird> s/aka,//
13:09:23 * Igloo would hope they'll be up by then
13:09:25 <Cale> It really seems useful, I wonder why it was discarded.
13:09:55 <ehird> bavardage: primes = 2 : sieve [3..]
13:09:58 <ehird> er
13:10:03 <ehird> that's identical to primes = sieve [2..]
13:10:03 <ehird> heh
13:10:11 <ehird> but you don' need to consider 1
13:10:18 <ehird> bavardage: also, afaik "rem" is rarely used
13:10:26 <bavardage> right
13:10:32 <bavardage> what is the difference between rem and mod?
13:10:36 <ehird> dunno
13:10:38 <bavardage> hehe
13:10:42 <bavardage> I'll go with mod then
13:10:45 <ehird> @qc (\x y -> rem x y == mod x y)
13:10:45 <lambdabot> Not enough privileges
13:10:49 <ehird> @check (\x y -> rem x y == mod x y)
13:10:50 <lambdabot>   "* Exception: divide by zero
13:10:56 <ehird> @check (\x y -> y /= 0 && rem x y == mod x y)
13:10:57 <lambdabot>   "Falsifiable, after 1 tests:\n0\n0\n"
13:10:57 <ehird> er
13:11:05 <ehird> @check (\x y -> y == 0 || (rem x y == mod x y))
13:11:06 <lambdabot>   "Falsifiable, after 6 tests:\n-1\n2\n"
13:11:14 <ehird> > (rem -1 2,mod -1 2)
13:11:15 <lambdabot>   Add a type signature
13:11:19 <monochrom> They understandably disagree over negative numbers.
13:11:24 <ehird> right
13:11:26 <hzap> > -10 `rem` (-3)
13:11:26 <ehird> > rem -1 2
13:11:27 <lambdabot>   -1
13:11:27 <lambdabot>   Add a type signature
13:11:28 <ehird> > mod -1 2
13:11:29 <lambdabot>   Add a type signature
13:11:31 <hzap> > -10 `mod` (-3)
13:11:31 <ehird> ....
13:11:32 <lambdabot>   2
13:11:34 <ehird> damn you lambdabot.
13:11:37 <bavardage> :D
13:11:51 <hzap> there's some different results
13:11:51 <monochrom> I forgot which one is closer to x86 hardware. Actually I think rem is closer.
13:12:05 <Cale> Yeah, mod is usually the one you want.
13:12:23 <bavardage> the one book I have uses rem which is why I was using it, but it's not exactly a haskell book
13:12:26 <ehird> s/\.{4}/.../
13:12:28 <Cale> > (-10) `mod` 6
13:12:30 <lambdabot>   2
13:12:35 <Cale> > (-10) `rem` 6
13:12:36 <lambdabot>   -4
13:12:48 <Peaker> btw, regarding take/drop/etc -- I wrote a little split-predicate library a while back that allows some stuff that take/drop/etc don't easily allow:  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6189#a6189
13:12:52 <hzap> ehird: human brains don't have a regex engine built in :-)
13:12:59 <ehird> hzap: mine does.
13:13:02 <monochrom> I guess if gmp is involved, there is no speed difference.
13:13:07 <hzap> ehird: ok...
13:13:16 <ehird> monochrom: depends on the atomic components of the gmp implementation ofc
13:13:20 <Cale> Be careful, since `mod` and `rem` are considered multiplicative operators, they have precedence over negation.
13:13:21 <ehird> hzap: hey, it's an irc standard :)
13:13:38 <Cale> So if you write -x `mod` y, you're really writing -(x `mod` y)
13:13:50 <hzap> ehird: \.{4} might be a bit complicated :D
13:13:53 * tibbe thinks Control.Exception.catch should mention whether the exception is re-thrown
13:13:59 <monochrom> Ah, then I like (-10)`mod`6 giving 2.
13:14:09 <ehird> hzap: the literal character dot, four times. simple
13:14:20 <hzap> ehird: ok you win
13:14:26 <ehird> 21:13 Cale: Be careful, since `mod` and `rem` are considered multiplicative operators, they have precedence over negation.  waaaart!
13:14:37 <Cale> Not a wart at all!
13:14:52 <ehird> -x `mod` y = -(mod x y) is so a wart.
13:14:53 <Cale> I think it's the correct behaviour.
13:14:59 <monochrom> Only a wart of plain-text programming.
13:15:05 <ehird> well really -x should always be (-x) imo
13:15:09 <ehird> assuming no whitespace ;-)
13:15:13 <monochrom> WILL PROGRAMMING BE LIBERATED FROM THE PLAIN TEXT FILE!
13:15:29 <ehird> monochrom: That was a statement, was it not!
13:15:41 <monochrom> Syntax bitching contains no semantics.
13:15:41 <Badger> Peaker will ensure that it is so!
13:15:56 <Zao> monochrom: But think of the editor wars!
13:16:01 <ehird> Badger: LOL, I remember the loong pointless back and forths about that :)
13:16:06 * Cale chooses to interpret that as some kind of present subjunctive.
13:18:13 <monochrom> Editor war arms dealers want to perpertuate syntax wars and editor wars.
13:18:34 <bremner> who is this Will Programming? and who enslaved him/her?
13:18:56 <ehird> bremner: Will Programming Be, you mean
13:19:03 <monochrom> Plain Text File enslaved him.
13:19:08 <ehird> Will Programming Be liberated from the Plain Text File!
13:19:13 <ehird> Extra, extra! Read all about it!
13:19:36 <triplez> you guys are hilarious
13:19:59 <ehird> triplez: unlike you; why, you're a ZZZ
13:20:04 <ehird> *rimshot*
13:20:11 <triplez> hehe... yes i am
13:20:19 <mle> well, a good example of editing which doesn't look like plaintext might be emacs+paredit editing sexps.
13:20:31 <mle> very nice structured editing.  not everyone's cuppa though.
13:21:45 <Cale> http://haskell.org/pipermail/haskell-cafe/2009-June/062690.html -- did people see this? It's an interesting technique for closing typeclasses.
13:23:11 <monochrom> Eww, induction principle. Haha, brilliant. Of course induction equals minimality.
13:23:24 <monochrom> I should pretend to be Dijkstra.
13:23:31 <monochrom> Induction equivales minimality.
13:23:52 <Cale> Haha, equivales :)
13:25:28 <Cale> myReplicate :: (Nat n) => a -> List a n
13:25:39 <Cale> Cute
13:26:19 <monochrom> "equivale" is the best invention since sliced bread.
13:27:02 <dever> anyone got any good ideas for an intro to haskell talk :D
13:27:16 <stepcut> dever: talk about arrows
13:27:22 <oal> any DPH people here?
13:27:51 <dbpatterson> is anyone familiar with hyena (or the idea of left-fold enumeration)? I'm looking for an example of how one would use it for things that are less obviously data streams. I have cludged together something that works, but it feels very very ugly (http://www.moonpatio.com/fastcgi/hpaste.fcgi/view?id=2863#a2863)
13:28:20 <monochrom> Someone gave a cute talk on how "impossible" equivales "never".
13:28:37 <monochrom> (where "never" equivales "wait forever")
13:28:52 <oal> as for me, I seem to fail to express even complex multiplication the way vectoriser loves me
13:29:12 <oal> monochrom, bottom ;)
13:29:14 <Cale> oal: hmm
13:30:04 <Cale> oal: So you want to parallelise the computation of the real and imaginary parts?
13:30:14 <monochrom> Here is the gist. I claim I have a function of type "a->b". You know from parametericity it's impossible. So what's going on? Of course the only way I could have implemented it is to have an infinite loop (whether I intend it or it's a bug). So you will wait forever.
13:30:40 <ellisbben> :t error
13:30:42 <jmcarthur_work> equivaling unicorn bottoms
13:30:42 <lambdabot> forall a. [Char] -> a
13:30:55 <dever> 
13:31:24 <jmcarthur_work> or it is unsafe, of course
13:31:39 <oal> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6190#a6190
13:31:39 <monochrom> Here is how the talk was cute. To motivate the above reasoning, the speaker gave a daily-life example. You try to ask a girl out. The girl answers "yeah, when Hell freezes". That means wait forever. That's also her way to say "impossible".
13:31:46 <oal> Cale, no!
13:32:07 <oal> actually I try to compute FFT to compare DPH with other parallel haskells
13:32:11 <jmcarthur_work> monochrom, oh that is an excellent example
13:32:27 <oal> but I can't express anything and then subsequently found out
13:32:49 <oal> that the multiplication of pairs of doubles alone freaks the vectoriser out
13:33:04 <oal> maybe I am doing something wrong
13:33:14 <Cale> ah, yeah, that seems like it's just not ready
13:33:28 <monochrom> The talk used a coding example more interesting than "a->b". He showed a buggy sorting code. The inferred type was "[a] -> [b]". So you know the code has some infinite loop. The code forgot a base case.
13:33:31 <oal> oh, ok
13:33:50 <Cale> oal: but you might submit it as a test case :)
13:34:15 <oal> ok, I'll clean it up a bit more
13:34:23 <oal> whom should I address?
13:35:36 <Cale> Maybe Manuel Chakravarty
13:36:08 <Cale> Or you could file a bug report here: http://hackage.haskell.org/trac/ghc/
13:36:38 <Cale> or post to the GHC-users mailing list: glasgow-haskell-users@haskell.org
13:36:58 <oal> well, ok
13:37:10 <oal> I think I'll do it tomorrow
13:37:26 <oal> I just wanted to be sure, that it's not my fault
13:37:30 <Saizan> i wonder if we can rewrite HList in that caseNat style and get away with less typeclass programming
13:40:01 <Cale> oal: Yeah, that pretty much has to be a bug in the compiler. My understanding is that the DPH stuff which is in the released GHC is a preview and not really very solid yet.
13:56:31 <Baughn> @pl case foo of (xs,r) -> last xs <:> r
13:56:32 <lambdabot> (line 1, column 20):
13:56:32 <lambdabot> unexpected ">" or "-"
13:56:32 <lambdabot> expecting variable, "(", operator or end of input
13:57:00 <Baughn> @pl let (xs,r) = foo in last xs <:> r
13:57:01 <lambdabot> (line 1, column 5):
13:57:01 <lambdabot> unexpected "("
13:57:01 <lambdabot> expecting "()", natural, identifier or "in"
13:57:23 <soupdragon> @pl \xsr ->last (fst xsr) <:> snd xsr
13:57:23 <lambdabot> uncurry ((<:>) . last)
13:57:25 <Baughn> @pl last (fst foo) <:> (snd foo)
13:57:26 <lambdabot> last (fst foo) <:> snd foo
13:58:01 <Baughn> soupdragon: ..yeah, guess that works.
13:58:26 <HugoDaniel> hello
13:58:28 <hzap> Baughn: pl responds to lambda expressions
13:58:37 <HugoDaniel> i need some help on understanding type variables
13:58:53 <HugoDaniel> can i have a type [MyType a] ?
13:59:07 <Baughn> Sure
13:59:13 <HugoDaniel> hmm
13:59:15 <HugoDaniel> but
13:59:42 <HugoDaniel> would it be possible to have [MyType String, MyType Int, ...]
13:59:42 <HugoDaniel> ?
14:00:01 <HugoDaniel> (assuming data MyType a = MyType ...)
14:00:03 <Baughn> No, [] is a one-parameter type constructor.. actually, that's just bad syntax
14:00:13 <hzap> you need to use existential types
14:00:20 <HugoDaniel> ok
14:00:25 <Baughn> hzap: I wouldn't bet on that
14:00:38 <Baughn> HugoDaniel: Though, what exactly is that syntax supposed to mean?
14:00:46 <hzap> it's gonna get messy
14:01:00 <HugoDaniel> so, if i say data MyType a = forall a. blabla, i can have [MyType Int, MyType String ... ]
14:01:20 <HugoDaniel> well i want a list of MyTypes, but each has its own different type
14:01:35 <jmcarthur_work> they would all have the same type with existential quantification
14:01:42 <Baughn> HugoDaniel: Well, what about "data MyType = A String | B Int | C ..."?
14:01:48 <jmcarthur_work> it would be data MyType = forall a . ...
14:01:55 <jmcarthur_work> note that a is not on the left side
14:01:57 <hzap> data MyType = forall a. SomeTypeClass a => MyType a
14:01:59 <jmcarthur_work> so you wouldn't know what is what
14:02:11 <HugoDaniel> ah ok
14:02:11 <Baughn> Yes, but there still isn't any hint of a type-class in here
14:02:13 <jmcarthur_work> yeah, hzap's suggestion would give you basically what OO gives you
14:02:17 <Baughn> And we don't really know what Hugo /wants/
14:02:36 <hzap> but it's messy
14:02:43 <jmcarthur_work> HugoDaniel, if you actually care what type is in there, you will want the ADT version like Baughn suggests
14:03:11 <HugoDaniel> no
14:03:14 <HugoDaniel> i have the typeclass
14:03:15 <jmcarthur_work> but it still means all elements of the list have the same type: [MyType]
14:03:15 <HugoDaniel> thanks
14:03:16 <HugoDaniel> :)
14:03:50 <HugoDaniel> i have the set of functions this type must implement
14:03:53 <HugoDaniel> ok, thanks
14:04:09 <jmcarthur_work> HugoDaniel, another alternative would be to store function/value pairs or partially applied functions, rather than just the values. this would depend on what you need that list for, of course
14:04:51 <hzap> yeah, there isn't one best way to do this
14:05:15 <jmcarthur_work> like if the type class is something like class MyClass a where foo :: a -> Int -> String, or something, then you could have [foo "bar", foo 5, foo True] :: [Int -> String]
14:07:46 <Gracenotes> hm. Would that be allowed? It might complain about ambiguous typeclasses
14:08:11 <jmcarthur_work> > [show "foo", show 5, show True]
14:08:12 <lambdabot>   ["\"foo\"","5","True"]
14:08:57 <jmcarthur_work> :t let foo = const . show in [foo "foo", foo 5, foo True]
14:08:58 <lambdabot> forall b. [b -> String]
14:09:01 <Gracenotes> > [shows 10, shows True] <*> pure ""
14:09:02 <lambdabot>   ["10","True"]
14:09:35 <jmcarthur_work> i see no ambiguity there
14:10:08 <jmcarthur_work> perhaps if the x, y, and z were polymorphic in [foo x, foo y, foo z]...
14:10:15 <Gracenotes> duh
14:10:26 <jmcarthur_work> :t \x y z -> [show x, show y, show z]
14:10:28 <lambdabot> forall a a1 a2. (Show a, Show a1, Show a2) => a -> a1 -> a2 -> [String]
14:10:34 <jmcarthur_work> heh
14:11:08 <jmcarthur_work> :t \x y z -> let foo = const . show in [foo x, foo y, foo z]
14:11:09 <lambdabot> forall a b a1 a2. (Show a2, Show a1, Show a) => a -> a1 -> a2 -> [b -> String]
14:11:14 <jmcarthur_work> yeah, looks okay to me
14:11:16 * Baughn notes that his FRP implementation has degenerated into line-noise
14:11:21 <jmcarthur_work> Baughn, :(
14:11:25 <Gracenotes> just that "pure <*> pure" it the weirdest typeclass thing evar
14:11:33 <Gracenotes> so I have been wary lately
14:11:38 <hzap> @type pure <*> pure
14:11:39 <lambdabot>     Ambiguous type variable `f' in the constraint:
14:11:39 <lambdabot>       `Applicative f'
14:11:39 <lambdabot>         arising from a use of `pure' at <interactive>:1:9-12
14:11:42 <jmcarthur_work> i don't think it's so weird
14:11:52 <jmcarthur_work> :t (pure <*>)
14:11:53 <lambdabot> forall b a. (b -> a) -> b -> b
14:11:54 <Baughn> jmcarthur_work: Well, it's not that bad, but.. the symbol to alphabetic char ratio is hovering at around 1:1 now
14:12:05 <Gracenotes> the type is: Applicative f => a -> a
14:12:06 <jmcarthur_work> that a there is polymorphic and not constrained anywhere
14:12:18 <jmcarthur_work> right
14:12:28 <Gracenotes> and ghc throws a hissy-fit about it
14:12:32 <jmcarthur_work> right
14:13:23 <jmcarthur_work> :t undefined :: Applicative f => a -> a
14:13:25 <lambdabot>     Ambiguous constraint `Applicative f'
14:13:25 <lambdabot>         At least one of the forall'd type variables mentioned by the constraint
14:13:25 <lambdabot>         must be reachable from the type after the '=>'
14:16:31 <Peaker> > pure <*> 5
14:16:33 <lambdabot>   Overlapping instances for GHC.Show.Show (b -> b)
14:16:33 <lambdabot>    arising from a use of `...
14:16:54 <Peaker> > (pure <*> show) 5
14:16:56 <lambdabot>   5
14:17:09 <Peaker> @type const id
14:17:11 <lambdabot> forall a b. b -> a -> a
14:18:33 <Alpounet> @type pure
14:18:35 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
14:18:59 <Alpounet> @type (<*>)
14:19:00 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
14:19:42 <humasect> hello friends =) how may i export a module in scope ? for example: import MyHtml, and then being able to touch Text.Html 's symbols
14:20:39 <Peaker> humasect: I think you can re-export a module by using "module Blah" in your module's export list, and then importing Blah below. Please don't use open-unqualified imports, they're evil
14:20:40 <djahandarie> Is there any way to do a "soft reset" in ghci? Basically reload the hs file it was pulling from and reintepret all the rules.
14:21:07 <monochrom> module MyHtml(module Text.Html, module MyHtml) where ...
14:21:27 <hzap> djahandarie: are you looking for :r ?
14:21:34 <humasect> ah, cool! thanks Peaker =) you are correct
14:21:47 <dbpatterson> anyone here played around with hyena (http://hackage.haskell.org/package/hyena)
14:22:53 <djahandarie> hzap, ah yeah, that's what I was looking for. Thanks
14:23:21 <djahandarie> hzap, is there any way to do that in the middle of a piece of code running?
14:23:52 <hzap> djahandarie: don't thiink so...
14:24:12 <djahandarie> Like, "suspend" it, :r and "resume" or something
14:24:24 <djahandarie> I know it probably won't be possible... but if it is, that would be cool. :P
14:24:25 <Cale> I think it's at least in part a conscious decision to keep the results of things consistent.
14:25:02 <Cale> Though, an option which allowed dynamic reloading of code in cases where types have not changed would be interesting.
14:25:32 <djahandarie> I think Erlang can do something of the sorts
14:25:39 <djahandarie> I could be mistaken though
14:25:49 <Cale> Yeah, and clojure as well.
14:26:22 <djahandarie> I just want it because I'm writing something which works on an open connection, and it's a bit annoying for it to open/close every time I make a change.
14:26:39 <djahandarie> Actually -- is it possible to make Haskell connect to an already open connection?
14:26:44 <Cale> hmm..
14:26:57 <Cale> I'm not sure where you'd store it.
14:28:08 <djahandarie> Someone said a bit ago that lambdabot could dynamically change it's modules or something of the sort
14:28:17 <djahandarie> I would look in the code myself but I'm not that good at Haskell
14:28:18 <SimonRC> it can
14:28:28 <djahandarie> I wonder how it does that
14:29:32 <Cale> Explicit dynamic linking using the plugins package.
14:30:26 <djahandarie> Ooh, this looks cool
14:30:39 <Cale> More modern and easy to use, perhaps, would be the hint library
14:30:48 <Cale> http://hackage.haskell.org/package/hint
14:31:41 <djahandarie> Hm... wouldn't it be a bit slower to run a whole interpreter in the middle of things though?
14:31:50 <djahandarie> Than to just dynamically link things
14:32:14 <Cale> Well... yes, possibly. :)
14:32:15 <djahandarie> I would really have no idea, but it seems like an interpreter would be slower... wouldn't that have to introduce security layers etc?
14:32:42 <Cale> Technically, it should be possible to have hint load object code, but I'm not sure if it currently supports that.
14:32:56 <Cale> It's just a wrapper around the GHC API which is what GHCi uses too.
14:33:19 * Cale decides to try it.
14:33:42 <djahandarie> It does look a lot easier to use though
14:33:46 <jelly12gen> hi you can't make a two dimensial "array" in haskell right ? like  grid[x][y] ?
14:34:22 <copumpkin> you can index an array by a 2-tuple
14:34:25 <hzap> jelly12gen: you can make a list of lists, array of arrays, etc
14:34:40 <Cale> jelly12gen: There's direct support for arrays with 2-dimensional indices
14:34:48 <Cale> You just use a pair as an index
14:34:57 <Cale> But if you're talking about lists instead, you would want a list of lists.
14:35:08 <jelly12gen> [(x,y).(x,y)..]
14:35:09 <jelly12gen> aha ok
14:35:21 <Cale> (arrays and lists are not the same thing at all)
14:35:30 <jelly12gen> no
14:35:36 <jelly12gen> i mean lists
14:35:45 <Cale> Yeah, in that case, just nest lists.
14:35:59 <jelly12gen> like this [[]] ?
14:36:15 <Cale> > [[1,2,3],[4,5,6],[7,8,9]] :: [[Integer]]
14:36:16 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9]]
14:36:24 <Cale> > transpose [[1,2,3],[4,5,6],[7,8,9]]
14:36:25 <lambdabot>   [[1,4,7],[2,5,8],[3,6,9]]
14:36:38 <jelly12gen> ah right i see it
14:36:39 <jelly12gen> thanks
14:37:24 <luqui> > [ [x..x+2] | x <- [1.4.7] :: [] ([] Integer)
14:37:26 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
14:37:30 <luqui> > [ [x..x+2] | x <- [1.4.7] ] :: [] ([] Integer)
14:37:32 <lambdabot>   Couldn't match expected type `GHC.Integer.Internals.Integer'
14:38:08 <hzap> > [ [x..x+2] | x <- [1,4,7] ] :: [] ([] Integer)
14:38:09 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9]]
14:38:50 <luqui> oh, stupid mistake
14:39:04 <luqui> :t 1.4.7
14:39:06 <lambdabot> forall b c a. (Fractional (b -> c), Num (a -> b)) => a -> c
14:39:13 <luqui> yow
14:39:15 <hzap> wow, what a type
14:39:40 <gwern> heh. apparently 'the credit card transform' means circular programming
14:39:47 <FunctorSalad> > toConstr (S.singleton 1)        -- this one took me at least an hour to hunt down :|
14:39:48 <lambdabot>   * Exception: toConstr
14:40:06 <FunctorSalad> that message could use improvement ;o
14:41:02 <FunctorSalad> should I file a ticket somewhere?
14:42:31 <mmorrow> FunctorSalad: that message is hardcoded into Data.{Set,Map,IntSet,IntMap}
14:42:32 <Peaker> FunctorSalad: what's toConstr ?
14:43:05 <mmorrow> FunctorSalad: look at the Data instance in the code for any one of those
14:43:08 <Peaker> @hoogle toConstr
14:43:09 <lambdabot> Data.Generics.Basics toConstr :: Data a => a -> Constr
14:43:25 <hzap> @type toConstr
14:43:26 <lambdabot> forall a. (Data a) => a -> Constr
14:43:35 <Peaker> > toConstr 1
14:43:37 <lambdabot>   1
14:43:44 <Peaker> > toConstr (Just 5)
14:43:46 <lambdabot>   Just
14:44:09 <FunctorSalad> mmorrow: ok
14:44:52 <FunctorSalad> (why is that? doesn't seem like it would hurt to publically expose reps of private constructors)
14:45:08 <mmorrow> FunctorSalad: i guess then they're not private
14:45:34 <FunctorSalad> fwiw, I tried to write a "generic Ord" (Data a => a -> a -> Ordering)
14:45:52 <FunctorSalad> mmorrow: why? they're just metadata
14:46:27 <mmorrow> FunctorSalad: ask the author of Data.Set/Map
14:47:06 <mmorrow> or whoever it was that wrote those instances
14:47:41 <mmorrow> but yeah, those instances break anything that relies on Data
14:47:58 <djahandarie> Just wondering... I'm wondering how to write out this generic function... Basically it accepts at least two strings, but can support an infinite amount. It then concanates all of them together and sends them somewhere
14:48:01 <mmorrow> Botje: had this problem with using Data.Set with Uniplate iirc
14:48:04 <mmorrow> oops
14:48:10 <mmorrow> FunctorSalad: Botje ...
14:48:34 <djahandarie> Should I do  whatever :: String -> String -> [String] -> String
14:48:38 <djahandarie> Or is there a better way
14:49:05 <hzap> > concat ["abc", "def", "ghi"]
14:49:05 <mmorrow> that or make a datatype to represent "two or more Strings"
14:49:06 <lambdabot>   "abcdefghi"
14:49:52 <djahandarie> hzap, yeah, I know I can concat the list, but I was wondering if there was a way to make a function accept an infinite amount of params I guess
14:50:00 <djahandarie> An infinantly currying function
14:50:01 <djahandarie> Or something
14:50:02 <djahandarie> :P
14:50:17 <hzap> djahandarie: pretty hard
14:50:28 <djahandarie> Yeah, probably not worth the trouble. :P
14:50:46 <Cale> You can use typeclasses to design functions which take an arbitrary number of parameters
14:50:51 <hzap> you can look at the printf function, it does some typeclass hackery
14:51:08 <Cale> But it's usually not worth the trouble.
14:51:11 <byorgey> I doubt that is what djahandarie really wants to do.
14:51:35 <djahandarie> It just feels stupid to pass the rest of the params in a list though...
14:51:38 <Cale> If you want something to take an arbitrary number of values of the same type, use a container like a list.
14:51:41 <Cale> Why?
14:51:44 <byorgey> it's never difficult to just write the parameters inside a list.
14:51:50 <byorgey> djahandarie: why does it feel stupid?
14:51:52 <mmorrow> > printf "%d %s %g" pi :: String
14:51:53 <lambdabot>   "* Exception: Printf.printf: bad argument
14:51:58 <Cale> (In fact, it's more convenient, most of the time)
14:52:02 <byorgey> that's exactly how you gather up an unknown number of things into a single object =)
14:52:17 <djahandarie> Bah.
14:52:19 <opqdonut> err, in Coq i have a hypothesis of form "forall x, P"
14:52:23 <opqdonut> how do i instantiate x?
14:52:23 <djahandarie> Alright, fine, whatever, you win. :P
14:52:37 <soupdragon> opqdonut: You cannot
14:52:45 <byorgey> soupdragon: what? sure you can.
14:53:01 <soupdragon> I think 'instantiate' means give a value to
14:53:11 <opqdonut> i have a specific x in mind i want to instantiate that hypothesis with
14:53:20 <soupdragon> you can split x into cases if it is inductive, but you can't choose a single value
14:53:21 <opqdonut> apply H to x if you will
14:53:28 <FunctorSalad> (re syb: at least you can make a special case for Data.Set with ext1Q :))
14:53:39 <soupdragon> Oh sorry... *hypothesis*
14:53:42 <soupdragon> yes byorgey is right
14:53:44 <opqdonut> soupdragon: i know "forall x, P", my Goal is something else
14:53:51 <FunctorSalad> opqdonut: it's just a function
14:54:03 <opqdonut> yeah
14:54:07 <opqdonut> but i'm in this proof mode
14:54:07 <djahandarie> By the way, is there an easier way to concat a list with an extra object in the middle of each list? Or would I have to use concatMap with a function or something
14:54:23 <luqui> opqdonut, just apply it.
14:54:25 <FunctorSalad> opqdonut: "exact (myHyp myX)", for example
14:54:38 <soupdragon> if you have h : forall x, P then pose (h <value for x>)
14:54:44 <Cale> > intercalate "," (words "here are some strings")
14:54:46 <lambdabot>   "here,are,some,strings"
14:54:48 <Cale> like that?
14:54:54 <opqdonut> okay, exact was the thing i was looking for
14:54:56 <opqdonut> thanks
14:54:58 <luqui> opqdonut, If H : forall x : A, P x, and y : A, then H y : P y
14:55:06 <opqdonut> yes, yes
14:55:07 <djahandarie> Basically, I want concat ["abc", "def", "ghi"] to return "abc def ghi"
14:55:17 <Cale> > unwords ["abc", "def", "ghi"]
14:55:19 <lambdabot>   "abc def ghi"
14:55:22 <djahandarie> Ooh
14:55:22 <djahandarie> Cool
14:55:23 <opqdonut> luqui: i'm just struggling with the logic of the proof mode
14:55:25 <jmcarthur_work> :t intercalate
14:55:26 <lambdabot> forall a. [a] -> [[a]] -> [a]
14:55:28 <mmorrow> > intercalate "," ["abc", "def", "ghi"]
14:55:29 <luqui> opqdonut, ah
14:55:30 <lambdabot>   "abc,def,ghi"
14:55:30 <jmcarthur_work> :t interpolate
14:55:31 <lambdabot> Not in scope: `interpolate'
14:55:33 <jmcarthur_work> :P
14:55:42 <hzap> isn't Data.List is awesome...
14:55:43 <FunctorSalad> opqdonut: "refine" is also handy, it's like exact but you can put in placeholders _ and solve them later
14:55:44 <ray> :t calate
14:55:46 <lambdabot> Not in scope: `calate'
14:55:50 <djahandarie> Oh, I missed this cool "functions on strings" section.
14:55:51 <luqui> opqdonut, yeah, i'd say there are at least 30 tactics to learn before you can do much at all...
14:55:53 <FunctorSalad> opqdonut: trial and error ;o
14:56:02 <Botje> mmorrow: yes, it was a very annoying problem and didn't manifest itself directly :)
14:56:19 <FunctorSalad> (throw a bunch of tactics at it and see what sticks ;))
14:56:20 <jmcarthur_work> :intersperse -- what i meant to say instead of interpolate :\
14:56:24 <jmcarthur_work> :t intersperse -- what i meant to say instead of interpolate :\
14:56:25 <opqdonut> thanks all
14:56:25 <lambdabot> forall a. a -> [a] -> [a]
14:56:26 <opqdonut> :)
14:56:29 <mmorrow> Botje: FunctorSalad apparently spent an hour trying to track down "***Exception: toConstr"
14:56:56 <mmorrow> at least the error call could give the module that it's in..
14:57:09 <soupdragon> luqui: you can learn to use refine first and do 99% of stuff with that
14:57:10 <FunctorSalad> or the type
14:57:12 <Botje> yeah, i saw :)
14:57:13 <djahandarie> Would it be frowned upon in terms of design to do   unwords [a, b, c]   rather than a ++ " " ++ b ++ " " ++ c  ?
14:57:20 <Cale> Hmm, that's funny. I could have sworn hint had a way to compile code properly with optimisations when it loaded it.
14:57:26 <opqdonut> gah, it's not exact after all
14:57:33 <jmcarthur_work> djahandarie, quite the contrary
14:57:37 <FunctorSalad> (in fact it could even give the parameter of the Set in question by doing "typeOf")
14:57:37 <opqdonut> exact wants my goal to be of the form H x
14:57:41 <luqui> soupdragon, true.. I didn't. And when I was learning I didn't have a firm enough grasp of Coq's way of thinking to do it that way anyway.
14:57:43 <djahandarie> jmcarthur_work, alright
14:57:47 <opqdonut> i just want a new hypothesis H0 = H x
14:57:51 <soupdragon> opqdonut: if you want to make a new hypothesis with it instantiated use pose like I said
14:57:55 <Cale> hmm... old versions had setOptimizations, but that seems to be gone.
14:57:57 <luqui> opqdonut, pose
14:58:00 <opqdonut> soupdragon: hmm, missed that
14:58:19 <opqdonut> thanks.
14:58:19 <luqui> opqdonut, pose (H := H x).  though exact (H x) really ought to do it.
14:58:25 <lpsmith> ok,  if you cabal-installed something, but didn't generate the docs, is there a nice way to generate the docs without re-installing the package?
14:58:32 <Cale> oh, maybe we can still use unsafeSetGhcOption
14:58:33 <FunctorSalad> opqdonut: there's also "apply H in x" or "apply x in H". it's illogical so I can't remember the order ;)
14:58:51 <mmorrow> FunctorSalad: TH can see through those pesky abstract types though ;)
14:58:58 <mmorrow> ghci> ppDoc $(lift =<< reify ''Set)
14:58:58 <mmorrow> data Set a_0 = Tip | Bin !Size a_0 !(Set a_0) !(Set a_0)
14:59:06 <luqui> FunctorSalad, apply x in H.  the thing after the "in" is the hypothesis you want to change.
14:59:21 <FunctorSalad> mmorrow: great, I'll write the ord instance with unsafePerformIO . runQ ;)
14:59:27 <mmorrow> weee
14:59:41 <luqui> man, all this coqtalk could give #coq higher traffic than it's had in months, if we were there
14:59:50 <FunctorSalad> (hmm that won't work, you can't do reify in IO)
15:00:03 <mmorrow> FunctorSalad: i have Lift instance in hashell-src-meta
15:00:07 <mmorrow> sk
15:00:16 <mmorrow> so you can wrap in
15:00:28 <mmorrow> , $(lift =<< reify ''Tree)
15:00:30 <lunabot>  TyConI (DataD [] Data.Tree.Tree [a_1627417407] [RecC Data.Tree.Node [(Dat...
15:00:34 <mmorrow> , ppDoc $(lift =<< reify ''Tree)
15:00:36 <lunabot>  data Tree a_0 = Node {rootLabel :: a_0, subForest :: (Forest a_0)}
15:00:37 <jcpetruzza> Cale: hint runs ghc in interpreted mode, and iirc, it ignores -O2 and -O in that mode?
15:00:38 <FunctorSalad> thanks, I think I'll just do a special case for Set and Map though
15:00:51 <Cale> jcpetruzza: hmm, seems to be the case
15:01:06 <mmorrow> FunctorSalad: but yeah, you'd need to do the TH all at compile-time
15:01:21 <mmorrow> for every possible type or something
15:01:23 <FunctorSalad> lunabot: it's understandable that he asked here, #coq can be quite silent
15:01:36 <Cale> jcpetruzza: It would be nice if it could at least load an already-compiled .o the way that GHCi can...
15:01:36 <mmorrow> heh
15:01:39 <FunctorSalad> lunabot <- luqui
15:01:57 <Cale> oh, it does
15:02:00 <Cale> good :)
15:02:02 <jcpetruzza> Cale: it should
15:02:26 <Cale> Yeah, I just tried it with something that would fail if compiled without optimisations and it did actually load the .o correctly
15:02:47 <Cale> hmm, it does actually need the .hs to be present for some reason though
15:02:57 * Cale wonders if this is true of ghci as well
15:03:08 <mmorrow> Cale: or at least a .hi i believe
15:03:16 <jelly12gen> can you make an typle "getter" return an list ?
15:03:16 <jcpetruzza> it is
15:03:21 <Cale> hmm, seems that ghci can load a .o without having the .hs present
15:03:26 <jelly12gen> like getFirst = (x,y,_,_) = l
15:03:31 <jcpetruzza> does it?
15:03:43 <FunctorSalad> mmorrow: what does the "lift" do there? "invert" reify?
15:03:43 <mmorrow> Cale: (it needs a .hi too though)
15:03:44 <Cale> er...
15:03:53 <FunctorSalad> mmorrow: (except that reify works on names, not ASTs)
15:04:11 <mmorrow> FunctorSalad: it lifts the Info to an ExpQ, then splices it back to an Info
15:04:25 <Cale> ah, it doesn't seem to put anything in scope
15:04:31 <Vulpyne> jelly12gen: getFirst (x,y,_,_) = [x,y] -- perhaps?
15:04:32 <mmorrow> s/Info/Exp,Dec,etc/
15:04:33 <Cale> (even with the .hi hanging around)
15:04:38 <Cale> So, fair enough :)
15:04:40 <a_guest> I am currently reading about monad transformers, using 'mtl'. It says that monad transformers can structure bigger applications. My question is wheter this is a normal way to write (bigger) Haskell applications?
15:04:42 <jelly12gen> uweDeportivo: ok wil try that
15:04:47 <Cale> djahandarie: So that's something you can do at least. :)
15:05:05 <FunctorSalad> mmorrow: oh, I think I once did a similar trick. I just put the info into a string literal ;)
15:05:06 <djahandarie> Cale, okay, cool, I'll look into it
15:05:12 <djahandarie> The example didn't look too complicated
15:05:16 <mmorrow> FunctorSalad: exactly. same idea
15:05:17 <Cale> djahandarie: Use hint, but if you need the extra performance, simply run ghc on the modules before loading them
15:05:37 <djahandarie> Okay that makes sense
15:06:04 <mmorrow> FunctorSalad: (the lift though saves you from having to reconstruct the whatever from the String is the only difference essentially)
15:06:21 <opqdonut> yay, Qed.
15:06:26 <jix> is there something like Data.Binary.Get which has some error handling not based on error "foo"?
15:07:20 <jcpetruzza> Cale: there is a flag that allows ghci to actually compile the module, maybe by setting it with unsafeSetGhcOption along with -O2 one can get the optimizations
15:07:41 <jcpetruzza> (but in that case, I guess there will be no access to unexported bindings)
15:09:10 <jcpetruzza> that would be -fobject-code
15:10:02 <Cale> yep, that works :)
15:10:03 <iFire`> list some good haskell textbooks/guides
15:10:54 <kynky> yaht,rwh,haskell wiki book
15:11:14 <Saizan_> @where LYAH
15:11:14 <lambdabot> www.learnyouahaskell.com
15:11:21 <kynky> yaht=yet another haskell tutorial, rwh = real world haskell
15:12:19 <kynky> start with yaht, then haskell wiki book, then real world haskell, then the worlds your oyster :)
15:12:57 <Saizan_> i'd recommend LYAH over YAHT
15:13:12 <lament> I second the TWYO recommendation
15:13:13 <iFire> so which of those are textbooks
15:13:33 <Alpounet> RWH is also fine as a first contact with Haskell
15:13:37 <Saizan_> uhm, none of those
15:13:54 <Alpounet> RWH is.
15:13:54 <iFire> Realworld Haskell is
15:14:31 <Saizan_> differing definition of textbook i guess :)
15:14:58 <kynky> a book with text in
15:15:00 <iFire> Saizan_ do you like learnyouahaskell?
15:15:27 <iFire> I guess I'll narrow it down to lyah and RWH
15:15:52 <Saizan_> iFire: i've skimmed and it seems good, when i learned haskell myself it wasn't there though :)
15:16:24 <iFire> because I'm looking throw the wiki list of books and some of them are ancient
15:16:27 <iFire> through*
15:16:38 <kynky> for me the english spoken video lecturers, 26 vids of 1h30m really good, free d/l
15:16:50 <iFire> kynky itunes U?
15:17:00 <iFire> where are they exactly?
15:18:19 <kynky> http://video.s-inf.de/#FP.2005-SS-Giesl.(COt).HD_Videoaufzeichnung
15:18:33 <kynky> fp = functional programming
15:18:47 <iFire> they're in English right?
15:18:49 <kynky> yep
15:19:10 <kynky> been watching them, kinda less intense than reading
15:19:34 <Peaker> jix: maybe Iteratee
15:19:41 <kynky> and way brain works, best to absorb info in multiple diff ways
15:19:57 <iFire> maybe by the time I get an iPod Touch haskell's iPhone pipeline will be debugged
15:20:10 <Peaker> jix: I have an alternate Data.Binary package on my TODO list (where Get values that can fail are in a MaybeT Get or ErrorT Get instead)
15:20:17 <Peaker> jix: (And Put is a Monoid, and not a Monad)
15:20:41 <Peaker> jix: I also wonder if Iteratee can be done more nicely, and maybe even united with Data.Binary into a single thing
15:35:56 <djahandarie> Is there any reason why putting a do inside of a guard wouldn't work?
15:36:06 <djahandarie> It says parse error on input `|'
15:36:20 <iFire> anyone here familiar with http://www.nabble.com/Haskell-on-the-iPhone-td24156714.html ?
15:36:28 <luqui> djahandarie, you will run into layout hell if you try to use layout
15:36:42 <luqui> but if you use the explicit notation, do { ... ; ... ; ... }  it should be fine
15:36:54 <djahandarie> Ah, alright
15:36:54 <ehird> iFire: yes!
15:36:59 <ehird> iFire: come to #haskell-iphone ;)
15:37:00 <ehird> *:)
15:37:07 <djahandarie> Is there explicit notation for a do where?
15:37:21 <djahandarie> do { ... ; } where { x = ... } ?
15:37:31 <ehird> Uh, sure. It's just a where + a do.
15:37:39 <ehird> (Much a do about nothing.)
15:37:46 <luqui> djahandarie, mind, though, that where applies to *definitions*, not expressions
15:37:48 <Cale> djahandarie: The more obvious reason why putting do inside of a guard is silly is that the result of (do ...) can never be a Bool
15:37:51 <luqui> so what you just wrote is nonsense
15:38:06 <luqui> > do True
15:38:08 <lambdabot>   True
15:38:16 <luqui> %-)
15:38:20 <Cale> Heh, apart from that special case.
15:38:26 <ehird> How does that work?
15:38:38 <Cale> Actually, it shouldn't work.
15:38:40 <djahandarie> Ugh, I'm confused. >.<
15:38:49 <Cale> but  do { x } = x  is the syntax translation rule
15:39:05 <luqui> > let f | Just x <- do { y <- Just 4; return y } = x in f
15:39:07 <lambdabot>   4
15:39:29 <ehird> Cale: ah
15:39:30 <Cale> Yeah, I'm also not talking about the pattern guard extension :)
15:39:36 <ehird> that's a rather literal sort of translation in ghc...
15:39:45 <djahandarie> Well I'm confused as hell....
15:40:06 <luqui> djahandarie, =P...  yeah, #haskell can do that.  keep asking specific questions and we'll try not to get side-tracked.
15:40:31 <Cale> djahandarie: basically, under ordinary circumstances, you would not use do-notation to write a boolean value, and guards are required to evaluate to a boolean value (True or False)
15:41:00 <djahandarie> guard y | "whatever" `isPrefixOf` x = do { something xw } where { xw = words x}
15:41:03 <djahandarie> For example ^^
15:41:11 <Cale> djahandarie: well, that's different
15:41:12 <djahandarie> I don't think that works, but it should be clear what I'm trying to do
15:41:27 <djahandarie> Cale, yeah, I think I stated the question wrong
15:41:31 <djahandarie> I didn't want it INSIDE the guard
15:41:34 <Cale> Apart from the fact that x is not in scope, that is fine.
15:41:34 <djahandarie> Just... with guards
15:41:53 <tibbe> @seen gwern
15:41:53 <Cale> (if you were to change that first y to x, then it would be okay)
15:41:54 <lambdabot> gwern is in #darcs, #xmonad and #haskell. I last heard gwern speak 1h 2m 13s ago.
15:42:03 <djahandarie> Cale, oh yeah, that's what I meant
15:42:25 <tibbe> who's the current maintainer of Haddock?
15:42:52 <Berengal> a do block is just an expression, and can be used wherever an expression can be used, which is mostly everywhere
15:43:11 <djahandarie> Berengal, that's what I thought, just it started giving me errors once I put it in there
15:44:03 <Berengal> djahandarie: That usually means you misplaced a character somewhere, for example an extra = where there shouldn't be one
15:44:32 <djahandarie> It still gives me an error on the | even when I put it all on one line...
15:44:35 <djahandarie> Hmm
15:44:39 <Berengal> paste?
15:44:45 <djahandarie> Alright, hold on
15:44:48 <djahandarie> Probably something stupid
15:46:17 <djahandarie> http://pastebin.com/d5c503c27
15:46:26 <djahandarie> It errors on the | before "!nick"
15:46:53 <Cale> The 'where' should come after all the guards
15:46:58 <djahandarie> Oh
15:47:04 <Cale> 'where' is not part of the syntax of expressions
15:47:08 <djahandarie> But what if I only want it to apply to the do?
15:47:09 <Cale> It's part of the syntax of declarations
15:47:22 <Cale> It'll only be evaluated as needed anyway
15:47:25 <Cale> but you could use let
15:47:30 <djahandarie> Hm
15:47:35 <djahandarie> What would you recommend?
15:47:37 <McManiaC> how can i read from stdin?
15:48:18 <McManiaC> @src getLine
15:48:18 <lambdabot> getLine = hGetLine stdin
15:48:29 <Alpounet> McManiaC, getLine ?
15:48:39 <Alpounet> @type getLine
15:48:41 <lambdabot> IO String
15:48:54 <McManiaC> does getLine handle bash-pipes too?
15:49:02 <McManiaC> like echo "foo" | ./myhaskelltool
15:49:11 <Berengal> McManiaC: No, Bash handles bash-pipes
15:49:23 <ehird> What Berengal said; a pipe is just like typing.
15:49:24 <Alpounet> it passes "foo" as argument to your app
15:49:34 <ehird> Alpounet: no it doesn't
15:49:39 <ehird> "./myhaskelltool foo" does that
15:49:42 <McManiaC> yeh thats what i meant, okay
15:49:44 <Alpounet> yeah
15:50:29 <Cale> djahandarie: this is strange...
15:50:35 <Cale> djahandarie: are you sure that you mean 'last' there?
15:50:39 <Cale> > last [1,2,3]
15:50:40 <lambdabot>   3
15:51:27 <McManiaC> ok, so getLine gets *one* line, how can i get everything, kinda like getArgs?
15:51:39 <Berengal> getContents
15:52:22 <McManiaC> perfect
15:52:24 <McManiaC> :)
15:52:39 <Berengal> Warning: don't use it in ghci
15:53:01 <ehird> why not
15:53:03 <ehird> just type ^C
15:53:06 <ehird> to dismiss it
15:53:10 <ehird> well
15:53:10 <Cale> djahandarie: actually, if I were writing this, I would have the whole thing be a big case on words x
15:53:12 <ehird> you can only use it once :P
15:54:36 <Berengal> djahandarie: view patterns and stripPrefix is a nifty combination
15:56:25 <Berengal> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6192#a6192
15:57:37 <Cale> http://pastebin.com/m232d703b -- let's just start with indenting things sanely.
15:58:39 <McManiaC> "prettier" way to write "text' <- foo; let text = bla text'" ?
15:58:50 <Cale> The (drop 4)'s are really ugly. I'm not even sure what (drop 4 y) is supposed to be...
15:59:09 <Cale> McManiaC: text <- fmap bla foo
15:59:16 <Berengal> McManiaC: 'bla -> text <- foo' or 'text <- bla <$> foo'
15:59:24 <Cale> ?
15:59:40 <Cale> Oh, pff, view patterns
15:59:43 <Berengal> :P
16:00:10 <Berengal> (Not really a fan of them in that context, but it's cute)
16:00:13 <Cale> Does that actually work without the extra parens?
16:00:23 <Berengal> Actually, I don't think so...
16:00:54 <Cale> I don't know why I'm not a bigger fan of <$>
16:01:03 <McManiaC> eeeh?
16:01:04 <McManiaC> Main.hs:9:10: parse error on input `->'
16:01:11 <Cale> McManiaC: Ignore that one.
16:01:16 <Berengal> I never use `fmap` anymore
16:01:36 <Cale> McManiaC: It requires the ViewPatterns extension, and it also needs more parens :)
16:01:38 <Berengal> Not only is it more characters, but ` is a deadkey in an awkward position on my keyboard
16:01:49 <Cale> I never use fmap infix either.
16:01:57 <Cale> I just always use it prefix.
16:02:03 <McManiaC> kay
16:02:15 <Berengal> Yeah, I tend to use prefix alot more than infix, even for stuff like elem, div, mod...
16:02:23 <McManiaC> <$> == fmap?
16:02:37 <Berengal> McManiaC: Yes, in Control.Applicative
16:02:37 <Cale> I think the reason that I don't use <$> more is that it requires that I import Control.Applicative, which I won't do unless I'm actually writing something which is applicative and not monadic.
16:02:58 <Berengal> I almost always import Control.Applicative...
16:02:58 <McManiaC> kay
16:03:05 <Cale> (and most of the useful applicatives are also monads...)
16:03:23 <Berengal> And you'll find me putting things like foo *> bar <* baz in do expressions...
16:04:15 <Cale> We need more metamodules which just reexport lots of things.
16:04:32 <Berengal> Meta.Everything
16:04:47 <Berengal> Meta.Control
16:04:55 <Berengal> I can see how that could be nice...
16:05:00 <Berengal> Meta.Data.Structures?
16:05:05 <Cale> It's too inconvenient to have 20-some-odd imports at the top of every program, and yet sticking everything in the Prelude isn't so nice either.
16:05:18 <Cale> We also need a way to re-export things qualified.
16:05:40 <Berengal> Yeah, I've noticed the import list growing in my modules as well
16:05:49 <Berengal> At times they're about 20% of the source :/
16:05:52 <luqui> Berengal, same, gg}}iControl.Applicative   is hardwired into my brain
16:06:23 <luqui> Cale, re: re-export qualified... YES!
16:06:23 <Berengal> Also, top line in my last module: {-# LANGUAGE PatternGuards, NoMonomorphismRestriction, RankNTypes, ExistentialQuantification, ImpredicativeTypes, FlexibleContexts, ViewPatterns, ScopedTypeVariables #-}
16:06:44 <luqui> i would like modules to feel more first class, even if they aren't actually
16:06:58 <luqui> Berengal, boo!
16:07:11 <Cale> It takes me *two* import lines if I want Set or Map the way I want it, which is a shame.
16:07:32 <luqui> i don't find it that much of a pain to write Map.Map
16:07:46 <Cale> I can't stand to write anything qualified in types.
16:07:58 <Cale> I also can't stand qualified infix operators.
16:08:07 <luqui> agree there, those things are gross
16:08:09 <Berengal> Cale: When it comes to Map I've found I usually just type MyMap = M.Map SomeType SomeOtherType
16:08:12 <Cale> (Data.Sequence is really bad that way)
16:08:13 <luqui> why don't you like qualified types?
16:08:36 <Cale> Actually, I'm somewhat opposed to explicit qualification altogether somehow.
16:08:50 <Cale> I think because I started using Haskell back when the namespace was completely flat :)
16:08:53 <aavogt> don't you input the infered type signatures most of the time anyways?
16:09:09 <Cale> aavogt: I write my own type signatures if I write them at all.
16:09:28 <ehird> 00:07 Cale: It takes me *two* import lines if I want Set or Map the way I want it, which is a shame.
16:09:32 <ehird> can't a module e.g. do
16:09:41 <luqui> aavogt, i trust myself to get my type signatures correct much more than i trust getting my code correct
16:09:46 <ehird> import Data.Map (Map); import qualified Data.Map as Map -- and then rexport these?
16:09:51 <ehird> so you can just do "import Data.Map.Sane"
16:09:54 <luqui> so i write the type signature first
16:10:09 <Cale> ehird: the qualifications aren't re-exported
16:10:15 <ehird> lame
16:10:37 <luqui> can TH mess with imports?
16:10:45 <Berengal> I wish there was a way to get import lists built automatically...
16:10:45 <mmorrow> no :(
16:10:49 <luqui> :-(
16:11:00 <mmorrow> TH doesn't have a rep for imports or modules
16:11:31 <Berengal> If there's one thing I loathe about reading Haskell code it's when there's 30 imports without import lists, and function names are all over the place
16:11:41 <Peaker> Berengal: I want to write a tool that adds (names) to unqualified open imports (to make them closed), but I don't have time, and it would take a lot of getting to know the ghc libs
16:11:44 <luqui> really that shouldn't be an issue
16:11:53 <luqui> it's an artifact of our lack of good editing environments
16:11:57 <Saizan_> Peaker: there's a ghc flag to get that
16:12:10 <Saizan_> Peaker: -ddump-minimal-imports or something
16:12:16 <aavogt> so it is not common to put functions that belong in a 'where' at top level (at least initially, so that you can track down which things don't have the type you think they should?)?
16:12:53 <luqui> aavogt, yeah i've done that once or twice when i get into tricky type errors.
16:13:00 <Peaker> Saizan_: cool, thanks, I'll look
16:13:15 <luqui> though usually if i have functions in a where, it's because they depend on a parameter of a binding, so i can't easily put them at the top level
16:13:33 <luqui> man... there is so much potential for a killer haskell editor
16:14:30 <Berengal> Leksah has some nice module browsing ability
16:14:49 <Peaker> Saizan_: I wish it didn't mess with qualified imports, only non-qualified ones, but I guess its easy enough to extract what I want from there
16:14:53 <Berengal> And Yi has built-in ghci and type inference
16:15:05 <Peaker> Berengal: The option Saizan_ mentioned seems really nice..
16:15:24 <Berengal> Peaker: Yup, I'm looking into it now
16:16:01 <Peaker> its weird
16:16:23 <Peaker> seems not to be built to handle qualified imports.  The default of unqualified really sucks :(
16:16:40 <aavogt> Berengal: does yi have type inference for just top level stuff (same as vim, emacs), or for arbitrary expressions?
16:16:57 <Berengal> aavogt: Currently it just asks ghci and copies the resulting string :P
16:17:28 <Peaker> if we had nice type-classes for dictionaries/etc, then we could probably get only Map from Data.Map to force the types, and very few other names, and use the type-class names of everything else
16:17:57 <ehird> how many non-haskell lang modes does yi have anyway?
16:20:36 <aavogt> Berengal: too bad, and yi isn't particularily fast anymore either
16:22:20 <gwern> ehird: if someone would just write a tool to get alex into happy, then yi could have every mode highlighting-kate does...
16:22:42 <ehird> alex, happy... no parsec love :)
16:22:44 <Saizan_> alex into happy?
16:22:51 <ehird> gwern: but that's just highlighting.
16:23:18 <gwern> ehird: which implies partial parsing
16:23:30 <gwern> but really highlighting is about 90% of what I expect from a mode
16:23:36 <ehird> gwern: but doesn't imply indentation, helpers, ...
16:25:50 <mmorrow> gwern: what does "alex into happy" mean?
16:26:00 <Berengal> Eh, as long as the indenter knows I want things to align at four spaces I'm happy
16:26:18 <Berengal> Proper indenting is just a bonus
16:26:19 <gwern> mmorrow: well, iirc there are are 2 main parser formats; highlighting-kate compiles into one, and yi uses the other
16:26:31 <gwern> theirs is a love fated never to compile!
16:27:04 <mmorrow> what does this have to do with alex and happy?
16:27:48 <mmorrow> (alex and happy are usually used together in parsers, but neither one does what the other does)
16:28:02 <mmorrow> lex/yacc
16:29:04 <gwern> mmorrow: man, stop getting all up in my earhole! my desire is simple: make *that* [yi] do *that* [highlighting-kate]. if the technicals details interest you there's a bug report
16:29:09 <mmorrow> does highlighting kate use happy? (that would be impressive)
16:29:38 * mmorrow pours earwigs into gwern's earhole
16:29:41 <gwern> @quote hallucinogenic
16:29:42 <lambdabot> DerekGlidden says: [GNOME] Development strategies are generally determined by whatever light show happens to be going on ... one of the developers will leap up and scream "I WANT IT TO LOOK JUST
16:29:42 <lambdabot> LIKE THAT" and then straight-arm his laptop against the wall in an hallucinogenic frenzy before vomiting copiously, passing out and falling face-down in the middle of the dance floor.
16:29:48 <gwern> ^ comprende?
16:30:00 <mmorrow> haha
16:31:14 * mmorrow adds that quote to his quotes file
16:32:36 <gwern> mmorrow: oh, you should track down glidden's whole blog post. it's great
16:35:43 * mmorrow is trying to find it, only coming up with other people mentioning/quoting it, but no link yet
16:36:19 <mmorrow> http://inmyholyopinion.com/2007/05/11/gnome-vs-kde/
16:37:30 <gwern> mmorrow: there's a full quote on reddit somewhere, btw
16:42:38 <copumpkin> omg it's ChilliX
16:42:53 <ChilliX>  :)
16:47:54 <ehird> mmorrow: http://web.archive.org/web/20031203024955/http://illusionary.com/GNOMEvKDE.html
16:47:57 <ehird> is the original source
16:49:43 <mmorrow> ehird: nice! i got as far as finding out the site no longer existed before i quit
16:50:15 <ehird> it's quite a bit more disparaging on the gnome side, i notice :)
16:51:53 <Adamant> it's funny, considering how Nazi GNOME devs are about features, I would tend to expect the reverse
16:56:09 <mmorrow> Adamant: it looks like it has become the reverse http://gnomejournal.org/article/5/experimental-culture
17:11:47 <ehird> @hoogle sequenceM
17:11:47 <lambdabot> No results found
17:11:50 <ehird> @hoogle sequence
17:11:50 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
17:11:50 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
17:11:50 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
17:13:42 <conal> is there a unary-friendlier synonym for ($!)?
17:13:53 <conal> like strict = ($!) ?
17:14:04 <monochrom> What is unary-friendly?
17:14:06 <mmorrow> i like
17:14:17 <mmorrow> bang k !x = k x
17:14:33 <mmorrow> (although i usually use
17:14:41 <mmorrow> bang !x k = k x)
17:14:53 <monochrom> Do you accept ($!) k x ?
17:14:54 <conal> mmorrow: yeah, or "strict", since "bang" is about the binary name rather than its meaning.
17:15:17 <mmorrow> conal: how do you mean?
17:15:37 <mmorrow> (/me equates "bang" with "strict")
17:15:48 <monochrom> bang strict
17:15:50 <conal> i mean i have a function and i want a strict version.  i'm not applying the function.  so i say "($!) foo"
17:16:08 <conal> the name $! is binary-friendly
17:16:31 <conal> meaning it's more convenient to use in a binary (specifically infix) setting
17:16:31 <Cale> There used to be a function called strict
17:16:37 <Cale> But I think it's gone.
17:16:49 <mmorrow> conal: ah, i see. i suppose bang !x k = k x is more "bangy" and flip bang is more "stricty" :)
17:16:52 <conal> Cale: oh!  i just tried "strict" and didn't find it.  i guess an old haskell memory.
17:17:30 <conal> i'll use prefix ($!), since "strict" has vanished
17:17:52 <Saizan_> (foo $!)
17:18:32 <conal> Saizan_: my real example is ($!) (runAnim . installGrid rows cols)
17:19:36 <Cale> :t \f g -> (f . g $!)
17:19:37 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
17:19:57 <mmorrow> good thing ($) is infixr!
17:20:00 <ehird> @hoogle a->a->[a]->[a]
17:20:00 <lambdabot> Prelude enumFromThenTo :: Enum a => a -> a -> a -> [a]
17:20:00 <lambdabot> Language.Haskell.TH.Syntax mkNameG_tc :: String -> String -> String -> Name
17:20:00 <lambdabot> Language.Haskell.TH CondE :: Exp -> Exp -> Exp -> Exp
17:20:03 <mmorrow> ;)
17:20:10 <Cale> It's not the infixr of it, I think
17:20:15 <Cale> It's the precedence.
17:20:22 <mmorrow> heh, i just realized that's the case
17:21:21 <mmorrow> > let (&) = ($); infixl 1 &; in (id . id &)
17:21:22 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
17:21:22 <lambdabot>    arising from a use of `...
17:21:50 <mmorrow> @type let (&) = ($); infixl 1 &; in (show . (*2) &)
17:21:52 <lambdabot> forall a. (Num a) => a -> String
17:22:21 <mmorrow> err, i don't think that example even says anything interesting..
17:22:49 <mmorrow> ooh, no it does
17:24:36 <soupdragon> ~ It's 3 o clock in the morning and I'm on the streets again, disobeyed another warning ~
17:25:08 <monochrom> Go back to your basement and code more Haskell.
17:25:25 <soupdragon> you mean my moms basement surely?
17:25:36 <monochrom> You don't have your own basement?
17:26:06 <Cale> Doesn't matter whose basement, just so long as it's a basement.
17:26:23 * mmorrow wonders that people without basements are to do
17:27:02 <Cale> I suppose you could dig a sort of pit somewhere, and code from there.
17:27:13 <mmorrow> yeah, that's what i was thinking too
17:27:19 <mmorrow> or find a cave
17:27:42 <mmorrow> and a long extension cord
17:27:57 <monochrom> If you dig yourself into a pit rather than out of, don't feel bad, keep digging and you will come out of it at the other end of Earth.
17:28:43 <gwern> '    DownNova automagically classifies and downloads interesting torrents from mininova.org.  It uses the  above mentioned Classify  library to intelligently recognize and rename files.
17:28:47 <gwern>     This might be abused for categorizing illegally downloaded material. That is however not the intended use of this program and I do not condone such activities.'
17:28:50 <gwern> hahaha. silly Lemmih
17:29:32 <gwern> @ask Lemmih http://darcs.haskell.org/~lemmih/aboutMe.html <-- is conjure really being actively developed?
17:29:33 <lambdabot> Consider it noted.
17:30:17 <gwern> you know, if you ever weary of cabal install pony, you can cabal install Frown instead
17:30:37 <ehird> that sounds depresing
17:30:40 <ehird> depressing
17:31:35 <gwern> sometimes one wants to be depressed
17:40:16 <conal> is there yet a hackage package with a generalized boolean class?
17:40:27 <Elly> generalized boolean?
17:40:46 <conal> to work around the limiting types of (==), (<=), if-then-else, etc
17:40:52 <copumpkin> like with (==) :: Boolean a => b -> b -> a ?
17:40:55 <SamB> conal: you mean like the top-level class of the three Bits should be broken into?
17:40:57 <copumpkin> whoops, Eq b
17:40:59 <conal> copumpkin: for instance.
17:41:14 <copumpkin> that'd be nice
17:41:25 <copumpkin> I really want to be able to write equations and inequalities to be solved
17:41:46 <conal> i keep rolling my own variations of those operators.
17:42:05 <conal> i'll play with it.
17:42:48 <Peaker> What methods would a boolean class have?  toBool/fromBool?
17:44:51 <conal> Peaker: working on a design now.  as an example, i want variations of (<) & (==) that operate on functions and expressions.
17:45:01 <conal> Peaker: returning boolean functions / expressions
17:45:50 <Peaker> conal: I see, you'd still need to have the concrete Eq/Ord of today, I think, for data structures such as Map/etc
17:52:41 <FunctorSalad> class BooleanAlgebraa?
17:52:44 <FunctorSalad> -a
17:53:09 <Raevel> what about it?
17:53:35 <FunctorSalad> Raevel: uh, just commenting on what conal and Peaker had been talking about
17:54:00 <Raevel> oh :-)
17:55:04 <Raevel> i used BooleanAlgebra once, felt good
18:01:11 <djahandarie> I want to change x = [("1", ["a", "b", c"]), ("2", ["a", "b", "c"])] into "1 a b c 2 a b c"... what's the best way to do this?
18:01:28 <djahandarie> It's basically just flattenting out the whole thing and unwording it
18:02:45 <FunctorSalad> djahandarie: unwords . fmap (\(x,y) -> unwords (x:y))    ?
18:02:52 <Saizan_> > unwords . concat . map (uncurry (:)) $  [("1", ["a", "b", c"]), ("2", ["a", "b", "c"])]
18:02:53 <lambdabot>   <no location info>:
18:02:53 <lambdabot>      lexical error in string/character literal at end o...
18:03:08 <Saizan_> > unwords . concat . map (uncurry (:)) $  [("1", ["a", "b", "c"]), ("2", ["a", "b", "c"])]
18:03:09 <lambdabot>   "1 a b c 2 a b c"
18:09:01 <djahandarie> Hm... which way is better? :P
18:09:17 <Saizan_> mine! absolutely!
18:09:31 <djahandarie> :P
18:10:09 <Saizan_> > unwords . fmap (\(x,y) -> unwords (x:y)) $  [("1", ["a", "b", "c"]), ("2", ["a", "b", "c"])]
18:10:11 <lambdabot>   "1 a b c 2 a b c"
18:10:45 <djahandarie> That looks friendlier to me because it doesn't have the uncurry
18:10:59 <Saizan_> don't be afraid of uncurry
18:11:04 <Saizan_> ?type uncurry
18:11:05 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
18:11:09 <Saizan_> ?src uncurry
18:11:10 <lambdabot> uncurry f p = f (fst p) (snd p)
18:11:30 <aavogt> @type curry . uncurry
18:11:31 <lambdabot> forall a b c. (a -> b -> c) -> a -> b -> c
18:11:41 <FunctorSalad> yes I considered it but pointlesser isn't *always* better
18:12:11 <copumpkin> I'd prefer pointful if it weren't a pain to type the lambda symbol instead of \
18:12:53 <Saizan_> > unwords . concat . map (\(x,y) -> (x:y)) $  [("1", ["a", "b", "c"]), ("2", ["a", "b", "c"])]
18:12:55 <lambdabot>   "1 a b c 2 a b c"
18:13:09 <Saizan_> i just don't like using unwords twice
18:14:09 <Saizan_> > unwords . listify $  [("1", ["a", "b", "c"]), ("2", ["a", "b", "c"])]
18:14:10 <lambdabot>   Couldn't match expected type `[GHC.Base.String]'
18:14:16 <Saizan_> :t listify
18:14:17 <lambdabot> forall r a. (Data a, Typeable r) => (r -> Bool) -> a -> [r]
18:14:21 <FunctorSalad> hmm right, actually it turned out correct (no double spaces) by pure luck ;)
18:14:29 <Saizan_> > unwords . listify (const True) $  [("1", ["a", "b", "c"]), ("2", ["a", "b", "c"])]
18:14:30 <lambdabot>   "1  a  b  c  2  a  b  c "
18:14:35 <FunctorSalad> hehe
18:14:38 <Saizan_> > listify (const True) $  [("1", ["a", "b", "c"]), ("2", ["a", "b", "c"])]
18:14:40 <lambdabot>   []
18:14:45 <Saizan_> > listify (const True) $  [("1", ["a", "b", "c"]), ("2", ["a", "b", "c"])] :: [String]
18:14:46 <lambdabot>   ["1","","a","","b","","c","","2","","a","","b","","c",""]
18:14:51 <Saizan_> ah!
18:16:56 <aavogt> > listify (<3) [1..]
18:17:01 <lambdabot>   mueval-core: Prelude.read: no parse
18:17:02 <lambdabot>  mueval: ExitFailure 1
18:17:07 <aavogt> > listify (<3) [1..10]
18:17:08 <lambdabot>   [1,2]
18:17:53 <ehird> <3
18:18:37 <aavogt> :[]
18:26:47 <Alpounet> g'night here.
18:40:12 <lowlycoder> how do I convert something from "Inferred type: X (Maybe String)" to "Expected type: IO (Maybe a)" ?
18:41:02 <copumpkin> @pl \f -> f . f . f
18:41:02 <lambdabot> ap (.) (join (.))
18:42:57 <byorgey> lowlycoder: you can't convert X to IO, but you can convert IO to X, with liftX
18:49:45 <djahandarie> Hm... in terms of design, if I have two primary cases, then multiple secondary cases under each primary case, what is the best way to format this? It would normally be a huge tree of if statements in a imperative language
18:51:05 * jthing is satisfied
18:55:54 <aavogt> djahandarie: pattern guards, case expressions, if, or define the top level as separate equations, or if you deal with the Nothing case use do notation?
18:57:22 <aavogt> those are the options, the 'best' is mostly an arbitrary style choice
19:01:08 <jmcarthur> people using do notation so much is why we still don't have things like :: (a -> b -> m c) -> (m a -> m b -> m c)
19:01:35 <jmcarthur> Monad m => ... , that is
19:02:31 <sw17ch> hello all
19:02:54 <aavogt> @type (join .) . liftM2
19:02:56 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m a2)
19:02:56 <lambdabot>     Probable cause: `liftM2' is applied to too few arguments
19:02:56 <lambdabot>     In the second argument of `(.)', namely `liftM2'
19:03:06 <aavogt> @type ((join .) .) . liftM2
19:03:07 <lambdabot> forall (m :: * -> *) a a1 a2. (Monad m) => (a1 -> a2 -> m a) -> m a1 -> m a2 -> m a
19:03:20 <sw17ch> is there any one who'd be willing to test a patch to HsOpenSSL's build process for me?
19:03:26 <sw17ch> i have it working without the ./configure step
19:03:37 <aavogt> jmcarthur: that should be a library function?
19:04:59 <aavogt> @type \f x y -> f <*> x <*> y
19:05:00 <lambdabot> forall (f :: * -> *) a a1 b. (Applicative f) => f (a -> a1 -> b) -> f a -> f a1 -> f b
19:05:37 <monochrom> do-notation is versatile. I prefer it to a suite of 140 combinators of 140 variations.
19:06:20 <pikhq> djahandarie: Just came from imperative-land?
19:06:35 <monochrom> There is this tendency in the haskell community to include all combinators implementable in 140 tokens or less in a standard library. Prelude.Twitter, Control.Monad.Twitter.
19:06:44 * pikhq is in the same boat; only started on Haskell last night.
19:06:47 <aavogt> @qote imperative
19:06:47 <lambdabot> Maybe you meant: quote vote
19:06:54 <aavogt> @quote imperative
19:06:54 <lambdabot> BMeph says: <BMeph> Welcome to Haskell Adventure! You are in a maze of twisty imperative statements, all alike. There is a lambda here. <monochrom> Where can I find out more about Haskell Adventure?
19:07:14 <aavogt> @quote 'best imperative'
19:07:15 <lambdabot> No quotes for this person. My brain just exploded
19:07:18 <aavogt> @quote imperative
19:07:19 <lambdabot> dibblego says: using logic in imperative programming language channels is generally considered trolling
19:08:31 <aavogt> monochrom: doesn't most of the Prelude already qualify for twitter?
19:08:43 <inimino> @quote
19:08:43 <lambdabot> audreyt says: yes, I'm aware that I'm abusing GHC beyond its designed purpose
19:08:52 <inimino> @quote
19:08:53 <lambdabot> astrolabe says: I guess missile launching would have to be in IO
19:09:05 <ben> aavogt: That would make a twitter bot I would totally be following
19:09:42 <monochrom> aavogt: Yes but apparently human greed is unlimited.
19:10:16 <jmcarthur> aavogt: yes, i think it should be in the library
19:10:37 <jmcarthur> we should have a family of those functions instead of the liftM family, since those are already covered by liftA
19:11:07 <aavogt> can applicative support such an operation?
19:11:24 <jmcarthur> liftA, liftA2, liftA3, etc. for Applicative... bind, bind2, bind3, etc. for Monad
19:11:32 <ben> Why did map end up not being overloaded over functors?
19:11:33 <jmcarthur> no, i'm pretty sure it can only be done in Monad
19:11:38 <FunctorSalad> is there a way to fix "Could not find module `Data.Data':      it is a member of the hidden package `base'" from the cabal command line, without editing the package?
19:12:05 <FunctorSalad> (the fix if you edit it is to set "base >= 4" in the deps)
19:12:12 <Saizan_> FunctorSalad: --constraint="base >= 4" doesn't work?
19:12:18 <FunctorSalad> Saizan_: no :(
19:12:25 <FunctorSalad> Saizan_: hmm let me try with the spaces
19:12:56 <FunctorSalad> still no luck
19:13:06 <Saizan_> that's what i experienced too
19:14:15 <aavogt> @undo \f x y - > do { a <- x; b <- y; f x y }
19:14:15 <lambdabot>  Parse error at "-" (column 8)
19:14:21 <aavogt> @undo \f x y -> do { a <- x; b <- y; f x y }
19:14:21 <lambdabot> \ f x y -> x >>= \ a -> y >>= \ b -> f x y
19:14:29 <BMeph> ben: FUD, mainly. <ducks>
19:14:32 <FunctorSalad> it's not completely ignored -- if you enter a bogus version it fails
19:14:52 <aavogt> same reason that  . /= fmap
19:15:47 * BMeph is continually annoyed when recalling that 'join' is not in the Prelude.
19:16:10 * ben is continually annoyed when not recalling what 'join' is doing in the first place
19:16:25 <aavogt> @src join
19:16:25 <lambdabot> join x =  x >>= id
19:16:31 <jmcarthur> aavogt: not the same as . and fmap. bind m k = join (fmap k m), and join is only in monad
19:16:35 <ben> Oh, that seems simple enough.
19:16:39 <jmcarthur> bind = (>>=)
19:17:12 <Cale> I just had an awesome idea thanks to BMeph's quote above...
19:17:18 <jmcarthur> we have >>= already, of course, but i wish we also had a family of bind functions, is all
19:18:02 <Cale> How about a Haskell tutorial/text adventure game, where there are Haskell values lying around and you combine them with your trusty evaluator to get the values you need to solve puzzles :)
19:18:05 <aavogt> jmcarthur: ? my comment about . and fmap was with regard to ben's question about the type of map
19:18:25 <Saizan_> FunctorSalad: yes, it's a subtle bug, caused by the special casing of base to allow base-3 to depend on base-4
19:18:29 <jmcarthur> wah! i have made a fool of myself!
19:18:43 <inimino> Cale: build it! :)
19:19:01 <aavogt> @where 40 questions type
19:19:01 <lambdabot> I know nothing about 40.
19:19:15 <jmcarthur> aavogt: actually, now the reason that (.) /= fmap is that (.) is already generalized for Category
19:19:22 <jmcarthur> arguably, that is where it really belongs anyway
19:19:50 <Saizan_> FunctorSalad: add your voice to http://hackage.haskell.org/trac/hackage/ticket/538 :)
19:20:24 <Cale> Hmm, we'll probably want hint for the actual evaluation, and we'll also need a way to parse things and make sure that the player doesn't use items that they don't have.
19:20:58 <aavogt> does anybody recall that that blog post with those exercises where you had to write instances for weirdly named classes?
19:21:07 <Cale> aavogt: yeah?
19:21:23 <Cale> I believe it was written by dibblego?
19:21:23 * ManateeLazyCat pasted "DoubleLinkedList.hs" at http://paste2.org/get/280448
19:21:24 <ManateeLazyCat> In above DoubleLinkedList.hs , I have function `insert`, create `newLeftNode` need `newNode`, but before create `newLeftNode`, `newNode` haven't created.  When running those code, ghci will report "Exception: stack overflow", i think i write wrong code, how to fix this? Thanks!
19:21:27 <aavogt> well, such questions could go in your game, Cale
19:21:46 <dibblego> Cale, what's that?
19:21:54 <dibblego> oh the blog post
19:22:11 <dibblego> aavogt, http://dibblego.wordpress.com/2008/07/17/haskell-exercises-for-beginners/
19:22:46 <dibblego> aavogt, http://dibblego.wordpress.com/2008/09/18/20-intermediate-haskell-exercises/
19:23:06 <FunctorSalad_> any alternative suggestions how to compile containers with -auto-all? ;)
19:23:07 <Cale> I was just thinking about the possibility of writing a text adventure game which featured Haskell evaluation.
19:23:31 <FunctorSalad_> except for accidentally recompiling the whole ghc...
19:23:41 <ManateeLazyCat> I think my code make GHCi create object recursive, then make stack overflow.
19:23:53 <aavogt> dibblego: that's the one. I think they are pretty good
19:24:06 <ManateeLazyCat> Someone help me? Thanks!
19:26:28 <ManateeLazyCat> If write `Node` like this "data Node a = Node {nodeLeft :: IORef (Maybe (Node a)), nodeRight :: IORef (Maybe (Node a))}, problem will be simple, i just use `modifiedIORef` modified `nodeLeft` and `nodeRight`. But i don't want use IORef in  library `DoubledLinkedList.hs`, have a better solution?
19:30:27 <jmcarthur> ManateeLazyCat: if you want a pure doubly linked list, you could look at http://hackage.haskell.org/packages/archive/liboleg/0.1.1/doc/html/Data-FDList.html
19:30:46 <FunctorSalad_> nvm my last question, solved
19:30:54 <ManateeLazyCat> jmcarthur: I have read it, but i don't like it's solution.
19:31:05 <jmcarthur> ManateeLazyCat: essentially it just uses an IntMap to emulate pointers
19:31:15 <ManateeLazyCat> jmcarthur: Yep
19:31:18 <jmcarthur> yeah i know it seems inelegant, but sometimes that's just the best you can do
19:31:39 <ManateeLazyCat> jmcarthur: But i want better search effective.
19:31:55 <ManateeLazyCat> jmcarthur: So i use Data.Set maintain node list.
19:32:48 <ManateeLazyCat> jmcarthur: I make `nodeLeft` and `nodeRight` with `Maybe (Node a)`, and not `Int`, then i just need constant time if i insert right side or left side.
19:33:07 <jmcarthur> oh i see
19:33:41 <jmcarthur> so it's like a zipper combined with Oleg's FDList
19:33:52 <ManateeLazyCat> jmcarthur: I use Data.Set maintain (Node a) list, and a is `Ord :: a`, then if i want search some node in doubledlinkedlist, it's efficient is O (log n), not O (n)
19:33:56 <jmcarthur> well, besides the IORef thing
19:34:16 <jmcarthur> but O(1) if it's just nodeLeft or nodeRight, gotcha
19:35:02 <jmcarthur> i like your idea, but unfortunately i can't think of a way to do away with the IORef. you could use STRef, but that doesn't make the structure less imperative
19:35:07 <mmorrow> what if you insert a new node?
19:35:14 <mmorrow> O(lg n)
19:35:37 <jmcarthur> yeah, that isn't constant time either. it's only constant time update i guess
19:35:42 <mmorrow> and how do you get the node you're inserting if it's not new? Set lookup?
19:36:02 * mmorrow doesn't see how this is asymptotically better than using IntMap
19:36:13 <mmorrow> and IntMap surely has a smaller constant
19:36:33 <ManateeLazyCat> mmorrow: Better search efficient with Data.Set
19:36:39 <jmcarthur> it isn't. it's only better in that you can keep a pointer into the list and get constant time update in that area
19:36:49 <mmorrow> especially of compare on the elems in the Set isn't O(1)
19:36:52 <jmcarthur> the other stuff is probably slower
19:36:54 <mmorrow> s/of/if/
19:37:05 <jmcarthur> the Set probably is only comparing IORefs
19:37:18 <ManateeLazyCat> jmcarthur: If i change Node with "Node {nodeLeft :: IORef (Maybe (Node a)), nodeRight :: IORef (Maybe (Node a))}, my problem is very simple
19:37:19 <mmorrow> err, what is the datatype we're talking about here
19:37:24 <mmorrow> ok
19:37:31 <ManateeLazyCat> jmcarthur: But i don't want embedded IORef in library code.
19:37:39 <jmcarthur> mmorrow: it's a zipper with IORefs on each node
19:37:45 <mmorrow> if we're using IORefs, why bother with Set at all?
19:37:47 <jmcarthur> as far as i can tell
19:38:08 <jmcarthur> dunno
19:38:09 <ManateeLazyCat> mmorrow: http://paste2.org/get/280448
19:38:17 * mmorrow looks
19:39:15 <ManateeLazyCat> jmcarthur: Data.Set just for search (Node a), and a is `Ord :: a`, Node structure have `nodeLeft` and `nodeRight` to keep reference previous or next node.
19:39:16 <mmorrow> ah, ok. since you're comparing on the Int, i'd just use IntMap
19:39:25 <jmcarthur> ah yea, i think oleg's is gonna be faster here
19:39:26 <mmorrow> because it'll be much faster than Set
19:40:14 <ManateeLazyCat> mmorrow: How to search give node in IntMap?
19:40:46 <mmorrow> ManateeLazyCat: hmm, true. so this isn't just a doubly-linked list then.
19:40:56 <ManateeLazyCat> mmorrow: Yep.
19:41:03 * mmorrow thinks
19:41:15 <jmcarthur> well, oleg's also keeps a pointer, but i think it just dereferences it each time anyway
19:41:16 <ManateeLazyCat> mmorrow: I haven't know a better name before i finish it.
19:41:23 <ManateeLazyCat> s/think/know
19:42:00 <jmcarthur> oh your code is actually based on oleg's. woops :)
19:42:25 <ManateeLazyCat> jmcarthur:  oleg's ?
19:42:31 <jmcarthur> FDList
19:43:37 <ManateeLazyCat> jmcarthur: Yep, i read it's code, but i won't copy it's code, i haven't finish it, it's in testing.....
19:44:02 <ManateeLazyCat> jmcarthur: I just want to use Data.Set improve `search` efficient.
19:45:07 <jmcarthur> i'm still a little confused about what you mean by "search", i think
19:45:39 <copumpkin> set membership checking?
19:46:20 <jmcarthur> copumpkin: well, each node has a unique Int id, it looks like, so a set of nodes is effectively an IntMap anyway, i think
19:47:02 <jmcarthur> i guess the set could store more than one node per id, but that's probably an invariant
19:47:15 <jmcarthur> that it shouldn't, i mean
19:47:17 <djahandarie> Is there a native Haskell dbms?
19:47:25 <djahandarie> Similar to what mnesia is for Erlang
19:47:28 <ManateeLazyCat> jmcarthur: If i want to search another node (not current node) in doubledlinkedlist, use Data.Set is faster
19:47:55 <jmcarthur> faster than an IntMap? really?
19:47:57 <ManateeLazyCat> jmcarthur: `nodeRef` in Node just for Data.Set for search.
19:49:32 <jmcarthur> djahandarie: look at happstack-state and tcache, maybe? they aren't databases, just persistent storage, but happstack-state does provide ACID guarantees. not sure about TCache
19:49:38 <jmcarthur> there are probably other things, too
19:49:56 <djahandarie> Okay. Persistent storage is really all I need
19:50:07 <jmcarthur> happstack-state stores everything in memory, btw
19:50:15 <copumpkin> that happstack-state feels like it needs to drop the happstack prefix :P
19:50:15 <jmcarthur> it just serializes to hard drive for persistence
19:50:20 <copumpkin> it seems like it should be generally useful
19:50:21 <jmcarthur> copumpkin: i agree 100%
19:50:31 <jmcarthur> the same for all the other happstack parts
19:50:45 <jmcarthur> and many of the utils should separate from happstack-utils, too
19:51:14 <jmcarthur> i and a few others are currently pushing for a separation on the happs mailing list
19:51:38 <jmcarthur> probably a low priority thing to do, though
19:51:43 <ManateeLazyCat> jmcarthur: In IntMap, if i want search random element, it efficiency is?
19:52:10 <jmcarthur> Set has O(log n) and IntMap has O(log n), but the IntMap should have smaller constants
20:03:12 <hackagebot> Omega 0.1.1 - Operations on Presburger arithmetic formulae (ChristopherRodrigues)
20:04:38 <ManateeL`> jmcarthur: In my code, i use `Maybe (Node a)` replace unique id for next node, then i don't need search in list before i insert new node.
20:05:46 <ManateeL`> jmcarthur: Problem is i haven't better idea that reference next node that won't use IORef.
20:07:48 <mmorrow> ManateeL`: i'd use something like this:
20:07:49 <mmorrow> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6199#a6199
20:07:59 <mmorrow> which is similar to http://www.cs.tufts.edu/~nr/pubs/zipcfg-abstract.html
20:08:30 <mmorrow> (but the datastructure in that paper is a zipper on a graph, while ZList in that paste is a zipper on a doubly-linked list)
20:08:55 <mmorrow> well, a doubly-linked list *is* technically a graph
20:09:43 <mmorrow> (and lookup is O(lg n) in ZList too)
20:09:58 <ManateeL`> mmorrow: Thanks, i read it.
20:10:03 <mmorrow> :)
20:10:18 <mmorrow> ManateeL`: what are your thoughts?
20:10:50 <ManateeL`> mmorrow: You write those code right now?
20:11:13 <mmorrow> ManateeL`: yes, but that code is very fresh in my mind since i'm using that ZGraph too for another project
20:11:25 <mmorrow> and it's essentially the same
20:11:37 <ManateeL`> mmorrow: Too fast, cool. :)
20:11:44 <mmorrow> heh
20:11:58 <ManateeL`> mmorrow: Yep, i write DoubledLinkedList for my project too. :)
20:12:24 <Gracenotes> hm. anyone know any builtin recursive constructors besides (:) for [] and Node for Tree?
20:13:16 <mmorrow> Gracenotes: the other containers modules have some, but they're not exported
20:13:24 <mmorrow> (not sure if that counts)
20:13:35 <ManateeL`> mmorrow: Okay, your code looks very cool, maybe i don't need write it self. I will read your code later, now i need cooking for lunch. Thank you very much! :)
20:13:39 <Gracenotes> nothing else in base?
20:13:47 <mmorrow> ManateeL`: no problem, good luck :)
20:13:54 <Gracenotes> yeah, I know about Set and Map and whatnot
20:14:25 <mmorrow> Gracenotes: nothing else i can think of
20:15:35 <Gracenotes> D:
20:22:45 <mmorrow> ManateeL`: ah, i just realized that insertR/L should first check in the (Map a Int) to see if the `a' is *already* in the list, and if so just use its nodeId so it can be shared
20:23:07 <mmorrow> so it really would be a graph then
20:26:38 <mmorrow> hmm, or possible you might not want to do that, because then you could get loops in your list.. i guess it depends on what you want
20:30:13 <nainaide> How to make statically linked application in GHC 6.10.3
20:31:09 <copumpkin> is there a good binding to all of openssl in haskell? I need some of the more esoteric things
20:32:01 <copumpkin> I gues HsOpenSSL might provide what I need
20:32:31 <copumpkin> aha, hsopenssl+asn1
20:37:26 <djahandarie> But it complains and says (head c == '#') returns m Bool
20:37:41 <cjs> How do I get rid of the boilerplate in http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6200 ?
20:37:54 <djahandarie> So if I do Monad m => String -> m Bool for the type
20:38:03 <djahandarie> Then the if complains and says it doesn't want a m Bool
20:38:52 <mmorrow> cjs: data Foo a = One a | More a (Foo a) -- maybe
20:39:03 <mmorrow> for non-empty lists
20:39:29 <copumpkin> hmm, newbinary seems to care about the S# and J# :(
20:39:46 <mmorrow> isn't newbinary really the old binary?
20:39:49 <cjs> mmorrow: I don't quite get what you mean.
20:39:54 <copumpkin> wtf
20:39:59 <copumpkin> why is oldbinary called newbinary? :P
20:40:02 <mmorrow> cjs: oh, what boilerplate do you mean?
20:40:07 <mmorrow> copumpkin: haha
20:40:18 <copumpkin> it's stopping me from installing the asn1 package, dammit :P
20:40:26 <copumpkin> ah well, asn.1 will have to wait
20:40:31 <mmorrow> cjs: (i thought you meant the "error" calls)
20:40:37 <cjs> omMsgType, omMsgSeqNo and omDate are all basically doing the same thing; I'd like to extract as much of that as possible out to a separate function.
20:40:45 <mmorrow> ahh, i see
20:40:49 <cjs> They problem is, they use pattern matching.
20:40:57 <cjs> And they have different return types.
20:41:00 <djahandarie> Let me restate: When I try to return (x == y) it says it's a m Bool. but when I pass an m Bool to an if, it complains and wants a Bool
20:41:16 <cjs> Oh, hmmm. So I want a function that just checks the match, and returns Maybe a....
20:41:16 <soupdragon> cjs: First deal with the recursion
20:41:19 <mmorrow> cjs: oh, i totally missed the point :)
20:42:01 <mmorrow> maybe use a record?
20:42:36 <mmorrow> because it seems like OMMessage has to have all the fields anyways..
20:43:12 <mmorrow> (also, list comprehensions are nice for this type of thing, if you don't go with the record)
20:43:17 <cjs> The problem is, my parser constructs it on the fly.
20:43:30 <mmorrow> [ t:_ | SeqNo t <- fs]
20:43:40 <mmorrow> oops
20:43:43 <Gracenotes> wha
20:43:45 <mmorrow> head [ t | SeqNo t <- fs]
20:46:23 <cjs> mmorrow: Ah, cool!
20:48:01 <soupdragon> I annotated your paste http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6200#a6201
20:48:41 <ac> is there a way I can show my source code after all the template haskell has been expanded?
20:50:29 <mmorrow> ac: -ddump-splices
20:51:02 <dmwit> :t find
20:51:03 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
20:51:09 <dmwit> cjs: find is better
20:51:11 <mmorrow> ac: but that won't show you the complete module code with the splices inserted in the appropriate places though
20:51:19 <dmwit> It's more honest to return a Maybe. ;-)
20:51:33 <djahandarie> ischan :: String -> Bool
20:51:35 <djahandarie> ischan c = return (head c == '#')
20:51:44 <djahandarie> Why does it think that returns an m Bool?
20:51:50 <dmwit> djahandarie: Because you're calling return.
20:51:58 <gwern> djahandarie: remove the return
20:52:03 <djahandarie> Ah
20:52:05 <djahandarie> ...
20:52:07 <djahandarie> -_-
20:52:10 <gwern> == returns a Bool, no need for return to wrap it in a m ()
20:52:11 <mmorrow> @type return
20:52:12 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
20:52:54 <gwern> djahandarie: you are probably thinking of other languages where return is more part of the syntax than a monadic function occasionally useful
20:53:10 <djahandarie> Yeah, that was a stupid mistake on my part
20:53:11 <ac> mmorrow: thanks
20:53:15 <djahandarie> Thanks
20:53:26 <cjs> soupdragon: That doesn't really seem to reduce the boilerplate much....
20:53:59 <BMeph> djahandarie: First thing that may be helpful for you: "return" is not just syntax to get the answer to a function...never mind. Dumb Internet lag. :\
20:54:36 <gwern> BMeph: jinx
20:54:38 <ac> mmorrow: I'm trying to figure out how to use the chunks module
20:54:53 <BMeph> gwern: No jinx, I was slow. :)
20:55:13 <ac> I can't find an example template
20:55:22 <mmorrow> what's the chunks module?
20:55:49 <ac> supposed to be a nice way to insert the contents of a template file in to source code when you compile it
20:55:53 <mmorrow> or what would such an example template need to do?
20:56:07 <mmorrow> oh, i see
20:56:10 <ac> a type safe compile time templating system
20:56:10 <mmorrow> so something like:
20:56:46 <ac> the docs just give me the TH function: $(chunksFromFile "blah.html")
20:57:13 <ac> and that gets turned in to a variable I assume, and a data type that holds the template variables, but it doesn't say exactly what they're called
20:57:44 <mmorrow> insertChunkButCheckFirst :: (String -> Maybe String) -> FilePath -> ExpQ; insertChunkButCheckFirst check file = do a <- runIO (readFile file); case check a of Nothing -> fail "type error"; Just a -> lift a
20:58:28 <ac> time to dig through the source code I guess
20:58:36 <mmorrow> ac: what's the type of chunksFromFile?
20:58:42 <mmorrow> (ExpQ or DecQ?)
20:58:45 <soupdragon> cjs: can you post a version which is a good solution?
20:58:50 <mmorrow> err, or (Q [Dec]) i mean
20:59:12 <mmorrow> if it's ExpQ, it just becomes an expression without a name
20:59:30 <mmorrow> myChunk = $(chunksFromFile "foo.html")
20:59:46 <mmorrow> if it's a (Q [Dec]), then you'd put $(chunksFromFile "foo.html") at the module top-level
20:59:56 <mmorrow> (and who knows what name it would be bound to)
21:00:08 <ac> the type is Q [Dec]
21:00:10 <mmorrow> it could even spit out classes, data decls, types
21:00:18 <sw17ch> hey, does any one here maintain HsOpenSSL or use it?
21:00:29 <mmorrow> ac: ooh, hmm. then it's gotta explain what it's splicing somewhere i'd imagine
21:00:44 <mmorrow> because there's no way you could know
21:01:09 <ac> it should spit out an instance of Chunk, a data type that I can feed to format, and a value of type (Chunk a) => a
21:01:16 <mmorrow> ac: one way to see it though would be to use the haskell-src-meta pkg, and then in ghci do:
21:01:29 <mmorrow> ghci> ppDoc $(lift =<< chunksFromFile "foo.html")
21:01:37 <mmorrow> will prettyprint the source code
21:01:46 <ac> oh cool
21:01:57 <ac> where does ppDoc come from?
21:02:03 <mmorrow> (you'd need :m + Language.Haskell.Meta.Utils Language.Haskell.TH.Syntax)
21:02:11 <mmorrow> from the former of those two imports
21:02:34 <mmorrow> also, the first import gives you instances of Lift for all the TH AST, which you need to be able to view that in ghci
21:02:45 <cjs> soupdragon: Working on it!
21:02:47 <mmorrow> or else you'd get a "can't do reify in the IO monad" error
21:03:05 <mmorrow> (if chunksFromFile uses reify that is)
21:03:37 <ac> (installing haskell-src-meta)
21:04:10 <mmorrow> grr, hopefully you don't have the newest haskell-src-exts, because i need to update the .cabal in src-meta..
21:04:14 * mmorrow does that now
21:04:17 <ac> "cabal: happy version >=1.17 is required but it could not be found"
21:04:29 <cjs> soupdragon: Try this one out: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6200#a6204
21:04:34 <ac> it'd be nice if I didn't have to follow the dependency trail to get the actual error
21:04:40 <lpsmith> Does anybody know how to turn on logging in HappStack?
21:04:56 <cjs> That "Missing" thing is a bit of a hack, but I can't think of a way around it that isn't quite verbose.
21:04:59 <ac> lpsmith: no, but what're you up to with happstack?
21:06:38 <ac> does anybody know exactly how happstack handles requests? Specifically does it spawn a thread for each request?
21:07:00 <lpsmith> ac:  a bit of local integration
21:07:10 <ac> if one request blocks, does it tie up the whole server?
21:08:39 <elbar> dunno, but a server that fragile wouldn't sound like a good idea
21:08:45 <Saizan_> ac: ues, it spawns a thread for each request
21:10:31 * ac knows nothing about threaded Haskell
21:10:57 <copumpkin> long live the state thread
21:11:23 <Saizan_> basically ghc provides user-land threads which are scheduled on the available OS threads
21:11:51 <Saizan_> you can control the number of OS threads to be created with +RTS -Nn
21:12:16 <Saizan_> all of this if you compile with -threaded, so that you use the threaded runtime
21:12:18 <djahandarie> Hmm. Is there any easy way to parse XML with Haskell?
21:12:49 <ac> Saizan_: do all these threads see the same variables?
21:12:57 <sjanssen> djahandarie: there are several libraries for it on Hackage
21:13:19 <ac> Saizan_: like if you make an IORef and read/write to it with several threads, you'll run in to inconsistencies
21:13:27 <Saizan_> ac: yeah
21:13:39 <Saizan_> ac: that's why we use MVars for those cases
21:14:07 <ac> ok. Hopefully happstack's State library takes care of all that for me
21:14:45 <Saizan_> well, it's based on transactions
21:15:08 <Saizan_> you get to decide what has to be considered atomic
21:15:17 <djahandarie> sjanssen, I'm not too good with figuring out how to use these Libraries without a guide of sorts
21:16:51 <cjs> ac: GHC runtime multiplexes it's own threads over OS threads. So link with "-threaded" and when you run your program use "+RTS -N 7 -RTS" or whatever to set up an appropriate number of OS threads for your CPU. The runtime threads are very, very cheap; it's no problem to have millions. Blocked threads do not have any effect on other threads in the system.
21:17:47 <ac> cjs: yeah, I think I've read that before. So I must compile with -threaded whenever I run my happs server
21:18:07 <cjs> Right. And don't forget to run it with the RTS -N option.
21:18:30 <cjs> Otherwise it will by default use only one OS thread, and you'll be even slower than compiling without '-threaded'. :-)
21:19:02 <ac> well, it'd still be worth it for the concurrency aspect if some of my requests took a significant number of cycles
21:19:03 <cjs> There is a way to set that to a default when you link your program, by the way. But it involves compiling and linking in a C file.
21:19:44 <cjs> ac: Yes. I've got apps that happily use more than 500% CPU from time to time. Not to mention that you also get parallel GC.
21:19:50 <Saizan_> the threaded runtime at least doesn't block all the threads when one calls a blocking syscall
21:20:34 <cjs> BTW, if you have an 8-core machine (such as an i7), you want to use -N 7 rather than -N 8, I think. Some benchmarks I saw were unreliable (in terms of how long they took) at -N 8, but consistent at -N 7.
21:20:50 <cjs> This may have been related to how Linux was scheduling the OS threads.
21:22:17 <ac> good to know I suppose. I have no idea what sort of machine I'll be running this on so far. Need to find a webhost that gives me a whole virtual machine
21:24:14 <cjs> Do you? You could always set yourself up on a shared host by configuring your apache (or whatever) virtual server to proxy the requests back to your Happs server running on a different port.
21:24:42 <cjs> We in fact do this on our non-shared production machines, so that separate applications can run their own web server configurations.
21:25:12 <ac> hrm, I imagine a lot of hosts don't even have mod_proxy (that's what you're using, right?)
21:26:05 <cjs> Actually, we use lighttpd.
21:26:35 <cjs> I wouldn't know if most shared hosting services have mod_proxy or not, but I would think that they would. Usually they load up on all the features, and mod_proxy is pretty standard.
21:27:20 <ac> cjs: sounds like you have a happs site up. What do you use for templating?
21:34:26 <koninkje_away> I'm having some strange SMTP issues where deleting emails takes a very long time (and usually times out when deleting multiple messages) both with Thunderbird and SquirrelMail. Is this a known issue?
21:34:57 <inimino> ?
21:35:07 <inimino> koninkje_away: wrong channel?
21:35:21 <koninkje_away> whoops, next channel over :)
21:35:38 <shapr> Yay Boston Haskell User Group!
21:36:34 <ac> shapr: sweet. Seattle just has seafunc (functional programming group)
21:36:45 <shapr> ac: You could start a SHUG
21:37:27 * Cale wonders if there is another Haskell user in his city.
21:38:33 <ac> bah. I hate broken packages
21:38:43 <ryant5000> hey shapr :)
21:38:46 <ryant5000> long time no see, lol
21:39:44 <holmak> Hey, I'm in Seattle.
21:39:54 <ac> holmak: yay
21:39:58 <holmak> Not a terribly dedicated Haskell user though
21:40:08 <ac> holmak: oh. Just going to ask if you wanted to start a SHUG :-P
21:40:15 <holmak> Haha
21:40:24 <holmak> Well, it would be hilarious
21:41:38 <ac> grr, I have happy 1.18 installed, and haskell-src-exts still fails to install because it needs happy >= 1.17
21:41:54 <ac> holmak: which neighborhood?
21:42:10 <holmak> MS campus, so, Redmond area
21:42:26 <holmak> Not exactly Seattle
21:43:09 <ac> close enough
21:43:38 <ac> ever go to seafunc meetings?
21:44:20 <holmak> Never heard of it
21:46:04 <ac> thing is, happy isn't even appearing in "ghc-pkg list". Could this be a problem?
21:46:25 <hiredman> ac: I have been eyeing them, but actully showing up for something other people goes against my crazy recluse life plan
21:46:58 <holmak> hiredman: Haven't I seen you over in #clojure ?
21:47:04 <ac> I've showed up a few times. They're all pretty smart
21:47:07 <hiredman> yessir
21:47:19 <ac> so usually it's pretty interesting
21:48:21 <ac> and they all seem to be working on projects that are a good deal cooler than whatever I happen to be working on
21:48:26 <holmak> It would be pretty crazy to actually see a functional programmer in the flesh.
21:48:43 <hiredman> oh man
21:49:07 <ac> really? They all just look like nerds
21:49:09 <holmak> functional programmers: fact or fiction?
21:49:12 <bos31337> ()
21:49:32 <holmak> ac: Eh, I've accepted that the Haskell community does not work on any project that couldn't potentially cause the Singularity.
21:49:59 <ac> holmak: heh. I ultimately intend to work on such a project, just haven't gotten my act together quite yet
21:50:09 <holmak> Yeah me neither
21:50:28 <holmak> Why did bos31337 make a Unicode-face?
21:50:52 <pstickne> why not?
21:50:55 <bos> > let a  b = a + b
21:50:57 <lambdabot>   <no location info>: lexical error at character '\1641'
21:50:59 <bos> hmph
21:51:01 <ac> how do I convince cabal install that happy >= 1.17 is actually already installed?
21:51:05 <lpsmith> holmak:  I think you misjudge the Haskell community.   I won't speak for everybody,  but I for one think the singularity is a crock o' poo.
21:51:40 <pstickne> lpsmith:  terminal velocity or cyclic then?
21:51:51 <holmak> lpsmith: Well, I didn't mean to step on any toes. Just a little hyperbole... :D
21:52:05 <Saizan_> ac: do you have it on your $PATH ?
21:52:11 <ac> Saizan_: yeah
21:52:15 <Gracenotes> > let () a b = a + b in 1 `` 2
21:52:17 <lambdabot>   <no location info>: lexical error at character '\1641'
21:52:19 <lpsmith> holmak:  no offense taken :-)
21:52:34 <Saizan_> ac: are you calling cabal from the same user? i.e. not with sudo?
21:52:47 <Cale> (_)
21:52:47 <ac> Saizan_: yep, it's all as my user
21:52:58 <Gracenotes> ARABIC-INDIC DIGIT NINE
21:53:19 <bos> unicode opens up a new world of text art
21:53:22 <Gracenotes> > let (a) a b = a + b in 1 `a` 2
21:53:23 <lambdabot>   3
21:53:31 <Saizan_> ac: weird, it should pick it up if it's on your $PATH, however you can pass --with-happy=path/to/happy
21:53:34 <Gracenotes> hehe. it's not a valid symbol because it's a number
21:53:38 <bos> oh, nice!
21:53:40 <Gracenotes> albeit an arabic number
21:53:44 <mauke> > "\0"
21:53:45 <lambdabot>   "\NUL\1641"
21:53:54 <bos> and there i was, thinking we already had a perfectly good 9
21:53:56 <lpsmith> pstickne:  I'm not sure what you are speaking of,  I hope we will maintain steady technological progress,  but I really don't think that will ever be fully automated.
21:54:08 <Cale> (_)
21:54:09 <bos> > isDigit '\1641'
21:54:09 <holmak> Gracenotes: Didn't I see you get thrown out of ##java ?
21:54:10 <lambdabot>   False
21:54:14 <bos> huh
21:54:19 <Gracenotes> holmak: yep
21:54:29 <ac> Saizan_: excellent. Looks like that worked
21:54:39 <holmak> Gracenotes: Your ban took me out as well, we apparently are using the same ISP :D
21:54:43 <Cale> Haha, why'd you get thrown out of ##java?
21:54:50 <mauke> > isDigit '\x969'
21:54:51 <lambdabot>   False
21:54:52 <lpsmith> Indeed,  I want to hear the story!
21:54:58 <pstickne> lpsmith:  I thought the point behind the 'singularity' was an ever-increasing rate of progress/advancement
21:54:58 <holmak> Gracenotes was going on about cats or something
21:55:11 <Gracenotes> holmak: that wasn't me, that was someone else who was also talking about kitties
21:55:15 <pstickne> holmak:  and I still can't talk about kittens in there :(
21:55:31 * Gracenotes points at pstickne
21:55:46 <ac> hum, ghc should define special character as anything but [abcd...] rather than [!@#$%^...]
21:55:54 <holmak> Yeah, I don't know why there is a whole gang of us here in both #Haskell and ##java
21:56:13 <holmak> Seems like a strange combination of interests...
21:56:13 <Gracenotes> I went asking javabot about cat factoids
21:56:16 <lpsmith> pstickne:  well, if you ever have read any of Kurtzweils work,   there's a lot more to it than that.  But honestly,  I really can't stomach his writing
21:56:20 <pstickne> holmak:  it's because the languages are based on the same underlying philosophies and principles! :)
21:56:23 <Gracenotes> and then someone gave a kickban warning but I didn't see it
21:56:30 <Gracenotes> and I asked about enterprise kitties
21:56:48 <inimino> haha
21:56:52 <holmak> Saying enterprise ought to get you whitelisted in ##java
21:57:02 <inimino> enterprise kitties
21:57:07 <inimino> that's worth a ban
21:57:17 <holmak> I swear, ##java reminds me of an 1800s-style sanitarium
21:57:34 <holmak> Total madness, with sporadic heavy-handed discipline from the administrators
21:57:41 <lpsmith> See, I like cats.   Lambda Cats,  concatenative cats,  actual real life cats.   It's all good
21:57:42 <inimino> at least a ban from ##java
21:57:42 <Gracenotes> holmak: I take it you haven't seen ##c++ then
21:57:44 * inimino honestly can't imagine wanting to be in ##java anyway
21:58:01 <holmak> inimino: I am engaging in IRC anthropology
21:58:11 <holmak> And no, I have not seen ##c++
21:58:15 <holmak> Now I am intrigued
21:58:25 <pikhq> ##c++ -- the only channel to ban-kick you for being wrong about some minor detail concerning the language.
21:58:46 <holmak> Pardon my language, but is there a #brainfuck ?
21:58:54 <mauke> simple solution: don't be wrong
21:58:56 <Gracenotes> #esoteric
21:58:57 <pstickne> BF is an esoteric language
21:59:10 <inimino> apparently there is
21:59:12 <pikhq> ##brainfuck, and yes, but #esoteric is where most all interested are at.
21:59:13 <holmak> pstickne: And all this time I thought they were serious.
21:59:50 <pikhq> pstickne: ,[.,] most elegant implementation of cat EVER
22:00:10 <pstickne> looks ... dead :(
22:00:17 <holmak> At one point I wanted to create a cross-compiler from a sane language to something like BF
22:00:24 <Gracenotes> pikhq: not getContents >>= putStrLn? :)
22:00:41 <mauke> pikhq: only in brainfucks that use 0 for EOF
22:01:01 <pikhq> holmak: I wrote a macro language for it a couple years back. Fun hack.
22:01:33 <holmak> pikhq: Are you saying you wrote a metaprogramming system for BF?
22:01:36 <Gracenotes> macros would be useful in brainfuck. in most esoteric languages.
22:01:41 <pikhq> holmak: Yes.
22:01:47 <holmak> Can you imagine? Making BF homoiconic...somehow?
22:01:49 <Gracenotes> where you have to do repeated tasks
22:01:52 <ac> mmorrow: finally got haskell-src-meta installed, and that command produced: No instances for (Data.Data.Data (Q Exp), Language.Haskell.TH.Ppr.Ppr (Q Exp))
22:02:08 <holmak> You could trick legions of Lisp programmers into writing BF!
22:02:09 <ac> these exceptions are beyond my level of Haskell comprehension
22:02:18 <pikhq> Very hackish (implemented as a DSL in Tcl), but...
22:02:21 <mmorrow> what was the command you typed?
22:02:25 <lpsmith> mauke:   indeed,  but only one problem... who decides who is wrong ;-)
22:02:27 <mauke> type error or dadaism?
22:02:31 <mauke> lpsmith: I do
22:02:33 <mmorrow> ac: what was the command you typed?
22:02:38 <ac> mmorrow: ppDoc $(lift =<< chunksFromFile "test.html")
22:02:51 <mmorrow> and what's the type of chunksFromFile?
22:02:58 <mmorrow> ohh, i see
22:03:02 <mmorrow> do:
22:03:11 <ac> mmorrow: chunksFromFile :: FilePath -> Q [Dec]
22:03:17 <mmorrow> err, one sec
22:03:53 <mauke> what's the language with the shortest infinite loop?
22:04:04 <ac> brainfuck is pretty damn short: []
22:04:08 <cjs> ac: Sorry, no I don't have a Happs site. All my web server stuff is currently Ruby, but I hope to change that one day.
22:04:13 <pikhq> ac: +[]
22:04:14 <ac> er, +[]
22:04:15 <copumpkin> ac: wouldn't you need to increment the cell first?
22:04:18 <pikhq> The cells start at 0.
22:04:18 <copumpkin> yeah
22:04:24 <mauke> I can beat that: IF
22:04:29 <mauke> (works in ploki)
22:04:43 <pikhq> Now, what was it in Unlambda again...
22:04:51 <holmak> Are we playing golf? Did I stumble into #perl ?
22:04:51 <cjs> Regarding functional programming groups, you're all invited to Tokyo for TSAC tomorrow evening. :-)
22:04:57 <ac> mmorrow: what monad is lift lifting?
22:05:23 <Saizan_> cjs: is the 1:1 gundam still up? :)
22:05:37 <cjs> Haskell has a pretty short infinite loop: x=x
22:05:41 <cjs> Saizan_: Yes it is.
22:06:01 <mauke> ```sii``sii
22:06:07 <mmorrow> ac: ghci> :t Text.PrettyPrint.vcat . fmap ppDoc $ $(lift =<< chunksFromFile "template01.html")
22:06:16 <mauke> cjs: needs at least main=main
22:06:23 <mauke> and that could throw an exception
22:06:24 <mmorrow> ac: it's lifting [Dec] to an ExpQ, then splicing it back to a [Dec]
22:06:33 <mmorrow> then prettyprinting the [Dec]
22:06:39 <Gracenotes> @type ap id id
22:06:40 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> b
22:06:40 <lambdabot>     Probable cause: `id' is applied to too few arguments
22:06:40 <lambdabot>     In the second argument of `ap', namely `id'
22:06:55 <mmorrow> (you only need the $(lift =<< ...) if the "..." is using reify somewhere)
22:06:58 <Gracenotes> y combinator, huh
22:07:03 <cjs> Not if you compile with "--main-is x" :-)
22:07:13 <mmorrow> otherwise (a <- runQ (...)) would work
22:07:50 * pikhq should sleep; trying to figure out applicative functors at midnight is probably a bad idea.
22:07:51 <mauke> holmak: the best perl solution (non-cheating) is {redo}
22:08:02 <mauke> cheating: do$0
22:08:03 <lpsmith> you could do a two-character infinite loop,  maybe
22:08:09 <Saizan_> @pl ap id id
22:08:09 <lambdabot> join id
22:08:19 <lpsmith> if you were allowed to use a non-standard prelude
22:08:21 <holmak> I don't know Perl, I just know of the famed sport of Perl golf.
22:08:22 <ac> mmorrow: Ambiguous type variable `a' in the constraints: `Data.Data.Data a'
22:08:43 <ac> mmorrow: this code looks a little magical to me :-P
22:08:59 <mmorrow> ac: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2865#a2865
22:09:24 <mmorrow> did you import Language.Haskell.TH.Syntax and Language.Haskell.Meta.Utils ?
22:09:35 <ac> mmorrow: yeah
22:09:45 <mmorrow> hmm. what ghc are you using?
22:10:03 <ac> ghci 6.10.1
22:10:04 * mmorrow starts to wonder if his haskell-src-meta is haxxored
22:10:13 <copumpkin> omgwtfhax
22:10:35 <lpsmith> meh,  a one character infinite loop is obviously do-able with a nonstandard prelude...
22:10:42 <mmorrow> ac: i just made haskell-src-meta work with the newest haskell-src-exts, i'll upload that to hackage now
22:10:57 <mmorrow> ac: that's the only thing i can think could be happening
22:11:02 <ac> mmorrow: oh excellent. I'm using the real old version of src-exts
22:11:27 <ac> mmorrow: looks like you already did exactly what I'm trying to do. Can you hpaste the template source too? :)
22:12:25 <ac> I should learn more about this src-meta package. Looks useful
22:14:30 <cjs> Hm. What's up with this? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6205#a6205
22:15:06 <Saizan_> -main-is Main.x ?
22:15:18 <cjs> Tried that, same problem.
22:15:44 <hackagebot> haskell-src-meta 0.0.4 - Parse source to template-haskell abstract syntax. (MattMorrow)
22:15:49 <mmorrow> ac: http://hackage.haskell.org/package/haskell-src-meta-0.0.4
22:16:13 <mmorrow> ac: i used the template that came in chunks-2007.4.18/examples/template01.html
22:16:34 <Saizan_> cjs: you need a module Main where header too, it seems
22:16:42 <cjs> Darn it all!
22:16:46 <mmorrow> ac: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2865#a2866
22:16:58 <ac> mmorrow: ah, so there _IS_ an example template
22:17:03 <mmorrow> heh
22:17:06 <Saizan_> and anyway you get a <<loop>> exception, not really a loop :)
22:17:13 <mmorrow> wow, the hackagebot beat me to it
22:17:44 <cjs> And it doesn't even work!
22:17:56 <cjs> Running it just prints "x: <<loop>>", and then it exits.
22:18:01 <mmorrow> ac: err, so the "module Main (main) where" didn't come from the TH, it got added by "hstidy"
22:18:34 <cjs> Saizan_: What's up with that? Pretty silly runtime, when it won't do what you tell it.
22:19:25 <cjs> I even think that a non-terminating type-checker is a good thing. Then again, I like to play games while waiting for a compile. :-)
22:19:33 <ac> mmorrow: heh, that line is implicit anyway
22:20:09 <mmorrow> ac: grrr
22:20:28 <mmorrow> (haskell-src-exts seems to like being explicit)
22:20:55 <Saizan_> cjs: heh, that reminds me of an xkcd strip :)
22:22:27 <Gracenotes> speaking of which, latest xkcd...
22:22:30 <Gracenotes> .read.
22:22:43 <ac> (is awesome)
22:22:47 <Gracenotes> hm. could use more overt reference to game theory
22:23:05 <Gracenotes> oh. the title.
22:23:18 <Gracenotes> still, nerdiness
22:23:29 <lament> nerdy xkcd is nerdy
22:24:10 <ac> oh, there's a new one. The previous one is hilarious
22:24:20 <mmorrow> ac: if you try the newer haskell-src-meta and it doesn't work, let me know (although i can't imagine that it wouldn't work if it worked for me :/)
22:24:29 <dolio> No it isn't.
22:25:20 <mmorrow> dolio: oh hai
22:25:32 <dolio> What up, dawg?
22:25:40 <mmorrow> you know, stuff.
22:26:29 <ac> mmorrow: I must be doing something stupid. Same error
22:26:29 <mmorrow> dolio: i've almost got this interp i've been working on working! http://moonpatio.com/lem/
22:26:35 <mmorrow> ac: hmm
22:27:07 <mmorrow> ac: what if you just omit the "ppDoc" ?
22:27:23 <mmorrow> (that should be the only thing that's putting the Data constraint on anything)
22:27:44 <mmorrow> (you should just get a huge jumble of TH AST dumped to your term)
22:28:13 <mmorrow> at least, i think that's the only thing putting the Data constraint on anything
22:28:42 <dolio> mmorrow: It's all in one file there? Linked on Lem? :)
22:28:51 <mmorrow> dolio: heh
22:28:58 <ac> mmorrow: the problem is my template was broken
22:29:02 <ac> :-/
22:29:05 <mmorrow> dolio: not quiiiiiiite
22:29:22 <dolio> That seems like something you'd do.
22:29:23 <ac> mmorrow: works fine with the example template
22:29:24 * mmorrow is slightly disturbed by how many loc he has laying around
22:29:36 <mmorrow> ac: ahh, ok good :)
22:29:44 <mmorrow> dolio: haha
22:29:56 <dolio> Given that most of your code I see is dumped onto hpaste. :)
22:30:13 <mmorrow> dolio: but it's just so darn convenient! ;)
22:30:26 * mmorrow is teh lazy
22:31:52 * mmorrow returns to trying to implement graph dominators
22:32:57 <mmorrow> ac: ohhh, that makes sense now. when a (Q [Dec]) has an empty [], that's the error that happens, now that i think about it.
22:33:52 <ac> mmorrow: not what I'd expect
22:34:54 <mmorrow> me neither
22:36:35 * mmorrow likes HsColours new -icss options (black background), although at first he was horrified
22:36:58 <ac> ah, I was simply missing <!-- END --> :-[
22:37:45 <ac> I really like the chunks template system, where the text ends up in the binary, but the <!-- ##foo## --> syntax is horrifically verbose
22:42:55 <shepheb> anyone know if Turbinado is experimentation-ready, in the sense that I might try to prototype a website in it but not really deploy it in production.
22:56:24 <adu> hey
23:08:52 <dons> this is cool http://www.reddit.com/r/programming/comments/8v0zg/hey_reddit_im_the_15_year_old_that_was_asking/
23:10:27 <tommd> neat - is he in Portland?
23:11:27 <tommd> @#$@  Xen is frustrating.   I want my Arch system back.
23:11:27 <lambdabot>  Xen is frustrating.   I want my Arch system back.
23:11:47 <tommd> @#$# Lambdabot doesn't know when to keep its trap shut.
23:11:47 <lambdabot> Unknown command, try @list
23:12:18 <dons> not sure. i pinged him to see if he wanted a copy of RWH though. might be fun :)
23:12:26 <dons> ah Xen.
23:12:40 <tommd> I want my ARM netbook and an L4 kernel.
23:13:01 <tommd> Forget all this x86 / x86-pae / x86_64 and Dom0 nonsense
23:13:21 <dons> hey, we just need this ghc on iphone business to go live
23:13:29 <tommd> Just need to get GHC running on ARM.
23:14:00 <tommd> I was wondering how well they'd draw a line between building an ARM backend and tying it to the IPhone platform.
23:14:06 <Saizan> which cpu is the iphone on?
23:14:31 <dons> tommd: we've had ghc on debian/arm in the past though
23:14:36 <copumpkin> new one is an ARM cortex-a8
23:14:58 * dons off to bed. nytol
23:15:08 <tommd> dons: But not registered I'm guessing?
23:15:09 <copumpkin> tommd: no one has an ARM codegen for ghc yet anyway...
23:15:18 <tommd> Oh, have a good night.
23:15:41 <tommd> copumpkin: No, but I have an ARM system developers book and an ARM netbook getting shipped here.
23:15:43 <copumpkin> I wanted to start working on one, but someone said working on llvm might be more productive
23:16:13 <copumpkin> as we can go from llvm to ARM as well as many other archs, and could probably submit patches to llvm for any issues we encountered
23:16:29 <tommd> It strikes me as more risky.  An ARM NCG for GHC seems likely to be accepted.  An LLVM backend might be more intrusive and thus less likely to be accepted.
23:16:56 <copumpkin> intrusive how?
23:17:45 <Saizan> isn't cmm already lower level than what llvm accepts?
23:17:48 <tommd> Perhaps I am being too ignorant - LLVM doesn't cause any issues with using our own GC or RTS.
23:18:03 <copumpkin> I don't think it has to
23:18:30 <copumpkin> at its lowest, I think you can just use llvm's intermediate representation as a codegen for multiple archs, but I may be mistaken
23:19:29 <tommd> So what would the project be?  Make sure GHC outputs decent cmm and have a LLVM front end for it?  Or perhaps make a GHC backend that outputs that LLVM asm like language, can't recall its name?
23:23:03 <copumpkin> tommd: as far as I understand it would be to write a GHC "native" codegen for http://llvm.org/docs/LangRef.html
23:23:37 <copumpkin> which would then be passed through one additional layer to become actual machine code
23:24:37 <tommd> copumpkin: Who suggested LLVM would be a better use of your time than an ARM NCG? (and thanks for the link)
23:25:18 <copumpkin> benl23, who knows someone who was going to start work on an llvm ncg anyway
23:28:34 <Axman6> tommd: LLVM could be used for producing ARM executables no?
23:28:42 <tommd> Sure it could
23:30:10 <copumpkin> tommd: anyway, it obviously wasn't an order not to do it :P he just knows more about GHC than I do and I trust his judgment, but I also enjoy ARM a lot, so if you were to start an ARM NCG project I'd still enjoy contributing :)
23:31:18 <mmorrow> http://groups.google.com/group/fa.haskell/msg/5a96df64500298d0
23:31:37 <tommd> copumpkin: Sure, I understand.  I have these conflicting desire for a simple, correct compiler pipeline while still having one that produces binaries on par with GHC (speed wise)
23:32:48 <copumpkin> the suggestion with regards to the llvm drawbacks was to submit patches to llvm to make it work for us, rather than rewriting most of their targets ourselves :P
23:33:02 <copumpkin> just because some parts don't work doesn't mean we can't use any of it
23:33:29 <copumpkin> but I remember augustss saying that they weren't very open to bug reports from him
23:33:30 <mmorrow> llvm also is all SSA'ed out, which is more targeted at compiling imperative languages
23:33:44 <mmorrow> ghc would need to scrap everything cmm, and rewrite it all
23:33:56 <copumpkin> yeah, I guess :/
23:34:25 <copumpkin> I really wish more people got exposure to more languages earlier in their lives, and would avoid the whole "all languages are the same thing with different syntax and stdlibs" outlook
23:34:51 <mmorrow> this is an interesting short paper http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.34.3282
23:36:50 <tommd> mmorrow: Having only read the title and the impressive name of the author... doesn't that contradict the 'SSA is for imperative langauges' comment you just made?
23:37:01 <mmorrow> tommd: read it :)
23:37:12 <tommd> Ok, ok
23:37:47 <copumpkin> ah well, I'm all for writing an ARM-specific NCG... as I said I enjoy the architecture enormously :P
23:37:56 <copumpkin> and it only seems to be growing these days
23:39:42 <mmorrow> it shows how converting to SSA is essentially converting an imperative program into a functional one
23:40:56 * copumpkin hits the hay
23:41:07 <hackagebot> sendfile 0.1 - A portable sendfile library (MatthewElder)
23:41:14 <mmorrow> night
23:41:17 <opqdonut> i should probably hit the road and cycle to work
23:41:30 <opqdonut> gah, hate mornings
23:44:03 * tommd reboots to a new kernel (compile finished!)
23:52:01 <mae> sendfile-0.1 is up: http://hackage.haskell.org/package/sendfile-0.1
23:54:38 <trofi_> cool. hackagebot has just announced
23:55:14 <mae> werd
23:55:21 <mae> well its portable across windows and linux so far
23:55:28 <mae> and falls back to a haskell portable implementation
