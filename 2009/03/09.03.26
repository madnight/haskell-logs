00:15:00 <Axman6> argh! frigging C assignment!
00:16:10 * Axman6 can't figure out this card shuffling algorithm
00:16:55 <vegai> Axman6: http://xkcd.com/221/
00:17:23 <Kvasir> I have a C assignment with cards too
00:17:32 <TSC> Maybe you're actually the same person
00:17:46 <Axman6> not so helpful when you're trying to do an out-shuffle :\
00:18:03 <TSC> What is an out-shuffle?
00:18:10 <Kvasir> mine is about poker, not shuffling
00:18:47 <Axman6> split the desk into k piles, and then take one card from each pile in turn, starting with the pile with the original top card on top
00:19:24 <Axman6> [1..10] -> ([1..5],[6..10]) -> [1,6,2,7,3,8,4,9,5,10]
00:19:35 <TSC> Ah, an anti-merge
00:19:43 <Axman6> yeah
00:19:44 <Kvasir> I have some 2D array with the cards and I have to print the score
00:20:29 <TSC> With 2 piles (like that example) it is a riffle shuffle
00:20:35 <Axman6> my algorithm works fine when k divides n (n cards, k piles), but getting the one where the first n % k piles have an extra card in them is difficult
00:20:41 <Axman6> yeah
00:21:10 <Axman6> but we're doing it with arbitrary numbers of piles
00:24:20 <Gracenotes> hm... C++ is seemingly more tolerable than C to deal with for simple stuff. It seems the slightest bit of misguided complication can screw things up, though :/
00:25:05 <wli> C++ is very close to a superset of C.
00:26:02 <Gracenotes> yes. In reference to the somewhat higher level libraries though.
00:26:26 <p_l> wli: I always got the impression that C++ is what happens when you try to package chaos in C syntax
00:50:34 <SubStack> @pl (\f -> f 1 2 3)
00:50:34 <lambdabot> flip (flip ($ 1) 2) 3
00:50:40 <SubStack> @pl (\f -> f 1 2 3 4 5 6)
00:50:40 <lambdabot> flip (flip (flip (flip (flip ($ 1) 2) 3) 4) 5) 6
00:50:43 <SubStack> bleh
00:51:26 <mmorrow> foldl flip ($ 1) [2..]
00:52:35 <mmorrow> (where that foldl is meant to be a "meta"-level)
00:52:42 <SubStack> @pl (\a b c d -> (\f -> f a b c d))
00:52:42 <lambdabot> (((flip .) . flip) .) . flip . flip id
00:53:15 <mmorrow> @pl \a b c d e -> g (f a b c d e)
00:53:15 <lambdabot> ((((g .) .) .) .) . f
00:53:20 <SubStack> hmm
00:53:37 <mmorrow> @pl \a b c d -> g (f a b c d)
00:53:37 <lambdabot> (((g .) .) .) . f
00:53:41 <SubStack> I want partial application to pass along its arguments to a bunch of monads that take the same arguments
00:54:09 <mmorrow> what type would that be?
00:54:23 <SubStack> Key -> KeyState -> Modifiers -> Position -> IO ()
00:55:00 <mmorrow> i'm not sure that those types are
00:55:17 <SubStack> it's from glut
00:55:22 <mmorrow> @type mapM ($ a)
00:55:24 <lambdabot> forall (m :: * -> *) b. (Monad m) => [Expr -> m b] -> m [b]
00:55:28 <mmorrow> @type \a -> mapM ($ a)
00:55:29 <lambdabot> forall a (m :: * -> *) b. (Monad m) => a -> [a -> m b] -> m [b]
00:55:33 <mmorrow> ?
00:55:56 <mmorrow> @type \a -> mapM_ ($ a)
00:55:58 <lambdabot> forall a (m :: * -> *) b. (Monad m) => a -> [a -> m b] -> m ()
01:00:53 <SubStack> > foldM (\(a,b,c) f -> const `ap` f a b c) (2,3,5) [(\a b c -> return $ a * b + c)] (2,3,5)
01:00:54 <lambdabot>   (2,3,5)
01:01:18 <mmorrow> foldM is a nice one
01:01:38 <SubStack> I'm sucking at flipping it properly though
01:02:20 <mmorrow> also note that foldM is the analogue of fold_l_
01:06:14 <SubStack> need some sort of multiplexer for these functions
01:07:10 <SubStack> or multicast
01:10:18 <mmorrow> what do you have in mind for this to return?
01:10:32 <mmorrow> err
01:10:34 <SubStack> just IO ()
01:10:43 <mmorrow> i still don't know really what you're trying to do
01:11:02 <SubStack> I have a bunch of KeyboardMouseCallbacks
01:11:08 <mmorrow> in words, you want to take a list of functions, and give them all the same arg?
01:11:13 <SubStack> yes
01:11:18 <SubStack> the same arguments
01:11:33 <mmorrow> ah, so _different_ arg for each
01:11:44 <mmorrow> ?
01:11:47 <SubStack> the same arguments for all of the callbacks
01:11:59 <SubStack> and they do their IO () business with them
01:12:05 <mmorrow> and you
01:12:18 <mmorrow> 're problem is that each takes more than a single arg?
01:12:22 <luqui> sounds like a repeated lift of Monad (->)
01:12:34 <SubStack> mmorrow: basically
01:12:39 <SubStack> it's easy enough with just one of them
01:14:12 <SubStack> > (forM_ [putStrLn] . flip id) "doom"
01:14:13 <lambdabot>   * Exception: "<IO ()>"
01:17:06 <mmorrow> haskell's type system doesn't like stuff like you're trying to do
01:17:29 <SubStack> a shame
01:17:38 <mmorrow> @type foldr (.) id (replicate 4 concat)
01:17:39 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
01:17:40 <lambdabot>       Expected type: [[a]] -> [[a]]
01:17:40 <lambdabot>       Inferred type: [[a]] -> [a]
01:17:55 <mmorrow> @type concat . concat . concat . concat
01:17:56 <lambdabot> forall a. [[[[[a]]]]] -> [a]
01:18:52 <mmorrow> but you can always just put each arg into an ntuple or a nested (2)tuple
01:19:08 <mmorrow> or make a datatype for the args to a callback
01:19:41 <SubStack> there's already a type for the args
01:20:02 <mmorrow> i mean wrap them in another dataype
01:20:06 <SubStack> hmm
01:20:58 <mmorrow> data CallbackArgs = KeybdArgs { this :: foo, that :: bar} | MissileLauncherArgs { target :: Coords, satelliteGuidanceLink :: Int } | ...
01:21:52 <mmorrow> err, but maybe avoid the multiple "|"'s, since then you'd have to deal with a keybd callback getting missile launcher args..
01:22:30 <mmorrow> data KeybdArgs = ...
01:25:15 <notsmack> i've got a question about HTTP 4000.0.4
01:25:23 <kadaver> how does paths work with ghc?
01:25:36 <kadaver> C:/ghc/ghc-v/progs/webserver/Webserver.hs ; i want to import that from: C:/ghc/ghc-v/progs/Vidindi/Vidindi.hs
01:25:59 <notsmack> i'm using sendHTTP and trying to reuse the connection, but for some reason it's shutting down the connection after each response
01:26:19 <notsmack> (I believe this worked correctly until I upgraded from an old HTTP)
01:30:18 <kadaver> C:/ghc/ghc-v/progs/webserver/Webserver.hs ; i want to import that from: C:/ghc/ghc-v/progs/Vidindi/Vidindi.hs
01:30:23 <kadaver> how?
01:31:42 <mmorrow> kadaver: you need     foo/Webserver.hs  foo/Vivindi/Vivindi.hs  +  in Webserver.hs: "import Vivindi.Vivindi"
01:31:58 <mmorrow> (and in Vivindi => module Vivindi.Vivindi where ...)
01:32:07 * wli gets aggravated that the way monad transformer evaluators are used is always the exact wrong order for his purposes.
01:32:26 * wli wonders if anyone else is bothered by that.
01:32:28 <notsmack> mmorrow, vice versa i think
01:33:04 <mmorrow> notsmack: i don't believe so :)
01:33:16 <mmorrow> oh
01:33:20 <notsmack> ;-)
01:33:32 <mmorrow> you're right, he wants to import Webserver *from* Vivindi..
01:33:38 <mmorrow> :)
01:34:12 <mmorrow> kadaver: in that case, stick WebServer.hs in Vivindi/
01:35:02 <kadaver> mmorrow: no
01:35:14 <mmorrow> no what?
01:35:14 <notsmack> kadaver, they both need to be in the same module/directory hierarchy
01:35:32 <kadaver> obv i just want to be able to import Webserver from anyhwere since it is a geenral-purpose webserver that iwant for all ym apps
01:35:53 <kadaver> i dont want to copy it to every webapp
01:35:56 <mmorrow> you can't do something like "include "../../foo/zmog/../asdf.h""
01:36:19 <mmorrow> kadaver: then make it it's own separate cabal package
01:36:21 <notsmack> kadaver, then you make it a module and put it in your ghc pkg
01:36:22 <p_l> lol @ asdf
01:36:22 <kadaver> so haskells module systems s***s?
01:36:36 <kadaver> ok isee
01:36:37 <notsmack> kadaver, no, it doesn't;  i think that's your problem here?
01:36:52 <p_l> ASDF=Another System Definition Facility xD
01:36:57 <kadaver> never made a cabal package so good exercise
01:37:13 <kadaver> but still it isnt done yet is it easy to just rebuld the cabal package?
01:37:49 <mmorrow> runhaskell Setup.lhs configure && runhaskell Setup.lhs build && sudo runhaskell Setup.lhs install
01:38:19 <mmorrow> (although i prefer: ghc --make Setup.lhs && ./Setup configure && .. )
01:38:36 <mmorrow> just write a script to do that in the pwd
01:39:21 <mmorrow> ./Setup haddock --hyperlink-source --hoogle --haddock-options=--html
01:39:33 <mmorrow> gives you docs with nice HsColoured code and src links
01:39:45 <mmorrow> (in dist/doc/html/<pkgname>/)
01:47:12 <RayNbow> > evalState (mapM (State . splitAt) [1..]) [1..]
01:47:13 <lambdabot>   [[1],[2,3],[4,5,6],[7,8,9,10],[11,12,13,14,15],[16,17,18,19,20,21],[22,23,2...
01:47:28 <RayNbow> > takeWhile (not.null) $ evalState (mapM (State . splitAt) [1..]) [1..10]
01:47:30 <lambdabot>   [[1],[2,3],[4,5,6],[7,8,9,10]]
01:48:33 <kadaver> Setup.lhs, what shoudl that be?
01:49:09 <wli> Argh, I'm still choking on the Fibonacci chain problem.
01:50:00 <wli> So you can use doubling, tripling, etc. formulas generalized in the form of http://en.wikipedia.org/wiki/Fibonacci_numbers#Another_identity
01:50:55 <mlesniak> Anyone knows possible problem sources if a freshly installed ghc-6.10.1 (64bit) can not link libraries like HSarray-0.2.0.0? (e.g. /usr/bin/ld: cannot find -lHSarray-0.2.0.0)
01:51:57 <wli> So the idea is that one uses that identity to try to minimize the number of distinct Fibonacci numbers computed along the way toward computing all the Fibonacci numbers with indices drawn from some set as input.
01:53:27 <wli> (There are probably generalizations in terms of varying numbers of conscutive Fibonacci numbers etc.)
02:15:21 <wli> How do I stop a re-export of mapM_?
02:16:42 <wli> Something I'm importing re-exports Control.Monad.mapM_ and I can't figure out how to hide it.
02:19:48 <mlesniak> On a fresh install of ghc-6.10.1 for 64 bit I can not execute the standard Setup.lhs install script of a package: "Setup: <command line>: can't load .so/.DLL for: HSarray-0.2.0.0 (libHSarray-0.2.0.0.so: cannot open shared object file: No such file or directory)" Any ideas where I can find sources for the problem?
02:20:00 <mlesniak> ...sources of the problem... ;)
02:20:02 <idnar> wli: I would have thought "hiding (mapM_)", but presumably that doesn't work?
02:20:19 <notsmack> wli, you've gotta figure out what's re-exporting it and hide it on that import, right?
02:20:37 <wli> idnar: I've got import Control.Monad.Logic hiding (mapM, mapM_, Control.Monad.mapM_, Control.Monad.State.mapM_, Control.Monad.Reader.mapM_, Control.Monad.Writer.mapM_) thus far and am still lost.
02:20:40 <mlesniak> (NB the i386  version works on a different machine)
02:21:06 <quicksilver> wli: no.
02:21:17 <quicksilver> wli: import Control.Monad.Logic hiding (mapM_)
02:21:17 <wli> I don't even know if that's the right syntax.
02:21:35 <quicksilver> wli: and then, also, import Control.Monad.EverythingElse hiding (mapM_)
02:21:39 <wli> quicksilver: Doesn't work. It re-exports it from somewhere.
02:21:53 <notsmack> wli:  sounds like something else is re-exporting it, not Control.Monad.Logic then
02:21:57 <quicksilver> hiding (mapM_) will hide it from Control.Monad.Logic
02:22:08 <quicksilver> it doesn't matter if Control.Monad.Logic re-exports it from 47 million other modules
02:22:10 <blarf> k
02:22:13 <blarf> is cabal tied to darcs?
02:22:16 <quicksilver> you only have to hide it once from Control.Monad.Logic
02:22:20 <quicksilver> but you do *also* have to hide it from
02:22:24 <quicksilver> Control.Monad.EverythingElse
02:22:30 <quicksilver> (once for each EverythignElse you import)
02:22:45 <quicksilver> I have no idea why the Control.Monad.KitchenSink all re-export those functions
02:22:48 <quicksilver> it's pretty stupid.
02:23:55 <blarf> lol kitchensink?
02:24:02 <idnar> conveniencelol
02:24:13 <quicksilver> inconvenience, in practice.
02:24:30 <wli> Still can't hide it.
02:25:00 <notsmack> wli, what's your whole import list?
02:25:31 <blarf> how do i un configure+build+install all in one?
02:27:27 <wli> Control.Arrow, Control.Monad hiding (mapM, mapM_), Control.Monad.Logic hiding (mapM, mapM_), Control.Monad.State hiding (mapM, mapM_), Control.Monad.Writer hiding (mapM, mapM_), Data.IntSet hiding (filter, map, null), qualified Data.IntSet as IntSet, Data.Traversable, Data.Foldable hiding (foldr1), Data.Monoid(), Prelude hiding (mapM, mapM_)
02:27:41 <Axman6> blarf: eh?
02:28:00 <notsmack> Data.Foldable hiding (foldr1, mapM_)
02:28:26 <wli> Data.Foldable.mapM_ is the one I actually want to use.
02:28:31 <notsmack> Oh.
02:28:56 <quicksilver> wli: can you paste a minimal source file exhibiting the problem?
02:29:24 <wli> I'll work on minimizing it.
02:31:18 <wli> it was ghci
02:31:58 <blarf> does a cabal file need a main?
02:32:25 <blarf> i dont really have one but: runServer :: PortNumber -> Application -> IO ()
02:32:36 <blarf> does it need to be renamed to main?
02:32:38 <wli> I had :m + Control.Monad.Logic or something going.
02:35:55 <notsmack> repeating a question i asked earlier:
02:35:57 <notsmack> i'm using sendHTTP and trying to reuse the connection, but for some reason it's shutting down the connection after each response
02:36:12 <notsmack> it worked correctly until i updated to a recent HTTP
02:38:01 <Phyx-> Hi, i was wondering if there's a Timer module available somewhere
02:40:27 <ndm> I'm having some weirdities with QSem, is there any decent docs for them?
02:40:36 <blarf> i dont really have one but: runServer :: PortNumber -> Application -> IO ()
02:40:45 <Axman6> Phyx-: System.Time.Clock is probably what you're after
02:40:47 <blarf> does it need to be renamed to main , ie does cabal need a main?
02:40:59 <Phyx-> Axman6, i'll take a look thanks
02:42:47 <Phyx-> Axman6, is there nothing like, where i can specify an interval and a callback function and it just calls the callback after that interval is expired?
02:43:12 <Axman6> Phyx-: you can use threadSleep i think
02:43:21 <Axman6> @hoogle sleep
02:43:21 <lambdabot> No results found
02:43:28 <Axman6> @hoogle delay
02:43:28 <lambdabot> Control.Concurrent threadDelay :: Int -> IO ()
02:43:33 <Axman6> that one
02:43:41 <Phyx-> that's what we do now, I just don't think it's very ellegant :(
02:44:01 <Axman6> what're you actually trying to do?
02:45:03 <Phyx-> we have an action that has to be executed every xxx seconds
02:45:06 <quicksilver> ndm: I've never seen any.
02:45:20 <quicksilver> ndm: there's probably somethign mentioned in a paper which is out of date and doesn't match the current API :P
02:45:22 <Phyx-> so i thought there was a timer like in c# or java etc
02:45:31 <trofi^w> happspack tutorial uses separate thread to dump it's state time to time
02:45:38 <quicksilver> Phyx-: you can build a timer very easily using threadDelay :)
02:45:47 <quicksilver> Phyx-: and some tookit libraries provide one.
02:45:56 <trofi^w> :t forever
02:45:57 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
02:45:58 <ndm> quicksilver: awesome, i may add some docs at the end then, if i figure out what is going on - i'm assuming standard semaphore implementation, just wondering if there are crazy gotcha's
02:46:08 <Phyx-> yeah, we're using gtk2hs so we could use it's timers i suppose
02:46:28 <trofi^w> :t (forever $ do { stuff; threadDelay 10000; })
02:46:29 <lambdabot> Not in scope: `stuff'
02:46:29 <lambdabot> Not in scope: `threadDelay'
02:47:27 <quicksilver> Phyx-: I would do that, yes. (gtk's timers)
02:47:53 <Phyx-> quicksilver, ok, cool, thanks
02:48:00 <alx`> hi all !
02:48:34 <ppavelV6> hi alx`
02:48:36 <alx`> I have a stupid question about arrays of lists, could someone help me ?
02:49:00 <C-Keen> what is the question actually
02:49:33 <alx`> I try to create an array of lists by accumlation. The code is : hist2 ::  (Int,Int) -> [Int] -> Array Int [Int]
02:49:34 <alx`> hist2 bnds lst = accumArray (:) [] bnds [(i,[i]) | i <- lst, inRange bnds i]
02:49:35 <Axman6> alx`: not if we don't know the problem ;)
02:49:57 <alx`> but GHC complains that :   Couldn't match expected type `[Int]' against inferred type `Int'
02:49:57 <alx`>     In the first argument of `accumArray', namely `(:)'
02:49:57 <alx`>  
02:50:07 <alx`> and I don't get why...
02:50:13 <quicksilver> :t accumArray
02:50:14 <lambdabot> forall e a i. (Ix i) => (e -> a -> e) -> e -> (i, i) -> [(i, a)] -> Array i e
02:50:39 <Axman6> alx`: maybe (flip (:))
02:50:43 <quicksilver> alx`: (:) takes its parameters i the wrong order
02:50:54 <quicksilver> alx`: (:) takes the new element on the left, and the array on the right
02:50:58 <quicksilver> sorry, list on the right.
02:51:09 <quicksilver> it would have type (a -> e -> e) in the notation of accumArray's type.
02:51:21 <alx`> hum... testArrayList.hs:8:51:
02:51:21 <alx`>     Couldn't match expected type `Int' against inferred type `[a]'
02:51:21 <alx`>     In the expression: [i]
02:51:21 <alx`>     In the expression: (i, [i])
02:51:23 <quicksilver> as Axman6 points out, (flip (:)) is probably what you want.
02:51:24 <alx`>     In the fourth argument of `accumArray', namely
02:51:27 <alx`>         `[(i, [i]) | i <- lst, inRange bnds i]'
02:51:30 <alx`>  
02:51:52 <quicksilver> you just want (i,i), surely
02:52:01 <quicksilver> if you're using (:) to accum alements anyway.
02:52:19 <alx`> Yes ! it works ! Thanks !
02:52:52 <alx`> But...I don't understand the (i,i) part. The second argument of (i,i) isn't supposed to be accumulated to the growing list ?
02:53:37 <wli> Hmm. This is really slow.
02:53:57 <alx`> ah, I got it... :t (:)
02:53:57 <alx`> (:) :: a -> [a] -> [a]
02:53:57 <alx`> => so I must give an i and not a [i]...
02:54:26 <quicksilver> right.
02:55:20 <wli> I probably am not thinning the decision space somewhere.
02:55:51 <alx`> However, I'm puzzled by this way of creating arrays "in one time" (I'm a still newbie)...Aren't there more incremental (and simple) ways of doing it, for ex. with the ST monad ?
02:57:10 <quicksilver> yes.
02:57:18 <quicksilver> except I don't know if I'd call them more simple.
02:57:28 <quicksilver> your basic array type is immutable
02:57:36 <quicksilver> so you have to create it 'all at once'
02:58:35 <alx`> A solution would then be to call "complicated" functions in the creation of the array, for ex (i, complicatedFunction i otherArgument yetAnotherArgument) ?
02:59:01 <blarf> Webserver.hs:10:17:
02:59:01 <blarf>     Could not find module `Data.Map':
02:59:01 <blarf>       it is a member of package containers-0.2.0.0, which is hidden
02:59:04 <blarf> uh?
03:00:20 <trofi^w> add containers to .cabal file?
03:00:26 <quicksilver> blarf: projects built using cabal must be explicit in their dependencies
03:00:36 <quicksilver> blarf: you need to list all the packages you use in the .cabal file
03:00:40 <quicksilver> (that's kind-of the point ;0
03:01:47 <blarf> how?
03:02:56 <quicksilver> kadaver: http://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program
03:03:04 <quicksilver> and other links form http://www.haskell.org/cabal/
03:03:14 <kadaver> Setup.hs: can't find source for Data.Map in ., dist\build\autogen
03:06:03 <quicksilver> the name of the package is 'containers' not 'Data.Map'
03:07:49 <wli> Okay, I don't seem to be able to run this on very large of inputs. :(
03:08:54 <wli> Presumably the chain [4,13] is for the 3*n+1 recurrence.
03:09:52 <kadaver> you mean Other-Modules:  should be containers?
03:10:56 <kadaver> C:\ghc\ghc-6.10.1\progs\Webserver>Setup.hs: Webserver.cabal:13: Parse of field
03:10:56 <kadaver> other-modules' failed.
03:11:28 <wli> Hmm. It took 7:13 to enumerate the chains for 15, and they're pretty much all trivial one-steps.
03:11:54 <quicksilver> kadaver: did you read either of the pages I pasted?
03:16:32 <mmorrow> whoa, so if you import (e.g.) "import Foo as Bar" and you want to re-export it, you _don't_ do:
03:16:39 <mmorrow>   ,module Foo
03:16:42 <mmorrow> but
03:16:46 <mmorrow>   ,module Bar
03:16:57 * mmorrow was surprised for some reason
03:17:07 <ndm> demo: _make/_journal: hClose: illegal operation (handle is finalized) - any idea what that means?
03:17:36 <quicksilver> mmorrow: that is surprising.
03:17:44 <mmorrow> i wonder if a module that import it will only ever see that alias (e.g. in ghci)
03:18:30 <mmorrow> quicksilver: that's what the error msg's i'm working through seem to say. until i work them out though, it could just be some weird error cascade thing
03:19:50 <doserj> from the report: (in an export list) ... The form "module M" names the set of all entities that are in scope with both an unqualified name "e" and a qualified name "M.e".
03:19:57 <mmorrow> weird, yeah i think this is the case
03:20:34 <mmorrow> (ghc(i)'s error messages about "module Foo not imported" went away, and it now refers to "Foo" as "Bar"
03:21:35 <mmorrow> doserj: in particular, the situation is importing as module "import Foo as Bar" simply to re-export it. it looks like you have to refer to "Foo" as "Bar" in the export list
03:21:44 <mmorrow> otherwise it's an error (ghc-6.10.1)
03:22:13 <mmorrow> *..importing s/as/a/ module ...
03:25:01 <doserj> mmorrow: if you import Foo as Bar, Foo is not in scope, so you can't export it.
03:27:24 <mmorrow> exactly. this surprises me.
03:28:10 <mmorrow> because it seems like _in any module that imports this one_, Foo will be know as Bar. (i like this, but i didn't expect it)
03:28:19 <wli> This nondeterminism stuff is not swift for me.
03:30:54 <blarf> so how the f*** am i supposed to do with Data.Map in-cabal?
03:31:19 <profmakx> put containers into tour dependencies
03:31:54 <wli> http://wli.pastebin.com/m46bfafa4 <-- runs slow for some reason; maybe I'm not pruning choices well enough or have to track nondeterminism by hand or something.
03:32:26 <blarf> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2895#a2895 <- there is what i have
03:33:19 <bremner> I suppose there is no way to change the interpretation of  "--@" as operator, rather than a comment.
03:33:46 <quicksilver> bremner: add containers to Build-Depends.
03:33:47 <wli> I probably am not thinning the decision space somewhere.
03:33:53 <quicksilver> blarf: add containers to Build-Depends.
03:33:59 <quicksilver> bremner: sorry, tab complete error :)
03:34:05 <quicksilver> blarf: and not Exposed-Modules
03:34:14 <quicksilver> blarf: you could have just read the docs I pointed you to.
03:35:57 <blarf> what is Exposed-modules then?
03:36:08 <blarf> and containers means imported stuff?
03:36:17 <blarf> next problem is
03:36:18 <blarf> Could not find module `Data.ByteString.Char8':
03:36:18 <blarf>   it is a member of package bytestring-0.9.1.4, which is hidden
03:36:39 <wli> I think I found a speedup.
03:36:54 <quicksilver> containers doesn't mean imported stuff.
03:36:59 <quicksilver> containers is the name of a package.
03:37:00 <Axman6> mmorrow: hooray
03:37:08 <quicksilver> containers is the package which provides Data.Map.
03:37:14 <quicksilver> Your program *depends* on Data.Map.
03:37:20 <ejt> blarf: have you tried adding bytestring to your dependencies ?
03:37:31 <quicksilver> Therefore you must list containers - the package which provides Data.Map - in your Build-Depends.
03:37:34 <ppavelV6> blarf: you need build-depends
03:37:37 <ppavelV6> ops
03:37:42 <quicksilver> YOu must also list the packages which contain the other things you can use.
03:37:55 <quicksilver> Did you not notice this error looked just like the last one I spend the last 30 mintues telling you how to solve?
03:38:02 <quicksilver> did you not think that maybe the same solution might apply?
03:38:26 <ppavelV6> quicksilver:  isn't that a ridiculing question? :)
03:38:37 <ppavelV6> :)
03:39:46 <blarf> yeah but how do i know what they are called
03:39:54 <ejt> the error message told you
03:39:57 <blarf> what package is parsec?
03:39:58 <ppavelV6> compiler tells you
03:40:10 <ejt> ' it is a member of package bytestring-0.9.1.4, which is hidden'
03:40:26 <ejt> you even pasted the message !
03:40:36 <ppavelV6> very nice mechanics btw. let you know exactly what you depend on
03:40:38 <quicksilver> the error message tells you the package name, and so does the documentation.
03:40:45 <quicksilver> http://www.haskell.org/ghc/dist/current/docs/libraries/index.html
03:40:50 <quicksilver> ^^ package names in the right hand column.
03:48:41 <blarf> thanks quick it worked
03:50:40 <wli> http://wli.pastebin.com/m2e315bc <-- thinned out the search space some there
03:51:59 <quicksilver> blarf: yay :)
03:55:34 <wli> http://wli.pastebin.com/m780f7335 <-- with the super-long line cleaned up
03:55:44 <blarf> why does haskell use || for or when it means different thing in math, http://en.wikipedia.org/wiki/Table_of_mathematical_symbols
03:56:11 <bremner> blarf: because Haskell is a programming language
03:56:48 <ivanm> and there isn't much call for a parellel line operator in any programming language that I can think of
03:57:01 <blarf> @src any
03:57:01 <blarf> bad answer
03:57:01 <lambdabot> any p =  or . map p
03:57:02 <blarf> but why nto just or?
03:57:15 <ivanm> blarf: becuase or runs on lists
03:57:26 <blarf> so make or something else
03:57:26 <ivanm> and in this case, the Haskell designers decided to use some C-like syntax
03:57:39 <Axman6> blarf: || has been used for or in programming languages for a very very long time
03:58:10 <ivanm> @type or
03:58:11 <lambdabot> [Bool] -> Bool
03:58:13 <ivanm> blarf: ^^
03:58:16 <ivanm> that's what or is for
03:58:25 <Zao> It's not like && is mathy either.
03:58:41 <RayNbow> > let (∨) = (||) in True ∨ False
03:58:42 <lambdabot>   True
03:58:45 <Axman6> and i think people would get frustrated by having to write or x (or y (or y t))) instead of x || y || z || t
03:59:00 <ivanm> Zao: yes, but no-one claimed it was
03:59:12 <bremner> Axman6: lisp!
03:59:23 <RayNbow> > let (∧) = (&&) in True ∧ False
03:59:24 <ivanm> yes, but this isn't lisp
03:59:24 <lambdabot>   False
03:59:27 <Axman6> let alone sticking in all the in `'s in for the infix version
03:59:39 <ivanm> RayNbow: but most people prefer to program using good-ol' ASCII...
03:59:50 <Zao> RayNbow: let missing_glyph = ...
03:59:53 <ivanm> since there doesn't seem to be a `∧' key on my keyboard...
04:00:05 <ivanm> Zao: it's the mathematical and predicate
04:00:11 <ivanm> (i.e. upside-down V)
04:00:33 <wli> Ah, now I see; I have to uniquify the state in the nondeterministic dispatch.
04:00:36 <Zao> I gleaned so much from context, but reading his boolean expressions in a terminal that doesn't have the glyphs would be fun.
04:00:39 <RayNbow> ivanm: that's why I sometimes wish there was a LaTeX-style IME or something :p
04:01:13 <RayNbow> so you could type \vee and it would automatically get replaced by ∨
04:01:46 <wli> StateT/LogicT actually make it hard to do.
04:01:53 <ppavelV6> RayNbow: +1!!! i always dreamed about the ability to send tex :)
04:02:09 <blarf> hPutStr cant take a ByteString?
04:03:00 <ppavelV6> @hoogle hPutStr
04:03:00 <lambdabot> Data.ByteString hPutStr :: Handle -> ByteString -> IO ()
04:03:00 <lambdabot> System.IO hPutStr :: Handle -> String -> IO ()
04:03:00 <lambdabot> Data.ByteString.Char8 hPutStr :: Handle -> ByteString -> IO ()
04:03:10 <ivanm> RayNbow: now _that_ would be cool...
04:04:29 <ppavelV6> blarf:  so the answer is "yes" if you use the right hPutStr (from Data.ByteString.Char8)
04:04:50 <ppavelV6> blarf:  or from Data.ByteString
04:05:21 <RayNbow> ivanm: I wonder how hard it would be to make and add a custom IME to Windows...
04:05:38 <ivanm> *shudder*
04:05:41 <RayNbow> Windows' IME for Japanese is fairly nice for example...
04:06:04 * ppavelV6 needs vim binding to mac osx :)
04:10:10 <blarf> parsec: I want P.many P.letterOrNum; but alphaNum doesnt work
04:10:21 <blarf> i want to match blah1 blah or 1 etc
04:10:34 <wli> I basically have to explicitly track the frontier of active nondeterministic choices and maintain a state history. Before nondeterministically generating a state transition, check to see if the candidate state to transition to has already been visited, and if so, eliminate it.
04:12:47 <wli> So basically all the monads have to go.
04:14:03 <jedai> blarf: What do you mean "alphaNum doesn't work" ?
04:16:12 <jedai> blarf: It seems to work perfectly to me
04:20:02 <wli> Nondeterminism and state is "interesting" at best.
04:21:25 <wli> In this case it looks like 2 layers of nested state and nondeterminism are required.
04:22:22 <blarf> uh this is really weird. i serve my compiled webserver at 8080. it uses a package. now the file Webserver.hs that the cabal package was built from is loaded into ghci at the same time as the compiled ProgramIncludingTheWebsevrerPackage is running and that increases the memory use with 1MB inside the program but not ghci. why?
04:30:06 <blarf> dores the memcache bindins lib contain memcached itself?
04:30:22 <Axman6> i doubt it
04:31:03 <NameAlreadyInUse> why does my code prompt me for input before printing "abc"?
04:31:04 <NameAlreadyInUse> putStr "abc" >> getLine >>= putStr
04:31:37 <notsmack> NameAlreadyInUse, probably because the line's not flushed until a newline?
04:32:35 <koeien> yes, you will need a hFlush in there
04:32:36 <Workybob> hSetBuffering stdout NoBuffering >> ...
04:32:40 <Workybob> or that
04:32:41 <koeien> also possible
04:33:01 <Axman6> i prefer Workybob's solution though
04:33:27 <NameAlreadyInUse> what does it do exactly?
04:33:43 <koeien> it switches off buffering for the standard output file handle
04:33:46 <Workybob> it asks the terminal not to buffer output on stdout
04:33:53 <NameAlreadyInUse> is there a downside?
04:33:59 <Workybob> yes, it's slower
04:33:59 <Axman6> what's the point of buffering anyway?
04:34:00 <koeien> it may be a bit slower, i guess
04:34:13 <Workybob> Axman6: think "early terminal"
04:34:18 <Workybob> like... one with a print head
04:34:21 <Workybob> and a roll of paper
04:34:32 <Workybob> and what you do about backspace characters
04:36:03 <Workybob> also NameAlreadyInUse – with no buffering you can get lazyness causing the characters of two outputs to get interleaved
04:36:05 <Workybob> not just the lines
04:36:09 <Workybob> which is... fun
04:36:14 <wli> It'd be a memoizing states for nondeterministic state monads.
04:36:32 <Saizan> laziness?
04:36:54 <Saizan> ah, maybe with some very weird use of unsafeInterleaveIO?
04:37:41 <Workybob> no, you don't need to fuck about with anything like that to get wierd things coming out of lazy IO
04:38:07 <Saizan> can you give me an example?
04:38:12 <Workybob> sec
04:38:17 <Saizan> i've never found anything surprising when writing
04:38:28 <quicksilver> surely that's an issue with threading.
04:38:32 <quicksilver> not interleaved IO.
04:38:33 <NameAlreadyInUse> but isn't the point of the IO monad to sequence so that it doesn't behave like that?
04:38:39 <Axman6> i've written things that've done it before
04:38:41 <Saizan> yeah, threading sure
04:38:45 <quicksilver> I don't think any of the builtin IO constructs are interleaved on output
04:38:49 <quicksilver> (only interleaved on input)
04:38:56 <Axman6> NameAlreadyInUse: no. sounds more like the ST monad to me
04:39:17 <Saizan> in general the point of IO is to sequence the side-effects, yeah
04:39:40 <Workybob> gah not sure I can
04:39:45 <Workybob> I've had some very odd things going on before
04:39:52 <Saizan> unless you forkIO or unsafeInterleaveIO
04:41:13 <wli> Oh yeah, the differential extensions like (t')^2=4*t^3-g_2*t-g_3 or (t')^2=(1-t^2)*(1-k^2*t^2) are ordinary differential polynomial rings K{t} where K is the differential ring extended by the transcendental t.
04:47:44 <trh> Hello !
04:47:53 <mmorrow> wow, you can do a lot with at least two levels of modules that simply imports stuff hiding things and rexporting
04:48:04 <mmorrow> *re-exp...
04:48:17 <trh> Can anyone tell me how to check list of list is empty or not ?
04:48:24 <mmorrow> > null []
04:48:25 <lambdabot>   True
04:48:30 <mmorrow> > null [[]]
04:48:31 <lambdabot>   False
04:48:37 <mmorrow> > all null [[]]
04:48:38 <trh> Yeah
04:48:38 <lambdabot>   True
04:48:42 <trh> I wanna check
04:48:43 <trh> [[]]
04:48:52 <trh> But null [[]] is giving
04:48:53 <trofi^w> > null [()]
04:48:54 <lambdabot>   False
04:48:55 <trh> false
04:49:01 <mmorrow> @type all null
04:49:02 <lambdabot> forall a. [[a]] -> Bool
04:49:03 <lepassive> clojure sounds nice
04:49:08 <trofi^w> :t all
04:49:09 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
04:49:12 <mmorrow> @src and
04:49:12 <lambdabot> and   =  foldr (&&) True
04:49:15 <mmorrow> @src or
04:49:15 <lambdabot> or    =  foldr (||) False
04:49:25 <mmorrow> @src all
04:49:25 <lambdabot> all p =  and . map p
04:49:26 <quicksilver> trofi^w: well, yes, [[]] isn't empty.
04:49:31 <quicksilver> trh: damn that was for you
04:49:42 <trofi^w> quicksilver: i know, thanks
04:49:49 <quicksilver> trh: [[]] isn't empty - it is a list with one item. That item is the empty list.
04:49:51 <trofi^w> > head [[]]
04:49:52 <lambdabot>   []
04:50:01 <quicksilver> trofi^w: can you be more precise about what you want to check?
04:50:04 <quicksilver> damn!
04:50:07 <trofi^w> [:
04:50:09 <quicksilver> trofi^w: sorry again :)
04:50:12 <trh> Ok, Thanks ... all null [[]] work !
04:50:12 <trofi^w> np
04:50:27 <quicksilver> trh: another option is null (concat [[]])
04:50:37 <quicksilver> trh: i.e. flatten the list before you check if it's null.
04:50:47 <quicksilver> (that has the same effect as all null)
04:50:50 <trh> Yep
04:51:10 <quicksilver> @check \xs -> all null xs == null (concat xs)
04:51:11 <lambdabot>   "OK, passed 500 tests."
04:51:19 <quicksilver> ^^ "proved" by lambdabot ;)
04:51:48 <kadaver> "This starts memcached up as a daemon, using 2GB of memory, " uh RAM that is? so memcache is for big hardcore apps?
04:51:50 <ivanm> is it really proven, or looks statistically valid?
04:51:57 <koeien> ivanm: the latter
04:52:07 <koeien> "hasn't been disproved"
04:52:11 <trh> BTW, what does @ means ?
04:52:15 <trh> @check ?
04:52:15 <lambdabot>   <no location info>: parse error on input `?'
04:52:16 <quicksilver> ivanm: I was joking
04:52:17 <trofi^w> > join [[],[],[]]
04:52:17 <trh> @src ?
04:52:17 <lambdabot> Source not found.
04:52:19 <lambdabot>   []
04:52:24 <koeien> trh: command for lambdabot
04:52:24 <quicksilver> trh: @ means 'give a command to lamdbdabot'
04:52:33 <ivanm> quicksilver: oh, OK
04:53:00 <trofi^w> quotes point to that :]
05:00:21 <wli> I'm not sure you can do much more than treat it like K(t,t')/((t')^2-4*t^3+g_2*t+g_3). I think you can directly plug in algebraic differential systems like s' = c*d, c' = -s*d, d' = -k^2*s*c to _something_, though there's not much about what you can do with them.
05:04:32 <tomh> is there a function which removes duplicates from a list ?
05:04:39 <tomh> (with a badly chosen name perhaps)
05:04:46 <quicksilver> > nub [1,2,3,2,1]
05:04:47 <dolio> nub
05:04:47 <lambdabot>   [1,2,3]
05:04:59 <NameAlreadyInUse> that name is badly chosen
05:05:03 <quicksilver> it's called "nub" because only nubs think it is a bad name.
05:05:06 <ivanm> how can you call that name badly chosen! it's ancient egyptian IIRC!
05:05:07 <NameAlreadyInUse> hah
05:05:56 <ivanm> @wordnet nub
05:05:56 <lambdabot> Unknown command, try @list
05:06:01 <ivanm> @wn nub
05:06:08 <lambdabot> *** "nub" wn "WordNet (r) 2.0"
05:06:08 <lambdabot> nub
05:06:08 <lambdabot>      n 1: a small lump or protuberance [syn: {nubble}]
05:06:08 <lambdabot>      2: a small piece; "a nub of coal"; "a stub of a pencil" [syn: {stub}]
05:06:08 <lambdabot>      3: the choicest or most essential or most vital part of some
05:06:10 <lambdabot> [5 @more lines]
05:06:29 <NameAlreadyInUse> @more
05:06:29 <lambdabot>         idea or experience; "the gist of the prosecutor's
05:06:29 <lambdabot>         argument"; "the heart and soul of the Republican Party";
05:06:29 <lambdabot>         "the nub of the story" [syn: {kernel}, {substance}, {core},
05:06:29 <lambdabot>          {center}, {essence}, {gist}, {heart}, {heart and soul}, {inwardness},
05:06:29 <lambdabot>          {marrow}, {meat}, {pith}, {sum}, {nitty-gritty}]
05:08:29 <tomh> ok thanks, I really wish that name was renamed though to something more descriptive :P
05:08:42 <wunki> > nub [1,1,1,2,3,2,2]
05:08:43 <lambdabot>   [1,2,3]
05:08:48 <ivanm> tomh: why?
05:08:59 <tomh> because it doesn't make sense to call it 'nub'
05:09:02 <kadaver> unique?
05:09:06 <ivanm> sure it does
05:09:09 <quicksilver> tomh: how does it not make sense?
05:09:20 <tomh> it doesn't describe what the function does
05:09:23 <quicksilver> yes it does.
05:09:26 <osfameron> it's the 3rd listed definition of a rare noun for a start...
05:09:29 <kadaver> for a brit perhaps
05:09:38 <NameAlreadyInUse> i can't draw the connection between "nub" and removing duplicates from lists
05:09:48 <osfameron> and essence doesn't imply anything about duplicates
05:10:01 <ivanm> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html#v:nub
05:10:20 <osfameron> nub listWhereTheEssentialInterestingThingIsThatEveryElementIsListedTwice
05:10:49 <quicksilver> it's no worse than 'map'
05:11:01 <tomh> no one said map made sense
05:11:09 <quicksilver> and it's no worse than the use of the word 'index' in the context of arrays, as found in most programming languages.
05:11:23 <osfameron> true
05:11:26 <quicksilver> sometimes the best thing to do is take a nice word with a closely related meaning, and use it.
05:11:28 <ivanm> osfameron: I wouldn't call it rare...
05:11:29 <tomh> well most other languages would call nub just removeDuplicates or something
05:11:42 <ivanm> tomh: that's too long IMHO
05:11:45 <quicksilver> most other languages wouldn't have it.
05:11:45 <osfameron> I guess the problem then is merely that it's not commonly enough used in programming terminology for it to seem normal
05:11:48 <ivanm> and not as catchy ;-)
05:11:50 <dobblego> function names are less important in light of a rigorous type system and automated spec testing
05:12:20 <tomh> ivanm: it is not too long, function names should describe what they do, if it is too long it probably does too much
05:12:33 <ivanm> oh, you think nub does too much?
05:12:37 <kadaver> http://www.urbandictionary.com/define.php?term=nub -> the unqiue items of a list. hmm
05:12:37 <kadaver> i find index and map to be descriptive
05:12:37 <kadaver> and just because one name is poorly chosen it doesnt excuse another poorly one
05:12:38 <tomh> no
05:12:50 <tomh> thats why removeDuplicates is ok
05:12:54 <tomh> because it ain't too long
05:13:02 <ivanm> tomh: I think it is
05:13:17 <ivanm> especially if you're going to use nubBy rather than just plain nub
05:13:21 <tomh> why is it too long
05:13:30 <tomh> nubBy doesn't make sense either
05:13:42 <tomh> programs are read a lot more often than they are written
05:13:48 <ivanm> tomh: nub-by-using-this-function
05:13:52 <wli> omfg the fib chains for 20 took almost an hour
05:14:15 <kadaver> unique is good?
05:14:15 <kadaver> set?
05:14:33 <ivanm> set doesn't make sense
05:14:35 <tomh> set is a datastructure
05:14:42 <ivanm> unique is iffy as well
05:14:44 <tomh> unique sounds more like a boolean function
05:14:53 <ivanm> tomh: no, Set is a data structure
05:14:55 <tomh> removeDuplicates tells exactly what the function does
05:15:16 <ivanm> tomh: I would argue that removeDuplicates removes all elements that have more than one value present
05:15:29 <ivanm> i.e. removeDuplicates [1,2,4,1,2] = [4]
05:15:34 <tomh> ivanm: yes, but im talking about definition not the constructor
05:15:41 <tomh> ye ok true
05:15:44 * wli often does Set.toList . Set.fromList
05:16:03 <osfameron> ivanm: that's a less common meaning of the term removeDuplicates I'd have thought
05:16:04 <ivanm> wli: what for?
05:16:16 <ivanm> osfameron: /me is playing devil's advocate ;-)
05:16:18 <wli> ivanm: Faster nub
05:16:28 <ivanm> wli: but non-lazy?
05:16:31 <osfameron> if a library was talking about removing duplicate copies of books, it'd be obvious what they meant...
05:16:35 <NameAlreadyInUse> wli: is it really faster? i can't imagine how
05:16:43 <tomh> anyway i gonna finish my homework using more shitty named haskell functions :)
05:16:58 <wli> ivanm: For the cases I use it, laziness is not much of an issue.
05:17:01 <ivanm> NameAlreadyInUse: O(log n) rather than O(n^2)
05:17:23 <ivanm> wli: so you use that rather than the more common "map head . group . sort" ?
05:17:36 <wli> ivanm: Yeah.
05:17:37 <dobblego> with an incredibly unconvincing argument :)
05:17:59 <ivanm> dobblego: for what?
05:18:07 <ivanm> who had the unconvincing argument?
05:18:24 <NameAlreadyInUse> ivanm: how can it be O(log n)? it must be at least O(n) to turn the list into a set
05:18:34 <ivanm> sorry, O(n log n)
05:18:39 <dobblego> that nub is poorly named
05:18:43 <koeien> @oeis [1,-24,252,-1472]
05:18:43 <lambdabot>  Sequence not found.
05:18:49 <wli> It's O(n*lg(n)) or O(n) depending on how intelligent the internals are.
05:18:51 <koeien> is that the correct syntax ?
05:18:53 * ivanm agrees with dobblego 
05:19:14 <Axman6> @oeis 1 -24 252 -1472
05:19:15 <lambdabot>  Ramanujan's tau function (or tau numbers).
05:19:15 <lambdabot>  [1,24,252,1472,4830,6048,16744,84480,113643,115920,534612,370944,577738,4018...
05:19:22 <ivanm> wli: well, if the Set is a tree, it can take up to log n for the nth element to be inserted
05:19:24 <wli> Never mind, if anything could be O(n) it would have to be Set.fromAscList
05:19:27 <koeien> Axman6: thanks
05:19:33 <ivanm> wli: yeah
05:20:32 <wli> ivanm: There's a dumb trick to do it in O(n) time when the list to make into a tree is sorted, and maybe its length needs to be known in advance to avoid an extra pass over the list.
05:20:59 <ivanm> wli: nah, if it's already sorted and you know it I think it can be done in O(n)
05:21:13 <ivanm> using a heap-like construction, maybe....
05:21:22 <ivanm> oh, wait, for it to be balanced you'd need the length as well
05:21:55 <wli> It's still O(n), just bumps up the constant.
05:22:03 <blarf> @src nub
05:22:03 <lambdabot> nub = nubBy (==)
05:22:09 <blarf> @src nubBy
05:22:10 <lambdabot> nubBy eq []             =  []
05:22:10 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
05:22:14 <ivanm> wli: yeah
05:22:30 <blarf> is nubBy O(n^2)?
05:22:33 <ivanm> yes
05:23:06 <ivanm> blarf: well, assuming that the list traversal is more expensive than an individual eq function, anyway ;-)
05:23:11 <wli> I almost never use lists for anything except analogues of induction variables in for loops in C/Fortran/etc. anymore.
05:23:42 <ivanm> so not as a data structure? :o
05:23:44 <blarf> but sort + traverse is: n log n right?
05:23:53 <ivanm> blarf: yes
05:24:06 <ivanm> but "map head . group . sort" isn't lazy, and hence won't work on infinite lists
05:24:10 <ivanm> for example:
05:24:23 * edwardk is finding himself in need of some kind of side-effectful monoid. i.e. mappend' :: Monad m => a -> a -> m a -- maybe an applicative would probably suffice. anything leap to mind?
05:24:24 <ivanm> > nub ([1..] ++ [1..](
05:24:25 <lambdabot>   <no location info>: parse error on input `;'
05:24:26 <ivanm> > nub ([1..] ++ [1..])
05:24:27 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
05:24:35 <Axman6> > map head . group . sort $ [1..]
05:24:43 <osfameron> unless the infinite list is already sorted, or you can assume an appropriate cutsort
05:24:46 <ivanm> > map head . group . sort $ [1..] ++ [1..]
05:24:55 <lambdabot>   mueval: Prelude.read: no parse
05:25:01 <ivanm> osfameron: well, then you need a smarter version rather than a generic one
05:25:09 <osfameron> no, you can just leave out the sort :-)
05:25:09 <lambdabot>   mueval: Prelude.read: no parse
05:25:19 <osfameron> and assume that 'uniq' has the same semantics as unix uniq
05:25:20 <ivanm> osfameron: yes, but you can't generelise that, is what I meant
05:25:24 <osfameron> (i.e. expectsa sorted list)
05:25:26 <ivanm> i.e. a generic nub replacement
05:25:30 <osfameron> true
05:25:47 <dobblego> it's not the same function as nub anyway
05:25:47 <dobblego> nub preserves order
05:25:48 <ivanm> hmmmm..... anyone remember the link for that new record view extension stuff in 6.10?
05:26:16 * ivanm wants to use size for two  similar data structures, but isn't sure he wants a type class
05:26:21 <wli> blarf: Depends. IntSet.toList . IntSet.fromList looks interesting, depending on how it's done.
05:26:37 <NameAlreadyInUse> in Reader String Int, what is the Int? the return value of the computation?
05:26:39 <osfameron> how would you do a stateful filter in haskell?
05:26:58 <ivanm> dobblego: yes, but if you only care about uniqueness and have small lists, than group.sort might be better for you
05:27:08 <osfameron> i.e. filter on "m contains e" but updating m as you go
05:27:45 <Axman6> foldl?
05:28:08 <osfameron> though foldl isn't lazy either is it?
05:28:08 <koeien> either foldr or foldl. it is more convenient to write it out i guess
05:28:17 <koeien> at least initially
05:28:44 <ivanm> osfameron: mapAccumL?
05:28:45 <koeien> i would use explicit recursion and don't think twice about it
05:29:22 <osfameron> ivanm: ah, maybe... with concatMap ?
05:29:30 <koeien> yes, or catMaybes
05:29:39 <ivanm> depends on how you want it
05:29:44 <ivanm> @type mapAccumL
05:29:47 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
05:30:01 <osfameron> I saw some evalState examples earlier today... didn't understand them, but that would also seem like a way to do it
05:31:54 <quicksilver> mapAccum* are precisely mapM in the state monad.
05:32:06 <quicksilver> you can construct mapAccumR from evalState and mapM
05:32:12 <quicksilver> the L version requires some reverses.
05:32:59 <ivanm> quicksilver: I dind't know mapAccum* used state...
05:33:03 <ivanm> @src mapAccumL
05:33:03 <lambdabot> mapAccumL _ s []        =  (s, [])
05:33:03 <lambdabot> mapAccumL f s (x:xs)    =  (s'',y:ys)
05:33:03 <lambdabot>    where (s', y ) = f s x
05:33:03 <lambdabot>          (s'',ys) = mapAccumL f s' xs
05:33:17 <ivanm> @src mapAccumR
05:33:17 <lambdabot> Source not found. I am sorry.
05:33:21 * ivanm can't see any state...
05:33:32 <quicksilver> @type macAccumR
05:33:34 <lambdabot> Not in scope: `macAccumR'
05:33:38 <quicksilver> @type mapAccumR
05:33:38 <osfameron> @idx mapAccumL
05:33:39 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
05:33:40 <lambdabot>  mapAccumL
05:33:44 <osfameron> @index mapAccumL
05:33:45 <lambdabot> Data.List
05:33:50 <quicksilver> ivanm: 'acc' is the "state"
05:34:04 <quicksilver> that's the state monad written out explicitly without a newtype.
05:34:09 <ivanm> quicksilver: ahhh
05:34:12 * ivanm didn't realise that
05:34:16 <ivanm> @hoogle mapAccum
05:34:16 <lambdabot> Data.IntMap mapAccum :: (a -> b -> (a, c)) -> a -> IntMap b -> (a, IntMap c)
05:34:17 <lambdabot> Data.Map mapAccum :: (a -> b -> (a, c)) -> a -> Map k b -> (a, Map k c)
05:34:17 <lambdabot> Data.ByteString mapAccumL :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
05:34:21 <quicksilver> it may be a useful pathway to understanding State
05:34:28 <quicksilver> to understand mapAccumR first.
05:34:38 <quicksilver> and then you can see the 'point of' monads, and the 'point of' mapM
05:36:12 <ivanm> quicksilver: I thought the 'point of' monads was IO ;-)
05:36:44 <ivanm> why doesn't lambdabot know mapAccumR's src?
05:36:52 <koeien> lambdabot's src is limited
05:37:03 <kadaver> why doesn readFile return a Maybe?
05:37:07 <quicksilver> ivanm: lb's src is a manually written work of fiction.
05:37:11 <koeien> kadaver: exceptions are used instead
05:37:13 <kadaver> or that would be to annoying because msot of the time you know the File does exist?
05:37:19 <ivanm> quicksilver: :o
05:37:27 <ivanm> so it's readable rather than efficient?
05:37:30 <quicksilver> kadaver: you could say it has been simplified for the common case.
05:37:35 <quicksilver> ivanm: right.
05:37:35 <ivanm> esp. if the under-the-hood stuff is complex?
05:37:37 <koeien> kadaver: yes, that's more or less the reason. exceptions are used for exceptional cases
05:37:43 <quicksilver> kadaver: you could also say it's completely broken.
05:37:48 <quicksilver> (since it uses interleaved IO)
05:38:07 <koeien> quicksilver: in that case lazy IO is broken
05:38:12 <quicksilver> yes.
05:38:17 <quicksilver> it is a broken default.
05:38:18 <koeien> well, that's because it is ;)
05:38:23 <koeien> but it's useful
05:38:24 <quicksilver> and I dislike the phrase 'lazy IO'
05:38:31 <quicksilver> laziness is a good thing
05:38:34 <koeien> IO on demand?
05:38:34 <quicksilver> lazy IO is a bad thing.
05:38:37 <ivanm> quicksilver: "bufferd IO"?
05:38:38 <quicksilver> interleaved IO.
05:38:45 <quicksilver> is my current phrase of choice.
05:38:51 <quicksilver> since the IO is interleaved with the pure reductions.
05:38:52 <ivanm> "current"? for how long?
05:38:53 <ivanm> ;-)
05:38:57 <quicksilver> last few months.
05:39:13 <ivanm> what was your previous phrase of choice?
05:39:29 <quicksilver> it was unrepeatable in a friendly IRC channel like this
05:39:43 <ivanm> heh
05:39:49 <quicksilver> bowdlerised, it might unsafeBreakIntoYourKitchenAndStealYourCookiesGetContents
05:40:14 <osfameron> I should be able to do something like: uniq = mapAccumL (\s e -> (e `S.insert` s, e `S.member` s)) S.fromList []   then?
05:40:30 <osfameron> (that fails of course)
05:40:37 <ivanm> osfameron: sure, why not ;-)
05:40:41 <ivanm> just write it to do that! :p
05:41:21 <Baughn> " hSend h =<< maybe (return Nothing) (\k -> Just <$> stripKey k) mIdentity" <-- Is there a better way to write this?
05:42:18 <osfameron> ah ok, then of course that doesn't preserve the ordering
05:42:19 <kadaver> what do haskellians think about erlang?
05:42:29 <osfameron> so really I want a tuple accumulator (seen,list)
05:43:10 <ivanm> kadaver: the general consensus when I've asked similar questions is that some of the concepts behind Erlang (message passing, OTP, etc.) are nice, but the syntax leaves a lot to be desired
05:43:11 <edwardk> kadaver: not enough types, nicely distributed, too strict, neat tricks with the garbage collector that abuse that strictness, message passing is nice
05:43:14 <koeien> kadaver: too bad it's dynamically typed
05:43:28 <koeien> ugly syntax
05:43:29 <edwardk> and it needs hierarchical namespaces ;)
05:43:45 <dobblego> @type Data.Traversable.mapM -- Baughn
05:43:47 <lambdabot> forall a (m :: * -> *) b (t :: * -> *). (Monad m, Data.Traversable.Traversable t) => (a -> m b) -> t a -> m (t b)
05:44:10 <wli> osfameron: Why not just Set.toList . Set.fromList?
05:44:12 <osfameron> uniq = S.toList . fst . mapAccumL (\s e -> (e `S.insert` s, e `S.member` s)) S.empty
05:44:29 <quicksilver> Baughn: isn't that (fmap.fmap) (stripKey k) ?
05:44:33 <osfameron> wli: a) interest, b) to see if that ends up with a solution that retains ordering
05:44:54 * ivanm wished there was a way of ensuring predicates were always fulfilled on a data structure
05:44:58 <quicksilver> Baughn: one fmap for your monad, second fmap for the maybe
05:45:14 <osfameron> three fmaps to get ready now, go kids go!
05:45:18 <quicksilver> :t \f -> maybe (return Nothing) (\k -> Just <$> f k)
05:45:19 <lambdabot> forall a (m :: * -> *) a1. (Functor m, Monad m) => (a1 -> m a) -> Maybe a1 -> m (Maybe a)
05:45:21 <koeien> ivanm: smart constructors?
05:45:25 <koeien> ivanm: or use agda ;)
05:45:29 <quicksilver> no, it's not.
05:45:35 <ivanm> at the moment, I'm storing the number of isJust cells in an array as part of the record-base data structure, but it would be nice if there was a way I could ensure that that is the correct value :s
05:45:39 <ivanm> koeien: heh
05:45:46 <wli> osfameron: Set does balanced binary search tree stuff; there's no way ordering is preserved. You can literally use it for sorting, too.
05:46:17 <Baughn> quicksilver: ..my mind is making tiny hissing noises. I think it's on fire.
05:46:21 <quicksilver> Baughn: I think the 'neater' way is to use MaybeT
05:46:29 <quicksilver> Baughn: it's not neater, for this particular case.
05:46:44 <Baughn> Ah. Hm.
05:47:21 <osfameron> wli: uniq = join . snd . mapAccumL (\s e -> (e `S.insert` s, if e `S.member` s then [] else [e])) S.empty
05:47:24 <osfameron> that preserves ordering
05:48:11 <osfameron> (that's pretty much the standard Perl idiom)
05:49:26 <quicksilver> osfameron: I prefer Nothing/Just e
05:49:32 <quicksilver> osfameron: and then catMaybes instead of Join
05:49:58 <EvilTerran> what's this? nub by another route?
05:50:23 <osfameron> quicksilver: being listy, I thought a concatMap join thing seemed to make more sense
05:50:30 <osfameron> EvilTerran: yarr
05:52:48 <osfameron> http://gist.github.com/86072 is slightly nicer maybe
05:53:08 <ivanm> osfameron: what are you actually trying to do?
05:53:29 <osfameron> ivanm: I'm just playing ;-)
05:53:32 <wli> osfameron: IOW you're only using the set to test whether it's already occurred.
05:53:34 <ivanm> heh
05:53:38 <osfameron> ivanm: nub using sets
05:53:40 <ivanm> with a non-filter nub?
05:53:42 <osfameron> wli: yeah
05:53:42 <ivanm> *nod*
05:53:50 <ivanm> which won't improve the performance though...
05:54:22 <ivanm> osfameron: why not use Maybe?
05:54:24 <osfameron> it's the equivalent of perl's do { my %seen; grep { ! $seen{$_}++ } @list }
05:54:31 <ivanm> since you're only ever caring about single values anyway...
05:54:40 <osfameron> true.  can do.  is it faster/clearer?
05:54:54 <ivanm> I'd think it'd be clearer, and possibly a bit faster
05:55:04 <ivanm> (not sure about the faster)
05:55:11 <wli> uniq = catMaybes . snd . mapAccumL (\s e -> (Set.insert e s, guard (not $ Set.member e s) >> return e) Set.empty
05:55:27 <ivanm> osfameron: but it's also 'safer', in that you can't accidentally include an extra value in the Maybe type, but you can with the list
05:55:34 <ivanm> e.g. you might accidentally have entered [e,e] instead of [e]
05:56:41 <lady_6thofAu> when i try to install cabal-install i get the following error:
05:56:42 <wli> I guess the garbage that comes up I need to go looking for is algebraic differential manifolds.
05:56:49 <lady_6thofAu> Distribution/Client/IndexUtils.hs:56:17:
05:56:49 <lady_6thofAu>     Could not find module `Codec.Compression.GZip':
05:56:49 <lady_6thofAu>       Use -v to see a list of the files searched for.
05:56:58 <lady_6thofAu> any help?
05:56:58 <ivanm> would it take a dependent type to enforce on the type level that an array has 1-based indexing (for example)?
05:57:13 <ivanm> lady_6thofAu: how are you installing cabal-install?
05:57:18 <blarf> could parametric polymorphism be added to C without performance penalty?
05:57:29 <lady_6thofAu> ./bootstrap.sh
05:57:49 <osfameron> wli: heh, the guard >> return  trick is cute
05:58:00 <ivanm> lady_6thofAu: OK, thought I thought it was meant to install all the deps...
05:58:11 <ivanm> @hoogle Codec.Compression.GZip
05:58:11 <lambdabot> No results found
05:58:25 <ivanm> how can I find which hackage package provides that module?
05:58:40 <lady_6thofAu> it's compression
05:59:04 <lady_6thofAu> i tried to install it separately, but then it has a dependency on bytestring, which i think i have installed...
05:59:23 <doserj> it's in zlib, which should be installed by bootstrap.sh
05:59:24 <lady_6thofAu> but even when i try to install it then another dependency comes up
05:59:34 <ivanm> I don't think that's what you want...
05:59:38 <ivanm> zlib looks more likely
05:59:53 <ivanm> lady_6thofAu: run "ghc-pkg list zlib"
05:59:56 <quicksilver> ivanm: very slightly faster (Maybe vs list with one element)
06:00:06 <quicksilver> ivanm: list with one element wastes a 'tail pointer' to the []
06:00:15 <ivanm> yeah, it's zlib
06:00:15 <quicksilver> ivanm: which has to be gced etc.
06:00:25 <ivanm> quicksilver: yeah, that's what I was thinking of
06:00:43 <ivanm> wasn't sure how that compared to the wrapping/unwrapping of the Maybe constructors
06:00:46 <lady_6thofAu> /usr/local/lib/ghc-6.10.1/./package.conf:
06:00:46 <lady_6thofAu>     zlib-0.5.0.0
06:00:46 <lady_6thofAu> /home/m0renita/.ghc/i386-linux-6.10.1/package.conf:
06:00:46 <lady_6thofAu>     zlib-0.4.0.4, zlib-0.5.0.0
06:01:07 <quicksilver> ivanm: well [] is precisely like Nothing
06:01:10 <Baughn> "attempt to mix Haskell and C finalizers in the same ForeignPtrattempt to mix Haskell and C finalizers in the same ForeignPtr" <-- Was this error added in 6.10?
06:01:12 <ivanm> lady_6thofAu: OK, you might have a problem with multiple zlib's installed, but I don't think that's a problem...
06:01:15 <ivanm> quicksilver: true
06:01:16 <quicksilver> ivanm: but (a:[]) is not precisely like Just
06:01:27 <quicksilver> ivanm: since Just has one paramter (the a) whilst (:) has two
06:01:30 <ivanm> lady_6thofAu: run ghci, and then enter ":m Data.Compression.GZip"
06:01:30 <quicksilver> and there the extra cost.
06:01:35 <quicksilver> it's pretty small.
06:01:37 <ivanm> quicksilver: *nod*
06:01:56 <lady_6thofAu> Could not find module `Data.Compression.GZip':
06:01:58 <ivanm> though when we say that nub is O(n^2), that's assuming all elements are unique, right?
06:02:08 <ivanm> lady_6thofAu: OK, so zlib isn't installed properly then
06:02:25 <Saizan> ivanm: it's Codec
06:02:34 <doserj> laddy: try again with Codec.Compression.GZip
06:02:38 <quicksilver> ivanm: I think it's O(n * m) where n is number of elts and m is number of unique elts.
06:02:52 <ivanm> Saizan: whoops :s
06:03:01 <ivanm> quicksilver: yeah, that's what I was going towards
06:03:10 <mmorrow> i just put vacuum on hackage
06:03:15 <lady_6thofAu> Could not find module `Codec.Compression.GZip':
06:03:18 <mmorrow> , vacuum (fix (0:))
06:03:21 <lunabot>  [(0,[1,0]),(1,[])]
06:03:22 <ivanm> I've just seen O(n^2) bandied about so much I was lary of using nub for my code, but then realised there wouldn't be many unique elements
06:03:26 <ivanm> mmorrow: which is?
06:03:34 <ppavelV6> does anyone run local package for private code?
06:03:39 <ppavelV6> hackage
06:03:40 <ppavelV6> :)
06:03:43 <mmorrow> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/vacuum-0.0.1
06:03:52 <ivanm> ppavelV6: I sometimes install a package locally when I'm testing stuff
06:04:10 <Saizan> lady_6thofAu: do you have multiple ghc installed? however i think there's some problem with your installation of zlib
06:04:11 <ivanm> mmorrow: so you can't tell us what it is here, rather than forcing us to open up our browsers? :p
06:04:25 <mmorrow> here's a montage of the heapgraph for inserting 12 pairs sequentially into an IntMap http://www.moonpatio.com/vacuum/mapIntChar.png
06:04:27 <ivanm> ppavelV6: but generally, I install it system wide
06:04:36 <quicksilver> mmorrow: it's very very cool but I hope people don't start abusing this stuff for real code :)
06:04:38 <mmorrow> ivanm: it walks the ghc heap
06:04:45 <mmorrow> quicksilver: heh
06:04:46 <lady_6thofAu> i don't think i have multiple ghc
06:04:49 <ivanm> mmorrow: ahhh
06:04:57 <ppavelV6> ivanm:  sorry i meant hackage :)
06:05:03 <quicksilver> mmorrow: that is a thing of beauty.
06:05:04 <quicksilver> mmorrow++
06:05:07 <ivanm> mmorrow: not another graphviz binding! :o
06:05:15 <mmorrow> quicksilver: yeah, there're a few places where i'm not sure how to not enter a closure that shouldn't be entered
06:05:15 <quicksilver> mmorrow: can I haz animated realtime plz?
06:05:20 <doserj> lady_6thofAu: try to remove the zlib package and start bootstrap again
06:05:29 <lady_6thofAu> hmm... reinstalled zlib
06:05:34 <lady_6thofAu> now it's fine :)
06:05:38 <lady_6thofAu> thanks a lot :))
06:05:42 <mmorrow> for instance, with Integers with the J# con, i can't seem to not enter an "ARR_WORDS" and crash :(
06:05:54 * ppavelV6 started CoreGraphics/Quartz binding once
06:06:19 <mmorrow> quicksilver: you can haz!
06:06:35 <ivanm> quicksilver: but only if you can write! ;-)
06:06:40 <quicksilver> mmorrow: I can? Where when?
06:07:17 <mmorrow> quicksilver: i just said that, but it sure would be cool..
06:07:48 * quicksilver nods
06:07:52 <quicksilver> it really would.
06:07:58 <mmorrow> opengl + cool graph rendering + this would be amazing
06:08:04 <wli> > let uniq xs = let u _ [] = [] ; u s (x : xs) = let s' = Set.insert x s ; xs' = u s' xs in if Set.member x s then xs' else x : xs' in u Set.empty xs in uniq $ [1 .. 10] ++ [3 .. 13] ++ [6 .. 16]
06:08:05 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]
06:08:11 <ivanm> mmorrow: since hackage hasn't built your docs yet, what do you use as your internal data structure (graph-wise)?
06:08:13 <mmorrow> i wonder how you'd track changes though
06:08:14 <quicksilver> I want to see the heap graph of traversing a transposed list of lazy lists.
06:08:36 <Baughn> @hoogle finalize
06:08:36 <lambdabot> System.Mem.Weak finalize :: Weak v -> IO ()
06:08:36 <lambdabot> Foreign.ForeignPtr finalizeForeignPtr :: ForeignPtr a -> IO ()
06:08:36 <lambdabot> Distribution.PackageDescription.Configuration finalizePackageDescription :: Package pkg => FlagAssignment -> Maybe (PackageIndex pkg) -> OS -> Arch -> CompilerId -> [Dependency] -> GenericPackageDescr
06:08:36 <lambdabot> iption -> Either [Dependency] (PackageDescription, FlagAssignment)
06:08:46 <mmorrow> ivanm: do you mean the nodes, or the graph itself?
06:08:52 <ivanm> the graph itself
06:09:00 <wli> I've got a bad feeling that open-coding may very well win.
06:09:02 <ivanm> a custom one?
06:09:03 <mmorrow> IntMap HNode
06:09:09 <ivanm> wli: open-coding?
06:09:12 <ivanm> mmorrow: *nod*
06:09:20 <ivanm> mmorrow: any particular reason for not using something like FGL?
06:09:27 <Baughn> What is a "haskell finalizer", exactly?
06:09:41 <wli> ivanm: Explicit recursion vs. any of the Prelude/List/etc. combinators.
06:09:42 <ivanm> Baughn: something that finalises haskell as the greatest language evah!
06:09:43 <ivanm> ;-)
06:09:46 <mmorrow> ivanm: well i'm not really doing any graph algos, just walking the heap
06:09:52 <ivanm> wli: *nod*
06:09:58 <mmorrow> and it'd be trivial to turn into an fgl graph
06:09:59 <Baughn> ivanm: It also appears to make HsOpenSSL not work, though..
06:10:01 <ivanm> mmorrow: *nod* so it was easier for you to hack together?
06:10:09 <ivanm> and hence why you needed custom graphviz bindings?
06:10:15 <ppavelV6> ivanm:  haskell' is the ultimate haskell finalizer :)
06:10:18 <ivanm> Baughn: well, I don't really know ;-)
06:10:22 <liyang> Baughn: something for implementors and FFI authors to worry about. :3
06:10:27 <ivanm> ppavelV6: no, haskell('^n) is ;-)
06:10:39 <ppavelV6> :)
06:10:41 <ivanm> i.e. ((..((haskell')')'..)')'
06:10:47 <mmorrow> ivanm: oh yeah, those are just the boilerplate ones i use for messing around. i want to check out the hs dot generating code for sure
06:10:50 <Baughn> liyang: No, I'm worried. Very worried.
06:11:11 <ivanm> mmorrow: well, I quite like matthew-1's one, except it's taking him a while to check the changes I've made :s
06:11:21 <ivanm> and it needs to be updated to use the new version of polyparse as well :s
06:12:05 <mmorrow> ivanm: (and bear in mind i hacked this together yesterday kindof spur-of-the-moment, so it's not extremely thought-out etc..  ;)
06:12:18 <ivanm> heh
06:12:25 <ivanm> hence the 0.01 versioning?
06:12:41 <mmorrow> hehe, that's just my default .cabal
06:12:41 <quicksilver> Baughn: a finaliser written in haskell (As opposed to C)
06:12:56 <ivanm> ahhh
06:13:01 <quicksilver> Baughn: the point being that, since finalisers occur at GC time, they better not provoke another GC
06:13:12 <quicksilver> Baughn: so therefore it's not all that nice to write them in haskell.
06:13:24 <quicksilver> Although you could schedule them for later execution.
06:13:49 <wli> > let uniq ys = let u _ [] = [] ; u s (x : xs) | Set.member x s = u s xs | otherwise = x : u (Set.insert x s) xs in u Set.empty ys in uniq $ [1 .. 10] ++ [3 .. 13] ++ [6 .. 16] :: [Int]
06:13:51 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]
06:14:05 <Baughn> quicksilver: Do you use some special function to add them?
06:14:23 <quicksilver> Baughn: addForeignPtrFinalizer? or something like that
06:14:29 <quicksilver> @hoogle finalizer
06:14:30 <lambdabot> Foreign.ForeignPtr type FinalizerEnvPtr env a = FunPtr (Ptr env -> Ptr a -> IO ())
06:14:30 <lambdabot> Foreign.Marshal.Alloc finalizerFree :: FinalizerPtr a
06:14:30 <lambdabot> Foreign.ForeignPtr type FinalizerPtr a = FunPtr (Ptr a -> IO ())
06:15:05 <Baughn> quicksilver: Hm. That sounds like a no.
06:15:40 <Baughn> quicksilver: I'm staring at the source of HsOpenSSL now, though, and I can't see where they even add multiple finalizers, much less mix C and Haskell ones..
06:21:36 <wli> What could be interesting is selecting the k highest in sorted order.
06:22:06 <wli> er, selecting the k highest in an order-preserving fashion
06:22:45 <wli> non-order-preserving is highest k xs = let step x = do { s <- get ; let s' = Set.insert x s in if Set.size s' <= k then put s' else put $ Set.deleteMin s'  } in Set.toList . flip execState Set.empty $ mapM_ step xs
06:29:38 <ivanm> is there a way of creating an Array wit a default value used for those values not provided in an assocs list?
06:31:00 <ivanm> I can obviously create one with the default value and overwrite those values that have a non-default value...
06:49:41 <ivanm> @users
06:49:41 <lambdabot> Maximum users seen in #haskell: 662, currently: 616 (93.1%), active: 7 (1.1%)
06:49:49 <ivanm> seems rather dead in here atm...
06:50:33 <quicksilver> it's like the emperor's new clothes
06:50:43 <quicksilver> the discussion is only visible to truly good people.
06:50:52 <ivanm> heh
06:51:02 <Baughn> quicksilver: Turns out my HsOpenSSL woes are caused by a bug in 6.11.. somewhere
06:51:07 <Baughn> At least, it works fine in 6.10
06:51:42 <ivanm> is there any data structure that can represent a 2D grid which gives me easy/efficient access to a given row or column?
06:52:02 <ivanm> if I use IntMap (IntMap a)), I can get easy access to a given row, but not to a column...
06:52:23 <mmorrow> ivanm: it'd be easy if you don't mind keeping some dup data
06:52:40 <ivanm> mmorrow: two lots of them?
06:53:07 <Baughn> ivanm: 2D array wouldn't work?
06:53:08 <mmorrow> ivanm: hmm, i'm not sure if you'd need quite two, but it's possible
06:53:19 <ivanm> that would require careful management as I perform calcualtion on a row being reflected on those same cells in the column view...
06:53:26 <mmorrow> exactly
06:53:34 <mmorrow> which wouldn't be fun, but..
06:53:35 <ivanm> Baughn: well, first of all an array won't work because I need to store [a] :s
06:53:40 <ivanm> mmorrow: *nod*
06:53:51 <wli> One grand IntMap for the whole and a pair of IntMaps for column major vs. row major?
06:54:00 <Baughn> ivanm: There's also IntMap a, doing your own row-column-offset calculations
06:54:04 * ivanm thinks he might be getting too fancy for his own good :s
06:54:05 <mmorrow> you could wrap it in an interface that makes the bookkeeping invisible
06:54:13 <ivanm> Baughn: yeah
06:54:31 <ivanm> mmorrow: well, that was the eventual goal (as in this is an internal data structure anyway)
06:54:37 <wli> The two of which contain as contents indices into the one flat grand IntMap?
06:54:58 <ivanm> I could make it easier on myself by having each cell store it's row and column number...
06:55:12 <ivanm> wli: hmmmm....
06:55:19 <ivanm> that's an interesting way of looking at it...
06:55:38 <ivanm> but having an offset calculation into the one grand IntMap would probably be a neater way of doing it
06:55:39 <mmorrow> the best i can think is to keep something like what wli suggested
06:55:56 * ivanm might stick to Map (Int,Int) for now and see how that goes
06:56:01 <McManiaC> can u say monads are impure in generall?
06:56:04 <mmorrow> and that "grand IntMap" could just as well be a chunk of memory
06:56:10 <ivanm> McManiaC: no
06:56:15 <mmorrow> and you can keep indices in IntMaps
06:56:16 <McManiaC> im kinda confused with puriy & monads
06:56:16 <ivanm> only IO-based ones are
06:56:31 <wli> ivanm: Is this for flexible arrays or some such?
06:56:34 <quicksilver> McManiaC: the whole point of monads, actually, is that they are pure.
06:56:35 <McManiaC> so monads in general are pure but IO arent?
06:56:43 <McManiaC> ok
06:56:44 <ivanm> McManiaC: monads are just a way of dealing with data structures that can store another type of data
06:56:52 <ivanm> wli: latin squares
06:56:59 <quicksilver> McManiaC: they are a pure way of expressing a variety of things - including side effects which normall break purity.
06:57:11 <quicksilver> McManiaC: it is common to speak of IO functions as being impure, but technically incorrect.
06:57:19 <ivanm> actually, what quicksilver says is better than what I said
06:57:22 <quicksilver> McManiaC: IO functions are all perfectly pure, as is all of haskell.
06:57:23 <NameAlreadyInUse> quicksilver: why is it incorrect?
06:57:27 <mmorrow> McManiaC: it's just so happens there's an IO monad. there doesn't have to be, but since haskell's lazy you'd need to use cps or something else to get sequencing
06:57:31 <quicksilver> it's just a comvenient shorthand.
06:57:37 <ivanm> mmorrow: by storing indices in IntMaps, you mean IntMap (IntMap Int) or something?
06:57:39 <quicksilver> we use 'impure' to mean 'in the IO monad'
06:57:45 <NameAlreadyInUse> i thought it was that the IO monad was pure, but that IO itself was impure
06:57:50 <quicksilver> (sometimes we use it that way, but it's technically an abuse of language)
06:57:58 <ivanm> NameAlreadyInUse: the main function is impure
06:57:58 <quicksilver> NameAlreadyInUse: that's one way of describing it, yes.
06:58:05 <ivanm> as it's the only thing that can actually do IO
06:58:10 <mmorrow> ivanm: yeah, (IntMap (f Int), IntMap (f Int)) or something
06:58:16 <mmorrow> for some f
06:58:24 <ivanm> *nod*
06:58:46 <McManiaC> the "in the IO monad" description makes sense
06:58:47 <McManiaC> thx :)
06:59:45 <ivanm> IO a == way of expressing what actions you want done that interface with the real world
06:59:48 <Ferdirand> if you see "IO a" as World -> (a,World), it stills obey the definition or purity, or am I mistaken ?
06:59:48 <ivanm> main actually runs it
07:00:06 <ivanm> Ferdirand: that sounds a bit like uniqueness types in Clean...
07:00:19 <quicksilver> Ferdirand: yes, that is a perfectly pure view.
07:00:19 <ivanm> Ferdirand: IO a itself is just a chunk of instructions to do
07:00:23 <Ferdirand> then IO is just a way of enforcing single-threadedness, and the impurity only arises from the implementation
07:00:36 <quicksilver> Ferdirand: it's also a view which permits time travel and duplication  :)
07:00:39 <quicksilver> Ferdirand: but its' pure.
07:00:40 <ivanm> when you call it indirectly via main, it actually performs the instructions
07:00:46 <ivanm> quicksilver: time travel?
07:00:49 <ivanm> without a delorian? :o
07:00:54 <ivanm> blasphemy!
07:00:55 <ivanm> ;-)
07:00:56 <quicksilver> :)
07:01:10 <McManiaC> lol
07:01:12 <Baughn> ivanm: It'd be really /useful/ to implement, though
07:01:21 <Baughn> You could probably get infinite work done in finite time that way
07:01:23 <ivanm> what, time travel?
07:01:35 <ivanm> yes, but you'd need infinite loops through time
07:01:39 <Ferdirand> what if you have a quantum computer ?
07:01:46 <ivanm> Ferdirand: nope
07:01:46 <Baughn> ivanm: Not really a problem
07:01:56 <Baughn> Ferdirand: "Very fast" != "Infinite"
07:01:59 <McManiaC> :o
07:02:08 <ivanm> quantum computers are just the ultimate parallel processors
07:02:26 <NameAlreadyInUse> ivanm: that is a good way of putting it
07:02:29 <Ferdirand> are they so ?
07:02:32 <ivanm> in that they can consider multiple test inputs, etc. at the same time, and spit out valid inputs
07:02:47 <ivanm> actually, IIRC you need to make sure all quantum calculations are reversible...
07:02:47 <Ferdirand> that sounds like time travel to me
07:02:55 <ivanm> (from Landau's computing stuff)
07:03:01 <ivanm> Ferdirand: in what way?
07:03:03 <Baughn> Ferdirand: Sure. Quantum computers work by, er, splitting up the universe to do a lot of calculations - one per universe - and then merging them back together to find the result. Sort of like map-reduce, really.
07:03:17 <ivanm> Baughn: heh, I like that
07:03:21 <ivanm> quantum-mapReduce
07:03:38 <Baughn> Ferdirand: And I'm not even kidding about the "splitting the universe" bit. That's how they work.
07:03:45 <Baughn> (Mind you, that happens naturally. The special thing about QC is the merging.)
07:03:49 <ivanm> Baughn: quantumCalc :: (a -> Bool) -> Maybe a
07:03:57 <McManiaC> McManiaC :: (SimpleQuestionAboutPurity s, TimeTraveling t, HaskellChannel h) => s -> h -> t
07:04:00 <McManiaC> :D
07:04:02 <Baughn> ivanm: Heh. Not quite, but pretty good. :P
07:04:05 <ivanm> quantumComputer :: (a -> Bool) -> [a] (using a catMaybe . map)
07:04:05 <blarf> so the IO Monad is impure and is therefore the exception not the ruleamon monads?
07:04:18 <ivanm> Baughn: need the second bit as well ;-)
07:04:31 <ivanm> blarf: no
07:04:36 <ivanm> IO Monad is pure
07:04:37 <Baughn> ivanm: Nah, you can only get O(1) data out of a quantum computer
07:04:41 <ivanm> but when main runs it, it's impure
07:04:44 <blarf> so Monads are a way to conveniently express state in a pure way?
07:04:47 <Baughn> ivanm: Or, I suppose, O(t) - like any other computer
07:04:53 <ivanm> Baughn: oh? only one result will work?
07:04:59 <blarf> ivanm: uhm,ok
07:05:01 <Baughn> ivanm: Yep
07:05:08 <ivanm> blarf: no, the State monad is a convenient way of expressing State ;-)
07:05:25 <Baughn> blarf: Monads are a convenient way of expressing computations that have a monadic structure. ;)
07:05:25 <ivanm> Baughn: hmmm.... I thought they'd return _all_ possible results...
07:05:35 <Baughn> blarf: Read the typeclassopedia for the details. :P
07:05:39 <ivanm> oh, there's one other use for quantum computers: quantum crypto! ;-)
07:05:50 <HON> monads are good for when you want monads?
07:06:00 <ivanm> HON: precisely
07:06:04 <McManiaC> hehe
07:06:15 <ivanm> @type join
07:06:16 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
07:06:26 <ivanm> a monad is a data structure that lets you collapse multiple levels of that data structure into one
07:06:28 <ivanm> aka join
07:06:33 * blarf segfaults
07:06:38 <ivanm> *i.e. it implements join
07:06:53 <mmorrow> quicksilver: vacuum on a transposed list was a nice idea: http://moonpatio.com/vacuum/replicate4AndTranspose.png
07:06:55 <Baughn> Yep. Monad = Applicative + join
07:07:00 <mmorrow> that's on:
07:07:06 <ivanm> blarf: so we can convert Maybe (Maybe ( ... Maybe a ... ))) into just Maybe a
07:07:09 <mmorrow> transpose (replicate 4 [0..3])
07:07:15 <quicksilver> mmorrow: nice.
07:07:18 <Ferdirand> so, how about expressing quantum computations by replacing IO with [] ? :)
07:07:26 <Baughn> blarf: Or collapse IO (IO a)) into just IO a
07:07:39 <ivanm> Baughn: I thought join was necessary and sufficient criteria....
07:07:50 <ivanm> Ferdirand: unfortunately, it's not that simple :(
07:07:54 <quicksilver> ivanm: join + return.
07:08:00 <Baughn> ivanm: Well, join doesn't make much sense if the functor isn't already applicative, but..
07:08:03 <quicksilver> ivanm: you get return from Applicative, in Baughn's case.
07:08:10 <Baughn> No, Pointed. ;)
07:08:24 <ivanm> quicksilver: *nod*, I was recalling this from someone trying to explain monads to me a few years ago
07:08:32 <ivanm> obviously, I dind't recall all too well
07:08:40 <ivanm> and no, I haven't finished reading byorgey's masterpiece
07:09:12 <Baughn> ivanm: It goes (Pointed, Functor) => Applicative -> Monad. Sadly, Pointed doesn't exist and Monad duplicates all the Applicative functions. ^^;
07:09:38 <ivanm> Baughn: yeah, I read _that_ much
07:09:41 <Ferdirand> but the merging step that Baughn mentioned
07:09:42 <ivanm> but that was about it :(
07:09:52 <ivanm> Ferdirand: join?
07:09:53 * Baughn also has a feeling pure should be called singleton, but whatever
07:09:58 <ivanm> @src join
07:09:58 <lambdabot> join x =  x >>= id
07:10:01 <Ferdirand> if you are able to select the final universe by "filtering" the result
07:10:09 <ivanm> Baughn: pure == return (in terms of what it does)?
07:10:10 <Ferdirand> you've, in some sense, acted on your past
07:10:12 <quicksilver> Baughn: that would be somehow inappropriate for ZipList
07:10:21 <ivanm> singleton only makes sense in terms of [], IMHO
07:10:30 <quicksilver> Baughn: and thus Reader (which is the same)
07:10:34 <Baughn> quicksilver: Well, sort of..
07:10:46 <mmorrow> quicksilver: here's (replicate 4 [0..3]) before transpose http://moonpatio.com/vacuum/replicate4_0dotdot4.png
07:10:50 <Baughn> (repeat 2) /is/ a singleton, in one sense
07:10:55 <Baughn> Just.. not the same one as [2]
07:11:22 <Baughn> ivanm: pure = return, by definition.
07:11:48 <quicksilver> mmorrow: now I *really* want you animate the one into the other :)
07:12:00 <quicksilver> Baughn: I'm not sure what sense (repeat 2) is a singleton
07:12:03 <quicksilver> or (const 2)
07:12:05 <ivanm> Baughn: thought so, just checking
07:12:25 <Baughn> quicksilver: Memory-wise. It's a cell referring to itself, so there's just a single cell, there will never be more than one cell..
07:12:32 <Baughn> ..but that's not very haskelly of me, I know
07:12:42 <quicksilver> it's not part of the spec of repeat that it consumes only a single cell :)
07:12:46 <quicksilver> that's an implementation detail.
07:12:52 <quicksilver> although a handy one.
07:13:51 <ivanm> just like how cycle doesn't actually create an infinite list?
07:13:56 <mmorrow> here's a side-by-side montage of before/after transpose http://moonpatio.com/vacuum/transpose.png
07:14:01 <mmorrow> cool
07:14:18 <ivanm> mmorrow: why the name?
07:14:28 <mmorrow> because the left is
07:14:29 <ivanm> and what does ":|" mean?
07:14:35 <ivanm> mmorrow: I meant "vacuum"
07:14:37 <mmorrow> replicate 4 [0..3]
07:14:38 <ivanm> ;-)
07:14:40 <mmorrow> heh
07:14:50 <mmorrow> ivanm: because it's sucking the heap out
07:14:52 <mmorrow> ;)
07:14:56 <ivanm> (I hit enter too early)
07:14:57 <ivanm> ahhh
07:15:08 <ivanm> OK, what does ":|" mean?
07:15:15 <conal> lispy: congrats on your thesis defense!
07:15:36 <mmorrow> ivanm: ah, so ":|n" is <constructor-name>|<order-that-the-traversal-reached-that-node>
07:15:39 <ivanm> has someone blocked eleanore or something? or is it a problem at his/her end?
07:15:49 <ivanm> mmorrow: *nod*
07:16:07 <mmorrow> so it's doing breadth-first, just like you'd do in a copying garbage collector
07:16:07 <ivanm> so you're just listing traversal order, and not what it contains?
07:16:17 <ivanm> oh, wait, that's what S# means I take it?
07:16:23 <mmorrow> @src Integer
07:16:23 <lambdabot> data Integer = S# Int#
07:16:25 <lambdabot>              | J# Int# ByteArray#
07:16:31 <ivanm> ooohhhh.....
07:16:39 <mmorrow> i could list what it contains, as i have the list of that closure's literals
07:17:25 <McManiaC> wow
07:17:25 <McManiaC> weird definition
07:17:29 <quicksilver> ivanm: if I'd blocked her (him) they wouldn't even get that far.
07:21:15 <Olathe> > 5
07:21:43 <lambdabot>   5
07:23:58 --- mode: irc.freenode.net set +o ChanServ
07:25:02 <ejt> Olathe: is that the answer you expected ?
07:25:11 <blarf> in C, should import like #include <stdio> be in .h or .c?
07:25:28 <mmorrow> kadaver: h
07:25:40 <kadaver> what the f, why did my psotcome twice?
07:25:52 <kadaver> thnx
07:26:50 <vixey> when you do problem solvings like math homework in school type things,  you are putting emphasis on how you got the answer,  but in functional programming you have emphasis on what the answer is ?
07:29:28 <kadaver> can you achieve generics in C with macros?
07:29:43 <kadaver> liek replace type when you instantiate a linkedlist for exampel?
07:33:58 <NameAlreadyInUse> kadaver: er.. sort of, but not really
07:33:58 <vixey> kadaver: try ##c
07:33:58 <edwardk> @seen dons
07:33:58 <lambdabot> dons is in #haskell-soc, #gentoo-haskell, #yi, #concatenative, #arch-haskell, #ghc, #xmonad, #darcs and #haskell. I don't know when dons last spoke.
07:33:58 <edwardk> preflex: seen dons
07:33:58 <preflex>  dons was last seen on #haskell 11 hours, 46 minutes and 42 seconds ago, saying: yes.
07:33:58 <NameAlreadyInUse> what is preflex?
07:33:58 * edwardk doesn't know why i bother asking lambdabot any more ;)
07:33:58 <edwardk> my memory on its origin is pretty fuzzy, but I think it's mauke's bot
07:33:58 <quicksilver> another bot, which is better at reliable 'seen' information.
07:33:58 <vixey> preflex: seen jkff
07:33:58 <preflex>  jkff was last seen on #haskell 6 days, 1 minute and 17 seconds ago, saying: Not all of them. There was a thread in haskell-cafe that provided counterexamples: iirc, they were about Either
07:33:59 <quicksilver> it is mauke's, yes.
07:33:59 <ejt> preflex: seen ejt
07:33:59 <preflex>  ejt was last seen on #haskell 9 minutes and 58 seconds ago, saying: Olathe: is that the answer you expected ?
07:34:52 <mmorrow> vixey: i put vacuum on hackage
07:36:29 <NameAlreadyInUse> what is with all this joining?
07:36:32 <Workybob> > second (+1) undefined
07:36:32 <lambdabot>   (* Exception: Prelude.undefined
07:37:02 <vixey> mhm so
07:37:02 <wli> join $ asks lift
07:37:03 <vixey> there are very many subtle differences between type systems
07:37:11 <vixey> hmf
07:39:06 <Ferdirand> stay together, you humpty-dumpty of networks !
07:39:55 <vixey> it's too turbulent to actually say what I want to
07:40:14 <vixey> HM, HM(X), SysF, SysF(c), Boxy types, Rank2, RankN, Impredicative/Predicative, CHR typeclasses, fundeps, families... Is there any uniform way to look at them all (similar to the lambda cube?)
07:40:52 <wli> They aren't really the same sorts of things.
07:45:23 <trofi^w> what is faster to encode/decode? json or yaml?
07:45:36 <Baughn> trofi^w: Binary
07:45:44 <EvilTerran> trofi^w, i doubt there's a significant difference
07:45:51 <intuit> I gues yaml
07:45:53 <Baughn> Data.Binary, that is
07:46:01 <intuit> it has less superflupous characters.
07:46:09 * EvilTerran would've guessed json, because of the non-whitespace-sensitivity
07:46:09 <intuit> superflurous*
07:46:12 <trofi^w> i have 20GB of unstructured textual logs
07:46:59 <trofi^w> Baughn: i have problems making simple extensible binary formats
07:48:12 <EvilTerran> gesundheit, freenode
07:48:21 <trofi^w> json can represent objects in 1 string (no newlines), while yaml can not. right?
07:48:32 <Baughn> trofi^w: So?
07:48:41 <EvilTerran> i think you can do non-whitespace-sensitive yaml
07:48:54 <EvilTerran> iirc, the syntax is pretty much identical to json
07:48:57 <trofi^w> Baughn: easy to grep
07:53:00 <trofi^w> looks like yaml library (HsSyck) uses ByteString, while json/rjson plain String
07:55:57 <maltem> Good afternoon everyone. Is there a history/reference to the use of the word "eigenvariable" in the context of existential types?
07:59:35 <guenni> Workybob: still there?
08:00:37 <maltem> (I picked it from Jason Dagit's thesis and was just wondering.)
08:00:58 <BMeph_> mmorrow: I got a weird error when cabal-installing vacuum. Interesting, but weird. :)
08:01:34 <BMeph_> preflex: seen lispy
08:01:34 <preflex>  lispy was last seen on #haskell 9 hours, 52 minutes and 18 seconds ago, saying: good luck
08:01:58 <BMeph_> maltem: Go to the source. ^^
08:03:22 <maltem> BMeph_: which is?
08:11:41 <BMeph_> maltem: lispy == "Jason Dagit". Leave a message for lispy, and he should help you out. :)
08:13:11 <maltem> ahh I see :)
08:13:19 <vixey> maltem: is this online ?
08:13:30 <vixey> great http://files.codersbase.com/thesis.pdf
08:13:56 <maltem> vixey: Right, I was going to link there
08:14:37 <maltem> @tell lispy Out of curiosity, is  there a history/reference to the use of the word "eigenvariable" in the context of existential types, as I picked it up from your thesis?
08:14:37 <lambdabot> Consider it noted.
08:15:02 <vixey> what's German for variable?
08:15:13 <vixey> in the context of mathematics and logic
08:15:32 <ksf> wooot! i just came up with comonads.
08:15:37 * ppavelV6 can help with russian :)
08:16:52 <maltem> vixey: "Variable"
08:17:03 <NameAlreadyInUse> @src liftIO
08:17:04 <lambdabot> Source not found. My pet ferret can type better than you!
08:17:29 <vixey> oh it's actually a German word originally?
08:17:53 <maltem> vixey: Hm I don't think it is in this case. "Eigenwert" is, though (eigenvalue)
08:18:02 <ksf> "variabel" sounds latin or greek
08:18:07 <blarf> does it make any sense to learn C++ these days? imight want to get into gamedev, is it C or C++ that is used then?
08:18:07 <blarf> i know some C and some Java
08:18:23 <ppavelV6> http://www.dict.cc/english-german/variable.html
08:18:25 <NameAlreadyInUse> blarf: C++ is used in game dev mostly
08:18:50 <NameAlreadyInUse> blarf: but you can also use newer languages like python, with libraries for graphics and sound, etc
08:18:53 <maltem> vixey: ("it" standing for eigenvariable)
08:19:03 <Zao> blarf: C-ish C++ tends to be the main language for core tech.
08:19:07 <ksf> why didn't they translate it to innate value?
08:19:16 <Zao> blarf: More fun languages like C# and Python work fine with most tools.
08:19:34 <NameAlreadyInUse> i prefer C to C++, i only wish that C had more support for polymorphism
08:19:36 <Zao> This is proper professional dev, of course. For indie, use whatever pleases you.
08:19:52 <maltem> ksf: Maybe they were lacking a dictionary
08:20:07 <ppavelV6> there're actually lots of guys around with microbenchmarking staff in mind who keep struggling with c++ even this seem ineffective
08:20:36 <ppavelV6> the spend good amount of their life learning quirks of the monstrous language and not prepared to give up their expertize
08:20:48 <ksf> if http://www.dwb.uni-trier.de/ was loading, i could tell you where "variable" comes from.
08:21:14 <ksf> c is utterly polymorphic.
08:21:22 <maltem> I'm pretty sure it's latin, no?
08:21:28 <vixey> *noise*
08:21:37 <ksf> you can even mix types with different sizeof's in pointers.
08:21:50 <ppavelV6> go assembler
08:21:56 <ppavelV6> PDP-11 is my favorite
08:22:15 <maltem> ksf: Merriam-Webster says: Middle English, from Anglo-French, from Latin variabilis, from variare to vary
08:22:36 * ksf only knows x86 and amd64 with almost no mmx/see, but loves x87
08:22:58 <BMeph_> ppavelV6: Y'know, C is the llvm for the PDP-11. ;)
08:23:10 <ppavelV6> BMeph: yep:) always told so :)
08:23:22 <ppavelV6> and C++ is overgrown macroassembler
08:23:23 <NameAlreadyInUse> ksf: i mean proper support for polymorphism, not hacking around with macros and typecasting
08:23:40 <ppavelV6> NameAlreadyInUse: you're kidding, right?
08:23:45 <ksf> "Vernderliche" is actually the "proper" german word for variable.
08:24:03 <NameAlreadyInUse> ppavelV6: no, i am not kidding
08:24:07 <ksf> literally meaning "changeable thingy"
08:24:24 <BMeph_> dcoutts: ping
08:24:46 <ksf> "veraendern" being the perfect aspect of "aendern" == "to change"
08:24:48 <ppavelV6> NameAlreadyInUse: you will end up with the language which you can't call C anymore
08:25:59 <blarf> NameAlreadyInUse: but for serious game dev is python used? for writing complete games or like lua is used?
08:26:04 <NameAlreadyInUse> ppavelV6: so? when you change things, they become different
08:26:26 <guenni> does anybody here know of a good haskell resource to learn "single pass" techniques, deforestation, etc?
08:26:33 <vixey> @free split :: ((x,y) -> x, (x,y) -> y)
08:26:33 <lambdabot> (forall k p. f . k = p . $map_Pair f g             =>              h k = p) => (forall f1 f2. g . f1 = f2 . $map_Pair f g               =>                q f1 = f2) => $map_Pair h q split = split
08:26:37 <ksf> mmmmhhhh.... list comonad.
08:26:48 <NameAlreadyInUse> blarf: for 'serious' game dev you have large and experienced teams of people
08:26:51 <ksf> I think I'm sold and abandoning iteratees.
08:27:16 <ksf> nope, that's "enterprise" game dev.
08:27:40 <ksf> for serious game dev you got a couple of coders, a couple of pixlers and some contracted sfx guys.
08:27:53 <NameAlreadyInUse> i am not going to start quibbling over semantics
08:28:08 <quicksilver> most of the big successful games have only a small handful of coders
08:28:18 <quicksilver> obviously loads of other peopl involved in the project
08:28:20 <ppavelV6> NameAlreadyInUse: no problem with this, but asking for more polymorphism in C is like asking for better high-altitude hypersonic characteristics of submarine
08:28:42 <wli> I hate ap.
08:28:43 <ksf> ...and are written in assembly. see transport tycoon.
08:29:42 <ksf> ppavelV6, well, you never know if you want to space-drop them while invading a planet...
08:30:22 <jeffersonheard> @seen dons
08:30:23 <lambdabot> dons is in #haskell-soc, #gentoo-haskell, #yi, #concatenative, #arch-haskell, #ghc, #xmonad, #darcs and #haskell. I don't know when dons last spoke.
08:30:27 <blarf> is there some Maybe readFile to?
08:30:43 <blarf> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2901#a2901 <- im trying to implement it there, help plz
08:30:45 <NameAlreadyInUse> ppavelV6: are you suggesting that if C had more support for polymorphism, that it would go unused? i can't see where you are coming from here
08:31:05 <ksf> does anyone have pointers to good comonad blogs?
08:32:05 <blarf> so the main work of a game is the arty side of graphics, not the engine itself?
08:32:30 <ksf> yes.
08:32:32 <ppavelV6> NameAlreadyInUse: i suggest that C has it's niche and fits it perfectly. Trying to stretch it you ultimately get something like C++
08:32:33 <ejt> blarf: why not write a 'try' function that takes any IO action and checks for exceptions
08:32:44 <ejt> blarf: eg. try :: IO a -> IO (Maybe a)
08:32:46 <ksf> ...or pixlers are a lazy bunch, whatever.
08:33:06 <ksf> level design, too.
08:33:10 <ppavelV6> NameAlreadyInUse: frankly, i should stop commenting on this issue coz i don't really understand what kind of polymorphism support you envision in C
08:33:34 <blarf> is it ok to use structs to achieve a limited form of polymorphism in C where the user then would then create a struct and sepcify the type in the struct?
08:33:44 <mmorrow> BMeph: uhoh. what was the error?
08:35:21 <mmorrow> s/BMeph/BMeph_/
08:35:33 <ksf> I figure it's because a good game needs emergent complexity, and good code provides exactly that. otoh, stuff like procedural texture+level generation can be very, very hard to pull off at decent quality.
08:36:05 <guenni> anybody know a tutorial for efficient grouping?
08:36:16 <guenni> mmorrow: hi
08:36:21 <mmorrow> hey
08:37:00 <NameAlreadyInUse> blarf: that technique is also useful for encapsulation, and you can do that, but it is a very big stretch to say that C has a good level of support for polymorphism
08:37:51 <ksf> still, i'd love to work for a studio that says "we're going to ship c64 and pc binaries, built from the same sources"
08:38:18 <guenni> ksf: c64?
08:38:39 <NameAlreadyInUse> commodore 64 i assume
08:38:41 <mmorrow> void* is the ultimate in polymorphism
08:38:57 <ksf> http://en.wikipedia.org/wiki/Commodore_64
08:39:01 <guenni> NameAlreadyInUse: so you're an old fossil too :)
08:39:46 <ksf> well, strictly speaking, c64's are older than me.
08:40:02 <ksf> ...at least they were designed before i was born, though not sold.
08:40:11 <quicksilver> Thing on a Spring!!!
08:40:12 <guenni> ksf: not me, that was the 1st comp I had
08:40:22 <BMeph_> mmorrow: I have what looks like an unstable GHC build. I have conflicts in the process package. I don't think it's your pasckage in particular, it's just where it's popped up. :)
08:40:42 <NameAlreadyInUse> mmorrow: if you are going down that road then you might say that untyped languages are the ultimate in polymorphism, but that's not what i mean
08:41:03 <mmorrow> BMeph_: oh yuk, did you get a duplicate symbol loaded in ghci?
08:41:26 <BMeph_> mmorrow, no I didn't get so lucky. Here's what I saw:
08:41:51 <mmorrow> NameAlreadyInUse: untyped language cannot be polymorphic, because its definition depends on the existence of types :)
08:41:51 <BMeph_> "cabal: dependencies conflict: ghc-6.10.1 requires process ==1.0.1.0 however process-1.0.1.0 was excluded because ghc-6.10.1 requires process ==1.0.1.1"
08:41:58 <lilac> @type elemIndices
08:41:59 <lambdabot> forall a. (Eq a) => a -> [a] -> [Int]
08:42:37 <mmorrow> BMeph_: ah, sucky. i guess the ghc==6.10.1 constraint woke the giant
08:43:42 <NameAlreadyInUse> mmorrow: sigh, fine, i give up
08:43:58 <mmorrow> NameAlreadyInUse: hehe
08:44:25 <NameAlreadyInUse> mmorrow: it still doesn't change the fact that it is much easier to write a cons function that works on any type in C++ than it is in C, which is a shame
08:45:08 <wli> I hate ap so bad. @pl always uses ap on the reader monad and it's always totally indecipherable and untranslatable to anything comprehensible.
08:46:59 <ksf>  @pl should also have a no-pattern-matching option, I hate expression duplication.
08:47:15 <mmorrow> typedef struct cons {void *hd; void *tl;} Cons; Cons *cons(void *x, Cons *xs){Cons *ys = (Cons*)malloc(sizeof(Cons)); ys->hd = x; ys->tl = xs; return ys;}
08:47:24 <mmorrow> oops
08:47:33 <mmorrow> typedef struct cons {void *hd; Cons *tl;} Cons;
08:47:59 <NameAlreadyInUse> that doesn't work on any type
08:48:14 <mmorrow> why not?
08:48:20 <ksf> graagh can't citeseer generate sane file names?
08:48:27 <NameAlreadyInUse> because it only works on pointers
08:48:41 <mmorrow> um, registers can only hold pointers
08:48:46 <jmcarthur> huh?
08:48:54 <mmorrow> i meant words
08:49:04 <mmorrow> that cons function works fine for ints
08:49:24 <mmorrow> void *foo(int x){ return (void*)x; }
08:49:46 <jmcarthur> what about float or double?
08:50:03 <mmorrow> you'll need to pass in a ptr for them
08:50:14 <jmcarthur> then it doesn't work for just any type
08:50:24 <vixey> #define type double
08:50:29 <vixey> #include polymorphic.h
08:50:32 <vixey> #define type int
08:50:34 <mmorrow> well then haskell lists don't work for any type then
08:50:34 <vixey> #include polymorphic.h
08:50:41 <vixey> now you have  list_double  and  list_int
08:50:44 <mmorrow> everything in haskell is a ptr
08:51:05 <jmcarthur> haskell lists work for any haskell type
08:51:09 <vixey> ptr oriented programming :P
08:51:19 <jmcarthur> just not every C type
08:51:26 <ksf> sadly enough, the c preprocessor isn't touring-complete.
08:51:36 <intuit> Turing*
08:51:47 <vixey> stick it in a while loop, then it's turing complete
08:51:52 <mmorrow> jmcarthur: so you're arbitrarily restricting the "types" the haskell list has to work for?
08:52:04 <lilac> jmcarthur: they don't work for types of kind # do they?
08:52:29 <jmcarthur> mmorrow: would it make sense to expand the definition of type to things outside of haskell control in the context of haskell lists?
08:52:50 <jmcarthur> lilac: that's ghc, not haskell, afaik
08:52:54 <mmorrow> all i'm trying to say is that whether it "works" or not is just a matter of arbitrary perspective
08:52:58 <lilac> jmcarthur: true :)
08:53:11 <vixey> my way works for basic types
08:53:17 <jmcarthur> i don't think the choice to remain in the haskell world is so arbitrary...
08:53:25 <mmorrow> jmcarthur: well, why not? everything is under haskell's control, including C "types"
08:53:31 <ksf> there's all kind of cool stuff you can do with e.g. the nasm preprocessor.
08:53:35 <mmorrow> , 1#
08:53:36 <lunabot>  luna: Not in scope: `#'
08:53:37 <jeffersonheard> who runs haskell.hivefire.com?
08:53:51 <jeffersonheard> I need to have a post removed from it asap...
08:53:51 <jeffersonheard> :-(
08:54:04 <mmorrow> (where a "type" in C is basically a given bit width)
08:54:39 <NameAlreadyInUse> mmorrow: there is no pointer manipulation in haskell at least. i can do "String" : [] or 53 : [] and not have to worry about allocating the memory and whatever else
08:55:32 <lilac> @users
08:55:32 <lambdabot> Maximum users seen in #haskell: 662, currently: 619 (93.5%), active: 23 (3.7%)
08:55:47 <lilac> jeffersonheard: you now have 619 people looking for that post :-o
08:56:13 <mmorrow> mallocBytes, peek, poke... (all i'm saying is that these things are accessible), but i concede that the C pointer list doesn't work for *any* type, if type is defined as "n, where n is a multiple of 32bits"
08:56:14 <jmcarthur> mmorrow: don't the "C types" from the FFI still indirect from pointers?
08:56:33 <jmcarthur> i know unboxed types don't, but those are not haskell as i already said
08:56:51 <quicksilver> the C types indirect via pointers, sure.
08:57:04 <quicksilver> but the Ptr / ForeignPtr functions give you direct access
08:57:11 <quicksilver> to memory which has been allocated by you, or by a C program.
08:57:17 <mightybyte> What is the best practice regarding GHC's "definition but no type signature" warning?
08:57:29 <mmorrow> jmcarthur: well what does it *really* mean for you to "have" a var in C?
08:57:40 <mightybyte> Include type signatures for everything, or turn it off/ignore it?
08:57:47 <quicksilver> mightybyte: (a) add a type signature (b) ignore it ;)
08:57:50 <jmcarthur> mmorrow: it doesn't really mean anything in C ;)
08:57:59 <mightybyte> quicksilver: Can you turn that warning off?
08:58:17 <mmorrow> jmcarthur: :)
08:58:21 <quicksilver> well you can not have warnings on.
08:58:53 <kadaver> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2903#a2904
08:59:07 <kadaver> ^^ error message
08:59:14 <mightybyte> quicksilver: There's no way to use -Wall and then supply another option to turn that warning off?
08:59:24 <quicksilver> mightybyte: sadly I don't think so.
08:59:26 <c_wraith> Personally, I'd just add a type signature.  They're useful as documentation anyway.
08:59:32 <quicksilver> mightybyte: really there should be one flag per warning but I don't think there is.
08:59:39 <quicksilver> mightybyte: I don't find -Wall helpful.
08:59:40 <mightybyte> quicksilver: Ok
09:00:05 <Cale> kadaver: I've had that annoyance as well. Basically, you have to give a type signature to your error handler.
09:00:14 <quicksilver> (mainly because of the inexhaustive pattern match warning)
09:00:27 <ejt> I've got -Wall -iSource -fno-warn-name-shadowing
09:00:31 <mightybyte> So is it a reasonable policy to have a warning-free compile with -Wall for significant haskell applications?
09:00:38 <Cale> kadaver: It's a result of the way the new exceptions library works.
09:00:40 <ejt> so you can turn off options from Wall
09:01:01 <Frederick[SE]> how can i read the contents of a file through readFile?
09:01:37 <Cale> Frederick[SE]: Inside an IO do-block, you would write something like  cs <- readFile "foo"
09:01:45 <mightybyte> quicksilver: I think the main reason I started using -Wall was to catch functions missing a definition for a particular constructor.
09:02:13 <sandy78> vien me voir sur www.maxicanne.com
09:02:24 <mightybyte> quicksilver: ...as opposed to finding out in a runtime error
09:02:24 --- mode: ChanServ set +o quicksilver
09:02:33 --- mode: quicksilver set +b *!*=Maxicann@*.ai.une.maxicanne.com
09:02:33 --- kick: sandy78 was kicked by quicksilver (quicksilver)
09:02:50 <quicksilver> mightybyte: well, IMO it isn't. But then again the warning I hate is precisely the one you're after :)
09:03:05 <mightybyte> quicksilver: Oh really?
09:03:50 <Frederick[SE]> <Cale> Frederick[SE]: Inside an IO do-block, you would write something like  cs <- readFile "foo" << Ok, but then the result in cs is like an IO String no?
09:03:53 <mightybyte> quicksilver: You find it necessary to have incomplete funcitons?
09:04:06 <Cale> Frederick[SE]: No, readFile "foo" is an IO String, cs is a String
09:04:51 <Frederick[SE]> ok, i guess ill give it a try
09:05:09 <jeffersonheard> argh...  that was odd.
09:05:14 <jeffersonheard> Is it possible to remove an article from Planet Haskell?
09:06:09 <jeffersonheard> Yes, I just asked, but since I was booted, I wasn't sure the question made it to the channel
09:06:09 <Cale> Frederick[SE]: Of course, in that same do-block, you'll probably actually want to do something with that String, like transform it somehow and print it, say.
09:06:19 <dons> I don't think so. the feed disappears though, next time it is indexed
09:06:21 <jeffersonheard> dons, do you know who runs haskell.hivefire.com?
09:06:21 <Cale> Frederick[SE]: The do-expression as a whole will have type IO t for some type t.
09:06:22 <dons> nope
09:06:22 <dons> cleaning up the internet is hard :/
09:06:22 <vixey> what article is it?
09:06:22 <jeffersonheard> Alright.  Well, I wrote to their editors as well
09:06:24 <dons> ok.
09:06:53 <dons> you did well to get the key hits for that term inside a week :)
09:07:22 <Frederick[SE]> <Cale> Frederick[SE]: Of course, in that same do-block, you'll probably actually want to do something with that String, like transform it somehow and print it, say. << I would like to input it to the lines function
09:07:24 <jeffersonheard> The "Preview: Data Waves" article. Basically I have a director who's working on a paper for IEEE Vis with a similar, but non-identical bent, and my article's appearing well above her work in the search engines
09:07:27 <quicksilver> mightybyte: yes.
09:07:34 <Frederick[SE]> do { contents <- readFile "toll.in"; fn_cases2 1 lines contents }
09:07:34 <kadaver> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2903#a2905 <- so it works now but how can I avoid 3 returns when only 2 should be needed? and can it be done ina clearer way?
09:07:36 --- mode: quicksilver set -o quicksilver
09:07:46 <Frederick[SE]> ive done this, where fn_cases2 is another function
09:08:00 <Frederick[SE]> i think i need parenthesis around "lines contents"
09:08:02 <jeffersonheard> It's not that big a deal, but I see her point; better to let her article get published on it before it feels like everyone's thought of it already.
09:08:05 <Frederick[SE]> but besides that, it doesnt work either :\
09:08:13 <dons> jeffersonheard: shows why blogs rule
09:08:22 <Cale> Frederick[SE]: yes, unless you intend to pass the lines function as a parameter to fn_cases2
09:08:35 <vixey> @free oneOf :: a -> a -> a
09:08:35 <lambdabot> f . oneOf x = oneOf (f x) . f
09:08:45 <jeffersonheard> dons: I agree.  *shrugs* Oh well.
09:08:45 <dons> and ACM is useless, in terms of having an impact as a researcher
09:08:50 <Cale> Frederick[SE]: fn_cases2 will have to produce an IO action for that to be valid.
09:08:50 <dons> :)
09:08:54 <Frederick[SE]> im a beginner in haskell, started yesterday
09:09:52 <Cale> Frederick[SE]: If you want it to simply print the result of fn_cases2, you should apply 'print' to the result.
09:09:52 <Cale> :t print
09:09:53 <lambdabot> forall a. (Show a) => a -> IO ()
09:09:53 <bremner> dons: first draft of slides from RWH 1-3. Let me know if the attribution etc... is not OK. http://www.cs.unb.ca/~bremner/teaching/4613/lectures/week11/
09:09:53 <jeffersonheard> dons: However, blog posts can't go on your CV, so they're not that good for getting hired
09:09:53 <Frederick[SE]> fn_cases2 :: Int -> [String] -> [ (Int, Int, String, String) ]
09:09:54 <Frederick[SE]> thats the signature of the function fn_cases2
09:10:24 <Frederick[SE]> i want to feed it a number, and a list of lines as [String]
09:13:01 <dons> jeffersonheard: right
09:13:22 <Frederick[SE]> i think i dont understand what the notation IO String means
09:13:24 <Cale> Frederick[SE]: and do what with the resulting list?
09:13:35 <dons> bremner: checking...
09:13:41 <Cale> Frederick[SE]: a value of type (IO t) is like a program which if you run it, produces a value of type t.
09:14:08 <Cale> Damn these netsplits!
09:14:26 * bremner makes no guarantee that his slides have any educational value
09:14:35 <Frederick[SE]> hrmm...
09:14:38 <Frederick[SE]> this is starting to become annoying
09:14:42 <dons> probably i'd mention ghc -O2 as well, so they don't think it is a toy :)
09:14:46 <dons> bremner: otherwise, looks fine
09:15:27 <Cale> Frederick[SE]: anyway, does that make sense?
09:15:37 <bremner> dons: great. thanks.
09:15:48 <Cale> Frederick[SE]: So inside a do-block when you write  v <- x  it means to run the IO action x, and name its result v
09:16:05 <Cale> Frederick[SE]: And then the do-block as a whole has type IO t again.
09:16:27 <Cale> That is, do-notation is how you glue simpler IO actions together into more complicated ones.
09:16:27 <bremner> dons: about toyness, I'm going to get them to play with the simple xml library
09:16:27 <Frederick[SE]> hrm... ok, the do-block itself is an IO as well?
09:16:33 <Cale> yes
09:16:45 <Frederick[SE]> so, now i got from one problem to another problem, how does this help me?
09:16:50 <saml> do block is an expression. one expression.
09:17:05 <Cale> Frederick[SE]: So, you said that fn_cases2 :: Int -> [String] -> [ (Int, Int, String, String) ]
09:17:10 <Frederick[SE]> yep
09:17:20 <Cale> Frederick[SE]: what do you want to do with that [ (Int, Int, String, String) ] you're going to get?
09:17:24 <Frederick[SE]> that im calling with: fn_cases = do { contents <- readFile "toll.in"; fn_cases2 1 lines contents }
09:17:32 <Cale> That's a type error
09:17:44 <Frederick[SE]> yah, i suppose there's something wrong
09:17:48 <Cale> Because fn_cases2 doesn't produce an IO action, and the lines of a do-block need to be IO actions
09:18:01 <Frederick[SE]> let me paste the piece of code on hpaste
09:18:16 <Cale> Frederick[SE]: It's okay, just tell me what you want to do with the resulting list.
09:18:24 <Frederick[SE]> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=2906#a2906
09:18:29 <Frederick[SE]> i just want to return it
09:18:37 <Cale> Oh, then you want return
09:18:51 <Cale> fn_cases = do { contents <- readFile "toll.in"; return (fn_cases2 1 (lines contents) }
09:19:13 <Cale> This will have type  IO [(Int, Int, String, String)]
09:19:18 <jacobian> How do I compile Main.hs to a static executable with ghc?
09:19:30 <jacobian> ghc -c Main.hs -o File
09:19:30 <jacobian> ?
09:19:32 <Cale> jacobian: ghc --make Main
09:19:53 <Cale> jacobian: Or  ghc Main.hs -o Main
09:20:17 <Cale> jacobian: But it's generally a good idea to use --make because it will add extra -package flags if needed.
09:20:55 <jacobian> Thanks
09:20:59 <Frederick[SE]> now i get this error: Algorithm.hs:42:28: Couldn't match expected type `[t]' against inferred type `IO String' In a 'do' expression: contents <- readFile "toll.in" In the expression: do contents <- readFile "toll.in" return (fn_cases2 1 (lines contents)) In the definition of `fn_cases': fn_cases = do contents <- readFile "toll.in" return (fn_cases2 1 (lines contents))
09:21:23 <Cale> It looks like you're missing a semicolon.
09:21:28 <Cale> Or... something.
09:22:02 <jacobian> Hmm, When I compile it doesn't print the prompt prior to asking for input, but it does using ghci.  I suspect this has something to do with laziness...
09:22:18 <saml> jacobian, it's about buffer
09:22:20 <NameAlreadyInUse> jacobian: what are you using to print the prompt?
09:22:24 <Frederick[SE]> the semicolon before return is actually in the program
09:22:24 <Cale> jacobian: Probably not actually. It's probably line buffering.
09:22:34 <saml> @hoogle stdout
09:22:34 <lambdabot> System.IO stdout :: Handle
09:22:34 <lambdabot> Distribution.Simple.Program rawSystemProgramStdout :: Verbosity -> ConfiguredProgram -> [ProgArg] -> IO String
09:22:34 <lambdabot> Distribution.Simple.Program rawSystemProgramStdoutConf :: Verbosity -> Program -> ProgramConfiguration -> [ProgArg] -> IO String
09:22:35 <jacobian> The magic incantation to make this work?
09:22:38 <jmcarthur> jacobian: laziness won't cause your IO actions to change order
09:22:56 <jacobian> Ah yeah, because they are in a monad
09:23:45 <jacobian> Is there a force output?
09:23:47 <vixey> is there any IO comonad that isn't broken?
09:23:51 <saml> jacobian, you can try this:      hSetBuffering stdout NoBuffering
09:24:07 <saml> but if you compile it.. i think by default it doesn't buffer
09:24:10 <Cale> Frederick[SE]: Did you change the type of fn_cases?
09:24:22 <saml> jacobian, what operating system are you using?
09:24:32 <jacobian> linux
09:24:38 <Frederick[SE]> no Cale
09:24:38 <jmcarthur> vixey: i can't imagine one, really
09:24:39 <mmorrow> vixey: what in particular is the broken parts of some you've seen?
09:24:49 <Cale> Frederick[SE]: Because it's not a list.
09:24:56 <Cale> Frederick[SE]: It's an IO action which produces a list.
09:25:14 <Cale> Frederick[SE]: So it has type  IO [(Int,Int,String,String)]
09:25:35 <Frederick[SE]> return (fn_cases2 1 (lines contents)), why does this not return the result of fn_cases2 with those arguments?
09:25:58 <vixey> mmorrow: All I remember is it's broke
09:26:02 <vixey> was called OI
09:26:05 <mmorrow> heh
09:26:09 <Cale> Frederick[SE]: If v is any value of type t, then return v is an IO action of type IO t, which does nothing, and whose result is always v.
09:26:36 <Cale> Frederick[SE]: The result of a do-block is the result of the last IO action in it.
09:26:53 <Frederick[SE]> which in my case would be?
09:26:53 <mmorrow> was it broken because of the fact that haskell's a lazy lang, or because of something actually under its control?
09:26:53 <Cale> Frederick[SE]: So the result of that IO action will indeed be fn_cases 2 with those arguments.
09:27:07 <Cale> er, fn_cases2
09:27:13 <Frederick[SE]> i dont think i understand how the IO things work
09:27:19 <saml> jacobian, import System.IO            hSetBuffering stdout NoBuffering
09:27:22 <Frederick[SE]> im really puzzled :(
09:28:06 <Cale> Think of an IO action value as representing a program. Normal Haskell evaluation doesn't cause that program to run, but there are ways to glue these programs together into larger ones.
09:28:10 <saml> Frederick[SE], don't be. think of IO as C
09:28:18 <Cale> In the end, you define an IO action called main
09:28:23 <Cale> and it's what gets to run
09:28:30 <saml> do {  stmt1; stmt2;   var <- assignment;  return result; }
09:28:44 <jacobian> I'm using hFlush
09:28:48 <jacobian> Which seems to work
09:28:55 <jacobian> thnx all
09:28:56 <Cale> saml: you have an extra superfluous semicolon there
09:28:56 <mmorrow> Cale: i'd say it as, running a program is what causes it to be evaluated
09:29:07 <saml> woops
09:29:10 <Cale> mmorrow: sure.
09:29:19 <saml> > return 1; return 1;
09:29:20 <lambdabot>   <no location info>: parse error on input `;'
09:29:28 <Frederick[SE]> <Cale> In the end, you define an IO action called main << I get that idea, that your program itself is like an IO action
09:30:15 <Frederick[SE]> but i just want to read the contents of a file with readFile and pass it to the lines function to get something of type [String]
09:30:15 <Ogedei> I'm looking for information on the way GHC's garbage collector is implemented. any recommended papers/websites?
09:30:16 <Cale> Frederick[SE]: so... the only remaining thing which is wrong with your code, I think, is that you have a bad type signature for fn_cases
09:30:41 <jmcarthur> I think conal has finally convinced me that the IO monad is just a hack. I mean, of course it's kind of a sin bin, but now I think it doesn't fit declarative programming style at all. :\
09:30:47 <Cale> Frederick[SE]: Because it does I/O, its type *must* have IO somewhere in it.
09:30:53 <Frederick[SE]> yeah, but i dont want to return something of type IO [ (Int, Int, String, String) ]
09:30:55 <Frederick[SE]> i want to return something of [ (Int, Int, String, String) ]
09:31:00 <NameAlreadyInUse> Frederick: you can't do that
09:31:05 <Cale> jmcarthur: I'm unconvinced.
09:31:06 * Frederick[SE] cries
09:31:13 <Cale> Frederick[SE]: impossible.
09:31:15 <Frederick[SE]> damn you haskell
09:31:16 <mmorrow> Frederick[SE]: imagine you're living in a function of type ([String -> a), and you've just been handed to (\f -> ... . f . lines =<< readFile)
09:31:21 <conal> jmcarthur: glad to hear it. :)
09:31:25 <Cale> Frederick[SE]: What would you do with that list anyway?
09:31:42 <Frederick[SE]> the result list is a case for a dijkstra algorithm i have to implement
09:31:47 <Frederick[SE]> a list of cases
09:31:56 <jmcarthur> Cale: I am unconvinced that the Reactive semantics are necessarily a good alternative, but I'm optimistic.
09:31:56 <Cale> Frederick[SE]: Well, that's fine.
09:32:02 <jmcarthur> conal: :)
09:32:12 <Frederick[SE]> so, it _must_ have IO in it?
09:32:19 <Frederick[SE]> i can never get rid of the IO part?
09:32:23 <c_wraith> Frederick[SE]: Just separate your file-opening logic from your parsing logic.  The file opening logic must have IO in it.  The parsing logic doesn't need it.
09:32:28 <Cale> Frederick[SE]: The parts which need to do input and output do.
09:32:39 <jmcarthur> Frederick[SE]: you can apply pure functions to it with fmap/liftA/liftM/(<$>)/etc.
09:32:50 <Cale> Frederick[SE]: but, as you can see, you can pass the result of some IO action off to some other function which isn't in IO
09:32:54 <jmcarthur> Frederick[SE]: so even though it can't escape from IO, you can still use it
09:33:14 <Cale> Frederick[SE]: and get back a result that you do some further I/O stuff with (like printing it)
09:33:14 <Frederick[SE]> so, i can write a seperate function which executes the IO part
09:33:28 <Cale> Frederick[SE]: right, reading the file, printing the results.
09:33:30 <Frederick[SE]> and then use that function in another function which wont need the type IO Something
09:33:35 <seliopou> jmcarthur, I take the position that it's a good pragmatic solution to the problem
09:33:36 <Cale> no
09:33:41 <Cale> Frederick[SE]: That's backwards
09:33:45 <NameAlreadyInUse> jmcarthur: what makes the IO monad a hack? i was not aware that there were conflicting views on monadic IO
09:33:51 <Cale> Frederick[SE]: You use the non-IO function inside your IO
09:34:02 <jmcarthur> seliopou: for now :)
09:34:10 <Frederick[SE]> yes Cale, the fn_cases2 function you mean?
09:34:21 <Cale> Frederick[SE]: right, for one.
09:34:21 <vixey> IO isn't a hack
09:34:21 <vixey> it's perfect
09:34:36 <conal> one can think of functional programming in a mechanical way or a semantic way.  perhaps IO fits with the former but not the latter.
09:34:39 <jmcarthur> NameAlreadyInUse: It's inherently imperative. Some think this is fine because they see the real world as inherently imperative. Others do not.
09:34:55 * mmorrow throws oil-spill seagulls at vixey
09:35:03 <Cale> I don't see the IO monad as inherently imperative.
09:35:17 <seliopou> jmcarthur, of course, but I have this visceral reaction to PL people saying "the IO monad is a hack, and so I'm not going to use it (read: haskell)"
09:35:18 <conal> i don't know how anyone can think of reality as imperative.
09:35:18 * vixey cleans them
09:35:20 <Cale> But this is something I seem to have trouble explaining to others. :)
09:35:31 <seliopou> when it's something that actually lets you write real programs
09:35:39 <ksf> If IO wasn't imperative, Haskell wouldn't be the best imperative language.
09:35:39 <jmcarthur> Cale: sure, you can declaratively compose actions, but then those actions are just imperatively evaluated.
09:35:40 <seliopou> for the most part, in the style you want
09:35:42 <Frederick[SE]> i got to prepare dinner, thanks for the help Cale
09:35:46 <Frederick[SE]> i will be back later
09:36:11 <Cale> jmcarthur: If you want to think of it that way, I suppose.
09:36:12 <conal> i don't know where this notion of "real programs" came from or what it could really mean.
09:36:20 <Cale> jmcarthur: I'm not sure it's something intrinsic.
09:36:22 <ksf> it also has the most thunk-forcing bind implementation that I know of.
09:36:27 <conal> how could some programs be more real than others?
09:36:53 <jmcarthur> Cale: Perhaps not. I do think a monad is a reasonable abstraction for side effects, just not a declarative one.
09:37:07 <conal> hm.  maybe haskell is a "complex" language, in that it combines "real" (imperative) and "imaginary" (functional).
09:37:10 <Cale> jmcarthur: I don't see why it's not declarative...
09:37:10 <seliopou> conal, by "real" I mean programs that actually do things, rather than little theoretical toys
09:37:17 <jmcarthur> conal: haha
09:37:28 <Cale> jmcarthur: Though perhaps it's not *as* declarative in some ways as one might like.
09:37:38 <conal> seliopou: oh -- so you're into *do*ing.  then you probably like imperative programming.
09:37:46 <conal> functional programming is not about doing things.
09:37:47 <NameAlreadyInUse> jmcarthur: do you think that monads in general suffer from this problem of being imperative?
09:37:47 <seliopou> conal, I do not
09:37:54 <ksf> conal, it's a thing that arises if you accept the hypothesis of a time line.
09:37:59 <jmcarthur> Cale: I'll put it this way. The IO monad is little more declarative than a C program. To some degree, even a C program is declarative though.
09:38:08 <Cale> jmcarthur: Right.
09:38:08 <jmcarthur> NameAlreadyInUse: monads are not about being imperative
09:38:11 <ksf> ...which, of course, is bunk, as we all know since relativity and quantum mechanics.
09:38:13 <vixey> conal, some thought occured to me today -- We are usually brought up told to show our working when solving problems.. but functional programming is much more about describing what the solution is so.. it's maybe why imperative programming is something more people pick up first (not sure ..)
09:38:16 <conal> ksf: (hi)  what thing arises?
09:38:20 <seliopou> FP 4lyfe
09:38:25 <vixey> "even a C program is declarative though" -- what ?
09:38:28 <vixey> can you justify that
09:38:29 <jmcarthur> NameAlreadyInUse: monads are just a decent way to model imperative things
09:38:48 <Cale> jmcarthur: I think the monadic style is something which we can't quite call completely imperative, and we can't quite call it completely declarative either.
09:38:55 <jmcarthur> vixey: a program doesn't do anything, even a C program
09:39:05 <Cale> But it's certainly functional
09:39:10 <jmcarthur> vixey: only when it's executed does anything happen
09:39:10 <vixey> 'not doing something' isn't the definition of declarative
09:39:10 <idnar> vixey: I don't think there's any inherent preference between imperative and declarative programming
09:39:20 <mmorrow> vixey: CPP is like acid for your codez
09:39:21 <idnar> vixey: the only reason why people pick up imperative programming first is because that's how programming is presented
09:39:28 <sebaseba> would it be possible to make a QuickCheck-like tool that generates arbitrary data to approximately calculate the space and time behavior of a function?
09:39:32 <conal> idnar: agreed.
09:39:52 <vixey> idnar: I'm suggesting that it might also be to do with the way we are brought up
09:39:55 <conal> idnar: since imperative programming is such an unnatural view,
09:39:57 <idnar> most people are introduced to mathematics in a declarative fashion, and then "imperative" maths seems awkward
09:39:57 <NameAlreadyInUse> jmcarthur: what are some potentially better approaches to IO, in your opinion?
09:40:04 <EvilTerran> sebaseba, in theory, i think so, yes
09:40:13 <vixey> what is imperative maths?
09:40:16 <jmcarthur> NameAlreadyInUse: FRP is one area that I think has potential.
09:40:32 <dancor> how should i store floating point literals in my abstract-syntax-tree
09:40:38 <conal> NameAlreadyInUse: i'll offer an answer: think about what things mean / are rather than what discrete sequences of actions to take.
09:40:45 <EvilTerran> sebaseba, although there's trouble involved in making sure everything gets evaluated at the right times
09:40:50 <idnar> vixey: something like the Euclidean algorithm, perhaps?
09:41:03 <dancor> string is safest wrt floating wackiness
09:41:07 <jmcarthur> @quote frp
09:41:07 <lambdabot> No quotes match.
09:41:15 <ksf> conal, imperativity. without time, you can't have an effect follow its cause, you can only have effects depending on causes, which is declerative.
09:41:15 <jmcarthur> ah i thought we had one or two
09:41:36 <dancor> but Double might be nicer and work anyway bc the ieee standard is just as wack in php as in haskell?
09:41:38 <Cale> Although it's very beautiful, and I think it's the right design for many types of programs, FRP seems somehow far less universal to me than IO. It's "easy" to construct an FRP library which uses IO as a foundation, but can we reasonably expect the reverse?
09:41:40 <sebaseba> EvilTerran: you mean the evaluation order depends on what the caller does with the data?
09:41:54 <conal> ksf: you think imperativity follows from time?
09:41:54 <idnar> Cale: I was trying to put that into words just now
09:42:23 <Cale> And if we can, then how does FFI work?
09:42:27 <conal> ksf: if so, i wonder if you mean something much looser than temporally discrete, sequential imperative programming.
09:42:32 <idnar> Cale: I might change my mind on that subject as the FRP "space" is explored further, but right now, it certainly seems unclear how most programs would be expressed in an FRP fashion
09:42:40 <EvilTerran> sebaseba, indeed; the complexity of evaluating an expression may vary depending on the caller's forcing behaviour (as well as whether it's been evaluated before)
09:42:50 <idnar> Cale: whereas we already know how to do all manner of things in an IO fashion
09:42:55 <jmcarthur> ksf: I like your observation that the dependencies between cause and effect is declarative.
09:42:56 <Cale> idnar: Right.
09:43:01 <conal> once you look at time continuously, i don't know how to apply the traditional imperative model.  but the functional model fits easily.
09:43:03 <EvilTerran> sebaseba, so creating something general that measures the complexity of evaluating arbitrary things may be a bit tricky
09:43:37 <idnar> Cale: I certainly thing FRP is attractive for the cases where we know how to use it, though
09:43:43 <Cale> I do too.
09:43:45 <EvilTerran> sebaseba, it'd probably be necessary to use ghc-api rather than just writing an in-language library (cf quickcheck)
09:43:50 <idnar> *think
09:44:08 <Cale> I just don't see it replacing the IO monad until some big new idea comes along.
09:44:08 <vixey> if FRP means what I think it does there is no reason you would ever /not/ use it in haskell
09:44:09 <quicksilver> idnar: attractive FRP! http://roobarb.jellybean.co.uk/~jules/Picture%205.png
09:44:15 <idnar> quicksilver: hee hee
09:44:18 <Cale> (at least, not entirely)
09:44:30 <idnar> uhm, does FRP have any roots in graphics programming, or did it "evolve" separately?
09:44:35 <mmorrow> i don't see why it's so hard to view a program as a mapping from its "input" to its "output"
09:44:41 <vixey> quicksilver: what's the implementation of that?
09:44:53 <idnar> because that's the first thing I thought about when I read a description of FRP for the first time
09:45:09 <tpr> How to declare an array of infinite ones?
09:45:14 <NameAlreadyInUse> can "do" be nested?
09:45:14 <jmcarthur> idnar: if anything, i think it may come more from robots and simulations
09:45:14 <conal> idnar: i was working on graphics when i came up with FRP.  but i knew it was much more general.
09:45:17 <jmcarthur> > repeat 1
09:45:19 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
09:45:21 <Cale> mmorrow: The hard thing about it is what types its input and output are.
09:45:24 <NameAlreadyInUse> tpr: let x = 1:x
09:45:25 <vixey> tpr: a list or array?
09:45:26 <Cale> mmorrow: (At least in my mind)
09:45:29 <quicksilver> vixey: petal = Prim2D $ Bezier2D (0,0) (25,50) [((25,100),(0,100),(-25,100))] (-25,50) (0,0)
09:45:34 <mmorrow> Cale: heh, i'm thinking about exactly that right now
09:45:35 <conal> FRP is the product of thinking about what things mean.  if you want to explore FRP-ish perspectives, shift your thinking to what things mean.
09:45:39 <quicksilver> vixey: flower n = Many $ map (\r -> RotateDeg2D r petal) [0,step..(360-step)] where step = 360 / fromIntegral n
09:45:42 <idnar> early graphics APIs (computer games etc.) were highly imperative; then later APIs became more and more declarative
09:45:54 <vixey> aha
09:45:56 <Cale> mmorrow: It's the expression problem all over again!
09:45:56 <mmorrow> Cale: well, a computer can only take as input bits, and output bits
09:46:01 <mmorrow> bits are information
09:46:09 <mmorrow> hence, input and output are information
09:46:13 <Cale> mmorrow: The IO monad has a good solution to adding new types of input and output.
09:46:13 <quicksilver> vixey: for full source, http://www.haskell.org/pipermail/reactive/2009-March/000253.html
09:46:20 <mmorrow> program :: Information -> Information
09:46:20 <idnar> initially there was a fair amount of resistance, but in the end it turned out that "immediate mode" graphics and such just can't be as easily efficient
09:46:21 <quicksilver> NameAlreadyInUse: yes. do constructs expressions.
09:46:23 <sebaseba> EvilTerran: let's imagine a concrete case. Some data is read in through IO, processed, and written back. How would you go around measuring the complexity of this code?
09:46:24 <vixey> thanks
09:46:37 <NameAlreadyInUse> quicksilver: ok, i'll see if i can get it right
09:46:38 <quicksilver> NameAlreadyInUse: you can use that anywhere else you use expressions, including other do blocks.
09:46:38 <idnar> so modern graphics APIs seem to be quite FRPish in nature
09:46:39 <Cale> mmorrow: But if you shove input and output into data structures, since Haskell doesn't have open datatypes, it becomes a problem to extend.
09:46:52 <EvilTerran> sebaseba, ah, if you include IO as well, that makes things even harder
09:47:07 <seliopou> yowzers
09:47:12 <quicksilver> tpr: haskell arrays can't be infinite. haskell lists can.
09:47:13 <conal> idnar: yes.  FRP was taking the idea of retained mode graphics to a (for me) logical conclusion.
09:47:13 <tpr> vixey: may I ask what's the difference.. :S
09:47:21 <tpr> quicksilver: ahso
09:47:24 <EvilTerran> sebaseba, for measuring memory consumption at least, you'd need some kind of introspection or something
09:47:25 <vixey> tpr: Well arrays cannot be infinite .. I think
09:47:35 <conal> idnar: and adding in modern PL design & theory.
09:47:37 <vixey> tpr: lists are 'built up from below' but arrays are one thing
09:47:42 <jmcarthur> tpr: lists are linked lists, arrays are buffers
09:47:51 <mmorrow> Cale: i think some good answer to this question would be very interesting
09:48:09 <quicksilver> idnar: a good graphics library is "static" - it doesn't do any IO anyway.
09:48:10 <vixey> we should really find something better than IRC :/
09:48:18 <jmcarthur> type classes can serve as "open data types"
09:48:26 <quicksilver> idnar: so I was cheating, really, but the graphics I just pasted are animated by FRP.
09:48:32 <idnar> quicksilver: heh
09:48:40 <quicksilver> idnar: at least it was on-topic self promotion.
09:48:43 <idnar> quicksilver: well when I say "graphics", I'm actually talking about a bit more than just image generation / manipulation anyhow
09:48:53 * vixey has abused normal 'closed' data types to write open programs
09:48:57 <jmcarthur> well, combined with existential quantification anyway
09:49:22 <vixey> infact I'm not the only one to do this, there's even an example on haskell wiki
09:49:28 <jmcarthur> or, in the absence of type classes, the dictionary passing mechanism that it abstracts
09:49:35 <vixey> really open data types would be a great thing to add though
09:49:44 <Cale> jmcarthur: Well, yes, but really inconveniently so. :)
09:49:50 <vixey> I think the theory of it is all worked out, just no implementation
09:50:16 <conal> i encourage people not to think of FRP as the important thing, but semantic design, which is what led to frp and can lead to other & better things.
09:50:40 <Cale> Am I the only one who thinks the new exceptions library looks nice on paper but when you try to actually use it, it's far more painful than the old one?
09:50:59 <sebaseba> EvilTerran: then how about starting with pure functions, and assuming that all inputs to the function are unevaluated (WHNF?), and that the output is completely evaluated?
09:51:01 <vixey> Cale: no!
09:51:01 <vixey> I hate the new one
09:51:02 <vixey> :p
09:51:04 * jmcarthur has never used exceptions except when a library throws them already
09:51:49 <wunki> as a complete Haskell beginner, would it be "do-able" to write a web crawler? (need to make a web crawler to gather data for my final thesis)
09:52:04 <vixey> wunki: yeah sure
09:52:17 <NameAlreadyInUse> wunki: so your final thesis is the web crawler?
09:52:18 <jmcarthur> wunki: sounds like an excellent beginner project, actually
09:52:24 <yakov> hey
09:52:35 <EvilTerran> sebaseba, well, that'd be simpler; you can do timing from within haskell fairly straightforwardly, too
09:52:49 <wunki> no, my final thesis needs the data from the web crawler as input for a SVM
09:52:55 <jeffersonheard> conal: The thing I struggle with is how to think about a large program with many inputs and outputs and heterogenous data.  I can do FRP in small projects, but when I have a visualization that also outputs files occasionally to interact with other apps that I have no control over, I'm kind of lost as to how to represent that
09:53:24 <ziman> what is the best way to go if i wanted a large (60 million elements), therefore preferrably unboxed, array of a custom type? (data Correlation = Correlation !Double !Double) i've tried uvector but i don't know how to write an UA instance for Correlation
09:53:25 <EvilTerran> with Data.Time.*, say
09:53:27 <wunki> ok, so as a complete haskell no-no, I should be able to create a crawler..
09:53:44 <yakov> i'm back to haskell from long pause, seems like I need to go through abc once again, though could anybody take a look, what am I doing wrong to make lazy list of event here
09:53:44 <yakov> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2909#a2910
09:53:48 <jmcarthur> wunki: given some patience to learn as you go, of course :)
09:53:53 <sebaseba> EvilTerran: how about measuring space complexity in this case?
09:53:55 <vixey> wunki: Well you can expect to learn a bit on the way
09:54:15 <wunki> well, I got 3 months to build it :)
09:54:16 <jeffersonheard> ziman, you could just use two unboxed arrays of Doubles...
09:54:30 <jmcarthur> wunki: oh yeah, you should be able to do that
09:54:36 <vixey> wunki: You can do it in a week :p
09:54:41 <vixey> or less
09:54:48 <EvilTerran> sebaseba, i don't think you can get at memory usage information without using ghc-api or similar
09:54:49 <wunki> thanks for the coinfedence :)
09:54:55 <conal> jeffersonheard: yep.  i bet it's hard.  as always, i'd hang out with the question of what *meanings* you're getting at.
09:55:28 <conal> jeffersonheard: otherwise, the *doings* will keep distracting you.
09:55:35 <wunki> ok, well, let's get started with RWH than...
09:55:40 <sebaseba> EvilTerran: ok thanks, will take a look at the ghc-api
09:55:43 <quicksilver> jeffersonheard: "outputs files occasionally" sonds like outputs files in response to events.
09:55:49 <jeffersonheard> conal: I am -- I still see things as essentially events and behaviours
09:55:52 <quicksilver> jeffersonheard: I have found the type "Event (IO ())" useful.
09:55:53 <jeffersonheard> quicksilver, yes
09:56:10 <quicksilver> jeffersonheard: that is "execute a little bit of old fashioned IO on event arrival"
09:56:20 <quicksilver> handy for patching in stuff like writeFile and putStrLn
09:56:22 * jmcarthur has been thinking about starting a tutorial that approaches haskell from a semantic design point of view from the very beginning with no imperative->functional transitioning material
09:56:41 <conal> jmcarthur: !
09:57:09 <yakov> even if i write ``take 1'' nonthing happens :-/
09:57:15 <jeffersonheard> quicksilver, interesting, because what I was developing was instead something that looked more like IO (Event a)
09:57:20 <jmcarthur> conal: i'm not sure i'm good enough in the area of semantic design yet to be instructive though
09:57:29 <jmcarthur> just something that's been in my head lately
09:57:40 <quicksilver> jeffersonheard: there is a trivial example in hte code I just linked to above
09:57:52 <quicksilver> jeffersonheard: (it putStrLns every key press event)
09:58:15 <quicksilver> my answer to your initial query would be "don't just think of a big mass of inputs and outputs"
09:58:23 <conal> when people start with the question "how do i do something?", they're going to be at odds with functional programming throughout.  i wonder how to inspire people to trade in that question.  to see doing as secondary -- in service of being, not vice versa.
09:58:34 <jeffersonheard> quicksilver, thanks.  Basically I've come to seeing a large application as essentially bunch of behaviours linked together by a bus on which sit events.
09:58:39 <ziman> jeffersonheard, yeah, or maybe i could try UArr (Double :*: Double)
09:58:47 <conal> jmcarthur: takes practice.  glad to hear your interest. :)
09:59:35 <quicksilver> jeffersonheard: hmm. I don't think of events as linking behaviours, really.
09:59:45 <quicksilver> jeffersonheard: I just think of events-and-behaviours being mutually dependent.
09:59:51 <jmcarthur> conal: yeah. i just want to better solidify the manner of thinking
09:59:55 <quicksilver> where events are discrete and behaviours are continous.
10:00:11 <quicksilver> jeffersonheard: but yes, between the inputs and outputs are lots of intermediate behaviours.
10:00:19 <quicksilver> (just like the intermediate claculations in an imperative program)
10:01:52 <jeffersonheard> quicksilver: I don't think of events as linking behaviours either.  I think of the bus as linking behaviours
10:02:44 <jmcarthur> conal: i'm thinking of starting very simple, of course. i want to see how far i can take things without talking about recursion and pattern matching, using combinators and higher order functions instead and considering their implementations to be low-level details
10:03:11 <jeffersonheard> Behaviours consume discrete events and produce discrete events.
10:03:40 <conal> jmcarthur: cool.
10:03:41 <jmcarthur> jeffersonheard: I like that!
10:03:47 <quicksilver> jeffersonheard: ah, sorry, I mis-parsed you then.
10:04:05 <conal> jeffersonheard: also vice versa.
10:04:15 <jeffersonheard> conal: exacty
10:04:47 <conal> except, not really.  behaviors just are.  and events just are.
10:04:47 <vixey> jmcarthur: You wil start with an alternative prelude?
10:04:59 <jmcarthur> vixey: thought about it
10:05:25 <conal> and they satisfy relationships without each other, just as numbers do (e.g., 3+4 == 7).
10:05:25 <jmcarthur> although that would admittedly be less practical
10:05:37 <vixey> I don't see why that is any less practical
10:06:36 <jmcarthur> vixey: eh, just because a lot of libraries are in love with the prelude functions, and document assuming them
10:06:38 <jmcarthur> would need to introduce Prelude somewhere anyway, i guess
10:07:03 <jeffersonheard> conal: I think I see what you're saying but where are the events/behaviours in (3+4 == 7) ? 3, 4, and 7 are events, and + and == are behaviours?
10:07:17 <jeffersonheard> Trying to figure out what you mean by "satisfy relationships"
10:07:29 <mmorrow> jmcarthur: "every great journey begins with a single step", and so on
10:08:32 <zandax> hello
10:08:46 <quicksilver> jeffersonheard: I think probably the fact that behaviourFoo = snapshotWith f behaviourBar eventBaz
10:08:59 <quicksilver> jeffersonheard: here, foo is 7 and bar is 3 and baz is 4
10:09:03 <quicksilver> jeffersonheard: (and + is f)
10:09:12 <quicksilver> the point is, 7 = 3 + 4 isn't the *definition* of 7
10:09:17 <quicksilver> although it is a way to calculate it.
10:09:21 <conal> jeffersonheard: "just as numbers do (e.g., 3+4 == 7)."
10:09:50 <conal> quicksilver: yeah.  nor are 7 "caused by" 3 & 4.
10:10:11 <lament> and 1 begat 2, and 2 begat 3, and 3 begat 7...
10:10:19 <conal> :)
10:10:22 <zandax> I had a look at IORefs the other day and I don't get why they are functional. To me it looks like an impreative construct. Can someone explain to me how their existence is reasoned? :/
10:10:46 <conal> which is also why i don't like "scene graphs":  they're more like expressions than they are like meanings.  and we *already* have expressions.
10:11:03 <lament> zandax: Simple. They're cheating.
10:11:03 <jmcarthur> zandax: They are imperative.
10:11:04 <jeffersonheard> ah right, so there are no events in (3+4==7), only an expression of relation, I understand
10:11:23 <lament> zandax: there's absolutely no ideological justification for them. If you want to write nice functional code, don't use them.
10:11:25 <quicksilver> zandax: they are functional because the only way you can access them in IO.
10:11:34 <zandax> lament jmcarthur are you serious?
10:11:41 <quicksilver> zandax: readIORef :: IORef a -> IO a
10:11:42 <zandax> how Haskell can be completly functional then?
10:11:46 <conal> jeffersonheard: no -- i mean that there is no "produced by".  i'm using numbers as an *analogy*.
10:12:00 <quicksilver> zandax: since you can only access them in IO, all bets are essentally off.
10:12:01 <jeffersonheard> oh.  I'm overcomplicating things
10:12:09 <jmcarthur> zandax: the IO monad is haskell's way of handling imperative ideas
10:12:10 <quicksilver> zandax: IO is nondeterministic, it's allowed to do anything.
10:12:18 <zandax> I understand
10:12:21 <quicksilver> having said that, it's not very difficult to give a well-defined semnatics for IORefs.
10:12:33 <lament> if you can do input and output in IO, why not IORefs?
10:12:43 <quicksilver> after all, STRefs are perfectly semantically sane, and they're the same thing.
10:12:45 <NameAlreadyInUse> zandax: IO is done in the IO monad, so functions can still be referentially transparent
10:12:54 <conal> IO is called the "sin bin" because it's where we toss things that don't have meanings & nice properties.
10:13:01 <jmcarthur> zandax: also see STRef, which gives you a pure way to use mutation without disastrous effects leaking into the rest of your pure code
10:13:21 <zandax> I'll hava a look at it.
10:13:43 <conal> that's why "pure functional language" doesn't ring as true in my ears as "segregated imperative/functional language"
10:13:53 <jmcarthur> zandax: in fact, IORef and STRef are exactly the same in implementation, afaik. they just have different types
10:14:05 <zandax> I see
10:14:05 <conal> which i don't mean as a language criticism.  the segregation trick is cool.
10:14:19 <zandax> I still need to fully understand monads.
10:14:20 <jmcarthur> yeah, it's a very good architectural design
10:14:44 <lament> blah blah blah it's purely functional and realworld is an argument, whoever still believes that junk :)
10:15:08 <zandax> :)
10:15:24 <lament> (if you think of haskell like that, you can also think of every other language like that)
10:15:33 <conal> "realworld as an argument" sort of works if one doesn't have concurrency.
10:15:37 <jmcarthur> lament: It's a reasonable abstraction though.
10:15:46 <lament> jmcarthur: yes.
10:15:54 <___> every other language doesn't give you the option of *not* taking RealWorld as input to every function :)
10:15:56 <conal> concurrency breaks the abstraction.
10:15:58 <vixey> zandax: an IORef is just a name for some slot, and functions on it just produce instructions about what to do (that's what a value of IO a is).
10:16:14 <lament> ___: right, haskell's saving grace is essentially not having global variables :)
10:16:18 <jmcarthur> conal: forkIO is just another action
10:16:20 <quicksilver> lament: it's not junk.
10:16:27 <quicksilver> lament: it just might not be the argument you're looking for.
10:16:33 <jmcarthur> conal: both threads can still pretend the other doesn't exist
10:16:39 <vixey> > 1+1
10:16:40 <lambdabot>   2
10:16:40 <quicksilver> lament: "getLine" is a constant - it always returns the same 'IO String' action.
10:16:41 <vixey> I use the GADT and Tree models, Not RealWorld
10:16:46 <quicksilver> lament: that's the point of the purity argument.
10:16:49 <quicksilver> it's an important point.
10:16:52 <conal> jmcarthur: that model wouldn't behave like IO.
10:16:56 <quicksilver> even if it's not the one you want.
10:17:03 <lament> quicksilver: no, it's not the one i want
10:17:05 <jmcarthur> conal: why not?
10:17:43 <vixey> > 1+1
10:17:45 <lambdabot>   2
10:17:46 <conal> jmcarthur: because concurrent imperative programming uses nondeterministic *interleaving*.  and the semantic model of World -> (a,World) can't handle interleaving.
10:17:50 <lament> quicksilver: the problem is that as soon as you can do a lot of stuff in the realworld (for example, put things in IORefs), it should become part of your semantic model, otherwise you're cheating
10:17:55 <conal> jmcarthur: and it's not nondeterministic.
10:18:17 <quicksilver> lament: sure, but that's not the purity argument.
10:18:24 <quicksilver> lament: that's the "tractable semantics" argument.
10:18:32 <blarf> how do you choose a hashfunction so it always lands within a given range? lets say i have 10K elem array to store the keys. now I made a naive hashfunction that returns 176K roughy for 'c' . so do you divide it by 100? but then if you get a low value it could result in 0. what imwodnering is how to bst avoid collisions i guess
10:18:43 <quicksilver> blarf: module division.
10:18:49 <jmcarthur> Thinking about what happens to the RealWorld parameter breaks the IO abstraction though. IO actions are already nondeterministic. Just because forkIO (in "reality") changes what future actions return doesn't mean that it is any different from any other action, which can do the same thing.
10:18:52 <quicksilver> > 1765412 `mod` 10000
10:18:54 <lambdabot>   5412
10:19:45 <jmcarthur> (forkIO someAction) is just an atomic action as far as IO is concerned, is what I mean.
10:19:46 <ejt> blarf: I use hash tables that are power of 2 sized and then just and the key against table_size - 1
10:19:56 <quicksilver> lament: I don't think it's particular hard to give IORef a tractable semantics, although I'm not sure anyone has done so formally.
10:20:07 <quicksilver> ejt: which mathematically is hte same answer as mine.
10:20:17 <quicksilver> ejt: it's just a bit manipulation algorithm ;)
10:20:24 <conal> jmcarthur: try giving a semantic model that explains the meaning of "x := 3; print x"
10:20:43 <blarf> whats up with this friggin flushing the channel?
10:20:45 <ejt> quicksilver: yep
10:20:48 <jmcarthur> conal: I don't see how a good semantics for IO is relevant to whether forkIO breaks the IO abstraction.
10:20:55 <Cale> blarf: netsplits.
10:21:05 <jmcarthur> conal: We already both agree that IO pretty much has no semantics.
10:21:18 <Cale> blarf: One or more of the servers which freenode runs on is having connection problems.
10:21:23 <quicksilver> ejt: depending on yoru hash algorithm and how much you care, it might be better to use prime numbers for your bucket size, too.
10:21:59 <ejt> quicksilver: yep
10:22:07 <conal> jmcarthur: probably communication confusion.  i meant the semantic model (abstraction) of IO a as World -> (World,a) works only in the absence of concurrency.
10:22:56 <conal> jmcarthur: and not only absence of intra-program concurrency.  also program/world concurrency.
10:23:28 <jmcarthur> conal: I think it depends on what World is. The IO monad doesn't expose World to you, and in fact doesn't guarantee anything about what World represents. Without being able to observe what forkIO does to World, I don't see how forkIO breaks the abstraction.
10:24:08 <ejt> quicksilver: I think having a prime number of buckets is mainly useful if you're using open addressing rather than a chained hash table
10:24:16 <conal> jmcarthur: toss out World.  replace it with any state type at all.
10:24:35 <jmcarthur> conal: But a State type *does* have defined semantics.
10:25:00 <jmcarthur> Almost by definitions, World does not.
10:25:09 <quicksilver> jmcarthur: then, it wouldn't be a semantics.
10:25:21 <quicksilver> if you claim you are modelling IO as World -> (World,a) World has to mean something
10:25:25 <quicksilver> otherwise that's not a model
10:25:28 <quicksilver> it's just a crayon sketch.
10:25:33 <conal> jmcarthur: maybe you're saying that effectively IO has no semantics, so people won't mind anything that happens when their program executes.
10:25:41 <lament> heh
10:26:01 <quicksilver> by saying IO a is World -> (World,a) we must have in our minds some way of formalising World values
10:26:12 <quicksilver> even if it's so fiddly we don't even expect to write it down.
10:26:19 <jmcarthur> quicksilver: how is forkIO any different than any other asynchronous action?
10:26:23 <Gracenotes> a World is 584935820459834322-tuple...
10:26:30 <Gracenotes> *is a
10:26:31 <quicksilver> well it's not. It'st he asynchronous part that's the problem
10:26:35 <quicksilver> and I think that's conal's point.
10:26:45 <quicksilver> World -> (World,a) requires synchronoy
10:26:52 <quicksilver> and it requrires the World not to change while you're not looking
10:26:56 <luite> does anyone know why scanlU (uvector) does not do the same as a regular scanl (in particular, its result is one element shorter)
10:26:57 <quicksilver> neither of those sounds like promising assumptions
10:26:58 <jmcarthur> which we don't have even in the absence of forkIO
10:27:05 <quicksilver> although you can certainly simplify things so it is true
10:27:18 <quicksilver> (the definition of 'World' required for IORef, and IORef alone, would be fine)
10:27:47 <jmcarthur> that's the ST monad :)
10:27:53 <int-e> World -> (World,a) doesn't capture the linear nature of the usage of World.
10:28:04 <quicksilver> int-e: that doesn't matter.
10:28:12 <quicksilver> int-e: the need to use it linearly is an implementation constraint.
10:28:23 <quicksilver> int-e: semantically it's fine to duplicate Worlds all over the place :)
10:28:34 <quicksilver> although of course no haskell programs can do that.
10:28:36 <___> world0 has an x in the world's keybuffer, world1 has an empty keybuffer
10:28:43 <___> well say (getChar :: IO Char) or in other words (getChar :: World -> (Char, World)).
10:28:48 <jmcarthur> i see now what you mean though. the IO monad's bind operator pretends that World is the same coming from one action as it is going to the next action, but that is not necessarily the case
10:28:49 <___> we would expect getChar world0 == ('x', world1)
10:28:54 <quicksilver> jmcarthur: yes.
10:29:08 <___> if getChar is pre-empted, that may not be the case.
10:29:09 <quicksilver> including getChar in World is harder than IORef.
10:29:09 <conal> int-e: the program is that World -> (World,a) *does* express linearity.  that's why it doesn't work for concurrency.
10:29:15 <jmcarthur> ... which i think is the same as saying that IO has no semantics ;)
10:29:29 <quicksilver> to include getChar in World you have to "fix all future input"
10:29:44 <quicksilver> i.e. the initial World has to "know" all the input, forever.
10:29:50 <quicksilver> but that's not totally absurd, for a semantics.
10:29:57 <quicksilver> (it's like the stream model of IO)
10:30:08 <quicksilver> putChar is no problem at all.
10:30:16 <quicksilver> that's just appending to an outpulist embedded in World.
10:30:32 <quicksilver> World works fine for those fragments of IO which have obvious, simple semantics :)
10:30:55 <int-e> conal: Well my mental model of World is non-deterministic. And in that model World -> (World, a) is a convenient lie, and it only works because it's used linearly.
10:31:22 <conal> int-e: can you explain the meaning of sequential composition in that semantics?
10:31:40 <conal> int-e: when concurrency is allowed?
10:32:23 <c_wraith> You could argue that World has multiple data streams, and that concurrency is just a mechanism to access additional streams.
10:32:27 <int-e> conal: Anything can happen. There are views World (like IORef operations) that are a little bit more well-behaved. So, no, I can't.
10:32:48 <int-e> views *of the* world
10:33:07 <conal> c_wraith: and different threads are somehow prevented from influenceing each other?
10:33:10 <pao> @src group
10:33:13 <lambdabot> group = groupBy (==)
10:33:20 <pao> @src groupBy
10:33:20 <lambdabot> groupBy _  []       =  []
10:33:21 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
10:33:21 <lambdabot>     where (ys,zs) = span (eq x) xs
10:33:24 <jmcarthur> (>>=) :: (World, a) -> (a -> (World', b)) -> (World', b) -- more correct type for IO's bind
10:33:48 <jmcarthur> well...
10:33:52 <jmcarthur> i just messed that up
10:34:00 <quicksilver> int-e: "anything can happen" is not a semantics.
10:34:00 <conal> jmcarthur: even (>>) is problematic.
10:34:15 <quicksilver> int-e: if we say "IO has a semantics as World -> (World,a)"
10:34:20 <quicksilver> we mean in a very concrete way
10:34:29 <quicksilver> there actually exists a set "World"
10:34:29 <conal> quicksilver: i'd say it is a semantics.  just not a useful one.
10:34:29 <int-e> quicksilver: I said that is a convenient lie.
10:34:32 <int-e> quicksilver: so I already admitted that point.
10:34:37 <quicksilver> and every IO action actually is a function
10:34:44 <quicksilver> an ordinary, set-theoretic function
10:34:46 <c_wraith> conal: I don't really think that matters.  muxing input and demuxing output are implementation-dependent.
10:34:53 <quicksilver> which actually takes concrete members of the set "World"
10:35:00 <quicksilver> to other members of the set "World"
10:35:03 <quicksilver> (plus their result)
10:35:06 <edwardk> is the implicit configuration pearl from oleg and shan in hackage anywhere?
10:35:13 <quicksilver> that's what a smenatics is.
10:35:20 <quicksilver> it's a real interpretation in a real mathematical model.
10:35:28 * edwardk just found himself needing it for a couple of scary monoids
10:35:31 <quicksilver> that -> is a *real* arrow of set theory
10:35:31 <int-e> quicksilver: if we follow that path, we'll get into a free will discussion.
10:35:34 <conal> c_wraith: interference is exactly why the simple imperative semantics doesn't work in the presence of (a) sequential composition and (b) concurrency.
10:35:40 <quicksilver> (or category theory if that's your boat)
10:35:49 <quicksilver> int-e: I don't think so. There's no free will in mathematics.
10:35:59 <quicksilver> mathematics is a set of axioms, and it's what we can prove from them.
10:36:06 <quicksilver> semantics is a very concrete notion.
10:36:13 <quicksilver> it's not philosophical or abstract.
10:36:32 <conal> (as dr spaceman says "science is whatever we want it to be")
10:36:33 <___> just read "Tackling the The Awkward Squad."  That's pretty much my only exposure I've had with operational semantics, and it was very enlightening.
10:36:35 <guenni> what do I need to read in order to understand this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2912#a2912
10:36:59 <quicksilver> ___: to be clear, I'm talking abotu denotational not operational here.
10:37:28 <conal> operational semantics always leaves me unsatisfied.  like reading a C program.  i see gears turning but i don't get a sense of what anything means/is.
10:38:14 <quicksilver> conal: that's by design. It's not about what things mean, it's about how they work.
10:38:26 <conal> quicksilver: yep.
10:38:26 <quicksilver> conal: (...about one possible way they might be constructed to work)
10:39:02 <conal> i guess i mostly don't care how something works until i relate to what it means.
10:39:12 <conal> means/is.
10:39:14 <jmcarthur> ___ has to be the coolest nick I've seen in a while.
10:39:39 <pao> jmcarthur: _|_ would be even nicer :-)
10:39:49 <vixey> owg I hate twitter
10:39:50 <_|_> sweet!
10:39:50 <___> already registered, though.  Not used in almost a year.
10:40:01 <pao> _|_: you rulez :-)
10:40:11 <___> your bottom is showing
10:40:11 <quicksilver> RT: @vixey owg I hate twitter
10:40:15 <_|_> do nicks expire on freenode?
10:40:18 <lament> ___ is dirty, the only word i know that fills that blank is a swearword
10:40:25 <quicksilver> you have to ask a staffer to expire the nick.
10:40:35 <quicksilver> they will generally do so if it's not been used for over a year
10:40:40 <c_wraith> I'm pretty sure nicks don't expire.  I registered this one a couple years ago, and forgot the password.
10:40:51 <quicksilver> they only get expired on request
10:40:58 * _|_ considers asking about it
10:40:59 <quicksilver> not automatically.
10:41:08 <c_wraith> ah, ok.  maybe I should ask
10:41:19 <jmcarthur> nah i don't care enough
10:41:22 <quicksilver> more info in #freenode
10:41:44 <Eridius> they get expired on request, but if it hasn't been used in almost a year it's long past the expiration time, so said request would be granted
10:42:15 <c_wraith> 2 years, 42 weeks...  almost 3 years.
10:46:34 <___> @quote
10:46:34 <lambdabot> b7j0c says: the haskell community should take out life insurance on dons
10:47:00 <vixey> @quote
10:47:00 <lambdabot> ari says: The problem I have with grues is that although I know that currently, if it is very dark I am likely to be eaten by one... but how can I tell if grue suddenly became benign at, say, the
10:47:00 <lambdabot> year 2010? The evidence I've gathered so far can't support the idea that that *wouldn't* happen.~
10:49:24 <jmcarthur> I've got it: RealWorld is a Behavior that happens to be dependent (albeit, not solely) on an Event Action, where those actions are dependent on snapshots of RealWorld.
10:51:53 <jmcarthur> lunch time
10:52:05 <conal> jmcarthur: now eliminate the Action part.
10:52:48 <jmcarthur> conal: I'm just modeling the IO monad on FRP, not necessarily making *good* semantics.
10:53:28 <conal> jmcarthur: i do see *continuous* RealWorld as a solution to the semantic mess.
10:53:47 <jmcarthur> yes
10:54:07 <jeffersonheard> still no luck figuring out who runs MONAD on HiveFire... :-(   Seems to be an aggregator of some kind
10:54:08 <conal> it squeezes out interleaving, which was is problem with concurrency and the simple imperative semantics.
10:54:26 <conal> *was the problem*
10:54:59 <roconnor> @wiki IO_Semantics
10:55:00 <lambdabot> http://www.haskell.org/haskellwiki/IO_Semantics
10:57:15 <Frederick[SE]> @ty: readFile
10:57:15 <lambdabot> Maybe you meant: thx type
10:57:27 <Frederick[SE]> thx readFile
10:57:33 <___> @ty readFile
10:57:36 <lambdabot> FilePath -> IO String
10:58:41 <Frederick[SE]> thanks ___
11:00:00 <___> @thx
11:00:00 <lambdabot> you are welcome
11:01:10 <hallongrottan> @hoogle unsafeInterleaveIO
11:01:11 <lambdabot> System.IO.Unsafe unsafeInterleaveIO :: IO a -> IO a
11:01:16 <hallongrottan> hehe
11:02:19 <alexsuraci> > print "Hello, irssi theme tester."
11:02:21 <lambdabot>   * Exception: "<IO ()>"
11:02:25 <alexsuraci> good enough
11:19:43 <roconnor> > let f = evalState . mapM (State . splitAt) in f [1,2,3] [1..]
11:19:44 <lambdabot>   [[1],[2,3],[4,5,6]]
11:20:16 <roconnor> > let f = evalState . mapM (State . splitAt) in f (repeat 1) [1..]
11:20:19 <lambdabot>   [[1],[2],[3],[4],[5],[6],[7],[8],[9],[10],[11],[12],[13],[14],[15],[16],[17...
11:20:44 <Eridius> hrm, that second one looks like a very fancy way of saying map (:[]) [1..]
11:20:49 <Eridius> >map (:[]) [1..]
11:20:51 <Eridius> > map (:[]) [1..]
11:20:54 <lambdabot>   [[1],[2],[3],[4],[5],[6],[7],[8],[9],[10],[11],[12],[13],[14],[15],[16],[17...
11:21:06 <roconnor> > let f = evalState . mapM (State . splitAt) in head . last $ f (take 1000 $ [3,3..]) [1..10^6]
11:21:06 <lambdabot>   2998
11:21:35 <roconnor> what's wrong with partitionsTooFrickinClever ?
11:21:48 <roconnor> oh wait
11:22:04 <roconnor> > let f = evalState . mapM (State . splitAt) in head . last $ f (repeat 3) [1..10^6]
11:22:34 <lambdabot>   mueval: Prelude.read: no parse
11:22:49 <Eridius> last? o_O
11:23:03 <lilac> @@ @type id :: @type unsafeInterleaveIO
11:23:08 <lambdabot>  parse error on input `in'
11:23:24 <___> @let partitions = evalState . mapM (State . splitAt)
11:23:27 <lambdabot>  Defined.
11:23:35 <___> > partitions (cycle [1,2,3]) [1..]
11:23:39 <lambdabot>   [[1],[2,3],[4,5,6],[7],[8,9],[10,11,12],[13],[14,15],[16,17,18],[19],[20,21...
11:24:47 <Eridius> clever
11:25:07 <___> not terrifically.
11:25:18 <___> @type splitAt
11:25:21 <lambdabot> forall a. Int -> [a] -> ([a], [a])
11:25:21 <mmorrow> this is neat. oleg's doubly-linked list from the wiki, and a heap graph showing its structure: http://moonpatio.com/vacuum/dlist.html
11:25:21 * Eridius isn't used to thinking about State as a way of folding over a list yet
11:25:35 <lilac> ___: that's pretty neat :)
11:25:49 <___> not my work, it was in haskell-cafe
11:26:12 <mmorrow> lilac: i'm thinking up some sort of gallery with the theme on that page
11:26:34 <___> the fst's are the result of each action, and the snd's are propagated to the next action
11:27:17 <mmorrow> that image's .dot was generated with:
11:27:22 <mmorrow> ghci> (writeFile "dlist.dot" . render . ppDot . nameGraph . vacuum) (dlist [0..5])
11:27:35 <lilac> ___: indeed. after a moment staring I can see how it works. it's a /really/ nice way of writing it
11:28:00 <mmorrow> yeah, it's so much cooler now that i can see the links
11:28:25 <mmorrow> letrec++
11:30:04 <lilac> mmorrow: very cool indeed. is this the 'vacuum' people were playing with on lunabot the other day?
11:30:22 <mmorrow> lilac: exactly. i just put it up on hackage a few hours ago
11:30:55 <mmorrow> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/vacuum-0.0.1
11:31:32 <lilac> i'ma get me one of those :)
11:31:33 <mmorrow> :)
11:31:33 <Eridius> vacuum? o_O
11:31:34 <mmorrow> (it's way fun.. addicting even)
11:31:53 <roconnor> god damn mapM
11:31:56 <mmorrow> Eridius: it walks ghc's heap and sucks out the graph a value is represented by
11:32:06 <Eridius> wacky
11:33:13 <___> map is sequence . map (ignoring the function arities)
11:33:21 <___> It's the sequence that's the hard part
11:33:35 <Eridius> you mean mapM
11:33:44 <___> right, mapM*
11:33:47 <Eridius> @src mapM
11:33:47 <lambdabot> mapM f as = sequence (map f as)
11:33:54 <Eridius> @pl \f as -> sequence (map f as)
11:33:54 <lambdabot> (sequence .) . map
11:34:53 <mmorrow> here're the vacuum haddocks since they don't seem to be built yet on hackage http://moonpatio.com/vacuum/haddocks/
11:35:07 <hallongrottan> @pl getKeys w >>= \ks -> return (Nothing:ks)
11:35:07 <lambdabot> (Nothing :) `fmap` getKeys w
11:35:53 <hallongrottan> @pl getKeys w >>= \ks -> return (Just k:ks)
11:35:54 <lambdabot> (Just k :) `fmap` getKeys w
11:35:57 <hallongrottan> hmm
11:36:02 <hallongrottan> should have figured that out
11:36:22 <Eridius> @pl \f g x -> g (f x )
11:36:22 * Eridius pokes lambdabot
11:36:22 * Eridius pokes IRC... hello? are you working?
11:36:25 <lambdabot> flip (.)
11:36:41 <mmorrow> haha, i just realized there's a "__" here
11:36:47 <Eridius> there was a _|_ earlier
11:36:52 <mmorrow> i was really confused for a good 20 seconds
11:36:56 <___> who?  I'm ___, not __
11:37:03 <___> :P
11:37:12 <mmorrow> i can't believe that nick's not taken
11:37:25 <___> it is.  seems abandoned, though
11:37:37 <___> I'm doppleganging
11:38:06 <mmorrow> hmm, 4 _'s is invalid
11:38:19 <Badger> probably for timeouts
11:38:23 <vixey> I want to be confused too
11:38:59 <___> vixey: /nick confused
11:39:14 <Eridius> whoa, seriously? (let a = (a+1) in a) not only spikes to 100% CPU but also sucks up all my memory?
11:39:43 <mauke> did you compile with -O2?
11:39:50 <Eridius> no, I tested with ghci
11:40:03 <mauke> oh, that's ok then
11:40:09 * Eridius hates how ghci doesn't interrupt computations when you type ^C
11:40:26 <solidsnack> {-# LANGUAGE BottomBurnsUpComputer #-}
11:40:32 <glguy> I think that ^C only works during allocation
11:40:32 <Eridius> heh
11:40:49 <Eridius> ghci should be smart enough to always pay attention to ^C. Other language CLI interpreters do
11:41:06 <vixey> yeah it would be nice if you could set a mode where ^C actually halts the thing
11:41:08 <vixey> I don't care what it does on compiled programs
11:41:22 <vixey> but when you test things out it's really painful
11:41:29 <vixey> setting heap and stack limits don't seem to help
11:41:39 * Eridius hates opening a new console and typing 'killall ghc' while the entire system is swapping
11:41:48 <glguy> Eridius, use ^Z
11:41:48 <mauke> Eridius: ^Z
11:41:51 <glguy> and then you can kill %1
11:41:57 <glguy> kill -9 %1 if needed
11:42:03 <Eridius> ooh, didn't occur to me that ^Z would work on ghci, but of course it makes sense
11:42:08 <mmorrow> heh, gcc compiles this (w/ -O3) "main(){int x = 0; while(1) x++;}" to:
11:42:19 <mmorrow> .L2:
11:42:19 <mmorrow> 	jmp	.L2
11:42:24 <vixey> nice
11:42:28 <vixey> I can read that :p
11:42:45 <mauke> I'm not impressed
11:42:52 <wjt> mmorrow: ISTR gcc -O3 compiles this: "main() {int x = 0; while (x >= 0) x++;}" to an infinite loop
11:42:55 <vixey> mauke you have really high standards
11:42:56 <Eridius> mmorrow: it's just throiwng out the dead store
11:43:01 <mauke> I wrote an interpreter that compiled infinite loops to sleep(~0u)
11:43:01 <Eridius> *throwing
11:43:14 <mmorrow> wjt: heh
11:43:18 <mmorrow> mauke: lol
11:43:23 <wjt> mmorrow: so TBH all bets are off
11:43:49 <vixey> mmorrow: Do you know how to write this  jmp  stuff by hand?
11:43:50 <mmorrow> wjt: i guess wrapping isn't considered a valid consideration
11:43:55 <___> "jmp stuff"?  You mean assembly?
11:43:55 <wjt> mmorrow: i guess it's a bug :)
11:44:00 <vixey> ___, yes
11:44:16 <Cale> Eridius: If ^Z doesn't work for some reason, try just closing the terminal window, provided it's not running in a screen session or something.
11:44:23 <mauke> wjt: the bug is in the program
11:44:26 <mauke> gcc is doing it right
11:44:30 <___> assemblies languages aren't too difficult to learn, just difficult to write useful things in :)
11:44:38 <mmorrow> vixey: i get the general idea, but i only know regs/etc for x86 really
11:44:51 <vixey> I want to write a compiler that turns something easy like scheme into it
11:44:57 <Eridius> Cale: I don't think that saves much over ⌘N killall ghc ↩
11:44:57 <Badger> http://menuetos.net
11:44:59 <Badger> :P
11:45:01 <vixey> how do you do it ?
11:45:03 <wjt> mauke: eh.
11:45:23 <mauke> vixey: here's a brainfuck compiler written in perl: http://mauke.ath.cx/stuff/perl/bfc.pl :-)
11:45:33 <Cale> Eridius: Well, if your system is swapping starting new processes might be slow.
11:45:59 <ziman> wellformed $src or die "?\n"; :)
11:46:01 <Cale> Eridius: (if it's near the point where things are going to be OOM-killed)
11:46:03 <Eridius> Cale: true, but closing the window also involves UI interaction because it pops up a sheet warning me that there's a running process and asking if I really want to kill it
11:46:05 <wli> Floating point asm on x86 is painful.
11:46:10 <Cale> Eridius: oh
11:46:18 <Eridius> OOM-killed? Dunno if that happens on OS X. I think it just swaps to death
11:46:53 <Cale> Eridius: Well, eventually memory allocation requests will start getting denied.
11:47:01 <glguy> linux has the same swap-death behavior
11:47:05 <vixey> I think I will try it out for fun
11:47:08 <Eridius> heh
11:47:27 <vixey> Ihmmm
11:47:36 <Cale> (when you run out of swap space)
11:47:55 <blarf> mauke: thats incredibly ugly,my haskell brainfuck compile ri smuch shorter and clearer
11:48:08 <mauke> blarf: but does it generate OISC code?
11:48:11 <vixey> not really haskell ... but I will implement it in Haskell..,  other than these intel docs is there some especially good article/reference about what instructions to put together?
11:48:13 <lilac> linux has controllable behaviour. if you let it overcommit, it'll kill processes when they try to use more memory than is available
11:48:18 <lilac> (it overcommits by default)
11:48:40 <wli> ia64 asm is interesting
11:49:06 <wli> The FPU is prety slick with rotating registers etc.
11:51:33 <___> @quote assembl
11:51:34 <lambdabot> qwe1234 says: the statement that c++ is 'simpler' than assembly is so patently stupid i have doubts that you can program at all.
11:51:39 <bd_> lilac: OTOH, if you disable overcommit, heap allocations start to fail, and most programs will die when that happens anyway, so not much difference...
11:51:48 <bd_> er, start to fail when you run out of memory
11:52:23 <wli> It would've been interesting for Haskell in particular as its register set was massive and it had $gp affairs to make closure environments easy and the whole single assignment from the get-go is a dream for the VLIW bundles.
11:54:12 <wli> No save/restore pain on calls from the register set size; register windowing does it all for you.
11:54:20 <eu-prleu-peupeu> how do i append values to an array ?
11:54:28 <mauke> perldoc -f push
11:54:32 * mauke runs away, cackling madly
11:55:10 <wli> So you can inline to your heart's content and it can take the register pressure and then some (128 registers!).
11:55:20 <___> @doc Data.Array
11:55:21 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array.html
11:55:52 * wli remembers seeing whole statically sized arrays land in registers.
11:55:57 <Mathematics> hey
11:56:09 <Mathematics> can haskell by used for hardware stuff? like if a usb is plugged in?
11:56:46 <___> http://www.haskell.org/ghc/docs/latest/html/libraries/array/Data-Array.html
11:57:19 <___> seems to have moved out of base
11:57:39 <vixey> Is it possible to compile a strict functional language into better code than C?
11:57:45 <vixey> faster/smaller
11:57:50 <vixey> I am unrealistic?
11:58:06 <vixey> gcc
11:58:09 <wli> There was something called SASL of that nature. It was first-order, strict, and pure.
11:58:28 <vixey> I want to try out higher order, stict, typed, pure
11:58:36 <vixey> strict*a
11:59:12 <wli> SASL outcompeted autoparallelizing Fortran and so on.
11:59:19 <vixey> cool
11:59:42 <Mathematics> module LOL where        is that like: :set prompt "LOL"
11:59:42 <Mathematics> ??
12:00:13 <wli> You have to realize, though, that it is a very different story from when you have non-strictness and higher-order functions.
12:00:36 <___> Mathematics: ghci's default prompt lists the loaded modules.
12:01:14 <ksf> http://www.sun.com/products/sunmd/s20/gallery/index.xml?p=1
12:01:17 <ksf> zomg
12:01:36 <stepcut> it seems my GHCi  (6.10.1)  can't parse input at the command prompt that is longer than 275 characters, anyone else have this problem?
12:01:48 <ksf> imagine using `par` on one of those
12:03:05 <int-e> stepcut: not me. what's your OS?
12:03:22 <stepcut> int-e: ubuntu hardy
12:03:43 <stepcut> int-e: I suspect this is related to GHCi not using readline anymore
12:03:51 <BMeph_> wli: Have the Clean crew stopped using SASL?
12:04:15 <solidsnack> ksf: It's actually a colo, not a computer.
12:04:34 <wli> BMeph_: I had no idea that they ever used it, or that it had any currency outside a particular system.
12:05:18 <int-e> stepcut: I haven't experienced such a problem with libedit either.
12:05:37 <stepcut> int-e: ok, thanks.
12:05:50 <wli> Back in those days, languages, architectures, and OS's were all made from the ground up by each vendor.
12:06:14 <int-e> (neither libedit-20050930 and nor -20090111.3.0)
12:06:38 <stepcut> int-e: seems to only happen if GHCi is running in emacs
12:10:35 <mmorrow> vixey: one thing that i've found particularly useful is to write mini strategically-constructed C programs, then gcc -O3 (-fomit-frame-pointer) -S foo.c && less foo.s
12:10:46 <mmorrow> where useful := instructive
12:10:58 * vixey nod
12:13:49 <BMeph_> wli: Oops, don't mind me, the Clean guys use SAPL, not SASL. I feel silly. :)
12:16:08 <blarf> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2915#a2918 <- C is a bunch of tards, can someone explain why the insert doesnt work in that (very naive) hashtable implementation?
12:17:47 <mauke> blarf: #haskell-blah
12:21:04 <RayNbow> > partitions [1..] [1..10]
12:21:06 <lambdabot>   [[1],[2,3],[4,5,6],[7,8,9,10],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],...
12:21:19 <Badger> @src partitions
12:21:20 <lambdabot> Source not found. Wrong!  You cheating scum!
12:21:32 <RayNbow> <___> @let partitions = evalState . mapM (State . splitAt)  -- <-- an additional takeWhile (not.null) might be nice
12:23:02 <skorpan> @src ($)
12:23:02 <lambdabot> f $ x = f x
12:23:27 <tromp> @src id
12:23:29 <lambdabot> id x = x
12:23:54 <skorpan> @pl \xs -> trace ("Failed: " ++ (show $ any hasFailed xs)) . few (stroker . tokenToStroke) xs
12:23:54 <lambdabot> ap ((.) . trace . ("Failed: " ++) . show . any hasFailed) (few (stroker . tokenToStroke))
12:24:03 <skorpan> pointless indeed
12:29:30 <Eridius> interesting that lambdabot doesn't use the common `infix` form of ap
12:32:42 <conal> Eridius: <*> ?
12:33:40 <arjanb> Eridius: i think pl was written before Applicative
12:34:11 <conal> and now it may be perpetuating non-Applicative style.
12:34:16 <Eridius> true
12:34:22 <conal> unnecessarily-monadic style
12:34:34 * Eridius has never used ap
12:34:47 <Eridius> of course, my only real use of <*> to date has been playing around with parsec in relation to RWH
12:35:09 <conal> does RWH teach parsec via Applicative?
12:35:14 <wli> ap is crap; I take the time to find some other pointfree expression by hand to eliminate it.
12:35:45 <conal> ap is crap; return is to spurn
12:36:11 <conal> (needs work)
12:37:58 <wli> conal: Anyway, you can extend your differential ring by any transcendental function satisfying a diffeq of the form t' = p(t) for a polynomial p with coefs in the un-extended ring. Things like sn(x,k) with (t')^2=(1-t^2)*(1-k^2*t^2) are ordinary differential polynomial extensions and involve algebraic differential equations/manifolds/etc.
12:38:39 <Peaker> conal: It could also help if someone gives a name to liftA2 (flip const)  (>> in Applicative)
12:38:47 <Peaker> (eliminating another Monadic use)
12:38:52 <wli> conal: Anything beyond t'=p(t) for polynomial p seems to lack googlable computational methods.
12:39:15 <___> isn't (*>) the Applicative name for (>>)?
12:39:16 <conal> wli: wowzers
12:39:37 <conal> i keep thinking of ___ as an invisible/disembodied person.
12:39:37 <Peaker> ___: who are you? :)
12:39:50 <Peaker> @hoogle Applicative f => f a -> f b -> f b
12:39:51 <lambdabot> Control.Applicative (*>) :: Applicative f => f a -> f b -> f b
12:39:51 <lambdabot> Control.Applicative (<*) :: Applicative f => f a -> f b -> f a
12:39:51 <lambdabot> Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
12:40:11 <Peaker> oh, yeah, then I guess it only lacks some use, then :)
12:40:13 <___> :)
12:40:32 <wli> conal: The idea here is that the expressions/etc. can be dealt with in a manner suitable for zero testing, canonicalization, etc.
12:40:34 <conal> now that one looks like a smiling caterpillar
12:40:55 <conal> wli: blog!
12:42:25 <wli> What am I going to say? I found background material on the web that helped me decipher more of a Bronstein paper?
12:43:14 <conal> wli: sure.  with code and example uses.
12:43:48 <wli> conal: I'm not really getting anywhere with the code, so there's nothing to post.
12:44:11 <conal> i just wrote "blog" in my code where i meant "const".  i guess i don't multi-task very well.
12:45:30 <eu-prleu-peupeu> how do i generate a list like the following gen i p = [(i, 0),   (i - 1, 1),(i, 1),   (i - 2, 2),(i - 1, 2),(i, 2), ..  (i - p, p),..(i,p)] ?
12:45:32 * ___ also suffers from thought-to-keyboard race conditions from time to time
12:46:14 <eu-prleu-peupeu> im trying out with list comprehensions but i lack the haskle skillz
12:46:52 <BMeph_> eu-prleu-peupeu: You mean "HaskillZ". ;p
12:46:55 <jatqceer> Can someone give me a hint how to write a function that does "MonadError m => Array Int (m x) -> m (Array Int x)" ?
12:46:59 <eu-prleu-peupeu> :)
12:47:25 <jatqceer> without converting the array into list?
12:47:45 <BMeph_> jatqceer: Hint 1: Change your first Array into a list. :)
12:47:49 <BMeph_> D'Oh!
12:48:19 <jatqceer> right, it's just too slow to change into a list
12:48:37 <jatqceer> and convert the list back to array
12:49:34 <jatqceer> i guess i need to write explicit recursion
12:49:52 <Saizan> jatqceer: Array is immutable, so you need to contruct a new one anyway
12:50:12 <wli> There is thawing.
12:50:34 <BMeph_> jatqceer: NM, just use Data.Traversable.sequence, since (Array Int) is Traversable. :)
12:51:15 <jatqceer> I see
12:51:27 <jatqceer> how efficient is that?
12:53:24 <ksf> I want to write a function consume :: ([a] -> b) -> [a] -> ([a],b) , where the resulting [a] is the part of the original [a] that wasn't consumed.
12:53:25 <ksf> any ideas?
12:53:41 <tomik> hi, i have a newbie question: in type definition: 'data Tree a = Nil | Node a (Tree a) (Tree a)' i want to enforce the type parameter 'a' to be of class Ord ( so i don't have to specifiy that in every function working with the tree). Is that possible ?
12:53:56 <mauke> tomik: no
12:53:57 <pumpkin> ksf: how would the function report how much it consumed?
12:53:58 <ksf> (please don't tell me to use iteratees, that's what i'm trying to get rid of)
12:53:59 <jmcarthur> ksf: not enough information there
12:54:17 <ksf> well, replace [] with whatever you want.
12:54:18 <vixey> tomik: in what function?
12:54:29 <eu-prleu-peupeu> let gen i p = [(s,n) | s <- [i..i-n], n <- [0..p]]
12:54:46 <jmcarthur> ksf: the function argument needs to be ([a] -> ([a],b)) for that to be possible, i think
12:54:59 <eu-prleu-peupeu> it complains about n not being in skope, also i can't seem to be able to generate a descending list :/
12:55:04 <jmcarthur> in which case consume is just id :\
12:55:07 <jatqceer> BMeph_: traverse f arr = listArray (bounds arr) `fmap` traverse f (elems arr)
12:55:19 <jatqceer> so its the same list thing
12:55:22 <tomik> for instance i have simple function member:: Ord a => Tree a -> a -> Bool expressing whether given element is in the tree - the thing is that it is a bin tree and so the ordering is enforced on it's members
12:55:34 <wli> unfoldr maxView
12:55:41 <ksf> my intuition tells me that it's possible to do without iteratee-style continuations and passing the tail back from the consumer, but i failed actually implementing it.
12:56:08 <___> eu: list comp bindings scope over the remainder of the comp, swap s <- ... with n <- ...
12:56:25 <___> to count down, add a step
12:56:31 <___> > [10..1]
12:56:33 <lambdabot>   []
12:56:35 <jmcarthur> @djinn (Maybe a -> b) -> Maybe a -> (Maybe a, b) -- will not be anything like what you want, but is all that's possible
12:56:35 <lambdabot> Cannot parse command
12:56:36 <pumpkin> ksf: intuitively to me, it seems that the only place to get the [a] you want to return in the tuple is the input (so you'd basically have id &&& something
12:56:36 <___> > [10, 9 .. 1]
12:56:38 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
12:56:41 <eu-prleu-peupeu> ah nice
12:56:41 <eu-prleu-peupeu> :)
12:56:42 <jmcarthur> @djinn (Maybe a -> b) -> Maybe a -> (Maybe a, b)
12:56:42 <lambdabot> f a b =
12:56:42 <lambdabot>     case b of
12:56:42 <lambdabot>     Nothing -> (Nothing, a Nothing)
12:56:42 <lambdabot>     Just c -> (Nothing, a (Just c))
12:56:52 <eu-prleu-peupeu> thanks anonymous
12:56:55 <jmcarthur> okay, there are two ways to do that, oh well
12:57:22 <jmcarthur> ksf: either way, the same thing with lists will look very similar for that type
12:57:42 <ksf> http://hackage.haskell.org/packages/archive/iteratee/0.1.0/doc/html/Data-Iteratee-Base.html#v%3AconvStream
12:58:58 <eu-prleu-peupeu> amazing!
12:59:04 <eu-prleu-peupeu> let gen i p = [(s,n) | n <- [0..p], s <- [i-n .. i]]  this works :D
12:59:11 <eu-prleu-peupeu> i feel my haskillz have improved
12:59:12 <ksf> strteam-fusion like pipelines should have the info necessary, but that coding style makes my head hurt, strangely enough worse than oleg's continuations.
12:59:48 <jmcarthur> ksf: i don't _really_ see what it is you want
13:00:11 <jmcarthur> [a] -> b will never be able to tell you how much of [a] it actually used
13:00:19 <eu-prleu-peupeu> on day ill be able to write lots of crazy blog posts about haskle
13:00:30 <ksf> sure, as it has to consume stuff to use it.
13:00:53 <jmcarthur> ksf: no function _of that type_ can tell you how much it used
13:00:56 <pumpkin> consume?
13:01:01 <ksf> I'm not arguing that it's possible with the standard list type.
13:01:07 <pumpkin> ah
13:01:40 <pumpkin> ([a] -> ([a], b)) -> [a] -> ([a],b) ;)
13:01:44 <jmcarthur> ksf: i think you will end up just reimplementing iteratee
13:01:46 <pumpkin> nice and easy ;)
13:01:50 <jmcarthur> pumpkin: id ;)
13:01:53 <pumpkin> I know :P
13:02:13 <jmcarthur> pumpkin: i know you know, and i know you know i know you know, etc...
13:02:15 <pumpkin> omg
13:02:18 <ksf> you see, to do such a thing with e.g. parsec, you have to actually use two full-blown parsers.
13:02:21 <pumpkin> now I know that you know all that
13:02:29 <ksf> ...converting a stream, that is.
13:02:41 <jmcarthur> ksf: what?
13:03:18 <ksf> like, converting String to [Token] to [AST] to [whatever]
13:04:11 <jmcarthur> there's only one parser in there...
13:04:17 <ksf> the idea is to make a zero-lookahead parser part of something resembling vanilla lists.
13:04:45 <ksf> you _can_ do it in one, but it's dirty, and if you do eg. layout rules, masochistic.
13:05:02 <jmcarthur> String -> [Token] is lexing, not parsing
13:05:34 <jmcarthur> well, i guess it could be parsing from some point of view
13:05:54 <jmcarthur> i'll bite, at least
13:07:17 <jmcarthur> i'm actually not sure if adding layout rules to the mix makes lexing more like parsing anyway
13:07:18 <ksf> ...anyway, the point is that "1 >= 2" lexes to "1", " ", ">=", " ", "2", and you don't want to trust every individual lexer to return the part of the string it hasn't consumed.
13:07:46 <jmcarthur> you don't?
13:08:21 <ksf> well, as i tried layout rules, state quickly became so complex that it fried my brain, not to mention that i stumbled across a nasty parsec misfeature involving eof.
13:09:11 <jmcarthur> i've never done layout rules before
13:09:14 <ksf> one could also say: as a programmer, you're too lazy to do by hand what
13:09:22 <ksf> ...the pc can do for you.
13:10:20 <jmcarthur> so you're saying you don't want the lexer to return the unconsumed string, but you want to be able to get it magically?
13:10:46 <ksf> i want the enumerator to keep track of how much the iteratee consumes, yes.
13:10:46 <jmcarthur> sorry, i don't mean to sound rude there
13:11:44 <jmcarthur> and you're not using oleg's iteratee?
13:12:14 <ksf> iteratees are the reason i'm trying to figure out how to do it without them.
13:12:15 <pumpkin> doesn't iteratee just give you the same amount of information as [a] -> ([a], b) ?
13:12:19 <jmcarthur> rather, you are coming up with your own way iteratee library?
13:12:41 <jmcarthur> pumpkin: yeah, that's what i'm getting at. it seems like ksf is doomed to reimplementing it
13:13:06 <ksf> ngargh. I'm just trying to do it without continuations.
13:13:10 <pumpkin> all it's really doing is going through chunk of the list and saying Continue | Stop isn't it?
13:13:27 <jmcarthur> OH
13:13:31 <earthy> pumpkin: slightly more than that
13:13:31 <ksf> kinda, but it's saying Continue (withThisFunction)
13:13:37 <pumpkin> yeah
13:14:17 <pumpkin> I was oversimplifying, but the point was that you need a function that says where it stopped, or an iteratee-like mechanism that includes a "Stop" step
13:15:10 <ksf> ...whereas i believe you can somehow count the yield's a stream-fusion stage is forcing and work from there.
13:15:36 <jeffersonheard> I may be evil...  I just defined a "reverse skipping bind operator" a =<<^ b, which is basically \m -> b >> a m
13:15:41 <jeffersonheard> that's unreadable as hell.
13:15:56 <jmcarthur> @pl \m -> b >> a m
13:15:57 <lambdabot> (b >>) . a
13:16:37 <jmcarthur> :t \m -> b >> a m
13:16:38 <lambdabot>     Couldn't match expected type `m a' against inferred type `Expr'
13:16:38 <lambdabot>     In the first argument of `(>>)', namely `b'
13:16:38 <lambdabot>     In the expression: b >> a m
13:17:18 <jmcarthur> :t \a b m -> b >> a m
13:17:20 <lambdabot> forall t (m :: * -> *) a b. (Monad m) => (t -> m b) -> m a -> t -> m b
13:17:30 <jeffersonheard> typo, sorry
13:17:34 <jeffersonheard> jmcarthur has it
13:17:40 <jmcarthur> @pl \a b m -> b >> a m
13:17:41 <lambdabot> flip ((.) . (>>))
13:18:31 <jeffersonheard> suppose that's slightly more readable than the way I defined it.
13:20:26 <jmcarthur> :t \a b m -> m a << b
13:20:27 <lambdabot> Not in scope: `<<'
13:20:39 <dons> mmorrow: are you going to announce vacuum...
13:20:43 <dons> looks *very* interesting
13:20:45 <___> @src (<*)
13:20:45 <lambdabot> (<*) = liftA2 const
13:21:03 <jmcarthur> :t (<*)
13:21:05 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
13:21:50 <jmcarthur> :t \a b m -> a m <* b
13:21:53 <lambdabot> forall t (f :: * -> *) a b. (Applicative f) => (t -> f a) -> f b -> t -> f a
13:22:02 <jmcarthur> thanks ___
13:22:09 <___> (<*) is decidedly _not_ flip (*>)
13:22:24 <jmcarthur> jeffersonheard: ^^
13:22:49 <jmcarthur> :t (*>)
13:22:50 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
13:23:23 <jeffersonheard> jmcarthur, is that an operator or a smiley face?
13:23:31 <jeffersonheard> :t (^^)
13:23:33 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
13:23:36 <jmcarthur> jeffersonheard: look in Control.Applicative
13:23:45 <jeffersonheard> oh right!
13:24:38 <jmcarthur> @check \xs ys -> ((xs :: [Int]) *> (ys :: [Int])) == (xs >> ys)
13:24:40 <lambdabot>   "OK, passed 500 tests."
13:26:17 <jmcarthur> jeffersonheard: oh you were referring to when I said "^^"... i was pointing upward :P
13:31:33 <pumpkin> c_wraith: :o
13:31:53 <ITX> how do i do a comment in haskell?
13:32:44 <Debugger> {- No idea.... -}
13:33:01 <Debugger> {- Can't you use google? -}
13:33:04 <mauke> -- no comment
13:34:08 <Botje> -- this is not a comment
13:34:46 <Debugger> -- Pfff Comments are for pussies
13:34:49 <ITX> no actually, i cant not at this moment of time, internet is going too slow so pages dont load, only this and msn will run
13:35:21 <___> -- ceci n'est pas un commentaire.
13:35:38 <jeffersonheard> oh right.  I guess that is the same thing...
13:39:41 <ITX> sayCheese :: String -> IO()      I thought that would be taking in IO() and outputting a String?
13:40:11 <___> that's not what the type says
13:40:23 <lament> ITX: which way is the arrow pointing?
13:40:29 <ITX> right
13:40:43 <lament> from String, to IO()
13:40:47 <ITX> i mean like, i thought it would be IO() -> String
13:41:02 <ITX> taking in input and outputing String
13:41:09 <___> that would be a strange function indeed
13:41:21 <StoneFix> http://www.youtube.com/watch?v=5kyxEG4XcNI    :lol:   -_-
13:41:24 <ITX> im new i dont really get why its that way around
13:41:38 <___> @where syntax
13:41:39 <lambdabot> http://cs.anu.edu.au/Student/comp1100/haskell/tourofsyntax.html
13:42:02 <StoneFix> it is not comfortable
13:42:11 <lament> ITX: IO() doesn't mean input
13:42:20 <lament> ITX: IO() means an action
13:42:33 <lament> ITX: sayCheese takes a string and returns an action
13:42:41 <ITX> aha i see
13:42:42 <lament> which you can later execute
13:43:09 <ITX> but don't all functions take an action?
13:43:10 <___> presumably that action, when runs, prints your string.
13:43:22 <ITX> like.. getName :: Int -> IO()?
13:43:28 <ITX> *getAge
13:43:31 <lament> ITX: that function takes an integer and returns an action.
13:43:38 <ITX> action being if age < 10 then blah
13:43:42 <lament> just as its type says
13:43:54 <ITX> I mean is that the right way to do it? instead of like Int -> Int or w.e
13:44:02 <lament> what's the right way to do what?
13:44:40 <___> generally you should think in terms of expressions.  Given some inputs passed to a function, it produces a result based on those inputs.
13:45:10 <___> you ought not to involve IO unless it's necessary.
13:45:24 <___> have you looked at any beginning tutorials?
13:45:47 <ITX> so, say I inputted a number and depending on that number said you are + number, would that be an action?
13:46:00 <___> inputting a number is itself an action, yes
13:46:01 <ITX> rather than taking 2 ages and returning the minimum that being Int -> Int?
13:46:23 <___> and the only way to make use of IO actions is to bind them to further IO actions that use their results.
13:46:53 <___> however, you can do the actual meaty logic in ordinary IO-less functions called from you main actions.
13:46:53 <ITX> aha thank you, ill remember IO() NOW
13:47:00 <___> from your*
13:47:44 <ITX> how can i concatenate a print function? e.g. print "your older than 10!" + "lol"
13:47:51 <___> (++)
13:47:52 <pumpkin> *you're
13:47:56 <___> @ty (++)
13:47:57 <lambdabot> forall a. [a] -> [a] -> [a]
13:48:00 <___> @src String
13:48:00 <lambdabot> type String = [Char]
13:48:12 <pumpkin> ___: neat nick
13:48:18 <___> > "abc" ++ "def"
13:48:20 <lambdabot>   "abcdef"
13:48:53 <pumpkin> dons: sorry for being out of touch about uvector + binary and stuff recently... been traveling and haven't had much time to do anything
13:48:56 <sciolizer> ITX: use putStr or putStrLn instead of print if you don't want the string to be quoted
13:49:32 <___> also, put the argument to print in parentheses.  (print "your older than 10!" + "lol") parses to ((print "your older than 10!") + ("lol"))
13:49:34 <ITX> kk thanks, can I get putStrLn to print a var?
13:49:53 <ITX> why parenthesees?
13:49:55 <sciolizer> > let x = "text" in putStrLn x
13:49:57 <lambdabot>   * Exception: "<IO ()>"
13:49:58 <___> you can use putStrLn to put a string, followed by a newline. :)
13:50:01 <mauke> you can't get putStrLn to treat variables differently
13:50:26 <___> @src print
13:50:26 <lambdabot> print x = putStrLn (show x)
13:50:38 <paper_cc> @ty show
13:50:40 <lambdabot> forall a. (Show a) => a -> String
13:50:51 <___> show turns various values into strings
13:52:27 <ITX> sciolizer thanks for the parenthesees bit (: know what they do now
13:53:09 <rovar> is there a mutable Map type library?
13:54:34 <centrinia> rovar, What is a mutable Map?
13:55:18 <pumpkin> rovar: hashtable?
13:55:21 <pumpkin> it lives in IO
13:55:27 <pumpkin> and isn't particularly pretty :P
13:55:33 <rovar> a data structure that maps keys to values... a hashtable in IO is perfect :)
13:55:34 <Baughn> rovar: A mutable version of Map would not actually be any faster, so there's no point
13:55:39 <Cale> rovar: Use Data.Map
13:55:46 <rovar> Baughn: really?
13:56:04 <Baughn> rovar: Well, not asymptotically at least. It's a balanced tree, and the operations are all O(lg n) already.
13:56:16 <Baughn> rovar: A hash table is something else again, but Data.Hashtable kind of sucks
13:56:27 <Cale> rovar: Data.HashTable is not really any faster (in some cases I recall it being slower than Data.Map), has a clunky IO interface, and is much less scalable.
13:56:28 <rovar> it's making a copy of the tree every time I want to add or remove a value that concerns me
13:56:34 <ITX> how do you do "loops" in haskell again? like outputting numbers from x to 50?
13:56:43 <Cale> rovar: Only logarithmically many of the nodes are copied.
13:56:47 <Baughn> rovar: OTOH, we've got all sorts of mutable arrays, and if you want to pretend Data.Map is mutable just stick it in State
13:56:53 <Cale> rovar: That's why it can be done in log time.
13:57:10 <Baughn> rovar: In other words, don't worry about it. ;)
13:57:27 <Cale> rovar: That is, only the path from the root to the affected node -- all the other subtrees are shared.
13:57:36 <rovar> a map isn't an exact fit for what I need.. but it is a starting place.
13:57:37 <Baughn> ITX: That /particular/ loop would be "mapM_ print [1x..50]"
13:57:47 <rovar> basically.. i"m implementing a reliable udp protocol.
13:58:04 <rovar> and I need a short history of messages in case a retry is required
13:58:17 <Baughn> ITX: But, generally, with higher-order functions. That's one of them. If you don't find one that fits you can write a recursive function, and get told a little later that there's a HOF that fits it anyway. ;)
13:58:21 <ITX> why 1x?
13:58:24 <rovar> short as in less than 20.. however, it will be changing *very* frequently
13:58:26 <laz0r> would it make sense to just stick IORefs into a Data.Map to get in-place updates?
13:58:28 <Cale> rovar: Try Data.Map and see if the performance is unsuitable (via profiling) before worrying about using something with an IO interface.
13:58:31 <Baughn> ITX: Oh. Er, [x..50] of course.
13:58:40 <centrinia> rovar, Why don't you use a List?
13:58:45 <luite> dons: do you know why foldlU is different from foldl? foldl (+) 0 [1,2,3] = [0,1,3,6]  , foldlU (+) 0 (toU [1,2,3]) = toU [0,1,3]
13:59:04 <Baughn> laz0r: Yes, but you don't normally /need/ in-place updates
13:59:10 <luite> dons: sorry, make that scanl and scanlU
13:59:33 <iwannalog> Is there a hashtable in monad to have mutable hastable ?
13:59:47 <Baughn> iwannalog: Not "in monad"; there can't be that.
13:59:53 <iwannalog> why ?
14:00:04 <Cale> In any case, people who think it's possible to do a hashtable lookup in constant time are mistaken one way or another anyway. :)
14:00:18 <Baughn> iwannalog: Well, because a lot of monads don't even have a concept of state. I think you're mixing it up with IO.
14:00:29 <Cale> (It takes at least log time to compute any suitable hash)
14:00:39 <iwannalog> Cale: many lies exit in computer science
14:00:43 <ITX> Baughn can I use mapM_ with putStr?
14:00:45 <Baughn> iwannalog: Data.HashTable is in IO. It /should/ be in State too, but.. *shrug*
14:01:01 <___> @ty mapM_
14:01:04 <Heffalump> Baughn: you mean ST
14:01:05 <Baughn> ITX: Check the type. (Yes, but you should be able to answer that yourself pretty easily)
14:01:09 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
14:01:13 <Baughn> Heffalump: That too?
14:01:29 <Heffalump> how would you put it in State without making it non-mutable?
14:01:30 <Baughn> Heffalump: I suppose, MonadIO too
14:01:38 <Heffalump> err no, that's what liftIO is for!
14:01:48 <Baughn> Meh
14:01:54 <ITX> i dont know how to apply it to mapM_
14:01:57 <ITX> *putStr
14:02:01 <Baughn> @type mapM_
14:02:01 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
14:02:04 <Baughn> @type putStr
14:02:06 <lambdabot> String -> IO ()
14:02:14 <Baughn> @type mapM_ putStr
14:02:15 <lambdabot> [String] -> IO ()
14:02:45 <iwannalog> IO Monad is not a garbage can
14:02:57 <Baughn> iwannalog: One might wonder
14:02:57 <Heffalump> iwannalog: tell that to conal
14:03:08 <iwannalog> who is conal ?
14:03:21 <centrinia> Is there a bitbucket monad?
14:03:29 <Baughn> Heffalump: And you're right about State, of course. Hmmph.
14:03:32 <Heffalump> /whois will tell you
14:03:46 <Baughn> Heffalump: But I could do it with a little unsafePerformIO
14:04:23 <whpearson_> @google Conal Elliot
14:04:24 <lambdabot> http://conal.net/
14:04:24 <lambdabot> Title: Conal Elliott's home page
14:04:24 <ITX> I dont know what to put in # -> #
14:04:34 <ITX> iv tried int, [string] IO etc
14:04:37 <conal> (note two "t"s)
14:04:56 * whpearson_ notes
14:05:06 <conal> btw, i think "sin bin" is Simon PJ's term.
14:05:16 <rovar> what I need is a ring buffer
14:05:42 <ITX> mapM_ putStr ([x..50])       have I done that bit wrong? me is thinking I need show in there?
14:05:50 <conal> i think i use it the same way simon did: we toss things in that we don't have clean theory for.
14:05:58 <conal> our "sins".
14:06:11 <TSC> ITX: either some "show"s or use "print" (which is putStrLn + show)
14:06:12 <___> ITX: looks fine to me, provided a definition for x.
14:06:20 <___> er, yeah, and that
14:06:49 <Baughn> ITX: You don't need the parantheses, but the type mismatch should be telling
14:06:57 <Baughn> ITX: Read the error message you get again. :)
14:07:07 <Cale> rovar: Data.Sequence.
14:07:36 <Cale> (possibly)
14:07:41 <pumpkin> rovar: you can make a "circular" list with cycle :P
14:07:46 <ITX> :(
14:07:51 <ITX> what do I put here: loop :: String -> IO()
14:07:59 <pumpkin> rovar: not sure it's very good for insertion though :)
14:08:14 <rovar> hehe
14:08:23 <vixey> ITX: why is everything with IO ? :p
14:08:24 <___> ITX: that's a type annotation.  I don't understand your question.
14:08:32 <Baughn> ITX: Why is it called "loop"?
14:08:46 <ITX> just a name
14:08:52 <pumpkin> @type loop
14:08:53 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowLoop a) => a (b, d) (c, d) -> a b c
14:09:08 <Baughn> pumpkin: ..that's cruel and unusual punishment
14:09:28 * pumpkin feels guilty
14:09:37 <___> @slap pumpkin
14:09:37 <lambdabot> *SMACK*, *SLAM*, take that pumpkin!
14:09:40 <Baughn> @instances ArrowLoop
14:09:41 <lambdabot> (->), Kleisli m
14:09:46 <rovar> can someone explain why Map and Sequence and others are built to hinder partial application?
14:09:51 <ITX> lolzarz :: String -> IO()
14:09:52 <ITX> lolzarz x =
14:09:52 <ITX>   mapM_ putStr show [x..50]
14:09:57 <pumpkin> rovar: you mean the argument orders they use?
14:10:14 <centrinia> rovar, You can use flip. ;)
14:10:15 <___> ITX: you can't count up from a string using [x..y] syntax
14:10:23 <Baughn> rovar: That's what (flip.flip).flip is for
14:10:28 <pumpkin> rovar: people often like to chain them up
14:10:35 <centrinia> :t (flip.flip).flip
14:10:36 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
14:10:49 <ITX> shoyldnt it be Int or Integral or Num?
14:10:57 <rovar> so the API was purposefully designed to let people practice using flip?
14:10:58 <pumpkin> omg seydar
14:11:01 <centrinia> ITX, Try using show. ;)
14:11:02 <centrinia> :t show
14:11:04 <lambdabot> forall a. (Show a) => a -> String
14:11:12 <Baughn> rovar: Yes
14:11:12 <ITX> i have used show
14:11:13 <___> @instances Show
14:11:13 <pumpkin> rovar: nope, it just was catering to a different use case than yours :)
14:11:13 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, ST s a, Sum a, [a]
14:11:15 <seydar> pumpkin: you in H-Town over vaca?
14:11:24 <centrinia> > map show [45..50]
14:11:25 <lambdabot>   ["45","46","47","48","49","50"]
14:11:29 <pumpkin> seydar: I'm actually over in the bay area right now
14:11:35 <Baughn> rovar: Well, this sort of thing is why we have both mapM and forM
14:11:39 <rovar> pumpkin, I'm just trying to discover what that use case is.
14:12:05 <ITX> can someone just correct my code and ill learn from mistaskes :/
14:12:08 <seydar> pumpkin: funny, i thought places outside of the mountains were fictitious
14:12:09 <pumpkin> rovar: which function in particular? there's actually a wiki page about data structure access function parameter orders
14:12:27 <pumpkin> "data structure access function parameter orders" wow
14:12:31 <seydar> is there a way to define a type as either  IO String or IO [Int]?
14:12:48 <Baughn> seydar: ":: IO String"? -_-
14:12:56 <pumpkin> seydar: sure :P Either (IO String) (IO [Int])
14:12:57 <pumpkin> :P
14:12:59 <dibblego> seydar, Either (IO String) (IO [Int])
14:13:02 <centrinia> Either (IO String) (IO [Int]) ?
14:13:05 <seydar> ah! either!
14:13:10 <seydar> that's what i was looking for
14:13:18 <Baughn> IO (Either String [Int])
14:13:22 <seydar> thanks all!
14:13:27 <pumpkin> seydar: might be easier to just do it Baughn's way though
14:13:38 <Baughn> It does a totally different thing, though. :P
14:13:38 <centrinia> Baughn, That is not isomorphic to Either (IO String) (IO [Int])
14:13:55 <seydar> data Either a b = a | b
14:13:55 <Baughn> IO (Either (IO String) (IO [IO Int]))
14:14:00 <seydar> @src Either
14:14:01 <lambdabot> Source not found. Where did you learn to type?
14:14:06 <pumpkin> still, you can do roughly similar things seydar Left a | Right b
14:14:08 * seydar cries
14:14:08 <ITX> http://codepad.org/E3F3WmIZ
14:14:14 <dibblego> data Either a b = Left a | Right b
14:14:19 <seydar> how do i see the soourcecode of Either?
14:14:25 <vixey> you just look
14:14:26 <pumpkin> seydar: you read dibblego's message :)
14:14:31 <dibblego> with your eyeballs ^^
14:14:31 <Baughn> seydar: data Either a = Left a | Right b
14:14:33 <seydar> pumpkin: what's Left and Right for?
14:14:34 <___> or the report.
14:14:37 <seydar> ah
14:14:40 <seydar> i can read
14:14:42 <dibblego> constructors
14:14:42 <seydar> we're good
14:14:43 <Baughn> @type Left 2
14:14:44 <lambdabot> forall t b. (Num t) => Either t b
14:14:59 <pumpkin> seydar: the constructors allow it to determine which "side" you chose
14:15:31 <TSC> ITX: mapM_ takes three arguments, not four
14:15:33 <centrinia> Isn't (Either a b) dual to (a,b) ?
14:15:35 <___> @ty [Left "", Left "abc", Right (0::Int), Left "foo", Right 2398]
14:15:36 <lambdabot> [Either [Char] Int]
14:16:00 <ITX> so can you change my code to work pls
14:16:27 <centrinia> ITX, see what (mapM_ (putStr . show) [1..50]) does.
14:17:49 <ITX> is there suppost to be a dot?
14:17:51 <seydar> grr can someone look this over? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2927#a2927
14:17:59 <centrinia> ITX, yes.
14:18:08 <dibblego> print = putStr . show
14:18:17 <centrinia> The dot is the function composition operator.
14:18:24 <pumpkin> seydar: you need a Right in your return
14:18:37 <ITX> I first need to know what to put in lolzarz :: .. -> ..
14:18:42 <seydar> huh?
14:19:03 <ITX> i changed loop to lozarz ^.^
14:19:16 <pumpkin> seydar: if you're going to use Either, you need to tell it which of the two alternatives you're using, with Left and Right constructors
14:19:17 <seydar> pumpkin: what do you mean
14:19:18 <iwannalog> your function return a string and you use  Either (IO ()) (IO [Int])
14:19:26 <iwannalog> can't be a string
14:19:37 <seydar> yargh, i fixed that up
14:19:42 <pumpkin> seydar: also, your a <- testFunc won't work
14:19:44 <seydar> dumb of me, iwannalog
14:19:52 <pumpkin> because testFunc doesn't return an IO, it returns an Either
14:19:56 <TSC> It also looks like testFunc's type should be "IO ..."
14:20:30 <___> print . show is probably not what you want
14:20:38 <___> print is itself putStrLn . show
14:20:40 <dev31212> nice name, ____
14:20:48 <___> so print . show = putStrLn . show . show
14:20:48 <TSC> Especially with a String
14:21:04 <pumpkin> > putStrLn . show . show . show . show $ "allo allo"
14:21:05 <lambdabot>   * Exception: "<IO ()>"
14:21:10 <pumpkin> > text . show . show . show . show $ "allo allo"
14:21:11 <lambdabot>   "\"\\\"\\\\\\\"allo allo\\\\\\\"\\\"\""
14:22:02 <seydar> ok all: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2927#a2928
14:22:30 <pumpkin> seydar: that should compile (at first glance) but do nothing
14:22:39 <pumpkin> oh actually, it'll print hello
14:22:41 <___> [1,2,3,4,5] :: [Int], so Right [1,2,3,4,5] :: Either a [Int]
14:22:52 <centrinia> seydar, You probably would want to have type Object = IO (Either () [Int])
14:22:54 <___> not Either a (IO [Int])
14:22:58 <pumpkin> ah
14:23:38 <seydar> YES it compiles
14:23:48 <centrinia> I don't think that (IO a) is an instance of Show.
14:23:53 <pumpkin> IO (Either (IO ...) (IO ...)) looks quite unlikely
14:24:09 <___> you could have deleted the type for testFunc and asked GHC what its type was supposed to be :)
14:24:42 <paczesiowa> why if there are two methods in a class, that are defined by default with mutual recursion (like negate and (-) in Num) there are no warnings if I don't implement at least one of them?
14:24:49 <centrinia> pumpkin, He could use join. ;)
14:25:14 <pumpkin> join with an either in between somehow :o
14:25:15 <iwannalog> paczesiowa: it could become too complex
14:25:23 <dev31212> Hey all
14:25:29 <___> in main, you'll need to scrutinize testFunc's result to see whether it's a Left or a Right
14:25:29 <centrinia> Hi Dev.
14:25:32 <seydar> centrinia: what's a join?
14:25:37 <paczesiowa> iwannalog: what would become too complex?
14:25:38 <centrinia> :t join
14:25:40 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
14:25:42 <dev31212> Are centrenia's haskell studies going well?
14:25:53 <dev31212> Hi centrenia.  I decided to check up your progress.
14:25:59 <pumpkin> o.O
14:26:01 <iwannalog> express the constraint
14:26:45 <marcot> Hello, I have some functions :: State MyData, which I'd like to run.  But I wanted to run then inside a Writer monad, which would write the state to a log at each function.
14:26:59 <marcot> I'm thinking about this for a time, and it's not being easy..
14:27:16 <paczesiowa> iwannalog: I was instancing Num and I was adding methods to get rid of warnings (so there was no negate and no (-)) and that infinite loop wasn't easy to find
14:27:51 <grahamhutton> ICFP 2009 poster, an essential item for everyone's office door/wall :-)  http://www.cs.nott.ac.uk/~gmh/icfp09-poster-letter.pdf
14:28:05 <___> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2927#a2929
14:28:19 <seydar> try 3: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2927#a2930
14:28:32 <pumpkin> paczesiowa: I thought the compiler could catch simple things like that, and tell you <<loop>> or something
14:28:54 <pumpkin> seydar: anything wrong with that?
14:28:59 <seydar> ___: you're a genius!
14:29:16 <Heffalump> grahamhutton: the paper dates seem a bit redundant since submission is past
14:29:24 <seydar> pumpkin: it complains about expecting a String but getting a () around putStrLn
14:29:29 <___> "Left r  -> putStrLn r"  is wrong since (r :: ()), not String
14:29:31 <seydar> basically r is (), like ___ divined
14:29:39 <seydar> ___: why is r ::()?
14:29:43 <pumpkin> seydar: oh, right
14:29:49 <pumpkin> seydar: you didn't give it a string
14:29:49 <paczesiowa> pumpkin: oh yeah, stack overflow, not infinite loop
14:29:54 <___> seydar: because you defined it that way
14:29:58 <pumpkin> paczesiowa: ah, that's sad
14:30:06 <___> type Object = IO (Either () [Int])
14:30:10 <paczesiowa> pumpkin: even with -Wall
14:30:20 <___> () is the Left type.
14:30:24 <seydar> well
14:30:25 <seydar> damn
14:30:28 <seydar> i lose
14:30:38 <pumpkin> paczesiowa: seems like there should be a pragma for telling GHC about mutually recursive class functions
14:30:54 <iwannalog> paczesiowa: didn't know that, but i already complain to myself about this kind of problem
14:31:01 <pumpkin> seydar: btw, Either () a is basically Maybe a
14:31:14 <pumpkin> not exactly, but pretty close
14:31:32 <___> yar, Left () is not substantially different from Nothing.
14:31:42 <paczesiowa> pumpkin: what pragma? it's easy to spot
14:31:48 <Peaker> IO (Either () a) -> IO (Maybe a) -> MaybeT IO a
14:32:09 <paczesiowa> marcot: do you have to use State?
14:32:13 <pumpkin> paczesiowa: is it always?
14:33:21 <paczesiowa> pumpkin: why not? if default definition uses another function from the same class which has default definition that uses the first function than bam, mutual recursion
14:33:28 <seydar> ___: if i change my Either to be IO (Either String [Int]), will i no longer be able to have my putStrLn in testFunc?
14:33:40 <marcot> paczesiowa: Yes, my app is ok with State.  Now I want to write a debug mode, that goes through the functions writing the States passed to Writer.
14:34:06 <paczesiowa> pumpkin: add some transitive magic to that relation and it should work (it's just warnings, they can warn even if it is possible that it would work)
14:34:09 <pumpkin> paczesiowa: seems like you could construct some logic defining when the mutual recursion happens that would make it hard (impossible) for the compiler to determine if the mutual recursion actually occurs
14:34:41 <___> seydar: the result will have to have the type you declare it as, but you can do whatever you like in the actions leading up to it.
14:35:38 <paczesiowa> marcot: I think you'd have to wrap each State computation and pass states manually, you could define your own monad, that looks like StateT . Writer, but also logs things
14:36:07 <marcot> paczesiowa: I thought it would be a WriterT State.  Is it different?
14:36:16 <paczesiowa> marcot: would be easier if you have used MonadState from the beginning instead of State
14:36:28 <marcot> paczesiowa: I think I can live with this.
14:37:04 <paczesiowa> marcot: I think WriterT State wouldn't know when to log things
14:37:27 <paczesiowa> marcot: like lift (put 1 >> put 2 >> put 3)
14:37:45 <paczesiowa> marcot: WriterT would see it as single computation
14:38:08 <marcot> @unmtl WriterT String (State Int) ()
14:38:08 <lambdabot> Int -> ((), String, Int)
14:38:20 <marcot> @unmtl StateT Int (WriterT String) ()
14:38:20 <lambdabot> err: `WriterT String ((), Int)' is not applied to enough arguments.
14:38:27 <paczesiowa> marcot: the easiest and ugliest would be to implement your own State and hide the default one, and just add trace to put/modify
14:38:30 <marcot> @unmtl StateT Int (Writer String) ()
14:38:30 <lambdabot> Int -> ((), Int, String)
14:39:39 <jeffwheeler> Woah, that's very neat.
14:39:58 <jeffwheeler> It just, um, "unwraps" the type from the constructors, etc.?
14:40:00 <marcot> paczesiowa: I get your point about StateT being better...
14:40:58 <marcot> paczesiowa: I think writing my State is not very bad.
14:43:25 <paczesiowa> marcot: for the future, use MonadState everywhere and fix it at the toplevel to State
14:43:38 <marcot> paczesiowa: yes, it's a good tip,  Thanks.
14:43:54 <Baughn> @unmtl StateT Int (IO String) ()
14:43:54 <lambdabot> Int -> IO String ((), Int)
14:44:08 <nzeh> Hi folks, I have a question about a recent (?) change in the interface of Data.Map.  In the default version of D.M packaged with ghc up to v6.8.3, D.M.lookup used to have a return value of (m ...), where m could be any Monad.  As of v6.10.1, D.M.lookup has return type (Maybe ...), that is, is more restrictive.  Does anybody here know why this decision was made?
14:44:25 <dons> it means less programs fail with 'error'
14:44:37 <dons> (also: you can always lift Maybe into any error type)
14:44:42 <centrinia> :t lookup
14:44:44 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
14:44:46 <dons> but by default it means lookup will not terminate your program
14:45:01 <dons> whereas previously almost all return types would throw an exception on failure
14:45:19 <dons> which is unacceptable in the haskell tradition :)
14:45:23 <nzeh> Thanks, dons.  That makes sense.
14:45:36 * ___ supports an step towards abolishing Monad's fail.
14:45:39 <___> any*
14:45:53 <luite> dons: did you see my question about why scanlU gives a shorter result than scanl? does it have something to do with optimization (result is the same length as argument)?
14:46:16 <jmcarthur> oh i didn't know about that change to Data.Map. that makes me happy
14:46:59 <dons> luite: that's the tradition in array programming
14:47:09 <dons> it's a weird artifact of haskell98 that it returns n+1 length lists
14:48:09 <luite> ah ok, for some reason, I need the n+1 result more often than the length n result :)
14:48:24 <Heffalump> I don't find it weird, really.
14:48:38 <Heffalump> it mirrors inits/tails
14:48:39 <pumpkin> luite: there's a scanResU
14:48:54 <pumpkin> luite: that does return the last element as the second element of the strict pair
14:48:59 <bastl1> hello. im thinking about understandig abstract syntax as DSEL and want to write software-engineering tools using that approach. does anyone know related work? the idea is quite simple, but i never saw similar things. most tools are "ad-hoc" ...
14:49:01 <luite> dons: by the way, the GC bug I had last weekend was not caused by uvector or my code. it was fixed by Igloo a few days ago
14:49:08 <luite> in case you were wondering :)
14:52:24 <seydar> how do you spell out "H", like "B" -> "bee", "A" -> "ay"
14:52:45 <Baughn> "Eitch"
14:53:00 <___> I was not aware there was a standard letter -> spelling mapping.
14:53:12 <Baughn> There are several. ;
14:53:13 <Baughn> ;)
14:53:18 <seydar> ___: care to give it a shot?
14:53:26 <seydar> let's see what #haskell can come up with
14:53:36 <___> I'd give the IPA pronunciation for my local dialect.  :)
14:53:41 <mauke> Ay Bee Cee Dee Ee Eff Gee, Aitch Eye Jay Kay El em en oh pee
14:54:05 <paczesiowa> let's have first haskell spelling bee!
14:54:06 <luite> pumpkin: hm, I'd have to use a snocU, I wonder how efficient that is
14:55:17 <luite> would it eliminate the extra array with fusion?
14:55:23 * Axman6 hates it when people pronounce 'H' as haych
14:56:21 * ___ is ambivalent.  Everyone has a dialect, you just don't know it yet.  :)
14:59:15 <pumpkin> luite: I doubt it, you could check though
14:59:28 <pumpkin> luite: you absolutely need it to be in the same array/stream?
15:00:04 <Kydoc> example simpleComment given in http://legacy.cs.uu.nl/daan/download/parsec/parsec.html#manyTill  ; how would one prevent nested comments?
15:01:50 <luite> pumpkin: yes. I might use a fromU, then a scanl on the list, and a toU, but that often results in a lot of allocation. but I'm already trying a few things
15:02:05 <pumpkin> hmm
15:02:20 <Kydoc> *Main> parse simpleComment "" "<!-- blah blah <!-- nested --> -->"
15:02:20 <Kydoc> Right " blah blah <!-- nested "
15:02:40 <___> Kydoc: s/prevent/allow/?  The example doesn't provide for nesting.
15:03:01 <luite> I find it very hard to do optimizations for haskell, often when I make one thing faster, other things get slower, without changing anything there
15:03:32 <pumpkin> hmm
15:03:50 <___> Kydoc: you'd have to look for "<!--" in the token stream in addition to the "-->"s.  If you encounter one, you could parse it as a comment recursively.
15:04:02 <luite> in this case, snocU with scanResU seems a little bit faster than fromU ... scanl ... toU and explicit recursion instead of a scanl
15:05:50 <Kydoc> nah, prevent in the sense of having a parse error on nested comments
15:06:07 <pumpkin> luite: maybe you could check how the stream-fusion does it
15:06:15 <Kydoc> rather than later when the extra --> causes problems
15:06:18 <___> the parse error will occur when you encounter the "-->" outside of the comment.
15:06:28 <pumpkin> luite: since it emulates Data.List behavior
15:06:44 <___> for all the parse knows, the things after the first "-->" could be valid.
15:06:47 <___> parser*
15:07:23 <___> or you could explicitly fail if you encounter "<!--" in the body of a comment.
15:07:24 <luite> pumpkin: hm, good idea
15:07:51 <pumpkin> it all comes down to the unstreamScanM function in uvector
15:07:55 <___> I think that's what you're asking for.
15:07:58 <Kydoc> yeah, is the explicitly failing thats tripping me up
15:07:59 <Kydoc> yes
15:08:45 <pumpkin> mmorrow: vacuum!
15:09:05 <mmorrow> pumpkin: !!
15:09:15 <mle> heh, or allow nested <!-- with optional nesting of --> using GLR to find the only valid parse at the end
15:09:17 <pumpkin> mmorrow: tell us more!
15:09:45 <mmorrow> i'm making a little page for it with a mini-gallery with the theme of http://moonpatio.com/vacuum/dlist.html
15:10:10 <pumpkin> mmorrow: you should make an announcement to cafe :) it looks pretty awesome to me
15:10:23 <Kydoc> short of using error, i'm not sure how to make that fail early
15:10:24 <mmorrow> pumpkin: yeah, i'm gonna for sure
15:10:48 <mmorrow> pumpkin: it's soo addicting.. :)
15:10:59 <pumpkin> oh no, now I'll waste even more time
15:11:03 <mmorrow> "ooh, i wonder what this looks like .... holy crap!"
15:11:04 <pumpkin> playing with code for the sake of code
15:11:10 <___> manyTill (not (string "<!--")) (try (string "-->")) -- haven't done parsec or indeed any haskell in a while, this is almost certainly wrong.
15:11:40 <pumpkin> mmorrow: what was the input for that graph?
15:11:56 <mmorrow> i generated the .dot with:
15:12:16 <mmorrow> ghci> (writeFile "dlist.dot" . render . ppDot . nameGraph . vacuum) (dlist [0..5])
15:12:23 <pumpkin> ah
15:12:27 <pumpkin> so 0..5
15:12:32 <mmorrow> yeah
15:12:50 <pumpkin> I wonder if you could make the graph interactive using embedded svg
15:13:10 <mmorrow> the node labels given to dot are just one possibility, i'm gonna add more options to the .dot gen too
15:13:50 <mmorrow> pumpkin: totally! i'm thinking about possible cools things to do with (e.g.) graphviz's ability to generate html image maps
15:13:51 <Kydoc> yeah, i'd love for (not (string "whatever")) to work, but a parser is not a boolean . . .
15:14:07 <mmorrow> i don't really know anything about svg, but that sounds sweet
15:14:58 <pumpkin> mmorrow: I'm not sure how many browsers even support embedding svg in a page
15:15:10 <pumpkin> (if any)
15:15:19 <pumpkin> but it looks like a nice project
15:15:36 <pumpkin> you should show us a Data.Sequence
15:15:44 <mmorrow> pumpkin: hmm. i think graphiz .png + html imagemap + some javascript could potentially be nuts
15:15:45 <___> I only had a cursory look at the doc, there ought to be parser negation somewheres.
15:17:03 <mmorrow> pumpkin: the haddocks are here until they get built on hackage http://moonpatio.com/vacuum/haddocks/
15:17:27 <Gracenotes> there ought to be JESUS CHRIST IT'S A LION GET IN THE CAR
15:17:46 <mmorrow> pumpkin: oh nice idea. Sequence/FinagerTrees would be sweet on account of the polymorphic recursion
15:17:59 <mmorrow> *Finger
15:18:35 <pumpkin> what's that omg.png from?
15:18:48 * BMeph_ dares mmorrow to pull his finger...tree.
15:18:51 <___> notFollowedBy might work
15:19:11 <pumpkin> mmorrow: those other PNGs are quite exciting
15:19:30 <mmorrow> pumpkin: yeah
15:19:34 <Gracenotes> ___: what are you trying to match? Text that doesn't contain HTML comments?
15:19:36 <ErhardtMundt> hello
15:19:47 <ErhardtMundt> i need some information
15:20:01 <pumpkin> mmorrow: is there any way you can catch a thunk without evaluating it?
15:20:05 <ErhardtMundt> may i find some haskell library
15:20:13 <eu-prleu-peupeu> can i use a Map that maps integers to functions ?
15:20:19 <pumpkin> sure
15:20:22 <ErhardtMundt> in order to acquire an image from a webcam?
15:20:23 <mmorrow> pumpkin: i'm trying to figure out the deal with that actually right now
15:20:25 <centrinia> ErhardtMundt, Try HackageDB.
15:20:38 <Taejo> :t let loeb x = fmap ($ loeb x) x in loeb
15:20:39 <lambdabot> forall (f :: * -> *) b. (Functor f) => f (f b -> b) -> f b
15:20:42 <ErhardtMundt> centrinia: still read
15:20:43 <ErhardtMundt> :)
15:20:50 <mmorrow> pumpkin: "deal" being, what the possible options wrt that are
15:21:03 <Taejo> > let loeb x = fmap ($ loeb x) x in   loeb [ (!!5), const 3, liftM2 (+) (!!0) (!!1), (*2) . (!!2), length, const 17]
15:21:05 <lambdabot>   [17,3,20,40,6,17]
15:21:15 <___> Gracenotes: not me, Kydoc.
15:21:22 <ilseman2> @pl     spt i g = runDijkstra i g [] 0 []
15:21:23 <lambdabot> spt = flip flip [] . flip flip 0 . flip flip [] . runDijkstra
15:21:35 <ErhardtMundt> centrinia: another problem is i whish it to be portable
15:21:40 <ilseman2> don't think I'm going to go with that...
15:21:50 <mmorrow> @type let loeb a = fix (\x fmap ($ x) a) in loeb
15:21:52 <lambdabot> Parse error in pattern
15:21:59 <pumpkin> mmorrow: there was that ghc blog entry that allows you to find sizeOf anything, and would always return something small for unevaluated thunks... maybe you could do something based on that?
15:21:59 <eu-prleu-peupeu> pumpkin: why is your twitter the most followed ?
15:22:05 <ErhardtMundt> so i'd prefer not to use v4l related solutions
15:22:08 <mmorrow> @type let loeb a = fix (\x -> fmap ($ x) a) in loeb
15:22:10 <lambdabot> forall (f :: * -> *) b. (Functor f) => f (f b -> b) -> f b
15:22:20 <pumpkin> eu-prleu-peupeu: I'm quite well known in the iphone community and have a lot of fanboys following me
15:22:21 <Kydoc> Gracenotes, just trying to figure out how one would find a parse error early on nested multi-character bracketed structures
15:22:29 <eu-prleu-peupeu> ah nice :)
15:22:29 * mmorrow realized that loeb def yesterday as it so happens
15:22:37 <pumpkin> eu-prleu-peupeu: they mostly just bug me about upcoming jailbreaks and unlocks
15:22:48 <eu-prleu-peupeu> im going to follow you too, but for the haskell stuff
15:22:55 <mmorrow> pumpkin: ooh, that's right. i think that was JaffaCake
15:23:00 * mmorrow looks for that
15:23:14 <ilseman2> @pl  sptW i g = spt i $ convGraphW g
15:23:14 <lambdabot> sptW = (. convGraphW) . spt
15:23:25 <pumpkin> http://ghcmutterings.wordpress.com/2009/02/12/53/
15:23:32 <mmorrow> nice, thx
15:23:47 <___> Kydoc: notFollowedBy is what you want.
15:23:50 <pumpkin> unpackClosure# hmm
15:24:05 <mmorrow> oh nice, i'm looking at that and friends as we speak
15:24:35 <mmorrow> pumpkin: (if you're into this, ByteCodeLink, and ByteCode* in general are good reads)
15:24:44 <eu-prleu-peupeu> pumpkin, is it possible to code haskell for the iphone ?
15:24:44 <Kydoc> i thought notFollowedBy was a single char, not a string
15:24:58 <mmorrow> pumpkin: i have ghc haddocks with src links here http://moonpatio.com/docs/ghc/
15:25:00 <pumpkin> eu-prleu-peupeu: only hugs for now... if I ever get any time I'll give a ghc port another try
15:25:05 <pumpkin> mmorrow: my savior!
15:25:11 <mmorrow> and a ghc hoogle file http://moonpatio.com/docs/ghc/ghc.txt
15:25:16 <eu-prleu-peupeu> sweet :)
15:25:34 <___> notFollowedBy negates any arbitrary parser.
15:25:50 <skorpan> > let (<,>) = (+) in 1 <,> 2
15:25:51 <lambdabot>   <no location info>: parse error on input `,'
15:26:12 <___> comma is not a valid operator identifier character.
15:28:53 <nzeh> ___: a problem I ran into with using notFollowedBy recently is that it requires the argument parser to return something of type a if the parser parses a stream of a's.
15:29:17 <nzeh> So, for example: notFollowedBy eof will not work if you're parsing a stream of characters.
15:30:16 <pumpkin> mmorrow: closureIsThunk :: ClosureInfo -> Bool ?
15:30:51 <mmorrow> pumpkin: yeah, i actually have that one now
15:30:53 <pumpkin> don't think that's exposed though
15:30:56 <pumpkin> oh
15:31:07 <mmorrow> the only thing is, the top-level is usually a thunk too..
15:31:26 <pumpkin> hmm, yeah
15:31:29 <mmorrow> pumpkin: ah yeah, i should expose everything in one of the modules
15:31:44 <mmorrow> pumpkin: Data.Sequence.fromList [0..39]
15:31:46 <mmorrow> http://moonpatio.com/vacuum/sequence2.png
15:31:47 <pumpkin> whnf + closureIsThunk? or something
15:32:06 <pumpkin> nice
15:32:12 <pumpkin> proof of finger-treeness
15:32:53 <Kydoc> --help = do { anyChar; notFollowedBy (string "<!--")}
15:32:53 <Kydoc> help = do { anyChar; notFollowedBy (char '<')}
15:33:01 <Kydoc> first of those wont compile, second will
15:33:05 <paczesiowa> augustss: do you have your whole C DSL code laying around? I'm trying to make it work from your blog posts, but there are a few higher ranked type errors that I can't fix
15:33:16 <nzeh> Kydoc: that's what I meant.
15:33:19 <Kydoc> yeah
15:33:25 <nzeh> You can work around it:
15:33:44 <nzeh> anyChar; notFollowedBy (string "xxx" >> return 'x')
15:33:49 <Kydoc> hahaha
15:33:54 <nzeh> But I think it's a bug in the current parsec library
15:33:56 <mmorrow> pumpkin: i just added one that quits at a specified depth, which is lets you do only part of graphs with infinite unfoldings, but yeah i want to figure out a (heuristic or whatever) way to selectively enter stuff given some initial guidance
15:34:14 <mmorrow> or something
15:34:45 <pumpkin> you need isInfinite/Bottom :P
15:35:40 <Kydoc> yeah, then you get unexpected 'x'
15:36:45 <nzeh> Kydoc: You can fix this with <?>, too
15:37:48 <iago> hello, there is any checkpoint library for Haskell?
15:38:04 <rovar> checkpoint?
15:38:14 <Kydoc> yeah, at least that way you have explanation in addition to the unexpected 'x'
15:38:18 <Kydoc> thanks for the help
15:38:36 * othello glares at iago
15:40:37 <paczesiowa> iago: maybe http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Workflow
15:41:14 <iago> arg
15:41:32 <iago> ok, thanks paczesiowa, sorry, I though I search fine
15:42:07 <paczesiowa> iago: no problem, I remembered that there was smth sick like this:)
15:45:57 <centrinia> The fruity vegetables nicks have all been taken. :(
15:46:16 <pumpkin> aw
15:46:28 <pumpkin> how about breadFruit
15:46:57 <rovar> rhubarb?
15:47:15 <rovar> arugula?
15:49:43 <augustss> paczesiowa: I don't have it packaged up
15:54:32 <paczesiowa> augustss: do you mind taking a look at http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2932 ? I have no idea how to make that last thing "foralled"
15:54:52 <paczesiowa> augustss: (only arr doesn't work)
16:08:48 <m3ga> is there a way to get the current user id on Posix systems? Hoogle doesn't help with questions like this :-)
16:09:32 <ddarius> @hoogle userId
16:09:32 <lambdabot> No results found
16:09:35 <kynky>   be set in the environment, get it from there ?
16:09:35 <ddarius> @hoogle user
16:09:36 <lambdabot> Prelude userError :: String -> IOError
16:09:36 <lambdabot> System.IO.Error userError :: String -> IOError
16:09:36 <lambdabot> Control.Exception userErrors :: Exception -> Maybe String
16:12:20 <m3ga> kynky, the environment var can't be trusted. the getuid system call can
16:15:25 <m3ga> @hoogle getRealUserID
16:15:25 <lambdabot> No results found
16:16:40 <tromp> :t State
16:16:42 <lambdabot> forall s a. (s -> (a, s)) -> State s a
16:18:52 <m3ga> hmmmm. getRealUserID is in System.Posix.User which Hoogle doesn't seem to know about
16:25:31 <marcot> @hoogle f a -> a
16:25:31 <lambdabot> Data.Monoid getDual :: Dual a -> a
16:25:31 <lambdabot> Foreign unsafePerformIO :: IO a -> a
16:25:31 <lambdabot> Data.ByteString.Internal inlinePerformIO :: IO a -> a
16:26:16 <Japsu> @dice 6d12
16:26:16 <lambdabot> 6d12 => 40
16:26:31 <Japsu> > 40 + 12 + 18
16:26:33 <lambdabot>   70
16:26:53 <Japsu> may IPU bless high crit weapons.
16:33:03 <pumpkin> mmorrow: find anythunk useful?
16:33:12 <pumpkin> (sorry, lame)
16:33:55 <DarthArachides> I want to redefine `instance Applicative Maybe`, how do I override the definition in Control.Applicative?
16:34:11 <DarthArachides> In general, how do I override functionality provided in imported modules?
16:35:00 <timstewart> Are there any Haskell libraries I can use to programmatically create images (bmps, jpgs, gifs, pngs, etc)?
16:35:23 <kynky> cairo
16:35:36 <kynky> gd does some of those
16:35:43 <kynky> or use ffi ?
16:35:43 <pumpkin> DarthArachides: overriding instances isn't possible as far as I know
16:35:53 <pumpkin> DarthArachides: you could wrap the type though
16:35:56 <timstewart> kynky: Thanks!
16:36:21 <kynky> cairo part of the gtk2hs
16:37:07 <timstewart> kynky: I'll see if gtk2hs runs on my Mac.  Thanks again!
16:37:10 <DarthArachides> pumpkin, I see; could you tell me more about "wrap the type"?
16:37:42 <pumpkin> data Moo a b = Moo (Maybe a b) :P
16:37:49 <pumpkin> actually
16:37:59 <pumpkin> not sure why I gave Maybe two type arguments :P
16:38:32 <pumpkin> then you can do instance Applicative Moo
16:38:37 <pumpkin> and make it behave as you want
16:38:51 <DarthArachides> oh, that's a bit messy :); I was hoping something like "import Control.Applicative hiding (...)"
16:39:29 <nolrai_East> Can one redefine implicate parameters, or do I have to use Reader to get a local functionlity?
16:40:11 <Saizan> "implicate"?
16:40:17 <pumpkin> implicit?
16:41:05 <Saizan> > let ?foo = 1 in (let ?foo = 2 in ?foo)
16:41:06 <lambdabot>   2
16:41:07 <nolrai_East> yeah implicit.
16:41:17 <Saizan> > let ?foo = 1 in (let ?foo = ?foo + 1 in ?foo)
16:41:19 <lambdabot>   2
16:41:26 <pumpkin> :o
16:41:37 <nolrai_East> sweet.
16:41:42 <nolrai_East> Thanks!
16:42:02 <Saizan> np, i've learned it too :)
16:42:02 <mmorrow> pumpkin: i'm looking http://moonpatio.com/docs/ghc/src/ByteCodeGen.html currently
16:42:18 <Saizan> +now
16:43:42 <solidsnack> does `import {-# SOURCE #-} GHC.Err` require me to have the sources for `GHC.Err` available?
16:43:57 <pumpkin> what does the SOURCE pragma do? :o
16:44:16 <solidsnack> Well, I worry that it does exactly what it looks like...
16:44:54 <seliopou> It lets you specify line numbers, I believe
16:45:07 <solidsnack> Hmm
16:45:09 <Saizan> isn't that used with boot files to cut cyclic imports?
16:45:12 <seliopou> (used by hsc2hs extensively to provide better error messages)
16:45:13 <solidsnack> Yet, there is no number.
16:45:21 <seliopou> ah, maybe I'm wrong
16:45:23 <solidsnack> Saizan: The error I get is "Bad interface file: /Library/Frameworks/GHC.framework/Versions/610/usr/lib/ghc-6.10.1/base-4.0.0.0/GHC/Err.hi-boot"
16:45:51 <seliopou> what am I thinking of then
16:45:53 <seliopou> ...
16:45:53 <solidsnack> (That file does not exist, so it's definitely bad.)
16:46:02 <Saizan> heh
16:46:15 <solidsnack> seliopou: `{-# LINE #-}` ?
16:46:19 <seliopou> heh
16:46:22 <seliopou> that would make more sense
16:46:34 <seliopou> that's the one
16:46:52 <solidsnack> It would be cool, though, if the source could specify a different file.
16:47:18 <solidsnack> s/source/source pragma/
16:47:29 <solidsnack> Like, `http://...`
16:47:34 <Saizan> LINE or LOCATION can
16:47:50 <Saizan> however where are you imporitng with {-# SOURCE #-}?
16:47:55 <blackh> @tell dons http://www.haskell.org/haskellwiki/Hexpat/
16:47:55 <lambdabot> Consider it noted.
16:48:03 <Saizan> you shouldn't need to do that outside of base
16:48:16 <solidsnack> Saizan: It's in the stream fusion code.
16:48:42 <Saizan> ah, a package on hackage?
16:48:50 <solidsnack> Yes.
16:49:04 <solidsnack> I just want to load a little piece of it, though. I don't want to install it.
16:49:36 <pumpkin> blackh: you have an odd image at the bottom, where the img src is the linked file
16:50:05 <solidsnack> Oh, what the hell.
16:50:09 <solidsnack> I'll just install it.
16:50:19 <blackh> pumpkin: That's an image in the sense of "binary image"
16:50:24 <pumpkin> :o
16:51:13 <Saizan> solidsnack: you need to pass -DEXTERNAL_PACKAGE
16:51:28 <Saizan> solidsnack: like the .cabal file does
16:52:34 <solidsnack> Ahhh.
16:52:48 <solidsnack> Well, installing with Cabal was easy enough.
16:59:09 <nolrai_East> :type (..)
16:59:25 <nolrai_East> @t (..)
16:59:25 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
16:59:30 <nolrai_East> @ty (..)
16:59:32 <lambdabot> parse error on input `..'
17:00:00 <nolrai_East> @ty pred
17:00:01 <lambdabot> forall a. (Enum a) => a -> a
17:02:00 <mmorrow> pumpkin: nice, i think this is what we're looking for exactly http://moonpatio.com/repos/LIBS/Language/ghc/rts/ClosureFlags.c
17:02:35 <pumpkin> ooh
17:12:58 <nolrai_East> @ty (-)
17:12:59 <lambdabot> forall a. (Num a) => a -> a -> a
17:25:45 <olivierp> hi everyone, is there a way to write a type annotation for a function that accepts, say, either Int or VAR Int as an argument, where data VAR a = ... ? The function is already polymorphic in this argument, with signature (CollectArgs a) => a -> result type, but I'd like each use to be able to restrict the type further.
17:26:49 <olivierp> also note that instance CollectArgs (VAR a) and instance CollectArgs a - I'm using overlapping instances
17:27:15 <olivierp> (instance head constraints omitted)
17:27:46 <Saizan> Either Int (Var Int) ?
17:28:38 <Japsu> @pl \a b -> a `x` 1 `y` b
17:28:38 <lambdabot> y . (`x` 1)
17:28:56 <Japsu> meh
17:29:10 <Japsu> @pl \a b -> x a (y 1 b)
17:29:11 <lambdabot> (. y 1) . x
17:29:11 <skorpan> or y . (flip x 1) no?
17:29:28 <Japsu> nah, lambdabot doesn't know that y binds tighter than x
17:29:35 <Japsu> :P
17:30:06 <skorpan> hm...  i wonder if you can tell lambdabot somehow.
17:30:33 <olivierp> Saizan: hmm, sounds good, I should be able to declare type Arg a = Either a (VAR a) right ?
17:30:40 <Olathe> @pl \a b -> a `x` (1 `y` b)
17:30:40 <lambdabot> (. (1 `y`)) . x
17:30:48 <Saizan> olivierp: yes
17:30:57 <olivierp> sweet
17:32:57 <olivierp> does this mean haskell supports union types btw?
17:33:48 <jmcarthur> union types? like C unions?
17:33:55 <jmcarthur> that would be called a sum type, and yes
17:34:14 <jmcarthur> data Foo = Bar Int | Baz String
17:34:17 <travisbrady> what does kind mean in Haskell? ala
17:34:19 <travisbrady> @kind []
17:34:21 <lambdabot> * -> *
17:34:24 <jmcarthur> ^^ like Either Int String
17:34:48 <jmcarthur> travisbrady: [] is a type constructor. it takes a type and returns a type
17:34:55 <|jedai|> travisbrady: A kind is a "type of type"
17:35:07 <jmcarthur> for example, [Int] is the type constructed by applying [] to Int
17:35:21 <jedai> travisbrady: All normal type have kind *
17:35:34 <travisbrady> so what does the kind say about them then?
17:35:43 <travisbrady> * -> * doesn't seem terribly descriptive
17:35:49 <jedai> travisbrady: type constructor  have kind "* -> *" for instance
17:35:56 <jmcarthur> * says that it's a type, * -> * says it's not a type until you apply it to a type
17:36:10 <travisbrady> @kind 9
17:36:11 <lambdabot> Only unit numeric type pattern is valid
17:36:18 <jedai> travisbrady: it says that it takes a type parameter and return a type
17:36:24 <jmcarthur> @kind IO
17:36:25 <lambdabot> * -> *
17:36:29 <travisbrady> @kind Maybe
17:36:30 <jmcarthur> @kind Either
17:36:30 <lambdabot> * -> *
17:36:31 <lambdabot> * -> * -> *
17:36:52 <jmcarthur> @kind (,,,,,)
17:36:54 <lambdabot> * -> * -> * -> * -> * -> * -> *
17:36:55 <Saizan> olivierp: more properly it supports "sum" or "discrimated union" types
17:36:57 <travisbrady> this is another one of those things in Haskell that i'm not sure how badly i need to know it
17:37:01 <skorpan> @kind (,)
17:37:02 <lambdabot> * -> * -> *
17:37:03 <jedai> travisbrady: In the future it may be that different kind become available
17:37:16 <jmcarthur> @kind ((,,,),(,,),(,,,,),(,,,,,,))
17:37:18 <lambdabot>     `(,,,)' is not applied to enough type arguments
17:37:18 <lambdabot>     Expected kind `*', but `(,,,)' has kind `* -> * -> * -> * -> *'
17:37:25 <jmcarthur> @kind ((,,,),(,,),(,,,,),(,,,))
17:37:26 <lambdabot>     `(,,,)' is not applied to enough type arguments
17:37:26 <lambdabot>     Expected kind `*', but `(,,,)' has kind `* -> * -> * -> * -> *'
17:37:32 <jmcarthur> oh, stupid
17:37:34 <jedai> travisbrady: for now you don't really need to know and there's not much to know anyway
17:37:38 <jmcarthur> that won't work :)
17:37:39 <ddarius> :k (->)
17:37:40 <lambdabot> ?? -> ? -> *
17:37:45 <olivierp> jmcarthur: not like C unions no, like union types in formal ML, I'm trying to put my type systems class to use :)
17:37:57 <travisbrady> I've written real stuff in Haskell but get the sense all the time that I'm doing it wrong or something, I should be using Monoids  or State or Applicative or something
17:38:07 <travisbrady> jedai: thank you
17:38:25 <jmcarthur> olivierp: isn't familiar with union types then
17:38:30 <jmcarthur> err... /me isn't
17:38:56 <olivierp> jmcarthur: I think it's the same as sum types
17:38:58 <jedai> travisbrady: Seeing very abstract pattern like that comes with experience (if you try to see them)
17:39:27 <jmcarthur> olivierp: then we have that :)
17:39:30 <Saizan> (oops, i meant discriminated earlier)
17:39:49 <jmcarthur> travisbrady: feel free to ask for refactoring suggestions here :)
17:41:12 <travisbrady> jmcarthur: one question i have is, in my code here http://github.com/travisbrady/haskell-tyrant/blob/ffb09057650f92a2746457245ccb0a992663cb6a/Database/TokyoTyrant.hs i have an IO action that returns a Socket, but my module doesn't export Socket, should I wrap socket for my uses and export that?
17:41:36 <travisbrady> relevant code is openConnection on line 131
17:42:13 <olivierp> jmcarthur: yeah actually I think it doesn't and that it's related to haskell having iso-recursive types and not equi-recursive types
17:42:17 <jmcarthur> travisbrady: would you consider client code using Socket directly to be an abstraction leak?
17:42:39 <travisbrady> yes i suppose i would
17:42:49 <travisbrady> i mean, i'm all for people using code as they see fit
17:43:01 <jmcarthur> travisbrady: then it's probably a good idea to wrap it
17:43:05 <travisbrady> i was thinking of wrapping socket as TokyoTyrantHandle or something
17:43:26 <travisbrady> can i just do something like "type TokyoTyrantHandle = Socket"?
17:43:32 <jmcarthur> if the point is to provide convenience functions to work with sockets, no wrapping, but if the point is for this to be transparent, you certainly don't want to expose those details
17:43:47 <jmcarthur> type doesn't hide any information
17:43:56 <jedai> travisbrady: Not if you want to avoid leaking abstraction
17:44:01 <jedai> travisbrady: use newtype
17:44:03 <jmcarthur> travisbrady: i recommend newtype
17:44:22 <travisbrady> i haven't ever actually used newtype and i always forget its purpose
17:44:39 <jedai> travisbrady: it will hide Socket, forbid abstraction leaking but keep the performance
17:44:54 <jmcarthur> travisbrady: newtype creates a truly new type, not just an alias
17:44:58 <travisbrady> jedai: ahh, sounds perfect then
17:45:34 <jmcarthur> travisbrady: but differs from data in that is doesn't create another level of indirection, and the strictness is just the strictness of the wrapped type
17:45:51 <solidsnack> I am trying to write a type signature like that of `Stream` in the `Data.Stream` package; but it's quite confusing: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2935
17:46:21 <solidsnack> Long and short of it is, they wrote what looks like an existential but it turns out not to be.
17:46:32 <solidsnack> However, per the paper, it's supposed to be.
17:46:32 <jedai> travisbrady: newtype allows you to encapsulate an existing type for the type system (new instances, abstract type from outside your module, ...) but in reality in the compiled code it's directly th original data representation that's used, which means you don't lose any performance due to indirection
17:46:37 <jmcarthur> jedai: in theory, it should keep the performance. doing things like fmap NewtypeConstructor still has overhead :\
17:47:09 <travisbrady> jmcarthur, jedai: say for example i used data, would that mostly be bad from a performance/strictness perspective?
17:47:13 <jedai> jmcarthur: in theory that could be optimized away though
17:47:16 <jedai> travisbrady: Yes
17:47:20 <jmcarthur> jedai: yes, and i would love that
17:48:10 <travisbrady> jmcarthur: did you take a look at that code by any chance?  anything stand out to you as especially offensive?  i have this desire to write proper Haskell code but fear I'm not
17:48:22 <jmcarthur> travisbrady: i'll give it a closer look
17:48:53 <jmcarthur> travisbrady: do you prefer point free?
17:49:12 <travisbrady> sometimes, when it improves readability
17:49:20 <jmcarthur> travisbrady: it is my preference, but it's also kind of stylistic (although there are efficiency benefits too)
17:49:25 <jmcarthur> okay
17:49:49 <jmcarthur> your functions of the form foo x = f $ g x are easy pickings for that
17:50:14 <jmcarthur> and also things like foo x y = bar baz x y
17:50:15 <travisbrady> so just foo = f . g
17:50:21 <jmcarthur> yup
17:51:31 <jmcarthur> travisbrady: this is also purely stylistic, but i prefer to avoid do notation unless necessary for readability
17:51:56 <travisbrady> jmcarthur: yeah, i use it a lot because i struggle with bind
17:52:02 <jmcarthur> especially thing like getInt don't need it
17:52:26 <jmcarthur> but also the functions that could be written as foo >> bar... in my opinion, too simple not to write that way
17:52:27 <travisbrady> oh that one is really unnecessary, you're right
17:53:08 <jmcarthur> travisbrady: but i seem to be focusing on small scale things right now. you were really wanting more architectural suggestions, weren't you?
17:53:13 * wli hits MonadCont vs. MonadWriter unhappiness again
17:53:14 <travisbrady> i always have trouble converting do blocks to use >>= and >> when i've got let's in my do, lambdabot is no help
17:53:17 <olivierp> Saizan: with Either, I'll always be forced to wrap the parameter to my function as Left x or Right y. can you think of a way that would allow me to give just the parameter, keeping the function polymorphic?
17:53:32 <travisbrady> jmcarthur: i appreciate everything, i really want to understand it all
17:53:59 <jmcarthur> travisbrady: okay. pick a function in do notation that you want to work on and we'll reduce it a bit
17:54:16 <jmcarthur> keep it kind of simple. i'm going to need to leave fairly soon
17:54:53 <travisbrady> jmcarthur: hmmm, actually i've got to leave as well, i'm on irc most of the time though, i'll see you on here again
17:55:53 <jmcarthur> travisbrady: okay, just let me know next time you are ready
17:56:05 <travisbrady> ok, thanks
17:56:13 <olivierp> Saizan: actually I can sort of think of a way to do it using Template Haskell: generate a class with the method, and 2 instances, one for Int and the other for VAR int
17:57:15 <monadic_kid> i haven't seen anyone acknowledge the existence of Ct in the context of haskell NDP discussions
17:57:21 <olivierp> Saizan: but this feels heavy handed, and I don't like that splices are explicit in TH, it makes things look funny (this is for a DSL)
18:01:16 <Saizan> olivierp: you could add a type parameter to CollectArgs, so that you can specify the type of the "argument"
18:01:55 <Saizan> CollectArgs (Var a) a; CollectArgs a a; foo :: CollectArgs a Int => a -> ..
18:02:20 <olivierp> Saizan: hmm that sound good
18:02:22 <wli> No instance for (MonadWriter (Seq (b, b)) (ContT (b, b) (StateT ((b, b, b), (b, b, b), (b, b, b)) (Writer w))))
18:05:13 <Saizan> wli: either the MonomorphismRestriction, or you've to fix a type for whose b and w
18:06:19 <Saizan> or at least connect the two..
18:07:46 <Saizan> maybe i'm talking nonsense
18:07:53 * Saizan `ap` sleep
18:23:49 <wli> doesn't look good; it just gives the analogous for b = Double, w = Seq (b, b)
18:48:23 <jmcarthur> test
18:48:41 <jmcarthur> @users
18:48:42 <lambdabot> Maximum users seen in #haskell: 662, currently: 597 (90.2%), active: 4 (0.7%)
18:48:51 <jmcarthur> just checking. unusually quiet in here!
19:06:12 <wli> lift . lift did it
19:07:07 <jmcarthur> :t lift . lift
19:07:08 <lambdabot> forall (t :: (* -> *) -> * -> *) (m :: * -> *) a (t1 :: (* -> *) -> * -> *). (Monad m, MonadTrans t1, Monad (t1 m), MonadTrans t) => m a -> t (t1 m) a
19:09:00 <monochrom> "you only lift twice" :)
19:10:19 <wli> @type lift . lift . tell . Data.Sequence.singleton
19:10:20 <lambdabot> forall (t :: (* -> *) -> * -> *) (t1 :: (* -> *) -> * -> *) (m :: * -> *) a. (MonadWriter (Data.Sequence.Seq a) m, MonadTrans t1, Monad (t1 m), MonadTrans t) => a -> t (t1 m) ()
19:12:28 <wli> http://wli.pastebin.com/m6cc515fa <-- stupid small code to play with loop-breaking via MonadCont and getting MonadWriter to cooperate with it.
19:16:53 <jmcarthur> is there a vector of the new logo anywhere?
19:30:27 <wli> (in other news, I suspect this is bisecting most of the time)
19:31:22 <burninator> I'm having a problem compiling some code....
19:31:36 <burninator> I'm doing an "import qualified Data.ByteString as B"
19:31:59 <burninator> but I get the error "Not in scope: type constructor or class 'B'"
19:32:58 <burninator> I'm not sure why, does anyone know what is wrong with that import statement?
19:34:44 <burninator> never mind, figured it out
19:35:21 <wli> It seems to mostly make one huge leap and bisect the rest of the time.
19:36:21 <chessguy> 'evening
19:36:43 <gwern> have you ever noticed that ear wax must be a rather effective insect repellant?
19:37:45 <chessguy> wow, clearly i'm walking in on a fascinating conversation :)
19:38:14 <Nafai> Is the HAppS stuff the easiest way to put together a simple web application?
19:38:21 <gwern> chessguy: no, think about how wonderful an ear canal must look to an insect
19:38:27 <gwern> think how perfectly suited it is
19:38:40 <chessguy> um...i'd rather not, thankks
19:38:51 <gwern> Nafai: easiest? I'd expect turbinado or one of the other lightweight frameworks to be easier than happs
19:39:14 <monochrom> Tomorrow when your programmer colleagues need to debug their programs, give them the gift of ear wax.
19:39:25 <Nafai> gwern: All I want is something that will map a URL to an action
19:39:31 <gwern> I mean, it's narrow enough you can't get your finger into it; it's moist; it's protected from the elements; it has all the flesh an insect could eat, and so on
19:39:42 * ddarius thinks gwern is oversimplifying things.
19:39:52 <gwern> and unlike some other orifices, escape to the outside world is easy
19:40:07 <ddarius> gwern: Not really.  I know this from personal experience.
19:40:25 <gwern> do tell
19:40:38 <monochrom> It has access to the most powerful computer in Nature, too, when the insect wants to play a shooting game or surf the internet...
19:42:25 <monochrom> "Hey, Ant #4398! Why are you so lagged?"  "Hi Ant #293, my host has the dumb --- he's programming in VB."
19:42:26 <jmcarthur> Nafai: happstack definitely provides that functionality, and it's even pretty easy to do, but it might be a bit overkill for that too
19:42:39 <jmcarthur> at least as far as figuring out what you're doing
19:43:04 <jmcarthur> Nafai: happstack provides its own web server too
19:44:10 <Nafai> jmcarthur:  I need the webserver too :)
19:50:28 <harblcat> I'm having trouble wrapping my head around the State monad. Anyone have experience with it?
19:51:12 <monochrom> Yes, try wrapping the State monad around your head instead.
19:51:55 <monochrom> More seriously, suppose you want to mimick just one mutable variable of type Int.
19:52:15 <chessguy> harblcat, interestingly, most imperative languages run in an implicit State monad
19:52:48 <monochrom> evalState (some code here) 0  will run that code with the mutable variable inited to 0.
19:52:56 <harblcat> monochrom: wrapping the State monad around my head sounds like a zen-buddhism thing :P
19:52:59 <chessguy> hiya bos
19:53:11 <bos> howdy
19:53:11 <monochrom> Inside that code, you can use put to set a new value, and get to read the current value.
19:53:32 <gwern> @quote koan
19:53:32 <lambdabot> No quotes match. Have you considered trying to match wits with a rutabaga?
19:53:37 <gwern> @quote Nothing
19:53:37 <lambdabot> monochrom says: "Monad is about computation." "Our company is about synergy." "iPod is about coolness."  Godawful postmodernism nothingness.
19:53:55 <gwern> not a very good quote
19:53:57 <gwern> @quote Nothing
19:53:57 <lambdabot> monochrom says: All numbers just sit there doing nothing.
19:54:12 <monochrom> Example.  evalState (do { x <- get; let {y=x+1}; put y; z <- get; return (z+1) }) 0
19:54:46 <gwern> harblcat: if you want koans, we do have them
19:54:48 <ddarius> Better known as 2.
19:54:51 <monochrom> So the mutable variable starts out as 0. Then x becomes 0. y becomes 1. 1 is stored. z becomes 1. 1+1 is returned.
19:54:57 <gwern> @where koan
19:54:57 <lambdabot> http://haskell.org/haskellwiki/Koans
19:55:02 <monochrom> > evalState (do { x <- get; let {y=x+1}; put y; z <- get; return (z+1) }) 0
19:55:03 <lambdabot>   2
19:55:08 <chessguy> @quote strict.language
19:55:08 <lambdabot> dark says: <shapr> for example: "head (filter (\x -> x > 5) [1..])" <shapr> in a strict language, you can't easily play with infinite lists <dark> In a strict language, you would write that as "6" :)
19:55:10 <monochrom> As predicted.
19:55:15 <harblcat> now, the state I'm working with can be anything at all, right?
19:55:30 <cadr> Anyone have a minute for a Cabal problem?
19:55:35 <monochrom> Yes, some people use a whole record because they need several variables.
19:55:42 <gwern> cadr: I could look if it's not too hard
19:55:55 <harblcat> I think I might 'get' it now...
19:56:21 <cadr> I have a data file that the code can't find
19:56:21 <harblcat> execState and evalState are different in what they return, but runState returns the both of them, right?
19:56:37 <monochrom> That is what I mean by wrapping it around your head. Immersion. Practice practice practice. Experience it for 24 hours.
19:56:46 <monochrom> Yes.
19:56:55 <cadr> gwern: and I'm not sure how to tell how to find the file
19:57:15 <cadr> The code is here:  http://patch-tag.com/repo/fallingblocks
19:57:18 <gwern> cadr: you are uinsg the Paths_ stuff?
19:57:28 <cadr> trying to
19:57:40 <cadr> gwern: wait, which Paths_ stuff?
19:58:21 <cadr> gwern: sorry, thought you were talking about something else, I think.
19:58:27 <gwern> the Paths_ stuff which contains functions which evaulate to where the data-files are stored
19:58:36 <cadr> gwern: no
19:59:28 <gwern> well there you go
19:59:37 <gwern> didn't ndm point you at his blogpost covering Paths_*?
20:00:00 <cadr> gwern: point me?  If so, I missed it.
20:00:22 <cadr> gwern: who is ndm and when did he do this?
20:00:56 <gwern> http://neilmitchell.blogspot.com/2008/02/adding-data-files-using-cabal.html
20:02:03 <cadr> gwern: Ok, so I was looking at the wikibook on haskell packaging, and I tried changing my cabal file to have a 'data-files' section, and it didn't like it.
20:02:32 <gwern> probably put it in the wrong part
20:03:52 <cadr> gwern: which 'part' is it suppose to go in?  he says to add it in the 'top section', but I'm not sure what that is
20:05:36 <Cale> cadr: If there are multiple parts separated by blank lines, it probably means the first of those.
20:06:49 <gwern> in main.hs, your changes will probably look like this:
20:06:51 <gwern> +import Paths_fallingblocks
20:06:53 <gwern> +  let mus = getDataFileName "music.mp3"
20:06:53 <gwern> +  music <- loadMUS mus
20:06:57 <cadr> Cale: rock on!  It seems to have liked that better
20:08:02 <gwern> hm. you load a file other than in main.hs
20:08:05 <gwern> naughty
20:08:24 <gwern> well, '+  music <- loadMUS =<< getDataFileName "music.mp3"
20:08:28 <gwern> compiles
20:08:46 <cadr> gwern: naught?
20:08:49 <cadr> gwern: naughty?
20:09:09 <gwern> @wn naughty
20:09:12 <lambdabot> *** "naughty" wn "WordNet (r) 2.0"
20:09:12 <lambdabot> naughty
20:09:12 <lambdabot>      adj 1: suggestive of sexual impropriety; "a blue movie"; "blue
20:09:12 <lambdabot>             jokes"; "he skips asterisks and gives you the gamy
20:09:12 <lambdabot>             details"; "a juicy scandal"; "a naughty wink";
20:09:14 <lambdabot> [6 @more lines]
20:09:22 <gwern> @more
20:09:22 <lambdabot>             "naughty words"; "racy anecdotes"; "a risque story";
20:09:23 <lambdabot>             "spicy gossip" [syn: {blue}, {gamy}, {gamey}, {juicy},
20:09:23 <lambdabot>              {racy}, {risque}, {spicy}]
20:09:23 <lambdabot>      2: badly behaved; "he was saucy and mischievous in school"; "a
20:09:24 <lambdabot>         naughty boy" [syn: {mischievous}]
20:09:26 <lambdabot>      [also: {naughtiest}, {naughtier}]
20:09:33 <gwern> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2937
20:10:44 <cadr> gwern:  haha, no, I guess I was asking 'in what way is it naughty?'  :)
20:13:07 <Chani> I find myself reversing lists a lot today, because I'm trying to use them as queues. am I missing an easier way?
20:14:15 <ddarius> Chani: Use a queue.
20:15:44 <wli> Chani: Data.Sequence
20:18:06 <edwardk> Data.Sequence is handy
20:18:21 <edwardk> that reminds me i need to add a bunch of monoids for that
20:19:17 <wli> It's got a wonderful Monoid instance for MonadWriter.
20:21:50 <edwardk> yeah, they forgot the corresponding Monoid for FingerTree, but I added it in my toy library
20:22:03 <wli> edwardk: I've figured out how to get MonadWriter to interoperate with the flip runContT return . callCC . runReaderT idiom: the result of tell needs to be lifted twice.
20:22:44 <edwardk> so you can keep your logs through the continuation?
20:23:03 <wli> yeah
20:23:34 <edwardk> sounds about right
20:24:00 <wli> Well, all I use the continuation for is loop-breaking anyway, but one could, for instance, use it to jump between phases, each of which consist of loops, until hitting a continuation that doesn't loop.
20:24:50 <wli> My code experiment is at http://wli.pastebin.com/m527828e5
20:25:47 <edwardk> newt = newton-raphson?
20:26:13 <wli> Yeah. Basically iteration to convergence.
20:26:46 <cadr> gwern:  Thanks for the help!  Still having issues, but have new directions to research.  But need to go.  Cheers!
20:27:15 <cadr> Cale: thanks for your help, too!
20:27:22 <edwardk> wli: http://comonad.com/haskell/monoids/dist/doc/html/monoids/ is where i have gotten with the monoid stuff
20:27:46 <edwardk> right now i'm branching out add adding all the misc. monoids that are missing in the standard libs
20:27:58 <Berengal1> Hello, I'm wondering if someone could help me clear something up
20:28:31 <wli> edwardk: The things I actually want to use the idiom for are discrete, it's just that this was a small enough use case for the idiom and unimportant enough code to hammer out whatever was needed to get MonadWriter past MonadCont.
20:28:31 <edwardk> but the core Generator and Reducer models are pretty clean. in fact I love the contents of Data.Monoid.Generator.Combinators - it reads kind of like the punchline of the whole package
20:29:04 <Berengal1> I'm trying to compile a relatively simple program, but ghc fails during the linking phase. Is this a compiler bug, or is my installation of 6.10.1 being interferred with by the 6.8.2 version from the ubuntu repos I've also installed
20:29:44 <edwardk> berengal: more likely the latter
20:30:25 * Chani is not having much luck searching for examples of Data.Sequence. I don't fully understand it from  the documentation
20:30:26 <jmcarthur> work makes me miss haskell a lot
20:30:58 <wli> edwardk: (Actually, I think it's a vaguely slick code snippet.)
20:31:08 <Berengal1> edwardk: That's what I thought as well, but it does compiler even simpler yet programs...
20:31:12 <edwardk> Chani: data.sequence is a neat structure. take a binary (actually 2-3) tree and lift up the left-most and rightmost node, letting the stuff in the middle dangle down
20:32:18 <edwardk> wli: the newton raphson thing is pretty dense
20:32:26 <jmcarthur> Chani: the best thing to do would be to read up on fingertrees, probably
20:32:41 <jmcarthur> Chani: they are very cool :)
20:32:49 <ivanm> gah, as I'm writing my code I think I'm being too ambitious in how to "optimise" it, so I keep getting waylaid :s
20:33:21 <wli> edwardk: But certainly not golfed.
20:33:29 <edwardk> chani: the key concern is you can both append and prepend in O(1). and you can convert it to a list using toList because it is Foldable
20:33:42 <Chani> edwardk: yeah but how do I *use* it?
20:33:52 * Chani isn't used to reading haskell documnentaton
20:34:21 <edwardk> Chani: well, singleton a >< singleton b >< singleton c is a perfectly good Sequence
20:34:34 <Chani> is something like empty |> foo valid syntax? or shold it be empty (|>) foo? am I reading the page too literally?
20:34:45 <Chani> ahh...
20:34:45 <edwardk> you're reading it too literally
20:35:03 <edwardk> the parentheses are because thats for the type annotation
20:35:06 <edwardk> @type (+)
20:35:07 <lambdabot> forall a. (Num a) => a -> a -> a
20:35:15 <edwardk> > 2 + 4
20:35:16 <lambdabot>   6
20:35:20 <edwardk> no parens when used.
20:35:22 <edwardk> that said
20:35:24 <edwardk> you can use them
20:35:26 <edwardk> > (+) 2 3
20:35:28 <lambdabot>   5
20:36:01 <Chani> ohhhhhh.
20:36:05 <kapil> 2 `(+)` 3
20:36:24 <jmcarthur> kapil: that won't work though
20:36:41 <kapil> is see!
20:36:45 <jmcarthur> > 2 `(+)` 3
20:36:46 <lambdabot>   <no location info>: parse error on input `('
20:36:58 <Chani> why?
20:37:30 <jmcarthur> Chani: `foo` is just a way to make normal identifiers infix, just like (*) is a way to make operators prefix
20:37:48 * ivanm wonders why  you would want to do `(+)` anyway...
20:37:55 <edwardk> hrmm do you think anyone would mind if I showed the Data.FingerTree package that is in hackage some love and gave it a meaningful Monoid instance for >< and empty?
20:38:09 <kapil> i guess there is no point to having such a construction as `(+)` or (`foo`)
20:38:12 * jmcarthur has wanted to do (a `foo bar` b) before though
20:38:20 <ivanm> edwardk: as the person who uploaded it?
20:38:22 <wli> edwardk: There is still some trouble since I don't detect when there is failure to reduce the residuals or when abscissae become equal on account of roundoff error.
20:38:54 <edwardk> ivanm: that appears to be ross@soi.city.ac.uk
20:39:24 <edwardk> Ross Paterson doesn't sign in here does he?
20:39:33 <ivanm> not that I know of...
20:39:49 <wli> I guess I need a quick check that one interval strictly contains another.
20:40:00 <Berengal1> I'm still having compilation problems after removing ghc 6.8.2 and "./configure && sudo make install" on 6.10.1...
20:40:57 <Berengal1> Is there some place I should paste the errors, or are four lines short enough to paste here?
20:42:01 <ivanm> Berengal1: any paste site should be fine
20:42:26 <ivanm> there's also hpaste which is geared towards haskell code
20:43:01 * Chani has switched to using seq now :)
20:43:18 <Berengal1> http://pastebin.com/m6f27a0d7
20:44:06 * ivanm guesses a C linking error
20:44:43 <pumpkin> --make ?
20:45:02 <Berengal1> Make doesn't die, but it doesn't link either
20:45:05 <Berengal1> Stops at .o
20:45:15 <pumpkin> it shouldn't
20:45:36 <Berengal1> I know, it works fine for 'main = putStrLn "hello"'
20:46:14 <pumpkin> what's changed?
20:46:45 <Berengal1> About 120 lines
20:47:04 <Berengal1> The only imports I'm using is Control.Monad, Data.List and Data.Maybe
20:47:16 <pumpkin> so something in those 120 lines made it decide to make --make stop linking the final output?
20:47:17 <Berengal1> It also works fine in ghci
20:47:39 <pumpkin> do you have any {- OPTIONS in your source?
20:47:45 <Berengal1> None
20:48:26 <pumpkin> so you're 100% positive that using --make doesn't produce an executable (it will leave a .o lying around too)?
20:48:46 <ivanm> Berengal1: are you using Integer?
20:49:06 <Berengal1> Actually, it's not my source, but one of the nonogram solvers from the wiki with about 15 extra lines to make it work in some other things I'm doing
20:49:21 <ivanm> no, wait, it doesn't look like a GMP issue
20:49:21 <Berengal1> No, Int, Bools, Lists and Maybes
20:49:26 <ivanm> Berengal1: which one?
20:49:29 * ivanm will try here
20:49:36 <Berengal1> Second one
20:49:42 <wli> edwardk: Okay, I fixed it up so it gives up upon lack of forward progress.
20:50:02 <ivanm> Berengal1: second what? ;-)
20:50:06 <ivanm> i.e. link please!
20:50:23 <Berengal1> http://www.haskell.org/haskellwiki/Nonogram
20:50:29 <Berengal1> Second one there
20:50:44 <Berengal1> (It was on its way :P)
20:51:55 <ivanm> how does one use it?
20:52:01 <ivanm> there's no main function that I can find...
20:52:11 <Berengal1> Hang on a sec...
20:52:16 <wli> http://wli.pastebin.com/m581a0765
20:52:49 <ivanm> wli: that's a rather ugly looking function :s
20:52:52 <Berengal1> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2938#a2938
20:52:58 <Berengal1> Bottom few lines are mine
20:53:06 <pumpkin-> that's a terrifying function
20:53:28 <wli> ivanm: Mostly the point was to figure out how to get MonadWriter to interoperate with the MonadReader/MonadCont idiom for loop breaking.
20:53:46 <wli> pumpkin: Worse than newt?
20:53:55 <pumpkin-> I meant the newt is terrifying :)
20:54:16 <ivanm> Berengal1: how does one use it?
20:54:39 <ivanm> pumpkin-: which is what I meant as well
20:54:52 <wli> pumpkin/ivanm: Anything in particular I did wrong?
20:55:02 <ivanm> wli: make an ugly function? ;-)
20:55:29 <ivanm> I would try and split it up to have multiple smaller functions rather than one big one
20:55:31 <pumpkin-> wli: nothing particularly wrong with it, I'm just not used to seeing "big" functions
20:55:52 <Berengal1> ivanm: The main intent is to throw it into a python script generating these puzzles... basically something like 'echo "[[2],[1]]\n[[1],[2]]" | ./nonogram' should work
20:56:20 <ivanm> Berengal1: works here
20:56:34 <ivanm> Berengal1: you might have to make it "module Main where" rather than "module Nonogram where" up the top
20:56:37 <Berengal1> Well, yes, it does work in ghci as well, but it doesn't compile
20:57:00 <Berengal1> Huh... indeed...
20:57:19 <wli> ivanm/pumpkin: Well, the results suck. Despite trying 3 different Newton steps, it still bisects almost 100% of the time.
20:57:38 <ivanm> oh, is that meant to be Newton's method? :o
20:59:22 <ivanm> Berengal1: does it work now?
20:59:29 <ivanm> how are you trying to compile it, anyway?
20:59:41 <wli> ivanm: Well, it takes a bit more than \f f' -> iterate (\x -> x - f x / f' x) to be useful.
21:00:01 <ivanm> but why in ST?
21:00:15 <Berengal1> ivanm: Yeah, it works now. I was just checking if it worked in conjunction with the script as well, which it did
21:00:41 <Berengal1> I compiled by simply 'ghc nonogram.hs'
21:00:58 <ivanm> yeah, so that code is a library module, rather than a stand-alone program
21:01:25 * pumpkin- advertises mmorrow's vacuum for him!
21:01:28 <Berengal1> I get why --make didn't work. To have it fail like that without --make was confusing though
21:01:34 <pumpkin-> hey all, vacuum is awesome!
21:01:38 <ivanm> pumpkin-: is he selling a vacuum cleaner?
21:01:42 <pumpkin-> yup
21:01:44 <pumpkin-> it's a kirby ;)
21:01:45 <ivanm> Berengal1: because it expects a Main module
21:01:59 * ivanm prefers Hoover
21:02:25 * wli frequently uses ghc -O2 -main-is MyModule.driver --make MyModule -o ./driver etc.
21:02:52 * Berengal1 frequently uses ghci MyModure.hs
21:02:52 <ivanm> wli: what's the .driver file?
21:03:01 <pumpkin-> I think that's the function
21:03:11 <wli> ivanm: It's not a file, it's a qualified function name.
21:03:30 <ivanm> wli: ahhhh
21:03:35 <wli> ivanm: You can basically tell ghc to use any function of type IO () instead of the one named main.
21:03:42 <wli> In any module, not just Main.
21:03:45 <ivanm> *nod*
21:04:07 <Berengal1> I've spent most of my haskell time in the interpreter, which has left me somewhat unfamiliar with the surrounding framework
21:04:22 <steveklabnik> is there a simple way to split a number into its individual digits?
21:04:39 <pumpkin-> steveklabnik: map digitToInt . show
21:04:53 <pumpkin-> > map digitToInt . show $ 526
21:04:54 <lambdabot>   [5,2,6]
21:05:03 <wli> So I write some quick and dirty test interaction crap in some functions in/around each module, and each testcase or test repl or whatever gets a different makefile target, generated by calling ghc on the same file with a different -main-is
21:05:10 <steveklabnik> pumpkin-: thanks. i knew there had to be something easier than what i was trying to do
21:05:14 <ivanm> pumpkin-: which unfortunately is a rather hacky way of doing it
21:05:19 <pumpkin-> yup :)
21:05:30 <ivanm> the other way would be to do an unfold `div` 10 or something
21:05:41 <pumpkin-> :t divmod
21:05:42 <lambdabot> Not in scope: `divmod'
21:05:46 <pumpkin-> :t divMod
21:05:47 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
21:05:49 <pumpkin-> aha
21:05:51 <TSC> But that's what show does anyway, right?
21:06:14 <pumpkin-> > unfoldr (Just . flip divMod 10) 526
21:06:15 <lambdabot>   [52,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
21:06:18 <pumpkin-> boo
21:06:24 <pumpkin-> I guess that doesn't make sense
21:06:34 <pumpkin-> > unfoldr (Just . (snd &&& fst) . flip divMod 10) 526
21:06:36 <ivanm> pumpkin-: you need a Nothing case for < 10 or something
21:06:36 <lambdabot>   [6,2,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
21:06:40 <pumpkin-> yeah
21:06:50 <kerlo> How p-adic.
21:07:04 <kerlo> Now do arithmetic on those.
21:07:04 <pumpkin-> having the infinite list isn't terrible though
21:07:08 <wli> Yeah, there need to be termination conditions.
21:07:08 <pumpkin-> as long as it's backwards
21:07:15 <solidsnack> Is there a way to get GHCi to print all implicit foralls in a type?
21:07:28 <pumpkin-> kerlo: mmm arithmetic :D
21:07:34 <pumpkin-> who needs that
21:07:41 <FunctorSalad_> solidsnack: hmm mine does but I'm not sure how :)
21:07:44 <wli> The backward part is bad.
21:07:48 <kerlo> Num does.
21:07:54 <FunctorSalad_> :set -fglasgow-exts?
21:08:05 <solidsnack> FunctorSalad_: That's the only option you have set?
21:08:15 <pumpkin-> wli: it's bad if you want to do anything useful with it, but it makes sense if you think of it as successive powers of 10
21:08:28 <pumpkin-> the issue is that you never know when it ends :P
21:08:37 <solidsnack> FunctorSalad_: Does not seem to be the ticket on mine.
21:09:03 <FunctorSalad_> solidsnack: here's my whole .ghci http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2939#a2939
21:09:18 <Berengal1> > let swap (a,b) = (b,a) in reverse . unfoldr (\i -> if i == 0 then Nothing else Just (swap . divMod i $ 10)) 123
21:09:19 <lambdabot>   Couldn't match expected type `a -> [a1]'
21:09:23 <Berengal1> :(
21:09:42 <solidsnack> FunctorSalad_: Curses.
21:10:00 <Berengal1> > let swap (a,b) = (b,a) in reverse . unfoldr (\i -> if i == 0 then Nothing else Just (swap . divMod i $ 10)) $ 123
21:10:02 <lambdabot>   [1,2,3]
21:10:08 <pumpkin-> ivanm: http://moonpatio.com/vacuum/dlist.html is vacuum btw
21:11:09 <ivanm> pumpkin-: I was here when put it on hackage and played with it for quicksilver last night
21:11:14 <ivanm> so I know what vacuum is ;-)
21:11:23 <pumpkin-> ah, ok
21:12:04 <pumpkin-> can't hurt for me to try to get the word out ;)
21:12:05 <wli> > let digits (n :: Integer) | n == 0 = [0] | otherwise = digits' [] n ; digits' s n | n == 0 = s | otherwise = let (q, r) = n `divMod` 10 in digits' (r : s) q in digits 127
21:12:07 <lambdabot>   [1,2,7]
21:12:31 <solidsnack> FunctorSalad_: Okay, it must be that one of my options turns it off. Thanks for your help.
21:12:50 <pumpkin-> > swap (3, 4)
21:12:51 <lambdabot>   (4,3)
21:12:52 <ivanm> pumpkin-: why? is it stuck somewhere?
21:13:13 <ivanm> I take it someone @let swap?
21:13:18 <FunctorSalad_> solidsnack: we are talking about this, right? Ghci> :t map           map :: forall a b. (a -> b) -> [a] -> [b]
21:13:26 <solidsnack> FunctorSalad_: Yes.
21:13:40 <pumpkin-> I tried to suck up supercalifragilisticexpialidocious and it got stuck
21:13:58 <pumpkin-> > fst $ swap (undefined, 4)
21:13:59 <lambdabot>   4
21:14:10 <wli> The above digits function is what I would try to cram into a prepackaged loop idiom.
21:14:27 <ivanm> wli: gah!
21:14:37 * ivanm would stick with the unfoldr option
21:14:39 <ivanm> unfoldr++
21:14:50 <Berengal1> unfoldr++ indeed
21:14:54 <ivanm> I ended up using unfoldr a lot for graph unravelling, etc. last year
21:15:08 <kerlo> > map digitToInt "271,828,182 is about a hundred million times e."
21:15:10 <lambdabot>   [2,7,1,* Exception: Char.digitToInt: not a digit ','
21:15:17 <ivanm> kerlo: heh
21:15:47 <wli> unfoldr does reversal, which is evil.
21:15:47 <ivanm> but yes, that's one reason why I think unfolding is better than using show
21:15:48 <Berengal1> takeWhile (not.(==undefined)) :P
21:15:57 <ivanm> Berengal1: can't do that, sorry
21:16:01 <ivanm> @src undefined
21:16:01 <lambdabot> undefined =  error "Prelude.undefined"
21:16:03 <ivanm> > undefined
21:16:04 <lambdabot>   * Exception: Prelude.undefined
21:16:07 <ivanm> ;-)
21:16:19 <Berengal1> Yeah, I know...
21:16:22 <kerlo> bottom should not be a valid value. :-P
21:16:30 <ivanm> kerlo: how about top?
21:16:31 <Berengal1> Hence the ":P"
21:16:33 <ivanm> left?
21:16:34 <ivanm> right?
21:16:35 <ivanm> ;-)
21:16:38 <solidsnack> FunctorSalad_: Oh, I know what it is. :t and :i show different stuff.
21:17:36 * jeffwheeler is very excited to play with the CouchDB bindings on Hackage
21:18:22 <kerlo> Not left and right. top, on the other hand...
21:18:29 <solidsnack> For whatever reason, :i only shows some of the foralls.
21:20:03 <kerlo> Bottom is the value whose type is the bottom type, I guess.
21:20:17 <Berengal1> There is a bottom type?
21:20:24 <Berengal1> a -> [a]?
21:20:25 <kerlo> forall a. a is the bottom type.
21:20:31 <dibblego> the uninhabited type
21:20:46 <kerlo> So top is the value whose type is the top type.
21:21:46 <kerlo> Say, what will GHC say about the type of unTop here: "data Top where Top :: a -> Top; unTop (Top x) = x"
21:22:01 <kerlo> Anyway, every value is of the top type, so every value is top.
21:22:24 <Berengal1> Including bottom?
21:22:33 <ddarius> kerlo: It will say 'a' escapes.
21:23:51 <kerlo> Berengal1: yep, bottom is top.
21:24:25 <kerlo> Bottom is everything and everything is top; therefore, bottom is top by both a logical fallacy and hundreds of actual valid proofs.
21:26:07 <Berengal1> Right... I still haven't caught up to the type theory papers I've been storing up...
21:29:01 <ddarius> Bottom has to do with semantics not type theory.  Most of what kerlo has been saying is mashing those things together into a not very meaningful mess.
21:29:40 <Berengal1> If there are valid proofs, I expect I'll encounter them at some point
21:30:22 <kerlo> I'm assuming that all concepts that are not on Wikipedia do not exist.
21:31:07 <kerlo> Actual valid proofs: s/everything/the type of all dogs/ and, while you're at it, s/is/is a subtype of/g
21:31:11 <ddarius> Berengal1: There are proofs that bottom :: Top, in fact, it's trivial, but "Top" is not top in the sense that "bottom" is bottom.  In fact, Top is isomorphic to ().
21:32:19 <ddarius> There is rarely any "top" element in the sense that bottom is the bottom element.  When there is, it's usually more of an accident, though, incidentally () does have a top element, namely ().
21:33:56 <kerlo> Indeed.
21:34:18 * jmcarthur doesn't really understand what top represents
21:34:26 * wli can't reduce the digits function to one of the stock recursion idioms.
21:35:54 <Pseudonym> > unfoldr (Just . divMod) 16384
21:35:55 <lambdabot>   Couldn't match expected type `(a, b)'
21:36:13 <Pseudonym> Not quite.
21:36:14 <jmcarthur> ddarius: "Top is isomorphic to ()" ... so Top is when there is only one possible value of a type? and i way off base?
21:36:20 <Pseudonym> You want modDiv, don't you.
21:36:24 <wli> You're thinking unfoldr (Just . uncurry (flip (,)) . flip divMod 10)
21:36:35 <ddarius> jmcarthur: Top shouldn't be called "Top"
21:36:42 <wli> That builds the list backward.
21:36:47 <Pseudonym> Yeah, or something like that.
21:37:04 <wli> @type unfoldr (Just . uncurry (flip (,)) . flip divMod 10)
21:37:06 <lambdabot> forall b. (Integral b) => b -> [b]
21:37:23 <wli> > unfoldr (Just . uncurry (flip (,)) . flip divMod 10) 65537
21:37:25 <lambdabot>   [7,3,5,5,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
21:37:35 <dolio> Top is a wrapper that can hold a value of any type, but you can't inspect that value in any way.
21:37:35 <Pseudonym> > unfoldr (Just . uncurry (flip (,)) . (`divMod` 10) $ 16384
21:37:36 <lambdabot>   <no location info>: parse error on input `;'
21:37:43 <Pseudonym> > unfoldr (Just . uncurry (flip (,)) . (`divMod` 10)) 16384
21:37:44 <lambdabot>   [4,8,3,6,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
21:37:46 <wli> See? Backward digits, and worse yet, an infinite list.
21:37:46 <Pseudonym> Right.
21:37:52 <dolio> Actually, you can use seq on it, which makes Top not quite isomorphic to (), but that's evil.
21:38:19 <jmcarthur> dolio: data Top = forall a . Top a?
21:38:26 <dolio> Yes.
21:38:28 <jmcarthur> okay
21:38:32 <Pseudonym> > unfoldr (\n -> if n == 0 then Nothing else Just (n `mod` 10,n `div`10)) 16384
21:38:34 <lambdabot>   [4,8,3,6,1]
21:38:43 <wli> > let digits (n :: Integer) | n == 0 = [0] | otherwise = digits' [] n ; digits' s n | n == 0 = s | otherwise = let (q, r) = n `divMod` 10 in digits' (r : s) q in digits 16384
21:38:45 <Pseudonym> But there's really no nice way to say that, I suspect.
21:38:45 <lambdabot>   [1,6,3,8,4]
21:39:06 <jmcarthur> you're right, that is a nasty way to use seq
21:39:07 <wli> Pseudonym: Slight trouble with initial inputs of 0 and still backward.
21:39:25 <Pseudonym> Well, the initial input of 0 makes perfect sense.
21:39:31 <Pseudonym> > unfoldr (\n -> if n == 0 then Nothing else Just (n `mod` 10,n `div`10)) (-16384)
21:39:33 <lambdabot>   [6,1,6,3,8,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,...
21:39:39 <pumpkin-> > reverse . unfoldr (\x -> guard (x /= 0) >> (Just . swap . (`divMod` 10) $ x)) $ 16384
21:39:39 <Pseudonym> That's not so good, though.
21:39:40 <lambdabot>   [1,6,3,8,4]
21:39:42 <Pseudonym> Tens-complement.
21:39:47 <pumpkin-> lol
21:40:07 <wli> reverse is bad.
21:40:12 <Pseudonym> Oh, i like the guard.
21:40:32 <pumpkin-> wli: yeah, but not terrible
21:40:38 <Pseudonym> Why is reverse bad?
21:40:46 <Pseudonym> Radix conversion is inherently right-to-left.
21:40:49 <jmcarthur> dolio: i don't really see how that's isomorphic to () though. i can pattern match on ()
21:41:19 <wli> The recursion pattern should just reflect that.
21:41:43 <pumpkin-> > reverse . unfoldr (liftM2 (>>) (guard (x /= 0)) (return . (snd &&& fst) . (`divMod` 10))) $ 16384
21:41:44 <lambdabot>   Couldn't match expected type `Maybe a' against inferred type `()'
21:41:46 <dolio> Top has values _|_, Top _|_ and Top v, where v is some value whose whnf is non-bottom.
21:41:47 <pumpkin-> boo
21:42:06 <pumpkin-> @pl  (\x -> guard (x /= 0) >> (Just . swap . (`divMod` 10) $ x))
21:42:07 <lambdabot> ap ((>>) . guard . (0 /=)) (Just . swap . (`divMod` 10))
21:42:11 <pumpkin-> ack
21:42:15 <wli> If you postprocess that way you aren't actually doing anything about the recursion pattern.
21:42:17 <pumpkin-> that makes sense
21:42:37 <dolio> So, ignoring that you can detect Top _|_ with seq, you have _|_ associated with _|_ and Top whatever associated with ().
21:43:19 <jmcarthur> dolio: oh i see, you can't tell the difference between Top _|_ and Top a where a is not bottom
21:43:52 <pumpkin-> > reverse . unfoldr (liftM2 (>>) (guard . (/= 0)) (return . (snd &&& fst) . (`divMod` 10))) $ 16384
21:43:53 <dolio> You can, but only with seq.
21:43:54 <lambdabot>   [1,6,3,8,4]
21:44:04 <pumpkin-> still not fixing the reverseness
21:44:12 <jmcarthur> dolio: right, which i already understood that that is clearly evil
21:44:18 <dolio> Right. :)
21:45:00 <Pseudonym> > (map (read . return) . show $ 16384) :: [Int]
21:45:01 <lambdabot>   [1,6,3,8,4]
21:45:05 <Pseudonym> There you go, no reverse.
21:45:19 <pumpkin-> > unfoldl (liftM2 (>>) (guard . (/= 0)) (return . (snd &&& fst) . (`divMod` 10))) $ 16384
21:45:20 <lambdabot>   [1,6,3,8,4]
21:45:35 <pumpkin-> Pseudonym: I was originally doing that, with intToDigit, but ivanm didn't like it
21:45:55 <ivanm> sure, blame me ;-)
21:46:02 <pumpkin-> I always do :)
21:46:09 <Berengal1> How do you know show doesn't use reverse internally?
21:46:11 <ivanm> pumpkin-: even when I didn't say anything? :o
21:46:12 <pumpkin-> anyway, I got rid of the reverse too!
21:46:17 <pumpkin-> ivanm: yup
21:46:30 <pumpkin-> omg
21:46:33 <not_ivanm> ;-)
21:46:54 <wli> @type fst . until (\(_, n) -> n == 0) (\(s, n) -> let (q, r) = n `divMod` 10 in (r : s, q)) . (,) []
21:46:56 <lambdabot> forall a. (Integral a) => a -> [a]
21:47:08 <pumpkin-> ack
21:47:45 <pumpkin-> you didn't like my latest one? :(
21:47:59 <wli> @src unfoldl
21:48:00 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
21:48:06 <pumpkin-> wli: it's yours :P
21:48:12 <pumpkin-> I stole it from fastest fib in the west
21:48:25 <wli> heh
21:48:40 <dolio> unfoldl is all nasty and general recursive, though.
21:48:46 <pumpkin-> yup
21:48:55 <pumpkin-> but look ma, no reverse!
21:49:07 <pumpkin-> and it's pretty golfed
21:49:17 <wli> It's got a little overhead. There I considered it okay because it was only ever going to be used on very short lists.
21:49:48 <pumpkin-> > unfoldl (liftM2 (>>) (guard . (/= 0)) (return . (snd &&& fst) . (`divMod` 10))) $ 271828 ^ 31415
21:49:57 <pumpkin-> boo :)
21:49:57 <lambdabot>   mueval: Prelude.read: no parse
21:50:37 <pumpkin-> > 271828 ^ 31415
21:50:41 <lambdabot>   224890829691931576481062527093060271896304417545800481696456449238531976695...
21:50:50 <pumpkin-> > length . show $ 271828 ^ 31415
21:50:51 <lambdabot>   170719
21:51:03 <wli> The until may be the more enlightening recursion pattern.
21:51:54 <ivanm> pumpkin-: (snd &&& fst) == flip ?
21:52:16 <jedai> ivanm: no, it's equal to swap
21:52:26 <ivanm> ummm, yeah, that's what I meant
21:52:29 <jedai> swap (x,y) = (y,x)
21:52:30 <pumpkin-> I @let swap earlier
21:52:30 <ivanm> @hoogle swap
21:52:30 <lambdabot> Control.Concurrent.MVar swapMVar :: MVar a -> a -> IO a
21:52:31 <lambdabot> Control.Concurrent.STM.TMVar swapTMVar :: TMVar a -> a -> STM a
21:52:48 <ivanm> pumpkin-: yeah, I wish that was in the std libs :s
21:53:00 <ivanm> @pl \ (a,b) -> (b,a)
21:53:01 <lambdabot> uncurry (flip (,))
21:53:09 <ivanm> ^^ I normally use this though
21:53:19 <pumpkin-> we need swap (x, y) = (y, x) and both f = first f >>> second f
21:53:19 <ivanm> @unpl uncurry (flip (,))
21:53:19 <lambdabot> uncurry (\ b c -> (,) c b)
21:53:34 <ivanm> @unpl (snd &&& fst)
21:53:34 <lambdabot> (snd &&& fst)
21:53:43 <Eridius> @hoogle >>>
21:53:43 <lambdabot> Control.Arrow (>>>) :: Arrow a => a b c -> a c d -> a b d
21:53:45 <wli> I think unfoldl can be rewritten moderately efficiently using until.
21:53:49 <ivanm> pumpkin-: for the latter, I use (f *** f)
21:53:56 <ivanm> wli: what's until?
21:53:58 <ivanm> @hoogle until
21:53:59 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
21:54:02 <pumpkin-> yeah, me too, but still
21:54:04 <pumpkin-> might as well
21:54:04 <ivanm> ahhh
21:54:09 <dolio> It's another kind of general recursion. :)
21:54:24 <pumpkin-> ivanm: I just defined with >>> because that's how they like to define stuff in Arrow :P
21:54:24 <ivanm> almost a more "normal" fixed point function
21:54:33 <pumpkin-> like *** is defined in terms of first >>> second
21:54:33 <ivanm> heh
21:54:40 <ivanm> O RLY? :o
21:54:44 <Eridius> @pl \f -> (f *** f)
21:54:44 <lambdabot> join (***)
21:54:56 <dolio> @src (->) (***)
21:54:56 <lambdabot> (f *** g) ~(x,y) = (f x, g y)
21:54:56 <pumpkin-> I've done that too, but it's rather obscure
21:55:14 <pumpkin-> that's not what's in the Control.Arrow source afaik
21:55:26 <dolio> @src first
21:55:26 <lambdabot> Source not found.
21:55:39 <ivanm> dolio: what does ~ do again?
21:55:46 <dolio> Irrefutable match.
21:55:48 <ivanm> a lazy match or something, isn't it?
21:55:58 <ivanm> irrefutable == crash if undefined?
21:56:12 <ivanm> @type join (***)
21:56:14 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
21:56:15 <jedai> ivanm: No, irrefutable means that it always succeed
21:56:28 <dolio> Matching ~(x,y) against _|_ causes x and y to be _|_, but the match doesn't fail.
21:56:36 <ivanm> dolio: *nod*
21:56:46 <ivanm> so spreading the undefined around?
21:56:52 <ivanm> partition uses that as well, IIRC...
21:56:55 <ivanm> @src partition
21:56:56 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
21:56:56 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
21:56:56 <lambdabot>                               | otherwise = (ts, x:fs)
21:57:00 <pumpkin-> which is the url to the ghc docs with source?
21:57:02 <jedai> ivanm: But of course it may crash later because you try to use some of the vars from the pattern
21:57:15 <ivanm> jedai: *nod*, but *** itself won't crash?
21:57:23 <ivanm> pumpkin-: not the normal ones?
21:57:32 <ivanm> note that the base modules don't have src IIRC
21:57:33 <pumpkin-> there are two sets of ghc docs on haskell.org iirc
21:57:35 <dolio> Anyhow, (***) is a method of the Arrow class, so you can give it a different definition if you want.
21:57:36 <pumpkin-> one of them has source
21:57:47 <dolio> It's just its default implementation that uses first and second.
21:57:50 <pumpkin-> yeah
22:01:57 <Olathe> > 5 + 5
22:01:58 <lambdabot>   10
22:02:00 <Olathe> +++
22:02:12 <ddarius> @karma +
22:02:12 <lambdabot> + has a karma of 38
22:02:27 <Olathe> @karma (+)
22:02:27 <lambdabot> (+) has a karma of 0
22:02:31 <Olathe> (+)++
22:02:42 <lament> @karma c
22:02:42 <lambdabot> c has a karma of 0
22:02:49 <Olathe> They blocked that :(
22:02:56 <Olathe> @karma c++
22:02:56 <lambdabot> c++ has a karma of -2
22:02:56 <lament> what if i like c :(
22:03:07 <ddarius> @karma+
22:03:08 <lambdabot> usage @karma(+|-) nick
22:03:12 <Olathe> You're not allowed to like or dislike C.
22:03:15 <lament> @karma+ c
22:03:15 <lambdabot> c's karma raised to 1.
22:03:16 <Olathe> c--
22:03:22 <Olathe> Ah hah !
22:10:30 <wli> >  let unfoldl f x = snd $ until (isNothing . fst) (\(~(Just (y, x')), s) -> (f x', y : s)) (f x, []) in unfoldl (\n -> guard (n /= 0) >> return (uncurry (flip (,)) $ n `divMod` 10)) 256
22:10:32 <lambdabot>   [2,5,6]
22:11:29 <wli> pumpkin: How's that look?
22:13:04 <Eridius> > map digitToChar . show $ 256
22:13:05 <lambdabot>   Not in scope: `digitToChar'
22:13:07 <Eridius> pfft
22:13:20 <Eridius> hrm, what's it actually called?
22:13:31 <pumpkin-> looks nice :)
22:13:34 <pumpkin-> digitToInt
22:13:35 <Olathe> @hoogle Int -> Char
22:13:36 <Eridius> > map digitToInt . show $ 256
22:13:36 <lambdabot> Data.Char chr :: Int -> Char
22:13:36 <lambdabot> Data.Char intToDigit :: Int -> Char
22:13:36 <lambdabot> Data.ByteString.Char8 index :: ByteString -> Int -> Char
22:13:36 <wli> Eridius: This is about the left-to-right accumulation pattern, not the concrete matter of radix expansion.
22:13:37 <lambdabot>   [2,5,6]
22:13:41 <Eridius> wli: :P
22:13:59 <Olathe> Oh, neat.
22:14:06 <Olathe> Better than read, for sure.
22:15:07 <wli> pumpkin: I expect that to be better than the garbage I used for the fastest fib bits (not sure what happened to my competition on that front, but there are no unequivocal results from my end).
22:17:02 <wli> > fst $ until (\(_, n) -> n == 0) (\(s, n) -> let (q, r) = n `divMod` 10 in (r : s, q)) ([], 257 :: Int)
22:17:03 <lambdabot>   [2,5,7]
22:17:18 <wli> > let digits (n :: Integer) | n == 0 = [0] | otherwise = digits' [] n ; digits' s n | n == 0 = s | otherwise = let (q, r) = n `divMod` 10 in digits' (r : s) q in digits 127
22:17:19 <lambdabot>   [1,2,7]
22:17:45 <wli> Those are the three stages of pulling out the recursion pattern.
22:20:33 <wli> Step 1: pull out the loop termination as a predicate supplied as a function argument
22:21:26 <wli> Step 2: move from calling a function to case analysis of an algebraic type
22:23:56 <wli> One could envision something like unfoldWeird f x :: (t -> Maybe (Either t' t', t)) -> t -> Seq t' that builds up a Seq slapping the result on the left or right end of the current sequence according to the Either in the result.
22:26:10 <Eridius> Maybe Either? hah
22:26:25 <wli> t -> Maybe (Either t' t', t)
22:26:35 <edwardk> thats a whole mess of monad transformers ;)
22:29:57 <Olathe> > (read ('[':).(++"]").intercalate ','.show $ 127) :: [Int]
22:29:58 <lambdabot>   Couldn't match expected type `String'
22:30:06 <Olathe> > (read ('[':).(++"]").intersperse ','.show $ 127) :: [Int]
22:30:07 <lambdabot>   Couldn't match expected type `String'
22:30:10 <Olathe> Bah.
22:30:55 <Eridius> @src unfoldr
22:30:55 <lambdabot> unfoldr f b  = case f b of
22:30:55 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
22:30:55 <lambdabot>    Nothing        -> []
22:31:12 <Olathe> > (show $ 127)
22:31:13 <lambdabot>   "127"
22:31:19 <Olathe> > (intersperse ','.show $ 127)
22:31:20 <lambdabot>   "1,2,7"
22:31:28 <Olathe> > (read.('[':).(++"]").intersperse ','.show $ 127) :: [Int]
22:31:29 <lambdabot>   [1,2,7]
22:31:32 <Olathe> Ah hah !
22:32:54 <Eridius> @let unfoldrWeird f b = case (f b) of Just (ea, b') -> either (<|) (flip (|>)) ea $ unfoldrWeird f b'; Nothing -> empty
22:32:54 <lambdabot>   Parse error
22:32:57 <Eridius> bah!
22:33:00 <wli> unfoldWeird f x = snd $ until (isNothing . fst) (\(~(Just (ey, x')), s) -> (f x', either (<| s) (s |>) ey)) (f x, Seq.empty)
22:33:14 <jedai> > map digitToInt . show $ 1234
22:33:15 <lambdabot>   [1,2,3,4]
22:34:41 <exbio> a
22:34:56 <wli> Eridius: It doesn't make sense to call it unfoldrWeird if left-to-right vs. right-to-left is determined by the function arguments.
22:35:06 <Eridius> wli: true, I mistyped
22:35:10 <Eridius> but I doubt that was the parse error
22:35:24 <Eridius> @src [] (<|)
22:35:24 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
22:35:26 <Eridius> hah
22:35:50 * Eridius is more interested in |> of course
22:38:20 <wli> > let unfoldWeird f x = Data.Foldable.toList . snd $ until (isNothing . fst) (\(~(Just (ey, x')), s) -> (f x', either (<| s) (s |>) ey)) (f x, Seq.empty) in unfoldWeird (\n -> guard (n /= 0) >> return (first Left . uncurry (flip (,)) $ n `divMod` 10)) (289 :: Integer)
22:38:21 <lambdabot>   Not in scope: `<|'Not in scope: `|>'    Failed to load interface for `Seq':...
22:38:41 <Eridius> heh
22:39:53 <wli> > let unfoldWeird f x = Data.Foldable.toList . snd $ until (isNothing . fst) (\(~(Just (ey, x')), s) -> (f x', either (flip (Sequence.<|) s) ((Sequence.|>) s) ey)) (f x, Sequence.empty) in unfoldWeird (\n -> guard (n /= 0) >> return (first Left . uncurry (flip (,)) $ n `divMod` 10)) (289 :: Integer)
22:39:54 <lambdabot>   [2,8,9]
22:40:10 <Olathe> > let zomg x = [2, 8, 9] in zomg 289
22:40:12 <lambdabot>   [2,8,9]
22:40:23 <Olathe> Fast !
22:40:45 <wli> The point is you can define unfoldl and unfoldr in terms of unfoldWeird.
22:41:12 <Eridius> @hoogle unfoldl
22:41:12 <lambdabot> No results found
22:41:14 <Eridius> :P
22:41:31 <Eridius> unfoldl sounds horribly inefficient
22:41:50 <pumpkin-> hell yeah
22:42:09 <wli> Eridius: Try unfoldl f x = snd $ until (isNothing . fst) (\(~(Just (y, x')), s) -> (f x', y : s)) (f x, [])
22:43:21 <ivanm> how does one test if there are _any_ duplicates in a list?
22:43:24 <wli> I think it's a paramorphism or hylomorphism or some such.
22:44:14 <Eridius> > let unfoldl f x = snd $ until (isNothing . fst) (\(~(Just (y, x')), s) -> (f x', y : s)) (f x, []) in unfoldl (if x > 5 then Nothing else succ x) 0
22:44:15 <lambdabot>   Couldn't match expected type `t1 -> Maybe (t, t1)'
22:44:23 <Eridius> > let unfoldl f x = snd $ until (isNothing . fst) (\(~(Just (y, x')), s) -> (f x', y : s)) (f x, []) in unfoldl (if x > 5 then Nothing else Just (succ x)) 0
22:44:23 <pumpkin-> zygohistomorphic prepromorphism, probably
22:44:24 <lambdabot>   Couldn't match expected type `t1 -> Maybe (t, t1)'
22:44:29 <Eridius> yarr
22:44:30 <Eridius> I fail
22:44:44 <Eridius> > let unfoldl f x = snd $ until (isNothing . fst) (\(~(Just (y, x')), s) -> (f x', y : s)) (f x, []) in unfoldl (if x > 5 then Nothing else Just (x, succ x)) 0
22:44:46 <lambdabot>   Couldn't match expected type `t1 -> Maybe (t, t1)'
22:45:11 <Eridius> > let unfoldl f x = snd $ until (isNothing . fst) (\(~(Just (y, x')), s) -> (f x', y : s)) (f x, []) in unfoldl (\x -> if x > 5 then Nothing else Just (x, succ x)) 0
22:45:13 <lambdabot>   [5,4,3,2,1,0]
22:45:16 * Eridius is chock full of failure tonight
22:45:17 <wli> ivanm: Map.toList . Map.filter (> 1) . Map.fromListWith (+) . zip (repeat 1)
22:45:35 <ivanm> *shudder*
22:45:44 <pumpkin-> > Map.toList . Map.filter (> 1) . Map.fromListWith (+) . zip (repeat 1) $ [1,2,3,2,3]
22:45:46 <lambdabot>   [(1,11)]
22:45:55 <pumpkin-> hmm
22:45:58 <wli> whoops
22:45:58 <Eridius> map? there is a Data.Set type
22:46:01 <wli> flip zip
22:46:07 <pumpkin-> > Map.toList . Map.filter (> 1) . Map.fromListWith (+) . flip zip (repeat 1) $ [1,2,3,2,3]
22:46:09 <lambdabot>   [(2,2),(3,2)]
22:46:12 <pumpkin-> that makes more sense
22:46:16 <ivanm> even manually checking "hasdups (x:xs) = elem x xs || hasdups xs" is better IMHO
22:46:50 <Eridius> how about \x -> x == nub x
22:46:52 <wli> > not . null . Map.toList . Map.filter (> 1) . Map.fromListWith (+) . flip zip (repeat 1)
22:46:54 <lambdabot>       Overlapping instances for Show ([a] -> Bool)
22:46:54 <lambdabot>        arising from a use ...
22:47:04 <wli> > not . null . Map.toList . Map.filter (> 1) . Map.fromListWith (+) . flip zip (repeat 1) $ [1,2,3,2,3]
22:47:06 <lambdabot>   True
22:47:09 <Eridius> (uncurry (==)) (id &&& nub)
22:47:21 <ivanm> Eridius: yeah, that's probably even worse
22:47:25 <pumpkin-> lol
22:47:33 <ivanm> the code is nicer, but the implementation isn't ;-)
22:47:37 <Eridius> :P
22:47:43 <Olathe> @src nub
22:47:43 <lambdabot> nub = nubBy (==)
22:47:46 <Olathe> @src nubBy
22:47:46 <lambdabot> nubBy eq []             =  []
22:47:46 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
22:47:49 <blarf> ugh, C has goto?
22:47:52 <pumpkin-> @pl \x -> x == nub x
22:47:52 <lambdabot> ap (==) nub
22:47:55 <pumpkin-> blarf: damn right
22:47:58 <Olathe> Yes, C has goto.
22:48:03 <Olathe> So does Haskell.
22:48:08 <wli> It's a fold or a mapAccum with a seen set.
22:48:16 <Eridius> ok, so nub is lazy, which means it's probably not *that* bad
22:48:24 <pumpkin-> nub also doesn't require Ord
22:48:35 <pumpkin-> n^2 schmn^2
22:49:25 <ivanm> AFAIC, using a map is non-lazy
22:49:26 <Olathe> > let zomg [] = True; zomg (x:xs) = not (elem x xs) && zomg xs in zomg [1..10]
22:49:27 <lambdabot>   True
22:49:31 <Olathe> > let zomg [] = True; zomg (x:xs) = not (elem x xs) && zomg xs in zomg [1, 2, 1]
22:49:32 <lambdabot>   False
22:49:36 <Olathe> zomg !
22:49:41 <wli> ivanm: Just maintain a seen set.
22:49:58 <ivanm> yeah
22:50:42 <ivanm> which then reduces right back down to "nodups = not . hasdups; hasdups [] = False, hasdups (x:xs) = elem x xs || hasdups xs"
22:50:57 <ivanm> except that with a seen set, you have lookup/insertion, etc. to consider as well
22:51:13 <zeno_> hmm according to this i should be able to download a .mobi for my kindle 2 or rwh (bought/registered it) but its not showing up http://www.realworldhaskell.org/blog/2009/03/13/real-world-haskell-on-the-kindle-2/#comments
22:51:16 <wli> > let hasDups = hasDups' Set.empty ; hasDups' _ [] = False ; hasDups' s (x : xs) | Set.member x s = True | otherwise = hasDups' (Set.insert x s) xs in hasDups [1,2,3,2,3 :: Int]
22:51:17 <lambdabot>   True
22:52:08 <zeno_> this being http://www.realworldhaskell.org/blog/2009/03/13/real-world-haskell-on-the-kindle-2/#comments
22:52:46 <ivanm> zeno_: you probably have to buy it
22:53:19 <Olathe> Can you get ghc on the Kindle ?
22:53:37 <pumpkin-> not for now, I'd guess
22:53:52 * ivanm doubts it
22:54:05 <Olathe> Ahh.
22:54:13 <solidsnack> Do I need special permissions, beyond an account, to edit this page?
22:54:14 <solidsnack> http://hackage.haskell.org/trac/haskell-prime/wiki/ExistentialQuantification
22:54:51 <ivanm> solidsnack: that would be a different account from the haskell wiki, I'd think
22:55:17 <solidsnack> Well, I can log in; however, I can not edit.
22:56:21 <jmcarthur> > let hasDups = (/=) `on` sort <*> nub in hasDups [1,2,3,2,3 :: Int]
22:56:23 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[a1]'
22:56:30 <jmcarthur> > let hasDups = ((/=) `on` sort) <*> nub in hasDups [1,2,3,2,3 :: Int]
22:56:32 <lambdabot>   True
22:56:43 <solidsnack> There is a spelling error: "if you with the quantifier" is likely "if you wish the quantifier". I have reported it :)
22:57:16 <zeno_> ivanm: the post says if you bought the book you can download the mobi for free
22:57:24 <ivanm> *shrug* dunno :s
22:57:32 <ivanm> there was a pdf version which you had to buy seperately...
22:57:35 * Chani is using Seq wrong somehow...
22:57:37 <Chani> Couldn't match expected type `Seq Alt' against inferred type `ViewL a'
22:57:49 <zeno_> hmm thats lame you buy one you should get all of em
22:57:56 <Chani> postfix as cs (a:<pre) = postfix (a:as) ((numChildren a):cs) pre
22:57:57 <zeno_> i suppose ill make a .txt
22:58:29 <zeno_> from the site
22:58:32 <Chani> <| doesn't work either
22:59:53 <pumpkin-> "Proﬁling was used to ﬁnd an optimal chunk size: too small, and performance
22:59:53 <pumpkin-> approaches that of a [Char ] structure, too large (larger than the L2 cache) and
22:59:53 <pumpkin-> performance also falls away. In practice, a chunk size that allows the working set
22:59:53 <pumpkin-> to ﬁt comfortably in the L2 cache has been found to be best"
22:59:57 <solidsnack> Oh, wait -- it looks like Haskell Prime is committee only for edits. That's reasonable.
23:00:03 <pumpkin-> we need a System.Cache.getL2CacheSize :P
23:00:11 <pumpkin-> sorry for the long paste
23:00:31 <solidsnack> pumpkin-: That is from the Iteratee/Enumerator paper?
23:00:41 <pumpkin-> from the ByteString fusion paper
23:00:47 <solidsnack> Oh.
23:01:26 <Chani> anyone know how to properly match againt the head and tail of a sequence? like (a:as) for lists
23:01:40 <pumpkin-> simultaneously?
23:01:50 <Chani> huh?
23:01:55 <Heffalump> Chani: using viewl
23:01:59 <wli> ivanm: For a dynamic set I would use a multiplicity table indexed by value passed alongside the list or whatever.
23:02:03 <Heffalump> and perhaps view patterns
23:02:07 <Chani> Heffalump: but I got that error above...
23:03:09 <Chani> is there no way to do it on hte left side of the =? do I have to use a case statement somehow?
23:03:19 <Heffalump> use view patterns (viewl -> a:<pre)
23:03:45 <Chani> what are view patterns?
23:04:27 <Chani> Illegal view pattern:  (viewl -> a :< pre) Use -XViewPatterns to enable view patterns
23:06:16 <wli> ivanm: e.g. ins x (xs, mults) = (x : xs, Map.insertWith (+) x 1 mults) ; del ([], _) = Nothing ; del (x : xs, mults) = Just (x, (xs, Map.update (\n -> if n == 1 then Nothing else Just (n - 1)) x mults))
23:06:21 <zeno_> Chani: add ViewPatterns in a language pragma
23:06:21 <Chani> hmm, it runs now, and even works, but with a warning about overlap
23:06:22 <ivanm> gah!
23:06:29 * ivanm just manually uses notElem
23:06:43 <Chani> zeno_: what's a language pragma? :)
23:08:27 <wli> oh, yeah, it needs a set of duplicates somewhere updated based on the multiplicity in the Map.
23:15:29 <blarf> Olathe: how does haskell has goto?
23:15:37 <Olathe> I think it has continuations.
23:15:49 <jmcarthur> you can implement continuations in haskell
23:16:03 <Olathe> Which are sort of like comebacks rather than gotos, but still.
23:16:09 <jmcarthur> not *quite* goto, but a close functional equivalent
23:17:08 <jmcarthur> Chani: {-# LANGUAGE ViewPatterns #-} at the very top of your source file will eliminate the need to pass -XViewPatterns on the command line
23:17:42 <zeno_> Chani: {-# LANGUAGE exensions, that, i, want #-} at the top of the file, and they are automatically used
23:17:50 <jmcarthur> Chani: that's the "language pragma"
23:18:11 <Olathe> {-# ZOMG #-} is the zomg pragma.
23:18:19 <Chani> ooh, thanks
23:18:33 <Gracenotes> and {-# {-# #-} #-}, the pragma pragma
23:18:36 <Olathe> It lets the compiler know that this is a particularly surprising section of code.
23:18:49 <pumpkin-> that's the {-# CODE #-} pragma
23:18:49 <zeno_> i like NoMonomorphismRestriction, so i dont have to write out my types
23:18:49 <jmcarthur> {-# SURPRISE #-}
23:18:54 <pumpkin-> ;)
23:19:04 <mornfall> {-# DWIM!!1 #-}
23:19:06 <Gracenotes> ;(
23:19:20 <Olathe> {-# LANGUAGE English #-}
23:19:25 <erikc> is there a clean way to get a Haskell program which defines main linking with SDL, or do you have to bootstrap through a C program which has main() ?
23:19:40 <wli> ivanm: ins x (xs, mults, dups) = (x : xs, Map.insertWith (+) x 1 mults, maybe dups (const $ Set.insert x dups) $ Map.lookup x mults) ; del ([], _, _) = Nothing ; del (x : xs, mults, dups) = Just (x, let mults' = Map.adjust (subtract 1) x mults in case Map.lookup x mults of { Just k | k == 2  -> (xs, mults', Set.delete x dups) | k == 1 -> (xs, Map.delete x mults, dups) ; _ -> (xs, mults', dups) }) ; hasDups (_, _, dups) = Set.size dups > 0
23:19:44 <jmcarthur> erikc: on os x?
23:20:01 <ivanm> wli: gah!
23:20:03 <ivanm> ugliness!
23:20:14 <erikc> jmcarthur: i have the problem on osx and windows
23:20:45 <jmcarthur> erikc: i had to make a main.c wrapper, yes
23:20:58 <jmcarthur> erikc: and on os x i had to make some obj-c calls to create an autorelease pool
23:21:00 <FunctorSalad_> Chani: I think the overlap warnings with view patterns are bogus
23:21:15 <erikc> right :\
23:21:25 <Eridius> {-# SURPRISE BUTTSECKS #-}
23:21:44 <jmcarthur> wli: what is that?!
23:21:54 <Olathe> Eridius: I don't think the compiler enjoys that.
23:22:02 <Eridius> Olathe: unless it's the one doing it
23:22:13 <wli> ivanm: Well, if you're maintaining a dynamic list with O(lg(n)) duplicate testing, it probably maintains a fair amount of information on the side.
23:22:25 <Olathe> Eridius: O-o
23:22:26 <Gracenotes> Olathe: how do you know
23:22:53 <jmcarthur> > {-# SURPRISE BUTTSECKS #-}
23:22:54 <lambdabot>   <no location info>: parse error on input `;'
23:22:54 <Eridius> maybe it's the compiler's ultimate seekrit fantasy?
23:23:04 <wli> jmcarthur: An API and set of auxiliary structures around lists to track the presence of duplicates.
23:23:45 <Olathe> See, it can't even parse that.
23:23:46 <Gracenotes> > map chr {-# SURPRISE BUTTSECKS #-} [83,85,82,80,82,73,83,69,32,66,85,84,84,83,69,67,75,83]
23:23:47 <lambdabot>   "SURPRISE BUTTSECKS"
23:23:55 <Olathe> It's like "What the hell are you trying to do to me ?!"
23:24:06 <Eridius> haha
23:24:07 <pumpkin-> dons: you around?
23:24:54 <wli> I don't see why it's so ugly.
23:25:02 <pumpkin-> buttsecks? me neither
23:25:03 <Eridius> hrm, there's no OrderedSet type?
23:25:12 <Olathe> wli: I think it's just ugly as a one-liner.
23:25:26 <mornfall> Eridius: Data.Set is ordered.
23:25:29 <mornfall> If that's what you mean.
23:25:35 <jmcarthur> > map chr {-# SURPRISE BUTTSECKS #-} [89,69,83,33]
23:25:37 <lambdabot>   "YES!"
23:25:42 <Eridius> mornfall: is it?
23:25:47 <Eridius> > toList $ fromList [5,1,2,3,4]
23:25:48 <lambdabot>   Not in scope: `toList'Not in scope: `fromList'
23:25:57 <Eridius> > Data.Set.toList $ Data.Set.fromList [5,1,2,3,4]
23:25:58 <lambdabot>   /tmp/1244349863103218811:70:52: Not in scope: `Data.Set.toList'/tmp/1244349...
23:26:01 <pumpkin-> it's ordered, but it isn't insertion order
23:26:02 <Eridius> oh come on!
23:26:03 <Olathe> > target
23:26:04 <lambdabot>   Not in scope: `target'
23:26:09 <Eridius> pumpkin-: yeah it appears to be sorted
23:26:14 <pumpkin-> > Set.toList . Set.fromList $ [5,1,2,3,4]
23:26:15 <lambdabot>   [1,2,3,4,5]
23:26:16 <Eridius> there should be an insertion order set
23:26:37 <Olathe> > let sort = Set.toList . Set.fromList $ "zomg"
23:26:38 <lambdabot>   <no location info>: parse error on input `;'
23:26:41 <Olathe> > let sort = Set.toList . Set.fromList in sort "zomg"
23:26:42 <lambdabot>   "gmoz"
23:26:53 <Olathe> zomg is completely backwards.
23:26:58 <jmcarthur> @check \xs -> sort (xs :: [Int]) == Set.toList (Set.fromList xs)
23:26:59 <lambdabot>   "Falsifiable, after 0 tests:\n[3,-2,-2]\n"
23:27:00 <pumpkin-> like, totally
23:27:06 <FunctorSalad_> Eridius: State Int (Map a Int)? ;)
23:27:06 <Eridius> > let sort = Set.toList . Set.fromList in sort "SURPRISE BUTTSECKS"
23:27:08 <lambdabot>   " BCEIKPRSTU"
23:27:09 <Olathe> Ahh :)
23:27:13 <jmcarthur> @check \xs -> sort (nub xs :: [Int]) == Set.toList (Set.fromList xs)
23:27:14 <mornfall> Eridius: You can use list as insertion order set.
23:27:14 <lambdabot>   "OK, passed 500 tests."
23:27:22 <mornfall> Eridius: But it's gonna be more like O(n^2) than anything else.
23:27:26 <pumpkin-> nubList
23:27:30 <Eridius> FunctorSalad_: you'd need another Int to hold the maximum value unless you want O(n) insertion
23:27:36 <Olathe> I wonder if you can make a sort that works for things that are Eq, but not Ord.
23:27:47 <jmcarthur> Olathe: a "sort"?
23:27:49 <pumpkin-> Olathe: how would that work?
23:27:51 <jmcarthur> maybe a group
23:27:52 <Eridius> it seems like you should be able to use a (fingertree, Int) to  do the task
23:27:54 <mornfall> Olathe: Umm?
23:28:00 <Olathe> Well, just grouping equal things together in a list.
23:28:04 <Olathe> A finite list.
23:28:05 <jmcarthur> errr... partition, i mean
23:28:07 <mornfall> Olathe: group? :)
23:28:08 <pumpkin-> group?
23:28:11 <jmcarthur> @hoogle partition
23:28:12 <lambdabot> Data.ByteString partition :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
23:28:12 <lambdabot> Data.IntMap partition :: (a -> Bool) -> IntMap a -> (IntMap a, IntMap a)
23:28:12 <lambdabot> Data.IntSet partition :: (Int -> Bool) -> IntSet -> (IntSet, IntSet)
23:28:19 <jmcarthur> not what i wanted
23:28:21 <FunctorSalad_> insert x xs = do { i <- get; put (i+1); return (insert x i xs) } -- Eridius ?
23:28:22 <Olathe> No, like [1, 2, 3, 4, 1] -> [1, 1, 2, 3, 4]
23:28:28 <jmcarthur> @hoogle group
23:28:28 <lambdabot> Data.ByteString group :: ByteString -> [ByteString]
23:28:28 <lambdabot> Data.List group :: Eq a => [a] -> [[a]]
23:28:28 <lambdabot> Data.ByteString.Char8 group :: ByteString -> [ByteString]
23:28:30 <pumpkin-> but group only works on adjacent elements
23:28:40 <pumpkin-> you need a  concat . group . makeAdjacent
23:28:43 <Olathe> Yeah, I want it to make far away equal elements adjacent.
23:28:45 <FunctorSalad_> Eridius: modulo Data.Map API
23:28:57 <jmcarthur> whatever it is it would need to be O(n^2)
23:29:01 <pumpkin-> yup
23:29:06 <Olathe> That's fine.
23:29:14 <mornfall> n^2 is teh suxor.
23:29:19 <pumpkin-> n^2 is hot
23:29:28 <pumpkin-> it's a nicer shape than n log n
23:29:29 <mornfall> It sucks! It swallows!
23:29:29 <Heffalump> Chani: the overlap warning with view patterns is a GHC bug
23:29:33 <Olathe> n^2 stays at a distance.
23:29:36 <Heffalump> (in the "not yet implemented" sense of bug)
23:29:49 <FunctorSalad_> oh really? when I was young, we had n^7.5, and ...
23:30:06 <jmcarthur> @src nub
23:30:07 <lambdabot> nub = nubBy (==)
23:30:30 <jmcarthur> @src nubBy
23:30:30 <lambdabot> nubBy eq []             =  []
23:30:30 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
23:37:53 <wli> http://wli.pastebin.com/m10e0d159 <-- the code for ivan, cleaned up
23:42:33 <wli> ivanm: Does the pastebinned code look okay to you, or do you need it to avoid carrying out comparisons on (potentially large) values?
23:43:00 <ivanm> wli: I've already just used a simple thing instead ;-)
23:43:08 <ivanm> and it's just Ints, anyway
23:43:24 <ivanm> gah!
23:44:02 <wli> ivanm: You could use IntMap and IntSet for that. Also, depending on whether it's an online sort of thing or not, you may be able to get away with just accumulating a seen set as elsewhere.
23:45:18 <wli> ivanm: ins/del overhead is O(lg(n)) but if you only check for duplicates once at the end, it's not worth it.
23:45:36 <wli> Hmm. The Set is not necessary; you could just keep count.
23:48:27 <wli> ivanm: http://wli.pastebin.com/m5ee29bec <-- fixed up so it just keeps count of the number of duplicates
23:48:45 <ivanm> wli: give it up already ;-)
23:49:13 <wli> The problem piqued my interest.
23:50:09 <wli> There are a number of things you might want to do with a structured multiset.
23:54:59 <rovar> i'm trying to use a module i created called Network.RUDP.Types
23:55:24 <rovar> i can't seem to get ghc to recognize it from my test module
23:55:36 <wli> If you kept track of the list length, you could know the number of unique elements at all times, too.
23:55:50 <ivanm> wli: uuhhh.... all I wanted to do was detect if there were duplicates!
23:56:53 <wli> ivanm: Well, it does it with some O(lg(n)) insertion/deletion, I think IntMap may cut it down a bit depending.
