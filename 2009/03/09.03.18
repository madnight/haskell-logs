00:06:41 <wli> I tried to do escaping variable analysis and failed, so I'm pretty printing the hash consed representations.
00:10:14 <quicksilver> FunctorSalad: ;
00:10:15 <quicksilver> )
00:11:50 * Gracenotes eats a sea kitten
00:11:58 * roconnor votes by bubblesorting
00:12:18 * quicksilver sorts by uploading voting contests.
00:12:51 * wli suggests mergesort.
00:13:06 * Gracenotes suggests vote by DDOS
00:13:10 <wli> (I use selection sort as the stupider-than-thou sort in C.)
00:13:43 <quicksilver> I think selection sort fits better with my cognitive model of voting.
00:13:55 <roconnor> actually, I'm doing a radix sort
00:13:59 <quicksilver> I wonder if anyone has studied sorts where the comparison function changes gradually.
00:16:05 <Cale> quicksilver: For appropriate definitions of "gradually", I think that could be quite interesting.
00:19:04 <quicksilver> Does GHC ever float a constant expression up past a lambda?
00:19:14 <quicksilver> (resulting in that constant being shared between successive calls of the lambda
00:19:24 <Gracenotes> gradual i.e. deterministic, or based on external (not referentially transparent) state?
00:19:27 <quicksilver> ). Did that even make sense?
00:19:42 <quicksilver> Gracenotes: probably continuously in some topology.
00:19:46 <Cale> quicksilver: I seem to recall having some problem with it like that.
00:20:09 <quicksilver> Cale: problem that it did or problem that it didn't?
00:20:13 <Cale> quicksilver: Where turning -O on resulted in a program using way more space.
00:20:14 <Cale> yeah
00:20:23 <Cale> Er, problem that it did do it.
00:20:24 <quicksilver> I actually want it to.
00:20:43 <quicksilver> Cale: in more detail, suppose "f n" is a tree-like structure, dependent on n
00:20:53 <quicksilver> but *most* of the tree is actually independent of n
00:21:02 <quicksilver> (and this is obvious, statically, to the compiler)
00:21:12 <Cale> Does it hurt much to do the lifting by hand?
00:21:22 <quicksilver> Yes, because this is a combinator library
00:21:29 <quicksilver> I don't want my users to have to lift out the constant parts.
00:21:34 <Cale> mmm...
00:21:53 <quicksilver> let me take it one level more concrete.
00:21:55 <quicksilver> animation library.
00:22:04 <quicksilver> some combinators construct things which don't vary, frame to frame
00:22:05 <Cale> I'm not really sure what can be done...
00:22:09 <quicksilver> other parts vary frame to frame.
00:22:18 <quicksilver> ideally the compiler would not recompute the constant bits.
00:23:01 <quicksilver> preferably I want to use MemoizingConstructors to save some of the tesselation/calculation step
00:23:07 <quicksilver> so that only occurs on the first frame
00:23:12 <quicksilver> ...but that requires the sharing, to work.
00:23:19 <Cale> yeah
00:23:44 <quicksilver> this feels like the kind of problem that someone ought to have thought of before ;)
00:24:48 <Cale> It's definitely not the kind of thing you want to always happen. It would be nice if there was some sort of pragma which could be applied as a hint that it might be profitable to lift something.
00:25:15 <quicksilver> maybe it's not too arduous to teach the user how to lift stuff by hand.
00:25:41 <quicksilver> "spaceship = .....; scene x = translate x spaceship"
00:25:50 <Cale> yeah
00:25:51 <quicksilver> make spaceship a top level definition so it's shared.
00:26:21 <quicksilver> when jaffacake gets in I'll ask him what GHC actually does in practice. He might have an observation.
00:26:30 <quicksilver> I think conal has done some stuff in this area too.
00:37:13 <wli> http://wli.pastebin.com/m2152f3ad <-- my "progress" thus far tonight
00:40:46 <wli> Maybe I have to do a conservative approximation for recursion in the presence of bindings introduced by case statements.
00:48:45 <profmakx> who is doing the Lambda-Cube thing?
00:59:24 <wli> Just detecting recursion is pretty painful.
01:10:27 <quicksilver> profmakx: his irc name is hcube
01:14:06 <profmakx> quicksilver does he hang around here sometimes?
01:14:08 <profmakx> @seen hcube
01:14:08 <lambdabot> I saw hcube leaving #haskell 1d 11h 29m 46s ago, and .
01:14:57 * Badger curious
01:15:06 <Badger> @go define:this
01:15:06 <lambdabot> No Result Found.
01:19:16 <GrayShade> I think this is asked all over the place
01:19:33 <GrayShade> but why does let f (x, y) a = (x + a, y + 1); (sum, count) = foldl' f (0, 0) [1..10000000] in sum / count crash with a stack overflow?
01:20:14 <GrayShade> the fold is strict, foldl is tail-recursive, so..
01:21:29 <vegai> I went through that just a few months ago but forgot what it was again...
01:21:42 <vegai> optimization level too low, perhaps?
01:21:52 <GrayShade> might be
01:23:45 <johnw> GrayShade: your accumulator is a tuple
01:23:58 <johnw> you're constructing a very deeply nested tuple on the stack, therefore
01:24:22 <johnw> after just a few iterations it wlil be ((((((x, y), y), y), y), y), for example
01:24:51 <GrayShade> oh
01:24:52 <GrayShade> I see
01:24:53 <GrayShade> thanks
01:25:06 <idnar> is there a function f such that f [1..10] = [(1,2),(3,4),(5,6),(7,8),(9,10)] ? (or perhaps f 2 [1..10])
01:25:32 <quicksilver> erm
01:25:52 <quicksilver> GrayShade is not constructed a nested tuple.
01:26:03 <quicksilver> that would not be a haskell type.
01:26:05 <quicksilver> well, not a simple one.
01:26:08 <johnw> he's doing x + a
01:26:09 <vegai> could it be a lazy tuple, though?
01:26:12 <johnw> isn't a (0, 0)?
01:26:22 <idnar> johnw: that would be a type error, then
01:26:25 <johnw> so x+ a just becomes (0 + x, 0 + x)
01:26:26 <johnw> hmm
01:26:26 <blackh> idnar: I don't think there is one in the standard libraries.
01:26:27 <idnar> > 5 + (0,0)
01:26:28 <lambdabot>       No instance for (Num (t, t1))
01:26:28 <lambdabot>        arising from the literal `5' at <i...
01:26:44 <johnw> oh, it's a foldl, i'm sorry
01:26:48 <johnw> acc on the left
01:27:02 <Stephan202> > let f (x1:x2:xs) = (x1,x2) : f xs; f _ = []; in f [1..10]
01:27:03 <lambdabot>   [(1,2),(3,4),(5,6),(7,8),(9,10)]
01:27:10 <Stephan202> idnar: ^
01:27:32 <idnar> Stephan202: yeah, I was just looking for something shorter
01:27:44 <quicksilver> foldl' has a constant type accumulator.
01:27:45 <idnar> oh, I know
01:27:45 <glguy> takeWhile (not . null) . map (take 2) . iterate (drop 2)
01:27:48 <glguy> :-p
01:28:02 <idnar> > let f n xs = map (take n) . iterate (drop n) in f 2 [1..10]
01:28:03 <lambdabot>       Overlapping instances for Show ([a] -> [[a]])
01:28:03 <lambdabot>        arising from a use...
01:28:13 <idnar> bah, glguy beat me to it
01:28:49 <idnar> also, his version type checks :P
01:28:58 <Stephan202> that will not produce tuples, though :)
01:28:59 <GrayShade> but maybe it's not strict enough? I tried with -O2 and it doesn't work
01:29:08 <idnar> oh yeah, true
01:29:14 <idnar> but the generic version can't be tuples
01:29:18 <glguy> GrayShade, foldl' in your example was strict in the tuple
01:29:23 <quicksilver> GrayShade: the problem is that tuplpes are lazy
01:29:25 <glguy> and not in the fst and snd components of the tuple
01:29:29 <johnw> glguy: ahh!!!
01:29:31 <quicksilver> GrayShade: and the foldl' is only stricting the 'top-level'
01:29:32 <johnw> glguy: that's it
01:29:33 <Stephan202> idnar: yes, I'm afraid so
01:29:36 <Stephan202> Anyway, /me off
01:29:39 <quicksilver> which is the tuple itself, not the contents.
01:29:52 <idnar> Stephan202: the original problem was in Python code, I was just wondering about the Haskell version
01:30:03 <idnar> and tuples and lists are kinda the same thing in Python
01:30:05 <GrayShade> that's what I thought vegai was sayinh :)
01:30:07 <GrayShade> g*
01:30:10 <Stephan202> ah, python has tuple() ;)
01:31:42 <quicksilver> haskell has (\[x,y]->(x,y)) ;)
01:31:49 <Stephan202> (:
01:31:56 <quicksilver> you could make it generic with HList style techniques.
01:32:03 <quicksilver> it's doubtful that that is what you want.
01:32:10 <idnar> list of lists is fine
01:32:26 <quicksilver> idnar: nice thing about list of tlists is you can transpose it
01:32:27 <idnar> especially since I'm not actually using the code for anything, just golfing ;)
01:32:59 <quicksilver> > let chunksOf n = takeWhile(not.null).map(take n).iterate(drop n) in transpose (chunksOf 2 [1..8])
01:33:00 <lambdabot>   [[1,3,5,7],[2,4,6,8]]
01:35:48 <idnar> quicksilver: heh, at one point, I was looking for a function that would give me every n'th element of a list, and then I was going to transpose
01:36:42 <davidL> is there an idiom for join (***) ?
01:37:04 <idnar> @type join (***)
01:37:05 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
01:37:26 <pao> @type join
01:37:28 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
01:37:36 <idnar> @type join (***) (+)
01:37:37 <lambdabot> forall b. (Num b) => (b, b) -> (b -> b, b -> b)
01:38:13 <idnar> eh
01:38:17 <idnar> @type join (***) (+5)
01:38:18 <lambdabot> forall c. (Num c) => (c, c) -> (c, c)
01:38:22 <idnar> @type join (***) (+5) (1,6)
01:38:23 <lambdabot> forall b. (Num b) => (b, b)
01:38:39 <idnar> oh; I guess that's bimap on (,)
01:38:46 <blAckEn3d> hi, i'm reading through rwh and i came across this issue: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2542#a2542 -- isn't helper tail recursive? why does it blow the stack?
01:38:59 <davidL> yeah
01:39:18 <davidL> > join (***) succ (1,2)
01:39:20 <lambdabot>   (2,3)
01:41:00 <TSC> blAckEn3d: It looks like it would build up a huge thunk for s and c; look at http://www.haskell.org/haskellwiki/Stack_overflow
01:41:15 <blAckEn3d> thanks.. i'll read it
01:41:25 <TSC> (and perhaps the later parts of http://www.haskell.org/haskellwiki/Performance/Accumulating_parameter)
01:42:19 <blAckEn3d> thanks
01:42:42 <TSC> You're welcome (:
01:43:12 <wli> I have an idea for detecting recursion.
01:43:31 <TSC> Maybe you could detect recursion by detecting recursion
01:43:58 <wli> eh?
01:44:11 <TSC> It's a joke!
01:45:33 <basvandijk> Hello, does anybody know if the following functions exists somewhere on hackage:
01:45:35 <basvandijk> insert :: (Monoid (f a), Pointed f) => a -> f a -> f a
01:45:35 <basvandijk> insert a h = h `mappend` (point a)
01:46:54 <wli> Track the transitive usage of variables by expressions, then let-bound variables use the variables on the RHS and just give up on case-bound variables and make them depend on all the variables of their scrutinee.
01:50:23 <wli> I think I can just tie the knot.
01:54:33 <qff> Hi, I have a question
01:56:57 <johnw> another naive solution to the [(1,2),(3,4),(5,6),(7,8),(9,10)] puzzle: http://gist.github.com/81008
01:57:07 <blackh> qff: Hello! Ask away!
01:57:24 <qff> I want to make the list of primes (lazy of course) but I want it to expand itself by only checking division with the primes already in the list
01:57:40 <qff> is this possible?
01:58:45 <blackh> qff: It definitely should be.  I did this once.
01:59:03 <qff> okay
01:59:33 <qff> was it hard?
01:59:48 <qff> (I'm not very experienced with Haskell)
02:00:30 <yitz> > let primes = [p | p <- 2:[3,5..], and [p `mod` q /= 0 | q <- takeWhile ((<= p) . (^2)) primes] in primes
02:00:31 <lambdabot>   <no location info>: parse error on input `in'
02:00:48 <yitz> > let primes = [p | p <- 2:[3,5..], and [p `mod` q /= 0 | q <- takeWhile ((<= p) . (^2)) primes]] in primes
02:01:03 <lambdabot>   thread killed
02:01:33 <blackh> qff: I am not sure if this is the same or not...
02:01:56 <blackh> qff: What i did was I made a list of the primes less than N using a sieve method...
02:02:21 <yitz> > let primes = 2:[p | p <- [3,5..], and [p `mod` q /= 0 | q <- takeWhile ((<= p) . (^2)) primes]] in primes
02:02:22 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
02:02:29 <blackh> qff: Then I made another function that kept doubling N until it was big enough to find the requested one. Probably not the same at all!
02:02:46 <yitz> qff: something like that?
02:03:11 <qff> hehe, no blackh, not the same it seems
02:03:34 <qff> but yes yitz it seems that your code does what I requested, though I'm not sure how
02:04:19 <yitz> @remember simonpj Oleg you are a master at persuading GHC's somewhat ad-hoc implementation to dance to your tune.  But it'd be better just to make the implementation more complete in the solutions it finds.
02:04:19 <lambdabot> Done.
02:05:41 <yitz> qff: what part are you having trouble with?
02:06:00 <qff> how can you have "and" right after the comma
02:06:26 <yitz> qff: "and" is function
02:06:28 <yitz> @type and
02:06:29 <lambdabot> [Bool] -> Bool
02:06:30 <jre21> do any of the FR gui libraries have a widget that allows me to fill a grid of pixels?
02:06:39 <yitz> > and [True, True]
02:06:40 <lambdabot>   True
02:06:47 <yitz> > and [True, False]
02:06:47 <lambdabot>   False
02:06:52 <qff> aah
02:06:58 * SubStack wonders how xmonad is even running if he can't even :m +XMonad it
02:07:03 <qff> thought it was something like that
02:07:20 <QtPlaty[hireme]> Not to be confused with &&
02:07:31 <QtPlaty[hireme]> > True && True
02:07:33 <lambdabot>   True
02:07:33 <yitz> QtPlaty[hireme]: much
02:07:43 <yitz> @src and
02:07:43 <lambdabot> and   =  foldr (&&) True
02:08:52 <qff> I think I understand most of the code now
02:09:09 <qff> I'll study it until I understand it fully
02:09:13 <zeno> how do you get the source of something in ghci?
02:09:13 <qff> thank you :)
02:09:45 <qff> bye
02:09:54 <yitz> qff: it might be also useful
02:10:09 <qff> ?
02:10:18 <qff> to study it?
02:10:19 <yitz> qff: to understand why my second attempt failed
02:10:24 <qff> aah
02:10:30 <yitz> (my first attempt was a stupid typo)
02:12:33 <qff> okay
02:12:37 <wli> No instance for (Traversable IntMap)
02:12:40 <qff> I'll check that one out as well
02:13:49 <wli> How the Hell is IntMap Foldable but not Traversable?
02:14:14 <qff> thanks again
02:16:32 <yitz> zeno: you don't. you get it from lambdabot in #haskell.
02:16:32 <johnw> yitz: I also showed him this verbose solution: http://gist.github.com/81018
02:17:35 <yitz> johnw: you can't reverse an infinite list
02:17:45 <johnw> oh, you have such a good point there
02:17:49 <johnw> i'm glad I showed you
02:17:56 <yitz> johnw: you also can't foldl and infinite list - you need foldr
02:18:23 <yitz> *an
02:18:23 <johnw> i did try foldr, but I thought the algorithm needed to know initial primes sooner
02:18:39 <zeno> yitz: ah ok so its impossible? i meant for my own programs, when debugging could just do :s myFunction instead of finding in the src
02:18:41 <yitz> johnw: it probably does. so feed them to it first.
02:19:35 <yitz> zeno: ghci doesn't remember the source. use an editor together with ghci - or even ghci inside an editor if you prefer.
02:21:18 <johnw> yitz: i can't feed it without already knowing them :)
02:21:34 <johnw> if I feed it a 3, for example, i end up with a very strange list
02:21:42 <johnw> hmm
02:21:51 <johnw> will have to investigate another day, after sleep, but I appreciate your correction
02:21:59 <yitz> johnw: ok :)
02:22:07 <johnw> i was still thinking in non-infinite land
02:23:52 <zeno> yitz: ah ok, would be a cool option to have a --remember-src that would do that (not replacing the compiled functions, in addition to)
02:24:43 <yitz> zeno: hmm, you know what, I haven't really used the new debugger features in ghci. Maybe it does remember the source now.
02:26:17 <quicksilver> well it knows where to find the source (for the debugger)
02:27:50 <quicksilver> wli: http://hackage.haskell.org/trac/ghc/ticket/2960
02:36:22 <zeno> @hoogle RandomGen g => (a, a) -> g -> ([a], g)
02:36:22 <lambdabot> No results found
02:37:16 <yitz> @type randomRs
02:37:17 <lambdabot> forall a g. (RandomGen g, Random a) => (a, a) -> g -> [a]
02:37:39 <zeno> yitz: ah thanks, i can just use that and snd random
02:37:56 <yitz> zeno: it swallows the generator, because it might need to use it infinitely many times
02:40:53 <quicksilver> NOM.
02:41:01 <quicksilver> I ACCIDENTALLY THE WHOLE GENERATOR.
02:41:23 <yitz> :)
02:48:32 <yitz> zeno: so i was wrong. if you have :loaded a module from source, you can say :list myFunction. it's indeed one of the new debugger features. how about that.
02:51:00 <quicksilver> yitz: neat. I didn't know that.
02:51:10 <quicksilver> yitz++ # spreading knowledge.
02:51:22 <yitz> hehe. give the credit to zeno.
02:51:37 <quicksilver> zeno++ # inspiring enquiry
02:52:27 <yitz> @list and
02:52:27 <lambdabot> No module "and" loaded
02:52:45 <yitz> urgh. different meaning than in ghci
02:52:51 <yitz> :list and
02:53:01 <yitz> @help list
02:53:01 <lambdabot> list [module|command]
02:53:01 <lambdabot> show all commands or command for [module]. http://code.haskell.org/lambdabot/COMMANDS
02:53:17 <yitz> oh, of course.
03:09:40 <wli> I wonder how this ended up looping.
03:11:06 <wli> The expression graph should only ever cycle through variable references, so those should break the loop every time.
03:17:08 <zeno> @hoogle (a -> a) -> (a, b) -> (a, b)
03:17:09 <lambdabot> Control.Arrow (^>>) :: Arrow a => (b -> c) -> a c d -> a b d
03:17:09 <lambdabot> Control.Arrow (<<^) :: Arrow a => a c d -> (b -> c) -> a b d
03:17:09 <lambdabot> Data.Array.Base ixmap :: (IArray a e, Ix i, Ix j) => (i, i) -> (i -> j) -> a j e -> a i e
03:17:24 <zeno> yitz: awesome, thanks a lot!
03:19:31 <quicksilver> zeno: "first"
03:19:42 <quicksilver> > first (*2) (6,"rabbit")
03:19:44 <lambdabot>   (12,"rabbit")
03:20:01 <zeno> quicksilver: wow you people are helpful :)
03:20:16 <quicksilver> I'm only one person.
03:20:19 <C-Keen_> hm, is there a way to formulate an empty tuple?
03:20:22 <quicksilver> appearances to the contrary.
03:20:26 <quicksilver> C-Keen_: () ?
03:20:37 <zeno> quicksilver: meant channel in general
03:20:47 <quicksilver> zeno: I know. It was a joke.
03:20:53 <quicksilver> not a very good one, but they don't pay me to be funny.
03:21:02 <Stephan202> :P
03:21:16 <wli> It works so long as I don't tie the knot through the error monad.
03:21:37 <C-Keen_> quicksilver: ah no. I get a type error with that. What I want to do is insert a key in a Data.Map  without a value
03:22:04 <quicksilver> C-Keen_: that's broken.
03:22:14 <quicksilver> C-Keen_: make it a Map k (Maybe v) instead
03:22:23 <quicksilver> C-Keen: and use 'Nothing' to encode "no value"
03:22:30 <quicksilver> the type system is your friend :)
03:22:31 <C-Keen> quicksilver: hm...
03:22:39 <C-Keen> quicksilver: sounds better
03:22:41 <C-Keen> thx
03:23:09 <wli> Okay, now I have transitive variable usage by expressions.
03:23:28 <bastl> hi I used "hint" to write a program that loads a Module.hs at runtime and evaluates a function whose signature  is fixed. I compiled it and want to run it on arbitrary hosts. What can I use inside Module.hs? Especially when no ghc is available !?
03:23:43 <zeno> C-Keen: used to java where every type implicityly is a Maybe?
03:24:22 <Baughn> bastl: You should be able to use whatever /is/ available on the various hosts..
03:24:28 <wli> So let-bound variables transitively use variables transitively used by the RHS's of their definitions, and case-bound variables transitively use the variables transitively used by the scrutinees of their definitions.
03:24:57 <Baughn> bastl: Mind you, hint is a GHC API wrapper, so it won't /work/ if ghc isn't around
03:25:04 <bastl> i c
03:25:07 <Athas> How do you remove a package that you've installed with "cabal install"?
03:25:20 <Baughn> bastl: Or, rather, when you compile a program with hint linked in, it balloons the program size to include large parts of GHC
03:25:33 <xenoblitz> hi people, was wondering if anyone in the room knows of any papers about DSELs embedded in Haskell which make use of GADTs
03:25:56 <bastl> Baughn: but then: what can i use !?
03:26:12 * bastl had no way to test that by now ...
03:26:14 <Baughn> bastl: Anything that's installed on all the hosts, as I said.
03:26:45 <bastl> Baughn: but you said, that large parts of GHC might be linked in already. then I would need ghc itself, or?
03:27:00 <quicksilver> you need ghc at compile time, sure.
03:27:07 <quicksilver> then you produce a huge executable which embeds GHC.
03:27:27 <Baughn> bastl: Dynamic linking would be nice, but we don't have that yet. Your program will embed GHC.
03:27:36 <bastl> hm
03:27:40 <zeno> is ghc fast on arm? wondering about writing apps for my g1 (has debian)
03:27:41 <bastl> i have to test.
03:27:54 <xenoblitz> any one? should I try another channel perhaps?
03:28:09 <Baughn> xenoblitz: It does sound like one for #haskell-in-depth
03:28:11 <Baughn> Or the cafe, perhaps
03:28:41 <bastl> wow, youre right, my executable is 28 MB :-)
03:28:43 <xenoblitz> Hmmm i don't know about this channel :) Going to give it a go :)
03:29:48 <bastl> what are DS_E_Ls ?
03:30:08 <quicksilver> domain specific embedded languages
03:30:23 <quicksilver> instead of having a parser, you just write directly into haskell code.
03:30:30 <blackh> zeno: GHC may not be quite as fast on ARM because there's no mangler and it runs in a mode called "mini interpreter", but my reading of the code says that this should only add a small amount of overhead.
03:30:31 <xenoblitz> bastl: what quicksilver said :)
03:30:54 <C-Keen> quicksilver++
03:31:00 <xenoblitz> quicksilver++
03:31:04 <C-Keen> quicksilver: I should have thought about maybe earlier
03:31:05 <wli> ARM users tend to be more concerned about code size and space overhead anyway.
03:31:12 <blackh> Athas: ghc-pkg is the command you want
03:31:39 <C-Keen> zeno: no, I don't know java
03:31:52 <C-Keen> zeno: I was more thinking about lisp's nil
03:32:03 <zeno> C-Keen: ah ok, java has null
03:32:04 <blackh> Athas: ghc-pkg unregister <package>, to be more specific
03:32:16 <bastl> whats the difference to "normal" DSLs? or do people mean the same thing but use different acronyms ?
03:32:28 <quicksilver> a DSL is just any minilanguage.
03:32:29 <wli> So how do I know if a variable escapes?
03:32:30 <quicksilver> regexps are a DSL.
03:32:46 <quicksilver> however, regexps exist in a haskell program as strings, and are explicitly parsed and compiled.
03:32:54 <bastl> ok, so DSL embedded in a larger lang like haskell .. right?
03:33:07 <quicksilver> an *embedded* DSL is one which is directly written in the syntax of the host language
03:33:13 <bastl> ok, got it
03:33:14 <quicksilver> no parsing step.
03:33:36 <xenoblitz> bastl: you get to use Haskell's compiler without having to rewrite all yourself... that's basically their main advantage over DSLs
03:33:40 <quicksilver> in haskell in particular, a DSEL has to respect haskell's type system
03:33:46 <quicksilver> which, obviously has its good and bad points.
03:33:53 <quicksilver> that's why GADTs are relevant
03:34:02 <quicksilver> they are a more flexible type system.
03:34:29 <Baughn> And of course, the functor/monad typeclass hierarchy makes for very flexible EDSL supports
03:34:52 <bastl> yeah, i understand the point, but was unsure about the terminology. Is there any fundamental literature on that? something one _has to_ cite when using these arguments ?
03:35:06 <xenoblitz> quicksilver: I was hoping to see examples of GADTs in use, such as papers which make use of Phantom types
03:35:14 <quicksilver> there certainly are some.
03:35:18 <quicksilver> I can't name one for you.
03:35:21 <xenoblitz> bastl: yes let me find one for you
03:35:29 <bastl> xeno: cool. tx.
03:35:33 <quicksilver> (one of) the GADT papers might use DSELs as an example
03:35:50 <xenoblitz> bastl: Building domain-specific embedded languages - Paul Hudak
03:35:57 <xenoblitz> bastl: that's one of the introductory papers
03:36:07 <bastl> thanks alot.
03:36:20 <Athas> blackh: Thanks.
03:36:20 <xenoblitz> bastl: Modular domain specific languages and tools - also by Hudak is another one
03:36:56 <xenoblitz> quicksilver: you are right I'll take a look at some more of them then :)
03:37:35 <quicksilver> hudak++
03:38:30 <xenoblitz> quicksilver: its amazing how Haskell can achieve so much with embedding just because of its non-restrictive syntax... Hudak making use of that is just pure genious :)
03:39:05 <xenoblitz> *genius
03:41:26 <cizra> @karma hudak
03:41:27 <lambdabot> hudak has a karma of 1
03:42:20 <Saizan> hey, a new logo! "Haskell: DSL for DSELs"
03:42:49 <xenoblitz> Saizan: is Haskell really a DSL though?
03:44:12 <xenoblitz> or perhaps I misunderstood you :p
03:44:16 <yitz> Saizan: good, there aren't enough logos for us to sift through yet.
03:44:46 <Saizan> xenoblitz: it was a joke, however it depends on the domain :)
03:46:58 <xenoblitz> Saizan: well Hudak does say that Haskell is a DSL for denotational semantics but I donno xD
03:50:20 <quicksilver> xenoblitz: lisp has arguably fewer restrictions and is arguably better for DSLs.
03:50:45 <quicksilver> xenoblitz: indeed, good lisp programmers use DSLs so consistently it is essentially a core programming technique.
03:50:52 <quicksilver> it's their replacement for data structures, which they don't have.
03:51:36 <xenoblitz> quicksilver: interesting... I never used Lisp though... I know a bit about it but never experimented with it
03:52:20 <xenoblitz> quicksilver: ... and *psssst* don't tell Lisp but I'm in love with Haskell right now :P
03:52:39 <quicksilver> sure. I prefer statically typed data structures myself.
03:52:58 <quicksilver> I'm just saying that with first class symbols and dynamic scoping, lisp can do some neat DSL tricks.
03:54:31 <xenoblitz> quicksilver: someday someone should write a book about DSELs in various languages and the techniques used... I don't know enough yet to attempt such a noble cause :P
03:59:35 <zipMe> Hello, is it possible to see the source of function in the Prelude from within ghci ?
03:59:41 <Saizan> xenoblitz: if you find examples of gadts for EDSLs let me know, btw
03:59:48 <quicksilver> zipMe: no. but they are on the web.
04:00:05 <quicksilver> zipMe: http://www.haskell.org/ghc/dist/current/docs/libraries/index.html
04:00:25 <quicksilver> (for the prelude specifically, they're in the report, too, but that link has source to all the other libraries which come with GHC)
04:01:17 <zipMe> quicksilver: thanks
04:04:55 <maltem> @hoogle (Functor f, Functor g) => (a -> b -> c) -> f (g a) -> f (g b) -> f (g c)
04:04:56 <lambdabot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
04:04:56 <lambdabot> Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
04:04:56 <lambdabot> Distribution.Simple.InstallDirs combineInstallDirs :: (a -> b -> c) -> InstallDirs a -> InstallDirs b -> InstallDirs c
04:05:35 <wli> let f = \x -> g (h x) ; g = \y -> h (f y) ; h = \z -> f (g z) in Con { u = f 'a', v = g 'b', w = h 'z' } looks like a better test. Maybe I should get a parser so expressions aren't so onerous to write.
04:06:40 <maltem> Aha, so I wanted (liftA2.liftA2)
04:07:22 <wli> I'm still not sure how the heck to tell if a variable escapes.
04:08:11 <wli> I think something like let y = ... in \x -> x + y sees y escape.
04:08:43 <jre21> I'm trying to install wxcore, but it errors with "ghc-pkg: dependency bytestring-0.9.1.4 doesn't exist"
04:09:34 <jre21> any idea why cabal didn't pull in the dependancy?
04:10:17 <dcoutts> jre21: it's not a missing dep like that, it's a problem with something that's already been built
04:10:46 <dcoutts> it's an existing package that depends on the installed bytestring-0.9.1.4, but for some reason  bytestring-0.9.1.4 ismissing
04:10:52 <wli> I wonder why let y = ... in x + y wouldn't see y escape (assuming that x is defined in some enclosing scope).
04:11:12 <dcoutts> jre21: check your ghc-pkg list, is bytestring-0.9.1.4 still there?
04:11:56 <porges> any reason Double isn't Bounded as +/-Infinity
04:11:57 <lambdabot> porges: You have 1 new message. '/msg lambdabot @messages' to read it.
04:12:00 <jre21> bytestring-0.9.0.1 for the global one, bytestring-0.9.1.4 for my user
04:13:01 <dcoutts> jre21: for wxcore are you doing something like building it as user but then trying to register it globally?
04:13:22 <dcoutts> jre21: is this a clean build or are there .o/.hi files left over from a previous attempt?
04:13:31 <jre21> I was trying to install it as user with cabal-install
04:18:59 <dcoutts> jre21: I don't know if they've made that work yet, wx is a bit special in that it uses makefiles which doesn't integrate so well with normal cabal stuff like user installs.
04:19:06 <dcoutts> jre21: you might try a --global install
04:19:29 <wli> Maybe any variable appearing in the body of a let expression escapes.
04:19:38 <jre21> a global install of the latest bytestring?
04:19:45 <quicksilver> dcoutts: last I tried, wxcore had to be installed by hand, but wx could use cabal-install
04:19:49 <quicksilver> but that was a while ago.
04:19:53 <dcoutts> jre21: no, of wx
04:22:52 <wli> Hmm, I wonder why my readline stuff doesn't do history like it should.
04:24:06 <dcoutts> wli: ghc-6.10? libedit?
04:24:31 <wli> Probably not a great time to wonder that since some jerkoff nuked readline from the newest libs.
04:24:43 <wli> dcoutts: No way.
04:26:00 <Baughn> wli: Use haskelline?
04:26:11 <dcoutts> or the readline patches
04:26:17 <wli> addHistory
04:26:58 <wli> When I figure out how to cabal install or emerge the latest ghc plus the readline patches, sure. In the meantime I'm still on 6.8.3
04:27:13 <wli> addHistory solved all my problems.
04:27:27 <dcoutts> wli: for 6.10.2 the gentoo plan is to apply the readline patches
04:27:43 <wli> dcoutts: Thank $DEITY
04:27:50 <dcoutts> seeing how libedit basically doesn't work
04:28:06 <dcoutts> wli: you can thanks kolmodin, he's doing the work
04:28:26 <wli> export DEITY=kolmodin
04:30:01 <wli> My question was actually about usage of the System.Console.Readline API. I apparently needed to addHistory after calling readline itslf.
04:36:11 <aapole> Anyone else having problems with GHC 6.6.1 in OpenBSD/amd64?
04:38:30 * pumpkin yawns and stretches
04:38:41 <JuanDaugherty> aapole, prolly not, one too many outliers.
04:38:53 <wli> I don't think very many people here have used 6.6.1 in a number of years.
04:39:30 <osfameron> I have
04:39:37 <osfameron> it's the ubuntu package I have
04:40:43 <JuanDaugherty> of the three, bsd is prolly the stickiest wicket
04:40:45 <aapole> What is the current version?
04:41:11 <blackh> 6.10.1
04:42:13 <aapole> Gotta try compiling it from sources then..
04:42:34 <quicksilver> I use 6.6.1 often.
04:42:36 <jre21> aapole: yea, I just realized the system I'm on is using 6.8 still
04:42:47 <quicksilver> I only upgraded to 6.8 a few weeks ago.
04:43:08 <jre21> quicksilver: how do you avoid packages requiring the new base?
04:43:42 <JuanDaugherty> by just doing it
04:44:17 <JuanDaugherty> .
04:44:55 * Baughn notes that physics has no notion of referential equality. So haskell matches physics closer than the more common languages, then? ^_^
04:47:38 <HugoDaniel> convRow :: [SqlValue] -> (Int,Int,Int,Day,Day,String,String,Int,Int,Int,Int,Int)   :/
04:47:42 <quicksilver> jre21: by not using them.
04:47:51 <quicksilver> jre21: I very rarely use packages :)
04:48:17 <Baughn> @remember Baughn fix (@remember Baughn . (:))
04:48:17 <lambdabot> Done.
04:48:49 <jre21> quicksilver: aren't you lucky
04:49:19 <quicksilver> jre21: evidently.
04:49:21 <Baughn> jre21: I'm sure cabal-install will get that feature eventually. Meanwhile, why don't you istall 6.10?
04:49:47 <quicksilver> many packages support both base versions.
04:50:35 <jre21> Baughn: because I need to wrap up a small script by 8am
04:50:46 <jre21> given it being 6:50 am here
04:50:52 <Baughn> jre21: MEanwhile, you can ask cabal-install for particular versions
04:51:13 <Saizan> it's a combination of 1) package managers being too lazy to use extensible-exceptions 2) cabal-install's dependency solver is not complete and prefers higher versions, that leads to an apparent need of base-4
04:52:39 <HugoDaniel> in ghci how do i recall the last result returned ?
04:53:00 <HugoDaniel> without repeating the expression
04:53:02 <Baughn> HugoDaniel: it
04:53:06 <HugoDaniel> ah
04:53:06 <HugoDaniel> yes
04:53:08 <HugoDaniel> thanks
04:53:39 <lilac> @@ @run fix ("@remember " ++)
04:53:40 <lambdabot>   "@remember @remember @remember @remember @remember @remember @remember @rem...
04:54:25 <lilac> @@ @remember @run fix ("@remember " ++)
04:54:27 <lambdabot>  It is forever etched in my memory.
04:54:32 <lilac> @quote @remember
04:54:32 <lambdabot> fasta says: I think the @remember command is way overused.
04:54:42 <lilac> @quote @remember
04:54:42 <lambdabot> omnId says: geez, how many metastereo quotes are going to be @remembered?  >_>
04:54:44 <trofi^w> [:
04:54:46 <lilac> :-/
04:54:50 <lilac> @quote @remember @remember
04:54:50 <lambdabot> No quotes for this person. Just what do you think you're doing Dave?
04:55:10 <Baughn> @quote lilac
04:55:10 <lambdabot> lilac says: <drdozer> gha! I'm drowning in the haskell number hierarchy again <lilac> drdozer: magic 8-ball says 'add calls to fromIntegral'
04:56:14 <mxc> good evening..
04:56:39 <mxc> anyone recognize a module called 'View' or 'Misc'  they're referred to in the happstack tutorial, but can't find any docs on them
05:07:11 <wli> http://wli.pastebin.com/m2454902d <-- current code dump
05:10:00 <wli> I'm not sure why the spec'd out version of transVar pukes.
05:10:17 <wli> (specifically looping)
05:17:12 <porges> Is it possible to put class contexts on RULEs?
05:17:34 <porges> http://www.haskell.org/ghc/docs/latest/html/users_guide/rewrite-rules.html doesn't say either way
05:19:02 <quicksilver> porges: http://www.haskell.org/ghc/docs/latest/html/users_guide/rewrite-rules.html#rule-spec
05:19:19 <quicksilver> porges: is not what you asked, but it's related.
05:20:54 <porges> ah, figured it out
05:21:12 <porges> forall (x :: (BoundedUpper a) => a)
05:22:43 * wli is at a complete loss to come up with conditions for variables escaping.
05:24:38 <zeno> hmmm is this duplicating a built-in function? rec f x = let next = f x in next : rec f next
05:25:04 <wli> iterate
05:25:13 <opqdonut> yeah
05:25:21 <zeno> ah ok thanks
05:25:23 <opqdonut> > iterate (+1) 0
05:25:24 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
05:25:27 <trofi^w> > iterate f x :: [Expr]
05:25:28 <lambdabot>   [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (...
05:29:11 <wli> I wonder how to parse expressions spanning multiple lines.
05:29:53 <mxc> have a low level question.  getting linker errors trying to build the happs-tutorial on OSX..  anyone see this:
05:30:02 <wli> The parser would have to be able to stop and resume.
05:30:08 <mxc> Linking dist/build/happs-tutorial/happs-tutorial ...
05:30:09 <mxc> ld warning: atom sorting error for hspreadzm0zi3zi1_ControlziConcurrentziChanziCloseable_W_closure_tbl and ....
05:31:31 <wli> And also to return partial results (i.e. the state to resume from) along with the fact the parse is incomplete in the event a complete parse did not occur.
05:32:41 <wli> Why do I get the feeling this requires LR parsing?
05:34:18 <Saizan> mxc: i think you've recompiled some libraries while not recompiling their reverse deps
05:34:49 <Saizan> mxc: since compiling a library won't always produce the same ABI
05:35:02 <mxc> yeah, the thing is, this is all a fresh install
05:35:06 <mxc> hm
05:35:27 <mxc> i guess I can just clear out ~/.cabal and try again
05:35:46 <Saizan> not .cabal
05:35:48 <Saizan> but .ghc
05:36:36 <mxc> doesn't that just have the list of installed packages?
05:36:59 <Saizan> yeah, that's the important bit
05:37:01 <wli> I think that's how zsh does it; the nonterminals in an LR parser's stack tell you all the construct nesting you need to know.
05:37:18 <mxc> so if i delete that and run a cabal upgrade will that basically for a recompile on everything/
05:37:19 <mxc> ?
05:39:33 <wli> Actually s,LR,shift/reduce,
05:39:50 <wli> There are shift/reduce LL parsers that can do the same.
05:40:41 <wli> It may hobble the strength of the parsing algorithm used since no lookahead is possible.
05:42:47 <wli> (lookahead would force it to lag behind the last input entered by however many tokens)
05:44:21 <wli> I'm really getting some kind of weird insight into parsing. With the multistage stuff from last night and this stuff now, there could almost be a project here.
05:45:32 <wli> The big hole in it is how to hand back parse trees.
05:46:47 * wli drops a pin.
05:50:36 <wli> I remember I had a strategy: rose trees with labelled nodes, something like data Parse terminal nonterminal = Parse nonterminal [Either (Parse terminal nonterminal) terminal]
05:53:15 <wli> I'd probably use something like data Parse terminal nonterminal = Parse Int nonterminal (Seq (Either (Parse terminal nonterminal) terminal))
05:53:30 <wli> Where the Int specifies the reduction rule used.
05:55:21 <hallongrottan> is there a function in the standard libraries to compute base-10 logarithms?
05:55:36 <opqdonut> :t logBase
05:55:37 <lambdabot> forall a. (Floating a) => a -> a -> a
05:55:41 <hallongrottan> oh snap!
05:55:43 <hallongrottan> thanks :)
05:55:46 <opqdonut> > logBase 10 1000
05:55:48 <lambdabot>   2.9999999999999996
05:56:23 <hallongrottan> lol
05:56:49 <EvilTerran> > logBase 10 1000 :: CReal
05:56:51 <lambdabot>   3.0
05:57:22 <opqdonut> but CReals can't tell us that's exactly 3.0 right?
05:58:06 * EvilTerran doesn't know; all i know is that CReal has an uncanny habit of getting the right answer, not how it goes about doing that
05:58:33 <opqdonut> CReals are printed to some default precision in their show instance iirc
05:58:37 <opqdonut> > pi :: CReal
05:58:39 <lambdabot>   3.1415926535897932384626433832795028841972
05:59:04 <opqdonut> logBase 10 1000.000000000000001 :: CReal
05:59:12 <opqdonut> > logBase 10 1000.000000000000001 :: CReal
05:59:13 <lambdabot>   3.000000000000000000434294481903251827434
05:59:18 <wli> > exp (0 :+ pi) :: Complex CReal
05:59:20 <lambdabot>   (-1.0) :+ 0.0
05:59:20 <opqdonut> > logBase 10 1000.00000000000000000000000000000000000000001 :: CReal
05:59:21 <lambdabot>   3.0
05:59:25 <opqdonut> there :)
05:59:39 <wli> I thought my example was interesting.
06:00:27 <porges> instance Magic CReal where ..
06:00:47 <doserj> > (1::CReal) == 1.000000000000000000000000000000000000000001
06:00:48 <lambdabot>   True
06:00:50 <doserj> > (1::CReal) == 1.00000000000000000000000000000000000000001
06:00:52 <lambdabot>   False
06:03:41 <wli> I'm not sure I want to think of how crappy a grammar has to be to be LR(0) or LL(0).
06:03:44 <PeakerWork> "cabal install agda" installs no executable.  Have to wrap it with a main=Agda.Main.main  executable
06:04:31 <swiert> PeakerWork: try "cabal install Agda-executable"
06:04:53 <PeakerWork> swiert: that's silly
06:05:11 <PeakerWork> swiert: but thanks :)
06:05:31 <swiert> PeakerWork: yeah. The idea is that other people may want to write different front-ends.
06:05:41 <swiert> But it's kind of confusing.
06:06:14 <PeakerWork> swiert: but Agda.Main in the library is suitable just for this, so why not have an executable instead of it? Also, having an exe and a lib does not prevent you from using the lib
06:06:24 <pejo> swiert, why not have the executable in the same package, with the library?
06:06:30 <PeakerWork> and if they do separate it this way, libagda and agda are nicer than agda and agda-executable
06:06:57 <swiert> I'm not sure what the underlying design decision has been.
06:07:02 <PeakerWork> "The interactive mode is no longer supported. Don't complain if it doesn't work." :-(
06:07:24 <swiert> I don't know why they didn't just bundle it in one package.
06:10:36 <NameAlreadyInUse> @unproc
06:10:36 <lambdabot> Unknown command, try @list
06:10:54 <KoenigGunther> Hi!
06:12:30 <NameAlreadyInUse> in the haskell wikibook, they have an example of arrow notation: idA :: a -> a; idA = proc a -> returnA -< a
06:12:36 <littlemog> hi, i'm trying to write something that will return the second last element in a list. -- if (length [a]) == 2 then head [a] else function (tail[a])    it loads into ghci but returns Exception: ... non-exhaustive pattern... when i feed it a list... why?
06:12:46 <NameAlreadyInUse> but it is never explained how this notation translates to arrows
06:12:54 <ivanm> littlemog: do you take empty lists into account?
06:13:02 <ivanm> or even singleton element lists?
06:13:09 <littlemog> ivanm: not at the moment :(
06:13:16 <ivanm> then that's why it's complaining!
06:13:23 <ibid> littlemog: that program example is broken anyway, since length [a] is always 1
06:13:31 <littlemog> ivanm: ah... ok
06:13:33 <wli> length [a] == 1
06:13:38 <ivanm> "nonexhaustive" == "you missed a pattern match"
06:13:40 <littlemog> ibid: thanks
06:14:07 <KoenigGunther> Can you tell me whats wrong with my code?
06:14:07 <KoenigGunther> http://paste.ubuntuusers.de/394491/
06:14:11 <littlemog> ok
06:14:11 <ibid> littlemog: you probably mean a not [a] - depending on what else is in the definition
06:14:30 <KoenigGunther> I always get this error message:runhugs: Error occurred
06:14:30 <KoenigGunther> ERROR "main.hs":20 - Cannot justify constraints in explicitly typed binding
06:14:30 <KoenigGunther> *** Expression    : main
06:14:30 <KoenigGunther> *** Type          : IO ()
06:14:30 <KoenigGunther> *** Given context : ()
06:14:30 <KoenigGunther> *** Constraints   : (Show a, Arbitrary a, Ord a)
06:14:43 <ivanm> KoenigGunther: you should really paste the error with the code
06:14:44 <littlemog> i'll go rework the code. thanks guys
06:15:01 <Saizan__> NameAlreadyInUse: there should be a description in the ghc manual, or you can play with the preprocessor here http://www.haskell.org/arrows/syntax.html
06:15:02 <KoenigGunther> yes, sorry
06:15:12 <ivanm> KoenigGunther: and it looks like your code assumes that "a" is an instance of Show, Arbitrary and Ord, but your type constraint doesn't specify that
06:16:21 <Saizan__> ivanm: no
06:16:31 <KoenigGunther> Here is an updated version: http://paste.ubuntuusers.de/394492/
06:16:36 <ivanm> Saizan__: OK, I'm wrong, I can admit it ;-)
06:16:39 <Saizan__> the problem is that you didn't pick a type for the element of the list
06:16:41 * ivanm has never used QC before
06:16:55 <ivanm> Saizan__: yes, so isn't it choosing the most lax one it can?
06:17:04 <ivanm> one that doesn't have those type constraints?
06:17:14 <ivanm> that's how I interpreted it, anyway...
06:17:16 <KoenigGunther> ah, so if I say that prop_InsertOrdered only should use Integer for example it works?
06:17:31 <Saizan__> ivanm: defaulting doesn't work with non-standard classes
06:17:37 <Saizan__> KoenigGunther: yes
06:17:40 <ivanm> oh, yeah
06:18:12 <KoenigGunther> damn
06:18:13 <KoenigGunther> :D
06:18:24 <KoenigGunther> Thank you!
06:18:30 <Saizan__> KoenigGunther: e.g. main = quickCheck (prop_InsertOrdered :: Integer -> [Integer] -> Bool)
06:18:53 <NameAlreadyInUse> alright, i'm using the preprocessor from that page
06:18:57 <NameAlreadyInUse> thanks Saizan
06:19:04 <KoenigGunther> thank you Saizan
06:19:13 <Saizan__> np :)
06:20:12 <mikhail^> hi guys, I have a type called UserData and I wanted to make it JSON encodable
06:20:55 <mikhail^> I'm reading the Text.JSON documentation, but I'm getting confused with making the type an instance of the JSON typeclass
06:21:56 <NameAlreadyInUse> how is it possible that i can say "let idA :: a -> a; idA = returnA"
06:22:17 <NameAlreadyInUse> when returnA's signature is: (Arrow a) => a b b
06:22:31 <mikhail^> is there a more intuitive/noob-friendly guide to making my types JSON encodable out there?
06:22:41 <Saizan__> because (->) is an instance of Arrow
06:23:01 <NameAlreadyInUse> oh, now i understand
06:23:05 <Saizan__> mikhail^: what problem are you having?
06:23:27 <NameAlreadyInUse> is it possible to make (->) an instance of other types?
06:23:38 <Botje> sure
06:23:42 <Botje> \bot has a show instance:
06:23:43 <wli> Hmm. I think in the scheme I've got going, labels are always under the scope of some constructor except during extension operations.
06:23:44 <Botje> > id
06:23:45 <lambdabot>       Overlapping instances for Show (a -> a)
06:23:45 <lambdabot>        arising from a use of `s...
06:23:51 <Saizan__> s/type/typeclasses/
06:23:54 <Botje> it has several, even!
06:24:01 <mikhail^> Saizan__, I'm trying to do 'instance JSON UserData where showJSON user = toJSONObject [ ... ]'
06:24:04 <NameAlreadyInUse> heh
06:24:30 <Saizan__> mikhail^: looks right so far
06:25:19 <Saizan__> mikhail^: ah, wait, you've to wrap that in the JSObject constructor
06:25:47 <mikhail^> Saizan__, in the [...] are `("id", show $ fromJust (user_id user) ), ("somefield", show $ fromJust (somefield user))`
06:26:01 <wli> I think that means that I should qualify labels with constructors during extensions.
06:26:11 <Saizan__> showJSON user = JSObject (toJSObject [ .. ])
06:26:19 <mikhail^> Saizan__, Ah, let me try that...
06:26:56 <Saizan__> and you've to wrap the values in constructors too
06:27:29 <mikhail^> Saizan__, nice, thanks! I'll do a little more and find out if it works out better.
06:28:24 <Saizan__> you can probably substitute show with showJSON in your example
06:29:20 <zeno> is this not in 6.10? unsupported extension: XMultiParamTypeClasses
06:29:37 <Saizan__> remove the X
06:29:43 <zeno> thanks
06:30:26 <zeno> the error still tells me to use the -X.. is that a bug?
06:30:54 <Saizan__> -X<Extension> is the cli flag
06:31:12 <Saizan__> but in the LANGUAGE pragma you just use the <Extension> part
06:31:27 <mikhail^> Saizan__, You're right! It compiles now. I'll try showJSON later. :)
06:31:56 <Saizan__> nice :)
06:33:04 <mreh> what the shizzle do curly braces do?
06:33:21 <mreh> s1{ship = moveShip (ship s1)} where
06:33:21 <mreh>   s1 = foldl procEv s evs
06:33:37 <ibid> mreh: they're an alternative to indentation
06:33:38 <mreh> is that some kind of record access?
06:33:44 <ibid> that one is
06:34:18 <ibid> mreh: foo { bar = baz } returns foo except that bar has baz as its value
06:34:19 <mreh> are records mutable?
06:34:23 <ibid> mreh: no
06:34:39 <ibid> mreh: basically, it makes a copy with the specified changes
06:34:41 <mreh> boyakasha
06:34:45 <mreh> okay
06:34:47 <ibid> ?
06:34:56 <mreh> haven't you heard of Ali G?
06:39:42 <ivanm> mreh: I prefer Borat
06:41:18 <Baughn> dons: I may be misunderstanding what I'm seeing, so - is there any way to catch parsing failures from Data.Binary in pure code?
06:42:24 <chessguy_work> 'morning
06:42:33 <mikhail^> Okay, now my problem becomes I get a segfault in my app -- what's the best way to track down where the segfault is coming from?
06:43:21 <jmcarthur> mikhail^, are you using the FFI?
06:43:41 <mikhail^> jmcarthur, I think so -- I'm using SimpleHTTP and HaskellDB
06:43:47 <jmcarthur> if not, then it's either a bug in ghc or a bug in one of the libraries you are using
06:43:57 <jmcarthur> hmm...
06:44:14 <mikhail^> jmcarthur, right so what's the easiest way to pinpoint where it's going wrong?
06:44:19 <wli> Right now I have something like ExtExpr being "exp with { lab1 = exp1, lab2 = exp2, ...}" but all records are variant records, with constructors, like Haskell data Record = Con1 { lab1_1 :: t1_1, lab1_2 :: t1_2, ... } | Con2 { lab2_1 :: t2_1, ... } | ...
06:44:32 <jmcarthur> i have no idea how to track down a segfault other than something like Debug.Trace or something
06:44:50 <jmcarthur> which i, admittedly, have zero experience with
06:45:07 <jmcarthur> some swear by it for debugging, but i haven't run into a problem that i felt required it yet
06:45:18 <mikhail^> jmcarthur, I was going to ask how do I create a core or something
06:45:26 <chessguy_work> anybody see simon marlow's Go code sent to -cafe this morning? looks pretty cool, though quite messy
06:45:26 <mikhail^> will google Debug.Trace
06:46:11 <wli> So I'm thinking I have to make ExtExpr be something like "exp with Con1 { lab1_1 = exp1_1, lab1_2 = exp1_2, ...} | Con2 { lab2_1 = exp2_1, ... }" so each label is always under the umbrella of a constructor.
06:46:14 <jmcarthur> chessguy_work, what thread is it in?
06:46:37 <chessguy_work> jmcarthur, "Go Haskell!"
06:46:39 <jmcarthur> oh i found it
06:46:41 <jmcarthur> thx
06:48:23 <jmcarthur> ugly haskell code always makes me perk up because i like to try making it pretty
06:48:50 <chessguy_work> :)
06:49:03 <chessguy_work> well this has a lot of performance hacks, so that could make it pretty har
06:49:04 <chessguy_work> d
06:49:10 <jmcarthur> not necessarily
06:49:29 <jmcarthur> performance hacks are best when abstracted :)
06:49:42 <chessguy_work> hm, good point
06:49:48 <jmcarthur> i just like to see when it's possible and when it's not
06:50:00 <jmcarthur> and when it's not, i like to think about what would _make_ it possible
06:51:00 <chessguy_work> i'm still trying to grok what he's trying to accomplish. i suspect some sort of monte carlo style
06:53:44 <chessguy_work> yeah
06:53:44 <chessguy_work> randomPlayout :: Seed -> Board -> Player -> IO ([Vertex],RandomPlayoutResult)
06:54:27 <BONUS> why do you need a seed and IO
06:55:56 <chessguy_work> i think he's just using IO for IORefs
06:57:04 <jmcarthur> yeah, it's extremely imperative
06:57:28 <chessguy_work> yeah
06:57:49 <jmcarthur> i think this is beyond saving. would probably need a rewrite to get a more declarative style
06:58:01 <chessguy_work> shame
06:58:25 * jmcarthur goes back to work with c++ :(
06:58:37 * chessguy_work goes back to work with c# :(
06:58:46 <jmcarthur> c# is waaaay better than c++
06:58:52 <jmcarthur> consider yourself lucky
06:58:58 <vininim> no wai
06:59:04 <chessguy_work> c# is waaaay worse than haskell
06:59:04 <jmcarthur> it even has lambdas and closures!
06:59:09 <jmcarthur> agreed :)
06:59:23 <ibid> c++ will have lambdas, i believe
06:59:24 <chessguy_work> not in our version of .Net
06:59:40 <jmcarthur> c++ will have closures as well, i believe
06:59:41 <Baughn> ibid: Does already, via boost
06:59:45 <Baughn> Doesn't mean it's /nice/
06:59:45 <chessguy_work> we barely have delegates
06:59:53 <jmcarthur> chessguy_work, ew :(
06:59:55 <yitz> what are you talking about, they're adding laziness to c++ now
07:00:05 <Baughn> And of course the memory-management issues when using closures in C++ are.. stunning. :P
07:00:06 <yitz> sort of
07:00:08 <ibid> Baughn: i'm talking about the new method proposed for c++0x
07:00:20 <Baughn> ibid: Are they also adding a real GC?
07:00:31 <mikhail^> okay, I think this is a stupid question: can a Monadic function (that yields IO ()) call itself recursively?
07:00:40 <Baughn> mikhail^: Yes
07:00:46 <Axman6> Kvasir: sure
07:00:47 <ibid> Baughn: i think there has been some talk about it, but i haven't looked at it recently
07:00:51 <nullterminated> ya mik
07:00:51 <Baughn> mikhail^: (See Control.Monad.forever, and friends
07:01:02 <ibid> Baughn: though it's obvious they won't make it mandatory
07:01:12 <jmcarthur> the new method proposed for c++0x is still going to suffer from the same (or worse) problems as c++'s extensions to C though. the requirement to be extremely low-level wreaks havoc on it all
07:01:14 <mikhail^> Baughn, oh okay. Thanks. :)
07:01:20 <Axman6> let ohNoes = putStr ":O " >> ohNoes
07:01:47 <lilac> Baughn: no GC in C++0x I think, but Hans Boehm is On The Case
07:02:06 <Baughn> mikhail^: A common pattern is "fix $ \fun -> do stuff; fun"
07:02:13 <jmcarthur> contrary to what a lot of people say, i don't think it's a fault of the designers at all. it's simply hard to combine things like closures and pointer math into the same language
07:02:15 <Axman6> wonder if Apple's GC would work well with C++, it's supposed to be fairly generic
07:02:19 * mikhail^ doesn't think C++0x needs a GC. ;)
07:02:28 * vininim 2
07:02:29 <lilac> @go wg21 papers
07:02:31 <lambdabot> http://www.open-std.org/jtc1/sc22/wg21/docs/papers/
07:02:31 <lambdabot> Title: C++ Standards Committee Papers
07:02:31 <Axman6> Baughn: not in my world >_<
07:02:34 <vixey> how can you have lambda and no GC
07:02:36 <mikhail^> Baughn, oh nice. let me try that.
07:02:44 <jmcarthur> vixey, by breaking the lambdas
07:02:47 <nullterminated> what is c++0x?
07:02:55 <lilac> vixey: when they say closures, they mean openures
07:03:02 <Axman6> the new C++ standard
07:03:02 <Baughn> Axman6: Well, it's the simplest way to get an anonymous self-calling do block. ;)
07:03:15 <Axman6> yeah,  but... why would i want to? :P
07:03:15 <Baughn> Though I suppose it's not entirely anonymous
07:03:19 <yitz> @type fix $ \fun -> do return (); fun
07:03:20 <vininim> nullterminated: c++05(?) postponed until c++xy
07:03:22 <lambdabot> forall (t :: * -> *) t1. (Monad t) => t t1
07:03:59 <Axman6> > fix $ \fun -> do return (); fun :: [()]
07:04:01 <lambdabot>   * Exception: stack overflow
07:04:10 <lilac> vixey: you have a choice: either you take a reference to the variables/stack frame (and crash horribly and vulnerably if the stack frame has gone away)
07:04:12 <Axman6> > fix $ \fun -> do return (); fun :: Maybe ()
07:04:14 <lilac> vixey: or you take a copy
07:04:24 <Axman6> ...
07:04:27 <lambdabot>   thread killed
07:04:31 <Axman6> there we go
07:04:35 <Axman6> anyway, night all
07:04:47 <mikhail^> Okay, fix sounds a little weird for my case... Let's say I have a list that I want to deal with that's passed as a parameter to the monadic function
07:04:50 <lilac> vixey: such is c++ ;-)
07:04:51 <mikhail^> so I have a function:
07:05:12 <mikhail^> indexAndSave :: [(Int, Int)] -> IO ()
07:05:18 <Baughn> Axman6: Well, sure, but that's different
07:05:39 <lilac> mikhail^: are you aware of mapM_ ?
07:05:39 <mikhail^> I was thinking initially that I should be able to recursively call indexAndSave until [] matches (just like pure functions)
07:05:47 <lilac> @type mapM_
07:05:48 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
07:06:03 <lilac> @src mapM_
07:06:03 <lambdabot> mapM_ f as = sequence_ (map f as)
07:06:08 <lilac> @src sequence_
07:06:09 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
07:06:20 <Baughn> mikhail^: You can, though you might prefer foldM or some such
07:06:35 <mikhail^> lilac, Yup, I was trying to avoid the returning of a list
07:06:47 <lilac> mikhail^: mapM_ doesn't return a list
07:07:04 <lilac> mikhail^: that's the difference between mapM and mapM_
07:07:05 <nullterminated> mik have it return IO [ Int, Int ]
07:07:34 <mikhail^> Baughn, foldM sounds like something I can deal with... Is there a left fold so it performs better?
07:07:36 <nullterminated> instead of io ()
07:07:44 <lilac> mikhail^: fwiw, mapM_ f [] = return (); mapM_ f (x:xs) = do f x; mapM_ f xs
07:07:57 <yitz> @type foldM
07:07:58 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
07:08:50 <yitz> @hoogle foldM
07:08:50 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
07:08:50 <lambdabot> Control.Monad foldM_ :: Monad m => (a -> b -> m a) -> a -> [b] -> m ()
07:08:50 <lambdabot> Data.Foldable foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
07:09:19 <mikhail^> lilac, hmmm... so f's signature for mapM_ would look like 'f :: (Int, Int) -> IO ()' ?
07:09:31 <chessguy_work> jmcarthur, what do you think a functional interface to something like what Simon was trying to do would be?
07:10:00 <Baughn> mikhail^: foldM is already a left-fold
07:10:03 <jmcarthur> i will need to take a closer look at it later and see. i'm at work right now and probably shouldn't devote too much time to this yet
07:10:25 <mikhail^> Oh, it should be 'f :: (Int, Int) -> IO (Int, Int)' ... or did I completely miss that?
07:10:49 <zeno> mikhail^: could be depends what you are trying to do
07:10:50 <Saizan_> mikhail^: it can be either, the result is discarded by mapM_
07:10:54 <mikhail^> Baughn, great, I'll try converting it into a fold.
07:11:07 <mikhail^> Saizan_, nice. Thanks. :)
07:11:12 <yitz> > let f s c = [s,s+c..200] in length $ foldM f 0 [200,100,50,20,10,5,2]
07:11:13 <lambdabot>   73682
07:11:23 <yitz> well, what do you know
07:12:13 <yitz> Axman6, wli: ^
07:13:54 <wilkes> Can anyone point me to a project using the com package?  The InArg, OutArg, ResArg's are confusing to me.
07:15:49 <yitz> @hoogle ResArg
07:15:49 <lambdabot> No results found
07:16:01 <yitz> com package?
07:17:43 <quicksilver> I've never heard of anyone using the COM stuff.
07:19:23 <yitz> oh, windows COM?
07:20:39 <yitz> wilkes: windows COM?
07:20:48 <wilkes> yes
07:21:23 <wilkes> yitz: I couldn't find anything under Hayoo or Hoogle
07:22:16 <yitz> wilkes: i wouldn't have even looked for a com package. I would just assume that you write the com layer in C and then access it via the FFI.
07:23:25 <wilkes> yitz: haha, I haven't touched C in a decade, and have never done COM programming with anything but a high-level wrapper
07:23:40 <tromp_> chessguy_work: where do you see this  randomPlayout?
07:23:53 <yitz> wilkes: true, it's a lot messier in c
07:24:01 <chessguy_work> tromp_, in the code that simon marlow sent to -cafe
07:24:12 <chessguy_work> the thread is "go haskell!"
07:24:37 <yitz> wilkes: you could do the com in python and then access it via MissingPy
07:24:49 <tromp_> is that a newsgroup?
07:24:51 <yitz> that'll be slower of course
07:25:09 <chessguy_work> tromp_, a mailing list called haskell-cafe
07:26:29 <EvilTerran> ?where cafe
07:26:29 <lambdabot> I know nothing about cafe.
07:26:32 <wilkes> yitz: interesting, I already have some py code that does what I need, that would be a useful bridge for me
07:26:40 <EvilTerran> ?where haskell-cafe
07:26:41 <lambdabot> http://www.haskell.org/mailman/listinfo/haskell-cafe
07:27:08 <yitz> wilkes: haven't tried it with the current ghc, but it worked great with 6.8
07:27:42 <chessguy_work> tromp_, here's the particular thread the code is on: http://www.haskell.org/pipermail/haskell-cafe/2009-March/057982.html
07:28:08 <tromp_> thx
07:29:51 <tromp_> funny, it says komi 5.5 may be high on 9x9 :)
07:30:09 <tromp_> the opposite is true
07:31:28 <mikhail^> @type lift
07:31:29 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Monad m, MonadTrans t) => m a -> t m a
07:32:47 <yitz> tromp_: simon's run of thousands of random games indicated and advantage for white with 5.5. But that may not have been a realistic simulation.
07:32:57 <yitz> s/and/an/
07:33:42 <ImInYourMonad> hmm i writing a graphic Go
07:34:44 <ImInYourMonad> i will put it on Hackage when it is done. i plan to make it a complete humna vs computer game and make it easy to write AI-strategies for it and implement some basic ones myself
07:36:05 <yitz> could be part or most of black's advantage comes from the ability to drive the opening. which would yield a more pronounced advantage on 9x9, and would disappear altogether when playing computer-generated random games.
07:37:02 <yitz> tromp: simon's run of thousands of random games indicated an advantage for white with 5.5. But that may not have been a realistic simulation.
07:37:05 <yitz> could be part or most of black's advantage comes from the ability to drive the opening. which would yield a more pronounced advantage on 9x9, and would disappear altogether when playing computer-generated random games.
07:38:07 <quicksilver> it's certainly an unrealistic assumption to imagine that random games are statistically representative of real games.
07:38:28 <quicksilver> on the ohter hand, it's anyone's guess how the differencee would manifest
07:39:51 <mikhail^> okay, yet another question -- how do you re-use an existing ODBC connection so that every query you make you don't need to re-connect to ODBC?
07:39:54 <yitz> quicksilver: i wonder if the simulation had any intelligence at all - like avoiding obvious suicide movers
07:40:13 <tromp> certainly for strong 9x9 programs b has a distinct advantage with 5.5 komi
07:40:19 <mikhail^> I have the convenience function 'withDB' as defined in the HaskellDB example
07:40:30 <tromp> that code does look awfully imperative:(
07:40:49 <tromp> wonder who wrote the original in F#
07:40:56 <yitz> heh
07:41:22 <tromp> might be a port from libego
07:41:36 <tromp> a C++ library
07:55:07 <mun> i'm trying to install the package HTTP-3000.0, but i get the error saying "Could not find module `Data.ArrayMArray' it is a member of package array-0.2.0.0, which is hidden. does anyone know how to fix this?
07:55:51 <quicksilver> I think it indicates that HTTP's dependencies are wrong.
07:55:55 <quicksilver> I'm not sure why that would be.
07:56:14 <mun> hmmm
07:56:52 <jmcarthur> mun, add "array" to the list of dependencies in the .cabal file for HTTP
07:57:03 <mun> ok
07:57:04 <mun> thanks
07:57:05 <jmcarthur> but yeah, you shouldn't have to do that anyway
07:57:12 <jmcarthur> something must be wrong
07:58:32 <ImInYourMonad> anyone know what happens if the board is filled in Go? can it not be?
07:58:35 <ImInYourMonad> i cant find a rule for it anywhere
07:58:46 <ImInYourMonad> basically i dont really know Go but still trying to writ it :)
07:58:57 <blackh> ImInYourMonad: It's the end of the game.
07:59:01 <doserj> mun: 3000.0 is a very old version, before the base split. 3001.0 should work
07:59:08 <EvilTerran> ImInYourMonad, the board can't be full; if it was, no groups would have any liberties
07:59:11 <EvilTerran> and they'd all die
07:59:20 <EvilTerran> and the board would be blank again :P
07:59:36 <doserj> EvilTerran: no. there would be only stones of one color left
07:59:41 <mikhail^> okay, I think I've narrowed down the bug I'm encountering (segfault) from HaskellDB -- is there a way of re-using a connection to the ODBC driver instead of connecting every time you have a query to ODBC?
07:59:56 <mun> doserj, the reason i'm installing 3000.0.0 is because the guys have changed the type for Response in later version. definitely in 4000.0
07:59:59 <EvilTerran> doserj, ah, true, the player who played the last stone would get to keep his group
08:00:01 <mun> but i'll give 3001.0 a try
08:00:19 <doserj> EvilTerran: yes
08:00:55 <quicksilver> ImInYourMonad: real games tend to have at least one eye
08:01:07 <quicksilver> which inherently mean the board can't be filled...
08:01:15 <mun> if i already have HTTP-4000.0 installed, does --reinstall remove 4000.0 with the indicated version?
08:01:15 <quicksilver> unless the player is stupid enough to fill his own eye
08:01:22 <quicksilver> which is a legal move, I guess.
08:01:44 <doserj> quicksilver: in most rules, suicide is disallowed. but there is no real reason for that
08:01:56 <lilac> presumably the go board being entirely full isn't necessarily even the end of the game?
08:02:03 <EvilTerran> the board can only be full between a stone being played and removing a resulting dead group
08:02:19 <lilac> although it probably is if both players are competent
08:02:31 <EvilTerran> so, by the start of the other player's turn, there'd be spaces available to play again
08:03:06 <quicksilver> doserj: filling an eye isn't suicide, per se
08:03:14 <quicksilver> doserj:  your opponent then fills the other hole
08:03:18 <quicksilver> doserj: and takes you
08:03:30 <quicksilver> playing into your own safe territory isn't suicide, it's just stupid.
08:03:41 <quicksilver> even more stupid when you remove the bits that make it safe.
08:04:05 <quicksilver> EvilTerran: the board can ultimately be full of one colour's pieces
08:04:16 <doserj> quicksilver: you can fill the board without ever playing inside your own territory
08:04:28 <quicksilver> EvilTerran: although normally you'd expect to stop with one empty space :)
08:04:38 <quicksilver> doserj: right, but you have to play inside your own territory to fill an eye.
08:04:42 <quicksilver> doserj: which was my point.
08:04:57 <doserj> quicksilver: you can fill the board without there ever being an eye to fill
08:05:02 <quicksilver> of course.
08:05:14 <quicksilver> which is why I said "...real games tend to have at least one eye..."
08:05:18 <quicksilver> in my introduction to that point.
08:05:53 <EvilTerran> doserj, if all of the board was full except for one corner space, that'd be an eye, though
08:06:31 <doserj> EvilTerran: not necessarily
08:06:48 <EvilTerran> admittedly, of a one-eyed (and so dead) group
08:07:26 <doserj> EvilTerran: it could also be a dame point (of two groups with no eyes)
08:08:05 <EvilTerran> doserj, ah; yeah, i was thinking stones of one colour. never mind.
08:08:11 <quicksilver> EvilTerran: yes, I was using the terminology wrongly.
08:08:26 <quicksilver> EvilTerran: in some of the places I said eye, I really meant "group with two eyes"
08:08:33 <quicksilver> lazy.
08:09:45 <EvilTerran> i guess it's a false eye if it's not surrounded by living stones, anyway
08:11:35 <cnwdup> @check \bs -> (foldl' (\a b -> shiftL a 8 .|. fromIntegral b) 0) === (foldl' (\a b -> shiftL a (bitSize b) .|. fromIntegral b) 0
08:11:35 <lambdabot>  Unbalanced parentheses
08:11:48 <cnwdup> @check \bs -> (foldl' (\a b -> shiftL a 8 .|. fromIntegral b) 0) === (foldl' (\a b -> shiftL a (bitSize b) .|. fromIntegral b) 0)
08:11:49 <lambdabot>   Not in scope: `==='
08:12:45 <cnwdup> @check \bs -> (foldl' (\a b -> shiftL a 8 .|. fromIntegral b) 0) == (foldl' (\a b -> shiftL a (bitSize b) .|. fromIntegral b) 0)
08:12:46 <lambdabot>       No instance for (Eq ([b] -> a))
08:12:46 <lambdabot>        arising from a use of `==' at <i...
08:13:36 <cnwdup> Ah, nevermind... Have to go.
08:14:12 <mikhail^> okay, soon as I perform a second query with a different set of parameters with HaskellDB I get a segfault in my app
08:14:38 <blackh> If the board is completely filled, then it gets completely emptied, but this is illegal because of the rule of ko.  That makes every move illegal, which means that the game ends
08:14:40 <mikhail^> is there a good way of debugging a segfault?
08:15:02 <blackh> mikhail^: No.  I have debugged many segfaults, so therefore I should know.
08:15:12 <mikhail^> even running it in ghci causes a segfault -- using ghc 6.10.1
08:15:13 <blackh> mikhail^: A better answer is that you should use gdb and valgrind.
08:15:24 <quicksilver> mikhail^: recompile with -debug and then use gdb
08:15:27 <quicksilver> you may learn more.
08:15:38 <mikhail^> will gdb show the Haskell code?
08:15:57 <blackh> mikhail^: No, but the Haskell code won't be the cause of the seg fault.
08:16:19 <mikhail^> blackh, okay, thanks. Hopefully this gives me a better idea
08:16:30 <blackh> mikhail^: valgrind is sometimes better than gdb because it finds the segfault exactly when it happens, rather than when the bad knock-on effects happen.
08:16:50 <quicksilver> mikhail^: I'm sorry this channel is not being more helpful but none of use have used haskellDB
08:16:53 <mun> does anyone know how to use cabal to remove a package?
08:17:12 <quicksilver> segfaults with an FFI library are usually due to breaking some invariant the C library expects.
08:17:20 <blackh> mun: ghc-pkg unregister <package>. Cabal can't currently do it.
08:17:23 <quicksilver> I've had them by dropping a reference so it gets GCed while the C code still needs it.
08:17:23 <pejo> mun, ghc-pkg unregister
08:17:28 <mun> ah ok
08:17:29 <mun> thanks
08:17:45 <mikhail^> blackh, I'll try valgrind too, thanks.
08:18:15 <mikhail^> quicksilver, it's alright. I can imagine how frustrating something like that would be -- dropping to a lower level is never fun especially if you can avoid it
08:18:36 <blackh> mikhail^: Do you have to use SQL?
08:18:50 <mikhail^> so looks like my database server isn't keeping connections persistent from the looks of the trace from gdb
08:19:07 <quicksilver> maybe you let the 'db' reference get garbage collected
08:19:15 <quicksilver> and that drops the connection
08:19:17 <blackh> (I ask because I am always trying to find ways to eliminate SQL from planet Earth.)
08:19:21 <quicksilver> this is pure guesswork on my part.
08:19:22 <mikhail^> blackh, I'm using HaskellDB to deal with a MySQL database that I access through HDBC.ODBC
08:19:34 <mikhail^> blackh, no SQL from the Haskell code
08:19:52 <mikhail^> quicksilver, I'm guessing the same. How do I ensure that something doesn't get GC'd?
08:20:30 <quicksilver> do something stupid to make it obvious you need to keep it alive
08:20:38 <quicksilver> like adding "print db" as the last line of your program
08:21:19 <mun> blackh, i'm trying to unregister HTTP-4000.0.4, which is listed under $HOME/.ghc/x86_64-linux-6.8.2/package.conf. but when i unregistr, it says it cannot be found.
08:21:53 <mikhail^> quicksilver, right, but I already do this: 'do { let connection = withDB "mydb" ; mapM_ (\x -> dealwith x connection) ranges }'
08:21:59 <blackh> mun: Try ghc-pkg list, and copy & paste, just in case there's a typo somewhere
08:22:31 <quicksilver> mikhail^: that is deliberately opening a new connection each time.
08:22:37 <blackh> mun: Also note that packages can be install globally or in the user's home directory
08:22:38 <mun> blackh, tried that too. "ghc-pkg: cannot find package HTTP-4000.0.4"
08:22:45 <quicksilver> mikhail^: doesn't look right.
08:22:51 <quicksilver> mikhail^: can you paste some code to hpaste?
08:22:54 <mikhail^> quicksilver, hmmm... so any idea how I can re-use an existing connection?
08:23:07 <quicksilver> yes, don't keep calling withDB over and over again
08:23:08 <quicksilver> call it once
08:23:10 <mun> blackh, are the ones in the user's home directory removed the same way, i.e. via ghc-pkg unregister?
08:23:13 <blackh> mun: Does it appear in the global list or the local list?
08:23:20 <mun> blackh, the local list
08:23:24 <mikhail^> quicksilver, yup, I'll sanitize (remove proprietary stuff) then show the section which I suspect does segfault
08:23:43 <blackh> mun: It has worked for me on several occasions, and I think I've run out of obvious things to tell you.
08:24:01 <blackh> mun: I have always installed locally
08:24:11 <mun> blackh, hmm okay
08:24:20 <blackh> mun: Try without the version number
08:25:52 <mun> blackh, tried that too
08:25:54 <Saizan_> mun: do you have multiple ghc installed?
08:26:02 <Saizan_> mun: each one uses its own ghc-pkg
08:26:11 <mun> Saizan_, hmm.. yes i do 6.8 and 6.10
08:26:30 <mun> indeed
08:26:38 <mun> ghc-pkg is the 6.8.2
08:26:40 <mcnster> exception q.  the ghc docs give an example of:  catch (openFile f ReadMode) (\e -> hPutStr stderr "<msg>") yet this will fail type checking.  how do i return an "IO Handle" type in the handler?
08:26:56 <mikhail^> quicksilver, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2558#a2558
08:27:12 <mun> thanks for that
08:27:25 <vixey> yiikes \x -> UserData (x!xid) (x!firstname) (x!photo) (x!photorandom)
08:27:33 <vixey> this is horrible
08:28:06 <quicksilver> mikhail^: passing "connection" around is badly broken.
08:28:17 <Saizan_> vixey: why so?
08:28:25 <quicksilver> mikhail^: "connection" (defined as 'withDB "foo"') is a piece of code to open a new connection
08:28:30 <abuiles> Hi, guys, I was wondering if there is any possibility of spliting a string based in a regular expression returning just the groups specified in the regexp, for example :  "foo - foo - foo" =~ "((.*)-(.*)-(.*)" should return [foo,foo,foo]. I'm doing that recursively, but I think the solution with the regexp will look nicer,
08:28:55 <quicksilver> abuiles: yes, haskell's regexp library can do that.
08:29:01 <mikhail^> vixey, was the quickest way to construct an object
08:29:02 <Workybob> @faq can Haskell make Twigathy beer
08:29:02 <lambdabot> The answer is: Yes! Haskell can do that.
08:29:05 * Twigathy pokes Workybob in the lurk
08:29:26 <Twigathy> What's the type of Beer? :o
08:29:35 <abuiles> quicksilver: Text.Regex.Posix?
08:29:37 <Workybob> @vixen what type of beer would you make Twigathy?
08:29:37 <lambdabot> any type will due
08:29:44 <quicksilver> abuiles: yeah, or one its friends
08:29:51 <quicksilver> mikhail^: do you see what I meant?
08:30:03 <quicksilver> mikhail^: so, by passing that piece of code around and continually re-executing it
08:30:16 <mikhail^> quicksilver, so the suggestion would be that instead of just partially binding the arguments I complete it and then the resulting object is what I pass around... right?
08:30:32 <abuiles> quicksilver: thanks
08:30:35 <quicksilver> yes, at the top(ish) level you : withDB "foo" $ \db -> ....
08:30:41 <quicksilver> and then it's the "db" that you pass around.
08:32:56 <mikhail^> quicksilver, so in 'main' i can do that connect once then do something like 'connection <- connect driver ["dsn", "dsn"]' then use connection instead?
08:33:18 <quicksilver> somethign like that.
08:38:33 <mikhail^> hmmm... that doesn't seem to work. apparently it seems that the 'withDB' function requires a third argument that contains the actual HaskellDB query to be performed (a monad at that)
08:39:01 <mikhail^> well, second I mean after the name of the data source
08:39:29 <Saizan_> mikhail^: what's the type of connect?
08:40:00 <mikhail^> Saizan_, I can't seem to find it from the imports that I've made... Although I can go check with ghci
08:41:30 <mikhail^> Saizan_, it appears to be a type constructor for Database.HaskellDB.DriverApi.DriverInterface
08:41:39 <seliopou> It's in DriverAPI
08:42:19 <Saizan_> "connect" can't be a constructor
08:43:07 <mikhail^> Saizan_, http://hackage.haskell.org/packages/archive/haskelldb/0.12/doc/html/Database-HaskellDB-DriverAPI.html#v%3Aconnect
08:43:26 <Saizan_> ah, it's a field
08:43:29 <mikhail^> Saizan_, ah, rather it's a field accessor
08:44:17 <Saizan_> ok, so it uses an idiom for automatic disposal of resources
08:44:47 <Saizan_> connect params (\db -> <monadic action that uses db>)
08:44:51 <mun> if i've already downloaded the archive of a package, can i use cabal to install it without fetching it again from hackage?
08:45:08 <Saizan_> after the monadic action returns the connection will be closed, presumably
08:45:45 <Saizan_> ah, i forgot the "driver" parameter
08:46:11 <Saizan_> mun: you can untar it and run "cabal install" from the resulting directory
08:46:24 <mun> Saizan_, i see. thanks
08:46:45 <mikhail^> Saizan_, I think you got it right. My only problem now seems to be that I get a segfault when I do it the second time from the same application
08:48:47 <mikhail^> Saizan_, so do you think it would work if the lambda passed in would try and re-use the connection somehow?
08:49:44 <Saizan_> the connection should remain alive until the lambda returns, yes
08:49:46 <mikhail^> Saizan_, let my try and place the indexAndSave function inside the lambda and see if I get away with it...
09:07:00 <mikhail^> Saizan_, pure genius!
09:07:35 <mikhail^> Saizan_, that worked. :) So it seems ODBC doesn't like opening and closing connections too much and would rather have to re-use a single connection. Thanks for the guidance!
09:08:06 <mikhail^> Saizan_, I owe you an <insert beverage of choice here>. :)
09:08:14 <Saizan_> :D
09:08:15 <mikhail^> quicksilver, and you too. :)
09:08:18 <quicksilver> :)
09:08:31 <Saizan_> it shouldn't segfault like that though
09:08:34 <quicksilver> mikhail^: I think it's essentially a bug in the ODBC library, or its binding
09:08:39 <Saizan_> maybe it's worth a report
09:08:40 <quicksilver> it uses global variables for something
09:08:46 <mikhail^> Saizan_, yeah, that was a little unnerving for me
09:09:22 <mikhail^> quicksilver, yeah, it's notorious in C/C++ libraries that are written "the old style" where you have globals and what not
09:09:45 <mikhail^> I should check the code in now that it's working. :D
09:12:32 <mikhail^> Saizan_, where's the best place to report the bug?
09:13:12 <Saizan_> mikhail^: there should be a maintainer field on the hackage page
09:13:40 <mikhail^> Saizan_, hmmm... no Trac/Bugzilla yet? :D I'll shoot an email then in liew of that. ;)
09:14:02 <Saizan_> each maintainer chooses that
09:14:22 <Saizan_> it seems haskelldb has a sourceforge page, so maybe there?
09:17:18 <mikhail^> Saizan_, yup, however I'll file a bug there and send the maintainer(s) an email
09:17:44 <mun> i'm trying to install another package, but i keep getting the error "Could not find module `Data.map'". which package am i missing?
09:18:01 <mun> it also says "it is a member of pacage container-0.2.0.0, which is hidden"
09:18:47 <mikhail^> Saizan_, it also looks like the best way is through their users mailing list. :)
09:20:06 <zipMe> Hello I am trying to load a file in ghci, but i get the following error message : Could not find module `Base64':
09:20:06 <zipMe>       it is hidden (in package simplesmtpclient-0.2)
09:20:22 <zipMe> what does hidden mean ?
09:20:36 <Saizan_> mun: you've to put containers in the build-depends: field of that package.
09:20:54 <mun> Saizan_, yep i just tried that -- thanks
09:20:55 <quicksilver> I think what mun actually has is a complex dependency problem
09:20:58 <quicksilver> and it's rejecting containers
09:21:23 <Saizan_> quicksilver: that should fail at confiugure time, not when building
09:21:28 <mxc> hm
09:21:45 <mxc> still getting linker errors even on a totally fresh build
09:22:02 <mxc> oh well, will have to look at it another time
09:22:25 <mun> but now i get "cabal: cannot configure HCl-0.2. It requires container -any"
09:22:48 <mun> i already have containers-0.2.0.0 installed though
09:22:53 <Saizan_> mun: "containers"
09:22:58 <Saizan_> with the final s
09:22:59 <mun> argh
09:23:03 <mun> sorry
09:23:04 <quicksilver> Saizan_: oh
09:23:32 <Saizan_> if i understood what you were saying..
09:23:41 <zipMe> so anybody knows what a hidden package means ?
09:24:34 <Saizan_> and hidden package is one that appears between ( ) in ghc-pkg list
09:24:59 <Saizan_> you can use ghc-pkg expose to unhide it
09:25:04 <zipMe>  but why won't ghci load the file ?
09:25:26 <zipMe> Saizan_: ok I try this
09:26:39 <Saizan_> Cabal also hides packages not listed in build-depends for the duration of the build
09:27:28 <Saizan_> but maybe your problem is with an hidden module
09:27:33 <zipMe> Saizan_: I was able to build the package with cabal, but when I try to load one of the file in ghci I get an error message
09:27:55 <Saizan_> which is an internal module not exposed in the public API for that package
09:28:05 <zipMe> yes it says  Could not find module `Base64': it is hidden (in package simplesmtpclient-0.2)
09:28:12 <Saizan_> ok
09:28:25 <Saizan_> you're not supposed to import that module
09:28:31 <zipMe> how can I load that file in ghci ?
09:28:52 <dons> "
09:28:53 <dons> To summarize a bit, I'm trying out new things again and Haskell seem to be the most mainstream functional language out there at the moment with quite a bit of support and community. "
09:28:57 <dons> woo
09:29:02 <Saizan_> :set -ipath/where/the/module/is
09:29:17 <Saizan_> and then :load Base64.hs
09:29:56 <zipMe> Saizan_: but Base64 does not appear in ghc-pkg list... where is it ?
09:30:27 <Saizan_> zipMe: Base64 is a module, not a package
09:30:43 <zipMe> Saizan_: yes sorry , it's in the package tarball
09:30:52 <Saizan_> zipMe: "ghc-pkg describe simplesmtpclient" will have it in hidden-modules
09:30:57 <zipMe> Saizan_: thanks
09:31:36 <Saizan_> zipMe: though ghc won't let you import it from the installed package, without messing with the installation info
09:32:19 <zipMe> Saizan: ok, great
09:32:56 <gwern> > 14334 / 150
09:32:57 <lambdabot>   95.56
09:33:41 <Saizan_> but you can off course copy the source in your tree and load it directly
09:34:23 <zipMe> Saizan_: you mean copy Base64.hs into the file I was trying to load initially ?
09:35:51 <Saizan_> zipMe: you just have to copy Base64.hs in the same directory, so when you "import Base64" ghci will see it there and load it from the source, not caring about the installed one
09:36:22 <Saizan_> zipMe: ghc will consider it a totally separate module
09:37:02 <zipMe> Saizan_ : ok, that should do
09:37:34 <Saizan_> but "simplesmtpclient" might offer a nicer way to do what you need
09:38:38 <zipMe> Saizan_ : I just want to load it in ghci to see what is going on because it's not behaving nicely for me right now
09:40:00 <zipMe> Saizan_ : sendEmailAsString do not send anything and return False ... not very helpful
09:43:40 <MyCatVerbs> > fix (\r x -> x++(r "considered harmful")) $ "Goto "
09:43:41 <lambdabot>   "Goto considered harmfulconsidered harmfulconsidered harmfulconsidered harm...
09:43:50 * MyCatVerbs fails at spacing. :(
09:43:51 <mun> i have 2 versions of ghc installed, 6.8 and 6.10, does anyone know how to uninstall just 6.10?
09:44:41 <vixey> @let considerHarmful thing = "(" ++ thing ++ " considered harmful)"
09:44:42 <lambdabot>  Defined.
09:45:02 <quicksilver> mun: which OS, how did you install them?
09:45:16 <mun> quicksilver, i'm on linux.. i compiled the source.
09:45:34 <gwern> @car
09:45:34 <lambdabot> Maybe you meant: arr faq map part yarr
09:45:38 <quicksilver> hmm, I don't know.
09:45:39 <gwern> @Quote car
09:45:40 <lambdabot> glguy says: map became not overloaded in the great polymorphic scare of haskell 98
09:45:45 <quicksilver> do the makefiles have an uninstlal target?
09:45:53 <mun> quicksilver, nope
09:45:55 <MyCatVerbs> mun: IIRC, just make sure 6.10's executables are no longer in your PATH, and 6.8's are. But that won't get you 6.8 back if the executables that 6.8 installed were overwritten by the ones installed by 6.10.
09:46:59 <mun> MyCatVerbs, that doesn't sound like a safe approach, does it?
09:47:03 <MyCatVerbs> mun: the actual "ghc" and "ghci" executables fix up paths that tell the running GHC where its libraries and stuff really are. So once you've taken care of making sure that the right versions of "ghc" and "ghci" are in your path, you should be sorted.
09:47:49 <MyCatVerbs> mun: I take it you installed 6.8 from your distro's repositories, and 6.10 from sources? The sanest way might be to uninstall 6.8, delete all the files that 6.10 installed, and then reinstall 6.8.
09:48:11 <mun> MyCatVerbs, yes you're right
09:48:15 <MyCatVerbs> mun: if you've any packages installed into your home directory (say with cabal install) then you'd need to blow those to smithereens, too.
09:48:58 <MyCatVerbs> (Object files generated by old and new versions of GHC tend not to play nicely together. In fact, they fight like cats in a sack. :)
09:50:22 <mun> ok thanks
09:52:29 <gwern> 'The lack of a good ide and community support have lead me searching for something new again. Through out my looking for languages haskell has popped up quite a bit. I joined the haskell irc channel just to see what happens there and to my surprise it's quite busy most the time (busy enough that I don't want to read all the chatting that goes on). The next thing I looked at is an IDE, there are quite a few out there although most of ...
09:52:36 <gwern> ... them seem dead. The last thing that really won me over is the great amount of packages that are easy to install.'
09:52:40 <gwern> http://seanchapel.blogspot.com/2009/03/haskell.html <-- another schemer converts
09:53:49 <upperDeck> hello out there
09:54:05 <upperDeck> I'm just pasing through
09:54:29 <upperDeck> Well bb Tc :)
09:58:26 <mun> should array-0.2.0.0 work with ghc 6.8?
09:58:30 <bremner> qwern: converted by an IDE, the mind boggles
09:58:40 <bremner> ^gwern
09:59:58 <lament> <3 IDE :)
09:59:59 <koeien> bremner: yeah, although a good IDE is a plus for a language
10:00:33 <quicksilver> yes, but haskell doesn't have one :)
10:00:50 <koeien> true. but haskell is too good of a language to ignore :)
10:01:08 <vininim> there are emacs-mode for lot's of languages. =P
10:01:25 <koeien> he said the E-word! take him!
10:01:32 <Vq^> yeah, the real question isn't whether there is an IDE, the question is whether there is an emacs-mode :P
10:01:52 <vininim> ^^^^ this :D
10:01:59 <lament> I don't understand how anybody can still take emacs seriously after last years' (?) RMS discovery that IDEs exist and are good
10:02:07 <koeien> i happen to love vim. *cough*, but code completion eclipse-style would be nice
10:02:21 <Vq^> lament: when was that discovered?
10:02:25 <pejo> lament, those IDEs are pretty bad at reading email and for irc.
10:02:33 <koeien> i always need my browser pointed to hoogle
10:02:49 <lament> Vq^: a year or two ago RMS finally discovered that IDEs exist, and some of their features are nice. He honestly didn't know before.
10:03:02 <koeien> lament: wow, do you happen to have a source for this?
10:03:03 <bremner> lament: I was using emacs in 1985, rms is almost johnny-come-lately :-)
10:03:38 <mikhail^> lament, talk about living under a rock. ;)
10:03:45 <lament> koeien: sure. http://lists.gnu.org/archive/html/emacs-devel/2008-03/msg02254.html
10:04:01 <lament> "I just got a demo of the Eclipse editor and saw these features
10:04:02 <lament> which we should have in Emacs."
10:04:04 <koeien> lament: whaha, nice
10:04:17 <koeien> eclipse is pretty okay, save for the memory usage
10:07:38 <leimy> and all the java
10:08:13 <lament> eclipse seemed nice but kinda raw, especially for haskell
10:08:26 <koeien> leimy: i use pydev actually, but it's a decent java IDE
10:08:31 <quicksilver> the problem is that the neater features (intellisense, refactoring, and so on) are heavily java-based
10:08:32 <koeien> i meant this, modulo the language
10:08:39 <quicksilver> it's substantially non-trivial to port those to haskell
10:08:47 <koeien> quicksilver: yep, but i guess this would be hard to do that generally
10:08:47 <quicksilver> since haskell is so different from java in so many ways.
10:08:55 <quicksilver> people are trying to do things like it, though.
10:08:59 <koeien> they might do it for java-like languages
10:09:03 <lament> yeah, ideally every language needs its own IDE
10:09:10 <koeien> but the intersection of features of all programming languages is trivial
10:09:17 <lament> or at least every "genus"
10:09:19 <vixey> every language needs decent syntax coloring
10:09:23 <koeien> lament: yes
10:09:42 <koeien> lament: so an haskell/ocaml/...-IDE would be nice
10:10:07 <lament> not sure if ocaml is the same genus, or just the same family :)
10:10:30 <lament> i guess most refactorings etc are compatible
10:10:34 <quicksilver> autocompletion is hard because a half-written line of java has a better structure than a half-written line of haskell.
10:10:56 <quicksilver> especially w.r.t. the face that we use binary (infix) operations so often.
10:11:16 <koeien> yes, it's hard to complete
10:11:28 <quicksilver> but also just the nice simple idiom "objectref.incompletemethodname"
10:11:33 <quicksilver> is so easy to autocomplete.
10:11:50 <quicksilver> (assuming you can get a handle on the type of objectref, but in java you always can)
10:12:08 <koeien> in haskell this would be inferred, you mean?
10:12:11 <pejo> quicksilver, clearly we need objects in Haskell!
10:12:20 <quicksilver> (a) in haskell the type of objectref would be inferred
10:12:38 <quicksilver> (b) in haskell we prefer the word order "verb subject" not "subject verb"
10:12:48 <quicksilver> so you haven't normally specified the 'subject', when you're typing the verb
10:12:51 <quicksilver> (yet)
10:13:01 <lament> it's still useful for modules
10:13:10 <quicksilver> I view it as mostly an unfortunate coincidence.
10:13:25 <quicksilver> lament: it certainly is! but any naive autocomplete routine suffices for tha.
10:13:30 <koeien> well, you still have, S.<complete>  when you have import qualified Data.Set as S
10:13:36 <quicksilver> I just use emacs totally dumb M-/ for that.
10:13:49 <quicksilver> koeien: yes, that one sure.
10:13:55 <quicksilver> I avoid qualified modules like the plague :)
10:14:11 <koeien> quicksilver: for Set & Map it's hard to avoid :)
10:14:20 <koeien> i like import lists more, too
10:14:34 <koeien> unless you use a large collection of functions
10:15:15 <quicksilver> yes, I use them for Set and Map and Sequence
10:15:28 <quicksilver> but it's not a common enough case that I worry about it
10:15:37 <quicksilver> and I really don't need to autocomple words like 'filter' and 'map'
10:15:48 <koeien> no, that's unnecessary
10:15:51 <quicksilver> (it's not like it's enterpriseFactoryObjectEnablerEnable() )
10:16:32 <jmcarthur> AbstractStrategyFactory, ftw
10:16:56 <koeien> oh, eclipse has a nice debugger too
10:17:05 <koeien> haskell's one is a bit harder to use
10:17:17 <koeien> (or ghc's one)
10:17:52 <quicksilver> that's true.
10:18:03 <quicksilver> but no one knows how to make ghci's debuger as nice as eclipses
10:18:04 <koeien> in fact, i haven't needed the ghc debugger so far, so this point may be moot (i've toyed with it once it was released to check it out)
10:18:07 <quicksilver> personally I never use it.
10:18:38 * jmcarthur wants to be able to visualize the graph and watch it get reduced as i step through an algorithm, more because it would be cool than it being useful, but i can imagine it being useful as well, especially for noobies
10:18:56 <quicksilver> jmcarthur: I would really like that.
10:19:43 <jmcarthur> would be fun to animate too
10:19:51 <jmcarthur> watching a zipper, things like that
10:20:24 <vixey> how would it look
10:23:13 <jmcarthur> references could be considered physical constraints and represented by lines, let would add new objects and constraints to the graph, case would break constraints, and all objects would have a general tendency to repel each other
10:23:43 <EvilTerran> jmcarthur, i think "hat" does something like that, if you can get it working
10:23:46 <EvilTerran> ?where hat
10:23:46 <lambdabot> http://www.haskell.org/hat/
10:23:51 <jmcarthur> and as objects drift further away from the graph after being broken off, they are eventually garbage collected
10:23:52 <mun> does anyone know what gets generated using the cabal option --gen-script?
10:23:54 <jmcarthur> never heard of hat
10:23:57 * jmcarthur peeks
10:24:17 <dcoutts> mun: run it and see, it's fairly simple
10:25:22 <jmcarthur> well, of course case wouldn't *actually* break constraints... i need to rethink that explanation
10:25:49 <mun> dcoutts, well nothing gets generated in my case
10:26:10 <dcoutts> mun: oh, is it an executable rather than a lib?
10:27:12 <mun> dcoutts, i'm trying to compile this program which calls "runhaskell Setup.hs register --gen-script; ./register.sh" it seems to presume register.sh gets generated
10:27:16 <mun> dcoutts, but there's no such fil
10:27:18 <mun> *file
10:27:39 <whpearson> Are there any guides to working out type signatures by hand. E.g. figuring out the type of map.foldr and other such oddities.
10:28:16 <jmcarthur> dude hat looks pretty awesome
10:28:54 <Botje> whpearson: look up all the types yourself, alpha rename them all, then do the unification
10:29:22 <vixey> > map.foldr
10:29:23 <lambdabot>       Overlapping instances for Show ((a -> b -> b) -> [b] -> [[a] -> b])
10:29:23 <lambdabot>    ...
10:29:55 <EvilTerran> whpearson, any textbook or whatever that discusses type inference from first principles would do nicely
10:29:56 <whpearson> Botje: You missed out the step, (re) learn lambda calculus.
10:30:51 <vixey> whpearson: If you know the unification algorithm then understanding how type inference works is very simple and you will be able to do it by hand. so just learn this algorithm
10:31:19 <vixey> first order unification
10:31:40 <dcoutts> mun: well I'm not sure what's going on there. It is supposed to generate ./register.sh and it does so for me.
10:31:45 <whpearson> Thanks all, I'll have a look.
10:31:49 <dcoutts> mun: we'll need more details to work out what's going on
10:32:03 <mun> dcoutts, usually what should Setup.hs contain? mine's very brief
10:32:17 <dcoutts> mun: yes it should be brief
10:32:18 <mun> two lines: import Distribution.Simple and main = defaultMain
10:32:21 <dcoutts> yep
10:32:31 <mun> right
10:32:45 <dcoutts> mun: and this package is definitely a library? not just an exe?
10:33:16 <mun> dcoutts, yeah it should be a library
10:33:58 <cycloid> I'm looking for tips on how to keep my Mac OSX 10.4 system from going into swap death when my haskell programs try to allocate all the memory in the universe.  It appears that ulimit -d has no effect; +RTS -M doesn't seem to help either.  Any suggestions?
10:35:09 <MyCatVerbs> > let { ack 0 j = j+1; ack i 0 = ack (i-1) 1; ack i j = ack (i-1) (ack i (j-1)) } in ack 3 3
10:35:10 <lambdabot>   61
10:35:12 <dons> +RTS -M should certainly work
10:36:48 <cycloid> dons: doesn't seem to (at least not in ghci).  I'll try it in compiled version.
10:39:14 <dcoutts> mun: do you have any more details? what Cabal version? what package? Is the package available to reproduce the problem? Got a hpaste of runghc Setup register --gen-script -v3 ?
10:40:11 <mun> dcoutts, i'm using cabal 1.6.0.2. here's the package: http://www.informatik.uni-bremen.de/agbkb/forschung/formal_methods/CoFI/hets/src-distribution/versions/uni-ghc-6.8.x-HaXml-1.13.2-2008-01-25.tgz
10:41:09 <dons> cycloid:
10:41:10 <dons> $ ./A +RTS -M256k
10:41:11 <dons> A: maximum heap size (-M) is smaller than minimum alloc area size (-A)
10:41:11 <dons> Heap exhausted;
10:41:11 <dons> Current maximum heap size is 253952 bytes (0 MB);
10:41:13 <dons> use `+RTS -M<size>' to increase it.
10:41:14 <mun> dcoutts, it needs HaXml to compile properly. i've run configure, but fails at make cabal
10:42:09 <cycloid> dons: thanks, but seems broken here:
10:42:17 <cycloid> mojo:jeff$ ./City +RTS -M10m
10:42:18 <cycloid> ^CCity: memory allocation failed (requested 2097152 bytes)
10:44:23 <gwern> hm. how many packages are there on hackage exactly...
10:44:28 <dons> where is "here"? linux?
10:44:35 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/stats
10:45:04 <gwern> ah. where's that linked?
10:45:10 <quicksilver> cycloid: it can take a long time for -M to fail
10:45:10 <dons> it's not, afaik
10:45:15 <dons> cycloid: hmm.
10:45:18 <quicksilver> cycloid: as it gets close to the limit, it will run the GC more and more often
10:45:23 <quicksilver> so you get massive CPU usage
10:45:28 <wli> What's City?
10:45:29 <quicksilver> before it finally, totally, runs out of space.
10:45:45 <cycloid> I'm atchning VM size, it uses 2G of phys mem before failing
10:45:47 <dons> hmm. i think it isn't working.
10:45:52 <quicksilver> ok, that's not working then.
10:45:53 <cycloid> (watching)
10:45:58 <dons> $ ./A +RTS -M1M -sstderr
10:46:07 <dons>              682 MB total memory in use (162 MB lost due to fragmentation)
10:47:07 <cycloid> I think macos doesn't implement setrlimit(RLIMIT_DATA, ...).  Could it be that ghc is depending on that?
10:47:21 <dons> well, i'm getting this result on linux too nw
10:47:29 <dons> let me check with 6.8.x
10:47:54 <cycloid> thanks.  I don't have a linux (or 6.8) handy
10:47:56 <dons> bah, not installed
10:47:57 <dons> ?bug
10:47:57 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
10:50:46 <dons> cycloid: http://hackage.haskell.org/trac/ghc/ticket/3110
10:50:51 <dons> see if you can reproduce that test case
10:51:07 <cycloid> looking
10:51:18 <dons> oh, i wonder. this might be the 6.10.x bug....
10:51:23 <dons> let me check with the 6.10.2 RC
10:53:07 <dons> hmm. is your test program using Integer?
10:54:33 <cycloid> dons: yes, reproduces
10:55:06 <dons> 6.10.1 ?
10:55:20 <cycloid> on 6.10.1 + macos 10.4
10:55:31 <dons> i think this is fixed in 6.10.2
10:56:56 <cycloid> that would be great.  Think I should start using the HEAD or STABLE branch, or wait for release?
10:57:06 <dcoutts> mun: are you sure this is the first failure? when I run ./configure I do indeed get the thing about register, but that's because something went wrong much earlier but the system did not stop,
10:57:32 <mun> dcoutts, let me check
10:57:47 <dcoutts> mun: for me, it goes wrong when running gmake cabal, when it tries to configure and there's still a package missing. So it doesn't build and so there's nothing to register yet.
10:57:47 <mreh> :t foldl
10:57:48 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
10:57:54 <cycloid> (missed your Q: Is your test program using Integer): no, lists of Int
10:58:18 <dons> cycloid: yes, this definitely is fixed with the ghc 6.10.2 release candidate
10:58:48 <cycloid> thanks much for digging in to it.  Let's see how far I get with RC. :-)
10:58:59 <dons> i've closed the ticket: http://hackage.haskell.org/trac/ghc/ticket/3110#comment:1
10:59:00 <mun> dcoutts, make cabal only gives two lines -- first ends with echo Finished make cabal and second is the ./register.sh line
10:59:22 <mun> dcoutts, my ./configure outputs "---- Configuration Successful ---"
10:59:38 <mun> dcoutts, does yours?
11:00:06 <mun> and my ./configure ends with "To compile UniForM type make cabal"
11:00:42 <dcoutts> mun: yes, ./configure succeeds, it's the make step that fails. The make step still has to call Setup.hs configure
11:01:40 <mun> dcoutts, yes indeed. you mean "runhaskell $Home/uni/Setup.hs configure -O"?
11:01:51 <mun> i get no output if i run that alone though. is that normal?
11:01:57 <dcoutts> mun: yes
11:02:00 <dcoutts> that's normal
11:02:07 <dcoutts> it says something if it goes wrong
11:03:13 <mun> dcoutts, i've tried running each individually, but it doesn't generate a register.sh
11:04:42 <dcoutts> mun: which ones? which subdirs?
11:06:03 <dcoutts> mun: I presume you're using ghc-6.8.x
11:06:10 <mun> dcoutts, yep that's right
11:06:21 <mun> dcoutts, but it fails on your end too, right?
11:06:24 <dcoutts> mm, I should try that version, it needs too many changes for 6.10
11:06:33 <mun> and no register.sh is generated, right?
11:06:39 <mun> oh right
11:06:43 <dcoutts> mun: I can't get it to build yet
11:10:42 <gwern> @remember WilliamShakespeare Mad world! mad kings! mad composition!
11:10:42 <lambdabot> It is forever etched in my memory.
11:11:03 <gwern> if only shakespeare had known some stream fusion theorems
11:11:09 <gwern> @flush
11:11:19 <mun> dcoutts, this has taken me 2 days to try to debug.. thanks a lot for your attempt to help!
11:11:31 <zcvvc> two links in RWH online version are broken: choose "comments" anywhere, then "[ help ]" and "give you credit" lead to 404
11:12:47 <travisbrady> anyone have pointers on writing tests for something that does lots of io? (a db interface library)
11:13:00 <gwern> hunit tests?
11:13:01 <dcoutts> mun: did you also have to hack it to change the haxml version to 1.13.3?
11:13:20 <mun> dcoutts, i got myself 1.13.2
11:13:38 <mun> dcoutts, http://www.haskell.org/HaXml/HaXml-1.13.2.tar.gz
11:13:54 <dcoutts> mun: hmm, that version doesn't build with ghc-6.8, it was updated for ghc-6.8 in version 1.13.3
11:14:05 <mun> dcoutts, but i *think* you could hack it
11:14:08 <dcoutts> mun: but no matter, the versions are compatible
11:14:13 <mun> dcoutts, oh? let me try to build it again
11:14:46 <koeien> my program is about 25% faster with -N4 -g1 compared to -N4. is this normal?
11:14:51 <mun> dcoutts, i ran cabal install and it seems to be fine
11:15:43 <travisbrady> gwern: unit tests (proper ones i'm told) do no io
11:16:30 <gwern> travisbrady: piffle. if unit tests don't do io, then they're just qc/smallcheck properties
11:16:34 <gwern> of a degenerate sort
11:16:53 <c_wraith> travisbrady: that's silly.  Proper unit tests often have reason to read data from specially-constructed test files
11:17:21 <gwern> and thus there's no reason to have a special name like 'unit test' to distinguish them. they're just crappy properties
11:18:17 <dcoutts> mun: this thing is not easy :-) there's no way to tell it what ghc to use except hacking the path, these are not normal cabal packages
11:23:26 <mun> eek..
11:26:10 <dataangel> Are there any tools for haskell that attempt to give a "complexity" (from a how-difficult-is-it-for-a-human-to-understand perspective, something like cyclomatic complexity) to haskell code? Would something like this be easier to write due to haskell being pure?
11:26:21 <vixey> @w80 cyclomatic
11:26:24 <lambdabot> No match for "cyclomatic".
11:26:49 <dataangel> vixey: http://en.wikipedia.org/wiki/Cyclomatic_complexity
11:26:51 <mreh> @hoogle getWindowTick
11:26:51 <lambdabot> No results found
11:27:33 <koeien> my program is about 25% faster with -N4 -g1 compared to -N4. is this normal?
11:27:45 <gwern> dataangel: currently not that I've heard of
11:27:46 <kmeyer> whoo
11:27:49 <mun> dcoutts, just curious, what does Setup.hs actually do since it's so brief?
11:27:54 <kmeyer> this latest Monad.Reader is very enlightening (for me)
11:28:05 <jmcarthur> dataangel, since pure haskell functions are stateless, actual cyclomatic complexity is basically zero, unless i misunderstand the wikipedia article
11:28:13 <koeien> kmeyer: the article by brent ?
11:28:14 <gwern> dataangel: the closest I think we have is a lint tool, hlint, and a module visualizer
11:28:15 <ImInYourMonad> is Javas GC more predictable than Haskells?
11:28:15 <dcoutts> mun: it calls a great big library which does a lot of stuff
11:28:22 <ImInYourMonad> if Java can be used on cellphones, then why not haskell?
11:28:28 <kmeyer> koeien: yes
11:28:57 <mreh> ImInYourMonad: there is nothing stopping it
11:28:59 <koeien> kmeyer: yeah that's very good. it was published before, if you'd have been subscribed to the -cafe, you'd know :)
11:29:01 <mun> dcoutts, i've tried fiddling with the flags, but it still doesn't return any error, e.g., deliberately misspelling --gen-script
11:29:04 <kmeyer> ImInYourMonad: ghc is kind of hard to bootstrap on new archs
11:29:26 <kmeyer> koeien: I'm subscribed to cafe, I just don't read everything :)
11:29:35 <dcoutts> mun: that's not good, it does check its command line args and should complain if it's not understood. Does --help work?
11:29:38 <koeien> kmeyer: i skim as well. a good mail client is essential
11:29:46 <dataangel> jmcarthur: I'm not an expert, but it says the number of linearly independent paths through the code, so Haskell having 'if' I think means there has to be some cyclomatic complexity. Which part makes you think it depends on their being state?
11:30:13 <jmcarthur> dataangel, the part that says it is based on a control flow graph
11:30:40 <mun> dcoutts, e.g., i've tried "runhaskell /home/mchan/uni/Setup.hs register --gen-scrip" and i don't get an error
11:30:42 <jmcarthur> haskell's if is not really "control" per se
11:30:42 <mreh> you only need cyclomatic complexity measures really when you're performing testing
11:30:43 <dataangel> jmcarthur: How does haskell not have a control flow graph? There is if and case
11:30:45 <koeien> the problem with analyzing complexity of haskell programs is not the purity, but the laziness
11:30:51 <ImInYourMonad> why?
11:31:04 <dcoutts> mun: oh, that's because there's a unique completion
11:31:12 <kmeyer> koeien: eh, I just don't have a ton of time
11:31:32 <mun> dcoutts, but even "runhaskell /home/mchan/uni/Setup.hs register --fdfds"
11:31:41 <dcoutts> mun: what about --help?
11:31:55 <dataangel> jmcarthur: If I write f x = if == 3 then 4 else 2 -- you could consider that to be a function with two paths and two returns, although that's not normally how you'd think about it from a haskell'y perspective
11:31:57 <mreh> does anyone know of an alternative in SOE for getWindowTick?
11:31:58 <koeien> okasaki's book helps to understand it, and contains some examples
11:32:04 <mun> dcoutts, runhaskell /home/mchan/uni/Setup.hs --help doesn't return anything
11:32:10 <dataangel> koeien: How does laziness complicate it?
11:32:28 <jmcarthur> dataangel, exactly. is such a metric really meaningful for haskell?
11:32:32 <koeien> dataangel: you don't know exactly how long evaluating a parameter is going to take
11:32:42 <mreh> is there a haskell command that pauses for a defined period?
11:32:51 <koeien> mreh: threadDelay
11:32:55 <mreh> @hoogle wait
11:32:55 <lambdabot> System.Process waitForProcess :: ProcessHandle -> IO ExitCode
11:32:55 <lambdabot> Control.Concurrent.QSem waitQSem :: QSem -> IO ()
11:32:55 <lambdabot> Control.Concurrent.QSemN waitQSemN :: QSemN -> Int -> IO ()
11:33:03 <koeien> @hoogle threadDelay
11:33:03 <lambdabot> Control.Concurrent threadDelay :: Int -> IO ()
11:33:07 <mreh> @hoogle threadDelay
11:33:07 <lambdabot> Control.Concurrent threadDelay :: Int -> IO ()
11:33:09 <koeien> note, iirc this is in *micro*seconds
11:33:22 <mreh> micro seconds!
11:33:43 <mreh> is there scientific notation in haskell? :D
11:33:50 <koeien> > 1e6
11:33:51 <lambdabot>   1000000.0
11:33:53 <koeien> yes
11:34:04 <mreh> scweet
11:34:10 <gwern> > read "1e6" :: Int
11:34:11 <lambdabot>   1000000
11:34:13 <mreh> > 1e3
11:34:14 <lambdabot>   1000.0
11:34:16 <dataangel> koeien: I'm not sure that's necessary for figuring out the cyclomatic complexity for a single function. We don't need to know anything about what the inputs actually are, just the possibilities that could result (if causes a branch here, case causes a branch there, etc.)
11:34:24 <jmcarthur> dataangel, if in haskell is just a way of saying that the result of the expression can be one of two things, not that the expression might *do* one of two things, since the expression doesn't *do* anything
11:34:26 <dcoutts> mun: then there's something wrong with your ghc or Cabal installation. Nothing with --help -v3 too?
11:34:27 <mreh> 30e3
11:34:27 * gwern is a little impressed that read works on sinotation
11:34:32 <mreh> > 30e3
11:34:32 <Saizan_> you can use a data-dependency graph instead of a control-flow graph in haskell, and you'd get similar results.
11:34:33 <lambdabot>   30000.0
11:34:35 <koeien> dataangel: cyclomatic, i don't know anything about it :)
11:35:17 <gwern> @quote cyc
11:35:17 <lambdabot> shapr says: CosmicRay ran a HiddenMarkov bot on four years of #haskell logs and it kept trying to talk to me about unicycling.
11:35:20 <dcoutts> mun: ok, so I've got to the stage where it has built the util package and it generates the register.sh and that works. However the next package in line, that does not find the uni-util package
11:35:27 <gwern> @quote cyc
11:35:27 <lambdabot> ghc says: Cycle in type synonym declarations
11:35:33 <jmcarthur> at runtime, sure, something happens to make the cpu hotter, but if the idea is to measure complexity as far as humans understand it then we can effectively assume that a pure function does nothing
11:35:38 <Gracenotes> > fromRational 30e10 :: CReal
11:35:39 <lambdabot>   300000000000.0
11:35:41 <gwern> man, why are ghc messages in lb?
11:35:43 <mreh> @src e
11:35:43 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
11:36:23 <Gracenotes> > pi * 1e1000 :: CReal
11:36:24 <lambdabot>   314159265358979323846264338327950288419716939937510582097494459230781640628...
11:36:26 <gwern> @quote Rolls
11:36:26 <lambdabot> No quotes match. Are you on drugs?
11:36:28 <jmcarthur> yeah, data dependency would make a lot more sense
11:36:31 <Saizan_> jmcarthur: why? the algorithm for the addition of two numbers is pure, but still needs to make decisions
11:36:42 <mreh> it's odd how e is use for n*10^x
11:36:42 <dataangel> jmcarthur: True, but is the consequence any different? From the programmer's perspective, the expression still has two possibilities. That's more complexity than say if there were only 1 (the expression was a constant).
11:36:46 <gwern> @remember RobertXCringely If automobiles had followed the same development cycle as the computer, a Rolls-Royce would today cost $100, get a million miles per gallon, and explode once a year, killing everyone inside.
11:36:46 <lambdabot> It is forever etched in my memory.
11:36:50 <mreh> when it's also euclids number
11:36:54 <mreh> > e
11:36:55 <lambdabot>   e
11:36:57 <Gracenotes> mreh: it's standard floating point notation
11:37:01 <Gracenotes> > exp e
11:37:02 <lambdabot>   exp e
11:37:05 <LeoD> :t e
11:37:06 <lambdabot> Expr
11:37:06 <Gracenotes> > exp 1
11:37:07 <lambdabot>   2.718281828459045
11:37:18 <mun> dcoutts, how did you generate the script?
11:37:18 <Gracenotes> ^ use exp 1 for e
11:37:21 <jmcarthur> Saizan_, "make decisions" is not declarative language though
11:37:28 <mreh> thanks
11:37:35 <Gracenotes> mreh: the argument is that e isn't so useful as e to a power
11:37:45 <mreh> is e infix?
11:37:48 <Saizan_> jmcarthur: so case-expressions are not declarative?
11:37:51 <dcoutts> mun: it did it automatically, because it calls runhaskell Setup.hs register --gen-script
11:37:56 <Gracenotes> e isn't a function, it's part of the syntax
11:38:04 <mreh> oh right
11:38:12 <koeien> > 2 e2 -- doesn't work
11:38:13 <lambdabot>   Not in scope: `e2'
11:38:13 <Gracenotes> > 2e2 :: Ratio
11:38:14 <lambdabot>       `Ratio' is not applied to enough type arguments
11:38:14 <lambdabot>      Expected kind `?',...
11:38:15 <jmcarthur> Saizan_, sure they are, just not the idea that they make decisions. all they do is map constructors to expressions
11:38:17 <koeien> > 2e2 -- works
11:38:18 <lambdabot>   200.0
11:38:19 <mun> dcoutts, v3 returns nothing either
11:38:26 <dcoutts> mun: however the mk/cabal-ghc-pkg does not work, it's trying to get cabal to look in the local package.conf file, but it's not doing it right.
11:38:27 <jmcarthur> "do" was the wrong word for me to use there
11:38:34 <Gracenotes> > let e2 = a? in 2e2 :: Ratio
11:38:35 <lambdabot>   <no location info>: parse error on input `in'
11:38:41 <Gracenotes> > let e2 = ?a in 2e2 :: Ratio
11:38:41 <jmcarthur> i should have said "they represent mappings from constructors to expressions"
11:38:41 <koeien> > 2e2 :: Ratio Integer
11:38:42 <lambdabot>       `Ratio' is not applied to enough type arguments
11:38:42 <lambdabot>      Expected kind `?',...
11:38:42 <lambdabot>   200%1
11:38:48 <dcoutts> mun: in ghci, when you run Distribution.Simple.defaultMain, does it work?
11:38:49 <koeien> Gracenotes: Ratio has kind * -> *
11:38:55 <Gracenotes> ah, forgot about that. It's an integral
11:39:07 * Gracenotes thought that some functions were declared specifically for Ratio Integer, though
11:39:19 <Saizan_> jmcarthur: it's still strongly connected with control-flow for me
11:39:24 <dcoutts> mun: it probably did work accidentally in an older version of Cabal, but it was never intended to work that way
11:39:26 <Gracenotes> anyways.
11:39:57 <dcoutts> mun: if you look at mk/cabal-ghc-pkg, it calls ghc-pkg with --package-conf=package.conf
11:40:00 <mun> dcoutts, i should give you a bit of history. just a bit earlier, i had both 6.8 and 6.10 installed. then i removed 6.10 (in /usr/bin/local) by renaming all the links. thus, at the end ghc, ghci from the environment will load 6.8.
11:40:14 <mun> dcoutts, do you think that would affect other parts of the installation?
11:40:18 <dcoutts> mun: however that doesn't help, because cabal only looks at the global and user package dbs, not any extra that ghc-pkg might know about
11:40:54 <dcoutts> mun: no, should be fine, it should only be looking for ghc and ghc-pkg
11:40:56 <Gracenotes> oh, I think the problem was that I confused the two error messages. hrm.
11:41:22 <dcoutts> mun: but it looks like this system was built for Cabal-1.2.x and relies on some of the bugs in that version of Cabal
11:41:30 <mun> dcoutts, if i run Distribution.Simple.defaultMain in ghci, it loads all the packages
11:41:49 <mun> dcoutts, in that case, i'll install 1.2 and see
11:41:54 <jeffersonheard> so here's an interesting one...
11:41:57 <dcoutts> mun: so you might have more luck if you use the version of Cabal that came with ghc-6.8, rather than the latest version
11:42:08 <dcoutts> mun: ghc-6.8 came with Cabal-1.2, no need to install anything
11:42:15 <dcoutts> mun: just unregister the later version
11:42:38 <quicksilver> Gracenotes: Ratio Integer = Rational.
11:42:42 <dcoutts> mun: who wrote this system by the way?
11:42:43 <jmcarthur> if only conal was around. he normally has some insight into whether things are declarative
11:42:55 <quicksilver> Gracenotes: Ratio wiht finite types (like Int) is a bit broken.
11:42:58 <Gracenotes> quicksilver: ah, that's it
11:43:03 <dcoutts> mun: they should really file some cabal feature requests, it's doing a lot of hacking
11:43:07 <mun> dcoutts, DFKi wrote it.. the german AI institute
11:43:19 <Gracenotes> quicksilver: I think I confused it. okay, gotcha :x
11:43:24 <jeffersonheard> let's say I have a function and a record type constructor like this, where every item in the constructor is a different parsing of the parameter x:  \x -> R (f x) (g x) (h x) (j x) ... (m x)
11:43:27 <mun> dcoutts, well, the guys are now at DFKI, but they wrote it while they were at University of Breman
11:43:41 <dcoutts> mun: is it still maintained?
11:43:54 <jeffersonheard> is there some way to simplify that so that the R is folded over a list of evaluating f,g,h,j,and m over x?
11:44:05 <mun> dcoutts, yes it is. so which file do you find the hacks?
11:44:20 <Gracenotes> jeffersonheard: Applicative is one way
11:44:36 <dcoutts> mun: these days it should be possible to do all this without a makefile or configure script and more reliably, using cabal-install
11:44:41 <jeffersonheard> Gracenotes, I thought so, but I'm failing to understand quite how to do it...
11:44:44 <Saizan_> jeffersonheard: R <$> f <*> g <*> h <*> j <*> ... <*> m, with the (->) r applicative
11:44:51 <ski> jeffersonheard : return R `ap` f `ap` g `ap` h `ap` j `ap` .. `ap` m
11:44:57 <Gracenotes> for instance, (:) is a constructor
11:45:11 <Gracenotes> > (liftA2 (:) negate repeat) 10
11:45:12 <lambdabot>   [-10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,1...
11:45:21 <Gracenotes> > ((:) <$> negate <*> repeat) 10
11:45:22 <lambdabot>   [-10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,1...
11:45:37 <Gracenotes> (same for liftM2)
11:45:44 <jeffersonheard> Saizan, I was trying to understand the difference the other day between <$> and <*> and it was eluding me.  Looking at applicative Parsec
11:45:54 <mun> dcoutts, i see... i believe uni was written a while ago
11:45:56 <dcoutts> mun: or even just a variation on what it does now, it could use the --package-db flag instead of making a ghc-pkg script and telling Setup.hs to use that
11:45:57 <jeffersonheard> But thanks, that's exactly what I was looking for
11:46:07 <ski>   pure f <*> i = f <$> i
11:46:16 <dcoutts> mun: sure, there didn't used to be much support for building multiple packages in one go
11:46:24 <jeffersonheard> ski, actually, that clarifies it completely
11:46:30 <jeffersonheard> I just wnated ot understand one in terms of the other
11:46:32 <jeffersonheard> perfect
11:47:01 <Gracenotes> jeffersonheard: have you read http://www.serpentine.com/blog/2007/01/19/playing-fast-and-loose-with-parsec-for-parsing-in-haskell/ ?
11:47:13 <Gracenotes> er, actually, wrong look
11:47:15 <Gracenotes> *wrong link
11:47:17 <Gracenotes> just a sec
11:47:22 <mun> dcoutts, so did you suggest me to just unregister Cabal 1.6? but then my cabal-install would still be 1.6
11:47:35 <jeffersonheard> no...  I was trying to understand it from RWH, but the example was so simple I got lost trying to do something more complicated
11:47:43 <dcoutts> mun: yep, that's fine. cabal-install is statically linked
11:48:06 <Gracenotes> jeffersonheard: this is it: http://www.serpentine.com/blog/2008/02/06/the-basics-of-applicative-functors-put-to-practical-work/
11:48:17 <Gracenotes> an entire blog post about Parsec in applicative style
11:48:32 <Saizan_> you can use --cabal-lib-version to force cabal-install to use a particular version for Setup.hs scripts
11:48:40 <Gracenotes> it also links to the paper that introduced Applicative, which is reasonably readable (the first half, anyway)
11:48:56 <mun> dcoutts, hmm still no difference even with Cabal 1.2.3
11:49:27 <dcoutts> Saizan_: yes, though this is a big collection of scripts and makefiles
11:49:29 <jeffersonheard> yay.  perfect.  I was using it to generate type-safe xml-rpc proxies from an extended haskell prototype notation in several diff. languages.
11:49:29 <mun> dcoutts, but make packages did proceed further
11:49:50 <Gracenotes> wha
11:49:53 <dcoutts> mun: it might be easier to install each of these packages in turn using cabal-install
11:50:00 <mun> dcoutts, if you run "make packages" does it fail?
11:50:27 <dcoutts> mun: working so far...
11:50:30 <Gracenotes> jeffersonheard: just take a look at the blog if you're interested x-x
11:50:49 <jeffersonheard> am doing so now, thanks Gracenotes
11:50:53 <Gracenotes> written by a coauthor of RWH
11:50:55 <Gracenotes> okay :)
11:50:59 <mun> dcoutts, is yours 1.2.x or 1.6?
11:51:32 <dcoutts> mun: 1.2 actually
11:51:56 <mun> dcoutts, i see. so make packages works for you?
11:52:17 <dcoutts> mun: ah, it completed. yes.
11:52:32 <mun> dcoutts, mine fails at Compiling ChildProcess. Ambiguous occurrence `env'
11:52:35 <mun> dcoutts, oh!
11:52:45 <mun> dcoutts, something must be wrong on my end...
11:52:51 <dcoutts> mun: but the registration is still borked, for the reason I described earlier
11:53:56 <mun> dcoutts, right
11:54:14 <mun> dcoutts, do you think i should uninstall ghc 6.10 and 6.8 and reinstall 6.8?
11:54:50 <nikki93> OMG! fac 0 = 1, fac (n+1) = (n+1) * fac n works! :o
11:55:12 <nikki93> Now that's pure math.
11:55:30 <Botje> nikki93: shh. you'll anger the people who hate n+k patterns :)
11:55:37 <idnar> n+k patterns are kinda evil, though...
11:55:38 <koeien> nikki93: and now do it without (n+1)
11:56:10 <mun> what's the best way to uninstall ghc 6.10 on linux? i compiled it from source.
11:56:17 <nikki93> koeien: Hm?
11:56:21 <wli> I don't mind n+k patterns; in fact, I'd not mind m*n+k patterns.
11:56:30 <koeien> nikki93: fac 0 = 1; fac n = n * fac (n-1)
11:56:51 <nikki93> koeien: Just subtract 1 from the 'n' terms everywhere, that's all..
11:57:02 <jeffersonheard> my particular favorite is how to calculate the Nth fibonacci number in sqrt(n) time using 2x2 matrix multiplcation
11:57:21 <koeien> jeffersonheard: by decomposition of A = [1 1 ; 1 0] ?
11:57:31 <jeffersonheard> koeien = yep
11:57:31 <nikki93> memoizing fac is awesome too..
11:57:46 <koeien> nikki93: if you want more factorial-implementations
11:57:52 <koeien> ?where The evolution of a haskell programmer
11:57:52 <lambdabot> I know nothing about the.
11:57:59 <koeien> @go The evolution of a haskell programmer
11:58:00 <lambdabot> http://www.willamette.edu/~fruehr/haskell/evolution.html
11:58:00 <lambdabot> Title: The Evolution of a Haskell Programmer
11:58:14 <nikki93> :)
11:58:19 <jeffersonheard> oh god the Peano numbers
11:58:53 <wli> The idea of "m*n+k" patterns would be being able to write something like fib (2*n) = let fn = fib n in fn * (2 * fib (n+1) - fn) ; fib (2*n+1) = (fib n)^2 + (fib (n+1))^2
11:59:16 <nikki93> Djikstra?
11:59:23 <c_wraith> Eh.  Does haskell have arbitrary-precision floating-point types?
11:59:51 <dolio> There's CReal, although that's not strictly "floating point".
12:00:07 <c_wraith> because floor(phi^n) is probably the fastest way to calculate fib n. :)
12:00:18 <wli> Memoizing fac? 1 : scanl1 (*) [1..]
12:00:39 <wli> c_wraith: Only for sufficiently small n.
12:01:04 <Gracenotes> c_wraith: for CReal is takes forever.
12:01:05 <wli> I'm still looking for hotar2k3
12:01:11 <dolio> > let phi :: CReal ; phi = (1 + sqrt 5)/2 in phi
12:01:12 <lambdabot>   1.6180339887498948482045868343656381177203
12:01:17 <Gracenotes> or at least an excruciatingly long amount of time
12:01:22 <wli> hotaru2k3 even.
12:01:24 <Gracenotes> *it
12:01:31 <c_wraith> is CReal BCD?
12:01:34 <Gracenotes> iterative is faster
12:01:45 <Gracenotes> (well, better than recursive)
12:01:47 <ski> `CReal' is exact (constructive) real numbers
12:01:50 <dolio> > let phi :: CReal ; phi = (1 + sqrt 5)/2 in floor $ phi^12
12:01:51 <lambdabot>   321
12:02:06 <Gracenotes> that's not the fib formula
12:02:37 <dolio> Yeah, what's the right one?
12:02:48 <dolio> I can never remember.
12:03:20 <c_wraith> Isn't it?  That looks right to me.
12:03:30 <wli> c_wraith: There is http://haskell.org/haskellwiki/The_Fibonacci_sequence#Fastest_Fib_in_the_West
12:03:39 <ski> > let phi :: CReal ; phi = (1 + sqrt 5)/2; phi' = 1 - phi; fib n = (phi ^ n - phi' ^ n) / (phi - phi') in fib 12
12:03:41 <lambdabot>   144.0
12:03:45 <wli> c_wraith: Though hotaru2k3 and I have made progress in this area.
12:03:47 <dolio> > (fix $ (1:) . scanl (+) 1) !! 12
12:03:48 <lambdabot>   233
12:03:51 <dolio> > (fix $ (1:) . scanl (+) 1) !! 13
12:03:52 <lambdabot>   377
12:03:59 <ski> > let phi :: CReal ; phi = (1 + sqrt 5)/2; phi' = 1 - phi in (phi - phi') - sqrt 5
12:03:59 <lambdabot>   0.0
12:04:12 <Gracenotes>   0.0
12:04:20 <dolio> > (fix $ (1:) . scanl (+) 1) !! 11
12:04:21 <lambdabot>   144
12:04:26 <ski> (c_wraith : dolio's one used `floor')
12:04:57 <c_wraith> phi' ^ n is always going to be < 1
12:05:03 <c_wraith> For positive n, anyway
12:05:22 <c_wraith> so (- phi' ^ n) is the same as floor
12:05:25 <Gracenotes> there are more efficient formulas, computationally, than that one
12:05:41 <Gracenotes> I mean ones with phi
12:06:56 <pcc1> is there an archive of old hpastes (i.e. from 2007) tried archive.org
12:07:18 <Gracenotes> anyway, calculating fib 1000 with ski's formula took 43 seconds :)
12:07:44 <Gracenotes> and 0.01 iteratively
12:08:06 <ehirdghostghost> Has anyone got a fix to the "haskell-mode repeats input" problem?
12:08:39 <wli> It's taking something like 8-9 us here.
12:09:04 <dolio> GMP has an arbitrary precision floating point type, but I think you have to choose the precision ahead of time.
12:09:04 <wli> For fib 1000 according to microbench.
12:09:12 <Gracenotes> us?
12:09:20 <dolio> And it has limited size for the exponent if I understand correctly.
12:09:33 <pcc1> nm gogle cache had it
12:09:59 <dolio> And, of course, you'd have to write a library wrapping all the C stuff into Haskell. :)
12:10:06 <Gracenotes> is the precision lazy anyway?
12:10:12 <Gracenotes> in GMP
12:10:25 <Gracenotes> or is it entirely calculated before you can use a number
12:10:32 <dcoutts> mun: so long as ghc-6.10 is not on the $PATH, then it'll just be ignored
12:10:33 <Gracenotes> like in Java's BigDecimal, iirc
12:10:37 <dolio> I think you select the precision when you allocate it, but I'm not totally sure.
12:11:33 <dcoutts> mun: I think if you copy the Setup.hs into each package subdir, or add build-type: Simple to all the .cabal files that they'll all install ok
12:11:41 <dolio> The exponent sounded like a harder limit, like no more than the word size.
12:11:47 <ski> (btw,  phi  and  phi'  are the two solutions for `x' in `x^2 - x - 1 = 0')
12:11:52 <dcoutts> mun: I think all the problems are with the fragile scripts and makefiles
12:12:14 <mun> dcoutts, right. but it's strange how make packages doesn't work here.
12:12:36 <dolio> But, I've never actually used it. Just browsed the docs while assesing how feasible it'd be for me to write a wrapper library.
12:12:38 * ski . o O ( let x^2 - x - 1 = 0 in ..x.. )
12:12:41 <mun> i keep getting ChildProcess.hs:97:6:  Ambiguous occurrence `env';  It could refer to either `ChildProcess.env', defined at ChildProcess.hs:85:6
12:12:57 <mun> or `System.Process.env', imported from System.Process at ChildProcess.hs:58:0-20
12:14:05 <dcoutts> mun: you're using a new process library
12:14:33 <mun> dcoutts, and that would have come with the 6.10 installation?
12:15:14 <mun> dcoutts, so i'll need to completely uninstall 6.10...
12:15:23 <dcoutts> mun: sounds like you're actually using 6.10
12:15:45 <mun> dcoutts, ghc --version gives 6.8.2 though
12:15:57 <dcoutts> mun: it's not possible to accidentally use a package for one version of ghc with another. It is however possible to install a later process lib for an older ghc.
12:16:23 <dcoutts> mun: you can check with ghc-pkg list process
12:16:47 <mun> dcoutts, i have 1.0.0.0 and 1.0.1.1
12:16:57 <dcoutts> mun: ok, get rid of the newer one
12:17:01 <mun> okay
12:17:17 <dcoutts> mun: use ghc-pkg check to see if there are any broken packages as a result
12:17:28 <ahamay42> What's wrong with force here?
12:17:28 <ahamay42> newtype (Arrow ar) => Failable ar a b = F {runF :: ar a (Either String b)}
12:17:28 <ahamay42> force :: (ArrowChoice ar) => Failable ar a b -> ar a b
12:17:28 <ahamay42> force (F f) = F $ f >>> (arr error ||| id)
12:17:28 <ahamay42> ghci:    Occurs check: cannot construct the infinite type:
12:17:28 <ahamay42>                  b = Either String b
12:17:28 <dcoutts> mun: or ghc-pkg list shows broken ones with {}'s
12:17:30 <ahamay42>               When generalising the type(s) for `force'
12:17:49 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2563#a2563 <- so what is the point of using arrows there? what can i abstract out with an arrow?
12:18:15 <vixey> ImInYourMonad: View Arrow.hs
12:18:16 <seliopou> Gracenotes: in GMP you select the precision when you allocate the number
12:18:26 <seliopou> I don't recall if you can change it afterwards, probably not
12:18:31 <mun> dcoutts, a lot of them have missing haskell98-1.0.1.0 as a dependency, is that normal?
12:19:15 <dcoutts> mun: that'd be bad. What version of haskell98 do you have registered?
12:19:25 <mun> dcoutts, oh i think that's because haskell98-1.0.1.0 needs process-1.0.1.1
12:19:26 <ImInYourMonad> is fmap basically apply?
12:19:29 <Gracenotes> seliopou: ah. does it calculate a number to full precision?
12:19:40 <Gracenotes> or just have a maximum precision that it .can. reach
12:19:41 <dcoutts> mun: ah, sounds like you've been using cabal update :-)
12:19:43 <dolio> @type arr error ||| id
12:19:44 <lambdabot> forall a. Either [Char] a -> a
12:19:45 <ImInYourMonad> vixey: where?
12:19:52 <dolio> @type arr error ||| arr id
12:19:53 <lambdabot> forall (a :: * -> * -> *) c. (ArrowChoice a) => a (Either [Char] c) c
12:19:58 <dcoutts> mun: get rid of these core packages registered in the per-user package db.
12:20:20 <ski> ImInYourMonad : "apply" ?
12:20:26 <seliopou> Gracenotes: I'm sortof talking out of my ass here, but in general this is how GMP works
12:20:41 <mun> dcoutts, haskell98-1.0.1.0 is the one wrapped inside {}
12:20:43 <dolio> ahamay42: You shouldn't wrap the result with F, that makes it think it's a Failable.
12:20:46 <seliopou> you have inputs x and y with their own precision, and you have a result z already allocated with some precision
12:20:50 <dcoutts> mun: check your ghc-pkg list for any cases where the exact same version is installed per-user and globally.
12:21:09 <mun> dcoutts, yes, the haskell98 in user has missing dependencies
12:21:09 <lilac> ski: with sufficient evil, i think i can get 'let x = x^2 - 1 in ..x..' to work
12:21:11 <seliopou> and you make a call like f(&z, x, y), and GMP will compute up to the precision of z
12:21:11 <mun> ok let me try
12:21:22 <dolio> ahamay42: Also, you should use hpaste next time.
12:21:24 <dcoutts> mun: so get rid of the per-user registered one
12:21:51 <ahamay42> dolio: yes, just put it there
12:21:56 <mun> much better
12:21:59 <seliopou> Gracenotes, does that answer your question?
12:22:11 * lilac hugs makeStableName, provider of many possibilities for evil
12:22:27 <ski> lilac : maybe some spectral sequences or what ?
12:22:30 <mun> i think i'll need to spend more time cleaning this up
12:22:39 <Gracenotes> seliopou: ah.. I see.suppose z's precision can't be reached
12:22:42 <Gracenotes> ?
12:22:45 <mun> dcoutts, is it bad to use cabal update?
12:23:04 <dcoutts> mun: I disabled it in the latest version because people kept using it to break their systems
12:23:08 <dolio> ahamay42: Anyhow, my advice is to remove the "F $".
12:23:08 <lilac> ski: special Num instance which solves quadratics by way of pure evil
12:23:08 <Gracenotes> seliopou: or does it not matter, since GMP sees x and y as finite anyway?
12:23:13 <ski> (also, tbh the `let' above is ambiguous .. i should have chosen `exists' or `forall')
12:23:28 <dcoutts> mun: you might like to install the latest version of cabal-install, (version 0.6.2)
12:23:50 <mun> dcoutts, i actually am using that version
12:23:50 <ski> (.. or have nondeterministic expressions .. maybe)
12:23:50 <ImInYourMonad> when does it make sense to declare a new class?
12:24:04 <ImInYourMonad> can you name a time you did ? i mean for what
12:24:05 <dcoutts> mun: ah ok, you'll notice cabal update is disabled
12:24:18 <seliopou> Gracenotes, not sure what you mean by that
12:24:29 <c_wraith> ImInYourMonad:  One common is when using MonadError in library code
12:24:32 <ahamay42> dolio: thx, that was the mistake
12:24:34 <mun> dcoutts, it's downloading the package list
12:24:36 <Gracenotes> hm. never mind. I'll take a look at the documentation myself
12:24:41 <ahamay42> next time I'll paste directly :)
12:24:41 <seliopou> it'll compute anything it can until z is full. If it can't fill it, then...
12:24:50 <dcoutts> mun: oops, upgrade I mean.
12:24:52 <seliopou> it can't fill it
12:24:57 <mun> dcoutts, i see
12:24:58 <lilac> ImInYourMonad: if you have some general interface which you have multiple types which conform to
12:24:58 <ski> ImInYourMonad : i invented a new class `Variable' for types supporting logic variables (and skolems)
12:25:15 <c_wraith> ImInYourMonad: You declare a class for your Error type, so that you don't restrict code using your library to have to use your exact error.
12:25:20 <mun> dcoutts, i'll spend some more time cleaning up other broken dependencies
12:25:27 <mun> dcoutts, thanks very much for your help today
12:25:28 <seliopou> that doesn't seem to be problematic, does it?
12:25:32 <dcoutts> mun: np
12:25:33 <mun> very appreciated
12:25:41 <Gracenotes> not really
12:26:24 <ImInYourMonad> and thn you could ahve you functions that id need to use?
12:36:31 <kmeyer> why does Set require Ord (and not just Eq)?
12:36:47 <vixey> kmeyer, it builds a tree from these elemenst
12:36:58 <kmeyer> and?
12:37:03 <c_wraith> a binary search tree
12:37:05 <trofi> HashSet should not :]
12:37:11 <kmeyer> ah
12:37:30 <dolio> HashSet would require Hash, though. :)
12:37:30 <kmeyer> an unordered uptree also works for storing a set
12:38:06 <trofi> @hoogle HashSet
12:38:06 <lambdabot> No results found
12:41:58 <wli> I'm a big fan of hash tries. They're like ordinary tries / radix trees with huge branching factors and node sizes mitigated via hashing by open addressing.
12:45:20 * Gracenotes should try implementing a basic Huffman coding thing in Haskell
12:46:00 <vixey> Gracenotes: do it pointfree
12:46:21 <Gracenotes> is there any particular difference between that and doing it pointful? :)
12:46:34 <vixey> yes
12:46:46 <Gracenotes> besides explicit arguments, that is
12:46:49 <vixey> no
12:47:32 <Gracenotes> vixey: oh, I see. So as an exercise?
12:47:37 <vixey> yes
12:48:14 <dolio> Turn in your solution by Friday.
12:48:28 <Gracenotes> is there extra credit?
12:48:33 <kmeyer> yes
12:48:36 <kmeyer> type with your nose only
12:49:16 <vixey> yes lots of extra credit
12:49:38 <Gracenotes> oikay
12:49:38 <Gracenotes> wait, you can't verify that
12:50:33 <gwern> Gracenotes: the pattern of typos will give it away
12:51:05 <seliopou> they'll spell FACE SMASH
12:51:39 <Gracenotes> okay, I'll type with my prehensile tongue then
12:51:46 <seliopou> oh my
12:51:52 <wli> benchpress seems to be doing slightly better wrt. statistics but isn't doing anything truly useful like student's t or casting out outliers etc.
12:52:23 <gwern> prehensile tongue?
12:52:30 * gwern resists the urge
12:54:02 <Gracenotes> gwern: it's okay, I've accepted myself
12:54:19 <Saizan_> is there a declarative description of Tarjan's SCC algorithm somewhere?
12:54:44 <gwern> Gracenotes: actually, I was thinking more along the lines of 'Gracenotes: you can come over any day then!'
12:55:23 <Gracenotes> ah. I see
12:55:24 <Gracenotes> <(^.^<)
12:56:21 <Gracenotes> -_-
12:58:04 <Gracenotes> truthfully, I can't even roll my tongue up into a U
12:58:15 <Gracenotes> not being genetically equipped to do so
12:58:15 <lament> you are worthless
12:58:33 <dolio> Wow.
12:58:34 <vixey> :u
12:58:50 <lament> :w
12:59:05 <dolio> You aren't really a human being unless you can do the clover thing.
12:59:10 <gwern> Gracenotes: can you at least wiggle your ears?
12:59:19 <gwern> or do the trek greeting?
12:59:21 <Gracenotes> not without moving my jaw
12:59:26 <lament> dolio: you haven't really lived, certainly
12:59:27 <vixey> it's like primary school here :p
12:59:29 <Gracenotes> yes, I am very adept at the Trek getting
12:59:56 <Gracenotes> as well as crossing four pairs of fingers at the same time (on two hands)
13:00:32 <Gracenotes> not to mention singing the alphabet backwards
13:00:34 <Gracenotes> !
13:01:08 <dolio> That'll help when you get field tested.
13:01:09 <lament> there's some hope for you
13:01:38 <lament> do you have any other possible redeeming features, like extra joints, webbed palms, second head?
13:02:23 <Gracenotes> I have expressive eyebrows
13:03:00 <Gracenotes> uh
13:03:26 <Gracenotes> I think that's it
13:04:17 <Gracenotes> oh, and I can implement Huffman coding in Haskell
13:04:43 <ImInYourMonad> > let (pointFree == pointLess) == True in Missile
13:04:45 <lambdabot>   <no location info>: parse error on input `in'
13:04:50 <ImInYourMonad> > let (pointFree == pointLess) = True in Missile
13:04:51 <gwern> anyone can do that
13:04:51 <lambdabot>   <no location info>: Parse error in pattern
13:04:57 <gwern> but can you do it on the type level?
13:05:52 <Gracenotes> do you really think implementing Huffman coding on the type level will be useful in the coming apocalypse?
13:06:00 <wchogg> Almost certainly
13:09:53 <koeien> I <3 haskell!!!
13:10:19 <Nafai> koeien: That's the kind of enthusiasm we like to see! :)
13:10:30 <wchogg> Yeah, but what prompted it?
13:10:35 <koeien> lazy evaluation saved the day
13:10:55 <koeien> or my program is a gazillion times faster than an equivalent C program
13:11:06 <koeien> (naively written)
13:11:42 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2567#a2567 <- im trying to implement a typeclass but it is not working
13:12:05 <koeien> ImInYourMonad: what is a1 ?
13:12:13 <c_wraith> a1 is unbound...
13:12:23 <koeien> yes i see that, but that is pointless
13:12:23 <c_wraith> unbound types are usually bad
13:13:49 <Gracenotes> @. unpl run text . intercalate "." $ replicate 10 "(.)"
13:13:51 <lambdabot> (\ ag b c f i l o r u x aa ad -> ag (b c f i l o r u x aa ad))
13:14:23 <mreha> does Roman Leshchinskiy hang out here?
13:14:29 <koeien> ImInYourMonad: there are various problems with your code. e.g. type type of 'fire' in the instance
13:16:04 <Gracenotes> @djinn a -> a1
13:16:04 <lambdabot> -- f cannot be realized.
13:16:49 <c_wraith> eh?  doesn't "const undefined" realize a -> a1 ?
13:16:51 <koeien> Gracenotes: yes, only undefined / const undefined make sense there
13:17:02 <mreha> Does no one seriously want to mentor that NES emulator project for GSoC?
13:17:03 <koeien> c_wraith: that doesn't count.
13:17:12 <c_wraith> I suppose it doesn't.
13:17:16 <Gracenotes> djinn ignores trivial cases
13:17:29 <koeien> in a `seq`-less language, it's the same as undefined
13:17:58 <Gracenotes> I suppose it's just not part of its intuitionist logic
13:18:06 <Gracenotes> given that bottom is false, iirc
13:18:32 <travisbrady> i'm writing something that uses Network.Socket.ByteString and Data.Binary which are strict and lazy respectively, is there some way to unify them in some way to avoid explicit conversions?
13:18:40 <c_wraith> ImInYourMonad: You might want to declare the typeclass as "class Fireable a b"
13:18:50 <Gracenotes> MultiparameterTypeclasses
13:18:52 <Gracenotes> or somelike
13:18:57 <c_wraith> Give it two type parameters, one for the input, one for the output
13:19:00 <koeien> in that case you need {-# LANGUAGE MultiParamTypeClasses #-}
13:19:04 <vixey> bottom is false  ?
13:19:09 <koeien> (but GHC will warn you)
13:19:17 <Gracenotes> vixey:  :(
13:19:50 <Gracenotes> if I recall correctly. Since the statement was based entirely on recall, not meaningful knowledge
13:20:48 <lament> if you model false as bottom, your program will always be true!
13:21:01 <miamiam> Hi, I want to link a lot of people on my facebook, add me at Pascal Parret !
13:21:54 <Gracenotes> lament: oh goodie :)
13:22:03 <travisbrady> Gracenotes: that would still require that lazy to strict and vice versa conversions were being done though right, just behind the scenes?
13:22:25 <travisbrady> i'm concerned about performance
13:22:57 <Gracenotes> of @djinn?
13:23:52 <travisbrady> Gracenotes: oops, sorry i thought you were answering my question
13:24:06 <tromp> @hoogle isSuffix
13:24:06 <lambdabot> Data.ByteString isSuffixOf :: ByteString -> ByteString -> Bool
13:24:06 <lambdabot> Data.List isSuffixOf :: Eq a => [a] -> [a] -> Bool
13:24:06 <lambdabot> Data.ByteString.Char8 isSuffixOf :: ByteString -> ByteString -> Bool
13:25:56 <pao> is there a catch in defining "class  MyFunctor f a b where myMap :: (a -> b) -> f a -> f b" in order to support restricted functors?
13:26:25 <ImInYourMonad> class Fireable a where; does all instances of Fireable be 1 param things or cant they be records?
13:28:14 <alexsuraci> Isn't there a command/app to get the info (e.g. class) of a window?
13:28:32 <alexsuraci> er, in X11
13:28:37 <Gracenotes> ImInYourMonad: records?
13:28:57 <Gracenotes> hm, do you mean one-parameter vs. multi-parameter type classes?
13:29:17 <alexsuraci> xprop. that's it.
13:29:27 <Gracenotes> er, I mean, type variables
13:30:00 <Gracenotes> if by records you mean constructors, then that has little to do with typeclass instances
13:30:47 <insane> hello i'm looking for someone responsible for haskell projects regarding google summer of code
13:30:47 <ImInYourMonad> yes
13:31:55 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2567#a2569 <- first part(2) works
13:32:00 <ImInYourMonad> but i want something like the second
13:32:54 <Gracenotes> ImInYourMonad: if you have a function a -> b -> (a, b), then the only possibly implementation is fire2 a b = (f a, b)
13:33:29 <Gracenotes> f :: a -> a, assuming you know the type of a in advance. Unless I'm reading it wrong.
13:35:01 <Gracenotes> ImInYourMonad: it seems like you want a multiparameter typeclass, so use it :) class Fireable a b where fire :: a -> b -> (a,b)
13:36:36 <ImInYourMonad> Use -XMultiParamTypeClasses to
13:37:03 <ImInYourMonad> how do I declare that?
13:37:04 <ImInYourMonad> {- XMultiParamTypeClasses -}
13:37:21 <jeffersonheard> has anyone written a unit conversion library?  I don't see one on hackage.   like meters -> inches, etcetera
13:37:38 <jeffersonheard> figured that the entire thing could be written using newtypes and realToFrac
13:37:47 <jeffersonheard> but I'm not sure
13:38:40 <Gracenotes> you can use the LANGUAGE pragma, as koeien mentioned... {-# LANGUAGE MultiParamTypeClasses #-}
13:39:02 <vixey> "infinite lambda terms constitute a syntactic approach to the semantics of finite lambda terms with beta reduction"
13:39:51 <ImInYourMonad> doesnt work,unknown extension
13:40:34 <ImInYourMonad>  unsupported extension: XMultiParamTypeClasses
13:40:48 <Gracenotes> the X is for command line args. try taking it out
13:42:18 <insane> is there anyone who i can ask few questions regarding this year google summer of code?
13:42:35 <vixey> isn't there a #gsoc
13:43:10 <insane> yes there is but i'm interrested in applying for one of haskell projects
13:43:50 <insane> so i decided to ask here ;]
13:44:32 <Gracenotes> oh, an official GSOC channel?
13:44:56 <dancor> how is unamb useful
13:45:00 <insane> Gracenotes: ?
13:45:18 <dancor> if the things have to have the same value
13:45:20 <mreha> are haskell programs like trees?
13:45:37 <mreha> i.e. can i do GP in haskell?
13:46:03 <vixey> mreha: what's GP
13:46:05 <dons> hmm?
13:46:09 <dancor> http://en.wikipedia.org/wiki/Goal_programming ?
13:46:14 <mreha> genetic programming
13:46:18 <dancor> oh
13:46:19 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2571#a2571 <- zero is to little, 1 is too many, hmm
13:46:21 <tromp> yes, you could mutate the parse tree
13:46:27 <tromp> but you have to preserve types
13:46:51 <mreha> getting the damn thing to even work parse would be an issue
13:46:58 <ImInYourMonad> mreha: yes you could write a compiler or interpreter, use harpy to generate machine oce, maybe use Data.Dynamic
13:47:05 <tromp> and not mess up the scope
13:47:05 <mreha> s//work/
13:47:28 <mreha> i suspect lisp/scheme are best suited to GP
13:47:48 <dons> why?
13:47:50 <dancor> or some really minimal lang
13:48:03 <dons> oh, you want to mutate the source?
13:48:11 <mreha> because a scheme program is a tree
13:48:14 <dons> or do you want to write genetic algorithms for other systems?
13:48:29 <dons> can you explain why being a tree helps?
13:48:31 <mreha> a genetic program is a genetic algorithm
13:48:50 <mreha> because you can easily do genetic operations on trees
13:48:56 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2571#a2571 <- zero is to little, 1 is too many, hmm
13:48:56 <dancor> if you can find a way to "stay within the lines" tho, it could be nice that the set of programs that compile in haskell is smaller and more likely to do something useful..
13:49:04 <mreha> but also being scheme, there is no namespace
13:49:23 <mreha> dancor: yeah
13:49:46 <dons> mreha: so you mean to mutate the actual syntax tree of the program itself?
13:49:47 <BMeph> ImInYourMonad: You do know that 34:9 and 34:19 are two different sections of your program, right? :)
13:49:49 <mreha> i'm writing a proposal for GSoC, just wondering if Haskell could be a candidate for GP as an extension to a GA framework i want to write
13:50:04 <mreha> dons: you mutate the actual program yeah
13:50:22 <mreha> dons: by mutation, i mean macro mutation
13:50:26 <dons> how do you make it semantics-preserving?
13:50:30 <Aisling> "Strongly Typed Genetic Programming" http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.45.5720
13:50:34 <mreha> taking one program and crossbreeding with another
13:50:49 <mreha> hrm
13:50:51 <Aisling> mreha: might be interesting to you
13:50:58 <mreha> in scheme, you dont have string typing
13:51:02 <mreha> thanks
13:51:06 <mreha> strong*
13:51:26 <mreha> actually, in reality scheme programs are lists
13:51:39 <mreha> which makes them impossible to read
13:51:40 <dons> right, i can see  how having a small, simple AST makes manipulating the AST easy.
13:51:42 <ImInYourMonad> BMeph: yeah i cut pasted the relevant stuff
13:52:25 <dons> how do you ensure that your modifcations don't break the program? (and what's the goal of the breeding? to find solutions? or make existing code fasteR?)
13:52:57 <mreha> dons: you dont
13:52:57 <mreha> you have to get lucky
13:53:20 <dons> you just make random programs, and hope they work?
13:53:30 <mreha> or use a language that makes luck easy to come by
13:53:32 <trofi> :]
13:53:37 <seliopou> Programming is hard. Let's go mutating!
13:53:40 <mreha> dons: yup, or salt the population
13:53:41 <skorpan> dons: that what python programmers do
13:53:44 <dons> what kind of problems can be solved this way?
13:53:47 <mreha> haha
13:53:48 <tromp> try using plain lambda calculus
13:53:50 <trofi> s/python/windows
13:53:52 <dons> (seems like the search space is very big)
13:53:56 <ImInYourMonad> i did a genetic something program in clojure.it took data as input and tried to find a function that fits the data, what is that called?
13:54:09 <mreha> it's not random anyway, it's more like intelligent design than darwinian evolution
13:54:12 <pumpkin> ImInYourMonad: you mean as a sequence?
13:54:17 <mreha> take that anti-creationism!!!
13:54:22 <ImInYourMonad> dons: optimization problems
13:54:24 <ozy`> dons: the search space is huge, naturally. hence the research into ways to make it smaller
13:54:38 <dons> ImInYourMonad: but in this case he's talking about generating entire programs?
13:54:49 <mreha> yup
13:54:50 <dons> i'm wondering what kind of problems are usefully solved this way
13:54:54 <vixey> none
13:54:58 <pumpkin> lol
13:55:01 <mreha> hah
13:55:02 <dons> fwiw, i wrote a post on using GAs to solve inlining in haskell last week
13:55:11 <tromp> normally you mutate over parameter space
13:55:12 <ozy`> there are a lot of alternatives to GA
13:55:12 <dons> http://donsbot.wordpress.com/2009/03/09/evolving-faster-haskell-programs/
13:55:13 <ImInYourMonad> dons: Nasa made an antenna
13:55:21 <dons> ImInYourMonad: yep, i know about that.
13:55:37 <tromp> mutating programs break too often
13:55:44 <dons> if the modification space is small, i don't think being tree-based helps signficantly, fwiw
13:55:50 <dons> the bottleneck won't be writing AST manipulations
13:55:55 <ImInYourMonad> http://ti.arc.nasa.gov/projects/esg/research/antenna.htm
13:56:02 <ozy`> tromp: finding a way to make them not break would be pretty awesome, wouldn't it?
13:56:35 <tromp> that would mean the language is not very expressive
13:56:58 <mreha> you're confusing programming with genetic programming
13:57:02 <mreha> this isn't done by men
13:57:04 <ozy`> tromp: no, it would just mean the mutating algorithm is smarter
13:57:38 <vixey> mreha: How do you grade each program?
13:57:43 <tromp> you mean semantics preserving?
13:57:49 <mreha> fitness function
13:58:10 <mreha> how well does this solution fit, say, a curve
13:58:35 <tromp> sure it wld be awesome
13:58:46 <mreha> it's up to the designer to define that
13:59:01 <mreha> i wrote a chess playing GA, and the fitness function was "who has won the most games"
13:59:04 <dancor> genetic programming is just searching thru the space of all programs.  unfortunately generic searching usually takes way too long
13:59:04 <ImInYourMonad> again, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2571#a2571, what do i need to do?
13:59:39 <mreha> dancor: read about schemas
14:00:03 <mreha> the problem space is composed of intersecting planes
14:00:12 <vixey> mreha: But how you, given a program.. compute the value of "fitness function"
14:00:20 <mreha> if you find one of those planes, it will start cropping up in all of your solutions
14:00:28 <vixey> mreha: do you use EVAL?
14:00:29 <pumpkin> ImInYourMonad: Firable takes two type arguments
14:00:33 <pumpkin> Fireable
14:00:41 <pumpkin> Battleship takes 2
14:00:43 <pumpkin> 0, I mean
14:00:51 <Gracenotes> success
14:01:02 <pumpkin> yeah, I suck
14:01:03 <pumpkin> lol
14:01:16 <mreha> you sank my battleship
14:01:46 <mreha> vixey: in GP, you run the program
14:01:54 <ImInYourMonad> so how do i silve it?
14:02:28 <pumpkin> ImInYourMonad: you make your kinds consistent... I don't know what your intent there is
14:02:33 <mreha> and record how long it took, how close the answer was to what you want, run a profiler, anything you like
14:02:35 <ImInYourMonad> me neither
14:02:44 <pumpkin> ImInYourMonad: if you don't know, then you're in trouble :)
14:02:47 <ImInYourMonad> can you make my stuff consistent?
14:02:58 <ImInYourMonad> i jsut want something that compiles
14:03:04 <pumpkin> Fireable uses both its type arguments
14:03:14 <pumpkin> you need to figure out what the second argument means :P
14:03:23 <pumpkin> and then provide it
14:03:34 <pumpkin> or decide there isn't a need for the second one, change the type of fire
14:03:52 <mreha> vixey: did you see what I wrote
14:04:15 <ImInYourMonad> both arwe battleships
14:04:28 <ImInYourMonad> but should thr instance jabev mroe thna one type?
14:04:41 <ImInYourMonad> oh there
14:04:42 <vixey> mreha: you run the program - what if it doesn't terminate
14:05:17 <mreha> timeout
14:05:29 <mreha> and it scores -infinit
14:05:55 <mreha> dons: is there a GA framework for haskell already?
14:06:38 <dancor> mreha: http://hackage.haskell.org/packages/archive/pkg-list.html
14:06:54 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2571#a2572
14:07:09 <ImInYourMonad> so now what
14:07:45 <Gracenotes> ImInYourMonad: Battleship 10 is a function
14:07:55 <Gracenotes> Int -> Battleship
14:08:07 <mreha> you sank my battleship
14:08:17 <Gracenotes> add an Int (the life record name) for it to be a Battleship
14:08:45 <ImInYourMonad> god im stupid
14:08:49 <Gracenotes> or declare it using record notation if you like; perhaps better for not screwing up parameters etc.
14:08:58 <ImInYourMonad> yeah i egt it soemtimes i wodner if im retarded
14:10:25 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2573#a2573
14:10:27 <ImInYourMonad> wee!
14:11:07 <pumpkin> what is the Fireable class trying to capture? the fact that only some ships can fire at each other?
14:12:27 <Gracenotes> it sounds pretty much like multiple dispatch. unfortunately, you might reach a dead end if you don't know exactly the type of everything
14:12:52 <ImInYourMonad> if i have : f a b; and get (a,b) as inout, sint f $ uncurry (a,b) correct then?
14:13:07 <Gracenotes> you could take the opposite approach and use a typeclass for missiles, rocks, bunnies, whatever else you have on the playing field, with means to modify life/missiles/whatever
14:13:36 <ImInYourMonad> uncurry fire
14:14:31 <Gracenotes> @type uncurry
14:14:32 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
14:15:03 <pumpkin> you need curry :)
14:15:10 <pumpkin> and basmati rice
14:15:27 <Gracenotes> my old shoes were stained with curry lentil soup
14:15:43 <Gracenotes> until, that is, my family dog licked them clean during winter break
14:15:53 <ImInYourMonad> Gracenotes: isnt that what im doing?
14:16:55 <Gracenotes> ImInYourMonad: if f is a -> b -> c, uncurry f (x, y) will get you a c
14:20:51 <Alpounet> uncurry f $ (x,y)
14:21:00 <vixey> uncurry f (x,y)
14:21:11 <Alpounet> (is clearer)
14:21:16 <vixey> no it isn't
14:21:37 <vixey> uncurry f(x,y)
14:21:43 <vixey> that's unclear ^
14:21:54 <Alpounet> heh
14:22:06 <ImInYourMonad> i see now a little more about typeclasses
14:22:09 <ImInYourMonad> foldable etc
14:22:30 <ImInYourMonad> I could amke one(doesnt make much sense though) Transposable and implement it for lists and matrices for example
14:25:30 <Alpounet> Oh I forgot, vixey, yes it is.
14:25:30 <Alpounet> :-p
14:25:40 <vixey> yes what is?
14:25:44 <dolio> It.
14:25:59 <Alpounet> check above.
14:27:12 <vixey> "The formal systems describing logic, ontology, and computability have an amazingly small number of axioms and rules."
14:27:24 <vixey> did anyone try  wc  in Agda repo? :p
14:27:42 <vixey> maybe it has small description but no simple implementation..
14:28:24 <dolio> Agda isn't even close to a minimal implementation.
14:28:32 <kmeyer> is the "pure" function for ((->) e) as an instance of Pointed just const?
14:29:31 <ImInYourMonad> (f *** g) ~(a,b) = (f a, g b)
14:29:31 <ImInYourMonad> foo f g ~(a,b) = (f a, g b)
14:29:31 <ImInYourMonad> what advantage does the arrow offer? i think it just males it look more perly...
14:29:33 <vixey> It seems like Agda is a direct implementation of some high level language -- but it doesn't compile down into the (logically) simple one
14:32:03 <dolio> The wonky pure type system interpreter on my code.haskell.org page is probably multiple orders of magnitude smaller than Agda.
14:32:10 <iago_> ImInYourMonad, the arrow is a generalization, the code is just a case for an arrow (->)
14:32:41 <vixey> dolio: But the question is how to translate some complex program with data types and pattern matching into it
14:32:56 <ImInYourMonad> -> is not an arrow is it? isnt that jsut syntax?
14:33:04 <vixey> (such that agda typechecks it <= your PTS code typechecks it)
14:33:12 <dons> shapr, glguy are the old posts on hpaste available anywhere?
14:33:16 <iago_> ImInYourMonad, of course, (->) is an arrow
14:33:31 <kosmikus> vixey: full implementations of programming languages are almost never simple. why should agda be simpler in that respect than typical Haskell implementations?
14:33:37 <iago_> but there is another arrows
14:33:43 <iago_> there are*
14:33:47 <ImInYourMonad> yeah it looks like an arrow
14:34:01 <ImInYourMonad> Control.Arrow, is -> one?
14:34:13 <iago_> is what I'm saying
14:34:59 <ImInYourMonad> why is it of course an arrow?
14:36:06 <vixey> kosmikus: I don't think Agda needs to be small (simple would be nice though), that would mean getting rid of nice things like interactive use, inference etc... but I think it would be good if there was a small typechecker for agda code (or agda code that has implicit parameters put in and pattern matching compiled away for example)
14:36:37 <ImInYourMonad> what is a good template haskell tutorial?
14:36:38 <vixey> I def. agree with the observation about implementations being hideous and complicated.. hopefully that isn't going to continue
14:36:55 <dolio> That's kind of what Coq strives for, no?
14:36:56 <iago_> ImInYourMonad, well, I think the name Arrow is not casual
14:37:10 <dolio> Simple underlying core type theory with complex overlays.
14:37:27 <vixey> It's called De Bruijn criteria
14:37:34 <vixey> (I think it is)
14:37:56 <dolio> Agda is 'practical dependently typed programming.'
14:38:26 <vixey> so practical is justification for everything bad about it ? :p
14:39:36 <jmcarthur> is it so bad that the code base is large?
14:39:54 <vixey> jmcarthur: I tried to make a distinction between large/small and complex/simple
14:40:00 <jmcarthur> ah yes i see now
14:40:34 <jmcarthur> i can't say anything about agda's simplicity or lack thereof as i haven't studied its code. semantically, agda seems... mostly simple
14:40:50 <vixey> but also to write an efficient compiler, I should think working out the theory for a small core language is easier and more practical than working it all out for a monstrous thing
14:40:58 <kosmikus> dolio, vixey: I agree that we should strive for simpler implementations of dependently typed programming languages, even if that means that they're less practical. but I don't think the design space has been explored enough yet.
14:41:13 <jmcarthur> it also seems highly researchy for a "practical" language. they are constantly adding and removing features
14:41:35 <kosmikus> vixey: and yes, I'd support that Agda should try to compile to a core language
14:41:37 <jmcarthur> of course it's a work in progress, so i can't blame them for it
14:41:48 <jmcarthur> yeah, compiling to haskell doesn't feel right to me
14:42:18 <vixey> compiling to haskell seems like an awful idea
14:42:20 <kosmikus> jmcarthur: Agda is "practical" on a whole different level
14:42:32 <dolio> It's a research language trying to figure out what a "practical" language with dependent types should look like. :)
14:42:37 <vixey> Haskell has such a different type system that programs will not survive the journey
14:42:40 <jmcarthur> kosmikus, no i get it. for a language with dependent types, it's highly highly practical
14:42:45 <kosmikus> yes
14:42:52 <Gracenotes> dolio: is Epigram somewhat like that as well?
14:43:00 <dolio> Yes.
14:43:03 <vixey> afaict Epigram is dead
14:43:03 <jmcarthur> epigram is an attempt from a different direction
14:43:12 <vixey> (which is a terrible shame)
14:43:27 <dolio> Although epigram seems to stick closer to the 'build on an underlying, simple type theory' too.
14:43:29 <kosmikus> Epigram is not necessarily dead
14:43:40 <kosmikus> there are still people working on a new version, albeit slowly
14:43:42 <vixey> kosmikus: I just mean in terms of nobody is hacking on it
14:43:53 <kosmikus> nobody is working on the old Epigram
14:43:56 <dolio> Instead of taking the fancy stuff as primitive, like agda seems to.
14:44:37 <jmcarthur> seems to me that epigram is undergoing a lot of rethinking right now
14:44:38 <kosmikus> but there's still some hope that Epigram 2 will ultimately appear
14:45:07 <vixey> dolio: But I think giving direct implementations of fancy stuff is pragmatic (and important for bigger programs/theories) but without having any way to justify it in terms of a smaller core is very distressing
14:46:09 <vixey> (I know there is some research paper that say this is possible.. but that's not really in the spirit of curry-howard, no computational evidence)
14:46:15 <ImInYourMonad> does calling (main = do) mainmuppeteer = do ; change the semantics ?
14:47:20 <Gracenotes> (main = do) ?
14:47:30 <ImInYourMonad> main = do blah
14:47:47 <dolio> Agda is just one language. There are plenty of others to focus on the complex-on-top-of-simple stuff.
14:48:07 <Gracenotes> well, blah will have to be of type IO ()
14:48:21 <vixey> kosmikus: (It's just that there seems to be no posts on the mailing list in ages, and no commits to the repo since last year. I guess pi-sigma is research but not sure what else is going on)
14:48:43 <vixey> dolio: so you think its not fundamentally important to go that way ?
14:48:49 <seliopou> agda's code is in a darcs repo :(
14:49:04 <dolio> Conor mentioned in the thread about his numeric constraints project that he's still working on epigram, if slowly.
14:49:19 <dolio> I think it's not fundamentally important for every single language in existence to go that way.
14:49:35 <JuanDaugherty> anybody use Hets?
14:50:01 <dolio> Some have to look for fancy stuff so that we know what needs to be grounded by the simple stuff.
14:50:09 <aempirei> haskelltown!
14:50:13 <vixey> dolio, it seems odd because you can't really trust something so complex.. and that means we don't really know if programs you write in it are type safe
14:50:34 <seliopou> aempirei, like tacotown?
14:50:47 <vixey> then again, a lot of people that use haskell don't even care about type safe code (unsafePerformIO)
14:50:58 <JuanDaugherty> no, like chinatown
14:51:02 <jmcarthur> seliopou, what's wrong with agda being in a darcs repo?
14:51:12 <seliopou> Somebody should make a haskelltown video, except use monad transformers instead of tortillas, pizzas, and pancakes
14:51:13 <kosmikus> vixey: pi-sigma is unrelated to epigram
14:51:29 <seliopou> it makes me less likely to check it out :(
14:51:50 <jmcarthur> seliopou, because of speed?
14:51:51 <kosmikus> vixey: Conor moved universities, the people who've been working on Epigram in Nottingham are scattered around, but I'm still optimistic that something might happen in the future.
14:52:13 <seliopou> I don't like the feel of it
14:52:21 <jmcarthur> ah
14:52:32 <seliopou> (note: I'm an avid git user)
14:53:09 <jmcarthur> i am mostly a git user and didn't like the way darcs "felt" for a long time either, but i've made myself use it for a while now to learn more about the theory of patches and have grown quite accustomed to it
14:53:26 <kosmikus> forgive me, but saying that you're not going to look at the project because of its choice of vcs is something I'd understand if the system in question is RCS or CVS, but not darcs vs. git. vs. mercurial vs. ...
14:53:50 <vixey> I think you can cabal install it now ?
14:53:52 <seliopou> "less likely"
14:54:12 <jmcarthur> yeah, cabal install agda works great :)
14:54:21 <jmcarthur> as long as you have alex and happy already installed
14:54:23 <seliopou> does cabal still have that bug on OS X?
14:54:27 <vixey> grumble
14:54:28 <korpios> kosmikus: well, *look at*, yes ... but I've honestly felt much less likely to want to *contribute* to a project that's not using git, once I really became comfortable with it
14:54:29 <seliopou> where it eats up all your memory?
14:54:38 * vixey has installed alex and happy about 20 times
14:55:07 <vixey> korpios: why is it a big deal, isn't there like 3 commands you need to know? Doesn't take that long to learn them
14:55:14 <kosmikus> korpios: I also like git more than darcs at the moment. But I don't understand why it would be a reason for anyone not to contribute.
14:55:22 <pejo> korpios, I'm sure they'll accept traditional patches.
14:55:34 <korpios> that's the thing -- I don't want to bother with patches anymore
14:55:49 <korpios> I want to point to a git branch and say "pull that"
14:55:54 <seliopou> this argument is pointless, btw
14:56:12 <korpios> (not really arguing, just pointing out my particular tendency)
14:56:26 <kosmikus> I think there's a lot to be said to not switch vcs of a project with every change in fashion
14:56:32 * korpios shrugs
14:56:41 <JuanDaugherty> anybody already know of and/or have an opinion on Hets?
14:57:08 <JuanDaugherty> s/opinion/impression/
14:57:12 <ddarius> You shouldn't be switching vcses at all without a very good reason.
14:57:33 <kosmikus> ddarius: yes, indeed.
14:57:38 <dons> yeah, really, darcs and git are so similar, it shouldn't be an issue
14:57:39 <Zao> ddarius: Especially not within a project.
14:57:51 <dons> you should count your blessings darcs and git exist at all :)
14:58:23 <Heffalump> they're only similar if you haven't watched Ian's video ;-)
14:58:33 <ddarius> If I were going to stand up an open source VCS at work, I'd probably use Subversion.
14:58:36 <dons> hehe. ok.
14:58:40 <kosmikus> in a way, I'm happy that I haven't given in to the pressure of switching from SVN to darcs for lhs2TeX, because by now people would start asking me why I'm not using git instead.
14:58:40 <jmcarthur> darcs and git are worlds apart
14:58:56 <Eridius> yeah, darcs is for academics and git is actually useful ;)
14:59:01 <dons> only if the words are dvcs with cherry picking and cheap branches.
14:59:04 <seliopou> zing!
14:59:04 <dons> worlds.
14:59:08 <JuanDaugherty> darcs, last I knew was in a world of its own.
14:59:35 <Heffalump> absolutely. A very nice world, if you don't mind the odd inefficiency here and there.
14:59:37 <ddarius> Eridius: You know the history of git, yes?
15:00:02 * seliopou is curious where ddarius is going with this
15:00:02 <Eridius> ddarius: yeah, why?
15:00:10 <JuanDaugherty> isn't a vcs a bikeshed?
15:00:37 <jmcarthur> the differences between darcs and git are at least large enough that the way i use each of them is drastically different
15:00:57 <dons> jmcarthur: wow, really?
15:01:13 <dons> i use them identically, but with git not quite as fluid.
15:01:27 <Eridius> really? I can barely use darcs
15:01:30 <wli> I'm terrible with vcs's on all fronts.
15:01:31 <seliopou> So it's been a while, but does darcs have have an interactive rebase feature?
15:01:47 <vixey> dolio: what I meant really is that it seems /more/ researchy if it doesn't satisy de bruijn criteria than if it did
15:02:05 <jmcarthur> seliopou, rebase is meaningless in darcs because the patches commute
15:02:06 <seliopou> At the risk of looking foolish: or rebasing at all?
15:02:11 <Heffalump> seliopou: in certain cases you get rebase for free just by cherry-picking, and in cases where that doesn't work because of dependencies or conflicts, you're completely out of luck
15:02:15 <wli> vixey: What are de Bruijn criteria?
15:02:25 <Heffalump> jmcarthur: *if* the patches commute
15:02:29 <seliopou> yeah
15:02:35 <jmcarthur> Heffalump, of course, if there are dependencies and conflicts then a git-style rebase would fail too
15:02:39 <Heffalump> it's not meaningless, you can simulate it with amend-record, but for more than one patch it's very hard
15:02:46 <Heffalump> jmcarthur: I thought it just gave you conflicts?
15:02:51 <dolio> vixey: I'm not sure the common man would agree with your definition of "researchy," but I understand what you mean. :)
15:02:54 <vixey> wli: that proofs (programs against types) should be checkable by a simple core that is easily rewritting/replaced
15:03:13 <Heffalump> actually, I'm not 100% certain I fully understand what scenarios git rebase covers.
15:03:24 <Eridius> jmcarthur: rebase makes a certain amount of sense in darcs - if there are conflicts, it seems like it might be useful to be able to "rebase" a patch on top, fix the conflicts, and produce a new patch that now depends on what you just rebased over
15:03:27 <jmcarthur> Heffalump, yes... stopping for every single patch in the dependency chain, essentially having you rewrite each one
15:03:38 <Heffalump> jmcarthur: ah, yes.
15:03:45 <Eridius> Heffalump: git's rebase works automatically when there are no conflicts. When there are merge conflicts, you have to fix them before you can continue
15:03:56 <vixey> dolio: But in reality if I wanted to formalize some mathetics or a program I would not use Agda because of this...
15:04:06 <Heffalump> OK. So darcs commutation covers all the cases where git's rebase works automatically.
15:04:13 <Heffalump> (I think)
15:04:16 <vixey> dolio: it is fun to try out ideas with though
15:04:18 <dolio> I can't fault you there, either.
15:04:19 <jmcarthur> Eridius, all you have to do for that scenario in darcs is just `darcs unrecord` the patch you want to edit on top
15:04:30 <Heffalump> jmcarthur: only if there's a single patch to deal with
15:04:39 <dolio> Coq has way more of that done, anyway. :)
15:04:46 <Heffalump> if the patch with the conflict is way down the dependency list, you're basically out of luck
15:04:48 <vixey> wouldn't really want to use Coq either :/
15:04:51 <seliopou> and if it can "commute down", right?
15:04:53 <vixey> (no eta or proof irr....)
15:05:04 <jmcarthur> Heffalump, yes. this is one of the many major differences between darcs and git for me
15:05:05 <vixey> (both of which Agda /does/ have)
15:05:05 <Heffalump> seliopou: correct (hence "down the dependency list")
15:05:27 <seliopou> Heffalump, that was directed to jmcarthur
15:05:31 <seliopou> didn't see your comment
15:05:40 <dolio> Agda's proof irrelevance is kind of sketchy, though.
15:05:56 <Heffalump> sure, I was just making my reply in the context of already having said it
15:06:02 <dolio> I thought Coq had it with Prop.
15:06:05 <jmcarthur> Heffalump, again though, does it make much sense to bring a patch to the top to edit it if other patches would be underneath it that depend on it?
15:06:26 <Heffalump> jmcarthur: well, you have to do something if you want to edit it
15:06:33 <vixey> dolio: Coq pretends to have it, Coqs philosophy is proof irrelevance .. but it doesn't actually implement it in conversion :p
15:06:34 <jmcarthur> it's a complicated situation in either VCS, is all i mean
15:06:45 <Heffalump> A hypothetical darcs rebase command would have to rerecord the dependent patches after you did that.
15:06:53 <jmcarthur> just in darcs there are cases where it's impossible whereas in git you just have to rewrite your entire history
15:06:54 <dolio> Heh.
15:07:19 <vixey> dolio: so if you try to do any dependent programming you get all these sticky bits (JMeq axioms or similar) and that stops you doing proofs or reflection.. basically jams up the works from there on
15:07:27 <Heffalump> Also, if there are only conflicts involved, then darcs can handle it fine. (At least if you don't get an exponential conflict blowup, which should be unlikely with a darcs 2 repo)
15:07:49 <Heffalump> It's if you want to pull some patches but not some things those patches depend on that you are completely out of luck.
15:07:51 <dolio> Lame.
15:08:08 <Heffalump> ("handle it fine" = give you a merged repo, albeit with lots of conflict markers to sort out)
15:08:20 <vixey> (you can avoid it in most cases but I am pointing out the bad things not the good things :))
15:08:28 <jmcarthur> Heffalump, yeah. it's by biggest hindrance when using darcs
15:09:03 <Heffalump> If darcs had some "supercedes" metadata and a rebase command, it would compete with git really nicely on the usability front (in this regard)
15:09:04 <jmcarthur> it needs a meta-patch theory so you can patch your patches ;)
15:09:31 <Heffalump> volunteers welcome!
15:09:34 <jmcarthur> you dawg...
15:09:36 <jmcarthur> err
15:09:38 <jmcarthur> *yo
15:09:58 <Heffalump> I think a rebase command is eminently doable with some concentrated effort.
15:10:27 <jmcarthur> agreed, it is essentially just a rewind and reapply with maybe some different steps along the way. should be easy
15:10:50 <Heffalump> well, there has been some discussion about it already and I don't think everyone agrees that it is easy
15:10:54 <jmcarthur> well... easy in theory
15:11:08 <jmcarthur> ah, i have not seen this discussion
15:11:15 <Heffalump> though actually I think this discussion has helped crystalise the thoughts in my head about how it'd work
15:11:18 <Heffalump> one sec, I'll find it
15:11:49 <Heffalump> http://bugs.darcs.net/issue938 (I'm ganesh)
15:12:00 <ImInYourMonad> does skype make money or not?
15:13:11 <vixey> kosmikus, dolio: in that space what  do you think should be explored more ?
15:13:28 <kosmikus> what space?
15:13:37 <vixey> dependent programming languages
15:14:02 <kosmikus> vixey: efficient compilation :)
15:14:23 <vixey> hm there seems to be a lot of scope for efficient compilation
15:14:39 <vixey> lots of stuff to erase anyway
15:15:08 <kosmikus> vixey: yes, but Agda isn't even preserving sharing when compiling to Haskell
15:15:11 <pejo> kosmikus, are dependently typed languages harder to compile than .. say Haskell?
15:15:19 <dolio> What languages actually do proof erasure right?
15:15:30 <jmcarthur> pejo, not inherently, afaik
15:15:50 <dolio> Epigram 2 should have some sort of proof erasure, because it's part of OTT, right?
15:16:02 <vixey> dolio: I don't even know how to do proof erasure right yet
15:16:07 <jmcarthur> pejo, in fact, i believe the JHC compiler translates haskell into a dependently typed core language before generating C
15:16:13 <vixey> I've read various notes about it but it doesn't seem solved
15:16:16 <ImInYourMonad> is software even needed in todays society? i say ban it!
15:16:31 <kosmikus> pejo: no, I don't think so. but for some reason, Agda is not doing it well. and Epigram wasn't efficient either. Coq is a bit better.
15:16:35 <dolio> I mean, proof erasure that actually erases proofs. :) If coq doesn't do it, and I don't think agda does eitehr. :)
15:16:53 <vixey> dolio: coq erases things in Prop though
15:16:57 <vixey> what did you mean?
15:17:03 <vixey> well Extraction does
15:17:15 <dolio> I thought you said it wasn't actually doing erasure.
15:17:54 <Heffalump> so if I wanted to write a Haskell application but with better types, are there any good options?
15:18:09 <dolio> There's ATS.
15:18:20 <dolio> But it's not dependently typed in the same way as Agda or Coq.
15:18:29 <dolio> It's fast, though.
15:18:35 <vixey> dolio: proof irr. in the conv. check, erasure at type checking time and erasure for extraction/compiling are quite distinct (but they have some interactions)
15:19:55 <vixey> Heffalump: Idris is kind of like Haskell
15:20:19 <dolio> Have you tried that? I don't think I've ever gotten it to compile for some reason.
15:20:24 <thoughtpolice> ATS is probably your most 'realistic' bet
15:20:37 <Heffalump> vixey: not very complete, though
15:20:40 <kosmikus> Heffalump: I find Agda nice for figuring out what I actually want to write. Then I usually encode that in Haskell in a separate step.
15:20:41 <thoughtpolice> although I have gotten idris to work here (recently, too)
15:20:42 <vixey> dolio, no just seen examples
15:21:14 <Heffalump> I want the moon on a stick, really. Proper automatic extraction to Haskell and all the nice types.
15:21:16 <kosmikus> I've never used ATS, but it looks more like C than Haskell, so I don't find it particularly accessible.
15:21:29 <vixey> Heffalump: now /that/ I think is impossible
15:21:45 <vixey> Heffalump: beyond something like embedding untyped language in haskell
15:21:46 <dolio> Well, a lot of the ATS I've seen has a lot of embeded C.
15:21:48 <Heffalump> why? I don't mind the odd unsafeCoerce.
15:21:55 <vixey> oh
15:21:56 <vixey> I mind unsafeCoerce
15:22:17 <dolio> Actual ATS code looks more like ML with more annotations required.
15:22:19 <vixey> (since it makes programs crash)
15:22:32 <vixey> (including well typed ones)
15:22:37 <thoughtpolice> kosmikus: that's because the best source of ATS programs is currently the shootout, which have tons of inline C.
15:22:59 <vininim> what is the name of that dependently type language, irrlich... erlitch or something
15:23:01 <kosmikus> thoughtpolice: possibly. so where can I find more representative ATS programs?
15:23:02 <vixey> the best source of ATS programs is the ATS implementation
15:23:07 <Heffalump> vixey: really? When?
15:23:08 <thoughtpolice> kosmikus: it's something of an ML, and would be so much more bearable to program in if there were some libs for basic stuff like threading.
15:23:14 <Heffalump> (re unsafeCoerce crashing well-typed programs)
15:23:23 <thoughtpolice> kosmikus: because C interfacing in ATS is so dead simple it's awesome
15:23:23 <vixey> Heffalump, some large extraction from Coq
15:23:49 <vixey> Heffalump, (I think someone maybe fixes this eventually.., but basically I don't see why we can trust unsafeCoerce)
15:24:17 <kosmikus> vixey: if you trust your dependently typed language, you can trust the unsafeCoerce's it generates.
15:24:36 <dolio> Assuming you trust the extractor, too.
15:24:46 <vixey> and the compiler ...
15:24:46 <ddarius> kosmikus: unsafeCoerce in Haskell currently has little in the way of semantics or semantic guarantees.
15:24:48 <vixey> of GHC
15:25:00 <kosmikus> well, yes, but I trust the Haskell compiler as well (to a certain extent)
15:25:07 <vixey> I do not trust Haskell compiler
15:25:22 <kosmikus> most languages do give up types at some point when going toward assembly language
15:25:27 <kosmikus> it's a pragmatic choice
15:25:37 <vixey> (when it compiles something that includes unsafe functions)
15:26:07 <kosmikus> thoughtpolice: so do you know a good source of example programs for ATS that don't contain lots of inline C?
15:26:36 <thoughtpolice> kosmikus: there are some examples on the website... outside of the website/the shootout though there isn't much material
15:26:45 <thoughtpolice> although the documentation does seem to have improved a bit recently
15:26:51 <hcube_> hi! I'd like to work on my render engine (http://www.haskell.org/haskellwiki/LambdaCubeEngine) as summer of code project. do you think is it possible?
15:27:03 <dolio> kosmikus: The website has a quicksort with some proofs.
15:27:12 <vixey> uhm
15:27:20 <vixey> the best source of ATS programs is the ATS implementation
15:27:26 <dolio> Which is probably instructive of actual code you'd expect to write in a dependently typed language.
15:29:13 <monochrom> All I need to know about ATS I learned from the website.
15:29:17 <ImInYourMonad> dloio: which wbesite?
15:29:31 <kosmikus> vixey: you're saying ATS is bootstrapped?
15:29:42 <vixey> yes
15:29:51 <kosmikus> ok
15:29:55 <kosmikus> that's good
15:30:08 <vixey> there is more examples than just the compiler in the implementation though
15:30:32 <kosmikus> ok, I'll try to have a more detailed look at ATS soon
15:34:11 <nikki93> What's the quickest (shortest) code to get the largest number in a list smaller than 'n'?
15:34:28 <nikki93> max (filter (<n) ls)
15:34:32 <jmcarthur> :t max
15:34:33 <lambdabot> forall a. (Ord a) => a -> a -> a
15:34:35 <vixey> :t maximum
15:34:36 <lambdabot> forall a. (Ord a) => [a] -> a
15:34:38 <vixey> :t maximum . filter ?p
15:34:39 <lambdabot> forall a. (?p::a -> Bool, Ord a) => [a] -> a
15:34:42 <vixey> :t maximum . filter (<= ?q)
15:34:43 <lambdabot> forall a. (?q::a, Ord a) => [a] -> a
15:34:57 <vixey> :t max (filter (< ?n) ?ls)
15:34:59 <lambdabot> forall a. (?ls::[a], Ord a, ?n::a) => [a] -> [a]
15:35:24 <vixey> :t max
15:35:25 <nikki93> > maximum (filter (<6) [1..20])
15:35:25 <lambdabot> forall a. (Ord a) => a -> a -> a
15:35:26 <lambdabot>   5
15:35:29 <nikki93> Good.
15:35:31 <nikki93> Thanks guys.
15:35:35 <nikki93> But I gut it myself. :D
15:35:36 <vixey> I don't understand your code nikii
15:35:36 <dolio> http://www.ats-lang.org/EXAMPLE/MISC/listquicksort.dats finally found it.
15:35:38 <vixey> nikii*
15:35:42 <vixey> nikki*****
15:35:44 <nikki93> I'm bad at composing functions, sorry.
15:35:51 <vixey> why does it have type [a] -> [a]
15:35:54 <nikki93> I /still/ don't get '.' and '$'
15:36:05 <vixey> hm I guess Ord a => Ord [a]
15:36:13 <vixey> nikki: . is simple and $ is confusion,
15:36:25 <nikki93> > maximum (filter (<6) [1..n])
15:36:26 <lambdabot>   * Exception: not a number
15:36:29 <vixey> nikki:  let h = f . g then you have  h x = f (g x)
15:36:34 <Deewiant> ?ty \a b -> max [a] [b] -- vixey
15:36:36 <lambdabot> forall t. (Ord t) => t -> t -> [t]
15:36:52 <vixey> > maximum []
15:36:53 <lambdabot>   * Exception: Prelude.maximum: empty list
15:37:02 <vixey> oh n isn't a number
15:37:03 <Deewiant> > max [] [1]
15:37:04 <lambdabot>   [1]
15:37:57 <nikki93> > maximum (filter (<6) [1..n])
15:37:58 <lambdabot>   * Exception: not a number
15:38:00 <nikki93> why doesn't that work?
15:38:06 <vixey> nikki: n isn't a number
15:38:08 <Deewiant> Because you haven't defined n
15:38:13 <nikki93> Woops
15:38:17 <nikki93> > maximum (filter (<6) [1..])
15:38:22 <nikki93> I forgot haskell syntax. :P
15:38:32 <lambdabot>   thread killed
15:38:35 <nikki93> Hmm... Now it's stuck
15:38:38 <Deewiant> You can't run maximum on infinite lists
15:38:46 <Deewiant> Since it can't know whether the list is sorted or not
15:38:47 <nikki93> But it isn't infinite, is it...
15:38:50 <nikki93> Oh wiat.
15:38:51 <Deewiant> > [1..]
15:38:52 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
15:38:56 <nikki93> Filter doesn't know about rest terms.
15:38:57 <nikki93> Ah damn.
15:38:59 <jmcarthur> > last [1..]
15:39:01 <Deewiant> nikki93: takeWhile
15:39:06 <nikki93> Yep.
15:39:12 <lambdabot>   mueval: Prelude.read: no parse
15:39:32 <nikki93> > last (takeWhile (<6) [1..])
15:39:35 <lambdabot>   5
15:39:42 * ivanm wonders how come hackage has a non-integral number of functions according to hayoo :s
15:39:55 <nikki93> > last (takeWhile (<6) (map (2^) [1..]))
15:39:56 <lambdabot>   4
15:39:58 <jmcarthur> partial functions? )
15:40:01 <jmcarthur> ;)
15:40:03 <nikki93> > last (takeWhile (<20) (map (2^) [1..]))
15:40:04 <lambdabot>   16
15:40:21 <Deewiant> > last . takeWhile (<20) . map (2^) $ [1..]
15:40:22 <lambdabot>   16
15:43:49 <nikki93> > let breakBase num base = highest ++(if (diff == 0) then [] else (breakBase diff base)
15:43:50 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
15:43:52 <nikki93>     where highest = last (takeWhile (<num) (map (base^) [1..]))
15:43:53 <nikki93> Hmm
15:43:56 <nikki93> 	  diff = num - highest
15:44:06 <idnar> jmcarthur: bwahaha
15:44:24 <Deewiant> nikki93: You open more brackets than you close
15:44:33 <Deewiant> nikki93: Starting to see the benefits of . and $ yet? ;-)
15:44:54 <nikki93> I know.
15:45:02 <nikki93> > breakBase num base = highest ++ if (diff == 0) then 0 else (breakBase diff base)
15:45:03 <lambdabot>   <no location info>: parse error on input `='
15:45:05 <nikki93>     where highest = last (takeWhile (<num) (map (base^) [1..]))
15:45:08 <nikki93> 	  diff = num - highest
15:45:13 <nikki93> Forget it. IRC ain't the place for this, it seems. :)
15:45:13 <Deewiant> nikki93: Oh, you're pasting that into GHCi?
15:45:17 <Deewiant> That won't work.
15:45:25 <nikki93> I know, 'let'.
15:45:30 <nikki93> No, I'm reading from file.
15:45:42 <nikki93> > let breakBase num base = highest ++ if (diff == 0) then 0 else (breakBase diff base)
15:45:42 <lambdabot>   <no location info>: parse error on input `;'
15:45:45 <nikki93>     where highest = last (takeWhile (<num) (map (base^) [1..]))
15:45:47 <nikki93> Hmm
15:45:50 <nikki93> 	  diff = num - highest
15:45:51 <Deewiant> nikki93: If you want lambdabot to read it, put it on one line
15:46:02 <nikki93> > let breakBase num base = highest ++ if (diff == 0) then 0 else (breakBase diff base) where highest = last (takeWhile (<num) (map (base^) [1..])) diff = num - highest
15:46:03 <lambdabot>   <no location info>: parse error on input `='
15:46:23 <Deewiant> nikki93: You need a semicolon between definitions in 'where' clauses, and at the end of that you need an 'in' to match with the 'let'
15:46:51 <Deewiant> Because lambdabot wants expressions, so you can't just give it 'let foo = bar'.
15:47:03 <Deewiant> It has to be 'let foo = bar in baz'.
15:47:45 <nikki93> > let breakBase num base = highest ++ if (diff == 0) then 0 else (breakBase diff base) where highest = last (takeWhile (<num) (map (base^) [1..])) diff = num - highest in breakBase 40 2
15:47:46 <lambdabot>   <no location info>: parse error on input `='
15:47:59 <Deewiant> nikki93: Semicolon before 'diff ='
15:48:19 <nikki93> Where/
15:48:21 <nikki93> I don't see any!
15:48:28 <Deewiant> nikki93: Yeah, you need to add one :-)
15:48:51 <Deewiant> nikki93: Otherwise it thinks 'diff' is a second argument to 'last' and gets confused about the '='
15:49:23 <nikki93> Oh oh.
15:49:31 <nikki93> > let breakBase num base = highest ++ if (diff == 0) then 0 else (breakBase diff base) where highest = last (takeWhile (<num) (map (base^) [1..])); diff = num - highest in breakBase 40 2
15:49:32 <lambdabot>       No instance for (Num [a])
15:49:32 <lambdabot>        arising from a use of `breakBase' at <...
15:49:40 <nikki93> Now we come to the real error.
15:49:44 <Deewiant> :-)
15:50:02 <nikki93> I solved it!
15:50:05 <Deewiant> nikki93: I guess you want 'then [0]'?
15:50:11 <Deewiant> Oh, sorry :-)
15:50:15 <nikki93> > let breakBase num base = [highest] ++ if (diff == 0) then [0] else (breakBase diff base) where highest = last (takeWhile (<num) (map (base^) [1..])); diff = num - highest in breakBase 40 2
15:50:16 <lambdabot>   [32,4,2,* Exception: Prelude.last: empty list
15:50:21 <Deewiant> Yay
15:50:22 <Deewiant> ;-)
15:51:06 <adimit> Can I access the documentation of the stable version of HaXml somewhere? The link on the homepage to the 1.13 docs doesn't work.
15:51:50 <nikki93> > let breakBase num base = [highest] ++ if (diff == 0) then [0] else (breakBase diff base) where highest = last (takeWhile (<=num) (map (base^) [1..])); diff = num - highest in breakBase 40 2
15:51:51 <lambdabot>   [32,8,0]
15:51:55 <nikki93> Owned.
15:52:07 <Deewiant> :-)
15:52:14 <nikki93> > let breakBase num base = [highest] ++ if (diff == 0) then [] else (breakBase diff base) where highest = last (takeWhile (<=num) (map (base^) [1..])); diff = num - highest in breakBase 40 2
15:52:15 <lambdabot>   [32,8]
15:52:24 <nikki93> > let breakBase num base = [highest] ++ if (diff == 0) then [] else (breakBase diff base) where highest = last (takeWhile (<=num) (map (base^) [1..])); diff = num - highest in breakBase 90 2
15:52:25 <lambdabot>   [64,16,8,2]
15:52:41 <nikki93> > let breakBase num base = [highest] ++ if (diff == 0) then [] else (breakBase diff base) where highest = last (takeWhile (<=num) (map (base^) [1..])); diff = num - highest in breakBase 90 3
15:52:42 <lambdabot>   [81,9]
15:52:47 <nikki93> Man, I rock. :D
15:53:02 <Deewiant> Hmm, what exactly are you computing there?
15:53:07 <Deewiant> Oh, I see, never mind.
15:53:41 <nikki93> Yes.
15:55:43 <nikki93> > let breakBase num base = [highest] ++ if (diff == 0) then [] else (breakBase diff base) where highest = last (takeWhile (<=num) (map (base^) [1..])); diff = num - highest in breakBase 241525 12
15:55:45 <lambdabot>   [20736,20736,20736,20736,20736,20736,20736,20736,20736,20736,20736,1728,172...
15:56:46 <ImInYourMonad> what is a good template haskell tutorial?
16:00:48 <Deewiant> ImInYourMonad: I don't think there is one; just dive in head-first, it worked for me
16:06:18 <nikki93> What's the haskell 'print' function?
16:06:25 <nikki93> That accepts newlines etc.
16:06:31 <nikki93> printstrln or something..
16:06:41 <vixey> @go printstrln
16:06:42 <lambdabot> No Result Found.
16:06:59 <nikki93> @go print
16:07:01 <lambdabot> http://www.printmag.com/
16:07:01 <lambdabot> Title: PRINT Magazine - America's Graphic Design Magazine
16:07:13 <Deewiant> nikki93: putStrLn
16:07:21 <mreh> > foldl (:) 0 [1..10]
16:07:22 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
16:07:22 <lambdabot>        Expect...
16:07:36 <Deewiant> ?src reverse
16:07:36 <lambdabot> reverse = foldl (flip (:)) []
16:07:38 <mreh> hurum
16:07:53 <nikki93> Oh yeah.
16:07:57 <mreh> i was just reminding myself of how foldl works
16:08:11 <Deewiant> > foldl f z [a,b,c]
16:08:13 <lambdabot>   f (f (f z a) b) c
16:08:15 <mreh> is it (0 + (1 + (2 + (3 ... )))
16:08:19 <Deewiant> > foldl (+) z [a,b,c]
16:08:21 <lambdabot>   z + a + b + c
16:08:26 <mreh> right, yeah
16:08:28 <mreh> thanks
16:08:36 <Deewiant> > foldl (+) 0 [1,2,3] :: Expr
16:08:37 <lambdabot>   0 + 1 + 2 + 3
16:08:40 <Deewiant> No sweat :-)
16:08:43 <mreh> i was just looking at this code
16:08:52 <mreh> s1= foldl procEv s evs
16:09:01 <Deewiant> See also http://foldl.com/ (and http://foldr.com/)
16:09:02 <mreh> thinking how could this possible?!
16:10:49 <ozy`> > foldr (+1) (-1.0 / 0)
16:10:50 <lambdabot>       Overlapping instances for Show ([b -> b] -> b)
16:10:50 <lambdabot>        arising from a us...
16:10:52 <ozy`> er whoops
16:11:04 <ozy`> > foldr (+) (-1.0 / 0) $ cycle 1
16:11:05 <lambdabot>       No instance for (Num [a])
16:11:05 <lambdabot>        arising from the literal `1' at <inter...
16:11:10 <ozy`> > foldr (+) (-1.0 / 0) $ cycle [1]
16:11:12 <lambdabot>   * Exception: stack overflow
16:11:15 <mreh> what's wrong with foldl (:) 0 [1..10]?
16:11:42 <ozy`> > foldr (+) (-1.0 / 0) $ cycle [1] :: Expr
16:11:43 <lambdabot>   1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (...
16:12:19 <ddarius> cycle . (:[]) = repeat
16:12:25 <BMeph> mreh: Technically, it is (((0 + 1) + 2) + 3) + ..., not (0 + (1 + (2 + ( 3 + ...)))). The latter is foldr. :)
16:14:13 <BMeph> :ty foldl
16:14:21 <BMeph> @ty foldl
16:14:23 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
16:14:30 <BMeph> @ty (:)
16:14:31 <lambdabot> forall a. a -> [a] -> [a]
16:14:44 <BMeph> mreh: ^^
16:15:24 <ImInYourMonad> so can I implement my data Vector to be of Foldable and then call foldl on it? or which folds are available?
16:16:59 <BMeph> ImInYourMonad: ...have you considered reading the docs to Data.Foldable? :)
16:17:23 <BMeph> ImInYourMonad: But, to answer your question, "Yes." :)
16:22:23 <ImInYourMonad> so I ahev for example also redblacktree and then i have foldTree. so the standard way when implementing a fold over a new structure is to import Foldable and then define those? and then they can all be called with foldl foldr etc
16:23:51 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2578#a2578
16:24:00 <ImInYourMonad> so how do I do it there? it ocmpiels but tdoesnt work
16:29:48 * gwern feels vaguely flattered: '> I assume I should raise this with Gwern.\n I mean David.' 
16:30:21 <ez> hi all
16:31:00 <ez> in an instance declaration, it seems like it's impossible to use the bound type variables in a type ascription within the definitions
16:31:12 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2578#a2578
16:31:16 <ImInYourMonad> so I ahev for example also redblacktree and then i have foldTree. so the standard way when implementing a fold over a new structure is to import Foldable and then define those? and then they can all be called with foldl foldr etc
16:31:26 <gwern> and fmap
16:32:11 <ImInYourMonad> wel fmap over a Tree mgiht amke not a bst or rbt anymore...
16:32:27 <vixey> what .. language is this ...?
16:33:30 <ImInYourMonad> haskell?
16:33:38 <ez> here's an example (contrived) where I can't use the bound type variable: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2579#a2579
16:33:41 <ez> any ideas?
16:34:37 <olsner> vixey: I think he means that fmap over a Tree may produce a tree that is no longer a proper binary search tree or red-black tree
16:35:00 <BMeph> ez: -XScopedTypeVariables is your Friend. :)
16:35:11 <pejo> olsner, I think his point was that all the characters are out of order, and therefore it's very hard to read.
16:35:35 <olsner> pejo: indeed
16:36:21 <ez> BMeph: brilliant, thanks!
16:36:22 * BMeph "patiently" points to the section in Data.Foldable that states: "Minimal complete definition: foldMap or foldr."
16:36:40 <ez> I wonder, then, what's the reason for the non-XScopedTypeVariables behavior
16:36:40 <ImInYourMonad> yeah i know
16:36:47 <ImInYourMonad> but i still don t get how to callit
16:37:03 <Gracenotes> make something that emulates a Turing Machine, very easy with zippers. Actually finding a useful Turing machine to run... not so much :x
16:37:07 <BMeph> ez: "If I have given good advice, it is only by eavesdropping on the conversations of giants." :)
16:37:31 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2580#a2580 compiels but doesnt work when ic all it
16:37:37 <dons> bos: do you have that tiny http server you used to measure conn/sec back in january somewhere?
16:37:43 <dons> the hpaste for it has gone, in the hpaste changeover
16:38:43 <ImInYourMonad> is there a class Zippable?
16:38:48 <Gracenotes> ImInYourMonad: it compiles? :/
16:39:03 <Gracenotes> is fromVector some function from Vector -> Vector?
16:39:22 <ImInYourMonad> fromVector (Vector [1,2,3]) -> [1,2,3]
16:39:50 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2580#a2581
16:40:06 <BMeph> ImInYourMonad: The compiles is smart, not clever. It cannot read your mind and Do What You Meant, Not What You Said. :)
16:40:10 <gwern> ImInYourMonad: probably in one of the zip packages
16:40:11 <BMeph> *compiler
16:41:18 <Gracenotes> ImInYourMonad: hm. I see... what happens if you change the definition to,     foldr f initial v = foldr f initial undefined ?
16:42:11 <dolio> Are you calling it like "foldl ..." like you were before?
16:42:24 <dolio> Because you're still importing the prelude foldl, which is what you're actually calling.
16:42:37 <dolio> Which is why the [] vs Vector type error occurred.
16:42:58 <ImInYourMonad> same. Couldn't match expected type `[a]' against inferred type `Vector t
16:43:01 <ImInYourMonad> im callign with foldr
16:43:13 <pejo> dons, it's not in the google cache any longer either?
16:43:47 <ImInYourMonad> but I cant use F.foldr ont he left side...
16:44:24 <ImInYourMonad> ah
16:44:35 <Gracenotes> :x\
16:45:36 <ImInYourMonad> if i import and import hiding
16:45:41 <ImInYourMonad> which order should it be?
16:45:51 <ImInYourMonad> because i dotn want to have to prefix foldr with F.foldr
16:46:07 <sjanssen> ImInYourMonad: order doesn't matter
16:46:55 <ImInYourMonad> and i dont have to declare foldl? it is automatically derivied from foldr?
16:47:16 <Gracenotes> Minimal complete definition: foldMap or foldr.
16:47:27 <Gracenotes> /quote
16:47:58 <ImInYourMonad> and
16:47:59 <ImInYourMonad> `sum' is not a (visible) method of class `Foldable'
16:49:01 <Gracenotes> it isn't, it's a function in the Data.Foldable class. take a look at the docs, http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Foldable.html
16:49:09 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2580#a2582
16:49:58 <ImInYourMonad> yes but this is seriously effy
16:50:03 <ImInYourMonad> if i dont hdie sum i get
16:50:09 <ImInYourMonad>   Ambiguous occurrence `sum'
16:50:09 <ImInYourMonad>     It could refer to either `Prelu
16:50:16 <ImInYourMonad> if i hdie it i cant use it anywhere...
16:50:44 <shapr> dons: I was accidentally proselytizing in a Comic Shop today! I was carrying my copy of RWH for sit-down reading and someone asked...
16:51:14 <dons> heh
16:51:50 <shapr> dons: So they ended up giving me their email address to add to the bostonhaskell mailing list.
16:52:20 <dons> woot!
16:52:26 <dons> you accidentally the whole haskell
16:53:11 <ImInYourMonad> it is jsut that apart form the Num class
16:53:30 <ImInYourMonad> typeclasses dont seem to do that much needed stuff and the convenience is very minor
16:54:07 <sjanssen> ImInYourMonad: you need to hide sum from Prelude and import it from foldable
16:54:29 <sjanssen> import Prelude hiding (sum); import Data.Foldable
16:54:46 <ImInYourMonad> and
16:54:52 <ImInYourMonad> i did that
16:54:55 <ImInYourMonad> mbiguous occurrence `foldr'
16:54:55 <ImInYourMonad>     It could refer to either `L.foldr', imported
16:55:08 <ImInYourMonad> how can that be ambious when one is prefixed?
16:55:20 <sjanssen> ImInYourMonad: you probably have "import Data.List as L" you need "import qualified Data.List as L"
16:55:32 <ImInYourMonad> import Prelude hiding (foldl,foldr,sum)
16:55:47 <ImInYourMonad> import qualified Data.List as L is what i ahve and then jsut import Data.Foldable
16:56:50 <TomMD> ImInYourMonad: It should tell you what the second foldr is from - perhaps ByteString.
16:57:13 <sjanssen> ImInYourMonad: the problem is the redundant Prelude import, remove it
16:57:46 <ImInYourMonad> is the point of all typeclasse sto present a common itnerface, so whether the underlyign rpepresenation is a tree or a lsit o whatever it can still be mapM - ed etc?
16:58:05 <ImInYourMonad> Ambiguous occurrence `foldr'
16:58:06 <sjanssen> "import Prelude hiding (foldr); import Prelude" -- will still import foldr from Prelude
16:58:07 <ImInYourMonad> i get then
16:58:12 <sjanssen> ImInYourMonad: paste your actual working copy
16:58:17 <ImInYourMonad> i dotn improt preluide again
16:58:26 <vixey> you dotn improt preluide
16:58:27 <sjanssen> ImInYourMonad: your paste has import Prelude listed twice
16:58:35 <vixey> what ?
16:58:38 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2584#a2584
16:58:58 <ImInYourMonad> i dotn want vsum, just sum
16:59:19 <ImInYourMonad> I'm a spelling-bee.
16:59:31 <vixey> more like spelling-eff
17:00:36 <TomMD> That paste works fine.
17:00:39 <jaj> Hi, I was wondering, is there some usable llvm frontend for haskell?
17:00:46 <sjanssen> ImInYourMonad: I receive no errors from that paste
17:00:54 <TomMD> jaj: Yes, its called 'llvm'
17:00:57 <TomMD> And found on hackage.
17:00:59 <TomMD> @where hackage
17:00:59 <lambdabot> http://hackage.haskell.org/
17:01:17 <TomMD> @hackage llvm
17:01:17 <ImInYourMonad> so if I wanted to have a common way to determine similarity with cosiensiimilaroty, euclideandistance etc then I'd create a class Similar and then implement methods like euclideanDistance v v1 ...
17:01:17 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/llvm
17:01:30 <ImInYourMonad> yeah ti works read what i say
17:01:37 <ImInYourMonad> vsum should just be sum
17:01:42 <ImInYourMonad> s that possible?
17:02:03 <ImInYourMonad> it isnt becaus e there is no Summable class?
17:02:04 <TomMD> ImInYourMonad: Sorry, its just hard to understand the meaning from the text you type.
17:02:52 <BMeph> ImInYourMonad: Replace the batteries in your wireless keyboard, please? ;)
17:02:59 <vininim> heh
17:03:23 <vininim> looks like data mining
17:04:12 <jaj> TomMD: but that package doesn't compile haskell code towards llvm ssa code, does it?
17:04:57 <TomMD> jaj: No, that goal has been suggested but not accomplished (yet) - there are a few efforts but I don't know their status.
17:05:35 <TomMD> jaj: As I understand it, this package allows you to JIT compile code from a DSL written in Haskell.
17:05:49 <jaj> yes, sorry I didn't formulate my question correctly in the beginning
17:06:19 <TomMD> jaj: So this is a red-herring for you and I don't know of anyone who has what you are looking for.
17:06:31 <TomMD> But it would be a good project!
17:06:36 <jaj> I saw that there was some work done on EHC to make it do that
17:07:02 <ImInYourMonad> is foldr assosicative?no
17:07:22 <vininim> most haskell developers would like to make a self-hosting compiler. and cps is more inline with functional programming style
17:07:35 <ImInYourMonad> it jsut seems easier to implement your own foldTree than implement Foldable
17:07:48 <vininim> (and equivalent to ssa)
17:09:07 <jaj> perhaps it's possible to convert CPS to SSA
17:09:48 <vininim> yeah
17:10:08 <vininim> not sure how usefull it would be
17:12:05 <BMeph> jaj, vininim: You guys mean, citeseer.ist.psu.edu/662243.html
17:12:26 <BMeph> Hm... *http://citeseer.ist.psu.edu/662243.html
17:12:31 <thoughtpolice> @go ssa is functional programming andrew appel
17:12:32 <lambdabot> http://www.cs.princeton.edu/~appel/papers/ssafun.ps
17:12:55 <BMeph> Hm... * http://citeseer.ist.psu.edu/662243.html
17:14:23 <mreh> @hoogle threadDelay
17:14:24 <lambdabot> Control.Concurrent threadDelay :: Int -> IO ()
17:14:37 <jaj> BMeph: thanks, that looks interesting
17:15:16 <mreh> presumably that does exactly the same thing that getWindowTick does?
17:15:20 <ImInYourMonad> is it possibel to do a qualified import and a hiding import of the same module?
17:15:22 <mreh> @hoogle getWindowTick
17:15:22 <lambdabot> No results found
17:15:29 <mreh> boo
17:15:50 <Gracenotes> o nos :(
17:16:14 <mreh> :d
17:16:33 <BMeph> jaj: Yes, especially since the paper I linked is a reference to thoughtpolice's one.
17:17:10 <mreh> i think there should be a haskell lolcat picture
17:17:15 <Cale> ImInYourMonad: yes, what gets imported is the union of all the imports that you do. You can also combine hiding with qualification.
17:17:26 <BMeph> ImInYourMonad: Yes, but not both in one line.
17:18:00 <ImInYourMonad> well does order matter?
17:18:05 <Cale> import qualified Foo as F hiding (bar, baz)
17:18:48 <mreh> google lambdacats
17:18:49 <Cale> Or, if you mean something different:
17:18:56 <Cale> import qualified Foo as F
17:19:01 <Cale> import Foo hiding (bar, baz)
17:19:32 <BMeph> Cale: Your first example works? =8*O
17:19:38 <Cale> Does it not?
17:19:45 <Cale> I would be surprised for it not to work.
17:21:04 <mreh> why has someone always thought of my idea first
17:21:10 <Cale> It's definitely permitted according to the Report.
17:21:48 <monochrom> Because great minds think alike.
17:22:01 <mreh> haha, lolcats, hardly a great idea
17:22:07 <eu-prleu-peupeu> hi
17:22:10 <jaj> rule 34
17:22:57 <BMeph> jaj: Lolcat pr0n?
17:23:23 <jaj> BMeph: lambdacat unsafePerformIO
17:23:34 <Cale> http://cale.yi.org/share/coequaliser.jpg -- category theory lolcats :)
17:23:49 <monochrom> hahaha
17:23:53 <mreh> I can haskell cheezburger?!
17:24:05 <BMeph> jaj: But the lolcat is watching you perform, you are not watching the lolcat perform. :\
17:24:28 <Philonous> @faq can I haskell cheeseburger
17:24:29 <lambdabot> The answer is: Yes! Haskell can do that.
17:24:37 <SubStack> delicious
17:24:59 <monochrom> @quote accidentally
17:24:59 <lambdabot> bd_ says: I think I accidentally implemented subtraction
17:25:16 <mreh> how does that quote thing work?
17:25:26 <BMeph> @quote spelling
17:25:26 <lambdabot> vixey says:  <ImInYourMonad> I'm a spelling-bee.  <vixey> more like spelling-eff
17:25:27 <monochrom> I am not entirely sure.
17:25:30 <Cale> @quote
17:25:31 <lambdabot> yewT says: bons wrote yaht
17:25:39 <mreh> @quote
17:25:39 <lambdabot> reddi says: and now i know: IT DOES NOT WORK ALWAYS ;-)
17:25:45 <Cale> haha "bons"
17:25:46 <mreh> @quotw mreh
17:25:46 <lambdabot> No quotes match. Do you think like you type?
17:25:49 <Cale> @quote
17:25:50 <lambdabot> mikaeli says: hmm, one national tv station I was watching while eating breakfast crashed with bsod. I guess that's what you get for running windows in production use
17:25:50 <mreh> @quote mreh
17:25:50 <lambdabot> No quotes match. The more you drive -- the dumber you get.
17:26:05 <Cale> @quote
17:26:06 <lambdabot> chunk says: \n -> unfoldr (\l -> if null l then Nothing else Just $ splitAt n l)
17:26:46 <monochrom> That looks like someone intended @let but typed @remember
17:26:56 <gwern> yeah. let's scrap it
17:27:06 <gwern> @forget chunk \n -> unfoldr (\l -> if null l then Nothing else Just $ splitAt n l)
17:27:06 <lambdabot> Done.
17:27:08 <mreh> @quote
17:27:08 <lambdabot> BillWood says: it became obvious that when a Prolog program is tuned by removing non-determinism it moves towards a functional program.
17:27:10 <gwern> @flush
17:27:27 <mreh> why are half of these things quoted?
17:27:37 <gwern> mreh: because they're interesting
17:27:42 <gwern> @quote large
17:27:42 <lambdabot> poetix says: 22:19 < poetix> liftIO makes you larger, and foldR makes you small 22:19 < poetix> And the id that mother gives you, doesn't do anything at all
17:27:42 <mreh> i dont even understand that one, i'd call it meta humour
17:28:20 <mreh> @quote small
17:28:20 <lambdabot> lambdabot says: Nobody brings small problems into a laundromat.
17:28:21 <gwern> mreh: it's a ref to claims that when you tune haskell by removing laziness, you move towards an imperative formulation
17:28:29 <Japsu> @quote segfault
17:28:29 <lambdabot> Japsu says: segfault cat is watching you unsafeCoerce
17:28:32 <Japsu> ^^;
17:28:42 <gwern> mreh: remove nondterminism from prolog, get haskell; remove laziness from haskell, get imperative
17:28:52 <gwern> @quote defined
17:28:52 <lambdabot> pjdelport says: qwe1234, boldly defining where no man has defined before!
17:29:27 <gwern> @quote
17:29:27 <lambdabot> OlinShivers says: "I am not a Church numeral; I am a free variable!"
17:29:38 <gwern> hee hee. I like that because I just finished The Prisoner
17:29:43 <mreh> haha
17:30:05 <mreh> I've been to the place where it is filmed
17:30:11 <mreh> it's in wales would you beleive
17:30:15 <mreh> believe*
17:30:18 <gwern> I heard half a century later, it looks eerily the same
17:30:26 <gwern> mreh: did they explain the last episode while you were there?
17:30:28 <mreh> almost exactly
17:30:36 <gwern> mreh: ooh ooh and do the doors really open like that?
17:30:40 <ImInYourMonad> thanks cale it works
17:31:00 <mreh> no
17:31:29 <mreh> but there was a strange rotating seesaw with men sitting on either end looking into periscopes
17:31:41 <gwern> how mundane
17:31:46 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2589#a2589 <- so which is preferrable , instance Foldable or just implementing foldLeft?
17:32:10 <mreh> it was built by an eccentric to look like venice
17:33:15 <mreh> @quote
17:33:16 <lambdabot> HavocPennington says: Haskell is the least-broken programming language available today.
17:33:26 <mreh> too true
17:33:50 <sm> ha, I've been there too. A fantastical place.
17:33:59 <gwern> hm, 'not', 'and', 'or', 'xor', have I forgotten anything?
17:34:13 <mreh> However, everyone else in the world doesn't believe that, so the rest of us cant find jobs
17:34:22 <sm> Portmeirion
17:34:30 <mreh> i was trying to remember the name
17:34:51 <sm> http://www.beautifulbritain.co.uk/htm/outandabout/portmeirion.htm
17:35:20 <monochrom> 'implies', 'implied by', 'iff', 'nand', 'nor'
17:35:22 <mreh> @quote
17:35:22 <lambdabot> NormanRamsey says: Type annotations in OCaml are completely broken and always have been.
17:35:50 <mreh> @quote
17:35:50 <lambdabot> <linkenpork> says: the room makes me dizzy
17:36:01 <mreh> @quote
17:36:01 <lambdabot> Anonymous says: I'd love to explain to you how to write hello world in Haskell, but first let me introduce you to basic category theory.
17:36:20 <mreh> classic
17:36:41 <monochrom> haha
17:36:42 <gwern> yeah, one of our few good quotes from the *chans
17:36:53 <gwern> @quote chan
17:36:53 <lambdabot> xerox says: <dons> then again, bots themselves are simple  <xerox> "...they are just a morphism in the category of IRC channels together with an endomapping ..."
17:36:59 <ImInYourMonad> are type classes a knd of generic programming?
17:37:09 <ImInYourMonad> or parametric polymorphism?
17:37:18 <gwern> ImInYourMonad: the latter I'm fairly sure is
17:37:28 <monochrom> a kind of operator overloading
17:37:37 <mreh> gwern: dont understand that one
17:37:54 <mreh> i suppose that's the joke
17:38:29 <gwern> mreh: I don't really either; I think the morphism is from irc channel input to irc messages, and the endomapping may be messages -> IO?
17:38:40 <mreh> @quote
17:38:40 <lambdabot> Wild_Cat says: [on #python] (I mean, if you believe the #haskell denizens, half the financial world uses Haskell)
17:38:59 <mreh> but that's true! Isnt it?!
17:39:32 <gwern> you can't prove it isn't
17:39:44 <bremner> right now that might not be a claim to trumpet :-)
17:39:59 <mreh> @quote
17:39:59 <lambdabot> pjdelport says: [on qwe1234:] It must be a drag, being the sole beacon of sanity in a field where all the established researchers are unanimously insane.
17:40:06 <monochrom> There is always the other half.
17:40:13 <gwern> qwe1234 is the gift that keeps giving
17:40:19 <gwern> @hoogle prime
17:40:19 <lambdabot> Data.HashTable prime :: Int32
17:40:19 <lambdabot> Text.Parsec.Prim tokenPrimEx :: Stream s m t => (t -> String) -> (SourcePos -> t -> s -> SourcePos) -> Maybe (SourcePos -> t -> s -> u -> u) -> (t -> Maybe a) -> ParsecT s u m a
17:40:19 <lambdabot> Text.ParserCombinators.Parsec.Prim tokenPrimEx :: Stream s m t => (t -> String) -> (SourcePos -> t -> s -> SourcePos) -> Maybe (SourcePos -> t -> s -> u -> u) -> (t -> Maybe a) -> ParsecT s u m
17:40:19 <lambdabot> a
17:40:20 <mreh> what is it?
17:40:31 <gwern> ironically, I find myself needing a prime :: Int -> Bool right now :)
17:40:37 <mreh> @faq what is qwe1234
17:40:37 <lambdabot> The answer is: Yes! Haskell can do that.
17:40:41 <gwern> @hoogle Int -> Bool
17:40:41 <lambdabot> Data.Bits testBit :: Bits a => a -> Int -> Bool
17:40:41 <lambdabot> Data.IntSet member :: Int -> IntSet -> Bool
17:40:41 <lambdabot> Data.IntSet notMember :: Int -> IntSet -> Bool
17:41:02 <ImInYourMonad> gwern the latter is what
17:41:13 <ImInYourMonad> type classes are parametricpolymorphism?
17:41:18 <mreh> @faq The moonwalk?
17:41:18 <lambdabot> The answer is: Yes! Haskell can do that.
17:41:21 <ImInYourMonad> but not generic programming?
17:41:27 <gwern> ImInYourMonad: :(
17:41:40 <Raevel_> gwern: i have one' but it's not very efficient :-)
17:41:43 <gwern> is this what our educational system has come to? people not knowing what 'former' and 'latter' mean?
17:41:49 <gwern> Raevel_: that's fine
17:41:57 <mreh> @quote
17:41:57 <lambdabot> cypherx says: Oh god, C++ is like a lamprey in my urethra.
17:42:13 * gwern is paging through hoogle output. is there really no primality test in the entire stdlb?
17:42:21 <mreh> @quote
17:42:22 <lambdabot> lambdabot says: *** "Jezebel" hitchcock "Hitchcock's Bible Names Dictionary (late 1800's)": Jezebel, chaste
17:42:26 <ddarius> gwern: This isn't J.
17:42:41 <mreh> @quote
17:42:41 <lambdabot> JohnMeacham says: her name is lambda and she dances on the sand
17:42:45 <gwern> ddarius: yeah, but I mean, we have 'odd'
17:42:54 <mreh> @quote
17:42:54 <lambdabot> lambdabot> says: do i seem  un-feminine to you? <ksf> @vixen, please don't load your problems onto me. Just stand there and look pretty, it'll make you feel better about yourself. <lambdabot> awww,
17:42:54 <lambdabot> you're too sweet to say that! * ksf senses a date
17:43:02 <Raevel_> gwern: http://ecmascript.se/etc/numbertheory/
17:43:04 <ImInYourMonad> @faq can haskell unriddle gwern "speaking in riddles"?
17:43:04 <lambdabot> The answer is: Yes! Haskell can do that.
17:43:23 <ImInYourMonad> > parse gwernspeak "ImInYourMonad: :("
17:43:24 <RayNbow> @quote byorgey math
17:43:24 <lambdabot> byorgey says: if math, haskell :: [Knowledge], the problem with learn $ math ++ haskell (or vice-versa) is that both lists are infinite, so you'll never get to the second one.  Better to do something
17:43:24 <lambdabot> like learn $ zip math haskell.
17:43:24 <lambdabot>   Not in scope: `parse'Not in scope: `gwernspeak'
17:43:28 <gwern> ImInYourMonad: first remedy the defects in your education, then you'll know my answer
17:43:48 <gwern> RayNbow: that's actually a really insightful quote
17:44:11 <gwern> wow, how does hoogle 'Int -> Bool' turn up results like 'Data.IntMap intersectionWith :: (a -> b -> a) -> IntMap a -> IntMap b -> IntMap a'?
17:44:19 <mreh> @quote
17:44:19 <lambdabot> robreim says: I'm in your base hacking all your lambdas
17:44:20 <ImInYourMonad> its not my fault that i know python+haskell+c+java and school wants to teach me to write 4line pascalprograms
17:44:25 * gwern thinks hoogle is just bullshitting by that point
17:44:29 <RayNbow> gwern: but there's a reason why byorgey is awesome ;)
17:44:30 <mreh> it's like sitting on grampa's knee this
17:44:58 <mreh> @quote
17:44:58 <lambdabot> Gwern says: all good languages are but corruptions or extensions of haskell
17:45:08 <mreh> haha
17:45:10 <gwern> not my best quote
17:45:10 <mun> does anyone know how to install the package process-1.0.0.0 with cabal? when i run cabal install process-1.0.0.0 i get the rror saying "Warning: The 'build-type' is 'Configure' but there is no 'configure' script." and then fails
17:45:12 <gwern> @quote gwern
17:45:12 <lambdabot> gwern says: [regarding the naming of Monoids] we will call them CuteFluffableThings, since you can put more fluff into them, but no one would remove fluff from a cute thing
17:45:28 <mreh> @quote
17:45:28 <lambdabot> xerox says: > take 10 lol where lol = "ol" : zipWith (:) (intersperse 'o' $ cycle "l") lol
17:45:32 <gwern> 'Initialized empty Git repository in /home/gwern/numbertheory/.git/
17:45:34 <gwern>  fatal: http://ecmascript.se/etc/numbertheory//info/refs not found: did you run git update-server-info on the server?
17:45:38 <saml> > let even x = if x > 0 then odd (x-1) else True; odd x = if x > 0 then even (x-1) else False in even 42
17:45:39 <lambdabot>   True
17:45:40 <gwern> Raevel_: ^^
17:45:42 <pejo> mun, is there a configure.ac or .in in the tarball?
17:46:05 <Raevel_> gwern: :-O you might have to wget it
17:46:15 <mun> pejo, no there isn't
17:46:21 <mreh> :t intercalcate
17:46:22 <lambdabot> Not in scope: `intercalcate'
17:46:26 <Raevel_> i hadn't made the repo public, so i just cp'd it
17:46:43 <pejo> mun, doesn't process come with ghc anyways?
17:46:49 <mreh> @hoogle [a] -> a -> [a]
17:46:49 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
17:46:49 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
17:46:49 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
17:47:23 <mun> pejo, yeah, but i accidentally uninstalled it
17:47:37 <gwern> Raevel_: what's with the 'isFactorOf = isDivisorOf'?
17:47:42 <mun> pejo, i thought it caused a conflict and removed it
17:47:50 <ImInYourMonad> > "Obama" ++ " " ++ "Haskell" == True
17:47:51 <lambdabot>   Couldn't match expected type `[Char]' against inferred type `Bool'
17:48:05 <ImInYourMonad> > "Obama" ++ " " ++ "Haskell" == "O'Baskell"
17:48:06 <lambdabot>   False
17:48:15 <mreh> > take 10 lol where lol = cycle (intersperse 'o' "l")
17:48:16 <ImInYourMonad> stupid nbot
17:48:16 <lambdabot>   "llllllllll"
17:48:35 <Raevel_> gwern: same thing? :-)
17:48:39 <gwern> Raevel_: and isPrime 10 seems to evaluate to True...
17:49:19 * Raevel_ hides
17:49:22 <mreh> > take 10 lol where lol = (intersperse 'o' $ cycle "l")
17:49:23 <lambdabot>   "lololololo"
17:49:27 <pejo> mun, sorry, no idea. Easiest is to remove and install ghc. The cabal hackers might know how to coerce cabal into re-registereing the package.
17:49:47 <mreh> @quote
17:49:47 <lambdabot> ddarius says: [re: a40a15cb.0304160038.585f3e8@posting.google.com ] The best thing to get out of this, I guess,is that Haskell IS becoming more mainstream and even morons have heard of it.
17:49:48 <mun> pejo, ok thanks
17:49:51 * gwern goes to google for a primality test
17:50:15 <mreh> @quote
17:50:15 <lambdabot> beelsebob says: <lambdabot> Parse error <beelsebob> where bitch?
17:50:26 <mreh> @quote
17:50:27 <lambdabot> tehgeekmeister says: bahhhh; i did not ask for all these thunks
17:50:33 <mreh> @quote
17:50:33 <lambdabot> nocotigo says: if you can't tell what encoding the code is in, I'd say you've gone too far
17:50:43 <mreh> @quote
17:50:43 <lambdabot> rwbarton says: A type class is not a type just like a dog house is not a dog.
17:50:55 <ddarius> mreh: You can privmsg lambdabot.
17:51:10 <mreh> ta
17:51:19 <BMeph> gwern: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2593#a2593 may be easier for you to use (it's my Factors module)
17:51:49 <Raevel_> i wonder how i managed to pass my number theory class with a broken isPrime
17:51:54 <Raevel_> OH WELL
17:52:31 <ddarius> Raevel_: Clearly you shouldn't've.
17:52:56 <Raevel_> ah, i actually have another isPrime that seems to work :-)
17:53:19 <mreh> @quote automobiles
17:53:19 <lambdabot> RobertXCringely says: If automobiles had followed the same development cycle as the computer, a Rolls-Royce would today cost $100, get a million miles per gallon, and explode once a year, killing
17:53:19 <lambdabot> everyone inside.
17:53:25 <wli> I've been dying to implement Shanks' SQUFOF but haven't managed to get a complete description of it.
17:53:28 <Raevel_> gwern: how about this one http://pastie.caboo.se/paste/420430
17:53:39 <gwern> wli: and what's that?
17:53:56 <wli> gwern: A factorization algorithm.
17:53:58 <gwern> Raevel_: well, it's certainly shorter than the miller-rabin test I'm currently using
17:54:39 <Raevel_> gwern: well, it's certainly several exponents slower as well :-)
17:54:58 <gwern> space for time - it's an old tradeoff
17:55:38 <monochrom> brain work for computer work
17:56:23 <mreh> @quote dark
17:56:23 <lambdabot> dark says: <shapr> for example: "head (filter (\x -> x > 5) [1..])" <shapr> in a strict language, you can't easily play with infinite lists <dark> In a strict language, you would write that as "6" :)
17:56:49 <wli> gwern: SQUFOF would be nice because its performance is faster than naive algorithms for much smaller numbers than the truly modern/advanced algorithms require for their asymptotic superiorities to take effect.
17:57:41 <gwern> you mean its constants are good?
17:57:46 <ImInYourMonad> why isnt concatmap defined as: cmap f = concat . (map . map) f
17:58:10 <gwern> thought concatmap = concat . map?
17:58:15 <gwern> @type concat . (map . map)
17:58:16 <lambdabot>     Couldn't match expected type `[[a]]'
17:58:16 <lambdabot>            against inferred type `[[a1]] -> [[b]]'
17:58:16 <lambdabot>     Probable cause: `.' is applied to too few arguments
17:58:18 <wli> gwern: Well, for small enough numbers even it loses to trial division.
17:58:38 <Draconx|Laptop> ImInYourMonad, because that'd be a different function?
17:58:45 <gwern> @hoogle xor
17:58:45 <lambdabot> Data.Bits xor :: Bits a => a -> a -> a
17:58:56 <gwern> @hoogle Bool -> Bool -> Bool
17:58:56 <lambdabot> Prelude (&&) :: Bool -> Bool -> Bool
17:58:57 <lambdabot> Prelude (||) :: Bool -> Bool -> Bool
17:58:57 <lambdabot> Data.Bool (&&) :: Bool -> Bool -> Bool
17:59:07 <gwern> ah, surely data.bool has xor
17:59:12 <wli> http://en.wikipedia.org/wiki/SQUFOF <-- An incomplete description of SQUFOF
17:59:28 <gwern> ...no it doesn't
18:00:44 <wli> I have to wonder why Bool wasn't made an instance of Bits
18:02:17 <Cale> heh, it must be that "Bits" is plural ;)
18:02:48 <jkup> Is it because a bool can only have two values?  Where as bits have many
18:04:21 <adamvo> is there some function I don't know for updating elements in a list at specific indices (indices found with elemIndex)?
18:04:46 <wli> If anyone else can smoke out SQUFOF I'm all ears.
18:05:02 <BMeph> concatMap = concat.(. map)
18:05:14 <dons> adamvo: updating? no.
18:05:18 <ImInYourMonad> traverse (Node _ v left right) = traverse left ++ [v] ++ traverse right
18:05:18 <dons> maybe switch to IntMap
18:05:26 <ImInYourMonad> that is my original im of traverse
18:05:40 <ImInYourMonad> but i dotn get hwo to use instance Traversable
18:05:55 <ImInYourMonad> im readin Monad.Reader
18:06:08 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2594#a2594 <- the code
18:06:08 <BMeph> wli: Is http://www.usna.edu/Users/math/wdj/mcmath/SQUFOF.pdf too sketchy? :)
18:06:36 <adamvo> dons: its just one operation, but I guess it could pass through a Map
18:07:35 <ImInYourMonad> i first need foldable+functor to do traversable?
18:08:58 <ImInYourMonad> but fmap makes no sens eon a redblacktree
18:09:02 <adamvo> ImInYourMonad: yes you need foldable and functor
18:10:14 <adamvo> ImInYourMonad: why not?
18:10:53 <adamvo> fmap would apply the function to all nodes, and then update any invariants...
18:11:17 <wli> BMeph: I've not tried implementing based on its description yet. It could be that I've erred in implementation vs. not having enough detail to go on.
18:11:17 <ImInYourMonad> fmap (\x -> if x == 1 then 500000 else x) tree ; that could vilate the properties of  what makes it a rbt
18:11:40 <ImInYourMonad> adamvo: you mean reinsert everything? that would be very expensive
18:11:49 <mauke> adamvo: can't update properties without Ord
18:11:55 <wli> Try fmap (\x -> 100 - x)
18:12:23 <gwern> I'm curious guys. how would you generate random functions of the form [Int] -> Bool?
18:12:42 <gwern> (my approach of turning basic logical and math operators into ADTs isn't working out so hot)
18:12:48 <dons> isn't that described in the quickcheck paper? :)
18:12:58 <gwern> is it?
18:13:05 <Cale> gwern: The coarbitrary trick should work :)
18:13:06 <nohluhtC> @ty (\ _ [] -> [])
18:13:07 <lambdabot> forall t t1 a. t -> [t1] -> [a]
18:13:26 <dons> ?check \f -> let _ = f :: [Int] -> Bool in f [1..10] == True
18:13:27 <lambdabot>       Overlapping instances for Show ([Int] -> Bool)
18:13:27 <lambdabot>        arising from a us...
18:13:30 <gwern> Cale: but isn't coarbitrary gone?
18:13:36 <dons> gwern: but not far.
18:13:42 <Cale> gwern: It ought not to be gone.
18:13:51 <dons> it's not gone. it has its own class now
18:13:53 <Cale> The idea is to write a function which consumes a list of Int and produces a random generator.
18:13:58 <gwern> hm, is this the original 2000 paper or 2002 paper?
18:14:28 <gwern> Cale: no, I'm just trying to write an induction game where you try to guess the rule that certain lists of ints fail or pass as the case may be
18:15:35 <Cale> gwern: Oh, then you probably want the possible rules to be somewhat simpler...
18:16:04 <wli> BMeph: Might you be willing to help debug an SQUFOF implementation based on that paper?
18:16:25 <Cale> gwern: Maybe decide on a bunch of primitive tests and ways to combine them, represent those with an algebraic datatype, and then generate a random one of those of a given size?
18:17:11 <gwern> Cale: well, the trouble comes when I try to translate from the adt to functions. som functions are bool -> bool, some are int -> bool, some are bool -> bool -> bool etc
18:17:36 <ImInYourMonad> meh it just makes things complicated for no real good reason it seems
18:17:43 <ImInYourMonad> instance Functor RedBlackTree where
18:17:43 <ImInYourMonad>     fmap f Leaf = Leaf
18:17:43 <ImInYourMonad>     fmap f (Node c v left right) = Node c (f v) (fmap f left) (fmap f right)
18:17:58 <ImInYourMonad> if i have that then once it is mapped i need to resort it, how?
18:18:29 <Cale> gwern: hmm... are you using a GADT?
18:18:44 <gwern> Cale: a gadt? no, just a humble little 'data'
18:19:20 <Cale> gwern: Ideally, you'd probably want to ensure that everything represented an [Integer] -> Bool, if that was your goal.
18:19:28 <ImInYourMonad> is it really a functor if it does mroe than change the elements? if it also changes the order of the tree?
18:20:13 <Botje> as long as fmap id === id and fmap f . fmap g === fmap (f . g) it's all good
18:20:33 <Cale> But if you need to compare the elements, you won't be able to write an instance.
18:20:34 <ImInYourMonad> welli dont know what that means
18:21:22 <Cale> The first means that if you fmap the identity function over your data structure, it will leave the structure alone.
18:21:45 <Cale> The second means that if you fmap one function and then another, it's the same as fmapping their composite over the structure.
18:22:01 <jamesnvc> Hello
18:22:09 <Cale> jamesnvc: hello
18:22:11 <gwern> Cale: it sort of works if  i restrict myself to one type, say int -> bool
18:22:20 <gwern> 'zipWith (\ x y -> x y) (map translateUnadic' [Even, Odd]) ([1 .. ])' ~> [False,False]
18:22:49 <jamesnvc> I'm having some trouble with cabal...it gives me "ghc-pkg describe * failed, etc" but my package database isn't empty...
18:23:29 <gwern> ('zipWith ($)' works as well)
18:25:35 <BMeph> wli: ...I might. :)
18:25:44 <mun> hmm
18:25:46 <ImInYourMonad> Cale: but thats what i mean, if i map over a bst or rbt, ihave to make sure the structure is still a bst and thus i mgith hev to reorder the tree, thus fmap on a rbt makes no sense
18:26:39 <Cale> ImInYourMonad: Only in that fmap isn't allowed access to the Ord instance. BSTs are functors on the category of ordered Haskell types, but not on the full category of Haskell types for that reason.
18:26:52 <Cale> (and so at present, we have no way to make them instances of Functor)
18:26:57 <wli> BMeph: Hmm. I should actually stick to trying to get escaping variable analysis going on this hash consed IR.
18:27:21 <Cale> If you try to write the instance, you'll find that you won't be allowed to do the comparisons you need to do in order to re-sort the tree.
18:27:23 <ImInYourMonad> ehh. so what i said was correct?
18:27:30 <wli> I still haven't figured out what escaping variables even mean in a functional program.
18:28:06 <dolio> Like with ST?
18:28:13 <dolio> @type runST
18:28:14 <lambdabot> forall a. (forall s. ST s a) -> a
18:28:22 <dolio> s is only in scope inside those parentheses.
18:28:47 <wli> dolio: No, like data FuncProg = IntExpr Int | VarExpr String | AppExpr FuncProg FuncProg | LamExpr v FuncProg | ...
18:29:54 <dolio> In that case, I'm not sure what it means, either.
18:29:57 <wli> Now I remember that I also have to fix up the record extension operator to actually make sense with variant records.
18:30:47 <wli> Oh, | LetExpr (String, FuncProg) FuncProg
18:30:51 <wli> er
18:31:06 <wli> rather | LetExpr [(String, FuncProg)] FuncProg
18:31:33 <wli> dolio: The goal is to eliminate let-bound variables where DAG -based expression representations make them unnecessary.
18:33:08 <wli> I can already detect recursion, so that part of checking for eliminability is done. Escape analysis is the part I haven't got down yet.
18:33:26 <ImInYourMonad> anyone know of a good primer on cryptography?
18:33:27 <kniu> how can I get a page that requires authentication with simpleHTTP?
18:35:01 <gwern> ImInYourMonad: bruche schneier's textbook
18:35:40 <wli> dolio: At one point I came to the conclusion that with lazy evaluation, every variable escapes.
18:36:20 <gwern> lazy evaluation is freedom. lazy evaluation is efficient. you will love the lazy evaluation.
18:36:30 <BMeph> wli: Were you going to use the CF version of SQUFOF?
18:36:53 <wli> BMeph: I don't know.
18:36:57 <ImInYourMonad> what is the point of a Tree iof it isnt a bst or rbt or avletc?
18:38:28 <Cale> ImInYourMonad: There are lots of other important hierarchical organisations of data :)
18:38:56 <wli> BMeph: I don't see anything in the paper I would call that.
18:38:56 <jamesnvc> Um, where is a good place to ask about my cabal being completely borked?
18:39:29 <Cale> jamesnvc: Well, here, but perhaps the Cabal experts aren't around at the moment...
18:39:35 <Cale> jamesnvc: dcoutts would know
18:39:35 <gwern> @seen dcoutts
18:39:35 <lambdabot> dcoutts is in #gentoo-haskell, #haskell, #ghc, #haskell-overflow, #haskell-soc and #darcs. I last heard dcoutts speak 5h 51m 50s ago.
18:39:38 <gwern> @seen dcoutts_
18:39:38 <lambdabot> dcoutts_ is in #ghc. I last heard dcoutts_ speak 2h 40m 48s ago.
18:39:44 <jamesnvc> Alright, thanks
18:39:47 <gwern> @seen dcoutts_ dcoutts
18:39:47 <lambdabot> dcoutts_ is in #ghc. I last heard dcoutts_ speak 2h 40m 58s ago.
18:40:02 <gwern> darn. you would think lb would be mapping over it, but guess not
18:40:11 <jamesnvc> Man, I can't even use xmonad now.... :(
18:40:38 <gwern> how do you think I feel? I can't even write the core of my induction game without learning gadts
18:41:01 <Cale> jamesnvc: Perhaps you could paste the errors that you're getting somewhere?
18:41:14 <ImInYourMonad> plus i start to question foldable as use for rbt too since then you get minimuma nd maximum which are slower
18:43:10 <ImInYourMonad> than implementing then hby just going right until you find a leaf
18:43:15 <jamesnvc> Cale: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1923#a1923
18:44:16 <Cale> jamesnvc: What version of GHC?
18:44:16 <wli> dolio: Yeah, I think every var escapes.
18:44:44 <jamesnvc> Cale: 6.10.1
18:45:16 <Cale> jamesnvc: one sec, I'll try it for myself
18:45:46 <Cale> Have you done a cabal update?
18:46:22 <wli> dolio: OTOH given the way that things break down every subexpression has to have a sort of implicit let associated with it anyway, so the only essential LetExpr usage is for recursion.
18:46:47 <jamesnvc> Cale: Yup
18:47:06 <ImInYourMonad> isnt lift an instance ofsomething like Liftable?
18:47:21 <Cale> ImInYourMonad: It's a method of the MonadTrans class
18:47:33 <ImInYourMonad> liftVector f v = Vector (f (fromVector v))
18:47:37 <ImInYourMonad> liftVector :: ([a] -> [b]) -> Vector a -> Vector b
18:47:54 <ImInYourMonad> should i do it like that or it should be MonadTrans then?
18:48:00 <Cale> jamesnvc: Well... here it works.
18:48:15 <Cale> jamesnvc: (cabal install xmonad, that is)
18:48:20 <jamesnvc> :(
18:48:33 <jamesnvc> Blah, my computer is messed up
18:48:47 <Cale> How much output do you get from ghc-pkg describe \* ?
18:48:48 <kerlo> Does MonadTrans have any variables other than lift?
18:49:35 <Cale> Here, it's about 4300 lines, but that's obviously going to depend on how many packages you have.
18:50:39 <Cale> ImInYourMonad: That's not the right type for lift.
18:50:52 <Cale> (so just do that)
18:51:13 <jamesnvc> Cale: 1097
18:51:26 <jamesnvc> Lines, from ghc-pkg, that is
18:51:37 <Cale> yeah, so that's reasonable
18:51:39 <Cale> hmm
18:52:33 <ImInYourMonad> Cale: well i want to do it the right way
18:52:51 <ImInYourMonad> instance Functor Vector where
18:52:51 <ImInYourMonad>     fmap = liftVector . map
18:52:57 <Cale> ImInYourMonad: Yeah, it's not a monad transformer, so that 'lift' doesn't make sense in this context.
18:53:12 <ImInYourMonad> shoul that be fmap = liftM . map?
18:53:25 <jamesnvc> Cale: There's also the thing with ghc not being able to find the libraries...Any ideas where I should investigate for that?
18:53:56 <ImInYourMonad> last time it was up i was told thart was what lift is, a common pattern where you take the structure of your data , do something to it and put it back in...
18:54:56 <wli> What would be the difference wrt. heap allocation for recursive vs. non-recursive let-bound vars?
18:56:43 <Cale> ImInYourMonad: liftM is an implementation of fmap for any monad.
18:57:04 <ddarius> wli: What kind of differences are you wondering about?
18:57:26 <Cale> jamesnvc: odd... maybe your .cabal is somehow strange?
18:57:35 <wli> ddarius: Essentially trying to avoid heap allocation altogether and keep things in analogues of value stacks.
18:59:15 <ImInYourMonad> Cale: ok i dont get that, but is there a name for what i did?
18:59:18 <jamesnvc> Cale: I tried with a new .cabal, same thing
18:59:22 <Janin> Anybody know of a library for parsing a bytestring in IEEE format into a Float/Double?
18:59:39 <idnar> @type liftM
18:59:40 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
18:59:41 <idnar> @type fmap
18:59:42 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
19:00:31 <Cale> ImInYourMonad: hmm, so long as a Vector is basically the same thing as a list, it should be okay
19:01:04 <jamesnvc> Hm, I manually installed xmonad, now it can see that again, but now can't find System.IO.UTF8
19:03:27 <wli> ddarius: Maybe it has more to do with strictness than scope?
19:03:43 <ddarius> wli: If your stuff is lazy, then you are going to have to heap allocate a thunk.  If the let-binding is recursive then it is either lazy or a function and you'll probably have to allocate something, though you may be able to minimize it.  If it is strict then you just evaluate the body and store the result.
19:03:55 <ddarius> wli: That's more or less the case.
19:04:33 <wli> So everything escapes unless it's forced.
19:04:45 <wli> ddarius: That'll do it, thanks.
19:08:38 <wli> So the DAG that can land on the value stack is something like forcing implications. If forcing subexpression %t7 implies the forcing of some set of other subexpressions as well, they can all get grouped the way I'm thinking.
19:10:43 <ImInYourMonad> where should pure be defined? isntance monad?
19:11:43 <Eridius> pure comes from Control.Applicative
19:11:44 <Eridius> @hoogle pure
19:11:44 <lambdabot> Control.Applicative pure :: Applicative f => a -> f a
19:11:44 <lambdabot> Control.Arrow pure :: Arrow a => (b -> c) -> a b c
19:11:44 <lambdabot> package pureMD5
19:11:59 <Eridius> @src Control.Applicative
19:11:59 <lambdabot> Source not found. I am sorry.
19:12:06 <Eridius> @src Control.Applicative.Applicative
19:12:06 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
19:12:08 <Eridius> @src Applicative
19:12:08 <lambdabot> class Functor f => Applicative f where
19:12:08 <lambdabot>     pure  :: a -> f a
19:12:08 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
19:13:41 <ImInYourMonad> what is it for?
19:14:01 <ImInYourMonad> applicative stuff makes haskelllook like perl
19:17:34 <ImInYourMonad> how do i even implemen t anyting liek <*>
19:17:42 <ImInYourMonad> is the f there a fucntor not a function?
19:17:55 <Eridius> f there is the Applicative
19:18:16 <kerlo> f is a functor, indeed.
19:28:13 <ImInYourMonad> @src all
19:28:13 <lambdabot> all p =  and . map p
19:28:29 <ImInYourMonad> how can you implement all with fold?
19:28:40 <kerlo> @src and
19:28:40 <lambdabot> and   =  foldr (&&) True
19:28:43 <kerlo> Like that.
19:35:10 <Olathe> @type foldr
19:35:11 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
19:35:57 <ddarius> foldr f z . map g = foldr (f . g) z
19:36:15 <Olathe> all p = foldr ((&&) . p) True
19:36:30 <ddarius> :t \p -> foldr ((&&) . p) True
19:36:31 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
19:36:47 <Olathe> But that should be optimized automatically by GHC.
20:00:10 <dons> get yr. Language.Python http://www.haskell.org/pipermail/haskell-cafe/2009-March/058051.html
20:00:46 <Eridius> I just saw that, and saw that it used Happy. I don't really know much about parsing yet, but why use Happy over Parsec?
20:01:02 <dons> faster.
20:01:11 <dons> and you might already have a BNF grammar to get started
20:01:20 <Eridius> ah
20:02:02 <sjanssen_> Eridius: Happy can also statically analyze your grammar and tell you whether it has conflicts
20:02:20 <Eridius> what does Parsec do with conflicts?
20:03:28 <sjanssen_> Eridius: it can potentially eat more memory, or choose an alternative that isn't very obvious
20:03:34 <Eridius> ok
20:04:27 <sjanssen_> dons: it's obvious what should be done with Language.Python -- a Python runtime that doesn't have a GIL :)
20:04:53 <sjanssen_> it would be awesome if the first concurrent version of Python was written in Haskell :)
20:06:14 <dons> oh boy
20:06:23 <Eridius> anybody know offhand of any good resources for trying out HaskellDB? The project page has hopelessly out-of-date documentation
20:06:43 <dons> walk the Python AST. Emit Haskell code. Game over.
20:07:07 <sjanssen> I was imagining an interpreter of some sort
20:07:17 <dons> yeah, hey. why interpret when we can compile! :)
20:07:19 <sjanssen> it would probably be hard to map Python semantics to Haskell's
20:07:28 <Eridius> dons: would everything be in IO? :P
20:07:32 <dons> yeah
20:07:36 <dons> IO + crazy
20:07:48 <sjanssen> IO + Data.Dynamic
20:07:59 <dons> sjanssen: i bet you could knock up a working prototype for a subset in a day or so
20:08:08 <dons> just pure functions + print
20:08:23 <Janin> What is the difference between `Integer' and `Int'?
20:08:28 <dons> > maxBound :: Int
20:08:29 <lambdabot>   9223372036854775807
20:08:30 <dons> > maxBound :: Integer
20:08:31 <lambdabot>       No instance for (Bounded Integer)
20:08:31 <lambdabot>        arising from a use of `maxBoun...
20:08:32 <mmorrow> > 100^100
20:08:33 <lambdabot>   100000000000000000000000000000000000000000000000000000000000000000000000000...
20:08:33 <dons> there is no bound!
20:08:38 <Janin> Ah, thanks
20:08:42 <sjanssen> > product [1 .. 365] :: Int
20:08:43 <lambdabot>   0
20:08:47 <sjanssen> > product [1 .. 365] :: Integer
20:08:48 <lambdabot>   251041286755587322929294437488120277051655202698760797668725951939011061382...
20:10:03 <wy> :t undefined
20:10:05 <lambdabot> forall a. a
20:10:09 <mmorrow> > ceiling (1/0::Double) :: Integer
20:10:10 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
20:10:37 <wy> mmorrow: that's weird
20:10:41 <mmorrow> heh
20:10:52 <mmorrow> it's some bogus number iirc
20:10:54 <wy> > 1/0
20:10:55 <lambdabot>   Infinity
20:11:09 <monochrom_> It is a singularity gone nuts.
20:11:12 <wy> > 1/0 :: Double
20:11:13 <lambdabot>   Infinity
20:11:19 <mmorrow> > (ceiling (1/0::Double) :: Integer) > 100^100
20:11:20 <lambdabot>   True
20:11:22 <mmorrow> > (ceiling (1/0::Double) :: Integer) > 100^1000
20:11:24 <lambdabot>   False
20:11:30 <wy> haha!
20:11:34 <mmorrow> hehe
20:11:38 <wy> This is weirrrrd
20:11:46 <monochrom_> The Archimedian property fails.
20:12:02 <ddarius> > (ceiling (1/0 :: Double) :: Integer) > 2^1023
20:12:03 <lambdabot>   True
20:12:06 <ddarius> > (ceiling (1/0 :: Double) :: Integer) > 2^1024
20:12:08 <lambdabot>   False
20:12:30 <mmorrow> nice call
20:12:39 <wy> > ceiling (1/0 :: Double)
20:12:40 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
20:12:44 <ddarius> mmorrow: Double precision floating point has a ten bit exponent.
20:12:53 <monochrom> Interesting.
20:12:59 <wy> > ceiling (1/0 :: Double) > 2^1023
20:13:00 <lambdabot>   True
20:13:04 <wy> > ceiling (1/0 :: Double) > 2^1024
20:13:05 <lambdabot>   False
20:13:18 <ddarius> It's 1 sign bit, 10 exponent bits (biased), and 53 mantissa bits.
20:14:00 <ddarius> (or maybe it's eleven exponent bits and 52 mantissa bits with an implied mantissa bit)
20:14:05 <monochrom> Onoes, the converter dumbly looks at those bits and forgets to check "this pattern means infinity"
20:14:33 <ddarius> (yeah, the latter)
20:14:35 <Chandon> > (5 :: Int) < ceiling (1/0)
20:14:36 <lambdabot>   False
20:14:47 <wy> another processor bug or something?
20:14:53 <ddarius> wy: No.
20:15:24 <wy> > Infinity
20:15:25 <lambdabot>   Not in scope: data constructor `Infinity'
20:15:34 <Gracenotes> > floor (1/0 :: Double)
20:15:34 <Valodim> > 1/0
20:15:35 <wy> > Inf
20:15:37 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
20:15:37 <lambdabot>   Infinity
20:15:37 <lambdabot>   Not in scope: data constructor `Inf'
20:15:57 <monochrom> infinity is not accessible by name.
20:15:59 <wy> Ah. So that's "Inf"...
20:16:16 <wy> a bug of lambdabot?
20:16:29 <mmorrow> > (ceiling (1/0 :: Float) :: Integer) > 2^1023
20:16:30 <lambdabot>   False
20:16:33 <mmorrow> > (ceiling (1/0 :: Float) :: Integer) > 2^1024
20:16:34 <lambdabot>   False
20:16:52 <monochrom> try something near 23
20:17:01 <mmorrow> i don't remember the rep of float
20:17:04 <wy> > Inf > 2^1024
20:17:05 <lambdabot>   Not in scope: data constructor `Inf'
20:17:18 <monochrom> err nevermind my 23
20:17:36 <wy> > Inf
20:17:37 <lambdabot>   Not in scope: data constructor `Inf'
20:17:48 <mmorrow> @let inf = 1/0
20:17:49 <lambdabot>  Defined.
20:17:53 <mmorrow> > inf
20:17:54 <lambdabot>   Infinity
20:18:07 <mmorrow> > (inf :: Float, inf :: Double)
20:18:07 <wy> oh I see... That number was not response to my input... doh
20:18:08 <lambdabot>   (Infinity,Infinity)
20:18:32 <wy> > inf > 2^1024
20:18:34 <lambdabot>   False
20:18:43 <mmorrow> which inf?
20:18:55 <wy> > inf
20:18:56 <lambdabot>   Infinity
20:19:02 <wy> > 1/0
20:19:02 <mmorrow> @type inf
20:19:03 <lambdabot> forall t. (Fractional t) => t
20:19:04 <lambdabot>   Infinity
20:19:19 <wy> > 1/0 :: Double
20:19:20 <lambdabot>   Infinity
20:19:37 <wy> > ceiling(1/0)
20:19:38 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
20:19:41 <mmorrow> > (ceiling(inf::Float)::Integer) > 2^1024
20:19:42 <lambdabot>   False
20:19:47 <mmorrow> > (ceiling(inf::Double)::Integer) > 2^1024
20:19:47 <monochrom> floatRange (1.0 :: Float)
20:19:48 <lambdabot>   False
20:19:50 <monochrom> > floatRange (1.0 :: Float)
20:19:51 <wy> > ceiling(1/0) > 2^1024
20:19:51 <lambdabot>   (-125,128)
20:19:52 <lambdabot>   False
20:19:54 <wy> > ceiling(1/0) > 2^1024
20:19:56 <lambdabot>   False
20:19:59 <mmorrow> > (ceiling(inf::Float)::Integer) > 2^1023
20:20:01 <lambdabot>   False
20:20:03 <mmorrow> > (ceiling(inf::Double)::Integer) > 2^1023
20:20:04 <lambdabot>   True
20:20:11 <wy> It seems that we don't need casts?
20:20:11 <monochrom> For float try 2^128
20:20:19 <mmorrow> > (ceiling(inf::Float)::Integer) > 2^127
20:20:21 <lambdabot>   True
20:20:22 <mmorrow> > (ceiling(inf::Float)::Integer) > 2^128
20:20:23 <lambdabot>   False
20:20:25 <mmorrow> woohoo
20:20:49 <mmorrow> wy: ceiling is doing it for us
20:20:53 <mmorrow> @type ceiling
20:20:54 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
20:21:25 <ddarius> wy: The ":: Type" are type annotations, not casts.
20:21:42 <wy> That's strange. Is there something wrong with ceiling?
20:21:53 <monochrom> Yes.
20:22:10 <ddarius> wy: It's behavior is unlikely to be defined by the Report on "infinite" inputs.
20:22:13 <wy> ddarius: I see. wrong word for it.
20:22:13 <mmorrow> the pita about ceiling/floor though is if you want to (ceiling(pi)::Double), you need an additional fromIntegral
20:22:45 <ddarius> mmorrow: I find the alternative far, far worse.
20:23:00 <monochrom> Every choice is a pita.
20:23:08 <mmorrow> yeah, a choice of suckinesses
20:23:41 <gwern> mm.... pita bread...
20:24:19 <monochrom> Every choice is a pita. Every right is a falafel.
20:24:26 <jtokle> so i'd like to dynamically generate a format string and apply printf to a list of arguments whose length is unknown beforehand
20:24:29 <mmorrow> every left is a gyro?
20:24:29 <jtokle> but
20:24:36 <mmorrow> s
20:24:39 <monochrom> yum gyro!
20:24:44 <Eridius> hrm, I can't install haskelldb-hdbc-odbc because libodbc.a requires linking against CoreFoundation.framework as well, but adding --ld-options='-framework CoreFoundation' to cabal install does absolutely nothing
20:24:49 <Eridius> does anybody know what's going wrong?
20:24:52 <jtokle> > foldl (\f x -> f x) (printf "%s -- %s\n") ["foo","bar"]
20:24:53 <lambdabot>       Occurs check: cannot construct the infinite type: a = b -> a
20:24:53 <lambdabot>      Proba...
20:25:29 <monochrom> Only Oleg knows how to do that.
20:25:32 <mmorrow> > foldl (printf "%s -- %s\n") [] ["foo","bar"]
20:25:33 <lambdabot>   Add a type signature
20:25:34 <ddarius> You can't pass dynamically many arguments to any function.
20:25:45 <ddarius> You can, of course, make a function that takes a list.
20:25:48 <mmorrow> , foldl $(printf "%s -- %s\n") [] ["foo","bar"]
20:25:52 * Gracenotes wishes Google search did base conversion
20:25:52 <lunabot>  " -- foo\n -- bar\n"
20:26:10 <seliopou> http://okmij.org/ftp/typed-formatting/FPrintScan.html
20:26:37 <gwern> Gracenotes: what, like '10 in hex'?
20:26:39 <gwern> that works
20:26:46 <gwern> 10 apparently is 0xA
20:26:57 <mmorrow> , flip showHex [] 10
20:26:58 <lunabot>  "a"
20:27:05 <Gracenotes> oh, it seems binary works with the 0b prefix
20:27:05 <ddarius> @google 10 in hex
20:27:06 <lambdabot> http://en.wikipedia.org/wiki/Hexadecimal
20:27:06 <lambdabot> Title: Hexadecimal - Wikipedia, the free encyclopedia
20:27:19 <ddarius> There was a time when that sort of stuff worked through lambdabot.
20:29:34 <wy> :t undefined :: Integer
20:29:35 <lambdabot> Integer
20:32:21 <mreh> @hoogle Event
20:32:21 <lambdabot> package event-list
20:32:21 <lambdabot> package codec-libevent
20:32:21 <lambdabot> package control-event
20:33:08 <mreh> can someone give me a headstart on capturing keystrokes?
20:33:10 <Eridius> oh neat, ghc understands -framework on Darwin
20:33:30 <mreh> i've got getEvs to get the events
20:33:45 <wy> monochrom: Only Oleg knows how to do what?
20:34:48 <wli> I can't have any notion of strictness until I have primitives.
20:35:09 <ddarius> wli: You don't have function application?
20:35:17 <ddarius> or case analysis/if?
20:35:34 <wli> I've got case statements and function application, yeah.
20:35:41 <wy> > undefined
20:35:42 <lambdabot>   * Exception: Prelude.undefined
20:36:00 <wli> ddarius: http://wli.pastebin.com/m2454902d
20:36:27 <mreh> i cant find any documentation for the SOE lib anywhere
20:36:36 <wli> Extension expressions are broken; they need constructor qualifications.
20:37:26 <ImInYourMonad> is: (<-) not something you can impleemtn or override for a  MOnad?
20:38:37 <ImInYourMonad> what is the point of round? when we have floor and ceiling and round rounds down
20:38:40 <wli> The expression table is almost turning into a heap.
20:39:32 <wli> ImInYourMonad: round rounds to the nearest integer, not down.
20:39:50 <mreh> is it not the same as just converting to int thought
20:40:03 <mreh> thought
20:40:06 <mreh> though!
20:41:27 <gwern> mreh: the docs for SOE is _The Haskell School of Expression_ :)
20:41:33 <gwern> although I could swear I saw haddocks before
20:41:59 <travisbrady> is there a way to read an Int in via getLine in one line?
20:42:38 <gwern> something like (getLine >>= read) :: IO Int maybe?
20:42:49 <wli> @type readLn
20:42:50 <lambdabot> forall a. (Read a) => IO a
20:43:20 <ImInYourMonad> > round (-0.3)
20:43:21 <lambdabot>   0
20:43:26 <ImInYourMonad> i see
20:43:35 <gwern> @src readLn
20:43:35 <lambdabot> readLn =  do l <- getLine; r <- readIO l; return r
20:43:52 <gwern> (well that makes snese)
20:43:59 <ddarius> gwern: No it doesn't.
20:44:08 <ImInYourMonad> > getLine >>= readIO
20:44:09 <lambdabot>   Add a type signature
20:44:10 <ddarius> do r <- readIO l; return r === readIO l
20:45:29 <jkup> > return "line" >>= readIO >>= putStrLn
20:45:30 <lambdabot>   * Exception: "<IO ()>"
20:45:46 <jkup> err
20:46:19 <mmorrow> wli: i was just looking at the logs. it seems to me what you're trying to accomplish is exactly a live-vars dataflow analysis on the control-flow graph
20:46:30 <Gracenotes> @hoogle readIO
20:46:31 <lambdabot> Prelude readIO :: Read a => String -> IO a
20:46:31 <lambdabot> System.IO readIO :: Read a => String -> IO a
20:46:31 <lambdabot> Data.IORef readIORef :: IORef a -> IO a
20:46:35 <mmorrow> (which is much easier to do on a lower-level rep)
20:47:07 <wli> mmorrow: I guess I have to break it down to a lower-level rep than what I've already got.
20:47:07 <mmorrow> wli: like, this is exactly the pre-step to doing graph-coloring register allocation
20:47:55 <ozy`> how hard would it be to extend the REPL to allow the interactive development that lisp hackers are so fond of?
20:48:50 <mmorrow> wli: so livevars is a backwards dataflow problem
20:49:25 <ddarius> @google "Static Single Information"
20:49:26 <lambdabot> http://citeseer.ist.psu.edu/584096.html
20:50:02 <ddarius> also http://citeseer.ist.psu.edu/733167.html
20:50:24 <wli> mmorrow: I don't know, ddarius and I came to the conclusion that every variable escapes, so I need to do strictness analysis.
20:51:18 <wli> Okay, ExtExpr is fixed.
20:51:42 <mmorrow> wli: you can do that too. but yeah, what you're trying to do seems like it doesn't really make sense for a lazy lang
20:51:43 <ddarius> wli: I'm not even sure what you mean by "every variable escapes"
20:53:00 <mmorrow> yeah, *every* "let" corresponds to a heap allocation
20:53:32 <wli> ddarius: Escaping variable analysis in a strict language with higher-order functions and lexical scope would determine the precise forms of the environments required for closures, but the deferred execution in lazy languages makes the methods there useless.
20:53:39 <mmorrow> because functions are never actually called initially. they just get stuck in a heap node along with their args
20:56:12 <wli> mmorrow: Not every let; when the body is strict in the let-bound variable and the let-bound variable is non-recursive they do not.
20:57:03 <mmorrow> wli: sure, but only primops/calls that operate on _unboxed_ values are strict
20:57:04 <wy> @let bot = bot
20:57:05 <lambdabot>  Defined.
20:57:08 <wy> :t bot
20:57:09 <lambdabot> forall t. t
20:57:14 <wy> > bot
20:57:21 <mmorrow> everything else is only "strict in the sense that it evals to whnf"
20:57:29 <lambdabot>   thread killed
20:57:40 <wy> > undefined
20:57:41 <lambdabot>   * Exception: Prelude.undefined
20:57:58 <wy> Why does bot behaves differently from undefined?
20:58:57 <wli> mmorrow: Sure, but a whole bunch of things can have the strictness cascade down.
20:58:57 <wy> @src foldl
20:58:57 <lambdabot> foldl f z []     = z
20:58:57 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
20:59:02 <ozy`> > bot :: Expr
20:59:04 <wy> @src undefined
20:59:04 <lambdabot> undefined =  error "Prelude.undefined"
20:59:15 <ozy`> > pizza :: Expr
20:59:16 <lambdabot>   Not in scope: `pizza'
20:59:17 <lambdabot>   thread killed
20:59:18 <travisbrady> i'm putting together a cabal package, but i'm not certain how to determine what versions of stuff my code depends on, how do i track that down?  does it matter?
20:59:38 <mmorrow> wli: sure
20:59:41 <ozy`> wy: aha, I see you defined bot
20:59:51 <wli> mmorrow: Oh, I see, you need to try to narrow the scope of the let.
20:59:56 <ozy`> wy: an infinite loop is different from an error, that's why
20:59:59 <wy> @src bot
21:00:00 <lambdabot> Source not found. Do you think like you type?
21:00:54 <wy> It's just a little strange that they have the same type
21:01:32 <wy> or maybe I should think of it as a difference between 3 and 4?
21:02:03 <wli> mmorrow: Break up the let into SCC's and shove each let down to enclosing the nearest common ancestor expression of all uses of the variables bound therein.
21:02:43 <wy> @hoogle a
21:02:44 <lambdabot> Text.XHtml.Frameset abbr :: Html -> Html
21:02:44 <lambdabot> Text.XHtml.Strict abbr :: Html -> Html
21:02:44 <lambdabot> Text.XHtml.Transitional abbr :: Html -> Html
21:02:48 <wli> mmorrow: So transform let v = ... in con (...) to con (let v = ... in ...)
21:03:06 <wy> @hoogle a -> [a]
21:03:06 <lambdabot> Prelude repeat :: a -> [a]
21:03:06 <lambdabot> Data.List repeat :: a -> [a]
21:03:06 <lambdabot> Prelude iterate :: (a -> a) -> a -> [a]
21:03:17 <wy> @hoogle forall a. a
21:03:18 <lambdabot> Prelude undefined :: a
21:03:18 <lambdabot> Data.Array.Base arrEleBottom :: a
21:03:18 <lambdabot> Test.QuickCheck.Batch bottom :: a
21:04:32 <wy> :t error
21:04:33 <lambdabot> forall a. [Char] -> a
21:04:55 <wli> mmorrow: Then the strictness analysis is far more useful.
21:05:22 <mmorrow> wli: totally, let-sorting is huge for efficiency
21:06:46 <wli> I think the thing is that if I punt on playing with lets, it's still correct and I can get somewhere.
21:07:38 <mmorrow> definitely, but it's probably a prerequisite for a bunch of transformations/analysis
21:07:56 <mreh> what are the actual constituent parts of a DSL?
21:08:05 <mreh> functions? types?
21:08:26 <mreh> a DSL embedded in haskell that is
21:08:30 <mmorrow> also, if you're going to go to bytecode, you'll need to lift lambdas/local-functions, and let-sorting makes a big difference in efficiency there
21:09:49 <wli> I thought STG-like affairs with the environments on the left of \pi abstractions and arguments on the right dodged the need to lambda lift.
21:10:38 <mmorrow> wli: i'm not sure, i'm not using any environments
21:11:23 <mmorrow> (i'm not following the STG machine 100% either though)
21:12:44 <mmorrow> wli: but consider something like:
21:12:51 <mmorrow> err, i'll paste it
21:13:40 <mreh> :t ()
21:13:41 <lambdabot> ()
21:14:21 <mreh> :t \x = ()
21:14:22 <lambdabot> parse error on input `='
21:14:41 <mreh> bleh
21:14:59 <wli> {e_1,e_2} \n {a_1, a_2} -> v
21:15:22 <wli> Or, potentially, \u instead of \n (for updateable vs. non-updateable).
21:17:21 <mmorrow> wli: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1925#a1925
21:17:46 <wli> It basically makes closures for everything instead of lambda lifting and has some special-case handling of captured vars vs. lambda lifting.
21:17:55 <ozy`> :t \x -> () --mreh
21:17:56 <lambdabot> forall t. t -> ()
21:18:05 <ozy`> :t \x == ()
21:18:06 <lambdabot> parse error on input `=='
21:18:12 <ozy`> whoops
21:18:16 <ozy`> :t \x -> x == ()
21:18:17 <lambdabot> () -> Bool
21:18:46 <mmorrow> so that sorts-and-flattens lets into minimal groups, does "johnsson" lambda-lifting (i haven't actually turned lambdas into lets yet, nor lifted local functions to top-level, but that's trivial at this point), and floats lambdas as inward as possible
21:18:49 <Gracenotes>   False
21:18:54 <Gracenotes> :x
21:20:12 <ozy`> @check (== ())
21:20:13 <lambdabot>   "OK, passed 500 tests."
21:21:11 <ozy`> @src () ==
21:21:11 <lambdabot> Source not found. You untyped fool!
21:21:25 <ozy`> (I'm gonna guess it's \_ _ -> True)
21:22:04 <wli> mmorrow: Yeah, App (Lam ...) (...) should get reduced to let up-front. lets with only one use of the var should get ripped out, too.
21:22:11 <Gracenotes> instance Eq () where
21:22:13 <Gracenotes>     () == () = True
21:22:15 <Gracenotes>     () /= () = False
21:22:19 <Gracenotes> hah
21:22:43 <Gracenotes> both defined just to be on the optimal side, I guess
21:23:10 <mmorrow> wli: totally. you can inline lets if the var is only used once
21:24:40 <wli> I'm sort of giving a temporary name to every subexpression as things now stand anyway.
21:24:40 <mmorrow> wli: i followed that 2000 spj/other-person minibook for the johnsson and lambdafloatinginwards algos
21:25:17 <Gracenotes> ozy`: well, there is a comment -- XXX Why aren't these derived?
21:25:34 <mmorrow> i think they cover let-sorting too, but i'd already had that done when i looked at that book
21:25:47 <ozy`> Gracenotes: is there another comment next to that saying "this is left as an exercise to the reader"?
21:26:08 <Gracenotes> x.x
21:26:30 <p_l> ozy`: that's my favourite thing in data structures...
21:26:31 <wli> It's almost sounding like I should interpret the subexpressions as things other than temporaries.
21:26:53 <mmorrow> you just takes scc's of the call (freevars) graph of a binding group, and scc's gives you a reverse-toposort, so then just turn one "let" into nested lets, one for each SCC
21:27:14 <p_l> ozy`: seeing a very useful data structure and then "removal is left as exercise to the reader". Of course, removal can actually provide twice the material that was covered already
21:27:35 <wli> Then push them down into the nearest common ancestor of all the vars they bind.
21:27:51 <mmorrow> exactly
21:28:09 <mmorrow> but that's essentially what taking the SCCs is doing for you
21:28:19 <mmorrow> (well, part of what it's doing)
21:28:35 <mmorrow> (the other being identifying minimal recursive binding groups)
21:29:13 <mmorrow> but yeah, then you push them down by building the nested lets
21:30:19 <wli> Well, the reverse toposort gives a nesting order of the lets, but I'd imagine you'd want to actually collect antichains of SCC's and push them down independently.
21:31:48 <mmorrow> what do you mean by antichains?
21:32:12 <mmorrow> scc :: [(a, [a])] -> [[a]]
21:32:19 <wli> Sets of mutually incomparable elements in the topological ordering induced by the graph.
21:32:53 <mmorrow> sure, so each [a] in [[a]] is a let group
21:33:04 <mmorrow> toposort = reverse . scc
21:33:14 <wli> i.e. the subsequences of the topological ordering whose order is actually ambiguous.
21:33:24 <wli> Subsequences of SCC's, that is.
21:33:29 <mmorrow> yes. and those correspond exactly to letrecs
21:33:59 <wli> No, the SCC's themselves correspond to letrecs. These are lets that commute.
21:34:00 <mmorrow> hmm, i see what you're saying.
21:34:29 <mmorrow> i'm not sure if choice of ordering of those letrecs matters, as long as they are indeed separated
21:35:41 <wli> It can matter, because you might have let v1 = .. in let v2 = in (...) + (...) where the v1 and v2 bindings commute and want to push them down as (let v1 = ... in ...) + (let v2 = ... in ...)
21:36:14 <mmorrow> wli: ah yeah, very true. if you're trying to float a lambda inward, then yeah it could matter.
21:36:57 <mmorrow> i haven't thought about inlining yet
21:38:04 <wli> This isn't even inlining, it's just trying to push lets inward so their bodies have the best chance possible of being strict in their let-bound var(s).
21:39:10 <mmorrow> ok, so this strictness anlysis then?
21:39:23 <mmorrow> i haven't gone into that yet either.
21:40:09 <wli> I'll have to bear commuting lets in mind.
21:40:47 <mmorrow> yeah, that's an interesting situation that i hadn't thought about before.
21:41:00 <wli> After you've broken up a let and push one of its pieces down, you may run into a let that wasn't part of its original group, too.
21:41:35 <mmorrow> you'd need to push-down and letsort simultaneously probably
21:42:12 <mmorrow> (or something to that effect)
21:44:55 <wli> Or maybe just consider the SCC's of the dependency graph of all vars simultaneously, then collapse that graph into a dependency DAG between SCC's to guide the possibility of lets commuting. Once there, let expressions that were part of the original binding group are on equal standing with all other expressions potentially involving the bound variables of a let expression wrt. commutation.
21:45:32 <mmorrow> "all vars" being all vars of what?
21:45:52 <wli> Including let expressions not part of the original binding group associated with the let expression under consideration for movement.
21:46:18 <wli> mmorrow: All let-bound vars in the overall expression.
21:46:20 <mmorrow> ah, so all enclosing lets
21:46:41 <wli> All lets at once, yeah.
21:46:46 <mmorrow> interesting
21:49:21 <wli> Mutual dependencies within a let binding could easily pass through all sorts of let bindings in inner scopes anyway, so it has to be done for the most part anyway.
21:49:52 <mmorrow> crap, i just noticed an error in my `floatLamIn'
21:50:00 <mmorrow>    in \z_0 -> let a_8 x_9 y_10 = (f_4 z_0) (g_2 w_1)
21:50:00 <mmorrow>                   in \w_1 -> (a_8 (f_4 w_1)) (g_2 (h_3 z_0))
21:50:17 <mmorrow> notice the "w_1" before it's bound
21:50:26 * mmorrow goes back to work
21:52:49 <mmorrow> heh, i think it's a fencepost error with "splitAt"
21:56:05 <mmorrow> (zip bs [1..]) -- [0..])
21:56:07 <mmorrow> grr
21:57:14 <wli> I need defaults for case exprs.
21:57:23 <mmorrow> thats such a pita
21:57:45 <mmorrow> i haven't decided what to do about that yet either..
21:58:20 <wli> I need matching vs. primitive values, too.
21:58:51 <wli> And primops
22:00:54 <wli> All-singing all-dancing case? No, make prim matching a distinct expr type.
22:06:41 <wli> Maybe even one prim match expr type per prim type.
22:09:59 <JoshTriplett> When trying to use simple view patterns, I get "Pattern match(es) are overlapped" errors.  For instance, this gives such an error: let f (stripPrefix "hello " -> Just x) = x in f "hello world"
22:10:02 <JoshTriplett> Why might that happen?
22:10:10 * JoshTriplett wonders if lambdabot can do view patterns...
22:10:23 <JoshTriplett> > let (length -> x) = "hello" in x
22:10:24 <lambdabot>   <no location info>: parse error on input `->'
22:10:26 <JoshTriplett> Nope...
22:11:26 * wli sleeps on what to do next.
22:12:00 <JoshTriplett> Oh, bug.
22:12:02 <JoshTriplett> http://hackage.haskell.org/trac/ghc/ticket/2395
22:12:03 <roconnor> "Write a paper promising salvation, make it 'abstract', 'distributed' or 'higher-order' or 'applicative' something and you can almost be certain of having started a new cult.
22:13:23 <sjanssen> what does "`a" do in OCaml? (I can't google it)
22:13:51 <ozy`> sjanssen: you mean 'a ?
22:13:54 <nyrd> hows the functional world folks?
22:14:09 <nyrd> I was wondering if anyone did something like cfengine in haskell?
22:14:17 <nyrd> somethign along the lines of promise theory
22:14:18 <ozy`> that's ML syntax for type variables (since the ML family doesn't require type names to be capitalized)
22:14:29 <sjanssen> ozy`: no, I mean `
22:14:39 <sjanssen> seems to be related to variants, perhaps?
22:15:47 <ozy`> sjanssen: \O_o/
22:19:57 <dons> woo. haskell facebook apps. http://blog.happstack.com/2009/03/18/jeremy-shaw-creates-first-facebook-app-with-happstack/#comment-65
22:20:03 <dons> stepcut++
22:20:37 <dons> sjanssen: someone trolling you? ;)
22:20:58 <sjanssen> dons: I'm attempting to anti-troll jdh30
22:21:17 <ozy`> dons: this whole thread, basically.
22:21:17 <ski> sjanssen :polymorphic variants
22:21:17 <ozy`> http://www.reddit.com/r/programming/comments/84sqt/dear_reddit_i_am_seeing_12_articles_in/c089q8f
22:21:43 <ozy`> dons: if you jump in, I'm sure there will be fireworks, for what it's worth
22:21:45 <sjanssen> ski: okay, that makes sense then.  Variants would be quite hairy in GHC as the poster claims
22:22:01 <ski> (.. poster ?)
22:22:39 <sjanssen> ski: Harrop, on reddit
22:23:21 <ski> ozy`s link above ?
22:23:27 <ozy`> yes
22:25:35 <Adamant> lol @ Harrop
22:26:36 <mmorrow> , let (length -> x) = "hello" in x
22:26:38 <lunabot>  5
22:26:38 <Adamant> sounds like a certain language just pissed in his cheerios.
22:27:59 <ozy`> Adamant: apparently we're all "frauds" and "liars" and every mention ever made of haskell being used for actual projects is a complete fabrication invented by expert trolls
22:28:15 <_dolio> @remember JonHarrop We invested a lot of time and money diversifying into Haskell before I discovered that their industrial success stories were largely faked.
22:28:15 <lambdabot> I will never forget.
22:28:30 <mmorrow> @go expert troll
22:28:30 <lambdabot> No Result Found.
22:28:43 <mmorrow> @go professional troll
22:28:44 <lambdabot> No Result Found.
22:29:06 <Adamant> seriously, I don't have time to play with reddit trolling wars, but pointing out that his entire tiny irrelevant consultancy is built on OCaml would be a good start
22:29:23 <Adamant> and that he hasn't shipped anything worthy of note ever
22:30:04 <sjanssen> Adamant: it might be true, but I don't think it would be productive in this case
22:30:45 <sjanssen> rather than state negative things about Harrop and OCaml, I'd prefer to merely provide facts that contradict his non-facts
22:30:53 <Adamant> sjanssen: fair enough
22:31:29 <TomMD> I prefer to program, there are now several people I filter out on the Haskell ML, among other venues.
22:32:08 <Adamant> sjanssen: his thread isn't productive either though, of course
22:36:45 <Heffalump> yes, please do jump into the reddit threads, the bigger the crowd shouting him down the better
22:37:56 <ozy`> personally I am completely satisfied with the knowledge that only one of his points (which he repeated ad nauseam in different forms, it turns out) had any kind of factual basis whatsoever
22:38:14 <dolio> Which is that?
22:38:27 <dolio> GHC has bugs?
22:39:10 <ozy`> haha, did I miss some of his posts? (it wouldn't surprise me. oh well... TL, DR)
22:39:34 <ozy`> the one I meant was "haskell doesn't have ocaml's module system"
22:39:45 <dolio> Oh, well, that's obvious.
22:39:49 <dolio> OCaml doesn't have type classes.
22:39:54 <dolio> Done.
22:43:35 <Gracenotes> but how can you make large-scale applications without OCaml's module system!1!1!
22:44:04 <Lemonator> how do I use IO to perform a specific action periodically with respect to time?
22:44:15 <Lemonator> while other stuff keeps happening?
22:44:27 <Gracenotes> concurrency, likely
22:45:12 <Cale> Lemonator: Write something like   foo = do some stuff; threadDelay something; foo  and then forkIO that.
22:45:14 <dons> sjanssen: http://www.reddit.com/r/programming/comments/84sqt/dear_reddit_i_am_seeing_12_articles_in/c08bpzl
22:45:53 <zakwilson> Thank you, #haskell, for reminding me of why I rarely read reddit anymore.
22:45:58 <dons> :}
22:45:59 <Lemonator> k
22:46:10 <dons> yes. it's not much of a community anymore
22:47:08 <Eridius> it has its faults, but I really appreciate seeing haskell articles pop up there (thanks dons!)
22:47:26 <Gracenotes> :)
22:47:26 <dons> well, the haskell reddit should be useful i hope
22:47:55 <Lemonator> :t ()
22:47:56 <lambdabot> ()
22:48:16 <dolio> We need to get some ayrnieu in there.
22:48:59 <ozy`> ayrnieu submitted the link to JDH's comments as a new article in the first place....
22:49:09 <dolio> Hah.
22:49:49 <dons> yay, troll alliance!
22:50:11 <dolio> People with irrational grudges against haskell need to stick together.
22:50:22 <dons> harrop's weird. he's says really bizarre things, and doesn't seem to make friends.
22:50:57 <dolio> I suppose Harrop's might not be as irrational. I can't really figure out ayrnieu.
22:51:01 <dons> but he's also supremely self-confident
22:51:31 <zakwilson> I'm sad about the current state of reddit. I was a very early user. I bought a t-shirt from kn0thing.
22:52:24 <Eridius> hah, ayrnieu's story links back to the old article about seeing Haskell articles in proggit? That's rather odd
22:53:18 <Eridius> oh hey, it actually links to a comment, it just has ridiculous ?context=
22:56:57 <dons> its strange how the internet has cranks and bizarre personalities
22:57:13 <dons> sjanssen: have you seen jdh is moving into open source?
22:57:25 <dons> he's going to fix ocaml by building a runtime on top of llvm.
22:57:26 <dolio> The internet lets them reach more people. :)
22:57:32 <mmorrow> s/internet/_/
22:57:37 <dons> which sounds interesting. then you think how weird it is.
22:58:12 <Heffalump> Why is it weird?
22:58:14 <mmorrow> s/strange// :)
22:58:27 <Heffalump> LLVM sounds like the backend of choice these days
22:58:34 <Eridius> LLVM FTW
22:58:59 <mmorrow> Heffalump: for functional language implementations?
22:59:09 <Heffalump> for something new, yes
22:59:18 <mmorrow> Heffalump: link?
22:59:33 <Gracenotes> :t (<*>).(<$>)
22:59:34 <lambdabot> forall a a1 b. (a1 -> b) -> ((a -> a1) -> a) -> (a -> a1) -> b
22:59:45 <mmorrow> (i haven't seen any functional _languages_ using it)
22:59:51 <Heffalump> I don't have any specific references, just general impressions from stuff I've read. As I'm not an FPL implementor, you should take my opinions with the appropriate pinch of salt.
23:00:01 <Gracenotes> @. djinn type (<*>).(<$>)
23:00:02 <lambdabot> f a b c = a (c (b c))
23:00:15 <dolio> Both the ghc and lhc people seem to think llvm is currently lacking.
23:00:20 <dolio> But then, they're both Haskell.
23:00:23 <Heffalump> ok, "of choice" => "the natural thing to use for a fresh backend"
23:01:00 <p_l> and afaik the expressed reason is mostly something about lack of low-level enough access...
23:01:06 <dons> Heffalump: he wants to make ocaml's backend faster, for numerical purposes. on his own. by forking ocaml (?)
23:01:19 <dons> take the one thing ocaml's good for. and fix it.
23:01:21 <dolio> Oh, right, his hlvm thing.
23:01:42 <dons> i just don't see a bright future for a harrop-run open source language project, i must admit.
23:01:48 <dons> too much light shining on things
23:01:48 <Heffalump> no, that's certainly true
23:01:54 <Adamant> there isn't.
23:01:57 <Heffalump> but that's the harrop factor, not the concept
23:02:05 <dons> yeah.
23:02:17 <dons> he's not a language guy, so it'll be a tough task.
23:02:20 <Heffalump> and anyway, he hasn't pissed off the O'Caml community to anything like the same extent as the Haskell community
23:02:35 <dons> though they do have to apologies when they point out ocaml is nice.
23:02:38 <Adamant> he doesn't have a lot of fans there either
23:02:38 <Heffalump> he's shown a reasonable degree of clue from what I can tell
23:03:04 <Heffalump> they haven't been collectively called liars and frauds, though
23:03:27 <Adamant> Heffalump: I agree, but even OCaml people think the guy is a bit off.
23:03:55 <Lemmih> What did this guy do to the Haskell community?
23:04:00 <dons> Heffalump: well, he has alternated between saying ocaml is doomed by F#, to going back to his old ways
23:04:13 <Heffalump> yeah
23:04:44 <dolio> Yeah, I thought F# was the only functional language with a future these days. :)
23:04:59 <Adamant> yes, that's won him lot of friends and admirers among the OCaml folks
23:05:04 <dolio> Is the concurrent garbage collector and Microsoft backing not important anymore?
23:05:04 <dons> Lemmih: he has a plan to sell hand printed tutorials about ocaml (and other things now). the strategy he described was to create flame wars, mostly on usenet in the lisp chans. that flameish behaviour he got into out of college leaks over into other communities he interacts with
23:05:26 <ibid> who's "he"?
23:05:55 <Heffalump> ibid: jdh30 on reddit
23:05:58 <dons> oh, jdh. someone put bees in his breakfast again
23:06:04 <Heffalump> and Jon Harrop in real life.
23:06:14 <NameAlreadyInUse> oh, i thought jdh was just a troll?
23:06:20 <Adamant> sort of
23:06:28 <Heffalump> no, he has an F#/OCaml consultancy business
23:06:30 <Heffalump> and writes books
23:06:37 <Heffalump> that are full of mistakes
23:06:45 <NameAlreadyInUse> heh, wow
23:06:50 <dolio> Oh?
23:06:52 <dons> but he's not quite ... normal. there's something vaguely off about how he's doing things.
23:06:56 <dolio> I've never actually read one.
23:07:06 <Heffalump> neither have I, I've just been told that
23:07:07 <dons> the hand printing, the 90% tax. the books with mistakes. the open source trolling.
23:07:10 <dons> all a bit weird
23:07:11 <Heffalump> (by someone who has read them)
23:07:17 <Gracenotes> there are anonymous trolls. Then there are non-anonymous trolls.
23:07:33 <Adamant> non-anonymous trolls are the most effective
23:07:37 <Adamant> look at Don King
23:07:52 <p_l> then there are super-trolls known under names like POTUS etc.
23:08:15 <Adamant> p_l: it's not trolling if you believe your own BS
23:08:41 <glguy> it is *really effective* trolling if you can derail the #haskell channel without joining it
23:08:43 <dons> Adamant: oh, that's interesting
23:08:52 <Gracenotes> I've heard more than a few non-anonymous trolls saying "oh, you're hiding behind your pseudonymity." It was interesting to see Jon Harrop say it in the reddit thread...
23:08:56 <dons> glguy: yeah, he's over on 4chan now laughing it up :)
23:09:06 <dolio> Are they at least entertaining? Joe Celko's books are riddled with errors, but they're fun to read.
23:09:18 <Adamant> glguy: indeed
23:09:19 <Gracenotes> (in fact, one dude banned from Wikipedia went on an active campaign to out Wikipedia admins, because they have 'influence')
23:09:22 <Heffalump> I dunno about derailing, it makes for a nice early morning chat for me.
23:09:28 <jmcarthur> i love the trolls that don't go away
23:09:33 <p_l> dons: in the text or graphic part? :D
23:09:42 <jmcarthur> qwe1234 is just gold, for example
23:09:52 <Gracenotes> the supporting cast! :D
23:10:22 <dons> Gracenotes: oh, didn't jdh get banned from wikipedia?
23:10:26 <dons> i'd forgotten all about that
23:10:33 <p_l> as for books... someone please write "The Manga Guide to Haskell". It will be hilarious to see people speaking haskell :P
23:10:36 <Heffalump> I think he just got annoyed that his material was constantly reverted.
23:10:40 <Gracenotes> dons: no, this is someone different
23:11:00 <Eridius> wow, Harrop really loves calling things "strawman arguments"
23:11:15 <Heffalump> He really ought to learn what that means.
23:11:20 <Eridius> indeed
23:11:22 <Gracenotes> dons: in fact, not related at all. But he's a non-anonymous troll who publishes this page: http://www.wikipedia-watch.org/hivemind.html
23:11:45 <ozy`> p_l: for a while now I've wanted to do a comic where all the characters are anthropomorphizations of programming languages
23:11:48 <NameAlreadyInUse> Eridius: i was just looking at: http://www.reddit.com/r/programming/comments/84sqt/dear_reddit_i_am_seeing_12_articles_in/c08aslt
23:11:55 <Gracenotes> basically the personal addresses of any Wikipedia admin whose info he could get his hands on
23:12:08 <ozy`> Gracenotes: that's... madness
23:12:11 <p_l> ozy`: I found one about OSes
23:12:17 <Eridius> NameAlreadyInUse: yeah, and that comes right after using the term "strawman argument" incorrectly at least 2 other times
23:12:36 <Adamant> yes. the strawman. the last desperate hope of people who don't bother to actually learn rhetoric. I don't know rhetoric, which is why I try not to use that phrase.
23:12:40 <dons> this is kinda cool. http://www.reddit.com/r/programming/comments/84sqt/dear_reddit_i_am_seeing_12_articles_in/c08be65
23:12:42 <ozy`> p_l: well they already have "OS-tan" characters, so I guess that's just an incremental step :p
23:13:16 <NameAlreadyInUse> Eridius: seems like a very strange person
23:13:28 <Eridius> NameAlreadyInUse: I agree
23:13:44 <p_l> ozy`: well, there's also this famous Windows ME anime series opening...
23:14:11 <ozy`> p_l: the all blue one, right?
23:14:55 <p_l> ozy`: it was interactive, in flash. clicking in various places changed the flow...
23:16:10 <p_l> ozy`: the comic I was pointed to on deviantart, otoh, was about adventures of Linux-tan
23:16:33 <dons> hey, did people see stepcut wrote a facebook app in happstack?
23:16:47 <p_l> ozy`: it began during the perilous time of UNIX Wars, with various OS-tans falling as casualties in the conflict
23:16:51 <dons> and it teaches people math :)
23:17:57 <Gracenotes> how to construct monoids and magmas?
23:18:19 <mauke> has anyone noticed we were visited by gavin again?
23:18:31 <ozy`> p_l: fascinating...
23:19:24 <dons> mauke: gavino?
23:19:32 <mauke> yes
23:19:36 <dons> huh. it is wacky week
23:19:45 <dons> what pseudonym?
23:19:49 <mauke> nyrd
23:20:24 <dons> wow. totally. and we were too busy to notice
23:24:29 <jberryman> I want to a apply a function ([a] -> [a]) only if the [a] is not empty. is there a combinator I'm missing in Applicative or MonadPlus?
23:25:57 <dons> if null x then f x else x , you're saying?
23:26:06 <dons> sorry, not (null x)
23:26:31 <jberryman> right. maybe liftA?
23:27:34 <NameAlreadyInUse> i think that might be complicating it
23:27:36 <Gracenotes> boolean combinators are somewhat lacking :x
23:27:42 <Gracenotes> imho
23:27:57 <dancor> @pl \ x -> if x == mempty then x else f x
23:27:57 <lambdabot> ap (if' =<< (mempty ==)) f
23:29:15 <Gracenotes> @pl \ x -> bool x (f x) (x == mempty)
23:29:15 <lambdabot> ap (ap bool f) (mempty ==)
23:29:41 <dancor> this is kind of like code golf
23:29:48 <Gracenotes> :)
23:29:56 <Gracenotes> @pl \x -> bool mempty (f x) (x == mempty)
23:29:56 <lambdabot> ap (bool mempty . f) (mempty ==)
23:30:22 <NameAlreadyInUse> what is the @pl command?
23:30:48 <jberryman> NameAlreadyInUse: makes function point-free
23:30:51 <dancor> http://en.wikipedia.org/wiki/Tacit_programming
23:31:48 <ozy`> NameAlreadyInUse: it converts a function (or lambda) that takes explicit arguments into one that only has implicit arguments
23:31:52 <NameAlreadyInUse> that is pretty cool
23:32:18 <NameAlreadyInUse> are there some things for which @pl doesn't work?
23:32:22 <ozy`> yes
23:32:23 <ozy`> lots
23:32:39 <ozy`> it doesn't understand pattern matching
23:32:48 <ozy`> and it breaks hilariously on some library functions
23:32:57 <Gracenotes> also, arrows
23:33:00 <NameAlreadyInUse> oh
23:33:31 <Gracenotes> @pl \a -> (f a, g a)
23:33:32 <lambdabot> liftM2 (,) f g
23:33:52 <Gracenotes> . :x actually, that's pretty :) although liftA2 would be great there too
23:34:08 <Gracenotes> @pl \(a, b) -> (f a, g b)
23:34:09 <lambdabot> f *** g
23:34:21 <Gracenotes> oh, well well.
23:34:30 <ozy`> @pl \(a, b) (c, d) -> (a + c, b + d)
23:34:30 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (+)) . flip . (((.) . (,)) .) . (+))
23:34:35 <dolio> f &&& g
23:34:35 <NameAlreadyInUse> heh
23:35:15 <jberryman> protip: if you ever see flip flip, you're doing it wrong
23:35:40 <NameAlreadyInUse> i really can't grasp these esoteric uses of flip
23:36:34 <NameAlreadyInUse> how "flip id x" works like ($x), i really can't fathom
23:36:36 <jml> flip flop flap.
23:36:50 <Gracenotes> NameAlreadyInUse: in this case, id is (a -> b) -> (a -> )
23:36:55 <Gracenotes> err (a -> b) -> (a -> b)
23:37:17 <Gracenotes> @type flip
23:37:19 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
23:37:29 <NameAlreadyInUse> ah
23:37:35 <NameAlreadyInUse> so the c is "a -> b"?
23:37:43 <NameAlreadyInUse> in flip id
23:37:57 <jml> @type flip id
23:37:58 <lambdabot> forall b c. b -> (b -> c) -> c
23:38:07 <Gracenotes> NameAlreadyInUse: almost. interestingly, (a -> b) -> (a -> b) actually means the same thing as (a -> b) -> a -> b
23:38:32 <Gracenotes> this can be seen with partial application.
23:39:05 <Gracenotes> so suppose the type of flip is: (x -> y -> z) -> y -> x -> z
23:39:10 <Gracenotes> equivalent to the above
23:39:26 <Gracenotes> then the first argument is id, a.ka. (a -> b) -> a -> b in this case
23:39:34 <Gracenotes> so x = (a -> b), y = a, z = b
23:40:02 <NameAlreadyInUse> but ((a -> b) -> c) is not the same as (a -> b -> c), so how does it figure that id is ((a -> b) -> a -> b) instead of ((b -> c) -> b -> c)?
23:40:43 <Gracenotes> well, id is normally a -> a
23:41:00 <Gracenotes> in this case, a is itself a function
23:41:07 <ski> a function *type*
23:41:14 <Gracenotes> right
23:41:32 <Axman6> a == (a -> b) there
23:41:46 <ski> you have to rename the variables
23:42:06 <ski>   id :: forall a. a -> a
23:42:19 <ski>   flip :: forall a b c. (b -> a -> c) -> a -> b -> c
23:42:33 <ski> first you make instances of these, for fresh type variables
23:42:38 <ski>   id :: a0 -> a0
23:42:54 <ski>   flip :: (b1 -> a1 -> c1) -> a1 -> b1 -> c1
23:43:19 <ski> then the application `flip id' will unify the type of `id' with the argument type of `flip'
23:43:23 <ski> i.e. unify
23:43:26 <ski>   a0 -> a0
23:43:28 <ski> with
23:43:32 <ski>   b1 -> a1 -> c1
23:43:39 <NameAlreadyInUse> so it becomes:  ((a1 -> c1) -> a1 -> c1) -> a1 -> (a1 -> c1) -> c1?
23:43:40 <ski> this succeeds iff
23:43:45 <ski>   a0 = b1
23:43:46 <ski> and
23:43:55 <ski>   a0 = (a1 -> c1)
23:44:05 <ski> the result type of `flip' was
23:44:08 <ski>   a1 -> b1 -> c1
23:44:25 <ski> er, sorry
23:44:52 <ski> no, that's right
23:45:13 <ski> so, `b1' is the same as `a0' which is `a1 -> c1', so the result type is
23:45:24 <ski>   a1 -> (a1 -> c1) -> c1
23:45:42 <ski> now we generalize the remaining non-instantiated type variables (and i rename them), so we get
23:46:01 <ski>   flip id :: forall a b. a -> (a -> b) -> b
23:46:22 <NameAlreadyInUse> @src flip
23:46:22 <lambdabot> flip f x y = f y x
23:47:37 <Gracenotes> @type const id
23:47:37 <lambdabot> forall a b. b -> a -> a
23:47:45 <Gracenotes> == flip const
23:48:02 <Gracenotes> another combination that works similar-ishly
23:49:02 <Gracenotes> @type map map
23:49:03 <lambdabot> forall a b. [a -> b] -> [[a] -> [b]]
23:49:18 <Gracenotes> (also somewhat unexpected... was on the mailing lists lately, actually ^.^)
23:50:10 <NameAlreadyInUse> what is the use of map map?
23:50:20 <NameAlreadyInUse> oh, i see
23:50:36 <Gracenotes> not much, as far as I know :)
23:51:10 <Gracenotes> @type map map [length, head]
23:51:11 <lambdabot> [[[Int]] -> [Int]]
23:53:52 <ski> @hoogle (f a -> f b) -> (a -> b)
23:53:52 <lambdabot> Data.Generics.Aliases ext1T :: (Data d, Typeable1 t) => (d -> d) -> (t d -> t d) -> d -> d
23:54:11 <ski> hmhm
23:54:20 <NameAlreadyInUse> > map ($[1, 2, 3]) $ map map $ [pred, id, succ]
23:54:21 <lambdabot>   [[0,1,2],[1,2,3],[2,3,4]]
23:54:29 <Gracenotes> a reverse fmap of sorts?
23:54:33 <NameAlreadyInUse> that is pretty cool
23:57:20 <NameAlreadyInUse> @type map map (map map [map])
23:57:21 <lambdabot> forall a b. [[[a -> b]] -> [[[a] -> [b]]]]
