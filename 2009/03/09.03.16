00:12:47 <bmh> find :: (Ord k) => SplayTree k v -> k -> (Maybe v, SplayTree k v)
00:12:47 <bmh> find Leaf _ = (Nothing, Leaf)
00:13:03 <bmh> ghc is claiming that I'm constructing an infinite type
00:13:05 <bmh> I don't see it
00:13:54 <wli> Is there more code for find? Odds are it's a type constraint somewhere in that.
00:14:42 <bmh> mind if I dump it on you via a message?
00:15:02 <wli> Better pastebin; it'll scroll away if message.
00:15:17 <wli> (or hpaste or moonpatio or whatever)
00:15:37 <cads> I'd like to be able to map quickly through the elements in {0, 1}^n.
00:15:48 <bmh> http://pastebin.com/d4de44f2e
00:16:25 <cads> counting through the n digit binary numbers from least to greatest would be the simplest, conceptually, but I was wondering if a more recursive scheme would be more efficient
00:16:30 <mmorrow> bmh: what's the data decl for SplayTree?
00:16:47 <bmh> I'll pastebin it
00:16:47 <pumpkin> bmh: where does it say the infinite type is coming from?
00:17:04 <wli> I don't have a data decl to try to fix it.
00:17:12 <bmh> http://pastebin.com/d96ef4b0
00:17:27 <bmh> v = Maybe v,  When generalising the type(s) for `find'
00:17:55 <pumpkin> :o
00:18:09 <pumpkin> Just v1?
00:18:14 <wli> if sk == k then (Just v, n)
00:18:20 <bmh> doh
00:18:28 <cads> for example given a binary number, we can insert a zero at each position past the last zero in the number, to have a kind of exponential branching through all the combinations
00:18:59 <bmh> ok, wli, this should do what we were talking about
00:19:37 <Axman6> bmh: seems to me that you can write a much more consise, recursive definition here
00:20:07 <bmh> Axman6: This isn't actually the 'splay' operation
00:20:24 <Axman6> i don't know what that is...
00:20:42 <bmh> splay brings a node to the root via rotations upon finding it
00:20:46 * pumpkin splays all over Axman6
00:20:50 <bmh> (or the nearest node to it in BST order)
00:21:07 <Eridius> is there any easy way of benchmarking two implementations a function against each other?
00:21:08 <bmh> this searches for a node and brings it up on level in the tree
00:21:10 <wli> bmh: http://pastebin.com/m49fdba00 gets it typechecking and shuts up ghc -Wall warnings.
00:21:13 <Gracenotes> what was that DSL for graphics called? blackboard something?
00:21:46 <Gracenotes> where the drawing area could (for instance) be rotated with a statement in a monad, or something like that.
00:22:22 <bmh> wli: thanks
00:23:09 <bmh> I'm sure if we sat down and did the analysis of this we'd conclude you'd never want to use it
00:24:49 <bmh> (otherwise Tarjan would have published on it)
00:24:52 <mmorrow> bmh: this is a nice concise-via-pattern-mathcing (partial (no delete!)) rb-tree implem that i like http://darcs.haskell.org/yhc/src/compiler98/Util/Tree234.hs
00:25:01 <mmorrow> (it's rb-trees despite the name)
00:25:11 <Eridius> Gracenotes: chalkboard?
00:25:15 <Eridius> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/chalkboard
00:25:17 <Axman6> dons: you around?
00:25:31 <pumpkin> how much of a problem (if at all) is it to define *** in terms of first >>> second when none of them are explicitly inlined? is there an overhead, or does the inliner catch that and do it for us?
00:25:44 <wli> mmorrow: That is freaking slick.
00:26:09 <wli> Is there an ST monad transformer module around anywhere?
00:26:11 <mmorrow> wli: yeah, that translated to C really nicely too
00:26:11 <pumpkin> mmorrow: I actually made a subtle reference to that code earlier this evening!
00:26:21 <mmorrow> pumpkin: hehe
00:26:57 <Gracenotes> Eridius: yep, exactly it :) thanks
00:26:58 <pumpkin> 22:49:42 <pumpkin> you need a 2-3-4-5-6-7-8-9 tree (that's actually an RB tree)
00:27:10 <mmorrow> hah
00:27:13 <bmh> mmorrow: is there a reason the author didn't encode the rb-tree invariant into the type?
00:27:41 <wli> bmh: Have you got an implementation that does so? I'm not aware of how it could be done.
00:27:41 * Axman6 is a little surprised dons submitted his IO tutorial to reddit
00:27:50 <pumpkin> Axman6: why?
00:27:55 <bmh> wli: I was going to write one
00:28:24 <Axman6> because its not very good :P
00:28:33 <mmorrow> bmh: not really any reason
00:28:34 <wli> mmorrow: Hmm, no split/join.
00:28:45 <mmorrow> wli: yeah :(
00:29:39 <mmorrow> bmh: i think there's an okasaki implem somewhere with the invariant in the type
00:29:50 <mmorrow> (so i've heard), but i haven't actually ever seen it
00:30:13 <pumpkin> someone pointed me at a paper once that had it but I've since lost it
00:30:41 <wli> Generally the way I do unions is to find the smaller of the two sets, split the larger one into three pieces, one of all larger than the other tree, one all smaller than the other tree, and the other intersecting its range. Then I do the stupid union on the smaller of the two middle sets and join for the rest.
00:31:11 <mmorrow> i mean, i've seen his one that's in his book, but i don't know where this other one is hiding
00:32:09 <wli> There's probably a strategy for dividing things into more pieces to accelerate that algorithm.
00:33:49 <Gracenotes> hm. Anyone know what distinguishes a graph from a digraph in dot?
00:33:57 <mmorrow> oh nice, this page is excellent http://home.bway.net/kbeen/teaching/algorithms/resources/red-black-tree.html
00:34:18 <mmorrow> you could probably implem everything without having to read a single word from the looks of it
00:35:03 <mmorrow> Gracenotes: a graph is undirected
00:35:07 <mmorrow> a -- b
00:35:11 <bmh> words? who needs words when you have pictures?
00:35:12 <mmorrow> instead of
00:35:14 <mmorrow> a -> b
00:35:16 <wli> I have a fair amount of trouble fixing up balance info and figuring out what to do when walking back up from leaves to root.
00:35:28 <Gracenotes> mmorrow: ah, I see.
00:35:29 <mmorrow> bmh: yes!
00:35:34 <Gracenotes> oh! so it stands for 'directed'
00:37:44 <bmh> wli: thought about it some more. promoting a leaf to the root via individual rotations versus splay probably takes log^2 n instead of log n
00:38:27 <bmh> on the other hand, the constants are undoubtedly smaller
00:38:32 <wli> I'm trying to figure out exactly how I want to do environment management and argument/input and return/output temporary stuff.
00:40:25 <cads> you guys, using a rewrite rule similar to   a = $([1,0]*)0[1]* -> A' = {x in ($1)0[1]*0[1]* : |x| = |a|}, and applying it recursively starting at a = [1]*, |a| = n, we may step through the binary sequences of length n, and equivalently, through the elements of the superset of a given finite set. I think
00:40:39 <cads> for example1111 -> {0111, 1011, 1101, 1110} -> {{0011, 0101, 0110}, {1001, 1010}, 1100} -> {{{0010, 0001}, 0100}, 1000} -> {0000}
00:41:01 <cads> s/example1111/example 1111 :)
00:41:27 * pumpkin is finally understanding the point of Arrow beyond the -> instance
00:43:08 * cads wonders if arrows have to do with the ->'s in type notation
00:43:29 <Gracenotes> I wonder what happened to the 5 in http://en.wikipedia.org/wiki/File:Fsm_parsing_word_nice.svg :)
00:43:43 <pumpkin> cads: people often represent them as ~>
00:43:57 <pumpkin> but that has also been used a (value) operator elsewhere
00:44:52 <wli> I can't figure out what kind of arrows there are besides the (->) instance.
00:44:54 <Gracenotes> pumpkin: so, made any interesting Arrow instances lately?
00:45:03 <pumpkin> Gracenotes: no, but maybe I will soon!
00:45:30 <pumpkin> wli: Kleisli wraps any Monad instance, and the papers include a few other examples
00:45:55 <wli> The paper obviously didn't help me much.
00:46:36 <pumpkin> http://www.cs.chalmers.se/~rjmh/afp-arrows.pdf has been quite helpful for me (it even contains an actual use of loop!)
00:46:54 <wli> That may very well be a different paper.
00:47:09 <pumpkin> there are a few
00:47:12 <pumpkin> this one reads like a tutorial
00:48:28 <wli> So (>>>) == (>=>) ?
00:49:07 * SubStack wrote a nifty navigator for glut camera navigation, he thinks
00:49:10 <SubStack> http://modzer0.cs.uaf.edu/~substack/snippets/Navigate.hs
00:49:16 <pumpkin> not quite
00:49:20 <jharptree> I wrote an arrow instance for a type Listener i o = i -> IO (Listener i o, [o])
00:50:15 <jharptree> this is to create actions which take input, and return a new action to respond to further input, as well as optionally sending output to further actions
00:50:37 <SubStack> not especially idiomatic just yet, but it's getting better
00:51:15 <wli> @type (>=>)
00:51:16 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
00:51:29 <Gracenotes> hah. Love this license: http://sam.zoy.org/wtfpl/
00:51:49 <Gracenotes> "Although the validity of the WTFPL has not been tested in courts [..]"
00:51:52 <cads> I am downloading a many gigabyte collection of pirate ebooks, where the is a subfolder that seems to be dedicated to FP style arrows.. intriguing
00:52:04 <cads> pirate math ebooks, that is
00:53:01 <pumpkin> wli: I guess they are the same if you wrap in Kleisli
00:53:09 <cads> they seem to be just publicly available papers though
00:53:37 <Eridius> @pl \n x -> 2*n + x
00:53:38 <lambdabot> (+) . (2 *)
00:53:52 <wli> @type (>>>) `asTypeOf` (\f g -> Kleisli (runKleisli f >=> runKleisli g))
00:53:53 <lambdabot> forall b c d (m :: * -> *). (Monad m) => Kleisli m b c -> Kleisli m c d -> Kleisli m b d
00:55:19 <pumpkin> @type (>=>) `asTypeOf` (\f g -> runKleisli (Kleisli f >>> Kleisli g))
00:55:20 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
00:55:24 <pumpkin> :D
00:56:09 <mmorrow> @type [($), id]
00:56:10 <lambdabot> forall a b. [(a -> b) -> a -> b]
00:58:04 <wli> Hmm, (>=>) `on` runKleisli is getting a weird type.
00:58:29 <pumpkin> :t (>=>) `on` runKleisli
00:58:30 <lambdabot> forall (m :: * -> *) b. (Monad m) => Kleisli m b b -> Kleisli m b b -> b -> m b
00:58:41 <pumpkin> what's weird about it?
00:58:55 <mmorrow> @let coprod (<>) h i1 i2 = \f g -> h (i1 f <> i2 g)
00:58:56 <lambdabot>  Defined.
00:58:57 <pumpkin> :t runKleisli . ((>=>) `on` runKleisli))
00:58:58 <lambdabot> parse error on input `)'
00:58:59 <wli> Ugh, Data.Function.on constrains the types nastily.
00:59:03 <pumpkin> :t runKleisli . ((>=>) `on` runKleisli)
00:59:04 <lambdabot>     Couldn't match expected type `Kleisli m a b'
00:59:04 <lambdabot>            against inferred type `Kleisli m1 b1 b1 -> b1 -> m1 b1'
00:59:04 <lambdabot>     Probable cause: `on' is applied to too few arguments
00:59:11 <pumpkin> wli: yeah, it does :/
00:59:23 <wli> @type (Kleisli .) . ((>=>) `on` runKleisli)
00:59:24 <lambdabot> forall (m :: * -> *) b. (Monad m) => Kleisli m b b -> Kleisli m b b -> Kleisli m b b
00:59:37 <pumpkin> @type ((runKleisli .) .) . ((>=>) `on` runKleisli)
00:59:38 <lambdabot> forall (m :: * -> *) a b. (Monad (Kleisli m a)) => Kleisli (Kleisli m a) b b -> Kleisli (Kleisli m a) b b -> b -> a -> m b
00:59:43 <mmorrow> @type join (coprod (>>>) runKleisli) Kleisli
00:59:44 <lambdabot> forall d (m :: * -> *). (Monad m) => (d -> m d) -> (d -> m d) -> d -> m d
01:00:03 <pumpkin> :P
01:00:07 <Gracenotes> :X
01:00:10 <pumpkin> :P
01:00:25 <pumpkin> omg, we just made jesus
01:00:43 <yitz> @type on
01:00:44 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
01:00:52 <Gracenotes> pumpkin: so sell the logs on ebay?
01:00:53 <mmorrow> @type coprod
01:00:54 <lambdabot> forall t2 t3 t4 t5 t t1. (t2 -> t3 -> t4) -> (t4 -> t5) -> (t -> t2) -> (t1 -> t3) -> t -> t1 -> t5
01:00:55 <yitz> Seems pretty general to me
01:00:55 <wli> I've not gotten a whole lot further than case/forcing corresponding to tailcalls and spine unwinding corresponding to ordinary calls.
01:01:02 <pumpkin> Gracenotes + pumpkin = P + X = XP
01:01:12 <Gracenotes> @hoogle coprod
01:01:12 <lambdabot> No results found
01:01:22 <pumpkin> omg, do you think windows xp isn't really xp, but actually chi rho?
01:01:31 <wli> The static chain is the spine, and the dynamic chain is environment stuff slung around alongside closures.
01:01:32 <Gracenotes> @. djinn type coprod
01:01:32 <lambdabot> f a b c d e f = b (a (c e) (d f))
01:01:42 <Gracenotes> @unpl ((f .) . ) . g
01:01:42 <lambdabot> (\ e j m -> f (g e j m))
01:02:08 <mmorrow> @let prod (><) f p1 p2 = \a -> f (p1 a >< p2 a)
01:02:09 <lambdabot>  Defined.
01:02:13 <mmorrow> @type prod
01:02:13 <pumpkin> yitz: it'd be nice to be able to take different typeclass instances for the a -> a -> at the end, but I don't think that's possible
01:02:14 <lambdabot> forall t1 t2 t3 t4 t. (t1 -> t2 -> t3) -> (t3 -> t4) -> (t -> t1) -> (t -> t2) -> t -> t4
01:03:09 <mmorrow> @type join (prod (,) id)
01:03:10 <lambdabot> forall t2 t. (t -> t2) -> t -> (t2, t2)
01:03:25 <mmorrow> @type join (coprod (,) id)
01:03:26 <lambdabot> forall t3 t. (t -> t3) -> t -> t -> (t3, t3)
01:03:30 <wli> What I've got has the inefficiency that the alternatives in a case statement require the union of all their necessary arguments as arguments and the union of all their environments as environments.
01:03:31 <mmorrow> err
01:03:49 <mmorrow> @type join (coprod (,) id) id
01:03:50 <lambdabot> forall t3. t3 -> t3 -> (t3, t3)
01:04:00 <mmorrow> hmm
01:04:05 <pumpkin> on :: [TypeClass T] ==> T a, T b => (y -> y -> c) -> (T x => x -> y) -> a -> b -> c if that makes any sense
01:04:12 <pumpkin> of course, I made up the notation :P
01:05:33 <pumpkin> maybe it makes no sense though
01:06:21 <yitz> pumpkin: forall a a' b c . forallclass C . (C a, C a') => (b -> b -> c) -> (forall d . C d => d -> b) -> a -> a' -> c
01:06:44 <pumpkin> that's certainly prettier than my made-up notation
01:06:49 <mmorrow> @. djinn type prod
01:06:50 <lambdabot> f a b c d e = b (a (c e) (d e))
01:06:53 <mmorrow> @. djinn type coprod
01:06:54 <lambdabot> f a b c d e f = b (a (c e) (d f))
01:07:03 <mmorrow> crap, i botched it
01:07:08 <pumpkin> yitz: I assume that's 100% impossible in current haskell?
01:07:13 <yitz> 100%
01:07:36 <pumpkin> is there any work on "typeclass variables"?
01:07:50 <yitz> pumpkin: write a paper proving that it's sound, and SPJ will be happy to implement it for you.
01:07:54 <pumpkin> lol
01:07:59 <pumpkin> I haven't even read TAPL yet :P
01:08:08 <pumpkin> I'm pulling this all out of places you don't want to know about
01:08:26 <pumpkin> I like your notation though
01:08:31 <wli> The environments are basically just arrays slung alongside the things, like displays stored in $gp or whatever.
01:09:01 <wli> (maybe display pointer?)
01:10:15 <pumpkin> yitz: so no work has gone into exploring that kind of typing?
01:10:22 <pumpkin> I guess it isn't very common
01:11:34 <Gracenotes> @. djinn run text . (++") -> g") . ('(':) . intercalate ") -> (" . map (intercalate " -> " . map return) . tail . inits $ "abcdefg"
01:11:36 <lambdabot> Cannot parse command
01:11:44 <Gracenotes> :O
01:11:54 <Gracenotes> @. djinn run text . (++") -> f") . ('(':) . intercalate ") -> (" . map (intercalate " -> " . map return) . tail . inits $ "abcdef"
01:11:56 <lambdabot> Cannot parse command
01:12:15 <Gracenotes> silly lambdabot, cutting off run output
01:12:21 <Gracenotes> @. djinn run text . (++") -> e") . ('(':) . intercalate ") -> (" . map (intercalate " -> " . map return) . tail . inits $ "abcde"
01:12:24 <lambdabot> Cannot parse command
01:12:28 <Gracenotes> :(
01:12:36 * Gracenotes cries self to sleep
01:12:43 <yitz> pumpkin: I don't recall seeing it. You could do it manually for specific classes though.
01:12:47 <pumpkin> yeah
01:13:24 <pumpkin> but that'd require writing one on for every typeclass, or maybe sticking on itself into a typeclass and doing a Suitable-like trick that's used in rmonad
01:13:26 <Gracenotes> foiled again by the bot who claimed to be my friend :(
01:14:12 <wli> The big difference is that the dynamic chains I remember from classes did some kind of search loop through a chain of arrays with pointers looking for the escaping variable value depending on how many nested scopes up the thing was defined.
01:17:12 <wli> Aha, I think I have an idea to nuke the case alternative inefficiency.
01:20:30 <wli> Hmm. An indirect instruction is sort of like an indirect jump. I guess the two things to do are disallow using the indirection affair as a target and so on. From there the jump table is an array of call instructions, each crafted for the needs of the particular alternative branch.
01:22:07 <wli> Ignoring the overhead of passing extra args and having extra crap in the environment sounds like the best thing for a first pass.
01:23:58 <pumpkin> is there any package that exposes the Stream constructs that go into stream fusion?
01:24:09 <pumpkin> the Next | Skip | End thing
01:24:21 <wli> Or, given the amount of crap I have to pass as side information alongside calls, maybe a call descriptor data structure is in order.
01:25:37 <pumpkin> I meant Yield :)
01:26:28 <pumpkin> > cycle 1 ++ undefined
01:26:30 <lambdabot>       No instance for (Num [a])
01:26:30 <lambdabot>        arising from the literal `1' at <inter...
01:26:36 <pumpkin> > repeat 1 ++ undefined
01:26:37 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
01:28:38 <Workybob> is renderWith the only way to get out of Gtk2Hs's Render monad?
01:29:46 <dblick1> If I only want to learn one library for parsing XML in Haskell, which should it be?
01:30:00 <wli> Yeah, make it so that tailcalls can either use a data structure describing the branch targets, arg registers, and environment, or supply them in the instruction itself. Then jump tables don't need all-identical arguments and environments.
01:30:29 <trygvis> dblick1: afaik there is only one for reading raw xml, but there are additional libs to read common structures on top (like the feed lib)
01:32:01 <dblick1> trygvis, I was considering Haskell XML Toolbox or HaXml, or maybe hxml
01:35:02 <wli> In actual machine code it would be a jump table to a series of distinct (tail)call setup and teardown code blocks.
01:35:46 <wli> Fortunately I don't have to deal with that or the double branch overhead.
01:40:07 <vegai> hmm, strange that nobody has written an ssh lib yet
01:40:23 <vegai> should be not very difficult given that we have Crypto, right?
01:43:06 <vegai> there's some easy infamy to be gained right there
01:43:42 <wli> I guess I'm trying to capture the spine and the graph etc. in significant part with call stacks.
01:46:06 <wli> Maybe it's not so different from having discriminated unions for unevaluated thunks vs. evaluated ones sitting around the heap.
01:52:33 <wli> data Node m = Value (Value m) | Thunk (m (Value m) and then data Value = IntVal Int | ConVal Con [Node m] | ...
01:53:49 <wli> I'm confused but
01:55:42 <wli> data Node m = Value Value | Thunk (m Value) and then data Value = IntVal Int | ConVal Con [HeapIdx] | ... ; type HeapIdx = Int ; type Heap m = Map HeapIdx (Node m) etc.
01:57:53 <wli> Functions kill me again.
02:03:54 <andrey_nado> hello
02:04:05 <andrey_nado> is anybody here?
02:04:16 <wli> Of course not. We're all just bots.
02:05:23 <andrey_nado> wli, could you help me a bit?
02:05:48 <Lemmih> If he can't, I can.
02:05:50 <pumpkin_> tell us your problem :)
02:06:07 <andrey_nado> thank you, guys! :)
02:06:53 <andrey_nado> I'm considering using haskell in my little project, but I don't know what to start from
02:07:44 <kosmikus> Lemmih: are you going to be at the Hackathon?
02:07:57 <andrey_nado> My program simulates behavior of system of N cells (one dimensional case)
02:08:07 <Lemmih> kosmikus: I'm not sure.
02:08:55 <wli> I suck so go with Lemmih
02:09:07 <Lemmih> kosmikus: My financial future is uncertain.
02:09:45 <andrey_nado> In general, I need to iteratively solve this equation: cell[i, t+dt] = F(cell[1,t], cell[2,t],...,cell[N,t],t,dt)
02:09:57 <kosmikus> Lemmih: I see. What are you doing these days?
02:10:36 <andrey_nado> Periodically I have to flush intermediate cell state to a file
02:11:04 <andrey_nado> Could you guys tell me what should I dig in to start solving my problem in Haskell?
02:12:59 <pumpkin_> andrey_nado: how much haskell do you know?
02:13:11 <Lemmih> kosmikus: Looking for work involving fp.
02:14:14 <andrey_nado> pumpkin_: I'm just started learning it, but I have sills enough in usual imperative programming
02:14:44 <pumpkin_> andrey_nado: I'd spend more time on general tutorials to get a firmer grasp of the basics before trying something too specific, then
02:17:48 <andrey_nado> pumpkin_: I used to learn any new IT technology working on specific problem
02:18:31 <m3ga> andrey_nado: the trick to learning a functional language is to start with a problem that plays to the strengths of functional programming
02:18:37 <andrey_nado> pumpkin_: Could you tell sections of Haskell help I need to learn first? (arrays, monads etc(
02:19:03 <yottis> andrey_nado: i tried that too with haskell, but i got all the time the feeling that there must be a better way to do this
02:19:22 <yottis> and of course there were, but it's hard to guess what those could be out of the blue
02:19:27 <andrey_nado> m3ga: I believe my problem can be FP-formulized very well
02:20:40 <m3ga> what is the problem?
02:21:24 <andrey_nado> m3ga: my problem - is my program I like to write in Haskell (I specified it above)
02:23:19 <m3ga> i actually don't think thats a good FP task for an FP beginner
02:24:10 <pumpkin_> andrey_nado: can you elaborate on why you think it's a good match?
02:24:49 * cads loves PICS, but FP does not!
02:25:40 <pejo> JaffaCake, have you optimized WSDeque a lot?
02:26:20 <JaffaCake> optimised, no - there isn't much optimisation to be done there (apart from doing idempotent work-stealing queues)
02:27:43 <pejo> JaffaCake, on a rather unrealistic benchmark with takes and puts your implementation is faster than the idempotent work-stealing queues (preliminary numbers).
02:28:59 <andrey_nado> pumpkin_: I can't now. I'm working in math modelling and use ะก++. Now I'd just like to investigate how Haskell would be usefull in my models. I really like declarative programming and use it as much as possible to avoid bugs. This is why I'm trying Haskell. If it doesn't work sell in problems like mine, could you tell in couple words, why?
02:30:04 <pumpkin_> I'm not saying it doesn't work well, I'm just saying it's learning to swim by jumping in on the deep end of the pool. You might learn well or you might almost drown and vow never to touch water again :P
02:30:20 <m3ga> andrey_nado: i'm sure there are a couple of people here who could code your problem well and produce good, fast, readable code, but those are haskell experts.
02:32:12 <m3ga> i'm still a haskell newbie and that just looks like one of those tasks that would be difficult for me in haskell
02:32:59 <andrey_nado> m3ga: in other words, you think that usual imperative programming is more suitable in my case?
02:33:32 <m3ga> for that problem there are obvious imperative programming solutions.
02:33:44 <quicksilver> andrey_nado's problem sounds very easy in haskell to me.
02:34:49 <andrey_nado> quicksilver: glad to hear it :) Could you help me a bit with it?
02:35:13 <quicksilver> I don't know where to start.
02:35:15 <pumpkin_> @type \x f -> join (return . f $ x)
02:35:16 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => a -> (a -> m a1) -> m a1
02:35:21 <pumpkin_> that's bind, right?
02:35:25 <quicksilver> I agree with the general notion of learning a programming language by practical examples
02:35:33 <quicksilver> but you have to get some of the basics down first, IMO.
02:35:56 <quicksilver> implementing the generational step shoul dbe very simple
02:35:59 <quicksilver> you could do that first
02:36:03 <quicksilver> do the file writing later
02:36:15 <quicksilver> you'll need to decide on a representation for your cells (a list?
02:37:49 <andrey_nado> quicksilver: I'd refer something like arrays instead
02:38:01 <andrey_nado> mutable arrays
02:38:23 <quicksilver> mutable arrays are not very idiomatic haskell
02:38:25 <pumpkin_> then you'd just be learning to write imperative code in haskell :)
02:38:36 <quicksilver> I'd recommend a Map or a Seq.
02:40:27 <andrey_nado> quicksilver: what package?
02:41:34 <BONUS> pumpkin_: that's not bind, that just kind of looks like $ :)
02:41:49 <BONUS> bind is m a -> (a -> m a1) -> m a1
02:41:57 <pumpkin_> oh yeah
02:42:00 <Kvasir> newbie question, how can I ask the user to input 10 numbers and put them in a list?
02:42:10 <BONUS> @type \x f -> join (fmap f x)
02:42:11 <lambdabot> forall a (m :: * -> *) a1. (Monad m, Functor m) => m a -> (a -> m a1) -> m a1
02:42:12 <pumpkin_> BONUS: was trying to figure out how to write it in terms of return and join only
02:42:27 <BONUS> you can't imho, you need fmap
02:42:40 <quicksilver> andrey_nado: they're both standard in a loose sense of standard.
02:42:46 <pumpkin_> hmm, but a Monad in category theory is typically expressed in those terms, I thought?
02:42:59 <quicksilver> andrey_nado: the package is called containers
02:43:03 <pumpkin_> oh, you have a functor too
02:43:05 <pumpkin_> duh
02:43:07 <quicksilver> andrey_nado: this is a good page to have open : http://www.haskell.org/ghc/dist/current/docs/libraries/index.html
02:43:14 <mmorrow> @type (join .) . flip fmap
02:43:15 <lambdabot> forall a a1 (f :: * -> *). (Functor f, Monad f) => f a1 -> (a1 -> f a) -> f a
02:43:35 <pumpkin_> yeah, I'm stupid :P
02:43:39 <mmorrow> interestingly, @pl knows one case and not another
02:43:45 <mmorrow> @pl (join .) . flip fmap
02:43:45 <lambdabot> (join .) . flip fmap
02:43:47 <andrey_nado> quicksilver: thank you, I'll learn it
02:43:55 <mmorrow> @pl flip ((join .) . fmap)
02:43:55 <lambdabot> (>>=)
02:43:56 <andrey_nado> quicksilver++
02:44:01 <pumpkin_> hah
02:44:10 <mmorrow> @free flip
02:44:11 <lambdabot> (forall x. h . k x = p (f x) . g) => h . flip k y = flip p (g y) . f
02:44:25 <pumpkin_> what does @free do?
02:44:41 <mmorrow> it computes identities given types
02:44:52 <pumpkin_> hmm
02:45:03 <mmorrow> kinda like solving a system of equation
02:45:06 <mmorrow> (i think)
02:45:12 <mmorrow> i haven't read about it though
02:45:18 <Peaker> I think it finds the available "theorems for free" that you have for a type?
02:45:23 <mmorrow> yeah
02:45:35 <mmorrow> identities := "theorems"
02:45:37 <quicksilver> actually, it phone the author of 'theorems for free'
02:45:39 <Feuerbach> Kvasir: fmap (map read) $  sequence (replicate 10 getLine) :: IO [Int]
02:45:43 <quicksilver> that's why its' a bit slow sometimes.
02:46:10 <Kvasir> uhm
02:46:18 <Peaker> @src replicateM
02:46:19 <lambdabot> replicateM n x = sequence (replicate n x)
02:46:34 <BONUS> Kvasir: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2447#a2447
02:46:42 <mmorrow> @type replicateM 10 (read `fmap` getLine)
02:46:43 <lambdabot> forall a. (Read a) => IO [a]
02:47:02 <Kvasir> can I do it with a listcomp?
02:47:12 <mmorrow> hmm
02:47:40 <Kvasir> I was randomly trying something like [do { y <- getLine; y} | x <- [0..10]]
02:47:41 <mmorrow> not without it being forced
02:47:46 <mmorrow>  /contrived
02:48:12 <mmorrow> "do" notation is almost the same as list comprehensions
02:48:21 <mmorrow> just s/[]/m/
02:48:34 <mmorrow> for lists, do and [ x | ..,. |] coincide
02:49:00 <Kvasir> ok
02:49:05 <mmorrow> , do x <- [0..9]; return (x * 2)
02:49:07 <lunabot>  [0,2,4,6,8,10,12,14,16,18]
02:49:21 <mmorrow> , [ x * 2| x <- [0..9] ]
02:49:22 <lunabot>  [0,2,4,6,8,10,12,14,16,18]
02:49:31 <mmorrow> , [ x * 2 | x <- [0..9], x < 5 ]
02:49:32 <lunabot>  [0,2,4,6,8]
02:49:42 <mmorrow> , do x <- [0..9]; guard (x < 5); return (x * 2)
02:49:43 <lunabot>  [0,2,4,6,8]
02:50:43 <mmorrow> Kvasir: there used to be monad comprehensions in haskell
02:51:03 <mmorrow> so you could have done [ read x | x <- getLine ]
02:51:07 <mmorrow> but no more
02:52:14 <mmorrow> Kvasir: yeah, `replicate' capture that exact pattern
02:52:24 <mmorrow> ("[do { y <- getLine; y} | x <- [0..10]]")
02:52:54 <mmorrow> (replicateM or replicateM_ for the monad case)
02:53:05 <Kvasir> this is probably too advanced for me
02:53:30 <mmorrow> Kvasir: is reading 23 files in a row too advanced ?
02:53:33 <mmorrow> ;)
02:53:47 <quicksilver> sequence_ plus a list comp is occasionally a useful idiom
02:53:53 <quicksilver> can be easier to read than nested fors
02:53:58 <quicksilver> (forM_s)
02:54:11 <mmorrow> err, you probably wouldn't use replicateM for 23 files...
02:54:25 <mmorrow> probably mapM or forM
02:54:34 <wli> Some people are really good at golfing Project Euler etc. problems with the list monad.
02:54:58 <wli> Never mind.
02:55:06 <pumpkin_> it's true :)
02:55:33 <mmorrow> i don't use the list monad much. maybe because i've never programmed in prolog..
02:56:43 <mmorrow> i'm surprised there's so `for' analog of forM
02:56:48 <mmorrow> s/so/no/
02:57:28 <mmorrow> (..in the prelude)
02:58:04 <pumpkin_> people tend to use forM where they'd do a stateful for loop
02:58:21 <pumpkin_> it feels weird doing flip map on pure values, but maybe I'm just not open-minded enough!
02:58:22 <trofi^w> :t flip
02:58:23 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
02:58:28 <Gracenotes> list comprehensions sort of have the order of a for
02:58:51 <Gracenotes> if you're just looking for the ordering look-nice, at least
02:59:01 <Gracenotes> and no pointless either
03:01:54 <quicksilver> pumpkin_: it's a question of the relative length of the expressions, in my opinion
03:02:02 <quicksilver> "map f xs" looks fine
03:02:10 <pumpkin_> I guess that makes sense
03:02:17 <quicksilver> but map (\x -> ... some rather long 10 line function ..) [1,2,3]
03:02:21 <quicksilver> looks a bit odd.
03:02:34 <quicksilver> but the time you get to the [1,2,3] you've forgotten what they were for.
03:02:39 <osfameron> don't you just map f [1,2,3] where f... ?
03:02:39 <pumpkin_> I guess it collects the easy-to-absorb stuff close by
03:02:40 <quicksilver> at least, that's the way it feels to me :P
03:02:53 <quicksilver> osfameron: I don't like naming things I only use once.
03:03:05 <quicksilver> it feels like a waste of cognitive energy coming up with a good name.
03:03:12 <pumpkin_> yeah
03:03:14 <Gracenotes> [ rather long and complicated halp I'm stuck in an expression factory | x <- [1,2,3] ]
03:03:33 <Gracenotes> actually... hm, that's not a different order at all.
03:03:35 <osfameron> otoh it feels like a waste of energy decoding what 'flip' has done to me ;-)
03:03:46 <Gracenotes> o nos, my mind, I feel it going!
03:03:58 <pumpkin_> fail
03:04:26 <pumpkin_> did you see in the monad reader, "epic fail" was used? :)
03:04:42 <pumpkin_> (the latest issue)
03:05:13 <Gracenotes> NO I DIDN'T
03:05:53 <Kvasir> I shouldn't do haskell while I study C
03:15:38 <trofi^w> :t epic
03:15:39 <lambdabot> forall t. ([Char] -> t) -> t
03:15:54 <trofi^w> @hoogle pic
03:15:54 <lambdabot> Data.Fixed type Pico = Fixed E12
03:15:55 <lambdabot> Data.Time.Clock picosecondsToDiffTime :: Integer -> DiffTime
03:15:55 <lambdabot> Distribution.PackageDescription.Check PackageDistSuspicious :: String -> PackageCheck
03:15:58 <trofi^w> @hoogle epic
03:15:58 <lambdabot> No results found
03:16:23 <trofi^w> @src epic
03:16:23 <lambdabot> Source not found. You untyped fool!
03:17:49 <Kvasir> http://rafb.net/p/Z35gHt95.html
03:31:03 <BONUS> haha
03:31:04 <BONUS> nice
03:34:09 <Gracenotes> Kvasir: hehe :)
03:34:25 <Gracenotes> although, beware, recursion in C isn't as nice as it is in Haskell.
03:34:34 <Kvasir> too bad that I can't do void main(int k=0)
03:34:40 <Kvasir> yep, I know
03:34:45 <Gracenotes> Haskell can make optimizations like tail recursion optimization, etc.
03:35:02 <Gracenotes> in C it just keeps track of the stack no matter what!
03:35:32 <Gracenotes> (as far as I know, at least. An aggressive C optimizer might notice.)
03:58:33 <wli> I won't just drop dead in my sleep etc. It'll have me spending quite a bit of time with no arms and no legs and blind and so on.
03:59:13 <yitz> wli? are you ok?
03:59:55 <wli> Just the usual chronic health problems, permanent conditions, et al. Sorry, wrong channel.
04:00:11 <yitz> ;)
04:00:29 <SamB> yitz: you were afraid he was going to be the next dibblego?
04:01:04 <yitz> SamB: I was thinking I had better close my irc client, real quick.
04:01:14 <SamB> oh?
04:01:29 <yitz> If that's what it does to wli
04:02:19 * SamB wonders how to kill a DOS program ...
04:02:40 <pumpkin_> ctrl + c?
04:02:49 <wli> I'm still trying to figure out how to write an interpreter.
04:03:03 <wli> I probably never will.
04:03:06 <SamB> I tried ctrl+C
04:03:10 <yitz> SamB: Release a new version of DOS that is incompatible.
04:03:11 * mstr wonder what DOS programs people still run ..
04:03:31 <SamB> I guess just killing the dosemu works well enough
04:05:27 <pozic> Am I doing anything wrong if I write instance MonadTrans FooT where lift = FooT . lift . lift . lift . lift ? Or is there no way around that?
04:05:27 <SamB> apparantly the QuickBasic compiler doesn't like me
04:06:10 <Gracenotes> hm. For applicative parsers, what happens if one parsing statement has no effect? Just join it into the next statement and compose them somehow?
04:06:39 <ski> there is no `join' for applicative functors
04:06:39 <Gracenotes> well, bad phrasing. no effect meaning that it consumes input, but yields no result.
04:07:01 <SamB> it doesn't seem to support /?
04:07:02 <ski> does "no result" mean `()' or `Void' ?
04:07:04 <osfameron> :t lift
04:07:05 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Monad m, MonadTrans t) => m a -> t m a
04:07:05 <quicksilver> Gracenotes: applicatives have (>>)
04:07:08 <osfameron> :t lift . lift
04:07:09 <lambdabot> forall (t :: (* -> *) -> * -> *) (m :: * -> *) a (t1 :: (* -> *) -> * -> *). (Monad m, MonadTrans t1, Monad (t1 m), MonadTrans t) => m a -> t (t1 m) a
04:07:18 <SamB> thank god MS put up the usage information on http://support.microsoft.com/kb/43090
04:07:22 <quicksilver> Gracenotes: conventionally they call it (*>)
04:07:36 <quicksilver> Gracenotes: e.g. "lparen *> expr <* rparen"
04:07:40 <Gracenotes> ah, I see, all the other symbols :)
04:07:46 <Gracenotes> @type (*>)
04:07:47 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
04:07:57 <Gracenotes> @src *>
04:07:57 <lambdabot> (*>) = liftA2 (const id)
04:08:00 <quicksilver> Gracenotes: the paren parts yield no results
04:08:08 <quicksilver> Gracenotes: so the result of that is just the result of 'expr'
04:08:14 <pumpkin_> it's a pretty neat system
04:08:37 <quicksilver> mnemonic : the '>' point towards the return value you actually want.
04:08:44 <pumpkin_> I much prefer the idea of an applicative parser to a monadic one
04:09:13 <quicksilver> 90% of the time, "monadic" parsers I write are, in fact, applicative.
04:09:22 <mmorrow> yeah, i was just about to say that
04:09:27 <Gracenotes> hm. I see what people mean about context.
04:09:33 <quicksilver> the "10%" is this construct: do { n <- parseLength; xs <- replicateM n parseItem }
04:09:33 <SamB> certainly Applicative gives the library more freedom
04:09:38 <Gracenotes> and how monads provide them (in terms of scope)
04:09:39 <mmorrow> but that other 10%, applicatives are fail
04:09:45 <quicksilver> ^^ that's fundamentally monadic
04:09:53 <quicksilver> the parser depends on the first parsed value.
04:10:00 <quicksilver> and length bytes are pretty common in binary formats.
04:10:01 <mmorrow> ReadP (ReadP a)
04:10:18 <SamB> well, that's why you need to use a general API that you can intantiate with a monadic parser if it turns out you need one?
04:10:25 <Gracenotes> so, how does *> work... x.x
04:10:38 <SamB> @src (*>)
04:10:38 <lambdabot> (*>) = liftA2 (const id)
04:10:48 <SamB> :t liftA2
04:10:49 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
04:10:54 <quicksilver> textual formats are more likely to just read any amount, and then defer well-formedness to a later step.
04:10:57 <SamB> :t const id
04:10:58 <lambdabot> forall a b. b -> a -> a
04:11:01 <mmorrow> SamB: um, but a monadic parser lib is applicative by default
04:11:12 <quicksilver> you don't necessarily need to parse the right grammar, you can parse a superset of it and then have a second parse.
04:11:15 <Gracenotes> yeah, the definition doesn't make so much sense. I know about functions as applicatives and lists, but other stuff and in general, not so much
04:11:17 <quicksilver> that's often more conveneient.
04:11:24 <Gracenotes> > (+) <$> [1,2,3] *> [4,5,6]
04:11:25 <lambdabot>   [4,5,6,4,5,6,4,5,6]
04:11:31 <SamB> mmorrow: well, what I mean is that you use a Parser typeclass with more than one instance ;-P
04:11:39 <mmorrow> yuk, typeclasses
04:11:53 <wli> How do you do fixity decls anyway? ;)
04:11:57 <mmorrow> well, i like them for prettyprinters
04:12:04 <mmorrow> not for parsers for some reason
04:12:06 <Gracenotes> > ((+) <$> negate *> (+5)) 10
04:12:07 <lambdabot>   15
04:12:14 <Gracenotes> > ((+) <$> negate <* (+5)) 10
04:12:15 <lambdabot>       Overlapping instances for Show (a -> a)
04:12:15 <lambdabot>        arising from a use of `s...
04:12:18 <SamB> Gracenotes: I'm guesing it "runs" both args and returns the output of the second?
04:12:21 <Gracenotes> oh... hm.
04:12:34 <quicksilver> like >>
04:12:37 <SamB> try some more parens?
04:12:47 <Gracenotes> > ((+) <$> (negate <* (+5))) 10
04:12:48 <lambdabot>       Overlapping instances for Show (a -> a)
04:12:48 <lambdabot>        arising from a use of `s...
04:12:57 <Gracenotes> > ((+) <$> (negate <* (+5))) 10 20
04:12:58 <lambdabot>   10
04:13:08 <SamB> @type negate
04:13:10 <lambdabot> forall a. (Num a) => a -> a
04:13:13 <SamB> type (+5)
04:13:18 <SamB> @type (+5)
04:13:19 <lambdabot> forall a. (Num a) => a -> a
04:13:21 <SamB> huh
04:13:24 <SamB> wierd
04:13:36 <Gracenotes> @type (<*)
04:13:37 <mmorrow> wli: you fix up your parse tree in a second pass
04:13:37 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
04:13:55 <mmorrow> in the first one, you just parse everything as infixl
04:14:03 <Gracenotes> intuitively, it makes sense like >>, but I don't get that from the source
04:14:36 <mmorrow> (or you can scan the file i guess, catch the fixity decls in the lexer/a pre-stage)
04:14:39 <SamB> wli: yeah, you can't resolve the fixity until you've made an initial parse, because you need to look at any fixity declarations
04:14:43 <mmorrow> but that sounds nasty
04:14:48 <Gracenotes> @src liftA2
04:14:48 <lambdabot> liftA2 f a b = f <$> a <*> b
04:14:53 <SamB> that sounds highly impractical
04:15:50 <SamB> what the heck is MS OS/2 ???
04:16:24 <yitz> SamB: What it will be called after MS buys IBM?
04:16:42 <pozic> SamB: http://pages.prodigy.net/michaln/history/pr/87apr_m3592.html
04:16:46 <mmorrow> Java.NET(R)(R)
04:16:47 <mmorrow> ?
04:17:06 <Gracenotes> hrm.
04:17:06 <Gracenotes> > ((+) <$> (negate <* (+7))) 0 1000
04:17:06 <Gracenotes> @botsnack
04:17:07 <lambdabot> :)
04:17:07 <lunabot>  :)
04:17:07 <lambdabot>   1000
04:17:38 <yitz> Can we please get lunabot to stop eating lambdabot's snacks?
04:17:48 <SamB> yitz: it's mentioned in http://support.microsoft.com/kb/43090
04:18:17 * SamB wonders in what way the object file can be specific to the MS version anyway
04:18:30 <Gracenotes> @botsmack
04:18:30 <lambdabot> :)
04:18:30 <lunabot>  :)
04:18:31 <wli> Yeah, it doesn't seem all that bad to me. Expressions where fixity decls matter are delimited by various means within other expressions anyway.
04:18:57 <pumpkin_> that was one of the weird things that struck me about haskell when I first started learning it
04:19:10 <SamB> yeah, basically you just need to make sure you keep track of where all the parens are
04:19:13 <pumpkin_> (being able to alter associativty and precedence)
04:19:22 <wli> if/then/else
04:19:32 <SamB> hmm?
04:19:43 <SamB> what about if/then/else?
04:19:58 <wli> That delimits things too, as does let, do, where, etc.
04:20:13 <pozic> Is there a way to make this less horrible? http://paste.debian.net/30677/
04:21:11 <pumpkin_> MonadUnique :o
04:21:14 <yitz> SamB: Interesting, the wikipedia article says that MS and IBM developed it jointly for the first few years.
04:21:18 <SamB> wli: what I mean is that you need to keep parens in your parse tree until you've resolved fixity
04:21:40 <mmorrow> SamB: parens are implicit in the tree structure
04:21:47 <mmorrow> (assuming:)
04:21:50 <mmorrow> , src ''AppE
04:21:53 <mmorrow> binary app
04:21:53 <lunabot>  luna: Not in scope: type constructor or class `AppE'
04:21:58 <mmorrow> , src 'AppE
04:22:00 <pumpkin_> you just need to be able to rearrange/rotate parts of the tree after seeing fixity?
04:22:03 <lunabot>  data Exp = ... | AppE Exp Exp | ...
04:22:03 <lunabot>  infixl 9
04:22:12 <mmorrow> pumpkin_: yes
04:22:28 <wli> SamB: Kind of. You can keep the bits between parens unparsed save for other parens.
04:22:31 <pumpkin_> what about cases where you define it to not be associative?
04:22:46 <wli> SamB: Or other delimiting tokens (if/then/else, do, let, etc.)
04:22:50 <mstr> yitz: MS wasn't a big player yet back then
04:22:56 <pumpkin_> how is 5 + 6 + 7 represented before you know the fixity of +?
04:22:59 <mmorrow> here some code that does some form of this http://code.haskell.org/lambdabot/lambdabot-utils/Lambdabot/FixPrecedence.hs
04:23:13 <mmorrow> pumpkin_: however
04:23:20 <wli> pumpkin: It's only separated by operators so you keep it unparsed.
04:25:42 <wli> pumpkin: if x + y == z then u + v else r + s can parse as far as IfThenElse [["x","+","y","==","z"],["u","+","v"],["r","+","s"]]
04:26:04 <quicksilver> I parsed assuming left assoc
04:26:08 <mmorrow> personally, i
04:26:08 <quicksilver> and then rotated the tree
04:26:10 <mmorrow> yeah
04:26:12 <mmorrow> me too
04:26:15 <quicksilver> I wasn't very happy with that solution to be honest
04:26:17 <quicksilver> but it did work.
04:26:35 <quicksilver> sometimes the notion of an 'ABA' list is useful.
04:26:38 <pumpkin_> but I mean, if the parens are implicit
04:26:44 <mmorrow> wli: the problem with that thought, is what if you have:
04:26:53 <wli> I'd just dump the parts relying on fixities into lists.
04:27:00 <mmorrow> (let ....... 40 lines) + (case ....  where .... ) * 20
04:27:06 <pumpkin_> how do you know whether something was written with x ? (y ? z) or x ? y ? z?
04:27:31 <mmorrow> yeah, that too
04:27:39 <wli> mmorrow: Yes, you need some way to have parsed subexpressions for where synchronizing tokens/etc. appear between operators.
04:28:03 <mmorrow> which the infixl method handles seamlessly
04:28:11 <wli> pumpkin: You have grouping suboperators I didn't talk about.
04:28:15 <pumpkin_> ah
04:28:26 <mmorrow> hmm, i can't even think of how you could do it otherwise
04:28:27 <pumpkin_> I'm mostly curious about infix, not infixl and infixr
04:28:32 <pumpkin_> unless I'm confused
04:28:37 <pumpkin_> which is quite possible :)
04:29:10 <mmorrow> pumpkin_: if all you have is binary application, then you have to rep it one way or another
04:29:23 <mmorrow> but that doesn't mean you interpret it semantically as infixr or l
04:29:32 <wli> mmorrow: OpExpr [LetExpr ..., OpWhatever "+", CaseExpr ..., OpWhatever "*"]
04:30:04 <mmorrow> wli: hmm, i see how that could work.
04:30:14 <mmorrow> it just looks painful to me
04:30:23 <wli> pumpkin: OpExpr [OpWhatever "x", OpWhatever "?", OpExpr [OpWhatever "y", OpWhatever "?", OpWhatever "z"]]
04:30:36 <pumpkin_> hmm
04:30:46 <pumpkin_> yeah, that makes sense
04:30:59 <pumpkin_> how do you write infix declarations inline in a let ?
04:31:05 <pumpkin_> I can't seem to make it work
04:31:23 <mmorrow> , ppDoc $ foldl AppE (mkName "f") (replicate 8 (mkName "a"))
04:31:24 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Syntax.Exp'
04:31:39 <mmorrow> , ppDoc $ foldl AppE (VarE (mkName "f")) (replicate 8 (VarE (mkName "a")))
04:31:40 <lunabot>  f a a a a a a a a
04:31:44 <mmorrow> , ppDoc $ foldr AppE (VarE (mkName "f")) (replicate 8 (VarE (mkName "a")))
04:31:46 <lunabot>  a (a (a (a (a (a (a (a f)))))))
04:31:50 <mmorrow> grr
04:31:59 <wli> Well, when there are synchronizing tokens that can be parsed to some extent without relying on expression fixities etc., you can actually pick those up in the first pass.
04:32:51 <mmorrow> , ppDoc $ foldr (AppT . ArrowT) (VarT (mkName "o")) (fmap (VarT . mkName . (:[])) ['a'..'g'])
04:32:52 <lunabot>  luna: Couldn't match expected type `a -> Language.Haskell.TH.Syntax.Type'
04:33:00 <wli> Parens, if/then/else, let/in, where, do, etc.
04:38:06 <pumpkin_> > let (><) x y = x + 2*y; infix 7 ><; in 7 >< 5 >< 3
04:38:07 <lambdabot>       precedence parsing error
04:38:07 <lambdabot>          cannot mix `(><)' [infix 7] and `(><)...
04:38:35 <pumpkin_> > let (><) x y = x + 2*y; infix 7 ><; in (7 >< 5) >< 3
04:38:36 <lambdabot>   23
04:38:49 <pumpkin_> mmorrow: that's the situation I was talking about
04:39:31 <pumpkin_> if you assume left associativity when parsing, you can't distinguish the first from the second, so you can't throw an error when you find out that >< is non-associative
04:40:52 <wli> My solution is the synchronizing token -based partial parse.
04:41:13 <pumpkin_> yeah, I can definitely see how your scheme would work in that situation
04:41:28 <pumpkin_> was just wondering what the alternative was, since mmorrow said it was clunky :)
04:41:41 <wli> OpExpr [OpExpr [OpWhatever "7", OpWhatever "><", OpWhatever "5"], OpWhatever "><", OpWhatever "3"]
04:43:34 <wli> I don't see how it's clunky at all. You do essentially do the infixl, but use it to accumulate a sequence where partial parses might end up as sequence elements.
04:43:48 <pumpkin_> yeah, it seems reasonable to me
04:44:05 <mreh> :t sgn
04:44:06 <lambdabot> Not in scope: `sgn'
04:44:10 <mreh> :t sign
04:44:11 <lambdabot> Not in scope: `sign'
04:44:12 <pumpkin_> :T signum
04:44:16 <mreh> ta
04:44:18 <pumpkin_> :)
04:44:22 <pumpkin_> I fail anyway
04:44:50 <HugoDaniel> im sorry
04:44:51 <mreh> are there matricies supported in haskell?
04:44:56 <mreh> some library?
04:45:02 <pumpkin_> @hackage hmatrix
04:45:02 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hmatrix
04:45:10 <HugoDaniel> but what is the problem with my indentation here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2453#a2453  ?
04:45:38 <mreh> someone showed me how to check if a line intersecs a circle using matricies
04:45:51 <pumpkin_> hmm
04:45:54 <wli> You can go around doing depth affairs so that everything in an expression list is either completely parsed or a naked token, and continue merely as if you'd not done a leftmost derivation or whatever.
04:46:07 <pumpkin_> how does that work? a circle isn't linear
04:46:12 <pumpkin_> but maybe it's too late
04:46:19 <abbe> HugoDaniel, forgtten an else for the last if
04:46:34 <HugoDaniel> abbe, there is none
04:46:41 <HugoDaniel> can't i have an if without an else ?
04:46:46 <pumpkin_> no
04:46:54 <HugoDaniel> argh :/
04:46:57 <pumpkin_> it doesn't make sense in the functional mentality
04:47:02 <pumpkin_> everything has a value
04:47:02 <wli> pumpkin: This is where LBA's shine. They rely in an essential way on doing reductions in the middle of the string.
04:47:05 <Gracenotes> .x.x
04:47:13 <pumpkin_> Gracenotes: sleep or I whip you
04:47:30 <HugoDaniel> ok, thanks
04:47:30 <Gracenotes> no, I'm going out to get something to eat
04:47:31 <quicksilver> HugoDaniel: what would you expect it to do in the 'else' case?
04:47:41 <quicksilver> HugoDaniel: all expressions must have a value...
04:47:43 <Gracenotes> I'll sleep at 2, after my last class
04:47:48 <HugoDaniel> quicksilver: it is never reached
04:47:54 <quicksilver> ah, then
04:47:55 <Gracenotes> (my first class is around 11:45)
04:48:01 <quicksilver> error "This can't happen"
04:48:14 <pumpkin_> if it seriously can't happen, then just take out the if :P
04:48:21 <pumpkin_> if it's a sanity check, put the error in
04:48:22 <quicksilver> right.
04:48:37 <wli> pumpkin: LBA's are completely prepared to handle a string of terminal symbols with a nonterminal in the midst of it because the generality of their grammars is such that they must.
04:48:43 <Gracenotes> and your user goes "No! This can't happen!"
04:48:54 <pumpkin_> "The impossible has happened" or something like that
04:49:04 <Gracenotes> wli: mm, what does that stand for?
04:49:23 <pumpkin_> yeah, what is it? I only know of LBA in the context of storage
04:49:36 <Gracenotes> oh, they're the automata that can recognize context-sensitive grammars, right?
04:49:43 <pumpkin_> oh
04:49:46 <pumpkin_> lienar-bounded?
04:49:48 <Gracenotes> *languages
04:49:48 <pumpkin_> linear
04:50:00 <wli> Linear Bounded Automaton
04:50:06 <Gracenotes> like a Turing machine, but more like... a computer :X
04:50:07 <pumpkin_> ah, yeah, makes sense
04:51:49 <Gracenotes> o.o
04:52:18 <pumpkin_> ?
04:52:26 <Gracenotes> > (:[]) . (:[]) . (:[]) . (:[]) . (:[]) . (:[]) . (:[])            $0.0
04:52:27 <lambdabot>   [[[[[[[0.0]]]]]]]
04:52:32 <pumpkin_> lol
04:52:36 <mreh> is there a plus/minus operator in haskell?
04:52:43 <pumpkin_> ?
04:52:44 <wli> Aha, http://www.aclweb.org/anthology-new/E/E91/E91-1012.pdf
04:52:51 <koeien> mreh: you can make one
04:53:00 <HugoDaniel> mreh: yes, it is + and -
04:53:07 <mreh> like in the solution to a quadratic equation
04:53:13 <pumpkin_> > let x +- y = [(x - y)..(x + y)] in 5 +- 2
04:53:14 <lambdabot>   [3,4,5,6,7]
04:53:19 <pumpkin_> oh
04:53:29 <mreh> silly question i know
04:53:35 <pumpkin_> not unary
04:53:54 <Gracenotes> mreh: ah. Well, you can make a function that, given two values, returns a+b and a-b in a tuple
04:54:02 <pumpkin_> or in a list
04:54:07 <mreh> yeah, that was my thought too
04:54:08 <pumpkin_> and then you can take list monadness
04:54:47 <mreh> would it work though? it would need to be the lowest precedence operator though
04:55:02 <mreh> it was a badly thought out idea i think
04:55:13 <Gracenotes> sure Or potentially use arrows, but something like this should work fine: let (x, y) = yourFunc firstValue secondValue; 2a = 2*a in (x / 2a, y / 2a)
04:55:13 <quicksilver> you can set the precedence according to your taste.
04:55:21 <quicksilver> it could work, and could be quite neat
04:55:23 <mreh> seeing as + and - are such high precedence
04:55:32 <pumpkin_> mreh: +- is disjoint from + or -
04:55:35 <quicksilver> but how often do you solve problems with many many +-s
04:55:50 <mreh> the intersection of a line with a circle has two solutions
04:56:00 <Gracenotes> well, maybe one :)
04:56:03 <pumpkin_> if you thought of it in terms of a monad, every +- you introduce would expand the solutions
04:56:04 <mreh> or none
04:57:42 <quicksilver> this is related to interval arithmetic
04:57:49 <quicksilver> in which you only ever keep the upper and lower bounds
04:58:23 <quicksilver> which is useful for error bounds but also for clever analysis
04:58:31 <pozic> Is it possible to write a language implementation in Haskell such that the GHC garbage collector has only an additive constant of overhead? So, suppose the language implementation interprets x86 assembly and suppose a very large program is being computed by the x86 assembly program and then executed. Is it possible to have the GC somehow ignore all this?
04:58:51 <pumpkin_> you can work outside the GC if you want
04:59:03 <pumpkin_> but you forego many helpful things
04:59:07 <pozic> pumpkin_: how?
04:59:18 <quicksilver> it's extremely difficult to work outside the GC.
04:59:23 <pumpkin_> lots of low-level functions like malloc/poke etc.
04:59:26 <pumpkin_> it's a real pain :P
04:59:28 <pumpkin_> but would work for an asm
04:59:50 <quicksilver> pozic: it can be shown that the amortized cost of GC is no worse than the cost of free/malloc
04:59:57 <quicksilver> as long as you don't actually have leaks
05:00:07 <quicksilver> it's O(amount allocated) as far as I know.
05:00:28 <quicksilver> (normally well-bounded, though, as in, less than that)
05:00:30 <pozic> quicksilver: where can I find that proof?
05:00:36 <quicksilver> I don't know.
05:00:55 <pumpkin_> it's typical though
05:00:56 <max_> quicksilver: is that number of allocations, or the actual space allocated? Surely free/malloc doesn't care about the latter?
05:01:07 <Gracenotes> > let func x y = [x+y, x-y]; quad a b c = [ u/(2*a) | u <- nub (func (negate b) (sqrt $ b^^2 - 4*a*c)) ] in quad 1 (-1) (-6) -- proof of concept
05:01:08 <lambdabot>   [3.0,-2.0]
05:01:11 <quicksilver> Taejo: not entirely true.
05:01:21 <quicksilver> Taejo: allocating more space takes more time.
05:01:23 <Gracenotes> > let func x y = [x+y, x-y]; quad a b c = [ u/(2*a) | u <- nub (func (negate b) (sqrt $ b^^2 - 4*a*c)) ] in quad 1 2 1
05:01:25 <lambdabot>   [-1.0]
05:01:28 <quicksilver> Taejo: you have to ask the OS for more pages.
05:01:35 <quicksilver> Taejo: free() is more expensive than malloc, typically.
05:01:36 <Gracenotes> not taking into account imaginary monsters
05:01:51 <pozic> quicksilver: AFAIK, GC complexity depends on the amount of live objects. Free/malloc complexity just depends on the amount of changes to live objects.
05:02:23 <mreh> zipWith (,) [1..10] (tail . cycle $ [1..10])
05:02:28 <mreh> > zipWith (,) [1..10] (tail . cycle $ [1..10])
05:02:29 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,1)]
05:02:30 <Taejo> quicksilver: well, you can write a free/malloc implementation where malloc does all the work, and you can write one where free does almost all the work
05:02:32 <quicksilver> pozic: sure, but it isn't that simple.
05:02:59 <quicksilver> pozic: a smart GC doesn't re-check live objects it knows haven't changed since last time
05:03:07 <quicksilver> pozic: or doesn't re-check all live objects every time
05:03:09 <quicksilver> etc.
05:03:46 <pozic> quicksilver: ok, then I would like to know the numbers for a "smart GC". (yes, I know you don't know them).
05:05:00 <quicksilver> I don't have a reference, I'm afraid. Maybe something by Boehm or Richard Jones.
05:07:22 <wli> I think you can do LR(1) (or even LR(k)) without much of a problem.
05:07:42 <mreh> i have to map a truth value to all elements in a long list, and then check if at least one is true, will the normal order of evaluation do that as efficiently as possible?
05:08:35 <lilac> i vaguely recall some oleg magic which gave a typeclass instances for all types, but different instances for function types and non-function types
05:08:57 <lilac> can anyone confirm my memory (and possibly indicate how it's done)?
05:09:32 <Taejo> lilac: that sounds familiar... I think there might be something like that in HList
05:10:01 <quicksilver> lilac: yes, it's overlapping instances 'magic'.
05:10:13 * quicksilver considers anything which uses overlapping instances broken.
05:11:10 <wli> And even merge whatever items with identical cores you can without introducing reduce/reduce conflicts.
05:14:07 <wli> I guess you pair every nonterminal you reduce with some sort of thing describing the reduction rule used and the sentential form reduced to form a sort of labelled rose tree.
05:14:44 <pumpkin_> alright, I must sleep :)
05:15:05 <wli> Then you can run through it with really obvious functions to construct a real parse tree.
05:15:14 <det_> Why do types in Haskell begin with a capital letter ?
05:15:39 <wli> det: It's a convention to distinguish type names from other kinds of names.
05:16:22 <det> But aren't types always syntacticly apparent (unlike constructors) ?
05:16:37 <johnbs> You need to distinguish types from type variables
05:16:49 <johnbs> "Maybe something" and so on
05:16:57 <wli> det: What johnbs said.
05:17:23 <det> ahh
05:19:29 <det> I guess you could instead list the type variables of a type.
05:19:43 <det> foldl a b :: (a -> b -> a) -> a -> [b] -> a
05:19:46 <det> instead of
05:19:50 <det> foldl :: (a -> b -> a) -> a -> [b] -> a
05:20:19 <quicksilver> there isn't a strong reason for the syntactic distinction
05:20:22 <quicksilver> other languages do without it
05:20:32 <quicksilver> (ML, as far as I remember agda?)
05:20:39 <johnbs> It's nice though -- makes it easier to read
05:20:43 <quicksilver> it just seems convenient to some people.
05:20:49 <quicksilver> it makes it easier to read, and it makes some error messages better.
05:20:55 <quicksilver> although that is a bit of a joke ;)
05:20:57 <det> ML uses 'a 'b 'c
05:21:03 <quicksilver> considering how bad most of the error messages are.
05:21:14 <quicksilver> det: for variables yes, but not for type names themselves
05:21:15 <quicksilver> IIRC?
05:21:33 <quicksilver> whereas haskell actually *doesn't* distinguish type variables from value variables
05:21:47 <quicksilver> but it does 'type constants'.
05:21:52 <det> Same thing really, just different syntax.
05:22:41 <det> "('a -> 'b -> 'a) -> 'a -> 'b list -> 'a" is the same as "(a -> b -> a) -> a -> [b] -> a"
05:23:13 <det> ML just chooses to differentiate based on syntactic convention of type variables instead of types
05:25:36 <lilac> ah! http://okmij.org/ftp/Haskell/isFunction.lhs
05:31:24 <ImInYourMonad> is it possible to draw in gtk2hs? im making a Go-application(the game Go). and Imwondering if I should use opengl+glut(or glfw) or gtk2hs?
05:31:46 <ImInYourMonad> right nowi us gtk2hs and buttons and that is probably easir but it doesnt look like a neat Go-boar
05:31:48 <ImInYourMonad> d
05:32:19 <yitz> ImInYourMonad: you'd use cairo
05:39:03 <Mr_Giraffe> how active is haskell-cafe?
05:39:47 <osfameron> Mr_Giraffe: see for yourself: http://www.haskell.org/pipermail/haskell-cafe/
05:39:53 <vegai> highly
05:40:23 <ImInYourMonad2> why cairo?
05:41:39 <yitz> ImInYourMonad: so you can draw your board however you'd like
05:45:27 <Mr_Giraffe> osfameron, vegai: thanks!
05:46:33 <ImInYourMonad2> is there a cairo binidng in hackage,entiher me or cabal can find it
05:49:39 <ivanm> ImInYourMonad2: not in hackage, but gtk2hs has one IIRC
05:49:58 <Zao> ImInYourMonad2: hsclock supposedly uses gtk and cairo.
05:50:45 <Gracenotes> if it possible for every type in a type system to have a bottom not associated with some odd behavior (like throwing an error or hanging)?
05:51:02 <ImInYourMonad2> hmm it is in ghc b default?
05:51:07 <ImInYourMonad2> becuase i couldimport Graphics.Rendering.Cairo
05:51:26 <wli> Hmm, this parsing techniques book explains GLR, albeit under another name ("Tomita's parser").
05:51:27 <Gracenotes> in the implementation of any type system, that is. Preferably a non-trivial one :)
05:52:10 <wli> ftp://ftp.cs.vu.nl/pub/dick/PTAPG_1st_Edition/BookBody.pdf
05:52:11 <Zao> ImInYourMonad2: A wild guess would be that it'd be in gtk2hs
05:52:16 <RayNbow> http://www.haskell.org/gtk2hs/docs/gtk2hs-docs-0.9.12/Graphics-Rendering-Cairo.html
05:53:48 <wli> Looks like a directed graph is required to represent various of its structures.
05:54:38 <Saizan_> Gracenotes: why do you want a least defined element in such a type system?
05:56:17 <Gracenotes> Saizan_: no particular reason. _|_ seems to be an error or a = a in Haskell, values which can be of any type, so maybe there was better defined least defined element :/
05:57:23 <ImInYourMonad2> CSV=comma separated V=?
05:57:41 <Gracenotes> values
05:58:04 <Saizan_> ah, so by bottom you meant a value inhabiting any type?
05:58:05 <yitz> Gracenotes: the behavior of _|_ is undefined. it doesn't necessarily do anything in particular
05:59:05 <yitz> @go csv
05:59:05 <lambdabot> http://en.wikipedia.org/wiki/Comma-separated_values
05:59:05 <lambdabot> Title: Comma-separated values - Wikipedia, the free encyclopedia
05:59:29 <yitz> CSVโ - Carriage Services, Inc. (NYSE)โ
06:02:12 <mstr> i lold
06:03:54 <McManiaC> how can i get the current mouse position in on X11 screen?
06:04:41 <wli> ugh I've got so much shit to clean up so they can deliver this guy's deathbed or whatever
06:07:33 <wli> ugh I've got so much shit to clean up so they can deliver this guy's deathbed or whatever
06:08:24 <wli> Sorry, channel destination problems today.
06:09:58 <Gracenotes> wow... for the addDigits0, addDigits1, addDigits2, addDigits3 and addDigits4 in Data.Sequence... talk about boilerplate :)
06:10:21 <McManiaC> hehe
06:10:49 <McManiaC> take a look at Control.Monad and liftM to liftM5
06:10:50 <McManiaC> :D
06:11:19 <Gracenotes> well. That doesn't pattern match on 16 cases.
06:11:19 <wli> If you were to ask me how to do it, I'd use an rbtree and a circular doubly linked list with STRef's inside for maintenance purposes, but anyway.
06:11:36 <Gracenotes> 16 cases *each*, by the way :)
06:11:40 <McManiaC> =)
06:11:45 <Gracenotes> x.x
06:13:02 <wli> I'm not 100% sure how you could actually do that sort of thing where you save mutable state and resume computing with it without infecting callers with the ST monad.
06:14:19 <Gracenotes> @type forever (Just 10)
06:14:21 <lambdabot> Maybe ()
06:14:22 <wli> It'd basically be an imperative algorithm in Haskell's assembly-like verbose syntax for mutable state manipulation. :(
06:15:29 <Gracenotes> @type forever (Just 10) :: Just (Either a b -> a)
06:15:30 <lambdabot> Not in scope: type constructor or class `Just'
06:15:31 <wli> I have a tough time doing balanced binary search trees in C anymore. I don't think I could do it at all in Haskell (in fact I've yet to succeed at it in C since bad things happened).
06:15:37 <Gracenotes> @type forever (Just 10) :: Maybe (Either a b -> a)
06:15:37 <lambdabot>     Couldn't match expected type `Either a b -> a'
06:15:37 <lambdabot>            against inferred type `()'
06:15:37 <lambdabot>       Expected type: Maybe (Either a b -> a)
06:15:57 <Gracenotes> aww.
06:16:57 <wli> Seriously. You've got the imperative trees to do plus smoking out how somehow you might be able to avoid infecting callers with the state monad.
06:17:38 <wli> The good news is that the linked list simplifies tree deletion.
06:17:39 <Gracenotes> wli: hm. Well, you could hide the constructor and make it a (state, restofdata)
06:18:36 <Gracenotes> or just another constructor parameter...
06:19:11 <wli> Gracenotes: Well, you'd want it to look like Data.Sequence, so the caller can never inspect it except through your API's. The pain comes with the existential in ST.
06:19:21 <kunley> Hi. I created a git mirror of haskell-mode cvs repository at http://github.com/kunley/haskell-mode/tree/ . I wanted to drop an info at haskellwiki but I see the account creation is off. So I just announce it here. Someone may find it convenient.
06:19:25 <Gracenotes> ah, the ST monad
06:19:44 <Gracenotes> yeah :(
06:20:18 <wli> Gracenotes: I don't know why but I have trouble dealing with it.
06:20:53 <ImInYourMonad> can a button have a label in gtk2hs? because I cant for the life ofme figure out how to change what a button says
06:20:55 <wli> Gracenotes: I guess I could try a circular doubly-linked list and beg for help to get ideas of how to do things like this.
06:21:29 <Gracenotes> mm.
06:22:03 <Gracenotes> @type foldr (liftM2 (:)) (return [])
06:22:04 <lambdabot> forall a1 (m :: * -> *). (Monad m) => [m a1] -> m [a1]
06:23:03 <Gracenotes> @type \f xs-> foldr (liftM2 (:) . f) (return []) xs
06:23:03 <lambdabot> forall a1 (m :: * -> *) a. (Monad m) => (a -> m a1) -> [a] -> m [a1]
06:23:44 <Gracenotes> I'd hope GHC did that automatically with foldr/map rules and such... x.x
06:25:20 <pejo> Gracenotes, what does "that" mean in your sentence?
06:25:51 <Gracenotes> oh.
06:25:54 <Gracenotes> @src mapM
06:25:54 <lambdabot> mapM f as = sequence (map f as)
06:25:59 <Gracenotes> type (Monad m) => (a -> m a1) -> [a] -> m [a1]
06:26:24 <Gracenotes> sequence is basically a foldr, so GHC might be able to combine them
06:26:31 <Gracenotes> the foldr and the map
06:26:40 <EvilTerran> oh, fusion
06:26:51 <wli> data CircNode s t = CircNode { val :: t, prev, next :: STRef s (CircNode s t) } ; data Circ t = Circ { circHead, circTail :: forall s . STRef s (CircNode s t) }
06:26:53 <Gracenotes> foldr f z xs . map g == foldr (f . g) z xs
06:27:13 <Gracenotes> more efficient, very slightly. still :)
06:27:51 <Gracenotes> wli: hm. Well, I think you mentioned that you .could. do an existential
06:28:07 <EvilTerran> Gracenotes, i believe current GHC uses stream fusion, see http://www.cse.unsw.edu.au/~dons/papers/CLS07.html
06:28:23 <wli> Gracenotes: I don't know how or if it'll work.
06:28:33 <Gracenotes> yeah. existential types are interesting like that x.x
06:28:50 <Gracenotes> EvilTerran: yeah. although that's not stream fusion, tis map fusion
06:28:55 <pejo> EvilTerran, does it?
06:29:16 <EvilTerran> pejo, ISTR people've been working on it, altho i may be wrong
06:29:43 <Gracenotes> iirc GHC actually fuses map with go, what foldr's written using
06:29:45 <ImInYourMonad> can a button have a label in gtk2hs? because I cant for the life ofme figure out how to change what a button says
06:29:54 <Gracenotes> or actually, build. argh names.
06:31:07 <EvilTerran> ImInYourMonad, http://www.haskell.org/gtk2hs/docs/current/Graphics-UI-Gtk-Display-Label.html#v%3AlabelSetText
06:31:10 <Gracenotes> actually, I need to review the base classes. But either way it's a trick to make recursion pretty and painless
06:31:14 <gwern> wow, darcs has raised 1k
06:31:23 <gwern> I didn't actually expect that to happen
06:31:30 <wli> Gracenotes: I'm already stuck.
06:31:59 <vegai> only 1k?
06:32:11 <gwern> vegai: well that was the target
06:32:35 <vegai> oh, well then
06:32:43 <ImInYourMonad> thats for labels not buttons
06:32:43 <ImInYourMonad> can i stick alabl on a button?
06:33:05 <EvilTerran> ImInYourMonad, http://www.haskell.org/gtk2hs/docs/current/Graphics-UI-Gtk-Buttons-Button.html#v%3AbuttonSetLabel
06:33:10 <EvilTerran> then
06:33:42 <yitz> ImInYourMonad: create the button with buttonNewWithLabel
06:34:08 <yitz> ImInYourMonad: or use buttonSetLabel
06:34:29 <yitz> both in Graphics.UI.Gtk.Buttons.Button
06:35:11 <yitz> ah. like what EvilTerran said.
06:36:00 <yitz> gwern: 1k what?
06:36:26 <ImInYourMonad> wait wtf
06:36:26 <ImInYourMonad> i thought i tried buttonSetLabelmself,
06:36:26 <ImInYourMonad> uim sure id did
06:36:26 <ImInYourMonad> now ti works
06:36:46 <EvilTerran> maybe you made a typo.
06:39:04 <gwern> yitz: pennies. we're thrilled to death - we may be able to afford lunch for the darcs code sprint
06:39:15 <gwern> we couldn't've done it without the community's help!
06:39:15 <Gracenotes> @type ((&&) `on` (==0))
06:39:17 <lambdabot> forall a. (Num a) => a -> a -> Bool
06:40:30 <yitz> gwern: ah, doubtless as a result of the recent discussion of Project Euler problem 31 on this channel.
06:45:51 <wli> No such thing as a null STRef?
06:49:51 <yitz> wli: use STRef (Maybe a)
06:50:05 <wli> Already there.
06:51:31 <anders^^> is it supposed to be allowed to have a comma after the last exported function in a module? like this http://pastebin.com/m57e12109 where i have a unnecessary comma after function named two
06:53:06 <ImInYourMonad> so what is it exactl a monad does? is there not really real state? ic an do sideeffects without sideefects?
06:53:16 <yitz> anders^^: a trailing comma is allowed, yes. see 5.2 in the report
06:53:30 <anders^^> oki thanks
06:53:33 <ImInYourMonad> or the IO monad just makes sure I cant mix sideeffectful code with pure code?
06:53:50 <araujo> morning
06:54:48 <fasta> ImInYourMonad: The IO monad is just as pure as id.
06:55:13 <yitz> ImInYourMonad: in haskell, a monad is just a type class. you need to define an instance for two functions, >>= and return. by convention, they need to satisfy certain simple properties.
06:55:20 <yitz> ImInYourMonad: so nothing magical needs to be going on in a monad.
06:55:33 <wli> I now have stuff that doesn't compile.
06:55:50 <cizra> If the IO monad is pure as a baby's conscience, how come stuff can have side effects then?
06:56:06 <yitz> ImInYourMonad: the IO monad is special - those two functions are defined in a way that allows you to interact with the "real world".
06:56:19 <fasta> cizra: it's only when you evaluate the IO value when that happens.
06:56:44 <fasta> cizra: the evaluation basically can be seen as a kind of runIO or runhaskell function.
06:56:47 <cizra> fasta: Isn't it an impurity? Making something happen when something is evaluation.
06:56:50 <cizra> evaluated*
06:57:45 <Vq^> cizra: it's not evaluation in the same sense
06:58:05 <yitz> cizra: your function named "Main.main" is magical. it has type IO (). when you run your program, the IO actions are actually performed.
06:58:24 <Peaker> I think "Evaluation" of an IO value is considered only forming the IO value itself. Running it called "executing", not "evaluating"
06:58:43 <wli> http://wli.pastebin.com/m11fb3428
06:58:50 <Peaker> IO values may be "pure", but computations in the IO monad are not
06:59:15 <wli> Well, just give a qualified name to ghc -main-is
06:59:22 <fasta> Yeah, it's executing the IO "action".
06:59:45 <Vq^> pure values representing unpure effects perhaps
07:00:00 <yitz> wli: and? what's the error?
07:01:13 <wli>       Expected type: STRef s1 (Maybe (CircNode s1 t1))
07:01:13 <wli>       Inferred type: STRef s (Maybe (CircNode s t1))
07:01:13 <cizra> *sigh*
07:01:22 * cizra continues to be confused about impurities in Haskell.
07:01:38 <wli> (Couldn't match expected type `s1' against inferred type `s')
07:02:01 <Botje> haskell: making impossible things easy and mutable variables hard :)
07:02:23 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2454#a2454 <- an ugly draft of my go-game. the state that is passed to makeBoard and is used in onClick, it is not th same state that is latr used? becaus the board itself doesnt get updated when I click a button,just changs the text on the button
07:03:29 <yitz> wli: where?
07:03:30 <Botje> wli: I think it's failing to see the two s variables in your insert are different
07:03:34 <Peaker> cizra: (IO a) represents a potentially impure computation, but the (IO a) value itself is pure
07:03:42 <Botje> s/different/the same/
07:03:48 <mightybyte> Is there a way to build a list with different types that are all instances of the same type class?
07:04:05 <Peaker> mightybyte: yeah, existential types
07:04:20 <Peaker> mightybyte: its likely that you don't really want a type-class there, though, but simply a record of functions
07:04:30 <wli> Botje: You mean that they're the same?
07:04:44 <mightybyte> Peaker: So by existential types you mean something that uses forall?
07:04:45 <Botje> they are the same, but haskell has no way of knowing that
07:04:46 <Botje> i think
07:04:47 <Peaker> mightybyte: in which case, if your record of functions has the list item as an input arg, you can "feed" the input to all the functions before forming the list, and get rid of the existential
07:04:51 <Peaker> mightybyte: yep
07:05:11 <cizra> Peaker: What does it mean when a value is pure? I believe I know what pure computations are, but values?
07:05:22 <mightybyte> Peaker: Well here's my situation.  I used to have a data type with multiple type constructors.
07:05:49 <yitz> wli, Botje yeah, CircNode requires the *same* s for both components but Circ doesn't provide that
07:05:54 <mightybyte> Peaker: Then I got some runtime errors when I forgot to create some typeclass instances for some of the type constructors.
07:06:39 <Peaker> mightybyte: for example, if you wanted:  [forall a. Blah a => a] -- maybe you can instead use:  data BlahFuncs { func1 :: a -> Int ; ... } with:  [forall a. (BlahFuncs a, a)] -- and then maybe you can factor out the (a->) from each of BlahFunc's field types, out into:  type Blah = Blah { Int, ... } ; type BlahFuncs = a -> Blah ; [Blah]
07:06:42 <mightybyte> Peaker: So I decided to switch from a single type with multiple constructors to using a type class and multiple types that are instances.
07:06:55 <Peaker> cizra: they are unchanging and referentially transparent
07:07:00 <mightybyte> Peaker: ...thinking that this would give me compile-time checking instead of runtime checking.
07:07:41 <Peaker> mightybyte: both of these will give you compile-time errors
07:07:52 <Peaker> mightybyte: you need to use -Wall to get errors about unexhaustive pattern-matches though
07:07:59 <yitz> wli: I think you want insert to be in the ST monad.
07:08:06 <pejo> Peaker, what values ever change?
07:08:10 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2454#a2454 <- an ugly draft of my go-game. the state that is passed to makeBoard and is used in onClick, it is not th same state that is latr used? becaus the board itself doesnt get updated when I click a button,just changs the text on the button
07:08:13 <mightybyte> Peaker: Ahhh, I had forgotten -Wall.
07:08:22 <ImInYourMonad> http://www.cs.toronto.edu/~sme/presentations/cat101.pdf <- category thoery for noobs like me
07:08:22 <Peaker> pejo: the values inside IORef's, change in the IO monad
07:08:58 <mightybyte> Peaker: So what are the tradeoffs between having a single type with multiple constructors and several types that all instantiate a class?
07:09:34 <wli> Record update for the non-Haskell-98 data type `Circ' is not (yet) supported
07:09:45 <wli> That's one I've not seen before.
07:10:00 <yitz> wli: bummer
07:10:18 <quicksilver> existentials or higher ranks
07:10:34 <cizra> Peaker: Ahhh. Makes sense. Haskell has impure types, though, right? Arrays and such.
07:11:05 <yitz> cizra: no they're pure
07:11:08 <pejo> Peaker, Odd. I would have seen that as putting a new value into the IORef, not changing the old one.
07:11:11 <Peaker> mightybyte: a single type with multiple constructors is a "closed type" -- the advantage is that functions that use this type have access to all the details and can special-handle all the cases.   A single type class with many types is an "open type", in a sense, but for an open type to work you must have a "sealed interface" (the type-class) shared between them all. Functions that use this type are limited to this interface, but you can extend it with new
07:11:11 <Peaker>  types
07:11:39 <Peaker> cizra: arrays are not impure. Haskell has impure values inside impure monads
07:11:55 <Botje> ImInYourMonad: it looks okay to me
07:12:00 <wli> http://wli.pastebin.com/m6b37cd02 <-- still trouble with the existential
07:12:25 <mightybyte> Peaker: It seems like I am running into more type-level difficulties with the open type approach.
07:12:45 <quicksilver> wli: haskell's not smart enough to do an array update which "might change the s"
07:12:52 <ImInYourMonad> Botje: yeha but it doesnt work, when i click the button the internal baord isnt updatd,just the GUI
07:12:57 <quicksilver> that is, the s you bound with forall in the definition of Circ.
07:13:11 <quicksilver> wli: you just have to write it as a fresh record construction and it hshould be fine.
07:13:20 <Botje> ImInYourMonad: are you sure the takeMVar is returning?
07:13:27 <cizra> Peaker: Enlightening, thanks.
07:13:35 <ImInYourMonad> wait im dumb
07:13:39 <Botje> hmm, yes. it's the only one
07:13:50 <wli> quicksilver: Fresh record construction is already happening.
07:14:11 <quicksilver> wli: hmm, I didn't read carefully enough.
07:14:15 * quicksilver reads more carefully.
07:14:16 <Peaker> cizra: Maybe I'm being inaccurate there, but I think its a valid intuitive way to see it.  When programming in the IO monad, its pretty much the same as programming imperative languages
07:14:16 <Botje> ImInYourMonad: the printBoard button is of course pretty broken
07:14:28 <Botje> ImInYourMonad: printBoard should take the MVar instead of printing the default board :)
07:14:38 <ImInYourMonad> it works i wasnt prinitn ghte board but the functio board
07:14:46 <cizra> Peaker: .. and gives me the creeps. I'm a lot more comfortable around pure Haskell (I'm a newb)
07:15:17 <quicksilver> wli: having read more carefully, I think 'Circ' is useless.
07:15:30 <Peaker> cizra: often newbies are more comfortable in IO monad because its similar to the imperative languages they know.  Its best to be in your position :-)  Some gurus believe IO is a horrible workaround and we should have alternate ways to interact with the world that are pure :)
07:15:43 <yitz> cizra: if the IO monad gives you the creeps, you're on your way to becoming a great Haskell programmer :)
07:15:45 <quicksilver> wli: having an STRef into an unknown 's' isn't useful, because you can't use it.
07:16:30 <cizra> yitz, Peaker: My background is in maintaining old C++ applications. You can have three guesses why I'm looking into Haskell...
07:16:43 <Peaker> cizra: rewrite?
07:16:52 <Botje> need something to scrub the dirty off/
07:16:53 <Botje> ?
07:17:02 <wli> quicksilver: Well, it should be clear what I'm trying to accomplish. I guess the question I'm trying to answer is how this is carried out.
07:17:06 <cizra> Peaker: Not an option. I'm using Haskell for throwaway scripts and fun, mostly.
07:17:11 <cizra> Botje gets the cookie.
07:17:21 <Botje> yay! *chomp*
07:17:24 <yitz> wli: put insert into the ST monad
07:17:30 <quicksilver> wli: I think you need to lift out the 's' parameter  in Circ, just like you did in CircNode
07:17:40 <wli> yitz: I do that and it's a doorstop to callers.
07:18:32 <Vq^> cizra: C++ applications isn't going to seem simpler to maintain when you know Haskell :P
07:18:37 <yitz> wli: it means they'll also have to be in the ST monad. which is necessary if they are to be able to use your ST state.
07:18:46 <Saizan_> data Circ s t = ...; insert :: t -> Circ s t -> ST s (Circ s t)
07:19:36 <wli> Callers want API's like Data.Map, Data.Sequence, etc. I force use of the ST monad and it's useless.
07:19:42 <cizra> Vq^: At least i won't step into the same bucket when I have the choice.
07:19:56 <ImInYourMonad> what would b the alternatives to IO Monad?
07:20:33 <Vq^> cizra: thats very true (it might even be true regardless of language after you learned Haskell)
07:20:50 <yitz> wli: circular linked lists are immutable. To modify them in any way, you need to rebuild them from scratch.
07:21:18 <yitz> wli: so in case that is needed, represent your cll using an IntMap
07:21:25 <Saizan_> wli: until you keep references alive you can escape from the ST monad, STArray are like that too
07:21:41 <Saizan_> s/can/can't/
07:22:01 <wli> I was just thinking I'd have to use State on an IntMap plus extra crud to simulate a pointer graph.
07:22:23 <yitz> yeah
07:22:55 <wli> Control.Monad.State vs. Control.Monad.ST/Data.STRef
07:23:17 <ricky_clarkson> @users
07:23:17 <lambdabot> Maximum users seen in #haskell: 667, currently: 629 (94.3%), active: 18 (2.9%)
07:23:59 <fasta> More bots/puppets every day! ;)
07:24:00 <yitz> wli: doesn't matter, whatever state monad you use needs to be exposed to the user.
07:24:01 <Saizan_> if you use an IntMap you can put it directly into the circular list
07:24:37 <Saizan_> hiding it from the user
07:24:37 <yitz> fasta: repeat after me: i am not a bot
07:25:33 <wli> yitz: Nah, runState hands back the saved state, so you can stash that in the list header structure and be done with it.
07:25:52 <fasta> wli: The ST monad is about 20 times faster than IntMap.
07:26:02 <yitz> wli: oh, ok, you can do that.
07:26:40 <yitz> fasta: not always true, depends on what you are doing.
07:27:25 <wli> fasta: Yes. The performance implications here are doorstopping it about as badly as the monad infection bits do for ST, which sort of explains why no one has bothered writing this sort of thing.
07:27:30 <martyn4> Hi, I have likely simply question, but kind of hard to google (unsuccessful). How to get rid of rounding error in "[0, 0.1 .. 1]"? The "[0, 0.1 .. 1] :: [Rational]" kind of works, but not what I exactly want. Thanks.
07:27:32 <martyn4> > [0, 0.1 .. 1]
07:27:34 <yitz> fasta: you mean Control.Monad.State right?
07:27:35 <lambdabot>   [0.0,0.1,0.2,0.30000000000000004,0.4,0.5,0.6,0.7,0.7999999999999999,0.89999...
07:27:40 <fasta> yitz: nothing is always true if you talk like that. Ok, if you initialize an STArray with >100K elements and an IntMap with >100K elements, the STArray is 20 times faster (if you do lots of accesses).
07:27:45 <fasta> yitz: no
07:27:53 <fasta> yitz: ST /= State
07:27:53 <athos> > let (@.@) = "@.@" in (@.@)
07:27:55 <lambdabot>   "@.@"
07:28:02 <yitz> ah, IntMap vs. STArray?
07:28:12 <fasta> yitz: that's what I said.
07:28:34 <yitz> you said "ST", which in general means state
07:28:39 <fasta> wli: what is the problem with the "infection".
07:28:39 <cizra> martyn4: Well, that's a problem of floating-point arithmetics. I guess you can't easily get around it and still keep using floats.
07:28:47 <fasta> yitz: no, it doesn't.
07:28:59 <cizra> martyn4: Are you sure rational numbers are unacceptable?
07:29:01 <wli> fasta: The users want API's similar to Data.Sequence, Data.Map, etc.
07:29:04 <yitz> fasta: that's what ST stands for :)
07:29:17 <fasta> yitz: no, it doesn't. Read the paper.
07:29:19 <fasta> yitz: :)
07:29:20 <cizra> martyn4: Also, every Haskell tutorial I've read says that list building with floats is buggy.
07:29:24 <quicksilver> fasta: but if you want to share or store some older versions, the IntMap is 100K times faster :)
07:29:51 <martyn4> cizra: I'm quite a beginner, and it does not fit into my code. So I would rather like to use Double type. But might be my code is wrong and Rational are right
07:29:52 <fasta> quicksilver: yep, they do different things, but "sharing" is not a very popular thing to do.
07:30:04 <wli> fasta: Altering the users to go monadic is often beyond my power.
07:30:18 <EvilTerran> martyn4, you could do something like
07:30:24 <fasta> wli: what users?
07:30:25 <EvilTerran> > map (/10) [1..10] :: [Double]
07:30:26 <lambdabot>   [0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0]
07:30:53 <fasta> wli: you can also implement the ST interface without the ST monad, btw.
07:31:00 <cizra> martyn4: Your code is all right, floats are just so imprecise.
07:31:10 <martyn4> EvilTerran: I've actually reveled this trick, but I thought it is just workaround for something ........ simpler. But thanks.
07:31:12 <wli> fasta: Things assuming pure list computations like reverse.
07:31:26 <wli> fasta: I'm all ears.
07:31:51 <wli> fasta: The surrounding code is often too complex for me to understand etc.
07:31:59 <fasta> wli: you only need to write something (basically a memory allocator) on top of DiffArray, replace DiffArray with something fast.
07:32:18 <fasta> wli: aka, as a lot of work (I know, because I did ;) )
07:32:23 <wli> fasta: Or the monadification would backpropagate through the whole program.
07:32:25 <martyn4> cizra: by floats you mean Float and Double, right?
07:33:03 <fasta> wli: I didn't do the "make it fast" part, to be clear.
07:33:05 <wli> fasta: (Which in turn has parts I don't understand well enough to do that to, or which is too large for me to get through.)
07:34:13 <cizra> martyn4: Well, Double is more precise than Float, of course.
07:34:21 <cizra> martyn4: but in general, yes.
07:34:32 <fasta> wli: it would be nice if one could refactor the whole program to monadic style with one push on a button. But on your concrete problem, I think you know best what to do. Other than the very contrived solution I mentioned, there really isn't any.
07:35:23 <wli> fasta: If it's something I'm writing myself I mostly won't have trouble doing the whole thing monadically.
07:36:27 <martyn4> cizra: I'm just trying to do something like: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2459 , probably I need to use Rational. Anyway thanks, quite responsive ML.
07:36:31 <yitz> wli: if it's mutable, you need it to be in a monad and you must export that as part of yor interface. If you want an interface that creates modified copies, that's ok. If you want the possibility of sharing and not complete copies every time - use IntMap.
07:37:13 <cizra> martyn4: ML?
07:37:24 <martyn4> cizra: ML == Mailing LIst
07:37:48 <bremner> SML = Standard Mailing List
07:38:05 <cizra> I'm not a mailing list. you must be confusing me with somebody.
07:38:14 <yitz> Mona Lisa
07:38:54 <wli> yitz: I guess I've figured out that it takes monads top-to-bottom to avoid horrendous complexities for FIFO queues.
07:39:00 <ehird> Hmm... if (->) is implication, (,) is and, Either is or, what's not? I can figure out all the others, pretty much, apart from that...
07:39:21 <yitz> wli: how about Data.Sequence?
07:39:28 <ImInYourMonad> hmm, if you have a clickable board and then want to have the comptr and plaer mov in turns,how would you check if the player moved? just poll the board to see if it has changed?
07:39:32 <bremner> ehird: in what context?
07:39:40 <ehird> bremner: Logic in the type system.
07:39:58 <ehird> (p -> q, p) -> q        -- modus ponens, proof: \(f,x) -> f x
07:40:00 <wli> yitz: Okay, s/FIFO queue/doubly-linked lists/
07:40:23 <doserj> ehird: data Void; type Not a = a -> Void
07:40:36 <ehird> Ah.
07:40:36 <quicksilver> wli: what do you want doubly linked lists for?
07:40:47 <bremner> ehird: umm. ok. dunno about that
07:41:06 <wli> quicksilver: Splicing, reverse traversal, etc.
07:41:12 <quicksilver> wli: Data.Sequence
07:42:37 <quicksilver> reverse traversal in O(n), splicing in O(log n), or thereabouts.
07:42:39 <ImInYourMonad> fac (n+1) = (n+1) * fac n <- is that n+k patterns?
07:42:42 <wli> Well, mostly I'm just going to ignore the possibility of other people using the code and go monadic.
07:43:16 <koeien> ImInYourMonad: yes
07:43:19 <Philippa_> wli: if users actually require that type+performance, they're going to have to anyway and if they're clueful they already know it
07:43:28 <ehird> doserj: That doesn't work
07:43:35 <ehird> doserj: You can prove ((p -> q) -> (Not p -> Not q)) with that
07:43:39 <Philippa_> the question becomes: which monad(s), not whether
07:43:41 <quicksilver> wli: I think you should consider Data.Sequence more carefully before you do that.
07:43:58 <quicksilver> it's a surprisingly good balance of complexities.
07:44:23 <fasta> That's something I don't like about most programming languages: lack of data structures. I don't know a single programming language with a freely available library, which has sequences that have log n reversal (can be constant), log n concatenation + all the other standard operations.
07:44:29 <Philippa_> and yeah, unless you want a circular buffer, Data.Sequence is good
07:45:00 <quicksilver> fasta: where does haskell's Data.Sequence fail your requirements?
07:45:05 <wli> Well, one of the ulterior motives was to try to write a competitor to Dat.Sequence, but I've got other ulterior motives.
07:45:27 <ImInYourMonad> then n+k patterns are ver ugly
07:45:49 <wli> (And frankly the trouble I've been having lately with lots of things make it unlikely I'd ever get around to even attempting it.)
07:45:59 <yitz> quicksilver: fasta wants log n reversal
07:46:32 <fasta> quicksilver: in particular a way to refer to a sequence from multiple locations and changing it in one place has an effect on all of them in constant time (so, it has to be mutable).
07:46:40 <ImInYourMonad> wli and his ulteriormotivs be damned!
07:46:46 <quicksilver> fasta: IORef (Seq)
07:47:15 <yitz> quicksilver: no, fasta is trying to advocate STArray
07:47:30 <fasta> quicksilver: maybe that would have worked.
07:47:43 <wli> fasta: B+ tree with leaf (data) nodes linked into a list.
07:47:48 <yitz> hmm, but reverse is O(n) there also
07:48:02 <quicksilver> reverse is O(n), it's true
07:48:17 <fasta> quicksilver: you can implement reverse by just keeping a bit
07:48:19 <quicksilver> but partial traverses from the 'back' do not require a reversal.
07:48:20 <yitz> two Data.Sequences, one forward and one reverse
07:48:32 <quicksilver> yes, exactly, you don't need to explicitly reverse.
07:49:06 <EvilTerran> ehird, what's the proof of ((p -> q) -> (Not p -> Not q))?
07:49:21 <yitz> ah, right, reverse is O(n), but you almost never need it because you can reach the end in O(1) and traverse in reverse
07:49:24 <ehird> EvilTerran: oh, wait
07:49:27 <ehird> you can't get a Not a
07:49:31 <ehird> no, indeed you can't prove it
07:49:33 <ehird> OK, then :)
07:49:35 * ehird silly
07:49:51 <yitz> I sure hope you can't prove that
07:49:58 <ehird> yitz: Well, you CAN...
07:50:01 <ehird> \f x -> undefined
07:50:11 <ehird> ... but undefined is a proof of anything, so lets pretend it doesn't exist :-)
07:50:24 <Peaker> would it be a good idea for IO not to have support for exceptions, and instead have:  ErrorT IOError IO  for exceptions?  runErrorT could do the "catching" perhaps?
07:50:33 <Peaker> (in Haskell prime, I mean)
07:51:05 <yitz> Peaker: I would like that, but I don't think it would be too popular :)
07:51:36 <Peaker> people rightfully complain that there are too many exception handling mechanisms in Haskell :)
07:51:38 <Peaker> we can unite some of them
07:52:28 <yitz> Peaker: there is one snag - you need block to work differently, and you lose some effeciency
07:53:14 <Philippa_> Peaker: IO exceptions are a special case that deserves to live, IMO
07:53:25 <Peaker> Philippa_: why?
07:53:37 <yitz> instead of block :: IO a -> IO a, you would need startBlocking, stopBlocking :: IO (). JaffaCake told me that you would lose certain optimizations then.
07:53:41 <Peaker> hey if Haskell can eventually replace IO with FRP it would be great :)
07:53:55 <yitz> Peaker: now you're talking!
07:54:20 <Philippa_> supporting FRP-as-IO, sure. Throwing away the IO monad entirely, I'm less convinced by
07:54:58 <Philippa_> Peaker: they deserve to live because they have different characteristics (not least the ability to catch pure failures)
07:55:02 <yitz> The main question is how would you support FFI
07:55:09 <Philippa_> they're semantically distinct
07:55:38 <Philippa_> you can wrap an appropriate typeclass instance around them, sure
07:55:42 <ehird> Peaker: no IO would ruin the scripting potential
07:56:28 <cizra> What is FRP?
07:56:36 <Philippa_> now, good ways to interface different error monads at appropriate boundaries? That's always good
07:56:36 <yitz> Haskell itself could define its own interaction with the outside world natively in FRP, but you can't force C to do that
07:56:44 <Peaker> Philippa_: If FRP works, why ever use IO?
07:56:48 <Philippa_> catch-and-rethrow-in-underlying-monad
07:56:51 <Philippa_> Peaker: works for what?
07:57:05 <Peaker> Philippa_: for whatever IO works for :)
07:57:26 <Philippa_> and that's kinda the point - showing that it provides everything equivalently is a big task
07:57:55 <Philippa_> myself, I'm skeptical as to whether it can be done without performance concerns - something which is very much in the realm of IO
07:58:01 <Vq^> cizra: Functional Reactive Programming
07:58:01 <yitz> Philippa_: why can't you catch pure failures in FRP? It's an event, just as it is now in IO.
07:58:13 <Philippa_> yitz: you're mixing things up :-)
07:58:22 <yitz> how so?
07:58:22 <Philippa_> I never said that
07:58:27 <yitz> oh
07:58:31 <cizra> Vq^: Sounds like something to be read about with a team of medics sitting nearby.
07:58:38 <yitz> so what did you mean?
07:58:52 <Philippa_> yitz: two separate points, one about errors, one about FRP-replacing-IO
07:58:56 * jmcarthur wonders how the IO monad might be implemented in terms of FRP
07:59:05 <Philippa_> jmcarthur: slowly :-)
07:59:24 <Philippa_> you'd ship all your IO operations off as events
07:59:48 <yitz> jmcarthur: Peaker isn't suggesting doing that. He just claims that everything that one currently does in the IO monad could be done in FRP instead. (I think that's the claim)
08:00:09 <Philippa_> yitz: jmcarthur's not claiming Peaker suggested it
08:00:15 <yitz> ok :)
08:00:21 <jmcarthur> yitz, if that is the claim them the IO monad can be written in terms of FRP ;)
08:00:44 <Philippa_> jmcarthur: yep. Or the reverse
08:00:54 <Philippa_> thing is, the precise value of 'everything' matters here
08:01:00 <Peaker> yeah, the IO monad and its monstrous complicated semantics can be implemented in FRP, probably
08:02:10 <yitz> Peaker: don't confuse unspecified semantics with complicated semantics
08:02:43 <Peaker> yitz: you disagree that IO semantics are very complicated?
08:02:45 <dons> hey guys, here's my post on visualizing the complete hierarchical namespace
08:02:46 <dons>  http://www.reddit.com/r/programming/comments/851k6/visualising_the_haskell_universe/
08:02:50 <dons> pretty pictures. enjoy.
08:02:58 <Philippa_> yitz: to be fair, if you insist IO includes all the features GHC supports in it, it's complicated
08:03:17 <Philippa_> it's just that if you're willing to punt on that slightly, operationally it's /very/ simple
08:04:13 <wli> Actually just going over all the garbage a kernel makes available to you, or even a usefully complete subset of it, will get you a complicated interface.
08:04:16 <quicksilver> Philippa_: I think "very simple" and "monstrous complicated" mean the same thing here, unfortunately.
08:04:24 <quicksilver> it's just a question of perspective.
08:04:44 <yitz> Philippa_: mm, anything too general has "complicated semantics". Because no one really thought about it, when you try to describe the semantics after the fact it seems hugely complicated.
08:04:46 <Philippa_> quicksilver: heh. It's the punting I mentioned that makes the difference, I think
08:05:03 <quicksilver> modelling all the states that posix fd/sockets can be in and all the asynchronous signals that POSIX can send a process is monstrous complicated.
08:05:07 <quicksilver> and that's all in IO.
08:05:17 <Philippa_> yitz: to be fair, the IO monad contains a lot of things that warranted research papers
08:05:23 <quicksilver> on the other hand, a naive but entirely sufficient model of IORef / Handle IO is very simple
08:05:32 <wli> quicksilver: Or how about passing file descriptors over UNIX-domain sockets?
08:05:37 <yitz> oh of course. ground-breaking work.
08:05:48 <quicksilver> e.g. digging holes.
08:05:52 <quicksilver> ;)
08:05:52 <yitz> heh
08:06:23 <Philippa_> quicksilver: quite. FRP doesn't magically fix the "does this actually nuke anybody?" question
08:07:04 <yitz> yes, redefining select/poll and friends in terms of FRP should be done at the OS level.
08:07:08 <quicksilver> rather it poses the question "is this simple(r) semantic model good enough for you?"
08:07:21 <quicksilver> ...and it strongly implies that the proponents believe the answer is yes.
08:07:38 <johnbs> launching nukes with Haskell?  brings a whole new meaning to "unsafePerformIO"
08:08:07 <Philippa_> johnbs: that's precisely why launchMissiles is a common example of a side-effect :-)
08:08:17 <yitz> johnbs: SPJ uses that example all the time in his papers
08:08:29 <johnbs> heh, yeah, i'd forgotten that
08:08:30 <EvilTerran> unsafePerformKingInYellow!
08:10:18 <FunctorSalad_> is there some good way to implement persistent mutable local variables?
08:10:44 <FunctorSalad_> (the function already is in the IO monad)
08:10:57 <MiniCow> Can anybody explain this to me? Why can't I limit this import to these symbols? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2460
08:11:21 <FunctorSalad_> for example, to remember the time of the previous call to an "idle" callback
08:11:40 <jeffersonheard> dons: can you link to bigger images of those images on the Haskell namespace post?
08:11:50 <EvilTerran> MiniCow, "import Diving.Common.Gasses (Gas (Nitrogen, Helium))"
08:12:03 <MiniCow> Ahhh, I'll give it a go
08:12:06 <EvilTerran> MiniCow, because Nitrogen and Helium are constructors of Gas
08:13:14 <MiniCow> EvilTerran: Taa! That worked. Wasn't aware of that syntax.
08:13:31 <quicksilver> FunctorSalad_: call newIORef in some enclosing scope, pass the ref to the callback.
08:13:57 <FunctorSalad_> quicksilver: ahhh thanks
08:14:16 <quicksilver> dons: if there is one thing haskell needs, it's a better library for neatly packing those word-size-pictures
08:14:17 <MiniCow> EvilTerran: I thought importing Gas might bring all its constructors with it, but that didn't work either.
08:14:28 <quicksilver> dons: they look so much neater when they 'tuck' under the descenders.
08:14:29 <EvilTerran> MiniCow, that would be "import Diving.Common.Gasses (Gas (..))"
08:14:41 <MiniCow> Good to know
08:14:45 <jeffersonheard> n/m don, I just noticed you linked at the end of the post
08:15:04 <ski> there is no side-effects
08:20:16 <dons> jeffersonheard: woo
08:20:26 <dons> jeffersonheard: there's .dot and .svg
08:20:54 <jeffersonheard> dons: I found them, thanks
08:21:47 <javuchi> hello
08:22:00 <javuchi> what ide are you using with haskell?
08:22:12 <abbe> emacs
08:22:14 <BONUS> i think most people use vim or emacs
08:22:29 <Philippa_> BONUS: their text editor of choice, anyway
08:22:32 <BONUS> you don't really need an IDE for haskell
08:22:33 <Mr_Giraffe> javuchi: vim
08:22:35 <BONUS> yeah
08:22:36 <jeffersonheard> javuchi: vim
08:22:40 <abbe> there is also a haskell based editor named yi
08:22:46 <EvilTerran> vim or SciTE, depending on my mood
08:22:46 <javuchi> it seems good enough but i don't know how to activate autocompletion in emacs
08:22:57 <Mr_Giraffe> ick, autocompletion?
08:22:58 <jeffersonheard> javuchi: I use TextMate when editing at home.  It's got some nice things in the Haskell Bundle
08:23:09 <Mr_Giraffe> i've never been much of a fan
08:23:10 <abbe> no autocompletion for haskell in Emacs, AFAIK.
08:23:17 <fasta> BONUS: what do you mean by we don't need an IDE?
08:23:23 <bremner> emacs indentation is helpful
08:23:51 <abbe> true, any haskell indentation helpers for vim ?
08:24:08 <BONUS> fasta: well, for instance, in Java an IDE mainly helps you pump out boilerplate code
08:24:13 <drdozer1> IDE? the lack of one of the quality of intellij for Java or the ms toolset is a major issue IMHO
08:24:15 <Peaker> I really really wish I had a Haskell editor that could show me inferred type of sub-terms when I am debugging type errors
08:24:20 <BONUS> new StreamBufferedReaderFactoryFactory(newBlahbalbah
08:24:24 <Mr_Giraffe> abbe: setting up auto-indentation works easily in vim
08:24:24 <quicksilver> I use autocompletion in emacs.
08:24:25 <javuchi> is not there any IDE with autocomplementation for haskell?
08:24:27 <osfameron> Peaker: yeah, that'd be nice
08:24:29 <fasta> I am fairly sure that when someone releases an Emacs mode or even an Eclipse plugin that works efficiently and has all the bells and whistles I want, that _everyone_ would get it and use it.
08:24:36 <abbe> Mr_Giraffe, how ?
08:24:37 <quicksilver> it's not "smart" like intellij
08:24:37 <Peaker> osfameron: text is a huge obstacle, imo
08:24:39 <quicksilver> but it works
08:24:41 <abbe> quicksilver, how ?
08:24:42 <Mr_Giraffe> abbe: do you have syntax enabled?
08:24:45 <quicksilver> M-/
08:24:48 <abbe> Mr_Giraffe, yes
08:24:50 <BONUS> haskell is much more terse and you spend most of your time thinking instead of typing anyway
08:24:52 <fasta> BONUS: we could use tools, like refactoring tools.
08:24:57 <drdozer1> I want to be able to mouse-over some haskell code, see the type, perhaps run that fragment in a little interpreter session
08:24:57 <Mr_Giraffe> abbe: autoindent?
08:25:05 <ImInYourMonad> move :: (IO Int, IO Int),how do I get that out of IO? it doesnt want to aggree to x <- move
08:25:08 <drdozer1> browse the type derivation tree where it's doing things i don't understand
08:25:09 <abbe> Mr_Giraffe, let me check, I'm not a regular vim user.
08:25:12 <Mr_Giraffe> ahh, alright
08:25:17 <Mr_Giraffe> well are you on *nix?
08:25:19 <drdozer1> refactor things - inline functions, extract functions
08:25:28 <quicksilver> ImInYourMonad: you probably wanted it to be move :: IO (Int,Int)
08:25:30 <Mr_Giraffe> just :set autoindent or add "set autoindent" to ~/.vimrc
08:25:37 <BONUS> ImInYourMonad: x <- fst move; y <- snd move
08:25:37 <fasta> We don't "need it", the same way that you don't need a roof on your house ;)
08:25:40 <drdozer1> autocompletion (type sensitive, ideally)
08:25:54 <drdozer1> manage import and export lists
08:25:57 <Mr_Giraffe> autocompletion is more useful for boilerplate code
08:25:57 <abbe> Mr_Giraffe, yes, I'm on GNU/Linux. I did :set autoindent
08:26:01 <BONUS> fasta: i dont know, i dont need refactoring tools. depends on the tastes i guess
08:26:10 <Mr_Giraffe> abbe: i'll just send you my .vimrc
08:26:18 <abbe> Mr_Giraffe, after typing instance Show Cool where<CR>
08:26:19 <fasta> BONUS: it depends on how big your programs are.
08:26:22 <abbe> Mr_Giraffe, no auto indent
08:26:40 <BONUS> fasta: well i think if your programs are modular enough, you dont need big tools to manage them
08:26:59 <jeffersonheard> simple stupid question:  given a list of ["a","b","c"], there should be a fold or a scan that will render it to "a -> b -> c"
08:27:02 <javuchi> Mr_Giraffe: autocompletion is good if you want a fast search of some required function
08:27:06 <jeffersonheard> what is taht fold/scan?
08:27:07 <fasta> BONUS: sometimes there is a good reason to rename a particular field.
08:27:10 <javuchi> is there anyway to activate it in emacs?
08:27:17 <pejo> BONUS, as programs evolve they're  going to become not modular enough.
08:27:18 <drdozer1> BONUS: modules give with one hand and take with the other - you have to manage cross-module issues somehow
08:27:23 <EvilTerran> > intercalate " -> " ["foo","bar","baz"]
08:27:24 <lambdabot>   "foo -> bar -> baz"
08:27:28 <Mr_Giraffe> javuchi: i think that knowing the modules you're sing is important
08:27:30 <jeffersonheard> thanks EvilTerran
08:27:31 <Mr_Giraffe> using*
08:27:38 <EvilTerran> it's in Data.List :)
08:27:41 <jeffersonheard> I knew that I'd used it before
08:27:45 <EvilTerran> ?src intercalate
08:27:46 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
08:27:47 <Mr_Giraffe> and in using autocompletion you just rely on the computer to do it all for you, so to speak
08:27:49 <jeffersonheard> but I forgot its name
08:28:03 <drdozer1> see  - in an IDE you'd type interchalate, and it would say "would you like to import this from Data.List?"
08:28:20 <javuchi> anyone is using http://www.leksah.org/ ?
08:28:22 <Mr_Giraffe> autocompletion doesn't tell you whether or not something is a good idea to use, though
08:28:35 <drdozer1> or you'd press the "signature" modifyer and type [a]->[[a]], and it would hoogle for functions with that sig
08:28:36 <Mr_Giraffe> for example, if i type "fold" and get "foldl" and try to run that on an infinite list...
08:28:44 <Mr_Giraffe> well sure, it autocompleted just fine, didn't it?
08:28:45 <ski> abbe : some of <http://tokyoenvious.xrea.jp/vim/indent/haskell.vim>,<http://www.vim.org/scripts/script.php?script_id=1968>,<http://www.vim.org/scripts/script.php?script_id=2062> might work ..
08:28:49 <EvilTerran> drdozer1, and i'd say "no! i wanted to import that from Control.Pathological.Intercal!" :P
08:28:53 <drdozer1> Mr_Giraffe: no of course not :) but it cuts down the the space
08:29:11 <pejo> Mr_Giraffe, if you type foldl manually it's still not a good idea to run it on an infinite list.
08:29:12 <drdozer1> EvilTerran: cool - as long as that's in the searchpath the IDE knows about, it would be in the drop-down
08:29:31 <Mr_Giraffe> pejo: i know, that's my point
08:29:41 <abbe> okay ski
08:29:58 <ski> (ianavu)
08:30:05 * drdozer1 shudders at writing a haskell eclipse plugin
08:30:08 <pejo> Mr_Giraffe, so your problem with autocompletion is that it doesn't solve a different problem, that we have even without autocompletion?
08:30:13 * EvilTerran shudders at eclipse
08:30:24 <Mr_Giraffe> pejo: no, i'm saying autocompletion exacerbates the problem
08:30:30 * drdozer1 agrees with ET
08:30:45 <yitz> drdozer1: there are useful tools in an ide that are not in emacs/vim. but the opposite is also true, since most ides have an underlying editor like Notepad.
08:31:09 <quicksilver> yitz: and it's the opposite that bugs me more often
08:31:16 <yitz> overall, for power users of emacs/vim, it's not worth it.
08:31:17 <quicksilver> I suppose I'm a fairly sophisticated user of my editor
08:31:20 <abbe> ski, thanks for those scripts, I don't have that indentation script with me.
08:31:27 <quicksilver> and I've never been a particularly capable user of IDEs
08:31:30 <ski> (EvilTerran : ECLiPSe, otoh ..)
08:31:32 <quicksilver> although I played with a few.
08:31:44 <yitz> what would be nice if some really high-level haskell-aware tools were added to a real editor.
08:32:26 <wli> Philippa: The one bit of "good news" is that I think I understand a little better how to do an abstract register machine -based lazy evaluator esp. as regards control flow, and now I'm grinding at when and where dynamic allocations are needed.
08:32:38 <yitz> maybe yi will be heading in that direction...
08:32:54 <quicksilver> yitz: unfortunately yi isn't even a real editor yet :)
08:32:56 <wli> yitz: Like structure editors?
08:33:01 <quicksilver> yitz: but hopefully it is heading htat way, yes.
08:33:08 <yitz> wli: for example, yeah, nice
08:33:09 <quicksilver> yitz: are you aware of nominolo's scion project?
08:33:19 <drdozer1> quicksilver: I think coders fall into 2 camps on this - one lot work primarily with text, the other with abstractions - the latter like IDEs, the former like emacs - most people don't read black and white ascii code and see the AST and run-time :)
08:33:29 <yitz> quicksilver: doesn't ring a bell
08:33:53 <quicksilver> yitz: http://github.com/nominolo/scion/tree/master
08:34:03 <quicksilver> intended to be a library for IDE/editor bindings to use
08:34:10 <quicksilver> so they can do clever stuff with haskell code.
08:34:14 <darrenhobbs> autocompletion and automated refactorings are like powertools. You don't need a chainsaw to chop down a tree but it's faster if you do. But (like with chainsaws) it's easier to chop your leg off if you're careless.
08:34:45 <quicksilver> darrenhobbs: but in haskell we make our bridges just by folding paper, and they're stronger.
08:34:46 <flux> darrenhobbs, chainsaws, however, are lacking in the undo-area :)
08:34:50 <quicksilver> darrenhobbs: not power tools required.
08:35:00 <yitz> quicksilver: that's great - it's the infrastructure that's needed
08:35:20 <quicksilver> drdozer1: I think I know what you're saying, but I'm not sure about how you said it.
08:35:33 <quicksilver> drdozer1: I definitely work primarily with abstractions; I'm from a pure maths background.
08:35:33 <darrenhobbs> I've consistently found that communities with refactoring tools wonder how they managed without them and communities without tend to protest that they don't need them. Draw your own conclusions :)
08:35:47 <quicksilver> drdozer1: but I still write code in a text editor :)
08:35:48 <yitz> darrenhobbs: but a laser sabre is even better, which is what you get with a real editor
08:36:04 <quicksilver> darrenhobbs: sure, I was mainly just poking at a fun hole in a metaphor. Refactoring tools are great.
08:36:15 <quicksilver> darrenhobbs: but they *are* less necessary in haskell than java (to be concrete)
08:36:21 <drdozer1> quicksilver: sure, but those abstractions are more of the AST kind I would guess
08:36:40 * drdozer1 is now making wild accusations about someone he's never been to a pub with
08:36:42 <pejo> yitz, except that most of us aren't jedi's.
08:36:44 <fasta> By "IDE" I mean something which can at least do "jump to definition".
08:36:44 <Saizan_> i only miss auto-management of import lists
08:36:54 <yitz> darrenhobbs: i agree with quicksilver. those tools are nice, but a powerful as they are, it's not worth reverting to the Notepad stone age.
08:37:19 <yitz> pejo: heh, well yeah, those editors do have a steeper learning curve :)
08:37:20 <quicksilver> the thing that's always mystified me about IODEs is the waste of an few inches of horizontal space with a list of all files in the project
08:37:21 <drdozer1> Saizan_: and export lists
08:37:26 <quicksilver> (Yes, I know it can be turned off)
08:37:40 <yitz> quicksilver: speedbar
08:37:42 <quicksilver> do people really get so confused about their project they need to have the list of files taking up screen estate 100% of the time?
08:37:53 <quicksilver> I have never, ever, in my life, forgotten which files are in my project...
08:37:56 <quicksilver> or how to find them.
08:38:04 <drdozer1> quicksilver: these are usually in a panel that collapses away
08:38:09 <quicksilver> I know, I know.
08:38:19 <quicksilver> but my experience of looking over people's shoulders is they don't collapse that panel.
08:38:25 <quicksilver> it just strikes me as an odd default :)
08:38:35 <pejo> quicksilver, I don't even know 10% of the files in GHC.
08:38:35 <drdozer1> then they must have big screens, or like typing small text :)
08:38:39 <osfameron> it's vaguely handy to be able to immediately edit any file in the project
08:38:40 <yitz> drdozer1: and that feature happens to appear in all of the editors as well
08:38:44 <Petrosian> quicksilver: It helps when you're working on someone elses project
08:38:49 <osfameron> certainly I spend a lot of time finding and navigating to files in vim
08:39:02 <quicksilver> and when people try to build IDE modes in emacs the first thing they do is open that window.
08:39:07 <quicksilver> Petrosian: that's certainly true.
08:39:13 <quicksilver> Petrosian: but so does building a TAGS file :)
08:39:24 <drdozer1> IDEs come into their own in collaborative environments
08:39:48 <drdozer1> like the issue-tracking plugins to eclipse
08:39:54 <quicksilver> osfameron: navigating to files is certainly a task. But I normally know where I'm going, and if I'm looking for something, I have tags and find/grep.
08:40:11 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2461#a2461 <- how do I make tmap strcit?
08:40:12 <drdozer1> quicksilve: where as in intellij, I have ctrl-click on the symbl
08:40:13 <ImInYourMonad> strict
08:40:21 <ImInYourMonad> so it doesnt overflow at 1million elems
08:40:45 <pejo> quicksilver, find is very slow.
08:40:57 <EvilTerran> ImInYourMonad, er... why is tmap building up its result in a parameter?
08:41:08 <EvilTerran> and then reversing it?
08:41:42 <Workybob> arh
08:41:50 <Workybob> Gtk2hs's render monad is a royal pain in the ass
08:41:56 <pejo> quicksilver, I'm not saying that notepad is good, or even desirable. I'm suggesting that better tools would help us all.
08:43:10 <quicksilver> drdozer1: ctrl-click!!!! using a mouse!!!! :P
08:43:18 <quicksilver> drdozer1: M-. is a lot faster than ctrl-click.
08:43:43 <quicksilver> pejo: I don't find it so. for a sufficiently large project is it, yes.
08:43:45 <ImInYourMonad> EvilTerran_ because it is tailrecursive, not idiomatic haskell
08:43:46 <sjw> and M-* is also handy
08:44:15 <quicksilver> pejo: TAGS file is handy; admittedly no tool I use gives me a full-text index of all project files.
08:44:30 <fasta> quicksilver: how do you get a proper TAGS file? I opened a bug for a working implementation of hasktags years ago.
08:45:01 <ImInYourMonad> i never remember the strictness sntax
08:45:08 <quicksilver> fasta: I must admit, I'm mixing experience from different projects here. I have used tags files more often in C++ projects.
08:45:19 <fasta> TAGS files are a hack from before I was born :)
08:45:28 <quicksilver> fasta: my haskell projects never seem to get so big that they need them.
08:45:42 <quicksilver> they're not a hack; they're an index.
08:45:47 <quicksilver> an index is a sensible thing.
08:45:53 <quicksilver> (although it needs useful data to be useful)
08:46:36 <thoughtpolice> exuberant ctags is pretty good
08:46:40 <thoughtpolice> and has shitloads of language support
08:46:42 <thoughtpolice> but no haskell :(
08:47:08 <trofi^w> how about hasktags?
08:47:23 <thoughtpolice> IMLE, it doesn't work too well.
08:47:36 <ski> > cmap (^ 2) [0..3] where cmap f xs = cmap' f xs id where cmap' f [] k = k []; cmap' f (x:xs) k = cmap' f xs (\ys -> k (f x : ys))  -- tail-recursive
08:47:37 <fasta> @go IMLE
08:47:37 <lambdabot>   [0,1,4,9]
08:47:37 <lambdabot> No Result Found.
08:47:59 <trofi^w> @dict-all IMLE
08:47:59 <lambdabot> Unknown command, try @list
08:48:11 <vegai> in my leery e-pinion?
08:48:24 <thoughtpolice> trofi^w: in my limited experience
08:48:33 <ImInYourMonad> is there a good wa to make an input loop in gtk2hs? i just use recursion and it zooms up the memory use
08:48:43 <fasta> Is there anyone with unlimited experience?
08:48:47 <trofi^w> ah
08:49:02 <ski> > cmap (^ 2) [0..3] where cmap f xs = cmap' f xs id where cmap' f [] k = k []; cmap' f (x:xs) k = cmap' f xs (\ys -> k (f x : k ys))  -- meep
08:49:03 <lambdabot>   [0,1,0,4,0,1,0,9,0,1,0,4,0,1,0]
08:49:17 <trofi^w> i tried hasktags once actually
08:49:34 <trofi^w> and it worked for my simplest use cases
08:49:35 <ehird> What happened to that YHC->Javascript thingy? Is it still being worked on?
08:50:13 <quicksilver> ImInYourMonad: what is an input loop? I don't understand your question.
08:51:33 <ImInYourMonad> quicksilver: well i gues si shouldnt have one,i meant a mainloop btw
08:51:33 <ImInYourMonad> gameloop
08:52:34 <ImInYourMonad> while gamenotfinished: dostuff
08:55:04 <BONUS> ImInYourMonad: you mean like main = doStuff >> when gamenotfinished main
08:56:35 <quicksilver> ImInYourMonad: with GUI libraries there is always the choice about who controls the main loop
08:56:44 <quicksilver> lots of GUI libraries want ot run the main loop.
08:57:06 <rmoss> is there an easy way to cons a space onto a list of strings except the last element?
08:58:39 <quicksilver> > intercalate " " ["hi","there"]
08:58:40 <lambdabot>   "hi there"
08:59:00 <ImInYourMonad> if i hav: case x of Finished -> ; and there iw ant to do nothing but exit the loop,what do i do? return () ?
08:59:04 <rmoss> thanks
08:59:24 <BONUS> ImInYourMonad: yah
08:59:34 <ski> > intersperse ' ' ["hi","there"]
08:59:35 <lambdabot>   Couldn't match expected type `Char' against inferred type `[Char]'
08:59:41 <quicksilver> return () doesn't exit any loops
08:59:43 <quicksilver> it just does nothing.
08:59:55 <quicksilver> I need to see a bit more code to see what you mean by 'exit the loop'
08:59:56 <quicksilver> :)
09:00:01 <ski> ah, right
09:02:16 <CosmicRay> @hoogle mkIOError
09:02:17 <lambdabot> System.IO.Error mkIOError :: IOErrorType -> String -> Maybe Handle -> Maybe FilePath -> IOError
09:02:47 <bmh> IP addresses speak volumes.
09:03:43 * wli suspects there needs to be something like "Why LR parsing matters" akin to "Why FP matters."
09:03:49 <mreha> how does one go about combining every element in one list with every element of another?
09:03:56 <mreha> like a cartesian product
09:04:07 <ImInYourMonad> BONUS: yes like that
09:04:08 <vixey> mreha: liftA2 (+)
09:04:10 <wli> [(x, y) | x <- xs, y <- ys]
09:04:11 <bmh> [f x y | x <- lst, y <- lst]
09:04:19 <quicksilver> > [ (x,y) | x <- [1,2,3], y <- [4,5,6]]
09:04:21 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
09:04:35 <bmh> oops -- missed "another"
09:04:35 <mreha> immense
09:04:47 <trofi^w> > return (,) `ap` [1,2,3] `ap` [4,5,6]
09:04:48 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
09:05:02 <mreha> these list comprehensions are lazy right?
09:05:07 <Saizan_> > sequence [[1,2,3],[4,5,6],[7,8,9]]
09:05:09 <lambdabot>   [[1,4,7],[1,4,8],[1,4,9],[1,5,7],[1,5,8],[1,5,9],[1,6,7],[1,6,8],[1,6,9],[2...
09:05:20 <trofi^w> > return (,) `ap` [1..] `ap` [4..]
09:05:21 <lambdabot>   [(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(1,11),(1,12),(1,13),(1,14),(1,...
09:05:24 <wli> > liftA2 (,) [1..3] "abc"
09:05:25 <lambdabot>   [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
09:05:29 <bmh> > [(x,y) | x <- [1..], y <- [1..]]
09:05:30 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(1,11),(1,12)...
09:05:33 <Saizan_> mreha: yes
09:05:47 <CosmicRay> @hoogle ioErrors
09:05:47 <mreha> boyakasha
09:05:47 <lambdabot> Control.Exception ioErrors :: Exception -> Maybe IOError
09:05:48 <ski> > liftA2 (,) [0..] []
09:06:35 <ImInYourMonad> quicksilver: so does gtk2hs want to run the mainloop?
09:07:00 <quicksilver> ImInYourMonad: I believe so, I've never used it. I expect the docs say.
09:07:39 <Mr_Giraffe> :t liftA2
09:07:46 <Mr_Giraffe> @type liftA2
09:07:49 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
09:07:55 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
09:09:27 <mreha> my syntax highlighter always makes apostrophies a different colour, what are they used for in haskell?
09:09:30 <mreha> i've never had to use one
09:09:36 <mreha> backticks maybe
09:09:45 <BONUS> mreha: they have no special meaning in haskell
09:10:18 <BONUS> > let conanO'Brien = 3 in conanO'Brien
09:10:19 <lambdabot>   3
09:10:32 <ski> > '"' `elem` "'"
09:10:33 <lambdabot>   False
09:10:43 <mreha> my eyes!
09:10:46 <vixey> lol ski
09:11:01 <bmh> mreha: infix
09:11:15 <mreha> '"' as appoosed to "'"
09:14:24 <ski> Evening was drawing near.
09:14:28 <jpcooper> could someone tell me how to get the system time, please?
09:14:42 <vixey> @hoogle system time
09:14:43 <lambdabot> No results found
09:14:46 <vixey> impossible
09:15:03 <jpcooper> impossible?
09:15:57 <jpcooper> @hoogle time
09:15:57 <lambdabot> package time
09:15:57 <lambdabot> module Data.Time
09:15:57 <lambdabot> Data.Time.LocalTime data TimeOfDay
09:17:30 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2463#a2463 <- so again how do I make tmap strict?
09:19:13 <ImInYourMonad> tmap' f (x:xs) acc = tmap' f xs (f x `seq` f x : acc)
09:19:24 <ImInYourMonad> seems to work at leats but not sure it is what i want
09:19:28 <ImInYourMonad> but still voerflows
09:19:51 <dolio> Those are two different f x.
09:20:09 <ImInYourMonad> so how do I do it?
09:20:24 <dolio> let fx = f x in fx `seq` fx : acc
09:21:57 <ImInYourMonad> tmap' f (x:xs) acc = tmap' f xs (let fx = f x in fx `seq` fx : acc)
09:22:00 <ImInYourMonad> still vorflows
09:22:13 <ski>   (: acc) $! f x
09:22:15 <ski> please
09:22:15 <dolio> Yeah, that isn't surprising.
09:22:21 <bmh> if I'm exposing multiple modules in a cabal package, do I enumerate all of the modules on one line in the cabal file (comma delimited?) or one per line?
09:23:12 <dolio> What are you calling tmap on?
09:24:33 <ImInYourMonad> sum $ tmap (^2) [1..1000000],r or wait lol it could be sum that is overflowing obv
09:24:51 <dolio> It probably is.
09:25:27 <BONUS> try foldl' (+) 0 . tmap (^2) $ [1..1000000]
09:26:43 <ImInYourMonad> yeah works
09:27:30 <vixey> try to think of something interesting to program
09:27:39 <vixey> I am...
09:31:42 <BONUS> exceptions from pure code: are they ever warranted?
09:31:55 <ImInYourMonad> vixey: a regulator for a chicken-staircase
09:31:55 <BONUS> today's topic, with us in the studio, residents of #haskell
09:32:08 <vixey> BONUS: I read that exceptions let you write programs that are otherwise impossible
09:32:15 <ImInYourMonad> BONUS: when calling fib with negative n?
09:32:23 <vixey> and there was some SML code that was far too complex
09:32:28 <BONUS> hmm
09:32:54 <conal> vixey: usually impossible == assumptions
09:32:56 <vixey> you know how there's {(),_|_} and you can not write a function ()/_|_ |--> _|_/()
09:33:16 <BONUS> i mean more like throwing pure exceptions with the intention of them being caught
09:33:18 <vixey> conal, I mean topologically there is some argument about which functions are continuous and only those are expressible
09:33:19 <BONUS> yeah
09:33:31 <quicksilver> BONUS: No.
09:33:41 <vixey> I should really find the page if I can.. because it's really not something I understood myself
09:34:04 <conal> vixey: so exceptions somehow enable breaking (Scott) continuity?
09:34:15 <vixey> @go when is a functional program not a functional program?
09:34:16 <lambdabot> http://citeseer.ist.psu.edu/253319.html
09:34:17 <quicksilver> conal: they certainly do.
09:34:21 <Taejo> :t unfoldr
09:34:21 <BONUS> my opinion right nao is: i/O exceptions = good, exceptions from pure code = don't bother
09:34:21 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
09:34:26 <vixey> & http://homepages.inf.ed.ac.uk/jrl/Research/whenfun.sml
09:34:38 <quicksilver> conal: they also convert _|_ into multiple distinguishable things
09:34:39 <vixey> Conal, I think that's what he was saying.. but I didn't study it in much detail
09:34:47 <quicksilver> conal: or "semi-distinguishable".
09:34:59 <conal> vixey: i think i reviewed that paper.  will re-read.
09:35:02 <vixey> it's interesting to note that  error  is pure, but catching and exception is IO
09:35:08 <ImInYourMonad> vixe: age? if you ar 19 ou know a lot about math
09:35:10 <vixey> I only noticed that when James Iry mentiode it
09:35:28 <conal> vixey: yes, i think that's exactly why we cannot catch errors in pure code.
09:35:45 <conal> because we keep our semantic domains simple by identifying errors with bottom.
09:35:58 <BONUS> i sort of decided not to cover dealing with exceptions from pure code in LYAH and im wondering if it was the right decision
09:37:02 <conal> BONUS: if you're teaching *functional* programming, exception-handling is probably not relevant.  for haskell programming, though, it is.
09:37:12 <darrenhobbs> my background is java, but in my projects there are generally 2 types of exception: Bad Programmer (you wrote it wrong) or Bad Environment (dodgy user input, lost network connection etc)
09:37:34 <BONUS> conal: i write about I/O exceptions
09:37:42 <quicksilver> conal: somewhat a question of naming, though.
09:37:45 <ImInYourMonad> @djinn String -> String
09:37:45 <lambdabot> Error: Undefined type String
09:37:48 * ski saw some code that computed modulus of continuity with exceptions
09:37:57 <ImInYourMonad> @djinn Int -> Int
09:37:57 <lambdabot> Error: Undefined type Int
09:38:00 <quicksilver> conal: you could teach the use of Left/Right and point out that it is very like exception handling.
09:38:01 <ImInYourMonad> how?
09:38:04 <vixey> ski modulus of continuity ? that sounds like a sci-fi term
09:38:12 <conal> quicksilver: definitely.  and Maybe before Either.
09:38:14 <bmh> ugh. cabal appears to be broken. It alerts me that it's "Resolving dependencies..." and then dies a few minutes later without an informative error
09:38:16 <quicksilver> conal: whether it "is" exception handling is a just a notion of naming.
09:38:26 <conal> quicksilver: agreed.
09:38:34 <ski> vixey : it's in analysis :)
09:38:46 <BONUS> basically i say: I/O exceptions are cool but don't throw exceptions from pure code, use haskell's expressive type system (Maybe, Either) to represent computations that can fail
09:38:50 <quicksilver> vixey: "ski modulus of continuity" <- that sounds like a an advanced winter sports measure!
09:39:05 * conal chuckles
09:39:12 * ski grumbles
09:39:13 <quicksilver> BONUS: I only use IO exceptions when I need their asyncrhony / cross thread behaviour.
09:39:22 <vixey> sorry ski :p
09:39:27 <BONUS> hmm ah
09:39:27 <ski> (np)
09:39:28 <quicksilver> BONUS: within one thread, for conventional failure, I prefer ErrorT IO
09:39:30 <chanr> hi girl
09:39:42 <quicksilver> or MonadError m, MonadIO m => M
09:39:42 <ski> hi boy
09:39:46 <mauke> hi chanr
09:39:50 <chanr> )
09:39:54 <BONUS> ErrorT is cool yeah
09:40:23 <BONUS> i'll offer it as a better solution to I/O exceptions when i cover monad transformers
09:40:41 <quicksilver> fair enough.
09:40:45 <ski> (.. anyway .. then Escardo computed the modulus without exceptions)
09:40:55 <TomMD> BONUS: Where do you teach?
09:41:03 <vixey> well I don't know what it means
09:41:13 <BONUS> TomMD: haha i dont teach, i have this 'lil online tutorial
09:41:17 <BONUS> im an undergrand myself
09:41:18 <Baughn> Can I assume there are Deep Reasons why functor/applicative/monad can't at this point (in base-5, say) be refactored to work the way they logically ought to work? Eg. making ap = <*>, liftM = fmap, return = pure and so on?
09:41:28 <BONUS> s/grand/grad
09:41:39 <vixey> Baughn: I think it's because typeclass dispatch isn't expressive enough
09:41:39 <Baughn> (And, most importantly, adding the correct subclassing)
09:41:39 <quicksilver> Baughn: just annoying historical ones.
09:41:40 <dons> the visualisation post needs upmods! http://www.reddit.com/r/programming/comments/852l2/visualising_the_haskell_universe/
09:41:42 <ImInYourMonad> BONUS: so if you have a fucntion that onl takes positive integers or zero, you would 1. leave it to the user to not pass in negativ nrbs, 2. return Left "Negative input" or Right Int ?
09:41:52 <quicksilver> Baughn: it would technically break backwards compatibility.
09:41:55 <vixey> Baughn: afaict it's near impossible to do subtyping well
09:42:22 <quicksilver> Baughn: and some people get annoyed by the redundancy in the method defns.
09:42:25 <Baughn> quicksilver: Okay. So, with base-4 there's now a mechanism that allows us to break backwards compatibility while maintaining a compatibility layer, so it could be done in base-5?
09:42:29 <gwern> @seen dons
09:42:30 <lambdabot> dons is in #concatenative, #arch-haskell, #darcs, #yi, #xmonad, #ghc and #haskell. I last heard dons speak 50s ago.
09:42:32 <BONUS> ImInYourMonad: i would probably leave it to the user not to pass in negative numbers. and when i say user, i mean like the programmer using my library
09:42:38 <gwern> oh
09:42:41 <BONUS> otherwise i'd check for negative beforehand or use Either
09:42:44 <quicksilver> Baughn: I would be in favour of it.
09:42:50 <Baughn> quicksilver: Yes, well, I find that cross-posting is superior to multi-posting
09:42:53 <gwern> dons: btw, have you noticed that the rss comments for RWH seem to be broken links?
09:43:13 <dons> mmm
09:43:15 <dons> nope
09:43:29 <Baughn> quicksilver: You'd have a much better chance than me at having it accepted, too, so hop to it. ^_^
09:43:56 <gwern> well, the rss feed for one particular comment links to http://book.realworldhaskell.org/read/deftypes.html#x_UC1?comment=9514&uuid=bdeacf7753ad4cc29653
09:44:00 <ski> (BONUS : don't forget to mention that the `Error e' constraint is evil, though ..)
09:44:01 <gwern> which looks right, but is very much 404
09:44:15 <gwern> dons: and the links seem to've been broken for at least several days now
09:44:19 <BONUS> ski: will do!
09:44:33 <dons> gwern: send a post to the book mailing list
09:45:02 * ski has used exceptions of type `[Integer]' ..
09:45:46 <TomMD> In a network library, the code that takes a layer 3 header and produces the pseudo header for layer 4 checksumming (UDP, TCP), where would you put the routine?  In the L3Header typeclass or L4Header?
09:46:14 <TomMD> I haven't seen a layer4 need a different type of pseduo header yet.
09:46:41 <TomMD> So I think it would be safe (and reduce redundancy) to have this routine as part of class L3Header.
09:47:06 <quicksilver> why is L3Header a typeclass?
09:47:25 <fasta> Regarding the IDE: TomMD has a perfect example: a good IDE helps people discover APIs. With a good IDE, nobody would care where TomMD would put it.
09:48:13 <TomMD> quicksilver: Because I like it that way.  There are many layer3 headers and sometimes (usually) you don't care if your looking at IPv4 or IPv6.
09:48:17 <quicksilver> I don't think a good IDE should be a crutch to base poor design on.
09:48:35 <BONUS> also a good tool for discovering APIs: a web browser
09:48:39 <TomMD> So with a typeclass your routines can accept both without a bunch of if() statements or #ifdef like in most C code I see.
09:48:46 <quicksilver> TomMD: sure, just trying to understnad your model so I can answer your question.
09:49:01 <Nafai> quicksilver: It shouldn't be a crutch.  But an IDE with great navigation helps with looking through code and seeing how things fit together
09:49:27 <TomMD> quicksilver: Sure.  So the most obvious routines of L3Header are srcAddress and dstAddress  - I exepect the average user to need only those and nothing else.
09:49:53 <fasta> BONUS: that's a horrible tool, imho.
09:50:11 <quicksilver> TomMD: if the code works on all layer 3 packets I'd make it work on all layer 3 types
09:50:11 <TomMD> quicksilver: But any user looking at headers is already non-average, so there will certainly be other capabilities.
09:50:19 <quicksilver> it doesn't sound like it needs to know about layer 4 stuff to work.
09:50:35 <HugoDaniel> is there a fold without an initial value ?
09:50:45 <fasta> quicksilver: it sounded a bit like an arbitrary choice.
09:50:47 <centrinia> foldl1, foldr1
09:51:12 <TomMD> quicksilver: Sounds good.  I'm just worried that some L4 protocol will show up that builds the pseudo headers differently than TCP/UDP do (I'm checking what SCTP does now).
09:51:29 <Baughn> TomMD: But hang on, with typeclasses the actual type is (ignoring existentials for the moment) usually decided at compile-time. How does that mesh with an application that should handle multiple protocols simultaneously?
09:51:34 <BONUS> idk, i think browsing http://www.haskell.org/ghc/docs/6.10.1/html/libraries/ for instance or hackage is a good way to discover APIs and stuff
09:51:57 <Baughn> TomMD: Existentials might make sense in this case, granted, but I think I'd prefer a simple ADT
09:54:07 <TomMD> Baughn: Not sure if I understand your issue.  This is a library and it allows people to build programs that handle, for example, IPv4 and IPv6.
09:54:26 <Baughn> TomMD: Well, maybe there isn't one. Can I see the API?
09:54:47 <TomMD> Baughn: So if you want to build a routine that says: buildDummyHeader (L3Header h, L3Address a) => a -> a -> h     You might have a chance.
09:55:10 <TomMD> Baughn: Soon enough it will be on Hackage.  Probably end of today.  I ment to have it a week ago but you know how life goes.
09:55:49 <Baughn> Right, I'll comment after seeing it, then
09:55:56 <Baughn> Assuming I haven't fallen into a coma by then
09:56:03 <quicksilver> TomMD: well, the alternative would be "buildDummyHeader :: L3Address -> L3Address -> L3Header"
09:56:03 <TomMD> I'll send you a note when I get it up.
09:56:14 <Baughn> That's probably for the best
09:56:46 <TomMD> quicksilver: But then when someone makes IPv8 or a layer 4 protocol XTP, or adds SCTP support then I have to rework those data types.
09:56:52 <quicksilver> where presumably data L3Address = IP4Addr ... | IP6Addr ... | WeirdNetworking ...
09:56:57 <quicksilver> yes, precisely.
09:57:22 <TomMD> I dislike the closed nature of data types on things I feel should be extendible by third parties.
09:57:25 <Baughn> You'd have to add code /somewhere/ to support them
09:57:45 <TomMD> Baughn: But if the user can avoid touching the libraries and just _extend_ them then that is good.
09:58:06 <Baughn> TomMD: I suppose. I /can/ get what I want using existentials anyway, so I have nothing to complain about.
09:58:28 <BONUS> TomMD: i'd suggest you take a look at http://tinyurl.com/gtx86 this is a paper from simon marlow on extensible hierarchical exceptions in haskell
09:58:28 <TomMD> I guess I don't see what my solution lacks that you would otherwise have.
09:58:37 <BONUS> but it looks like it could be used for what you're doing to
09:58:42 <BONUS> too
09:58:58 <TomMD> yes, I've got it.
09:59:03 <Baughn> TomMD: As I said, I'd have to see the code to be sure, but basically what I want is dynamic typing
09:59:16 <Baughn> Arguably existential quantification is a better way to go about that
09:59:34 <TomMD> Baughn: Ok, well I'll release soon, send you a note, and perhaps a version 0.1.x will follow closer than I intended.
10:05:02 <ehirdghost> If I started a movement to get [N..M] not to include M, how much support would I get? :-P. Dijkstra would approve.
10:05:21 <opqdonut> hehe
10:05:26 <Baughn> ehirdghost: Ah, none. It'd break way too much code, for no good reason.
10:05:33 <Baughn> Plus, the syntax is [1..3], not [1..3)
10:05:34 <bmh> [N..M] includes M. [N..M) does not
10:05:47 * bmh high-fives Baughn
10:05:58 <ehirdghost> Okay, make [N..M) work, then ;-)
10:06:08 <sjw> ehirdghost: Isabelle has [_<.._] and [_..<_],  Just sayin
10:06:16 <osfameron> would (N..M) include neither N nor M ?
10:06:28 <Baughn> osfameron: Yep
10:06:41 <Baughn> Especially fun with continuous sets
10:07:09 <bmh> does cabal have an option to make it verbose?
10:07:17 <Baughn> -v
10:07:22 <bmh> that prints the version number
10:07:34 <bmh> rather -V does that
10:07:34 <Baughn> No, "cabal <operation> -v"
10:07:37 <bmh> ok
10:07:37 <ehirdghost> bmh: printing the version number is verbose, no? :-)
10:08:16 <bmh> darn. No additional useful output. "Resolving dependencies..." and then it just spins its wheels
10:10:24 <Saizan_> bmh: are you using cabal-install-0.5.* with ghc-6.10 ?
10:11:15 <bmh> The Glorious Glasgow Haskell Compilation System, version 6.10.1. cabal-install version 0.5.2 using version 1.4.0.2 of the Cabal library
10:11:21 <Saizan_> ok
10:11:27 <Saizan_> known bug then
10:11:33 <bmh> there seem to be a lot of those
10:11:36 <Saizan_> you need to upgrade to 0.6.*
10:11:37 <bmh> like bug #2204
10:22:21 <hcube> hi! I'm working on a 3d render engine in haskell. Should i create a wiki page for it? but i'll release the code later (in 2 weeks under GPLv3) but now i'd like to promote it a but with some screenshots :)
10:23:06 <quicksilver> I think you can make a wiki page for that.
10:23:10 <maltem> hcube: Sure, we all love pretty screenshots
10:23:12 <quicksilver> although I don't know if image uploading is working
10:23:17 <bmh> we also love source code
10:23:18 <quicksilver> someone said file uploads were broken?
10:23:20 <quicksilver> but try it.
10:23:36 <maltem> quicksilver: I think there was some mail about uploads being fixed
10:24:00 <maltem> by raising the upload file size limit
10:24:35 <quicksilver> good.
10:24:37 <hcube> the code is messy now
10:25:01 <bmh> so? my code looks like crap and last night some people here helped me improve it.
10:25:07 <hcube> i have to cleanup a bit before release it
10:25:10 <bmh> don't be afraid :-)
10:25:28 <hcube> ok
10:25:41 <hcube> where should i put the code?
10:25:46 <hcube> code.google.com?
10:25:51 <hcube> svn or darcs?
10:26:04 <BONUS> how about hackage?
10:27:04 <hcube> not now
10:27:16 <hcube> later for a stable version
10:27:22 <quicksilver> you can apply for an account on haskell.org
10:27:28 <bmh> there are plenty of things on hackage labeled as 'experimental'
10:27:33 <quicksilver> or you can use google, or github, or whatever suits you
10:27:41 <bmh> or bitbucket
10:27:53 <hcube> bmh: ok but it will be ready for relase in 3 weeks
10:28:03 <wchogg> I'll throw out my vote for patch-tag.com
10:28:21 <bmh> wchogg: what's that?
10:29:46 <wchogg> bmh : It allows you to host open source darcs projects rather conveniently.  I've got a few of my hackage releases based off of it.
10:30:12 <bmh> wchogg: Call me a blasphemer, but I have a thing against darcs.
10:31:36 <wchogg> bmh : I'll try to temper my abject horror. ;)
10:32:23 <hcube> first i create the wiki page :)
10:33:18 <wchogg> If you _do_ like darcs though, I'd recommend patch-tag.
10:34:38 <bmh> ugh. cabal lies!
10:34:48 <bmh> I'm trying to cabal-install bootstrap and it claims I don't have parsec
10:37:43 <conal> dons: i was looking at Data.DList yesterday, and it occurs to me that some of the definitions could be made prettier with a bit of semantic editor combinator magic.  particularly, if you define inDL = unDL ~> DL, and inDL2 = unDL ~> inDL.  For instance, 'cons x = inDL ((x:).)' and 'append = inDL2 (.)'.
10:37:56 <Saizan_> bmh: i guess you've parsec-3 instead of 2, you can use the script that's in the darcs repo, which avoids that check
10:38:09 <conal> dons: snoc is bit less convenient: 'snoc = flip $ \ x -> inDL (. (x:))'
10:38:14 <bmh> Saizan_: can you link me?
10:38:39 <vixey> cons x = ((x:).) append = (.) = (++)
10:38:47 <vixey> that's what I use
10:39:04 <vixey> it seems odd to newtype, but I guess that's in order to get typeclass dispatch to do something
10:39:06 <Saizan_> bmh: http://darcs.haskell.org/cabal-install/
10:40:17 <Saizan_> bmh: oh, wait, i'm not sure that change has been pushed
10:40:32 <bmh> aw.. but I'm already 447 patches in!
10:41:08 <bmh> and yes, I do have parsec 3
10:42:19 <Saizan_> bmh: however, if i'm right, you just need to comment out dep_pkg "parsec" "2\."
10:45:18 <bmh> Saizan_: looks like it's working, thank you
10:47:20 <bmh> odd. cabal-install 0.5.2 and lib 1.4.0.2 are still coming up. I deregistered the old version of cabal-install and yes, I've restarted my shell
10:51:30 <Saizan_> bmh: maybe the old one is installed somewhere else like /usr/local/bin ?
10:51:40 <Saizan_> bmh: which takes precedence?
10:51:56 <bmh> Saizan_: correct again.
10:52:04 <bmh> I'm going to go out on a limb and blame Debian
10:52:30 <hcube> here is the page of my render stuff: http://www.haskell.org/haskellwiki/LambdaCubeEngine
10:52:49 <bmh> cool
10:55:21 <conal> vixey: yes, i think the newtype is to allow instances (Monoid, Functor, Applicative, ...)
10:56:19 <bmh> Saizan_: do you have a suggestion for compelling it to use the correct version?
10:56:46 <Saizan_> bmh: i'd just rm the old one
10:57:21 <Saizan_> bmh: or you can put ~/.cabal/bin on the front of your PATH
10:57:28 <Saizan_> bmh: or both
10:57:35 <sinelaw> @seen Peaker
10:57:35 <lambdabot> Peaker is in #haskell-blah and #haskell. I don't know when Peaker last spoke.
10:58:42 <blueonyx> hi
10:59:01 <Eridius> how do I ask darcs for a list of all patches from a specific author?
11:00:12 <blueonyx> are there any pointers to something like "sublanguages" in haskell, like in ruby? maybe even regarding chemistry?
11:01:01 <bmh> hrm.. still hanging on resolving dependencies
11:01:16 <bmh> with cabal-install version 0.6.2 using version 1.6.0.2 of the Cabal library
11:01:27 <lament> blueonyx: sublanguages are what Haskell is all about!
11:01:51 <blueonyx> okay
11:01:51 <lament> but chemistry?.. does hackage have anything?
11:01:54 <MyCatVerbs> @index Seq
11:01:54 <lambdabot> bzzt
11:02:13 <lament> nothing on hackage :(
11:02:59 <gwern> Eridius: look at the darcs manual for the --match stuff
11:03:07 <Eridius> gwern: manual? ugh.
11:03:20 <gwern> iirc it'd be something like darcs changes --match "author 'gwern'"
11:03:28 <Eridius> srsly? bah
11:03:33 <gwern> or you could just grep I suppose
11:03:40 <gwern> or parse the xml output
11:03:52 <Eridius> hrm, "author kevin" works, but "author kevin@sb.org" doesn't
11:04:01 <jmcarthur> Eridius, why the hostility to RTFA?
11:04:06 <gwern> probably need an escape
11:04:06 <Eridius> oh "author kevin@sb.org" works too, but not "author 'kevin@sb.org'"
11:04:15 <Saizan_> bmh: that's quite odd, what commands are you trying exactly?
11:04:22 <bmh> sudo cabal install quickcheck -v
11:04:24 <Eridius> jmcarthur: because the `darcs changes -h` didn't describe the --author flag as using a custom syntax that requires the manual
11:04:36 <gwern> Eridius: match has some oddities
11:04:42 <Eridius> err, the --match flag
11:04:48 <Saizan_> bmh: sudo cabal --version ?
11:05:02 <bmh> oh doh.
11:05:06 <bmh> sudo uses a different path
11:05:08 <gwern> and by oddities I mean I tore my hair out over them when writing filestore
11:05:16 <Saizan_> bmh: yeah, it uses root's one
11:05:41 <jmcarthur> Eridius, you mean it doesn't just take a pattern like it says?
11:05:58 <bmh> let there be light!
11:06:10 <Eridius> jmcarthur: it doesn't define "matches PATTERN" as using a custom syntax, I assumed (obviously incorrectly) that it was doing a glob pattern
11:06:27 <FunctorSalad_> sorry, maybe a stupid question... once I've uploaded a repo to my code.haskell.org account via ssh, how do I make the repo publically accessible over http?
11:06:29 <Saizan_> bmh: also, i'd suggest "cabal install --global --root-cmd=sudo quickcheck", so that only actually copying the files in the final location is done with root privileges
11:06:46 <Eridius> you can define the root-cmd in your .cabal/config file
11:07:09 <Saizan_> FunctorSalad_: you've to put it under public_html/ if it's not a "project"
11:07:18 <FunctorSalad_> Saizan_: thanks
11:07:53 <jmcarthur> i would have expected a regex
11:08:06 <Eridius> jmcarthur: the next command is --patch which has the same doc string but using REGEX instead of PATTERN
11:08:09 <jmcarthur> not saying it is unreasonable to expect a glob, mind you
11:08:13 <Eridius> which is why I assumed --match meant glob, as that's the usual counterpart to regex
11:08:14 <jmcarthur> ah
11:08:21 <jmcarthur> yeah, that is a reasonable guess then
11:08:22 <Eridius> and the most common meaning of PATTERN
11:08:45 <blueonyx> is there something for structural matching on graphs?
11:08:49 <bmh> oh shit.
11:08:59 <bmh> rm -rf .cabal/ instead of rm -rf cabal/
11:09:20 <Saizan_> hah
11:09:28 <Saizan_> you shouldn't have lost much anyway
11:09:47 <gwern> Eridius: no, match has its own very very special syntax
11:09:52 <Saizan_> the user installed packages are under .ghc
11:09:54 <gwern> (you really need to look at the manual)
11:10:14 <gwern> (the date stuff is even more complicated!)
11:10:22 <jeffersonheard> are there any complicated examples of Grapefruit out there?  I'd like to re-implement a large application using it, but I've not seen anything that describes how to integrate not just GUI, but also other IO-actions into the mix
11:10:30 <Eridius> gwern: I'm complaining that the usage string made no indication that it was a custom syntax
11:10:49 <bmh> jeffersonheard: there are red grapefruits, yellow grapefruits and white. The red ones are tastiest.
11:11:19 <jeffersonheard> bmh: thanks.  I'm looking for highly reactive grapefruits rather than tasty ones
11:12:19 <gwern> Eridius: ok, file a bug then
11:12:48 <jeffersonheard> case in point.  the application I'm writing is *like* google maps. Occasionally, the loaded portion of the map scrolls off the screen, and the application has to download new tiles from the web.  Can I handle this as part of my circuit?
11:14:30 <Eridius> hrm, is there any way to easily say "reverse this patch" without unrecord (since the patch has already left my repo)?
11:14:43 <Eridius> I want to generate a new patch that reverses the changes made in an old one
11:14:49 <Saizan_> Eridius: rollback
11:15:01 <Eridius> ahh
11:17:04 <blueonyx> lament, can you point me to any introduction to how haskell is all about sublanguages?
11:17:28 <lilac> blueonyx: programming is all about sublanguages
11:17:40 <blueonyx> ah :(
11:17:41 <gwern> DSLs you mean?
11:17:50 <lilac> we build abstractions and program against them (SICP's pretty good at covering this)
11:18:01 <blueonyx> gwern, yea
11:19:11 <blueonyx> ah that was the keyword .oO(http://www.haskell.org/haskellwiki/Research_papers/Domain_specific_languages)
11:19:32 <lament> blueonyx: http://augustss.blogspot.com/2009/02/regression-they-say-that-as-you-get.html
11:19:32 <blueonyx> thanks
11:22:28 <blueonyx> oh nice
11:23:49 <kunley> Emacs haskell-mode in the inf-haskell buffer shows the result of evaluation twice. It's a bit annoying. Why is it so?
11:24:24 <jeffersonheard> is there a relatively easy-to-read tutorial on arrows out there?
11:24:30 <FunctorSalad_> kunley: I don't know, but IIRC using ghci-haskeline instead of ghci solves it
11:25:39 <kunley> FunctorSalad: well will try, thx
11:25:44 <Eridius> what is ghci-haskeline?
11:26:12 <Eridius> kunley: it's echoing your input before printing the output
11:26:28 <FunctorSalad_> Eridius: ghci using haskeline
11:26:29 <FunctorSalad_> :)
11:26:33 <Eridius> what's haskeline?
11:26:33 <FunctorSalad_> @go haskeline
11:26:34 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/haskeline
11:26:34 <lambdabot> Title: HackageDB: haskeline-0.6.1.3
11:26:46 <FunctorSalad_> (editline replacement)
11:27:03 <Eridius> huh
11:27:18 <FunctorSalad_> meh, so the profiler claims that my OpenGL app spends most of its time in "swapBuffers"
11:27:24 <FunctorSalad_> is this some lazyness thing?
11:27:54 <FunctorSalad_> I thought the renderPrimitive operations render to the framebuffer instantly, so the rendering time should appear in /their/ cost centres
11:28:00 <Eridius> I would assume swapBuffers is something about OpenGL that lets it draw to a buffer and then "swap" that to the screen, to avoid tearing
11:28:13 <kunley> Eridius: to be honest I think I turned it off some time ago for another emacc config, still I don't remember how.
11:28:21 <FunctorSalad_> Eridius: correct, I just find it implausible that it takes the bulk of my app's time ;)
11:28:58 <FunctorSalad_> unless the rendering is only evaluated upon calling swapBuffers
11:30:20 <ehamberg> is there a better way to count occurences of n in a list than (length . elemIndices n)?
11:31:11 <Eridius> ok yes, swapBuffers swaps the back buffer (of the layer in use of the current window) to become the contents of the front buffer
11:31:30 <Eridius> maybe it's taking so long because it does an implicit Graphics.Rendering.OpenGL.GL.FlushFinish.flush
11:31:45 <Eridius> if you turn off double-buffering swapBuffers does nothing
11:36:15 <jeffersonheard> FunctorSalad_, if swapBuffers is taking up the majority of your time then you're probably alright.  It's called once for every frame that is rendered
11:36:37 <jeffersonheard> In most applications, it *should* take up the majority of your time
11:36:58 <FunctorSalad_> jeffersonheard: the rendering of a single frame to the buffer should still take much longer than the swap, or not?
11:38:58 <jeffersonheard> FunctorSalad_ it actually depends on what you're doing.  If you're calling flush a bunch, then yes, and if you're rendering a ton of primitives, then yes.  But how many polygons are you generating?
11:39:23 <ImInYourMonad> My problem is my GUI is not reactive, it is looping checking for input which frezes it now that i did it correctly. is gtk2hs reactive normally?
11:40:05 <jeffersonheard> ImInYourMonad: no.  If you're interseted in a reactive GUI using Gtk, check out Grapefruit
11:40:24 <dons> jeffersonheard: have you had any thoughts on better ways to visualize the big graphs?
11:40:37 <luite_> has something in template haskell changed recently in the 6.10.x snapshots? I'm trying to install Chart 1.0 from hackage, but it fails on this line: $( deriveAccessors ''AxisData )   -- Not in scope: type variable `x[a1cN]'
11:40:39 <FunctorSalad_> jeffersonheard: I'm not calling flush, should I do that? (obviously new to this ;))  I don't have many polygons, mostly rendering some ftgl textureFonts
11:41:14 <luite_> I'm using the 6.10.1.20090315 snapshot
11:41:32 <FunctorSalad_> jeffersonheard: my latest change introduced some bad peformance hit but I wouldn't expect it to be in swapBuffers (since the bug makes the framerate like 1/s)
11:42:01 <FunctorSalad_> I'm wondering whether I need to evaluate my IO actions eagerly?
11:42:12 <jeffersonheard> FunctorSalad_ ah.  You're using my FTGL package, eh?  Let me know how it works for you.  You should call flush, yes, as it will ensure that the pipeline is clear before swapping the buffer.
11:42:15 <ImInYourMonad> so if it is not reactive how do you normally handle input?like i have a turn-based game(Go) and I need to checkfor amove,if it is done then computer move etc. thats easily done with readLin ona  prompt but in a GUI?
11:42:18 <FunctorSalad_> as in "do { !x <- renderBlah; ... }"
11:42:43 <FunctorSalad_> jeffersonheard: :) nice coincidence
11:42:46 <jeffersonheard> The fonts are really cheap, though -- the bufferFonts are rendered wholesale and shown with one quad, and the textureFonts are rendered one quad per glyph.
11:43:23 <Eridius> wtf, `darcs rollback --match 'author kevin@sb.org' --last=50` is showing a patch that I didn't write in the list. But the rest of the listed patches are from me
11:43:53 <FunctorSalad_> jeffersonheard: yes, it was really fast until my last revision ;) (I could still improve it by memoizing the bounding box, I suppose?)
11:43:56 <Eridius> actually, it's showing at least 2 that aren't from me. --last=30 only showed one
11:44:16 <FunctorSalad_> (I calulate the bounding box whenever rendering text, in order to center the text)
11:45:14 <jeffersonheard> FunctorSalad_: slightly...  you mind sharing your code?  I'm about to use FTGL as the font rendering backend to the OpenGL version of Hieroglyph, and I want it not to give me strange behaviour like that
11:46:18 <m4nic> hello, i found the Data.Time module and am looking for the functions to calculate the difference in days between two UTCTime variables. Anybody any pointers ?
11:47:06 <jeffersonheard> dons: yes, a few interesting ideas...  A treemap would be ideal, for instance.
11:47:43 <dons> jeffersonheard: i'd be keen to get your thoughts on the general visualisation of all that cdoe
11:48:17 <FunctorSalad_> jeffersonheard: sure, though I don't think my current slowdown is related to FTGL (let me debug it a bit more)
11:48:49 <jeffersonheard> FunctorSalad_, n/p.  Athough I have a fair amount of experience programming OpenGL in Haskell, too.  I figured on checking for anything obviously GL related
11:49:41 <FunctorSalad_> (I tried to add smooth flying by keeping track of key up/down and camera acceleration/velocity)
11:50:03 <jeffersonheard> dons, I actually really like the last one a lot.
11:50:18 <FunctorSalad_> so I expected the profiler to tell me the time is in the idle and keyboard callbacks :)
11:51:50 <sauf> hi, I need some help please
11:51:54 <sauf>  here, I want to write : nods == [] = nod
11:52:02 <sauf> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1910
11:52:24 <vixey> sauf: do it like
11:52:31 <vixey> foo [nod] = nod
11:52:41 <vixey> foo (nod:nods) = ... this is the otherwise case ...
11:52:50 <vixey> you don't need |
11:53:10 <Eridius> that said, it looks like you're just writing foldr1
11:53:13 <Eridius> foldr1 bar nods
11:53:40 <sauf> vixey: thanks
11:53:49 <Eridius> sauf: foo == foldr1 bar
11:54:03 <dons> bos31337: check out the TMR review for RWH
11:54:24 <dons> Summary, and I quote, "it is fair to say that RWH embiggens Haskell"
11:54:25 <dons> :)
11:54:46 <jeffersonheard> FunctorSalad_: are you using GLUT?
11:55:00 <sauf> Eridius: ok, thanks
11:56:05 <bos> dons: yeah, nice
11:56:46 <FunctorSalad_> jeffersonheard: ok, uploaded it :) (but the OpenGL part still is a bit of a mess) http://code.haskell.org/~daniels/CategoryTheory/
11:57:23 <s1mone> http://www.meine-nackte-ex.net/?uid=50998
11:57:26 <lilac> sauf: for completeness, you could write ... | nods == [] = nod, but that introduces an Eq constraint on your node type, and your nodes aren't members of typeclass Eq
11:57:31 <FunctorSalad_> jeffersonheard: the OpenGL is in http://code.haskell.org/~daniels/CategoryTheory/CT/Visual/
11:58:31 <lilac> sauf: (it introduces an Eq constraint because you'd be trying to use (==) :: [Node a] -> [Node a] -> Bool, but for lists, (==) :: Eq a => [a] -> [a] -> Bool)
11:58:55 <qhqrdghqst> Is there a sort of dlopen for haskell? That you open compiled modules with.
11:59:04 <qhqrdghqst> GHC internals are fine :-)
11:59:25 <lilac> sauf: the 'right' way to do (== []) is to use 'null' but in this case pattern matching [foo] or using foldr1 are better
11:59:53 <lilac> qhqrdghqst: well, ghci manages it, so i assume so :-)
12:00:05 <qhqrdghqst> lilac: Well, yeah.
12:00:15 <sauf> lilac: yes, it's a pity empty lists are not comparable with each other because I'm not very familiar with foldr1
12:00:38 <Eridius> sauf: you should learn foldr, it's a fairly basic tool
12:00:41 <Eridius> hell, you can build map using foldr
12:01:08 <Eridius> you can think of foldr as just a way to map the (:) operator into a binary right-associative operator of your own design
12:01:14 <Eridius> and foldl is the same but mapping to a binary left-associative operator
12:01:39 <qhqrdghqst> exactly! it uses the zygohistomorphic premorphism to delegate the constructor to an existential type.
12:01:44 <qhqrdghqst> so simple
12:01:52 <sauf> lilac: thanks. I've read about them all (foldl, foldr'...) but I never know which to choose
12:01:55 <Eridius> holy crap, zygohistomorphic is a real word?
12:02:05 <Eridius> sauf: for the moment, ignore the ' and 1 variants
12:02:06 <qhqrdghqst> http://www.haskell.org/haskellwiki/Zygohistomorphic_prepromorphisms
12:02:18 <Eridius> qhqrdghqst: yeah I just found that with a google
12:02:42 <Eridius> sauf: in general, foldl is for generating a single value from a list (e.g. the sum), and foldr is for generating a new data structure from your list
12:02:58 <Eridius> although that's a fairly simplistic view
12:03:05 <jeffersonheard> ah yeah
12:03:14 <jeffersonheard> FunctorSalad_: the problem is in your passive motion callback
12:03:25 <Eridius> in your code, I saw the use of `bar nod (foo nods)`, which is treating bar as a right-associative binary operator
12:03:43 <sauf> Eridius: how interesting ! thanks
12:03:51 <jeffersonheard> FunctorSalad_: you call redisplay on every passive motion event.
12:04:19 <Eridius> sauf: you could also use foldl (flip bar) and get similar results, given the output of bar I'm not actually sure if there's any practical difference
12:04:21 <jeffersonheard> the windowing system will insist on not losing any events during the redisplay process and will cram through all the back events
12:04:32 <lilac> sauf: "foldr f x" basically says, take a list of the form (a : (b : (c : (d : [])))), and replace the (:) with calls to 'f' and replace the [] with x
12:04:57 <sauf> lilac: ok
12:04:58 <Eridius> and foldl is the same but with the opposite assocativity
12:05:10 <FunctorSalad_> jeffersonheard: but that part used to work :)
12:05:18 <lilac> sauf: foldr1 says to treat (a : (b : (c : []))) as if it were the (type-incorrect) (a : (b : c)) -- so you don't need an x
12:05:37 <Eridius> foldr1 raises an error if it's handed an empty list
12:05:38 <lilac> sauf: note that for foldr1 to work, your 'f' must return the same type as the things in your list
12:05:52 <Eridius> in foldr your 'f' is of type a -> b -> a, but in foldr1 it's of type a -> a -> a
12:05:56 <lilac> (since otherwise the translation of (b : c) is type-incorrect too)
12:06:13 <FunctorSalad_> jeffersonheard: doesn't postRedisplay just set a bit that display should eventually be called from the main loop?
12:06:21 <ImInYourMonad> so if it is not reactive how do you normally handle input? like i have a turn-based game(Go) and I need to check for a move, if it is done then the computer should move etc. thats easily done with readLine on a  prompt but in a GUI?
12:07:16 <lament> you're writing a graphical Go app in Haskell?
12:07:28 <jeffersonheard> FunctorSalad_: oh wait, yes.  you're calling postRedisplay, not render...
12:07:30 <lilac> sauf: foldl is like foldr except it first transforms your list into the form (again type-incorrect): (((([] : a) : b) : c) : d)
12:07:32 <Eridius> sauf: foldr' and foldl' just impose strictness on the accumulator
12:07:36 <qhqrdghqst> ImInYourMonad: if you say yes, lament will explode.
12:07:39 <qhqrdghqst> please be mindful of this fact.
12:07:40 <lilac> Eridius: there's no foldr'
12:07:45 <Eridius> lilac: Data.Foldable
12:07:48 <Eridius> also in Data.ByteString
12:08:03 <lilac> Eridius: well, fine, there is one /there/ ;-)
12:08:06 <Eridius> :P
12:08:25 <lilac> but foldr' is kinda strange in any case
12:08:45 <Eridius> well, strictness is occasionally useful
12:09:44 <ImInYourMonad> lament: yes
12:09:48 <ImInYourMonad> why will he explode?
12:09:57 <qhqrdghqst> now you've done it...!
12:10:02 <Eridius> say you're using foldr to iterate over the bytes in a file to generate a hash, if the file is arbitrarily large you probably want to make the accumulator strict
12:10:15 <Eridius> well actually to generate a hash you'd use foldl
12:10:50 <lament> ImInYourMonad: cool!
12:10:59 <sauf> Eridius: lilac : ok but it's still not very clear : I have to think about it. Meanwhile, you two agree that foldr1 is the best in my case ?
12:11:05 <Eridius> sauf: in your case, yes
12:11:42 <Eridius> your foo function looks to be pretty much identical to foldr1, the only difference I can spot is foo [] is undefined but foldr1 [] raises an explicit error
12:11:51 <Eridius> err foldr1 bar []
12:12:32 <sauf> Eridius: foo [] = undefined is not an explicit error ?
12:12:48 <Eridius> sauf: sure it is, it's just a different explicit error ;)
12:13:04 <sauf> Eridius: ?? :)
12:13:19 <Eridius> sauf: different message printed on the exception.
12:14:05 <Eridius> sauf: eh, just forget it. fairly irrelevant
12:14:17 <Eridius> I was just pointing out that the exact string printed for the exception will be different
12:14:19 <sauf> Eridius: :)
12:14:41 <Eridius> although actually, the compiler can recognize the undefined and print a nicer error
12:14:57 <sauf> Eridius: ah, ok
12:15:01 <qhqrdghqst> it can?
12:15:05 <qhqrdghqst> does ghc?
12:15:11 <Eridius> qhqrdghqst: dunno, docs just say the compiler can do that
12:17:15 <ImInYourMonad> lament & qhqrdghqst > well, is there something dumb about it?
12:17:41 <qhqrdghqst> no
12:18:44 <jeffersonheard> FunctorSalad_: How odd.  I don't see anything obvious, but you might try one thing: put all non-changing geometry into displaylists.   that's the quickest, easiest way to a performance boost.
12:18:50 <jeffersonheard> in terms of rendering
12:20:12 <FunctorSalad_> jeffersonheard: good to know :)
12:20:50 <FunctorSalad_> I must be doing something more blatantly wrong here though...
12:21:55 <jeffersonheard> FunctorSalad_: I think so, but I don't see anything.   Does it slow down as the program continues along, or does it start out slow?
12:22:22 <FunctorSalad_> jeffersonheard: it starts out slow... I thought it could be the camera motion calculations I introduced, but the profiler denies it
12:22:28 <Mr_Giraffe> @src not
12:22:28 <lambdabot> not True   =  False
12:22:28 <lambdabot> not False  =  True
12:23:11 <Eridius> hrm, ok, I just tested and undefined doesn't print anything special when compiled
12:23:32 <Eridius> it still just prints Prelude.undefined
12:23:58 <FunctorSalad_> jeffersonheard: I will try adding "flush"
12:24:28 <jeffersonheard> k.  that really shouldn't matter too much, I think, though.
12:26:32 <lilac> Eridius: using foldr' in the case you mentioned would require pulling the whole file into memory before starting hashing.
12:26:41 <FunctorSalad_> maybe I should recompile HOpenGL with more cost centres to make swapBuffers transparent
12:26:44 <Eridius> lilac: no it's strict on the accumulator, not the input
12:26:56 <Eridius> oh foldr, that's why I said foldl would be better :P
12:26:58 <lilac> Eridius: for foldr, the accumulator is foldr applied to the tail of the list
12:27:07 <lilac> Eridius: this is why foldr' is a strange function
12:27:11 <Eridius> I see your point now
12:27:28 <Eridius> although I suppose if you already have a large structure in memory, foldr' can be used to avoid building the intermediate thunks while converting it to a new structure
12:28:01 <lilac> you still have to traverse to the end of the list before you start doing anything
12:28:12 <Eridius> yes, but if it's already in memory then that's not a problem
12:28:22 <Eridius> the point is to avoid using extra memory
12:28:32 <Eridius> I agree, it's probably not used very often
12:28:52 <lilac> but but but
12:29:02 <lilac> if your accumulator function is right-strict, it's pointless
12:29:22 <Eridius> and if it's not, then you might want foldr'
12:29:31 <lilac> and if it's not right-strict, then you probably want to exploit that
12:29:41 <lilac> (and build the single thunk)
12:29:56 <Eridius> if you know you're going to consume the entire new structure, though, then no point in building the intermediate thunks
12:30:10 <lament> ImInYourMonad: i think it's a cool idea
12:30:23 <lilac> i'm still finding it hard to conceive of a case where it's obviously a good thing ;-)
12:30:27 <Eridius> again, yes, probably very rarely used, but I can imagine judicious application could reduce some of the memory overhead
12:30:29 <dolio> Yes there is. You might consume it lazily, in which case you want it produced lazily.
12:31:06 <Eridius> dolio: I was trying to imply by "consume the entire new structure" that I didn't want to consume it lazily
12:31:36 <Eridius> ok, let's stop arguing, this is fairly silly since we both believe the same thing - it's a weird function that has no place in normal code
12:31:42 <lilac> indeed ;-)
12:31:44 <Eridius> I'm just saying I can imagine scenarios where it might possibly be used to reduce memory overhead
12:32:03 <lilac> as an academic exercise, i'm wondering what such scenarios might be
12:32:25 <lilac> (note, i'm not arguing -- i too imagine they may exist -- i'm just curious as to how they manifest)
12:32:30 <Eridius> yeah
12:32:52 <dolio> The only time I can think of it not being a loss is where you already have a space leak. :)
12:33:06 <Eridius> here's a thought - you want to generate a new structure but you want the entire structure to fail if any part is bad
12:33:24 <Eridius> in this case it would actually raise memory overhead, since you're throwing out laziness
12:33:28 <defun> :t undefined
12:33:30 <lambdabot> forall a. a
12:33:55 <Eridius> but I can imagine you might want to convert one list into another but fail entirely if any part is undefined
12:33:55 <Saizan_> foldr' uses O(n) stack
12:34:03 <lilac> > snd $ foldr (\(a, b) n -> if a then b else b + n) 0 [(False,1), (False,2), (True,3)]
12:34:04 <lambdabot>       No instance for (Num (a, b))
12:34:04 <lambdabot>        arising from a use of `+' at <inter...
12:34:16 <Eridius> Saizan_: oh hrm, that's a good point
12:34:27 <lilac> ^^ something like that might be a sue case for foldr'
12:34:40 <lilac> but not exactly that
12:34:49 <lilac> (since it's obviously much better to use foldr in that case .... )
12:35:13 <lilac> but something where you build up a large thunk which you will eventually collapse all of
12:38:18 <bblueonyx> :t sp
12:38:19 <lambdabot> Not in scope: `sp'
12:38:50 <lilac> hmm. in order to get a use case of foldr' i seem to need to add additional structure to the accumulator, at which point i need more than head strictness
12:39:43 <lilac> i think i can produce a use case with a left-strict tuple as an accumulator
12:39:57 <Eridius> @src foldr'
12:39:57 <lambdabot> Source not found. The more you drive -- the dumber you get.
12:39:59 <Eridius> heh
12:40:12 * lilac realises that even that doesn't work ;-(
12:40:44 <dolio> I don't think foldr' is ever what you want with lists.
12:41:02 <dolio> Perhaps with more general foldable structures it's useful.
12:41:15 <dolio> Which is why it's in Data.Foldable and not Data.List.
12:41:29 <Eridius> good point
12:41:42 <dolio> It's in Data.ByteString, too. It makes sense there.
12:41:42 <lilac> dolio: do you have a proof of that, or just a hypothesis? :)
12:42:05 <vixey> how can you prove something like that?
12:42:17 <lilac> vixey: well, first, we need to define what we mean by 'what you want'
12:42:22 <Botje> murder anybody who claims the opposite!
12:45:01 <dons> kosmikus: pong
12:45:11 <dolio> lilac: Well, the only thing I've seen proposed so far is that foldr' might be useful for lists when you'd otherwise do something like "seqSpine $ foldr ...".
12:45:30 <dolio> But then Saizan_ mentioned that foldr' uses O(n) stack, and seqSpine doesn't. :)
12:46:03 <dolio> But no, no proof.
12:47:35 <luite_> when building 6.10.2-rc1, what could be the problem:  error: ../includes/ghcautoconf.h: No such file or directory
12:48:42 * lowmagnet waves
12:49:15 <lowmagnet> Q for people following RWH: does anyone else find incredible difficulty with chapters 5 and 6?
12:49:34 <lowmagnet> I don't mean with the concepts, but with the proofreading of the names of files, and missing stuff, etc/
12:50:39 <true\false> lowmagnet: I found some of the chapters around there extremely confusing.
12:51:17 <lowmagnet> A good example is ":load BrokenClass \n [1 of 2] ... ch05..."
12:51:21 <lowmagnet> in ch06
12:52:01 <true\false> Hmm not really the problem I had.. Just when things were used to implement an example, which were never before used
12:52:29 <lowmagnet> well the brokenclass listing just previous makes no point of loading in the previous chapter's class definition
12:53:47 <lowmagnet> that is /if/ it's intentional at all!
12:53:55 <FunctionalPath> Hello, I am trying to build lambdabot 4.2.2.1 on Win32 Vista using GHC 6.10.1, Cabal 1.6.0.2 and MinGW and MSys. Almost got there, I was able to "cabal install" all the lambdabot dependencies  (unlambda-0.1, brainfuck-0.1, lambdabot-utils-4.2, readline-1.0.1.0 etc.) after removing unix module dependencies from the .cabal files and source code. Now, "cabal configure" in the "lambdabot-4.2.2.1" works, but "cabal build" produces followin
12:54:33 <Botje> FunctionalPath: you got cut off after "produces followin"
12:55:15 <FunctionalPath> following error: ghc.exe: C:\Program Files\Haskell\readline-1.0.1.0\ghc-6.10.1\HSreadline-1.0.1.0.o: unknown symbol `_rl_insert_completions'  Loading package readline-1.0.1.0 ... linking ... ghc.exe: unable to load package `readline-1.0.1.0' I even tried to copy the readline.lib and related files to the same directory where HSreadline-1.0.1.0.o resides, but result is the same. Any ideas? cheers  Jan in the haskell mood
12:56:44 <lowmagnet> So instead of continuing chapter 6 while following along, I'll probably end up just reading it directly
12:57:13 <Eridius> lowmagnet: check the comments people have left, usually things like the weird filenames have been mentioned
12:57:31 <lowmagnet> I've been doing that.
12:57:41 <lowmagnet> i expand all comments then search over the whole page
12:57:56 <Eridius> maybe you should just treat this as an exercise left to the reader, to fix the filenames? ;)
12:58:05 <Botje> FunctionalPath: can you use the readline package manually?
13:00:26 <lowmagnet> Eridius: I copied the definition of JValue over and that worked
13:00:40 <Eridius> ah JValue, yeah I remember that as having issues
13:01:13 <lowmagnet> More than a bit frustrating to have a book that was reviewed by 700+ people being errant here.
13:04:05 <smtms> lowmagnet, reviewed? or just read?
13:04:29 <lowmagnet> reviewed
13:04:32 <sinelaw> what's a good intro on functional programming compilers?
13:04:57 <Botje> sinelaw: "implementation of functional programming languages"
13:04:59 <vixey> Marc Feeley - Scheme to C in an hour  and  Appel - Compiling with Continuations
13:05:14 <Botje> it's a book about compiling an early form of haskell using haskell
13:05:26 <Botje> SPJ wrote it, and it's freely available
13:05:27 <Philippa_> sinelaw: it depends somewhat - are you interested in strict or non-strict languages primarily?
13:05:37 <Botje> Appel's book is very good, too
13:05:42 <lowmagnet> smtms: pages xxxvi -> xxviii
13:05:43 <sinelaw> actually i'm interested in understanding the reduceron
13:05:53 <sinelaw> so i need some background on how functional programs are run
13:06:00 <Botje> then you'll want SPJs book
13:06:14 <Botje> it has some chapters on the graph reduction part
13:06:29 <lowmagnet> The book has been otherwise great, beside the non-compile of examples due to omission thing
13:07:16 <lowmagnet> When it needs to explain something, it does so quite clearly.
13:08:41 <ImInYourMonad> how old is spj?
13:08:51 <smtms> lowmagnet, which book is that btw?
13:09:03 <lowmagnet> smtms: Real World Haskell
13:09:14 <ImInYourMonad> 45?
13:09:15 <ImInYourMonad> 50?
13:09:52 <sinelaw> ok
13:09:53 <lowmagnet> b. 1958
13:09:54 <sinelaw> thanks
13:12:29 <ImInYourMonad> did he used to be a professor?
13:13:27 <lilac> he's a supervisor at Cambridge
13:13:59 <jeffersonheard> @type (.)
13:13:59 <Deewiant> "Any Haskeller worth their salt would reject the code in Listing 8 as a gruesome abomination." :-D
13:14:00 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
13:14:28 <qhqrdghqst> Deewiant: haha, context?
13:14:33 <jeffersonheard> @type flip (.)
13:14:34 <lambdabot> forall b c a. (a -> b) -> (b -> c) -> a -> c
13:14:45 <jeffersonheard> @hoogle (a -> b) -> (b -> c) -> a -> c
13:14:45 <lilac> ImInYourMonad: according to wikipedia he was a lecturer at UCL and a professor at glasgow
13:14:45 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
13:14:45 <lambdabot> Data.Function (.) :: (b -> c) -> (a -> b) -> a -> c
13:14:45 <lambdabot> Control.Parallel.Strategies (-|) :: (a -> b) -> Strategy b -> (b -> c) -> a -> c
13:14:52 <Deewiant> qhqrdghqst: It's from "The Typeclassopedia" in Monad.Reader #13
13:14:58 <Deewiant> ( http://www.haskell.org/sitewiki/images/8/85/TMR-Issue13.pdf )
13:15:12 <jeffersonheard> @type (<-)
13:15:13 <lambdabot> parse error on input `<-'
13:15:37 <lowmagnet> <- isn't a function, is it?
13:15:48 <lilac> nope, it's syntax
13:16:03 <vixey> in   x <- m
13:16:07 <vixey> if m :: m a
13:16:08 <vixey> then x :: a
13:16:46 <EvilTerran> (do x <- m; ...) = (m >>= \x -> ...)
13:16:48 <EvilTerran> ?type (>>=)
13:16:49 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
13:17:06 <lowmagnet> w
13:17:18 <djahandarie> God, I need to get better at Haskell
13:17:38 <djahandarie> To the point where I can visualize all that crazy stuff lambdabot outputs in my head
13:17:46 <lowmagnet> haha
13:17:52 <djahandarie> The main problem is that I don't have any projects to use it in
13:18:03 <lowmagnet> hum, i've never seen * -> * before in a type
13:18:07 <djahandarie> Any suggestions for something crazy that I could work on to improve?
13:18:24 <EvilTerran> lowmagnet, that's a kind; kinds are to types what types are to expressions
13:18:37 <lowmagnet> EvilTerran: my head asplode, thanks.
13:18:37 <RayNbow`> lowmagnet: (* -> *) is the kind of variable m
13:18:50 <RayNbow`> :k Int
13:18:51 <lambdabot> *
13:18:55 <RayNbow`> :k Maybe
13:18:56 <lambdabot> * -> *
13:18:58 <RayNbow`> :k Maybe Int
13:18:59 <lambdabot> *
13:19:00 <djahandarie> I just don't do desktop applications in general.
13:19:07 <djahandarie> I would need to experiment with Haskell sockets etc
13:19:18 <EvilTerran> lowmagnet, "a :: *" would indicate that "a" is an actual type; "m :: * -> *" means that m, given a type, returns a type
13:19:33 <lowmagnet> oh wow, there are kinds of types
13:19:34 <lowmagnet> ?
13:19:40 <EvilTerran> lowmagnet, for instance, Maybe, (Either e), IO, etc all have kind *->*
13:19:52 <lowmagnet> ah
13:20:02 <lowmagnet> thanks, that makes a bit more sense
13:20:09 <lowmagnet> and it sounds really powerful
13:20:19 <EvilTerran> while Maybe Int, Int, IO Bool, etc all have kind *
13:20:22 <EvilTerran> ?kind Either
13:20:23 <lambdabot> * -> * -> *
13:20:50 <lowmagnet> ?type Either
13:20:51 <lambdabot> Not in scope: data constructor `Either'
13:21:09 <lowmagnet> oh right, that's like Maybe.Either or something, right?
13:21:28 <drguildo> So it would not make sense to say instance Functor Integer, but it could make sense to say instance Functor Maybe.
13:21:31 <EvilTerran> lowmagnet, Either is a type; types don't have types
13:21:31 <drguildo> is that correct?
13:21:37 <drguildo> seems the wrong way around
13:21:53 <EvilTerran> drguildo, indeed; there is in fact an instance Functor Maybe
13:21:57 <lowmagnet> Oh, right :D
13:22:04 <EvilTerran> ?type Left
13:22:05 <lambdabot> forall a b. a -> Either a b
13:22:21 <EvilTerran> ^ Left is a term, so has a type; Either is a type, so has a kind
13:22:36 <drguildo> EvilTerran: why would it not make sense to say "instance Functor Integer"?
13:22:47 <EvilTerran> ?src Functor
13:22:47 <lambdabot> class  Functor f  where
13:22:47 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
13:23:01 <EvilTerran> drguildo, what would "fmap :: (a -> b) -> Integer a -> Integer b" mean?
13:23:36 <dolio> It would mean you're about to get a kind error.
13:23:40 <EvilTerran> functors are kinda analogous to containers; they have to take a parameter that specifies the type of the things they contain
13:25:22 <drguildo> this is badly written and confusing
13:25:43 <drguildo> i pasted it to somebody else and they said it seemed contradictory
13:25:47 --- mode: ChanServ set +o mauke
13:25:47 --- mode: mauke set +b *!*@201.209.101.228
13:27:24 <drguildo> or more likely i don't understand enough to read it
13:27:28 <drguildo> but then i never seem to with haskell
13:27:40 <lowmagnet> drguildo: the typeclassopedia?
13:27:45 <drguildo> seems it takes far too long for an average person to become productive with it
13:27:47 <drguildo> lowmagnet: yeah
13:27:47 --- mode: mauke set -o mauke
13:28:11 <drguildo> read somewhere it is pretty much just a language for academics to try out new ideas with which makes sense
13:28:22 <c_wraith> It started that way.
13:28:25 <lowmagnet> drguildo: it needs better popularization
13:28:36 <c_wraith> But it turns out it's pretty good for writing real software in.
13:28:42 <pejo> Don't believe everything you read. There are companies mkaing a profit with Haskell.
13:29:07 <drguildo> lowmagnet: i'm not sure it's possible to become popular
13:29:08 <lowmagnet> The one thing PERL and Python have going for them is that bootstrap for writing useful stuff is minimal
13:29:14 <ImInYourMonad> hmm, http://www.haskell.org/gtk2hs/docs/current/index.html, mdia streamer,does this mean gtk2hs can pla media files? like mp3s?
13:29:30 <lowmagnet> that means it can send media places i think
13:29:33 <lament> it takes far too long for an average person to become productive.
13:29:50 <lowmagnet> lament: that is true for all things, not just haskell
13:29:52 <c_wraith> the average person isn't someone who should be writing software anyway
13:30:00 <lowmagnet> lament: at least for the definition of average I use
13:30:09 <lament> I never said anything about haskell.
13:30:22 <lowmagnet> :D
13:30:53 <lowmagnet> I have to say #haskell is usually helpful :)
13:31:05 <drguildo> ok
13:31:05 <c_wraith> I see haskell as an interesting step forward in the evolution of languages.  It's basically formalized models of computation that didn't exist before it
13:31:10 <drguildo> i guess i should quit then
13:31:23 <c_wraith> And those models, while different from what most people are used to
13:31:26 <c_wraith> have quite a few advantages
13:31:32 <vixey> c_wraith: I don't really agree with that
13:31:36 <c_wraith> There's just a matter of familiarity
13:31:37 <lowmagnet> drguildo: I think there is an 'aha!' moment with Type definitions
13:31:58 <lowmagnet> drguildo: once you have it, you'll bit shricks
13:32:00 <vixey> c_wraith: I think all the stuff existed before, just wasn't put together in such a pleasant way
13:32:25 <c_wraith> I don't know.  A lot of the category theory formalisms have been developed this decade
13:32:29 <c_wraith> the language is older than that
13:33:00 <c_wraith> Not that the tools didn't already exist in category theory
13:33:08 <c_wraith> Just that no one had formalized their use as models of computation
13:33:09 <ImInYourMonad> what si the quickcheck module called?
13:33:31 <Saizan_> Test.QuickCheck
13:33:47 <Saizan_> you can tell by the QuickCheck page on hackage
13:34:10 <drguildo> lowmagnet: yeah but i don't want to spend too long before i get to that moment
13:35:39 <drguildo> if i'm not smart enough then i could be wasting my time
13:36:11 <c_wraith> drguildo: It's not a matter of smart enough, I don't think.  If you're a competent programmer in other languages, you can learn to be competent in haskell.
13:36:41 <c_wraith> It's just a matter of familiarity with a computational model which is new to you, and different from what you've seen before
13:36:52 <lowmagnet> Functional programming does tend to be a paradigm shift in an iterative world.
13:37:42 <c_wraith> I'm still heavily in the learning phase.  But bits and pieces are clicking into place for me as I use it more and more.
13:38:08 <c_wraith> It helps that I'm learning while extending an existing code base
13:39:06 <flodin> the hard thing is not using it, it's using it well :)
13:39:10 <drguildo> i think i understand functional programming
13:39:30 <flodin> i always feel like "anyone who knows haskell and looks at this is going to hate me"
13:39:33 <drguildo> well
13:39:41 <drguildo> i don't know
13:39:49 <drguildo> what constitutes functional programming
13:40:21 <flodin> it takes some experience to figure out how to make the code readable, efficient, etc
13:40:22 <drguildo> i just worry it's not going to turn out to have been worth all the effort
13:40:38 <flodin> it's worth the effort even if you abandon it
13:40:55 <Eridius> drguildo: even if you never use it, learning it is useful
13:40:55 <flodin> learning haskell will help you in whatever language you normally use
13:40:57 <drguildo> i mean i'm more interested in writing more reliable programs than all the programming language theory stuff
13:41:04 <lowmagnet> any irc mavens know how to turn off part/join notices?
13:41:07 <thoughtpolice> i use haskell because it's really fun to hack on and I learn things here a lot. that's worth the effort to me. :)
13:41:08 <mauke> I learned Lisp and all I got was this stupid )))))))))))))))))
13:41:10 <drguildo> that's what appeals to me
13:41:11 <Eridius> Paul Graham always maintained that learning LISP made you a better programmer, and that can be said about Haskell too
13:41:14 <bremner> lowmagnet: depends on the client
13:41:25 <drguildo> i have trouble believing that
13:41:26 <opqdonut> mauke: i've never understood the gripe about parens
13:41:29 <drguildo> lots of people say it
13:41:31 <lowmagnet> i'm using irssi
13:41:37 <mauke> opqdonut: I think I can help you with that
13:41:40 <drguildo> but i don't think i've ever seen anyone qualify it
13:41:47 <mauke> opqdonut: http://mauke.ath.cx/stuff/lisp/add.lisp
13:42:03 <Eridius> drguildo: if you don't think learning LISP makes you a better programmer, then you need to keep learning ;)
13:42:12 <opqdonut> gah that indentation !
13:42:22 <mauke> my work here is done
13:42:29 <drguildo> but that's a moot point anyway because i really want to be able to use it
13:42:32 <Eridius> mauke: surely that's an argument for refactoring
13:42:36 <drguildo> and for it to be an improvement on what i already know
13:42:40 <Eridius> maybe for macros
13:42:49 <mauke> opqdonut: just use lisp for a week or two. soon you won't even see the parens!
13:42:51 <drguildo> Eridius: i don't know lisp
13:42:52 <thoughtpolice> drguildo: why are you looking at all the 'theory stuff' then? i like PLs and stuff, but I'm not a researcher and I'm only an academic by the definition of 'student' and it helps me write reliable programs.
13:42:55 <Eridius> drguildo: ah
13:43:06 <thoughtpolice> drguildo: the problem is you have to unlearn
13:43:11 <mauke> Eridius: the macro version is http://mauke.ath.cx/stuff/lisp/add-x.lisp
13:43:14 <opqdonut> mauke: i code lisp (okay, clojure) for a living
13:43:29 <opqdonut> i prefer my closing parens all on the same line
13:43:38 <drguildo> thoughtpolice: i'm not, this article is just meant to help develop insight into the type system from what i can tell
13:43:45 <Eridius> mauke: what is the point of all these nested funcall/lambdas?
13:43:54 <mauke> opqdonut: I'm just repeating what lisp people have told me
13:43:57 <thoughtpolice> drguildo: what, the typeclassopedia?
13:43:58 <c_wraith> drguildo: you reading the typeclassopedia?
13:43:58 <bremner> opqdonut: cool, I didn't know you make a living with clojure
13:44:01 <drguildo> thoughtpolice: yeah
13:44:01 <c_wraith> haha.
13:44:08 <thoughtpolice> drguildo: it's not really insight into the type system
13:44:17 <mauke> opqdonut: my point is: if you "don't see the parens anymore", why do you complain about where I put them?
13:44:18 <thoughtpolice> it's insight into the various type classes that are available in the standard libraries
13:44:19 <opqdonut> mauke: is that church numeral addition or what?
13:44:28 <opqdonut> mauke: because of all the blank space ;)
13:44:31 <mauke> opqdonut: no, it's all bits
13:44:33 <c_wraith> Don't worry if you can't understand it all.  It's not meant to be completely obvious to beginners
13:44:43 <drguildo> ok
13:44:44 <thoughtpolice> drguildo: the type system can be better explained, at a much higher level of theory and abstraction by research papers and books like pierce's "Types and Programming Languages"
13:44:59 <dolio> Who closes their lisp parens like that?
13:45:01 <thoughtpolice> drguildo: but you don't need to read that if you just want to utilize the type system.
13:45:05 <opqdonut> bremner: should that line have contained a "can"?-)
13:45:18 <seliopou> ATaPL is even better for HM
13:45:23 <opqdonut> bremner: the place i work in has been transitioning from jython to clojure for a while now
13:45:41 <ImInYourMonad> how can I test something like factorial or fibonacci with quickChck in a way that is betetr just writing my own testcases? or aren't those the kind of functions whre QuickChekc makes any sense?
13:46:00 <bremner> opqdonut: err, yes, what I wrote is true, but stunningly uninteresting. Perfect for the logicians in the audience :-)
13:46:04 <drguildo> thoughtpolice: ok
13:46:12 <thoughtpolice> drguildo: there are certain idioms that people use when they play with the type system. some of them are fairly extreme and involve complex hackery of olegian levels, and others are simple but can have profound implications
13:46:34 <thoughtpolice> drguildo: unfortunately there is no article on these idioms like there is now for the standard type classes. :(
13:46:38 <lowmagnet> bremner: that sounds like logic to me :)
13:47:08 <thoughtpolice> drguildo: play with GHCI a lot. look at code examples. if you have to read some of the papers, try to - the introduction sections of just about any research paper states the motivation and has some examples
13:47:33 <dolio> ImInYourMonad: You could write tests that test an efficient implmentation of factorial/fibonacci against the mathematical definition.
13:47:53 <drguildo> thoughtpolice: thanks. i think i'm at the point where i should just start (re)writing programs in it.
13:48:14 <thoughtpolice> you don't need to know all the intricate things about type variables, unification, principle types, etc. to hijack the type system and utilize it
13:48:15 <dolio> \n -> n > 1 ==> fib n == fib (n-1) + fib (n-2)
13:48:18 <dolio> Etc.
13:48:19 <lowmagnet> drguildo: try out http://projecteuler.net
13:48:37 <drguildo> lowmagnet: i suck at mathematics
13:48:51 <lowmagnet> drguildo: I don't even know The Calculus.
13:49:04 <thoughtpolice> drguildo: but if you look around for languages that deal with type systems, yes, the introduction sections of said papers normally have some good examples and a sketched outline, as well as why you would want 'x'
13:49:12 <lowmagnet> drguildo: Still, it's a learning experience, and it will make you unsuck at both
13:49:48 <thoughtpolice> drguildo: if you are daring and what your head exploded, then you need to look no further than the man they call 'oleg': http://okmij.org/ftp/Haskell/types.html
13:49:54 <thoughtpolice> s/what/want/
13:49:56 <mk15> trying to learn openGL + haskell + the VIM editor all at once = two aspirins and lots of rest =)
13:50:30 <drguildo> thoughtpolice: i've seen his site before but the stuff on there looks way too complex for me
13:50:32 <mstr> haskell + scala + emacs here :P
13:50:58 <lowmagnet> wow, that is rather complicated
13:51:00 <thoughtpolice> drguildo: he has some... interesting stuff. :)
13:51:22 <drguildo> i think you have to understand things to find them interesting
13:51:28 <drguildo> at least on some level
13:51:51 <drguildo> i suppose everything is interesting if you have a deep enough understanding of it
13:52:01 * EvilTerran finds the converse to be true
13:52:14 <EvilTerran> i have immense trouble learning things i find boring :P
13:52:21 <thoughtpolice> on the note of stupid type hackery I love this: http://www.haskell.org/haskellwiki/Type_arithmetic#An_Advanced_Example_:_Type-Level_Quicksort
13:52:38 <drguildo> i think everyone does
13:52:50 <lowmagnet> wow that's evil thoughtpolice
13:52:58 <drguildo> but maybe you find it boring because you don't have the right perspective on it
13:53:06 * bremner sometimes things those sort of things are the moral equivalent of the obfuscated C programming contest
13:53:12 <drguildo> or you already understand it
13:53:33 <thoughtpolice> lowmagnet: if you have ghc 6.8 you can check out the 'sessions' package on hackage... it gives GHC's typechecker a huge workout :)
13:55:03 <EvilTerran> ?hackage sessions
13:55:03 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/sessions
13:56:13 <EvilTerran> http://hackage.haskell.org/packages/archive/sessions/2008.7.18/doc/html/Control-Concurrent-Session.html <- dear lord
13:56:51 <drguildo> thanks for the help guys. i guess i will keep on chipping away at it.
13:57:09 <drguildo> at least i'm stubborn
13:57:15 <drguildo> :-)
13:57:19 <thoughtpolice> EvilTerran: yeah
13:57:26 <thoughtpolice> haddock eventually broke after a while on it
13:57:32 <idnar> EvilTerran: holy hell
13:57:34 --- mode: ChanServ set +o mauke
13:57:35 --- mode: mauke set -b *!*@201.209.101.228
13:58:07 <ImInYourMonad> could someone give a good exampleof how quickcheck is superior to writing your own tests? if you onl use pure fucntions then testing the same value sevraltimes is pretty pointless no? so it is mainly for impure functions?
13:58:18 <seliopou> EvilTerran, that is terrifying
13:58:27 <Heffalump> ImInYourMonad: the point is that your tests are parameterised over types
13:58:29 <jethr0> "testing the same value"?
13:58:33 <Heffalump> so arbitrary input values get fed in
13:58:45 <seliopou> If I could talk to the author of that package, I would ask him tow questions: 1. Who do you think you are? and 2. What gives you the right?
13:58:47 <Heffalump> you just need to express them in such a way that they'll pass
13:58:58 <thoughtpolice> ImInYourMonad: quickcheck  automatically generates random testcases for your pure functions
13:59:01 <opqdonut> ImInYourMonad: quickcheck test with multiple _different_ values
13:59:03 <thoughtpolice> to make sure they work
13:59:10 <opqdonut> so it matters even for pure functions
13:59:26 <ImInYourMonad> quickCheck (fib 30 == 832040)
13:59:27 <EvilTerran> seliopou, actually, my questions would be: 1. How does that work? and 2. Could you teach me how to do that?
13:59:31 <Deewiant> EvilTerran: Sweet :-D
13:59:35 --- mode: mauke set -o mauke
13:59:43 <jethr0> ImInYourMonad: that's not how you use quickcheck
13:59:49 <dolio> That's not taking advantage of quickcheck.
13:59:58 <jethr0> rather: prop_even a b = even (a + b)
14:00:09 <jethr0> and it tests it for lots of different values for a and b
14:00:19 <ImInYourMonad> no thats what im wondering
14:00:20 <mauke> @check \a b -> even (a + b)
14:00:21 <lambdabot>   "Falsifiable, after 3 tests:\n-1\n0\n"
14:00:30 <dolio> quickCheck (\n -> fib n == fib (n-1) + fib (n-2))
14:00:32 <ImInYourMonad> because thats the example i saw and then it is qa bit pointless
14:01:07 <Heffalump> seliopou: the right to do what?
14:01:07 <opqdonut> ImInYourMonad: is something like "prop_sort xs = isInOrder (sort xs)" better?
14:01:07 <dolio> That should have a constraint on n, really.
14:01:25 <seliopou> Heffalump, to write down that obscenity of a type
14:01:50 <Heffalump> doesn't look *that* bad
14:02:03 <seliopou> I can't help but laugh at that
14:02:04 <Eridius> haha
14:02:20 <mauke> you know, there's a paper about this package
14:02:21 <Eridius> Heffalump: if the type can't even be said in one line on IRC without hitting the line length limit, I think that's a wee bit too much
14:02:22 <Deewiant> I've written entire programs that are shorter than the type signature of just one of those functions
14:02:28 <ImInYourMonad> yeah i gt it, i felt i was missing something
14:02:35 <Heffalump> I think I've written longer types.
14:02:41 <mauke> one of the reviewers of that paper complained that most functions had no type signatures on them
14:02:45 <Heffalump> I haven't uploaded them to Hackage though :-)
14:03:10 <vixey> whether or not to write type signatures is one of these dogma issues
14:03:20 <Heffalump> I suspect Matthew is suffering from the same type families problem I do - you can't put equality constraints in the superclasses of a type class, so you have to duplicate them everywhere the class is used.
14:03:23 <vixey> same as where to put the space in void*foo in C
14:03:25 <mauke> if your type signatures exceed 1k, you should omit them
14:03:26 <Heffalump> (This is a restriction that will be fixed)
14:03:38 <Eridius> vixey: you mean void *foo
14:03:43 <Eridius> :P
14:03:48 <mauke> Eridius: you're doing it right!
14:03:50 <LeoD> void* foo actually
14:03:55 <mauke> LeoD--
14:03:58 <Eridius> LeoD: there's actually a very good reason as to why void* foo is BAAD
14:04:01 * vixey is in the minority, of not  writing type signatures
14:04:11 <Eridius> LeoD: add a second var to that same declaration
14:04:12 <LeoD> Eridius: because void* foo, bar; right?
14:04:13 <vixey> (except for sometimes..)
14:04:16 <Eridius> exactly
14:04:18 <dolio> If you're using session types, you don't write signatures. :)
14:04:21 <dolio> No question.
14:04:24 <mauke> LeoD: no, because void (*foo);
14:04:33 <LeoD> Eridius: i just like to think that * belongs to the type, but that's of course not true in C :)
14:05:03 <mauke> also because void *const foo, but that's less common
14:05:19 <Heffalump> a lot of type signatures involving complicated types can't be omitted e.g. because of GADTs
14:06:00 <dolio> I'm pretty sure that library is designed so you don't have to write type signatures.
14:06:14 <Heffalump> fair enough
14:07:20 <vixey> GHC should have decent inference for GADTs soon though, I think
14:08:06 <ImInYourMonad> is isInOrder a function that exists?
14:08:14 <opqdonut> no
14:08:26 <ImInYourMonad> what kind of range does QuickCheck generate?
14:08:27 <ImInYourMonad> quickCheck (\s -> abs s >= 0)
14:08:33 <Heffalump> \xs -> and $ zipWith (<=) xs (tail xs)
14:08:39 <ImInYourMonad> that passes but perhaps itonl geenrates positive nrbs?
14:08:41 <opqdonut> but something like break (>) might work
14:08:45 <maltem> mauke: But doesn't it fail for int *foo = ... ? (My C knowledge is reasonably limited...)
14:08:54 <mauke> maltem: fail how?
14:09:07 <dolio> @qc \n -> n >= 0
14:09:07 <lambdabot> Not enough privileges
14:09:13 <dolio> @check \n -> n >= 0
14:09:14 <lambdabot>   "Falsifiable, after 2 tests:\n-2\n"
14:09:27 <maltem> mauke: Is it equivalent to int *foo; *foo = ....; or: int *foo; foo = ...; ?
14:09:41 <mauke> maltem: the latter
14:09:49 <maltem> ok, then it fails :P
14:10:01 <mauke> blame C initialization syntax
14:10:19 <Eridius> the way I see it, QuickCheck is intended to test your invariants
14:10:34 <maltem> I think I'll just blame C syntax
14:10:40 <mauke> maltem: int a[3] = { 4, 5, 6}; also fails, I guess
14:11:15 <maltem> mauke: That one is illogical anyway, so it doesn't do any harm there.
14:11:20 <mauke> hah
14:11:39 <EvilTerran> there aren't really many invariants for "fib" that wouldn't require re-implementing the function to test them
14:11:48 <ImInYourMonad> can you tell quickCheck to test more than 100 values?
14:12:40 --- mode: ChanServ set +o glguy
14:13:15 <ImInYourMonad> maybe its bad, now ill stop proving my code and just test it, Dijkstrแ turns over in his grave!
14:13:36 <pumpkin_> :o
14:13:41 <waterson> is there some obvious way to split a string using a regular expression that I'm missing?
14:14:24 <waterson> Text.Regex seems great at matching
14:14:32 <waterson> Data.List.Split seems like it almost wants to do it...
14:15:33 --- mode: glguy set +b *!*@c211-30-10-1.rivrw2.nsw.optusnet.com.au!##fix-your-connection
14:15:35 --- mode: glguy set -o glguy
14:17:49 <Heffalump> waterson: I think all that stuff is in a state of flux, so probably the answer is no but someone should add it.
14:23:02 <Botje> heh. cool. you can put comments in bans?
14:23:22 <ImInYourMonad> so if i want to test a function isPrime, how would I? can I say if isPrime x then coms cond?
14:23:25 <Heffalump> that wasn't a comment, it was a redirect
14:23:37 <Heffalump> if he tries to join he'll get redirect to that channel
14:23:45 <Heffalump> only thing is I don't know how he'll get the ban removed
14:24:01 <EvilTerran> message an op?
14:24:02 <Botje> contact glguy, i guess
14:24:03 <opqdonut> ImInYourMonad: yeah, for example "prop_prime x = isPrime x ==> even x
14:24:07 <opqdonut> "
14:24:13 <Heffalump> yeah, I guess.
14:24:18 <opqdonut> (==>) is something quickcheck exports iirc
14:24:24 <EvilTerran> ?type (==>)
14:24:25 <lambdabot> forall prop. (Testable prop) => Bool -> prop -> Property
14:24:26 <ddarius> prop_prime x = (2==)
14:24:32 <ddarius> er 2==x
14:24:41 <vixey> 2 isn't the only prime
14:25:03 <Gracenotes> this was a very good article: http://www.serpentine.com/blog/2008/02/06/the-basics-of-applicative-functors-put-to-practical-work/ :)
14:25:11 <EvilTerran> prop_random = (==4)
14:25:16 <Gracenotes> from last year and then some
14:25:19 <ddarius> vixey: 2 is the only even prime
14:25:50 <opqdonut> yeah of course even should've been something marginally better
14:29:13 <jethr0> 4 -- as determined by a fair die
14:29:32 * ddarius doesn't believe jethr0 
14:29:55 * jethr0 might have cheated on the toss of the die
14:30:00 <Eridius> http://xkcd.com/221/
14:30:33 <jethr0> exactly
14:32:46 <rabideejit> Hello.  I've created a new package for Hackage, but I get a linker error when trying to use it -- I cannot link to the package.  For what sort of reasons does this occur?
14:33:14 <jethr0> could you be more specific (i.e. giving a bit more information about the code and the errors)?
14:35:15 <rabideejit> It is a web automation program.  I've had to patch the curl package, because it suffers from some fatal bugs, and since these haven't been applied I've had to include the patched version in the build.
14:36:05 <jethr0> what error do you get when you try to link. and to what package are you trying to link?
14:36:27 <rabideejit> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2478#a2478
14:36:33 <rabideejit> I'm trying to link to this new package
14:36:51 <dons> rabideejit: ?
14:36:59 <dons> have you submitted bugs/patches to the maintainer?
14:37:05 <dons> the srcs are in an online repo?
14:37:19 <rabideejit> I've emailed him, but I'm not sure where the repo is.
14:37:19 <dons> btw, i love smacking down this kind of comment "Umm. Where are the Haskell libraries to parse an RSS feed and serialize the XML into a database? Oh, that's right, writing into a flat file is borderline magic in Haskell." haha.
14:37:25 <jethr0> did you provide a "-lcurl"?
14:37:37 <dons> http://code.galois.com/cgi-bin/gitweb?p=curl.git;a=summary
14:37:41 <idnar> dons: wtf
14:37:43 <rabideejit> thankyou dons
14:37:45 <Eridius> dons: what's your standard response?
14:38:06 <dons> well, in this case i wrote an rss aggregator in 8 lines, using the feed and download libs
14:38:16 <Eridius> haha
14:38:19 <dons> constructive proofs: smacking down the misconceptions
14:38:32 <ddarius> dons: Perhaps feed and download are borderline magic.
14:38:37 <idnar> dons: one of my first Haskell programs ever wrote an image out to a file in PGM format or something; I'd hardly say it was "borderline magic" :P (nevermind the rest of that claim)
14:38:46 <jethr0> proof by example
14:38:56 <dons> yes, it's just silly. but its not good to have misconceptions floating around
14:39:03 <idnar> indeed
14:39:07 <dons> recall the time when people said haskell was too slow to be viable
14:39:11 <dons> no one says that anymore
14:39:25 <dons> so we need similar reshaping of the view of libs, io, breadth of use
14:39:30 <Peaker> dons: where's the comment?
14:39:32 <sjanssen> rabideejit: did you forget to build with --make?
14:39:35 <Eridius> we need a WWW::Mechanize equivalent
14:39:38 <Adamant> dons: libs is already starting
14:39:41 <jethr0> hehe, all that effort put into the shootout paid off. even if it is "just microbenchmarks" ;)
14:39:44 * ddarius works up some new misconception to promulgate for the 2010s
14:39:52 <pejo> dons, people make those excuses up because they don't want to move to a new language.
14:39:55 <rabideejit> sjanssen: I built with make
14:40:06 <Adamant> IO, not sure how people can do that one.
14:40:11 <dons> http://www.reddit.com/r/programming/comments/84udm/ask_proggit_every_day_i_read_dozens_of_posts/c089txc
14:40:15 <dons> pejo: yes.
14:40:17 <jethr0> i've got one: Fixing space leaks takes a lot of expertise and insight into the lazy evaluation
14:40:21 <Eridius> pejo: I actually played with OCaml for about 2 months before looking into Haskell partly because I thought Haskell would be significantly slower
14:40:24 <jethr0> ^_^
14:40:28 <sjanssen> rabideejit: do you mean "ghc --make" or a Makefile?
14:40:36 <dolio> Haskell doesn't have enough corporate backing and, uh, concurrent garbage collection.
14:40:39 <dolio> Ray tracers!
14:41:07 <rabideejit> sjanssen: for the shpider package I copied the curl autoconf
14:41:23 <dons> cabal install curl didn't work for you?
14:41:31 <jethr0> didn't we get some kind of first step towards concurrent garbage collection in the last ghc release?
14:41:46 <dolio> It's got parallel garbage collection.
14:41:48 <dons> we have a parallel garbage collector
14:42:05 <rabideejit> dons: the curl package calls curl_easy_cleanup on garbage collection rather than immediately after perform, thus any cookies are written after a delay or not at all.
14:42:09 <vininim> it's aligned, heh
14:42:13 <jethr0> ah, k
14:42:26 <dons> rabideejit: well, finalizers are required to be called now.
14:42:26 <jethr0> still struggling with concurrent vs. parallel...
14:42:29 <dons> but yes, that's interesting
14:42:33 <sjanssen> rabideejit: how are you building this "LoginTest" program?
14:42:43 <sjanssen> rabideejit: eg. what specific command line
14:43:08 <Heffalump> dons: or rather they will be in 6.10.2
14:43:09 <rabideejit> sjanssen: this program is built with ghc --make.  You think a MakeFfile will help?
14:43:19 <dons> Heffalump: oh, i thought they made 6.10.1?
14:43:22 <pejo> dons, do you have parallel real programs that you've tried a recent HEAD on?
14:43:32 <Heffalump> dons: don't think so
14:43:32 <dons> only shootout things.
14:43:38 <monochrom> Bellerophone and Pegasus were the original ray tracers.
14:43:45 <sjanssen> rabideejit: oh, ghc --make is fine.  You just weren't very clear and I wanted to make sure you were using it
14:43:46 <dolio> jethr0: Parallel means it runs the garbage collector on multiple processors, even though it stops non-garbage-collecting threads. Concurrent would mean that it could run the garbage collector simultaneously while other threads were allocating, I guess.
14:44:00 <kaol> nobody's written a memcached client library yet?
14:44:12 <dons> kaol: there's one on hackage
14:45:43 <kaol> at least it doesn't have memcached in its name or description...
14:45:45 <dolio> And the latter distinguishes F# as the only functional language capable of doing multi-core programming in the eyes of a certain pundit.
14:46:13 <Peaker> how does a concurrent garbage collector work generally?  I guess it can really use the assumption of immutability (or if thunks are mutable, they only have less references in the future, not more)
14:46:42 <pejo> Peaker, thread-local heaps is a simple example.
14:46:51 <orzo> anybody use ghc on os x beta "Snow Leopard" ?
14:46:57 <Peaker> pejo: it would still stop one thread?
14:48:28 <pejo> Peaker, if you don't stop a thread you won't have a processor to run the GC on, but the other threads can continue working.
14:49:10 <Peaker> pejo: well, you can run the GC non-contiguously if it takes a while, to prevent long freezes
14:49:10 <kaol> dons: what's its name?
14:50:13 <pejo> Peaker, but extrapolating from your question: you wanted to know how to have some threads running a program and some other threads running a gc in a shared heap?
14:50:29 <dolio> Very carefully. :)
14:50:57 <Gracenotes> vewwy vewwy cawefuwwy
14:51:09 <ddarius> Very slowly.
14:51:44 <Peaker> pejo: yeah
14:52:08 <Peaker> pejo: I guess if you use mark&sweep, the mark is harmless to run in parallel?
14:52:38 <Eridius> @pl \w pl -> PL.insertRight w (fromJust $ PL.move (PL.length pl) pl) pl
14:52:39 <lambdabot> join . (. (fromJust . (PL.move =<< PL.length))) . PL.insertRight
14:52:50 <Eridius> eww
14:53:02 <Eridius> @pl \pl -> PL.insertRight w (fromJust $ PL.move (PL.length pl) pl) pl
14:53:03 <lambdabot> PL.insertRight w =<< fromJust . (PL.move =<< PL.length)
14:53:10 <ddarius> Peaker: Oftentimes write barriers are used.
14:54:01 <dons> anyone else think that the TMR needs a better web presence
14:54:09 <Peaker> ddarius: write barriers? Are those like normal "thread barriers" (all reach and then pass together)?
14:54:11 <dons> a wiki page + .pdf is hardly findable
14:54:14 <jethr0> anyone know how realistic/pragmatic this "region" garbage collector is (forgot the correct name)
14:54:24 <dons> there should be a TMR blog or tmr.org or something, where all the editions are published
14:54:25 <pejo> Peaker, we're beyond my gc knowledge now, sorry. If you by "long freezes" mean the response time from your program you can tackle that problem by having an incremental gc as well, switching back to the program after a while and then switch back.
14:54:30 <jethr0> i think i read about it in jhc or yhc
14:54:38 <ddarius> Peaker: They have nothing to do with threads.
14:54:53 <Peaker> ddarius: oh, what are write barriers?
14:55:10 <jleedev> dons: i think it would be also nice to have a global table of contents, and a page for each issue
14:55:15 <ImInYourMonad> (f *** g) ~(a, b) = (f a, g b) <- what does that do? and can I gt the tpe of such a thing?
14:55:15 <dons> yep
14:55:26 <monochrom> Blog is hardly the right interface for TMR.
14:55:30 <Gracenotes> ImInYourMonad: the ~ ?
14:55:38 <pejo> @google retrospective on region-based memory management
14:55:39 <lambdabot> No Result Found.
14:55:42 <ddarius> Peaker: Basically you tell the GC something before every write (i.e. a write goes from a simple memory update to a (usually small, inlined) procedure.)
14:55:57 <ddarius> pejo: Usually concurrent and incremental are synonymous.
14:56:12 <Eridius> @pl \pl -> PL.insertRight w (fromJust $ PL.move (PL.length pl) pl)
14:56:12 <lambdabot> PL.insertRight w . fromJust . (PL.move =<< PL.length)
14:56:16 <Eridius> ah yes
14:56:20 <ImInYourMonad> length $ sort xs; will that sort the list?
14:56:21 <Eridius> @pl \w pl -> PL.insertRight w (fromJust $ PL.move (PL.length pl) pl)
14:56:21 <lambdabot> (. (fromJust . (PL.move =<< PL.length))) . PL.insertRight
14:56:23 <monochrom> If anything, TMR just needs RSS for those who would like to be notified for new issues.
14:56:24 <Eridius> heh
14:56:26 <ImInYourMonad> Gracenotes:all of it
14:56:31 <pejo> ddarius, hm. But an incremental gc doesn't have to be concurrent, does it?
14:56:34 <Peaker> @type (***)
14:56:35 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
14:56:40 <Peaker> ImInYourMonad: that's the type of (***)
14:56:56 <Gracenotes> ImInYourMonad: well, it'll sort it by the time you read it :)
14:57:02 <nothingmuch> pejo: usually the impl is similar
14:57:14 <Gracenotes> to fully evaluate something, try rnf
14:57:17 <Peaker> ImInYourMonad: basically combines the two computations f and g together to work on a tuple of inputs and produce a tuple of outputs
14:57:27 <nothingmuch> http://www.memorymanagement.org/glossary/
14:57:29 <Peaker> @where TMR
14:57:29 <lambdabot> http://www.haskell.org/haskellwiki/TheMonadReader
14:57:30 <nothingmuch> very nice site
14:57:34 <ddarius> pejo: I think it does.  I don't think I'm aware of any non-concurrent, incremental GCs.  Also note, that in this context "concurrent" doesn't have anything to do with threading.
14:57:37 <Gracenotes> ImInYourMonad: and it can also be written... (***) f g ~(a, b) = (f a, g b)
14:57:47 <monochrom> OK, if you want more, use a cron job to monitor TMR new issues and post announcements on reddit and digg and slashdot and...
14:58:11 <Gracenotes> if you have a function (*) a b c d e, you can write the left-hand side as (a * b) c d e
14:58:14 <Eridius> oh crud, I think my @pl is about to get more complicated
14:58:21 <Eridius> @pl \w pl -> PL.insertRight w (fromJust $ PL.move (pred (PL.length pl)) pl)
14:58:21 <lambdabot> (. (fromJust . (PL.move =<< pred . PL.length))) . PL.insertRight
14:58:33 <Gracenotes> that doesn't look too bad, actually
14:58:35 <Eridius> oh right, wrong one, but actually not so bad
14:58:46 <jethr0> *aahh*, multi-argument infix operations
14:58:53 <ddarius> monochrom: I have a daemon process called dons to do that.
14:58:56 <Eridius> I keep not being able to reason about the -> monad properly until after I see the point-free version
14:59:17 <monochrom> Your daemon process is speaking dissatisfaction, apparently :)
14:59:22 <pejo> ddarius, hm, ok. I have to read up about this. Thanks.
14:59:41 <Peaker> most math notations don't have anything but infix notations.. more than 2 args, they start putting the args _around_ the function
14:59:41 <monochrom> $ killall free-will
14:59:58 <ddarius> monochrom: That's it's mode to recruit new processes in a distributed network.
15:00:04 <Gracenotes> Eridius: you don't even need to know how it works... just look at the type :)
15:00:13 <jethr0> peaker: like what?
15:00:24 <Eridius> Gracenotes: I don't have type annotations in the middle of my expression :P
15:00:29 <Peaker> jethr0: integral, sum, product
15:00:32 <monochrom> like if x then y else z endif
15:00:37 <Peaker> jethr0: big greek letter with args all around it :)
15:00:37 <Eridius> but yeah, I should have been able to see how to insert the pred
15:00:51 <Gracenotes> it simply takes an argument, transforms it using one function, and feeds the transformed argument *and* the original argument to another function
15:01:25 <Gracenotes> > ((,) =<< length) "omfg :("
15:01:26 <lambdabot>   (7,"omfg :(")
15:01:35 <jethr0> > let (<*>) a b c = a*b*c in 1 <*> 2 3
15:01:36 <lambdabot>       Overlapping instances for Show (t -> t)
15:01:36 <lambdabot>        arising from a use of `s...
15:01:41 <lern2haskell> hey, can anyone tell me what's wrong with this function? http://rafb.net/p/Zxb2bz20.html  (besides most likely being horribly bad style)  The error I'm getting from ghci is in the paste
15:01:44 <dons> conal: you might like to look at http://www.haskell.org/haskellwiki/LambdaCubeEngine
15:02:13 <jleedev> > let (<*>) a b c = a*b*c in 1 <*> 2 $ 3
15:02:14 <lambdabot>   6
15:02:42 <jethr0> *brr*
15:03:27 <jethr0> > let (<*>) a b c d = a*b*c*d in (1 <*> 2) 3 4
15:03:28 <lambdabot>   24
15:03:36 <Gracenotes> @type (,,,,,,,,,,,,,,,)
15:03:37 <lambdabot> forall a b c d e f g h i j k l m n o p. a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p)
15:03:53 * jethr0 rolls on the floor laughing
15:04:16 <jleedev> > replicateM 4 "enough lambdabot spam"
15:04:17 <lambdabot>   ["eeee","eeen","eeeo","eeeu","eeeg","eeeh","eee ","eeel","eeea","eeem","eee...
15:04:18 <jethr0> @type (,) . (,)
15:04:19 <lambdabot> forall b a b1. a -> b -> (b1 -> (a, b1), b)
15:04:24 <jethr0> sorry
15:05:09 <Eridius> what's the darcs term for the most recent state of the repo (the equivalent to Git's HEAD)?
15:05:15 <jethr0> jleedev: now you have to fill the ensuing dead air with something witty!
15:05:33 <jleedev> > "something" >> "witty"
15:05:34 <lambdabot>   "wittywittywittywittywittywittywittywittywitty"
15:05:36 <nothingmuch> i think that's just a repo
15:05:41 <nothingmuch> though look into the patch context stuff
15:05:47 <nothingmuch> maybe there is a term in there
15:06:01 <Heffalump> are the unix and X11 packages expected to work on cygwin?
15:06:03 <nothingmuch> darcs' model is sort of like git with only one ref
15:06:17 <lern2haskell> :-/ anyone willing to look at my paste? it's only a 9 line function...
15:06:34 <Gracenotes> @. type run text.("("++).(++")") $ replicate 26 ','
15:06:36 <lambdabot> forall a b c d e f g h i j k l m n o p q r s t u v w x y z t28. a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t28 -
15:06:36 <lambdabot> > (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t28)
15:06:54 <nothingmuch> t28... cute =)
15:06:57 <Peaker> After using git for a while, I really like it -- but it has one big problem of artificial dependencies between revisions, even though there is no logical dependency
15:07:07 <bashyal>  lern2haskell:  that seems to work fine for me.
15:07:08 <jethr0> niiiice
15:07:09 <nothingmuch> Peaker: rebase --interactive
15:07:09 <Botje> lern2haskell: it's not lisp :)
15:07:15 <jethr0> good old meta-programming
15:07:18 <Peaker> nothingmuch: that's a workaround, not a solution
15:07:22 <nothingmuch> not really
15:07:25 <nothingmuch> it's just another POV
15:07:26 <bashyal>  myMax [1,2,3] gives me 3
15:07:28 <Botje> lern2haskell: make sure you're not mixing tabs and spaces
15:07:30 <nothingmuch> some dependencies are implicit
15:07:32 <Peaker> nothingmuch: yes, because I can't collaborate on a branch that I rebase
15:07:34 <nothingmuch> darcs --ask-deps mode is just as hacky
15:07:37 <lern2haskell> bashyal: really? i'm getting a syntax error
15:07:41 <jleedev> lern2haskell: you're mixing tabs and spaces
15:07:44 <lowmagnet> lern2haskell: yeah tabs in that paste
15:07:46 <lern2haskell> Botje: ah, I didn't know that was an issue in haskell
15:07:51 <lern2haskell> thanks guys
15:07:54 <lowmagnet> yw
15:07:57 <nothingmuch> you can collaborate if others are aware
15:08:06 <centrinia> lern2haskell, You can use curly braces and semicolons.
15:08:13 <nothingmuch> i would really like a pull mode that hashes the diffs
15:08:14 <Botje> lern2haskell: haskell is the reason i switched on expandtabs in vim
15:08:16 <jethr0> *yuch*
15:08:27 <Peaker> nothingmuch: I don't know how darcs does it - but I think git's way is not perfect. it shouldn't "need" rebases.  If you can cleanly rebase a branch, then why is it attached to a specific base revision? It should be a "floating" set of patches then :)
15:08:46 <nothingmuch> and if the set of patches is the same, it could accept any order
15:08:48 <Peaker> nothingmuch: At work we collaborate on branches, so "rebase" is not an option
15:08:54 <nothingmuch> (allowing you to pull from a rebased branch)
15:09:00 <nothingmuch> that would give all the goodness of darcs
15:09:09 <nothingmuch> but that's a UI feature
15:09:18 <nothingmuch> with darcs you can'
15:09:25 <nothingmuch> t address the entire state using one sha1
15:09:26 <Peaker> nothingmuch: can you come to #haskell-blah?
15:09:29 <nothingmuch> sure
15:09:43 <nothingmuch> sorry
15:10:53 <jleedev> "I like to pronounce >=> as 'fish'..."
15:11:23 <Deewiant> Well, how else? :-)
15:11:24 <centrinia> What do you call 'arrow' then?
15:11:38 <lowmagnet> Is FlexibleInstances new?
15:12:08 <Heffalump> lowmagnet: not very
15:12:40 <lowmagnet> Is RWH ch06 incorrect then?
15:12:49 <monochrom> (In fact I don't get any syntax error using lern2haskell's paste, verbatim, cut-n-paste.)
15:13:12 <Heffalump> lowmagnet: what page?
15:13:15 <monochrom> (I tried both hugs sept-2006 and ghc 6.8.2)
15:13:19 <lowmagnet> 153
15:13:36 <lowmagnet> monochrom: if you're using vi with haskell mode, there is a paste handler that fixes that i think
15:13:46 <lowmagnet> monochrom: i think yi does as well
15:13:54 <Heffalump> I don't see anything obviously wrong there - what specifically?
15:14:28 <lern2haskell> monochrom: wierd... that might be because I converted a tab to several spaces when things didn't line up in the paste (it did fine in vim).  I actually didn't realize whitespace was significant in haskell, not a problem, just, didn't know that
15:14:46 <lowmagnet> If i copy ch06/Overlap.hs verbatim, then try to :l it in ghci, I get an illegal instance declaration on (Int, Int)
15:15:25 <Heffalump> oh, right. I guess it must be then. It feels to me like I've been using it for ages, but I also tend to use the bleeding edge a lot.
15:16:06 <lowmagnet> it says it needs typevars instead of types
15:16:41 <lowmagnet> So I declare ummmm...{#- LANGUAGE FlexibleInstances -#}
15:17:07 <lowmagnet> err {-# #-} rather
15:17:28 <lowmagnet> beat my head in for like a half hour on that one
15:17:32 <Eridius> heh
15:18:41 <lowmagnet> I'm on 6.10 here
15:18:45 <lowmagnet> (ghci)
15:19:18 <ahamay42> Why does ghc 6.10.1 with --make name the output files Main.o instead of MyFileName.o?
15:19:45 <ahamay42> it might become a problem as I have mutliple programs in the same folder
15:20:00 <sw17ch> ahamay42, what command are you running?
15:20:19 <ImInYourMonad> is this correct: a mapping between categories is a way to translate a mathematicalproblem in one domain to a problem in another(wher it hopefully is easier to solve) without losing any information?
15:21:01 <ahamay42> ghc --make -outputdir gen/ghc/ -isrc-o gen/bin/prog src/Prog.hs
15:21:28 <sw17ch> you could just tack a -o on there to specify the output file
15:21:40 <ehird> Can lambdavm compile itself?
15:21:56 <ahamay42> will it also specefy the .hi basename?
15:22:04 <sw17ch> hmm... i'm not sure
15:22:07 <sw17ch> it usually works fine for e
15:22:09 <sw17ch> me
15:22:17 <sw17ch> i'm not sure what the problem you're having stems from
15:22:33 <grykgru> is it possible to translate programs written in procedural languages, to functional languages, vice versa, et al?
15:22:52 <ahamay42> I mean, I do already hace a -o option for my binary
15:22:58 <Heffalump> ahamay42: probably because your file has module Main where in it, or doesn't have any module specifier at all
15:23:00 <Botje> grykgru: GHC does functional -> procedural
15:23:08 <leadnose> grykgru, compilers do that all the time
15:23:08 <grykgru> Botje: ah?
15:23:15 <Botje> the other way round is probably possible, but I'm not familiar with that
15:23:25 <Botje> it's probably much more high-level anyway
15:23:31 <ahamay42> heffalump: yes the module is (implicitly) Main
15:23:35 <leadnose> oh, I didn't notice the other way around thing
15:23:51 <ahamay42> otherwise I couldn't make an executable out of it could I?
15:24:01 <Heffalump> I normally name my modules more descriptively and use -main-is
15:24:28 <Heffalump> another guess would be not to use --make
15:24:33 <ddarius> ImInYourMonad: No.
15:24:36 <ahamay42> oh, I didn't know that option
15:24:39 <ahamay42> I'll try that
15:24:54 <ahamay42> dropping --make makes the linking much more work
15:25:02 <Heffalump> yeah
15:25:10 <ahamay42> I have many dependencies
15:25:28 <Botje> grykgru: actually, look into SSA (single static assignment)
15:25:52 <Botje> it's an intermediate representation which is pretty close to functional programming
15:26:04 <Botje> (Andrew W Appel, "SSA is functional programming")
15:26:47 <Heffalump> be a bit careful with -main-is, it actually does some internal renaming so the module is called Main in the object file (though it should make the correctly named .o), so you can't also use the module imported from another one
15:27:56 <edwardk> @seen ddarius
15:27:56 <lambdabot> ddarius is in #haskell, #haskell-blah and #haskell-overflow. I last heard ddarius speak 3m 23s ago.
15:28:30 <grykgru> hm, Botje is SSA built into GHC?
15:29:19 <seliopou> Botje, that sound like something an erlang programmer would say...
15:29:41 <edwardk> grykgru: indirectly by compiling through gcc. most optimizations are done in ghc on core ;)
15:30:05 <grykgru> edwardk: I see
15:30:19 <ahamay42> thx heffalump, -main-is does the job for me
15:30:34 <Heffalump> cool. It does sound like bad behaviour on ghc's part, though.
15:31:10 <bmh> GHC objects and says I need an instance declaration Eq, but I was under the impression that ord would suffice here. Could someone push me in the right direction? http://pastebin.com/m2cf5603b
15:31:30 <ahamay42> my ghc installation feels a little weird in differend cases, too
15:31:35 <grykgru> BONUS: have you updated that picture book of yours, yet?
15:31:59 <Eridius> bmh: Ord a requires Eq a
15:32:03 <Eridius> ,src Ord''
15:32:05 <lunabot>  luna: Not in scope: data constructor `Ord'''
15:32:08 <ahamay42> but anyways, it runs :)
15:32:09 <Eridius> oh hrm
15:32:10 <Eridius> ,src Ord'
15:32:11 <lunabot>  luna: Not in scope: data constructor `Ord''
15:32:15 <ImInYourMonad> to define a new Monad, do I usr instance Monad X where?
15:32:19 <Eridius> @src Ord
15:32:19 <lambdabot> class  (Eq a) => Ord a  where
15:32:19 <lambdabot>     compare      :: a -> a -> Ordering
15:32:19 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
15:32:19 <lambdabot>     max, min         :: a -> a -> a
15:32:22 <Heffalump> i.e. you need an instance of Eq before you can write an instance of Eq.
15:32:29 <Heffalump> IM before you can write an instance of Ord.
15:32:42 <bmh> I thought that if I said (Ord n) it would imply (Eq n)
15:32:57 <Heffalump> 'fraid not
15:33:01 <bmh> it seems silly to write (Eq n, Ord n) /everywhere/
15:33:14 <Heffalump> oh, you don't need it in instance heads
15:33:24 <Heffalump> IM on the left-hand side of =>
15:33:29 <Peaker> bmh: I agree. could be nice if you could have "extends" relationship which isn't "subclass" but (I am a superset of that expressiveness)
15:33:36 <Eridius> bmh: you need it here because you're trying to define a new instance of Ord, and Ord requires that your datatype conform to Eq
15:33:38 <Heffalump> but you do need to make an instance of Eq for BinaryHeap n
15:34:02 <Eridius> bmh: the problem isn't that you need to declare Eq in your types, it's that you need to derive Eq (or create an instance of it) for BinaryHeap
15:34:11 <mauke> it's easy to do: instance Eq Whatever where a == b = compare a b == EQ
15:34:15 <ImInYourMonad> ddarius: no what?
15:34:38 <ddarius> [17:20] <ImInYourMonad> is this correct: a mapping between categories is a way to translate a mathematicalproblem in one domain to a problem in another(wher it hopefully is easier to solve) without losing any information?
15:35:04 <bmh> mauke: thanks!
15:35:14 <Eridius> bmh: ignore him, just derive Eq
15:35:51 <bmh> Eridius: that works too..
15:36:00 <mauke> Eridius: bad idea, unless you also derive Ord
15:36:09 <Eridius> mauke: and why is htat?
15:36:10 <Eridius> *that
15:36:32 <mauke> because you don't want a type where == and compare return different results
15:36:49 <Eridius> mauke: looking at his definition of Ord, I don't think that's an issue
15:37:06 <bmh> Eridius: I think he might have a point in the general case
15:37:30 <Eridius> sure, deriving Eq and manually writing Ord, you have to be careful that == implies compare -> EQ
15:37:40 <Eridius> or rather, == iff compare -> EQ
15:37:40 <mauke> let x = Node 0 0 Leaf Leaf; y = Node 0 1 Leaf Leaf in (compare x y, x == y)
15:37:49 <bmh> the lighter the gun the programmer has, the better
15:38:03 <bmh> muzzles tend towards feet, you know.
15:38:14 <Eridius> oh mauke, you're right, I wasn't paying enough attention to the Node case
15:38:41 <Eridius> although that does make me wonder why compare is defined as only looking at the first arg to Node
15:38:48 <bmh> oh christ, why am I writing "compare n2 n1"
15:38:50 <ImInYourMonad> ddarius: ok is there a name for what i said :)?
15:38:56 --- mode: ChanServ set +o glguy
15:38:58 --- mode: glguy set -b *!*@c211-30-10-1.rivrw2.nsw.optusnet.com.au!##fix-your-connection
15:39:05 --- mode: glguy set -b *!*@195.60.175.242
15:40:02 <bmh> Eridius: because it's a heap.
15:40:21 --- mode: glguy set -o glguy
15:41:05 <Eridius> bmh: you've defined "two heaps are identical if their root element is the same"
15:41:38 <ddarius> ImInYourMonad: Not to my knowledge.  It's a pretty vague and informal idea.
15:42:14 <bmh> Eridius: I think this might be reasonable.
15:42:43 <Eridius> bmh: seems like a pretty odd definition of equal
15:42:51 <bmh> perhaps just sticking to ordering makes more sense
15:43:08 <Eridius> except the ability to order requires equality
15:44:00 <bmh> if the heap derives Eq and I define instance ord to just examine the heads, I think that's "correct"
15:44:40 <Eridius> well no, that would cause the problem mauke mentioned, where compare returning EQ doesn't necessarily mean that == returns True
15:45:28 <Eridius> I don't think you should be defining Ord for BinaryHeap in the first place, though
15:45:42 <Eridius> the idea that an entire heap could be less than another heap isn't very well-defined
15:45:57 <bmh> perhaps I should just create a new typeclass called "Rank"?
15:46:12 <Eridius> why do you need a new typeclass?
15:46:24 <Eridius> you could just define a new method compareHead that takes two BinaryHeaps and does the comparison that you're trying to use Ord for
15:46:49 <bmh> sure. I'll do that.
15:48:15 <ImInYourMonad> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=2481#a2481 <- a completely useless monad but it isjsut for my poor brain to udnerstand it. it doesnt work though so...how can i make it work?
15:48:40 <mauke> kind error
15:48:53 <mauke> return has a completely wrong type
15:49:15 <mauke> so does (>>=); this looks more like a monoid
15:52:27 <rabideejit> aha! I found why my package wasn't linking.  I forgot to mention the other, hidden modules in Other-modules.
15:52:30 <Eridius> ImInYourMonad: what mauke said, but also even if you fixed the kind error your definition there would fail the Monadic laws
15:53:21 <mauke> ImInYourMonad: the first thing you need is a parameterized type, like data Foo a = ...
15:53:27 <Eridius> actually there's also a type error in >>=
15:53:35 <mauke> you also need a singleton constructor, i.e. something that wraps a value in Foo
15:55:12 <idnar> that definitely looks more like a monoid than a monad
15:55:31 <ImInYourMonad> so ou can trick the Monad? ie define a Monad instance that isnt a monad really?
15:55:41 <mauke> sure
15:55:42 <idnar> or at the very least, that definition of (>>=) should be mplus
15:56:01 <lowmagnet> Does anyone here use yi?
15:56:59 <lowmagnet> if so, does "=>" look like "=" once typed?
15:57:09 <Eridius> lowmagnet: it actually uses a unicode symbol
15:57:24 <lowmagnet> which char?
15:57:31 <Eridius> โ
15:57:35 <lowmagnet> ok
15:57:41 <lowmagnet> maybe i need to change font again
15:57:43 <Eridius> that's U+21D2, or RIGHTWARDS DOUBLE ARROW
15:57:44 <conal> dons: was just looking at the LambdaCubeEngine page.  i'm curious about how elegant & functional it is.
15:57:47 <Glenjamin> hi guys, would anyone be able to point me towards some up-to-date documentation on using HUnit (or an example of a test file) ?
15:57:51 <lowmagnet> i had to change font to get -> to work
15:58:02 <conal> dons: did you see my earlier remarks about DList coding?
15:58:03 <Eridius> ImInYourMonad: why do you want a Monad? It looks like all you really want is a Monoid
16:01:10 <lowmagnet> ah, iTerm isn't rendering correctly. No problem with Terminal.app
16:01:47 <dons> conal: ah yes.
16:01:54 <dons> conal: happy to accept patches
16:02:04 <dons> particularly if they're backwards compat
16:02:20 <conal> dons: will do.  :)
16:02:51 <Eridius> lowmagnet: iTerm sucks anyway :P
16:03:07 <dons> we really need a tutorial that's super quick, for building some canonical "real" program (e.g. network+database+gui) , consisting entirely of composing libraries
16:03:10 <ImInYourMonad> Eridius: well if I could have a Monoid id be happy too. i want a monad because im trying to understand them.
16:03:16 <lowmagnet> Eridius: I like it a lot more than terminal
16:03:25 <Eridius> lowmagnet: why?
16:03:26 <dons> just to point people to, if they want to write a gui app
16:04:21 <lowmagnet> Eridius: I've not used terminal much since 10.1 days. I'll give it a shot again though
16:04:27 <ImInYourMonad> i am fairly productive in haskell now but i want to udnerstand the theory better and it seems i never really run into a place where i need to define one
16:04:27 <ImInYourMonad> so i made up a stupid example
16:05:12 <Eridius> lowmagnet: completely rewritten in 10.5
16:05:16 <Eridius> it's a brand new app
16:05:35 <Eridius> the only reason to ever use iTerm was tab support, and 10.4 (and possibly 10.3) had tabs
16:05:45 <lowmagnet> ok, i'm convinced :)
16:06:04 <lowmagnet> you had me at rewriteen
16:06:17 <lowmagnet> err pretend i spelled that right
16:06:34 <Eridius> heh
16:07:39 <conal> ImInYourMonad: Monad is a type *constructor* class.  Vector is a type, not a type constructor.
16:07:54 <trofi> @hoogle isDirectory
16:07:54 <lambdabot> No results found
16:07:56 <conal> ImInYourMonad: if you abstract out Double, you can make it a monad
16:08:08 <trofi> @hoogle ':: FilePath -> FooStuff'
16:08:08 <lambdabot> Parse error:
16:08:08 <lambdabot>   --count=20 "':: FilePath -> FooStuff'"
16:08:08 <lambdabot>              ^
16:08:14 <trofi> @hoogle :: FilePath -> FooStuff
16:08:15 <lambdabot> Warning: Unknown type FooStuff
16:08:15 <lambdabot> Prelude error :: String -> a
16:08:15 <lambdabot> Debug.Trace trace :: String -> a -> a
16:08:17 <bmh> Eridius: I fixed it. I explicitly check head equality and if that falls through then I drop down to relying on ordering
16:08:35 <dons> hey guys, did you know Arch has 160 haskell *applications* packaged?
16:08:39 <dons> that's kinda cool.
16:09:03 <Heffalump> is there a list of them somewhere?
16:09:07 <Eridius> bmh: if you're still defining an instance of Ord on BinaryHeap that works that way, then you *still* don't have == iff compare -> EQ
16:09:11 <Heffalump> (separated from libraries)
16:09:15 <dons> Heffalump: yeah, gimme a sec.
16:09:17 <conal> ImInYourMonad: and in that case, i suggest Functor, then Applicative, then Monad, to work from simple/general to complex/specific.
16:09:23 <dons> oh, there's more if we count apps bundled with libraries
16:09:50 <monochrom> Such as the SAT solver written in Haskell. :)
16:10:24 <ImInYourMonad> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=2481#a2484
16:10:51 <Eridius> SAT solveR?
16:11:13 <dons> there's a few sat solvers
16:11:18 <Eridius> what's SAT in this context?
16:11:28 <bmh> the standardized aptitude test, duh.
16:11:32 <monochrom> I totally predicated your reaction. :)
16:11:37 <Eridius> ImInYourMonad: the `singleton' function is unnecessary, what he meant was you need a singleton constructor, which you already have in the form of Vector
16:11:45 <Eridius> bmh: hence "in this context" :P
16:11:58 <Baughn> > (enumFromTo 2 >=> enumFromTo 1) 5
16:11:59 <lambdabot>   [1,2,1,2,3,1,2,3,4,1,2,3,4,5]
16:12:00 <bmh> Eridius: hence my ribbing.
16:12:03 <Eridius> ImInYourMonad: also, your type error comes from the use of ++
16:12:16 <ImInYourMonad> ok
16:12:30 <ehird> Main.hs:385:2:
16:12:30 <ehird>     Ambiguous type variable `e1' in the constraint:
16:12:31 <ehird>       `Exception.Exception e1'
16:12:31 <bremner> Eridius: see e.g. http://paste.debian.net/30732
16:12:33 <ehird>         arising from a use of `Exception.catch' at Main.hs:(385,2)-(387,56)
16:12:34 <Eridius> ImInYourMonad: what is the type of v1 in your definintion of >>=?
16:12:35 <ehird>     Probable fix: add a type signature that fixes these type variable(s)
16:12:59 <Eridius> bremner: you realize that's a paste consisting of the text "sat.hs", right?
16:13:17 <vixey> lol
16:13:18 <ehird> :s
16:13:20 <ehird> when compiling ghc
16:13:33 <ehird> Well, lambdavm
16:13:33 <Eridius> http://en.wikipedia.org/wiki/Boolean_satisfiability_problem ?
16:13:39 <bremner> dang I hate that script. The rest is an exercise for the reader :-P
16:13:45 <bremner> ja
16:14:18 <ImInYourMonad> i have no idea
16:14:27 <Eridius> ImInYourMonad: what is the type of >>= itself?
16:14:31 <ImInYourMonad> does it even make any sense to define monads for vectors?
16:14:46 <Eridius> doubtful
16:14:54 <ImInYourMonad> (>>=) :: (Monad m) => m a -> (a -> m b) -> m b
16:15:00 <bremner> ok, here is a quick and dirty SAT solver http://paste.debian.net/30733
16:15:04 <Eridius> ImInYourMonad: ok, so what's the type of the second arg to (>>=) ?
16:15:11 <bremner> (this time, with actual content)
16:16:23 <ehird> The problem is in ghc-pkg/Main.hs
16:16:24 <ehird>   str <- readFile filename `Exception.catch` \_ -> return emptyPackageConfig
16:16:30 <ehird> Why is that invalid...?
16:17:06 <ImInYourMonad> (a -> m b)
16:17:08 <ImInYourMonad> so a function
16:17:21 <Eridius> ImInYourMonad: yes
16:18:16 <sjanssen> ehird: changes due to extensible exceptions
16:18:20 <ehird> ah
16:18:30 <Eridius> ImInYourMonad: Vector makes no sense as a monad because there's no meaning besides the data that a Vector encapsulates. For example, there's absolutely no point to "v >> v2" (where v, v2 :: Vector a)
16:18:36 <ehird> Is there a way to quick-fix it?
16:18:42 <ehird> oh wait
16:18:45 <ehird> Exception -> OldException, right?
16:19:01 <ehird> that worked :)
16:19:07 <OscarZ> do you think it's possible to model the conscious mind with a pure functional language like haskell?
16:19:20 <rabideejit> ehird: I kind of like the change because it forces me to think about what sort of exception I'm expecting.
16:19:27 <ehird> OscarZ: it's as possible as it is in any turing complete language
16:19:28 <Baughn> OscarZ: Sure. Haskell's turing-complete.
16:19:40 <ehird> I think yes, some others [mainly religious] think no.
16:19:58 <Baughn> Well, the /laws of physics/ appear to be turing-complete, so..
16:20:10 <ehird> Baughn: massively parallel :-D
16:20:11 <Baughn> Anyway, he just asked it to model a conscious mind, not to actually create consciousness. :P
16:20:18 <ehird> err, same thing?
16:20:24 <Baughn> Maybe
16:20:31 <OscarZ> seems that you've thought about the same thing :)
16:20:38 <Baughn> I'd say creating a consciousness in a lazy language is a massive headache, too. ;)
16:21:01 <ImInYourMonad> Baughn: isnt the question if the are more than turingcomplete
16:21:06 <ehird> ImInYourMonad: no
16:21:07 <FunctorSalad_> Eridius: with Vector a := Map a Real (element of a vector space with a as Basis), Vector is nice monad :)
16:21:22 <ehird> ImInYourMonad: why do you think your brain is superturing?
16:21:26 <wli> Depending about what you believe about the nature of consciousness, the idea of creating one may very well be nonsensical.
16:21:44 <Eridius> FunctorSalad_: hehe
16:21:45 <ehird> wli: ... ergo, giving birth is impossible
16:21:46 <OscarZ> im not expert on the subject.. but haskell being "turing-complete" puts it on the same ground with the more "loose" languages like c, c++, java etc ?
16:21:49 <Baughn> ImInYourMonad: The laws of physics are only turing-complete, and it's impossible to create a superturing system as part of a pure-turing one
16:21:54 <ehird> and everyone is hallucinating their conciousness
16:21:57 <ehird> OscarZ: yes
16:22:02 <rabideejit> OscarZ; and brainfuck
16:22:09 <ehird> :-D
16:22:21 <ImInYourMonad> ehird: because i can understand things that are not formal systems?
16:22:22 <Baughn> wli: I would argue that that is nonsensical, but it'd take all night
16:22:28 <ehird> ImInYourMonad: and turing complete languages can't?
16:22:36 <wli> I'm not aware of what superturing systems are.
16:22:44 <Peaker> Baughn: what is a super-turing machine? One that solves the halting problem for turing machines?
16:22:49 <Baughn> wli: Turing oracles, for a simple one
16:22:54 <ehird> Peaker: there are many super turing classes
16:22:55 <Baughn> Peaker: That's one of them
16:23:05 <ehird> None of them have been implemented :P
16:23:13 <Baughn> None of them can be implemented. :P
16:23:19 <Peaker> Baughn: the universe might already be super-turing, for all we know
16:23:21 <ehird> Baughn: that is not certain
16:23:21 <ImInYourMonad> what about them superreucrisve procedures?
16:23:22 <wli> FunctorSalad: Hmm, what does your linalg lib look like?
16:23:28 <ehird> there may be implementable super-turing machines
16:23:30 <ehird> we just haven't found one yet
16:23:33 <Baughn> Peaker: It might. And the moon might be made of yellow cheese.
16:23:46 <psygnisfive> ehird what are you doing here
16:23:46 <Peaker> Baughn: what evidence is there that it isn't?
16:23:50 <psygnisfive> stop being silly
16:23:56 <ehird> psygnisfive: what?
16:23:56 <Baughn> Peaker: There is no evidence that it is
16:24:06 <Baughn> Peaker: Absence of evidence is evidence of absence, as a matter of fact, so..
16:24:08 <Peaker> Baughn: there is evidence that the moon isn't made of yellow cheese, though
16:24:15 <ImInYourMonad> well maybe consciousness is an illusion, but i can build a computer but a computer cant build me unless a human tells it how to
16:24:24 <FunctorSalad_> wli: I haven't implemented that thing myself yet but I think it's on hackage. mathematically it is an example of a free functor -| forgetful functor adjunction
16:24:27 <wli> FunctorSalad: Can it cope with e.g. fields of rational functions?
16:24:28 <dons> Heffalump: http://haskell.org/haskellwiki/Arch_Linux/Applications
16:24:28 <ehird> ImInYourMonad: You are completely misunderstanding the entire field of AI; please stop.
16:24:28 <Baughn> Peaker: Sure, so the probability is higher than that of a cheesy yellow moon
16:24:38 <dons> Heffalump: raw dump of applications written in Haskell, packaged for ARch
16:24:41 <psygnisfive> ImInYourMonad: sure a computer can build you. it just has to run Evolution for 4 billion years.
16:25:02 <idnar> ImInYourMonad: if a computer builds you, and you build a computer, then it was the computer that told the human how to build a computer :P
16:25:20 <rabideejit> the computer built me from age 16 *sigh*
16:25:27 <Heffalump> dons: ta
16:25:34 <omnihil> ImInYourMonad, you can't build a computer unless a human tells you how. that puts you in the same class as a computer.
16:26:19 <wli> omnihil: If I was ever far enough out to be able to build one otherwise uninstructed I am no longer.
16:26:23 <FunctorSalad_> wli: yeah, (>>= f) is just "extend f by linearity"... since every vector is just a linear combo of finitely many basis vectors, there's no problem with infinitary stuff (given that the operations on your field are computable :))
16:26:32 <Baughn> omnihil: Well, no, since he can do it with asymptotically less information than the computer would need
16:26:43 <ImInYourMonad> where can i see the source for data.Maybe?
16:26:51 <Baughn> omnihil: Unless you start by building an AI into the computer, in which case it may well be the other way around
16:26:52 <FunctorSalad_> wli: although it's not a real haskell monad because of the "Ord a" constraint for Map
16:26:58 <wli> FunctorSalad: I just want fields of rational functions, algebraic number fields, algebraic extensions of Q(x), etc.
16:27:09 <wli> FunctorSalad: No RMonad?
16:27:26 <FunctorSalad_> RMonad should work
16:27:27 <blackdog> dons: GC stats done? trying to think of something to give a talk on for FP-Syd, and evidence is always nice
16:27:28 <rabideejit> Just because a dog can't do match doesn't mean he's not smarter than you in the field and forest.
16:27:47 <rabideejit> *math
16:27:48 <rabideejit> I just didn't use no double negative. Don't not damn.
16:27:55 <ImInYourMonad> ehird:well educate me then. im not disucssing AI,im discussing consciousness.
16:28:02 <TomMD> Baughn: network-data is uploaded with definitions for IPv4, IPv6 (not complete), UDP, and TCP.  Its still a work in progress - as discussed, the API is subject to massive change.
16:28:08 <ImInYourMonad> can we build something that is smarter than ourselves?
16:28:09 <ehird> ImInYourMonad: A working strong AI _is_ a conciousness.
16:28:12 <OscarZ> i think einstein was on the spot... that consciousness is an illusion, albeit persistent one.. it's quite difficult to separate oneself from it and think about it scientifically
16:28:24 <ehird> As for the latter question; depends on if you're a singularitarian or not.
16:28:26 <OscarZ> but then.. is subjectivity real ?
16:28:26 <bmh> I reject Searle's terminology
16:28:29 <FunctorSalad_> computability theory is massively irrelevant to consciousness. I can build you an AI with a *finite automaton* if it's big enough, lol ;)
16:28:44 <ehird> FunctorSalad_: ssh, stephen wolfram might hear you and have a heart attack
16:28:45 <FunctorSalad_> (reality is finite and stuff)
16:28:50 <ImInYourMonad> "A working strong AI _is_ a conciousness." es but by definition, that doesnt sa anthin rea๖y
16:28:58 <ehird> ImInYourMonad: er.
16:29:05 <OscarZ> bmh: am i using Searle's terminology?
16:29:05 <rabideejit> FunctorSalad_: It's true.
16:29:20 <Baughn> ImInYourMonad: But that sentence isn't /based/ on your definition
16:29:22 <bmh> OscarZ: "Strong AI"
16:29:22 <rabideejit> I agree with Searle's terminology, but I apply it to humans too.
16:29:30 <Baughn> ImInYourMonad: You have to read it using the same definitions the writer used
16:29:52 <Baughn> TomMD: Righto. I'll take a look.. after I wake up. Time to pluck my eyes out and become unconscious.
16:29:55 <rabideejit> Searle couldn't accept that humans were anything more than a black-box.
16:30:03 <Heffalump> lol, reddit post about jdh:
16:30:04 <Heffalump> >> For all your long trolling experience, you're not
16:30:04 <Heffalump> >> very good at baiting when things get outside the
16:30:04 <Heffalump> >> technical realm.
16:30:39 <lowmagnet> Heffalump: linky?
16:30:56 <OscarZ> what about subjectivity? "the feel" of what we are in our heads? ;-)
16:30:58 <Heffalump> http://www.reddit.com/r/programming/comments/84sqt/dear_reddit_i_am_seeing_12_articles_in/c089y2x
16:30:58 <omnihil> doesn't "black box" imply that there is something more we don't know?
16:31:07 <rabideejit> Heffalump: kinda the opposite of the "man in the pub"
16:31:38 <Baughn> @seen byorgey
16:31:38 <lambdabot> I saw byorgey leaving #haskell-blah, #xmonad and #haskell 1m 20d 18h 2m 24s ago, and .
16:31:51 <ehird> utils/Binary.hs:466:13: Not in scope: data constructor `S#'
16:31:51 * bremner runs away before the talk turns to God
16:31:55 <ehird> Where is S#/J#?
16:31:55 <Baughn> ..what. I talked to him yesterday.
16:32:04 <ehird> Baughn: god? :P
16:32:05 <Baughn> Didn't I?
16:32:12 <Baughn> ehird: Byorgey
16:32:17 <ehird> i was joking
16:32:35 <Baughn> I talk to Eris every friday, so that's three days ago
16:32:45 <rabideejit> omnihil: I mean in the chinese room sense - if I remember rightly, Searle said that a person could sit in a room which had a massive chinese dictionary and translate from english to chinese, but never actually know the language -- he likened that to machine intelligence.  I think he's right but it would shock of him to concieve of himself as something so "dumb".
16:33:47 <idnar> rabideejit: the way I see it, if you're "simulating" intelligence perfectly, there's no difference
16:33:57 <Baughn> Well, of course. At 200Hz, the brain /is/ mostly just cache lookups.
16:34:04 <wli> FunctorSalad: Well, vector space affairs for algebraic extensions of K(x) where K is an extension of Q are already rather painful. Finding the basis is not very easy for me.
16:34:14 <dons> Heffalump: cleaned up a bit, http://haskell.org/haskellwiki/Arch_Linux/Applications
16:34:15 <idnar> rabideejit: I don't find any of the suggestions of what a "real intelligence" could do that a "machine intelligence" couldn't convincing
16:34:36 <idnar> oh man, I really shouldn't get sucked into this
16:34:46 <Baughn> @seen byorgey_
16:34:46 <lambdabot> byorgey_ has changed nick to byorgey.
16:34:46 <lambdabot> I saw byorgey leaving #haskell-blah, #xmonad and #haskell 1m 20d 18h 5m 31s ago, and .
16:34:50 <wli> idnar: I think they usually turn to the arts.
16:34:51 <OscarZ> rabideejit: i think his "argument" was based heavily on degrees of complexity and speed which he used to make it appear unfeasible
16:34:53 <rabideejit> idnar: I agree.  I just think Searle's argument against machine intelligence is actually good metaphor for human thought.
16:35:00 <blackdog> you get the obvious reductio ad absurdum of having a group of connected men in chinese rooms, each of which has the much simpler job of reacting as a single neuron would...
16:35:05 <FunctorSalad_> wli: I meant you just set V a := vector space of formal linear combinations of elements of a
16:35:29 <wli> FunctorSalad: I'm in a bit deeper doo doo than that, I guess.
16:36:08 <rabideejit> blackdog: I like your thought, do get it, and agree it is a good thought indeed!
16:36:18 <FunctorSalad_> wli: well, that monad doesn't help you actually finding a basis of your vector space :)
16:36:32 <Valodim> @src fix
16:36:32 <lambdabot> fix f = let x = f x in x
16:36:33 <wli> FunctorSalad: I'll in particular need it to do some linear equation solving to implement division in the algebra after the smoke clears wrt. bases.
16:36:37 <ehird> ghc: unrecognised flags: -no-link-chk  <-- Oh brutha.
16:36:42 <OscarZ> rabideejit: using something strongly semantic like language (and brain-computationally complex) slowered down to bullet-time..
16:37:11 <Baughn> @msg byorgey In the "monad transformers" chapter you mention that applicatives are easier to compose - okay, I can maybe see that, but you should provide an example of that too at some point before that
16:37:11 <lambdabot> Not enough privileges
16:37:32 <bmh> huh. I'm getting a "these aren't the droids you're looking for" problem out of cabal
16:37:49 <bmh> There is no available version of ghc that satisfies >=6.8.2 && <6.13, ghc --version: The Glorious Glasgow Haskell Compilation System, version 6.10.1
16:38:07 <bmh> 6.8.2 <= 6.10.1 < 6.13
16:38:24 <wli> FunctorSalad: It's not so different from getting (2^(1/2) + 3^(1/3))/(2 - (2^(1/2) - 3^(1/3))^(1/5)) and trying to express that as a linear combination of elements of an integral basis elements for whatever the smallest extension of Q is you can figure out.
16:38:38 <FunctorSalad> :O
16:38:39 * BMeph|work still gets a kick over dons and his `cabal install pony` line...
16:38:52 <wli> FunctorSalad: In fact, that's a sub-problem.
16:39:15 <dcoutts> bmh: run ghc-pkg check, is the ghc package broken? Cabal ignores broken packages
16:39:20 <Baughn> BMeph|work: Now run the program. :D
16:39:36 <bmh> package ghc-6.10.1 has missing dependencies:
16:39:45 <bmh> neat, it's missing 0 dependencies!
16:40:17 <dcoutts> bmh: the reporting sounds wrong, it's probably really missing some deps, perhaps indirectly
16:40:22 * comexk can't figure out how to extract a range (say, items 3-5) of a list
16:40:41 <wli> comexk: [xs !! k | k <- [3..5]]
16:40:46 <wli> comexk: Where xk is your list.
16:40:49 <dcoutts> bmh: look for any packages where the exact same version is registered both in the user and global package dbs. See ghc-pkg list
16:40:55 <wli> comexk: Where xs is your list.
16:41:00 <OscarZ> you guys obviously have no problems with numbers... what do you think things like numbers really are? are they really some fixed Platonic ontological nodes or do you have more "scientific" approach to them?
16:41:07 <FunctorSalad> (don't do that for 3 > 10 or so ;))
16:41:16 <omnihil> oscarz, they are "really" numbers.
16:41:25 <comexk> wli: any built-in shorter way?
16:41:25 <BMeph|work> Baughn: I have - it even works in een-doze! ;)
16:41:26 <Baughn> OscarZ: http://brage.info/~svein/luminous.pdf
16:41:30 <wli> OscarZ: Um, I'm talking precisely about what problems I'm having with numbers.
16:41:30 <dcoutts> bmh: blow away the user version if you find any
16:41:33 <beelsebob> comexk: range k l = take (l-k) . drop (k-1)
16:41:35 <BMeph|work> Er, *Ween-doze
16:41:41 <rabideejit> OscarZ:  I label my fingers things like e, pi, f(g(x)) so I don't get confused.
16:41:48 <wli> comexk: drop 2 . take 3 $ xs
16:42:14 <bmh> dcoutts: nada. I have four packages in my user install and none of the appear in global
16:42:14 <dcoutts> bmh: you should be able to unbreak the ghc package that way, though you may need to rebuild other things that depended on the things you unregister
16:42:18 <wli> comexk: What beelsebob said.
16:42:46 <bmh> though I am happy to just wipe out user, if that will make the world right again
16:42:55 <comexk> even that is a lot bigger than, say, python some_list[3:6]
16:43:03 <dcoutts> bmh: perhaps you can hpaste the ghc-pkg list output
16:43:04 <comexk> I guess I can just make a function :p
16:43:26 <dcoutts> bmh: every time I've seen this problem, that's been the cause.
16:43:41 <bmh> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2486
16:44:21 <OscarZ> wli: i thought mathematicians loved abstractions :)
16:44:29 * FunctorSalad prefers just setting the global prefix to his home dir ;)
16:45:27 <Glenjamin> hello, does anyone know how to assert that a function will error using HUnit?
16:45:28 <dcoutts> bmh: hmm, that is strange indeed.
16:45:51 <ehird>     Failed to load interface for `Data.Array':  <- Huh? Why would that ever happen?
16:46:00 <Heffalump> no profiling libs?
16:46:19 <bmh> dcoutts: I'll live. I can find someone locally to have a look
16:46:24 <ehird> Heffalump: No, no...
16:46:46 <dcoutts> bmh: I'm not sure what is going on there, ghc-pkg and cabal even use independent methods to decide if packages are broken.
16:47:01 <bmh> ghc /is/ in brackets
16:47:14 <dcoutts> bmh: yes, {} meaning broken
16:47:29 <dcoutts> bmh: but all the things it depends on are present
16:47:42 <dcoutts> and none of them are marked broken
16:50:19 <ehird> does anyone know why I'd get Failed to load interface for  for base lib packages?
16:50:39 <Baughn> > 2 `mappend` 3
16:50:40 <lambdabot>   Add a type signature
16:50:47 <Baughn> > 2 `mappend` 3 :: Int
16:50:48 <lambdabot>       No instance for (Monoid Int)
16:50:48 <lambdabot>        arising from a use of `mappend' at ...
16:51:10 <Heffalump> > Sum 2 `mappend` Sum 3 :: Sum Int
16:51:11 <lambdabot>   Sum {getSum = 5}
16:51:14 <rabideejit> ehird: hmm, it seems all too familiar... in what sort of context are you getting this error?
16:51:22 <ehird> Compiling an old ghc
16:51:30 <ehird> Failed to load interface for `Data.PackedString':
16:51:30 <ehird> Failed to load interface for `Data.Array':
16:51:32 <ehird> etc
16:52:50 <Igloo> dcoutts: Looks to me like it's missing Cabal-1.6.0.1
16:53:18 <dcoutts> iggly: doh! so it is. I misread
16:53:21 <rabideejit> ehird: It just reminds me of a sad time when I borked gentoo.  But I'm sorry, I have no idea.
16:53:25 <Nafai> Is it true that I can get :info to show me where the a given function is defined?
16:53:33 <rabideejit> or :i
16:53:48 <dcoutts> bmh: Igloo is right, it's broken because the Cabal-1.6.0.1 package got unregistered.
16:53:48 <Nafai> What do I have to do to get this to work?
16:54:01 <dcoutts> oh, he left
16:54:02 <Igloo> dcoutts: He's gone
16:54:20 <rabideejit> Nafai: it works for me just to load ghci and type something like :i tail
16:54:49 <Nafai> rabideejit: All I get it this: "-- Defined in GHC.List"
16:55:12 <rabideejit> Nafai: me too.  I guess you were looking for a line number
16:55:16 <Nafai> Yeah
16:56:22 <mreha> if a girl is forgiving about the fact that i havent spoken to her in over a year, and last time i said anything to her it was an insult, do you think she likes me?
16:56:55 <mreha> boys, i wont be coming home tonight!
16:57:12 <rabideejit> Nafai: I guess it would be useful in debugging programs with bad documentation, like HAppS, but I usually just grep the source.
16:57:26 <RamzaB> is there a debugger for haskell?
16:57:41 <mreha> can anyone think of a case where if two polygons are overlapping, one point of one shape wont lie in the other
16:57:45 <wli> ghci
16:57:47 <mreha> RamzaB: use ghci
16:57:52 <ImInYourMonad> these Monads are in my head!
16:58:00 <ImInYourMonad> forkingBrain
17:00:31 <rabideejit> Mreha:  What do you mean, maybe I'm dumb but I read that as - "Do you mean if two curves 3d intersect eachother?"
17:01:49 <rabideejit> Gee that made no sense.  What I mean to say is, do you mean "If two 3d curves intersect eachother, will one point on one curve not exist on another?"
17:01:51 <mreha> 2d polygons, if one polygon is overlapping the area marked out by the points of the other, is there are case where none of the points in either polygon lies inside the area of the other
17:01:56 <comexk>     Couldn't match expected type `Integer' against inferred type `Int'
17:02:30 <rabideejit> comexk: fromIntegral, or start explicitly with either one or the other from the beginning.
17:02:33 <mreha> yes, but in 2d, and with polygons, straight lines segments connected ot make a closed space
17:02:50 <gwern> so, kind of curious. anyone here familiar with the game of Zendo?
17:04:01 <rabideejit> well, if set intersects, set b then some members of set b will be members of set a, if you see what I mean
17:04:53 <Baughn> >  (\a b -> (,) <$> a <*> b) <$> Just [1..2] <*> Just [1..3] -- Is there a nicer way of combining applicatives like this?
17:04:54 <lambdabot>   Just [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3)]
17:06:04 <Baughn> > liftA2 (,) <$> Just [1..2] <*> Just [1..3]
17:06:05 <lambdabot>   Just [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3)]
17:06:10 <Baughn> Oh...
17:06:11 <gwern> part of zendo is expressing the rule you think all the sequences have been generated according to; I was wondering how the user of a zendo program would express their rule. presumably in some sort of code - '\pieces -> all (isRed && not upsideDown)' - but I was wondering how y'all would do it in some way lighterweight than calling the GHC API
17:06:45 <blackdog> i think there was an attempt at a python compiler a while ago...
17:06:56 <blackdog> sorry, wrong chan
17:07:59 <rabideejit> gwern:  It sounds like an interesting networked multiplayer adventure perhaps.
17:09:04 <gwern> I was vaguely thinking perhaps I could derive read & show & eq on some datatype which encodes a basic logic, so the user would input 'ALL [IsRed, Not (UpsideDown)]', and then on doing a Read of user input I could do == on the actual rule the program was using, but I dunno if that's impossibly clunky or not
17:10:43 <edwardk> gwern: well, the issue is that one party expresses the function that they think the unspoken arrangement is equivalent tand the other tries to prove the function wrong, right?
17:11:09 <edwardk> gwern: so whats wrong with just using arbitrary functions through a lambdabot-like api
17:12:28 <gwern> edwardk: well, there's the safety issue (a game just shouldn't be able to delete your computer), there's the issue of checking against the used rule (does one check by running QC a couple hundred times?), and there's the executable size
17:12:46 <MarcWeber> ?where network-bytestring
17:12:46 <lambdabot> I know nothing about network-bytestring.
17:12:53 <gwern> and I guess it'd limit its audience to haskellers as well
17:14:06 <edwardk> gwern: haven't deleted lambdabots computer yet ;)
17:14:09 <rabideejit> gwern:  I think some sort of DSL is needed.... unless you could warp the game slightly - have it based around matrices where the players have to guess some obscure transform.  But that could take all day.
17:14:34 <edwardk> and i thought the person who supplied the original rule when playing a game like that got to try to provide a counter example themselves.
17:14:41 <edwardk> that makes it multiplayer
17:15:00 <rabideejit> I guess taking all day isn't an issue for the buddha.
17:15:21 <gwern> edwardk: yeah, cuz mueval takes like 6 different security techniques
17:16:16 <gwern> edwardk: typically yes the master in zendo will provide a counterexample; the 'mondo' is also somewhat multiplayer
17:16:43 <edwardk> provide quick refutation with quickcheck perhaps by testing both the original function and the one they provide and then when it passes 100 make the master provide a counter example or lose
17:16:48 <zachk2> is zendo zen or that japanese sword art
17:17:35 <gwern> zachk2: in this context neither
17:18:14 <gwern> edwardk: I'm thinking from the perspective of having the computer be the master and all the players be humans
17:18:39 <gwern> depending on what you're guessing on, a decent AI player is a Hard problem :)
17:18:49 <edwardk> think 'web 2.0' ;)
17:19:04 <edwardk> anyways losing consciousnes, later man
17:20:46 <rovar> what does the ! mean in constructors?
17:20:54 <gwern> strict
17:21:03 <rovar> mkay
17:21:14 <Peaker> is the bug augustss mentioned about FFI allocations for Storables fixed?
17:32:14 <rovar> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1911#a1911
17:33:15 <Botje> you probably mean Get (Either String Bool)
17:33:20 <ImInYourMonad> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=2490#a2490 i have mself a monad!
17:33:44 <Botje> rovar: also note that that first case (bson_bool) will _ALWAYS_ match
17:34:22 <rovar> bson_bool is defined already
17:34:24 <orzo> hello
17:34:41 <orzo> is ghc available for os x beta "snow leopard" ?
17:35:28 <rovar> orzo: it might be buildable from source, but I don't think a dmg exists yet
17:35:42 <Botje> rovar: then you have to explicitly compare against bson_bool
17:35:47 <orzo> buildable from source is fine
17:36:05 <orzo> actually, i tried installing the macports version, but the port failed to build
17:36:23 <rovar> Botje: is there a way to specify a constant?  that is my whole point of predefining bson_bool is I don't want magic numbers floating around
17:37:23 <orzo> i was contemplating fixing the macports version but maybe ghc source itself will fail, so i wanted to find out if snow leopard is known to be an issue for ghc before i delved into that
17:37:26 <rovar> also, what it's complaining about is  "the last statement in a do construct must be an expression" i thought a case was an expression
17:38:25 <Botje> rovar: if t == bson_bool then ... else ...
17:39:04 <Botje> also, your otherwise case is the wrong type
17:39:20 <Botje> also also, you need to shift that whole case statement left one space
17:40:20 <ImInYourMonad> Game g >>= f = f g , is it not possibleto use liftM here to stick it in the typr?
17:40:24 <ImInYourMonad> again
17:40:42 <Botje> rovar: annotated your paste
17:40:48 <Botje> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1911#a1912
17:40:51 <Botje> this should compile, i think
17:41:46 <rovar> Botje: that's basically what I ended up with. Thanks.   Can you think of any ways to make this less ugly?
17:42:56 <ImInYourMonad> is: do x; y; z; == x >>= y >>= z ?
17:43:06 <Botje> x >> y >> z
17:43:17 <Botje> rovar: a combinator to ensure the type is bson_bool
17:43:20 <Botje> that'd help
17:44:03 <Botje> damn, copying 2 terabytes is SLOW
17:44:13 <rovar> heh
17:44:56 <Botje> it's been going for five hours and it's just now creeping past 45%
17:44:58 <dons> yeah, takes a few hours
17:45:09 <dons> it took 6hrs to copy 1TB on my lazy bytestring benchmark
17:45:14 <gwern> well sure. hard drives have crapy write speeds donchaknow
17:45:31 <gwern> my hard drive benchmarks at something ridiculous like 10 or 20 megabytes a second
17:46:11 <dolio> > 1024 * 1024 / (6 * 60 * 60)
17:46:12 <lambdabot>   48.54518518518518
17:46:17 <Glenjamin> i'm trying to get my head around exception catching, i'm using an example from http://www.randomhacks.net/articles/2007/03/10/haskell-8-ways-to-report-errors, but clearly some stuff has changed - as when i try it i get this: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1913#a1913
17:46:25 <monochrom> Hard drive is O(1) ha ha ha
17:46:56 <mauke> Glenjamin: Control.OldException
17:47:03 <Glenjamin> aha
17:47:07 <ImInYourMonad> hmm = Game 5 >> Game 4 ;retusn Game 4. so what is the point?
17:47:33 <Botje> game 5 should have some side effect for that code to be useful
17:47:57 <Glenjamin> mauke: seems obvious now, thanks
17:48:22 <Glenjamin> is OldException the best way to trap an error from the "error" function?
17:48:29 <mauke> no
17:48:42 <mauke> I think there is no good way to trap error
17:48:57 <rovar> do return f is the same thing as f, yes?
17:49:23 <mauke> no
17:49:34 <mauke> but do EXPR is the same as EXPR
17:50:10 <Eridius> can anybody explain to me why, in http://okmij.org/ftp/Haskell/perfect-shuffle.txt (about 2/3rds down the page, just under "** Efficient implementation ..") the fixed-point combinator is used instead of simple recursion?
17:50:38 <kerlo> do return f is the same as return f.
17:51:26 <ImInYourMonad> Botje but thn i use >>= ?
17:51:37 <ImInYourMonad> hmm = readFile "C:/users/XXXX/desktop/datasets/spam.txt" >>= print
17:53:09 <Eridius> ImInYourMonad: Monads encapsulate not only a value but also some idea of a computation (there's a second way to look at Monads, but it's irrelevant for the moment)
17:53:36 <Eridius> for example, the IO monad
17:54:06 <ImInYourMonad> instance Monad Botje where return question = answer
17:54:40 <Botje> ImInYourMonad: f >> g === f >>= \_ -> g
17:54:45 <Eridius> ImInYourMonad: the >> operator lets you ignore the value from the left-hand side while still performing the computation, whereas >>= performs the computation and then passes the value to the right-hand side
17:55:09 <ImInYourMonad> ok but could they also be for just encapsulating? ie, holding an impure value?
17:55:12 <Eridius> ImInYourMonad: it should be fairly obvious that (putStrLn "hello" >> return 3) prints "hello" to the console even though the "value" of that expression is ignored and 3 is returned
17:56:29 <Eridius> ImInYourMonad: if you define your own Monad where the >> operator is useless, then you probably shouldn't be using Monad
17:57:56 <orzo> Hey, i'm interested in using haskell to write a installer binary to install a software package on windows.  However, that requires linking my installer against the LGPL library gmp.  Obviously i don't want the user to have to download a DLL.  It seems like the LGPL is making me go to extroardinary measures in this case in order to comply with their license
17:59:10 <orzo> has anybody ever used an LGPL library in an executable installer package?  Do we really need to go to extraordinary measures?
17:59:11 <p_l> orzo: Can't you have the installer unpack itself into a directory which would include the "proper" installer and necessary libraries?
18:00:02 <orzo> p_l, the LGPL requires the user is able to relink the installer against their own version of gmp.  That's my understanding.
18:00:24 <orzo> that's pretty inconvenient
18:00:29 <orzo> heh
18:00:50 <p_l> orzo: yes, and if the bootstrapper unpacks the installer into temporary directory which contains the real installer and gmp.dll then you are clear
18:01:46 <orzo> so, the binary they download unpacks and then the user must activate the real installer?
18:02:05 <p_l> orzo: the binary starts the proper installer (in fact, a lot of installers work like that)
18:02:48 <orzo> well, say i'm a user and i want to run teh installer with my own gmp (i can't imagine this ever occuring).  How do i do it?
18:02:59 <lowmagnet> orzo: if you're doing something windows-specific, why not write an msi?
18:03:02 <p_l> orzo: override DLLs
18:03:13 <p_l> however, lowmagnet's idea is better :)
18:03:23 <lowmagnet> orzo: or is this a cyg/gnu thing?
18:03:25 <orzo> well i'm not actually writing it
18:03:35 <orzo> somebody else is and he wanted to use haskel
18:03:54 <orzo> it's to replace a custom built c++ installer
18:04:03 <lowmagnet> oh so there's a lot of configuration involved?
18:04:17 <orzo> there's a lot of crap involved, it's a complicated installer
18:04:18 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2491#a2491 so is htat a legal monad(whether it is a good one or not)?
18:04:30 <p_l> orzo: really consider msi, it's much better option for windows deployment
18:04:31 <lowmagnet> orzo: ah, that's what i though
18:05:03 <lowmagnet> orzo: *t ... when i did installer work, we used installshield scripts, and the only reason we used it was for the complexity issues
18:05:21 <lowmagnet> orzo: otherwise we'd msi it. But i guess your co-worker can suffer
18:06:01 <p_l> orzo: You can have the msi installer call to special purpose apps for configuration... AFAIK, nowadays, even installshield calls msi in order to take use of it's facilities
18:06:50 <lowmagnet> orzo: yeah, think 'apt' -- you still have to write your app-specific stuff, but it handles putting stuff where it belongs, and setting up registry keys for file types, etc.
18:07:44 <orzo> okay, so what you're saying is that even if he goes msi route, he'll probably be running a lot of our home grown code and might likely want to rewrite it in haskell anyway
18:08:14 <lowmagnet> he may, if he's a masochist. :-)
18:08:35 <p_l> orzo: Except that calling msi is a good idea still, as it's the closest thing windows have to proper package management
18:09:06 <lowmagnet> it's not PakageMaker.app, but i'll do
18:09:21 <Eridius> ImInYourMonad: I believe that is legal, it's just also fairly pointless
18:09:45 <ImInYourMonad> replicateM 3 $ m (Game 5) >>= \s -> m (return s)
18:10:05 <ImInYourMonad> can I repeat a monadic action several time? reapply it toitself?
18:10:11 <lowmagnet> You people make me fear reading chapter 7 on IO ()
18:10:23 <orzo> heh
18:10:38 <Eridius> ImInYourMonad: what do you mean, reapply it to itself?
18:11:06 <orzo> i recently used unsafePerformIO in a program where i thought i shouldn't need to but every way around it seemed like it';d likely be pretty inefficient
18:11:13 <monochrom> replicateM_ 7 ForgiveSeventyTimes
18:11:34 <orzo> maybe one of you gurus would be able to manage it better
18:12:15 <monochrom> perhaps replicateM_ 70 ForgiveSevenTimes
18:12:39 <dolio> ForgiveSeventyTimes is a constructor?
18:12:46 <monochrom> Oh! Darn.
18:12:53 <monochrom> replicateM_ 70 forgiveSevenTimes
18:13:04 <monochrom> Sorry, was using Javascript this weekend. :)
18:14:13 <orzo> What i was doing was image manipulation.  I had a tranform function that I wanted to apply to a bitmap in memory.  The tranform function seemed like something I'd really like to write as pure functional.  But the function that it was acting on was actually a bit map (mapping Int x Int -> Word8 x Word8 x Word8 ) that required peeks and pokes to apply the transform.  I ended up using unsafePerformIO.
18:14:50 <bd_> why did you need peeks and pokes?
18:15:06 <orzo> i was applying a transformation to an SDL bitmap
18:15:23 <bd_> oh, I see. So it was already foreign data?
18:15:24 <orzo> so reading pixels is a peek and writing npixels is a peek.
18:15:36 <rovar> Botje:  I have made a combinator, but it won't compile :)   http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1911#a1915
18:15:53 <lowmagnet> orzo: so sdl is managing all of this?
18:15:55 <orzo> the bitmap was represented in haskell as a ForeignPtr
18:16:22 <orzo> managing all what?
18:16:27 <orzo> sdl gave me a ForeignPtr
18:16:35 <orzo> and i needed to peek and poke on it
18:16:40 <lowmagnet> did it give you a size?
18:16:49 <Botje> rovar: your function isn't of type Get a
18:16:51 <orzo> actually peek on one pointer and poke on another, becaus i wasnt applying the transform in place or anything
18:16:51 <Botje> it's just a
18:16:54 <Botje> you need to add return
18:17:08 <orzo> yes i have a size of the bitmap and such
18:17:25 <lowmagnet> orzo: i was just thinking peek to get the 'buffer' in unsafe mode, bring it back to pure and manipulate then send it back unsafe
18:17:44 <lowmagnet> but i can see the performance hit there
18:17:47 <bd_> lowmagnet: That would involve copying the entire buffer
18:18:04 <rovar> Botje: you're right.. i forgot to take that out
18:18:19 <lowmagnet> bd_: yeah hence the disclaimer :D
18:18:27 <orzo> heh
18:18:58 <bd_> if you really want to do it safely, one could probably write a manipulateSDLBufferInST :; (forall st. StSDLBuffer st -> ST st StSDLBuffer) -> SDLBuffer -> IO SDLBuffer
18:19:17 <bd_> er, a few minor mistakes in that type, but you can probably manage to implement something along those lines
18:19:25 <rovar> Botje: return as in how?  then return $ getWord8 >>= f >>= Right    it doesn't like it
18:19:35 <Botje> rovar: no, inside your lambda
18:19:58 <Botje> (\b -> if b == 1 then return  True else return False)
18:20:06 <rovar> really?
18:20:17 <bd_> hmm, though, orzo, unsafePerformIO for something liek that is something you need to be really careful about
18:20:36 <bd_> orzo: as if you're not careful the writes could end up after you pass the buffer to SDL
18:21:28 <orzo> well i'm pretty sure i prevented that
18:22:30 <bd_> orzo: Are you sure? :) It's really hard to ensure proper ordering if you're not in IO normally (and why aren't you?)
18:24:46 <orzo> bd_: what i did is make an IO action transformSurface that takes an SDL Surface and a pure-functional transform and returns a new SDL Surface with it applied
18:25:28 <orzo> if you like, i'll show you a paste
18:25:31 <bd_> sure
18:25:42 <orzo> forgive my excessive prefixing tho
18:27:09 <orzo> http://rafb.net/p/q7cL2o39.html
18:28:04 <orzo> so the unsafePerformIO usage is hidden inside the transformSurface action and so ordering is gauronteed as i understand it
18:28:11 <orzo> the only unsafe thing is i didnt put any bounds checking
18:29:28 <bd_> why are you using unsafePerformIO, when you're in IO and can just evaluate it the normal way? :)
18:29:43 <bd_> @L23
18:29:43 <lambdabot> Unknown command, try @list
18:29:49 <orzo> because i'm passing it to trans
18:29:53 <lowmagnet> silly bot
18:30:02 <bd_> Ah, I see.
18:30:05 <orzo> trans is pure functional argument passed in
18:30:32 <bd_> Hmm, okay, since the input surface is constant, and you're completely forcing the results of the trans function, I guess it's safe
18:30:48 <orzo> ya seems so
18:31:10 <orzo> (except bounds checking, which did bite me a few times)
18:31:15 <orzo> heh
18:32:44 <orzo> it just seems to me that this situation is probably not uncommon and I thought unsafePerformIO might not be neccessary
18:34:33 <orzo> or maybe this situation is exactly what unsafePerformIO is intended for?
18:34:38 <cognominal_> in the yi code there is $(nameDeriveAccessors ''Attributes (\n -> Just (n ++ "AA")))    # I don't understand the syntax ''Attributes
18:40:37 <lowmagnet> That is odd
18:40:50 <FunctionalPath> @ft map
18:40:51 <lambdabot>  fd:7: hClose: resource vanished (Broken pipe)
18:42:04 <FunctionalPath> @all-dicts sex
18:42:07 <lambdabot> *** "sex" gcide "The Collaborative International Dictionary of English v.0.48"
18:42:07 <lambdabot> Gender \Gen"der\ (j[e^]n"d[~e]r), n. [OF. genre, gendre (with
18:42:07 <lambdabot>    excrescent d.), F.genre, fr. L. genus, generis, birth,
18:42:07 <lambdabot>    descent, race, kind, gender, fr. the root of genere, gignere,
18:42:07 <lambdabot>    to beget, in pass., to be born, akin to E. kin. See {Kin},
18:42:09 <lambdabot> [199 @more lines]
18:42:37 <orzo> incidently, my transformSurface function does run pretty slow on a large bitmap.  Do you see any good way to optimize it?
18:43:13 <sjanssen> cognominal_: it is Template Haskell syntax
18:43:46 <orzo> im compiling with ghc's deafult optimization level
18:43:56 <orzo> i'm not sure how aggressive that is
18:44:12 <sjanssen> orzo: GHC uses no optimization by default, use -O2
18:44:20 <orzo> oh really
18:44:38 <orzo> why is that the default?
18:45:03 <mmorrow> cognominal_: that's template-haskell syntax for "the Name of"
18:45:08 <mmorrow> , ''Maybe
18:45:11 <lunabot>  Data.Maybe.Maybe
18:45:12 <mmorrow> , 'Just
18:45:13 <lunabot>  Data.Maybe.Just
18:45:15 <mmorrow> , 'Maybe
18:45:16 <lunabot>  luna: Not in scope: data constructor `Maybe'
18:45:18 <mmorrow> , ''Just
18:45:19 <lunabot>  luna: Not in scope: type constructor or class `Just'
18:45:33 <ddarius> , '''''
18:45:34 <lunabot>  luna: parse error on input `''
18:45:39 <sjanssen> orzo: most compilers don't turn optimizations on by default
18:47:05 <monochrom> Everyday I have 50% probability to defend that by saying "gcc doesn't optimize by default either" and the other 50% probability to say "screw that, it's the 21st Century already". :)
18:47:09 <cognominal_> thx mmorrow
18:47:53 <cognominal_> how do I enable this syntax in ghci?
18:48:27 <monochrom> To be fair both "ghc -O2" and "gcc -O2" give you the least surprise, especially if you aren't an old-geezer.
18:49:49 <orzo> heh
18:51:13 <orzo> well -O2 is still pretty slow for my image transform
18:51:18 <orzo> heh
18:51:25 <orzo> but i didn't compare
18:52:32 <sundaymorning> I sure wish hopengl's documentation was more comprehensive
18:53:33 <orzo> i'm timing it now
18:53:43 <orzo> let's see how much -O2 is really helping me
18:54:05 <seoushi> -O3 might be good to bench against as well
18:54:12 <sjanssen> seoushi: -O3 does nothing in GHC
18:54:18 <seoushi> ah
18:54:25 <sjanssen> orzo: remember to force GHC to rebuild the executable with -no-recomp
18:54:27 <seoushi> I figure it would just pipe things to gcc
18:54:50 <sjanssen> seoushi: GHC doesn't use GCC by default on most platforms nowadays
18:55:31 <seoushi> interesting to know, does it use msvc or have it's own compiler?
18:55:46 <orzo> sjanssen: i'm not sure what -no-recomp is, but it's a single file haskell program and i built it with -O2 and moved the executable to a different name and then built it without -O2.  Is that sufficient to compare?
18:55:50 <sjanssen> seoushi: it doesn't go via C at all by default
18:56:11 <sjanssen> orzo: that's enough if you're not using ghc --make
18:56:15 <orzo> i used ghc --make
18:56:18 <orzo> okay
18:56:21 <sjanssen> yep, that isn't sufficient
18:56:25 <seoushi> sjanssen, guess I'm just use to reading outdated articles :)
18:56:37 <idnar> ghc --make-damnit
18:57:07 <orzo> uh, wait, sjanssen.  you said "orzo: that's enough if you're not using ghc --make" ... did you mean that "not" ?
18:57:13 <sjanssen> orzo: yes
18:57:33 <orzo> uh
18:57:50 <orzo> you contradict yourself
18:57:52 <sjanssen> "ghc --make foo -no-recomp -O2" will force GHC to rebuild the file with optimizations
18:58:06 <orzo> i did not use -no-recomp
18:58:22 <sjanssen> orzo: I don't think I did.  I meant not using -no-recomp is enough if you're not using --make
18:58:41 <sjanssen> you are using --make so -no-recomp is required
18:59:03 <ddarius> Doh.
18:59:04 <orzo> i used "ghc --make im.hs" both times to build both executables (once with {-# OPTIONS_GHC -O2 #-} and once without
18:59:16 * ddarius fails to build gtk2hs because he ran out of disk space.
18:59:34 <orzo> okay
18:59:37 <sjanssen> orzo: ah, now if you're editing the file and adding OPTIONS_GHC then -no-recomp will *not* be required :)
18:59:44 <orzo> the results are in.
18:59:57 <orzo> they are pretty big
19:00:16 <orzo> No optimisations: 3m37.421s
19:00:18 <monochrom> If you use floating-point, -fexcess-precision is faster.
19:00:32 <orzo> With -O2:  real    0m36.383s
19:00:43 <monochrom> w00t!
19:00:50 <orzo> heh
19:01:26 <orzo> i wish i was using -O2 from the beginning heh
19:01:36 <orzo> all that waiting for results...
19:02:30 <orzo> I am going to try to be sure to put -O2 by default from now on
19:09:36 <orzo> man that's a lot, 36 seconds down from 3 and a half minutes
19:09:55 <Debugger> haskell ftw
19:11:53 <rovar> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1916#a1916
19:12:24 <gnuvince_> Debugger: wtf?
19:12:39 <rovar> what am I doing wrong here?
19:14:08 <Cano`Away> DCC SEND C:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
19:14:24 --- mode: ChanServ set +o monochrom
19:14:33 <Cano`Away> DCC SEND C:\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
19:14:54 <dons> bos: http://twitter.com/bohanlon/statuses/1337982522
19:15:31 <monochrom> I need to jot down some commands such as the remove command.
19:16:14 --- mode: monochrom set -o monochrom
19:21:27 <Eridius> rovar: it's complaining that the type signature of getBSONVal has (b -> a) but you're treating it like (Word8 -> a)
19:22:34 <rovar> gotcha.. yea.. i'd actually like to not pass it any value..
19:22:59 <rovar> and have it call getWord* from the lambda
19:23:20 <Eridius> then do that
19:23:33 <Eridius> getBSONVal :: Word8 -> Get a -> Get (Either String a)
19:24:12 <rovar> how do I define a lambda that takes no args?
19:24:22 <Eridius> you don't.
19:24:28 <Eridius> you don't need to
19:24:32 <Eridius> it's a lazy language, remember?
19:25:16 <Eridius> and even if it wasn't, Get is really State which is really a lambda anyway
19:25:19 <Eridius> @src State
19:25:19 <lambdabot> Source not found.
19:25:23 <Eridius> heh
19:25:33 <Eridius> well, according to the documentation, newtype State s a = State { runState :: s -> (a, s) }
19:25:34 <orzo> a lambda that takes no args? you probably want unsafeInterleaveIO
19:25:39 <Eridius> orzo: no he doesn't
19:25:58 <orzo> oh
19:26:06 <Asztal_> @unmtl State
19:26:06 <lambdabot> err: `State' is not applied to enough arguments, giving `/\A B. A -> (B, A)'
19:27:36 <rovar> okay.. i'm having a hard time conceptualizing how I would reconstruct this to be a  Get A
19:28:20 <Eridius> rovar: think of it as a computation. That's what Get is, after all
19:28:41 <ddarius> dons: Library flowers: http://img4.imageshack.us/img4/3113/testcxa.jpg
19:28:57 <Eridius> ooh pretty
19:35:28 <gwern> ddarius: looks like fireworks, or maybe a trellis of flowers glowing in the dark
19:38:07 <orzo> is there any glue to connect SDL Surfaces and a library for manipulating image files.  I used SDL, but i'm discovering I don't have a convenient way to save off the image
19:38:24 <ddarius> gwern: Reminds me of diagrams of chromosomes.
19:38:36 <ddarius> Use sdl-image?
19:38:41 <gwern> hm... yes, I could see that
19:38:59 <orzo> ddarius: unless i'm mistaken, that has no routine for saving to file
19:40:25 <orzo> i need to glue SDL and stb-image
19:40:43 <orzo> oh, nope, not stb-image
19:41:10 <orzo> Graphics.GD perhaps
19:46:39 <rovar> Eridius: Short of calling runGet, I'm still not sure how to compose this
19:46:52 <Eridius> rovar: how about with the standard <- operator?
19:47:17 <Eridius> actually you don't even need it, because you just want to return the results
19:47:26 <rovar> right
19:48:01 <Eridius> if t == intype then liftM Right f else return (Left $ "Expecting flag: " ++ (show intype) ++ " got " ++ (show t))
19:48:55 <mmorrow> <cognominal_> how do I enable this syntax in ghci?
19:49:04 <mmorrow> cognominal_: with ":set -XTemplateHaskell"
19:49:42 <rovar> Eridius: but how do I define f in terms of the parameter to getBSONVal?
19:50:21 <Eridius> what do you mean? you said you wanted to call getWord8 inside of f. So do that
19:50:40 <rovar> i call getWord8 then check the result
19:51:01 <Eridius> f is just an action in the Get monad
19:51:17 <rovar> getBSONBool = getBSONVal bson_bool (\b -> if b == 1 then True else False)
19:51:21 <Eridius> you can do whatever you were going to do in your original code, except it's in the Get monad and it has to call getWord8 instead of accepting a parameter
19:51:36 <Eridius> ah I see what you mean
19:52:12 <Eridius> getBSONBool = getBSONVal bson_bool (getWord8 >>= \b -> if b == 1 then return True else return False)
19:52:48 <rovar> ah
19:52:55 <rovar> that makes sense
19:53:14 <mmorrow> you'll need to join that too
19:53:19 <ddarius> return (b == 1)
19:53:49 <mmorrow> err, you need to give it type:
19:53:54 <mmorrow> from: getBSONVal :: Word8 -> (b -> a) -> Get (Either String a)
19:53:57 <mmorrow> to:
19:54:07 <orzo> anybody know any good algorithms for recognizing severely broken lines in images?  I have monochrome image with a lot of dots forming easily recognizable geometric paterns amidst some background noise and i'd like some nifty algorithm to try to find the shapes
19:54:16 <mmorrow> getBSONVal :: Word8 -> Get Bool -> Get (Either String a)
19:54:27 <mmorrow> or something
19:54:42 <mmorrow> err, where's the 'a' coming from?
19:54:46 <Eridius> ddarius: hehe my mind must be broken to have missed that
19:54:57 <mmorrow> you're trying to apply (f :: a -> b) to a Word8
19:54:59 <orzo> humans do it instantly and compulsively, but i suppose its a hard problem for computers
19:55:01 <Eridius> mmorrow: it's Get a, not Get Bool
19:55:11 <rovar> getBSONVal needs to be generic
19:55:15 <mmorrow> but how do you get an 'a'?
19:55:30 <mmorrow> you need to pass in a (Get a) too
19:55:30 <ddarius> orzo: You could use a standard edge-detection approach and just continue the lines until they intersect (or, in a different situation, averaging out a background noise some way)
19:55:43 <Eridius> yes, Word8 -> Get a -> Get (Either String a)
19:55:54 <mmorrow> getIf :: Word8 -> Get a -> Get (Either String a)
19:55:57 <mmorrow> yeah, exactly
19:56:05 <Eridius> mmorrow: I think you missed a whole segment where I talked about this
19:56:08 <mmorrow> ah
19:57:14 <mmorrow> getIf w m = do v <- getWord8; if w==v then m else return (Left "zmog")
19:58:02 <mmorrow> oops
19:58:07 <mmorrow> getIf w m = do v <- getWord8; if w==v then Right `fmap` m else return (Left "zmog")
19:58:11 <Eridius> mmorrow: you're still repeating earlier parts of the convo
19:58:36 <mmorrow> i don't see above where you gave what getIf is doing
19:58:46 <mmorrow> getBSONBool = getBSONVal bson_bool (getWord8 >>= \b -> if b == 1 then return True else return False)     ?
19:58:51 <Eridius> I gave just the if statement part
19:58:55 <Eridius> <Eridius> if t == intype then liftM Right f else return (Left $ "Expecting flag: " ++ (show intype) ++ " got " ++ (show t))
19:59:29 <ddarius> orzo: Look at a median filter to get rid of speckles.
19:59:46 <ddarius> (while preserving crisp edges0
20:00:47 <rovar> so what's better idiomatically?  liftM Right m   or Right `fmap` m
20:01:12 <ddarius> Nowadays, Right <$> m
20:01:19 <mmorrow> liftM Right m == Right `liftM` m == Right `fmap` m
20:01:26 <ddarius> otherwise fmap Right or liftM Right
20:01:27 <mmorrow> (== Right <$> m)
20:02:03 <mmorrow> you can make that "getIf" even more general (==> useful) something like:
20:02:20 <Eridius> <$> is good but if you are already using Monads but aren't already using Control.Applicative, liftM is simpler
20:03:02 <ddarius> instance Applicative MyMonad where pure = return; (<*>) = ap isn't too hard to write (assuming it isn't already done) or just "deriving Applicative"
20:03:21 <mmorrow> getM p m n = do a <- m; if p a then Just `fmap` n else return Nothing
20:03:24 <ddarius> Anyway, (<$>) doesn't rely on Applicative.
20:03:25 <Eridius> ddarius: sure, I just meant "simpler" as in "you don't have to add an import for Control.Applicative"
20:03:27 <orzo> ddaarius, thanks for the tip
20:03:27 <ddarius> :t (<$>)
20:03:28 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
20:03:34 <mmorrow> then move the error reporting outside of getM
20:03:42 <Eridius> ddarius: I'm talking purely in terms of minimal edits to the existing source
20:04:37 <mmorrow> maybe (Left "oh noes") Right `fmap` getM ....
20:05:00 <mmorrow> @src (<$>)
20:05:00 <lambdabot> f <$> a = fmap f a
20:05:24 <mmorrow> i can't bring myself to not use fmap out of habit
20:05:38 * ddarius hates `fmap`
20:05:42 <mmorrow> heh
20:05:56 <rovar> i've always used liftM, so that's what I'm using in this case
20:06:06 <mmorrow> i don't like syms that match "<.+>"
20:06:14 <mmorrow> but i like (<>) a lot
20:06:15 <rovar> thanks for your help guys
20:06:17 <mmorrow> go figure
20:09:12 <orzo> ddarius: looking at http://en.wikipedia.org/wiki/Median_filter, i see their psuedo code implies the order in which the image is processed changes the results because the input and output pixel maps are apparently the same and later pixels will depend on results from earlier pixels.  Is that correct?
20:10:45 <orzo> hm, actually, input pixels are pixelvalue[][] and output pixels are pixelValue[][] so I suppose they might have intended a case-sensitive pseudo code
20:10:52 <orzo> heh
20:12:45 <orzo> os the median filter supposed to be order-dependent?
20:12:50 <orzo> s/os/is/
20:13:52 <Adamant> can you split a list into a (x:xs) in a guard pattern?
20:13:54 <ddarius> There's nothing to "order".  For a 2D image, you'd use a 2D median filter.
20:14:22 <ddarius> Adamant: You can use a let in a guard (or a case, or any expression)
20:14:41 <orzo> ddarius: the nested for loops in the psuedo code implies an ordering, and that ordering apparently matters
20:15:03 <orzo> it wouldn't matter if the output map was not the same as the input
20:15:09 <orzo> maybe that's the intention?
20:16:04 <Eridius> from the description of how the filter works, it is intentionally modifying its input source rather than producing a new one
20:16:13 <Eridius> well... I think. maybe.
20:16:20 <Eridius> wikipedia descriptions of algorithms often leave much to be desired ;)
20:16:30 <ddarius> orzo: A filter is always conceptually Signal -> Signal.
20:17:02 <Eridius> actually hrm, from the small Example I think what I said is not true
20:18:24 <orzo> ddarius, im not sure i follow you, it sounds like you are saying they intended the output map to be different than the input map which is not what's written in their pseudo code
20:18:40 <Eridius> orzo: from the Example, that's exactly what they intended
20:18:44 <Eridius> their pseudo-code is pretty bad ;)
20:19:53 <orzo> okay
20:21:01 <mmorrow> orzo: to filter an image, you can use convolution, or fft it, do the filtering there, then fft it back. in both cases, you're mapping the original image's data to pixels in the output image, so order doesn't matter because you aren't taking any of your output as input
20:21:04 <orzo> why is their pseudo-code bad?  Seems to me we can just change the pixelValue thing into two seperate names and we'll be good
20:21:31 <gwern> {{sofixit}}
20:21:39 <Eridius> orzo: yes, but right now it's using pixelvalue and pixelValue as two separate variables. That's why it's bad
20:21:55 <orzo> heh
20:22:09 <orzo> i guess they intended the case to matter, which is lame
20:22:14 <davidL> > reverse $ unfoldr (\x -> if x == 0 then Nothing else Just $ (flip mod 2 &&& flip shiftR 1) x) 255 -- can anyone golf this?
20:22:15 <lambdabot>   [1,1,1,1,1,1,1,1]
20:23:15 <davidL> or make a cuter one :)
20:23:35 <ddarius> mmorrow: That approach won't work for the median filter.
20:23:46 <mmorrow> what does the media filter do?
20:23:50 <mmorrow> *median
20:24:13 <ddarius> mmorrow: It replaces a sample with the median of its neighbors.
20:24:29 <mmorrow> sure, most filters have a width > 1
20:24:44 <ddarius> mmorrow: Taking the median is a very non-linear operation.
20:24:49 <Eridius> davidL: instead of flip mod 2 you could use Data.Bits.testBit
20:24:52 <ddarius> mmorrow: Convolution is linear.
20:25:01 <wli> > reverse $ unfoldr (\x -> if x == 0 then Nothing else Just $ (((Data.Bits..&.) 1) &&& flip shiftR 1) x) 255 :: [Word]
20:25:02 <lambdabot>   [1,1,1,1,1,1,1,1]
20:25:14 <orzo> i just fixed their psuedo code heh
20:26:03 <davidL> ah! good point
20:26:15 <TSC> > map digitToInt $ showIntAtBase 2 ("01"!!) 255 ""
20:26:26 <lambdabot>   [1,1,1,1,1,1,1,1]
20:26:33 <TSC> Cheating?
20:26:37 <davidL> a bit :P
20:26:41 <wli> > reverse $ unfoldr (\x -> if x == 0 then Nothing else Just . uncurry (flip (,)) $ (x `divMod` 2)) 255 :: [Word]
20:26:42 <lambdabot>   [1,1,1,1,1,1,1,1]
20:26:52 <davidL> :t divMod
20:26:55 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
20:27:00 <davidL> wow
20:27:57 <ddarius> Another approach to get rid of speckles and reconnect lines is to use morphology-based operators as detailed on this random web page on them I pulled up.
20:27:57 <ddarius> http://www.ph.tn.tudelft.nl/Courses/FIP/noframes/fip-Morpholo.html
20:28:08 <rovar> getBSONDouble = getIf bson_number_dbl (getWord64le >>= \d -> return $ realToFrac $ (unsafeCoerce :: a -> CDouble) d)
20:28:31 <rovar> anyone here good with C Types?
20:28:39 <rovar> Is there a better way to do this?
20:29:08 <gwern> huh. a jhc release
20:29:10 <mmorrow> ddarius: in convolution, you're doing, for every pixel in the output image, a function that maps an MxN window of input image pixels to that single output pixel
20:29:12 <gwern> wonder how lhc is doing
20:29:35 <ddarius> mmorrow: I know what convolution is.
20:29:36 <mmorrow> that's how you can do, e.g. blur filters
20:29:40 <rovar> does ghc compile to llvm yet?
20:29:56 <mmorrow> ddarius: so then how can you not use convolution for a media filter
20:29:59 <gwern> rovar: yet?
20:30:03 <rovar> :P
20:30:16 <gwern> ghc has never planned to compile to llvm, and no haskell compiler has
20:30:25 <rovar> it's inevitable.. llvm is the future of computing
20:30:27 <dolio> ehc might.
20:30:28 <ddarius> mmorrow: Convolving against a kernel is a linear transformation.  Median filters are non-linear.  You can't make a kernel that will lead to a median filter.
20:30:29 <mmorrow> let medianFilter xss = media (concat xss)
20:30:31 <rovar> actually.. the ehc does
20:30:36 <mmorrow> let medianFilter xss = median (concat xss)
20:30:56 <Eridius> > reverse $ unfoldr (\x -> guard x >> return . uncurry (flip (,)) $ (x `divMod` 2)) 255 :: [Word]
20:30:57 <lambdabot>   Couldn't match expected type `Word' against inferred type `Bool'
20:30:58 <gwern> rovar: hm. anyway I had understood from the lhc devs that llvm is not well suited to FP langs
20:31:04 <idnar> rovar: I imagine you could compile with -fvia-c and llvm-gcc
20:31:04 <Eridius> oh oops
20:31:16 <Eridius> > reverse $ unfoldr (\x -> guard (x/=0) >> return . uncurry (flip (,)) $ (x `divMod` 2)) 255 :: [Word]
20:31:17 <lambdabot>       No instance for (MonadPlus ((->) (Word, Word)))
20:31:17 <lambdabot>        arising from a u...
20:31:21 <Eridius> darn
20:31:21 <gwern> idnar: I thought -fvia-c was more pseudo-c than real c?
20:31:23 <ddarius> mmorrow: A median filter picks n samples, sorts them, and outputs the middle (i.e. the median).  This is obviously not expressible as a weighted sum of the original elements.
20:31:24 <mmorrow> ddarius: sure you can, since you just allow your filters to be arbitrary (non-linear) functions
20:31:28 <wli> guard (x/=0)
20:31:29 <gwern> although that'd work for lhc/jhc I guess
20:32:06 <rovar> gwern, interesting, I wonder what constructs they're after.
20:32:09 <idnar> gwern: I don't really know, I'm just guessing
20:32:19 <mmorrow> (i.e.  any  :: [[Pixel]] -> Pixel)
20:32:21 <gwern> rovar: there's a lhc blog
20:32:40 <Eridius> wli: yes I fixed that, though I'm wondering why it's complaining about no instance for MonadPlus ((->) r) when that's supposed to be Maybe
20:32:50 <Eridius> :t unfoldr
20:32:50 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
20:33:01 <ddarius> It's highly implementation-specific C.
20:33:03 <Eridius> oh it's because it's specifically Maybe (a,b)
20:33:11 <rovar> heh.. googling for "lhc blog" isn't productive :)
20:33:41 <Eridius> actually hrm, no, that should still work
20:34:33 <ddarius> mmorrow: A convolution based filter is a specific (type of) filter, not a mixture of arbitrary filters.  There's nothing to allow to be non-linear.  An arbitrary filter can be non-linear, but then they aren't the convolution against some kernel.
20:35:00 <dolio> Eridius: That parses as: \x -> (guard x >> return . uncurry (flip (,))) $ (x `divMod` 2))
20:35:08 <wli> flip evalState (19, []) $ let m = get >>= \(x, s) -> if x == 0 then return s else let (q, r) = x `divMod` 2 in put (q, r:s) >> m in m
20:35:11 <Eridius> oh bah
20:35:15 * Eridius stabs $
20:35:16 <wli> > flip evalState (19, []) $ let m = get >>= \(x, s) -> if x == 0 then return s else let (q, r) = x `divMod` 2 in put (q, r:s) >> m in m
20:35:18 <lambdabot>   [1,0,0,1,1]
20:35:40 <Eridius> although why was $ present in the first place when the next arg has parens?
20:35:54 <Eridius> > reverse $ unfoldr (\x -> guard (x/=0) >> (return . uncurry (flip (,))) (x `divMod` 2)) 255 :: [Word]
20:35:55 <lambdabot>   [1,1,1,1,1,1,1,1]
20:36:37 <mmorrow> ddarius: are we talking mathematically here, or in terms of the algorithm you'd use in code?
20:36:48 <ddarius> mmorrow: I'm talking mathematically.
20:36:54 <davidL> Eridius: nice
20:37:08 <mmorrow> ddarius: ok. in that case you're right.
20:37:09 * Eridius hates if statements in Haskell ;)
20:37:10 * ddarius doesn't know what linear/non-linear means algorithmically.
20:37:16 <mmorrow> ddarius: nothing
20:37:20 <centrinia> Do convolution filters have to work in the field of complex numbers?
20:37:24 <mmorrow> because you can use the same exact algo
20:37:35 <ddarius> centrinia: No.
20:37:36 <mmorrow> centrinia: no
20:37:54 <wli> > evalState (let m = get >>= \(x, s) -> if x == 0 then return s else put (second (:s) $ x `divMod` 2) >> m in m) . flip (,) [] $ (19 :: Int)
20:37:55 <lambdabot>   [1,0,0,1,1]
20:38:02 <centrinia> So you can't do weighed sums over finite fields? :(
20:38:18 <mmorrow> centrinia: why not?
20:39:22 <centrinia> Maybe you can then.
20:39:30 <ddarius> You certainly can.
20:39:49 <ddarius> centrinia: Heck, multiplication of polynomials is just convolution of their coefficients.
20:39:53 <wli> davidL/Eridius: My evalState etc. bit doesn't get the overhead of list reversal.
20:40:11 <Eridius> wli: it's painful to read :P
20:40:20 <centrinia> What do frequencies mean with respect to vectors of elements of some finite field?
20:40:44 <mmorrow> ddarius: hmm, actually you may be able to express that as a convolution (in the mathematic sense) by considering vector spaces of (non-linear) functions
20:41:50 <shapr> YOW!
20:42:10 <davidL> > reverse $ unfoldr (\x -> guard (x/=0) >> (return $ (flip testBit 0 &&& flip shiftR 1) x)) (255::Word)
20:42:11 <lambdabot>   [True,True,True,True,True,True,True,True]
20:42:23 <ddarius> mmorrow: Yeah, if you lift the whole thing up you might be able to get what you want, but it wouldn't help taxonomy at all.
20:43:30 <ddarius> centrinia: You'd need a different "Fourier" transform for a different field (or rather inner-product space).
20:44:17 <centrinia> Is it possible to perform any bilinear transformation with convolutions?
20:46:15 <ddarius> Convolution is symmetric.
20:46:44 * wli prefers the evalState solution.
20:46:51 <centrinia> Oh, what about with arbitrary linear filters?
20:48:22 <davidL> wli: how's it avoid the overhead of reversal?
20:48:38 <ispiked> I'm having trouble comparing an IO value to another IO value: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2493#a2494
20:48:50 <davidL> > bool 1 0 True
20:48:51 <lambdabot>   Not in scope: `bool'
20:49:04 <ddarius> "Arbitrary linear filter" == "arbitrary linear function/transformation"
20:49:05 <wli> davidL: It just stuffs the digits into a stack as it goes and returns the stack when done.
20:49:30 <davidL> @let bool true false True = true; bool true false False = false
20:49:31 <lambdabot>  Defined.
20:50:03 <davidL> > reverse $ unfoldr (\x -> guard (x/=0) >> (return $ ((bool 1 0 . flip testBit 0) &&& flip shiftR 1) x)) (19::Word)
20:50:04 <lambdabot>   [1,0,0,1,1]
20:50:26 <wli> > snd . execState (let m = get >>= \(x, s) -> when (x /= 0) (put (second (:s) $ x `divMod` 2) >> m) in m) . flip (,) [] $ (19 :: Int)
20:50:27 <lambdabot>   [1,0,0,1,1]
20:51:22 --- mode: irc.freenode.net set +o ChanServ
20:51:42 <ispiked> http://www.haskell.org/ghc/docs/latest/html/libraries/random/System-Random.html
20:51:54 <ispiked> will the randomR function return values of non-IO type?
20:52:16 <davidL> wli: rewrite it with testBit and shiftR :)
20:54:04 <wli> > snd . execState (let m = get >>= \(x, s) -> when (x /= 0) (put (second (:s) ((flip testBit 1 &&& flip shiftR 1) x)) >> m) in m) . flip (,) [] $ (19 :: Int)
20:54:05 <lambdabot>   Couldn't match expected type `Bool' against inferred type `Int'
20:54:30 <wli> > snd . execState (let m = get >>= \(x, s) -> when (x /= 0) (put (second (:s) ((flip shiftR 1 &&& flip testBit 0) x)) >> m) in m) . flip (,) [] $ (19 :: Int)
20:54:31 <lambdabot>   [True,False,False,True,True]
20:55:05 <davidL> > snd . execState (let m = get >>= \(x, s) -> when (x /= 0) (put (second (:s) ((flip shiftR 1 &&& (bool 1 0 . flip testBit 0))  x)) >> m) in m) . flip (,) [] $ (19 :: Int)
20:55:06 <lambdabot>   [1,0,0,1,1]
20:55:15 <davidL> cute
20:55:48 <Eridius> what's with the let m = ... in m?
20:55:57 <Eridius> oh durr, I missed the >> m
20:56:02 <wli> Eridius: Recursion.
20:57:39 <wli> What the heck is bool and where is it defined?
20:57:57 <Eridius> @index bool
20:57:58 <lambdabot> bzzt
20:57:59 <Eridius> bah
20:58:01 <Eridius> @src bool
20:58:01 <lambdabot> Source not found. :(
20:58:04 <davidL> 03:49 <davidL> @let bool true false True = true; bool true false False = false
20:58:05 <Eridius> double-bah
20:58:32 <Eridius> oh well, if we can use that when golfing, how about I just use @let to hide 90% of the code?
20:58:40 <davidL> > if' True 1 0
20:58:40 <lambdabot>   Not in scope: `if''
20:58:55 <davidL> :P
20:59:12 <dolio> > let stopAt p f x = guard (not $ p x) >> return (f x) ; swap (x,y) = (y,x) ; unfoldl f s = go where go s a = maybe a (\(x,s') -> go s' (x:a)) in unfoldl (stopAt (==0) $ swap . divMod) (19 :: Int)
20:59:13 <lambdabot>   Couldn't match expected type `[t]'
20:59:17 <dolio> Bah.
20:59:44 <dolio> > let stopAt p f x = guard (not $ p x) >> return (f x) ; swap (x,y) = (y,x) ; unfoldl f s = go s [] where go s a = maybe a (\(x,s') -> go s' (x:a)) in unfoldl (stopAt (==0) $ swap . divMod) (19 :: Int)
20:59:45 <lambdabot>   Couldn't match expected type `[t]'
21:00:56 <dolio> > let stopAt p f x = guard (not $ p x) >> return (f x) ; swap (x,y) = (y,x) ; unfoldl f s = go s [] where go s a = maybe a (\(x,s') -> go s' (x:a)) (f s) in unfoldl (stopAt (==0) $ swap . divMod) (19 :: Int)
21:00:57 <lambdabot>   Couldn't match expected type `(t, t1)'
21:01:01 <dolio> Geeze.
21:02:22 <dolio> > let stopAt p f x = guard (not $ p x) >> return (f x) ; swap (x,y) = (y,x) ; unfoldl f s = go s [] where go s a = maybe a (\(x,s') -> go s' (x:a)) (f s) in unfoldl (stopAt (==0) $ swap . flip divMod 2) (19 :: Int)
21:02:24 <lambdabot>   [1,0,0,1,1]
21:02:30 <Eridius> @pl \x -> x : (f x)
21:02:30 <lambdabot> ap (:) f
21:03:26 <Eridius> > (ap (:) ((:[]) . succ)) 5
21:03:27 <lambdabot>   [5,6]
21:03:30 <Eridius> huh
21:05:09 <Eridius> > foldl ((flip (:)) . (`mod` 2)) . unfoldr (\x -> guard (x/=0) >> return (x, x `div` 2)) $ 19
21:05:10 <lambdabot>       Overlapping instances for Show ([a] -> [a])
21:05:10 <lambdabot>        arising from a use o...
21:05:16 <Eridius> o_O
21:07:30 <dolio> foldl is under-applied.
21:07:42 <Eridius> yes I realized that, I was just confused at lambdabot's error
21:08:08 <c_wraith> well, it was going to say "of ..."
21:08:24 <c_wraith> It truncates output when printing to a channel
21:08:50 <davidL> > foldl1 ((flip (:)) . (`mod` 2)) . unfoldr (\x -> guard (x/=0) >> return (x, x `div` 2)) $ 19
21:08:51 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
21:08:51 <lambdabot>        Expect...
21:08:57 <Eridius> yes, but it's the Show bit that puzzled me
21:09:22 <Eridius> > flip (foldl ((flip (:)) . (`mod` 2))) [] . unfoldr (\x -> guard (x/=0) >> return (x, x `div` 2)) $ 19
21:09:23 <lambdabot>       No instance for (Integral [a])
21:09:23 <lambdabot>        arising from a use of `mod' at <i...
21:09:26 <Eridius> bah
21:09:36 <c_wraith> it just means there's no Show instance defined for functions
21:09:53 <dolio> Yes, lambdabot has not one, but two show instances for functions.
21:09:55 <Eridius> c_wraith: when I plugged it into ghci it gave a completely different, and more relevant, error
21:10:04 <c_wraith> ah
21:10:44 <Eridius> :t ((flip (:)) . (`mod` 2))
21:10:44 <lambdabot> forall a. (Integral [a]) => [a] -> a -> [a]
21:10:48 <Eridius> heh, Integral [a]
21:11:34 <Eridius> @pl \l a -> (a `mod` 2):l
21:11:34 <lambdabot> flip ((:) . (`mod` 2))
21:11:45 <Eridius> ah, I put the parens in the wrong spot
21:12:07 <Eridius> > flip (foldl ((flip ((:) . (`mod` 2))) [] . unfoldr (\x -> guard (x/=0) >> return (x, x `div` 2)) $ 19
21:12:08 <lambdabot>   <no location info>: parse error on input `;'
21:12:11 <Eridius> ack
21:12:44 <Eridius> >flip (foldl (flip ((:) . (`mod` 2))) [] . unfoldr (\x -> guard (x/=0) >> return (x, x `div` 2)) $ 19
21:12:49 <Eridius> > flip (foldl (flip ((:) . (`mod` 2))) [] . unfoldr (\x -> guard (x/=0) >> return (x, x `div` 2)) $ 19
21:12:50 <lambdabot>   <no location info>: parse error on input `;'
21:12:55 <Eridius> bah, I say, bah!
21:14:47 <mmorrow> @let pullback (=?=) f g as bs = [ (a, b) | a <- as, b <- bs, f a =?= g b ]
21:14:47 <lambdabot>  Defined.
21:14:55 <Eridius> oh oops, that flip is wrong
21:15:17 <Eridius> > foldl (flip ((:) . (`mod` 2))) [] . unfoldr (\x -> guard (x/=0) >> return (x, x `div` 2)) $ 19
21:15:18 <lambdabot>   [1,0,0,1,1]
21:15:27 <ddarius> mmorrow: A bit recursive, eh? ...
21:15:42 <ddarius> Or not.
21:15:44 * ddarius misread.
21:15:52 <mmorrow> heh
21:16:23 <Eridius> is (=?=) the name of a parameter to the function?
21:16:28 <ddarius> mmorrow: Have you read Burstall's book, Computational Category Theory?
21:16:34 <ddarius> Eridius: Yes.
21:16:47 <Eridius> huh, it never occurred to me that you could have "operators" as the names of parameters
21:17:16 <ddarius> Eridius: It surprises a lot of people (though it technically shouldn't)
21:17:27 <Eridius> yeah it makes sense in retrospect
21:18:11 <mmorrow> ddarius: ahh, i've seen it and it looked really nice but had forgotten about it
21:18:25 * mmorrow finds it again
21:18:25 <Eridius> > pullback (==) succ pred [1,2,3,4,5] [5,4,3,2,1]
21:18:27 <lambdabot>   [(1,3),(2,4),(3,5)]
21:18:34 <Eridius> neat
21:19:17 <Eridius> @pl (\x -> guard (x/=0) >> return (x, x `div` 2))
21:19:17 <lambdabot> ap ((>>) . guard . (0 /=)) (return . ap (,) (`div` 2))
21:19:25 <Eridius> blech
21:21:38 <wli> I'd try unfoldl f x = fst $ execState (let m = do { (s, y) <- get ; maybe (return ()) (\(t, x') -> put (t : s, x) >> m) (f y) } in m) ([], x)
21:22:58 <wli> There's probably a schnazzy way to do that with arrows.
21:25:29 <mmorrow> @let pushout (=?=) f g as = nubBy (=?=) (fmap (Left . f) as ++ fmap (Right . g) as)
21:25:30 <lambdabot>  Defined.
21:26:27 <dolio> Why would you do that? It's more verbose than just passing parameters.
21:26:47 <mmorrow> ddarius: nice, http://www.cs.man.ac.uk/~david/categories/
21:27:38 <mmorrow> dolio: ?
21:28:23 <dolio> Use State for unfoldl. The purpose of State is to hide the implicit state passing in pieces of code that have nothing to do with state, but depend on other pieces that do.
21:28:30 <mmorrow> ah
21:29:18 <wli> I did not intend to make a serious effort to golf it via arrows.
21:29:26 <wli> Or any effort at all.
21:29:26 <mmorrow> mapAccum* are nice, i should use them more
21:29:39 <Eridius> wli: you and your silly state monad
21:29:41 <ddarius> mapAccumL/R = sequence
21:29:49 <wli> I've been using State vs. mapAccumL/R anymore.
21:30:16 <mmorrow> ddarius: i always feel like i'm cheating if i use the list monad
21:30:32 <mmorrow> err, or did you mean for State
21:30:35 <ddarius> I believe mapAccumL is sequence for the State monad.
21:30:48 <mmorrow> yeah, good observation
21:31:03 <dolio> Isn't it mapM?
21:31:08 <dolio> @type mapAccumL
21:31:09 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
21:31:10 <ddarius> Maybe.
21:31:18 <mmorrow> ah yeah, that's it
21:31:22 <wli> runState on the result of mapM
21:31:44 <ddarius> :t runState . mapM . State
21:31:45 <lambdabot>     Couldn't match expected type `a -> m b'
21:31:45 <lambdabot>            against inferred type `State s a1'
21:31:45 <lambdabot>     Probable cause: `State' is applied to too many arguments
21:32:03 <ddarius> :t (runState .) . mapM . State
21:32:04 <lambdabot>     Couldn't match expected type `a -> m b'
21:32:04 <lambdabot>            against inferred type `State s a1'
21:32:04 <lambdabot>     Probable cause: `State' is applied to too many arguments
21:32:10 <ddarius> :t ((runState .) .) . mapM . State
21:32:11 <lambdabot>     Couldn't match expected type `a -> m b'
21:32:11 <lambdabot>            against inferred type `State s a1'
21:32:11 <lambdabot>     Probable cause: `State' is applied to too many arguments
21:32:28 <ddarius> Ah yeah.  Need to swap args as well and such.
21:32:41 <ddarius> :t mapAccumR
21:32:42 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
21:33:04 <wli> @type \f -> runState . mapM (State . f)
21:33:05 <lambdabot> forall s a a1. (a1 -> s -> (a, s)) -> [a1] -> s -> ([a], s)
21:33:12 <ddarius> :t flip . runState . mapM . State . flip
21:33:12 <lambdabot>     Couldn't match expected type `(a, b)'
21:33:12 <lambdabot>            against inferred type `a1 -> c'
21:33:12 <lambdabot>     Probable cause: `flip' is applied to too few arguments
21:33:17 <wli> @pl \f -> runState . mapM (State . f)
21:33:17 <lambdabot> (runState .) . mapM . (State .)
21:33:23 <dolio> mapAccumR is what, backward state?
21:34:27 <wli> I'm not sure the two differ wrt. translations to the State monad.
21:34:40 <ddarius> @src mapAccumR
21:34:40 <lambdabot> Source not found. Wrong!  You cheating scum!
21:36:15 <wli> Anyway the brute force monadic everything approach is mostly serving me well.
21:37:18 <mmorrow> @type [(\f acc xs -> uncurry (flip (,)) (runState (mapM (State . ((uncurry (flip (,))) .) . flip f) xs) acc)), mapAccumL]
21:37:19 <lambdabot> forall b a a1. [(a -> a1 -> (a, b)) -> a -> [a1] -> (a, [b])]
21:37:26 <mmorrow> epic
21:37:40 <mmorrow> @pl (\f acc xs -> uncurry (flip (,)) (runState (mapM (State . ((uncurry (flip (,))) .) . flip f) xs) acc))
21:37:40 <lambdabot> ((uncurry (flip (,)) .) .) . flip . (runState .) . mapM . ((State . (uncurry (flip (,)) .)) .) . flip
21:37:47 <mmorrow> goooh
21:37:52 <dolio> > mapAccumR (\a _ -> (a+1, a)) 1 [1..10]
21:37:53 <lambdabot>   (11,[10,9,8,7,6,5,4,3,2,1])
21:38:00 <dolio> > mapAccumL (\a _ -> (a+1, a)) 1 [1..10]
21:38:01 <lambdabot>   (11,[1,2,3,4,5,6,7,8,9,10])
21:39:54 <mmorrow> @let swap = uncurry (flip (,))
21:39:55 <lambdabot>  Defined.
21:40:09 <mmorrow> @type [(\f acc xs -> swap (runState (mapM (State . (swap .) . flip f) xs) acc)), mapAccumL]
21:40:10 <lambdabot> forall a b a1. [(a -> a1 -> (a, b)) -> a -> [a1] -> (a, [b])]
21:40:17 <mmorrow> @pl (\f acc xs -> swap (runState (mapM (State . (swap .) . flip f) xs) acc))
21:40:18 <lambdabot> ((swap .) .) . flip . (runState .) . mapM . ((State . (swap .)) .) . flip
21:40:41 <mmorrow> @unpl ((swap .) .) . flip . (runState .) . mapM . ((State . (swap .)) .) . flip
21:40:41 <lambdabot> (\ n af ai -> swap (runState (mapM (\ ao -> (State) (\ as -> swap (n as ao))) ai) af))
21:40:59 <dolio> @type let ret a = \s -> (s,a) ; (m >>>= f) s = let (s'', a) = m s' ; (s', b) = f a s in (s'', b) ; mapMM f [] = ret [] ; mapMM f (x:xs) = f x >>>= \a -> mapMM f xs >>>= \as -> ret (a:as) in mapMM
21:41:00 <lambdabot> forall t t1 a. (t -> t1 -> (t1, a)) -> [t] -> t1 -> (t1, [a])
21:41:42 <mmorrow> one more flip
21:41:54 <dolio> > let ret a = \s -> (s,a) ; (m >>>= f) s = let (s'', a) = m s' ; (s', b) = f a s in (s'', b) ; mapMM f [] = ret [] ; mapMM f (x:xs) = f x >>>= \a -> mapMM f xs >>>= \as -> ret (a:as) in mapMM (\_ a -> (a+1,a)) [1..10] 1
21:41:55 <mmorrow> ooh, i hate trying to flip arg 2/3
21:41:55 <lambdabot>   (11,[10,9,8,7,6,5,4,3,2,1])
21:42:07 <dolio> So, yes, mapAccumR is mapM in the backward state monad.
21:42:52 <dolio> Modulo argument munging.
21:42:53 <mmorrow> @pl \x -> flip (flip f x)
21:42:53 <lambdabot> flip . flip f
21:42:57 <mmorrow> oh nice
21:43:08 <mmorrow> @type (flip .) . flip
21:43:09 <lambdabot> forall b c a b1. (a -> b1 -> b -> c) -> b1 -> b -> a -> c
21:44:43 <mmorrow> @let flop = (flip .) . flip
21:44:44 <lambdabot>  Defined.
21:44:52 <mmorrow> @type flop foldl
21:44:52 <lambdabot> forall a b. a -> [b] -> (a -> b -> a) -> a
21:45:17 <mmorrow> i constantly wish the folds were that arg order
21:45:52 <mmorrow> (for when you're handing it a non-trivial lambda)
21:50:40 <Eridius> how long do @lets persist?
21:50:53 <dolio> Until someone @undefines.
21:50:58 <dolio> Or lambdabot crashes.
21:51:29 <Eridius> lambdabot should check its @let bindings when asked for @src
21:51:29 <wli> If there were a Data.Traversable.mapM_ I'd be golden.
21:51:43 <dolio> Data.Foldable.mapM_
21:52:32 <johnw> is anyone else unable to "make install" GHC because it complains about a Cabal version mismatch?
21:53:55 <wli> Well, there we go.
21:54:07 <wli> @type let unfoldl f x = fst $ execState (let m = get >>= uncurry (\s -> Data.Foldable.mapM_ ((>> m) . put . first (:s)) . f) in m) ([], x) in unfoldl
21:54:08 <lambdabot> forall d (t :: * -> *) a. (Data.Foldable.Foldable t) => (d -> t (a, d)) -> d -> [a]
21:56:54 <mmorrow> @src bracket
21:56:54 <lambdabot> bracket before after thing = block $ do
21:56:54 <lambdabot>     a <- before
21:56:54 <lambdabot>     r <- catch (unblock (thing a)) (\e -> do { after a; throw e })
21:56:54 <lambdabot>     after a
21:56:54 <lambdabot>     return r
21:58:00 <Eridius> @src finally
21:58:01 <lambdabot> a `finally` sequel = block $ do
21:58:01 <lambdabot>     r <- catch (unblock a) (\e -> do { sequel; throw e })
21:58:01 <lambdabot>     sequel
21:58:01 <lambdabot>     return r
21:58:11 <Eridius> huh, I would have expected one of them to be defined in terms of hte other
21:58:11 <Eridius> *the
22:05:07 <wli> I guess I should brew up a representation for the STG core language.
22:10:23 <wli> Hmm. Maybe I should go with looser inspiration.
22:16:02 <mae> is there any way i can tell ghci to periodically poll for new changes ? or even to run :r every minute or so
22:25:29 <bmh> wli: I'm not sure what to name this data structures package of mine. "Structures" might be a little cocky
22:25:50 <wli> bmh: BMH Trees
22:26:03 <bmh> wli: that's a lame name for hackage
22:26:15 <bmh> "TreeStructures"?
22:26:30 <wli> That sounds good.
22:28:22 <wli> Okay, the first thing I can do once I hash cons expressions is to eliminate all let-bound variables that neither escape nor recurse.
22:33:13 <bmh> I have my source organized, my cabal file written. How do I package it all up for hackage?
22:33:26 <bmh> (NB. mkcabal won't install)
22:34:11 <TomMD> bmh: cabal sdist
22:34:27 <bmh> awesome
22:34:30 <TomMD> bmh: That will create a .dist/xxx.#.#.#.tar.gz file
22:34:43 <TomMD> err, just 'dist' not '.dist'
22:35:38 <bmh> hm.. the haddock docs don't see to be there
22:41:03 <dufflebunk> I want to make a function that splits a list up given an element to split it up with: Eq a => a -> [a] ->[[a]]
22:41:48 <mae> how can I emulate the behavior of && on the shell with System.Cmd.rawSystem ?
22:42:12 <dufflebunk> I figured there's already be something to do it, but the closes is span, but that only splits it in two.
22:42:13 <jeffwheeler> I'm working on a ticket for Yi (http://code.google.com/p/yi-editor/issues/detail?id=135), but I don't see any clear way to see the last time that a package's/library's source was recompiled.
22:42:30 <jeffwheeler> Does Cabal provide a build-time, anywhere, that's easy to read?
22:43:08 <bmh> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/TreeStructures-0.0.1 -- let there be light!
22:43:47 <dufflebunk> mae: The && isn't really part of a command. It's shell syntax.
22:44:50 <mae> yes i understand that
22:44:58 <dufflebunk> What you probably want to do is run it in bash, so you want ["foo", "&&", "bar"], then try: ["sh", "-c", "foo && bar"]
22:45:12 <mae> dufflebunk: nope, I want platform independence :)
22:45:18 <mae> i want something like what bash does
22:45:18 <dufflebunk> ah, ok
22:45:54 <mae> there is mplus, but IO defines this in terms of throwing exceptions
22:46:03 <mae> and an ExitFailure does not throw an exception
22:46:08 <mae> so i have to define my own monad
22:46:18 <mae> i was just thinking, gee, I wonder if there is a lib like this already :)
22:47:23 <TomMD> bmh: The proper category is 'Data', just fyi
22:47:57 <bmh> drat.
22:48:39 <bmh> that's what I get for looking at other packages
22:48:54 <TomMD> bmh: No big deal, if a new release has the change then this new category will disappear.  I've the same issue right now with one of my packages being in 'networking' instead of 'network'
22:49:57 <bmh> TomMD: a new version will probably be by within the week. I need to add more structures and all sorts of quickcheck stuff. I also need to clean up my O(n) heap construction
22:50:16 <TomMD> bmh: What?  O(n) isn't in style anymore?
22:50:34 <dufflebunk> mae: Can't help much then, sorry. I'd probably make a small structure like: data Cmd = Cmd [String] (ExitFailure -> Bool) Cmd | Done  then just write a function that goes through the structure so long as the condition is True. Not a nice as what you want probably, but I'm not good enough to go for pretty ;)
22:50:37 <bmh> TomMD: I mean the code itself. I'm doing tournament style merging, and the code looks like crap
22:51:05 <c_wraith> I demand nothing worse than O(lg n) when processing O(n) data.  Don't give me any sort of factual argument as an excuse why it can't be done.
22:51:11 <wli> TomMD: Was it ever?
22:51:21 <mae> dufflebunk: 10-4 thanks :)
22:59:56 <dons> haskell being used at friendster? http://twitter.com/LaTtEX/statuses/1340635159 <--
23:00:13 <wli> Okay, so I'm hash consed, so now I need to find let-bound variables that neither escape nor recurse.
23:06:16 <wli> I can't figure out how to determine either of those two conditions.
23:12:55 <mmorrow> @let prod (><) f g = (\p -> f p >< g p)
23:12:56 <lambdabot>  Defined.
23:12:59 <mmorrow> @let coprod (<>) f g = (\a b -> f a <> g b)
23:13:00 <lambdabot>  Defined.
23:13:43 <mmorrow> @type let on (<>) f = coprod (<>) f f in [on, Data.Function.on]
23:13:44 <lambdabot> forall t2 t4 t. [(t2 -> t2 -> t4) -> (t -> t2) -> t -> t -> t4]
23:13:54 <wli> I have the general idea of how to determine whether a let-bound variable recurses, and am not even sure of the general idea of how to determine whether it escapes.
23:14:34 <mmorrow> wli: you'd need to build the control-flow graph
23:15:09 <mmorrow> and do some dataflow analysis that computes that in particular
23:15:22 <mmorrow> (or something)
23:15:44 <edwardk> ah woot, Data.Function, i wondered where they'd stuffed that. i use it all the time ;)
23:15:57 <edwardk> now I can actually import rather than rewrite it all over the place
23:16:17 <wli> The basic idea here is that once you're hash consed, let-bound variables can be gotten rid of in favor of directly plugging values into the subexpression DAG.
23:16:30 <wli> But only if they neither recurse nor escape.
23:16:31 <mmorrow> edwardk: heh, yeah i always end up duplicating fix because i don't want to scroll up and write "import Data.Function"
23:16:43 <mmorrow> > length "fix f = let x = f x in x"
23:16:44 <lambdabot>   24
23:16:52 <mmorrow> > length "import Data.Function"
23:16:53 <lambdabot>   20
23:16:54 <mmorrow> aww
23:17:03 <mmorrow> almost
23:17:45 <mmorrow> wli: wouldn't that result in a total loss of sharing?
23:18:30 <wli> mmorrow: Not at all. The temporary name used in the stack frame just takes the place of the variable name, and an indirection vaporizes.
23:18:35 <mmorrow> wli: that's one method that i've read used for inlining, but a let-bound var is only inlined into the rhs if it's only used once (or is trivial)
23:19:12 <mmorrow> wli: maybe i'm confused what you're saying. so what would happen in this:
23:19:26 <mmorrow> let x = 1 + 1 in f x x
23:19:27 <mmorrow> ?
23:19:49 <mmorrow> or is that "escaping"
23:20:02 <wli> No, it doesn't escape.
23:20:11 <mmorrow> so you'd inline (1 + 1) twice?
23:20:16 <wli> No
23:20:30 <mmorrow> what would you do?
23:21:24 <mmorrow> (assuming (1 + 1) could just as well be (reallyExpensive 42))
23:21:29 <wli> $t1 <- IntExpr 1 ; $t2 <- AppExpr "+" $t1 ; $t3 <- AppExpr $t2 $t1 ; $t4 <- AppExpr "f" $t3 $t3
23:22:13 <mmorrow> oh, ok. that looks like the standard way to me
23:22:57 <mmorrow> ("standard" being relative to a (spineless) graph reduction strategy)
23:23:45 <mmorrow> wli: so did i misunderstand what you said earlier about "getting rid of let-bound expressions", or is this how you meant it, or did your strategy just not happen to apply in this case?
23:23:51 <wli> Expressions become DAG's instead of trees, and some of the variable bindings disappear as they're just used to connect the DAG in a non-tree-like fashion.
23:24:09 <wli> mmorrow: What happened in this case is the whole of my strategy.
23:24:09 <mmorrow> oh, yeah totally. that's the beauty of graph reduction. :)
23:24:27 <mmorrow> sharing "just happens"
23:24:27 <wli> This isn't graph reduction, this is static analysis.
23:24:53 <mmorrow> well, it's the building part of it
23:25:10 <mmorrow> and the generated code does it at runtime
23:25:20 <wli> My plot is to heap allocate let-bound variables not satisfying this criterion.
23:25:34 <mmorrow> ohhhh. wait
23:25:37 <mmorrow> so in
23:25:38 <mmorrow> $t1 <- IntExpr 1 ; $t2 <- AppExpr "+" $t1 ; $t3 <- AppExpr $t2 $t1 ; $t4 <- AppExpr "f" $t3 $t3
23:25:46 <mmorrow> "<-" doesn't mean heap allocation?
23:26:05 <wli> No, it's subexpression formation.
23:26:26 <mmorrow> but where are you storing "IntExpr 1"?
23:26:31 <mmorrow> and what is "$t1"
23:27:02 <wli> The numbers after the "$t" are IntMap indices, and the RHS's of <- are IntMap entries.
23:27:46 <mmorrow> ah. is the IntMap you model heap, or is it the virtual heap you intend to use for statically doing this
23:27:47 <mmorrow> ?
23:28:29 <wli> This particular IntMap is just to represent expressions.
23:29:13 <mmorrow> for interpretation? or for code generation?'
23:29:49 <mmorrow> i'm confused about where in the process we are
23:29:54 <wli> It's got the generality of a DAG, which I'm leveraging in this case to eliminate uses of variables which are non-essential in DAG representations.
23:30:26 <mmorrow> ah, ok. so this is a static analysis you're going to do during "compilation".
23:30:34 <wli> This is a very early preparatory pass during bytecode generation.
23:30:42 <mmorrow> cool. i see you know.
23:32:11 <wli> I just finished hash consing expressions again.
23:44:03 <wli> The hash consing implementation is short and sweet.
23:52:21 <mmorrow> oops, my earlier definition of `pushout' was wrong
23:52:23 <wli> http://wli.pastebin.com/ma1375c0 <-- I suspect there are ways to eliminate more boilerplate
23:52:59 <wli> That's Traversable.mapM getting used there BTW.
23:53:20 <mmorrow> @undefined
23:53:21 <mmorrow> @undefine
23:53:27 <mmorrow> hmm
23:53:34 <mmorrow> > pullback
23:53:35 <lambdabot>   Not in scope: `pullback'
23:53:42 <mmorrow> @let pushout (=?=) f g as = nubBy (\(b1,c1) (b2,c2) -> b1 =?= c2 || b2 =?= c1) [ (fa, ga) | a <- as, let {fa = f a; ga = g a}, fa =?= ga ]
23:53:42 <lambdabot>  Defined.
23:54:01 <mmorrow> @let pullback (=?=) f g as bs = [ (a, b) | a <- as, b <- bs, f a =?= g b ]
23:54:01 <lambdabot>  Defined.
23:55:16 <mmorrow> wli: cool
