00:00:01 <Taejo> ivanm: thank you, and my apologies
00:00:07 <ivanm> no worries
00:00:21 <ivanm> it's rather quite at the moment, but if it suddenly gets busier then ... *shrug*
00:01:16 <Taejo> ivanm: sure
00:10:43 * Taejo fmap `fmap` fmap `fmap` fmap
00:10:54 <pumpkin> rude
00:11:31 <ivanm> @slap Taejo
00:11:32 <lambdabot> stop telling me what to do
00:11:36 <ivanm> grrr.....
00:11:52 <pumpkin> is there a way to get ghc to dump explicitly where each applicable rewrite rule is firing? I'm looking around in the various -ddump-simpl* but it doesn't seem to say where it's happening, just that it is
00:11:55 <ivanm> pumpkin: you want to try telling lambdabot what to do? ;-)
00:12:06 <pumpkin> :o
00:12:21 <ivanm> to @slap Taejo for his rudeness!
00:12:29 <pumpkin> @slap Taejo
00:12:29 * lambdabot hits Taejo with a hammer, so they breaks into a thousand pieces
00:12:33 <pumpkin> :o
00:12:43 <Taejo> they breaks?
00:12:47 <Taejo> lambdabot--
00:13:10 <ivanm> lambdabot++
00:13:12 <ivanm> Taejo--
00:13:21 <ivanm> how dare you try and reduce lambdabot's karma!
00:13:23 <ivanm> @karma lambdabot
00:13:24 <lambdabot> lambdabot has a karma of 1
00:14:53 <scriptdevil> Is it ok to use a tab of 4 spaces. (Not a mixture. Just spaces. But only 4)
00:15:30 <inimino> 4 spaces is 4 spaces, not a tab
00:15:57 <inimino> but indentation by means of spaces is generally a good practice
00:16:29 <ivanm> the report says tabs == 8 spaces
00:16:35 <ivanm> but most people agree that spaces > tabs
00:17:46 <mmorrow> anyone have some nice one-liners for left and right (bitwise) rotation?
00:18:16 <mmorrow> (obviously not allowed to use rotate[R,L])
00:18:26 <pumpkin> shiftR/L?
00:18:31 <mmorrow> rotation
00:18:35 <pumpkin> I mean
00:18:39 <pumpkin> are we allowed to use those
00:18:42 <mmorrow> sure
00:18:44 <mcnster> @hoogle IOException
00:18:45 <lambdabot> Control.Exception IOException :: IOException -> Exception
00:18:45 <lambdabot> Control.Exception data IOException
00:19:08 <mmorrow> pumpkin: you're allowed to use any C primitive
00:19:11 <pumpkin> mmorrow: you can do the shiftR | shiftL but you need to know how wide the int is
00:19:20 <mmorrow> assume you have macros for that
00:19:33 <mmorrow> (and that we're doing it on unsigned ints)
00:19:42 <mmorrow> ohhh
00:19:48 <mmorrow> i just grokked what you jyust said
00:19:57 <pumpkin> :)
00:19:59 <mmorrow> nice, that's easy
00:20:00 <mmorrow> :)
00:22:08 <scriptdevil> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2179#a2179
00:22:16 <scriptdevil> Anyone?
00:22:48 <scriptdevil> never mind. I found the problem
00:22:49 <scriptdevil> !
00:24:28 <scriptdevil> Oh well http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2179#a2180 Same error!
00:26:36 <trofi>             return num : tail
00:26:52 <trofi> is there ok with operator precedence?
00:27:05 <scriptdevil> trofi: Oh... Well.. no..
00:27:33 <scriptdevil> trofi: But still.. The error is on a different line
00:27:33 * mmorrow loves how his limits.h is missing some standard macros..
00:27:57 <scriptdevil> trofi: Even after the change
00:28:10 <scriptdevil> trofi: It is on the if line
00:28:12 <trofi> and do word is superfluous
00:28:39 <trofi> 'if' is a pure construct (but returns monad tho)
00:29:13 <trofi> s/num = do/num =/
00:30:42 <scriptdevil> trofi: Works. :) Thanks. So where do I have to use do? Where I couple actions other than if-then-else?
00:31:14 <trofi> do you know do-less monad syntax?
00:31:43 <trofi> (IOW, how to write equivalent code without any do constucts)
00:34:34 <mmorrow> garh, this took wayyyy longer than it should have ;) http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1793#a1793
00:34:50 <mmorrow> oh, i forgot rot{l,r}..
00:35:06 <trofi> scriptdevil: 've read http://book.realworldhaskell.org/read/monads.html ? :]
00:35:11 <mmorrow> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1793#a1794
00:35:20 <trofi> (esp. Desugaring of do blocks)
00:35:24 <scriptdevil> trofi: not yet
00:35:30 <trofi> try to
00:35:40 <pumpkin> mmorrow: omg you used %
00:36:05 <scriptdevil> trofi: sure. I was in chapter 4.. Then I suddenly became dormant ;)
00:36:11 <pumpkin> I wonder if your compiler is smart enough to change a mod by a power of 2 into a bitwise op
00:36:29 <edwardk> pumpkin: assuming its been written in the last two decades? =)
00:36:32 <trofi> scriptdevil: ah :]
00:36:36 <mmorrow> omg this one werx http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1793#a1795
00:36:44 <pumpkin> edwardk: who knows! :P
00:36:49 <mmorrow> pumpkin: oh hmm
00:36:56 <pumpkin> I've seen so many people write out mod by power of 2 explicitly
00:37:16 <pumpkin> probably a self-perpetuating myht
00:37:19 <edwardk> pumpkin: i've seen cargo cult programmers do lots of things ;)
00:37:25 <trofi> scriptdevil: in short, any sequence of monadic actions needs do word
00:37:50 <pumpkin> :)
00:38:03 <edwardk> back in the turbo pascal days it mattered because the compiler didn't do much anything, but i can't think of a compiler that doesn't strength reduce that sort of thing that wasn't written by an undergrad ;)
00:38:08 <mmorrow> hehe "cargo cult"
00:39:26 <mmorrow> pumpkin: there's only one way to find out ...
00:39:32 <pumpkin> too lazy :P
00:41:32 <edwardk> pumpkin: just checked for you, gcc still does it, all these many years later ;)
00:41:39 <pumpkin> yay
00:43:01 <mmorrow> pumpkin, edwardk: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1793#a1796
00:43:22 <mmorrow> not bad
00:43:28 <pumpkin> that's even nicer
00:45:16 <dolio> I know one. GHC. :)
00:45:51 <edwardk> dolio: heh, strength reduction doesn't make sense for most of its numeric types
00:46:07 <edwardk> and you have --via-c and all that anyways
00:46:46 <edwardk> besides i think ghc meets my earlier criteria, didn't simon pj never get a ph.d? =)
00:47:06 <dolio> Heh.
00:47:19 <pumpkin> he has an MS
00:47:25 <edwardk> ah shucks =)
00:48:12 <pumpkin> and even if he didn't, he probably wasn't an undergrad when he wrote it :P
00:48:35 <pumpkin> or is it "once an undergrad, always an undergrad, until you get a higher degree"? :P
00:48:38 <edwardk> well, stuff written by folks in industry tends to be even worse than that written by undergrads ;)
00:49:10 <pumpkin> people in industry seem convinced of the same thing, except replace undergrads with academics :P
00:49:23 <dolio> Wow, the code generated for Word is a lot different than the one for Int.
00:49:24 <pumpkin> oh wait
00:49:27 <pumpkin> wrong replacement :)
00:49:31 <edwardk> well, i would say that you should generalize to just realize that most code is crap ;)
00:49:37 <pumpkin> yeah :)
00:50:01 <pumpkin> hmm, the CORE pragma seems to affect code generation
00:50:08 <edwardk> dolio: yeah, you have to ensure that it generates all those microsoft bugs
00:50:28 <edwardk> wait, wrong Word
00:50:38 <dolio> Zing!
00:58:30 <mmorrow> dolio: were you talking about gcc ("Word different than Int")?
00:58:39 <dolio> No, GHC.
00:58:43 <mmorrow> because it's way diff
00:58:46 <mmorrow> ah
00:59:33 <dolio> It doesn't turn `mod` 1024 into .&. 1023 for either, though, as far as I can tell.
00:59:40 <scriptdevil> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2181#a2181
01:00:01 <mmorrow> dolio: look at for gcc http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1793#a1798
01:00:06 <scriptdevil> Can someone check that out please?
01:00:41 <mmorrow> scriptdevil: use fromIntegral
01:00:53 <mmorrow> powers5 x = map pow5 [1 .. intlog5 (fromIntegral x)]
01:01:02 <scriptdevil> mmorrow: Thanks
01:01:04 <mmorrow> :)
01:01:47 <mmorrow> oops, i guess i pasted that twice
01:02:19 <dancor> we run a fork of lambdabot at work in a git repo.  should i switch it to a darcs repo so it's easy to merge upstream changes, or is there a git<->darcs bridge?
01:02:24 <dolio> > ((-5) `mod` 1024, (-5) .&. 1023) :: (Int,Int)
01:02:25 <lambdabot>       Ambiguous occurrence `.&.'
01:02:25 <lambdabot>      It could refer to either `Data.Bits..&....
01:02:32 <dolio> > ((-5) `mod` 1024, (-5) Data.Bits..&. 1023) :: (Int,Int)
01:02:34 <lambdabot>   (1019,1019)
01:02:47 <mmorrow> wuh, what's the other (.&.) ?
01:03:00 <mmorrow> , ((-5) `mod` 1024, (-5) .&. 1023) :: (Int,Int)
01:03:02 <lunabot>  luna: Not in scope: `.&.'
01:03:04 <mmorrow> grr
01:03:47 <dolio> @hoogle (.&.)
01:03:48 <lambdabot> Data.Bits (.&.) :: Bits a => a -> a -> a
01:04:49 <mmorrow> , ((-5) `mod` 1024, (-5) .&. 1023) :: (Int,Int)
01:04:50 <lunabot>  (1019,1019)
01:07:58 <mmorrow> dancor: i think there's some sort of darcs->git converter, but going darcs->git is lossy
01:08:14 <mmorrow> not sure if there's a git->darcs..
01:08:43 <dancor> lossy would be fine if it's better than manually merging right now
01:11:06 <mmorrow> dancor: http://repo.or.cz/w/darcs2git.git
01:11:12 <dancor> i'm only avoiding darcs bc it's another hurdle for other ppl at work doing mods
01:11:20 <dancor> tx
01:11:58 <mmorrow> np
01:16:29 <Fredrik_> @pl f x = x + 1
01:16:30 <lambdabot> f = (1 +)
01:16:36 <Fredrik_> @pl u p f = do r <- f; if p r then return r else u p f
01:16:36 <lambdabot> (line 1, column 18):
01:16:36 <lambdabot> unexpected ";"
01:16:36 <lambdabot> expecting letter or digit, variable, "(", "`", "!!", ".", operator or end of input
01:17:16 <Fredrik_> @pl u p f = f >>= \r -> if p r then return r else u p f
01:17:17 <lambdabot> u = fix ((ap (>>=) .) . ap ((.) . flip . (`ap` return) . (if' .)))
01:19:06 <Fredrik_> :t ap
01:19:08 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
01:22:49 <dolio> , (5 `mod` (-1024), 5 .&. (-1023)) :: (Int, Int)
01:22:50 <lunabot>  (-1019,1)
01:27:39 <scriptdevil> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2182#a2182
01:28:35 <scriptdevil> I am sorry I am asking so many questions :(
01:28:55 <dolio> readl(num-1) :: IO [Int] (or whatever)
01:29:16 <dolio> IO [String] I guess.
01:29:38 <dolio> Also. [] isn't right in the then case.
01:30:05 <scriptdevil> dolio: omg... I missed an s in the return :-|
01:30:23 <scriptdevil> dolio: what else?
01:30:39 <dolio> I think those three are it.
01:31:04 <scriptdevil> dolio: Can you paste a correct code in that screen?
01:31:36 <dolio> @type replicateM 5 getLine
01:31:37 <lambdabot> IO [String]
01:37:50 <scriptdevil> dolio: Hmmm.. I am still kinda clueless... Could you paste the code?
01:55:42 <brool> scriptdevil: added a revision, maybe that's what you want?
02:03:59 <Fredrik_> @i any
02:04:00 <lambdabot> Maybe you meant: id ignore index instances instances-importing irc-connect . ? @ v
02:04:27 <Fredrik_> @?
02:04:47 <trofi> :t any
02:04:48 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
02:05:04 <Fredrik_> I want to see the implementation :)
02:05:10 <trofi> @src any
02:05:10 <lambdabot> any p =  or . map p
02:05:15 <Fredrik_> thx
02:05:34 <Fredrik_> @src or
02:05:35 <lambdabot> or    =  foldr (||) False
02:05:38 <Fredrik_> ah
02:05:56 <trofi> @hoogle :: Bool -> Bool -> Bool
02:05:57 <lambdabot> Prelude (&&) :: Bool -> Bool -> Bool
02:05:57 <lambdabot> Prelude (||) :: Bool -> Bool -> Bool
02:05:57 <lambdabot> Data.Bool (&&) :: Bool -> Bool -> Bool
02:17:32 <mmorrow> preflex: seen Botje
02:17:40 <mmorrow> @seen Botje
02:17:41 <lambdabot> Botje is in #haskell.dut and #haskell. I last heard Botje speak 8h 19m 14s ago.
02:19:51 <mmorrow> @tell Botje apparently Biplate dies with "undefined" if you try to use universeBi on datatypes with strict fields. i discovered this while trying out milc, and it was just dying with "milc: undefined" until i finally figured this out and got rid of the bangs on all the datatypes in AST and CPS..
02:19:52 <lambdabot> Consider it noted.
02:21:22 <Fredrik_> @src concatMap
02:21:22 <lambdabot> concatMap f = foldr ((++) . f) []
02:28:22 <Fredrik_> @src maybe
02:28:22 <lambdabot> maybe n _ Nothing  = n
02:28:22 <lambdabot> maybe _ f (Just x) = f x
02:29:49 <Fredrik_> @src Either
02:29:49 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
02:30:06 <Deewiant> Is there no way of telling Cabal to pass a certain option to cpphs?
02:30:18 <beelsebob> ohhhhh, next OS X release is gonna be great for Haskell typing... system wide text substitutions of things like -> with →
02:34:04 <Fredrik_> @src fst
02:34:05 <lambdabot> fst (x,_) =  x
02:34:18 <Fredrik_> @src snd
02:34:18 <lambdabot> snd (_,y) =  y
02:35:14 <Saizan> Deewiant: there's cpp-options: in .cabal files
02:35:35 <Saizan> Deewiant: and --cpp-options= as a cl argument
02:35:57 <Deewiant> Saizan: thanks. It's not documented, though :-P
02:36:51 <Fredrik_> :t concatMAp
02:36:52 <Deewiant> Hmm, and now how do I get this to use cpphs instead of GHC's cpp
02:36:53 <lambdabot> Not in scope: `concatMAp'
02:36:56 <Fredrik_> :t concatMap
02:36:57 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
02:40:14 <Saizan> Deewiant: there doesn't seem to be a way, actually
02:41:05 <Saizan> Deewiant: short of defining a "custom" preprocessor in the Setup.hs
02:42:02 <Deewiant> Meh, that sucks
02:42:03 <Fredrik_> @src liftA2
02:42:04 <lambdabot> liftA2 f a b = f <$> a <*> b
02:42:15 <Fredrik_> @src liftM2
02:42:16 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
02:42:29 <Fredrik_> :t <$>
02:42:30 <lambdabot> parse error on input `<$>'
02:42:35 <Fredrik_> :t (<$>)
02:42:36 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
02:48:49 <Deewiant> Oh nice, there is a ready ppCpphs which I could use in Distribution.Simple.PreProcess but it's not exported
02:49:08 <Deewiant> Looks like I have to lie about what compiler I'm using in order to get at it
02:49:36 <Saizan> yeah..
02:50:29 <Saizan> i wonder if there's any reason why you should never use a different cpp with ghc
02:50:59 <Deewiant> I don't see what reason there could be
02:51:57 <koeien> trxhs!
02:52:04 <koeien> trhsx, i mean
02:52:17 <koeien> but that could now be solved with quasiquoting
02:52:17 <Saizan> what about it?:)
02:52:26 <koeien> Saizan: it's a cpp right? :)
02:52:41 <Saizan> isn't it only a pp?
02:52:43 <koeien> maybe not a Cpp, rather a Hpp
02:53:03 <Saizan> by cpp i mean something that interprets #ifdefs and #define etc..
02:59:08 <aleator> ghc quasiquoting blows my mind. Has anyone done anything with it yet?
03:36:26 <multiholle> does anybody know, how to connect to pc via network? exists a simple example?
03:39:33 * Botje yawns
03:39:34 <lambdabot> Botje: You have 1 new message. '/msg lambdabot @messages' to read it.
03:40:06 <Botje> mmorrow: eep, that's scary. Odd that i never ran into it :)
03:40:24 <multiholle> no one knows how to build a simple client/server application? doesn't exist an example?
03:40:49 <mcnster> ffi q.  i have a foreign import of Ptr Foo -> CInt (where Ptr Foo is a kind of file descriptor).  does the return value have to be of IO CInt?
03:40:54 <leadnose_> multiholle, check out real world haskell
03:41:07 <leadnose_> http://book.realworldhaskell.org/read/
03:42:25 <mcnster> leadnose_, multiholle:  rwh is the best hs book i've come across (i bought it in hard copy)
03:42:52 <mmorrow> Botje: yeah, i was wondering about that (why you never ran into it)
03:42:54 <mmorrow> weird
03:43:08 <mmorrow> Botje: maybe Uniplate changed something?
03:43:15 <Botje> that's possibly
03:43:18 <Botje> *possible
03:43:26 <Botje> in my current project i'm not using strict fields anymore
03:43:54 <Botje> they don't really do anything noticeable anyway :)
03:44:08 <mmorrow> Botje: i'm curious what the uniplate code is doing to cause this
03:44:51 <mmorrow> i guess it's probably just inserting explicit "undefined"s into fields..
03:45:06 <mmorrow> that's kinda sketchy
03:45:09 <multiholle> thanks. the book is realy good :)
03:57:15 <Deewiant> Can anybody confirm that GHC barfs on this? http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=2184#a2184
03:57:19 <Gracenotes> > let (a+1) = 5 in a
03:57:20 <lambdabot>   4
03:59:40 <porges> *twitch*
04:01:02 <Deewiant> C'mon, nobody feels like trying to compile a bunch of comments? :-P
04:01:13 <Gracenotes> + is my favorite constructor in the whole world
04:01:50 <trofi> > let (a-1) = 5 in a
04:01:51 <lambdabot>   <no location info>: Parse error in pattern
04:01:55 <trofi> > let (a+1) = 5 in a
04:01:57 <lambdabot>   4
04:02:14 <trofi> awfully regular
04:02:35 <cnwdup> Deewiant, ghc complains about the LANGUAGE pragma.
04:02:39 <wli> > let (2 * a + 1) :: Integer = 5 in a
04:02:41 <lambdabot>   <no location info>: Parse error in pattern
04:02:54 <Deewiant> cnwdup: alright, thanks. Notice that it doesn't if you remove even a single byte from the preceding comments.
04:02:57 <Gracenotes> Deewiant: it seems to be all better if you get rid of the blank line between the last comment and the LANGUAGE directive
04:03:08 <trofi> > let (log(a)) = sin(a) in a
04:03:08 <Deewiant> Gracenotes: removing absolutely anything will do.
04:03:09 <cnwdup> Deewiant, seems like those definitions have to be in the first line.
04:03:09 <lambdabot>   <no location info>: Parse error in pattern
04:03:32 <wli> m * n + k patterns would've been nice from my POV, not that anyone else likes n + k patterns.
04:03:33 <cnwdup> Deewiant, oh. Haven't read your response. Thats odd, indeed.
04:03:34 <Gracenotes> ah, I see
04:03:34 <Deewiant> cnwdup: No they don't.
04:03:45 <Deewiant> It's a bug which I'm reporting within about 60 seconds.
04:03:48 <Deewiant> Thanks for the confirmations. :-)
04:04:08 <porges> perhaps there is a limit on how much the parser gobbles as a comment at a time
04:04:28 <trofi> > case 5 of (x+1) -> x; (x+2) -> x
04:04:29 <lambdabot>   4
04:04:36 <trofi> > case 5 of (x+1) -> x*2; (x+2) -> x
04:04:37 <lambdabot>   8
04:04:39 <Gracenotes> 10, 9, 8, 7...
04:04:45 <Gracenotes> 3
04:04:47 <Gracenotes> 2
04:04:48 <Gracenotes> 1
04:04:53 <Gracenotes> submitted!
04:04:58 <Gracenotes> :X
04:05:27 <Deewiant> I said 'about'
04:05:32 <Deewiant> http://hackage.haskell.org/trac/ghc/ticket/3079
04:05:56 <Deewiant> Now you made me hurry a bit so I probably forgot something relevant :-P
04:06:16 <Gracenotes> oh, the length is 1024. hmmm.
04:06:28 <centrinia> What should (let (2*a) :: Integer = 1 in a) be?
04:06:51 <Deewiant> Gracenotes: rather, 1024 is between the {-# and the #-}
04:07:03 <Deewiant> centrinia: a parse error
04:07:37 <wli> error
04:07:48 <Gracenotes> if an n*k were allowed, as was proposed I think?
04:08:00 <centrinia> Gracenotes: Yes.
04:08:07 <porges> //stab
04:08:20 <EvilTerran> centrinia, undefined, as it's a pattern-match failure
04:08:29 <EvilTerran> > let x+1 = 0 in x
04:08:30 <lambdabot>   x
04:08:33 <EvilTerran> er
04:08:35 <Deewiant> heh
04:08:40 <Deewiant> > let x+1 = 0 in 1+1
04:08:42 <lambdabot>   0
04:08:45 <EvilTerran> > let (x+1) = 0 in x
04:08:46 <lambdabot>   * Exception: /tmp/7265359645481580620:71:44-52: Irrefutable pattern failed ...
04:09:23 <centrinia> > let (x+1) = 0 in x+1
04:09:25 <lambdabot>   * Exception: /tmp/5445786928143363989:71:48-56: Irrefutable pattern failed ...
04:09:50 <Gracenotes> > let (a+1) = 0 in a
04:09:51 <lambdabot>   * Exception: /tmp/5454082546630003967:71:44-52: Irrefutable pattern failed ...
04:09:54 <Gracenotes> > let (a+1) = 1 in a
04:09:55 <lambdabot>   0
04:09:58 <Gracenotes> x.x
04:10:11 <centrinia> > let (x+1) = 2*x in x
04:10:13 <lambdabot>   * Exception: stack overflow
04:10:16 <centrinia> Wow.
04:10:19 <centrinia> > let (x+1) = 2*x-1 in x
04:10:34 <Gracenotes> > let (a+1) = 1 in a :: Natural
04:10:34 <lambdabot>   thread killed
04:10:35 <lambdabot>   0
04:10:44 <centrinia> > let (x+1) = 2*x+3 in x
04:10:59 <lambdabot>   thread killed
04:13:03 <centrinia> > let (x+2^100)=2^101 in x `mod` 2
04:13:04 <lambdabot>   <no location info>: Parse error in pattern
04:13:14 <centrinia> > let (x+(2^100))=2^101 in x `mod` 2
04:13:16 <lambdabot>   <no location info>: Parse error in pattern
04:13:30 <centrinia> I don't want to write out 2^100 manually. :(
04:15:24 <cnwdup> Is it possible to let the compile solve equations like this?
04:16:22 <Axman6> > 2^100
04:16:24 <lambdabot>   1267650600228229401496703205376
04:16:30 <Axman6> C&P
04:16:48 <trofi> >let (0*a) = 0 in a
04:17:40 <cnwdup> > let a = 1; (x+a) = 10 in x
04:17:41 <lambdabot>   <no location info>: Parse error in pattern
04:17:45 <cnwdup> > let (x+1) = 10 in x
04:17:47 <lambdabot>   9
04:18:11 <cnwdup> Why is the second working and the first isn't?
04:20:41 <Olathe> Because a isn't defined in the first one.
04:21:02 <cnwdup> Isn't it defined as a = 1?
04:21:07 <cnwdup> > let a = 1; x = a in x
04:21:09 <lambdabot>   1
04:21:13 <Olathe> Nope.
04:21:28 <Olathe> > let a = 5; f a b = a + b in f 0 1
04:21:29 <lambdabot>   1
04:21:35 <Olathe> a isn't 5 in f.
04:21:51 <dolio> In n+k patterns k must be an integral literal, I believe.
04:21:54 <Olathe> > let a = 5; (....) a b = a + b in 0 .... 1
04:21:56 <lambdabot>   1
04:22:03 <Olathe> a isn't 5 in that either.
04:22:22 <Olathe> > let a = 5; (+) a b = a * b in 0 + 1
04:22:23 <lambdabot>   0
04:22:28 <Olathe> And that's what you had.
04:22:37 <Olathe> > let a = 5; a + b = a * b in 0 + 1
04:22:38 <lambdabot>   0
04:23:51 <cantor> how would you define filter p as an instance of foldr ?
04:23:53 <cnwdup> Olathe, ah. Okay. So you redefine (+) if you write a + b?
04:24:01 <Olathe> cnwdup: Yep.
04:24:30 <Olathe> cnwdup: Any variables on the left side of an assignment can only get values from the right or from whatever is filled in when the function is used.
04:24:41 <cnwdup> Olathe, thanks.
04:24:48 <Olathe> cantor: Well, the accumulator is a list.
04:24:53 <Olathe> cnwdup: You're welcome.
04:25:18 <Olathe> @type foldr
04:25:19 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
04:25:28 <cantor> jap
04:26:03 <Olathe> > let fltr f = foldr (\el ac -> el:ac) [] in fltr even [1..10]
04:26:04 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
04:26:28 <Olathe> That's pretty easy to modify to get what you want.
04:28:09 <cantor> thanks Olathe
04:28:21 <Olathe> cantor: You're welcome.
04:34:12 <mmorrow> this is cool: gcc alternatively uses a jump-table or a (unrolled in asm) binary search for switch statements depending on the case values http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1801
04:35:40 <Deewiant> Yes, most sane compilers do :-)
04:35:54 <centrinia> What about a perfect hash table? :(
04:36:44 <mmorrow> i wonder if there're any other variations for a switch
04:40:09 <trofi> AFAIR, switch->computed gotos is a gcc >= 4 feature
04:40:36 <Deewiant> Really? O_o
04:45:40 <mije> i have an issue installing cabal-install
04:46:10 <mije> when i run bootstrap.sh, i end up with /usr/bin/ld: cannot find -lgmp
04:46:36 <mije> did someone met this problem ?
04:49:33 <Saizan> can you compile other haskell programs with ghc?
04:50:06 <Saizan> i think you need to install libgmp via your OS's package manager otherwise
04:50:29 <centrinia> mije: Try setting LD_LIBRARY_PATH=/usr/lib:$LD_LIBRARY_PATH or whereever libgmp.so is.
04:50:42 <mije> ok
04:51:38 <mmorrow> omg, the ghc-produced asm for this (the same as that C switch, but a case) is over 14000 lines long http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1801#a1805
04:52:03 <mmorrow> i can't even tell if it's binary searching or just running through it linearly
04:52:11 <mmorrow> i think linearly..
04:52:29 <mmorrow> http://moonpatio.com/repos/foo.s
04:54:40 <dolio> That case is ridiculous.
04:54:45 * mmorrow takes a note never to switch on a bunch of literals in haskell
04:55:21 <mmorrow> dolio: heh, what's ridiculous? the case stmt itself, or the asm?
04:55:31 <mmorrow> err, i mean case expr of course ;)
04:55:34 <dolio> Well, both, I guess.
04:55:46 <mmorrow> dolio: which did you mean though initially?
04:55:55 <dolio> The case expression.
04:56:00 <mmorrow> heh, ok
04:56:20 <mmorrow> i wanted to compare it to gcc's asm for the equiv switch
04:56:50 <mmorrow> dolio: gcc apparently is doing an unrolled binary search (or something) http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1801#a1804
04:57:04 <arjanb> does restricting the type help anything?
04:57:23 <mmorrow> arjanb: good point
04:57:25 * mmorrow tries
04:58:27 <mmorrow> holy crap
04:58:47 <mmorrow> using Int, it becomes 1209 lines of asm
04:58:52 <mmorrow> :o
04:59:06 <dolio> Better than 14 thousand.
04:59:17 <Botje> @instances Num
04:59:18 <lambdabot> Double, Float, Int, Integer
04:59:24 <Botje> was it generating an instance for each type? :(
05:00:12 <dolio> Yeah, what type was it using before?
05:00:59 <mmorrow> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1801#a1808
05:01:02 <mmorrow> dolio: Integer
05:02:06 <mmorrow> dolio: the gcc-generated asm is around 700 lines (for comparison)
05:02:57 <agruman> im having some problems with the my environment when trying to implement a interpreter for a small subset of haskell, the problem is env := [("Closure "f" (lambda "x" (App "f" "x")),[]),...] but then when i substitute f for its implementation the env is [] since thats the env in the closure, is there some smart way to maintain the "global" env?
05:02:59 <dolio> Well, ghc isn't too much worse, then, although if gcc is really doing binary search, that's pretty cool.
05:03:45 <dolio> Integer will have all kinds of GMP stuff, so that case expression is potentially non-trivial there.
05:03:58 <mmorrow> dolio: yeah, that's way cool :) (binary search)
05:04:28 <dolio> Although all those numbers fit in the small integer constructor. But I don't know if it back-converts once it's gone big, so maybe it has to check both.
05:04:50 <mmorrow> dolio: it's interesting to see how the blocks got reordered, it looks like they could be better though (but that's not to say that doing so would be trivial, since this is a special case, etc..)
05:05:40 <mmorrow> dolio: yeah, it looks like there's all kinds of gc info, etc in the Integer case
05:06:16 <mmorrow> each literal gets its own infotable/static-closure, complete with all that comes with that
05:07:51 <mmorrow> dolio: i *think* gcc is doing binary search, or something along these lines..
05:08:04 <mmorrow> it's hard to follow though just looking at the jmps
05:09:05 <centrinia> mmorrow: I got it down to 1021 lines of assembly by using unboxed types.
05:10:13 <mmorrow> centrinia: hmm, i wonder if using explicit unboxed Ints is much different than just Ints and -O2
05:10:42 <mmorrow> centrinia: it's around 1200 with `Int' http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1801#a1808
05:12:04 <mmorrow> Botje: ohh, that's a good question (an instance for every type)
05:12:47 <mmorrow> Botje: no, it was defaulting to Integer
05:16:33 <mije> thanks Saizan and centrinia, it works now, in fact i just had to create a symlink for libgmp.so.3 i had in /usr/lib to libgmp.so
05:17:23 <Fredrik_> @pl f x y = f y x
05:17:23 <lambdabot> f = fix flip
05:17:38 <Fredrik_> @pl \x y = y x
05:17:38 <lambdabot> (line 1, column 6):
05:17:38 <lambdabot> unexpected "="
05:17:38 <lambdabot> expecting pattern or "->"
05:17:42 <Fredrik_> @pl \x y -> y x
05:17:43 <lambdabot> flip id
05:19:40 <Fredrik_> @src map
05:19:40 <lambdabot> map _ []     = []
05:19:40 <lambdabot> map f (x:xs) = f x : map f xs
05:19:54 <Fredrik_> @src (++)
05:19:54 <lambdabot> []     ++ ys = ys
05:19:54 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
05:19:54 <lambdabot> -- OR
05:19:54 <lambdabot> xs ++ ys = foldr (:) ys xs
05:20:46 <Fredrik_> @src null
05:20:47 <lambdabot> null []     = True
05:20:47 <lambdabot> null (_:_)  = False
05:21:02 <Fredrik_> @src length
05:21:03 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
05:21:48 <Fredrik_> @src reverse
05:21:49 <lambdabot> reverse = foldl (flip (:)) []
05:23:11 <Fredrik_> @src and
05:23:11 <lambdabot> and   =  foldr (&&) True
05:23:46 <Fredrik_> @src sum
05:23:47 <lambdabot> sum = foldl (+) 0
05:23:53 <centrinia> @let mylength = foldr (const (+1)) 0
05:23:56 <lambdabot>  Defined.
05:24:10 <centrinia> > mylength [1..10]
05:24:12 <lambdabot>   10
05:24:16 <centrinia> > mylength []
05:24:17 <lambdabot>   0
05:24:19 <centrinia>  :)
05:24:29 <Fredrik_> Why is "and" defined in terms of foldr and "sum" in terms of foldl?
05:25:52 <Fredrik_> @src take
05:25:52 <lambdabot> take n _      | n <= 0 =  []
05:25:52 <lambdabot> take _ []              =  []
05:25:52 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
05:26:29 <igel> Fredrik_: because 'and' doesn't necessarily evaluate the entire list, but sum does
05:26:33 <adimit> Fredrik_: because with lazy evaluation, "and" can see if a list of items will evaluate to true or false with a minimal amount of items.
05:26:43 <igel> > and (False:undefined)
05:26:44 <lambdabot>   False
05:26:52 <igel> sum (1:undefined)
05:26:55 <igel> >sum (1:undefined)
05:26:59 <igel> > sum (1:undefined)
05:27:01 <lambdabot>   * Exception: Prelude.undefined
05:27:11 <Fredrik_> @src foldl
05:27:12 <lambdabot> foldl f z []     = z
05:27:12 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
05:27:13 <Fredrik_> @src foldr
05:27:13 <lambdabot> foldr f z []     = z
05:27:13 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
05:27:32 <Fredrik_> I see, foldr can stop
05:27:34 <Fredrik_> early
05:27:53 <igel> foldr is usually the right choice, if you don't need to evaluate everything
05:28:06 <igel> @src concat
05:28:07 <lambdabot> concat = foldr (++) []
05:28:08 <Fredrik_> But foldl has the benefit of being tail recursive, right?
05:28:53 <igel> i don't know if foldr *never* does
05:29:15 <Fredrik_> @src zip
05:29:15 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
05:29:15 <lambdabot> zip _      _      = []
05:29:38 <Fredrik_> Wouldn't this make more sense:
05:29:40 <chessguy> > foldr f w [x,y,z]
05:29:41 <Fredrik_> zip = zipWith (,)
05:29:41 <lambdabot>   f x (f y (f z w))
05:29:54 <chessguy> > foldl' f w [x,y,z]
05:29:55 <lambdabot>   f (f (f w x) y) z
05:30:23 <Fredrik_> @src zipWith
05:30:24 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
05:30:24 <lambdabot> zipWith _ _      _      = []
05:30:48 <igel> oh that's strange... i thought zip = zipWith (,)
05:30:58 <chessguy> igel:  it is
05:31:06 <igel> @src zip
05:31:06 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
05:31:06 <lambdabot> zip _      _      = []
05:31:24 <chessguy> conceptually, even if @src doesn't show it that way
05:31:41 <igel> of course that's equivalent
05:32:24 <igel> (,) is probably inlined anyway
05:33:07 <igel> @check (\x y -> zip x y == zipWith (,) x y :: [Int] -> [Int] -> Bool)
05:33:08 <lambdabot>   Couldn't match expected type `[Int] -> [Int] -> Bool'
05:33:23 <igel> @check ((\x y -> zip x y == zipWith (,) x y) :: [Int] -> [Int] -> Bool)
05:33:24 <lambdabot>   "OK, passed 500 tests."
05:34:44 <centrinia> Is it possible to implement foldr with map and inits?
05:36:10 <chessguy> i've never understood why people would want to do things like that
05:37:06 <centrinia> Do things like what?
05:37:50 <chessguy> implement folds and maps in terms of each other
05:38:43 <centrinia> Minimalism is rewarding. :)
05:40:21 <Fredrik_> If I have a function that uses some constant list, for example f x = x `elem` [2,3,5,7] is the list rebuilt every time I enter the function?
05:40:38 <Fredrik_> Or are all constants always there?
05:41:01 <beelsebob> Fredrik_: yes
05:41:12 <Fredrik_> yes what?
05:41:27 <beelsebob> it's entirely implementation dependant
05:41:44 <beelsebob> in ghc, I think they are rebuilt each time, you can chose to optimise it by making them CAFs
05:41:52 <Fredrik_> What is a CAF?
05:42:24 <beelsebob> a constant appricative form – a top level constant
05:42:42 <Fredrik_> help = [2,3,5,7]
05:42:45 <Fredrik_> something like that?
05:42:48 <beelsebob> yep
05:42:51 <Fredrik_> thank you
05:44:05 <Fredrik_> Here is what I do, any comments? http://haskell.pastebin.com/d7373a6b0
05:46:41 <Botje> best to inspect the core to be sure
05:46:57 <Botje> i believe ghc lifts constants to toplevel if possible
05:48:37 <wli> Is the derived ordering on pairs the dictionary ordering?
05:48:59 <BONUS> yah
05:49:07 <Botje> it first compares the fsts, then the snds
05:49:32 <wli> Is there a quick lib function to invert a map?
05:49:56 <chessguy> you mean a Data.Map.map?
05:50:07 <wli> Data.Map.Map yes
05:50:25 <chessguy> @hoogle Map a b -> Map b a
05:50:25 <lambdabot> Data.Map mapWithKey :: (k -> a -> b) -> Map k a -> Map k b
05:50:25 <lambdabot> Data.Map map :: (a -> b) -> Map k a -> Map k b
05:50:25 <lambdabot> Data.Map mapKeysMonotonic :: (k1 -> k2) -> Map k1 a -> Map k2 a
05:50:39 <wli> Like Map.fromList . map (uncurry (flip (,))) . Map.toList
05:52:44 <Fredrik_> Anybody care to critique my first Haskell game? :) http://haskell.pastebin.com/m7ab9f9b9
05:55:17 <centrinia> Fredrik_: See what happens if you play an occupied cell.
05:55:34 <chessguy> @type untilM
05:55:35 <lambdabot> Not in scope: `untilM'
05:55:44 <Fredrik_> the move is rejected
05:55:52 <Fredrik_> you must chose antoehr move
05:56:50 <chessguy> Fredrik_:  you should get into the practice of writing type signatures
05:57:44 <centrinia> Is there an hsproto that does that for you? :)
05:57:59 <chessguy> hsproto?
05:58:17 <centrinia> It adds the type signatures for you. :)
05:58:31 <centrinia> It would be similar to cproto.
05:58:44 <chessguy> cproto? :)
05:58:53 <beelsebob> Fredrik_: `and` can be written <^(&&)^> with infixApplicative (and no need for the where clause)
05:59:05 <centrinia> cproto generates C prototypes for you. :)
06:00:08 <Fredrik_> what is the complete line? i cant get it to work
06:00:35 <beelsebob> you need to use the InfixApplicative package
06:00:53 <chessguy> i think it's fine as it is
06:01:51 <|jedai|> centrinia: There is a haskell-mode shortcut to add a type signature to a top-level declaration
06:02:17 <centrinia> Okay.
06:04:46 <Fredrik_> Is a tail recursive function good practice for a game loop? I had no other idea of doing it.
06:05:04 <|jedai|> centrinia: But often it's better to write the signature yourself, it gives documentation, declare your intention even before you code the function and prevent type errors from getting out of hand
06:05:15 <Botje> Fredrik_: sure
06:05:41 <|jedai|> Fredrik_: As long as it doesn't build a big thunk by lack of strictness, it's fine
06:07:34 <centrinia> Fredrik_: How does one quit?
06:07:41 <Fredrik_> by winning ;)
06:07:51 <Fredrik_> or filling the board
06:08:04 <Fredrik_> or closing the terminal window
06:14:42 <agruman> im am writing a interpreter for a minimalistic subset of haskell, but the code doesnt work when a function calls itself (since the environment no longer contains the definition for that function). Any hints on how to fix it would be appreciated, http://interpret.pastebin.com/d459741dd
06:15:15 <pejo> agruman, why doesn't the environment contain that function?
06:16:36 <agruman> pejo, cuz i cant seem to get the env to maintain the definition
06:19:02 <agruman> pejo, ex f = \x -> f x, then the first iteration works, but the second complains on undefined, this since the "apply" uses the environment from the "subst"
06:21:55 <pejo> agruman, I didn't understand "since the apply uses the environment from the subst"-part.
06:22:02 <agruman> when first constructing the env i get all definitions from the source file, but since the definition is a closure i would need this definition in there as well, so it ends up in a infinite loop ... "f = def + env" where env is "f = def + env" aso ..
06:22:29 <vixey> You can represent recursive programs as infinite objects
06:22:47 <vixey> f = \x -> (\x' -> (\x'' -> ... x'') x') x
06:23:32 <vixey> people even have studied 'coinductive lambda calculus'
06:23:36 <agruman> vixey, i dont think that the problem is in the representation of the program (ast), but in my implementation of the interpreter
06:23:50 <jedai> agruman: infinite data is a speciality of Haskell, that's not really a problem
06:24:07 <vixey> agruman, these two things,  representation and implementation  are actually the same thing
06:24:10 <agruman> it "should'nt" be this hard ... im just doing something wrong
06:24:25 <agruman> jedai, yeah i know and i use that, thats not the problem though
06:24:50 <agruman> vixey, well, one dont match the other :I
06:26:46 <vixey> agruman, why is your code in IO?
06:27:26 <agruman> vixey, i have had some printouts for debugging purposes, though remove them before posting
06:28:03 <boegel> shapr: y0!
06:28:12 <shapr> y0 boegel!
06:28:14 <boegel> shapr: how about that presentation of ours?
06:28:34 <shapr> boegel: I'm working on it now, looking for STM references while I sit on the train.
06:28:38 <boegel> shapr: hmm, we should move this to #haskell-blah probably
06:28:55 <boegel> shapr: STM or SMT?
06:28:57 <shapr> I think STM citations is totally on-topic.
06:29:28 <shapr> There are the three papers that are reference on HaskellWiki: http://www.haskell.org/haskellwiki/Research_papers/Parallelism_and_concurrency#Lock_free_data_structures_and_transactional_memory
06:29:37 <centrinia> Software Transactional Memory can be used with Simultaneous Multi-Threading hardware. :)
06:29:45 <agruman> vixey, as an example this is the staring env on "f = \x -> f x" [(id: f, val: ValClosure (ExpLambda (Ident "x") (ExpApp (ExpId (Ident "f")) (ExpId (Ident "x"))),[])]
06:30:05 <shapr> And there's the HaskellWiki page: http://www.haskell.org/haskellwiki/Software_transactional_memory
06:30:06 <shapr> Just curious if I'm missing anything.
06:30:23 <gwern> http://d.hatena.ne.jp/smly/20090305/1236267016 <-- ok, that's a nice gitit plugin
06:30:40 <agruman> vixey, and on the first invocation of apply, it will be substituted to "[]" (the last part), and i dont know how to solve that
06:31:00 <centrinia> shapr: What about the Transactional Memory/Garbage Collection Analogy?
06:31:19 <shapr> centrinia: What's that?
06:31:28 <vixey> agruman, my opinion is that one should not debug
06:31:36 <centrinia> It is a Dan Grossman paper.
06:31:42 * boegel hasn't heard about the TM/GC analogy either
06:31:44 <jedai> agruman: You know Debug.Trace ? For your debugging purpose ? On the other hand, putting your interpreter in a monadic framework from the beginning is probably a good idea, it's quite a good fit for an interpreter
06:31:44 <vixey> agruman, a lot of people don't seem to share it though
06:31:56 <centrinia> Here: http://www.cs.washington.edu/homes/djg/papers/analogy_oopsla07.pdf
06:32:04 <gwern> boegel: I like the filesystem/gc analogy of Nix better, personally
06:33:09 <agruman> vixey, well, i suppose i wouldnt have done that if i wouldnt have been at this for 2 days without success ... :(
06:33:25 <agruman> jedai, no didnt know about that, gonna have to check it out
06:33:25 <boegel> gwern: haven't heard about it either
06:33:57 <gwern> boegel: oh, it's great stuff. go read the nix papers
06:34:14 * boegel feels bloody tired after working until 1am and then working in the "garden" all morning
06:34:28 <boegel> gwern: "nix" is the author?
06:34:35 <boegel> gwern: I wish I had time to read more papers...
06:34:48 <boegel> gwern: too busy trying to come up with a paper of my own ;-)
06:35:21 <vixey> agruman -- so anyway one consequence of that is that I think you should start you interpreter code from scratch
06:35:35 <gwern> boegel: http://nixos.org/docs/papers.html you probably want '# Eelco Dolstra  and Eelco Visser  and Merijn de Jonge. Imposing a Memory Management Discipline on Software Deployment. In 26th International Conference on Software Engineering (ICSE 2004), pages 583–592, Edinburgh, Scotland. IEEE Computer Society, May 2004. [pdf] [acm] [abstract]
06:35:50 <vixey> agruman but there is a very simple way to rewite such that it will be shorter and correct
06:37:04 <agruman> vixey, i dont think it would end up much different though, since whatever i try i seem to end up with the same solution :/
06:37:18 <vixey> it would be very different
06:38:06 <agruman> vixey, not if i were to rewrite it, thats what i meant, but if you got some pointers to give me perhaps it would
06:38:15 <vixey> yes
06:39:13 <vixey> agruman, thinking about  data S = Lambda (Scope S) | Apply S S | Var Ref | Def String  for concreteness
06:39:33 <vixey> agruman, so bound variables are  Var i  for some i,  top level function definitions are  Def "f"
06:40:20 <vixey> agruman: \x -> f x would be  Lambda (Scope (Apply (Def "f") (Var 0)))
06:40:58 <boegel> gwern: I'll see if I can find the time... ;-)
06:41:02 <agruman> vixey, thats using bruijn?
06:41:08 <vixey> agruman, (I think this is roughly what you already have at the moment but maybe you don't use Scope which is nice for type safety, or maybe you don't have de bruijn indices yet..)
06:41:14 <vixey> agruman, yes
06:41:50 <agruman> vixey, i dont have bruijn no.
06:42:25 <vixey> agruman, so anyway to write a lazy eval for this,
06:42:41 <vixey> agruman, (which can be changed into strict evaluation by an obvious adaptation later on)
06:43:43 <vixey> agruman, we can build some kind of semantic domain in which only normal forms can live
06:43:53 <vixey> agruman, (call that D)
06:44:20 <agruman> ok
06:44:23 <vixey> agruman, if you could write a function  S -> D  that would give a normalized version and a function D -> S would give you back the syntax of the normal form.. so it would be an evaluator
06:44:29 <vixey> so we should now design D
06:45:05 <vixey> this simple language at the moment doesn't have numbers or anything, so the only values are lambda terms or neutral (stuck applications)
06:45:24 <vixey> for example \x -> x x is a value
06:45:51 <vixey> so data D = DLambda (D -> D) | DNeutral N ; data N = NApp N D
06:46:13 <vixey> but to quote back from D into S again we need to augment N with | NQuote Ref
06:47:34 <vixey> agruman, going ev :: S -> D is quite trivial given an environment of values:    ev delta (Lambda (Scope s)) = DLambda (\x -> ev (x:delta) s) ; ev delta (Var i) = delta !! i ; ev delta (App m n) = apply (ev delta m) (ev delta n) ; ...
06:47:54 <vixey> agruman, apply (DLambda f) x = f x ; apply (DNeutral n) x = DNeutral (NApp n x)
06:48:07 <vixey> the rest of the cases are probably obvious enough to fill in
06:49:50 <vixey> agruman, going back quote :: Ref -> D -> S should be straight forward too, you need to carry around a number that increases each time you use it so that the NQuote parts can be differentiated and it would be mutually recursive with a nquote function :: Ref -> N -> S
06:51:00 <vixey> agruman, D and N maybe seem a bit magic but they come quite naturally out of domain theory and are easily extended to more complex languages
06:51:51 <agruman> vixey, yes a bit like magic :), i cant say i fully understand it all yet though :/
06:52:27 <vixey> agruman, well tinker a bit with Haskell and it will become clear -- unless  it doesn't but in that case just ask more questions
06:53:02 <agruman> vixey, will do that :), thanks alot for the help
06:55:40 <johnbs> I have a language design question...
06:55:44 <johnbs> Why are operator precedences defined with integer precedence levels?
06:56:08 <Baughn> Maybe it would be better if they weren't..
06:56:29 <byorgey> johnbs: well, it's simple to implement, but other than that, no particularly good reason that I know of
06:56:35 <EvilTerran> because no-one can agree on anything better?
06:56:48 <Baughn> There's no fundamental reason, I don't think. In theory it doesn't matter, but in practice decimal numbers would've been nicer I guess..
06:57:39 <johnbs> Couldn't they be defined by a partial ordering, so when you define an operator you can say "binds tighter than +", and then if you use two operators in the same expression that can't be compared (because the ordering isn't complete) it can give a warning/error and force you to use brackets to disambiguate?
06:58:24 <Baughn> Now that would've been fun
06:59:15 <johnbs> or maybe that would just lead to too many annoying errors from operators being defined in different modules and not being comparable
06:59:22 <opqdonut> indeed
06:59:32 <opqdonut> there's been some discussion on this
06:59:49 <opqdonut> and many people would prefer a more fine-grained precedence system
06:59:53 <opqdonut> but the current one is simple and works
07:00:05 <johnbs> right
07:00:11 <vixey> just use rational numbers
07:00:17 <johnbs> do you know if there's archived discussion on it somewhere?
07:00:18 <opqdonut> almost every point in h98 where there was a choice between a complicated and a simple solution, the simpler one was chosen
07:00:19 <vixey> prec 4452/6731 +
07:00:33 <opqdonut> err, and even before h98
07:00:42 <johnbs> vixey: heh, nice
07:00:46 <opqdonut> for haskell records are the result of such a decision
07:00:53 <vixey> every point in perl 6 design where there was a choice .. they took -both- :p
07:00:56 <opqdonut> spj talked about this in some interview
07:01:02 <byorgey> vixey, hehe
07:01:05 <opqdonut> hehe
07:02:33 <Azstal> is that also where the dreaded monomorphism restriction comes from?
07:03:50 <Baughn> That's different. The monorphism restriction just makes things easier on the implementors. ^_^
07:04:02 <Baughn> ..as well as preventing a source of bugs from newbies
07:04:31 <opqdonut> indeed
07:06:49 <tibbe_> is "length `fmap` readFile filename >>= print" enough to force a file (I'm trying to prime things for a benchmark)?
07:07:06 <vixey> isn't there a strict readFile ?
07:09:30 <vixey> @hoogle strict
07:09:30 <lambdabot> package strict
07:09:30 <lambdabot> module Control.Monad.RWS.Strict
07:09:30 <lambdabot> module Control.Monad.ST.Strict
07:09:31 <Baughn> tibbe_: Use System.IO.Strict instead
07:09:48 <Baughn> tibbe_: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/strict
07:10:02 <tibbe_> Baughn: thanks
07:10:16 <tibbe> reordering my benchmarks yield different results :/
07:11:10 <Phyx-> hi, i was wondering if anyone can help me with a problem with gtk2hs, i can't seem to get it to not distribute the space evenly on an hBox http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1809#a1809
07:18:40 <Deewiant> Gah! 'cabal haddock' doesn't appear to use the preprocessed sources in dist/build
07:18:59 <dcoutts_> Deewiant: hmm?
07:19:20 <Deewiant> dcoutts_: I need to run cpphs on my sources, GHC's cpp won't do.
07:19:28 <Deewiant> dcoutts_: That involved some hacking using a 'Custom' build-type.
07:19:46 <dcoutts_> Deewiant: do you use .hs extensions or .cpphs?
07:20:01 <Deewiant> dcoutts_: I tried the latter as well and it didn't seem to work.
07:20:15 <Deewiant> I.e. it still used GHC's built-in CPP.
07:20:28 <Deewiant> I can try again if you think it should work :-)
07:20:36 <dcoutts_> oh, it should pre-process first if the files are .cpphs
07:21:44 <dcoutts_> Deewiant: oh, actually .cpphs will also use cpp
07:22:02 <dcoutts_> there's no way to declare that you need cpphs except perhaps by hacks in Setup.hs
07:22:11 <Deewiant> Yep.
07:22:24 <Deewiant> I got that bit to work, but no 'cabal haddock' still tries to run haddock on the original files instead of the ones in dist/build.
07:22:31 <Deewiant> Leading to parse errors.
07:22:37 <Deewiant> s/no/now/
07:22:47 <dcoutts_> Deewiant: that's not the way to hack it
07:22:57 <dcoutts_> you'd use the PPSuffixHandler in the hooks
07:23:04 <Deewiant> That's what I've got.
07:23:06 <dcoutts_> to declare how to handle .cpphs extensions
07:23:11 <Deewiant> hookedPreProcessors
07:23:14 <dcoutts_> right
07:23:20 <Deewiant> with a Compiler called "force-cpphs-usage-hack"
07:23:34 <Deewiant> I'm using it for .hs now but I guess that shouldn't matter, or?
07:23:45 <dcoutts_> no that will not work for .hs
07:23:50 <Deewiant> It works for cabal build
07:23:51 <dcoutts_> because they do not get preprocessed
07:24:01 <Deewiant> Evidently they do
07:24:11 <Deewiant> The preprocessed files are there in dist/build
07:24:15 <dcoutts_> Deewiant: so you set a preprocessor for .hs files?
07:24:21 <Deewiant> pp = ("hs", \bi lbi -> ppCpp' ["--layout"] bi lbi{ compiler = hack })
07:24:24 <Deewiant> That's what I've got
07:24:30 <dcoutts_> ugg
07:24:42 <Deewiant> Had to look at the source to see that ppCpp' uses ppCppHs
07:24:49 <Deewiant> Because the latter isn't exported
07:24:51 <Deewiant> (Why not?)
07:25:18 <Deewiant> Well, I guess because one isn't supposed to be doing this anyway :-P
07:25:23 <dcoutts_> right
07:25:39 <Deewiant> But I need the --layout option of cpphs
07:25:55 <trygvis> have any one check out jaskell? http://jaskell.codehaus.org
07:25:57 <Deewiant> Anyhoo, I've got that and then: main = defaultMainWithHooks simpleUserHooks{ hookedPreProcessors = [pp] }
07:26:16 <Deewiant> And it does work as far as building, but for Haddock.
07:26:28 <Deewiant> *not
07:27:53 <dcoutts_> Deewiant: so it calls initialBuildSteps with the list of suffixes
07:28:08 <dcoutts_> Deewiant: which is the bit that does preprocessing
07:30:12 <Deewiant> dcoutts_: Oh, and I'm not sure if this is a bug or not (given that what I'm doing is somewhat questionable), but when doing 'cabal haddock' without 'cabal build' there's no dist/build/autogen/cabal_macros.h which is explicitly passed as an include to cpphs
07:30:30 <dcoutts_> Deewiant: right, that bug only got fixed recently
07:30:39 <ImInYourMonad> i get a stack overflow when deserializing a Map (Int,Int) Int. however creating it works fine
07:30:41 <Deewiant> Okay, cool
07:30:49 <dcoutts_> Deewiant: are you using 1.6.0.1 or .2 ?
07:31:07 <Deewiant> 0.6.2 using 1.6.0.1, evidently
07:31:20 <ImInYourMonad> it is 100K elems big
07:31:28 * Deewiant upgrades Cabal
07:31:51 <dcoutts_> Deewiant: so, initially I don't see why it should not work. the haddock stuff also calls the initialBuildSteps to do pre-processing as it does for build.
07:32:23 <Deewiant> dcoutts_: I think it's just that it uses the source directory's files instead of the dist/build files.
07:32:32 <Deewiant> At least, that's what it seems like to me.
07:32:36 <dcoutts_> Deewiant: ah yes you're right:
07:33:12 <dcoutts_>   ++ ["-i" ++ l | l <- nub (hsSourceDirs bi)]
07:33:12 <dcoutts_>   ++ ["-i" ++ autogenModulesDir lbi]
07:33:12 <dcoutts_>   ++ ["-i" ++ preprocessDir]
07:33:27 <dcoutts_> Deewiant: should put preprocessDir before the sources dir
07:33:39 <dcoutts_> Deewiant: so it'd work if you were using an extension other than .hs
07:33:40 <Deewiant> Yay for ordering bugs :-P
07:33:46 <Deewiant> It didn't seem to
07:33:50 <dcoutts_> which since you're using a pre-processor does not seem unreasonably
07:34:08 <dcoutts_> Deewiant: well it would not find Foo.hs in the source dirs
07:34:21 <dcoutts_> since it'd be Foo.cpphs or whatever
07:34:36 <Deewiant> Maybe it accepts .cpphs anyway
07:35:04 <dcoutts_> what ghc?
07:35:07 <Deewiant> 6.10.1
07:35:07 <dcoutts_> I don't think so
07:35:13 <Deewiant> Haddock 2.3.0
07:35:20 <Deewiant> And it does not work, I just tried it.
07:36:25 <dcoutts_> well its for a different reason then
07:37:30 <dcoutts_> Deewiant: you can check if ghc recognises .cpphs files. touch Foo.cpphs; ghci Foo
07:37:32 <dcoutts_> it doesn't
07:38:26 <Deewiant> You're right, it's failing for a different reason
07:38:44 <Deewiant> Ehm
07:38:48 <Deewiant> It's running ghc -E -cpp now
07:38:55 <Deewiant> Oh, duh
07:39:03 <Deewiant> I didn't update my setup.hs to account for the .cpphs-ness
07:39:06 <dcoutts_> that's the default cpp implementation
07:39:08 <Deewiant> That'd make a difference now wouldn't it :-)
07:39:15 <dcoutts_> :-)
07:39:41 <Deewiant> There we go, now it fails due to GHC #3079 as expected
07:39:46 <dcoutts_> heh
07:40:07 <Deewiant> And if I work around that it works, yay!
07:40:08 <zachk1> that bug they wont fix?
07:40:18 <Deewiant> That bug I filed 3.5 hours ago
07:40:25 <zachk1> ah
07:40:37 <Deewiant> dcoutts_: I still think the .hs one should work
07:40:55 <dcoutts_> Deewiant: it works completely differently in Cabal HEAD now
07:41:07 <Deewiant> So there's no telling whether it'll work or not? :-)
07:41:32 <dcoutts_> Deewiant: right :-)
07:41:42 <Deewiant> ^_^
07:41:52 <dcoutts_> Deewiant: in theory, using .cpphs and a preprocessor rule should continue to work
07:42:03 <Deewiant> dcoutts_: How about anything more robust for forcing cpphs usage?
07:42:04 <dcoutts_> I'd not count on it if you use .hs, that's asking for trobule
07:42:27 <Deewiant> hack = Compiler (CompilerId (OtherCompiler "force-cpphs-usage-hack") (Version [] [])) []
07:42:32 <Deewiant> Not very pretty IMHO
07:42:33 <Deewiant> :-P
07:42:35 <dcoutts_> Deewiant: the .cpphs route should just work.
07:42:49 <dcoutts_> Deewiant: well that's because you're using the generic cpp function
07:43:02 <Deewiant> Well because there is no ppCpphs function
07:43:04 <dcoutts_> when you actually want cpphs
07:43:07 <Deewiant> Or there is, but it's not exported
07:43:15 <Deewiant> I can't get at cpphs directly
07:43:34 <dcoutts_> Deewiant: what if you wanted to use your own custom pre-processor, you'd not be complaining that it's not exported
07:43:56 <Deewiant> True, but relying on compilerFlavor is a hack
07:44:10 <Deewiant> What's another way of doing this?
07:44:17 <ImInYourMonad> i get a stack overflow when deserializing a Map (Int,Int) Int. however creating it works fine. i is 100K elems big. how do I get around that?
07:44:27 <dcoutts_> Deewiant: writing the PreProcessor for cpphs
07:44:29 <ImInYourMonad> and is the stack overflow due to laziness?
07:44:45 <Deewiant> dcoutts_: Copying the one in Distribution.Simple.PreProcess to my Setup.hs?
07:45:00 <dcoutts_> Deewiant: that'd work
07:45:27 <Deewiant> Any particular reason you can't export it, given that it's there anyway?
07:45:41 <dcoutts_> Deewiant: it doesn't help you much anyway
07:45:51 <dcoutts_> since you would not be able to use it now
07:46:25 <zachk1> i just looked up the haskell case expressions. wow i have not even come close to using its full power :-D
07:46:38 <Deewiant> dcoutts_: Not now, but in the future, maybe with 6.10.2
07:46:46 <dcoutts_> Deewiant: remember to put build-tools: cpphs
07:46:53 <dcoutts_> Deewiant: no, no api changes in stable releases
07:46:57 <Deewiant> dcoutts_: I even put >= 0.5
07:47:01 <Deewiant> Ah, true
07:47:22 <Deewiant> dcoutts_: Well, in 6.12 then ;-)
07:47:58 <dcoutts_> .cpphs should probably just default to using cpphs
07:48:39 <dcoutts_> Deewiant: so what in particular goes wrong with ordinary cpp?
07:49:51 <Deewiant> dcoutts_: I've got an exports.h which lists the stuff exported from a module (reused in several modules), without --layout they're all on one line and comments break
07:50:12 <Deewiant> I figured cpphs would be the simple solution and I wanted to get that to work :-P
07:50:58 <Deewiant> Now I'm wondering if {- * Heading -} works
07:51:09 <Deewiant> Which will end up being easier if it does ;-)
07:51:16 <dcoutts_> Deewiant: if you send us a cut down test case that uses Setup.hs to specify a .cpphs handler then we can make sure it keeps working in future
07:51:40 <Deewiant> dcoutts_: An entire project with .cabal and all?
07:53:46 <McManiaC> is there an easy way to setup vim for autocompletion for (at least) the functions in the prelude library?
07:56:52 <Deewiant> dcoutts_: Copying this ppCpphs into my Setup.hs involves pulling in nasty stuff marked with TODO and FIXME :-P
07:59:25 --- mode: irc.freenode.net set +o ChanServ
07:59:48 <shapr> So, anyone else in NYC today?
08:01:33 <shapr> tromp_: Are you in NYC?
08:03:47 <Deewiant> dcoutts_: Is it alright if I just file a ticket that says .cpphs should prefer cpphs over the compiler's cpp?
08:04:01 <dcoutts_> Deewiant: yep
08:04:20 <Deewiant> Seems the most sensible thing to do IMHO — I'll file that then
08:04:39 <dcoutts_> Deewiant: I'd be interested to know if your Setup.hs works with Cabal HEAD though
08:04:54 <dcoutts_> Deewiant: since we just replaced all the haddock code
08:05:19 <Deewiant> dcoutts_: Currently I doubt it: I had to pull in over 50 lines of definitions I copy-pasted from the 1.6.0.1 source
08:05:40 <dcoutts_> you should not need that much
08:05:43 <Deewiant> In order to get ppCpphs to compile, since it used all kinds of internal stuff
08:05:49 <dcoutts_> certainly no need for the compiler hack
08:05:58 <Deewiant> The compiler hack is only 3 lines
08:06:00 <tibbe_> hmm, if "(a -> b -> a) -> a -> [b] -> b" is a fold and "(a -> b -> m a) -> a -> [b] -> m a" is foldM what is then "(a -> b -> a) -> a -> [b] -> m a"?
08:06:01 <Deewiant> This is now without the hack
08:06:40 <vixey> tibbe_, it's got to be just return'ing the result of a normal foldl
08:06:43 <Deewiant> tibbe_: it's return . fold
08:07:08 <vixey> the first type you wrote is probably supposed to be: (a -> b -> a) -> a -> [b] -> a  instead?
08:07:25 <tibbe_> vixey: yes
08:07:49 <johnbs> :t (return . foldl)
08:07:50 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> b -> a) -> m (a -> [b] -> a)
08:07:51 <Deewiant> dcoutts_: For instance ppCpp' depends on getCppOptions which depends on hcDefines which depends on versionInt
08:08:14 <Deewiant> Or not 'for instance', that's the single reason I need all this stuff
08:08:18 <tibbe_> hmm, my example wasn't that great. What would you call "(a -> b -> a) -> a -> FilePath -> m a" where the function performs some I/O (i.e. reading from a file) to provide the b:s?
08:08:29 <dcoutts_> Deewiant: you don't need that stuff
08:09:03 <Deewiant> dcoutts_: It uses it to define stuff like __GLASGOW_HASKELL__ which I don't use currently but I might need at some point
08:09:13 <dcoutts_> Deewiant: right
08:09:14 <tibbe_> i.e. you have a function that needs to perform I/O to generate b:s but the side effects aren't not visible to the function being folded over the file
08:10:10 <Deewiant> dcoutts_: ... and they're not defined unless I use all this stuff, right? So while I don't need it now I might as well have it so I don't have to bash my head against the wall in the future
08:10:23 <dcoutts_> Deewiant: ok
08:10:47 <dcoutts_> Deewiant: as you say though, it also makes it more fragile to internal Cabal api changes
08:11:06 <Deewiant> dcoutts_: There could be something simple which gives those -Doperating-system -Darchitecture -Dcompiler-version flags
08:11:13 <Deewiant> exported, that is
08:11:18 <dcoutts_> Deewiant: we don't change the UserHooks and types defined in it but we do change other stuff
08:11:25 <tibbe_> perhaps this is a question for haskell-in-depth. something between Foldable and Monad
08:11:37 <dcoutts_> defined/used
08:11:47 <johnbs> tibbe_: you mean something like (readFile name >>= foldl f a) ?
08:12:02 <tibbe_> johnbs: yes, although not lazy
08:12:31 <Deewiant> dcoutts_: Which is why it currently seems most attractive to me to avoid this cpphs madness altogether :-)
08:12:36 <tibbe_> johnbs: hmm, perhaps it's more like a fold than a foldM
08:12:52 <tibbe_> johnbs: since the folded function can't have side effects
08:13:02 <tibbe_> johnbs: (in my case it's a monoid like with foldable)
08:13:11 <dcoutts_> Deewiant: personally I'd just try to make it work using ordinary cpp
08:13:19 <Deewiant> dcoutts_: I'll file the ticket about .cpphs and leave it at that; if you want to see the Setup.hs I can hpaste it, but really it's the two lines I pasted earlier + ppCpphs
08:13:25 <dcoutts_> Deewiant: I don't quite follow what you said about the original problem and lines etc
08:13:29 <Deewiant> dcoutts_: Yep, exactly
08:13:40 <Deewiant> I think I figured out a way whereby I can make it work
08:13:43 <johnbs> tibbe_: i would've thought if the fold doesn't actually have any side-effects related to the I/O then it's just a fold -- i'm not sure why it needs a different name
08:14:02 <tibbe_> johnbs: me neither, I'm just asking :)
08:14:15 <tibbe_> johnbs: I guess I'm asking: what makes a fold a fold
08:14:35 <tibbe_> johnbs: but also is there something more general than Foldable that allows the "collection" being folded over to have side effects
08:14:42 <johnbs> getting pretty close to philosophy there
08:16:08 <johnbs> 'fraid i'm not really the best person to talk about it, as i'm still a haskell neophyte
08:16:14 <tibbe_> johnbs: me too
08:16:26 <tibbe_> I'll ask haskell-in-depth
08:16:27 <Deewiant> tibbe_: the collection doesn't have side effects in your case
08:17:05 <ddarius> @src Traversable
08:17:06 <lambdabot> class (Functor t, Foldable t) => Traversable t where
08:17:06 <lambdabot>     traverse    :: Applicative f => (a -> f b) -> t a -> f (t b)
08:17:06 <lambdabot>     sequenceA   :: Applicative f => t (f a) -> f (t a)
08:17:06 <lambdabot>     mapM        :: Monad m => (a -> m b) -> t a -> m (t b)
08:17:06 <lambdabot>     sequence    :: Monad m => t (m a) -> m (t a)
08:17:15 <Deewiant> or did you mean  weird :: (a -> b -> a) -> a -> [m b] -> a
08:17:18 <jeltsch> Hello, is there any Gtk2Hs expert online?
08:17:38 <tibbe_> Deewiant: well, it's a file being read
08:17:56 <tibbe_> Deewiant: or we might be fetching the elements over the network for all we know
08:18:02 <jeltsch> I’d like to know how one can be notified about changes in an Entry.
08:18:31 <tibbe_> brb
08:18:34 <Deewiant> tibbe_: So if you do it lazily you just do  ioFunction >>= return (normalFold f z)
08:18:57 <tibbe_> Deewiant: right, but I don't. I might be talking to 5 servers in the backfground and taking lokcs
08:19:01 <tibbe_> brb
08:19:52 <Deewiant> tibbe_: AFAICT, using the base library the way you would do this is with lazy IO
08:20:01 <Deewiant> I'm not sure why it wouldn't fit what you're describing
08:22:32 <amaron_> jeltsch: I'm not sure, but I think onEditableChanged
08:22:40 <amaron_> jeltsch: first cast entry to editable
08:22:55 <jeltsch> amaron_: Thanks.
08:23:12 <jeltsch> amaron: I had forgotten to look in superclasses/interfaces.
08:23:36 <amaron> jeltsch: basic functionality is usualy there
08:24:14 <jeltsch> amaron: Conversion to Editable shouldn’t be needed because onEditableChanged doesn’t only work with Editable but with every type ec that is an instance of EditableClass.
08:25:12 <amaron> jeltsch: even better :)
08:39:23 <jeltsch> For every kind of event, Gtk2Hs has an on and an after function. Do you usually use the on or the after function for registering event handlers?
08:39:36 <dcoutts_> jeltsch: on
08:39:55 <dcoutts_> it only makes a difference when there is a default action
08:40:13 <jeltsch> dcoutts_: When do you use after?
08:40:42 <dcoutts_> jeltsch: I never do, but if you need your action to run after the default action
08:41:04 <jeltsch> dcoutts_: Can you imagine any examples where this might be necessary?
08:41:09 <dcoutts_> jeltsch: this mostly applies for signals that are really hooks of widget's standard behaviour
08:41:48 <dcoutts_> jeltsch: eg you can suppress some response by setting an on handler and stopping the signal propagating
08:42:03 <dcoutts_> eg you could prevent a button from being animated when it's clicked
08:42:26 <dcoutts_> since that's done through the handler for the mouse click signal
08:42:55 <jeltsch> dcoutts_: Okay, but i hook into the on handler for mouse clicks. When do I need the after handler?
08:43:10 * SamB thought for a few seconds that dcoutts was talking about javascript ;-P
08:43:21 <dcoutts_> jeltsch: only if you need your action to happen after the default
08:43:29 <dcoutts_> if the sequencing is important
08:43:37 <jeltsch> dcoutts: Aha.
08:43:46 <jeltsch> dcoutts_: I already thought in this line.
08:43:48 <SamB> does GTK have the bubble-down/bubble-up thing too ?
08:44:10 <jeltsch> dcoutts_: I want the following: I
08:44:21 <dcoutts_> SamB: I've never used javascript, so I cannot compare from experience
08:44:34 * SamB wonders how often people use jQuery to write mozilla add-ons
08:44:43 <SamB> dcoutts: I've only played with it
08:45:00 <jeltsch> dcoutts_: If a user tries to change the contents of an Entry, my software should catch this attempt, do something and change the Entry afterwards.
08:45:13 <jeltsch> dcoutts_: So is it correct to do it the following way:
08:45:43 <dcoutts_> jeltsch: you can intercept it and not let it change in the first place
08:46:00 <dcoutts_> I'm assuming there's some reason you don't want to simply disable the entry
08:46:08 <jeltsch> dcoutts_: The on handler of the change signal suppresses the change signal then does something then programmatically changes the Entry. The after handler removes the signal blocking. Correct?
08:46:27 <jeltsch> dcoutts_: I want to do model-view with Entries.
08:46:36 <ImInYourMonad> i get a stack overflow when deserializing a Map (Int,Int) Int. however creating it works fine. i is 100K elems big. how do I get around that?
08:46:43 <ImInYourMonad> and is the stack overflow due to laziness?
08:47:01 <dcoutts_> jeltsch: most handlers of that sort return a bool to say if the signal should propagate to the remaining handlers or be stopped
08:47:10 <jeltsch> dcoutts_: The entry shall not be changed directly by GTK+. When a change is requested by the user (e.g., by entering a character), I want to update the model. Changing the model shall update the entry.
08:47:16 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2185#a2185
08:47:28 <jeltsch> dcoutts_: How would I do this?
08:48:27 <ImInYourMonad> can I tell ghci to garbagecollect?
08:48:57 <adimit> erhm. Stupid newbie question: when I try to import Control.Monad.State, it fails: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1810#a1810
08:49:21 <adimit> it seems it's declared in two packages and ghc is confused. What can I do?
08:52:02 <dcoutts_> jeltsch: see the gtk2hs docs about onInsert/DeleteText
08:54:03 <adimit> (apart from the obvious unregistering of monads-fd, since I'd like to keep that around for yi)
08:55:27 <gwern> > 2 / 14
08:55:29 <lambdabot>   0.14285714285714285
08:55:43 <gwern> > 14 * (1/5)
08:55:44 <lambdabot>   2.8000000000000003
08:56:45 <gwern> adimit: if you figure out, I'd like to know - same issue keeps me from using ghci when messing around with Yi.IReader
08:57:07 <ddarius> Can't you just hide one of the packages?
08:57:49 <ImInYourMonad> can I tell ghci to garbagecollect?
08:58:01 <gwern> hiding mtl would probably break a lot of stuff, and hiding monads-fd breaks yi iirc
08:58:06 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2185#a2185
08:58:14 <ImInYourMonad> ^^ why is that stackoverflowing?
08:58:17 <gwern> ImInYourMonad: think there are ghc specific libs for triggering gc. dunno if they'd work in ghci tho
08:58:24 <ddarius> gwern: Well you shouldn't need both at the same time, if you do then you are screwed.
08:59:03 <gwern> ImInYourMonad: foldr? duno
08:59:32 <gwern> ddarius: I blame the author of monads-fd for reusing a module name
08:59:42 <adimit> ddarius: one does indeed not need both at the same time, *but* having to hide/unhide monads-fd (the less dangerous option of the two) all the time (I compile yi fairly often) is quite annoying.
09:00:06 <adimit> gwern: I really think that monads-fd is sort-of broken for shadowing quite a popular package name.
09:00:49 <gwern> adimit: indeed. have you complained to the maintainer yet?
09:00:58 <ImInYourMonad> gwern: sure but it is when I unpack it
09:01:06 <ImInYourMonad> sorry, decode it.
09:01:09 <ddarius> adimit: So make a script that does it for you or a GHCi command.
09:01:14 <adimit> gwern: no, I just hit this problem 5 minutes ago.
09:01:22 <ImInYourMonad> the decoding shouldnt know anything about foldr or foldl'
09:01:35 * gwern thinks gruesome hacks around a problem aren't really Haskelly
09:01:41 <adimit> isn't Jeff responsible for monads-fd?
09:01:58 <EvilTerran> ImInYourMonad, incidentally, foldr (++) [] = concat
09:02:01 <ddarius> Isn't monads-fd supposed to be a "replacement" for the normal mtl library?
09:02:05 <adimit> I'll have a look and file a complaint to yi-devel or some other place. Thanks anyway, I didn't think of hiding monads-fd.
09:02:54 <EvilTerran> ImInYourMonad, not that you'd really need it there; or the map, for that matter
09:03:08 <adimit> ddarius: yes, it seems so.
09:03:47 <EvilTerran> ImInYourMonad, seeing as "M.fromList $ ([1..100000] `zip` movies) `zip` grades" would be the same (i think)
09:03:58 <noufnouf> Hi. Does someone know of a way to "serialize" closures in ghc, i.e. save a function (potentially partially evaluated) on the disk and then read it with the same program ?
09:05:13 <vixey> noufnouf, I don't .. but I am curious what your application of that is
09:05:20 <gwern> noufnouf: there is no way. ghc/haskell does not support that functionality like clean does
09:05:25 <EvilTerran> noufnouf, while it's a nice idea, i don't think it's possible
09:05:48 <noufnouf> vixey : send continuations over a network, for instance ...
09:06:22 <vixey> noufnouf, what would someone over a network do with your continuation?
09:06:50 <gwern> vixey: run it locally. this allows for failover or parallelism. precisely why the mobile haskell folks put so much effort into it
09:06:51 <noufnouf> ok thanks, in fact ocaml also has it, it saves program addresses
09:08:44 <ozy`> you can send any thunk to a different thread to be evaluated.... going to a whole separate node on the network seems like a disaster waiting to happen though
09:08:57 <ozy`> or at least it sounds like it would be a nightmare to implement
09:09:16 <mcnster> ffi q.  is it possible to construct a value having type Ptr Foo where its address is arbitrarily set from a value of type Word?
09:09:49 <gwern> ozy`: the mobile haskell folks had to fork ghc to do it, and clean put a fair bit of effort into serializing program graphs to disk
09:11:18 <mcnster> dcoutts, are you awake?
09:11:24 <ozy`> forking GHC..... yep, that sounds like a nightmare to me :p
09:11:33 <dcoutts_> mcnster: aye
09:11:51 <mcnster> can u answer my q?
09:12:01 <dcoutts_> mcnster: yes, you can convert from word to pointer
09:13:09 <dcoutts_> mcnster: see the functions in Foreign.Ptr
09:13:28 <mcnster> how?  maybe i'm tired, but i don't grok how to go from Word -> Ptr b (it doesn't have to be Word, but it seemed a logical choice)
09:13:45 <dcoutts_> mcnster: plusPtr nullPtr n
09:14:22 <mcnster> i AM tired.  thank you very much :)
09:14:25 <dcoutts_> mcnster: it's highly dubious however
09:14:37 <dcoutts_> it relies on int, word and ptr being the same size
09:14:49 <ImInYourMonad> EvilTerran: the weird thing is the stack overflow happens when I decodeFile, ie deserialize it. why is that? ir works for smaller inputs but i need ti serialize 100MB or so.
09:14:53 <dcoutts_> and nullPtr being a 0 pointer
09:15:05 <johnbs> mcnster: or (wordPtrToPtr . fromIntegral)
09:15:36 <EvilTerran> ImInYourMonad, i have no idea, i was just suggesting style points
09:15:55 <mcnster> johnbs, i didn't notice that!  cool :)
09:15:57 <EvilTerran> ImInYourMonad, but, if you can't get this to work, maybe looking at using an actual database might be in order?
09:16:22 <ImInYourMonad> no databases doesnt work, way to slow
09:16:26 <ImInYourMonad> this is for netflix btw
09:16:38 <johnbs> you just have to be careful because Word and WordPtr are not the same type, and I guess might not be the same size
09:16:44 <dcoutts_> johnbs: good point (I was looking at old docs)
09:17:01 <dcoutts_> johnbs: right same problem as before
09:17:20 <johnbs> you don't rely on nullPtr being 0 though (although that's probably a safe assumption in the first place)
09:17:22 <Fredrik_> I'm having trouble creating a diff array. This doesnt work:
09:17:22 <Fredrik_> let a = newDiffArray (1,3) [(1,0),(2,0),(3,0)]
09:17:31 <Fredrik_> How exactly do I create a diff array?
09:18:38 <Baughn> Fredrik_: To begin with, try not to. The current DiffArray implementation is awful; you won't get a speedup so much as an upping of speed bumps.
09:19:11 <Fredrik_> I don't really need them, I'm just intrigued by the idea :)
09:19:19 <Fredrik_> And completely puzzled by the type signare of newDiffArray
09:19:31 <EvilTerran> ?hoogle newDiffArray
09:19:31 <lambdabot> Data.Array.Diff newDiffArray :: (MArray a e IO, Ix i) => (i, i) -> [(Int, e)] -> IO (IOToDiffArray a i e)
09:19:38 <EvilTerran> O.o
09:19:43 <EvilTerran> me too...
09:21:54 <EvilTerran> Fredrik_, the Data.Array.Diff haddock describes newDiffArray as "low-level interface", so maybe there's something else to use
09:22:14 <EvilTerran> Fredrik_, where "something else" seems to be Data.Array.IArray.array
09:22:18 <EvilTerran> ?type Data.Array.IArray.array
09:22:19 <lambdabot> forall i e (a :: * -> * -> *). (Ix i, Data.Array.Base.IArray a e) => (i, i) -> [(i, e)] -> a i e
09:29:12 <mibyi> hi guys, i am having a problem compiling yi, can anybody help?
09:29:20 <gwern> mibyi: maybe
09:29:24 <gwern> describe plskthnxbai
09:31:37 <mibyi> http://pastebin.com/m58f1a420 <-- this is my problem
09:31:56 <mibyi> ghc is 6.10.1
09:32:01 <colin___> I'm having a problem build my library with cabal - It says the Prelude is hidden
09:32:14 <colin___> my .cabal file has base in it
09:32:19 <mibyi> everything works with cabal install yi up to that error above in the pastebin
09:32:41 <gwern> mibyi: related to the recent release of regex-tdfa
09:32:47 <gwern> the maintainer changed a lot
09:32:52 <gwern> I forget what the soltion was
09:33:01 <dcoutts_> colin___: is the build-depends field in the right location?
09:33:18 <gwern> mibyi: turn on -v; my cabal install says 'Dependency regex-tdfa ==1.0.* && ==1.0.0: using regex-tdfa-1.0.0
09:33:28 <mibyi> ok, just a moment
09:33:38 <colin___> dunno - I've just posted the .cabal file to the cafe, before gwern suggested trying here
09:33:40 <gwern> mibyi: also look at 'ghc-pkg list|grep tdfa' and see what version's installed
09:33:45 <dcoutts_> mibyi: cabal install yi --constraint='regex-tdfa<1'
09:34:05 <dcoutts_> mibyi: it needs cabal version 0.6.2
09:34:08 <colin___> build-depends is after build-type
09:34:12 <mibyi> aha
09:34:18 <mibyi> just a moment guys
09:34:59 <dcoutts_> colin___: sounds like it's in the wrong place then, it has to be in the library section, not the global section
09:35:30 <dcoutts_> colin___: it's a bug that cabal does not complain about the mistake
09:35:41 <mibyi> dcoutts_, gwern, cabal is doing its magic, still waiting for it to complete
09:35:59 <colin___> mkcabal didn't create a Library section
09:36:03 <gwern> dcoutts_: ah, so now it's a bug is it
09:36:03 <mibyi> and it failed again
09:36:13 <mibyi> Module `Graphics.UI.Gtk' does not export `Event'
09:36:14 <gwern> colin___: mkcabal is old and out of date, it shouldn't've been recommended
09:36:35 <dcoutts_> gwern: if it's an old style .cabal file it'll work
09:36:36 <gwern> mibyi: well, the gtk ui is known to be buggy. I think jpb supports just the pango interface now
09:36:37 <mibyi> another downgrade for it to work guys?
09:36:49 <gwern> mibyi: personally, I just stick with vty
09:37:00 <colin___> I moved build-depends and it builds and installs now - thanks guys
09:37:13 <dcoutts_> mibyi: -f-gtk -f-pango  or you'd need gtk2hs 0.9.12
09:37:25 <mibyi> i have that
09:37:34 <mibyi> 0.9.12
09:37:36 <mibyi> hmm
09:37:56 <dcoutts_> gwern: in new style it simply doesn't work at all, the field is accepted but ignored
09:38:08 <dcoutts_> gwern: so yes it's a bug.
09:38:15 <gwern> bah
09:38:31 <dcoutts_> gwern: it should either be used or rejected, not silently ignored.
09:38:57 <dcoutts_> gwern: so it's clearly a bug, it's just the fix that you and I disagree about
09:39:40 <gwern> as I've said, it should be used; factor out commonalities, DRY, etc.
09:40:14 <dcoutts_> gwern: I agree but I think it should be more explicit
09:40:27 <dcoutts_> ie done properly
09:40:56 <colin___> I am still having problems building the program itself
09:41:04 <mibyi> dcoutts_ it worked
09:41:06 <mibyi> it compiled this time
09:41:19 <gwern> dcoutts_: what, something like 'global-build-depends'? or a 'global' section?
09:41:27 <colin___> first, I get a warning about the tested-with: field - it doesn't like a value of ghc
09:41:29 <dcoutts_> gwern: global, common, something like that
09:41:39 <colin___> but i ignored that and tried to build anyway
09:41:43 <gwern> 'global\n\tbuild-depends: base\nghc-options: -Wall\n'...
09:42:19 <colin___> now it complains that Data.Map can't be found because package containers is hidden
09:42:33 <gwern> so chuck in containers to build-depends
09:42:34 <dcoutts_> colin___: list containers in the build-depends
09:43:30 <mibyi> ok, vty mode works just fine
09:43:37 <colin___> OK - I understand now - i just keeping adding pacckages until it ceases to complain?
09:43:42 <dcoutts_> gwern: similarly the extra-source-files and data-files and that kind of thing ought to be in a subsection not the top level
09:44:02 <dcoutts_> gwern: either per lib/exe or a new common/global section
09:44:20 <gwern> colin___: basically. you have to explicitly enable all libraries
09:44:29 <gwern> mibyi: told ya
09:44:36 <mibyi> :)
09:44:57 <mibyi> no way we can make a gtk version though work
09:44:59 <gwern> dcoutts_: I suppose so. sounds complex, though; in what sense are data-files not global?
09:45:11 <dcoutts_> gwern: do they belong to the lib or exe?
09:45:14 <mibyi> dcoutts_ any ideas?
09:45:42 <dcoutts_> mibyi: yi needs updating for gtk2hs 0.9.13 ot 0.10
09:45:45 <gwern> mibyi: as I said maybe no point jpb is only interested in the pango frontend - better performance etc. I think
09:46:10 <mibyi> ok, then i dump the idea of a gtk frontend
09:46:21 <mibyi> thank you very much both
09:46:22 <dcoutts_> gwern: he's right of course, drawing the text directly is the better long term approach
09:46:24 <mibyi> very very much
09:47:03 <gwern> welcome
09:47:11 <colin___> hey! It works! Thanks guys. :-)
09:51:51 <colin___> what should the tested-with: field look like for ghc 6.10.1?
09:52:42 <roconnor> Tested-with:         GHC == 6.8.2
09:52:51 <roconnor> s/8.2/10.1/
09:53:30 <colin___> thanks roconnor
09:53:45 <roconnor> I remember it taking a while for me to figure that out
09:57:17 <tiz> Hi all... I seem to be having trouble declaring a new instance of IArray (in GHC)
09:57:50 <tiz> There don't seem to be enough visible functions to implement (only bounds)
09:58:54 <tiz> Is it intented to be impossible, or am I missing something?
10:01:04 <mibyi> gwern: is syntax highlighting killed in vim emulation mode? I can't find something
10:01:20 <mibyi> or does it work only for haskell source
10:03:32 <gwern> mibyi: think it's enabled by config
10:03:37 <gwern> look at Yi.Users/
10:05:51 <mibyi> hmm, confused
10:05:57 <mibyi> your .gwern ?
10:06:14 <gwern> yes
10:08:21 <m4nic> I am playing around with template vars. I want several types to convert to TmplVar using a class and instances on the types I want to convert. I am struggling with converting them back again to the original types. I would like to have one seperate function to do that. Can someone here help me? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2187#a2187
10:09:30 <mibyi> gwern it is on by default for haskell i think
10:09:49 <mibyi> i can't get it to work with .c
10:10:20 <gwern> yi has C highlighting?
10:10:21 <mibyi> no sec
10:10:33 <mibyi> .cc *
10:10:51 <trofi> point me plz how to setup YI to understand Home/End keys (it shows [F[H instead)
10:10:53 <skorpan> yes, yi should have C highlighting
10:10:57 <skorpan> at least the lexer is there
10:11:33 <mibyi> hmm it does not highlight .cc files
10:11:43 <skorpan> maybe it's not enabled for .cc
10:11:49 <mibyi> is there an option i am supposed to enable for them?
10:11:54 <mibyi> and where can I do that?
10:12:14 <skorpan> yes, indeed it is not enabled for cc files
10:12:27 <skorpan> the line: modeApplies = anyExtension ["c", "h"],
10:12:32 <skorpan> in Yi.Modes
10:12:38 <skorpan> i'm not sure how you override it in your own config
10:12:51 <pejo> Isn't .cc for C++?
10:13:04 <skorpan> cppMode has cxx, cpp, hxx
10:13:14 <gwern> skorpan: you could probably do something with the 'modeTable' field
10:13:15 <mibyi> pejo yes
10:13:25 <mibyi> .cc is also widely used
10:13:26 <skorpan> yes gwern
10:14:08 <skorpan> let me paste something you could try
10:14:09 <gwern> define your own c++ mode, stick it in your modetable and then it'd pick up cc if you wrote it right
10:14:24 <skorpan> oh, right, what i thought of won't work
10:15:03 <skorpan> or maybe it will... like: cMode { modeApplies = anyExtension ["c", "cc", "h" }
10:15:18 <skorpan> modeTable = (cMode { modeApplies = anyExtension ["c", "cc", "h" }):(modeTable defaultConfig)
10:15:49 <yottis_> uhm, does anyone know if shootout thread-ring benchmark for ghc actually creates 503 os threads?
10:15:58 <pumpkin> it doesn't
10:16:13 <yottis_> shouldn't it be disqualified then
10:16:16 <Baughn> There's no requirement for it to do so
10:16:17 <pumpkin> no
10:16:24 <yottis_> http://shootout.alioth.debian.org/u32q/benchmark.php?test=threadring&lang=all#about
10:16:28 <skorpan> mibyi: try something like this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2188#a2188
10:16:29 <yottis_> Programs may use kernel threads, lightweight threads; but coroutines, cooperative threads and other programs with custom schedulers will be listed as interesting alternative implementations. Briefly say what concurrency technique is used in the program header comment.
10:16:35 <pumpkin> lightweight threads
10:16:39 <gwern> lightweight threads
10:16:40 <Baughn> The benchmark isn't meant to measure the speed of OS threads. ;)
10:16:42 <mibyi> i just did this: modeApplies = anyExtension ["cxx", "cpp", "C", "hxx", "H", "h", "c", "cc", "hh"],  in cppMode
10:16:51 <mibyi> adding cc and hh
10:16:51 <Baughn> yottis_: Yes, GHC's threads fall under "lightweight threads"
10:16:58 <yottis_> what's the definition of a lightweight thread here
10:17:09 <skorpan> mibyi: if you're okay with the conflicts that may occur when pulling, that'll do
10:17:18 <pumpkin> yottis_: something run by your language RTS rather than the OS
10:17:21 <gwern> userland threads multiplexed into a os thread?
10:17:30 <Baughn> yottis_: Threads that are created by the language runtime and don't involve the OS, but otherwise behave like OS threads
10:17:40 <pumpkin> yottis_: many other languages on the shootout have lightweight threads too
10:17:49 <Baughn> Eg. capable of running on multiple cores, are preemptive, etc.
10:18:03 <Baughn> ..although, the GHC threads aren't /exactly/ preemptive; they just work that way most of the time
10:18:03 <mibyi> skorpan: i will do it your way
10:18:25 <mibyi> it makes yi recompile this and put it on the fly yes?
10:18:34 <skorpan> i don't know
10:18:51 <skorpan> don't you have to run M-x reload?
10:19:11 <snoobino_> hey
10:19:14 <gwern> reloadEditor
10:19:20 <mibyi> yea
10:19:26 <gwern> nice to see it still works
10:19:33 <gwern> a lot of the M-x stuff is broken
10:19:45 <skorpan> mibyi: if it doesn't work, it may very well be my imagination thinking it will work
10:19:53 <skorpan> i.e. i'm not sure it will work at all :P
10:20:01 <yottis_> ok, cool, my c fanboy friend just started complaining :)
10:20:14 <snoobino_> why can't I get polymorphic types on let bindings ?
10:20:15 <vixey> complaining
10:20:18 <yottis_> makes the benchmark also more interesting
10:20:21 <vixey> snoobino, you can
10:20:31 <skorpan> mibyi: and oh, i just realized i have two "(modeTable defaultConfig)" in the paste... don't use that.
10:20:48 <pumpkin> yottis_: it's definitely allowed :) all the languages that are at the top have lightweight threads and it just means you don't have to be afraid to spawn a new thread :P
10:21:00 <snoobino_> vixey, how ?
10:21:10 <mibyi> it bombs out skorpan  :P
10:21:17 <mibyi> but thanks for the reminder
10:22:10 <johnbs> is there a built in name for this operator: f |.| f' = (\x -> f x || f' x)
10:22:33 <vixey> snoobino it just happens
10:22:49 <vixey> johnbs, liftA2 (||)
10:22:52 <snoobino_> > let t = (3, 4) :: (Fractional t) => (t,t)
10:22:53 <lambdabot>   <no location info>: parse error on input `;'
10:23:00 <vixey> snoobino, don't write type signatures
10:23:04 <johnbs> vixey: oh ok, thanks
10:24:27 <skorpan> okay mibyi i got it working
10:24:27 <snoobino_> @t (3,4)
10:24:28 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
10:24:32 <Baughn> yottis_: Who cares how threads are implemented? It's how you can use them that matters.
10:24:41 <vixey> :t let t = (3,4) in (t,t)
10:24:42 <lambdabot> forall t t1 t2 t3. (Num t1, Num t, Num t3, Num t2) => ((t, t1), (t2, t3))
10:24:50 <mibyi> skorpan: do tell!
10:24:55 <vixey> :t let t = (3,4) in [t,t]
10:24:57 <lambdabot> forall t t1. (Num t1, Num t) => [(t, t1)]
10:25:00 <skorpan> mibyi: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2190#a2190
10:25:04 <Baughn> yottis_: Now, coroutines or cooperative threads /can't/ be used the same way as POSIX threads, so those might be disallowed, but GHC threads certainly can be.
10:25:20 <skorpan> GOTTA RUN
10:25:42 <yottis_> yeah, this c guy just started complaining that with those rules he couldn't use some library and get the thread count from the command line
10:25:43 <dons> you can't implement threads in userland for  the benchmark, you have to use whatever the runtime provides
10:25:43 <lambdabot> dons: You have 7 new messages. '/msg lambdabot @messages' to read them.
10:25:51 <dons> in haskell's case, this is sparcs : threads : OS threads.
10:25:54 <mibyi> skorpan with ppp replaced though yes?
10:25:54 <dons> sparks.
10:26:00 <yottis_> which arguably is what ghc does, but it's called a language feature
10:26:15 <mibyi> i should make a .yi folder for putting the YiConfig.hs
10:26:20 <Baughn> It's a very complex language feature with a lot of thought behind it
10:26:26 <snoobino_> @ty (3,4)
10:26:27 <lambdabot> forall t t1. (Num t1, Num t) => (t, t1)
10:26:31 <yottis_> i mean you could path gcc to do that, but it would be meaningless effort because you don't benefit from it
10:26:40 <yottis_> patch
10:26:41 <vixey> snoobino: look:
10:26:48 <vixey> :t let id = \x -> x in (id,id
10:26:50 <lambdabot> parse error (possibly incorrect indentation)
10:26:50 <vixey> :t let id = \x -> x in (id,id)
10:26:51 <lambdabot> forall t t1. (t -> t, t1 -> t1)
10:27:01 <Baughn> yottis_: Haskell is supposed to be a pure language, but it has thunks. Getting those right while threading it is /not/ a trivial thing. :P
10:27:04 <vixey> :t (\id -> (id,id)) (\x -> x)
10:27:05 <lambdabot> forall t. (t -> t, t -> t)
10:28:00 <yottis_> yes yes, but that doesn't impress the c crowd (or at least all of them)
10:28:07 <yottis_> "why bother if it's still slower"
10:28:17 <dons> raw numbers impress. and C's lagging :)
10:28:21 <pumpkin> because you can get fast code with a lot less effort :)
10:28:36 <snoobino> vixey, what did you do on the last thing you printed
10:28:38 <Baughn> Because I've got near-AI in my filesystem instead of an LRU cache. ;)
10:28:40 <jlouis> yottis_: the alioth shootout is boring anyway
10:28:41 <yottis_> that was what i was saying too but it's not like the c guys like to listen to that :)
10:28:45 <thoughtpolice> YOU'RE LOSING MICROSECONDS OF YOUR LIFE, MAN.
10:28:51 <thoughtpolice> -MICROSECONDS-
10:28:52 <snoobino> vixey, you typed I mean
10:29:02 <dons> jlouis: its not that boring, try writing faster programs for it.
10:29:16 <pumpkin> yottis_: I was a c guy and was impressed :) my options were ruby for fun and c for speed before, and haskell's taken over both almost completely :P
10:29:19 <vixey> benchmarks bore me
10:29:29 <vixey> I can imagine other people like it
10:29:38 <yottis_> but i still like the performance benefit compared to some interpreted languages that would be roughly the same code amount for most programs
10:29:38 <gwern> well, you bore benchmarks. you're way slower than any of the programs
10:29:44 <Baughn> dons: Actually, is there a "setMinimumHeapSize" call anywhere? Or "setCapabilityCount"?
10:30:01 <dons> Baughn: they're flags, not internal variables
10:30:08 <Baughn> I know
10:30:16 <mibyi> how does haskell compare to erlang when it comes to concurrency (concurrent haskell?) ?
10:30:17 <jlouis> dons: yeah, it is fun as a code golf thing :)
10:30:22 <Baughn> And right now, I've got the program re-executing itself to set them
10:30:32 * dons finds it funny how the ocaml kids don't like the shootout now, ;)
10:30:43 <gwern> mibyi: on multicore machines, it's faster, but iirc there is no good story for haskell on multiple machines
10:30:45 <jlouis> I am no ocaml kid though :)
10:30:48 <ozy`> those ocaml jokers
10:30:50 <mmorrow> > let cont f = Cont (\k -> f (runCont (cont k) f)) in runCont (cont (0:)) id
10:30:51 <vegai> mibyi: haskell has more ways of doing it which can be either a blessing or a curse
10:30:52 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
10:30:56 <thoughtpolice> i think overall I would find more interest in results from the shootin these days then the shootout (providing the shootin wasn't dead)
10:31:05 <mibyi> gwern i see
10:31:05 <gwern> shootin?
10:31:17 <vixey> > let cont f = Cont fix in runCont (cont (0:)) id
10:31:18 <lambdabot>   * Exception: stack overflow
10:31:18 <thoughtpolice> i find the shootout fun when I want to golf things, though.
10:31:29 <vixey> > let cont f = Cont (fix f) in runCont (cont (0:)) id
10:31:30 <lambdabot>   Couldn't match expected type `(a -> r) -> r'
10:31:40 <thoughtpolice> gwern: http://shootin.sourceforge.net/
10:31:41 <dons> mibyi: http://shootout.alioth.debian.org/u64q/benchmark.php?test=all&lang=ghc&lang2=hipe&box=1
10:31:44 <dons> erlang's slower.
10:31:49 <dons> similar threading model though
10:32:01 <jlouis> erlang is a _lot_ slower than ghc for most things
10:32:11 <gwern> oh, the shootout does fractions now
10:32:13 <gwern> that's nice
10:32:28 <pumpkin> thoughtpolice: are you considering putting your generate-c on hackage?
10:32:29 <thoughtpolice> for string i/o erlang is going to get slaughtered by anything afaik
10:32:31 <mibyi> hmm
10:32:40 <gwern> 1/156th? the erlang one must be doing something seriously wrong in that one
10:32:47 <thoughtpolice> pumpkin: sometime when it actually does something useful; I've been meaning to finish it for a while
10:32:48 <dons> you'd be using erlang for different  things
10:32:50 <vegai> erlang's power is in the server framework. Haskell has no equivalent (afaik)
10:32:51 <dons> distribution
10:32:59 <pumpkin> thoughtpolice: ah ok :)
10:33:00 <thoughtpolice> pumpkin: i've been working on my shiny new compiler thing I haven't put in github yet out of fear of ridicule :p
10:33:07 <mibyi> vegai wasn't haskell server pages a project ?
10:33:16 <jlouis> thoughtpolice: for string manipulation it is.. for string i/o I am not so sure
10:33:21 <pumpkin> vegai: there's a haskell module to allow haskell programs to act as erlang nodes isn't there :P
10:33:22 <mibyi> dons: no shared state you mean?
10:33:26 <vegai> mibyi: I'm not talking about web
10:33:32 <pumpkin> thoughtpolice: ooh, what is it? other than shiny
10:33:42 <mibyi> vegai ah ok
10:33:46 <mibyi> misread
10:34:00 <thoughtpolice> pumpkin: namely it wouldn't be hard to make generate-c work, I just want the output to e.g. have a pretty-printer first at the least
10:34:09 <pumpkin> ah
10:34:17 <pumpkin> it's tied in with language.c though?
10:34:25 <thoughtpolice> pumpkin: originally it was going to be
10:34:39 <thoughtpolice> pumpkin: since then I've got changes here on my computer which make it just a stand-alone lib
10:34:44 <pumpkin> I tried using language-c to generate code and it was icky :P which is why I was happy your module appeared
10:34:46 <thoughtpolice> since I was going to hi-jack most of language-c's stuff
10:34:46 <pumpkin> ah
10:35:08 <thoughtpolice> I then realized constructing raw AST fragments around language-c and getting things to work 'okay' was too difficult
10:35:18 <pumpkin> yeah
10:35:23 <thoughtpolice> so now I'm just opting for a basic, pure solution + a pretty printer
10:35:32 <thoughtpolice> really it shouldn't be that hard to do
10:35:33 <pumpkin> sounds good
10:35:37 <thoughtpolice> and I think it would be really useful
10:35:40 <mibyi> this is interesting: http://shootout.alioth.debian.org/u64q/benchmark.php?test=all&lang=ghc&lang2=gpp&box=1
10:35:44 <pumpkin> yup :)
10:36:18 <thoughtpolice> pumpkin: i'm trying to write a compiler in SML
10:36:22 <pumpkin> :O
10:36:56 <jlouis> yay, SML!
10:37:03 <vixey> language.c is really awkward for generating C
10:37:11 <pumpkin> yeah
10:37:24 <pumpkin> they stick "source" location information into the AST for one
10:37:35 <mmorrow> thoughtpolice: nice!
10:37:39 <thoughtpolice> pumpkin: god, NodeInfo information sucks ass to generate
10:37:45 <pumpkin> yeah :)
10:38:03 <thoughtpolice> pumpkin: I eventually just had something at the bottom like 'u = undefined; i = NodeInfo u' so I wouldn't have to write 'NodeInfo...' everywhere
10:38:05 <vixey> what compiler?
10:38:06 <mmorrow> yeah, i got fed up with language-c and decided to make my own too..
10:38:29 <dons> vixey: i think it would be interesting to convey to the authors why Language.C is difficult for generation
10:38:33 <pumpkin> its parsing seems good, but for code generation it's no fun
10:38:40 <dons> write it all down somewhere
10:38:56 <thoughtpolice> dons: I've talked to benedikt a little
10:39:22 <mmorrow> i think it's good at what it's made for, parsing C
10:39:28 <dons> mibyi: it's cool that in the worst case ghc's 3x slower (binary-trees is a bit weird, since it trivially parallelises, but we can't use heap settings)
10:39:49 <thoughtpolice> mmorrow: yeah it's fun. sml is really simple and interesting, but right now i'm writing most of the RTS
10:40:01 <thoughtpolice> mmorrow: on that note thanks for referencing those appel papers!
10:40:09 <jlouis> sml is simple as hell indeed
10:40:13 <thoughtpolice> his runtime work is amazingly simple and understandable
10:40:18 <jlouis> I prefer it to ocaml any dat
10:40:19 <jlouis> day
10:40:19 <gwern> 'There are few sources of power as strong as a procrastinating grad student.'
10:40:27 <mmorrow> but it's like a 2 zillion ton tank with src-position death canons when you're trying to manipulate/view/generate C
10:40:37 <dons> maybwe we need a ghc -server setting
10:40:42 <gwern> @remember PaulGraham "There are few sources of energy so powerful as a procrastinating grad student."
10:40:43 <lambdabot> Good to know.
10:40:45 <gwern> @flush
10:40:48 <gwern> @quote energy
10:40:49 <lambdabot> PaulGraham says: "There are few sources of energy so powerful as a procrastinating grad student."
10:40:49 <jlouis> dons: haha, like Java?
10:40:54 <mmorrow> thoughtpolice: yeah, i really am starting to like sml
10:40:54 <thoughtpolice> jlouis: that's a big reason I chose it actually - easy to understand, fun to play with. :)
10:41:00 <dons> yeah, that just does -N4 -H1G  :)
10:41:05 <jlouis> lol
10:41:19 <mmorrow> thoughtpolice: heh, np. yeah, they hit the spot perrrfectly
10:41:23 <dons> make it simple for the kiddies
10:41:26 <mibyi> dons, yeah
10:41:26 <jlouis> because _that_ is allowed, but -N4 -H1G isn't?
10:41:28 <pumpkin> or automatically determines the -N for you
10:41:33 <mibyi> it is a bit weird
10:41:49 <dons> jlouis: right.
10:41:53 <dons> well, -server is some kind of default
10:41:55 <mibyi> but i am relatively new at this, still studying the slow and painful way
10:41:58 <dons> its not program-specific
10:41:59 <jlouis> thoughtpolice: it has some warts, but it is a pretty clean language
10:42:09 <vixey> I like SML because it's got a watertight definition
10:42:19 <vixey> ...but I never actually program in it
10:42:28 <jlouis> -server enforces JIT compilation up front for instance
10:42:45 <Botje> how is it JIT then? :)
10:42:49 <thoughtpolice> i've had several people tell me that 'the definition of standard ml' is really what made fp and other stuff 'click' for them
10:42:57 <thoughtpolice> apparently a really great book
10:43:00 <jlouis> "watertight"... most implementations of SML suck
10:43:01 <thoughtpolice> i just have paulson's book.
10:43:12 <gwern> they actually learned from a formal semantics?
10:43:19 * gwern hates mathematical folks like that
10:43:36 <thoughtpolice> jlouis: iirc, you were the one talking about an llvm backend for moscow/ml? (jlouisramblings?)
10:43:41 <jlouis> yeah
10:43:46 <jlouis> Still hacking on it
10:44:03 <thoughtpolice> jlouis: ah, fun. :) i'm using mlton for my little project.
10:44:09 <thoughtpolice> i recently tried to install poly/ml
10:44:11 <jlouis> I am probably going to start with a snail-speed implementation
10:44:14 <thoughtpolice> only to find it has 0 stability on OS X
10:44:26 <mibyi> thanks for all the help guys
10:44:30 <mibyi> i appreciate it
10:44:31 <jlouis> and then walk over llvm-gcc
10:44:33 <thoughtpolice> like, absolutely 0 stability, i.e. you can't exit the terminal without it crashing in a horrible death
10:44:35 <mibyi> see you soon :)
10:44:42 <thoughtpolice> jlouis: hehe. :)
10:45:06 <thoughtpolice> also this sucks because it means I actually have to SSH to my linux box
10:45:13 <thoughtpolice> to attempt to use isabelle/HOL in any form :(
10:45:22 <jlouis> and then take the interpreters main-loop and poor-mans-jit it
10:45:44 <thoughtpolice> jlouis: why'd you choose moscow/ml? simple implementation?
10:45:47 <jlouis> I've never done anything with Isabelle. Coq and Twelf on the other hand ...
10:46:26 <jlouis> thoughtpolice: simple implementation, original authors close by and Xavier Leroy is the implementor of the backend so it is somewhat sane
10:46:30 <mmorrow> thoughtpolice: i love how you could sit there, write a bunch of signatures and functors, and have a huge complicated system all perfectly specified, compartmentalized, organized, and insulated from changes to other piece
10:46:39 <mmorrow> s
10:47:12 <mmorrow> and all this before you even write any of the implementation
10:47:19 <jlouis> The disadvantage is that moscow ml is pretty non-conformant to the standard
10:49:16 <jlouis> thoughtpolice: I was hacking on mlton earlier :)
10:49:31 <jlouis> but I think that project is going to die with multicore
10:50:40 <pejo> jlouis, what did people move to from mlton?
10:51:01 <jlouis> pejo: as in the implementors?
10:51:29 <pejo> jlouis, yes
10:52:36 <cnwdup> @src digitToInt
10:52:37 <lambdabot> Source not found.
10:52:45 <Gracenotes> hm. In general, the response to "Is Haskell standardized?" should be 'yes', right? For Haskell 98?
10:52:46 <cnwdup> > digitToInt 'F'
10:52:47 <lambdabot>   15
10:52:50 <jlouis> Suresh and Henry hasn't comitted to the project for quite some years, Stephen Weeks hack ocaml at Janes St. Capital and Matthew Fluet is working on the Manticore project: http://manticore.cs.uchicago.edu/
10:52:55 <Gracenotes> http://en.wikipedia.org/wiki/Comparison_of_programming_languages#General_comparison lists it as NO
10:52:58 <cnwdup> > digitToInt 'X'
10:52:59 <jlouis> pejo: ^
10:53:00 <lambdabot>   * Exception: Char.digitToInt: not a digit 'X'
10:53:28 <pumpkin> Gracenotes: I'd say so, yes
10:53:36 <jlouis> Gracenotes: Haskell 98 is definitely a standard
10:54:02 <pumpkin> all the ones with a "yes" in there are either ISO, ECMA, or ANSI though
10:54:08 <thoughtpolice> jlouis: how does moscow/ml not conform?
10:54:11 <pumpkin> but to define standardized in terms of those bodies is silly
10:54:17 <gwern> pumpkin: yeah, I was about to say...
10:54:23 <thoughtpolice> jlouis: at the very least I guess there'll always be sml/nj, i just really like getting standalone binaries from mlton
10:54:34 <jlouis> - 3.0 = 3.0;
10:54:34 <jlouis> > val it = true : bool
10:54:34 <lambdabot>   <no location info>: parse error on input `='
10:54:37 <jlouis> for instance
10:55:05 <jlouis> reals are not eqtypes, but mosml thinks they are
10:55:57 <jlouis> I need to add typeclasses to the thing. I have type class envy to the Haskell guys...
10:56:10 <Gracenotes> so, would you suggest I change the wiki page? :)
10:56:16 <vixey> I don't like typeclasses
10:56:32 <pastah> @pl \x y -> f (g x y)
10:56:32 <lambdabot> (f .) . g
10:56:43 <pastah> ehm... allright...
10:56:49 <vixey> (very useful but I can't /program/ using them)
10:57:06 <pastah> vixey: i just found a great example
10:57:15 <pastah> like, the greatest
10:57:28 <gwern> Gracenotes: ...haven't you been a wikipedian for years now? you should know the answer
10:57:35 <pumpkin> Gracenotes: I'd say yes
10:57:47 <pastah> it's a lab i'm doing for school, a C++ (subset) interpreter
10:57:56 <Gracenotes> gwern: this relates to content, not to process
10:58:08 <jlouis> GHC is much better at it than most SML compilers. You have a UNIX command line. You call ghc and out comes a binary
10:58:13 <jlouis> easy as a pie
10:58:14 <ImInYourMonad> im trying to figure out how to use latex+emacs, can ltex generate nice symbols like sigma?
10:58:24 <ImInYourMonad> will Yi support latex?
10:58:25 <jlouis> ImInYourMonad: sure
10:59:07 <gwern> ImInYourMonad: does
10:59:13 <pumpkin> Gracenotes: if they say "only national standards bodies need apply" just say that it
10:59:22 <pumpkin> is ridiculous to tie a language down to a particular country
10:59:26 <thoughtpolice> jlouis: yes, that's what I like about mlton. and heap2exe for sml/nj has no support for anything other than x86 linux from what I can tell
10:59:28 <jlouis> ImInYourMonad: look up auctex mode on the emacswiki. Also look at the short-math-guide and the amsmath package. That should make you get a head start
10:59:56 <jlouis> thoughtpolice: mlton is a really cool compiler. I hope to eventually get speeds on par with it
11:00:28 <thoughtpolice> jlouis: yeah it is, and there has been some recent activity in the svn log but... it's just been a while since a release.
11:00:38 <jlouis> even if that means whole-program-compilation
11:00:52 <thoughtpolice> looking at the changelog there seem to be some pretty big additions/fixes too since the last release
11:01:13 <jlouis> Yeah
11:01:26 <pumpkin> Gracenotes: in the talk page they talk about it a bit in the context of standardized python
11:01:30 <pumpkin> the arguments are dumb
11:01:45 <Gracenotes> yes, I skimmed through it
11:07:10 <gwern> I think by the standardization article, haskell '98 is a standard
11:08:37 <pumpkin> yeah, but people are trying to make the argument that it needs to be standardized by a disinterested body for it to be a "true standard"
11:08:59 <jlouis> that is bahlooney
11:08:59 <pumpkin> I'm not sure what the reasoning is behind that
11:09:00 <lifflander> I'm trying to convert from an unsigned Word32 to a signed Int32. How would I go about this?
11:09:51 <pumpkin> > fromIntegral (123 :: Word32) :: Int32
11:09:53 <lambdabot>   123
11:10:03 <pumpkin> > fromIntegral (2^31 + 1 :: Word32) :: Int32
11:10:05 <lambdabot>   -2147483647
11:10:08 <lifflander> >fromIntegral (-1 :: Word32) :: Int32
11:10:23 <lifflander> > fromIntegral (-1 :: Word32) :: Int32
11:10:24 <lambdabot>   -1
11:10:42 <Gracenotes> okay, done. And if someone objects to GHC, Hugs, etc. not being strictly Haskell 98, I'll just point out that JavaScript is listed as a standard, even though most implementations extend it anyway
11:10:48 <lifflander> For some reason that wasn't working on in GHCI?
11:11:27 <lifflander> Nevermind, typing mistake...
11:12:04 <Gracenotes> the Battle Royale of programming language comparisons... bring it on... x-x
11:13:04 <gwern> Gracenotes: not sure it was necessary to point out the extensions
11:13:11 <gwern> ammo f'r enemies
11:16:32 <mjb> How come "--=" doesn't parse as a single line comment?
11:16:46 <dons> looks like a tokenn to me
11:16:48 <Mauke> because it's an operator
11:16:49 <pumpkin> "-- " is the actual comment sequence
11:16:51 <koeien> mjb: that's just a token
11:16:56 <dons> > let (--=) x y = x - y in 1 --= 3
11:16:58 <lambdabot>   -2
11:17:05 <mjb> Ahhhh, so the space is required.
11:17:13 <koeien> > 2+2 --Hello world
11:17:14 <lambdabot>   4
11:17:17 <koeien> no
11:17:24 <pumpkin> or rather, followed by a non-punctuation char
11:17:29 <vixey> > 2+2 -------------------
11:17:30 <lambdabot>   4
11:17:39 <dons> > let (-->) x y = if x ==1 then y else undefined in 1 --> 3
11:17:40 <lambdabot>   3
11:21:35 <ozy`> unfortunately most syntax highlighting code is unaware of the caveat that e.g. (-->) does not begin a comment
11:22:12 <ozy`> including my own :\ too lazy to sit down and hammer out a regex that works.
11:22:20 <dons> writing a proper lexer is a good first step
11:22:43 <stepcut> ozy`: emacs seems to get it right :)
11:22:51 <ozy`> dons: and when that isn't an option?
11:23:09 <ozy`> stepcut: yes, I figured emacs would get it right... and most people use emacs, so this isn't a problem anyone notices
11:23:32 <Mauke> ozy`: --+(?![!#\$%&*+./<=>?\@\\^|~:])
11:23:37 <stepcut> ozy`: when it's not an option --> death by a thousand paper cuts?
11:27:11 <gwern> ozy`: the old geshi highlighter doesn't, so hawiki has that issue
11:27:32 <gwern> yi gets it right fwiw
11:27:40 <stepcut> ozy`: emacs uses a regex I think ;)
11:27:44 <m0nkfish> --[\w\d\s] begins a comment
11:27:45 <m0nkfish> no?
11:28:07 <ozy`> Mauke: awesome, that looks like it'll work
11:28:25 <mle> > ------------------------------------------------------------
11:28:26 <ozy`> gwern: yi has a proper lexer, yes?
11:28:27 <lambdabot>   <no location info>: parse error on input `;'
11:28:37 <ozy`> > --'
11:28:38 <lambdabot>   <no location info>: parse error on input `;'
11:28:38 <vixey> @>--------
11:28:38 <lambdabot> Unknown command, try @list
11:28:43 <gwern> ozy`: think so
11:28:55 <mle> vixey: heh
11:29:10 * sbahra wonders what mle is trying to do
11:29:48 <mle> sbahra: I was demonstrating the problem with monkfish's regex
11:38:04 <vixey> One usually considers ZFC (the axiom system ZF plus the axiom of choice) as a foundation for mathematics (see the entry on set theory). The axiom of choice (AC) has been often considered the most controversial principle of set theory. In constructive contexts one witnesses a peculiar phenomenon. The usual form of the axiom of choice is validated by intensional theories of types such as Martin-Löf type theory, where the Curry-Howard correspondence holds.
11:43:37 <wli> mmorrow: Yeah, Haskell's hurting bad without a module system.
11:44:08 <pumpkin> :o
11:45:35 <Gracenotes> no module system whatsoever
11:46:42 <Baughn> vixey: Hang on, don't we already know the axiom choice is wrong in this universe?
11:46:49 <Baughn> *axiom of choice
11:46:58 <vixey> Baughn, apparently not
11:47:02 <wli> Gracenotes: Well, there's something in the garage, but it's a bicycle, not a Lamborghini Diablo.
11:47:14 <vixey> axiom of choice and excluded middle sort of independent (?)
11:48:40 <ddarius> In those cases the Axiom of Choice is likely a much weaker statement, e.g. the Axiom of Countable Choice.
11:48:56 <Baughn> vixey: Well, the whole cutting-sphere-in-two-for-two-equal-spheres thing?
11:48:59 <paolo> hi all, my question could appear stupid, but I need the answer in order to install a program . I receive this error while doing: runhaskell Setup.hs configure ----- >
11:49:01 <paolo> Setup.hs: At least the following dependencies are missing:
11:49:02 <paolo>     mtl -any
11:49:23 <paolo> what sould I install (I'm using ubuntu)
11:49:25 <paczesiowa> cabal install mtl
11:49:30 <vixey> choice : (forall a : A, exists b : B, aRb) -> (exists f : A -> B, forall a : A, aR(f a))
11:49:32 <vixey> I thinka
11:49:41 <vixey> (for any R : A -> B -> *)
11:49:45 <catface> you need unmeasurable sets for the 1 sphere -> 2 spheres thing
11:49:50 <ddarius> paczesiowa: If he was using cabal install he wouldn't have had that problem to begin with.
11:50:18 <ddarius> Axiom of Choice: All epis are split.
11:50:19 <paolo> paczesiowa: should I type that command ?
11:50:34 <paczesiowa> ddarius: maybe he got that packge from other place than hackage
11:50:49 <paczesiowa> paolo: try haskell-mtl
11:51:16 <paolo> paczesiowa: I don't have it
11:51:33 <paczesiowa> paolo: https://launchpad.net/ubuntu/intrepid/+source/haskell-mtl
11:52:18 <paolo> paczesiowa: thanks, let's try
12:02:48 <paolo> good. but now I have another error:
12:02:51 <paolo>     Could not find module `Text.Regex':
12:02:52 <paolo>       Use -v to see a list of the files searched for.
12:03:30 <dons> cabal install regex-base
12:04:16 <EvilTerran> paolo, what're you trying to install, anyway?
12:04:52 <paolo> a compiler bot: geordi
12:05:25 <paolo> dons: I can't execute the command
12:05:30 <dcoutts_> paolo: actually it's regex-compat you need there
12:05:59 <Zao> paolo: Did you read the installation documentation? Also, there's #geordi
12:06:24 <paolo> Zao: I have read it.
12:06:30 <paolo> I ignored the channel
12:06:32 <paolo> let's try
12:06:38 <dons> paolo: i imagine you don't have 'cabal' installed?
12:07:00 <paolo> dons: I don't have it in the packages list tooo
12:07:09 <dcoutts_> @where cabal
12:07:09 <lambdabot> http://www.haskell.org/cabal
12:07:51 <dcoutts_> or http://www.haskell.org/haskellwiki/Cabal-Install#Installation
12:08:11 <paolo> no, understand me: I have already installed other packages
12:08:22 <paolo> other cabal packages
12:08:33 <vixey> what's the difference of  A^B and B -> A ?
12:10:58 <EvilTerran> vixey, i think they're different notations for the same thing (in some contexts, anyway)
12:11:17 <Raevel> anyone know a prettier way of doing id &&& f?
12:11:24 <EvilTerran> Raevel, that's "second f"
12:11:39 <Raevel> > second (+1) 2
12:11:40 <lambdabot>       No instance for (Num (d, b))
12:11:40 <lambdabot>        arising from the literal `2' at <in...
12:11:44 <EvilTerran> er, no, that'd be (id *** f), my bad
12:11:57 <Raevel> thought so :-)
12:12:19 <mauke> > ap (,) (+1) 2
12:12:20 <lambdabot>   (2,3)
12:12:42 <ddarius> > (,) <*> (2*) $ 1
12:12:43 <lambdabot>   (1,2)
12:12:59 * ddarius would recommend (id &&& f)
12:13:17 <Raevel> yeah
12:14:24 <ddarius> vixey: It depends on the context, and it's likely defined in whatever you are reading.  One common distinction is A -> B is used for an arrow in a category while B^A is used for an exponential object.
12:14:39 <mjb> Is it possible for user-defined classes with no function declarations to be automatically derivable?
12:17:49 <pastah> @faq Can haskell do my dishes?
12:17:49 <lambdabot> The answer is: Yes! Haskell can do that.
12:19:46 <chessguy> @faq can Haskell be ridiculously slow?
12:19:46 <lambdabot> The answer is: Yes! Haskell can do that.
12:20:48 <chessguy> @quote slow
12:20:48 <lambdabot> shapr says: < shapr> the snow falls slowly / the lambdas are lifting - / weak head normal form.
12:21:22 <mauke> 5 6 5?
12:23:42 <gwern> mauke: don't cavil; be grateful it has a kigo at all
12:24:56 <trofi> @src inRange
12:24:57 <lambdabot> Source not found. It can only be attributed to human error.
12:25:10 <trofi> > inRange 3 (1, 3)
12:25:11 <lambdabot>       No instance for (Num ((t, t1), (t, t1)))
12:25:11 <lambdabot>        arising from the litera...
12:25:22 <trofi> > inRange (1, 3) 3
12:25:24 <lambdabot>   True
12:25:25 <trofi> > inRange (1, 3) 1
12:25:27 <lambdabot>   True
12:26:19 <Raevel> oh, ruby has both take and drop, happy day
12:27:35 <ozy`> Raevel: since what version?
12:27:40 <Raevel> no idea
12:27:58 <Raevel> it's funny how ruby code is just like haskell code, except it reads the other way and is 30% longer
12:28:07 <ozy`> or do you mean the "some_array[x,y]" syntax?
12:28:08 <ozy`> yeah
12:28:36 <ozy`> actually, part of the reason I learned haskell was that it would let me do all the stuff I wanted to do (but couldn't) in ruby :p
12:28:49 <Raevel> no i mean [1,2,3].drop(2)
12:29:23 <ozy`> that doesn't seem to be in 1.8
12:29:27 <Raevel> :-O
12:29:37 <Raevel> i have 1.8.7
12:29:53 <Raevel> that's nasty
12:29:54 <pumpkin> some module you loaded provides it for Array?
12:30:01 <Raevel> it's not in 1.8.6
12:30:09 <ozy`> oh right
12:30:10 <Raevel> i just started irb
12:30:19 * ozy` is on 1.8.6
12:30:32 <pumpkin> "Hello friggin,"
12:30:42 <Raevel> my devenv is .7 and production is .6 -_-
12:31:49 <viraptor> hi, is it possible to create a 'IO (Either ParserError a) -> Either ParserError (IO a)' function?
12:32:08 <Heffalump> viraptor: no
12:32:18 <Heffalump> because you can't tell whether it's an error or not without doing the IO
12:32:34 <chessguy> @hoogle ParserError
12:32:34 <lambdabot> No results found
12:32:43 <ozy`> Raevel: class Array; def take n; self[0,n]; end; def drop n; self[n,-1]; end; end
12:33:15 <ozy`> hmm, drop is wrong
12:33:16 <ozy`> oh well
12:33:19 <viraptor> Heffalump: ok, thanks...
12:33:23 <pumpkin> -n, -1
12:33:29 <pumpkin> oh actually :)
12:33:34 <pumpkin> not that either
12:34:00 <Raevel> i ended up writing a[0..n]
12:34:13 <chessguy> Heffalump:  not to mention that the result isn't in the right monad...
12:34:14 <ozy`> I was never all that clear on the semantics of all the different array syntax in ruby
12:34:29 <paczesiowa> viraptor: maybe you don't need IO in your parser, do you use parseFromFile ?
12:34:46 <ozy`> the Range class was always a gigantic hack anyway
12:37:19 <viraptor> paczesiowa: yes, I basically do a '[String] -> [IO (Either P.E. a)]' with parseFromFile and now I'm thinking how to get it to a [a] or fail state...
12:37:48 <paczesiowa> viraptor: separete reading from parsing, first readFile, then parse
12:38:45 * wli writes his third or fourth integer linear equation solver, albeit in insufficient generality.
12:41:10 <viraptor> paczesiowa: will it force the file to be read completely before parsing of will it be lazy? they're quite big and I wouldn't like to read stuff I don't need
12:42:12 <paczesiowa> viraptor: it will be lazy thanks to brilliant unsafeInterleaveIO hack hidden inside readFile bowels
12:42:16 <catface> does Visual Haskell work on VS 2005?
12:42:30 <viraptor> heh, thanks :)
12:42:31 <catface> the website seems confused
12:42:39 <ozy`> catface: only for building GUIs to track IP addresses
12:42:51 * wli attempts to write a Parsec parser for garbage like 3*x + 4*y = 5
12:43:13 <paczesiowa> viraptor: how big are those files? don't be suprised if your parser is really slow
12:44:20 <viraptor> paczesiowa: couple of megs - it's ok if it's slow, but I wouldn't like it to read all of them if the first one fails anyway
12:45:13 <LeoD> wli: you can do that very easily with buildExpressionParser
12:45:15 <eu-prleu-peupeu> hi
12:46:53 <wli> I want it to be very limited though. Literal integer on the left, '*' in the middle, single character variable on the right, a sequence of those separated by '+', then one '=' between that mess and a literal integer.
12:46:57 <pastah> @pl \x y -> f (g x) (g y)
12:46:57 <lambdabot> (. g) . f . g
12:47:25 <pastah> @pl \f x -> f x x
12:47:25 <lambdabot> join
12:47:37 <LeoD> wli: maybe a regex would be enough then :P
12:48:05 <pastah> @pl \x y -> (g x, g y)
12:48:05 <lambdabot> (. g) . (,) . g
12:48:11 <pastah> i want curry!
12:48:22 <pastah> @faq can haskell give me curry?
12:48:22 <lambdabot> The answer is: Yes! Haskell can do that.
12:48:23 <ImInYourMonad> do you use latex to format source code for a paper?
12:48:52 <ImInYourMonad> I have asked this sveeral times with no answer, can you run ghci in Yi?
12:50:51 <BONUS> \x y -> (g x, g y) = curry (join (***) g)
12:50:53 <BONUS> welp
12:51:07 <tombom> well i dunno what rubber could possibly do for yoU!!!!
12:51:11 <tombom> god i'm a genius
12:53:22 <sjanssen> ImInYourMonad: see lhs2tex
12:53:40 <BMeph> @type on (,) (?g::a->b)
12:53:41 <lambdabot>     Could not deduce (?g::a -> b) from the context ()
12:53:41 <lambdabot>       arising from a use of implicit parameter `?g'
12:53:41 <lambdabot>                    at <interactive>:1:8-9
12:53:50 <BMeph> @type on (,) (?g)
12:53:51 <lambdabot> forall b a. (?g::a -> b) => a -> a -> (b, b)
12:54:14 <BMeph> > on (,) g x y
12:54:15 <lambdabot>   Add a type signature
12:54:15 <lambdabot> BMeph: You have 1 new message. '/msg lambdabot @messages' to read it.
12:54:21 <BMeph> > on (,) g x y::Expr
12:54:21 <lambdabot>   Couldn't match expected type `Expr' against inferred type `(b, b)'
12:54:30 <BMeph> > on (,) g x y::(Expr,Expr)
12:54:31 <lambdabot>   (g x,g y)
12:55:33 <BMeph> eu-prleu-peupeu: hi
12:55:50 <pumpkin> :po
12:56:23 <ImInYourMonad> I have asked this sveeral times with no answer, can you run ghci in Yi?
12:57:30 <pumpkin> if people were present who knew the answer, you'd have received an answer by now...
12:57:58 <pumpkin> unless you think people are just witholding information to spite you  :)
12:58:17 <gwern> ImInYourMonad: sort of
12:58:27 <gwern> it's tricky; you can load a lot of it into ghci tho
12:58:39 <ImInYourMonad> sure but C-h C-l is worth a lot
12:58:47 <ImInYourMonad> otherways i migh as well compile
12:59:04 <ImInYourMonad> wait, C-c C-l
12:59:09 <ImInYourMonad> or whatver it is i do in emacs
12:59:25 <gwern> there is that monads-fd issue tho
13:07:25 <gwern> @quote precog
13:07:25 <lambdabot> No quotes match. stty: unknown mode: doofus
13:07:50 <gwern> @remember EliezerYudkowsky Perfect software has an interface which is both telepathic and precognitive.
13:07:50 <lambdabot> Good to know.
13:07:54 <gwern> @flush
13:09:45 <vixey> Perfect software probably has some crap command line interface that you have to sift through 20 man pages to use
13:12:03 <lament> perfect software uses the only intuitive interface.
13:12:37 <p_l> lament: nipple?
13:16:10 <snoobino__> What about an editor which presents code through diagrams (like UML diagrams) ?
13:16:24 <snoobino__> Would that be usefull at all ?
13:17:41 <m0nkfish> it would obviously be a useful prototyping tool
13:18:26 <snoobino__> why ?
13:18:51 <mle> p_l: heh
13:19:02 <m0nkfish> because you wouldnt have to spend a long time writing code to get your ideas down
13:19:11 <m0nkfish> and visual representation in UML form is so much easier to follow
13:19:18 * p_l finds UML counter-intuitive
13:19:33 <mle> uml is really inappropriate for a lot of things
13:19:43 <snoobino__> uml or anything else
13:19:46 <pumpkin> UML gives management boners
13:21:18 <p_l> pumpkin says the truth about UML
13:23:47 <dcoutts_> uml is pretty!
13:24:06 <dcoutts_> looks like it ought to be really technical and mean something
13:24:49 <Spark> it's ok in the right place
13:25:05 <Spark> but it's not the be all and end all of documentation
13:25:18 <Spark> sequence diagrams are quite often useful
13:25:24 <Spark> as they give scenarios by which an API is meant to be used
13:25:27 <ddarius> dcoutts: It does?  Is there a similar format in a different field that is technical and meaningful?
13:25:29 <Spark> class diagrams look awful
13:25:44 <Spark> "actor" is a fairly useless concept
13:25:54 <dcoutts_> ddarius: not sure really, perhaps it reminds people of blueprints
13:26:53 <lament> without UML how do you represent the object model?
13:27:09 <Spark> diagrams of other forms
13:27:09 <lament> when discussing it, i mean.
13:27:13 <lament> Spark: such as?
13:27:19 <p_l> lament: What if you don't use single-dispatch model? :D
13:27:26 <lament> p_l: what if you do?
13:27:26 <Spark> like the diagrams doxygen produces
13:27:28 <Spark> when not in UML mode
13:27:45 <p_l> lament: I lately keep away from it? (even on JVM)
13:27:50 <lament> UML is standard, everybody knows what it means, therefore, it's better than any alternative
13:28:01 <lament> since its purpose is communication
13:28:14 <dcoutts_> lament: UML doesn't mean anything precise
13:28:16 <lament> a crappy language that everybody can speak is better than a wonderful language nobody knows
13:28:30 <Spark> diagrams are only a language by the most simplistic of definitions
13:28:33 <lament> dcoutts_: imprecise communication is better than no communication at all.
13:28:36 <Spark> they are grunts and gesticulations
13:28:49 <dcoutts_> lament: true but precise communication is even better
13:28:52 <Spark> diagrams should be intuitive enough on their own or presented with text otherwise
13:28:52 <p_l> action diagrams can be useful, class diagrams only apply to a certain kind of OOP.
13:28:55 <lament> Spark: i'm not aware of any better alternative.
13:28:59 <p_l> And I'm not a fan of OOP
13:29:07 <thoughtpolice> pencil and paper?
13:29:09 <lament> dcoutts_: not always
13:29:18 <p_l> (at least not Java style OOP)
13:29:22 <lament> dcoutts_: often it takes too long
13:29:33 <Spark> if you want precision, you have to read the code
13:29:37 <lament> exactly
13:29:39 <Spark> documentation is not about precision
13:29:41 <dcoutts_> lament: well if details are not actually important then a fuzzy idea is fine
13:29:47 <jeltsch> Hello, does anyone know how to set the background color of a row in a list view with Gtk2Hs?
13:29:50 <Spark> it's about giving a rough idea of the general top level decisions that were made
13:29:57 <jeltsch> Is this good style at all?
13:30:10 <Spark> http://www.ogre3d.org/docs/api/html/classOgre_1_1Mesh.html
13:30:12 <Spark> this is not uml
13:30:29 <Spark> in my opinion it is clearer than a class diagram
13:30:35 <Spark> because it contains less crap
13:30:56 <lament> it looks like a strict subset of UML to me. The distinction is pretty trivial.
13:31:08 <dcoutts_> Spark: right, UML is nice as a common style of drawing diagrams that give an informal overview
13:31:13 <Spark> http://spark.woaf.net/x10-cpp/classx10_1_1lang_1_1Box.html
13:31:17 <Spark> that on the other hand is horrible
13:31:30 <Spark> too much information
13:31:39 <lament> Spark: that's your own fault for putting it all in.
13:31:47 <dcoutts_> jeltsch: you've looked up the cell renderer properties?
13:32:10 <Spark> lament: it's not uml if you don't put it all in
13:32:29 <dcoutts_> Spark: I don't think that's true
13:32:38 <Spark> well if that's not true then 90% of what people do is UML
13:32:42 <dcoutts_> Spark: it's supposed to be something with a variable level of detail
13:32:43 <Spark> since what people do is draw box/arrow diagrams
13:32:46 <lament> Spark: it's not English unless you tell 100% of what you know.
13:33:01 <Spark> it's not you what know.
13:33:48 <lament> looks like my and dcoutts's concept of UML is different from yours. I'm not sure which one is closer to the "official" definition, but mine is more useful.
13:33:59 <lament> Since UML is imprecise anyway, obeying silly rules is silly.
13:34:13 <pumpkin> silly rule is silly
13:34:15 <dcoutts_> right, the danger with UML is when people assume it means anything
13:34:35 <jeltsch> dcoutts_: Cell renderers provide colorization? Oh, please wait a moment.
13:34:39 <Spark> http://www.conceptdraw.com/products/img/ScreenShots/cd5/uml/UML_Sequence-diagram.gif
13:34:45 <Spark> these are useful though
13:35:00 <vixey> Spark to whom?
13:35:15 <Spark> to people who want to understand the software
13:35:23 <Spark> it's like an abstraction of a call tree
13:35:36 <jeltsch> dcoutts_: Oops, yes. When I first looked at cell renderers a short time ago, I must have ignored these properties automatically since I wasn’t interested in them at that time. :-)
13:35:39 <amaron_> is TreeModelFilter implemented yet in ght2hs current?
13:35:47 <dcoutts_> jeltsch: :-)
13:35:57 <lament> Spark: that's very nice, it makes the layers of the architecture explicit
13:36:03 <Spark> exactly
13:36:25 <Spark> it's also hard to grasp from the code
13:36:33 <Spark> since this information will be split across lots of places
13:36:47 <Spark> and attempting to construct it automatically will result in no abstraction
13:37:05 <amaron_> *gtk2hs
13:38:07 <Spark> but this.. is just ugly http://spark.woaf.net/x10-cpp/classx10_1_1lang_1_1Box__inherit__graph.png
13:38:26 <Spark> the stupid block shadows on the sequence diagram are ugly but that's easily correctable
13:38:32 <Spark> by not being an idiot when drawing the diagram
13:38:36 <ImInYourMonad> is an implementation of an algorithm a proof? under curry-howard is writing an implementation of quicksort a proof of quicksort?
13:39:12 <vixey> proof of quicksort
13:39:12 <vixey> lol
13:39:21 <vixey> what does that mean?
13:39:36 <MyCatVerbs> @pl \f x -> (x,f x)
13:39:36 <lambdabot> ap (,)
13:39:40 <Spark> proving quicksort is fairly easy
13:39:42 <Spark> iirc
13:39:50 <ImInYourMonad> yes but thats not what im asking
13:40:09 <vixey> "proving quicksort" "proof of quicksort" what does this mean
13:40:14 <Spark> and i don't think that's what curry-howard means
13:40:15 <MyCatVerbs> ImInYourMonad: type systems correspond to logics. Curry-Howard is a description of that.
13:40:44 <ImInYourMonad> given a list of Integers, this algorithm returns them in ascending order in n log n time with a worst case of N2
13:40:46 <MyCatVerbs> ImInYourMonad: type checkers are hence formal proof verifiers.
13:40:49 <wli> Hmm. I'm getting nontermination.
13:40:55 <Spark> vixey: prove that it sorts things properly?
13:41:03 <MyCatVerbs> ImInYourMonad: in this case, no, not really. Haskell's type system is not really sufficiently powerful to embed a proof of quicksort's correctness in.
13:41:04 <pumpkin> ImInYourMonad: the key point is the type
13:41:07 <ImInYourMonad> so curry-howard is type proofs only?
13:41:38 <Spark> i can't remember but isn't the type the thing you're trying to prove
13:41:42 <Spark> and the term is the proof?
13:41:44 <MyCatVerbs> ImInYourMonad: the problem is that H98's type system is not expressive enough to model some constraints.
13:41:50 <Spark> and the derivation is the checking?
13:41:58 <vixey> and that haskell corresponds to a trivial logic
13:42:11 <vixey> one where True = False
13:42:19 <vixey> everything collapses into meaninglessnesss
13:42:23 <MyCatVerbs> ImInYourMonad: in order to model arbitrary constraints, you need a Turing-complete type system. Which is, y'know, a pain.
13:43:22 <amaron_> dcoutts_, jeltsch : if you want to filter model of TreeView (ListStore -> TreeModelSort) how do you do it?
13:43:25 <MyCatVerbs> ImInYourMonad: plus, as vixey points out, the logic that Haskell's type system corresponds to is actually inconsistent. Mainly because (undefined :: forall a. a) exists, and hence under Haskell's type system, *all* types are occupied and hence in the logic that it corresponds to *all* statements are true.
13:44:10 <Spark> you don't use the type system of a programming language for doing proof checking
13:44:13 <dcoutts_> amaron_: it's probably easier to do it on your store directly rather than generically
13:44:20 <wli> I'm probably getting a cycle in my reductions.
13:44:25 <MyCatVerbs> ImInYourMonad: that's the theory. In practice it's not so much of a problem, and you *can* use the type system to model some interesting properties, mainly because you do your damnedest to avoid the inconsistent parts.
13:45:08 <MyCatVerbs> Spark: you can if you have a Turing-complete type system. Adga hackers seem to do it all the time. Usually to prove that things terminate, but yeah.
13:45:17 <Spark> what is the haskell type that corresponds to a sorted list? :)
13:45:21 <ImInYourMonad> MyCatVerbs: a pain as in impossible? because then youd need an even more complete typesystem to rpove that?
13:45:47 <ImInYourMonad> and making haskell inconsistent would ame it suck?
13:46:05 <cnwdup> Spark, if you don't want duplicates it would be Data.Set I guess.
13:46:12 <amaron_> dcoutts_: hmmm, so if I allready have sorted model wrapped around ListStore, isn't that bad way to do it?
13:46:35 <MyCatVerbs> ImInYourMonad: no, a pain because it's possible that you could write a program that will make the type checker loop forever. And also a pain because it makes the type system's behavoir more complicated, so it can be more difficult to use.
13:47:13 <amaron_> dcoutts_: i would have to get list from ListStore, filter it, make new ListStore, sort it and set it as model
13:47:13 <ImInYourMonad> what Im wondering is I guess, how would mathematicians react to a computer program that made it obvious how some proof could be constructed?
13:47:47 <MyCatVerbs> ImInYourMonad: disbelief. :)
13:47:51 <dcoutts_> amaron_: yes, I'd do all filtering and sorting on the original in Haskell code.
13:48:23 <Spark> ImInYourMonad: proof-carrying code
13:48:25 <dcoutts_> amaron_: a generic one is harder. If you don't need the original to remain unsorted and unfiltered then do it all together in the one store.
13:48:42 <Spark> ImInYourMonad: you can annotate a program with its proof easily enough
13:49:01 <iago_> Spark, how
13:49:01 <Spark> and by "easily enough" i mean "without upsetting mathmeticians"
13:49:16 <MyCatVerbs> iago_: trivial way is to write it in the comments.
13:49:17 <Spark> see proof carrying code
13:49:43 <Spark> whether you would prove the whole thing does what's expected is debateable
13:49:54 <Spark> you would probably want to prove that it never encounters certain states
13:49:55 <MyCatVerbs> iago_: more difficult, but also doable, is where you use a Turing-complete type system like Adga's or GHC's with MPTC and undecidable instances turned on to embed the proof in the types.
13:49:57 <iago_> MyCatVerbs, informal proofs aren't very useful
13:49:57 <Spark> like a divide by 0 for example
13:50:01 <amaron_> dcoutts_: i see, so you dont use TreeModelSort at all
13:50:10 <dcoutts_> amaron_: right
13:50:13 <Spark> iago_: they would be checked by a special interpreter
13:50:21 <MyCatVerbs> iago_: just because they aren't machine-verified on compilation doesn't make them informal. :P
13:50:56 <iago_> Spark, yeah
13:51:02 <iago_> something exists?
13:51:05 <Spark> probably
13:51:08 <Spark> something awful and academic
13:51:08 <ddarius> MyCatVerbs: If they aren't machine verified at all, it does by computer scientist standards.  Of course, computer scientist standards are way higher than mathematician standards.
13:51:16 <Spark> that is useless for writing real programs
13:51:20 <Spark> the concept is reasonable though
13:51:29 <MyCatVerbs> iago_: look up Coq.
13:51:35 <iago_> MyCatVerbs, I know Coq
13:51:43 <iago_> Spark, do you know something?
13:51:47 <amaron_> dcoutts_: hmmm, it was useful since you just set sort functions for each column and gtk handles rest: click on header, ascending/descending...
13:51:51 <MyCatVerbs> ddarius: er, really? Because I'm thinking of some algorithms work I've seen and, well...
13:51:56 <Spark> nah i got bored of the area
13:52:07 <Spark> as a programmer, i don't want to prove my code correct
13:52:13 <Spark> it takes too long
13:52:33 <iago_> MyCatVerbs, Coq approach is quite different
13:52:38 <MyCatVerbs> ddarius: "assume we can generate log(n)-independant hash functions that can be evaluated in O(1) time" at the start of the cuckoo hashing paper, for example. :)
13:52:39 <Spark> i'd rather have more features than less features that are known to be correct
13:52:42 <dcoutts_> amaron_: and it's bound in Haskell is it? and works? I wasn't bound last time I thought of using it.
13:52:48 <dcoutts_> I/it
13:52:58 <ddarius> MyCatVerbs: Did they call the proof formal?
13:53:59 <MyCatVerbs> ddarius: I... don't know. The rest of the proof works just fine, once you have those mayhap-impossible hash functions in hand, though.
13:54:19 <ddarius> MyCatVerbs: How do you know it works just fine?
13:54:19 <vixey> iago_, different to what?
13:54:23 <goomba`> MyCatVerbs, they can just say quantum mechanics did it
13:54:40 <iago_> vixey, to the approach that we was discussing
13:54:40 <amaron_> dcoutts_: ah, I see, it's not ready yet... I'm porting my old pygtk code to gtk2hs, so I didn't knew that.
13:54:49 <wli> GAH I forgot to divide out the gcd when nontrivial.
13:55:03 <MyCatVerbs> ddarius: gone through it in a lecture. It establishes that its conclusions are implied by its premises.
13:55:35 <MyCatVerbs> ddarius: what else would I need?
13:55:36 <ddarius> MyCatVerbs: I'm sure you've "known" your programs were type correct right up until you compiled them.
13:56:28 <vixey> iago_, have you written some things which could be an example of it? I am curious to see these
13:56:45 <iago_> vixey, an example of what?
13:56:50 <MyCatVerbs> ddarius: surprisingly enough, I don't think I actually have any time in the last year or so.
13:57:09 <vixey> iago_, the different approach of Coq
13:57:16 <ddarius> MyCatVerbs: That's because you are becoming more and more a computer scientist and learning that you are always wrong and the computer is always right.
13:57:22 <Eridius> is there any sort of compiler directive you can insert into code that says not to warn about an unused value? The purpose here is to stick it within an #ifdef block
13:57:28 <iago_> vixey, well, will be degree-project
13:57:31 <jackdempsey> might anyone be able to point out my boneheadedness with this: (sum [1,2,3]) / (length [1,2,3])
13:57:36 <MyCatVerbs> ddarius: Yes. Now, when I *started out* on the other hand...
13:57:41 <vixey> iago_, details? :)
13:58:03 <vixey> jackdempsey, I blame Haskells numeric thingy sucking
13:58:10 <Eridius> jackdempsey: you're doing division on Ints
13:58:11 <vixey> jackdempsey, you could `div` or fromIntegral
13:58:12 <iago_> vixey, something like why-for-haskell, nowadays in "thinking" phase
13:58:14 <jackdempsey> just getting started with haskell, and not really sure how to 'get' what No instance for (Fractional Int) means
13:58:19 <MyCatVerbs> ddarius: I'm glad I went into this field, because I don't think I'd've had the arrogance kicked out of me quite so efficiently anywhere else. Heh.
13:58:22 <jackdempsey> right but 6 / 3 works
13:58:30 <iago_> vixey, you annotate the code and some tool generates proof obligations
13:58:37 <Eridius> jackdempsey: the / operator is only defined for Fractional values. Int is not one
13:58:47 <jackdempsey> yea i was trying to use fromIntegral but thought i'd simplify things a bit and make sure i get it...which has been a challenge :-)
13:58:49 <jackdempsey> ohh
13:58:52 <Eridius> jackdempsey: 6 / 3 works because every integer constant in your source has an implied (fromIntegral x) wrapped around it
13:59:00 <jackdempsey> ah
13:59:10 <jackdempsey> implied not so obvious :-) thanks much, that definitely clears it up
13:59:15 <vixey> iago_, do you use Bove-Capretta method for showing the Haskell program terminates?
13:59:41 <jackdempsey> ah yes, adding a fromIntegral to the second makes sense. cool
14:00:20 <__moose> hey room - has anyone in here got experience with getting the llvm bindings for haskell working?
14:00:42 <__moose> I'm trying to, but keep ending up with link errors when I eventually try to use them :(
14:02:40 <iago_> vixey, I just start one week ago to think in the project, I don't think in this details yet, for now, I was thinking in the goals etc, and perhaps in some problem that I see, but not in concrete algorithms for do something
14:02:58 <vixey> iago_, oh ok
14:03:55 <iago_> vixey, 6 months later I can say more to you ;P I would start to work seriously in three months
14:04:41 <iago_> I have to finish some courses first
14:05:51 <pumpkin> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/future weird packages with self-referential homepages
14:07:15 <Heffalump> seems kind of appropriate for a future
14:09:09 <wli> woops, I was dividing by the abs of the coefficient where I should've been dividing by the actual coefficient.
14:09:16 <__moose> More generally then... does anyone know much about how ghc links in additional libraries?
14:09:37 <bgk> _moose with glue!
14:09:39 <__moose> I notice from the output of ghc -v that there is no mention of the llvm library that I assume it must need to link in... hence I'm getting undefined symbols.
14:09:48 <pumpkin> __moose: --make?
14:09:52 <__moose> bgk: apparently, not enough glue in my case!
14:09:58 <__moose> pumpkin: let me try, hang on..
14:10:20 <pumpkin> you can pass in -l<library minus the lib prefix> too
14:10:43 <pumpkin> but I've only had once case where that was necessary
14:10:48 <__moose> pumpkin: thanks - that did the trick... I had asumed --make was only for navigating source dependencies between .hs files, I didn't realise it was involved in link decisions too
14:10:59 <__moose> yeh, I've been fiddling with the -l and friends all night :)
14:11:07 <__moose> I assumed I was missing something! --make in this case.
14:11:20 <pumpkin> --make should be renamed to --magick :)
14:11:40 <__moose> LOL :)
14:11:56 <__moose> Thanks for the assistance pumpkin
14:12:13 <pumpkin> no problem
14:12:26 <ddarius> "--make" should be renamed to ""
14:12:27 <wli> triangularize $ Data.Set.fromList [eq | Right eq <- map parseEqn ["3*x+5*y+7*z=11","1*x+1*y+1*z=13","1*x+2*y+4*z=17"]] ---> (fromList [Eqn {lhs = fromList [("x",1)], rhs = 45}],[("z",Eqn {lhs = fromList [("x",1),("y",1),("z",1)], rhs = 13}),("y",Eqn {lhs = fromList [("x",-2),("y",-1)], rhs = -40})])
14:12:37 <pumpkin> yeah, that's probably a better idea :)
14:12:40 <__moose> :)
14:12:54 <__moose> It is certainly surprising to me that it affects the link flags... but, oh well, I have it working now
14:12:58 <__moose> Thanks
14:14:16 <Heffalump> ddarius: well, if a --nodeps flag is added to undo it
14:14:17 <wli> The solve routine isn't quite correct.
14:14:28 <pumpkin> yeah
14:14:31 <wli> (By a longshot)
14:16:00 <ddarius> Heffalump: Indeed.
14:16:13 <jackdempsey> heh, man this is taking some getting used to
14:16:19 <jackdempsey> 2.51 rounds to 3, but 2.5 rounds to 2
14:16:35 <vixey> :t toRational
14:16:36 <lambdabot> forall a. (Real a) => a -> Rational
14:16:44 <vixey> > toRational (2.5::Double)
14:16:45 <lambdabot>   5%2
14:16:46 <Heffalump> jackdempsey: round to even
14:16:48 <ddarius> > map round [0.0, 0.5 ..]
14:16:49 <lambdabot>   [0,0,1,2,2,2,3,4,4,4,5,6,6,6,7,8,8,8,9,10,10,10,11,12,12,12,13,14,14,14,15,...
14:16:56 <Heffalump> it helps to avoid systematic errors in rounding
14:17:00 <wli> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2191#a2191
14:17:02 <ozy`> > round (0.5 :: Rational)
14:17:03 <lambdabot>   0
14:17:21 <jackdempsey> heh
14:17:47 <jackdempsey> cool thanks
14:19:23 <wli> The basic idea is to find the nonzero coefficient of smallest absolute value and carry out integer row reductions around coefficients of that variable.
14:19:59 <wli> Once a variable is eliminated from all but one equation, pull the equation out and recurse.
14:20:52 <Axman6> > toRational (pi :: Double)
14:20:53 <lambdabot>   884279719003555%281474976710656
14:21:05 <Axman6> > toRational (pi :: CReal)
14:21:07 <lambdabot>   * Exception: CReal.toRational
14:21:18 <Axman6> :t toRational
14:21:20 <lambdabot> forall a. (Real a) => a -> Rational
14:21:57 <wli> When the smoke clears, you should get some equations relating variables trivially determined via linear relations and a system where Bezout or whatever generalization determines all the solutions.
14:23:30 <jackdempsey> so i'm working through some simple examples from RWH. one exercise is to see if a list is a palindrome. i was thinking i could get the length of the list, halve it, take that many from the front, and do the same on the reverse of the list and compare
14:23:43 <jackdempsey> or is that over/under thinking it?
14:23:56 <tromp_> why not compare whole with reverse?
14:24:06 <jackdempsey> heh
14:24:09 <jackdempsey> ah
14:24:11 <jackdempsey> why indeed
14:24:41 <jackdempsey> there really is a different mindset. thank you tromp_
14:25:18 <Axman6> > let palin xs = xs == reverse xs in palin ([1..1000] ++ [1000,999..1])
14:25:20 <lambdabot>   True
14:25:31 <Axman6> > let palin xs = xs == reverse xs in palin ([1..10000] ++ [10000,9999..1])
14:25:33 <lambdabot>   True
14:25:43 <Axman6> > let palin xs = xs == reverse xs in palin ([1..100000] ++ [100000,99999..1])
14:25:45 <lambdabot>   True
14:25:48 <tromp_> keep palin out of this:)
14:26:07 <Eridius> you only have to actually compare the first half (rounded up) characters
14:26:24 <tromp_> round down is fine too
14:26:28 <Eridius> ...true
14:26:29 <Axman6> > let palin xs = xs == reverse xs in palin (0:[1..100000] ++ [100000,99999..1])
14:26:31 <Alpounet> hi guys
14:26:32 <lambdabot>   False
14:26:51 <jackdempsey> haha
14:27:17 <Axman6> Eridius: got to traverse the list once anyway
14:27:19 <Alpounet> do you think there's a better way to define a function returning the last but one element of a list than : head . tail . reverse ?
14:27:42 <vixey> @src init
14:27:42 <lambdabot> init [x]    = []
14:27:42 <lambdabot> init (x:xs) = x : init xs
14:27:42 <lambdabot> init []     = undefined
14:27:54 <tromp_> last . init ?
14:28:40 <pumpkin> > length . init . replicate 5 $ undefined
14:28:41 <lambdabot>   4
14:29:29 <ddarius> tromp_: head . tail . reverse would be more efficient than that.
14:29:51 <tromp_> yes, unless ghc is very smart
14:29:57 <iago_> vixey, do you work on FV?
14:30:07 <Alpounet> > head . tail . reverse $ [1,2,3]
14:30:09 <lambdabot>   2
14:30:14 * BMeph_ agrees with ddarius. In general, but most certainly on this point.
14:30:14 <viraptor> how can I make a '[FilePath] -> IO [(FilePath, String)]' function? I've done '[FilePath] -> [(FilePath, IO String)]' with mapM and readFile...
14:30:36 <Alpounet> so head.tail.reverse seems to be better ?
14:30:46 <Axman6> > init . last $ [1..10000]
14:30:48 <lambdabot>       No instance for (Enum [a])
14:30:48 <lambdabot>        arising from the arithmetic sequence ...
14:30:59 <Axman6> > last . init $ [1..10000]
14:31:01 <lambdabot>   9999
14:31:02 <vixey> iago_: no what is FV
14:31:05 <Axman6> > last . init $ [1..100000]
14:31:07 <lambdabot>   99999
14:31:11 <Eridius> Alpounet: last . init has to traverse the list twice. head.tail.reverse only traverses it once
14:31:13 <Axman6> > last . init $ [1..1000000]
14:31:15 <lambdabot>   999999
14:31:24 <Axman6> > last . init $ [1..10000000]
14:31:26 <lambdabot>   9999999
14:31:32 <Axman6> > last . init $ [1..100000000]
14:31:38 <lambdabot>   99999999
14:31:39 * Axman6 is waiting for this to die :|
14:31:42 <Alpounet> Eridius, okay.
14:31:44 <Axman6> > last . init $ [1..1000000000]
14:31:59 <lambdabot>   thread killed
14:32:04 <Eridius> the fastest way would be to write your own function similar to init :P
14:32:12 <Axman6> > logBase 10 1000000000
14:32:14 <lambdabot>   8.999999999999998
14:32:16 <Eridius> certainly the most memory-efficient way
14:32:17 <Alpounet> init drops the last element ?
14:32:19 <iago_> vixey, formal verification sorry
14:32:21 <Eridius> yes
14:32:55 <tromp_> @hoogle join
14:32:55 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
14:32:55 <lambdabot> System.FilePath.Posix joinDrive :: FilePath -> FilePath -> FilePath
14:32:55 <lambdabot> System.FilePath.Windows joinDrive :: FilePath -> FilePath -> FilePath
14:32:56 <Alpounet> Okay, thanks.
14:33:05 <Alpounet>  > head.tail.reverse $ [1..1000000000]
14:33:11 <ImInYourMonad> is there langauges that are more highlevel or a the same level as C that doesn have pointers? ie can you have manual memory management without pointers and without being down in asm?
14:33:16 <Alpounet> > head.tail.reverse $ [1..1000000000]
14:33:32 <lambdabot>   thread killed
14:33:33 <vixey> iago_, it's something I study in free tim
14:33:37 <vixey> iago_, time*
14:33:43 <Axman6> > last . init $ [1..100000000]
14:33:53 <lambdabot>   99999999
14:33:54 <Axman6> > head . tail . reverse $ [1..100000000]
14:33:57 <Eridius> ImInYourMonad: your question is very confused
14:34:10 <lambdabot>   thread killed
14:34:34 <Axman6> ImInYourMonad: Objective-C does something like that, though it's garbage collected not anyway
14:34:46 <pumpkin> objective c still has pointers up the wazoo
14:34:52 <Axman6> yeah
14:34:53 <sjanssen> ImInYourMonad: I think any language with manual memory management will probably have something similar to pointers
14:34:56 <sjanssen> even if they're not called that
14:35:01 <Eridius> Axman6: GC in Obj-C is pretty new
14:35:18 <Axman6> uhm s/not/now :)
14:35:27 <Axman6> it's new in 10.5, yes
14:35:34 <iago_> vixey, constructive ? or any
14:35:39 <Eridius> heh
14:35:51 <Axman6> the GC is open source too, which is nice. apparently it's quite generic
14:35:56 <Eridius> the newest obj-c platform doesn't even have GC (the iPhone)
14:36:19 <Eridius> of course that's for practical reasons (GC on the iPhone would kinda suck)
14:36:28 <pumpkin> :)
14:36:51 <vixey> iago_: constructive
14:37:10 <Axman6> Eridius: the iPhone doesn't have GC?
14:37:15 <Axman6> did not know that
14:37:23 <pumpkin> yup
14:37:51 <Eridius> Axman6: yeah, they left it out on purpose
14:37:53 <pumpkin> it's rather memory-constrained already, so you can't rely on something "eventualy" being cleaned up
14:37:53 <Axman6> guess it is the sort of platform where tyou need to be careful with memory usage
14:37:59 <Eridius> exactly
14:38:30 <Eridius> that and GC means your processor usage is now less predictable, which can be a very bad thing if you're writing realtime games
14:39:00 * Eridius hugs NSAutoreleasePool
14:39:08 <pumpkin> :P
14:39:21 <Deewiant> if you're writing realtime games you have to preallocate everything, GC or no GC
14:40:17 <ddarius> Deewiant: You could use a real-time GC, but that will probably cost too much throughput.
14:40:30 <pejo> There's been work on realtime GC. (Not saying it's easy).
14:41:10 <Deewiant> How does that work? My point was that anything that allocates memory will run in unpredictable time
14:41:11 <ImInYourMonad> but Android uses Java. or Dalvik VM a specialized Java VM. but still GCed.
14:41:22 <ddarius> Deewiant: You point is false.
14:41:37 <Deewiant> ddarius: Do tell
14:43:55 <ddarius> Deewiant: Modulo virtual memory, which doesn't require allocation to be unpredictable, allocating doesn't have to be expensive and usually it is not nor unpredictable modulo GC.  Real-time GCs are exactly things that give you guarantees about how long a GC pass will take which would give you guarantees on how long an allocation would take.
14:45:03 <ddarius> As a trivial example, I can allocate just by bumping a pointer and if I just fail if I run out of memory as opposed to GC then I have guaranteed costant and low time for allocation.
14:45:16 <L11> is there a way to do enumeration in haskell?
14:45:33 <Heffalump> there's the Enum type class
14:45:38 <pumpkin> L11: enumeration in what sense?
14:46:05 <L11> well I need to make a function that converst years to their roman equivalent
14:46:23 <L11> I was hoping to have enumeration, like in C++ or PHP where I could define M to be 1000
14:47:21 <Deewiant> ddarius: Well I'm sort of assuming systems where allocation fails only when it actually is not possible to get more memory i.e. the OS has killed all running processes that it can, the heap is defragmented, and all the RAM is still in use
14:47:32 <L11> my plan is to go through the date, mod it until I no longer get a remainder - how should I try each case (I = 1, IV = 4, V = 5 . . . etc)
14:48:55 <Deewiant> ddarius: If you just fail like that then it's essentially equivalent to preallocation, the pointer bump isn't "really" a memory allocation
14:50:44 <ddarius> Deewiant: If you get to where you have to ask for memory for the OS then you are probably screwed as few OSes give any kinds of guarantees.
14:50:50 <brool> L11: you could probably fold over a list, or something like that
14:50:54 <Deewiant> ddarius: Yeah, and that was my point.
14:51:18 <ddarius> Deewiant: However, you could preallocate a large amount from the OS and still handle memory (or rather the RTS does) yourself and avoid that issue.
14:51:25 <vixey> L11, I wonder if you could do it as a term rewriting system starting with "I"^n, reduce "IIIII" --> "V" and so on
14:51:36 <ddarius> And that would not be equivalent to simply preallocating all your data structures.
14:51:41 <Deewiant> ddarius: Yes, preallocation works and is the only way to do real-time systems.
14:52:06 <Deewiant> Okay, yes, it's different, but I map both of those under 'preallocation'. :-)
14:52:07 <vixey> L11, probably not a good way
14:52:13 <ImInYourMonad> has anyone tried to get a haskell program to run on a cellphone?
14:52:24 <ImInYourMonad> like is their some port of ghc to jvm?
14:52:30 <Deewiant> ImInYourMonad: http://www.joachim-breitner.de/blog/archives/300-Xmonad-on-my-mobile-phone.html
14:52:34 <ddarius> Deewiant: I'm sure there are OSes/OS interfaces that guarantee a bounded response time.
14:53:00 <Deewiant> ddarius: Possibly, but then we're probably talking embedded systems.
14:53:30 <ddarius> Well, many embedded systems do, but I'd be very surprised if there weren't Linux variants that offered such interfaces.
14:53:39 <Olathe> > map roman [1..20]
14:53:41 <lambdabot>   ["I","II","III","IV","V","VI","VII","VIII","IX","X","XI","XII","XIII","XIV"...
14:53:45 <ddarius> Let alone experimental desktop operating systems.
14:53:53 <vixey> what is the source code of roman
14:54:01 <p_l> ddarius: desktop & hard real time doesn't go well
14:54:08 <Olathe> vixey: let roman = f' [("M", 1000), ("CM", 900), ("D", 500), ("CD", 400), ("C", 100), ("XC", 90), ("L", 50), ("XL", 40), ("X", 10), ("IX", 9), ("V", 5), ("IV", 4), ("I", 1)] where f' [] 0 = ""; f' xxs@((a, b):xs) n = if n >= b then a ++ f' xxs (n - b) else f' xs n
14:54:10 <Deewiant> Perhaps, but I can't really see how that'd work well
14:54:11 <tromp_> > roman 0
14:54:12 <lambdabot>   ""
14:54:26 <Deewiant> > roman 9001
14:54:27 <ddarius> Deewiant: If they worked well we'd have them in every OS.
14:54:28 <lambdabot>   "MMMMMMMMMI"
14:54:48 <p_l> also, I wouldn't run Linux for hard realtime
14:54:52 <Deewiant> ddarius: Quite. :-)
14:55:05 <rio> > map roman [1..20]
14:55:06 <lambdabot>   ["I","II","III","IV","V","VI","VII","VIII","IX","X","XI","XII","XIII","XIV"...
14:55:08 <lotfi>  :)
14:55:27 <mle> remove IV for historical accuracy
14:55:28 <SamB> you can probably get them to work, but most of the desktop apps wouldn't be able to support hard realtime themselves ;-)
14:55:31 <p_l> however, L4Linux might give you bounded response time, by preempting Linux kernel completely :)
14:55:43 <lotfi> mi scusi ho sbalit
14:56:13 <p_l> mind you, L4Linux is a _userspace_ application. The hard-real-time part would have to run without Linux apis :P
14:56:38 <lotfi>  '<
14:58:06 <wli> I don't remember how to generate solutions for integer linear equations when there are more than 2 un-eliminated variables left in the final equation.
14:59:35 <ozy`> > roman 1994
14:59:36 <lambdabot>   "MCMXCIV"
15:00:52 <LeoD> @src roman
15:00:53 <lambdabot> Source not found. That's something I cannot allow to happen.
15:01:00 <wli> e.g. the system { 41*w+61*x+71*y+101*z=161, 37*w+29*x+23*y+19*z=17 } reduces to z = -211 - 469*w - 281*x - 155*y and 1479*w + 885*x + 487*y = -671, but getting the (w,x,y) triples from Bezout or whatever I forget how to do.
15:02:55 <wli> I don't know of a good way to represent solution spaces anyway, so who knows.
15:03:14 <Olathe> Well, the first part of the solution has z and the second part doesn't, so I'd say you just need to solve the second using extended GCD or something.
15:04:16 <wli> Olathe: That's what I meant with "Bezout;" the trouble is that I only know how to do solutions for two variables with Bezout / extended GCD.
15:05:04 <Olathe> > gcd 1479 885
15:05:05 <lambdabot>   3
15:05:20 <Olathe> You have 3*a + 487*y = -671
15:05:43 <Olathe> Then, once you have a value for a, you can get 1479*w + 885*x = 3*a
15:07:22 <wli> Olathe: I really have to look this up somewhere. Even if that works for this case, who knows in general. Anyway, I can do the elimination steps well enough.
15:07:58 <Olathe> Oh, it works in general.
15:08:06 <wli> Olathe: For most of the cases I care about right now, I just want to throw an error if there isn't a unique solution.
15:08:20 <Olathe> Oh, there isn't one.
15:08:49 <Olathe> All of these linear things have more than one.
15:08:50 <wli> That was just some garbage test input.
15:09:13 <Olathe> You can, after all, just add the LCM to one term and subtract it from another to get a second solution.
15:09:52 <wli> { 3*x+5*y+7*z=11, 1*x+1*y+1*z=13, 4*x+2*y+1*z=17 } ---> (fromList [Eqn {lhs = fromList [("x",1)], rhs = -36}],[("z",Eqn {lhs = fromList [("x",1),("y",1),("z",1)], rhs = 13}),("y",Eqn {lhs = fromList [("x",-2),("y",-1)], rhs = -40})])
15:10:05 <wli> Olathe: That system has a unique solution.
15:10:28 <Olathe> Sure.
15:11:08 <Olathe> That has zero unknowns.
15:11:15 <Olathe> The one you had before had two.
15:11:24 <Olathe> So, it has infinite solutions.
15:12:01 <Olathe> Or zero if the constant term isn't a multiple of the GCD of the other coefficients.
15:13:22 <wli> I was cranking out a more general integer linear equation solver than strictly necessary for my problem. For my immediate purposes, throwing an error when there isn't precisely one solution is all I need. I'd sort of like to make it more general, though.
15:14:20 <L11> Olate: Im tinkering with the code you provided above for roman, what does "xxs@((a, b):xs)" do exactly?
15:14:28 <L11> *olathe
15:15:19 <pumpkin> "if I am provided with a list containing at least one element that is a pair, bind a to the first element of the pair, b to the second element, xs to the tail of the list, and xxs to the entire list"
15:15:38 <Olathe> > let f xxs@((a, b):xs) = "xxs = " ++ show xxs ++ ", a = " ++ show a ++ ", b = " ++ show b ++ ", xs = " ++ show xs in f [[("M", 1000), ("CM", 900), ("D", 500), ("CD", 400), ("C", 100), ("XC", 90), ("L", 50), ("XL", 40), ("X", 10), ("IX", 9), ("V", 5), ("IV", 4), ("I", 1)]
15:15:39 <lambdabot>   <no location info>: parse error on input `;'
15:16:17 <L11> hm ok so what does the xxs@ mean? I take it, it says to gather this information for xxs?
15:16:54 <Botje> "bind this to xxs"
15:16:55 <rainmann> L11, it is an as-pattern; it assigns xxs to the pattern that follows
15:17:17 <L11> ah, alright - what I figured, but wanted to make sure :)
15:17:18 <L11> thanks
15:17:49 <Olathe> > let f xxs@((a, b):xs) = say $ "xxs = " ++ show xxs ++ ", a = " ++ show a ++ ", b = " ++ show b ++ ", xs = " ++ show xs in f [("IX", 9), ("V", 5), ("IV", 4), ("I", 1)]
15:17:50 <lambdabot>   xxs = [("IX",9),("V",5),("IV",4),("I",1)], a = "IX", b = 9, xs = [("V",5),(...
15:17:57 <Olathe> There we go.
15:19:29 <wli> Oh crap I do need to solve when the solutions aren't unique in another case, or otherwise figure out mixed systems of equalities and inequalities.
15:20:10 <L11> ah alright i understand it now, thanks Olathe :)
15:20:41 <Olathe> L11: You're welcome.
15:22:26 * wli may have to punt this one out to another day.
15:23:48 <wli> The algebraic division problem was the case for unique solutions, but this one weird summation needs the indices enumerated.
15:23:50 <thorkilnaur> wli, You may want to look at Knuth, TAOCP, vol 2, Seminumerical Algorithms, section 4.5.2: The GCD
15:25:26 <wli> thorkilnaur: In storage, like the rest of everything. I don't believe it has much coverage of integer linear equations beyond the two-variable Bezout.
15:28:41 <thorkilnaur> wli, Oh, it does: "The ideas underlying Euclid's algorithm can also be applied to find a general solution in integers of any set of linear equations with integer coefficients." This is p. 303 of the 1st edition.
15:29:12 <thorkilnaur> wli, And Knuth proceeds to demonstrate how.
15:29:26 <wli> thorkilnaur: Sounds like I should hold out until I dredge it out of storage.
15:32:19 <gwern> byorgey: you slacker, no quotes this week?
15:32:53 <gwern> byorgey: also, http://lukepalmer.wordpress.com/2009/03/04/new-game-spacebattle/ doesn't actually have anything to do with haskell
15:33:27 <wli> I'm running out of time. I need to get to the hospital to visit.
15:35:20 <augustss> no quotes?!?
15:35:29 <augustss> it's an outrage!
15:35:35 <wli> (for the algebraic integer case, the equations should always be fully determined, and should be considered insoluble if not solvable in integers)
15:37:22 <wli> For the more general algebraic case over Ratio Integer, I shouldn't have to pivot near as much.
15:37:50 <gwern> augustss: I'd suggest impeaching byorgey but there's no quorum here for't
15:37:59 <augustss> wli: would you need to pivot at all?
15:38:19 <wli> augustss: Just to avoid zeroes, but that's about it.
15:38:36 <ddarius> gwern: We can't do that unless you want to take over HWN.
15:39:38 <gwern> ddarius: perhaps a motion to censure would be more appropriate, in light of byorgey's past civic service
15:41:01 <shapr> Live from New York... It's Saturday Night!
15:41:07 * shapr cheers
15:41:53 <monochrom> Remember to adjust clocks tonight.
15:42:06 <ddarius> Uh, oh!  sigfpe on ends
15:42:12 <augustss> coends
15:42:40 <ddarius> He doesn't cover ends as well?  What kind of laziness is this?
15:43:11 <augustss> According to his twittering his time was up. :)
15:45:37 <gwern> maybe if he wasn't twittering he'd've'd the time
15:46:19 <ddarius> gwern: I'.
15:46:27 <augustss> He's probably out running 100 miles or something.
15:46:47 <gwern> ddarius: ?
15:47:32 <ddarius> gwern: I was taking your excessive use of contraction marks to the logical extreme.
15:48:04 <gwern> I disagree, I was merely compressing, but your example is not lossless
15:48:41 <gwern> ddarius: and I could have gone even further - I left the 'the' unmolested, for example!
15:48:53 <gwern> (to make my point in th'main)
15:49:09 <gwern> (if you follow 't)
15:52:52 <monochrom> Please don't play golf games on English. Restrict it to Haskell.
15:53:56 <idnar> Golflish
15:54:00 <ddarius> @free fix
15:54:01 <lambdabot> f . g = h . f => f (fix g) = fix h
15:55:05 <monochrom> Nice, it knows the fusion rule!
15:57:00 <zachk> function <some-symbol>(Data x y z t)=... what is some symbol to do a named match
15:57:22 <aempirei> whats up hilarious haskell people
15:58:00 <L11> when using as-pattern matching, how should I setup my type?
15:58:06 <zachk> the sky is always up unless you are upside down but then the downside would be up or wouldnt the sky still be up it is just you who are upside down
16:01:35 <mjb> zachk: Are you looking for "@"?
16:02:50 <Zao> > let f x@(Just y) = y in f (Just 42)
16:02:51 <lambdabot>   42
16:05:08 <dons> gwern: can you try http://hackage.haskell.org/cgi-bin/hackage-scripts/package/binary-0.5.0.1
16:08:34 <ImInYourMonad> http://www.puffinwarellc.com/p3a.htm <- a brilliant tutorial on Singular Value Decomposition, but can someone tell me where he gets 148 from?
16:15:00 <Zao> ImInYourMonad: It's the squared length of the vectors?
16:17:41 <ImInYourMonad> which vectors exactly?
16:18:41 <Zao> ImInYourMonad: HoleDifficulty and PlayerAbility in the table above.
16:19:05 <Zao> The length of HoleDifficulty is sqrt(148) and the length of PlayerAbility is sqrt(3)
16:21:07 <Zao> So in the following composition you have a normalized column vector, a scale factor that are the unnormalized lengths summed together, and a normalized row vector.
16:21:17 <jberryman> I'm looking for something like quickCheck but I want to use it for profiling so I want to be able to reproduce the same random tests. is there anything for that?
16:23:34 <Saizan> jberryman: depending on how quickcheck is written you might get away with setting the IO random seed at the start to some fixed value
16:24:46 <Saizan> jberryman: with setStdGen
16:24:56 <augustss> Doesn't QC2 have something for repeatable tests?
16:27:21 <Saizan> it appears so: runATest :: State -> (StdGen -> Int -> Prop) -> IO Result
16:27:30 * Saizan has never used QC2
16:28:59 <augustss> QC2 has shrinking.  Just that makes it worth using.
16:30:24 <sanity> newbie question:  why won't this attempt to define a function (called "dampb") work : dampb x lr = x + lr*(1-x)
16:30:45 <sanity> I get the error "Occurs check: cannot construct the infinite type: a = a -> a -> a"
16:31:12 <augustss> > let dampb x lr = x + lr*(1-x) in 1
16:31:14 <lambdabot>   1
16:31:18 <augustss> Works fine
16:31:49 <augustss> Maybe you're using it wrong?
16:32:19 <sanity> augustss: hmm
16:32:26 <centrinia> sanity, Where did you use dampb?
16:32:31 <sanity> augustss: well, I'm defining it in a file, not using let
16:32:45 <augustss> sanity: makes no difference
16:33:02 <sanity> here is the entire file: http://gist.github.com/75514
16:33:33 <sanity> and here is the error ghci gives me: http://gist.github.com/75516
16:33:52 <augustss> sanity: (n-1)
16:33:55 <centrinia> sanity, Put parentheses around n-1 in the last line.
16:34:22 <sanity> augustss: ah
16:34:47 <augustss> sanity: without type signatures you don't always get the type error exactly where the real error is
16:35:01 <sanity> augustss: i see, ok - many thanks :-)
16:35:16 <sanity> augustss: BTW - what is a good IDE for Haskell?  I'm using Emacs with haskell-mode
16:35:31 <augustss> sanity: that's what I use too
16:35:48 <augustss> But I'm an Emacs user in general
16:36:30 <m0nkfish> i'm just starting out with emacs
16:36:33 <m0nkfish> im getting nowhere lol
16:36:38 <m0nkfish> im too used to regular ides
16:39:07 <thoughtpolice> <3 emacs
16:39:25 <thoughtpolice> ctags+sml-mode plus some mlton stuff has already made life much easiera
16:41:36 <m0nkfish> im still confused by ctrl+z minimizing
16:41:39 <m0nkfish> its so annoying
16:41:43 <m0nkfish> :<
16:43:27 <augustss> yes, it is.
16:43:38 <Eridius> ctrl-z is the standard suspend character for terminals
16:43:51 <bremner> m0nkfish: You can rebind it
16:44:08 <m0nkfish> yeah i havent figured out rebinding yet
16:44:24 <m0nkfish> ive heard emacs can take ages to set up
16:44:38 <Eridius> switch to yi ;)
16:44:45 <augustss> there is no end to things you can learn about Emacs
16:45:12 <ImInYourMonad> i see, i shoulld have figured thta out if irea dbetter
16:45:55 <Raevel> m0nkfish: it only takes forever to set up if you want to change everything
16:55:34 <FunctorSalad> hmm... is there some class for monoid/group/whatever actions already that I'm missing? "class Act a b where act :: a -> b -> b"
16:56:17 <FunctorSalad> geometrical transformations and objects would be a common case
16:57:56 <FunctorSalad> not sure if the abstraction would really be of much use :)
16:58:01 <Eridius> FunctorSalad: it seems like any relevant transformation would want its own name
16:59:12 <Eridius> plus, I don't think that would even work. such a transformation is only defined for a specific pair of two types
17:00:25 <L11> I'm passing in a value, how can I check that this value is in fact set?
17:00:31 <FunctorSalad> Eridius: what about a = 2-dimensional affine transformations, b = circle,rectangle,curve, ....
17:00:44 <L11> in C I would do like if(x) { // . . . }
17:00:52 <FunctorSalad> Eridius: (so I don't think it'd be confined to single pairs)
17:00:56 <L11> not sure how to do that in haskell? Can I pass in NULL?
17:00:58 <Eridius> L11: you'd have to define what it means by "set". What type is the value?
17:01:14 <mmorrow> instance Act (a->a) a where act = id
17:01:22 <FunctorSalad> mmorrow: yeah ;)
17:01:31 <Eridius> FunctorSalad: in that case you'd want a class AffineTransformable b
17:02:31 <Eridius> well I dunno. I'm still having trouble wrapping my brain around this stuff ;)
17:02:32 <FunctorSalad> Eridius: you could also instantiate it for, say, a any matrix type from one of the different matrix packages on hackage
17:03:03 <Eridius> actually wait, a -> b -> b doesn't even work as a type for a transform
17:03:17 <Eridius> unless it just uses the type of the second arg to select the implementation and throws away its actual value
17:03:44 <Eridius> it would have to be just simply a -> b, though I don't know if you can use the return type to select an instance
17:04:02 <FunctorSalad> I'm not following what's wrong with a->b->b :)
17:04:23 <Eridius> you hava matrix of type MatrixFromPackageA and you want to convert it to type MatrixFromPackageB, right?
17:04:27 <Eridius> what would you give the function?
17:04:31 <Eridius> act myMatrix ???
17:04:34 <Eridius> what goes in ???
17:05:08 <FunctorSalad> Eridius: no, I meant you could have "instance Act MatrixFromPackA Circle", "instance Act MatrixFromPackB Circle", and so on
17:05:09 <mmorrow> an "action" is just a mapping of (a) to (Endo b)
17:05:49 <FunctorSalad> mmorrow: how is it different than any other type class? :)
17:05:57 <Eridius> FunctorSalad: I don't think you understand what I was just saying
17:06:19 <gwern> dons: I tried darcs binary just a day or two ago, I doubt a hackage binary will help much
17:06:38 <FunctorSalad> Eridius: how so? I wasn't going to convert one matrix type into another
17:07:04 <Eridius> I don't care what particular types you wanted to use it for, the general case you suggested was to convert one type to another, yes?
17:07:06 <FunctorSalad> (of course, that'd be a reasonable way to do it too)
17:07:10 <Saizan> gwern: it includes a fix from a few hours ago, afaiu
17:07:23 <Eridius> and yet your function takes values of both types, and returns a value of the second.
17:07:29 <FunctorSalad> Eridius: nope, I was arguing why AffineTransformable would be less flexible
17:07:30 <Eridius> if you're just converting, why do you need to accept a value of the second type as input?
17:07:40 <gwern> Saizan: I'm also not sure I want to undo my patches and recompile yi
17:07:40 <FunctorSalad> (unless it takes two params)
17:07:59 <mmorrow> Eridius: i like to think of an action as a mapping `a' to (b -> b)
17:08:04 <Eridius> FunctorSalad: ignore my original complaint. That was actually the exact same complaint I have now, I just didn't realize it and didn't understand my own objection ;)
17:08:05 <gwern> yi takes a very long time to compile, after all
17:08:10 <Eridius> mmorrow: what's the point of that?
17:08:16 <mmorrow> i think haskell's syntax obscurs this (slightly subtle) point
17:08:27 <Eridius> gwern: what package are you talking about?
17:08:44 <Eridius> mmorrow: I understand what you're saying, but it brings up the same question
17:08:46 <mmorrow> Eridius: consider the action of the Real numbers on pairs of real numbers
17:08:50 <gwern> Eridius: data.binary
17:08:51 <Eridius> what is the point of accepting the input of type b?
17:09:01 <mmorrow> or just the trivial case of R on R (==R)
17:09:16 <FunctorSalad> Eridius: you are thinking of something different altogether (a general "Convertible" class)
17:09:18 <Eridius> mmorrow: now I'm lost
17:09:20 <mmorrow> then the action degenerates to simply (*) in R
17:09:42 <Eridius> FunctorSalad: oooooh, I thought that's what you said. It suddenly makes sense
17:09:44 <FunctorSalad> I'm thinking of some monoid a acting on some set b
17:09:48 <mmorrow> , let act a (b,c) = (a*b,a*c) in act 4 (9,8)
17:09:50 <lunabot>  (36,32)
17:10:02 <Eridius> I also now understand why you were going from Matrix to Circle ;)
17:10:13 <mmorrow> the real numbers acting on the vectorspace RxR
17:10:21 <Eridius> mmorrow: I get it
17:10:36 <mmorrow> so an action is just a generalization of (*)
17:10:45 <mmorrow> (for any particular (*))
17:10:47 <FunctorSalad> now, that class would be most useful if there are actually some polymorphic functions you could write for it
17:11:29 <FunctorSalad> mmorrow: I'm not sure what you are saying, I agreed that the type would be "a -> b -> b" in the first place :)
17:12:05 <FunctorSalad> (hmm actually that looks a lot like (:)) ;)
17:12:07 <mmorrow> FunctorSalad: i'm agreeing that that type is the type for an "action" (as it's defined) :)
17:13:22 <dons> gwern: i just uploaded a new binary
17:13:24 <Eridius> act 3 <$> (2,3)
17:13:25 <dons> Data.Binary
17:13:31 <dons> gwern: designed to fix stack issues
17:13:38 <Eridius> > let act = (*) in act 3 <$> (2,3)
17:13:40 <lambdabot>   (2,9)
17:15:26 <FunctorSalad> I guess (:) is the free action of a on [a] (disregarding infinite lists)
17:16:42 <FunctorSalad> (not that that realization would have any point)
17:17:04 <koninkje> Does anyone here know details about the base package for Hugs?
17:21:44 <FunctorSalad> hmm I guess you couldn't do a lot of polymorphic computations even with a group action unless you ask for additional finiteness/computability conditions
17:29:58 <bos> koninkje: a little, why?
17:29:58 <lambdabot> bos: You have 1 new message. '/msg lambdabot @messages' to read it.
17:31:13 <koninkje> bos: I'm needing to use unsafeCoerce which Hugs (Sept 2006) has in Hugs.IOExts, though newer versions of base have it in Unsafe.Coerce. But I'm not sure when the change happened to properly CPP it
17:31:51 <ImInYourMonad> how do I generate a list of size X with randomized Ints between 1 and 5 both inclusive?
17:32:10 <bos> koninkje: oh, messy.
17:32:12 <monochrom> something about randomRs
17:32:26 <Eridius> probably with replicateM
17:33:12 <koninkje> bos: yeah. The Unsafe.Coerce module is nice for wrapping ghc, nhc, and hugs all into one; but I don't know when that started
17:33:13 <Eridius> > replicateM 10 $ randomRIO (1, 5)
17:33:14 <lambdabot>   * Exception: "<IO [Integer]>"
17:33:18 <dons> :t randomRs
17:33:19 <Eridius> bah
17:33:20 <lambdabot> forall a g. (RandomGen g, Random a) => (a, a) -> g -> [a]
17:33:29 <dons> > randomRs (1,5) (mkStdGen 42)
17:33:30 <lambdabot>   [2,2,3,5,2,2,4,2,4,1,1,5,2,4,5,1,3,2,4,2,2,5,3,5,2,5,1,4,4,5,5,1,3,3,2,4,5,...
17:33:36 <bos> koninkje: yeah, you've exceeded my level of detailed knowledge there.
17:33:56 <koninkje> bos: thanks anyways :)
17:34:00 <Eridius> dons: ooh, that's even beter
17:34:14 <Eridius> though I wonder why lambdabot raised an exception? The exact same expression worked in ghci
17:34:55 <dons> IO
17:34:56 <koninkje> dons: Do you happen to know which version of base/array added the numElements method to IArray?
17:35:03 <dons> mm. 6.6?
17:35:06 <dons> so hmm base 2
17:35:24 <koninkje> hmm. Hugs (Sept 2006) doesn't like it...
17:35:30 <Eridius> dons: lambdabot can't handle IO actions?
17:37:14 <Botje> correct.
17:37:28 <Botje> otherwise people here would do "> launchMissiles"
17:38:26 <tromp_> > readFile "/etc/password"
17:38:27 <lambdabot>   * Exception: "<IO [Char]>"
17:38:37 <Eridius> haha
17:38:42 <Eridius> > unsafePerformIO $ readFile "/etc/password"
17:38:44 <lambdabot>   Not in scope: `unsafePerformIO'
17:38:46 <Eridius> bah
17:39:15 <gwern> dons: dunno, using that data.binary results in yi internal errors 'Prelude.chr: bad argument'
17:41:12 <dons> oh really?
17:41:16 <dons> sjanssen: yikes
17:41:57 <dons> that would imply the on disk format changed, which i'm not sure it has
17:42:27 <Eridius> what does yi use data.binary for?
17:42:33 * gwern switches back to bytestring
17:42:45 <gwern> Eridius: don't know
17:43:00 <dons> i don't really know what gwern's issue was, but he made a lot of noise about binary this week, which i think is fixed.
17:43:02 <gwern> 'sall over the place tho
17:43:03 <Eridius> I can imagine it using such a thing for the state file, but that's only relevant when calling reloadEditor
17:43:05 <Eridius> huh
17:43:27 <gwern> dons: well, I suppose prelude.chr: bad argument is better than 'stack overflow!'
17:43:39 <gwern> at least some of the file loads this way
17:44:07 <dons> well your state file might be broken for other reasdons
17:44:12 <dons> that aren't my fault
17:44:33 <Eridius> the state file is only used when you pass --resume to yi, which only happens in reloadEditor, right?
17:44:44 <gwern> no, it loads just fine with the bytestring version
17:44:59 <Eridius> ooh, upgrading the binary package to 0.5.0.1 causes a build failure in yi
17:45:15 <dons> gwern: what does that mean?
17:45:18 <gwern> Eridius: yi's state file is different from my ireader mode's serialized file
17:45:18 <Eridius> Yi/Editor.hs:67:14:    No instance for (Binary (PL.PointedList (PL.PointedList Window)))      arising from a use of `get' at Yi/Editor.hs:67:14-16
17:45:23 <dons> youre trying to load the same file with two different parsers?
17:45:34 <dons> aren't they going to be entirely incompatible? i.e. you'd expect binary to fail?
17:46:15 <gwern> my understanding was that seq bytestring and seq string serialized to the same thing
17:46:19 <gwern> they certainly look the same...
17:46:31 <dons> i don't believe that to be stated anywhere
17:46:34 <dons> if it does, it is by accident
17:47:06 <gwern> I don't really know how they could serialize to differne thing s - string versus bytestring is just in haskell land, how could they be different on disk?
17:47:56 <TomMD> gwern: String serializes as a list.  Word64 | elem | elem | ...
17:48:23 <Eridius> oh hey, build failure is probably because pointedlist-0.3.1 is still using binary 0.5
17:48:45 <aempirei> is a morphism from an object to a type the same thing as a dependant type in a lang that has first class types
17:48:59 <gwern> TomMD: no strings serialize as "foo"
17:49:01 <dons> gwern: there's nothing in common here
17:49:12 <dons> and you're saying crazy things.
17:49:13 <gwern> not ['f', 'o' or whatever silliness you're suggesting
17:49:23 <aempirei> and by object i mean the category theroy object not an oop object
17:49:35 <dons>     put l  = put (length l) >> mapM_ put l
17:49:35 <dons>     get    = do n <- get :: Get Int
17:49:35 <dons>                 getMany n
17:49:41 <dons> for lists
17:49:55 <dons> Chars get utf8 encoding
17:50:08 <dons> so String will be a length prefixed sequence of utf8 encoded thingies
17:50:38 <dons> bytestrings are just length prefixed, then the raw bytes are written directly
17:51:23 <Eridius> so basically, if your bytestring contains UTF-8 then it will be the same
17:51:35 <Eridius> well, actually does Char do any normalization?
18:01:46 <aempirei> man im on my way to camping right now
18:02:07 <aempirei> and i got a few lbs of organic clemintine oranges
18:02:13 <aempirei> they are so delicious
18:06:50 <FunctorSalad> trying to learn c2hs... in the examples distributed with it, the Makefile dies while doing Pointer.hs
18:07:15 <FunctorSalad> Pointer.chs:51:2: `aColourPoint' is not a (visible) method of class `APointClass'
18:07:25 <FunctorSalad> (and another method error for the same class)
18:07:57 <mmorrow> aempirei: clementines rule
18:10:39 <jberryman> I'm getting a bunch of "undefined reference to" errors when trying to compile a module I'm working on. ghci loads it fine. what does this mean?
18:11:13 <aempirei> yea they do
18:11:14 <MyCatVerbs> jberryman: --make ?
18:11:36 <aempirei> who in here is in sf
18:11:42 <aempirei> and wheres newsham
18:11:59 <mmorrow> @vixen a/s/l
18:11:59 <lambdabot> 19/f/California
18:12:04 <aempirei> sexy
18:12:39 <jberryman> MyCatVerbs: doh! thanks. I guess I've never tried to compile something that needed that
18:15:27 <Eridius> aempirei: I'm in sf
18:15:41 <MyCatVerbs> jberryman: I've never tried to compile anything without it. :)
18:16:00 <aempirei> did u go to the sweet haskell party oj thursday
18:16:02 <aempirei> on
18:16:32 <aempirei> wait i think u already said u didnt
18:16:40 <Eridius> was it you who was talking about that?
18:16:45 <Eridius> didn't you say you didn't even know where you heard about it?
18:16:51 <Eridius> because I still haven't found out
18:16:51 <aempirei> ya
18:16:54 <aempirei> oh
18:17:00 <aempirei> thewres a list
18:17:04 <aempirei> 1 sec
18:18:24 <aempirei> bahaskell@googlegroups.com
18:19:11 <Eridius> ooh
18:19:16 <aempirei> its fatally dorky but the people are enthusiastic
18:19:20 * Eridius hits Join
18:20:24 <Eridius> hrm, I wonder why I never saw http://www.reddit.com/r/haskell/comments/7ysaz/announcing_the_bay_area_haskell_users_group/
18:20:56 <koninkje> (Matt Hellige)++ http://matt.immute.net/content/pointless-fun
18:21:13 <sjanssen> dons: let me check
18:22:22 <MyCatVerbs> aempirei: "fatally dorky" is a bonus.
18:23:02 <aempirei> haskell preole and language enthusiasts are like stoners
18:23:27 <Eridius> duuuuuuude did you see that huuuge pointfree expression I constructed last night?
18:23:46 <sjanssen> dons, gwern: not a compatibility change, I think
18:23:58 <sjanssen> gwern: ByteString uses no encoding, Char uses UTF-8
18:24:03 <sjanssen> these things are not compatible
18:24:34 <aempirei> nexactly
18:24:39 <aempirei> eridus exactly like that
18:25:16 <aempirei> the tiniest conceptual things are percieved as larger than life
18:25:37 <FunctorSalad> interesting observation
18:28:12 <FunctorSalad> aempirei: also, both haskell and pot are frowned upon by the realworldsy types ;)
18:29:32 <dons> aempirei: do you have a coherent haskell question?
18:31:00 <Eridius> aempirei: the tiniest conceptual things still stretch people's brains, and it's the unfamiliar feeling of having your brain being stretched that makes people go wow
18:37:56 <aempirei> i dont have a haskell question. so if a coherent haskell question is a question then i dont otherwise i may
18:37:56 <aempirei> Maybe question
18:37:56 <sjanssen> aempirei: I think what dons is getting at is that we try to keep discussion in #haskell on topic.  Oranges and camping aren't really related to Haskell :)
18:37:56 <aempirei> i guess i now have a meta metaquestion in regards to haskell, am i allowed to hang out here and talk about objects in the neighborhood of haskell
18:37:56 <sjanssen> aempirei: I think #haskell-blah is what you're looking for
18:37:57 <aempirei> ah cool
18:37:57 <aempirei> thanks
18:37:57 <Eridius> uh, is dons speaking? from what people are saying it sounds like he is, but I don't see anything
18:37:57 <monochrom> yes
18:37:57 <Eridius> why don't I see anything??
18:38:00 <Eridius> my client doesn't even have an /ignore function, so I guarantee it's not that
18:38:05 <monochrom> Insufficient data for a meaningful answer.
18:38:20 <aempirei> yes he was askingn if i had a coherent haskell question nut i think he meant did i have one that he could personally understand
18:38:35 <Eridius> hrm
18:38:40 <aempirei> but sjanssen gave me some useful info
18:41:46 <dons> wacky night in #haskell, i guess.
18:41:52 <Eridius> whoa, I just saw that
18:42:03 <dons> whoa.
18:42:10 <quylui> whoah, i just got here, what happened?
18:42:12 <Eridius> whoa, I know Kung Fu
18:42:13 <dons> its like the computer is transmitting my thoughts to your screen!
18:42:23 <Eridius> quylui: for some reason I couldn't see dons's speech for a little while
18:42:26 <Eridius> now it's working again
18:42:36 <quylui> glitch in the matrix it seems
18:43:01 <FunctorSalad> halp I'm trapd in a text box
18:43:24 <mauke> ESC
18:43:49 <MyCatVerbs> sjanssen: er, Char does not use UTF8. Char is UCS-4. Things like System.IO.UTF8 convert between byte-valued UTF8 [Char]s and UCS-4 [Char]s. No/
18:44:12 <dons> MyCatVerbs: he's referring to the utf8 encoding Data.Binary does
18:44:31 <Eridius> UCS-4? interesting choice. Why not UTF-16?
18:44:43 <mauke> because UTF-16 is made of fail and fail
18:44:53 <Eridius> is that so?
18:45:01 <mauke> that is, it combines the disadvantages of UTF-8 and UTF-32
18:45:04 <sjanssen> MyCatVerbs: I am referring to the format Data.Binary uses for Char
18:45:07 <MyCatVerbs> Eridius: because one codepoint per list element is easier to deal with.
18:45:22 <MyCatVerbs> sjanssen, dons: ah, my bad. Didn't have a clue. Thanks.
18:45:43 <Eridius> except UCS-4 doubles the size of your data, and yet it's quite uncommon to use codepoints that require two UTF-16 characters
18:45:50 <MyCatVerbs> Eridius: or, one list element per codepoint, is what I'm after.
18:46:00 <mauke> Eridius: and UTF-16 doubles the size of my data
18:46:03 <sjanssen> MyCatVerbs: but it is not right to say that Char is UCS-4.  Encoding is a property of bytestream formats, Char is an abstract thing
18:46:04 <dolio> mauke: What's that? Wastes more space but still has to do fancy encoding?
18:46:10 <Eridius> mauke: only if your data is all ASCII
18:46:13 <mauke> Eridius: it is
18:46:25 <Nafai> shapr!
18:46:26 <Eridius> mauke: well, it's not uncommon to have non-ASCII data :P
18:46:30 <mauke> dolio: yes, wastes space without allowing easy indexing
18:46:39 <MyCatVerbs> Eridius: yes. [Char] puts ease of use before performance. There's a nice stream-fusing UTF16 library in the works, though.
18:46:43 <sjanssen> mauke: that point is controversial, many platforms have gone with UTF-16 and claim there are many advantages
18:46:47 <shapr> Nafai!
18:46:50 <Eridius> you can use easy indexing as long as you're willing to treat each UTF-16 character as a separate element
18:46:56 <mauke> those platforms are windows and therefore disqualified
18:47:01 <Nafai> shapr: How's it going?
18:47:12 <MyCatVerbs> sjanssen: well... there isn't any other sane way of implementing Char, and it doesn't hurt to think of it that way.
18:47:15 <Eridius> Cocoa uses UTF-16 internally, and test show that two composed UTF-16 characters show up as length 2
18:47:18 <mauke> Eridius: so just use UTF-8
18:47:33 <Eridius> mauke: err no, you can't extend the argument like that
18:47:38 <mauke> you can use easy indexing as long as you're willing to treat each UTF-8 byte as a separate element
18:47:48 <Eridius> UTF-8 loses all the benefits of UTF-16 without gaining anything except better size for ASCII storage
18:47:57 <mauke> it works perfectly fine for all unicode characters < 128
18:48:05 <Eridius> each UTF-8 byte cannot be treated as a separate element. That just plain doesn't work
18:48:15 <sjanssen> mauke: way more than that.  OS X, Qt, Java, the list goes on
18:48:23 <Eridius> it does with UTF-16 because UTF-16 is designed such that when you need composed characters, each character is still a valid codepoint
18:48:25 <mauke> sjanssen: java is also fail
18:48:30 <wli> Eridius: That's considered a big factor.
18:48:37 <MyCatVerbs> Eridius: neither can each pair of bytes in UTF-16. UTF-8 does have the wonderous property that you don't need to worry about endian-ness.
18:48:38 <mauke> Eridius: er, how is e.g. 156 not a valid codepoint?
18:48:51 <Eridius> mauke: what?
18:48:59 <gwern> @quote value
18:48:59 <lambdabot> monochrom says: recursive directory search is an alpha-beta with boring values of alpha and beta.
18:49:08 <gwern> @quote cost
18:49:08 <lambdabot> newsham says: C programmers know the cost of everything and the value of nothing.
18:49:11 <mauke> Eridius: each byte of a UTF-8 characters is still a valid codepoint
18:49:15 <mauke> -s
18:49:22 <canadaduane> Good evening...
18:49:22 <Eridius> MyCatVerbs: actually it does. Each pair of bytes in UTF-16 is a valid codepoint. The only restriction is anything which emits a UTF-16 stream must not emit half of a codepoint pair without the other half
18:49:27 <gwern> hee hee. wonder if the original perlism is in there
18:49:29 <MyCatVerbs> Eridius: admittedly that's only useful when serializing and deserializing, but still. You have nothing to lose but your byte order marks!
18:49:32 <gwern> @quote cost of nothing
18:49:33 <lambdabot> No quotes for this person. You type like i drive.
18:49:36 <Eridius> but you can disregard that when manipulating a pre-existing stream
18:49:45 <gwern> @quote cost.*of.*nothing
18:49:45 <lambdabot> AlanPerlis says: A LISP programmer knows the value of everything, but the cost of nothing.
18:49:53 <canadaduane> does anyone know of a vrml parser in haskell?  e.g. create a data structure from a ".wrl" file?
18:49:58 <gwern> (guess so)
18:50:47 <canadaduane> or for that matter, a way to load 3d point data from any format at all?
18:51:45 <tromp_> > iterate (/2) 1
18:51:46 <lambdabot>   [1.0,0.5,0.25,0.125,6.25e-2,3.125e-2,1.5625e-2,7.8125e-3,3.90625e-3,1.95312...
18:51:59 <shapr> Nafai: Life is good! I'm in Times Square.
18:52:01 <MyCatVerbs> Eridius: ah, no? One half of a surrogate pair does not on its own encode a valid codepoint.
18:52:12 <Eridius> yes it does
18:52:21 <Nafai> shapr: Awesome!  I hope to see that someday!
18:52:24 <Eridius> there's a range of codepoints that are explicitly marked as surrogate pair codepoints
18:52:28 <shapr> It's blinding!
18:52:30 <gwern> times square is overrated
18:52:37 <gwern> it's annoying, is what it is
18:52:43 <shapr> gwern: it's really shiny too!
18:53:17 <gwern> yes, that's the annoying part. it's the epitome of intrusive advertising
18:53:18 <MyCatVerbs> Eridius: no, there's a range of codepoints that are explicitly marked as reserved for surrogate pairs. On their own, they do not encode characters!
18:53:29 <gwern> the only way to maintain one's sanity is to concentrate on the technical aspects
18:53:30 <Eridius> MyCatVerbs: who's talking about characters? We're talking about codepoints
18:53:31 <shapr> Anyway, I'm in Times Square with Lemmih, so it's especially cool..
18:53:34 <gwern> like the BSODs :)
18:53:53 <Eridius> I already said, a valid UTF-16 stream emitter must not emit half of a surrogate pair without the other half.
18:54:10 <Eridius> but that doesn't mean the individual codepoint isn't valid
18:54:26 <MyCatVerbs> Eridius: right, so. Getting back to the point.
18:54:43 <ddarius> > chr maxBound
18:54:44 <Eridius> which point?
18:54:47 <gwern> 'Whenever two programmers meet to criticize their programs, both are silent.'
18:54:48 <lambdabot>   * Exception: Prelude.chr: bad argument
18:54:55 <Eridius> > maxBound :: Char
18:54:57 <lambdabot>   '\1114111'
18:55:06 <MyCatVerbs> Eridius: why UCS-4 is a sane choice for character encoding.
18:55:19 <Eridius> > fromEnum (maxBound :: Char)
18:55:19 <lambdabot>   1114111
18:55:20 <Eridius> hah
18:55:40 <rian> whoa large room
18:55:44 <MyCatVerbs> Eridius: if you use lists of UTF-16s, then something like (take 5 string) would potentially give you a string with only one half of a surrogate pair in it, rather than do what you wanted, which is to take the first five characters.
18:56:03 <Eridius> depends on how you define character
18:56:11 <rian> quick q to anyone, what is more correct to import in haskell, import IO or import System.IO
18:56:17 <MyCatVerbs> Eridius: if you use lists of UCS-4, then that still won't handle diacritics properly, but it'll blow up in fewer cases.
18:56:22 <MyCatVerbs> rian: System.IO these days.
18:56:26 <rian> same with import Monad vs import System.Monad
18:56:31 <Eridius> System.IO
18:56:31 <sjanssen> rian: System.IO
18:56:32 <monochrom> godawful semantics
18:56:38 <rian> MyCatVerbs: thanks
18:56:41 <mauke> Control.Monad
18:56:47 <rian> mauke: right oops :)
18:56:50 <sjanssen> rian: IO is the old name from Haskell '98.  In general, prefer the name with the '.' in it
18:57:00 <gwern> smaller modules
18:57:03 <rian> sjanssen: is there a document that describes this shift?
18:57:12 <Eridius> MyCatVerbs: that's not a good enough justification to double the size of Char
18:57:17 <rian> from the old haskell 98 to now
18:57:24 <mauke> Eridius: yes, it is
18:57:24 <MyCatVerbs> Eridius: in Haskell, you may as well use UCS-4, because as it's implemented, the size of a Char is enormous anyway.
18:57:27 <sjanssen> rian: hmm, not that I'm aware of
18:57:37 <Eridius> as has already been said, lots of languages (including extremely popular ones like Java) use UTF-16 for strings, and yet you don't hear anybody saying that's a problem
18:57:46 <mauke> Eridius: a language's basic string type should not expose any encoding details
18:57:49 <gwern> sjanssen: what about the appendix to the '98 report on hierarchical modules?
18:58:04 <mauke> Eridius: I think you will hear me complaining loudly about how that sucks
18:58:06 <rian> gwern: thx
18:58:21 <MyCatVerbs> Eridius: specifically, consider the string, "a". It consists of one list cell, with a one word header, a one word data pointer, and a one word tail pointer, pointing to [].
18:58:26 <rian> thx http://www.haskell.org/hierarchical-modules/
18:58:46 <MyCatVerbs> Eridius: the Char value it points to has a one word header, and one word of data storing the character itself.
18:59:03 <Eridius> huh, I never realized it was quite that space-inefficient
18:59:09 <Eridius> I guess that's why ByteString exists
18:59:20 <MyCatVerbs> Yeah, it basically sucks. This is why ByteString exists, and why Data.Text is being written.
18:59:36 <mauke> I'm afraid of looking at Data.Text :(
18:59:43 <monochrom> Insufficient users of Java programs use non-European languages for you to conclude "no one complains".
18:59:44 <Eridius> what is Data.Text using?
18:59:45 <sjanssen> gwern: it specifies the new syntax, but not the new module names
19:00:09 <MyCatVerbs> But it's more or less necessary(*) for some of the nicer parts of Haskell's semantics. The header words, for example, are needed for boxing, otherwise we can't have laziness.
19:00:10 <sjanssen> it is a little bit scary those aren't in any standard
19:00:14 <Eridius> monochrom: really? Nobody in Europe or Asia uses any Java programs? Or OS X programs? Or, hell, Windows?
19:00:28 * Eridius notes Windows, ever since 2000, uses UTF-16 as its native internal text encoding
19:00:35 <ddarius> Technically, using . for hierarchical modules isn't in any standard either.
19:00:57 <MyCatVerbs> (* for certain values of "necessary". Specifically, it's thought of as being as good as necessary now, but if you came up with good way that didn't need so much overhead then you could publish a nice paper and SPJ would be impressed)
19:00:58 <monochrom> I mean, just wait a few more years for 20% of the Chinese population to own computers. Then all your English-centric worldview will not matter.
19:01:00 <sjanssen> ddarius: at least there's a draft addendum document
19:01:06 <dancor> is it stupid to have a BoardGame class that data Go,Chess,Hex,etc are instances of
19:01:24 <Eridius> SPJ?
19:01:40 <Eridius> monochrom: what exactly do you think all the European and Asian people are using today?
19:01:40 <MyCatVerbs> Eridius: peyton `simon` jones. :)
19:01:46 * wli is expecting a slightly different trajectory for personal computer ownership for certain reasons.
19:02:02 <Eridius> ah
19:02:03 <gwern> dancor: not really, but I'd submit the name is misleading - not all board game are turn-based 2-player perfect-knowledge games
19:02:06 <cinchapps> chinese have these really huge keyboards with like a million keys --
19:02:10 <cinchapps> :P
19:02:17 <mauke> I use UTF-8
19:02:28 <dancor> mm
19:02:34 <Eridius> hmm, Data.Text uses packed Word16 arrays
19:02:36 <MyCatVerbs> Eridius: also, AFAIK, it's actually impossible in the current implementation for a boxed value to take less space than one machine word! Hence, a *boxed* Word16 takes as much room as a boxed Word32, on a 32-bit or wider architecture.
19:02:45 <Eridius> huh
19:03:07 <sjanssen> @src Word8
19:03:07 <lambdabot> Source not found. Maybe if you used more than just two fingers...
19:03:14 <Eridius> ,src ''Word8
19:03:15 <ddarius> MyCatVerbs: That's the case by the very meaning of "boxed"
19:03:18 <lunabot>  data Word8 = W8# Word#
19:03:21 <shapr> @quote jlouis
19:03:22 <lambdabot> jlouis says: Q: When does one know he has programmed too much Haskell? A: When he uses == and /= in everyday IRC chat or when he tries to fix a relationship by passing himself as a continuation
19:03:33 <MyCatVerbs> Eridius: I'm not certain about that one, though. I'd have to poke some of GHC's implementors, but there are a few in here and none have contradicted me yet. :)
19:03:46 <Eridius> heh
19:04:04 <dancor> "everyday IRC" -> when you have used irc too much
19:04:11 <ddarius> MyCatVerbs: Your statement is tautological.
19:04:19 <Eridius> ok, you make  good arguments for why the size of UCS-4 is irrelevant for Char. So I concede that there's no downside. However, I still dispute the arguments made against UTF-16
19:04:21 <MyCatVerbs> ddarius: is it?
19:04:53 <MyCatVerbs> So anyway. If Char was UTF-16 rather than UTF-32, a) we wouldn't gain anything and b) we'd actually lose, because the list cells we use for strings are larger than the boxed characters we put in 'em!
19:04:57 <Eridius> although I will also conceded that I know of one interesting bug that's caused by UTF-16 use
19:05:11 * mauke wants UTF-21
19:05:30 <Eridius> WebKit translates %234 escapes directly into UTF-16 without doing any surrogate pair checking, as documented in http://kevin.sb.org/2008/11/10/webkit-and-handling-of-surrogate-pairs-in-html-entities/
19:05:39 <Eridius> so you can produce rendering errors
19:05:53 <Eridius> *%#234; escapes
19:05:56 <ddarius> MyCatVerbs: Yes.  Boxed means represented by a pointer to a (usually heap allocated) object.  A pointer takes up as much space as a pointer does which is a machine word in most popular architectures.
19:06:10 * wli wants keyboards that make it easier to hammer in Greek, Russian, and Hebrew letters, and also real three-button mice back.
19:06:11 * Eridius wrote code that translated %#234; escapes into UTF-16 for an iPhone app, but he was smart enough to check for surrogate pairs
19:06:19 <MyCatVerbs> ddarius: not quite what I was referring to.
19:06:22 <mauke> &#234;
19:06:30 <MyCatVerbs> Eridius: so yeah, the current situation is decidedly imperfect. This is where Data.Text and Data.ByteString come in. Both use unboxed mutable buffers behind the scenes in various illegal ways, hiding all the naughty impure stuff that makes them fast behind pure APIs.
19:06:42 <Eridius> ddarius: in theory, you could have boxed values that are smaller than a word, and pack multiple values together, but then you'd have to have nonaligned pointers ;)
19:06:48 <dancor> since utf16 is still variable-width, it's not clear to me why you'd use it over utf8.  bc for certain locales the text is generally a smaller number of bytes?
19:07:02 <Eridius> dancor: because utf-16 isn't variable-width
19:07:09 <Eridius> it just has one quirk called surrogate pairs
19:07:14 <dancor> Eridius: aren't there markers that let .. yes.
19:07:20 <Eridius> utf-16 allows constant-time indexing into the string
19:07:31 <MyCatVerbs> dancor: it's smaller than UTF-8 for, say, Chinese text.
19:07:33 <mauke> Eridius: except when it doesn't
19:07:37 <Eridius> though you have to treat each half of a surrogate pair as a separate character (which all utf-16 systems that I'm aware of do)
19:07:39 <Riastradh> It allows constant-time indexing of useless units.
19:07:56 <mauke> Eridius: wait, you mean all existing utf-16 systems are broken?
19:08:16 <dancor> Eridius: how is that true that you have constant-time indexing?
19:08:17 * Eridius sighs
19:08:23 <Eridius> because every unit is 2 bytes
19:08:31 <Eridius> that's like asking how you can do a constant-time index into a char*
19:08:40 <dancor> but the surrogate pairs are _two_ 2 byte units right?
19:08:42 <mauke> it's easy to get the wrong answer in O(1)
19:08:56 <Eridius> dancor: yes, except it's a pair of characters.
19:09:01 <Eridius> I'm saying constant-time indexing into characters, not into glyphs
19:09:08 <Riastradh> Glyphs are different.
19:09:09 <Eridius> you can never have constant-time indexing into glyphs even with UCS-4
19:09:11 <FunctorSalad> so basically it achieves constant-time indexing by declaring characters out of the 16-bit range to be two chars? ;)
19:09:12 <Eridius> because of diacritic markers
19:09:19 <Riastradh> I hope you're not suggesting that glyphs are some unit of text in Unicode.
19:09:25 <dancor> yeah and utf8 has constant into bytes.  but that's not the important thing usually
19:09:31 <MyCatVerbs> dancor: AFAIK there are lots of characters in Chinese which are in the BMP (and hence take only two bytes to represent in UTF-16) but for which the UTF-8 encoding is three characters.
19:09:33 <Eridius> FunctorSalad: all unicode codepoints outside of Plane 0 are encoded as a surrogate pair
19:10:32 <mauke> hmm, new rule: if your "UTF-16" API lets you see surrogate codepoints, it's really just UCS-2
19:10:34 <sjanssen> Eridius: I don't think it is quite right to say that UTF-16 has O(1) indexing on characters.  It has O(1) indexing onto half a codepoint (or, if you're lucky, an entire codepoint)
19:10:38 <dancor> ya the only advantage i see is that space thing which has never been that compelling for me with like zip available..
19:10:44 <MyCatVerbs> dancor: er, BMP -> Basic Multilingual Plane. Basically all the characters up to and including those that got stabbed in the face during the almighty Han Unification. :)
19:10:56 <Eridius> sjanssen: actually no, it's O(1) indexing into a codepoint
19:11:07 <Eridius> codepoints outside of the BMP are represented as two separate codepoints in UTF-16
19:11:11 * dancor declares utf16 a middling encoding
19:11:24 <Riastradh> In what applications is it useful to work with the units that UTF-16 gives you, Eridius?
19:11:30 <MyCatVerbs> dancor: UTF-8 is painfully variable-width, though. Your string handling code will end up... branchy.
19:11:32 <sjanssen> Eridius: I think you're confused
19:11:33 <Riastradh> Certainly not any application that processes Unicode text.
19:11:41 <Eridius> Riastradh: err, every single text processing I have ever done has worked just fine using UTF-16
19:11:49 <Eridius> sjanssen: no, I'm not.
19:11:54 <dancor> MyCatVerbs: true.. it is ..more variable
19:11:54 <Riastradh> Surrogate code points may be called `code points', but they are not independently useful objects.
19:11:59 <sjanssen> Eridius: UTF-16 somtimes uses two Word16s for a single code point
19:12:05 <Eridius> Riastradh: who said anything about them being independently useful? They're still codepoints
19:12:09 <sjanssen> Eridius: that is what Unicode defines as a "codepoint"
19:12:10 <Zao> Riastradh: They're code units, not code points.
19:12:13 <Eridius> sjanssen: no, it uses two codepoints to represent what UCS-4 would use one codepoint for
19:12:15 <Riastradh> sjanssen, strictly speaking, Eridius is correct: a surrogate code point is still a code point.
19:12:18 <mauke> every single text processing I've ever tried using UTF-16 sucked
19:12:21 <Eridius> sjanssen: there's a range of codepoints in the BMP that are reserved for surrogate pairs
19:12:30 <MyCatVerbs> Eridius: that's exactly as meaningless as saying that you can index to arbitrary bytes in constant time in a UTF-8 stream.
19:12:35 <Eridius> MyCatVerbs: no it's not!
19:12:40 <Riastradh> sjanssen, perhaps you'd be happier to talk about Unicode scalar values than to talk about Unicode code points.
19:12:41 <Eridius> you can do useful things with independent codepoints in UTF-16
19:12:43 <Zao> The individual elements in an encoding are code units, out of which one or more make up code points when decoded.
19:12:46 <Eridius> you can't with independent bytes in UTF-8
19:12:58 <monochrom> <sarcasm> If I use UTF-8, a CJK character may become 5 codepoints. That's my definition of codepoints. I still have O(1) indexing into codepoints. </sarcasm>
19:13:03 <MyCatVerbs> Eridius: yes it is. No, you can't do useful things with the halves of surrogate pairs individually in UTF-16.
19:13:06 <mauke> Eridius: the only difference is that Unicode reuses the codepoints in the range 128 .. 256
19:13:09 <Riastradh> Zao, each code unit in UTF-16 corresponds with a code point.  Some of those code points are just not useful independently, and not permitted to occur outside of UTF-16 streams.
19:13:29 <Eridius> monochrom: you can't redefine the word "codepoint" and expect to have a useful discussion
19:13:33 <Eridius> I'm not redefining the word codepoint
19:13:33 <Riastradh> Before you folks get all uppity arguing semantics, why don't you read the Unicode standard?  Chapter 3, specifically.
19:13:53 <Zao> Riastradh: Lovely book, that.
19:13:55 <Eridius> the range of codepoints U+D800 - U+DFFF are reserved for surrogate pairs
19:13:56 <Zao> Too bad no-one reads it.
19:14:27 <dancor> i think a solid grounding in information theory is just as useful for reasoning in this discussion..
19:14:29 <Zao> UTF-16 is suboptimal in that many APIs misuse it as UCS-2.
19:14:31 <Eridius> IIRC, U+D800-U+DBFF is the first half and U+DC00-DFFF is the second
19:14:46 <mauke> just because U+80 .. U+FF isn't reserved doesn't mean they can't be useful
19:14:49 <Eridius> Zao: it's not UTF-16's fault if code treats it as UCS-2's
19:15:02 <mauke> and that's why I index into UTF-8 bytestrings
19:15:25 <kiris> cabal update => Warning: No remote package servers have been specified. Usually you would have one specified in the config file.
19:15:35 <kiris> how do you specify remote package servers in cabal install?
19:15:36 <Riastradh> So, Eridius, why are you happy to index code units in a UTF-16 stream, but not happy to index code units in a UTF-8 stream?
19:15:52 <Eridius> what's a "code unit"?
19:15:57 <Riastradh> ...
19:16:12 <Zao> Eridius: As covered above, a single indexable element in a UTF sequence.
19:16:32 <Eridius> so you mean a byte in the case of UTF-8?
19:16:34 <Gracenotes> 'code point'
19:16:35 <FunctorSalad> "The encoding form maps each character to a sequence of 16-bit words. Characters are known as code points and the 16-bit words are known as code units."
19:16:40 <Eridius> because an individual byte in UTF-8 is worthless
19:16:40 <Zao> Eridius: Yes.
19:16:40 <Riastradh> I suggest, once again, that you folks read the Unicode standard.
19:16:44 <Riastradh> It might be enlightening.
19:16:56 <Riastradh> It might help to reduce miscommunication.
19:17:12 <MyCatVerbs> Riastradh: no. If you have, then just quote bits of it at people.
19:17:21 <gwern> kiris: what did you do to your .cabal/config ?
19:17:27 <FunctorSalad> I quoted from WP 'UTF-16'
19:17:27 <MyCatVerbs> Riastradh: that'll hopefully shut them up, at least until they do. ;)
19:17:33 <Zao> Text is hard, let's go shopping.
19:17:45 <Riastradh> MyCatVerbs, quoting it only encourages them not to read it.
19:18:10 <Eridius> FunctorSalad: it's using the term "code unit" to mean the encoded representation of a codepoint. It goes on to say: For both UTF-16 and UCS-2, all 65,536 code points contained within the BMP (Plane 0), excluding the 2,048 special surrogate code points, are assigned to code units in a one-to-one correspondence with the 16-bit non-negative integers with the same values
19:18:13 <MyCatVerbs> Riastradh: not if the bit you're quoting disagrees with what they're saying.
19:18:22 <Eridius> but that's fairly irrelevant
19:18:42 <Riastradh> Eridius, final question before I leave:  Why is a UTF-8 code unit any more or less valuable than a UTF-16 code unit?
19:18:51 <kiris> gwern: hmm. I made a config file to set the install dir to ~/Programs/bin and not .cabal/bin, but opening the config file now it's 57 lines of configuration. so I have no idea
19:19:04 <Eridius> to use its terminology, the point of the surrogate pair range is so that each element of the pair of "code units" that a codepoint outside of the BMP is encoded to in UTF-16 is still a valid codepoint
19:19:11 <gwern> kiris: look for a line like 'repos: hackage.haskell.org:http://hackage.haskell.org/packages/archive
19:19:20 <Eridius> Riastradh: because you can't do anything meaningful when you do a constant index by code units into a UTF-8 stream
19:19:33 <Eridius> but you can with a UTF-16 stream
19:19:36 <kiris> gwern: I have this: remote-repo: hackage.haskell.org:http://hackage.haskell.org/packages/archive
19:19:40 <Riastradh> Eridius, why are UTF-8 and UTF-16 any different in this respect?
19:19:49 <Eridius> because UTF-8 is a variable-width encoding and UTF-16 is not
19:19:51 <Riastradh> To be sure, UTF-8 has a smaller set of code units that overlap with scalar values.
19:20:02 * FunctorSalad has been wondering the same as Riastradh ...
19:20:21 <kiris> gwern: wait. sorry. I'm on two different emacs sessions, opened the wrong computer's config file >_>
19:20:25 <mauke> UTF-16 varies between 2 and 4 bytes
19:20:33 <Eridius> no it doesn't
19:20:35 <Riastradh> But both UTF-8 and UTF-16 streams contain code units that overlap with scalar values and code units that don't overlap with scalar values.  The code units that don't overlap with scalar values have no interpretation on their own.
19:20:38 <gwern> kiris: well there you go?
19:20:52 <Eridius> Riastradh: what do you mean, that overlap with scalar values?
19:21:22 <FunctorSalad> the range that is encoded as a single Word16, I suppose
19:21:40 <mauke> blargh, now I'd have to look up how U+DC01 is encoded in UTF-16
19:21:49 <Riastradh> Sorry, that was a little imprecise.  For example, the isolated octet #x80 in a UTF-8 stream has no interpretation on its own.  Similarly, the isolated code unit #xD800 in a UTF-16 stream has no interpretation on its own.
19:21:59 <Eridius> U+DC01 is a codepoint in the surrogate pair range
19:22:07 <Eridius> it's not valid on its own in *any* representation
19:22:15 <kiris> gwern: I think I know what the problem is. I created a config file before running cabal so I could tell it to install executables to the right place, presumably before cabal creates one, so it saw my file with just the line "symlink-bindir: /home/chris/Programs/bin" and thought "no need to create the file", so I had a one-line cabal config. I see now looking at my other PC's that it's supposed to have loads of entries >_> thanks
19:22:33 <Eridius> Riastradh: sure it does. #xD800 in a UTF-16 stream is interpreted as the codepoint U+D800
19:22:50 <mauke> er, you just said that codepoint is invalid
19:22:50 <Riastradh> So, I wonder where this sentence came from, Eridius:
19:22:56 <Riastradh> `Isolated surrogate code units have no interpretation on their own.'
19:23:05 <gwern> kiris: ah, that makes sense. cabal-install wouldn't do anything fancy like merging changes if it saw you had a manual config generated
19:23:13 <Riastradh> Eridius, take a wild guess where I just took that sentence from.
19:23:18 <kiris> gwern: indeed
19:23:39 <Eridius> Riastradh: it means when consuming a UTF-16 stream if you encounter an isolated surrogate code unit, what you do with it is undefined
19:23:53 <Eridius> which is why it stipulates that anything emitting a UTF-16 stream must not emit isolated surrogate pair code units
19:24:08 <monochrom> Text is too hard. Let's go chopping. :)
19:24:13 <Riastradh> I'm waiting for you to take a wild guess where I just took that sentence from.  Until you do that, I can only assume that you and I are speaking different languages.
19:24:24 <Eridius> given your earlier comments, I assume you took it from the Unicode spec
19:24:41 <Riastradh> That's right.
19:24:50 <Riastradh> Now, suppose I have a UTF-8 stream and a UTF-16 stream.
19:25:00 <FunctorSalad> I think you're disagreeing about whether a single real-life character can correspond to two codepoints
19:25:03 <Riastradh> I can index each one by assigning to each code unit in it a natural number.
19:25:13 <Riastradh> FunctorSalad, whoa!  Careful with words such as `character'.
19:25:15 <Eridius> ok, hold on. I think I can resolve the difference between UTF-8 and UTF-16 easily
19:25:24 <kiris> does anyone ever globally cabal install? I never ever want to do that
19:25:30 <mauke> kiris: yes
19:25:34 <gwern> kiris: some people do't
19:25:41 <kiris> mauke: in what cases?
19:25:42 <Eridius> if you index directly into a UTF-8 stream, you have no guarantee at being at the beginning of a logical unit (the representation of a codepoint). Nor can you even tell if you are most of the time
19:25:45 <Riastradh> What I'd like you to explain, Eridius, is why the natural number index of a code unit in the UTF-8 stream is less valuable than the natural number index of a code unit in the UTF-16 stream.
19:25:48 <FunctorSalad> (with two I mean a sequence of length two)
19:25:50 <mle> I thought utf-8 should not use surrogate pairs?
19:25:51 <mauke> kiris: in every case. I've disabled local installs
19:25:57 <Eridius> if you index into a UTF-16 stream you are guaranteed to be at the beginning of a codepoint, and what's more, you can easily detect if you're in the middle of a surrogate pair
19:25:59 <kiris> mauke: why?
19:26:23 <mle> aren't they a left-over from ucs-16?  utf-anything should make them unnecessary...
19:26:27 <Riastradh> Eridius, you are mistaken.  You can always tell, simply by examining the bits of the code unit you are looking at, where in a scalar value you are looking, in UTF-8.
19:26:29 <Eridius> mle: utf-8 actually does use surrogate pairs after a fashion
19:26:35 <mauke> kiris: because I don't need two package registries in my home directory
19:26:36 <Eridius> mle: utf-8 encodes each half of a surrogate pair using a 3-byte sequence
19:26:52 <mle> Eridius: but there is no reason to ever encode a surrogate pair in utf8
19:26:55 <kiris> mauke: which two?
19:27:04 <Eridius> mle: true, but the encoding is defined
19:27:08 <mauke> kiris: the local and the global one
19:27:14 <kiris> oh right
19:27:15 <cjb> Eridius: it's true that utf-8 loses you optimizations that a fixed-width encoding would have, but do you really want to make (almost) every character use twice as much space instead?
19:27:39 <mauke> Eridius: I bet UTF-16 also lets you encode each half of a surrogate pair as a 4-byte sequence
19:27:50 <Eridius> cjb: you only use (almost) twice as much space for English text
19:27:52 <cjb> I guess if you happen to have a use where you care very much about CPU time and not at all about memory use, go ahead and use UTF-16; no-one will stop you.
19:27:58 <Riastradh> cjb, Eridius is talking about two fixed-width encodings for code units, and two variable-width encodings for scalar values.
19:28:00 <cjb> Eridius: Right.
19:28:01 <Eridius> for non-English text, UTF-16 can easily be smaller (depending on the language in question)
19:28:05 <Eridius> mauke: err, no it doesn't
19:28:12 <mauke> that's ridiculous
19:28:13 <mle> Eridius: fixed width is kinda a lost cause
19:28:19 <Eridius> mauke: when you just start making up shit like that, it just shows that you have no idea what you're talking about
19:28:32 <kiris> mauke: so do you do all your hacking of packages with runhaskell Setup.lh* or similar? I assume the general notion is to hack on cabal packages and build them with cabal install but that could just be me
19:28:35 <mauke> Eridius: sorry, all I have is practical experience
19:28:46 <mauke> kiris: huh?
19:28:54 <mle> when you include all of the non-spacing combining marks and things like that, no amount of normalization can cause a single code-point to be enough to represent a potential "character"
19:29:20 <Saizan> kiris: seen the --global/--user flags?
19:29:20 <mle> Eridius: why do you want to deal with surrogate pairs?
19:29:30 <Riastradh> I think the term you want, mle, is `(default) grapheme cluster'.  Unicode doesn't have a term `character'.
19:29:37 <Eridius> mle: I've been waiting for someone to make a practical argument as to why surrogate pairs cause problems specifically so I could put out that combining marks cause the exact same problems in UCS-4
19:29:40 <Saizan> kiris: also user-install field in ~/.cabal/config
19:29:47 <kiris> mauke: for example, I download package X from Hackage, I build it with cabal install --user, and modify it, when I want to rebuild it to use in my programs I use cabal install --user again
19:29:48 <mle> Riastradh: exactly, thanks.
19:30:05 <kiris> Saizan: what does that do?
19:30:12 <mauke> kiris: I don't modify packages after downloading them from hackage
19:30:18 <Riastradh> There are `abstract characters', which are equivalence classes of scalar values; and there are `encoded characters', which are the associations between abstract characters and the scalar values that represent them.  Neither of these is what users tend to think of as the units of text, however.
19:30:26 <kiris> mauke: ok
19:30:26 <Eridius> mle: I don't. I want to ignore them. I have no reason to ever touch text that's not in the BMP. But if I ever was fed text that's not in the BMP, I still shouldn't have a problem
19:30:27 <ImInYourMonad> how do I pass RTS?
19:30:34 <kiris> ImInYourMonad: +RTS?
19:30:46 <ImInYourMonad> C:\ghc\ghc-6.10.1\progs\MachineLearning\Netflix>ghc --make -O2 +RTS 20000000 -ma
19:30:46 <ImInYourMonad> in-is Serialize.main Serialize.hs
19:30:51 <ImInYourMonad> then i get th options
19:31:25 <Saizan> kiris: you can use it to change the default from --user to --global, also root-cmd is useful if you need root privileges for a global install
19:31:26 <mle> Eridius: sure.  it's reasonable to Read surrogate pairs, but I'm arguing it is not reasonable to emit them except in very odd circumstances where you are trying to leave a ucs-16 stream in its original state.  They should be removed from utf-8
19:31:27 <Eridius> Riastradh: ok here we go, you said that you can always tell by looking at the bits of the current code unit in UTF-8 where you are
19:31:27 <Riastradh> Eridius, let's rephrase that a little:  `I have no reason ever to touch text that's not in US-ASCII.  But if I ever was fed text that's not in US-ASCII, I still shouldn't have a problem.'  If you treat non-US-ASCII octets in UTF-8 analogously to surrogate code units in UTF-16, you will get analogous results.
19:31:34 <FunctorSalad> ImInYourMonad: you start the compiled program with +RTS (try +RTS --help)
19:31:46 <monochrom> what is that 20000000 doing there? shouldn't there be something between +RTS and 20000000?
19:31:48 <Eridius> Riastradh: however, the 2nd, 3rd, and 4th bytes of a UTF-8 code unit all start with 0b10. Their length is determined by the first byte
19:31:56 <Eridius> err, of a UTF-8 codepoint encoding
19:32:01 <dancor> i think i'm going to call my class TurnGame and make it at least apply to n-player games like chinese checkers
19:32:03 <ImInYourMonad> -Ksize
19:32:06 <Eridius> Riastradh: no you won't
19:32:14 <ImInYourMonad> but how do I set the stacksize?
19:32:21 <dancor> i still wonder if i'm overabstracting.  but the best way to be sure about a mistake is to go thru with it
19:32:25 <Riastradh> Eridius, sorry, you're right.  It requires scanning forward or backward by at most three octets.
19:32:34 <Riastradh> (Backward, rather.)
19:32:35 <Eridius> Riastradh: exactly. But you don't have to do any scanning in UTF-16
19:32:36 <Eridius> it's constant-time
19:32:41 <ImInYourMonad> Stack space overflow: current size 8388608 bytes.
19:32:42 <ImInYourMonad> Use `+RTS -Ksize' to increase it.
19:32:45 <Riastradh> It's constant-time in UTF-8, too.
19:32:51 <Riastradh> Bounded by the small constant `3'.
19:32:54 <Eridius> no, it's fuzzy time in UTF-8
19:33:01 <Riastradh> Do you know what `constant-time' means?
19:33:04 <Eridius> ok, let me be clearer. in UTF-16 you don't have to look at any other code points
19:33:06 <Eridius> in UTF-8 you do
19:33:07 <kiris> Saizan: so cabal installs as --user and not as --global now? a while ago it used to try to globally install by default so I've always used --user.. I hack on packages so much that globally installed and all the root-nonsense isn't what I want
19:33:12 <Eridius> Riastradh: I'm not talking amortized constant time
19:33:15 <Eridius> I'm talking literally constant time
19:33:17 <Riastradh> Neither am I.
19:33:20 <Riastradh> So am I.
19:33:21 <mauke> Eridius: 3 is a constant
19:33:34 <Eridius> mauke: in UTF-8 it's you have to look 0, 1, 2, or 3 units away
19:33:34 <Riastradh> `Constant-time' does not mean that the number of steps is the same each time.
19:33:36 <monochrom> +RTS -K200000000000000
19:33:40 <mauke> Eridius: that's constant time
19:33:46 <Saizan> kiris: for cabal-install the default is --user, for runghc Setup.hs the default is still --global
19:33:56 <Riastradh> Can you define `constant-time' for me, Eridius?
19:34:02 <kiris> Saizan: hmm, cool :-)
19:34:11 <Eridius> why are we arguing about such a completely pointless thing? Stop it. you're just wasting time and ignoring the important argument
19:34:16 <monochrom> Actually +RTS -K200M may do.
19:34:20 <Eridius> which is that in UTF-8 you have to look at other code units to be sure of where you are. In UTF-16 yo udon't
19:34:21 <Eridius> *you don't
19:34:38 <mauke> how is that an important point?
19:34:47 <MyCatVerbs> mauke: yes, but no. Constant time means that the number of steps is *bounded* by some constant. The number of steps actually *being* constant is a stronger notion again. That's the distinction Riastradh is drawing.
19:34:54 <Riastradh> I'm discussing this because you are trying to make a strong technical judgement founded on what appears to be a poor understanding of the issues involved.
19:34:57 <Riastradh> This makes your judgement suspect.
19:35:02 * Cale could define constant time... if anyone cared ;)
19:35:05 <FunctorSalad> Eridius: but wouldn't you still have to scan the whole stream to find the n-th *character*? (confused by Riastradh's terminology so I will continue to use that word ;))
19:35:17 <mauke> FunctorSalad: you always have to do that
19:35:18 <Zao> Eridius: You can decide where in a code point you are in UTF-8 just by looking at the current code unit.
19:35:26 <Riastradh> FunctorSalad, the phrase you want is probably `scalar value', if you want to rule out surrogate code points.
19:35:28 <Eridius> Riastradh: you haven't pointed out a single "poor understanding" yet
19:35:32 <FunctorSalad> mauke: not with fixed width I'd think
19:35:41 <mauke> FunctorSalad: unicode is variable width
19:35:45 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2198#a2198 <- didnt work changing
19:35:46 <mle> indexing a given codepoint is an O(n) operation in both utf-8 and utf-16
19:35:56 <Cale> Constant time = number of steps taken is bounded above by a constant independent of the input.
19:35:56 <FunctorSalad> mauke: oh, it's not even limited to 2^32?
19:36:06 <Riastradh> Eridius, you have demonstrated unfamiliarity with the Unicode standard, and unfamiliarity with basic technical terms such as `constant-time'.
19:36:14 <MyCatVerbs> FunctorSalad: even with fixed width. There are ways to make up individual as-you-see-them-on-screen glyphs out of multiple codepoints. Diacritics for one.
19:36:15 <Zao> Eridius: Never mind, misremembered.
19:36:17 <Eridius> Zao: you can only know where you are when looking at a single code unit if it happens to be the start of a given codepoint sequence
19:36:24 <mle> FunctorSalad: 21bit
19:36:29 <mle> for now
19:36:30 <mauke> FunctorSalad: well, the actual bound is probably in the range of a few million
19:36:50 <mauke> bytes, that is
19:36:53 <Eridius> Riastradh: that is completely incorrect
19:37:04 <mauke> I think unicode lets you make MB-sized characters
19:37:05 <FunctorSalad> MyCatVerbs: oh, didn't know that either :)
19:37:08 <Eridius> you are assuming a different context for the phrase "constant time" than I am, a context that makes no sense
19:37:09 <Zao> You can step forward without having to traverse all code units though.
19:37:13 <Riastradh> Now, do I understand your argument correctly that the difference between UTF-8 and UTF-16 is whether a single 16-bit code unit suffices to identify one's position in a scalar value, as opposed to a maximum of four 8-bit code units?
19:37:21 <kiris> mauke: unicode facepalm here we come!
19:37:30 <Eridius> as for unfamiliarity with the Unicode standard, I am simply unfamiliar with a couple of the terms you've used
19:37:35 <MyCatVerbs> FunctorSalad: (diacritics being things like codepoints that encode "put a hat on the next character". So, put that in front of 'a' and a conforming implementation should treat it as the single character â.)
19:37:49 <mle> mauke: ...what?
19:37:52 <Eridius> Riastradh: that's *an* argument I've made
19:38:03 <mauke> mle: what what?
19:38:09 <MyCatVerbs> FunctorSalad: (one detail I'm not sure about. I don't actually know whether diacritics go before the character they affect or after. I think it's before. :))
19:38:26 <mauke> mle: ?̧̨̛̃̄̅̆̈̌̐͒
19:38:28 <Eridius> a better one is that you can't extract the nth *codepoint* from a UTF-8 sequence without scanning the entire string up to that point. However, you can do a constant-time lookup of the nth *codepoint* in a UTF-16 sequence
19:38:29 <MyCatVerbs> Eridius: funnily enough, Riastradh uses those terms because those are the terms that the unicode standard document does.
19:38:45 <Eridius> MyCatVerbs: funnily enough, not everybody has read the entire damn document cover to cover
19:38:45 <mle> mauke: the set of codepoints is fairly well defined
19:38:58 <Riastradh> What happens if I substitute the term `scalar value' for the term `code point' in your last assertion, Eridius?
19:39:10 <FunctorSalad> MyCatVerbs: I presumed all the diacritics in use were hard-wired in, as they are for the vowels (I think)
19:39:14 <Eridius> MyCatVerbs: using standard terminology is all well and good, but accusing someone else of not understanding the subject just because they aren't familiar with the same terminology is fallacious
19:39:18 <catface> why would you want the nth codepoint?
19:39:22 <mle> Eridius: but codepoints aren't that useful...
19:39:29 <Riastradh> (I'll give you a hint: it doesn't remain true!)
19:39:30 <Eridius> Riastradh: I asked you define the term "scalar value" earlier and you ignored me
19:39:32 <MyCatVerbs> FunctorSalad: they have it set up both ways.
19:39:55 <MyCatVerbs> FunctorSalad: this is why you need to normalize Unicode strings in order to compare them.
19:39:59 <Riastradh> Eridius, sorry, I missed your request to define `scalar value' in the noise of the channel.  A scalar value is the Unicode standard's term for a code point that is not a surrogate code point; in other words, a code point that has an interpretation as an abstract character.
19:40:15 <Eridius> mle: in general, yes they are. They're significantly more useful than individual bytes in UTF-8
19:40:31 <MyCatVerbs> Eridius: no, they aren't, because they might be surrogate pairs.
19:40:32 <Eridius> Riastradh: ok
19:40:41 <mauke> all bytes are equal, but some bytes are more equal than others!
19:40:42 <mle> for some things yes, but code-points are not sufficient for an editor.
19:40:52 <Riastradh> To be fair, the term `scalar value' is not used as pervasively as `code point' and `code unit' in the Unicode standard.  However, it is the concisest term by which to refer to `useful' code points, namely those that denote abstract characters.
19:41:18 <Eridius> Riastradh: if you replace "codepoint" with "scalar value" then UTF-16 has problems. I've never denied this. But you can make a similar case with UCS-16 when you try and go from scalar values to grapheme clusters
19:41:19 <monochrom> Oh! I'll stick with "scalar value" next time.
19:41:19 <MyCatVerbs> Eridius: in UTF-8, individual bytes might have values in the range 0-127 and hence be validly interpretable on their own, but that doesn't help!
19:41:24 <mle> Riastradh: are scalar values a sort of "base" for grapheme clusters?
19:41:38 <Riastradh> mle, grapheme clusters are groups of scalar values.
19:41:41 <sjanssen> hmm, so is Haskell's Char a code point or a scalar value?
19:41:41 <Riastradh> Eridius, yes, precisely.
19:41:49 <Eridius> MyCatVerbs: in UTF-8 encountering non-ACSII characters is very common. In UTF-16 encountering surrogate pairs is extremely uncommon
19:41:57 <Eridius> sjanssen: it's UCS-4
19:42:06 <MyCatVerbs> sjanssen: scalar value. It's UCS-4.
19:42:12 <Eridius> surrogate pairs are invalid in UCS-4
19:42:23 <Riastradh> Eridius, so, when you say that one encoding or another is `fixed-width' or `variable-width', you should be clear about what units have fixed or variable width.
19:42:25 <MyCatVerbs> Eridius: tell that to anyone writing in Hangul.
19:42:27 <Eridius> actually, if UCS-4 is anything like UCS-2, surrogate pairs aren't even defined
19:42:30 <sjanssen> Eridius: no, that doesn't make sense.  Char is an abstract entity, not a byte encoding
19:42:44 <Eridius> sjanssen: Char uses UCS-4 as its internal encoding
19:42:49 <sjanssen> Eridius: no, it doesn't
19:42:54 <sjanssen> it is abstract
19:43:15 <Eridius> Riastradh: that's a fair argument to make. I wish you had said that earlier instead of devolving into pointless arguments about whether bytes in a UTF-8 stream are meaningful
19:43:18 <mauke> hah, sjanssen speaks sanity
19:43:25 <MyCatVerbs> sjanssen: it does in practice, in every single implementation, and there's no other way you'd particularly want to do it. Isn't that good enough?
19:43:31 <Riastradh> UTF-8 is has fixed-width code units, encodes scalar values with variable width, and can expresses grapheme clusters with variable width.  UTF-16 has fixed-width code points, encodes scalar values with variable width, and expresses grapheme clusters with variable width.
19:43:34 <MyCatVerbs> sjanssen: s/good/close/
19:43:48 <Riastradh> UTF-32, however, has fixed-width code units *and* encodes scalar values with fixed width.  On the other hand, all three express grapheme clusters with variable width.
19:43:51 <sjanssen> MyCatVerbs: what are the bytes of "asdf" in UCS-4?  What are the bytes of said string in Haskell?
19:44:02 <sjanssen> MyCatVerbs: the only answer is "type error"
19:44:09 <Cale> "The character type Char is an enumeration whose values represent Unicode characters."
19:44:14 <Riastradh> `Char uses UCS-4 as its internal encoding' doesn't make sense.
19:44:15 <kiris> I don't care about unicode but all of this contention about describing it makes me want to read the unicode standard
19:44:15 <Cale> That's how it's specified.
19:44:17 <Eridius> Riastradh: sure, but you're completely glossing over the practicality of fixed-width codepoints in UTF-16
19:44:43 <Eridius> Cale: I wish it didn't use the term "character"
19:44:49 <Riastradh> kiris, please do.  It will make many discussions about Unicode clearer (or illustrate why they are not clear).
19:44:54 <MyCatVerbs> sjanssen: 0x00000041, 0x00000051, ...
19:44:55 <Cale> So, as far as the Report is concerned, I don't even think it specifies whether each Char is a scalar value or grapheme, or what.
19:45:15 <sjanssen> MyCatVerbs: and the bytes in Haskell?
19:45:21 <Eridius> Riastradh: my original point was that UTF-16 is the most practical encoding (for packed strings, at least)
19:45:39 <Eridius> Cale: I think the most common interpretation of "Unicode character" would be "scalar value"
19:45:43 <MyCatVerbs> sjanssen: aaaand, ((Char# 0x00000041) : (Char# 0x00000051) : ... : [])
19:45:47 <Riastradh> Eridius, so, what operations would you like to perform on UTF-16 that work better in practice than the analogous operations on UTF-8?
19:46:19 <sjanssen> MyCatVerbs: firstly that's GHC (but not actually valid syntax), and you do notice the pesky ":" in between?
19:46:28 <Eridius> how about constant-time indexing into English strings? Note that English strings can still include non-ASCII
19:46:36 <Riastradh> Cale, probably what was meant was `encoded character'.
19:46:46 <Riastradh> Eridius, what operations would you like to perform that involve constant-time indexing?
19:46:54 <mauke> Eridius: English strings can also include non-BMP
19:47:08 <Riastradh> I'm talking about genuinely random access here, by the way.
19:47:15 <Eridius> mauke: what non-BMP character will ever show up in an English language string?
19:47:16 <Riastradh> Merely advancing or retreating a cursor does not qualify.
19:47:23 <mle> Eridius: why are you worried about indexing?
19:47:28 <FunctorSalad> (is math BMP?)
19:47:30 <mauke> Eridius: every single one
19:47:34 <dancor> http://www.unicodesnowmanforyou.com
19:47:49 <Eridius> mauke: what a completely worthless argument. Thank you very much. I specified English for a reason
19:47:51 <MyCatVerbs> Eridius: er, no, because English strings occasionally include accented characters, and it's possible for those to be encoded with diacritics rather than using the accented character.
19:48:05 <MyCatVerbs> Eridius: so you are still boned.
19:48:10 <wli> FWIW Graphics.GD seems to be the big winner here.
19:48:14 <Zao> Some normalization forms encourage that kind of thing.
19:48:30 <Eridius> Riastradh: I don't know, I'm writing the library, not the application. When the specific use case is unknown, UTF-16 is the most practical because it allows for constant-time indexing into 99.999999% of text the program is likely to deal with
19:48:44 <Eridius> MyCatVerbs: that argument holds true for UCS-4 too
19:48:48 <Eridius> so it becomes irrelevant when deciding between the two
19:48:50 <Riastradh> Eridius, what library are you writing?
19:48:54 <Riastradh> For what applications does your library exist?
19:48:58 <dancor> wli: for writing png?
19:49:07 <mauke> “For example, one of the Linear B syllables looks like this: 𐀂.”
19:49:07 <MyCatVerbs> Eridius: yes. So it's irrelevant for deciding between all three. So why bring it up?
19:49:10 <Eridius> Riastradh: how about the basic string library for a given language? for example, NSString in Cocoa
19:49:11 <mle> Eridius: it seems more useful to have cursors that move forward or backward by grapheme-clusers (or lesser units) and lines
19:49:15 <Eridius> MyCatVerbs: you just brought it up
19:49:28 <mauke> ^ English text
19:49:40 <Eridius> mauke: diacritic marks are in the BMP
19:49:43 <Riastradh> Eridius, well, in that case, surely you must have a great variety of sample applications to choose from that require random access to Unicode strings.
19:49:46 <MyCatVerbs> Eridius: no, why bring the example of indexing into the middle of an English string up?
19:49:48 <mauke> Eridius: but not Linear B syllables
19:50:02 <Eridius> Riastradh: I fail to see your point
19:50:02 <MyCatVerbs> sjanssen: there's nothing particularly abstract about cons cells... :/
19:50:35 <Eridius> even if random-access is irrelevant, UTF-16 is generally the most practical space-wise too for strings of an unknown language
19:50:55 <Riastradh> Eridius, if you are trying to optimize an operation, I hope that you have a reason to optimize it, such as an application that uses it extensively.  In this case, the operation is random access to the code units of a UTF-16 stream, and I don't know what the application you have in mind is.
19:51:15 <Riastradh> If there are no applications that require it, is it worth one's while to optimize it?
19:51:20 <Eridius> Riastradh: I don't have one. That's merely just one aspect of why UTF-16 is more practical
19:51:24 <sjanssen> MyCatVerbs: sure they are, their exact representation is not defined in the standard.  In fact, I doubt there are many people in the world that can tell you exactly what the cons cells look like in GHC
19:51:25 <mauke> Eridius: man, if your "UTF-16 library" exposes surrogate pairs to my application, it's really just UCS-2
19:51:31 <MyCatVerbs> Eridius: Riastradh is also referring to the fact that, for entirely unsurprising reasons, most programs that actually process text in some way rather than just pass strings around without examining them end up being written to consume them as streams, and never actually need to index into them.
19:51:33 <mauke> Eridius: and I have no reason to use it
19:51:56 <Riastradh> Eridius, if it's to be practical, there must be practice that requires it.
19:51:56 <MyCatVerbs> sjanssen: really? I've met something like thirty. :)
19:52:11 <Riastradh> Eridius, if you want to claim that it's practical, you had better be prepared to give examples of its practice.
19:52:24 <MyCatVerbs> sjanssen: aka "everyone who went to AngloHaskell last year, because it came up during one of the speakers' presentations". :)
19:52:27 <Eridius> you're completely ignoring my second example
19:52:42 <sjanssen> MyCatVerbs: "thirty" counts as few when considering the whole population of the world
19:52:46 <Riastradh> Eridius, sorry, by `second example' do you mean your other argument that UTF-16 is more compact for CJK text?
19:52:47 <Eridius> Riastradh: you have a habit of getting fixated on a single point and ignoring everything else
19:53:04 <Eridius> Riastradh: yes
19:53:12 <MyCatVerbs> sjanssen: "every Haskell programmer on the planet, and also their immediate families" counts as "nobody whatsoever" when considering the whole population of the world, too!
19:53:16 <ddarius> Okay, as far as I can tell Riastradh is saying the approach Eridius would like to take is broken and Eridius is saying he doesn't care because it works "often enough."
19:53:26 <MyCatVerbs> sjanssen: that doesn't mean that we don't exist.
19:53:46 <Eridius> ddarius: what exactly do you think the word "practical" means?
19:53:47 <sjanssen> MyCatVerbs: not every Haskell programmer knows this.  Most know roughly how it works in GHC, very few know *exactly*
19:53:48 <Riastradh> Eridius, contrariwise, you have a habit of refusing to defend some assertions.  Please realize that I may already be convinced that UTF-16 is better, but that I may be trying to help you to strengthen your argument by identifying the omissions in it.
19:54:11 <sjanssen> MyCatVerbs: and, of course, the exact implementation is liable to change at any time
19:54:44 <Eridius> Riastradh: I'm dropping the constant-time-index argument because you've already asserted that you believe having a cursor into a string is a better approach than indexing into it. That may be true, but most languages use the index approach rather than the cursor one
19:54:58 <Eridius> so it's hard to argue the point unless we step back and talk about that
19:54:59 <ddarius> Eridius: Is my summary accurate with regards to your statement or not?
19:55:03 <Riastradh> Eridius, you have claimed that UTF-16 is practical because it grants random access to code units (many, but not all, of which are scalar values) in constant time.  The omission in this argument is applications to defend the `practical' claim.
19:55:10 <MyCatVerbs> sjanssen: okay. Let's cut this short. "The map is not the territory" is what you're getting at, here?
19:55:16 <Eridius> ddarius: no, I think it works "virtually all of the time", not "often enough"
19:55:28 <Riastradh> Eridius, I didn't say (in this discussion) that cursors are better than random access.
19:55:32 <Eridius> and when it's broken, it's also likely to be broken when using diacritic marks
19:55:43 <Eridius> and so if you care about that sort of thing your app should handle it
19:55:49 <monochrom> "Haskell Char is 32-bits" is a C mindset. "w00t I need 32-bit storage, let me use unsigned long long char as workaround!"  For Christ's sake if you really care that you want exactly 32 bits please use Word32 and leave Char alone.
19:55:57 <sjanssen> MyCatVerbs: oh, and did you know that a Char# is 8 bytes on 64-bit platforms?  This sinks the UCS-4 argument, I think
19:56:04 <ddarius> Eridius: I agree that "virtually all of the time" is not "often enough," but it sounds like the answer to my question is "yes."
19:56:24 <Eridius> ddarius: ok, sure
19:56:42 <Eridius> Riastradh: ok, let me give a concrete example
19:56:53 <Eridius> Obj-C has an NSString class which provides object-oriented access to a string
19:56:57 <MyCatVerbs> sjanssen: yes. But UCS-8 uses the same numerical values as UCS-4 does. ;)
19:56:57 <Eridius> the internal representation is UTF-16
19:57:08 <Eridius> if I ask NSString to search for a substring, it gives me back a location
19:57:26 <Eridius> now if I want to extract from that substring onwards, I'd need to index back into that location in the string
19:57:47 <Eridius> if the internal representation was UTF-8 it would have to scan the entire string up until that index twice, but in UTF-16 it only has to do that once
19:57:59 <Riastradh> Just a moment.
19:58:09 <mauke> Eridius: not really
19:58:15 <mauke> it all depends on your units
19:58:16 <Eridius> mauke: why not?
19:58:27 <sjanssen> Eridius: this is assuming that the API returns an integer index
19:58:28 <Riastradh> The NSString method to search for a substring gave you an object representing location of the substring.
19:58:40 <Eridius> sjanssen: what else would it return?
19:58:44 <Riastradh> Does it matter how this object is represented?
19:58:46 <sjanssen> Eridius: a UTF-8 version would more likely provide a pointer inside the string
19:58:54 <monochrom> abstract pointer it can return
19:58:56 <MyCatVerbs> sjanssen: plus there's all the boxing overhead, and the cons cells for the lists... all of which is implementation-dependant as you say. So yeah, okay, you can't necessarily calculate the exact memory usage just from the length of the string. For that, you need a packed representation.
19:58:57 <sjanssen> Eridius: or an abstract byte index
19:59:03 <Eridius> sjanssen: no it wouldn't. that breaks the NSString abstraction
19:59:05 <Riastradh> For example, could it be a number of bytes from the beginning of the string's internal storage?
19:59:09 <monochrom> haskell uses abstract pointers too
19:59:12 <Riastradh> Could it be a pointer into memory?
19:59:20 <mauke> sjanssen: or an integer plus putting an entry into a hidden utf-8 cache in teh string
19:59:31 <Eridius> pointer into memory breaks the abstraction of the object
19:59:36 <Riastradh> How so, Eridius?
19:59:37 <Eridius> and it also removes the ability to reason about the result
19:59:46 <monochrom> why not return a "new" string for your substring?
19:59:47 <mauke> Eridius: offset of codepoint also breaks the abstraction
19:59:52 <MyCatVerbs> sjanssen: but the important bit from a semantic point of view is that a Haskell Char is at least as wide as a UCS-4 code unit. Not that it's necessarily exactly the same size.
19:59:55 <Riastradh> I'm not asking, by the way, about the *exposed* representation of the location.
20:00:07 <sjanssen> MyCatVerbs: I still don't think that is necessarily true
20:00:12 <Riastradh> I'm only asking about how the NSString class might internally represent the location, in a way that users of the NSString class are not meant to observe.
20:00:16 <Eridius> while NSString is implemented using UTF-16, it does not expose this implementation to the outside world (except in the edge case of string indices treat surrogate pairs as separate values, which I regard as a bug)
20:00:23 <Eridius> well, not really a bug
20:00:27 <Eridius> I regard that as unfortunate but expected behavior
20:00:36 <Riastradh> I'm not assuming that that I can do pointer arithmetic on the object denoting the location of the substring, for instance.
20:00:40 <Riastradh> Nor am I assuming that I can do integer arithmetic on it.
20:00:46 <mauke> so in conclusion, NSString-- for leaking implementation internals
20:00:46 <Eridius> monochrom: because Obj-C is a practical language, not an idealistic one
20:00:59 <sjanssen> MyCatVerbs: data Char = C0 Word8 | ... -- is a perfectly reasonable definition.  A compiler than GHC might use less than four bytes for certain values
20:01:06 <mauke> Eridius: errr... may I point you to Perl?
20:01:10 <Eridius> Riastradh: Obj-C is a C-derived language (it's actually a superset of C)
20:01:12 <sjanssen> s/compiler than/compiler other than/
20:01:21 <Riastradh> Yes, I'm familiar with Objective-C.
20:01:30 <ddarius> Can you guys please take this elsewhere as it has nothing to do with Haskell and I think my summary of the situation shows that it has little to no value to anybody except (perhaps) the arguers.
20:01:32 <mauke> and if you call Perl idealistic, I'm going to slap you
20:01:38 <Eridius> mauke: if my IRC client had an /ignore feature, you'd be on it. Please stop wasting time with silly arguments
20:01:56 <mauke> haha
20:02:04 <lament> Eridius: your IRC client doesn't have ignore?
20:02:15 <Eridius> lament: no. It's lame that way. And I haven't had the time to hack it in myself
20:02:28 <MyCatVerbs> sjanssen: oh, that's what you mean. Yes, but the semantics you see with that representation still make a Char just as wide as a UCS-4 code unit.
20:02:29 <lament> that is truly bizarre.
20:02:49 <mauke> ok, let me just say this: Perl's string API exposes "scalar values", i.e. it looks basically like a sequence of UCS-4 units
20:02:53 <MyCatVerbs> sjanssen: (where "wide" is measured in terms of the range of values that you can encode in a single one, rather than by memory usage).
20:03:23 <MyCatVerbs> mauke: that sounds... disturbingly sane, for Perl. ;)
20:03:27 <Eridius> Riastradh: if NSString returned an opaque datatype when you ask it for a location, that would be very unexpected behavior, especially since it's harder to make guarantees about portability of locations across multiple strings
20:03:29 <mauke> substr() and similar functions take character indices, yet the implementation actually uses UTF-8 behind the scenes
20:03:52 <Riastradh> Eridius, what operations do you want to perform that require the location to be meaningful to multiple distinct strings?
20:03:58 <mauke> MyCatVerbs: Perl's unicode support is pretty good IMHO
20:04:09 <MyCatVerbs> mauke: oh, nice! Out of curiosity, has it ever been benchmarked against a comparative UTF-16 implementation of the same?
20:04:19 <mauke> MyCatVerbs: AFAIK no
20:04:21 <Eridius> Riastradh: if I generate 3 new modified copies of an original string, I might want to be able to reason about locations within all 4 strings at the same time
20:04:27 <MyCatVerbs> mauke: I only ask because that's what Data.Text is shaping up to be, more or less.
20:04:35 <Riastradh> Modified copies?
20:04:37 <ddarius> Eridius, Riastradh: The conversation still has nothing to do with Haskell.
20:04:45 <Riastradh> I apologize.
20:04:48 <Riastradh> I shall leave now.
20:05:11 * MyCatVerbs facepalms.
20:05:21 <mauke> MyCatVerbs: also, that wasn't the whole story; internal strings can be either latin-1 or utf-8
20:05:22 * MyCatVerbs would headdesk, but he is not sitting at a desk.
20:05:31 <mauke> there's a special flag on every string for that
20:05:32 <kyagrd> Hello folks, quick question about QuickCheck, since QC versioned up to 2.x there are some incompatiblities and wiki docs have stale info.
20:05:44 <kyagrd> For example, http://www.haskell.org/haskellwiki/Introduction_to_QuickCheck
20:05:53 <MyCatVerbs> mauke: eh, but it's Perl, and therefore it obviously promotes latin-1 strings to utf-8 as soon as you do something that requires characters outside of latin-1, right? ^^
20:05:59 <mauke> yes
20:06:05 <MyCatVerbs> Also, Tom Harper already released Data.Text. D'oh.
20:06:12 <mauke> see utf8::upgrade
20:06:24 <kyagrd> I can't find deepCheck and verboseCheck any more, anyone knows what's the way around?
20:07:50 <MyCatVerbs> So yeah. Data.Text uses packed Word16 arrays, and exposes an API that hands out ordinary Chars, which are scalar units. And it's already on Hackage. Yay.
20:08:00 <kyagrd> Oh, deepCheck is just a local definition in the document sorry but verboseCheck does not seem to be in the library any more.
20:08:58 <MyCatVerbs> mauke: *looks* oh dear. Perl supports UTF-EBCDIC... oh, dear, no...
20:09:29 <mauke> oh right, on EBCDIC platforms the internal representation is UTF-EBCDIC
20:12:42 <MyCatVerbs> mauke: I mean I suppose it's sometimes useful to have it supported, but still. Couldn't Larry and friends just leave it to die, unloved and alone?
20:12:58 <mauke> no, I like Perl
20:13:07 <mauke> lots of people do
20:13:33 <Eridius> ...wait seriously? I thought UTF-EBCDIC was a joke, but wikipedia says it's not :http://en.wikipedia.org/wiki/UTF-EBCDIC
20:13:54 * sjanssen prefers UTF-9
20:14:21 <amz> utf-1
20:14:43 <mauke> "UTF-18 is a fixed length encoding using an 18 bit integer per code point." awesome!
20:14:47 <amz> wait, damn, utf-1 actually exists.
20:14:53 * Eridius prefers UTF-7.
20:15:02 <monochrom> wtf-8
20:15:35 <Eridius> NSString actually has an encoding called NSNonLossyASCIIStringEncoding which represents all unicode codepoints in 7 bytes
20:15:38 <mauke> WTF-8 is © me
20:15:44 <Eridius> basically the same way interpreters print strings at the console :)
20:16:11 <MyCatVerbs> Eridius: UTF-EBCDIC is for use on EBCDIC machines.
20:16:40 <Eridius> MyCatVerbs: yes I read that. I wasn't aware there were any EBCDIC machines still around that needed unicode support
20:16:50 <MyCatVerbs> Eridius: and UTF-7 is dead for a reason. Anywhere where you need to hide arbitrary strings inside of a safe subset of 7-bit ASCII, you use uuencode.
20:17:13 <MyCatVerbs> Eridius: I think IBM still sells them. Mainframes.
20:17:53 <Eridius> MyCatVerbs: well, uuencode makes ASCII text unreadable. NSNonLossyASCIIStringEncoding is really intended as a fallback for when converting to another encoding fails and you don't want to handle it intelligently
20:19:28 <wli> THey're still sold, yes.
20:20:55 <mcnster> hi.  i have a file M.hsc which is being run through hsc2hs to create M.hs.  however when i run ghc on M.hs the C preprocessor is not being run.  i've tried -cpp and an OPTIONS pragma, but to no avail.  any ideas?
20:21:20 <mauke> yeah, why are you trying to run the C preprocessor?
20:21:55 <mcnster> mauke, sorry the ghc preprocessor... whichever processor is activated by -cpp
20:22:20 <mauke> yeah, why?
20:22:22 <mcnster> mauke, i have #defines that need expansion before compilation
20:22:28 <mauke> hsc2hs does that
20:24:58 <mcnster> mauke, hs2hs doesn't expand my #defined'ed macros
20:25:24 <mauke> can you give me an example file?
20:27:48 <mcnster> here is M.hsc:  #define FOO(x) data x = x <nl> FOO(Bar) <nl><eof>
20:28:00 <mcnster> hsc2hs leaves FOO(Bar) unexpanded
20:28:11 <mauke> and removes the #define
20:28:18 <mcnster> right
20:29:20 <mcnster> am i not groking something?  or is this a feature?
20:29:51 <MyCatVerbs> There are two 'k's in "grokking". Beyond that I cannot help you, sorry. ;)
20:30:22 <mauke> well, the #define is processed by hsc2hs
20:30:25 <dolio> So you want "FOO(T)" ==> "data T = T ; data Bar = Bar ; data Bar = Bar ; data Bar = Bar ; ..."?
20:30:31 <mcnster> MyCatVerbs, in canada we say "groking" (like going "oouting")  ;)
20:30:39 <mauke> I wouldn't even know how to make hsc2hs emit #defines
20:31:08 <MyCatVerbs> mcnster: ...how exotic!
20:32:15 <mcnster> mauke, when i want to keep a #define for the ghc pre-processor, i write it thus: "##define ..."  yet ghc is not running the preprocessor, and i'm at as loss as to why?
20:32:59 <sjanssen> mcnster: how are you running hsc2hs?
20:33:19 <mcnster> hsc2hs M.hsc -I/usr/lib64/ghc-6.10.1/include
20:33:28 <dolio> Oh, never mind me.
20:34:02 <mauke> ah, nice
20:34:16 <mauke> mcnster: that works here
20:34:43 <mcnster> mauke, what works?  (and i will try it here)
20:34:51 <mauke> ##define
20:35:23 <mcnster> yes, i have no problem with hsc2hs.  but the generated M.hs file is not being preprocessed when i invoke ghc
20:35:49 <mauke> ghc -cpp foo.hs  # works
20:37:13 <mauke> btw, here's how you could do it directly in hsc2cs: #let FOO x = "data %1$s = %1$s", #x
20:37:20 <mauke> #FOO Bar
20:38:20 <mcnster> mauke, cool
20:45:50 <mcnster> mauke, thanks for your help :) i'm going to get some sleep and try this tomorrow
20:49:07 <Axman6> are there any nice haskell webservers? not happs style web app things, but apache type servers
20:49:24 <cjb> that doesn't sound like a problem you want to reach for haskell for, to me
20:49:29 <cjb> s/for/to/1
20:49:54 <lfeagan> Why do you think that Haskell cannot be a good choice for a webserver?
20:49:55 <Axman6> well, it'd be interested to see how effective it was
20:50:30 <cjb> Axman6: this person says they made one in twenty lines with HTTP and network:  http://lstephen.wordpress.com/2008/02/14/a-simple-haskell-web-server/
20:50:57 <Spark> wonder how many million requests/second it can handle :)
20:51:23 <cjb> lfeagan: I just don't see what the point is.  Apache's perfectly capable of talking to Haskell programs over CGI, and is clearly better as a web server than a Haskell program could ever be,
20:51:47 <Axman6> cjb: i don't think that's at all true
20:52:06 <Axman6> there's no reason a haskell program couldn't be better than apache
20:52:15 <cjb> good luck with that.
20:52:39 <Axman6> well, i think Oleg might have somethign that is up there.
20:52:42 <Axman6> hyena i think
20:52:57 <kbateman> Apache has undergone a great deal of use and evolutionary pressure to be a useful web server.
20:53:33 <lfeagan> It isn't that I don't think that Apache isn't great. But there could be benefits to a Haskell web server. Apache has had many years of development to get to where it is today.
20:53:34 <Saizan> if only, cheap concurrency should be a win
20:54:03 <Axman6> i still prefer lighttpd anyway
20:54:09 <sjanssen> cjb: Apache is better than any Haskell webserver because of its maturity, or because Haskell is inadequate?
20:54:39 <kbateman> What is "better"?  Faster?  Safer?  Easier to administer?
20:54:41 <lfeagan> Yes, from the end-user standpoint, I think that an argument for Apache makes a lot of sense. From the developer standpoint, I think that Haskell has some big positives going for it.
20:54:52 <Axman6> kbateman: any and all i guess
20:54:55 <Saizan> Axman6: hyena is an implementation of HTTP using the iteratee concept by tibbe, it doesn't aim to be a full "webserver"
20:55:06 <Spark> beyond the features, speed and stability are what is needed
20:55:14 <MyCatVerbs> cjb: I believe you're wrong about that. AFAIK you *could* happily write a faster webserver in Haskell than Apache. I don't think you could write a faster webserver than lighttpd or nginx, though.
20:55:18 <Axman6> Saizan: yeah, i wasn't sure on the details.
20:55:27 <Spark> i don't think haskell has enough performance transparency to get the speed needed for a webserver like apache
20:55:53 <Axman6> i think haskell has all the tools needed to make it fast and stable oin the sort of environment needed for a webserver
20:55:54 <kbateman> I could be wrong here, but I didn't think apache was particularly fast.
20:55:54 <Spark> apache has probably had a lot of microoptimisation done on it
20:56:00 <cjb> sjanssen: I guess I feel like it's written to the level of assembly language, which you're unlikely to beat either in speed or memory use.
20:56:07 <cjb> Spark: decades, yeah.
20:56:20 <sjanssen> cjb: is it actually?
20:56:28 <Axman6> isn't lighttpd faster than apache for static content?
20:56:40 <Axman6> and FastCGI
20:56:51 <MyCatVerbs> Spark: note that for efficiency here you need high-level cleverness about how you do IO, not CPU time microoptimization.
20:56:52 <cjb> Axman6: I think they're similar for static content, and lighttpd is faster for simple dynamic content, or something.
20:56:55 <sjanssen> isn't a webserver just a bunch of memcpy() and IO scheduling?
20:57:13 <Spark> some parsing
20:57:49 <Spark> for static files you can probably just memory map the file and memcpy straight into the socket :
20:57:50 <kbateman> sjanssen: URL rewriting, security features, per-directory configuration
20:57:53 <Spark> :)
20:57:59 <MyCatVerbs> Spark: lighttpd and nginx both beat the stuffing out of Apache because they use efficient mechanisms like epoll() and its equivalents (basically, libevent and its competitors) to do their IO.
20:58:01 <Axman6> there's http://hackage.haskell.org/cgi-bin/hackage-scripts/package/mohws-0.1 too
20:58:35 <ImInYourMonad> #math are retards and #machinelearning is to shy and since #haskell is genious ill try here. Im trying out the netflix prize. i have KNN working, it is a simple algorithm to implement. now it seems SVD is the way to go looking at the big boys. I have some trouble implementing it with my basic linear algebra skills though. if I set up a matrix with [customers][movies] = rating(1-5) and the unrated ones are 0. then I run SVD on that a
20:58:46 <lfeagan> Web serving is about being a good cache for the static and doing some quick "personalization" effects for the dynamic content.
20:58:47 <wli> writev(), not memcpy()
20:58:48 <Spark> MyCatVerbs: i thought apache did that too
20:58:58 <cjb> sjanssen: so, if you're interested in this question, I wouldn't expect it to take more than a few hours to make an efficientish static server in Haskell
20:59:02 <Spark> MyCatVerbs: split over threads and processes for more speed and stability
20:59:04 <kbateman> lighttpd is single-cpu, right?  It isn't multithreaded?
20:59:18 <MyCatVerbs> Spark: no. Apache uses fork() and passes file descriptors from process to process using Unix sockets.
20:59:19 <cjb> sjanssen: then you can throw tens of thousands of connections at it and see what the throughput looks like
20:59:49 <Spark> people use apache for high volume web servers which wouldn't be the case if it used fork
20:59:56 <Spark> there are other options
20:59:58 <MyCatVerbs> ImInYourMonad: you got cut off ad "then I run SVD on that a...".
21:00:06 <Zao> ImInYourMonad: You were truncated at "then I run SVD on that a"
21:00:11 <cjb> (I'm updating my statement to be an even stronger one, namely that I don't think you could make a competitive *static page* server in Haskell.)
21:00:14 <ImInYourMonad> on that and suposedly get out factors that correlate to attributes of the users and movies. but if I multiply them again I get the original matrix again right? so how do I set this up to be bale to predict the 0 fields?
21:00:21 <MyCatVerbs> Spark: er... but it does. And it does. Respectively.
21:00:31 <Axman6> cjb: i think many people would disagree
21:00:44 <cjb> Axman6: then it shouldn't take them more than a few hours to prove me wrong ;)
21:01:05 <Axman6> i would, but i wouldn't know where to start :)
21:01:39 <MyCatVerbs> Spark: you might just have underestimated how fast modern machines actually are, there. Plus, Apache does not fork() on every request. It pre-forks, and keeps a pool of worker processes around. Plus, it has failure modes that only affect fork() models.
21:01:51 <Spark> MyCatVerbs: right that sounds more like it
21:02:00 <sjanssen> cjb: GHC actually scales fairly well to thousands of threads
21:02:01 <Spark> MyCatVerbs: each fork also has threads doesn't it
21:02:18 <centrinia> Doesn't Erlang also scale well to thousands of threads?
21:02:21 <Spark> MyCatVerbs: and each thread is handling a number of actual connections
21:02:25 <lfeagan> cjb: I don't think most businesses running commercial sites would be very exited about a very fast static page server. Dynamic content is extremely prevalent--> Web 2.0 is the norm.
21:02:30 <MyCatVerbs> Spark: I don't think so, no. It's not necessarily faster to multithread the individual processes.
21:02:35 <Axman6> cjb: sure, but erlang has other problems imo
21:02:40 <Axman6> i like erlang though
21:02:42 <cjb> lfeagan: of course.  I'm trying to give you an easier problem than that.
21:02:49 <sjanssen> cjb: and there is some existing work on making that even better (I think the project is called "Unity"?)
21:02:59 <Axman6> uh, s/cjb/centrinia
21:03:41 <Spark> as soon as you have a hugely dynamic website, the problem is how to encourage people to write non-shitty php
21:03:43 <MyCatVerbs> Spark: no. Apache uses one process per client. This is why it fails up with large numbers of clients connected simultaneously. Have a quick look at people implementing COMET apps.
21:03:50 <Spark> and how to make your database handle the load
21:03:58 <Saizan> and they are working on using epoll instead of select in the IO manager, iirc
21:04:17 <Spark> MyCatVerbs: might have been some other server i was reading about then
21:04:22 <Spark> i've never set up apache for more than casual use
21:04:46 <MyCatVerbs> Spark: that doesn't necessarily mean that it won't hold up well enough for high volumes of short-lived, sequential connections, however. It does not work well for large numbers of *concurrent* connections.
21:05:25 <centrinia> Would it make sense to consolidate the entire IP/TCP/Apache stack into one application and do global optimizations on it?
21:05:55 <centrinia> I mean, IP/TCP/WWW stack
21:06:04 <Spark> what global optimisations are you expecting to be able to perform
21:06:07 <ImInYourMonad> no linear algebra gods in here?
21:06:17 <MyCatVerbs> centrinia: yes. It's been done. Someone wrote an in-kernel webserver for Linux.
21:06:19 <kbateman> centrina: if you're going that far, you might as well make it a kernel module
21:06:29 <kbateman> great minds think alike
21:06:37 <cjb> it was Rik van Riel, and "tux"
21:06:44 <Spark> that just cuts out some overhead in the kernel/userspace barrier though
21:06:45 <MyCatVerbs> centrinia: AFAIK the performance was pretty amazing, but it never got any widespread fame or usage.
21:06:50 <Spark> it's not a global optimisation
21:07:06 <jackdempsey> hey all...working on some simple haskell exercises and somethings confused me a bit.
21:07:12 <jackdempsey> palindromeChecker a = a == reverse a
21:07:15 <kbateman> http://www.fenrus.demon.nl/
21:07:23 <jackdempsey> i kept messing up the type declaration of that. thought it would be
21:07:23 <cjb> MyCatVerbs: well, it only served static content
21:07:26 * wli cjb: That wasn't riel.
21:07:31 <jackdempsey> palindromChecker :: [a] -> Bool
21:07:35 <jackdempsey> but it complains about Eq
21:07:36 <kbateman> That's kHTTPd, the in-kernel web server
21:07:37 <cjb> wli: yeah, you're right, it was Ingo.
21:07:40 <MyCatVerbs> Spark: that is a surprisingly large uantity of overhead, though. Syscalls hurt.
21:07:44 <MyCatVerbs> *quantity
21:07:47 <Axman6> jackdempsey: you need Eq a => [a] -> Bool
21:07:49 <centrinia> palindromeChecker :: (Eq a) => [a] -> Bool
21:07:53 <jackdempsey> then when i look at it with :type i see palindromeChecker :: (Eq a) => [a] -> Bool
21:08:04 <Spark> MyCatVerbs: yes of course, but it's not a global optimisation
21:08:09 <jackdempsey> yeah, why/whats the Eq? can't seem to find it in the book..
21:08:09 <wli> cjb: riel's on IRC (actually, mingo is too, albeit not here)
21:08:14 <Axman6> :t ([] ==)
21:08:15 <lambdabot> forall a. (Eq a) => [a] -> Bool
21:08:22 <cjb> wli: yes.
21:08:32 <Spark> it's more like a completely different design
21:08:36 <jackdempsey> hmm
21:08:38 <centrinia> jackdempsey, Eq is a typeclass.
21:08:39 <Saizan> jackdempsey: Eq is a typeclass, Eq a rougly means that 'a' must be a type for which (==) is defined
21:08:46 <jackdempsey> ah
21:08:49 <jackdempsey> ok that makes sense
21:08:53 <jackdempsey> so
21:08:54 <Axman6> :t (==)
21:08:55 <cjb> MyCatVerbs: context switches and data copies do, too
21:08:56 <lambdabot> forall a. (Eq a) => a -> a -> Bool
21:08:57 <jackdempsey> saying just a is too basic
21:09:03 <kbateman> jackdempsey: if a datatype is in the Eq typeclass, then it has a meaningful == operation defined on it
21:09:04 <Axman6> yep
21:09:07 <Spark> it would be like arguing that implementing a router in hardware rather than software is a global optimisation :)
21:09:09 <jackdempsey> need to say this is something, a, that Eq can be used on
21:09:14 <Axman6> @src Eq
21:09:15 <lambdabot> class  Eq a  where
21:09:15 <lambdabot>     (==), (/=)   :: a -> a -> Bool
21:09:15 <Saizan> right
21:09:18 <jackdempsey> yeah ok cool
21:09:22 <centrinia> (forall a. a) is too generic.
21:09:25 <jackdempsey> yea
21:09:35 <Axman6> @src (==)
21:09:36 <lambdabot> x == y = not (x /= y)
21:09:37 <MyCatVerbs> cjb: I was hoping you'd account for context switching and data copying overhead as part of the syscall overhead. :P
21:09:39 <Axman6> @src (/=)
21:09:39 <lambdabot> x /= y = not (x == y)
21:09:41 <Axman6> >_>
21:09:46 <jackdempsey> so i'm sure these are "omg really?!" type questions....but i really appreciate the great help given today
21:09:52 <kbateman> Plus there's another typeclass definition that says if you have Eq a, you also have Eq [a]
21:10:02 <Axman6> jackdempsey: that's what we're here for :)
21:10:05 <jackdempsey> ah
21:10:08 <MyCatVerbs> Spark: well... you could compile it in monolithically rather than producing an object to be linked in.
21:10:22 <Axman6> @src [] (==)
21:10:22 <lambdabot> []     == []     = True
21:10:22 <lambdabot> (x:xs) == (y:ys) = x == y && xs == ys
21:10:22 <lambdabot> _      == _        = False
21:10:41 <MyCatVerbs> Spark: and then get cross-module optimization by using "cat" as your linker, rather than ld. :)
21:10:52 <jackdempsey> nice.
21:11:17 <MyCatVerbs> Spark: (by which I mean, concatenate the C source files together! I don't mean omit the 'ld' steps at the end of the compilation chain.)
21:11:24 <Spark> static linking could be argued a form of inlining
21:11:47 <Spark> fair enough, but completely non-standard use of the terms
21:12:27 <Spark> anyway, can you write a haskell program that mmaps files and does very fast copying from one file to another
21:12:35 <Spark> say the files are in an shm file system
21:13:18 <Saizan> there's a bytestring-mmap package
21:13:19 <Spark> or are in disk cache
21:13:21 <MyCatVerbs> Spark: no, not non-standard use of the terms. Just a not-entirely-standard way (i.e. fugly hack) of doing it.
21:13:37 <Saizan> or FFI at worst
21:14:45 <MyCatVerbs> "safe" FFI calls require only that the function being called won't ever make a call to the Haskell runtime, right?
21:15:11 <kbateman> sendfile() is the fastest way to do it.
21:15:23 <kbateman> http://linux.die.net/man/2/sendfile
21:16:29 <Gracenotes> sD:
21:16:33 <Gracenotes> D:
21:16:48 <Axman6> spaghetti chin!
21:17:06 <MyCatVerbs> Unsafe FFI calls for all of your IO would kinda suck. You'd have to use writev() and readv() with large collections of iovecs just to amortize the extra cost, I'd bet.
21:17:38 <wli> 1024 iovec elements max
21:18:36 <wli> It can't be made big enough to compensate for much
21:18:37 <MyCatVerbs> wli: that's probably enough. :) I don't see a mention of that limit in the man page, though.
21:18:55 <wli> It's a kernel limit. glibc emulates above that.
21:19:08 <MyCatVerbs> Ah. Hrmn. Weeeelll...
21:19:45 <MyCatVerbs> Can you actually do any better than that in C on Linux?
21:19:54 <MyCatVerbs> 1024 reads or writes with one syscall, I mean.
21:20:29 <wli> You could patch your kernel to support more (or arbitrary if you want to go beyond just changing a number).
21:20:46 <wli> You could use aio, but it doesn't really do much in Linux.
21:21:13 <MyCatVerbs> wli: thing is, if you're using big iovec collections in order to avoid the FFI overhead, then it doesn't matter to you that glibc makes multiple syscalls for each call to it, since those multiple syscalls all happen on the *other* side of the FFI.
21:21:20 <kbateman> If you're sending the simple contents of a file, sendfile() does it best I think
21:22:07 <MyCatVerbs> Not necessarily. AFAIK plain old write() on mmap()ed files is just as efficient, these days.
21:22:35 <MyCatVerbs> (On account of some nice people putting lots of work in to make it as close as humanly possible to zero-copy.)
21:23:00 <MyCatVerbs> wli: yeah, and from what I gather, aio doens't really do much anywhere. :)
21:23:03 <kbateman> There's the copy-on-write risk, but I guess that can be handled
21:23:07 <wli> The read() side is what kills you.
21:23:30 <wli> MyCatVerbs: Nah, aio DTRT on various other kernels besides Linux.
21:24:48 <wli> MyCatVerbs: Linux is just way behind on this front.
21:24:52 <MyCatVerbs> kbateman: copy-on-write risk? PROT_READ when you mmap() it, if I understand correctly what you're getting at.
21:25:01 <MyCatVerbs> kbateman: PROT_READ and MAP_SHARED, I mean.
21:25:54 <kbateman> the small risk of somebody writing to the file, which means the page is (horror of horrors!!!) copied.
21:26:39 <MyCatVerbs> wli: which other kernels? From people I've spoken to and what I've read, I got the impression that AIO was poorly supported anywhere, often not actually implemented, and not even useful anywhere because the API doesn't even include an O(1) poll() replacement.
21:27:34 <MyCatVerbs> wli: like the implementation is supposed to be not particularly impressive on Linux and Solaris, and not even present on some (not sure about all) of the BSDs.
21:27:46 <wli> Solaris, NT, VMS.
21:27:59 <bd_> kbateman: I don't believe MAP_PRIVATE gives any guarentees of what happens if you write to the backing file while mapped. Technically speaking MAP_SHARED doesn't give guarentees if you write() to the file either, although I believe things happen to work in that case on linux.
21:28:15 <wli> Solaris tried a bit harder than Linux, and does get mileage out of it despite not being very impressive.
21:28:46 <MyCatVerbs> wli: NT, VMS? I would be astounded by the notion of either implementing POSIX AIO. oO
21:29:06 <MyCatVerbs> wli: (plus, doesn't NT have completion ports? And don't they not suck?)
21:29:10 <wli> POSIX AIO? The standard is barely adhered to, if at all.
21:30:00 <wli> Linux' aio is unfortunately in a bit sadder shape than "not very impressive." :(
21:30:52 <MyCatVerbs> wli: I was under the impression that Solaris' sucked more.
21:31:51 <wli> Completion ports are a minor part of how NT's aio is good. Most of it is the internal block and fs IO code structure.
21:33:22 <bd_> unfortunately a lot of blocking operations in linux keep state on the kernel stack, meaning you'd need some thread to host them. I believe there was a proposal for an API to spin off ultra-lightweight kernel threads for such operations, but it never got merged...
21:34:07 <Saizan> are there nice interactive graph viewers with a reasonable input format?
21:34:21 <kbateman> Saizan: like gnuplot?
21:34:36 <roconnor> @src fix
21:34:36 <lambdabot> fix f = let x = f x in x
21:35:03 <wli> bd: Don't worry, distros will carry the patch if it's any good.
21:35:23 <wli> bd: And a lot of times even if it isn't.
21:35:26 <bd_> wli: well, it's a change to the syscall API - glibc's not getting anywhere near that sort of thing unless it's a stable API
21:35:31 <MyCatVerbs> wli: still. The POSIX AIO API as defined seems not useful. The only way it provides to do large quantities of IO with any single syscall is lio_listio, which I don't think is any more useful than readv/writev on nonblocking sockets. Feel free to dissuade me of that if it's not correct.
21:35:32 <Saizan> kbateman: no, like graphviz, but with the ability to collapse/expand parts of the graph interactively
21:36:33 <wli> MyCatVerbs: POSIX AIO is almost completely ignored. No one even talks about it. I never had it in mind when I referred to Solaris', NT's, or VMS' aio.
21:36:35 <bd_> wli: I mean, worst case if they do merge that sort of patch is a program built on distro A /appears/ to run on kernel B, but actually does something entirely different :|
21:36:49 <bd_> which nobody wants
21:37:10 <wli> MyCatVerbs: Or Linux'
21:37:11 <MyCatVerbs> wli: oh. Oops. In Solaris' case, were you talking about Ports, then?
21:38:13 <wli> MyCatVerbs: Sort of. I was really thinking of kernel-internal event propagation and how well blocking operations are prevented from blocking calling contexts.
21:38:18 <kbateman> Saizan: oh, _that_ kind of graph
21:39:22 <kbateman> Saizan: I don't know of any.
21:39:45 <MyCatVerbs> wli: oh, I see. I was thinking almost purely in terms of the APIs that're exposed to userspace, and just assuming that the kernel devs are clever enough to optimize anything that people are making heavy use of in the wild - provided that the API doesn't chain them to a crap mechanism. Like poll() and select() do.
21:41:38 <bd_> I can't help but wonder if a really lightweight userspace thread-based implementation might be good enough for AIO?
21:42:02 <bd_> ie, don't bother setting up TLS or anything like that, just carve out a 4kb stack, clone a thread, and hand it some work
21:43:17 <MyCatVerbs> bd_: AFAIK that's sort of what Java does now and it's very efficient.
21:43:38 <bd_> yeah
21:44:09 <bd_> I mean, a context switch between threads that use the same address space isn't /that/ expensive...
21:44:34 <MyCatVerbs> bd_: userspace threads multiplexed across multiple OS threads. Then it talks to the OS through the usual APIs (all event-driven), but provides a thread-oriented API.
21:45:01 <bd_> what's "it" in this context? java? Haskell?
21:45:26 <MyCatVerbs> bd_: both, actually. =)
21:45:41 <bd_> Hmm, I thought java uses a native thread for each java thread these days?
21:46:42 <MyCatVerbs> I am unsure. It definitely did make good use of green threads at one point.
21:54:00 <wli> I'll be more able to concentrate when I get back to the apartment. Right now I'm trying to avoid fainting in my (ex-)bf's hospital room.
22:21:12 <pumpkin> shhh, I'm hunting bunny wabbits
22:22:13 <thoughtpolice> @seen shapr
22:22:13 <lambdabot> I saw shapr leaving #scannedinavian and #haskell 2h 27m 1s ago, and .
22:23:32 * wli is waiting to get into good enough shape to drive home.
22:24:00 <Eridius> wli: what's wrong?
22:26:41 <wli> I've got my own incurable problems.
22:57:09 <kiris> http://www.reddit.com/r/programming/comments/82xfv/hasp_another_way_to_metaprogram_for_haskell/
22:57:11 <kiris> neat :-)
23:00:02 <pumpkin> aha
23:00:20 <pumpkin> I saw that earlier, but had no clue what it was about due to the point nanothief made :)
23:00:30 <pumpkin> but yeah, it does look cool now that I know what it does :P
23:00:45 <nanothief> pumpkin, hehe yeah
23:01:54 <Saizan> fsvo cool
23:02:02 <pumpkin> fsvo?
23:02:14 <Saizan> for some value of
23:02:19 <pumpkin> ah :)
23:02:20 <wli> ?
23:26:43 <Saizan> ?djinn (a -> b,c -> d) -> (a,c) -> (b,d)
23:26:44 <lambdabot> f (a, b) (c, d) = (a c, b d)
23:27:09 <vixey> ?djinn (a -> b,c) -> (a,c -> d) -> (b,d)
23:27:09 <lambdabot> f (a, b) (c, d) = (a c, d b)
23:28:14 <Saizan> and reason for that permutation of the arguments?:)
23:28:24 <Saizan> s/and/any/
23:30:19 <jml> are there any good docs (or examples) around for haskelldb?
23:31:24 <Saizan> ?djinn (a,c) -> (b -> d) -> (a -> b,c -> d)
23:31:24 <lambdabot> -- f cannot be realized.
23:31:34 <Saizan> ?djinn (a,c) -> (b,d) -> (a -> b,c -> d)
23:31:34 <lambdabot> f _ (a, b) = (\ _ -> a, \ _ -> b)
23:31:56 <vixey> ?djinn (a,c) -> (b -> d,c -> b) -> (a -> b,c -> d)
23:31:56 <lambdabot> f (_, a) (b, c) = (\ _ -> c a, \ _ -> b (c a))
23:35:13 <Saizan> ?type uncurry (***)
23:35:15 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => (a b c, a b' c') -> a (b, b') (c, c')
23:35:55 * jml decides to write a bunch of boilerplate sql for the moment
23:39:43 <jml> boilerplate, incorrect sql :(
23:49:55 <walter_> pairs ps = intercalate ", " (map renderPair ps)
23:49:56 <walter_> renderPair (k,v) = show k ++ ": " ++ renderJValue v
23:50:25 <walter_> renderPair (k,v) means renderPair (k:v) ?
23:51:22 <Zao> (k:v) has type [a], (k,v) has type (a,b)
23:51:42 <walter_> Zao, thanks.
23:52:11 <Zao> The first matches on the head and tail of a list and the second matches on the components of a 2-tuple.
23:52:46 <walter_> got it , one is tuple the other is list
23:57:51 <wli> Try viewL and viewR with Seq
