00:01:48 <zeno> when i have a multiparamater type class like class Foo a b where some of its methods dont use all the types  where defaultA :: a (etc), calls to it ask me to add and instance declaration for Foo a (unnamed type). changing it to instance Foo Int String where defaultA b = 5 fixes it but clutters the type signatures.  whats a better way?
00:03:18 <FunctorSalad> zeno: - add a fundep "a -> b", or split the class
00:03:21 <jmcarthur> zeno: you may want to look into functional dependencies or type families
00:04:20 <kadaver> pumpkin: you know your split loops forever at mySplit 0 xs?
00:04:47 <pumpkin-> kadaver: nope, I spat it out while I was sitting in a talk :)
00:04:53 <pumpkin-> but that makes sense
00:05:02 <FunctorSalad_> I was disconnected :(
00:05:07 <pumpkin-> aw
00:05:25 <pumpkin-> kadaver: I'd almost argue that it's the correct behavior
00:05:40 <pumpkin-> > [0,0..4]
00:05:41 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
00:05:48 <pumpkin-> > [1,1..4]
00:05:49 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
00:05:56 <pumpkin-> same kind of idea, it seems
00:06:07 <zeno> FunctorSalad: jmcarthur thanks. so if it is class Foo a b c, change to class Foo a b c | a -> b, b -> c, c -> a?
00:06:35 <kadaver> pumpkin: i see good poit
00:06:55 <pumpkin-> but I wasn't proposing it as a serious solution
00:07:09 <pumpkin-> the takeWhile ... is ugly
00:07:16 <FunctorSalad_> zeno: if possible.
00:07:37 <jedai> zeno: are you sure every one of those dependency are real ? Introducing artificial dependencies just to "make it work" may harm the usefulness of your solution
00:07:55 <FunctorSalad_> jedai: well, it will just fail to compile :)
00:08:07 <FunctorSalad_> (if you violate fundeps)
00:08:30 <jedai> FunctorSalad_: Yes, but there may be some of those fundeps that don't need to be there
00:08:56 <FunctorSalad_> isn't more better assuming that the fundeps are valid?
00:09:13 <jedai> FunctorSalad_: I'm not saying it will produce incorrect code, just that adding fundeps willy-nilly to get the thing to compile isn't always the best way
00:09:46 <FunctorSalad_> jedai: agreed, if you break them later anyway you've wasted time with that approach
00:09:50 * edwardk has just noticed that there are a ton of monoids in the standard libraries/common extensions for haskell.
00:09:53 <FunctorSalad_> so yes, they should make sense
00:10:13 <jedai> FunctorSalad_: Besides if he really has all those fundeps, then any of a b or c determine completely the instance, maybe type families are more appropriate ?
00:10:24 <zeno> FunctorSalad_: wow fixed all my issues thanks a ton
00:10:35 <edwardk> renamed my package to note that fact, since now i have a lot more 'normal' monoids than lexical ones.
00:10:36 <jedai> edwardk: Sometimes they're neat :)
00:10:37 <edwardk> http://comonad.com/haskell/monoids/dist/doc/html/monoids/
00:10:54 <zeno> jedai: i dont really know how fundeps work, i could try removing and seeing which breaks it
00:10:56 <kadaver> State abstracts out tuplifying :P ?
00:11:31 <FunctorSalad_> jedai: they might save typing, yes :)
00:11:32 <edwardk> jedai: i found it funny that a fingertree itself forms a monoid/reducer under my scheme
00:11:57 <jedai> zeno: well fundeps are exactly how they sounds, a -> b says that for a given a you can only have one corresponding b
00:12:00 <pumpkin-_> bah
00:12:28 <kadaver> a = 1 is a function too right?
00:12:43 * FunctorSalad_ somehow finds it funny that the C preprocessor is actually pretty good in haskell
00:12:46 <zeno> jedai: yeah i really want them all to determine the other
00:12:58 <zeno> why would type families work better? what ARE they?
00:13:01 <jedai> zeno: The fundeps you put there basically says that any of a b or c completely determine your instance
00:13:03 <pumpkin-_> kadaver: not really
00:13:19 <zeno> jedai: thats my intention
00:13:29 <FunctorSalad_> #define CXT(a,b) Typeable a, LongAssContext(a,b), Show b
00:13:31 <FunctorSalad_> ;)
00:13:51 <FunctorSalad_> err the right side shouldn't have parentheses
00:13:52 <pumpkin-_> hot
00:13:54 <lament> kadaver: the jargon is variable, even though it clearly isn't
00:14:41 <jedai> zeno: Type families are the most recent solution to this kind of problem, they have a more "functional" feel to them than fundeps and are increasingly better supported
00:15:04 <kadaver> well, is it a function or not?
00:15:19 <pumpkin-_> no
00:15:46 <pumpkin-_> unless you count its Num-ness as being a function, which would seem silly
00:16:57 <jedai> zeno: http://www.haskell.org/haskellwiki/GHC/Type_families
00:17:16 <pumpkin-_> one big happy type family
00:17:24 <dolio> Type families aren't really ideal for a class like 'class Foo a b c | a -> b, b -> c, c -> a'.
00:17:52 <dolio> You can still do them, but it looks more convoluted.
00:17:56 <jedai> dolio: That depends on what the function of the class are like
00:18:02 <FunctorSalad_> I ran into issues with associated type synonyms with the fact that t can't be inferred from (Syn t)
00:18:19 <jedai> dolio: He only spoke of a function with only a
00:18:28 <FunctorSalad_> you can use associated data in that situation, *but* fundeps have the advantage that you don't have to make up new types
00:18:35 <kadaver> I need to cache pages in my webserver, should I use a Map String String? or should I come up with a proper cacheing-scheme?
00:18:49 <jedai> dolio: if there are no function with only b or/and only c, then type family might be a good fit
00:18:54 <FunctorSalad_> maybe it should be possible to give a fundep "(Syn t) -> t"
00:20:15 <dolio> Well, those fundeps say that any one parameter to the type class determines the other two.
00:20:15 <quicksilver> kadaver: I think you probably want Map String Bytestring, at least
00:20:19 <jedai> FunctorSalad_: you don't only have associated data type, you also have associated type synonym now
00:20:28 <quicksilver> kadaver: the cached data wants to be in a compact format which is quick to send.
00:20:32 <aLegendaryPengui> guys, i have a serious question
00:20:41 <dolio> Those sorts of dependencies are pretty much automatically more complicated to encode into type famiilies.
00:20:41 <aLegendaryPengui> why does this chat have so many people
00:21:36 <jedai> aLegendaryPengui: because there's a lot of people interested in Haskell that also happen to like IRC as a mean of communication (and the channel is friendly enough)
00:21:51 <kadaver> aLegendaryPengui: because everyone wants to be on the winners side in WW3
00:22:18 <ozy`> aLegendaryPengui: haskell is the language they use for programming giant robots. and who doesn't like giant robots?
00:22:23 <aLegendaryPengui> really
00:22:33 <aLegendaryPengui> like ive noticed a lot of other chats dont have nearly as many people
00:22:40 <aLegendaryPengui> even popular languages like perl
00:22:43 <ozy`> that's because they're not about haskell
00:22:44 <jedai> dolio: Right, but keep in mind that zeno just discovered fundeps, he may not needs all those fundeps
00:23:00 <dolio> Ah, okay.
00:23:27 <dolio> Yeah, if it's something more like a determining the other two (but not vice versa) then type families are probably nicer.
00:23:32 <zeno> aLegendaryPengui: haskell has a lot of extensions and options, and there a lot of knowlegable people here who know a lot about them and are helpful.
00:23:39 <jedai> dolio: I just want him to be aware of the existence of TF, even if eventually it's not the good solution in this case
00:24:22 <sjanssen> aLegendaryPengui: #haskell on freenode is just about the only Haskell IRC channel on the Internet, which explains part of it.  Also, we work hard at making #haskell a friendly and useful community
00:24:24 <zeno> jedai: thanks, reading the wiki on them.
00:24:35 <cpfr> is anyone in here familiar with the Text.JSON module
00:24:44 <zeno> dolio: yeah i want one type to determine the other two in this case.  that solution fixed all
00:24:54 <aLegendaryPengui> oh, you mean other languages typically have multiple servers?
00:25:10 <jedai> cpfr: Not really, but I had to help someone make an instance recently (it wasn't a particularly complicated instance though)
00:25:31 <cpfr> I am trying to fix some code
00:25:50 <cpfr> in older version JSRational only took a Rational as input
00:25:55 <cpfr> now it takes that and a Bool
00:25:58 <kadaver> hGetLine h; where h is a Handle, can I get the URL from where it was requested?
00:26:00 <cpfr> what does this Bool do?
00:26:37 <kadaver> Booleskan
00:27:08 <cpfr> ?
00:30:01 <jedai> cpfr: It seems to be True when it's a Float and only in this case, I have no idea how this is significant in any way
00:31:22 <Gracenotes> > '.':[]
00:31:23 <Gracenotes> > '.':[]
00:31:25 <lambdabot>   "."
00:31:25 <cpfr> thanks
00:31:25 <lambdabot>   "."
00:31:25 <Gracenotes> :/
00:31:51 <Gracenotes> kadaver: no reason to store the Handle's URL, I don't think
00:32:09 <vegai> glory to the new logo
00:32:24 <Gracenotes> or do so in a tuple or datatype
00:32:34 <Gracenotes> a URL is encoded into the HTTP layer of transport. TCP/sockets wouldn't know much about it.
00:32:46 <musekinin> That is no moon.
00:37:46 <kadaver> Gracenotes: ok but when  a user does a POST request I have to know the context(ie page) to choose the correct action...?
00:38:25 <Gracenotes> are you a client or a server?
00:39:32 <kadaver> client? a client is a user no?
00:39:35 <kadaver> im a webserver
00:39:56 <aLegendaryPengui> ima computr
00:39:59 <Gracenotes> if you're doing POSTs, then you need some mechanism of giving other scripts the information
00:40:15 <Gracenotes> if you're doing a simple file server, GETs should be all you need, afaik
00:40:38 <jedai> kadaver: You usually receive the URL asked of you in the request...
00:40:50 <Gracenotes> either way, you should definitely do some parsing
00:42:43 <Gracenotes> generally it's in the first line, GET /path/to/file HTTP/1.1
00:43:18 <Gracenotes> starting from a 'web directory'.
00:43:42 <Gracenotes> also, for caching, it seems that there's http://hackage.haskell.org/cgi-bin/hackage-scripts/package/memcached-0.1.1
00:44:01 <Gracenotes> added, in fact, not even a week ago
00:44:25 <kadaver> haskell explode in ya face
00:44:29 <Gracenotes> squid is possibly on another level, runs independently of whether the server uses Haskell/whatever
00:44:40 <Gracenotes> *ble
00:44:56 <kadaver> seems haskell is moving at high speed these days
01:34:45 <kadaver> @faq can Haskell Curry kill a C-programmer with his bare hands?
01:34:45 <lambdabot> The answer is: Yes! Haskell can do that.
01:46:40 <zeno> kadaver: lols me that after you said its high speed nooone talks for an hour XD
01:48:42 <kadaver> yes
01:50:31 <SubStack> yay
01:50:49 <SubStack> finally got that pesky fragment shader to work in glsl under haskell's glut bindings
01:51:11 <SubStack> set the source texture as a Index0 GLsizei type which was totally not obvious
01:51:44 <Workybob> heh, just as well I know more than 1 person working on how to do shaders properly in Haskell
01:52:04 <Workybob> (yay for writing GPU code in pure haskell)
01:52:25 <SubStack> well the shaders are still C-ish, but all the scaffolding is haskell
01:52:39 <Ralith> Is there a way to force a garbage collection to occur at a specific point, or forcibly delete something?
01:52:42 <SubStack> wrapping around the C will probably be my next project
01:54:43 <SubStack> Ralith: you could probably just use Foreign.Marshall.Alloc and putz about with memory from there
01:55:34 <Ralith> SubStack: it's data I got from a library, rather than created myself, so I'm hesitant to do stuff at a low level for fear of accidently circumventing things.
01:56:54 <SubStack> you do want to forcibly delete something
01:58:54 <zeno> is this a bug? When ghc complains about not having many extnstions enabled it tells you to use XFunctionalDependencies, when the real thing you need is FunctionalDependencies
01:59:17 <Ralith> I'm not familiar with the module you name, so I'm not sure just how external to Haskell the act would be.
01:59:55 <zeno> lots of times it tells you to use XFOO when you need Foo
01:59:59 <Ralith> but is there no similar internal functionality?
02:01:27 <SubStack> zeno: lots of switches to ghc start with X
02:01:40 <SubStack> -XFoo
02:01:58 <SubStack> there's also that other comment style way that I forget how to use
02:02:13 <Ralith> {-# Foo #-} iirc
02:02:23 <SubStack> that's the one
02:02:33 <Ralith> no wait
02:02:37 <Ralith> {-# LANGUAGE Foo #-}
02:02:46 <SubStack> something like that anyways
02:02:49 <SubStack> coffee time!
02:05:24 <osfameron> heh, I like the haskell logo on airplane
02:06:01 <idnar> SubStack: stop! collaborate and listen!
02:06:03 <Ralith> ?
02:07:02 * SubStack draws up some flow charts
02:08:27 * wli is trying to figure out how to declare data types with weird mix and match stuff.
02:13:07 <quicksilver> @seen conal
02:13:07 <lambdabot> I saw conal leaving #haskell and #ghc 3h 44m 48s ago, and .
02:13:18 <kadaver> i have a weird problem, when i run my webserver from ghci it works fine but when  compiel and run it it doesnt load the file. is there some weirdo thing with serving html from files?
02:13:39 <kadaver> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2845#a2845
02:15:27 <quicksilver> "it doesn't load the file"
02:15:32 <sinelaw> what's that function in lambdabot that finds the rule in a series?
02:15:33 <quicksilver> can you explain the symptom more clearly?
02:16:14 <kadaver> quicksilver: nothing happens at 8080, it jsut sits there the page doesnt appear to load at all
02:22:00 <mmorrow> , let bits x = fmap ((".o"!!) . (.&.1) . (x`shiftR`)) [0..bitSize(x)-1] in bits 98276984573
02:22:02 <lunabot>  "o.oooooo.oo...oooo....ooo....ooo"
02:22:47 <mmorrow> (a nice way to see bitmaps)
02:24:48 <mmorrow> , let bits x = fmap ((".o"!!) . fromIntegral . (.&.1) . (x`shiftR`)) [0..fromIntegral(bitSize(x)-1)] in bits (98276984573::Word64)
02:24:49 <lunabot>  "o.oooooo.oo...oooo....ooo....ooo.oo.o..........................."
02:26:58 <wli> I've found myself wanting things like Word128, Word256, etc., and also quad-precision etc. floats.
02:29:19 <opqdonut> wli: there's a largeword library somewhere
02:29:26 <opqdonut> trying to find it
02:30:46 <quicksilver> kadaver: did you compile with -threaded
02:30:52 <Ralith> wli: there's no libgmp wrapper?
02:33:50 <wli> Ralith: The libgmp wrapper was what I was hoping for.
02:34:04 <Ralith> huh?
02:34:28 <kadaver> quicksilver: no
02:35:08 <wli> Ralith: For the large fixed-precision floats and words.
02:35:14 <Ralith> yeah
02:35:16 <Ralith> does it exist or not?
02:35:34 <wli> Ralith: I doubt it.
02:35:41 <Ralith> that seems odd
02:35:47 <Ralith> given how it's what Integer's from.
02:35:57 <Ralith> (right?)
02:36:08 <Ralith> (I know libgmp is a ghc dep)
02:36:17 <Ralith> wli: well, write one!
02:36:23 <Ralith> either that or wrap Integer.
02:36:26 <wli> Ralith: I think people choke on the supporting intrinsics, but maybe I'm imagining an issue that's not there.
02:36:35 <quicksilver> it's harder than it should be.
02:36:42 <kadaver> quicksilver: what does -threaded do? I mena I understand it allows me to run multithreaded programs(it works now) but why does that have to be told to the compiler?
02:36:53 <quicksilver> two different RTSes.
02:41:35 <HugoDaniel> :)
02:41:43 <HugoDaniel> whats the status on the sdl binding ?
02:42:15 <Steven_M> hi all
02:42:27 <HugoDaniel> nvidia just released opengl 3.1 beta drivers... im guessing glut passed way, since there is no support for opengl 3 context windows
02:43:31 <HugoDaniel> im shifting jobs now, so ill be coding a lot of python instead of haskell
02:43:55 <quicksilver> kadaver: off-hand I don't see why your code requires -threaded.
02:43:59 <quicksilver> I'm probably being stupid.
02:44:14 <HugoDaniel> python seems so 1990 compared to haskell :/
02:44:35 <HugoDaniel> haskell seems like 2010, and python seems like 1990
02:44:52 <HugoDaniel> oh well, enough rant, time to work
02:45:24 <quicksilver> Ralith, wli : because of the way gmp is tightly integrated with the RTS, particularly memory management, exposing extra functions requires new GHC prims. I"m not sure why.
02:45:24 <kadaver> why doesnt my appplication shut down when i do Ctrl-c in the command prompt?
02:46:01 <kadaver> quicksilver: what do you mean? why i need threads at all?
02:46:01 <kadaver> forkIO (handle sock)
02:46:14 <quicksilver> kadaver: you don't need -threaded to use threads in general.
02:46:19 <kadaver> ok
02:46:22 <quicksilver> you only need it for FFI calls not to block.
02:46:38 <quicksilver> apparently it's a windows/GHC "issue" that you need -threaded to use accept
02:46:53 <quicksilver> on a real OS your code wouldn't have needed -threaded.
02:47:20 <kadaver> lol
02:49:25 <pao> what is the syntactical meaning of tilde in "infZipWith f ~(x:xs) ~(y:ys) = f x y : infZipWith f xs ys"?
02:49:35 <Ralith> quicksilver: couldn't GMP be worked with outside of GHC entirely, via C bindings?
02:50:53 <RayNbow> pao: lazy match
02:51:17 <quicksilver> Ralith: you can't link the same library twice.
02:51:22 <quicksilver> not easily.
02:51:28 <Ralith> libdl.
02:51:29 <pao> RayNbow: is that haskell 98?
02:51:30 <RayNbow> http://www.haskell.org/tutorial/patterns.html <-- pao, section 4.4
02:51:46 <pao> RayNbow: thanks a lot, very helpful
02:51:46 <quicksilver> Ralith: yes, true.
02:51:58 <quicksilver> Ralith: it would then be hard to make them interact with standard language Integers.
02:52:07 <Ralith> true.
02:52:07 <quicksilver> Ralith: still it would be great if someone tried it.
02:52:23 <Ralith> it would be even better if somebody gave ghc full support of all gmp features :D
02:52:23 <quicksilver> it's always bugged me that we use GMP and fail to bind some of it's important fast functions.
02:52:24 <RayNbow> pao: basically, a lazy pattern always matches, but delays the deconstruction
02:53:07 <pao> RayNbow: ... and when evaluation is required and pattern doesn't match -> bottom, right?
02:53:33 <RayNbow> indeed
02:53:47 <Ralith> RayNbow: in a practical sense, how does that differ from normal behavior?
02:54:04 <quicksilver> Ralith: I think one reason that the GHC team haven't worked on binding more of GMP is they want to move away from GMP
02:54:10 <Ralith> why's that?
02:54:27 <doserj> > let f (x:xs) = 1 in f []
02:54:28 <lambdabot>   * Exception: /tmp/3046428070810289746:71:40-51: Non-exhaustive patterns in ...
02:54:32 <doserj> > let f ~(x:xs) = 1 in f []
02:54:33 <lambdabot>   1
02:54:35 <doserj> > let f ~(x:xs) = x in f []
02:54:37 <lambdabot>   * Exception: /tmp/7431748095893887266:71:36-48: Irrefutable pattern failed ...
02:54:42 <quicksilver> Ralith: I'm not sure. Licensing maybe?
02:55:00 <Ralith> what's gmp under?
02:55:10 <Ralith> I thought it was fairly liberal.
02:55:13 <ivanm> LGPL, IIRC
02:55:16 <Steven_M> I've downloaded two .tar.gz's from http://hackage.haskell.org/ Is there anywhere on the website where I can find md5sums for their .tar.gz's?
02:55:21 <quicksilver> Ralith: http://hackage.haskell.org/trac/ghc/wiki/ReplacingGMPNotes
02:55:25 <ivanm> which means you have to be able to replace it, IIRC
02:55:43 <ivanm> Steven_M: well, you can probably find the md5's for them if they have haskell ebuilds
02:55:52 <RayNbow> pao: see doserj's examples :)
02:55:55 <ivanm> IIRC, look in code.haskell.org/gentoo-haskell/
02:56:35 <pao> RayNbow: doserj: thanks to both
02:56:45 <ivanm> actually, i'ts code.haskell.org/gentoo/gentoo-haskell/ (you'll find most of them under the dev-haskell category); the Manifest files have the md5s in them
02:58:43 <Steven_M> ivanm: wouldn't the ebuild md5 be different from the .tar.gz md5?
02:59:00 <ivanm> Steven_M: they'll contain the .tar.gz md5s as well
02:59:28 <ivanm> actually, they use sha1 rather than md4
02:59:30 <ivanm> *md5
03:00:00 <pao> RayNbow: doserj: so basically "infZipWith  f ~(x:xs) ~(y:ys) = f x y : infZipWith f xs ys" can only be applied to infinite lists and is even "lazier" than the one without lazy patterns (even the first element thunk is not "generated"), correct?
03:00:38 <Steven_M> ivanm: ok, I'm not a gentoo user, when do I go for the info?
03:01:11 <Steven_M> ivanm: when=where
03:01:43 <pao> it would be very handy to have a tool to visualize and debug lazy evaluation... is there anything like that?
03:02:01 <ivanm> code.haskell.org/gentoo/gentoo-haskell/dev-haskell/<package name>/Manifest
03:02:04 <ivanm> look in the DIST lines
03:02:19 <ivanm> note that it will only contain those packages which we have ebuilds for (which is nowhere near all of them)
03:02:29 <ivanm> and that some mightn't be in dev-haskell (e.g. darcs is in dev-util)
03:03:29 <Steven_M> ivanm: ok thanks :)
03:03:37 <ivanm> no worries
03:04:27 <doserj> > let infZipWith f ~(x:xs) ~(y:ys) = f x y : infZipWith f xs ys in infZipWith const [1..] []
03:04:29 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
03:05:16 <doserj> pao: if the function to zip with is non-strict in one argument, you can even use non-infinite lists
03:06:07 <doserj> > let infZipWith f ~(x:xs) ~(y:ys) = f x y : infZipWith f xs ys in infZipWith (const (const 1)) [] []
03:06:08 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
03:06:44 <RayNbow> http://www.haskell.org/haskellwiki/Maintaining_laziness <-- this wiki page contains another example of using ~
03:08:04 * wli mostly uses ~ to shut up warnings about incomplete pattern matches in cases where the pattern is known a priori to always match.
03:08:16 <pao> doserj: yep... but is that true that, with infinite lists and strict f, the differece of the two version (lazy pattern vs strict pattern) is minimal? you only delay the creation of the thunk for the first element, right?
03:09:33 <pao> ... I'm talking about infZipWith
03:10:34 <doserj> pao: the difference is just when which evaluation happens, yes.
03:11:13 <pao> RayNbow: thank you for the wiki link
03:13:03 <kadaver> hey I heard you like kadavers so I put a kadaver in your fridge
03:15:25 <Sparky_> DCC SEND "0101010101010101" 0 0 0
03:16:35 <ivanm> Isn't a tuple an instance of Arrow?
03:17:30 <ivanm> @instances Arrow
03:17:31 <lambdabot> (->), Kleisli m
03:20:32 <bastl1> Hi. I have a list of records, and want to List.find an element that matches a component of the record. how can i do that?
03:21:29 <quicksilver> bastl1: find (\x -> (fieldname x) == bar)
03:21:41 <quicksilver> or find ((== bar) . fieldname)
03:21:44 <quicksilver> if you like being cute :)
03:21:52 <bastl1> quicksilver: thanks
03:22:55 <ivanm> quicksilver: but what happens if he prefers (bar ==) to (== bar) ?
03:22:56 <ivanm> ;-)
03:24:00 <quicksilver> ivanm: no.
03:24:34 <quicksilver> ivanm: although I think you could do Pointed a => Arrow (a,b)
03:24:44 <quicksilver> it's not a very useful instance I don't think
03:24:58 <ivanm> oh.... so how come stuff like (***) works on tuples?
03:25:04 <ivanm> @type (***)
03:25:05 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
03:26:18 <quicksilver> because *** is all about tuples :)
03:26:22 <quicksilver> (,) isn't the arrow, there
03:26:25 <quicksilver> "a" is the arrow.
03:30:55 <temoto-wd> @src .
03:30:55 <lambdabot> (f . g) x = f (g x)
03:31:03 <temoto-wd> @src $
03:31:04 <lambdabot> f $ x = f x
03:31:14 <temoto-wd> hm
03:32:16 <temoto-wd> (f . g) x = f $ g x   ?
03:33:47 <andun> temoto-wd: yes.
03:34:23 <temoto-wd> What's difference between them then?
03:34:27 <temoto-wd> . and $
03:34:42 <andun> (f . g) x /= (f $ g) x
03:34:46 <quicksilver> temoto-wd: . composes two functions.
03:34:56 <quicksilver> temoto-wd: $ applys a function to a value.
03:34:57 <temoto-wd> Yeah, composition and application.
03:35:08 <quicksilver> the interesting equation is this:
03:35:18 <temoto-wd> But i'm stuck at minding real-world example of difference.
03:35:18 <quicksilver> a $ b $ c $ d $ e = a . b . c . d $ e
03:35:20 <quicksilver> BUT
03:35:23 <temoto-wd> omg
03:35:25 <quicksilver> you need to understand that carefully.
03:35:31 <quicksilver> the bracketing is the other way around
03:35:37 <quicksilver> (.) is left assoc and ($) is right assoc
03:35:40 <quicksilver> that's why it works.
03:35:44 <quicksilver> with full brackets, the example is :
03:35:48 <temoto-wd> Aha, that's the difference.
03:36:06 <quicksilver> a $ (b $ (c $ (d $ e))) = (((a.b).c).d) e
03:36:29 <quicksilver> the . example builds up a complex function, and then applies it to e
03:36:36 <quicksilver> the $ example applies functions one-by-one to e
03:36:44 <quicksilver> it's the same result, acheived two different ways.
03:37:06 <temoto-wd> Thank you very much.
03:37:10 <andun> note that 'map (sqrt . abs)' works, but with $ it becomes 'map (\x -> sqrt $ abs x)' because it needs the value
03:39:04 <temoto-wd> andun: thanks, that's real world example i was suffering :)
03:39:47 <Eridius> it's all pointless
03:39:56 <Eridius> @pl \x -> sqrt $ abs x
03:39:56 <lambdabot> sqrt . abs
03:39:58 <quicksilver> ;)
03:40:11 <Ferdirand> is there a reason why (.) would be left assoc rather than right assoc ?
03:40:32 <temoto-wd> Given that haskell is lazy-lazy, composition and application may result in same executed code, right?
03:40:52 <Eridius> temoto-wd: no idea, but pointfree style is often cleaner
03:41:09 <Eridius> Ferdirand: . is actually right-assoc
03:41:12 <Eridius> infixr 9 .
03:41:23 <Saizan> GHC inlines both away if they are fully applied, i assume
03:42:20 <Eridius> . must be right-assoc or (a . b . c . d $ e) would be invalid
03:42:23 <ivanm> quicksilver: so what is the arrow in that case? :s
03:42:34 <Saizan> ivanm: (->)
03:42:34 <dbbddbdb> > test
03:42:35 <lambdabot>   Not in scope: `test'
03:42:49 <dbbddbdb> > [x | x <- [0..10], then take 1]
03:42:50 <lambdabot>   <no location info>: parse error on input `then'
03:43:03 <Eridius> > (succ *** pred) (1,2)
03:43:04 <lambdabot>   (2,1)
03:43:14 <Eridius> dbbddbdb: what are you trying to do?
03:43:25 <dolio> > let infixl 9 . ; f . g = \x -> f (g x) in sum . map (+1) . negate $ [1..10]
03:43:27 <lambdabot>       No instance for (Num [a])
03:43:27 <lambdabot>        arising from a use of `negate' at <int...
03:43:33 <dolio> > let infixl 9 . ; f . g = \x -> f (g x) in sum . map (+1) . map negate $ [1..10]
03:43:33 <dbbddbdb> Eridius: nothing, sir!
03:43:34 <lambdabot>   -45
03:43:39 <Eridius> o_O
03:44:29 <dbbddbdb> :t (***)
03:44:29 <Eridius> > let infixl 9 . ; f . g = \x -> f (g x) in (+2) . (-1) $ 3
03:44:29 <dolio> Mixing infixl and infixr operators is only a problem when they have the same precedence.
03:44:30 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
03:44:31 <lambdabot>       No instance for (Num (a1 -> a))
03:44:31 <lambdabot>        arising from a use of `negate' a...
03:44:33 <dbbddbdb> :t (<*>)
03:44:34 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
03:44:40 <dolio> Which (.) and ($) do not.
03:44:49 <dbbddbdb> :t let fap = (<*>) in fap.fap.fap
03:44:50 <lambdabot> forall a a1 b. (a -> a1 -> b) -> (((a -> a1) -> a) -> a -> a1) -> ((a -> a1) -> a) -> b
03:44:51 <Eridius> dolio: oh yeah, good point
03:44:59 <Eridius> dolio: I'm a bit fuzzy tonight
03:45:15 <dbbddbdb> :i (***)
03:45:18 <Saizan> (.) is infixr for the same reason (++) is infixr
03:45:19 * Eridius was thinking ($) was 9, for some strange reason
03:45:30 <Eridius> Saizan: it makes no difference logically, but it's an optimization?
03:46:07 <Saizan> yeah
03:46:09 <quicksilver> ivanm: which case?
03:46:25 <Saizan> though i don't know how much it matters for (.)
03:46:49 <quicksilver> Eridius: that's not true (. must be right assoc or (a.b.c.d$e) wouldn't be valid)
03:47:07 <quicksilver> Eridius: it could be valid simply because . had a higher precedence.
03:47:18 <Eridius> quicksilver: dolio already pointed out my folly
03:47:18 <quicksilver> oh, doli just said that
03:47:24 <Eridius> for some reason I was thinking ($) had the same precedence as (.)
03:47:29 <quicksilver> serves me right for replying to old messages without reading new ones.
03:47:33 * Eridius chuckles
03:47:38 <quicksilver> still of course (.) is truly assocatiave
03:47:41 <quicksilver> so it doesn't matter.
03:47:48 <quicksilver> so my explanation was a bit clumsy.
03:48:09 <quicksilver> it is important that the (.) gets parenthesised "away from" the $
03:48:10 <Eridius> is there any way to search for operators based on fixity? I'm wondering what other operators have precedence level 9 and what association they are
03:48:13 <quicksilver> it doesn't matter which way around.
03:48:38 <dbbddbdb> :t a.b.c.d$e
03:48:40 <lambdabot>     Couldn't match expected type `b -> c' against inferred type `Expr'
03:48:40 <lambdabot>     In the first argument of `(.)', namely `a'
03:48:40 <lambdabot>     In the first argument of `($)', namely `a . b . c . d'
03:49:00 <dbbddbdb> :t a.b.c.(d$e)
03:49:01 <lambdabot>     Couldn't match expected type `b -> c' against inferred type `Expr'
03:49:01 <lambdabot>     In the first argument of `(.)', namely `a'
03:49:12 <Eridius> does lambdabot treat all unknown identifiers as Expr, or does it just have that for all one-character alphabetic symbols?
03:49:27 <Eridius> dbbddbdb: you're running afoul of a trick lambdabot uses that makes other things easier
03:49:39 <Eridius> @pl \e -> a $ b $ c $ d $ e
03:49:39 <lambdabot> a . b . c . d
03:50:04 <Saizan> single letters, there's a fixed list exported from a module
03:50:24 <Saizan> :t f . g . h $ e
03:50:26 <lambdabot>     Ambiguous type variable `c' in the constraints:
03:50:26 <lambdabot>       `SimpleReflect.FromExpr c'
03:50:26 <lambdabot>         arising from a use of `g' at <interactive>:1:4
03:50:32 <dbbddbdb> :t aa
03:50:33 <lambdabot> Not in scope: `aa'
03:50:49 <Eridius> heh
03:51:12 <dbbddbdb> Eridius: when is this trick useful?
03:51:23 <Eridius> dbbddbdb: I just gave an example with the @pl command
03:51:37 <Eridius> although I'm not certain that relies on Expr
03:51:44 <Eridius> @pl \e -> aa $ bb $ cc $ dd $ e
03:51:44 <lambdabot> aa . bb . cc . dd
03:51:47 <Eridius> ah, apparently it doesn't
03:51:53 <Eridius> but I'm sure it's useful in other places
03:52:11 <Eridius> :t f
03:52:12 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
03:52:13 <dbbddbdb> «@pl» is «make this pointfree»?
03:52:19 <Eridius> dbbddbdb: yeah
03:52:27 <dbbddbdb> @pl f a b = a + b
03:52:27 <lambdabot> f = (+)
03:52:29 <Eridius> quite handy
03:52:31 <dbbddbdb> Cool
03:52:35 <Eridius> @pl \_ b -> b
03:52:35 <sinelaw> what's that function in lambdabot that finds the rule in a series?
03:52:35 <lambdabot> const id
03:52:51 <Saizan> sinelaw: @oeis
03:52:55 <sinelaw> thanks
03:53:02 <Eridius> hrm, isn't flip const the more common way of doing what I just @pl'd?
03:57:12 <quicksilver> Eridius: I think the best way of expressing that is (\_ x -> x)
03:57:26 <Eridius> quicksilver: not really any shorter than flip const
03:57:36 <quicksilver> Eridius: it's fewer characters than flip const, a very similar number to const id, and much easier to read.
03:57:39 <kadaver> @pl \a -> a+1
03:57:39 <lambdabot> (1 +)
03:57:44 <Eridius> flip const has more semantic meaning though
03:57:55 <quicksilver> what?
03:57:58 <quicksilver> in what way?
03:58:01 <Eridius> once you wrap your brain around it, "flip const" suddenly reads as "a function that's constant on its second input rather than its first"
03:58:17 <quicksilver> sure, but (\_ x->x) does that with no brain wrapping at all.
03:58:24 <quicksilver> lambda notation is concise, easy to read, and precise.
03:58:32 <Eridius> maybe, but I have a fondness for pointless style
03:58:41 <quicksilver> so do I, but only when it's better.
03:58:50 <Eridius> @let coonst = flip const
03:58:52 <lambdabot>  Defined.
03:58:55 <Eridius> @pl \_ b -> b
03:58:55 <lambdabot> const id
03:58:57 <kadaver> @pl \a -> a+1
03:58:57 <Eridius> bah
03:58:57 <lambdabot> (1 +)
03:59:00 <Eridius> BAH, I say!
03:59:03 <kadaver> @src pl
03:59:03 <lambdabot> Source not found. Wrong!  You cheating scum!
03:59:05 <Eridius> haha
03:59:12 <Eridius> kadaver: go read the lambdabot source
03:59:18 <Saizan> Eridius: @pl has fixed rewriting rules.
03:59:22 * Eridius prefers succ to (1+)
03:59:29 <Eridius> Saizan: yeah I figured, I was just hoping
04:01:20 <RayNbow> > let (++) = succ in (3++)  -- postfix increment, yeah! :p
04:01:22 <lambdabot>   4
04:01:23 * RayNbow hides
04:01:50 <Eridius> > let (++) = succ in (++3)
04:01:51 <lambdabot>       Overlapping instances for Show ((t -> t1) -> t1)
04:01:51 <lambdabot>        arising from a ...
04:01:53 <Eridius> hrm
04:02:36 <RayNbow> postfix operators is a GHC extension
04:03:11 <kadaver> @pl \a -> a+1
04:03:11 <lambdabot> (1 +)
04:03:19 <kadaver> @pl \a -> 1+a
04:03:19 <lambdabot> (1 +)
04:03:24 <RayNbow> http://www.haskell.org/ghc/docs/6.10.1/html/users_guide/syntax-extns.html#postfix-operators <-- Eridius
04:03:26 <kadaver> @pl \a -> a**2+1
04:03:26 <lambdabot> (1 +) . (** 2)
04:03:31 <Eridius> Raynes: thanks
04:05:39 <RayNbow> Eridius: be careful with tab completion, there are 3 ray* nicks in this channel ;)
04:05:45 <Eridius> ack, you're right
04:05:55 <Eridius> 4 AM is a cruel mistress
04:07:09 <NightWalker^> I'm unsure about whether to learn haskell or ocaml first. From what I've read ocaml seems to be easier to get things done because it's not purely functional but that seems to me like trying to learn to ride a bike but never removing the stabilisers
04:07:23 <NightWalker^> Would haskell be a good choice as a first functional language?
04:07:41 <Eridius> LISP ;)
04:07:47 <Eridius> (or Scheme)
04:08:01 <kadaver> scheme or haskell i say
04:08:03 <NightWalker^> My goal is not so much initially to get things done, but to really become one with the functional way of programming and thinking
04:08:06 <Eridius> I played with OCaml for about 2 months, then decided to try Haskell and discovered that what people were saying about OCaml being a "more practical" language because of the lack of purity was just balony
04:08:24 <kadaver> I second Eridius
04:08:27 <quicksilver> NightWalker^: haskell every time.
04:08:37 <kadaver> and ocaml has that ridic one notation for floats and one for ints
04:08:41 <NightWalker^> Yes. I think Haskell is probably very very powerful, but it'll take more time to get to grips and that oCaml is an easier path, but in the long run less powerful
04:08:41 <Eridius> OCaml makes it far too easy to work imperatively, whereas Haskell restricts imperative style to a very specific subset of the program, and even then it's not really imperative
04:08:50 <Eridius> kadaver: yeah, that's what irritated me enough to switch
04:08:53 <kadaver> and the O in ocaml is a pretty horrible addition imho
04:08:57 <Eridius> indeed
04:09:03 <Eridius> in my 2 months of toying with it I never used the O part
04:09:10 <quicksilver> things I hate about ocaml - constructors aren't functions and the value restriction.
04:09:12 <NightWalker^> I'm also interested in computational linguistics. Haskell will be obviously very good for it?
04:09:22 <quicksilver> both of those make it more painful than it should be to work with combinators.
04:09:23 <Eridius> although right now I'm doing some database stuff and I keep thinking having an O in Haskell might make it easier to write some sort of database abstraction
04:09:50 <sioraiocht> NightWalker^: that would depend
04:09:55 <NightWalker^> I'll definitely learn Haskell, oCaml and lisp at some point, but the question is what one to pick first to give me the best start
04:09:57 <sioraiocht> both on how you lke to think about things and what you are doing in CL
04:09:57 <Eridius> quicksilver: I never quite grokked the value restriction, though now that I know more about this stuff, could you give me a quick summary?
04:10:20 <Eridius> NightWalker^: if you're actually interested in the CS part, Haskell is probably the most interesting
04:10:23 <sioraiocht> NightWalker^: learning lisp is a lifetime project
04:10:23 <NightWalker^> sioraiocht: Just now chat bots, but I'm interested in most aspects of CL. Translators are interesting
04:10:26 * wli I think extensible records and variants would make a lot of sense, mostly variants (I can't think of use cases for records).
04:10:30 <Eridius> although if you've never done anything functional at all, Scheme is probably the easiest to start with
04:10:42 <NightWalker^> So Scheme is easier, but Haskell would be more rewarding if I give it the time?
04:10:45 <sioraiocht> NightWalker^: I find lua very useful for CL
04:11:11 <sioraiocht> NightWalker^: I think Haskell is the "prettiest", and you'll get less caught up in syntax, that way
04:11:18 <sioraiocht> esp if you are comfortable with mathematical notation
04:11:27 <sioraiocht> but scheme is the easiest with no type system, and symbols
04:11:29 <NightWalker^> Yes, I am. I like mathematical notation and that way of thinking
04:11:39 <NightWalker^> It seems very natural to me
04:11:43 <wli> My perspective is probably bizarre because Standard ML was my first FP language, never mind the rest of my background.
04:12:02 <sioraiocht> wli: Mine was Haskell, but I did OCaml but never warmed up to it
04:12:18 <sioraiocht> and Scala can go...do several unspeakable things to itself...as far as I am concerned
04:12:19 <mmorrow> wli> I've found myself wanting things like Word128, Word256, etc., and also quad-precision etc. floats.
04:12:19 <quicksilver> Eridius: you can't have polymorphic values
04:12:20 <NightWalker^> Haskell seems to have a very good community too
04:12:24 <mmorrow> wli: me too
04:12:26 <Eridius> quicksilver: oh
04:12:31 <Eridius> quicksilver: that seems like a pretty big restriction
04:12:31 <quicksilver> Eridius: if you want it to be polymorphic it has to be syntactically a 'function'
04:12:36 <quicksilver> Eridius: that is, it has to have a visible parameter
04:12:38 <Eridius> ahh, now that sounds familiar
04:12:42 * Eridius stabs OCaml
04:12:48 <Saizan> \() ->
04:12:51 <Eridius> quicksilver: what is the reason for this restriction?
04:12:57 <quicksilver> Eridius: side effects and shit.
04:12:57 * wli misses ML modules so badly it hurts on a daily basis.
04:13:04 <Eridius> quicksilver: ok
04:13:05 <quicksilver> and sharing.
04:13:08 <sioraiocht> NightWalker^: we're not bad =) you are more likely to get too many answers to a question than too few
04:13:15 <quicksilver> it's very closely related to the monomorphism restriction in haskell
04:13:17 <Eridius> quicksilver: is it related to the monomorphism restriction?
04:13:18 <Eridius> haha
04:13:20 <quicksilver> but it's even more restrictive
04:13:21 <NightWalker^> Yes, that's always a good thing
04:13:21 * wli wants ML modules basically everywhere.
04:13:23 <quicksilver> because of side effects
04:13:33 <Eridius> stupid impure language...
04:13:47 <NightWalker^> Different perspectives allow one to come to their own conclusion based on their own circumstances etc
04:14:05 <mmorrow> Ralith: the issue with gmp and the rts is that ghc passes gmp function ptr that it uses to allocate memory _in the haskell heap_
04:14:06 <NightWalker^> There is no 1 answer for all in almost anything
04:14:14 <mmorrow> *function ptrS
04:14:23 <NightWalker^> My gut feeling tells me to go with Haskell anyway, so that's probably what I'll go for
04:14:32 <Saizan> consider: ref :: a -> Ref a; write :: a -> Ref a -> (); read :: Ref a -> a; let r = ref id in write not r; read r 1
04:14:32 <mmorrow> (allocate and free and a third one i don't recall)
04:14:33 <Eridius> wow, SQLite3 doesn't support RIGHT JOIN?
04:14:40 <sioraiocht> NightWalker^: I found the initial learning curve for haskell fairly easy
04:14:45 <mmorrow> (probably realloc)
04:14:52 <NightWalker^> sioraiocht: That's reassuring :-)
04:16:18 <temoto-wd> :t -
04:16:19 <lambdabot> parse error (possibly incorrect indentation)
04:16:23 <temoto-wd> :t (-)
04:16:24 <lambdabot> forall a. (Num a) => a -> a -> a
04:16:37 <temoto-wd> How to know infix for operator?
04:16:43 <temoto-wd> i mean command for lambdabot
04:16:54 <vixey> lambdabot doesn't have that command
04:17:00 <wli> My first impression of Haskell was that it was an ML variant distinguished by not much more than lacking the module system. As I got to doing more intra-module affairs its advantages within individual modules became apparent.
04:17:06 <sioraiocht> NightWalker^: and haskell is good for chat bots, but so is Erlang, imo
04:17:14 <temoto-wd> How to know infix of operator in ghci?
04:17:31 * NightWalker^ nods
04:17:40 <sioraiocht> temoto-wd: Sorry, I don't your question
04:17:49 <Eridius> temoto-wd: you mean fixity?
04:18:05 <sioraiocht> damn, I mean I don't UNDERSTAND your question
04:18:06 <sioraiocht> the irony...
04:18:07 <Eridius> temoto-wd: just ask ghci for :i operator
04:18:12 <wli> So even though I picked it up before H98 came to town, I didn't start favoring it over ML until 2000 or so.
04:18:14 <Eridius> sioraiocht: you accidentally the question?
04:18:14 <sioraiocht> :i (+)
04:18:23 <Eridius> sioraiocht: don't think lambdabot supports this
04:18:34 <sioraiocht> bummer
04:18:35 <temoto-wd> uh.. i mean how to know operator precedense value and associativity (left/right/_)
04:18:42 <Eridius> temoto-wd: fire up ghci and ask it
04:18:47 <Eridius> with the same command sioraiocht just tried to run
04:18:58 <temoto-wd> Yeah :i yields what i need, thanks.
04:19:14 <wli> To this day, Haskell's lack of a module system still makes me cry.
04:19:23 <sioraiocht> wli: lol
04:19:49 <Eridius> wli: I don't recall how OCaml's module stuff worked. what are you missing?
04:20:03 <wli> Not kidding, though.
04:20:04 <temoto-wd> wli: Doesn't haskell have modules?
04:20:05 <gal_bolle> functors
04:20:14 <quicksilver> it doesn't have ML-style modules.
04:20:29 <quicksilver> haskell modules are just a rather simple minded namespace / hiding system.
04:20:30 <wli> Eridius: Did you miss all the parameters modules take, the signatures, and so on?
04:21:05 <Eridius> wli: signatures sound vaguely familiar. I only toyed with OCaml, never actually used it for much besides Project Euler
04:21:42 <Eridius> although I do recall some interesting stuff about, e.g. the Hashtable module (or whatever it was called)
04:21:52 <Eridius> and defining my own module name that was really just a concrete hashtable
04:22:29 <wli> It's pretty crude even on the namespace front; you can't import modules locally to expressions etc., which is helpful when you would like e.g. global qualification and local open imports.
04:22:34 * Eridius is reading the ocaml manual on the module system, don't think I ever actually did anything with functors
04:23:53 <quicksilver> wli: the qualification stuff isn't composable either
04:23:58 <quicksilver> wli: you can't re-export qualified
04:24:06 <quicksilver> it feels like there are gaps in the setup
04:24:14 <quicksilver> although I don't have a concrete proposal on how to improve it.
04:25:04 <wli> There are gaps all over the place, but it's light years ahead of the doorstop things are saddled with now.
04:26:08 <quicksilver> wli: sorry, I meant gaps in the current haskell system
04:26:21 <wli> I'm not sure qualified re-exports are on of them; the importer's the one that decides to qualify.
04:26:22 <quicksilver> quite independent of the desirability of having something better.
04:26:35 <quicksilver> well it's a composability failure.
04:26:39 <wli> Oh, yeah, there is that.
04:26:50 <quicksilver> I can't set up one module which sets up "quicksilver's favourite namespace"
04:27:17 <quicksilver> module Quicksilver (module Data.Sequence qualified as S, module Data.Map qualified as M, Data.Map(Map))
04:27:27 <quicksilver> it means if you are creating a very large library
04:27:39 <quicksilver> and you want to a smaller number of managable import points - convenience modules
04:27:44 <quicksilver> they can't use qualification inside.
04:27:55 <quicksilver> In turn, that means you can't "recommend" a particular qualification style onto your users.
04:28:18 <wli> Once you hit programming in the large you're in for pain without module system power.
04:28:20 <quicksilver> it would be nice to say "I intend to you to import this module qualified as BS., and if you import my convenience module that's exactly what you get
04:28:37 <quicksilver> I don't honestly think it's huge pain.
04:28:55 <quicksilver> C has jsut about no module system, and C++ has one that almost no one understands, let alone uses.
04:29:04 <quicksilver> adn the are definitely used for 'programming in the large'.
04:29:27 <quicksilver> am I wrong in thinking that both the linux kernel and the BSD kernel are large programs which have no module system support from their host languages?
04:29:38 <quicksilver> they just make do with naming conventions and mor-or-less discipline.
04:29:55 <quicksilver> that doesn't mean I wouldn't like something better :)
04:29:59 <wli> quicksilver: Linux experiences all kinds of pain from the modularity garbage.
04:30:31 <quicksilver> I think first-class ML modules would be a major implementation change for GHC
04:30:35 <quicksilver> I bet that's why they haven't been done.
04:30:53 <wli> quicksilver: If C++ namespaces have been extended to do anything nontrivial it's been in language revisions too recent for me to track.
04:30:57 <quicksilver> I think it would require  lot of thought not to break the current optimiser.
04:31:27 <quicksilver> however, I think you could add a formal notion of module signature in a fairly lightweight way.
04:31:38 <quicksilver> after all, ".hi" files already contain a module signature.
04:31:46 <quicksilver> it's just not present as a source-level feature.
04:32:02 <quicksilver> but ML-functors - modules with parameters - would be hard.
04:32:48 <wli> i.e. not per se, but for ghc's codebase?
04:33:05 <quicksilver> yes.
04:33:09 <quicksilver> for GHC's implementation decisions.
04:33:25 <quicksilver> relying heavily on a blend of separate compilation and aggressive cross-module inlining.
04:33:44 <wli> That sounds like trouble.
04:33:45 <quicksilver> of course everything gets easier if you just go for whole-program compilation.
04:33:54 <quicksilver> but that's probably not feasible.
04:34:05 <Peaker> quicksilver: C++ "module system" you mean its namespaces?
04:34:11 <quicksilver> Peaker: yes.
04:34:22 <Peaker> quicksilver: I wouldn't call that a "module system"... though it is pretty easy to understand
04:34:46 <quicksilver> it's pretty much as much of a module system as haskells :P
04:34:51 <quicksilver> and that's exactly the point I was making.
04:34:53 <wli> quicksilver: I'm thinking it mostly has to do with the communication protocol used for generated interface files.
04:34:55 <quicksilver> it isn't much of one.
04:36:09 <kadaver> scala felt like C++
04:36:30 <wli> You're basically doing whole-program compilation but by incrementally processing only whatever modules are specified in a given invocation and passing saved state around on the side.
04:36:37 <kadaver> but without pointers and having proper HOF , so better but still a kitchen sink
04:37:02 <vixey> scala does look like C++
04:37:08 <vixey> in terms of HUGEness
04:37:36 <wli> quicksilver: I can see how things get very fragile with respect to changes in that very quickly.
04:39:10 <wli> quicksilver: Now that I think about it I'm impressed that someone's actually done a quasi- whole-program compiler arranged to be incremental in such a manner.
04:39:13 * bremner predicts  scala's success on the basis that Haskell people dislike it :-)
04:39:22 <wli> quicksilver: Apart from SGI, that is.
04:39:50 * vixey thinks "Haskell for people that would really rather still be using Java"
04:40:12 <wli> quicksilver: MIPSpro CC is the first time I ever saw a whole program compiler that operated that way.
04:40:34 <wli> quicksilver: I'm just shocked I've been staring at one for so long without realizing it.
04:42:24 <quicksilver> GHC is a whole-program compiler with some crude heuristics to discard large chunks of the program at any particular time
04:42:30 <quicksilver> ;)
04:42:48 <quicksilver> those "crude heuristics" being, essentially, the converse of the inlining threshold.
04:47:04 <blackh> @tell dons http://www.moonpatio.com/fastcgi/hpaste.fcgi/view?id=1983#a1983  <-- progress on xml parser benchmarks
04:47:04 <lambdabot> Consider it noted.
04:50:31 <pejo> quicksilver, I only see the end of the discussion but your usage of whole-program compiler is quite unorthodox to me.
04:52:30 <NameAlreadyInUse> is this how a simple factorial function expands with lazy evaluation: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2846#a2846
04:52:34 <NameAlreadyInUse> or am i way off?
04:53:06 <vixey> NameAlreadyInUse: You didn't finish
04:53:54 <byorgey> NameAlreadyInUse: after expanding to  5 * fac (5-1), it actually has to evaluate the 5-1 because it needs to pattern-match it against the 0
04:54:21 <byorgey> so it goes  5 * fac (5-1) --->  5 * fac 4 ---> 5 * (4 * fac (4 - 1)) ---> ... and so on
04:54:47 <byorgey> but it doesn't do all the multiplications until the end
04:55:00 <NameAlreadyInUse> vixey: oh, i know, i was just wondering if what i have so far is correct
04:55:12 <NameAlreadyInUse> byorgey: so is pattern matching strict?
04:55:30 <byorgey> NameAlreadyInUse: for numbers it is.
04:55:50 <byorgey> NameAlreadyInUse: in general, if you pattern-match something, it is evaluated just far enough to be able to tell whether it matches the pattern.
04:56:24 <Peaker> NameAlreadyInUse: pattern-matching forces the computation of as little as needed to match that pattern -- in the case of Ints/Integers, you still have to match the whole thing.  There are other representations of numbers where you don't have to match the whole number
04:56:27 <byorgey> for example, if you pattern-match against a list with cases [] and (x:xs), it will be evaluated far enough to tell whether it is empty, or a cons... but the xs won't be evaluated yet.
04:56:55 <NameAlreadyInUse> byorgey: if i replaced the pattern match with an if then else, would it be different?
04:57:21 <byorgey> NameAlreadyInUse: no, if you're comparing a number with 0, that number has to be evaluated.
04:57:34 <wli> pejo: It's really my usage of it.
04:58:28 <pejo> wli, so although ghc is hiding a lot of information between modules, you still consider it a whole-program compiler?
04:58:45 <wli> pejo: Not in the derogatory fashion.
05:01:44 <wli> In all honesty, if I were going for some serious heavy-duty project where I had to do something I wouldn't have even tried something as ambitious as what ghc did; I would've just dumped bytecode representations of IR's.
05:01:52 <quicksilver> pejo: if you inline everything, it's a whole-program compiler.
05:02:07 <quicksilver> pejo: so it's a whole-program compiler except that it decides not to inline everything
05:02:11 <quicksilver> *shrug*
05:02:34 <quicksilver> well not quite whole-program, even then. But connected component or something.
05:02:58 <wli> It also has ways to avoid recompilation of unchanged modules, which is a big factor.
05:03:23 <wli> The distinction is a little fuzzy I guess.
05:03:32 <quicksilver> wli: except that any parts which are exported for inlining are indeed recompiled.
05:03:58 <quicksilver> wli: so in the extreme case (everything exported for inlinging) the only recompilation it 'avoids' is type-checking and data-types.
05:04:14 <quicksilver> none of this is intended as a criticism ;)
05:04:44 <wli> Once you're communicating enough info across per-module invocations it's really blurry.
05:04:56 <wli> I intend it as criticism, specifically, praise.
05:05:23 <wli> (which is counter to the usual connotation but never mind that)
05:05:31 <NameAlreadyInUse> byorgey: so if then else is also strict?
05:06:25 <byorgey> NameAlreadyInUse: It's strict in the test, since the test must be fully evaluated to either True or False.
05:06:40 <byorgey> but it's definitely not strict in the 'then' or 'else' parts
05:06:47 <byorgey> that's the whole point =)
05:07:12 <NameAlreadyInUse> byorgey: ok, i think i understand that
05:07:13 <byorgey> so if you write something like 'if x == 0 then ... else ...'
05:07:23 <byorgey> then it has to evaluate  x == 0, which means it has to evaluate x.
05:07:48 <wli> Most of the time the "whole-program compiler" thing is deriding the unnecessary re-processing of unchanged data where state could and should be saved in whatever fashion. Here we're giving kudos to ghc for passing enough state across invocations to do good optimizations.
05:07:58 <quicksilver> ah, that's not how I mean it.
05:08:18 <quicksilver> I mean "whole-program-compiler" as something you should aspire to - maximum information for optimisation - but can't acheive
05:08:27 <quicksilver> because of exponential complexity
05:08:37 <quicksilver> (of all kinds of different bits of the compilation process, typically)
05:10:01 <wli> I don't see exponential blowups anywhere not explicitly punted to reasonable-time approximations.
05:10:15 <dcoutts_> @seen sioraiocht
05:10:15 <lambdabot> sioraiocht is in #haskell. I last heard sioraiocht speak 50m 52s ago.
05:10:29 <quicksilver> wli: really? I thought it was generally accepted that all kinds of bits of compilation are exponential worst-case
05:10:37 <sioraiocht> hey dcoutts_
05:10:40 <dcoutts_> sioraiocht: I've got a chapter for you to read if you want :-) it's only 40 pages :-)
05:10:57 <quicksilver> wli: IIRC long string literals is one :)
05:11:03 <sioraiocht> dcoutts_: sure! I can read it tnight or tomorrow morning, if that's alright
05:11:09 <quicksilver> wli: although maybe it's only high order polynomial.
05:11:14 <dcoutts_> sioraiocht: but I hear you're doing the category theory exam at the moment
05:11:16 <quicksilver> wli: s/string literal/list literal/
05:11:18 <sioraiocht> indeed
05:11:28 <sioraiocht> but I have some time tomorrow
05:11:31 <wli> quicksilver: wtf??
05:11:31 <dcoutts_> sioraiocht: oh, no rush, I'm on holiday for two week from next week
05:11:37 <sioraiocht> oh okay! heh
05:11:44 <sioraiocht> yes, then send it to me whenever =)
05:11:52 <dcoutts_> sioraiocht: if you're that keen I'll give you another chapter ;-)
05:12:12 <dcoutts_> sioraiocht: especially since you're doing the category stuff :-)
05:12:23 <wli> quicksilver: How the heck do you get long list literals to do exponential blowup during parsing? Aren't they using happy-generated LR(1)?
05:12:33 <dcoutts_> sioraiocht: you can tell me if my explanations of the meaning of data and co-data makes any sense
05:13:16 <quicksilver> wli: I didn't say it was during parsing.
05:13:41 <wli> quicksilver: Okay, what phase has high complexity for list literals?
05:13:54 <quicksilver> I don't know
05:13:55 <sioraiocht> okie dokie!
05:14:01 <quicksilver> I'll try to find the trac
05:16:49 <quicksilver> can't find it. Odd.
05:16:52 <quicksilver> maybe I made the whole thing up.
05:17:17 <wli> quicksilver: (Actually, speaking of parsing, I think I've cooked up some moderately systematic methods for fixity declaration handling that may be pertinent to the sorts of languages we deal with here.)
05:17:39 <bastl1> how can i reverse the arguments of this lookup:  (!!) [1,2,3] 0  ?
05:18:03 <BONUS> > flip (!!) 0 [1, 2, 3]
05:18:04 <lambdabot>   1
05:18:39 <quicksilver> wli: http://hackage.haskell.org/trac/ghc/ticket/2346
05:18:43 <quicksilver> is a quadratic blowup.
05:18:49 <bastl1> BONUS: tx
05:18:54 <quicksilver> maybe I was talking rubbish about the existence of exponential blowups.
05:18:59 <quicksilver> but I thought there were some
05:19:14 <wli> Type inference, sure.
05:19:24 <ivanm> quicksilver: well, it's exponential for the case of n = 2 ;-)
05:20:12 <wli> You don't want to even try to do :t let u = (,) ; v = u . u ; w = v . v ; x = w . w ; y = x . x ; z = y . y in z
05:20:21 * quicksilver nods
05:20:28 <quicksilver> http://hackage.haskell.org/trac/ghc/ticket/830
05:20:31 <quicksilver> ^^ but that one is fixed.
05:21:47 <ivanm> have they fixed that weird long module name bug yet?
05:22:02 <quicksilver> it's an easter egg to punish java developers
05:22:14 <ivanm> heh
05:22:36 <quicksilver> yo dawg I heard you liked objects so I put a factory in your factory so you can instantiate while you instantiate, etc.
05:22:47 <yasha> hey
05:22:59 <wli> I think there are only really a few cases where that happens, and some of them are artifacts of how types are pretty-printed. That's not really exponential in any other way than the particular way the type is represented. If you do like e.g. some CAS's and heuristically use variable names for repeated common subexpressions of expressions that would otherwise be enormous, you can dodge that bullet.
05:23:27 <kadaver> you dawg I heard you like Java so I turned you into a cadaver
05:25:07 <HugoDaniel> so you can code while you rotten ?
05:25:29 <quicksilver> wli: ok, interesting.
05:30:57 <quicksilver> wli: http://hackage.haskell.org/trac/ghc/query?status=new&status=assigned&status=reopened&type=compile-time+performance+bug&order=priority
05:31:13 <quicksilver> wli: I don't know how those break down between 'hard to solve' and 'GHC implementation issue'
05:31:27 <wli> quicksilver: It's not all that much different from let u = () ; v = (u, u) ; w = (v, v) ; x = (w, w) ; y = (x, x) ; z = (y, y) in z and taking the results from show. In the heap it's not remotely exponential, but the string it generates has exponential length.
05:32:22 * quicksilver nods
05:32:41 <quicksilver> and any other similar traversal would be exponential time
05:32:51 <quicksilver> but if your use for it doesn't require a traversal like that
05:32:54 <quicksilver> it may not matter.
05:33:10 <quicksilver> unelss you need to generate an error message :)
05:33:18 <EvilTerran> you may be able to adapt what would be an exp-time traversal to be faster
05:33:29 <EvilTerran> if you can take advantage of the sharing somehow
05:34:04 <wli> Well, if you wanted a sub-exponential time algorithm, you'd have to represent the heap graph.
05:34:16 <EvilTerran> true
05:34:43 <wli> It's feasible for compiler error messages. Things like Read/Show doing so would need compiler magic.
05:42:59 <mmorrow> you can pull out the heap graph by doing a standard "reachable" on it, starting from (using wli's vars) 'z'
05:43:13 <mmorrow> (the hard part would be to get at the underlying ptrs)
05:43:44 <mmorrow> err, s/hard/easy once you figure out where they're stored/
05:44:55 <wli> You'd also have to keep some tables going so you know when you've hit something already there etc.
05:45:25 <wli> Basically you end up reconstructing let expressions from the heap graph.
05:45:42 <mmorrow> yeah, you just keep a seen set
05:46:33 <mmorrow> it's essentially doing a (copying) gc with that one object as root
05:47:17 <wli> When you dump things in such representations, you have a sort of language with let expressions, constructors, and primitive types.
05:47:27 <mmorrow> (but you'd probably just pull out a (Graph Ptr) rather than the actual heap nodes)
05:47:54 <mmorrow> [(Ptr, [Ptr])]
05:49:01 <wli> To pretty print I'd envision one would do some work on the graph to turn it into expressions of a language with let expressions, constructors, primitive types, and nothing else.
05:49:53 <wli> Just start off hash consed and inline anything that only occurs once.
05:53:31 <wli> SCC's come up right off the bat. From there I guess biconnected components might come up again.
05:58:02 <wli> Well, not quite. More like a sort of dual of biconnected components.
06:00:44 <wli> The bridgeless components of a graph.
06:01:33 <wli> A bridge is a graph from which the removal of any edge would increase the number of connected components.
06:04:48 <ziman> @hoogle [a] -> [a] -> [[a]]
06:04:49 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
06:04:49 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
06:04:49 <lambdabot> Data.List deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
06:04:56 <wli> There is probably no well-defined breakdown into such components and so some refinement of the concept may be necessary.
06:05:54 <b_jonas> hello! which function behaives like select but not blocking other ghc threads?
06:06:11 <quicksilver> wli: weaken the definition to bridge as "a bridge is a graph from which the removal of any edge would decrease the number of proper cycles" ?
06:06:28 <quicksilver> b_jonas: don't use it?
06:06:41 <quicksilver> b_jonas: just use the ordinary IO primitives
06:06:47 <quicksilver> (which call select behind the scenes)
06:06:54 <wli> quicksilver: Not sure if that would work. I wouldn't want to have to count proper cycles.
06:06:59 <b_jonas> quicksilver: yes, normally that would work, but let me explain
06:07:05 <Igloo> Who's responsible for hpaste?
06:07:37 <b_jonas> quicksilver: I'd like to make an interface for libcurl (either extending the existing cabal module curl or a new one) that supports running queries and doing other stuff in threads,
06:08:00 <b_jonas> libcurl supports this by having a callback and functions that give me fdmasks and a timeout to tell what curl wants to wait for
06:08:12 <wli> quicksilver: I would expect it not to work since it's meant to be applicable to DAG's.
06:08:31 <b_jonas> this way you can call curl back in a program with a select loop when it needs to wake up
06:08:38 <quicksilver> b_jonas: then probably you just want to use -threaded
06:08:44 <quicksilver> b_jonas: so that FFI calls don't block.
06:08:54 <b_jonas> quicksilver: yeah, that's one solution too
06:09:01 <b_jonas> :-(
06:09:05 <wli> quicksilver: e.g. let u = () ; v = (u, u) ; w = (v, v) ; x = (w, w) ; y = (x, x) ; z = (y, y) in z is a DAG.
06:09:45 <quicksilver> wli: *nod*
06:10:06 <quicksilver> wli: I think I was tangenting, I'd forgotten what you were talking about ;)
06:10:11 <b_jonas> quicksilver: ruby threads and perl coro have such an emulated select call so it is possible
06:10:16 <wli> quicksilver: You'd basically want to notice the two in-edges and refuse to expand the let on account of them.
06:10:41 <b_jonas> quicksilver: but because of the way haskell ffi works it's not easy to write one in C for haskell
06:12:16 <b_jonas> quicksilver: anyway, even threading might not be that easy to do
06:13:31 <b_jonas> the curl docs warn that the global init function has to be called while there's only one thread because it might call non-thread-safe libraries, so it might not even work even if you only call it from one thread only
06:13:37 <b_jonas> (like, it could chdir)
06:13:43 <b_jonas> how would I do that in haskell threads?
06:14:29 <b_jonas> must I call the init before I launch the ghc runtime or is it enough to call it while there's only one ghc thread?
06:15:34 <wli> That gives me some ideas wrt. let bindings elsewhere.
06:16:00 <b_jonas> quicksilver: still, threaded sounds like a good idea so thanks for the hint
06:17:34 <b_jonas> does ghc -threaded work well on all platforms, including modern linux and old linux?
06:17:51 <quicksilver> yes.
06:17:53 <b_jonas> thanks
06:20:29 <b_jonas> so I can use threaded, emulate select by waiting for the individual files, find out how ghc threading internals work to write an efficent thread-aware select, or find an existing library for this on cabal.
06:21:43 <b_jonas> and how do I wait for one handle without actually reading or writing to it?
06:21:51 <quicksilver> fork a thread which waits for it.
06:21:56 <quicksilver> or just call POSIX.select
06:22:59 <intuit> hi folks
06:23:15 <intuit> total newb here...I am looking for the *easiest* way to connect to mysql from haskell
06:23:16 <b_jonas> POSIX.select from what module?
06:23:20 <quicksilver> b_jonas: POSIX
06:23:25 <intuit> I ma having troubles compiling HDBC with mingw
06:23:30 <intuit> are there any prebuilt libs?
06:23:35 <quicksilver> (that's what the part before the . was supposed to denote)
06:23:50 <b_jonas> quicksilver: yes, fork a thread, and use mvars and stuff to synchronize, but how does the individual thread wait withuot actually reading when it becomes readable?
06:23:58 <intuit> I am in Windows Vista, by the way.
06:24:00 <intuit> Thanks!
06:24:16 <quicksilver> intuit: I'm afraid I'm not a windows user, hopefully someone else will step up.
06:24:20 <intuit> I was shown the light by a mathematics graduate.
06:24:31 <intuit> I intend to even develop my websites using HApps..eventually
06:24:35 <intuit> so I need some help =/
06:24:38 <wli> Form SCC DAG's on the binding groups of lets, find the data dependencies of each SCC, find the least common ancestor of all the dependencies, float the let to there.
06:24:41 <b_jonas> um, is POSIX in the ghc core or a cabal package?
06:24:41 <intuit> ok quick
06:24:42 <intuit> thanks
06:24:44 * b_jonas is confused
06:25:04 <quicksilver> b_jonas: http://www.haskell.org/ghc/dist/current/docs/libraries/index.html
06:25:12 <quicksilver> b_jonas: most of the things you think of as GHC core are not GHC core.
06:25:18 <quicksilver> b_jonas: they are "extralibs"
06:25:34 <quicksilver> b_jonas: posix is in the unix package, which I believe is in extralibs.
06:25:56 <zeno> intuit: sorry this isnt a real answer but you could install linux in a vm like virtualbox
06:26:06 <ppavel> hi
06:26:18 <b_jonas> quicksilver: okay, but I still can't see just "POSIX". there's a System.Posix.IO which I looked but it does not seem to have such a function
06:26:48 <intuit> zeno, that is an option
06:26:58 <intuit> I suppose I could also install cygwin, and try my luck with that
06:26:59 <wli> I guess one has to watch for variable shadowing, which can be nuked as a problem relatively easily.
06:27:09 <intuit> but I dont wanna spend another few hours on this not knowing if I am on the right path
06:27:12 <intuit> nkow what I mean
06:27:54 <intuit> hmm ok let me try this...
06:28:30 <intuit> Warning: No 'build-type' specified. If you do not need a custom Setup.hs or
06:28:30 <intuit> ./configure script then use 'build-type: Simple'.
06:28:42 <intuit> This is the error I get when I run setup configure
06:28:50 <intuit> excuse my naivete..
06:28:55 <Saizan> it's not an error though
06:29:02 <intuit> yseah..warning
06:29:08 <intuit> ok..when I run setup install...
06:29:29 <intuit> Installing library in C:\Program Files\Haskell\HDBC-1.0.1\ghc-6.10.1
06:29:29 <intuit> setup: Error: Could not find module: Database.HDBC with any suffix: ["hi"]
06:29:40 <intuit> oh wait...
06:29:41 <intuit> duh
06:29:44 <intuit> the path is wrong
06:29:54 <intuit> does the Cabal file say where the path should be?
06:30:35 <intuit> hmm it doesnt..
06:30:42 <b_jonas> ah, there's a hWaitForInput in System.IO
06:30:44 <Saizan> the error is not related to the path where the library will get installed
06:31:00 <intuit> ok, so whats my next step sir?
06:31:01 <Saizan> intuit: did you run setup build?
06:31:02 <quicksilver> b_jonas: ok, that's odd. I just assumed System.Posix would expose select somewhere.
06:31:34 <intuit> C:\ghc\hdbc\hdbc>setup build
06:31:34 <intuit> Preprocessing library HDBC-1.0.1...
06:31:34 <intuit> Building HDBC-1.0.1...
06:31:34 <intuit> Database\HDBC\Types.hs:51:7:
06:31:34 <intuit>     Could not find module `System.Time':
06:31:34 <intuit>       it is a member of package old-time-1.0.0.1, which is hidden
06:31:42 <intuit> sorry for the multi line post
06:31:44 <intuit> was not intended
06:32:13 <Saizan> ok, that means you've to add old-time to the build-depends field in the .cabal file
06:32:44 <intuit> library
06:32:45 <intuit>   if flag(splitBase)
06:32:45 <intuit>     Build-Depends: base>=3, old-time, time, bytestring, containers, old-locale
06:32:45 <intuit>   else
06:32:45 <intuit>     Build-Depends: base<3
06:32:45 <intuit>   Build-Depends: mtl, convertible >= 1.0.1, utf8-string
06:33:03 <intuit> ok, so ill add old-time to the else clause
06:33:11 <Saizan> that's weird
06:33:26 <intuit> didnt help
06:33:59 <ppavel> q
06:34:28 <b_jonas> System.IO.hWaitForInput is implemented in GHC.IO
06:34:33 <Saizan> intuit: which ghc version are you using?
06:34:42 <intuit> sai, 6.10.1
06:34:47 <intuit> Saizan*
06:35:48 <Saizan> and you're trying to build HDBC-2.1.0 ?
06:36:10 <intuit> yes, 2.1.0, according to the cabal
06:37:46 <intuit> hmmm
06:37:55 <intuit> I wonder if my system path is just screwed up?
06:38:11 <intuit> I can compile and run most tutorials I get from the web just fine.
06:38:20 <intuit> I am only experiencing problems with this, at the moment
06:38:50 <Saizan> paste the output of setup configure -v on hpaste.org
06:38:55 <b_jonas> oh no
06:39:10 <b_jonas> I don't want to find out how ghc threads internals work
06:39:11 <intuit> ok
06:40:35 <b_jonas> anyway, thanks for the help
06:41:02 <intuit> saizan: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2850#a2850
06:43:17 <wli> Hmm, it looks like the characterization of the SCC DAG is as a Scott domain(!).
06:44:00 <wli> There's no direct description in terms of graph notions.
06:44:33 <Saizan> intuit: it looks like everything is fine
06:44:48 <intuit> saizan, well, my GHC isnt even in Program files
06:44:53 <intuit> why is it doing anything in there?
06:44:57 <wli> Only using the SCC DAG to define a poset gets you something like a finite Scott domain.
06:45:17 <intuit> my HDBC isnt there either
06:45:18 <Saizan> intuit: that's only where the library will be installed
06:45:22 <intuit> oh
06:45:58 <Saizan> Using ghc version 6.10.1 found on system at: C:\ghc\ghc-6.10.1\bin\ghc.exe
06:46:01 <intuit> ok, well what we know is that setup barfs on the time module issue
06:46:08 <intuit> yes, Saizan
06:46:15 <ppavel> did anyone build recent ghc tarballs on FreeBSD?
06:46:27 * Badger bets the people in #haskell-freebsd did.
06:47:00 <quicksilver> I wonder if intuit has two package databases, or two versions of cabal
06:47:02 <quicksilver> or something like that.
06:47:04 <ppavel> ops :) should go there :) thanks Badger
06:47:29 <Saizan> intuit: uhm, we're not using the same HDBC package though, since in mine build-type: Simple is specified
06:47:35 <Badger> mind you, they're usually asleep as I recall. :P
06:47:50 <intuit> How do I specify that?
06:47:58 <intuit> the  haskell source indicates Simple
06:48:06 <intuit> > import Distribution.Simple
06:48:07 <lambdabot>   <no location info>: parse error on input `import'
06:48:15 <Saizan> did you get the package from http://hackage.haskell.org/packages/archive/HDBC/2.1.0/HDBC-2.1.0.tar.gz ?
06:48:43 <Saizan> "build-type: Simple" should be in the .cabal file
06:48:46 <ppavel> do you suggest this has something to do with the OS ? :-P
06:48:53 <intuit> Saizan,I have tried to downloads, thusfar.  The first was the latest you specified...
06:48:59 <intuit> I tried a zip before that
06:49:05 <intuit> strangely, with different resultsd
06:49:22 <intuit> I am not really a linux guru, or a C guru...so this is a bit maddening.
06:49:32 <intuit> I cant really afford to spend all day to get it working :(
06:49:44 <intuit> but THANKS for your help
06:49:49 <Saizan> well, that package works out of the box for me
06:50:07 <intuit> hmm
06:50:09 <rittyan2> http://paste.pocoo.org/show/109541/ <- can somebody help me how to deal with that issue?
06:50:13 <intuit> maybe I should try something besides GHC
06:50:20 <Saizan> with just configure/build/install
06:50:26 <intuit> you are on Vista?
06:50:55 <rhox> +memo mrc_001 http://www.gamestar.de/specials/spiele/1954841/10_fragen_und_antworten_zu_bioshock_2.html dürfte dich interessieren
06:51:10 <Saizan> linux
06:51:18 <intuit> oh
06:51:26 <intuit> ok...that settles it...
06:51:30 <Saizan> but i'd be very surprised if that's related
06:51:34 <intuit> im going to install DSL on virtualbox
06:51:37 <intuit> and try it out there
06:51:43 <intuit> Ive already spent 2 hours on this
06:51:50 --- mode: ChanServ set +o quicksilver
06:51:54 --- mode: quicksilver set +b *!*n=rhox@88.117.153.*
06:51:54 --- kick: rhox was kicked by quicksilver (quicksilver)
06:51:55 <intuit> well, im sure this is a easy thing to fix
06:52:05 <intuit> the only problem is I dont want to spend all day figuring it out
06:52:09 <intuit> I chose Haskell to make life easier
06:52:23 <Saizan> ok, what works best for you :)
06:52:41 <Badger> quicksilver: and I thought it looked like a wrong window problem. :P
06:53:05 <intuit> im going to try it out in damn small linux
06:53:08 <intuit> ill report my results
06:53:13 <intuit> I bet it will work easy
06:53:31 <Badger> ghc is too big for damn small linux :P
06:53:40 <intuit> :(
06:53:48 <quicksilver> Badger: Hmm. Perhaps. Well he can PM me if so :)
06:53:57 <intuit> Should I get cygwin?
06:54:01 <intuit> (again)
06:54:09 --- mode: quicksilver set -b *!*n=rhox@88.117.153.*
06:54:17 <Badger> if you have windows you should have cygwin ;)
06:54:31 <intuit> ok, ill reinstall cygwin
06:54:32 <Saizan> well, it's not like there's a cygwin build for ghc
06:54:34 <intuit> and see hoe it goes
06:54:38 <kadaver> so how do I get from what page a http-request comes from?
06:54:47 <Saizan> msys might help
06:55:00 <Saizan> but only for bindings with C libraries
06:55:10 <intuit> hmm
06:56:41 <intuit> haskell is such a pretty language
06:56:48 <intuit> Just gotta get past these initial problems
06:56:59 <intuit> I am sure when I get advanced enough to work with Happas ill be crying, yet again, though
06:57:12 <intuit> s\pretty\elegant,concise
06:57:14 <quicksilver> I don't think many people use the mysql bindings
06:57:17 <intuit> HApps
06:57:19 <quicksilver> (who would use mysql out of choice?)
06:57:32 <intuit> I am accustomed to Mysql
06:57:36 <quicksilver> so I'm not sure they're particularly thorough.
06:57:39 <intuit> I am a PHP/Mysql developer, by trade
06:57:39 --- mode: quicksilver set -o quicksilver
06:58:22 <quicksilver> intuit: I'm so sorry.
06:58:28 <Saizan> intuit: cabal-install really helps -> http://www.haskell.org/cabal/download.html
06:59:03 <intuit> quick, pays the bills
06:59:10 <intuit> I have only been a PHP guy the past 3 years
06:59:13 <quicksilver> intuit: yeah, I know :)
06:59:16 <intuit> I was a "real" programmer before that
06:59:29 <intuit> Saizan, thanks, ill check that out
06:59:36 <intuit> Gotta go send some mail
06:59:39 <intuit> be back in a bit
06:59:41 <intuit> thanks
07:01:30 <b_jonas> :)
07:07:50 <intuit> quicksilver, before I go, what is the defacto standard DBMS for Haskell?
07:08:43 <quicksilver> I don't think there is one.
07:08:51 <quicksilver> I don't think the DB code in haskell is as widely used as in most languages.
07:08:54 <quicksilver> for whatever reason.
07:09:02 <quicksilver> I'd start with postgres, myself.
07:13:02 <kadaver> so how do I get from what page a http-request comes from?
07:13:27 <kadaver> quicksilver: whats wrong with mysql? i use postgresql but not for any particular reason
07:15:36 <quicksilver> kadaver: there is no short answer to that. Recent versions are much less shit than the early ones. Lack of proper transaction support, lack of a sensible on-disk format, poor query optimiser, poor support of the SQL language, etc etc.
07:18:13 <kadaver> ok you prefer postgresql?
07:18:25 <kadaver> (i see now the pagename comes int he GET request)
07:18:27 <rittyan2> any Text.JSON users here? How does "decode" function knows to what structure some string decodes? I am feeling lost :<
07:20:20 <Eridius> rittyan2: it decodes to any valid instance of JSON
07:20:30 <Eridius> I'm curious as to the use of a new Result type instead of just using Either
07:20:35 <Eridius> or rather, Either String
07:20:58 <rittyan2> Result looks erlangish
07:21:08 <Eridius> yeah it kinda does
07:21:24 <Eridius> in any case, decode is polymorphic in its return type
07:21:41 <Eridius> if your code expects a JSString, and the JSON is in fact a number, it will give you back an Error
07:22:00 <Eridius> but if your code expects, say, a JSArray and the JSON string is in fact an array, then it will give you back a JSArray (wrapped in Ok)
07:22:15 <Eridius> have you ever used read?
07:22:38 <Eridius> this looks like read, but for JSON encoding and with proper error handling (instead of just throwing an exception if the input can't be parsed)
07:23:17 <rittyan2> hmm... I need some time to read my code again and map your words onto it
07:23:30 <rittyan2> (newcomer)
07:23:41 <hcube> hi!
07:23:51 <Eridius> hi
07:23:56 <Badger> ho
07:24:20 <Eridius> hrm, I wonder what JSRational is for? I wasn't aware JSON could encode arbitrary-precision rational numbers
07:24:33 <rittyan2> Eridius, http://paste.pocoo.org/show/109549/ <- is it expecting anything? I dont think so, hm (there is a list in "content", stringified)
07:24:57 <Eridius> what's AttackReport?
07:25:32 <Eridius> rittyan2: I suspect if you compile that you'll get an error saying no Instance for JSON AttackReport
07:26:04 <rittyan2> ah
07:26:08 <Eridius> heh, Text.JSON has resultToEither. Makes me wonder even more why bother with the Result type
07:26:24 <rittyan2> Eridius, http://paste.pocoo.org/show/109551/
07:26:51 <Eridius> ah so you do have an instance
07:26:59 <Eridius> ok so what's the confusion here?
07:27:05 <kadaver> what is the Parsec for Parsec.string? ie char 'h' >> char 't' etc?
07:27:37 <Eridius> kadaver: pardon?
07:28:21 <Eridius> kadaver: there's a Parsec function called simply string, which takes a string and returns a parser for that string
07:29:28 <rittyan2> Eridius, I don't know, code compiles but isn't doing what I want... http://paste.pocoo.org/show/109552/ <- here's the code (33 loc). it is supposed to open files, read list of attack reports, concat them and dump into a file, that is all
07:29:38 <ndm> ?hoogle char
07:29:38 <lambdabot> Text.Parsec.Char char :: Stream s m Char => Char -> ParsecT s u m Char
07:29:39 <lambdabot> Text.ParserCombinators.ReadP char :: Char -> ReadP Char
07:29:39 <lambdabot> Text.PrettyPrint.HughesPJ char :: Char -> Doc
07:30:05 <ndm> ?hoogle Stram s m Char => String -> ParsecT s u m String
07:30:06 <lambdabot> Warning: Unknown class Stram
07:30:06 <lambdabot> Text.Parsec.Token symbol :: GenTokenParser s u m -> String -> ParsecT s u m String
07:30:06 <lambdabot> Text.ParserCombinators.Parsec.Token symbol :: GenTokenParser s u m -> String -> ParsecT s u m String
07:30:22 <rittyan2> Eridius, I get "Successfuly parsed: 5" (when feeding 5 files)
07:31:05 <ndm> ?hoogle+
07:31:05 <lambdabot> Text.ParserCombinators.Parsec.Token symbol :: GenTokenParser s u m -> String -> ParsecT s u m String
07:31:05 <lambdabot> Text.Parsec.Prim tokens :: (Stream s m t, Eq t) => ([t] -> String) -> (SourcePos -> [t] -> SourcePos) -> [t] -> ParsecT s u m [t]
07:31:05 <lambdabot> Text.ParserCombinators.Parsec.Prim tokens :: (Stream s m t, Eq t) => ([t] -> String) -> (SourcePos -> [t] -> SourcePos) -> [t] -> ParsecT s u m [t]
07:31:29 <Eridius> rittyan2: what's chanWriter?
07:31:32 <ndm> grr, on the web version of Hoogle string is result 3, was trying to show how you can find these functions on your own
07:31:59 <quicksilver> woohoO!
07:32:04 <quicksilver> wb ndm :)
07:32:17 <rittyan2> Eridius, ah, nevermind it (I just removed it)... printing thread... gets strings and prints them to stdout
07:33:16 <ndm> quicksilver: been a long time - 8 months or so I reckon
07:33:26 <quicksilver> ndm: you've been missed!
07:33:37 <ndm> I've had a job, it takes up all my time...
07:33:49 <ndm> today I'm working from home, so can hop on IRC in the background
07:34:17 * quicksilver nods
07:34:22 <Eridius> rittyan2: I still don't know what the problem is.
07:34:24 <quicksilver> jobs, heh.
07:34:52 <lilac> @hoogle Stream s m Char => String -> ParsecT s u m String
07:34:52 <lambdabot> Text.Parsec.Char string :: Stream s m Char => String -> ParsecT s u m String
07:34:52 <lambdabot> Text.ParserCombinators.Parsec.Char string :: Stream s m Char => String -> ParsecT s u m String
07:34:52 <lambdabot> Text.Parsec.Token symbol :: GenTokenParser s u m -> String -> ParsecT s u m String
07:35:02 <lilac> without typos, string is result 1
07:36:57 <lilac> IIRC string = mapM char
07:37:28 <Eridius> string s            = tokens show updatePosString s
07:37:48 <rittyan2> Eridius, I got it to work, thanks :3
07:37:52 <Eridius> rittyan2: glad to hear it
07:38:03 <rittyan2> almost
07:38:11 <Eridius> rittyan2: what was the problem?
07:38:18 <lilac> Eridius: isn't that semantically the same thing?
07:38:22 * lilac ponders about the 'show'
07:38:29 <Eridius> lilac: possibly. I don't know what tokens or updatePosString do
07:38:42 <lilac> updatePosString moves the position on by the lenght of the string IIRC
07:38:59 <lilac> i think "string" gives more correct errors though
07:39:33 <rittyan2> Eridius, I don't know yet... problem still persists except that I know that 99.9% of code works fine... I can print 'encode report' just fine to stdout, but I cannot find content in "assembly.json" (i.e. it is empty)
07:39:35 <lilac> that is, (string "foo") applied to "fox" gives "unexpected "fox", expected "foo"" whereas with mapM you'd get "unexpected "x", expected "o""
07:39:50 <kadaver> doesnt P.<|> mean or in Parsec?
07:39:51 <Eridius> yeah
07:40:07 <quicksilver> lilac: hmm "unexpected fox"
07:40:13 <Eridius> kadaver: basically, yeah
07:40:14 <quicksilver> lilac: that would be a good name for a parsing book :)
07:40:15 <vixey> <|> means take the left branch
07:40:20 <Eridius> kadaver: same meaning as in Control.Applicative
07:41:52 <quicksilver> conal: good morning.
07:42:02 <quicksilver> conal: I fixed my problem by cheating. Ah well. At least my animations work now :)
07:42:30 <conal> quicksilver: hi.
07:42:45 <rittyan2> Eridius, http://paste.pocoo.org/show/109553/ <- can you see anything suspicious in dumpAssembly code? putStrLn works just fine, hPut doesn't seem to, hmm
07:43:16 <Eridius> rittyan2: well, I notice you aren't closing the file
07:43:29 <quicksilver> conal: instead of having an Event kick in 2 seconds later to drop back from "Transitioning from A to B" to "In State B", I just have the behaviour check the current time.
07:43:56 <Eridius> hrm, what encoding does ByteString use for pack?
07:43:56 <quicksilver> conal: if we are supposededly in the "A -> B" state but actualy we are passed the end-time of the transition, just behave as State B.
07:44:13 <rittyan2> Eridius, that's it! it works now
07:44:15 <Eridius> rittyan2: I will point out that putStrLn adds a newline, hPut probably doesn't
07:44:20 <Eridius> heh
07:44:30 <quicksilver> Eridius: the "clip chars to least sign. 8 bit" encoding
07:44:31 <rittyan2> I am feeling careless ^^
07:44:39 <Eridius> quicksilver: hah, nice encoding, that
07:44:48 <conal> quicksilver: oh yeah.  simple hack.
07:45:07 <Eridius> quicksilver: although, what does clip mean? Unless we're talking about a dependency on the internal representation of a Char
07:45:11 <conal> quicksilver: an ongoing conditional instead of a transition.
07:45:16 <quicksilver> conal: I also came up with a good example of getting (a -> B b) and transforming it to B (a -> b)
07:45:26 <quicksilver> conal: and I left the non-working version in the code as an example.
07:45:46 <conal> nice
07:46:00 <Eridius> rittyan2: wonder why you don't just use ByteString's writeFile
07:46:19 <Eridius> rittyan2: undoubtedly the file handle is buffered (dunno why) and putStrLn worked because a newline flushes
07:46:23 <rittyan2> Eridius, I don't know :) hey I am less than a week with haskell >_>
07:46:37 <quicksilver> conal: and as a result I have 3 "animated" scenes, which I can switch between them with button presses
07:46:40 <Eridius> rittyan2: heck, I'm just reading the library docs right now ;)
07:46:52 <quicksilver> conal: and during the switch, one scene zooms off-screen and the other zooms on
07:46:59 <quicksilver> conal: and they keep animating as they do so :)
07:47:05 <Eridius> rittyan2: I have never actually written a full-fledged script in Haskell that does I/O, so I haven't played around with file handles or ByteString very much
07:47:19 <quicksilver> Eridius: we're talking about unicdoe code points.
07:47:30 <quicksilver> Eridius: so it's the lower 8 bits of the unicode code point
07:47:36 <Eridius> quicksilver: ok, so basically it's ISO-8859-1?
07:47:43 <quicksilver> Eridius: ...which happens to coincide with 8859-1 or 9 or 15 or something
07:47:48 <Eridius> I think it's -1
07:47:49 <quicksilver> depending on what they did with the euro sign
07:48:15 <Eridius> € is U+20AC
07:48:27 <conal> quicksilver: sounds lovely!
07:49:08 <yasha> quicksilver, I'm reading your message "Monadic tunnelling", I don't quite get if it's possinble to use approach when usesCB has type like (Handle -> String -> IO ()) -> IO () i.e. when callback does accept some arguments from foreign world
07:49:09 <Eridius> rittyan2: for reference, openFile opens in "text mode", which apparently means buffered. openBinaryFile should give you an unbuffered handle
07:49:52 <yasha> quicksilver, in this case callback in user monad could have type Handle -> String -> MyMonad () respectively
07:50:04 <quicksilver> yasha: yes
07:50:17 <quicksilver> yasha: you either need to have different versions of usesCB dependin on the number of parameters
07:50:25 <quicksilver> yasha: or you need to uncurry them into a tuple
07:50:30 <quicksilver> (so it's always one argument)
07:50:59 <quicksilver> Eridius: hSetBuffering to choose explicitly.
07:51:24 <rittyan2> Eridius, hmm, I see...
07:51:36 * QtPlaty[Hireme] flops into bed.
07:51:51 <yasha> quicksilver, you probably meant embedIO and makeCallback, because usesCB is 'library function'
07:55:56 <gwern> I have google alerts set up for myself, and it never fails to make sense. like, why did this week turn up old patches of mine from pugs and tagsoup?
07:56:25 <Eridius> you mean it never fails to present a complete lack of sense?
07:56:39 <jmcarthur> quicksilver, "I also came up with a good example of getting (a -> B b) and transforming it to B (a -> b)" <-- is that B specific to FRP or are you speaking in generalities?!
07:56:58 <gwern> Eridius: that too
07:57:13 <jmcarthur> B == Behavior?
07:59:22 <jmcarthur> actually... it seems like that might be a possible general function for monads
08:00:06 <kadaver> so how do I if I successfully parse: a >> b >> c; how do Ir eturn b?
08:00:12 <vixey> :t liftM
08:00:13 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
08:00:20 <vixey> :t join
08:00:22 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
08:00:34 <byorgey> jmcarthur: I don't think you can implement it generally for monads.
08:00:39 <quicksilver> jmcarthur: it's not possible in general for monads
08:00:50 <quicksilver> jmcarthur: erm, sorry, that's backwards.
08:00:56 <quicksilver> jmcarthur: it's possible for all monads, yes ;)
08:01:00 <quicksilver> not for all applicatives.
08:01:02 <jmcarthur> not for all applicatives
08:01:03 <jmcarthur> yeah
08:01:13 <quicksilver> the point is Behaviour is an applicative but not a monad
08:01:18 <quicksilver> only *really* it is a monad
08:01:20 <jmcarthur> that is what made me surprised at first
08:01:23 <quicksilver> this is semantically obvious
08:01:27 <vixey> :t join . liftM
08:01:28 <quicksilver> but we can't write the instance
08:01:28 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m a1)
08:01:28 <byorgey> what? how would you implement  (a -> m b) -> m (a -> b) ?
08:01:28 <lambdabot>     Probable cause: `liftM' is applied to too many arguments
08:01:28 <lambdabot>     In the second argument of `(.)', namely `liftM'
08:01:29 <jmcarthur> i was thinking the same thing
08:01:37 <quicksilver> because of implementation constraints which appear to be hard to solve.
08:01:52 <quicksilver> however, since they are semantically the same really
08:01:58 <jmcarthur> yeah, i ran into those same things in my implementations of Behavior
08:02:03 <quicksilver> if you can write a sensible expression of the form (a -> B b)
08:02:16 <quicksilver> you can probably write the 'equivalent' one of the form
08:02:20 <quicksilver> B (a -> b)
08:02:23 <jmcarthur> nice
08:02:28 <quicksilver> I say 'probably'
08:02:34 <vixey> yeah byorgey it seems impossible
08:02:47 <vixey> considering e.g.  (a -> Maybe a) -> Maybe (a -> b)
08:03:00 <jmcarthur> quicksilver, it seems semantically plausible at least
08:03:05 <quicksilver> to prove it would need to be a structural induction over all combinators which can produce behaviours
08:03:11 <quicksilver> jmcarthur: because *really* Behaviour is (t ->)
08:03:16 <byorgey> vixey: well, that one you can just say  foo _ = Nothing  =)
08:03:19 <quicksilver> jmcarthur: and (t -> a -> b) is (a -> t -> b)
08:03:21 <jmcarthur> @djinn (a -> Maybe b) -> Maybe (a -> b)
08:03:21 <lambdabot> f _ = Nothing
08:03:26 <jmcarthur> :\
08:03:27 <byorgey> vixey: but obviously that wouldn't satisfy reasonable laws for such a function.
08:03:42 <quicksilver> byorgey: other way around is what I want, though.
08:03:51 <quicksilver> byorgey: it's just ap + return
08:03:59 <vixey> :t ap + return
08:04:00 <lambdabot>     Occurs check: cannot construct the infinite type: b = a -> b
08:04:00 <lambdabot>       Expected type: m (a -> b) -> m a -> m b
08:04:00 <lambdabot>       Inferred type: m (a -> b) -> m a -> m (a -> b)
08:04:03 <quicksilver> :P
08:04:05 <byorgey> oh,  m (a -> b) -> a -> m b  ?  yes, I agree that is easy.
08:04:11 <quicksilver> yes.
08:04:11 <jmcarthur> @djinn Maybe (a -> b) -> a -> Maybe b
08:04:11 <lambdabot> f a b =
08:04:11 <lambdabot>     case a of
08:04:11 <lambdabot>     Nothing -> Nothing
08:04:11 <lambdabot>     Just c -> Just (c b)
08:04:18 <mmorrow> just figured out how to hackily extract a heap graph (in bytecode) given a root of type 'a'
08:04:21 <mmorrow> , let a = 0 : a in vacuum a
08:04:23 <lunabot>  [(0,[1,0]),(1,[])]
08:04:39 <quicksilver> actually I'm not sure what I do mean.
08:04:43 * quicksilver thinks this through more carefully.
08:04:47 <mmorrow> , let a = 0 : a in vacuum (repeat [a,a,a])
08:04:49 <lunabot>  [(0,[1,0]),(1,[2,3]),(2,[4,2]),(3,[2,5]),(4,[]),(5,[2,6]),(6,[])]
08:04:53 <jmcarthur> yeah, now we seem to reversed the goal
08:05:04 <quicksilver> OK, I think it isn't possible for all monads
08:05:06 * mmorrow puts it on hackage (w/ .dot rendering)
08:05:11 <quicksilver> but it is possible for the reader monad
08:05:13 <quicksilver> and that's really my point.
08:05:14 <vixey> , let o = 0 : e ; e = 0 : o in vacuum e
08:05:16 <lunabot>  [(0,[1,2]),(1,[]),(2,[3,0]),(3,[])]
08:05:17 <quicksilver> apologies for talking rubbish.
08:05:32 <vixey> , let x = x ; o = x : e ; e = x : o in vacuum e
08:05:34 <lunabot>  luna: out of memory (requested 2097152 bytes)
08:05:47 <vixey> , let x = () ; o = x : e ; e = x : o in vacuum e
08:05:49 <mmorrow> ooh, i've gotta check for x = x
08:05:49 <lunabot>  [(0,[1,2]),(1,[]),(2,[1,0])]
08:05:58 <jmcarthur> :t \f x -> f <*> pure x
08:05:59 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> a -> f b
08:06:03 <vixey> that's really mad mmorrow
08:06:07 <vixey> cool
08:06:12 <jmcarthur> so, possible for all applicatives
08:06:21 <jmcarthur> in that direction, i mean
08:06:25 <mmorrow> vixey: seeing it rendered by graphviz in realtime is soooo cool :)
08:06:27 <kadaver> how can I match optional in Parsec?
08:06:38 <quicksilver> @hoogle option
08:06:38 <lambdabot> Distribution.Simple.Command option :: SFlags -> LFlags -> Description -> get -> set -> MkOptDescr get set a -> OptionField a
08:06:39 <lambdabot> Text.Parsec.Combinator option :: Stream s m t => a -> ParsecT s u m a -> ParsecT s u m a
08:06:39 <lambdabot> Text.ParserCombinators.ReadP option :: a -> ReadP a -> ReadP a
08:08:41 <quicksilver> conal: anyhow I think I'll have this polished up tonight and posted to the reactive list tomorrow.
08:08:48 <quicksilver> conal: I hope it's useful or interesting to someone.
08:09:34 <kadaver> so how do I do if I successfully parse: a >> b >> c; how do I return b?
08:10:12 <thomastc> omg, I just realized... leksah is haskel spelled backwards :D
08:10:30 <thomastc> and I used to think that it was just a BrEeZaH way of spelling 'lexer' :D
08:10:42 <thomastc> I like the name much better now :)
08:10:46 <Saizan> kadaver: do a; x <- b; c; return x
08:11:05 <vixey> mmorrow: realtime.. as a haskell program is running?
08:11:15 <Saizan> or a >> b >>= \x -> c >> return x
08:11:53 <kadaver> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2856#a2856 <- from inside a parser
08:12:37 <mmorrow> vixey: err, i just meant in ghci. i wonder if it'll work in compiled code
08:13:01 <mmorrow> (like as in ["cat",dot,{-"|","tred",-}"|","dot -Tpng",">",png,"2>/dev/null;","display",png,"&"])
08:13:08 <Saizan> kadaver: it's the same
08:13:10 <mmorrow> system _
08:13:21 <vixey> , let up i = i : up (i+1) in vacuum (up 0)
08:13:27 <lunabot>  Killed.
08:13:47 <quicksilver> Saizan: or "a *> b <* c"
08:13:57 <quicksilver> mnemonic - the arrows point to the return value you want.
08:14:07 <mmorrow> , let up i = i : up (i+1) in vacuum (take 4 (up 0))
08:14:09 <lunabot>  [(0,[1,2]),(1,[]),(2,[3,4]),(3,[]),(4,[5,6]),(5,[]),(6,[7,8]),(7,[]),(8,[])]
08:14:12 <vixey> , vacuum id
08:14:15 <lunabot>  [(0,[])]
08:14:18 <vixey> , vacuum fix
08:14:21 <lunabot>  [(0,[])]
08:14:30 <vixey> what does it do for functions?
08:14:53 <vixey> , vacuum (1 + 1)
08:14:55 <lunabot>  [(0,[])]
08:15:26 <mmorrow> , vacuum (fix (\x -> Node () [x,x]))
08:15:26 <Saizan> ?type (<*)
08:15:27 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
08:15:28 <lunabot>  [(0,[1,2]),(1,[]),(2,[0,3]),(3,[0,4]),(4,[])]
08:15:41 <vixey> , fix vacuum
08:15:52 <mmorrow> heh
08:15:58 <mmorrow> , 42
08:15:59 <lunabot>  42
08:16:11 <mmorrow> i think it might have had no output
08:16:13 <vixey> , 42 `mod` 13
08:16:14 <lunabot>  3
08:16:51 <Saizan> , [$type|vacuum|]
08:16:52 <lunabot>  luna: Not in scope: `type'
08:17:13 <mmorrow> , [$ty|vacuum|]
08:17:16 <lunabot>  forall a . a -> [] ((Int, [] Int))
08:18:08 <kadaver> parsec is pretty amazing imho
08:19:25 <lunabot>  luna: no output
08:19:59 <mmorrow> heh, fix vacuum exposes some weird bug in lunabot
08:20:10 <kadaver> is there some way to simplify parsec scomplicated types?
08:20:10 <kadaver> requestParser :: Text.Parsec.Prim.ParsecT
08:20:11 <kadaver>                    P.SourceName u Control.Monad.Identity.Identity String
08:20:22 <mmorrow> i just had to kill -9 some procs that were doing nothing, but alive
08:20:54 <smiskis> haskell must be a revolution.. 630 users and java has 360... when beeing the most popular language
08:21:24 <vixey> , let a = take 3 (fix (1:)) ; b = [1,1,1] in (a == b, vacuum a == vacuum b)
08:21:26 <lunabot>  (True,False)
08:21:29 <vixey> !
08:21:38 <mreh> @faq I can Haskell cheezburger?
08:21:38 <mmorrow> hmm
08:21:38 <lambdabot> The answer is: Yes! Haskell can do that.
08:21:43 <mmorrow> ah
08:21:49 <vixey> smiskis: yes!
08:21:57 <mmorrow> , vacuum (take 3 (fix (1:)))
08:21:59 <lunabot>  [(0,[1,2]),(1,[]),(2,[1,3]),(3,[1,4]),(4,[])]
08:22:04 <mmorrow> , vacuum [1,1,1]
08:22:06 <lunabot>  [(0,[1,2]),(1,[]),(2,[3,4]),(3,[]),(4,[5,6]),(5,[]),(6,[])]
08:22:13 <vixey> , (take 3 (fix (1:)))
08:22:15 <lunabot>  [1,1,1]
08:22:51 <kadaver> or haskell is so hard all the worlds 630 haskell programmers need help :P
08:23:39 <BMeph> kadaver: Well, given the nature of the language, it's obvious that the java ones need help. ;p
08:24:21 <mreh> are there only 630 haskell programmers?
08:24:27 <Raevel> yes
08:24:33 <mreh> am i included?
08:24:49 <Raevel> mu
08:24:52 <mreh> 631, i think.
08:24:53 <ikke> hah
08:24:54 <ikke> :p
08:25:08 <mreh> is there a t-shirt?
08:25:09 <kadaver> mreh: the 631st is Guy Steele trolling
08:25:19 <Raevel> not him again -.-
08:25:22 <ikke> mreh chanserv isn't a haskell programmer... he is more into C
08:25:33 <mreh> :O
08:25:34 <ikke> he justs hangs arround
08:25:39 <mreh> who is guy steele?
08:25:53 <asgaroth> If confusion correlates with channel size, python people must be even more confused than we are :)
08:26:48 <mreh> oh that guy steele
08:27:09 <kadaver> pretty cool name
08:27:24 <mreh> http://arcanux.org/lambdacats/imperative.jpg
08:27:30 * bremner wonders what guy steeles porn-star-name would be
08:28:12 <mreh> probably, pig benis
08:28:16 <mmorrow> , vacuum (fix (\x -> Node () (fix (x:))))
08:28:18 <lunabot>  [(0,[1,2]),(1,[]),(2,[0,2])]
08:28:52 <vixey> , vacuum (map (+1))
08:28:54 <lunabot>  [(0,[])]
08:28:55 <mmorrow> , levels $ fix (\x -> Node () (fix (x:))
08:28:56 <lunabot>  luna: parse error (possibly incorrect indentation)
08:29:01 <mmorrow> , levels $ fix (\x -> Node () (fix (x:)))
08:29:02 <lunabot>  [[()],[(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),...
08:29:04 <vixey> , vacuum (map (join (,)) [1..10])
08:29:06 <lunabot>  [(0,[1,2]),(1,[3,3]),(2,[4,5]),(3,[]),(4,[6,6]),(5,[7,8]),(6,[]),(7,[9,9]...
08:31:55 <mreh> http://arcanux.org/lambdacats/varbl.jpg <- this one is great, although I wonder if it was bring your cat to work day?
08:32:18 <mreh> "men, we need more man hours, it's time to bring out the cats"
08:34:36 <wli> bremner: Guy Steele probaly wouldn't need a pseudonym for that.
08:35:48 <BMeph> mmorrow: Does lunabot accept PMs?
08:36:02 <mmorrow> BMeph: yes
08:37:29 <Sargun_Screen> Hey, can someone look at my program and tell me what I'm doing wrong: http://haskell.pastebin.com/m22b5755d
08:38:02 <quicksilver> Sargun_Screen: you want 'readLn' not 'read', for starters.
08:38:20 <quicksilver> Sargun_Screen: and the type signature for area is incorrect
08:38:23 <quicksilver> Fractional is not a type
08:38:48 <quicksilver> also you don't appear to have written the definition of 'area'
08:38:56 <Sargun_Screen> err, the program got truncated.
08:39:11 <lilac> @type (=<<)
08:39:13 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
08:39:14 <lilac> @type let f :: (a -> m b) -> m (a -> b); f = undefined in (<*>) . f
08:39:15 <lambdabot> forall a (m :: * -> *) b. (Applicative m) => (a -> m b) -> m a -> m b
08:41:01 <mmorrow> hehe
08:41:03 <mmorrow> , vacuum (let xs = fix (([1]++ys) ++); ys = zipWith (+) xs xs in xs)
08:41:05 <lunabot>  luna: internal error: ARR_WORDS object entered!
08:41:09 <mmorrow> !
08:41:25 <EvilTerran> vacuum?
08:41:29 <Sargun_Screen> *Main> :t 4.2
08:41:30 <Sargun_Screen> 4.2 :: (Fractional t) => t
08:41:39 <Sargun_Screen> Doesn't that mean 4.2 is a "Fractional"
08:41:44 <mmorrow> EvilTerran: it walks the byecode heap starting from the value you hand it
08:41:52 <mmorrow> and gives back the graph
08:42:02 <mmorrow> , [$ty|vacuum|]
08:42:05 <lunabot>  forall a . a -> [] ((Int, [] Int))
08:42:40 <quicksilver> Sargun_Screen: no.
08:42:43 <EvilTerran> Sargun_Screen, "... :: (Fractional t) => t" means: for any type t, if t is an instance of the typeclass "Fractional", t is a valid type for "..."
08:42:51 <quicksilver> Sargun_Screen: it means 4.2 is "Fractional t => t"
08:42:57 <quicksilver> Sargun_Screen: not "Fractional" ;)
08:43:03 <quicksilver> Sargun_Screen: Fractional is a class not a type.
08:43:13 <quicksilver> personally I just wouldn't bother to give a type signature for area.
08:43:14 <EvilTerran> you can read "is an instance of the typeclass" as "implements", if you want an OO analogy
08:43:14 <lilac> , vacuum fix
08:43:16 <lunabot>  [(0,[])]
08:43:23 <quicksilver> but if you want to, make it "Num n => n -> n -> n"
08:43:29 <quicksilver> :t (*)
08:43:31 <lambdabot> forall a. (Num a) => a -> a -> a
08:43:36 <quicksilver> because that's the most general type for *
08:44:27 <smiskis> 630 users! Has this any correlation to usage in the industry?
08:44:55 <mreh> yes
08:44:57 <ikke> no
08:44:57 <ikke> :|
08:45:07 <ikke> with the usage in the academy maybe
08:45:08 <dons> blackh: very cool. what about hxt?
08:45:08 <lambdabot> dons: You have 10 new messages. '/msg lambdabot @messages' to read them.
08:45:13 <mreh> sure if 630 people use it, then 630 use it
08:45:24 <ikke> mreh lmao
08:45:27 <doserj> a negative correlation, of course. industrial users don't have time for IRC
08:45:47 <quicksilver> industrial users can't hear IRC over all those drills.
08:46:19 <earthy> industrial users tend to be locked behind atrocious firewalls disallowing them access to IRC
08:46:32 <mreh> earthy, i used to be there
08:46:41 <mreh> then i broke free into unemployment!
08:46:44 <earthy> which is why e.g. #asp is fairly quiet. :)
08:46:58 <dons> smiskis: there's industry users sitting in here, and industry workshop,, and an industry support services company
08:46:59 <jmcarthur> earthy, that's just because nobody likes asp
08:47:15 <earthy> jmcarthur: that is not entirely true
08:47:34 <earthy> (asp.net + f# is actually reasonably nice)
08:47:38 <EvilTerran> earthy, yeah, managers who don't have to program in it like ASP :P
08:48:08 <earthy> hey, I prefer plain asp.net + vb.net over PHP
08:48:16 <monochrom> I agree with the firewall argument. I also add that industry people don't have time to IRC.
08:48:31 <earthy> monochrom: s/have/take/
08:48:33 <mreh> half the peeps in #c are working
08:48:52 <jmcarthur> i know i don't go to the irc channels for languages i use at work, yet i go to irc channels for the languages i use outside of work
08:48:52 <monochrom> It's the same reason you don't find a dentist on IRC.
08:49:21 <monochrom> If you want a dentist, you go into an office and pay.
08:49:41 <jmcarthur> i also don't feel like i get very much out of channels like #c
08:49:48 <mreh> why would a dentist be looking for another dentist
08:49:52 <monochrom> If you want an ASP person, you also go into an office and pay.
08:50:17 <monochrom> If you want a lawyer, again you go into an office and pay.
08:50:18 <mreh> you go to irc for advice, not services
08:50:57 <monochrom> Oh yeah, you have to pay for their advice too. That is why they don't spend time on IRC giving advice.
08:51:05 <jmcarthur> some services are advice
08:51:58 <monochrom> However, haskell and math people don't manage to get paid for giving advice, so they have nothing better to do than IRC.
08:52:11 <monochrom> At least that's my theory.
08:52:29 <quicksilver> I'm in other IRC channels on topics you most certainly can get paid for consultancy
08:52:34 <quicksilver> (databases, web programming)
08:52:42 <quicksilver> and yet there are still useful people there.
08:52:48 <quicksilver> they're not as nice as this one, of course.
08:53:07 <monochrom> Of course it is not an all-or-nothing thing.
08:53:11 <mreh> @faq Can Haskell make you a nicer person?
08:53:12 <lambdabot> The answer is: Yes! Haskell can do that.
08:53:21 <monochrom> But notice how there is no legal advice IRC channel.
08:53:50 <quicksilver> you obviously didn't use to hang out in #debian in the old days
08:54:00 <quicksilver> we used to spent a lot of time talking law and software licenses
08:54:06 <doserj> monochrom: in some countries, that would be illegal, anyways...
08:54:09 <quicksilver> and we did have a qualified copyright attorney or two.
08:54:10 <monochrom> The explanation for the existence of database and programming advice in IRC is the same as that of open source software.
08:54:17 <kadaver> does all browsers result int he same type of requests?
08:54:19 <Zao> Too much free time?
08:54:33 <mreh> kadaver: check out http
08:54:35 <quicksilver> kadaver: they hopefully all obey the HTTP protocol.
08:54:39 <paper_cc> kadaver: well, they do HTTP =)
08:54:47 <quicksilver> kadaver: there are considerable variations permitted by that protocol.
08:54:55 <mreh> HTTP protocol, pah, what a misuse of langauge
08:54:57 <paper_cc> kadaver: but they may or may not use Continue etc.
08:55:02 <quicksilver> different headers, different protocol versions, keep-alive, content negotiation.
08:55:07 <quicksilver> mreh: sorry ;)
08:55:07 <mreh> hypertext transfer protocol protocol
08:55:40 <jmcarthur> most browsers are not compliant, sadly. i don't think PUT and DELETE are optional in the spec, but most browsers don't support them
08:55:47 <koeien> mreh: that is true, but this occurs far far far more often
08:55:48 <kadaver> obv noone would say they use Haskell,everyoen says they use Java to fool the competition.
08:56:13 <koeien> jmcarthur: if the browser never issues a PUT request, why does it matter?
08:56:25 <koeien> you mean in forms?
08:57:14 <jmcarthur> yeah
08:57:22 <koeien> is that even legal? ;)
08:57:32 <jmcarthur> not that the behavior can't just be emulated by POST, of course, but it's still stupid that it's not supported when it's in the spec
08:57:49 <jmcarthur> koeien, legal html? pretty sure
08:57:53 <koeien> jmcarthur: ok
08:58:41 <monochrom> I say I never prove my programs correct to fool the competition.
08:59:29 <monochrom> Gosh I miss parentheses and scoping. Why do natural language inventors not introduce scoping.
08:59:57 <mreh> what does haskell use?
08:59:58 <jmcarthur> "natural language inventors"?
09:00:23 <mreh> i think he means, normal people
09:00:41 <monochrom> inventors of natural languages
09:00:41 <jmcarthur> lojban has parens and lambda abstraction, i think
09:00:46 <jmcarthur> but it's not natural
09:02:19 <RayNbow> @seen roconnor  -- today, the start of another episode of two people who keep missing each other :p
09:02:19 <lambdabot> roconnor is in #haskell. I don't know when roconnor last spoke.
09:02:56 <monochrom> . o O ( This is why message queues work better than shared variables. )
09:03:43 <jmcarthur> took me a second to get that
09:05:13 <montymonty> hi. does anyone know, is there a character convention for "relative to"? like i have a.x = 100, and i want y.x = #-25 (ie. 75)
09:05:46 <vixey> huh??
09:05:55 <vixey> a.x ?
09:05:57 <koeien> explain?
09:06:05 <vixey> montymonty: what language is this/
09:06:10 <montymonty> no language
09:06:14 <monochrom> y.x = a.x - 25
09:06:18 <vixey> well can you rewrite it in haskell?
09:06:41 <montymonty> monochrom: yes, but i cant write that
09:06:57 <monochrom> Is "a.x - 25" OK?
09:06:58 <Eridius> montymonty: what is this a.x syntax supposed to mean?
09:07:09 <vixey> "no language" doesn't support variables?
09:07:11 <jmcarthur> (\x -> x-25)  -- 25 less than x?
09:07:20 <Eridius> (-25)
09:07:28 <monochrom> "25 less"
09:07:30 <jmcarthur> Eridius, that's negative 25 :P
09:07:33 <Eridius> jmcarthur: BAH
09:07:37 <montymonty> Eridius: that might work
09:07:40 <Eridius> (- 25)
09:07:40 <jmcarthur> :t subtract 25
09:07:41 <lambdabot> forall t. (Num t) => t -> t
09:07:47 <jmcarthur> :t (- 25)
09:07:48 <lambdabot> forall a. (Num a) => a
09:07:53 <Eridius> oh come on!
09:07:59 <koeien> yeah the infamous unary minus!
09:07:59 <Eridius> there's a space there!
09:08:03 <monochrom> "no language" is a lie. you must have some language in mind. or even multiple languages.
09:08:03 <jmcarthur> Eridius, an unfortunate wart
09:08:14 * Eridius flails wildly
09:08:26 <monochrom> or you want to invent a new language
09:08:40 <Eridius> ((-)5)
09:08:43 <koeien> it should die, people that want to do -1 should write (0-1) instead
09:08:43 <Eridius> :/
09:08:52 <jmcarthur> Eridius, that's (5-)
09:08:53 <koeien> or the space convention (makes it a bit harder on the parser maybe)
09:08:57 <montymonty> monochrom: yes, i need to pass syntax to a variable
09:08:59 <Eridius> koeien: or steal some other character as the unary prefix operator
09:09:06 <Eridius> jmcarthur: BAH I say, BAH!
09:09:12 <Eridius> (flip (-) 5)
09:09:31 <jmcarthur> might as well just say subtract 5
09:09:34 <montymonty> then parse that syntax, without access to the referenced var
09:09:35 <Eridius> :(
09:09:41 <isaacd> koeien: I tried to propose that once: it seemed to make the parser too messy for some (e.g. (x-5))
09:09:58 <montymonty> i was wondering if anyone knew a "math" convention for it
09:10:02 <koeien> isaacd: true
09:10:11 <monochrom> If you want to say "y.x is 25 less than a.x" I don't see why you can avoid mentioning a.x.
09:10:19 <jmcarthur> montymonty, it sounds like you want lambda abstraction, no?
09:10:38 <koeien> montymonty: i don't see how you can do this
09:10:48 <montymonty> well, i really want to reassign x based on previous x (sorry i know, not haskell)
09:10:49 <monochrom> Please don't tell me you're re-inventing English "y.x is less than him --- oh you know what I mean by him, com'on you don't need me to say a.x".
09:10:49 <kadaver> so it isnt enough to implement GET and POST in a webeserver? the few sites i ahev doen only use that,never HEAD PUT etc
09:11:03 <EvilTerran> $_!
09:11:20 <Eridius> kadaver: what does the HTTP spec say?
09:11:28 <jmcarthur> kadaver, HEAD is used a lot, i think
09:11:29 <montymonty> Eridius: what is that perl?
09:11:34 <EvilTerran> kadaver, well, you should probably be able to deal with HEAD, too
09:11:36 <Eridius> montymonty: you mean EvilTerran
09:11:51 <jmcarthur> kadaver, to see when a resource was last updated, potentially avoiding redownloading the whole thing, etc.
09:11:54 <montymonty> sorry, i just see the big E
09:12:08 <vixey> montymonty: why are you asking haskell this
09:12:36 <monochrom> It's the best place to ask for advice on language design.
09:12:36 <EvilTerran> montymonty, i was thinking of perl, yeah; monochrom's comment reminded me of my tendency to pronounce $_ as "it" in my head
09:12:55 <jmcarthur> monochrom, #oasis ?
09:12:55 <montymonty> because i figure of all the languages, the people in here would know a more "mathy" way
09:13:04 <vixey> bluh
09:13:08 <vixey> ask #haskell-blah or something
09:13:13 <jmcarthur> well, except #oasis is purposely not about syntax
09:13:32 <jmcarthur> montymonty, i don't think we even get what it is you want to do yet
09:13:50 <jmcarthur> montymonty, i suspect that you are after lambda abstraction, but i'm not sure
09:14:35 <monochrom> If you ask about language design in #haskell, you tend to get suggested to mimic haskell... :)
09:14:41 <montymonty> ok, a.x = 50; a.apply(x:'-25') => a.x = 25
09:15:18 <monochrom> a.modify(x, \z -> z - 25)
09:15:28 <jmcarthur> what he said
09:15:41 <EvilTerran> first-class field names!
09:15:45 <monochrom> You can also replace \z -> z - 25 by (- 25)  (Haskell sectioning)
09:15:47 <RayNbow> hmm
09:15:56 <RayNbow> Δ is a constructoroperator in Haskell?
09:16:01 <EvilTerran> monochrom, except that'd be (subtract 25) in haskell :P
09:16:01 <jmcarthur> monochrom, well, in an ideal world you can
09:16:09 <monochrom> oops.
09:16:10 <EvilTerran> RayNbow, it's a capital letter, isn't it?
09:16:12 <RayNbow> oh wait
09:16:15 <RayNbow> I just noticed :p
09:16:46 <EvilTerran> so, constructor, but not operator
09:17:01 <monochrom> Here is another. a.eval("x := x - 25")
09:17:19 <monochrom> I call them 'modify' and 'eval' for a reason.
09:17:36 <montymonty> right, i like that ':='
09:17:49 <monochrom> a.modify(field, function) means: use the function to compute the new value for the field.
09:18:27 <mreha> does javascript and all it's derivatives have a purely functional core?
09:18:39 <monochrom> a.eval( string ) means: interpret and execute the code in the string, under a's scope, i.e., try to use a's fields if you see a variable name.
09:18:51 <montymonty> mreha: yes, at least js and as3
09:19:09 <monochrom> 'modify' and 'eval' therefore will do very different things in general.
09:19:38 <monochrom> It is an example of eval but not of modify: a.eval("print x")
09:19:39 <mreha> montymonty: do you have any references? like papers or blog entries i can read
09:20:20 <mreha> can you do recursive datastructures?
09:21:01 <montymonty> mreha: http://tinyurl.com/c93rt6
09:21:22 <vixey> man you are annoying
09:21:27 <vixey> can you go into -blah
09:21:43 <mreha> me?
09:21:46 <montymonty> sorry, just wanted to type it. anyway thanks all for the suggesstions!
09:21:49 <vixey> no montymonty
09:21:54 <monochrom> Oh javascript can do eval alright.
09:22:35 <monochrom> err nevermind, mixing up two threads
09:23:27 <mreha> thank you monty
09:23:33 <monochrom> Every language since Fortran has a pure functional core. Just probably not higher-order or support anonymous functions.
09:23:51 <koeien> monochrom: you mean, every language has a semantics ?
09:24:16 <mreha> i dont really know what i'm say then
09:24:18 <monochrom> When you write "x+y*z" instead of "tmp2 := y*z; now I want x+tmp2" you're already doing functional programming.
09:24:19 <EvilTerran> heck, you can give functional semantics for bytecode, can't you?
09:24:28 <mreha> ill ask when i work out what it is I want
09:24:50 <koeien> EvilTerran: of course, but semantics i've seen are functional
09:25:46 <wli> wtf. is a first-class label?
09:26:06 <monochrom> You can store labels in variables, pass them in parameters...
09:26:49 <wli> Sounds H98.
09:26:52 <monochrom> void MyJump(Label x) { goto x; }
09:27:34 <wli> I was referring to record labels.
09:27:37 <monochrom> If you have continuations, you can already do this.
09:27:42 <Eridius> wli: like the RIAA?
09:28:03 <monochrom> Oh oops. I guess you can pass field names in parameters and variables then.
09:28:09 <vixey> well continuations aren't like goto
09:28:13 <wli> No. Like l1 in data T = C { l1 :: Int, l2 :: Char, l3 :: Double }
09:28:25 <EvilTerran> wli, i guess functional references are akin to first-class field names
09:28:39 <monochrom> MyRecord r {...}; void SetField(Field f) { r.f = 0; }
09:29:19 <EvilTerran> seeing as they encapsulate the basic idea of a field name (a "getter" and a "setter" for an element of a compound type)
09:29:50 <monochrom> Yeah if record syntax is syntactic sugar for getter + setter, you can already do this.
09:30:06 <PeakerWork> record field names should be accessors/frefs to the fields, not getters
09:30:07 <PeakerWork> IMO
09:30:13 <wli> EvilTerran: How is that supposed to interact with variants?
09:30:30 <EvilTerran> i have no idea, having done no reading on the matter
09:30:31 <PeakerWork> using an accessor as a getter is trivial, and composing accessors is nice.  Using setter syntax and composing those is not nice at all
09:30:32 <EvilTerran> :P
09:30:33 <monochrom> That will be very sophisticated dynamic typing.
09:30:50 <PeakerWork> Hmm.. accessor composition ^>  should probably be (>>>) instead...
09:30:54 <PeakerWork> (just use arrow instances)
09:31:18 <wli> data T = C1 { l1 :: T1, l2 :: T2 } | C2 { l3 :: T3, l4 :: T4 }
09:32:16 <wli> What are label accessors supposed to do there?
09:32:44 <vixey> l1 (C2 _ _) = undefined probably
09:33:02 <monochrom> "404 no page found" :)
09:33:03 <ski> one could consider partial labels
09:33:10 <PeakerWork> I think type products and type sums should be separate things, not combined in a single ADT, and then records would only do type products, no sums :)  But if you do have this in ADT, you're going to have to have the accessors be just as unsafe as the getters currently are
09:33:28 <ski> head :: LensM Maybe [a] a
09:33:42 <ski> lab1 ::LensM Maybe T T1
09:33:46 <PeakerWork> ski: why not hard-code to Maybe?
09:34:00 <PeakerWork> ski: How do you build the monad value if it isn't Maybe?
09:34:04 <ski> you might want other type constructors, sometimes ?
09:34:34 <ski> allElements :: LensM [] (Tree a) a  -- i'm not too sure about this, though
09:35:00 <PeakerWork> ski: How would:   head :: LensM Reader [a] a    work?
09:35:08 <vixey> ski, you could map over the leaves and get back a mapped tree that way?
09:35:12 <ski> (obviously that can't have a general getter)
09:35:15 <PeakerWork> ski: (Reader Int) that is
09:35:25 <EvilTerran> what the heck is LensM?
09:35:30 <ski> PeakerWork : it wouldn't. simply because that wouldn't be the type of `head'
09:35:53 <wli> Peaker: Why would you want to hobble the type system in such a fashion?
09:36:04 <PeakerWork> ski: ah, but what other monads are interesting to combine with LensM, besides Maybe?
09:36:20 <ski>   newtype LensM m a b = LM {unLM :: a -> m (b,b -> a)}  -- i think
09:36:21 <PeakerWork> ski: sorry, missed the LensM [] example
09:37:27 <gwern> @ask dons incidentally, me and john are discussing how to handle gitit plugins since we now have 4 or 5. do you have any plugins after your months of use?
09:37:27 <lambdabot> Consider it noted.
09:37:39 <ski> (i have no idea if `m' ought to be a monad, or if applicative/idiom would be enough, et.c. .. i'm just saying it might be worthwhile trying to investigate various generalizations)
09:37:44 <PeakerWork> data Accessor whole part = Accessor (whole -> (part, part->whole)) ;  allElements :: Accessor (Tree a) [a]
09:37:56 <ski> that's not the same thing
09:38:21 <PeakerWork> ski: What does the allElements above do?
09:39:45 <ski> Tangible Value 10.2 IO <http://haskell.org/haskellwiki/TV#IO>
09:39:50 <wli> Peaker: How are variants supposed to work at all if they're not part of a single type? One has, at the very least, nonempty binary trees like data NET t = NETBranch t (NET t) (NET t) | NETLeaf t
09:40:09 <ski> i was thinking of the distinction between `onLines' and `perLine'
09:40:24 <wli> Peaker: Or even Either
09:41:42 <ski> i.e. the above `allElements' (should be renamed `everyElement' i suppose) would allow simultaneous modification
09:42:29 <wli> Peaker: How is Either String supposed to have a MonadError String (Either String) instance?
09:43:26 <ski> wli : doesn't it already have one ?
09:44:12 <wli> ski: Peaker was proposing removing support for coproduct type declarations or maybe something I'm not catching on to.
09:44:16 <ski> (.. hm, or maybe general setter works)
09:44:49 <vixey> it's not really right to call Agda "proof assistant" is it
09:44:55 <liyang> :3
09:44:58 <liyang> I'm using it as one.
09:45:03 <vixey> how?!
09:45:12 <liyang> how... not!?
09:45:17 <vixey> actually, the more interesting question is what do you prove ?
09:45:24 <ski> define "proof assistant" ?
09:45:39 <vixey> well there are no tactics, .. so it's all lambda terms or reflective proofs
09:45:55 <liyang> There's a ring solver.
09:45:56 <jmcarthur> vixey, wikipedia calls it a proof assistant, which also confused me. agda is a programming language that happens to provide features that are pretty good for proving things
09:46:14 <wli> Well, I'd just scrutinize things in a case statement for record access.
09:46:35 <vixey> Agda is a proof assistant: It is an interactive system for writing and checking proofs
09:47:29 <wli> I'm not sure why the getters and setters are so great or important.
09:47:40 <jmcarthur> surely whoever said that misunderstood the purpose of agda
09:49:16 <wli> Or maybe even provide some sort of fresh construct for record access that deals with variants somehow.
09:49:18 <ski> wli : would you rather write `rec {l0 = (l0 rec) {l1 = (l1 (l0 rec)) {l2 = ..(l2 (l1 (l0 rec)))..}}}' ?
09:49:38 <liyang> vixey: I give SemiringSolver.prove a list of vars, symbolic representations of the LHS and RHS, and it returns me an equality term.
09:50:07 <liyang> (I'm doing proofs of operational semantics stuff.)
09:50:38 <wli> ski: Instead of what?
09:51:09 <ski>   modify (l0 >>> l1 >>> l2) (\x -> ..x..)
09:51:16 <ski> (or something similar)
09:53:14 <dons> so kids. how are we going to take over the world today?
09:53:27 <koeien> nuke it from orbit
09:53:28 <profmakx> purely?
09:53:29 <lilac> am i behind the times? i'm still trying to avoid success
09:53:48 <dons> always with the "nuke from orbit" solution
09:53:58 <wli> ski: I'd use let expressions, for starters.
09:54:21 <liyang> jmcarthur: given my limited experience of Coq (if you'll accept that as a proof assistant), I find the basic idea pretty similar -- i.e. you state a proposition, then the Emacs mode tells you your goal and assumptions, but Agda to be a lot more transparent. I didn't like the linear proof scripts of Coq, which make no sense unless you happen to be going through them at the time.
09:54:26 <lilac> dons: how are we going to take over the world? oleg-style, in the type-system.
09:54:57 <quicksilver> dons: clearly the currently trendy path to world domination is via an iPhone app.
09:55:07 <quicksilver> dons: so, we should write a native arm backend.
09:55:16 <dons> mm
09:55:17 <quicksilver> dons: if we can do that in the type-system, that would be a bonus.
09:55:30 <Philippa_> liyang: tactics langs feel really weird a lot of the time, yeah
09:55:54 <ski> wli : yes, one could avoid `l0 rec' (et.c.) in multiple places .. but then the code looks even more clumsy
09:56:04 <Philippa_> I think the linearity's kinda the worst of it, I like the look of what Edwin's trying with Idris there
09:56:34 <wli> ski: let r1 = l0 rec ; r2 = l1 r1 ; r3 = l2 r2 ; ... in rec { l0 = r1 { l1 = r2 { l2 = ...
09:56:36 <ski> wli : i just want to modify a field in a nested record (.. also, perhaps one of those records are in a list of records, instead of directly in a field)
09:56:57 <ski> if you defined
09:57:16 <liyang> I quite like SemiringSolver.prove. You have be a lot more explicit, but that only serves to document the code (or proof, if you will.)
09:57:31 <ski>   l0Mod :: Rec0 -> (Rec1 -> Rec1) -> Rec0
09:57:38 <ski>   l1Mod :: Rec1 -> (Rec2 -> Rec2) -> Rec1
09:57:41 <liyang> Only problem with Agda is that it's not as fast as I'd like it to be.
09:57:44 <vixey> liyang, did you use it in this operational semantics stuff?
09:57:48 <ski>   l2Mod :: Rec2 -> (Foo -> Foo) -> Rec2
09:57:51 <ski> then you could write
09:57:54 <liyang> vixey: am using it right now. :3
09:57:57 <vixey> cool
09:57:59 <dons> lilac: what aspect isn't as fast?
09:58:03 <dons> the generated code?...
09:58:19 <ski>   l0Mod rec $ \rec1 -> l1Mod rec1 $ \rec2 -> l2Mod rec2 $ \x -> ..x..
09:58:50 <liyang> (dons: was that aimed at me?)
09:58:50 <ski> the lenses is just a tidying-up of this, also adding the getter into the `l0Mod', et.c. things
09:58:54 <dons> lilac: yeup
09:59:14 <liyang> (dons: I repeat my question. ;p~~)
09:59:23 * wli has never heard of lenses.
09:59:41 <quicksilver> wli: http://twan.home.fmf.nl/blog/haskell/overloading-functional-references.details
09:59:48 <dons> lilac: what aspect of agda isn't fast enough?
09:59:49 <quicksilver> for one formulation, under a different name.
09:59:56 <dons> is it the compiler, the interpreter, or the generated code?
09:59:57 <vixey> :S
10:00:00 <ski> lenses / functional references / generalized accessors  .. more or less the same things
10:00:16 <liyang> dons: nope, never even run the compiler. I mean, the typechecker/interpreter sometimes takes an age.
10:00:41 <liyang> dons: I mean, srsly. You expect me to run my proofs? ;)
10:02:26 <dons> ah hehe
10:02:33 <quicksilver> srs cat has a proof of that, but it won't fit in the mrgn ?
10:02:38 <dons> i thought you might be extracting ... you know .. code
10:02:46 <liyang> quicksilver: :3
10:02:46 <dons> because what's the point otherwise? :)
10:03:10 <liyang> dons: in this instance I'm using it as a proof assistant, not a programming language. :)
10:03:14 <jeffersonheard> okay, I'm overcomplicating things...  there should be some simple Parsec applicative parser that takes a namespace qualified XML tag and spits out a string that is a valid qualified Haskell type constructor
10:03:16 <dons> crazy talk
10:03:33 <dons> jeffersonheard: oh, one of the xml reflection libs?
10:03:37 <dons> doesn't hxt support that?
10:03:51 <dons> or you want something much simpler... ?
10:04:01 <jeffersonheard> something simpler
10:04:11 <liyang> (All hail Curry-Howard! Praised be their names!)
10:04:16 <jeffersonheard> parsecthingie "kml:mySimpleType"  -> "Kml.MySimpleType"
10:05:02 <jeffersonheard> dons: I'm writing an XML reflection lib for general XML schemas from the W3C definition, because the one that someone pointed me to yesterday doesn't parse general schemae
10:05:36 <vixey> http://wiki.portal.chalmers.se/agda/
10:05:37 <jeffersonheard> basically something that writes out a type hierarchy, complete with bounded types and validator functions, and also the parser that turns the XML into that hierarchy
10:06:20 <doserj> jeffersonheard: not so simple. what should parsecthingie "kml:MySimpleType" evaluate to?
10:06:24 <jeffersonheard> Like I said, it should be simple to write that parser, but I think I'm in post-lunch food coma
10:06:28 <liyang> vixey: oh yes. New (proper) release and everything. There's even been work on the documentation(!)
10:06:39 <jeffersonheard> doserj, "Kml.MySimpleType"
10:07:03 <jeffersonheard> the rule is that anything following a colon, and the beginning of the string should be capitalized
10:07:05 <BMeph> wli: I still haven't read it yet, but I believe http://www.cis.upenn.edu/~bcpierce/papers/boomerang.pdf should be helpful (re: lenses).
10:07:09 <jeffersonheard> and the colons turn into dots
10:07:09 <doserj> jeffersonheard: so two different XML schema types can map to the same haskell type?
10:07:14 <Taejo> it really bugs me that my computability theory textbook uses a down arrow to represent definedness and an up arrow to represent undefinedness, in contrast to the Haskell/order-theoretic idea that downward is less defined (with *bottom* the least defined value)
10:07:15 <wli> The only way this stuff makes sense is if you refuse to allow types with multiple alternatives to use field labels.
10:07:31 <jeffersonheard> doserj, it's *highly* unusual for someone to write a schema so braindead
10:07:49 <doserj> jeffersonheard: I like to break software :)
10:08:37 <jeffersonheard> I suppose I could prepend with "T" instead of merely capitalizing the first of the string, but I prefer an intuitive interface to complete generality, as I plan on using this for w3c standards schemae, which are mostly sanely constructed
10:09:17 <wli> I actually use field labels on types with multiple alternatives.
10:10:28 <Eridius> @pl \x -> fst x <= snd x
10:10:28 <lambdabot> uncurry (<=)
10:12:52 <wli> I was not under the impression it was an uncommon practice.
10:13:02 <marcot> Hello, I'm going to write a simplified pascal compiler in my course of compilers in haskell.  What would you recommend for using as frontend?  Alex + Happy?
10:13:28 <Botje> marcot: i've used parsec to good effect
10:13:39 <lament> parsec!!!
10:13:41 <Botje> marcot: http://infogroep.be/~dharnie/milc/
10:13:56 <ski> wli : why would it not work if you use the same field label in all alternatives ?
10:13:59 <sw17ch> @seen dons
10:13:59 <lambdabot> dons is in #haskell-soc, #gentoo-haskell, #concatenative, #arch-haskell, #darcs, #yi, #xmonad, #ghc and #haskell. I last heard dons speak 10m 7s ago.
10:14:05 <jeffersonheard> Suppose I could just write a function instead of using parsec for such a simple task
10:15:00 <wli> ski: I suppose it could if you allowed labels to be shared across alternatives (which is reasonable).
10:15:08 <marcot> Botje: Ok, I'll try it.  I thought I would have to do things by hand using Parsec, and that with happy things would be more automated.  So this was a wrong impression?
10:15:32 <vixey> you have to write the whole parser in both cases
10:15:53 <wli> ski: e.g. data NET t = NETLeaf { val :: t } | NETBranch { val :: t, left, right :: NET t }
10:16:05 <Botje> marcot: i don't have any experience with happy. but I thought parsec would be a lot of trouble until i found the operator table :)
10:16:38 <wli> ergh, s/left, right/leftNET, rightNET/
10:16:59 <ski> wli : yes, partial labels are trouble .. that's why i was thinking one could have a `LensM Maybe' to handle this
10:17:54 <Ninju> can someone please help me figure out the type of main: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2860#a2860
10:18:06 <Ninju> I'm pulling my hair out here, I guessed it would just be IO ()
10:18:08 <Ninju> but it isn't working
10:18:54 <Botje> Ninju: align the pattern and PutStrLn in your code
10:19:16 <Botje> no wait
10:19:20 <seliopou> the pattern <- patterns is in the list monad
10:19:21 <Ninju> Botje: Sorry? I don't know what you mean.
10:19:23 <Botje> Ninju: pattern <- patterns only works in the list monad
10:19:45 <Botje> you want forM_ patterns $ \pattern -> ...
10:19:50 <Ninju> damnit, I thought that *might* be it
10:20:01 <Ninju> ok, great, thanks
10:20:20 <Ninju> yeah of course, it makes sense
10:20:29 <Ninju> I was just being an idiot
10:20:31 <Ninju> thanks
10:20:42 <marcot> Botje: thanks, I'll take a look at Parsec.
10:24:46 <Eridius> ugh, do I really have to explicitly compile regex-tdfa against parsec 3.0 in order to use it in yi?
10:25:19 <jeffersonheard> won't cabal install do that for you?
10:25:33 <Eridius> parsec 2.1.whatever is the default for parsec
10:25:38 <Eridius> and regex-tdfa declares it depends on parsec -any
10:25:41 <Eridius> but HOC depends on parsec 3.0
10:25:50 <Eridius> so I have to say `cabal install regex-tdfa --constraint='parsec >= 3.0'`
10:25:56 <Eridius> in order to get regex-tdfa to use the right parsec
10:26:21 <Eridius> oh wtf? darcs didn't tell me I had a conflict!
10:26:22 <Saizan> you can just cabal install yi --fuseHOC and cabal-install will recompile regex-tdfa automatically if necessary
10:26:29 <Eridius> what's -fuseHOC?
10:26:38 <Saizan> -f is how you set the flags
10:26:39 <Eridius> oh the flag for yi
10:26:47 <Eridius> sorry, didn't pay attention to the package name you listed
10:26:47 <Saizan> useHOC is a flag i invented here :)(
10:26:50 <Eridius> heh
10:27:05 <Eridius> I've been building yi with `runghc Setup whatever` because it seems like using `cabal` always does a clean build
10:27:12 <Eridius> and so it's faster to just use runghc Setup
10:27:40 <Saizan> if you use "cabal install" without a package name then it does the same
10:27:52 <Saizan> otherwise it looks up the package on hackage
10:28:00 <Eridius> hmm
10:28:20 <Saizan> you've to pass it the configure flags though
10:28:55 <Eridius> well, this isn't strictly an error, it's warning me that I may run into issues because of two libraries using different versions of parsec. Will that actually make cabal reject the HOC flag?
10:29:04 <Eridius> (flag is actually called cocoa btw)
10:30:06 <Eridius> hrm, darcs is confusing me with this conflict
10:30:24 <Eridius> it's not making clear what the change introduced by my patch was, and the change introduced by the conflicting patch
10:30:27 * Eridius wants to see a 3-way merge :/
10:30:53 <Saizan> "cabal install" doesn't give the warning but recompiles packages to avoid it if it can, otherwise errors out
10:31:04 <Eridius> huh
10:31:06 <Saizan> the warning is not fatal per se
10:31:25 <Saizan> (being a warning..)
10:31:46 <Eridius> yeah, but I haven't had any issues having regex-tdfa depend on parsec 3 so far
10:32:08 * Eridius stabs darcs repeatedly in the head
10:32:25 <EvilTerran> i thought the HEAD was ghc, not darcs...
10:32:30 <Eridius> you mean git
10:32:42 <jeffersonheard> alright, well, I'm generating the type hierarchy now...  now for the parser
10:32:58 <Eridius> arg, why can't darcs show me a 3-way merge? I want to see how each patch differs from their common ancestor!
10:33:11 * EvilTerran notes several different parses for "you mean git"
10:33:26 <Eridius> EvilTerran: ghc is a compiler. HEAD is git
10:33:51 <Saizan> doesn't it show the conflicting parts with vvvvvvvvvvvvvvvvvv ... *************** ... ^^^^^^^^^^^^^^?
10:33:51 <EvilTerran> ah, you mean "HEAD" is a git-ism?
10:33:58 <Eridius> EvilTerran: yes
10:34:16 <Eridius> Saizan: yes, and I threw away one half of that and kept the other half. Now it's marking more stuff as changed in my working copy than I believe it should
10:34:23 <EvilTerran> ah, i see; i thought it was a ghc-development-ism
10:34:26 <Eridius> Saizan: a hunk that was added by a patch I just pulled is showing as whatsnew
10:34:37 <ski> (Eridius : <http://arcanux.org/lambdacats/fixed-in-head.jpg> ?)
10:34:47 <vixey> haha
10:34:54 <Eridius> EvilTerran: I don't know anything about ghc, but HEAD is the name for the current checked-out commit (which is almost always a branch, so in general it means the most recent commit on the checked-out branch)
10:35:04 <Saizan> Eridius: it's new because you've resolved the conflict by "adding" that modification
10:35:04 <Eridius> ski: hah, nice
10:35:06 <Eridius> :/
10:35:32 <Eridius> Saizan: I'm irritated because I want to make sure I haven't accidentally introduced any changes against the new hunk from that patch
10:35:52 <Saizan> i've seen HEAD generally used for "main devel repo", regardless of the content/vcs
10:35:54 <lilac> EvilTerran: did you parse that as 'you are a mean git' too?
10:35:56 <Eridius> I would much prefer to just unrecord my patch, then try and apply it on top of the new patch, and get the conflict in that direction
10:36:03 <EvilTerran> lilac, initially, yeah :P
10:36:10 <Eridius> haha
10:36:24 <jmcarthur> Eridius, when darcs has a conflict, it "resolves" it by excluding the conflicting changes and then puts some temporary stuff in your working copy for you to fix youself as another patch
10:36:24 <EvilTerran> i thought Eridius was addressing darcs
10:36:31 <Eridius> Saizan: I usually see trunk for that. The all-caps HEAD is something I've only seen in the context of git
10:37:05 <Eridius> jmcarthur: yes, I'm just irritated that darcs seems to have no way for me to compare this new version against either of the conflicting patches in isolation
10:37:09 <Eridius> hell, it didn't even tell me which patches conflicted
10:37:32 <jmcarthur> darcs mark-conflicts?
10:37:32 <Eridius> if I can figure out exactly the two conflicting patches I can probably use `darcs diff --from-patch`
10:37:44 <Eridius> jmcarthur: that just reintroduces the vvvv **** ^^^^ stuff
10:37:59 <jmcarthur> oh which patches, not in which files, gotcha
10:38:02 <Eridius> right
10:38:32 <Saizan> yeah, i think there's an open ticket for that
10:38:33 <Eridius> clearly darcs knows it has conflicting patches, why can't I just ask it?
10:38:46 <jmcarthur> i don't know the "correct" way to do it, but you could just obliterate the patches you just pulled and repull them one at a time
10:38:54 <Eridius> darcs is neat in theory, but in practice I find it extremely difficult to use :/
10:39:01 <Eridius> jmcarthur: I created one of the patches
10:39:03 <jmcarthur> Eridius, i think it's more interface than theory
10:39:05 <Eridius> it's a WIP patch that hasn't left my repo yet
10:39:28 <Saizan> you can send -O it
10:39:37 <jmcarthur> Eridius, oh... i think that is one of the worst "features" in darcs is that you can have WIP changes and pull
10:39:48 <Eridius> jmcarthur: yeah, in git I'd keep them on their own topic branches
10:40:07 * Saizan pulls before recording
10:40:22 <Eridius> Saizan: I've had this patch sitting recorded in my repo for about 2 weeks
10:40:27 <jmcarthur> it should at least be transactional so that if there are conflicts it can roll back and you don't have to deal with them yet
10:40:58 <Eridius> with git I'd have no worries because I know that, regardless of what I do (short of some very specific commands), I can always recover my history for at least 2 weeks
10:41:04 <Saizan> you can force it to not pull if there are conflicts
10:41:10 <Eridius> (i.e. even if I completely obliterate a commit, it doesn't actually disappear for at least 2 weeks)
10:41:35 * Eridius should probably send -O just to make sure he has a saved copy of his patch
10:41:42 <Saizan> or use another branch
10:41:54 <Eridius> branch? in darcs? what is this you speak of?
10:42:22 <Baughn> > traverse show [1..5]
10:42:24 <lambdabot>   Not in scope: `traverse'
10:42:24 * jmcarthur keeps a separate darcs branch that stores every single patch ever made in the project even if it's been deleted in the main repo
10:42:44 <lilac> Eridius: branch in darcs = separate checkout
10:42:47 <Eridius> ah
10:42:47 <Saizan> Eridius: darcs put ../branch1
10:42:49 <jmcarthur> Eridius, in darcs, branch == repo
10:43:12 * jmcarthur prefer's git's in-place branching though
10:43:28 <Eridius> is there any particular reason all these haskell projects use darcs, or is it just a language loyalty thing?
10:43:36 * lilac thinks lambdabot should be able to spot semantically equivalent statements and add one of its own
10:43:37 <Eridius> "if we don't use darcs, who will?"
10:43:51 <jmcarthur> Eridius, i think it's a combination of language loyalty and sincere taste for the ideas behind darcs
10:43:59 <quicksilver> Eridius: it predates the popularity of all the other dvcses
10:44:11 <lilac> Eridius: i use darcs for small stuff i work on by myself because it's easy and quick and unobtrusive
10:44:11 <quicksilver> Eridius: and dvcs is at least a million times better than old-style vcs.
10:44:15 <Eridius> quicksilver: yeah, I used darcs for a few months to manage my CS homework stuff and then I discovered git
10:44:32 <quicksilver> personally I use bzr, because I happened to learn it first.
10:44:47 <lilac> to be honest, i'd probably use mercurial if i started a large project now
10:45:06 <Eridius> why?
10:45:18 <jmcarthur> Eridius, i used darcs for a bit years ago, got frustrated with some of the issues you are having, switched to git for a while, and recently switched back to darcs because i realized that with enough discipline darcs can be superior to git
10:45:26 <jmcarthur> it's unfortunate that it requires that discipline though
10:45:41 <lilac> Eridius: remembering reasons is harder than remembering conclusions, but i investigated this a couple of months ago and that was my conclusion :)
10:45:51 <Eridius> hehe
10:46:05 <quicksilver> I dont' really believe in commutting patches, which is the darcs-USP.
10:46:15 <quicksilver> beyond that it comes down to speed and UI.
10:46:21 <lament> I would use git because 1) it's the most popular and 2) it's what GHC maintainers chose
10:46:31 <lilac> Eridius: though as i recall, out of about 40 RCS tools, only darcs, git, hg and bzr weren't completely ruled out for some large flaw
10:46:38 <Eridius> git is by far the fastest, and it's UI has actually gotten to be pretty friendly
10:46:40 <jmcarthur> GHC maintainers are switching to git simply because it's faster, as far as i know
10:46:41 <Eridius> whygitisbetterthanx.com
10:46:47 <Saizan> i wouldn't use git because i don't have a bazillion patches yet :)
10:46:56 <Eridius> I love using git for even local projects that nobody else will touch
10:47:07 <jmcarthur> i am a long time git user and still prefer darcs now
10:47:07 <vixey> they don't have darcs on that site
10:47:15 <Eridius> `git init && git add -A && git commit -m 'Initial commit'`. Boom, saved my current state, and I don't have to worry
10:47:37 <vixey> what
10:47:48 <Eridius> vixey: go talk to Scott Chacon. However, that site was meant to be a *practical* comparison and IMHO darcs isn't practical ;)
10:47:52 <vixey> cp something backup-1
10:47:53 <jmcarthur> `darcs init && darcs add -r . && darcs record -a -m 'blah blah'. Boom
10:48:13 <vixey> Eridius: You are wrong then -- I've used darcs lots of times
10:48:15 <Eridius> vixey: oh sure, if I want a snapshot, but no, I'm going to be working in this dir for a while and I want to be able to save state as I go
10:48:29 <Eridius> jmcarthur: sure, except darcs is horribly impractical to use in my experience
10:48:42 <quicksilver> Eridius: it's obvious not, since it's used in practice.
10:48:43 <vixey> "Impractical" is just a buzzword that means nothing
10:48:54 <jmcarthur> Eridius, i used git-svn at work then switched to darcs and manual merging with svn and the latter is far easier than the former was
10:48:57 <vixey> You can hide behind any mistake you make by saying "it's practical to do so"
10:48:58 <quicksilver> Eridius: that site appears to be wrong about bzr.
10:49:05 <quicksilver> Eridius: I imagine therefore it is wrong about everything
10:49:06 <Eridius> jmcarthur: then you weren't using any of git's tools to help with merging
10:49:12 <jmcarthur> Eridius, yes i was
10:49:18 <quicksilver> you very rarely get unbiased comparisons
10:49:23 <Eridius> jmcarthur: I've never encountered a merge conflict that `git mergetool` didn't trivially solve
10:49:28 <quicksilver> the author always knows how to drive one system better than the others
10:49:29 <jmcarthur> i've been using git for a long time, and loved it, and still love it, but darcs is every bit as painless as git
10:49:37 <Eridius> quicksilver: wrong how?
10:49:42 <lament> at work, i use SVN and have no issues with it. Am I special?
10:49:45 <Eridius> quicksilver: that site is actually hosted on github, you can fork it and contribute changes
10:49:49 <jmcarthur> lament, yes
10:49:53 <Eridius> quicksilver: see the footer
10:50:02 <lament> woo! i'm special!
10:50:10 <vixey> SVN is great
10:50:31 <vixey> infact I would go as far as saying, SVN is practical
10:50:32 <tromp> everybody is special:)
10:50:47 <quicksilver> Eridius: bzr has cheap local branching; bzr is not that slow.
10:50:47 * jmcarthur doesn't think SVN is very practical
10:51:00 <quicksilver> Eridius: I suspect his bzr timings are based on an old version but he doesn't say that I can see.
10:51:03 <lilac> Eridius: well, that site as failed to persuade me that git is better than hg :) (3 advantages of which 1 is untrue and 1 is irrelevant) :D
10:51:07 <lament> you guys should define 'practical' in some sane fashion before talking about it. Just saying.
10:51:20 <vixey> jmcarthur: since practical means nothing I am just joking -- but I did have good experience with svn in the past
10:51:23 <Eridius> quicksilver: are you taking issue with actual benchmarking numbers? If you think bzr has gotten faster since those numbers were calculated, feel free to send an email to Scott (link is in the footer)
10:51:29 <tromp> it's impractical to define practical
10:51:40 <Eridius> lilac: so submit patches or email Scott
10:51:50 <Eridius> lilac: what's untrue though?
10:51:53 * Eridius hasn't actually used hg
10:51:53 <quicksilver> Eridius: I would, except I don't really care. I have no interest in persuading people to use bzr.
10:51:56 <eu-prleu-peupeu> hello
10:52:01 <quicksilver> Eridius: I'm just telling you since you brought it up ;)
10:52:04 <vixey> lament: practical is the programmers version of what governments say about terrorism -- it's lets you get away with anything if it's in the intrests of 'practicality'
10:52:05 <Eridius> hah
10:52:26 <quicksilver> Eridius: it doesn't appear to address the main disadvantage that I hear about git, which is it has a terrible UI. I don't know if that's true since I've never used it.
10:52:27 <eu-prleu-peupeu> i want to define a type that is a non-decreasing sequence of real numbers, how do i do that i haskell ?
10:52:33 <lament> quicksilver: you simply have to use mercurial, because of the nickname
10:52:34 <jmcarthur> i think the only thing listed at whygitisbetterthanx.com that puts git over darcs is that git's branches are in place
10:52:42 <vixey> eu-prleu-peupeu: impossible
10:52:43 <pumpkin> eu-prleu-peupeu: you don't
10:52:46 <jmcarthur> quicksilver, git's ui is not bad at all, really
10:52:48 <quicksilver> I know I'm poorly qualified to comment on systems I haven't used :)
10:52:54 <Eridius> quicksilver: that used to be true, back in git <= 1.4. Git 1.5 and 1.6 significantly improved the UI
10:52:58 <eu-prleu-peupeu> there is no way to ensure it ?
10:53:00 <eu-prleu-peupeu> :S
10:53:10 <tromp> hide the constructor
10:53:29 <Eridius> eu-prleu-peupeu: I don't think a type itself can encapsulate that constraint, but yeah do what tromp says and hide the constructor. write your own function which ensures that invariant
10:53:33 <lament> sure there is, first get only positive numbers (e.g. peano) and then store the difference between consecutive numbers. Write a bunch of sane accessor functions.
10:53:38 <tromp> supply a function that checks/enforces monotonicity
10:53:42 <pumpkin> eu-prleu-peupeu: maybe if you do type-level numbers it's possible, but then the numbers must be known at compile time
10:53:44 <Eridius> lament: hmm, good point
10:53:46 <lilac> Eridius: no cheap local branches. untrue is perhaps too strong; cheap local branches are available as an extension (http://hg.kublai.com/mercurial/extensions/localbranch)
10:54:05 <pumpkin> eu-prleu-peupeu: if you want that in general for run-time values, you need dependent types
10:54:26 <eu-prleu-peupeu> oh, i dont know what those are :/
10:54:26 <Eridius> lilac: ah, one of the many things that sounds so ridiculous to a non-hg-user - from watching other people use it, it seems like you need to install a half-dozen extensions just to get proper functionality
10:54:29 <vixey> if you want it for runtime .. use  assert
10:54:38 <eu-prleu-peupeu> i guess ill just say its a list of integers, and run a validation function whenever i use that list :S
10:54:45 <vixey> pumpkin, you really think using dependent types will be a good way to deal with what he is doing?
10:54:50 <pumpkin> eu-prleu-peupeu: it doesn't have to be whenever
10:54:54 <pumpkin> vixey: not at all :P
10:55:02 <vixey> it's odd to suggest it then
10:55:06 <lilac> Eridius: if that sounds ridiculous, that's fair enough. but the extensibility of hg is pretty good, and extensibility is an important feature for an RCS IMO
10:55:09 <tromp> sotring differences may lose precision
10:55:14 <tromp> storing
10:55:26 <lament> they're integers though
10:55:30 <Eridius> lilac: git is extensible by virtue of the fact that it was designed in the true UNIX style
10:55:31 <pumpkin> vixey: he asked how to ensure in the type system that you had a monotonic list, I told him
10:55:32 <tromp> he said reals
10:55:37 <lament> he then said integers
10:55:41 <lament> maybe he doesn't know :)
10:55:46 <tromp> oh, missed that:)
10:55:46 <lilac> Eridius: FWIW, i would choose bzr or hg over git simply because they have decent python interfaces for extensibility
10:55:50 <eu-prleu-peupeu> its reals, but greater than 0
10:56:07 <Eridius> lilac: git is plenty extensible
10:56:07 <pumpkin> hard :P
10:56:07 <tromp> ok, then differences are exactly representable
10:56:19 <eu-prleu-peupeu> mostly ill use them as integers, so the mathematical definition is reals
10:56:34 <eu-prleu-peupeu> s/so/but
10:56:36 <Eridius> lilac: git doesn't have a library API, instead it has 150 or so different commands (only about a dozen the end-user is supposed to touch, those are called porcelain (as opposed to plumbing))
10:56:41 <Philippa_> eu-prleu-peupeu: if you wanted non-decreasing naturals that'd be easy...
10:56:44 <Eridius> so you can write extensions as scripts, and there's libraries to help in Perl and Ruby
10:56:52 <Philippa_> reals is tricky because we have no positive real type and no good way to write one
10:56:59 <lilac> Eridius: and python?
10:57:02 <Philippa_> (how do you do non-decreasing sequence? Store the deltas)
10:57:16 <Eridius> hell, GitHub uses a Ruby library that IIRC one of them wrote that lets them interface with a git repo directly (i.e. implementing the git repo file format in ruby instead of going through the git commands)
10:57:25 <Eridius> lilac: no idea if there's a python library for doing Git-related stuff
10:57:29 <lament> I have zero knowledge about DVCS, but I would choose git because it seems by far the most likely one to survive for a while and have lots of useful tools written for it
10:57:59 <Eridius> lament: if nothing else, git is the most popular right now so by picking it you'd have the greatest likelihood of being able to interact with other people/tools
10:58:01 <Philippa_> eu-prleu-peupeu: does my line of thinking make sense there? You'd have to decide how to interface it with ordinary ints or nats yourself, too
10:58:02 <bremner> Eridius, lilac, yes there is such a python library
10:58:08 <lament> Eridius: sure
10:58:24 * Eridius has been thinking about writing a Haskell library for interfacing with a Git repo, but doesn't think he knows enough to design a proper idiomatic Haskell API
10:58:44 <ppavel> seems like every one put up on darcs?
10:59:16 <lilac> to be honest, i'm of the opinion that no VCS actually gets version control for software anywhere remotely near "right".
10:59:20 <eu-prleu-peupeu> Philippa_: the examples i've seen of this all use integers, but mathematically its a list of non-decreasing real values
10:59:34 <vixey> use [Real]
10:59:35 <eu-prleu-peupeu> storing the deltas would be a bit intrusive for the programmer i guess :/
10:59:44 <lilac> if i can't move a function from earlier in a file to later in the same file (or to a different file) and have the VCS know that these are the same lines, then it's failed IMO
10:59:49 <vixey> the fact that they are monotonic needn't be stored in types
11:00:00 <Eridius> lilac: in theory git can know that. I don't know if there's anything useful it can do with that info
11:00:11 <Philippa_> eu-prleu-peupeu: well, depends what the interface is like
11:00:22 <Eridius> git doesn't store diffs - it stores the exact text at any given revision, so as git becomes smarter your existing repos can benefit from the improved code analysis
11:00:22 <lilac> Eridius: well, patches applied to those lines should be applied to wherever they've gone in case of a conflict
11:00:24 <eu-prleu-peupeu> hmm
11:00:28 <Philippa_> in general, interface != implementation :-)
11:00:30 <lament> lilac: i agree, all sourcecode-related tools need to be language-specific
11:00:45 <eu-prleu-peupeu> ill just use [Double] and write a validation function
11:00:46 <lament> mainly the editor but also the VCS
11:00:47 <Eridius> lilac: git's repo model is I think the best suited for being able to do that, though I don't know what work on that area has actually been done
11:00:56 <Philippa_> but either way, you're left with the interface running border patrol for you, because you can't type it in a way that forces the type system to do it for you
11:01:00 <bremner> lament: gah, I am quite happy with emacs and git tyvm
11:01:01 <jmcarthur> i think version control should eventually become nothing more than a refactoring tool
11:01:19 <jmcarthur> where each refactoring is a darcs-style patch
11:01:31 * bremner is very much against closed software ecosystems
11:01:33 <pumpkin> someone should write a semantically aware VCS for specific languages :P
11:01:44 <lament> bremner: i didn't say anything about closed.
11:01:44 <pumpkin> not sure how it would work, but I'm sure it would be awesome
11:01:47 <jmcarthur> the hard part is the sheer number of languages
11:01:52 <jmcarthur> plugins could fix that
11:01:57 <lament> pumpkin: by-line diff is already semantically aware in a very dumb way
11:02:10 <bremner> lament: language specific==closed
11:02:10 <pumpkin> yeah, I meant using more meaningful units
11:02:11 <pumpkin> for the language
11:02:26 <lament> should be easyish for lisp/scheme
11:02:31 <lilac> lament: i wouldn't say language-specific. but i would say language-aware
11:02:33 <pumpkin> even haskell
11:02:39 <lament> lilac: one leads to the other
11:03:00 <Eridius> it seems like the ability to translate semantic changes to a program across patches really requires some way to model these changes that's indifferent to the actual textual representation
11:03:01 <lilac> lament: an editor with extensible syntax highlighting is language-aware but not language-specific
11:03:17 <Eridius> which would mean that translating said changes wouldn't in any way be defined to actually preserve the text of the changes, just the semantic meaning
11:03:18 <lament> lilac: it has language-specific bits in it
11:03:21 <Saizan> semantic or syntactic?
11:03:30 <vixey> both!
11:03:31 <jmcarthur> i think we should just finally break out of text source files
11:03:39 <Saizan> i.e. should it know that \x -> x == id?
11:03:39 <jmcarthur> why should a language even have a syntax?
11:03:42 <lament> jmcarthur: and switch to mp3!
11:03:43 <Philippa_> lament: usually by way of a metalang + extensible lang-specific stuff though
11:03:47 <vixey> jmcarthur: waht ??
11:03:47 <lilac> lament: i think we're disagreeing on what 'language-specific' means here :)
11:03:49 <Philippa_> the question's how general that metalang is
11:03:58 <jmcarthur> vixey, a text syntax, i mean
11:04:12 <Philippa_> usually it's somewhat specific to some class of languages (or of highlightable constructs)
11:04:15 <vixey> jmcarthur: did you have some alternative(s) in mind?
11:04:22 <lament> Philippa_: i could argue that the more specific, the more useful it is
11:04:27 <Philippa_> usually definable in terms of regexes :-)
11:04:34 <jmcarthur> i mean, it's okay to have a textual representation, but the existence of a parser should not be necessary to use a language's semantics
11:04:38 <Philippa_> lament: yeah. I know what I /really/ want out of a Haskell editor, for example
11:04:38 <lament> Philippa_: and so any class of languages > 1 is less useful than an actually language-specific tool
11:04:43 <lilac> things get easier if you scrap the textual representation of programs (or consider it secondary, as merely an irrelevant denotation)
11:04:44 <Saizan> working with the abstract syntax is still far from dealing with semantics
11:04:51 <Philippa_> lament: that depends how many langs you want to work with
11:05:13 <Philippa_> to put it another way: given that you have finite resources to obtain usable editors with...
11:05:21 <lament> blessed are the languages popular enough to actually have extensive tools written _for_ them
11:05:23 <vixey> syntax is more than just text btw
11:05:33 <lament> sadly the languages themselves tend to be crappy, but the tools sure are great
11:05:38 <Philippa_> vixey: no duh, really?
11:05:41 <vixey> I mean syntax isn't just whether loops are called 'while' or 'do'
11:05:50 <jmcarthur> vixey, i know, that's why i qualified it as "textual" when you said "huh?"
11:06:13 <Philippa_> vixey: that's barely even syntax, that's a lexical issue
11:06:19 <vixey> yes
11:06:38 <vixey> text vs non-text seems a lexical issue too
11:06:39 <Philippa_> and my text editor /is/ capable, given a bit of work, of distinguishing eg expressions from statements in a number of languages
11:07:10 <Baughn> Why is Traversable in Data, while Applicative is in Control? Is there some significance?
11:07:21 <lament> Philippa_: doesn't help in haskell much, does it :)
11:07:24 <Philippa_> text vs non-text isn't quite lexical, it's something mildly deeper
11:07:32 <vixey> hm why?
11:07:36 <Philippa_> lament: well no, but that's significantly because the layout rule is complex
11:07:47 <jmcarthur> haskell programs are graphs. why do we have to feed the compiler text?
11:07:55 <vixey> graphs ??
11:08:08 <vixey> I can not understand half of what is being talked about here
11:08:10 <lament> I certainly think of a haskell program as a bunch of text.
11:08:10 <Philippa_> vixey: it's a change of 'carrier'. You need a deeper equivalence to relate a string and its corresponding CST
11:08:12 <Baughn> jmcarthur: If you can figure out a better representation...
11:08:29 <Philippa_> vixey: yes, haskell programs are graphs. Recursive let gives you that
11:08:56 <Philippa_> the *syntax* is a tree because drawing the graphs is a PITA, but Haskell evaluation is graph reduction
11:08:58 <Eridius> hrm, using --diff-command with `darcs diff` seems to make it do nothing at all (i.e. it just calls the diff command without any args)
11:09:09 <jmcarthur> Baughn, that's the hurdle, of course. there is still the matter of justification though, which is all i'm after right now
11:09:43 <vixey> Has anyone tried drawing some prograams as graphs?
11:10:01 <vixey> Have you looked at linear logic proof nets?
11:10:09 <Philippa_> vixey: some people have, yes
11:10:13 <vixey> is that like it?
11:10:27 <Philippa_> usually not masses, but you get snippets of graph sometimes when talking about evaluation mechanisms for lambda calculus
11:10:35 <vixey> I saw Cales fold pictures but I think they are presentations, more than actual *code*
11:10:38 <Philippa_> similar concept I suspect, yes
11:10:53 <lament> See the failing Haskell logo
11:11:12 <lament> http://haskell.org/logos/logos/Graphicc.gif
11:11:14 <Philippa_> it's actually really simple: replace variables with arcs to the corresponding term
11:11:32 <sinelaw> how far from haskell are Scheme & ML?
11:11:33 <Philippa_> suddenly, variables correspond directly to opportunities for sharing
11:11:42 <sinelaw> (in taxicab driver distance)
11:11:59 <vixey> Philippa_: I saw some visualizations of arcade games like -- pretty but it's totally unread/writeable
11:12:00 <lament> sinelaw: about half an hour of brisk walking
11:12:01 <Philippa_> sinelaw: far enough that all three deserve to co-exist until someone subsumes them
11:12:04 <jmcarthur> sinelaw, very far from scheme, walking fistance from ML?
11:12:09 <jmcarthur> *distance
11:12:23 <Philippa_> vixey: sure. It doesn't mean that programs don't have that structure though
11:12:41 <lament> vixey: there have been many attempts to design graphical programming languages
11:12:48 <lament> very many, over decades
11:12:53 <jmcarthur> vixey, i don't mean we should be looking at the raw graph representation, just that our tools should be
11:12:56 <vixey> lament: I've seen this one guys webpage with lots of ideas
11:12:58 <lament> they're all quite laughable, which suggests that this is a really hard problem
11:13:02 <jmcarthur> but right now our tool are looking at text
11:13:04 <vixey> but they all seem like bending over backwards compared to text
11:13:08 <lament> yes
11:13:23 <vixey> I don't think I'm being closed minded about it, but necessarily I couldn't know
11:13:24 <lament> if it's possible to design a good graphical language, then it must be really hard
11:13:33 <sinelaw> vixey, what's the page? or a hint for googling it
11:13:37 <lament> aardappel's page?
11:13:46 <Philippa_> jmcarthur: very few of our tools really want to be looking at graphs rather than trees as primary rep
11:13:49 <vixey> yeah aardappel is the one that comes to mind
11:13:54 <lament> sinelaw: http://strlen.com/aardappel/index.html
11:14:24 <lament> i mean, http://strlen.com/proglang/index.html
11:14:27 <sinelaw> i think it the representation should be text-ish, with graphical cues
11:14:28 <jmcarthur> we don't necessarily need so-called "visual programming," but things like syntax errors simply shouldn't exist because our tools should not provide a way to create them
11:14:40 <sinelaw> exactly. :)
11:14:56 <sinelaw> the code should be structured correctly at all times
11:15:01 <jmcarthur> and type errors similarly
11:15:12 <Cale> mm...
11:15:13 <monochrom> @quote plain text file
11:15:13 <lambdabot> No quotes for this person.
11:15:16 <bremner> and the halting problem
11:15:17 <vixey> jmcarthur: I guess Epigram style interaction could erase syntax errors
11:15:18 <monochrom> @quote plain
11:15:18 <lambdabot> Jerub says: shapr: we have a new manager. she complained of a bad heart when I told her we didn't have revision control.
11:15:21 <lament> jmcarthur: so you shouldn't be able to type in a function half-way and then go have a berak?
11:15:23 <bremner> and a pony
11:15:24 <lament> *break
11:15:36 <monochrom> Will programming be liberated from the plain text file?
11:15:37 <vixey> bremner: halting problem is solved :p
11:15:39 <sinelaw> jmcarthur, have you spoken to Peaker abuot that?
11:15:49 <Philippa_> jmcarthur: tbh, I want room to make errors
11:15:58 <vixey> bremner: we pretty much know what's to know about it now
11:16:02 <bremner> vixey: by lazy evaluation?
11:16:05 <vixey> no
11:16:06 <Philippa_> why? Because I want to be able to screw around and toy with stuff when I need to
11:16:07 <vixey> by mathematics
11:16:29 <Cale> Yeah, while it seems somewhat sensible on paper that there should be no way to create a syntax error, in practical use, all the implementations of that which I've ever tried have been somewhat awkward to actually use compared to just plain text.
11:16:29 <bremner> vixey: the halting problem _is_ mathematics
11:16:47 <Philippa_> bremner: the 'solution' to the halting problem is to /add extra info if you care/ and use that to resolve it
11:17:06 <Philippa_> CIC+universes has a fairly strong claim to being all you need as a base for that
11:18:45 <Philippa_> IOW, if functions aren't analysable enough, work with more than just functions and have done with it
11:18:58 <Cale> Though, I do have a soft spot in my heart for the view of functional programs as digraphs, and evaluation as graph rewriting.
11:19:01 <monochrom> You can type in a function halfway and take a break. The editor uses placeholders to signify the rest and also knows what syntactic category the placeholders belong to. A file with no placeholder is automatically syntactically correct.
11:19:03 <Philippa_> (this is the workaround for Rice's theorem as a whole)
11:20:36 <Frederick[SE]> i started today with Haskell for an assignment, and some of the errors are just plain confusing. Anybody care to help a bit?
11:21:00 <monochrom> paste everything on a paste bin. perhaps hpaste.org
11:21:01 <Frederick[SE]> well, i got a different interpreter/compiler now... went from Hugs to Helium and thats already some improvement
11:21:12 <Frederick[SE]> ok monochrom, will try :)
11:21:16 * ksf recommends ghc
11:21:18 <Philippa_> Cale: I quite like Epigram's 'sheds' idea, I might adopt that for an IDE for a haskell-like lang
11:21:25 <Philippa_> (if I were writing one!)
11:21:30 <vixey> hehe
11:21:39 <vixey> I want something like TeX & HTML
11:21:54 <vixey> if that was programmable it could be nice
11:22:04 <Philippa_> tbh, I'd be inclined to define two top-level syntaxes
11:22:22 <Cale> The thing about Epigram is it really deserves to have an editor which makes it look exactly like it does in papers.
11:22:23 <Philippa_> one where another lang's the top-level and our lang's embedded in it, another for our lang at top-level
11:22:34 <Cale> (ascii art is so ugly for that)
11:22:37 <Philippa_> I mean, that's sorta what .hs vs .lhs is about anyway
11:22:49 <Philippa_> Literate Haskell just defines a couple of embeddings
11:23:07 <Philippa_> but an IDE'd need to be able to work from both points of view
11:23:38 <Philippa_> (hrmm, perhaps I should teach jedit about that so you can have LaTeX highlighting at top-level for LaTeX .lhs)
11:23:56 <lament> Cale: that's the thing about Haskell, too
11:24:18 <Frederick[SE]> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=2862#a2862 << Anyone who's willing to look into this?
11:24:57 <Cale> lament: Well, Haskell looks reasonably good in ascii.
11:25:04 <Cale> lament: Compared to Epigram.
11:26:06 <centrinia> Frederick[SE], in line 4, readFile :: FilePath -> IO String
11:26:23 <centrinia> Your fn_roads does not return an IO monad.
11:26:37 <lament> Cale: true.
11:26:59 <Frederick[SE]> nope, it should return an array of tuples (Int, String, String)
11:27:15 <Frederick[SE]> so im confused why it says it expects that to be returned
11:27:40 <centrinia> It should return an IO monad.
11:28:03 <Cale> an IO action
11:28:03 <monochrom> Frederick[SE]: «lines» is a builtin function, not a list of strings. And what centrinia says. «readFile 'toll.in"» will not be a string.
11:28:12 <Cale> Monads are not values!
11:28:21 <Frederick[SE]> it wont be a list of strings either?
11:28:27 <monochrom> No.
11:28:34 <Philippa_> Cale: unless you encode first-class modules, anyway :-)
11:28:36 <centrinia> Cale, sorry. :(
11:28:40 <Frederick[SE]> ok, got a good API overview somewhere on the web?
11:29:04 <Frederick[SE]> i thought lines was a built-in function returning an array/list of strings
11:29:19 <lilac> Frederick[SE]: the first problem is in fn_roads
11:29:28 <paper_cc> @ty lines
11:29:29 <lambdabot> String -> [String]
11:29:37 <lilac> fn_roads = fn_roads2 1 lines readFile "toll.in"
11:29:46 <monochrom> lines takes a parameter before it returns anything. You are not giving it any parameter.
11:29:51 <lilac> ^^ this calls fn_roads2 and passes it 4 arguments, 1, lines, readFile and "toll.in"
11:30:03 <lilac> Frederick[SE]: you probably meant something closer to:
11:30:10 <Frederick[SE]> hrmm... shouldnt lines take as parameter the result of readFile "toll.in"?
11:30:12 <Frederick[SE]> i suppose not
11:30:17 <centrinia> fn_roads = do { contents <- reaedFile "toll.in"; return (fn_roads2 1 (lines contents)); }
11:30:17 <lilac> fn_roads = do stuff <- readFile "toll.in"
11:30:25 <lilac>                  fn_roads2 1 (lines stuff)
11:30:26 <roconnor> @seen RayNbow -- I might need to leave for a bit in a few minutes
11:30:27 <lambdabot> RayNbow is in #haskell. I last heard RayNbow speak 2h 14m 11s ago.
11:30:34 <bremner> Somebody tell Frederick[SE] about interact
11:30:56 <Frederick[SE]> sorry guys, i havent ever programmed in a functional way :)
11:30:59 <centrinia> Frederick[SE], the result of readFile "toll.in" is not a String.
11:31:06 <RayNbow> @seen roconnor
11:31:07 <lambdabot> roconnor is in #haskell. I last heard roconnor speak 40s ago.
11:31:20 <lilac> Frederick[SE]: so, here are some things you need to know:
11:31:21 <roconnor> @seen RayNbow
11:31:22 <lambdabot> RayNbow is in #haskell. I last heard RayNbow speak 15s ago.
11:31:24 <Frederick[SE]> @ty readFile
11:31:25 <lambdabot> FilePath -> IO String
11:31:29 <RayNbow> :p
11:31:32 <andun> do you guys have any ideas on a representation for neural networks in haskell?
11:31:44 <roconnor> RayNbow: I'm here
11:32:01 <lilac> Frederick[SE]: "f a b c" /always/ means "call the function f with arguments a, b and c" (this is a simplification, but it'll do)
11:32:06 <monochrom> OK cool, you two find each other finally.
11:32:13 <roconnor> RayNbow: did I want to talk to you or did you want to talk to me?
11:32:27 <RayNbow> I sent a question via lambdabot a while ago
11:32:33 <Frederick[SE]> yeah lilac, thats what i understood from reading my book
11:32:34 <roconnor> ya
11:32:38 <RayNbow> Do you have any (in-depth) articles/resources on corecursion? :)
11:32:47 <roconnor> I said I only knew a chapter in TTFP
11:32:59 <roconnor> not sure if you got that though
11:33:02 <lilac> Frederick[SE]: so if you want to apply "lines" to x, and pass that to fn_roads2, you need to say "fn_roads2 (lines x)" or similar (note the parentheses)
11:33:03 <RayNbow> hmm, didn't see that
11:33:07 <vixey> @go linear temporal logic
11:33:08 <lambdabot> http://en.wikipedia.org/wiki/Linear_temporal_logic
11:33:08 <lambdabot> Title: Linear temporal logic - Wikipedia, the free encyclopedia
11:33:11 <roconnor> @where TTFP
11:33:11 <lambdabot> I know nothing about ttfp.
11:33:15 <monochrom> . o O ( corecursion is not deep... )
11:33:23 <roconnor> damn it lambdabot, I just told you 2 days ago
11:33:40 <monochrom> Yes I remember that one! Haa....
11:33:41 <RayNbow> lemme check to be sure :p
11:33:49 <Frederick[SE]> ok, so i need to the parenthesis to make it apply lines to x before passing it to fn_roads2?
11:33:50 <monochrom> (And I was saying "how would I ever rembmer...")
11:33:55 <RayNbow> nope, didn't receive any messages
11:33:57 <lilac> Frederick[SE]: if we assume that readFile :: String -> String (it's not, we'll come to that), then you can rewrite fn_roads as...
11:34:01 <Frederick[SE]> otherwise it will try to pass lines as an argument of fn_roads2
11:34:04 <lilac> Frederick[SE]: (yes, that's right)
11:34:11 <Frederick[SE]> ok
11:34:19 <monochrom> http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/
11:34:26 <lilac> Frederick[SE]: fn_roads = fn_roads2 1 (lines (readFile "toll.in"))
11:34:28 <monochrom> (My firefox remembers. :) )
11:34:28 <RayNbow> btw roconnor, no longer in NL?
11:34:31 <roconnor> RayNbow: ya I didn't send you a message
11:34:41 <roconnor> RayNbow: I live in Canada now
11:34:42 <lilac> Frederick[SE]: however, readFile's type is not String -> String, it's String -> IO String
11:34:51 <roconnor> @where+ TTFP http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/
11:34:51 <lambdabot> It is stored.
11:35:08 <zeno> anyone have a link to simon marlows go code? i just wrote my first program and getting 5 :( playouts per second (9x9 board).  he was getting 20,000 (omg how!)
11:35:08 <cadr> Can I import a type class from a module without importing instances of that type class defined in that module?
11:35:13 <Frederick[SE]> yeah lilac, thats exactly what i was thinking now
11:35:16 <lilac> Frederick[SE]: "IO String" is a different type, and it's the type of computations with side-effects which ultimately produce a String
11:35:24 <Frederick[SE]> and i can use getContents and pass it an IO String?
11:35:46 <SubStack> pass it?
11:35:47 <lilac> no, getContents is of type "IO String", so it's a computation which produces a String
11:35:48 <mauke> getContents is not a function
11:36:02 <mauke> cadr: I don't think so
11:36:06 <lilac> Frederick[SE]: you can't 'execute' a computation in Haskell
11:36:06 <monochrom> I wonder if you absolutely unavoidably nonnegotiably must read from a file.
11:36:09 <ksf> :t >>=
11:36:10 <lambdabot> parse error on input `>>='
11:36:14 <ksf> :t (>>=)
11:36:14 <RayNbow> hmm, 378 pages... I wonder if the printer at my university can staple that... :p
11:36:15 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
11:36:16 <mauke> cadr: instances sort of seep through everything
11:36:18 <lilac> Frederick[SE]: all you can do is glue computations together to produce bigger ones
11:36:27 <ksf> Frederick[SE], you're going to need that, in some way or the other.
11:36:32 <lilac> Frederick[SE]: ultimately, you glue them together to produce a computation which /is/ your program
11:36:34 <SubStack> you can't grep paper
11:36:34 <RayNbow> but thanks for the link, roconnor :)
11:36:38 <RayNbow> @karma roconnor
11:36:38 <lambdabot> roconnor has a karma of 5
11:36:41 <RayNbow> roconnor++
11:36:42 <roconnor> RayNbow: it's a good book, but there is only a few pages on correcursive types
11:36:51 <cadr> mauke: Well, I now feel less silly for not being able to figure out how to do it :)  Thanks!
11:37:03 <Frederick[SE]> lilac: I think i understand what you mean
11:37:08 <lilac> Frederick[SE]: you can glue computations together by using 'do-notation'
11:37:09 <ksf> as in readFile "foo" >>= (\str -> putStrLn (doStuffTo str)
11:37:22 <eden> Hi, as a learning exercise, I've been implementing a few different maps. Has a generic map class had been created that implements most of the Data.Map operations in terms of a few of the most general versions?
11:37:44 <lilac> Frederick[SE]: 'do-notation' is a shorthand for expressions involving the >>= and >> operators, which are the 'glue'
11:37:54 <zugsi> hi @ everybody, small question: does anybody know why data-accessor-template fails to derive the accessors on type constructors with type arguments?
11:38:22 <lilac> Frederick[SE]: so you have readFile "toll.in" which is an IO String
11:38:47 <ksf> or, in the terms of the >>= type above, m a where m = IO and a = String
11:38:49 <b_jonas> ksf: I don't think that's a really good example :-(
11:39:06 <eden> Uh, that most general functions like insertLookupWithKey
11:39:13 <lilac> Frederick[SE]: you can "get the String out of it" by using do-notation
11:39:39 <lilac> Frederick[SE]: but since you can't actually execute anything, the result of the do-notation must also be a computation (that is, it must be IO <something>)
11:39:40 <ksf> b_jonas, it's equivalent to do {str <- readFile foo; putStrLn (doStuffTo str)}, which I see all over the place everywhere.
11:40:00 <lilac> Frederick[SE]: you can do that like this:
11:40:06 <lilac> do readFile "toll.in"
11:40:08 <Frederick[SE]> i guess it is more difficult than i thought
11:40:11 <b_jonas> ksf: it is valid code, but I think it's not a good example for what you're trying to explain
11:40:20 <lilac> ... erk
11:40:30 <lilac> do contents <- readFile "toll.in"
11:40:39 <lilac>    return (fn_roads2 1 (lines contents))
11:40:40 <b_jonas> becuase readFile is an unsafe operation
11:40:54 <lament> the things you're explaining to Frederick[SE], shouldn't he already know all that from the lectures?
11:40:59 <ppavelV6> hi
11:41:13 <zugsi> data Foo a = Foo { unFoo_ :: a }
11:41:13 <Frederick[SE]> no lament, ive only had one small introduction to Haskell, one lecture
11:41:13 <zugsi> $( deriveAccessors ''Foo )
11:41:25 <lament> Frederick[SE]: they must have covered IO there if they gave you the assignment
11:41:29 <zugsi> fails with
11:41:30 <zugsi>  Not in scope: type variable `a[a3I7]'
11:41:30 <Frederick[SE]> nothing else, just the basics, its only a small part of my course on Advanced Programming Concepts
11:41:39 <monochrom> I don't believe you have to read from a file.
11:41:45 <centrinia> fn_roads = fn_roads2 1 (lines (unsafePerformIO (readFile "toll.in")))
11:42:07 <ksf> well, lectures need either to start with monads, right away, or do stuff using interact and leave the rest as magic, for the time being.
11:42:09 <monochrom> @stop centrinia
11:42:09 <lambdabot> Maybe you meant: show slap
11:42:11 <lilac> centrinia-is-evil++
11:42:16 <monochrom> oh bother
11:42:21 <monochrom> @stab centrinia
11:42:21 * lambdabot pokes centrinia in the eye
11:42:21 <vixey> Advanced Programming Concepts such as recursion
11:42:27 <Frederick[SE]> thanks lilac, i will try to use the do-notation
11:42:28 <centrinia> Ouch. :(
11:42:31 <monochrom> hehe
11:42:49 <lilac> Frederick[SE]: ok, so the first line of that do-notation gives a name to the String in the IO String
11:42:52 <monochrom> Haha vixey
11:43:01 <vixey> Day 1: Monads  Day 2: The Type System
11:43:17 <vixey> I can't imagine that working
11:43:26 <lilac> Frederick[SE]: the second line uses 'return'. 'return' takes a normal value and turns it into a computation which does nothing and produces that value.
11:43:50 <ksf> Frederick[SE], also try "main = interact (map toUpper)", it could be sufficient for your problem and can shelter you from monads.
11:43:51 <Frederick[SE]> ok, didnt know return would do something like that, but that sounds really helpful
11:44:07 <lilac> Frederick[SE]: remember I said the result of do-notation has to be IO <something>? that's why we use 'return'
11:44:13 <profmakx> hm
11:44:16 <monochrom> No no no no no. Day 1: Recursion  Day 2: Linked Lists  Day 3: Binary Trees
11:44:34 <ksf> Day 4: Actually compile and use a program
11:44:42 <b_jonas> why start with recursion?
11:44:47 <ksf> recursion is evil.
11:44:48 <lilac> Frederick[SE]: so the result of this 'do' block will be a computation whihc reads the file "toll.in", splits it into lines, runs fn_roads2 1 on the lines, and then returns the result of that
11:44:52 <monochrom> Advanced class.
11:44:53 <NameAlreadyInUse> recursion makes sense
11:44:54 <mauke> I think you'd want to introduce recursion together with recursive data
11:44:55 <b_jonas> recursion can be closed to a few library functions
11:44:58 <profmakx> because to understand recursion you first have to understand recursion!
11:45:05 <lilac> Frederick[SE]: fn_roads :: IO [(Int, String, String)]
11:45:06 <Botje> when do the students get time for finding out which brain chunks are theirs and gluing together their skull fragments? :)
11:45:08 <ksf> start with map and folds
11:45:09 <b_jonas> profmakx: true
11:45:22 <Frederick[SE]> what does the IO <something> do, the IO part? What does it mean?
11:45:35 <Botje> Frederick[SE]: "this is a computation that does IO"
11:45:39 <centrinia> Week 1: Category Theory; Day 6: Type Systems; Day 7: Recursion; Day 8: Writing a Hello World! application.
11:45:40 <mauke> IO is a parameterized type
11:45:47 <lilac> Frederick[SE]: you know how functions act on values, so that "f x" is some function applied to x?
11:45:53 <Frederick[SE]> yeah
11:46:03 <ksf> Frederick[SE], it's like [Int], which is special syntax for List Int.
11:46:10 <monochrom> Day 9: Proving 0=0 in the type system
11:46:13 <b_jonas> .oO( understanding the state monad helps )
11:46:14 <lilac> Frederick[SE]: well IO is a function which acts on types, so "IO x" is some type distinct from x
11:46:14 <ksf> ...or any other higher-order type.
11:47:04 <lilac> Frederick[SE]: (note that 'distinct from x' isnt' actually a requirement in general for a type function in the same way it's not a requirement for a value-level function)
11:47:12 <monochrom> Day 9+n: Proving n=n in the type system
11:47:23 * ksf thinks the best way to understand monads is to read the typeclassopedia, but that might be a bit difficult for a newbie.
11:47:41 <profmakx> best way to understand stuff is use stuff
11:47:46 <lilac> Frederick[SE]: the "IO" type function (in haskell, it's called a type constructor) maps from the type x to the type of computations which produce an x
11:47:53 <bremner> did I mention beginners should use interact and forget the rest of the IO stuff?
11:47:55 <monochrom> I agree with profmakx
11:48:10 <Frederick[SE]> ksf: i think ive learned more in this 5 min chat than from the whole lecture i had last week
11:48:17 <ksf> as in "the only really special thing about monads is bind/join, the rest is just a vanilla functor"
11:48:20 <b_jonas> ksf: actually byorgey said in a blog post before that that you shouldn't say "the best way to understand monads is" some simple thing or another
11:48:27 <conal> @seen sclv
11:48:27 <lambdabot> Last time I saw sclv was when I left ##freebsd, ##hrg, ##logic, #arch-haskell, #concatenative, #darcs, #dreamlinux-es, #friendly-coders, #funtoo, #gentoo-haskell, #gentoo-uy, #ghc, #haskell, #
11:48:27 <lambdabot> haskell-blah, #haskell-books, #haskell-overflow, #haskell-soc, #haskell.cz, #haskell.de, #haskell.dut, #haskell.es, #haskell.fi, #haskell.fr, #haskell.hr, #haskell.it, #haskell.jp, #haskell.no, #
11:48:27 <lambdabot> haskell.ru, #haskell.se, #haskell_ru, #jhc, #jtiger, #macosxdev, #perl6, #rosettacode, #scala, #scannedinavian, #unicycling and #xmonad 3m 25d 20h 28m 57s ago, and .
11:48:28 <profmakx> and actually it does not matter if its ugly at first
11:48:43 <mauke> preflex: seen sclv
11:48:43 <preflex>  Sorry, I haven't seen sclv
11:48:46 <mauke> :-(
11:48:54 <lilac> b_jonas: "the best way to understand monads is" to read lots of explanations until the gestalt of them makes something click
11:48:55 <monochrom> Frederick[SE]: There is a law about "the best tutorial is the 3rd tutorial you read"
11:49:31 <lament> the best way to understand monads is to think of them like spacesuits full of orange juice.
11:49:31 <eu-prleu-peupeu> are there any functions to search elements in lists ?
11:49:31 <ksf> b_jonas, yes, and he deliberately avoided comparing monads to anything else but functors in the typeclassopedia :)
11:49:31 <monochrom> @quote postmodernism
11:49:33 <lambdabot> monochrom says: Monad is about postmodernism. There are laws but no one owns them. You can interpret them any way you want. You can write about your own understanding and the meaning of your writing
11:49:33 <lambdabot> is not fixed.
11:49:36 <eu-prleu-peupeu> like binary search and stuff like that ?
11:49:41 <Frederick[SE]> what Haskell compiler/interpreter are you all using?
11:49:50 <lilac> lament: monads are space burritos full of orange juice
11:50:09 <mauke> eu-prleu-peupeu: binary search on linked lists? wtf?
11:50:13 <Frederick[SE]> i was using Hugs, but now i switched to Helium as according to some forum posts it gives better debug information
11:50:14 <NameAlreadyInUse> lilac: on a conveyor belt
11:50:15 <ksf> eu-prleu-peupeu, try elemIndexAt for basics.
11:50:19 <lament> Frederick[SE]: GHC
11:50:21 <vixey> binary search on binary trees only
11:50:30 <mauke> Frederick[SE]: helium isn't "real haskell"
11:50:40 <lament> Frederick[SE]: Helium is not haskell at all, your code will not work.
11:50:47 <ksf> eu-prleu-peupeu, then there's a boyers-moore-prat or whatever it was called search algo on hackage, that's the fastest you can get with general-purpose string search.
11:51:01 <Frederick[SE]> ok, best would be to just use GHC?
11:51:03 <ksf> prolly called "string-serach" or something
11:51:05 <lament> yes.
11:51:19 <mauke> it's what all the cool kids use :-)
11:51:21 <mauke> except for ndm
11:51:23 <eu-prleu-peupeu> hmm its a list of doubles, ill implement my binary search function then :/
11:51:39 <mauke> eu-prleu-peupeu: why do you want to make your code slow?
11:51:39 <Frederick[SE]> i guess ill reinstall GHC then, i actually removed it 5 mins before joining :P
11:51:44 <zeno> OH GOD its ugly! but so fast! http://www.haskell.org/~simonmar/goboard.tar.gz
11:51:52 <eu-prleu-peupeu> hehe
11:52:00 <eu-prleu-peupeu> ok, ill just iterate through each element :P
11:52:19 <mauke> but only once, I hope
11:52:24 <lament> zeno: what is it?
11:52:25 <eu-prleu-peupeu> me too
11:52:27 <mauke> binary search would take O(n^2)
11:53:26 <monochrom> binary search on a linked list. jet engine on the moon.
11:53:59 <eu-prleu-peupeu> oh okye, these are linked lists
11:54:09 <lament> and this is the moon :)
11:54:13 <ksf> eu-prleu-peupeu, are you matching with one or more doubles?
11:54:19 <mauke> that's not a moon
11:54:22 <monochrom> "there is no air friction on the moon, so the 747 should fly much faster!"
11:54:22 <zeno> lament: go game ai
11:54:37 <zeno> its 2000 times faster than mine
11:54:37 <ksf> eu-prleu-peupeu, i.e. is it matching [Double] against Double or [Double]?
11:54:49 <centrinia> "There is no royal road to Haskell." -- Euclid
11:54:53 <gwern> monochrom: in space, no one can hear your sonic boom
11:54:54 <monochrom> haha
11:55:00 <eu-prleu-peupeu> its Double against [Double]
11:55:12 <lament> zeno: how strong? how strong is yours?
11:55:18 <monochrom> @remember centrinia "There is no royal road to Haskell." -- Euclid
11:55:18 <lambdabot> I will remember.
11:55:22 <ksf> :t elemIndex
11:55:23 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe Int
11:55:29 <Frederick[SE]> lilac: Algorithm.hs:4:14: The last statement in a 'do' construct must be an expression
11:55:35 <ksf> that should do it.
11:55:36 <Frederick[SE]> in the do you gave me
11:55:41 <eu-prleu-peupeu> i need to find the values where Double is inbetween
11:55:49 <eden> Oh well, I guess not. I'll do it myself as another learning exercise...
11:55:51 <eu-prleu-peupeu> thats why i thought about binary search :P
11:55:52 <centrinia> monochrom, that shouldn't have been attributed to me. I got it from The Typeclassopedia.
11:55:59 <monochrom> Oh oops
11:56:02 <ksf> :t findWith
11:56:03 <lambdabot> Not in scope: `findWith'
11:56:09 <monochrom> @forget centrinia "There is no royal road to Haskell." -- Euclid
11:56:09 <lambdabot> Done.
11:56:10 <ksf> ...there was something like that.
11:56:16 <monochrom> @quote centrinia
11:56:16 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
11:56:24 <centrinia> Hmm.
11:56:25 <monochrom> Eww!
11:56:42 <ksf> :t findIndex
11:56:43 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe Int
11:56:45 <monochrom> @quote Euclid
11:56:45 <lambdabot> Igloo says: * shapr is desperately trying to grow a beard at this point... // <Igloo> You normally grow beards over partial non-Euclidean planes, not at points
11:56:48 <ksf> :t findIndices
11:56:49 <lambdabot> forall a. (a -> Bool) -> [a] -> [Int]
11:57:08 <zeno> lament: mine makes captures and runs stones in atari right now so 28k lol.  his does 30k random playouts on a 9x9 on my computer (monte carlo)
11:57:11 <eu-prleu-peupeu> ah nice :)
11:57:18 <NameAlreadyInUse> <Frederick[SE]>: what is the do?
11:57:20 <centrinia> @remember byorgey "There is no royal road to Haskell." -- Euclid
11:57:20 <lambdabot> It is forever etched in my memory.
11:57:36 <lament> zeno: er... impressive :)
11:57:50 <Frederick[SE]> fn_roads :: [ ( Int , String , String ) ]
11:57:50 <Frederick[SE]> fn_roads = do { contents <- readFile "toll.in" } return (fn_roads2 1 (lines contents))
11:57:50 <monochrom> @quote royal
11:57:51 <lambdabot> byorgey says: "There is no royal road to Haskell." -- Euclid
11:57:55 <monochrom> OK cool.
11:57:56 <Frederick[SE]> thats the do
11:58:07 <ksf> eu-prleu-peupeu, you can, of course, use a binary tree, but you'd need thousands of doubles to notice a real difference in lookup.
11:58:10 <Frederick[SE]> ive inlined it a bit so it wont spam the channel
11:58:17 <zeno> lament: 30k/second sorry
11:58:33 <eu-prleu-peupeu> yes, its not worth it, a list will work just fine :) thanks ksf
11:59:01 <lament> zeno: ah. I'm 9d/100 years
11:59:16 <ksf> ...you could also match against the head of all tails or something, if you don't want to go via indices.
11:59:39 <NameAlreadyInUse> <Frederick[SE]>: i am not sure about this, but are you sure it is not "fn_roads :: IO [ ( Int , String , String ) ]; fn_roads = do { contents <- readFile "toll.in"; return (fn_roads2 1 (lines contents)) }"?
11:59:40 <jmcarthur> sinelaw, what would Peaker have to say about it? (i think i have had a short discussion with him about this stuff, but i don't really remember details)
11:59:57 <zeno> lament: since it gets exponentially harder to impove you must be 5d now :)
12:00:01 <sinelaw> jmcarthur, a whole lot.
12:00:08 <Frederick[SE]> i will try NameAlreadyInUse, im not an expert, i just started today :)
12:00:10 <sinelaw> i've been working with him on this
12:00:12 <zeno> oo heres another one a bit prettier but slower http://www.cs.kent.ac.uk/people/staff/cr3/tmp/SimpleGo.hs
12:00:16 <sinelaw> lately, he's been working on it alone
12:00:27 <quicksilver> conal: (and Workybob) mail sent to reactive, my 2D curve animation thing uploaded.
12:00:37 <jmcarthur> sinelaw, ah. any links to research that you know of?
12:00:53 <sinelaw> jmcarthur, cabal install lui
12:01:00 * jmcarthur looks up lui
12:01:12 <sinelaw> you won't find much in google i think
12:01:30 <sinelaw> jmcarthur, this is our old website: http://enough.googlecode.com/
12:01:34 <sinelaw> it's completely outdated by now
12:01:36 <Frederick[SE]> i think you are right NameAlreadyInUse, im getting a whole load of other errors now, i guess that is a good sign
12:02:32 <sinelaw> jmcarthur, the idea is to write an editor that will hold the syntax graph in memory and any edit you do won't be textual
12:03:04 <NameAlreadyInUse> <Frederick[SE]>: do you mind pasting your code at http://hpaste.org/ ?
12:03:05 <sinelaw> it will be directly on that tree
12:03:18 <jmcarthur> sinelaw, ah! i'll take a peek at it
12:03:41 <sinelaw> i mean grahp. and the gui will represent that however we may like, but at first as haskell syntax
12:04:36 <Frederick[SE]> <NameAlreadyInUse> <Frederick[SE]>: do you mind pasting your code at http://hpaste.org/ ? << I will paste my new code
12:06:02 <Frederick[SE]> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=2862#a2864 << I have added a revision, errors are at the end of the haskell ive pasted
12:06:15 <NameAlreadyInUse> ok, i will have a look
12:06:38 <jmcarthur> sinelaw, thanks
12:06:53 <bmh> pumpkin signed off of #haskell! what is the world coming to?
12:07:00 <NameAlreadyInUse> -- Returns the road tuples
12:07:00 <NameAlreadyInUse> fn_roads :: [ ( Int , String , String ) ]
12:07:00 <NameAlreadyInUse> fn_roads = do { contents <- readFile "toll.in";	return (fn_roads2 1 (lines contents)) }
12:07:00 <NameAlreadyInUse> -- Case number -> array of lines in file -> road tuples
12:07:00 <NameAlreadyInUse> fn_roads2 :: Int -> [ String ] -> [ ( Int , String , String ) ]
12:07:17 <Frederick[SE]> ouch
12:07:22 <NameAlreadyInUse> oops
12:07:29 <NameAlreadyInUse> that's what i get for not making sure my copy buffer has the correct
12:07:44 <sinelaw> jmcarthur, np, and if you see Peaker here - he can tell you a lot more and probably make it sound more interesting too :)
12:07:59 <jmcarthur> heh
12:08:00 <beelsebob> NameAlreadyInUse: fn_roads has the type IO ...
12:08:28 <zeno> lament: i can link you to my version if your interested
12:08:37 <NameAlreadyInUse> beelsebob: i know, sorry, i accidentally pasted that
12:08:40 <sinelaw> i'll go back to my studying for that insanely boring yet difficult exam i have tomrrow
12:08:45 <beelsebob> also, [ a ] is not an array of as
12:08:48 <beelsebob> its a list of as
12:09:11 <lament> zeno: will i be able to run it? (what does it use for UI?)
12:09:32 <beelsebob> also, fn_roads is written fn_roads = fn_roads2 <$> readFile "toll.in"
12:09:41 <sinelaw> analog transistor circuits...blaaarg
12:09:44 <beelsebob> also, it's traditional to use camelCase, not_underscores
12:09:46 <zeno> lament: just hacked at it for like 2 days now so ghci :( working on GTP
12:09:49 <Frederick[SE]> beelsebob, thats actually my code
12:10:00 <zeno> runs tho lol
12:10:00 <beelsebob> ah, k
12:10:05 <beelsebob> well, same to you :)
12:10:06 <Frederick[SE]> but still, i need help :P
12:10:22 <NameAlreadyInUse> beelsebob: my copy buffer did not hold the data i expected
12:10:51 <ksf> line 13 is a parenthesis issue, 26 ++ vs. : , 42 misses an argument to lines, 51 parens, again, and 62 should be readily fixed with fromIntegral.
12:11:07 <ksf> ...or, rather, read.
12:11:11 <zeno> lament: maybe theres some really obvious reason why its so slow you could tell me
12:11:20 <lament> zeno: er, okay
12:11:44 <ksf> I'd advice you to split the problem up in smaller parts, that is, comment most of the stuff out, load the file in ghci and try out each function on its own.
12:12:45 <Frederick[SE]> yeah, i guess thats the best way, i thought i was pretty close, but i guess i was wrong
12:13:48 <Frederick[SE]> what API are you all using? as in the standard functions. Those in Prelude
12:16:14 <CTA> would you recommend me using haskell on a windows os or linux?
12:16:53 <lament> CTA: you mean, which OS you should use? It doesn't matter.
12:17:03 <CTA> kk
12:17:19 <CTA> im thinking about seriously learning haskell
12:17:31 <CTA> would you reccomend rwh or lyah?
12:17:37 <p_l> CTA: linux would make it easier, I think, but that's mostly about other parts of the environment, not haskell itself
12:17:48 <lament> CTA: "seriously" = rwh
12:17:48 <ksf> CTA, linux.
12:18:01 <CTA> what about mac?
12:18:09 <osfameron> not sure if rwh is a good /first/ book
12:18:18 <ksf> ...not only because it's not windoze, but also because some libs don't properly build on non-unices due to bash scripts.
12:18:27 <beelsebob> CTA: mac is basically the best platform for Haskell development
12:18:30 <ksf> osfameron, sure it is.
12:18:30 <beelsebob> all the libraries work
12:18:37 <beelsebob> and you get some bloody good editors too
12:18:44 <CTA> aha
12:18:51 <CTA> im hoping to get a mac when i go to college
12:18:53 <ksf> huh? there's vim for linux...
12:18:58 <beelsebob> heh
12:19:00 <CTA> that's not another 1/2 years though..
12:19:06 <osfameron> beelsebob: i couldn't install ghc on dad's macbook...
12:19:14 <ksf> i'm not aware of any bloody good editors besides vim and yi.
12:19:17 <beelsebob> osfameron: o.O
12:19:22 <beelsebob> it's... a double click installer
12:19:37 <sbahra> beelsebob, huh?
12:19:37 <osfameron> gave up and put hugs on instead
12:19:43 <beelsebob> o.O
12:19:47 <sbahra> beelsebob, why is Mac OS X the best platform for Haskell development?
12:19:49 <sbahra> I disagree.
12:20:03 <beelsebob> seriously... haskell.org/ghc download the installer, double click, click next repeatedly... done
12:20:03 <p_l> ksf: Emacs. But I agree about Vim being a bloody good editor :)
12:20:04 <Frederick[SE]> can i do something like toInteger but then it returns an Int instead of an Integer?
12:20:05 <sbahra> Damn it!
12:20:08 <CTA> so, would you say for me to read lyah or rwh? or both? and if so in which order?
12:20:09 <gwern> mac is horrible for haskell development; linux is best
12:20:10 <beelsebob> sbahra: because all the libraries work
12:20:13 <b_jonas> osfameron: out of curiosity, how did you try to install it, and is it running latest OS X?
12:20:17 <sbahra> beelsebob, no they don't.
12:20:21 <beelsebob> and you get a whole crap load of good editors not available on other platforms
12:20:24 <beelsebob> sbahra: which don't?
12:20:27 <b_jonas> Frederick[SE]: toIntegral
12:20:32 * beelsebob has never had one fail
12:20:33 <osfameron> beelsebob: i'll try again next time i'm subjected to osx
12:20:40 <sbahra> beelsebob, on hackage.
12:20:45 <Frederick[SE]> Algorithm.hs:62:50: Not in scope: `toIntegral'
12:20:46 <beelsebob> sbahra: which ones don't work?
12:20:48 * bremner things which OS discussion are fail by definition
12:21:02 <b_jonas> Frederick[SE]: um, sorry, ignore that
12:21:04 <ksf> CTA, personally i can't stand lyah-style texts, but if you can stand it, read it first
12:21:07 <sbahra> beelsebob, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HFuse
12:21:11 * bremner also thinks the grammar of that last statement is fail
12:21:12 <sbahra> beelsebob, one example. :-P
12:21:17 * sbahra giggles
12:21:23 <ksf> :t fromIntegral
12:21:24 <lambdabot> forall a b. (Num b, Integral a) => a -> b
12:21:24 <beelsebob> sbahra: why doesn't that work?
12:21:30 <osfameron> b_jonas: ah. actually i think that was the problem. it was slightly too old an osx for anyone to have bothered compiling a binary
12:21:34 <sbahra> beelsebob, because it is bindings to Linux FuSE.
12:21:34 <beelsebob> sbahra: http://code.google.com/p/macfuse/
12:21:34 <ksf> ...but that's not what you want to use.
12:21:37 <ksf> :t read
12:21:38 <lambdabot> forall a. (Read a) => String -> a
12:21:40 <beelsebob> sbahra: which works on OS X ...
12:21:46 <osfameron> this is a problem with mac...
12:21:50 <ksf> ...which can convert a string to an int.
12:21:50 <b_jonas> osfameron: I see
12:21:51 <sbahra> beelsebob, anyways, that isn't why.
12:22:05 <sbahra> beelsebob, in general, Mac OS X ptrace is not fully implemented.
12:22:09 <b_jonas> osfameron: I don't really know OS X actually, I work on linux machines mostly
12:22:12 <osfameron> my dad is never going to/pay/ to upgrade osx
12:22:13 <beelsebob> no... dtrace is sbahra
12:22:16 <beelsebob> which is much much better
12:22:23 <sbahra> beelsebob, it isn't completely open-source, you don't have a good interface to CPU-specific performance monitoring.
12:22:31 <osfameron> b_jonas: yeah, me too
12:22:34 <CTA> haskell code interests me by scaring me, the code itself scares the math outa me, but thinking about being able to right that type of stuff makes me want to learn it
12:22:39 <beelsebob> sbahra: you have used dtrace?
12:22:43 <sbahra> beelsebob, sure. But you have dtrace on Solaris.
12:22:45 <sbahra> beelsebob, quite a bit.
12:22:47 <beelsebob> indeed
12:22:54 <CTA> what's haskell like for network programming? like to say, build an irc?
12:22:56 <beelsebob> so you'll know that dtrace is fairly stunningly awesome then
12:22:59 <jmcarthur> as somebody who learned haskell on a mac and has since mostly switched to linux, i find haskell development far easier on linux
12:23:01 <sbahra> beelsebob, and Solaris is fully POSIX-compliant
12:23:04 <beelsebob> CTA: see lambdabot
12:23:08 <ksf> CTA, look at lambdabot's source.
12:23:10 <sbahra> beelsebob, it's fine. It depends on the kind of work you do, I guess.
12:23:10 <beelsebob> sbahra: so is OS X
12:23:12 <Saterus> CTA: i just started haskell about a month ago. i was doing RWH and understood things up until about ch10. i kept going, but i was kinda lost. last night i decided to switch to lyah.
12:23:18 <beelsebob> sbahra: UNIX certified at that
12:23:20 <sbahra> beelsebob, it is? That's news to me. :)
12:23:23 <ksf> @vixen, will you show us your code?
12:23:24 <lambdabot> whoa whoa whoa, one question at a time!
12:23:28 <jmcarthur> CTA, there is a tutorial on making an IRC bot in haskell somewhere, actually
12:23:29 <sbahra> beelsebob, Where can I learn about its POSIX compliance?
12:23:56 <ksf> CTA, then there's happstack, but it will utterly blow any newbies mind.
12:24:01 <beelsebob> sbahra: http://www.apple.com/macosx/technology/unix.html
12:24:03 <CTA> is networking in haskell as hidious as other languages? like c, c++?
12:24:04 <sbahra> beelsebob, Mac OS X doesn't have something like FreeBSD's hwpmc framework or Solaris's various cpustat utilities.
12:24:05 <jmcarthur> yeah, don't start with happstack
12:24:11 <bvck> Can someone clarify this for me? *Main> :kind (->)    shows    (->) :: ?? -> ? -> *
12:24:11 <Saterus> CTA: both are good. they have slightly different spins to the material. that's my impression of the beginning chapters of lyah anyway.
12:24:16 <bvck> What is ?? and ? here?
12:24:18 <Frederick[SE]> @ty read
12:24:19 <lambdabot> forall a. (Read a) => String -> a
12:24:20 <ni|> Cale: ping
12:24:24 <b_jonas> may I reask (a variant of) my question from afternoon again? in a ghc thread, how do I block until a file descriptor becomes readable (or writable resp) without blocking the other threads?
12:24:30 <ksf> CTA, the basic socket interface is the same.
12:24:30 <beelsebob> sbahra: what do those utilities do?
12:24:39 <jmcarthur> CTA, networking is haskell is about how you would expect it to be in a scripting language like python or ruby
12:24:45 <sbahra> beelsebob, provide access to CPU performance counters.
12:24:47 <ksf> ...but there's abstraction over most of the really dirty parts.
12:24:55 <beelsebob> sbahra: what CPU performance counters specifically...
12:25:11 <ksf> b_jonas, compile with -threaded
12:25:12 <sbahra> beelsebob, let's say...cycle count, L2 cache misses
12:25:15 <Cale> ni|: hi
12:25:20 <CTA> i gtg soon, btw iv heard haskell + math ===== niceeee?
12:25:23 <Frederick[SE]> Does this convert noSpoons to an Int? read noSpoons::Int
12:25:25 <jmcarthur> low level networking, that is. monad stacks can take pain out of anything ;)
12:25:25 <beelsebob> sbahra: /Developer/Applications/CHUD
12:25:35 <sbahra> beelsebob, ok ok
12:25:38 <b_jonas> ksf: what I mean is how I can block until it's readable without actually reading from it
12:25:41 * sbahra will check it out
12:25:42 <ksf> > read "123" ::Int
12:25:43 <lambdabot>   123
12:25:46 <b_jonas> ksf: or writable without writing
12:25:56 <Frederick[SE]> > read noSpoons::Int
12:25:58 <lambdabot>   Not in scope: `noSpoons'
12:25:59 <NameAlreadyInUse> @type read
12:26:00 <lambdabot> forall a. (Read a) => String -> a
12:26:14 <beelsebob> /Developer/Applications/Performance\ Tools/CHUD even
12:26:25 <sbahra> beelsebob, still, I think it's a stretch to say it is the "best".
12:26:29 * sbahra shrugs
12:26:39 <beelsebob> sbahra: well, it has pretty much everything that linux offers
12:26:41 <beelsebob> plus more
12:26:43 <NameAlreadyInUse> >read "[1,2,3,4]" :: [Int]
12:26:45 <ksf> > let noSpoons = "123" in read noSpoons :: Int
12:26:47 <lambdabot>   123
12:26:50 <sbahra> beelsebob, what's the more?
12:26:53 <beelsebob> and none of the irritating library problems that windows has
12:26:54 <NameAlreadyInUse> > read "[1,2,3,4]" :: [Int]
12:26:56 <lambdabot>   [1,2,3,4]
12:26:56 <sbahra> beelsebob, dtrace.
12:27:03 <beelsebob> sbahra: various bloody good text editors, and things like dtrace
12:27:10 <beelsebob> which is surprisingly useful for Haskell
12:27:14 <sbahra> Fair enough.
12:27:18 <Frederick[SE]> NameAlreadyInUse, that last one made an Int array out of it didnt it?
12:27:19 <ksf> b_jonas, that _should_ be the default behaviour.
12:27:25 <jmcarthur> what does dtrace actually offer for haskell programs?
12:27:37 <CTA> can i create apps for iPhone with haskell?
12:27:37 <sbahra> beelsebob, I just wish it was an option to use X11 exclusively on Mac OS X.
12:27:41 <ksf> Frederick[SE], yes... read and show can serialise almost everything.
12:27:43 <jmcarthur> and even on os x, i didn't find any of the text editors any better than emacs
12:27:52 <beelsebob> jmcarthur: if you compile with -fvia-c you can manage to do some pretty nice profiling tricks with it
12:28:07 <jmcarthur> sbahra, you can if you don't use any aqua apps, of course
12:28:09 <beelsebob> jmcarthur: SubEthaEdit, but if you're an emacs user you may prefer TextMate
12:28:14 <sbahra> jmcarthur, you can?
12:28:17 <Frederick[SE]> show and read both look quite promising indeed :)
12:28:18 <sbahra> jmcarthur, how?
12:28:22 <beelsebob> and yeh... it's entirely possible to turn Aqua off
12:28:24 <beelsebob> just... stupid
12:28:28 <jmcarthur> beelsebob, i was a long time user of both of those editors
12:28:28 <beelsebob> there's absolutely no reason to
12:28:29 <b_jonas> ksf: default behaibiour of what? what io function do I call?
12:28:30 <sbahra> jmcarthur, I couldn't find such a method.
12:28:36 <jmcarthur> beelsebob, then switched to emacs
12:28:39 <ni|> Cale: its bbs :)
12:28:45 <ni|> do you have anything to do with gsoc?
12:28:48 <sbahra> beelsebob, I don't want to use Aqua.
12:28:52 <beelsebob> sbahra: why not?
12:28:54 <Cale> ni|: nope
12:28:55 <NameAlreadyInUse> <Frederick[SE]>: read is like the opposite of "show"
12:29:07 <beelsebob> jmcarthur: fair enough, I'm a passionate subscriber to the view that the reason people argue over vi or emacs is ebecause they both suck
12:29:08 <jmcarthur> a long long time ago i ran kde on os x as my main window manager, just to try it out
12:29:09 <ksf> b_jonas, any that reads or writes.
12:29:23 <sbahra> beelsebob, because I prefer to use xmonad, firefox, etc...various X11 applications and a terminal.
12:29:34 <ksf> non-blocking io wouldn't play nicely with monadic sequencing, now would it?
12:29:37 <jmcarthur> sbahra, oh yeah, people have gotten xmonad working on os x
12:29:37 <beelsebob> sbahra: fair enough... why does that mean you don't want aqua running at all?
12:29:38 <sbahra> beelsebob, without the combined overhead of both X11 and Aqua.
12:29:49 <Frederick[SE]> <NameAlreadyInUse> <Frederick[SE]>: read is like the opposite of "show" << Yeah, so i just read :)
12:30:04 <osfameron> aqua is fairly pish also
12:30:06 <beelsebob> meh, aqua barely uses any resources... about 50MB of RAM here
12:30:07 <omnihil> how do you view cpu stats in CHUD? there's no CHUD.app, just Reggie SE.app, SpindownHD.app, and Saturn.app
12:30:21 <Frederick[SE]> > fn_case caseno words x
12:30:22 <lambdabot>   Not in scope: `fn_case'Not in scope: `caseno'
12:30:23 * sbahra owns a PCC Mac Mini
12:30:25 <sbahra> With 512MB RAM
12:30:29 <sbahra> hrhr
12:30:31 <omnihil> none of those seems to show cpu counters
12:30:32 <b_jonas> ksf: er look
12:30:37 <sbahra> Maybe that explains my terrible experience with Mac OS.
12:30:38 <b_jonas> I think I didn't explain myself well
12:30:56 <beelsebob> omnihil: oh, they've taken some apps out of there... let me see if I can find them again
12:31:12 * jmcarthur ran KDE on a iMac G3 with something like 128 MB of memory alongside aqua, then disabled aqua just for kicks, but there was little performance difference
12:31:48 <jmcarthur> that is, it was _all_ slow
12:31:56 * ksf once ran solaris 9 on an ultasparc 1, and went fishing.
12:31:57 <sbahra> jmcarthur, I also find Mac OS X very unresponsive under I/O.
12:32:06 <m`lan> beelsebob: may i ask which editor ure using instead of vi or emacs? just curious :p
12:32:08 <sbahra> Any "heavy" I/O that is.
12:32:13 <beelsebob> m`lan: SubEthaEdit
12:32:29 <beelsebob> sbahra: I find that on Intel machines, not on PPC
12:32:30 <m`lan> gah. now i have to google that :)
12:32:33 <beelsebob> but that's a flaw in x86
12:32:34 <beelsebob> not OS X
12:32:36 <jmcarthur> sbahra, i think the xnu kernel kind of suffers on performance for a lot of POSIX stuff, yes
12:32:44 <sbahra> beelsebob, FreeBSD has no such problem on x86.
12:32:59 <jmcarthur> sbahra, apple's pro apps use a lot of mach messages that seem to be better tuned than the freebsd stuff they ripped off
12:33:01 <sbahra> beelsebob, Solaris does better than Mac OS X in this regard, too.
12:33:10 <ksf> my linux only becomes unresponsive if it's starting to swap badly.
12:33:13 <beelsebob> I've not found Solaris any better on x86
12:33:16 <Frederick[SE]> GHC keeps complaining about this function call: fn_case caseno words x
12:33:17 <sbahra> jmcarthur, I'm not sure this is relevant.
12:33:17 <beelsebob> much much better on Sparc
12:33:19 <beelsebob> but not on x86
12:33:23 <Frederick[SE]> fn_case :: Int -> [String] -> (Int, Int, String, String)
12:33:24 <beelsebob> not tried using FBSD
12:33:31 <sbahra> beelsebob, ? Not sure what basis you're using for comparison
12:33:39 <Frederick[SE]> which i can understand, i tried putting parenthesis around words x, but it doesnt help
12:33:40 <sbahra> Anyways, I have to run.
12:33:44 <jmcarthur> sbahra, i just mean that the most responsive apps from apple are using entirely different APIs than most of us are
12:33:46 <beelsebob> sbahra: heavy swapping and seeing if it stays vaguely responsive
12:33:54 <beelsebob> both on x86 become pretty bogged down
12:34:01 <beelsebob> because x86 requires interupts for disk access
12:34:09 <sbahra> In fact, Mac OS X still does on-demand page zeroing?
12:34:13 <sbahra> And other silly things.
12:34:27 <beelsebob> on demand page zeroing?
12:34:31 <ni|> Cale: too bad :)
12:34:33 <ni|> thx anyways
12:34:35 <sbahra> beelsebob, why does it require interrupts? DMA?
12:34:47 <sbahra> beelsebob, if it requires interrupts, then your HDD is not properly supported (or sucks).
12:34:48 <NameAlreadyInUse> <Frederick[SE]>: the type signature says that fn_case takes 2 arguments, but you are calling it with three
12:34:55 <beelsebob> sbahra: because that's the way x86 is
12:34:59 <sbahra> No.
12:35:09 <sbahra> That's not true, unless you're doing PIO or something silly like this
12:35:15 * sbahra has to run :(
12:35:16 * sbahra poofs
12:36:02 <Frederick[SE]> <NameAlreadyInUse> <Frederick[SE]>: the type signature says that fn_case takes 2 arguments, but you are calling it with three << Yeah, thats why i added parenthesis around "words x"
12:36:11 * ksf wants a 60gb ssd for system+swap
12:36:15 <Frederick[SE]> which should help no? i do get a different error... hrmmm maybe there's something different wrong now
12:36:31 <BMeph> :t words
12:36:32 <lambdabot> String -> [String]
12:36:38 <Baughn> Other than the extra functions, are there any real differences between a TVar and a TMVar?
12:37:19 <BMeph> Frederick[SE]: Yeah, let us know what the error is with "words x" in paras. :)
12:37:47 <NameAlreadyInUse> <Frederick[SE]>: change "length words x" on the line above to "length (words x)"
12:38:24 <Frederick[SE]> Algorithm.hs:52:4: Couldn't match expected type `[(Int, Int, String, String)]' against inferred type `(Int, Int, String, String)' In the first argument of `(++)', namely `fn_case caseno (words x)' In the expression: (fn_case caseno (words x)) ++ ((fn_cases2 caseno) + (1 xs)) In the definition of `fn_cases2': fn_cases2 caseno (x : xs) | (length (words x)) == 3 = (fn_case caseno (words x)) ++ ((fn_cases2 caseno) + (1 xs)) | otherwise = f
12:38:28 <Frederick[SE]> this is the error message inlined
12:39:25 <ksf> gragh. someone please tell me how iteratees and stream fusion differ, i need some beer to unbend my brain after staring at them.
12:40:39 <ksf> :t (++)
12:40:40 <lambdabot> forall a. [a] -> [a] -> [a]
12:40:43 <ksf> :t (:)
12:40:45 <lambdabot> forall a. a -> [a] -> [a]
12:40:46 <BMeph> Frederick[SE]: Try making the '++' between the fn_case and the fn_case2 into a ':'
12:40:49 <ksf> see the difference?
12:41:22 <int-e> Frederick[SE]: the (fn_cases2 caseno) + (1 xs) looks very odd
12:41:24 <Frederick[SE]> ah, ++ concatenates two arrays and : adds an element in front
12:41:34 <Frederick[SE]> do you always talk about lists or arrays?
12:41:38 <ksf> DON'T YOU CALL THEM ARRAYS
12:42:08 <ksf> > [1..]
12:42:10 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
12:42:10 <bremner> @quote fight club
12:42:10 <lambdabot> No quotes for this person. There are some things that I just don't know.
12:42:16 <ksf> ...try to do that with arrays.
12:42:35 <Frederick[SE]> yay, i got it to say that im lacking a main function again, i suppose this means that all the other errors are fixed :)
12:42:47 <NameAlreadyInUse> ksf: incidentally, is there any reason arrays can't have lazy semantics like that?
12:43:06 <Frederick[SE]> <ksf> DON'T YOU CALL THEM ARRAYS << I suppose this means you call them lists :P
12:43:12 <ilseman2> @pl     enPqs as pq = foldr (insertBy $ comparing snd) pq as
12:43:12 <lambdabot> enPqs = flip (foldr (insertBy (comparing snd)))
12:43:24 <sinelaw> does anybody know of a good screencast creator (linux)?
12:43:31 <sinelaw> i tried gtk-recordmydesktop but it's buggy
12:43:40 <ksf> NameAlreadyInUse, not without additional plumbing. it's just that you don't have infinite amounts of memory, except if you're name is turing.
12:43:45 <Baughn> "if' <$> connect conn <*> return conn <*> throwIO ConnectionFailed" <-- Is this a sufficiently good use-case for if'? (I'm sort of collecting reasons it should exist)
12:44:05 <Frederick[SE]> this is the most helpful ive ever been in... thanks for all the help, im off to watch some tv now :)
12:44:23 <int-e> Baughn: that doesn't do what you want
12:44:37 <ksf> NameAlreadyInUse, you also don't have the time to wait infinitely to fill a single chunk of infinite memory before starting to print the first element.
12:44:42 <b_jonas> NameAlreadyInUse: well, you could implement resizable arrays,
12:44:47 <Baughn> int-e: Er.. really?
12:44:59 <ksf> ...or chunk them, like bytestrings do.
12:45:00 <int-e> Baughn: try it. it'll always throw ConnectionFailed.
12:45:05 <monochrom> My name is Banach. I have more memory than Turing does. He has Aleph-null memory but I have c memory.
12:45:05 <b_jonas> NameAlreadyInUse: and I think you could also implement resizable arrays which resize on reading and have a default element depending on the index
12:45:23 <ksf> anyway, for me "array" is a synonym for "dumb memory region"
12:45:27 <Baughn> int-e: Well, I already decided I should let connect do the throwing, but.. yeah, I see now. Thanks for the pointer.
12:45:28 <b_jonas> NameAlreadyInUse: so I think nothing in theory, only it's not too practical
12:46:04 <Baughn> int-e: <*> attempts to pass the return value of throwIO to if'. Drat.
12:46:26 <int-e> right.
12:46:31 * Baughn is vaguely amused that he'd get blocked by an overly strict if in Haskell of all languages
12:46:33 <int-e> personally I've never missed if'.
12:46:54 <Baughn> It /was/ handy. The original had "return Nothing" in place of the throwIO.
12:47:12 <b_jonas> @type when
12:47:14 <int-e> (that's no objection to adding it to Data.Function or some place like that. It won't hurt either.)
12:47:14 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
12:47:18 <b_jonas> @src when
12:47:18 <lambdabot> when p s = if p then s else return ()
12:47:37 <NameAlreadyInUse> how does ByteString performance compare to String performance?
12:47:43 <monochrom> faster
12:47:51 <b_jonas> NameAlreadyInUse: depends on how you use them
12:47:59 <monochrom> smaller
12:48:01 <Baughn> b_jonas: I suppose I'm looking for "Monad m => m a -> b -> b -> b"
12:48:12 <Baughn> Er, 'm b' on that last one
12:48:25 * Baughn ponders. That wouldn't quite work either; I'd need a join. Hmm.
12:48:38 <eu-prleu-peupeu> is there any function that allows me to check this: val1 < x < val2 ?
12:48:39 <monochrom> (Why don't I use it? Because it doesn't store a quantifier.)
12:48:45 <ksf> NameAlreadyInUse, with lazy ones you should always be faster, unless you're hitting some utterly degenerated case that even dons didn't think of.
12:48:46 <NameAlreadyInUse> much faster? if i was planning to parse medium-sizedish files, for instance, would String be a large performance burden?
12:49:02 <Baughn> "if* p a b = do p' <- p; if p' then a else b"
12:49:05 <int-e> Baughn: and a = Bool?
12:49:13 <monochrom> medium performance burden.
12:49:16 <Baughn> int-e: That too
12:49:17 <Botje> eu-prleu-peupeu: inRange (val1, val2) ?
12:49:46 <eu-prleu-peupeu> hmm, i dont know that one
12:49:48 <Baughn> int-e: But I just kicked off a ghc compile, so my laptop will shortly be too hot to touch. I'll be back.
12:49:54 <Botje> it's in Data.Ix
12:49:55 <ksf> NameAlreadyInUse, depends on how you parse it. if you parse every single char on its own, string can be as fast as bytestring if your consumer don't build up stuff.
12:50:02 <b_jonas> Botje: it's not exactly the same for tuples for example
12:50:11 * ksf doesn't believe what he just wrote.
12:50:20 <monochrom> I attach an external keyboard mouse and monitor to my laptop.
12:50:28 <Botje> b_jonas: it's not? :(
12:50:29 <NameAlreadyInUse> so how does ByteString work? by partially
12:50:37 <NameAlreadyInUse> unrolling the String?
12:50:38 <Botje> wait, or wasn't that for me :)
12:50:39 <ksf> surely it's going to be slower, as single read() calls are always slower than block-io.
12:50:43 <b_jonas> > inRange ((3,3),(6,6)) (5,1)
12:50:44 <lambdabot>   False
12:50:58 <b_jonas> > ((3,3) < (5,1), (5,1) < (6,6))
12:50:59 <lambdabot>   (True,True)
12:51:09 <ksf> NameAlreadyInUse, it's basically a list of immutable arrays with a list-like interface and smart plumbing.
12:51:15 <b_jonas> also it's a <= c <= b instead of a < c < b
12:51:22 <Botje> ah, i see
12:51:23 <b_jonas> > inRange (2,4) 2
12:51:25 <lambdabot>   True
12:51:38 <NameAlreadyInUse> ksf: i'll probably be reading chunks of the file into a buffer and working from there
12:52:00 <ksf> NameAlreadyInUse, anyway, you shouldn't care: just use parsec, you can use it with both strings and bytestrings.
12:52:04 <b_jonas> and then there are types like Maybe and Either which are Ord but not Ix
12:52:12 <b_jonas> you could write a between function if you wanted though
12:52:14 <ksf> premature optimisation is the root of all evil.
12:52:36 <b_jonas> parsec works with bytestrings?
12:52:39 <ksf> NameAlreadyInUse, lazy bytestrings do exacly that.
12:52:46 <ksf> for a long time now.
12:52:48 <int-e> @type let bool t f b = if b then t else f in ?connect >>= bool (return ?conn) (error "lalala")
12:52:49 <lambdabot> forall a (m :: * -> *). (Monad m, ?conn::a, ?connect::m Bool) => m a
12:52:59 <Saterus> question about "where" syntax: does having a where clause save the result of that expression, while if you didn't throw the expression in a where clause it would be recalculated each time the expression is read?
12:53:04 <Saterus> example: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2871#a2871
12:53:10 <int-e> Baughn: how about this?
12:53:42 <ksf> the complexity of parsec's type signatures successively approximates the complexity of happstacks' signatures.
12:53:44 <vixey> Saterus: min' is better
12:54:13 <Saterus> vixey: for the reason i mentioned?
12:54:14 <ilseman2> @pl     findEdge (n1,n2) = find isWanted
12:54:14 <ilseman2>         where isWanted (s, t, _) = (n1 == s) && (n2 == t)
12:54:15 <lambdabot> findEdge = const (find isWanted)
12:54:32 <b_jonas> Saterus: it's because you use the value twice, once when checking which branch you need, and once in the last branch
12:54:39 <ksf> Saterus, afair only top-level CAF's are automatically memoized.
12:54:53 <b_jonas> Saterus: so in min' haskell surely computes it only once, in min'' you can't know that
12:55:36 <int-e> ksf: other CAFs may be floated out to the toplevel.
12:55:49 <Saterus> ok, thanks, that's what i thought.
12:56:12 <ilseman2> @pl  findEdge2 (n1,n2) = find (\(s,t,_) -> (n1 == s) && (n2 == t))
12:56:12 <lambdabot> (line 1, column 19):
12:56:12 <lambdabot> unexpected "="
12:56:12 <lambdabot> expecting variable, "(", operator or end of input
12:57:01 <ilseman2> @pl   findEdge2 (n1,n2) lst = find (\(s,t,_) -> (n1 == s) && (n2 == t)) lst
12:57:01 <lambdabot> (line 1, column 23):
12:57:01 <lambdabot> unexpected "="
12:57:01 <lambdabot> expecting variable, "(", operator or end of input
12:59:56 <ilseman2> any idea what I'm doing wrong with lambdabot?
13:00:45 <ksf> dunno, my local install can parse function definitions.
13:00:53 <ilseman2> does it not like the destructuring of the argument? or is that lambdabot's way of saying it can't reduce it
13:03:59 <b_jonas> @pl let findEdge2 (n1,n2) lst = find (\(s,t,_) -> (n1 == s) && (n2 == t)) lst in findEdge2
13:03:59 <lambdabot> (line 1, column 40):
13:03:59 <lambdabot> unexpected ","
13:03:59 <lambdabot> expecting letter or digit, operator or ")"
13:03:59 <lambdabot> ambiguous use of a non associative operator
13:04:33 <ksf> try a lambda.
13:04:38 <b_jonas> I think it wants an expression, not a declaration
13:04:46 <Deewiant> b_jonas: It can't handle triples
13:04:57 <vixey> yeah try a lambda, you're only smoking it
13:04:57 <b_jonas> Deewiant: oh
13:04:58 <mmorrow> here's a progression of the heapgraph of a (Map Int [Char]) over 12 steps of inserting (zip [0..11] randchars) into it http://moonpatio.com/vacuum/mapIntChar.png
13:05:01 <Deewiant> @pl \(s,t,_) -> s
13:05:01 <lambdabot> (line 1, column 6):
13:05:01 <lambdabot> unexpected ","
13:05:01 <lambdabot> expecting letter or digit, operator or ")"
13:05:01 <lambdabot> ambiguous use of a non associative operator
13:05:04 <b_jonas> I see
13:05:34 <b_jonas> @pl f x y = x + x
13:05:34 <lambdabot> f = const . join (+)
13:05:39 <b_jonas> so a declaration is ok
13:06:00 <b_jonas> @pl Just x = f y
13:06:01 <lambdabot> Just = const (f y)
13:06:05 <Deewiant> :-)
13:06:06 <int-e> mmorrow: urgh. 4000x3000 pixels.
13:06:10 <b_jonas> that's wrong, isn't it?
13:06:18 <mmorrow> int-e: whoa, really
13:06:22 <Deewiant> b_jonas: Garbage in, garbage out
13:06:36 <b_jonas> Deewiant: why? isn't that a correct declaration?
13:06:37 * vixey prefers  Garbage in, type error
13:06:57 <b_jonas> the result should be 'x = fromJust (f y)' or 'Just x = f y'
13:06:58 <mmorrow> here's an intmap of stuff with lists http://moonpatio.com/vacuum/omg3.png
13:06:59 <Deewiant> Hmm, it is isn't it
13:07:06 <b_jonas> why's that garbage?
13:07:16 <Deewiant> No, you're right
13:07:41 <b_jonas> > let { f = id; y = Just 42; Just x = f y; } in x
13:07:42 <Deewiant> @pl (Just x) = f j
13:07:42 <lambdabot> (line 1, column 10):
13:07:42 <lambdabot> unexpected "="
13:07:42 <lambdabot> expecting variable, "(", operator or end of input
13:07:42 <lambdabot>   42
13:07:45 * mmorrow needs to use gimp
13:08:08 <b_jonas> @pl (x, _) = y
13:08:08 <lambdabot> (line 1, column 3):
13:08:08 <lambdabot> unexpected ","
13:08:08 <lambdabot> expecting letter or digit, variable, "(", operator or ")"
13:08:55 <k_nishant> I've some queries in haskell can anyone solve it
13:09:07 <Deewiant> Not without knowing the queries
13:09:22 <k_nishant> 1)	Where a word occurs N times on the same line, ensure that the line number occurs n times in the index entry for that word.
13:09:48 <k_nishant> given attached code is
13:09:48 <b_jonas> k_nishant: building an index?
13:09:52 <k_nishant> import Prelude  type Doc	=  String type Line	=  String type Word	=  String	  makeIndex  ::  Doc  ->  [ ([Int], Word) ]  makeIndex  = 	shorten .	--	[([Int], Word)]	-> [([Int], Word)]   	amalgamate .--	[([Int], Word)]	-> [([Int], Word)]   	makeLists .	--	[(Int, Word)]	-> [([Int], Word)]   	sortLs .	--	[(Int, Word)]	-> [(Int, Word)]  	allNumWords .--	[(Int, Line
13:09:53 <mmorrow> int-e: i've gotta figure out how to scale stuff progressively, since any non-massive montage that has a large range of different sized graphs comes out crappy, since the big ones are too small
13:10:05 <k_nishant> yaa
13:10:11 <b_jonas> k_nishant: could you pastebin that? it's too long for one irc line
13:10:13 <Deewiant> k_nishant: paste long code snippets to hpaste, please
13:11:40 <knishant> hello
13:11:50 <knishant> some quesiries are there please it
13:11:55 <knishant> solve it
13:12:19 <b_jonas> wow
13:13:03 <knishant> these are the functions defined
13:13:08 <knishant> import Prelude
13:13:23 <b_jonas> knishant: copy the code to a pastie site please, and no, we won't solve your homework, but we may help you solve it if you took effort but you're stumped
13:14:00 <knishant> sir half sone
13:14:15 <NameAlreadyInUse> knishant: i can not understand you
13:14:18 <knishant> problem in two 2 problem
13:14:24 <dons> hmm
13:14:24 <lambdabot> dons: You have 12 new messages. '/msg lambdabot @messages' to read them.
13:14:29 <knishant> 3)	Treat a capitalised word (one or more capitals) as being different from the word in all lower case (but they should still be sorted alphabetically)  unless it is at the start of a sentence with only the initial letter capitalised.  A sentence is terminated by a ., ? or !.	
13:14:37 <dons> knishant: this is a homework question
13:14:41 <dons> we will not solve it for you.
13:15:11 <knishant> well ne wto haskell done completed some question
13:15:17 <knishant> robm coccuring on two
13:15:30 <knishant> need to solve only two question
13:15:37 <knishant> not other than two
13:15:41 <NameAlreadyInUse> knishant: what code have you got so far?
13:15:44 <Deewiant> You could try to present a partial solution or ask a more specific question (what are you stuck with)
13:15:52 <knishant> 3)	Treat a capitalised word (one or more capitals) as being different from the word in all lower case (but they should still be sorted alphabetically)  unless it is at the start of a sentence with only the initial letter capitalised.  A sentence is terminated by a ., ? or !.	
13:16:02 <dons> do not paste the question
13:16:10 <knishant> 1)	Where a word occurs N times on the same line, ensure that the line number occurs n times in the index entry for that word.
13:16:12 <dons> please go to #haskell-in-depth
13:16:15 --- mode: ChanServ set +o dons
13:16:20 <vixey> #haskell-in-depth isn't the right channel
13:16:32 <knishant> so where
13:16:37 <vixey> no where
13:16:38 <liyang> Use pastebin.com
13:16:42 <liyang> or hpaste
13:16:43 <ksf> -overflow, or hpaste
13:17:39 <dons> knishant: are you learning haskell for a course in India? that's cool.
13:18:39 <PeakerWork> I have a   class TypeStr where typeStr :: a -> String ;  instance TypeStr Int where typeStr _ = "Int"  -- and so on
13:18:40 <knishant> yaa
13:18:41 <monochrom> It infects India now?
13:18:52 <knishant> that's why I need help
13:18:56 <PeakerWork> now I have a function f:  (TypeStr a => a -> b) -- I want to call typeStr with (undefined :: a)  -- how can I do that?
13:19:05 <PeakerWork> Will scoped type variables work?
13:19:06 <knishant> if u please solve thses question
13:19:13 <Botje> knishant: USE A PASTEBIN
13:19:21 <Botje> then people will solve your question
13:19:23 <knishant> pasted the question
13:19:34 <monochrom> Does he know "pastebin"?
13:19:34 <Botje> now paste the url you got back here
13:19:47 <dons> fyi guys, http://www.haskell.org/haskellwiki/Homework_help
13:20:06 <Botje> knishant: http://hpaste.org/fastcgi/hpaste.fcgi/new
13:20:13 <Botje> put your question and any code you may have tehre
13:20:24 <b_jonas> in case you want statistics, my fresh ghc-6.10.1 install from source with extralibs and html docs without profiling libraries on linux-amd64-debian takes 307M
13:20:28 <b_jonas> now to install libraries
13:20:37 <PeakerWork> can I mix (forall a b c ..) with multiple class contexts?
13:21:02 <PeakerWork> forall a. Ord a => ...     works  but   forall a. (Ord a, Show a) =>     doesn't seem to
13:21:11 <PeakerWork> > (undefined :: forall a. a)
13:21:12 <lambdabot>   * Exception: Prelude.undefined
13:21:17 <PeakerWork> > (undefined :: forall a. Ord a => a)
13:21:19 <lambdabot>   * Exception: Prelude.undefined
13:21:23 <PeakerWork> > (undefined :: forall a. (Ord a, Show a) => a)
13:21:25 <lambdabot>   * Exception: Prelude.undefined
13:22:07 <ppavelV6> does anyone aware about the state of x86-64 under Mac OSX?
13:22:10 <TomMD> @type (undefined :: forall a. (Ord a, Show a) => a)
13:22:11 <lambdabot> forall a. (Show a, Ord a) => a
13:22:14 <knishant> when will i get the answers solved
13:22:28 <TomMD> knishant: No one will solve them for you
13:22:29 <johh> you have to post the link
13:22:43 <knishant> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2873#a2873 this is link
13:22:43 <PeakerWork> weird, ghc rejects that
13:22:50 <TomMD> knishant: This channel will help you understand concepts and methods, but you must do your own homework.
13:23:04 <knishant> well its my starting
13:23:18 <PeakerWork> It wanted () around the type (so forall is in ())
13:23:20 <knishant> I'll try to understand Haskell very well
13:23:32 <knishant> its an advanced language so take time to understand
13:23:46 <ppavelV6> knishant i think you have to ask specific questions to get help
13:25:27 <knishant> yaa specific questions are
13:25:38 <knishant> 3)	Treat a capitalised word (one or more capitals) as being different from the word in all lower case (but they should still be sorted alphabetically)  unless it is at the start of a sentence with only the initial letter capitalised.  A sentence is terminated by a ., ? or !.
13:25:43 <vixey> :p
13:25:46 <vixey> this is not going somewhere
13:25:49 <Deewiant> That's not specific
13:25:51 <TomMD> knishant: A copy and paste of the homework is not a specific question.  I'm muting you now.
13:26:00 <knishant> sorry
13:26:23 <knishant> I need help man
13:26:34 <monochrom> . o O ( I don't have a 42-inch LCD-plasma HD TV to read that wiiiiiiiiddddddeeeee text. )
13:26:35 <liyang> Have you attempted the work on your own.
13:26:38 <liyang> (?)
13:26:58 <liyang> Show us what you've attempted first.
13:27:21 <monochrom> . o O ( I guess 19" monitor is not enough. )
13:27:27 <iwannalog> how are encoded Char in GHC, they are ASCCI Char ?
13:27:35 <knishant> me done some coding on HAskell programming
13:27:39 <Deewiant> iwannalog: UTF-32
13:27:51 <Deewiant> Or strictly, 'unknown to you, arbitrary Unicode'
13:27:55 <knishant> http://pastebin.com/d12f585f6
13:27:57 <Deewiant> But at least in GHC they're just Ints
13:28:07 <iwannalog> Deewiant: why not utf-8 ?
13:28:11 <c_wraith> wouldn't that be UCS-32?
13:28:23 <lilac> knishant: what are you actually having trouble with? how far have you got?
13:28:34 <Botje> knishant: pick one of the questions. write code for it, _THEN_ come with questions.
13:28:38 <Deewiant> c_wraith: No, that'd be UCS-4, which is pretty much the same thing as UTF-32.
13:28:50 <Deewiant> iwannalog: I'm not sure actually
13:28:52 <c_wraith> Oh.  UCS specifies byte width, rather than bit width?
13:28:54 <knishant> i gone to curried function
13:28:55 <knishant> and homework is beyond that
13:29:10 <b_jonas> no, first you'll have to try to make that code run as is
13:29:15 <Deewiant> c_wraith: Well, the names do
13:29:20 <iwannalog> But if I rode an utf-8 file, does it work or did I need some postprocessing ?
13:29:26 <b_jonas> I'm trying, I've replaced funny quotes to ascii single quotes, added a main function,
13:29:28 <Botje> knishant: at least show that you've made an effort.
13:29:32 <b_jonas> and changed '.--' to '. --'
13:29:37 <b_jonas> then you should understand the code
13:29:38 <knishant> i'll show
13:29:46 <b_jonas> only after that should you start to make the changes
13:29:51 <Deewiant> iwannalog: Input is 'direct' by default: e.g. byte 255 maps to char value 255
13:30:06 <Deewiant> iwannalog: If you want to decode UTF-8 you need to do it yourself (or use a library which does it for you; there are some on Hackage)
13:30:22 <knishant> shud i submot my code
13:30:26 <iwannalog> okay, that's super
13:30:28 <knishant> here itself
13:30:30 <b_jonas> it does work after those changes
13:30:38 <knishant> module HASKELL_ASSIGNEMENT where
13:30:38 <knishant> import Prelude -- prelude hiding prelude is used to import built in function that is predefined in the haskell
13:30:38 <knishant> import Char
13:30:38 <knishant> -----------------------------------------------------------------------------------------------------------------------------------
13:30:45 <b_jonas> :-(
13:30:49 <monochrom> iwannalog: Some future versions of GHC will generate code that knows UTF-8 cold. For now there are packages "encode" and "utf8-string".
13:30:58 <lilac> knishant: hpaste.org
13:31:31 <iwannalog> That's great that tey decided that it was not C char.
13:31:56 <monochrom> In fact there are "Encode", "encoding", "utf8-light", "utf8-string"
13:32:02 * iwannalog is happy.
13:32:13 <b_jonas> main = getContents >>= (mapM_ print) . makeIndex
13:32:36 <b_jonas> ah, so it drops the whort words
13:32:47 <monochrom> Currently GHC generates code that assumes the most stupidest Americanism-centric ISO-8859-1.
13:33:10 <Deewiant> Well, Western Europe
13:33:20 <iwannalog> monochrom: i thu
13:33:29 <lilac> monochrom: where is that assumed? in I/O?
13:33:30 <liyang> It's developed in England, you know.
13:33:33 <iwannalog> monochrom: i thought it was european
13:33:48 <iwannalog> and that amricans use ASCII
13:33:51 <b_jonas> but, well, it does work
13:33:54 <Deewiant> US-centric would be to call 'fail' on non-ASCII ;-)
13:33:55 <lilac> iso-8859-15 is more appropriate for europe these days
13:34:04 <monochrom> Oh the American language started out from England too.
13:34:25 <knishant> i posted http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2876#a2876 the tried one
13:34:26 <iwannalog> iso-8859-1 is for french especially
13:34:40 <iwannalog> iso-8859-15 is for french especially
13:34:44 <b_jonas> what about this '.--' instead of '. --' in the code? is that really a bug or am I doing something wrong? does '.--' count as a single operator?
13:34:50 <knishant> well if someone solve my problem
13:34:51 <b_jonas> I guess it does
13:34:51 <Deewiant> ISO-8859-15 has €
13:34:55 <b_jonas> is it pasted wrong or what?
13:34:56 <Deewiant> b_jonas: Sure it does
13:35:01 <liyang> (cheese surrender monk... oh I can't be bothered.)
13:35:11 <Deewiant> > let a .-- b = a + b in 2 .-- 4
13:35:12 <lambdabot>   6
13:35:20 <iwannalog> Deewiant: and  'œ'
13:35:20 <monochrom> Anyway, the runtime I/O routines assume ISO-8859-1. It's most likely because it is quite compatible with Unicode for the lowest 8 bits.
13:35:57 <Deewiant> monochrom: I'd say it's more that they never did anything about encoding
13:36:03 <monochrom> Yeah. :)
13:36:07 <Deewiant> monochrom: It's just that mapping the bytes directly to Unicode gives you ISO-8859-1 :-P
13:36:09 <b_jonas> knishant: first try to actually run the code. you have to do three changes in it to be able to run: fix the funny quotes, fix the '.--' thing, and add a main function
13:36:38 <liyang> knishant: ask a question along the lines of ``I'm trying to write a function that does xyz. Here's the type I think it should have: f :: a -> b ; and here's how I'm implementing it: f = ... ; It doesn't produce the right output for some reason. Help?''
13:36:39 <b_jonas> knishant: run it with runghc redirecting some ascii english text to the input and see if its output looks reasonable
13:36:50 <iwannalog> in OCaml there are a open_in_bin and open_in
13:36:58 <liyang> knishant: and then we'll help you all you want.
13:36:59 <iwannalog> is it the same in Haskell ?
13:37:24 <b_jonas> knishant: while you can't run it, you won't be able to do the changes as well because somehow you have to test if they work (as you likely won't be able to write them right the first attempt)
13:37:38 <b_jonas> Deewiant: thanks
13:37:41 <monochrom> But I said the Americanism thing not because of GHC. I said it because in American emails people only use ascii or iso-8859-1, never utf-8, it's as though they never heard of utf-8 or other countries.
13:38:00 <b_jonas> how about the funny quotes? does ghc really accept them if I save the file as utf8 and possibly use some flag?
13:38:08 <Deewiant> iwannalog: At least System.IO is basically only binary input
13:38:08 <iwannalog> monochrom: american doesn't know there exist other keyboard than PC qwerty
13:38:09 <knishant> i submitted my problem
13:38:13 <ksf> dons, do you think one could implement iteratee's convStream using stream-fusion? It's kinda like a concatMap on steroids, type (Stream a -> Stream b) -> Stream a -> Stream b with the itarator taking an arbitrary number of a's and producing an arbitrary number of b's, and, most importantly, smart enough plumbing to avoid passing the non-consumed stream out of the iterator back into the enumerator. I bent my brain trying to do it, and am now way pa
13:38:13 <ksf> st the balmer-peak.
13:38:18 <iwannalog> Deewiant: argh
13:38:23 <knishant> by which time will it be solved
13:38:35 <lilac> knishant: we're not your slaves
13:38:35 <b_jonas> knishant: no, it's the teacher that submitted it to you. you'll have to solve it
13:38:36 <Deewiant> iwannalog: Because, as has been said, nothing is done about encodings :-P
13:38:48 <iwannalog> it's worse than you think
13:38:57 <b_jonas> (or should I say, I haven't got the cheque yet)
13:38:58 <Deewiant> iwannalog: But, there's no need for you to open in non-binary mode?
13:39:02 <knishant> well I know, I posted the tried on e alse
13:39:07 <iwannalog> Deewiant: text file
13:39:13 <Deewiant> iwannalog: Doesn't matter
13:39:21 <PeakerWork> this is cool! :-) http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2878#a2878  -- quickcheck-like type-class hackery to auto-input the right inputs for a function from the user
13:39:25 <iwannalog> Deewiant: you're joking ?
13:39:27 <Deewiant> iwannalog: On non-Windows there is no such thing as a separate 'binary mode' anyway
13:39:38 <lilac> knishant: ok, so tell us about your solution. how is it supposed to work, and what doesn't work?
13:39:48 <Deewiant> iwannalog: On Windows, all a text mode would do is translate \r\n to \n (IIRC; I never use text mode)
13:40:15 <iwannalog> Deewiant: so i don't care about binary or text ?
13:40:30 <Deewiant> iwannalog: Not for opening a file, no
13:40:34 <ksf> it should also interpret eof literally.
13:40:40 <iwannalog> and writing ?
13:40:43 <knishant> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2872  this is link
13:40:51 <knishant> plzz help me to solve it
13:41:10 <Deewiant> iwannalog: Also doesn't matter; if you output text, you get text. :-P
13:41:25 <mauke> I don't know what you're talking about but it's making me a sad panda
13:41:25 * ksf still doesn't get how people could have been so braindead as to include eof in ascii range.
13:41:36 <mauke> end-of-file is not a character
13:41:42 <Deewiant> mauke: 0x1a
13:41:45 <mauke> Deewiant: no
13:41:50 <iwannalog> Deewiant: doen't it give problem with transfer between different arch and OS ?
13:41:52 <liyang> knishant: look, if you keep asking us that same question, we're just going to start ignoring you.
13:41:52 <lilac> knishant: if you want my help, you will need to answer my questions.
13:42:03 <ksf> someone _must_ have noticed that there's an idiotic company around that's able to fall into that trap.
13:42:04 <Deewiant> iwannalog: No
13:42:24 <iwannalog> time has changed, what a great news
13:42:34 <b_jonas> Deewiant: that's used in dos only for dos1 (cp/m) compatibility because back in dos1 files didn't have a size, only number of sectors, so that's the only way to know where the end of a text file is
13:42:53 <Deewiant> True
13:42:54 <lilac> ksf: it was handy in MS-DOS; you could have a text string at the top of a file describing it, followed by an EOF, followed by the actual data
13:42:59 <b_jonas> Deewiant: dos 2 is like unix in that files have sizes so every program works without that char in the files
13:43:11 <Deewiant> Some old programs still stop reading on 0x1a
13:43:23 <b_jonas> Deewiant: they will, but they don't require it, they also stop at eof
13:43:26 <PeakerWork> in-band EOF is ... oh man
13:43:34 <b_jonas> Deewiant: the terminal thing is different though,
13:43:37 <Deewiant> b_jonas: Oh, sure, I never claimed otherwise
13:43:40 <mauke> I don't care what programs do; 0x1a is substitute, not end of file
13:43:55 <Deewiant> They couldn't read past EOF even if they tried, anyway :-P
13:44:01 <b_jonas> in dos programs reading from the terminal stop at control-z or f6 because of the same reason why they stop when they read it from a file
13:44:27 <b_jonas> which is handy because dos doesn't have control-d as the flush character like the default setting for unix terminals do
13:45:05 <b_jonas> even though that would be handy esp because in dos the a line read from terminal is limited to 255 chars or somethig like that
13:45:14 <b_jonas> a flush character like in unix would at least allow you to type longer lines
13:45:17 <iwannalog> b_jonas: ctl-d is a char ? i thougt it simulates an EOF
13:45:25 <mauke> it's both
13:45:44 <Baughn> "modifyMVar handle $ \handle -> do" <-- Evil?
13:45:45 <lilac> iwannalog: ctl-d is a key combination. different systems interpret it in different ways
13:45:46 <ksf> eof is wider than a byte, that's why read returns an int.
13:45:48 <b_jonas> iwannalog: it's a char before the terminal layer like control-c is, but the program reading the terminal doesn't see it
13:46:20 <b_jonas> iwannalog: the terminal translates it to a flush which is like what it does with enter (control-m) so you can't backspace over it, the program gets the line before it immediately
13:46:21 <lilac> iwannalog: on linux, depending on the terminal's mode, it might be translated into eof, or might get returned as character 4
13:46:36 <PeakerWork> Baughn: I think using the same name for a mutable ref to handle as handle is evil.. rHandle or vHandle or something is nicer, imo
13:46:40 <b_jonas> (except that enter also adds a control-j character to the input as well, another funny historical accident)
13:46:46 <iwannalog> b_jonas: i remember that with C i must use feof or check if the rode char was -1
13:46:57 <mauke> iwannalog: both are wrong
13:47:08 <lilac> b_jonas: enter doesn't add a ctrl-j. ctrl-j just happens to translate to ascii 10, which is enter
13:47:09 <b_jonas> and if you use it on am empty line then read will return 0 which is the same thing as it returns on eof for regular files
13:47:17 <b_jonas> it's amazing
13:47:19 <mauke> feof is insufficient, you also need to check for ferror; and EOF isn't guaranteed to be -1
13:47:20 <iwannalog> mauke: what must i do in C
13:47:23 <ksf> you read into an int, check it against eof, if it isn't eof, you cast it to char.
13:47:31 <b_jonas> lilac: well, I call that character cntrl-j but ok you're technically correct
13:47:59 <mauke> iwannalog: depends on the function you use, but in general you look at the return value
13:48:03 <lilac> b_jonas: yeah, i think you're being clear enough, but i dislike conflating the concept of keys to the input stream from the terminal, since i've seen that cause a /lot/ of confusion
13:48:09 <ksf> ...and, honestly, I never ever checked against errors w/ read and still passed the exercises.
13:48:19 <liyang> iwannalog: you keep using `rode'. I don't think it means what you think it means...
13:48:40 <iwannalog> mauke: my man page say that i must compar with EOF
13:48:52 <mauke> iwannalog: for which function?
13:48:57 <iwannalog> liyang: could you explain
13:49:00 <iwannalog> fgetc
13:49:13 <c_wraith> iwannalog: "read" is the past tense of "read".  spelled the same, pronounced differently
13:49:15 <Deewiant> iwannalog: The past tense of 'read' is 'read', pronounced the same as 'red'; not 'rode'
13:49:16 <mauke> yes, fgetc returns EOF when it reaches the end or when an error happens
13:49:18 <liyang> iwannalog: rode is past tense of ride...
13:49:36 <vixey> read is the past tense of read
13:49:41 <vixey> read is read RED
13:49:48 <liyang> -_-;;
13:49:56 <c_wraith> thanks for making everything even more confusing, vixey. :)
13:49:57 <vixey> whereas read is read reed :p
13:50:07 <mauke> int red = read(0, p, n);
13:50:15 <vixey> 1111 race 1 day 22112
13:50:15 <iwannalog> Deewiant and liyang, each one said the opposite of the other, who must i trust ?
13:50:24 <iwannalog> no sorry i misread
13:50:32 <Deewiant> Yes; not 'misrode' ;-)
13:50:34 <mauke> 11 was 1 race horse / 22 was 12 / 1111 race / 22112
13:50:42 <ksf> read, rid, ridden?
13:51:05 <liyang> Another irregular verb to be aware of is 'to twit', as in, to post to Twitter.com.
13:51:10 <ksf> rade?
13:51:20 <Deewiant> Rude
13:51:21 <mauke> beridden
13:51:26 <vixey> "I feel like a twit"
13:51:27 <Deewiant> Rad?
13:51:28 <b_jonas> liyang: how's it conjugated
13:51:28 <ksf> reaten?
13:51:58 <liyang> The past tense of 'twit' is 'twat' -- not very many people know that.
13:52:09 <liyang> (like sit/sat)
13:52:12 <ksf> twit, twad, twodden?
13:52:24 <vixey> ksf: twatted
13:52:24 <lilac> b_jonas: to twit: i tweet / you tweet / he,she is a twit. past tense: twat
13:52:35 <iwannalog> what is the name of the third "time", there is present, past tense and ?
13:52:40 <lilac> future
13:52:53 <ksf> past perfect?
13:52:54 <Deewiant> perfect
13:52:54 <opqdonut> iwannalog: past perfect
13:52:56 <mauke> future and pasture
13:53:02 <ksf> it's been a long time.
13:53:03 <liyang> Past tense of `to defecate' is `shat'.
13:53:06 <iwannalog> past perfect is I have bought
13:53:22 <Deewiant> Yes
13:53:41 <iwannalog> thx
13:53:44 <lilac> also, there's present continuous, as in "i buy food" versus "i am buying food"
13:54:02 <liyang> (I am being a twit.)
13:54:04 <c_wraith> english grammar has many more tenses than there are times available to do those things in.
13:54:22 <liyang> (Terribly irregular, that pesky verb.)
13:54:31 <lilac> "i will have been going to buy food"
13:54:33 <b_jonas> c_wraith: only because time travel is not common practice yet
13:54:44 <Deewiant> There's also past continuous; I was buying food
13:54:50 <lilac> "i was going to have been buying food tomorrow"
13:54:54 <liyang> (I was being a twat.)
13:55:03 <mauke> I could have been buying food
13:55:39 <Deewiant> Or wait, what actually
13:55:45 <iwannalog> is "tense" what i call time ?
13:55:59 <Deewiant> Past perfect is the pluperfect, "I had bought"
13:56:04 <c_wraith> "tense" is a grammatical construct used to indicate time, as well as a few other things
13:56:11 <Deewiant> "I have bought" is the present perfect
13:56:12 <ksf> to thense, dense, tense
13:56:25 <Deewiant> And then there's the future perfect "I will have bought"
13:56:58 <iwannalog> are there mood (mode, i dont know) ?
13:56:59 <mauke> np: Juno Reactor - Las Vegas Future Past
13:57:03 <ksf> "I had bought, but now I haven't, anymore"... wtf?
13:57:16 <Deewiant> iwannalog: Yes, there are moods
13:57:17 <lilac> historical present: "plato says that there are only 5 regular solids"
13:57:30 <iwannalog> Dewhich are ?
13:57:51 <vixey> plato said that!?
13:58:00 <c_wraith> There are also aspects, and voices...  English grammar is.... ummm...  flexible.  To be polite.
13:58:00 <lilac> ksf: "i had bought some soup for you but my niece became ill so i gave it to her"
13:58:03 <Deewiant> iwannalog: E.g. imperative
13:58:10 <lilac> vixey: you may be thinking of a different plato
13:58:22 <ksf> lilac, so you stopped having bought it for me as soon as that brat came along?
13:58:23 <Deewiant> iwannalog: I'm not quite sure when it comes to English, actually
13:58:26 <mauke> plato, platas, platat
13:58:28 <ksf> i call that revisionism.
13:58:35 <lilac> ksf: yeah, it's not for you any more
13:58:46 <mauke> platamus, platatis, platant
13:58:49 <vixey> I thought it was Euclid
13:59:01 <liyang> platypus.
13:59:08 <Baughn> "modifyMVar_ vPeerIdentity (return . const peerId)" <-- Is this safer than using swapMVar?
13:59:08 <vixey> ll
13:59:09 <ksf> "I bought you some soup but gave it to a brat" sounds better to me.
13:59:44 <lilac> vixey: well, in modern parlance they're named for plato, but i could well believe they were known of long before his time
13:59:59 <mmorrow> @tense \willHaveHadModifiedMVar_
14:00:00 <lambdabot> Unknown command, try @list
14:00:35 <vixey> it says on wiki "The earlier Greeks were interested primarily in the convex regular polyhedra, which came to be known as the Platonic solids. Pythagoras knew at least three of them, and Theaetetus (circa 417 B. C.) described all five. Eventually, Euclid described their construction in his Elements"
14:00:36 <lilac> @type unsafeWillHaveBeenGoingToHavePerformedIO
14:00:37 <lambdabot>     Not in scope: `unsafeWillHaveBeenGoingToHavePerformedIO'
14:01:02 <vixey> and "They are named for the ancient Greek philosopher Plato who theorized that the classical elements were constructed from the regular solids."
14:01:10 <lilac> vixey: does it say who was first to prove there were no more? i guess that's significantly more recent
14:01:16 <vixey> but I thought /that/ was Kepler
14:01:37 <lilac> Kepler thought the solar system could be explained in terms of them somehow i think
14:01:58 <NameAlreadyInUse> i am trying to use Control.Exception.Catch to handle possible errors when opening a file, but ghc complains about an ambiguous type variable in this code:
14:02:00 <NameAlreadyInUse> Exception.catch (readFile str >>= putStrLn) (const $ putStrLn "File could not be opened")
14:02:10 <liyang> lilac: Scottish expression -- ``You'll have had your tea then?'', meaning ``You've eaten dinnar, amirite?''
14:02:13 <Deewiant> NameAlreadyInUse: Specify the type of exception you want to catch
14:02:29 <lilac> liyang: sounds completely natural to me
14:02:40 <NameAlreadyInUse> Deewiant: how do i do that?
14:02:47 <ksf> Bucky describe how to make up chemical elements out of lego bricks.
14:02:50 <liyang> lilac: quite. But try explaining it.
14:02:54 <mauke> I was born where Kepler died
14:03:06 <Deewiant> NameAlreadyInUse: E.g. (const :: WhateverExceptionYouWant -> IO () -> IO ())
14:03:08 <ksf> ...not out of regular solids, though, chemistry is to complex to do that.
14:03:16 <mauke> NameAlreadyInUse: you could also import Control.OldException instead
14:03:27 <Deewiant> NameAlreadyInUse: What I'd do is \x -> const (x :: WhateverExceptionYouWant) $ putStrLn ...
14:03:37 <iwannalog> Okay after speaking about english grammar (thanks for your explanation), we'll speak about Comonad
14:03:40 <Deewiant> NameAlreadyInUse: In this case, IOException
14:03:52 <mauke> como?
14:04:01 <lilac> liyang: "i'm assuming that if i see you in this situation, you will have had your tea. am i right?"
14:04:04 <iwannalog> I have deiscovered a Comonad which gave me an interesting question
14:04:30 <iwannalog> The comonad fork, which have one entrance : fork :: Fork Int
14:04:33 <b_jonas> um
14:04:44 <iwannalog> and extract is doing the fork
14:04:53 * millz http://failblog.org/2009/03/18/bill-payment-win/
14:04:54 <b_jonas> can't you use the io-based exception thing in h89 instead?
14:05:35 <Deewiant> Well yeah, if you don't need Control.Exception then just use Prelude.catch for IO
14:05:41 <iwannalog> if you see it as a List there is the case of the empty list which prevent list from being a Comonad but with fork, whene th elist is empty, extract is like doing exit ()
14:05:43 <liyang> lilac: you've just repeated the "will have had" bit. :3
14:05:56 <iwannalog> and the question was if this monad break referential transparency
14:05:57 <Deewiant> liyang: Well, it makes sense, no need to explain :-P
14:06:29 <b_jonas> oh, Control.Exception's catch is called catch too?
14:06:37 <b_jonas> why are they shadowing the name?
14:06:38 <Deewiant> Yep
14:06:41 <vixey> > sqrt ((5 - sqrt 5) / 2) :: CReal
14:06:43 <lambdabot>   1.1755705045849462583374119092781455371953
14:06:44 <Deewiant> Well, it's the same thing
14:06:50 <Deewiant> Just a different type
14:07:00 <Deewiant> Which is a superset of the Prelude type
14:07:03 <b_jonas> oh
14:07:05 <b_jonas> I see
14:07:33 <b_jonas> and is the semantics consistent too?
14:07:35 <vixey> iwannalog: Well you can't implement in terms of forkIO  I guess.. it would need unsafePerformIO right?
14:07:40 <b_jonas> I don't know C.E
14:07:56 <Deewiant> b_jonas: Well, it's IO so there's never any semantic consistency ;-)
14:07:57 <iwannalog> vixey: right but i think it doesn't break referen...
14:08:08 <Deewiant> b_jonas: But seriously: yes
14:08:11 <vixey> iwannalog: Can you implement it in terms of Co-IO?
14:08:19 <vixey> iwannalog: I think that Co-IO was shown broken
14:08:21 <iwannalog> i don't know CoIO
14:08:36 <NameAlreadyInUse> Deewiant: i've added the type signature now and it works, but i think i will just use the prelude catch
14:08:49 <Deewiant> NameAlreadyInUse: That way is more portable :-)
14:09:04 <b_jonas> "CoIO" lol
14:09:10 <vixey> OI
14:10:27 <lilac> iwannalog: i don't think that's usefully a comonad to be honest
14:10:59 <iwannalog> lilac: it'a theoric monad I don't want to implement and use it, I just love to think about funny things
14:11:15 <NameAlreadyInUse> Deewiant: i don't understand why things in the standard library don't make more use of Either and Maybe
14:11:26 <b_jonas> NameAlreadyInUse: like what things?
14:11:29 <Deewiant> Well, the Prelude sucks in dozens of ways :-P
14:11:30 <iwannalog> NameAlreadyInUse: because of the hidden Monad
14:11:31 <bmh> iwannalog: A priest, a rabbi, and a pimp walk into a bar...
14:11:35 <skorpan`> :t fmap mappend
14:11:36 <lambdabot> forall a (f :: * -> *). (Functor f, Monoid a) => f a -> f (a -> a)
14:11:44 <iwannalog> bmh: and ?
14:11:50 <skorpan`> :t fmap (mappend (x :: Expr))
14:11:51 <lambdabot>     No instance for (Monoid Expr)
14:11:51 <lambdabot>       arising from a use of `mappend' at <interactive>:1:6-24
14:11:51 <lambdabot>     Possible fix: add an instance declaration for (Monoid Expr)
14:11:52 <NameAlreadyInUse> b_jonas: like openFile and such
14:11:57 <bmh> iwannalog: You're the one who likes to think about funny things.
14:11:58 <Deewiant> ?ty ap . fmap mappend
14:11:59 <lambdabot> forall a (f :: * -> *). (Functor f, Monoid a, Monad f) => f a -> f a -> f a
14:12:09 <b_jonas> NameAlreadyInUse: well, I think the exception-raising ones are easier to program usually
14:13:34 <skorpan`> :t fmap
14:13:36 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:13:49 <skorpan`> :t mappend
14:13:50 <lambdabot> forall a. (Monoid a) => a -> a -> a
14:14:03 <skorpan`> @instance Monoid
14:14:04 <lambdabot> Maybe you meant: instances instances-importing
14:14:08 <skorpan`> @instances Monoid
14:14:08 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
14:14:12 <skorpan`> @instances Functor
14:14:13 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
14:14:19 <iwannalog> Is there a place where people talk about haskell future ?
14:14:31 <bmh> #haskell-time-travel
14:14:41 <iwannalog> bmh: thx :)
14:14:56 <vixey> this channel
14:15:05 <Deewiant> And #haskell-in-depth
14:15:09 <iwannalog> vixey: but i mean a really dedicated one
14:15:23 <vixey> no
14:15:33 <alexbobp> I hope that wasn't in response to me joining...
14:15:43 <lilac> no
14:15:46 <vixey> oh no it's alexbobp
14:15:53 <lament> no
14:16:14 <opqdonut> no
14:16:18 <alexbobp> no
14:16:26 * alexbobp doesn't know what's going on
14:16:38 <ilseman2> @pl     replace p new = update p (\a -> new)
14:16:38 <lambdabot> replace = (. const) . update
14:16:48 <opqdonut> :)
14:16:58 <opqdonut> cute innit
14:17:19 <Deewiant> replace = ((>>>) >>> (>>>) (>>>)) update const
14:18:00 <ilseman2> const takes two arguments and returns the first, correct?
14:18:05 <opqdonut> indeed
14:18:07 <Deewiant> ?ty const
14:18:08 <lambdabot> forall a b. a -> b -> a
14:18:10 <Deewiant> Seems that way ;-)
14:18:21 <opqdonut> ?djinn a -> b -> a
14:18:22 <lambdabot> f a _ = a
14:18:25 <opqdonut> :)
14:18:57 <ilseman2> partial function composition ...
14:19:22 <iwannalog> Will one day Haskell include a proof checker ?
14:19:27 <vixey> no
14:19:33 <iwannalog> why ?
14:19:39 <vixey> that's external
14:19:43 <Nik_89> anyone noticed that theres a memory leak created when a callback is created (from the foreign wrapper) and freeHaskellFunPtr doesn't solve it
14:19:51 <lament> haskell includes a proof checker, it's the type system!
14:20:10 <vixey> mumble
14:20:14 <iwannalog> lament: it doesn't do what we want it to do
14:20:27 <beelsebob> http://www.computingcareers.co.uk/job/329156/functional-programming-consultancy-f-scala-erlang-haskell <-- for anyone looking for an excuse to play with FP all day
14:20:33 <opqdonut> iwannalog: yes it does :)
14:20:51 <ilseman2> so, does "(. const) blah) compose const with blah, or blah with const?
14:21:12 <Deewiant> ?ty (. const)
14:21:14 <lambdabot> forall c a b. ((b -> a) -> c) -> a -> c
14:21:17 <iwannalog> opqdonut: how could i use it to have a sorted list and be sure it's a sorted list without runtime code ?
14:21:19 <lilac> beelsebob: is that a galois job?
14:21:20 <Heffalump> beelsebob: that'll be lshift
14:21:34 <opqdonut> ilseman2: think of (+3) for example: (+3) 4 = 4+3
14:21:52 <beelsebob> lilac: I have no idea, Heffalump seems to though :)
14:21:54 <opqdonut> iwannalog: with enough type family magic
14:21:57 <vixey> iwannalog: You don't this sort of thing *in* Haskell, it's an activity of the mind (or an external analysis tool)
14:22:03 <opqdonut> iwannalog: and/or gadts
14:22:12 <Heffalump> I got called up by someone from that agency about it
14:22:25 <opqdonut> iwannalog: proving, for example, that ones matrix arithmetic is dimension-consistent
14:22:25 <iwannalog> vixey: ok, does a such tool exists ?
14:22:29 <opqdonut> is easy in the type system
14:22:36 <iwannalog> opqdonut: yes
14:22:38 <opqdonut> sortedness is just a bit harder
14:22:45 <vixey> sortedness is not possible in Haskell
14:22:56 <ilseman2> oh, I only tried partially applying the right hand to the - operator, which when I try to do it, just gives me the negative number
14:23:06 <opqdonut> :P
14:23:12 <ilseman2> as in let f = (- 5)
14:23:14 <lilac> vixey: do you have a proof of that? (i'll accept an intuitive one)
14:23:22 <opqdonut> i don't believe it
14:23:44 <vixey> There is no way in Haskell to reflect _computational properties_ about programs into the type system
14:24:07 <iwannalog> vixey: i read things about type arithmetic
14:24:52 <lilac> vixey: there is for some classes of properties; the type system can prove that i don't take the same lock twice and that i take a lock before running some portion of code, for instance
14:24:59 <ksf> ...unless you're oleg.
14:25:09 <lilac> vixey: but perhaps you meant something more specific?
14:25:16 <opqdonut> iwannalog: that's different. everything happens in the type system then
14:25:22 <vixey> lilac: Is that the regions stuff? or something else?
14:25:41 <Heffalump> opqdonut: you can make it happen in the type system and at the value level if you really want
14:25:47 <lilac> vixey: i think that was a parameterized monad
14:25:54 <lilac> vixey: so yeah, region stuff
14:25:59 <iwannalog> Heffalump: do you have an example ?
14:26:14 <bvck> Haskell syntax question.
14:26:15 <Heffalump> just use type classes
14:26:26 <bvck> Given this newtype StateTrans s a = ST (s -> (s, a))
14:26:47 <bvck> A monad definition starts with instance Monad (StateTrans s)
14:26:55 <bvck> Why is 'a' missing here?
14:27:10 <dibblego> bvck, the type constructor for a monad must take one more type argument
14:27:11 <bvck> I get a a strange kind exception if I supply 'a'.
14:27:17 <ksf> 'cos the a isn't applied, yet.
14:27:22 <dibblego> bvck, consider instance Monad [] and instance Monad Maybe
14:27:28 <Heffalump> data Z = Z ; data S n = S n ; class IsNum t where num :: t -> Int ; instance IsNum Z where num _ = 0 ; instance IsNum n => IsNum (S n) where num (S n) = num n + 1
14:27:38 <Heffalump> infact you'll be doing arithmetic on the Z/S values anyway
14:27:39 <lilac> vixey: you can do something like 'module LT (LT, lt, ...) where data LT a = LT a a; lt a b | a < b = LT a b | otherwise = LT b a; ...' and then you only need to prove that one module correct
14:27:40 <dibblego> bvck, right the "kind" of the type constructor must be * -> * not *
14:28:09 <bvck> dibblego, I think I am close to understanding it, but an example would help clarify.
14:28:33 <iwannalog> Heffalump: you could have a fact function with that ?
14:28:34 <bvck> Can one create a dummy Monad on newtype XX a b c = XX (a -> b -> c -> (a, b, c)) ?
14:28:35 <dibblego> bvck, you'd get the same kind error if you did instance Monad [Int] since [Int] does not take another type argument, but [] does
14:28:47 <Heffalump> iwannalog: don't see why not
14:28:54 <iwannalog> effective one ?
14:28:56 <Heffalump> well
14:29:10 <Heffalump> yeah, just do it with fundeps/type functions
14:29:18 * lilac thinks Functor should be derivable
14:29:31 <dibblego> bvck, you could on XX a b but that particular definition makes it difficult to give a body of anything but undefined
14:29:32 <iwannalog> lilac: it is with an extension
14:29:42 <lilac> iwannalog: cool! know which one?
14:29:50 <dibblego> NewtypeDeriving
14:29:56 * vixey thinks that we should be able to implement derivables using generic programming
14:29:58 <bvck> dibblego, thanks. That is the path I was walking on.
14:30:00 <iwannalog> don't remember, i read it on a blog
14:30:00 <Heffalump> that's cheating!
14:30:02 <lilac> dibblego: for 'data' not 'newtype'
14:30:31 <Heffalump> couldn't you do it with this? http://www.haskell.org/ghc/docs/latest/html/users_guide/generic-classes.html
14:31:05 <lilac> 'data Foo a = None | Many a (Foo a) | Indexed (Int -> a) deriving Functor'
14:32:17 <vixey> data Untyped = Var Ref | Lam (Scope Untyped) | App Untyped Untyped deriving Syntax
14:32:21 <iwannalog> @hoogle a -> a
14:32:21 <lambdabot> Prelude id :: a -> a
14:32:21 <lambdabot> Data.Function id :: a -> a
14:32:21 <lambdabot> Data.Generics.Schemes everywhere :: (a -> a) -> a -> a
14:32:28 <iwannalog> @hoogle (b -> c -> d) -> (a -> b) -> (a -> c) -> a -> d
14:32:28 <lambdabot> No results found
14:32:53 <iwannalog> @hoogle (b -> c -> d) -> (a -> b) -> c -> a -> d
14:32:53 <lambdabot> Data.Generics.Basics gmapQr :: Data a => (r' -> r -> r) -> r -> (a -> r') -> a -> r
14:32:53 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
14:32:53 <lambdabot> Data.Generics.Basics gmapQl :: Data a => (r -> r' -> r) -> r -> (a -> r') -> a -> r
14:33:41 * iwannalog thinks that some basic functions are missing in haskell
14:33:55 <vixey> iwannalog: Can't you define them yourself?
14:34:00 <bvck> Just to reiterate and to clarify: StateTrans type constructor takes two parameters (types) and returns another type (StateTrans s a)
14:34:22 <iwannalog> vixey: of course, but they are really standrad function used every day by mathematicians
14:35:10 <vixey> you only have to define them once
14:35:23 <iwannalog> vixey: in which module ?
14:35:24 <opqdonut> which ones?
14:35:28 <vixey> MyModule
14:35:53 <iwannalog> opqdonut: (b -> c -> d) -> (a -> b) -> (a -> c) -> a -> d
14:36:01 <iwannalog> @djiin a -> a
14:36:02 <lambdabot> f a = a
14:36:08 <iwannalog> @djiin (b -> c -> d) -> (a -> b) -> (a -> c) -> a -> d
14:36:08 <lambdabot> f a b c d = a (b d) (c d)
14:36:36 <vixey> iwannalog: what's that called?
14:37:05 <opqdonut> :t on
14:37:07 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
14:37:12 <opqdonut> a nice function
14:37:14 <iwannalog> they got no name they are too standard, but each time a mathematician add two functions it use it
14:37:33 <opqdonut> :t liftM2
14:37:34 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
14:37:42 <vixey> oh that
14:37:43 <opqdonut> that in the (a->) monad
14:37:45 <pavel831> :t app
14:37:46 <lambdabot> forall (a :: * -> * -> *) b c. (ArrowApply a) => a (a b c, b) c
14:37:49 <vixey> yeah that's defined already, you just didn't know it
14:37:55 <opqdonut> :)
14:38:03 <iwannalog> vixey: what ? where ?
14:38:16 <opqdonut> > liftM2 (+) sin cos $ 0.3
14:38:17 <lambdabot>   1.2508566957869456
14:38:30 <opqdonut> > sin 0.3 + cos 0.3
14:38:31 <bvck> dibblego, is 'currying' valid on type constructors?
14:38:32 <lambdabot>   1.2508566957869456
14:38:43 <opqdonut> ^_^
14:38:59 <iwannalog> (-> a) is a monad ?
14:39:15 <dibblego> iwannalog, yes
14:39:20 <iwannalog> great
14:39:26 <opqdonut> the greatest
14:39:29 <opqdonut> :t ap
14:39:31 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
14:40:01 <dibblego> bvck, yes that's what you're doing
14:40:02 <iwannalog> and the opposite one (where a is at the end of the arrow) is a comonad ?
14:40:05 <dibblego> @king []
14:40:05 <lambdabot> Maybe you meant: kind ping
14:40:10 <dibblego> @kind []
14:40:12 <lambdabot> * -> *
14:40:30 <opqdonut> iwannalog: no, i don't think so
14:40:33 <bvck> dibblego, thanks. Light bulb beginning to flicker...:)
14:40:37 <iwannalog> opqdonut: stange
14:40:55 <opqdonut> can't think of a definition for coreturn
14:41:07 <dibblego> bvck, try this: data List a = Nil a | a `Cons` List a; instance Monad List ...
14:41:13 <opqdonut> :t coreturn
14:41:14 <lambdabot> Not in scope: `coreturn'
14:41:15 <dibblego> oops
14:41:18 <dibblego> bvck, try this: data List a = Nil | a `Cons` List a; instance Monad List ...
14:41:25 <dibblego> m a -> a
14:41:26 <opqdonut> well anyway, w a -> a
14:42:00 <vixey> how about f undefined
14:42:33 <opqdonut> indeed.
14:42:53 <bvck> dibblego, yes. I had not realized till yesterday that List is a Monad also.
14:42:56 <bvck> Fun...:)
14:43:11 <O1athe> > const 3 undefined
14:43:12 <lambdabot>   3
14:43:34 <bvck> While I have you here, one more question...
14:43:42 <dibblego> newtype Fun t r = Fun (t -> r); instance Monad (Fun t) ...
14:43:56 <bvck> *Main> :kind (->) shows (->) :: ?? -> ? -> *
14:44:02 <bvck> What is ?? and ? here?
14:44:11 <iwannalog> what is (+ 1) is it (? + 1) or (1 + ?)
14:44:12 <dibblego> just pretend it says * -> * -> * for now :)
14:44:30 <vixey> (+ 1) is \x -> (x + 1)
14:44:41 <bvck> Okay...:)
14:44:48 <iwannalog> and (1 +) is \x -> 1 + x
14:45:05 <vixey> > let (+) = const in  (1 +) 3
14:45:06 <lambdabot>   1
14:45:10 <vixey> > let (+) = const in  (+ 1) 3
14:45:11 <lambdabot>   3
14:45:20 <opqdonut> bvck: the kind could as well be * -> * -> * , the other kinds are just an implementation detail
14:45:45 <alexbobp> How do I get the nth item from a tuple?
14:45:53 <bmh> pattern match on it
14:46:07 <vixey> alexbobp: How big is the tuple ?
14:46:30 <bvck> So basically there are three 'kinds' : '*', '* -> *' and '* -> * -> *'?
14:46:48 <dibblego> there are as many as you like
14:46:53 <opqdonut> bvck: and '* -> * -> * -> *' and '(
14:46:55 <opqdonut> gah
14:47:00 <opqdonut> (* -> *) -> *
14:47:02 <opqdonut> i meant to say
14:47:03 <ddarius> :k RWST
14:47:04 <dibblego> they simply denote the number of type arguments required to get a type
14:47:05 <lambdabot> * -> * -> * -> (* -> *) -> * -> *
14:47:28 <alexbobp> vixey: 4 elements
14:47:30 <alexbobp> bmh: thanks
14:47:31 <bvck> dibblego, that makes sense.
14:49:23 <bvck> (I have not written a single Haskell program yet. The abstraction in the language is stretching this rusty imperative brain of mine)
14:50:18 <skorpan`> ?ty foldMap
14:50:19 <lambdabot> Not in scope: `foldMap'
14:50:24 <skorpan`> :t foldMap
14:50:25 <bmh> can anyone point me to a good example of using the ST monad? I'm rusty.
14:50:26 <lambdabot> Not in scope: `foldMap'
14:50:31 <skorpan`> :t Data.Monoid.foldMap
14:50:33 <lambdabot> Not in scope: `Data.Monoid.foldMap'
14:50:35 <skorpan`> @hoogle foldMap
14:50:35 <lambdabot> Data.Foldable foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
14:50:36 <lambdabot> Data.Traversable foldMapDefault :: (Traversable t, Monoid m) => (a -> m) -> t a -> m
14:50:41 <skorpan`> :t Data.Foldable.foldMap
14:50:42 <lambdabot> forall a m (t :: * -> *). (Monoid m, Data.Foldable.Foldable t) => (a -> m) -> t a -> m
14:50:51 <skorpan`> sometimes it just needs some work :P
14:51:51 <bvck> bmh, does this help http://www.engr.mun.ca/~theo/Misc/haskell_and_monads.htm
14:51:58 <skorpan`> could someone try to explain to me again how foldMap works?
14:52:10 <skorpan`> i'm imagining a foldr with mappend somewhere in it
14:52:33 <wli> bmh: There are no instances to help with things like liftIO
14:52:35 <skorpan`> foldMap f xs = foldr (\x -> f x `mappend`) mempty xs
14:52:37 <skorpan`> something like that?
14:54:58 <skorpan`> @src Data.Foldable.foldMap
14:54:58 <lambdabot> Source not found. stty: unknown mode: doofus
14:55:49 <wli> I'd imagine foldrM (mappend . f) mempty xs vs. foldr per se.
14:56:22 <wli> Never mind, that's Monad not Monoid
14:56:28 <eu-prleu-peupeu> im calculating a recursive function in which several calls are repeated throughout, is there any way to use memoization or whatever in order to save those calculations ?
14:56:38 <vixey> yes
14:56:40 <Gracenotes> bmh: see http://en.wikibooks.org/wiki/Haskell/Hierarchical_libraries/Arrays for STArray info
14:56:58 <eu-prleu-peupeu> vixey: where can i read about that ?
14:57:01 <Gracenotes> the ST section and freezing-and-thawing section
14:57:05 <vixey> the haskell wiki
14:57:06 <wli> MonadReader/
14:57:12 <eu-prleu-peupeu> thanks
14:57:34 <bmh> I'm just looking to use it to transform a tree to a list in linear time, nothing complicated
14:57:41 <bmh> (I hope)
14:58:07 <Gracenotes> yep. That can be done with a simple recursive function
14:58:32 <bmh> Gracenotes: how? how long does concatenate take?
14:59:14 <tromp> you dont always need arrays for memoization, lists sometimes work too
14:59:52 <Gracenotes> well, in general, a ++ b takes as long as the number of elements in a.
15:00:09 <c_wraith> timing analysis in haskell is complicated, sometimes
15:00:21 <c_wraith> a ++ b, by itself is an O(1) operation
15:00:26 <Gracenotes> except if a is constructed on the fly, you'll need all the elements anyway, so once you get to b you'll be taking them in linear time
15:00:34 <Gracenotes> each.
15:00:38 <bmh> Gracenotes: so, I think what you're suggesting will take O(n lg n)
15:00:56 <Gracenotes> bmh: in a strict language, yes
15:00:57 <c_wraith> bmh, you can just use cons for your homework problem
15:01:05 <bmh> c_wraith: get bent.
15:02:01 <wli> bmh: I'd use Data.Sequence
15:02:12 <Gracenotes> bmh: you musts think lazily...
15:02:27 <c_wraith> But anyway.  haskell timing is interesting.  generating a ++ b is O(1), due to laziness.  Iterating over it is O(a + b).  Turns out being lazy has its advantages.
15:03:06 <wli> > (Sequence.><) (Sequence.fromList [1,2]) (Sequence.fromList [3,4])
15:03:07 <ilseman2> @pl  isWanted n = t == (Graph.id n)
15:03:07 <lambdabot> isWanted = (t ==) . Graph.id
15:03:07 <lambdabot>   fromList [1,2,3,4]
15:03:36 <bmh> wli: I don't see an escape from Sequence land
15:03:43 <wli> Not elegant on IRC because you have to qualify the operator.
15:03:55 <wli> bmh: Oh, Data.Foldable.toList
15:04:22 <bmh> wli: http://hackage.haskell.org/packages/archive/containers/0.2.0.0/doc/html/Data-Sequence.html, fromList is there, but not toList
15:04:24 <wli> > Data.Foldable.toList $ (Sequence.><) (Sequence.fromList [1,2]) (Sequence.fromList [3,4])
15:04:25 <lambdabot>   [1,2,3,4]
15:04:27 <bmh> ah
15:04:51 <ilseman2> @pl  isWanted n =  (Graph.id n) == t
15:04:51 <lambdabot> isWanted = (t ==) . Graph.id
15:05:57 <bmh> wli: I'll give that a shot before trying to optimize
15:06:05 <ddarius> > Sequence.fromList [1,2] `mappend` Sequence.fromList [3,4]
15:06:06 <lambdabot>   fromList [1,2,3,4]
15:06:18 <ilseman2> @pl  setParent n = n { _parent = P s }
15:06:19 <lambdabot> (line 1, column 17):
15:06:19 <lambdabot> unexpected "{"
15:06:19 <lambdabot> expecting variable, "(", operator or end of input
15:06:24 <bmh> c_wraith: What I'm doing may sound trivial to you, but I'm writing an alternative to Data.Map and would like it to be efficient.
15:06:47 <c_wraith> bmh: What structure are you basing it on?
15:06:48 <Gracenotes> have you looked at the source of Data.Map.toList?
15:07:23 <bmh> c_wraith: I'm implementing more than one. I have splay trees (an unsuitable replacement) and AVL trees
15:07:24 <wli> bmh: What kind of structure are you using?
15:08:02 <wli> bmh: AVL will be nice in terms of good balancing for fast repetitive lookups.
15:08:37 <bmh> wli: I haven't benchmarked it yet. I got it working on a plane last night
15:08:42 <c_wraith> well, for any BST, the conversion to a list should be the same.
15:08:50 <c_wraith> You can start with the same thing Data.Map does
15:09:10 <c_wraith> Then I suppose you can benchmark other approaches from there
15:09:29 <bmh> wli: I've also implemented binomial heaps and skew heaps
15:09:36 <wli> Someone here actually did a B+ tree lib at some point.
15:09:38 <bmh> I'd like to do pairing heaps, but I think they might be tricky
15:10:14 <Gracenotes> > let !a = a in a
15:10:16 <lambdabot>       Recursive bang-pattern bindings aren't allowed: { !a = a }
15:10:16 <lambdabot>      In the ...
15:10:16 <conal> quicksilver: what's "d.e.s"?
15:10:43 <conal> quicksilver: oh differential-equations?
15:10:51 <wli> I think B* not B+. quicksilver: Was it you?
15:11:22 <bmh> do we have an implementation of unionFind?
15:12:46 <bmh> huh, Data.Map is size balanced. That doesn't seem like a good idea.
15:13:09 <bmh> I wonder why they didn't use AVL or RB trees
15:14:00 <wli> bmh: I've not looked at the implementation but I'm suitably horrified. I'll bet your alternative will trounce it.
15:14:19 <bmh> wli: Don't underestimate my capacity for writing poor code. :)
15:15:03 <quicksilver> wli: b*, yes it was me.
15:15:14 <quicksilver> wli: It's not properly finished, I dont' finish anything :)
15:15:39 <quicksilver> bmh: Bulat wrote an AVL replacement for Data.Map
15:15:42 <quicksilver> I don't know why no one uses it
15:15:53 <quicksilver> conal: yes, as in p.d.e.s and o.d.e.s ;)
15:15:56 <bmh> quicksilver: it isn't in base?
15:15:58 <wli> quicksilver: What was your strategy for dealing with array update nastiness. ST/IO monad all the way through?
15:16:01 <quicksilver> bmh: no.
15:16:08 <bmh> quicksilver: There's your answer.
15:16:14 <quicksilver> wli: something a bit subtle with a type class, I think
15:16:21 <quicksilver> wli: my objective was to be able to test it in pure code.
15:16:35 <quicksilver> wli: something like MonadSeekable m => m () etc.
15:17:19 <p_l> \/act
15:17:26 <bmh> I've been tossing around the idea of writing a min/max heap based on binomial heaps, but I need something like six pointers per node, so I doubt that it's practical
15:17:50 <Baughn> http://rafb.net/p/Z82jNn16.html <-- On a scale from one to ten, how sane is this method of receiving data?
15:18:16 <Steven_M> hi all
15:19:08 <wli> quicksilver: The #1 hit for Bulat AVL Haskell Map is http://markmail.org/message/dhepznk7l7jz27nk
15:19:52 <bmh> I once implement splay trees in C. That was miserable.
15:20:24 <bmh> oh! That's what I should do next -- unordered splay trees
15:21:26 <Eridius> hrm, is there an easier way to remove older versions of packages installed with ghc-pkg then to unregister them one-by-one?
15:21:35 <Eridius> (and making sure to unregister in dependency order)
15:21:45 * Eridius is also reinstalling some packages that depend on older versions
15:21:53 <Eridius> ideally the only package that I'll have installed with multiple versions will be parsec
15:21:58 <Steven_M> do you guys have an ebuild for xmobar-0.9.1, if so where can I find a manifest file for it?
15:22:06 <Eridius> well actually, I don't know if I can get rid of Cabal-1.6.0.1
15:23:13 <wli> I wonder how they benched vs. stock Data.Map
15:23:57 <bmh> wli: good question. It's also application specific. I assume that most people do more lookups than inserts. So AVL will beat out, say RB for that usage
15:24:11 <quicksilver> Baughn: every time you use try + evaluate to catch an exception raised in pure code, god kills a kitten.
15:24:16 <quicksilver> Baughn: or was it SPJ?
15:24:55 <Baughn> quicksilver: I'd appreciate suggestions for better code. ^_^
15:25:19 <Baughn> quicksilver: Actually, what'd happen if it threw an OutOfMemory or ThreadKilled exception in there?
15:26:43 <quicksilver> Baughn: I'm not sure if Binary has a sensible way to recover from errors?
15:26:53 <quicksilver> I've not played with it much.
15:26:58 <Baughn> It does not.
15:27:17 <quicksilver> then I suspect it's not fit for this purpose (parsing untrusted data)
15:27:28 <quicksilver> you can use the 'lower level' of Binary by hand though
15:27:31 <quicksilver> the Get + Put parts
15:27:31 <ddarius> The Binary class isn't really meant for that.
15:27:38 <quicksilver> without actually using the Binary class.
15:28:00 <quicksilver> Binary class is probably only for data guaranteed to be in the correct format.
15:28:09 <ddarius> More or less, yes.
15:28:13 <eric___> I am having trouble with monad transformers: I have the type ErrorT String [] Int and mzero and mplus work over the Error part. Is it possible to get them to work over the  List part? So that runErrorT mzero  is the empty list versus [Left ""].
15:28:28 <Baughn> ddarius: But then I wouldn't be able to use all the pre-defined instances
15:28:40 <Baughn> quicksilver: And there is no such thing
15:28:41 <ddarius> You probably shouldn't be using them.
15:29:04 <Baughn> I shouldn't?
15:29:44 <ddarius> If this is going over a network, it would be more sensible to use a (more) standardized, or at least explicitly defined, format.
15:29:50 <bmh> the documentation for Data.Map lies.
15:30:00 <bmh> er, scratch that
15:30:37 <bmh> jetlag...
15:31:06 <Eridius> eric___: maybe with lift?
15:31:20 <Baughn> ddarius: I suppose then I could use binary-strict, too
15:31:30 <Eridius> > lift mzero :: ErrorT String [] Int
15:31:31 <lambdabot>       No instance for (Show (ErrorT String [] Int))
15:31:31 <lambdabot>        arising from a use...
15:31:34 <Eridius> heh
15:31:40 <Baughn> Oh well. This'll do for testing.
15:31:46 <Eridius> >runErrorT (lift mzero) :: ErrorT String [] Int
15:31:51 <Eridius> and I screwed up my space
15:31:53 <Eridius> > runErrorT (lift mzero) :: ErrorT String [] Int
15:31:54 <lambdabot>   Couldn't match expected type `Int'
15:31:58 <Eridius> heh
15:33:42 <Eridius> > runErrorT (lift mzero) :: forall a. ErrorT String [] a
15:33:43 <lambdabot>   Couldn't match expected type `a2'
15:33:45 <Eridius> heh
15:33:50 <Eridius> > runErrorT (lift mzero) :: ErrorT String [] ()
15:33:51 <lambdabot>   Couldn't match expected type `()'
15:33:53 <Eridius> blah
15:34:13 <Eridius> :t (runErrorT (lift mzero))
15:34:14 <wli> bmh: What did it lie about?
15:34:14 <lambdabot> forall (m :: * -> *) a e. (Error e, MonadPlus m) => m (Either e a)
15:34:43 <Steven_M> does anyone know where I can find a published checksum for xmobar-0.9.1.tar.gz?
15:35:32 <bmh> wli: my brain is addled. I misread a runtime guarantee
15:38:05 <adamvo> Steven_M: google can't find its md5, or sha256, so you probably won't be able to find it
15:38:08 <wli> Data.Tree.AVL seems to already exist and be able to do things.
15:38:34 <bmh> wli: 'eh, two implementations never hurt anyone
15:38:43 <bmh> as long as the interface agrees
15:39:34 <Steven_M> adamvo: ok nevermind
15:45:32 <wli> They don't agree.
15:45:39 <bmh> wli: They will.
15:45:54 <bmh> Stability: Experimental
15:48:06 <wli> Well, people will complain that the API got in the way no matter whether Data.Map or anything else loses.
15:48:23 <bmh> wli: What do you mean?
15:48:55 <defun> How does one go about creating extensions for GHC? Is there documentation somewhere?
15:49:49 <bmh> defun: the answer to your second question is yes. I'm trying to locate it.
15:50:26 <thomastc> is it ok if I ask you ppl for some commentary on my GSoC project proposal?
15:50:58 <bmh> thomastc: it depends on if you view us as competitors or collaborators :)
15:51:08 <wli> bmh: If the benchmark is written to Data.Map's API the Data.Tree.AVL maintainer will complain, if it's written to Data.Tree.AVL's API, mutatis mutandis.
15:51:24 <thomastc> bmh: aren't we all collaborators in the OSS world? ;)
15:51:29 <bmh> wli: oh! He /didn't/ match Data.Map
15:51:55 <bmh> I think that's a poor choice. Like it or not, people use Data.Map and don't want to be buggered to change their code
15:52:23 <defun> thanks.
15:53:20 <eu-prleu-peupeu> are arrays better than lists ? :P
15:53:29 <eu-prleu-peupeu> for random access ?
15:53:35 <NameAlreadyInUse> yes
15:53:36 <|jedai|> defun: You should start by the GHC dev wiki
15:54:08 <jedai> defun: You'll find links towards documents on building and hacking GHC there
15:54:28 <pejo> defun, http://hackage.haskell.org/trac/ghc/
15:55:14 <bmh> oh sweet. I just flew into the heart of a measles epidemic (http://wiki.epfl.ch/rougeole/english)
16:08:01 <wli> One could write a front end to Data.Tree.AVL to match Data.Map
16:08:20 <bmh> wli: That sounds silly.
16:08:27 <opqdonut> why?
16:08:43 <bmh> unnecessary layer of indirection?
16:08:51 <bmh> just fork it and change the API?
16:09:19 <wli> So the same code can be used in a driver using the Data.Map API.
16:09:54 <eu-prleu-peupeu1> is there any way to do findIndex on a array ?
16:10:18 <omnihil> given the standard fibonacci infinite list the list comprehension [ x | x <- fib, x < n ] does not generate a finite list. what's the best way to generate that finite list?
16:10:48 <bmh> take?
16:10:52 <Saizan> omnihil: takeWhile (<n)
16:10:52 <wli> omnihil: take 10
16:10:55 <ddarius> omnihil: It does generate a finite list, it's just the last element is undefined.
16:10:59 <opqdonut> takeWhile is best
16:11:05 <ddarius> But, yes, takeWhile as Saizan said.
16:11:31 <wli> > takeWhile (<100) $ let fs = 0 : 1 : zipWith (+) fs (tail fs)
16:11:32 <lambdabot>   <no location info>: parse error on input `;'
16:11:46 <wli> > takeWhile (<100) $ let fs = 0 : 1 : zipWith (+) fs (tail fs) in fs
16:11:47 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89]
16:11:51 <omnihil> ah takeWhile is the magic I wanted. thanks.
16:12:15 <bmh> if takeWhile is magic, what are Monads?
16:12:26 <omnihil> more magic.
16:12:38 <omnihil> any sufficiently advanced technology is indistinguishable from magic.
16:13:08 <opqdonut> any sufficiently unadvanced magic is indistinguishable from technology
16:14:05 <bmh> any sufficiently indistinguishable from magic is advanced technology?
16:14:40 * wli ponders if grammars could be assembled via GADT's.
16:17:05 <bmh> wli: I think I've decided about what to do with randomized data structures -- prohibit or suggest against merging
16:18:41 <wli> Regexes seem to be able to use them.
16:19:55 <ksf> regexen are indistinguishable from random strings.
16:20:30 <wli> They're assembled via Kleene star, alternation, etc.
16:21:03 <wli> ksf: Such as here: http://haskell.org/haskellwiki/GADT#Parsing_Example
16:22:02 <andun> is it possible to do something like: a = array (1,1) [(1,1), (1, a ! 1 + 1)]?
16:22:27 <wli> Tying the knot through arrays is not only possible but often done.
16:22:35 <ddarius> andun: Sure, except array (1,1) means you only have one element.
16:23:06 <ddarius> :t array
16:23:07 <lambdabot> forall i e. (Ix i) => (i, i) -> [(i, e)] -> Array i e
16:23:16 <andun> ddarius: i know that. it's supposed to be the same as a = [1]; a[0] = a[1] + 1
16:23:54 <andun> err. a[0] = a[0] + 1
16:25:16 <wagle> if a directed acyclic graph is a dag, what is a direced cyclic graph?
16:25:27 <ddarius> > let a = array (1,1) [(1,[]), (1, 'x':(a!1))] in a
16:25:29 <lambdabot>   array (1,1) [(1,"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx...
16:26:20 <ksf> wagle, vanilla-flavoured?
16:26:38 <andun> > let a = array (1,2) [(1,[]), (1, 'x':(a!1)), (2,[])] in a ! 2
16:26:40 <lambdabot>   ""
16:26:42 <andun> neat.
16:26:46 <wagle> not a three letter acronym..  8)
16:27:13 <ddarius> Occasionally DCG is used, but "(directed) graph" already means, potentially, cyclic.
16:27:24 <wagle> at one point I thought up DIG, but i cant remember what it meant
16:27:48 <wagle> yeah, but DCG is hard to say..  8(  8-D
16:28:11 <ddarius> "graph" isn't.
16:28:50 <wagle> well, graph means more than DCG does..  fuzzier/ambiguoius or something
16:28:57 <ksf> vanilla neither.
16:29:03 * ksf opts for vg.
16:29:18 <wagle> vag
16:29:31 <wagle> vang?
16:29:52 <wagle> ding and dag..  ooo
16:30:16 <wagle> sigh
16:30:31 <andun> hm. i though UArray might work since it's strict, but it doesn't look like it does :(
16:31:00 <ddarius> Why would it being strict make you think it would work?
16:31:23 <wli> > let a :: Int -> Array Int Int ; a n = array (0, n) $ (0, 0) : (1, 1) : [(k, let a' = a n ; k' = k `div` 2 in if even k then let s = a' ! k' ; t = a' ! (k' - 1) in s * (s + 2 * t) else let s = a' ! (k' + 1) ; t = a' ! k' in s * s + t * t) | k <- [2 .. n]] in Data.Array.elems $ a 15
16:31:24 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610]
16:31:49 <andun> ddarius: it would work if it "updates" the field as it goes. maybe i have to use IOArray...
16:32:29 <ddarius> andun: All you are essentially doing is defining a value like: let a1 = 'x':a1
16:33:32 <andun> oh, yeah. i'm using the parameter i bind on the outside of array, ufcourse
16:33:47 <wli> There's a Fibonacci problem for you: given a set of indices k, compute fib k for all k in that set of indices while minimizing the number of extra Fibonacci numbers calculated.
16:34:56 <andun> ddarius: i was a bit confused, i thought i had access to the partially constructed array inside the function
16:38:43 <lepassive> How is Haskell compared to Erlang ?
16:38:43 <lambdabot> lepassive: You have 1 new message. '/msg lambdabot @messages' to read it.
16:39:10 <ddarius> lepassive: Learn Haskell.  Learn Erlang.  Decide for yourself.
16:40:06 <lepassive> how can i read the messages? i applied '/msg lambdabot @messages' ?
16:40:38 <wli> There's a general identity for k = m*n+l in terms of the fibs of the m consecutive numbers around and including n.
16:41:45 <wli> That could make the search a little hairier than e.g. addition chain multiplication.
16:45:34 <wli> Hmm. It gets more interesting since you can play around with the m consecutive Fibonacci numbers to break up the interval, squish it down to 2 consecutive fibs, etc.
16:46:09 <wli> I'm stupid and misread the formula. It's in terms of 2 consecutive fibs to begin with.
16:49:58 <Gracenotes> an esoteric language proposal: where the type system is based on Pokemon's type system
16:50:43 <Gracenotes> hm.
16:52:04 <wli> So if they're all m*n+p for various p then the first m Fibonacci numbers and the n-th and (n+1)-th Fibonacci number can generate them.
16:53:29 <wli> So that makes it f([m*n+p|p<-ps]) = m + 2 + f([n,n+1])
16:56:11 <wli> I vaguely suspect something like m = floor (q**(1/3)), n = floor (q**(2/3)) might make sense but am clueless.
17:01:19 <gwern> Gracenotes: so you can cast a Fire Int to a Grass Int, but not the reverse?
17:02:45 <Gracenotes> I'm not sure if I'd allow polymorphism. There must be some mechanism of types interacting with each other, but conversion doesn't seem like a good way to do it.
17:03:14 <gwern> maybe Ghost-types are HOFs, and Fire-type is IO...
17:04:21 <gwern> mm. I just don't see any workable analogy to a reasonably powerful type system
17:05:59 <Gracenotes> not anything predictable, at least. I like the idea of certain flavors of functionality being assigned to certain types, and having them interact with each other.
17:06:32 <ddarius> Perhaps you want to look at effect types.
17:08:42 * Gracenotes looks around for information
17:08:52 <monochrom> everything is a type system
17:09:38 <Gracenotes> "effects abstract side-effects", from a paper called effect systems.. same thing? Similar name, different thing?
17:09:54 <monochrom> that's a right paper
17:12:40 <Gracenotes> "Type and Effect Systems", "Polymorphic effect systems", "Annotated type and effect systems".. mm, I see
17:16:25 <tehgeekmeister> how big can Int get in haskell?  or is it os dependent?
17:16:59 <Gracenotes> > maxBound :: Int
17:17:01 <lambdabot>   9223372036854775807
17:17:17 <pavel_> minBound :: Int
17:17:22 <Gracenotes> > logBase 2 9223372036854775807
17:17:23 <lambdabot>   63.0
17:17:25 <dolio> , maxBound :: Int
17:17:27 <lunabot>  2147483647
17:17:35 <Gracenotes> > logBase 2 2147483647
17:17:36 <lambdabot>   30.999999999328196
17:17:58 <Gracenotes> are effect systems related to monads, in a side-effectful sense?
17:18:18 <tehgeekmeister> hmm, okay
17:18:33 <tehgeekmeister> ints are more than big enough for now.  =P
17:23:44 <Gracenotes> hm. are there any programming languages, academic or otherwise, with effect systems used in types?
17:23:51 <dons> DDC
17:23:53 --- mode: ChanServ set -o dons
17:24:10 <mmorrow> bmh: i only ever use from Data.Map ==> [insert[With'],delete,map,union[With],intersection[With],unions,(whytf is there no isects?),{to,from}List] and those are all i think
17:24:24 <dons> Someone should combine Agda and DDC.
17:24:27 <dons> that'd be nuts
17:24:41 <Gracenotes> what sort of effects does it model?
17:24:41 <wli> I use unionsWith also.
17:24:54 <mmorrow> ooh! i didn't know there was one
17:25:09 <dons> monadic effects
17:25:11 * mmorrow always folds with {union,intersection}With
17:25:30 <wli> And all the mapKeys stuff and all update/adjust/etc. stuff too.
17:25:33 <Gracenotes> dons: in the Haskell sense?
17:25:49 <mmorrow> wli: yeah, i never use any of the key stuff
17:26:35 <dolio> Gracenotes: I'm sure mutable references are one effect.
17:26:42 <dons> http://haskell.org/haskellwiki/DDC/EffectSystem
17:26:59 <dons>     putStr :: String -(!e1)> ()
17:27:00 <dolio> And, for instance, there's no need for map vs. mapM in the language, because map is parameterized by the effect type of the function you pass.
17:27:17 <dolio> Oh, yeah, output too, of course.
17:27:38 <Gracenotes> with an identity (no) effect, I suppose
17:27:41 <dons> imagine all our pure code was in Identity
17:27:50 <Cale> I kind of think that's misleading though.
17:27:57 <Cale> (to say there's no need for mapM)
17:28:09 <dolio> Well, you could also say there's no map.
17:28:14 <sundaymorning> does anyone know where I can find a factor function?
17:28:28 <Cale> What about mapM for the list monad?
17:29:03 <dolio> Well, that's the problem. I don't recall seeing any way to define custom 'effects'.
17:29:19 <dons> :t gcd
17:29:20 <lambdabot> forall a. (Integral a) => a -> a -> a
17:29:36 <Gracenotes> I suppose in an esoteric Pokemon language, I'd allow a dozen or so types of effects
17:31:16 <Gracenotes> :\
17:32:09 <Gracenotes> does seem very similar to Haskell, indeed
17:32:16 <Gracenotes> I'll have to squint to tell the differences..
17:32:32 <mmorrow> @let reachable f a = let go seen a = let s = f a; as = Set.toList (s `Set.difference` seen) in foldl' go (s `Set.union` seen) as in go (Set.singleton a) a
17:32:33 <lambdabot>  <local>:24:50: Not in scope: `Set.toList'
17:32:33 <lambdabot>  
17:32:33 <lambdabot>  <local>:24:64: Not in scope: `S...
17:32:41 <mmorrow> > Set.empty
17:32:42 <lambdabot>   fromList []
17:32:47 <mmorrow> > Set.toList
17:32:48 <lambdabot>       Overlapping instances for Show (S.Set a -> [a])
17:32:49 <lambdabot>        arising from a u...
17:33:01 <Gracenotes> > S.toList (S.fromList [1,2,3])
17:33:02 <lambdabot>   /tmp/5184762007474101327:70:44: Not in scope: `S.toList'/tmp/51847620074741...
17:33:12 * wli manages to cram MonadRWS, MonadCont, and MonadLogic all in the same monad stack.
17:33:17 <mmorrow> i guess @let isn't part of mueval
17:33:42 <mmorrow> or something weird scopewise is happening
17:33:48 <mmorrow> wli: heh
17:33:53 <wli> Well, not RWS, just Reader, Writer, and State all at the same time.
17:34:37 <mmorrow> @let asdfdaqasd = Sequence.viewl
17:34:37 <lambdabot>  <local>:24:13: Not in scope: `Sequence.viewl'
17:36:19 <dons> hmm. so you know how we have a full featured twitter library for haskell
17:36:25 <dons> and a full featured gui library for haskell (gtk2hs)
17:36:34 <dons> why don't we put those together and have a killer app for haskell?
17:36:57 <bmh> dons: you mean constructing guis using twitter, right? :)
17:37:02 <dons> heh
17:37:08 <dons> now THAT'S AN IDEA!
17:37:27 <bmh> speaking of ridiculous things...
17:37:41 <bmh> dons: I'm interested in gsoc
17:37:50 * dons suggests the gsoc channel
17:38:00 <dons> but is too busy at work to talk right now
17:38:04 * dons drops back in the trenches
17:38:09 <bmh> what timezone are you in?
17:38:23 <dons> west coast usa.
17:38:46 <bmh> ah. I'm presently in central european time and my clock is on east coast time. It's disorienting
17:39:42 <RayNbow> bmh: for how long will you stay in Europe?
17:39:58 <RayNbow> (next weekend, DST :p)
17:40:29 <bmh> RayNbow: I was warned about that. Which direction is it moving?
17:40:52 <RayNbow> on Sunday, 2 AM -> 3AM
17:41:03 <bmh> *grumble*
17:41:23 <RayNbow> that means less sleep ;)
17:42:13 <jmcarthur> what is this, daylight savings or something?
17:42:25 <RayNbow> yes
17:42:25 <jmcarthur> i've already gone through this year's "spring forward" :\
17:42:34 <bmh> jmcarthur: who knows. It was still nighttime at 6am.
17:44:09 <RayNbow> bmh, http://www.timeanddate.com/worldclock/clockchange.html?n=87 :)
17:44:33 * wli runs into trouble.
17:44:45 <bmh> I should write a haskell program to set my clock based on my IP address
17:44:56 <bmh> if it's 192.168.*.* it should get set to UTC ;-)
17:46:01 <wli> No instances for (MonadLogic (ContT () (StateT IntSet (WriterT w Logic))), MonadWriter IntSet (ContT () (StateT IntSet (WriterT w Logic))))
17:46:27 <wli> Where'd ReaderT go?
17:49:12 <sundaymorning> no one here has a factoring function he can share?
17:49:44 <dons> :t gcd
17:49:46 <lambdabot> forall a. (Integral a) => a -> a -> a
17:49:46 <dons> build it from that
17:50:13 <bmh> no one here has some money he can share? ;-)
17:50:39 <jmcarthur> for what?
17:51:02 <sundaymorning> well, money is a bit different, if you share it you lose it. If you share code you don't lose it :P
17:51:07 <Gracenotes> hrm...? http://code.haskell.org/ddc/ddc-head/library/Class/Functor.ds
17:51:14 <jmcarthur> oh i missed it, n/m
17:51:40 <jmcarthur> sundaymorning: proprietary nuts beg to differ
17:51:48 <Gracenotes> what noise :/
17:52:34 <Gracenotes> even just Eq, http://code.haskell.org/ddc/ddc-head/library/Class/Eq.ds seems quite complicated
17:54:51 <Gracenotes> @hackage ddc
17:54:51 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/ddc
17:54:56 <Gracenotes> hm.
17:58:09 <Gracenotes> http://code.google.com/p/disciple/issues/list -_-
18:05:50 <Gracenotes> well, doesn't look like I'll be running it anytime soon :\
18:07:27 <Gracenotes> installing haskell-src, what's meant by " The program happy is required but it could not be found"?
18:07:34 <Gracenotes> @hackage happy
18:07:35 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/happy
18:07:42 <wli> Hmm. My exit continuation needs some way to hand back something for observeAllT to use.
18:07:57 <Gracenotes> it's not even a dependency
18:08:03 <Sekaino> Gracenotes, I hadn't run across DDC before.  You know much about it?
18:08:10 <Gracenotes> nothing.
18:08:24 <Gracenotes> I'm looking through a couple of papers on effect systems
18:08:27 <pejo> Gracenotes, cabal-install doesn't install build dependencies automatically. "cabal install happy" should take care of that though. (Make sure to have "happy" in your path too).
18:08:32 <Sekaino> Aha.
18:08:47 <Gracenotes> here's the author: http://cs.anu.edu.au/~Ben.Lippmeier/
18:09:22 <Gracenotes> pejo: installing happy, I get an unbelievable number of error messages :/
18:10:17 <Gracenotes> ah. path. lemme see.
18:10:55 <gwern> Gracenotes: executable deps don't work
18:11:06 <gwern> since executable packages aren't even tracked by cabal/ghc-pkg
18:11:21 <Gracenotes> with happy in current directory, cabal install haskell-src fails spectacularly :(
18:12:03 <Gracenotes> well, I suppose I could give in to even more inconsistency and just install libghc6-haskell-src-dev from apt-get
18:12:23 <Gracenotes> what the hell, I'll have to reinstall everything one day
18:12:46 <pejo> Gracenotes, in current directory? Why not install it as a normal package and have it in your ordinary cabal directory?
18:13:27 <gwern> Gracenotes: wait for 6.10.2 before resintalling at least
18:13:33 <Gracenotes> pejo: it yields an executable, not a lib.
18:14:49 <pejo> Gracenotes, I'm not sure it should work with "." in your path.
18:16:18 <Gracenotes> O_O it would be nice if ddc told me which libraries it'd need instead of making me guess
18:18:00 <Gracenotes> what, it can't find Text.Regex? wha?
18:18:21 <Gracenotes> can you even import that? not Posix or Base?
18:18:37 <Gracenotes> I have a feeling this is old :\
18:20:02 * Gracenotes changes the source
18:20:04 <Steven_M> hi all
18:20:29 <Gracenotes> greetings, Steven_M
18:21:12 <Steven_M> Gracenotes: greatings back :)
18:24:20 <Gracenotes> oh god, I hate these sorts of errors: xvshm.c:36:34: error: X11/extensions/Xvlib.h: No such file or directory
18:24:45 <Nik_89> Gracenotes how come? those are the easiest and most obvious ones heh
18:24:52 <skorpan> i'm quite fond of them to be honest
18:25:18 <Gracenotes> any tips then?
18:25:40 <dridus> I'm under the (perhaps mistaken) impression that in the past when I used :i in GHCi on a typeclass, I got a list of instances that GHCi knew about. Now I don't, does anyone have any helpful hints?
18:25:42 <Gracenotes> I've come across them before. I'm always on the compiling end, not the makefile-making end
18:26:47 <Nik_89> Gracenotes this is from compiling your own code or some other project
18:27:10 <Gracenotes> another project
18:27:19 <Steven_M> I've just downloaded the xmobar-0.9 binary from http://code.haskell.org/~arossato/xmobar/xmobar-0.9.bin, since I had trouble compiling xmobar from source. Is there anywhere I can find a published checksum for the binary?
18:27:30 <Nik_89> Gracenotes look for yourself in /usr/X11R6/include/X11/extensions
18:27:47 <Nik_89> Gracenotes for fun, check if the file Xvlib.h exists there
18:28:14 <Gracenotes> only bin exists in /usr/X11R6
18:28:46 <Nik_89> Gracenotes whats your OS?
18:28:51 <wli> I'm having trouble unraveling this monad stack.
18:28:53 <Gracenotes> Ubuntu. :\
18:28:58 <Nik_89> Gracenotes ah
18:29:19 <Nik_89> Gracenotes my guess is you need to go into synaptic and install the dev package for X11
18:29:32 <Gracenotes> got it, libxv-dev
18:29:41 <Gracenotes> except I'd no idea it was in /usr/X11R6
18:29:50 <Gracenotes> the aforementioned 'couldn't find' directory
18:30:00 <Nik_89> Gracenotes yes, thats the standard path
18:30:10 <Nik_89> Gracenotes although ubuntu changes the rule some heh
18:30:17 <Gracenotes> for all X11-related items? or libraries in general?
18:30:27 <Nik_89> Gracenotes only for X11 related
18:30:54 <Nik_89> Gracenotes I think ubuntu puts the X11 files into /usr itself
18:31:08 <Nik_89> Gracenotes look for /usr/include/X11
18:31:08 <Steven_M> bye all
18:31:19 <dridus> cya steven_m
18:31:50 <Steven_M> dridus: see ya
18:32:45 <Gracenotes> Nik_89: it's there.. should I create a symlink from /usr/X11R6 to there?
18:33:00 <Nik_89> Gracenotes check further into it
18:33:12 <Nik_89> Gracenotes look in extensions
18:33:29 <Nik_89> Gracenotes hopefully the Xvlib.h file is present
18:33:32 <Gracenotes> no, I mean I found /Xvlib.h
18:33:40 <Nik_89> Gracenotes where?
18:33:57 <Gracenotes> but should I make a link from /usr/include/X11/extensions/Xvlib.h
18:34:03 <Gracenotes> erm.
18:34:08 <Gracenotes> wrong answer
18:34:18 <Gracenotes> but that's the path
18:34:43 <Nik_89> Gracenotes link /usr/include to /usr/X11R6/include
18:34:56 <Nik_89> Gracenotes or X11R6 to /usr
18:35:04 <pejo> No, don't make links. When build scripts can't find your include files it's the scripts that are wrong, not your installation.
18:35:07 <Nik_89> Gracenotes (the latter is the standard ubuntu way)
18:35:29 <Gracenotes> pejo: okay, I'd do that if I had make-fu
18:35:31 <Gracenotes> :\
18:35:42 <pejo> Nik, why doesn't ubuntu do that link if it's the standard way?
18:36:13 <Nik_89> pejo it probably happened after he installed some packages
18:36:37 <Nik_89> nevertheless, ubuntu normally has /usr/X11R6 a link to /usr
18:37:00 <Nik_89> if its not the case, its not the project which is non standard
18:37:37 <p_l> well, /usr/X11Rx is standard...
18:38:48 * Gracenotes hasn't dealt with development on a distro scale terribly much
18:39:16 <wli> MonadLogic doesn't seem to have a whole lot of lifting instances.
18:39:22 <Nik_89> p_l this is totally true :) but ubuntu organised their architecture so all which is inside /usr/X11R6 is placed in /usr instead and create a link /usr/X11R6 which points to /usr
18:39:50 <p_l> well, many do that, seems common with the new autobroken^Wimproved build system
18:40:10 <centrinia> What does (fmap fmap fmap) do?
18:42:13 <dolio> The first fmap is (.).
18:42:19 <adamvo> :t fmap fmap fmap
18:42:20 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
18:43:05 <wli> There's something screwy about LogicT on monad transformer stacks.
18:43:54 <wli> No instances for (MonadWriter IntSet (ContT () (WriterT w (StateT IntSet Logic))), MonadLogic (ContT () (WriterT w (StateT IntSet Logic))))
18:44:19 <centrinia> I saw (fmap fmap fmap) mentioned in The Typeclassopedia. Is it actually used anywhere else?
18:44:30 <dons> hehe
18:44:34 <dons> i think xmonad might ...
18:44:40 <ddarius> centrinia: It shouldn't be.
18:44:53 <adamvo> :t (fmap . fmap . fmap)
18:44:54 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f2, Functor f1, Functor f) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
18:44:55 <dons> runLayout (Workspace i (Layout l) ms) r = fmap (fmap Layout) `fmap` runLayout (Workspace i l ms) r
18:45:18 <dons>  return $ fmap (map (toEnum . fromIntegral)) md
18:45:25 <ddarius> centrinia: fmap fmap fmap is just a more obfuscated (and longer) way to write fmap . fmap.
18:45:38 <dons> yeah, i hope:  fmap fmap fmap
18:45:40 <dons> is not used.
18:46:35 <Nik_89> dons I have a question for you :) I'm using your latest hs-plugins and I'd like to know how/if its possible to reload a script which was already loaded. The static binary continually loops forever and my current code compiles the new dynamic script but it still behave like the old version until I restart the binary.
18:46:40 <ddarius> fmap: Because getting functions to the values is half the battle.
18:48:57 <dons> Nik_89: should be possible using 'reload' , yes.
18:49:33 <Nik_89> dons yes, I thought of using it but the issue here is how exactly I can figure if a script was rebuilt or not
18:50:06 <Nik_89> dons as my implementation goes over the make code whenever its calling the function
18:51:08 <sebaseba> @remember ddarius fmap: Because getting functions to the values is half the battle.
18:51:08 <lambdabot> Nice!
18:52:04 <mmorrow> dridus: ghci can only see the instances currently in-scope
18:53:23 <dridus> mmorrow: yeah, I think the issue I'm running into is that something got into my scope in a previous session without my intent and now it's not
18:53:32 <mmorrow> is the other half getting the values to the functions?
18:53:49 <mmorrow> dridus: i think that's most likely
18:54:21 <mmorrow> dridus: you probably got the instance(s) through another module that re-exported them
18:54:37 <wli> Okay, nondeterminism vs. deep monad transformer stacks is confusing.
18:54:45 <dridus> mmorrow: now the only problem of course, is to find out where and what ;-)
18:54:46 <mmorrow> err, or actually you don't have to re-export instance
18:54:47 <mmorrow> s
18:54:50 <mmorrow> (?)
18:55:00 <dridus> 'tis automatic, isn't it?
18:56:28 <dridus> mmorrow: you're exactly right in this case, I had Control.Arrow in scope, which brought in instances from Control.Monad.Instances
18:56:55 <mmorrow> ah, were you looking for instance Functor ((,)a) by chance?
18:57:19 <mmorrow> (seems to always be being looked for ;)
18:57:38 <wli> observeAllT . execWriterT isn't the trouble in there.
18:57:54 <dridus> haha no, in this case I was looking for Monad ((->) a). I asked lambdabot for pointfree version of \ f x -> f x x, and it said join
18:58:01 <dridus> which caused me a bit of the ol' brain explodey
18:58:05 <mmorrow> ah, that one too :)
18:58:33 <dridus> in the aftermath of my neurons all on the floor, I apparently ceased to be able to read properly and made broad accusations about my GHCi's behavior
18:58:35 <dridus> and here we are
18:59:31 <centrinia> @pl \f x -> f x x
18:59:31 <lambdabot> join
18:59:51 <dridus> it's a trap!
19:00:20 <ddarius> @quote trappe
19:00:21 <lambdabot> qwe1234 says: good lord, help me. i feel like i'm trapped in a website full of elizabots.
19:00:29 <ddarius> @quote sprynge
19:00:30 <lambdabot> Cale says: Beware of the function [a] -> a. For it may contain trappes and sprynges of great variety and harm.
19:01:02 <dridus> the haskell community has, perhaps, the most hilariously geeky humor I have ever been exposed to
19:01:18 <dridus> and my parents didn't slack attempting to make sure I was properly raised in that area
19:02:12 <p_l> dridus: I was warned that haskell is taken over by 4chan visitors, so...
19:02:37 <p_l> (similar thing happens in #gsoc O_O)
19:03:06 <dridus> p_l: I'm not a 4chan visitor, the closest is that I could probably play an extra one on TV
19:03:54 <p_l> dridus: Can't help but notice how the memes have appeared here. Also, last discussion about incest was hilarious :D
19:04:12 <dridus> p_l: tail recursion?
19:04:43 <p_l> dridus: it started with timezones, but tailcalls would be interesting too...
19:05:46 <dridus> p_l: I uh, don't think I want to know any more. Ignorance may not be bliss, but it certainly isn't as disturbing
19:06:17 <wli> There's no MonadWriter instance for MonadCont as the interior monad.
19:06:35 <dolio> You can't make one, because of pass.
19:07:09 <dolio> At least, not one that works as expected.
19:07:53 <dolio> You mean MonadWriter w m => MonadWriter w (ContT r m), right?
19:09:14 <wli> Yeah.
19:09:34 <dridus> alright next dumb question, what's the super general category theory way of mapping a function over all values of a tuple (a,a), (a,a,a), ...?
19:10:23 <centrinia> dridus, why don't you just use [a] ?
19:11:06 <dridus> centrinia: seems like overkill? I really only ever want to have two values (or three values)
19:11:49 <wli> Couldn't match expected type `ReaderT (ContT () (StateT IntSet Logic) b) (ContT () (StateT IntSet Logic)) ()' against inferred type `ContT () (StateT IntSet Logic) b'
19:12:33 <centrinia> I guess you can compose the product functor with whatever you want to map over the values in the tuple.
19:13:27 <ddarius> (a,a) ~ Bool -> a
19:15:24 <dridus> centrinia: okay, I grepped around a little and asked GHCi some questions but I can't find what product functor you're talking about?
19:16:25 <centrinia> dridus, I read about products in a category theory textbook.
19:16:27 <Gracenotes> is there a list of compilers written in Haskell?
19:16:44 <ddarius> Gracenotes: The list of implementations of Haskell.
19:17:34 <centrinia> http://haskell.org/haskellwiki/Applications_and_libraries/Compilers_and_interpreters
19:17:38 <Gracenotes> it seems DDC's compiler was written in Haskell
19:18:17 <Gracenotes> thanks, centrinia
19:18:31 <centrinia> Sure.
19:18:35 <ddarius> As far as I know, Hugs is written in C (but it is an interpreter) and there was a compiler written in Common Lisp.  Every other implementation was written in Haskell except for bootstrapping versions.
19:18:45 <defun> :t (++)
19:18:46 <lambdabot> forall a. [a] -> [a] -> [a]
19:18:52 <defun> :t (:)
19:18:53 <lambdabot> forall a. a -> [a] -> [a]
19:19:02 <Gracenotes> ah, okay
19:19:36 * wli loses the nondeterminism vs. state and all the other monads battle.
19:20:09 <pejo> Gracenotes, compilers that compile other languages than Haskell?
19:21:17 <Gracenotes> compilers written largely in Haskell that compile a language, Haskell or not, although the latter would be more interesting.
19:23:33 <centrinia> Oh yeah, Pugs is written in Haskell. :)
19:24:38 <jmcarthur> Agda, Epigram
19:24:40 <MarcWeber> There is also a write yourself a scheme in XX hours tutorial. But the more a howto do it than a final production ready interpreter
19:25:38 <centrinia> Read You a LISP for Good Great. :D
19:26:27 <mmorrow> Gracenotes: timber-lang.org
19:26:34 <pejo> Gracenotes, there's a compiler and compiler/interpreter section on hackage.
19:26:43 <rovar> timber is looking pretty awesome
19:26:59 <goomba`> that scheme tutorial turns into alot of work if you keep up support for the extra stuff in the exercises
19:27:13 <pejo> What is Cryptol written in, or is that a secret?
19:27:48 <sundaymorning> is the function Data.List.permutation not present in ghc 6.8.2?
19:27:50 <mmorrow> yeah, i like the reactive/graph-of-autonomous-units/whatever aspect of timber
19:28:02 <centrinia> :t permutation
19:28:03 <lambdabot> Not in scope: `permutation'
19:28:12 <centrinia> :t permutations
19:28:13 <lambdabot> Not in scope: `permutations'
19:28:27 <sundaymorning> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html#v%3Apermutations
19:28:31 <sundaymorning> where is that function at?
19:28:56 <dridus> centrinia: well, I think I might be getting where you going with that, but I think I'm going to need to train up my ability to reason about abstract nonsense before I have any clue how to pull it off... thanks for the pointer though
19:29:02 <mmorrow> pejo: the galois cryptol compiler is in haskell (at least most of from the looks of the objdump output..)
19:29:20 <centrinia> Hmm, I can't find Data.List.permutations in my GHC 6.8.2 distribution either. :(
19:29:36 <centrinia> dridus, Just use Lists.
19:29:54 <dridus> centrinia: never!
19:30:08 <Gracenotes> sorry, pejo, lost my connection. My experiences with it have led me to believe more and more the theory of internet tubes :/
19:30:11 <Gracenotes> +in
19:31:07 <lispy> Hello #Haskell!!
19:31:16 <dons> hmm.
19:31:28 <sundaymorning> if I could copy its code from somewhere
19:32:29 <sundaymorning> I guess I should download the full ghc source and look for it
19:33:30 <dons> are modifyIORef and atomicModifyIORef "broken" wrt. strict updates?
19:34:13 <dons> e.g. is there any way to make this run in constant space, without modifying modifyIORef's implementation?
19:34:16 <dons>   
19:34:19 <dons>   main = do
19:34:21 <dons>     modifyIORef ref $! \a ->
19:34:24 <dons>         let b = a + 1 in b `seq` b
19:34:26 <dons>     main
19:34:32 <dons>     main = modifyIORef ref (\a -> let b = a + 1 in b)i >> main
19:34:34 <dons> i mean.
19:36:21 <ddarius> There's an ugly way.
19:36:47 <centrinia> > let permutations [] = [[]]; permutations (x:xs) = [(\(y1,y2) -> y1 ++ [x] ++ y2) (splitAt i ys) | ys <- permutations xs, i <- [0..length xs]] in permutations [1..4]
19:36:48 <lambdabot>   [[1,2,3,4],[2,1,3,4],[2,3,1,4],[2,3,4,1],[1,3,2,4],[3,1,2,4],[3,2,1,4],[3,2...
19:36:54 <ddarius> @hoogle permutations
19:36:54 <lambdabot> No results found
19:36:54 <centrinia> > let permutations [] = [[]]; permutations (x:xs) = [(\(y1,y2) -> y1 ++ [x] ++ y2) (splitAt i ys) | ys <- permutations xs, i <- [0..length xs]] in permutations [1..3]
19:36:56 <lambdabot>   [[1,2,3],[2,1,3],[2,3,1],[1,3,2],[3,1,2],[3,2,1]]
19:37:20 <ddarius> centrinia: permutations is in Data.List or somewhere in the most recent release of base.
19:37:20 <dons> ddarius: what's the ugly way?
19:37:34 <dons> i might be tired, but e.g. strict boxes were about all I could think of, which don't work.
19:38:06 <wli> Might be a good idea to convert to a sequence before trying to splitAt like that.
19:38:36 <centrinia> wli, It is already O(n!)
19:38:47 <ddarius> modifyIORefStrict ref f = do res <- modifyIORef ref f; tmp <- readIORef; tmp `seq` return res
19:38:50 <ddarius> :t modifyIORef
19:38:51 <lambdabot> Not in scope: `modifyIORef'
19:38:55 <dons> ddarius: hmm
19:38:57 <ddarius> @hoogle modifyIORef
19:38:57 <lambdabot> Data.IORef modifyIORef :: IORef a -> (a -> a) -> IO ()
19:38:57 <lambdabot> Data.IORef atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b
19:39:02 <dons> that's nto a bad idea.
19:39:02 <centrinia> I don't think that converting to a sequence would really improve the asymptotic performance of it. :p
19:39:06 <ddarius> drop the res stuff
19:39:10 <dons> but we should have these by-default be strict prob.
19:39:22 <ddarius> dons: I agree (I believe)
19:39:32 <dons> I did the same for MVars a couple of years ago
19:39:38 <dons> otherwise modifyMVar is useless
19:39:59 <ddarius> The question is: is the use case for a lazy modifyFoo common?
19:40:05 <ddarius> s/the/a
19:40:19 <wli> centrinia: Well, actually, add it all up. The quadratic splitAt stuff will get you at least n!^2 or maybe something worse.
19:40:29 <centrinia> Hmm.
19:41:17 <wli> Maybe a zipper can dodge that bullet.
19:41:38 <wli> But I doubt it.
19:42:15 <dons> ddarius: nice idea, btw.
19:42:26 <ddarius> dons: It's ugly.
19:42:33 <dons> yep
19:42:35 <dons> suxors
19:42:45 <dons> i'm going to patch the 'modify' things in base, I reckon.
19:42:52 <dons> main = do modifyIORef ref (\a -> a + 1) !r <- readIORef ref -- BAM! main
19:43:09 <rovar> dons just turned it up a notch
19:43:58 <dons> ddarius says ugly. i say stupid.
19:44:43 <ddarius> dons: We need to go through the entire set of commonly used libraries and choose sane defaults/behavior for strictness.
19:45:07 <dons> yes.
19:52:26 <whome> hello
19:52:35 <dridus> hi
19:52:48 <whome> new to haskell, tried several books
19:52:51 <whome> and Im lost
19:53:35 <steveklabnik> whome: anything in particular, or just in general?
19:53:45 <whome> so I have a semi ordered list of categoriers and members
19:53:47 <whome> in the form
19:53:59 <whome> (where capitals represent categories)
19:54:37 <whome> [X,a,s,d,Y,v,b,n,X,u,i,Y,o,p]
19:55:21 <whome> i need to break this list into individual lists of distinct categories and members
19:55:57 <whome> in the form [[X,a,s,d,u,i] [Y,v,b,n,o,p]]
19:55:57 <jmcarthur> @hoogle (a -> Bool) -> [a] -> ([a], [a])
19:55:57 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
19:55:57 <lambdabot> Prelude span :: (a -> Bool) -> [a] -> ([a], [a])
19:55:57 <lambdabot> Data.List break :: (a -> Bool) -> [a] -> ([a], [a])
19:56:04 <jmcarthur> oh
19:56:24 <jmcarthur> now i see
19:56:28 <rovar> which bot in here stores definitions?
19:56:55 <rovar> as in: I can associate a name with a value
19:57:07 <rovar> where value is a url
19:58:12 <jmcarthur> whome: maybe it would be good to look into something like Data.Map? Do something like Map Category [Member] or something?
19:58:31 <whome> Ill try
19:58:36 <jmcarthur> with that structure chosen, it may be easier to come up with an appropriate algorithm
19:59:06 <jmcarthur> and once the map is populated, it would be easier to convert it back into that final list form you want (unless the Map is good enough for you)
19:59:18 <ddarius> :t assocs
19:59:19 <lambdabot> forall i e. (Ix i) => Array i e -> [(i, e)]
19:59:22 <newsham> > let spanWord (x:xs) = let (s,r) = span isLower xs in ((x,s),r) in unfoldUntil null spanWord "FooBarBlah"
19:59:23 <lambdabot>   [('F',"oo"),('B',"ar"),('B',"lah")]
19:59:42 <ddarius> newsham: Look at accumArray
20:00:21 <whome> I see
20:00:27 <whome> thank you
20:00:44 <jmcarthur> :t unfoldUntil
20:00:45 <lambdabot> forall b a. (b -> Bool) -> (b -> (a, b)) -> b -> [a]
20:00:59 <jmcarthur> i've used unfold, never unfoldUntil
20:01:12 <ddarius> @hoogle unfoldUntil
20:01:12 <lambdabot> No results found
20:01:12 <newsham> unfoldUntil p f = unfoldr (\x -> guard (not (p x)) >> return (f x))
20:01:17 <ddarius> jmcarthur: That's because it doesn't exist.
20:01:26 <jmcarthur> oh
20:02:03 <jmcarthur> darn, it looks useful
20:02:20 <ddarius> jmcarthur: It's just a different presentation of unfoldr that's often more intuitive.
20:03:48 <newsham> ddarius: whats your accumArray soln?
20:04:29 <ddarius> newsham: I haven't made one, I just think it would be easy.
20:04:31 <ddarius> :t accumArray
20:04:33 <lambdabot> forall e a i. (Ix i) => (e -> a -> e) -> e -> (i, i) -> [(i, a)] -> Array i e
20:07:33 <ddarius> Actually, you'd have to "spread" the categories at which point you might as well use groupBy.
20:07:57 <ddarius> (Well, there'd still be some benefit.)
20:10:32 <ddarius> > foldr (\c cs cat -> if isUpper c then cs c else c:cs cat) (const []) "FooBarBlah" undefined
20:10:33 <lambdabot>   "ooarlah"
20:10:47 <ddarius> > foldr (\c cs cat -> if isUpper c then cs c else (cat,c):cs cat) (const []) "FooBarBlah" undefined
20:10:48 <lambdabot>   [('F','o'),('F','o'),('B','a'),('B','r'),('B','l'),('B','a'),('B','h')]
20:11:22 <ddarius> > accumArray (flip (:)) [] (chr 0, chr 255) $ foldr (\c cs cat -> if isUpper c then cs c else (cat,c):cs cat) (const []) "FooBarBlah" undefined
20:11:24 <lambdabot>   array ('\NUL','\255') [('\NUL',""),('\SOH',""),('\STX',""),('\ETX',""),('\E...
20:11:39 <gwern> @wn doux
20:11:42 <lambdabot> No match for "doux".
20:12:03 <gwern> I keep trying to think of a pronunciation for 'doux' that doesn't sound like 'douche'...
20:12:53 <FunctorSalad> "do"?
20:13:12 <gwern> hm, a silent x. That's possible
20:13:31 <FunctorSalad> I have no clue actually :)
20:14:05 <rovar> deaux
20:14:24 <FunctorSalad> ah that would be my other guess ;0
20:15:03 <ddarius> > uncurry (:) $ filter (not . null . snd) $ assocs $ accumArray (flip (:)) [] (chr 0, chr 255) $ foldr (\c cs cat -> if isUpper c then cs c else (cat,c):cs cat) (const []) "FooBarBlah" undefined
20:15:04 <lambdabot>   Couldn't match expected type `(a, [a])'
20:15:23 <ddarius> > concatMap (uncurry (:)) $ filter (not . null . snd) $ assocs $ accumArray (flip (:)) [] (chr 0, chr 255) $ foldr (\c cs cat -> if isUpper c then cs c else (cat,c):cs cat) (const []) "FooBarBlah" undefined
20:15:24 <lambdabot>   "BhalraFoo"
20:20:05 <ddarius> > sortBy (const $ const True) "astoehastbualroeridarth"
20:20:06 <lambdabot>   Couldn't match expected type `Ordering'
20:20:12 <ddarius> > sortBy (const $ const EQ) "astoehastbualroeridarth"
20:20:14 <lambdabot>   "astoehastbualroeridarth"
20:22:37 <ddarius> > concatMap (uncurry (:)) $ sortBy (comparing fst) $ foldr (\c cs cat -> if isUpper c then cs c else (cat,c):cs cat) (const []) "FooBarBlah" undefined
20:22:38 <lambdabot>   Couldn't match expected type `[Char]' against inferred type `Char'
21:19:32 <dolio> > foldl (\a b -> a + b) 1 [1..5]
21:19:34 <lambdabot>   16
21:23:29 <QtPlaty[Hireme]> dolio: Doesn't that get one more then you want?
21:23:54 <QtPlaty[Hireme]> > foldl (\a b -> a + b) 0 [1..5]
21:23:56 <lambdabot>   15
21:24:12 <dolio> Considering the place I took it from said it was a method of computing the nth fibonacci number, I don't think 1 vs 0 is the biggest problem. :)
21:24:35 * QtPlaty[Hireme] laughs.
21:25:33 <SubStack> @pl (\x -> mapM ($ x) [putStrLn])
21:25:33 <lambdabot> flip mapM [putStrLn] . flip id
21:25:41 <SubStack> hmmm
21:25:58 <SubStack> @pl (\x -> mapM_ ($ x) [putStrLn])
21:25:58 <lambdabot> flip mapM_ [putStrLn] . flip id
21:26:40 <SubStack> @pl (\x -> forM_ [putStrLn] ($ x))
21:26:41 <lambdabot> forM_ [putStrLn] . flip id
21:37:00 <SubStack> @pl (\x y -> map (($ x) . ($ y)) [(+), (-), (*)])
21:37:00 <lambdabot> flip flip [(+), (-), (*)] . (map .) . flip (flip . flip id)
21:38:34 <SubStack> @pl (\x y z -> map (($ x) . ($ y) . ($ z)) [(\a b c -> a * b + c)])
21:38:34 <lambdabot> flip flip [((+) .) . (*)] . ((flip . (map .)) .) . (. flip (flip . flip id)) . (.) . flip flip
21:52:01 <Gracenotes> x.-.x
21:52:41 <kadaver> .x+x.
21:52:53 <psygnisfive> what are you doing, inventing new emoticons?
21:54:18 <jfredett> ... somehow I need to write a function which prints the structure it's a part of...
21:54:42 <jfredett> specifically, it's an IO ().
21:55:26 <Gracenotes> \*\_/*/
21:55:45 * jfredett ponders
21:56:17 <psygnisfive> \*\_/*/ is the function you're looking for jfredett
21:56:35 <jfredett> ...
22:04:00 <lispy> jfredett: what do you mean by struture?
22:05:32 <jfredett> literally, a datastructure. Basically, I'm wrapping up a bunch of IO actions in a structure, and associating them with names and descriptions, to abstract over command line arguments
22:06:08 <lispy> jfredett: have you ever looked at the getopt library?
22:06:13 <jfredett> The notion is that the user would provide a structure which gives a specification of the possible arguments to the command line, and actions to take wrt to them, and this handles the rest.
22:06:21 <jfredett> lispy: is that what I'm reinventing? sonova...
22:06:34 <lispy> jfredett: Well, getopt just parses command lines
22:06:44 <jfredett> lispy: is that for haskell or something else?
22:06:55 <jfredett> lispy: right- the punchline of which is getArgs, oui?
22:07:00 <lispy> jfredett: it's for something else (C/Unix) but it has a Haskell binding.
22:07:10 <jfredett> @where getopt
22:07:10 <lambdabot> I know nothing about getopt.
22:07:26 <lispy> http://cvs.haskell.org/Hugs/pages/libraries/base/System-Console-GetOpt.html
22:07:33 <lispy> That url mayb e out of date
22:07:34 <jfredett> found it.
22:07:36 <lispy> But, that is the library
22:08:05 <lispy> jfredett: Darcs is the only haskell program I know off the top of my head that uses it
22:08:15 <lispy> jfredett: so you can look there for examples
22:08:15 <jfredett> right, so my idea was to go a bit higher level...
22:08:19 <jfredett> but thats interesting
22:08:51 <jfredett> but this will save me from having to do parsing... I can just build on top of this.
22:09:11 <lispy> nice
22:09:16 <lispy> good luck
22:09:48 <jfredett> still, my problem remains, how can I make a self referential function... perhaps if I do some kind of record wrapper...
22:10:30 <jfredett> the goal is to be able to automate the --help flag.
22:20:16 <Cale> http://www.youtube.com/watch?v=gEyFH-a-XoQ :)
23:15:17 <pragma_> a`
23:18:16 <Mr_Giraffe> :t (\*\_/*/)
23:18:17 <lambdabot> parse error on input `)'
23:18:28 <Mr_Giraffe> :t (\\*\\_/*/)
23:18:29 <lambdabot> parse error on input `)'
