00:24:07 <wli> mmorrow: Would something like tracking definitions vs. uses come up for detecting mutual recursion?
00:26:26 <wli> Tabulate variables by names and subexpressions defining them, then associate the set of subexpressions using them with those pairs?
00:27:27 <wli> I think this need only be lexical.
00:31:10 <mmorrow> you'd use SCCs for mutual recursion
00:31:47 <wli> Well, yes, you eventually do SCC's on the graph computed from that.
00:32:21 <mmorrow> you can just take freeVars of bindings, then assoc them with their bound var to get a [(Id, [Id])]
00:32:46 <mmorrow> then scc :: [(a, [a])] -> [[a]]
00:33:44 <wli> What are the meanings of fst and snd?
00:34:20 <p_l> wli: first and second? (car and cdr?)
00:35:53 <mmorrow> wli: here's my scc code http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1918#a1918
00:37:42 <wli> I'm a few steps behind there where I'm trying to get the info to compute the SCC's on (and maybe other computations).
00:39:30 <mmorrow> wli: fst and snd in [(a, [a])] did you mean?
00:39:38 <wli> yeah
00:39:52 <mmorrow> it's an adjacency list rep of a graph
00:41:00 <mmorrow> @type (maybe undefined id .) . flip lookup
00:41:01 <lambdabot> forall a b. (Eq a) => [(a, b)] -> a -> b
00:41:29 <mmorrow> @type (maybe [] id .) . flip lookup :: (a -> [a])
00:41:29 <lambdabot>     Couldn't match expected type `[a]'
00:41:29 <lambdabot>            against inferred type `a2 -> [a1]'
00:41:29 <lambdabot>     Probable cause: `.' is applied to too few arguments
00:41:38 <mmorrow> @type (maybe [] id .) . flip lookup :: [(a, [a])] -> (a -> [a])
00:41:40 <lambdabot>     Could not deduce (Eq a) from the context ()
00:41:40 <lambdabot>       arising from a use of `lookup' at <interactive>:1:23-28
00:41:40 <lambdabot>     Possible fix:
00:41:44 <mmorrow> @type (maybe [] id .) . flip lookup :: (Eq a) => [(a, [a])] -> (a -> [a])
00:41:45 <lambdabot> forall a. (Eq a) => [(a, [a])] -> a -> [a]
00:42:09 <wli> The Id key stands for what? Under what conditions does an Id appear in the list in the right element of the pair?
00:42:15 <mmorrow> so you can use that to feed the graph to any function that happens to use a (a -> [a]) rep for the input graph
00:42:42 <mmorrow> wli: oh, the Id i meant to be some type used for variable names
00:42:57 <mmorrow> , VarE ?n
00:43:17 <mmorrow> lunabots split
00:43:37 <mmorrow> it's handy to define
00:43:46 <mmorrow> (!) = (maybe [] id .) . flip lookup :: (Eq a) => [(a, [a])] -> (a -> [a])
00:44:15 <wli> My plot at the moment is the following:
00:44:17 <wli> resVars :: IntMap (ExprInt con lab var) -> (IntMap (ExprInt con lab Int), IntMap var, Map var Int, IntMap (Int, IntSet))
00:44:18 <mmorrow> preds = (g!)
00:45:40 <wli> This gives each variable a unique name, assembles translation tables back and forth from names to whatever, and gives the defining subexpression and using subexpressions.
00:45:59 <mmorrow> wli: cool. i bet you could apply some various standard graph algos and pull out some interesting info
00:46:23 <wli> I've not written the function yet. :)
00:46:44 <wli> Maybe better is resVars :: IntMap (ExprInt con lab var) -> (IntMap (ExprInt con lab Int), Map (Int, var) Int, IntMap (Int, var, IntSet))
00:47:04 <mmorrow> wli: i'd prbably make a datatype to the result type of that
00:47:17 <wli> Where the key of the Map is the subexpression in which it appears and the name.
00:47:19 <mmorrow> it'd probably ease a lot of pain
00:47:37 <mmorrow> s/to/for/
00:47:54 <wli> I don't believe that's where the pain is.
00:50:48 <mmorrow> heh
00:52:00 <wli> I don't think the Map is useful.
00:57:52 <wli> resVars :: IntMap (ExprInt con lab var) -> (IntMap (ExprInt con lab Int {- unique lexical ID -}),  IntMap (Int {- def site -}, var {- original name -}, IntSet {- use sites -}))
00:58:11 <kohwj> i'm trying to write a .cabal file for an app that uses gtk2hs, but "build-depends: gtk" and "cabal build" gives an error about gtk2hs being hidden
00:59:33 <Saizan_> kohwj: what's the exact error?
00:59:51 <kohwj> Could not find module `Graphics.UI.Gtk.Gdk.Events':      it is a member of package gtk-0.10.0, which is hidden
01:00:18 <Saizan_> you need to rerun cabal configure, maybe?
01:00:27 <kohwj> Saizan_: i did
01:00:50 <Saizan_> where did you put the build-depends field?
01:01:08 <Saizan_> you should have it in the Executable stanza
01:01:14 <wli> Do ReaderT and StateT commute? I completely forget.
01:01:32 * kohwj hugs Saizan_
01:01:51 <kohwj> Saizan_: haha, i got it. thanks!
01:01:54 <Saizan_> wli: afaiu they do
01:02:11 <Saizan_> kohwj: np
01:16:47 <cjs> So if I have a function typed "Monad m => [WMDatum] -> m MessageName", how can I generate a type synonym Foo a that will let me type that function "Foo MessageName"?
01:17:25 <yitz> type Foo a = [WMDatum] -> m a
01:17:35 <yitz> oops Monad m =>
01:18:00 <cjs> You mean like this? "type WMDLookup' a = Monad m => [WMDatum] -> m a"
01:18:39 <cjs> For that I get an "Illegal polymorphic or qualified type" error. It suggests I might want to use -XRank2Types, but I'm not clear on whether I really want to do that.
01:18:50 <cjs> Or do I just have the syntax wrong?
01:20:22 <yitz> so you'd have to write Monad m => Foo m MessageName
01:20:48 <yitz> a rank 2 type might be useful for you, but that is a different type
01:21:07 <yitz> type Foo m a = [WMDatum] -> m a
01:21:26 <cjs> Ok....
01:22:32 <cjs> Hm. So there's no way to get that (Monad m) qualification into the type declaration?
01:22:46 <yitz> no. just checked that in the report.
01:22:58 <yitz> only a newtype or a data.
01:23:11 <cjs> Hm. I was thinking I might need a newtype.
01:23:13 <yitz> and it's usually wrong to use them there, too.
01:24:02 <cjs> How would I do it with a newtype?
01:24:43 <yitz> newtype Foo m a = Foo ([WMDatum] -> m a)
01:25:02 <yitz> you could put in the class restraint, but it doesn't gain you anything.
01:25:26 <yitz> also, the newtype then requires you to wrap/unwrap everything with the constructor.
01:25:39 <cjs> Yeah, that's very annoying.
01:26:21 <yitz> the main use of newtype is if you need several different instances of a class for the same type.
01:26:41 <yitz> well, other uses also I guess
01:27:27 <cjs> Oh, I'd not thought about that use of it before. Cool.
01:27:41 <yitz> you use it instead of data when there is only one constructer and extra strictness is good for you.
01:28:50 <yitz> there isn't really a good way to alias a class constraint. you have to write it at point of use.
01:28:50 <cjs> Not to mention that it avoids runtime representation of the type.
01:29:33 <yitz> john meacham suggested a cool extension called "class aliases" that would fill that gap. everyone likes it, but no one has gotten around to implementing it yet.
01:29:55 <yitz> cjs: right, it's more efficient.
01:33:46 <Taejo> wasn't logo voting supposed have started yesterday?
01:47:57 <rabideejit> I get a weird package error. http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1919#a1919
01:48:24 <rabideejit> I don't see where the network module explicitely asks for parsec-2.2.0.1
01:51:55 <rabideejit> also note:  This isn't public version of tagsoup-parsec even though it says 0.0.2 --- I just wanted to warn you because of the horrible error.  It would be ghastly to see in the wild.  Like alcoholic teenagers roaming the Serengeti, it's better to avoid that.
01:53:51 <yitz> @quote rabideejit It would be ghastly to see in the wild.  Like alcoholic teenagers roaming the Serengeti.
01:53:51 <lambdabot> No quotes for this person. There are some things that I just don't know.
01:54:04 <yitz> @remember rabideejit It would be ghastly to see in the wild.  Like alcoholic teenagers roaming the Serengeti.
01:54:04 <lambdabot> Done.
01:54:28 <yitz> rabideejit: but I can't help you with the error though. sorry. :)
01:54:41 <rabideejit> thankyou yitz
01:54:45 <rabideejit> It's okay
01:56:53 <yitz> rabideejit: what version of ghc are you using?
01:57:18 <quicksilver> rabideejit: I believe it is because parsec 2 is the "Default" version of parsec
01:57:28 <quicksilver> rabideejit: so a plain depends on parsec is interpreted as a depends on parsec 2.
01:59:05 <pozic> parsec 2 is the one without monad transformers, IIRC.
01:59:53 <rabideejit> quicksilver: That's interbesting, but then why does it interpret it is as parsec 2 for one package, and not infer it for the other?  Because I have parsec 3 installed, I'd guess.
02:00:08 <rabideejit> yitz: The Glorious Glasgow Haskell Compilation System, version 6.10.1
02:00:37 <quicksilver> rabideejit: good question. Only the awesome dcoutts can save you now.
02:01:38 <Saizan_> rabideejit: what command are you using to configure?
02:01:50 <rabideejit> Saizan_: cabal configure
02:02:12 <Saizan_> cabal --version ?
02:02:28 <Saizan_> however cabal configure --constraint="parsec < 3" should work
02:03:00 <quicksilver> Saizan_: can you explain why it's happening in the first place?
02:03:03 <rabideejit> cabal-install version 0.6.0/using version 1.6.0.1 of the Cabal library -- ok, thankyou
02:03:31 <Saizan_> quicksilver: well, cabal configure didn't use the smart solver in older versions
02:04:03 <Saizan_> quicksilver: so it picks the latest version available for the direct dependencies, and then discovers that the installed network is linked against parsec-2
02:04:08 <quicksilver> oh.
02:04:20 <quicksilver> understand.
02:04:29 <quicksilver> why does network depend on parsec anyway, I wonder?
02:04:31 <Saizan_> "cabal configure" is not supposed to fetch packages from hackage or rebuild installed packages, anyhow
02:04:55 <Saizan_> good question
02:04:59 <yitz> is hpaste.org broken?
02:05:03 <Saizan_> to parse some packets?
02:05:24 <rabideejit> yitz: for me too
02:05:44 <Saizan_> rabideejit: i recommend to update cabal-install with cabal install cabal-install, btw
02:06:31 <rabideejit> Saizan_: will do, cheers
02:07:08 <yitz> the dns for hpaste.org now points to unitedequitable.com. is that right?
02:07:53 <yitz> ah, that's moonpatio. ok.
02:07:58 <yitz> @seen mmorrow
02:07:58 <lambdabot> mmorrow is in #ghc and #haskell. I last heard mmorrow speak 1h 17m 10s ago.
02:08:39 <yitz> it's 4:00 am in texas, mmorrow is probably asleep.
02:12:22 <ImInYourMonad> why do people even use Lisp anymore?
02:13:55 <Gracenotes> heh, colorblind color-synesthetes are awesome
02:14:24 <Gracenotes> well. I'd rather much not be colorblind. I suppose it's not awesome :( interesting, though.
02:14:31 * Gracenotes is not colorblind
02:14:41 <Gracenotes> @vixen darn, it's late
02:14:41 <lambdabot> nothing good is on TV
02:14:56 <p_l> ImInYourMonad: Cause it's still a darn good language?
02:16:03 <trofi^w> :t intercalate
02:16:04 <lambdabot> forall a. [a] -> [[a]] -> [a]
02:16:45 <trofi^w> > let lispify = unwords . intercalate "(" . words in lispify "lisp is good"
02:16:46 <lambdabot>   Couldn't match expected type `String' against inferred type `Char'
02:16:54 <osfameron> I thought by and large people *don't* use Lisp anymore...
02:17:02 <trofi^w> > let lispify = intercalate "(" . words in lispify "lisp is good"
02:17:04 <lambdabot>   "lisp(is(good"
02:17:08 <osfameron> except for writing emacs macros in
02:17:12 <Gracenotes> is dat sum dangling parens
02:17:24 <quicksilver> osfameron: it always seems that way when you don't know people who use it.
02:17:31 <quicksilver> osfameron: it seems to me that nobody uses ruby
02:17:31 <osfameron> yeah, true
02:17:36 <quicksilver> but I know that isn't true.
02:17:39 <leadnose> clojure is a lisp, people use clojure => people use lisp
02:17:47 <leadnose> and others too of course
02:18:05 <quicksilver> I imagine more people are actively writing programs in lisp than haskell
02:18:09 <quicksilver> although that's a bit hard to verify.
02:18:24 <ImInYourMonad> i used clojure, it is weaksauce compared to haskell
02:18:24 <p_l> osfameron: and for many other things. It's just that outside of certain communities, you probably won't hear of anything other than Java, .NET, C/C++, PHP and then maybe Perl and Python
02:18:51 <osfameron> which communities do heavilyuse lisp/clojure/etc. ?
02:19:19 <p_l> osfameron: I mean outside of smug language people like those who attend #haskell, #clojure, #lisp etc. :D
02:19:24 <Gracenotes> > let lispify = ((++) <$> intercalate "(" <*> flip replicate ')' . length) . words in lispify "lisp is good and so is haskell"
02:19:25 <lambdabot>   "lisp(is(good(and(so(is(haskell)))))))"
02:19:35 <Gracenotes> :D
02:20:11 <Gracenotes> actually, not quite matching
02:20:13 <osfameron> ("":).words maybe ?
02:21:47 <quicksilver> osfameron: I'd say 'AI' except any attempt to utter those two letters makes me physically sick.
02:21:58 <Gracenotes> > let lispify = ((++) <$> concatMap ("("++) <*> flip replicate ')' . length) . words in lispify "lisp is good and so is haskell"
02:22:00 <lambdabot>   "(lisp(is(good(and(so(is(haskell)))))))"
02:22:16 <quicksilver> osfameron: but certainly lisp is used for symbolic manipulation and data transformation.
02:22:59 <p_l> There's also some Web Development going on etc.
02:23:01 <Gracenotes> > let lispify = tail . ((++) <$> concatMap (" ("++) <*> flip replicate ')' . length) . words in lispify "lisp is good and so is haskell"
02:23:02 <lambdabot>   "(lisp (is (good (and (so (is (haskell)))))))"
02:23:32 <p_l> mostly it's client-server or other "backbone" work, though
02:23:32 <Gracenotes> applicative style is very fun :)
02:23:50 <osfameron> :t (<*>)
02:23:51 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
02:24:02 <Gracenotes> @src liftA2
02:24:02 <lambdabot> liftA2 f a b = f <$> a <*> b
02:24:04 <osfameron> how do I read that?
02:24:10 <Gracenotes> for functions, liftA2 == liftM2
02:24:20 <wli> You should try to emit it as a parse tree, e.g. (and (is (lisp good)) (is (so haskell)))
02:24:53 <wli> ergh, wrong, (and (is lisp good) (is so haskell))
02:24:57 <Gracenotes> > liftM2 (,) (length) (map negate) $ [1..10]
02:24:58 <lambdabot>   (10,[-1,-2,-3,-4,-5,-6,-7,-8,-9,-10])
02:25:12 <osfameron> (is haskell so) no?
02:25:15 <Gracenotes> > ((,) <$> length <*> map negate) [1..10]
02:25:16 <lambdabot>   (10,[-1,-2,-3,-4,-5,-6,-7,-8,-9,-10])
02:25:20 <p_l> wli: (and (good-p 'lisp) (good-p 'haskell))
02:25:31 <Gracenotes> o nos, natural language processing
02:25:41 <osfameron> (split-p soup) ;-)
02:25:54 <wli> p_l: Different concept from a parse tree of the sentence.
02:25:58 <Gracenotes> @type liftA2
02:25:59 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
02:26:31 <Gracenotes> (a -> b -> c) -> (e -> a) -> (e -> b) -> e -> c
02:26:53 <p_l> wli: well, I used idiomatic CL :P
02:27:13 <Gracenotes> so you can combine the results of the second and third functions.. without using any explicit variables
02:27:26 <Gracenotes> (the combination is done with the first function)
02:27:36 <wli> S-expressions are about basically hammering parse trees instead of having a genuine concrete syntax (in spirit; in actuality they're a mess) so if you're going to "lispify" a sentence, dump it out as a parse tree in S-expression form.
02:28:01 <rabideejit> can anyone think of a better way of doing this? http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1920#a1920
02:28:05 <Gracenotes> well, I'm not sure you can "variables" in Haskell anyway >_>
02:28:19 <Gracenotes> use
02:28:40 <p_l> wli: the funniest thing is when the input is free form :D
02:29:04 <Gracenotes> rabideejit: it's a map that alternates functions to apply?
02:29:14 <mmorrow> yitz: not sure what really happened there with hpaste.org, but it's up now
02:29:38 <rabideejit> Gracenotes: yes
02:29:39 <quicksilver> > zipwith ($) (cycle [(*7),id]) ([1..20])
02:29:40 <lambdabot>   Not in scope: `zipwith'
02:29:44 <quicksilver> > zipWith ($) (cycle [(*7),id]) ([1..20])
02:29:45 <lambdabot>   [7,2,21,4,35,6,49,8,63,10,77,12,91,14,105,16,119,18,133,20]
02:29:52 <quicksilver> rabideejit: like that, perhaps.
02:29:58 <jmg> hi
02:30:00 <wli> mmorrow: Resolving variables has been tricky for stupid reasons. I'm getting closer to finishing resVars.
02:30:05 <Gracenotes> rabideejit: well, you can write it simply enough with plain old recursion, too
02:30:11 <jmg> is anybody here with experience on building hoc ?
02:30:14 <rabideejit> quicksilver: I like that, cool
02:30:38 <Gracenotes> onEverySecond f g (x:y:xs) = f x : g y : onEverySecond f g xs
02:30:49 <Gracenotes> onEverySecond f g [x] = [f x]
02:30:54 <mmorrow> wli: yeah, there's totally all these hidden boobytraps and trapdoors
02:30:55 <rabideejit> Gracenotes:  I'm a sucker for HOT things
02:30:58 <Gracenotes> onEverySecond f g [] = []
02:30:58 <rabideejit> *HOF
02:31:18 <quicksilver> the oneliner is cooler than the explicit 3-case recursion :)
02:31:20 <Gracenotes> rabideejit: I like 'em elegant too, but just sayin :D
02:31:52 <Gracenotes> @hoogle ZipList
02:31:53 <lambdabot> Control.Applicative newtype ZipList a
02:31:53 <lambdabot> Control.Applicative ZipList :: [a] -> ZipList a
02:31:53 <lambdabot> Control.Applicative getZipList :: ZipList a -> [a]
02:32:37 <Gracenotes> > getZipList $ ZipList (cycle [(*7),id]) <*> ZipList [1..20]
02:32:38 <lambdabot>   [7,2,21,4,35,6,49,8,63,10,77,12,91,14,105,16,119,18,133,20]
02:32:49 <Gracenotes> (same result as above, using applicative)
02:33:16 <osfameron> huh?
02:33:20 <osfameron> why do you repeat ZipList ?
02:33:49 <osfameron> oh it's just a list constructor
02:33:53 <Gracenotes> yeah, so that they're both ZipLists
02:34:32 <rabideejit> It's cool.  The use of cycle in these are good examples of why infinite lists are useful.
02:36:03 <quicksilver> yup.
02:36:26 <wli> mmorrow: Well, once I stopped tripping over my own dumb non-mnemonic data structures I'm back to tearing through it with Data.Foldable.mapM_ on Data.Map
02:37:49 <wli> mmorrow: It's really astounding how the Foldable and Traversable instances on Map, IntMap, Set, and IntSet completely massacre this.
02:39:30 <wli> mmorrow: It's not just that it's getting the job done, it's that it's doing it with both brevity and a complete absence of linear search where unnecessary.
02:40:56 <quicksilver> wli: it's really nice when nice algebraic structures + operations compose to do exactly the right thing.
02:41:05 <quicksilver> it's bloody annoying when they compose to do precisely the wrong thing, of course.
02:46:14 <yitz> mmorrow: hmm, still not working for me
02:47:20 <Gilly> does there exist a builtin function of type (a -> b -> c) -> (a,b) -> c ?
02:47:50 <Ferdirand> :t curry
02:47:51 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
02:47:57 <Ferdirand> so it's the other one
02:48:01 <Ferdirand> :t uncurry
02:48:03 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
02:48:06 <Gilly> ah, thanks :)
02:49:30 <yitz> mmorrow: well, deep-linking to the full fastcgi url works now. but the url http://hpaste.org/ is still unhelpful.
02:54:53 <bastl> can anyone help with hint, the haskell runtime interpreter ?
02:55:36 <profmakx> bastl what do you mean?
02:55:40 <quicksilver> we can try.
02:55:48 <quicksilver> until you ask a question, I"m not sure if I can help or not.
02:55:51 <bastl> i want to load modules i installed via a cabal-package. but get a ghc-error "module `XXX' is a package module. How can let hint load package modules ?
02:56:42 <bastl> ok, same message in ghci.
02:57:41 <quicksilver> what's the exact message from ghci?
02:57:56 <bastl> so in ghci, ":m + XXX" works but ":load XXX" gives error "module `Language.Java.Absjava' is a package module"
02:58:21 <quicksilver> yeah, you don't ":load" compiled packages
02:58:36 <quicksilver> they're already in the search path you could say
02:58:45 <quicksilver> you ":load" other stuff you want to bring in.
03:00:09 <bastl> qs: ok, i think i got it. before i used cabal, i had to :load the source files myself, correct? Now i dont have to anymore ...
03:01:13 <quicksilver> I don't know what "used cabal" means, really
03:01:25 <quicksilver> you don't have to ":load" somethign which is an installed package.
03:01:37 <quicksilver> that it, it's in ghc's package database.
03:01:44 <quicksilver> you have to load stuff which is outside of that.
03:03:04 <rabideejit> It's annoys me when I'm in the package directory base directory and I :m one of the modules in ghci - it causes a load error as it looks through the directory path first and finds the source file.
03:04:53 * wjt wonders how to write (\f xs -> case xs of { x:xs' -> f x:xs' ; _ -> xs }) more concisely
03:05:34 <wjt> I guess more generally I want something akin to (&&&) but for the head and tail of a list
03:08:12 <BONUS> > uncurry (:) . first (+3) . (head &&& tail) $ [1,1,1]
03:08:13 <lambdabot>   [4,1,1]
03:08:49 <BONUS> @pl \f -> uncurry (:) . first f . (head &&& tail)
03:08:49 <lambdabot> (uncurry (:) .) . (. (head &&& tail)) . first
03:08:55 <BONUS> haha wow not cool
03:09:07 <Olathe> @pl \(x:xs) -> f x:xs
03:09:07 <lambdabot> ap ((:) . f . head) tail
03:11:21 <Gracenotes> Olathe: eek :X
03:12:45 <Saizan_> bimap f id
03:13:14 <Gracenotes> hrm.
03:13:30 <quicksilver> wjt: "if p x then f x else x" is something I occasionally need
03:13:40 <quicksilver> wjt: is what you talked about "if null x then f x else x" ?
03:13:44 <Axman6> condApply?
03:14:10 <Gracenotes> @pl \f -> zipWith id (f : repeat id)
03:14:10 <lambdabot> zipWith id . (: repeat id)
03:14:14 <Saizan_> if null x then x else f (head x) : tail x
03:14:22 <Axman6> :t let condApply p f x = if p x then f x else x in condApply
03:14:23 <lambdabot> forall t. (t -> Bool) -> (t -> t) -> t -> t
03:14:32 <Gracenotes> > (zipWith id . (: repeat id)) (+3) [1,2,3]
03:14:33 <lambdabot>   [4,2,3]
03:14:35 <Gracenotes> :)
03:14:52 <quicksilver> Saizan_: oh, yes.
03:14:53 <quicksilver> hmm.
03:14:56 <Gracenotes> kind of messy if you have a long list
03:15:46 <Gracenotes> because it id's everything :x
03:17:29 <Gracenotes> @pl \f x -> cond [] (f (head x) : tail x) (null x)
03:17:29 <lambdabot> (`ap` null) . (cond [] .) . (`ap` tail) . ((:) .) . (. head)
03:18:34 <mib_dxfc3j0r> Hi Everyone,
03:19:10 <Gracenotes> greetings
03:19:36 <mib_dxfc3j0r> I was reading the Hudak book - the one about
03:19:42 <wli> This is bloody brutal. I love it.
03:19:46 <mib_dxfc3j0r> history of functional programming
03:20:07 <mib_dxfc3j0r> towards the end he sets out to explain how to get state
03:20:39 <mib_dxfc3j0r> nd maps out several eqns
03:20:50 <mib_dxfc3j0r> eg f:=g =\s->fs(gs)
03:21:14 <mib_dxfc3j0r> I wouldn't grok that at all. :)
03:21:29 <mib_dxfc3j0r> \s ->fs(gs)
03:22:05 <mib_dxfc3j0r> meanin anonymous fn that takes variable s and maps it to f(s) composed to g(s)
03:22:12 <mib_dxfc3j0r> is that right?
03:22:54 <QtPlaty[hireme]> mib_dxfc3j0r: I think your missing spaces.
03:23:10 <mib_dxfc3j0r> ok
03:23:47 <mib_dxfc3j0r> f := g = \s -> f s (g s)
03:23:57 <mib_dxfc3j0r> sorry about that pasted from pdf
03:23:59 <wli> http://wli.pastebin.com/m5e7743f0 <-- collecting def/use sites for vars and providing lexically unique ID's for them
03:24:14 <QtPlaty[hireme]> mib_dxfc3j0r: Or is this lambda cal rather then haskell.
03:25:10 <wli> No idea why I don't need Ord lab, but anyway.
03:25:12 <Gracenotes> mib_dxfc3j0r: that's what the reader monad is (albeit, with the arguments switched)
03:25:27 <mib_dxfc3j0r> I think it is haskell based BUT old haskell
03:25:38 <Gracenotes> f >>= g = \s -> f (g s) s
03:25:55 <wli> All the mapM's are Data.Traversable.mapM and all the mapM_'s are Data.Foldable.mapM_'s
03:26:03 <Gracenotes> and I think you have to switch f and g.
03:26:35 <Gracenotes> so what you have there, actually, is closer to ap.
03:27:54 <mib_dxfc3j0r> ok but what does f:= g mean?
03:28:24 <wli> In almost every instance applied to an IntMap, IntSet, Map, or Set.
03:29:39 <Gracenotes> mib_dxfc3j0r: assigning the value g to f, at least in programming languages like Pascal
03:30:01 <Gracenotes> assignment in general, really... not sure if the author of whatever book you're reading is using the notation for something else
03:30:39 <mib_dxfc3j0r> ok. this was in Hudak, towards the end where he is talking about emulating state.
03:30:55 <mib_dxfc3j0r> any good tutorials out there for that?
03:31:08 <Gracenotes> emulating mutable state?
03:31:19 <mib_dxfc3j0r> ya,
03:31:33 <wli> It's not just doing all that variable resolution, it's doing it with efficient data structures! w00t!
03:33:11 <Gracenotes> > do { x <- id; local (+1) $ do { x <- id; return x } } $ 10
03:33:12 <lambdabot>   11
03:33:54 <Gracenotes> I suppose you could emulate state like that. Every time you want to modify a variable, just create a new local block.
03:33:59 <wli> Gracenotes: moi?
03:34:11 <fasta> Gracenotes: it works at compile-time.
03:34:15 <wli> Never mind.
03:34:32 <Gracenotes> fasta: ahm, what does?
03:34:44 <fasta> Gracenotes: never mind ;)
03:34:48 <mib_dxfc3j0r> i mean I grok passing state as a parameter. :)
03:35:35 <Gracenotes> @undo do { x <- id; local (+1) $ do { x <- id; return x } }
03:35:35 <lambdabot> id >>= \ x -> local (+ 1) $ id >>= \ x -> return x
03:35:46 <Gracenotes> @src local
03:35:46 <lambdabot> Source not found. Take a stress pill and think things over.
03:35:53 <mib_dxfc3j0r> and he even makes an interesting statement that you can add state to in a data structure that is updated nondestructively
03:36:02 <mib_dxfc3j0r> so that, at least conceptually, the old value
03:36:05 <QtPlaty[hireme]> @type local
03:36:06 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
03:36:12 <mib_dxfc3j0r> of the data structure remains intact and
03:36:16 <wli> @src Reader
03:36:16 <lambdabot> Source not found. You type like i drive.
03:36:19 <mib_dxfc3j0r> can be accessed later.
03:38:14 <mib_dxfc3j0r> ok I will come back latter but which are the top 2 tutorials to grok: Real World Haskell, yet another Haskell or some other?
03:38:20 <RayNbow> > do { x <- ask; local (+1) $ do { x <- ask; return x } } $ 10  -- Gracenotes, isn't it clearer if you use ask instead of id?
03:38:21 <lambdabot>   11
03:38:34 <Gracenotes> well, yes. Although they do the same thing
03:39:19 <bremner> mib_dxfc3j0r: RWH is the current "hot" one, but people like also several others. Depends what you want
03:39:33 <wli> Which is just do { x <- ask ; local (+1) ask } which is just asks (+1)
03:39:39 <mikhail^> Hi guys, I've been using HaskellDB and I must say that it's cool. Question is, how do I make my query limit the number of results it does?
03:39:42 <RayNbow> > do { x <- id; local (+1) `id` do { x <- id; return x } } `id` 10 -- or we could use id more :p
03:39:44 <lambdabot>   11
03:40:02 <wli> > asks (+1) $ 10
03:40:03 <lambdabot>   11
03:40:05 <Gracenotes> the point is, to extract the variable you do need id. now, just a sec
03:40:11 <mib_dxfc3j0r> I first want to emulate  imperial programmng by understaning the Haskell state model. :)
03:40:51 <Gracenotes> as I said above, what I posted was equivalent to... id >>= (\ x -> local (+ 1) $ id >>= \ x -> return x)
03:40:53 <h0tzenpl0tz> @src asks
03:40:54 <lambdabot> asks f = do
03:40:54 <lambdabot>     r <- ask
03:40:54 <lambdabot>     return (f r)
03:41:00 <h0tzenpl0tz> @src ask
03:41:00 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
03:41:12 <Gracenotes> id >>= (\ x -> (id >>= \ x -> return x) . (+1))
03:41:19 <koala_man> where does @src gets the source from?
03:41:25 <fasta> mib_dxfc3j0r: Look at a recent specification of Scheme and you see it immediately.
03:41:38 <Gracenotes> koala_man: a huge file
03:42:47 <Gracenotes> @type id >>= (\ x -> (id >>= \ x -> return x) . (+1))
03:42:48 <lambdabot> forall a. (Num a) => a -> a
03:42:59 <Gracenotes> @type \e -> (\x -> (id >>= \ x -> return x) . (+1)) e e
03:43:00 <lambdabot> forall a. (Num a) => a -> a
03:44:06 <Gracenotes> @type \e -> (\x -> (\e' -> const e' e') . (+1)) e e
03:44:07 <lambdabot> forall a. (Num a) => a -> a
03:44:26 <Gracenotes> @type \e -> (\x -> (+1)) e e
03:44:27 <lambdabot> forall a. (Num a) => a -> a
03:44:36 <Gracenotes> @type \e -> (+1) e
03:44:37 <lambdabot> forall a. (Num a) => a -> a
03:44:41 <Gracenotes> @type (+1)
03:44:42 <lambdabot> forall a. (Num a) => a -> a
03:44:49 <Gracenotes> and that's how the reader monad gets simplified
03:45:07 <Gracenotes> note the substitution that I did...
03:45:19 <Gracenotes> f =<< g = \e -> f (g e) e
03:45:30 <Gracenotes> which is what you had above, mib_dxfc3j0r
03:46:19 <Gracenotes> so you can have local scope by using that transformation.
03:48:05 <Gracenotes> and local scope means that you can 'mutate' something in an outer scope just by rebinding the name to a new value
03:48:12 <mikhail^> anybody know how to limit the number of records retrieved in HaskellDB?
03:48:16 <Gracenotes> at least in this context. anyway... a bit convoluted, using monads to explain it >-.
03:48:20 <Gracenotes> >_>
03:49:47 <quicksilver> mikhail^: according to the docs, "top" "Return the n topmost records. "
03:50:31 <mikhail^> quicksilver, i see... was looking for 'limit' in the docs but never found that. thanks for the tip, will try top and see if that works.
03:50:38 <mib_dxfc3j0r>  my head is going to explode. :) I can't pretend I really followed that.
03:50:45 <rabideejit> a random interjection but:  HAppS is good because if you ever end up with screwy data ( if you don't parse input properly, like me ) you can just write a command line program using the same state module to fix it.
03:50:54 <ImInYourMonad> i never use the state monad, is it ever REALLY needed?
03:51:08 <quicksilver> ImInYourMonad: no.
03:51:09 <pejo> Im, it's sometimes convenient.
03:51:13 <quicksilver> it's merely a way to construct functions.
03:51:22 <Gracenotes> (the State monad is a lot more flexible than the reader monad, by the way)
03:51:26 <quicksilver> the state monad is a tool for constructing functions (s -> s) or (s -> (a,s))
03:51:31 <quicksilver> you can always do it by hand.
03:51:41 <quicksilver> it's sometimes convenient.
03:51:57 <quicksilver> and the monad combinators (mapM, and so on) are convenient.
03:51:58 * bremner thinks nostalgicly of denotational semantics class
03:52:08 <Gracenotes> abstracting away implicit state
03:52:51 <mib_dxfc3j0r> way I understand it
03:53:05 <mib_dxfc3j0r> state monad carries the tuple state and result
03:53:29 <mib_dxfc3j0r> and passes it to given function and retrieves new state and result tuple
03:53:35 <rabideejit> it can be a simple way of writing an interpreter.  Especially if you generate template haskell code.
03:54:06 <mib_dxfc3j0r> state monad abstracts the tuple passing away.
03:54:27 <quicksilver> yes.
03:54:41 <quicksilver> it stops you making mistakes where fail to thread the state correctly
03:54:51 <quicksilver> which are common in hand-written state code
03:55:03 <quicksilver> one of them was a bug in ghc 6.8.1 which stopped an optimisation kicking in ;)
03:56:31 <mib_dxfc3j0r> great. is there some nice example code (as short as possible!) where a state machine for parsing a line from the reader or something is there.
03:56:44 <Gracenotes> when you use it you don't have to think about precisely where the state comes from, just that you can access it and modify it... feels good man...
03:57:24 <quicksilver> well, it feels nicest when you never access the state explicitly
03:57:25 <bremner> Gracenotes: well, you could just use an imperitive language :-)
03:57:33 <quicksilver> but just chain together other functions which do so automatically.
03:57:44 <Gracenotes> bremner: hah :)
03:58:02 <Gracenotes> well, granted, I don't use it very often
03:58:11 <mib_dxfc3j0r>  I know. :) but if I want to leave imperative mode, I really have to grok how the equivalent mapping is done. :)
03:58:36 <mib_dxfc3j0r> after all 90 % of "real world" programming typically uses state.
03:59:07 <Peaker> mib_dxfc3j0r: most programmers use state, but that doesn't mean its the right thing to do..
03:59:10 <Gracenotes> sure, state. But not necessarily state you have to mutate.
03:59:18 <Gracenotes>  But... uh, what do you mean by a "state machine"?
03:59:28 <mib_dxfc3j0r> ok.
03:59:39 <Olathe> He deals with state so much he's a state MACHINE !
03:59:39 <mib_dxfc3j0r> think of an editor
03:59:49 <Peaker> mib_dxfc3j0r: do you know FRP?
04:00:05 <Gracenotes> mib_dxfc3j0r: okay, thinking
04:00:17 <pejo> quicksilver, what was the bug in 6.8.1 you were thinking of?
04:00:56 <mib_dxfc3j0r> :0 No idea of frp. but in an editor, the machine "remembers" what the user had done last
04:01:01 <mib_dxfc3j0r> eg insert mode or not
04:01:09 <mib_dxfc3j0r> now that is pure state
04:01:15 <Gracenotes> you mean a list of changes?
04:01:25 <mib_dxfc3j0r> yes,
04:01:28 <Gracenotes> that could easily be modeled by a singly linked list
04:01:36 <Peaker> mib_dxfc3j0r: it can be done functionally, with no imperative destructive writes in sight, with FRP
04:01:47 <quicksilver> pejo: pointer tagging failed to work in a large proportion of cases
04:01:51 <mib_dxfc3j0r> frp links?
04:01:55 <quicksilver> pejo: there should be a message from SPJ about it somewhere.
04:01:58 <Gracenotes> when the user updates, prepend the list of changes with the new change
04:02:14 <quicksilver> actually imperative editors do something like this too ;)
04:02:23 <quicksilver> the naive imperative algorithm does not scale well.
04:02:36 <quicksilver> all real editors have some notion of difference lists and checkpoints.
04:02:39 <quicksilver> the devil is in the details.
04:02:47 <Gracenotes> now, to actually save the list in a GUI application... unfortunately most Haskell GUI libraries use a model with IORefs and actual mutable state
04:03:12 <Gracenotes> FRP, though I don't know it, apparently makes it purely functional and so on with other delicious goodies
04:03:19 <Peaker> mib_dxfc3j0r: http://www.haskell.org/haskellwiki/Reactive
04:04:08 <fasta> quicksilver: The problem regarding the data structures was actually that it had to be possible to point from multiple places to multiple arbitrary locations within this sequence (in constant time).
04:04:44 <fasta> quicksilver: that's something that I believed to be incompatible with Data.Sequence.
04:05:08 <Peaker> Gracenotes: Read an FRP tutorial.. its really easy there's no reason "not to know it yet" :)
04:05:24 <Gracenotes> Peaker: the lack of simple working examples is a huge pain
04:05:33 <quicksilver> fasta: well you can obviously point to the value at a location, and you can point to its index.
04:05:37 <Peaker> Gracenotes: well, the tutorials still make it pretty understandable
04:05:45 <quicksilver> fasta: I suppose neither of those is quite what you want.
04:05:47 <Gracenotes> it's either 50-line programs or an abstract tutorial that doesn't impart anything concrete
04:05:48 <rabideejit> the scenegraph program uses Reactive for buttons within openGL.  It's kinda cool.
04:05:49 <fasta> quicksilver: yes, but not in constant time.
04:06:04 <rabideejit> Gracenotes: ^^
04:06:08 <quicksilver> fasta: well you can point to them in constant time. It takes log n time to look them up.
04:06:16 <fasta> quicksilver: I mean, given the "pointer", to dereference the "pointer" in constant time.
04:06:20 <quicksilver> fasta: I don't believe in the distance between log n and constant.
04:06:24 <Gracenotes> Peaker: you'd recommend any tutorials with runnable code?
04:06:29 <fasta> quicksilver: right, but instead of log n, I needed O(1)
04:06:56 <aleator> Why is Data.Map.mapKeysWith Ord k2 => (a -> a -> a) -> (k1 -> k2) -> Map k1 a -> Map k2 a instead of Ord k2 => (a -> b -> b) -> (k1 -> k2) -> Map k1 a -> Map k2 b
04:07:00 <quicksilver> fasta: there is no O(1).
04:07:01 <Saizan_> fasta: did you solve that?
04:07:10 <fasta> Saizan_: yes
04:07:12 <Peaker> Gracenotes: why must there be runnable code? :-)   I think this makes it pretty clear what events are: http://netsuperbrain.com/blog/posts/introducing-reactive-events/
04:07:26 <fasta> quicksilver: how do you mean there is no O(1)
04:07:34 <Gracenotes> Peaker: I read that. Didn't shed much light.
04:07:43 <fasta> quicksilver: do you mean in the universe?
04:07:54 <Peaker> Gracenotes: ah, do you know what Behaviors are, too?
04:07:57 <Saizan_> fasta: how?
04:08:01 <mib_dxfc3j0r> ok. It really has been AWESOME talking to you guys. My name is Girish and I will come back with more doubts after revisting everything and reading FRP. :)
04:08:01 <quicksilver> fasta: an O(1) pointer is really just O(1) on a bounded data set (maximum 32 bit or 64 bit pointers)
04:08:10 <Peaker> Gracenotes: and the functions that compose them? e.g: snapshot, withTime, stepper, etc?
04:08:25 <fasta> quicksilver: yes, but by that reasoning everything is O(1).
04:08:26 <quicksilver> fasta: if you are prepared to accept a bound like 32 bit or 64 bit, then IntMap and Map are also O(1).
04:08:29 <Gracenotes> Peaker: it's interesting to explain some abstract concepts, but until you understand the entry point to them from the real world, it's all abstract nonsense
04:08:29 <rabideejit> Gracenotes: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/scenegraph I found reading the scenegraph code helped my understanding of frp
04:08:41 <Peaker> Gracenotes: you can look at the examples in reactive-fieldtrip, they're quite nice
04:08:43 <Gracenotes> Peaker: for exmple, I didn't understand the State monad one bit until I learned about runState
04:08:48 <Gracenotes> then it all clicked
04:09:26 <quicksilver> fasta: there is a massive practical difference between O(1) and O(n), similarly O(n) and O(n^2)
04:09:33 <fasta> Saizan_: what exactly are you asking for?
04:09:40 <quicksilver> fasta: the practical difference between O(1) and O(log n) is alike to a constant factor.
04:09:46 <Gracenotes> Peaker: that is, using runState as an entry point into a State computation
04:09:50 <quicksilver> fasta: if the constant factor is too slow for your needs, then sure, you need something else.
04:09:51 <fasta> quicksilver: but a machine is a finite thing, so everything is O(1).
04:09:58 <Peaker> Gracenotes: in reactive-fieldtrip there's anim3 which might be the equivalent :-)  anim3 :: (UI -> Behavior Geometry3) -> IO ()
04:10:19 <rabideejit> the reactive package has a monadic approach to FRP... as it says mempty is a future that never arrives... when you apply Reactive monadic functions, they wait till events occur.
04:10:20 <fasta> quicksilver: (because you can solve the Halting problem for a finite machine).
04:10:24 <quicksilver> fasta: Yes.
04:10:35 <quicksilver> fasta: But still, I stand by my previous two sentences.
04:10:46 <luite_> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=2496 <- I've installed this package before without problems, but now it goes wrong. any idea?
04:10:50 <fasta> quicksilver: I don't need it anymore. It was just for CS purposes.
04:11:06 <Gracenotes> rabideejit: okay, I'll check the graph out. Does it use an FRP library?
04:11:15 <Peaker> Gracenotes: UI is basically how you get user input, there's   keyboardAction :: UI -> Event (KeyAction, Key)   etc.   So you get a UI and have to return an animation (Geometry3 is a 3d model to render)
04:11:18 <rabideejit> Gracenotes:  it uses the reactive package.
04:11:30 <Peaker> Gracenotes: and anim3 is reactive-fieldtrip's adapter that runs it in IO
04:11:34 <Gracenotes> rabideejit: not in the dependencies X.X
04:11:47 <quicksilver> fasta: the difference between O(1) and O(n) matters.
04:11:47 <quicksilver> the difference between O(1) and O(log n) does not matter.
04:11:47 <quicksilver> what matters (in the latter case) is the constant factors.
04:11:56 <Peaker> rabideejit: mostly applicative-functory approach, there's not much use of monads in there
04:12:10 <rabideejit> Gracenotes: If I remember rightly, it has it's own fork.
04:13:09 <rabideejit> Peaker:  hmm!
04:13:51 <rabideejit> Peaker:  Yes you're right, it's functor based.
04:14:03 <Peaker> rabideejit: Behavior isn't a monad because of technical difficulties, too :-(
04:14:22 <Peaker> hopefully conal manages to make it a monad (or maybe he already has?)
04:14:23 <rabideejit> Soooo sad.
04:14:43 <Peaker> rabideejit: it might be important for real world uses of FRP to be able to generate and use Behaviors inside behaviors
04:14:51 <fasta> quicksilver: the O(.) has little relation to reality
04:15:01 <Gracenotes> Peaker: you define keyboardAction yourself?
04:15:01 <Gracenotes> okay, that's neat.. I've been grokking applicative functors reasonably well lately :) so long as there's no 'operator overload'
04:15:02 <quicksilver> fasta: it has some.
04:15:10 <fasta> quicksilver: yes, it has some.
04:15:17 <quicksilver> fasta: if I write an O(n) algorithm, and run a simulation with 1000 entities
04:15:31 <quicksilver> fasta: and then scaling up to 10000 entities takes 10 as long, that matters.
04:15:31 <Peaker> Gracenotes: no, that's a library primitive from reactive-glut
04:15:33 <rabideejit> Peaker:  That would be cool.
04:15:33 <fasta> quicksilver: it just depends on what kinds of functions you are interested in.
04:15:39 <quicksilver> fasta: if it takes 100 times as long, it's a disaster (often)
04:15:46 <quicksilver> fasta: so n -> n^2 matters quite often.
04:16:07 <Peaker> Gracenotes: UI is basically a record of behaviors and events representing user input
04:16:21 <quicksilver> if it just takes (1.33) times longer (that is, log 10000/log 1000) that's pretty much as good as the same speed.
04:16:25 <Peaker> Gracenotes: There's no global event source for user input or such because its not a global, it depends on the instance of UI that was created somewhere
04:16:35 <quicksilver> in that sense, O(log n) is practically the same as O(1)
04:20:37 <wli> Um, no... the reason why O(lg(n)) is practically the same as O(1) is because the input space requirements are typically Omega(n) and real computing hardware is bounded in memory/etc. capacity.
04:21:40 <quicksilver> I don't think that's true
04:21:45 <wli> Asymptotics do set in before capacities are reached but in different ways for different functions.
04:22:01 <quicksilver> there is a whole body of query algorithms which do not have Omega(n) input space requirements
04:22:06 <quicksilver> and that's rather the point of them.
04:22:14 <wli> O(n) shows strong variations before the limits are reached. O(lg(n)) does not.
04:24:49 <wli> You can, for instance, with 1.44*lg(n) + O(1) as an asymptotic estimate say that 46.08 nodes are visited in the worst case on a 32-bit machine or some such.
04:25:25 <quicksilver> btu I agree with you on the variational point.
04:25:38 <quicksilver> there is precious little different between lg(25) and lg(32)
04:25:57 <quicksilver> and yet, 2^25 might be a moderate data set and 2^31 might be an absurdly huge one
04:26:35 <wli> And 2^64 beyond human capacity to construct.
04:28:11 <wli> Get an asymptotic estimate, moke out some constants, plug 2^64 into the slowly varying parts like lg(n), and you've got good (if not tight) bounds.
04:28:37 <wli> Provided Omega(n) space is required for inputs.
04:32:15 <cizra> Heh. O'er here I'm using random 0-2^64-1 values as SQL table unique keys (non-production code, tests to be specific). I'm absolutely certain some day someone will trip over this and curse me.
04:32:44 <opqdonut> cizra: hehe, something like that was in daily wtf just a while ago :)
04:33:24 <Botje> more risks involved in assigning them sequentially, i'd think
04:33:49 <cizra> opqdonut: They had 10^6 unique items, I have 10^19
04:34:17 <Botje> that's like, a thousand! woa!
04:34:24 <opqdonut> :D
04:34:24 <cizra> opqdonut: And this is an automated test.
04:34:28 <cizra> Botje: haha. That reminds me..
04:35:06 <cizra> (a real story) A physics teacher once asked the student, how high above horizon is the noon-time sun on the spring equinox.
04:35:18 <cizra> The student answered, "Oh my, that must be several thousand kilometres!"
04:35:27 <opqdonut> :D
04:35:59 <Botje> grin :)
04:36:14 <Philonous1> Finding new keys when the keyspace is almost saturated sounds like an expensive operation in any event. I always wondered how this is usually done. Keep a collection of free keys?
04:36:45 <opqdonut> the standard malloc implementation uses a circular list
04:36:48 <cizra> Philonous1: Use sequential keys, when you can? (like in SQL)
04:36:58 <cizra> opqdonut: What does malloc do with keys?
04:37:04 <opqdonut> cizra: he was talking about fragmentation
04:37:09 <opqdonut> or so i presumed
04:37:15 <opqdonut> when items get removed
04:37:43 <cizra> Hmm, OK
04:38:07 <Philonous1> Yes, fragmentation.
04:39:33 <TimGoodwin> Hello all - I've just arrived here 'cos I'm having trouble installing ghc-6.10.1... thought somebody here might be able to help?
04:40:18 <fasta> Philonous: so you actually meant how to find free continuous memory of size at least X in M, where M is the memory and X a number efficiently?
04:40:47 <cizra> TimGoodwin: Which OS?
04:40:50 <fasta> TimGoodwin: you don't ask to ask.
04:41:13 <TimGoodwin> cizra: Fedora 9, essentially; fasta: OK!
04:41:18 <Philonous> fasta: Well, this problem is related, I guess, but I actually meant how to find a unused unique key in a (SQL) database, when the keyspace is fragmented and almost saturated
04:41:55 <TimGoodwin> Here's a paste bin http://www.mibbit.com/pb/1G443R shows the last few lines of "make install"
04:42:14 <fasta> Philonous: you need a special API call to do that, or it is going to be horribly slow.
04:42:31 <lowmagnet> Speaking of complexity: If loading 6553 rows takes 0:45, and loading 65535 takes 8:10, that's almost O(2n) right?
04:42:46 <opqdonut> can't say
04:43:02 <opqdonut> you can fit any curve (except a constant) to thos two points
04:43:07 <fasta> lowmagnet: O(n) = O(2n).
04:43:37 <osfameron> constant factors *are* important too though
04:43:38 <opqdonut> of course if one also presumes loading 0 rows takes 0 time and the time requirement is monotonic, then O(n) looks like a good guess
04:43:40 <Philonous> lowmagnet: any number of polynomials and even more complex function might yield these two values
04:43:42 <int-e> lowmagnet: 0:45 * 10 = 7:30. But n may still be small.
04:43:45 <Gracenotes> , <3
04:43:52 <osfameron> depending on size of n and the constant factor
04:44:04 <lowmagnet> so i need a third point?
04:44:21 <fasta> lowmagnet: no, you need all points if you want to define a function ;)
04:44:26 <TimGoodwin> Searching for that error made me think that "ghc-pkg unregister Cabal" might help. But it didn't.
04:44:44 <fasta> lowmagnet: if you really want to know the complexity, you need to prove it.
04:45:11 <lowmagnet> I'm testing not proving :)
04:45:12 <fasta> lowmagnet: if on the other hand, you are not interested in a proof, you could just fit a curve to some data points.
04:45:15 <Philonous> lowmagnet: If you don't know the algorithm so you can't reason about it you would need a few points more, yes
04:45:18 <int-e> lowmagnet: O(n) doesn't have any practical meaning really. (although many algorithms are so well-behaved that this means a linear growth even for small n.)
04:45:19 <fasta> lowmagnet: see gnuplot
04:45:47 <lowmagnet> I have splus and a few other programs available to me in the app i'm testing
04:46:10 <lowmagnet> (I do quality analysis but not necessarily performance for a living)
04:47:32 <cizra> TimGoodwin: Dunno... Try to get rid everything Cabal-smelling?
04:47:54 <TimGoodwin> cizra: thanks - I'm just about to try another build, after "rm ~/.cabal"...
04:48:34 <kiris> the logo in the monad.reader issue is dirty
04:49:32 <ivanm> kiris: the hammer and spanner forming a lambda?
04:49:36 <ivanm> how is it dirty?
04:50:18 <wli> I'd at least try to do some asymptotics to get it in the form of \sum_k C_k f_k(n) and then do linear regression on a bunch of samples.
04:51:39 <lowmagnet> it's not pure!
04:51:53 <maxote> hello, i did read a little the System F_2, the conclusion is easy
04:52:13 <McManiaC> whats wrong about this list comprehension? where can i place the let to make it work?
04:52:19 <McManiaC> [ let n = if i == 10 then 0 else i
04:52:19 <McManiaC>                             "^ca(1,superkey " ++ show (n) ++ ")" ++ ws ++ "^ca()" |
04:52:19 <McManiaC>                             (i,ws) <- zip [1..length l] l ]
04:52:29 <McManiaC> (indention is ofc wrong)
04:52:57 <Gracenotes> where's the "in"? :)
04:53:00 <fasta> McManiaC: missing in
04:53:03 <McManiaC> oh
04:53:07 <maxote> in System F_2, it extends HM to a new feature: the type is a value of first-class too in F_2 when in F_1, the high-order function was a value of first-class.
04:53:12 <McManiaC> ok :) ive been working too much with do latley ;)
04:53:31 <Gracenotes> McManiaC: however, you *can* do: [ "^ca(1,superkey " ++ show (n) ++ ")" ++ ws ++ "^ca()" | (i,ws) <- zip [1..length l] l; let n = if i == 10 then 0 else i ]
04:53:47 <McManiaC> ah cool ok
04:53:59 <Gracenotes> McManiaC: you can also do zip [1..] l, instead of zip [1..length l] l
04:54:07 <Gracenotes> zip stops when it reaches the end of one of the lists
04:54:15 <Gracenotes> it will reach the end of l first :)
04:54:36 <McManiaC> yeh cool
04:54:37 <McManiaC> :)
04:55:09 <McManiaC> thx!
04:55:36 <cizra> > zip [1..] [1..]
04:55:37 <lambdabot>   [(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10),(11,11),(12,...
04:55:51 <maxote> typechecking a src program of class F_2 can be either decidable or undecidable, depending of if every the types-as-values constructs are possible in compilation time or not, otherwise undecidable (they are constructs dinamically typed that should be computed in running time ) :)
04:55:51 <cizra> > let l = [1..] in zip [1..length l] l
04:55:56 <Olathe> It's actually better to do [1..] since it doesn't have to compute the length unlazily that way.
04:56:02 <lambdabot>   mueval: Prelude.read: no parse
04:56:05 <osfameron> > zip [1..] [1..5] -- demonstrates better
04:56:07 <Gracenotes> s/when/if/ :)
04:56:08 <cizra> > let l = [1..] in zip [1..length l] in l
04:56:08 <Olathe> As cizra demonstrates :)
04:56:09 <lambdabot>   <no location info>: parse error on input `in'
04:56:10 <lambdabot>   [(1,1),(2,2),(3,3),(4,4),(5,5)]
04:57:21 <Gracenotes> > zip [0..] [' '..]
04:57:23 <lambdabot>   [(0,' '),(1,'!'),(2,'"'),(3,'#'),(4,'$'),(5,'%'),(6,'&'),(7,'\''),(8,'('),(...
04:57:28 <McManiaC> ^^
04:57:35 <Gracenotes> (>^.^)>
04:57:36 <Gracenotes> <(^.^<)
04:57:45 <osfameron> ooo, chars increment too, just like Perl!
04:57:48 <osfameron> do strings?
04:57:58 <osfameron> > ["bar1".."bar9"]
04:57:59 <lambdabot>       No instance for (Enum [Char])
04:57:59 <lambdabot>        arising from the arithmetic sequen...
04:58:03 <osfameron> nope
04:58:04 <Gracenotes> no.
04:58:05 <maxote> for undecidable construction in System F_2, i think the a Virtual Machine is required for typechecking again in running time
04:58:08 <Valodim> everything increments if you define the instance...
04:58:08 <Olathe> You can make an Enum easily enough.
04:58:29 <Olathe> What we need is enumerable CReals.
04:59:00 <Gracenotes> > sequence (replicate 4 [' '..])
04:59:02 <lambdabot>   ["    ","   !","   \"","   #","   $","   %","   &","   '","   (","   )","  ...
04:59:11 <Gracenotes> > sequence (replicate 3 ['a'..]) --better
04:59:13 <lambdabot>   ["aaa","aab","aac","aad","aae","aaf","aag","aah","aai","aaj","aak","aal","a...
04:59:29 <Gracenotes> > length . sequence $ replicate 3 ['a'..]
04:59:38 <RayNbow> Olathe: it would be pretty awesome if they were enumerable :p
04:59:39 <lambdabot>   mueval: Prelude.read: no parse
05:00:00 <QtPlaty[hireme]> Gracenotes: Could you do that so it did first one char strings then two char strings ...
05:01:23 <maxote> in F_1 -> functions as values of 1st class ; in F_2 -> types as values of 1st class ; what about F_3 does XXX as values of 1st class?
05:02:32 <quicksilver> > [1..4] >>= flip replicateM ['a'..'e']
05:02:36 <lambdabot>   ["a","b","c","d","e","aa","ab","ac","ad","ae","ba","bb","bc","bd","be","ca"...
05:02:41 <quicksilver> QtPlaty[hireme]: yes.
05:02:47 <TimGoodwin> it gets worse: I removed ~/.cabal, and now the build fails thusly http://www.mibbit.com/pb/H4GXM8
05:05:42 <wli> Now that I can connect definitions to uses, what do I do now?
05:05:53 <Gracenotes> QtPlaty[hireme]: sorry about that... sometimes ghci just doesn't know when to stop using your memory :/
05:05:55 <Gracenotes> QtPlaty[hireme]: was your question answered?
05:06:13 <quicksilver> > [1..4] >>= flip replicateM ['a'..'c']
05:06:15 <lambdabot>   ["a","b","c","aa","ab","ac","ba","bb","bc","ca","cb","cc","aaa","aab","aac"...
05:06:15 <quicksilver> Gracenotes: &&
05:06:21 <quicksilver> ^^, rather.
05:07:02 <QtPlaty[hireme]> Gracenotes: Looks like quicksilver was able to do it.
05:08:28 <quicksilver> replicateM is sequence after replicate, by the way.
05:08:31 <Gracenotes> okay :) I have a sequence version somewhere in my code archives...
05:08:44 <Gracenotes> that doesn't use replicate, that is
05:08:51 <Gracenotes> might be mistaken though
05:11:28 <crem|work> How can I get nth element of a list?
05:11:42 <Botje> list !! n
05:11:44 <Gracenotes> QtPlaty[hireme]: hm... I know I have it! lemme see x.x
05:11:44 <wli> xs !! n
05:11:48 <Botje> it's zerobased
05:11:49 <crem|work> thanks
05:13:50 <QtPlaty[hireme]> > length ['a'..]
05:13:51 <lambdabot>   1114015
05:14:23 <QtPlaty[hireme]> > [1..] >>= flip replicateM ['a'..]
05:14:25 <lambdabot>   ["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s...
05:20:38 <Gracenotes> > (inits . repeat) ['a'..'c'] >>= sequence
05:20:39 <lambdabot>   ["","a","b","c","aa","ab","ac","ba","bb","bc","ca","cb","cc","aaa","aab","a...
05:20:58 <Gracenotes> QtPlaty[hireme]: there :)
05:21:02 <ivanm> Gracenotes: probably want a tail on that...
05:21:24 <Gracenotes> ivanm: how so?
05:21:36 <quicksilver> Gracenotes: well, repeat is very closely related to replicate in the list monad, of course.
05:21:37 <ivanm> Gracenotes: unless you want the "" there at the beginning...
05:21:52 * ivanm has no idea what Gracenotes is actually doing though...
05:22:06 <Gracenotes> it's a member of the alphabet [a..c]*
05:22:18 <Gracenotes> something that enumerates all strings in an alphabet, one could say
05:22:20 <ivanm> oh, OK
05:23:31 <ivanm> going through byorgey's typeclassopedia... how is [] normally made an instance of Applicative?
05:23:59 <Gracenotes> quicksilver: it is closely related.. ish.. :x
05:24:40 <Gracenotes> although, with inits the enumeration of various lengths is implicit. With replicateM, it's explicit
05:25:12 <quicksilver> agreed.
05:26:02 <quicksilver> ivanm: in the way which agrees with the list monad.
05:26:08 <ivanm> which is?
05:26:20 <quicksilver> > [(+1),(*2)] <*> [3,6]
05:26:21 <lambdabot>   [4,7,6,12]
05:26:24 <ivanm> he gives a zip-version and a nondeterministic-version... I take it the latter is closer to the monad?
05:26:36 <quicksilver> nondeterminism, yes.
05:27:12 <quicksilver> > [(+),(*)] <*> [3,5] <*> [7,11]
05:27:14 <lambdabot>   [10,14,12,16,21,33,35,55]
05:28:13 <RayNbow> > let f n xs = filter ((==n).length) (take n <$> tails xs) in f 2 [1..10]  -- hmm, what's a good name for f?
05:28:14 <lambdabot>   [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7],[7,8],[8,9],[9,10]]
05:29:07 <Gracenotes> > let f n xs = filter ((==n).length) (take n <$> tails xs) in f 5 [1..10]
05:29:08 <lambdabot>   [[1,2,3,4,5],[2,3,4,5,6],[3,4,5,6,7],[4,5,6,7,8],[5,6,7,8,9],[6,7,8,9,10]]
05:30:14 <Gracenotes> subsequences?
05:30:37 <Gracenotes> in the spirit of inits and tails..
05:30:43 <quicksilver> RayNbow: checking the length of all of them seems like an expensive choice.
05:31:09 <RayNbow> Gracenotes: Data.List.subsequences does something different than f though
05:31:13 <quicksilver> RayNbow: better to work out how many will be the right length which is a one time calculation.
05:31:21 <quicksilver> subsequences can mean more than one thing :)
05:31:36 <Gracenotes> RayNbow: oh, didn't know it existed. subsequencesWithLength, then, although an abbreviation
05:31:41 <Gracenotes> of it
05:32:24 <Gracenotes> infixWithLength... hrm
05:33:00 <Gracenotes> @type subsequences
05:33:01 <lambdabot> Not in scope: `subsequences'
05:33:04 <Gracenotes> wha
05:33:05 <RayNbow> GHC 6.10
05:33:24 <RayNbow> quicksilver: hmm, but it might not be always possible to compute how many will have the right length
05:33:47 <wli> Given a string, construct a Data.Map from subsequences of the list to sets of positions in the input list where the corresponding subsequences occur...
05:33:52 <quicksilver> RayNbow: it's (length xs - n + 1)
05:33:54 <quicksilver> RayNbow: isn't it?
05:34:04 <RayNbow> what if xs is infinitely long?
05:34:14 <quicksilver> ah, fair point.
05:34:55 <RayNbow> although if we know xs will always be infinitely long... we don't need to filter at all :p
05:35:24 <luite_> ah, just check whether it's infinite then ;)
05:35:25 <guenni> how can I check on what thunks are piling up on the stack?
05:35:33 <Gracenotes> well, if the length requirement fails at one point, it'll fail for everything after that point
05:36:00 <RayNbow> Gracenotes: ah right... so takeWhile might be a better :)
05:36:35 <Gracenotes> foldr (.) id (replicate n init)  :)
05:37:09 <Gracenotes> a messy way to go about it, but one that should work
05:37:18 <Gracenotes> @src init
05:37:18 <lambdabot> init [x]    = []
05:37:18 <lambdabot> init (x:xs) = x : init xs
05:37:18 <lambdabot> init []     = undefined
05:38:00 <Alpounet> @src words
05:38:01 <lambdabot> words s = case dropWhile isSpace s of
05:38:01 <lambdabot>     "" -> []
05:38:01 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
05:38:12 <Gracenotes> messy probably meaning slow
05:38:59 <wjt> quicksilver: it is! i would like condApply
05:40:24 <RayNbow> > foldr (.) id (replicate 2 init)  [1..10]
05:40:25 <lambdabot>   [1,2,3,4,5,6,7,8]
05:41:27 <Gracenotes> > scanr (.) id (replicate 3 init) [1..5]
05:41:28 <lambdabot>   Couldn't match expected type `[t1] -> t'
05:41:33 <Gracenotes> :/x
05:41:43 <Gracenotes> oh, yeah. hrm.
05:42:38 <wjt> @undo do { x <- m; guard (p x); return x }
05:42:38 <lambdabot> m >>= \ x -> guard (p x) >> return x
05:42:42 <wjt> @. pl undo do { x <- m; guard (p x); return x }
05:42:43 <lambdabot> ap ((>>) . guard . p) return =<< m
05:43:12 <wjt> this feels like a variation on the theme of m <* p but with a version of <* more akin to >>= than to >>
05:43:28 <koeien> is unsafeAt always zero-based ?
05:43:43 <koeien> just replacing a working program's (!) with unsafeAt yields a segfault
05:43:49 <quicksilver> wjt: I've needed that one once or twice, too.
05:44:05 <quicksilver> koeien: yes, it's "after" the index scaling is done
05:44:07 <quicksilver> :t (!)
05:44:09 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
05:44:13 <quicksilver> :t unsafeAt
05:44:14 <lambdabot> Not in scope: `unsafeAt'
05:44:24 <Gracenotes> @hoogle unsafeAt
05:44:24 <wjt> I think 'provided' is a nice name for it
05:44:24 <lambdabot> Data.Array.Base unsafeAt :: (IArray a e, Ix i) => a i e -> Int -> e
05:44:25 <quicksilver> koeien: note that the type of unsafeAt is Int, whilst the type of (!) is 'i'
05:44:40 <koeien> quicksilver: in my case they are both Int. that is probably what caused confusion
05:44:43 * quicksilver nods
05:44:47 <wjt> because you can then say "<something returning Maybe a> `provided` predicate"
05:44:56 <koeien> quicksilver: thanks
05:44:58 <quicksilver> wjt: I like that.
05:45:27 <quicksilver> wjt: I note that if you apply 'provided' to lists, you get 'filter'.
05:45:39 <wjt> quicksilver: oh, that's interesting
05:45:51 <wjt> that's a very nice generalization
05:46:02 <Gracenotes> provided defined for MonadPlus?
05:46:25 <wjt> Gracenotes: provided m p = do x <- m; guard (p x); return x
05:46:38 <Gracenotes> ah. so MonadPlus
05:46:42 <wjt> yeah
05:47:51 <wjt> I'm also sure that 'lastJust :: (a -> Maybe a) -> a -> a; lastJust f x = maybe x (lastJust f) (f x)' should be expressible more concisely
05:47:55 <Gracenotes> provided :: MonadPlus m => m a -> ma
05:48:05 <Gracenotes> provided :: MonadPlus m => m a -> (a -> Bool) -> ma
05:48:07 <wjt> indeed
05:48:09 <Gracenotes> yeah. second :/
05:48:15 <Gracenotes> s/ma/m a/
05:48:17 <wli> > let f s = Map.unionsWith IntSet.union [Map.fromList [(y, IntSet.singleton k) | y <- tail $ inits x] | (k :: Int, x) <- zip [0 ..] (init $ tails s)] in f "abab"
05:48:18 <lambdabot>       Failed to load interface for `IntSet':
05:48:18 <lambdabot>        Use -v to see a list of t...
05:48:30 <Gracenotes> @type (<*)
05:48:30 <wli> You've got to be kidding...
05:48:31 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
05:49:10 <quicksilver> :t Data.IntSet.singleton
05:49:11 <lambdabot> Int -> IS.IntSet
05:49:21 <quicksilver> :t IS.singleton
05:49:22 <lambdabot> Int -> IS.IntSet
05:49:22 <Gracenotes> @type (?m <* guard ?b)
05:49:24 <lambdabot> forall (f :: * -> *) a. (Applicative f, MonadPlus f, ?b::Bool, ?m::f a) => f a
05:49:30 <quicksilver> wli: imported as 'IS' it seems.
05:49:54 <Gracenotes> @type \b m -> b m <* guard (b m)
05:49:55 <lambdabot>     Couldn't match expected type `Bool' against inferred type `f a'
05:49:55 <lambdabot>       Expected type: t -> Bool
05:49:55 <lambdabot>       Inferred type: t -> f a
05:50:06 <wjt> Gracenotes: <* doesn't give the right argumetn the result of the left
05:50:19 <Gracenotes> yeah, you need to quote-extract-unquote the m first
05:50:34 <Gracenotes> which applicatives are not too keen on :)
05:50:41 <wli> lambdabot still doesn't like IS
05:50:54 <quicksilver> > IS.singleton 1
05:50:55 <lambdabot>   /tmp/8334608454839250884:70:36: Not in scope: `IS.singleton'
05:51:06 <quicksilver> > Data.IntSet.singleton 1
05:51:07 <lambdabot>   /tmp/214917515105875132:70:36:
05:51:07 <lambdabot>      Not in scope: `Data.IntSet.singleton'
05:51:13 <quicksilver> don't understand that.
05:51:19 <quicksilver> Cale: why does that happen?
05:51:24 <RayNbow> @let dropLast n = foldr (.) id (replicate n init)
05:51:25 <lambdabot>  Defined.
05:51:34 <RayNbow> > let f n = dropLast n . (take n <$>) . tails   in   f 2 [1..10]  -- thx, Gracenotes :)
05:51:35 <lambdabot>   [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7],[7,8],[8,9],[9,10]]
05:51:47 <Saizan_> i guess Data.IntSet is not imported
05:52:16 <Gracenotes> quicksilver: because of Deeper Magic from before the dawn of time
05:52:43 <quicksilver> Saizan_: but why can :t see it?
05:52:45 <Gracenotes> RayNbow: sure :D only thing is, dropLast seems rather inefficient.
05:52:57 <quicksilver> Saizan_: every time @type is different from @run, there is a bug.
05:52:59 <wli> > let f s = Map.unionsWith Set.union [Map.fromList [(y, Set.singleton k) | y <- tail $ inits x] | (k :: Int, x) <- zip [0 ..] (init $ tails s)] in f "abab"
05:53:01 <lambdabot>   fromList [("a",fromList [0,2]),("ab",fromList [0,2]),("aba",fromList [0]),(...
05:53:09 <quicksilver> I don't understand why it happens so often.
05:53:32 <Gracenotes> RayNbow: yeah, you're piling one init application on top of the other, which is kept as a thunk. best used for small numbers, methinks :x
05:53:32 <wli> I don't understand how lambdabot's Haskell evaluation is so fscking screwed up.
05:53:48 <Gracenotes> the nice part is that it works for infinite lists, but the inits are always there
05:54:34 <wli> If anything, just dump to a temporary file, open a pipe up to ghci, and get on with it.
05:57:16 <Saizan_> quicksilver: :t just calls ghci, and fully qualified identifiers are always in scope there, for @run we can't allow that
05:57:33 <Saizan_> quicksilver: oh, now i see that IS works too
05:57:40 <Saizan_> quicksilver: that's a bug
05:57:47 <wli> IS works where?
05:58:02 <Saizan_> wli: only for @type
05:58:14 <quicksilver> Saizan_: given that @run can't use ghci, @type should also not use ghci - @type should use the same mechanism @run uses, IMO. That would guarantee consistency.
05:58:26 <wli> Well, slightly more interesting is
05:58:29 <wli> > let f s = Map.unionsWith Set.union [Map.fromList [(y, Set.singleton k) | y <- tail $ inits x] | (k :: Int, x) <- zip [0 ..] (init $ tails s)] in Map.filterWithKey (\k is -> length k > 1 && Set.size is > 1) $ f "now is the winter of our discontent"
05:58:30 <lambdabot>   fromList [(" o",fromList [17,20]),("is",fromList [4,26]),("nt",fromList [13...
05:59:16 <yitz> annoying - I sent a post to cafe, and it is being held for moderation due to a "suspicious header"
05:59:17 <Saizan_> quicksilver: good point
05:59:46 <wli> wtf. does @run use if not ghci?
05:59:50 <SamB> yitz: did it say which one?
05:59:56 <yitz> the moderator appears to be JaffaCake, who is quite busy. is there anyone else who can free up my post?
06:00:02 <yitz> SamB: no
06:00:04 <Saizan_> wli: mueval, currently
06:00:13 <SamB> yitz: is he?
06:00:33 <yitz> busy? I have no doubt.
06:00:46 <wli> How is mueval screwing up library imports?
06:01:03 <SamB> yitz: I told him anyway ;-P
06:01:07 <Saizan_> wli: different import lists are used
06:01:19 <yitz> SamB: thanks
06:02:07 <ImInYourMonad> would there be a market for far-from-perfect speech-translation? ie google translate for speech? I mean obv if it could do perfect translation it would be but that would be incrdibly hard. is Google working on somehting like this?
06:02:11 <wli> I have to wonder if there's a way to do this better.
06:03:54 <Saizan_> @version
06:03:54 <lambdabot> lambdabot 4.2.2
06:03:54 <lambdabot> darcs get http://code.haskell.org/lambdabot
06:04:00 <SamB> ImInYourMonad: that sounds incredibly hard
06:04:23 <koeien> hmm, it appears that unsafeAt makes it slower 8)
06:04:48 <SamB> do you have any idea how hard it is for a non-fluent speaker to figure out where a native speaker's words begin and end?
06:04:53 <ImInYourMonad> SamB: yes probably something for 2100 but it is cool
06:05:52 <bastl> hi, i try to run a compiled program on another host and get: error while loading shared libraries: libedit.so.2: cannot open shared object file. How can I know on what shared libs my program depends ?
06:06:02 <koeien> bastl: ldd
06:06:04 <kiris> as I understand it, google's translation depends on a massive corpus
06:06:51 <kiris> getting a massive, realiable corpus of speech might be hard
06:07:03 <drhodes> I was thinking movies with subtitles
06:07:03 <daf> you can get the Google corpus
06:07:10 <daf> oh, audio corpus
06:07:17 <drhodes> the words are there, somewhat linked to the audio track.
06:07:27 <bremner> bastl: there are two different ghc binaries for two different versions of libedit. Maybe that is relevant...
06:07:44 <daf> drhodes: hah, I wonder if that would work
06:08:21 <daf> for languages like English, you have to cope with the non-trivial correspondance between the text and the phonetics
06:09:00 <quicksilver> daf: only if you're actually trying to make a phonetic model.
06:09:17 <quicksilver> if you're content to make a word-level model, you can ignore spelling and phonetics entirely.
06:09:29 <quicksilver> I'm not sure that makes it 'easier' ;)
06:09:41 <daf> hmm
06:09:59 <daf> a word-level model would still have to deal with conjugation and declination
06:10:00 <bastl> what package would provide libedit !?
06:10:07 <bastl> ( i have to tell my admin to install it ..)
06:10:24 <koeien> bastl: what distro?
06:10:30 <bastl> suse
06:10:33 <koeien> bastl: libedit2 on debian
06:10:56 <bastl> hmm, sounds as if that shouldbe installed on avery normal host ..
06:11:11 <koeien> bastl: i had to install it specifically for GHC as well
06:11:21 <yitz> daf: I worked with a nice corpus of English spelling <-> phonetics almost 30 years ago. Don't know where it is now though.
06:11:25 <bastl> ok, ill ask him
06:11:57 <daf> yitz: mm, I get the impression these things tend to disappear :(
06:12:16 <daf> either that, or people try to sell them for lots of money
06:12:21 <yitz> daf: it was made by Sue Hertz at the Lingustics dept. at Cornell. I'll bet she'd give it to you if you asked.
06:12:23 <drhodes> audiobooks might be a good source too
06:14:09 <vladsharp> yitz: that's what she said... wait.
06:14:11 <yitz> daf: she generated it using a really nice set of rules. not so trivial for English. it was for a text-to-speech synthesis system.
06:14:24 <mmorrow> yitz: is it working for you now?
06:14:34 <mmorrow> (i haven't changed anything)
06:14:38 * yitz checks hpaste
06:15:17 <daf> yitz: well, that's nice to know, but I probably wouldn't do anything useful with it :)
06:15:29 <quicksilver> hpaste.org works for me, FWIW.
06:15:52 <yitz> mmorrow: http://hpaste.org/ gives a plain white page with only the word "hello."
06:17:10 <yitz> mmorrow: deep links to the fastcgi do work though. thanks.
06:17:24 <quicksilver> yitz: sounds like something broken + locally cached
06:17:33 <yitz> ah, good point.
06:17:47 <quicksilver> http://hpaste.org/ works for me form two different machines on different net connections
06:17:52 <yitz> yes, a reload fixed it
06:17:57 <yitz> thanks
06:19:21 <yitz> daf: truth is, there are several open source text-to-speech systems out there nowadays. festival, etc. I'm sure you could get it from there.
06:19:52 <daf> yitz: yeah, probably
06:20:33 <ImInYourMonad> yitz: age?
06:21:02 <yitz> whose?
06:21:33 <ImInYourMonad> daf: how can you egt the googlecorpus?
06:21:38 <luite_> does Tim Docker, (author of haskell charts) visit this channel?
06:21:50 <ImInYourMonad> you mean just collect stuff manually?
06:21:50 <ImInYourMonad> but yeah procssing such an amount of audio would probanly not be feasible today
06:22:25 <daf> ImInYourMonad: hmm, maybe you can only get it in N-gram form
06:22:27 <yitz> ImInYourMonad: also, google doesn't like people spidering their site.
06:23:16 <ivanm> yitz: but it's perfectly OK for them to spider everyone else's? :o
06:23:23 <ivanm> *sniff* how rude!
06:23:23 <bastl> any SuSE -cracks around? how do I get libedit.so.2 !?
06:23:30 <yitz> ivanm: you got it!
06:23:46 <EvilTerran> ivanm, i doubt everyone's; i suspect they obey robots.txt, and expect others to do likewise
06:23:58 <ivanm> bastl: /me guesses a package called "libedit"
06:24:12 <ivanm> EvilTerran: yes, but do they filter out their entire site in their robots.txt?
06:25:10 <wli> > let un = Map.unionWith Set.union in Map.filterWithKey (\k v -> length k > 1 && Set.size v > 1) . (\(_, u, v) -> u `un` v) $ flip execState (0, Map.empty, Map.empty) $ mapM_ (\c -> do { (k, m, m') <- get ; put (k + 1, m `un` m', Map.mapKeys (++[c]) m' `un` Map.singleton [c] (Set.singleton k)) }) (concat $ replicate 4 "abc")
06:25:11 <yitz> ivanm: see http://google.com/robots.txt
06:25:11 <lambdabot>   fromList [("ab",fromList [0,3,6,9]),("abc",fromList [0,3,6,9]),("abca",from...
06:25:56 * ivanm finds "6" allows in that entire list...
06:26:08 <bastl> ivanm: thanks, but that is installed.
06:26:13 <ivanm> yitz: of course, by looking at that list we know which bits of google are the interesting ones... ;-)
06:26:19 <wli> That has the nicety that it builds up the data structures based on list traversal, but the disadvantage that it constructs the substrings in the reverse order. :(
06:26:32 <ivanm> bastl: does "locate libedit.so" return anything?
06:27:26 <yitz> wli: trie?
06:27:38 <bastl> ivanm: yes. but ldd on my binary says i need libedit.so.2 (instead of .0 or .0.0.26 which locate reports)
06:27:46 <bastl> should i symlink ?
06:27:53 <quicksilver> no.
06:27:55 <quicksilver> .2 is not .0
06:28:05 <quicksilver> at least, I don't think that will work :)
06:28:07 <wli> yitz: That would be better than Data.Map for most of these purposes.
06:28:11 <ivanm> bastl: :(
06:28:11 <bremner> bastl: I think .so.2 is the debian/ubuntu version. Can you relink on the target?
06:28:12 <bastl> OT: what do these suffixes mean?
06:28:28 <ivanm> bremner: I have .so.2, and I'm not using any debian derivative...
06:28:29 <bremner> version of shared library
06:28:30 <yitz> bastl: perhaps just get the source and build it?
06:28:37 <bremner> ivanm: okay
06:29:06 <ivanm> I take it back: I just have .so
06:29:08 <ivanm> not .so.2
06:29:09 <ivanm> :s
06:29:32 <Gracenotes> > (read . show . Map.fromList $ [(1,2),(3,4),(5,6)]) `asTypeOf` Set.singleton (0,0)
06:29:33 <lambdabot>   fromList [(1,2),(3,4),(5,6)]
06:29:37 <bremner> ivanm: no so version?  is this MacOS or something bizarre?
06:29:43 <bastl> hm. gtg, thanks for the help ill leave it to our sysadmin. he has magic hands.
06:29:51 <ivanm> bremner: gentoo ;-)
06:30:10 <ivanm> note that this is for version 20061103 (whatever that means)
06:30:12 <bremner> ivanm: so yes, then :-)
06:30:16 <ivanm> heh
06:30:20 <mmorrow> yitz: cool
06:38:24 <TimGoodwin> If anyone was interested in my ghc-6.10.1 install problem... I fixed it by "rm -r ~/.cabal ~/.ghc"
06:39:09 <PeakerWork> community.haskell.org is down, gonna be up any time?
06:39:56 <TimGoodwin> hmm... ghci seems to be talking to my terminal in raw mode! ^D doesn't work for EOF, nor does delete / backspace...
06:40:04 <SamB> I think Igloo is fiddling with community.haskell.org
06:40:07 <TimGoodwin> Can I make ghci use readline?
06:40:34 <SamB> TimGoodwin: you could recompile
06:41:00 <TimGoodwin> SamB: "sh configure --help" doesn't offer a "--with-readline" or similar that I recognise
06:41:08 <TimGoodwin> Do you know the runes?
06:43:35 <quicksilver> PeakerWork: the logo contest has taken it out :P
06:43:40 <PeakerWork> quicksilver: ah
06:43:47 <PeakerWork> quicksilver: I wanted to see the logos, it said I was a voter, woohoo
06:44:02 <quicksilver> apparently you weren't the only one :P
06:44:23 <wjt> HASKELL YEAAAAAAAAAAAAAAH
06:45:15 <SamB> should be back up now
06:46:55 <wli> Data.Sequence saves the day.
06:47:02 <quicksilver> 112 ("do <- haskell") would be a lousy logo for the project as a whole, but it might be a nifty logo for a publicity sub-project.
06:47:11 <wli> > let un = Map.unionWith Set.union in Map.filterWithKey (\k v -> Sequence.length k > 1 && Set.size v > 1) . (\(_, u, v) -> u `un` v) $ flip execState (0 :: Int, Map.empty, Map.empty) $ Data.Foldable.mapM_ (\c -> do { (k, m, m') <- get ; put (k + 1, m `un` m', Map.mapKeys (flip (Sequence.|>) c) m' `un` Map.singleton (Sequence.singleton c) (Set.singleton k)) }) (Sequence.fromList . concat $ replicate 4 "abc")
06:47:12 <lambdabot>   fromList [(fromList "ab",fromList [0,3,6,9]),(fromList "abc",fromList [0,3,...
06:50:27 <TimGoodwin> hmm... looks to me like building ghc should automatically pick up readline - but it didn't for me
06:51:17 <bremner> TimGoodwin: ghc uses editline instead of readline]
06:52:00 <TimGoodwin> Which editline? That name's been used by various different projects, including *BSD of course
06:52:46 <bremner> TimGoodwin: that one. It is all documented on the ghc site
06:54:33 <TimGoodwin> bremner: thanks for the pointer - will RTFM!
06:54:37 <wli> Either something is re-exporting the mapM_ definition from Control.Monad.State or ghci has a bug where it's showing up in scope despite being explicitly hidden.
06:58:47 <wli> I think it's a ghci bug because I can use the name mapM_ unqualified in the file with all the imports.
07:00:23 <koeien> does the function 'par' exist in ghc-6.8.2
07:00:55 <koeien> ah never mind, debian overzealous package breaking
07:01:08 <temoto-alt> Hello. To get number from string use    read   function, right?
07:01:48 <Alpounet> yes
07:02:01 <SamB> > read "hi!" :: Integer
07:02:03 <lambdabot>   * Exception: Prelude.read: no parse
07:02:12 <SamB> hmm. apparantly there are some restrictions!
07:02:16 <Alpounet> > read "1" :: Integer
07:02:17 <lambdabot>   1
07:02:24 <temoto-alt> > read "2.4"
07:02:25 <lambdabot>   * Exception: Prelude.read: no parse
07:02:34 <temoto-alt> :t read
07:02:35 <lambdabot> forall a. (Read a) => String -> a
07:02:41 <temoto-alt> What's Read?
07:02:44 <wli> I could probably use foldl' for this.
07:02:46 <SamB> @src Read
07:02:46 <lambdabot> class Read a where
07:02:46 <lambdabot>   readsPrec    :: Int -> ReadS a
07:02:46 <lambdabot>   readList     :: ReadS [a]
07:02:46 <lambdabot>   readPrec     :: ReadPrec a
07:02:46 <lambdabot>   readListPrec :: ReadPrec [a]
07:02:48 <Alpounet> a typeclass
07:02:53 <temoto-alt> oh
07:02:59 <SamB> @src ReadS
07:02:59 <lambdabot> Source not found. I feel much better now.
07:03:00 <temoto-alt> Thanks.
07:04:51 <temoto-alt> I don't get how to make use of readList.
07:05:22 <wli> foldl' did it
07:06:38 <koeien> why don't Data.Set functions show up in my profiler report?
07:07:26 <koeien> are they inlined?
07:08:17 <Saizan_> maybe the package wasn't compiled with -auto-all?
07:08:37 <wli> This substring stuff could be interesting from the POV of nondeterministic LBA's.
07:08:56 <koeien> Saizan_: yes, it was. i don't know if Data.Set is though :)
07:09:15 <koeien> i did install ghc6-prof
07:09:30 <Saizan_> koeien: yeah, i was referring to the package Data.Set is in, containers iirc
07:10:10 <koeien> libghc6-containers-prof is installed
07:10:45 <wli> (The question becomes how to dynamically maintain the substring map as an LBA carries out reductions all over the place.)
07:10:46 <PeakerWork> LBA's?
07:11:01 <wli> PeakerWork: Linear Bounded Automata
07:11:06 <koeien> guessing: linear bounded automatons :)
07:11:43 <PeakerWork> ah. I know its Linear Block Address :)
07:12:22 <wli> PeakerWork: The thing about linear-bounded automata is that they have to search the entire input for a substring to carry out a reduction on in order to parse, and so they have to deal with nonterminals scattered all through the input.
07:13:16 <wli> PeakerWork: When you have multistage parsing, you get the same phenomenon of nonterminals scattered all throughout the input that other automata can't deal with very well if at all.
07:13:32 <wli> PeakerWork: This arises with e.g. fixity decls.
07:15:50 <wli> PeakerWork: I guess what really happens is that you have some highly tractable grammar class, but the need to cope with nonterminals floating around the middle of the input vs. the order in which parsing would usually be carried out e.g. leftmost/rightmost derivations (or any predetermined derivation order at all).
07:17:07 <jeffwheeler> For some reason, I tried voting in the logo contest and I got a 404 response the first time; retrying worked.
07:17:20 <jeffwheeler> (On submission, I mean.)
07:18:21 <wli> PeakerWork: CYK does not sound like an attractive proposition here. There should be some way to leverage the tractability of the grammar to reduce the complexity to something manageable.
07:18:52 <wli> PeakerWork: I'm thinking that first/follow sets may have to be generalized to include nonterminals.
07:20:32 <wli> PeakerWork: Actually that's the whole of the answer.
07:21:58 <mreh> did anyone here participate in a haskell project with GSOC last year?
07:22:16 <mreh> or prior to that even
07:22:35 <wli> Just do LR(1)/whatever and when you build the dispatch tables with lookaheads etc. use that generalization to include nonterminal symbols.
07:32:04 <guenni> Data.Map is an abstract data type, so there is no way to do pattern matching on it?
07:33:10 <Saizan_> that's more or less the definition, yes
07:33:21 <guenni> Saizan_: thx
07:34:10 <Saizan_> since ghc-6.10.1 you can use ViewPatterns though
07:35:16 <Saizan_> like foo (minView -> (x,m)) = ..
07:36:59 <guenni> Saizan_: sounds interesting, where can I read more?
07:37:34 <lilac> , let go (minViewWithKey -> Just ((k, v), m)) = v:go m; go (minViewWithKey -> Nothing) = [] in go $ fromList [(4,'l'),(2,'e'),(3,'l'),(1,'H'),(5,'o')]
07:38:47 <lilac> @botsmack
07:38:48 <lambdabot> :)
07:38:52 <lilac> @seen lunabot
07:38:52 <lambdabot> I saw lunabot leaving #haskell 8h 52m 28s ago, and .
07:39:38 <Saizan_> @google ghc manual ViewPatterns
07:39:40 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html
07:39:40 <lambdabot> Title: 8.3.Syntactic extensions
07:40:04 <Saizan_> guenni: section 8.3.5 ^^^
07:40:16 <guenni> Saizan_: many thanks
07:40:23 <BONUS> how come it says "pattern matches are overlapped" when i try to define something like f (tail -> x:xs) = x:x:xs
07:40:44 <lilac> cleaner: let go (minViewWithKey -> view) | Just ((k, v), m)) <- view = v:go m | Nothing <- view = [] in go $ fromList [(4,'l'),(2,'e'),(3,'l'),(1,'H'),(5,'o')]
07:40:58 <lilac> view patterns + pattern guards ftw
07:41:10 <ImInYourMonad> if I have f :: (IO Int, IO Int); x <- fst f; y <- snd y; then it wont do f twice meaning 4 -computations but just do the lft tuple and then the right tuple, 2 computations?
07:41:17 <lilac> BONUS: i guess it's parsed as f ((tail -> x):xs) ?
07:41:41 <BONUS> lilac: nah, does the same if i  put parens around x:xs
07:42:04 <BONUS> ImInYourMonad: y <- snd y?
07:42:14 <BONUS> you mean y <- snd f?
07:42:33 <ImInYourMonad> ys
07:43:08 <ImInYourMonad> yes
07:43:18 <ImInYourMonad> f :: (IO Int, IO Int); x <- fst f; y <- snd f;
07:43:23 <BONUS> (IO Int, IO Int) is a pair of seperate I/O actions. so when you do x <- fst f; y <- snd f; you're saying: perform the first one, call its result x and then perform the second one, call its result y
07:43:27 <lilac> ImInYourMonad: GHC should only evaluate f once in that case (in general, values bound to names tend to only get evaluated once)
07:43:38 <BONUS> ah wait that was your question ah
07:43:38 <BONUS> i see
07:44:01 <lilac> ImInYourMonad: but evaluating f means reducing it to WHNF, which means only evaluating until a tuple is produced, not until the values within the tuple are produced
07:44:22 <BONUS> or performed
07:45:40 <lilac> ImInYourMonad: if you have "let f = foo 1 2 3 in do x <- fst f; y <- snd f; return (x,y)" then foo will (probably) only be called once
07:46:06 <lilac> ImInYourMonad: if you change that to "do x <- fst (foo 1 2 3); y <- snd (foo 1 2 3); return (x, y)" then foo will (probably) be called twice
07:46:42 <lilac> semantically, they're the same, but GHC does try to respect your wishes with regard to sharing
07:47:01 <ImInYourMonad> i see
07:49:40 <trofi^w> @src HashTable
07:49:41 <lambdabot> Source not found. That's something I cannot allow to happen.
07:55:50 <cnwdup> I've written a parser for ID3v2 tags and now I've noticed to search for a tag I have to be able to seek in the file. Can this be achieved by ByteStrings or what else should I use to store the file?
07:56:21 <BONUS> @hoogle hSeek
07:56:21 <lambdabot> System.IO hSeek :: Handle -> SeekMode -> Integer -> IO ()
07:56:30 <BONUS> you can seek, no problem :]
07:56:48 <Saizan_> indexing should be O(1) with strict BS
07:57:29 <cnwdup> > B.pack "Hello World"
07:57:30 <lambdabot>       Failed to load interface for `B':
07:57:30 <lambdabot>        Use -v to see a list of the fi...
08:00:27 <cnwdup> Saizan_, BONUS, thanks. (:
08:01:13 <trofi^w> @help let
08:01:13 <lambdabot> let <x> = <e>. Add a binding
08:01:21 <trofi^w> @list
08:01:21 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
08:01:55 <Gracenotes> > BS.pack ":O :O :O :O :O :O : : :O  :O :O :O"
08:01:56 <lambdabot>   Couldn't match expected type `Word8' against inferred type `Char'
08:02:15 <Gracenotes> > ":O :O :O  O:::OB:O O O: O::O O: O:  : O :O:O:ODOMGGO MHELP"
08:02:16 <lambdabot>   ":O :O :O  O:::OB:O O O: O::O O: O:  : O :O:O:ODOMGGO MHELP"
08:03:00 <fasta> Gracenotes: I don't think you can send in another logo.
08:04:17 <cnwdup> let s = BS.pack (map (fromIntegral . ord) "ID3"); str = BS.pack (map (fromIntegral . ord) "ID3hello lolID3endend") in BS.breakSubstring s str
08:04:20 <cnwdup> > let s = BS.pack (map (fromIntegral . ord) "ID3"); str = BS.pack (map (fromIntegral . ord) "ID3hello lolID3endend") in BS.breakSubstring s str
08:04:21 <lambdabot>   /tmp/6068550357774225034:70:52: Not in scope: `BS.pack'/tmp/606855035777422...
08:05:22 <ImInYourMonad> hmm,what exactly is reactiveprogramming? im so stupid soemtimes,yesterday iw as trying to make the computer mov by having a loop. but duh onClicked then move...talking Go here
08:05:34 <ImInYourMonad> but isnt onClicked reactive progrmaming?
08:07:30 <cnwdup> Suppose I write a parser which isn't consuming the input by using B.uncons but which is storing the position of the current char and consumes it by using index and increment the internal position. Would this be memory inefficient or is Haskell smart enough to handle this well?
08:13:31 <ImInYourMonad> is it possible to skin buttons in gtk2hs?
08:14:30 <Shamgar> Hey guys.  I'm trying to build QuickCheck 2.1 under GHC 6.10.1, and I get an error.
08:14:33 <Shamgar> Test/QuickCheck/Exception.hs:12:31: Class `Exception' used as a type In the type `Exception' In the type `Either Exception a' In the type `IO (Either Exception a)'
08:15:12 <Shamgar> when I search for it, the only real hit I get is an IRC discussion from last year where someone was saying it was broken.
08:15:26 <Shamgar> can anyone lend a hand here?
08:15:51 <Saizan_> cnwdup: i think the two are operationally equivalent
08:16:13 <Saizan_> Shamgar: use --constraint="base < 4"
08:16:25 <Saizan_> Shamgar: when configuring
08:17:59 <cnwdup> Saizan_, okay. Thanks.
08:18:49 <ImInYourMonad> can I store grk2hs-Buttons in a datastructure?
08:20:04 <Saizan_> cnwdup: bytestrings are represented as (pointer,length,offset) so taking the tail just decrements the length and increments the offset, which is pretty similar to incrementing the index
08:21:48 <Shamgar> thanks!  that works
08:24:00 <osfameron> ImInYourMonad: I think you have to sew them on with gtk2hs-Thread
08:26:40 <lilac> lol
08:27:19 <lilac> @remember osfameron <ImInYourMonad> can I store gtk2hs-Buttons in a datastructure? <osfameron> ImInYourMonad: I think you have to sew them on with gtk2hs-Thread
08:27:19 <lambdabot> Okay.
08:30:25 <Nafai> osfameron: Okay, I usually don't do this, but...lol!
08:31:06 <osfameron> ;-)
08:31:31 <mikhail^> weird question: what's the best way to debug a Segfault in Haskell? I've been doing repetitive HTTP calls and after a bit I get a segmentation fault on the compiled application
08:33:33 <ImInYourMonad> howdo I patternmatch  an IO String?
08:33:49 <ImInYourMonad> case buttonGetLabel b of "Black" ->
08:33:53 <ImInYourMonad> IO Black
08:34:11 <Saizan_> ImInYourMonad: you can't
08:34:12 <drdozer1> I don't think you do - you run your code in the IO monad where the string is already unwrapped for you
08:34:36 <EvilTerran> ImInYourMonad, extract a String from it with do ...; aString <- anIOString; case aString of ...
08:34:37 <Saizan_> do str <- buttonGetLabel b; case str of "Black" -> ..
08:45:20 <pejo> allbery_b, another approach would be to actually have a cosf-implementation somewhere, or some kind of reasonable fallback for platforms without cosf.
08:46:05 <mreh> guys, what would it take to embed haskell in another language?
08:46:26 <mreh> a parser written in that particular language? you cant always do 1 to 1 translations can you.
08:47:08 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2500#a2500
08:47:14 <ImInYourMonad>  Pattern syntax in expression context:
08:47:50 <pejo> mreh, what do you mean by embed?
08:48:14 <mreh> place fragments of haskell in my C code for example
08:48:38 <mreh> i know that I can translate the code to C, but can I do it more idiomatically than that?
08:48:38 <EvilTerran> you'd need to preprocess your code to make that work
08:49:27 <edbond2> how to cabal upgrade? v0.6.2 cabal-install GHC 6.10.1? I searched fa.haskell
08:49:34 <mreh> ta
08:49:38 <edbond2> I want a new HaXml
08:50:03 <maltem> mreh: There's a way to combine Haskell code with C, but you have to take care (i.e. find the appropriate manual) s.t. the RTS gets linked
08:50:25 <pejo> edbond2, does the new HaXml depend on a more recent version of Cabal than what comes with ghc 6.10.1?
08:50:34 <maltem> mreh: When compiling with ghc, that is.
08:50:44 <ImInYourMonad>  Pattern syntax in expression context:
08:50:44 <ImInYourMonad>         do l <- buttonGetLabel b
08:50:48 <ImInYourMonad> whats wrong with that?
08:50:58 <edbond2> pejo: no, but recent cabal don't upgrade packages AFAIK
08:51:04 <mreh> NES emulator in Haskell?! YES PLEASE
08:51:17 <Saizan_> ImInYourMonad: i think the offender it's the following line
08:51:17 <mreh> anyone doing GSoC this year?
08:51:37 <pejo> edbond2, can't you give an explicit version number? "cabal install HaXml-7.93"?
08:52:45 <edbond2> pejo: thanks, I don't know about this hack )
08:57:12 <guenni> is there already a "chunkalize" function?
08:58:56 <tromp_> of what type?
08:59:12 <ImInYourMonad> where is when?
08:59:23 <cnwdup> Control.Monad
08:59:37 <tromp_> when is where?
08:59:38 <cnwdup> (If that answer doesn't makes sense, just ignore it. Haven't read the preceeding conversation.)
09:00:38 <mmorrow> , [0..]
09:00:40 <lunabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,2...
09:00:42 <lilac> @index when
09:00:43 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
09:01:52 <EvilTerran> guenni, what do you want it to do exactly?
09:04:09 <guenni> EvilTerran: I'd like to write a foldl that takes an additional argument, a function, which is applied to the accumulated value, every n-times (n=10)
09:05:02 <guenni> EvilTerran: that function would be a function that forces the evaluation of the accumulated values
09:05:21 <EvilTerran> does it do anything else, or just force?
09:05:47 <guenni> well yes, I hope tp solve my stack overflow problem this way
09:06:21 <lilac> why every n times, not every time? (why not use foldl'?)
09:06:22 <EvilTerran> because i'd expect forcing every 10th time (say) to be pretty much indistinguishable from forcing every time (ie with foldl')
09:06:48 <tromp_> so just use foldl'
09:06:49 <guenni> EvilTerran: and since this could be a rather expensive function I'd like to do that only every n-times
09:06:57 <jmcarthur> yeah this sounds like the wrong approach to me unless there is something going on with unsafePerfomIO or something
09:07:16 <guenni> well foldl' doesn't realy go "deep" enough
09:07:17 <jmcarthur> guenni, delaying evaluation doesn't make anything less expensive
09:07:42 <lilac> guenni: so you want something more like rnf?
09:07:52 <korpios> I'm having an awful time trying to compile GHC 6.10.1 on Ubuntu 8.10 ... it keeps failing with this error: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2502
09:08:04 <jmcarthur> oh, deep evaluation. you could do something with rnf or you could change your data structure to something strict
09:08:14 <guenni> lilac: no, actually I in particular do not want rnf
09:08:43 <lilac> guenni: what in particular do you want? :-)
09:09:32 <guenni> what I'd like is a purely functional way to avoid a stack overflow and no seq, ! or stuff like that
09:09:40 <jmcarthur> based on what i've read so far i would try a strict data type definition
09:09:51 <jmcarthur> guenni, avoid a stack overflow due to what?
09:10:03 <bremner> guenni: seq is perfectly functional, just not lazy
09:10:19 <jmcarthur> the best way to avoid a stack overflow is to just understand evaluation semantics and how to make the proper things strict
09:10:31 <guenni> jmcarthur: well a huge amount of defered inserts
09:10:35 <vixey> Haskell is perfectly functional programming :)
09:11:00 <Saizan_> guenni: inserts into what?
09:11:01 <jmcarthur> inserts into what?
09:11:10 <lilac> guenni: if you don't explain what your /actual/ use case is, we're just going to be guessing
09:11:32 <guenni> I'll try hpaste, 1 min
09:11:47 <BMeph> guenni: If it (your "original" folding function) is so expensive, do you have some fusion rule that makes running it ten times every now-and-then better then running it once, at ten times the frequency? :)
09:12:19 <jmcarthur> that actually sounds like an interesting fusion rule
09:12:33 <Saizan_> running something like rnf every insert can be a waste, that's true
09:12:36 <BMeph> vixey: s/perfectly/*pure*fectly/ ;)
09:12:45 <jmcarthur> can't think of any case off the top of my head where it would be useful, but still interesting
09:13:02 <guenni> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2503#a2503
09:13:03 <Saizan_> but the solution is to design the inserting function or the data-structure better
09:13:46 <guenni> that is the data structure, and inserting a huge amount into that from a lazy list causes a stack overflow
09:13:47 <ImInYourMonad> can I store grk2hs-Buttons in a datastructure?
09:13:50 <ImInYourMonad> and funny guy
09:14:00 <EvilTerran> yes.
09:14:01 <ImInYourMonad> answer seriosuly this time please :)
09:14:35 <fasta> ImInYourMonad: I don't know. Can you?
09:14:53 <jmcarthur> guenni, yeah, this could benefit from some appropriate strictness annotations in the data structure with foldl', i think
09:15:14 <jmcarthur> guenni, and don't feel like ! is dirty or not functional in any way
09:15:29 <Saizan_> right, strict fields in those records and foldl' should be fine
09:15:32 <jmcarthur> it's an important part of haskell's semantics
09:15:54 <guenni> jmcarthur: it's just that I had tried all theses approaches before, sry I should have mentioned that
09:15:56 <Saizan_> guenni: what's the type of the accumulator? Entgelt?
09:16:09 <guenni> EntgelteIdx
09:16:46 <guenni> every Entgelt is put into an EntgelteIdx, which holds to maps
09:17:00 <allbery_b> pejo: ?
09:17:11 <Saizan_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2503#a2504 <- did you try with that and foldl'?
09:18:16 <guenni> Saizan_: not realy sure any more, I propably have
09:18:50 <Saizan_> that should be enough.
09:19:21 <pejo> allbery_b, in response to your ghc-users mail. :-)
09:20:37 <allbery_b> libm? reimplementing all of it, compatibly, would be Hard. my hackaround is to make a fake libm.so.2 from libm.so.1, adding the missing functions ((float) versions of trig functions), and telling the linker to ignore symbol versioning
09:21:00 <guenni> Well I remember trying just about anything when it came to strictness annotations and nothing, nothing period, really works, unless you rewrite the algo in such a way that the value is need.
09:21:00 <guenni> For the next computation
09:21:07 <daf> allbery_b: !
09:21:15 <allbery_b> I suspect that constructing a working libm.so.2 from libm.sso.1 would violate Sun copyright
09:21:30 <guenni> So back to my originnal question: Is there a "chunked version" of fold?
09:21:41 <pejo> allbery_b, in that case ghc should have a fallback, it seems unreasonable that Solaris 8/9 are "deprecated".
09:21:42 <allbery_b> (well, not constructing, but distributing it. might be able to distribute a program that created it)
09:22:04 <jmcarthur> guenni, strictness annotations are not optimizations. they are a semantically significant part of the language. just trying them in random places is basically equivalent to a monkey banging on a keyboard
09:22:13 <allbery_b> um, solaris 8/9 *are* deprecated.  sol8 is EOLed, don;t recall about sol9
09:22:42 <allbery_b> but the last solaris 9 release was in 2005, IIRC
09:22:53 <jmcarthur> guenni, i know of no such function that you ask for. i just think you could do it better with what we are advising either way
09:23:04 <guenni> jmcarthur: agreed, unfortunately they are also very difficult to get right
09:23:20 <jmcarthur> guenni, not if you really understand what you are doing
09:23:33 <pejo> allbery_b, already? Time flies when you're having fun.
09:23:53 <guenni> jmcarthur: Is there a way of inspecting the stack?
09:24:25 <allbery_b> (mind, we still have a solaris 7 box in production... and no solaris 10.  yet.)
09:24:28 <jmcarthur> dunno about that, but you could use heap profiling to see where your memory is going
09:24:53 <guenni> jmcarthur: and that is exactly where the problem is, I quite often do not know what I'm doing :)
09:25:09 <pejo> allbery_b, yes, I remember complaining that some 2.5-boxes were hard to maintain a couple of years ago.
09:25:20 <jmcarthur> guenni, http://www.haskell.org/ghc/docs/latest/html/users_guide/prof-heap.html
09:25:30 <pejo> allbery_b, performing unecessary upgrades just breaks things. :-)
09:26:08 <Saizan_> guenni: if you give us an example that stack overflows we can try to spot the problem
09:26:50 <jmcarthur> guenni, seriously though, if you just put in the strictness annotations and use foldl' the stack overflow should probably be gone unless the problem is actually in another area of your code
09:27:08 <allbery_b> actually the sol7 box is there for a single program that won't work on newer releases and source lost
09:27:12 <guenni> Saizan_: love to, how can I do that, the sample data is in large CSV files, and I access them on XP via ODBC and a Schema.ini
09:27:34 <jmcarthur> eek
09:27:35 <allbery_b> the others are there because of commercial software, some of which *still* hasn't been sol10-certified
09:27:36 <pejo> allbery_b, Sun takes their backwards compat seriously, have you tried reporting it to them?
09:27:56 <Saizan_> guenni: can you generate dummy data with an expression?
09:28:04 <jmcarthur> guenni, how about a small test program with its own main and dummy data?
09:28:14 <allbery_b> I'm not sure anyone outside CMU and MIT cares about a fingerd
09:28:41 <Saizan_> the precise shape doesn't matter, probably, unless it's triggering a loop
09:29:08 <guenni> Saizan_: unfortunetly not yet, I think I'll come back here with this when I'm better prepared, ie have done all my homework
09:29:43 <adityam> @pl         different p =  or [ notElem n p , null $ intersect r p ]
09:29:43 <lambdabot> different = or . ap ((:) . notElem n) (return . null . intersect r)
09:30:17 <vixey> adityam: probably better to use (||) rather than or [-,-]
09:30:39 <adityam> vixey: Thanks
09:30:40 <vixey> that way you get  liftA2 (||) (notElem n) (null . intersect r)
09:30:56 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2505#a2505
09:31:00 <ImInYourMonad> !!!!
09:32:29 <vixey> lol
09:32:41 <vixey> ImInYourMonad you've invented grid bag layout for Haskell
09:33:28 <Saizan_> guenni: btw, chunkedFold l g f z = foldl' (\(!n,!a) x -> if n == l then (0,g (f a x)) else (n+1,f a x)) (0,z)
09:34:51 <quicksilver> wli: the Control.Monad.* module re-export a lot of stuff. It's very annoying.
09:35:08 <quicksilver> wli: ghc doesn't complain because it's smart enough not to think re-exports are ambiguous.
09:35:50 <tHD> hi
09:35:55 <tHD> what is the status of the sdl binding
09:40:26 <guenni> Saizan_: thx
09:41:08 <guenni> Saizan_: um, and btw, um, you were right, um
09:41:47 <jmcarthur> guenni, never fear being wrong here. that was lesson #1 for me :)
09:43:08 <guenni> jmcarthur: I can't believe this, I tried every trick in the book on that problem, and I *was* sure that was also one of the things I tried, I guess I didn't
09:43:54 <guenni> Saizan_: I mean I spent weeks on this... aaaaaahhhhhh
09:45:55 <jmcarthur> you probably tried strictness annotations without foldl' or foldl' without strictness annotations
09:46:33 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2506#a2506 <- how can that be allowed, a data declared with 2 params and ok taking one
09:46:42 <quicksilver> tHD: I believe one of them works fine, btu I don't know anyone who's used it. I haven't.
09:46:53 <quicksilver> ImInYourMonad: partial application.
09:47:08 <quicksilver> if data A = A Int String, then "A 4" has the type "String -> A"
09:47:11 <guenni> jmcarthur: actually I remember now, I didn't use my Indexed Structure, I was using the generic one from HApps-IxSet, so I couldn't place any ! there
09:47:14 <quicksilver> it's waiting for one more parameter.
09:47:47 <jmcarthur> i'm not familiar with happs' IxSet yet
09:48:19 <jberryman> elegant way to define function from [1,2,3,4,5,6] to [[1],[2,3],[4,5,6]]?
09:48:23 <tHD> ok, thanks
09:48:35 <jmcarthur> guenni, if you believe that the IxSet stuff may have the wrong strictness then it may be worth a bug report
09:49:01 <MarcWeber> dcoutts: Do you just know wether all package.conf files may contain the LGPL Maybe type? Or should they only contain LGPL ?
09:49:06 <guenni> jmcarthur: I had (still have actually) to query large amounts of data in numerous ways and it was either that or use SQL instead
09:49:49 <guenni> jmcarthur: and that project was orphaned is now revived under the name happstack by someone else
09:50:31 <jmcarthur> guenni, yup. it may be worth a stop to #happstack to see if anybody knows if there is an appropriate way to control IxSet's strictness
09:50:39 <RayNbow> jberryman: could you be more specific?
09:50:43 <guenni> jmcarthur: also where they were using Sets as the actually container I chose lists
09:50:46 <jmcarthur> or the #happs mailing list
09:51:03 <jmcarthur> guenni, oh, Set may be strict, lists are not
09:51:08 <jmcarthur> at least not Prelude lists
09:52:07 <dons> hehe. anyone notice something unusual about this site: http://www.infosthetics.com/
09:52:08 <guenni> jmcarthur: that wasn't why I chose lists over sets, the problem was that a Set does not hold 2 identical elements, whereas a list does, and when you do sums for instance that makes a huge difference
09:52:12 <quicksilver> jberryman: can you even specify that?
09:52:22 <quicksilver> jberryman: chunk a list into increasing parts?
09:52:41 <RayNbow> or chunk it in parts based on the first element of the chunk?
09:53:36 <guenni> jmcarthur: and I did point both of these out to the current maintainer
09:53:45 <jmcarthur> guenni, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/multiset is strict, or you could just do what it does and have a Map a Int, where the int is the number of elements with that value
09:53:53 <RayNbow> <dons> hehe. anyone notice something unusual about this site: http://www.infosthetics.com/ <-- the Haskell charts lack color? :p
09:54:29 <dons> heh.
09:55:07 <guenni> jmcarthur: thx
09:55:12 <jberryman> RayNbow, quicksilver: right, sorry. split a list into increasing lengths. I would actually like the lengths to be 2 ^ 0, 2 ^ 1, 2 ^2, etc. but wanted to simplify
09:56:04 <jberryman> I already have an unfoldUntil function, and am using splitAt. it's very ugly
10:03:32 <sjanssen> it is hard to rank 113 options
10:03:46 <jmcarthur> yeah, i thought that as well
10:03:53 <jmcarthur> i would rather have had a rating system than a ranking system
10:04:17 <sjanssen> it would be a little bit easier if the pictures were integrated into the ballot
10:04:21 <vixey> :t unfold
10:04:22 <lambdabot> Not in scope: `unfold'
10:04:23 <vixey> :t splitAt
10:04:24 <lambdabot> forall a. Int -> [a] -> ([a], [a])
10:04:25 <vixey> :t unfoldr
10:04:26 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
10:04:33 <drhodes> > nub [take (2^i) $ drop (2^i) [0..20] | i <- [0..20]]
10:04:35 <lambdabot>   [[1],[2,3],[4,5,6,7],[8,9,10,11,12,13,14,15],[16,17,18,19,20],[]]
10:04:41 <drhodes> jberryman: ^^
10:05:19 <drhodes> probably not elegent though ;)
10:08:27 <PeakerWork> @let sortNub = map head . group . sort
10:08:31 <lambdabot>  Defined.
10:09:13 <PeakerWork> is there a way to time computations with lambdabot?
10:09:54 <maltem> > map (fst.snd) $ iterate (\(n,(_,xs)) -> (2*n,splitAt n xs)) (1,[],[0..20])
10:09:55 <lambdabot>   Couldn't match expected type `(Int, ([a], [a]))'
10:10:07 <maltem> > map (fst.snd) $ iterate (\(n,(_,xs)) -> (2*n,splitAt n xs)) (1,([],[0..20]))
10:10:08 <lambdabot>   [[],[0],[1,2],[3,4,5,6],[7,8,9,10,11,12,13,14],[15,16,17,18,19,20],[],[],[]...
10:10:52 <maltem> > takeWhile (not.null) . tail . map (fst.snd) $ iterate (\(n,(_,xs)) -> (2*n,splitAt n xs)) (1,([],[0..20]))
10:10:53 <lambdabot>   [[0],[1,2],[3,4,5,6],[7,8,9,10,11,12,13,14],[15,16,17,18,19,20]]
10:11:15 <maltem> Efficiency is a killer for elegance.
10:11:24 <vixey> I don't think so
10:11:31 <maltem> Well in this particular example :)
10:18:20 <Gracenotes> @hoogle (<^)
10:18:20 <lambdabot> Control.Arrow (<<^) :: Arrow a => a c d -> (b -> c) -> a b d
10:24:16 <orzo> hello
10:24:36 <Vq^> hello orzo
10:25:06 <vixey> @let head' f (x:xs) = f x : xs
10:25:07 <lambdabot>  Defined.
10:25:47 <leithaus> hello, a few months back someone put up a wiki page covering/comparing several implementation of n-queens
10:25:55 <leithaus> does anybody have a link to that?
10:26:13 <leithaus> google is giving me no joy
10:26:22 <quicksilver> leithaus: http://therning.org/magnus/archives/330 ?
10:26:28 <orzo> i'm trying to use a 32bit build of ghc for os x on os x beta "Snow Leopard".  It mostlyworks but the generated assembler is bad.  The assembler is complaining about improper register names such as %rbp.  Anybodygot an idea on hacking this to make it work?
10:27:12 <FunctionalPath> I just voted in a new Haskell logo poll. It was great fun, no monads needed!
10:27:22 <orzo> Snow Leopard i a 64bit os
10:27:41 <leithaus> quicksilver, thanks i have that one, but that's not the one i was thinking of because it doesn't have the LogicT implementation
10:27:42 <bmh> FunctionalPath: I didn't care for the UI. It would be nice to be able to click and drag logos into the desired order
10:28:09 <quicksilver> orzo: try -fasm
10:28:17 <quicksilver> orzo: (which avoids the C compiler part)
10:28:39 <vixey> > let k 0 xs = [] : xs ; k n (x:xs) = k (n-1) xs in k 0 [1,2,3,4,5]
10:28:39 <lambdabot>       No instance for (Num [a])
10:28:39 <lambdabot>        arising from the literal `1' at <inter...
10:29:07 <quicksilver> orzo: alternatively, you will need to teach GHC to call GCC with the appropriate options to work in '32-bit mode'
10:29:08 <orzo> quicksilver: no difference
10:29:13 <quicksilver> hmm
10:29:53 <orzo> well, i do have it calling gcc with appropriate options
10:30:13 <orzo> i ued -opta and -optc
10:30:39 <orzo> oh
10:30:41 <orzo> i got it to work
10:31:11 <orzo> i had tried opta and optc alternatiely but not oth together
10:32:16 <pejo> orzo, rbp sounds like a 64-bit register, you sure you're running a 32-bit ghc?
10:32:30 <vixey> > let k 0 m xs = [] : k m m xs ; k n m (x:xs) = head' (x:) (k (n-1) (m+1) xs) in k 1 1 [1..]
10:32:39 <lambdabot>   [[1],[2,3],[4,5,6,7],[8,9,10,11,12,13,14,15],[16,17,18,19,20,21,22,23,24,25...
10:34:53 <koeien> noob question here. what is the easiest way to parse a number of lines like, "e %d %d", where %d is a positive integer i'm interested in. i've used parsec now but this seems overkill
10:35:08 <vixey> parsec is not "overkill"
10:35:34 <koeien> in C i'd use scanf()
10:35:38 <Gracenotes> there's words
10:35:45 <koeien> ah yes, words & lines
10:35:50 <vixey> koeien, How would you implement scanf in Haskell?
10:35:50 <koeien> that's easier. thanks
10:35:55 <koeien> vixey: i wouldn't
10:36:05 <vixey> koeien, k
10:36:10 <vixey> not really what I meant
10:36:13 <koeien> TH perhaps?
10:36:26 <vixey> koeien, the answer is: Using parsec
10:36:33 <BONUS> > let [w,a,b] = words "af 3 5" in (w, read a :: Int, read b :: Int)
10:36:34 <lambdabot>   ("af",3,5)
10:36:42 <koeien> BONUS: yeah that's easier. thanks
10:36:51 <Gracenotes> i c u pattern match thar
10:37:12 <koeien> i don't need to do validation, my program is allowed to crash :)
10:37:25 <vixey> that sounds pretty stupid to me
10:37:31 <vixey> going from something that works to something that can crash..
10:37:31 <koeien> vixey: that's because it is :)
10:37:43 <BONUS> depends on the requirements
10:37:52 <koeien> i remove a depedency so that my program can be compiled on machines without parsec
10:38:07 <koeien> which is in this case more important than validation of the input format
10:38:19 <vixey> koeien: Parsec is implemented in Haskell
10:38:29 <vixey> koeien: you can just provide it
10:38:31 <orzo> pejo, it works now, thanks
10:38:36 <lament> what, there're still machines out there that don't have Parsec?
10:38:50 <orzo> i had left out an -optc
10:38:50 <koeien> well, it's not installed by default or am i mistaken?
10:38:57 <Gracenotes> not on Debian/Ubuntu
10:39:07 <vixey> koeien: When what you're doing is stupid that should be a warning signal
10:39:15 <sw17ch> i've read a good overview of using Lenses in haskell... does any one know which article that might have been? I can't find it
10:39:28 <koeien> Gracenotes: stock ghc provides it?
10:39:33 <BONUS> but yeah uh
10:39:35 <koeien> from haskell.org/ghc ?
10:39:37 <Gracenotes> 'sudo apt-get install ghc' doesn't
10:39:44 <BONUS> using read is unsafe and you should never do it in any real app
10:39:47 <Gracenotes> yes, probably that
10:39:54 <lament> unsafeRead
10:39:56 <koeien> Gracenotes: ok, thanks, then i'll keep it this way
10:39:56 <Gracenotes> indeed, BONUS
10:39:58 <vixey> never do it in any real app ?
10:40:01 <quicksilver> BONUS: it's OK in an app you are happy to crash.
10:40:02 <koeien> BONUS: yep
10:40:05 <Gracenotes> @type reads
10:40:06 <lambdabot> forall a. (Read a) => String -> [(a, String)]
10:40:11 <Gracenotes> ^ quite fine, mind ya
10:40:13 <BONUS> quicksilver: well yeah haha
10:40:17 <quicksilver> BONUS: which is a valid attitude for small commandline components.
10:40:25 <koeien> in this case i read a number of vertices and edges. if somebody wants to enter shakespeare, i'm happy to crash
10:40:27 <lament> > (read "thirty-two") :: Int
10:40:28 <lambdabot>   * Exception: Prelude.read: no parse
10:40:29 <quicksilver> BONUS: sometimes quick death by exception is all you want to do.
10:40:37 <BONUS> true
10:40:40 <Gracenotes> > (reads "thirty-two") :: Int
10:40:41 <lambdabot>   Couldn't match expected type `Int'
10:40:49 <Gracenotes> > (reads "thirty-two") :: [(Int,String)]
10:40:50 <lambdabot>   []
10:40:53 <vixey> koeien: doesn't seem very wise
10:41:00 <Gracenotes> @elite did u see wat i did thar
10:41:00 <lambdabot> DID U 53e \/\/a7 i diD T|-|4R
10:41:18 <vixey> koeien: I think there's value in making proper solutions as easy as ugly crap solutions
10:41:20 <koeien> vixey: what is the difference between 'Prelude.read: no parse' and another error message
10:41:50 <lament> koeien: i think the answer to that is obvious :)
10:41:53 <vixey> koeien: the bigger picture is if you want to rip out some part of this program to use elsewher...
10:42:08 <koeien> lament: yeah the line/column info :)
10:42:11 <vixey> and yeah, meaningful error messages are worthwhile
10:42:22 <bremner> Gracenotes: libghc6-parsec-dev
10:42:36 <Gracenotes> bremner: not default. as I said :)
10:42:58 <sw17ch> @where lense
10:43:06 <lambdabot> I know nothing about lense.
10:43:12 * sw17ch grumbles
10:43:36 <quicksilver> sw17ch: you after an implementation, or a blog post?
10:43:42 <sw17ch> quicksilver: both/and
10:43:51 <quicksilver> http://twan.home.fmf.nl/blog/haskell/overloading-functional-references.details
10:44:00 <quicksilver> sw17ch: there is an implementation called Data.Accessor.
10:44:05 <sw17ch> quicksilver: that's exactly what i was looking for :)
10:44:05 <quicksilver> I don't like their choice of primitives ;)
10:44:15 <sw17ch> i do'nt like Data.Accessor either
10:45:02 <quicksilver> I also don't like the name they chose :)
10:45:07 <quicksilver> lenses are more than accessors.
10:45:14 <quicksilver> Basically,  I'm a grumpy bastard.
10:45:23 <Gracenotes> @elite , (\((?):(??)) ->(?)+1000 : ((*2)<$>(??))) $ (*2)<$>[1..]
10:45:23 <lambdabot> , (\((?):(??)) ->(?)+1000 : ((*2)<$>(??))) $ (*2)<$>[1..]
10:45:25 <lunabot>  [1002,8,12,16,20,24,28,32,36,40,44,48,52,56,60,64,68,72,76,80,84,88,92,96...
10:45:29 <Gracenotes> :)
10:45:59 <sw17ch> quicksilver: permission to be grumpy granted
10:46:27 * Gracenotes doesn't think the same is possible with lunabot
10:46:29 <vixey> @oies 1002,8,12,16,20,24,28,32,36,40,44,48,52,56,60,64,68,72,76,80,84,88,92,96
10:46:29 <lambdabot>  Sequence not found.
10:46:52 <lament> vixey: ignore the 1002.
10:46:54 <Gracenotes> oh, it's random, is all
10:47:02 <Gracenotes> arbitrary rather
10:47:09 <bremner> Gracenotes: well, okey, if the extra apt-get install is a barrier for you...  You could make a haskell "task" that installs everything haskelly
10:47:43 <Gracenotes> uh huh. it's just not default, is all I'm sayin.
10:48:21 <koeien> i'm on debian, that's why i had to apt-get the extra package. the person i'm sending this to will have ghc from the ghc site, so that's not a problem
10:48:24 <ehird> @help elite
10:48:24 <lambdabot> elite <phrase>. Translate English to elitespeak
10:48:52 <ehird> @hoogle (a -> Int -> b) -> [a] -> [b]
10:48:52 <lambdabot> Prelude scanr :: (a -> b -> b) -> b -> [a] -> [b]
10:48:52 <lambdabot> Data.List scanr :: (a -> b -> b) -> b -> [a] -> [b]
10:48:52 <lambdabot> Prelude zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
10:51:09 <Gracenotes> @type (. zip [0..]) . (map . uncurry)
10:51:10 <lambdabot> forall a b c. (Enum a, Num a) => (a -> b -> c) -> [b] -> [c]
10:52:27 <vixey> I am disappointed when haskell programmers use unsafePerformIO (or anything that breaks through the theory of the type system),  or ad-hoc solutions -- it seems like out of everyone the people that would not be doing this are Haskell programmers.. so it sort of indicates people have very little interest in doing things 'right' as opposed to just 'getting it done'
10:53:08 <ImInYourMonad> if i do type Board = A.Array (Int, Int) Square,arent all valid ops on a Array valid on Board then?
10:53:31 <Gracenotes> yeah
10:54:02 <Gracenotes> newtyping is also an option
10:54:13 <koeien> ImInYourMonad: type is just a type synonym. so yes
10:54:28 <ImInYourMonad> vixey: my exprience is if I get things done the program breaks later. the "haskell way" usually equalds a good program. like I wish sometime sit was dynamic so I could "just get the effing thing to work", but then it forces me to think out a better solution instead and it ends up being better
10:55:28 <vixey> ImInYourMonad: yeah I think that it's possible experienced programmers can get the same frustration, but because of experience they think it's haskells fault and not their own and don't find a better solution
10:56:03 <vixey> I would also suppose there is some kind of atrophy, a lot of people given up on writing correct programs because it's "impossible" or too "expensive"
10:56:16 <koeien> it's harder to write programs in haskell, i'm sure
10:56:22 <jmcarthur> oftentimes the "get the effing thing to work" approach ends up just being wrong (in a badly typed way) anyway
10:56:24 <vixey> koeien: than?
10:56:28 <koeien> that is because it's easy to write incorrect programs
10:56:55 <koeien> vixey: compared to, say python or C. but your program is more likely to be incorrect
10:57:06 <vixey> I think it's quite the opposite, python and C are muddy quagmires
10:57:27 <koeien> hmm, i have to retract my statement
10:57:30 <vixey> When you express something clearly in a simple way in Haskell you are led to learn new generalizations that make programming in future easy
10:58:00 <ehird> also haskell cooks you dinner
10:58:03 <pejo> vixey, Martin Rinard argued that we pay too much attention on correctness.
10:58:09 <koeien> @faq can Haskell cook me dinner?
10:58:10 <lambdabot> The answer is: Yes! Haskell can do that.
10:58:32 <gbacon> can I play with options on the #! line to convince runghc to execute a file with an extension other than .hs?
10:58:57 <vixey> pejo: in some publication or talk that I can read ?
10:59:24 <koeien> gbacon: works for me
10:59:28 <jmcarthur> koeien, wait, are you claiming that it's easier to write incorrect programs in haskell than in other languages?!
10:59:28 <koeien> gbacon: ghc 6.10.1 here
10:59:36 <koeien> jmcarthur: no
10:59:50 <jmcarthur> koeien, okay, you had me confused there as that makes no sense ;)
10:59:51 <pejo> vixey, I think it's linked from the POPL'09 homepage. It was Arvind who presented his thoughts though.
11:00:12 <gbacon> koeien: me too, but I get "target `foo' is not a module name or a source file"
11:00:18 <koeien> gbacon: #!/usr/bin/env runghc
11:00:20 <pejo> vixey, (the panel debate)
11:00:29 <vixey> pejo: I can probably assume he was talking to language designers then, not _users_
11:01:06 <pejo> vixey, well, academics atleast.
11:01:35 <gbacon> koeien: I had #! /usr/local/bin/runghc
11:01:51 <gbacon> odd
11:02:24 <koeien> gbacon: that doesn't work for me as well. i've run into this before
11:02:33 <koeien> gbacon: i guess using env is better for portability
11:02:39 <gbacon> koeien: thanks
11:03:10 <centrinia> How does one determine the number of multinomials in an element of Z_n[x,y,z] ?
11:04:18 <koeien> depends on your representation of it
11:05:26 <centrinia> What if my representation is only (x+y+z)^r ?
11:05:49 <koeien> centrinia: i suggest you ask #math
11:06:51 <centrinia> Okay.
11:07:23 <koeien> unless i'm mistaken, this is a combinatorial question. i think they might be able to help you better
11:08:36 <centrinia> This is actually a part of an Project Euler question. :p
11:14:01 <hallongrottan> is it possible to have lhs2TeX syntax highlight code?
11:15:33 <hallongrottan> that is, besides the bolding of "data" and "type"
11:18:02 <jmcarthur> hallongrottan, you would need to learn how to extend it yourself, but it can be done afaik
11:18:27 <jmcarthur> just check through the documentation about customizing the styling
11:18:28 <aleator> How can I easily test a cabalized library inplace?
11:18:41 <jmcarthur> aleator, cabal configure && cabal build
11:19:13 <jmcarthur> aleator, or in the absence of cabal-install, runhaskell Setup.lhs configure && runhaskell Setup.lhs build
11:19:53 <aleator> After building, how do I, say, get it to give proper flags to ghci?
11:20:30 * jmcarthur doesn't understand the question
11:20:59 <aleator> Well, I have just one c2hs file Test.chs and cabal set up to build it.
11:20:59 <jmcarthur> your program is launching ghci, or what?
11:21:13 <aleator> Then, without installing the package I want to test it in ghci
11:21:18 <jmcarthur> ah
11:21:25 <jmcarthur> this is a library?
11:21:30 <ImInYourMonad> anyone know, can gtk2hs buttons have a color-label? like a gif or bmp?
11:21:30 <aleator> yep
11:21:56 <aleator> I'm finding lack of t-tests in haskell disturbing. ;)
11:22:02 <jmcarthur> i have never tried loading a .chs in ghci, but that may work. if not you may be able to load a .o file or something
11:22:04 <ImInYourMonad> t-tests?
11:22:41 <aleator> I cannot find a single ready made gadget to perform Students t-test for me.
11:22:48 <wchogg> Alright, so in the Haddock docs for ByteString what is the 'c' in computations labeled as O(c).  Chunk size?  For some reason I didn't see this.
11:23:30 <mmorrow> aleator: try hmatrix
11:23:59 <aleator> mmorrow: I can't get the damn thing to build anymore.
11:24:17 <mmorrow> aleator: dang. what's the error?
11:25:08 <aleator> mmorrow: I'm not at my work pc, but iirc it barfed on some generated file missing.
11:25:33 <aleator> Weird. Hackage seems to build it ok..
11:26:33 <waern> wchogg: constant? :)
11:26:59 <waern> that should be O(1), I guess
11:27:00 <mmorrow> aleator: hmm. maybe it had problems finding a (c)blas lib or something on that other machine. iirc i had that happen a few times
11:27:10 <wchogg> waern : One might think that except they do label others as O(1), which is why I'm confused.
11:27:19 <waern> wchogg: ah, ok
11:27:41 <aleator> mmorrow: I will try again. It used to build on 6.8 fine but then 6.10 onwards I've had troubles. It is a must have tool, so I'd be dissapointed not to have it working
11:28:24 <aleator> mmorrow: But it still doesn't seem to do t-tests or gsl_cdf_tdist_P..
11:30:25 <mmorrow> vixey: restricting yourself to doing it "the right way" in haskell is limiting yourself to what's possible in haskell.
11:31:33 <mmorrow> why limit yourself to work constrained within some system that happens to be the currently accepted "right way"?
11:32:18 <mmorrow> aleator: if you have any ffi+C experience, you could bind some of the GSL stat functions via hmatrix pretty easily
11:33:01 <mmorrow> aleator: he's got a bunch of C macros that make it fairly straightforward
11:34:30 <aleator> mmorrow: Hmm.. I don't know what changed but now it builds.
11:35:36 <aleator> mmorrow: I've done quite lots of ffi things. It is just that binding that stuff is trivial with c2hs. I'll look if I can figure out how hmatrix works.
11:35:40 <tromp_> > showIntAtBase 2 13 ""
11:35:41 <lambdabot>       Overlapping instances for Show (String -> String)
11:35:41 <lambdabot>        arising from a...
11:35:48 <tromp_> > showIntAtBase 2 13 intToDigit ""
11:35:49 <lambdabot>       No instance for (Integral (Int -> Char))
11:35:49 <lambdabot>        arising from a use of `...
11:35:51 <tromp_> > showIntAtBase 2 13 intToDigit
11:35:51 <lambdabot>       Overlapping instances for Show (String -> String)
11:35:51 <lambdabot>        arising from a...
11:36:08 <tromp_> :t showIntAtBase
11:36:09 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
11:36:29 <tromp_> > showIntAtBase 2 13 intToDigit ""
11:36:30 <lambdabot>       No instance for (Integral (Int -> Char))
11:36:30 <lambdabot>        arising from a use of `...
11:36:41 <ImInYourMonad> why does  a GUI crash if you index soem thing out of range?
11:36:42 <mmorrow> aleator: ah nice, i've been wanting to take a look at c2hs. it sounds like it might be super useful.
11:36:56 <tromp_> > showIntAtBase 2 intToDigit 13  ""
11:36:57 <lambdabot>   "1101"
11:37:07 <tromp_> :t chr
11:37:08 <lambdabot> Int -> Char
11:37:27 <tromp_> @djinn Char -> Int
11:37:27 <lambdabot> Error: Undefined type Char
11:37:54 <tromp_> @hoogle chr
11:37:54 <lambdabot> Data.Char chr :: Int -> Char
11:37:54 <lambdabot> Text.PrettyPrint.HughesPJ Chr :: Char -> TextDetails
11:37:54 <lambdabot> System.Posix.Internals c_s_ischr :: CMode -> CInt
11:38:41 <tromp_> > showIntAtBase 2 intToDigit (ord '[')  ""
11:38:42 <lambdabot>   "1011011"
11:39:04 <mreh> anyone heard of any other orgs doing FP with GSoC?
11:41:44 <sw17ch> does any one know of a good way to get the representation ghc uses for a data type?
11:41:52 <aleator> mmorrow: I think I figured out how to make hmatrix do this. Thanks
11:42:44 <mmorrow> aleator: great, np :)
11:43:03 <mmorrow> sw17ch: at what level?
11:43:54 <sw17ch> mmorrow: I'd like to see something like this: data Foo = Foo Int Int ==> struct Foo { *int32; *int32 }
11:44:03 <sw17ch> a memory layout
11:44:05 <tromp_> @let byte c = take 8 . (++ repeat ' ') . reverse $ showIntAtBase 2 intToDigit (ord c) ""
11:44:06 <lambdabot>  Defined.
11:44:08 <sw17ch> what things get unboxed, etc
11:44:23 <sw17ch> basically, something i could use to pick into the innards with a C program
11:44:26 <tromp_> > bits '['
11:44:27 <lambdabot>   Not in scope: `bits'
11:44:33 <tromp_> > byte '['
11:44:34 <lambdabot>   "1101101 "
11:45:17 <tromp_> > byte '+'
11:45:18 <lambdabot>   "110101  "
11:46:18 <mmorrow> sw17ch: are you interested in static data, or runtime data?
11:46:45 <sw17ch> mmorrow: i guess both would be interesting, but i'm more interested in runtime storage
11:46:52 <sw17ch> this isn't for a specific tool, just curiosity
11:46:58 <sw17ch> and analysis
11:47:30 <mmorrow> this is an decent overview http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage
11:48:43 <sw17ch> neat, thanks!
11:49:16 <mmorrow> and then these're nice ghc/includes/{ClosureTypes,InfoTables,Closures,ClosureMacros}.h
11:50:26 <mmorrow> sw17ch: also, there's a (bitrotted, no longer working) package on hackage called "reify", that at one point was able to suck stuff out of the heap and play with it
11:50:40 <sw17ch> wow
11:50:45 <mmorrow> i found that code nice
11:51:05 <mmorrow> (nice := informative)
11:51:08 <sw17ch> :)
11:51:13 <mmorrow> ;)
11:51:13 <sw17ch> i like the RTS code in most places
11:51:21 <sw17ch> some times it's hard to follow and doesn't make much sense
11:51:30 * BMeph wishes there were a simple, direct way to go from C structs to Haskell ADTs, and vice-versa.
11:51:54 <sw17ch> BMeph: i'd also like a pony
11:52:06 <lilac> ooh, ponies? i'll take one
11:52:14 <sw17ch> :)
11:52:44 <lilac> that said, BMeph's wish doesn't sound /that/ hard, apart from sharing issues
11:52:49 <BMeph> lilac, sw17ch: Check hackage, or ask dons directly. ;p
11:53:02 <sw17ch> :)
11:53:08 <sw17ch> cabal install pony # except it's a unicorn
11:53:12 <Nafai> BMeph: Pardon my ignorance, but why ADTs instead of records?
11:53:35 * BMeph wants to put `cabal install pony` on business-card stock, and hand them out to people...
11:53:46 <vixey> records are ADTs
11:54:02 <Nafai> vixey: I figure that was the case :)
11:54:10 <sw17ch> actually, is it possible to convince GHC to layout a record in the same way a struct would be?
11:54:17 <sw17ch> struct { int a; int b; }
11:54:20 * BMeph points to vixey, and looks at Nafai
11:54:26 <sw17ch> data Foo = Foo Int# Int#
11:54:34 <sw17ch> data Foo = Foo !Int# !Int#
11:54:39 <sw17ch> or how ever it goes
11:55:08 <BMeph> For my next trick, I want C unions to work like Haskell ADTs, too! >:\
11:55:36 <sw17ch> mmorrow: actually, this was the root of my curiosity
11:55:46 <Nafai> BMeph: Sheesh you are wanting to do no work on wrapping C libs!
11:55:47 <sw17ch> =)
11:56:06 <vixey> unions throw a spanner in the works
11:56:10 <Eridius> @faq Can Haskell give me a pony?
11:56:10 <lambdabot> The answer is: Yes! Haskell can do that.
11:56:16 <sw17ch> cabal install magic; magic blah.h; runhaskell Setup build
11:56:55 <sw17ch> @faq Can Haskell ask a question even Haskell cannot answer?
11:56:55 <lambdabot> The answer is: Yes! Haskell can do that.
11:57:44 <Eridius> @faq Can Haskell answer a question even Haskell cannot ask?
11:57:44 <lambdabot> The answer is: Yes! Haskell can do that.
11:57:51 <Raynes> And it can answer it too.
11:57:57 <Eridius> @faq Can Haskell be used to build a superturing system?
11:57:58 <lambdabot> The answer is: Yes! Haskell can do that.
11:57:59 <Eridius> LIAR
11:58:03 <tromp_> > [' '..]
11:58:04 <lambdabot>   " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefg...
11:58:37 <BMeph> sw17ch: With exhaustible sets, your faq is trivial. ;)
11:58:38 <tromp_> > ['h'..]
11:58:39 <lambdabot>   "hijklmnopqrstuvwxyz{|}~\DEL\128\129\130\131\132\133\134\135\136\137\138\13...
11:58:42 <mofmog> let { y f = f (y f); g h x = if x==0 then 1 else h(x-1)*x; fact x = y g x;} in fact 10000
11:58:52 <mofmog> > let { y f = f (y f); g h x = if x==0 then 1 else h(x-1)*x; fact x = y g x;} in fact 10000
11:58:53 <lambdabot>   284625968091705451890641321211986889014805140170279923079417999427441134000...
11:59:54 <bremner> @faq Can Haskell do things that Haskell cannot do?
11:59:54 <lambdabot> The answer is: Yes! Haskell can do that.
12:01:56 <mreh> http://hackage.haskell.org/trac/summer-of-code/report/1 I saw this page sorted by category before
12:02:06 <mreh> how do i get it back?
12:02:43 <mreh> it's some kind of report page on hackage
12:02:51 <Eridius> that's Trac
12:03:21 <Eridius> maybe you want http://hackage.haskell.org/trac/summer-of-code/query?status=new&status=assigned&status=reopened&group=topic&order=priority
12:05:34 <mreh> if they only funded nine projects last year, how do you rate my chances of programming something in the realm of games programming
12:05:54 <mreh> that sentence doesnt read well
12:06:54 <mreh> who actually approves the project, presumably the person paying the stipend
12:09:33 <mreh> does anyone in here know anything of what im talking about, or am i being ignored
12:09:42 <mreh> :'(
12:09:50 <bremner> mreh: yes
12:10:09 <mreh> that doesn't answer the question
12:10:27 <bremner> mreh: yes it does, the question was an or
12:10:35 <PeakerWork> we need well-typed discussions
12:10:37 <lilac> @fap Can Haskell to that?
12:10:37 <lambdabot> Maybe you meant: faq map
12:11:03 <bremner> mreh: anyway, I'm pretty sure google decides who gets google's money
12:13:47 <mreh> how much of haskell is written in haskell?
12:14:00 <vixey> 90%
12:14:04 <mreh> im talking about GHC
12:14:24 <mreh> and the rest?
12:15:23 <arjanb> the evil mangler is perl
12:16:31 <MyCatVerbs> arjanb: fortunately that's well on the way to being abandoned.
12:16:40 <shepheb> plus some C for the core of the RTS.
12:16:43 <thoughtpolice> running cloc over the ghc source (from the git clone of ghc)
12:16:56 <thoughtpolice> there's about 125,000 lines of haskell code in there for the compiler itself
12:17:01 <thoughtpolice> the runtime itself is 50,000 lines
12:17:03 <MyCatVerbs> And some C-- for parts of the RTS that have to work very, very closely with Haskell code.
12:32:10 <Mr_Giraffe> so if i want to have a function for a graphical program that gets the distance between two objects
12:32:17 <Mr_Giraffe> like (dist creatureA objectB)
12:32:32 <Mr_Giraffe> but i don't want to make different functions for each data type...how would i go about this?
12:33:03 <mreh> @src nub
12:33:03 <lambdabot> nub = nubBy (==)
12:33:10 <Zao> Make a type class and add instances with dist for any relevant types?
12:33:26 <mreh> can anyone explain that?
12:33:37 <mreh> @src nubBy
12:33:37 <lambdabot> nubBy eq []             =  []
12:33:37 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
12:33:45 <jmcarthur> class Point a where position :: a -> (Double, Double); distance :: (Point a, Point b) => a -> b -> Double
12:33:48 <jmcarthur> ^ one possibility
12:34:16 <Mr_Giraffe> excellent!
12:34:26 <Mr_Giraffe> jmcarthur, Zao: thanks much
12:35:06 <Mr_Giraffe> i have to say, coming from a C/C++ background haskell is a really wonderful language
12:35:14 <daofma> Is anybody familiar with the differences between standard library specs on Haskell.org and the specs of the standard library in GHC? I've noticed that many IntMap functions have different types.
12:35:37 <jmcarthur> Mr_Giraffe, it becomes more and more wonderful the deeper you go :)
12:35:42 <Mr_Giraffe> jmcarthur: indeed
12:36:02 <mreh> why dont you marry haskell
12:36:31 <Mr_Giraffe> mreh: i imagine spooning with a lambda might be a bit uncomfortable
12:36:39 <Mr_Giraffe> ymmv
12:37:10 <jmcarthur> can't marry anybody that has monads, sorry
12:37:12 <kiris> I just got an email about voting on the new haskell logo
12:37:19 <kiris> will this come with a new home page design or something?
12:38:20 <seliopou> I'm just gonna throw this out there: the new logos aren't very good :(
12:38:33 <BONUS> better than the old one
12:38:39 <jmcarthur> seliopou, agreed :(
12:38:40 <seliopou> ehhh
12:38:42 <BONUS> some of them are kewl
12:38:52 <vixey> I like the old one
12:39:05 <jmcarthur> BONUS, i don't really want a "kewl" logo. i want a _good_ logo
12:39:08 <vixey> it is the "logo of logos"
12:39:09 <Mr_Giraffe> i like the lambda, personally
12:39:11 <vixey> @quote logo
12:39:11 <lambdabot> xahlee says: The Haskell Logo is the perfection of logos
12:39:13 <Mr_Giraffe> straight and to the point
12:39:15 <MyCatVerbs> daofma: how so, exactly? Sometimes GHCi will print types differently to how they're listed in the documentation - often because it has more detailed information than what the documentation says really ought to be in scope, but the type you see in GHCi should always be equivalent to the type you see in the Haddock documentation. Otherwise is a bug.
12:39:22 <Mr_Giraffe> oh my that is a lot of text
12:39:26 <BONUS> ah well there you go then. i'll settle for kewl
12:40:05 <jmcarthur> how long is the voting period?
12:40:32 <daofma> What I mean is that GHC's types for Data.IntMap differ in some important ways from Haskell.org's. c.f. http://www.haskell.org/ghc/docs/latest/html/libraries/containers/Data-IntMap.html#v%253AfindMin for GHC and http://www.haskell.org/ghc/dist/current/docs/libraries/containers/Data-IntMap.html#v%253AfindMin
12:40:34 <jmcarthur> nm, i just checked the email
12:40:46 <jmcarthur> irc makes me lazy
12:40:51 <seliopou> I now regret now having subscribed to haskell-cafe
12:40:53 <seliopou> no vote for me :(
12:41:48 <pastah> @pl \t -> local (setExpected t) (infer e)
12:41:48 <lambdabot> flip local (infer e) . setExpected
12:42:04 <mreh> > nub [1..10]
12:42:05 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
12:42:12 <vixey> @pl \e t -> local (setExpected t) (infer e)
12:42:12 <lambdabot> flip (local . setExpected) . infer
12:42:15 <vixey> @pl \t e -> local (setExpected t) (infer e)
12:42:15 <lambdabot> (. infer) . local . setExpected
12:42:35 <trofi> > nub [nub, nub]
12:42:36 <lambdabot>       Overlapping instances for Show ([a] -> [a])
12:42:36 <lambdabot>        arising from a use o...
12:42:40 <mreh> :t zip
12:42:40 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
12:42:53 <trofi> > length . nub [nub, nub]
12:42:54 <lambdabot>   Couldn't match expected type `a -> [a1]'
12:43:05 <jmcarthur> > nub [1,3,6,7,4,6,4,4,2,2,4,6,7]
12:43:06 <lambdabot>   [1,3,6,7,4,2]
12:43:20 <mreh> yah, i got it
12:43:25 <mreh> thanks
12:43:39 <mreh> what the nub does nub stand for anyway
12:43:55 * jmcarthur shrugs
12:44:08 <conal> mreh: the essence
12:44:10 <mreh> i'll give you such a nubbing
12:44:19 <lament> mreh: http://en.wiktionary.org/wiki/nub
12:45:14 <mreh> it's how you pronounce n00b isnt it
12:45:45 <mreh> and apparently it's a small knot
12:47:15 <mreh> inP ps c = (length. nub. map (det c). sides) ps == 1
12:47:21 <mreh> can anyone decipher that?
12:47:52 <mreh> any mathematicians know why he's using a determinant to detect whether a point is in a polygon
12:47:58 <vixey> only an egytologist or higher
12:48:55 <vixey> mreh, what is the type of det?
12:48:55 <c_wraith> mreh: you can use a determinant to determine what side of a line a point is on.  this allows you to (with some care) determine if it's inside a polygon
12:49:12 <mreh> hmmmm
12:49:33 <conal> mreh: what's the type of det here?  it appears to be binary.
12:49:44 <conal> since 'det c' is a function.
12:49:44 <cnwdup> Is it bad practise to mix applicative and monadic combinators in a one function?
12:49:50 <mreh> yeah, ill get source
12:49:54 <vixey> cnwdup: of course not
12:49:59 <seliopou> c_wraith, for convex polygons
12:50:03 <cnwdup> Or mix do syntax and desugared notation?
12:50:04 <vixey> cnwdup: it's like, is it bad to mix integers and booleans
12:50:16 <seliopou> it's very straightforward in that case
12:50:18 <mreh> det (cx,cy) ((ax,ay), (bx,by)) =
12:50:21 <mreh>   signum ((by-ay)*(cx-bx)-(cy-by)*(bx-ax))
12:50:27 <vixey> :t signum
12:50:28 <lambdabot> forall a. (Num a) => a -> a
12:50:32 <jmcarthur> cnwdup, i think it's personal preference
12:50:40 <vixey> > map signum [3,2,0,-4,-5]
12:50:41 <lambdabot>   [1,1,0,-1,-1]
12:50:50 <cnwdup> jmcarthur, vixey, ok. Thanks.
12:50:51 <c_wraith> Indeed.  For non-convex polygons, the usual approach is to draw a line from the point to a known-external point, and count how many lines it intersects. odd = inside, even = outside
12:50:58 <conal> cnwdup: there are some monad names that are sort of historical accidents, i.e., we probably wouldn't have them if Applicative had been invented first.  namely return, ap, liftM2, ... .   i'm for deprecating those names.
12:51:09 <vixey> c_wraith: I think that'll work for convex ones too..
12:51:10 <seliopou> c_wraith, that's the general algorithm
12:51:15 <conal> cnwdup: toward the day that Monad derives from Applicative.
12:51:24 <c_wraith> sorry.  I meant for "non-guaranteed-convex" :)
12:51:31 <seliopou> yep
12:51:40 <seliopou> works for self-intersecting polygons as well
12:52:04 <monochrom> Recall: (A) formula for triangle area from three vertices gives +ve if counterclockwise, -ve if clockwise; (B) that formula is a determinant too.
12:53:00 <c_wraith> The only thing to be careful of with the general algorithm is that you count your test line intersecting at a vertex exactly once, rather than 0 times or 2 times.
12:53:00 <monochrom> You can also think of it as a cross product.
12:53:16 <pastah> @pl \f x -> f x x
12:53:17 <lambdabot> join
12:53:57 <conal> mreh: oh!  the signum is an important clue.  i think it's saying the point in on inside of all of the half-spaces or on the outside of all of them.
12:54:33 <seliopou> c_wraith, I don't think that's right
12:55:01 <conal> i.e., the det function gives the same sign in each case.
12:55:07 <seliopou> it depends
12:55:38 <conal> allEqual l = length (nub l) == 1
12:56:02 <seliopou> you'd want to avoid non-transverse intersections, but if you couldn't, different kind of vertex intersections would have to have different values
12:57:16 <c_wraith> I think we're saying the same thing, but not quite agreeing on the terminology.
12:57:23 <c_wraith> And mine is probably non-standard.
12:57:55 <seliopou> I'm saying there are times that you'd want to count a vertex intersection as 0 rather than 1
12:58:06 <seliopou> in the case where the intersection is "tangential"
12:58:35 <seliopou> (it should really count for 2, but even/odd, whatever)
12:59:36 <c_wraith> Oh, yeah.  I missed that case.  Yeah, there are some subtleties to the general approach.
12:59:54 <c_wraith> If you know your polygon is convex, use the simpler algorithm that started this whole thing. :)
13:00:06 <seliopou> indeed
13:00:34 <seliopou> though there are some things you can do to speed that up
13:00:57 <seliopou> some preprocessing in particular for repeated queries
13:08:14 <det> conal, I has a function??
13:08:53 <Gracenotes> (_)
13:13:47 <conal> det: apparently yeah.  to help distinguish insides from outsides.  use it wisely.
13:16:43 <Mr_Giraffe> is there a module for mathematical vectors?
13:16:52 <Mr_Giraffe> i'm assuming there's a data type for it in haskell, but i dunno where to look
13:17:02 <vininim> any sparse matrix library in hackage?
13:17:08 <conal> Mr_Giraffe: as in vector spaces?
13:17:15 <conal> @hackage vector-space
13:17:15 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/vector-space
13:17:34 <kiris> the voting interface really needs previews and drag and drop. completing this properly will take ages
13:18:00 <Mr_Giraffe> conal: just something simple, like a Vector typeclass
13:18:12 <Mr_Giraffe> i suppose i could write one, but that's a bit more effort than i feel is worthwhile
13:18:34 <conal> Mr_Giraffe: yeah.  look at the vector-space package.  modules AdditiveGroup and VectorSpace
13:19:01 <conal> Mr_Giraffe: you can safely ignore the derivative stuff
13:19:13 <Mr_Giraffe> mm
13:20:54 <conal> Mr_Giraffe: Does that VectorSpace class match what you're looking for?
13:21:30 <Mr_Giraffe> actually, yes
13:21:51 <vininim> oh I see hmatrix is around gsl, and they don't have spblas yet.
13:22:16 <Mr_Giraffe> but i might wind up implementing this differently than i was thinking initially
13:32:23 <kiris> yeah I like the current haskell logo. it represents haskell perfectly, a big beautiful mess
13:33:01 <lament> Haskell: The Language That Badly Needs Stuff Taken Out
13:33:09 <osfameron> hmmm, current logo doesn't seem to be beautiful at all
13:33:22 <kiris> in contrast to The Algorithmic Language Scheme
13:33:31 <Mr_Giraffe> lament: psh
13:33:58 <MyCatVerbs> I'd say it's pretty fitting. Haskell is a language designed by committee, which is reasonably nice despite the fact.
13:34:13 <Mr_Giraffe> designed by committee isn't even quite appropriate, imo
13:34:25 <MyCatVerbs> Haskell's logo looks like it was designed by a committee intent on nailing everything possible onto the thing. Despite the fact, it looks reasonably nice.
13:34:26 <Mr_Giraffe> it's more like...a democratic language
13:34:46 <kiris> "nailing everything possible onto" is the important part. that's what haskell is
13:34:53 <MyCatVerbs> The original H98 standard was put together by, literally, a committee.
13:35:05 <kiris> @vixen do you like the current haskell logo?
13:35:05 <lambdabot> church is my favourite computer scientist.
13:35:13 <MyCatVerbs> It just happens to have been an unusually smart committee. :P
13:35:23 * sw17ch doesn't like current logo
13:35:31 <sw17ch> it's not nearly flashy enough to bring to my boss
13:35:44 <sw17ch> i strongly advocate option 51 or 54 :)
13:35:56 <monochrom> The important thing for Haskell is that the committee is not commercial or political.
13:36:19 <kiris> sw17ch: what about #56? you can pretend haskell is a cool video game about zombies and space
13:36:28 <jmcarthur> yeah haskell is the perl of functional languages
13:36:51 <Nafai> jmcarthur: Bah, that makes me not like it :)
13:36:54 <Philippa_> jmcarthur: I take it you don't consider common lisp an FPL for purpose of that statement?
13:36:55 <p_l> kiris: dead space?
13:36:57 <lament> haskell is the perl of programming languages
13:37:01 <lament> oh wait...
13:37:03 <jmcarthur> it just so happens that most of the crazy features added are type safe :)
13:37:11 <sw17ch> kiris: that one reminds me of an ink blot test, and the first thing that comes to mind is not "awesome language i can get things done with"
13:37:20 <Philippa_> ah, different value of 'perl' :-)
13:37:29 <sw17ch> :)
13:37:41 <Mr_Giraffe> http://media.nokrev.com/junk/haskell-logos/logo1.png i actually like this one
13:37:48 <cnwdup> @src Either (>>=)
13:37:48 <lambdabot> Left  l >>= _ = Left l
13:37:48 <lambdabot> Right r >>= k = k r
13:38:10 <jmcarthur> Philippa, no i don't think common lisp is a good representative of functional languages
13:38:17 <lament> Mr_Giraffe: it looks like the logo of some armed forces. Something you'd expect to see on a shoulder badge.
13:38:17 <cnwdup> @src Either fail
13:38:17 <lambdabot> fail msg      = Left (strMsg msg)
13:38:52 <Mr_Giraffe> lament: i suppose, it is every angular
13:38:58 <sw17ch> Mr_Giraffe: that's my favorite as well
13:39:01 <sw17ch> also my background at work
13:39:19 <sw17ch> lament: i fail to see the problem :)
13:39:44 <Mr_Giraffe> http://www.haskell.org/sitewiki/images/a/a8/Icon_lambda.png this is nice too
13:39:52 <sw17ch> it's smart, precise, not messy, and stylish
13:39:58 <Mr_Giraffe> exactly
13:40:03 <lament> haskell, the droopy language
13:40:20 <kiris> logo1.png is like a laptop's logo
13:40:27 <sw17ch> the ones based on infinity didn't work so well with me
13:40:34 <Mr_Giraffe> i only like that one
13:40:42 <c_wraith> logo1.png is a sort of in-joke.  I'm not sure how I feel about that
13:40:44 <sw17ch> even that one doesn't seem balanced
13:40:48 <johnw> is there some way to get ":info intercalate" to show me where intercalate is defined within my GHC build tree?
13:41:04 <iwannalog> logo1.png is nice
13:41:05 <kiris> I like #15
13:41:08 <Mr_Giraffe> in terms of hilarity though, the narwahl one is *classic*
13:41:23 <Igloo> c_wraith: What's the in-joke?
13:41:30 <Gracenotes> yeah, I voted for the narwhal one
13:41:34 <c_wraith> It has the >>= operator embedded in it
13:41:40 <kiris> #1, #5 and #11 are what I voted for
13:41:57 <Gracenotes> anyone else like 51?
13:41:59 * Nafai seconds johnw's question
13:42:05 <Gracenotes> >\=
13:42:27 <Gracenotes> :D-|-<
13:42:28 <Mr_Giraffe> c_wraith: i wouldn't call that an in-joke per se
13:42:41 <Igloo> c_wraith: Aren't most of them in-jokes due to having a lambda embedded by that logic?
13:42:42 <Eridius> johnw: intercalate is Data.List IIRC
13:42:43 <Mr_Giraffe> >>= is an extremely important part of the language
13:42:45 <Eridius> @index intercalate
13:42:45 <lambdabot> bzzt
13:42:52 <Eridius> darn, that command must not do what I thought
13:42:55 <kiris> @hoogle intercalate
13:42:55 <lambdabot> Data.ByteString intercalate :: ByteString -> [ByteString] -> ByteString
13:42:55 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
13:42:55 <lambdabot> Data.ByteString.Char8 intercalate :: ByteString -> [ByteString] -> ByteString
13:43:00 <Gracenotes> > intercalate ", " ["a", "b", "c"]
13:43:01 <lambdabot>   "a, b, c"
13:43:03 <Eridius> ah yes, hoogle shows where
13:43:13 <johnw> Eridius: I want to know where in List, what line within my build tree
13:43:18 <Nafai> Eridius: But johnw would like the line number so he can jump to the source
13:43:24 <Eridius> @src intercalate
13:43:24 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
13:43:25 <johnw> so I can jump to the definition in inf-haskell-mode with C-c M-.
13:43:28 <Nafai> Eridius: File and line number
13:43:41 * Nafai wonders how @src does it
13:43:44 <Gracenotes> uh, grep the GHC source? :)
13:43:46 <vininim> > let (:D-|-<) x y = True in 1 :D-|-< 2
13:43:47 <lambdabot>   <no location info>: parse error on input `)'
13:43:49 <Gracenotes> Nafai: huge file with many sources
13:43:50 <Eridius> make a tags file for the GHC source?
13:43:53 <Baughn> Nafai: It's got a database of source
13:44:01 <iwannalog> Where do you see the logos ?
13:44:07 <vininim> heh
13:44:08 <Baughn> Nafai: Which often bears little resemblance to the actual code. For example..
13:44:10 <johnw> Eridius: hmm.. so the compiler doesn't know?
13:44:11 <Baughn> @src sortBy
13:44:11 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
13:44:20 <Baughn> Nafai: ^-- That thing is /not/ how it's done. :P
13:44:25 <Heffalump> aargh, this voting process is unusable :-(
13:44:25 <johnw> Eridius: in CL, it knows where every definition came from
13:44:32 <dolio> It's how it's done in the Haskell 98 report.
13:44:39 <Gracenotes> code/extproj/ghc/libraries/base/Data/List.hs
13:44:41 <Gracenotes> 427:intercalate xs xss = concat (intersperse xs xss)
13:44:45 <Gracenotes> ^^ johnw
13:44:45 <Eridius> johnw: you're going to have to talk to someone else about that, I don't know much about how ghc actually works
13:44:53 <Heffalump> if I could see them as I voted, I'd be able to just rank them quickly
13:45:05 <johnw> Gracenotes: you got that info from ghc?  or via tags?
13:45:33 <Gracenotes> GHC source... the runtime keeps enough information about functions for you to use them. Line number is not important in that respect.
13:46:07 <johnw> Gracenotes: but what about the fact that I built with full debugging?
13:46:08 <Gracenotes> oh, but for meta stuff, not just usage
13:46:16 <Baughn> I've often wished for more reflection; it's hard to build a decent middleware layer without it
13:46:17 <Gracenotes> yeah, never mind, not my area :)
13:46:18 <johnw> I can understand a typical installation having no such info
13:46:33 <c_wraith> http://www.haskell.org/sitewiki/images/4/4c/Haskell_proceed.png <-- awesome
13:46:48 <Gracenotes> you might want to try out the ghc mailing list, I guess
13:46:53 <johnw> Gracenotes: thanks!
13:47:23 <Gracenotes> johnw: probably http://www.haskell.org/mailman/listinfo/glasgow-haskell-users
13:48:07 <colin__> Hello, I'm having problems installing my own application on a Mac - cabal dependencies on svgcairo et. al. are causing the problems
13:49:01 <Eridius> colin__:  can you not install svgcairo?
13:49:24 <Eridius> oh svgcairo is part of gtk2hs
13:50:02 <colin__> it is installed - if I comment out the dependency in the .cabal file then when building it says it cannot find the SVG module, which is a memeber of svgcairo, but is hidden
13:50:14 <colin__> I don't understand hidden packages
13:50:14 <Eridius> yes, because you commented it out
13:50:25 <Eridius> cabal hides packages which you don't depend on in order to keep you honest
13:51:01 <djahandarie> Logo 1 is easily the best
13:51:08 <djahandarie> Or maybe it's just presented the best.
13:51:08 <colin__> but the package is installed - I can compile the code if I don't use cabal
13:51:21 <Eridius> colin__: so what's the error you get if you don't comment it out?
13:52:22 <colin__> at least the following dependencies are missing
13:52:30 <sw17ch> Gracenotes: i liked 51
13:53:30 <sw17ch> > let (:]-|-<) x y = True in 1 :]-|-< 2
13:53:31 <lambdabot>   <no location info>: parse error on input `]'
13:53:39 <sw17ch> > let (:}-|-<) x y = True in 1 :]-|-< 2
13:53:40 <lambdabot>   <no location info>: parse error on input `}'
13:53:46 <sw17ch> > let (:/-|-<) x y = True in 1 :]-|-< 2
13:53:47 <lambdabot>   <no location info>: parse error on input `]'
13:53:47 <trofi> : is allowed?
13:53:51 <sw17ch> > let (:/-|-<) x y = True in 1 :/-|-< 2
13:53:52 <lambdabot>   Not in scope: data constructor `:/-|-<'Not in scope: data constructor `:/-|...
13:54:15 <trofi> > let x -:- y = x + y in 1 -:- 2
13:54:16 <sw17ch> > let (:/-|-<) = True in (:/-|-<)
13:54:16 <lambdabot>   3
13:54:16 <lambdabot>   Not in scope: data constructor `:/-|-<'Not in scope: data constructor `:/-|...
13:54:38 <trofi> > let x -/:\- y = x + y in 1 -/:\- 2
13:54:39 <lambdabot>   3
13:55:10 <trofi> > let x :D y = x + y in 1 :D 2
13:55:11 <lambdabot>   Not in scope: data constructor `D'Not in scope: data constructor `D'
13:55:18 <trofi> > let x :] y = x + y in 1 :] 2
13:55:19 <lambdabot>   <no location info>: parse error on input `]'
13:56:28 <kiris> Heffalump: I just ranked the ones I thought were ones and twos and skipped the rest
13:56:59 <kiris> iwannalog: http://www.haskell.org/logos/poll.html
13:57:48 <roconnor> This grant application form want to know what the anticipated impact of my research will be.
13:57:57 <roconnor> I'm not sure how I should try to answer this question.
13:58:50 <iwannalog> kiris: I found it, but thx.
13:59:01 <thetallguy> roconnor: what will it replace, what will it enable
13:59:23 <thetallguy> roconnor: what new areas might it open up
13:59:25 <vixey> roconnor: about the integration and reals?
13:59:44 <iwannalog> But how we do to vote ?
13:59:59 <lament> does the narwhal have an explanation?
14:00:31 <roconnor> vixey: about a formal proof of the Feit-Thompson theorem.
14:00:42 <roconnor> thetallguy: that is helpful
14:01:30 <vixey> The proof of the Feit-Thompson theorem took up an entire journal issue (Feit and Thompson 1963).
14:01:44 <iwannalog> 300 pages
14:01:44 <thetallguy> roconnor: the funder's job is to maximize the impact of money granted.  research has a return on investment just like any other business
14:02:20 <thetallguy> roconnor: they are more likely to fund work on a theoretical problem that will unblock other work
14:03:15 <thetallguy> roconnor: the more people/time/money that goes into working on or around the problem you are solving, the more likely the funding.
14:03:32 <thetallguy> (often0
14:03:33 <thetallguy> )
14:04:38 <thetallguy> roconnor: even if your work is a brick in a new bridge, highlight that the bridge will be the shortest way over the river and that your brick is a keystone...
14:04:49 <sw17ch> some how i get the impression that roconnor is fairl familiar with how grants work
14:04:49 <roconnor> hmm
14:06:45 <thetallguy> roconnor: but most importantly, just make it easy for them
14:07:13 <roconnor> heh
14:07:15 <roconnor> 25 lines
14:07:27 <drdozer1> is there any way to tell the compiler that a given symbol should be accessed exactly once in your code?
14:08:02 <c_wraith> What's the use case for that, drdozer1?
14:08:14 <roconnor> accessed?
14:08:35 <drdozer1> c_wraith: let { b = f a ; c = g b ; d = h b } in d
14:08:45 <drdozer1> so each of b, c, d are accessed exactly once
14:09:06 <stepcut> drdozer1: in concurrent clean, you can use uniqueness types, but Haskell does not have the feature.
14:09:07 <roconnor> drdozer1: you mean ... d = h c ... ?
14:09:09 <thetallguy> drdozer1: that seems like imperative thinking.
14:09:15 <drdozer1> a common bug would be to miss-type as I did - I intended d = h c
14:09:26 <roconnor> drdozer1: not in Haskell.  You need a linear type system
14:09:45 <sjanssen> drdozer1: don't give them names: h . g . f $ a
14:10:03 <drdozer1> roconnor: right - I guess what I'm asking is if there is an ascii-char I can prefix the name with to tell the compiler that the symbol is 'linear'?
14:10:08 <roconnor> sjanssen: join h . g . f  :)
14:10:24 <roconnor> drdozer1: not in haskell
14:10:27 <drdozer1> sjanssen: you can in this case, but in the general case you can not
14:10:43 <drdozer1> roconnor: pity - it would cut out one class of bugs I generate
14:10:45 <sjanssen> drdozer1: you can in the general case, but it may become unreadable
14:11:12 <drdozer1> sjanssen: yeah - unreadable == bugs
14:11:39 <c_wraith> wouldn't the compiler warn that c was unused, in the example you gave?
14:11:48 <roconnor> drdozer1: do your b c and d happen to have the same type?
14:12:43 <drdozer1> drdozer1: yeah, they do
14:13:03 <drdozer1> c_wraith: possibly - it doesn't when I build from cabal install
14:13:29 <roconnor> drdozer1: sounds like you should be using a state monad
14:14:21 <roconnor> drdozer1: granted, that can be sort of a heavy solution
14:14:54 <c_wraith> it's conceptually kind of heavy, given the problem it's solving..  But there's no denying it'd work
14:21:37 <roconnor> thetallguy: our science minister won't confirm or deny his belief in evolution.
14:21:49 <roconnor> oh wait, this is a provincial grant.
14:22:00 <roconnor> so I guess the federal minister doesn't matter
14:22:55 <tromp_> > succ.succ $ '-'
14:22:56 <lambdabot>   '/'
14:23:07 <tromp_> > pred.pred $ '+'
14:23:08 <lambdabot>   ')'
14:23:09 <thetallguy> roconnor:  ooogh
14:24:23 <thetallguy> roconnor: which province?
14:24:33 <roconnor> Ontario
14:24:46 <roconnor> Actually, the grant has already been given to McMaster
14:24:57 <roconnor> and it seems to be solely up to McMaster, which students get the grant
14:25:19 <roconnor> McMaster University
14:25:57 <thetallguy> Then you need to learn about the Dean
14:27:22 <adiM> Is there a function to convert [1,2,3,4,5,6] to [(1,2),(3,4),(5,6)]
14:27:48 <roconnor> adiM: not in the standard libs
14:28:03 <ImInYourMonad> to implment a very basic webserver, what do i need to do? take requests and serve responses? ie a webserver can be incredibly simple or very complicated depending on how ambitious you are, there isnt a bit amount of features that have to be there?
14:28:05 <vixey> adiM: is it undefined for [1,2,3,4,5,6,7]?
14:28:21 <adiM> vixey: yes, the list is guaranteed to be even
14:28:39 <vixey> the just use  pairs (x:y:zs) = (x,y) : pairs zs
14:28:51 <vixey> pairs [] = ][
14:29:02 <adiM> Ah, thanks vixey!
14:29:15 <roconnor> vixey++
14:29:28 <adiM> :)
14:30:36 <RayNbow> @faq Can Haskell help to prevent power outages?
14:30:37 <lambdabot> The answer is: Yes! Haskell can do that.
14:30:41 <lunabot>  luna: lexical error in string/character literal at end of input
14:32:34 <ImInYourMonad> to implment a very basic webserver, what do i need to do? take requests and serve responses? ie a webserver can be incredibly simple or very complicated depending on how ambitious you are, there isnt a bit amount of features that have to be there?
14:32:35 <lincolnq> > 3
14:32:36 <lambdabot>   3
14:32:53 <ImInYourMonad> @faq can haskell cause power outages?
14:32:53 <lambdabot> The answer is: Yes! Haskell can do that.
14:34:05 <icee> @faq can haskell rape small children?
14:34:05 <lambdabot> The answer is: Yes! Haskell can do that.
14:34:59 <lament> @faq can Haskell Curry rape small children?
14:34:59 <lambdabot> The answer is: Yes! Haskell can do that.
14:36:35 <ImInYourMonad> @faq can haskell give therapy to icee and lament?
14:36:35 <lambdabot> The answer is: Yes! Haskell can do that.
14:36:50 <ImInYourMonad> partial rape?
14:36:52 <monochrom> ...
14:36:55 <Badger> hurray for haskell!
14:38:15 <icee> partial?
14:41:14 <mstr> some people are on lazy medication?
14:42:56 <c_wraith> @faq can haskell solve the halting problem?
14:42:57 <lambdabot> The answer is: Yes! Haskell can do that.
14:43:12 <vixey> @keal
14:43:12 <lambdabot> can GMP support KealDigit? I invent KealDigit
14:43:21 <icee> t love to c_wraith's mother?
14:43:22 <icee> ert
14:43:29 <icee> @faq can Haskell make sweet love to c_wraith's mother?
14:43:29 <lambdabot> The answer is: Yes! Haskell can do that.
14:43:41 <c_wraith> accidental select/delete there?
14:43:51 <icee> not really sure what meta key i hit
14:44:10 <Badger> he accidentally the whole mum insult.
14:44:40 <vixey> @keal
14:44:40 <lambdabot> i have basically written a proof that shows an assumption is wrong
14:45:34 <dolio> Heh.
14:45:34 <c_wraith> Oh.  Yeah, sometimes that "your mom" button causes friction.
14:45:46 <dolio> Basically written a proof. Not actually, but basically.
14:45:51 <c_wraith> I don't even know why they put it on keyboards
14:46:16 <adiM> Can someone help me to clean this function: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2515
14:46:30 <monochrom> yay real haskell
14:46:37 <adiM> I do not like the flow control here
14:46:52 <vixey> change it to:
14:46:57 <vixey> modify = ...
14:47:03 <vixey> and delete: $ gr
14:47:04 <dolio> Wow, does one of the graph libraries use 5-tuples?
14:47:26 <adiM> the five tuple is from one of my functions
14:47:32 <dolio> Ah.
14:47:54 <adiM> vixey: gr is used inside the where clause, so I can't delete it
14:48:22 <vixey> adiM: oh :(
14:48:45 <beelsebob> adiM: map (uncurry f) $ zip x y is zipWith f x y
14:48:51 <adiM> I am more concerned with a bunch of parallel concatMaps
14:49:14 <adiM> beelsebob: thanks
14:49:27 <monochrom> There is a chance you can use the do-notation.
14:49:48 <beelsebob> I think this is a case where using the do notation would be the oposite of useful
14:49:53 <beelsebob> there's nothing being "done" here
14:49:57 <beelsebob> nor any order
14:50:03 <dolio> They're all 'concatMap ... variables'.
14:50:19 <dolio> So I don't think do notation is applicable.
14:51:07 <monochrom> There is a chance you can use list comprehension.
14:51:31 <adiM> Is there a way I can do all of these computations in parallel, without having to go through the list three times?
14:51:45 <vixey> attribute grammars!
14:51:59 <vixey> adiM: yes you just mush them together into a tuple
14:51:59 <monochrom> . o O ( more tuples... )
14:52:02 <dolio> You can rewrite it as a foldr, but it won't look any better.
14:52:11 <beelsebob> adiM: I would hope that the compiler will fuse them
14:52:30 <adiM> Ah, the Glorious compiler :)
14:52:34 <beelsebob> :)
14:53:10 <adiM> So, basically unless performance becomes a real issue, I should just leave this function as it is
14:53:14 <beelsebob> in the mean time, if I were to try and clean this up, I would guess that the lambdas in there actually have a name
14:53:18 <monochrom> I think so.
14:53:20 <beelsebob> they seem to be sensible selectors
14:53:46 <mreh> > foldl (max) [10..1]
14:53:47 <lambdabot>       Overlapping instances for Show ([[t]] -> [t])
14:53:47 <lambdabot>        arising from a use...
14:53:50 <beelsebob> that would clean things up significantly
14:54:10 <beelsebob> > foldl max 0 [10,9..1]
14:54:11 <lambdabot>   10
14:54:30 <mreh> doi
14:54:40 <mreh> ta
14:54:55 <beelsebob> better yet...
14:55:01 <beelsebob> > foldl1 max [10,9..1]
14:55:02 <lambdabot>   10
14:55:11 <beelsebob> (now you can deal with negatives too)
14:55:19 <beelsebob> better yet...
14:55:24 <beelsebob> > maximum [10,9..1]
14:55:24 <mreh> High-five!
14:55:25 <lambdabot>   10
14:55:31 <mreh> heh
14:55:39 <mreh> @src maximum
14:55:39 <lambdabot> maximum [] = undefined
14:55:39 <lambdabot> maximum xs = foldl1 max xs
14:55:47 <mreh> :D
14:56:04 <mreh> @src foldl1
14:56:04 <lambdabot> foldl1 f (x:xs) = foldl f x xs
14:56:04 <lambdabot> foldl1 _ []     = undefined
14:56:10 <adiM> shouldn't one use foldl1' instead of foldl1 here?
14:56:15 <beelsebob> no
14:56:20 <adiM> I meant for maximum
14:56:23 <beelsebob> max can be non-strict
14:56:27 <beelsebob> for certain types
14:56:31 <beelsebob> so so can maximum
14:56:37 <adiM> ok
14:56:40 <beelsebob> arbitrarily strictifying code == bad
14:56:47 <monochrom> Yeah, use foldl1' yourself if you need it.
14:57:05 <mreh> @src foldl1'
14:57:05 <lambdabot> Source not found. :(
14:57:12 <beelsebob> strictifying should only be done when you identify that you really do have a memory leak, and you're really really certain that you don't lose anything with strictness
14:57:15 <monochrom> I do regret that maximum is non-strict. Probably more than minimum surprise.
14:57:20 <mreh> i take it it just has a `seq` in there
14:57:26 <mreh> foldl1'
14:57:36 <monochrom> It has a seq in every iteration.
14:57:53 <beelsebob> monochrom: perhaps it's worth suggesting for Haskell' that maximum' and minimum' should exist
14:57:58 <mreh> foldl1' f x xs `seq` xs
14:58:02 <beelsebob> but I have several programs that use the non-strictenss of maximum
14:58:11 <beelsebob> (Reactive is a good example there actually)
14:58:18 <monochrom> http://www.haskell.org/haskellwiki/Stack_overflow  has details on foldl'
14:58:25 <Nafai> If I have two versions of a package installed with cabal, how do I unregister a specific version?
14:59:04 <ddarius> monochrom: From that perspective, any laziness is more than minimum surprise.
14:59:10 <mreh> isn't non-strictness aka "laziness"?
14:59:11 <monochrom> ghc-pkg unregister halting-problem-solver-3.1.4.5
14:59:37 <monochrom> hahaha ok
14:59:43 <Nafai> monochrom: Doesn't work :(
15:00:31 <monochrom> Then I don't know. Do you have remote desktop access so I can login your computer and mess with things?  <duck>
15:01:31 <monochrom> I speak like "strict, non-strict", and "eager, lazy". I am thoroughly annoyed by "strict, lazy".
15:02:11 <mreh> one is opposite of t'other
15:02:17 <ImInYourMonad> Not in scope: `hGetLine' anyone know where it livs?
15:02:19 <ImInYourMonad> lives
15:02:24 <monochrom> System.IO
15:02:28 <Eridius> @hoogle hGetLine
15:02:28 <lambdabot> Data.ByteString hGetLine :: Handle -> IO ByteString
15:02:28 <lambdabot> System.IO hGetLine :: Handle -> IO String
15:02:28 <lambdabot> Data.ByteString.Char8 hGetLine :: Handle -> IO ByteString
15:03:30 <monochrom> I am not annoyed by "strict, lazy" from, let's say, people with <1year haskell experience. It's totally understandable and I am not that anal.
15:03:52 <monochrom> I am thoroughly annoyed when all the learned veterans do that too.
15:03:55 <c_wraith> the libraries do the whole strict/lazy thing, though
15:04:05 <ImInYourMonad> http://lstephen.wordpress.com/2008/02/14/a-simple-haskell-web-server/ <- is that supposed to work at all?
15:04:19 <Eridius> monochrom: can you clarify the difference between "non-strict" and "lazy"?
15:05:07 <monochrom> strict and non-strict talks about what cases get you bottom and what cases don't. at the level of denotational semantics, if you will.
15:05:17 <monochrom> eager and lazy talks about execution.
15:05:32 <Eridius> ahh
15:05:42 <Eridius> ok, now I understand the context
15:05:50 <dolio> There are several evaluation strategies that can be classed as non-strict.
15:06:29 <dolio> A simple example is to eliminate sharing from lazy (call-by-need) evaluation (which is called call-by-name).
15:06:31 <monochrom> The same learned veterans who write like "strict, lazy" are the same people who, on the mailing list, lecture you all the time on "don't mix up denotational and operational". That annoys me.
15:07:11 <mreh> Your mum annoys me.
15:07:39 <mreh> is it really that important
15:08:15 <mreh> i'm not being a pest, but I can't see the different
15:08:23 <mreh> difference*
15:08:27 <dolio> So under call-by-need '(\x -> x + x) (1 + 1)' reduction evaluates '1 + 1' once, whereas under call-by-name, it'd be evaluated twice.
15:08:47 <monochrom> Self-consistency is important. You lecture on not mixing them up, you behave according to your own lecture.
15:08:47 <roconnor> dolio: ya, what are the denational counterparts to the terms "normal-order" and "call-by-value" ?
15:09:11 <monochrom> You honestly believe there is no useful distinction, you behave as such.
15:09:49 <mreh> i honestly dont know
15:09:59 <roconnor> Actually, is there a nice way of giving denotation semantics to CBV?
15:09:59 <mreh> strict = eager to me
15:10:20 <bmh> the trouble with laziness is that I only want laziness when I want laziness.
15:10:41 <roconnor> bmh: really?  Most of the time I don't even care.
15:10:51 <mreh> Let's get Larry Wall in to talk about laziness, then we'd have a real ball
15:10:55 <bmh> roconnor: I should really make my jokes more clear.
15:10:56 * bremner hands bmh a language with the lazy keyword
15:11:06 <roconnor> :)
15:11:17 <dolio> roconnor: I'm not sure I understand that question. :)
15:11:57 <monochrom> Here is one way to do non-strict. Let's say evaluate "True || (infinite loop here)". You spawn two threads, one for each operand. The first thread finishes quickly, and you have the answer early. You may stop the second thread then.
15:12:04 <dolio> I always forget what 'normal order' refers to exactly.
15:12:15 <monochrom> Both threads are eager.
15:12:36 <mreh> but the program is lazy
15:12:58 <mreh> there are no loops in haskell either
15:13:26 <monochrom> Here is why it is eager not lazy. The infinite loop may consume lots of memory and electricity. You actually do that, not skip that. Lazy evaluation would not spend the memory or electricity.
15:14:17 <ImInYourMonad> what kind of mongoloid stuff is this:
15:14:19 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2518#a2518
15:14:30 <monochrom> haha mongoloid
15:14:36 <roconnor> > let f n = f (n+1) in f 0
15:14:48 <lambdabot>   mueval: Prelude.read: no parse
15:14:52 <monochrom> It's the Genghis Khan Monad.
15:15:09 <dolio> I believe the experiment with that evaluation strategy was dubbed "optimistic evaluation".
15:15:28 <ImInYourMonad> bah
15:15:29 <dolio> Or is optimistic the one where you try evaluating arguments right away, but stop if it takes too long?
15:15:29 <ImInYourMonad> init
15:15:57 <dolio> I guess it might be the latter.
15:17:00 <monochrom> I guess there is something about "strict" that forces you to be eager.
15:17:04 <dolio> Oh, the threaded one is "call by future" according to wikipedia.
15:17:36 <pejo> dolio, evaluating things for a while hoping they'd finish sounds like optimistic evaluation.
15:18:06 <bmh> I'm interested to see who's sponsoring haskell related GSOC projects
15:18:08 <dolio> And it says normal-order is different from call-by-name in that the former doesn't "evalute inside the body of an unapplied function."
15:18:28 <djwonk> I'm working on a board game...
15:18:32 <djwonk> I have data (CornerObject c, EdgeObject e) => Board c e = ...
15:19:07 <djwonk> but I use "Board" many times, so keeping the qualified types over and over is very repetitive
15:19:20 <djwonk> is there a way to hide these away somehow?
15:19:53 <koeien> i have two code fragments, one is       Just (u,us) -> fstB <+> sndB,   the other is  Just (u,us) -> result where result = fstB <+> sndB.    why is the second one slower?
15:22:47 <koeien> ah n/m, i forgot about some program running in the background.
15:24:01 <zcvvc> beginner question: is every Monad an instance of Functor?
15:25:07 <djwonk> zcvvc: I may be newer than you.  Have you tried `:i Monad` and `:i Functor`?
15:25:08 <dolio> It could be.
15:25:24 <Peaker> zcvvc: in theory, yes. In practice, probably not always (due to negligence of authors)
15:25:28 <dolio> It's not required by the structure of the libraries, though.
15:26:14 <Peaker> instance Functor <someMonad> where fmap = liftM ; instance Applicative <someMonad> where pure=return ; (<*>) = ap
15:26:28 <djwonk> zcvvc: in the Prelude, it appears to hold for [], Maybe, and IO
15:26:57 <Peaker> it *should* hold for everything. If something has a Monad instance and no Functor instance, its basically a bug
15:27:08 <Peaker> fixable with the above instances
15:28:41 <jmcarthur> djwonk, yes, but it may not be considered good style if it's just to save typing and not to hide implementation. look into the ExistentialQuantification extension
15:29:09 <jmcarthur> djwonk, warning, overuse of this extension can tempt you into OO style programming, which isn't necessarily bad, but usually there are more functional ways
15:29:11 <zcvvc> thanks alll. so IIUIC every monad can be made a functor by using liftM, but it usually requires separate declaration?
15:29:36 <jmcarthur> zcvvc, only because monad isn't defined as class Functor m => Monad m where ...
15:29:44 <zcvvc> is it possible to fix it?
15:29:44 <jmcarthur> although it probably should be
15:30:08 <jmcarthur> zcvvc, it would still require a separate definition, but that definition would at least be required for something to be a monad then
15:30:11 <ddarius> zcvvc: It always requires a separate declaration.  It's just a matter of whether it's done by you or by the library author.
15:30:27 <djwonk> jmcarthur: thanks, appreciate it
15:30:30 <zcvvc> I understand. thanks all for answers
15:30:51 <jmcarthur> zcvvc, there is the temptation by some to make instance Monad m => Functor m where ... but that requires extensions and is a big risk of overlapping instances
15:31:28 <jmcarthur> in fact, basically a guarantee of overlapping
15:31:29 <ddarius> jmcarthur: "big risk" is a bit of an understatement.
15:32:25 <ImInYourMonad> instance Stream Handle where; what are instances? typeclasses?
15:33:37 <ImInYourMonad> if I want to serve a page at 8080, what is the easiest way? Network.Render.renderString 8080 "hello" ; is there something like that?
15:34:01 <jmcarthur> ImInYourMonad, yes. an instance of a type class is a definition of a dictionary that is looked in wherever the type class is used
15:34:09 <c_wraith> ImInYourMonad: you should at least return a proper http response
15:34:10 <vixey> you can use nc and practice being a webserver by hand
15:34:55 <kynky> assume that it could ?
15:35:25 <ImInYourMonad> nc?
15:35:37 <jmcarthur> i think she means netcat ?
15:35:45 <c_wraith> yes, nc is netcat
15:36:39 <jmcarthur> and i agree. it's a very nice way to experiment with the http protocol
15:38:04 <ddarius> socat
15:38:48 <roconnor> telnet
15:39:03 <idnar> don't forget, HTTP uses CRLF line endings
15:40:51 <Peaker> oh man, the guy who started crlf ought to be punished
15:41:29 <c_wraith> you mean the teletype?  CRLF is two independent commands to a teletype, both are needed. :)
15:41:47 <kynky> guess it seemed sensible at the time given the circumstances
15:41:47 <Peaker> I mean the guy who thought it would be a good idea to bring CRLF to the PC
15:42:49 <kynky> which generation of PC do you mean ? as soon as we got guis ?
15:43:22 <jmcarthur> if only they would be interpreted the same way on computers as they were on teletypes, it would be okay
15:43:44 <kynky> its the windows/nix/mac thing that annoys me
15:44:01 <c_wraith> So really, then...  DOS did it right?  That's not something I'm used to hearing. :)
15:44:03 <kynky> different thigs for the same thing
15:44:34 <kynky> DOS did it its own way
15:44:52 <kynky> unix existed before dos
15:45:27 <p_l> CRLF in network protocols comes afaik from TOPS-10/TOPS-20
15:45:44 <p_l> and similar PDP-10 systems
15:46:03 <wli> UNIX was not the only tradition.
15:47:09 <p_l> afaik CRLF was written into RFC precisely in order to avoid future problems about what kind of line endings which protocols might use, as well because PDP-10 formed most of ARPAnet (Unix got networking shoehorned into it much later)
15:49:00 <RayNbow> > vbCrLf  -- something tells me my youth has been ruined by VB :p
15:49:01 <lambdabot>   "\r\n"
15:49:57 <ImInYourMonad> ok good tips because i want to learn the fundamentals and theory of tcp ip, ntowkring, http etc
15:50:04 <colouragga> Would Haskell be an appropriate language for world domination?
15:50:27 <colouragga> ImInYourMonad: well TCP/IP and UDP/IP are whole different worlds from HTTP.
15:50:56 <kynky> as long as you deal with all side-effects in the correct manner
15:51:18 <RayNbow> colouragga: http://www.haskell.org/sitewiki/images/8/85/NarleyYeeaaahh.jpg <-- does this answer your question?
15:51:42 <ImInYourMonad> can you do wardialing these days? you can do piggybacking obv.
15:52:15 <kynky> read a networking book, osi protocol layers, i.e. http sits on tcp which sits on ip, which sits on ...
15:52:43 <colouragga> RayNbow: If the narwhal had a planet on it's spike, yes.
15:58:27 <Peaker> ImInYourMonad: I can try to explain TCP/IP in #haskell-overflow if you want
16:00:56 <pumpkin_> both tcp and ip?
16:01:05 <Peaker> yeah
16:01:08 <Peaker> well, the basics
16:01:15 <pumpkin_> mmm
16:01:19 <colouragga> I would be interested, I know a fair bit about UDP.
16:01:29 <Peaker> I don't know everything about TCP -- there are all sorts of algorithms TCP uses that I don't know about
16:01:48 <kynky> all about the windows
16:01:50 <Peaker> IP is pretty simple if you ignore all sorts of weird options
16:02:20 <wli> SCTP is rather interesting because it supports things like reliable out-of-order delivery.
16:02:39 <dude7064> anybody here has experience working with SIM300 ? It's a GPRS module and need to have it commuincate with a microcontroller (WILL PAY if somebody is interested in helping me out)
16:02:56 <kynky> header-payload
16:11:09 <romildo> Hi.
16:14:43 <romildo> I want to extract some information from web pages. Up to know I have been doing that using the text rendered by some browser. I have been using regular expressions for that. But I miss some information in this process (like image links). Is there a good library to help me dealing with html directly in an easy way?
16:14:55 <romildo> s/know/now/
16:17:20 <McManiaC> romildo: did u take a look at http://hackage.haskell.org/packages/archive/pkg-list.html ?
16:17:37 <romildo> McManiaC, I am doing that now.
16:18:07 <McManiaC> ok, otherwise i dont know :)
16:19:24 <int-e> romildo: tagsoup comes to mind
16:19:55 <c_wraith> I've used tagsoup-ht.  I found it pleasant-enough.
16:29:58 <mreh> what module is nub in?
16:30:09 <mreh> @hoogle nub
16:30:09 <lambdabot> Data.List nub :: Eq a => [a] -> [a]
16:30:09 <lambdabot> Data.List nubBy :: (a -> a -> Bool) -> [a] -> [a]
16:30:16 <vixey> Data.List
16:31:52 * allbery_b thinks the one thing the logo poll is missing is "dear g-d, they're all beyond ugly - including the current one"
16:32:00 <lowmagnet> haha
16:32:43 <lowmagnet> I prefer the word "haskell" in helvtica bold
16:40:12 * mmorrow votes for the haskell nomads one
16:40:41 <vixey> @go haskell nomads
16:40:42 <lambdabot> No Result Found.
16:41:37 <mmorrow> gah, i can't find it. it's hillarious.
16:42:42 <fnor> Hi
16:44:21 <mreh> :t undef
16:44:22 <lambdabot> Not in scope: `undef'
16:44:33 <mreh> what is that keyword for a partial definition?
16:44:49 <vixey> @src undefined
16:44:49 <lambdabot> undefined =  error "Prelude.undefined"
16:44:59 <mreh> thanks
16:47:35 <Badger> > maxBound
16:47:37 <lambdabot>   ()
16:47:53 <Badger> > maxBound :: Int
16:47:55 <lambdabot>   9223372036854775807
16:47:58 <ddarius> > maxBound == minBound
16:47:59 <lambdabot>   True
16:49:21 <edwardk> hrmm, the off-by-one mealy machine that conal mentioned back in http://conal.net/blog/posts/functional-reactive-partner-dancing/ is a comonad.
16:50:09 <edwardk> http://comonad.com/haskell/Mealy.hs
16:51:25 * edwardk is amused because if you have a comonadic automaton, that means you can have mealy machine that iterates it -- a comonadic automaton automaton.
16:54:44 <Badger> @hoogle CReal
16:54:44 <lambdabot> No results found
17:03:21 <mreh> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2520#a2520
17:03:28 <mreh> what is wrong with line 2?
17:04:09 <mreh> it tells me it infers (Point -> a) from len c d
17:07:29 <c_wraith> that makes it sound like len wants 3 args
17:08:11 <c_wraith> But really, it's hard to say exactly what's wrong without knowing the definition of Len, and the type definitions being used.
17:08:16 <c_wraith> *len
17:08:17 <Saizan_> mreh: you should annotate with the whole error, and the type and/or definition of len
17:09:42 <mreh> i'll paste all the src
17:10:46 <mreh> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2521#a2521
17:10:59 <mib_lh0272> hi folks. I'd like to develop commercial GUI apps in Haskell. Do you have any advice for me? What toolkit would you use? What IDE/UI designer? Are there installers that package Haskell binaries?
17:11:02 <mreh> len is just the pythagorean distance between two points
17:11:32 <dons> mib_lh0272: gtk2hs is good, robust, and widely used
17:11:55 <lilac> mreh: don't you mean len (c, d) not len c d?
17:12:32 <mib_lh0272> dons: on Windows what would I use to design the UI if I go with gtk2hs?
17:12:54 <dcoutts> mib_lh0272: glade
17:13:26 <mreh> man, i am dense
17:13:26 <lilac> mreh: or possibly intersect (Circ (c0,c1) r) (Circ (d0,d1) s) = len (c0-d0,c1-d1) <= ...
17:13:33 <mreh> yeah, that one
17:13:42 <lilac> do you have a Num instance for point?
17:13:58 <mreh> Point = (Int,Int)
17:14:28 <lilac> you've defined an add and a negate, that's probably enough to justify a Num instance
17:14:32 <mib_lh0272> dcoutts: thanks. So Glade + gtk2hs will be a good combination that will work on the major OSes?
17:14:40 <lilac> even though you can't sensibly define mulitplication
17:14:54 <dcoutts> mib_lh0272: yep
17:15:38 <mib_lh0272> and say that I have a myapp.exe, myapp.app and myapp.bin. How can I have an installer to include all the dependencies? Can I just use generic installers?
17:16:15 <dcoutts> mib_lh0272: yes, eg I've used InnoSetup before to make Windows installers for gtk2hs progs.
17:16:45 <dcoutts> mib_lh0272: it has to handle installing all the gtk.dll files too, but it's not hard.
17:20:17 <mib_lh0272> dcoutts: thanks
17:23:17 <mib_lh0272> oh and what do you people think about wxHaskell?
17:26:02 <kmeyer> anyone familiar with compiling JHC?
17:37:41 <ImInYourMonad> Peaker++
17:39:18 <dolio> @quote qwe1234
17:39:18 <lambdabot> qwe1234 says: the only reason for 'dispatching, polymorphism and parametrization' to exist at all is for enforcing safety.
17:39:35 <dolio> @quote qwe1234
17:39:35 <lambdabot> qwe1234 says: check out 'complexity theory', it's all there.
17:39:50 <olsner> :)
17:40:08 <olsner> trolls <3
17:41:55 <Lemmih> @seen ndm
17:41:55 <lambdabot> I haven't seen ndm.
17:42:19 <pejo> Lemmih, he isn't around much on irc, but he responds quickly to mail.
17:42:28 <dolio> preflex: seen ndmitchell
17:42:28 <preflex>  Sorry, I haven't seen ndmitchell
17:43:09 <Lemmih> pejo: Thanks.
17:51:05 <lowmagnet> uh oh >> and >>= time
17:51:42 <mdmkolbe> type error: `and' expects argument of type [Bool], ;-P
17:52:22 <lowmagnet> I'm surprised yi doesn't use 'MATHEMATICAL DOUBLE RIGHT DOUBLE ANGLE BRACKET'
17:52:32 <lowmagnet> http://www.fileformat.info/info/unicode/char/27eb/index.htm
17:55:45 <EvilTerran> lowmagnet, i've seen TeX-ed papers use >\!>\!=
17:57:17 <EvilTerran> (where \! is "negative thin space")
17:57:51 <mun> hi
17:57:59 <lowmagnet> though 'z notation schema piping' makes sense from its name
17:58:29 <mattam> lowmagnet: I use \mathbin{>\!\!\!>\mkern-6.7mu=} and I think I took it from lhs2tex or something like that.
17:58:35 <mun> i'm trying to compile a program, but i'm getting errors, e.g., "ghc-pkg: cannot find package tar" "ghc-pkg: cannot find package glade"  etc. how do i add the packages?
17:58:43 <plesn> hello
17:59:13 <lowmagnet> mun: does the program have a bootstrap.sh?
17:59:44 <mun> lowmagnet, no, not that i can see
18:00:00 <lowmagnet> ah, k, stuff like cabal gets dependents that way
18:00:28 <mle> mun: grab cabal-install.  It has the ability to download, compile, and install these dependencies
18:00:42 <mle> the cabal-install package itself has a bootstrap.sh to get things rolling.
18:00:54 <mle> you'll need to add ~/.cabal/bin to your path though.
18:00:55 <mun> i'll try that now
18:06:02 <plesn> what would be an efficient way to read a Float from a ByteString ?
18:06:15 <plesn> I'm reading a big table of numbers, and most of the time is consumed by (read . L.unpack) ...
18:06:56 <pumpkin> plesn: read a Word32, unsafeCoerce it to a Float ;)
18:07:23 <int-e> plesn: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/bytestring-lexing
18:07:29 <pumpkin> oh, that
18:07:41 <plesn> oh, yes! good idea! thanks very much!
18:08:10 <pumpkin> which?
18:08:14 <wli> I'd write a C or assembly FFI function that does the coercion.
18:08:53 <pumpkin> why do you need that?
18:09:13 <plesn> I'm going to try that
18:09:24 <pumpkin> :o
18:09:44 <plesn> no, not the assembly/ffi way...
18:10:26 <pumpkin> so you're lexing it, or reading the binary form? if you're reading and writing it, you can just use the get/put instances for Float
18:10:31 <pumpkin> but they use lots of space
18:10:43 <plesn> I'm trying to rewrite some python scripts, to learn a bit of new things
18:13:15 <jberryman> would anyone care to look at this function and give any advice on avoiding explicit recursion in the function 'f' here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2524  ?
18:14:01 <jberryman> it's ALMOST elegant I think. any advice on the 'divide' function appreciated as well
18:15:47 <Saizan_> is it building a balanced tree?
18:16:31 <jberryman> Saizan_: yes, nearly optimal
18:17:36 <Saizan_> i don't think i'd use foldl' for such a thing, you want to be lazier than that
18:18:34 <mattp__> are there any good books written on haskell?
18:18:47 <mun> i'm trying to compile a program, but i'm getting errors, e.g., "ghc-pkg: cannot find package tar" "ghc-pkg: cannot find package glade"  etc. now i got cabal-install, but how do i add the packages?
18:18:53 <ImInYourMonad> @faq is Haskell greater than Googol?
18:18:53 <lambdabot> The answer is: Yes! Haskell can do that.
18:18:55 <wli> AVL is typically so close to optimal that you could probably just do rebalancing fixups on an AVL tree.
18:18:57 <mattp__> math oriented? ive heard poor things about the one in the topic
18:19:12 <omnihil> mattp, http://book.realworldhaskell.org/read/
18:19:35 <mattp__> omnihil: thanks!
18:19:52 <Saizan_> mun: cabal install tar
18:20:03 <Saizan_> mun: glade is not available on hackage though
18:20:30 <mun> i've tried that, but i get the the error "cabal: There is no package named tar"
18:20:39 <mun> oh my bad
18:20:41 <mun> i haven't updated the list
18:21:13 <wli> Although if you keep count of total descendants and rebalance ad hoc based on that, you can probably keep things in optimal balance that way.
18:21:44 <Saizan_> it's function is assuming a sorted list as input
18:21:52 <Saizan_> s/it's/his/
18:22:11 <wli> Oh, you can do much better in that case, though I don't know anything specific about how.
18:22:20 <jberryman> wli: I'm writing a binary search tree module, so I think importing AVL trees is cheating ;)
18:22:59 * Saizan_ got curious
18:23:05 <Saizan_> @source Data.Set
18:23:05 <lambdabot> http://darcs.haskell.org/packages/base/Data/Set.hs
18:23:48 <wli> jberryman: You could just write them, then.
18:24:04 <wli> jberryman: But AVL is height-balanced, not descendant-balanced.
18:25:12 <jberryman> really I would be happy with an elegant function to partition a list into sublists of increasing length. asked earlier but didn't get the expected brilliant responses
18:25:16 <wli> jberryman: HB[k] is where the two children of a node in a binary tree have heights differing by at most k, AVL is HB[1], optimal trees are more stringent and have bounds on differences of descendants.
18:26:22 <wli> jberryman: So starting from HB[1] you can adjust to fix up differences of descendants.
18:27:01 <wli> jberryman: OTOH AVL can be constructed from a sorted list in linear time.
18:27:34 <jberryman> wli: I'm finishing a Splay Tree implementation so really just need a special case function for ordered lists. I would like to learn more about AVL trees though.
18:30:24 <jberryman> Saizan_: can you tell me why you don't think the strict foldl' is a good pick?
18:31:10 <wli> jberryman: I've specifically seen/heard of AVL trees having an algorithm for doing so. I suspect other tree structures may have similar linear-time algorithms for tree construction from sorted lists.
18:31:42 <ImInYourMonad> jberryman: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2525#a2525 what you want?
18:31:58 <Saizan_> well, first of all you're always using a constructor on the RHS, so the ' actually does nothing
18:33:21 <Saizan_> then there's the problem that foldl won't give a result until all the list is consumed, which i'm not sure is necessary, but maybe it is?
18:34:24 <ImInYourMonad> jberryman: btw i made a red black treee in haskell, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2527#a2527, and a BST: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2528#a2528
18:36:23 <Saizan_> > unfoldr (\(n,xs) -> guard (not . null $ xs) >> (Just . fmap ((,) (n+1)) . splitAt (2^n) $ xs)) (0,[1..10])
18:36:25 <lambdabot>   [[1],[2,3],[4,5,6,7],[8,9,10]]
18:36:32 <Saizan_> > unfoldr (\(n,xs) -> guard (not . null $ xs) >> (Just . fmap ((,) (n+1)) . splitAt (2^n) $ xs)) (0,[1..20])
18:36:33 <lambdabot>   [[1],[2,3],[4,5,6,7],[8,9,10,11,12,13,14,15],[16,17,18,19,20]]
18:36:39 <b\6> is there some trick to tell ghc i don't want to export a newtype constructor? i'm not exporting the constructor but it's telling me 'defined but not used'. seems to differ from if i had used 'data'.
18:36:53 <centrinia> hiding?
18:37:06 <b\6> i thought hiding was for imports.
18:37:16 <Saizan_> yes, hiding is for imports
18:37:39 <wli> Don't count, multiply by 2 every iteration.
18:38:21 <Saizan_> > unfoldr (\(n,xs) -> guard (not . null $ xs) >> (Just . fmap ((,) (n*2)) . splitAt n $ xs)) (1,[1..20])
18:38:22 <lambdabot>   [[1],[2,3],[4,5,6,7],[8,9,10,11,12,13,14,15],[16,17,18,19,20]]
18:38:34 <wli> yeah
18:39:19 <Saizan_> b\6: if you're not exporting a constructor and never using it inside the module there's something strange
18:40:13 <b\6> Saizan_: i do use it. like newtype Blah a = B {...}. it's complaining about B being defined but not used. i export Blah.
18:41:40 <Saizan_> so you're not supposed to build values of type Blah?
18:42:51 <b\6> Saizan_: well, not with the constructor. i export a smart constructor.
18:43:15 <b\6> maybe the smart constructor has to use B.
18:43:31 <Saizan_> yeah
18:44:27 <jberryman> Saizan_: thanks. foldl' processes the list as it consumes it more or less, correct? so it doesn't build up a bunch of thunks?
18:45:55 <Saizan_> ?src foldl'
18:45:55 <lambdabot> foldl' f a []     = a
18:45:55 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
18:46:15 <FunctionalPath> How do I write a Functor instance for (-> e) ?
18:46:19 <dolio> Build tree shape of size n (probably O(log n)?) then traverse the shape filling in the values in order.
18:46:42 <Saizan_> seq there forces a' to be reduced to its outermost constructor only
18:46:48 <Saizan_> FunctionalPath: with a newtype
18:46:52 <lowmagnet> Whoo finished chapter 7!
18:48:02 <jberryman> dolio: interesting, thanks
18:52:15 <jfredett> Hiya, I've got a doosy of a bug, inconsistent .hi files, info @ http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2530#a2530 -- any help is greatly appreciated.
18:52:47 <mun> is ghumake supposed to be a valid command?
18:53:55 <b\6> mun: heh? maybe you want gnu make.
18:54:43 <ddarius> jfredett: Delete all the intermediate files and rebuild.
18:55:05 <jfredett> cabal clean doesn't do that?
18:55:18 <jfredett> i'll give it a shot in any case.
18:55:37 <ddarius> jfredett: Are you using mutually recursive modules in your project?
18:55:50 <jfredett> nope, gone to great lengths to avoid it.
18:55:59 <ddarius> Then you don't have any hs-boot files.
18:56:25 <ddarius> (And presumably no hi-boot files then.)
18:56:42 <jfredett> okay. I've completely cleaned the dist directory, nuked it w/ rm -rf, rebuilding...
18:56:56 <jfredett> same problem.
18:57:18 <jfredett> it happens when I run from the command line, or when I try to :browse from ghci
18:58:09 <jfredett> I'm a little worried it's because I'm using Hint, and doing it inappropriately. but this code doesn't even touch hint...
19:03:32 <ddarius> Is Hint trying to load the module or are you just compiling?  Also, make sure there aren't any odd .hi or .o files floating around.  Other than that you can try looking at the intermediate files that are produced to see if anything weird is in them.
19:04:36 <jfredett> Hint doesn't touch the module when I do a :browse (I think), though -- does ghci work the same way hint does?
19:04:50 <mun> is ghc-prim supposed to be on hackage?
19:04:51 <jfredett> it must be that a weird .hi floating around... time to go ahunting.
19:05:02 <ddarius> I believe Hint eventually just uses the GHC API which is what GHCi uses.
19:05:40 <jfredett> right, so that must be where the issue is, all the hint code I have does is set the module, and return a couple functions.
19:05:41 <ddarius> mun: I doubt it.
19:06:11 <mun> ddarius, do you know where i can find it?
19:06:38 <ddarius> mun: It sounds like a package that is distributed with GHC, likely essentially a part of GHC.
19:07:03 <FunctionalPath> @msg lambdabot @src Control.Monad.Reader
19:07:04 <lambdabot> Not enough privileges
19:07:10 <mun> ddarius, that's what i thought. i'm just trying to upgrade to base-4, but it says it requires ghc-prim and integer.
19:07:18 <mun> so it seems like they aren't already installed.
19:09:01 <ddarius> Um, it's probably looking for different versions.  I'm pretty sure you can't use base-4 with an old version of GHC if that's what you are trying to do.
19:09:54 <mun> ddarius, mine's 6.8.2. do i need at least 6.10?
19:10:59 <blackh1> mun: Yes, you do.
19:11:26 <jfredett> interesting... it only fails with the email type... maybe I can just move some stuff around...
19:11:50 <mun> ok thanks
19:21:19 <plesn> int-e: thanks, btw do you know how to convert those Data.ByteString.Lex.Double to usual Float ?
19:23:37 <gwern> @remember MiguelMitrofanov The first glimpse of this [logo] vote scared me so much that I've closed the page, stopped the browser, and shut my computer down.
19:23:37 <lambdabot> I will never forget.
19:23:56 <ddarius> Such sweet lies, lambdabot.
19:24:18 <Eridius> where is the page that lists the logos?
19:24:19 <gwern> @flush
19:25:02 <gwern> on the internets
19:25:06 <gwern> @quote scar
19:25:06 <lambdabot> monochrom says: data DesCarte = forall a. Think a => Exist a
19:25:23 <idnar> gwern: I thought that line was awesome
19:25:48 <gwern> @quote scare
19:25:48 <lambdabot> glguy says: map became not overloaded in the great polymorphic scare of haskell 98
19:25:53 <int-e> plesn: use realToFrac
19:26:01 <gwern> @quote sc
19:26:01 <lambdabot> JonathanShapiro says: Later we would come to feel that monads do not scale to large programs well.
19:26:30 <gwern> @quote s
19:26:31 <lambdabot> joelr says: Fundeps, existential types, & HList take a while to grasp
19:26:52 <gwern> @quote
19:26:52 <lambdabot> lambdabot says: * lambdabot secretly deletes lunabot's source code
19:27:11 <idnar> uh, what's up with that "monads do not scale" quote?
19:27:13 <dejones> Can someone give me a pointer to "lift" for monads in the Haskell GHC libs docs?  I can't seem to find it.
19:27:23 <dejones> or maybe explain "lift" ?
19:27:39 <gwern> @hoogle lift
19:27:39 <lambdabot> Control.Monad.Trans lift :: (MonadTrans t, Monad m) => m a -> t m a
19:27:39 <lambdabot> Text.ParserCombinators.ReadPrec lift :: ReadP a -> ReadPrec a
19:27:39 <lambdabot> Language.Haskell.TH.Syntax lift :: Lift t => t -> Q Exp
19:27:55 <dejones> gwern: ah yes, hoogle, forgot about that, thanks!
19:27:59 <gwern> idnar: what do you mean?
19:28:24 <mun> i'm trying to compile a program, but i keep getting the error "Could not find module `Text.XML.Light'" does anyone know how to fix it?
19:28:46 <idnar> gwern: it seems like a bit of a bizarre statement
19:28:57 <gwern> mun: add --make?
19:29:23 <mun> gwern, i'm compiling using a Makefile at the moment
19:29:31 <idnar> ah, I think I found the original source now
19:30:43 <idnar> seems like the context is "monad composition is hard"
19:31:02 <b\6> mun: think you need to cabal install xml.
19:31:29 <mun> b\6, i think i know where the problem is -- i just need to properly install hxt-filter.
19:31:43 <mun> but somehow it fails to install because i tcan't find the module 'System.PipeOpen'
19:32:06 <gwern> are yoj on windows?
19:32:25 <idnar> I need to take a proper look at BitC sometime
19:32:42 <ozy`> I wish they'd hurry up and redo the syntax like they say they will
19:33:01 <ozy`> then people can gnash their teeth and stuff
19:33:06 <idnar> heh
19:33:36 <ozy`> speaking of weeping and gnashing of teeth
19:34:26 <ozy`> the Adamo looks like it's shaping up to be Dell's response to Vista, rather than the Macbook Air
19:35:00 <plesn> int-e: thanks a lot! Even though I'm dissatisfied i'm still slower reading those floats than in the original python script...
19:35:41 <mreh> :t abs
19:35:42 <lambdabot> forall a. (Num a) => a -> a
19:36:52 <erikc> the adamo price point is bizarre
19:38:28 <FunctionalPath> /msg Saizan_ instance Functor ((->) e) where
19:38:28 <FunctionalPath> 			fmap g h x = g (h x)
19:40:36 <mun> is System.PipeOpen a valid module?
19:41:56 <jberryman> if I am profiling a binary search tree library, does it make sense to include a big list of test data in the test program to be profiled, to avoid IO?
19:45:12 <ddarius> jberryman: No, that doesn't make sense.
19:55:09 <jberryman> ddarius: crap, okay.
20:01:00 <jberryman> ddarius: how would you go about profiling a binary tree library?
20:01:18 <ddarius> You just profile it.  Why would binary trees be hard to profile?
20:03:50 <b\6> ddarius: maybe because you profile your laptop's crummy hard drive instead of your code.
20:04:05 <ddarius> b\6: Profiling isn't benchmarking.
20:05:18 <ddarius> Anyway, you profile the code you have, not some made up code (admittedly for a library you need to make some kind of "application" program)
20:06:57 <jberryman> ddarius: that makes sense. thanks
20:08:36 <wli> Benchmarking packages might help a bit.
20:09:16 <wli> maybench and benchpress, hmm.
20:09:34 <wli> I've already seen that microbench is not all that great.
20:11:21 <jberryman> wli: used microbench a bit, will check out those two others. thanks
20:13:54 <Gracenotes> does Parsec's 'try' make sense in the context of an applicative functor parser
20:14:11 <ddarius> Gracenotes: Why wouldn't it?
20:14:12 <Gracenotes> :?
20:14:53 <Gracenotes> not sure. It just seems contrary to the whole sequential-parsing thing, but I suppose that's true in monadic usage as well
20:28:28 <wli> I think I may have messed up using the expressions that cause the definition of a var vs. what they're defined as, but OTOH in case statements there isn't a very good candidate to use for the latter anyway.
20:36:47 <b\6> better way to express?  work c = readChan c >>= maybe (return ()) (\v -> f v >> work c)
20:41:53 <monochrom> Godawful, CPS at the typeclass level?!!  (Oleg's message on haskell mailing like (not -cafe))
20:43:23 <monochrom> What's going to be next? "We show that we can do mutable variables and I/O in types, already in Haskell98, no unsafe extensions"?
20:44:41 <monochrom> (Sounds like a fun April Fool event.)
21:10:28 <idnar> monochrom: let's rewrite ghc as a Haskell type-level program!
21:11:01 <idnar> you know, this reminds me a lot of my C++ days (C++ template hackery, specifically)
21:11:03 <ddarius> You could reasonably get the core of GHC that way.
21:11:15 <ddarius> idnar: That's because it's pretty much the same thing.
21:11:25 <idnar> yeah... I'm just not sure if it's better or worse
21:11:57 <idnar> I suppose < the syntax < is a bit more < legible > > > > > > > > > > > > > >
21:12:19 <ddarius> It's pretty much the same.  C++ has a little lazy functional programming language in the type system.  Haskell has a little non-backtracking functional/logic language in the type system.
21:16:01 <travisbrady> anyone know of a function to take a list of pairs like [(1, 1), (2, 2), (3, 3)] and yield [1,1,2,2,3,3]?
21:16:28 <wli> concatMap (\(x, y) -> [x, y])
21:16:33 <idnar> > concatMap (liftM (:) fst snd) [(1, 1), (2, 2), (3, 3)]
21:16:34 <lambdabot>   Couldn't match expected type `(a, b)'
21:16:42 <idnar> oh, doh
21:16:51 <idnar> nevermind me
21:16:54 <Gracenotes> @type (:[] ). (:)
21:16:55 <lambdabot> forall a. a -> [[a] -> [a]]
21:16:58 <Gracenotes> :x
21:17:10 <Gracenotes> @type ((:[]) .). (:)
21:17:11 <lambdabot> forall a. a -> [a] -> [[a]]
21:17:12 <travisbrady> wli, idnar: thank you
21:17:23 <Gracenotes> @type ((:) .). (:[])
21:17:24 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `[a1]'
21:17:24 <lambdabot>     In the second argument of `(.)', namely `(: [])'
21:17:24 <dolio> > uncurry interleave . unzip $ [(1,1), (2,2), (3,3)]
21:17:26 <lambdabot>   [1,1,2,2,3,3]
21:17:37 <idnar> @type unzip
21:17:38 <lambdabot> forall a b. [(a, b)] -> ([a], [b])
21:17:47 <idnar> cute
21:17:52 <Gracenotes> hm, I give up...
21:17:54 <Gracenotes> @pl \a b -> a:b:[]
21:17:54 <lambdabot> (. return) . (:)
21:19:06 <Gracenotes> and also, that would be liftM, up there
21:19:11 <Gracenotes> *liftM2
21:20:02 <idnar> @type (. (:[])) . (:)
21:20:03 <lambdabot> forall a. a -> a -> [a]
21:20:15 <idnar> yeah, I meant liftM2
21:21:00 <idnar> is (:) a Venus fly-trap?
21:21:49 <Gracenotes> ()
21:24:15 <Gracenotes> > let () a b = [a, b] in [(1,1), (2,2), (3,3)] >>= (()<$>fst<*>snd)
21:24:15 <lambdabot>   <no location info>: lexical error at character '\8285'
21:56:13 <dons> "The Int argument specifies the CPU number"
21:56:25 <dons> someone at GHC rts wasn't think of the manycore future ;)
21:57:01 <dolio> We'll just have to hope that we move to 128-bit processors before that becomes a problem.
21:58:09 <dons> fingers crossed
21:59:48 <Mr_Giraffe> @src sum
21:59:48 <lambdabot> sum = foldl (+) 0
22:00:00 <Mr_Giraffe> foldl?
22:00:29 <dolio> > logBase 10 (2^64)
22:00:30 <lambdabot>   19.265919722494793
22:02:08 <dolio> Evidently I picked a bad day to rebuild Agda.
22:03:20 <BMeph> dons: I accidentally the whole Connection Machine. Is that dangerous? ;p
22:06:32 <paulchiusano> hello
22:09:05 <jmcarthur> man, i think this (compiling agda) is the warmest this laptop has ever gotten so far...
22:09:27 <dolio> Just wait until you start running agda.
22:10:08 <paulchiusano> does anyone know of an alternative formulation of monads, using unit, map, zip :: m a -> m b -> m (a b), and unknown :: ???
22:10:18 <jmcarthur> dolio: been there done that ;)
22:10:28 <paulchiusano> or does one even exist
22:10:36 <jmcarthur> made my old powerbook go :'(
22:10:37 <dolio> zip?
22:10:53 <leimy_> > take 50 $ (flip id 100) <$> (+) <$> [1..]
22:10:54 <lambdabot>   [101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,11...
22:11:00 <paulchiusano> i just called it that, but look at the type signature
22:11:12 <dolio> Is that supposed to be an (a,b)?
22:11:14 <paulchiusano> m a -> m b -> m (a, b)
22:11:18 <dolio> Okay.
22:11:18 <paulchiusano> yes
22:11:24 <ddarius> How many more iterations of Moore's Law do we have before physical limitations set in?
22:11:29 <dolio> join :: m (m a) -> m a is what you need to add.
22:11:53 <leimy_> ddarius: didn't we hit that long ago, and have been lying to ourselves by adding caches? :-)
22:11:54 <paulchiusano> dolio: no, because join implies zip
22:11:59 <dolio> Although that makes zip redundant.
22:12:00 <wli> I think we're largely already done.
22:12:09 <diracdelta> > 1+1
22:12:10 <lambdabot>   2
22:12:13 <diracdelta> sorry
22:12:19 <jmcarthur> ddarius: we could always just increase size once we hit the physical limitations
22:12:29 <jmcarthur> ddarius: to an extent, anyway
22:12:34 <paulchiusano> dolio: I want something in which all the functions are needed, and 3 of the functions are unit, map, and zip
22:12:44 <ddarius> leimy: No.
22:12:50 <jmcarthur> i guess that would lead to major problems when taken to logical conclusions
22:12:58 <leimy_> ddarius: good answer.
22:13:08 <paulchiusano> dolio: i don't even know if such a formulation exists
22:13:18 <jmcarthur> obviously bulk, but also things like latency and such
22:13:18 <dolio> I haven't heard of one.
22:13:37 <paulchiusano> hmm
22:13:53 <ddarius> leimy: Moore's Law is just the number of transistors we can fit in a given area cheaply doubles every 18-24 months.  Not anything about processor speeds.
22:14:28 <leimy_> right
22:14:31 <ddarius> leimy: What's happened is that processor designers have reached a point where they have more transistors than they know what to do with.
22:14:36 <leimy_> and processor speeds have nothing to do with bus speeds :-)
22:14:47 <ddarius> Busses aren't transistors.
22:14:48 <leimy_> or whether said system is worth anything with a fast CPU :-)
22:15:33 <dolio> edwardk was pointing out the other day that unit :: f () and pair :: (f a, f b) -> f (a,b) isn't necessarily equivalent to the applicative formalism in all categories.
22:15:39 <wli> They can just miniaturize and reduce power.
22:15:41 <dolio> At least, I think that's what he was pointing out.
22:15:51 <dolio> Because not all categories have exponential objects.
22:16:32 <leimy_> ddarius: yeah I know... it's just people think moore's law is about performance.
22:16:42 <paulchiusano> dolio: what does the statement "not all categories have exponential objects" mean
22:16:43 <dolio> (Which in turn means that monads are not applicative in certain categories.)
22:16:51 <paulchiusano> what is an exponential object
22:17:03 <leimy_> and caches are our way of making memory appear closer to the CPU, (timewise) because bus speeds are so much slower than the CPU's.
22:17:29 <centrinia> paulchiusano, Implement a left fold with only the unit (or idenity?), map, and zip. :)
22:17:33 <dolio> It's an object in the category that represents a space of arrows.
22:17:36 <leimy_> There's a few people I typically hold in high regard who consider caches a hack :-)
22:17:46 <ddarius> leimy: Having bigger caches only helps so much.
22:18:04 <ddarius> leimy: They want the busses to somehow magically be faster instead?
22:18:11 <wli> "Memory is like an orgasm. It's better when you don't have to fake it." -- Seymour Cray
22:18:22 <dons> seymour cray said that?
22:18:49 <centrinia> Can we consider every storage device to be a cache?
22:19:19 <dons> dolio: cabal install agda seems to be working
22:19:31 <dons> centrinia: in what sense a cache?
22:19:41 <leimy_> ddarius: no, you just open up new cans of worms with caches you didn't have to worry about without them.  They're not really a solution but a workaround with their own problems.
22:19:42 <dolio> So, ap :: f (a -> b) -> f a -> f b is like an arrow f (b^a) ~> (f b)^(f a) in some category.
22:20:15 <centrinia> dons, In the sense that they are a part of a cache hierarchy.
22:20:27 <dolio> dons: I just rebuilt it yesterday, before they pushed all the changes to coinduction and tagged a release. :)
22:20:28 <leimy_> dons: I don't think it was seymour cray.
22:20:31 <centrinia> Register files are caches too. :)
22:20:40 <leimy_> I work with people who worked at Cray :-)
22:21:04 <leimy_> I can tell you that Cray people understand the value of locality :-)
22:21:05 <ddarius> leimy: The only (reasonable) problems I can think of off-hand have to do with having caching be implicit.  Not the concept of caching or having caches itself.
22:21:24 <leimy_> Well cache misses for instance can really screw up your plans :-)
22:21:31 <ddarius> centrinia: Register files are caches.
22:21:44 <leimy_> and make it hard to reason about certain performance situations.
22:21:49 <centrinia> Tape backups are also caches. :)
22:22:15 <leimy_> Anything that's a copy of the authoritative version of something is basically a cache :-)
22:23:09 <leimy_> Why not have CPUs communicate via message passing (hypertransport?  Nehalem stuff?) and put a buttload of memory on the CPU, instead of just the controller?
22:23:29 <leimy_> Throw out the cache, admit that a computer is really a distribtued system, and move on with life?
22:23:45 <ddarius> leimy: One word: legacy
22:23:48 <leimy_> I know :-)
22:24:24 <ddarius> But yes, basically the problems with (implicit) caching is the shared memory abstraction leaking.
22:24:45 <leimy_> that's a really big issue, as we get more and more cores, it's going to get worse
22:25:05 <leimy_> I think we're going to end up in NUMAland one way or the other :-)
22:25:36 <paulchiusano> dolio: what about unit, map, pair, and choice :: m (a, b) -> m (Either a b)
22:25:59 <wli> leimy: Suppose one's dealing with a vastly simpler CPU core than x86, like a real RISC core... and guess how many you can cram onto a die at 22nm...
22:26:28 <centrinia> BrainFuck core. :)
22:27:26 <rovar> can someone tell me if there is a more optimal way, or simpler way to do this? I'm attempting to Get a null terminated string and construct a bytestring out of it.
22:27:34 <paulchiusano> no, nm
22:27:35 <rovar> getCString :: Get ByteString
22:27:36 <rovar> getCString = build empty
22:27:38 <leimy_> wli: is there a real RISC core anymore?  Even the PPC G5 stuff ends up microcoded :-)
22:27:38 <rovar>              where build s = (getWord8 >>= \c -> if c == 0 then return s else build (snoc s c))
22:27:49 <leimy_> I suppose ARM :-)
22:28:18 <wli> leimy: Not in mass production. Even ARM is bloated crap anymore.
22:28:34 <wli> leimy: Witness Jazelle.
22:29:14 <centrinia> AVR?
22:29:18 <wli> I think that crushes the notion of ARM as the unbloated architecture for all time.
22:29:30 <wli> I'm less familiar with AVR. Hang on.
22:29:31 <ddarius> One of the benefits of stack machines (in their day) was that they tended to use significantly less transistors than register-based machines.
22:29:34 <dolio> paulchiusano: You need something that's going to flatten out multiple ms for you in some way.
22:30:14 <paulchiusano> dolio: but in a way that doesn't make pair redundant...
22:30:20 <dons> it's really cool that agda is cabalized now
22:31:00 <dolio> I was thinking m (m ()) -> m (), but I think you'll end up duplicating side effects with that.
22:31:06 <wli> leimy: Heh, wikipedia's AVR32 page lists Java hardware acceleration right there.
22:31:35 <dons> agda's pretty big too, 20k loc?
22:32:10 <paulchiusano> hmm
22:36:34 <dons> so now ... why can't we cabal install epigram ?
22:36:47 <dons> agda's going to win, isn't it?
22:37:05 <dolio> Because epigram isn't in a usable state yet.
22:37:25 <dolio> Unless you're talking about the old epigram 1.
22:38:24 <dons> well, epig2. release before the funding ran out
22:40:01 <dons> yay, debian-haskell seems active!
22:42:31 <bos> so
22:42:35 <bos> so is #fedora-haskell.
22:42:55 <dons> mmm. we need a distro meta site
22:43:23 <wli> I've never really understood the strategy of cabal vs. distro package management.
22:43:24 <jekor> Is there something more idiomatic than: liftM __ <$> __ (lifting a function into 2 monads)?
22:43:41 <wli> liftM2 ?
22:43:52 <wli> (Not sure what you're after.)
22:44:00 <jekor> I thought that was for 2 arguments.
22:44:04 <dons> i'm surprised -- repeatedly -- that people don't understand the difference :)
22:44:12 <jekor> Say I'm doing something in the IO monad and also want to handle Maybe.
22:44:43 <jekor> liftM (/= []) <$> __ where __ :: IO (Maybe [])
22:44:46 <bos> jekor: <*>
22:45:01 <bos> oh, you want two different monads?
22:45:15 <jekor> Right. It comes up a lot for me because I use the Maybe monad a lot.
22:45:47 <wli> MaybeT IO?
22:45:50 <jekor> Er, that should have been IO (Maybe [a]). But you get the point.
22:46:59 <jekor> Hmm...I'm already using one monad that's a combination of IO and CGI. I think it would get tricky with another transformer. I also only do this somewhat rarely. It's working with using liftM twice. Just seemed like it would be common enough to have some simpler form.
22:47:24 <Gracenotes> @type (liftM . liftM)
22:47:25 <lambdabot> forall (m :: * -> *) a1 r (m1 :: * -> *). (Monad m1, Monad m) => (a1 -> r) -> m (m1 a1) -> m (m1 r)
22:48:12 <wli> MaybeT IO [t] perhaps?
22:48:14 <jekor> Thanks. I guess I could define an alias for that.
22:48:14 <Gracenotes> @type join (.) (<$>)
22:48:16 <lambdabot>     Occurs check: cannot construct the infinite type: a = f a
22:48:16 <lambdabot>     Probable cause: `join' is applied to too few arguments
22:49:45 <jekor> Too bad parsec already grabbed <$$>.
22:50:53 <wli> @type runMaybeT . runListT $ liftM (not . List.null) <$> (undefined  :: ListT (MaybeT IO) t)
22:50:54 <lambdabot> Not in scope: `runMaybeT'
22:50:54 <lambdabot> Not in scope: `runListT'
22:50:54 <lambdabot> Not in scope: type constructor or class `ListT'
22:52:21 <Gracenotes> @. type run text $ intercalate "." (replicate 7 "(<$>)")
22:52:23 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *) (f3 :: * -> *) (f4 :: * -> *) (f5 :: * -> *) a b (f6 :: * -> *). (Functor f6, Functor f5, Functor f4, Functor f3, Functor f2, Functor f1, Functor f)
22:52:23 <lambdabot>  => (a -> b) -> f (f1 (f2 (f3 (f4 (f5 (f6 a)))))) -> f (f1 (f2 (f3 (f4 (f5 (f6 b))))))
22:52:40 <wli> What are the criteria for let-bound variables escaping?
22:56:55 <dons> bos, wann update the state of fedora?
22:56:56 <dons> http://haskell.org/haskellwiki/GNU/Linux
22:57:38 * bos tries to remember his wiki username
23:08:31 * Axman6 didn't get a logo invitation :(
23:12:10 <wli> This stuff is hard to read.
23:12:37 * ibid got two
23:43:12 <Gracenotes> it should be easy to translate from Gofer to GHC-Haskell, right? apparently the former follows the 98 report
23:44:06 <quicksilver> I thought gofer predated the h98 report
23:44:13 <Gracenotes> hm.
23:44:16 <quicksilver> but, yes, the differences are mostly small.
23:47:53 <dons> Gracenotes: you can get the gofer prelude from hackage
23:48:32 <Gracenotes> @go gofer prelude
23:48:33 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/gofer-prelude
23:48:33 <lambdabot> Title: HackageDB: gofer-prelude-2.30.2
23:48:57 <Gracenotes> *reads available functions*
23:49:33 <Gracenotes> it seems Gofer had more latitude in where one could put typeclasses
23:49:34 <dolio> It's probably better than the H98 prelude.
23:50:17 <Gracenotes> it does have more functionality, but said functionality is mostly in other modules, it seems :)
23:50:37 * quicksilver wishes people took a bit more effort in naming mailing list posts.
23:50:43 <Gracenotes> it also has fst3/snd3/thd3
23:51:01 <quicksilver> "Data.Binary" could have been better named "Data.Binary can't be found in ghci, what am I doing wrong?"
23:58:01 <FunctorSalad> quicksilver: I read your last msg before reading the one before.... confusing :)
