00:00:41 <quicksilver> what conclusion do you come to if a program is spending 50% GC times?
00:00:41 <opqdonut> @type fmap fmap (fmap fmap [fmap])
00:00:43 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f2, Functor f1, Functor f) => [f (f1 (a -> b)) -> f (f1 (f2 a -> f2 b))]
00:01:40 <NameAlreadyInUse> you can keep prefixing it with "fmap fmap $"
00:02:03 <Gracenotes> @type fmap . fmap . fmap . fmap . fmap . fmap . fmap . fmap
00:02:04 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *) (f3 :: * -> *) (f4 :: * -> *) (f5 :: * -> *) (f6 :: * -> *) a b (f7 :: * -> *). (Functor f7, Functor f6, Functor f5, Functor f4, Functor f3,
00:02:04 <lambdabot> Functor f2, Functor f1, Functor f) => (a -> b) -> f (f1 (f2 (f3 (f4 (f5 (f6 (f7 a))))))) -> f (f1 (f2 (f3 (f4 (f5 (f6 (f7 b)))))))
00:02:16 <blackh> quicksilver: Try -H. This makes a big difference on ghc 6.10.1
00:02:34 <dons> quicksilver: it might be doing   the right  thing, but give it more heap
00:05:23 <quicksilver> blackh, dons : hmmm, yes, that helps
00:05:37 <quicksilver> dons: I thought -H was only an 'initial hint'; how come it affects the long term behaviour of a program?
00:06:18 <Adamant> what's a good paper to get started with dependent typing?
00:06:29 <quicksilver> Adamant: I like conor's papers.
00:07:03 <Gracenotes> > let m = map (+1) (0:m) in m
00:07:04 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
00:07:29 <quicksilver> Adamant: http://www.cs.nott.ac.uk/~ctm/publications.html
00:07:35 <quicksilver> Adamant: perhaps "Why Dependent Types Matter"
00:07:50 <quicksilver> hopefully that references other interesting paper.s
00:08:19 <NameAlreadyInUse> what is dependent typing?
00:08:32 <dons> quicksilver: it really helps the parallel garbage collector
00:08:59 <quicksilver> dons: however, I'm in 6.8 and I'm only using one core.
00:09:03 <NameAlreadyInUse> i've looked at some of the papers but they are a little over my head
00:09:20 <Adamant> quicksilver: thanks!
00:09:25 <quicksilver> dons: this is a long running opengl app and it gets 80fps with default settings and 115 fps with -H100m
00:09:31 <ski> NameAlreadyInUse : things like `vector_append :: forall a. (m :: Natural) -> (n :: Natural) -> Vector a m -> Vector a n -> Vector a (m + n)'
00:09:37 <quicksilver> dons: that's a pretty big difference! (and long-term consistent)
00:09:58 <dons> work out what is allocating so much, i think, would be the nex step
00:10:02 <ski> NameAlreadyInUse : the type of the rest of the arguments and the result in the function can depend on the *value* passed as earlier arguments
00:10:15 <quicksilver> dons: I kind of know that.
00:10:21 <dons> quicksilver: might be worth checking against 6.10.2 as well
00:10:33 <quicksilver> dons: I do a preprocessing pass over a tree-like ADT, it's supposed to be an 'optimisation'
00:10:54 <sjanssen> dons: oh?
00:10:58 <quicksilver> dons: but it ends up trapping a lot more into memory and defeating some static optimisations which can remove some allocation.
00:11:12 <dons> sjanssen: yeah, 6.10.2 seems to be rocking it. lots of good rts tweaks and fixes
00:11:14 <Gracenotes> ski: can't C++ templates do that?
00:11:23 <dons> sjanssen: did you see my post on g.h.u ?
00:11:25 <Gracenotes> albeit hackily?
00:11:29 <quicksilver> dons: if I skip the preprocessing pass then it appears to process the large structure lazily.
00:11:42 <quicksilver> Gracenotes: C++ templates have a special case for int parameters, basically.
00:11:52 <quicksilver> Gracenotes: so, yes, they can do that very easily.
00:11:52 * dons has to get to bed, unfortunately. but whispers "profile" into the wind as he rides off
00:12:04 <Gracenotes> ah. Well, it seems ints is mainly what you'd want :)
00:12:08 <dolio> GHC can do it too.
00:12:47 <NameAlreadyInUse> yes, i have wanted in the past a way to make a type dependant on an int
00:12:49 <Gracenotes> generalizing it to other values is.. interesting
00:13:04 <NameAlreadyInUse> but it can only be done at compile time?
00:13:04 <Gracenotes> from what I've heard!
00:13:37 <Gracenotes> so you'd pass m and n explicit to the function?
00:13:41 <Gracenotes> *explicitly
00:13:45 <Gracenotes> in the above example
00:14:10 <NameAlreadyInUse> i think m and n would be part of the type constructor
00:14:53 <ski> Gracenotes : one can often have `m' and `n' be implicit arguments to `vector_append'
00:14:58 <Gracenotes> I mean in (m :: Natural) -> (n :: Natural) -> Vector a m -> blah, m and n are marked with a :: specifically
00:15:09 <Gracenotes> and explicit as arguments.
00:15:10 <ski> that could look like
00:15:10 <Gracenotes> okay
00:15:26 <ski>  vector_append :: forall a (m :: Natural) (n :: Natural). Vector a m -> Vector a n -> Vector a (m + n)
00:15:40 <Gracenotes> ah. that looks a bit neater, maybe
00:15:45 <quicksilver> NameAlreadyInUse: no, m and n don't have to be known at compile time
00:15:57 <quicksilver> NameAlreadyInUse: but if they're not, you can't prove much about (n+m)
00:16:01 <ski> in this case, one could usually infer `m' and `n' from applications of `vector_append)
00:16:02 <quicksilver> so it may not be all that useful.
00:16:11 <NameAlreadyInUse> like "type Vec4d = Vector Double 4"
00:16:37 <Gracenotes> could you do something like, with m and n Integer, Vector a m -> Vector a n -> Vector a (m `div` (ceil . sqrt . fromIntegral $ n))?
00:16:59 <Gracenotes> or Vector a (let u = u in u)
00:19:04 <ski> you could probably define a function with the same behaviour as `ceil . sqrt . fromIntegral'
00:19:31 <ski> usually (possibly) nonterminating computations like `let u = u in u' is not allowed .. at least not in types
00:19:43 <ski> (type checking would not be decidable)
00:19:56 <ski> so, yes
00:20:02 <Gracenotes> suppose I make a + with bottom in it, though :)
00:20:37 <Gracenotes> sounds very tricky, anyway!
00:21:12 <ski> well, you probably will not get such an `+' past the termination analysis
00:21:54 <Gracenotes> this is a form of the halting problem, isn't it?
00:22:04 <ski> in the general case, yes
00:22:10 <NameAlreadyInUse> ghc has termination analysis?
00:22:26 <ski> so obviously these termination analyses are conservative approximations
00:22:47 <ski> NameAlreadyInUse : we're talking about stuff like Agda(2),Coq,Epigram,..
00:22:57 <NameAlreadyInUse> oh
00:23:07 <NameAlreadyInUse> i have not used any of those
00:23:50 <dolio> GHC has termination analysis for its type system.
00:23:55 <dolio> Unless you turn it off.
00:24:45 <Gracenotes> from whence comes the undecidability if you turn it off (if any)?
00:24:46 <Axman6> hmm, i need a nice small linux distro that i can run in a VM, and hopefully has package management
00:25:06 <dolio> Type classes or type families.
00:25:13 <quicksilver> Gracenotes: from type class recursion.
00:25:24 <quicksilver> hmm, that's an ambiguous phrase.
00:25:35 <quicksilver> type class *instance* recursion, in particular
00:25:46 <Gracenotes> ah.. requiring a GHC extension though, right
00:25:54 <quicksilver> GHC by default has some simplistic restrictions on the form of type instances
00:26:01 <Gracenotes> with the name 'undecidable' in it, as a hint >_>
00:26:05 <quicksilver> which make it obvious that context resolution always terminates.
00:26:23 <quicksilver> if you lift that restriction, you can write some more interesting schemes (which still terminate)
00:26:31 <quicksilver> ...but you can also write the non-terminating ones.
00:26:31 <Lemonator> @src lookup
00:26:31 <lambdabot> lookup _key []          =  Nothing
00:26:31 <lambdabot> lookup  key ((x,y):xys) | key == x  = Just y
00:26:31 <lambdabot>                         | otherwise = lookup key xys
00:28:19 <Gracenotes> mm.
00:29:34 <quicksilver> Gracenotes: FlexibleInstances and FlexibleContexts are harmless and sensible; OverlappingInstances is stupid and completely broken; UndecidableInstances lets you program in the type (class) system, and IncoherentInstances I don't understand :)
00:30:00 <dolio> data Z ; data S n ; class C a where go :: a ; instance C (S n) => C n where go = undefined
00:30:17 <dolio> go :: Z ==> "Context reduction stack overflow; size = 20"
00:30:58 <Gracenotes> quicksilver: so if you had to implement a function that was id for a String and show for any other Showable, how would you sanely do it?
00:31:22 <Gracenotes> presumably with typeclasses... but can one keep it sane? :)
00:31:27 <quicksilver> dolio: is -XTypeFamilies split into terminating and non-terminating fragments?
00:31:37 <quicksilver> dolio: or do you get non-termination by default?
00:31:44 <dolio> It's terminating by default.
00:32:08 <quicksilver> Gracenotes: I wouldn't; that is non-parametric.
00:32:45 <mmorrow> Axman6: DamnSmallLinux?
00:32:49 <Gracenotes> impossible, then? :)
00:32:56 <dolio> The type family version is: type family Bad n :: * ; type instance Bad n = Bad (S n).
00:33:17 <dolio> Which doesn't even get you an overflow after a while, it seems.
00:34:08 <quicksilver> Gracenotes: well, it's not a stupid notion (what you've asked for)
00:34:09 <mmorrow> f !x = f (1+x) -- doesn't end in <<loop>> nor does it eat mem
00:34:17 <mmorrow> iirc
00:34:22 <Lemonator> how do I use implicit parameters?
00:34:25 <quicksilver> Gracenotes: it just doesn't "fit" with what type classes are for.
00:34:38 <quicksilver> Gracenotes: (and I reject the extension to typeclasses which appears to allow it)
00:34:59 <quicksilver> not particularly because this example is obviously broken, but because that extension allows other obviously broken things.
00:35:43 <Gracenotes> I saw something like "deriving instance (Eq  a, Eq  b) => Eq  (a, b)" in GHC source code. What's that?
00:35:55 <Gracenotes> only for tuples?
00:36:14 <quicksilver> Gracenotes: it's the same as "data MyPair a b = MyPair a b deriving (Eq)"
00:36:20 <quicksilver> the default deriving mechanism
00:36:30 <quicksilver> it's just been separated from the actual definition of the type.
00:36:43 <quicksilver> (because you can't define the tuple type in haskell syntax, it's built in)
00:36:55 <mmorrow> "standalone deriving"
00:37:01 <trofi^w> @src (,)
00:37:01 <lambdabot> Source not found. I feel much better now.
00:37:14 <mmorrow> it's super handy when people "forget" to define Show for their type in a package
00:37:21 <Gracenotes> hm. I suppose trying to do both String/other Show for that would yield the same problem
00:37:25 <mmorrow> you can just standalone derive
00:37:26 <Gracenotes> obviously ;x;
00:39:48 <quicksilver> mmorrow: but that fails for abstract or partly abstract types, I think.
00:42:56 <Axman6> mmorrow: that doesn't come with GCC though does it? need something quite functional, but preferably not to disk hungry
00:43:26 <p_l> Axman6: you can build T2 on host
00:43:37 <Axman6> T2?
00:43:44 <p_l> it's a distro building kit :)
00:43:53 <Axman6> ah
00:43:58 <p_l> you can also try adding GCC to OpenWRT
00:44:00 <Axman6> i want something easy too :P
00:44:12 <Axman6> might just go with trusty old Arch
00:44:14 <p_l> OpenWRT shouldn't be hard, except for that fscking libtool
00:44:27 <p_l> though that libtool issue might be MIPSel only
00:44:48 <Axman6> p_l: that's a router OS though no?
00:45:21 <Gracenotes> ugh, I haven't written a single essay this semester. I feel so lazy.
00:45:36 <p_l> Axman6: It had grown out of WRT distro, but you can customize it. Download the buildroot environment, start "make menuconfig", set arch to x86 :P
00:46:00 <Axman6> far too much work for what i need :\
00:46:12 <p_l> ...
00:46:45 <p_l> Gentoo? :P
00:47:10 <Axman6> i think you're missing the point of what i'm after :\
00:47:28 <p_l> or just use Arch/Debian, but don't cry when some misplaced package manages to pull in several database servers, half of Gnome and half of KDE, all in gloriously twisted deps
00:48:06 <p_l> Axman6: Gentoo is quite good for making a small distro for work inside VM
00:48:13 <p_l> just compile the stuff on another machine :)
00:52:38 <jberryman> @src splitAt
00:52:38 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
00:52:53 <jberryman> does that end up being more efficient than it looks?
00:55:37 <glguy> that's probably just a pedagogic definition
00:56:25 <Gracenotes> I think the actual splitAt uses a recursion helper function or two
00:59:27 <Gracenotes> jberryman: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2597#a2597
00:59:36 <Gracenotes> the first part is the 'official' definition
00:59:57 <Gracenotes> the second part is what you're probably actually using in GHC
01:01:11 <Gracenotes> (report prelude is the suggested prelude from the Haskell 98 report, iirc)
01:02:04 <jberryman> Gracenotes:  thanks.
01:04:41 <jberryman> does the simple definition benefit from laziness or sharing or anything like that?
01:14:50 <ski> It was morning.
01:17:24 <mmorrow> quicksilver: yeah, it refuses if any of the constructors are hidden
01:17:48 <mmorrow> Axman6: i'm not really sure what it comes with, i've messed with it maybe once for about 10 minutes
01:18:25 <mmorrow> Axman6: have you ever used Slackware?
01:18:53 <Axman6> i think i have. might look at it again if i can't get this working in OS X
01:18:56 <Axman6> frigging TCL
01:20:08 <mmorrow> slackware is great
01:20:24 <mmorrow> i haven't used it for a long time though..
01:21:05 <mmorrow> but it's probably changed little since then..
01:22:48 <mmorrow> yuk, looks like slackware has kde by as default :/
01:23:57 <ether10101> does anyone here have the book "The Craft of Functional Programming Second Edotion" by Simon Thompson
01:24:37 <ski> yes, someone here does
01:24:52 <Axman6> ether10101: yep
01:25:50 <ether10101> Axman6: I'm going through a list of exercises for a class, and I'm stumped by one.  It's just that I'm not sure what it's asking.  The exercise in question is 17.8.  Have any suggestions?
01:28:02 <Axman6> seems fairly clear to me, what's the problem>?
01:28:32 <Axman6> mmorrow: huh, i thought slackware was small. apparently it's 6CD's
01:29:02 <ether10101> Axman6: I think you only need the first 2 cds for a full install
01:29:16 <p_l> Axman6: 6CD is rather small
01:29:19 <Axman6> still, i need something smaller than that
01:29:34 <p_l> it's when it comes on two dual layer DVDs that you have to worry
01:29:40 <Axman6> i want something that will hopefully install in leas than a gig, and two at most
01:32:27 <ether10101> Axman6: I'm not sure what I'm supposed to be writing.  For example, for the first expression, following the example, would I define a variable as [m*m | m <- [1..10] ]?  Because that would let me do [x | x<- xs]  = xs, with xs being the variable I defined.
01:33:12 <Axman6> seems like you need the second 'rule' for the first bit
01:35:34 <ether10101> You mean [ f x | x <- xs ] = map f xs ?
01:37:45 <Axman6> yeah
01:37:53 <Axman6> map (^2) xs
01:39:45 <ether10101> I guess I'm just confused as to what my teacher could be expecting in my code
01:40:34 <ether10101> --First expression: [m*m | m <- [1..10] ]
01:40:34 <ether10101>  foo1 :: [Int]
01:40:34 <ether10101>  foo1 = map sqr1 [1..10]
01:40:40 <ether10101> that's what I have written?
01:42:24 <Axman6> looks fine to me (as long as you've defined sqr1)
01:43:49 <mmorrow> what do people like more: the destination register on the RIGHT or on the LEFT?
01:44:19 <ski> yes
01:44:52 <ski> i'm not sure if there's really any preference
01:45:17 <Axman6> i think i like it on the right, so i can see where the result ends up more clearly
01:45:19 <mmorrow> it's driving me crazy. i can't decide convention to use for my bytecode.
01:45:38 <mmorrow> i keep switching it and this has to stop. :)
01:45:43 <ski> so use both !?
01:45:49 <mmorrow> !!
01:45:57 <mmorrow> you're nuts!
01:46:05 <ski> (that's probably true, yes)
01:46:08 <mmorrow> heh
01:46:08 <Axman6> i'm going to be using a virtual machine that was written at my uni that's a Von Neumann architecture
01:46:59 <mmorrow> ok. i'm settling on on-the-right gas style.
01:47:06 <Axman6> so... no need to worry about registers for me :(
01:47:20 <mmorrow> Axman6: why?
01:47:48 <Axman6> well, it has no general purpose registers, so you can only really use the accumulator for the ALU
01:47:54 <mmorrow> ah, i see
01:49:25 * ski is loathe to make arbitrary choices
01:49:33 <ski> all or nothing, i say
01:49:36 <ski> death or glory !
01:52:51 <mmorrow> @remember ski death or glory !
01:52:51 <lambdabot> It is stored.
02:01:09 <quicksilver> do I remember some bug where the GHC state hack removes sharing?
02:01:39 <quicksilver> because I seem to have a pure value (though 'let' in an IO context) which is being constantly recomputed.
02:06:03 <quicksilver> yowch. -fno-state-hack makes me go from 90fps to 400fps.
02:08:48 <ether10101> --Second expression: [m*m | m <- [1..10] , m*m<50 ]
02:08:48 <ether10101>  foo2 :: [Int]
02:08:48 <ether10101>  foo2 = [y | y <- filter (<50)(map sqr1 [1..10] ) ]
02:08:56 <ether10101> Axman6: You think that works for the second one?
02:09:53 <Axman6> sure
02:09:59 <ynyr> is research.microsoft.com down for good now?
02:10:07 <ynyr> it hasn't been up for weeks
02:10:35 <yitz> ynyr: i've notice trouble with that site
02:10:47 <ejt> ether10101: [x | x <- xs] === xs
02:10:52 <yitz> ynyr: doesn't make sense that they took it down completely though
02:10:58 <yitz> ynyr: maybe they moved the url
02:11:14 <yitz> hmm... and forgot to redirect?
02:11:56 <Axman6> ejt: exercises from the Thompson book
02:11:57 <glguy> http://research.microsoft.com/en-us/ is still up
02:12:02 <ether10101> ejt: ?
02:12:24 <ejt> ether10101: I'm not sure exactly what the question is, but foo2 can be simplified further
02:13:56 <ether10101> ejt: How would you simplify it more in that case?
02:14:27 <yitz> glguy: no response here
02:14:39 <Axman6> well, filter (<50) . map (^2) $ xs is one way
02:14:40 <yitz> glguy: nor has there been for at least some days
02:15:14 <yitz> glguy: what country are you in?
02:15:47 <johnw> how often are list comprehensions really used, when there is filter and map?
02:15:51 <ynyr> glguy: no response here either
02:15:53 <ynyr> i'm in the uk
02:16:19 <ejt> johnw: it's a matter of taste, personally I try and avoid them
02:16:33 <Axman6> johnw: sometimes they're clearer imo
02:16:55 <yitz> traceroute bounces around the level3.net backbone in the us for a while, then gets stuck
02:17:45 <Axman6> like, i'd rather write [(x,y) | x <- xs, y <- ys] than do { x <- xs; y <- ys; return (x,y)}
02:18:07 <yitz> no reverse dns for the IP of research.microsoft.com
02:19:58 <dalmatian> Good Morning
02:20:15 <mmorrow> quicksilver: whoa. what does -fno-state-hack do?
02:20:27 <ejt> Axman6: (,) <$> xs <*> ys
02:20:28 <mmorrow> slash what is the state hack?
02:20:50 <yitz> use only federal haskell
02:20:55 <Axman6> hmm, i need to learn to use applicative more
02:21:38 <yitz> @type (,) <$> xs <*> ys
02:21:39 <lambdabot> Not in scope: `xs'
02:21:39 <lambdabot> Not in scope: `ys'
02:21:46 <ejt> I like applicative, but I think in that case you're right and the list comprehension is clearest
02:21:51 <yitz> @type \xs ys -> (,) <$> xs <*> ys
02:21:52 <lambdabot> forall a a1 (f :: * -> *). (Applicative f) => f a -> f a1 -> f (a, a1)
02:21:58 <dalmatian> Could you provide me witha a few examples of commercial sites or commercial applications that use Haskell?
02:22:05 <johnw> what about zipWith (,) xs ys
02:22:14 <ski> johnw : `ZipList'
02:22:17 <yitz> @type \xs ys -> (,) <*> xs <$> ys
02:22:18 <lambdabot> forall a a1 (f :: * -> *). (Functor f) => (a -> a1) -> f a -> f (a, a1)
02:22:22 <ejt> johnw: no, we want the cross product
02:22:55 <Axman6> dalmatian: galois is one company. there don't tend to be many commercian applications using haskell, but that's not a bad thing at all (there's quite a few large projects written in it)
02:23:15 <mmorrow> dalmatian: http://haskell.org/haskellwiki/Haskell_in_industry
02:23:17 <yitz> > (,)<$>[1..3]<*>[14..17]
02:23:18 <lambdabot>   [(1,14),(1,15),(1,16),(1,17),(2,14),(2,15),(2,16),(2,17),(3,14),(3,15),(3,1...
02:23:21 <ejt> dalmatian: there's a nice summary document of who's doing what in the haskell world
02:23:32 <Axman6> commercial*
02:24:21 <ejt> dalmatian: http://www.haskell.org/communities/
02:26:27 <ski> @type fmap . graph
02:26:28 <lambdabot> forall (f :: * -> *) a b. (Functor f) => (a -> b) -> f a -> f (a, b)
02:26:56 <yitz> @hoogle graph
02:26:56 <lambdabot> module Data.Graph
02:26:56 <lambdabot> Data.Graph type Graph = Table [Vertex]
02:26:56 <lambdabot> Data.Graph graphFromEdges :: Ord key => [(node, key, [key])] -> (Graph, Vertex -> (node, key, [key]), key -> Maybe Vertex)
02:27:03 <ski>   graph f = id &&& f
02:27:34 <ski>   cograph f = f ||| id
02:27:44 <dalmatian> ejt, Axman6 Interesting
02:28:31 <quicksilver> mmorrow: something badly broken ;)
02:28:38 <quicksilver> mmorrow: although it only hits people occasionally
02:29:05 <quicksilver> http://hackage.haskell.org/trac/ghc/ticket/2756 http://hackage.haskell.org/trac/ghc/ticket/2284 http://hackage.haskell.org/trac/ghc/ticket/1168
02:29:06 <mmorrow> quicksilver: i'll have to look it up
02:29:13 <mmorrow> thx
02:31:37 <RayNbow> > let infixl 1 «, »; («) = flip (<$>); (») = (<*>)   in   [1..3] «(,)» [14..17]
02:31:38 <lambdabot>   [(1,14),(1,15),(1,16),(1,17),(2,14),(2,15),(2,16),(2,17),(3,14),(3,15),(3,1...
02:31:40 <mmorrow> quicksilver: scary
02:32:48 <Axman6> http://industry.haskell.org/partners :\
02:33:14 <quicksilver> mmorrow: Hmm if I've been bitten by #2756, then it's going to be fixed in 6.10.2. If I've been hit by 2284/1168 I'm shit outta luck.
02:33:33 <yitz> > map (((&&&)`on`(!!)) 0 1) $ sequence [[1..3], [14..17]]
02:33:34 <lambdabot>   Couldn't match expected type `Int' against inferred type `[t]'
02:33:36 <quicksilver> mmorrow: my program is actually rather like #2284 - it does an expensive one-time traversal of a data structure before rendering it to screen many times.
02:33:54 <yitz> > map (((&&&)`on`flip (!!)) 0 1) $ sequence [[1..3], [14..17]]
02:33:55 <lambdabot>   [(1,14),(1,15),(1,16),(1,17),(2,14),(2,15),(2,16),(2,17),(3,14),(3,15),(3,1...
02:34:30 <ejt> > liftM2 (,) [1..3] [14..17]
02:34:32 <lambdabot>   [(1,14),(1,15),(1,16),(1,17),(2,14),(2,15),(2,16),(2,17),(3,14),(3,15),(3,1...
02:36:28 <ivanm> going through reddit... is jdh30 == jon harrop?
02:37:50 <dalmatian> ejt: is liftM2 some form of cartesian product?
02:38:22 <ejt> dalmatian: no, it lifts a binary function into a monad
02:38:25 <ski> (ivanm : so they say)
02:38:38 <ejt> dalmatian: in this case the list monad
02:38:49 <ether10101> Axman6: I'm confused about the third one.
02:39:34 <ether10101> Axman6: Any guidance in the right direction?
02:40:08 <Axman6> not really :\ i can't see a nice way of doing it using the rules provided
02:40:40 <ejt> ether10101: what's the question ?
02:40:45 <dalmatian> Not in scope: `liftM2'. What do I need to import?
02:40:51 <RayNbow> @hoogle liftM2
02:40:51 <lambdabot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
02:40:53 <ejt> dalmatian: Control.Monad
02:40:57 <ivanm> ski: so it might not be harrop? :o
02:41:12 <ejt> dalmatian: I find hayoo very useful, have it open in my browser all the time
02:41:45 <ski> (ivanm : i don't frequent reddit often enough to tell ..)
02:41:56 <ivanm> heh
02:41:58 <ether10101> ejt: The problem says:  List comprehensions can be translated into expressions involving map, filter, and concat by the following equations:
02:42:00 <ether10101> then it lists
02:42:07 <dalmatian> guys you are all so useful and friendly. Unlike the lisp folks. What's wrong with you? :)
02:42:15 <dalmatian> > liftM2 (+) [1..3][14..17]
02:42:16 <lambdabot>   [15,16,17,18,16,17,18,19,17,18,19,20]
02:42:25 <ether10101> [ x | x <-xs ] = xs
02:42:28 <yitz> @slap dalmatian
02:42:28 * lambdabot hits dalmatian with a hammer, so they breaks into a thousand pieces
02:42:35 <yitz> dalmatian: is that better?
02:42:38 <ether10101> [f x | x <- xs] = map f xs
02:43:02 <ether10101> [e | x <- xs, p x , ... ] = [e | x <- filter p xs, ...]
02:43:05 <dalmatian> yitz: a bit better yes. Now you also need to ignore a couple of technical questions. :-P
02:43:22 <yitz> dalmatian: sorry we're too compulsive for that
02:43:33 <ether10101> [e | x <- xs , y <- ys, ... ] = concat [  [e | y <- ys, ..] | x <-xs]
02:43:48 <mmorrow> heh, this is a flag for yhc:
02:43:51 <mmorrow> --unifyhack                    Enable nasty type hack needed to make the prelude compile
02:43:57 <ski> ether10101 : i don't see how to eliminate `[ () | True ]' with that ..
02:44:10 <ether10101> ejt: then it says "Translate the expressions" and the one I'm on is "[x+y | x <- [1..4] , y <- [2..4] , x>y]
02:44:28 <dalmatian> @where hayoo
02:44:28 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
02:44:46 <ski> ether10101 : what is your first step ?
02:44:47 <dalmatian> Service Temporarily Unavailable  :(
02:44:50 <ejt> ether10101: start with the concat rule
02:44:57 <dalmatian> hayoo is down
02:44:57 <ether10101> ski: Sorry I'm just relaying a workbook problem
02:45:07 <yitz> mmorrow: let that be a warning who say "oh, what a fun language, think I'll write a quick compiler for it"
02:45:27 <ski> ether10101 : yes, i know .. i was wondering what the first step you try is
02:46:13 <yitz> *for those who say
02:46:25 * ski wonders if "they" refer to "dalmatian and the hammer", collectively
02:47:01 <raji> You are given n 3D empty boxes. you have to pack them such that the total number of boxes are minimum. You can pack box A in box B if A.x < B.x AND A.y < B.y AND A.z < B.z. ? Any  ways for solving this
02:47:31 <bastl> I manually installed HaXml-1.13.5, and 'ghc-pkg list' looks good, but './Setup.lhs build' complains that the package is hidden ?
02:47:34 <ether10101> ski: I was looking at the concat rule, but I just don't really know how to apply it
02:47:38 <jml> raji: I suggest either science or mathematics!
02:47:42 <jml> raji: perhaps both!
02:47:57 <yitz> raji: this is probably a variation on the classic box packing problem, which is known to be very hard (NP complete)
02:48:18 <ether10101> ski: namely getting the x>y in there
02:48:32 <raji> yitz, n <500 , any polynomial time stuff and the widths are less 10^8
02:48:33 <ski> ether10101 : well, you might match, respectively, `e',`x',`xs',`y',`ys',`...' to `x+y',`x',`[1..4]',`y',`[2..4]',`x>y', no ?
02:48:34 <Saizan> bastl: you need to list it in the build-depends field in the .cabal file
02:48:39 <ejt> ether10101: the x>y goes in the ... bit
02:48:44 <bastl> Saizan: oh, thanks
02:50:45 <ether10101> ski, ejt:  ah I see
02:51:00 <ether10101> ski, ejt:  Doesn't really seem simpler than the expression
02:51:05 <yitz> raji: i was often faced with that problem in real life when working as a stocker in a supermarket when i was a kid. it was a hard problem.
02:51:31 <ski> ether10101 : but what is the expression you get, after this rewriting step ?
02:51:48 <yitz> raji: i also worked on box packing as part of a warehouse design app. that was also hard.
02:52:03 <raji> yitz, these are cuboids
02:52:13 <ether10101>  foo3 :: [Int]
02:52:14 <ether10101> foo3 = concat [ [x+y | y <- [2..4], x>y] | x <- [1..4]]
02:52:39 <ski> now, maybe you can apply one of the other rules ?
02:53:35 <ski> (hm .. you might have to do some beta-expansion, somewhere ..)
02:53:55 <yitz> raji: after emptying cuboid-shaped cardboard cases of food products, we then had to fit the empty cases into each other to take up the least space where they were stored afterwards
02:54:09 <yitz> same exact problem i think
02:56:53 <yitz> raji: this is also an obvious variant on the traveling salesman problem - except you are allowed multiple disjoint components to your traversal path
02:57:25 <yitz> raji: and the cost is the sum of the sizes of the components
02:57:34 <yitz> i mean number of components
02:58:16 <raji> cool , but that should be polynomial . Maybe we could do some stuff to LIS (longest increasing sequence)
02:58:21 <yitz> and the graph is not necessarily connected, of course.
03:00:05 <NameAlreadyInUse> @pl \c (Tree x y) -> Tree x (Tree c [] : y)
03:00:05 <lambdabot> (line 1, column 10):
03:00:05 <lambdabot> unexpected "x"
03:00:05 <lambdabot> expecting operator or ")"
03:00:11 <raji> yitz, how do we do it using graph ? maximal matching , any hints
03:00:55 <yitz> raji: i would start by listing all of the maximal paths and sort them by length i think
03:01:10 <NameAlreadyInUse> @pl \c (Tree x y) -> Node x (Node c [] : y)
03:01:10 <lambdabot> (line 1, column 10):
03:01:10 <lambdabot> unexpected "x"
03:01:10 <lambdabot> expecting operator or ")"
03:01:22 <ether10101> Hmm I copied a function directly from the book and it has an error
03:01:43 <Axman6> NameAlreadyInUse: it can only pl things it knows about
03:01:49 <yitz> raji: do you think we can prove that every solution contains at least one maximal path?
03:01:54 <NameAlreadyInUse> oh
03:01:59 <yitz> every optimal solution
03:02:54 <raji> yitz, yeah that is the box itself
03:03:05 <bastl> im confused about useer and global pkg-databases. I have some pkgs installed with --user, some with --global. Now, some dependencies dont work. Does user imply global, or vice versa, or are they disjoint ? e.g. i try something with --user, but my cabal file imports base which is in --global.
03:03:10 <NameAlreadyInUse> @pl \c (x:y) -> x:((c:[]) : y)
03:03:10 <lambdabot> (`ap` tail) . (. head) . flip ((.) . (:)) . (:) . return
03:03:13 <ski> @type \c -> tree ((. (Node c [] :)) . Node)
03:03:14 <lambdabot> forall t. t -> Tree t -> Tree t
03:03:42 <NameAlreadyInUse> ah thanks ski
03:03:45 <yitz> raji: i am thinking of each box as a node, and a directed path from x to y if x can contain y
03:03:53 <ski>   tree node (Node a ts) = node a ts
03:03:55 <bastl> (ehm: ~/.ghc/arch/package.conf == --user and ghc-dir/package.conf == global, right? )
03:05:54 <bastl> could i fix it by appending my user-package.conf to the global one, and do only global isntallations from now on?
03:06:43 <mmorrow> yitz: heh
03:07:46 <ether10101> perms :: Eq a => [a] -> [[a]]
03:07:46 <ether10101>  perms [] = [[]]
03:07:46 <ether10101>  perms xs = [ x:ps | x <- xs , ps <- perms (xs\\[x]) ]
03:07:54 <tomh> hey, is there any way to do something like when condition $ x <-something ?
03:08:01 <tomh> in a monad
03:08:04 <ether10101> I copied that from book and getting error that "\\" is an undefined variable, any suggestions?
03:08:33 <raji> yitz, let the boxes be ordered (l<=w<=h) length<=width<=height, now we sort the boxes according to relation ( increasing length, if tied for length, decreasing width, decreasing height). Now find LIS. Remove the longest length at the farthest distance. Does it sound wrong ?
03:10:52 <dcoutts> bastl: the user includes the global
03:11:05 <raji> yitz, removing the greater box may cause problem , not sure
03:11:14 <bastl> dcoutts: thanks.
03:11:22 <dcoutts> bastl: but global packages cannot depend on user ones
03:11:30 <bastl> clearly
03:12:10 <dcoutts> bastl: the only thing to watch out for is masking global packages by user ones, that can cause problems
03:12:34 <bastl> what do you mean by masking ?
03:12:40 <Saizan> ether10101: import Data.List
03:12:41 <bastl> newer versions or the like?
03:13:07 <dcoutts> bastl: if you've got the exact same version of a package in the user db then it masks the one from the global db
03:13:46 <dcoutts> bastl: which is bad if other things depended on the global one, as now they appear to depend on the user one (but there's no guarantee that you can get the same ABI)
03:13:46 <bastl> ok. in case, same version but different code, you mean?
03:13:57 <bastl> ABI ?
03:14:04 <dcoutts> low level binary interface
03:14:17 <bastl> k
03:14:23 <tomh> no one knows how to apply conditions in monads? :/
03:14:42 <yitz> raji: not sure why you think that will work
03:15:12 <yitz> tomh: what conditions?
03:15:25 <raji> yitz, it works well in 2D :)
03:15:26 <tomh> like bla <- something only when condition is true
03:15:58 <yitz> raji: true, but now width and height are both decreasing within each length
03:15:59 <RayNbow> tomh: what should the value of bla be when the condition is false?
03:16:08 <tomh> the previous one
03:16:36 <gal_bolle> bla is not an imperative variable, it's a value
03:16:36 <tomh> im 'overwriting' it to say in imperative terms
03:16:43 <tomh> i know
03:16:53 <tomh> but if i assign it twice the inner one will be passed down
03:16:58 <gal_bolle> so you can't, you're shadowing (it's lexical)
03:17:12 <gal_bolle> the rest of the code will always get the inner value
03:17:20 <tomh> yes thats what i want
03:17:24 <ether10101> Saizan: How can I import both that and Prelude without messing with the rest of my program (I get an "ambiguous" function error with one I overwrote from Prelude when I have two separate import lines)
03:17:39 <gal_bolle> yes, but that inner value is undefined if your condition is not met
03:17:40 <tomh> so when the condition is not true i dont want that inner value to be there
03:17:48 <gal_bolle> you can't
03:17:49 <tomh> then it takes the outer value
03:17:51 <ejt> ether10101: import Prelude hiding (<fn>)
03:18:06 <gal_bolle> you have to explicitely make it take the outer value in that case
03:18:14 <tomh> mm
03:18:19 <gal_bolle> so bla <- if condition then stuf else return bla
03:18:24 <gal_bolle> +indentation
03:18:36 <ether10101> ejt: I have that, but Saizan is saying I need to import Data.List for another function, and when I add that to the top, I get the error again
03:18:38 <yitz> tomh: just describe what you want the value to be under various conditions - don't translate that to a sequence of conditional assignments like you would need to do in an imperative language.
03:19:01 <ejt> ether10101: use hiding with Data.List too then ;)
03:20:06 <ether10101> ejt: ah thanks
03:20:09 <ejt> ether10101: the other thing you can do is qualify your function when you refer to it: eg, Main.myfun
03:20:44 <tomh> yitz: ok i will try that
03:30:42 <yitz> hmm, research.microsoft.com works fine in lynx, but not in safari. interesting.
03:31:25 <sundaymorning> as far as I can tell it works fine on firefox also
03:32:11 <sundaymorning> though I think I'm missing something in the center screen
03:32:44 <yitz> broken in camino, a version of firefox for the Mac
03:33:02 * yitz walks over to his Debian box
03:33:26 <sundaymorning> hm, I suppose ms guys don't care if their websites work on mac os x or not
03:34:09 <nlogax> looks the same for me in mac safari 4 and windows IE 8
03:34:21 <nlogax> front page at least :)
03:36:38 <yitz> for me, no response from the server in safari 3.2.1, camino, and iceweasel
03:37:19 <yitz> so there's no way for me to access that site now unless I reboot my Mac into WIndows, or use lynx.
03:37:55 <yitz> nlogax: but that's safari on windows
03:38:21 <nlogax> yitz: no, on os x
03:38:37 <yitz> oh. interesting
03:38:42 <nlogax> it's fine in firefox on os x for me, too
03:38:52 * yitz tries firefox
03:40:39 <yitz> broken for me in firefox 2.0.0.4
03:40:52 <yitz> nlogax: which firefox? are you in n. america?
03:41:13 <nlogax> yitz: 3.0, i'm in sweden
03:41:53 * yitz decides its time to upgrade firefox on the mac, even though he never uses it
03:42:37 <yitz> so it's apparently not geolocation related, rather platform discrimination
03:42:50 <yitz> who would of thought of it from microsoft
03:44:33 <ivanm> yitz: not the same company that produces the email web interface I have to use at uni, that treats all non-IE users as second-class citizens! :o
03:45:08 <ivanm> and I seem to recall research.microsoft.com not working here on my linux box as well
03:45:10 <yitz> ivanm: can't you pop3 or imap it over to gmail?
03:45:42 <ivanm> yitz: well, the only account I care about I can't, since it's a course mailing address that I run for the course co-ordinator
03:46:07 <ivanm> I _did_ try setting up a rule to send me a copy of all emails when I logged in using IE once, but it doesn't seem to work :s
03:46:28 <yitz> ivanm: no pop3 or imap access to that account?
03:46:59 <ivanm> yitz: not sure, and it's not really my account (the course co-ordinator also checks it), so I can't really do anything like that :s
03:48:02 <yitz> ivanm: imap access certainly wouldn't hurt, and with pop3 you just have to be careful to leave a copy of everything when you download mail
03:49:15 <ivanm> yitz: yeah... but I don't know if there's IMAP, as the firefox interface doesn't reveal much information ;-)
03:49:18 * yitz tries firefox on the mac again, now upgraded to 3.0.7
03:49:26 <yitz> heh
03:49:41 <dnul> is there a cool graph module?
03:49:54 <ivanm> dnul: graph as in plots?
03:50:02 <ivanm> or graph as in relationships between points?
03:50:14 <daf> hmm, why is BrowserAction not an instance of MonadState/MonadIO?
03:50:15 <ivanm> if the former, chart offers very nice looking 2D plots
03:50:24 <ivanm> or else there's a partial gnuplot library available
03:50:34 <marcot> Is there a function that gives me the factors of a number in the standard libraries?
03:51:03 <yitz> nope, broken in firefox 3 on Mac OX X Tiger. so perhaps geolocation sensitive after all?
03:51:09 <dnul> ivanm: as a relationship
03:51:20 <ivanm> dnul: FGL is the Functional Graph Library
03:51:26 <ivanm> (i.e. provides data structures)
03:51:46 <dnul> ivanm: thing is, im starting my AI course , and i've got to decide if i use Java , haskell or C , what would you pick?
03:51:52 <ivanm> it has inbuilt bindings to graphviz for visualisation, but there's a standalone library (called graphviz) that produces better results
03:52:06 <ivanm> dnul: I'm not a big fan of Java or C
03:52:09 <ivanm> ;-)
03:52:16 <ivanm> dnul: realistically, depends on what I've got to implement
03:52:39 <dnul> ivanm: right now , i've got to build an inference engine
03:52:44 <NameAlreadyInUse> i am a big fan of C
03:52:48 <NameAlreadyInUse> but not java
03:52:56 <ivanm> *shameless plug* there's also my Graphalyze library that has more analysis algorithms, etc. for use with FGL graphs
03:53:04 <ivanm> dnul: never having implemented one of those, I have no idea ;-)
03:53:27 <dnul> ivanm: ok , thx u , will try on fgl
04:00:44 <dnul> ivanm: it is possible i need to install mtl library?
04:00:55 <ivanm> yes
04:01:06 <dnul> ivanm: ok
04:01:07 <ivanm> dnul: which OS/distro are you using?
04:01:17 <dnul> ivanm: ubuntu 8.04
04:01:28 <nareshov> libghc-mtl-dev
04:01:38 <dnul> hehe , thx
04:01:46 <ivanm> dnul: there's probably packages for FGL available as well
04:07:06 <ether10101> Axman6: still here by chance?
04:07:20 <Axman6> sort of
04:07:27 <ether10101> Haha, sorry
04:08:00 <ether10101> I'm now on 17.24 and am completely clueless as to how to approach it
04:09:48 <ether10101> Can I do it all in one function or do I have to split it into two like the example addFirstTwo ones on page 364
04:14:59 <lilac> ether10101: RWH?
04:15:29 <ether10101> lilac: ?
04:15:54 <ejt> lilac: no, Thompson
04:17:32 <lilac> are the Thompson exercises available online somewhere?
04:18:20 <lilac> google seems to say no ;-(
04:18:21 <ether10101> If anyone else could help:  the problem is "Define the function runningSums :: [Int] -> [Int] which calculates the running sums [0, a0, a0+a1, a0+a1+a2, ...] of a list [a0,a1,a2,...]"
04:18:39 <lilac> ether10101: what are you allowed to use from the Prelude?
04:18:51 <lilac> are you aware of the existence of scanl, for instance?
04:18:58 <ejt> or tails
04:19:09 <ether10101> Our teacher hasn't mentioned scanll
04:19:11 <ejt> nope,ignore that
04:19:12 <ether10101> but tails yes
04:19:12 <lilac> or inits
04:19:24 <ether10101> not inits either
04:19:32 <lilac> > inits [a,b,c,d,e] :: [[Expr]]
04:19:33 <lambdabot>   [[],[a],[a,b],[a,b,c],[a,b,c,d],[a,b,c,d,e]]
04:20:01 <lilac> inits is to init as tails is to tail :)
04:20:06 <ether10101> Hmm that's not quite correct anyhow?
04:20:19 <ejt> it is if you map sum over it
04:20:23 <ether10101> ah yes
04:20:42 <lilac> mapping a fold over inits is really the same as scanl
04:20:42 <ejt> but I think you should start by writing it with explicit recursion
04:20:50 <lilac> > scanl (+) 0 [a,b,c,d,e] :: [Expr]
04:20:52 <lambdabot>   [0,0 + a,0 + a + b,0 + a + b + c,0 + a + b + c + d,0 + a + b + c + d + e]
04:21:26 <ether10101> I see
04:21:39 <ether10101> but I would hope he wouldn't be expecting us to use something we've never heard of
04:21:49 <ivanm> lilac: "mapping a fold"?
04:21:55 <ether10101> it's probably expecting explicit recursion like ejt said
04:22:10 <ivanm> do you mean "map (fold f)" ?
04:22:23 <lilac> ivanm: right.
04:22:47 <ivanm> oh, wait, I get what you mean now
04:23:24 <lilac> @check \f x xs -> map (foldl f x) (inits xs) == scanl f x xs
04:23:25 <lambdabot>       Overlapping instances for Show (a -> b -> a)
04:23:25 <lambdabot>        arising from a use ...
04:24:42 <wli> benchpress is very slow :(
04:24:55 <lilac> @check \x xs -> map (foldl (*) x) (inits xs) == scanl (*) x xs
04:24:57 <lambdabot>   "OK, passed 500 tests."
04:25:00 <wli> The results I got were not decisive, either.
04:25:01 <wli>              min          mean        +/-sd        median        max
04:25:01 <wli> hotaru:  1617760.000  1623923.000     4690.539  1624995.000  1631700.000
04:25:01 <wli> wli:     1618530.000  1623130.000     4698.063  1621875.000  1631870.000
04:25:21 <lilac> @check \x xs -> map (foldl (-) x) (inits xs) == scanl (-) x xs
04:25:22 <lambdabot>   "OK, passed 500 tests."
04:25:45 <lilac> wli: primality testing again?
04:25:52 <lilac> or was it fibonacci?
04:26:02 <wli> lilac: Fibonacci
04:26:51 <wli> There are things like student's t tests for comparisons of means it's not doing, and the full statistics aren't reported, either.
04:27:14 <ivanm> lilac: awww, wouldn't QC randomly choose a function for you? ;-)
04:28:00 <lilac> ivanm: IIRC, it can, but it needs a show instance for functions to provide a failing testcase
04:28:12 <ivanm> ahhhhh
04:28:29 <lilac> ivanm: the bigger problem is that it'd probably end up defaulting the type of x to () which makes the whole thing kinda trivial
04:28:30 <ivanm> the good old: show f = "<function>" ?
04:28:44 <ivanm> yeah :s
04:34:39 <wli> lilac: I wouldn't get too involved with primality testing; factorization is more important for e.g. phi(n), d(n), etc.
04:34:54 <wli> lilac: mu(n) too.
04:35:13 <wli> mu(n) being very important for number-theoretic convolution affairs.
04:37:07 <ether10101> lilac: any suggestion on how to approach the problem using only recursion?
04:37:54 <lilac> ether10101: if i tell you that the previous element of the result was 'x' and the next value in the list is 'y', what's the next value in the result?
04:38:25 <ether10101> x+y
04:39:11 <ether10101> I know you have to pass the sum back into the function... I just can't wrap my head around it
04:39:18 <ether10101> we haven't really worked with haskell that much
04:39:21 <lilac> ether10101: generalize the problem
04:39:36 <lilac> ether10101: instead of writing a recursive function which takes a list, write a recursive function which takes a list and a starting value
04:40:21 <lilac> ether10101: let's call that function 'go'
04:40:30 <lilac> ether10101: then runningSums xs = go xs 0
04:40:37 <wli> I guess it'd have to be a Welch's t-test.
04:40:39 <NameAlreadyInUse> is there a way i can define my own exceptions
04:40:49 <NameAlreadyInUse> i'm using undefined to indicate "no value here"
04:41:12 <NameAlreadyInUse> but sometimes my function spits back "exception prelude.undefined etc", and i can't be sure where its come from
04:41:48 <lilac> @hackage extensible-exceptions
04:41:48 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/extensible-exceptions
04:42:14 <NameAlreadyInUse> thanks
04:42:59 <quicksilver> NameAlreadyInUse: if you're using undefined
04:43:11 <quicksilver> NameAlreadyInUse: you could instead use 'error "This shouldn't happen because .... "'
04:43:23 <quicksilver> the extensible exceptions stuff is different, really.
04:43:39 <NameAlreadyInUse> ah, yeah, error seems to be what i need
04:45:28 <wli> If there were extensible variants, extensible exceptions wouldn't be much of a problem. ;)
04:45:47 <wli> quicksilver: I use throwError and monadify.
04:46:00 <quicksilver> well, among other things the extensible exceptions paper shows a way of encoding extensible variants.
04:46:06 <quicksilver> wli: sure. It's horses for courses.
04:46:30 <quicksilver> both throwError and extensible exceptions are intended for the type you "catch"
04:46:44 <quicksilver> whereas 'error "blah"' is more for the 'this shouldn't have happened case'
04:46:54 <quicksilver> and it can be useful to put something useful in the 'blah'
04:47:52 <NameAlreadyInUse> i intend to make the function total once i have finished figuring out how everything is going to work
04:49:00 <wli> I sort of vaguely hope that -Wall and exhaustive case analysis helps, but when there are spurious warnings I'm shutting up, error it is.
04:49:29 <quicksilver> wli: have you seen ndm's "catch" ?
04:49:38 <quicksilver> it checks the logic of your non-exhaustive cases.
04:50:11 <wli> quicksilver: Yeah, I'd love for it to get merged into various compilers.
04:50:22 <NameAlreadyInUse> who is ndm?
04:50:43 <quicksilver> neil mitchell
04:50:46 <wli> quicksilver: I have used it, but mostly I just silence -Wall
04:51:10 <quicksilver> http://community.haskell.org/~ndm/
04:51:18 <quicksilver> wli: I find -Wall not to be useful.
04:52:31 <quicksilver> unfortunately ndm is no longer a cool haskell hacker, since he has a job now :P
04:53:11 <wli> A non-Haskell job?
04:54:01 <osfameron> pesky jobs
04:54:27 <wli> My job is non-Haskell.
04:55:14 <NameAlreadyInUse> are there many haskell jobs?
04:55:17 <wli> It seemed like he specialized in FP/etc. so I figured the odds of his job having something to do with Haskell were moderately high.
04:55:24 <NameAlreadyInUse> i was under the impression that there weren't many
04:55:40 <mreh> email someone important and ask them
04:56:29 <wli> NameAlreadyInUse: I don't have any idea. FP/etc. is rather far afield from my actual specialty, so I've no contact with the world that makes any sort of actual use of any of it.
04:56:59 <pejo> quicksilver, I think ndm is still hacking haskell. But have to run for lunch.
04:57:33 <mmorrow> nice, tail recursion in C http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1927#a1927
04:57:42 <wli> NameAlreadyInUse: ndm actually worked on Haskell compilers, did research at uni's on it, etc., so it's a rather different story in his case.
04:58:35 <NameAlreadyInUse> wli: oh
04:58:42 <mreh> where does the community post improvement requests for modules guys? bug reports and those kinds of things
05:00:06 * wli hammers out defaults for case expressions.
05:00:14 <wli> mmorrow: Yeah, I've done that before, too.
05:02:08 <mmorrow> wli: cps ftw
05:02:44 <wli> mmorrow: Actually I did something different.
05:03:04 * ejt wonders if he's brave enough to ask the Ruby channel how they tie knots in their data
05:03:34 <wli> mmorrow: Or at least I passed different sorts of things as continuations and did different sorts of things in the functions.
05:03:57 <Baughn> ejt: Now, now. They do at least have a mark-and-sweep GC.
05:04:19 <Baughn> ejt: So try it in #perl.
05:04:45 <ejt> Baughn: I need to do it in Ruby :(
05:05:11 <wli> If your heap cells are bloated enough the space overhead isn't going to break you, go for Baker's treadmill.
05:05:18 <Baughn> ejt: Pretty simple, isn't it? Check whether the value is a function; if it is, call it and replace the variable with its result; otherwise use it
05:06:14 <wli> I guess most people would s/Baker's//g there and just say "treadmill"
05:07:03 <ejt> Baughn: y, that would work, I'd have to change a lot of code - but that's the best I can come up with
05:07:41 <Baughn> ejt: It's the same problem dealt with in dynamic programming problems; you could go look up how they do it
05:09:04 <wli> I think I'm probably going to use a treadmill.
05:10:36 <Schmallon> Is there any Haskell compiler which actually makes use of parser combinators?
05:10:46 <osfameron> tying knots in a dynamic language is trivial
05:11:02 <osfameron> (making them garbage collect sanely afterwards can be less fun)
05:11:20 <osfameron> (in perl, which has crappy refcount gc)
05:13:05 <wli> I don't know how bloated perl's heap nodes are, but suspect a fair amount of GC metadata could be shoehorned in without a significant hit.
05:13:22 <quicksilver> that's not the reason perl doesn't have a real GC
05:13:37 <quicksilver> it was more like larry didn't know how to write one, or didn't see the point.
05:14:19 <osfameron> and refcount was convenient for certain commonly used semantics
05:14:51 <wli> That rapidly raises the question of why people would actually use that junk.
05:17:13 <daf> because it's Good Enough
05:18:06 <quicksilver> wli: because it does a job, and does it well.
05:18:07 <NameAlreadyInUse> i think that is the perl philosophy
05:18:21 <quicksilver> historically perl was not often used for long-running applications
05:18:34 <quicksilver> and people tended not to build data structures with cycles.
05:18:47 <quicksilver> these days both those assupmtions are less solid, but the people who break them are aware of the issues.
05:20:48 <yitz> python uses refcount, but also has a GC for when there are cycles
05:21:17 <quicksilver> yitz: that's interesting.
05:21:25 <quicksilver> yitz: as far as I know refcounting is known to be slower than GC
05:21:35 <wli> yitz: That's vaguely sane. I guess you trade off some overhead for more eager reaping.
05:21:41 * yitz contacts his ISP to investigate why MSR is getting blocked for him
05:21:42 <quicksilver> so academci research rejects that compromise as the worst of both worlds.
05:21:50 <yitz> heh
05:21:56 <quicksilver> can't remember where I read that.
05:21:59 <quicksilver> maybe it's folklore.
05:22:02 <yitz> well, as wli says, latency is also important
05:22:55 <wli> quicksilver: It's true in a real sense. It means the GC shows up as overhead all over the place.
05:23:18 <quicksilver> e.g. http://wiki.tcl.tk/9386
05:23:21 <quicksilver> comment at the bottom.
05:23:38 <quicksilver> wli: yes, it's probably easier to understand the cost model of refcounting.
05:24:07 <quicksilver> you know objects get destroyed immediately that their count goes to zero, and in principle you can work out where that is.
05:24:55 <Philonous1> Can you recommend books/papers on GC?
05:25:10 <bastl> is there a public darcs repo for HaXml ?
05:25:25 <ivanm> @go haxml darcs
05:25:32 <lambdabot> http://wiki.loria.fr/wiki/Discuter:GenI/Getting_GenI
05:25:32 <lambdabot> Title: Discuter:GenI/Getting GenI - Loria Wiki
05:25:39 <ivanm> heh, don't think that's it somehow
05:25:46 <bastl> :-)
05:25:55 <quicksilver> bastl: "Ongoing development: The development version of HaXml is also available through
05:25:58 <quicksilver> darcs get http://www.cs.york.ac.uk/fp/darcs/HaXml "
05:26:02 <quicksilver> from http://www.cs.york.ac.uk/fp/HaXml-devel/
05:26:20 <bastl> thanks
05:26:21 <wli> quicksilver: I honestly wouldn't knock the overhead of recounting atop a genuine GC for the purposes of more eager memory reclamation.
05:27:29 <quicksilver> why is eager reclamation a virtue?
05:27:38 <quicksilver> (just taking devil's advocate position here)
05:29:13 <wli> quicksilver: Memory footprint is big esp. wrt. competition for resources on fully-utilized systems. CPU overhead tends to be almost meaningless anymore.
05:30:25 <quicksilver> wli: but GCs can be tuned to a particular memory overhead rather easily.
05:30:26 <osfameron> eager reclamation is nice for the perlish thing of closing filehandles immediately when they go out of scope
05:30:44 <quicksilver> osfameron: sure, but that's actually somethin different.
05:30:54 <quicksilver> osfameron: I'm not sure it's entirely helpful to unify memory with other resources.
05:30:57 <quicksilver> (although it's common to do so)
05:31:07 <quicksilver> they might deserve different treatment.
05:31:39 <quicksilver> some people argue that destructors which actually do something (like return a scarce OS resource) are not appropriate for dynamically allocated objects.
05:31:51 <quicksilver> they only work well/predictable for static allocation.
05:31:58 <quicksilver> stack allocation, in C++'s RAII idiom.
05:32:35 <quicksilver> we have that idiom in haskell too, as in "withFoo $ \foo -> .... do things with foo ...."
05:32:55 <NameAlreadyInUse> @type withFoo
05:32:56 <lambdabot> Not in scope: `withFoo'
05:32:59 <osfameron> ah, that's a good idiom
05:33:01 <koeien> NameAlreadyInUse: it's an idiom
05:33:05 <NameAlreadyInUse> oh
05:33:17 <koeien> e.g. inTransaction in HDBC
05:33:43 <koeien> or withArray or so
05:33:52 <koeien> withCString. there are numerous examples
05:34:14 <koeien> @type withCString
05:34:15 <lambdabot> Not in scope: `withCString'
05:34:17 <wli> quicksilver: I'd say memory is a scarce OS resource.
05:34:19 <quicksilver> I'm not, incidentally saying I'm completely in agreement with that extreme view about destructors.
05:34:29 <quicksilver> destructors are very very useful sometimes.
05:34:35 <NameAlreadyInUse> so the withFoo frees the resource after "do things with foo"?
05:34:39 <quicksilver> I simply remark that it's controversial enough that people take that view.
05:34:43 <quicksilver> NameAlreadyInUse: exactly.
05:34:54 <yitz> @type bracket
05:34:55 <lambdabot> Not in scope: `bracket'
05:34:58 <quicksilver> wli: yes, but it's a very special one.
05:35:04 <quicksilver> wli: in particular it's fungible.
05:35:07 <yitz> @type Control.Exception.bracket
05:35:09 <lambdabot> forall a b c. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
05:35:09 <NameAlreadyInUse> yeah, i think that is a good thing
05:35:17 <quicksilver> wli: and it often has softer limits.
05:35:20 <quicksilver> (not always, though)
05:35:34 <wli> quicksilver: OTOH the userspace apps I tend to run into are things like database servers that basically are stuck running in precisely fixed physical and virtual memory space.
05:36:54 <quicksilver> NameAlreadyInUse, osfameron, koeien : of course it's not always a safe idiom in haskell
05:37:06 <quicksilver> because in most cases nothing stops you letting 'foo' escape
05:37:07 <wli> There's some private space, but most of their stuff goes through a shm segment whose size is fixed up-front.
05:37:15 <quicksilver> and that may be broken.
05:37:33 <quicksilver> you can use a higher rank type to avoid that, like ST, but that has its own problems.
05:37:41 <quicksilver> you can't win em all, not all at the same time.
05:38:06 <wli> Hmm. Should I bind a var to the whole scrutinee in the default alternative for a case?
05:38:23 <quicksilver> I wouldn't have thought so.
05:38:39 <quicksilver> they must have access to the scrutinee by whatever method they used to apply case to it.
05:42:16 <Axman6> ha, first semi abusive comment on my blog. i am now a true blogger :)
05:42:36 <yitz> Axman6: url?
05:43:14 <Axman6> ot really abusive, just ignant dawg. http://axman6.homeip.net/blog/2009/03/datarandom-visitor-stats.html
05:43:45 <wli> quicksilver: The STG paper has their case exprs provide a var bound to the scrutinee. I guess it's like case f u v w of { [] -> ... ; xs -> foldr1 ... xs }
05:43:59 <yitz> quicksilver: python's gc only runs when the runtime suspects there might be a cycle somewhere. usually it's just refcounts.
05:44:28 <pejo> Philonous1, Garbage Collection: Algorithms for Automatic Dynamic Memory Management by Richard Jones and .. someone else.
05:44:37 <quicksilver> yitz: yes, and my argument is that that is stupid.
05:44:43 <quicksilver> yitz: since GC is faster than refcounting
05:44:56 <quicksilver> yitz: it would be MOAR SPEED to just use GC all the time.
05:45:14 <wli> yitz: Hmm. That's different from what I'd do with refcounting plus real GC. I'd just run the GC under the conditions it'd otherwise be invoked.
05:45:39 <wli> yitz: e.g. whenever heap expansion would be required
05:45:52 <mreh> I MISSED MY APPOINTMENT AT THE UNEMPLOYMENT OFFICE
05:46:07 <mreh> goodbye cruel world
05:46:34 <wli> quicksilver: Oh, yeah, another reason is latency; GC may have to do large scans etc. of the heap.
05:47:15 <yitz> quicksilver, wli: python was built from the ground up with refcounts. gc was bolted on later. you'd basically need a complete rewrite to switch to just gc.
05:47:22 <quicksilver> yitz: understood.
05:47:38 <quicksilver> wli: if you remove the last reference to a large structure which contains many many last references to other strutures
05:47:43 <quicksilver> wli: then you have bad latency too.
05:47:45 <pejo> quicksilver, (returning to old subjects) I think HLint came out after Neil got a job. And Hlint is definitely cool in my book.
05:47:52 <wli> Treadmills are huge overheads vs. other GC methods but their latencies are good.
05:48:06 <quicksilver> wli: (in refcounting, that was supposed to be)
05:48:15 <quicksilver> recounting latencies are a bit easier to predict, at least in principle
05:48:20 <quicksilver> although in practice they're not.
05:48:35 <yitz> Axman6: :)
05:48:36 <quicksilver> if your object graph is complex, occasinally destroying one object sets of a massive chain reaction.
05:48:43 <wli> quicksilver: Yeah. I'm not religious about refcounting.
05:48:52 * Axman6 totally did not just edit that comment >_>
05:48:52 <quicksilver> this problem doesn't occur often in practice.
05:48:58 <quicksilver> I'm not entirely sure why not.
05:49:14 <quicksilver> I think maybe users of refcounting langauges just tend not to build up things like that.
05:49:15 <yitz> Axman6: btw your captcha word is "unpaid". hmm... (oops, I revealed it)
05:49:35 <wli> quicksilver: High-overhead tolerance for low latency may be best accomplished via treadmills.
05:49:50 <jmcarthur> i've always been rather agnostic toward the GC algorithm in whatever implementation of a language i'm using
05:49:59 <wli> quicksilver: Treadmills in isolation, that is.
05:50:04 <jmcarthur> at least as far as how i use the language
05:50:26 <quicksilver> jmcarthur: well, on the counter balance, GC is a real problem for games.
05:50:35 <quicksilver> I've written several haskell game proofs of concept
05:50:35 <jmcarthur> can be
05:50:43 <quicksilver> and the occasional GC lurge is often visible.
05:50:44 <yitz> quicksilver: a smart refcount heap can safely delay part of the reclaimation when there is a complex object graph like that
05:50:54 <jmcarthur> isn't there a way to force a gc in ghc?
05:51:03 <quicksilver> jmcarthur: yup. But you have to be careful.
05:51:12 <quicksilver> jmcarthur: forcing GC more often than necessary is just stupid ;)
05:51:12 <yitz> (don't know if python does that though)
05:51:15 <quicksilver> since GC is reather slow.
05:51:23 <yitz> jmcarthur: but yes
05:51:25 <quicksilver> forcing it every frame is too often, typically, for example.
05:51:41 <jmcarthur> right, but it could at least give you more peace of mind that it happens consistently
05:51:47 <wli> yitz: Yeah, there is an obvious solution of queueing up targets of cascading refcounts.
05:51:47 <jmcarthur> yeah
05:52:36 * wli beats the treadmill drum.
05:53:27 <int-e> yitz: but you lose the immediate freeing of resources that refcounting advocates seem to be so fond of.
05:53:45 <wli> A refcount cascade queue could then be drained on demand etc.
05:54:47 <wli> I'd use something like an accelerated regime from deferred coalescing, so you free more objects than you defer refcount-based freeing of.
05:55:01 <yitz> int-e: yeah, oops. I guess you can't delay it for too long.
05:55:53 <wli> yitz: A periodic timer to go around cleaning things out incrementally?
05:56:13 <yitz> wli: it's usually driven by demand
05:59:00 <yitz> mreh: this channel is for discussion of haskell.
05:59:04 <wli> yitz: Sure, but if you want/need to eagerly free without large interruptions, periodic reaping makes sense.
05:59:30 <quicksilver> it almost begins to sound like GC now :)
05:59:59 <wli> quicksilver: I'm presuming a treadmill sitting behind "my" refcounts.
06:00:19 <yitz> wli: yeah, in addition
06:01:44 <wli> quicksilver: Without that or _something_ it's unsound, and so a non-starter.
06:02:16 <guenni4> I'd like to "cabal install" a few packages with profiling enabled, however subsequent dependencies apparently also need to be reinstalled with profiling enabled. Is there a way for cabal install to handle this automatically or do I need to do this by hand?
06:02:16 <wli> I guess this is sort of "how do you fight GC pauses?"
06:03:24 <Philonous1> pejo: Thanks a bunch
06:04:16 <wli> But also keeping resource footprints down within fairly narrow time windows for apps dominated by IO.
06:05:26 <ivanm> when do we have to vote by for the new logo? I can't seem to recall seeing a date anywhere :s
06:05:43 <wli> You can use resources overall to the point of squandering them, but just not all at once.
06:05:51 <int-e> ivanm: march 24th IIRC
06:06:06 <ivanm> oh, good, I can do that over the weekend or something then
06:06:09 <ivanm> thanks int-e
06:07:05 <wli> quicksilver: And from that POV the deferred refcounting makes a lot of sense.
06:08:20 <Saizan> guenni4: by hand unfortunately, since there's no proper way for cabal to tell if the profiling version is installed or not
06:08:50 <guenni4> Saizan: thx
06:09:33 <wli> The "accelerated regime" affair means that when you have a cascading refcount, you queue up a zero-refcount object in the GC somewhere instead of following the chain all the way. Then every time you ever pull from the queue of zero refcount objects, you don't just take a free object out, but you follow the chain at least 2 steps but some bounded and constant number of steps.
06:10:36 <quicksilver> wli: well incremental GC is a popular train of thought for fighting pausses.
06:10:45 <quicksilver> and arguably a good parallel collector helps.
06:11:24 <wli> True; it's not a bad use for another core.
06:11:42 <wli> Or another thread or whatever.
06:13:45 <wli> If there's high pointer/reference fanout even the limited cascading affair is tricky because it may not yield a usable object because the zero refcount object is still holding references after hitting the bound on references to decrement, and so are all the children it decremented refcounts on, etc.
06:14:28 <wli> The fanout issue is death for refcounts. They're useless.
06:15:04 <wli> quicksilver: Cite that case for anti-refcount affairs.
06:15:30 * quicksilver nods
06:15:46 <wli> quicksilver: It's very easily the case with B+ trees, radix trees, hash tries, etc.
06:16:37 <wli> Okay, f*** refcounts, treadmill all the way baby.
06:16:59 <quicksilver> or a hybrid of treadmill and generational GC.
06:17:19 <quicksilver> have you read Jones' paper on the beltway?
06:17:37 <wli> No, I've never heard of beltways.
06:18:22 <quicksilver> it's a more complex generational structure. I forget the details but enjoyed the talk at the time.
06:19:14 <quicksilver> wli: http://www.cs.kent.ac.uk/pubs/2002/1363/index.html
06:20:42 <wli> I'm debating whether to make case statements matching against primitive types be done once per-type or to just have one primcase and let the typechecker catch it.
06:24:02 <wli> quicksilver: I'm not sure I actually get the gist of it from the paper. Is it like a treadmill with multiple queues?
06:24:16 <quicksilver> I don't remember the details :-(
06:24:26 <quicksilver> it was about 6 years ago I went to the talk.
06:25:41 <Martijn> I've set "documentation: True" in my ~/.cabal/config -- can I also set it to generate links to source by default?
06:25:47 <wli> I can't figure it out from the paper.
06:31:30 <wli> quicksilver: ftp://ftp.cs.utexas.edu/pub/garbage/bigsurv.ps seems to have a fair amount of detail.
06:31:51 <wli> quicksilver: Unfortunately the algorithms are rather basic.
06:34:23 <lilac> Axman6: no hits from konqueror at all? :-(
06:34:59 <Axman6> i think it was further down the list
06:40:43 <andun> I'm holding a Haskell talk in Trondheim, Norway this evening, in case anyone is nearby :-)
06:44:28 <quicksilver> andun: that's a bit too far to walk, I'm afraid.
06:45:00 <andun> quicksilver: i'll force you to hold it if you come :-P
06:45:35 <pejo> Will be a very long talk if you do that to all listeners.
06:45:38 <bremner> also, isn't it still winter in Trondheim?
06:45:53 <Martijn> I doubt that
06:45:57 <andun> yes it is
06:46:04 <Martijn> Hmm
06:46:07 <Martijn> Winters are longer there?
06:46:11 <andun> but it's getting hotter and spring :-)
06:46:27 <andun> Martijn: we usually have snow until early may, i think
06:46:55 <Martijn> But it will be Spring officially in a few days, just like here in the Netherlands, right?
06:47:35 <SamB> mmorrow: why does hpaste always link you to view?id=NNNN#aNNNN when you create a new paste?
06:47:42 <andun> Martijn: sure. it's just still cold :)
06:47:43 <SamB> why not just view?id=NNNN ?
06:47:49 <Martijn> andun: fair enough :-P
06:48:50 <andun> i'm telling these people that Monads shold me named Marsvin in norwegian. (Marsvin means guinea pig, which is a warm, fuzzy thing :-)
06:49:01 <SamB> heh
06:49:10 <pejo> Martijn, I went to the netherlands in mid-may last year, the grass was green, there were flowers everywhere and so on. Significant difference to home.
06:49:42 * lilac doesn't get why renaming Monad to something which equally has no associated semantics to a non-category-theorist would be a good thing
06:50:07 <andun> lilac: not better, just cuter.
06:50:57 <lilac> well, cuteness /is/ a compelling reason ;-)
06:51:27 <colouragga> π
06:53:29 <EvilTerran> µ!
06:53:41 <lilac> #! /usr/bin/??on
06:53:52 <Martijn> pejo: our grass is evergreen. My flatmate is from Iceland and loves our grass; his grass turns grey in winter.
06:58:07 <eden_> first time at this, lets see if it does anything
06:58:39 <Martijn> Yup! It's working
06:59:11 <irekj> hi
06:59:35 <eden_> Rocking. I was wondering if anybody is familiar with generating error messages in Parsec. My web searching has finally failed me...
07:00:14 <Martijn> Try parserFail
07:00:21 <Martijn> Or the <?> combinator
07:01:04 <Martijn> @hoogle parserFail
07:01:04 <lambdabot> Text.Parsec.Prim parserFail :: Monad m => String -> ParsecT s u m a
07:01:26 <Martijn> :t Text.Parsec.Prim.parserFail
07:01:28 <lambdabot> Couldn't find qualified module.
07:01:35 <wli> It's tough to find an adequate description of Dijkstra's write barrier -based incremental collector.
07:01:36 <cnwdup> Can darcs create a .tar.gz from the sources in the repo?
07:02:11 <irekj> beginner's question: usually one map with a function over a list of "data". I often do the other way around I have a list of functions and I map to a list of results by applying a parameter, so I do map (\a->a parameter) listOfFunctions. Is there a "standard" function that would replace my lambda exp, something like apply a f = f a ?
07:02:21 <irekj> one maps*
07:02:21 <pejo> cnwdup, cabal can, if that is of any help.
07:02:38 <cnwdup> pejo, thanks. I'll check it out and see if it is. (:
07:02:56 <Martijn> @pl \a -> a parameter
07:02:56 <lambdabot> ($ parameter)
07:02:56 <trofi^w> > map ($ 3) [sin, cos]
07:02:59 <lambdabot>   [0.1411200080598672,-0.9899924966004454]
07:03:59 <irekj> thanks Martijn, trofi and unreplacable lambdabot! :)
07:04:09 <Martijn> Enjoy :-)
07:04:36 <trofi^w> [:
07:05:16 <irekj> it's very cool
07:05:24 <irekj> I mean haskell and this channel too
07:05:54 <EvilTerran> > sequence [f,g,h] x :: [Expr]
07:05:55 <lambdabot>   [f x,g x,h x]
07:06:48 <irekj> this is even better! thanks a lot
07:06:57 <cnwdup> pejo, darcs can do it too. darcs dist. But thanks for the hint with cabal anyways.
07:07:10 <trofi^w> > sequence [(+1), (-2)] 4
07:07:11 <lambdabot>       No instance for (Num (a -> a))
07:07:11 <lambdabot>        arising from a use of `negate' at...
07:07:27 <trofi^w> > sequence [(+1), (2-)] 4
07:07:29 <lambdabot>   [5,-2]
07:07:40 <Martijn> @pl \f y r x -> r (f x y)
07:07:40 <lambdabot> (flip (.) .) . flip
07:08:26 <EvilTerran> irekj, "map ($x) fs" is probably more self-documenting than "sequence fs x", though
07:08:30 <EvilTerran> ?type seuqnece
07:08:31 <lambdabot> Not in scope: `seuqnece'
07:08:33 <EvilTerran> ?type sequnece
07:08:34 <lambdabot> Not in scope: `sequnece'
07:08:49 * EvilTerran can't tyep today, he has teh dumb
07:08:53 <trofi^w> the next one should be correct
07:09:01 <EvilTerran> ?type sequence
07:09:03 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
07:11:13 <wli> ah, wikipedia links directly to Dijkstra's original paper.
07:11:41 <wli> (which appears to be a poor description of the algorithm also)
07:13:05 <wli> I'm actually unsure of how the proper GC algorithms cope with the pointer fanout problem that refcounting also has.
07:13:49 <wli> I guess some don't traverse pointers in garbage.
07:15:44 <irekj> @pl wordConfigurables word = concat$sequence configurators word
07:15:44 <lambdabot> wordConfigurables = join . sequence configurators
07:16:07 <irekj> ?type join
07:16:08 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
07:17:24 <Alpounet> Hi all. I'm trying to write an IRC Bot, like lambdabot. I get : ERROR :Closing Link: 127.0.0.1 (Connection Timed Out)
07:17:27 <Alpounet> any idea ?
07:17:55 <profmakx> do you have an icq server listening on the lo interface?
07:18:14 <Alpounet> don't think so, no.
07:18:36 <profmakx> have you ever done network programming of any kind?
07:18:41 <Alpounet> Yes.
07:19:02 <Alpounet> I'm just sending the necessary to the server (NICK, USER, etc... with \r\n at the end of lines)
07:19:08 <profmakx> uh
07:19:17 <profmakx> you actually _are_ connected to the irc server
07:19:31 <profmakx> ?
07:19:39 <Alpounet> Hmmm, I am.
07:19:42 <Ferdirand> which irc server do you use for testing ?
07:19:47 <Alpounet> this one (freenode)
07:19:48 <Ferdirand> are you replying to its initial ping message ?
07:20:07 <Alpounet> I've a part of the code for replying PONG Something when receiving PING Something
07:20:08 <Alpounet> yep
07:20:39 <Alpounet> Ferdirand, if there is something wrong in that part, the server would close the connection ?
07:20:58 <Ferdirand> yes, it will if you don't answer the ping within x seconds
07:21:33 <Ferdirand> but 127.0.0.1 is weird if you're using freenode to test
07:21:38 <Alpounet> yep.
07:22:35 <raimo__> how can I change my IP in internet to 127.0.0.1?
07:22:41 <profmakx> O.o
07:23:35 <raimo__> if I configure it as my ip on network devices I can't see any webpages anymore
07:23:38 <Ferdirand> raimo__: that doesn't make sense
07:25:05 <eden_> I've parsed something successfully in parsec but want to fail when it is an illegal value, with a message that reports the start of the token. Would parserFail do that?
07:31:16 <wli> I'm actually having trouble understanding even more basic GC algorithms. :(
07:31:41 <vixey> wli: I know a dead simple one
07:32:01 <wli> vixey: Semispaces?
07:32:10 <wli> vixey: Stop-and-copy, right?
07:32:14 <vixey> yes
07:32:28 <vixey> I guess you know it already then
07:32:53 <wli> That one I understand, but it's sort of doorstop-level. I'm falling down on tricolor marking.
07:33:00 <mikhail^> hey guys, I'm trying to use haskelldb-hsql and I'm running into problems when doing 'cabal install haskelldb-hsql'
07:33:30 <mikhail^> it complains that it can't find module `System.Time' which is in old-time-1.0.0.0 which apparently is hidden
07:33:46 <vixey> well presumably you know what each color means?
07:33:49 <mikhail^> any quick way for me to address this situation?
07:36:30 <quicksilver> lilac: I think we should rename Monad to ColourlessGreenIdeaDreamingFuriously
07:38:11 <wchogg> quicksilver : I second this suggestion, if only for the adverb Furiously
07:38:25 <ejt> quicksilver: how about s/Monad/WelcomeToAbstractThought/
07:40:13 <wchogg> or perhaps changing it to SaundersMacLaneIsKindOfDissappointedInYourIrrationalFearOfAbstractionButItsCoolHesStillComingToYourBirthday
07:40:50 <ejt> lol
07:54:18 <mikhail^> okay, that's odd -- I have old-time 1.0.0.0 and old-time 1.0.0.1 but when I cabal install haskelldb-hsql it still keeps looking for old-time-1.0.0.0
07:55:53 <mikhail^> is there way for me to remove the old version of old-time (1.0.0.0) ?
07:56:01 <eden_> Oh well, parserFail definately doesn't help me. I need a new version of the base libraries for it, and cabal is refusing to upgrade them. It's always refused to upgrade tuff, so I give up.
07:57:07 <vixey> eden_: I tend to have parse trees annotated with locations
07:57:48 <vixey> you can get a location from Parsec somehow (automatically)
08:04:16 <Philippa_> vixey: there's a get function, it's part of parsec's state
08:05:42 <BrokenClockwork> hey, I am calculating Pi: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2602#a2602 however I cannot make to many operations, I get really fast a stack overflow
08:05:50 <BrokenClockwork> are there some options to tune it?
08:06:48 <Botje> you should probably make it stricter somehow
08:07:05 <vixey> use the ocaml monad
08:07:08 <BrokenClockwork> stricter huh
08:07:09 <Botje> :)
08:07:33 <Botje> BrokenClockwork: let a = wallis (n - 1); b = 1/.... in b `seq` a` seq` a + b
08:08:10 <profmakx> hm
08:08:12 <Botje> that way haskell immediately computes that division instead of storing it for later computation
08:08:31 <quicksilver> wchogg++
08:08:33 <Botje> bonus: you see a nice way to refactor that guard :)
08:09:31 <Botje> heh
08:09:42 <Botje> BrokenClockwork: of course the obvious thing to do is make your function tail recursive
08:10:00 <BrokenClockwork> okay I had this done already, but it didnt mad eit better ;D
08:10:07 <profmakx> that guard is evil anyway
08:10:08 <BrokenClockwork> but I will try again with your add. infos
08:10:10 <Botje> seq or tail recursion?
08:10:17 <BrokenClockwork> second
08:10:43 <Botje> then you just have to seq the second component before using it
08:11:05 <BrokenClockwork> ok! :)
08:11:06 <Botje> wallis n acc = acc `seq` wallis (n-1) (acc + whatever)
08:14:45 * MyCatVerbs swears at his university lots and lots.
08:15:33 <wchogg> MyCatVerbs : ?
08:16:10 <MyCatVerbs> wchogg: sufficiently broken GHC install that I can't get, for example, ghc-core up and running.
08:16:25 <MyCatVerbs> Or install libraries from Hackage, either by hand or through Cabal.
08:16:41 <MyCatVerbs> I'm not quite clear on how they manage to get GHC to install at all while simultaneously breaking it so terribly.
08:22:39 <BrokenClockwork> okay, accumulating pattern + seq is working now very fine :)
08:23:57 <BrokenClockwork> @src seq
08:23:57 <lambdabot> Source not found. It can only be attributed to human error.
08:24:22 <Botje> it's in the prelude
08:24:25 <Botje> :t seq
08:24:26 <lambdabot> forall a t. a -> t -> t
08:24:45 <Botje> it evaluates the first argument (up to a certain point), then throws it away and returns the second one
08:24:53 <Botje> it's as close to side effects as you're going to get in pure haskell :)
08:25:35 <BrokenClockwork> so it's forcing to evaluate, for unneeded laziness
08:25:44 <Botje> yes
08:25:57 <Botje> optimization in haskell boils down to: make it stricter OR make it lazier
08:26:55 <jmcarthur> aka: avoid unnecessary thunks or avoid unnecessary work
08:29:03 <BrokenClockwork> so, for instance (3 + 3 + 3 + ... + 3) `seq` 2 returns 2, but also calculated the result for (3 + 3 + 3 + ... + 3) ?
08:29:18 <Deewiant> Yep.
08:29:23 <BrokenClockwork> what I dont get, the result is thrown away, as only the second argument is returned
08:29:43 <Deewiant> So do 'let x = ... in x `seq` f x', for instance.
08:32:19 <Botje> or f $! x
08:32:23 <Botje> which is the same but shorter :)
08:32:54 <BrokenClockwork> heh :)
08:35:04 <ziman> @src ($!)
08:35:04 <lambdabot> f $! x = x `seq` f x
08:44:22 <skorpan> hi.  completely off-topic: an o'reilly book states that javascript is an untyped language.  i don't find this entirely true though, since there is e.g. the "typeof" in the language.  i'd argue that it is typed, but dynamically so.  does this make any sense?
08:44:46 <Abica> It's typeless.
08:44:51 <NameAlreadyInUse> maybe ask javascript
08:44:57 <NameAlreadyInUse> i mean the channel
08:45:03 <Abica> typeof basically gives you the object that it is.
08:45:13 <skorpan> NameAlreadyInUse: i would, but i've found that they are generally clueless.
08:45:18 <MyCatVerbs> skorpan: it's strongly typed in the sense that you can't (modulo bugs) cause the interpreter to segfault by passing the wrong type of operand to any primitive.
08:45:53 <NameAlreadyInUse> skorpan: oh, fair enough
08:46:27 <MyCatVerbs> skorpan: but, at compile time, there is no typing whatsoever. There is no way to encode compile-time constraints in javascript's type system, like you can in languages like Haskell (and to a lesser extent, Java and friends).
08:46:50 <MyCatVerbs> skorpan: AIUI, the most correct term for this is "strong, dynamic typing".
08:46:51 <NameAlreadyInUse> i think it would be quite a thing to have an untyped higher level language
08:46:51 <Saizan_> many claim that types are only static, and what it's generally called dynamic typing is a fundamentally different thing
08:47:02 <skorpan> you're saying that you can't make it segfault, but what if i try to divide a string by an integer?
08:47:02 <MyCatVerbs> Saizan_: yes, but they are wrong. :)
08:47:44 <Abica> It will let you if the string is a number.
08:47:49 <MyCatVerbs> skorpan: then you will get an error at run-time, not at compile-time, and the error you get is well-defined, and you can recover from it.
08:47:59 <NameAlreadyInUse> you will get NaN
08:48:06 <Saizan_> MyCatVerbs: well, they are indeed quite different, dynamic types are just automatic assertions
08:48:16 <Abica> Nah it would divide.
08:48:32 <skorpan> i see...  so all in all, it is *not* untyped.  right?
08:48:37 <Abica> >>> "34"/3 //=> 11.333333333333334
08:48:38 <MyCatVerbs> skorpan: contrast weakly-typed languages, like C, where you could potentially do that anyway and just get garbage.
08:48:55 <skorpan> but javascript is weakly typed as well
08:49:09 <MyCatVerbs> skorpan: mmhmm. Values carry their types around, but variables, parameters, etc, don't.
08:49:14 <Abica> You would only get NaN if the string can't be coerced into a float.
08:49:25 <skorpan> Abica: "hello" / 2 then
08:49:26 <NameAlreadyInUse> oh, true
08:49:32 <Abica> See above.
08:49:32 <MyCatVerbs> skorpan: no it isn't. What happens when you try something invalid is well-defined.
08:49:40 <Abica> In that case you would get NaN.
08:50:00 <MyCatVerbs> skorpan: contrast, say, C, where misinterpreting the type of a pointer will lead to undefined behavoir - garbage or a segfault or whatever.
08:50:15 <Trafalgard> > "hello / 2
08:50:16 <lambdabot>   <no location info>:
08:50:16 <lambdabot>      lexical error in string/character literal at chara...
08:50:21 <Trafalgard> Fun!
08:50:25 <skorpan> MyCatVerbs: but i thought "var x = 5; x = 'hi';" makes it weakly typed?
08:50:29 <Saizan_> > "hello" / 2
08:50:30 <lambdabot>       No instance for (Fractional [Char])
08:50:30 <lambdabot>        arising from a use of `/' at...
08:50:41 <MyCatVerbs> skorpan: no. It just means that *variables* (such as x) have no types.
08:50:50 <Trafalgard> Oh, I missed the closing " didn't I
08:51:03 <MyCatVerbs> skorpan: the *values* (such as 5 and 'hi') both have properly checked types, however.
08:51:29 <Abica> Javascript is a prototype based language, objects are technically of the type of the objects they clone.
08:51:31 * Trafalgard would've caught that in an IDE
08:51:39 <skorpan> MyCatVerbs: peculiar...  so one (almost official) source tells me javascript is untyped, which it obviously isn't, and wikipedia (which of course i shouldn't rely that much on) says it's weakly typed, which it also isn't
08:52:01 <MyCatVerbs> skorpan: also, people disagree about the meanings of these terms sometimes. But that's okay, because they are all wrong, except me. :)
08:52:17 <Trafalgard> It might be fishily typed.
08:52:21 <NameAlreadyInUse> skorpan: sometimes people say "weakly typed" to refer to two different things
08:52:30 <vixey> skorpan: Haskell is weakly typed too,
08:52:38 <vixey> skorpan: see e.g. unsafeCoerce
08:52:41 <skorpan> this means that the introduction for my thesis will be quite ... prone for discussion.
08:52:41 <MyCatVerbs> vixey: yes, but we lie about it.
08:52:59 <MyCatVerbs> vixey: loudly and vehemently, even.
08:53:16 <byorgey> UNSAFECOERCE DOES NOT EXIST HOW DARE YOU
08:53:16 <lambdabot> byorgey: You have 1 new message. '/msg lambdabot @messages' to read it.
08:53:34 * MyCatVerbs makes a note to buy byorgey a cookie.
08:53:55 * byorgey makes a note to eat it
08:54:17 <NameAlreadyInUse> vixey: but might you as well say that it isn't purely function, either?
08:54:32 <vixey> woo! http://www.galois.com/blog/2009/03/18/solving-sudoku-using-cryptol/
08:54:32 <MyCatVerbs> NameAlreadyInUse: ah, no, that it is.
08:54:34 <vixey> this is cool
08:54:52 <vixey> everyone probably saw it already except me
08:55:04 <NameAlreadyInUse> what about unsafePerformIO?
08:55:04 <vixey> as much as I hate sudoku that is clever
08:55:17 <MyCatVerbs> NameAlreadyInUse: IO actions are constructed in a purely functional manner, as a term algebra on (wrappers around) primitive functions, bound together with (>>=).
08:55:28 <vixey> NameAlreadyInUse: oh and we have got nontermination .. yeah it's just a big grey mush
08:55:31 <eden_> vixey: I've got the position (which is easy using the getPosition action), and can even construct a new error message, but without the parserFail function can't cause the parser to fail immediately. I guess I do some post processing and return it then.
08:55:32 <MyCatVerbs> NameAlreadyInUse: oh yeah, that too. But we lie, loudly and vehemently, about unsafePerformIO also.
08:55:53 <vixey> eden_: it makes sense as a post process to me yeah
08:56:03 <NameAlreadyInUse> are there situations where unsafePerformIO might be necessary?
08:56:15 <skorpan> MyCatVerbs: so basically you're saying that weakly typed languages are type safe?
08:56:40 <vixey> NameAlreadyInUse: necessary for what?
08:56:56 <MyCatVerbs> skorpan: no. I define "weakly typed" as "you can cause undefined behavoir by committing a type error".
08:57:24 <NameAlreadyInUse> vixey: i am not sure, for performing some task that can't be accomplished otherwise
08:57:29 <jrx> hi everyone. Is there any possibility to make computations in State monad lazy enough, that I can have computation returning infinite list, and after running it just take some front part of the list, discarding the state value (because it's never going to be computed actually)
08:57:35 <MyCatVerbs> skorpan: in javascript, you cannot do that. In Haskell, you cannot do that unless you use some things that are marked explicitly as "unsafe" and which it is politely assumed you will never, ever touch without knowing what you are doing.
08:57:42 <eden_> It does mean that a later genuine parse error gets caught before then.
08:57:51 <vixey> NameAlreadyInUse: If you can make the statement more formal or clearer ..
08:58:01 <vixey> NameAlreadyInUse: If not I would say, no -- there's nothing
08:58:21 <MyCatVerbs> skorpan: whereas in C, casting a pointer to the wrong type will cause completely undefined behavoir. Daemons are allowed to fly out of your noise, according to the spec. And they often do, in practice.
08:58:28 <seliopou> Can we talk about nomenclature? safe vs. unsafe; static vs. dynamic
08:58:35 <seliopou> those are the terms that make sense to me
08:58:49 * MyCatVerbs pokes seliopou.
08:58:56 <seliopou> Yeah?
08:59:02 <seliopou>  Where's the trout?
08:59:14 <MyCatVerbs> I define "weak" and "strong" as "unsafe" and "safe", respectively. Probably your terms are better, because people have less stupid and wrong notions of what they mean.
08:59:47 <seliopou> I thought people meant something differnt by weak though
08:59:54 * vixey goes with  typed vs untyped  &  strong vs weak
08:59:57 <seliopou> like safe-with-coercion
09:00:10 <seliopou> what's strong vs. weak?
09:01:04 <MyCatVerbs> seliopou: I usually define languages with coercion as "die die die DIE DIE DIE DIEEEEE!". :/
09:01:09 <vixey> C is weak, Lisp and Haskell without unsafe* are strong
09:01:28 <mun_> is there an ide for haskell such that you can jump between imported functions, etc.? much like eclipse for java?
09:01:31 <daf> weakness == coersion?
09:01:36 <vixey> daf no
09:01:50 <daf> your definition by example does not help me
09:01:55 <Abica> weak languages don't enforce typings and strong languages do
09:01:56 <seliopou> vixey, that's type safety you're talking about
09:02:00 <daf> unless weak == bad, and strong == good
09:02:05 <seliopou> why not just call it that/
09:02:18 <vixey> seliopou: call what ? what?
09:02:32 <vixey> I am talking about type safety.. that's true
09:02:54 <seliopou> your notion strong vs. weak, as far as I can tell, is the same as type safe vs. not
09:03:13 <seliopou> is that accurate?
09:03:21 <vixey> I don't know what "type safe" means
09:03:49 <seliopou> It means your primitives can only act on types that they were meant to
09:03:55 <seliopou> ... act on
09:03:57 <Abica> It means an error is raised if you use an incorrect type
09:04:13 <vixey> Abica: when?
09:04:22 <vixey> that could happen at compile or runtime
09:04:23 <Abica> could be at compile time, could be at runtime
09:04:26 <Abica> depends on the language
09:04:27 <seliopou> vixey, that's the distinction between static and dynamic
09:04:38 <Abica> dynamic usually means runtime
09:05:24 <mun_> is there an ide for haskell such that you can jump between imported functions, etc.? much like eclipse for java?
09:05:40 <Abica> surely there's an eclipse plugin for haskell
09:05:53 <seliopou> For the sake of being pedantic, what I meant by "act on types" I mean "act on values of types"
09:06:54 <seliopou> And by primitives, I mean constructors and destructors where, for example 1 is a constructor for Int and (+) is a destructor for Int
09:07:06 <Mr_Giraffe> mun_: this has been asked before and no, there is not
09:07:25 <vixey> seliopou: so instead of "typed vs untyped  &  strong vs weak", "static vs dynamic  &  strong vs weak"
09:07:45 <vixey> ?
09:07:51 <mun_> Mr_Giraffe, ok thanks
09:07:54 <Mr_Giraffe> mun_: haskell is somewhat different from java in that it's not nearly as verbose and there isn't an object-oriented aspect to it
09:08:05 <Mr_Giraffe> mun_: did you get what i said?
09:08:10 <seliopou> vixey, nope. static vs. dynamic, type-safe vs. not type-safe
09:08:11 <seliopou> imo
09:08:17 <Mr_Giraffe> mun_: haskell is somewhat different from java in that it's not nearly as verbose and there isn't an object-oriented aspect to it
09:08:18 <Abica> vixey: not all static languages are typed
09:08:23 <Abica> and not all dynamic are untyped
09:08:38 <mun_> Mr_Giraffe, right. but what is a good editor for haskell?
09:08:44 <mun_> Mr_Giraffe, just emacs?
09:08:47 <seliopou> Abica, you mean type safe, yes?
09:08:52 <Mr_Giraffe> mun_: for example, if you have something like Data foo = ... and you have a function of type Foo -> Bar
09:09:00 <Mr_Giraffe> *Data Foo
09:09:04 <Abica> seliopou: yep
09:09:14 <Saizan_> i'd say that those terms have been misused so much that they're almost meaningless :)
09:09:15 <Mr_Giraffe> you couldn't do something like f = Foo ... and then f.someFunc
09:09:29 <vixey> Abica: so you are saying that  static and typed aren't synonymous,   and   dynamic and untyped aren't synonymous
09:09:33 <Mr_Giraffe> mun_: i prefer vim myself, but emacs works just as well for most purposes
09:09:44 <Abica> vixey: correct
09:09:49 <vixey> Abica: but what is the difference? I consider something a type only if it exists at compile time but not runtime
09:09:59 <seliopou> in fact, most dynamic languages are type safe
09:10:16 <mun_> Mr_Giraffe, ok thanks
09:10:24 <Mr_Giraffe> mun_: what exactly are you trying to do?
09:10:47 <pejo> vixey, how do systems without type-erasure come into that picture?
09:10:56 <Mr_Giraffe> mun_: i'm sure there's a way to cleanly do it, but haskell is not quite built for auto-completion like java is
09:10:56 <roconnor> I don't think throwing a run-time exception counts as type safe.
09:10:59 * Deewiant throws http://www.pphsg.org/cdsmith/types.html into the mix at this point
09:11:15 <vixey> pejo: I mean in theory you could erase all types -- whatever implementation you use isn't important
09:11:38 <mun_> Mr_Giraffe, I basically want to browse the source of a very large library. right now, i open each file in a separate window, but i can't tell where the functions originate from.
09:11:46 <seliopou> roconnor, what do you consider type safety?
09:12:00 <Mr_Giraffe> mun_: right...hmm
09:12:17 <mun_> Mr_Giraffe, i'm not quite after autocompletion, but just pointers for functions to the destination
09:12:31 <Mr_Giraffe> see, the issue with autocompletion in haskell is that with java you have objects performing methods, correct?
09:12:51 <Mr_Giraffe> with haskell you have functions that consume data--it's sort of inside out
09:12:52 <Mr_Giraffe> oh!
09:12:56 <mun_> Mr_Giraffe, yes. but i'm not quite after autocompletion or refactorying
09:13:04 <mun_> *refactoring
09:13:06 <Mr_Giraffe> mun_: if you want something quick you can run ghci and just do :i someFunc after loading
09:13:11 <Mr_Giraffe> loading a module, i mean
09:13:18 <Mr_Giraffe> i wonder if that works in here...
09:13:21 <Mr_Giraffe> :i map
09:13:27 <Mr_Giraffe> no :(
09:13:40 <Mr_Giraffe> well here's an example:
09:13:42 <Mr_Giraffe> Prelude> :i map
09:13:42 <Mr_Giraffe> map :: (a -> b) -> [a] -> [b] 	-- Defined in GHC.Base
09:13:57 <roconnor> seliopou: compile-time guarentees that there will be "no exceptions" (some restrictions may apply)
09:14:21 <Mr_Giraffe> mun_: it might not be ideal, but at the very least that'll give you what you need
09:14:49 <Mr_Giraffe> so you can know when you need to load HugeModule.SmallModuleA and HugeModule.SmallModuleB instead of HugeModule
09:15:29 <gbacon> ?pl \a b c -> (a, b, c)
09:15:29 <lambdabot> (,,)
09:15:29 <mun_> Mr_Giraffe, yeah, i'll try using that instead then
09:15:39 <Mr_Giraffe> alright
09:15:43 <gbacon> ?pl \a (b,c) -> (a, b, c)
09:15:43 <lambdabot> (`ap` snd) . (. fst) . (,,)
09:16:22 <mun_> Mr_Giraffe, thanks for that
09:16:27 <seliopou> roconnor, so what you mean by "no exceptions" is "no exceptions caused by types"
09:16:29 <seliopou> correct?
09:16:45 <Abica> vixey: that depends on whether you mean static or statically typed
09:17:33 <roconnor> seliopou: let me phrase it in a better way
09:19:04 <ozy`> seliopou: with a stronger type system than haskell's, you could even guarantee that there would be literally no exceptions whatsoever
09:19:24 <ozy`> haskell does a pretty good job of it though, for what it's worth
09:19:39 <Mr_Giraffe> mun_: no problem
09:19:55 <roconnor> seliopou: type safe means an expression of a given type is guarenteed to evaluate to a value of that type when evaluated on an ideal machine.
09:22:46 <roconnor> ah Pierce's quote
09:22:49 <roconnor> ``A type system is a tractable syntactic method for proving the absence of certain program behaviors by classifying phrases according to the kinds of values they compute.
09:23:48 <McManiaC> can u think of map as the fmap version for lists? ^^
09:23:54 <McManiaC> or is there any big differences?
09:24:04 <daf> map == fmap for lists
09:24:08 <McManiaC> ok
09:24:09 <daf> map used to be fmap
09:24:17 <daf> but it was renamed to fmap to avoid scaring people
09:24:23 <McManiaC> and liftM is the fmap for monads?
09:24:30 <Abica> roconnor: about things like void *?
09:24:34 <daf> no, liftM is the liftM for monads
09:24:48 <daf> I think the typeclassopedia explains this well
09:25:05 <Mr_Giraffe> @src map
09:25:05 <lambdabot> map _ []     = []
09:25:05 <lambdabot> map f (x:xs) = f x : map f xs
09:25:18 <daf> @src [] fmap
09:25:18 <lambdabot> fmap = map
09:25:21 <beelsebob> McManiaC: liftM is the "this shouldn't be here at all function"
09:25:30 <beelsebob> all monads are functors
09:25:33 <beelsebob> and can just use fmap
09:25:38 <McManiaC> really?
09:25:42 <beelsebob> yes
09:25:43 <McManiaC> wow
09:25:46 <McManiaC> okay
09:25:48 <daf> @src Monad fmap
09:25:48 <lambdabot> Source not found. Wrong!  You cheating scum!
09:25:56 <jmcarthur> all Monads _should_ be Functors
09:26:07 <Gracenotes> you can make WrappedMonad a functor
09:26:07 <daf> ah yes
09:26:12 <beelsebob> jmcarthur: no, all monads *are* functors, the implementation just may not be there
09:26:16 <daf> but they aren't for historical reasons
09:26:20 <beelsebob> an implementation is easy to add though
09:26:26 <jmcarthur> beekor, the capitalization was important there ;)
09:26:39 <McManiaC> so you can "actually" forget about liftM and map and always use fmap? ^^
09:26:50 <jmcarthur> beelsebob, ^
09:26:54 <jmcarthur> sorry beekor
09:27:12 <daf> McManiaC: only if the author of the monad you're using was sensible enough to make a Functor instance
09:27:35 <McManiaC> ok
09:27:37 <beelsebob> McManiaC: you can easily add the functor instance...
09:27:39 <McManiaC> thats why i put it in ""
09:27:40 <McManiaC> :)
09:27:46 <beelsebob> instance Functor <thingy> where fmap = liftM
09:27:50 <beelsebob> done
09:27:57 <McManiaC> cool =)
09:27:59 <jmcarthur> assuming you don't mind orphans or wrappers
09:28:05 <beelsebob> similarly instance Applicative <thingy> where pure = return; (<*>) = ap
09:28:07 <daf> @src Functor []
09:28:07 <lambdabot> Source not found. My pet ferret can type better than you!
09:28:11 <daf> @src fmap []
09:28:11 <lambdabot> Source not found. My pet ferret can type better than you!
09:28:16 <daf> @src [] Functor
09:28:17 <lambdabot> Source not found. Do you think like you type?
09:28:20 <Gracenotes> , src ''WrappedMonad
09:28:20 <daf> @src [] fmap
09:28:20 <lambdabot> fmap = map
09:28:24 <iago_> there are plans to fix it?
09:28:24 <lunabot>  newtype WrappedMonad m a = WrapMonad {unwrapMonad :: (m a)}
09:28:26 <daf> @src Maybe fmap
09:28:26 <lambdabot> fmap _ Nothing       = Nothing
09:28:26 <lambdabot> fmap f (Just a)      = Just (f a)
09:28:34 <Gracenotes> FUNCTOR FLOOD
09:28:48 <daf> hmm, I wonder why Maybe special cases it
09:28:53 <jmcarthur> functor functor functor functor functor functor functor functor MOOONAAAD MOOOONAAAD
09:28:57 <daf> is there some non-strictness advantage or something?
09:29:14 <Gracenotes> what else is Maybe going to use?
09:29:35 <Gracenotes> it has a case for Nothing and a case for Just :) it does this with pattern matching
09:29:45 <jmcarthur> @djinn (a -> b) -> Maybe a -> Maybe b
09:29:46 <lambdabot> f a b =
09:29:46 <lambdabot>     case b of
09:29:46 <lambdabot>     Nothing -> Nothing
09:29:46 <lambdabot>     Just c -> Just (a c)
09:30:34 <temoto> :t pmap
09:30:35 <lambdabot> Not in scope: `pmap'
09:30:47 <temoto> What is pmap?
09:30:59 <jmcarthur> @hoogle pmap
09:30:59 <lambdabot> No results found
09:31:05 <temoto> hm
09:31:06 <jmcarthur> no idea :)
09:31:14 <jmcarthur> where did you find it?
09:31:21 <temoto> i'm sure i've seen pmap in this chan logs
09:31:28 <daf> Gracenotes: oh, right, i was thinking backwards
09:31:39 <temoto> how do you paralelize jobs to different cores?
09:32:05 <daf> are you thinking of parMap?
09:32:13 <jmcarthur> :t parMap
09:32:14 <lambdabot> forall b a. Strategy b -> (a -> b) -> [a] -> [b]
09:33:37 <temoto> aw.. how nice
09:33:48 <temoto> it doesn't involve monads?
09:33:59 <jmcarthur> should it?
09:34:05 <dancor> @pl \ x -> f <$> gIO x
09:34:05 <lambdabot> (f <$>) . gIO
09:34:42 <temoto> I'm just surprised how they made it pure.
09:34:43 * jmcarthur find (fmap f . gIO) more readable when composing like that
09:34:46 <vixey> @free not :: Bool -> Bool
09:34:46 <lambdabot> not = not
09:34:46 <temoto> great
09:34:53 <dancor> jmcarthur: ah
09:35:02 <vixey> @free and :: (Bool -> Bool) -> Bool
09:35:02 <lambdabot> and = and
09:35:02 <jmcarthur> :t par -- for temoto
09:35:03 <lambdabot> forall a b. a -> b -> b
09:35:15 <vixey> @free and :: Bool -> (Bool -> Bool)
09:35:15 <lambdabot> and = and
09:35:20 <roconnor> vixey: free theorems are not very exciting for non-polymorphic types
09:35:29 <vixey> roconnor: yes :(
09:35:43 <jmcarthur> temoto, par sparks the first argument and returns the second
09:35:44 <vixey> roconnor: I was thinking it might be easier to consider a restriction to simple typed lambda calculus at first
09:35:51 <jmcarthur> temoto, parMap uses it
09:35:51 <vixey> but.. it just becomes trivial then
09:35:59 <temoto> jmcarthur: sorry, "sparks"?
09:36:10 <Saizan_> is it hard to write proofs about graphs in agda/coq ?
09:36:16 <jmcarthur> temoto, queues the computation into the thread pool
09:36:25 <ozy`> temoto: since the entire lifetime of the thread is encapsulated under the hood by a special primitive, it gets counted as a pure operation
09:36:34 <roconnor> Saizan_: no harder than anything else
09:36:56 <jmcarthur> temoto, it's pure because it is referentially transparent
09:36:58 <ozy`> temoto: if you want to dispatch a thread that can perform IO and communicate with other threads, -then- you have to use IO functions
09:37:12 <temoto> I see.
09:37:18 <temoto> It's just wonderful.
09:37:24 <jmcarthur> temoto, it is :)
09:37:53 <temoto> Of all i know only Erlang can compare to such simple SMP.
09:38:01 <jmcarthur> dons has a neat blog post showing it off to parallelize a naive fibonacci algorithm that you may find instructive
09:40:23 <jmcarthur> temoto, http://donsbot.wordpress.com/2007/11/29/use-those-extra-cores-and-beat-c-today-parallel-haskell-redux/
09:47:41 <temoto> jmcarthur: thank you.
09:54:25 <ozy`> @index forM_
09:54:25 <lambdabot> bzzt
10:03:46 <quicksilver> ozy`: Control.Monad
10:03:52 <quicksilver> I don't know why lambdabot didn't find it
10:03:53 <quicksilver> odd.
10:03:58 <quicksilver> @hoogle forM_
10:03:59 <lambdabot> Control.Monad forM_ :: Monad m => [a] -> (a -> m b) -> m ()
10:03:59 <lambdabot> Data.Foldable forM_ :: (Foldable t, Monad m) => t a -> (a -> m b) -> m ()
10:04:12 <dons> those who didn't see it yet: we now have Language.Python : http://www.reddit.com/r/programming/comments/85y4j/just_released_languagepython_parse_and_analyse/
10:05:26 <Nafai> dons: Awesome, thanks!
10:06:05 <Nafai> Darn only Python 3 right now
10:07:26 <ImInYourMonad> can someone give an example of something that is commutative but not associative=
10:07:32 <ImInYourMonad> ?
10:07:59 <ozy`> dons: presumably for the purpose of converting python programs to haskell? :p
10:08:35 <dons> let's hope
10:08:35 <ksf> gnnnnnnnnnnnnnaaargh
10:09:07 <seliopou> roconnor, (I'm back from lunch), two things
10:09:41 <seliopou> 1. your definition of soundness omits something very important, and that's _if_ the expression reduces to a value
10:09:43 <ksf> I've just made my iteratee code work and discovered that I have to hack up literally all of the library to get relative seeks. currently, it only does absolute ones.
10:10:02 <seliopou> 2. the pierce quote describes a type system. that's a whole different debate
10:10:29 <roconnor> seliopou: yes ... one remedy is to take a suitably broad definition of value
10:10:40 <lilac> dons: nice! next trick: a python compiler!
10:10:48 <roconnor> I agree about 2.  I just thought it was a nice quote
10:11:07 <ImInYourMonad> can someone give an example of something that is commutative but not associative?
10:11:38 <roconnor> seliopou: granted, taking a suitably broad definition of value also might include run-time exceptions.
10:11:40 <seliopou> So th idea that the use of an exception is unacceptable in ensuring safety, I'd say, has no basis the definition of soundness
10:11:56 <seliopou> ok, I think we agree (?)
10:12:09 <Nafai> dons: Actually, I might use this to generate Python programs :)
10:12:48 <roconnor> seliopou: possibly.
10:12:50 <ImInYourMonad> was SPJ one of the invntors of haskell?
10:13:07 <seliopou> let's run with it
10:13:38 <seliopou> then, my claim is that safety can be attributed to a language without a static type system
10:13:56 <dons> well vote up the article if you think it is good, so the pythonistas see it
10:14:36 <seliopou> And if you really want a static type system, I can just have a type system that says Ok! for expression it gets, and then checks at runtime that the types are correct at the application of primitives, throwing exceptions if they're not
10:14:37 <roconnor> seliopou: ya, perhaps you are right.
10:14:45 <lilac> > let a ** b = a * b + 1 in (2 ** (3 ** 5), (2 ** 3) ** 5) -- ImInYourMonad
10:14:46 <lambdabot>   (33,36)
10:14:46 <ksf> Wasn't haskell discovered on the bottom of a whiskey instead of invented?
10:15:17 <skorpan> OT: is there any way of saying "thanks to X, ..." but a bit negatively? "due to X" isn't quite negative, is it?
10:15:21 <roconnor> seliopou: well, when we talk about static type systems, we usually mean non-trivial static type systems
10:15:24 <roconnor> it goes without saying
10:15:33 <seliopou> sure
10:15:52 <lilac> skorpan: 'sadly, due to X' :)
10:16:09 <vixey> skorpan: "thanks to X" works
10:16:18 <lilac> skorpan: or 'as a result of X's embarrassing mismanagement of this situation, ...'
10:16:19 <vixey> if you say it sarcastically
10:16:24 <seliopou> the system above certainly doesn't "prove the absence of errors" as pierce would say, unless you consider the checking of the primitive applications as part of the type system
10:16:38 <roconnor> that is not part of the type system
10:17:02 <skorpan> i'm trying to write "thanks to (or maybe i should say <something>), ..."
10:17:13 <seliopou> In some cases it could be
10:17:15 <vixey> thanks to (or maybe i should say no thanks to),
10:17:35 <skorpan> HEH
10:17:37 <skorpan> -caps
10:17:55 <ksf> "thanks to (or less sarcastically, due to), ..."
10:18:14 <seliopou> in soft typing, if you can prove that a certain primitive application won't cause errors, you'd emit a program that doesn't use a checked primitive. Whereas if you can't, you'd emit a program that uses a checked primitive
10:18:32 <seliopou> And put there to ensure soundness for the type system
10:18:44 <skorpan> i'll just go for "due to, ..." :P
10:18:46 <seliopou> *And the check is put there...
10:18:53 <skorpan> no need to be a smart-ass
10:19:11 <seliopou> where the type system is unable to determine safety statically
10:23:03 <roconnor> maybe I should argue that haskell's type system is unsound instead. :P
10:25:03 <ImInYourMonad> if you make a proof of something and use a conjecture on the wya, then it is still a proof right?
10:25:49 <lament> ImInYourMonad: then the conjecture is a proof too
10:26:03 <lament> Theorem: Conjecture. Proof: Assume conjecture. Therefore, conjecture. QED
10:26:49 <sm> morning all. Is ?: (ignore this group) not supported in regex-posix ? how could this be ?
10:27:09 <Botje> ?: is a perl extension
10:27:09 <lambdabot> Maybe you meant: . ? @ v
10:27:27 <sm> Botje: are you sure ?
10:28:19 <ksf> about everything you usually use in regexen is a perl extension
10:28:32 <Botje> sm: the grep man page doesn't mention it, neither does sed's
10:28:34 <sm> ack
10:28:38 <stone_> ImInYourMonad: only if you prove the conjecture, or if the conjecture is known to be true
10:28:44 <sm> nor does http://en.wikipedia.org/wiki/Regular_expression#POSIX .. thanks
10:29:11 <quicksilver> sm: there is a pcre regexp package though
10:29:14 <quicksilver> sm: you can try that one
10:29:25 <sm> will do, thank you
10:29:29 <seliopou> roconnor, why would you do that? Don't do that. :P
10:30:10 <roconnor> seliopou: Coq and maybe Adga have the properties I want. :)
10:30:32 <seliopou> But you can't write programs in Coq, just algorithms
10:31:32 <roconnor> I don't think there is an essential difference between the two
10:31:42 <sm> why doesn't Text.Regex.PCRE provide the usual mkRegex api ?
10:31:42 <vixey> seliopou: You can use a monada
10:31:52 <vixey> e.g. IO Monad
10:31:54 <seliopou> algorithms terminate
10:32:03 <dons> try pcre-light
10:32:04 <ksf> prolly because it's a ffi library
10:32:08 <vixey> algorithms don't have to terminate imo
10:32:16 <seliopou> o_O
10:32:16 <vixey> you can have partially correct things
10:32:24 <Eelis> and you can have corecursive algorithms
10:32:29 <iago_> vixey, algorithms have to terminate, no?
10:32:30 <iago_> by definition
10:32:36 <seliopou> yes, by definition
10:32:45 <vixey> I use a different definition
10:32:47 <sm> dons: that one doesn't either, as far as I can tell from haddock
10:32:47 <jmcarthur> what about an algorithm that results in an infinite list?
10:32:50 <roconnor> seliopou: a formal IO type in Coq/Adga would probably be a co-inductive structure
10:32:50 <ksf> you don't have to prove them in agda, it'd accept your guesses.
10:33:06 <ksf> but then, without a proof your in non-terminating typechecking lala-land, again.
10:33:13 <roconnor> seliopou: and hence, it wouldn't necessarily terminate when executed by the run-time system.
10:33:20 <iago_> vixey, it's better use standard definitions
10:33:28 <iago_> to avoid confuse
10:34:35 <seliopou> jmcarthur, I'd call that a program
10:34:54 <ksf> otoh, you don't need agda to have non-terminating typechecking, haskell can do that, too.
10:34:56 <gbacon> ?hoogle comparing
10:34:56 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
10:34:56 <lambdabot> Distribution.Simple.Utils comparing :: Ord a => (b -> a) -> b -> b -> Ordering
10:34:58 <jmcarthur> then you can make programs in coq
10:35:25 <seliopou> roconnor, perhaps I should read up on these coinductive structures
10:35:28 <seliopou> got a reference?
10:35:31 <roconnor> hmm
10:35:51 <sm> I can't figure out which is a more twisty maze, regex libs or time libs
10:35:53 <roconnor> then again, Coq doesn't have subject reduction, so maybe it isn't sound either.
10:36:03 <roconnor> stupid coinductive types.
10:36:32 <jmcarthur> coinductive types do still feel a bit ad hoc to me
10:36:37 <vixey> seliopou: there is a good note about coinductives,
10:36:49 <jmcarthur> especially the productivity rules that are usually associated with it
10:37:15 <seliopou> Found this: http://portal.acm.org/citation.cfm?id=232640
10:37:24 <seliopou> damn you ACM!
10:37:40 <jkff> seliopou: I can download that for you
10:37:55 <seliopou> found it on google scholar, thanks though!
10:38:03 <jmcarthur> google scholar rocks
10:38:17 <quicksilver> google copyright violator ^W^W scholar to the rescue :)
10:38:25 <ImInYourMonad> well is it an axiom then?
10:38:30 <jkff> Yeah. The only thing that really sucks is springerlink :-/
10:38:34 <Saizan_> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.37.1418
10:38:53 <quicksilver> ImInYourMonad: sure, if you take it as an axiom then your proof is a proof.
10:39:05 <quicksilver> proofs are relative to formal systems (which includes the axiom sets)
10:39:30 <pejo> quicksilver, I think acm allows the author to have a copy on their homepage, that isn't for commercial use etc.
10:40:13 <lilac> truth is relative, absolute truth is doubly so
10:40:47 <dancor> i don't get why ppl continue to publish in proprietary journals
10:40:59 <seliopou> dancor, street cred
10:41:19 <pejo> dancor, because their career depends on it.
10:41:39 <stone_> ImInYourMonad: false implies everything, so as long as the conjecture is true the proof holds
10:41:46 <seliopou> I had a prof that wanted to publish his book on PL, and he debates for literally years on whether to go with MIT Press or whatever, or continue to make it available for free online
10:42:22 <seliopou> he felt a lot of pressure to publish it "legitimately" to help his career, but in the end he chose the path of righteousness
10:42:38 <dancor> nice
10:42:40 <vixey> is it a good book ? :)
10:42:45 <seliopou> I like it
10:42:48 <seliopou> PLAI
10:42:51 <vixey> oh right PLAI
10:44:07 * p_l would do both... the smell of freshly-printed book is great
10:44:22 <vininim> PLAI?
10:44:26 <seliopou> p_l: I agree with that sentiment
10:44:41 <seliopou> http://www.cs.brown.edu/~sk/Publications/Books/ProgLangs/
10:44:45 <dancor> i don't think propriojournals pay their referees so i think in theory you could get just as much cred from a sufficiently hard-ass opensourcejournal
10:45:29 <rolly1975> whats PLAI
10:45:32 <jeltsch> Hello, any Gtk2Hs expert around?
10:45:34 <seliopou> vininim, that link was for you ^
10:45:35 <pejo> dancor, but in practice you get a lot more cred for publishing in Nature or Science.
10:45:39 <dancor> rolly1975: http://www.google.com/search?q=PLAI
10:45:41 <seliopou> rolly1975, my link above
10:45:48 <rolly1975> ah, thanks
10:46:48 <p_l> dancor: the one I did some work for (not as author, no, a HS kid doesn't write in journals) actually _tried_ paying authors
10:47:09 <ksf> so maybe it's time for a guaranteed hard-ass version of the monad reader?
10:47:28 <dancor> pejo: yeah.  maybe later when opensource journal collections have been around longer a hardest-to-get-into one will emerge
10:48:09 <p_l> some of the newer "classical" journals seem to have interesting acceptance policies
10:48:50 <p_l> like "you have to check, finish, peer-review etc. a wikipedia article related to the discipline" (or to the subject you just wrote about, I'm not sure)
10:49:09 <dancor> pyramid scheme
10:49:44 <p_l> lol
10:49:48 <seliopou> dancor, please, ponzi scheme is a little more current :P
10:49:59 <dancor> i know, i thought that right after i said it
10:50:01 <c_wraith> shouldn't we be calling them Madoff schemes now?
10:50:22 <p_l> still, that forces an actuall scientist to spend some time improving wikipedia content, which I find a good thing :)
10:50:27 <p_l> *actual
10:50:28 <dancor> it's cooler to use ppl's names instead of descriptive terms
10:50:39 <vininim> seliopou: dlded it :)
10:53:54 <BMeph_> seliopou: Got it in my Google Docs collection. ;)
10:54:05 <ImInYourMonad> jeltsch: no not really but i might be able to help
11:11:39 * byorgey cooks spicy lambda sausages
11:11:59 <lilac> byorgey: making a curry?
11:12:10 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2612#a2612 <- i didnt expect that to work, but what should I do?
11:12:23 <ImInYourMonad> it is for extracting haskell code from Coq
11:12:37 <SingInTime> hello everybody
11:12:45 <byorgey> lilac: I've never seen sausage in curry before, but I guess that could work =)
11:12:53 <byorgey> hi there SingInTime
11:13:33 <SingInTime> I'm completely new to here... actually completely new to functional programming also :)
11:13:43 <byorgey> SingInTime: welcome!
11:13:49 <SingInTime> just started a course in my university :)
11:13:50 * byorgey hands SingInTime a golden lambda
11:14:08 <SingInTime> hahaha thanks byorgey!
11:14:11 <byorgey> SingInTime: are you using Haskell in your course?
11:14:17 <SingInTime> no, ocaml
11:14:22 <byorgey> oh, ok =)
11:14:34 <SingInTime> but there's a reason why I'm here
11:14:44 <Taejo> are IntMaps strict in values?
11:14:46 <dons> we're friendly, helpful and fun?
11:14:49 <dons> Taejo: yeah
11:14:55 <dons> Taejo: oh wait
11:14:59 <SingInTime> sure ;) that's the first
11:15:12 <dons> no
11:15:15 <dons> Taejo: nope
11:15:19 <SingInTime> the second is that i use xmonad and i love it
11:15:25 <dons> cool!
11:15:32 <byorgey> \o/
11:15:40 <abdullah`> Hello everyone
11:15:48 <SingInTime> and the third is that i'm trying to write a program which involves xml parsing
11:15:54 <SingInTime> hello abdullah
11:15:55 <byorgey> hi abdullah`
11:16:12 <abdullah`> Great to learn that haskell was once again selected as part of Gsoc
11:16:17 <SingInTime> but after trying various tools for ocaml
11:16:27 <dons> SingInTime: maybe just grab one of the xml libs off hackage
11:16:30 <ImInYourMonad> hu buorgey!
11:16:30 <ImInYourMonad> hi abduallh'
11:16:32 <ImInYourMonad> hi almdabot
11:16:32 <dons> cabal install haxml , or hxt, or xml
11:16:33 <SingInTime> i gave up
11:16:43 <SingInTime> that's what i'll try to do
11:16:46 <SingInTime> ;)
11:16:48 <dons> the 'xml' lib is a nice place to start
11:16:56 <dons> if it works for you, no need for the bigger things like haxml
11:17:38 <byorgey> SingInTime: what kind of xml are you parsing?  and do you need to also produce xml, or just extract some information?
11:17:48 <SingInTime> just extract
11:17:58 <byorgey> cool, that makes things a lot easier
11:18:06 <SingInTime> it will be a format converter
11:18:16 <SingInTime> anyone interested in computer music here?
11:18:22 <byorgey> and yeah, in that case something like hxt or haxml is probably overkill
11:18:47 <byorgey> SingInTime: I am, actually =)
11:18:54 <SingInTime> cool
11:19:09 <byorgey> I don't know that much though (yet).
11:19:23 <SingInTime> then you'll be probably interested in ieee1599
11:19:29 <SingInTime> also known as MX
11:19:42 <SingInTime> an xml format still nearly unknown
11:20:14 <SingInTime> but that (hopefully) will have some useful applications
11:20:50 <SingInTime> as there aren't any viewers yet, i'm trying to convert mx to lilypond
11:21:00 <byorgey> SingInTime: nice =)
11:21:05 * byorgey <3 lilypond
11:21:41 <SingInTime> and just thought it would be the perfect occasion to learn another language
11:21:49 <SingInTime> possibly a cool one ;)
11:22:32 <SingInTime> @ImInYourMonad: can I ask where you're from?
11:22:32 <lambdabot> Unknown command, try @list
11:25:29 * SingInTime downloading haskell-xml
11:25:57 <quicksilver> wierd. the GHC trac keeps logging me out.
11:27:53 <ImInYourMonad> thats because you didnt answer my question quicksilver. nonloclaity is a bitch.
11:28:23 <ImInYourMonad> SingInTime: where are you from?
11:29:41 <SingInTime> venice
11:29:48 <SingInTime> italy
11:30:04 <quicksilver> ImInYourMonad: your question was too dull. It contained no monkeys.
11:30:29 <quicksilver> I've never used Coq.
11:32:25 * byorgey makes a mental note to preface questions to quicksilver with monkeys
11:33:27 <lilac> > let if' a b c | a = b | not a = c in (fix $ ap (flip if' [] . null) . (`ap` (return . head)) . ((++) .) . (. tail)) "syeknom"
11:33:28 <lambdabot>   "monkeys"
11:33:31 <SingInTime> ImInYourMonad: I asked you because in my local dialect the word "mona" (without the final "d") has got a particular meaning
11:33:32 <lilac> quicksilver: ^^ how does that work?
11:33:49 <lilac> SingInTime: what does mona mean?
11:33:52 * vixey has some syntax.. now what :/
11:34:04 <SingInTime> vagina
11:34:07 <lilac> vixey: semantics!
11:34:15 <vixey> hehe lilac
11:34:16 <lilac> SingInTime: excellent!
11:34:19 <vixey> ok good idea
11:34:39 <SingInTime> so "I'm in your <mona>"... you know...
11:34:45 <ImInYourMonad> hehe
11:34:51 <ehird> SingInTime: Vaginads are essential for programming in Haskell.
11:35:00 <SingInTime> bwahahahahah
11:35:01 <lilac> rofl
11:35:21 <mauke> prepare an april 1 announcement
11:35:21 <lilac> well, we have our new typeclass name
11:35:28 <ehird> mauke: hahahaha
11:35:35 <mauke> "monads officially renamed to vaginads"
11:36:02 <lilac> "feminist haskell programmers worldwide are reported to be pleased"
11:36:11 <wchogg> Crap...where do you put the emphasis on that?
11:36:21 <quicksilver> I have a nasty feeling my phone company's proxy is screwing up the authentication on the GHC trac.
11:36:25 <ehird> lilac: it's empowering
11:36:31 <quicksilver> Bar stewards every one.
11:36:39 <quicksilver> I'll have to make this coment when I get home.
11:37:07 <ImInYourMonad> dear vixey,willst thou extract me some haskell code from Coq?
11:37:10 <lilac> "lambdas renamed to labiadas"
11:38:12 <ksf> hmmm... is there a way to get the current read position from a posix fd?
11:38:28 <ksf> I need to emulate relative seeks with absolute ones.
11:38:34 <lilac> @hoogle hTell
11:38:34 <lambdabot> System.IO hTell :: Handle -> IO Integer
11:38:51 <ksf> that's for handles
11:38:55 <lilac> indeed
11:39:01 <lilac> FFI ftell?
11:39:15 <lilac> hmm, that's for FILE*
11:39:17 * SingInTime tries to parse some xml with his new toy :)
11:39:24 <mauke> ksf: huh?
11:39:39 <mauke> cur = lseek(fd, 0, SEEK_CUR)
11:40:02 <ksf> ouch! argh! the pain!
11:40:24 <quicksilver> ksf: why are you using fds and not Handles?
11:40:28 <quicksilver> (out of interestes)
11:40:37 <ksf> 'cos i'm using john lato's iteratees.
11:41:22 <quicksilver> I wonder why he does that.
11:41:52 <ksf> manual buffer handling.
11:41:53 <shapr> Whoa, was that top?
11:42:01 <shapr> TopMind?
11:42:10 <vixey> topcoder
11:42:50 <shapr> Just wondering if that's the notorious person known as TopMind.
11:44:44 <ksf> tbh, both nicks sound like a php "programmer" self-awarded them during a lan party involving wow playing.
11:45:22 <byorgey> shapr: why are they notorious?
11:45:26 <shapr> TopMind is all about "Table Oriented Programming", google can give you more information than you actually want.
11:45:37 <ksf> like, excel?
11:45:56 <shapr> Suffice it to say that TopMind thinks that all of programming is a facade around database structures.
11:46:05 <vixey> http://lambda-the-ultimate.org/node/989
11:46:30 <mauke> shapr: oh god, that sounds familiar
11:46:36 <dolio> We're all electrons flying around a giant plutonium atom.
11:46:44 <shapr> vixey: Right, the TopMind mentioned there. He has many sock puppets, so beware.
11:46:50 <SingInTime> hmmm... there's no xml validator in xml library
11:46:57 <SingInTime> anyone ever used hxt?
11:47:00 <vixey> i feel TOP is "domain specific anti-normalisation"
11:47:12 <vixey> this is great
11:47:34 <ksf> do i really have to read that now?
11:47:42 <shapr> No! Don't read about TopMind!
11:48:08 <shapr> You can't get that time back, and TopMind's only claim to fame is being one of the internet cranks.
11:48:16 <HomingHamster> is haskell even a good language?
11:48:26 <lament> No.
11:48:28 <shapr> HomingHamster: Yes, as are many languages.
11:48:29 <vixey> HomingHamster: you should make your own mind up about stuff like that
11:48:34 <byorgey> it's mostly odd a good language
11:48:36 <mauke> HomingHamster: no, it's a dessert topping
11:48:37 <bremner> SingInTime: I have used hxt; to be honest I mostly try to avoid the "arrowness", which probably makes it suboptimal
11:48:43 <lament> I think I speak for everyone in this channel when I say haskell is absolutely horrible and nobody would ever want to use it
11:48:44 <ksf> mostly, it's an evil language.
11:48:57 <vixey> @remember lament: I think I speak for everyone in this channel when I say haskell is absolutely horrible and nobody would ever want to use it
11:48:57 <lambdabot> Good to know.
11:49:06 <mauke> vixey: fail
11:49:06 <shapr> HomingHamster: Perhaps you have a specific task you'd like to accomplish with Haskell?
11:49:12 <dolio> @quote lament:
11:49:12 <lambdabot> lament: says: I think I speak for everyone in this channel when I say haskell is absolutely horrible and nobody would ever want to use it
11:49:16 <shapr> HomingHamster: Then we could address your specific concerns.
11:49:39 <bremner> or make better jokes
11:49:44 <shapr> HomingHamster: Which is fancy for "Haskell is really good for some tasks, and not good for others. What Tasks do you have in mind?"
11:49:59 <shapr> bremner: y0, long time no see.
11:50:29 <HomingHamster> how does it compare to python|
11:50:31 <HomingHamster> ?
11:50:33 * shapr boings randomly, waiting impatiently for a response!
11:50:37 <bremner> it is different
11:50:38 <lament> HomingHamster: it's very different!
11:50:58 <lament> HomingHamster: but i like both, if that's any indication.
11:50:59 <shapr> HomingHamster: Python is more imperative than Haskell, but they share significant whitespace a sa feature.
11:51:05 <bremner> shapr: hi! were we romantically entangled and I forget to call?
11:51:07 <ksf> python's are poisonous, but do it to survive. haskell is pure evil.
11:51:18 <lament> i think both python and haskell are prettier than average programming languages
11:51:27 <mauke> I think python is ugly
11:51:28 <trofi> average? :]
11:51:33 <shapr> HomingHamster: Python's list comprehensions were seen as a good idea that already existed in Haskell.
11:51:36 <HomingHamster> ok cool
11:51:37 <SingInTime> bremner: so what would you suggest?
11:51:45 <vixey> bremner: this happens a lot with you? :p
11:51:46 <shapr> bremner: Weren't you previous dbremner?
11:51:51 <shteou> Best explanation ever, shapr.
11:51:52 <ksf> in general, "can i compare foo to haskell" will get you the answer "no."
11:51:53 <wli> I wonder if there are better ways to format than e.g. pp i s = "%t" ++ show i ++ " transitively uses [" ++ List.intercalate ", " vs ++ "]" where vs = ["$v" ++ show v | v <- IntSet.toList s]
11:51:58 <HomingHamster> thanks for the opinions guys (+ gals?)
11:52:01 <ImInYourMonad> @quotw
11:52:01 <lambdabot> bos says: * bos is 6 months old, and can lift small buildings (after a bottle of milk) // Botje> bos: .. into what monad?
11:52:03 <wli> (e.g. more efficient ways)
11:52:03 <ImInYourMonad> @quote
11:52:03 <lambdabot> weitzman says: The Prelude needs verse numbers to use when quoting it.
11:52:06 <ImInYourMonad> @quote
11:52:07 <lambdabot> Pseudonym says: All hail the Evil Mangler!
11:52:30 <bremner> SingInTime: I don't have enough experience to compare to the other libraries. It is workable for a beginner (me), but a bit daunting.
11:52:33 <dolio> Pythons aren't poisonous.
11:52:35 <ImInYourMonad> Coq: it doesnt work to copy from the bottom right window in coqide, why not?
11:52:43 <shapr> HomingHamster: If you have some specific small bits of code you'd like to see, we could demonstrate with lambdabot.
11:52:49 <lament> pythons aren't even venomous
11:52:55 <SingInTime> ok thanks a lot, I'll give it a try
11:53:02 <ksf> whatever. i hate snakes.
11:53:04 <shapr> bremner: But if you want to call me, I will talk to you.
11:53:08 <dolio> :)
11:53:09 <bremner> shapr: I could have been, but I don't think I was ever other than bremner on irc. What did I talk about as dbremner?
11:53:30 <bremner> vixey ^ the "I will talk to you" almost never happens
11:53:33 <HomingHamster> shapr, yes please
11:54:01 <shapr> HomingHamster: Ok, join #haskell-in-depth, it's a bit quieter, yeah?
11:54:01 <lament> > 1
11:54:02 <lambdabot>   1
11:54:06 <HomingHamster> ok
11:54:32 <trofi> folks! how come i can't use my local lambdabot when yi-0.6 is installed?
11:54:34 <trofi> lambdabot> > 1+2
11:54:34 <trofi>   Could not find module `Control.Monad.Writer':
11:54:35 <trofi>    it was found in multiple packages: monads-fd-0.0.0.0 mtl-1.1.0.2
11:55:08 <byorgey> ouch.
11:55:28 <trofi> is it bug, feature? :]
11:55:52 <byorgey> trofi: well, monads-fd (along with transformers and monads-tf) are a reimplementation of mtl
11:55:59 <byorgey> unfortunately, they export the same things.
11:56:10 <trofi> weird
11:56:27 <trofi> so it's more like hs-plugins bug?
11:56:35 <byorgey> you could try hiding monads-fd like this: ghc-pkg hide monads-fd
11:56:40 <trofi> it can use any implementation in this case?
11:56:42 <byorgey> trofi: it isn't a bug at all.
11:56:53 <byorgey> just poor package/module naming.
11:57:22 <trofi> erm.. if it is fully compatible implementtaion - it can have the same name
11:57:26 <byorgey> if yi is already built then it should be ok to hide some of the packages used to build it.
11:57:35 <trofi> sure
11:57:38 <SingInTime> gotta go now... thank to everybody for the suggestions
11:57:40 <SingInTime> cya :)
11:57:44 <byorgey> oh, but the whole point of yi is that you can rebuild it on the fly, never mind =(
11:57:58 <trofi> heh, true
11:58:20 <byorgey> trofi: but the problem is that when you try to import something exported by two different packages, it doesn't know which to choose
11:58:42 <trofi> [sf] ~:mueval -e '1+2'
11:58:43 <trofi> mueval-core: NotAllowed "Could not find module `Control.Monad.Cont':\n  it was found in multiple packages: monads-fd-0.0.0.0 mtl-1.1.0.2"
11:58:46 <byorgey> trofi: it works fine for building packages, which must explicitly specify which packages they depend on
11:58:51 <byorgey> but for ghci...
11:59:01 <trofi> yep :[
11:59:10 <c_wraith> ghci -hiding-package mtl
12:00:52 <vixey> > (map fst . iterate (uncurry (+) &&& fst)) (0,1)
12:00:53 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
12:00:54 <vixey> , (map fst . iterate (uncurry (+) &&& fst)) (0,1)
12:00:55 <lunabot>  luna: Not in scope: `&&&'
12:01:16 <trofi> why does not YI break when recompiles itself?
12:02:02 <Eridius> trofi: cabal and Setup.hs hide packages properly
12:03:16 <trofi> does YI recompiles itself via cabal ?
12:03:18 <lilac> ksf: generally, the question "can i compare foo with haskell?" will get you the answer "type mismatch"
12:04:09 <Eridius> trofi: yes, `runghc Setup.hs install` is effectively the same thing as `cabal install` (although not quite - I think `cabal install` always does a clean build)
12:04:33 <Eridius> well no, `cabal install` is actually `runghc Setup.hs configure && runghc Setup.hs build && runghc Setup.hs install`
12:04:52 <mmorrow> doing "cabal install" can also choose to rebuild an arbitrary number of your packages
12:04:57 <Eridius> yes
12:05:00 <trofi> Eridius: i'm about recompiling when you edir ~/.yi/yi.hs
12:05:12 <Eridius> ahh
12:05:20 <Eridius> trofi: it recompiles the "real" yi binary when you do that
12:05:37 <Eridius> I haven't looked into exactly what it does, but it doesn't use cabal for that
12:07:48 <mmorrow> all yi does to recompile is
12:07:48 <HomingHamster> bye
12:07:53 <mmorrow>  waitForProcess =<< runProcess GHC.Paths.ghc ["--make", projectName ++ ".hs", "-i", "-fforce-recomp", "-v0", "-o",binn,"-threaded"]
12:08:07 <mmorrow> and finally
12:08:08 <mmorrow> child_pid <- forkProcess $ executeFile executable_path False args' Nothing
12:09:43 <trofi> heh
12:09:59 <trofi> have added Control.Monad.Writer to yi.hs and it broke
12:10:03 <adityam> Is it possible to write a TH function, lets say called "generate" such that 'generate "x" 3' is equal to 'x1 = f 1; x2 = f 2; x3 = f3'?
12:10:20 <trofi> yi.hs:11:7:
12:10:23 <trofi>     Could not find module `Control.Monad.Writer':
12:10:26 <trofi>       it was found in multiple packages: monads-fd-0.0.0.0 mtl-1.1.0.2
12:10:42 <adityam> I am trying to figure out what 'x1 = f 1' looks like to TH, but runQ says parse error at =
12:11:04 <Peaker> adityam: why generate TH functions? what's wrong with using f directly there?
12:11:17 <lilac> adityam: you want this at the top level?
12:11:25 <lilac> (that is, function definitions)
12:11:47 <adityam> lilac, yes I want this at top level
12:12:02 <adityam> Peaker, I want to get the variable names x1, x2, and x3 from TH
12:12:07 <lilac> , [d| x1 = f 1; x2 = f 2; x3 = f 3 |]
12:12:08 <lunabot>  ValD (VarP x1) (NormalB (AppE (VarE f) (LitE (IntegerL 1)))) []
12:12:08 <lunabot>  ValD (VarP x2) (NormalB (AppE (VarE f) (LitE (IntegerL 2)))) []
12:12:08 <lunabot>  ValD (VarP x3) (NormalB (AppE (VarE f) (LitE (IntegerL 3)))) []
12:12:22 <lilac> adityam: ^^ that's what you want then ;-)
12:12:46 <Peaker> adityam: yeah, I am wondering why you need that (not saying you don't.. just wondering what reason you have for that :)
12:12:51 <adityam> liliac: Thanks. Did not realize that there was a [d| ..|]
12:13:51 <adityam> Perker: I am writing code where I have x1 = Node "X1"; x2 = Node "X2" , etc. so wanted to avoid some typig
12:14:10 <Exteris> are there bindings for xchat somewhere?
12:14:12 <Exteris> for haskell
12:14:15 <ksf> oh wtf.
12:14:17 <vixey> adityam: here's an idea
12:14:18 <ksf> i'm buggered.
12:14:26 <vixey> adityam: instead of x1, x2, ... use x 1, x 2, ...
12:14:37 <vixey> adityam: then x n = Node ("X"++show n)
12:14:48 <vixey> adityam: Now we just defined x1 .. infinity all in one go
12:14:56 <vixey> no TH
12:15:02 <lilac> ksf: that was sudden ;-)
12:15:07 <Peaker> adityam: I see.. Repeating the name is indeed a repeating problem in Haskell.. Maybe it can be generalized to some assign macro that is given a name and a function and does both assignment and giving the name to the function
12:15:07 <adityam> vixey: Thanks. Did not think of it this way!
12:15:36 <ksf> it figures that the easiest way to get relative seeking is to manually count, thanks to the iteratee api.
12:15:54 <ImInYourMonad> can object-orientation be dervied from set theory?
12:15:59 <ImInYourMonad> si has been claimed
12:16:00 <ksf> ...the other possibility is annotating every byte with its position.
12:16:17 <Peaker> ImInYourMonad: Object Orientation is an undefined term :)
12:16:21 <ksf> even if done lazily, i doubt i wanna do it like that.
12:16:39 <lilac> ImInYourMonad: well, set theory is all "everything is a set" and oo is all "everything is an object". my typechecker unifies them by setting object = set
12:17:02 <lament> object theory!
12:17:11 <mmorrow> ,  ppDoc `fmap` (let generate x f n = do {xs <- replicateM n (newName x); sequence (zipWith (\x n -> valD (varP x) (normalB [|$(varE (mkName f)) $(lift (n::Int))|]) []) xs [1..])} in generate "x" "f" 3)
12:17:13 <lunabot>  x_0 = f 1
12:17:13 <lunabot>  x_1 = f 2
12:17:13 <lunabot>  x_2 = f 3
12:17:34 <ImInYourMonad> lilac: ok but is that really valid?
12:17:58 <lilac> ImInYourMonad: probably not. i also need to make 'a' and 'an' equivalent.
12:18:12 <Peaker> I think most "mainstream OO" is about having a short-hand for:  (exists a. SomeInterface a => a) encouraging its use, even though most of the time, existentials aren't even necessary
12:18:15 <dino-> A colleague sent me something, a blog post that goes over an old-ish article by Osterhout about scripting vs non-scripting languages.
12:18:20 <dino-> http://asserttrue.blogspot.com/2009/03/making-one-line-of-code-do-work-of-47.html
12:18:22 <shapr> bremner: Clearly you are not the David Bremner who has been a regular on #haskell for five years or so.
12:18:54 <ksf> scripting vs. non-scripting is bunk.
12:19:22 <bremner> shapr: I don't think so.   If so, I blanked about 4 and half of those years.
12:19:27 <lament> i always thought "Scripting" meant "I don't really like this language and I think it's a toy"
12:19:30 <ksf> ...'specially since people tend to call stuff like perl and python scripting and totally forget about lua.
12:19:40 <Phyx-> Hi, i'm hoping someone here can help me out, i'm trying to hook the afterSizeAllocate event in gtk2hs, and it works, for the initial event, but then crashes in subsequent calls saying "Perhaps a 'foreign import unsafe' should be 'safe'?"
12:19:46 <dino-> Specifically, things are said here about having a type system, that it makes you write more, so is bad.
12:19:47 <Peaker> dino-: I think "instructions/statement" is a misguided measure of a language's "high-levelness"
12:20:01 <ksf> scripting basically means "is parsed at run-time"
12:20:13 <maltem> lament: Or, alternatively, "I know nothing about programming, but I frequently do scripting"
12:20:17 <lament> ksf: according to you. Not a common definition, though.
12:20:22 <Peaker> dino-: Its wrong
12:20:29 <dino-> This all strikes me as very blub. The "more firmly" typed langauge these people are familiar with are labor-intensive with type annotations, so types are bad.
12:20:42 <Peaker> dino-: Having a type system can make you write more or write less, depending on how much type inference you have, and what exactly you are writing
12:20:47 <ksf> so, is scheme a scripting language?
12:20:49 <lament> ksf: e.g. people often say python is a scripting language
12:20:59 <ksf> haskell, when using the ghc api?
12:21:01 <ksf> java?
12:21:12 <Peaker> Python is parsed at compile-time
12:21:14 <mads-> Hi - I was in here before (I thik) did you see my question`
12:21:18 <mmorrow> , eval "eval \"42\""
12:21:21 <lunabot>  <<Dynamic>>
12:21:36 <ksf> ...so is perl, it gets compiled to bytecode, first.
12:21:47 <mmorrow> , (fromJust . fromDynamic . fromJust . fromDynamic) (eval "eval \"42\"") :: Integer
12:21:49 <lunabot>  42
12:21:52 <ksf> i meant "is parsed during run-time of some bigger thing"
12:21:54 <Zao> mads-: If by "before" you mean ten minutes ago, no.
12:21:56 <dino-> I think these pair of articles is more about typed/not-typed
12:21:57 <ksf> like, level scripting.
12:21:59 <Peaker> lament: I think "Scripting language" is an untyped language
12:22:00 <ksf> gimp scripting.
12:22:04 <ksf> yi scripting.
12:22:20 <lament> Peaker: same comment as to ksf. That's one possible definition. The problem is, everybody has their own.
12:22:20 <dino-> Peaker: yes  Sorry to confuse everyone
12:22:28 <bremner> Peaker: you mean dynamically typed I guess
12:22:50 <ImInYourMonad> scripting languages ~= dynamic bytecode langs, perl,ruby,python,php. that seems to be the "definition"
12:22:58 <lament> Peaker: the question is not really of which definition is correct. It doesn't matter which one is correct, what matters is in practice everyone uses a different one, so the term is useless.
12:23:13 <Peaker> bremner: I prefer "untyped" to "dynamic typing".  Dynamic types are not the same kind of "Types" as static types at all. They are runtime "tags" on runtime values, whereas static "types" are compile-time tags on terms/expressions
12:23:15 <ksf> ImInYourMonad, but then it's a matter of compilation technique.
12:23:23 <Peaker> lament: I agree :)
12:23:32 <ksf> haskell can be bytecode interpreted, not to mention scheme.
12:23:48 <ImInYourMonad> i didnt say it was a good or correct definition, jsut that that seems to be what people use
12:23:49 <RayNbow> imo, scripting languages are about their intended use... but intended use changes over time :p
12:23:50 <ksf> and i know a lot of people who would lynch you for calling java a scripting language.
12:24:04 <ksf> (most significantly me, because it's a bugger to integrate anywhere)
12:24:05 <lament> The definition I encountered most often is "a language the most popular implementation of which is interpreted"
12:24:11 <dino-> But the point here really is: making this claim about more strongly typed languages relies on the ignorance of inference.
12:24:29 <Peaker> dino-: Yeah -- I agree it stems from ignorance
12:24:31 <lament> er, make that "a language the most popular implementation of which is interpreted, with dynamic typing"
12:24:35 <bremner> Peaker: how do you distinguish  C from python wrt to types then?
12:24:41 <Peaker> dino-: not only of inference - but also of limitations of the type system
12:25:10 <Phyx-> is there a gtk2hs channel or forum i can go to to ask in?
12:25:13 <ksf> c is statically typed.
12:25:14 <Peaker> bremner: C has compile-time types, and no runtime tags.  Its types are weak as unsafeCoerce is used everywhere :) Python uses runtime tags, which are strong (you can't unsafe coerce them)
12:25:15 <mads-> I have just install slackware and have just downloaded ghc. ghc requires libedit2.0, but I can only find 3.0 online. Is this a known issue or what?
12:25:20 <dino-> I would love to see one of us post to refute this while he's got comments open.
12:25:20 <ksf> the only run-time checks you get are segfaults.
12:25:24 <ImInYourMonad> yeah their use isprob the best definition
12:26:25 <bremner> Peaker: ok fine, but I prefer to use standard(ish) terminology.
12:26:54 <seliopou> We actually discussed these terms earlier
12:26:55 <Peaker> bremner: the standard terminology is misleading though, calling two different things by the same name "types"
12:27:11 <lament> the real issue is that the programmer community is fragmented along several lines, and different subgroups use terms in different meanings
12:27:27 <|jedai|> [11:31:33]mads-: libedit2 is more often seen than the 3rd version so I'm not sure what you're speaking about ?
12:27:36 <dino-> It all reminds me of the Chris Smith thing about debating type systems.
12:27:40 <seliopou> there are type safe languages and not type safe languages, and there are statically typed language and non statically typed languages
12:27:42 <mads-> |jedai|: You now where I can find it?
12:27:51 <Peaker> programming is such a horrible discipline where lots of uninformed idiots make up a lot of the terminology (and even popular languages) that are in use
12:27:58 <Peaker> s/programming/software
12:28:03 <lament> seliopou: there are basically no type-safe languages in use, though :)
12:28:05 <dino-> Which needs updating, too, because it talks about Data.Map.lookup :: (Monad m) ...
12:28:09 <seliopou> ?
12:28:27 <seliopou> Haskell is if you don't use unsafe*
12:28:35 <seliopou> so's python, ruby, scheme, etc
12:28:45 <jedai> mads-: either libedit or libedit2 should be the correct package for Slackware
12:28:50 <seliopou> the only unsafe languages that come to mind are C and C++
12:28:52 <Peaker> seliopou: I think calling Python type-safe is a misnomer
12:28:56 <lament> seliopou: that's a pretty useless definition, then
12:29:03 <seliopou> why?
12:29:04 <Peaker> seliopou: Just because you get a type error rather than seg fault does not mean its "safe"
12:29:10 <mauke> Peaker: yes, it does
12:29:11 <seliopou> it in fact does
12:29:26 <Peaker> mauke: Type-safety is not about avoiding seg faults, its about correctness
12:29:29 <mauke> defined vs. undefined behavior
12:29:34 <Eridius> seliopou: there's a ruby library called evil.rb (I believe _why created it) that lets you unsafely coerce ruby types ;)
12:29:36 <seliopou> you're never doing things to data that you should not be doing
12:29:41 <Peaker> mauke: "Type safety" is not just about avoiding UB
12:29:43 <mads-> jedai: libedit2 is? :)
12:29:45 <mauke> it is now
12:29:48 <seliopou> Eridius, I yield to that point :)
12:29:50 <Eridius> (it was, of course, written in C and twiddles the type tag in the object's internal representation)
12:30:00 <Peaker> mauke: ok, then most languages are "type safe" - but that's a useless term then
12:30:09 <mauke> I think most languages aren't
12:30:09 <bremner> Peaker: head []
12:30:10 <seliopou> Peaker, why?
12:30:22 <mauke> is "safely typed" better?
12:30:27 <mmorrow> Peaker: (\f -> (\x -> f (x x)) (\x -> f (x x))) is perfectly correct, yet haskell's type system rejects it
12:30:35 <Peaker> seliopou: because its more interesting to be correct than to just not have UB
12:30:36 <seliopou> because the information gain in making that distinction is low?
12:30:41 <adamvo> it it possible to have a read instance for a heterogenous collection?
12:30:51 <jedai> mads-: Don't you use the package on your Slackware ?
12:31:17 <Peaker> mmorrow: Yeah, type safe programs only have to be a subset of the "correct" programs, not match exactly, for type safety to imply correctness
12:31:21 <seliopou> just because it's "more interesting" to consider something else doesn't mean the notion is useless
12:31:32 <adamvo> ie. it should behave like a tuple, but the size should be variable like a list
12:31:42 <Peaker> adamvo: you mean like HList?
12:31:48 <mmorrow> Peaker: so it's not about correctness, just about some particular system's idea of such.
12:31:50 <vixey> adamvo: doesn't make much sense
12:31:55 <mauke> e.g. Perl and Lisp are "unsafely typed"
12:32:18 <seliopou> they're dynamically typed
12:32:35 <seliopou> types are enforced at runtime
12:32:46 <mauke> they're unsafe because I can make them segfault
12:32:57 <mauke> well, not quite
12:33:03 <seliopou> you can?
12:33:04 <adamvo> Peaker: yes
12:33:06 <seliopou> the former I belive, but the latter?
12:33:07 <mauke> Lisp is unsafe because violating its type declaration causes UB
12:33:07 <seliopou> really?
12:33:19 <mauke> yes, most useless type declarations ever
12:33:30 <p_l> depends on implementation
12:33:40 <vixey> type declarations usually used for optimization
12:33:49 <mauke> pseudosyntax: (let ((foo)) (declare foo integer) ...)  ; UB
12:34:09 <adamvo> vixey: it doesn't? we can have: instance (Read a, Read b) => Read (a, b) -- Defined in GHC.Read
12:34:13 <p_l> with (safety 3) the types will be checked on any production-quality CL system
12:34:16 <vixey> A good compiler would give a warning message
12:34:17 <mauke> the declaration syntax is wrong, but that causes UB because foo contains NIL which is not a number
12:34:34 <mauke> p_l: irrelevant, the language spec says it's UB
12:34:35 <vixey> adamvo,
12:34:51 <p_l> mauke: That's why I'm saying it's implementation dependant
12:35:01 <vixey> > read "(3,('x',(True,())))" :: (Integer, (Char, (Bool, ())))
12:35:02 <lambdabot>   (3,('x',(True,())))
12:35:04 <ImInYourMonad> haskell isnt type-safe?
12:35:08 <mauke> just like C
12:35:09 <vixey> > read "(3,('x',(True,())))"
12:35:10 <lambdabot>   * Exception: Prelude.read: no parse
12:35:11 <romildo> Hi.
12:35:18 <vixey> adamvo, does this help
12:36:06 <seliopou> ImInYourMonad, I've made Haskell segfault :)
12:36:14 <seliopou> A haskell program, that is
12:36:20 <mauke> ImInYourMonad: depends on which operations you allow
12:36:31 <adamvo> vixey: not really, since I don't want to have to specify the number of elements (in the type)
12:36:56 <seliopou> I was using some sort of mutable array... but that was a while ago
12:37:32 <iago_> seliopou, in theory haskell doesn't segfault
12:37:32 <mmorrow> ImInYourMonad: you can access raw memory in haskell if you like
12:37:40 <seliopou> iago_, I'm aware
12:37:42 <iago_> without use of unsafe operations
12:37:52 <seliopou> thing is, I wasn't using unsafe operations
12:37:53 <ImInYourMonad> well it is "ype safe enough" i guess
12:37:58 <ImInYourMonad> hype safe?
12:38:03 <iago_> seliopou, you found a bug so
12:38:06 <seliopou>  yep
12:38:09 <seliopou> that's what I'm saying
12:38:14 <seliopou> I'm sure it's fixed now though
12:38:21 <seliopou> This was in... summer 2005
12:38:30 <vixey> adamvo: So what do you get instead then?
12:38:38 <romildo> Although my main OS is Linux, I am installing alex on Windows, because my compiler students use mainly Windows. Therefore I first installed ghc from the binary distribution found on its home page. Then I downloaded the latest source code of alex from hackage and I am following its instalation instructions. When compiling alex I am told that I need perl installed. So, which perl distribuition would you recommend?
12:38:39 <mmorrow> ImInYourMonad: any language that you can access raw memory in is trivial to segfault
12:38:49 <vixey> adamvo: You know why the second one didn't work yes?
12:38:52 <mmorrow> peek nullPtr
12:38:56 <mauke> romildo: strawberry perl
12:39:18 <mauke> see also http://mauke.ath.cx/stuff/haskell/hell.hs if you feel like executing raw machine code in haskell :-)
12:39:31 <mmorrow> yay!
12:39:57 <vixey> could you write a very efficient compiler using that idea?
12:40:06 <vixey> interpreter*
12:40:07 <vixey> I meant
12:40:20 <mmorrow> vixey: which idea? generating machine code? ;)
12:40:26 <mauke> similar idea in perl, slightly obfuscated: http://mauke.ath.cx/stuff/perl/japh8.pl
12:40:37 <vixey> but inside haskell
12:40:41 <mmorrow> vixey: have you seen that harpy tutorial #2?
12:40:45 <vixey> rather that outputting a .s
12:40:48 <mmorrow> it's pretty cool
12:40:48 <mauke> sounds like JIT
12:40:56 <mmorrow> vixey: yes
12:40:57 <jedai> vixey: Sure, you could, but using harpy would be better anyway
12:40:59 <mauke> also, I think tinycc does that
12:41:27 <adamvo> vixey: I guess read need to know which type is required, and its not allowed to just pick ones at random until one works
12:41:29 <romildo> mauke: thanks for the indication. I will install it.
12:41:41 <vixey> adamvo, that is correct
12:42:03 <vixey> adamvo, Imagine if you are given a string it could be "'x'" or "True" or "3"
12:42:23 <mauke> > read "3" :: Complex Double
12:42:24 <lambdabot>   * Exception: Prelude.read: no parse
12:42:26 <mmorrow> we need a generic "harpy" that just provides the front-end interface, and has a way to plug in machine/opcode definitions
12:42:26 <jedai> adamvo: Often in real programs the type is imposed by the context
12:42:36 <vixey> adamvo, you could read it (but not using the read function) but into a type   Either Char (Either Bool (Either Integer Void)))
12:42:56 <vixey> adamvo, but that Either is there and the 3 types are known already is essential
12:43:26 <vixey> mmorrow: Like a GHCi except assembly instead of haskell?
12:43:39 <jedai> mmorrow: Isn't Harpy a little bit too x86 oriented right now ?
12:43:58 <mmorrow> jedai: yeah, i'd start from scratch
12:44:37 <mmorrow> vixey: i'm thinking more along the lines of a generic "assembly" language
12:45:06 <vixey> I can't make the last tow lines of this program typecheck :/
12:45:13 <mmorrow> jedai: (by "i" i mean "one would probably want to")
12:45:23 <mmorrow> vixey: http://uebb.cs.tu-berlin.de/harpy/download/larger-tutorial.pdf
12:45:33 <bd_> mmorrow: isn't that what llvm is doing?
12:45:40 <trofi> generic assembly? :]
12:45:53 <trofi> sounds like as useless as C
12:46:08 <dolio> As useless as C--?
12:46:12 <mmorrow> bd_: for languages with c-like call stacks, yes
12:46:35 <mmorrow> trofi: no way. it would be super useful.
12:46:53 <trofi> but _much_ less powerful than target asm?
12:47:07 <vixey> I want to write a compiler for typed lambda calculus
12:47:11 <vixey> that is very efficient..
12:47:21 <mmorrow> trofi: but the point is that you can have full control, while at the same time not having to write your code for each arch.
12:47:24 <vixey> and lazy would be good I think too
12:47:32 <mmorrow> trofi: (C doesn't give full control)
12:47:45 <mmorrow> vixey: awesome, do it!
12:48:01 <trofi> mmorrow: why doesn't ?
12:48:14 <vixey> yeah I don't know how
12:48:17 <pejo> vixey, efficient and lazy sounds difficult. But it would certainly be nice!
12:48:23 <iago_> I'm doing one now vincenz
12:48:23 <mmorrow> trofi: because it forces you to use its calling convention and data layout
12:48:24 <vixey> I can't write assembly yet
12:48:25 <iago_> ops
12:48:30 <adamvo> jedai: it works well when it does, only I'd have to intervene somewhere because those elements have different types, but belong to the same typeclass
12:48:42 <iago_> well, compiler no, interpreter
12:48:46 <dolio> Didn't say lazy.
12:48:55 <trofi> mmorrow: data layout == alignment restrictions ?
12:49:37 <mmorrow> trofi: like for instance, ghc puts code next to data for its infotables. and for -fvia-C, this is why the mangler exists
12:50:31 <adamvo> basically, I want Read and Show instances for:
12:50:32 <adamvo> data Sublayout l a = Sublayout (l a) [(l a,W.Stack a)]
12:50:37 <ehird> Has anyone made something like Processing for Haskell? That would be nice.
12:51:03 <jedai> adamvo: You know "deriving" right ?
12:51:17 <adamvo> but I want to accept arbitrary l as long as they are part of one type class
12:51:20 <jedai> adamvo: You want something nicer ?
12:51:33 <adamvo> jedai: deriving does not work on existential types
12:51:39 <trofi> mmorrow: i dream about high level assembler too, but don't have any clue how it should look like :]
12:51:50 <adamvo> for the reason that the actual types are not known
12:52:07 <adamvo> so the right read instance cannot be found
12:52:13 <jedai> adamvo: Sublayout isn't existential though
12:52:17 <adamvo> l is
12:52:18 <mmorrow> trofi: me neither :)
12:52:33 <adamvo> I would like to accept existential types into this data
12:53:04 <vixey> adamvo: but I mean...
12:53:09 <adamvo> or at least be able to have different l, though they all do the same thing
12:53:13 <vixey> adamvo: you can't have a program that doesn't have a type
12:53:21 <vixey> adamvo: this is what I tried to explain
12:53:42 <jedai> adamvo: What you want isn't very clear, could you give an exemple ?
12:54:06 <dolio> You'd need a Dynamic more integrated with the compiler for that.
12:54:26 <adamvo> in this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2613#a2613
12:54:43 <dolio> So you can read a type rep, and choose a read instance based on that, for instance.
12:54:44 <trofi> mmorrow: http://valerieaurora.org/synthesis/SynthesisOS/ <-- worth reading i think
12:55:18 <Baughn> Practically speaking, is there any significant speed difference between using Binary-Strict and using rnf on Binary to force exceptions?
12:55:30 <adamvo> dolio: where can I store the type rep: it can't be turles all the way down?
12:55:52 <Baughn> adamvo: Some languages do have infinite hierarchies of types...
12:55:56 <dolio> You store it with the data you're reading.
12:56:04 <vixey> adamvo: I bet there's a different, better way to program this..
12:56:14 <Baughn> @seen dons
12:56:14 <lambdabot> dons is in #gentoo-haskell, #haskell, #darcs, #concatenative, #xmonad, #ghc, #arch-haskell and #yi. I last heard dons speak 1h 39m 18s ago.
12:56:14 <dolio> The data needs to tell you what type you're reading in.
12:56:36 <dolio> Of course, you can do that by hand.
12:56:42 <adamvo> dolio: so I have to write my own instances :(
12:57:02 <dolio> Yes, you need a nicer dynamic, as I said.
12:57:10 <dolio> Maybe the GHC api can do it, but that'd be hairy.
12:57:16 <mmorrow> trofi: interesting
12:57:35 <mmorrow> trofi: C-- is really cool too
12:57:56 <mmorrow> trofi: and a "portable assembly lang" is actually its stated goal
12:58:50 * trofi 've seen sphinx C-- some years ago. is it that one?
12:58:51 <mmorrow> dolio: yeah, i think you need a dependently typed language to be able to do cool stuff with dynamic
12:59:12 <mmorrow> trofi: http://www.cminusminus.org/
12:59:28 <dolio> Well, GADTs are probably Good Enough, but they're kind of limited as a basis for Dynamic.
12:59:34 <mmorrow> dolio: (heh, in which case it wouldn't have to be dynamic i suppose)
12:59:36 <vixey> GADTs + type lambda
12:59:44 <vixey> GADTs + type level lambda*
12:59:59 <vixey> mmorrow: I used Data.Dynamic in Coq once
13:00:12 <mmorrow> vixey: how so?
13:00:32 <vixey> it's part of some ugly hack to get pattern matching
13:00:34 <adityam> @pl f n = zip [1..n] $ inits [1..n]
13:00:34 <lambdabot> f = ap (zip . enumFromTo 1) (inits . enumFromTo 1)
13:00:56 <vixey> it would be unnecessary if you had proof irrelevance or pattern matching
13:01:03 <mmorrow> vixey: hmm
13:02:24 <dolio> mmorrow: Well, even with GADTs you could probably structure things such that they don't go through a Dynamic type, but such a type is a handy way to package up the functionality.
13:03:23 <dolio> Of course, with a sufficiently nice language Dynamic is just Sigma (t : TypeRep) (Lift t).
13:03:53 <dolio> Lift : TypeRep -> Set
13:04:26 <dancor> if anyone wants to tell me if i'm implementing this alternating-list data-type poorly: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1928#a1928
13:04:28 <mmorrow> dolio: oh yeah, definitely handy. i'm just unsatisfied with going from a Dynamic to a value of the type it actually is. Typeable sucks because it has to be monomorphic then. so the only way in haskell's type system is to use unsafeCoerce (which Dynamic does anyways, but uses Typeable as its "guarantee")
13:05:06 <mmorrow> like, suppose you did  (eval ".....")
13:05:16 <vixey> mmorrow: I don't think you /have/ to use unsafeCoerce
13:05:29 <vixey> you can do a closed universe of types with a GADT that doesn't need coerce
13:05:41 <mmorrow> vixey: but what about an open universe?
13:06:02 <dolio> An open universe needs open GADTs.
13:06:11 <mmorrow> for instance, ghci does (unsound) runtime-type-reconstruction by traversing the heap
13:06:13 <Saizan_> mmorrow: unsafeCoercing to a polymorphic type works? i got segfaults when typeclasses were involved
13:06:16 <mmorrow> for :type
13:06:22 <dino-> Well, thanks everyone for discussing that whole "waah, types make my code too long" crybaby nonsense. I knew I could get good discourse on it here.
13:06:51 <mmorrow> Saizan_: sure it works, you just can't be wrong :) (hmm, i'm not sure what the interaction with typeclasses would be)
13:07:02 <dolio> Having actual polymorphic values in a Dynamic in a haskell-like language probably requires actual compiler support.
13:07:10 <mmorrow> Clean has a dynamic that can handle polymorphic values
13:08:08 <mmorrow> dolio: yeah, totally. i've been thinking recently what exactly that support would need to be, and further if that could somehow be handled by a (dependent) type system alone
13:08:43 <dolio> Well, polymorphic values in Agda, for instance, are just ordinary functions that take type parameters.
13:08:48 <dolio> So it may be possible there.
13:09:07 <dolio> Although you proably run into universe trouble there.
13:09:18 <dolio> You might need type-in-type to make it non-painful.
13:09:18 <mmorrow> hmm, but does the actual generated code take a type parameter (in some form)?
13:09:19 <vixey> You could probably have a GADT with a type level list of base types, a list of * -> * types, etc
13:09:35 <vixey> that is open in the sense that you can reuse it on an old function with even more types
13:10:23 <mmorrow> hmm
13:10:42 <dolio> mmorrow: Presumably it would if it had to. Languages like Agda don't have as clear a phase distinction between types and values as GHC does.
13:10:59 <vixey> dolio: What do you mean by that?
13:11:20 <dolio> I mean you can't necessarily erase everything with a type of Set or greater.
13:11:30 <mmorrow> dolio: i think it would only have to in the case of typeclasses (or equiv)
13:11:43 <vixey> dolio: I think you can
13:12:10 <vixey> dolio: Not during the execution that happens in type checking, but during normal runtime
13:12:13 <mmorrow> for instance, id (as generated by ghc at least) won't segfault no matter what type you give it
13:12:40 <dolio> I think it's fairly trivial to construct an example that violates that.
13:12:49 <vixey> can you show me it please?
13:13:07 <mmorrow> let foo = (unsafeCoerce (id::Int->Int)) :: a -> a
13:13:24 <mmorrow> should work the same as "id"
13:13:46 <Baughn> I would /hope/ id gets compiled down to a no-op most of the time
13:13:47 <mmorrow> ie, (id::Int->Int) === (id::a->a)  wrt generated code
13:14:18 <mmorrow> Baughn: do in ghci:
13:14:24 <mmorrow> :set -ddump-bcos
13:14:29 <mmorrow> let foo a = a
13:14:31 <Baughn> mmorrow: Well, ghci is different. That's an interpreter.
13:14:46 <mmorrow> Baughn: ok, do :set -ddump-asm
13:14:50 * mmorrow tries
13:14:56 <dolio> vixey: Oh, well, I suppose it depends what you mean. For instance, I can construct datakinds that obviously can't be erased, despite their values being "type-level".
13:15:13 <Baughn> mmorrow: What I mean is, foo should usually be inlined, and optimized down to nothingness
13:15:23 <mmorrow> Baughn: separate compilation, etc
13:15:29 <dolio> Because I can trivially send value-level naturals to type-level naturals and back over the course of my program.
13:15:36 <Baughn> mmorrow: -O2, cross-module inlining, etc. ;)
13:15:38 <vixey> dolio: Well to typecheck something you have to keep types around -- but to just run the program you should be able to erase these datakinds
13:15:56 <vixey> assuming that datakinds have type Set ... ?
13:16:15 <Baughn> Of course there's no reason for the non-noop version of id to do anything other than a pointer copy, but that's a different story
13:16:21 <mmorrow> Baughn: hmm. but i think this is irrelevant to what we're talking about, in the sense that if we're doing "eval "\a->a"", it certainly will exist
13:16:51 <Saizan_> Prelude Unsafe.Coerce GHC.Exts> let z = unsafeCoerce (show :: Show a => a -> String) :: Any
13:16:54 <Baughn> @seen kolmodin
13:16:54 <lambdabot> kolmodin is in #haskell.se, #gentoo-haskell, #arch-haskell, #darcs, #yi, #ghc and #haskell. I last heard kolmodin speak 2m 49s ago.
13:16:54 <Saizan_> Prelude Unsafe.Coerce GHC.Exts> (unsafeCoerce z :: Show a => a -> String) 1
13:16:57 <Saizan_> :\
13:16:59 <Saizan_> "()"
13:17:04 <vixey> dolio: I think it boils down to: If an object has type Set then it's always treated as () i.e. you can't pattern match on -- or if you do then that pattern match always has exactly one case
13:17:06 <ehird> mmorrow: wait, what? You have an eval :: String -> a?
13:17:08 <mmorrow> Saizan_: heh, yeah it defaults
13:17:09 <Baughn> kolmodin: Oh, that's handy. Lennart kolmodin?
13:17:10 <dolio> Like "print (tnatToNat (natToTnat 5 +T natToTNat 5))"
13:17:30 <kolmodin> @yarr
13:17:30 <lambdabot> Shiver me timbers!
13:17:38 <kolmodin> Baughn: yes
13:17:44 <mmorrow> ehird: sure, thanks to the ghc-api (but its type would be eval :: String -> Any)
13:17:47 <vixey> dolio: I don't get that what is the implementation?
13:17:56 <ehird> mmorrow: String -> Any? How boring.
13:18:01 <mmorrow> i know! sucky
13:18:02 <ehird> unsafeCoerce, ye land lubber.
13:18:20 <Baughn> kolmodin: Er, right. I wanted to ask, are there any real plans to make Binary strict, at least in the sense of detecting parse errors?
13:18:41 <ksf> i'm about a beer apart from giving up on fd's and just use mmap.
13:18:48 <dolio> vixey: 'data TNat : Set1 where TZ : TNat ; TS : TNat -> TNat' etc. 'tnatToNat TZ = Z ; tnatToNat TS tn = S (tnatToNat tn)' ...
13:18:55 <ehird> ksf: haskell has mmap?
13:19:04 <ksf> c has, and that's enough.
13:19:13 <ehird> right, err, that's very #haskell
13:19:27 <dolio> +T is addition on TNats.
13:19:36 <kolmodin> Baughn: I haven't really worked with binary for a while, but no, it's not something I've heard of
13:19:38 <ksf> it's very haskell because i'm struggling with seeking and iteratees.
13:19:45 <vixey> dolio: Why are you calling it "TNat"?
13:20:01 <dolio> Because TNat : Set1 just like Set : Set1.
13:20:09 <vixey> dolio: this is exactly equivalent to Nat
13:20:15 <Baughn> kolmodin: Ah. Right now I'm usinh "decode `using` rnf", which seems a bit wrong somehow.
13:20:23 <dolio> Yes, but its sort is one level higher.
13:20:33 <ksf> calling read(), in whatever way whatsoever, seems to be insanity if you've got mmap.
13:20:54 <vixey> dolio: The program you wrote is:   print (id (id 5 + id 5))
13:21:14 <dolio> Yes, but it runs through a datakind that you can't erase.
13:21:24 <vixey> 5 : Nat
13:21:26 <vixey> id 5 : TNat
13:21:32 <vixey> this isn't a value of type Set
13:21:36 <ksf> saves you from making mere guesses wrt. to read buffer sizes, too.
13:22:34 <dolio> Right, but if you have an automatic TypeRep type that you can do case analysis on, and a getTypeRep : Set -> TypeRep, I think you get similar non-erasibility issues.
13:22:50 <vixey> getTypeRep : Set -> TypeRep  is impossible to implement
13:23:09 <vixey> (unless you have something like   getTypeRep _ = defaultValue )
13:23:17 <vixey> you can't do e.g.
13:23:22 <vixey> getTypeRep Bool = "Bool"
13:23:38 <vixey> getTypeRep (A -> B) = getTypeRep A "->" getTypeRep B
13:23:46 <dolio> I know you can't.
13:25:06 <vixey> if you added getTypeRep as a primitive, yes that would break the property of erasure
13:25:10 <mmorrow> why can't you?
13:25:11 <dolio> But, I think if you wanted a dynamic like mmorrow wants, you'd have to have it.
13:25:25 <dolio> mmorrow: You can't do case analysis on values of type Set.
13:25:25 <mmorrow> (yeah, sure types would be values then)
13:25:39 <dolio> (In Agda)
13:26:11 <mmorrow> i think that's limiting
13:26:16 <vixey> what is limiting?
13:26:36 <mmorrow> that types can't be values too
13:26:41 <vixey> types are values
13:26:56 <vixey> that's the one great thing about dependent types :p
13:27:11 <mmorrow> so then why can't you do getTypeRep : Set -> TypeRep ?
13:27:36 <mmorrow> if they were values, that function would be trivial
13:28:05 <jmcarthur> that function is trivial when the type is known at compile time
13:28:07 <mmorrow> s/values/whatever the term is that what i'm saying implies/ ;)
13:28:14 <mmorrow> jmcarthur: but it won't be
13:28:35 <jmcarthur> getTypeRep : {A:Set} -> A -> Set
13:28:57 <jmcarthur> well, that would better be described as getType
13:29:06 <ehird> With a binary op how can I make (a op b c) be ((a op b) c)?
13:29:21 <dolio> You cannot.
13:29:27 <mmorrow> getTypeRep : Set -> TypeRep
13:29:30 <ehird> dolio: :<
13:29:39 <vixey> quote :: Set -> TypeRep
13:29:41 <jmcarthur> mmorrow, that is not a dependently typed function
13:29:52 <jmcarthur> it doesn't have enough information
13:30:01 <Saizan_> getTypeRep A _ = A?
13:30:04 <vixey> what is the normal form of (\(x :: Set) -> quote (Bool -> x)) ?
13:30:20 <mmorrow> jmcarthur: well then i need something more than dependent types :)
13:30:24 <jmcarthur> Saizan_, in agda it would look like getTypeRep {A} _ = A
13:30:35 <jmcarthur> since it's normally an implicit argument
13:30:36 <vixey> mmorrow: This quote feature is utterly useless btw
13:30:43 <mmorrow> at least, more than Agda's idea of them
13:30:49 <vixey> mmorrow: anything you want to do with it is done better using a different methodology
13:31:01 <jmcarthur> mmorrow, you want tagged values, that's all
13:31:03 <mmorrow> vixey: :t eval "\\x -> x"
13:31:08 <mmorrow> a -> a
13:31:18 <vixey> mmorrow: You can do that
13:31:21 <jmcarthur> it's the only way that function can be truly polymorphic like that
13:31:31 <vixey> eval :: (s :: String) -> typeCheck s
13:31:31 <mmorrow> but i intend to do that, so i need to figure out how.
13:31:46 <vixey> mmorrow: just like Cayenne printf
13:32:14 <mmorrow> hmm
13:32:26 <vixey> eval "\\x -> x" :: typeCheck "\\x -> x" = forall a. a -> a
13:32:36 <ImInYourMonad> how do you define subtraction of the natural numbers?
13:32:42 <ImInYourMonad> Pred Nat?
13:32:50 <mmorrow> but you do know that cayenne's printf is equivalent to the TH printf
13:32:53 <vixey> ImInYourMonad: using fold
13:32:55 <Gracenotes> un-Succing Nat
13:33:04 <vixey> mmorrow: No they are totally different
13:33:06 <mmorrow> i.e., cayenne's printf needs the format string *at compile-time*
13:33:10 <mmorrow> try it
13:33:13 <mmorrow> i have
13:33:23 <vixey> mmorrow: it doesn't actually
13:33:23 <Gracenotes> ImInYourMonad: pred (Succ n) = n
13:33:30 <Gracenotes> ImInYourMonad: which of course fails for zero
13:33:33 <mmorrow> i actually wrote my TH printf exactly from cayenne's
13:33:40 <mmorrow> vixey: try it
13:33:49 <ehird> mmorrow: err, can't you just offer a proof that the string is OK?
13:33:51 <vixey> try what exactly?
13:33:51 <mmorrow> it truly does
13:33:59 <ehird> i.e. "don't worry, this printf call will result in this type -- and I can prove it"
13:34:12 <mmorrow> vixey: try to give cayenne's printf a string at runtime. the compiler will error out
13:34:21 <vixey> mmorrow: you can't do
13:34:22 <ehird> sure, you need a proof don't you?
13:34:24 <vixey>  do x <- readLine
13:34:30 <vixey>    printf x 3 5 3
13:34:39 <ImInYourMonad> Gracenotes: thats my problem yes
13:34:39 <vixey> that doesn't and shouldn't typecheck
13:34:44 <mmorrow> exactly. thus, it is the same as TH's printf
13:34:48 <ehird> ...no
13:34:54 <vixey> no mmorrow, there's more to it
13:34:56 <ehird> because you can pass printf a string at runtime, AFAIK
13:35:11 <mmorrow> vixey: it computes the type given the format string
13:35:14 <Gracenotes> ImInYourMonad: you can make it so that pred Zero = Zero. either that or an error, but both a reasonably conventional
13:35:18 <mmorrow> my TH printf does the same
13:35:20 <Gracenotes> are
13:35:31 <jmcarthur> you would have to do something more like do x <- readLine; printf {appropriateProofStuff x} x 3 5 3
13:35:33 <ImInYourMonad> Gracenotes: are natural numbers positive only?
13:35:39 <Gracenotes> positive or zero
13:35:42 <vixey> mmorrow: but you could do,  do x <- readLine ; case check x of Left prf -> printf x ; Right prf -> printf x 3 4 "foo"
13:35:56 <Gracenotes> in most (sensible) definitions anyway
13:36:02 <vixey> mmorrow: (assuming pattern matching, if you didn't have pattirn matching you could rewrite the prf's manually)
13:36:12 <jmcarthur> ImInYourMonad, positive or zero
13:36:16 <dolio> mmorrow: You need to verify that the string you read will produce the right type for printf somehow if you want to pass it a runtime string.
13:36:17 <Gracenotes> it can be represented by this ADT: data Natural = Zero | Succ Natural
13:36:24 <jmcarthur> ImInYourMonad, some people say only positive numbers, but i think they are crazy
13:36:31 <Gracenotes> me too!
13:36:37 <Gracenotes> those are the counting numbers ^.^
13:36:46 <dolio> Proving that may be difficult, of course.
13:37:18 <mmorrow> vixey, dolio: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1929
13:37:33 <ehird> that's missing the point mmorrow
13:37:41 <ehird> you can pass a string at runtime, just not without checking it first
13:37:55 <vixey> mmorrow, see that you have  printf :: (fmt::String) -> PrintfType fmt
13:38:07 <mmorrow> ehird: hmm
13:38:15 <vixey> mmorrow, now if I have a string x, perhaps read from input -- and a proof PrintfType x = (Int, Int, Bool),
13:38:18 <ehird> of course you have to check it; for type safety
13:38:27 <RayNbow> data Fluffy = Warm | More Fluffy -- better Natural numbers? This way you don't have to argue about Zero/One :p
13:38:49 <vixey> mmorrow, then I can put that proof to use rewriting the type of  printf x  from  PrintfType x  which holds no info, into (Int, Int, Bool) -> String
13:38:54 <jmcarthur> the nice thing is that even though it sounds like more work, you really aren't having to do anything you wouldn't have to do anyway
13:39:14 <Gracenotes> More . More . More . More . More . More $ Warm
13:39:35 <mmorrow> so then, would a typecheck for `eval'  need to enumerate every possible type?
13:39:49 <ehird> LambdaVM is rather crufty... is there any other Haskell->JVM compiler?
13:40:16 <vixey> enumerate every possible type -- yes if I understand you correctly, of course you can use a recursive definition to do it in finite space
13:43:24 <dolio> vixey: Anyhow, with fancier erasure systems, it might be possible to have getTypeRep, but still erase types when you don't use it.
13:44:28 <dolio> Like the one in Erasure Pure Type Systems. They advocate erasure based not on type, but on usage in the program.
13:44:34 <ImInYourMonad> yes I need Predecssor O = O otherways I cant raise to the power of 1
13:46:11 <dolio> My bad, the paper is called Erasure and Polymorphism in Pure Type Systems.
13:46:28 <mmorrow> i still don't see any real gain in power from that cayenne printf. the only thing you get is the type system not complaining to you. you still need to enumerate all possible cases if you're taking a user-input string. this is equivalent to casing on the type. also, this is not really what i'm after anyways.
13:46:42 <vixey> mmorrow: there isn't really any -- with printf it doesn't matter
13:46:54 <mmorrow> also, i'm not thinking of using eval in statically compiled code.
13:47:01 <mmorrow> i'm thinking of using it interactively
13:47:18 <mmorrow> perhaps to completely replace the machine code of a running program
13:47:31 <mmorrow> and that program itself will do the replacing
13:47:50 <mmorrow> (well, you couldn't replace the code that implems eval, at least until the very end that is)
13:48:17 <vixey> mmorrow: you should check out common lisp/SLIME if you haven't
13:48:39 <mmorrow> cool, i will
13:48:55 <vixey> you can put together a webserver while it's up and running for example
13:49:04 <vixey> and debug it .. still processing connections
13:49:15 <mmorrow> interesting
13:49:16 <wli> The examples I think are useful are kind of braindead, i.e. linear algebra with matching matrix dimensions enforced by the type system, other vaguely array bounds checking -like things.
13:50:22 <ImInYourMonad> wli: can such things be made in the type ssyetms?
13:51:10 <ImInYourMonad> > let pow xs ys = foldr (const (>> xs)) [()] ys in pow [(),()] [(),(),()]
13:51:11 <lambdabot>   [(),(),(),(),(),(),(),()]
13:51:20 <wli> My vague thought on the issue is that the dependent typing sorts of things needed for practical use are rather limited and could be feasible with some weird programming restrictions (such as occur with Oleg's Haskell typeclass bits for bounds-checked "array" -like things).
13:51:46 <wli> In fact, I think Oleg already wrote them in Haskell. ;)
13:53:28 <Gracenotes> ImInYourMonad: you .could. make a [()] instance for Num, too :)
13:53:41 <Gracenotes> (although not exciting)
13:54:14 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2615#a2615 <- why is my power wrong=
13:55:43 <Gracenotes> ImInYourMonad: what's n^0?
13:55:50 <Gracenotes> or, yeah, you got that, nvm
13:55:57 <bmh> howdy
13:56:01 <mads-> jedai: Which repo are you using for slackware?
13:58:22 <jmcarthur> i would like it if dependently typed languages made it as easy to write code that doesn't rely on dependent types as languages that don't have dependent types (that is, without extra boilerplate)
13:59:32 <mmorrow> <dolio> vixey: Anyhow, with fancier erasure systems, it might be possible to have getTypeRep, but still erase types when you don't use it.
13:59:48 <mmorrow> dolio: totally. that's exactly what i'm thinking about
13:59:54 <jmcarthur> like if we somehow extended haskell with dependent types but left it backward compatible
14:00:02 <vixey> jmcarthur: nahh..
14:00:08 <vixey> jmcarthur: would carry along too much crap
14:00:08 <Gracenotes> ImInYourMonad: oh. the problem is that the predecessor call is superfluous
14:00:17 <jmcarthur> vixey, of course, the libraries would be annoying at that point
14:00:23 <Gracenotes> if (S p) i the your number (p) is the pred.
14:00:30 <Gracenotes> *is
14:00:55 <jmcarthur> plus design decisions like partial functions might screw things up somewhere
14:01:45 <seliopou> :t tup a = (a, a)
14:01:47 <lambdabot> parse error on input `='
14:01:57 <seliopou> :t let tup a = (a, a) in tup
14:01:58 <lambdabot> forall t. t -> (t, t)
14:02:00 <bmh> seliopou: how do monads work?
14:02:04 <jmcarthur> :t \a -> (a,a)
14:02:05 <seliopou> :t let tup a = (a, a) in tup . tup
14:02:05 <lambdabot> forall t. t -> (t, t)
14:02:06 <lambdabot> forall a. a -> ((a, a), (a, a))
14:02:08 <seliopou> :t let tup a = (a, a) in tup . tup . tup
14:02:10 <lambdabot> forall a. a -> (((a, a), (a, a)), ((a, a), (a, a)))
14:02:12 <seliopou> :t let tup a = (a, a) in tup . tup . tup . tup
14:02:13 <lambdabot> forall a. a -> ((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a))))
14:02:15 <seliopou> :t let tup a = (a, a) in tup . tup . tup . tup . tup
14:02:16 <lambdabot> forall a. a -> (((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))), ((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))))
14:02:18 <Gracenotes> :x
14:02:21 <seliopou> :t let tup a = (a, a) in tup . tup . tup . tup . tup . tup
14:02:22 <lambdabot> forall a. a -> ((((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))), ((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a))))), (((((a, a), (a, a)), ((a,
14:02:22 <lambdabot>  a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))), ((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a))))))
14:02:22 <seliopou> ok last one
14:02:23 <jmcarthur> enough!
14:02:26 <seliopou> :)
14:02:53 <Gracenotes> for the most part, monads work by calling functions
14:02:56 <vincenz> seliopou: Is that seriously necessary?
14:02:57 <vixey> let Tup Z A = A ; Tup (S n) A = Tup n (A, A)
14:03:04 <bmh> Gracenotes: that was a joke.
14:03:04 <vixey>  tup . tup . tup . tup :: Tup 4 a
14:03:05 <vincenz> seliopou: lambdabot supports private messaging
14:03:06 <seliopou> vincenz, not strictly
14:03:14 <vincenz> seliopou: Don't spam a channel with > 300 users
14:03:24 <seliopou> vincenz, didn't mean to offend, just saw some comment about big types
14:03:35 <vincenz> Alright, thanks.
14:03:51 <Gracenotes> bmh: just kidding then, the evaluation of monads are guided by the spirit of SPJ
14:04:33 <wli> Not sure where to go there.
14:04:34 <beelsebob> @. djinn type :t let tup a = (a, a) in tup . tup . tup . tup . tup
14:04:35 <lambdabot> Cannot parse command
14:04:42 <beelsebob> @. djinn type let tup a = (a, a) in tup . tup . tup . tup . tup
14:04:44 <lambdabot> f a =
14:04:44 <lambdabot>     (((((a, a), (a, a)), ((a, a), (a, a))),
14:04:44 <lambdabot>       (((a, a), (a, a)), ((a, a), (a, a)))),
14:04:44 <lambdabot>      ((((a, a), (a, a)), ((a, a), (a, a))),
14:04:44 <lambdabot>       (((a, a), (a, a)), ((a, a), (a, a)))))
14:04:46 <beelsebob> :D
14:04:58 <beelsebob> it's @unpl in disguise!
14:05:24 <Adamant> I see your type signature is as large as mine
14:05:33 <beelsebob> it's not a type sig
14:05:35 <Adamant> :P
14:05:42 <Gracenotes> @. pl . djinn type let tup a = (a, a) in tup . tup . tup . tup
14:05:44 <lambdabot> f = ap ((,) . ap ((,) . ap ((,) . join (,)) (join (,))) (ap ((,) . join (,)) (join (,)))) (ap ((,) . ap ((,) . join (,)) (join (,))) (ap ((,) . join (,)) (join (,))))
14:05:48 <mauke> use the schwartz
14:05:49 <Gracenotes> success!
14:05:50 <beelsebob> hehe
14:05:52 <beelsebob> awesome
14:06:04 <beelsebob> it's actually pretty close to id
14:06:12 <Adamant> mauke got it
14:06:22 <beelsebob> @. pl . djinn type ap ((,) . ap ((,) . ap ((,) . join (,)) (join (,))) (ap ((,) . join (,)) (join (,)))) (ap ((,) . ap ((,) . join (,)) (join (,))) (ap ((,) . join (,)) (join (,))))
14:06:24 <lambdabot> f = ap ((,) . ap ((,) . ap ((,) . join (,)) (join (,))) (ap ((,) . join (,)) (join (,)))) (ap ((,) . ap ((,) . join (,)) (join (,))) (ap ((,) . join (,)) (join (,))))
14:06:26 <beelsebob> :D
14:07:19 <insane_> who is agocorona and where i can reach him/her?
14:07:44 <sioraiocht> :t pure
14:07:45 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
14:08:02 <sioraiocht> in which library is applicative?
14:08:07 <seliopou> base
14:08:10 <beelsebob> Control.Applicative
14:08:10 <seliopou> I believe
14:08:11 <sioraiocht> thanks
14:08:16 <ImInYourMonad> Gracenotes: superflous? how?
14:08:20 <sioraiocht> also, i just found it, and realised it was a stupid question, thanks =p
14:10:18 <Gracenotes> ImInYourMonad: if your pow is 5, what will p be?
14:10:36 <Gracenotes> and then what value will you call the power function with recursively?
14:10:48 <Heffalump> @seen pgavin
14:10:48 <lambdabot> pgavin has changed nick to pgavin-away.
14:10:48 <lambdabot> Last time I saw pgavin-away was when I left ##logic, #arch-haskell, #darcs, #dreamlinux-es, #friendly-coders, #gentoo-haskell, #gentoo-uy, #ghc, #haskell, #haskell-blah, #haskell-books, #haskell-
14:10:48 <lambdabot> hac07, #haskell-overflow, #haskell-soc, #haskell.cz, #haskell.de, #haskell.dut, #haskell.es, #haskell.fi, #haskell.fr, #haskell.hr, #haskell.it, #haskell.jp, #haskell.no, #haskell.ru, #haskell.se, #
14:10:48 <lambdabot> haskell_ru, #jhc, #jtiger, #macosx, #perl6, #rosettacode, #scala, #scannedinavian, #unicycling and #xmonad 7m 5d 19h 8m 43s ago, and .
14:10:54 <bmh> jesus.
14:10:58 <Heffalump> errm, sorry
14:11:18 <wli> @type let u = join (,) ; v = u . u ; w = v . v ; x = w . w ; y = x . x ; z = y . y in z
14:11:33 <lambdabot> thread killed
14:11:35 <seliopou> eheh
14:12:27 <seliopou> I forgot where I ran across that
14:12:47 <vixey> it's well known
14:13:09 <wli> I'm trying to remember the trick for accomplishing the tower of compositions in even fewer lines/variables/etc.
14:13:49 <vixey> maybe with polymorphic recursion
14:13:51 <seliopou> vixey, sure, but there's some exposition from some mailing list...
14:13:54 <Gracenotes> oh wow, that's huge
14:14:49 <Gracenotes> does it grow via tetration?
14:15:58 <seliopou> Gracenotes, wli's does
14:16:02 <Gracenotes> yeah
14:16:03 <idnar> how much memory do you need to run that?
14:16:05 <wli> Trying to think of how to do it with polymorphic recursion.
14:16:17 <wli> I don't know. I ran out.
14:16:45 <gnut> has anyone installed chart? I can't seem to find gtk or cairo packages.
14:16:54 <gnut> I can't get gtk2hs to compile either.
14:16:55 <idnar> if I remove one level, I can do it on my desktop machine
14:17:12 <idnar> although it takes a while to print it out
14:17:21 <Gracenotes> @oeis 2, 4, 16, 256
14:17:21 <lambdabot>  2^(2^n).
14:17:21 <lambdabot>  [2,4,16,256,65536,4294967296,18446744073709551616,34028236692093846346337460...
14:17:45 * seliopou warm fuzzies
14:18:17 <Gracenotes> so 4 levels probably = 2^16
14:18:51 <ImInYourMonad> Gracenotes: my pow and p? Succ (Succ (Succ (Succ (Succ Zero)))) == 5
14:19:03 <ImInYourMonad> i will call it with 4 Succ
14:19:44 <Gracenotes> if pow = Succ (Succ (Succ (Succ (Succ Zero)))), then in Succ p, p matches with Succ (Succ (Succ (Succ Zero)))
14:25:00 <wli> I'm trying to think of some way to do the polymorphic recursion here.
14:25:54 <ImInYourMonad> Gracenotes:yes...
14:26:13 <ImInYourMonad> ah
14:27:31 <wli> let d = join (.) ; u = join (,) in d (d u)
14:27:36 <wli> That seems to be it.
14:38:03 <wli> I can't smoke out the type signature.
14:42:51 <ImInYourMonad> name a simple proof for me to do in Coq
14:46:06 <vixey> 1 + 1 = 2
14:46:57 <Botje> doesn't that one take 23 pages or something?
14:47:09 <vixey> in early versions of type theory :p
14:47:38 <wli> The type signature for d f = f . f so as to permit the polymorphic recursion for d u?
14:47:39 <Botje> urgh, this tea is vile
14:47:52 <vixey> which tea?
14:48:19 <Botje> forgot the name
14:48:28 <Botje> but i do know i still have plenty of it
14:48:33 <wli> :t let u = join (,) in u . u
14:48:35 <lambdabot> forall a. a -> ((a, a), (a, a))
14:48:37 <Botje> it's from india and comes in really tiny balls
14:48:41 <wli> :t let d f = f . f in d (join (,))
14:48:42 <lambdabot>     Occurs check: cannot construct the infinite type: c = (c, c)
14:48:42 <lambdabot>       Expected type: c -> c -> c
14:48:42 <lambdabot>       Inferred type: c -> c -> (c, c)
14:48:45 <Botje> it's not gunpowder
14:48:47 <kerlo> @type let d = join (.) ; u = join (,) in d (d u)
14:48:48 <lambdabot>     Occurs check: cannot construct the infinite type: b = (b, b)
14:48:48 <lambdabot>       Expected type: b -> b
14:48:48 <lambdabot>       Inferred type: b -> (b, b)
14:49:00 <kerlo> @type join (.)
14:49:01 <lambdabot> forall b. (b -> b) -> b -> b
14:49:34 <kerlo> Oh.
14:50:15 <kerlo> So it returns (a -> c) given something whose type is a superset of both (a -> b) and (b -> c).
14:51:29 <kerlo> One of these days I should figure out how MIT's hostnames work.
14:51:41 <kerlo> BRAIN-AND-COG-THREE-TWELVE doesn't seem to be very regular.
14:52:05 <kerlo> > BRAIN-AND-COG-THREE-TWELVE.MIT.EDU
14:52:05 <lambdabot>   Not in scope: data constructor `BRAIN'Not in scope: data constructor `AND'N...
14:52:41 <vixey> @brain
14:52:41 <lambdabot> I think so, Brain, but isn't that why they invented tube socks?
14:55:48 <seliopou> wli, I think I figured it out
14:56:06 <wli> seliopou: Okay, but make it quick.
14:56:27 <seliopou> so I'm not quite sure if this does what you want, but
14:56:38 <vixey> @quote
14:56:38 <lambdabot> b7j0c says: the haskell community should take out life insurance on dons
14:56:40 <vixey> @quote
14:56:40 <lambdabot> wilx says: I mean, besides the murders, it all looks so nice.
14:56:42 <vixey> @quote
14:56:43 <lambdabot> lament: says: I think I speak for everyone in this channel when I say haskell is absolutely horrible and nobody would ever want to use it
14:56:43 <seliopou> > let f d (a, b) = (d a, d b)
14:56:44 <lambdabot>   <no location info>: parse error on input `;'
14:56:47 <vixey> @quote
14:56:47 <lambdabot> PaulGraham says: I get the impression that using [Haskell] would feel like reading a novel written by a literary critic.
14:57:00 <ImInYourMonad> rofl
14:57:03 <zachk> paul graham sleeps alone
14:57:05 <seliopou> :t let f d (a, b) = (d a, d b) in f . f
14:57:06 <lambdabot> forall t t1. (t -> t1) -> ((t, t), (t, t)) -> ((t1, t1), (t1, t1))
14:57:21 <seliopou> It's something like that
14:57:25 <seliopou> a lot of arrows, but almost
14:57:44 <wli> Looks good.
14:58:00 <wli> :t let f d (a, b) = (d a, d b) in (f . f . f . f) (join (,))
14:58:01 <lambdabot> forall t. ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))) -> (((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (
14:58:01 <lambdabot> t, t))), (((t, t), (t, t)), ((t, t), (t, t)))))
14:58:29 <wli> Well, maybe a different manner of exponential behavior, but anyway.
14:58:43 <seliopou> :t let f d (a, b) = (d a, d b) in (f . f . f . f) (join (,)) undefined
14:58:44 <lambdabot> forall t. (((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))))
14:58:46 <seliopou> hax
14:58:47 <seliopou> :)
14:59:10 <vixey> :t let f d (a, b) = (d a, d b) in (f . f . f . f) id
14:59:11 <lambdabot> forall t. ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))) -> ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t))))
14:59:39 <seliopou> I don't think I accomplished anything
14:59:45 <vixey> me neither
14:59:54 <ehird> LambdaVM is rather crufty... is there any other Haskell->JVM compiler?
15:00:06 <wli> I think the polymorphic recursion and RankNTypes are involved.
15:00:30 <Nafai> ehird: Would sure be nice :/
15:00:39 <ehird> Nafai: Yes. Yes it would be.
15:00:49 <ehird> It would be very, very nice.
15:00:50 <vixey> why?
15:01:06 <ehird> vixey: Sneaking Haskell into places it wasn't judged worthy.
15:03:41 <wli> At what type is (.) instantiated in let u = join (,) in u . u?
15:04:53 <Deewiant> ?ty join (,)
15:04:54 <lambdabot> forall a. a -> (a, a)
15:05:02 <Deewiant> ?ty (.)
15:05:03 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
15:05:50 <vixey> :t let u = join (,) in ?dot u u
15:05:51 <lambdabot> forall t a a1. (?dot::(a -> (a, a)) -> (a1 -> (a1, a1)) -> t) => t
15:05:55 <Deewiant> b = (x,x), c = ((x,x),(x,x)), a = x ?
15:06:00 <vixey> :t let u = join (,) in ?dot u u :: a -> (a, a)
15:06:01 <lambdabot>     Could not deduce (?dot::(a1 -> (a1, a1))
15:06:01 <lambdabot>                             -> (a2 -> (a2, a2))
15:06:01 <lambdabot>                             -> a4
15:06:11 <insane> did anyone tried installing cabal on gentoo from portage ?
15:06:36 <vixey> :t let u = join (,) in (?dot :: (b -> c) -> (a -> b) -> a -> c) u u
15:06:37 <lambdabot>     Could not deduce (?dot::(b -> c) -> (a -> b) -> a -> c)
15:06:37 <lambdabot>       from the context ()
15:06:37 <lambdabot>       arising from a use of implicit parameter `?dot'
15:06:46 <omnihil> @info join
15:06:46 <lambdabot> join
15:07:37 <ehird> implicit parameters are so weird, does anyone acutally use them
15:07:41 <ehird> *actually
15:08:23 <wli> Mostly on here to smoke out types.
15:08:33 <kerlo> I used them once, I think.
15:08:43 <ehird> kerlo: what for?
15:09:17 <kerlo> Passing a handle around.
15:09:23 <ehird> why not use State?
15:09:27 <ehird> or whatnot
15:09:30 <ehird> or Reader, actually
15:10:09 <wli> > let u = join (,) ; v = u . u ; w = v . v ; x = w . w in length $ show (x ())
15:10:10 <lambdabot>   1277
15:10:33 <zachk> is using haskell to do Project Euler considered cheating? O:-)
15:10:39 <ehird> zachk: why?
15:10:48 <seliopou> jokes
15:10:48 <ehird> only insofar as any language is, which is not at all
15:10:57 <ddarius> zachk: You should use only pencil and paper.
15:11:16 <ehird> ddarius: err, Project Euler explictly endorses using a programming language
15:11:22 <ehird> am I missing sracasm?
15:11:24 <ehird> *sarcasm
15:12:28 <Botje> zachk: it's a great way to get started!
15:17:32 <dolio> @type let u = join (,) in ?dot u u
15:17:33 <lambdabot> forall t a a1. (?dot::(a -> (a, a)) -> (a1 -> (a1, a1)) -> t) => t
15:18:21 <kerlo> @type let u = join (,) in ?dot (?dot u)
15:18:22 <lambdabot> forall a. (?dot::(a -> (a, a)) -> a -> (a, a)) => a -> (a, a)
15:18:45 <vixey> @seen jkff
15:18:45 <lambdabot> I saw jkff leaving #haskell 2h 4m 35s ago, and .
15:20:39 <dolio> In let u = join (,) in u . u, (.) has type ((a,a) -> ((a,a),(a,a))) -> (a -> (a,a)) -> a -> ((a,a),(a,a))
15:21:28 <zeno> hi im getting errors with cabal upgrade, might be this /usr/bin/ld: cannot find -ledit, heres the full text http://pastebin.ca/1365660
15:23:48 <neale> Is there a good way to debug a Parsec parser?
15:24:42 <ImInYourMonad> is there a good way to parse a debugger
15:25:35 <neale> meh.
15:25:44 <kerlo> What if REPL is the best way to debug anything at all?
15:26:17 <neale> kerlo: probably your screen would explode.
15:26:21 <stepcut> is there a "write yourself a ML in 48 hours"
15:26:37 <jethr0> neale: have you added the "<?>" error message for all your parsec functions?
15:26:51 <guenni> does the ghci debugger offer an option to display all variables that are in scope?
15:26:53 <neale> jethr0: I know where it's having trouble, I just don't know how it got there.
15:27:07 <vixey> stepcut: a typechecker and interpreter ?
15:28:11 <jethr0> neale: so you want a debug trace without modifying your code, right?
15:28:53 <jethr0> might be difficult seeing how parsec can backtrack arbitrarily far...
15:29:20 <altmattr> I know there are various alternatives, but is anyone here actually using haskell for their shell?
15:29:52 <jethr0> wasn't there a way to get a "stack trace" with all calling functions via ghci debugger?
15:30:15 <stepcut> vixey: yes
15:31:15 <stepcut> vixey: i mean, HM type-checking is old hat now. It's not like, 'write yourself an epigram in 48 hours.' :)
15:31:58 <hollenjf> which photograph is nicer? http://solarcourt.net/bitmaps/IM001562.JPG or http://solarcourt.net/bitmaps/IM001565.JPG
15:32:05 <vixey> stepcut, there is some very simple code online but not a tutorial in taht style
15:32:43 <mauke> bitmaps/JPG? what treachery is this
15:33:29 <mle> well, maps can be implemented in various ways...
15:33:35 <stepcut> vixey: how hard code it be? I'll just make it up :)
15:35:14 <jethr0> neale: the ":trace" command in ghci debugger might help. if you ":trace" all your parsec functions you should be able to see a stack trace of function calls (very theoretically)
15:36:02 <jethr0> but probably there is a neater way. if "hat" weren't such a pain to get running that might also be suitable to analyse function calls and parameters post-mortem
15:36:25 <neale> ghci is almost impossibly difficult to get running on this Solaris box.
15:36:31 <neale> I've been using hugs
15:36:39 <neale> but, okay, it sounds like printf debugging time.
15:36:41 <altmattr> so no-one I guess, why not?
15:36:56 <jethr0> neale: you know about "trace", right?
15:37:00 <jethr0> :t trace
15:37:01 <lambdabot> Not in scope: `trace'
15:37:09 <neale> do, I don't...
15:37:24 <neale> s/do,/no,/
15:37:44 <TomMD> altmattr: Your question is ambigious.  Perhaps thats why there are no responses.
15:38:25 <jethr0> neale: it's in debug.trace and let's you output debug information in otherwise pure functions
15:38:56 <neale> neat, thanks :)
15:44:16 <ddarius> @quote oasis
15:44:16 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
15:49:04 <Trowalts> oh thank god
15:50:16 <Trowalts> I'm truly glad that this channel exists, freenode is amazing and I shall return again
15:52:22 <chessguy> @bot
15:52:22 <lambdabot> :)
15:52:22 <lunabot>  :)
16:00:51 <Botje> yay, satisfied customer!
16:06:37 <coco`> How can two ordered lists be merged?
16:07:06 <mauke> carefully
16:07:26 <adamvo> just use (++)
16:07:41 <adamvo> works for me :)
16:08:28 <ivanm> and then re-sort
16:08:55 <ivanm> coco`: though it might be an idea to consider other data types, such as Set if you need to keep the order
16:09:06 <chessguy> @type let merge [] xs = xs; merge xs [] = xs; merge (x:xs) (y:ys) | x < y = x : merge xs (y:ys) | otherwise = y : merge (x:xs) ys in merge
16:09:07 <lambdabot> forall t. (Ord t) => [t] -> [t] -> [t]
16:09:12 <chessguy> coco`, ^^
16:09:52 <RayNbow> @let mergeByR cmp fxy fx fy z = go    where go []     ys     = foldr fy z ys ; go xs     []     = foldr fx z xs ; go (x:xs) (y:ys) = case cmp x y of ; LT -> fx  x   (go xs (y:ys)) ; EQ -> fxy x y (go xs ys) ; GT -> fy    y (go (x:xs) ys)
16:09:54 <lambdabot>  Defined.
16:10:31 <chessguy> is that somehow more efficient?
16:10:44 <RayNbow> no, just more flexible :p
16:10:45 <vininim> > mergeByR (*) (+1) (+2) "wat is this?"
16:10:46 <lambdabot>   Couldn't match expected type `Ordering -> b -> b'
16:10:57 <mauke> :t L.mergeByR
16:10:58 <lambdabot> forall a1 a b. (a1 -> a -> Ordering) -> (a1 -> a -> b -> b) -> (a1 -> b -> b) -> (a -> b -> b) -> b -> [a1] -> [a] -> b
16:11:02 <RayNbow> @go twan van laarhoven mergeByR
16:11:02 <lambdabot> No Result Found.
16:11:20 <Japsu> now that is one complex type sig
16:11:25 <ivanm> mauke: what doe the "L." mean?
16:11:26 <chessguy> bah, that's nothing
16:11:31 <int-e> > mergeByR (:) (:) (const (:)) [] [1,3,4,5,6] [2,5,6,8,9]
16:11:32 <lambdabot>   Couldn't match expected type `Ordering'
16:11:42 <int-e> > mergeByR compare (:) (:) (const (:)) [] [1,3,4,5,6] [2,5,6,8,9]
16:11:44 <lambdabot>       Occurs check: cannot construct the infinite type: a1 = [a1]
16:11:44 <lambdabot>      Probab...
16:11:51 <chessguy> ivanm, it's the namespace when you @let something
16:11:53 <RayNbow> http://twan.home.fmf.nl/blog/haskell/generic-merge.details <-- twanvl's blog post about mergeByR
16:12:03 <ivanm> chessguy: thought so, wanted to check
16:12:18 <int-e> seems to be overly generic to me
16:12:50 <int-e> oh. fxy comes second not fourth
16:13:01 <int-e> > mergeByR compare (const (:)) (:) (:) [] [1,3,4,5,6] [2,5,6,8,9] -- this?
16:13:03 <lambdabot>   [1,2,3,4,5,6,8,9]
16:13:14 <neale> oh, man
16:13:23 <neale> you do *not* want to use Debug.Trace in Parsec.
16:13:40 <vixey> you don't want to use Debug.Trace ever
16:13:51 <neale> I do.
16:14:00 <neale> well, I did.
16:14:13 <neale> I don't have a lot of options with hugs :\
16:15:26 <chessguy> vixey, what's wrong with using Debug.Trace strictly for debugging?
16:15:43 <vixey> nothing
16:15:53 <chessguy> ...
16:16:43 <neale> how do you explicitly specify a module?
16:16:48 <neale> ERROR "./parser.hs":13 - Ambiguous variable occurrence "try"
16:16:48 <neale> *** Could refer to: Text.ParserCombinators.Parsec.Prim.try System.IO.Error.try
16:17:04 <vixey> neale: I do:  import System.IO hiding (try)
16:17:07 <neale> ah
16:17:17 <vixey> but you could write,  Text.ParserCombinators.Parsec.Prim.try  instead
16:17:40 <mle> or not include both System.IO and Parsec in the same module....
16:17:45 <neale> hugs doesn't like that.
16:19:37 <int-e> neale: you can create a .hs file that does the import and load it.
16:19:52 * neale nods
16:19:59 <neale> okay, hiding is good enough for now
16:20:25 <neale> this is going to be its own module now.
16:20:27 <neale> thanks
16:21:15 <int-e> and while you are at it, you could learn about qualified and named imports:  import Text.ParserCombinators.Parsec.Prim as P   allows you to use P.try. import qualified System.IO  forces you to use System.IO.try for the System.IO function. The two can be combined, and can be combined with import lists and hiding imports.
16:26:35 <jfredett2> @where mtl
16:26:36 <lambdabot> www.cs.brown.edu/~jwicks/mtl_reference/
16:27:21 <jfredett2> whereabouts is the darcs repo containing the Control.Monad.Reader stuff?
16:27:54 <jfredett2> code.haskell.org doesn't have it (or at least, it's not uploaded
16:30:23 <Saizan_> @source Control.Monad.Reader
16:30:23 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/Reader.hs
16:31:11 <jfredett2> ahhh
16:31:15 <jfredett2> thanks
16:38:21 <travisbrady> is there a standard way to carry a database connection around?  the State monad?
16:38:34 <vixey> yes
16:38:38 <dons> Reader?
16:38:47 <dons> roll your own DB monad ?
16:39:11 <mle> reader won't help if you need to reconnect...
16:39:34 <dons> takusen and hdbc have monads to encapsulate some plumbing
16:39:36 <dons> check them/
16:39:43 <Philonous> What would prevent that DB from being updated while the connection is open and doesn't that break referential transparency?
16:40:18 <dons> it's a DB socket you're holding. not the DB itself.
16:40:27 <ispiked> when building a list with a list comprehension, is there any way to check if an element's already been added to list you're constructing?
16:40:28 <dons> and the DB runs in IO (or something like it) since it is mutable
16:40:33 <travisbrady> so using the Galois sqlite library for instance say i wanted a web app to be able to execute things without reconnecting every time a request comes in and without threading a single connection through everything, do i instantiate a Reader on startup or something?
16:40:47 <travisbrady> i wrote an interface to TokyoTyrant and i want to write some real code against it now
16:40:57 <dons> travisbrady: yeah, you'll want some kind of local environment for the stuff you'd have to thread
16:42:00 <Philonous> Ah I see
16:42:44 <travisbrady> here's the code if anyone is curious http://github.com/travisbrady/haskell-tyrant/tree/master
16:43:02 <travisbrady> dons: incidentally, is a SQLiteHandle just a Socket?
16:43:30 * dons checks the src
16:44:14 <dons> travisbrady: is that in the galois sqlite lib?
16:44:18 <dons> i don't see it defined
16:44:47 <travisbrady> dons: http://hackage.haskell.org/packages/archive/sqlite/0.4.2/doc/html/Database-SQLite.html#t%3ASQLiteHandle
16:45:18 <dons> newtype SQLiteHandle = SQLiteHandle (ForeignPtr ())
16:45:55 <dons> it it wraps the sqlite-managed object
16:46:58 <ivanm> dons: did you know of my sourcegraph app when you wrote your cabalgraph, etc.?
16:47:14 <ivanm> because it seems to do some of the same stuff...
16:49:25 <Philonous> ispiked: I don't see how. If you bind the list to a name you have access to the whole list, but you wouldn't know which part is already defined, possibly leading to an infinite loop. You could, however, just keep the double elements and just nub the list afterwards
16:52:04 <singintime> hello everybody
16:52:10 <ispiked> Philonous: oh, nice. didn't realize there was a function for that... thanks
17:05:02 <coco`> is there a function to remove the nth element of a list?
17:05:41 <Botje> nope
17:05:45 <ivanm> coco`: you can write one using splitAt...
17:05:46 <Botje> but you can easily write it yourself
17:06:05 <coco`> sure, just wondering if it's already done
17:06:23 <Botje> not in the standard lib
17:06:35 <ivanm> > let removeNth n xs = let (fr,_:bk) = splitAt n xs in fr ++ bk in removeNth 3 [1..10]
17:06:36 <lambdabot>   [1,2,3,5,6,7,8,9,10]
17:06:42 <ivanm> coco`: ^^
17:07:08 <ivanm> note that you really should use a case statement to check that there's something to split, etc. ...
17:08:08 <ImProvablyInYour> can someone come up with something that is easy toprove in coq?
17:08:36 <Botje> ImProvablyInYour: giggle. nice nick :)
17:08:36 <coco`> ImProvablyInYour: 1+1=2
17:10:49 <azathoth99> http://www.prevayler.org/wiki/ how close to this is happs?
17:10:51 <ImProvablyInYour> coco: reflecitivity.done.
17:10:54 --- mode: ChanServ set +o mauke
17:11:22 <coco`> why is there no strict version of "map"?
17:12:54 --- mode: mauke set -o mauke
17:12:59 <ivanm> coco`: why should there be?
17:13:33 <ivanm> if all else fails, replace "map f" with "map (f !$)"
17:13:58 <ivanm> (which will make it strict in the elements, but not strict in the list)
17:14:01 <coco`> ivanm: that wouldn only make each cell strict, not the whole list
17:14:06 <coco`> right :)
17:14:09 <ivanm> yeah, I realised that
17:14:19 <ivanm> you could seq the result or something
17:14:34 <ivanm> but generally, you want to discourage arbitrary strictness
17:14:42 <ivanm> (foldl' is probably the one exception)
17:15:47 <ivanm> write -> profile -> some judicious strictness
17:20:28 <edwardk> deepSeq . map
17:20:30 <edwardk> ? =)
17:20:57 <edwardk> @type join deepSeq . map
17:20:58 <lambdabot> Not in scope: `deepSeq'
17:21:29 <mmorrow> @let deepSeq x = rnf x `seq` x
17:21:30 <lambdabot>  Defined.
17:21:51 <mmorrow> oops, is deepSeq something else?
17:22:06 <Valodim> @src rnf
17:22:06 <lambdabot> Source not found. Do you think like you type?
17:22:14 <mmorrow> , 'rnf
17:22:16 <lunabot>  Control.Parallel.Strategies.rnf
17:22:20 <edwardk> http://www.haskell.org/pipermail/libraries/2006-October/005945.html seems to indicate they are the same
17:22:48 <edwardk> http://cpansearch.perl.org/src/AUDREYT/Perl6-Pugs-6.2.13/src/Data/DeepSeq.hs was the one i was thinking of, but the rnf version is better thought out
17:23:16 <mmorrow> ahh, i see
17:24:34 <coco``> doesn't deepSeq/rnf force a second traversal of the list?
17:24:48 <ivanm> @hoogle deepSeq
17:24:49 <lambdabot> No results found
17:25:17 <edwardk> coco`` but it'll be your first traversal because the map won't happen until forced
17:25:38 <coco``> oh
17:25:53 <edwardk> coco`` otherwise you'd have what you wanted without the extra effort ;)
17:25:59 * ivanm thinks all elements should be doubly-seq'd to make sure they're _really_ forced!
17:26:00 <ivanm> ;-)
17:26:20 <coco``> no way to push this into a datatype/newtype?
17:26:22 <edwardk> seq and you shall find
17:27:11 <edwardk> well you can make a newtype that has the silly strict map as fmap but it won't meet the functor laws
17:27:13 <singintime> goodnight :)
17:27:18 <edwardk> fmap id = id will fail for instance
17:27:39 <edwardk> (when applied to an infinite structure)
17:27:53 <monochrom> You only seq twice.
17:28:10 <edwardk> hide and seq?
17:28:12 <ivanm> monochrom: lol
17:28:58 <monochrom> @quote bond
17:28:58 <lambdabot> No quotes match. Sorry about this, I know it's a bit silly.
17:29:09 <monochrom> @quote 007
17:29:09 <lambdabot> monochrom says: 007 titles for haskellers.  fromForeignPtr withCString.  You Only lift Twice. Bottoms Are Forever.  The Monad with the Pure Function.  For Your Types Only.  A view to A seq.  Licence
17:29:09 <lambdabot> to killThread.  iterate Never Dies.  unsafePerformIO Is Not Enough.
17:29:45 <ivanm> monochrom: you need to add you only seq twice to it!
17:30:13 <monochrom> Yeah, I used to have "you only lift twice" there, which is a good pun too.
17:30:27 <ivanm> that's better, tbh
17:30:58 <mmorrow> license to killthread is my fav
17:31:19 <mmorrow> shortly followed by iterate never dies
17:31:33 <dolio> fromForeignPtr withCString
17:31:34 <monochrom> I like "bottoms are forever" and "unsafePerformIO is not enough" most.  you can also try "the RealWorld# is not enough".
17:31:45 <mmorrow> dolio: yeah, i just don't get that one
17:31:53 <monochrom> from russia with love
17:31:53 <dolio> From Russia With Love.
17:31:56 <mmorrow> ahh
17:32:06 <monochrom> That one is the most subtle. :)
17:32:10 <mmorrow> ok, fromForeignPtr withCString is my new fav
17:32:17 <zeno> hi im getting errors with cabal upgrade, might be this /usr/bin/ld: cannot find -ledit, heres the full text http://pastebin.ca/1365660
17:32:21 * mmorrow doesn't know many 007 titles
17:34:31 <mmorrow> zeno: do you not have libedit in /usr/lib ?
17:35:02 <mmorrow> if not, is it in your LD_LIBRARY_PATH ?
17:42:03 <travisbrady> how does one resolve Control.Monad.Reader being found in monads-fd and mtl as in http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2344#a2622 ?
17:44:59 <jedai> travisbrady: You can specify which package to import
17:45:37 <jedai> instead of letting --make choose for you (and getting confused when a module is in two packages)
17:46:20 <travisbrady> jedai: for now i'm just using ghci, is this something i pass with -package ?
17:47:12 <mmorrow> travisbrady: you could use this as a (non-portable, but what is;) http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2344#a2623
17:47:14 <Saizan_> travisbrady: e.g. :set -hide-package monads-fd
17:47:16 <mmorrow> .. fix
17:47:36 <mmorrow> -XPackageImports
17:47:40 <mmorrow> import "network" Network.Socket
17:48:27 <travisbrady> mmorrow, Saizan_ : thank you both
17:48:43 <mmorrow> np
17:49:01 <travisbrady> now i've just gotta figure out how to actually use Reader
17:58:21 <coco``> is the SPECIALIZE pragma recursive within a module?
17:58:39 <coco``> if f calls g and I SPECIALIZE f, is g specialized as well?
17:59:12 <sjanssen> coco``: not necessarily
17:59:23 <sjanssen> you'd need to specialize both to be sure
18:05:36 <mmorrow> does anyone know what could be happening with whatever if you saw:
18:05:38 <mmorrow> From sc-mcl1-br1-g4-0.servint.net (207.58.128.1) icmp_seq=1 Time to live exceeded
18:05:56 <mmorrow> what does this mean exactly?
18:06:05 <Igloo> Probably a routing loop
18:06:14 <mmorrow> hmm, weird
18:06:16 <ImInYourMonad> can I prove a function length on lists in Coq?
18:06:36 <dolio> Prove what?
18:07:26 <ImInYourMonad> that it works for all inputs of lists?
18:07:36 <mmorrow> Igloo: oh nice, it's fixed (somehow)
18:08:50 <dolio> length would be a total function in Coq, so there's nothing to prove there, really.
18:09:42 <Saterus> any obvious tips to get rid of indentation errors?
18:09:51 <mmorrow> Saterus: don't use tabs
18:10:16 <Saterus> mmorrow: not using tabs. i'm getting a parse error at column 0 of a line.
18:10:47 <mmorrow> hmm. that was the only "obvious" tip i could think of :)
18:10:54 <psygnisfive> in case this hasn't be linked to yet: http://infosthetics.com/archives/2009/03/graphing_dependencies_in_the_haskell_package_universe.html
18:12:47 <Saterus> mmorrow: thats fair. its just frustrating to get held up by "possibly incorrect indentation".
18:21:34 <ImInYourMonad> dolio: total?
18:24:22 <dolio> Has a well-defined result for every element of the domain.
18:31:27 <ImInYourMonad> dolio: do you mean an implementation sia enough of a proof? how?
18:33:03 <dolio> There is no undefined value in Coq like there is Haskell, so any function with type [a] -> Natural in Coq works for all lists, returing a well-defined natural number.
18:33:16 <mmorrow> Saterus: yeah, it's a pita initially, but once you get it down, you forget it's even there
18:34:42 <Saterus> mmorrow: its just irritating to follow along with RWH and get to a point where the example wont compile for no apparent reason.
18:35:11 <dons> bah
18:35:24 <dons> i'm sorry if there are bugs. submit bug reports (or discuss on the mailing list)
18:36:09 <ivanm> dons: did you see my previous question to you? ;-)
18:36:30 <dons> checking...
18:36:43 <dons> no, didn't know about sourcegraph
18:36:45 <dons> is it on reddit?
18:36:53 <dons> s/reddit/hackage/
18:37:01 <ivanm> yes ;-)
18:37:01 <monochrom> If you define a recursive function in Coq, Coq makes you write a terminating proof.
18:37:11 <monochrom> s/terminating/termination/
18:37:23 <dons> ah yes, i remember "use graph theory"
18:37:25 <ivanm> dons: I'm waiting for matthew-_ to approve changes to his graphviz module before I update any further
18:37:35 <dons> i don't know how to use it.
18:37:38 <dons> ok.
18:37:45 <ivanm> atm, it only generates html report
18:37:46 <dons> why not post about what kind of visualizations it can do
18:37:58 <ivanm> dons: I did, IIRC... >_>
18:38:00 <dons> i think i only didn't remember it through forgetfulness
18:38:06 <Saterus> dons: i don't think its the book. there are 6 comments on that block of code, none of them are people mentioning it won't compile. that's why i was asking about common indentation mistakes i may have made.
18:38:21 <dons> Saterus: ah ok.
18:38:26 <ivanm> dons: but I'm planning on getting it working to just do visualisations if you want once graphviz has been updated
18:38:37 <dons> cool
18:40:00 <idnar> monochrom: what about corecursion?
18:40:09 <hax-> Selling "PayPal Bruteforcer" v. 1.0b1 by PHC2 Underground Hacking Crew [$20] - query if interested
18:40:24 <monochrom> Its builtin types don't do corecursion IIRC.
18:40:34 <dolio> They do.
18:40:48 <dolio> In that case you have to write productive functions.
18:41:48 <idnar> why on earth would you advertise "underground hacking" software in #haskell?
18:42:15 <ivanm> idnar: AFAICT, it's called SPAM
18:42:36 <idnar> ivanm: well, yes; I think "PHC2 Underground Hacking Crew" needs a new director of sales & marketing
18:43:21 <Botje> maybe it's written in haskell!
18:43:25 <dolio> cabal install paypal-cracker
18:43:30 <Botje> giggle
18:43:37 <Botje> let's put these bastards out of a job! :)
18:43:54 <dolio> Take that, Harrop! Does OCaml have illegal cracking utilities?
18:44:13 <ivanm> dolio: lol
18:44:38 <ivanm> @remember dolio [regarding a paypal spam message on #haskell] Take that, Harrop! Does OCaml have illegal cracking utilities?
18:44:38 <lambdabot> It is forever etched in my memory.
18:44:52 <ivanm> only if someone @flush's, anyway...
18:45:04 <Botje> until then it's etched in crayon?
18:45:25 <ivanm> nah, finger-paint
18:47:43 <gnut> would you ever use StateT on State?
18:48:08 <gnut> if you wanted two different things to keep track of?
18:48:31 <Botje> probably easier to lump the two states together, then
18:48:57 <gnut> but then you would have to modify one of them each time you want to change the other?
18:49:19 <Botje> that's what first and second in control.Arrow are for ;)
18:49:20 <gnut> say you have a state that evolves
18:49:29 <gnut> Botje: oh... let me look at that
18:49:36 <Botje> :t first
18:49:38 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
18:51:59 <gnut> say I have a state vector that evolves (ODE), and that I want to keep track of the last component of the vector throughout the evolution
18:52:50 <gnut> so I have one state (the current state including all components), and the other is just the time evolution of the last component
18:54:01 <gnut> so I would have one State type... but what if I decided I wanted to keep the first component. Would I need to redefine my State type that includes the evolving part?
18:54:21 <gnut> not so good if I wanted to make this a library
18:55:56 <Botje> i see your point
18:56:04 <Botje> yeah, then it'd be worthwile
18:56:26 <Botje> but i thnk you're better off with writerT state, then
18:58:46 <gnut> so two writerT's?
18:59:07 <Botje> nah
18:59:11 <gnut> I mean... writerT on top of writer?
18:59:33 <Botje> you're going to be reading that state back, right?
18:59:48 <gnut> yeah
18:59:53 <gnut> oh
18:59:55 <gnut> sorry
18:59:57 <gnut> brain fart
19:00:01 <Botje> i'd go for writerT state then
19:00:06 <gnut> you mean writerT on top of State
19:00:09 <Botje> yeah
19:00:14 <gnut> hehe... sorry
19:00:55 <gnut> Botje: yeah... that makes sense... read it out only at the very end with writerT
19:01:00 <gnut> thanks for the tip.
19:02:31 <Botje> you can vary the monoid used with WriterT
19:02:41 <Botje> eg Last a
19:02:44 <Botje> or [a]
19:02:55 <Botje> or even take averages if you write it
19:03:04 <ImInYourMonad> how would higherorder functions woth without garbage collection? like vould you ad hof to C by extending the compiler for it only? or would you need to change the semantics of the language?
19:03:32 <bd_> ImInYourMonad: C++0x has higher order functions without GC
19:03:41 <Botje> if you don't have closures HOFs are easy
19:03:46 <Botje> then they're just code pointers
19:03:53 <bd_> although it may use refcounting
19:04:32 <bremner> even closures can be managed without GC. I'm not saying it's a good idea, but C++ can do it
19:04:41 <ImInYourMonad> hmm now i get clousre si think.
19:05:38 <bremner> (purists may disagree, I'm thinking of some object with () overridden faking a closure)
19:06:04 <ImInYourMonad> blarf q xs = map (\x -> q+x) xs; tats a closure since it uses a variable from outside the lambda? whereas blarfan xs = map (\x -> x+1) xs;is not a closure,jsut a lambda?
19:06:29 <Botje> correct
19:06:36 <Cale> Ugh, neither is a closure.
19:06:54 <ImInYourMonad> damn
19:07:04 <tibbe> Cale has IRC highlighting set up for the word "closure"
19:07:11 <ImInYourMonad> lol
19:07:15 <Cale> nah, I just happened to look at the discussion
19:07:29 <Cale> A closure is a data structure which is part of a possible implementation mechanism for first class functions.
19:07:44 <tibbe> Cale: I'm just kidding
19:08:40 <Cale> It's a pair consisting of a bunch of code (in one representation or another), possibly with some free variables, together with a mapping which assigns values to those free variables.
19:09:12 <Cale> gah, quit.
19:09:20 <ImInYourMonad> also, when you map over a list, do they have structual sharing then? what could they share?
19:09:23 <ImInYourMonad> does it use a closure?
19:09:33 <Cale> ImInYourMonad: Are you asking about GHC, or Haskell?
19:09:34 <ImInYourMonad> imissed if u answered btw
19:09:40 <ImInYourMonad> ghc
19:09:48 <Cale> A closure is a pair consisting of a bunch of code (in one representation or another), possibly with some free variables, together with a mapping which assigns values to those free variables.
19:10:12 <monochrom> A closure is a function f:P->P (P is assumed to be a poset) satisfying x<=f(y) iff f(x)<=f(y).
19:10:13 <tibbe> Cale: there's no non-operational interpretation of the word?
19:10:20 <Cale> monochrom: hahaha
19:10:25 <Cale> tibbe: Right.
19:10:28 <ddarius> monochrom: That's a closure operator.
19:10:53 <Cale> tibbe: At least, not in my lexicon. People use the word "closure" sometimes when they really want to say "function", but that's bad.
19:11:04 <tibbe> Cale: OK
19:12:14 <Botje> @tell gnut http://blog.sigfpe.com/2009/01/haskell-monoids-and-their-uses.html ; check "the product monoid" for tracking two values with just one Writer
19:12:14 <lambdabot> Consider it noted.
19:13:21 <Cale> ImInYourMonad: So, if you want to know about how GHC represents functions... the first paper you probably want to read is the STG machine paper.
19:14:33 <Cale> ImInYourMonad: But, it's not actually terribly important for understanding Haskell, or even the general performance of Haskell programs. (It might be useful for finer scale performance tweaks though)
19:16:12 <Cale> ImInYourMonad: What's more important is understanding how expressions get evaluated under lazy evaluation, because that's a pretty good rough approximation of how your program will actually run -- optimisations will change that around a bunch of course.
19:16:58 <Cale> ImInYourMonad: Connection issues?
19:17:03 <ImInYourMonad> yup
19:17:13 <Cale> Did you get my responses?
19:17:23 <ImInYourMonad> yes
19:17:25 <ImInYourMonad> thnx
19:19:57 <Cale> If you still really care about how the language gets run on real hardware, I can get you the STG machine paper, but it doesn't really reflect how I think about Haskell programs evaluating.
19:21:26 <ImInYourMonad> well get me? isnt it published online? if it is not to much work for you id like to see it
19:21:33 <Cale> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3729
19:21:42 <Cale> (just had to google :)
19:22:07 <Cale> There are pdf/ps links in the upper right of the yellow bit there.
19:23:39 <Cale> Myself, I just think of functions evaluating by substituting the parameters into the body, and introducing a 'let' whenever a parameter occurs more than once, to ensure that when it gets evaluated, the work is shared between the copies.
19:23:59 <monochrom> me too
19:24:25 <Cale> No need to worry about anything lower-level than that most of the time.
19:25:23 <monochrom> hell, Launchbury too.  "A Natural Semantics for Lazy Evaluation".  uses "let" for heap and sharing.
19:26:45 <dons> great paper, btw.
19:26:55 <dons> (even if he is my boss ;)
19:26:59 <monochrom> haha
19:27:13 * dons doesn't think jl reads the logs
19:27:17 <edwardk> @hpaste
19:27:17 <lambdabot> Haskell pastebin: http://hpaste.org/new
19:27:53 <monochrom> Operational semantics tend to be messy. HIs is not.
19:28:16 <dons> not to be confused by "An adequate operational semantics of sharing in lazy evaluation"
19:28:22 <edwardk> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2626#a2626 <-- hrmm, has anyone seen a monoid like this one for tracking position in a file incrementally?
19:28:56 <dons> some kind of cursor?
19:28:59 <edwardk> the 'Pos' constructor can be used when parsing #line pragmas, the others accumulate delta position, partial information about tabs and line counts, etc.
19:29:31 <edwardk> use with a finger tree to tell the position of an arbitrary char when relexing the file
19:29:51 <edwardk> put it together for an incremental parser i'm using in kata
19:29:59 <edwardk> and realized i'd never seen it before
19:31:44 <edwardk> i was to see if i can use this, along with a monoid that just adds up byte counts and one that transforms layout stacks to fully incrementalize my lexer
19:31:51 <edwardk> er want
19:32:22 <edwardk> i wound up needing something like this because otherwise changes to the middle of a file would invalidate all positions after it in the file
19:33:25 <inimino> edwardk: are you working on Yi?
19:33:37 <edwardk> dons: its more of a 'what file/line/col do i report' monoid.
19:33:48 <edwardk> inimino: nah, this is for something else actually
19:34:02 <inimino> oh, well it sounds interesting
19:34:18 <edwardk> used with a fingertree it can tell you lines and columns incrementally
19:34:18 <ivanm> edwardk must be writing a rival haskellian editor! :o
19:34:21 <ivanm> zi? :p
19:34:26 <inimino> I want to do something very similar
19:34:32 <edwardk> ivanm: hah, nah, actually its inside the parser for my toy language
19:35:09 <edwardk> i'm trying to see if i can keep the parser entirely incremental so that it could be used online for things like syntax highlighting, etc.
19:35:38 <inimino> exactly
19:35:39 <edwardk> and relex just by updating the fingertree for the file
19:36:37 <edwardk> i was originally also tracking byte count, but that of course always just adds, so i can factor that out into just using the Sum monoid and pairing it with this Pos one
19:37:11 <edwardk> i also need to make this more complicated to handle partial utf-8 chars on the left and right of any pos
19:37:28 <edwardk> that way if you parse files in 4k rigid chunks or something it yields valid results
19:37:55 <inimino> hrm, wouldn't it just deal with streams of characters?
19:38:24 <edwardk> inimino: right now, yes, but i want it to deal with streams of bytes
19:38:55 <inimino> I'd think you'd bury that one layer down
19:39:04 <edwardk> i thought about it
19:39:52 <edwardk> might wind up being the way to go, build a utf8 parsing monoid, and just use this on the fully formed chars in the middle
19:40:05 <inimino> I seem to recall something similar with Iteratee but it was a while since I looked at it
19:40:06 <edwardk> where the monoid tracks the fragments on the ends
19:40:19 <inimino> yeah
19:40:25 <edwardk> utf8 parses backwards and forwards so i kinda like that
19:40:45 <edwardk> ok, thats the plan =)
19:40:55 <inimino> what do you mean backwards?
19:41:51 <edwardk> you can tell if you're looking at a byte in the tail of a valid char from the utf-8 encoding of that byte.
19:42:03 <inimino> oh, right
19:42:10 <inimino> just check the high bit
19:43:13 <inimino> I right, I see, at the beginning of a chunk
19:43:16 <edwardk> so something that held onto up to 3 bytes on the left, up to 3 bytes on the right, and the result of mapping all intermediate chars to the monoid and applying the monoidal operation would be ideal
19:43:34 <edwardk> with some action for invalid characters
19:44:00 <inimino> and invalid byte sequences, yeah, sounds like a plan
19:44:17 <edwardk> alright adding the other monoid
19:44:24 <inimino> :)
19:44:54 <edwardk> this is winding up surprisingly clean.
19:45:02 <edwardk> the layout monoid will suck, but the rest is nice =)
19:46:51 <ImInYourMonad> doesnt coq have a way to test for eq on naturla numbers?
19:48:00 <SamB> ImInYourMonad: of course it does!
19:48:14 <SamB> why do you ask?
19:48:35 <SamB> and, er, wouldn't it make more sense to ask in #coq?
19:49:45 <SamB> anyway, try looking in the coqdocs
19:50:03 <rovar> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1931#a1931
19:50:17 <SamB> and maybe play with some of the search commands, perhaps mediated by proof general
19:50:42 <rovar> on line 137, I'm attempting to pass a GADT from a monad into a list comprehension.. and doing something stupid apparently
19:51:35 <rovar> i added the error message as well.
19:52:04 <rovar> o should be a  [(a, b)]   and I want to make a [b]
19:52:51 <idnar> rovar: you can't use !! on tuples
19:52:56 <rovar> oh
19:52:59 <idnar> try snd
19:52:59 <rovar> well that'll do it
19:53:04 <rovar> duh
19:53:06 <ImInYourMonad> SamB how?
19:53:07 <rovar> thanks :)
19:53:16 <idnar> :)
19:53:35 <rovar> and it compiles.. sad. i would have stared at that for another half hour
19:56:15 <SamB> ImInYourMonad: how which?
19:56:55 <SamB> just open up tabs for the coq tutorial, manual, and library documentation
20:00:05 <ivanm> @doc Not
20:00:05 <lambdabot> Not not available
20:00:15 <ivanm> does that mean it _is_ available? :o
20:05:54 <zeno> mmorrow: still there?
20:06:32 <ImInYourMonad> nat == nat
20:07:14 <MyCatVerbs> ImInYourMonad: that's implied by the derivable definition of Eq. :)
20:07:25 <MyCatVerbs> ImInYourMonad: except when nat contains bottoms. =D
20:10:10 <rovar> I'm trying to run Data.Binary.Get  with runGet, it says it expects a ByteString, however, I load a file into a ByteString and get:
20:10:20 <rovar>     Couldn't match expected type `Data.ByteString.Lazy.Internal.ByteString'
20:10:21 <rovar>            against inferred type `ByteString'
20:11:15 <sjanssen> rovar: you're trying to use a lazy ByteString as a strict ByteString
20:11:49 <rovar> how do I explicitly use a strict bytestring, because I thought i was?
20:12:10 <rovar> i've tried Data.ByteString and Data.ByteString.Char8
20:12:45 <rovar> f <- C8.readFile "basic_types/array.bson"
20:14:33 <sjanssen> rovar: both Data.ByteString and D.B.Char8 are strict ByteString
20:14:59 <sjanssen> rovar: binary uses lazy ByteString, found in D.B.Lazy.ByteString
20:15:10 <rovar> kay
20:15:23 <sjanssen> so use that module
20:17:18 <rovar> right.. that worked
20:19:05 <rovar> man.. i love how Haskell just works
20:19:11 <rovar> once I get it  to compile :)
20:19:57 <rovar> i've been working on a parser for a binary encoding (BSON) off and on for the last couple weeks in the evenings when I could get to it
20:20:17 <rovar> my 1st test case was a binary blob of an object containing an array of strings..
20:20:21 <rovar> it worked
20:26:56 <dons> rovar: using Data.Binary?
20:27:04 <dons> that's mega sweet
20:27:10 <rovar> dons:  Data.Binary.Get
20:27:14 <dons> yay
20:27:23 <rovar> :)
20:27:28 <dons> step 2. release on hackage ; step 3. .... ; step 4. profit!
20:28:02 <rovar> step 1.5 test a lot more.  step 1.75, finish the rest of the MongoDB drivers then on to step 2
20:28:10 <TomMD> Step 3 must be start a company or get hired.
20:28:25 <dons> TomMD: hey!
20:28:34 <TomMD> Hey dons, how are things?
20:28:38 <rovar> the downside is that I am already hired and have a company :)
20:28:55 <rovar> so my hacking time is rather short
20:29:23 <kerlo> Hey, now. Everyone knows that the number between 1.5 and 2 is 1.7.
20:29:29 <jfredett> hrm, anyone here know about doing typeable instances for types w/ monads in them? eg, a typeable instance for ReaderT (which has kind * -> (* -> *) -> * -> * ?
20:30:21 <sjanssen> jfredett: hmm, I don't think Typeable can do higher-kinded types
20:30:28 <jfredett> damn damn damn damn.
20:31:05 <travisbrady> rovar: how are you finding mongodb so far?  we've been looking at it at work, but are somewhat scared by the license
20:31:17 <jfredett> sjanssen: Theres no way I can dynamically import this code as is then... perhaps I can hack my way around it...
20:31:21 <jfredett> thanks.
20:31:36 <sjanssen> jfredett: use a newtype?
20:31:52 <rovar> travisbrady: it's pretty nice, I've only run tests in C++ because I plan to use it with my happstack web services.
20:31:59 <jfredett> well, that causes lots (in the dozens) of type errors, which I would like to avoid having to resolve.
20:32:05 <sjanssen> newtype MyMonad a = MM (ReaderT MyEnv IO a) -- will work
20:32:11 <rovar> So I haven't pushed it too far.. but prelim tests are all valid and very fast.
20:32:18 <jfredett> I think I can just put a little more work on the interpreter
20:32:20 <sjanssen> jfredett: if you're using mtl correctly, it should be a snap to fix :)
20:32:34 <jfredett> sjanssen: thats the issue, I'm probably not. :P
20:32:40 <sjanssen> jfredett: in fact, it is almost never a good idea to program against transformers directly
20:32:43 <jfredett> I don't really use mtl _that_ much.
20:32:45 <travisbrady> rovar: cool, incidentally i just built a interface to tokyo cabinet/tyrant using Data.Binary.Put/Get and was thinking of taking a crack at BSON next
20:33:01 <sjanssen> always abstract with at least a type synonym, and preferably with a newtype
20:33:10 <travisbrady> rovar: is your stuff on github or somewhere else viewable?
20:33:22 <rovar> travisbrady: its feature set is pretty amazing. If you search by regex, if it is a simple enough regex, it will know to use an index if there is one
20:33:31 <jfredett> sjanssen: well, if thats best practice. I suppose it's better just to deal with it now.
20:34:00 <travisbrady> ahh, i'd heard they define a binary serialization for regexes actually
20:34:01 <rovar> travisbrady: Currently I just have a single file that just does gets and puts of the BSON values, 90% untested :)
20:34:03 <sjanssen> jfredett: you can use generalized newtype deriving to make it quite pleasant
20:34:28 <jfredett> sjanssen: but since ReaderT doesn't have a typeable instance, it dies a painful death.
20:34:40 <travisbrady> Put and Get took me a little getting used to but i actually really like the interface now and find it very readable
20:34:42 <BMeph> Does anyone here use patch-tag with some regularity? :)
20:34:42 <rovar> travisbrady: they do in a sense, but that's just for communication to the server.. i guess you could store it if you want
20:34:50 <jfredett> I actually tried that a while ago, but I thought I had found a way around it...
20:34:56 <sjanssen> jfredett: right, but GHC will be able to use normal newtype deriving for your newtype
20:35:07 <sjanssen> jfredett: generalized newtype deriving is for deriving MonadReader, MonadIO, etc.
20:35:10 <rovar> yea.. I handle all but 3 of the data types and It's at 137 lines of code :)
20:35:13 <sjanssen> oh, and Monad of course :)
20:35:45 <dons> BMeph: i've seen people are starting to
20:35:51 <dons> BMeph: pumpkin does
20:35:51 <sjanssen> s/normal newtype deriving/normal deriving
20:36:07 <jfredett> sjanssen: i'm confused, now -- should I do newtype Filter a = Filter $ ReaderT (Config, Email) IO a -- or some fancy business w/ MonadReader?
20:36:14 <rovar> BMeph: I use it, but only because I work on happstack :)
20:36:19 <jfredett> sjanssen: mtl makes my head HurtT.
20:36:26 <beekor> i'm just about brand new at haskell, and i realize that it's sorta depressing to be in here and just have nooo cluuuee what you guys are talking about.   i guess i may figure it out evenutally though.
20:36:29 <jfredett> err, HurT.
20:36:59 <sjanssen> jfredett: newtype Filter a = Filter (ReaderT (Config, Email) IO a) deriving (Monad, MonadReader (Config, Email), MonadIO)
20:37:04 <dons> beekor: it is just a matter of time and thinking :)
20:37:05 <dons> welcome!
20:37:19 <sjanssen> jfredett: also Typeable and Functor
20:37:20 <rovar> beekor, I'm just learning too. It will be frustrating for at least 2 months
20:37:20 <beekor> ha.  hey thanks dons.
20:37:21 <jfredett> beekor: thats the best part- cause in about 3-6 months, you'll be tossing around awesome words like this to your friends, and you'll sound like an Ubergeek
20:37:41 <SubStack> it's true
20:37:50 <jfredett> sjanssen: aah
20:37:54 <dons> dropping `par` with your mad skills
20:37:55 <jfredett> I <3 deriving.
20:38:11 * sjanssen tends to say "monadic parser combinators" to non-technical friends to see them boggle
20:38:20 <jfredett> beekor: you'll be all, "I'm all up in your Monad, biatch."
20:38:32 <beekor> haha.  okay.
20:38:43 <sjanssen> that has to be one of the nerdiest string of characters in existence
20:39:04 * SubStack drops "monadic" in more conversations than he'd like to admit
20:39:05 <TomMD> beekor: Next thing you know, you'll be moving to Portland or Cambridge and writing papers about new concepts in type systems.
20:39:05 <rovar> multivariant catamorphism
20:39:20 <SubStack> morphisms \m/
20:39:33 <lament> everything sounds better with -morphism at the end
20:39:51 <lament> morphomorphism
20:39:53 <rovar> what is the deal? I used to live in Wa state, why didn't I know about OGI and company when I lived there, I would have been down every week for the tech talks
20:39:57 <SubStack> metamorphism
20:40:11 <rovar> now I'm in NYC and want to visit
20:40:24 <lament> oh jeez, i googled for morphomorphism, the hits are all in the log for this channel
20:40:32 <SubStack> too bad the geologists already took metamorphism
20:40:33 <rovar> haha
20:40:38 <lament> (okay so it's one hit)
20:40:54 <rovar> what you're seeing is the realtime google indexing of this channel
20:40:59 <SubStack> metamorphomorphism
20:41:10 <rovar> it's kind of like that scene in spaceballs, where they're watching the moving in the movie
20:41:15 <rovar> movie
20:41:19 <rovar> in the movie
20:41:36 <dons> sjanssen: it would be nerdier if it had delimited control
20:41:51 <dons> or possibly type-indexied delimited continuation-based monadic parser combinators
20:42:04 <dons> as a certain glguy brought to my attention at work today :)
20:42:19 <sjanssen> dons: whoa, do those actually exist?
20:42:50 <dons> i didn't think type-indexed delimited continuations did, stacked on monads. i bet you can use them to write parsers too :)
20:43:01 <jfredett> sjanssen: Error with MonadIO deriving, it doesn't have arity 1... but perhaps I can do that on my own... :/
20:43:02 <SubStack> topological functor metamonomorphomorphism combinators
20:43:16 <jfredett> sjanssen: thanks for the suggestion, anyway. :)
20:43:19 <dons> zygoprepomorphisms are also nerdy
20:43:35 <rovar> ooh.. continuation-based parser combinators?
20:43:39 <idnar> nerdymorphisms
20:43:43 <lament> zygoprepomorphisms sound biological
20:43:47 <dons> makes oleg tremble.
20:43:49 <rovar> is there a paper on this?
20:44:02 <SubStack> 0 results
20:44:15 <rovar> is there a googlebot in the house?
20:44:16 <dons> rovar: yes!
20:44:17 <dons> http://209.85.173.132/search?q=cache:b_hXVpFPqhUJ:people.cs.uu.nl/doaitse/Papers/1999/SofSem99.pdf+continuation+parser+combinators&cd=1&hl=en&ct=clnk&gl=us
20:44:31 <SubStack> crazy mathemagicians
20:44:34 <rovar> perfect
20:44:41 <dons> a certain  Doaitse Swierstra has written a paper describing continuation-based parser combinators
20:44:41 <sjanssen> jfredett: deriving MonadIO should definitely work with the definition I gave you
20:44:51 <dons> now, to just add delimited control to it
20:44:56 <jfredett> OOH! I added a space between monad and IO.
20:45:03 <jfredett> I'm a dipshitonastickomorphism.
20:46:50 <rovar> jfredett, which facet of category theory does that one come from?
20:47:44 <jfredett> rovar: the category containing only bottom? (I don't grok the CT yet... so my joke is probably lame... :()
20:48:04 <jfredett> then again, it'd be lame even if I did grok the CT.
20:48:16 <zachk> i grab bottom
20:48:18 <rovar> so that would be the category theory describing category theory
20:48:28 <jfredett> rovar: sure.
20:48:54 <rovar> oh well.. time for sleep
20:49:42 <jfredett> sjanssen: one more question -- do I need to pattern match to get to the Reader stuff? or can I do it without prying open Filter?
20:50:14 <sjanssen> jfredett: well, you should only need to get to the ReaderT to finally execute it
20:50:24 <sjanssen> jfredett: and to do that you can use pattern matching, or add a record accessor
20:50:51 <jfredett> fair enough. I think I only really, "access" the thing once anyway, after that it's wrapped up in a record...
20:52:18 <jfredett> ... sjanssen, you beautiful bastard... no type errors... none at all...
20:52:51 * jfredett reclines, equal parts mystified and terrified at the awesomeness of sjanssen haskell-fu.
20:52:52 <ozy|> I just realized haskell is the perfect language to use for programming giant robots
20:53:06 <ozy|> what other language has "newtype" as a keyword?
20:53:12 <jfredett> ozy|: or tiny, insidious robots with lots of teeth.
20:54:13 <sjanssen> jfredett: don't thank me, thank type classes!
20:54:26 <jfredett> sjanssen: lol, Thank you, Type classes!
20:55:12 <idnar> R-type!
20:55:33 <zachk> are haskell arrays stored as associated lists?
20:55:46 <zachk> er can i use that model to mess with them
20:56:03 <dons> arrays are stored as arrays in memory
20:56:07 <sjanssen> zachk: Data.Array arrays?  No, those aren't association lists
20:56:19 <sjanssen> @src Array
20:56:19 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
20:56:27 <dons> the src for Array is kinda big
20:56:33 <sjanssen> data Array i e = GHC.Arr.Array !i !i !Int (GHC.Prim.Array# e)
20:56:46 <zachk> im using Array, should i be using Data.Array?
20:56:47 <SubStack> awk and php are the only languages that I can think of where arrays and hashes are the same thing
20:56:55 <sjanssen> Array lowerbound upperbound size (ArrayPrimitive containing actual elements)
20:57:11 <dons> zachk: they're the same, you're just using a 1998 namespace
20:57:14 <sjanssen> zachk: Array is the old name, Data.Array is the preferred name
20:57:16 <ozy|> SubStack: you forgot Polan--er, Lua
20:57:22 <SubStack> oh right
20:57:25 <sjanssen> or Data.Array.IArray if you think you might need unboxed arrays
20:57:28 <zachk> sjanssen: ah ok
20:57:29 <SubStack> but when Lua does it it's cool
20:57:38 <dons> Data.Array.Unboxed is what I use.
20:57:51 <dons> the array interface is a bit weird
20:58:00 * sjanssen hands dons some lists to put in that UArray
20:58:13 <pumpkin-> omg I'm in SF
20:58:15 <idnar> yo dawg we heard you like arrays
20:58:19 <sjanssen> WHERE ARE YOUR BOXES NOW?
20:58:28 <SubStack> s/^yo/sup/
20:58:53 <SubStack> pumpkin-: I was in SF for a few hours once
20:58:59 <zachk> this conversation is da bomb
20:59:11 <dons> sjanssen: why do you import IArray?
20:59:18 <dons> or is tha the type
20:59:33 <sjanssen> oh, does Unboxed reexport the class?
20:59:39 <dons> oh, mutable/immutable
20:59:44 <dons> -- Immutable arrays, with an overloaded interface.  For array types which
20:59:44 <dons> -- can be used with this interface, see the 'Array' type exported by this
20:59:44 <dons> -- module, and the "Data.Array.Unboxed" and "Data.Array.Diff" modules.
21:00:16 <sjanssen> yeah, seems Unboxed does export IArray.  Handy
21:00:31 <dons> it's kinda my baby UArr
21:00:35 <dons> MUArr
21:02:10 * BMeph longs to see someone stuff Harrop in an STFUArr...
21:02:51 <pumpkin-> you need an unboxed box!
21:02:51 <pumpkin-> UBox
21:03:11 <dons> dude wat did u do with my box? it was right here!
21:03:16 <zachk> Uboxing.got.teef?!!
21:05:03 <zachk> > let u=array ('a','z') $ zip ['a'..'z'] [1..26] in u!'z'
21:05:05 <lambdabot>   26
21:05:23 <zachk> so why do i need az twice
21:06:21 <sjanssen> zachk: arrays are statically sized, so the first listing is required to determine the size
21:06:55 <sjanssen> > let u = listArray ('a', 'z') [1 .. 26] in u ! 'z' -- only list the bounds once
21:06:56 <lambdabot>   26
21:07:22 <ivanm> dons: you seen this? http://www.reddit.com/r/programming/comments/862r1/haskell_wank_dons_fails_to_rebut_claims_about/
21:07:42 <pumpkin-_> o.O
21:07:44 <sjanssen> ivanm: hahahaha
21:07:59 <dons> mwhaha
21:08:01 * ivanm thinks it's a harrop fanboi claiming this
21:08:11 <dons> it's weird that they've formed an alliance.
21:08:25 <dons> we need to get some new posts on http://harrop-highly.blogspot.com/
21:08:30 <dons> all about his wackiness
21:08:37 <ivanm> dons: have you been annoying harrop's wife? :o
21:08:41 <sjanssen> ivanm: no, ayrnieu just really dislikes Haskell for some reason
21:08:54 <dons> he used to hang out here in 2004 or so
21:09:07 <sjanssen> proggit is starting to turn into a reality TV show.  Like MTV's Real World or something
21:09:16 <sjanssen> but with code instead of alcohol and sex
21:09:19 <lament> harrop is my god
21:09:22 <ivanm> sjanssen: "The Biggest Redditor!"
21:09:27 <lament> i aspire to be the perfect troll
21:09:31 <ivanm> lament: an evil god?
21:09:35 <bos> proggit is really terrible these days. a complete waste of bits.
21:09:39 <lament> but to be the perfect troll i'd have to kill harrop first, since there can be only one
21:10:19 <dons> the haskell reddit is on its upcurve, imo. it's not quite got enough userbase yet, but it might reach some nice place.
21:10:30 <sjanssen> bos: there are a few gems here and there.  http://www.reddit.com/r/programming/comments/85trh/understanding_ssds/ was highly interesting
21:10:31 <ivanm> lament: Two there are... a master and an apprentice...
21:11:31 <ivanm> sjanssen: here's another gem ( :p ): windows fixes case issues for URLs! ;-) http://www.reddit.com/r/programming/comments/862n8/how_do_i_make_my_url_not_case_sensitive/
21:11:44 <dibblego> yo
21:11:53 <ivanm> yoyo
21:12:11 <dons> ivanm: you should check http://coding.derkeiler.com/Archive/Lisp/comp.lang.lisp/2007-05/msg01440.html for a study of the master
21:12:42 <ivanm> dons: you mean harrop _isn't_ the master? :o
21:12:47 <ivanm> oh, wait, they're _talking_ about harrop
21:12:57 <ivanm> *talking _about_
21:13:26 <dons> the lisp guys were at it for years before we discovered him
21:13:35 <ivanm> lucky us :s
21:13:46 <dolio> He discovered us.
21:13:49 <ivanm> dons: so that means he's badgering you (and through you us) instead of them?
21:14:04 <ivanm> dolio: he "discovered" us, in the sense that a studio "discovers" a new singer?
21:14:05 <bmh> dons: is this an appropriate place to discuss GSOC?
21:14:19 <ivanm> so we're only beginning to become well known because of harrop? :o
21:14:22 * ivanm faints
21:14:41 <ivanm> bmh: there's also #haskell-soc IIRC
21:15:09 <ivanm> dons: btw, where can I get cryptol from?
21:15:14 * ivanm that it was on hackage, but it isn't
21:15:26 <ivanm> I want to compare the speed/efficiency of the cryptol sudoku solver
21:15:27 <dolio> No, it's more like, "I discovered my house has an additional toilet I didn't previously know about."
21:15:27 <bmh> ivanm: looks like a lively chat in there :)
21:15:41 <ivanm> bmh: since I'm not in there, I have no idea ;-)
21:15:46 <ivanm> dolio: lol
21:15:57 <ivanm> well, an additional toilet could be useful... >_>
21:16:04 <dolio> It's called the sink!
21:16:29 * ivanm resolves never to go to dolio's house
21:16:29 <bmh> (zing)
21:18:22 <dons> ivanm: hmm. you can download binaries
21:18:42 <ivanm> no source? :(
21:18:46 <dons> there's a big download button on the cryptol page (the interpreter is free)
21:18:55 <ivanm> due to copyright or the yankee crypto exporting laws?
21:18:57 <dons> i suppose it is possible the interpreter could be open sourced, i've not heard.
21:18:59 <ivanm> @where cryptol
21:18:59 <lambdabot> I know nothing about cryptol.
21:19:03 <ivanm> @go cryptol
21:19:03 <lambdabot> http://www.cryptol.net/
21:19:08 <dons> the idea is to use the interpreter for teaching crypto
21:19:25 <ivanm> *nod*
21:19:47 <ivanm> dons: do I get the "trial" version?
21:19:50 <dons> actually, uminho and cincinatti started using it this week for coursees
21:19:58 <dons> ivanm: i think that's it yes. it's the full interpreter (ghci-like)
21:20:04 <ivanm> *nod*
21:20:04 <dons> not the vhdl or verifier
21:20:18 * dons imagines putting the sudoku solver in an fpga.
21:20:19 <ivanm> OK, in that sense there's no point in me trying to do comparisons if I"m comparing interpreters
21:20:28 <sjanssen> ivanm: though according to the terms you're only allowed to use it for one year :(
21:20:32 <ivanm> dons: FPGA?
21:20:34 <dons> sjanssen: oh :/
21:20:36 <ivanm> sjanssen: :(
21:20:39 <dons> hmm. i'll ask about that
21:21:08 <dons> the language is intended to be a standard, so  the interpreter needs to be clearly free and open
21:21:28 <ivanm> dons: does the full version convert to haskell, or straight to machine code?
21:21:43 <dons> C and VHDL and Haskell
21:21:54 <dons> but the valuable thing is the verifier
21:21:55 <ivanm> oh, wait, I thought it was just Haskell...
21:22:04 <dons> to show that say, schenier's C version of blowfish matches the spec
21:22:15 <ivanm> ahhhh
21:22:21 <dons> the other important thing is the vhdl backend. so you can burn your crypto into fpga
21:22:27 <ivanm> dons: did you see the recent post by schneir about blowfish on 24?
21:22:30 <dons> yeah :)
21:22:40 <ivanm> FPGA == field-programmable gate array?
21:22:45 <ivanm> or is wikipedia lying to me?
21:22:47 <dons> yup.
21:22:50 <dons> programmable hardware
21:22:54 <ivanm> *nod8
21:23:02 <dons> these guys use cryptol to build all this chip designs, http://www.signalicorp.com/
21:23:14 <ivanm> dons: so do you choose which you want it converted to?
21:23:17 <ivanm> or is it a mixture?
21:23:26 <dons> you choose
21:23:30 <dons> like the C or asm backend to ghc
21:23:54 <ivanm> well, since you presumably have access to the full thing, could you convert the cryptol sudoku solver to haskell for me so I can try using that?
21:24:37 <dons> why not the generated C?
21:25:15 <ivanm> dons: I'm more interested in how it compares to the pure haskell sudoku solvers on the wiki
21:25:24 <ivanm> though if that's all you've got, I'll take it
21:26:04 <dons> i'll ask levent at work tomorrow
21:26:19 <ivanm> oh, wait, that's right, it's night there, isn't it... >_>
21:26:21 <dons> it'd be kinda fun to have sudoku fpga benchmarks :)
21:26:27 <ivanm> heh
21:26:56 <ivanm> my main reason for caring is because I taught myself Haskell by converting bird's sudoku solver to a latin square completor/generator
21:27:02 <dons> mm.
21:27:11 <ivanm> and I'm going to be re-writing it soon (though possibly using a more graph-like approach)
21:27:28 <NameAlreadyInUse> is Either a monad?
21:27:34 <ivanm> I know bird's probably wasn't the most efficient one there (list usage, etc.), but it was the easiest for me to play with ;-)
21:27:39 <ivanm> NameAlreadyInUse: (Either a) is
21:27:52 <NameAlreadyInUse> what do you mean?
21:28:09 <ivanm> NameAlreadyInUse: Either takes in two type params (Either a b)
21:28:12 <ivanm> monads only take one
21:28:26 <ivanm> so (Either a) is a monad, just as Maybe is
21:28:29 <ivanm> @instances Monad
21:28:30 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
21:28:35 <ivanm> ^^
21:29:00 <ivanm> @src (>>=) (Either e)
21:29:00 <lambdabot> Source not found. There are some things that I just don't know.
21:29:14 <NameAlreadyInUse> oh, so "Either String" is a monad, for instance?
21:29:15 * ivanm can't remember how to get instance definitions from lambdabot 
21:29:19 <NameAlreadyInUse> @src Either (>>=)
21:29:19 <lambdabot> Left  l >>= _ = Left l
21:29:19 <lambdabot> Right r >>= k = k r
21:29:20 <ivanm> NameAlreadyInUse: yes
21:29:26 <ivanm> oh, that way ;-)
21:30:17 <NameAlreadyInUse> so how would i use it?
21:30:30 <ivanm> NameAlreadyInUse: how do you want to use it? ;-)
21:30:54 <NameAlreadyInUse> well, i have a function that can return either a data structure or a list of error messages
21:31:24 <ivanm> NameAlreadyInUse: a list of messages?
21:31:30 <ivanm> maybe you want something like Writer then...
21:31:40 * BMeph things it sounds like a Writer...
21:31:44 <NameAlreadyInUse> oh, what does Writer do?
21:31:53 <ivanm> @doc Writer
21:31:53 <lambdabot> Writer not available
21:31:57 <ivanm> @hoogle Writer
21:31:57 <lambdabot> module Control.Monad.Writer
21:31:57 <lambdabot> Control.Monad.Writer.Lazy newtype Writer w a
21:31:57 <lambdabot> Control.Monad.Writer.Lazy Writer :: (a, w) -> Writer w a
21:32:02 <ivanm> NameAlreadyInUse: acts as a logger, etc.
21:32:10 <ivanm> @doc Control.Monad.Writer
21:32:10 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Writer.html
21:32:16 <NameAlreadyInUse> oh
21:32:35 <NameAlreadyInUse> i will have a look
21:33:06 <NameAlreadyInUse> i would still like to know how to use bind, etc, on Either String
21:33:07 <Gracenotes> for monoids
21:33:16 * ivanm only knows what Writer is for because RWH turns a custom logging monad into Writer
21:33:18 <ivanm> RWH++
21:33:43 <ivanm> NameAlreadyInUse: same as Maybe, but it uses Right instead of Just, and Left "error" instead of Nothing
21:33:48 <ivanm> @karma RWH
21:33:48 <lambdabot> RWH has a karma of 2
21:33:56 <NameAlreadyInUse> if i do "Right 5 >>= return", it doesn't work for instance
21:33:58 <Gracenotes> preflex: karma RWH
21:33:58 <preflex>  RWH: 1
21:34:18 <ivanm> preflex: karma+ RWH
21:34:20 <ivanm> preflex: karma RWH
21:34:20 <preflex>  RWH: 1
21:34:35 <Gracenotes> just uses ++ notation
21:34:36 <ivanm> dammit, I was hoping that was a way of getting preflex's karma in sync with lambdabot's :s
21:34:39 <Gracenotes> preflex: karma c
21:34:39 <preflex>  c: 1143
21:34:43 <ivanm> :o
21:34:50 <ivanm> wtf? who here likes C? :o
21:34:58 <NameAlreadyInUse> i like C
21:34:59 <inimino> I like C
21:35:06 <bmh> I am Spartacus?
21:35:10 <Gracenotes> no, I am C!
21:35:14 <ddarius> I hate C, but I like C++.
21:35:21 <Gracenotes> preflex: karma c
21:35:21 <preflex>  c: 1144
21:35:22 <bmh> ddarius: What's wrong with you?
21:35:23 <NameAlreadyInUse> i am opposite
21:35:41 <kfish> ddarius, then you need to say C++++
21:35:48 <NameAlreadyInUse> i like D though
21:35:51 <ivanm> preflex: karma C
21:35:51 <preflex>  C: 1144
21:35:59 <ivanm> preflex: karma C\+\+
21:35:59 <preflex>  C\+\+ has no karma
21:36:01 <ivanm> heh
21:36:07 <ivanm> preflex: karma haskell
21:36:08 <preflex>  haskell has no karma
21:36:10 <ivanm> @karma haskell
21:36:10 <lambdabot> haskell has a karma of 49
21:36:11 <glguy> dons, what about indexed, delimited, continuation monad transformers?
21:36:13 <ivanm> :o
21:36:28 <Gracenotes> > Left "nooo" >>= return
21:36:29 <lambdabot>   Left "nooo"
21:36:30 <ivanm> how about C--? (and yes, I'm asking this just to drop C's karma...)
21:36:31 <erikc> i love C, hate C++
21:38:14 <NameAlreadyInUse> Gracenotes: does it not work for ghc, then? i can't seem to be find the Monad instance for (Either a) in the library pages
21:38:45 <Gracenotes> instance (Error e) => Monad (Either e)
21:38:47 <Gracenotes>   -- Defined in Control.Monad.Error
21:39:38 <NameAlreadyInUse> ah, thanks
21:39:59 <Gracenotes> and String is an error
21:40:13 <Gracenotes> Error seems somewhat out-of-place
21:43:10 <ivanm> Gracenotes: it's a hack, IIRC, due to type synonym constraints or something
21:43:16 <ivanm> @src Either fail
21:43:16 <lambdabot> fail msg      = Left (strMsg msg)
21:43:35 <ivanm> ^^ can't have this as well as a general "Either e" monad
21:43:52 <Gracenotes> sounds like fail to me
21:44:09 <ivanm> well, yes, it's the fail function
21:44:12 <ivanm> ;-)
21:44:21 <ivanm> @type strMsg
21:44:23 <lambdabot> forall a. (Error a) => String -> a
21:50:18 <mmorrow> zeno: yes
21:50:49 <mmorrow> what's a good doc generator for C ?
21:50:55 <ivanm> doxygen?
21:51:00 <ivanm> isn't that the main one?
21:51:20 <mmorrow> yeah, i'm trying to see if there are any nice one's i don't know about
21:51:28 <mmorrow> ivanm: (but thx :)
21:51:32 <ivanm> heh
21:51:34 <mmorrow> heh
21:51:54 <ivanm> mmorrow: http://en.wikipedia.org/wiki/Comparison_of_documentation_generators
21:51:59 <mmorrow> ivanm: nicely done
21:52:06 * ivanm takes a bow
21:52:23 <ivanm> wikipedia: a repository of links to various tools that do similar jobs
21:53:17 <ivanm> mmorrow: http://en.wikipedia.org/wiki/HeaderDoc <-- looks interesting
21:53:50 * ivanm doesn't know what doxygen uses for tags, but HeaderDoc is meant to use javadoc-style tags, if wikipedia is being understood properly
21:54:08 <mmorrow> hmm, yeah that looks possibly nice
21:54:39 <ivanm> strangely enough, Haddock is the only doc generator that claims to support Haskell... >_>
21:55:57 * BMeph is impressed that Haddock was even mentioned.
21:56:14 <ivanm> mmorrow: or even http://en.wikipedia.org/wiki/Natural_Docs
21:56:38 <pumpkin> omg
21:56:43 <djwonk> my module seems to export more than I would have expected.  (when using the command line, ghci 6.8.3)
21:57:00 <ivanm> pumpkin: what?
21:57:06 <ivanm> djwonk: it will only export what you tell it to
21:57:18 <djwonk> ivanm: that's what I was hoping
21:57:18 <sjanssen> djwonk: in interpreted mode, ghci will export every top-level function in the current module
21:57:18 <pumpkin> just getting frustrated with my internet connection on this side of the country
21:57:22 <ivanm> if you're talking about ghci, ghci Foo.hs lets you play with everything defined in Foo.hs
21:57:35 <djwonk> sjanssen: thanks, that would be consistent with what I'm seeing
21:57:36 <ddarius> pumpkin: Walk to the other side.
21:57:42 <ivanm> ddarius: lol
21:57:45 <pumpkin> :)
21:57:52 <sjanssen> pumpkin: where are you usually?
21:58:03 <ivanm> sjanssen: he's normally at home?
21:58:04 <ivanm> ;-)
21:58:16 <pumpkin> sjanssen: NH, but in Berkeley now
21:58:23 <boyscared> @quote xahlee
21:58:24 <lambdabot> xahlee says: What's left are so called computer scientist, typically morons.
21:58:31 <djwonk> sjanssen: any way to "turn off" that top-level exporting behavior?
21:58:40 <ivanm> djwonk: why?
21:58:44 <ivanm> no other module can see it
21:58:46 <ddarius> djwonk: Compile the module.
21:58:52 <boyscared> @quote xahlee
21:58:52 <lambdabot> xahlee says: i do wonder, if any reputable computer scientist would blub out such idiotic things as this thread's lispers have been.
21:58:54 <sjanssen> djwonk: you can compile it to a .o first then load it in GHC
21:58:57 <sjanssen> erm, ghci
21:59:03 <djwonk> ivanm: b/c i'm new and want to make sure i'm doing things right
21:59:05 <djwonk> sjanssen: thanks
21:59:48 <ivanm> djwonk: ummm.... OK... not sure I follow your reasoning there though :s
22:00:04 <djwonk> ivanm: you wouldn't be the first!
22:00:04 * pumpkin- grrs
22:00:05 * ivanm likes how all top-level functions are exported so that you can "play"/debug your code
22:00:23 <djwonk> ivanm: i want to try out some of the ways of encapsulating code, that's why :)
22:00:30 <pumpkin-> I should get a bouncer to avoid being so annoying for others at least
22:00:32 <ivanm> pumpkin-: want some more 'r's to put in there?
22:00:34 <pumpkin-> at least in the connect/disconnect annoyance sense
22:00:41 <mmorrow> man, i really like haddock's approach to doc generation
22:00:42 <pumpkin-> yeah, I'll add more if it happens more
22:00:44 <Cale> djwonk: another thing you could do is create a new empty module, import the one you want to check out, and load that in ghci
22:00:48 <ivanm> mmorrow: in which sense?
22:01:03 <Cale> djwonk: Then you should only see the things which are actually exported, rather than everything.
22:01:07 <ddarius> pumpkin-: Perhaps God is telling you to do something else.
22:01:14 <djwonk> Cale: interesting idea, thanks
22:01:18 <Cale> djwonk: The reason for this behaviour is to make testing internal things simpler.
22:01:34 <pumpkin-> ddarius: I have been doing something else! haven't you missed me? :(
22:01:35 <mmorrow> ivanm: in that it pulls out the important pieces, labels them by category ==> so is useful even if you don't put any markup in comments
22:01:38 <ivanm> Cale: s/simpler/possible/ ?
22:01:48 <ivanm> mmorrow: oh, yes
22:01:54 <ddarius> pumpkin-: Continue doing something else or do some other thing else, and no.
22:02:00 <Cale> ivanm: If you want :)
22:02:01 <pumpkin-> :( ok
22:02:12 <ivanm> so at least you have _some_ documentation if the dev didn't write any comments... _assuming_ they did type annotations :s
22:02:19 <ivanm> Cale: /me does :p
22:02:26 <mmorrow> ivanm: yeah, assuming type annotations
22:02:48 <mmorrow> i almost forgot those aren't required..
22:03:16 <sjanssen> I don't think they're required in Haddock 2
22:03:39 <mmorrow> i was kidding, but nice i didn't know that
22:03:50 <mmorrow> that'll be handy for sure..
22:03:51 <mmorrow> errr
22:03:55 <mmorrow> i think they are
22:04:33 * mmorrow just wants something haddock like to run over a bunch of C code and show him the important parts
22:04:50 <djwonk> matthewp:  hi, did you see the question I asked above (about exporting).  this explains our problem from last time
22:05:05 <wli> It's not that good but there is docbook.
22:05:50 <mmorrow> wli: hmm
22:06:57 <wli> The Linux kernel uses it. It won't do much unless explicit annotations were done, though.
22:08:39 * mmorrow wonders how long it would take to whip up a quicky hacky C-haddock with language-c
22:09:33 <mmorrow> pretty much just  parse, then ===> Map DeclType CDecl , where  DeclType = EnumT | StructT | FunctionT | ...
22:10:12 * mmorrow chooses not to sidetrack for now
22:14:45 <wli> Worse yet it doesn't do anything unless documentations specifically for docbook are done. If they weren't already using docbook there's nothing for it to do.
22:37:35 <ivanm> mmorrow: sidetrack! sidetrack!
22:56:18 <Raeb> Anyone home, or is everyone lurking?
22:56:26 <Raeb> Just curious.
22:56:52 <dolio> I'm lurking.
22:59:16 <wli> I'm still foundering on how to do primitive value case statements.
23:01:31 <ivanm> wli: "primitive value"?
23:01:38 <ivanm> you mean as in Int#, etc.?
23:02:10 <wli> ivanm: Similar to such in GHC's scheme. Primitive values as opposed to algebraic data types etc.
23:03:07 <wli> ivanm: I guess univ. algebra would call it a ground type vs. a product or coproduct of things.
23:09:00 <NameAlreadyInUse> why are LL parsers supposed to be so much easier to hand write than LR parsers?
23:09:28 <edwardk> hrmm. it seems that my toy incremental utf8 parsing monoid fails to be a monoid when given invalid inputs. one thought that if it just goes into 'fail' mode when it encounters an invalid char i can make it happy
23:09:59 <wli> NameAlreadyInUse: I know of no methods other than working out the LR state machines for hand writing LR parsers.
23:10:10 <edwardk> in general parsing front to back and back to front find errors at different spots in the file, when an error is present
23:11:08 <wli> NameAlreadyInUse: There may be some useful method for doing so of which I'm unaware.
23:12:07 <wli> edwardk: I figured out some neat stuff about practical usage of LR parsers in various places just recently but it's too far back in my queue to do anything with.
23:12:09 <NameAlreadyInUse> edward: is any particular method better for error handling? i have seen people say that LL is better for error handling, but i've also seen people say the same about LR
23:12:31 <wli> NameAlreadyInUse: LR flags errors far earlier than LL.
23:13:08 <edwardk> LL is easier to think through for most people, because they can think through recursive descent
23:13:36 <NameAlreadyInUse> wli: you can build a recursive ascent parser that is LR, which might be easier to hand write than a state machine
23:14:04 <wli> edwardk: The first thing I figured out was about fixity decls and multistage parsing. You don't need an LBA to handle it; you can just generalize first and follow sets to include nonterminals so when you hit a nonterminal in the midst of an input stream from a prior partial parse you can keep going.
23:14:18 <NameAlreadyInUse> wli: i am not sure though, i have never written a non-trivial parser
23:15:53 <edwardk> i never liked haskell fixity decls =/
23:16:00 <wli> edwardk: The next one was that you can use the nonterminals on the stack to do what zsh does wrt. smoking out the nested constructs in partially-entered input.
23:16:22 <wli> edwardk: ML fixity decls are nicer in that they don't have the lexical restrictions.
23:16:32 <boyscared> @quote xahlee
23:16:32 <lambdabot> xahlee says: The Haskell Logo is the perfection of logos
23:16:52 <NameAlreadyInUse> has the new logo been selected?
23:17:26 <edwardk> hrmm. i guess the incremental parser wouldn't be too bad, to say that it can tell you if its ok to parse monoidally or if you need to do a left to right pass over a section to get the errors right.
23:17:50 <wli> edwardk: For LR parsers you can just stop and resume the state machine.
23:18:07 <wli> edwardk: And examine its state, which is of observable type.
23:18:16 <wli> Crucial, though, is 0 lookahead.
23:18:39 <edwardk> wli: yes, but its hard to hold onto tails of state machines. you can memoize tails but its not quite the same ;)
23:19:01 <edwardk> this lets me parse the whole file into a fingertree, then change something in the middle and keep the splices at the head AND the tail for the most part
23:19:36 <edwardk> i put together a fie position monoid a few hours ago that works even in that hostile environment, and started writing a utf8 parser that also works there
23:19:39 <wli> I don't understand that to the point it may as well have been another language.
23:19:52 <edwardk> lemme find the hpaste
23:20:08 <edwardk> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2626
23:20:42 <wli> wtf. is a tail of a state machine?
23:20:45 <edwardk> so if you parse a file and use that to track positions in the file, it maintains positions over 'snippets' of code. usually as relative positions.
23:20:56 <edwardk> you can glue together snippets using the monoid
23:21:40 <edwardk> an LR parser still has shifts and reduces to do, so you can 'save the state' at a given point in the file, but if i inserted 20 bytes at that position, i'd still have to reparse all the way to the end.
23:22:15 <edwardk> i can't keep the 'tail of the machine' after the 20 bytes i had inserted and just glue it back on
23:23:45 <edwardk> i can also lex into words using a monoid, so tokenization works in this setting, the hairiest thing i have to deal with is figuring out a monoid for layout
23:24:27 <wli> I'm still not quite getting it.
23:24:28 <edwardk> that part looks like it'll be a monoid of functions that take a layout stack and return a layout stack.
23:25:12 <edwardk> what happens when you start up a shiny new lr parser in the middle of a file?
23:25:30 <edwardk> it can only munch forward, right?
23:26:13 <sjanssen> edwardk: have you seen the recent Yi paper on this?
23:26:14 <wli> That sounds like linear-bounded automata.
23:26:31 <edwardk> sjanssen: yeah, they have slightly different goals than i do, but neat stuff
23:28:42 <edwardk> sjanssen: i'm trying to avoid the heuristic search stuff they need
23:29:22 <edwardk> mainly because i want to use this in the parser for the language itself
23:30:11 <wli> edwardk: Nonsequential parsing is a whole different class of algorithms.
23:30:25 <Gracenotes> is an expression outputted by @pl idempotent with respect to trying to @pl it again?
23:31:14 <edwardk> my current goal is to make the lexer fully monoidal and do utf8 parsing, location calculations and lexeme splitting that way. strangely that permits it to be done in parallel by dicing up the file
23:32:25 <sjanssen> Gracenotes: @pl has no nice properties
23:32:41 <sjanssen> though I bet it is idempotent in most cases
23:32:43 <kohwj> is stuff in the where clause lazily evaluated?
23:32:53 <wli> edwardk: I'm not sure how dicing up the file would work apart from LBA's.
23:32:57 <edwardk> i did find it neat that the position monoid worked out so cleanly. all i need is a monoidal-regex for finding #line directives and to wire it up so that it over rides the position when it matches
23:33:02 <sjanssen> kohwj: yes
23:33:05 <Gracenotes> sjanssen: yeah. Not so much a mathematical proof as wondering if there's a counterexample
23:34:35 <edwardk> wli: did you see http://blog.sigfpe.com/2009/01/fast-incremental-regular-expression.html and the followup?
23:34:56 <wli> edwardk: No.
23:35:36 <Gracenotes> interesting, the similarities between @pl output and a stack-oriented language. they're both applicative, I guess..
23:35:47 <edwardk> wli: or as a mental exercise try to figure out how you'd split a huge file into words in parallel, even when words can straddle the boundaries of your slices.
23:35:54 <kohwj> sjanssen: thanks
23:36:47 <edwardk> wli: that can be done just by defining an appropriate monoid
23:37:16 <wli> sigfpe mostly ends up losing me on most of his posts.
23:38:11 <wli> He lost me in that one, too.
23:39:01 <edwardk> wli: lets walk through a word splitting/tokenizing monoid. you can have a chunk of word that you don't know if its connected on either side to a bigger mass of word or you can have a segment of words with chunks of potentially unfinished words on either side
23:39:49 <dons> edwardk: so don't we split. align chunk boundaries. process?
23:40:19 <edwardk> nah, in this case, split, take the splits as they lie and clean up the ends in the monoid
23:41:18 <wli> edwardk: I don't have any concrete idea of how derivations would get done if you partition and work "in parallel" on partitions and reunify partitions, essentially because the choices of how to partition are the bad part there.
23:41:25 <Gracenotes> hm. if stack-oriented oriented isn't applicative, what is it? :\
23:41:50 <edwardk> partition arbitrarily, make the system correct for any partition schema, then partition if/when it makes sense
23:43:28 <wli> There are all sorts of bracketing tokens you can scan around for as generalizations of matching parentheses.
23:43:44 <wli> Maybe those would be meaningful partitioning schemes.
23:44:26 <edwardk> sure, and those make good simplification points for the value in the monoid, but the monoid needs to be able to hold any run of characters from the file meaningfully
23:45:55 <edwardk> @hpaste
23:45:55 <lambdabot> Haskell pastebin: http://hpaste.org/new
23:46:39 <edwardk> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2629#a2629 assuming i didn't make a typo
23:46:42 <edwardk> should encapsulate the idea
23:48:21 <edwardk> then just feed chars to it through 'Chunk . return
23:48:22 <aye_I_ken_the_wy> wow haskell looks cool
23:48:28 <wli> About all I can see doing that is an LBA that just carries out derivations wherever it can and halts instead of signalling errors.
23:48:36 <aye_I_ken_the_wy> is it as easy to learn as say python or something?
23:49:07 <wli> Or, if not halting per se, returns to a calling context when it's no longer possible to carry out derivations.
23:49:11 <edwardk> aye_I_ken_the_wy: i think so, you can get up and running with haskell pretty quick. what i like about it is that the rabbit hole goes pretty deep
23:49:12 <aye_I_ken_the_wy> has anyone done as DNS server in haskell?
23:49:31 <aye_I_ken_the_wy> follow the white rabbit!
23:51:35 <edwardk> wli: a linear bounded automaton is one thing you can use, but it isn't the only one
23:52:00 <wli> edwardk: What other kind of machine does derivations all over its input stream?
23:53:54 <edwardk> well, there is always moving up to a turing machine ;)
23:54:04 <aye_I_ken_the_wy> http://www.newartisans.com/2009/03/journey-into-haskell-part-1.html
23:54:11 <sjanssen> aye_I_ken_the_wy: actually, I think there was a DNS server in Haskell
23:54:20 <sjanssen> perhaps two?  IIRC, HAppS had one
23:55:42 <sjanssen> edwardk: so do you think future compilers will be using multiple cores to parse our source files?
23:56:20 <edwardk> sjanssen: probably not ;)
23:56:47 <edwardk> i'm mostly just enjoying the puzzle and it should lead to low latency syntax highlighting/reparsing
23:57:03 <edwardk> because i can stick the result into a fingertree and forget about it and just do incremental inserts/deletes
23:57:05 <aye_I_ken_the_wy> oh is the happs one not a stub resolver but a real dns?
23:57:06 <aye_I_ken_the_wy> woa
23:57:16 <aye_I_ken_the_wy> I saw a python dns server today
23:58:04 <sjanssen> edwardk: fingertree is so much fun
23:58:23 <aye_I_ken_the_wy> http://www.digitallumber.net/oak/
23:58:46 <wli> edwardk: Are you talking about the problem of adjusting parsing structures in the presence of modifications of the input?
23:59:17 <edwardk> sjanssen: i keep playing with how to make a nice general purpose monoidal lexer. you can smash together regexps for your tokens to get a bigger dfa, and you can run a dfa as a monoid, i currently don't need something that general purpose but it'd be a nice tool to have in the toolchest
23:59:20 <edwardk> wli: yeah
23:59:46 <wli> edwardk: Okay, now I have a better idea of where all these things come in.
23:59:48 <edwardk> wli: which drops out for free in this setting. i can already do it for line numbers and for a simple word tokenizer
